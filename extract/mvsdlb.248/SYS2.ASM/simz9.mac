         TITLE 'z9 Series Instruction Simulator'
*
*        Function -
*        SIMZ9 is an interrupt exit routine (SPIE) for Operation
*        Exceptions (0C1). It was originally written by Don
*        Higgins to simulate the new 370 opcodes used in programs
*        running on the previous generation 360 hardware. The
*        module has now been rewritten to simulate a range of new
*        opcodes made available on z9 and later series
*        hardware.
*
*        Operation -
*        For a program to use the new z9 series opcodes the
*        program issues a SPIE SVC to identify SIMZ9 to
*        process 0C1 interrupts. If the opcode causing the
*        interrupt is one that is simulated by this module then
*        the simulation operation is carried out and this exit
*        routine returns control to the program. If it is a
*        genuine 0C1 then the PICA is nulled and the failing
*        Opcode is set for retry resulting in a 0C1 Abend.
*
*        Examples -
*        For examples of how to set up the environment to use
*        the simulated z9 Opcodes see members TESTZ9 and RUNZ9.
*
*        Installation -
*        SIMZ9 must be placed in the STEPLIB or STEPLIB
*        concatenation of any program that uses the simulated
*        Opcodes. Alternatively, for general use, SIMZ9 may be
*        placed in a LNKLSTed library. No Authorization is
*        required for SIMZ9.
*
*        Assembler Environment -
*        This module requires the HLASM or the Tachyon Legacy
*        Assembler for successful assembly.
*
*        Original Author:
*        PROGRAM.  GU022800.
*        AUTHOR.   DON HIGGINS.
*        DATE.     05/28/73.
*        REMARKS.  LOAD AND EXECUTE THE PROGRAM NAMED IN THE
*                  PARM FIELD USING A SPIE ROUTINE TO TRAP
*                  AND SIMULATE 370 INSTRUCTIONS WHICH CAN BE
*                  REPRESENTED BY MULTIPLE 360 INSTRUCTIONS.
*
*        Reference:
*        SA22-7832-05 z/Architecture - Principles of Operation
*
*        Supported Op Codes for simulation :-
*
*                  AFI       Add Immediate
*                  AHI       Add Halfword Immediate
*                  ALFI      Add Logical immediate
*                  BASSM     Branch and Save and Set Mode
*                  BRAS      Branch Relative and Save
*                  BRASL     Branch Relative and Save Long
*                  BRC       Branch Relative on Condition
*                  BRCL      Branch Relative on Condition Long
*                  BRCT      Branch Relative on Count
*                  BSM       Branch and Set Mode
*                  NILF      And Immediate
*                  NILH      And immediate
*                  NILL      And Immediate
*                  CFI       Compare Immediate
*                  CHI       Compare Halfword Immediate
*                  CKSM      Checksum
*                  CLFI      Compare Logical Immediate
*                  XILF      Exclusive Or Immediate
*                  IILF      Insert Immediate
*                  IILH      Insert Immediate
*                  IILL      Insert Immediate
*                  IPM       Insert Program Mask
*                  LARL      Load Address Relative Long
*                  LB        Load Byte
*                  LBR       Load Byte
*                  LHI       Load Halfword Immediate
*                  LLC       Load Logical Character
*                  LLCR      Load Logical Character
*                  LLH       Load Logical Halfword
*                  LLHR      Load Logical Halfword
*                  LLILF     Load Logical Immediate
*                  LLILH     Load Logical Immediate
*                  LLILL     Load Logical Immediate
*                  LT        Load and Test
*                  LRV       Load Reversed
*                  LRVH      Load Reversed Halfword
*                  OILF      Or Immediate
*                  OILH      Or Immediate
*                  OILL      Or Immediate
*                  SAM24     Set Addressing Mode - 24 bit Addr
*                  SAM31     Set Addressing Mode - 31 bit Addr
*                  STRV      Store Reversed
*                  STRVH     Store Reversed Halfword
*                  TAM       Test Addressing Mode
*                  TMLH      Test Under Mask High
*                  TMLL      Test Under mask Low
*                  TP        Test Decimal
*                  TRTR      Translate and Test Reverse
*                  TRE       Translate Extended
*                  TROO      Translate One to One (ETF2 installed)
*                  TROT      Translate One to Two (ETF2 installed)
*                  TRTO      Translate Two to One (ETF2 installed)
*                  TRTT      Translate Two to Two (ETF2 installed)
*
*        Registers on Entry to SPIE Routine
*
*        R0  - Internal Control Program Use - Do Not Use
*        R1  - Addr of PIE
*        R2  - Interrupting Programs Register - Updated
*        R3  - Interrupting Programs Register - Updated
*        R4  - Interrupting Programs Register - Updated
*        R5  - Interrupting Programs Register - Updated
*        R6  - Interrupting Programs Register - Updated
*        R7  - Interrupting Programs Register - Updated
*        R8  - Interrupting Programs Register - Updated
*        R9  - Interrupting Programs Register - Updated
*        R10 - Interrupting Programs Register - Updated
*        R11 - Interrupting Programs Register - Updated
*        R12 - Interrupting Programs Register - Updated
*        R13 - Interrupting Programs SAVEAREA - Do Not Use
*        R14 - Return Addr to Control program
*        R15 - Address of this Routine
*
***********************************************************************
*                                                                     *
*        Internal Macro Definitions                                   *
*                                                                     *
***********************************************************************
*
*
*        SETCC - SET PIEPSW CONDITION CODE BITS
*
         MACRO
&N       SETCC &CC
         LCLA  &CCLEN
         LCLC  &CCREG
         AIF   ('&CC' EQ 'CC0').CC0
         AIF   ('&CC' EQ 'CC1').CC1
         AIF   ('&CC' EQ 'CC2').CC2
         AIF   ('&CC' EQ 'CC3').CC3
.*
.*       Test for the CC in a Register as a result of a BALR
.*
&CCLEN   SETA  K'&CC
         AIF   (('&CC'(1,1) EQ '(') AND ('&CC'(&CCLEN,1) EQ ')')).REGCC
         MNOTE 8,'INVALID CONDITION CODE'
         MEXIT
.REGCC   ANOP
&CCREG   SETC  '&CC'(2,&CCLEN-2)       Remove brackets
&N       ZEROB PIEPSW+4,(2,3)          Zero CC bits in PSW
         N     &CCREG,CCMASK           Zero all but CC bits in Reg
         O     &CCREG,PIEPSW+4         OR PSW into Register
         ST    &CCREG,PIEPSW+4         Store Updated PSW with CC set
         MEXIT
.CC0     ANOP
&N       ZEROB PIEPSW+4,(2,3)
         MEXIT
.CC1     ANOP
&N       ZEROB PIEPSW+4,(2)
         SETBIT PIEPSW+4,(3)
         MEXIT
.CC2     ANOP
&N       SETBIT PIEPSW+4,(2)
         ZEROB PIEPSW+4,(3)
         MEXIT
.CC3     ANOP
&N       SETBIT PIEPSW+4,(2,3)
         MEND
*
*        RS1 - OBTAIN R1 AND S2 ADDR FOR RS INS
*
*        Not used in this version but could be useful for
*        other Opcodes
*
         MACRO
         RS1
         SR    R8,R8
         IC    R8,1(,R2)
         SRL   R8,4
         SLL   R8,2
         LA    R8,PGMREGS(R8)      R8=A(R1)
         LH    R10,2(,R2)
         TESTB 2(R2),(0,1,2,3)     TEST FOR ABSOLUTE ADDRESS
         BZ    *+26
         LR    R11,R10
         N     R11,=X'00000FFF'
         N     R10,=X'0000F000'
         SRL   R10,10
         L     R10,PGMREGS(R10)
         LA    R10,0(R11,R10)      R10=A(D2B2)
         MEND
*
*        RS2 -
*        Obtain Rx and Operand Address (with Index Register)
*
         MACRO
         RS2
         SR    R6,R6
         IC    R6,1(,R2)           Get Rx and Index Register
         LR    R7,R6               Take a copy
         SRL   R6,4                R6 now has Rx in right most nibble
         SLL   R6,2                Convert into offset for PGMREGS
         LA    R6,PGMREGS(R6)      R6 - > Rx
         N     R7,=X'0000000F'     R7 now has Index Register only
         SLA   R7,2                Convert into offset for PGMREGS
         BZ    *+8                 Branch if R0 was coded as Index Reg
         L     R7,PGMREGS(R7)      R7 now has value of Index Reg
         SR    R8,R8
         IC    R8,2(,R2)           Get Base Reg and high order nibble
*                                  of displacement
         SRL   R8,4                Shift out displacement nibble
         SLA   R8,2                Convert to offset into PGMREGS
         BZ    *+8                 Branch if R0 used as Base Reg
         L     R8,PGMREGS(R8)      R8 now has value of Base Reg
         ICM   R9,B'0011',2(R2)    Get Base Reg and 12 bit Displacement
         N     R9,=X'00000FFF'     R9 now has displacement only
         LA    R5,0(R7,R8)         Add Index and Base registers
         LA    R5,0(R5,R9)         Add Displacement
.*
.*       Exit with R6 -> Rx and operand addr in R5
.*
         MEND
*
*        RS2X -
*        Obtain Rx and Operand Address (with Index Register) and
*        extended displacement DH and DL (20 bit) addressing
*
         MACRO
         RS2X
         SR    R6,R6
         IC    R6,1(,R2)           Get Rx and Index Register
         LR    R7,R6               Take a copy
         SRL   R6,4                R6 now has Rx in right most nibble
         SLL   R6,2                Convert into offset for PGMREGS
         LA    R6,PGMREGS(R6)      R6 - > Rx
         N     R7,=X'0000000F'     R7 now has Index Register only
         SLA   R7,2                Convert into offset for PGMREGS
         BZ    *+8                 Branch if R0 was coded as Index Reg
         L     R7,PGMREGS(R7)      R7 now has value of Index Reg
         SR    R8,R8
         IC    R8,2(,R2)           Get Base Reg and high order nibble
*                                  of displacement
         SRL   R8,4                Shift out displacement nibble
         SLA   R8,2                Convert to offset into PGMREGS
         BZ    *+8                 Branch if R0 used as Base Reg
         L     R8,PGMREGS(R8)      R8 now has value of Base Reg
         ICM   R9,B'0011',2(R2)    Get Base Reg and 12 bit Displacement
         N     R9,=XL4'00000FFF'   R9 now has 12 bit displacement only
         SR    R5,R5
         ICM   R5,B'0100',4(R2)    Get DH (signed) and set CC
         SRL   R5,4                Shift DH right one nibble to
*                                  align with 12 bit DL
         BNM   *+8                 DH not negative, Branch
         O     R5,=XL4'FFF00000'   Propagate Negative Sign
         OR    R5,R9               R5 now has DH and DL (signed)
*                                  in low order 20 bits
         LA    R7,0(R7,R8)         Add Base and Index Registers
         AR    R5,R7               Add to signed DH DL displacement
.*
.*       Exit with R6 -> Rx and operand addr in R5
.*
         MEND
*
*        BASEDIS Resolve Base Register and Displacement Addr
*
         MACRO
         BASEDIS &RABD,&RTADDR
.*
.*       Resolve Base and Displacement Addr pointed to by RABD
.*       into RTADDR
.*
         SR    &RTADDR,&RTADDR     Clear Result Register
         IC    &RTADDR,0(,&RABD)   Get Base Reg and high order nibble
         SRL   &RTADDR,4           Shift out displacement nibble
         SLA   &RTADDR,2           Convert to offset into PGMREGS
         BZ    *+8                 Branch if R0 used as Base Reg
         L     &RTADDR,PGMREGS(&RTADDR) Now has value of Base Reg
         ICM   R3,B'0011',0(&RABD) Get Base Reg and 12 bit Displacement
         N     R3,=X'00000FFF'     R3 now has displacement only
         LA    &RTADDR,0(&RTADDR,R3) Add Displacement
         MEND
*
*        BUILD INDEX TABLES FOR SPIE ROUTINE
*
         MACRO
         INSTAB
         LCLA  &S,&T,&I
&T       SETA  N'&SYSLIST
INSTAB   DC    256X'00'
&S       SETA  1
.LHEX    ANOP
&I       SETA  &I+4
         ORG   INSTAB+&SYSLIST(&S)
         DC    AL1(&I)
&S       SETA  &S+2
         AIF   (&S LT &T).LHEX
&S       SETA  2
         ORG
RTNTAB   DC    A(INVOP)
.LAD     ANOP
         DC    A(&SYSLIST(&S))
&S       SETA  &S+2
         AIF   (&S LE &T).LAD
         MEND
*
*        TESTB
*
         MACRO
&N       TESTB &FIELD,&BITS
         LCLA  &NBITS,&B(8),&S
&NBITS   SETA  N'&BITS
         AIF   (&NBITS LT 1).ERR
         AIF   (&NBITS GT 8).ERR
.LOOP    ANOP
&S       SETA  &BITS(&NBITS)
         AIF   (&S LT 0).ERR
         AIF   (&S GT 7).ERR
&B(&S+1) SETA  1
&NBITS   SETA  &NBITS-1
         AIF   (&NBITS GT 0).LOOP
&N       TM    &FIELD,B'&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)'
         MEXIT
.ERR     MNOTE 8,'INVALID BIT SPECIFICATION'
         MEND
*
*        SETBIT
*
         MACRO
&N       SETBIT &FIELD,&BITS
         LCLA  &NBITS,&B(8),&S
&NBITS   SETA  N'&BITS
         AIF   (&NBITS LT 1).ERR
         AIF   (&NBITS GT 8).ERR
.LOOP    ANOP
&S       SETA  &BITS(&NBITS)
         AIF   (&S LT 0).ERR
         AIF   (&S GT 7).ERR
&B(&S+1) SETA  1
&NBITS   SETA  &NBITS-1
         AIF   (&NBITS GT 0).LOOP
&N       OI    &FIELD,B'&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)'
         MEXIT
.ERR     MNOTE 8,'INVALID BIT SPECIFICATION'
         MEND
*
*        ZEROB
*
*
         MACRO
&N       ZEROB &FIELD,&BITS
         LCLA  &NBITS,&B(8),&S
&NBITS   SETA  N'&BITS
         AIF   (&NBITS LT 1).ERR
         AIF   (&NBITS GT 8).ERR
.LOOP    ANOP
&S       SETA  &BITS(&NBITS)
         AIF   (&S LT 0).ERR
         AIF   (&S GT 7).ERR
&B(&S+1) SETA  1
&NBITS   SETA  &NBITS-1
         AIF   (&NBITS GT 0).LOOP
&N       NI    &FIELD,X'FF'-B'&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)'
         MEXIT
.ERR     MNOTE 8,'INVALID BIT SPECIFICATION'
         MEND
*
***********************************************************************
*                                                                     *
*        SPIE ROUTINE USED TO TRAP OPERATION EXCEPTIONS               *
*                                                                     *
***********************************************************************
*
SIMZ9    CSECT
         USING SIMZ9,R15
         USING PIE,R1
         MODULEID ,                Generate eyecatcher
*
*        Make PGMREGS contiguous R0 - R15 from interrupting program
*
         MVC   PGMREGS(12),PIEGR0  Move R0, R1 and R2 into PGMREGS
         STM   R3,R13,PGMREGS+12   Store R3 - R13 into PGMREGS
         MVC   PGMREGS+56(8),PIEGR14 Move R14 - R15 into PGMREGS
*
         MVC   PGMPSW,PIEPSW       Copy PSW from PIE
         L     R2,PIEPSW+4         R2 = Program Interrupt PSW + 4
*                                  ie  ILC, CC, PGM MASK and Ins. Addr
         LR    R3,R2
         SRL   R3,30               Shift the ILC to the Right most bits
         SLL   R3,1                Convert ILC to byte value from
*                                  half word value
         LA    R2,0(,R2)           Clean out ILC, CC and PGMMASK
         SR    R2,R3               Subtract length of instruction to
*                                  calc addr of opcode so that :-
*                                  R2 - > Opcode
         LR    R10,R2              Take a copy of the Opcode Addr
*                                  for use with Relative Instructions
         LR    R11,R2              and a copy for INVOP routine
         MVI   EX_FLAG,X'00'       Clear EX_FLAG
*
EX_REDRIVE EQU *                   Redrive simulation after finding
*                                  0C1 was caused by EX target opcode
*
         LR    R4,R3               Copy ILC in bytes
         BCTR  R4,0                Decrement for EX
         EX    R4,EX_MVCOP         Move the 2, 4 or 6 byte op code
*                                  into PGMOPCDE
         LA    R2,PGMOPCDE         Use PGMOPCDE instead of actual
*                                  OPcode in the interrupting program
         TM    EX_FLAG,EX_MODE     EX Mode ?
         BNO   NOTEXINS            No, bypass OR Ins
         OC    PGMOPCDE+1(1),3(R6) OR Second byte of Opcode with
*                                  Low Order byte of Rx from Ex Opcode
NOTEXINS EQU   *
         IC    R3,0(,R2)           Insert Opcode into low order byte
*                                  Look up tables to select routine
         IC    R3,INSTAB(R3)       R3 = Offset to OpCode Routine
         L     R3,RTNTAB(R3)       R3 now has addr of OpCode Routine
         BR    R3                  Branch to Opcode Simulation Routine
*
EX_MVCOP MVC   PGMOPCDE(0),0(R2)   Move Opcode to PGMOPCDE
*
*
EXIT1    EQU   *
         MVC   PIEGR0(12),PGMREGS  Restore Programs Registers
         MVC   PIEGR14(8),PGMREGS+56
EXIT2    EQU   *
         LM    R3,R13,PGMREGS+12
         BR    R14
*
        INSTAB X'01',Z1INS,                                            X
               X'0B',BSMINS,           Single Instruction              X
               X'0C',BASSMINS,         Single Instruction              X
               X'44',EXINS,            Single Instruction              X
               X'A5',A5INS,                                            X
               X'A7',A7INS,                                            X
               X'B2',B2INS,                                            X
               X'B9',B9INS,                                            X
               X'C0',C0INS,                                            X
               X'C2',C2INS,                                            X
               X'D0',TRTRINS,          Single Instruction              X
               X'E3',E3INS,                                            X
               X'EB',TPINS             Single Instruction
*
*        01 OPCODE VALIDATION
*
Z1INS    EQU   *
         CLI   1(R2),X'0B'         TAM Opcode ?
         BE    SIM_TAM             Yes, go simulate
         CLI   1(R2),X'0C'         SAM24 Opcode ?
         BE    SIM_SAM24           Yes, go simulate
         CLI   1(R2),X'0D'         SAM31 Opcode ?
         BE    SIM_SAM31           Yes, go simulate
         B     INVOP               All others not supported
*
*        BSM - OPCODE 0B
*
*        BSM Rx,Ry
*        The basic addressing mode bit is set in Rx according to
*        the current addressing mode except if Rx is R0. The
*        contents of Ry become the new PSW Ins. Addr unless Ry is
*        R0.
*        CC: Unaltered
*
BSMINS   EQU   *
         SR    R7,R7
         IC    R7,1(,R2)           Get Rx and Ry
         LR    R4,R7               Take a copy
         SRA   R7,4                Move Rx into right most nibble
         BZ    BSMINSA             Branch if Rx is R0
         SLA   R7,2                Multiply by four
         LA    R7,PGMREGS(R7)      R7 - > Register value
         NI    0(R7),X'7F'         Ensure sign bit is zero
BSMINSA  EQU   *
         N     R4,=XL4'0000000F'   Get Ry
         BZ    EXIT1               Branch if Ry is R0
         SLA   R4,2                Multiply by four
         L     R4,PGMREGS(R4)      Load register value
         STCM  R4,B'0111',PIEPSW+5 Update Instruction Addr in PSW
         B     EXIT1
*
*        BASSM - OPCODE 0C
*
*        BASSM Rx,Ry
*        The current PSW Ins. Addr is stored in Rx. The contents
*        of Ry become the new PSW Ins. Addr unless Ry is R0.
*        CC: Unaltered
*
BASSMINS EQU   *
         SR    R7,R7
         IC    R7,1(,R2)           Get Rx and Ry
         LR    R4,R7               Take a copy
         SRA   R7,4                Move Rx into right most nibble
         SLA   R7,2                Convert to offset into PGMREGS
         LA    R7,PGMREGS(R7)      R7 -> Rx
         L     R5,PIEPSW+4         Save PSW Instruction Addr
         N     R4,=XL4'0000000F'   Get Ry
         BZ    BASSMINX            If Ry is R0, then leave R0 as is
         SLA   R4,2                Multiply by four
         L     R4,PGMREGS(R4)      Load register value
         STCM  R4,B'0111',PIEPSW+5 Update Instruction Addr in PSW
BASSMINX EQU   *
         MVI   0(R7),X'00'         Zero hi-order byte of Rx
         STCM  R5,B'0111',1(R7)    Move PSW Ins. Addr into Rx
         B     EXIT1
*
*        EX - OPCODE 44
*
*        EX    Rx,D2(X2,B2)
*        The target opcode is executed after the low order byte
*        in Rx is ORed into the second byte of the target opcode.
*        CC: As set by target opcode
*
*        Note:
*        EX will not cause an 0C1 but the target of an EX may
*        cause an 0C1 with the PSW pointing at the next
*        instruction after the EX - not the opcode causing the 0C1.
*        The target of the EX is the opcode that caused the 0C1.
*        Locate the target opcode and redrive the simuation code
*        using the target opcode.
*
EXINS    EQU   *
         RS2   ,                   Get Rx and Ex target addr
         SR    R3,R3
         IC    R3,0(,R5)           Get Target Op Code
         SRL   R3,6                Move ILC to rightmost two bits
         IC    R3,ILCLEN(R3)       Convert Opcode length bits
*                                  to Opcode length in bytes
         OI    EX_FLAG,EX_MODE     Turn on EX_Mode Flag
         LR    R2,R5               Target operand Addr now in R2
         LR    R10,R5              Update R10 in case Relative
*                                  Ins is the target of the EX
*                                  where the actual Ins addr is
*                                  needed to calc relative branch
         B     EX_REDRIVE          Go redrive opcode simulation with
*                                  EX target Opcode
*                                  R2 - Operand Addr
*                                  R3 - Instruction Len in bytes
*                                  R6 - > Rx
ILCLEN   DC    X'02040406'         Lookup table to convert Instruction
*                                  Length code in length of Opcode in
*                                  Bytes
*
*        A5 OPCODE VALIDATION
*
A5INS    EQU   *
         IC    R3,1(,R2)           Get Reg and sub opcode
         LR    R4,R3               Copy R3
         N     R4,=XL4'000000F0'   R4 now has specified Register
         SRL   R4,2                Convert to offset into PGMREGS
         LA    R4,PGMREGS(R4)      R4 - > Register value
         LA    R5,2(,R2)           R5 - > Immediate data
         N     R3,=XL4'0000000F'   R3 now has sub op code only
         SLL   R3,2                Multiply by 4 for branch table
         L     R3,A5TAB(R3)        Load opcode routine addr
         BR    R3                  Branch to individual A5 routine
*
A5TAB    DC    A(INVOP)            0 - IIHH Not supported
         DC    A(INVOP)            1 - IIHL Not Supported
         DC    A(SIM_IILH)         2 - IILH
         DC    A(SIM_IILL)         3 - IILL
         DC    A(INVOP)            4 - NIHH Not Supported
         DC    A(INVOP)            5 - NIHL Not Supported
         DC    A(SIM_NILH)         6 - NILH
         DC    A(SIM_NILL)         7 - NILL
         DC    A(INVOP)            8 - OIHH Not Supported
         DC    A(INVOP)            9 - OIHL Not Supported
         DC    A(SIM_OILH)         A - OILH
         DC    A(SIM_OILL)         B - OILL
         DC    A(INVOP)            C - LLIHH Not Supported
         DC    A(INVOP)            D - LLIHL Not Supported
         DC    A(SIM_LLILH)        E - LLILH
         DC    A(SIM_LLILL)        F - LLILL
*
*        A7 OPCODE VALIDATION
*
A7INS    EQU   *
         IC    R3,1(,R2)           Get Reg and sub opcode
         LR    R4,R3               Copy R3
         N     R4,=XL4'000000F0'   R4 now has specified Register
         SRL   R4,2                Convert to offset into PGMREGS
         LA    R4,PGMREGS(R4)      R4 - > Register value
         LA    R5,2(,R2)           R5 - > Immediate data
         N     R3,=XL4'0000000F'   R3 now has sub op code only
         SLL   R3,2                Multiply by 4 for branch table
         L     R3,A7TAB(R3)        Load opcode routine addr
         BR    R3                  Branch to individual A7 routine
*
A7TAB    DC    A(SIM_TMLH)         0 - TMLH and TMH
         DC    A(SIM_TMLL)         1 - TMLL and TML
         DC    A(INVOP)            2 - TMHH Not Supported
         DC    A(INVOP)            3 - TMHL Not Supported
         DC    A(SIM_BRC)          4 - BRC
         DC    A(SIM_BRAS)         5 - BRAS
         DC    A(SIM_BRCT)         6 - BRCT
         DC    A(INVOP)            7 - BRCTG Not Supported
         DC    A(SIM_LHI)          8 - LHI
         DC    A(INVOP)            9 - LGHI Not Supported
         DC    A(SIM_AHI)          A - AHI
         DC    A(INVOP)            B - AGHI Not Supported
         DC    A(SIM_MHI)          C - MHI
         DC    A(INVOP)            D - MGHI Not Supported
         DC    A(SIM_CHI)          E - CHI
         DC    A(INVOP)            F - CGHI Not Supported
*
*        B2 OPCODE VALIDATION
*
*        Supported:-  CKSM
*                     IPM
*                     TRE
*
B2INS    EQU   *
         IC    R4,3(,R2)           Get Registers
         LR    R5,R4               Copy R4
         N     R4,=XL4'000000F0'   R4 now has First Register
         SRL   R4,2                Convert to offset into PGMREGS
         LA    R4,PGMREGS(R4)      R4 - > First Register
         N     R5,=X'0000000F'     R5 now has Second Register
         SLL   R5,2                Convert to offset into PGMREGS
         LA    R5,PGMREGS(R5)      R5 - > Second Register
*
         CLI   1(R2),X'41'         CKSM Opcode ?
         BE    SIM_CKSM
         CLI   1(R2),X'22'         IPM Opcode ?
         BE    SIM_IPM
         CLI   1(R2),X'A5'         TRE Opcode ?
         BE    SIM_TRE
         B     INVOP               All others not supported
*
*
*        B9 OPCODE VALIDATION
*
*        Supported:-  LBR
*                     LLCR
*                     LLHR
*                     TRTT
*                     TRTO
*                     TROT
*                     TRTT
*
B9INS    EQU   *
         IC    R4,3(,R2)           Get First and Second Register
         LR    R5,R4               Copy R4
         N     R4,=XL4'000000F0'   R4 now has First Register only
         SRL   R4,2                Convert to offset into PGMREGS
         LA    R4,PGMREGS(R4)      R4 - > First Register value
         N     R5,=XL4'0000000F'   R5 has second Register only
         SLL   R5,2                Convert to offset into PGMREGS
         LA    R5,PGMREGS(R5)      R5 - > Second Register value
*
         CLI   1(R2),X'26'         LBR Opcode ?
         BE    SIM_LBR
         CLI   1(R2),X'90'         TRTT Opcode ?
         BE    SIM_TRTT
         CLI   1(R2),X'91'         TRTO Opcode ?
         BE    SIM_TRTO
         CLI   1(R2),X'92'         TROT Opcode ?
         BE    SIM_TROT
         CLI   1(R2),X'93'         TROO Opcode ?
         BE    SIM_TROO
         CLI   1(R2),X'94'         LLCR Opcode ?
         BE    SIM_LLCR
         CLI   1(R2),X'95'         LLHR Opcode ?
         BE    SIM_LLHR
         B     INVOP               All others not supported
*
*        C0 OPCODE VALIDATION
*
C0INS    EQU   *
         IC    R3,1(,R2)           Get Reg and sub opcode
         LR    R4,R3               Copy R3
         N     R4,=XL4'000000F0'   R4 now has specified Register
         SRL   R4,2                Convert to offset into PGMREGS
         LA    R4,PGMREGS(R4)      R4 - > Register value
         LA    R5,2(,R2)           R5 - > Immediate data
         N     R3,=XL4'0000000F'   R3 now has sub op code only
         SLL   R3,2                Multiply by 4 for branch table
         L     R3,C0TAB(R3)        Load opcode routine addr
         BR    R3                  Branch to individual C0 routine
*
C0TAB    DC    A(SIM_LARL)         0 - LARL
         DC    A(INVOP)            1 - LGFI Not Supported
         DC    A(INVOP)            2 - Not Defined
         DC    A(INVOP)            3 - Not Defined
         DC    A(SIM_BRCL)         4 - BRCL
         DC    A(SIM_BRASL)        5 - BRASL
         DC    A(INVOP)            6 - XIHF Not Supported
         DC    A(SIM_XILF)         7 - XILF
         DC    A(INVOP)            8 - IIHF Not Supported
         DC    A(SIM_IILF)         9 - IILF
         DC    A(INVOP)            A - NIHF Not Supported
         DC    A(SIM_NILF)         B - NILF
         DC    A(INVOP)            C - OIHF Not Supported
         DC    A(SIM_OILF)         D - OILF
         DC    A(INVOP)            E - LLIHF Not Supported
         DC    A(SIM_LLILF)        F - LLILF
*
*        C2 OPCODE VALIDATION
*
C2INS    EQU   *
         IC    R3,1(,R2)           Get Reg and sub opcode
         LR    R4,R3               Copy R3
         N     R4,=XL4'000000F0'   R4 now has specified Register
         SRL   R4,2                Convert to offset into PGMREGS
         LA    R4,PGMREGS(R4)      R4 - > Register value
         LA    R5,2(,R2)           R5 - > Immediate data
         N     R3,=XL4'0000000F'   R3 now has sub op code only
         SLL   R3,2                Multiply by 4 for branch table
         L     R3,C2TAB(R3)        Load opcode routine addr
         BR    R3                  Branch to individual C2 routine
*
C2TAB    DC    A(INVOP)            0 - Not Defined
         DC    A(INVOP)            1 - Not Defined
         DC    A(INVOP)            2 - Not Defined
         DC    A(INVOP)            3 - Not Defined
         DC    A(INVOP)            4 - SLGFI Not Supported
         DC    A(SIM_SLFI)         5 - SLFI
         DC    A(INVOP)            6 - Not Defined
         DC    A(INVOP)            7 - Not Defined
         DC    A(INVOP)            8 - AGFI Not Supported
         DC    A(SIM_AFI)          9 - AFI
         DC    A(INVOP)            A - ALGFI Not Supported
         DC    A(SIM_ALFI)         B - ALFI
         DC    A(INVOP)            C - CGFI Not Supported
         DC    A(SIM_CFI)          D - CFI
         DC    A(INVOP)            E - CLGFI Not Supported
         DC    A(SIM_CLFI)         F - CLFI
*
*        E3 OPCODE VALIDATION
*
*        Supported:-  LT
*                     LRV
*                     LRVH
*                     STRV
*                     STRVH
*                     LB
*                     LLC
*                     LLH
*
E3INS    EQU   *
         RS2X  ,                   R6 -> Rx, R5 -> Second Operand
         CLI   5(R2),X'12'         LT Opcode ?
         BE    SIM_LT
         CLI   5(R2),X'1E'         LRV Opcode ?
         BE    SIM_LRV
         CLI   5(R2),X'1F'         LRVH Opcode ?
         BE    SIM_LRVH
         CLI   5(R2),X'3E'         STRV Opcode ?
         BE    SIM_STRV
         CLI   5(R2),X'3F'         STRVH Opcode ?
         BE    SIM_STRVH
         CLI   5(R2),X'76'         LB Opcode ?
         BE    SIM_LB
         CLI   5(R2),X'94'         LLC Opcode ?
         BE    SIM_LLC
         CLI   5(R2),X'95'         LLH Opcode ?
         BE    SIM_LLH
         B     INVOP               All others not supported
*
*        Invalid or Unsupported Operation Code
*
*        To enable standard debugging techniques for 0C1 back
*        off the PSW to cause a retry of the failing Opcode. Zero
*        out the PICA. This is a crude technique but MVS does not
*        allow the SPIE to be cancelled within a SPIE
*        environment. The result will be an 0C1 without the
*        complications of the SPIE code or control blocks.
*
INVOP    EQU   *
         STCM  R11,B'0111',PIEPSW+5 Set PSW Addr to retry the failing
*                                  Opcode and force an 0C1 abend
         L     R6,PIEPICA          Get Addr of PICA
         MVC   0(NULLSPIEL,R6),NULLSPIE Replace current PICA with
*                                  Null PICA
         B     EXIT1
*
INVREGS  EQU   *
         ABEND 1002,DUMP           INVALID REGISTER SPECIFICATIONS
*
***********************************************************************
*                                                                     *
*        Opcode Simulation Routines                                   *
*                                                                     *
***********************************************************************
*
*
*        TAM
*
*        TAM
*        Test Addressing Mode
*        CC: CC0 - 24 Bit Mode - only CC set
*            CC1 - 31 Bit Mode - not set
*            CC2 - --
*            CC3 - 64 Bit Mode - not set
*
SIM_TAM  EQU   *
         SETCC CC0                Set 24 Bit Mode only
         B     EXIT1
*
*        SAM24
*
*        SAM24
*        Set Addressing Mode to 24 Bit
*        CC: Unaltered
*
SIM_SAM24 EQU  *
         B     EXIT1              Effective No Op
*
*        SAM31
*
*        SAM31
*        Set Addressing Mode to 31 Bit
*        CC: Unaltered
*
SIM_SAM31 EQU  *
         B     EXIT1              Effective No Op
*
*        IILH
*
*        IILH  Rx,I16
*        Insert 16 bits into the hi-order 2 bytes of the Rx Register
*        CC: Unaltered
*
SIM_IILH EQU   *
         MVC   0(2,R4),0(R5)
         B     EXIT1
*
*        IILL
*
*        IILL  Rx,I16
*        Insert 16 bits into the low-order 2 bytes of the Rx Register
*        CC: Unaltered
*
SIM_IILL EQU   *
         MVC   2(2,R4),0(R5)
         B     EXIT1
*
*        NILH
*
*        NILH  Rx,I16
*        AND 16 bits into the hi-order 2 bytes of the Rx Register
*        CC: CC0 - Bits Zero
*            CC1 - Bits not Zero
*
SIM_NILH EQU   *
         NC    0(2,R4),0(R5)
         BALR  R9,R0                   Get CC after NC
         SETCC (R9)
         B     EXIT1
*
*        NILL
*
*        NILL  Rx,I16
*        AND 16 bits into the low-order 2 bytes of the Rx Register
*        CC: CC0 - Bits Zero
*            CC1 - Bits not Zero
*            CC2 - --
*            CC3 - --
*
SIM_NILL EQU   *
         NC    2(2,R4),0(R5)
         BALR  R9,R0                   Get CC after NC
         SETCC (R9)
         B     EXIT1
*
*        OILH
*
*        OILH  Rx,I16
*        OR 16 bits into the hi-order 2 bytes of the Rx Register
*        CC: CC0 - Bits Zero
*            CC1 - Bits not Zero
*            CC2 - --
*            CC3 - --
*
SIM_OILH EQU   *
         OC    0(2,R4),0(R5)
         BALR  R9,R0                   Get CC after OC
         SETCC (R9)
         B     EXIT1
*
*        OILL
*
*        OILL  Rx,I16
*        OR 16 bits into the low-order 2 bytes of the Rx Register
*        CC: CC0 - Bits Zero
*            CC1 - Bits not Zero
*            CC2 - --
*            CC3 - --
*
SIM_OILL EQU   *
         OC    2(2,R4),0(R5)
         BALR  R9,R0                   Get CC after OC
         SETCC (R9)
         B     EXIT1
*
*        LLILH
*
*        LLILH Rx,I16
*        Load Logical 16 bits into the hi-order 2 bytes of
*        the Rx Register zeroing the 2 low-order bytes
*        CC: Unaltered
*
SIM_LLILH EQU   *
         MVC   0(2,R4),0(R5)           Move hi-order two bytes
         XC    2(2,R4),2(R4)           Zero Low-order bytes
         B     EXIT1
*
*        LLILL
*
*        LLILL Rx,I16
*        Load Logical 16 bits into the low-order 2 bytes of
*        the Rx Register zeroing the 2 hi-order bytes.
*        CC: Unaltered
*
SIM_LLILL EQU   *
         MVC   2(2,R4),0(R5)           Move low-order two bytes
         XC    0(2,R4),0(R4)           Zero hi-order bytes
         B     EXIT1
*
*        TMH/TMLH
*
*        TMH   Rx,I16
*        The contents of the I16 field are used as a 16 Bit
*        mask to test the 16 hi-order bits in the Rx Register
*        CC: CC0 - Selected bits all zero
*            CC1 - Mixed bits but leftmost bit zero
*            CC2 - Mixed bits but leftmost bit one
*            CC3 - Selected bits all ones
*
*        Note:
*        Because CC1 and CC2 are set for a mixed result
*        depending on the value of the selected leftmost bit then
*        the extended mnemonics BM, BNM,BMR and BNMR are
*        effectively broken with this Opcode and should not be
*        used after this Opcode to test the CC for a mixed
*        result.
*
SIM_TMLH EQU   *
         IC    R8,0(,R5)               Get First mask byte
         EX    R8,EX_TMH               Execute a TM
         BALR  R2,R0                   Get resulting CC
         N     R2,CCMASK               Zero all except CC
         IC    R8,1(,R5)               Get second mask byte
         EX    R8,EX_TML               Execute a TM
         BALR  R3,R0                   Get resulting CC
         N     R3,CCMASK               Zero all except CC
         CR    R2,R3                   Both TM result in same CC ?
         BE    SIM_TMLHA               Yes, Branch
*
*        CC is not equal from the two TM instructions so before
*        forcing a mixed result test the two mask bytes for a
*        mask of zero. If the mask is zero then ignore the CC
*        setting for that TM instruction.
*
         CLI   0(R5),X'00'             Hiorder Mask Byte Zero ?
         BNE   SIM_TMLHE               No, Branch
*                                      Mask Zero found
         LR    R2,R3                   Overide Hi Order TM CC with
*                                      Low Order TM CC
         B     SIM_TMLHA               Process CC
*
SIM_TMLHE EQU  *
         CLI   1(R5),X'00'             Low Order Mask Byte Zero ?
         BE    SIM_TMLHA               Yes, ignore CC for TM
*
*        Process mixed result
*
*
*        For simplification and performance the bit testing loop
*        to find the leftmost bit being selected has been
*        'rolled out'.
*
SIM_TMLHC EQU  *
         LA    R6,2                    Set Loop Count
SIM_TMLH1 EQU  *                       Bit 1
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'10000000'
         BNO   SIM_TMLH2               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'10000000'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
*
SIM_TMLH2 EQU  *                       Bit 2
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'01000000'
         BNO   SIM_TMLH3               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'01000000'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
*
SIM_TMLH3 EQU  *                       Bit 3
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'00100000'
         BNO   SIM_TMLH4               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'00100000'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
*
SIM_TMLH4 EQU  *                       Bit 4
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'00010000'
         BNO   SIM_TMLH5               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'00010000'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
*
SIM_TMLH5 EQU  *                       Bit 5
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'00001000'
         BNO   SIM_TMLH6               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'00001000'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
*
SIM_TMLH6 EQU  *                       Bit 6
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'00000100'
         BNO   SIM_TMLH7               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'00000100'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
SIM_TMLH7 EQU  *                       Bit 7
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'00000010'
         BNO   SIM_TMLH8               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'00000010'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
SIM_TMLH8 EQU  *                       Bit 8
*
*        Inspect the mask to find the leftmost bit being tested
*
         TM    0(R5),B'00000001'
         BNO   SIM_TMLHD               Not this bit - branch
*
*        Test the equivalent bit in the first Operand
*
         TM    0(R4),B'00000001'       Operand bit is one ?
         BO    SIM_TMLHL1
         B     SIM_TMLHL0
*
*        No bit has been selected for testing in the first mask
*        byte.
*
SIM_TMLHD EQU  *
         LA    R4,1(,R4)               Increment operand data
*                                      to next byte
         LA    R5,1(,R5)               Increment Immediate data addr
*                                      to next byte
         BCT   R6,SIM_TMLH1            Go test next byte
*
*        No bit has been found on in the 16 bit mask. This is a
*        Logic Error as a zero mask has to result in a CC0 for
*        both bytes. Drop through to set CC1.
*
*
*        Leftmost selected bit is off so set CC1
*
SIM_TMLHL0 EQU  *
         SETCC CC1
         B     EXIT1
*
*        Leftmost selected bit is on so set CC2
*
SIM_TMLHL1 EQU  *
         SETCC CC2
         B     EXIT1
*
*        Both CCs were the same but was it a mixed result ?
*
SIM_TMLHA EQU  *
         C     R2,CCMIXED              Mixed result ?
         BE    SIM_TMLHC               Branch to mixed logic
         SETCC (R2)                    Set condition code
         B     EXIT1
*                                      Executed Instructions
EX_TMH   TM    0(R4),X'00'             Test Hi-order byte
EX_TML   TM    1(R4),X'00'             Test Low-order byte
*
*        TML/TMLL
*
*        TML   Rx,I16
*        The contents of the I16 field are used as a 16 Bit
*        mask to test the 16 low-order bits in the Rx Register
*        CC: CC0 - Selected bits all zero
*            CC1 - Mixed bits but leftmost bit zero
*            CC2 - Mixed bits but leftmost bit one
*            CC3 - Selected bits all ones
*        Note:
*        Because CC1 and CC2 are set for a mixed result
*        depending on the value of the selected leftmost bit then
*        the extended mnemonics BM, BNM, BMR and BNMR are
*        effectively broken with this Opcode and should not be
*        used after this Opcode to test the CC for a mixed
*        result.
*
SIM_TMLL EQU   *
         LA    R4,2(,R4)               Point R4 to low-order bytes
         B     SIM_TMLH                Use TMLH routine with R4
*                                      adjusted to point to
*                                      Low-order bytes in Rx Register
*
*        BRC
*
*        BRC M,I16(signed h/w)
*        If the CC matches a mask setting then the PSW
*        Instruction address is set to the arithmetic addition of
*        the signed number of halfwords specified in the
*        Immediate data to the opcode address. Otherwise the next
*        sequential instruction is processed.
*        CC: Unaltered
*
SIM_BRC  EQU   *
         LH    R7,0(R5)            Get Signed number of halfwords
*
SIM_BRCA EQU   *                   Entry Point for BRCL Processing
*
         SLL   R7,1                Convert halfwords to bytes
         IC    R4,1(,R2)           Get Mask and sub opcode
         SRL   R4,4                Move Mask to rightmost bits
         N     R4,=XL4'0000000F'   R4 now has Mask only
         IC    R6,PIEPSW+4         Fetch Current ILC, CC and PGM Mask
         SRL   R6,4                Move CC to Rightmost bits
         N     R6,=XL4'00000003'   Zero all except CC
         LA    R6,MASKTAB(R6)      Use the CC value (00-03) as an
*                                  index into MASKTAB to point R6 at
*                                  equivalent mask values
         EX    R4,EX_TMCC          Test the mask against the equivalent
*                                  CC Values
         BZ    EXIT1               No bits in mask match CC, return
*
*        At least 1 bit in the mask matches the CC, update Ins Addr.
*
         LR    R4,R10              Copy Addr of Opcode
         AR    R4,R7               Calculate new Instruction Addr
*                                  by adding signed immediate data
         STCM  R4,B'0111',PIEPSW+5 Update Instruction Addr in PSW
         B     EXIT1
*
EX_TMCC  TM    0(R6),X'00'         Mask provided in R4
*
*        BRCL
*
*        BRCL  M,I32(signed h/w)
*        If the CC matches a mask setting then the PSW
*        Instruction address is set to the arithmetic addition of
*        the signed number of halfwords specified in the
*        Immediate data to the opcode address. Otherwise the next
*        sequential instruction is processed.
*        CC: Unaltered
*
SIM_BRCL EQU   *
         L     R7,0(,R5)           Get Signed number of halfwords
         B     SIM_BRCA            Branch into SIM_BRC processing
*                                  with the signed number of bytes
*                                  in R7
*
*        BRAS
*
*        BRAS Rx,I16(signed h/w)
*        The current PSW Instruction address is saved in the
*        specified Rx Register and the Instruction Addr is
*        updated by the number of signed half words in the
*        immediate data.
*        CC: Unaltered
*
SIM_BRAS EQU   *
         LH    R7,0(,R5)           Get Signed number of halfwords
*
SIM_BRASA EQU  *                   Entry point for BRASL Processing
*
         SLL   R7,1                Convert halfwords to bytes
         MVI   0(R4),X'00'         Zero hi order byte of Register
         MVC   1(3,R4),PIEPSW+5    Move current Instruction Addr
*                                  to Register
         LR    R6,R10              Copy Addr of Opcode
         AR    R6,R7               Calculate new Instruction Addr
*                                  by adding signed immediate data
         STCM  R6,B'0111',PIEPSW+5 Update Instruction Addr in PSW
*
         B     EXIT1
*
*        BRASL
*
*        BRASL Rx,I32(signed h/w)
*        The current PSW Instruction address is saved in the
*        specified Rx Register and the Instruction Addr is
*        updated by the number of signed halfwords in the
*        immediate data added to the Opcode address.
*        CC: Unaltered
*
SIM_BRASL EQU  *
         L     R7,0(,R5)           Get Signed number of halfwords
         B     SIM_BRASA           Branch into SIM_BRAS processing
*
*        LARL
*
*        LARL Rx,I32(signed halfwords)
*        The address specified in I32 is placed in Rx.
*        The contents of the I32 field is a signed binary word
*        integer specifying the number of half words to be added
*        to the address of the instruction to generate the
*        address.
*        CC: Unaltered
*
SIM_LARL EQU   *
         L     R7,0(R5)            Get Signed number of halfwords
*
*
         SLL   R7,1                Convert halfwords to bytes
         AR    R7,R10              Add Instruction Addr to
*                                  signed number of bytes
         ST    R7,0(,R4)           Store new address in Rx
         MVI   0(R4),X'00'         Ensure hiorder byte zero for 24 bit
         B     EXIT1
*
*        BRCT
*
*        BRCT  Rx,I16(signed h/w)
*        One is subtracted from the value in Rx and Rx is updated
*        with the new value. If the result is non zero then the
*        Instruction Addr is updated by the number of signed
*        half words in the immediate data added to the Opcode Addr.
*        CC: Unaltered
*
SIM_BRCT EQU   *
         L     R6,0(,R4)           Get Register Rx value
         SL    R6,=F'1'            Decrement Rx by 1 and set CC
*                                  for testing later
         ST    R6,0(R4)            Update Rx
         BC    2,EXIT1             If result is Zero, drop through to
*                                  next program instruction
         LR    R6,R10              Copy Instruction Addr.
         LH    R7,0(,R5)           Get Signed number of halfwords
         SLL   R7,1                Convert to bytes
         AR    R6,R7               Calculate new Instruction Addr
*                                  by adding signed immediate data
         STCM  R6,B'0111',PIEPSW+5 Update Instruction Addr in PSW
         B     EXIT1
*
*        LHI
*
*        LHI   Rx,I16
*        Load 16 bits into the Rx Register sign extended to 32 bits
*        CC: Unaltered
*
SIM_LHI  EQU   *
         LH    R9,0(,R5)               Get immediate data and sign
*                                      extend to full register
         ST    R9,0(,R4)               Store into Register
         B     EXIT1
*
*        AHI
*
*        AHI   Rx,I16
*        Add 16 bits into the Rx Register sign extended to 32 bits
*        CC: CC0 - Result Zero, No overflow
*        CC: CC1 - Result Less than Zero, No Overflow
*        CC: CC2 - Result Greater than zero, no Overflow
*        CC: CC3 - Overflow
*
SIM_AHI  EQU   *
         L     R9,0(,R4)               Get Register data
         AH    R9,0(,R5)               Add Immediate data
         ST    R9,0(,R4)               Store into Register
         BALR  R9,R0                   Get CC
         SETCC (R9)                    Set Condition Code
         B     EXIT1
*
*        MHI
*
*        MHI   Rx,I16
*        Multiply 16 bits into the Register sign extended
*        to 32 bits
*        CC: Unaltered
*
SIM_MHI  EQU   *
         L     R9,0(,R4)               Get Register data
         MH    R9,0(,R5)               Multiply Immediate data
         ST    R9,0(,R4)               Store into Register
         B     EXIT1
*
*        CHI
*
*        CHI   Rx,I16
*        Multiply 16 bits into the Rx Register sign extended
*        to 32 bits
*        CC: CC0 - Operands equal
*            CC1 - First operand low
*            CC2 - First operand high
*            CC3 - --
*
SIM_CHI  EQU   *
         L     R9,0(,R4)               Get Register data
         CH    R9,0(,R5)               Compare with Immediate data
         BALR  R9,R0                   Get CC
         SETCC (R9)                    Set Condition Code
         B     EXIT1
*
*        CKSM
*
*        CKSM Rx,Ry(even)
*        Generate a checksum into Rx from the data pointed to
*        by Ry(even) for a length in Register Ry+1
*        CC: CC0 - Entire Second operand processed
*            CC1 - --
*            CC2 - --
*            CC3 - CPU determined amount of data processed
*                  Not set by this simulation.
*        Notes: See logical flowchart in z/Arch PoP for CKSM
*
*
SIM_CKSM EQU   *
         TM    3(R2),X'01'             Second Register Odd ?
         BO    INVREGS                 Yes, Error. Must be even
         L     R6,0(,R4)               R6 -> Rx  = Checksum
         L     R7,0(,R5)               R7 -> Ry  = Addr of data
         L     R8,4(,R5)               R8 -> Ry+1 = Len of data
*                                      R9 -> Inc
*                                      R10 -> Element
         LA    R7,0(,R7)               Zero Hi-Order Byte to
         LA    R8,0(,R8)               prevent any arithmetic problems
SIM_CKSMA EQU  *
         C     R8,=F'4'                4 bytes or more to process ?
         BNL   SIM_CKSMB               Yes, Branch
*
*        Less than 4 bytes to process
*
         LR    R9,R8                   Inc = Len
         IC    R2,ICMTAB(R9)           Convert Inc into ICM Mask
         SR    R10,R10                 Zero Element
         EX    R2,EXICM                Insert remaining chars into
*                                      Element
         B     SIM_CKSMC
*
*        4 or more bytes to process
*
SIM_CKSMB EQU  *
         LA    R9,4                    Inc = 4
         L     R10,0(,R7)               load Element with 4 Chars
SIM_CKSMC EQU  *
         ALR   R6,R10                   Checksum = Checksum
*                                      + Element
         BC    12,SIM_CKSMD            Branch if no overflow
         AL    R6,=F'1'                Checksum = Checksum + 1
SIM_CKSMD EQU  *
         AR    R7,R9                   Addr = Addr + Inc
         SR    R8,R9                   Len = Len - Inc
         BNZ   SIM_CKSMA               Process more data
*
*        All data Checksummed
*
         ST    R6,0(,R4)               Store Checksum result
         ST    R7,0(,R5)               Store Updated Data Addr
         ST    R8,4(,R5)               Store Updated Len
         SETCC CC0                     Set Condition Code
         B     EXIT1                   Return
*
ICMTAB   DC    X'00'                   Mask for zero bytes
         DC    X'08'                   Mask for 1 byte
         DC    X'0C'                   Mask for 2 bytes
         DC    X'0E'                   Mask for 3 bytes
*
EXICM    ICM   R10,B'0000',0(R7)       Ex ICM to load remaining
*                                      Bytes into Element
*
*        IPM
*
*        IPM   Rx
*        The Condition Code and Program Mask are inserted into
*        The hi-order byte of Rx. The ILC bits are zeroed.
*        CC: Unaltered
*
SIM_IPM  EQU   *
         MVC   0(1,R4),PIEPSW+4        MOVE ILC, CC and PGM Mask
         NI    0(R4),X'3F'             Zero ILC
         B     EXIT1
*
*        LBR
*
*        LBR   Rx,Ry
*        The low order byte in Ry is sign extended to 32 bits and
*        placed in Rx
*        CC: Unaltered
*
SIM_LBR  EQU   *
         XC    0(3,R4),0(R4)           Zero hi-order 3 bytes of Rx
         MVC   3(1,R4),3(R5)           Move Byte
         TM    3(R4),X'80'             Negative 8 bit Number
         BNO   SIM_LBRA                No, Branch
         MVC   0(3,R4),=XL3'FFFFFF'    Extend Sign
SIM_LBRA EQU   *
         B     EXIT1
*
*        LLCR
*
*        LLCR  Rx,Ry
*        The low order byte in Ry is moved to the low order byte in
*        Rx. The 3 hi order bytes in Rx are zeroed.
*        CC: Unaltered
*
SIM_LLCR EQU   *
         XC    0(3,R4),0(R4)           Zero hi-order 3 bytes of Rx
         MVC   3(1,R4),3(R5)           Move Byte
         B     EXIT1
*
*        LLHR
*
*        LLHR  Rx,Ry
*        The 2 low order bytes in Ry are moved to the 2 low order
*        bytes in Rx and the 2 hi order bytes in Rx are zeroed.
*        CC: Unaltered
*
SIM_LLHR EQU   *
         XC    0(2,R4),0(R4)           Zero hi-order 2 bytes of Rx
         MVC   2(2,R4),2(R5)           Move 2 low order bytes to Rx
         B     EXIT1
*
*        XILF
*
*        XILF  Rx,I32
*        The Immediate data is Exclusive ORed with the bits in the
*        Rx Register and the result is placed in the Rx Register
*        CC: CC0 - Result is zero
*            CC1 - Result is not zero
*            CC2 - --
*            CC3 - --
*
SIM_XILF EQU   *
         XC    0(4,R4),0(R5)           Exclusive OR immediate data
*                                      into Rx Register
         BALR  R9,R0                   Get CC after XC
         SETCC (R9)                    Set the Condition Code
         B     EXIT1
*
*
*        IILF
*
*        IILF  Rx,I32
*        The Immediate data is Inserted into the Rx Register
*        CC: Unaltered
*
SIM_IILF EQU   *
         MVC   0(4,R4),0(R5)           Insert Immediate data into
*                                      the Rx Register
         B     EXIT1
*
*        NILF
*
*        NILF  Rx,I32
*        The Immediate data is ANDed into the Rx Register
*        CC: CC0 - Result is Zero
*            CC1 - Result is Non Zero
*
SIM_NILF EQU   *
         NC    0(4,R4),0(R5)           AND in Immediate data
         BALR  R9,R0                   Get Condition Code after NC
         SETCC (R9)                    Set the Condition code
         B     EXIT1
*
*        OILF
*
*        OILF  Rx,I32
*        The Immediate data is ORed into the Rx Register
*        CC: CC0 - Result is Zero
*            CC1 - Result is Non Zero
*            CC2 - --
*            CC3 - --
*
SIM_OILF EQU   *
         OC    0(4,R4),0(R5)           OR in Immediate data
         BALR  R9,R0                   Get condition Code after OC
         SETCC (R9)                    Set the Condition Code
         B     EXIT1
*
*        LLILF
*
*        LLILF Rx,I32
*        The Immediate data is moved into the Rx Register
*        CC: Unaltered
*
SIM_LLILF EQU  *
         MVC   0(4,R4),0(R5)
         B     EXIT1
*
*        SLFI
*
*        SLFI  Rx,I32
*        The Immediate data is Logically Subtracted from the data
*        in the Rx Register and the result stored in the Rx Register
*        CC: CC0 -
*            CC1 - Result is Non Zero - Borrow/Carry
*            CC2 - Result is Zero - No Borrow/Carry
*            CC3 - Result is Non Zero - No Borrow/Carry
*
SIM_SLFI EQU   *
         L     R9,0(,R4)               Get Rx Register data
         SL    R9,0(,R5)               Subtract Immediate data
         ST    R9,0(,R4)               Save Result in Rx
         BALR  R9,R0                   Get Condition Code
         SETCC (R9)                    Set Condition Code
         B     EXIT1
*
*        AFI
*
*        AFI   Rx,I32
*        The Immediate data is Added to the Rx Register
*        CC: CC0 - Result is Zero - No Overflow
*            CC1 - Result is less than Zero - No Overflow
*            CC2 - Result is greater tha Zero - No Overflow
*            CC3 - Overflow
*
SIM_AFI  EQU   *
         L     R9,0(,R4)               Get Rx Register Data
         A     R9,0(,R5)               Add Immediate Data
         ST    R9,0(,R4)               Save Result in Rx
         BALR  R9,R0                   Get Condition Code
         SETCC (R9)                    Set Condition Code
         B     EXIT1
*
*        ALFI
*
*        ALFI  Rx,I32
*        The Immediate data is Logically Added to the Rx Register
*        CC: CC0 - Result is Zero - No Carry
*            CC1 - Result is not Zero - No Carry
*            CC2 - Result is Zero - Carry
*            CC3 - Result is not Zero - Carry
*
SIM_ALFI EQU   *
         L     R9,0(,R4)               Get Rx Register Data
         AL    R9,0(,R5)               Add Logical Immediate Data
         ST    R9,0(,R4)               Save Result in Rx
         BALR  R9,R0                   Get Condition Code
         SETCC (R9)                    Set Condition Code
         B     EXIT1
*
*        CFI
*
*        CFI   Rx,I32
*        The Rx Register contents are Compared with the Immediate Data
*        CC: CC0 - Operands Equal
*            CC1 - First Operand Low
*            CC2 - First Operand High
*            CC3 -
*
SIM_CFI  EQU   *
         L     R9,0(,R4)               Get Rx Register Data
         C     R9,0(,R5)               Compare with Immediate Data
         BALR  R9,R0                   Get Condition Code
         SETCC (R9)                    Set Condition Code
         B     EXIT1
*
*        CLFI
*
*        CLFI  Rx,I32
*        The Rx Register contents are Compared Logically with
*        the Immediate Data
*        CC: CC0 - Operands Equal
*            CC1 - First Operand Low
*            CC2 - First Operand High
*            CC3 -
*
SIM_CLFI EQU   *
         L     R9,0(,R4)               Get Register Data
         CL    R9,0(,R5)               Compare Logically with
*                                      Immediate Data
         BALR  R9,R0                   Get Condition Code
         SETCC (R9)                    Set Condition Code
         B     EXIT1
*
*        TRTR - OPCODE D0
*
*        TRTR D1(L,B1),D2(B2)
*        TRTR functions the same as TRT except that the the
*        address of the first operand specifies the right most
*        byte and the address is decremented backwards testing
*        each byte against the second operand for a length L of
*        the first operand.
*        CC: CC0 - All function bytes zero
*            CC1 - Nonzero function byte, first operand not exhausted
*            CC2 - Nonzero function byte, first operand exhausted
*            CC3 - --
*
TRTRINS  EQU   *
         LA    R5,2(R2)                Point to Operand 1 Base and Dis
         BASEDIS R5,R4                 R4 now has resolved Base and Dis
*                                      R4 -> Operand 1
         LA    R5,4(R2)                Point to operand 2 Base and Dis
         BASEDIS R5,R6                 R6 now has resolved Base and Dis
*                                      R6 - > Operand 2
         SR    R3,R3
         IC    R3,1(R2)                Get length of Operand 1 - 1
         LR    R9,R4                   Copy Addr of Rightmost byte Op1
         SR    R9,R3                   Calculate Addr of Leftmost Op1
         BCTR  R9,0                    LeftMost byte of Op1 - 1
         LH    R8,=H'-1'               Increment value for BXH
         SR    R2,R2
TRTRINSA EQU   *
         IC    R3,0(,R4)               Fetch byte from Operand 1
         IC    R2,0(R3,R6)             Get function byte from Operand 2
         LTR   R2,R2                   Is it Zero
         BNZ   TRTRINSB                No, Branch
         BXH   R4,R8,TRTRINSA          Decrement Addr and loop with
*                                      Comparand in R9
*
*        Dropped out of the loop with no non-zero function bytes found
*
         SETCC CC0                     CC0 - All function bytes Zero
         B     EXIT1
*
TRTRINSB EQU   *                       Non-zero function byte found
         STC   R2,PGMREGS+11           Store function byte in low
*                                      order byte of R2
         STCM  R4,B'0111',PGMREGS+5    Store Operand 1 Addr in low
*                                      order 3 bytes of R1
         LA    R9,1(,R9)               R9 - leftmost byte of Operand 1
         SR    R4,R9                   Calculate number of bytes of
*                                      Operand 1 remaining to test
         BZ    TRTRINSC                Branch, Operand 1 exhausted
         SETCC CC1                     CC1, Operand 1 not exhausted
         B     EXIT1
*
TRTRINSC EQU   *                       Operand 1 exhausted
         SETCC CC2
         B     EXIT1
*
*        TRE
*
*        TRE   Rx,Ry
*        The bytes of the first operand Rx are compared to a test
*        byte in R0 and, unless an equal comparison occurs, are
*        used as an eight-bye arguement to reference a 256 byte
*        translation table designated by Ry, the second operand.
*        Each function byte selected from the second operand
*        replaces the corresponding arguement in the first
*        operand. the operation continues until a first operand
*        byte equal to the test byte or the end of the first
*        operand is reached. The first operand length is provided
*        in Rx+1.
*        CC: CC0 - Entire first operand processed without
*                  finding a byte equal to the test byte
*            CC1 - First operand byte is equal to the test byte
*            CC2 - --
*            CC3 - CPU determined number of bytes processed - Not set
*
SIM_TRE  EQU   *
         TM    3(R2),X'10'             Is Rx odd ?
         BO    INVREGS                 Yes, Invalid Register
         L     R7,0(,R4)               R7 - Operand 1
*                                      Rx+1 - Length of First operand
         ICM   R8,B'1111',4(R4)        R8 - Length of Operand 1
         BZ    SIM_TREZ                Zero Length return with CC0
         L     R5,0(,R5)               R5 - Operand 2
         SR    R3,R3
SIM_TREA EQU   *
         IC    R3,0(,R7)               Get Operand 1 byte
         CLM   R3,B'0001',PGMREGS+3    Operand 1 byte equal to test
*                                      byte in low order byte of R0 ?
         BE    SIM_TREC                Yes, Translate complete
         IC    R9,0(R3,R5)             Get function byte
         STC   R9,0(,R7)               Replace Operand 1 byte with
*                                      function byte
         LA    R7,1(,R7)               Increment Operand 1 Addr
         BCT   R8,SIM_TREA             Loop through Operand 1
*
*        Entire Operand 1 processed without finding byte equal to
*        test byte
*
         SETCC CC0
         B     SIM_TRES
*
SIM_TREC EQU   *                       Byte found equal to function
*                                      Byte
         SETCC CC1
SIM_TRES EQU   *                       Update Registers
         ST    R7,0(,R4)               Store Updated Operand 1 Addr
         ST    R8,4(,R4)               Store Updated operand 1 Length
         B     EXIT1
*
SIM_TREZ EQU   *                       Length of Operand 1 zero
         SETCC CC0
         B     EXIT1
*
*        TROO
*
*        TROO  Rx,Ry,[M]
*        The characters of Ry the second operand are used as
*        arguements to select function characters from a
*        translation table designated by the address in R1. When
*        the test character mask is zero each function character
*        is compared to a test character in R0 and, unless an
*        equal comparison occurs is placed at the first operand
*        location. If the test character mask is one then test
*        character comparison is not performed. The operation
*        proceeds until the end of the second operand is reached.
*        The second operand length is provided in Rx+1.
*        CC: CC0 - Entire second operand processed. If test character
*                  comparison was performed no function byte
*                  equalled the test byte.
*            CC1 - Second operand byte found equal to test character
*            CC2 - --
*            CC3 - CPU determined number of bytes processed - Not set
*
SIM_TROO EQU   *
         TM    3(R2),X'10'             Is Rx odd ?
         BO    INVREGS                 Yes, Invalid Register
         L     R7,0(,R4)               R7 - Operand 1
         LA    R7,0(,R7)               Force 24 Bit Addressing
*                                      Rx+1 - Length of Second operand
         ICM   R8,B'1111',4(R4)        R8 - Length of Operand 2
         BZ    SIM_TROOZ               Zero Length return with CC0
         L     R6,0(,R5)               R6 - Operand 2
         LA    R6,0(,R6)               Force 24 Bit Addressing
         L     R10,PGMREGS+4           Get translate table Addr from R1
         N     R10,=XL4'00FFFFF8'      Force DoubleWord Alignment
         SR    R3,R3
SIM_TROOA EQU  *
         IC    R3,0(,R6)               Get Operand 2 byte
         IC    R9,0(R3,R10)            Get function byte
         TM    2(R2),X'10'             Suppress character comparison ?
         BO    SIM_TROON               Yes, branch
         CLM   R9,B'0001',PGMREGS+3    Function byte equal to test
*                                      Character in R0 ?
         BE    SIM_TROOC               Yes, branch
SIM_TROON EQU  *
         STC   R9,0(,R7)               Store Function byte in Operand 1
         LA    R7,1(,R7)               Increment Operand 1 Addr
         LA    R6,1(,R6)               Increment Operand 2 Addr
         BCT   R8,SIM_TROOA            Loop through Operand 2
*
*        Entire Operand 2 processed without finding byte equal to
*        test byte or test character not performed
*
         SETCC CC0
         B     SIM_TROOS
*
SIM_TROOC EQU  *                       Byte found equal to function
*                                      Byte
         SETCC CC1
SIM_TROOS EQU  *                       Update Registers
         ST    R7,0(,R4)               Store Updated Operand 1 Addr
         ST    R8,4(,R4)               Store Updated Operand 2 Length
         ST    R6,0(,R5)               Store Updated Operand 2 Addr
         B     EXIT1
*
SIM_TROOZ EQU  *                       Length of Operand 2 zero
         SETCC CC0
         B     EXIT1
*
*        TROT
*
*        TROT  Rx,Ry,[M]
*        The characters of Ry the second operand are used as
*        arguements to select function characters from a
*        translation table designated by the address in R1. When
*        the test character mask is zero the function characters
*        is compared to a test characters in R0 and, unless an
*        equal comparison occurs is placed at the first operand
*        location. If the test character mask is one then test
*        character comparison is not performed. The operation
*        proceeds until the end of the second operand is reached.
*        The second operand length is provided in Rx+1.
*        CC: CC0 - Entire second operand processed. If test character
*                  comparison was performed no function byte
*                  equalled the test byte.
*            CC1 - Second operand byte found equal to test character
*            CC2 - --
*            CC3 - CPU determined number of bytes processed - Not set
*
SIM_TROT EQU   *
         TM    3(R2),X'10'             Is Rx odd ?
         BO    INVREGS                 Yes, Invalid Register
         L     R7,0(,R4)               R7 - Operand 1
         LA    R7,0(,R7)               Force 24 Bit Addressing
*                                      Rx+1 - Length of Second operand
         ICM   R8,B'1111',4(R4)        R8 - Length of Operand 2
         BZ    SIM_TROTZ               Zero Length return with CC0
         L     R6,0(,R5)               R6 - Operand 2
         LA    R6,0(,R6)               Force 24 Bit Addressing
         L     R10,PGMREGS+4           Get translate table Addr from R1
         N     R10,=XL4'00FFFFF8'      Force DoubleWord Alignment
SIM_TROTA EQU  *
         SR    R3,R3
         IC    R3,0(,R6)               Get Operand 2 byte
         SLA   R3,1                    Convert to half word offset
         LH    R9,0(R3,R10)            Get function bytes
         TM    2(R2),X'10'             Suppress character comparison ?
         BO    SIM_TROTN               Yes, branch
         CLM   R9,B'0011',PGMREGS+2    Function bytes equal to test
*                                      Characters in R0 ?
         BE    SIM_TROTC               Yes, branch
SIM_TROTN EQU  *
         STH   R9,0(,R7)               Store Function bytes in Oper 1
         LA    R7,2(,R7)               Increment Operand 1 Addr by h/w
         LA    R6,1(,R6)               Increment Operand 2 Addr
         BCT   R8,SIM_TROTA            Loop through Operand 2
*
*        Entire Operand 2 processed without finding bytes equal to
*        test bytes or test character not performed
*
         SETCC CC0
         B     SIM_TROTS
*
SIM_TROTC EQU  *                       Bytes found equal to function
*                                      Bytes
         SETCC CC1
SIM_TROTS EQU  *                       Update Registers
         ST    R7,0(,R4)               Store Updated Operand 1 Addr
         ST    R8,4(,R4)               Store Updated Operand 2 Length
         ST    R6,0(,R5)               Store Updated Operand 2 Addr
         B     EXIT1
*
SIM_TROTZ EQU  *                       Length of Operand 2 zero
         SETCC CC0
         B     EXIT1
*
*        TRTO
*
*        TRTO  Rx,Ry,[M]
*        The characters of Ry the second operand are used as
*        arguements to select a function character from a
*        translation table designated by the address in R1. When
*        the test character mask is zero the function character
*        is compared to a test characters in R0 and, unless an
*        equal comparison occurs, is placed at the first operand
*        location. If the test character mask is one then test
*        character comparison is not performed. The operation
*        proceeds until the end of the second operand is reached.
*        The second operand length is provided in Rx+1.
*        CC: CC0 - Entire second operand processed. If test character
*                  comparison was performed no function bytes
*                  equalled the test bytes.
*            CC1 - Selected function bytes found equal to test
*                  characters
*            CC2 - --
*            CC3 - CPU determined number of bytes processed - Not set
*
SIM_TRTO EQU   *
         TM    3(R2),X'10'             Is Rx odd ?
         BO    INVREGS                 Yes, Invalid Register
         L     R7,0(,R4)               R7 - Operand 1
         LA    R7,0(,R7)               Force 24 Bit Addressing
*                                      Rx+1 - Length of Second operand
         TM    7(R4),X'01'             Is Operand 2 length odd ?
         BO    INVREGS                 Yes, Error, must be even
         ICM   R8,B'1111',4(R4)        R8 - Length of Operand 2
         BZ    SIM_TRTOZ               Zero Length return with CC0
         L     R6,0(,R5)               R6 - Operand 2
         LA    R6,0(,R6)               Force 24 Bit Addressing
         L     R10,PGMREGS+4           Get translate table Addr from R1
         N     R10,=XL4'00FFFFF8'      Force DoubleWord Alignment
         SR    R3,R3
SIM_TRTOA EQU  *
         ICM   R3,B'0011',0(R6)        Get Operand 2 bytes
         IC    R9,0(R3,R10)            Get function byte
         TM    2(R2),X'10'             Suppress character comparison ?
         BO    SIM_TRTON               Yes, branch
         CLM   R9,B'0001',PGMREGS+3    Function bytes equal to test
*                                      Characters in R0 ?
         BE    SIM_TRTOC               Yes, branch
SIM_TRTON EQU  *
         STC   R9,0(,R7)               Store Function byte in Oper 1
         LA    R7,1(,R7)               Increment Operand 1 Addr
         LA    R6,2(,R6)               Increment Operand 2 Addr by h/w
         BCTR  R8,0
         BCT   R8,SIM_TRTOA            Loop through Operand 2
*
*        Entire Operand 2 processed without finding bytes equal to
*        test bytes or test character not performed
*
         SETCC CC0
         B     SIM_TRTOS
*
SIM_TRTOC EQU  *                       Bytes found equal to function
*                                      Bytes
         SETCC CC1
SIM_TRTOS EQU  *                       Update Registers
         ST    R7,0(,R4)               Store Updated Operand 1 Addr
         ST    R8,4(,R4)               Store Updated Operand 2 Length
         ST    R6,0(,R5)               Store Updated Operand 2 Addr
         B     EXIT1
*
SIM_TRTOZ EQU  *                       Length of Operand 2 zero
         SETCC CC0
         B     EXIT1
*
*        TRTT
*
*        TRTT  Rx,Ry,[M]
*        The characters of Ry the second operand are used as
*        arguements to select function characters from a
*        translation table designated by the address in R1. When
*        the test character mask is zero the function characters
*        is compared to test characters in R0 and, unless an
*        equal comparison occurs, is placed at the first operand
*        location. If the test character mask is one then test
*        character comparison is not performed. The operation
*        proceeds until the end of the second operand is reached.
*        The second operand length is provided in Rx+1.
*        CC: CC0 - Entire second operand processed. If test character
*                  comparison was performed no function bytes
*                  equalled the test bytes.
*            CC1 - Selected function bytes found equal to test
*                  characters
*            CC2 - --
*            CC3 - CPU determined number of bytes processed - Not set
*
SIM_TRTT EQU   *
         TM    3(R2),X'10'             Is Rx odd ?
         BO    INVREGS                 Yes, Invalid Register
         L     R7,0(,R4)               R7 - Operand 1
         LA    R7,0(,R7)               Force 24 Bit Addressing
*                                      Rx+1 - Length of Second operand
         TM    7(R4),X'01'             Is Operand 2 length odd ?
         BO    INVREGS                 Yes, Error, must be even
         ICM   R8,B'1111',4(R4)        R8 - Length of Operand 2
         BZ    SIM_TRTTZ               Zero Length return with CC0
         L     R6,0(,R5)               R6 - Operand 2
         LA    R6,0(,R6)               Force 24 Bit addressing
         L     R10,PGMREGS+4           Get translate table Addr from R1
         N     R10,=X'00FFFFF8'        Force DoubleWord Alignment
SIM_TRTTA EQU  *
         SR    R3,R3
         ICM   R3,B'0011',0(R6)        Get Operand 2 bytes
         SLL   R3,1                    Convert to half word offset
         LH    R9,0(R3,R10)            Get function bytes
         TM    2(R2),X'10'             Suppress character comparison ?
         BO    SIM_TRTTN               Yes, branch
         CLM   R9,B'0011',PGMREGS+2    Function bytes equal to test
*                                      Characters in R0 ?
         BE    SIM_TRTTC               Yes, branch
SIM_TRTTN EQU  *
         STH   R9,0(,R7)               Store Function bytes in Oper 1
         LA    R7,2(,R7)               Increment Operand 1 Addr by h/w
         LA    R6,2(,R6)               Increment Operand 2 Addr by h/w
         BCTR  R8,0
         BCT   R8,SIM_TRTTA            Loop through Operand 2
*
*        Entire Operand 2 processed without finding bytes equal to
*        test bytes or test character not performed
*
         SETCC CC0
         B     SIM_TRTTS
*
SIM_TRTTC EQU  *                       Bytes found equal to function
*                                      Bytes
         SETCC CC1
SIM_TRTTS EQU  *                       Update Registers
         ST    R7,0(,R4)               Store Updated Operand 1 Addr
         ST    R8,4(,R4)               Store Updated Operand 2 Length
         ST    R6,0(,R5)               Store Updated Operand 2 Addr
         B     EXIT1
*
SIM_TRTTZ EQU  *                       Length of Operand 2 zero
         SETCC CC0
         B     EXIT1
*
*        TP
*
*        TP    D(L,B)
*        The operand is tested for valid decimal digits and sign
*        with the result indicated in the CC.
*        CC: CC0 - All digits and sign valid
*            CC1 - Sign invalid
*            CC2 - At least one digit invalid
*            CC3 - Sign and at least one digit invalid
*
TPINS    EQU   *
         CLI   5(R2),X'C0'             Valid Opcode ?
         BNE   INVOP
         LA    R5,2(R2)                Point to Operand 1 Base and Dis
         BASEDIS R5,R4                 R4 now has resolved Base and Dis
         SR    R5,R5
         IC    R5,1(R2)                Length in highorder nibble
         SRA   R5,4                    Move to low order nibble
         SR    R9,R9                   Clear Reg used to set CC
         SR    R2,R2
         IC    R2,0(R4,R5)             Get digit and sign
         LR    R3,R2                   Take a copy
         N     R2,=X'0000000F'         Only sign now
         CLM   R2,B'0001',=X'0A'       Compare with lowest valid sign
         BNL   TPINSA                  Branch if sign valid
         O     R9,=X'10000000'         Set CC1 - Sign invalid
TPINSA   SRA   R3,4                    Low order digit into rightmost
*                                      nibble
         CLM   R3,B'0001',=X'0A'       Must be less than X'A'
         BL    TPINSB                  Branch if digit valid
         O     R9,=X'20000000'         Set CC2 - Digit invalid
TPINSB   EQU   *
         LTR   R5,R5                   Only one byte variable to test ?
         BZ    TPINSZ                  Yes, branch
         LA    R6,1                    Set Increment for BXLE
         LA    R7,0(R4,R5)             Set Comparand to addr of hiorder
         BCTR  R7,0                    byte of variable being tested
TPINSL   EQU   *
         IC    R2,0(,R4)               Get two decimal digits
         LR    R3,R2                   Take a copy
         N     R2,=X'0000000F'         Right most decimal digit only
         CLM   R2,B'0001',=X'0A'       Must be less than X'0A'
         BL    TPINSC                  Yes, Branch
         O     R9,=X'20000000'         Set CC2 - Digit invalid
TPINSC   EQU   *
         SRA   R3,4                    Move left digit to low nibble
         CLM   R3,B'0001',=X'0A'       Must be less than X'0A'
         BL    TPINSD                  Yes, Branch
         O     R9,=X'20000000'         Set CC2 - Digit invalid
TPINSD   EQU   *
         BXLE  R4,R6,TPINSL            Increment Addr by R6 and compare
*                                      with R7. Branch if low or equal
*        All bytes processed
*
TPINSZ   EQU   *
         SETCC (R9)                    Set CC
         B     EXIT1
*
*        LT
*
*        LT    Rx,D20(X2,B2)
*        The second operand is placed unchanged in Rx
*        CC: CC0 - Result Zero
*            CC1 - Result less than Zero
*            CC2 - Result Greater than Zero
*            CC3 - --
*
SIM_LT   EQU   *
         ICM   R4,B'1111',0(R5)        Get second Operand and set CC
         ST    R4,0(,R6)               Store in Rx
         BALR  R9,R0                   Get CC
         SETCC (R9)                    Set Resulting CC
         B     EXIT1
*
*        LRV
*
*        LRV   Rx,D20(X2,B2)
*        The second operand is placed in Rx in reverse order
*        of bytes.
*        CC: Unaltered
*
SIM_LRV  EQU   *
         MVCIN 0(4,R6),3(R5)
         B     EXIT1
*
*        LRVH
*
*        LRVH  Rx,D20(X2,B2)
*        A halfword is fetched from the second operand and placed
*        in reverse order in the low order two bytes of Rx.
*        CC: Unaltered
*
SIM_LRVH EQU   *
         MVCIN 2(2,R6),1(R5)
         B     EXIT1
*
*        STRV
*
*        STRV  Rx,D20(X2,B2)
*        Rx is placed in the second operand in reverse order
*        of bytes.
*        CC: Unaltered
*
SIM_STRV EQU   *
         MVCIN 0(4,R5),3(R6)
         B     EXIT1
*
*        STRVH
*
*        STRVH Rx,D20(X2,B2)
*        The two low order bytes in Rx are placed in the second
*        operand in reverse order of bytes.
*        CC: Unaltered
*
SIM_STRVH EQU  *
         MVCIN 0(2,R5),3(R6)
         B     EXIT1
*
*        LB
*
*        LB    Rx,D20(X2,D2)
*        The second operand byte is sign extended to 32 bits and
*        placed in Rx.
*        CC: Unaltered
*
SIM_LB   EQU   *
         XC    0(3,R6),0(R6)           Zero hi-order 3 bytes of Rx
         MVC   3(1,R6),0(R5)           Move Byte
         TM    0(R5),X'80'             Negative 8 bit Number
         BNO   SIM_LBA                 No, Branch
         MVC   0(3,R6),=XL3'FFFFFF'    Extend Sign
SIM_LBA  EQU   *
         B     EXIT1
*
*        LLC
*
*        LLC   Rx,D20(X2,D2)
*        The second operand byte is placed in the low order byte
*        of Rx and the three high order bytes zeroed.
*        CC: Unaltered
*
SIM_LLC  EQU   *
         XC    0(3,R6),0(R6)           Zero hi-order 3 bytes of Rx
         MVC   3(1,R6),0(R5)           Move Byte
         B     EXIT1
*
*        LLH
*
*        LLH   Rx,D20(X2,D2)
*        A halfword from the second operand is placed in the two
*        low order bytes of Rx and the two high order bytes zeroed.
*        CC: Unaltered
*
SIM_LLH  EQU   *
         XC    0(2,R6),0(R6)           Zero hi-order 2 bytes of Rx
         MVC   2(2,R6),0(R5)           Move Halfword
         B     EXIT1
*
*        SIMZ9 Control Block
*
         DS    0D
SIMZ9CB  DC    CL8'SIMZ9CB'            Eye Catcher
PGMPSW   DC    D'0'                    From the PIE
PGMREGS  DC    16F'0'                  R0 - R15
*
*        The registers saved in the PIE and R3 - R13 of the
*        program causing the 0C1 are saved in PGMREGS in the
*        order R0 - R15 to assist in the programming of
*        the simulation code. The Register values are moved
*        back in to the PIE and R3 - R13 reloaded on return
*        to the program after simulation of the opcode.
*
PGMOPCDE DC    XL6'000000000000'       The Opcode causing the Interrupt
*
*        Constants
*
         DS    0F
CCMASK   DC    XL4'30000000'           Zero all bits except CC
CCMIXED  DC    XL4'01000000'           Test for CC1 (Mixed)
MASKTAB  DC    XL4'08040201'           Mask table to convert CC
*                                      values to mask like values
EX_FLAG  DC    X'00'                   Status flags for EX mode
EX_MODE  EQU   X'80'                   Simulated Opcode is the
*                                      target of an EX
*
*        LITERALS
*
         LTORG
*
*        Generate Null PICA with SPIE
*
NULLSPIE SPIE  MF=L
NULLSPIEL EQU  *-NULLSPIE              Length of PICA
*
*        PIE DSECT
*
         IHAPIE
*
*        Register Equates
*
         IEZREGS
         END   SIMZ9
