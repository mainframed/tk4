*          Member C3270 at Level 007 as of 30/7/12               *WSJW*
C3270    TITLE 'V2M5 - CLIST Communication Routine for 3270 Terminals'
         MACRO
         REGEQU
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         MEND
         MACRO
&LAB     LEAVER &WR=R13,&WL=WORKLEN
&LAB     LR    R1,&WR             WORKAREA ADDR FOR FREEMAIN
         L     R0,=A(&WL)         WORKAREA LEN   "    "
         L     R13,4(R13)         GET CALLERS SAVEAREA ADDR
         LR    R11,R15            SAVE RETURN CODE
         FREEMAIN R,LV=(0),A=(1)
         LR    R15,R11            RESTORE RETURN CODE
         RETURN (14,12),RC=(15)
         MEND
         MACRO
&LAB     LEAVENR
&LAB     L     R13,4(R13)         GET CALLERS SAVEAREA ADDR
         RETURN (14,12),RC=(15)
         MEND
         MACRO
&LAB     KKPARSE &CPPL=R11,&ANS=ANS,&ECB=ECB,&PCL=PCL,&PPLA=PPLA
*                  DEFAULT OPERANDS :
*        KKPARSE &CPPL=R11,&ANS=ANS,&ECB=ECB,&PCL=PCL,&PPLA=PPLA
*                            CPPL IS THE REGISTER CONTAINING THE
*                                 POINTER TO THE COMMAND PROCESSOR
*                                 PARAMETER LIST.
*                            ANS  IS A FULLWORD WHERE PARSE RETURNS
*                                 THE POINTER TO HIS ANSWER (IKJPARMD).
*                            ECB  IS A FULLWORD.
*                            PCL  IS THE NAME OF THE PARSE CONTROL
*                                 LIST CSECT (IKJPARM).
*                            PPLA IS A 7 FULLWORD AREA USED FOR
*                                 THE PARSE PARAMETER LIST.
*
*        KKPARSE             USES REGS R14,R15,R1,&CPPL REG
*
         USING CPPL,&CPPL         POINTS TO CPPL (PARM LIST)
*
&LAB     LA    R1,&PPLA           R1->PPL AREA
         USING PPL,R1             TELL ASSEMBLER POINTS TO PPL AREA
*
*                         CONSTRUCT PARSE PARAMETER LIST
*                                           FOR IKJPARS :
*
         MVC   PPLUPT,CPPLUPT     UPT
         MVC   PPLECT,CPPLECT     ECT
         LA    R15,&ECB           ECB
         ST    R15,PPLECB
         L     R15,=V(&PCL.)      PCL
         ST    R15,PPLPCL
         LA    R15,&ANS           ANS
         ST    R15,PPLANS
         MVC   PPLCBUF,CPPLCBUF   CBUF
         XC    PPLUWA,PPLUWA
*
         DROP  R1
         EJECT
*        CALLTSSR EP=IKJPARS      CALL PARSE:
         CALLTSSR EP=IKJPARS      CALL PARSE:
         EJECT
*
*                        DSECTS NEEDED BY PARSE:
*
*CPPL    IKJCPPL
CPPL     IKJCPPL
*PPL     IKJPPL
PPL      IKJPPL
*
CVTMAP   DSECT
         ORG   CVTMAP+524
CVTPARS  DS    F
CVTPTR   EQU   16
*
*
&SYSECT  CSECT
         MEND
         MACRO
&L1      MOVE  &TO,&TL,&FROM,&FL,&PAD=
         LCLA  &NL,&UL,&VL
         LCLC  &TO$,&TL$,&FROM$,&FL$
&TO$     SETC  '&TO'
&TL$     SETC  '&TL'
&FROM$   SETC  '&FROM'
&FL$     SETC  '&FL'
         AIF   ('&TO'(1,1) NE '(').TLC
&TO$     SETC  '0&TO'
.TLC     AIF   ('&TL'(1,1) NE '(').FC
&TL$     SETC  '0&TL'
.FC      AIF   ('&FROM'(1,1) NE '(').FLC
&FROM$   SETC  '0&FROM'
.FLC     AIF   (T'&FL EQ 'O').OO
         AIF   ('&FL'(1,1) NE '(').OO
&FL$     SETC  '0&FL'
.OO      ANOP
&L1      STM   14,12,12(13)
         LA    R2,&TO$
         LA    R3,&TL$
         LA    R4,&FROM$
         AIF   (T'&FL EQ 'O').UTL
         LA    R5,&FL$
         AGO   .PC
.UTL     LA    R5,&TL$
.PC      AIF   ('&PAD' EQ '').NPC
         ICM   R5,8,=&PAD
.NPC     MVCL  R2,R4
         LM    14,12,12(13)
         MEND
         MACRO
&LAB1    ENTERR  &SA=SAVEAREA,&WA=WORKAREA,&WL=WORKLEN,&LEVEL=,&R=,   XX
               &CLEAR=NO
         MNOTE ' CLEAR=&CLEAR,SA=&SA,WA=&WA,WL=&WL,LEVEL=&LEVEL'
&LAB1    CSECT
         SAVE  (14,12),,&LAB1-&LEVEL
         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING
         USING &LAB1,R12
         LR    R10,R1             SAVE PARM PTR R10->PARM PTR
         L     R0,=A(&WL)         R0=GET LENGTH
         GETMAIN R,LV=(0)         R1->WORKAREA
         LR    R11,R13            R11->CALLERS SAVEAREA
         LR    R13,R1             R13->WORKAREA
         USING &WA.,R13
         AIF   ('&CLEAR' NE 'YES').NCLEAR
         L     R15,=A(&WL)        R0=GET LENGTH
         S     R15,=F'72'         SKIP REGS
         MOVE  72(13),(15),0,0,PAD=X'00'
.NCLEAR  ANOP
         ST    R11,&SA.+4         SAVE HIS SAVEAREA PTR
         LA    R13,&SA            R13->SAVEAREA (MINE)
         ST    R13,8(,R11)        MINE IN HIS
         LR    R11,R1             R11->WORKAREA IN CASE NOT SAME AS R13
*                       WORKAREA ADDR IS STILL R13 FOR
*                       THE ASSEMBLER - IF DIFFERENT FROM R13
*                       THEN USE: DROP R13 AND USING &WA.,R11
         LR    R1,R10             RESTORE PARM PTR PTR
         AIF   ('&R' EQ 'NO').NRE
         REGEQU
.NRE     ANOP
         MEND
         MACRO
&LAB1    ENTERNR &SA=SAVEAREA
&LAB1    START
         SAVE  (14,12),,*         HO-HUM
         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING
         USING &LAB1,R12
         ST    R13,&SA.+4         SAVE HIS SAVEAREA PTR
         LR    R11,R13            SAVE THE SAVE POINTER
         LA    R13,&SA            R13->SAVEAREA (MINE)
         ST    R13,8(,R11)        MINE IN HIS
         B     ENTEX
&SA      DS    18F
         REGEQU
ENTEX    DS    0H
         MEND
         MACRO
&LAB1    COMMENT &A,&B,&C,&D,&E,&F,&G,&H,&I,&J,&K
         MEND
         EJECT
*
* TSO Command C3270 - CLIST Communication Routine for 3270 Terminals
*  AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).
*          (206) 902-3119   *****  KOMM  V2M4          *****
*              V2M4 - MODIFIED FOR VTAM AND 3279 ORDERS 8/3/83
*
*  MOD:    Wolfgang Schaefer and Juergen Winkelmann (2.5)        *WSJW*
*                           *****  C3270 V2M5          *****     *WSJW*
*              V2M5 - Change SBA orders in input to    30/7/12   *WSJW*
*                     × (X'4F') to facilitate parsing in CLISTs. *WSJW*
*                   - Rename to C3270.                           *WSJW*
*                   - Complete Kermit's V2M4 extended datastream *WSJW*
*                     support: Optionally enable TPUT NOEDIT     *WSJW*
*                     to allow SFE and MF order arguments to     *WSJW*
*                     survive output datastream translation.     *WSJW*
*                   - Wide screen support:                       *WSJW*
*                     o 3270 buffer addresses specified through  *WSJW*
*                       row/column parameters on the command     *WSJW*
*                       line are calculated based on a default   *WSJW*
*                       screen width of 80. If GTSIZE returns a  *WSJW*
*                       screen size of more than 80 columns the  *WSJW*
*                       GTSIZE result replaces the default.      *WSJW*
*                     o 3270 buffer addresses coded in the       *WSJW*
*                       MESSAGE operand or returned to a CLIST   *WSJW*
*                       variable via the READTO operand after    *WSJW*
*                       SBA, EUA or RA orders are handled        *WSJW*
*                       depending on the new command line        *WSJW*
*                       TA/TRANSADD:                             *WSJW*
*                       + If TA/TRANSADD isn't specified these   *WSJW*
*                         addresses are reencoded from 80        *WSJW*
*                         columns to the current screen width on *WSJW*
*                         output and vice versa on input.        *WSJW*
*                       + If TA/TRANSADD is specified the six    *WSJW*
*                         bytes following an SBA, EUA, RA order  *WSJW*
*                         are two three digit numbers in EBCDIC  *WSJW*
*                         encoding defining the row and column.  *WSJW*
*                         On output these are encoded to and     *WSJW*
*                         replaced by their corresponding buffer *WSJW*
*                         address, on input the buffer address   *WSJW*
*                         is decoded and replaced by the         *WSJW*
*                         corresponding row and column numbers.  *WSJW*
*                     o New GS/GETSIZE operand stores the        *WSJW*
*                       current screen dimensions in CLIST       *WSJW*
*                       variables C3270ROW and C3270COL. These   *WSJW*
*                       variables must have been initialized to  *WSJW*
*                       three-character strings prior to running *WSJW*
*                       C3270 with the GS/GETSIZE operand.       *WSJW*
*                                                                *WSJW*
*  SYNTAX -   C3270 WCC('CHAR') RESET('LINE') CLEAR GS/GETSIZE   *WSJW*
*                   MESSAGE('ROW','COL','MESS') CURSOR('ROW','COL')
*                   READTO('VAR')  AI/ASIS TA/TRANSADD NE/NOEDIT *WSJW*
*
*  OPERANDS -
*             WCC('CHAR') -  'CHAR' IS THE WRITE CONTROL CHARACTER TO
*                          BE USED. 'C' IS THE DEFAULT.
*
*             RESET('LINE') - 'LINE' IS THE LINE YOU WISH TCAM'S LINE
*                          COUNTER TO BE SET TO. NORMAL OUTPUT BEGINS
*                          AT THIS LINE. 'LINE' DEFAULTS TO '1'.
*
*             CLEAR  -     CAUSES THE SCREEN TO BE CLEARED.
*
*             MESSAGE('ROW','COL','MESS') - DISPLAYS A MESSAGE ON THE
*                          SCREEN. 'ROW' AND 'COL' ARE THE ROW AND
*                          COLUMN WHERE THE MESSAGE STARTS. 'MESS' IS
*                          THE MESSAGE (SEE NOTE).
*
*             CURSOR('ROW','COL') - MOVES THE CURSOR TO LOCATION GIVEN.
*
*             READTO('VAR') - OBTAINS REPLY AND PLACES IN CLIST VAR-
*                          IABLE 'VAR'. 'VAR' MUST BE PRE-INITIALIZED
*                          TO HAVE SUFFICIENT ROOM FOR THE REPLY.
*
*             AI  -  SUPPRESSES THE REMOVAL OF LEADING SBA FROM REPLY
*
*             GS  -  Store the current screen dimensions in      *WSJW*
*                    CLIST variables C3270ROW and C3270COL.      *WSJW*
*                    These variables must have been initialized  *WSJW*
*                    to three-character strings prior to         *WSJW*
*                    running C3270 with the GS/GETSIZE operand.  *WSJW*
*                                                                *WSJW*
*             TA  -  interpret six bytes following an SBA, EUA   *WSJW*
*                    or RA order in the MESSAGE operand or the   *WSJW*
*                    CLIST variable defined through the READTO   *WSJW*
*                    operand as two three digit EBCDIC encoded   *WSJW*
*                    numbers defining a row and a column. The    *WSJW*
*                    corresponding 3270 buffer address for the   *WSJW*
*                    current screen width is calculated from     *WSJW*
*                    these numbers on output. On input these     *WSJW*
*                    numbers are calculated from the 3270        *WSJW*
*                    buffer address received.                    *WSJW*
*                                                                *WSJW*
*             NE  -  use TPUT NOEDIT instead of TPUT FULLSCR     *WSJW*
*                    for output and set STFSMODE ON,NOEDIT=YES   *WSJW*
*                    on input.                                   *WSJW*
*                                                                *WSJW*
         EJECT
*
* RETURN-CODES : C3270 RETURNS CODES IN CLIST VAR LASTCC AS FOLLOWS:
*
*  WRITE OPERATION ONLY -
*                       0 - NORMAL COMPLETION
*                     256 - PARSE ERROR
*                   OTHER - I/O ERROR OCCURED
*
*  WRITE AND READ OPERATION - THE RETURN CODE NORMALLY INDICATES WHICH
*                                TRANSMIT KEY WAS PRESSED:
*
*   241 - PF1   193 - PF13               1 - TEST REQ
*   242 - PF2   194 - PF14             110 - PA2
*   243 - PF3   195 - PF15             125 - ENTER
*   244 - PF4   196 - PF16            2048 - PA1 (C3270 interrupted
*   245 - PF5   197 - PF17                              then resumed)
*   246 - PF6   198 - PF18
*   247 - PF7   199 - PF19
*   248 - PF8   200 - PF20
*   249 - PF9   201 - PF21
*   122 - PF10   74 - PF22
*   128 - PF11   75 - PF23
*   124 - PF12   76 - PF24
*
*      IF NONE OF THE ABOVE:
*                     256 - PARSE ERROR
*                     260 - CLIST VARIABLE-NAME NOT FOUND
*                   OTHER - I/O ERROR OCCURED
         EJECT
*
* MESSAGE-NOTE:
*                 IN ORDER TO GIVE THE USER MORE CONTROL OVER THE
*              SCREEN FORMAT, C3270 SCANS THE MESSAGE AND DOES THIS:
*
*                 UPON ENCOUNTERING A Ö (CENT SIGN), C3270 REMOVES
*              THE Ö (CENT SIGN) FROM THE MESSAGE AND TRANSLATES
*              THE FOLLOWING CHARACTER TO A 3270 CONTROL CHARACTER
*              OR A TSO PROBLEM CHARACTER, USING THE TABLE BELOW:
*
*         3270 CONTROL:                  TSO PROBLEM CHARS:
*   CHAR   TRANSLATION   HEX          CHAR   TRANSLATION   HEX
*    _         IC       X'13'          <         (        X'4D'
*    -         SBA      X'11'          >         )        X'5D'
*    ×         SF       X'1D'          "         '        X'7D'
*    *         NULL     X'00'          /         ^        X'5F'
*    #         RA       X'3C'          Ö         Ö        X'4A'
*    @         EUA      X'12'          A    (BROKEN BAR)  X'6A'
*    .         PT       X'05'          B         ,        X'6B'
*
*         extended datastream:                                   *WSJW*
*                                                                *WSJW*
*    $         SFE      X'29' SF EXTNDED    attribute-value      *WSJW*
*    %         MF       X'2C' MOD FLD         pair counts        *WSJW*
*    S         SA       X'28' SET ATTR                           *WSJW*
*    C                  X'42' COLOR     Ö0 -> X'00'  Ö5 -> X'05' *WSJW*
*    H                  X'41' HIGHLITE  Ö1 -> X'01'  Ö6 -> X'06' *WSJW*
*    G                  X'43' SYM SET   Ö2 -> X'02'  Ö7 -> X'07' *WSJW*
*                                       Ö3 -> X'03'  Ö8 -> X'08' *WSJW*
*                                       Ö4 -> X'04'  Ö9 -> X'09' *WSJW*
*                                                                *WSJW*
*           OTHERS SHOULD NOT BE CONSIDERED AS DEFINED AT THIS TIME,
*       BUT ARE GENERALLY TRANSLATED TO THEMSELVES. THE PROBLEM CHARS
*       ARE TRANSLATED BECAUSE ALL 3270 CHARS ARE USED IN ADDRESS
*       SPECIFICATION ETC. BUT SOME HAVE SPECIAL SIGNIFICANCE TO TSO.
*
* EXAMPLE:
*           C3270 CLEAR MESS(10,40,'Ö#  Z')                      *WSJW*
*       WOULD CLEAR THE SCREEN AND FILL FROM LINE 10, COLUMN 40 TO
*       THE BOTTOM OF THE SCREEN WITH THE LETTER 'Z'.
*
*
*
         TITLE 'SPECIAL FULLSCREEN COMM RTN'
*
*********************************************************************
*    THIS PROGRAM IS DEPENDENT ON TCAM BEING ASSEMBLED WITH THE     *
*    'SPFSCRN' MACROS OR EQUIVALENT IF  NOT USING VTAM.             *
*********************************************************************
*
*        STANDARD CP LINKAGE
*
C3270    ENTERR LEVEL=V2M5        R13 -> workarea                *WSJW*
*                                 R12 -> C3270 addressability    *WSJW*
         EJECT
*
*        PARSE THE INPUT COMMAND BUFFER
*
         LR    R11,R1             SAVE THE PARM POINTER
*                                 R11 -> CPPL
DOPARSE  KKPARSE
*
*
ANALR    LTR   R15,R15            RC = 0? PARSE WENT OK?
         BNZ   PARSERR            NO. -> GO TO PARSE ERR
         L     R10,ANS            R10 -> IKJPARMD
         USING IKJPARMD,R10
         EJECT
         LA    R8,80              default screen width           *WSJW*
         LA    R9,24              default screen height          *WSJW*
         GTSIZE ,                 get screen dimensions          *WSJW*
         CR    R1,R8              line length greater 80?        *WSJW*
         BNH   *+6                no, use default width          *WSJW*
         LR    R8,R1              yes, use GTSIZE result         *WSJW*
         CR    R0,R9              number of rows greater 24?     *WSJW*
         BNH   *+6                no, use default height         *WSJW*
         LR    R9,R0              yes, use GTSIZE result         *WSJW*
         STH   R8,WIDTH           store line length              *WSJW*
         STH   R9,HEIGHT          store number of rows           *WSJW*
*                                                                *WSJW*
         NI    ADDRMODE,X'00'     clear addressing mode flags    *WSJW*
         CLI   TA+1,X'00'         TA entered?                    *WSJW*
         BE    *+8                no,  don't translate addresses *WSJW*
         OI    ADDRMODE,TRANSADD  yes, translate addresses       *WSJW*
*                                                                *WSJW*
         NI    PROTOCOL,X'00'     clear TPUT flags               *WSJW*
         CLI   NE+1,X'00'         NE entered?                    *WSJW*
         BE    *+8                no,  use TPUT FULLSCR          *WSJW*
         OI    PROTOCOL,NOEDIT    yes, use TPUT NOEDIT           *WSJW*
*                                                                *WSJW*
         NI    TRANMODE,X'00'     clear translate mode flags     *WSJW*
*                                                                *WSJW*
         MVC   BUFWRLST(BUFWRL),BUFWR initialize TPUT plist      *WSJW*
*
*              SETUP  -  PROCESS  OPERANDS
*
*                                 R9 == BAL REGISTER
*                                 R8 -> CURRENT POSITION IN OUT BUFFER
         LA    R8,BUFFO
         TM    PROTOCOL,NOEDIT    use TPUT NOEDIT?               *WSJW*
         BZ    MAINLINE           no, skip write cmd             *WSJW*
         MVI   0(R8),C'1'         put write command in buffer    *WSJW*
         LA    R8,1(,R8)          point past                     *WSJW*
*
MAINLINE BAL   R9,WCCP            GET WRITE CNTL CHAR
         TM    RESET+1,X'FF'      RESET ENTERED?
         BZ    CCK                NO
         BAL   R9,RESETP          PUT RESET IN OUT BUFFR
CCK      TM    CLEAR+1,X'FF'      CLEAR ENTERED?
         BZ    MCK
         BAL   R9,CLEARP          PUT CLR IN BUFFR
MCK      TM    MESS+1,X'FF'       MESSAGE ENTERED?
         BZ    ICK
         BAL   R9,MESSP           PUT MSG IN BUFFR
ICK      TM    IC+1,X'FF'         INSERT CURSOR NTRD?
         BZ    RCK
         BAL   R9,ICP             PUT IN BUFFR
RCK      TM    READTO+1,X'FF'     READTO ENTERED?
         BZ    SCK                                               *WSJW*
         BAL   R9,READTOP         GET ADDR FOR READTO
SCK      TM    GS+1,X'FF'         GETSIZE entered?               *WSJW*
         BZ    FIXLEN                                            *WSJW*
         BAL   R9,PUTSIZE         return screen size             *WSJW*
FIXLEN   BAL   R9,SETLEN          INITIALIZE BUFFER LENGTHS
*
         LTR   R15,R15            RC=0 SO FAR?
         BNZ   GETOUT             NO ->EXIT
         EJECT
*
*        PERFORM THE I/O OPERATION NOW
*
FULLCHK  TM    FLAGS,X'FF'        INPUT AND OUTPUT?
         BO    BOTH               YES
         BZ    WHAT THE HECK?
         TM    FLAGS,X'F0'        OUTPUT ONLY?
         BO    RITEONLY           YES
READONLY CALL  FULLSCRN,(=C'I',BUFFLI,BUFFI),VL,MF=(E,PARML)
         B     RCANAL
RITEONLY CALL  FULLSCRN,(=C'O',BUFFLO,BUFFO),VL,MF=(E,PARML)
         B     GETOUT
BOTH     CALL  FULLSCRN,(=C'B',BUFFLO,BUFFO,BUFFLI,BUFFI),VL,          X
               MF=(E,PARML)
         B     RCANAL
*
WHAT     EQU   *                  WHAT THE HECK ARE WE DOING HERE?
*
         TM    GS+1,X'FF'         GETSIZE entered?               *WSJW*
         BNZ   GETOUT             exit RC=0                      *WSJW*
*                                                                *WSJW*
         LA    R15,99             SET RC=99 TO CAUSE EXIT
         EJECT
*
*         ANALYZE ANY INPUT OBTAINED BY FULLSCRN
*
RCANAL   BAL   R9,ERRCK           CHECK ERRORS
         LTR   R15,R15            CORRECTED?
         BNZ   GETOUT2            NO.
*
         BAL   R9,SETRC           SET RC BY AID BYTE
         BAL   R9,SETVAR          MOVE ANY INPUT DATA TO CLIST VAR
*
*         ISSUE VTAM LINE COUNT RESET IN CASE UNDER VTAM: 8/3/83
*
GETOUT   EQU   *
         TM    RESET+1,X'FF'      RESET ENTERED?
         BZ    GETOUT2            NO
         BAL   R9,RESETV          TELL VTAM
*
GETOUT2  LEAVER                   EXIT REENTRANT ROUTINE
         EJECT
*
*       C3270 Subroutines here                                   *WSJW*
*
PARSERR  EQU   *
         LA    R15,256
         B     GETOUT
*
WCCP     EQU   *                  SETUP OUTPUT BUFFER
         MVI   0(R8),C'C'         WCC DEFAULT - RESET ONLY
         TM    CC+6,X'80'         WCC SPECIFIED?
         BNO   WPP                NO
         L     R7,CC              GET IT'S ADDRESS
         MVC   0(1,R8),0(R7)      MOVE IT
         OI    FLAGS,X'F0'        SET WRITE FLAG
WPP      LA    R8,1(,R8)          POINT PAST
         BR    R9
*
CLEARP   EQU   *                  SETUP OUTPUT BUFFER
         MVC   0(7,R8),=X'1140403C404000'  RA TO FILL SCRN W/NULLS
         OI    FLAGS,X'F0'        SET WRITE FLAG
         LA    R8,7(,R8)          POINT PAST
         BR    R9
*
RESETP   EQU   *
         ST    R9,L1LS
         MVI   0(R8),X'11'        goto lower right corner - 2    *WSJW*
         LH    R7,HEIGHT          R7 =  binary screen height     *WSJW*
         LH    R5,WIDTH           R5 =  binary screen width      *WSJW*
         SH    R5,=H'2'           lower right corner - 2         *WSJW*
         BAL   R9,CNVTADDR        get 3270 buff type addr        *WSJW*
         MVC   1(2,R8),BUFFI      move the addr                  *WSJW*
         MVI   3(R8),X'11'        SBA goes to lower right corner *WSJW*
         L     R7,LINE            R7 -> BINARY ROW NUMBER
         L     R7,0(R7)           R7 =   "      "    "
         LA    R5,1               R5 = 1
         BAL   R9,CNVTADDR        GET 3270 BUFF TYPE ADDR
         MVC   4(2,R8),BUFFI      MOVE THE ADDR
         LA    R8,6(,R8)          POINT PAST
         OI    FLAGS,X'F0'        SET WRITE FLAG
         L     R9,L1LS
         BR    R9                 RETURN
         SPACE 2                                                  WDPSC
RESETV   EQU   *                       VTAM RESET SUBRTN ADDED 8/3/83
         ST    R9,L1LS
         LR    R5,R15                  SAVE RC
         L     R7,LINE            R7 -> BINARY ROW NUMBER
         L     R7,0(R7)           R7 =   "      "    "
         STLINENO MODE=OFF,LINE=(R7)   TRY VTAM RESET         8/3/83
         LR    R15,R5                  RESTORE RC
         L     R9,L1LS
         BR    R9                 RETURN
         EJECT
MESSP    EQU   *
         ST    R9,L1LS
         MVI   0(R8),X'11'        SBA
         L     R7,MROW            R7 -> BINARY ROW NUMBER
         L     R7,0(R7)           R7 =   "      "    "
         L     R5,MCOL            R5 -> BINARY COL NUMBER
         L     R5,0(R5)           R5 =   "      "    "
         BAL   R9,CNVTADDR        GET 3270 BUFF TYPE ADDR
         MVC   1(2,R8),BUFFI      MOVE THE ADDR
         L     R7,MTEXT           GET TEXT ADDR R7-> TEXT
         LH    R6,MTEXT+4         GET TEXT LENGTH  R6= LEN
         BCTR  R6,R0              THEN EXECUTE     R6=R6-1
MOVE     MVC   3(0,R8),0(R7)      MOVE INSTRUCTION (EXECUTED)
         EX    R6,MOVE            MOVE TEXT
*
         LR    R5,R6              R5=LENGTH-1
         LA    R7,3(,R8)          R7->TRANS START
TRLOOP   EX    R5,TRANT           SCAN FOR Ö (CENT SIGN)
         BZ    TRDONE             NONE FOUND
         LR    R0,R1              remember R1                    *WSJW*
         TR    1(1,R1),TABLE2     TRANSLATE FOLLOWING CHAR
         TRT   1(1,R1),SBAEUARA   is it an SBA, EUA or RA order? *WSJW*
         BZ    NOCONVWR           no, nothing  to be converted   *WSJW*
         BCTR  R1,R0              yes, restore R1                *WSJW*
         CLC   WIDTH(2),=H'80'    screen width=80?               *WSJW*
         BNE   CONVWR             no, address must be converted  *WSJW*
         TM    ADDRMODE,TRANSADD  TRANSADD/TA specified?         *WSJW*
         BNO   NOCONVWR           no, don't convert address      *WSJW*
CONVWR   TM    ADDRMODE,TRANSADD  TRANSADD/TA specified?         *WSJW*
         BNO   *+12               no, do 80 to width mode        *WSJW*
         OI    TRANMODE,RCEB2BFR  yes, do EBCDIC to buffer mode  *WSJW*
         B     *+8                skip 80 to width mode          *WSJW*
         OI    TRANMODE,B802WDTH  translate 80 to width          *WSJW*
         BAL   R9,MULTITRN        translate address              *WSJW*
         LA    R1,2(,R1)          skip buffer address bytes      *WSJW*
NOCONVWR BCTR  R6,R0              R6=R6-1 update string length   *WSJW*
         LA    R7,1(,R1)          R7->NEW TRANS START
         LA    R5,4(R8,R6)        R5->NEW LAST CHAR
         SR    R0,R1              ..                   ..        *WSJW*
         AR    R1,R0               ..  adjust start   ..         *WSJW*
         LR    R9,R5                .. and length of ..          *WSJW*
         SR    R9,R0               ..  left shift     ..         *WSJW*
         SR    R9,R7              ..                   ..        *WSJW*
         SR    R5,R7              R5= NEW LENGTH
         BNP   TREX               NOT ENOUGH TO TRANSLATE
         EX    R9,TRMVC           shift string one to left       *WSJW*
         BCTR  R5,R0              R5=R5-1 UPDATE SCAN LENGTH
         B     TRLOOP             CHECK FOR MORE
TRANT    TRT   0(0,R7),TABLE3     EXECUTED TRANSLATE
TRMVC    MVC   0(0,R1),1(R1)      EXECUTED LEFT SHIFT
TREX     EX    R9,TRMVC           do left shift                  *WSJW*
TRDONE   LA    R8,4(R6,R8)        POINT PAST
         OI    FLAGS,X'F0'        SET WRITE FLAG
         L     R9,L1LS
         BR    R9                 RETURN
         EJECT
ICP      EQU   *
         ST    R9,L1LS
         L     R7,ICROW           R7 -> BINARY ROW NUMBER
         L     R7,0(R7)           R7 =   "      "    "
         L     R5,ICCOL           R5 -> BINARY COL NUMBER
         L     R5,0(R5)           R5 =   "      "    "
         BAL   R9,CNVTADDR        GET 3270 BUFF TYPE ADDR
         MVI   0(R8),X'11'        SBA
         MVC   1(2,R8),BUFFI      MOVE THE ADDR
         MVI   3(R8),X'13'        SAY IC
         LA    R8,4(,R8)          POINT PAST
         OI    FLAGS,X'F0'        SET WRITE FLAG
         L     R9,L1LS
         BR    R9                 RETURN
*
PUTSIZE  EQU   *                  return screen size to CLIST    *WSJW*
         XR    R15,R15            clear R15                      *WSJW*
         LR    R0,R9              remember R9                    *WSJW*
         LA    R7,=CL8'C3270ROW'  variable receiving rows        *WSJW*
         LA    R6,C3270ROW        address of rows value          *WSJW*
         BAL   R9,GTROWCOL        find CLIST variable C3270ROW   *WSJW*
         LA    R7,=CL8'C3270COL'  variable receiving columns     *WSJW*
         LA    R6,C3270COL        address of columns value       *WSJW*
         BAL   R9,GTROWCOL        find CLIST variable C3270COL   *WSJW*
         LR    R9,R0              restore R9                     *WSJW*
         LTR   R15,R15            all variables found?           *WSJW*
         BNZR  R9                 no, chicken out                *WSJW*
         L     R7,C3270ROW        address of C3270ROW variable   *WSJW*
         LH    R6,HEIGHT          get number of rows             *WSJW*
         CVD   R6,DWORD           convert to decimal             *WSJW*
         UNPK  0(3,R7),DWORD+5(3) convert to EBCDIC              *WSJW*
         OI    2(R7),X'F0'        fix sign                       *WSJW*
         L     R7,C3270COL        address of C3270COL variable   *WSJW*
         LH    R6,WIDTH           get number of columns          *WSJW*
         CVD   R6,DWORD           convert to decimal             *WSJW*
         UNPK  0(3,R7),DWORD+5(3) convert to EBCDIC              *WSJW*
         OI    2(R7),X'F0'        fix sign                       *WSJW*
         BR    R9                 return                         *WSJW*
*                                                                *WSJW*
SETLEN   EQU   *
         LA    R7,BUFFO           R7 -> BUFFO (R8->END OF BUFFO)
         SR    R8,R7              R8=BUFFER LENGTH OUT
         STH   R8,BUFFLO          SAVE IT IN BUFFLO
         MVC   BUFFLI(2),=H'256'  ALSO SET BUFFLI
         BR    R9                 RETURN
*
         EJECT
READTOP  EQU   *
         L     R5,CPPLECT         R5->ECT
         L     R5,4(,R5)          R5->IOSRL
         L     R4,0(,R5)          R4->TOP OF STACK
CKCLIST  TM    0(R4),X'08'        CLIST ELEMENT?
         BO    GOTCL              YES->WE HAVE A CLIST
         S     R4,=F'4'           R4=R4-4 (NEXT ELEMENT DOWN ON STACK)
         C     R4,4(,R5)          R4<BOTTOM OF STACK PTR?
         BNL   CKCLIST            NO ->STILL IN STACK; GO CHECK IT
         LA    R15,260            YES->R15=260=RC
         BR    R9                 EXIT READTOP WITH ERROR
GOTCL    L     R7,RDD             R7->VARIABLE NAME
         LH    R6,RDD+4           R6=VAR LENGTH FOR LENGTH COMPARE
         L     R5,0(,R4)          R5->LSD
         L     R5,12(,R5)         R5->EXECDATA
         L     R5,0(,R5)          R5->SNTAB
         L     R4,8(,R5)          R4==USED TABLE LENGTH
         LA    R4,0(R4,R5)        R4->END OF TABLE USED
         LA    R3,12(,R5)         R3->FIRST SNTAB ENTRY
         LR    R1,R6              R1=R6  VARIABLE NAME LENGTH
         BCTR  R1,R0              R1=R1-1 FOR EXECUTED COMPARE
*
RLOOP    LH    R2,6(,R3)          R2=NAME LENTH
         CR    R6,R2              SAME LENGTH?
         BNE   LOOPCHK            NO -> CHECK DONE
COMPARE  CLC   0(0,R7),8(R3)      EXECUTED
         EX    R1,COMPARE         COMPARE NAMES
         BE    GOTIT
LOOPCHK  LA    R3,8(R2,R3)        POINT TO NEXT ENTRY
         CR    R3,R4              DONE?
         BL    RLOOP              NO->CONTINUE
RERR     LA    R15,260       R15= RC=260
         BR    R9                 EXIT READTOP WITH ERROR
GOTIT    EQU   *
         L     R1,0(,R3)          GET VALUE ADDR
         ST    R1,VALADDR         SAVE IT
         OI    FLAGS,X'0F'        SET READ FLAG
         BR    R9                 RETURN
         EJECT
ERRCK    EQU   *
         BR    R9
*
GTROWCOL EQU   *                                                 *WSJW*
         L     R5,CPPLECT         R5->ECT                        *WSJW*
         L     R5,4(,R5)          R5->IOSRL                      *WSJW*
         L     R4,0(,R5)          R4->TOP OF STACK               *WSJW*
CKCLSIZE TM    0(R4),X'08'        CLIST ELEMENT?                 *WSJW*
         BO    GOTCSIZE           yes->we have a clist           *WSJW*
         S     R4,=F'4'           R4=R4-4 (next down on stack)   *WSJW*
         C     R4,4(,R5)          R4<bottom of stack ptr?        *WSJW*
         BNL   CKCLSIZE           no ->still in stack; check it  *WSJW*
         LA    R15,260            yes->R15=260=RC                *WSJW*
         BR    R9                 exit GTROWCOL with error       *WSJW*
GOTCSIZE L     R5,0(,R4)          R5->LSD                        *WSJW*
         L     R5,12(,R5)         R5->EXECDATA                   *WSJW*
         L     R5,0(,R5)          R5->SNTAB                      *WSJW*
         L     R4,8(,R5)          R4==used table length          *WSJW*
         LA    R4,0(R4,R5)        R4->end of table used          *WSJW*
         LA    R3,12(,R5)         R3->first sntab entry          *WSJW*
*                                                                *WSJW*
RLOOSIZE LH    R2,6(,R3)          R2=name lenth                  *WSJW*
         C     R2,=F'8'           same length?                   *WSJW*
         BNE   LOOPSIZE           no -> check done               *WSJW*
         CLC   0(8,R7),8(R3)      check name                     *WSJW*
         BE    GOTISIZE                                          *WSJW*
LOOPSIZE LA    R3,8(R2,R3)        point to next entry            *WSJW*
         CR    R3,R4              done?                          *WSJW*
         BL    RLOOSIZE           no->continue                   *WSJW*
         LA    R15,260            R15=RC=260                     *WSJW*
         BR    R9                 exit GTROWCOL with error       *WSJW*
GOTISIZE EQU   *                                                 *WSJW*
         L     R1,0(,R3)          get value addr                 *WSJW*
         LH    R3,2(,R1)          get size of variable           *WSJW*
         CH    R3,=H'3'           must be three characters       *WSJW*
         BE    *+10               it is, return address          *WSJW*
         LA    R15,260            it isn't, indicate error       *WSJW*
         BR    R9                 return                         *WSJW*
         LA    R1,4(,R1)          three byte value starts here   *WSJW*
         ST    R1,0(,R6)          store address                  *WSJW*
         BR    R9                 return                         *WSJW*
         EJECT                                                   *WSJW*
*                                                                *WSJW*
SETRC    EQU   *
         IC    R15,BUFFI          PICK UP AID BYTE IN R15
         BR    R9                 RETURN
*
SETVAR   EQU   *
         ST    R9,L2LS            remember R9                    *WSJW*
         L     R7,VALADDR         R7->VALUE TABLE ENTRY
         LH    R8,BUFFLI          GET INPUT LENGTH
         CH    R8,=H'3'           LEN > 3 ?
         BNH   SETNULL            NO -> SET VARIABLE TO NULL
         SH    R8,=H'3'           R8=R8-3  SKIP AID,CURSOR ADDR
         LA    R6,BUFFI+3         PT PAST  "
         CLI   AI+1,X'00'         AI ENTERED?
         BNE   CNVCHKRD           yes -> leave SBA in            *WSJW*
         CLI   0(R6),X'11'        SBA START MESSAGE?
         BNE   CNVCHKRD           no -> assume it's data         *WSJW*
         LA    R6,3(,R6)          R6=R6+3  SKIP SBA,ADDR
         SH    R8,=H'3'           AND FIX LENGTH
         BNP   SETNULL            IN CASE?
CNVCHKRD CLC   WIDTH(2),=H'80'    screen width=80?               *WSJW*
         BNE   CONVRD             no, address conversion req'd   *WSJW*
         TM    ADDRMODE,TRANSADD  TRANSADD/TA specified?         *WSJW*
         BNO   ROOMCHK            no, don't convert addresses    *WSJW*
CONVRD   TM    ADDRMODE,TRANSADD  TRANSADD/TA specified?         *WSJW*
         BNO   *+12               no, do width to 80 mode        *WSJW*
         OI    TRANMODE,BFR2RCEB  yes, do buffer to EBCDIC mode  *WSJW*
         B     *+8                skip width to 80 mode          *WSJW*
         OI    TRANMODE,BWDTH280  translate width to 80          *WSJW*
         LR    R4,R6              start of input data            *WSJW*
         LR    R5,R8              length of input data           *WSJW*
         BCTR  R5,R0              decrement length for EXecute   *WSJW*
FNDSBARD EX    R5,EXFNDSBA        SBA order in input data?       *WSJW*
         BZ    ROOMCHK            no, nothing to be translated   *WSJW*
         SR    R4,R1              negative offset to SBA order   *WSJW*
         AR    R5,R4              residual count                 *WSJW*
         SH    R5,=H'3'           skip order and address bytes   *WSJW*
         LA    R4,3(,R1)          new start of SBA scan          *WSJW*
         BAL   R9,MULTITRN        translate address              *WSJW*
         B     FNDSBARD           continue scan                  *WSJW*
ROOMCHK  NI    TRANMODE,X'00'     reset translate mode flags     *WSJW*
         CH    R8,2(,R7)          room for input?                *WSJW*
         BNH   SM                 YES->MOVE IT.
         LH    R8,2(,R7)          NO ->GET HIS LENGTH
SM       STH   R8,0(,R7)          STORE CORRECT LENGTH
         BCTR  R8,R0              R8=R8-1
         EX    R8,EXTRAN          translate input (SBA)          *WSJW*
         EX    R8,SMOVE           MOVE IT
         L     R9,L2LS            restore R9                     *WSJW*
         BR    R9
SMOVE    MVC   4(0,R7),0(R6)      EXECUTED
EXTRAN   TR    0(0,R6),TRINPUT    executed                       *WSJW*
EXFNDSBA TRT   0(1,R4),SBAEUARA   is it an SBA order? executed   *WSJW*
SETNULL  SLR   R8,R8              R8=0
         STH   R8,0(,R7)          STORE ZERO LENGTH
         BR    R9                 RETURN
         EJECT
*
CNVTADDR EQU   *                  change row/column binary to    *WSJW*
*                                 3270 buffer address            *WSJW*
*                                                                *WSJW*
*                                 R7 = ROW , R5 = COL
*                                                                *WSJW*
         ST    R9,L2LS            remember R9                    *WSJW*
         OI    TRANMODE,RC2BFR    indicate translate row/column  *WSJW*
         BAL   R9,MULTITRN        translate address              *WSJW*
         L     R9,L2LS            restore R9                     *WSJW*
         BR    R9
*
         EJECT
*                                                                *WSJW*
MULTITRN EQU   *                  do all address translations    *WSJW*
*                                                                *WSJW*
*                                                                *WSJW*
*                                                                *WSJW*
         STM   R0,R9,SAVEAREA+16  save registers                 *WSJW*
*                                                                *WSJW*
         TM    TRANMODE,B802WDTH  80 to width buffer addresses?  *WSJW*
         BNO   W28                no, check next translation     *WSJW*
         LA    R1,2(,R1)          point to 3270 buffer address   *WSJW*
         LH    R0,=H'80'          get standard terminal width    *WSJW*
         BAL   R9,BA2BIN          convert to binary              *WSJW*
         LH    R0,WIDTH           get current terminal width     *WSJW*
         BAL   R9,BIN2BA          convert to new buffer address  *WSJW*
         NI    TRANMODE,X'00'     reset translate mode flags     *WSJW*
         B     MULTRTRN           return                         *WSJW*
*                                                                *WSJW*
W28      TM    TRANMODE,BWDTH280  width to 80 buffer addresses?  *WSJW*
         BNO   R2B                no, check next translation     *WSJW*
         LA    R1,1(,R1)          point to 3270 buffer address   *WSJW*
         LH    R0,WIDTH           get current terminal width     *WSJW*
         BAL   R9,BA2BIN          convert to binary              *WSJW*
         LH    R0,=H'80'          get standard terminal width    *WSJW*
         BAL   R9,BIN2BA          convert to new buffer address  *WSJW*
         B     MULTRTRN           return                         *WSJW*
*                                                                *WSJW*
R2B      TM    TRANMODE,RC2BFR    row/column to buffer?          *WSJW*
         BNO   E2B                no, check next translation     *WSJW*
         LH    R0,WIDTH           get current terminal width     *WSJW*
         LA    R1,BUFFI           buffer address goes here       *WSJW*
         BCTR  R7,R0              R7=R7-1                        *WSJW*
         BCTR  R5,R0              R5=R5-1                        *WSJW*
         LR    R3,R7              row number                     *WSJW*
         LR    R4,R5              column number                  *WSJW*
         BAL   R9,BIN2BA          convert to new buffer address  *WSJW*
         NI    TRANMODE,X'00'     reset translate mode flags     *WSJW*
         B     MULTRTRN           return                         *WSJW*
*                                                                *WSJW*
E2B      TM    TRANMODE,RCEB2BFR  row/column EBC to buffer?      *WSJW*
         BNO   B2E                no, check next translation     *WSJW*
         PACK  DWORD(8),2(3,R1)   convert row to decimal ..      *WSJW*
         CVB   R3,DWORD            .. then to binary             *WSJW*
         BCTR  R3,R0              count rows from zero           *WSJW*
         PACK  DWORD(8),5(3,R1)   convert column to decimal ..   *WSJW*
         CVB   R4,DWORD            .. then to binary             *WSJW*
         BCTR  R4,R0              count columns from zero        *WSJW*
         LA    R1,2(,R1)          point to buffer address target *WSJW*
         LH    R0,WIDTH           get current terminal width     *WSJW*
         BAL   R9,BIN2BA          convert to 3270 buffer address *WSJW*
         LM    R0,R9,SAVEAREA+16  restore registers              *WSJW*
         SH    R6,=H'4'           R6=R6-4 update string length   *WSJW*
         ST    R6,SAVEAREA+40     remember new length and start  *WSJW*
         LA    R7,4(,R1)          point after buffer address     *WSJW*
         LA    R5,4(R8,R6)        R5->new last char              *WSJW*
         SR    R5,R7              R5= new length                 *WSJW*
         BM    *+8                nothing to move                *WSJW*
         EX    R5,SHBUFFO         shift string four to the left  *WSJW*
         NI    TRANMODE,X'00'     reset translate mode flags     *WSJW*
         B     MULTRTRN           return                         *WSJW*
*                                                                *WSJW*
B2E      TM    TRANMODE,BFR2RCEB  buffer to row/column EBC?      *WSJW*
         BNO   MULTRTRN           no, return                     *WSJW*
         EX    R5,CPBUFFI         shift input buffer ..          *WSJW*
         EX    R5,SHBUFFI          .. 4 bytes to the right       *WSJW*
         LA    R4,4(,R4)          adjust next SBA search start   *WSJW*
         LA    R8,4(,R8)          adjust total length of input   *WSJW*
         ST    R4,SAVEAREA+32     remember new search start      *WSJW*
         ST    R8,SAVEAREA+48     remember new length            *WSJW*
         LA    R1,1(,R1)          point to 3270 buffer address   *WSJW*
         LH    R0,WIDTH           get current terminal width     *WSJW*
         BAL   R9,BA2BIN          convert to binary              *WSJW*
         LA    R3,1(,R3)          count rows from one            *WSJW*
         CVD   R3,DWORD           convert row to decimal ..      *WSJW*
         UNPK  0(3,R1),DWORD+5(3)  .. then to EBCDIC             *WSJW*
         OI    2(R1),X'F0'        fix sign                       *WSJW*
         LA    R4,1(,R4)          count columns from one         *WSJW*
         CVD   R4,DWORD           convert column to decimal ..   *WSJW*
         UNPK  3(3,R1),DWORD+5(3)  .. then to EBCDIC             *WSJW*
         OI    5(R1),X'F0'        fix sign                       *WSJW*
*                                                                *WSJW*
MULTRTRN LM    R0,R9,SAVEAREA+16  restore registers              *WSJW*
         BR    R9                 return                         *WSJW*
*                                                                *WSJW*
CPBUFFI  MVC   BUFFO(1),0(R4)     shift input buffer 4 bytes ..  *WSJW*
SHBUFFI  MVC   4(1,R4),BUFFO       .. to the right (EXecuted)    *WSJW*
SHBUFFO  MVC   4(1,R1),8(R1)      shift output buffer 4 bytes .. *WSJW*
*                                  .. to the left (EXecuted)     *WSJW*
*                                                                *WSJW*
BA2BIN   TM    0(R1),AMODE12      12-bit buffer address?         *WSJW*
         BO    BA12BIT            yes, do original addressing    *WSJW*
         XR    R3,R3              no, get 3270 buffer ..         *WSJW*
         ICM   R3,X'3',0(R1)        .. address into R3 directly  *WSJW*
         B     BA14BIT            no conversion to be done       *WSJW*
BA12BIT  XR    R2,R2              get 3270 buffer ..             *WSJW*
         ICM   R2,X'3',0(R1)        .. address into R2           *WSJW*
         SRDL  R2,6               shift low-order 6 bits -> R3   *WSJW*
         SRL   R2,2               drop 2 bits                    *WSJW*
         SRDL  R2,6               shift high-order 6 bits -> R3  *WSJW*
         SRL   R3,20              move all 12 bits down to 20-31 *WSJW*
BA14BIT  XR    R2,R2              clear R2                       *WSJW*
         DR    R2,R0              divide binary address by width *WSJW*
         LR    R4,R2              remember column number         *WSJW*
         XR    R2,R2              clear R2, line number is in R3 *WSJW*
         BR    R9                 return                         *WSJW*
*                                                                *WSJW*
BIN2BA   MR    R2,R0              multiply line with width       *WSJW*
         AR    R3,R4              add column, R3=new address now *WSJW*
         CH    R3,=H'4095'        location greater than 4k?      *WSJW*
         BH    BI14BIT            yes, no conversion to be done  *WSJW*
         STC   R3,DWORD+1         no, do original addressing     *WSJW*
         NI    DWORD+1,B'00111111' low-order 6 bits of address   *WSJW*
         SRL   R3,6               drop low-order 6 bits from R3  *WSJW*
         STC   R3,DWORD           get high-order six-bit number  *WSJW*
         TR    DWORD(2),TABLE     convert to 3270 address chars  *WSJW*
         ICM   R3,X'3',DWORD      save in bottom two bytes of R3 *WSJW*
BI14BIT  STCM  R3,X'3',0(R1)      replace 3270 buffer address    *WSJW*
         BR    R9                 return                         *WSJW*
*                                                                *WSJW*
         EJECT                                                   *WSJW*
*
*        STATIC WORKAREA
*
TABLE    DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'               *WSJW*
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'               *WSJW*
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'               *WSJW*
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'               *WSJW*
*                                                                *WSJW*
TABLE1   DC    C' ABCDEFGHIÖ.<(+×&&JKLMNOPQR!$*);^'
         DC    C'-/STUVWXYZ ,%_>?0123456789:#@''="'
         ORG   TABLE1+X'2A'
         DC    X'6A'
         ORG
*
*  TRANSLATE CHARS PRECEEDED BY A CENT SIGN (Ö)
*
*            3270                      TSO
*        Ö_ -> IC  (13)            Ö< -> (  (4D)
*        Ö- -> SBA (11)            Ö> -> )  (5D)
*        Ö× -> SF  (1D)            Ö" -> '  (7D)
*        Ö* -> NULL(00)            Ö/ -> ^  (5F)
*        Ö# -> RA  (3C)            ÖÖ -> Ö  (4A)   CENT SIGN
*        Ö@ -> EUA (12)            ÖA ->    (6A)   BROKEN VERT BAR
*        Ö. -> PT  (05)            ÖB -> ,  (6B)
*            3279
*        Ö$ -> SFE (29) SF EXTNDED Ö1 ->    (01)
*        Ö% -> MF  (2C) MOD FLD    Ö2 ->    (02)
*        ÖS -> SA  (28) SET ATTR   Ö3 ->    (03)
*        ÖC ->     (42) COLOR      Ö4 ->    (04)
*        ÖH ->     (41) HIGHLITE   Ö5 ->    (05)
*        ÖG ->     (43) SYM SET    Ö6 ->    (06)
*                                  Ö7 ->    (07)
*                                  Ö8 ->    (08)
*                                  Ö9 ->    (09)
*                                  Ö  ->    (0A)
*                                  Ö  ->    (0B)
*                                  Ö  ->    (0C)
*                                  Ö  ->    (0D)
*                                  Ö  ->    (0E)
*                                  Ö  ->    (0F)
*
TABLE2   DC    X'000102030405060708090A0B0C0D0E0F'
         DC    X'101112131415161718191A1B1C1D1E1F'
         DC    X'202122232425262728292A2B2C2D2E2F'
         DC    X'303132333435363738393A3B3C3D3E3F'
         DC    X'404142434445464748494A054D4D4E1D'   05 4D 1D
         DC    X'505152535455565758595A29005D5E5F'   29 00
         DC    X'115F62636465666768696A6B2C135D6F'   11 5F 13 5D 2C
         DC    X'707172737475767778797A3C127D7E7D'   3C 12 7D
         DC    X'808182838485868788898A8B8C8D8E8F'
         DC    X'909192939495969798999A9B9C9D9E9F'
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    X'C06A6B42C4C5C64341C9CACBCCCDCECF'   6A 6B 42 43 41
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    X'E0E128E3E4E5E6E7E8E9EAEBECEDEEEF'   28
         DC    X'000102030405060708090A0B0C0D0E0F'
         EJECT
TABLE3   DC    XL256'00'
         ORG   TABLE3+74
         DC    X'04'
         ORG
*
TRINPUT  DC    256AL1(*-TRINPUT)                                 *WSJW*
         ORG   TRINPUT+X'11'                                     *WSJW*
         DC    X'4F'                                             *WSJW*
         ORG   ,                                                 *WSJW*
*                                                                *WSJW*
SBAEUARA DC    256X'00'                                          *WSJW*
         ORG   SBAEUARA+X'11'                                    *WSJW*
         DC    X'11'                 set buffer address          *WSJW*
         DC    X'12'                 erase unprotected to addr.  *WSJW*
         ORG   SBAEUARA+X'3C'                                    *WSJW*
         DC    X'3C'                 repeat to address           *WSJW*
         ORG   ,                                                 *WSJW*
*                                                                *WSJW*
BUFWR    TPUT  ,,NOEDIT,,HOLD,MF=L   noedit TPUT skeleton        *WSJW*
BUFWRL   EQU   *-BUFWR                                           *WSJW*
*                                                                *WSJW*
PTCHAREA DC    XL128'00'
*
AMODE12  EQU   X'40'                 indicator for 12-bit ..     *WSJW*
*                                     .. 3270 buffer addresses   *WSJW*
         LTORG
         EJECT
*
*   WORKING STORAGE AREA - DYNAMIC
*
WORKAREA DSECT
SAVEAREA DS    18F
PARML    CALL  ,(IOPARM,BUFFLO,BUFFO,BUFFLI,BUFFI),MF=L
*
IOPARM   DS    X
BUFFLO   DS    H
BUFFLI   DS    H
         DS    0F
BUFFO    DS    CL256
BUFFI    DS    CL256
*
FLAGS    DC    F'0'
L1LS     DC    F'0'
L2LS     DC    F'0'                  return address stack        *WSJW*
VALADDR  DC    F'0'
ANS      DC    F'0'
ECB      DC    F'0'
PPLA     DS    7F
BUFWRLST DS    0D                    noedit TPUT parameter list  *WSJW*
         ORG   *+BUFWRL                                          *WSJW*
*                                                                *WSJW*
PROTOCOL DS    X                     TPUT protocol flag          *WSJW*
NOEDIT   EQU   X'01'                  use TPUT NOEDIT            *WSJW*
*                                                                *WSJW*
ADDRMODE DS    X                     3270 buffer addressing mode *WSJW*
TRANSADD EQU   X'01'                  translate buffer addresses *WSJW*
*                                                                *WSJW*
TRANMODE DS    X                     translation control flags   *WSJW*
B802WDTH EQU   X'01'                  80 to width buffer address *WSJW*
BWDTH280 EQU   X'02'                  width to 80 buffer address *WSJW*
RC2BFR   EQU   X'04'                  row/column to buffer       *WSJW*
TRMDRSVD EQU   X'08'                  reserved                   *WSJW*
RCEB2BFR EQU   X'10'                  row/column EBC to buffer   *WSJW*
BFR2RCEB EQU   X'20'                  buffer to row/column EBC   *WSJW*
*                                                                *WSJW*
HEIGHT   DS    H                     screen height (rows)        *WSJW*
WIDTH    DS    H                     screen width (columns)      *WSJW*
C3270ROW DS    F                     variable C3270ROW address   *WSJW*
C3270COL DS    F                     variable C3270COL address   *WSJW*
DWORD    DS    D                     for format conversions      *WSJW*
WORKLEN  EQU   *-WORKAREA
C3270    CSECT ,                                                 *WSJW*
         EJECT
*
PCL      IKJPARM
CLEAR    IKJKEYWD
         IKJNAME   'CLEAR',ALIAS=('CL','C')
WCC      IKJKEYWD
         IKJNAME   'WCC',SUBFLD=CCFLD,ALIAS=('W','CC')
RESET    IKJKEYWD
         IKJNAME   'RESET',SUBFLD=LINEFLD,ALIAS=('RES','R')
MESS     IKJKEYWD
         IKJNAME   'MESSAGE',SUBFLD=MFLD,ALIAS=('MESS','MSG','M')
IC       IKJKEYWD
         IKJNAME   'IC',SUBFLD=ICFLD,ALIAS=('CURSOR','CUR','I')
READTO   IKJKEYWD
         IKJNAME   'READTO',SUBFLD=RDFLD,ALIAS=('READ','RT')
AI       IKJKEYWD
         IKJNAME   'AI',ALIAS=('ASIS')
GS       IKJKEYWD  ,                                             *WSJW*
         IKJNAME   'GS',ALIAS=('GETSIZE')                        *WSJW*
TA       IKJKEYWD  ,                                             *WSJW*
         IKJNAME   'TA',ALIAS=('TRANSADD')                       *WSJW*
NE       IKJKEYWD  ,                                             *WSJW*
         IKJNAME   'NE',ALIAS=('NOEDIT')                         *WSJW*
*  SUBFIELD DESCRIPTIONS FOLLOW
CCFLD    IKJSUBF
CC       IKJIDENT 'WCC',MAXLNTH=2,PROMPT='WCC',CHAR
*
LINEFLD  IKJSUBF
LINE     IKJIDENT 'RESET LINE NO',DEFAULT='1',INTEG
*
MFLD     IKJSUBF
MROW     IKJIDENT 'MSG ROW',MAXLNTH=3,PROMPT='MSG ROW',INTEG     *WSJW*
MCOL     IKJIDENT 'MSG COL',MAXLNTH=3,PROMPT='MSG COL',INTEG     *WSJW*
MTEXT    IKJIDENT 'MSG TEXT',PROMPT='MSG TEXT',CHAR
*
ICFLD    IKJSUBF
ICROW    IKJIDENT 'IC ROW',MAXLNTH=3,PROMPT='IC ROW',INTEG       *WSJW*
ICCOL    IKJIDENT 'IC COL',MAXLNTH=3,PROMPT='IC COL',INTEG       *WSJW*
*
RDFLD    IKJSUBF
RDD      IKJIDENT 'INPUT VARIABLE',PROMPT='INPUT VARIABLE',CHAR
         IKJENDP
         TITLE 'FULLSCRN - 3270 I/O SUBROUTINE'
*          DATA SET 761KKFSCRN AT LEVEL 002 AS OF 06/07/78
*  AUTHOR: KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC).
*          (206) 902-3119
FULLSCRN CSECT
FULLSC   DS    0H
         ENTRY FULLSC
         SAVE  (14,12),,*         HO-HUM
         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING
         USING FULLSCRN,R12
*
*   GET THE INPUT PARAMETERS:
*           CALL 'FULLSCRN' USING IOPARM OUTLEN OUTBUFF /RETLEN/
*                                        INLEN  INBUFF  /RETLEN/ .
*
*  OUTBUFF:  ESC/COM/WCC/SBA/ADDR/SF/ATTR/TEXT/IC
*  INBUFF :  AID/CURSOR-ADDR/SBA/ADDR/TEXT/..SBA/ADDR/TEXT....
*
GETPARMS LR    R11,R1             SAVE THE PARM POINTER
         L     R10,0(R11)         R10 -> IOFLAG
         L     R8,4(R11)          R8  -> OUT BUFFLEN
         LH    R8,0(R8)           R8  =  OUT BUFFLEN
         L     R7,8(R11)          R7  -> OUT BUFFADDR
         N     R7,=X'00FFFFFF'    FIX ADDR (REMOVE VL FLAG)
         SLR   R4,R4              R4=0
         TM    8(R11),X'80'       MORE?
         BO    SAMEIN             NO.
*
LENCH    TM    12(R11),X'80'      ONE MORE PARM?
         BNO   MOREIN             NO-> MAYBE TWO
         L     R4,12(R11)         R4->RETURN LENGTH BUFFER
         B     SAMEIN             GO ON
MOREIN   TM    16(R11),X'80'      TWO MORE PARMS?
         BO    DIFFIN             YES->INPUT PARMS ONLY
         L     R4,20(,R11)        NO-> R4 -> RET LEN BUFFER
*
DIFFIN   L     R9,12(R11)         R9  -> IN BUFFLEN
         LH    R6,0(R9)           R6  =  BUFFLEN
         L     R5,16(R11)         R5  -> IN BUFFADDR
         B     RETCH
SAMEIN   L     R9,4(R11)          R9  -> IN BUFFLEN
         LH    R6,0(R9)           R6  =  BUFFLEN
         LR    R5,R7              R5  -> IN BUFFADDR
*
RETCH    LTR   R4,R4              R4=0 STILL?
         BNZ   WRITECHK           NO->LEAVE IT THEN
         LR    R4,R9              R4->RET LEN BUFF (COMPATIBLE W/OLD)
         EJECT
*
*   CHECK FOR A WRITE
*
WRITECHK SLR   R3,R3              R3=0
         CLI   0(R10),C'O'        OUTPUT?
         BE    EDITCHK            yes.                           *WSJW*
         CLI   0(R10),C'B'        BOTH INPUT AND OUT?
         BNE   READCHK            NO.
EDITCHK  TM    PROTOCOL,NOEDIT    use TPUT NOEDIT?               *WSJW*
         BZ    FSCWRITE           no, skip keyboard handling     *WSJW*
         NI    1(R7),B'11111101'  don't restore keyboard         *WSJW*
         CLI   0(R10),C'B'        both input and out?            *WSJW*
         BNE   BUFFRITE           yes, skip keyboard restore     *WSJW*
         OI    1(R7),B'00000010'  restore keyboard               *WSJW*
         B     BUFFRITE           VTAM output                    *WSJW*
FSCWRITE TPUT  (R7),(R8),FULLSCR,,HOLD   use TPUT FULLSCR        *WSJW*
         B     OUTDONE            continue                       *WSJW*
BUFFRITE TPUT  (R7),(R8),MF=(E,BUFWRLST) use TPUT NOEDIT         *WSJW*
OUTDONE  LR    R3,R15             R3  =  RET CODE
         SLR   R15,R15            R15 CLEARED
*
*   CHECK FOR A READ
*
READCHK  CLI   0(R10),C'I'        INPUT?
         BE    BUFFREAD           YES.
         CLI   0(R10),C'B'        BOTH INPUT AND OUT?
         BNE   FINISH             NO.
BUFFREAD TM    PROTOCOL,NOEDIT    use NOEDIT on input?           *WSJW*
         BZ    JUSTREAD           no, just read                  *WSJW*
         STFSMODE ON,NOEDIT=YES   don't edit input stream        *WSJW*
JUSTREAD TGET  (R5),(R6),ASIS     get what we can                *WSJW*
         LR    R5,R15             remember return code           *WSJW*
         STH   R1,0(,R4)          give him the length            *WSJW*
         TM    PROTOCOL,NOEDIT    NOEDIT used on input?          *WSJW*
         BZ    READIT             no, continue                   *WSJW*
         STFSMODE OFF             back to normal input editing   *WSJW*
         CH    R5,=H'24'          ..    translate        ..      *WSJW*
         BNE   *+12                ..   NOEDIT=YES      ..       *WSJW*
         LA    R5,0                 ..  return codes   ..        *WSJW*
         B     READIT                .. to the        ..         *WSJW*
         CH    R5,=H'28'            ..  corresponding  ..        *WSJW*
         BNE   READIT              ..   NOEDIT=NO       ..       *WSJW*
         LA    R5,12              ..    values           ..      *WSJW*
READIT LR      R15,R5             restore return code            *WSJW*
*
*   RETURN
*
FINISH   SLL   R15,8(0) SAVE TGET RETURN CODE
         OR    R15,R3    GET TPUT RETURN CODE
EXIT     RETURN (14,12),RC=(15)   QUIT
         EJECT
         LTORG
         END
