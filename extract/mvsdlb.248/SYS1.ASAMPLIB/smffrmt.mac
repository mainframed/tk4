 /*  SMFFRMT - SMF RECORD PRINT ROUTINE  */
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = SMFFRMT
*01*  STATUS = CHANGE LEVEL 03                               @ZA05513*/
 /*    A207418-207465                                          Y01018*/
 /*    C055000,055100,060000,061500,207373,207799,208047       Y01018*/
 /*    D207947                                                 Y01018*/
 /*    C056500,266000                                          Y02034*/
 /*    A265600-265960,072600-072640,182000-184500,186600-186800Y02034*/
 /*    C263333,263500                                          Y02113*/
 /*    A068999-069331,253700-253996,266000-266420              Y02113*/
 /*    C045000,051500                                          Y02150*/
 /*    A069332-069442,266440-266831                            Y02150*/
 /*    C010500-011500,028000,030000,044000,052000,060500-062500Y02120*/
 /*    C067500-068000,108500,110000,114000,115500,127500,131000Y02120*/
 /*    C158500,173000,182000,254500-255000                     Y02120*/
 /*    A030100-030300,068520-068998,253504-253604              Y02120*/
 /*    D109000-109500,114500-115000,128000,131500,182500-185000Y02120*/
 /*    C048500,058500                                          Y02120*/
 /*    A058600                                                 Y02120*/
 /*    C046500-048000,063000-064500,243600,244600,250600,251600Y02133*/
 /*    A244000,245000-245400,251000,252000-252400              Y02133*/
 /*    D265500                                                 Y02113*/
 /*    A253728-253799                                        @YM04143*/
 /*    D242500-243000,243520,244500-245300,245500            @YM04143*/
 /*    D249500-250000,250520,251500,252400                   @YM04143*/
 /*    C011100,048500-048600,058500-058700,067000,068560     @YM04143*/
 /*    C061500,068600-068700,069332-069432,246100            @YM04143*/
 /*    C253569-253708                                        @YM04143*/
 /*    A129200,132600,132700,147100                          @ZA01928*/
 /*    C002500,026500,027000,027000,132500                   @ZA01928*/
 /*
*01*  DESCRIPTIVE-NAME = SMF RECORD PRINT ROUTINE
*01*  FUNCTION = THIS PROGRAM READS THE SMF RECORDS FROM TAPE AND
*     PRINTS
*     THEM IN THE FOLLOWING MANNER. THE SMF HEADER IS SEPARATED INTO
*     ITS
*     FOUR BIT HEXIDECIMAL VALUES.  EACH VALUE IS THEN CONVERTED INTO
*     EBCDIC NOTATION FOR PRINTING. EACH FIELD OF THE HEADER IS */ /*
*     SEPARATED FROM THE NEXT BY BLANKS FOR EASY REFERENCE. THE HEADER
*     IS THEN SCANNED FOR NON-ALPHANUMERIC CHARACTERS AND THESE ARE
*     REPLACED BY '.'.  THE ALPANUMERIC TRANSLATION IS THEN PRINTED TO
*     THE SIDE OF THE HEXIDECIMAL PRINT LINE.  THE FOLLOWING
*     SMF RECORDS MAY BE PRINTED.  RECORD TYPES 0, 2, 3, 7, 9, 10, 11,
*     17-22.  SMF RECORD
*     TYPES MAY BE PRINTED SELECTIVELY.  BY PASSING THE RECORD TYPES
*     DESIRED, SEPARATED BY COMMAS, TO THE PROGRAM AS PARAMETERS THE
*     PROGRAM WILL PRINT ONLY THOSE RECORD TYPES SPECIFIED.  IF NO
*     PARAMETERS ARE SPECIFIED THEN ALL VALID TYPES ARE PRINTED.  IF AN
*     INVALID RECORD TYPE IS SELECTED THE PROGRAM WILL PRINT A WARNING
*     MESSAGE,'RECORD TYPE XX IS NOT SUPPORTED BY THIS SAMPLE ROUTINE'
*
*     THE PROGRAM WILL CONTINUE WITH OTHER RECORD TYPES AS SELECTED.
*02*    RESTRICTIONS = PL/I RESTRICTS PROGRAM PARAMETERS TO 100
*       CHARACTERS.  THE INPUT RECORD LENGTH OF ALL SMF RECORDS HAS
*       BEEN
*       SET TO 4000 CHARACTERS.  IF THIS LENGTH IS NOT LONG ENOUGH TO
*       HANDLE ALL TYPES THEN THE FOLLOWING CHANGES MUST BE MADE WHEN
*       THE LENGTH IS INCREASED.  VARIABLES RECORD, BUFFER, AND HEX
*       MUST
*       BE INCREASED PROPORTIONATELY.
*02*    PROCESSOR = PL/1
*02*    MODULE-SIZE = 29818 BYTES
*02*    ATTRIBUTES = REUSABLE
*01*  ENTRY = SMFFRMT
*02*    INPUT = PARAMETER LIST OF SELECTED SMF RECORD TYPES
*02*    OUTPUT = HEXIDECIMAL AND EBCDIC RECORD PRINTOUT OF SELECTED SMF
*       RECORDS
**** END OF SPECIFICATIONS ***/
 SMFFRMT:  PROCEDURE (PARM_STRING) OPTIONS (MAIN);

   DECLARE
       PARM_STRING CHAR (100) VARYING,  /* THIS CHARACTER STRING
           CONTAINS THE RECORD TYPES TO BE SELECTED FROM THE SMF DATA
           TAPE.  IT IS RESTRICTED TO 100 CHARACTERS BY THE PL/1
           COMPILER. EACH TYPE MUST BE SEPARATED BY A COMMA. @ZA01928*/

       PARM_NUMBER (0:74) CHAR (2) VARYING INIT
          ('0','1','2','3','4','5','6',
           '7','8','9','10','11','12','13','14','15','16','17','18',
          '19','20','21','22','23','24','25','26','27','28','29','30',
          '31','32','33','34','35','36','37','38','39','40','41','42',
          '43','44','45','46','47','48','49','50','51','52','53','54',
          '55','56','57','58','59','60','61','62','63','64','65','66',
          '67','68','69','70','71','72','73','74'),
    /*   THIS TABLE CONTAINS ALL OF THE RECORD TYPES ACCEPTED BY     */
    /*    THIS PROGRAM                                               */

       START FIXED BINARY (15,0),  /* PARAMETER STRING POINTER       */

       PARM_LENGTH FIXED BINARY (15,0),  /* LENGTH OF PARAMETER      */

       REPORT FILE RECORD OUTPUT,    /* OUTPUT FILE FOR SMF RECORDS  */

       VALUE CHAR (3) VARYING,            /* PARAMETER ITEM -  THIS
          LENGTH SHOULD BE 1 MORE THAN THE LENGTH OF PARM_LENGTH
          TO PROTECT AGAINST TRUNCATION MATCHES  */

       PLACE FIXED BINARY (15,0),  /* POSITION VALUE RETURNED FROM
           THE BUILT-IN FUNCTION INDEX  */

       TYPE_TABLE (0:74) FIXED BINARY (15,0),  /*  THIS TABLE CONTAINS
           SWITCHES FOR EACH OF THE RECORD TYPES.  A VALUE OF ONE
           INDICATES THAT TYPE IS TO BE PROCESSED AND A VALUE OF ZERO
           INDICATES THAT TYPE IS TO BE IGNORED.  */

    /*  FIELD_TABLE CONTAINS THE BYTE LENGTHS OF THE VARIOUS FIELDS  */
    /*  FOR EACH RECORD TYPE.  6666 OR 7777 IS USED TO INDICATE A    */
    /*  VARIABLE LENGTH FIELD AND IS PROCESSED EXCEPTIONALLY         */
    /*  DEPENDING ON RECORD TYPE    8888 IS USED TO                  */
    /*  INDICATE THAT THE PARTICULAR RECORD TYPE IS UNDEFINED.       */
    /*  9999 TERMINATES TABLE ENTRIES FOR THAT TYPE RECORD           */
    /*  NOTE - IN EXCEPTIONAL PROCESSING SOME RECORDS HAVE A         */
    /*  VARIABLE NUMBER OF FIXED LENGTH FIELDS TO PRINT.  THE        */
    /*  LIMIT ON THE NUMBER OF PRINTABLE FOR ANY RECORD IS 32 DUE    */
    /*  TO THE TABLE DEFINITION.  THEREFORE A RECORD HAVING ENOUGH   */
    /*  OF THESE FIELDS TO CAUSE AN OVERRUN INTO THE NEXT ENTRY      */
    /*  WILL NOT HAVE THOSE FIELDS PRINTED THAT WOULD CAUSE AN       */
    /*  OVERRUN.                                                     */
       FIELD_TABLE (0:74,32) FIXED BINARY (15,0) INIT (
              4,4,4,1,4,9999,(26)*,                        /* REC 0  */
              8888,(31)*,                                  /* REC 1  */
              9999,(31)*,                                  /* REC 2  */
              9999,(31)*,                                  /* REC 3  */
              8888,(31)*,                                  /* REC 4  */
              8888,(31)*,                                  /* REC 5  */
              8888,(31)*,                                  /* REC 6  */
              2,4,4,9999,(28)*,                            /* REC 7  */
              8888,(31)*,                                  /* REC 8  */
              2,7777,9999,(29)*,                           /* REC 9  */
              8,4,4,8,2,7777,9999,(25)*,                   /* REC 10 */
              2,7777,9999,(29)*,                           /* REC 11 */
              8888,(31)*,                                  /* REC 12 */
              8888,(31)*,                                  /* REC 13 */
              8888,(31)*,                                  /* REC 14 */
              8888,(31)*,                                  /* REC 15 */
              8888,(31)*,                                  /* REC 16 */
              8,4,4,8,2,44,3,1,7777,9999,(22)*,            /* REC 17 */
              8,4,4,8,2,44,44,3,1,7777,9999,(21)*,         /* REC 18 */
              2,6,10,4,5,1,2,2,2,4,4,2,2,2,2,9999,(16)*,   /* REC 19 */
              8,4,4,8,2,20,1,7777,9999,(23)*,              /* REC 20 */
              2,6,2,4,1,1,2,1,1,1,2,2,1,2,2,9999,(16)*,    /* REC 21 */
              2,2,7777,9999,(28)*,                         /* REC 22 */
              8888,(31)*,                                  /* REC 23 */
              8888,(31)*,                                  /* REC 24 */
              8888,(31)*,                                  /* REC 25 */
              8888,(31)*,                                  /* REC 26 */
              8888,(31)*,                                  /* REC 27 */
              8888,(31)*,                                  /* REC 28 */
              8888,(31)*,                                  /* REC 29 */
              8888,(31)*,                                  /* REC 30 */
              8888,(31)*,                                  /* REC 31 */
              8888,(31)*,                                  /* REC 32 */
              8888,(31)*,                                  /* REC 33 */
              8888,(31)*,                                  /* REC 34 */
              8888,(31)*,                                  /* REC 35 */
              8888,(31)*,                                  /* REC 36 */
              8888,(31)*,                                  /* REC 37 */
              8888,(31)*,                           /* REC 38  Y01018*/
              8888,(31)*,                                  /* REC 39 */
              8888,(31)*,                                  /* REC 40 */
              8888,(31)*,                                  /* REC 41 */
              8888,(31)*,                                  /* REC 42 */
              8888,(31)*,                                  /* REC 43 */
              8888,(31)*,                                  /* REC 44 */
              8888,(31)*,                                  /* REC 45 */
              8888,(31)*,                                  /* REC 46 */
              8888,(31)*,                                  /* REC 47 */
              8888,(31)*,                                  /* REC 48 */
              8888,(31)*,                                  /* REC 49 */
              8888,(31)*,                                  /* REC 50 */
              8888,(31)*,                                  /* REC 51 */
              8888,(31)*,                                  /* REC 52 */
              8888,(31)*,                                  /* REC 53 */
              8888,(31)*,                                  /* REC 54 */
              8888,(31)*,                                  /* REC 55 */
              8888,(31)*,                                  /* REC 56 */
              8888,(31)*,                                  /* REC 57 */
              8888,(31)*,                                  /* REC 58 */
              8888,(31)*,                                  /* REC 59 */
              8888,(31)*,                                  /* REC 60 */
              8888,(31)*,                                  /* REC 61 */
              8888,(31)*,                                  /* REC 62 */
              8888,(31)*,                                  /* REC 63 */
              8888,(31)*,                                  /* REC 64 */
              8888,(31)*,                                  /* REC 65 */
              8888,(31)*,                                  /* REC 66 */
              8888,(31)*,                                  /* REC 67 */
              8888,(31)*,                                  /* REC 68 */
              8888,(31)*,                                  /* REC 69 */
              8888,(31)*,                                  /* REC 70 */
              8888,(31)*,                                  /* REC 71 */
              8888,(31)*,                                  /* REC 72 */
              8888,(31)*,                                  /* REC 73 */
              8888,(31)*),                                 /* REC 74 */
    01 ERROR_MESSAGE,                   /* THIS STRUCTURE IS PRINTED
                      TO INFORM THE USER THAT THE RECORD TYPE
                      REQUESTED IS NOT DEFINED BY THIS PROGRAM       */
       02 SEGMENT1 CHAR (13) INIT ('0RECORD TYPE '),
       02 TYPE PIC '99',
       02 SEGMENT2 CHAR (41) INIT
             (' IS NOT SUPPORTED BY THIS SAMPLE ROUTINE.'),

       ERROR2_MESSAGE CHAR (97) INIT
       ('0PROGRAM TERMINATED - SMF RECORD NOT GENERATED BY A VS2 SYSTEM
 (SYSTEM INDICATOR IS AT OFFSET 0).'),


    /*****************************************************************/
    /*                                                               */
    /*  THE FOLLOWING DATA DECLARATIONS PERTAIN TO THE BASIC READ    */
    /*  LOOP.  RECORD_TYPE IS SET IN THE BASIC READ LOOP, HOWEVER    */
    /*  IT IS DECLARED IN SMF_HEADER BECAUSE IT IS PART OF THAT      */
    /*  PRINT LINE.                                                  */
    /*                                                               */
    /*****************************************************************/

       SMFDATA FILE RECORD INPUT,  /* SMF INPUT DATA                 */

       EOF FIXED BINARY (15,0),    /* END OF FILE SWITCH             */

       RECORD CHAR (4000) VARYING, /* THIS STRING CONTAINS THE
          INPUT RECORD.  IT IS ARBITRARILY SET AT 4000 BYTES AS THE
          MAXIMUM SIZE OF CURRENT SMF RECORDS.  IF THIS SIZE NEEDS
          TO BE INCREASED THEN CORRESPONDING INCREASES MUST BE MADE
          TO 'HEX' AND 'BUFFER'.               */

       01 SUBFIELD BASED (RECORD_ADDR), /*SUBSTRUCTURE TO OBTAIN TYPE*/
          02 SUBLEN CHAR (2),           /*LENGTH FIELD       @ZA01928*/
          02 SUB1  BIT (8),             /* IGNORE FIRST BYTE         */
          02 RTYPE BIT (8),             /*DECLARE TYPE FOR CONVERSION*/

    /*****************************************************************/
    /*                                                               */
    /*  THE FOLLOWING DATA DECLARATIONS PERTAIN TO THE PRINTING      */
    /*  OF THE REPORT HEADER                                         */
    /*                                                               */
    /*****************************************************************/

       01 HEADER1,                      /* THIS STRUCTURE REPRESENTS */
                                     /* THE FIRST LINE OF THE REPORT */
          02 HDR1 CHAR (7) INIT ('1RECORD'),
          02 SPACE1 CHAR (13) INIT ((13)' '),
          02 HDR2 CHAR (13) INIT ('HEADER/RECORD'),
          02 SPACE2 CHAR (74) INIT ((74)' '),
          02 HDR3 CHAR (5) INIT ('DATE '),
          02 CALENDAR PIC 'Z999999',

       01 HEADER2,                      /* THIS STRUCTURE REPRESENTS */
                                    /* THE SECOND LINE OF THE REPORT */
          02 HDR1 CHAR (6) INIT ('  TYPE'),
          02 SPACE1 CHAR (101) INIT ((101)' '),
          02 HDR2 CHAR (5) INIT ('PAGE '),
          02 PAGE_NUMBER PIC 'ZZZZZZ9',

       01 HEADER3,                        /* TRIPLE SPACE FOR REPORT */
          02 HDR1 CHAR (1) INIT ('-'),
          02 SPACE1 CHAR (19) INIT ((19)' '),
       LINE_COUNT FIXED BINARY (15,0),   /* LINE COUNT PER PAGE      */

    /*****************************************************************/
    /*                                                               */
    /*  THE FOLLOWING DATA DECLARATIONS PERTAIN TO THE TRANSLATION   */
    /*  AND OUTPUT PROCESSES.                                        */
    /*                                                               */
    /*****************************************************************/

       01 SMF_HEADER,                   /* THIS STRUCTURE REPRESENTS */
                                        /* THE OUTPUT FORMAT OF THE  */
                                        /* STANDARD SMF HEADER       */
          02 SPACE1 CHAR (2) INIT ('0 '),
          02 RECORD_TYPE PIC '99',
          02 SPACE2 CHAR (6) INIT ((6)' '),
          02 TYPE CHAR (4),
          02 SPACE3 CHAR (2) INIT ('  '),
          02 TIME CHAR (8),
          02 SPACE4 CHAR (2) INIT ('  '),
          02 DATE2 CHAR (8),
          02 SPACE5 CHAR (2) INIT ('  '),
          02 ID CHAR (8),                                  /* Y02120 */
          02 SPACE7 CHAR (41) INIT ((41)' '),
          02 MARK1 CHAR (1) INIT ('*'),
          02 TYPE1 CHAR (2),
          02 SPACE8 CHAR (1) INIT (' '),
          02 TIME1 CHAR (4),
          02 SPACE9 CHAR (1) INIT (' '),
          02 DATE1 CHAR (4),
          02 SPACE10 CHAR (1) INIT (' '),
          02 ID1 CHAR (4),                                 /* Y02120 */
          02 SPACE12 CHAR (13) INIT ((13)' '),
          02 MARK2 CHAR (1) INIT ('*'),

       PRINT CHAR (18) DEF SMF_HEADER POS (87), /*GROUP FOR TRANSLATE*/

       01 SMF_FIELDS,                   /* THIS STRUCTURE REPRESENTS */
                                        /* THE OUTPUT FORMAT OF THE  */
                                        /* SMF DATA FIELDS           */
          02 SPACE1 CHAR (10) INIT ((10)' '),
          02 SIDE1 CHAR (60),
          02 SPACE2 CHAR (15) INIT ((15)' '),
          02 MARK1 CHAR (1) INIT ('*'),
          02 SIDE2 CHAR (30),
          02 MARK2 CHAR (1) INIT ('*'),

       BUFFER CHAR (4000),             /* THIS STRING CONTAINS THE   */
                                       /* HEXIDECIMAL REPRESENTATION */
                                       /* OF THE SMF INPUT RECORD IN */
                                       /* PRINTABLE CHARACTER FORMAT */

       01 HDR_SEGMENT DEF BUFFER POS (1), /* SMF HEADER STRUCTURE    */
          02 TYPE CHAR (4),
          02 TIME CHAR (8),
          02 DATE2 CHAR (8),                               /* Y02120 */
          02 ID CHAR (8),

       01 HDR_PORTION BASED (RECORD_ADDR), /* SMF HEADER STRUCTURE   */
          02 HEADLEN CHAR (2),             /* LENGTH FIELD   @ZA01928*/
          02 TYPE1 CHAR (2),
          02 TIME1 CHAR (4),
          02 DATE1 CHAR (4),
          02 ID1 CHAR (4),                                 /* Y02120 */

       01 HEX1  BASED (RECORD_ADDR),     /* SMF INPUT IN HEX @ZA01928*/
          02 HEXLEN CHAR (2),            /* LENGTH           @ZA01928*/
          02 HEX (4000) BIT (4),         /*                  @ZA01928*/

       TABLE (0:15) CHAR (1) INIT ('0','1','2','3','4','5','6','7','8',
                                 '9','A','B','C','D','E','F'),
                                        /* THIS TABLE IS USED TO     */
                                        /* TRANSLATE HEX TO DECIMAL  */

       COUNTFIELD  FIXED BINARY (15,0) INIT (0), /* BYTE OR FIELD CNT*/
       COUNT_CHAR CHAR (2) BASED (R),   /* CHAR DEF FOR FIELD */
       ZERO FIXED BINARY (15,0) INIT (0),  /* ZERO FIELD FOR */
       ZERO_CHAR CHAR (2) BASED (T),       /* FIELD ALIGNMENT */
       LENGTH_CHAR CHAR (2) BASED (P), /* CHARACTER FIELD FOR LENGTH */
       LENGTHFIELD FIXED BINARY (15,0), /* FIELD LENGTH */

       RECORD_SIZE FIXED BINARY (15,0), /*SAVE LENGTH OF INPUT RECORD*/

       RECORD_POINTER FIXED BINARY (15,0), /* POINTER TO RECORD DATA */

       BUFFER_POINTER FIXED BINARY (15,0), /* POINTER TO HEX BUFFER  */

       SIDE1_POINTER FIXED BINARY (15,0),  /* POINTER TO HEX OUTPUT  */

       SIDE2_POINTER FIXED BINARY (15,0),  /* POINTER TO CHAR OUTPUT */

       FIELD_INDEX FIXED BINARY (15,0),  /* POINTER TO DATA FIELD    */

       LENGTH_SAVE FIXED BINARY (15,0),  /* EXCESS LENGTH SAVE AREA  */

       FIELD_LENGTH FIXED BINARY (15,0), /* LENGTH OF SMF DATA FIELD */

       DATE BUILTIN,                    /*                   @ZA01928*/

       TRANSLATE_TABLE CHAR (37) INIT
          ('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 '),
                                        /* THIS TABLE IS USED TO     */
                                        /* ELIMINATE NON-ALPHANUMERIC*/

         DUMMY CHAR (1);        /* THIS CHARACTER IS THE DECLARATION */
                           /*TERMINATOR AND MUST ALWAYS REMAIN LAST  */

    ON ENDFILE (SMFDATA) EOF = 1; /* SET END OF FILE SWITCH FOR LOOP */
    OPEN FILE (SMFDATA);          /* OPEN SMF INPUT DATA SET         */
    EOF = 0;                      /* INITIALIZE EOF SWITCH TO OFF    */
    P = ADDR(LENGTHFIELD);              /* ADDRESSES OF BINARY       */
    T = ADDR(ZERO);                     /* FIELDS FOR BASED CHARACTER*/
    R = ADDR(COUNTFIELD);               /* FIELD ALIGNMENT           */
    TYPE_TABLE = 0;                     /* INITIALIZE TYPE SWITCHES  */
    PAGE_NUMBER = 0;                    /* INITIALIZE PAGE COUNT     */
    CALENDAR = DATE;                    /* GET DATE FROM SYSTEM      */
    RECORD_ADDR = ADDR(RECORD);         /*SET POINTER TO INPUT RECORD*/
    PARM_LENGTH = LENGTH(PARM_STRING);  /* SAVE PARAMETER LENGTH     */
    IF PARM_LENGTH = 0  THEN            /* TEST FOR NULL PARAMETER   */
                                        /* IF NULL, PROCESS ALL TYPES*/
      DO I = 0 TO 74;                                      /* Y02120 */
        IF FIELD_TABLE(I,1) ^= 8888 THEN /* TEST FOR UNDEF TYPE      */
                                        /* IF DEFINED,               */
          TYPE_TABLE(I) = 1;            /*       SET TYPE SWITCH ON  */
        ELSE                            /* IF UNDEFINED              */
          DO;                           /* SELECT TYPE IN ERROR      */
            ERROR_MESSAGE.TYPE = I;
            WRITE FILE (REPORT) FROM (ERROR_MESSAGE);
                                        /*       PRINT ERROR MESSAGE */
          END;                          /* END OF DO FOR = 8888      */
      END;                              /* END FOR DO I = 74         */
    ELSE                                /* IF TYPE PARAMETER VALUES  */
      DO;                               /* PRESENT, SET SELECT SWITCH*/
        START = 1;                      /* SET PARAMETER POINTER     */
        DO WHILE (START ^> PARM_LENGTH); /* SET LOOP FOR STRING      */
          PLACE = INDEX(SUBSTR(PARM_STRING,START),',');
                                        /* SEARCH PARAMETER FOR COMMA*/
          IF PLACE ^= 0  THEN           /* TEST FOR END OF PARAMETER */
                                        /* IF NOT THE END THEN       */
            DO;                         /* PROCESS CURRENT VALUE     */
                                        /* EXTRACT TYPE VALUE        */
              VALUE = SUBSTR(PARM_STRING,START,PLACE-1);
              START = START + PLACE;    /* INCREMENT POINTER         */
            END;                        /* END OF DO FOR PLACE ^= 0  */
          ELSE                          /* IF END OF PARAMETER       */
            DO;                         /* PROCESS LAST VALUE        */
              VALUE = SUBSTR(PARM_STRING,START);
              START = PARM_LENGTH + 1;  /* SET LOOP TO END           */
            END;                        /* END OF DO FOR PLACE = 0   */
                                                           /* Y02120 */
          DO I = 0 TO 74;               /* SET TYPE_TABLE LOOP       */
            IF VALUE = PARM_NUMBER(I) THEN /* SEARCH FOR VALUE       */
                                        /* IF VALUE FOUND            */
                                        /* TEST FOR UNDEFINED TYPE   */
              IF FIELD_TABLE(I,1) = 8888  THEN
                                        /* IF TYPE UNDEFINED         */
                DO;                     /* WRITE ERROR MESSAGE       */
                  ERROR_MESSAGE.TYPE = I;
                  WRITE FILE (REPORT) FROM (ERROR_MESSAGE);
                END;                    /* END OF DO FOR = 8888      */
              ELSE                      /* IF TYPE DEFINED           */
                TYPE_TABLE(I) = 1;      /* SET TYPE SWITCH           */
            ELSE;                       /* CONTINUE SEARCH IF UNEQUAL*/
          END;                          /* END OF DO FOR I = 74      */
        END;                            /* END OF DO FOR START < PARM*/
      END;                              /* END OF DO FOR LENGTH ^= 0 */
  CALL HEADER;                          /* PRINT REPORT HEADER       */
  READ FILE (SMFDATA) INTO (RECORD);    /* READ SMF INPUT DATA       */
  IF SUB1 ^= '00000010' THEN
    DO;
      WRITE FILE (REPORT) FROM (ERROR2_MESSAGE);
      GO TO SMFEND;
    END;
  ELSE;                            /* NULL ELSE FOR NONE VS2 RECORDS */
  DO WHILE (EOF = 0);              /* SET READ LOOP FOR ENTIRE FILE  */
    RECORD_TYPE = RTYPE;                /* CONVERT TYPE TO DECIMAL   */
    IF RECORD_TYPE > 74 THEN
      GO TO LOOP;
    ELSE;
    IF TYPE_TABLE(RECORD_TYPE) = 1 THEN /* TEST TYPE SWITCH          */
      DO;                               /* PROCESS THIS RECORD       */

    /*  DETERMINE THE LENGTH OF THE VARIABLE RECORD AND CONVERT      */
    /*  EACH FOUR BIT HEXIDECIMAL VALUE INTO CHARACTER FORM          */

        RECORD_SIZE = LENGTH(RECORD);
        DO I = 1 TO (RECORD_SIZE * 2);
          PLACE = HEX(I);
          SUBSTR(BUFFER,I,1) = TABLE(PLACE);
        END;

    /*  ASSIGN THE PRINTABLE HEXIDECIMAL SMF RECORD TO THE OUTPUT    */
    /*  BUFFER IN THE STANDARD SMF HEADER RECORD FORMAT              */

        SMF_HEADER = HDR_SEGMENT, BY NAME;
        SMF_HEADER = HDR_PORTION, BY NAME;

    /*  TEST THE SMF INPUT RECORD FOR NON-ALPHANUMERIC CHARACTERS    */
    /*  AND INSERT  A BULLET IN THE EBCDIC SIDE OF THE REPORT        */

        DO I = 1 TO 18;
          PLACE = INDEX(TRANSLATE_TABLE,SUBSTR(PRINT,I,1));
          IF PLACE = 0  THEN
            SUBSTR(PRINT,I,1) = '.';
          ELSE;
        END;

    /*  INCREMENT LINE COUNT PER PAGE.  IF COMPLETE RECORD WILL NOT  */
    /*  FIT ON CURRENT PAGE THEN SKIP TO NEW PAGE.  WRITE SMF HEADER */

        LINE_COUNT = LINE_COUNT + (RECORD_SIZE/30) + 5;
        IF LINE_COUNT > 50  THEN
          CALL HEADER;
        ELSE;
        WRITE FILE (REPORT) FROM (SMF_HEADER);

    /*  FORMAT OUTPUT BUFFER FOR SMF DATA FIELDS.  INSERT FIELDS     */
    /*  CHARACTER BY CHARACTER UNTIL THE BUFFER IS FULL.  THEN       */
    /*  TEST SIDE2 FOR NON-ALPHANUMERIC CHARACTERS BEFORE PRINTING   */

    /*  BEGIN FIELD LOOP INITIALIZATION.                             */

        SIDE1 = ' ';                    /* CLEAR CHARACTER BUFFER    */
        SIDE2 = ' ';                    /* CLEAR HEX PRINT BUFFER    */
        RECORD_POINTER = 15;            /* SET TO FIRST DATA         */
        BUFFER_POINTER = 29;            /* SET TO FIRST DATA         */
        SIDE1_POINTER = 1;              /* SET TO START OF BUFFER    */
        SIDE2_POINTER = 1;              /* SET TO START OF BUFFER    */
        FIELD_INDEX = 1;                /* POINT TO FIRST DATA LNG   */
        LENGTH_SAVE = 0;                /* INITIALIZE SAVE AREA      */
        FIELD_LENGTH = FIELD_TABLE(RECORD_TYPE,FIELD_INDEX);
                                        /* ASSIGN FIRST DATA LENGTH  */

    /*  BEGIN FIELD LOOP.  9999 MARKS THE END OF FIELDS FOR THAT     */
    /*  TYPE. 6666 OR 7777 INDICATES THAT THE REST OF THE SMF DATA   */
    /*  IS VARIABLE LENGTH AND IS TO BE PROCESSED EXCEPTIONALLY      */
    /*  DEPENDING ON RECORD TYPE.                                    */

        DO WHILE (FIELD_LENGTH ^= 9999);
          IF FIELD_LENGTH = 6666 THEN
    /*   6666 INDICATES REMAINDER OF RECORD IS VARIABLE LENGTH       */
            IF RECORD_TYPE = 5 × RECORD_TYPE = 35 THEN
              DO;                       /* GET # OF ACCT FIELDS      */

                COUNT_CHAR = SUBSTR(RECORD,RECORD_POINTER - 1,1);
                COUNT_CHAR = SUBSTR(ZERO_CHAR,1,1) ×× COUNT_CHAR;
                IF COUNTFIELD = 0 THEN
                  FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) = 9999;
                ELSE
                  DO;
                    FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) = 7777;
                    FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 2) = 9999;
                  END;
                GO TO VAR;
              END;                      /* END OF 5 & 35 PROCESSING  */
            ELSE                    /* ELSE FOR RECORD_TYPE = 5 × 35 */
              IF RECORD_TYPE = 14 × RECORD_TYPE = 15 THEN
                DO;                     /* GET # OF UCB'S            */
                  COUNT_CHAR = SUBSTR(RECORD,RECORD_POINTER - 223,1);
                  COUNT_CHAR = SUBSTR(ZERO_CHAR,1,1) ×× COUNT_CHAR;
                  LENGTHFIELD = COUNTFIELD; /* GET LENGTH OF UCB'S   */
                  COUNT_CHAR = SUBSTR(RECORD,RECORD_POINTER - 222,1);
                  COUNT_CHAR = SUBSTR(ZERO_CHAR,1,1) ×× COUNT_CHAR;
                  START = COUNTFIELD;
                  IF LENGTHFIELD > 20 THEN
                    LENGTHFIELD = 20;
                  ELSE;
                  DO I = 1 TO LENGTHFIELD;
                    FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + I) = START;
                  END;
                  FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + I) = 7777;
                  FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + I + 1) = 9999;
                  GO TO VAR;
                END;                    /* END 14 & 15 PROCESSING    */
              ELSE;      /* NULL ELSE FOR 14 & 15 AND END FOR 5 & 35 */
          ELSE                       /* ELSE FOR FIELD_LENGTH = 6666 */
            IF FIELD_LENGTH = 7777  THEN
              IF RECORD_TYPE = 4 × RECORD_TYPE = 34 THEN
                DO;
    /* THESE RECORDS HAVE BOTH VARIABLE & FIXED FIELDS WITH LENGTH OF*/
    /* VARIABLE FIELDS CONTAINED WITHIN                              */
                  LENGTH_CHAR = SUBSTR(RECORD,RECORD_POINTER - 2,2);
                                     /* GET LENGTH OF DEVICE SECTION */
                  FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) =
                  LENGTHFIELD - 2;
                  FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 2) = 1;
                  FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 3) = 3;
                  FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 4) = 1;
                  COUNT_CHAR = SUBSTR(RECORD,RECORD_POINTER +
                  LENGTHFIELD + 2,1);   /* GET # STEP ACCT FIELDS    */
                  COUNT_CHAR = SUBSTR(ZERO_CHAR,1,1) ×× COUNT_CHAR;
                  IF COUNTFIELD = 0 THEN /*TEST # OF ACCT FIELDS = 0 */
                    DO;                                    /* Y02133 */
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 5) = 8;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 6) = 12;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 7) = 8;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 8) = 9999;
                    END;              /* END FOR NO STEP ACCT FIELDS */
                  ELSE                  /* ELSE FOR COUNTFIELD = 0   */
                    DO;    /* INSERT LENGTH OF VAR LENGTH ACCT FIELD */
    /* GET LENGTH OF ACCT SECT & SUBTRACT CPU & #-OF-STEP ACCT FIELDS*/
                      COUNT_CHAR = SUBSTR(RECORD,RECORD_POINTER +
                      LENGTHFIELD - 2,1);
                      COUNT_CHAR = SUBSTR(ZERO_CHAR,1,1) ×× COUNT_CHAR;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 5) =
                      COUNTFIELD - 4;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 6) = 8;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 7) = 12;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 8) = 8;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 9) = 9999;
                    END;          /* END FOR HAVING SOME ACCT FIELDS */
                  GO TO VAR;    /* PICK UP NEXT FIELD FOR PROCESSING */
                END;                 /* END FOR RECORD_TYPE = 4 × 34 */

              ELSE                  /* ELSE FOR RECORD_TYPE = 4 × 34 */
                IF RECORD_TYPE = 47 × RECORD_TYPE = 6 THEN /*@YM04143*/
    /* THESE RECORDS HAVE OPTIONAL ADDITIONAL FIELDS BASED ON        */
    /* INDICATORS CONTAINED IN RECORD.                       @YM04143*/
                  IF RECORD_TYPE = 47  THEN                /*@YM04143*/
                    DO;                 /* GET EVENT TYPE            */
                      COUNT_CHAR = SUBSTR(RECORD,RECORD_POINTER
                      - 28,2);                             /*@YM04143*/
                      IF COUNTFIELD = 1 THEN /* CHECK FOR SIGNON     */
                        FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) = 2;
                      ELSE                                 /*@YM04143*/
                        FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) =
                        9999;                              /*@YM04143*/
                      GO TO VAR;                           /*@YM04143*/
                    END;                /* END FOR RECORD_TYPE = 47  */
                  ELSE                                     /*@YM04143*/
                    IF RECORD_TYPE = 6  THEN               /*@YM04143*/
                      DO;               /* GET SUBSYSTEM ID          */
                        COUNT_CHAR = SUBSTR(RECORD,RECORD_POINTER
                        - 26,2);                           /*@YM04143*/
                        IF COUNTFIELD = 0 THEN             /*@YM04143*/
                          FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) =
                          9999;                            /*@YM04143*/
                        ELSE                               /*@YM04143*/
                          FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) = 4;
                        GO TO VAR;                         /*@YM04143*/
                      END;              /* END 6 PROCESSING          */
                    ELSE;  /* NULL ELSE FOR RECORD_TYPE = 6 & END 47 */

                ELSE                /* ELSE FOR RECORD_TYPE = 47 × 6 */
                  IF RECORD_TYPE = 64 THEN                 /* Y02113 */
                    DO;
    /* THIS RECORD HAS A VAR LENGTH FIELD FOLLOWED BY FIXED FIELDS   */
    /* GET LENGTH OF EXTENT SECTION                                  */
                      LENGTH_CHAR = SUBSTR(RECORD,RECORD_POINTER
                      - 2,2);
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 1) =
                      LENGTHFIELD;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 2) = 4;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 3) = 44;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 4) = 44;
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 5) = 22;
 /*                                                          @ZA05513*/
                      FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + 6) = 9999;
 /*                                                          @ZA05513*/
                      GO TO VAR; /* PICKUP NEXT FIELD FOR PROCESSING */
                    END;                /* END FOR RECORD_TYPE = 64  */
                  ELSE                  /* ELSE FOR RECORD_TYPE = 64 */
                    IF RECORD_TYPE = 40 THEN               /* Y02120 */
                      DO;
    /* THIS HAS VAR NUMBER OF FIXED FIELDS WITH # OBTAINED WITHIN BY */
    /* LENGTH FIELD.                   GET LENGTH OF DEVICE SECTION  */
                        LENGTH_CHAR = SUBSTR(RECORD,RECORD_POINTER
                        - 2,2);
                        START = 8;
                        LENGTHFIELD = (LENGTHFIELD - 2) / START;
                        IF LENGTHFIELD > 21  THEN
                          LENGTHFIELD = 21;
                        ELSE;
  FIXED:                DO I = 1 TO LENGTHFIELD;
                          FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + I) =
                          START;
                        END;
                        FIELD_TABLE(RECORD_TYPE,FIELD_INDEX + I) =
                        9999;
                        GO TO VAR; /* PICK UP NEXT FLD FOR PROCESSING*/
                      END;

                    ELSE        /* ELSE FOR RECORD_TYPE = 40, Y02113 */
                      IF RECORD_TYPE = 62 × RECORD_TYPE = 22  ×
                      RECORD_TYPE = 70 × RECORD_TYPE = 72 ×
                      RECORD_TYPE = 73 × RECORD_TYPE = 74 THEN
                        DO;
    /* THESE HAVE VAR # OF FIXED FIELDS WITH # OBTAINED WITHIN BY    */
    /* # OF ENTRIES FIELD.                                           */

                          IF RECORD_TYPE = 22  THEN        /* Y02034 */
                            DO;         /* GET # OF ELEMENTS         */
                              COUNT_CHAR = SUBSTR(RECORD,
                              RECORD_POINTER- 2,2);
                              START=6;
                              IF COUNTFIELD > 28  THEN
                                COUNTFIELD = 28;
                              ELSE;
                            END;        /* END OF 22 PROCESSING      */
                          ELSE          /* ELSE FOR RECORD_TYPE = 22 */
                            IF RECORD_TYPE = 62  THEN
                              DO;       /* GET # OF VOLUMES   Y02113 */
                                COUNT_CHAR = SUBSTR(RECORD,
                                RECORD_POINTER- 2,2);
                                START = 10;
                                IF COUNTFIELD > 21  THEN
                                  COUNTFIELD = 21;
                                ELSE;
                              END;      /* END FOR 62 PROCESSING     */
                                                           /* Y02150 */
                            ELSE        /* ELSE FOR RECORD_TYPE = 62 */
                              IF RECORD_TYPE = 70 × RECORD_TYPE = 73
                              THEN
                                DO;     /* GET # OF CPU'S            */
                                  COUNT_CHAR = SUBSTR(RECORD,
                                  RECORD_POINTER - 6,2);
                                  START = 16;
                                  IF RECORD_TYPE = 70 THEN
                                    DO;
                                      IF COUNTFIELD > 17  THEN
                                        COUNTFIELD = 17;
                                      ELSE;
                                    END; /* END OF 70 PROCESSING     */
                                  ELSE  /* ELSE FOR RECORD_TYPE = 70 */
                                    DO;
                                      IF COUNTFIELD > 16  THEN
                                        COUNTFIELD = 16;
                                      ELSE;
                                    END; /* END OF 73 PROCESSING     */
                                END; /*END FOR RECORD_TYPE = 70 × 73 */
                              ELSE /* ELSE FOR RECORD_TYPE = 70 × 73 */
                                IF RECORD_TYPE = 72  THEN
                                  DO;   /* GET # OF PERF GROUPS      */
                                    COUNT_CHAR = SUBSTR(RECORD,
                                    RECORD_POINTER - 14,2);
                                    START = 20;
                                    IF COUNTFIELD > 15  THEN
                                      COUNTFIELD = 15;
                                    ELSE;
                                  END;  /* END FOR 72 PROCESSING     */
                                ELSE    /* ELSE FOR RECORD_TYPE = 72 */
                                  DO;
                                    IF RECORD_TYPE = 74  THEN
                                      DO;
                                        START = 28;
                                        COUNT_CHAR = SUBSTR(RECORD,
                                        RECORD_POINTER - 6,2);
                                        IF COUNTFIELD > 16  THEN
                                          COUNTFIELD = 16;
                                        ELSE;
                                      END; /* END FOR 74 PROCESSING  */
                                    ELSE; /*NULL ELSE FOR REC_TYPE=74*/
                                  END;  /* END ELSE'S FOR 22,62,70×73,
                                                   72 AND END FOR 74 */
                          LENGTHFIELD = COUNTFIELD;
                          GO TO FIXED;  /* INSERT AS FOR RECORD 40   */
                        END; /* END PROCESSING FOR 22,62,70,72,73,74 */
                      ELSE /*ELSE FOR RECORD_TYPE = 22×62×70×72×73×74*/
                        FIELD_LENGTH = RECORD_SIZE - RECORD_POINTER
                        + 1;
                        /* END ELSE'S FOR RECORD_TYPE =4×34,47,64,40 */
            ELSE;  /* NULL ELSE FOR FIELD_LENGTH = 7777  & ENDS 6666 */

    /*  IF THE LENGTH OF THE DATA FIELD IS TOO LONG TO FIT ON THE    */
    /*  CURRENT LINE THEN IT IS BROKEN INTO TWO SEGMENTS WITH THE    */
    /*  SECOND SEGMENT HELD UNTIL THE NEXT LINE.                     */

          IF FIELD_LENGTH + SIDE2_POINTER > 31  THEN
            DO;
              LENGTH_SAVE = FIELD_LENGTH - (31 - SIDE2_POINTER);
              FIELD_LENGTH = 31 - SIDE2_POINTER;
            END;
          ELSE;

    /*  ASSIGN THE SMF CHARACTER AND THE HEX REPRESENTATION TO THE   */
    /*  OUTPUT BUFFERS.  PROCESS THE HEX BUFFER TWO AT A TIME        */
    /*  IN ORDER TO MAINTAIN ALIGNMENT.  INCREMENT THE OUTPUT BUFFER */
    /*  BETWEEN FIELDS FOR DATA SPACING.                             */

          DO I = 1 TO FIELD_LENGTH;
            SUBSTR(SIDE1,SIDE1_POINTER,1) =
                                  SUBSTR(BUFFER,BUFFER_POINTER,1);
            SUBSTR(SIDE1,SIDE1_POINTER+1,1) =
                                  SUBSTR(BUFFER,BUFFER_POINTER+1,1);
            SUBSTR(SIDE2,SIDE2_POINTER,1) =
                                  SUBSTR(RECORD,RECORD_POINTER,1);
            RECORD_POINTER = RECORD_POINTER + 1;
            BUFFER_POINTER = BUFFER_POINTER + 2;
            SIDE1_POINTER = SIDE1_POINTER + 2;
            SIDE2_POINTER = SIDE2_POINTER + 1;
          END;
          SIDE1_POINTER = SIDE1_POINTER + 2;
          SIDE2_POINTER = SIDE2_POINTER + 1;

    /*  IF THE OUTPUT BUFFER IS FULL THEN TEST THE SMF CHARACTERS    */
    /*  FOR NON-ALPHANUMERIC CHARACTERS AND REPLACE ALL OF THEM      */
    /*  WITH '.'.  WRITE SMF DATA AND CLEAR OUTPUT BUFFERS FOR THE   */
    /*  NEXT LINE.                                                   */

          IF SIDE2_POINTER > 30  THEN
            DO;
              DO I = 1 TO 30;
                PLACE = INDEX(TRANSLATE_TABLE,SUBSTR(SIDE2,I,1));
                IF PLACE = 0  THEN
                  SUBSTR(SIDE2,I,1) = '.';
                ELSE;
              END;
              WRITE FILE (REPORT) FROM (SMF_FIELDS);
              SIDE1 = ' ';
              SIDE2 = ' ';

    /*  IF THE OUTPUT BUFFER EQUALS 31 THEN THIS IMPLIES THAT THE    */
    /*  LAST DATA FIELD IS TO BE CONTINUED IN THE FIRST POSITION     */
    /*  OF THE NEXT LINE.  IF THE OUTPUT BUFFER EQUALS 32 THEN       */
    /*  THIS IMPLIES THAT A NEW DATA FIELD WILL BEGIN THE NEXT LINE  */
    /*  AND THAT THE LINE SHOULD BE INDENTED BY ONE.                 */

              IF SIDE2_POINTER = 31  THEN
                DO;
                  SIDE1_POINTER = 1;
                  SIDE2_POINTER = 1;
                END;
              ELSE                    /* ELSE FOR SIDE2_POINTER = 31 */
                DO;
                  SIDE1_POINTER = 3;
                  SIDE2_POINTER = 2;
                END;              /* ENDS SIDE2_POINTER = 31 & ^= 31 */
            END;                        /* ENDS SIDE2_POINTER > 30   */
          ELSE;                       /* ELSE FOR SIDE2_POINTER > 30 */

    /*  TEST FIELD DATA LENGTH SAVE AREA FOR EXCESS LENGTH.  IF      */
    /*  PRESENT THEN PICK UP EXCESS LENGTH AND RESET BUFFER POINTERS */
    /*  OTHERWISE GET NEXT FIELD DATA LENGTH.                        */

          IF LENGTH_SAVE ^= 0  THEN
            DO;
              FIELD_LENGTH = LENGTH_SAVE;
              LENGTH_SAVE = 0;
              SIDE1_POINTER = 1;
              SIDE2_POINTER = 1;
            END;
          ELSE                          /* ELSE FOR LENGTH_SAVE ^= 0 */
            DO;
  VAR:        FIELD_INDEX = FIELD_INDEX + 1;
              FIELD_LENGTH = FIELD_TABLE(RECORD_TYPE,FIELD_INDEX);
              IF FIELD_LENGTH = 0 THEN
                GO TO VAR;
            END;                   /* END FOR LENGTH_SAVE ^= 0 & = 0 */
        END;                            /* END FOR FIELD ^= 9999     */

    /*  IF NO MORE FIELDS THEN TEST THE SMF CHARACTERS FOR           */
    /*  NON-ALPHANUMERIC CHARACTERS AND REPLACE THEM WITH '.'.       */
    /*  WRITE SMF DATA LEFT IN OUTPUT BUFFER                         */

        IF FIELD_INDEX = 1 × SIDE1_POINTER < 5 THEN
          GO TO LOOP;
        DO I = 1 TO 30;
          PLACE = INDEX(TRANSLATE_TABLE,SUBSTR(SIDE2,I,1));
          IF PLACE = 0  THEN
            SUBSTR(SIDE2,I,1) = '.';
          ELSE;
        END;
        WRITE FILE (REPORT) FROM (SMF_FIELDS);
      END;                              /* END FOR TYPE_TABLE = 1    */

    ELSE;                            /* NULL ELSE FOR TYPE_TABLE = 1 */

  LOOP: READ FILE (SMFDATA) INTO (RECORD);
  END;                                  /* END FOR WHILE (EOF = 0)   */
  SMFEND: ;
  CLOSE FILE (SMFDATA);

  HEADER: PROC;                   /* PROCEDURE TO PRINT REPORT HEADER*/
    PAGE_NUMBER = PAGE_NUMBER + 1;      /* INCREMENT PAGE COUNT      */
    WRITE FILE (REPORT) FROM (HEADER1); /* PRINT FIRST LINE OF HEADER*/
    WRITE FILE (REPORT) FROM (HEADER2); /* PRINT SECOND HEADER LINE  */
    WRITE FILE (REPORT) FROM (HEADER3); /* SPACE FOR REPORT DATA     */
    LINE_COUNT = 0;                     /* RESET LINE COUNT PER PAGE */
  END HEADER;                           /* END FOR HEADER ROUTINE    */

 END SMFFRMT;                           /* END OF PROGRAM            */
