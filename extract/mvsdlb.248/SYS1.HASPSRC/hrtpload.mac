         TITLE 'RTPLOAD PROLOGUE'
***********************************************************************
*                                                                     *
* MODULE NAME = HRTPLOAD                                              *
*                                                                     *
* DESCRIPTIVE NAME = RTPLOAD (LOADER FOR 1130 RJE PROGRAM - RTP1130)  *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 RELEASE 2, LEVEL 0                                  *
*                                                                     *
* FUNCTION = RTPLOAD IS THE CORE IMAGE LOADER AND REP CARD PROCESSOR  *
*            FOR THE 1130 RJE WORKSTATION PROGRAM (RTP1130). RTPLOAD  *
*            IS LOADED INTO 1130 CORE STORAGE VIA A 2501 OR 1442 CARD *
*            READER BY THE BOOTSTRAP LOADER (RTPBOOT). IF A /*SIGNON  *
*            CARD IS INCLUDED WITH THE RTP1130 DECK BEING LOADED, IT  *
*            IS READ BY RTPLOAD AND PASSED TO RTP1130, OTHERWISE AN   *
*            INTERNAL DEFAULT /*SIGNON CARD IS USED.                  *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
* DEPENDENCIES = STRUCTURE OF THE RTPBOOT PROGRAM WHICH DICTATES      *
*                THE 1442/2501 FLAG USED TO DETERMINE THE READER      *
*                TYPE                                                 *
*                                                                     *
* RESTRICTIONS = NONE                                                 *
*                                                                     *
* REGISTER CONVENTIONS = WA = XR1 = WORK                              *
*                        WB = XR2 = WORK                              *
*                        WC = XR3 = WORK                              *
*                                                                     *
* PATCH LABEL = NONE                                                  *
*                                                                     *
* MODULE TYPE = PROCEDURE                                             *
*                                                                     *
* PROCESSOR = ASSEMBLER F                                             *
*                                                                     *
* MODULE SIZE = 1024 DECIMAL 1130 WORDS                               *
*                                                                     *
* ATTRIBUTES = NON-REENTERNT, NON-REFRESHABLE, NON-SERIALLY REUSABLE  *
*                                                                     *
* ENTRY POINT = RTPLINIT                                              *
*                                                                     *
* PURPOSE = SEE FUNCTION                                              *
*                                                                     *
* LINKAGE = TRANSFER OF CONTROL FROM RTPBOOT VIA 'END' CARD ENTRY     *
*           POINT SPECIFICATION. WB = ADDRESS OF /*SIGNON CARD.       *
*                                                                     *
* INPUT = RTP1130 PROGRAM DECK AS PRODUCED BY RMTGEN PROCESS          *
*                                                                     *
* OUTPUT = EXECUTABLE RTP1130 PROGRAM LOADED IN 1130 CORE             *
*                                                                     *
* EXIT-NORMAL = CONTROL PASSED TO RTP1130                             *
*                                                                     *
* EXIT-ERROR = WAIT AT LOCATION X'0010' WITH AC DISPLAYED AS FOLLOWS- *
*                                                                     *
*              AC   CONDITION                                         *
*              --   ---------                                         *
*              FFF3 LAST REP CARD READ IN ERROR. LOADING PERMANENTLY  *
*                   TERMINATED                                        *
*                                                                     *
*              FFF2 CHECKSUM OF LAST CARD READ DOES NOT AGREE         *
*                   WITH RMTGEN COMPUTED CHECKSUM                     *
*                                                                     *
*              FFF1 LAST CARD INDICATION. TO COMMENCE RTP1130 , PRESS *
*                   START ON READER AND THEN ON 1130 CONSOLE          *
*                                                                     *
* EXTERNAL REFERENCES = NONE                                          *
*                                                                     *
* TABLES = XPRSZNTB - 12 BIT CARD CODE TO EBCDIC CONVERSION           *
*                                                                     *
* MACROS = LOCALLY DEFINED 1130 EQUIVALENT INSTRUCTION SET            *
*                                                                     *
***********************************************************************
         TITLE '1130 MACRO DEFINITIONS (11/7/70)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - OS/360 MACRO DEFINTIONS FOR 1130 INSTRUCTIONS               *
*                                                                     *
* GENERAL DESCRIPTION -                                               *
*                                                                     *
*  THE MACROS DEFINED BELOW ATTEMPT TO ALLOW 1130 PROGRAMS TO BE      *
*  ASSEMBLED ON AN IBM 360 USING THE OS/360 ASSEMBLER OR IT'S         *
*  EQUIVALENT UNDER OTHER OPERATING SYSTEMS.                          *
*                                                                     *
*  THE OBJECT DECK PRODUCED BY THE ASSEMBLER IS INCOMPATIBLE WITH     *
*  NORMAL 1130 LOADER AND THEREFORE MUST BE PROCESSED BY A SPECIAL    *
*  1130 LOADER COGNIZANT OF THE 360 FORMAT.                           *
*                                                                     *
* MACRO INSTRUCTION FORMAT                                            *
*                                                                     *
*  THE GENERAL FORMAT OF 1130 INSTRUCTIONS TO BE ASSEMBLED WITH       *
*  THE MACRO SET IS...                                                *
*                                                                     *
*                                                                     *
*                        LABEL $OP ADDR,TAG,FMT,MOD                   *
*                                                                     *
*  WHERE                                                              *
*              LABEL = THE STATEMENT LABEL SUBJECT TO OS/360          *
*                      ASSEMBLER RESTRICTIONS AND RULES               *
*                                                                     *
*              $OP   = MACRO FROM THE SET DEFINED BELOW               *
*                                                                     *
*              ADDR  = THE ADDRESS FIELD OF THE 1130 INSTRUCTION      *
*                                                                     *
*              TAG   = THE INDEX REGISTER (TAG) FIELD OF THE          *
*                      1130 INSTRUCTION                               *
*                                                                     *
*              FMT   = THE FORMAT OF THE 1130 INSTRUCTION.            *
*                    = L FOR LONG FORM                                *
*                                                                     *
*                    = I FOR LONG FORM INDIRECT ADDRESSING            *
*                                                                     *
*                    = X FOR SHORT FORM ABSOLUTE ADDRESS              *
*                                                                     *
*                    = 'BLANK' FOR SHORT FORM RELATIVE ADDRESS        *
*                                                                     *
*              MOD   = MODIFIER BITS REQUIRED FOR SOME 1130           *
*                      INSTRUCTIONS                                   *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*              GENERAL 1130 INSTRUCTION DEFINITION MACRO              *
***********************************************************************
         MACRO
&NAME    $DEF  &OP,&ADD,&TAG,&FMT,&MOD
         LCLA  &I                  DEFINED FOR INDIRECT ADDRESSING BIT
         LCLC  &T,&M               DEFINED FOR INTERNAL MANIPULATION
&T       SETC  '&TAG'              EQUATE TAG AND MOD FIELDS TO
&M       SETC  '&MOD'               INTERNAL PARAMETERS
         AIF   ('&T' NE '').A      TEST FOR NULL TAG FIELD
&T       SETC  '0'                  AVOID ASSEMBLY ERROR IF NULL
.A       AIF   ('&M' NE '').B      TEST FOR NULL MOD FIELD
&M       SETC  '0'                  AVOID ASSEMBLY ERROR IF NULL
.B       AIF   ('&FMT' NE 'L' AND '&FMT' NE 'I').H BRA IF SHORT FORM
         AIF   ('&FMT' EQ 'L').C   DETERMINE IF LONG ONLY OR INDIRECT
&I       SETA  X'80'               TURN ON INDIRECT ADDRESS BIT
.C       AIF   (T'&ADD EQ 'N' OR '&ADD'(1,1) EQ '$').G BR IF $ OR NUMR
         AIF   ('&ADD'(1,1) EQ 'W').E TEST FOR SYMBOL BEGINNING WITH W
         AIF   ('&ADD'(1,1) EQ '*').F TEST FOR RELATIVE EXPRESSION
.D       ANOP
&NAME    DC    AL1(&OP+&T+4,&I+&M),AL2((&ADD-$Z)/2)
         MEXIT
.E       AIF   ('&ADD'(2,1) EQ 'A' OR '&ADD'(2,1) EQ 'B' OR '&ADD'(2,1)C
                EQ 'C').G 
         AGO   .D                   WHICH ARE DEFINED AS ABSOLUTE
.F       AIF   (K'&ADD LT 3).D     ELIMINATE ILLEGAL EXPRESSION
         AIF   ('&ADD'(2,2) NE '-*').D   BRANCH IF NOT *-*
.G       ANOP
&NAME    DC    AL1(&OP+&T+4,&I+&M),AL2(&ADD)
         MEXIT
.H       AIF   ('&FMT' EQ 'X' OR '&ADD'(1,1) EQ '-' OR T'&ADD EQ 'N').I
&NAME    DC 0SL2(*+D-&ADD,&ADD-*+D),AL1(&OP+&T,(&ADD-*-1)/2)
         MEXIT
.I       AIF   ('&ADD'(1,1) EQ '-').J  BRANCH IF MINUS ABSOLUTE
&NAME    DC    0SL2(A-&ADD),AL1(&OP+&T,&ADD+&M)
         MEXIT
.J       ANOP
&NAME    DC    0SL2(B&ADD),AL1(&OP+&T,0&ADD)
         MEND
***********************************************************************
*              GENERAL LONG FORM DEFINITION MACRO                     *
***********************************************************************
         MACRO
&NAME    $DEFL &OP,&ADD,&TAG,&FMT,&MOD
         AIF   ('&FMT' EQ 'I').A
&NAME    $DEF  &OP,&ADD,&TAG,L,&MOD
         MEXIT
.A       ANOP
&NAME    $DEF  &OP,&ADD,&TAG,I,&MOD
         MEND
         EJECT
***********************************************************************
*              1130 INSTRUCTIONS                                      *
***********************************************************************
         SPACE 2
*                                  $LD    LOAD ACC
         MACRO
&NAME    $LD   &ADD,&TAG,&FMT
&NAME    $DEF  192,&ADD,&TAG,&FMT
         MEND
*                                  $LDD   LOAD DOUBLE
         MACRO
&NAME    $LDD  &ADD,&TAG,&FMT
&NAME    $DEF  200,&ADD,&TAG,&FMT
         MEND
*                                  $STO   STORE ACC
         MACRO
&NAME    $STO  &ADD,&TAG,&FMT
&NAME    $DEF  208,&ADD,&TAG,&FMT
         MEND
*                                  $STD   STORE DOUBLE
         MACRO
&NAME    $STD  &ADD,&TAG,&FMT
&NAME    $DEF  216,&ADD,&TAG,&FMT
         MEND
*                                  $LDX   LOAD INDEX
         MACRO
&NAME    $LDX  &ADD,&TAG,&FMT
&NAME    $DEF  96,&ADD,&TAG,&FMT
         MEND
*                                  $LXA   LOAD INDEX FROM ADD (LONG)
         MACRO
&NAME    $LXA  &ADD,&TAG
&NAME    $LDX  &ADD,&TAG,I
         MEND
*                                  $AXT   ADDRESS TO INDEX TRUE
         MACRO
&NAME    $AXT  &ADD,&TAG,&FMT
&NAME    $LDX  &ADD,&TAG,&FMT
         MEND
*                                  $STX   STORE INDEX
         MACRO
&NAME    $STX  &ADD,&TAG,&FMT
&NAME    $DEF  104,&ADD,&TAG,&FMT
         MEND
*                                  $STS   STORE STATUS
         MACRO
&NAME    $STS  &ADD,&TAG,&FMT
&NAME    $DEF  40,&ADD,&TAG,&FMT
         MEND
*                                  $LDS   LOAD STATUS
         MACRO
&NAME    $LDS  &ADD,&TAG
&NAME    $DEF  32,&ADD,&TAG,X
         MEND
*                                  $A     ADD
         MACRO
&NAME    $A    &ADD,&TAG,&FMT
&NAME    $DEF  128,&ADD,&TAG,&FMT
         MEND
*                                  $AD    ADD DOUBLE
         MACRO
&NAME    $AD   &ADD,&TAG,&FMT
&NAME    $DEF  136,&ADD,&TAG,&FMT
         MEND
*                                  $S     SUBTRACT
         MACRO
&NAME    $S    &ADD,&TAG,&FMT
&NAME    $DEF  144,&ADD,&TAG,&FMT
         MEND
*                                  $SD    SUBTRACT DOUBLE
         MACRO
&NAME    $SD   &ADD,&TAG,&FMT
&NAME    $DEF  152,&ADD,&TAG,&FMT
         MEND
*                                  $M     MULTIPLY
         MACRO
&NAME    $M    &ADD,&TAG,&FMT
&NAME    $DEF  160,&ADD,&TAG,&FMT
         MEND
*                                  $D     DIVIDE
         MACRO
&NAME    $D    &ADD,&TAG,&FMT
&NAME    $DEF  168,&ADD,&TAG,&FMT
         MEND
*                                  $AND   LOGICAL AND
         MACRO
&NAME    $AND  &ADD,&TAG,&FMT
&NAME    $DEF  224,&ADD,&TAG,&FMT
         MEND
*                                  $OR    LOGICAL OR
         MACRO
&NAME    $OR   &ADD,&TAG,&FMT
&NAME    $DEF  232,&ADD,&TAG,&FMT
         MEND
*                                  $EOR   LOGICAL EXCLUSIVE OR
         MACRO
&NAME    $EOR  &ADD,&TAG,&FMT
&NAME    $DEF  240,&ADD,&TAG,&FMT
         MEND
*                                  $SLA   SHIFT LEFT ACC
         MACRO
&NAME    $SLA  &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,0
         MEND
*                                  $SLT   SHIFT LEFT ACC AND EXT
         MACRO
&NAME    $SLT  &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,128
         MEND
*                                  $SLCA  SHIFT LEFT AND COUNT ACC
         MACRO
&NAME    $SLCA &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,64
         MEND
*                                  $SLC   SHIFT LEFT AND COUNT ACC+EXT
         MACRO
&NAME    $SLC  &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,192
         MEND
*                                  $SRA   SHIFT RIGHT ACC
         MACRO
&NAME    $SRA  &ADD,&TAG
&NAME    $DEF  24,&ADD,&TAG,X,0
         MEND
*                                  $SRT   SHIFT RIGHT ACC+EXT
         MACRO
&NAME    $SRT  &ADD,&TAG
&NAME    $DEF  24,&ADD,&TAG,X,128
         MEND
*                                  $RTE   ROTATE RIGHT ACC+EXT
         MACRO
&NAME    $RTE  &ADD,&TAG
&NAME    $DEF  24,&ADD,&TAG,X,192
         MEND
*                                  $BSC   BRANCH/SKIP ON CONDITION
         MACRO
&NAME    $BSC  &ADD,&TAG,&FMT,&MOD
         AIF   ('&FMT' EQ 'L' OR '&FMT' EQ 'I').A
&NAME    DC    AL1(72,&ADD)
         MEXIT
.A       ANOP
&NAME    $DEF  72,&ADD,&TAG,&FMT,&MOD
         MEND
*                                  $BOSC  BRANCH/SKIP RESET INTERRUPT
         MACRO
&NAME    $BOSC &ADD,&TAG,&FMT,&MOD
         LCLC  &M
         AIF   ('&FMT' EQ '' OR '&FMT' EQ 'X').A
&M       SETC  '64'
         AIF   ('&MOD' EQ '').B
&M       SETC  '&M+64'
.B       ANOP
&NAME    $DEF  72,&ADD,&TAG,&FMT,&M
         MEXIT
.A       ANOP
&NAME    DC    AL1(72,&ADD+64)
         MEND
*                                  $BP    BRANCH ACC POSITIVE (LONG)
         MACRO
&NAME    $BP   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,48
         MEND
*                                  $BNP   BRANCH ACC NOT POSITIVE(LONG)
         MACRO
&NAME    $BNP  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,8
         MEND
*                                  $BN    BRANCH ACC NEGATIVE (LONG)
         MACRO
&NAME    $BN   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,40
         MEND
*                                  $BNN   BRANCH ACC NOT NEG. (LONG)
         MACRO
&NAME    $BNN  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,16
         MEND
*                                  $BZ    BRANCH ACC ZERO (LONG)
         MACRO
&NAME    $BZ   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,24
         MEND
*                                  $BNZ   BRANCH ACC NOT ZERO (LONG)
         MACRO
&NAME    $BNZ  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,32
         MEND
*                                  $BC    BRANCH ON CARRY (LONG)
         MACRO
&NAME    $BC   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,2
         MEND
*                                  $BO    BRANCH ON OVERFLOW (LONG)
         MACRO
&NAME    $BO   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,1
         MEND
*                                  $BOD   BRANCH ACC ODD (LONG)
         MACRO
&NAME    $BOD  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,4
         MEND
*                                  $SKPP  SKIP IF ACC POSITIVE (SHORT)
         MACRO
&NAME    $SKPP
&NAME    $DEF  72,0,,X,8
         MEND
*                                  $SKPN  SKIP IF ACC NON-ZERO (SHORT)
         MACRO
&NAME    $SKPN
&NAME    $DEF  72,0,,X,24
         MEND
*                                  $SKPZ  SKIP IF ACC IS ZERO (SHORT)
         MACRO
&NAME    $SKPZ
&NAME    $DEF  72,0,,X,32
         MEND
*                                  $SKPO  SKIP IF OVERFLOW OFF (SHORT)
         MACRO
&NAME    $SKPO
&NAME    $DEF  72,0,,X,1
         MEND
*                                  $SKPC  SKIP IF CARRY IS OFF (SHORT)
         MACRO
&NAME    $SKPC
&NAME    $DEF  72,0,,X,2
         MEND
*                                  $SKPX  SKIP ACC NE 0, CARRY OFF
         MACRO
&NAME    $SKPX
&NAME    $DEF  72,0,,X,26
         MEND
*                                  $B     BRANCH UNCONDITIONALLY
         MACRO
&NAME    $B    &ADD,&TAG,&FMT
         AIF   ('&FMT' EQ 'L' OR '&FMT' EQ 'I').A
&NAME    $MDX  &ADD,&TAG,&FMT
         MEXIT
.A       ANOP
&NAME    $BSC  &ADD,&TAG,&FMT
         MEND
*                                  $BSI   BRANCH AND STORE IAR
         MACRO
&NAME    $BSI  &ADD,&TAG,&FMT,&MOD
&NAME    $DEF  64,&ADD,&TAG,&FMT,&MOD
         MEND
*                                  $TSL   BRANCH AND STORE IAR (LONG)
         MACRO
&NAME    $TSL  &ADD,&TAG,&FMT
&NAME    $DEFL 64,&ADD,&TAG,&FMT,0
         MEND
*                                  $MDX   MODIFY INDEX AND SKIP
         MACRO
&NAME    $MDX  &ADD,&TAG,&FMT
&NAME    $DEF  112,&ADD,&TAG,&FMT
         MEND
*                                  $STL   STORE LOCATION COUNTER
         MACRO
&NAME    $STL  &ADD,&FMT
&NAME    $STX  &ADD,0,&FMT
         MEND
*                                  $MDM   MODIFY MEMORY
         MACRO
&NAME    $MDM  &ADD,&VALUE
         AIF   ('&VALUE'(1,1) EQ '-').B
         AIF   ('&ADD'(1,1) EQ '$').A
&NAME    DC    0SL2(A-&VALUE),AL1(116,&VALUE),AL2((&ADD-$Z)/2)
         MEXIT
.A       ANOP
&NAME    DC    0SL2(A-&VALUE),AL1(116,&VALUE),AL2(&ADD)
         MEXIT
.B       AIF   ('&ADD'(1,1) EQ '$').C
&NAME    DC    0SL2(B&VALUE),AL1(116,0&VALUE),AL2((&ADD-$Z)/2)
         MEXIT
.C       ANOP
&NAME    DC    0SL2(B&VALUE),AL1(116,0&VALUE),AL2(&ADD)
         MEND
*                                  $WAIT  WAIT FOR INTERRUPT
         MACRO
&NAME    $WAIT
&NAME    DC    X'3000'
         MEND
*                                  $XIO   EXECUTE I/O
         MACRO
&NAME    $XIO  &ADD,&TAG,&FMT
&NAME    $DEF  8,&ADD,&TAG,&FMT
         MEND
*                                  $BSS   BLOCK STARTED BY SYMBOL
         MACRO
&NAME    $BSS  &NWRDS,&EVEN
         AIF   ('&EVEN' EQ '').B
         AIF   ('&EVEN' EQ 'E').A
         MNOTE 'ILLEGAL ALIGNMENT PARAMETER. ''E'' ASSUMED.'
.A       ANOP
&NAME    DS    0F,(&NWRDS)H
         MEXIT
.B       ANOP
&NAME    DS    (&NWRDS)H
         MEND
*                                  $BES   BLOCK ENDED BY SYSMBOL
         MACRO
&NAME    $BES  &NWRDS,&EVEN
         AIF   ('&EVEN' EQ '').B
         AIF   ('&EVEN' EQ 'E').A
         MNOTE 'ILLEGAL ALIGNMENT PARAMETER. ''E'' ASSUMED.'
.A       DS    0F,(&NWRDS)H
&NAME    DS    0H
         MEXIT
.B       DS    (&NWRDS)H
&NAME    DS    0H
         MEND
*                                  NULL OPERATION FOR DEFINING S
         MACRO
&NAME    $NULL
&NAME    DS    0H
         MEND
*                                  $ADCON    1130 ADCON EQUIVALENT
         MACRO
&NAME    $ADCON &ADDR
&NAME    DC    AL2((&ADDR-$Z)/2)
         MEND
*                                  $NOP  NO OPERATION
         MACRO
&NAME    $NOP
&NAME    $SLA  0
         MEND
*                                  $ZAC  CLEAR AC
         MACRO
&NAME    $ZAC
&NAME    $SRA  16
         MEND
         SPACE 1
         TITLE 'RTP1130 (SYSTEM MACRO DEFINITIONS)'
***********************************************************************
*                                  TRACE ROUTINE LINKAGE              *
***********************************************************************
         MACRO
         $TRACE
         GBLA  &TRACE              TRACE INDICATOR AND TABLE SIZE
         AIF   (&TRACE EQ 0).NOTRACE
         $TSL  STRACE              $TRACE LINKAGE
         DC    H'0'                ENTRY COUNTER
.NOTRACE MEND
*
***********************************************************************
*                                  $DEQUE - DEQUEUE AN ELEMENT        *
***********************************************************************
*                                                                     *
         MACRO
&NAME    $DEQUE &QP                &QP=QUEUE POINTER
&NAME    $NULL
         AIF   ('&QP' EQ '').A
         $AXT  &QP,WC,L            GET QUEUE POINTER
.A       $TSL  SGETQEL             GO TO DEQUEUE ROUTINE
         MEND
*
***********************************************************************
*                                  $QACTL - QUEUE AN ACTIVE ELEMENT   *
***********************************************************************
*                                                                     *
         MACRO
&NAME    $QACTL &QP,&QE            &QP=QUEUE POINTER, &QE=QUEUE ELEMENT
&NAME    $NULL
         AIF   ('&QE' EQ '').A
         $LD   &QE,,L              GET QUEUE ELEMENT ADDRESS
.A       AIF   ('&QP' EQ '').B
         $AXT  &QP,WC,L            GET QUEUE POINTER ADDRESS
.B       $TSL  SPUTAQL             GO TO ENQUEUE ROUTINE
         MEND
*
***********************************************************************
*                                  $QFREL - QUEUE A FREE ELEMENT      *
***********************************************************************
*                                                                     *
         MACRO
&NAME    $QFREL &QP,&QE            QP=QUEUE POINTER
&NAME    $NULL
         AIF   ('&QE' EQ '').A
         $LD   &QE,,L              GET ELEMENT ADDRESS
.A       AIF   ('&QP' EQ '').B
         $AXT  &QP,WC,L            GET QUEUE POINTER ADDRESS
.B       $TSL  SPUTFQL             GO TO ENQUEUE ROUTINE
         MEND
*
         EJECT
***********************************************************************
*                                  $GENQ - GENERATE CHAINED QUEUE     *
***********************************************************************
*                                                                     *
         MACRO
         $GENQ &ID=,&SIZE=,&NUM=
         LCLA  &CNT
&ID.AQP  DC    AL2(*-*)            ACTIVE ELEMENT QUEUE POINTER
&ID.BGN  $BSS  0,E                 START OF QUEUE
.A       $ADCON (*+4*D1+2*&SIZE)   CHAIN WORD
         DC    AL2(0)              ROOM FOR FIRST  CONTROL WORD
         DC    AL2(0)              ROOM FOR SECOND CONTROL WORD
         DC    AL2(0)              SPARE WORD
         DC    (&SIZE)AL2(0)       DATA AREA
&CNT     SETA  &CNT+1              INCREMENT COUNTER
         AIF   (&CNT LT &NUM-1).A  GENERATE &NUM-1 ENTRIES
         DC    AL2(0)              LAST ENTRY
         DC    AL2(0)              ROOM FOR FIRST  CONTROL WORD
         DC    AL2(0)              ROOM FOR SECOND CONTROL WORD
         DC    AL2(0)              SPARE WORD
         DC    (&SIZE)AL2(0)
         MEND
***********************************************************************
*                                  $WTO - TYPE SPECIFIED MESSAGE      *
***********************************************************************
         MACRO
&NAME    $WTO  &MESS,&NONE
&NAME    $NULL
         $TSL  SWTOPR              LINKAGE TO CONSOLE QUEUEING ROUTINE
         $ADCON (&NONE)            EXIT ADDRESS IF NO BUFFER AVAILABLE
         $ADCON (&MESS)            ADDRESS OF MESSAGE TO BE TYPED
         MEND
         TITLE 'RTP1130 (GLOBAL SET DEFINITIONS)'
         SPACE 3
***********************************************************************
*              GLOBAL DEFINITIONS                                     *
***********************************************************************
         GBLA  &RMTID              REMOTE IDENTIFICATION NUMBER
         GBLA  &MACHSIZ            1130 CORE SIZE IN WORDS
         GBLA  &RTPLORG            RTPLOAD ORIGIN IN 1130
         GBLA  &DEBUG              DEBUG MODE INDICATOR
         GBLA  &REP                PATCH MODE SWITCH
         GBLA  &TRACE              TRACE INDICATOR AND TABLE SIZE
         GBLA  &RD2501             CARD READER (2501-A1,A2)
         GBLB  &RD1442             CARD READER (1442-6,7)
         GBLB  &PN1442             CARD PUNCH (1442-5 OR 6,7)
         GBLB  &RP1442             CARD READER/PUNCH (1442-6,7)
         GBLB  &XX1442             DEFINE EXISTENCE OF 1442
         GBLA  &PR1132             PRINTER (1132)
         GBLA  &PR1403             PRINTER (1403-6,7)
         GBLA  &BSCALO             BSCA (STANDARD)
         GBLA  &BSCAHI             BSCA (SPECIAL)
         GBLA  &CNPSIZE            CONSOLE MESSAGE SIZE IN BYTES
         GBLA  &CONINSZ            CONSOLE INPUT TANK SIZE
         GBLA  &PRFOTLW            1403 PRINTER LINE WIDTH IN BYTES
         GBLA  &TRANPRN            TRANSPARENCY MODE INDICATOR
         GBLA  &TPBFSIZ            DEFAULT HASP TP BUFFER SIZE
         GBLA  &MLBFSIZ            MULTI-LEAVING BUFFER SIZE
         GBLA  &TPBFSZE            RTP1130 TP BUFFER SIZE
         GBLA  &LINESPD            LINE BAUD RATE
         GBLA  &CLOCK              DATA SET OR INTERNAL CLOCKING
         GBLA  &PRTSTRV            PRINT STREAM INITIAL VALUE
         GBLA  &PUNSTRV            PUNCH STREAM INITIAL VALUE
         GBLA  &RDRSTRV            READER STREAM INITIAL VALUE
         GBLA  &CNSKSTR            CONSOLE INPUT STREAM VALUE
         GBLA  &CNSPSTR            CONSOLE PRINT STREAM VALUE
         GBLA  &PRTFCSV            PRINT STREAM INITIAL FCS VALUE
         GBLA  &PUNFCSV            PUNCH STREAM INITIAL FCS VALUE
         GBLA  &RDRFCSV            READER STREAM INITIAL FCS VALUE
         GBLA  &CNSKFCS            CONSOLE INPUT FCS VALUE
         GBLA  &CNSPFCS            CONSOLE PRINT FCS VALUE
         GBLA  &PRFOTKL            NUMBER OF 1403 TANKS
         GBLA  &PRETTKL            NUMBER OF 1132 TANKS
         GBLA  &PUNFTKL            NUMBER OF 1442 (PUNCH) TANKS
         GBLA  &CONSTKL            NUMBER OF CONSOLE TANKS
         GBLA  &PRFOBFL            NUMBER OF 1403 TP BUFFERS
         GBLA  &PRETBFL            NUMBER OF 1132 TP BUFFERS
         GBLA  &PUNFBFL            NUMBER OF 1442 (PUNCH) TP BUFFERS
         GBLA  &CNSPBFL            NUMBER OF CONSOLE (PRINT) TP BUFFERS
         GBLA  &NPTFBFL            NUMBER OF INPUT DEVICE TP BUFFERS
         GBLA  &CMPTYPE            COMPRESSION TECHNIQUE
         GBLB  &DOCUMNT            DETAILED INTERNAL DOCUMENTATION
         GBLA  &FULLIST            FULL LISTING OPTION
         GBLA  &DELAY              DELAY COUNT FOR PROGRAM TIMER
         TITLE 'RTP1130 (HASPGEN VARIABLES)'
         SPACE 3
***********************************************************************
*              REMOTE TERMINAL GENERATION VARIABLES                   *
***********************************************************************
         SPACE 2
&MACHSIZ SETA  8*1024              1130 CORE SIZE IN WORDS
&RTPLORG SETA  2*(&MACHSIZ-1024)   RTPLOAD ORIGIN (-1K)
         SPACE 2
$Z       START 0                   DEFINE RELOCATABLE LOCATION 0
$RTPLORG EQU   &RTPLORG            DEFINE ABSOLUTE VALUE FOR &RTPLORG
$MACHSIZ EQU   &MACHSIZ            DEFINE ABSOLUTE VALUE FOR &MACHSIZ
         ORG   *+$RTPLORG          ORIGIN AT &RTPLORG
START    EQU   *                   DEFINE START SYMBOL
         SPACE 2
&RMTID   SETA  1                   DEFINE REMOTE IDENTIFICATION
&DEBUG   SETA  0                   SET TO 1 IF DEBUG
&TRACE   SETA  0                   TRACE INDICATOR AND TABLE SIZE
&REP     SETA  1                   SET TO 1 FOR REP OPTION
&DOCUMNT SETB  0                   SET TO 1 IF DETAILED DOCUMENTATION
&FULLIST SETA  1                   SET TO 0 FOR NO MACRO EXPANSION
         SPACE 2
&RD2501  SETA  0                   SET TO 1 IF 2501 READER
&RD1442  SETB  1                   SET TO 0 IF NO 1442 READER FUNCTION
&PN1442  SETB  1                   SET TO 0 IF NO 1442 PUNCH FUNCTION
&RP1442  SETB  (&RD1442 AND &PN1442)  SET 0 IF NO 1442 READER/PUNCH
&XX1442  SETB  (&RD1442  OR &PN1442)  SET 0 IF NO 1442
&PR1403  SETA  1                   SET TO 0 IF NO 1403 PRINTER
&PR1132  SETA  0                   SET TO 1 IF 1132 PRINTER
&BSCALO  SETA  1                   SET TO 1 IF STANDARD BSCA
&BSCAHI  SETA  0                   SET TO 1 IF SPECIAL BSCA
         SPACE 2
&CNPSIZE SETA  120                 CONSOLE PRINTER SIZE IN BYTES
&CONINSZ SETA  120                 CONSOLE INPUT TANK SIZE
&PRFOTLW SETA  120                 1403 PRINTER LINE WIDTH
         SPACE 1
&TRANPRN SETA  1                   SET TO 0 IF NO TRANSPARENCY
&TPBFSIZ SETA  400                 DEFAULT HASP TP BUFFER SIZE
&MLBFSIZ SETA  &TPBFSIZ            MULTI-LEAVING TP BUFFER SIZE
&TPBFSZE SETA  &MLBFSIZ            RTP1130 TP BUFFER SIZE
&LINESPD SETA  2000                LINE BAUD RATE
&CLOCK   SETA  0                   SET TO 1 IF INTERNAL CLOCKING
&DELAY   SETA  3                   DELAY COUNT FOR PROGRAM TIMER
         EJECT
&PRTSTRV SETA  X'94'               PRINT STREAM INITIAL VALUE
&PUNSTRV SETA  X'95'               PUNCH STREAM INITIAL VALUE
&RDRSTRV SETA  X'93'               READER STREAM INITIAL VALUE
&CNSPSTR SETA  X'91'               CONSOLE PRINT STREAM VALUE
&CNSKSTR SETA  X'92'               CONSOLE INPUT STREAM VALUE
&PRTFCSV SETA  X'08'               PRINT STREAM INITIAL FCS VALUE
&PUNFCSV SETA  X'01'               PUNCH STREAM INITIAL FCS VALUE
&RDRFCSV SETA  X'08'               READER STREAM INITIAL FCS VALUE
&CNSPFCS SETA  X'40'               CONSOLE PRINT FCS VALUE
&CNSKFCS SETA  X'40'               CONSOLE INPUT FCS VALUE
&PRFOTKL SETA  2                   NUMBER OF 1403 TANKS
&PRETTKL SETA  2                   NUMBER OF 1132 TANKS
&PUNFTKL SETA  2                   NUMBER OF 1442 TANKS (PUNCH)
&CONSTKL SETA  5                   NUMBER OF CONSOLE PRINT TANKS
&PRFOBFL SETA  2                   NUMBER OF 1403 TP BUFFERS
&PRETBFL SETA  2                   NUMBER OF 1132 TP BUFFERS
&PUNFBFL SETA  2                   NUMBER OF 1442 (PUNCH) TP BUFFERS
&CNSPBFL SETA  1                   NUMBER OF CONSOLE (PRINT) TP BUFFERS
&NPTFBFL SETA  (&RD2501+&RD1442+1) NUMBER OF INPUT DEVICE TP BUFFERS
         SPACE 3
&CMPTYPE SETA  2                   COMPRESSION TECHNIQUE
*
*                                  SET = 0 IF NO COMPRESSION
*
*                                  SET = 1 IF TRAILING BLANK
*                                          ELIMINATION ONLY
*
*                                  SET = 2 IF COMPRESSION OF ALL
*                                          IDENTICAL CHARACTERS
*                                          AND TRAILING BLANK
*                                          ELIMINATION
         TITLE 'RTP1130 (SYSTEM COMMUNICATION LOCATIONS)'
         SPACE 3
***********************************************************************
*              SYMBOLIC DEFINITIONS OF SYSTEM COMMUNICATION LOCATIONS *
***********************************************************************
         SPACE 3
$DUMPPTR EQU   0                   LOCATION OF SHORT FORM BRANCH
*                                  ($B $DUMP) TO SYSTEM DUMP LINKAGE
$WAIT    EQU   14                  LOCATION OF GENERAL 'WAIT' ROUTINE
*                                  ENTERED VIA $TSL $WAIT
*        EQU   15                  LOCATION OF WAIT INSTRUCTION
*        EQU   16                  LOCATION OF $B $WAIT,,I INSTRUCTION
$DUMP    EQU   18                  LOCATION OF $TSL $SDUMP
$LLIMIT  EQU   $DUMP+2             LOWER LIMIT OF TERMINAL DUMP
$ULIMIT  EQU   $LLIMIT+1           UPPER LIMIT OF TERMINAL DUMP
$CORESIZ EQU   $ULIMIT             CELL CONTAINING 1130 CORE SIZE
$ERRLOG  EQU   $CORESIZ+1          START OF LOG AREA
$ERRFFWT EQU   $ERRLOG             1403 WRITE ERROR COUNTER
$ERRETSC EQU   $ERRLOG+1           1132 SCAN CHECK COUNTER
$ERRSCRT EQU   $ERRLOG+2           SCA (LOW) RECEIVE TIMEOUT
$ERRSCWC EQU   $ERRLOG+3           SCA (LOW) TRANSMIT CHECK
$ERRSCTT EQU   $ERRLOG+4           SCA (LOW) TRANSMIT TIMEOUT
$ERRSCXX EQU   $ERRLOG+5           SCA (LOW) UNIDENTIFIED INTERRUPT
$PRTSCAN EQU   32                  1132 PRINTER SCAN AREA
         TITLE 'RTP1130 (UNIQUE KEYWORD DEFINITIONS)'
***********************************************************************
*              DEVICE CODES FOR I/O UNITS ALA IOCC                    *
***********************************************************************
         SPACE 3
$SWITCH  EQU   X'3800'             CONSOLE SWITCHES
$CONSOLE EQU   X'0800'             CONSOLE/KEYBOARD PRINTER
$1442    EQU   X'1000'             1442 CARD READER/PUNCH
$1132    EQU   X'3000'             1132 PRINTER
$ENTRY   EQU   X'3800'             CONSOLE ENTRY SWITCHES
$2501    EQU   X'4800'             2501 READER
$SCALOW  EQU   X'5000'             LOW SPEED BSCA
$1403    EQU   X'A800'             1403 PRINTER
         SPACE 2
***********************************************************************
*              I/O FUNCTIONS ALA IOCC                                 *
***********************************************************************
         SPACE 3
$WRITE   EQU   X'0100'             WRITE
$READ    EQU   X'0200'             READ
$SENSEI  EQU   X'0300'             SENSE INTERRUPT
$CONTROL EQU   X'0400'             CONTROL
$IWRITE  EQU   X'0500'             INITIATE WRITE
$IREAD   EQU   X'0600'             INITIATE READ
$SENSED  EQU   X'0700'             SENSE DEVICE
         SPACE 3
***********************************************************************
*              CONDITION CODE TEST BITS                               *
***********************************************************************
         SPACE 3
O        EQU   1                   OVERFLOW INDICATOR OFF
C        EQU   2                   CARRY INDICATOR OFF
E        EQU   4                   AC CONTENTS EVEN
P        EQU   8                   AC POSITIVE, NOT ZERO
N        EQU   16                  AC NEGATIVE
Z        EQU   32                  AC ZERO
         EJECT
         SPACE 3
***********************************************************************
*              MISCELLANEOUS UNIQUE SYMBOL DEFINITIONS                *
***********************************************************************
         SPACE 2
D1       EQU   2                   DISPLACEMENT OF 1 1130 WORD
A        EQU   127                 DEFINED TO
B        EQU   128                  SHORTEN MACRO
D        EQU   256                   EXPANSION LINE
         SPACE 1
***********************************************************************
*              BINARY SYNCHRONOUS CONTROL CHARACTERS                  *
***********************************************************************
         SPACE 1
$SOH     EQU   X'01'               START OF HEADING
$STX     EQU   X'02'               START OF TEXT
$ETX     EQU   X'03'               END OF TEXT
$DLE     EQU   X'10'               DATA LINK ESCAPE
$ETB     EQU   X'26'               END OF BLOCK
$ENQ     EQU   X'2D'               ENQUIRY
$SYN     EQU   X'32'               SYNCHRONOUS IDLE
$EOT     EQU   X'37'               END OF TRANSMISSION
$NAK     EQU   X'3D'               NEGATIVE ACKNOWLEDGEMENT
$ACK0    EQU   X'70'               POSITIVE ACKNOWLEDGEMENT
$PAD     EQU   X'FF'               PAD CHARACTER
         EJECT
***********************************************************************
*              SCA FUNCTION INDICATORS FOR BSXIOS INTERPRETATION      *
***********************************************************************
         SPACE 2
$BSXRDX  EQU   0                   READ (RECEIVE) FUNCTION
$BSXTMR  EQU   1                   PROGRAM TIMER FUNCTION
$BSXTNT  EQU   2                   TRANSMIT NORMAL TEXT
$BSXTTT  EQU   3                   TRANSMIT TRANSPARENT TEXT
$BSXTAK  EQU   4                   TRANSMIT DLE-ACK0
$BSXTNK  EQU   5                   TRANSMIT NAK
$BSXTSQ  EQU   6                   TRANSMIT SOH-ENQ
         SPACE 3
***********************************************************************
*              CONTROL RECORD TYPE IDENTIFICATION DEFINITIONS         *
***********************************************************************
         SPACE 2
$CRREQT  EQU   X'90'               REQUEST TO START
$CRPERM  EQU   X'A0'               PERMISSION TO START
         SPACE 3
***********************************************************************
*              INPUT (LOCAL DEVICES) CHARACTER CODE DEFINITIONS       *
***********************************************************************
         SPACE 2
$CRDCODE EQU   0                   IBM CARD CODE
$PTTCODE EQU   1                   PAPER TAPE CODE
$EBCCODE EQU   2                   EBCDIC CODE
         SPACE 3
***********************************************************************
*              CONSOLE MESSAGE LIST LEVEL SYMBOLICS                   *
***********************************************************************
         SPACE 2
$LIST15  EQU   15                  HIGHEST LEVEL
         SPACE 3
***********************************************************************
*              CONSOLE RIBBON COLOR AND PRINT CODE SYMBOLICS          *
***********************************************************************
         SPACE 2
$RED     EQU   X'80'               RED RIBBON CODE
$BLACK   EQU   X'00'               BLACK RIBBON CODE
$EBCD    EQU   X'00'               EBCDIC CODE
$TILT    EQU   X'01'               TILT-ROTATE CODE
         TITLE 'RTP1130 (CONSOLE ENTRY KEY DEFINITIONS)'
***********************************************************************
*              CONSOLE ENTRY KEY DEFINITIONS                          *
***********************************************************************
*                                                                     *
*                                  KEY  DESCRIPTION                   *
*                                  ---  -----------                   *
$KEY00   EQU   X'8000'               0  SET ON TO UPDATE $ENTKEYS WITH
*                                       VALUE OF ENTRY KEYS READ EACH
*                                       COMMUTATOR CYCLE
*                                                                     *
$KEY01   EQU   X'4000'               1  SET ON TO INHIBIT SCA TRACE
*
*                                    -  KEYS 2 THRU 7 ARE RESERVED FOR
*                                       SYSTEM PROGRAMMER WHIMS
*                                                                     *
*                                    -  KEYS 8 THRU 15 ARE AVAILABLE
*                                       FOR SENSIBLE OPERATIONAL USE
*                                                                     *
         TITLE 'RTP1130 (INDEX REGISTER DEFINITIONS)'
***********************************************************************
*              ABSOLUTE DEFINITION FOR INDEX REGISTERS                *
***********************************************************************
         SPACE 3
XR1      EQU   1                   INDEX REGISTER 1
XR2      EQU   2                   INDEX REGISTER 2
XR3      EQU   3                   INDEX REGISTER 3
         SPACE 3
***********************************************************************
*              STANDARD SYMBOLICS FOR WORK REGISTERS                  *
***********************************************************************
         SPACE 3
WA       EQU   XR1                 WORK REGISTER 1
WB       EQU   XR2                 WORK REGISTER 2
WC       EQU   XR3                 WORK REGISTER 3
         SPACE 3
         AIF   (&FULLIST EQ 1).XPANDOK
         PRINT NOGEN               DELETE MACRO EXPANSIONS
.XPANDOK ANOP
         TITLE 'RTPLOAD (ERROR CODE DEFINITIONS)'
         SPACE 3
***********************************************************************
*              ERROR CODES WHICH ARE DISPLAYED IN AC AT $WAIT TIME    *
***********************************************************************
         DS    0H
*ERROR1  DC    AL2(X'FFF1')        CARD READER OUT OF READY
SERROR2  DC    AL2(X'FFF2')        CHECKSUM ERROR ON LOAD CARD
SERROR3  DC    AL2(X'FFF3')        REP CARD FORMAT ERROR
*ERROR4  DC    AL2(X'FFF4')        BAD CALL TO 'RDCARD'
         TITLE 'RTPLOAD (INITIALIZATION SECTION)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - RTPLOAD                                                     *
*                                                                     *
* FUNCTION/OPERATION                                                  *
*                                                                     *
*  RTPLOAD IS THE MAIN LOADER FOR THE RTP1130 PROGRAM. RTPLOAD IS     *
*  LOADED INTO UPPER 1130 CORE BY THE BOOTSTRAP LOADER RTPBOOT.       *
*  THE MAJOR FUNCTIONS PERFORMED BY RTPLOAD ARE...                    *
*                                                                     *
*                    1. CLEARS DEFINED 1130 CORE UP TO ORIGIN OF      *
*                       RTPLOAD                                       *
*                                                                     *
*                    2. SETS INTERRUPT TRANSFER VECTORS AND A 'WAIT'  *
*                       ROUTINE IN LOWER CORE                         *
*                                                                     *
*                    3. TESTS THE VALUE OF HEX LOCATION 28 FOR AN     *
*                       INDICATION OF THE CARD READER BEING USED.     *
*                       INITIALIZES THE CARD READER ROUTINE FOR 1442  *
*                       OR 2501 OPERATION                             *
*                                                                     *
*                    4. READS AND PROCESSES RTP1130 DECK              *
*                                                                     *
*                    5. READS AND PROCESSES REP CARDS IF ANY          *
*                                                                     *
*                    6. READS AND PROCESSES /*SIGNON CARD IF ANY      *
*                                                                     *
*                    7. LOADS ADDRESS OF /*SIGNON CARD IN REGISTER    *
*                       WB AND TRANSFERS CONTROL TO RTP1130           *
*                       NOTE..IF A /*SIGNON CARD IS NOT READ, THEN    *
*                       A DEFAULT /*SIGNON CARD AS PRODUCED BY        *
*                       THE RMTGEN PROCESS IS USED                    *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              CLEAR 1130 CORE FROM &RTPLORG-1 TO 0                   *
***********************************************************************
RTPLINIT $NULL                     INITIALIZATION BEGINS HERE
         $LD   40,,L               GET 1442 COLUMN INTERRUPT ENTRY
         $STO  COLITVL             SAVE FOR LATER INTERROGATION
         $AXT  $RTPLORG/2-1,WA,L   LENGTH OF CORE TO CLEAR
         $ZAC                      CLEAR AC
RTPLICLR $STO  0,WA                CLEAR A CORE LOCATION
         $MDX  -1,WA               INCREMENT AND TEST INDEX
         $B    RTPLICLR            KEEP GOING
*                                  ALL DONE...
***********************************************************************
*              SET INTERRUPT VECTORS IN LOCATIONS 8 THRU 13           *
***********************************************************************
         $AXT  6,WA                NUMBER OF TRANSFER VECTORS
RTPLIGET $LD   RTPLIVCT-D1,WA,L    GET A VECTOR
         $STO  7,WA,L              STORE IT
         $MDX  -1,WA               DECREMENT AND TEST INDEX
         $B    RTPLIGET            GET NEXT VECTOR
         EJECT
***********************************************************************
*              SET UP GENERAL WAIT ROUTINE IN LOW CORE                *
***********************************************************************
         $LD   RTPLWT1             GET 'WAIT' INSTRUCTION
         $STO  $WAIT+1,,L          STORE IN $WAIT+1
         $LD   RTPLWT2             GET $B $WAIT,,I INSTRUCTION
         $STO  $WAIT+2,,L          STORE IN $WAIT+2
         $LD   RTPLWT2+D1          GET SECOND HALF
         $STO  $WAIT+3,,L          STORE IT
         $B    RTPLTRDR            GO TEST READER TYPE
RTPLWT1  $WAIT                     WAIT FOR $WAIT
RTPLWT2  $B    $WAIT,,I            RETURN FOR $WAIT
***********************************************************************
*              TEST FOR 2501/1442 READER AND ADJUST PROGRAM IF 1442   *
***********************************************************************
RTPLTRDR $NULL
         $LD   COLITVL             GET RTPBOOT 1442  COLUMN INTERRUPT
         $SRA  1                   CLEAR AC IF NO COLUMN INTERRUPT
         $BNZ  RTPLNT25            BRANCH IF 1442 COLUMN INTERRUPT
         $B    RTPLPB               OTHERWISE ASSUME 2501 READER
***********************************************************************
*              1442 INITIALIZATION VALUES                             *
***********************************************************************
         $BSS  0,E                 FOR EVEN STORAGE ASSIGNMENT
RTPLNOPI $NOP                      NOP FOR 1442 ADJUSTMENT
RTPLTR25 DC    AL2($2501+$SENSED)  SENSE 2501 NO RESET
RTPFFIR  DC    AL2($1442+$CONTROL+4) START 1442 COMMAND
RTPLTR42 DC    AL2($1442+$SENSED)  SENSE 1442 NO RESET
RTPLSRS4 DC    AL2($1442+$SENSED+2) SENSE WITH LEVEL 4 RESET
COLITVL  DC    AL2(*-*)            SET TO 1 IF 2501 READER
         $ADCON (RTPLZERO)         POINTER TO ZERO WORD COUNT
RTPLFEED DC    AL2($IREAD+$2501)   2501 FEED COMMAND
RTPLZERO DC    AL2(0)              ZERO WORD COUNT
RTPLFD42 DC    AL2($CONTROL+$1442+2) FEED COMMAND FOR 1442
*                                  MODIFY PROGRAM FOR 1442
RTPLNT25 $NULL
         $XIO  RTPLTR42-D1         SENSE 1442 WITHOUT RESET
         $BOD  RTPLTRDR            LOOP IF NOT READY
         $LD   RTPLSRS4            GET 1442 SENSE/RESET LEVEL 4
         $STO  RE252,,L            STORE IN CARD READ ROUTINE
         $LD   RTPFFIR             GET 1442 START READ COMMAND
         $STO  RE264+D1,,L         STORE IN CARD READ ROUTINE
         $LD   RTPLTR42            GET 1442 SENSE WITHOUT RESET
         $STO  RE288,,L            STORE IN CARD READ ROUTINE
         $LD   RTPLFD42            SET FEED COMMAND
         $STO  RTPLFEED            FOR 1442
         TITLE 'RTPLOAD (LOAD PROCESSOR)'
         SPACE 3
***********************************************************************
*              COMMENCE THE LOAD PROCESS                              *
***********************************************************************
RTPLPB   $NULL                     PRIME FIRST BUFFER
         $TSL  RDCARD              LINK TO CARD READ ROUTINE
         DC    X'1000'             READ PARAMETER
         $ADCON RTPLB1             POINTER TO FIRST BUFFER
         $ADCON RTPLUE             UNUSUAL END ROUTINE
*                                  WAIT FOR BUFFER  TO FILL
RTPLUP   $TSL  RDCARD              LINK TO CARD READ ROUTINE
         DC    X'0000'             TEST PARAMETER
         $B    RTPLUP              KEEP TESTING
         $LDD  RTPLBP              GET BUFFER POINTERS
         $RTE  16                  SWITCH BUFFERS
         $STD  RTPLBP              SET NEW POINTERS
         $MDM  RTPNDS,0            TEST LAST CARD FLAG
         $B    RTPZIPP             BRANCH IF ON
         $STO  RTPLNX              SET FOR NEXT READ
         $TSL  RDCARD              START READ INTO ALTERNATE BUFFER
         DC    X'1000'             READ PARAMETER
RTPLNX   DC    AL2(*-*)            MODIFIED TO ALTERNATE BUFFER
         $ADCON RTPLUE             UNUSUAL END ROUTINE ADDRESS
RTPZIPP  $NULL
         $LD   RTPLBP+D1           GET PRIMED BUFFER ADDRESS
         $STO  RTPLCL+D1           SET TEXT CARD PROCESSOR
RTPANOP  $A    C1                  POINT TO DATA
         $STO  RTPLDP              IN CONVERSION CALL
         $TSL  CONVRT              GO CONVERT CARD CODE TO EBCDIC
RTPLDP   DC    AL2(*-*)            SET TO ADDRESS OF INPUT/OUTPUT
***********************************************************************
*              TEST CARD TYPE AND GO TO PROPER ROUTINE                *
***********************************************************************
         $LXA  RTPLDP,WA           OUTPUT AREA ADDRESS
         $LD   0,WA                GET COLUMNS 1 AND 2
         $SRA  8                   COLUMN 1 TO LOW ORDER AC
         $S    RTPLCT              TEST FOR TEXT CARD
         $BZ   RTPLTX              BRANCH IF TEXT
         $LD   0,WA                NO. GET COLUMNS 1 AND I
         $AND  XFF00               MASK COLUMN 2
         $S    RTPLEN              TEST FOR END CARD
         $BNZ  RTPLUP              IGNORE IF NONE OF THE ABOVE
***********************************************************************
*              END CARD PROCESSOR                                     *
***********************************************************************
         $LD   1,WA                GET RIGHT HALF OF LOAD ADDRESS
         $SRT  16                  TO EXT
         $LD   0,WA                GET LEFT HALF OF LOAD ADDRESS
         $SLT  8                   FORM COMPLETE LOAD ADDRESS
         $STO  RTPLGO+D1           SAVE IT FOR GO...
RTPLLC   $NULL
         $LD   RTPNDS              GET LAST CARD FLAG
         $BZ   RTPLRP,,L           GO TO REP ROUTINE IF MORE CARDS
***********************************************************************
*              TERMINATION OF RTPLOAD                                 *
***********************************************************************
RTPLEND  $NULL
         $XIO  RTPLFEED-D1,,L      EJECT LAST CARD FROM READER
         $AXT  RTPETSOR,WB,L       ADDRESS OF SIGN-ON RECORD
RTPLGO   $B    *-*,,L              GO GO GO
***********************************************************************
*              TEXT CARD PROCESSOR                                    *
***********************************************************************
RTPXMS   DC    X'00FF'             MASK FOR HIGH ORDER BYTE
RTPLCK   DC    H'0'                CHECKSUM ACCUMULATOR
RTPLTX   $NULL                     TEXT CARD PROCESSOR
         $ZAC                      CLEAR AC
         $STO  RTPLCK              CLEAR CHECKSUM ACCUMULATOR
         $AXT  36,WB               SET WB FOR 72 COLUMNS
RTPLCL   $LD   *-*,WB,L            GET 2 COLUMNS
         $SRT  8                   MAKE IT 1 COLUMN
         $AND  RTPXMS              CLEAR HIGH BYTE
         $A    RTPLCK              COMPUTE COLUMN CHECKSUM
         $STO  RTPLCK              SAVE IT
         $ZAC                      CLEAR AC
         $SLT  8                   GET OTHER COLUMN
         $A    RTPLCK              COMPUTE CHECKSUM
         $STO  RTPLCK
         $MDX  -1,WB               DO IT FOR 72 COLUMNS
         $B    RTPLCL              KEEP GOING
***********************************************************************
*              COMPARE COMPUTED CHECKSUM WITH CARD VALUE              *
***********************************************************************
         $LD   36,WA               GET LETRRIP CHECKSUM
         $S    RTPLCK              COMPARE IT WITH RTPLOAD VALUE
         $BNZ  RTPLCE              BRANCH IF ERROR
***********************************************************************
*              FORM LOAD ADDRESS FOR DATA ON THIS CARD                *
***********************************************************************
RTPLGULP $NULL
         $LD   1,WA                GET RIGHT HALF OF LA
         $SRT  16                  TO EXT
         $LD   0,WA                GET LEFT HALF
         $SLT  8                   FORM LA IN AC
         $STO  TEMP1               TO TEMP STORAGE
         $LXA  TEMP1,WB            TO WB
         $ZAC                      CLEAR AC
         $SLT  8                   WORD COUNT FROM EXT
         $STO  RTPLWC              SAVE IT
RTPLDR   $LD   2,WA                GET DATA TO BE LOADED
         $STO  0,WB                LOAD IT
         $MDX  1,WA                INCREMENT WA
         $MDX  1,WB                AND WB
         $MDM  RTPLWC,-1           DECREMENT AND TEST WORD COUNT
         $B    RTPLDR              MORE TO LOAD
         $B    RTPLUP              GET NEXT BUFFER
         EJECT
***********************************************************************
*        CHECKSUM ERROR ROUTINE                                       *
***********************************************************************
RTPLCE   $NULL
         $LD   SERROR2,,L          GET CHECKSUM ERROR CODE
         $TSL  $WAIT               GO TO $WAIT ROUTINE
         $B    RTPLGULP            IGNORE ERROR ON RETURN
***********************************************************************
*              UNUSUAL END ROUTINE FOR 2501                           *
***********************************************************************
RTPLUE   DC    H'0'                ENTERED FROM RD2501
         $BNZ  RTPLUE,,I           RETRY ON ALL ERRORS
         $STL  RTPNDS              LAST CARD RUN UP THE FLAG
         $ZAC                      SET TERMINATION INDICATOR
         $B    RTPLUE,,I           AND RETURN TO READ ROUTINE
RTPNDS   DC    H'0'                SET TO NON-ZERO ON LAST CARD
***********************************************************************
*              CONSTANTS, STORAGE, BUFFERS, ETC.                      *
***********************************************************************
C1       DC    H'1'                CONSTANT UNO
XFF00    DC    X'FF00'             MASK
RTPLWC   DC    H'0'                CURRENT CARD LOAD ADDRESS
TEMP1    DC    H'0'                TEMPORARY STORAGE
RTPLCT   DC    X'00E3'             EBCDIC 'T'
RTPLEN   DC    X'C500'             EBCDIC 'E'
         $BSS  0,E                 EVEN LOCATION COUNTER
RTPLBP   $ADCON RTPLB1             BUFFER 1 POINTER
         $ADCON RTPLB2             BUFFER 2 POINTER
RTPLB1   DC    H'80'               BUFFER 1 CONTROL WORD
         $BSS  80                  BUFFER 1
RTPLB2   DC    H'80'               BUFFER 2 CONTROL WORD
         $BSS  80                  BUFFER 2
         TITLE 'REPLDR (REP CARD LOADER)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - REPLDR - REP CARD LOADER                                    *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  TO REPAIR FAULTY CODE OR TO ALLOW PROGRAMMING IN THE LOWEST        *
*  FORM. REP CARDS WITH FORMAT SHOWN BELOW MAY BE INCLUDED            *
*  FOLLOWING THE DECK LOADED BY RTPLOAD...                            *
*                                                                     *
*              COL 000000000111111111122222.........                  *
*                  123456789012345678901234.........                  *
*                  ------------------------.........                  *
*                  IREP CAAAAA CDDDD,CDDDD,...,CDDDD                  *
*                                                                     *
*              WHERE                                                  *
*                                                                     *
*                  I=ANY IDENTIFICATION CHARACTER                     *
*                                                                     *
*                  C=L FOR 'LISTING' OPTION WHERE THE                 *
*                    LOAD ADDRESS OR DATA CORRESPONDS                 *
*                    TO THE OS/360 ASSEMBLER LISTING OF               *
*                    THE PROGRAM BEING REPPED.                        *
*                                                                     *
*                  C=X FOR ABSOLUTE LOAD ADDRESS OR DATA              *
*                                                                     *
*                  A=LOAD ADDRESS OF FIRST DATA WORD AND              *
*                    IS INCREMENTED FOR EACH ADDITIONAL               *
*                    DATA WORDS ON THE CARD. REP CARDS MAY            *
*                    BE CONTINUED BY LEAVING 'A' BLANK.               *
*                                                                     *
*                  D=DATA (HEXADECIMAL) TO BE LOADED IN THE           *
*                    LOCATION COMPUTED AS A FUNCTION OF 'A'.          *
*                                                                     *
*              NOTE..THE LISTING OPTION (L) CAUSES THE SPECIFIED      *
*                    DATA TO BE DIVIDED BY 2 FOR CONVERSION FROM      *
*                    BYTE DATA TO 1130 WORD DATA. CAVEAT EMPTOR.      *
*                                                                     *
***********************************************************************
         SPACE 3
RTPLRP   $NULL
RTPRWTE  $TSL  RDCARD              WAIT FOR READ STARTED
         DC    X'0000'             BY LOADER TO COMPLETE
         $B    RTPRWTE             BRANCH IF NOT COMPLETE
         $LXA  RTPLNX,WA,L         GET BUFFER ADDRESS
         $STX  REPBFPT,WA          SET FOR NEXT READ
         $LD   RTPNDS,,L           GET LOADER LAST CARD FLAG
         $STO  REPLSC              AND STORE IN REP LAST CARD FLAG
         $B    REPNEXT             GO PROCESS REP CARD
REPREAD  $NULL
         $LD   REPLSC              TEST LAST CARD SWITCH
         $BNZ  RTPLEND             BRANCH IF ON
         $TSL  RDCARD              GO GET A REP CARD
         DC    X'1000'             READ PARAMETER
REPBFPT  DC    AL2(*-*)            SET TO DATA BUFFER ADDRESS
         $ADCON REPUSE             UNUSUAL END ROUTINE
REPTEST  $TSL  RDCARD              TEST FOR READ COMPLETE
         DC    X'0000'             TEST PARAMETER
         $B    REPTEST             WAIT FOR READ TO COMPLETE
***********************************************************************
*              TEST FOR 'REP' IN COLUMNS 2-4                          *
***********************************************************************
         $LXA  REPBFPT,WA          GET BUFFER POINTER
REPNEXT  $MDX  1,WA                POINT TO DATA
         $LD   1,WA                GET POSSIBLE 'R'
         $EOR  REPCNR              COMPARE WITH CARD CODE 'R'
         $BNZ  SIGNOT              GO TEST FOR /*SIGNON CARD
         $LD   2,WA                GET POSSIBLE 'E'
         $EOR  REPCNE              COMPARE WITH CARD CODE 'E'
         $BNZ  REPREAD             BRANCH IF NO MATCH
         $LD   3,WA                GET POSSIBLE 'P'
         $EOR  REPCNP              COMPARE WITH CARD CODE 'P'
         $BNZ  REPREAD             BRANCH IF NO MATCH
***********************************************************************
*              REP CARD DATA PROCESSOR                                *
***********************************************************************
REPROC   $NULL                     COMMENCE REPPING
         $MDX  7,WA                POINT TO LOAD ADDRESS
*                                  (ACCOMODATES 16K 1130
*                                  ONLY IF C=L)
         $LD   0,WA                GET FIRST DIGIT OF OF LOAD ADDRESS
         $EOR  REPBLK              TEST FOR BLANK (COL. 8 ONLY)
         $BZ   REPSKP              BRANCH IF BLANK AND ASSUME
*                                  CONTINUATION OF PREVIOUS LA
         $STX  REPDPT,WA           SET UP CONVERSION ROUTINE
         $TSL  SXHXBIN             GO CONVERT TO BINARY
REPDPT   DC    AL2(0)              DATA POINTER
         $BO   REPERR              BRANCH IF ERROR
         $STO  REPLDA              STORE LOAD ADDRESS
         $LD   -2,WA               GET CONTROL CHARACTER
         $EOR  REPCNX              TEST FOR 'X'
         $BZ   REPSKP              BRANCH IF 'X'
         $LD   -2,WA               GET CONTROL CHARACTER
         $EOR  REPCNL              TEST FOR 'L'
         $BNZ  REPERR              ERROR IF NOT 'X' OR 'L'
         $LD   REPLDA              IT'S 'L'. GET LOAD ADDRESS
         $SRA  1                   DIVIDE BY 2
         $STO  REPLDA              BACK TO LOAD ADDRESS CELL
REPSKP   $NULL
REPLOOP  $MDX  6,WA                POINT TO DATA
         $STX  REPDATA,WA          SET UP CONVERSION
         $TSL  SXHXBIN             GO CONVERT TO BINARY
REPDATA  DC    AL2(0)              DATA POINTER
         $BO   REPERR              BRANCH IF ERROR
         $STO  REPTMP              SAVE DATA
         $LD   -1,WA               GET CONTROL CHARACTER
         $EOR  REPCNX              TEST FOR 'X'
         $BZ   REPJMP              BRANCH IF 'X'
         $LD   -1,WA               GET CONTROL CHARACTER
         $EOR  REPCNL              TEST FOR 'L'
         $BNZ  REPERR              ERROR IF NOT 'X' OR 'L'
         $LD   REPTMP              IT'S 'L'. GET DATA
         $SRA  1                   DIVIDE BY 2
         $B    REPSTO              GO STORE IT
REPJMP   $LD   REPTMP              GET DATA
REPSTO   $STO  REPLDA,,I           STUFF IT
         $MDM  REPLDA,1            UP THE LOAD ADDRESS
*                                  AND THE IRISH
         $LD   4,WA                GET SEPARATOR OR TERMINATOR
         $EOR  REPCMA              TEST FOR COMMA
         $BZ   REPLOOP             BRANCH FOR MORE IF COMMA
         $LD   4,WA                NOT COMMA. HOW ABOUT
         $EOR  REPBLK              A BLANK (TERMINATOR)
         $BZ   REPREAD             BRANCH IF BLANK
***********************************************************************
*              REP CARD FORMAT ERROR                                  *
***********************************************************************
REPERR   $NULL
         $LD   SERROR3,,L          GET REP CARD ERROR CODE
         $TSL  $WAIT               GO TO $WAIT
         $B    REPREAD             IGNORE IF RETURN
***********************************************************************
*              UNUSUAL END WHILE READING REP CARDS                    *
***********************************************************************
REPUSE   DC    H'0'                ENTERED FROM CARD READ AT INTERRUPT
         $BNZ  REPUSE,,I           RETRY IF READ/FEED ERROR
         $STL  REPLSC              SET LAST CARD FLAG
         $ZAC                      CLEAR AC
         $B    REPUSE,,I           EXIT
***********************************************************************
*              CONSTANTS AND ALL THAT GOOD STUFF                      *
***********************************************************************
         DS    0H
REPCNR   DC    X'4010'             CARD CODE 'R'
REPCNE   DC    X'8100'             CARD CODE 'E'
REPCNP   DC    X'4040'             CARD CODE 'P'
REPBLK   DC    X'0000'             CARD CODE ' '
REPCMA   DC    X'2420'             CARD CODE ','
REPCNL   DC    X'4400'             CARD CODE 'L'
REPCNX   DC    X'2040'             CARD CODE 'X'
REPTMP   DC    H'0'                TEMPORARY STORAGE
REPLDA   DC    H'0'                LOAD ADDRESS
REPLSC   DC    H'0'                LAST CARD SWITCH FOR REP ROUTINE
         TITLE '$XHXBIN (HEXADECIMAL TO BINARY CONVERSION)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - $XHXBIN - EBCDIC HEXADECIMAL (CARD CODE) TO BINARY          *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  CONVERTS A FOUR CHARACTER HEXADECIMAL NUMBER IN CARD CODE EBCDIC   *
*  TO A ONE WORD BINARY EQUIVALENT CONTAINED IN AC AT EXIT. AC AND    *
*  EXT ARE NOT SAVED BY THIS ROUTINE                                  *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                   $TSL   $XHXBIN      LINKAGE                       *
*                   $ADCON INPUT        INPUT POINTER                 *
*                   ...                 EXIT WITH VALUE IN AC         *
*                                                                     *
* ERROR INDICATION -                                                  *
*                                                                     *
*  ILLEGAL CHARACTER (NOT HEX) INDICATED BY OVERFLOW INDICATOR        *
*  TURNED ON AND CARRY INDICATOR OFF AT EXIT                          *
*                                                                     *
***********************************************************************
         SPACE 3
SXHXBIN  DC    AL2(*-*)            ENTRY POINT
         $STX  XHXWA+D1,WA         SAVE WA
         $STX  XHXWB+D1,WB         AND WB
         $LDS  0                   TURN OFF OVERFLOW AND CARRY
         $STS  XHXST               SET FOR NORMAL EXIT
         $LXA  SXHXBIN,WA          ADDRESS OF INPUT POINTER
         $LD   0,WA                GET INPUT POINTER
         $A    XHXC3               INCREMENT TO END OF INPUT
         $STO  XHXSE+D1            SAVE END POINTER
         $MDX  1,WA                SET UP RETURN ADDRESS
         $STX  XHXEX+D1,WA         SET EXIT
XHXSE    $AXT  *-*,WA,L            END POINTER TO WA
         $LD   XHXC4               SET COUNT FOR
         $STO  XHXCT               FOUR DIGITS
XHX16    $LD   0,WA                GET CARD CODE
         $BN   XHX40               BRANCH IF SIGN BIT ON
         $AND  XHX400F             NUMERIC. CHECK FOR 1,12-15
         $BNZ  XHX42               BITS AND BRANCH IF YES
         $LD   0,WA                WHICH ROW BIT IS IT
XHX17    $AXT  12,WB               *
         $SLCA 0,WB                WB=10 IF ROW 0,WB=9 IF ROW 1, ETC.
         $S    XHX80               ERROR IF MULTIPLE ROWS
         $BNZ  XHX42               OR NO BITS ON
         $STX  XHXTM,WB            SAVE SHIFT COUNT
         $LD   XHXC10              CONSTANT 10 TO AC
         $S    XHXTM               XHXTM=ROW BIT SET
         $BSC  O                   IS DIGIT ALPHA
         $A    XHXC9               YES. ADD 9 TO ROW
         $SRT  4                   SAVE BINARY DIGITS IN EXT
         $MDX  -1,WA               NEXT DIGIT
         $MDM  XHXCT,-1            ARE WE DONE...
         $B    XHX16               NO. DO 4 DIGITS
XHXST    $LDS  0                   YES. RESTORE STATUS
XHX22    $RTE  16                  PUT RESULTS IN AC
XHXWA    $AXT  *-*,WA,L            RESTORE WA
XHXWB    $AXT  *-*,WB,L            RESTORE WB
XHXEX    $B    *-*,,L              RETURN
***********************************************************************
*              SECTION TO PROCESS ALPHA CHARACTERS                    *
***********************************************************************
XHX40    $LDS  1                   SET ALPHA INDICATOR
         $LD   0,WA                GET CHARACTER
         $AND  XHX607F             TEST FOR 11,0,7,8,9 ROW
         $BNZ  XHX42               ERROR IF SET
         $LD   0,WA                GET CHARACTER
         $EOR  XHX80               MASK 12 ROW BIT
         $B    XHX17               GO TO NORMAL PROCESSING
XHX42    $LDS  1                   SET ERROR INDICATOR
         $B    XHX22               EXIT
***********************************************************************
*              CONSTANTS AND STORAGE                                  *
***********************************************************************
XHXCT    DC    H'0'                CHARACTER COUNT
XHXC3    DC    H'3'                DECIMAL NUMBER FOR SCALING
XHXC4    DC    H'4'                ROW BIT VALUE
XHXC9    DC    H'9'                SCALING DIGIT
XHXC10   DC    H'10'               SCALING DIGIT
XHX400F  DC    X'400F'             MASK FOR BITS 1,12-15
XHX607F  DC    X'607F'             MASK FOR BITS 11,0,7,8,9
XHX80    DC    X'8000'             12-15 SIGN BIT MASK
XHXTM    DC    H'0'                TEMPORARY STORAGE
         TITLE 'RTPLOAD (INTERRUPT PROCESSORS)'
         SPACE 3
***********************************************************************
*              LEVEL 0 - 1442 CARD READ/PUNCH                         *
***********************************************************************
RTPLLVL0 DC    H'0'                ENTRY VIA HARDWARE $BSI 8,,I
         $STO  RTPL0SAC            SAVE AC
         $XIO  RTPL0SRS-D1         SENSE WITH RESET
         $LD   RE264,,L            GET CURRENT DATA POINTER-1
         $A    RTPL0CN1            POINT TO NEXT DATA SLOT
         $STO  RE264,,L            RESET DATA POINTER
         $STO  RTPL0DPT            SET FOR READ
         $XIO  RTPL0DPT            READ CURRENT COLUMN
         $LD   RTPL0SAC            RESTORE AC
         $BOSC RTPLLVL0,,I         RETURN
         $BSS  0,E                 FOR EVEN STORAGE ASSIGNMENT
RTPL0SAC DC    AL2(*-*)            AC SAVE
RTPL0SRS DC    AL2($1442+$SENSED+1) SENSE 1442 WITH RESET
RTPL0DPT DC    AL2(*-*)            COLUMN POINTER
         DC    AL2($1442+$READ)    READ 1442 COMMAND
RTPL0CN1 DC    AL2(1)              CONSTANT 1
         SPACE 1
***********************************************************************
*              LEVEL 1 - SCA AND 1130 PRINTER                         *
***********************************************************************
RTPLLVL1 DC    H'0'                ENTRY VIA HARDWARE $BSI 9,,I
         $WAIT
         SPACE 1
***********************************************************************
*              LEVEL 2 - DISK AND SAC                                 *
***********************************************************************
RTPLLVL2 DC    H'0'                ENTRY VIA HARDWARE $BSI 10,,I      *
         $WAIT
         SPACE 1
***********************************************************************
*              LEVEL 3 - 1627,2250 AND SAC                            *
***********************************************************************
RTPLLVL3 DC    H'0'                ENTRY VIA HARDWARE $BSI 11,,I
         $WAIT
         SPACE 1
***********************************************************************
*              LEVEL 4 - 1442,KB PRINTER,1134,1055,2501,1403,1231,SAC *
***********************************************************************
RTPLLVL4 DC    H'0'                ENTRY VIA HARDWARE $BSI 12,,I
         $STD  RTPL4SAQ            SAVE AC AND EXT
         $STS  RTPL4STS            AND STATUS
         $STX  RTPL4XR1+D1,XR1     XR1
         $STX  RTPL4XR2+D1,XR2     XR2
         $STX  RTPL4XR3+D1,XR3     XR3
         $XIO  RTPL4SIL-D1         SENSE ILSW
         $AND  RTPL4MSK            MASK ALL BUT 2501 AND 1442
         $BSI  RE048,,L,Z          GO IF 2501 OR 1442
*                                  IGNORE ALL OTHERS
RTPL4STS $LDS  0                   RESTORE STATUS AND
RTPL4XR1 $AXT  *-*,XR1,L           XR1
RTPL4XR2 $AXT  *-*,XR2,L           XR2
RTPL4XR3 $AXT  *-*,XR3,L           XR3
         $LDD  RTPL4SAQ            AC AND EXT
         $BOSC RTPLLVL4,,I         RETURN
RTPL4SAQ $BSS  2,E                 AC AND EXT SAVE
RTPL4MSK DC    X'3000'             MASK FOR ILSW
RTPL4SIL DC    X'0300'             IOCC FOR SENSE ILSW
         SPACE 1
***********************************************************************
*              LEVEL 5 - CONSOLE STOP AND SAC                         *
***********************************************************************
RTPLLVL5 DC    H'0'                ENTRY VIA HARDWARE $BSI 13,,I
         $WAIT                     WAIT FOR SOMEONE TO PUSH START
         $BOSC RTPLLVL5,,I         RETURN
         EJECT
***********************************************************************
*              INTERRUPT TRANSFER VECTORS                             *
***********************************************************************
         SPACE 1
RTPLIVCT $NULL                     LEVEL     VECTOR
         $ADCON RTPLLVL0           0           8
         $ADCON RTPLLVL1           1           9
         $ADCON RTPLLVL2           2          10
         $ADCON RTPLLVL3           3          11
         $ADCON RTPLLVL4           4          12
         $ADCON RTPLLVL5           5          13
         TITLE 'RTPLOAD (2501 CARD READ SUBROUTINE)    '
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - RD2501 (READ 2501 SUBROUTINE)                               *
*                                                                     *
* FUNCTION/OPERATION                                                  *
*                                                                     *
*  READS CARDS FROM THE 2501 OR 1442 READER AS MODIFIED DURING        *
*  RTPLOAD INITIALIZATION                                             *
*                                                                     *
* CALLING SEQUENCE                                                    *
*                                                                     *
*  TEST FUNCTION                                                      *
*                                                                     *
*              $TSL   RD2501       LINKAGE                            *
*              DC     X'0000'      CONTROL (TEST) PARAMETER           *
*              ...                 PREVIOUS OPERATION INCOMPLETE      *
*              ...                 PREVIOUS OPERATION COMPLETE        *
*                                                                     *
*  INITIATE READ FUNCTION                                             *
*                                                                     *
*              $TSL   RD2501       LINKAGE                            *
*              DC     X'1000'      CONTROL (READ) PARAMETER           *
*              $ADCON IOADD        I/O AREA ADDRESS                   *
*              $ADCON UNEND        UNUSUAL END ROUTINE ADDRESS        *
*              ...                 READ INITIATED                     *
*                                                                     *
***********************************************************************
RD2501   $NULL
RDCARD   EQU   RD2501
         DC    H'0'                ENTRY VIA $TSL RDCARD
         $STX  RE144+D1,WA         SAVE WA
         $LXA  RD2501,WA           CONTROL PARAMETER ADDRESS TO WA
         $STO  RE324               SAVE AC
         $STS  RE168               SAVE STATUS
         $STX  RE156+D1,WB         SAVE WB
         $LD   0,WA                GET CONTROL PARAMETER
         $SRA  12                  IS FUNCTION 'TEST'
         $BNZ  RE072               BRANCH IF NOT
         $LD   RE228               TEST FOR SUBROUTINE BUSY
         $SKPN                     SKIP IF BUSY (AC NON-ZERO)
         $MDX  1,WA                SET EXIT TO CALL+3
         $B    RE120               EXIT TO CALL+2 (OR CALL+3)
RE072    $S    RE240               IS FUNCTION LEGAL
         $BNZ  RE192               BRANCH IF NOT
RE084    $LD   RE228               IS SUBROUTINE BUSY
         $BNZ  RE084               LOOP IF YES
RE096    $XIO  RE288-D1            IS THE 2501 READY
         $BOD  RE204               BRANCH IF NOT
         $LD   1,WA,I              GET WORD COUNT
         $SKPN                     TEST FOR ZERO
         $B    RE108               BRANCH IF ZERO
         $BN   RE192               BRANCH IF NEGATIVE
         $S    RE276               0 THRU 80 IS LEGAL
         $BP   RE192               BRANCH IF GREATER THAN 80
RE108    $MDX  2,WA                SET WA TO SKIP PARAMETERS
         $LD   -1,WA               SAVE DATA
         $STO  RE264               ADDRESS
         $STO  RETRY               IN CASE OF 1442 READER
         $LD   0,WA                LOAD ERROR ADDRESS
         $STO  RE360+2*D1          STORE IN INTERRUPT ROUTINE
         $STO  RE370+2*D1          ERROR AND LAST CARD EXITS
         $STX  RE228,0             SET BUSY INDICATOR ON
         $XIO  RE264               INITIATE READ
RE120    $MDX  1,WA                SET EXIT POINTER
         $LD   RE324               RESTORE AC
RE132    $STX  RE180+D1,WA         SET TO SKIP FIRST PARAMETER
RE144    $AXT  *-*,WA,L            RESTORE WA
RE156    $AXT  *-*,WB,L            RESTORE WB
RE168    $LDS  0                   RESTORE STATUS
RE180    $B    *-*,,L              EXIT
RE192    $LD   RE312               ERROR CODE-ILLEGAL CALL
         $B    RE216               GO SET RETURN ADDRESS
RE204    $SRA  1                   IS DEVICE BUSY
         $BOD  RE096               BRANCH IF YES
         $LD   RE300               ERROR CODE-2501 NOT READY
RE216    $MDX  -2,WA               SET WAIT ROUTINE TO RETRY
         $STX  $WAIT,WA,L          WHEN OPERATOR PUSHES START
         $AXT  $WAIT+1,WA,L        GET WAIT INSTRUCTION ADDRESS
         $B    RE132               GO TO EXIT FOR RESTORATION
         SPACE 3
***********************************************************************
*              CONSTANTS                                              *
***********************************************************************
         SPACE 3
RE228    DC    H'0'                ROUTINE BUSY INDICATOR
         $BSS  0,E                 EVEN STORAGE DESIRED
RE240    DC    H'1'                CONSTANT 1
RE252    DC    X'4F01'             SENSE WITH RESET
RE264    DC    H'0'                I/O BUFFER ADDRESS
         DC    X'4E00'             IOCC TO INITIATE READ
RE276    DC    H'80'               CONSTANT
RE288    DC    X'4F00'             SENSE DSW WITHOUT RESET
RE300    DC    X'FFF1'             $ERROR1...2501 NOT READY
RE312    DC    X'FFF4'             $ERROR4...BAD CALL
RETRY    DC    AL2(*-*)            DATA ADDRESS
RE324    DC    H'0'                SAVE FOR AC
         SPACE 3
         EJECT
***********************************************************************
*                                  RD2501 INTERRUPT PROCESSING        *
***********************************************************************
RE048    DC    H'0'                ENTRY FROM INTERRUPT PROCESSOR
RE336    $XIO  RE252-D1            SENSE WITH RESET
         $SLA  3                   CHECK FOR READ ERROR
         $BC   RE360               YES. GO TO ERROR ROUTINE
         $BSC  P+Z                 TEST LAST CARD INDICATOR
         $B    RE370               YES...GO TELL USER
***********************************************************************
*                                  TERMINATE OPERATION AND EXIT       *
***********************************************************************
RE340    $SRA  16                  CLEAR ROUTINE BUSY INDICATOR
         $STO  RE228
RE348    $B    RE048,,I            RETURN TO INTERRUPT ROUTINE
***********************************************************************
*                                  EXIT TO USERS UNUSUAL END ROUTINE  *
***********************************************************************
RE360    $LD   RE240               GET READ ERROR CODE
         $TSL  *-*                 GO TO ROUTINE
         $SKPN                     TEST RETURN CODE
         $B    RE340               ZERO. TERMINATE OPERATION
RE362    $XIO  RE288-D1            SENSE WITHOUT RESET
         $BOD  RE375               TO ERROR EXIT IF NOT READY
         $LD   RETRY               RESET IOAR
         $STO  RE264               IN CASE 1442 READER
         $XIO  RE264               RE-INITIATE OPERATION
         $B    RE348               EXIT. DON'T CLEAR BUSY
RE370    $SRA  16                  SET LAST CARD INDICATOR (AC=0)
         $TSL  *-*                 GO TO USER ROUTINE
         $B    RE340               TERMINATE
RE375    $LD   RE300               NOT READY INDICATOR
         $TSL  $WAIT               GO TO WAIT
         $B    RE362               TRY AGAIN
         TITLE 'RTPLOAD (UNPACKED CARD CODE TO PACKED EBCDIC ROUTINE)'
***********************************************************************
*              UNPACKED CARD CODE TO PACKED EBCDIC IN INPUT AREA      *
***********************************************************************
CONVRT   DC    AL2(*-*)            ENTRY VIA $TSL CONVRT
         $LD   CONVRT,,I           INPUT DATA AREA ADDRESS
         $STO  WA,,L                TO WA
         $STO  CONVSB+D1             TO PUT
         $LD   CONV40              LOOP CONSTANT
         $STO  CONVCT               TO LOOP COUNTER
         $MDM  CONVRT,1            SET EXIT LINKAGE
CONVLP   $LD   0,WA                GET FIRST WORD OF COUPLE
         $TSL  SXPRESS             GO CONVERT TO EBCDIC
         $SLA  8                   PREPARE FOR
         $STO  CONVTM               BUILDING OUTPUT
         $LD   1,WA                GET SECOND WORD OF COUPLE
         $TSL  SXPRESS             GO CONVERT TO EBCDIC
         $OR   CONVTM              BUILD OUTPUT
CONVSB   $STO  *-*,,L              STORE IN PACKED FORM
         $MDM  CONVSB+D1,1         INCREMENT STORE ADDRESS
         $MDX  2,WA                 AND FETCH ADDRESS
         $MDM  CONVCT,-1           DECREMENT AND TEST COUNT
         $B    CONVLP              BRANCH IF MORE
         $B    CONVRT,,I            OR EXIT IF DONE
CONVCT   DC    AL2(*-*)            LOOP COUNTER
CONV40   DC    AL2(40)             COUNTER VALUE
CONVTM   DC    AL2(*-*)            TEMPORARY STORAGE
         TITLE 'RTPLOAD (/*SIGNON PROCESSOR)'
***********************************************************************
*              TEST FOR /*SIGNON AND PROCESS IF FOUND                 *
***********************************************************************
SIGNOT   $NULL                     WA POINTS TO FIRST WORD OF INPUT
         $STX  SIGDPT,WA           ASSUME CARD IS /*SIGNON
         $TSL  CONVRT              GO CONVERT TO EBCDIC
SIGDPT   DC    AL2(*-*)            INPUT/OUTPUT POINTER
         $LXA  SIGDPT,WA           RESTORE WA
         $LD   0,WA                TEST COLUMNS
         $EOR  SIGT12               1 AND 2
         $BNZ  REPREAD               FOR '/*'
         $LD   1,WA                   TEST COLUMNS
         $EOR  SIGT34                  3 AND 4
         $BNZ  REPREAD                  FOR 'SI'
         $LD   2,WA                      TEST COLUMNS
         $EOR  SIGT56                     5 AND 6
         $BNZ  REPREAD                     FOR 'GN'
         $LD   3,WA                         TEST COLUMNS
         $EOR  SIGT78                        7 AND 8
         $BNZ  REPREAD                        FOR 'ON'
***********************************************************************
*              MOVE SIGNON VARIABLE FIELD OVER ASSEMBLED VALUE        *
***********************************************************************
         $AXT  RTPETSOR+9*D1,WB,L  ADDRESS OF SIGNON VARIABLE FIELD
         $AXT  33,WC               SET UP TO MOVE COLUMNS 16-81
SIGLOOP  $LD   7,WA                GET OFFSET COLUMNS
         $SLA  8                    AND
         $STO  SIGSAV                ADJUST
         $LD   8,WA                   FOR
         $SRA  8                       RTP1130
         $OR   SIGSAV                   INITIALIZATION
         $STO  0,WB                      REQUIREMENTS
         $MDX  1,WB                       INCREMENT
         $MDX  1,WA                        POINTERS
         $MDX  -1,WC               TEST FOR COMPLETION
         $B    SIGLOOP             GET NEXT SET
         $B    REPREAD,,L           OR RETURN TO REP ROUTINE
SIGSAV   DC    AL2(*-*)            TEMPORARY STORAGE
SIGT12   DC    C'/*'               TEST VALUE FOR COLUMNS 1 AND 2
SIGT34   DC    C'SI'               TEST VALUE FOR COLUMNS 3 AND 4
SIGT56   DC    C'GN'               TEST VALUE FOR COLUMNS 5 AND 6
SIGT78   DC    C'ON'               TEST VALUE FOR COLUMNS 7 AND 8
         TITLE 'RTPLOAD (CARD CODE TO EBCDIC CONVERSION SUBROUTINE)'
***********************************************************************
*                                                                     *
* TITLE - $XPRESS (CONVERT 12 BIT CARD CODE TO EBCIDC)                *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
* TO  CONVERT 12 BIT 'IBM' CARD CODE TO EBCDIC 8 BIT CHARACTERS       *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL  $XPRESS  LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                   WHERE--AC CONTAINS CARD CODE IN BITS 0-11 ON      *
*                          ENTRY TO $XPRESS                           *
*                                                                     *
*                        --AC CONTAINS EBCDIC CHARACTER IN BITS 7-15  *
*                          ON RETURN FROM $XPRESS                     *
*                                                                     *
* NOTE---           EXT, WB AND WC ARE DESTROYED BY $XPRESS           *
*                                                                     *
***********************************************************************
SXPRESS  DC    AL2(*-*)            ENTRY VIA $TSL SXPRESS
         $BZ   XPRSBLNK            BRANCH IF CARD CODE BLANK
         $SRA  4                   RIGHT JUSTIFY DATA
         $SRT  2                   COLUMNS 8,9 TO EXT
         $STO  XPRSTEMP            SAVE REST TEMPORARILY
         $SRA  6                   DROP COLUMNS 2-7
         $SLT  2                   RESTORE COLUMNS 8,9
         $STO  WB,,L               TO REGISTER WB
         $LD   XPRSTEMP            GET RESIDUAL COLUMNS
         $AND  XPRSMASK            LEAVES COLUMNS 2-7
         $AXT  16,WC               START COUNTER
         $SLCA 0,WC                SET WC WITH ZONE
         $LD   XPRSZNTB,WB,L       GET ZONE BIT CONBINATION
         $MDX  0,WC                TEST FOR NUMERIC PUNCHES
         $SRA  8                   YES. POSITION ZONE WITH NUMERIC CODE
         $OR   XPRSNUMT,WC,L       ADD NUMERIC, IF ANY
         $MDX  -5,WC               TEST FOR POSSIBLE SPECIAL CASE
         $B    XPRSPECL            BRANCH FOR FURTHER INVESTIGATION
         $AND  XPRSCLHF            CLEAR HIGH ORDER BYTE
         $B    SXPRESS,,I          RETURN TO CALLER
XPRSPECL $EOR  XPRSXV6A            TEST FOR CONVERSION VALUE='6A'
         $SKPN                     SKIP AND RESTORE VALUE IF NOT
         $LD   XPRSCDE0            GET CODED 'E0'
         $EOR  XPRSXV6A            RESTORE OR CONVERT
         $B    SXPRESS,,I          RETURN TO CALLER
XPRSBLNK $LD   XPRSBLKC            GET EBCDIC BLANK
         $B    SXPRESS,,I          RETURN TO CALLER
XPRSCLHF DC    AL2(X'00FF')        CLEAR LEFT HALF
XPRSBLKC DC    AL2(X'0040')        EBCDIC BLANK
XPRSXV6A DC    X'006A'             TEST VALUE FOR POSSIBLE 'E0'
XPRSCDE0 DC    X'008A'             CODED VALUE FOR 'E0'
XPRSTEMP DC    AL2(*-*)            TEMPORARY STORAGE
XPRSMASK DC    X'003F'             MASK WORD
         EJECT
***********************************************************************
*              $XPRESS CONVERSION TABLE                               *
***********************************************************************
XPRSZNTB DC    X'F040'             00= NO PUNCHES
         DC    X'30F9'             01 = 9
         DC    X'78F8'             02 = 8
         DC    X'3838'             03 = 8-9
         DC    X'00F1'             04 = 1
         DC    X'0031'             05 = 1-9
         DC    X'0079'             06 = 1-8
         DC    X'0039'             07 = 1-8-9
         DC    X'E0F0'             08 = 0
         DC    X'20E9'             09 = 0-9
         DC    X'68E8'             0A = 0-8            * 0-8-2 = E0
         DC    X'2828'             0B = 0-8-9
         DC    X'6161'             0C = 0-1
         DC    X'2121'             0D = 0-1-9
         DC    X'6969'             0E = 0-1-8
         DC    X'2929'             0F   0-1-8-9
         DC    X'D060'             10 = 11             *
         DC    X'10D9'             11   11-9
         DC    X'58D8'             12 = 11-8
         DC    X'1818'             13 = 11-8-9
         DC    X'D1D1'             14 = 11-1
         DC    X'0011'             15 = 11-1-9
         DC    X'0059'             16 = 11-1-8
         DC    X'0019'             17 = 11-1-8-9
         DC    X'A0D0'             18 = 11-0           *
         DC    X'60A9'             19 = 11-0-9
         DC    X'A8A8'             1A = 11-0-8
         DC    X'E868'             1B = 11-0-8-9
         DC    X'00A1'             1C = 11-0-1
         DC    X'00E1'             1D = 11-0-1-9       *
         DC    X'00A0'             1E = 11-0-1-8
         DC    X'0020'             1F = 11-0-1-8-9
         DC    X'C050'             20 = 12
         DC    X'00C9'             21 = 12-9           * REAL 00
         DC    X'48C8'             22 = 12-8
         DC    X'0808'             23 = 12-8-9
         DC    X'00C1'             24 = 12-1
         DC    X'0001'             25 = 12-1-9
         DC    X'0049'             26 = 12-1-8
         DC    X'0009'             27 = 12-1-8-9
         DC    X'80C0'             28 = 12-0
         DC    X'4089'             29 = 12-0-9
         DC    X'8888'             2A = 12-0-8
         DC    X'C848'             2B = 12-0-8-9
         DC    X'0081'             2C = 12-0-1
         DC    X'0041'             2D = 12-0-1-9
         DC    X'0080'             2E = 12-0-1-8
         DC    X'0000'             2F = 12-0-1-8-9     * VALID 00
         DC    X'906A'             30 = 12-11
         DC    X'5099'             31 = 12-11-9
         DC    X'9898'             32 = 12-11-8
         DC    X'D858'             33 = 12-11-8-9
         DC    X'0091'             34 = 12-11-1
         DC    X'0051'             35 = 12-11-1-9
         DC    X'0090'             36 = 12-11-1-8
         DC    X'0010'             37 = 12-11-1-8-9
         DC    X'B070'             38 = 12-11-0
         DC    X'70B9'             39 = 12-11-0-9
         DC    X'B8B8'             3A = 12-11-0-8
         DC    X'F878'             3B = 12-11-0-8-9
         DC    X'00B1'             3C = 12-11-0-1
         DC    X'0071'             3D = 12-11-0-1-9
         DC    X'00B0'             3E = 12-11-0-1-8
         DC    X'0030'             3F = 12-11-0-1-8-9
***********************************************************************
*              $XPRESS CONVERSION TABLE                               *
***********************************************************************
XPRSNUMT DC    X'0000'             NO NUMERIC
         DC    X'0007'             7 PUNCH
         DC    X'0006'             6 PUNCH
         DC    X'0005'             5 PUNCH
         DC    X'0004'             4 PUNCH
         DC    X'0003'             3 PUNCH
         DC    X'0002'             2 PUNCH
         TITLE 'RTPLOAD (/*SIGNON CARD STORAGE)'
UPPER    EQU   START+2*(1024-43)
         ORG   UPPER               ORIGIN SIGN-ON IN FAR REACHES
*                                  OF UPPER CORE TO SIDESTEP
*                                  RTP1130 TP BUFFER BUILDING
*                                  PROCESS
RTPETSOR DC    AL1(0),C'0A/*SIGNON',7C' ',C'REMOTE',C'&RMTID',59C' '
         END   RTPLINIT
