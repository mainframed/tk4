               TITLE 'RTP1130 PROLOGUE'
***********************************************************************
*                                                                     *
* MODULE NAME = HRTP1130                                              *
*                                                                     *
* DESCRIPTIVE NAME = RTP1130 (1130 MULTILEAVING RJE PROGRAM)          *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 RELEASE 2, LEVEL 0                                  *
*                                                                     *
* FUNCTION = TO PROVIDE THE 1130 WORK STATION COMPONENT FOR RJE       *
*            IMPLEMENTATION USING THE MULTILEAVING DISCIPLINE OF      *
*            RTAM. THIS PROGRAM EXTENDS TO THE REMOTE LOCATION THE    *
*            FACILITIES OF LOCAL DEVICES SUCH AS OPERATOR CONSOLE     *
*            TYPEWITER, CARD READER(S), CARD PUNCH(ES), HIGH SPEED    *
*            LINE PRINTER(S). THIS MODULE OPERATES IN A STAND-ALONE   *
*            ENVIRONMENT AND REQUIRES NO EXTERNAL SUPPORT PROGRAM.    *
*            THE SOURCE CODE IS ASSEMBLED USING THE OS/VS2 ASSEMBLER  *
*            F PROGRAM IN ORDER TO SHARE THE GENERATION PARAMETERS    *
*            USED TO QUALIFY THE HOST SYSTEM. FOR AN EXPLANATION OF   *
*            THE INTERNAL PROGRAM OPERATION SEE OS/VS2 JES2 LOGIC     *
*            MANUALS.                                                 *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
* DEPENDENCIES = RTAM MULTILEAVING PROTOCOL                           *
*                                                                     *
* RESTRICTIONS = NONE                                                 *
*                                                                     *
* REGISTER CONVENTIONS = SEE SYMBOLIC REGISTERS UNDER EQUATES         *
*                                                                     *
* PATCH LABEL = NONE                                                  *
*                                                                     *
* MODULE TYPE = STAND-ALONE PROGRAM                                   *
*                                                                     *
* PROCESSOR = ASSEMBLER F                                             *
*                                                                     *
* MODULE SIZE = AS SPECIFIED BY RMTGEN PARAMETER &MACHSIZ             *
*                                                                     *
* ATTRIBUTES = STAND-ALONE PROGRAM                                    *
*                                                                     *
* ENTRY POINT = RTPETNI                                               *
*                                                                     *
* PURPOSE = SEE FUNCTION                                              *
*                                                                     *
* LINKAGE = ENTERED FROM LOADER (RTPLOAD) VIA END CARD LABEL          *
*                                                                     *
* INPUT =  (1) OS/VS2 JOBSTREAM VIA 1442 AND/OR 2501 CARD READER      *
*          (2) OPERATOR COMMANDS VIA CONSOLE KEYBOARD OR CARD READER  *
*          (3) MULTILEAVING BLOCKS VIA T/P LINE FROM HOST PROCESSOR   *
*                                                                     *
* OUTPUT = (1) SYSTEM DIRECTED OUTPUT FROM HOST PROCESSOR VIA LINE    *
*              PRINTER(S) (1132 AND/OR 1403), CONSOLE TYPEWRITER,     *
*              AND CARD PUNCH (1442)                                  *
*          (2) RESPONSES TO OPERATOR COMMANDS VIA TYPEWRITER OR       *
*              LINE PRINTER(S)                                        *
*          (3) MULTILEAVING BLOCKS VIA T/P LINE TO HOST PROCESSOR     *
*          (4) LOCALLY GENERATED OPERATOR MESSAGES                    *
*                                                                     *
* EXIT-NORMAL = WAIT AT LOCATION X'10' WITH AC SET TO X'FFFF' WHEN    *
*               A 'DISCONNECT' CONTROL RECORD RECEIVED FROM RTAM      *
*                                                                     *
* EXIT-ERROR  = WAIT AT LOCATION X'10' WITH AC SET TO X'0000' WHEN    *
*               NO CONSOLE BUFFERS AVAILABLE AT INITIALIZATION TIME   *
*                                                                     *
* EXTERNAL REFERNCES = NONE                                           *
*                                                                     *
* TABLES = SEE LISTING                                                *
*                                                                     *
* MACROS = SEE LISTING                                                *
*                                                                     *
* CHANGE ACTIVITY = OZ13222                                           *
*                                                                     *
***********************************************************************
         TITLE '1130 MACRO DEFINITIONS (11/7/70)'
***********************************************************************
*                                                                     *
* TITLE - OS/360 MACRO DEFINTIONS FOR 1130 INSTRUCTIONS               *
*                                                                     *
* GENERAL DESCRIPTION -                                               *
*                                                                     *
*  THE MACROS DEFINED BELOW ATTEMPT TO ALLOW 1130 PROGRAMS TO BE      *
*  ASSEMBLED ON AN IBM 360 USING THE OS/360 ASSEMBLER OR IT'S         *
*  EQUIVALENT UNDER OTHER OPERATING SYSTEMS.                          *
*                                                                     *
*  THE OBJECT DECK PRODUCED BY THE ASSEMBLER IS INCOMPATIBLE WITH     *
*  NORMAL 1130 LOADER AND THEREFORE MUST BE PROCESSED BY A SPECIAL    *
*  1130 LOADER COGNIZANT OF THE 360 FORMAT.                           *
*                                                                     *
* MACRO INSTRUCTION FORMAT                                            *
*                                                                     *
*  THE GENERAL FORMAT OF 1130 INSTRUCTIONS TO BE ASSEMBLED WITH       *
*  THE MACRO SET IS...                                                *
*                                                                     *
*                                                                     *
*                        LABEL $OP ADDR,TAG,FMT,MOD                   *
*                                                                     *
*  WHERE                                                              *
*              LABEL = THE STATEMENT LABEL SUBJECT TO OS/360          *
*                      ASSEMBLER RESTRICTIONS AND RULES               *
*                                                                     *
*              $OP   = MACRO FROM THE SET DEFINED BELOW               *
*                                                                     *
*              ADDR  = THE ADDRESS FIELD OF THE 1130 INSTRUCTION      *
*                                                                     *
*              TAG   = THE INDEX REGISTER (TAG) FIELD OF THE          *
*                      1130 INSTRUCTION                               *
*                                                                     *
*              FMT   = THE FORMAT OF THE 1130 INSTRUCTION.            *
*                    = L FOR LONG FORM                                *
*                                                                     *
*                    = I FOR LONG FORM INDIRECT ADDRESSING            *
*                                                                     *
*                    = X FOR SHORT FORM ABSOLUTE ADDRESS              *
*                                                                     *
*                    = 'BLANK' FOR SHORT FORM RELATIVE ADDRESS        *
*                                                                     *
*              MOD   = MODIFIER BITS REQUIRED FOR SOME 1130           *
*                      INSTRUCTIONS                                   *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*              GENERAL 1130 INSTRUCTION DEFINITION MACRO              *
***********************************************************************
         MACRO
&NAME    $DEF  &OP,&ADD,&TAG,&FMT,&MOD
         LCLA  &I                  DEFINED FOR INDIRECT ADDRESSING BIT
         LCLC  &T,&M               DEFINED FOR INTERNAL MANIPULATION
&T       SETC  '&TAG'              EQUATE TAG AND MOD FIELDS TO
&M       SETC  '&MOD'               INTERNAL PARAMETERS
         AIF   ('&T' NE '').A      TEST FOR NULL TAG FIELD
&T       SETC  '0'                  AVOID ASSEMBLY ERROR IF NULL
.A       AIF   ('&M' NE '').B      TEST FOR NULL MOD FIELD
&M       SETC  '0'                  AVOID ASSEMBLY ERROR IF NULL
.B       AIF   ('&FMT' NE 'L' AND '&FMT' NE 'I').H BRA IF SHORT FORM
         AIF   ('&FMT' EQ 'L').C   DETERMINE IF LONG ONLY OR INDIRECT
&I       SETA  X'80'               TURN ON INDIRECT ADDRESS BIT
.C       AIF   (T'&ADD EQ 'N' OR '&ADD'(1,1) EQ '$').G BR IF $ OR NUMR
         AIF   ('&ADD'(1,1) EQ 'W').E TEST FOR SYMBOL BEGINNING WITH W
         AIF   ('&ADD'(1,1) EQ '*').F TEST FOR RELATIVE EXPRESSION
.D       ANOP
&NAME    DC    AL1(&OP+&T+4,&I+&M),AL2((&ADD-$Z)/2)
         MEXIT
.E       AIF   ('&ADD'(2,1) EQ 'A' OR '&ADD'(2,1) EQ 'B' OR '&ADD'(2,1)C
                EQ 'C').G 
         AGO   .D                   WHICH ARE DEFINED AS ABSOLUTE
.F       AIF   (K'&ADD LT 3).D     ELIMINATE ILLEGAL EXPRESSION
         AIF   ('&ADD'(2,2) NE '-*').D   BRANCH IF NOT *-*
.G       ANOP
&NAME    DC    AL1(&OP+&T+4,&I+&M),AL2(&ADD)
         MEXIT
.H       AIF   ('&FMT' EQ 'X' OR '&ADD'(1,1) EQ '-' OR T'&ADD EQ 'N').I
&NAME    DC 0SL2(*+D-&ADD,&ADD-*+D),AL1(&OP+&T,(&ADD-*-1)/2)
         MEXIT
.I       AIF   ('&ADD'(1,1) EQ '-').J  BRANCH IF MINUS ABSOLUTE
&NAME    DC    0SL2(A-&ADD),AL1(&OP+&T,&ADD+&M)
         MEXIT
.J       ANOP
&NAME    DC    0SL2(B&ADD),AL1(&OP+&T,0&ADD)
         MEND
***********************************************************************
*              GENERAL LONG FORM DEFINITION MACRO                     *
***********************************************************************
         MACRO
&NAME    $DEFL &OP,&ADD,&TAG,&FMT,&MOD
         AIF   ('&FMT' EQ 'I').A
&NAME    $DEF  &OP,&ADD,&TAG,L,&MOD
         MEXIT
.A       ANOP
&NAME    $DEF  &OP,&ADD,&TAG,I,&MOD
         MEND
         EJECT
***********************************************************************
*              1130 INSTRUCTIONS                                      *
***********************************************************************
         SPACE 2
*                                  $LD    LOAD ACC
         MACRO
&NAME    $LD   &ADD,&TAG,&FMT
&NAME    $DEF  192,&ADD,&TAG,&FMT
         MEND
*                                  $LDD   LOAD DOUBLE
         MACRO
&NAME    $LDD  &ADD,&TAG,&FMT
&NAME    $DEF  200,&ADD,&TAG,&FMT
         MEND
*                                  $STO   STORE ACC
         MACRO
&NAME    $STO  &ADD,&TAG,&FMT
&NAME    $DEF  208,&ADD,&TAG,&FMT
         MEND
*                                  $STD   STORE DOUBLE
         MACRO
&NAME    $STD  &ADD,&TAG,&FMT
&NAME    $DEF  216,&ADD,&TAG,&FMT
         MEND
*                                  $LDX   LOAD INDEX
         MACRO
&NAME    $LDX  &ADD,&TAG,&FMT
&NAME    $DEF  96,&ADD,&TAG,&FMT
         MEND
*                                  $LXA   LOAD INDEX FROM ADD (LONG)
         MACRO
&NAME    $LXA  &ADD,&TAG
&NAME    $LDX  &ADD,&TAG,I
         MEND
*                                  $AXT   ADDRESS TO INDEX TRUE
         MACRO
&NAME    $AXT  &ADD,&TAG,&FMT
&NAME    $LDX  &ADD,&TAG,&FMT
         MEND
*                                  $STX   STORE INDEX
         MACRO
&NAME    $STX  &ADD,&TAG,&FMT
&NAME    $DEF  104,&ADD,&TAG,&FMT
         MEND
*                                  $STS   STORE STATUS
         MACRO
&NAME    $STS  &ADD,&TAG,&FMT
&NAME    $DEF  40,&ADD,&TAG,&FMT
         MEND
*                                  $LDS   LOAD STATUS
         MACRO
&NAME    $LDS  &ADD,&TAG
&NAME    $DEF  32,&ADD,&TAG,X
         MEND
*                                  $A     ADD
         MACRO
&NAME    $A    &ADD,&TAG,&FMT
&NAME    $DEF  128,&ADD,&TAG,&FMT
         MEND
*                                  $AD    ADD DOUBLE
         MACRO
&NAME    $AD   &ADD,&TAG,&FMT
&NAME    $DEF  136,&ADD,&TAG,&FMT
         MEND
*                                  $S     SUBTRACT
         MACRO
&NAME    $S    &ADD,&TAG,&FMT
&NAME    $DEF  144,&ADD,&TAG,&FMT
         MEND
*                                  $SD    SUBTRACT DOUBLE
         MACRO
&NAME    $SD   &ADD,&TAG,&FMT
&NAME    $DEF  152,&ADD,&TAG,&FMT
         MEND
*                                  $M     MULTIPLY
         MACRO
&NAME    $M    &ADD,&TAG,&FMT
&NAME    $DEF  160,&ADD,&TAG,&FMT
         MEND
*                                  $D     DIVIDE
         MACRO
&NAME    $D    &ADD,&TAG,&FMT
&NAME    $DEF  168,&ADD,&TAG,&FMT
         MEND
*                                  $AND   LOGICAL AND
         MACRO
&NAME    $AND  &ADD,&TAG,&FMT
&NAME    $DEF  224,&ADD,&TAG,&FMT
         MEND
*                                  $OR    LOGICAL OR
         MACRO
&NAME    $OR   &ADD,&TAG,&FMT
&NAME    $DEF  232,&ADD,&TAG,&FMT
         MEND
*                                  $EOR   LOGICAL EXCLUSIVE OR
         MACRO
&NAME    $EOR  &ADD,&TAG,&FMT
&NAME    $DEF  240,&ADD,&TAG,&FMT
         MEND
*                                  $SLA   SHIFT LEFT ACC
         MACRO
&NAME    $SLA  &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,0
         MEND
*                                  $SLT   SHIFT LEFT ACC AND EXT
         MACRO
&NAME    $SLT  &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,128
         MEND
*                                  $SLCA  SHIFT LEFT AND COUNT ACC
         MACRO
&NAME    $SLCA &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,64
         MEND
*                                  $SLC   SHIFT LEFT AND COUNT ACC+EXT
         MACRO
&NAME    $SLC  &ADD,&TAG
&NAME    $DEF  16,&ADD,&TAG,X,192
         MEND
*                                  $SRA   SHIFT RIGHT ACC
         MACRO
&NAME    $SRA  &ADD,&TAG
&NAME    $DEF  24,&ADD,&TAG,X,0
         MEND
*                                  $SRT   SHIFT RIGHT ACC+EXT
         MACRO
&NAME    $SRT  &ADD,&TAG
&NAME    $DEF  24,&ADD,&TAG,X,128
         MEND
*                                  $RTE   ROTATE RIGHT ACC+EXT
         MACRO
&NAME    $RTE  &ADD,&TAG
&NAME    $DEF  24,&ADD,&TAG,X,192
         MEND
*                                  $BSC   BRANCH/SKIP ON CONDITION
         MACRO
&NAME    $BSC  &ADD,&TAG,&FMT,&MOD
         AIF   ('&FMT' EQ 'L' OR '&FMT' EQ 'I').A
&NAME    DC    AL1(72,&ADD)
         MEXIT
.A       ANOP
&NAME    $DEF  72,&ADD,&TAG,&FMT,&MOD
         MEND
*                                  $BOSC  BRANCH/SKIP RESET INTERRUPT
         MACRO
&NAME    $BOSC &ADD,&TAG,&FMT,&MOD
         LCLC  &M
         AIF   ('&FMT' EQ '' OR '&FMT' EQ 'X').A
&M       SETC  '64'
         AIF   ('&MOD' EQ '').B
&M       SETC  '&M+64'
.B       ANOP
&NAME    $DEF  72,&ADD,&TAG,&FMT,&M
         MEXIT
.A       ANOP
&NAME    DC    AL1(72,&ADD+64)
         MEND
*                                  $BP    BRANCH ACC POSITIVE (LONG)
         MACRO
&NAME    $BP   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,48
         MEND
*                                  $BNP   BRANCH ACC NOT POSITIVE(LONG)
         MACRO
&NAME    $BNP  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,8
         MEND
*                                  $BN    BRANCH ACC NEGATIVE (LONG)
         MACRO
&NAME    $BN   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,40
         MEND
*                                  $BNN   BRANCH ACC NOT NEG. (LONG)
         MACRO
&NAME    $BNN  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,16
         MEND
*                                  $BZ    BRANCH ACC ZERO (LONG)
         MACRO
&NAME    $BZ   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,24
         MEND
*                                  $BNZ   BRANCH ACC NOT ZERO (LONG)
         MACRO
&NAME    $BNZ  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,32
         MEND
*                                  $BC    BRANCH ON CARRY (LONG)
         MACRO
&NAME    $BC   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,2
         MEND
*                                  $BO    BRANCH ON OVERFLOW (LONG)
         MACRO
&NAME    $BO   &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,1
         MEND
*                                  $BOD   BRANCH ACC ODD (LONG)
         MACRO
&NAME    $BOD  &ADD,&TAG,&FMT
&NAME    $DEFL 72,&ADD,&TAG,&FMT,4
         MEND
*                                  $SKPP  SKIP IF ACC POSITIVE (SHORT)
         MACRO
&NAME    $SKPP
&NAME    $DEF  72,0,,X,8
         MEND
*                                  $SKPN  SKIP IF ACC NON-ZERO (SHORT)
         MACRO
&NAME    $SKPN
&NAME    $DEF  72,0,,X,24
         MEND
*                                  $SKPZ  SKIP IF ACC IS ZERO (SHORT)
         MACRO
&NAME    $SKPZ
&NAME    $DEF  72,0,,X,32
         MEND
*                                  $SKPO  SKIP IF OVERFLOW OFF (SHORT)
         MACRO
&NAME    $SKPO
&NAME    $DEF  72,0,,X,1
         MEND
*                                  $SKPC  SKIP IF CARRY IS OFF (SHORT)
         MACRO
&NAME    $SKPC
&NAME    $DEF  72,0,,X,2
         MEND
*                                  $SKPX  SKIP ACC NE 0, CARRY OFF
         MACRO
&NAME    $SKPX
&NAME    $DEF  72,0,,X,26
         MEND
*                                  $B     BRANCH UNCONDITIONALLY
         MACRO
&NAME    $B    &ADD,&TAG,&FMT
         AIF   ('&FMT' EQ 'L' OR '&FMT' EQ 'I').A
&NAME    $MDX  &ADD,&TAG,&FMT
         MEXIT
.A       ANOP
&NAME    $BSC  &ADD,&TAG,&FMT
         MEND
*                                  $BSI   BRANCH AND STORE IAR
         MACRO
&NAME    $BSI  &ADD,&TAG,&FMT,&MOD
&NAME    $DEF  64,&ADD,&TAG,&FMT,&MOD
         MEND
*                                  $TSL   BRANCH AND STORE IAR (LONG)
         MACRO
&NAME    $TSL  &ADD,&TAG,&FMT
&NAME    $DEFL 64,&ADD,&TAG,&FMT,0
         MEND
*                                  $MDX   MODIFY INDEX AND SKIP
         MACRO
&NAME    $MDX  &ADD,&TAG,&FMT
&NAME    $DEF  112,&ADD,&TAG,&FMT
         MEND
*                                  $STL   STORE LOCATION COUNTER
         MACRO
&NAME    $STL  &ADD,&FMT
&NAME    $STX  &ADD,0,&FMT
         MEND
*                                  $MDM   MODIFY MEMORY
         MACRO
&NAME    $MDM  &ADD,&VALUE
         AIF   ('&VALUE'(1,1) EQ '-').B
         AIF   ('&ADD'(1,1) EQ '$').A
&NAME    DC    0SL2(A-&VALUE),AL1(116,&VALUE),AL2((&ADD-$Z)/2)
         MEXIT
.A       ANOP
&NAME    DC    0SL2(A-&VALUE),AL1(116,&VALUE),AL2(&ADD)
         MEXIT
.B       AIF   ('&ADD'(1,1) EQ '$').C
&NAME    DC    0SL2(B&VALUE),AL1(116,0&VALUE),AL2((&ADD-$Z)/2)
         MEXIT
.C       ANOP
&NAME    DC    0SL2(B&VALUE),AL1(116,0&VALUE),AL2(&ADD)
         MEND
*                                  $WAIT  WAIT FOR INTERRUPT
         MACRO
&NAME    $WAIT
&NAME    DC    X'3000'
         MEND
*                                  $XIO   EXECUTE I/O
         MACRO
&NAME    $XIO  &ADD,&TAG,&FMT
&NAME    $DEF  8,&ADD,&TAG,&FMT
         MEND
*                                  $BSS   BLOCK STARTED BY SYMBOL
         MACRO
&NAME    $BSS  &NWRDS,&EVEN
         AIF   ('&EVEN' EQ '').B
         AIF   ('&EVEN' EQ 'E').A
         MNOTE 'ILLEGAL ALIGNMENT PARAMETER. ''E'' ASSUMED.'
.A       ANOP
&NAME    DS    0F,(&NWRDS)H
         MEXIT
.B       ANOP
&NAME    DS    (&NWRDS)H
         MEND
*                                  $BES   BLOCK ENDED BY SYSMBOL
         MACRO
&NAME    $BES  &NWRDS,&EVEN
         AIF   ('&EVEN' EQ '').B
         AIF   ('&EVEN' EQ 'E').A
         MNOTE 'ILLEGAL ALIGNMENT PARAMETER. ''E'' ASSUMED.'
.A       DS    0F,(&NWRDS)H
&NAME    DS    0H
         MEXIT
.B       DS    (&NWRDS)H
&NAME    DS    0H
         MEND
*                                  NULL OPERATION FOR DEFINING S
         MACRO
&NAME    $NULL
&NAME    DS    0H
         MEND
*                                  $ADCON    1130 ADCON EQUIVALENT
         MACRO
&NAME    $ADCON &ADDR
&NAME    DC    AL2((&ADDR-$Z)/2)
         MEND
*                                  $NOP  NO OPERATION
         MACRO
&NAME    $NOP
&NAME    $SLA  0
         MEND
*                                  $ZAC  CLEAR AC
         MACRO
&NAME    $ZAC
&NAME    $SRA  16
         MEND
         SPACE 1
         TITLE 'RTP1130 (SYSTEM MACRO DEFINITIONS)'
***********************************************************************
*                                  TRACE ROUTINE LINKAGE              *
***********************************************************************
         MACRO
         $TRACE
         GBLA  &TRACE              TRACE INDICATOR AND TABLE SIZE
         AIF   (&TRACE EQ 0).NOTRACE
         $TSL  STRACE              $TRACE LINKAGE
         DC    H'0'                ENTRY COUNTER
.NOTRACE MEND
*
***********************************************************************
*                                  $DEQUE - DEQUEUE AN ELEMENT        *
***********************************************************************
*                                                                     *
         MACRO
&NAME    $DEQUE &QP                &QP=QUEUE POINTER
&NAME    $NULL
         AIF   ('&QP' EQ '').A
         $AXT  &QP,WC,L            GET QUEUE POINTER
.A       $TSL  SGETQEL             GO TO DEQUEUE ROUTINE
         MEND
*
***********************************************************************
*                                  $QACTL - QUEUE AN ACTIVE ELEMENT   *
***********************************************************************
*                                                                     *
         MACRO
&NAME    $QACTL &QP,&QE            &QP=QUEUE POINTER, &QE=QUEUE ELEMENT
&NAME    $NULL
         AIF   ('&QE' EQ '').A
         $LD   &QE,,L              GET QUEUE ELEMENT ADDRESS
.A       AIF   ('&QP' EQ '').B
         $AXT  &QP,WC,L            GET QUEUE POINTER ADDRESS
.B       $TSL  SPUTAQL             GO TO ENQUEUE ROUTINE
         MEND
*
***********************************************************************
*                                  $QFREL - QUEUE A FREE ELEMENT      *
***********************************************************************
*                                                                     *
         MACRO
&NAME    $QFREL &QP,&QE            QP=QUEUE POINTER
&NAME    $NULL
         AIF   ('&QE' EQ '').A
         $LD   &QE,,L              GET ELEMENT ADDRESS
.A       AIF   ('&QP' EQ '').B
         $AXT  &QP,WC,L            GET QUEUE POINTER ADDRESS
.B       $TSL  SPUTFQL             GO TO ENQUEUE ROUTINE
         MEND
*
         EJECT
***********************************************************************
*                                  $GENQ - GENERATE CHAINED QUEUE     *
***********************************************************************
*                                                                     *
         MACRO
         $GENQ &ID=,&SIZE=,&NUM=
         LCLA  &CNT
&ID.AQP  DC    AL2(*-*)            ACTIVE ELEMENT QUEUE POINTER
&ID.BGN  $BSS  0,E                 START OF QUEUE
.A       $ADCON (*+4*D1+2*&SIZE)   CHAIN WORD
         DC    AL2(0)              ROOM FOR FIRST  CONTROL WORD
         DC    AL2(0)              ROOM FOR SECOND CONTROL WORD
         DC    AL2(0)              SPARE WORD
         DC    (&SIZE)AL2(0)       DATA AREA
&CNT     SETA  &CNT+1              INCREMENT COUNTER
         AIF   (&CNT LT &NUM-1).A  GENERATE &NUM-1 ENTRIES
         DC    AL2(0)              LAST ENTRY
         DC    AL2(0)              ROOM FOR FIRST  CONTROL WORD
         DC    AL2(0)              ROOM FOR SECOND CONTROL WORD
         DC    AL2(0)              SPARE WORD
         DC    (&SIZE)AL2(0)
         MEND
***********************************************************************
*                                  $WTO - TYPE SPECIFIED MESSAGE      *
***********************************************************************
         MACRO
&NAME    $WTO  &MESS,&NONE
&NAME    $NULL
         $TSL  SWTOPR              LINKAGE TO CONSOLE QUEUEING ROUTINE
         $ADCON (&NONE)            EXIT ADDRESS IF NO BUFFER AVAILABLE
         $ADCON (&MESS)            ADDRESS OF MESSAGE TO BE TYPED
         MEND
         TITLE 'RTP1130 (GLOBAL SET DEFINITIONS)'
         SPACE 3
***********************************************************************
*              GLOBAL DEFINITIONS                                     *
***********************************************************************
         GBLA  &RMTID              REMOTE IDENTIFICATION NUMBER
         GBLA  &MACHSIZ            1130 CORE SIZE IN WORDS
         GBLA  &RTPLORG            RTPLOAD ORIGIN IN 1130
         GBLA  &DEBUG              DEBUG MODE INDICATOR
         GBLA  &REP                PATCH MODE SWITCH
         GBLA  &TRACE              TRACE INDICATOR AND TABLE SIZE
         GBLA  &RD2501             CARD READER (2501-A1,A2)
         GBLB  &RD1442             CARD READER (1442-6,7)
         GBLB  &PN1442             CARD PUNCH (1442-5 OR 6,7)
         GBLB  &RP1442             CARD READER/PUNCH (1442-6,7)
         GBLB  &XX1442             DEFINE EXISTENCE OF 1442
         GBLA  &PR1132             PRINTER (1132)
         GBLA  &PR1403             PRINTER (1403-6,7)
         GBLA  &BSCALO             BSCA (STANDARD)
         GBLA  &BSCAHI             BSCA (SPECIAL)
         GBLA  &CNPSIZE            CONSOLE MESSAGE SIZE IN BYTES
         GBLA  &CONINSZ            CONSOLE INPUT TANK SIZE
         GBLA  &PRFOTLW            1403 PRINTER LINE WIDTH IN BYTES
         GBLA  &TRANPRN            TRANSPARENCY MODE INDICATOR
         GBLA  &TPBFSIZ            DEFAULT HASP TP BUFFER SIZE
         GBLA  &MLBFSIZ            MULTI-LEAVING BUFFER SIZE
         GBLA  &TPBFSZE            RTP1130 TP BUFFER SIZE
         GBLA  &LINESPD            LINE BAUD RATE
         GBLA  &CLOCK              DATA SET OR INTERNAL CLOCKING
         GBLA  &PRTSTRV            PRINT STREAM INITIAL VALUE
         GBLA  &PUNSTRV            PUNCH STREAM INITIAL VALUE
         GBLA  &RDRSTRV            READER STREAM INITIAL VALUE
         GBLA  &CNSKSTR            CONSOLE INPUT STREAM VALUE
         GBLA  &CNSPSTR            CONSOLE PRINT STREAM VALUE
         GBLA  &PRTFCSV            PRINT STREAM INITIAL FCS VALUE
         GBLA  &PUNFCSV            PUNCH STREAM INITIAL FCS VALUE
         GBLA  &RDRFCSV            READER STREAM INITIAL FCS VALUE
         GBLA  &CNSKFCS            CONSOLE INPUT FCS VALUE
         GBLA  &CNSPFCS            CONSOLE PRINT FCS VALUE
         GBLA  &PRFOTKL            NUMBER OF 1403 TANKS
         GBLA  &PRETTKL            NUMBER OF 1132 TANKS
         GBLA  &PUNFTKL            NUMBER OF 1442 (PUNCH) TANKS
         GBLA  &CONSTKL            NUMBER OF CONSOLE TANKS
         GBLA  &PRFOBFL            NUMBER OF 1403 TP BUFFERS
         GBLA  &PRETBFL            NUMBER OF 1132 TP BUFFERS
         GBLA  &PUNFBFL            NUMBER OF 1442 (PUNCH) TP BUFFERS
         GBLA  &CNSPBFL            NUMBER OF CONSOLE (PRINT) TP BUFFERS
         GBLA  &NPTFBFL            NUMBER OF INPUT DEVICE TP BUFFERS
         GBLA  &CMPTYPE            COMPRESSION TECHNIQUE
         GBLB  &DOCUMNT            DETAILED INTERNAL DOCUMENTATION
         GBLA  &FULLIST            FULL LISTING OPTION
         GBLA  &DELAY              DELAY COUNT FOR PROGRAM TIMER
         TITLE 'RTP1130 (HASPGEN VARIABLES)'
         SPACE 3
***********************************************************************
*              REMOTE TERMINAL GENERATION VARIABLES                   *
***********************************************************************
         SPACE 2
&MACHSIZ SETA  8*1024              1130 CORE SIZE IN WORDS
&RTPLORG SETA  2*(&MACHSIZ-1024)   RTPLOAD ORIGIN (-1K)
         SPACE 2
$Z       START 0                   DEFINE RELOCATABLE LOCATION 0
$RTPLORG EQU   &RTPLORG            DEFINE ABSOLUTE VALUE FOR &RTPLORG
$MACHSIZ EQU   &MACHSIZ            DEFINE ABSOLUTE VALUE FOR &MACHSIZ
         ORG   *+80                ORIGIN AT 1130 LOCATION (40)10
START    EQU   *                   DEFINE START SYMBOL
         SPACE 2
&RMTID   SETA  1                   DEFINE REMOTE IDENTIFICATION
&DEBUG   SETA  1                   TURN ON DEBUG
&TRACE   SETA  0                   TRACE INDICATOR AND TABLE SIZE
&REP     SETA  1                   SET TO 1 FOR REP OPTION
&DOCUMNT SETB  0                   SET TO 1 IF DETAILED DOCUMENTATION
&FULLIST SETA  1                   SET TO 0 FOR NO MACRO EXPANSION
         SPACE 2
&RD2501  SETA  0                   SET TO 1 IF 2501 READER
&RD1442  SETB  1                   SET TO 0 IF NO 1442 READER FUNCTION
&PN1442  SETB  1                   SET TO 0 IF NO 1442 PUNCH FUNCTION
&RP1442  SETB  (&RD1442 AND &PN1442)  SET 0 IF NO 1442 READER/PUNCH
&XX1442  SETB  (&RD1442  OR &PN1442)  SET 0 IF NO 1442
&PR1403  SETA  1                   SET TO 0 IF NO 1403 PRINTER
&PR1132  SETA  0                   SET TO 1 IF 1132 PRINTER
&BSCALO  SETA  1                   SET TO 1 IF STANDARD BSCA
&BSCAHI  SETA  0                   SET TO 1 IF SPECIAL BSCA
         SPACE 2
&CNPSIZE SETA  120                 CONSOLE PRINTER SIZE IN BYTES
&CONINSZ SETA  120                 CONSOLE INPUT TANK SIZE
&PRFOTLW SETA  120                 1403 PRINTER LINE WIDTH
         SPACE 1
&TRANPRN SETA  1                   SET TO 0 IF NO TRANSPARENCY
&TPBFSIZ SETA  400                 DEFAULT HASP TP BUFFER SIZE
&MLBFSIZ SETA  400                 MULTI-LEAVING TP BUFFER SIZE
&TPBFSZE SETA  &MLBFSIZ            RTP1130 TP BUFFER SIZE
&LINESPD SETA  2000                LINE BAUD RATE
&CLOCK   SETA  0                   SET TO 1 IF INTERNAL CLOCKING
&DELAY   SETA  3                   DELAY COUNT FOR PROGRAM TIMER
         EJECT
&PRTSTRV SETA  X'94'               PRINT STREAM INITIAL VALUE
&PUNSTRV SETA  X'95'               PUNCH STREAM INITIAL VALUE
&RDRSTRV SETA  X'93'               READER STREAM INITIAL VALUE
&CNSPSTR SETA  X'91'               CONSOLE PRINT STREAM VALUE
&CNSKSTR SETA  X'92'               CONSOLE INPUT STREAM VALUE
&PRTFCSV SETA  X'08'               PRINT STREAM INITIAL FCS VALUE
&PUNFCSV SETA  X'01'               PUNCH STREAM INITIAL FCS VALUE
&RDRFCSV SETA  X'08'               READER STREAM INITIAL FCS VALUE
&CNSPFCS SETA  X'40'               CONSOLE PRINT FCS VALUE
&CNSKFCS SETA  X'40'               CONSOLE INPUT FCS VALUE
&PRFOTKL SETA  2                   NUMBER OF 1403 TANKS
&PRETTKL SETA  2                   NUMBER OF 1132 TANKS
&PUNFTKL SETA  2                   NUMBER OF 1442 TANKS (PUNCH)
&CONSTKL SETA  5                   NUMBER OF CONSOLE PRINT TANKS
&PRFOBFL SETA  2                   NUMBER OF 1403 TP BUFFERS
&PRETBFL SETA  2                   NUMBER OF 1132 TP BUFFERS
&PUNFBFL SETA  2                   NUMBER OF 1442 (PUNCH) TP BUFFERS
&CNSPBFL SETA  255                 NUMBER OF CONSOLE (PRINT) TP BUFFERS
&NPTFBFL SETA  (&RD2501+&RD1442+1) NUMBER OF INPUT DEVICE TP BUFFERS
         SPACE 3
&CMPTYPE SETA  2                   COMPRESSION TECHNIQUE
*
*                                  SET = 0 IF NO COMPRESSION
*
*                                  SET = 1 IF TRAILING BLANK
*                                          ELIMINATION ONLY
*
*                                  SET = 2 IF COMPRESSION OF ALL
*                                          IDENTICAL CHARACTERS
*                                          AND TRAILING BLANK
*                                          ELIMINATION
         TITLE 'RTP1130 (SYSTEM COMMUNICATION LOCATIONS)'
         SPACE 3
***********************************************************************
*              SYMBOLIC DEFINITIONS OF SYSTEM COMMUNICATION LOCATIONS *
***********************************************************************
         SPACE 3
$DUMPPTR EQU   0                   LOCATION OF SHORT FORM BRANCH
*                                  ($B $DUMP) TO SYSTEM DUMP LINKAGE
$WAIT    EQU   14                  LOCATION OF GENERAL 'WAIT' ROUTINE
*                                  ENTERED VIA $TSL $WAIT
*        EQU   15                  LOCATION OF WAIT INSTRUCTION
*        EQU   16                  LOCATION OF $B $WAIT,,I INSTRUCTION
$DUMP    EQU   18                  LOCATION OF $TSL $SDUMP
$LLIMIT  EQU   $DUMP+2             LOWER LIMIT OF TERMINAL DUMP
$ULIMIT  EQU   $LLIMIT+1           UPPER LIMIT OF TERMINAL DUMP
$CORESIZ EQU   $ULIMIT             CELL CONTAINING 1130 CORE SIZE
$ERRLOG  EQU   $CORESIZ+1          START OF LOG AREA
$ERRFFWT EQU   $ERRLOG             1403 WRITE ERROR COUNTER
$ERRETSC EQU   $ERRLOG+1           1132 SCAN CHECK COUNTER
$ERRSCRT EQU   $ERRLOG+2           SCA (LOW) RECEIVE TIMEOUT
$ERRSCWC EQU   $ERRLOG+3           SCA (LOW) TRANSMIT CHECK
$ERRSCTT EQU   $ERRLOG+4           SCA (LOW) TRANSMIT TIMEOUT
$ERRSCXX EQU   $ERRLOG+5           SCA (LOW) UNIDENTIFIED INTERRUPT
$PRTSCAN EQU   32                  1132 PRINTER SCAN AREA
         TITLE 'RTP1130 (UNIQUE KEYWORD DEFINITIONS)'
***********************************************************************
*              DEVICE CODES FOR I/O UNITS ALA IOCC                    *
***********************************************************************
         SPACE 3
$SWITCH  EQU   X'3800'             CONSOLE SWITCHES
$CONSOLE EQU   X'0800'             CONSOLE/KEYBOARD PRINTER
$1442    EQU   X'1000'             1442 CARD READER/PUNCH
$1132    EQU   X'3000'             1132 PRINTER
$ENTRY   EQU   X'3800'             CONSOLE ENTRY SWITCHES
$2501    EQU   X'4800'             2501 READER
$SCALOW  EQU   X'5000'             LOW SPEED BSCA
$1403    EQU   X'A800'             1403 PRINTER
         SPACE 2
***********************************************************************
*              I/O FUNCTIONS ALA IOCC                                 *
***********************************************************************
         SPACE 3
$WRITE   EQU   X'0100'             WRITE
$READ    EQU   X'0200'             READ
$SENSEI  EQU   X'0300'             SENSE INTERRUPT
$CONTROL EQU   X'0400'             CONTROL
$IWRITE  EQU   X'0500'             INITIATE WRITE
$IREAD   EQU   X'0600'             INITIATE READ
$SENSED  EQU   X'0700'             SENSE DEVICE
         SPACE 3
***********************************************************************
*              CONDITION CODE TEST BITS                               *
***********************************************************************
         SPACE 3
O        EQU   1                   OVERFLOW INDICATOR OFF
C        EQU   2                   CARRY INDICATOR OFF
E        EQU   4                   AC CONTENTS EVEN
P        EQU   8                   AC POSITIVE, NOT ZERO
N        EQU   16                  AC NEGATIVE
Z        EQU   32                  AC ZERO
         EJECT
         SPACE 3
***********************************************************************
*              MISCELLANEOUS UNIQUE SYMBOL DEFINITIONS                *
***********************************************************************
         SPACE 2
D1       EQU   2                   DISPLACEMENT OF 1 1130 WORD
A        EQU   127                 DEFINED TO
B        EQU   128                  SHORTEN MACRO
D        EQU   256                   EXPANSION LINE
         SPACE 1
***********************************************************************
*              BINARY SYNCHRONOUS CONTROL CHARACTERS                  *
***********************************************************************
         SPACE 1
$SOH     EQU   X'01'               START OF HEADING
$STX     EQU   X'02'               START OF TEXT
$ETX     EQU   X'03'               END OF TEXT
$DLE     EQU   X'10'               DATA LINK ESCAPE
$ETB     EQU   X'26'               END OF BLOCK
$ENQ     EQU   X'2D'               ENQUIRY
$SYN     EQU   X'32'               SYNCHRONOUS IDLE
$EOT     EQU   X'37'               END OF TRANSMISSION
$NAK     EQU   X'3D'               NEGATIVE ACKNOWLEDGEMENT
$ACK0    EQU   X'70'               POSITIVE ACKNOWLEDGEMENT
$PAD     EQU   X'FF'               PAD CHARACTER
         EJECT
***********************************************************************
*              SCA FUNCTION INDICATORS FOR BSXIOS INTERPRETATION      *
***********************************************************************
         SPACE 2
$BSXRDX  EQU   0                   READ (RECEIVE) FUNCTION
$BSXTMR  EQU   1                   PROGRAM TIMER FUNCTION
$BSXTNT  EQU   2                   TRANSMIT NORMAL TEXT
$BSXTTT  EQU   3                   TRANSMIT TRANSPARENT TEXT
$BSXTAK  EQU   4                   TRANSMIT DLE-ACK0
$BSXTNK  EQU   5                   TRANSMIT NAK
$BSXTSQ  EQU   6                   TRANSMIT SOH-ENQ
         SPACE 3
***********************************************************************
*              CONTROL RECORD TYPE IDENTIFICATION DEFINITIONS         *
***********************************************************************
         SPACE 2
$CRREQT  EQU   X'90'               REQUEST TO START
$CRPERM  EQU   X'A0'               PERMISSION TO START
         SPACE 3
***********************************************************************
*              INPUT (LOCAL DEVICES) CHARACTER CODE DEFINITIONS       *
***********************************************************************
         SPACE 2
$CRDCODE EQU   0                   IBM CARD CODE
$PTTCODE EQU   1                   PAPER TAPE CODE
$EBCCODE EQU   2                   EBCDIC CODE
         SPACE 3
***********************************************************************
*              CONSOLE MESSAGE LIST LEVEL SYMBOLICS                   *
***********************************************************************
         SPACE 2
$LIST15  EQU   15                  HIGHEST LEVEL
         SPACE 3
***********************************************************************
*              CONSOLE RIBBON COLOR AND PRINT CODE SYMBOLICS          *
***********************************************************************
         SPACE 2
$RED     EQU   X'80'               RED RIBBON CODE
$BLACK   EQU   X'00'               BLACK RIBBON CODE
$EBCD    EQU   X'00'               EBCDIC CODE
$TILT    EQU   X'01'               TILT-ROTATE CODE
         TITLE 'RTP1130 (CONSOLE ENTRY KEY DEFINITIONS)'
***********************************************************************
*              CONSOLE ENTRY KEY DEFINITIONS                          *
***********************************************************************
*                                                                     *
*                                  KEY  DESCRIPTION                   *
*                                  ---  -----------                   *
$KEY00   EQU   X'8000'               0  SET ON TO UPDATE $ENTKEYS WITH
*                                       VALUE OF ENTRY KEYS READ EACH
*                                       COMMUTATOR CYCLE
*                                                                     *
$KEY01   EQU   X'4000'               1  SET ON TO INHIBIT SCA TRACE
*
*                                    -  KEYS 2 THRU 7 ARE RESERVED FOR
*                                       SYSTEM PROGRAMMER WHIMS
*                                                                     *
*                                    -  KEYS 8 THRU 15 ARE AVAILABLE
*                                       FOR SENSIBLE OPERATIONAL USE
*                                                                     *
         TITLE 'RTP1130 (INDEX REGISTER DEFINITIONS)'
***********************************************************************
*              ABSOLUTE DEFINITION FOR INDEX REGISTERS                *
***********************************************************************
         SPACE 3
XR1      EQU   1                   INDEX REGISTER 1
XR2      EQU   2                   INDEX REGISTER 2
XR3      EQU   3                   INDEX REGISTER 3
         SPACE 3
***********************************************************************
*              STANDARD SYMBOLICS FOR WORK REGISTERS                  *
***********************************************************************
         SPACE 3
WA       EQU   XR1                 WORK REGISTER 1
WB       EQU   XR2                 WORK REGISTER 2
WC       EQU   XR3                 WORK REGISTER 3
         TITLE 'RTP1130 (UFCB DESCRIPTION)'
***********************************************************************
*              UNIT-FUNCTION CONTROL BLOCK DESCRIPTION                *
***********************************************************************
UFCBCNW  EQU   0                   CHAIN WORD
*
UFCBNFO  EQU   1                   INFORMATION WORD
*                                   BYTE 0 = RESERVED
*                                   BYTE 1 = INPUT CHARACTER CODE
*                                          = 0 FOR IBM CARD CODE
*                                          = 1 FOR PTTC/8 CODE
*                                          = 2 FOR EBCDIC CODE
*
UFCBSAR  EQU   2                   STATUS AND RCB
*                                   BYTE 0 = STATUS OF UNIT-FUNCTION
*                                          = X'90' IF REQUEST TO START
*                                            SENT FROM INPUT UNIT-
*                                            FUNCTION OR IF REQUEST
*                                            TO START RECEIVED FOR
*                                            OUTPUT UNIT-FUNCTION
*                                          = X'A0' IF PERMISSION TO
*                                            START RECEIVED FOR INPUT
*                                            UNIT-FUNCTION OR IF
*                                            PERMISSION TO START SENT
*                                            FOR OUTPUT UNIT-FUNCTION
*                                   BYTE 1 = RCB IDENTIFYING UFCB
*
UFCBFCS  EQU   3                   FCS (FUNCTION IDENTIFIER BIT)
*
UFCBCOM  EQU   4                   COMMUTATOR GATE ADDRESS
*
UFCBFQP  EQU   5                   TANK FREE QUEUE POINTER OR
*                                  ADDRESS OF INPUT ELEMENT
*                                  FOR TPCOMPR
*
UFCBBFP  EQU   6                   QUEUE POINTER FOR ACTIVE BUFFERS
*                                  OR END-OF-FILE FLAG FOR INPUT
*                                  DEVICES
*
UFCBBFC  EQU   7                   COUNT OF ACTIVE BUFFERS
*
UFCBBFL  EQU   8                   LIMIT OF ACTIVE BUFFERS
*
UFCBPBP  EQU   9                   BUFFER ADDRESS OF CURRENT
*                                  BUFFER BEING PROCESSED BY
*                                  TPGET. SET TO ZERO IF NONE
*                                  BEING PROCESSED
*
UFCBPBA  EQU   10                  ADDRESS OF NEXT RCB IN
*                                  PARTIALLY PROCESSED BUFFER
*
UFCBPBS  EQU   11                  LEFT/RIGHT POSITION INDICATOR
*                                  FOR NEXT RCB IN PARTIAL BUFFER
*
UFCBPWD  EQU   12                  OUTPUT DEVICE WIDTH = 2*W/P WHERE
*                                  W IS THE ACTUAL WIDTH IN CHARACTERS
*                                  AND P IS 2 FOR PACKED OUTPUT OR IS
*                                  1 FOR UNPACKED OUTPUT TANKS
*
UFCBPRO  EQU   13                  ENTRY POINT OF DATA ROUTINE
*                                  FOR EACH CHARACTER PROCESSED
*                                  BY $DBLOCK
*
UFCBSTO  EQU   14                  ENTRY POINT OF STORE ROUTINE
*                                  FOR COMPANION DATA PROCESSOR
         SPACE 2
***********************************************************************
*              ALTERNATE UFCB FIELD DEFINITIONS                       *
***********************************************************************
         SPACE 2
$FCBCOM  EQU   UFCBCOM             FACILITATES
$FCBPRO  EQU   UFCBPRO              LONG FORM
$FCBSTO  EQU   UFCBSTO               ABSOLUTE
         TITLE 'RTP1130 (COMMUNICATION LINE BUFFER DESCRIPTION)'
***********************************************************************
*              TPBUF ELEMENT DESCRIPTION                              *
***********************************************************************
TPBUFCW  EQU   0                   BUFFER CHAIN WORD
*
TPBUFST  EQU   1                   BUFFER STATUS WORD
*
TPBUFCB  EQU   2                   BUFFER CONTROL WORD
*                                   BYTE 0=0 (RESERVED)
*                                   TRANSMIT FUNCTION...
*                                   BYTE 1=NUMBER OF BYTES TO BE
*                                   TRANSMITTED (MINUS TWO FOR
*                                   END SEQUENCE WHICH IS INSERTED
*                                   BY BSXIOS)
*                                   RECEIVE FUNCTION...
*                                   BYTE 1=NUMBER OF BYTES RECEIVED
*                                   INCLUDING END SEQUENCE
*                                   TIMER FUNCTION...
*                                   BYTE 1=NUMBER OF PROGRAM TIMER
*                                   INTERRUPTS PROCESSED BEFORE
*                                   ENDING TIMER OPERATION
*
TPBUFDT  EQU   3                   START OF DATA AREA OF LENGTH
*                                  DEFINED BY '&TPBFSZE'
*
TPBUFHD  EQU   3                   BSC HEADER WORD
*                                   SET TO VALUE OF DESIRED SCA
*                                   FUNCTION (READ, WRITE OR TIMER)
*                                   AS DEFINED BY 'SCA FUNCTION
*                                   INDICATORS'
*
TPBUFBF  EQU   4                   CONTROL SEQUENCE
*                                   BYTE 0=BCB
*                                   BYTE 1=FIRST HALF OF FCS
*
TPBUFFR  EQU   5                   CONTROL SEQUENCE
*                                   BYTE 0=SECOND HALF OF FCS
*                                   BYTE 1=RCB
*
TPBUFSR  EQU   6                   CONTROL SEQUENCE
*                                   BYTE 0=SRCB
*                                   BYTE 1=SCB
*
         TITLE 'RTP1130 (QUEUE ELEMENT (TANK ENTRY) DEFINITIONS)'
         SPACE 3
***********************************************************************
*              GENERAL DESCRIPTION OF ALL TANK ELEMENTS               *
***********************************************************************
*                                                                     *
TANKWRDA EQU   0                   ELEMENT CHAIN WORD  (EVEN)
*
TANKWRDB EQU   1                   SPARE WORD          (ODD)
*
TANKWRDC EQU   2                   CONTROL WORD        (EVEN)
*
TANKWRDD EQU   3                   CONTROL WORD        (ODD)
*
TANKWRDE EQU   4                   DATA AREA START     (EVEN)
*                                  LENGTH OF AREA MUST BE EVEN
*                                  IN TERMS OF 1130 WORDS
         EJECT
***********************************************************************
*              1442 PUNCH ACTIVE ELEMENT DEFINITION                   *
***********************************************************************
PN1442CW EQU   TANKWRDA            ELEMENT CHAIN WORD
*
PN1442SP EQU   TANKWRDB            SPARE WORD
*
PN1442CB EQU   TANKWRDC            CONTROL WORD
*                                   BYTE 0 = RESERVED
*                                   BYTE 1 = SRCB
*
PN1442DL EQU   TANKWRDD            CONTROL WORD
*                                   BYTE 0 = RESERVED
*                                   BYTE 1 = ACTUAL DATA COUNT
*
PN1442DT EQU   TANKWRDE            START OF 80 WORD DATA AREA
*                                  IN UNCOMPRESSED CARD CODE
*                                  FORMAT. THE LAST COLUMN TO
*                                  BE PUNCHED CONTAINS A 12 BIT.
*
         EJECT
***********************************************************************
*              1403 PRINTER ACTIVE ELEMENT DEFINITION                 *
***********************************************************************
*                                                                     *
PR1403CW EQU   TANKWRDA            ELEMENT CHAIN WORD
*
PR1403SP EQU   TANKWRDB            SPARE WORD
*
PR1403CB EQU   TANKWRDC            CONTROL WORD
*                                   BYTE 0 = RESERVED
*                                   BYTE 1 = SRCB
*
PR1403DL EQU   TANKWRDD            CONTROL WORD
*                                   BYTE 0 = RESERVED
*                                   BYTE 1 = ACTUAL DATA COUNT
*
PR1403DT EQU   TANKWRDE            START OF '&PRFOTLW/2' WORD
*                                  DATA FIELD CONTAINING 6 BIT
*                                  PRINTER CODE (2 PER WORD) OF
*                                  DATA TO BE PRINTED.
*
PRTFOTLW EQU   &PRFOTLW/2          NUMBER OF WORDS PER 1403 PRINT LINE
         EJECT
***********************************************************************
*              1132 PRINTER ACTIVE ELEMENT DEFINITION                 *
***********************************************************************
PR1132CW EQU   TANKWRDA            ELEMENT CHAIN WORD
*
PR1132SP EQU   TANKWRDB            SPARE WORD
*
PR1132CB EQU   TANKWRDC            CONTROL WORD
*                                   BYTE 0 = RESERVED
*                                   BYTE 1 = SRCB
*
PR1132LC EQU   TANKWRDD            LINE CONTROL WORD
*                                  BYTE 0 = 0 FOR ALPHANUMERIC
*                                       0 = 1 FOR NUMERIC ONLY
*                                  BYTE 1 = NUMBER OF BYTES TO
*                                  TO BE PRINTED. MUST BE EVEN.
*
PR1132DT EQU   TANKWRDE            START OF DATA IN PACKED
*                                  EBCDIC FORM
*
         EJECT
***********************************************************************
*              CONSOLE MESSAGE GENERAL ACTIVE ELEMENT DEFINITION      *
***********************************************************************
CONMSGCW EQU   TANKWRDA            ELEMENT CHAIN WORD
*
CONMSGSP EQU   TANKWRDB            SPARE WORD
*
CONMSGCB EQU   TANKWRDC            CONTROL WORD
*                                   BYTE 0 = X'00' FOR BLACK EBCDIC
*                                          = X'01' FOR BLACK PRINT CODE
*                                          = X'80' FOR RED EBCDIC
*                                          = X'81' FOR RED PRINT CODE
*                                   BYTE 1 = SRCB
*
CONMSGDL EQU   TANKWRDD            CONTROL WORD
*                                   BYTE 0 = RESERVED
*                                   BYTE 1 = NUMBER OF BYTES
*                                   IN DATA FIELD DEFINED BY
*                                   CONMSGDT
*
*
CONMSGDT EQU   TANKWRDE            START OF DATA IN PACKED
*                                  EBCDIC OR CONSOLE PRINTER FORMAT
*
*                                  CONSOLE MESSAGE QUEUE SIZE IN WORDS
CONQSIZE EQU   &CNPSIZE/2
*
         AIF   (&FULLIST EQ 1).XPANDOK
         PRINT NOGEN               DELETE MACRO EXPANSIONS
.XPANDOK ANOP
         TITLE 'RTP1130 (DEFINE UFCB''S FOR SPECIFIED CONFIGURATION)'
SUFCBLKS $NULL                     START OF UFCB'S
         AIF   (&RD2501 EQ 0).NO25010
***********************************************************************
*              UFCB FOR 2501 CARD READER                              *
***********************************************************************
RDTFEQUA EQU   &RDRSTRV
RDTFEQUB EQU   &RDRFCSV
RDTFUFCB $ADCON (RDTFUFCX)         POINTER TO NEXT UFCB
         DC    AL1(0,$CRDCODE)     INFORMATION WORD (CARD CODE INPUT)
         DC    AL1(0,RDTFEQUA)     STATUS BYTE AND ASSOCIATED RCB
         DC    AL1(RDTFEQUB,0)     FCS (FUNCTION IDENTIFICATION BIT)
         $ADCON (RDTFOGT)          COMMUTATOR GATE ADDRESS
SRDTTANK DC    AL2(*-*)            ADDRESS OF 2501 INPUT TANK
RDTFUFLG DC    AL2(*-*)            END-OF-FILE FLAG
RDTFUFCX $NULL                     ADDRESS OF NEXT UFCB
&RDRSTRV SETA  &RDRSTRV+X'10'      INCREMENT INPUT STREAM VALUE
&RDRFCSV SETA  &RDRFCSV/2          CALCULATE FCS FOR NEXT STREAM
         SPACE 2
.NO25010 ANOP
         AIF   (NOT &RD1442).NO14420
         EJECT
***********************************************************************
*              UFCB FOR 1442 READER                                   *
***********************************************************************
RDFFEQUA EQU   &RDRSTRV
RDFFEQUB EQU   &RDRFCSV
RDFFUFCB $ADCON (RDFFUFCX)         POINTER TO NEXT UFCB
         DC    AL1(0,$CRDCODE)     INFORMATION WORD (CARD CODE INPUT)
RDFFUSTR DC    AL1(*-*,RDFFEQUA)   STATUS BYTE & ASSOCIATED RCB
         DC    AL1(RDFFEQUB,0)     FCS (FUNCTION IDENTIFICATION BIT)
         $ADCON (RPFFTGT)          COMMUTATOR GATE ADDRESS
SRPFTANK DC    AL2(*-*)            ADDRESS OF 1442 INPUT TANK
RDFFUFLG DC    AL2(*-*)            END-OF-FILE FLAG
RDFFUFCX $NULL                     ADDRESS OF NEXT UFCB
&RDRSTRV SETA  &RDRSTRV+X'10'      INCREMENT INPUT STREAM VALUE
&RDRFCSV SETA  &RDRFCSV/2          CALCULATE FCS FOR NEXT STREAM
         SPACE 2
.NO14420 ANOP
         EJECT
***********************************************************************
*              UFCB FOR CONSOLE INPUT (KEYBOARD)                      *
***********************************************************************
CNSKEQUA EQU   &CNSKSTR
CNSKEQUB EQU   &CNSKFCS
CNSKUFCB $ADCON (CNSKUFCX)         POINTER TO NEXT UFCB
         DC    AL1(0,$CRDCODE)     INFORMATION WORD (CARD CODE INPUT)
         DC    AL1(0,CNSKEQUA)     STATUS BYTE AND ASSOCIATED RCB
         DC    AL1(0,CNSKEQUB)     FCS (FUNCTION IDENTIFIER BIT)
         $ADCON (CONSLGT)          COMMUTATOR GATE ADDRESS
SCONTANK DC    AL2(*-*)            ADDRESS OF CONSOLE INPUT TANK
CNSKUFLG DC    AL2(*-*)            END-OF-FILE FLAG
CNSKUFCX $NULL                     ADDRESS OF NEXT UFCB
         SPACE 3
         AIF   (NOT &PN1442).NO14421
         EJECT
***********************************************************************
*              UFCB FOR 1442 PUNCH                                    *
***********************************************************************
PNFFEQUA EQU   &PUNSTRV
PNFFEQUB EQU   &PUNFCSV
PNFFEQUC EQU   &PUNFBFL
PNFFUFCB $ADCON (PNFFUFCX)         POINTER TO NEXT UFCB
         DC    AL2(*-*)            INFORMATION WORD
         DC    AL1(0,PNFFEQUA)     STATUS BYTE AND ASSOCIATED RCB
         DC    AL1(0,PNFFEQUB)     FCS (FUNCTION IDENTIFIER BIT)
         AIF   (NOT &RP1442).NO14428
         $ADCON (RPCNTGT)          COMMUTATOR ROUTINE GATE ADDRESS
         AGO   .NO14429
.NO14428 ANOP
         $ADCON (RPFFTGT)          COMMUTATOR ROUTINE GATE ADDRESS
.NO14429 ANOP
PNFF2FQP $ADCON (PNFF2BGN)         TANK FREE QUEUE POINTER
PNFFUBFP DC    AL2(*-*)            QUEUE POINTER FOR ACTIVE BUFFERS
         DC    AL2(*-*)            ACTIVE BUFFER COUNT
         DC    AL2(PNFFEQUC)       ACTIVE BUFFER LIMIT
         DC    AL2(*-*)            ADDRESS OF BUFFER BEING PROCESSED
         DC    AL2(*-*)            RCB ADDRESS IN BUFFER
         DC    AL2(*-*)            RCB POSITION INDICATOR
         DC    AL2(2*80)           WIDTH OF PUNCH
         $ADCON (SXCPNCH)          ADDRESS OF EBCDIC TO CARD CODE PGM
         $ADCON (DBLKSTF)          COMPANION ROUTINE TO FILL TANK
PNFFUFCX $NULL                     ADDRESS OF NEXT UFCB
&PUNSTRV SETA  &PUNSTRV+X'10'      INCREMENT PUNCH STREAM VALUE
&PUNFCSV SETA  &PUNFCSV*2          CALCULATE FCS FOR NEXT STREAM
         SPACE 2
.NO14421 ANOP
         AIF   (&PR1403 EQ 0).NO14030
         EJECT
***********************************************************************
*              UFCB FOR 1403 PRINTER                                  *
***********************************************************************
PRFOEQUA EQU   &PRTSTRV
PRFOEQUB EQU   &PRTFCSV
PRFOEQUC EQU   &PRFOBFL
PRFOEQUD EQU   &PRFOTLW
PRFOUFCB $ADCON (PRFOUFCX)         POINTER TO NEXT UFCB
         DC    AL2(*-*)            INFORMATION WORD
         DC    AL1(0,PRFOEQUA)     STATUS BYTE AND ASSOCIATED RCB
         DC    AL1(PRFOEQUB,0)     FCS (FUNCTION IDENTIFICATION BIT)
         $ADCON (PRFOTGT)          COMMUTATOR GATE ADDRESS
PRFO3FQP $ADCON (PRFO3BGN)         TANK FREE QUEUE POINTER
PRFOUBFP DC    AL2(*-*)            QUEUE POINTER FOR ACTIVE BUFFERS
         DC    AL2(*-*)            ACTIVE BUFFER COUNT
         DC    AL2(PRFOEQUC)       ACTIVE BUFFER LIMIT
         DC    AL2(*-*)            ADDRESS OF BUFFER BEING PROCESSED
         DC    AL2(*-*)            RCB ADDRESS IN BUFFER
         DC    AL2(*-*)            RCB POSITION INDICATOR
         DC    AL2(PRFOEQUD)       WIDTH OF PRINTER
         $ADCON (SXPPRNT)          ADDRESS OF 1403 CODE CONVERSION PGM
         $ADCON (DBLKPUT)          COMPANION ROUTINE TO FILL TANK
PRFOUFCX $NULL                     ADDRESS OF NEXT UFCB
&PRTSTRV SETA  &PRTSTRV+X'10'      INCREMENT PRINT STREAM VALUE
&PRTFCSV SETA  &PRTFCSV/2          CALCULATE FCS FOR NEXT STREAM
         SPACE 2
.NO14030 ANOP
         AIF   (&PR1132 EQ 0).NO11320
         EJECT
***********************************************************************
*              UFCB FOR 1132 PRINTER                                  *
***********************************************************************
PRETEQUA EQU   &PRTSTRV
PRETEQUB EQU   &PRTFCSV
PRETEQUC EQU   &PRETBFL
PRETUFCB $ADCON (PRETUFCX)         POINTER TO NEXT UFCB
         DC    AL2(*-*)            INFORMATION WORD
         DC    AL1(0,PRETEQUA)     STATUS BYTE AND ASSOCIATED RCB
         DC    AL1(PRETEQUB,0)     FCS (FUNCTION IDENTIFICATION BIT)
         $ADCON (PRETTGT)          COMMUTATOR GATE ADDRESS
PRET2FQP $ADCON (PRET2BGN)         TANK FREE QUEUE POINTER
PRETUBFP DC    AL2(*-*)            QUEUE POINTER FOR ACTIVE BUFFERS
         DC    AL2(*-*)            ACTIVE BUFFER COUNT
         DC    AL2(PRETEQUC)       ACTIVE BUFFER LIMIT
         DC    AL2(*-*)            ADDRESS OF BUFFER BEING PROCESSED
         DC    AL2(*-*)            RCB ADDRESS IN BUFFER
         DC    AL2(*-*)            RCB POSITION INDICATOR
PRETULWD DC    AL2(120)            LINE WIDTH OF 1132
PRETUPRO $ADCON (DBLKNCK)          ADDRESS OF NUMERIC DATA CHECKER
         $ADCON (DBLKPUT)          COMPANION ROUTINE TO FILL TANK
PRETUFCX $NULL                     ADDRESS OF NEXT UFCB
&PRTSTRV SETA  &PRTSTRV+X'10'      INCREMENT PRINT STREAM VALUE
&PRTFCSV SETA  &PRTFCSV/2          CALCULATE FCS FOR NEXT STREAM
         SPACE 2
.NO11320 ANOP
         EJECT
***********************************************************************
*              UFCB FOR CONSOLE OUTPUT (PRINT)                        *
***********************************************************************
CNSPEQUA EQU   &CNSPSTR
CNSPEQUB EQU   &CNSPFCS
CNSPEQUC EQU   &CNSPBFL
CNSPEQUD EQU   &CNPSIZE
CNSPUFCB $ADCON (CNSPUFCX)         POINTER OF NEXT UFCB
         DC    AL2(*-*)            INFORMATION WORD
         DC    AL1(0,CNSPEQUA)     STATUS BYTE AND ASSOCIATED RCB
         DC    AL1(0,CNSPEQUB)     FCS (FUNCTION IDENTIFIER BIT)
         $ADCON (CONSLGT)          COMMUTATOR GATE ADDRESS
CONSLFQP $ADCON (CONSLBGN)         TANK FREE QUEUE POINTER
CNSPUBFP DC    AL2(*-*)            QUEUE POINTER FOR ACTIVE BUFFERS
         DC    AL2(*-*)            ACTIVE BUFFER COUNT
         DC    AL2(CNSPEQUC)       ACTIVE BUFFER LIMIT
         DC    AL2(*-*)            ADDRESS OF BUFFER BEING PROCESSED
         DC    AL2(*-*)            RCB ADDRESS IN BUFFER
         DC    AL2(*-*)            RCB POSITION INDICATOR
         DC    AL2(CNSPEQUD)       CONSOLE PRINTER WIDTH
         $ADCON (SXCPRNT)          ADDRESS OF PRINT CONVERSION PGM
         $ADCON (DBLKPUT)          COMPANION ROUTINE TO FILL TANK
CNSPUFCX $NULL                     ADDRESS OF NEXT UFCB
         SPACE 3
SUFCBEND DC    AL2(0)              ZERO CHAIN WORD FOR END OF UFCB'S
         TITLE 'RTP1130 (SYSTEM SUBROUTINES)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - $GETQEL (DEQUEUE AN ELEMENT FROM A CHAINED LIST)            *
*                                                                     *
* FUNCTION/DESCRIPTION                                                *
*                                                                     *
*  TO RETURN THE ADDRESS OF THE FIRST ELEMENT AVAILABLE ON A LIST OF  *
*  CHAINED ELEMENTS.                                                  *
*                                                                     *
* CALLING SEQUENCE                                                    *
*                                                                     *
*                             $TSL   $GETQEL                          *
*                                                                     *
*              WHERE-- WC CONTAINS THE ADDRESS OF THE QUEUE ELEMENT   *
*                      POINTER ON ENTRY.                              *
*                                                                     *
*                      AC CONTAINS THE ADDRESS OF THE DEQUEUED        *
*                      ELEMENT ON EXIT. IF THE QUEUE IS NULL,         *
*                      THE AC IS SET TO ZERO ON EXIT                  *
*                                                                     *
*                      THE CHAIN FIELD OF THE DEQUEUED ELEMENT        *
*                      IS SET TO ZERO BEFORE RETURNING                *
*                                                                     *
***********************************************************************
         SPACE 3
SGETQEL  DC    H'0'                ENTRY VIA $TSL $GETQEL
         $LD   0,WC                GET THE QUEUE ELEMENT POINTER
         $BZ   SGETQEL,,I          RETURN IF NO ELEMENTS AVAILABLE
         $STO  GETQTEMP            SAVE ELEMENT ADDRESS FOR EXIT
         $LD   GETQTEMP,,I         GET ADDRESS OF NEXT ELEMENT
         $STO  0,WC                STORE IN QUEUE ELEMENT POINTER
         $ZAC                      CLEAR AC AND SET CHAIN
         $STO  GETQTEMP,,I         FIELD ZERO IN ELEMENT DEQUEUED
         $LD   GETQTEMP            ELEMENT ADDRESS TO AC
         $B    SGETQEL,,I          EXIT
GETQTEMP DC    H'0'                STORAGE FOR ELEMENT ADDRESS
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $PUTFQL (ENQUEUE AN ELEMENT IN A FREE ELEMENT CHAIN)        *
*                                                                     *
* FUNCTION PURPOSE                                                    *
*                                                                     *
*  TO ENQUEUE AN ELEMENT IN A FREE ELEMENT CHAIN.                     *
*                                                                     *
* CALLING SEQUENCE                                                    *
*                                                                     *
*                             $TSL  $PUTFQL                           *
*                                                                     *
*              WHERE-- WC CONTAINS THE ADDRESS OF THE FREE ELEMENT    *
*                      QUEUE POINTER ON ENTRY.                        *
*                                                                     *
*                      AC CONTAINS THE ADDRESS OF THE ELEMENT TO      *
*                      BE CHAINED (ENQUEUED).                         *
*                                                                     *
***********************************************************************
         SPACE 3
SPUTFQL  DC    H'0'                ENTRY VIA $TSL $PUTFQL
         $STO  PUTFTEMP            SAVE RETURNING ELEMENT ADDRESS
         $LD   0,WC                GET FREE ELEMENT QUEUE POINTER
         $STO  PUTFTEMP,,I         CHAIN CURRENT ELEMENT TO NEW
         $LD   PUTFTEMP            PUT NEW ELEMENT
         $STO  0,WC                IN QUEUE POINTER
         $B    SPUTFQL,,I          EXIT
PUTFTEMP DC    H'0'                NEW ELEMENT ADDRESS
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $PUTAQL (ENQUEUE AN ELEMENT IN AN ACTIVE ELEMENT CHAIN)     *
*                                                                     *
* FUNCTION/PURPOSE                                                    *
*                                                                     *
*  TO ENQUEUE AN ELEMENT IN AN ACTIVE (FIFO) CHAIN.                   *
*                                                                     *
* CALLING SEQUENCE                                                    *
*                                                                     *
*                             $TSL  $PUTAQL                           *
*                                                                     *
*              WHERE-- WC CONTAINS THE ADDRESS OF THE QUEUE ELEMENT   *
*                      POINTER ON ENTRY.                              *
*                                                                     *
*                      AC CONTAINS THE ADDRESS OF THE ELEMENT TO BE   *
*                      ENQUEUED (CHAINED) AT THE END OF A FIFO        *
*                      QUEUE.                                         *
*                                                                     *
***********************************************************************
         SPACE 3
SPUTAQL  DC    H'0'                ENTRY VIA $TSL $PUTAQL
         $STX  PUTAQSVC+D1,WC      SAVE WC
         $STO  PUTATEMP            SAVE ELEMENT ADDRESS
         $LD   0,WC                GET ACTIVE ELEMENT POINTER
         $BNZ  PUTAQADD            BRANCH IF CHAIN EXISTS
         $LD   PUTATEMP            START A NEW CHAIN
         $STO  0,WC                STORE NEW ADDRESS IN QUEUE POINTER
         $B    PUTAQSVC            GO TO EXIT
PUTAQADD $STO  WC,,L               CHAIN POINTER TO WC
         $LD   0,WC                GET NEXT ELEMENT
         $BNZ  PUTAQADD            SEARCH FOR LAST
         $LD   PUTATEMP            GET NEW ENTRY
         $STO  0,WC                ADD TO LIST
PUTAQSVC $AXT  *-*,WC,L            RESTORE WC
         $B    SPUTAQL,,I          EXIT
PUTATEMP DC    H'0'                NEW ELEMENT ADDRESS
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $TPOPEN (INITIATE CONTROL RECORD TRANSMISSION TO HASP)      *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  TO INITIATE CONTROL RECORD TRANSMISSION TO HASP FOR DEFINED        *
*  CONTROL RECORD TYPES (REQUEST TO START, PERMISSION TO SEND...,     *
*  ETC.) THE PROCESSING OF THE CONTROL RECORDS IS BY THE TPPUT        *
*  COMMUTATOR ROUTINE FOR BUILDING OUTPUT BUFFERS.                    *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL  $TPOPEN  LINKAGE                  *
*                             ....           EXIT POINT               *
*                                                                     *
*                             (ENTRY) WC CONTAINS ADDRESS OF          *
*                             UFCB FOR FUNCTION ASSOCIATED            *
*                             WITH CONTROL RECORD PROCESS             *
*                                                                     *
*                             (ENTRY) AC CONTAINS CONTROL             *
*                             TYPE LEFT JUSTIFIED WITH LOW            *
*                             ORDER BYTE ZERO. THIS VALUE             *
*                             IS STORED IN THE STATUS FIELD           *
*                             OF THE UFCB SUPPLIED                    *
*                                                                     *
*                             (EXIT) AC SET TO NON-ZERO IF REQUEST    *
*                             CANNOT BE PROCESSED IMMEDIATELY         *
*                                                                     *
*                             AC SET TO ZERO IF REQUEST PROCESSED     *
*                                                                     *
***********************************************************************
         SPACE 3
STPOPEN  DC    AL2(*-*)            ENTRY VIA $TSL $TPOPEN
         $STO  TPOPSVT             STORE CONTROL TYPE
         $LD   SCRQUEUE            GET CONTROL RECORD QUEUE
         $BNZ  STPOPEN,,I          EXIT IF PREVIOUS REQUEST
         $STX  SCRQUEUE,WC         SET UFCB ADDRESS FOR REQUEST
         $LD   UFCBSAR,WC,X        GET STATUS AND RCB WORD
         $AND  TPOPLHM             CLEAR STATUS BYTE
         $OR   TPOPSVT              SET TO TYPE
         $STO  UFCBSAR,WC,X          SUPPLIED BY CALLER
         $ZAC                      SUCCESS FLAG
         $B    STPOPEN,,I          RETURN TO CALLER
TPOPSVT  DC    AL2(*-*)            CONTROL TYPE STORAGE
TPOPLHM  DC    AL2(X'00FF')        STATUS BYTE MASK
SCRQUEUE DC    AL2(*-*)            SET TO ADDRESS OF UFCB
*                                  BY $TPOPEN
*                                  SET TO ZERO BY TPPUT WHEN
*                                  CONTROL RECORD PROCESSED
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $SRCHB (SEARCH UFCB'S FOR MATCHING RCB CODE)                *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  SEARCHES UFCB CHAIN FOR MATCHING RCB AS SUPPLIED BY USER.          *
*  ADDRESS OF MATCHING UFCB IS RETURNED IF SUCCESSFUL SEARCH.         *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL $SRCHCB   LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                             ENTRY...AC CONTAINS RCB CODE            *
*                             IN LOW ORDER BYTE (HIGH IGNORED)        *
*                             TO BE COMPARED WITH RCB FIELD           *
*                             (UFCBSAR) OF UFCB'S                     *
*                                                                     *
*                             (EXIT)....AC ZERO FOR SUCCESSFUL        *
*                             SEARCH. WC CONTAINS ADDRESS OF          *
*                             MATCHING UFCB CHAIN WORD                *
*                                                                     *
*                             AC SET TO SEARCH RCB IF NO MATCH        *
*                             WC CONTAINS ZERO                        *
*                                                                     *
***********************************************************************
         SPACE 3
SSRCHCB  DC    AL2(*-*)            ENTRY VIA $TSL $SRCHCB
         $AND  SRCHMSK             CLEAR HIGH ORDER BYTE
         $STO  SRCHRCB             SAVE RCB CODE FOR COMPARE
         $AXT  SUFCBLKS,WC,L       START OF UFCB CHAIN TO WC
SRCHALL  $LD   UFCBSAR,WC,X        GET STATUS/RCB ENTRY
         $AND  SRCHMSK             MASK STATUS BYTE
         $EOR  SRCHRCB             TEST FOR RCB MATCH
         $BZ   SSRCHCB,,I          RETURN IF MATCH
         $LD   UFCBCNW,WC,X        GET NEXT UFCB CHAIN WORD
         $STO  WC,,L               SET WC FOR SEARCH
         $BNZ  SRCHALL             RUN THE CHAIN
         $LD   SRCHRCB             END OF CHAIN AND
         $B    SSRCHCB,,I           NO RCB MATCH
SRCHRCB  DC    AL2(*-*)            INPUT RCB
SRCHMSK  DC    AL2(X'00FF')        STATUS MASK
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $WTOPR (TYPE SPECIFIED MESSAGE ON CONSOLE TYPEWRITER)       *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  TO QUEUE SPECIFIED MESSAGE FOR PRINTING ON THE CONSOLE             *
*  TYPEWRITER BY THE CONSOLE PRINTER COMMUTATOR ROUTINE               *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                        $TSL   $WTOPR       LINKAGE                  *
*                        $ADCON (NONE)       NO ELEMENT EXIT ADDRESS  *
*                        $ADCON (MESS)       ADDRESS OF MESSAGE       *
*                        ...                 NORMAL EXIT              *
*                                                                     *
*                WHERE.. 'NONE' IS THE EXIT ADDRESS USED IF           *
*                        NO ELEMENT IS AVAILABLE FOR THE              *
*                        MESSAGE.                                     *
*                                                                     *
*                        'MESS' IS THE ADDRESS OF THE MESSAGE TO      *
*                        BE PRINTED AND IS OF THE FORM...             *
*                                                                     *
*                        WORD 1 = CONTROL WORD INDICATING PRINT       *
*                        COLOR AND LIST LEVEL                         *
*                                                                     *
*                        WORD 2 = NUMBER (N) OF EBCDIC BYTES          *
*                        FOLLOWING (MUST BE EVEN)                     *
*                                                                     *
*                        WORD 3 = FIRST 2 BYTES                       *
*                                                                     *
*                                                                     *
*                        WORD (N/2)-1 = LAST 2 BYTES                  *
*                                                                     *
***********************************************************************
         SPACE 3
SWTOPR   DC    AL2(*-*)            ENTRY VIA $TSL $WTOPR
         $LXA  SWTOPR,WC           ADDRESS OF ADDRESS OF 'NONE' EXIT
         $LD   0,WC                ADDRESS OF 'NONE' EXIT
         $STO  WTOPRNO+D1          SET NO ELEMENT EXIT
         $LD   1,WC                ADDRESS OF MESSAGE
         $STO  WTOPRTM             SAVE IT
         $MDX  2,WC                SETUP
         $STX  WTOPRXT+D1,WC        EXIT
         $DEQUE CONSLFQP           GET A FREE QUEUE ELEMENT
WTOPRNO  $BZ   *-*                 EXIT IF NONE AVAILABLE
         $STO  WTOPREL             SAVE ADDRESS OF ELEMENT
         $STX  WTOPRSA+D1,WA       SAVE WA
         $STX  WTOPRSB+D1,WB       SAVE WB
         $LXA  WTOPRTM,WB          MESSAGE ADDRESS
         $LXA  WTOPREL,WA          ELEMENT ADDRESS
         $MDX  CONMSGCB,WA,X       POINT TO FIRST CONTROL WORD
         $LD   1,WB                GET LENGTH OF MESSAGE
         $SRA  1                   MAKE IT NUMBER OF WORDS
         $A    WTOPRCX             INCLUDE CONTROL WORDS
         $TSL  SMOVE               MOVE MESSAGE TO ELEMENT
         $LD   WTOPREL             ELEMENT ADDRESS
         $QACTL CONSLAQP           QUEUE IT FOR TYPING
         $LD   UNLATCH,,L          OPEN CONSOLE
         $STO  CONSLGT,,L           GATE
WTOPRSA  $AXT  *-*,WA,L            RESTORE WA
WTOPRSB  $AXT  *-*,WB,L            RESTORE WB
WTOPRXT  $B    *-*,,L              NORMAL EXIT
WTOPRTM  DC    AL2(*-*)            MESSAGE ADDRESS
WTOPREL  DC    AL2(*-*)            ELEMENT ADDRESS
WTOPRCX  DC    AL2(2)              CONTROL WORD COUNT
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $LOGSCA (LOG SCA MESSAGES FOR ERROR MONITORING OR DEBUGGING)*
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  TO QUEUE A MESSAGE FOR PRINTING ON THE CONSOLE TYPEWRITER WHICH    *
*  CONTAINS INFORMATION PERTINENT TO THE SCA OPERATION. THE FORMAT    *
*  OF THE MESSAGE IS FIXED BUT THE CONTENT IS DICTATED BY THE USER.   *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL  $LOGSCA  LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                   WHERE --- (ENTRY) AC AND EXT CONTAIN DATA TO BE   *
*                             CONVERTED TO HEX-EBCDIC FOR INSERTION   *
*                             IN THE MESSAGE QUEUED...THE FORMAT OF   *
*                             THE MESSAGE IS...                       *
*                                                                     *
*                             SCA LOG XXXXXXXX                        *
*                                                                     *
*                              WHERE 'XXXXXXXX' IS THE CONVERTED DATA *
*                                                                     *
*                             (EXIT) AC IS SET NON-ZERO IF MESSAGE    *
*                             SUCCESSFULLY QUEUED.                    *
*                                                                     *
*                             AC SET ZERO IF MESSAGE CANNOT BE        *
*                             PROCESSED IMMEDIATELY.                  *
*                                                                     *
*                             ALL INDEX REGISTERS ARE PRESERVED.      *
*                                                                     *
***********************************************************************
         SPACE 3
SLOGSCA  DC    AL2(*-*)            ENTRY VIA $TSL $LOGSCA
         $STD  LOGSINP             SAVE INPUT DATA
         $LD   CONSLFQP,,L         GET CONSOLE FREE QUEUE POINTER
         $BZ   SLOGSCA,,I          EXIT IF NO ELEMENT AVAILABLE
         $STX  LOGSVWA+D1,WA       SAVE
         $STX  LOGSVWB+D1,WB        ALL
         $STX  LOGSVWC+D1,WC         REGISTERS
         $AXT  -2,WA               INPUT WORD INDEX
LOGSOTL  $LD   LOGSOPT+2*D1,WA,L   GET OUTPUT AREA POINTER
         $STO  LOGSPUT+D1          SETUP STORE INSTRUCTION
         $LD   LOGSINP+2*D1,WA,L   GET INPUT DATA WORD
         $RTE  16                   TO EXTENSION OF AC (MQ)
         $AXT  -4,WB               INITIALIZE HEX DIGIT COUNTER
LOGSINL  $SLT  4                   GET A HEX DIGIT
         $AND  LOGSMSK             CLEAR BITS 0-11
         $STO  WC,,L               SET TABLE INDEX
         $LD   XXEBCTB,WC,L        GET EBCDIC VALUE
LOGSPUT  $STO  *-*,WB,L            STORE IN UNPACKED FORM
         $MDX  1,WB                STEP TO NEXT DIGIT
         $B    LOGSINL             CONVERT ALL FOUR
         $MDX  1,WA                STEP TO NEXT WORD
         $B    LOGSOTL             DO TWO WORDS
         $AXT  0,WA                INPUT INDEX
         $AXT  -4,WB               OUTPUT INDEX
LOGSPAK  $LDD  LOGSOUT,WA,L        GET TWO UNPACKED WORDS
         $SRA  8                   PACK
         $SLT  8                    AND
         $STO  LOGSOUT+4*D1,WB,L     STORE
         $MDX  2,WA                STEP TO NEXT PAIR
         $MDX  1,WB                INCREMENT AND TEST STORE INDEX
         $B    LOGSPAK             PACK 8 INTO 4
         $WTO  LOGSMSG,LOGSZAP     QUEUE MESSAGE
LOGSZAP  $LD   *                   FLAG SUCCESS
LOGSVWA  $AXT  *-*,WA,L            RESTORE
LOGSVWB  $AXT  *-*,WB,L             ALL
LOGSVWC  $AXT  *-*,WC,L              REGISTERS
         $B    SLOGSCA,,I          RETURN TO CALLER
***********************************************************************
*              CONSTANTS AND STORAGE                                  *
***********************************************************************
         $BSS  0,E                 EVEN STORAGE REQUIRED
LOGSOPT  $ADCON (LOGSOUT+4*D1)     FIRST WORD OUTPUT POINTER
         $ADCON (LOGSOUT+8*D1)     SECOND WORD OUTPUT POINTER
LOGSINP  $BSS  2                   STORAGE FOR INPUT
LOGSMSG  DC    AL1($BLACK+$EBCD,$LIST15) MESSAGE CONTROL WORD
         DC    AL2(16)             DATA COUNT
         DC    C'SCA LOG '         MUST BE EVEN NUMBER OF WORDS
LOGSOUT  $BSS  8                   OUTPUT AREA
LOGSMSK  DC    AL2(X'000F')        TO CLEAR BITS 0-11
***********************************************************************
*              HEXADECIMAL TO EBCDIC CONVERSION TABLE                 *
***********************************************************************
XXEBCTB  DC    X'F000'             0
         DC    X'F100'             1
         DC    X'F200'             2
         DC    X'F300'             3
         DC    X'F400'             4
         DC    X'F500'             5
         DC    X'F600'             6
         DC    X'F700'             7
         DC    X'F800'             8
         DC    X'F900'             9
         DC    X'C100'             A
         DC    X'C200'             B
         DC    X'C300'             C
         DC    X'C400'             D
         DC    X'C500'             E
         DC    X'C600'             F
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $MOVE (MOVE VARIABLE NUMBER OF WORDS)                       *
*                                                                     *
* FUNCTION/PURPOSE                                                    *
*                                                                     *
*  TO MOVE A SPECIFIED NUMBER OF WORDS FROM A SOURCE BLOCK TO         *
*  A TARGET BLOCK.                                                    *
*                                                                     *
* CALLING SEQUENCE                                                    *
*                                                                     *
*                             $TSL  $MOVE    LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*              WHERE--WA CONTAINS THE ADDRESS OF THE FIRST            *
*                     WORD OF THE TARGET BLOCK ON ENTRY               *
*                                                                     *
*                   --WB CONTAINS THE ADDRESS OF THE FIRST            *
*                     WORD OF THE SOURCE BLOCK ON ENTRY               *
*                                                                     *
*                   --AC CONTAINS THE NUMBER OF WORDS TO              *
*                     MOVE ON ENTRY                                   *
*                                                                     *
*                   WA AND WB ARE SAVED AND RESTORED.                 *
*                   AC IS DESTROYED.                                  *
*                                                                     *
***********************************************************************
         SPACE 3
SMOVE    DC    AL2(*-*)            ENTRY VIA $TSL $MOVE
         $STO  MOVECONT            STORE WORD COUNT
         $STX  MOVESVWA+D1,WA      SAVE WA
         $STX  MOVESVWB+D1,WB      SAVE WB
MOVELOOP $LD   0,WB                GET SOURCE DATA
         $STO  0,WA                STORE IN TARGET
         $MDX  1,WB                INCREMENT TO NEXT
         $MDX  1,WA                SOURCE AND TARGET
         $MDM  MOVECONT,-1         DECREMENT AND TEST COUNT
         $B    MOVELOOP            BRANCH IF MORE
MOVESVWA $AXT  *-*,WA,L            RESTORE WA
MOVESVWB $AXT  *-*,WB,L            RESTORE WB
         $B    SMOVE,,I            RETURN
MOVECONT DC    AL2(*-*)            NUMBER OF WORDS TO MOVE
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $XPRESS (CONVERT 12 BIT CARD CODE TO EBCIDC)                *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
* TO  CONVERT 12 BIT 'IBM' CARD CODE TO EBCDIC 8 BIT CHARACTERS       *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL  $XPRESS  LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                   WHERE--AC CONTAINS CARD CODE IN BITS 0-11 ON      *
*                          ENTRY TO $XPRESS                           *
*                                                                     *
*                        --AC CONTAINS EBCDIC CHARACTER IN BITS 7-15  *
*                          ON RETURN FROM $XPRESS                     *
*                                                                     *
*                        --AC IS SET TO ZERO IF NON-TRANSPARENT       *
*                          TRANSMISSION IS SELECTED (&TRANPRN=0)      *
*                          AND THE RESULTING EBCDIC CHARACTER         *
*                          VALUE IS .LT. X'40' (EBCDIC BLANK)         *
*                                                                     *
* NOTE---           EXT, WB AND WC ARE DESTROYED BY $XPRESS           *
*                                                                     *
***********************************************************************
SXPRESS  DC    AL2(*-*)            ENTRY VIA $TSL $XPRESS
         $BZ   XPRSBLNK            BRANCH IF CARD CODE BLANK
         $SRA  4                   RIGHT JUSTIFY DATA
         $SRT  2                   COLUMNS 8,9 TO EXT
         $STO  XPRSTEMP            SAVE REST TEMPORARILY
         $SRA  6                   DROP COLUMNS 2-7
         $SLT  2                   RESTORE COLUMNS 8,9
         $STO  WB,,L               TO REGISTER WB
         $LD   XPRSTEMP            GET RESIDUAL COLUMNS
         $AND  XPRSMASK            LEAVES COLUMNS 2-7
         $AXT  16,WC               START COUNTER
         $SLCA 0,WC                SET WC WITH ZONE
         $LD   XPRSZNTB,WB,L       GET ZONE BIT CONBINATION
         $MDX  0,WC                TEST FOR NUMERIC PUNCHES
         $SRA  8                   YES. POSITION ZONE WITH NUMERIC CODE
         $OR   XPRSNUMT,WC,L       ADD NUMERIC, IF ANY
         $AND  XPRSCLHF            CLEAR HIGH ORDER BYTE
         AIF   (&TRANPRN EQ 1).XPARENA
         $STO  WB,,L               SET WB TO EBCDIC VALUE
         $MDX  -63,WB              SUBTRACT AND TEST LIMIT
         $SLA  8                   NOT IN BSC CONTROL CODE RANGE
         $SRA  8                   RESTORE ORIGINAL OR SET TO 0
.XPARENA ANOP
         $MDX  -5,WC               TEST FOR POSSIBLE SPECIAL CASE
         $B    XPRSPECL            BRANCH FOR ADDITIONAL TESTING
         $B    SXPRESS,,I          RETURN TO CALLER
XPRSPECL $EOR  XPRSXV6A            TEST FOR CONVERSION VALUE='6A'
         $SKPN                     SKIP AND RESTORE VALUE IF NOT
         $LD   XPRSCDE0            GET CODED 'E0'
         $EOR  XPRSXV6A            RESTORE OR CONVERT
         $B    SXPRESS,,I          RETURN TO CALLER
XPRSBLNK $LD   XPRSBLKC            GET EBCDIC BLANK
         $B    SXPRESS,,I          AND RETURN TO CALLER
XPRSCLHF DC    AL2(X'00FF')        CLEAR LEFT HALF
XPRSBLKC DC    AL2(X'0040')        EBCDIC BLANK
XPRSXV6A DC    X'006A'             TEST VALUE FOR POSSIBLE 'E0'
XPRSCDE0 DC    X'008A'             CODED VALUE FOR 'E0'
XPRSTEMP DC    AL2(*-*)            TEMPORARY STORAGE
XPRSMASK DC    X'003F'             MASK WORD
         EJECT
***********************************************************************
*              $XPRESS CONVERSION TABLE                               *
***********************************************************************
XPRSZNTB DC    X'F040'             00= NO PUNCHES
         DC    X'30F9'             01 = 9
         DC    X'78F8'             02 = 8
         DC    X'3838'             03 = 8-9
         DC    X'00F1'             04 = 1
         DC    X'0031'             05 = 1-9
         DC    X'0079'             06 = 1-8
         DC    X'0039'             07 = 1-8-9
         DC    X'E0F0'             08 = 0
         DC    X'20E9'             09 = 0-9
         DC    X'68E8'             0A = 0-8            * 0-8-2 = E0
         DC    X'2828'             0B = 0-8-9
         DC    X'6161'             0C = 0-1
         DC    X'2121'             0D = 0-1-9
         DC    X'6969'             0E = 0-1-8
         DC    X'2929'             0F   0-1-8-9
         DC    X'D060'             10 = 11             *
         DC    X'10D9'             11   11-9
         DC    X'58D8'             12 = 11-8
         DC    X'1818'             13 = 11-8-9
         DC    X'D1D1'             14 = 11-1
         DC    X'0011'             15 = 11-1-9
         DC    X'0059'             16 = 11-1-8
         DC    X'0019'             17 = 11-1-8-9
         DC    X'A0D0'             18 = 11-0           *
         DC    X'60A9'             19 = 11-0-9
         DC    X'A8A8'             1A = 11-0-8
         DC    X'E868'             1B = 11-0-8-9
         DC    X'00A1'             1C = 11-0-1
         DC    X'00E1'             1D = 11-0-1-9       *
         DC    X'00A0'             1E = 11-0-1-8
         DC    X'0020'             1F = 11-0-1-8-9
         DC    X'C050'             20 = 12
         DC    X'00C9'             21 = 12-9           * REAL 00
         DC    X'48C8'             22 = 12-8
         DC    X'0808'             23 = 12-8-9
         DC    X'00C1'             24 = 12-1
         DC    X'0001'             25 = 12-1-9
         DC    X'0049'             26 = 12-1-8
         DC    X'0009'             27 = 12-1-8-9
         DC    X'80C0'             28 = 12-0
         DC    X'4089'             29 = 12-0-9
         DC    X'8888'             2A = 12-0-8
         DC    X'C848'             2B = 12-0-8-9
         DC    X'0081'             2C = 12-0-1
         DC    X'0041'             2D = 12-0-1-9
         DC    X'0080'             2E = 12-0-1-8
         DC    X'0000'             2F = 12-0-1-8-9     * VALID 00
         DC    X'906A'             30 = 12-11
         DC    X'5099'             31 = 12-11-9
         DC    X'9898'             32 = 12-11-8
         DC    X'D858'             33 = 12-11-8-9
         DC    X'0091'             34 = 12-11-1
         DC    X'0051'             35 = 12-11-1-9
         DC    X'0090'             36 = 12-11-1-8
         DC    X'0010'             37 = 12-11-1-8-9
         DC    X'B070'             38 = 12-11-0
         DC    X'70B9'             39 = 12-11-0-9
         DC    X'B8B8'             3A = 12-11-0-8
         DC    X'F878'             3B = 12-11-0-8-9
         DC    X'00B1'             3C = 12-11-0-1
         DC    X'0071'             3D = 12-11-0-1-9
         DC    X'00B0'             3E = 12-11-0-1-8
         DC    X'0030'             3F = 12-11-0-1-8-9
***********************************************************************
*              $XPRESS CONVERSION TABLE                               *
***********************************************************************
XPRSNUMT DC    X'0000'             NO NUMERIC
         DC    X'0007'             7 PUNCH
         DC    X'0006'             6 PUNCH
         DC    X'0005'             5 PUNCH
         DC    X'0004'             4 PUNCH
         DC    X'0003'             3 PUNCH
         DC    X'0002'             2 PUNCH
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $XCPRNT (EBCDIC TO CONSOLE PRINTER CODE CONVERSION)         *
*                                                                     *
* FUNCTION/PURPOSE                                                    *
*                                                                     *
*  CONVERTS THE EBCDIC CHARACTER IN THE LOW ORDER AC TO CONSOLE       *
*  PRINTER FORMAT CONTAINED IN THE HIGH ORDER AC ON COMPLETION        *
*                                                                     *
* CALLING SEQUENCE                                                    *
*                                                                     *
*                             $TSL  $XCPRNT    LINKAGE                *
*                             ....             RETURN                 *
*                                                                     *
*                   WHERE..AC CONTAINS EBCDIC CHARACTER TO BE         *
*                          CONVERTED IN BITS 8-15 ON INPUT            *
*                                                                     *
*                          AC CONTAINS CONSOLE PRINTER CODE           *
*                          IN BITS 0-7 ON EXIT                        *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
SXCPRNT  DC    AL2(*-*)            ENTRY VIA $TSL $XCPRNT
         $SRT  8                   EBCDIC CHARACTER TO EXT
         $ZAC                      CLEAR AC
         $SLT  1                   HIGH ORDER BIT TO AC
         $STO  XCPRLRTS            SET LEFT/RIGHT SWITCH
         $SRA  1                   CLEAR AC
         $SLT  7                   GET REMAINDER OF CHARACTER
         $A    XCPRTBAD            COMPUTE TABLE ADDRESS
         $STO  XCPRTGET+D1          CORRESPONDING TO DATA
XCPRTGET $LD   *-*,,L              FETCH TABLE ENTRY
         $MDM  XCPRLRTS,0          TEST LEFT/RIGHT SWITCH
         $SLA  8                   MOVE TO BITS 0-7
         $B    SXCPRNT,,I          RETURN TO CALLER
XCPRLRTS DC    AL2(*-*)            LEFT/RIGHT SWITCH
XCPRTBAD $ADCON (XCPRTBLE-64*D1)   ADJUSTED TABLE ADDRESS
         EJECT
         AIF   (&PR1403 EQ 0).NO1403E
***********************************************************************
*                                                                     *
* TITLE - $XPPRNT (EBCDIC TO 1403 PRINTER CODE CONVERSION)            *
*                                                                     *
* FUNCTION/PURPOSE                                                    *
*                                                                     *
*  CONVERTS THE EBCDIC CHARACTER IN THE LOW ORDER AC TO 1403          *
*  PRINTER CODE FORMAT CONTAINED IN THE HIGH ORDER AC ON EXIT         *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL $XPPRNT   LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                             AC CONTAINS EBCDIC CHARACTER TO BE      *
*                             CONVERTED IN BITS 8-15 ON ENTRY         *
*                                                                     *
*                             AC CONTAINS 1403 PRINTER CODE IN        *
*                             BITS 0-7 ON EXIT                        *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 2
SXPPRNT  DC    AL2(*-*)            ENTRY VIA $TSL $XPPRNT
         $AND  XPPRTCLH            CLEAR HIGH ORDER BYTE
         $SRT  7                   INPUT SANS HIGH BIT TO EXT
         $STO  XCPRLRTS            SET LEFT/RIGHT INDICATOR
         $SRA  1                   CLEAR AC
         $SLT  7                   GET REST OF EBCDIC CHARACTER
         $A    XPPRTBAD            COMPUTE TABLE ADDRESS
         $STO  XPPRTGET+D1          CORRESPONDING TO DATA
XPPRTGET $LD   *-*,,L              FETCH TABLE ENTRY
         $MDM  XCPRLRTS,0          TEST LEFT/RIGHT INDICATOR
         $SLA  8                   MOVE RIGHT TO LEFT
         $B    SXPPRNT,,I          RETURN TO CALLER
XPPRTCLH DC    AL2(X'00FF')        CLEAR LEFT HALF
XPPRTBAD $ADCON (XPPRTBLE-64*D1)   ADJUSTED TABLE ADDRESS
         EJECT
***********************************************************************
*              EBCDIC TO 1403 PRINTER CODE CONVERSION TABLE           *
***********************************************************************
XPPRTBLE DC    X'7F7F'             BLANK          NO GRAPHIC
         DC    X'7F64'             NO GRAPHIC     A
         DC    X'7F25'             NO GRAPHIC     B
         DC    X'7F26'             NO GRAPHIC     C
         DC    X'7F67'             NO GRAPHIC     D
         DC    X'7F68'             NO GRAPHIC     E
         DC    X'7F29'             NO GRAPHIC     F
         DC    X'7F2A'             NO GRAPHIC     G
         DC    X'7F6B'             NO GRAPHIC     H
         DC    X'7F2C'             NO GRAPHIC     I
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'6E7F'             PERIOD         NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'577F'             LEFT PAREN     NO GRAPHIC
         DC    X'6D7F'             PLUS           NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'157F'             AMPERSAND      NO GRAPHIC
         DC    X'7F58'             NO GRAPHIC     J
         DC    X'7F19'             NO GRAPHIC     K
         DC    X'7F1A'             NO GRAPHIC     L
         DC    X'7F5B'             NO GRAPHIC     M
         DC    X'7F1C'             NO GRAPHIC     N
         DC    X'7F5D'             NO GRAPHIC     O
         DC    X'7F5E'             NO GRAPHIC     P
         DC    X'7F1F'             NO GRAPHIC     Q
         DC    X'7F20'             NO GRAPHIC     R
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'627F'             DOLLAR SIGN    NO GRAPHIC
         DC    X'237F'             ASTERISK       NO GRAPHIC
         DC    X'2F7F'             RIGHT PAREN    NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'617F'             DASH           NO GRAPHIC
         DC    X'4C7F'             SLASH          NO GRAPHIC
         DC    X'7F0D'             NO GRAPHIC     S
         DC    X'7F0E'             NO GRAPHIC     T
         DC    X'7F4F'             NO GRAPHIC     U
         DC    X'7F10'             NO GRAPHIC     V
         DC    X'7F51'             NO GRAPHIC     W
         DC    X'7F52'             NO GRAPHIC     X
         DC    X'7F13'             NO GRAPHIC     Y
         DC    X'7F54'             NO GRAPHIC     Z
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'167F'             COMMA          NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7F49'             NO GRAPHIC     0
         DC    X'7F40'             NO GRAPHIC     1
         DC    X'7F01'             NO GRAPHIC     2
         DC    X'7F02'             NO GRAPHIC     3
         DC    X'7F43'             NO GRAPHIC     4
         DC    X'7F04'             NO GRAPHIC     5
         DC    X'7F45'             NO GRAPHIC     6
         DC    X'7F46'             NO GRAPHIC     7
         DC    X'7F07'             NO GRAPHIC     8
         DC    X'7F08'             NO GRAPHIC     9
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         DC    X'0B7F'             APOSTROPHE     NO GRAPHIC
         DC    X'4A7F'             EQUAL          NO GRAPHIC
         DC    X'7F7F'             NO GRAPHIC     NO GRAPHIC
         EJECT
.NO1403E ANOP
***********************************************************************
*        $XCPRNT EBCDIC TO CONSOLE PRINTER CODE TABLE                 *
***********************************************************************
XCPRTBLE DC    X'2121'             BLANK          NO GRAPHIC
         DC    X'213C'             NO GRAPHIC     A
         DC    X'2118'             NO GRAPHIC     B
         DC    X'211C'             NO GRAPHIC     C
         DC    X'2130'             NO GRAPHIC     D
         DC    X'2134'             NO GRAPHIC     E
         DC    X'2110'             NO GRAPHIC     F
         DC    X'2114'             NO GRAPHIC     G
         DC    X'2124'             NO GRAPHIC     H
         DC    X'2120'             NO GRAPHIC     I
         DC    X'0221'             CENT SIGN      NO GRAPHIC
         DC    X'0021'             PERIOD         NO GRAPHIC
         DC    X'DE21'             LESS THAN      NO GRAPHIC
         DC    X'FE21'             LEFT PAREN     NO GRAPHIC
         DC    X'DA21'             PLUS           NO GRAPHIC
         DC    X'C621'             LOGICAL OR     NO GRAPHIC
         DC    X'4421'             AMPERSNAD      NO GRAPHIC
         DC    X'217C'             NO GRAPHIC     J
         DC    X'2158'             NO GRAPHIC     K
         DC    X'215C'             NO GRAPHIC     L
         DC    X'2170'             NO GRAPHIC     M
         DC    X'2174'             NO GRAPHIC     N
         DC    X'2150'             NO GRAPHIC     O
         DC    X'2154'             NO GRAPHIC     P
         DC    X'2164'             NO GRAPHIC     Q
         DC    X'2160'             NO GRAPHIC     R
         DC    X'4221'             EXCLAMATION    NO GRAPHIC
         DC    X'4021'             DOLLAR SIGN    NO GRAPHIC
         DC    X'D621'             ASTERICK       NO GRAPHIC
         DC    X'F621'             RIGHT PAREN    NO GRAPHIC
         DC    X'D221'             SEMI-COLON     NO GRAPHIC
         DC    X'F221'             LOGICAL NOT    NO GRAPHIC
         DC    X'8421'             DASH           NO GRAPHIC
         DC    X'BC21'             SLASH          NO GRAPHIC
         DC    X'2198'             NO GRAPHIC     S
         DC    X'219C'             NO GRAPHIC     T
         DC    X'21B0'             NO GRAPHIC     U
         DC    X'21B4'             NO GRAPHIC     V
         DC    X'2190'             NO GRAPHIC     W
         DC    X'2194'             NO GRAPHIC     X
         DC    X'21A4'             NO GRAPHIC     Y
         DC    X'21A0'             NO GRAPHIC     Z
         DC    X'2121'             NO GRAPHIC     NO GRAPHIC
         DC    X'8021'             COMMA          NO GRAPHIC
         DC    X'0621'             PERCENT        NO GRAPHIC
         DC    X'BE21'             UNDERSCORE     NO GRAPHIC
         DC    X'4621'             GREATER THAN   NO GRAPHIC
         DC    X'8621'             QUESTION MARK  NO GRAPHIC
         DC    X'21C4'             NO GRAPHIC     0
         DC    X'21FC'             NO GRAPHIC     1
         DC    X'21D8'             NO GRAPHIC     2
         DC    X'21DC'             NO GRAPHIC     3
         DC    X'21F0'             NO GRAPHIC     4
         DC    X'21F4'             NO GRAPHIC     5
         DC    X'21D0'             NO GRAPHIC     6
         DC    X'21D4'             NO GRAPHIC     7
         DC    X'21E4'             NO GRAPHIC     8
         DC    X'21E0'             NO GRAPHIC     9
         DC    X'8221'             COLON          NO GRAPHIC
         DC    X'C021'             POUND SIGN     NO GRAPHIC
         DC    X'0421'             AT SIGN        NO GRAPHIC
         DC    X'E621'             APOSTROPHE     NO GRAPHIC
         DC    X'C221'             EQUAL SIGN     NO GRAPHIC
         DC    X'E221'             QUOTE SIGN     NO GRAPHIC
         AIF   (NOT &PN1442).NO1442N
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $XCPNCH (EBCDIC TO CARD CODE CONVERSION)                    *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  CONVERTS THE EBCDIC CHARACTER IN THE LOW ORDER AC TO 12 BIT        *
*  IBM CARD CODE FOR OUTPUT TO THE 1442 PUNCH                         *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL  $XCPNCH  LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                   WHERE --- (ENTRY) AC CONTAINS EBCDIC CHARACTER    *
*                             TO BE CONVERTED IN BITS 8-15            *
*                                                                     *
*                           (EXIT) AC CONTAINS CARD CODE VALUE        *
*                             IN BITS 0-11 (BITS 12-15 ARE ZERO)      *
*                                                                     *
***********************************************************************
         SPACE 3
SXCPNCH  DC    AL2(*-*)            ENTRY VIA $TSL $XCPNCH
         $STX  XCPNSVA+D1,WA       SAVE WA
         $AND  XCPNMSK             CLEAR HIGH ORDER BYTE
         $SRT  7                   INPUT SANS HIGH BIT TO EXT
         $STO  XCPNLRS             SAVE HIGH BIT FOR POSITION FLAG
         $SRA  1                   CLEAR POSSIBLE HIGH BIT
         $SLT  7                   TABLE INDEX TO AC
         $A    XCPNTBA             COMPUTE ENTRY ADDRESS
         $STO  XCPNGET+D1           CORRESPONDING TO DATA
XCPNGET  $LD   *-*,,L              FETCH TABLE ENTRY
         $MDM  XCPNLRS,0           TEST LEFT/RIGHT FLAG
         $SRA  8                    AND RIGHT JUSTIFY IF NECESSARY
         $SRT  8                     MOVE PACKED VALUE TO EXT
         $SLT  3                   ISOLATE 12,11 AND 0 PUNCHES
         $SLA  13                   TO HIGH ORDER AC
         $STO  XCPNTMO               SAVE FOR CONSTRUCTION
         $SLT  3                   GET 1-7 PUNCHES
         $BZ   XCPNFRM             BRANCH IF NONE
         $S    XCPNC13             REDUCE BY MAGIC NUMBER
         $STO  XCPNTMT             SAVE FOR CALCULATIONS
         $ZAC                      CLEAR AC AND
         $S    XCPNTMT              COMPLEMENT COUNT
         $STO  WA,,L                 TO WA
         $LD   XCPNCNO             CONSTANT ONE
         $SLA  0,WA                 TO COMPUTED POSITION
XCPNFRM  $OR   XCPNTMO             COMBINE WITH 12,11 AND 0 PUNCHES
         $SRA  6                   GET
         $SLT  6                    8-9
XCPNSVA  $AXT  *-*,WA,L            RESTORE WA
         $B    SXCPNCH,,I          RETURN TO CALLER
XCPNMSK  DC    AL2(X'00FF')        TO CLEAR BITS 0-7
XCPNLRS  DC    AL2(*-*)            LEFT/RIGHT FLAG
XCPNTBA  $ADCON (XCPNPCC)          PACKED CARD CODE TABLE ADDRESS
XCPNTMO  DC    AL2(*-*)            STORAGE FOR 11,12 AND 0 PUNCHES
XCPNC13  DC    AL2(13)             MAGIC NUMBER
XCPNTMT  DC    AL2(*-*)            STORAGE FOR COMPLEMENTED COUNT
XCPNCNO  DC    AL2(1)              ANOTHER CONSTANT ONE
         EJECT
***********************************************************************
*              PACKED EBCDIC TO CARD CODE CONVERSION TABLE            *
***********************************************************************
XCPNPCC  $NULL
         DC    X'A6A7'             NO GRAPHIC     NO GRAPHIC
         DC    X'A485'             NO GRAPHIC     NO GRAPHIC
         DC    X'A889'             NO GRAPHIC     NO GRAPHIC
         DC    X'AC8D'             NO GRAPHIC     NO GRAPHIC
         DC    X'B091'             NO GRAPHIC     PUNCH OFF
         DC    X'B495'             NO GRAPHIC     HORIZ TAB
         DC    X'B899'             NO GRAPHIC     LOWER CASE
         DC    X'BC9D'             NO GRAPHIC     DELETE
         DC    X'A283'             NO GRAPHIC     NO GRAPHIC
         DC    X'A187'             NO GRAPHIC     NO GRAPHIC
         DC    X'AA8B'             NO GRAPHIC     NO GRAPHIC
         DC    X'AE8F'             NO GRAPHIC     NO GRAPHIC
         DC    X'B293'             NO GRAPHIC     NO GRAPHIC
         DC    X'B697'             NO GRAPHIC     NO GRAPHIC
         DC    X'BA9B'             NO GRAPHIC     NO GRAPHIC
         DC    X'BE9F'             NO GRAPHIC     NO GRAPHIC
         DC    X'C6C7'             NO GRAPHIC     NO GRAPHIC
         DC    X'C445'             NO GRAPHIC     NO GRAPHIC
         DC    X'C849'             NO GRAPHIC     NO GRAPHIC
         DC    X'CC4D'             NO GRAPHIC     RESTORE
         DC    X'D051'             NO GRAPHIC     NEW LINE
         DC    X'D455'             NO GRAPHIC     BACKSPACE
         DC    X'D859'             NO GRAPHIC     IDLE
         DC    X'DC5D'             NO GRAPHIC     NO GRAPHIC
         DC    X'C243'             NO GRAPHIC     NO GRAPHIC
         DC    X'C147'             NO GRAPHIC     NO GRAPHIC
         DC    X'CA4B'             NO GRAPHIC     NO GRAPHIC
         DC    X'CE4F'             NO GRAPHIC     NO GRAPHIC
         DC    X'D253'             NO GRAPHIC     NO GRAPHIC
         DC    X'D657'             NO GRAPHIC     NO GRAPHIC
         DC    X'DA5B'             NO GRAPHIC     NO GRAPHIC
         DC    X'DE5F'             NO GRAPHIC     DS
         DC    X'6667'             NO GRAPHIC     SOS
         DC    X'6425'             NO GRAPHIC     FS
         DC    X'6829'             NO GRAPHIC     NO GRAPHIC
         DC    X'6C2D'             NO GRAPHIC     BYPASS
         DC    X'7031'             NO GRAPHIC     LINE FEED
         DC    X'7435'             NO GRAPHIC     EOB
         DC    X'7839'             NO GRAPHIC     PREFIX
         DC    X'7C3D'             NO GRAPHIC     NO GRAPHIC
         DC    X'6223'             NO GRAPHIC     NO GRAPHIC
         DC    X'6127'             NO GRAPHIC     SET MODE
         DC    X'6A2B'             NO GRAPHIC     NO GRAPHIC
         DC    X'6E2F'             NO GRAPHIC     NO GRAPHIC
         DC    X'7233'             NO GRAPHIC     NO GRAPHIC
         DC    X'7637'             NO GRAPHIC     NO GRAPHIC
         DC    X'7A3B'             NO GRAPHIC     NO GRAPHIC
         DC    X'7E3F'             NO GRAPHIC     NO GRAPHIC
         DC    X'E6E7'             NO GRAPHIC     NO GRAPHIC
         DC    X'E405'             NO GRAPHIC     NO GRAPHIC
         DC    X'E809'             NO GRAPHIC     NO GRAPHIC
         DC    X'EC0D'             NO GRAPHIC     NO GRAPHIC
         DC    X'F011'             NO GRAPHIC     PUNCH ON
         DC    X'F415'             NO GRAPHIC     READER STOP
         DC    X'F819'             NO GRAPHIC     UPPER CASE
         DC    X'FC1D'             NO GRAPHIC     EOT
         DC    X'E203'             NO GRAPHIC     NO GRAPHIC
         DC    X'E107'             NO GRAPHIC     NO GRAPHIC
         DC    X'EA0B'             NO GRAPHIC     NO GRAPHIC
         DC    X'EE0F'             NO GRAPHIC     NO GRAPHIC
         DC    X'F213'             NO GRAPHIC     NO GRAPHIC
         DC    X'F617'             NO GRAPHIC     NO GRAPHIC
         DC    X'FA1B'             NO GRAPHIC     NO GRAPHIC
         DC    X'FE1F'             NO GRAPHIC     NO GRAPHIC
         DC    X'A000'             PLUS ZERO      SPACE
         DC    X'84A5'             A              NO GRAPHIC
         DC    X'88A9'             B              NO GRAPHIC
         DC    X'8CAD'             C              NO GRAPHIC
         DC    X'90B1'             D              NO GRAPHIC
         DC    X'94B5'             E              NO GRAPHIC
         DC    X'98B9'             F              NO GRAPHIC
         DC    X'9CBD'             G              NO GRAPHIC
         DC    X'82A3'             H              NO GRAPHIC
         DC    X'8186'             I              NO GRAPHIC
         DC    X'AB8A'             NO GRAPHIC     CENT
         DC    X'AF8E'             NO GRAPHIC     PERIOD
         DC    X'B392'             NO GRAPHIC     LESS THAN
         DC    X'B796'             NO GRAPHIC     LEFT PAREN
         DC    X'BB9A'             NO GRAPHIC     PLUS
         DC    X'BF9E'             NO GRAPHIC     LOGICAL OR
         DC    X'6080'             MINUS ZERO     AMPERSAND
         DC    X'44C5'             J              NO GRAPHIC
         DC    X'48C9'             K              NO GRAPHIC
         DC    X'4CCD'             L              NO GRAPHIC
         DC    X'50D1'             M              NO GRAPHIC
         DC    X'54D5'             N              NO GRAPHIC
         DC    X'58D9'             O              NO GRAPHIC
         DC    X'5CDD'             P              NO GRAPHIC
         DC    X'42C3'             Q              NO GRAPHIC
         DC    X'4146'             R              NO GRAPHIC
         DC    X'CB4A'             NO GRAPHIC     EXCLAMATION
         DC    X'CF4E'             NO GRAPHIC     DOLLAR
         DC    X'D352'             NO GRAPHIC     ASTERISK
         DC    X'D756'             NO GRAPHIC     RIGHT PAREN
         DC    X'DB5A'             NO GRAPHIC     SEMI COLON
         DC    X'DF5E'             NO GRAPHIC     LOGICAL NOT
         DC    X'2A40'             NO GRAPHIC     DASH, MINUS
         DC    X'6524'             NO GRAPHIC     SLASH
         DC    X'2869'             S              NO GRAPHIC
         DC    X'2C6D'             T              NO GRAPHIC
         DC    X'3071'             U              NO GRAPHIC
         DC    X'3475'             V              NO GRAPHIC
         DC    X'3879'             W              NO GRAPHIC
         DC    X'3C7D'             X              NO GRAPHIC
         DC    X'2263'             Y              NO GRAPHIC
         DC    X'2126'             Z              NO GRAPHIC
         DC    X'6BC0'             NO GRAPHIC     NO GRAPHIC
         DC    X'6F2E'             NO GRAPHIC     COMMA
         DC    X'7332'             NO GRAPHIC     PERCENT
         DC    X'7736'             NO GRAPHIC     UNDERSCORE
         DC    X'7B3A'             NO GRAPHIC     GRATER THAN
         DC    X'7F3E'             NO GRAPHIC     QUESTION MARK
         DC    X'20E0'             0              NO GRAPHIC
         DC    X'04E5'             1              NO GRAPHIC
         DC    X'08E9'             2              NO GRAPHIC
         DC    X'0CED'             3              NO GRAPHIC
         DC    X'10F1'             4              NO GRAPHIC
         DC    X'14F5'             5              NO GRAPHIC
         DC    X'18F9'             6              NO GRAPHIC
         DC    X'1CFD'             7              NO GRAPHIC
         DC    X'02E3'             8              NO GRAPHIC
         DC    X'0106'             9              NO GRAPHIC
         DC    X'EB0A'             NO GRAPHIC     COLON
         DC    X'EF0E'             NO GRAPHIC     NUMBER
         DC    X'F312'             NO GRAPHIC     AT
         DC    X'F716'             NO GRAPHIC     APOSTROPHE
         DC    X'FB1A'             NO GRAPHIC     EQUAL
         DC    X'FF1E'             NO GRAPHIC     QUOTATION
.NO1442N ANOP
         TITLE 'RTP1130 (SCA I/O SUPERVISOR-LOW SPEED)'
***********************************************************************
*                                                                     *
* TITLE - BSXIOS (LOW SPEED BSCA INPUT/OUTPUT SUPERVISOR)             *
*                                                                     *
* FUNCTION/DESCRIPTION                                                *
*                                                                     *
*  PROCESSES REQUEST FOR TRANSMIT, RECEIVE OR PROGRAM TIMER           *
*  FUNCTIONS ON THE LOW SPEED BINARY SYNCHRONOUS COMMUNICATIONS       *
*  ADAPTER. BSXIOS INITIATES THE REQUESTED FUNCTION AND PREPARES      *
*  THE INTERRUPT ROUTINE FOR THE ENSUING ONSLAUGHT OF INTERRUPTS      *
*                                                                     *
* CALLING SEQUENCE...                                                 *
*                        $TSL  BSXIOS   LINKAGE                       *
*                        ...            REJECT EXIT                   *
*                        ...            NORMAL EXIT                   *
*                                                                     *
*              WHERE...  ON ENTRY...                                  *
*                                                                     *
*                        WA CONTAINS THE ADDRESS OF A CONTROL         *
*                        AND DATA AREA WITH THE FORMAT AS             *
*                        DESCRIBED UNDER 'TPBUF ELEMENT               *
*                        DESCRIPTION'. THE FUNCTION TO BE             *
*                        PERFORMED IS INDICATED BY THE VALUE          *
*                        OF THE 'TPBUFCB' FIELD OF THE ELEMENT.       *
*                                                                     *
*                        DATA TO BE TRANSMITTED MUST BE IN            *
*                        PACKED (2 BYTES PER WORD) EBCDIC FORM.       *
*                                                                     *
*                        DATA RECEIVED IS STORED IN PACKED FORM.      *
*                                                                     *
*                        ON EXIT...                                   *
*                                                                     *
*                        AC DESTROYED                                 *
*                        WA IS RESTORED                               *
*                                                                     *
*                        REJECT EXIT OCCURS IF DATA SET NOT           *
*                        READY                                        *
*                                                                     *
*                        LOCATION 'BSXOPF' IS SET TO THE              *
*                        ADDRESS OF A STATUS WORD WHICH               *
*                        CONTAINS ONE OF THE VALUES DEFINED           *
*                        BELOW. A SEPARATE STATUS WORD IS             *
*                        MAINTAINED FOR READ (BSXOPFR)                *
*                        AND WRITE (BSXOPFW) OPERATIONS.              *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*              OPERATION STATUS VALUES FOR BSXOPFR                    *
***********************************************************************
*                                  * RECEIVE FUNCTION *               *
*                                  ********************               *
*                                                                     *
BSXORF0  EQU   0                   READ FUNCTION IS INCOMPLETE
*
BSXORF1  EQU   1                   NORMAL READ COMPLETE...
*                                  END SEQUENCE (SYN-ETB OR DLE-ETB)
*                                  DETECTED AND NUMBER OF BYTES
*                                  REQUESTED OR LESS THAN THE
*                                  NUMBER REQUESTED HAVE BEEN
*                                  TRANSMITTED. THE ACTUAL COUNT
*                                  IS STORED IN THE FIRST WORD
*                                  OF THE I/O AREA SUPPLIED
*
BSXORF2  EQU   2                   ABNORMAL READ COMPLETE...
*                                  NUMBER OF BYTES REQUESTED HAVE
*                                  BEEN TRANSMITTED BUT THE END
*                                  SEQUENCE WAS NOT DETECTED. NO
*                                  BCC COMPARISON PERFORMED.
*
BSXORF3  EQU   3                   RECEIVE TIMEOUT...
*                                  DETECTED ON INITIAL SEQUENCE
*                                  WHILE ADAPTER IS ATTEMPTING
*                                  TO SYNCHRONIZE.
*
BSXORF4  EQU   4                   RECEIVE TIMEOUT...
*                                  DETECTED WHILE DATA BEING
*                                  READ AFTER INITIAL SYNCH-
*                                  RONIZATION ESTABLISHED.
*
BSXORF5  EQU   5                   BCC COMPARE ERROR...
*                                  CONDITIONS DESCRIBED BY
*                                  BSXORF1 ARE SATISFIED.
*
BSXORF6  EQU   6                   DATA OVERRUN ERROR...
*                                  PROGRAM DID NOT READ DATA
*                                  BEFORE NEXT CHARACTER
*                                  RECEIVED FROM LINE.
*
BSXORF7  EQU   7                   DATA SET NOT READY...
*                                  DISCOVERED AT INTERRUPT TIME
*
BSXORF8  EQU   8                   ERROR ON INITIAL READ...
*                                  FIRST CHARACTER NOT SOH, DLE,
*                                  ENQ OR NAK...OR...SOH-STX,
*                                  DLE-STX, DLE-ACK0 PAIR
*                                  NOT FOUND.
*
BSXORF9  EQU   9                   NAK RECEIVED
*
BSXORFA  EQU   10                  DLE-ACK0 RECEIVED
*
BSXORFB  EQU   11                  SINGLE DLE FOUND IN
*                                  TRANSPARENT TEXT
*
BSXORFC  EQU   12                  ENQ RECEIVED
*
BSXORFD  EQU   13                  ERROR ON SUSPECTED NAK OR ENQ...
*                                  NO PAD CHARACTER FOLLOWING NAK/ENQ.
*
***********************************************************************
*              OPERATION VALUES FOR BSXOPFW                           *
***********************************************************************
*                                  * TRANSMIT FUNCTION *              *
*                                  *********************              *
*                                                                     *
BSXOWF0  EQU   0                   WRITE FUNCTION IS INCOMPLETE.
*
BSXOWF1  EQU   1                   WRITE FUNCTION COMPLETED
*                                  NORMALLY.
*
*
BSXOWF2  EQU   2                   DATA SET NOT READY...
*                                  DISCOVERED AT INTERRUPT TIME
*
BSXOWF3  EQU   3                   TIMEOUT IN TRANSMIT MODE...
*                                  'CLEAR TO SEND' NOT RECEIVED
*                                  FROM DATA SET WITHIN 3 SEC.
*
*                                  THE VALUE OF BSXOWF3 IS ALSO USED
*                                  TO INDICATE NORMAL COMPLETION
*                                  OF REQUESTED PROGRAM TIMER
*                                  FUNCTION
*
         EJECT
         SPACE 3
***********************************************************************
*              LOW SPEED BSCA PROGRAM VARIABLES                       *
***********************************************************************
BSXLSPD  EQU   &LINESPD            LINE BAUD RATE
*
BSXNSIR  EQU   BSXLSPD/8           CHARACTER COUNT BEFORE INSERTING
*                                  SYNCHRONOUS IDLE SEQUENCE (SYN-SYN)
*                                  IN NORMAL TEXT MODE...
*                                  BSXNSIR=(BSXLSPD/8)*1.00
*                                  WHERE 1.00 IS THE NORMAL
*                                  2701 TIMER INTERVAL
*
         AIF   (&CLOCK EQ 0).CLOCK1
BSXTSIR  EQU   (84+56)/2           CHARACTER COUNT BEFORE INSERT-
*                                  ING SYNCHRONOUS IDLE SEQUENCE
*                                  IN TRANSPARENT TEXT WHEN
*                                  INTERNAL CLOCKING IS USED.
         AGO   .CLOCK2
.CLOCK1  ANOP
BSXTSIR  EQU   BSXNSIR             CHARACTER COUNT BEFORE INSERTING
*                                  SYNCHRONOUS IDLE SEQUENCE (DLE-SYN)
*                                  IN TRANSPARENT TEXT WHEN
*                                  EXTERNAL  (DATA SET) CLOCKING
*                                  IS USED.
.CLOCK2  ANOP
*
BSXNSYN  EQU   5                   NUMBER OF SYN CHARACTERS TO
*                                  TRANSMIT PRECEDING EACH MESSAGE
***********************************************************************
*              WRITE PROCESS MONITOR TRANSFER VECTOR TABLE            *
***********************************************************************
BSXNWPR  $NULL                     REFERENCE POINT
*
BSXWPR0  EQU   0                   PROCESS 0 INDEX
         $ADCON (BSXNINS)          WRITE INITIAL SYN CHARACTERS
*
BSXWPR1  EQU   1                   PROCESS 1 INDEX
         $ADCON (BSXNWHN)          WRITE NORMAL TEXT HEADER
*
BSXWPR2  EQU   2                   PROCESS 2 INDEX
         $ADCON (BSXNWHT)          WRITE TRANSPARENT TEXT HEADER
*
BSXWPR3  EQU   3                   PROCESS 3 INDEX
         $ADCON (BSXNWDA)          WRITE DLE-ACK0
*
BSXWPR4  EQU   4                   PROCESS 4 INDEX
         $ADCON (BSXNNAK)          WRITE NAK
*
BSXWPR5  EQU   5                   PROCESS 5 INDEX
         $ADCON (BSXNWSQ)          WRITE SOH-ENQ
*
BSXWPR6  EQU   6                   PROCESS 6 INDEX
         $ADCON (BSXNPDO)          TERMINATION PROCEDURE
*
BSXWPR7  EQU   7                   PROCESS 7 INDEX
         $ADCON (BSXWMON)          DATA MONITORING
         EJECT
***********************************************************************
*              READ PROCESS MONITOR TRANSFER VECTOR TABLE             *
***********************************************************************
BSXRSSQ  $NULL                     REFERENCE POINT
*
BSXRPR0  EQU   0                   PROCESS 0 INDEX
         $ADCON (BSXRMON)          MONITOR INITIAL INPUT FOR
*                                  NAK, SOH, DLE OR ENQ
*
BSXRPR1  EQU   1                   PROCESS 1 INDEX
         $ADCON (BSXRSHS)          SOH FOUND, NOW LOOK FOR STX
*
BSXRPR2  EQU   2                   PROCESS 2 INDEX
         $ADCON (BSXRDHS)          DLE FOUND, NOW LOOK FOR STX
*                                  OR ACK0
*
BSXRPR3  EQU   3                   PROCESS 3 INDEX
         $ADCON (BSXRNRM)          NORMAL TEXT...LOOK FOR SYN
*
BSXRPR4  EQU   4                   PROCESS 4 INDEX
         $ADCON (BSXRTRN)          TRANSPARENT TEXT, LOOK FOR DLE
*
BSXRPR5  EQU   5                   PROCESS 5 INDEX
         $ADCON (BSXRNET)          SYN FOUND (NORMAL) LOOK FOR
*                                  ETB OF SYN-ETB PAIR
*
BSXRPR6  EQU   6                   PROCESS 6 INDEX
         $ADCON (BSXRTET)          DLE FOUND (TRANSPARENCY) LOOK
*                                  FOR ETB OF DLE-ETB PAIR
*
BSXRPR7  EQU   7                   PROCESS 7 INDEX
         $ADCON (BSXRBBO)          PROCESS FIRST BCC CHARACTER
*
BSXRPR8  EQU   8                   PROCESS 8 INDEX
         $ADCON (BSXRBBT)          PROCESS SECOND BCC CHARACTER
*
BSXRPR9  EQU   9                   PROCESS 9 INDEX
         $ADCON (BSXRPCK)          CHECK FOR PAD FOLLOWING NAK OR ENQ
         EJECT
***********************************************************************
*              READ - WRITE STATUS VARIABLES                          *
***********************************************************************
BSXOPFW  DC    AL2(*-*)            SCA WRITE OPERATION STATUS
BSXOPFR  DC    AL2(*-*)            SCA READ OPERATION STATUS
BSXOPF   DC    AL2(*-*)            POINTER TO CURRENT OP STATUS
BSXOPFWP $ADCON (BSXOPFW)          ADDRESS OF WRITE OP STATUS
BSXOPFRP $ADCON (BSXOPFR)          ADDRESS OF READ OP STATUS
***********************************************************************
*              SPECIAL PROCESSOR TO STOP SCA OPERATION                *
***********************************************************************
BSXHALT  DC    AL2(*-*)            ENTRY VIA $TSL BSXHALT
         $XIO  BSXIRST             ISSUE SCA RESET COMMAND
         $B    BSXHALT,,I          RETURN TO CALLER
***********************************************************************
*              PROGRAM TIMER FUNCTION PREPARATION                     *
***********************************************************************
BSXITMR  $NULL
         $XIO  BSXIRST             ISSUE SCA RESET COMMAND
         $XIO  BSXISPT-D1          START THE PROGRAM TIMER
BSXISVA  $AXT  *-*,WA,L            RESTORE ORIGINAL WA VALUE
         $MDM  BSXIOS,1            SET BSXIOS FOR NORMAL EXIT
         $ZAC                      CLEAR AC AND RESET
         $STO  BSXOPF,,I            APPROPRIATE STATUS
         $B    BSXIOS,,I           RETURN TO CALLER
         $BSS  0,E
BSXICN1  DC    AL2(1)              CONSTANT 1
BSXISPT  DC    AL2($SCALOW+$CONTROL+32) PROGRAM TIMER START
BSXIRST  DC    AL2(0)              AVAILABLE SPACE
         DC    AL2($SCALOW+$IWRITE+64) RESET SCA COMMAND
***********************************************************************
*              ENTRY POINT TO BSXIOS                                  *
***********************************************************************
BSXIOS   DC    AL2(*-*)            ENTRY POINT VIA $TSL BSXIOS
         $XIO  BSXISNR-D1          SENSE SCA WITHOUT RESET
         $SLA  7                   GET DATA SET READY BIT
         $BNN  BSXIOS,,I           REJECT REQUEST IF NOT READY
         $XIO  BSXILDS             LOAD SYNC/IDLE REGISTER (SYN)
         $STX  BSXISVA+D1,WA       SAVE WA FOR EXIT RESTORATION
         $MDX  TPBUFCB,WA,X        POINT TO DATA COUNT FIELD
         $STX  BSXIOAR+D1,WA,L     AND SAVE POINTER
         $LD   0,WA                GET DATA COUNT FROM I/O AREA
         $STO  BSXICNT             SAVE FOR INTERRUPT ROUTINE
         $MDX  1,WA                POINT TO DATA START
         $ZAC                      CLEAR AC AND RESET...
         $STO  BSXNWOK+D1,,L       WRITE PROCESS MONITOR INDEX
         $STO  BSXNLRT,,L          WRITE FETCH LEFT/RIGHT SWITCH
         $STO  BSXBCCA,,L          BCC (CRC-16) ACCUMULATION
         $STO  BSXNXXT+D1,,L       WRITE TERMINATION INDEX
         $LD   BSXOPFWP            ASSUME WRITE OPERATION
         $STO  BSXOPF               AND SET STATUS WORD POINTER
         $LD   0,WA                GET FUNCTION TYPE
         $STO  BSXIOPT             AND SAVE IT
         $BZ   BSXIREC             BRANCH IF RECEIVE
         EJECT
***********************************************************************
*              WRITE SELECT (TRANSMIT) PREPARATION                    *
***********************************************************************
         $S    BSXICN1             DECREMENT FUNCTION TYPE
         $STO  BSXWHAT+D1,,L       AND FORM PROCESS INDEX
         $BZ   BSXITMR             BRANCH IF TIMER REQUEST
         $EOR  BSXIXPS             TEST FOR TRANSPARENT WRITE
         $STO  BSXITXT             SET ZERO IF TRANSPARENCY
         $LDD  BSXTRTX             ASSUME TRANSPARENT TEXT
         $MDM  BSXITXT,0           TEST MODE INDICATOR
         $LDD  BSXNRTX             GET NORMAL TEXT VALUES
         $STO  BSXTRL1,,L          SET FIRST TRAILER CHARACTER
         $STO  BSXISIX,,L          SET FIRST SYNC/IDLE CHARACTER
         $SLT  16                  GET SYNC/IDLE FREQUENCY CONSTANT
         $STO  BSXSTCN,,L          AND SET SYNC/IDLE INSERT
         $STO  BSXSTCT,,L          COUNTER VARIABLES
         $LD   BSXNCN2             SET DATE WRITE COUNT TO
         $STO  BSXXCNT,,L          INCLUDE HEADER CHARACTERS
         $MDX  1,WA                POINT TO DATA WORD FOLLOWING
         $STX  BSXDTAD,WA          HEADER AND SAVE ADDRESS
         $AXT  BSXNSYN,WA,X        SET INITIAL SEQUENCE FLAG
         $STX  BSXISCT,WA          TO NUMBER OF PRECEDING SYN'S
         $XIO  BSXITMM             SET TRANSMIT MODE
         $B    BSXISVA             GO TO EXIT PROCEDURE
***********************************************************************
*              READ SELECT (RECEIVE) PREPARATION                      *
***********************************************************************
BSXIREC  $STO  BSXRSEQ+D1,,L       RESET READ PROCESS INDEX
         $STO  BSXRCNT,,L          AND RECEIVE DATA COUNTER
         $STO  BSXRPLR,,L          AND LEFT/RIGHT SWITCH
         $STX  BSXDTAD,WA          SAVE POINTER TO DATA AREA
         $LD   BSXOPFRP            SET STATUS WORD POINTER
         $STO  BSXOPF               TO READ OPERATION
         $XIO  BSXISRD-D1          INITIATE SCA READ OPERATION
         $XIO  BSXITME-D1          START READ TIMER
         $B    BSXISVA             GO TO EXIT PROCEDURE
         EJECT
***********************************************************************
*              COMMANDS, CONSTANTS, VARIABLES, STORAGE                *
***********************************************************************
         $BSS  0,E
BSXIOPT  DC    AL2(*-*)            OPERATION TYPE FLAG           E
*                                   ZERO IF RECEIVE
*                                   NON-ZERO IF TRANSMIT
BSXISNR  DC    AL2($SCALOW+$SENSED) SENSE SCA WITHOUT RESET      O
*
BSXILDS  $ADCON (BSXISYN)          LOAD SYNC/IDLE WITH SYN       E
         DC    AL2($SCALOW+$WRITE+4)                             O
*
BSXICNT  DC    AL2(*-*)            BYTE COUNT FROM I/O AREA      E
BSXIRDS  DC    AL2($SCALOW+$IREAD) START READ                    O
*
BSXIXPS  DC    AL2($BSXTTT-1)      TEST FOR TRANSPARENT TEXT     E
BSXITME  DC    AL2($SCALOW+$SENSED+2) START TIMER                O
*
BSXITMM  DC    X'FF00'             INITIATE WRITE TO SET         E
         DC    AL2($SCALOW+$IWRITE) TRANSMIT MODE                O
*
BSXNRTX  DC    AL1($SYN,0)         INITIALIZATION VALUES FOR     E
         DC    AL2(BSXNSIR)        NORMAL TEXT MODE              O
*
BSXNDSW  DC    AL2(*-*)            STORAGE FOR SCA DSW           E
BSXNSWR  DC    AL2($SCALOW+$SENSED+1) SENSE SCA DSW WITH RESET   O
*
BSXTRTX  DC    AL1($DLE,0)         INITIALIZATION VALUES FOR     E
         DC    AL2(BSXTSIR)        TRANSPARENT TEXT MODE         O
*
BSXDTAD  DC    AL2(*-*)            VARIABLE DATA WORD POINTER    E
BSXISRD  DC    AL2($SCALOW+$IREAD) START SCA READ                O
*
BSXITXT  DC    AL2(*-*)            TRANSMIT MODE FLAG
*                                   ZERO IF TRANSPARENCY
*                                   NON-ZERO IF NORMAL
*
BSXNCN2  DC    AL2(2)              INITIAL WRITE DATA COUNT
BSXISCT  DC    AL2(*-*)            INITIAL SEQUENCE SYN COUNT
         EJECT
***********************************************************************
*              SCA (LOW SPEED) INTERRUPT PROCESSOR -SLIP 1            *
***********************************************************************
BSCLOINT $NULL                     ENTRY FROM FLIP 1
         $STX  BSXSVWA+D1,WA,L     SAVE WA IN EXIT ROUTINE
         $XIO  BSXNSWR-D1          SENSE SCA WITH RESET
         $STO  BSXNDSW             SAVE DSW FOR LATER USE
         $SLA  7                   GET SCA READY BIT
         $BNN  BSXNRDY             BRANCH IF SCA NOT READY
         $LD   BSXNDSW             RESTORE DSW AND
         $BN   BSXNRDR             BRANCH IF READ RESPONSE
         $SLA  1                   GET POSSIBLE WRITE RESPONSE
         $BNN  BSXNTMO             BRANCH IF NOT WRITE RESPONSE
***********************************************************************
*              WRITE RESPONSE PROCESSOR                               *
***********************************************************************
         $SLA  1                   GET POSSIBLE CHECK BIT
         $BNN  BSXNWOK             BRANCH IF CHECK BIT OFF
         $MDM  $ERRSCWC,1          INCREMENT TRANSMIT CHECK COUNT
         $LD   BSXISYN             GET A SYN CHARACTER
         $TSL  BSXWRXC             GO WRITE IT
         $B    BSXFLPX,,L          EXIT TO FLIP 1
***********************************************************************
*              DATA MONITORING PROCESS                                *
***********************************************************************
BSXWMON  $NULL
         $LD   BSXXCNT             GET DATA TRANSFERED COUNT
         $EOR  BSXICNT             COMPARE WITH REQUEST
         $BZ   BSXNXXT             BRANCH IF TERMINATION TIME
         $LD   BSXXCNT             GET DATA COUNT
         $EOR  BSXSTCT             COMPARE WITH SYNC/IDLE MARKER
         $BZ   BSXNSKT             BRANCH IF TIME TO INSERT SYNC/IDLE
         AIF   (&TRANPRN EQ 0).NOXPRNA
         $LD   BSXNDLI             WAS LAST CHARACTER A DLE
         $BNZ  BSXNRSD             BRANCH IF IT WAS
.NOXPRNA ANOP
         $LD   BSXDTAD,,I          GET NEXT DATA WORD
         $MDM  BSXNLRT,0           TEST LEFT/RIGHT SWITCH
         $SLA  8                   MOVE RIGHT TO LEFT
         $AND  BSXNMSK             CLEAR RIGHT CHARACTER
         $STO  BSXNTMP             SAVE DATA TO BE TRANSMITTED
         AIF   (&TRANPRN EQ 0).NOXPRNB
         $EOR  BSXNDLE             TEST FOR DLE IN DATA
         $BZ   BSXNDLP             BRANCH IF DLE FOUND
.NOXPRNB ANOP
BSXNORM  $LD   BSXDTAD             GET DATA WORD POINTER
         $A    BSXNLRT             POINT TO NEXT, IF TIME
         $STO  BSXDTAD             RESET DATA WORD POINTER
         $LD   BSXNLRT             GET LEFT/RIGHT SWITCH
         $EOR  BSXNCN1             REVERSE CURRENT SETTING
         $STO  BSXNLRT             FOR NEXT TIME AROUND
         $MDM  BSXXCNT,1           INCREMENT DATA COUNTER
         $LD   BSXNTMP             GET DATA CHARACTER
         $TSL  BSXWRXC             GO WRITE IT AND THEN
         $TSL  BSXNBCC             CALCULATE BCC
         $B    BSXFLPX,,L          GO TO EXIT
         AIF   (&TRANPRN EQ 0).NOXPRNC
BSXNDLP  $STL  BSXNDLI             TURN ON DLE FLAG
         $LD   BSXNDLE             GET DLE CHARACTER
         $TSL  BSXWRXC             GO WRITE IT
         $B    BSXFLPX,,L          GO TO EXIT
BSXNRSD  $ZAC                      CLEAR AC AND
         $STO  BSXNDLI             LOWER DLE FLAG
         $B    BSXNORM             GO TO NORMAL FLOW
***********************************************************************
*              LOCAL CONSTANTS,ETC.                                   *
***********************************************************************
BSXNDLI  DC    AL2(*-*)            DLE FLAG
BSXNDLE  DC    AL1($DLE,0)         DLE
.NOXPRNC ANOP
BSXXCNT  DC    AL2(*-*)            DATA TRANSFER COUNT
BSXNMSK  EQU   BSXITMM             RIGHT HALF MASK
BSXNLRT  DC    AL2(*-*)            LEFT/RIGHT SWITCH
BSXNTMP  DC    AL2(*-*)            TEMPORARY DATA STORAGE
BSXNSTI  DC    AL2(*-*)            TRIP INDICATOR
***********************************************************************
*              SYNCHRONOUS/IDLE INSERT TIME                           *
***********************************************************************
BSXNSKT  $LDD  BSXISIX             GET SYNC SEQUENCE SET BY BSXIOS
         $TSL  BSXWRXC             GO WRITE SELECTED SYNC CHARACTER
         $RTE  16                  GET NEXT SYNC CHARACTER AND
         $STD  BSXISIX             SET UP FOR NEXT TRIP
         $LD   BSXNSTI             GET TRIP INDICATOR
         $EOR  BSXNCN1             REVERSE IT'S SETTING
         $STO  BSXNSTI             SAVE IT FOR NEXT TRIP
         $BNZ  BSXFLPX             EXIT TO FLIP 1 FIRST TIME
         $LD   BSXXCNT             GET DATA TRANSFER COUNT
         $A    BSXSTCN             ADD SYNC TIME CONSTANT
         $STO  BSXSTCT             SET FOR NEXT SYNC TIME
         $B    BSXFLPX,,L          GO TO EXIT
***********************************************************************
*              LOCAL COMMANDS,STORAGE,FLAGS AND WHAT ELSE...          *
***********************************************************************
         $BSS  0,E
BSXISIX  DC    AL1($SYN,0)         SYNC/IDLE SEQUENCE...DLE OR SYN
         DC    AL1($SYN,0)         SECOND HALF OF SYNC/IDLE SEQUENCE
BSXTRL1  DC    AL1($SYN,0)         TRAILER SEQUENCE...DLE OR SYN
BSXTRL2  DC    AL1($ETB,0)         SECOND HALF OF TRAILER SEQUENCE
BSXWSAQ  DC    AL1($SOH,0,$ENQ,0)  SOH-ENQ SEQUENCE
BSXNENQ  DC    AL1($ENQ,0)         ENQ CONSTANT
BSXNCN1  DC    AL2(1)              CONSTANT 1
BSXSTCN  DC    AL2(*-*)            SYNC TIME CONSTANT
BSXSTCT  DC    AL2(*-*)            SYNC TIME COUNTER
***********************************************************************
*              WRITE SOH-ENQ AND TERMINATE                            *
***********************************************************************
BSXNWSQ  $NULL
         $LDD  BSXWSAQ             GET SOH-ENQ SEQUENCE
         $BSI  BSXWRXC             WRITE SOH, THEN ENQ
         $RTE  16                  REVERSE SOH-ENQ
         $STD  BSXWSAQ             STORE FOR NEXT PASS
         $EOR  BSXNENQ             TEST FOR ENQ NEXT
         $BZ   BSXFLPX             YES. EXIT FOR NEXT PASS
         $B    BSXWSPF             GO TERMINATE OPERATION
***********************************************************************
*              WRITE PROCESS MONITOR                                  *
***********************************************************************
BSXNWOK  $AXT  *-*,WA,L            GET SELECTED PROCESS INDEX
         $B    BSXNWPR,WA,I        GO TO SELECTED PROCESS
***********************************************************************
*              WRITE INITIAL SYN SEQUENCE                             *
***********************************************************************
BSXNINS  $NULL
         $LD   BSXISYN             GET A SYN CHARACTER
         $BSI  BSXWRXC             GO WRITE IT
BSXWHAT  $AXT  *-*,WA,L            PROCESS SELECTED BY BSXIOS
         $MDM  BSXISCT,-1          DECREMENT AND TEST SYN COUNT
         $AXT  BSXWPR0,WA,X        NOT DONE. RESET PROCESS TO 0
BSXWXIT  $STX  BSXNWOK+D1,WA       STORE PROCESS INDEX
         $B    BSXFLPX             GO TO EXIT
BSXISYN  DC    AL1($SYN,0)         SYN CHARACTER
***********************************************************************
*              WRITE NORMAL TEXT HEADER                               *
***********************************************************************
BSXNWHN  $NULL
         $LDD  BSXIHIX             GET HEADER SEQUENCE (SOH-STX)
         $BSI  BSXWRXC             WRITE SOH, THEN STX
         $RTE  16                  REVERSE SOH-STX
         $STD  BSXIHIX             STORE FOR NEXT PASS
         $EOR  BSXNSTX             TEST FOR STX NEXT
         $BZ   BSXFLPX             YES. EXIT FOR NEXT PASS
         $LD   BSXNSTX             NO. ALL DONE. GET STX
         $TSL  BSXNBCC             CALCULATE BCC
         $XIO  BSXNLDS             LOAD SYNC/IDLE REGISTER WITH SYN
BSXNWSI  $AXT  BSXWPR7,WA,X        GET DATA MONITORING INDEX
         $B    BSXWXIT             GO TO EXIT PROCEDURE
         $BSS  0,E
BSXNLDS  $ADCON (BSXISYN)          LOAD SYNC/IDLE WITH SYN
         DC    AL2($SCALOW+$WRITE+4)
BSXIHIX  DC    AL1($SOH,0,$STX,0)  SOH-STX SEQUENCE
BSXNSTX  DC    AL1($STX,0)         STX CONSTANT
         EJECT
***********************************************************************
*              WRITE TRANSPARENT TEXT HEADER (DLE-STX)                *
***********************************************************************
BSXNWHT  $NULL
         $LDD  BSXWTHD             GET HEADER SEQUENCE (DLE-STX)
         $BSI  BSXWRXC             WRITE DLE, THEN STX
         $RTE  16                  REVERSE DLE-STX
         $STD  BSXWTHD             STORE FOR NEXT PASS
         $EOR  BSXNSTX             TEST FOR STX NEXT
         $BZ   BSXFLPX             YES. EXIT FOR NEXT PASS
         $XIO  BSXPSID             NO. LOAD SYNC/IDLE WITH DLE
         $B    BSXNWSI             EXIT
         $BSS  0,E
BSXWTHD  DC    AL1($DLE,0,$STX,0)  DLE-STX SEQUENCE
BSXPSID  $ADCON (BSXWTHD)          LOAD SYNC/IDLE WITH DLE
         DC    AL2($SCALOW+$WRITE+4)
BSXWDAK  DC    AL1($DLE,0,$ACK0,0) DLE-ACK0 SEQUENCE
BSXNAKO  DC    AL1($ACK0,0)        ACK0 CONSTANT
***********************************************************************
*              WRITE DLE-ACK0 AND TERMINATE                           *
***********************************************************************
BSXNWDA  $NULL
         $LDD  BSXWDAK             GET DLE-ACK0 SEQUENCE
         $BSI  BSXWRXC             WRITE DLE, THEN ACK0
         $RTE  16                  REVERSE DLE-ACK0
         $STD  BSXWDAK             STORE FOR NEXT PASS
         $EOR  BSXNAKO             TEST FOR ACK0 NEXT
         $BZ   BSXFLPX             YES. EXIT FOR NEXT PASS
BSXWSPF  $AXT  BSXWPR6,WA,X        GET TERMINATION INDEX
         $B    BSXWXIT             GO TO EXIT
***********************************************************************
*              WRITE NAK AND TERMINATE                                *
***********************************************************************
BSXNNAK  $NULL
         $LD   BSXWNAK             GET A NAK
         $BSI  BSXWRXC             GO WRITE IT
         $B    BSXWSPF             GO TERMINATE OPERATION
BSXWNAK  DC    AL1($NAK,0)         NAK CONSTANT
***********************************************************************
*              WRITE TERMINATION MACHINATIONS                         *
***********************************************************************
BSXNXXT  $AXT  *-*,WA,L            SET WA TO PROCESS INDEX
         $B    BSXCNTL,WA,L        GO TO SELECTED PROCESS         0
BSXCNTL  $B    BSXNTR1             WRITE FIRST TRAILER CHARACTER  1
         $B    BSXNTR2             WRITE SECOND TRAILER CHARACTER 2
         $B    BSXNBC1             WRITE FIRST BCC CHARACTER      3
         $B    BSXNBC2             WRITE SECOND BCC CHARACTER     4
         $B    BSXNPDO             WRITE PAD CHARACTER-TERMINATE  5
         EJECT
***********************************************************************
*              WRITE FIRST TRAILER BSC CHARACTER                      *
***********************************************************************
BSXNTR1  $LD   BSXTRL1             GET FIRST TRAILER CHARACTER
         $BSI  BSXWRXC             GO TO WRITE ROUTINE
         $B    BSXNSEQ             SET SEQUENCE FOR 2ND TRAILER
***********************************************************************
*              WRITE SECOND TRAILER BSC CHARACTER                     *
***********************************************************************
BSXNTR2  $LD   BSXTRL2             GET SECOND TRAILER CHARACTER
         $BSI  BSXWRXC             GO TO WRITE ROUTINE
         $TSL  BSXNBCC             GO CALCULATE BCC
BSXNSEQ  $MDX  1,WA                STEP TO NEXT SEQUENCE
         $STX  BSXNXXT+D1,WA       STORE SEQUENCE INDEX
         $B    BSXFLPX             GO TO EXIT
***********************************************************************
*              WRITE FIRST BCC (CRC-16) CHARACTER                     *
***********************************************************************
BSXNBC1  $LD   BSXBCCA,,L          GET BCC WORD ACCUMULATED
BSXNBSQ  $SLA  8                   REVERSE ORDER
         $BSI  BSXWRXC             GO WRITE CHARACTER
         $B    BSXNSEQ             SET SEQUENCE FOR 2ND BCC
***********************************************************************
*              WRITE SECOND BCC(CRC-16) CHARACTER                     *
***********************************************************************
BSXNBC2  $LD   BSXBCCA,,L          GET BCC WORD ACCUMULATED
         $SRA  8                   CLEAR LOW ORDER BYTE
         $B    BSXNBSQ             GO WRITE IT
***********************************************************************
*              WRITE TERMINATION PROCESS                              *
***********************************************************************
BSXNPDO  $LD   BSXNPCN             GET PAD CHARACTER
         $BSI  BSXWRXC             GO WRITE IT
         $AXT  BSXOWF1,WA,X        FLAG WRITE COMPLETED
         $B    BSXREND,,L          GO TERMINATE SCA OPERATION
BSXNPCN  DC    AL1($PAD,0)         PAD CHARACTER
***********************************************************************
*              WRITE SPECIFIED DATA TO SCA                            *
***********************************************************************
BSXWRXC  DC    AL2(*-*)            ENTRY VIA $BSI BSXWRXC
         $STO  BSXWTMP             STORE DATA CHARACTER
         $XIO  BSXWWRS             WRITE IT
         $LD   BSXWTMP             RESTORE INPUT
         $B    BSXWRXC,,I          RETURN TO CALLER
         $BSS  0,E
BSXWWRS  $ADCON BSXWTMP            DATA POINTER
         DC    AL2($SCALOW+$WRITE) WRITE COMMAND
BSXWTMP  DC    AL2(*-*)            DATA STORAGE
         EJECT
***********************************************************************
*              COMMON EXIT FOR INTERRUPT PROCESSORS                   *
***********************************************************************
BSXFLPX  $NULL
         AIF   (&DEBUG EQ 0).NODBUGB
         $TSL  DBUGSCAL            GO TRACE THIS INTERRUPT
.NODBUGB ANOP
BSXSVWA  $AXT  *-*,WA,L            RESTORE WA
         $B    RTPL1RTN,,L         EXIT TO FLIP 1
         EJECT
***********************************************************************
*              PUT DATA INTO USER BUFFER                              *
***********************************************************************
BSXRCN1  DC    AL2(1)              CONSTANT 1
BSXRCNT  DC    AL2(*-*)            DATA READ COUNT
BSXRPLR  DC    AL2(*-*)            LEFT/RIGHT INDICATOR
BSXRPUT  DC    AL2(*-*)            ENTRY POINT
         $LD   BSXICNT,,L          GET REQUESTED INPUT COUNT
         $EOR  BSXRCNT             COMPARE WITH CURRENT
         $BZ   BSXRPXT             BRANCH IF EQUAL
         $STX  BSXRPSA+D1,WA       SAVE CONTENTS OF WA
         $LXA  BSXDTAD,WA,L        ADDRESS OF TARGET WORD
         $LD   BSXRPLR             GET LEFT/RIGHT INDICATOR
         $SKPN                     SKIP IF CONSTRUCTION UNDERWAY
         $STO  0,WA                OTHERWISE, CLEAR TARGET WORD
         $LD   BSXRNPT             GET DATA TO BE INSERTED
         $MDM  BSXRPLR,0           TEST LEFT/RIGHT SWITCH
         $SRA  8                   MOVE LEFT TO RIGHT
         $OR   0,WA                FORM DATA WORD
         $STO  0,WA                STORE IN TARGET WORD
         $LD   BSXRPLR             GET LEFT/RIGHT INDICATOR
         $SKPZ                     SKIP IF WORD UNDER CONSTRUCTION
         $MDX  1,WA                POINT TO NEXT WORD
         $STX  BSXDTAD,WA,L        SAVE POINTER FOR NEXT TRIP
         $EOR  BSXRCN1             REVERSE LEFT/RIGHT SWITCH
         $STO  BSXRPLR             PUT IT BACK
         $MDM  BSXRCNT,1           INCREMENT DATA COUNT
         $LD   BSXRNPT             GET DATA VALUE
BSXRPSA  $AXT  *-*,WA,L            RESTORE REGISTER WA
         $B    BSXRPUT,,I          RETURN TO CALLER
BSXRPXT  $AXT  BSXORF2,WA,X        GET COMPLETION CODE
         $B    BSXREND             END READ OPERATION
***********************************************************************
*              PROCESS FIRST BCC CHARACTER                            *
***********************************************************************
BSXRBBO  $NULL
         $LD   BSXRNPT             GET FIRST BCC CHARACTER
         $SRA  8                   REVERSE ORDER FOR COMPARE
         $STO  BSXBCCS             SAVE IT
         $AXT  BSXRPR8,WA,X        SET PROCESS 8 INDEX
         $B    BSXRINX             EXIT FOR SECOND BCC
***********************************************************************
*              PROCESS SECOND BCC CHARACTER                           *
***********************************************************************
BSXRBBT  $NULL
         $LD   BSXRNPT             GET SECOND BCC CHARACTER
         $OR   BSXBCCS             FORM COMPLETE BCC VALUE
         $EOR  BSXBCCA             COMPARE WITH CALCULATED BCC
         $AXT  BSXORF1,WA,X        ASSUME NO ERROR
         $SKPZ                     SKIP IF NO ERROR
         $AXT  BSXORF5,WA,X        GET ERROR COMPLETION CODE
         $LD   BSXRCNT             GET COUNT OF DATA READ
BSXIOAR  $STO  *-*,,L              STORE IT IN BUFFER COUNT WORD
         $B    BSXREND             TERMINATE
BSXBCCS  DC    AL2(*-*)
         EJECT
***********************************************************************
*              READ RESPONSE PROCESSOR                                *
***********************************************************************
BSXNRDR  $NULL
         $SLA  3                   GET TIMEOUT BIT AND
         $BN   BSXNTMR             BRANCH IF TIMEOUT
         $XIO  BSXREAD             READ DATA INTO BSXRNPT
BSXRSEQ  $AXT  *-*,WA,L            SEQUENCE INDEX TO WA
         $LD   BSXRNPT             GET INPUT CHARACTER
         $B    BSXRSSQ,WA,I        GO TO SELECTED PROCESS
***********************************************************************
*              LOCAL CONSTANTS,COMMANDS,ETC.                          *
***********************************************************************
         $BSS  0,E
BSXREAD  $ADCON BSXRNPT            ADDRESS OF INPUT STORAGE
         DC    AL2($SCALOW+$READ)  READ COMMAND
BSXRNPT  DC    AL2(*-*)            INPUT DATA STORAGE
BSXIEND  DC    AL2($SCALOW+$CONTROL+4) END SCA OPERATION
***********************************************************************
*              CHECK FOR PAD CHARACTER FOLLOWING NAK OR ENQ           *
***********************************************************************
BSXRPCK  $EOR  BSXRPAD             TEST FOR PAD CHARACTER
BSXRXVX  $AXT  *-*,WA,L            SET BY NAK OR ENQ PROCESSOR
         $SKPZ                     SKIP IF PAD CHARACTER FOUND
         $NOP                      CHANGE TO '$AXT BSXORFD,WA,X'
*                                  IF PAD CHECKING DESIRED
         $B    BSXREND             GO TO FINAL EXIT PROCESS
BSXRPAD  DC    AL1($PAD,0)         A PAD CHARACTER
         EJECT
***********************************************************************
*              TEST INITIAL DATA RECEIVED                             *
***********************************************************************
BSXRMON  $BSI  BSXRPUT             GO PUT INPUT IN I/O AREA
         $S    BSXRCNS             TEST FOR SOH
         $BZ   BSXRSOH             BRANCH IF SOH
         $S    BSXRCND             TEST FOR DLE
         $BZ   BSXRDLE             BRANCH IF DLE
         $S    BSXRCNQ             TEST FOR ENQ
         $BZ   BSXRENQ             BRANCH IF ENQ
         $EOR  BSXRCNN             TEST FOR NAK
BSXRBAD  $AXT  BSXORF8,WA,X        ASSUME IT IS NOT NAK
         $BNZ  BSXREND             BRANCH IF NOT NAK
***********************************************************************
*              NAK RECEIVED FROM BIG BROTHER                          *
***********************************************************************
         $AXT  BSXORF9,WA,X        GET NAK COMPLETION CODE
         $B    BSXRPSS             GO SETUP FOR PAD CHECKER
***********************************************************************
*              TERMINATE SCA OPERATION...SET COMPLETION CODE          *
***********************************************************************
BSXREND  $XIO  BSXIEND-D1          STOP SCA OPERATION
         $STX  BSXOPF,WA,I         SET APPROPRIATE STATUS WORD
         AIF   (&DEBUG EQ 0).NOSCDBA
         $TSL  DBUGSCAL            GO TRACE SCA INTERRUPT
.NOSCDBA ANOP
         $LD   BSXIOPT,,L          GET OPERATION TYPE AND
BSXWRAP  $BSI  *-*,,L,Z             ENTER APPENDAGE IF WRITE
         $B    BSXSVWA               OTHERWISE, GO TO EXIT...
BSXRCNS  DC    AL1($SOH,0)         SOH TEST VALUE
BSXRCND  DC    AL1($DLE-$SOH,0)    DLE TEST VALUE
BSXRCNQ  DC    AL1($ENQ-$SOH-($DLE-$SOH),0) ENQ TEST VALUE
BSXRCNN  DC    AL1($NAK-$SOH-($DLE-$SOH)-($ENQ-$SOH-($DLE-$SOH)),0) NAK
BSXBCCA  DC    AL2(*-*)            ACCUMULATED BCC (CRC-16)
***********************************************************************
*              SOH FOUND AS FIRST CHARACTER                           *
***********************************************************************
BSXRSOH  $NULL
         $AXT  BSXRPR1,WA,X        GET SEQUENCE INDEX
BSXRINX  $STX  BSXRSEQ+D1,WA       TO GO TO SELECTED PROCESS
         $B    BSXFLPX             GO TO EXIT PROCEDURE
***********************************************************************
*              DLE FOUND AS FIRST CHARACTER                           *
***********************************************************************
BSXRDLE  $NULL
         $AXT  BSXRPR2,WA,X        SET FOR PROCESS 2
         $B    BSXRINX             EXIT
***********************************************************************
*              ENQ FOUND AS FIRST CHARACTER                           *
***********************************************************************
BSXRENQ  $NULL
         $AXT  BSXORFC,WA,X        GET ENQ COMPLETION CODE
BSXRPSS  $STX  BSXRXVX+D1,WA       STORE IT FOR PAD CHECKER
         $AXT  BSXRPR9,WA,X        PAD CHECKER SEQUENCE INDEX
         $B    BSXRINX             GO SET SEQUENCE AND EXIT
         EJECT
***********************************************************************
*              LOOK FOR STX FOLLOWING SOH                             *
***********************************************************************
BSXRSHS  $EOR  BSXRSTX             TEST FOR STX
         $BNZ  BSXRBAD             STX NOT FOUND
         $STO  BSXTFLG             SET NORMAL TEXT INDICATOR
         $AXT  BSXRPR3,WA,X        GET PROCESS 3 INDEX
BSXRCMP  $BSI  BSXRPUT             PUT INPUT IN BUFFER
         $TSL  BSXNBCC             GO CALCULATE BCC
         $B    BSXRINX             EXIT
BSXRSTX  DC    AL1($STX,0)         STX CONSTANT
BSXTFLG  DC    AL2(*-*)            READ TEXT MODE FLAG
***********************************************************************
*              LOOK FOR STX OR ACK0 FOLLOWING DLE                     *
***********************************************************************
BSXRDHS  $S    BSXRSTX             TEST FOR STX
         $BZ   BSXRSXI             BRANCH IF STX
         $S    BSXRCAO             TEST FOR ACK0
         $BNZ  BSXRBAD             BRANCH IF NOT ACK0
         $TSL  BSXRPUT             PUT ACK0 IN BUFFER
         $AXT  BSXORFA,WA,X        GET DLE-ACK0 CODE
         $B    BSXREND             EXIT
BSXRSXI  $STL  BSXTFLG             FLAG TRANSPARENT DATA
         $AXT  BSXRPR4,WA,X        GET PROCESS 4 INDEX
         $TSL  BSXRPUT             PUT STX IN BUFFER
         $B    BSXRINX             GO SETUP TEXT MONITOR
BSXRCAO  DC    AL1($ACK0-$STX,0)   ACK0 TEST VALUE
***********************************************************************
*              NORMAL TEXT PROCESSOR..MONITOR SYN'S                   *
***********************************************************************
BSXRNRM  $NULL
         $EOR  BSXRSYN             TEST FOR SYN
         $BZ   BSXRSHV             BRANCH IF SYN
BSXRDTX  $TSL  BSXRPUT             GO PUT DATA IN BUFFER
         $BSI  BSXNBCC             GO CALCULATE BCC
         $B    BSXFLPX,,L          EXIT TO FLIP 1
BSXRSHV  $AXT  BSXRPR5,WA,X        GET PROCESS 5 INDEX
         $B    BSXRINX             GO TO EXIT
BSXRSYN  DC    AL1($SYN,0)         SYN TEST VALUE
         EJECT
***********************************************************************
*              TRANSPARENT TEXT PROCESSOR..MONITOR DLE'S              *
***********************************************************************
BSXRTRN  $EOR  BSXRDLL             TEST FOR DLE
         $BNZ  BSXRDTX             BRANCH IF NOT DLE
         $AXT  BSXRPR6,WA,X        GET PROCESS 6 INDEX
         $B    BSXRINX             GO TO EXIT
***********************************************************************
*              SYN FOUND. LOOK FOR ETB NEXT                           *
***********************************************************************
BSXRNET  $S    BSXRSYN             TEST FOR ANOTHER SYN FIRST
         $BZ   BSXRSNK             GO RESTART READ TIMER IF SYN
         $EOR  BSXRSEB             TEST FOR ETB
         $AXT  BSXRPR3,WA,X        ASSUME NOT ETB
         $SKPN                     SKIP IF NOT ETB
         $AXT  BSXRPR7,WA,X        SET FOR BCC PROCESS
         $B    BSXRCMP             GO PUT AND CALCULATE,ETC.
BSXRDLL  DC    AL1($DLE,0)         DLE TEST VALUE
BSXREMD  DC    AL1($ETB-$DLE,0)    ETB TEST VALUE
BSXREDS  DC    AL1($SYN-$DLE-($ETB-$DLE),0) SYN TEST VALUE
BSXRSEB  DC    AL1($ETB-$SYN,0)    ETB TEST VALUE
***********************************************************************
*              DLE FOUND..LOOK FOR ETB NEXT                           *
***********************************************************************
BSXRTET  $AXT  BSXRPR4,WA,X        ASSUME INPUT IS ANOTHER DLE
         $S    BSXRDLL             TEST FOR DLE
         $BZ   BSXRCMP             BRANCH IF DLE TO DATA PROCEDURE
         $AXT  BSXRPR7,WA,X        ASSUME INPUT IS AN ETB
         $S    BSXREMD             TEST FOR ETB
         $BZ   BSXRCMP             BRANCH IF ETB TO DATA PROCEDURE
         $AXT  BSXRPR4,WA,X        ASSUME INPUT IS A SYN
         $EOR  BSXREDS             TEST FOR SYN
         $BZ   BSXRSNK             GO RESTART READ TIMER IF SYN
         $AXT  BSXORFB,WA,X        GET COMPLETION CODE
         $B    BSXREND             TERMINATE
***********************************************************************
*              RESTART READ TIMER AFTER SYNC/IDLE SEQUENCE            *
***********************************************************************
BSXRSNK  $XIO  BSXITME-D1,,L       ISSUE START TIMER COMMAND
         $B    BSXRINX             GO TO EXIT
         EJECT
***********************************************************************
*              CALCULATE BLOCK CHECK CHARACTER ALIAS CRC-16           *
***********************************************************************
BSXNBCC  DC    AL2(*-*)            ENTRY WITH CHARACTER IN HIGH AC
         $SRA  8                   PUT IT IN LOW AC BYTE
         $EOR  BSXBCCA             ADD IN REMAINDER
         $BOD  BSXEOR1             BRANCH IF ONE
         $SRA  1
BSXNB2   $BOD  BSXEOR2             BRANCH IF ONE
         $SRA  1
BSXNB3   $BOD  BSXEOR3             ETC
         $SRA  1
BSXNB4   $BOD  BSXEOR4             ETC
         $SRA  1
BSXNB5   $BOD  BSXEOR5             ETC
         $SRA  1
BSXNB6   $BOD  BSXEOR6             ETC
         $SRA  1
BSXNB7   $BOD  BSXEOR7             ETC
         $SRA  1
BSXNB8   $BOD  BSXEOR8             ETC
         $SRA  1
BSXNB9   $STO  BSXBCCA             STORE NEW REMAINDER
         $B    BSXNBCC,,I          EXIT
BSXEOR1  $SRA  1
         $EOR  BSXPOLY             ADD POLYNOMIAL
         $B    BSXNB2              TEST NEXT BIT
BSXEOR2  $SRA  1
         $EOR  BSXPOLY             ETC
         $B    BSXNB3
BSXEOR3  $SRA  1
         $EOR  BSXPOLY             ETC
         $B    BSXNB4
BSXEOR4  $SRA  1
         $EOR  BSXPOLY             ETC
         $B    BSXNB5
BSXEOR5  $SRA  1
         $EOR  BSXPOLY             ETC
         $B    BSXNB6
BSXEOR6  $SRA  1
         $EOR  BSXPOLY             ETC
         $B    BSXNB7
BSXEOR7  $SRA  1
         $EOR  BSXPOLY             ETC
         $B    BSXNB8
BSXEOR8  $SRA  1
         $EOR  BSXPOLY             ETC
         $B    BSXNB9
BSXPOLY  DC    X'A001'             POLYNOMIAL FOR CRC-16
         EJECT
***********************************************************************
*              TIMEOUT PROCESSOR                                      *
***********************************************************************
BSXNTMO  $NULL
         $SLA  2                   GET DSW TIMEOUT BIT
         $BNN  BSXNTXX             BRANCH IF NOT TIMEOUT
         $MDM  BSXIOPT,0           TEST OPERATION TYPE
         $B    BSXNTWT             BRANCH IF WRITE OR TIMER FUNCTION
BSXNTMR  $MDM  $ERRSCRT,1          INCREMENT TIMEOUT COUNTER
         $AXT  BSXORF3,WA,X        ASSUME INITIAL READ SEQUENCE
         $MDM  BSXRSEQ+D1,0        TEST FOR INITIAL READ PROCESS
         $AXT  BSXORF4,WA,X        NOT INITIAL READ PROCESS
BSXNTGO  $B    BSXREND,,L          GO TERMINATE SCA OPERATION
BSXNTXX  $MDM  $ERRSCXX,1          COUNT UNIDENTIFIED INTERRUPTS
BSXNTXF  $B    BSXFLPX,,L          EXIT TO FLIP 1
BSXNTWT  $AXT  BSXOWF3,WA,X        WRITE TIMEOUT OR TIMER CODE
         $MDM  BSXWHAT+D1,0        TEST FOR TIMER FUNCTION
         $B    BSXNTOW             BRANCH IF WRITE TIMEOUT
         $XIO  BSXISPT-D1,,L       START THE PROGRAM TIMER
         $MDM  BSXICNT,-1          DECREMENT AND TEST INTERVAL
         $B    BSXNTXF             BRANCH IF MORE INTERVALS
         $B    BSXNTGO             OR TERMINATE SCA OPERATION
BSXNTOW  $MDM  $ERRSCTT,1          COUNT WRITE TIMEOUTS
         $B    BSXNTGO             AND TERMINATE SCA OPERATION
***********************************************************************
*              DATA SET NOT READY AT INTERRUPT TIME                   *
***********************************************************************
BSXNRDY  $NULL
         $AXT  BSXORF7,WA,X        ASSUME RECEIVE (READ) MODE
         $MDM  BSXIOPT,0           TEST OPERATION MODE
         $AXT  BSXOWF2,WA,X        TRANSMIT (WRITE) MODE
         $B    BSXNTGO             START EXODUS
         TITLE 'RTP1130 (COMMUTATOR)'
***********************************************************************
*              COMMANDS AND STORAGE FOR CONSOLE KEY INPUT             *
***********************************************************************
         $BSS  0,E
CONKREAD $ADCON (CONKDATA)         IOCC TO READ CONSOLE SWITCHES
         DC    AL2($SWITCH+$READ)
CONKDATA DC    AL2(*-*)            STORAGE FOR SWITCHES
SENTKEYS DC    AL2($KEY01)         SYMBOLIC KEY SETTING
***********************************************************************
*              COMMUTATOR START                                       *
***********************************************************************
UNLATCH  $NOP                      INSTRUCTION TO OPEN GATES
SCOMSTRT $NULL
         $XIO  CONKREAD            READ CONSOLE SWITCHES
         $LD   CONKDATA            GET VALUE READ
         $BSC  P+Z                 SKIP IF KEY 0 OFF
         $STO  SENTKEYS            SET SYMBOLIC KEYS
         SPACE 1
***********************************************************************
*              COMMUTATOR DEFINITION FOR SCA I/O PROCESSOR            *
***********************************************************************
TPIOXGT  $B    TPIOXEC             COMMUTATOR GATE
TPIOXWA  $AXT  *-*,WA,L            RESTORE WA
         $B    TPIOXEP,,L          GO TO ROUTINE ENTRY
TPIOXRT  $STX  TPIOXWA+D1,WA       SAVE WA
TPIOXEC  $NULL                     END OF COMMUTATOR ENTRY
         SPACE 3
***********************************************************************
*              COMMUTATOR DEFINITION FOR INPUT BUFFER PROCESSOR       *
***********************************************************************
TPGETGT  $B    TPGETEC             COMMUTATOR GATE
TPGETWA  $AXT  *-*,WA,L            RESTORE WA
TPGETWC  $AXT  *-*,WC,L            RESTORE WC
         $B    TPGETEP,,L          GO TO ROUTINE ENTRY
TPGETRT  $STX  TPGETWA+D1,WA       SAVE WA
         $STX  TPGETWC+D1,WC       SAVE WC
TPGETEC  $NULL                     END OF TPGET COMMUTATOR ENTRY
         SPACE 3
***********************************************************************
*              COMMUTATOR DEFINITION FOR OUTPUT BUFFER PROCESSOR      *
***********************************************************************
TPPUTGT  $B    TPPUTEC             COMMUTATOR GATE
TPPUTWA  $AXT  *-*,WA,L            RESTORE WA
TPPUTWB  $AXT  *-*,WB,L            RESTORE WB
TPPUTWC  $AXT  *-*,WC,L            RESTORE WC
         $B    TPPUTEP,,L          GO TO ROUTINE ENTRY
TPPUTRT  $STX  TPPUTWA+D1,WA       SAVE WA
         $STX  TPPUTWB+D1,WB       SAVE WB
         $STX  TPPUTWC+D1,WC       SAVE WC
TPPUTEC  $NULL                     END OF TPPUT COMMUTATOR ENTRY
         EJECT
         AIF   (&PR1132 EQ 0).NO1132A
***********************************************************************
*              COMMUTATOR DEFINITION FOR 1132 PRINTER                 *
***********************************************************************
PRETTGT  $B    PRETTEC             COMMUTATOR GATE
PRETTWA  $AXT  *-*,WA,L            RESTORE WA
PRETTWB  $AXT  *-*,WB,L            RESTORE WB
         $B    PRETTEP,,L          GO TO MAIN ROUTINE ENTRY
PRETTRT  $STX  PRETTWA+D1,WA       SAVE WA
         $STX  PRETTWB+D1,WB       SAVE WB
PRETTEC  $NULL                     END OF 1132 COMMUTATOR ENTRY
.NO1132A ANOP
         SPACE 3
         AIF   (NOT &XX1442).NO1442A
***********************************************************************
*              COMMUTATOR DEFINITION FOR 1442 READ/PUNCH              *
***********************************************************************
RPFFTGT  $B    RPFFTEC             COMMUTATOR GATE
         $B    RPFFTEP,,L          GO TO MAIN ROUTINE
RPFFTRT  $NULL                     RETURN FROM MAIN ROUTINE
RPFFTEC  $NULL                     END OF 1442 COMMUTATOR ENTRY
.NO1442A ANOP
         SPACE 3
         AIF   (&PR1403 EQ 0).NO1403B
***********************************************************************
*              COMMUTATOR DEFINITION FOR 1403 PRINTER                 *
***********************************************************************
PRFOTGT  $B    PRFOTEC             COMMUTATOR GATE
PRFOTWA  $AXT  *-*,WA,L            RESTORE WA
         $B    PRFOTEP,,L          GO TO MAIN ROUTINE ENTRY
PRFOTRT  $STX  PRFOTWA+D1,WA       SAVE WA
PRFOTEC  $NULL                     END OF 1403 COMMUTATOR ENTRY
.NO1403B ANOP
         SPACE 3
         EJECT
         AIF   (&RD2501 EQ 0).NO2501A
***********************************************************************
*              COMMUTATOR DEFINITION FOR 2501 CARD READER             *
***********************************************************************
RDTFOGT  $B    RDTFOEC             COMMUTATOR GATE
         $B    RDTFOEP,,L          GO TO ROUTINE MAIN ENTRY
RDTFORT  $NULL                     RETURN POINT FROM ROUTINE
RDTFOEC  $NULL                     END OF 2501 COMMUTATOR ENTRY
.NO2501A ANOP
         SPACE 3
***********************************************************************
*              COMMUTATOR DEFINITION FOR CONSOLE KB/PRINTER           *
***********************************************************************
CONSLGT  $B    CONSLEC             COMMUTATOR GATE
CONSLWA  $AXT  *-*,WA,L            RESTORE WA
         $B    CONSLEP,,L          GO TO MAIN ROUTINE ENTRY
CONSLRT  $STX  CONSLWA+D1,WA       SAVE WA
CONSLEC  $NULL                     END OF CONSOLE COMMUTATOR ENTRY
         AIF   (NOT &RP1442).NO1442P
         SPACE 3
***********************************************************************
*              COMMUTATOR DEFINITION FOR READER/PUNCH CONTROL         *
***********************************************************************
RPCNTGT  $B    RPCNTEC             COMMUTATOR GATE
         $B    RPCNTEP,,L          BRANCH TO MAIN ROUTINE
RPCNTRT  $NULL                     RETURN FROM MAIN ROUTINE
RPCNTEC  $NULL                     END OF COMMUTATOR ENTRY
.NO1442P ANOP
         SPACE 3
SCOMSTOP $B    RTPETIN,,L          CHANGED TO '$B $COMSTRT' BY
*                                  INITIALIZATION PROCESS
         TITLE 'RTP1130 (FIRST LEVEL INTERRUPT PROCESSORS)'
         SPACE 3
***********************************************************************
*              LEVEL 0 - 1442 CARD READ/PUNCH                         *
***********************************************************************
         AIF   (NOT &XX1442).NO1442F
***********************************************************************
*                                                                     *
*              FLIP 0 (FIRST LEVEL INTERRUPT PROCESSOR - LEVEL 0      *
*                                                                     *
*              SAVES AND RESTORES AC, STATUS ONLY.                    *
*              PASSES CONTROL TO 1442 SECOND LEVEL INTERRUPT          *
*              PROCESSOR DIRECTLY SINCE NO OTHER DEVICES CAUSE        *
*              LEVEL 0 INTERRUPTS.                                    *
*                                                                     *
***********************************************************************
.NO1442F ANOP
RTPLLVL0 DC    H'0'                ENTRY VIA HARDWARE $BSI 8,,I
         AIF   (NOT &XX1442).NO1442G
         $STO  RTPL0SVA            SAVE AC
         $STS  RTPL0STS            SAVE STATUS
         $B    RPCOLINT,,L         GO TO COLUMN INTERRUPT ROUTINE
RTPL0SVA DC    H'0'                AC SAVE AREA
RTPL0RTN $NULL                     RETURN FROM COLUMN INTERRUPT ROUTINE
RTPL0STS $LDS  0                   RESTORE STATUS
         $LD   RTPL0SVA            RESTORE AC
.NO1442G ANOP
         $BOSC RTPLLVL0,,I         RETURN
         EJECT
***********************************************************************
*              LEVEL 1 - SCA AND 1132 PRINTER                         *
***********************************************************************
RTPLLVL1 DC    H'0'                ENTRY VIA HARDWARE $BSI 9,,I
***********************************************************************
*                                                                     *
*              FLIP 1 (FIRST LEVEL INTERRUPT PROCESSOR - LEVEL 1)     *
*                                                                     *
*              SAVES AND RESTORES AC/EXT AND STATUS.  ADDITIONAL      *
*              SAVE/RESTORE PROCEDURES ARE THE RESPONSIBILITY OF      *
*              THE INDIVIDUAL SECOND LEVEL INTERRUPT PROCESSORS       *
*                                                                     *
*              CONTROL IS PASSED TO THE SCA OR 1132 SLIP (IF THE      *
*              1132 EXISTS) DEPENDING ON THE ILSW.                    *
*                                                                     *
***********************************************************************
         $STD  RTPL1SVA            SAVE AC AND EXT
         $STS  RTPL1STS            AND STATUS
         AIF   (&PR1132 EQ 0).NO1132E
         $XIO  RTPL1SIL-D1         GET ILSW
         $BN   PRETTINT            BRANCH IF 1132 INTERRUPT
.NO1132E ANOP
         $B    BSCLOINT,,L         BRANCH TO SCA (LOW) SLIP
RTPL1SVA $BSS  2,E                 AC AND EXT SAVE
         AIF   (&PR1132 EQ 0).NO1132F
         DC    AL2(0)              FILLER
RTPL1SIL DC    AL2($SENSEI)        SENSE ILSW
.NO1132F ANOP
RTPL1RTN $NULL                     RETURN POINT FROM SLIP
RTPL1STS $LDS  0                   RESTORE STATUS
         $LDD  RTPL1SVA            AND AC AND EXT
         $BOSC RTPLLVL1,,I         RETURN
         SPACE 1
***********************************************************************
*              LEVEL 2 - DISK AND SAC                                 *
***********************************************************************
RTPLLVL2 DC    H'0'                ENTRY VIA HARDWARE $BSI 10,,I      *
         $BOSC RTPLLVL2,,I         IGNORE LEVEL 2 INTERRUPT
         SPACE 1
***********************************************************************
*              LEVEL 3 - 1627,2250 AND SAC                            *
***********************************************************************
RTPLLVL3 DC    H'0'                ENTRY VIA HARDWARE $BSI 11,,I
         $BOSC RTPLLVL3,,I         IGNORE LEVEL 3 INTERRUPT
         EJECT
***********************************************************************
*              LEVEL 4 - 1442,KB PRINTER,1134,1055,2501,1403,1231,SAC *
***********************************************************************
*                                                                     *
*              FLIP 4 (FIRST LEVEL INTERRUPT PROCESSOR - LEVEL 4)     *
*                                                                     *
*              SAVES AND RESTORES AC, STATUS AND WA ONLY              *
*              DETERMINES INTERRUPTING DEVICE AND PASSES              *
*              CONTROL TO THE SLIP DEFINED IN THE ATTACHED            *
*              SLIP LIST. NOTE...ADDITIONAL SAVE/RESTORE              *
*              PROCESSING IS THE RESPONSIBILITY OF THE SLIP.          *
*                                                                     *
***********************************************************************
         SPACE 3
RTPLLVL4 DC    H'0'                ENTRY VIA HARDWARE $BSI 12,,I
         $STO  RTPL4SVA            SAVE AC
         $STS  RTPL4STS            AND STATUS
         $STX  RTPL4SWA+D1,WA      AND WA
         $AXT  (RTPL4END-RTPL4SLV)/2,WA,X GET NUMBER OF SLIPS
         $XIO  RTPL4SIL-D1         SENSE ILSW
         $SLCA 0,WA                SET WA TO INDEX SLIP LIST
         $B    RTPL4SLV-D1,WA,I    GO TO PROPER SLIP
RTPL4RTN $NULL                     RETURN POINT FROM SLIP
RTPL4STS $LDS  0                   RESTORE STATUS
         $LD   RTPL4SVA            AND AC
RTPL4SWA $AXT  *-*,WA,L            AND WA
         $BOSC RTPLLVL4,,I         RETURN
***********************************************************************
*              FLIP 4 SAVE AREA AND COMMANDS                          *
***********************************************************************
         $BSS  0,E                 EVEN STORAGE ASSIGNMENT
RTPL4SVA $BSS  1                   AC SAVE
RTPL4SIL DC    AL2($SENSEI)        SENSE ILSW COMMAND
***********************************************************************
*              SECOND LEVEL INTERRUPT PROCESSOR (SLIP) LIST           *
***********************************************************************
         AIF   (&RD2501 NE 0).NO2501C
RDTFOINT EQU   RTPL4RTN
.NO2501C ANOP
         AIF   (&XX1442 EQ 1).NO1442J
RPFFTINT EQU   RTPL4RTN
.NO1442J ANOP
RTPL4SLV $NULL                     START OF SLIP LIST
         $ADCON RTPL4RTN           1231 OMPR SLIP ADDRESS
         AIF   (&PR1403 EQ 0).NO14O3A
         $ADCON (PRFOTINT)         1403 PRINTER SLIP ADDRESS
         AGO   .NO14O3B
.NO14O3A ANOP
         $ADCON (RTPL4RTN)         FILLER FOR 1403 SLIP
.NO14O3B ANOP
         AIF   (&RD2501 EQ 0).NO25O1A
         $ADCON (RDTFOINT)         2501 SLIP ADDRESS
         AGO   .NO25O1B
.NO25O1A ANOP
         $ADCON (RTPL4RTN)         FILLER FOR 2501 SLIP
.NO25O1B ANOP
         AIF   (NOT &XX1442).NT1442A
         $ADCON (RPFFTINT)         1442 SLIP ADDRESS
         AGO   .NT1442B
.NT1442A ANOP
         $ADCON (RTPL4RTN)         FILLER FOR 1442 SLIP
.NT1442B ANOP
         $ADCON CONSLINT           CONSOLE SLIP ADDRESS
         $ADCON RTPL4RTN           1134 PTR, 1055 PTP SLIP ADDRESS
RTPL4END $NULL                     END OF SLIP LIST
         EJECT
***********************************************************************
*              LEVEL 5 - CONSOLE STOP AND SAC                         *
***********************************************************************
RTPLLVL5 DC    H'0'                ENTRY VIA HARDWARE $BSI 13,,I
         $TSL  $WAIT               GO TO COMMON WAIT ROUTINE
         $BOSC RTPLLVL5,,I         RETURN
         TITLE 'RTP1130 (TPIOX-SCA I/O BUFFER PROCESSOR)'
***********************************************************************
*                                                                     *
* TITLE - TPIOX (SCA READ/WRITE COMMUTATOR CONTROL PROCESSOR)         *
*                                                                     *
* FUNCTION/PURPOSE                                                    *
*                                                                     *
*  CONTROLS THE TRANSMISSION OF DATA AND/OR CONTROL INFORMATION       *
*  BETWEEN HASP AND RTP1130 VIA THE SYNCHRONOUS COMMUNICATIONS        *
*  ADAPTER. ALL I/O IS INITIATED THRU AND PROCESSED BY THE SCA        *
*  SUBROUTINE BSXIOS.                                                 *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              TRANSFER VECTOR TABLE FOR SCA READ COMPLETION CODES    *
***********************************************************************
TPIOXRV  $NULL                     TABLE REFERENCE POINT    CODE
         $ADCON (TPIOXRT)          READ NOT COMPLETED         00
         $ADCON (TPIONRC)          NORMAL READ COMPLETE       01
         $ADCON (TPIONAK)          ABNORMAL READ COMPLETE     02
         $ADCON (TPIORTO)          RECEIVE TIMEOUT (INITIAL)  03
         $ADCON (TPIORTO)          RECEIVE TIMEOUT (DATA)     04
         $ADCON (TPIONAK)          BCC COMPARE ERROR          05
         $ADCON (TPIONAK)          DATA OVERRUN               06
         $ADCON (TPIORNR)          DATA SET NOT READY         07
         $ADCON (TPIONAK)          HEADER ERROR               08
         $ADCON (TPIOXDT)          NAK RECEIVED               09
         $ADCON (TPIOIWB)          ACKO RECEIVED              10
         $ADCON (TPIONAK)          SINGLE DLE RECEIVED        11
         $ADCON (TPIONAK)          ENQ RECEIVED               12
         $ADCON (TPIONAK)          PAD ERROR                  13
***********************************************************************
*              TRANSFER VECTOR TABLE FOR WRITE COMPLETION CODES       *
***********************************************************************
TPIOXWV  $NULL                     TABLE REFERENCE POINT    CODE
         $ADCON (TPIOXRT)          WRITE NOT COMPLETE         00
         $ADCON (TPIOLOG)          NORMAL WRITE COMPLETE      01
         $ADCON (TPIOWNR)          DATA SET NOT READY         02
         $ADCON (TPIOWND)          TIMEOUT ON WRITE           03
         EJECT
***********************************************************************
*              HASP WAIT-A-BIT REQUEST                                *
***********************************************************************
TPIOHWA  $NULL
         $LD   TPBUFFQP,,L         GET TP BUFFER FREE QUEUE POINTER
         $BZ   TPIONOB             GO SET RTP1130 WAIT-A-BIT IF NONE
         $B    TPIOCHG              OR HANDSHAKE WITH NULL BUFFER
         SPACE 3
***********************************************************************
*              LOCAL CONSTANTS,STORAGE, ETC.                          *
***********************************************************************
TPIOTBF  DC    AL2(&DELAY)
         DC    AL2($BSXTMR)        PROGRAM TIMER INDICATOR
TPIOTOC  DC    AL2(BSXOWF3)        TIMER COMPLETION CODE
TPIOAK0  DC    AL2($BSXTAK)        TRANSMIT ACK0 INDICATOR
TPIORWB  $ADCON (TPIORWB)          DUMMY BUFFER POINTER
         DC    AL2(0)              DUMMY STATUS
TPIODXC  DC    AL2(*-*)            TRANSMIT COUNT WORD
TPIODHD  DC    AL2(*-*)            HEADER
         DC    AL2(0,0,0)          SPACE FOR BCB,FCS,RCB AND RESPONSE
TPIODMO  DC    AL2(6)              INITIALIZATION VALUE FOR WAIT-A-BIT
TPIOTMT  DC    AL2($BSXTNT)         SEQUENCE VIA DUMMY BUFFER
TPIOWBX  DC    AL2(X'4000')        WAIT-A-BIT BIT
         EJECT
***********************************************************************
*              PROCEDURE FOR NO OUTPUT BUFFER READY                   *
***********************************************************************
TPIOSTM  $NULL
         $AXT  (TPIOTBF-2*D1),WA,L DUMMY BUFFER POINTER TO WA
         $TSL  BSXIOS              START PROGRAM TIMER
         $B    TPIOTDX             DATA SET NOT READY EXIT
         $STL  TPIOXVE+D1          RESET VARIABLE ENTRY
         $DEQUE TPBUFOQP           TRY FOR AN OUTPUT BUFFER
         $BZ   TPIOTRF             BRANCH IF NONE READY
TPIONIT  $STO  TPIOWBP             SET WRITE BUFFER POINTER
         $TSL  BSXHALT             STOP SCA TIMER
         $B    TPIORXW,,L          GO INITIATE DATA WRITE
TPIOTRF  $LD   TPBUFFQP,,L         TEST FOR FREE TP BUFFER
         $BZ   TPIONOB             BRANCH IF NONE AVAILABLE
         $LD   SFCSXMT             GET CURRENT TRANSMIT FCS
         $EOR  SFCSPRV             COMPARE WITH PREVIOUS
         $BNZ  TPIOCHG             BRANCH IF ACTION REQUIRED
         $LD   TPIOLSR,,L          TEST LAST RESPONSE FROM HASP
         $BNZ  TPIOZAP             DELAY ONLY IF ACK0
         $LD   BSXOPFW,,L          GET COMPLETION CODE
         $BZ   TPIOXRT             EXIT IF TIMER NOT DONE
         $S    TPIOTOC             TEST FOR NORMAL COMPLETION
         $BZ   TPIOTUP             BRANCH IF NORMAL COMPLETION
***********************************************************************
*              DATA SET NOT READY ON TIMER OPERATION                  *
***********************************************************************
TPIOTDX  $TSL  TPIODSM             TELL OPERATOR DATA SET NOT READY
         $B    TPIOSTM             TRY AGAIN WHEN READY
***********************************************************************
*              INITIATE ACK0 RESPONSE TO HASP                         *
***********************************************************************
TPIOTUP  $DEQUE TPBUFFQP           GET AVAILABLE FREE BUFFER
         $STO  TPIOWBP             STORE BUFFER POINTER
         $LXA  TPIOWBP,WA           AND SET WA
         $LD   TPIOAK0             GET ACK0 SEQUENCE INDICATOR
         $STO  TPBUFHD,WA,X         STORE IN BUFFER
         $LD   SFCSXMT             RESET
         $AND  TPIOWBR              RTP1130
         $STO  SFCSXMT               WAIT-A-BIT
         $B    TPIOWPO             GO INITIATE ACK0 WRITE
***********************************************************************
*              RTP1130 WAIT-A-BIT TIME                                *
***********************************************************************
TPIONOB  $LD   SFCSXMT             TURN ON
         $OR   TPIOWBX              RTP1130
         $STO  SFCSXMT               WAIT-A-BIT
         $LD   TPIORWB             DUMMY BUFFER POINTER
         $STO  TPIOWBP              FOR WAIT-A-BIT WRITE
         $LD   TPIODMO             INITIALIZE
         $STO  TPIODXC              DUMMY
         $LD   TPIOTMT               BUFFER
         $STO  TPIODHD                VALUES
TPIOSTT  $TSL  BSXHALT             STOP PROGRAM TIMER
         $B    TPIOSBO,,L          GO INITIATE WRITE
***********************************************************************
*              FCS CHANGED ... TELL HASP WITH NULL BUFFER             *
***********************************************************************
TPIOCHG  $LD   SFCSXMT             SET 'PREVIOUS' FCS TO
         $STO  SFCSPRV              CURRENT VALUE
TPIOZAP  $DEQUE TPBUFFQP           GET AVAILABLE FREE TP BUFFER
         $STO  TPIOWBP             STORE POINTER FOR WRITE
         $LXA  TPIOWBP,WA           AND SET WA
         $LD   TPIODMO             INITIALIZE
         $STO  TPBUFCB,WA,X         BUFFER
         $LD   TPIOTMT               FOR
         $STO  TPBUFHD,WA,X           NULL
         $ZAC                          DATA
         $STO  TPBUFFR,WA,X             TRANSMISSION
         $B    TPIOSTT             GO WRITE NULL BUFFER
         EJECT
***********************************************************************
*              ENTRY POINT FROM COMMUTATOR                            *
***********************************************************************
TPIOXEP  $NULL
TPIOXVE  $B    TPIOXNI,,L          VARIABLE ENTRY VECTOR
TPIOXNP  $B    TPIOXRT,,L          NON-PROCESS EXIT POINT
TPIOXNI  $NULL                     INITIAL ENTRY POINT
***********************************************************************
*              TPIOX WRITE (TRANSMIT) BUFFER PROCESSOR                *
***********************************************************************
TPIOWRS  $LXA  TPIOWBP,WA          WRITE BUFFER POINTER
TPIOWPO  $LD   TPBUFHD,WA,X        GET SEQUENCE INDICATOR
         $EOR  TPIOACN             TEST FOR ACK0 SEQUENCE
         $BZ   TPIOSVG             BYPASS SETTING BCB/FCS IF ACK0
***********************************************************************
*              SET BCB AND FCS ON NORMAL WRITE                        *
***********************************************************************
         $LD   SBCBXMT             GET TRANSMIT BCB
         $SLA  8                   TO HIGH ORDER AC
         $OR   TPIOXHO             SET HIGH ORDER BIT ON
         $STO  TPBUFBF,WA,X        STORE BCB IN BUFFER
TPIONXB  $LD   SFCSXMT             GET TRANSMIT FCS
         $SRA  8                   FIRST HALF-FCS(1)
         $OR   TPBUFBF,WA,X        FORM BCB/FCS(1)
         $STO  TPBUFBF,WA,X        STORE IN BUFFER
         $LD   TPBUFFR,WA,X        GET FCS(2) SLOT AND RCB
         $SRT  8                   MOVE RCB TO EXT
         $LD   SFCSXMT             GET TRANSMIT FCS
         $SLT  8                   FORM FCS(2)/RCB
         $STO  TPBUFFR,WA,X        STORE IN BUFFER
***********************************************************************
*              SAVE SEQUENCE AND TRANSMIT COUNT                       *
***********************************************************************
TPIOSVG  $LD   TPBUFCB,WA,X        GET TRANSMIT COUNT
         $STO  TPIOWXX             SAVE IN CASE OF NAK
         $LD   TPBUFHD,WA,X        GET SEQUENCE INDICATOR
         $STO  TPIOWHD             SAVE IN CASE OF NAK
         $LD   TPBUFBF,WA,X        GET BCB AND FCS1
         $STO  TPIOWBF             SAVE IN CASE OF NAK
***********************************************************************
*              INITIATE WRITE OPERATION                               *
***********************************************************************
TPIOWND  $TSL  BSXIOS              INITIATE WRITE THRU BSXIOS
         $B    TPIOWNR             DATA SET NOT READY EXIT
         $STL  TPIOXVE+D1          RESET VARIABLE ENTRY
         $LXA  BSXOPFW,WB          COMPLETION CODE TO WB
         $B    TPIOXWV,WB,I        BRANCH TO INDICATED PROCESS
***********************************************************************
*              DATA SET NOT READY ON WRITE OPERATION                  *
***********************************************************************
TPIOWNR  $TSL  TPIODSM             TELL OPERATOR DS NOT READY
         $B    TPIOWND             INITIATE WRITE WHEN READY
         EJECT
***********************************************************************
*              TPIOX CONSTANTS,STORAGE,FLAGS,ETC.                     *
***********************************************************************
TPIOWBF  DC    AL2(*-*)            LAST BCB AND FCS1
TPIOWXX  DC    AL2(*-*)            LAST DATA WRITE COUNT
TPIOACN  DC    AL2($BSXTAK)        ACK0 SEQUENCE INDICATOR
TPIOWHD  DC    AL2(*-*)            LAST DATA WRITE HEADER
TPIOXHO  DC    AL2(X'8000')        HIGH ORDER BIT FOR CONTROL
TPIOWBP  DC    AL2(*-*)            TRANSMIT BUFFER ADDRESS
TPIOWBR  DC    AL2(X'BFFF')        RESET WAIT-A-BIT BIT
TPIORMX  DC    AL2(&TPBFSZE)       MAXIMUM READ COUNT
TPIORMN  DC    AL2(8)              MINIMUM READ COUNT
TPIORRQ  DC    AL2($BSXRDX)        READ SEQUENCE INDICATOR
*
SFCSREC  DC    AL2(*-*)            LAST FCS RECEIVED
SFCSXMT  DC    AL1(X'8F',X'CF')    LAST FCS TRANSMITTED
SFCSPRV  DC    AL1(X'8F',X'CF')    PREVIOUS FCS TRANSMITTED
SBCBREC  DC    AL2(*-*)            BCB EXPECTED FROM HASP
SBCBXMT  DC    AL2(*-*)            BCB TRANSMITTED TO HASP
         EJECT
***********************************************************************
*              READ PROCESS ENTERED FROM BSXIOS WRITE APPENDAGE       *
***********************************************************************
TPIORDS  DC    AL2(*-*)            ENTERED AT INTERRUPT TIME
         $LD   BSXWHAT+D1,,L       EXCLUDE TIMER FUNCTION
         $BZ   TPIORDS,,I           FROM APPENDAGE PROCESSING
         $MDX  -BSXOWF1,WA,X       TEST WRITE COMPLETION CODE
         $B    TPIOXRX             USE COMMUTATOR IF ABNORMAL
         $LXA  BSXISVA+D1,WA       GET BUFFER ADDRESS FROM BSXIOS
         $LD   SFCSXMT             TRANSMIT FCS
         $AND  TPIOWBM             ISOLATE WAIT-A-BIT
         $BZ   TPIORNO             BRANCH IF OFF
         $LD   TPIORMN             MINIMUM READ COUNT
         $B    TPIORSC             GO STORE IN BUFFER
TPIORNO  $LD   TPIORMX             MAXIMUM READ COUNT
TPIORSC  $STO  TPBUFCB,WA,X        STORE IN BUFFER
         $LD   TPIORRQ             SET READ SEQUENCE INDICATOR
         $STO  TPBUFHD,WA,X         IN BUFFER HEADER
TPIORIP  $TSL  BSXIOS              INITIATE READ AT WRITE END-OP
         $B    TPIORIP             PERSIST IF DATA SET NOT READY
TPIOXRX  $B    TPIORDS,,I          RETURN TO BSXIOS INTERRUPT RTN
***********************************************************************
*              DATA SET NOT READY ON READ OPERATION                   *
***********************************************************************
TPIORNR  $TSL  TPIODSM             TELL OPERATOR DS NOT READY
*                                  SEND NAK WHEN DS READY
***********************************************************************
*              SETUP AND TRANSMIT NAK TO HASP                         *
***********************************************************************
TPIONAK  $LD   TPIONCN             NAK INDICATOR
         $STO  TPBUFHD,WA,X        TO BUFFER
         $B    TPIOWND             GO WRITE NAK
TPIONCN  DC    AL2($BSXTNK)        NAK INDICATOR
***********************************************************************
*              NAK FROM HASP...RE-TRANSMIT LAST NON-NAK               *
***********************************************************************
TPIOXDT  $LD   TPIOWXX             LAST DATA WRITE COUNT
         $STO  TPBUFCB,WA,X        TO BUFFER
         $LD   TPIOWHD             LAST DATA SEQUENCE INDICATOR
         $STO  TPBUFHD,WA,X        TO BUFFER
         $LD   TPIOWBF             LAST BCB AND FCS1
         $STO  TPBUFBF,WA,X        TO BUFFER
         $B    TPIOWND             INITIATE WRITE
***********************************************************************
*              ACK0 FROM HASP...RESET WAIT-A-BIT                      *
***********************************************************************
TPIOIWB  $STO  TPIOLSR             RUN UP ACK0 FLAG
         $LD   SFCSREC             RESET
         $AND  TPIOWBR              HASP
         $STO  SFCSREC               WAIT-A-BIT
         $B    TPIOTBT             GO TEST BUFFER TYPE
         EJECT
***********************************************************************
*              NORMAL READ COMPLETE PROCESSOR                         *
***********************************************************************
TPIONRC  $NULL
         $LD   TPBUFBF,WA,X        GET RECEIVED BCB/FCS(1)
         $SRT  15                  TO EXT (EXCEPT SIGN)
         $ZAC                      CLEAR AC
         $SLT  3                   ISOLATE BCB CONTROL BITS
         $STO  TPIOBCI             SAVE FOR INVESTIGATION
         $SRA  3                   CLEAR AC
         $SLT  4                   GET ACTUAL BCB COUNT
         $STO  TPIORBC             SAVE FOR COMPARE
         $RTE  16                  FCS(1) TO HIGH ORDER AC
         $STO  TPIORFC             FORM FCS (FIRST BYTE)
         $LD   TPBUFFR,WA,X        GET FCS(2) AND RCB
         $SRA  8                   FORM
         $OR   TPIORFC              COMPLETE
         $STO  TPIORFC               FCS
***********************************************************************
*              TEST BCB CONTROL BITS                                  *
***********************************************************************
         $LD   TPIOBCI             GET BCB CONTROL BITS
         $BZ   TPIOVRB             BRANCH IF VERIFICATION
         $BOD  TPIOBDN             BRANCH IF NO VERIFICATION
***********************************************************************
*              RESET EXPECTED BCB TO VALUE OF RECEIVED                *
***********************************************************************
         $LD   TPIORBC             GET RECEIVED BCB
         $STO  SBCBREC             SET EXPECTED BCB ALA HASP
         $B    TPIOBDN             BYPASS FURTHER PROCESSING
***********************************************************************
*              MORE CONSTANTS,STORAGE,ETC.                            *
***********************************************************************
TPIORBC  DC    AL2(*-*)            BCB RECEIVED
TPIORFC  DC    AL2(*-*)            FCS RECEIVED
TPIOBCI  DC    AL2(*-*)            BCB CONTROL BITS
TPIODIG  DC    AL2(16)             OVERFLOW CORRECTION
TPIOMXE  DC    AL2(2)              MAXIMUM BCB ERROR
TPIOMOD  DC    AL2(15)             MODULO 16 MASK
TPIOCNO  DC    AL2(1)              CONSTANT 1
TPIOWBM  DC    AL2(X'4000')        WAIT-A-BIT BIT
TPIOLHM  DC    AL2(X'00FF')        LEFT HALF MASK
         EJECT
***********************************************************************
*              VERIFY RECEIVED BCB                                    *
***********************************************************************
TPIOVRB  $LD   SBCBREC             GET EXPECTED BCB
         $S    TPIORBC             MINUS RECEIVED
         $BZ   TPIOSTP             BRANCH IF NO ERROR
         $SKPP                     SKIP IF NO OVERFLOW
         $A    TPIODIG             OR CORRECT OVERFLOW
         $S    TPIOMXE             COMPARE WITH MAXIMUM ERROR
         $BP   TPIOBER             BRANCH IF MISSING DATA
***********************************************************************
*              DUPLICATE RECORD PROCESSING                            *
***********************************************************************
TPIOTBT  $LD   TPBUFCW,WA,X        GET BUFFER CHAIN WORD
         $BNZ  TPIOTHW             BRANCH IF DUMMY BUFFER
TPIORTN  $LD   TPIOWBP,,L          GET BUFFER POINTER
         $QFREL TPBUFFQP           RETURN TO FREE CHAIN
         $B    TPIOTHW             TEST HASP WAIT-A-BIT
***********************************************************************
*              STEP EXPECTED BCB COUNT                                *
***********************************************************************
TPIOSTP  $LD   SBCBREC,,L          GET EXPECTED BCB
         $A    TPIOCNO             INCREASE BY ONE
         $AND  TPIOMOD             MODULO 16
         $STO  SBCBREC,,L          RESET EXPECTED BCB
***********************************************************************
*              STORE RECEIVED FCS AND QUEUE BUFFER                    *
***********************************************************************
TPIOBDN  $LD   TPIORFC             SET RECEIVE FCS
         $STO  SFCSREC,,L          TO CURRENT VALUE
         $LD   TPBUFCW,WA,X        GET CHAIN WORD
         $BNZ  TPIOTHW             BRANCH IF DUMMY BUFFER
         $LD   TPBUFFR,WA,X        GET RCB FROM BUFFER
         $AND  TPIOLHM             TEST FOR RCB = 0
         $BZ   TPIORTN             BRANCH IF NULL RECORD
         $TSL  SSRCHCB             FIND MATCHING UFCB
         $BNZ  TPIOCRC             CHECK FOR CONTROL RECORD IF NO MATCH
         $LD   UFCBBFC,WC,X        INCREMENT
         $A    TPIOCNO              FUNCTION
         $STO  UFCBBFC,WC,X          COUNT
         $S    UFCBBFL,WC,X        TEST FOR BUFFER LIMIT
         $BNZ  TPIOQAC             BRANCH IF LIMIT NOT REACHED
         $S    TPIOCNO             CALCULATE
         $S    UFCBFCS,WC,X         SUSPENSION
         $STO  TPIOTSV               MASK
         $LD   SFCSXMT                AND
         $AND  TPIOTSV                 SUSPEND
         $STO  SFCSXMT                  FUNCTION
TPIOQAC  $MDX  UFCBBFP,WC,X        SET WC TO BUFFER QUEUE POINTER
         $LD   TPIOWBP,,L          GET BUFFER POINTER
         $QACTL ,                  QUEUE FOR TPGET
         EJECT
***********************************************************************
*              TEST HASP WAIT-A-BIT CONDITION                         *
***********************************************************************
TPIOTHW  $LD   SFCSREC,,L          GET RECEIVED FCS
         $AND  TPIOWBM             ISOLATE WAIT-A-BIT
         $BNZ  TPIOHWA             BRANCH IF ON
***********************************************************************
*              PREPARE FOR TRANSMISSION TO HASP                       *
***********************************************************************
TPIODQO  $DEQUE TPBUFOQP           TRY FOR AN OUTPUT BUFFER
         $BZ   TPIOSTM             BRANCH IF NO BUFFER READY
         $STO  TPIOWBP,,L          SET BUFFER POINTER
TPIORXW  $LD   SFCSXMT,,L          GET TRANSMIT FCS
         $AND  TPIOWBR,,L          RESET WAIT-A-BIT
         $STO  SFCSXMT,,L          ON GENERAL PRINCIPLES
         $STO  SFCSPRV,,L          RESET PREVIOUS FOR NEXT TRIP
         $LD   SPUTBFCT            DECREMENT PUT
         $S    TPIOCNO              ACTIVE BUFFER
         $STO  SPUTBFCT              COUNT FOR TPPUT
TPIOSBO  $LD   SBCBXMT,,L          CALCULATE
         $A    TPIOCNO              AND
         $AND  TPIOMOD               SET
         $STO  SBCBXMT,,L             BCB
         $B    TPIOWRS,,L          INITITATE WRITE
TPIOLSR  DC    AL2(*-*)            SET TO ZERO IF ACK0 RECEIVED
***********************************************************************
*              CHECK FOR CONTROL RECORD BUFFER                        *
***********************************************************************
TPIOCRC  $NULL
         $AND  TPIOCRM             TEST RCB FOR CONTROL RECORD
         $BNZ  TPIORTN             IGNORE BUFFER IF UNKNOWN TYPE
         $LD   TPBUFSR,WA,X        GET CONTROL RECORD SRCB/SCB
         $RTE  16                  TO EXT
         $LD   TPBUFFR,WA,X        GET CONTROL RECORD FCS(2)/RCB
         $SLT  8                   FORM RCB/SRCB
         $STO  TPIOTSV             SAVE IT
         $EOR  TPIODIS             TEST FOR 'DISCONNECT' CON REC
         $BZ   TPIOHLT             BRANCH IF DISCONNECT TIME
         $STL  TPIOXVE+D1,L        RESET VARIABLE ENTRY POINT
         $LD   SHCRQUE             GET HASP CONTROL RECORD QUEUE
         $BNZ  TPIOXRT             EXIT UNTIL PREVIOUS ENTRY PROCESSED
         $LD   TPIOTSV             GET RCB/SRCB
         $STO  SHCRQUE             TO CONTROL RECORD QUEUE
         $B    TPIORTN             RETURN BUFFER TO FREE CHAIN
TPIOCRM  DC    AL2(X'000F')        CONTROL RECORD RCB MASK
TPIOTSV  DC    AL2(*-*)            SAVE AREA FOR RCB/SRCB
SHCRQUE  DC    AL2(*-*)            HASP CONTROL RECORD QUEUE
SPUTBFCT DC    AL2(*-*)            ACTIVE BUFFER COUNT (INPUT)
TPIODIS  DC    AL2(X'F0C2')        DISCONNECT CR (RCB/SRCB)
         EJECT
***********************************************************************
*              DISASTROUS BCB ERROR PROCESSING                        *
***********************************************************************
TPIOBER  $STL  TPIOXVE+D1,L        RESET VARIABLE ENTRY
         $LD   SBCBREC,,L          GET EXPECTED BCB
         $RTE  16                  TO EXT
         $SLT  8                   CLEAR LOW ORDER BYTE
         $LD   TPIOLEC             GET BCB ERROR CODE
         $OR   TPIORBC,,L          COMBINE WITH BCB RECEIVED
         $TSL  SLOGSCA             GO LOG ERROR MESSAGE
         $BZ   TPIOXRT             EXIT UNTIL MESSAGE ACCEPED
         $LD   TPIODBC             SET WRITE COUNT FOR
         $STO  TPBUFCB,WA,X        DISASTROUS BCB CONTROL RECORD
         $LD   TPIODHX             SET HEADER FOR
         $STO  TPBUFHD,WA,X        NORMAL TEXT WRITE
         $LD   TPIORBC,,L          GET RECEIVED BCB
         $SLA  8                   TO HIGH ORDER AC
         $OR   TPIODRB             FORM FUNNY BCB
         $STO  TPBUFBF,WA,X        FOR HASP TO PONDER
         $LD   TPIODRC             GET RECORD TYPE
         $STO  TPBUFFR,WA,X        TO BUFFER
         $LD   SBCBREC,,L          GET EXPECTED BCB
         $SLA  8                   TO HIGH ORDER AC
         $OR   TPIODEB             FORM SRCB,SCB=0
         $STO  TPBUFSR,WA,X        TO BUFFER
         $ZAC                      CLEAR AC AND
         $STO  TPBUFSR+1,WA,X      SET END OF BLOCK
         $B    TPIONXB,,L          SET FCS AND INITIATE WRITE
TPIOLEC  DC    AL2(X'FF00')        BCB ERROR CODE=FF
***********************************************************************
*              DISASTROUS BCB BUFFER SKELETON VALUES                  *
***********************************************************************
TPIODBC  DC    AL2(9)              BYTE COUNT FOR WRITE
TPIODHX  DC    AL2($BSXTNT)        NORMAL TEXT HEADER
TPIODRB  DC    AL2(X'A0',0)        BCB SKELETON,FCS(1) SLOT
TPIODRC  DC    AL1(0,X'E0')        FCS(2),RCB=E0
TPIODEB  DC    AL2(X'80',0)        SRCB,SCB
         EJECT
***********************************************************************
*              ISSUE DATA SET NOT READY MESSAGE AND WAIT FOR READY    *
***********************************************************************
TPIODSM  DC    AL2(*-*)
         $STL  TPIOXVE+D1,L        RESET VARIABLE ENTRY
         $WTO  TPIOMS1,TPIOXRT     ISSUE NOT READY MESSAGE
         $STL  TPIOXVE+D1,L        RESET VARIABLE ENTRY
         $XIO  BSXISNR-D1,,L       SENSE SCA WITHOUT RESET
         $SLA  7                   GET DATA SET READY BIT
         $BNN  TPIOXRT             NON-PROCESS EXIT UNTIL READY
         $B    TPIODSM,,I          RETURN TO CALLER
TPIOMS1  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(22)             DATA COUNT
         DC    C'DATA SET NOT READY....'
         $NULL
         EJECT
***********************************************************************
*              TEST READ RESPONSE AND CYCLE COMMUTATOR UNTIL COMPLETE *
***********************************************************************
TPIOLOG  $NULL
         $STL  TPIOXVE+D1,L        RESET VARIABLE ENTRY POINT
         $LD   BSXOPFR,,L          GET BSXIOS COMPLETION CODE
         $BZ   TPIOXRT             CYCLE COMMUTATOR UNTIL READ DONE
         $STO  WB,,L               COMPLETION CODE TO WB
         $STO  TPIOLSR             RESET ACK0 INDICATOR
         $S    TPIOLTO             TEST FOR NORMAL COMPLETION
         $BZ   TPIOXRV,WB,I        BRANCH IF NORMAL COMPLETION
         $S    TPIOLTT             TEST FOR ACK0 READ CODE
         $BZ   TPIOXRV,WB,I        BRANCH IF ACK0 READ
***********************************************************************
*              LOG ALL UNUSUAL READ RESPONSES                         *
***********************************************************************
         $STX  TPIOLSB+D1,WB       SAVE WB IN CASE OF NPXT
         $STL  TPIOXVE+D1,L        RESET VARIABLE ENTRY
         $LD   BSXNDSW,,L          GET LAST DSW FROM TPIOX
         $RTE  16                  TO EXT
         $LD   BSXOPFR,,L          GET COMPLETION CODE
         $SLT  8                   LEFT JUSTIFY AND CLEAR LOW BYTE
         $TSL  SLOGSCA             GO LOG COMPLETION CODE, DSW
TPIOLSB  $AXT  *-*,WB,L            RESTORE WB
         $B    TPIOXRV,WB,I        OFF TO APPROPRIATE PROCESSOR
TPIOLTO  DC    AL2(BSXORF1)        NORMAL READ COMPLETION TEST VALUE
TPIOLTT  DC    AL2(BSXORFA-BSXORF1) ACK0 RECEIVED TEST VALUE
***********************************************************************
*              ISSUE TERM MESS AND HALT WHEN DISCONNECT CR READ       *
***********************************************************************
TPIOHLT  $TSL  BSXHALT             STOP THE COM ADAPTER
         $STL  TPIOXVE+D1,L        RESET TPIOX COMMUTATOR ENTRY
         $WTO  TPIOTEM,TPIOXRT     QUEUE TERMINATION MESSAGE
         $TSL  TPIOXVE+D1          RESET TPIOX ENTRY & TOUR COMM
         $LD   TPIODSA             SET AC TO SHOW COMPLETION
         $TSL  $WAIT               USE GENERAL WAIT ROUTINE
         $B    TPIOXRT,,L           WHEN CONSOLE PRINTER QUITS
TPIOTEM  DC    AL1($BLACK+$EBCD,$LIST15) MESSAGE CONTROL WORD
         DC    AL2(28)             BYTE COUNT OF MESSAGE
         DC    C'REMOTE PROCESSING TERMINATED' TERM MESSAGE
         $NULL                     1130 WORD BOUNDARY
TPIODSA  DC    AL2(X'FFFF')        CONSTANT TO DISPLAY IN AC
***********************************************************************
*              RE-ISSUE READ IF TIMEOUT ON PREVIOUS READ              *
***********************************************************************
TPIORTO  $LXA  BSXISVA+D1,WA       WA = ADDRESS OF READ BUFFER
         $LD   TPIORRQ,,L          READ SEQUENCE INDICATOR     @OZ18433
         $STO  TPBUFHD,WA,X        STORE IN BUFFER HEADER      @OZ18433
TPIORDR  $TSL  BSXIOS              INITIATE READ THRU BSXIOS
         $B    TPIORDR             PERSIST IF DATA SET NOT READY
         $B    TPIOLOG             GO WAIT FOR READ TO COMPLETE
         TITLE 'RTP1130 (TPGET - PROCESS TP BUFFERS FROM HASP)'
***********************************************************************
*                                                                     *
* TITLE - TPGET (PROCESSOR FOR BUFFERS RECEIVED FROM HASP)            *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  PROCESSES DATA RECEIVED FROM HASP IN THE FORM OF TP DATA BUFFERS   *
*  OR CONTROL RECORDS PREPROCESSED BY TPIOX...                        *
*                                                                     *
*  CONTROL RECORD PROCESSING IS IN THE FORM OF 'REQUEST TO START'     *
*  OR 'PERMISSION TO SEND' FUNCTIONS.                                 *
*                                                                     *
*  DATA BUFFERS ARE DEBLOCKED, DECOMPRESSED, CONVERTED TO APPROPRIATE *
*  CODE (1403 PRINT, 1442 PUNCH, CONSOLE TILT-ROTATE, ETC.) AND QUEUED*
*  FOR THE SPECIFIED COMMUTATOR I/O PROCESSOR.                        *
*                                                                     *
*  CONTROL INFORMATION PERTINENT TO THE UNIQUE REQUIREMENTS OF EACH   *
*  DATA TYPE IS PROVIDED THRU THE ASSOCIATED UFCB.                    *
*                                                                     *
***********************************************************************
         SPACE 3
TPGTCLH  DC    AL2(X'00FF')        CLEAR LEFT-HALF MASK
***********************************************************************
*              ENTRY POINT FROM COMMUTATOR                            *
***********************************************************************
TPGETEP  $NULL
TPGETVE  $B    TPGETNI,,L          VARIABLE ENTRY POINT
TPGETNP  $B    TPGETRT,,L          NON-PROCESS EXIT POINT
TPGETXT  $BSI  TPGETVE+D1          RESET ENTRY AND LEAVE
TPGETNI  $NULL                     INITIAL ENTRY POINT
***********************************************************************
*              PROCESS CONTROL RECORD FROM HASP                       *
***********************************************************************
         $LD   SHCRQUE,,L          GET CONTROL RECORD ENTRY
         $BZ   TPGTCRX             BRANCH IF NO CONTROL RECORD
         $STO  TPGTCRS             SAVE RCB/SRCB
         $ZAC                      CLEAR AC AND
         $STO  SHCRQUE,,L           FREE QUEUE
         $LD   TPGTCRS             GET FUNCTION SRCB=RCB
         $TSL  SSRCHCB             SEARCH UFCB'S
         $BNZ  TPGTCRX             IGNORE IF NO MATCH
         $LD   TPGTCRS             GET RCB/SRCB
         $SLA  1                   ELIMINATE SIGN
         $SRA  13                  ISOLATE CONTROL TYPE BITS
         $S    TPGTCN1             TEST FOR REQUEST TO START
         $BZ   TPGTREQ              FROM HASP
         $S    TPGTCN1             TEST FOR PERMISSION TO SEND
         $BNZ  TPGTCRX             IGNORE ALL OTHERS
         EJECT
***********************************************************************
*              PROCESS PERMISSION TO SEND FROM HASP                   *
***********************************************************************
         $LD   UFCBSAR,WC,X        GET STATUS/RCB WORD
         $AND  TPGTCLH             CLEAR STATUS BYTE
         $OR   TPGTCRS             SET STATUS TO
         $STO  UFCBSAR,WC,X        PERMISSION TO SEND
TPGTPMS  $LD   UNLATCH,,L          UNLATCH SPECIFIED
         $STO  $FCBCOM,WC,I        COMMUTATOR GATE
         $B    TPGTCRX             GO TO NEXT PROCESS
***********************************************************************
*              SOME TPGET CONSTANTS                                   *
***********************************************************************
TPGTCRS  DC    AL2(*-*)            CONTROL RECORD RCB/SRCB
TPGTCN1  DC    AL2(1)              CONSTANT 1
TPGTPTS  DC    AL1($CRPERM,0)      PERMISSION TO START IDENTIFICATION
TPGTSCC  DC    AL2(X'008E')        SPECIAL PRINT SRCB FOR FORMS
***********************************************************************
*              PROCESS REQUEST TO START FROM HASP                     *
***********************************************************************
TPGTREQ  $STL  TPGETVE+D1          RESET VARIABLE ENTRY POINT
         $LD   TPGTPTS             GET PERMISSION IDENTIFICATION
         $TSL  STPOPEN             GO INITIATE CONTROL RECORD TO HASP
         $BNZ  TPGETRT             CYCLE UNTIL ACCEPTED
         $B    TPGTPMS             GO UNLATCH APPROPRIATE GATE
TPGTCRX  $NULL                     END OF CONTROL RECORD PROCESSOR
         AIF   (&PR1403 EQ 0).NO1403F
         EJECT
***********************************************************************
*              PROCESS DATA DESTINED FOR 1403 PRINTER                 *
***********************************************************************
TPGTFOP  $AXT  PRFOUFCB,WB,L       1403 UFCB ADDRESS TO WB
         $LD   UFCBPBP,WB,X        BUFFER POINTER FROM UFCB
         $BNZ  TPGTFOL             BRANCH IF PARTIAL BUFFER
         $DEQUE PRFOUBFP           GET A 1403 TP BUFFER
         $BZ   TPGTFND             GO TO NEXT PROCESS IF NONE
         $TSL  TPGTINT             GO TO INITIALIZATION ROUTINE
TPGTFOL  $DEQUE PRFO3FQP           GET A 1403 TANK
         $BZ   TPGTFND             TO NEXT PROCESS IF NONE
         $STO  TPGTFTK             SAVE TANK ADDRESS
         $LXA  TPGTFTK,WA          TO WA
         $LD   TPGTFBV             1403 PRINTER BLANKS
         $TSL  TPGTFIL             GO FILL TANK WITH BLANKS
         $TSL  SDBLOCK             OFF TO DEBLOCKER
         $BZ   TPGTEOB             BRANCH IF END OF BUFFER
         $LD   DBLKSRC,,L          GET SRCB CODE FROM DBLOCK
         $EOR  TPGTSCC              AND TEST FOR FORMS LINE
         $BZ   TPGTNUL             IGNORE FORMS PRINT LINE
         $LD   TPGTFTK             GET PROCESSED TANK ADDRESS
         $QACTL PRFO3AQP           QUEUE IT FOR PRINT ROUTINE
         $BSI  TPGETVE+D1          CYCLE COMMUTATOR
         $B    TPGTFND             GO NEXT PROCESS
TPGTFTK  DC    AL2(*-*)            1403 TANK ADDRESS
TPGTFBV  DC    AL2(X'7F7F')        1403 PRINTER CODE BLANK
TPGTFND  $NULL                     END OF PROCESSOR
.NO1403F ANOP
         AIF   (&PR1132 EQ 0).NO1132G
         EJECT
***********************************************************************
*              PROCESS DATA DESTINED FOR 1132 PRINTER                 *
***********************************************************************
TPGTEOP  $AXT  PRETUFCB,WB,L       1132 UFCB ADDRESS TO WB
         $LD   UFCBPBP,WB,X        BUFFER POINTER FROM UFCB
         $BNZ  TPGTEOL             BRANCH IF PARTIAL BUFFER
         $DEQUE PRETUBFP           GET 1132 TP BUFFER
         $BZ   TPGTEND             TO NEXT PROCESS IF NONE
         $TSL  TPGTINT             GO TO INITIALIZATION ROUTINE
TPGTEOL  $DEQUE PRET2FQP           GET 1132 TANK
         $BZ   TPGTEND             TO NEXT PROCESS IF NONE
         $STO  TPGTETK             SAVE TANK ADDRESS
         $LXA  TPGTETK,WA          TO WA
         $LD   TPGTEBV             1132 PRINTER BLANKS
         $TSL  TPGTFIL             GO FILL TANK WITH BLANKS
         $TSL  SDBLOCK             OFF TO DEBLOCK ROUTINE
         $BZ   TPGTEOB             BRANCH IF END OF BUFFER
         $LD   DBLKSRC,,L          GET SRCB CODE FROM DBLOCK
         $EOR  TPGTSCC              AND TEST FOR FORMS LINE
         $BZ   TPGTNUL             IGNORE FORMS PRINT LINE
         $LD   PR1132LC,WA,X       GET TANK CONTROL WORD
         $BSC  E                   SKIP IF EVEN PRINT COUNT
         $A    TPGTCN1             FORCE COUNT TO BE EVEN
         $S    TPGTLIM             TEST FOR EXCESSIVE COUNT
         $BSC  N+Z                 SKIP IF LT OR EQ TO LIMIT
         $ZAC                      TRUNCATE EXCESSIVE COUNT
         $A    TPGTLIM             SET TO ORIGINAL OR LIMIT
         $STO  PR1132LC,WA,X       RESET TANK CONTROL WORD
         $LD   TPGTETK             TANK ADDRESS
         $QACTL PRET2AQP           QUEUE IT FOR PRINT ROUTINE
         $TSL  TPGETVE+D1          CYCLE COMMUTATOR
         $B    TPGTEND             GO TO NEXT PROCESS
TPGTETK  DC    AL2(*-*)            1132 TANK ADDRESS
TPGTEBV  DC    AL2(X'4040')        1132 BLANK VALUE
TPGTLIM  DC    AL2(120)            1132 LINE LENGTH LIMIT
TPGTEND  $NULL                     END OF PROCESSOR
.NO1132G ANOP
         AIF   (NOT &PN1442).NO1442O
         EJECT
***********************************************************************
*              PROCESS DATA DESTINED FOR THE 1442 PUNCH               *
***********************************************************************
         $AXT  PNFFUFCB,WB,L       1442 PUNCH UFCB ADDRESS
         $LD   UFCBPBP,WB,X        PUNCH BUFFER POINTER FROM UFCB
         $BNZ  TPGTFFF             BRANCH IF PARTIAL BUFFER
         $DEQUE PNFFUBFP           GET 1442 PUNCH BUFFER
         $BZ   TPGTPND             BRANCH IF NO BUFFER
         $TSL  TPGTINT             GO TO INITIALIZATION
TPGTFFF  $DEQUE PNFF2FQP           GET 1442 PUNCH TANK
         $BZ   TPGTPND             BRANCH IF NO TANK AVAILABLE
         $STO  TPGTPNT             SAVE TANK ADDRESS
         $LXA  TPGTPNT,WA          TO WA
         $ZAC                      CLEAR AC (PUNCH BLANK=0)
         $TSL  TPGTFIL             GO FILL TANK WITH BLANKS
         $TSL  SDBLOCK             GET A PUNCH RECORD
         $BZ   TPGTEOB             BRANCH IF END OF BUFFER
         $BN   TPGTFFP             BRANCH IF END-OF-FILE AND EOB
         $A    WA,,L               COMPUTE ADDRESS
         $STO  WA,,L                OF LAST COLUMN
         $LD   (PN1442DT-PN1442SP),WA,X GET LAST COLUMN
         $OR   TPGTCLP                   SET LAST COLUMN BIT
         $STO  (PN1442DT-PN1442SP),WA,X   FOR 1442 PUNCH ROUTINE
TPGTFFP  $LD   TPGTPNT             GET TANK ADDRESS
         $QACTL PNFF2AQP           QUEUE IT FOR PUNCH ROUTINE
         $TSL  TPGETVE+D1          CYCLE COMMUTATOR
         $B    TPGTPND             GO TO NEXT PROCESS
TPGTPNT  DC    AL2(*-*)            TANK ADDRESS
TPGTCLP  DC    AL2(X'0008')        LAST COLUMN BIT FOR 1442
TPGTPND  $NULL
.NO1442O ANOP
         EJECT
***********************************************************************
*              PROCESS MESSAGES FOR CONSOLE PRINTER                   *
***********************************************************************
         $AXT  CNSPUFCB,WB,L       CONSOLE PRINTER UFCB ADDRESS
         $LD   UFCBPBP,WB,X        MESSAGE BUFFER POINTER
         $BNZ  TPGTCCC             BRANCH IF PARTIAL BUFFER
         $DEQUE CNSPUBFP           GET NEXT MESSAGE BUFFER
         $BZ   TPGTCND             BRANCH IF NO BUFFER
         $TSL  TPGTINT             GO TO INITIALIZATION
TPGTCCC  $DEQUE CONSLFQP           GET A CONSOLE PRINT TANK
         $BZ   TPGTCND             TO NEXT PROCESS IF NONE
         $STO  TPGTCAN             SAVE TANK ADDRESS
         $LXA  TPGTCAN,WA          TO WA....
         $LD   TPGTCBK             TILT-ROTATE CODE BLANK
         $TSL  TPGTFIL             GO FILL TANK WITH BLANKS
         $TSL  SDBLOCK             GET A MESSAGE
         $BZ   TPGTEOB             BRANCH IF END OF BUFFER
         $LD   CONMSGCB,WA,X       GET CONTROL WORD
         $OR   TPGTRTR             SET RED TILT-ROTATE CODE
         $STO  CONMSGCB,WA,X        FOR CONSOLE PRINT ROUTINE
         $LD   UNLATCH,,L               OPEN CONSOLE
         $STO  $FCBCOM,WB,I             ROUTINE GATE
         $LD   TPGTCAN             GET TANK ADDRESS
         $QACTL CONSLAQP           QUEUE FOR CONSOLE PRINT
         $B    TPGTCND             GO TO NEXT PROCESS
TPGTCAN  DC    AL2(*-*)            PRINT TANK ADDRESS
TPGTCBK  DC    AL2(X'2121')        CONSOLE PRINTER BLANK
TPGTRTR  DC    AL1($RED+$TILT,0)   RED RIBBON WITH TILT-ROTATE CODE
TPGTCND  $NULL                     END OF PROCESSOR
***********************************************************************
*              END OF ALL TPGET PROCESSORS OF INPUT BUFFERS           *
***********************************************************************
         $B    TPGETXT,,L          CYCLE COMMUTATOR
         EJECT
***********************************************************************
*              END OF BUFFER ROUTINE                                  *
***********************************************************************
TPGTEOB  $NULL                     ENTERED FROM ANY PROCESSOR
         $LD   UFCBPBP,WB,X        TP BUFFER POINTER
         $QFREL TPBUFFQP           RETURN TO FREE CHAIN
         $ZAC                      RESET
         $STO  UFCBPBP,WB,X         POINTER
         $LD   UFCBBFC,WB,X        DECREMENT
         $S    TPGTEC1              FUNCTION
         $STO  UFCBBFC,WB,X          COUNT
         $S    UFCBBFL,WB,X        COMPARE COUNT WITH LIMIT
         $BNN  TPGTNUL             BRANCH IF NOT UNDER LIMIT
         $LD   UFCBFCS,WB,X        TURN-OFF
         $OR   SFCSXMT,,L           POSSIBLE
         $STO  SFCSXMT,,L            SUSPEND
TPGTNUL  $LD   WA,,L               GET TANK ADDRESS
         $MDX  UFCBFQP,WB,X        POINT WB TO FQP
         $STX  WC,WB,L              AND SET WC TO SAME
         $QFREL ,                  RETURN TO FREE CHAIN
         $B    TPGETXT,,L          CYCLE COMMUTATOR
TPGTEC1  DC    AL2(1)              CONSTANT 1
***********************************************************************
*              INITIALIZE UFCB FOR OUTPUT PROCESSORS                  *
***********************************************************************
TPGTINT  DC    AL2(*-*)
         $STO  UFCBPBP,WB,X        STORE BUFFER POINTER IN UFCB
         $A    TPGTFRP             CALCULATE FIRST RCB POSITION
         $STO  UFCBPBA,WB,X        STORE IN UFCB FOR $DBLOCK
         $ZAC                      CLEAR AC AND
         $STO  UFCBPBS,WB,X         RESET POSITION SWITCH
         $B    TPGTINT,,I          RETURN TO CALLER
TPGTFRP  DC    AL2(TPBUFFR)        RCB OFFSET
         EJECT
***********************************************************************
*                                                                     *
* TITLE - $DBLOCK (DEBLOCK AND DECOMPRESS DATA FROM HASP TP BUFFERS)  *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  LOCATES A RECORD (DEFINED BY RCB) IN A TP BUFFER AS SPECIFIED      *
*  BY GIVEN UFCB, DECOMPRESSES, EDITS AND MOVES DATA TO A SELECTED    *
*  TARGET AREA                                                        *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL  $DBLOCK  LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                   WHERE --- ON ENTRY--WA CONTAINS ADDRESS OF        *
*                             TARGET AREA WITH WORD BOUNDARY          *
*                             ASSUMED. THE TARGET AREA MUST HAVE A    *
*                             FORMAT AS DESCRIBED UNDER 'GENERAL      *
*                             DESCRIPTION OF ALL TANK ELEMENTS'       *
*                                                                     *
*                             WB CONTAINS ADDRESS OF UFCB FOR         *
*                             ASSOCIATED TP BUFFER                    *
*                                                                     *
*                             AC CONTAINS TANK INITIALIZATION         *
*                             VALUE FOR PARTICULAR DEVICE BEING       *
*                             PROCESSED                               *
*                                                                     *
*                             ON EXIT-- WA AND WB ARE RESTORED AND    *
*                             APPROPRIATE UFCB FIELDS ARE UPDATED     *
*                                                                     *
*                             'UFCBPBA' ADDRESS OF NEXT RCB WORD      *
*                             'UFCBPBS' RCB POSITION INDICATOR        *
*                                                                     *
*                              SET TO 0 FOR RIGHT JUSTIFIED RCB       *
*                              SET TO 1 FOR LEFT JUSTIFIED RCB        *
*                                                                     *
*                             'TANKWRDC' IS SET TO SRCB VALUE         *
*                             'TANKWRDD' IS SET TO RECORD LENGTH      *
*                             BOTH VALUES IN LOW ORDER BYTE WITH      *
*                             HIGH ORDER SET ZERO                     *
*                                                                     *
*                             AC SET TO LENGTH OF RECORD DEBLOCKED,   *
*                             OR 0 IF EOB, OR -1 IF EOF,EOB           *
*                                                                     *
*                             REGISTER WC IS DESTROYED                *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*              CHARACTER SUBSTRING PROCESSING                         *
***********************************************************************
DBLKCSS  $SRA  1                   CLEAR AC
         $SLT  6                   CHARACTER COUNT TO AC
         $BSI  DBLKACC             GO ACCUMULATE TOTAL
         $STO  WC,,L               SET COUNT REGISTER
         $LD   DBLKLRS             GET SCB POSITION FLAG
         $MDX  1,WC                 PLUS ONE FOR DUMMY PASS
         $B    DBLKMDL               EXECUTE DUMMY PASS FOR SET UP
DBLKCLP  $LD   DBLKSPT,,I          GET INPUT DATA WORD
         $MDM  DBLKINV,0           TEST INVERTED FLAG
         $SRA  8                   RIGHT JUSTIFY DATA
         $BSI  $FCBPRO,WB,I        GO TO INDICATED ROUTINE
         $BSI  $FCBSTO,WB,I         AND THEN STORE DATA
         $LD   DBLKINV             INVERT
DBLKMDL  $EOR  DBLKCN1              POSITION
         $STO  DBLKINV             FLAG
         $A    DBLKSPT             ADJUST DATA POINTER
         $STO  DBLKSPT              IF NECESSARY
         $MDX  -1,WC               DING COUNT REGISTER
         $B    DBLKCLP             BRANCH IF MORE DATA
         $LD   DBLKACT             GET CHARACTER COUNT
         $AND  DBLKCN1             REDUCE TO EVEN/ODD BIT
         $EOR  DBLKLRS             COMBINED WITH ORIGINAL
         $EOR  DBLKCN1              SCB POSITION INDICATOR
         $STO  DBLKLRS               YIELDS NEW POSITION FLAG
         $B    DBLKGET,,L          GET NEXT SUBSTRING
         EJECT
***********************************************************************
*              CHARACTER PROPAGATION PROCESS                          *
***********************************************************************
DBLKCPR  $SRA  2                   CLEAR AC
         $SLT  5                   PROPAGATION COUNT TO AC
         $BSI  DBLKACC             GO ACCUMULATE TOTAL
         $STO  WC,,L               SET COUNT REGISTER
         $LD   DBLKLRS             GET SCB POSITION
         $EOR  DBLKCN1             INVERT VALUE
         $STO  DBLKINV              TO CALCULATE
         $A    DBLKSPT               DATA WORD
         $STO  DBLKCLC+D1             ADDRESS
DBLKCLC  $LD   *-*,,L              FETCH DATA WORD
         $MDM  DBLKINV,0           TEST POSITION FLAG
         $SRA  8                   LEFT TO RIGHT
         $BSI  $FCBPRO,WB,I        GO TO INDICATED ROUTINE
         $STO  DBLKCHX             SAVE CONVERTED DATA
DBLKCPL  $LD   DBLKCHX             FETCH CHARACTER
         $BSI  $FCBSTO,WB,I        STORE IN TANK
         $MDX  -1,WC               DECREMENT AND TEST COUNT
         $B    DBLKCPL             BRANCH IF MORE
         $LD   DBLKCN1             CONSTANT ONE TO
         $B    DBLKSTO,,L           ADJUST SCB POINTER
***********************************************************************
*              ACCUMULATE RECORD BYTE COUNT TOTAL                     *
***********************************************************************
DBLKACC  DC    AL2(*-*)
         $STO  DBLKACT             SAVE ENTRY COUNT
         $A    DBLKTOT             ACCUMULATE
         $STO  DBLKTOT              TOTAL
         $LD   DBLKACT             RESTORE ENTRY COUNT
         $B    DBLKACC,,I          RETURN TO CALLER
***********************************************************************
*              SOME $DBLOCK CONSTANTS AND STORAGE                     *
***********************************************************************
DBLKACT  DC    AL2(*-*)            ENTRY COUNT
DBLKTOT  DC    AL2(*-*)            TOTAL RECORD LENGTH
DBLKCHX  DC    AL2(*-*)            DATA CHARACTER
DBLKLRS  DC    AL2(*-*)            RCB AND SCB POSITION FLAG
DBLKINV  DC    AL2(*-*)            INVERSE OF RCB, SCB POSITION FLAG
DBLKSPT  DC    AL2(*-*)            DATA POINTER
DBLKSRC  DC    AL2(*-*)            EXTRACTED SRCB
DBLKSCB  DC    AL2(*-*)            EXTRACTED SCB
DBLKCN1  DC    AL2(1)              CONSTANT 1
DBLKCLH  DC    AL2(X'00FF')        MASK TO CLEAR LEFT HALF
DBLKBIG  DC    AL2(X'FFFF')        BIG NUMBER
***********************************************************************
*              $DBLOCK ENTRY POINT                                    *
***********************************************************************
SDBLOCK  DC    AL2(*-*)            ENTRY VIA $TSL $DBLOCK
         $AND  DBLKCLH             CLEAR LEFT HALF AND STORE
         $STO  DBLKPDS              PARTIAL DATA WORD SKELETON
         $LD   UFCBPBS,WB,X        GET RCB POSITION FLAG
         $STO  DBLKLRS             SAVE FOR EXTENSIVE MANIPULATION
         $LD   UFCBPBA,WB,X        GET RCB WORD POINTER
         $A    DBLKCN1             MAKE IT SCB POINTER
         $STO  DBLKSPT              FOR FETCHING DATA
         $STO  WC,,L                 AND LOCAL EXTRACTION
         $LD   -1,WC               GET RCB WORD
         $MDM  DBLKLRS,0           TEST POSITION FLAG
         $SRA  8                   MOVE LEFT TO RIGHT
         $SLA  8                   AND/OR RIGHT TO LEFT
         $BZ   SDBLOCK,,I          EXIT IF END-OF-BUFFER
         $STX  DBLKSVA+D1,WA,L     SAVE WA
         $ZAC                      CLEAR AC AND
         $STO  DBLKPLR,,L           RESET POSITION FLAG
         $STO  DBLKTOT               AND STRING TOTAL
***********************************************************************
*              ISOLATE AND SAVE SRCB AND SCB                          *
***********************************************************************
         $LD   DBLKLRS             GET RCB/SCB POSITION FLAG
         $BOD  DBLKLJF             BRANCH IF RCB LEFT JUSTIFIED
         $LD   0,WC                GET SRCB/RCB WORD
         $SRA  8                   ISOLATE SRCB
         $STO  DBLKSRC              AND SAVE IT
         $LD   0,WC                GET SRCB/SCB WORD
         $AND  DBLKCLH             CLEAR LEFT HALF
         $B    DBLKSVS             GO SAVE AND TEST SCB
DBLKLJF  $LD   -1,WC               GET RCB/SRCB WORD
         $AND  DBLKCLH             CLEAR LEFT HALF
         $STO  DBLKSRC              AND SAVE SRCB
         $LD   0,WC                GET SCB WORD
         $SRA  8                   CLEAR WHATEVER
DBLKSVS  $STO  DBLKSCB              AND SAVE SCB
***********************************************************************
*              TEST FOR END-OF-FILE (FIRST SCB=0)                     *
***********************************************************************
         $BNZ  DBLKING             BRANCH IF NOT EOF
         $LD   DBLKBIG             SET COUNT TO MAXIMUM
         $STO  DBLKTOT              TO PREVENT EXIT EOB
         $ZAC                      CLEAR AC AND
         $STO  DBLKSRC              SETUP FOR EOF
         $B    DBLKEOR             GO TO EXIT PROCESS
***********************************************************************
*              COMMENCE DEBLOCKING PROCESS                            *
***********************************************************************
DBLKING  $SRT  7                   SCB SANS SIGN TO EXT
         $ZAC                      CLEAR AC
         $SLT  1                   GET SUBSTRING ID BIT
         $BOD  DBLKCSS             BRANCH IF CHARACTER SUBSTRING
         $SLT  1                   GET PROPAGATION BIT
         $BOD  DBLKCPR             BRANCH IF CHARACTER PROPAGATION
***********************************************************************
*              BLANK PROPAGATION TIME                                 *
***********************************************************************
         $SRA  2                   CLEAR AC
         $SLT  5                   PROPAGATION COUNT
         $BSI  DBLKACC             GO ACCUMULATE TOTAL
         $STL  DBLKPOP             SET BLANK PROPAGATION FLAG
         $BSI  $FCBSTO,WB,I        GO ADJUST VARIOUS POINTERS
         $ZAC                      CLEAR AC AND
         $STO  DBLKPOP              RESET PROPAGATION FLAG
         $LD   DBLKLRS             GET SCB POSITION FLAG
         $EOR  DBLKCN1             INVERT AND SWITCH
         $STO  DBLKLRS             TO NEW POSITION
DBLKSTO  $A    DBLKSPT             ADJUST
         $STO  DBLKSPT              POINTER
***********************************************************************
*              GET NEXT SCB AND TEST FOR END-OF RECORD                *
***********************************************************************
DBLKGET  $LD   DBLKSPT,,I          GET SCB WORD
         $MDM  DBLKLRS,0           TEST POSITION FLAG
         $SRA  8                   RIGHT JUSTIFY SCB
         $AND  DBLKCLH             CLEAR LEFT HALF
         $STO  DBLKSCB             SAVE SCB
         $BNZ  DBLKING             BRANCH IF NOT EOR
***********************************************************************
*              END-OF-RECORD (SCB=0) DETECTED                         *
***********************************************************************
DBLKEOR  $LD   DBLKLRS             SET
         $EOR  DBLKCN1              NEW
         $STO  UFCBPBS,WB,X          POSITION
         $A    DBLKSPT                AND
         $STO  UFCBPBA,WB,X            RCB
DBLKSVA  $AXT  *-*,WA,L            RESTORE WA
         $LD   DBLKSRC             SET
         $STO  TANKWRDC,WA,X        SRCB
         $LD   DBLKTOT               AND
         $STO  TANKWRDD,WA,X         COUNT
         $B    SDBLOCK,,I           AND RETURN TO CALLER
DBLKBPC  DC    AL2(*-*)            PROPAGATION COUNT
***********************************************************************
*              PUT CHARACTER DATA IN TANK AND/OR ADJUST POINTERS      *
***********************************************************************
DBLKPUT  DC    AL2(*-*)            AC CONTAINS CHARACTER OR COUNT
         $MDM  DBLKPOP,0           TEST FOR BLANK PROPAGATION
         $B    DBLKPAP             BRANCH IF BLANK PROPAGATION
         $MDM  DBLKPLR,0           TEST TARGET WORD POSITION FLAG
         $B    DBLKPSR             BRANCH IF DATA TO RIGHT HALF
         $AND  DBLKPCR             CLEAR RIGHT HALF OF INPUT
         $OR   DBLKPDS             FORM PARTIAL DATA WORD
DBLKPXT  $STO  TANKWRDE,WA,X        AND STORE IN SPECIFIED TANK
         $LD   DBLKPLR             GET WORD POSITION FLAG
         $SKPZ                     SKIP IF WORD NOT FULL
         $MDX  1,WA                 OR POINT TO NEXT WORD
         $EOR  DBLKPC1             INVERT
DBLKPXE  $STO  DBLKPLR              FLAG
         $B    DBLKPUT,,I          EXIT
DBLKPSR  $RTE  16                  DATA TO EXT
         $LD   TANKWRDE,WA,X       TARGET WORD TO AC
         $SRA  8                    UPTIGHT TO DATA BYTE
         $SLT  8                     FORM NEW TARGET WORD
         $B    DBLKPXT                GO STORE IN TANK
DBLKPAP  $SRA  1                   DIVIDE PROPAGATION COUNT
         $STO  DBLKPTO             SAVE COUNT/2
         $LD   DBLKACT             GET ORIGINAL COUNT
         $AND  DBLKPC1             REDUCE TO EVEN/ODD BIT
         $STO  DBLKPTT             SAVE EVEN/ODD BIT
         $LD   DBLKPLR             GET PUT POSITION FLAG
         $AND  DBLKPTT             CALCULATE
         $A    DBLKPTO              NEW
         $A    WA,,L                 WORD
         $STO  WA,,L                  POINTER
         $LD   DBLKPTT                 AND
         $EOR  DBLKPLR                  PUT
         $B    DBLKPXE                   FLAG
DBLKPOP  DC    AL2(*-*)            SET NON-ZERO IF BLANK PROPAGATION
DBLKPC1  DC    AL2(1)              CONSTANT ONE
DBLKPLR  DC    AL2(*-*)            STORE LEFT/RIGHT FLAG
DBLKPCR  DC    AL2(X'FF00')        CLEAR RIGHT HALF
DBLKPDS  DC    AL2(*-*)            PARTIAL DATA WORD SKELETON
DBLKPTO  DC    AL2(*-*)            PROPAGATION COUNT/2
DBLKPTT  DC    AL2(*-*)            COUNT EVEN/ODD BIT
***********************************************************************
*              STORE WORD VALUE IN TANK AND/OR UPDATE POINTER         *
***********************************************************************
DBLKSTF  DC    AL2(*-*)            AC CONTAINS WORD OR COUNT
         $MDM  DBLKPOP,0           TEST FOR BLANK PROPAGATION
         $B    DBLKSAP             BRANCH IF BLANK PROPAGATION
         $STO  TANKWRDE,WA,X       STORE INPUT IN TANK
         $MDX  1,WA                STEP TO NEXT WORD
         $B    DBLKSTF,,I          EXIT
DBLKSAP  $A    WA,,L               INCREMENT
         $STO  WA,,L                POINTER
         $B    DBLKSTF,,I          EXIT
***********************************************************************
*              FILL OUTPUT TANK WITH SPECIFIED VALUE                  *
***********************************************************************
TPGTFIL  DC    AL2(*-*)            FILLER WORD IN AC
         $STX  TPGTFLS+D1,WA       TANK ADDRESS IN WA
         $STO  TPGTFWD             SAVE FILLER IN ODD LOCATION
         $LD   UFCBPWD,WB,X        GET WIDTH OF TARGET (EVEN)
         $STO  WC,,L               SET COUNT IN WC
         $LDD  TPGTFWD             FILLER TO AC AND EXT
TPGTFLP  $STD  TANKWRDE,WA,X        THEN TO TANK
         $MDX  2,WA                STEP TO NEXT PAIR
         $MDX  -4,WC               DECREMENT AND TEST COUNT
         $B    TPGTFLP             BRANCH IF MORE
TPGTFLS  $AXT  *-*,WA,L            RESTORE WA
         $B    TPGTFIL,,I          RETURN TO CALLER
         $BSS  0,E
         DC    AL2(0)              FILLER FILLER
TPGTFWD  DC    AL2(*-*)            FILLER STORAGE
         AIF   (&PR1132 EQ 0).NO1132Z
***********************************************************************
*              NUMERIC DATA CHECKER FOR 1132 PRINT DATA               *
***********************************************************************
DBLKNCK  DC    AL2(*-*)            ENTRY WITH EBCDIC IN 8-15
         $SLA  8                   PROVIDE NUMERIC CHECK
         $B    DBLKNCK,,I           AT A LATER DATE...
.NO1132Z ANOP
         TITLE 'RTP1130 (TPPUT - PROCESS TP BUFFERS DESTINED FOR HASP)'
***********************************************************************
* TITLE - TPPUT (PROCESSOR FOR DATA DESTINED FOR HASP)                *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  ACQUIRES A TP BUFFER FROM THE FREE CHAIN AND COLLECTS DATA         *
*  FROM DEFINED SOURCES TO BE PROCESSED (CONVERTED,TRUNCATED,         *
*  COMPRESSED OR WHATEVER) AND INSERTED INTO THE BUFFER               *
*  WHICH IS QUEUED FOR TPIOX TRANSMISSION TO HASP.                    *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              TPPUT PROCESSOR TRANSFER VECTOR TABLE                  *
***********************************************************************
TPPTVCT  $NULL                     TRANSFER VECTOR REFERENCE POINT
         $ADCON (TPPTCRC)          CONTROL RECORD PROCESSOR
         AIF   (&RD2501 EQ 0).NO25012
         $ADCON (TPPTTFO)          2501 INPUT PROCESSOR
.NO25012 ANOP
         AIF   (NOT &RD1442).NO14423
         $ADCON (TPPTFFT)          1442 INPUT PROCESSOR
.NO14423 ANOP
         $ADCON (TPPTCLX)          CONSOLE INPUT PROCESSOR
         $ADCON (TPPTEND)          END OF PROCESSOR PROCESSOR
         SPACE 3
***********************************************************************
*              TPPUT STORAGE,CONSTANTS,ETC.                           *
***********************************************************************
TPPTBFP  DC    AL2(*-*)            BUFFER POINTER
TPPTHDR  $NULL                     BUFFER HEADER
         AIF   (&TRANPRN EQ 0).NOXPRN0
         DC    AL2($BSXTTT)        TRANSPARENT TEXT HEADER
         AGO   .NOXPRN1
.NOXPRN0 ANOP
         DC    AL2($BSXTNT)        NORMAL TEXT HEADER
.NOXPRN1 ANOP
TPPTCRL  DC    AL1(X'80',4)        CONTROL RECORD LENGTH
TPPTCRD  DC    AL1(*-*,*-*,0,0)    CONTROL RECORD SKELETON
TPPTCNT  DC    AL2(5)              INITIAL DATA COUNT FOR TPBUILD
TPPTRCN  DC    AL2(&TPBFSZE-11)    INITIAL RESIDUAL BUFFER COUNT
TPPTMAX  DC    AL2(&NPTFBFL)       INPUT BUFFER LIMIT
TPPTCN1  DC    AL2(1)              CONSTANT ONE
***********************************************************************
*              TPPUT ENTRY POINT FROM COMMUTATOR                      *
***********************************************************************
TPPUTEP  $NULL
TPPUTVE  $B    TPPUTNI,,L          VARIABLE ENTRY POINT
TPPUTNP  $B    TPPUTRT,,L          NON-PROCESS EXIT POINT
TPPUTXT  $BSI  TPPUTVE+D1          RESET ENTRY AND LEAVE
TPPUTNI  $NULL                     INITIAL ENTRY POINT
         $LD   SPUTBFCT,,L         GET NUMBER OF ACTIVE BUFFERS
         $S    TPPTMAX             TEST FOR MAXIMUM ALLOWED
         $BZ   TPPUTRT             CYCLE IF MAXIMUM REACHED
         $DEQUE TPBUFFQP           GET A FREE BUFFER FROM CHAIN
         $BZ   TPPUTRT             NON-PROCESS EXIT IF NONE
         $STO  TPPTBFP             SAVE BUFFER ADDRESS
         $LXA  TPPTBFP,WA          TO WA
         $LD   TPPTHDR             SET BUFFER HEADER VALUE
         $STO  TPBUFHD,WA,X         TO APPROPRIATE INDICATOR
         $LD   TPPTCNT             SET TPBUILD  VALUES
         $STO  TPBLCNT,,L           DATA COUNT..
         $LD   TPPTRCN               RESIDUAL
         $STO  TPBLRSC,,L             COUNT..
         $MDX  TPBUFFR,WA,X        SET TPBUILD
         $STX  TPBLTRG+D1,WA,L      DATA POINTER
         $LD   SPUTBFCT,,L         INCREMENT
         $A    TPPTCN1              ACTIVE
         $STO  SPUTBFCT,,L           COUNT
***********************************************************************
*              PROCESSOR SELECTION BASED ON ORDER OF TPPTVCT          *
***********************************************************************
TPPTSQI  $AXT  *-*,WB,L            LOAD PROCESS SEQUENCE INDEX
         $B    TPPTVCT,WB,I        GO TO SELECTED PROCESS
         EJECT
***********************************************************************
*              CONTROL RECORD CHECKER                                 *
***********************************************************************
TPPTCRC  $NULL
         $LD   SCRQUEUE,,L         GET CONTROL RECORD INDICATOR
         $BZ   TPPTSTP             STEP TO NEXT PROCESS IF NONE
         $STO  WC,,L               UFCB ADDRESS TO WC
         $ZAC                      CLEAR AC AND SHOW
         $STO  SCRQUEUE,,L          CONTROL RECORD PROCESSED
         $LD   UFCBSAR,WC,X        GET UFCB CONTROL RECORD VALUE
         $STO  TPPTCRD              AND BUILD CONTROL RECORD WITH EOB
         $LD   TPPTCRL             CONTROL RECORD LENGTH
         $AXT  TPPTCRD,WB,L         AND ADDRESS
         $TSL  TPBUILD             INSERT CONTROL RECORD AND EOB
***********************************************************************
*              QUEUE TP BUFFER FOR TPIOX                              *
***********************************************************************
TPPTQBF  $LD   TPBLCNT,,L          GET COUNT OF DATA
         $LXA  TPPTBFP,WA          ADDRESS OF BUFFER
         $STO  TPBUFCB,WA,X        STORE COUNT IN BUFFER
         $LD   TPPTBFP             BUFFER POINTER
         $QACTL TPBUFOQP           QUEUE BUFFER FOR TPIOX
         $B    TPPUTXT,,L          EXIT AND SET ENTRY TO BEGINNING
         EJECT
         AIF   (&RD2501 EQ 0).NO25011
***********************************************************************
*              INPUT PROCESSOR FOR 2501 READER                        *
***********************************************************************
TPPTTFV  $ADCON (TPPTTFI)          INITIAL ENTRY POINT
         $ADCON (TPPTTFG)          INSERT RETRY ENTRY POINT
TPPTTFO  $AXT  *-*,WB,L            GET SUBPROCESS INDEX
         $B    TPPTTFV,WB,I        OFF TO SUBPROCESS
TPPTTFI  $LD   SRDTTANK,,L         TEST FOR 2501 INPUT
         $BZ   TPPTSTP             STEP TO NEXT PROCESS IF NO INPUT
         $AXT  RDTFUFCB,WC,L       2501 UFCB ADDRESS TO WC
         $TSL  TPCOMPR             OFF TO CONSTRUCT RECORD
         $STO  TPPTRCL             SAVE LENGTH OF RECORD
         $TSL  TPPUTVE+D1          CYCLE COMMUTATOR
TPPTTFG  $LD   TPPTRCL             RESTORE LENGTH OF INSERT
         $AXT  RDTFUFCB,WC,L       REFRESH WC IF BUFFER TERMINATED
         $LXA  SRDTTANK,WB         ADDRESS OF RECORD FOR TPBUILD
         $TSL  TPBUILD             INSERT RECORD IN CURRENT BUFFER
         $BNZ  TPPTTFM             BRANCH IF NOT ENOUGH ROOM
         $STO  UFCBFQP,WC,X        RETURN INPUT TANK
         $STO  TPPTTFO+D1          RESET SUBPROCESS TO BEGINNING
         $LD   UFCBBFP,WC,X        GET END-OF-FILE FLAG FROM UFCB
         $BNZ  TPPTEOF              AND BRANCH IF EOF ON INPUT DEVICE
         $B    TPPTSTP             STEP TO NEXT SEQUENCE
TPPTTFM  $MDM  TPPTTFO+D1,1        STEP TO NEXT SUBPROCESS
         $B    TPPTERM,,L          GO TERMINATE THIS BUFFER
TPPTRCL  DC    AL2(*-*)            RECORD LENGTH STORAGE
.NO25011 ANOP
         EJECT
***********************************************************************
*              WRITE END-OF-FILE AND TERMINATE BUFFER                 *
***********************************************************************
TPPTEOF  $NULL
         $LD   UFCBSAR,WC,X        GET RCB CODE FROM UFCB
         $SLA  8                   RCB TO HIGH ORDER AC
         $OR   TPPTEFX             FORM
         $STO  TPPTEFS              EOF
         $LD   TPPTEFL             BYTE COUNT
         $AXT  TPPTEFS,WB,L        EOF SEQUENCE ADDRESS
         $TSL  TPBUILD             INSERT EOF,EOB SEQUENCE
         $ZAC                      CLEAR DEVICE
         $STO  UFCBBFP,WC,X         EOF IN UFCB
         $B    TPPTQBF             QUEUE BUFFER FOR HASP
TPPTEFX  DC    AL1(0,X'80')        SKELETON RCB, SRCB
TPPTEFL  DC    AL1(X'80',4)        BYTE COUNT OF EOF,EOB SEQUENCE
TPPTEFS  DC    AL1(*-*,X'80',0,0)  RCB(X)-SRCB-SCB(0)-RCB(0)
         EJECT
         AIF   (NOT &RD1442).NO14425
***********************************************************************
*              INPUT PROCESSOR FOR 1442 READER                        *
***********************************************************************
TPPTFFV  $ADCON (TPPTFFI)          INITIAL ENTRY POINT
         $ADCON (TPPTFFG)          RETRY INSERT ENTRY POINT
TPPTFFT  $AXT  *-*,WB,L            GET SUBPROCESS INDEX
         $B    TPPTFFV,WB,I        OFF TO SELECTED SUBPROCESS
TPPTFFI  $LD   SRPFTANK,,L         TEST FOR 1442 INPUT
         $BZ   TPPTSTP             STEP TO NEXT PROCESS IF NONE
         $AXT  RDFFUFCB,WC,L       1442 READER UFCB ADDRESS
         $LD   TPPTF80             REFRESH
         $STO  SRPFTANK,,I          COUNT
         $TSL  TPCOMPR             GO CONSTRUCT A RECORD
         $STO  TPPTRCX             SAVE RECORD LENGTH
         $TSL  TPPUTVE+D1          CYCLE COMMUTATOR
TPPTFFG  $LD   TPPTRCX             RESTORE RECORD LENGTH
         $AXT  RDFFUFCB,WC,L       REFRESH WC IF BUFFER TERMINATED
         $LXA  SRPFTANK,WB         ADDRESS OF RECORD FOR TPBUILD
         $TSL  TPBUILD             INSERT RECORD IN CURRENT BUFFER
         $BNZ  TPPTFFM             BRANCH IF NOT ENOUGH ROOM
         $STO  UFCBFQP,WC,X        RETURN INPUT TANK
         $STO  TPPTFFT+D1          RESET SUBPROCESS TO BEGINNING
         $LD   UFCBBFP,WC,X        GET END-OF-FILE FLAG FROM UFCB
         $BNZ  TPPTEOF              AND BRANCH IF EOF ON INPUT DEVICE
         $B    TPPTSTP             STEP TO NEXT PROCESS
TPPTFFM  $MDM  TPPTFFT+D1,1        STEP TO NEXT SUBPROCESS
         $B    TPPTERM,,L          GO TERMINATE THIS BUFFER
TPPTF80  DC    AL2(80)             INPUT COUNT
TPPTRCX  DC    AL2(*-*)            RECORD LENGTH STORAGE
.NO14425 ANOP
         EJECT
***********************************************************************
*              PROCESSOR EXIT PROCEDURE                               *
***********************************************************************
TPPTSTP  $NULL
         $MDM  TPPTSQI+D1,1        STEP TO NEXT PROCESSOR
TPPTRXT  $AXT  TPPTSQI,WB,L        RESET VARIABLE ENTRY TO
         $STX  TPPUTVE+D1,WB,L      SEQUENCE SELECTOR
         $B    TPPUTRT,,L          CYCLE COMMUTATOR
***********************************************************************
*              LAST PROCESS PROCESSOR                                 *
***********************************************************************
TPPTEND  $NULL
         $ZAC                      RESET
         $STO  TPPTSQI+D1,,L        SELECTOR
         $B    TPPTRXT             EXIT
***********************************************************************
*              TERMINATE CURRENT BUFFER PROCESSING                    *
***********************************************************************
TPPTERM  $NULL
         $LD   TPPTNDL             LENGTH OF INSERT
         $AXT  TPPTNDA,WB,L        ADDRESS OF EOB RCB
         $TSL  TPBUILD             TRUNCATE BUFFER
         $B    TPPTQBF,,L          GO QUEUE BUFFER
TPPTNDL  DC    AL1(X'80',1)        EOB LENGTH
TPPTNDA  DC    AL2(0)              EOB RCB
***********************************************************************
*              CONSOLE INPUT PROCESSOR                                *
***********************************************************************
TPPTCNP  $NULL
TPPTCTV  $ADCON (TPPTCNI)          INITIAL ENTRY POINT
         $ADCON (TPPTCRI)          RETRY ENTRY POINT
TPPTCLX  $AXT  *-*,WB,L            GET SUBPROCESS INDEX
         $B    TPPTCTV,WB,I        OFF TO SELECTED SUBPROCESS
TPPTCNI  $LD   SCONTANK,,L         TEST FOR KEYBOARD INPUT
         $BZ   TPPTSTP             STEP TO NEXT PROCESS IF NONE
         $AXT  CNSKUFCB,WC,L       CONSOLE KEYBOARD UFCB ADDRESS
         $TSL  TPCOMPR             GO CONSTRUCT A RECORD
         $STO  TPPTCDC             SAVE LENGTH OF INSERT
TPPTCRI  $LD   TPPTCDC             RESTORE IF BUFFER FULL
         $AXT  CNSKUFCB,WC,L       REFRESH FOR SAME REASON
         $LXA  SCONTANK,WB         ADDRESS OF RECORD FOR TPBUILD
         $TSL  TPBUILD             INSERT RECORD IN BUFFER
         $BNZ  TPPTCXT             BRANCH IF NOT ENOUGH ROOM
         $STO  UFCBFQP,WC,X        FREE INPUT TANK
         $STO  TPPTCLX+D1          RESET SUBPROCESS TO BEGINNING
         $B    TPPTERM             GO TERMINATE BUFFER
TPPTCXT  $MDM  TPPTCLX+D1,1        STEP TO NEXT SUBPROCESS
         $B    TPPTERM             GO TERMINATE BUFFER
TPPTCDC  DC    AL2(*-*)            RECORD LENGTH
         EJECT
***********************************************************************
*                                                                     *
* TITLE - TPCOMPR (MULTILEAVING RECORD CONSTRUCTION)                  *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  CONSTRUCTS A LOGICAL RECORD CONSISTING OF A PHYSICAL INPUT RECORD  *
*  WHICH IS TRANSLATED, COMPRESSED, TRUNCATED AND ENRICHED WITH       *
*  CONTROL BYTES NECESSARY FOR PROCESSING BY HASP.                    *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL  TPCOMPR   LINKAGE                 *
*                             ....            RETURN                  *
*                                                                     *
*                   WHERE --- (ON ENTRY) REGISTER WC CONTAINS         *
*                             ADDRESS OF UFCB FOR SOURCE DEVICE       *
*                                                                     *
*                             (ON EXIT) AC CONTAINS LENGTH OF         *
*                             PROCESSED RECORD (IN BYTES)             *
*                             REGISTERS WA, AND WC ARE SAVED AND      *
*                             RESTORED. AC, EXT AND WB ARE USED       *
*                             BUT NOT RESTORED.                       *
*                                                                     *
*                             PROCESSED RECORD IS CONTAINED           *
*                             IN ORIGINAL TANK DESIGNATED             *
*                             BY INPUT UFCB....                       *
*                                                                     *
*  NOTE..THIS VERSION OF TPCOMPR ASSUMES CARD CODE INPUT RATHER       *
*  THAN INTERROGATING THE INPUT CODE SPECIFIED BY THE UFCBNO          *
*  FIELD FOR THE INPUT RECORD AND PROCESSING ACCORDING TO THE         *
*  INDICATED VALUE. THE CHANGES REQUIRED TO SUPPORT VARIABLE          *
*  INPUT CODES ARE NOT EXTENSIVE.                                     *
*                                                                     *
***********************************************************************
         EJECT
         AIF   (&CMPTYPE GT 1).CMPT100
TPCOMPR  DC    AL2(*-*)
***********************************************************************
*              INITIALIZATION                                         *
***********************************************************************
         $STX  TPCO420+D1,WA,L     SAVE INDEX WA.
         $STX  TPCO410+D1,WC,L     SAVE INDEX WC.
         $LD   UFCBFQP,WC,X        POINT TO FIRST OF INPUT WDS- COUNT.
         $STO  TPCO110+D1          STORE THE
         $STO  TPCO120+D1            POINTER IN
         $STO  TPCO200+D1              ALL OF THE
         $STO  TPCO220+D1                EXCLUSIVE OR'S.
         AIF   (&CMPTYPE LT 1).CMPT010
         $STO  TPCO010+D1          STORE THE POINTER FOR TRUNCATION.
.CMPT010 ANOP
         $A    TPCOC1              UP POINTER TO FIRST TEXT WORD.
         $STO  TPCO100+D1          STORE
         $STO  TPCO130+D1           THIS
         $STO  TPCO140+D1            POINTER
         $STO  TPCO150+D1             IN
         $STO  TPCO210+D1              LOADS
         $STO  TPCO250+D1               AND
         $STO  TPCOP010+D1,,L            STORES.
         $STO  TPCOFRST            SAVE POINTER TO FIRST TEXT WORD.
         AIF   (&CMPTYPE LT 1).CMPT020
         $LXA  TPCO110+D1,WA       GET POINTER TO COUNT WORD.
         $LD   0,WA                GET NUMBER OF WORDS OF TEXT.
         $STO  WB,,L               PUT IT IN WB FOR TRUNCATION.
***********************************************************************
*              TRUNCATE TRAILING BLANKS.  START WITH LAST WORD.       *
***********************************************************************
TPCO010  $LD   *-*,WB,L            GET A WORD OF TEXT, AND
         $BNZ  TPCO020             BRANCH IF IT'S NON-BLANK.
         $MDX  -1,WB               OTHERWISE, POINT TO PREVIOUS
         $B    TPCO010             WORD AND LOOP.
***********************************************************************
*              ALL BLANKS ARE TRUNCATED AND NOTHING'S LEFT.           *
***********************************************************************
         $LD   UFCBFQP,WC,X        POINT TO THE FIRST INPUT WORD.
         $STO  WB,,L               RETURN POINTER IN INDEX WB.
         $LD   UFCBSAR,WC,X        NOW GET THE RECORD CONTROL BYTE
         $SLA  8                   AND LEFT-JUSTIFY IT IN THE ACC.
         $OR   TPCOX80             PUT AN SRCB TO ITS RIGHT.
         $STO  0,WB                STORE AS FIRST 2 BYTES OF OUTPUT.
         $LD   TPCOBLNK            THEN GET X'8100', A SINGLE-BLANK SCB
         $STO  1,WB                AND AN EOR SCB, FOR 2D 2 BYTES.
         $LD   TPCOC4              LOAD THE ACC WITH COUNT OF 4,
         $B    TPCOMPR,,I          AND RETURN TO THE CALLER.
***********************************************************************
*              HERE AT END OF TRUNCATION.                             *
***********************************************************************
TPCO020  $LD   WB,,L               THEN PICK UP TRUNCATED COUNT,
         $A    TPCOC1              UP IT BY 1, AND COMPARE
         $S    0,WA                WITH ORIGINAL COUNT.
         $BNN  TPCO030             BRANCH IF NO TRUNCATION.
         $A    0,WA                OTHERWISE, RESTORE TRUNCATED
         $STO  0,WA                COUNT AND SET COUNT WORD.
.CMPT020 ANOP
TPCO030  $LD   TPCO110+D1,,I       PICK UP THE COUNT
         $STO  TPCOCNT             AND SAVE IT.
         $S    TPCOC1              SUBTRACT 1 FROM IT, AND SET
         $STO  WA,,L               WA TO THE BACKWARD SCAN COUNT.
***********************************************************************
*              TAKE CARE OF RECORD AND SUB-RECORD CONTROL BYTES.      *
***********************************************************************
         $LD   UFCBSAR,WC,X        GET THE RECORD CONTROL BYTE.
         $SLA  8                   LEFT-JUSTIFY IT IN THE ACC.
         $OR   TPCOX80             STICK AN SRCB TO ITS RIGHT.
         $STO  TPCO110+D1,,I       CLOBBER COUNT WORD WITH RCB+SRCB.
         $LD   WA,,L               CHECK FOR ONE WORD ONLY OF TEXT.
         $BZ   TPCO390             BRANCH IF SO.
***********************************************************************
*              NOW PERFORM THE BACKWARD SCAN.                         *
***********************************************************************
TPCO100  $LD   *-*,WA,L            GET A WORD OF TEXT, AND SEE IF
TPCO110  $EOR  *-*,WA,L            IT'S EQUAL TO THE PREVIOUS WORD.
         $BZ   TPCO200             BRANCH IF THE TWO WORDS ARE EQUAL.
TPCO120  $EOR  *-*,WA,L            OTHERWISE, RESTORE THE WORD, AND
         $TSL  SXPRESS             GO TRANSLATE IT.
         $SKPN                     IF TRANSLATED WORD IS ZERO, ADD IN
         $OR   TPCOX100            X'0100' TO MAKE IT NONZERO FOR PACK.
TPCO130  $STO  *-*,WA,L            THEN STORE THE RESULT BACK IN WORD.
TPCO135  $MDX  -1,WA               LOWER THE RELATIVE POINTER BY 1,
         $B    TPCO100             AND GO DO THE NEXT-LOWER WORD.
TPCO140  $LD   *-*,,L              WHEN WE FALL THROUGH,
         $TSL  SXPRESS             TRANSLATE THE FIRST WORD OF TEXT.
         $SKPN                     IF THE RESULTANT EBCDIC BYTE IS ZERO
         $OR   TPCOX100            THEN FORCE THE WORD TO NON-ZERO.
TPCO150  $STO  *-*,,L              THEN SET THE TRANSLATED FIRST WORD,
         $SLT  16                  ZERO OUT THE EXT,
         $B    TPCO300             AND GO PACK.
TPCO200  $EOR  *-*,WA,L            RESTORE THE WORD OF TEXT.
         $TSL  SXPRESS             GO TRANSLATE IT TO EBCDIC.
         $SKPN                     IF RESULTANT BYTE IS ZERO,
         $OR   TPCOX100            FORCE THE WORD TO NONZERO.
         $RTE  16                  SAVE THE RESULT IN THE EXT.
         $LXA  WA,WB               SAVE WA IN WB.
         $AXT  2,WC                SET INITIAL DUPLICATE COUNT TO 2.
         $B    TPCO230             NOW FIND NUMBER OF DUPLICATES.
TPCO210  $LD   *-*,WA,L            GET THE NEXT-LOWER WORD AND
TPCO220  $EOR  *-*,WA,L            COMPARE WITH WORD BEFORE IT.
         $BNZ  TPCO240             IF UNEQUAL,TO DO THE DUPLICATES.
         $MDX  1,WC                OTHERWISE, UP DUP COUNT BY 1,
TPCO230  $MDX  -1,WA               POINT TO NEXT-LOWER WORD,
         $B    TPCO210             AND GO DO NEXT LOWER WORD.
***********************************************************************
*              STORE EBCDIC IN DUP WORDS, AVOIDING $XPRESS CALLS      *
***********************************************************************
TPCO240  $RTE  16                  PUT THE EBCDIC CHAR INTO ACC.
TPCO250  $STO  *-*,WB,L            STORE THE DUPLICATE IN A WORD.
         $MDX  -1,WC               REDUCE DUPLICATE COUNT BY 1.
         $B    TPCO260             BRANCH IF MORE TO GO.
         $B    TPCO135             OTHERWISE RESUME NON-DUPLICATE SCAN.
TPCO260  $MDX  -1,WB               POINT TO THE PRECEDING WORD
         $B    TPCO250             AND GO STORE IN IT.
         $B    TPCO150             OTHERWISE GO DO THE LAST STORE.
***********************************************************************
*              CONSTANTS                                              *
***********************************************************************
TPCOCNT  DC    AL2(*-*)
TPCOC1   DC    AL2(1)
TPCOC63  DC    AL2(63)
TPCOFRST DC    AL2(*-*)
TPCOXC0  DC    AL2(X'C0')
TPCOX100 DC    AL2(X'100')
TPCOX80  DC    AL2(X'80')
TPCOBLNK DC    AL2(X'8100')
TPCOC4   DC    AL2(4)
TPCOXC1  DC    AL2(X'C1')
***********************************************************************
*              NOW INSERT SCB'S AND PACK.                             *
***********************************************************************
TPCO300  $LXA  TPCOFRST,WA         INITIALIZE- POINT WA TO 1ST TXT WD.
TPCO310  $LD   TPCOCNT             PICK UP THE REMAINING COUNT.
         $BNP  TPCO400             BRANCH IF ALL DONE TO CLEAN UP.
         $S    TPCOC63             OTHERWISE, COMPARE COUNT WITH 63.
         $STO  TPCOCNT             (SAVE UPDATED COUNT.)
         $BSC  N                   SKIP IF COUNT IS .LT. 63.
         $ZAC                      OTHERWISE, ZERO OUT THE ACC.
         $A    TPCOC63             ADD 63 TO ACC FOR COUNT.
         $STO  WB,,L               STICK THE COUNT IN INDEX WB.
         $OR   TPCOXC0             ADD SCB BITS TO THE COUNT.
         $BSI  TPCOPACK            GO PACK THE SCB.
TPCO320  $LD   0,WA                THEN PACK EACH CHARACTER
         $BSI  TPCOPACK            OF THE CHARACTER STRING.
         $MDX  1,WA                POINT TO THE NEXT CHARACTER,
         $MDX  -1,WB               LOWER THE COUNT BY ONE,
         $B    TPCO320             AND PACK AGAIN.
         $B    TPCO310             THEN TRY FOR ANOTHER STRING.
***********************************************************************
*              SINGLE CHARACTER OF TEXT, I.E., TEXT COUNT IS 1.       *
***********************************************************************
TPCO390  $LD   TPCOXC1             GET A SINGLE-CHARACTER SCB, AND
         $BSI  TPCOPACK            PACK IT INTO OUTPUT.
         $LD   TPCOP010,,I         GET THE ONLY TEXT CHARACTER.
         $TSL  SXPRESS             TRANSLATE IT TO EBCDIC.
         $SKPN                     SKIP IF RESULT IS NONZERO.
         $OR   TPCOX100            OTHERWISE ADD A BIT FOR PACK.
         $BSI  TPCOPACK            THEN PACK IT INTO THE OUTPUT.
***********************************************************************
*              CLEAN UP AND RETURN TO CALLER.                         *
***********************************************************************
TPCO400  $LD   TPCOX100            GET EOR SCB PLUS A BIT FOR PACK.
         $BSI  TPCOPACK            PACK THE END-OF-RECORD SCB.
         $LD   TPCOC1              GET THE CONSTANT '1' AND PACK
         $BSI  TPCOPACK            IT FOR LENGTH DETERMINATION.
TPCO410  $LDX  *-*,WC,L            RESTORE INDEX WC, THE UFCB POINTER.
         $LD   UFCBFQP,WC,X        POINT TO INPUT AREA AS THE OUTPUT.
         $STO  WB,,L               SET WB TO POINT TO THE OUTPUT.
         $LD   TPCOP010+D1         POINT TO WD AFTER LAST WORD PACKED.
         $S    UFCBFQP,WC,X        SUBTRACT POINTER TO INPUT AREA.
         $SLA  1                   MULTIPLY WORDS BY 2 FOR BYTES.
         $STO  WA,,L               STICK THE COUNT IN WA TEMPORARILY.
         $RTE  16                  PUT THE EXT INTO THE ACC.
         $SKPN                     SKIP IF THE EXT WASN'T ZERO.
         $MDX  -1,WA               THE BYTE COUNT BY ONE.
         $LD   WA,,L               RETURN TRUE BYTE COUNT IN ACC.
TPCO420  $LDX  *-*,WA,L            RESTORE THE CALLER'S WA,
         $LXA  TPCOFRST,WB         POINT TO SECOND WD OF INPUT, AND SUB
         $MDX  -1,WB               TRACT 1 TO POINT TO FIRST WORD.
         $B    TPCOMPR,,I          THEN RETURN TO THE CALLER.
         AGO   .CMPT200
.CMPT100 ANOP
         AIF   (NOT &DOCUMNT).NODOC01
*                                                                     *
*      THIS ROUTINE TRANSLATES, COMPRESSES, AND TRUNCATES A VARIABLE- *
* LENGTH 1130-CARD-CODE RECORD INTO VARIOUS CONTROL BYTES AND EBCDIC  *
* CHARACTERS, AND PACKS THEM TWO TO A WORD.  THE CONTROL BYTES ARE-   *
* ONE RECORD CONTROL BYTE (RCB), THE FIRST BYTE OF THE OUTPUT.  ONE   *
* SUB-RECORD CONTROL BYTE (SRCB), THE SECOND BYTE OF THE OUTPUT.      *
* SEVERAL STRING CONTROL BYTES (SCB'S), OF WHICH THE FIRST SCB IS THE *
* THIRD BYTE OF THE OUTPUT, AND THE LAST SCB IS THE END-OF-RECORD     *
* (EOR) SCB.  EACH SCB, EXCEPT THE EOR SCB AND THE SCB DESCRIBING A   *
* COMPRESSED STRING OF BLANKS, IS FOLLOWED BY ONE OR MORE CHARACTERS. *
* THESE CHARACTERS CONSTITUTE THE STRING DESCRIBED BY THE SCB.        *
*                                                                     *
*      TRANSLATION IS THE PROCESS OF CONVERTING A CARD-CODE WORD TO   *
* AN EBCDIC BYTE.  THIS ROUTINE USES SYSTEM SUBROUTINE $XPRESS TO     *
* PERFORM TRANSLATION.  FOR EXAMPLE, A WORD CONTAINING X'9000' (A     *
* 12-1 PUNCH IN A CARD COLUMN, THE LETTER A) WOULD BE TRANSLATED TO   *
* X'00C1', THE EBCDIC CODE FOR THE LETTER A.                          *
*                                                                     *
*      COMPRESSION IS THE PROCESS OF FINDING STRINGS OF DUPLICATE     *
* BLANK OR NONBLANK CHARACTERS AND REDUCING THE LENGTH OF THE STRINGS *
* SO THAT THE TRANSMISSION LINE WILL HAVE FEWER BYTES TO SEND TO THE  *
* CENTRAL PROCESSOR.  A SINGLE SCB CAN DO DUTY FOR A STRING OF AS     *
* MANY AS 31 BLANKS.  FOR DUPLICATE NONBLANK CHARACTERS, A TWO-BYTE   *
* SEQUENCE CONSISTING OF AN SCB AND AN EBCDIC CHARACTER CAN REPLACE   *
* AS MANY AS 31 CHARACTERS.                                           *
*                                                                     *
*      TRUNCATION IS THE PROCESS OF DELETING ALL TRAILING BLANKS BUT  *
* ONE, TO FURTHER REDUCE THE LOAD ON THE TRANSMISSION LINE AND TO     *
* CONSERVE SPACE ON SPOOL VOLUMES.  FOR EXAMPLE, AN ALL-BLANK CARD    *
* WOULD BE TRUNCATED TO A SINGLE BLANK (REQUIRING TRANSMISSION OF 4   *
* BYTES- RCB, SRCB, AND TWO SCB'S), WHEREAS A CARD WITH ONLY A NON-   *
* BLANK CHARACTER IN COLUMN 80 WOULD REQUIRE TRANSMISSION OF 8 BYTES- *
* RCB, SRCB, THREE SCB'S REPRESENTING STRINGS OF 31, 31, AND 17       *
* BLANKS, AN SCB DESCRIBING AN UNCOMPRESSED STRING OF ONE CHARACTER,  *
* THE CHARACTER ITSELF, AND AN EOR SCB.                               *
*                                                                     *
*      PACKING IS THE PROCESS OF SQUEEZING TWO 8-BIT BYTES INTO A     *
* SINGLE 1130 WORD.  THE TWO BYTES MAY BE BOTH CONTROL BYTES, BOTH    *
* EBCDIC CHARACTERS, OR ONE OF EACH.                                  *
*                                                                     *
*                                                                     *
*      THIS ROUTINE PROCEEDS IN TWO PHASES - A BACKWARD SCAN WHICH    *
* PROCEEDS SMOOTHLY FROM THE LAST TEXT WORD TO THE FIRST TEXT WORD,   *
* AND A FORWARD SCAN WHICH PROCEEDS JERKILY FROM THE FIRST WORD TO    *
* THE LAST WORD.                                                      *
*                                                                     *
*      THE BACKWARD SCAN STARTS WITH CARD-CODE CHARACTERS, ONE PER    *
* 1130 WORD, AND LEAVES BEHIND IT THE SAME NUMBER OF WORDS, EACH WORD *
* CONTAINING EITHER AN EBCDIC CHARACTER IN BITS 8-15 (WITH THE SIGN   *
* BIT ALWAYS OFF) OR A NEGATIVE NUMBER WHICH IS SORT OF A DUPLICATION *
* COUNT.  IF THE EBCDIC CHARACTER IS X'00' (CARD PUNCHES 12-0-9-8-1)  *
* THEN BIT 7 IS FORCED TO A 1, FOR REASONS HAVING TO DO WITH THE PACK *
* SUBROUTINE.                                                         *
*                                                                     *
*      THE FORWARD SCAN TAKES ALL THIS STUFF AND MAKES SCB'S FOLLOWED *
* BY CHARACTER STRINGS, PACKING AS IT GOES.  IT DISCOVERS A STRING OF *
* DUPLICATE (BLANK OR NON-BLANK) CHARACTERS AS A POSITIVE WORD        *
* FOLLOWED BY A NEGATIVE WORD - THE POSITIVE WORD CONTAINS THE CHAR-  *
* ACTER TO BE DUPLICATED, AND THE NEGATIVE WORD CONTAINS THE 2'S      *
* COMPLEMENT OF THE NUMBER OF DUPLICATE CHARACTERS.  WHEN IT ENCOUN-  *
* TERS A DUPLICATE STRING, THE FORWARD SCAN CREATES AND PACKS ONE OR  *
* MORE SCB'S, EACH SCB EXCEPT THE LAST REPRESENTING 31 CHARACTERS.    *
* (STRINGS OF TWO NONBLANK DUPLICATE CHARACTERS ARE NOT HANDLED AS    *
* DUPLICATE CHARACTERS.  THEY ARE REPAIRED BY MAKING THE SECOND (NEG- *
* ATIVE) WORD THE SAME AS THE FIRST (POSITIVE) WORD.)  AFTER SUCH A   *
* DUPLICATE STRING HAS BEEN PROCESSED, THE FORWARD SCAN ROUTINE TAKES *
* A GREAT LEAP FORWARD TO THE NEXT WORD TO BE PROCESSED.              *
*      FORWARD SCAN ASSUMES NON-DUPLICATE CHARACTERS UNTIL IT FINDS   *
* OTHERWISE.  THUS IF, UPON SCANNING THE FIRST FEW WORDS, IT DISCO-   *
* VERS THAT WORDS 1-6 ARE POSITIVE AND WORD 7 IS NEGATIVE, THEN       *
* (UNLESS WORD 6 IS NONBLANK AND WORD 7 EQUALS -2) IT MUST MAKE A 5-  *
* BYTE STRING OF NON-DUPLICATE CHARACTERS.  TO DO THIS, IT CREATES    *
* AND PACKS THE APPROPRIATE SCB AND THEN TAKES A GREAT LEAP BACKWARD  *
* TO WORD 1 TO START PACKING THE EBCDIC CHARACTERS IT HAS FOUND IN    *
* THE RIGHT HALVES OF WORDS 1 THROUGH 5.  WHEN IT HAS COMPLETED PACK- *
* ING THE 5 BYTES, FORWARD SCAN REDISCOVERS THAT WORD 6 IS FOLLOWED   *
* BY A NEGATIVE WORD AND PROCEEDS WITH DUPLICATION, AS ABOVE.         *
*                                                                     *
*      IF YOU'RE TRYING TO FOLLOW THE CODE, YOU SHOULD KNOW THAT      *
* THERE ARE TWO SPECIAL CASES, ONE FOR BACKWARD SCAN AND ONE FOR FOR- *
* WARD SCAN.                                                          *
*                                                                     *
*      FOR BACKWARD SCAN, THE SPECIAL CASE IS THE FIRST WORD OF TEXT. *
* ANY OTHER WORD MAY END UP EITHER BEING TRANSLATED TO EBCDIC OR      *
* BEING SET TO A NEGATIVE STRING COUNT, BUT THE FIRST WORD WILL AL-   *
* WAYS BE TRANSLATED TO EBCDIC.  FURTHERMORE, EVERY WORD BUT THE      *
* FIRST IS COMPARED WITH THE WORD PRECEDING IT, TO CHECK FOR DUPLI-   *
* CATION.  THUS THE LOOP COUNTER IS SET INITIALLY TO COUNT-1, NOT TO  *
* COUNT, AND THE FIRST WORD OF TEXT IS TRANSLATED TO EBCDIC OUTSIDE   *
* THE LOOP AND AFTER ALL OTHER WORDS HAVE BEEN PROCESSED.             *
*                                                                     *
*      FOR FORWARD SCAN, THE LAST WORD OF TEXT WILL SOMETIMES BE A    *
* SPECIAL CASE, SINCE HERE, TOO, THE LOOP COUNTER WILL NEVER BE       *
* GREATER THAN THE NUMBER OF CHARACTERS REMAINING MINUS ONE.  IF THE  *
* LAST WORD IS NEGATIVE (SPECIFICALLY, -2 OR LESS IF THE NEXT-TO-LAST *
* WORD IS BLANK, OR -3 OR LESS IF THE NEXT-TO-LAST WORD IS NONBLANK)  *
* THE SPECIAL CASE WILL NOT OCCUR.  OTHERWISE, THE LAST WORD MUST BE  *
* MADE PART OF A NON-DUPLICATE CHARACTER STRING.  THE 7 LINES OF CODE *
* AT TPCO150 ATTEMPT TO UP THE CURRENT (NON-DUPLICATE) STRING LENGTH  *
* BY 1 TO ACCOMMODATE THE LAST CHARACTER.  IF THAT CANNOT BE DONE     *
* (THE CURRENT LENGTH IS ALREADY 63, THE MAXIMUM) THEN THE EXITING    *
* PROCEDURE AT TPCO300 WILL BUILD AND PACK THE NECESSARY SCB AND THE  *
* LAST CHARACTER.                                                     *
*                                                                     *
*                                                                     *
*      AS AN EXAMPLE OF THE OPERATION OF BACKWARD SCAN, CONSIDER AN   *
* INPUT OF TEN WORDS, CONSISTING OF THE CARD-CODE EQUIVALENTS OF 4    *
* BLANKS, 3 A'S, 2 B'S, AND A C.  THIS IS                             *
*        DC  XL2'0000,0000,0000,0000,9000,9000,9000,8800,8800,8400'.  *
* WHEN BACKWARD SCAN GETS THROUGH, IT LEAVES BEHIND                   *
*        DC  XL2'0040,FFFC,FFFD,FFFE,00C1,FFFD,FFFE,00C2,FFFE,00C3'.  *
* FORWARD SCAN WILL COMPRESS AND PACK THIS INTO THE BYTE STRING       *
*        DC  XL1'84,A3,C1,C3,C2,C2,C3'.                               *
*                                                                     *
.NODOC01 ANOP
TPCOMPR  DC    AL2(*-*)
         EJECT
***********************************************************************
*              INITIALIZATION.                                        *
***********************************************************************
         $STX  TPCO320+D1,WA,L     SAVE INDEX WA.
         $STX  TPCO330+D1,WC,L     SAVE INDEX WC.
         $LD   UFCBFQP,WC,X        GET A POINTER TO THE INPUT.
         $STO  WA,,L               PUT IT INTO INDEX WA.
         $LD   0,WA                GET NUMBER OF WORDS TO PROCESS.
         $A    WA,,L               POINT TO LAST WORD TO PROCESS.
         $STO  TPCOLAST            SAVE POINTER.
         $STX  TPCO020+D1,WA       SET $EOR'S TO POINT TO THE
         $STX  TPCO030+D1,WA       WORD BEFORE 1ST WORD OF TEXT.
         $MDX  1,WA                NOW POINT WA TO 1ST INPUT WORD.
         $STX  TPCO010+D1,WA       SET $LD'S AND $STO'S TO POINT TO
         $STX  TPCO050+D1,WA       THE FIRST WORD OF TEXT.
         $STX  TPCO060+D1,WA       SET $LD TO POINT TO FIRST WORD.
         $STX  TPCOFRST,WA         SAVE POINTER TO FIRST WORD.
         $STX  TPCOP010+D1,WA,L    SET UP THE PACK ROUTINE.
***********************************************************************
*              STORE RCB + SRCB OVER THE COUNT WORD OF INPUT BUFFER.  *
***********************************************************************
         $LD   UFCBSAR,WC,X        GET THE RECORD CONTROL BYTE.
         $SLA  8                   SHIFT IT LEFT 8 BITS.
         $OR   TPCOX80             OR IN HEXADECIMAL 80 FOR SRCB.
         $STO  -1,WA               STORE RCB+SRCB OVER THE COUNT.
         EJECT
***********************************************************************
*              SET UP TO SCAN BACKWARDS.  ON BACKWARD SCAN, NON-DUPLI-*
*              CATE WORDS WILL BE IMMEDIATELY TRANSLATED. FOR STRINGS *
*              OF TWO OR MORE DUPLICATE WORDS, ONLY THE TWO LEFTMOST  *
*              WORDS HAVE MEANING. THEY ARE, FROM LEFT TO RIGHT, THE  *
*              TRANSLATED WORD AND A NEGATIVE COUNT OF THE NUMBER OF  *
*              DUPLICATE WORDS IN THE STRING.                         *
***********************************************************************
         $LD   TPCOLAST            POINT TO LAST CHARACTER TO PROCESS.
         $S    TPCOFRST            SUBTRACT POINTER TO FIRST CHARACTER.
         $BZ   TPCO060             BR IF ONLY ONE WORD OF INPUT.
         $STO  WA,,L               PUT THIS OVERALL CT IN INDEX WA.
         $AXT  -1,WB               SET DUPLICATE COUNTER TO -1.
TPCO010  $LD   *-*,WA,L            GET A CARD-CODE CHARACTER.
TPCO020  $EOR  *-*,WA,L            IS IT SAME AS PREVIOUS CHARACTER...
         $BZ   TPCO040             BRANCH IF YES TO UP THE DUP COUNTER.
TPCO030  $EOR  *-*,WA,L            NO. RESTORE THE CARD-CODE CHARACTER,
         $TSL  SXPRESS             AND GO TRANSLATE IT TO EBCDIC.
         $SKPN                     SKIP IF NONZERO. OTHERWISE,
         $OR   TPCOX100            ADD A BIT FOR TPCOPACK.
         $AXT  -1,WB               RESET THE DUPLICATE COUNTER TO -1.
         $B    TPCO050             THEN GO STORE EBCDIC IN WORD.
***********************************************************************
*              CURRENT CHARACTER MATCHES THE ONE ON ITS LEFT.         *
***********************************************************************
TPCO040  $MDX  -1,WB               UP THE DUPLICATE COUNTER BY -1.
         $LD   WB,,L               PREPARE TO STORE DUP CTR IN CUR WD.
*
*
TPCO050  $STO  *-*,WA,L            STORE ACC IN CURRENT WORD.
         $MDX  -1,WA               NOW POINT TO THE PREVIOUS CARD-CODE
         $B    TPCO010             CHARACTER AND PROCESS IT.
***********************************************************************
*              STORE INTO WORD EITHER EBCD CHAR OR DUP CTR, AND LOOP. *
*              IN ALL CASES, TRANSLATE THE FIRST CARD-CODE CHARACTER. *
***********************************************************************
TPCO060  $LD   *-*,,L              GET THE FIRST WORD OF INPUT.
         $TSL  SXPRESS             TRANSLATE IT TO EBCDIC.
         $SKPN                     SKIP IF NONZERO. OTHERWISE,
         $OR   TPCOX100            MAKE SURE IT'S NONZERO FOR TPCOPACK,
         $STO  TPCO060+D1,,I       AND PUT IT BACK.
         EJECT
***********************************************************************
*              SET UP TO START THE FORWARD SCAN.                      *
***********************************************************************
         $SLT  16                  ZERO OUT THE EXT FOR TPCOPACK.
         $LXA  TPCOFRST,WA         POINT TO FIRST WORD.
***********************************************************************
*              COMPUTE COUNT TO SCAN - EITHER 63 OR NUMBER OF         *
*              CHARACTERS REMAINING MINUS 1, WHICHEVER IS LESS.       *
***********************************************************************
TPCO100  $LD   TPCOLAST            POINT TO LAST WORD.
         $S    WA,,L               SUBTRACT CURRENT WORD.
         $BNP  TPCO300             BRANCH IF DONE.
         $S    TPCOC63             IS COUNT GREATER THAN 63...
         $BNN  TPCO110             BRANCH IF YES.
         $A    TPCOC63             NO, .LE. 63.  RESTORE THE COUNT
         $B    TPCO120             AND BRANCH.
TPCO110  $LD   TPCOC63             COUNT IS .GT. 63. SET COUNTER TO 63.
TPCO120  $STO  TPCOCNT             SAVE COUNT FOR USE LATER.
         $STO  WB,,L               SET WB TO THE COUNT FOR LOOP.
         $LXA  WA,WC               SAVE LOC OF FIRST WORD IN INDEX WC.
***********************************************************************
*              ATTEMPT TO FIND A CHARACTER STRING.                    *
***********************************************************************
TPCO130  $LD   1,WA                LOAD THE NEXT WORD INTO THE ACC.
         $BN   TPCO200             BRANCH IF IT SHOWS DUPLICATION.
TPCO140  $MDX  1,WA                OTHERWISE POINT TO THE NEXT WORD,
         $MDX  -1,WB               LOWER THE COUNT BY ONE,
         $B    TPCO130             AND EXAMINE THE NEXT WORD.
***********************************************************************
*              A STRING NOW EXISTS THAT'S 63 CHARS OR GOES TO EOR     *
***********************************************************************
TPCO150  $LD   WA,,L               LOOK AT POINTER TO CURRENT WORD.
         $S    TPCOLAST            IS CURRENT WORD THE LAST WORD...
         $BNZ  TPCO155             BRANCH IF NOT- COUNT IS CORRECT.
         $LD   TPCOCNT             CURRENT WORD IS LAST WORD.  SEE IF
         $S    TPCOC63             THE COUNT IS THE MAXIMUM (63).
         $BZ   TPCO155             BRANCH IF SO.
         $MDM  TPCOCNT,1           OTHERWISE INCLUDE LAST WORD IN CT.
***********************************************************************
*              SET A CHARACTER-STRING SCB INTO THE OUTPUT STREAM.     *
***********************************************************************
TPCO155  $LXA  TPCOCNT,WB          PICK UP THE STRING COUNT INTO WB
TPCO160  $LD   WB,,L               FORM A STRING CONTROL BLOCK OF
         $OR   TPCOXC0             THE COUNT PLUS X'C0', AND
         $BSI  TPCOPACK,,L         PACK THE SCB INTO THE OUTPUT.
***********************************************************************
*              PACK THE CHARACTERS INTO OUTPUT FOLLOWING THE SCB.     *
***********************************************************************
TPCO170  $LD   0,WC                GET A WORD OF EBCDIC.
         $BSI  TPCOPACK            PACK IT INTO THE OUTPUT STREAM.
         $MDX  1,WC                POINT TO THE NEXT WORD.
         $MDX  -1,WB               REDUCE THE COUNT BY ONE.
         $B    TPCO170             BRANCH IF MORE CHARACTERS TO DO.
         $LXA  WC,WA               THEN SET WA TO THE CURRENT
         $B    TPCO100             POINTER AND GET ANOTHER STRING.
***********************************************************************
*              CONSTANTS                                              *
***********************************************************************
TPCOFRST DC    AL2(*-*)            POINTER TO FIRST WORD OF TEXT.
TPCOLAST DC    AL2(*-*)            POINTER TO LAST WORD OF TEXT.
TPCOCNT  DC    AL2(*-*)            SCAN COUNT. SEE COMMENTS AT TPCO100.
TPCOX80  DC    AL2(X'80')
TPCOC1   DC    AL2(1)
TPCOX100 DC    AL2(X'100')
TPCOC63  DC    AL2(63)
TPCOXC0  DC    AL2(X'C0')
TPCOC2   DC    AL2(2)
TPCOX40  DC    AL2(X'40')
TPCOX9F  DC    AL2(X'9F')
TPCOC31  DC    AL2(31)
TPCOXBF  DC    AL2(X'BF')
TPCOXA0  DC    AL2(X'A0')
TPCOX81  DC    AL2(X'81')
TPCOXC1  DC    AL2(X'C1')
***********************************************************************
*              A POSSIBLE DUPLICATE PLUS A POSSIBLE STRING EXISTS     *
***********************************************************************
TPCO200  $A    TPCOC2              ADD TWO TO THE (NEGATIVE) DUP COUNT,
         $BN   TPCO210             AND BRANCH IF COUNT WAS .GT. 2.
         $LD   0,WA                OTHERWISE, CHECK THE DUP CHARACTER
         $EOR  TPCOX40             FOR BLANK.  IF CHARACTER IS BLANK,
         $BZ   TPCO210             BRANCH TO DUPLICATE.
         $LD   0,WA                OTHERWISE, REPEAT THE CHARACTER
         $STO  1,WA                ONCE, AND RETURN TO CONTINUE
         $B    TPCO140             THE CHARACTER-STRING SCAN.
***********************************************************************
*              A DEFINITE DUPLICATE PLUS A POSSIBLE STRING EXISTS     *
***********************************************************************
TPCO210  $LD   TPCOCNT             CHECK FOR POSSIBLE STRING- GET ORIG
         $S    WB,,L               COUNT VALUE AND SUBTR CURRENT VALUE.
         $BZ   TPCO220             BRANCH IF NO CHARACTER STRING.
         $STO  WB,,L               OTHERWISE SET WB TO STRING COUNT,
         $B    TPCO160             AND GO DO THE STRING.
***********************************************************************
*              DUPLICATE PROCESSING. CHECK FOR BLANK.                 *
***********************************************************************
TPCO220  $LD   0,WA                GET THE CHARACTER TO BE DUPED.
         $STO  TPCOTMP             SAVE IN CASE IT IS OVERLAYED
         $EOR  TPCOX40             TEST THE CHARACTER FOR BLANK.
         $BNZ  TPCO250             BRANCH IF NOT BLANK.
         $S    1,WA                GET TRUE BLANK COUNT.
         $A    WA,,L               TEST FOR REST OF RECORD BLANK, BY
         $S    TPCOLAST            POINTING TO END+1 AND SUBTRACTING
         $BP   TPCO290             END+0. BRANCH IF REMAINDER IS BLANK.
         $A    TPCOLAST            OTHERWISE, CALCULATE A PTR TO THE
         $STO  WA,,L               NEXT NON-DUPE AND STORE IT IN WA.
         $S    WC,,L               GET THE TRUE COUNT AGAIN.
         $STO  WB,,L               PUT TRUE DUPLICATE COUNT INTO WB.
         $STL  TPCOPACK            ITERATE 31-COUNT BLANK SCB'S IF NEC.
         $LD   TPCOX9F             GET A 31-COUNT BLANK SCB.
         $MDX  -31,WB              SUBTRACT 31 FROM WB.
         $B    TPCOPACK+D1         IF RESULT POSITIVE, PACK A BLANK SCB
         $LD   WB,,L               OTHERWISE CLEAN UP. GET A SKELETOM
         $A    TPCOC31             BLANK SCB AND ADD TO IT THE
         $OR   TPCOX80             REMAINING BLANK COUNT.
         $BSI  TPCOPACK            THEN PACK THE FINAL BLANK SCB.
         $B    TPCO100             NOW BRANCH TO SET UP AGAIN.
***********************************************************************
*              A STRING OF DUPLICATE NONBLANK CHARACTERS EXISTS       *
***********************************************************************
TPCO250  $ZAC                      ZERO OUT THE ACCUMULATOR.
         $S    1,WA                GET TRUE COUNT OF NONBLANK DUPLICATE
         $STO  WB,,L               CHARS, AND SET WB TO IT.
         $A    WA,,L               ADD TRUE COUNT TO CURRENT POINTER,
         $STO  WA,,L               AND SET WA FOR NEXT TIME.
TPCO260  $MDX  -31,WB              REDUCE THE COUNT BY 31, AND
         $B    TPCO265             SKIP IF IT'S STILL POSITIVE.
         $B    TPCO270             OTHERWISE, BRANCH TO CLEAN UP.
TPCO265  $LD   TPCOXBF             GET MAXIMUM NONBLANK DUPE SCB,
         $BSI  TPCOPACK            AND PACK IT.
         $LD   TPCOTMP             GET THE DUPLICATE
         $BSI  TPCOPACK            CHARACTER, AND PACK IT TOO.
         $B    TPCO260             TRY FOR ANOTHER THIRTY-ONE.
TPCO270  $LD   WB,,L               CLEAN UP- GET REMAINING CT MINUS 31
         $A    TPCOC31             AND MAKE IT TRUE REMAINS.
         $OR   TPCOXA0             ADD SKELETON NONBLANK DUPE SCB.
         $BSI  TPCOPACK            PACK THIS FINAL SCB.
         $LD   TPCOTMP             GET THE DUPLICATE CHARACTER
         $BSI  TPCOPACK            AND PACK IT TOO.
         $B    TPCO100,,L          NOW GO SET UP AGAIN FOR SCAN.
***********************************************************************
*              THIS ROUTINE EFFECTIVELY TRUNCATES TRAILING BLANKS.    *
***********************************************************************
TPCO290  $LD   TPCOX81             GET BLANK SCB WITH COUNT OF ONE
         $BSI  TPCOPACK            GO PACK THE LAST BLANK.
         $B    TPCO310             THEN EXIT.
***********************************************************************
*              THIS ROUTINE CONCLUDES COMPRESSION AND TRUNCATION.     *
***********************************************************************
TPCO300  $BN   TPCO310             BRANCH IF ALL CHARACTERS ARE DONE.
         $LD   TPCOXC1             OTHERWISE A CHARACTER STRING OF
         $BSI  TPCOPACK            LENGTH ONE REMAINS.  PACK THE
         $LD   0,WA                APPROPRIATE SCB (X'C1'), AND PACK
         $BSI  TPCOPACK            THE CHARACTER RIGHT BESIDE IT.
TPCO310  $LD   TPCOX100            GET EOR SCB PLUS A BIT FOR TPCOPACK.
         $BSI  TPCOPACK            PACK THE END-OF-RECORD SCB.
         $LD   TPCOC1              GET THE CONSTANT '1' AND PACK
         $BSI  TPCOPACK            IT FOR LENGTH DETERMINATION.
TPCO330  $LDX  *-*,WC,L            RESTORE INDEX WC.
         $LD   TPCOP010+D1         POINT TO WORD AFTER LAST WORD PACKD.
         $S    UFCBFQP,WC,X        SUBTRACT THE INPUT AREA POINTER.
         $SLA  1                   MULTIPLY BY 2 FOR BYTES.
         $STO  WA,,L               SAVE BYTE COUNT TEMPORARILY.
         $LXA  TPCOP010+D1,WB      POINT WB TO WORD AFTER LAST PACKED.
         $LD   -1,WB               GET THE LAST WORD PACKED.
         $BSC  E                   SKIP IF EVEN (RIGHT BYTE IS EOR SCB)
         $MDX  -1,WA               OTHERWISE REDUCE BYTE COUNT BY 1.
         $LD   WA,,L               RETURN TRUE BYTE COUNT IN ACC.
TPCO320  $LDX  *-*,WA,L            RESTORE INDEX WA.
         $LXA  TPCOFRST,WB         POINT WB TO 2D WORD OF INPUT, AND
         $MDX  -1,WB               SUBTRACT 1 TO PT TO 1ST WORD.
         $B    TPCOMPR,,I          RETURN. THE ACC CONTAINS THE BYTE
*                                  COUNT, AND WB POINTS TO THE FIRST
*                                  WORD.
         EJECT
.CMPT200 ANOP
***********************************************************************
*              TPCOPACK-ROUTINE TO PACK CHARACTERS AND CONTROL BYTES  *
***********************************************************************
TPCOPACK DC    AL2(*-*)            CALLED VIA $BSI.
         $RTE  16                  SWITCH THE ACC WITH THE EXT.
         $BZ   TPCOPACK,,I         RETURN IF THE ACC IS ZERO.
*                                  OTHERWISE, ACC+EXT ARE X'1,B1,1,B2'.
         $SLT  8                   ACC+EXT ARE NOW X'B1,1,B2,0'.
         $SRA  8                   ACC+EXT ARE NOW X'0,B1,B2,0'.
         $SLT  8                   ACC+EXT ARE NOW X'B1,B2,0,0'.
TPCOP010 $STO  *-*,,L              STORE BYTE 1 AND BYTE 2 INTO A WORD.
         $MDM  TPCOP010+D1,1       POINT TO THE NEXT WORD.
         $B    TPCOPACK,,I         THEN RETURN TO CALLER.
TPCOTMP  DC    AL2(*-*)            TEMPORARY STORAGE
         EJECT
***********************************************************************
*                                                                     *
*TITLE - TPBUILD (CONSTRUCTS TP BUFFERS FOR TPIOX PROCESSING)         *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  CONSTRUCTS TP BUFFERS FROM INFORMATION PROVIDED THRU CALLING       *
*  SEQUENCE.                                                          *
*                                                                     *
* CALLING SEQUENCE -                                                  *
*                                                                     *
*                             $TSL TPBUILD   LINKAGE                  *
*                             ....           RETURN                   *
*                                                                     *
*                   WHERE---  ENTRY...AC CONTAINS LENGTH              *
*                             OF INSERT IN BYTES                      *
*                                                                     *
*                             WB CONTAINS ADDRESS OF FIRST            *
*                             CHARACTER (LEFT JUSTIFIED IN            *
*                             WORD) TO BE INSERTED                    *
*                                                                     *
*                             EXIT... AC SET TO ZERO IF DATA          *
*                             INSERTED. AC SET NON-ZERO IF            *
*                             INSUFFICIENT ROOM IN BUFFER             *
*                                                                     *
*                   NOTE---   REGISTERS WA,WB SAVED AND RESTORED      *
*                                                                     *
*                             COUNTERS AND POINTERS FOR TPBUILD       *
*                             ARE SET EXTERNAL TO THE ROUTINE         *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              SPECIAL ENTRY WHICH BYPASSES SPACE TEST                *
***********************************************************************
TPBLSPE  $SLA  1                   GET RID OF
         $SRA  1                    SIGN BIT
         $STO  TPBLSGL             STORE LENGTH
         $B    TPBLSVR             BYPASS SPACE TEST
***********************************************************************
*              TPBUILD ENTRY POINT                                    *
***********************************************************************
TPBUILD  DC    AL2(*-*)            ENTRY VIA $TSL TPBUILD
         $BNP  TPBLSPE             BRANCH IF SPECIAL ENTRY
         $STO  TPBLSGL             SAVE LENGTH OF INSERT
         $LD   TPBLRSC             GET CURRENT RESIDUAL
         $S    TPBLSGL             MINUS LENGTH OF INSERT
         $BN   TPBUILD,,I          EXIT IF INSUFFICIENT SPACE
         $STO  TPBLRSC             STORE NEW BUFFER RESIDUAL
TPBLSVR  $STX  TPBLSVA+D1,WA       SAVE
         $STX  TPBLSVB+D1,WB        REGISTERS
TPBLTRG  $AXT  *-*,WA,L            TARGET ADDRESS IN BUFFER
         $LD   TPBLSGL             GET INSERT LENGTH
         $BSC  E                   SKIP IF EVEN COUNT
         $A    TPBLCN1             MAKE IT EVEN
         $SRA  1                    NUMBER OF WORDS
         $STO  TPBLWDC             SAVE WORD COUNT
         $LD   TPBLCNT             GET LAST DATA TOTAL
         $BOD  TPBLHWD             BRANCH IF HALF-WORD TARGET
***********************************************************************
*              FULL-WORD TARGET STORE LOOP                            *
***********************************************************************
TPBLFWT  $LD   0,WB                GET SOURCE WORD
         $STO  0,WA                TO TARGET AREA
         $MDX  1,WB                INCREMENT
         $MDX  1,WA                 POINTERS
         $MDM  TPBLWDC,-1          DECREMENT WORD COUNT
         $B    TPBLFWT             MOVE SPECIFIED NUMBER
         $LD   TPBLSGL             GET INSERT LENGTH
         $BSC  E                   SKIP IF EVEN
TPBLADJ  $MDX  -1,WA               ADJUST TARGET POINTER
TPBLTOT  $A    TPBLCNT             TOTAL
         $STO  TPBLCNT              INSERT
         $STX  TPBLTRG+D1,WA       SET NEW TARGET POINTER
         $ZAC                      FLAG SUCCESS
TPBLSVA  $AXT  *-*,WA,L            RESTORE
TPBLSVB  $AXT  *-*,WB,L             REGISTERS
         $B    TPBUILD,,I          RETURN TO CALLER
***********************************************************************
*              TPBUILD CONSTANTS, STORAGE, ETC.                       *
***********************************************************************
TPBLCN1  DC    AL2(1)              CONSTANT 1
TPBLSGL  DC    AL2(*-*)            LENGTH OF CURRENT SEGEMENT
TPBLRSC  DC    AL2(*-*)            SET TO BUFFER RESIDUAL COUNT
TPBLWDC  DC    AL2(*-*)            DERIVED WORD COUNT
TPBLCNT  DC    AL2(*-*)            TOTAL BYTES USED
***********************************************************************
*              HALF-WORD TARGET AREA                                  *
***********************************************************************
TPBLHWD  $LD   0,WB                GET SOURCE WORD
         $RTE  16                  TO EXT
         $LD   0,WA                GET TARGET WORD
         $SRA  8                    UPTIGHT TO SOURCE
         $SLT  8                   FORM NEW TARGET WORD
         $STO  0,WA                STORE IT AWAY
         $SLT  16                  PARTIAL NEW TARGET
         $STO  1,WA                 PRIME IT
         $MDX  1,WB                INCREMENT
         $MDX  1,WA                 POINTERS
         $MDM  TPBLWDC,-1          DECREMENT COUNT
         $B    TPBLHWD             DO ALL WORDS
         $LD   TPBLSGL             GET SEGMENT LENGTH
         $B    TPBLTOT             GO COMPUTE TOTAL
         AIF   (&RD2501 EQ 0).NO2501B
         TITLE 'RTP1130 (COMMUTATOR ROUTINE FOR 2501 READER)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - RDTFO (2501 CARD READER COMMUTATOR ROUTINE)                 *
*                                                                     *
*  READ CARDS FROM THE 2501 WHENEVER COMMUTATOR GATE IS OPENED AND    *
*  THE 2501 IS IN READY STATUS. PASSES CARD (IN CARD CODE FORMAT)     *
*  TO TPPUT COMMUTATOR ROUTINE FOR COMPRESSION AND INSERTION INTO     *
*  THE LINE MANAGER OUTPUT (TO MAIN PROCESSOR) QUEVE. INPUT IS        *
*  DOUBLE BUFFERED.                                                   *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              ISSUE INTERVENTION REQUIRED MESSAGE AND WAIT           *
***********************************************************************
RDTFNOT  $STL  RDTFOVE+D1          RESET VARIABLE ENTRY POINT
         $WTO  RDTFMSG,RDTFORT     ISSUE OPERATOR MESSAGE
         $STL  RDTFOVE+D1          RESET VARIABLE ENTRY POINT
         $XIO  RDTFSWR-D1          SENSE 2501 WITHOUT RESET
         $BOD  RDTFORT             CYCLE UNTIL READY
         $B    RDTFSLC             ISSUE I/O REQUEST
RDTFMSG  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(30)             DATA COUNT
         DC    C'INTERVENTION REQUIRED ON 2501 '
RDTFOLT  $B    ((RDTFOEC-RDTFOGT)-2)/2,,X 2501 GATE LATCH
RDTFREQ  DC    AL1($CRREQT,0)      REQUEST TO START IDENTIFICATION
RDTFC80  DC    AL2(80)             COLUMN READ COUNT
***********************************************************************
*              ENTRY POINT FROM COMMUTATOR                            *
***********************************************************************
RDTFOEP  $NULL                     ENTRY POINT FROM COMMUTATOR
RDTFOVE  $B    RDTFONI,,L          VARIABLE ENTRY VECTOR
RDTFONP  $B    RDTFORT,,L          NON-PROCESS EXIT POINT
RDTFOXT  $BSI  RDTFOVE+D1          EXIT AND RESET ENTRY POINT
RDTFONI  $XIO  RDTFSWR-D1          SENSE 2501 WITHOUT RESET
         $BOD  RDTFORT             NON-PROCESS EXIT UNTIL READY
         $AXT  RDTFUFCB,WC,L       2501 UFCB ADDRESS
         $LD   RDTFREQ             GET REQUEST IDENTIFICATION
         $TSL  STPOPEN             GENERATE REQUEST TO SEND
         $BNZ  RDTFORT             CYCLE UNTIL ACCEPTED
         $LD   RDTFOLT             CLOSE
         $STO  RDTFOGT,,L           GATE
         $BSI  RDTFOVE+D1          EXIT AND RESET ENTRY
RDTFRGO  $NULL                     ENTRY POINT WHEN HASP IS READY
         $LD   RDTFBFP             GET BUFFER ADDRESS
RDTFGET  $STO  RDTFXAD             SET IOCC FOR CURRENT BUFFER
RDTFSVO  $XIO  RDTFSWR-D1          SENSE 2501 WITHOUT RESET
         $BOD  RDTFNOT             ISSUE MESSAGE IF NOT READY
RDTFSLC  $ZAC                      CLEAR AC AND TURN
         $STO  RDTFERR             OFF ERROR FLAG
         $STL  RDTFOPC             SET OPERATION NOT COMPLETE FLAG
         $LD   RDTFC80             REFRESH
         $STO  RDTFXAD,,I           COUNT
         $XIO  RDTFXAD             START READING
         $STL  RDTFOVE+D1          RESET VARIABLE ENTRY POINT
         $MDM  RDTFOPC,0           TEST FOR READ COMPLETE
         $B    RDTFONP             NO. NON-PROCESS EXIT
         $MDM  RDTFERR,0           TEST FOR ERROR ON READ
         $B    RDTFSVO             YES. TRY AGAIN
         $MDM  RDTFLSC,0           TEST LAST CARD FLAG
         $B    RDTFLST             BRANCH IF LAST CARD
         $STL  RDTFOVE+D1          RESET VARIABLE ENTRY POINT
         $LDD  RDTFBFP             GET BUFFER POINTERS IN AC AND EXT
         $MDM  SRDTTANK,0          TEST FOR AVAILABLE TANK
         $B    RDTFONP             NON-PROCESS EXIT IF NOT AVAILABLE
         $STO  SRDTTANK,,L         QUEUE THE BUFFER
         $RTE  16                  SWITCH BUFFERS
         $STD  RDTFBFP             STORE NEW POINTERS
         $B    RDTFGET             GO READ ANOTHER CARD
RDTFLST  $NULL                     LAST CARD PROCESS
         $ZAC                      CLEAR AC AND
         $STO  RDTFLSC             TURN OFF LAST CARD FLAG
         $STL  RDTFOVE+D1          RESET VARIABLE ENTRY
         $LD   RDTFBFP             GET DATA BUFFER POINTER
         $MDM  SRDTTANK,0          TEST FOR AVAILABLE TANK
         $B    RDTFONP             NOT AVAILABLE. TRY LATER
         $STO  SRDTTANK,,L         QUEUE THE BUFFER
         $STO  RDTFUFLG,,L          AND SET EOF IN UFCB
         $B    RDTFOXT             EXIT
***********************************************************************
*              INTERRUPT PROCESSOR FOR 2501                           *
***********************************************************************
RDTFOINT $NULL                     ENTRY FROM FLIP 4
         $XIO  RDTFSRS-D1          SENSE WITH RESET
         $SLA  3                   CHECK FOR READ/FEED ERROR
         $BC   RDTFRFR             BRANCH IF ERROR
         $BSC  P+Z                 TEST FOR LAST CARD
         $B    RDTFLAS             BRANCH IF LAST CARD
RDTFXIT  $ZAC                      CLEAR AC AND SET
         $STO  RDTFOPC             OPERATION COMPLETE FLAG
         $B    RTPL4RTN,,L         EXIT TO FLIP 4
RDTFRFR  $STL  RDTFERR             RUN UP THE ERROR FLAG
         $B    RDTFXIT             GO TO EXIT PROCEDURE
RDTFLAS  $STL  RDTFLSC             RUN UP THE LAST CARD FLAG
         $B    RDTFXIT             GO TO EXIT PROCEDURE
***********************************************************************
*              POINTERS, FLAGS, COMMANDS AND BUFFERS                  *
***********************************************************************
         $BSS  0,E                 EVEN STORAGE ASSIGNMENT
RDTFBFP  $ADCON RDTFBF1            BUFFER POINTERS WHICH
         $ADCON RDTFBF2            ARE SWITCHED
RDTFXAD  DC    AL2(*-*)            CURRENT INPUT BUFFER ADDRESS
         DC    AL2($IREAD+$2501)   INITIATE 2501 READ COMMAND
RDTFOPC  DC    H'0'                OPERATION STATUS FLAG...
*                                  SET TO ZERO FOR OPERATION COMPLETE.
*                                  SET NON-ZERO FOR OPERATION NOT
*                                  COMPLETE.
RDTFSWR  DC    AL2($SENSED+$2501)  SENSE DEVICE WITHOUT RESET
RDTFERR  DC    H'0'                OPERATION ERROR FLAG...
*                                  SET TO ZERO IF NO ERROR
*                                  SET NON-ZERO IF ERROR
RDTFSRS  DC    AL2($SENSED+$2501+1) SENSE DEVICE WITH RESET
RDTFLSC  DC    H'0'                LAST CARD FLAG
*                                  SET TO ZERO IF NOT LAST CARD
*                                  SET NON-ZERO IF LAST CARD
*
RDTFBF1  DC    AL2(80)             BUFFER DATA COUNT
         $BSS  80                  BUFFER 1
RDTFBF2  DC    AL2(80)             BUFFER DATA COUNT
         $BSS  80                  BUFFER 2
.NO2501B ANOP
         AIF   (NOT &XX1442).NO1442B
         TITLE 'RTP1130 (COMMUTATOR ROUTINE FOR 1442 READ/PUNCH)'
***********************************************************************
*                                                                     *
* TITLE - RPFFT (1442 READ OR PUNCH COMMUTATOR ROUTINE)               *
*                                                                     *
* FUNCTION/OPERATION-                                                 *
*                                                                     *
*  READS CARDS FROM THE 1442-6,7 OR PUNCHES CARDS ON THE 1442-5,6,7.  *
*  THE FUNCTION TO BE PERFORMED IS CONTROLLED BY THE VALUE OF THE     *
*  CONTROL WORD 'RPCNTRL'...                                          *
*                                                                     *
*                        RPCNTRL = ZERO FOR READ FUNCTION             *
*                        RPCNTRL = NON-ZERO FOR PUNCH FUNCTION        *
*                                                                     *
*  CARD READING IS DOUBLE BUFFERED                                    *
*                                                                     *
*  CARD PUNCHING IS CONTROLLED BY THE PUNCH QUEUE DEVELOPED           *
*  BY THE COMMUNICATIONS ADAPTER SUBROUTINES.                         *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              ISSUE INTERVENTION REQUIRED MESSAGE AND WAIT           *
***********************************************************************
RPFFNOT  $STL  RPFFTVE+D1          RESET VARIABLE ENTRY POINT
         $WTO  RPFFMSG,RPFFTRT     ISSUE INTERVENTION MESSAGE
         $STL  RPFFTVE+D1          RESET VARIABLE ENTRY POINT
         $XIO  RPFFSWR-D1          SENSE WITHOUT RESET
         $AND  RPFFRBM              AND EXIT IF NOT
         $BNZ  RPFFTRT               READY OR BUSY...
         $B    RPFFSET             GO ISSUE I/O REQUEST
RPFFMSG  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(30)             DATA COUNT
         DC    C'INTERVENTION REQUIRED ON 1442 '
***********************************************************************
*              LOCAL COMMANDS AND CONSTANTS                           *
***********************************************************************
         $BSS  0,E
RPFFREQ  DC    AL1($CRREQT,0)      REQUEST TO START              E
RPFFSWR  DC    AL2($SENSED+$1442)  SENSE 1442 WITHOUT RESET      O
RPFFRCN  DC    AL2($CONTROL+$1442+4) START 1442 READ
RPFFCRD  DC    AL2($READ+$1442)    READ 1442 COMMAND
RPFFCWR  DC    AL2($WRITE+$1442)   WRITE 1442 COMMAND
RPFFRBM  DC    X'0003'             NOT READY OR BUSY PRESERVATION MASK
RPFFTLT  $B    ((RPFFTEC-RPFFTGT)-2)/2,,X 1442 GATE LATCH
RPFFPRM  DC    AL2(X'2000')        MASK FOR PERMISSION TO SEND
RPFFACT  DC    AL2(*-*)            1442 ACTIVE/IDLE FLAG
***********************************************************************
*              COMMUTATOR ENTRY POINT                                 *
***********************************************************************
RPFFTEP  $NULL                     ENTRY POINT FROM COMMUTATOR
RPFFTVE  $B    RPFFTNI,,L          VARIABLE ENTRY VECTOR
RPFFTNP  $B    RPFFTRT,,L          NON-PROCESS EXIT POINT
RPFFTNE  $NULL                     EXIT POINT TO CLOSE GATE
         AIF   (NOT &RD1442).NO1442X IF 1442 DEFINED AS READER
         $LD   RPFFTLT             GET LATCH AND CLOSE
         $STO  RPFFTGT,,L          COMMUTATOR GATE
.NO1442X ANOP
RPFFTXT  $BSI  RPFFTVE+D1          EXIT- RESET TO ENTER RPFFTNI
RPFFTNI  $NULL                     NORMAL ENTRY POINT
         AIF   (NOT &RD1442).NO1442C
         AIF   (NOT &PN1442).NO1442R
         $MDM  RPCNTRL,0           TEST FUNCTION INDICATOR
         $B    RPFFPUN             BRANCH IF PUNCH REQUEST
.NO1442R ANOP
***********************************************************************
*              READ 1442 INITIALIZATION                               *
***********************************************************************
         $XIO  RPFFSWR-D1          SENSE WITHOUT RESET
         $AND  RPFFRBM             MASK ALL BUT READY/BUSY
         $BNZ  RPFFTRT             EXIT UNTIL READY
         $AXT  RDFFUFCB,WC,L       1442 READER UFCB ADDRESS
         $LD   RPFFREQ             GET REQUEST IDENTIFICATION
         $TSL  STPOPEN             GENERATE REQUEST TO SEND
         $BNZ  RPFFTRT             CYCLE UNTIL ACCEPTED
         $STL  RPFFTVE+D1          RESET VARIABLE ENTRY
         $LD   RDFFUSTR,,L         GET STATUS AND RCB
         $AND  RPFFPRM             TEST FOR PERMISSION
         $BZ   RPFFTRT             BRANCH IF NOT RECEIVED
         $LD   RPFFRCN             SETUP
         $STO  RPFFCTL              FOR
         $LD   RPFFCRD               BUFFERED
         $STO  RPFFVRC                READ
         $LD   RPFFBFP                 I/O
         $STO  RPFFIOAR                 OPERATION
         $B    RPFFSIO             GO START I/O
.NO1442C ANOP
         AIF   (NOT &PN1442).NO1442S
***********************************************************************
*              1442 PUNCH INITIALIZATION                              *
***********************************************************************
RPFFPUN  $NULL
         $DEQUE PNFF2AQP           GET A PUNCH ENTRY
         $BZ   RPFFTRT             NON-PROCESS EXIT IF NO ENTRY
         $STO  RPFFPNEL            SAVE PUNCH ELEMENT ADDRESS
         $LXA  RPFFPNEL,WA         ADDRESS OF ELEMENT TO WA
         $MDX  PN1442DT,WA,X       POINT WA TO DATA
         $STX  RPFFIOAR,WA         SAVE POINTER FOR I/O
         $LD   RPFFWCN             SET IOCC FOR
         $STO  RPFFCTL             WRITE CONTROL
         $LD   RPFFCWR             SET COLUMN IOCC
         $STO  RPFFVRC             TO WRITE
.NO1442S ANOP
***********************************************************************
*              READ/WRITE 1442 I/O PROCESSOR                          *
***********************************************************************
RPFFSIO  $STL  RPFFACT             SET 1442 ACTIVE FLAG
RPFFSLC  $LD   RPFFIOAR            GET DATA/BUFFER ADDRESS
RPFFSVO  $STO  RPFFXAD             POINTER AND STORE IN IOAR
         $ZAC                      CLEAR AC AND TURN
         $STO  RPFFERR             OFF ERROR FLAG
         $STL  RPFFOPC             SET OPERATION NOT COMPLETE
RPFFSET  $XIO  RPFFSWR-D1          SENSE WITHOUT RESET
         $AND  RPFFRBM             MASK ALL BUT NOT READY AND BUSY
         $BNZ  RPFFNOT             ISSUE MESSAGE IF NOT READY
         $XIO  RPFFCTL-D1          READ/WRITE CONTROL
         $STL  RPFFTVE+D1          SET VARIABLE ENTRY POINT
         $MDM  RPFFOPC,0           TEST FOR I/O COMPLETED
         $B    RPFFTNP             NO. NON-PROCESS EXIT
         $MDM  RPFFERR,0           TEST FOR I/O ERROR
         $B    RPFFSLC             YES...TRY AGAIN
         $MDM  RPFFLSC,0           TEST LAST CARD FLAG
         $B    RPFFLST             BRANCH IF WAVING
         AIF   (NOT &RD1442).NO1442D
         AIF   (NOT &PN1442).NO1442T
         $MDM  RPCNTRL,0           TEST FUNCTION INDICATOR
         $B    RPPNEXT             BRANCH IF PUNCHING
.NO1442T ANOP
***********************************************************************
*              HOUSEKEEPING PREPARATORY TO READING NEXT CARD          *
***********************************************************************
         $STL  RPFFTVE+D1          SET VARIABLE ENTRY POINT
         $LDD  RPFFBFP             GET BUFFER POINTERS
         $MDM  SRPFTANK,0          TEST FOR AVAILABLE TANK
         $B    RPFFTNP             NON-PROCESS EXIT IF NOT AVAILABLE
         $STO  SRPFTANK,,L         QUEUE THE ACTUAL DATA POINTER
         $MDM  SRPFTANK,-1          MINUS ONE FOR RCB/SRCB WORD
         $RTE  16                  SWITCH BUFFERS
         $STD  RPFFBFP             STORE POINTERS
         $STO  RPFFIOAR            SAVE FOR POSSIBLE RETRY
         $B    RPFFSVO             GO START NEXT READ
.NO1442D ANOP
         AIF   (NOT &PN1442).NO1442U
***********************************************************************
*              HOUSEKEEPING PREPARATORY TO PUNCHING NEXT CARD         *
***********************************************************************
RPPNEXT  $NULL
         $LD   RPFFPNEL            GET PUNCH ELEMENT ADDRESS
         $QFREL PNFF2FQP           RETURN ELEMENT TO FREE QUEUE
         $STL  RPFFTVE+D1          SET VARIABLE ENTRY POINT
         $DEQUE PNFF2AQP           GET NEXT PUNCH ELEMENT
         $BZ   RPFFTRT             NON-PROCESS EXIT UNTIL AVAILABLE
         $STO  RPFFPNEL            SAVE PUNCH ELEMENT ADDRESS
         $LXA  RPFFPNEL,WA         ADDRESS OF ELEMENT TO WA
         $LD   PN1442CB,WA,X       GET ELEMENT CONTROL WORD
         $MDX  PN1442DT,WA,X       POINT WA TO DATA
         $STX  RPFFIOAR,WA         SAVE POINTER FOR I/O
         $BNZ  RPFFSLC             GO START I/O IF MORE PUNCH
         $STO  RPFFACT             SET 1442 IDLE FLAG
         $LD   RPFFPNEL            GET PUNCH ELEMENT ADDRESS
         $QFREL PNFF2FQP           RETURN DUMMY ELEMENT TO QUEUE
         $B    RPFFTNE             EXIT
.NO1442U ANOP
         EJECT
***********************************************************************
*              LAST CARD PROCESSING                                   *
***********************************************************************
RPFFLST  $NULL
         $XIO  RPFFEED-D1          CLEAR THE 1442
         $ZAC                      CLEAR AC AND LOWER
         $STO  RPFFLSC             LAST CARD FLAG
         AIF   (NOT &RD1442).NO1442E
         AIF   (NOT &PN1442).NO1442V
         $MDM  RPCNTRL,0           TEST FUNCTION INDICATOR
         $B    RPFFPLC             BRANCH IF PUNCHING
.NO1442V ANOP
         $STO  RPFFACT             SET 1442 IDLE FLAG
         $STL  RPFFTVE+D1,L        RESET VARIABLE ENTRY POINT
         $LD   SRPFTANK,,L         GET TANK QUEUE AND
         $BNZ  RPFFTRT             EXIT IF PREVIOUS NOT DONE
         $LD   RPFFBFP             GET INPUT BUFFER POINTER
         $STO  SRPFTANK,,L         QUEUE THE ACTUAL DATA POINTER
         $MDM  SRPFTANK,-1          MINUS ONE FOR FLAG WORD
         $STO  RDFFUFLG,,L          AND SET EOF IN UFCB
         $B    RPFFTXT,,L          EXIT
.NO1442E ANOP
         AIF   (NOT &PN1442).NO1442W
RPFFPLC  $NULL                     LAST CARD WHILE PUNCHING
         $LD   RPFFPNEL            GET ELEMENT ADDRESS
         $QFREL PNFF2FQP           RETURN ELEMENT TO QUEUE
         $B    RPFFTXT,,L          EXIT WITH GATE OPEN
.NO1442W ANOP
***********************************************************************
*              POINTERS, FLAGS, COMMANDS AND BUFFERS                  *
***********************************************************************
         $BSS  0,E
         AIF   (NOT &RD1442).NO1442H
RPFFBFP  $ADCON RPFFBF1            BUFFER 1 POINTER
         $ADCON RPFFBF2            BUFFER 2 POINTER
.NO1442H ANOP
RPFFXAD  DC    AL2(*-*)            BUFFER PLUS COLUMN ADDRESS    E
RPFFVRC  DC    AL2(*-*)            READ OR WRITE COMMAND         O
RPFFOPC  DC    AL2(*-*)            OPERATION STATUS FLAG         E
RPFFWCN  DC    AL2($CONTROL+$1442+1) START 1442 WRITE            O
RPFFERR  DC    AL2(*-*)            OPERATION ERROR FLAG          E
RPFFSRS  DC    AL2($SENSED+$1442+1) SENSE 1442 WITH RESET        O
RPFFLSC  DC    AL2(*-*)            LAST CARD FLAG                E
RPFFCTL  DC    AL2(*-*)            READ OR WRITE CONTROL         O
RPFFPNEL DC    AL2(*-*)            ADDRESS OF PUNCH ELEMENT      E
RPFFSR4  DC    AL2($SENSED+$1442+2) SENSE-LEVEL 4 RESET          O
RPFFIOAR DC    AL2(*-*)            DATA OR BUFFER POINTER        E
RPFFEED  DC    AL2($CONTROL+$1442+2) FEED CYCLE COMMAND          O
         EJECT
***********************************************************************
*              1442 COLUMN INTERRUPT PROCESSOR - SLIP 0               *
***********************************************************************
RPCOLINT $NULL                     ENTRY FROM FLIP 0
         $XIO  RPFFSRS-D1          SENSE WITH RESET
         $XIO  RPFFXAD             ISSUE READ OR WRITE COMMAND
         $MDM  RPFFXAD,1           INCREMENT COLUMN POINTER
         $B    RTPL0RTN,,L         RETURN TO FLIP 0
***********************************************************************
*              1442 OPERATION COMPLETE INTERRUPT PROCESSOR - SLIP 4   *
***********************************************************************
RPFFTINT $NULL                     ENTRY FROM FLIP 4
         $XIO  RPFFSR4-D1          SENSE WITH LEVEL 4 RESET
         $SLA  3                   GET 'ERROR CHECK' BIT
         $BC   RPFFRFR             BRANCH IF ERROR
         $BSC  P+Z                 TEST LAST CARD
         $B    RPFFLAS             BRANCH IF LAST CARD
RPFFXIT  $ZAC                      CLEAR AC AND SET
         $STO  RPFFOPC             OPERATION COMPLETE FLAG
         $B    RTPL4RTN,,L         EXIT TO FLIP 4
RPFFRFR  $STL  RPFFERR             RUN UP ERROR FLAG
         $B    RPFFXIT             EXIT TO FLIP 4
RPFFLAS  $STL  RPFFLSC             RUN UP LAST CARD FLAG
         $B    RPFFXIT             EXIT TO FLIP 4
         AIF   (NOT &RD1442).NO1442B
         DC    AL2(80)             BUFFER DATA COUNT
RPFFBF1  $BSS  80                  BUFFER 1
         DC    AL2(80)             BUFFER DATA COUNT
RPFFBF2  $BSS  80                  BUFFER 2
.NO1442B ANOP
         AIF   (&PR1403 EQ 0).NO1403C
         TITLE 'RTP1130 (COMMUTATOR ROUTINE FOR 1403 PRINTER)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - PRFOT (1403 PRINTER COMMUTATOR ROUTINE)                     *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              ISSUE INTERVENTION REQUIRED MESSAGE AND WAIT           *
***********************************************************************
PRFOINV  $NULL                     ENTRY FROM PRFOWTE SECTION
         $MDM  PRFOMSW,0           TEST MESSAGE ISSUED FLAG
         $B    PRFOTNP             EXIT IF MESSAGE ISSUED
         $WTO  PRFOMSG,PRFOTRT     TELL OPERATOR ABOUT IT
         $STL  PRFOMSW             SET MESSAGE ISSUED FLAG
         $B    PRFOTNP             WAIT FOR OPERATOR ACTION
PRFOMSG  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(30)             DATA COUNT
         DC    C'INTERVENTION REQUIRED ON 1403 '
PRFOMSW  DC    AL2(*-*)            MESSAGE ISSUED FLAG
***********************************************************************
*              ENTRY POINT FROM COMMUTATOR                            *
***********************************************************************
PRFOTEP  $NULL                     ENTRY POINT FROM COMMUTATOR
PRFOTVE  $B    PRFOTNI,,L          VARIABLE ENTRY VECTOR
PRFOTNP  $B    PRFOTRT,,L          NON-PROCESS EXIT POINT
***********************************************************************
*              PROCESS END OF PRINT FILE                              *
***********************************************************************
PRFOEOF  $LD   PRFOAQE             GET NULL TANK POINTER
         $QFREL PRFO3FQP           RETURN TANK TO FREE CHAIN
PRFOTNI  $NULL                     NORMAL ENTRY POINT
PRFOGET  $STL  PRFOTVE+D1          RESET VARIABLE ENTRY POINT
         $DEQUE PRFO3AQP           GET A PRINT ELEMENT
         $BZ   PRFOTRT             BRANCH IF NOT AVAILABLE
         $STO  PRFOAQE             SAVE ELEMENT ADDRESS
         $LXA  PRFOAQE,WA          ELEMENT ADDRESS TO WA
         $MDX  PR1403DT,WA,X       POINT WA TO PRINT DATA
         $STX  PRFOIOA,WA          STORE ADDRESS IN IOAR
*                                  GET ELEMENT CONTROL WORD
         $LD   (PR1403CB-PR1403DT),WA,X
         $BZ   PRFOEOF             EXIT IF LAST LINE PRINTED
         $SLA  10                  GET SRCB (BIT 2)
         $STO  PRFOSCC             SAVE FOR LATER USE
         $BN   PRFOCCN             BRANCH IF SPACE OR SKIP IMMEDIATE
         $LD   PRFOSTM             SET DSW TEST MASK TO CHECK
         $STO  PRFOVMS              PRINTER AND CARRIAGE BUSY
         $BSI  PRFOWTE             BE SURE WRITE CAN BE ISSUED
         $STO  PRFOBFI             SET BUFFER INDICATOR NOT FULL
         $XIO  PRFOIOA             ISSUE INITIATE WRITE COMMAND
         $STL  PRFOTVE+D1          RESET VARIABLE ENTRY POINT
         $LD   PRFOBFI             WAIT FOR 1403 HARDWARE BUFFER
         $BZ   PRFOTRT              TO COMPLETE FILLING...
         $LD   PRFOSCC             GET SHIFTED SRCB FOR CARRIAGE
         $SKPZ                     SKIP IF WRITE-NO SPACE
         $B    PRFOCCN             OTHERWISE, OFF TO CC ROUTINE
PRFOEXT  $LD   PRFOAQE             GET ELEMENT ADDRESS
         $QFREL PRFO3FQP           RETURN TO FREE ELEMENT QUEUE
         $B    PRFOGET             GO GET MORE PRINT DATA
***********************************************************************
*              SUBROUTINE TO WAIT UNTIL 1403 NOT BUSY AND READY       *
***********************************************************************
PRFOWTE  DC    AL2(*-*)            ENTRY VIA $BSI PRFOWTE
         $STL  PRFOTVE+D1          SET VARIABLE ENTRY POINT
         $XIO  PRFOSWR-D1          SENSE 1403 WITHOUT RESET
         $BOD  PRFOINV             BRANCH IF NOT READY
         $AND  PRFOVMS             CLEAR ALL BUT BUSY BITS
         $BNZ  PRFOTRT             NON-PROCESS EXIT IF BUSY
         $STO  PRFOMSW             RESET MESSAGE ISSUED FLAG
         $B    PRFOWTE,,I          RETURN TO CALLER
***********************************************************************
*              CONSTANTS, COMMANDS AND STORAGE                        *
***********************************************************************
         $BSS  0,E                 EVEN STORAGE REQUIRED
PRFOIOA  DC    AL2(*-*)            SET TO ELEMENT DATA FIELD ADDRESS
         DC    AL2($1403+$IWRITE)  INITIATE WRITE COMMAND
PRFOWCM  $ADCON PRFOSKB            ADDRESS OF CHANNEL SKIP BIT WORD
         DC    AL2($1403+$WRITE)   WRITE COMMAND FOR SKIP
PRFOAQE  DC    AL2(*-*)            ACTIVE QUEUE ELEMENT ADDRESS
PRFOSWR  DC    AL2($1403+$SENSED)  SENSE 1403 WITHOUT RESET
PRFOSCC  DC    AL2(*-*)            STORAGE FOR SHIFTED SRCB
PRFOSRS  DC    AL2($1403+$SENSED+1) SENSE 1403 WITH RESET
PRFOVMS  DC    AL2(*-*)            VARIABLE PRINTER-CARRIAGE MASK
PRFOCNT  DC    AL2($1403+$CONTROL) CONTROL COMMAND TO SPACE 1 LINE
PRFOSTM  DC    X'0006'             MASK FOR DSW BUSY BITS
PRFOSKB  DC    AL2(*-*)            CALCULATED CHANNEL SKIP BIT
PRFODSW  DC    AL2(*-*)            DSW STORAGE FOR FLIP 4
PRFOCNB  DC    X'1000'             MODEL CHANNEL SKIP BIT
PRFODMS  DC    X'8600'             MASK FOR ALL BUT DSW ERROR BITS
PRFOWOC  DC    X'0004'             MASK FOR CARRIAGE BUSY BIT
PRFOBFI  DC    AL2(*-*)            HARDWARE BUFFER FULL INDICATOR
***********************************************************************
*              SUBROUTINE TO PERFORM SPACE AND SKIP FUNCTIONS         *
***********************************************************************
PRFOCCN  $NULL                     ENTRY WITH ADJUSTED SRCB IN AC
         $SLA  1                   SHIFT OUT SRCB BIT 2
         $LDS  0                   TURN OFF CARRY (AND OVERFLOW)
         $SLA  1                   SHIFT OUT SRCB BIT 3
         $SRA  12                  COUNT FIELD TO LOW ORDER AC
         $STO  WA,,L               STORE IN WA
         $LD   PRFOWOC             SET DSW MASK TO CHECK
         $STO  PRFOVMS              ONLY FOR CARRIAGE BUSY
         $BC   PRFOCHN             BRANCH IF SKIP TO CHANNEL N
***********************************************************************
*              THIS SECTION SIMULATES SPACE N FUNCTION                *
***********************************************************************
PRFOSLP  $BSI  PRFOWTE             WAIT FOR ANY PREVIOUS OPERATION
         $XIO  PRFOCNT-D1          ISSUE SPACE CONTROL COMMAND
         $MDX  -1,WA               DECREMENT SPACE COUNT
         $B    PRFOSLP             ISSUE ANOTHER SPACE
         $B    PRFOEXT             GO TO EXIT PROCEDURE
***********************************************************************
*              THIS SECTION ISSUES SKIP TO CHANNEL N COMMANDS         *
***********************************************************************
PRFOCHN  $LD   PRFOCNB             GET MODEL CHANNEL SKIP BIT
         $SRA  0,WA                POSITION AND SET
         $STO  PRFOSKB             FOR SKIP WRITE COMMAND
         $BSI  PRFOWTE             WAIT FOR PREVIOUS OPERATION
         $XIO  PRFOWCM             ISSUE SKIP COMMAND
         $B    PRFOEXT             GO TO EXIT PROCEDURE
***********************************************************************
*              1403 INTERRUPT PROCESSOR - SLIP 4                      *
***********************************************************************
PRFOTINT $NULL                     ENTRY FROM FLIP 4
         $XIO  PRFOSRS-D1          SENSE 1403 WITH RESET
         $STO  PRFODSW             SAVE DEVICE STATUS WORD
         $AND  PRFOSVT             CLEAR ALL BUT BUFFER FULL BIT
         $SKPZ                     PREVENT PREMATURE RESET...
         $STO  PRFOBFI             SET BUFFER FULL INDICATOR
         $LD   PRFODSW             GET DEVICE STATUS WORD
         $AND  PRFOPCM             MASK ALL BUT 'PRINT COMPLETE' BIT
         $BZ   RTPL4RTN            IGNORE ALL OTHER INTERRUPTS
         $LD   PRFODSW             GET STATUS WORD
         $AND  PRFODMS             MASK ALL BUT ERROR BITS
         $BZ   RTPL4RTN            EXIT TO FLIP 4 IF NO ERRORS
         $MDM  $ERRFFWT,1           OTHERWISE, DING ERROR COUNTER
         $B    RTPL4RTN,,L           AND THEN EXIT TO FLIP 4...
PRFOSVT  DC    X'4000'             MASK FOR BUFFER FULL BIT
PRFOPCM  DC    X'2000'             'PRINT COMPLETE' BIT MASK
.NO1403C ANOP
         AIF   (&PR1132 EQ 0).NO1132B
         TITLE 'RTP1130 (COMMUTATOR ROUTINE FOR 1132 PRINTER)'
***********************************************************************
*                                                                     *
* TITLE - PRETT (1132 PRINTER COMMUTATOR ROUTINE)                     *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              ISSUE INTERVENTION REQUIRED MESSAGE AND WAIT           *
***********************************************************************
PRETINV  $NULL                     ENTRY FROM PRETWTE SECTION
         $MDM  PRETMSW,0           TEST MESSAGE ISSUED FLAG
         $B    PRETTNP             EXIT IF MESSAGE ISSUED
         $WTO  PRETMSG,PRETTRT     TELL OPERATOR ABOUT 1132
         $STL  PRETMSW             SET MESSAGE ISSUED FLAG
         $B    PRETTNP             WAIT FOR OPERATOR ACTION
PRETMSG  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(30)             DATA COUNT
         DC    C'INTERVENTION REQUIRED ON 1132 '
         $BSS  0,E
PRETK48  DC    AL2(48)             CYCLE COUNTER CONSTANT
         DC    AL2(12)             CYCLE COUNTER CONSTANT
PRETAQE  DC    AL2(*-*)            PRINT ELEMENT ADDRESS
PRETCNT  DC    AL2(*-*)            PRINT ELEMENT WORD COUNT
***********************************************************************
*              ENTRY POINT FROM COMMUTATOR                            *
***********************************************************************
PRETTEP  $NULL                     ENTRY POINT FROM COMMUTATOR
PRETTVE  $B    PRETTNI,,L          VARIABLE ENTRY VECTOR
PRETTNP  $B    PRETTRT,,L          NON-PROCESS EXIT POINT
***********************************************************************
*              PROCESS END OF PRINT FILE                              *
***********************************************************************
PRETDNE  $LD   PRETAQE             GET NULL PRINT ELEMENT
         $QFREL PRET2FQP           RETURN ELEMENT TO FREE CHAIN
PRETTNI  $NULL                     NORMAL ENTRY POINT
PRETGIT  $STL  PRETTVE+D1          RESET ENTRY POINT
         $DEQUE PRET2AQP           GET A PRINT ELEMENT
         $BZ   PRETTRT             NON-PROCESS EXIT IF NONE
         $STO  PRETAQE             SAVE ADDRESS OF ELEMENT
         $LXA  PRETAQE,WA          ELEMENT ADDRESS TO WA
         $MDX  PR1132DT,WA,X       POINT WA TO PRINT DATA
         $STX  PRETDTA,WA,L        SAVE ADDRESS OF PRINT
         $STX  PRETFROM+D1,WA,L    DATA FOR PRESCAN
         $LD   (PR1132CB-PR1132DT),WA,X GET ELEMENT CONTROL WORD
         $BZ   PRETDNE             BRANCH IF LAST LINE PRINTED
         $SLA  10                  GET SRCB BIT 2
         $STO  PRETSCC             SAVE ADJUSTED SRCB
         $BNN  PRETRLD             BRANCH IF NOT IMMEDIATE OPERATION
         $BSI  PRETCCN             GO TO CARRIAGE CONTROL ROUTINE
         $LD   PRETAQE             GET ELEMENT ADDRESS
         $QFREL PRET2FQP           RETURN TO FREE CHAIN
         $B    PRETGIT             GET NEXT PRINT LINE
PRETRLD  $LD   (PR1132LC-PR1132DT),WA,X GET ELEMENT LINE CONTROL WORD
         $SRT  8                   ISOLATE NUMERIC INDICATOR
         $STO  PRETNUM,,L          SAVE FOR LATER INTERROGATION
         $ZAC                      CLEAR POSSIBLE INDICATOR
         $SLT  7                   GET NUMBER OF WORDS TO PRINT
         $STO  PRETCNT             SAVE IT
         $SRA  8                   CLEAR AC AND
         $S    PRETCNT             COMPLEMENT WORD COUNT
         $STO  PRENEGWD,,L         SAVE IT IN
         $STO  PRENEGW2,,L         VARIOUS PLACES
         $B    PREPRSCN,,L         GO TO PRESCAN ROUTINE
PRETSRTN $NULL                     RETURN FROM PRESCAN
         $LD   PRETAQE             GET PRINT ELEMENT ADDRESS
         $QFREL PRET2FQP           RETURN TO FREE ELEMENT QUEUE
         $BSI  PRETWTE             BE SURE PRINT CAN START
         $LDD  PRETK48             SET COUNTERS FOR A
         $STO  PRECTR48,,L         TOTAL OF 66
         $STD  PRECTR16,,L         PRINTER CYCLES
         $BSI  PRETCLRS            GO CLEAR SCAN AREA
         $MDM  $PRTSCAN+7,1        INSERT SCAN COMPLETE BIT
         $XIO  PRESTRTP-D1         START THE PRINTER
         $STL  PRETTVE+D1          RESET VARIABLE ENTRY POINT
         $LD   PRETCTR2,,L         GET PRINT COMPLETE FLAG
         $BNZ  PRETTRT             NON-PROCESS EXIT IF NOT DONE
         $LD   PRETSCC             GET ADJUSTED SRCB
         $BSI  PRETCCN,,L,Z        BRANCH IF CARRIAGE CONTROL REQUIRED
         $B    PRETGIT             GO GET MORE DATA
PRETMSW  DC    AL2(*-*)            MESSAGE ISSUED FLAG
         EJECT
***********************************************************************
*              ROUTINE TO PROCESS CARRIAGE CONTROL FUNCTIONS          *
***********************************************************************
PRETCCN  DC    AL2(*-*)
         $SLA  1                   SHIFT OUT SRCB BIT 2
         $LDS  0                   TURN OFF CARRY INDICATOR
         $SLA  1                   SHIFT OUT SRCB BIT 3
         $SRA  12                  COUNT FIELD TO LOW ORDER
         $STO  WA,,L               AC AND WA
         $BC   PRETSCK             BRANCH IF SKIP OPERATION
***********************************************************************
*              THIS SECTION SIMULATES THE SPACE N FUNCTION            *
***********************************************************************
PRETSPC  $NULL
         $BSI  PRETWTE             WAIT FOR PREVIOUS OPERATION
         $XIO  PRETSPA-D1          ISSUE SPACE CONTROL COMMAND
         $MDX  -1,WA               DECREMENT SPACE COUNT
         $B    PRETSPC             ISSUE ANOTHER SPACE
         $B    PRETCCN,,I          RETURN
***********************************************************************
*              THIS SECTION INITIATES SKIP TO CHANNEL N FUNCTION      *
***********************************************************************
PRETSCK  $NULL
         $LD   PRETMDS             GET MODEL SKIP BIT
         $SRA  0,WA                SHIFT COUNT=CHANNEL SPECIFIED
         $BOD  PRETSKT             BRANCH IF CHANNEL 12
         $SRA  3                   TRY CHANNEL 9
         $BOD  PRETSKN             BRANCH IF CHANNEL 9
         $SRA  3                   ASSUME CHANNELS 1-6
         $SLA  1                   POSITION MODEL BIT TO
PRETSKN  $SLA  1                   CORRESPOND TO INTERRUPT
         $SKPN                     SKIP IF LEGAL CHANNEL
         $LD   PRETCN1             OTHER WISE USE CHANNEL 1
PRETSKT  $STO  PRETSKM             SAVE FOR INTERRUPT TIME COMPARE
         $BSI  PRETWTE             WAIT FOR PREVIOUS OPERATION
         $XIO  PRETSCX-D1          ISSUE SKIP COMMAND
         $B    PRETCCN,,I          RETURN
         EJECT
***********************************************************************
*              CONSTANTS FOR CARRIAGE CONTROL ROUTINE                 *
***********************************************************************
         $BSS  0,E
PRETSCC  DC    AL2(*-*)            ADJUSTED SRCB STORAGE
PRETSPA  DC    AL2($1132+$CONTROL+1) SPACE CONTROL
PRETSTM  DC    X'0009'             PRINTER AND CARRIAGE BUSY MASK
PRESTRTP DC    AL2($1132+$CONTROL+128) START PRINTER COMMAND
PRETCN1  DC    AL2(X'0080')        CHANNEL 1 SKIP BIT
PRETSCX  DC    AL2($1132+$CONTROL+4) SKIP CONTROL
PRETSKM  DC    AL2(*-*)            MASK FOR CHANNEL SKIP CONTROL
PRETSNR  DC    AL2($1132+$SENSED)  SENSE WITHOUT RESET
PRETMDS  DC    X'1000'             MODEL CHANNEL SKIP BIT
***********************************************************************
*              WAIT FOR PRINTER OR CARRIAGE NOT BUSY                  *
***********************************************************************
PRETWTE  DC    AL2(*-*)            ENTRY VIA $BSI PRETWTE
         $STL  PRETTVE+D1          RESET VARIABLE ENTRY POINT
         $XIO  PRETSNR-D1          SENSE 1132 WITHOUT RESET
         $SRT  10                  GET PRINTER NOT READY BIT
         $BOD  PRETINV             BRANCH IF NOT READY...
         $SLT  1                   RESTORE PRINTER BUSY BIT
         $AND  PRETSTM             ISOLATE BUSY INDICATORS
         $BNZ  PRETTRT             NON-PROCESS EXIT IF BUSY
         $STO  PRETMSW             RESET MESSAGE ISSUED FLAG
         $B    PRETWTE,,I          RETURN TO CALLER
***********************************************************************
*              ROUTINE TO CLEAR PRINT SCAN AREA                       *
***********************************************************************
PRETCLRS DC    AL2(*-*)            ENTRY VIA $BSI PRETCLRS
         $AXT  0,WB                CLEAR WB AND
         $SLT  32                  AC/EXT AND LOCATIONS..
         $STD  $PRTSCAN,WB,X       32-33
         $STD  $PRTSCAN+2,WB,X     34-35
         $STD  $PRTSCAN+4,WB,X     36-37
         $STD  $PRTSCAN+6,WB,X     38-39
         $B    PRETCLRS,,I         RETURN
***********************************************************************
*              INTERNAL PRINT BUFFER AND CHARACTER TABLE              *
***********************************************************************
PRETTABL $BSS  64,E                CHARACTER TABLE
PRETBUFR $BSS  120                 PRINT BUFFER
         EJECT
***********************************************************************
*              INITIALIZATION FOR PRESCAN ROUTINE                     *
***********************************************************************
PREPRSCN $NULL
         $AXT  184,WB,L            LENGTH OF TABLE PLUS BUFFER
         $SLT  32                  CLEAR AC AND EXT AND
PRELOOP1 $STD  PRETTABL-2*D1,WB,L  TABLE PLUS BUFFER
         $MDX  -2,WB               DECREMENT COUNTER
         $B    PRELOOP1            KEEP GOING
         $STO  PRECTRSF            CLEAR PRECTRSF
***********************************************************************
*                                                                     *
*              ROUTINE TO EXAMINE EACH CHARACTER IN PRINT ELEMENT AND *
*              BUILD A CHARACTER TABLE INDICATING FOR EACH OF THE 48  *
*              PRINTABLE CHARACTERS THE NUMBER OF MASK WORDS REQUIRED *
*              AND THEIR RELATIVE LOCATIONS IN THE PRINT SCAN AREA    *
*                                                                     *
***********************************************************************
PRELOOP2 $AXT  16,WA               SET GROUP INDEX
PRELOOP3 $BSI  PRETGET             GET CHARACTER TABLE ADDRESS
         $LD   PRETAENT,,I         GET CHARACTER TABLE ENTRY
         $SRT  0,WB                CHECK RELATIVE WORD AND
         $BOD  PRETCHK             TEST FOR ANY OTHER CHARACTERS
         $OR   PRETKN1             IN THIS GROUP OF 16. NO, SET
         $SLT  0,WB                INDICATOR PLUS, ADD ONE TO
         $A    PREK0100            COUNT OF MASK WORDS REQUIRED
         $STO  PRETAENT,,I         FOR CHARACTER. REENTER TABLE
PRETCHK  $LD   PRENEGWD,,L         CHECK FOR SCAN DONE
         $BZ   PRELOOP8            EXIT IF DONE
         $MDX  -1,WA               ADJUST COUNTERS
         $B    PRELOOP3            FOR NEXT PASS
         $TSL  PRETTVE+D1          CYCLE COMMUTATOR
         $MDX  1,WB                LOOP
         $B    PRELOOP2            AGAIN
***********************************************************************
*              AFTER SCAN OF USERS PRINT BUFFER, SCAN THE CONSTRUCTED *
*              TABLE AND DETERMINE THE STARTING RELATIVE LOCATION FOR *
*              THE MASK WORDS TO BE STORED IN THE INTERNAL PRINT      *
*              BUFFER                                                 *
***********************************************************************
PRELOOP8 $AXT  64,WB               TABLE SIZE TO WB
PRELOOP4 $LD   PRETTABL-D1,WB,L    GET TABLE ENTRY
         $SRT  8                   LEFT HALF
         $STO  PRETTEMP            SAVE IT
         $A    PRECTRSF            UPDATE RELATIVE ADDRESS
         $STO  PRECTRSF            IN BUFFER FOR THIS
         $S    PRETTEMP            CHARACTER
         $SLT  8
         $STO  PRETTABL-D1,WB,L    STORE BACK IN TABLE
         $MDX  -1,WB               POINT TO NEXT ENTRY
         $B    PRELOOP4            GET IT
         EJECT
***********************************************************************
*              SCAN THE PRINT DATA TO CONSTRUCT THE ACTUAL MASK WORDS *
*              THAT ARE REQUIRED FOR INSERTING INTO THE SCAN AREA AT  *
*              EACH CHARACTER INTERUPT CYCLE                          *
***********************************************************************
         $LD   PRENEGW2            SET TO SCAN PRINT LINE
         $STO  PRENEGWD            TO CONSTRUCT MASK WORDS
         $LD   PRETDTA             IN BUFFER
         $STO  PRETFROM+D1         SETUP GET ROUTINE
PRELOOP6 $AXT  16,WA               SET GROUP INDEX
PRELOOP5 $BSI  PRETGET             GET CHARACTER TABLE ADDRESS
         $LD   PRETAENT,,I         GET CHARACTER TABLE ENTRY
         $SRT  8                   RELATIVE BUFFER ADDRESS
         $A    PREBADDR            GET ACTUAL BUFFER ADDRESS
         $STO  PREBUENT            AND STORE IT
         $S    PREBADDR
         $SRT  8                   ISOLATE PART OF ENTRY THAT
         $RTE  0,WB                HAS RELATIVE MASK WORDS REQUIRED
PRELOOP7 $BNN  PRELOOP9            LOOP TO FIND RELATIVE MASK
         $MDM  PREBUENT,1          WORD IN BUFFER WHICH
PRELOOP9 $SLA  1                   CORRESPONDS TO THIS CHARACTER
         $BNZ  PRELOOP7            IN THIS PRINT POSITION
         $LDD  PRETKN1             OR IN A BIT INTO THE
         $SRT  1                   APPROPRIATE MASK WORD
         $SLT  0,WA                AND STORE BACK IN
         $OR   PREBUENT,,I         THE PROPER SLOT
         $STO  PREBUENT,,I         IN THE BUFFER
         $LD   PRENEGWD,,L         ARE WE DONE
         $BZ   PRETSRTN            BRANCH IF DONE TO START PRINT
         $MDX  -1,WA               NO. ADJUST COUNTERS
         $B    PRELOOP5            FOR NEXT CHARACTER
         $TSL  PRETTVE+D1          CYCLE COMMUTATOR
         $MDX  1,WB                NEXT SCAN
         $B    PRELOOP6
***********************************************************************
*              CONSTANTS AND POINTERS FOR PRESCAN                     *
***********************************************************************
         $BSS  0,E
PRETDTA  DC    AL2(*-*)            PRINT DATA ADDRESS
PRECTRSF DC    AL2(*-*)            RELATIVE ADDRESS STORAGE
PREK0100 DC    X'0100'             CONSTANT
PRETKN1  DC    AL2(1)              CONSTANT
PRELFTRT DC    AL2(*-*)            LEFT/RIGHT INDICATOR
PRETTEMP DC    AL2(*-*)            TEMPORARY WORK STORAGE
PRETADDR $ADCON PRETTABL           TABLE POINTER
PRETAENT DC    AL2(*-*)            CHARACTER TABLE ENTRY POINTER
PREBADDR $ADCON PRETBUFR           BUFFER POINTER
PREBUENT DC    AL2(*-*)            WORK STORAGE
***********************************************************************
*              SUBROUTINE TO CONVERT PACKED EBCDIC CHARACTER IN TO A  *
*              TABLE ADDRESS OF 0-63 PLUS THE ADDRESS OF THE          *
*              BEGINNING OF THE TABLE                                 *
***********************************************************************
PRETGET  DC    AL2(*-*)            ENTRY VIA $BSI PRETGET
PRETFROM $LD   *-*,,L              GET WORD WITH PACKED EBCDIC
         $MDM  PRELFTRT,0          CHECK LEFT/RIGHT INDICATOR
         $SLA  8                   RIGHT. SHIFT TO LEFT
         $SLA  2                   FOLD INTO 6 BITS
         $SRA  10                  AND CREATE TABLE
         $A    PRETADDR            ENTRY ADDRESS
         $STO  PRETAENT            STORE IT
         $LD   PRELFTRT            ADJUST PRINT DATA ADDRESS
         $A    PRETFROM+D1         BY O OR 1 FOR NEXT
         $STO  PRETFROM+D1         CHARACTER FETCH
         $LD   PRENEGWD            REDUCE WORD COUNT
         $A    PRELFTRT            BY ZERO OR ONE
         $STO  PRENEGWD            AND STORE BACK
         $LD   PRELFTRT            REVERSE SETTING
         $EOR  PRETKN1             OF LEFT/RIGHT
         $STO  PRELFTRT            INDICATOR
         $B    PRETGET,,I          RETURN TO CALLER
         EJECT
***********************************************************************
*              1132 INTERRUPT PROCESSOR - SLIP 1                      *
***********************************************************************
PRETTINT $NULL                     ENTRY FROM FLIP 1 WITH AC/EXT
*                                  AND STATUS SAVED
         $XIO  PRESENSR-D1         SENSE WITH RESET
         $STO  PRETSDSW            SAVE DSW
         $SRA  14                  IGNORE SPACE RESPONSE INTERRUPT
         $BOD  PRETSKP             BRANCH IF SKIP RESPONSE
         $SRA  1                   GET EMITTER INTERRUPT BIT
         $BZ   RTPL1RTN            EXIT TO FLIP 1 IF NOT EMITTER
         $B    PREMITIN            GO TO EMITTER INTERRUPT ROUTINE
***********************************************************************
*              CONSTANTS, COMMANDS AND STORAGE                        *
***********************************************************************
         $BSS  0,E
PRETSDSW DC    AL2(*-*)            DSW STORAGE
PRESTOPC DC    AL2($1132+$CONTROL+2) STOP CARRIAGE CONTROL
PRECTR46 DC    AL2(*-*)            SCAN CHECK CYCLE DELAY COUNTER
PRESTOPP DC    AL2($1132+$CONTROL+64) PRINTER STOP COMMAND
PRETCK46 DC    AL2(46)             CONSTANT 46
PRESENSR DC    AL2($1132+$SENSED+1) SENSE 1132 WITH RESET
PRENEGWD DC    AL2(*-*)            NEGATIVE PRINT WORD COUNT
PRENEGW2 DC    AL2(*-*)            NEGATIVE PRINT WORD COUNT
PRETIMSK DC    AL2(X'00FF')        CLEAR ALL BUT CHANNEL SKIP BITS
PRETCN3  DC    AL2(3)              CONSTANT 3
***********************************************************************
*              SKIP TO CHANNEL N INTERRUPT PROCESSOR                  *
***********************************************************************
PRETSKP  $LD   PRETSDSW            GET INTERRUPT DSW
         $AND  PRETIMSK            CLEAR ALL BUT SKIP BITS
         $EOR  PRETSKM,,L          TEST FOR SELECTED CHANNEL
         $SKPN                     SKIP IF NOT
         $XIO  PRESTOPC-D1         STOP THE CARRIAGE
         $LD   PRETSDSW            GET INTERRUPT DSW
         $BNN  RTPL1RTN            EXIT IF NO EMITTER INTERRUPT
***********************************************************************
*              EMITTER INTERRUPT PROCESSOR                            *
***********************************************************************
PREMITIN $NULL
         $STX  PRETXXWA+D1,WA      SAVE WA
         $STX  PRETXXWB+D1,WB      AND WB
         $LD   PRECTR46            CHECK FOR RESCAN DELAY LOOP
         $BNZ  PREDNG46            BRANCH IF RESCAN DELAY
         $LD   PRETSDSW            GET DSW AND TEST
         $SLA  4                   FOR SCAN CHECK
         $BP   PRETFC70            BRANCH IF NO SCAN CHECK
         $LD   PRETCK46            SET UP FOR 46 CYCLE WAIT
         $STO  PRECTR46            LOOP AND RESUME SCAN FROM
         $TSL  PRETCLRS            LAST GOOD POSITION
         $MDM  $PRTSCAN+7,1        TURN ON SCAN COMPLETE BIT
         $MDM  $ERRETSC,1          DING 1132 SCAN CHECK COUNTER
         $B    PRETXXIT            EXIT IN LOOP MODE
PRETFC70 $LD   PRECTR48            TEST END OF SCAN
         $BNZ  PRETEMIT            BRANCH IF MORE
         $TSL  PRETCLRS            CLEAR SCAN AREA AND
         $MDM  $PRTSCAN+7,1        INSERT COMPLETE BIT
         $LD   PRECTR16            TEST RESTORE COUNTER
         $BNZ  PRETFC81            BRANCH IF NOT DONE
         $MDM  PRETCTR2,-6         DECREMENT 2 CYCLE COUNTER
         $B    PRETXXIT            BRANCH IF NOT ZERO
         $XIO  PRESTOPP            STOP THE PRINTER
PRETXXIT $NULL                     EXIT PROCEDURE
PRETXXWA $AXT  *-*,WA,L            RESTORE WA
PRETXXWB $AXT  *-*,WB,L            AND WB
         $B    RTPL1RTN,,L         EXIT TO FLIP 1
PREDNG46 $S    PRETCNO             DECREMENT RESCAN
         $STO  PRECTR46            WAIT LOOP COUNTER
         $B    PRETXXIT            EXIT
PRETFC81 $S    PRETCN3             DECREMENT RESTORE
         $STO  PRECTR16            CYCLE COUNTER
         $B    PRETXXIT            EXIT
***********************************************************************
*              READS AND PROCESSES CURRENT EMITTER CHARACTER          *
***********************************************************************
PRETEMIT $NULL
         $XIO  PREREADI            READ EMITTER CHARACTER
         $LD   PRETNUM             GET NUMERIC ONLY FLAG
         $BZ   PRETFC75            BRANCH IF ALPHANUMERIC
         $LD   PRETCN22            NUMERIC...SET SCAN
         $STO  PRECTR48            COUNTER TO 22
         $LD   PREWHEEL            GET CHARACTER READ
         $EOR  PREKNUM             COMPARE WITH FIRST NUMERIC
PRETFC74 $BNZ  PRETXXIT            EXIT IF NO MATCH
         $STO  PRETNUM             TURN NUMERIC FLAG OFF
PRETFC75 $LD   PREWHEEL            GET CHARACTER READ AND
         $SLA  2                   CONVERT TO ADDRESS IN THE
         $SRA  10                  CHARACTER TABLE TO INSERT
         $A    PRETKTBL            APPROPRIATE MASK WORDS
         $STO  PRETGTBL+D1         FROM BUFFER TO SCAN AREA
         $TSL  PRETCLRS            GO CLEAR SCAN AREA
PRETFC77 $AXT  -8,WA               SET STORE INDEX
PRETGTBL $LD   *-*,,L              GET TABLE ENTRY AND
         $SRT  8                   STORE BUFFER ADDRESS
         $STO  PRETGMSK+D1         TO WB FOR MASK WORDS
PRETGMSK $AXT  *-*,WB,L            FOR THIS CHARACTER
         $MDX  PRETBUFR,WB,L
         $SRT  8
PRETLOOP $RTE  1                   STORE MASK WORD
         $BNN  PRETUPIT            IN APPROPRIATE SCAN
         $LD   0,WB                AREA LOCATIONS
         $STO  $PRTSCAN+8,WA,X
         $MDX  1,WB                POINT TO NEXT CHARACTER
PRETUPIT $MDX  1,WA                DING STORE INDEX
         $B    PRETLOOP            BRANCH IF MORE
         $LD   PRECTR48            REDUCE SCAN
         $S    PRETCNO             COUNTER BY ONE
         $STO  PRECTR48            FOR EACH PROCESSED CYCLE
         $MDM  $PRTSCAN+7,1        TURN ON SCAN COMPLETE BIT
         $B    PRETXXIT            EXIT
         EJECT
***********************************************************************
*              LOCAL CONSTANTS, COMMANDS                              *
***********************************************************************
         $BSS  0,E
PREREADI $ADCON PREWHEEL           IOCC TO READ
         DC    AL2($1132+$READ)    EMITTED CHARACTER
PRECTR16 DC    AL2(*-*)            CYCLE COUNTER
PRETCTR2 DC    AL2(*-*)            CYCLE COUNTER
PRETCNO  DC    AL2(1)              CONSTANT 1
PRETKTBL $ADCON PRETTABL           TABLE POINTER
PRETNUM  DC    AL2(*-*)            NUMERIC ONLY INDICATOR
PRECTR48 DC    AL2(*-*)            CYCLE COUNTER
PREWHEEL DC    AL2(*-*)            RESTING PLACE
PREKNUM  DC    X'F100'             FIRST NUMERIC
PRETCN22 DC    AL2(22)             NUMERIC CYCLE COUNT
.NO1132B ANOP
         TITLE 'RTP1130 (CONSOLE KB/PRINTER COMMUTATOR ROUTINE)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - CONSL (CONSOLE KEYBOARD/PRINTER COMMUTATOR ROUTINE)         *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
*  TO PROCESS KEYBOARD INPUT AND TO PRINT ON THE CONSOLE TYPEWRITER   *
*  MESSAGES ORIGINATING FROM HASP OR INTERNAL SOURCES.                *
*                                                                     *
*  KEYBOARD INPUT IS INITIATED BY ACTIVATION OF THE 'INT REQ' KEY     *
*  AND BY THE INTERRUPT ROUTINE WHICH SETS A FLAG AND OPENS THE       *
*  CONSOLE ROUTINE GATE. NOTE...THE POSITION OF THE 'KEYBOARD/CONSOLE'*
*  SWITCH IS NOT INTERROGATED AND INPUT IS ASSUMED TO BE FROM THE     *
*  KEYBOARD. THE VALUE OF THE CONSOLE ENTRY KEYS IS READ ON EVERY     *
*  COMMUTATOR PASS AND, IF KEY 0 IS ON, STORED IN LOCATION $ENTKEYS.  *
*  ALL NON-CONTROL CHARACTER INPUT IS PRINTED AND THE CARD CODE VALUE *
*  STORED FOR INVESTIGATION AT EOF TIME. IF THE FIRST CHARACTER OF    *
*  INPUT IS '.' (PERIOD) THEN THE DATA IS ASSUMED TO BE A LOCAL       *
*  COMMAND. ALL OTHER DATA IS TRNSMITTED TO HASP FOR ACTION AS A      *
*  HASP OPERATOR COMMAND.                                             *
*                                                                     *
*   PRINT INPUT IS OBTAINED FROM A QUEUE WHICH ORIGINATES LOCALLY     *
*  AND/OR FROM HASP. DATA TO BE PRINTED MAY BE EBCDIC OR TILT-ROTATE  *
*  AND RED OR BLACK RIBBON. THE FORMAT OF THE MESSAGE AND CONTROL     *
*  DATA IS DESCRIBED UNDER 'CONSOLE MESSAGE GENERAL ACTIVE ELEMENT    *
*  DESCRIPTION'.                                                      *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*              DUMMY CONVERSION ROUTINE FOR TILT-ROTATE INPUT         *
***********************************************************************
CONPDUM  DC    AL2(*-*)            ENTRY WITH CODE IN BITS 8-15
         $SLA  8                   POSITION FOR PRINTING
         $B    CONPDUM,,I          GO PRINT IT
CONPRGM  $ADCON (SXCPRNT)          EBCDIC TO TILT-ROTATE CODE
         $ADCON (CONPDUM)          DUMMY ROUTINE
         DC    AL2(X'0900')        SHIFT TO RED COMMAND
CONPCLR  DC    AL2(X'0500')        SHIFT TO BLACK COMMAND
***********************************************************************
*              SUBROUTINE TO WAIT FOR PRINTER                         *
***********************************************************************
CONWAIT  DC    AL2(*-*)            ENTRY VIA BSI CONWAIT
         $STL  CONSLVE+D1          RESET VARIABLE ENTRY POINT
         $XIO  CONXNOR-D1          SENSE CONSOLE WITHOUT RESET
         $AND  CONPBMK             MASK ALL BUT READY/BUSY BITS
         $BNZ  CONSLRT             CYCLE COMMUTATOR UNTIL AVAILABLE
         $B    CONWAIT,,I          RETURN TO CALLER
CONSLLT  $B    ((CONSLEC-CONSLGT)-2)/2,,X CONSOLE GATE LATCH
         EJECT
***********************************************************************
*              COMMUTATOR ENTRY POINT                                 *
***********************************************************************
CONSLEP  $NULL                     ENTRY POINT FROM COMMUTATOR
CONSLVE  $B    CONSLNI,,L          VARIABLE ENTRY VECTOR
CONSLNP  $B    CONSLRT,,L          NON-PROCESS EXIT POINT
CONSLNE  $NULL                     NORMAL PROCESSING COMPLETE EXIT
         $LD   CONSLLT             CLOSE COMMUTATOR GATE
         $STO  CONSLGT,,L          GATE
CONSLXT  $BSI  CONSLVE+D1          EXIT. RESET TO ENTER AT CONSLNI
CONSLNI  $NULL                     NORMAL ENTRY POINT
CONTEST  $MDM  CONIRQF,0           TEST FOR OPERATOR REQUEST
         $B    CONOPIR             BRANCH IF OPERATOR INTERRUPT
***********************************************************************
*              SECTION TO PRINT QUEUED MESSAGES ON CONSOLE PRINTER    *
***********************************************************************
CONPMGO  $NULL
         $DEQUE CONSLAQP           GET PRINT ACTIVE QUEUE ELEMENT
         $BZ   CONSLNE             EXIT AND CLOSE GATE IF NONE
         $STO  CONPAQP             SAVE ADDRESS OF ELEMENT
         $BSI  CONWAIT             WAIT FOR PRINTER
         $LXA  CONPAQP,WA          TO WA
         $LD   CONMSGDL,WA,X       GET BYTE COUNT OF MESSAGE
         $STO  CONPCNT             STORE IT FOR LOOP CONTROL
         $LD   CONMSGCB,WA,X       GET ELEMENT CONTROL WORD
         $SRT  15                  PROPAGATE SIGN BIT
         $STO  WB,,L               SET RIBBON SHIFT INDEX
         $ZAC                      CLEAR AC AND
         $SLT  7                    GET CONVERSION CODE
         $STO  WC,,L                AND SET CONVERSION INDEX
         $LD   CONPRGM,WC,L        GET CONVERSION ROUTINE ADDRESS
         $STO  CONPLNK+D1           AND SET LINKAGE
         $LD   CONPCLR,WB,L        GET SHIFT CODE
         $STO  CONPDTA             STORE FOR I/O
         $XIO  CONPIOC-D1          SHIFT TO BLACK OR RED
         $LD   CONPCN1             SET LEFT/RIGHT
         $STO  CONXLRS             SWITCH TO LEFT
CONPLUP  $BSI  CONWAIT             WAIT FOR PRINTER
         $LD   CONMSGDT,WA,X       GET INPUT PRINT DATA
         $MDM  CONXLRS,0           TEST LEFT/RIGHT SWITCH
         $SRA  8                   SHIFT LEFT TO RIGHT
CONPLNK  $TSL  *-*                 GO TO SELECTED ROUTINE
         $STO  CONPDTA             STORE RESULTS AND
         $XIO  CONPIOC-D1          PRINT ON KEYBOARD PRINTER
         $LD   CONXLRS             REVERSE
         $EOR  CONXCN1              POSITION
         $STO  CONXLRS               SWITCH
         $SKPZ                     SKIP IF SAME WORD OK
         $MDX  1,WA                POINT TO NEXT WORD
         $MDM  CONPCNT,-1          DECREMENT AND TEST BYTE COUNT
         $B    CONPLUP             BRANCH IF MORE DATA
         $BSI  CONWAIT             WAIT FOR LAST CHARACTER
         $XIO  CONPCRT-D1          ISSUE CARRIAGE RETURN
CONPNUL  $LD   CONPAQP             GET ELEMENT ADDRESS
         $QFREL CONSLFQP           RETURN TO FREE QUEUE
         $B    CONTEST             SEE WHAT'S UP
***********************************************************************
*              LOCAL CONSTANTS, COMMANDS, ETC.                        *
***********************************************************************
         $BSS  0,E
CONPAQP  DC    AL2(*-*)            STORAGE FOR PRINT ELEMENT ADD E
CONXNOR  DC    AL2($CONSOLE+$SENSED) SENSE CONSOLE WITHOUT RESET O
         $ADCON CONPDTA            IOAR FOR FOLLOWING            E
CONPIOC  DC    AL2($CONSOLE+$WRITE) CONSOLE WRITE COMMAND        O
         $ADCON CONPCRC            IOAR OF CARRIAGE COMMAND      E
CONPCRT  DC    AL2($CONSOLE+$WRITE) CONSOLE WRITE COMMAND        O
CONPCRC  DC    X'8100'             CARRIAGE RETURN (NEW LINE)    E
CONPDTA  DC    AL2(*-*)            PRINT DATA STORAGE
CONPCNT  DC    AL2(*-*)            BYTE COUNT
CONPBMK  DC    X'0E00'             BUSY/READY MASK
CONPCN1  DC    AL2(1)              ANOTHER CONSTANT 1
CONXLRS  DC    AL2(*-*)            LEFT/RIGHT
         EJECT
***********************************************************************
*              CONSOLE INTERRUPT PROCESSOR - SLIP 4                   *
***********************************************************************
CONSLINT $NULL                     ENTRY FROM FLIP 4
         $XIO  CONISRS-D1          SENSE CONSOLE DSW WITH RESET
         $BN   RTPL4RTN            IGNORE PRINT COMPLETE INTERRUPT
         $SLA  1                   TRY KEYBOARD RESPONSE BIT
         $BN   CONIKBR             BRANCH IF KEYBOARD ENTRY
         $STL  CONIRQF             MUST BE INTERRUPT REQUEST
         $LD   UNLATCH,,L          OPEN CONSOLE COMMUTATOR
         $STO  CONSLGT,,L          GATE TO PROCESS OPERATOR INPUT
         $B    RTPL4RTN,,L         RETURN TO FLIP 4
CONIKBR  $NULL                     OPERATOR ENTERING DATA
         $STL  CONOPNP             FLAG INPUT AVAILABLE
         $XIO  CONIRDA-D1          READ INTO CONIKDA
         $B    RTPL4RTN,,L         RETURN TO FLIP 4
***********************************************************************
*              CONSOLE INTERRUPT PROCESSOR CONSTANTS,STORAGE,ETC.     *
***********************************************************************
         $BSS  0,E                 EVEN STORAGE ASSIGNMENT
         $ADCON CONIKDA            IOAR FOR COMMAND INPUT DATA   E
CONIRDA  DC    AL2($CONSOLE+$READ) READ COMMAND FOR INPUT DATA   O
CONIKDA  DC    AL2(*-*)            INPUT DATA                    E
CONISRS  DC    AL2($CONSOLE+$SENSED+1) SENSE WITH RESET          O
         $ADCON (CONPRCD)          ADDRESS OF INPUT (PRINT)      E
CONIWRS  DC    AL2($CONSOLE+$WRITE) WRITE COMMAND TO PRINT DATA  O
CONPRCD  DC    AL2(*-*)            CONVERTED INPUT FOR PRINTING
CONIRQF  DC    AL2(*-*)            INTERRUPT REQUEST FLAG
CONOPNP  DC    AL2(*-*)            INPUT AVAILABILITY FLAG
         EJECT
***********************************************************************
*              OPERATOR INTERRUPT REQUEST PROCESSOR                   *
***********************************************************************
CONOPIR  $NULL                     OPERATOR DESIRES TO COMMUNICATE
         $ZAC                      CLEAR AC AND
         $STO  CONIRQF             INTERRUPT REQUEST FLAG
         $STL  CONSLVE+D1          RESET VARIABLE ENTRY POINT
         $LD   SCONTANK,,L         TEST FOR PREVIOUS INPUT
         $BNZ  CONSLRT              AND CYCLE UNTIL PROCESSED
         $DEQUE CONSLFQP           GET A FREE ELEMENT
         $BZ   CONSLRT             NON-PROCESS EXIT IF NONE
         $STO  CONOFQP             SAVE ADDRESS OF ELEMENT
         $TSL  CONWAIT             WAIT FOR CARRIAGE
         $LD   CONPCLR,,L          GET SHIFT COMMAND
         $STO  CONPDTA              AND SHIFT RIBBON
         $XIO  CONPIOC-D1            TO BLACK FOR INPUT
CONOKST  $AXT  CONTANK,WA,L        ADDRESS OF BUILT-IN TANK
         $ZAC                      RESET INPUT
         $STO  CONOCNT              DATA COUNT
CONOCIR  $STO  CONOPNP               AVAILABILITY COUNT
         $XIO  CONOSLT-D1          SELECT CONSOLE KEYBOARD
         $STL  CONSLVE+D1,L        RESET VARIABLE ENTRY POINT
         $LD   CONOPNP             TEST FOR KEYBOARD INPUT
         $BZ   CONSLRT             BRANCH IF NONE YET
***********************************************************************
*              SECTION TO PROCESS EACH INPUT CHARACTER FROM KEYBOARD  *
***********************************************************************
         $LD   CONIKDA             GET KEYBOARD INPUT CHARACTER
         $SRA  1                   TEST FOR ERASE BIT
         $BOD  CONOZAP             BRANCH IF ERASE DESIRED
         $SRA  1                   TEST FOR BACKSPACE BIT
         $BOD  CONOBKS             BRANCH IF BACKSPACE
         $SRA  1                   TEST FOR END OF FILE
         $BOD  CONOEND             BRANCH IF END OF FILE
***********************************************************************
*              PRINT AND STORE NON-CONTROL DATA                       *
***********************************************************************
         $SLA  3                   RESTORE CARD CODE FORMAT
         $STO  1,WA                PUT DATA IN TANK
         $TSL  SXPRESS             CONVERT TO EBCDIC
         $TSL  SXCPRNT              THEN TO PRINT CODE
         $STO  CONPRCD               STORE FOR PRINTING
         $XIO  CONIWRS-D1          PRINT IT....
         $TSL  CONWAIT             WAIT FOR PRINTER
         $LD   CONOCNT             INCREMENT
         $A    CONXCN1              INPUT
         $STO  CONOCNT               COUNTER
         $S    CONOMAX             TEST FOR MAXIMUM
         $BZ   CONOZAP             BRANCH IF LIMIT REACHED
         $MDX  1,WA                POINT TO NEXT TANK WORD
         $ZAC                      CLEAR AC AND
         $B    CONOCIR              GET NEXT INPUT VALUE
         EJECT
***********************************************************************
*              LOCAL CONSTANTS,COMMANDS,ETC.                          *
***********************************************************************
         $BSS  0,E
CONOCNT  DC    AL2(*-*)            COUNT OF BYTES PROCESSED
CONOSLT  DC    AL2($CONSOLE+$CONTROL) CONSOLE SELECT COMMAND
CONOFQP  DC    AL2(*-*)            FQP ADDRESS
CONXCN1  DC    AL2(1)              CONSTANT 1
CONOMAX  DC    AL2(&CONINSZ)       MAXIMUM INPUT MESSAGE
***********************************************************************
*              ERASE INPUT PROCESSOR                                  *
***********************************************************************
CONOZAP  $NULL
         $XIO  CONPCRT-D1          ISSUE CARRIAGE RETURN
         $LD   CONOZML             GET LENGTH OF REPLY
         $AXT  CONOZBC,WB,L        GET SOURCE ADDRESS
         $B    CONORPL             GO PRINT ERASE MESSAGE
***********************************************************************
*              BACKSPACE KEYBOARD PROCESSOR                           *
***********************************************************************
CONOBKS  $NULL
         $B    CONOZAP             TREAT BACKSPACE AS ERASE
***********************************************************************
*              END OF FILE (MESSAGE) PROCESSOR                        *
***********************************************************************
CONOEND  $NULL
         $XIO  CONPCRT-D1          ISSUE CARRIAGE RETURN
         $LD   CONOCNT             GET COUNT OF CHARACTERS
         $BZ   CONOKST             TRY AGAIN IF NULL
         $STO  CONTANK             STORE COUNT IN TANK
         $LD   CONTANK+D1          GET FIRST CHARACTER
         $EOR  CONOLCL             TEST FOR LOCAL COMMANDS
         $BNZ  CONOQFH             NO. GO QUEUE IT FOR HASP
***********************************************************************
*              OPERATOR COMMAND PROCESSOR                             *
***********************************************************************
         $LD   CONTANK+2*D1        GET 2ND CHARACTER
         $EOR  CONODCM             TEST FOR 'DEFINE' COMMAND
         $BZ   CONODCP             BRANCH IF 'DEFINE' COMMAND
***********************************************************************
*              UNIDENTIFIED COMMAND PROCESSOR                         *
***********************************************************************
CONOHUH  $LD   CONOWML             GET LENGTH OF REPLY
         $AXT  CONOWTM,WB,L        GET SOURCE ADDRESS
CONORPL  $LXA  CONOFQP,WA          ADDRESS OF PRINT TANK
         $MDX  CONMSGCB,WA,X       POINT TO CONTROL WORD
         $TSL  SMOVE               MOVE MESSAGE TO ELEMENT
         $LD   CONOFQP             GET ADDRESS OF ELEMENT
         $QACTL CONSLAQP           QUEUE IT FOR PRINT
         $B    CONPMGO,,L          GO PRINT IT
         EJECT
***********************************************************************
*              'WHAT' MESSAGE                                         *
***********************************************************************
CONOWML  DC    AL2(5)              NUMBER OF WORDS FOLLOWING
CONOWTM  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(6)              DATA COUNT
         DC    C'WH'               WH
         DC    C'AT'               AT
         DC    C'? '               ?
***********************************************************************
*              'OK' MESSAGE                                           *
***********************************************************************
CONOKML  DC    AL2(4)              NUMBER OF WORDS FOLLOWING
CONOKMS  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(4)              DATA COUNT
         DC    C'OK'               OK
         DC    C'! '               !
***********************************************************************
*              'INPUT ERASED' MESSAGE                                 *
***********************************************************************
CONOZML  DC    AL2(8)              NUMBER OF WORDS FOLLOWING
CONOZBC  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(12)             DATA COUNT
         DC    C'INPUT ERASED'     MESSAGE
***********************************************************************
*              QUEUE MESSAGES FOR HASP                                *
***********************************************************************
CONOQFH  $NULL
         $AXT  CONTANK,WA,L        ADDRESS OF TANK
         $STX  SCONTANK,WA,L        QUEUE FOR TPPUT
         $LD   CONOFQP             RETURN PRINT
         $QFREL CONSLFQP            ELEMENT TO FREE CHAIN
         $B    CONPMGO,,L          GO TEST FOR PRINT
***********************************************************************
*              LOCAL CONSTANTS                                        *
***********************************************************************
CONOLCL  DC    X'8420'             CARD CODE '.'
CONODCM  DC    X'8200'             CARD CODE 'D'
         EJECT
***********************************************************************
*              'DEFINE' COMMAND PROCESSOR                             *
***********************************************************************
CONODCP  $NULL                     DEFINE 1442-6,7 AS READER OR PUNCH
         AIF (NOT &RP1442).NO1442L
         $LD   CONTANK+3*D1        GET 3RD WORD OF INPUT
         $EOR  CONOPNC             TEST FOR PUNCH COMMAND
         $BZ   CONOPPP             BRANCH IF DEFINE PUNCH
         $LD   CONTANK+3*D1        GET 3RD WORD OF INPUT
         $EOR  CONORDR             TEST FOR READER COMMAND
         $BNZ  CONOHUH             IGNORE IF NONE OF ABOVE
***********************************************************************
*              DEFINE 1442 READER/PUNCH AS READER                     *
***********************************************************************
         $LD   RPFFACT,,L          GET 1442 ACTIVE FLAG
         $BNZ  CONOHUH             IGNORE IF PUNCH ACTIVE
CONOPEN  $STO  RPCNTRL             SET READER FLAG
         $LD   CONUNLT             OPEN 1442
         $STO  RPFFTGT,,L           COMMUTATOR GATE
         $B    CONOKAY             GO TYPE 'OK' MESSAGE
***********************************************************************
*              DEFINE 1442 READER/PUNCH AS PUNCH                      *
***********************************************************************
CONOPPP  $LD   RPFFACT,,L          GET 1442 ACTIVITY FLAG
         $BNZ  CONOHUH             IGNORE REQUEST IF ACTIVE
         $LD   *                   SET PUNCH FLAG
         $B    CONOPEN              IF NOT ACTIVE
***********************************************************************
*              CONSTANTS INDIGENOUS TO 1442 READER/PUNCH AND 'DEFINE' *
***********************************************************************
CONOPNC  DC    X'4040'             CARD CODE 'P'
CONORDR  DC    X'4010'             CARD CODE 'R'
RPCNTRL  DC    AL2(*-*)            1442 READ OR PUNCH FLAG
CONUNLT  $NOP                      LOCAL UNLATCH GATE
.NO1442L ANOP
         AIF   (&RP1442 EQ 1).NO1442M
         $B    CONOHUH             IGNORE DEFINE IF NO 1442 R/P
.NO1442M ANOP
***********************************************************************
*              PRINT 'OK' MESSAGE                                     *
***********************************************************************
CONOKAY  $NULL
         $LD   CONOKML             GET LENGTH OF REPLY
         $AXT  CONOKMS,WB,L        AND MESSAGE ADDRESS
         $B    CONORPL             GO PRINT IT
CONTANK  $BSS  &CONINSZ+1          FIXED KEYBOARD INPUT AREA
         AIF   (NOT &RP1442).NO1442Q
         TITLE 'RTP1130 (READER/PUNCH CONTROL ROUTINE)'
***********************************************************************
*              COMMUTATOR ROUTINE TO SYNCHRONIZE 1442 READER/PUNCH    *
***********************************************************************
RPCNTLT  $B    ((RPCNTEC-RPCNTGT)-2)/2,,X GATE LATCH
RPCNTEP  $NULL                     ACTIVATED BY PUNCH REQUEST
         $WTO  RPCNTMG,RPCNTRT     ISSUE PUNCH MESSAGE
         $LD   RPCNTLT             CLOSE
         $STO  RPCNTGT,,L           GATE
         $B    RPCNTRT,,L           EXIT
RPCNTMG  DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(32)             DATA COUNT
         DC    C'PUNCH PROCESSOR WAITING FOR 1442'
.NO1442Q ANOP
         TITLE 'RTP1130 (INITIALIZATION)'
***********************************************************************
*                                                                     *
* TITLE - RTPET (RTP1130 INITIALIZATION PROCESSOR)                    *
*                                                                     *
* FUNCTION/PURPOSE -                                                  *
*                                                                     *
* RECEIVES CONTROL FROM RTPLOAD VIA THE SPECIAL COMMUTATOR LINKAGE    *
* PROVIDED AS THE LAST ENTRY IN THE COMMUTATOR. THE FOLLOWING MAJOR   *
*  FUNCTIONS ARE PERFORMED BY INITIALIZATION...                       *
*                                                                     *
*                    1. STORES INTERRUPT TRANSFER VECTORS             *
*                                                                     *
*                    2. ESTABLISHES LINKAGE TO $SDUMP IF              *
*                       DEBUG OPTION IS ON                            *
*                                                                     *
*                    3. SETS LOWER AND UPPER DUMP LIMITS              *
*                       FOR $SDUMP                                    *
*                                                                     *
*                    4. CONSTRUCTS TP BUFFER POOL AS A FUNCTION       *
*                       OF DEFINED CORE (&MACHSIZ), THE SIZE OF       *
*                       A TP BUFFER (&TPBFSZE) AND THE END OF         *
*                       RTP1130 ($BUFPOOL)                            *
*                                                                     *
*                    5. GETS A TP BUFFER AND MOVES SIGN-ON RECORD     *
*                       FROM RTPLOAD RESTING PLACE TO TP BUFFER       *
*                       (REGISTER WB CONTAINS ADDRESS OF SIGN-ON      *
*                       RECORD AS SET BY RTPLOAD)                     *
*                                                                     *
*                    6. SETS TP BUFFER TO WRITE SIGN-ON VIA TPIOX     *
*                       TO HASP                                       *
*                                                                     *
*                    7. ESTABLISHES COMMUNICATIONS WITH HASP BY       *
*                       INITIALLY WRITING SOH-ENQ TO THE SCA          *
*                       AND THEN READING FOR 'ACK0'                   *
*                                                                     *
*                    8. AFTER THE ABOVE SEQUENCE IS SUCCESSFUL,       *
*                       THE COMMUTATOR GATE USED BY INITIALIZATION    *
*                       IS CONVERTED TO A '$B COMSTRT', APPROPRIATE   *
*                       COMMUTATOR GATES ARE OPENED, INCLUDING        *
*                       TPIOX, WHICH WRITES THE SIGN-ON RECORD        *
*                       AND CONTROL IS RELINQUISHED TO THE            *
*                       COMMUTATOR                                    *
*                                                                     *
***********************************************************************
RTPETIN  $NULL                     COMMUTATOR REFERENCE POINT
RTPETVE  $B    RTPETNI,,L          VARIABLE ENTRY POINT
***********************************************************************
*              SET INTERRUPT VECTORS IN LOCATIONS 8 THRU 13           *
***********************************************************************
RTPETNI  $NULL                     INITIAL ENTRY POINT
         $AXT  6,WA                NUMBER OF TRANSFER VECTORS
RTPLIGET $LD   RTPLIVCT-D1,WA,L    GET A VECTOR
         $STO  7,WA,L              STORE IT
         $MDX  -1,WA               DECREMENT AND TEST INDEX
         $B    RTPLIGET            GET NEXT VECTOR
         $LDD  RTPETSL             GET $TSL $SDUMP INSTRUCTION
         $STD  $DUMP,,L            STORE IN SYSTEM DUMP LINKAGE CELL
         $LD   RTPETSB             GET SHORT FORM $B $DUMP
         $STO  0,,L                STORE IN LOCATION 0
         $ZAC                      CLEAR AC AND SET
         $STO  $LLIMIT,,L          LOWER DUMP LIMIT TO 0
RTPETLMT $AXT  $MACHSIZ-1,WA,L     DEFINED CORE SIZE-1
         $STX  $ULIMIT,WA,L        STORE AS UPPER LIMIT
         $B    RTPETSGO            GO TO SIGN-ON PROCEDURE
         $BSS  0,E
         AIF   (&DEBUG EQ 0).NOBUGZ
RTPETSL  $TSL  SSDUMP              LINKAGE TO SYSTEM CORE DUMP
         AGO   .NOBUGY
.NOBUGZ  ANOP
RTPETSL  $B    0,,L                LOOP IF BRANCH TO 0
.NOBUGY  ANOP
RTPETSB  $B    $DUMP-1,,X          ENTRY TO $DUMP FROM LOCATION 0
***********************************************************************
*              INTERRUPT TRANSFER VECTORS                             *
***********************************************************************
         SPACE 1
RTPLIVCT $NULL                     LEVEL     VECTOR
         $ADCON RTPLLVL0           0           8
         $ADCON RTPLLVL1           1           9
         $ADCON RTPLLVL2           2          10
         $ADCON RTPLLVL3           3          11
         $ADCON RTPLLVL4           4          12
         $ADCON RTPLLVL5           5          13
***********************************************************************
*              CONSTRUCT TP BUFFER CHAIN USING DEFINED CORE           *
***********************************************************************
RTPETSGO $NULL
         $LD   RTPETDCS            DEFINED 1130 CORE SIZE
         $S    TPBUFFQP,,L         MINUS BUFFER POOL START
         $SRT  16                  TO EXT (CLEAR AC)
         $D    RTPETABS            DIVIDED BY BUFFER SIZE
         $STO  WA,,L               YIELDING NUMBER OF BUFFERS
         $LD   TPBUFFQP,,L         GET START OF BUFFER POOL
RTPETBLD $A    RTPETABS            CALCULATE NEXT CHAIN WORD
         $STO  RTPETCNW,,I         STORE IN PRECEDING CHAIN WORD
         $STO  RTPETCNW            SET PRECEDING TO NEXT
         $MDX  -1,WA               DECREMENT AND TEST COUNT
         $B    RTPETBLD            CONSTRUCT CALCULATED NUMBER
         $S    RTPETABS            BACK UP TO LAST CHAIN WORD
         $STO  RTPETCNW            SAVE ADDRESS OF LAST CHAIN WORD
         $ZAC                      CLEAR AC AND
         $STO  RTPETCNW,,I          TERMINATE CHAIN
         $DEQUE TPBUFFQP           GET NEXT BUFFER FOR SIGN-ON
         $STO  TPIOWBP,,L          SET POINTER FOR TPIOX WRITE
         $LXA  TPIOWBP,WA          BUFFER POINTER TO WA
         $LD   RTPETCNT            GET WRITE COUNT FOR SIGN-ON
         $STO  TPBUFCB,WA,X        STORE IN BUFFER
         $LD   RTPETNTI            GET WRITE INDICATOR
         $STO  TPBUFHD,WA,X        STORE IN BUFFER
         $LD   RTPETMVC            GET MOVE COUNT
         $MDX  TPBUFFR,WA,X        POINT TO FCS(2)/RCB WORD
         $TSL  SMOVE               MOVE SIGN-ON TO REAL BUFFER
         $B    RTPETRNQ            GO SYNCHRONIZE WITH HASP
***********************************************************************
*              CONSTANTS AND STORAGE FOR INITIALIZATION               *
***********************************************************************
RTPETABS DC    AL2((&TPBFSZE/2)+TPBUFDT) TP BUFFER SIZE IN WORDS
RTPETDCS DC    AL2($MACHSIZ-1)     DEFINED CORE SIZE-1
RTPETCNW $ADCON (SBUFPOOL)         CHAIN CONSTRUCTION WORD
RTPETCNT DC    AL2(87)             TRANSMIT COUNT FOR SIGN-ON
RTPETNTI DC    AL2($BSXTNT)        WRITE NORMAL TEXT
RTPETMVC DC    AL2(42)             COUNT TO MOVE SIGN-ON RECORD
RTPETRNB DC    AL2(2)              READ COUNT FOR FAKE BUFFER
         DC    AL2($BSXRDX)        READ SEQUENCE INDICATOR
RTPETENQ DC    AL2(BSXORFC)        ENQ TEST VALUE
RTPETWSQ DC    AL2(2)              WRITE COUNT FOR FAKE WRITE BUFFER
         DC    AL2($BSXTSQ)        TRANSMIT SOH-ENQ INDICATOR
RTPETNWC DC    AL2(BSXOWF1)        NORMAL WRITE COMPLETE TEST
RTPETAK0 DC    AL2(BSXORFA)        ACK0 INDICATOR
RTPETDAP $ADCON (RTPETDUM)         ADDRESS OF DUMMY APPENDAGE
RTPETRAP $ADCON (TPIORDS)          ADDRESS OF NORMAL APPENDAGE
***********************************************************************
*              WRITE SOH-ENQ TO HASP                                  *
***********************************************************************
RTPETRNQ $NULL
         $LD   RTPETDAP            SETUP DUMMY WRITE
         $STO  BSXWRAP+D1,,L        APPENDAGE FOR BSXIOS
         $AXT  RTPETWSQ-2*D1,WA,L  FAKE WRITE BUFFER
         $TSL  BSXIOS              INITIATE WRITE SOH-ENQ
         $B    RTPETDSK            DATA SET NOT READY
         $STL  RTPETVE+D1,L        RESET ENTRY POINT
         $LD   BSXOPFW,,L          GET COMPLETION CODE
         $BZ   SCOMSTRT,,L         WAIT FOR WRITE COMPLETION
         $EOR  RTPETNWC            TEST FOR NORMAL COMPLETION
         $BNZ  RTPETRNQ            START AGAIN IF NOT
***********************************************************************
*              NORMAL WRITE COMPLETION...READ FOR ACK0                *
***********************************************************************
         $AXT  RTPETRNB-2*D1,WA,L  FAKE READ BUFFER
         $ZAC                      READ FLAG
         $STO  TPBUFHD,WA,X         TO BUFFER
         $TSL  BSXIOS              INITIATE READ
         $B    RTPETDSK            DATA SET NOT READY EXIT
         $STL  RTPETVE+D1,L        RESET ENTRY POINT
         $LD   BSXOPFR,,L          GET COMPLETION CODE
         $BZ   SCOMSTRT,,L         WAIT FOR READ TO COMPLETE
         $EOR  RTPETAK0            TEST FOR ACK0
         $BNZ  RTPETRNQ            ONE MORE TIME...
***********************************************************************
*              COMMUNICATIONS ESTABLISHED...PREPARE TO SIGN-ON        *
***********************************************************************
         $WTO  RTPETCMS,RTPETGLP   PACIFY THE OPERATOR
         $LD   RTPETRAP            SETUP NORMAL WRITE
         $STO  BSXWRAP+D1,,L        APPENDAGE FOR BSXIOS
         $AXT  SCOMSTRT,WB,L       SET $COMSTOP TO
         $STX  SCOMSTOP+D1,WB,L    '$B $COMSTRT'
         $LD   UNLATCH,,L          OPEN
         $STO  TPGETGT,,L          TPGET
         $STO  TPIOXGT,,L          TPIOX
         $STO  TPPUTGT,,L          TPPUT
         AIF   (NOT &XX1442).N01442
         $STO  RPFFTGT,,L          1442
.N01442  ANOP
         AIF   (&RD2501 EQ 0).NO2501J
         $STO  RDTFOGT,,L          2501
.NO2501J ANOP
         $B    SCOMSTOP,,L         STAND BACK...
***********************************************************************
*              DATA SET NOT READY...TELL OPERATOR AND WAIT FOR READY  *
***********************************************************************
RTPETDSK $STL  RTPETVE+D1,L        RESET ENTRY POINT
         $WTO  RTPETDSM,SCOMSTRT   ISSUE DATA SET NOT READY MESSAGE
         $STL  RTPETVE+D1,L        RESET ENTRY POINT
         $XIO  BSXISNR-D1,,L       SENSE SCA
         $SLA  7                   GET SCA READY BIT
         $BNN  SCOMSTRT            EXIT UNTIL READY
         $LD   CONSLGT,,L          BE SURE
         $EOR  UNLATCH,,L           CONSOLE ROUTINE
         $BZ   SCOMSTRT              IS DONE
         $B    RTPETRNQ,,L         START PROCESS AGAIN
RTPETDSM DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(18)             DATA COUNT
         DC    C'DATA SET NOT READY'
RTPETCMS $NULL
         DC    AL1($BLACK+$EBCD,$LIST15) CONTROL WORD
         DC    AL2(30)             DATA COUNT
         DC    C'COMMUNICATION LINE ESTABLISHED'
***********************************************************************
*              DEAD END IF NO CONSOLE TANKS AVAILABLE                 *
***********************************************************************
RTPETGLP $NULL
         $TSL  $WAIT               ALL IS LOST IF NO CONSOLE
         $B    RTPETGLP             MESSAGE TANKS EXIST NOW...
***********************************************************************
*              DUMMY WRITE END-OPERATION APPENDAGE FOR INIT           *
***********************************************************************
RTPETDUM DC    AL2(*-*)            ENTRY FROM BSXIOS
         $B    RTPETDUM,,I         USE COMMUTATOR LOGIC
         TITLE 'RTP1130 (SCA BUFFER DEFINITION)'
         AIF   (&PR1403 EQ 0 ).NO1403A
***********************************************************************
*              DEFINE 1403 PRINTER TANKS                              *
***********************************************************************
         $GENQ ID=PRFO3,SIZE=66,NUM=&PRFOTKL
.NO1403A ANOP
         SPACE 3
         AIF   (NOT &XX1442).NO1442I
***********************************************************************
*              DEFINE 1442 PUNCH TANKS                                *
***********************************************************************
         $GENQ ID=PNFF2,SIZE=80,NUM=&PUNFTKL
.NO1442I ANOP
         SPACE 3
         AIF   (&PR1132 EQ 0).NO1132D
***********************************************************************
*              DEFINE 1132 PRINTER TANKS                              *
***********************************************************************
         $GENQ ID=PRET2,SIZE=66,NUM=&PRETTKL
.NO1132D ANOP
         SPACE 3
***********************************************************************
*              GENERAL CONSOLE MESSAGE QUEUE (TANK) DEFINITION        *
***********************************************************************
         $GENQ ID=CONSL,SIZE=CONQSIZE,NUM=&CONSTKL
         AIF   (&TRACE EQ 0).NOTRACE
         TITLE 'RTP1130 (OPTIONAL TRACE ROUTINE AND TRACE TABLE)'
         SPACE 3
***********************************************************************
*                                                                     *
* TITLE - $TRACE                                                      *
*                                                                     *
* FUNCTION/OPERATION                                                  *
*                                                                     *
*  STORES THE INFORMATION SHOWN BELOW IN A TABLE OF VARIABLE LENGTH   *
*  FOR EACH ENTRY VIA THE $TRACE MACRO. THE TRACE TABLE IS CIRCULAR.  *
*                                                                     *
*  TRACE TABLE ENTRY                                                  *
*                                                                     *
*              WORD CONTENTS                                          *
*              ---- --------                                          *
*                1  ENTRY COUNTER                                     *
*                2  LOCATION + 1 OF CALLER TO $TRACE                  *
*                3  ACCUMULATOR                                       *
*                4  EXTENSION                                         *
*                5  XR1                                               *
*                6  XR2                                               *
*                7  XR3                                               *
*                                                                     *
* RESTRICTIONS                                                        *
*                                                                     *
*  THIS VERSION OF $TRACE CAN NOT BE USED AT INTERRUPT TIME           *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 3
STRCSIZ  EQU   7                   TRACE TABLE ENTRY SIZE
STRACE   DC    H'0'                ENTRY VIA $TSL $TRACE
         $STX  TRACEX1+D1,XR1      SAVE XR1 AND STATUS
         $STS  TRACEST             BITS FOR RESTORATION
         $LXA  TRACENX,XR1         GET ADDRESS OF NEXT SLOT
         $STD  2,XR1               AC AND EXT TO TABLE
         $LD   STRACE              GET LOCATION+1 OF CALLER
         $STO  1,XR1               STORE IN TABLE
         $LD   TRACEX1+D1          GET XR1
         $STO  4,XR1               STORE IN TABLE
         $LD   2                   GET XR2
         $STO  5,XR1               STORE IN TABLE
         $LD   3                   GET XR3
         $STO  6,XR1               STORE IN TABLE
         $LD   STRACE,,I           GET TRACE COUNTER
         $A    TRACEC1             DING BY ONE
         $SKPO                     TEST FOR COUNTER CYCLE
         $LD   TRACEC1             YES. RESET TO ONE
         $STO  STRACE,,I           UPDATE COUNTER AND
         $STO  0,XR1               SAVE IN TABLE
         $MDM  STRACE,1            SET TO BYPASS COUNTER AT EXIT
         $LD   TRACENX             UPDATE POINTER TO
         $A    TRACESZ             NEXT TABLE SLOT
         $STO  TRACENX             DO IT
         $S    TRACEND             TEST FOR END OF TABLE
         $BNZ  TRACEXT             EXIT IF NOT END
         $LD   TRACEOR             RESET TO TOP
         $STO  TRACENX             OF TABLE
TRACEXT  $LDD  2,XR1               RESTORE AC AND EXT
TRACEX1  $AXT  *-*,XR1,L           AND XR1
TRACEST  $LDS  0                   AND STATUS
         $B    STRACE,,I           RETURN
TRACEC1  DC    H'1'                COUNTER DINGER
TRACESZ  DC    AL2(STRCSIZ)        TABLE ENTRY SIZE
TRACEOR  $ADCON STRCTBL            TRACE TABLE START
TRACEND  $ADCON STRCTBL+2*(&TRACE*STRCSIZ) TRACE TABLE END
TRACENX  $ADCON STRCTBL            POINTER TO NEXT ENTRY
STRCTBL  $BSS  &TRACE*STRCSIZ,E    YE OLDE TRACE TABLE
.NOTRACE ANOP
         AIF   (&DEBUG EQ 0).NODBUGC
         TITLE 'RTP1130 (SCA INTERRUPT TRACE ROUTINE)'
***********************************************************************
*                                                                     *
* TITLE - DBUGSCAL (TRACE ROUTINE FOR LOW SPEED SCA INTERRUPTS)       *
*                                                                     *
* FUNCTION/PURPOSE                                                    *
*                                                                     *
*  TRACES ALL SCA INTERRUPTS IN THE FORM SHOWN BELOW. ENTRY IS        *
*  FROM THE SCA INTERRUPT ROUTINE EXIT SECTION..                      *
*                                                                     *
* NOTE..EXTERNAL CONTROL OF THE TRACE FUNCTION IS PROVIDED            *
*  THRU THE CONSOLE ENTRY KEYS..                                      *
*                                                                     *
*  THIS VERSION OF DBUGSCAL ASSUMES AN 1130 WITH A PHYSICAL CORE      *
*  SIZE OF 16K WORDS AND THAT RTP1130 HAS BEEN DEFINED FOR 8K VIA     *
*  THE PARAMETER &MACHSIZ. THE SCA TRACE TABLE OCCUPIES THE HIGH      *
*  ORDER 8K WORDS OF THE 16K CORE. THE VALUES OF 'DBUGSTRT',          *
*  'DBUGSTND' AND 'DBUGSTBL' DETERMINE THE TABLE START, END AND       *
*  CURRENT ENTRY, RESPECTIVELY.                                       *
*                                                                     *
*  TRACE TABLE FORMAT...                                              *
*                                                                     *
*                        WORD      DESCRIPTION                        *
*                        ----      -----------                        *
*                          1  OPERATION TYPE (BSXIOPT)                *
*                          2  DSW AT INTERRUPT TIME                   *
*                          3  COMPLETION CODE (BSXOPF)                *
*                          4  INTERRUPT LOCATION                      *
*                          5  DATA RECEVIED/TRANSMITTED               *
*                            (BSXRNPT OR BSXWTMP)                     *
*                          6  DATA TRANSFER COUNT                     *
*                            (BSXRCNT OR BSXXCNT)                     *
*                          7  READ OR WRITE SEQUENCE INDEX            *
*                             (BSXRSEQ OR BSXNWOK)                    *
*                          8  SPARE                                   *
*                                                                     *
***********************************************************************
DBUGSCAL DC    AL2(*-*)            ENTRY POINT
         $LD   SENTKEYS,,L         GET ENTRY KEYS SETTING
         $AND  DBUGSCKS            TEST FOR TRACE INHIBIT
         $BNZ  DBUGSCAL,,I         EXIT IF INHIBITED
         $STX  DBUGEXIT+D1,WA      SAVE WA
         $LXA  DBUGSTBL,WA         GET ADDRESS OF NEXT TABLE ENTRY
         $LD   BSXNDSW,,L          GET SCA DSW
         $STO  1,WA                TO TABLE
         $LD   BSXOPF,,I           GET COMPLETION CODE
         $STO  2,WA                TO TABLE
         $LD   RTPLLVL1,,L         GET INTERRUPT LOCATION
         $STO  3,WA                TO TABLE
         $LD   BSXIOPT,,L          GET OPERATION TYPE
         $STO  0,WA                TO TABLE
         $BZ   DBUGRSET            BRANCH IF READ
         $LD   BSXWTMP,,L          GET DATA LAST TRANSMITTED
         $STO  4,WA                TO TABLE
         $LD   BSXXCNT,,L          GET DATA TRANSMIT COUNT
         $STO  5,WA                TO TABLE
         $LD   BSXNWOK+D1,,L       GET WRITE SEQUENCE INDEX
         $STO  6,WA                TO TABLE
         $NOP                      SPARE
         $NOP                      SPARE
         $NOP                      SPARE
         $B    DBUGEXIT            EXIT
DBUGRSET $LD   BSXRNPT,,L          GET DATA READ
         $STO  4,WA                TO TABLE
         $LD   BSXRCNT,,L          GET DATA READ COUNT
         $STO  5,WA                TO TABLE
         $LD   BSXRSEQ+D1,,L       GET READ SEQUENCE INDEX
         $STO  6,WA                TO TABLE
         $NOP                      SPARE
         $NOP                      SPARE
         $NOP                      SPARE
DBUGEXIT $AXT  *-*,WA,L            RESTORE WA
         $LD   DBUGSTBL            UPDATE
         $A    DBUGTSZE             TABLE
         $STO  DBUGSTBL              POINTER
         $S    DBUGSTND            TEST FOR TABLE END
         $BNZ  DBUGSCAL,,I         EXIT IF NOT
         $LD   DBUGSTRT            RESET
         $STO  DBUGSTBL             POINTER
         $MDM  DBUGCRCL,1          INCREMENT CIRCLE COUNTER
         $B    DBUGSCAL,,I         EXIT
DBUGSIZE EQU   8                   TABLE ENTRY SIZE
DBUGTSZE DC    AL2(DBUGSIZE)       CONSTANT
DBUGSTRT DC    AL2(X'2000')        TABLE START
DBUGSTND DC    AL2(X'4000')        TABLE END
DBUGSTBL DC    AL2(X'2000')        CURRENT ENTRY
DBUGCRCL DC    AL2(*-*)            CIRCLE COUNTER
DBUGSCKS DC    AL2($KEY01)         GO-NOGO TESTER
.NODBUGC ANOP
         AIF   (&DEBUG EQ 0).NODBUGA
         TITLE 'HASP 1132 REMOTE TERMINAL SYSTEM DUMP ROUTINE'
         SPACE  1
***********************************************************************
*                                                                     *
*  FUNCTION/OPERATION -                                               *
*                                                                     *
*    * THIS IS THE HASP 1130 SYSTEM CORE DUMP ROUTINE. IT MAY BE      *
*      USED A A SUBROUTINE BY A SYSTEM PROGRAM OR IT MAY BE ENTERED   *
*      FROM THE CONSOLE BY PUSHING THE SYSTEM RESET AND START         *
*      BUTTONS. THIS DUMP ROUTINE IS COMPLETELY SELF CONTAINED AND    *
*      PERFORMS ITS OWN OUTPUT PROCESSING.                            *
*                                                                     *
*  ENTRY -                                                            *
*    * ENTRY CAN BE MADE FROM THE CONSOLE BY PUSHING SYSTEM RESET     *
*      AND PROGRAM START IN THAT RESPECTIVE ORDER.                    *
*                                                                     *
*    * CALLING SEQUENCE FOR USE AS A SUBROUTINE                       *
*                                                                     *
*        $BSI    $SDUMP,,L                                            *
*        $ADCON  ADDR1             ADDRESS OF DUMP LOWER LIMIT        *
*        $ADCON  ADDR2             ADDRESS OF DUMP UPPER LIMIT        *
*        $NULL                     RETURN POINT                       *
*                                                                     *
*  INPUT -                                                            *
*    * THE DUMP LIMITS MUST BE PROVIDED TO THE DUMP ROUTINE           *
*                                                                     *
*      * FOR CONSOLE ENTRY                                            *
*                                                                     *
*            THE LOWER LIMIT MAY BE INSERTED IN LOCATION '$LLIMIT'    *
*            THE UPPER LIMIT MAY BE INSERTED IN LOCATION '$ULIMIT'    *
*            DEFAULT LIMITS HAVE ALREADY BEEN ENTERED AT LOCATIONS    *
*            '$LLIMIT' AND '$ULIMIT' AND ARE ZERO AND MACHINES        *
*            MAXIMUM ADDRESS RESPECTIVELY.                            *
*                                                                     *
*      * FOR SUBROUTINE USE THE LIMITS MUST BE PROVIDED IN THE        *
*        CALLING SEQUENCE.                                            *
*  OUTPUT -                                                           *
*    * A HEXIDECIMAL CONVERTED DUMP OF CORE BETWEEN THE SPECIFIED     *
*      LIMITS AND THE CONTENTS OF THE ACCUMULATOR , EXTENTION, AND    *
*      THE THREE INDEX REGISTERS WHICH ARE PRINTED ON THE FIRST LINE. *
*                                                                     *
*    * THE DUMP CAN BE EITHER ON AN 1132 OR A 1403 PRINTER.           *
*      THE PROGRAM DETERMINES WHICH PRINTER IS ON THE SYSTEM          *
*      AND PROCEEDS TO USE THAT PRINTER. IF BOTH PRINTERS ARE         *
*      ON THE SYSTEM THE 1403 IS USED.                                *
*  EXITS -                                                            *
*    * IF ENTRY WAS FROM A CALLING PROGRAM THEN CONTROL IS RETURNED   *
*      TO THE CALLING PROGRAM AT THE LOCATION 3 WORDS PAST THE $BSI   *
*      INSTRUCTION.                                                   *
*                                                                     *
*    * IF ENTRY WAS FROM THE CONSOLE THEN THE PROGRAM ENTERS A        *
*      $MDX  *-2  LOOP UPON COMPLETION OF THE DUMP.                   *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE  1
         SPACE  1
***********************************************************************
*                                                                     *
*     INITIAL POINT OF ENTRY FOR SYSTEM DUMP                          *
*                                                                     *
***********************************************************************
         SPACE  1
SSDUMP   DS    H
         SPACE  1
***********************************************************************
*                                                                     *
*     SAVE ALL REGISTERS AND STATUS                                   *
*                                                                     *
***********************************************************************
         SPACE  1
         $STD  DMACCSV             SAVE ACC AND EXT
         $STX  DMR1SV,WA           SAVE INDEX REG 1
         $STX  DMR2SV,WB           SAVE INDEX REG 2
         $STX  DMR3SV,WC           SAVE INDEX REG 3
         $STS  DMSTASV             SAVE STATUS
         $LD   9,,L                PICK UP LEVEL 1 INT. ADDR
         $STO  DMOLEVL1            SAVE IT, RESTORE AT DUMPS END
         $LD   12,,L               PICK UP LEVEL 4 INT. ADDR
         $STO  DMOLEVL4            SAVE IT, RESTORE AT DUMP END
         SPACE  1
***********************************************************************
*                                                                     *
*     PICK UP DUMP LIMITS                                             *
*                                                                     *
***********************************************************************
         SPACE  1
         $LDX  SSDUMP,WA,I         PICK UP RETURN ADDRESS
         $MDX  -$LLIMIT,WA         IS ENTRY FROM CONSOLE
         $MDX  *+6                 NO,DO NOT MODIFY RETURN
         $MDM  DMLEAVE,(DMWAIT-DMRETURN)/2 WAIT WHEN COMPLETE
*                                  IF ENTRY IS FROM CONSOLE
         $LD   $LLIMIT,WA,X        LOAD LOWER LIMIT
         $STO  DMLOW               STORE IT IN DUMP LOWER LIMIT
         $LD   $ULIMIT,WA,X        LOAD UPPER LIMIT
         $S    $LLIMIT,WA,X        SUBTRACT LOWER LIMIT
         $STO  DMHIGH              STORE DIFF IN UPPER LIMIT
         $BSC  DMWAIT,,L,P+Z       BR TO HARD WAITIF LOW GT HIGH
         AIF   (&PR1132 NE 1 OR &PR1403 NE 1 ).DMASM01
DMPRINT  $BSC  DMCHKPRT,,L         THIS ADDR WILL BE CHANGED TO
*                                  BR TO THE CORRECT PRINT RTN.
*                                  AFTER DETERMINATION OF WHICH
*                                  PRINTER IS ON SYSTEM
         AGO   .DMASM03
.DMASM01 AIF   (&PR1132 NE 1 ).DMASM02
DMPRINT  $MDX  DMCHK2              BRANCH TO 1132 PRINT ROUTINE
         AGO   .DMASM03
.DMASM02 ANOP
DMPRINT  $MDX  DMCHK3              BRANCH TO 1403 PRINT ROUTINE
.DMASM03 ANOP
DMLEAVE  $MDX  DMRETURN            THIS INSTR BRANCHES TO A
*                                  RETURN TO THE CALLING PROG.
*                                  OR IF CONSOLE ENTRY IT IS
*                                  MODIFIED TO BRANCH TO A
*                                  WAIT
         SPACE  1
***********************************************************************
*                                                                     *
*      RETURN ROUTINE                                                 *
*              RESTORES REGS. AND RETURNS TO CALLING PROG.            *
***********************************************************************
         SPACE  1
DMRETURN $LD   DMOLEVL4            LOAD OLD LEVEL 4 INT. RTN ADDR
         $STO  12,,L               RESTORE IT
         $LD   DMOLEVL1            LOAD OLD LEVEL 1 INT. RTN. ADDR
         $STO  9,,L                RESTORE IT
         $LDD  DMACCSV             RESTORE ACC AND EXT
         $LDX  DMR1SV,WA,I         RESTORE XR1
         $LDX  DMR2SV,WB,I         RESTORE XR2
         $LDX  DMR3SV,WC,I         RESTORE XR3
DMSTASV  $LDS  0                   RESTORE STATUS
         $MDM  SSDUMP,2            INCRE. RETURN ADDR PAST PARAMETERS
         $BSC  SSDUMP,,I           RETURN
DMWAIT   $MDX  *-2                 HARD WAIT
*                                  ENTERED ON COMPLETION IF
*                                  CONSOLE ENTRY
DMOLEVL4 DS    H                   OLD LEVEL 4 INT. ADDR STORAGE
DMOLEVL1 DS    H                   OLD LEVEL 1 INT. ADDR STORAGE
*
DMLOW    DS    H                   LOWER LIMIT OF DUMP
DMHIGH   DS    H                   NO. OF WORDS TO BE DUMPED
DMACCSV  DC    F'0'                ACC AND EXT STORAGE AT ENTRY
         DC    H'1'                CONSTANT FOR FORMATTING DUMP
DMR1SV   DC    H'0'                XR1 STORAGE
         DC    H'2'                CONSTANT FOR FORMATTING DUMP
DMR2SV   DC    H'0'                XR2 STORAGE
         DC    H'3'                CONSTANT FOR FORMATTING DUMP
DMR3SV   DC    H'0'                XR3 STORAGE
DMACCSVA $ADCON  DMACCSV           ADDRESS OF ACC STORAGE
         AIF   (&PR1132 NE 1 OR &PR1403 NE 1 ).DMASM21
         SPACE  1
***********************************************************************
*      PRINTER DETERMINATION ROUTINE                                  *
*                                                                     *
*                                  THE FOLLOWING ROUTINE DETERMINES   *
*                                  WHETHER A 1403 OR AN 1132 IS ON    *
*                                  THE SYSTEM. IT THEN SELECTS THE    *
*                                  APPROPRIATE ROUTINE TO  DO THE     *
*                                  DUMP. IF BOTH AN 1132 AND A 1403   *
*                                  ARE ON THE SYSTEM , THEN THE       *
*                                  1403 IS USED FOR THE DUMP.         *
***********************************************************************
         SPACE  1
DMCHKPRT $XIO  DMSENS3,,L          CHECK IF 1403 PRINTER READY
         $BSC  E                   SKIP IF READY TO HOME 1403
         $MDX  DMCHK132            NOT READY, GO CHECK 1132
         $XIO  DMSKP3,,L           SKIP TO TOP OF PAGE
         $XIO  DMSENS3N,,L         SENSE FOR CARRIAGE BUSY
         $SLA  13                  CARRIAGE BUSY BIT TO LOW ORDER
         $BSC  DMCHK132,,L,N       NOT BUSY, GO CHECK 1132
         $MDM  DMPRINT+2,(DMCHK3-DMCHKPRT)/2 DMPRINT WILL BR TO 1403
         AGO   .DMASM23
.DMASM21 AIF   (&PR1403 NE 1 ).DMASM22
.DMASM23 ANOP
DMCHK3   $LDX  DMNLEVL4,WC,L       PICK UP LEVEL 4 INT ADDR
         $STX  12,WC,L             STORE IT IN INT. VECTOR
         $MDX  DM1403              GO START DUMP
         AIF   (&PR1132 NE 1 ).DMASM04
DMCHK132 $XIO  DMSENS2,,L          SENSE 1132 FOR READY
         $SLA  5                   NO READY BIT TO SIGN BIT
         $BSC  DMCHKPRT,,L,P+Z     NOT READY, CHECK 1403 READY
         $XIO  DMSKIP2,,L          SKIP 1132 TO TOP OF NEW PAGE
         $XIO  DMSENS2N,,L         SENSE FOR CARRIAGE BUSY
         $SLA 3                    SHIFT CARRIAGE BUSY TO SIGN
         $BSC  N                   SKIP IF BUSY
         $MDX  DMCHKPRT            NOT BUSY GO CHECK 1403 AGAIN
         $MDM  DMPRINT+2,(DMCHK2-DMCHKPRT)/2  DMPRINT WILL BR TO DMCHK2
.DMASM22 ANOP
DMCHK2   $LDX  DMNLEVL1,WC,L       PICK UP NEW LEVEL 1 INT ADDR
         $STX  9,WC,L              STORE IN INT. VECTOR
         $BSC  DM1132,,L           GO PREPARE TO DUMP
         AGO   .DMASM05
.DMASM04 ANOP
DMCHKPRT DS    6H                  1403 PRINT ROUTINE STORAGE
.DMASM05 AIF   (&PR1403 NE 1 ).DMASM06
         SPACE  1
***********************************************************************
*                                                                     *
*      1403 DUMP ROUTINE                                              *
*                                                                     *
***********************************************************************
         SPACE  1
DM1403   $LDX  1,WA                INITIALIZE COUNTER FOR
         $STX  DMBLOCK,WA          DOUBLE SPACING AFTER ADDRESS
         $LDX  -9,WA               LOAD NO. OF WORDS REG. STORAGE
         $MDM  DMHIGH,9            ADD REG. STOR. TO TOTAL
*                                  WORD COUNT
         $BSI  DMBUFBLK            GO BLANK OUT BUFFER
         $LDX  DMBUFSWT,WC,I       LOAD FIRST BUFFER ADDRESS
         $LD   DMACCSVA            LOAD ADDR OF ACC STORAGE
         $STO  DMWDADD             STORE IN LOAD NEXT WORD INSTR.
         $MDX  DMLOOP15            GO ENTER DUMP LOOP
*      THIS ENTRY POINT IS USED TO DUMP EACH 16 WORDS OF STORAGE
DMLOOP10 $BSI  DMBUFBLK            GO BLANK OUT BUFFER
         $LDX  1,WB                RESTORE COUNT TO SPACE AFTER
         $STX  DMBLOCK,WB          ADDR. OF BLOCK OF 16 WORDS
         $LDX  DMBUFSWT,WC,I       LOAD ADDRESS OF NEXT BUFFER
         $LD   DMADDR              LOAD ADDR OF FIRST WORD
*                                  OF NEXT 16 WORD BLOCK
         $MDM  DMADDR,16           INCRE. TO FOLLOWING BLOCK
DMLOOP18 $STO  DMWDADD             STORE IN LOAD NEXT WORD INSTR
         $MDM  DMHIGH,1            ADD 1 FOR ADDR. TO TOTAL COUNT
         $LDX  -17,WA              LOAD XR1 WITH WORD COUNT PLUS ONE
         $MDX  DMLOOP15            GO ENTER DUMP LOOP
DMLOOP9  $LD   *-*,,L              LOAD NEXT WORD TO BE DUMPED
         $MDM  DMWDADD,1           INCREMENT TO NEXT WORD
DMLOOP15 $LDX  2,WB                LOAD XR2 TO LOOP TWICE
         $SRT  16                  SHIFT WORD TO EXT
DMLOOP12 $BSI  DMCONVT             CONVERT ODD CHAR TO 1403 CODE
         $SLA  8                   MOVE TO HIGH ORDER BYTE
         $STO  DMTEMP1             TEMPORARY STORAGE
         $BSI  DMCONVT             CONVERT EVEN CHAR TO 1403 CODE
         $OR   DMTEMP1             PICK UP FIRST CHAR
         $STO  0,WC                STORE TWO CHAR IN BUFFER
         $MDX  1,WC                INCREMENT TO NEXT BUFFER LOCATION
         $MDX  -1,WB               CHECK LOOP COUNT
         $MDX  DMLOOP12            GO PICK UP REMAINDER OF WORD
         $MDX  1,WC                SPACE BETWEEN WORDS
         $MDM  DMBLOCK,-1          CHECK FOR EXTRA SPACE EVERY 4
*                                  WORDS
         $MDX  DMLOOP20            BR, NOT END OF 4 WORD GROUP
         $LDX  4,WB                RESTORE COUNT TO SPACE AFTER
         $STX  DMBLOCK,WB          EVERY FOUR WORD GROUP
         $MDX  1,WC                EXTRA SPACE EVERY FOUR WORDS
DMLOOP20 $MDM  DMHIGH,-1           REDUCE NO. WORDS TO BE DUMPED
         $MDX  DMLOOP17            NOT THRU, CHECK WORDS/LINE COUNT
         $MDX  DMLOOP22            ALL THRU PREPARE TO RETURN
DMLOOP17 $MDX  1,WA                DECREMENT WORDS PER LINE COUNT
         $MDX  DMLOOP9             BR TO GET ANOTHER WORD
         $MDX  DM1403E             GO PRINT A LINE
DMLOOP22 $MDM  DMLOOP14+2,(DMLOOP24-DMLOOP10)/2
         SPACE  1
***********************************************************************
*      1403 PRINT ROUTINE                                             *
*                                                                     *
*      INPUT -                                                        *
*          ACC POINTS TO DATA, DATA IS ALREADY IN 1403 CHAR CODE      *
*                                                                     *
***********************************************************************
         SPACE  1
DM1403E  $XIO  DMSENS3N            SENSE 1403, WITHOUT RESET
         $BSC  E                   SKIP IF 1403 READY
         $MDX  DM1403E             LOOP UNTIL THE 1403 IS READY
         $SRA  2                   SHIFT CARRIAGE BUSY BIT TO LOW
         $BSC  E                   LOOP IF CARRIAGE BUSY
         $MDX  DM1403E
         $MDM  DMPRTBSY,0          TEST FOR PRINTER BUSY
         $MDX  DM1403E             LOOP UNTIL PRINT NOT BUSY
         $LDD  DMBUFSWT            LOAD BUFFER SWITCH
         $STO  DMWRIT03            STORE BUFFER ADDR. IN WRITE XIO
         AIF   (&PR1132 NE 1 ).DMASM08
         $RTE  16                  SWITCH BUFFERS
         $STD  DMBUFSWT            RESTORE BUFFER ADDRESSES
.DMASM08 ANOP
DMCARXIO $XIO  DMSPC3              ISSUE EITHER SPACE OR SKIP
         AIF   (&PR1132 EQ 1 ).DMASM20
         $MDM  DMTRSBSY,1          INDICATE PRINT TRANSFER BUSY
DMTRNCHK $MDM  DMTRSBSY,0          CHECK FOR PRINT TRANSFER BUSY
         $MDX  DMTRNCHK            LOOP UNTIL TRANSFER COMPLETE
.DMASM20 ANOP
DMLOOP14 $BSC  DMLOOP10,,L         GO BUILD NEXT LINE
DMLOOP24 $MDM  DMPRTBSY,0          TEST FOR PRINT COMPLETE
         $MDX  DMLOOP24            LOOP UNTIL COMPLETE
         $MDM  DMLOOP14+2,(DMLOOP10-DMLOOP24)/2  RESTORE
         $BSC  DMLEAVE,,L
         SPACE  1
***********************************************************************
*                                                                     *
*      CONVERT BINARY TO 1403 CHAR CODE ROUTINE                       *
*                                                                     *
***********************************************************************
         SPACE  1
DMCONVT  DS    H                   RETURN ADDRESS
         $SRA  16                  CLEAR ACC
         $SLT  4                   MOVE IN NEXT CHAR FROM EXT
         $A    DMTABADD            ADD BINARY TO TABLE ADDRESS
         $STO  DMCHARAD            STORE SUM FOR INDIRECT ADDR.
         $LD   DMCHARAD,,I         LOAD 1403 BINARY CHAR
         $BSC  DMCONVT,,I          RETURN
         DS    0F                  ALIGN TO EVEN 1130 ADDRESS
         SPACE  1
***********************************************************************
*                                                                     *
*      1403 BUFFER BLANKING ROUTINE                                   *
*                                                                     *
***********************************************************************
         SPACE  1
DMBUFBLK DS    H                   RETURN ADDRESS
         $LDX  DMBUFSWT,WC,I       LOAD BEGIN BUFFER ADDRESS
         $LDD  DMBLANK             LOAD ACC WITH TWO 1403 BLANKS
         $LDX  30,WB               LOAD COUNT TO BLANK 120 CHARS
DMLOOP16 $STD  0,WC                STORE 4 BLANKS IN OUTPUT LINE
         $MDX  2,WC                POINT TO NEXT BUFFER LOCATION
         $MDX  -1,WB               COUNT 4 CHAR GROUPS
         $MDX  DMLOOP16            IF NOT THRU 120 CHAR,CONTINUE
         $BSC  DMBUFBLK,,I         RETURN IF BUFFER ALL BLANK
DMBLANK  DC    X'7F7F7F7F'         TWO 1403 BLANKS
         DS    0F                  ALIGN FOR EVEN ADDRESSES ON 1130
DMBUFSWT $ADCON DMBUFF1            BUFFER ADDRESSES
         AIF   (&PR1132 NE 1 ).DMASM18
         $ADCON  DMBUFF2
         AGO   .DMASM09
.DMASM18 ANOP
         DS    0F
.DMASM09 ANOP
         SPACE  1
***********************************************************************
*      1403 IOCCS                                                     *
***********************************************************************
         SPACE  1
DMSENS3N DC    X'0000AF00'         1403 SENSE WITHOUT RESET
DMSENS3  DS    0F
         DC    X'0000AF01'         IOCC TO SENSE 1403,RESET
DMSPC3   DC    H'0',X'AC00'        IOCC TO SINGLE SPACE 1403
DMSKP3   $ADCON DMSKPDW            IOCC TO SKIP 1403 TO CHAN 1
         DC    X'A900'
DMWRIT03 DC    H'0'                IOCC TO WRITE ON 1403
         DC    X'AD00'
DMSKPDW  DC    X'0800'             SKIP TO CHAN 1 DATA WORD
DMTABADD $ADCON  DM1403TB          ADDRESS OF CONVERSION TABLE
DM1403TB DC    X'0049'             1403 CONVERSION TABLE
         DC    X'0040'             CHARACTER 1
         DC    X'0001'             CHARACTER 2
         DC    X'0002'             CHARACTER 3
         DC    X'0043'             CHARACTER 4
         DC    X'0004'             CHARACTER 5
         DC    X'0045'             CHARACTER 6
         DC    X'0046'             CHARACTER 7
         DC    X'0007'             CHARACTER 8
         DC    X'0008'             CHARACTER 9
         DC    X'0064'             CHARACTER A
         DC    X'0025'             CHARACTER B
         DC    X'0026'             CHARACTER C
         DC    X'0067'             CHARACTER D
         DC    X'0068'             CHARACTER E
         DC    X'0029'             CHARACTER F
.DMASM06 AIF   (&PR1132 NE 1 ).DMASM07
         SPACE  1
***********************************************************************
*                                                                     *
*      1132 DUMP ROUTINE                                              *
*                                                                     *
***********************************************************************
         SPACE  1
         DS    0F                  ALIGN TO EVEN 1130 ADDRESS FOR
*                                  USE AS A 1403 BUFFER
DM1132   $BSI  DMCLEAR             GO CLEAR SCAN BITS
         $LDX  DMACCSV,WA,L        LOAD ADDR OF REG. STORAGE
         $SRA  16                  CLEAR ACC
         $STO  DMWDCNT             CLEAR WORD COUNT SWITCH
         $STO  DMREQE              INDICATE THAT AN E IS REQUIRED
         $LDX  9,WB                NO. OF REGS. PLUS ONE
         $BSI  DM1132E             GO PRINT OUT REGISTERS
DMLOOP23 $LDX  DMLOW,WA,I          PICK UP INITIAL DUMP ADDR
         $MDM  DMHIGH,-16          REDUCE WORD COUNT BY 16
          $MDX  DMLOOP19           NOT ZERO , CONTINUE
         $MDM  DMLOOP25+2,(DMLOOP26-DMLOOP23)/2  LEAVE AFTER THIS LINE
DMLOOP19 $LDX  17,WB               LOAD WORDS/LINE PLUS ONE
         $BSI  DM1132E             GO PRINT THIS LINE
         $MDM  DMLOW,16            POINT TO NEXT DUMP BLOCK
DMLOOP25 $BSC  DMLOOP23,,L         GO INITIALIZE NEXT LINE
DMLOOP26 $MDM  DMWDCNT,0           CHECK FOR PRINT COMPLETE
         $MDX  DMLOOP26            LOOP UNTIL PRINT COMPLETE
         $MDM  DMLOOP25+2,(DMLOOP23-DMLOOP26)/2   RESTORE
         $MDM  DMFIRST,125         INDICATE NOT FIRST FOR SUBR CALLS
         $XIO  DMSTPPR             STOP THE 1132 PRINTER
         $BSC  DMLEAVE,,L          RETURN
         SPACE  1
***********************************************************************
*                                                                     *
*     1132 PRINT ROUTINE                                              *
*                                                                     *
*            XR2  CONTAINS A COUNT OF THE NUMBER OF WORDS TO BE       *
*                 DUMPED PLUS 1                                       *
*                                                                     *
*            XR1 CONTAINS THE ADDRESS OF THE NEXT DUMP BLOCK          *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE  1
DM1132E  DS    H
         $XIO  DMSENS2N            SENSE 1132,WITHOUT RESET
         $SLA  3                   SHIFT CARRIAGE BUSY BIT TO SIGN
         $BSC  N                   SKIP IF CARRIAGE BUSY
         $SLA  2                   SHIFT NOT READY BIT TO SIGN
         $BSC  DM1132E+2,,L,P+Z    LOOP UNTIL 1132 IS READY
         $MDM  DMWDCNT,0           CHECK IF PRINT BUSY      -
         $MDX  DM1132E+2           LOOP UNTIL NOT BUSY
         $STX  DMSTADDL,WA         STORE ADDR OF DUMP BLOCK
         $STX  DMWDCNT,WB          STORE COUNT OF CHAR TO BE DUMPED
         $MDM  DMFIRST,0           IS THIS THE FIRST CALL
         $XIO  DM132STR            ISSUE 1132 START PRINTER
         $BSC  DM1132E,,I          RETURN
         SPACE  1
***********************************************************************
*                                                                     *
*     LEVEL 1 OR 1132 INTERRUPT ROUTINE                               *
*                                                                     *
***********************************************************************
         SPACE  1
DMNLEVL1 DS    H                   RETURN ADDR
         $STD  DMACCSAV            SAVE ACCUMULATOR
         $STX  DMXR1SV2,WA         SAVE XR1
         $STX  DMXR2SV2,WB         SAVE XR2
         $STX  DMXR3SV2,WC         SAVE XR3
         $XIO  DMSENS2             SENSE 1132 WITH RESET
         $BSC  DMREADEM,,L,P+Z     BR IF EMITTER READ INT.
         $SLA  1                   SHIFT SKIP RESPONSE TO SIGN BIT
         $BSC  DMSKPRES,,L,P+Z     BR IF SKIP RESPONSE
DM1132RT $LDX  DMXR2SV2,WB,I       RESTORE XR2 TO PRE INT.  VALUE
         $LDX  DMXR3SV2,WC,I       RESTORE XR3 TO PRE INT.  VALUE
         $LDD  DMACCSAV            RESTORE ACC TO PRE. INT. VALUE
         $LDX  DMXR1SV2,WA,I       RESTORE XR1 TO PRE. INT. VALUE
         $BOSC DMNLEVL1,,I         RETURN,CLEAR INT.
DMSKPRES $SLA  7                   SHIFT CHANNEL 1 INDICATOR TO SIGN
         $BSC  P+Z                 SKIP IF NOT CHANNEL 1
         $XIO  DMSSKIP2            STOP CARRIAGE SKIP
         $MDX  DM1132RT            RESTORE AND RETURN
         SPACE  1
***********************************************************************
*      1132 IOCCS                                                     *
***********************************************************************
         SPACE  1
DMSSKIP2 DS    0F
         DC    X'1000'             1132 STOP SKIP IOCC
         DC    X'3402'
DM132STR DC    X'00003480'         1132 START PRINTER IOCC
DMSKIP2  DC    H'0'                1132 START SKIP IOCC
         DC    X'3404'
DMSENS2  DC    X'F000'             1132 SENSE IOCC WITH RESET
         DC    X'3701'
DMSPACE2 DC    X'C500',X'3401'     1132 SPACE  IOCC
DMSTPPR  DC    X'90003440'         1132 STOP PRINTER IOCC
DMSENS2N DC    X'00003700'         SENSE 1132 WITHOUT RESET
DMRDEMIT $ADCON  DMEMIT            READ EMMITTER IOCC
         DC    X'3200'
DM9000   EQU   DMSTPPR
         AGO   .DMASM10
.DMASM07 ANOP
DMREADEM DS    60H                 1403 PRINT BUFFER
         AGO   .DMASM11
.DMASM10 AIF   (&PR1403 NE 1 ).DMASM26
.DMASM11 ANOP
         SPACE  1
***********************************************************************
*                                                                     *
*      LEVEL 4 OR 1403 INTERRUPT ROUTINE                              *
*                                                                     *
***********************************************************************
         SPACE  1
DMNLEVL4 DS    H                   RETURN ADDRESS
         $STD  DMACCSAV            SAVE ACC
         $XIO DMSENS3              SENSE 1403 AND RESET
         $SLA  2                   PRINT COMP. BIT TO SIGN
         $BSC   DM1403P,,L,P+Z     RETURN IF PRINT COMPLETE
         $SLA  1                   CARRIAGE COMP BIT TO SIGN
         $BSC  N                   SKIP IF CARRIAGE COMP
         AIF   (&PR1132 EQ 1 ).DMASM12
         $MDX  DM1403T             INDICATE TRANSFER COMPLETE
         AGO   .DMASM13
.DMASM12 ANOP
         $MDX  DMLEV4RT            IGNORE OTHER INTERRUPTS
.DMASM13 ANOP
         $MDM  DMPRTBSY,0
DM1403W  $XIO  DMWRIT03            ISSUE WRITE XIO
         $MDX DMLEV4RT
DM1403P  $SRA  16                  INDICATE THAT PRINT NOT BUSY
         $STO  DMPRTBSY,,L
DMLEV4RT $LDD  DMACCSAV            RESTORE ACC TO PRE-INT. VALUE
         $BOSC DMNLEVL4,,I         RETURN TO MAINLINE, CLEAR INT.
         AIF   (&PR1132 EQ 1 ).DMASM14
DM1403T  $SRA  16                  CLEAR ACC
         $STO  DMTRSBSY,,L         INDICATE TRANSFER COMPLETE
         $MDX  DMLEV4RT            RETURN
.DMASM14 ANOP
         AGO   .DMASM25
.DMASM26 ANOP
DMNLEVL4 DS    8H                  1132 PRINT ROUTINE STORAGE
.DMASM25 ANOP
DMACCSAV DS    F                   ACC AND EXT STORAGE AT INT.TIME
DMXR1SV2 DS    H                   XR1 STORAGE AT INT. TIME
DMXR2SV2 DS    H                   XR2 STORAGE AT INT. TIME
DMXR3SV2 DS    H                   XR3 STORAGE AT INT. TIME
         AIF   (&PR1132 NE 1 ).DMASM15
         SPACE  1
***********************************************************************
*                                                                     *
*     CLEAR SCAN AREA ROUTINE                                         *
*                                                                     *
***********************************************************************
         SPACE  1
DMCLEAR  DS    H                   RETURN ADDR
         $LDX  0,WA                LOAD XR1 FOR USE IN SHORT INST.
         $SLT  32                  CLEAR ACC AND EXT
         $STD  32,WA               CLEAR 32 AND 33
         $STD  34,WA               CLEAR 34 AND 35
         $STD  36,WA               CLEAR 36 AND 37
         $LDD  DMDBLONE            PUT A 1 BIT IN BIT 15
         $STD  38,WA               CLEAR 38 AND 39
         $BSC  DMCLEAR,,I          RETURN
         SPACE  1
***********************************************************************
*                                                                     *
*     1132 READ EMITTER RESPONSE INTERRUPT HANDLER                    *
*                                                                     *
***********************************************************************
         SPACE  1
         DS    0F                  ALIGN TO EVEN 1130 ADDRESS FOR
*                                  USE AS A 1403 BUFFER
DMREADEM $BSI  DMCLEAR            CLEAR SCAN AREA
         $XIO  DMRDEMIT            READ THE NEXT CHAR
         $MDM  DMREQE,0            ARE WE WAITING FOR AN E
         $MDX  DMTESTCH            NO GO CHECK FOR A-I, 0-9
*     CHECK FOR CHAR E ROUTINE
         $LD   DMEMIT              LOAD ACC WITH NEXT PRINT CHAR
         $EOR  DMSPACE2            CHECK FOR CHAR E
         $BSC  DM1132RT,,L,Z       BR TO RETURN IF NOT E
         $MDM  DMREQE,27           LOAD CHAR COUNT
         $XIO  DMSPACE2            ISSUE SKIP OR SPACE
         SPACE  1
***********************************************************************
*                                                                     *
*     COMMON ROUTINE TO SET UP SCAN FIELD , THIS IS ENTERED IF        *
*     A CHARACTER A-I OR 0-9 IS TO BE PRINTED NEXT                    *
*                                                                     *
***********************************************************************
         SPACE  1
DMCOMMON $LDX  DMWDCNT,WC,I        ADDR + 16 DATA WORDS PER LINE
         $LDX  16,WB               SET NO. OF MASK BITS IN XR2
         $LD   DMEMIT              LOAD NEXT PRINT CHAR
         $SLT  4                   IS CHAR NUMERIC
         $BSC  DMNUMBR,,L,C        BR IF NUMERIC(CARRY ON)
         $A    DM9000              ADD NINE
         $BSC  DM1132RT,,L,C       RETURN IF CHAR G, H, I
DMNUMBR  $STO  DMEMIT              FILL  DMEMIT WITH CHAR.
         $SRA  4                   EXAMPLE
         $OR   DMEMIT                 EMIT CONTAINS  EEEE  WHEN
         $STO  DMEMIT                 CHAR E IS TO BE PRINTED NEXT
         $SRA  8
         $OR   DMEMIT
         $STO  DMEMIT
         $LDX  1,WA                LOAD XR1 WITH ONE
         $STX  DMBLOCK2,WA         STORE IN COUNT FOR DOUBLE SPACING
         $LD   DMSTADDL            LOAD ADDR OF DUMP BLOCK
         $STO  DMSTADDR            STORE FOR CHAR. SCAN
         $MDX  DMLOOP3             GO PRINT ADDR AND STORAGE BLOCK
DMDBLONE DC    F'1'                DOUBLE WORD ONE
         SPACE  1
***********************************************************************
*                                                                     *
*     SET UP THE PRINT SCAN FIELD                                     *
*                                                                     *
***********************************************************************
         SPACE  1
DMLOOP1  $LD   DMSTADDR,,I         LOAD WORD TO BE DUMPED
         $MDM  DMSTADDR,1          POINT TO NEXT WORD
DMLOOP3  $LDX  4,WA                SET XR1 FOR LOOP CONTROL
         $EOR  DMEMIT              COMPARE WITH EMITTED CHAR
DMLOOP2  $A    DMSENS2             CHECK FOR OVERFLOW
         $BSC  DMLOOP4,,L,C        IF OVERFLOW,NO COMPARE,BR
         $AD   DMDBLONE            IF MATCH, INSERT MASK BIT
DMLOOP4  $BSI  DMOVER              GO POSITION BIT IN SCAN FIELD
         $SLA  3                   POSITION NEXT CHAR FOR CHECK
         $MDX  -1,WA               DECREMENT CHAR CNT ,SKIP IF END WORD
         $MDX  DMLOOP2             GO LOOK AT NEXT CHAR IN WORD
         SPACE  1
***********************************************************************
*                                                                     *
*     RTN. ENTERED AT END OF EACH WORD DUMPED                         *
*                                                                     *
***********************************************************************
         SPACE 1
DMLOOP5  $BSI  DMOVER              GO SPACE BETWEEN WORDS
         $MDM  DMBLOCK2,-1         DECREMENT BLOCK WORD COUNT
         $MDX  DMLOOP6             NOT DONE WITH 4 WORD BLOCK
         $BSI  DMOVER              EXTRA SPACE BETWEEN 4 WORD BLOCKS
         $MDM  DMBLOCK2,4          RESTORE COUNT TO EXTRA SPACE
*                                  EVERY 4 WORDS
DMLOOP6  $MDX  -1,WC               DECREMENT WORD COUNT
         $MDX  DMLOOP1             GO PICK UP NEXT WORD
         SPACE  1
***********************************************************************
*                                                                     *
*     RTN. ENTERED AT THE END OF EACH LINE                            *
*                                                                     *
***********************************************************************
         SPACE  1
         $MDM  DMFIRST,0           TEST FOR REGISTER LINE
         $MDX  DMRESTR1            BR TO RESTORE FIRST LINE
         $SLT  21                  POSITION LAST 10 BITS
         $STO  $MMASK1+5,,L        STORE LAST SCAN BITS
DMRESTR2 $LDX  32,WC               RESTORE MASK ADDRESS IN STORE
         $STX  DMSTO+2,WC          INSTRUCTION
         $BSC  DM1132RT,,L         RETURN
DMRESTR1 $SLT  15                  POSITION LAST 14 BITS
         $STO  $MMASK1+2,,L        STORE LAST SCAN BITS
         $MDX  DMRESTR2
         SPACE  1
***********************************************************************
*      RTN. TO SET MASK BITS                                          *
***********************************************************************
         SPACE  1
DMOVER   EQU   *+2                 STORAGE FOR RETURN ADDR
DMEXIT   $BSC  *-*,,L              RETURN TO CALLER
         $SLT  1                   SHIFT COMPARE CHAR AND MASK
         $MDX  -1,WB               DECREMENT MASK BIT COUNT
         $MDX  DMEXIT              RETURN IF NOT ZERO
         $LDX  16,WB               PUT BIT COUNT OF 16 IN XR2
         $RTE  17                  PUT MASK WD IN ACC
DMSTO    $STO  $MMASK1,,L          STORE MASK WORD
         $MDM  DMSTO+2,1           POINT TO NEXT MASK WORD
         $RTE  15                  RESTORE ACC
         $MDX  DMEXIT              RETURN
         SPACE  1
***********************************************************************
*                                                                     *
*     RTN. TO  TEST FOR THE CHAR A-I , 0-9                            *
*                                                                     *
***********************************************************************
         SPACE  1
DMTESTCH $MDM  DMREQE,-1           DECREMENT WHEEL CHAR COUNT
         $MDX  DMLOOP7             NOT ZERO CHECK FOR A-I
         $SRA  16                  ZERO THE CHAR COUNT FOR THIS
         $STO  DMWDCNT             LINE TO INDICATE THAT PRINT FREE
         $STO  DMFIRST             INDICATE NOT FIRST LINE
         $BSC  DM1132RT,,L         GO RETURN
DMLOOP7  $LD   DMEMIT,,L           GET PRESENT WHEEL CHAR
         $BSC  N                   CONTINUE IF ALPHA OR NUMERIC
         $MDX  DMTESTRT            RETURN IF NOT ALPHA OR NUMERIC
         $A    DMSSKIP2,,L         TURNS CARRY ON IF 0-9
         $BSC  DMCOMMON,,L,C       IF 0-9 GO SCAN DUMP LINE
         $SLA  2                   NOT 0-9 ,CHECK FOR A-I
         $BSC  DMCOMMON,,L,N       GO SCAN DUMP LINE IF A-I
DMTESTRT $BSC  DM1132RT,,L         OTHERWISE RETURN
.DMASM15 ANOP
         SPACE  1
***********************************************************************
*   SYMBOL DEFINITIONS                                                *
***********************************************************************
         SPACE  1
         AIF   (&PR1403 NE 1 ).DMASM17
DMPRTBSY EQU   DMWRIT03            PRINTER BUSY INDICATOR
DMTEMP1  EQU   DMCHKPRT            TEMPORARY STORAGE
DMBUFLOC EQU   DMTEMP1+2           START ADDR OF BUFFER
DMBLOCK  EQU   DMBUFLOC+2          COUNT FOR EXTRA SPACE EVERY 4
DMCHARAD EQU   DMBLOCK+2           ADDR IN TABLE OF CHAR
DMADDR   EQU   DMLOW               ADDR OF NEXT WORD TO DUMP
DMWDADD  EQU   DMLOOP9+2           ADDR FIELD IN LOAD NEXT WORD INSTR.
DMBUFF1  EQU   DMREADEM            1403 BUFFER 1
         AIF   (&PR1132 NE 1 ).DMASM16
DMBUFF2  EQU   DM1132              1403 BUFFER 2
         AGO   .DMASM17
.DMASM16 ANOP
DMTRSBSY EQU   DMCHARAD+2          TRANSFER COMPLETE INDICATOR
.DMASM17 ANOP
$MMASK1  EQU   32                  1132 MASK ADDRESS
DMFIRST  EQU   DMNLEVL4            1132 FIRST TIME INDICATOR
DMREQE   EQU   DMFIRST+2           1132 WAITING FOR AN E INDICATOR
DMWDCNT  EQU   DMREQE+2            NO. OF WORDS/LINE PLUS ONE
DMBLOCK2 EQU   DMWDCNT+2           COUNT FOR EXTRA SPACE EVERY 4
DMEMIT   EQU   DMBLOCK2+2          STORAGE FOR NEXT 1132 CHAR TO PRINT
DMSTADDR EQU   DMEMIT+2            WORD ADDR FOR CHAR SCAN
DMSTADDL EQU   DMSTADDR+2          ADDR OF DUMP BLOCK
.NODBUGA ANOP
         TITLE 'RTP1130 (TP BUFFER ORIGIN)'
         SPACE 3
***********************************************************************
*              TP BUFFER ORIGIN AND QUEUE POINTER DEFINITIONS         *
***********************************************************************
TPBUFFQP $ADCON (SBUFPOOL)         FREE BUFFER QUEUE POINTER
TPBUFIQP DC    AL2(*-*)            INPUT BUFFER QUEUE POINTER
TPBUFOQP DC    AL2(*-*)            OUTPUT BUFFER QUEUE POINTER
SBUFPOOL $NULL                     START OF TP BUFFER POOL
         END   RTPETIN
