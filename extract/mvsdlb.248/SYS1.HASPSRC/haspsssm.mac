SSSM     TITLE 'HASP SUBSYSTEM SUPPORT MODULE PROLOG'
***********************************************************************
*                                                                     *
* MODULE NAME = HASPSSSM                                              *
*                                                                     *
* DESCRIPTIVE NAME = HASP SUBSYSTEM SUPPORT MODULE FOR JES2           *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 MVS   --  SEE &VERSION (BELOW) FOR JES2 LEVEL       *
*                                                                     *
* FUNCTION = HASPSSSM INTERFACES DIRECTLY WITH THE OPERATING SYSTEM   *
*            TO PROVIDE JOB SCHEDULING, DATA MANAGEMENT (SYSIN AND    *
*            SYSOUT), AND OPERATOR COMMUNICATIONS. HASPSSSM CONTAINS  *
*            FUNCTION ROUTINES WHICH ARE INVOKED THROUGH THE USE      *
*            OF VECTORS IN THE SUBSYSTEM VECTOR TABLE (SSVT). THE     *
*            VECTORS ARE USED BY THE OPERATING SYSTEM TO INVOKE       *
*            FUNCTIONS WHICH ARE DEFINED BY THE IEFJSSOB MACRO        *
*            EXPANSION. ADDITIONAL SSVT VECTORS ARE USED BY THE       *
*            HASJES20 MODULE TO PROVIDE SERVICES TO THE REST OF THE   *
*            JES2 SYSTEM. DURING EXECUTION OF FUNCTIONS REPRESENTED   *
*            BY THE SSVT VECTORS, ADDITIONAL VECTORS ARE SET INTO     *
*            DEBS AND ACBS FOR DATA MANAGEMENT SUPPORT. HASPSSSM      *
*            MAKES REQUESTS FOR SERVICES TO THE HASJES20 MODULE       *
*            RUNNING UNDER THE JES2 TCB AS WELL AS TO THE OPERATING   *
*            SYSTEM IN THE PERFORMANCE OF ITS FUNCTIONS.              *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*    DEPENDENCIES = EXCP ACCESS METHOD, SUBSYSTEM INTERFACE,          *
*                   BRANCH ENTRIES TO GETMAIN/FREE MAIN AND           *
*                   POST, CMS AND LOCAL LOCK, SWA CREATE INTERFACE,   *
*                   ENQ,DEQ, AND GET/PUT RPL INTERFACE                *
*                                                                     *
*    RESTRICTIONS = NONE                                              *
*                                                                     *
*    REGISTER CONVENTIONS = SEE ENTRY POINT DOCUMENTATION             *
*                                                                     *
*    PATCH LABEL = SSMPATCH                                           *
*                                                                     *
* MODULE TYPE = PROCEDURE                                             *
*                                                                     *
*    PROCESSOR = ASSEMBLER F                                          *
*                                                                     *
*    MODULE SIZE = SEE $DLENGTH MACRO EXPANSION(S) AT END OF ASSEMBLY *
*                                                                     *
* ATTRIBUTES = REENTRANT                                              *
*                                                                     *
* ENTRY POINT = SSVT OPERATING SYSTEM DEFINED FUNCTIONS               *
*                                                                     *
*               HOSSOUT  - PROCESS SYSOUT                             *
*               HOSCANC  - TSO CANCEL                                 *
*               HOSSTAT  - TSO STATUS                                 *
*               HOSEOT   - END OF TASK                                *
*               HOSJBSL  - JOB SELECTION                              *
*               HOSALLOC - ALLOCATION                                 *
*               HOSUNAL  - UNALLOCATION                               *
*               HOSEOM   - END OF MEMORY                              *
*               HOSWTO   - WTO                                        *
*               HOSCMND  - COMMAND PROCESSING                         *
*               HOSUSER  - USER VALIDITY CHECK                        *
*               HOSTERM  - JOB DELETION (TERMINATE EXECUTION)         *
*               HOSRENQ  - RE-ENQUEUE JOB                             *
*               HOSOPEN  - OPEN                                       *
*               HOSCLOS  - CLOSE                                      *
*               HOSCKPT  - CHECKPOINT                                 *
*               HOSREST  - RESTART                                    *
*               HOSREQID - REQUEST JOB ID                             *
*               HOSRETID - RETURN JOB ID                              *
*                                                                     *
*               SSVT JES2 SERVICE FUNCTIONS                           *
*                                                                     *
*               $$POST   - POST JES2 MAIN TASK                        *
*               USERDEST - VERIFY DESTINATION AND CONVERT TO ROUTE    *
*               SSVOPNC  - CONVERTER FAKE OPEN                        *
*               SSVCLSC  - CONVERTER FAKE CLOSE                       *
*               TSGCELL  - GET STORAGE CELL                           *
*               TSGCPOL  - GET CELL POOL (EXPAND CELLS)               *
*               TSFCELL  - FREE CELL BY STORAGE ADDRESS               *
*               TSFCELA  - FREE CELL BY SJB/TCB ADDRESS               *
*               TSGCMNS  - GET MAIN FOR CELLS                         *
*               $$VFL    - SIMULATE VFL INSTRUCTION                   *
*                                                                     *
*               ACCESS METHOD FUNCTIONS                               *
*                                                                     *
*               HASPAM   - GET/PUT/CHECK/POINT/ENDREQ/ERASE           *
*                          SUPPORT ROUTINE FOR SYSIN/SYSOUT           *
*                          REQUESTS VIA ACB VECTORS                   *
*               SVCHAM   - END OF BLOCK ROUTINE ENTERED BY HASPAM     *
*                          VIA SVC 111                                *
*               HAMCEA   - CHANNEL END APPENDAGE FOR SVCHAM I/O       *
*               HAMCEX   - ABNORMAL CHANNEL END APPENDAGE FOR         *
*                          SVCHAM I/O                                 *
*                                                                     *
*    PURPOSE = SEE ENTRY POINT DOCUMENTATION                          *
*                                                                     *
*    LINKAGE = SEE ENTRY POINT DOCUMENTATION                          *
*                                                                     *
* INPUT = SEE ENTRY POINT DOCUMENTATION                               *
*                                                                     *
* OUTPUT = SEE ENTRY POINT DOCUMENTATION                              *
*                                                                     *
* EXIT-NORMAL = SEE ENTRY POINT DOCUMENTATION                         *
*                                                                     *
* EXIT-ERROR = SEE ENTRY POINT DOCUMENTATION                          *
*                                                                     *
* EXTERNAL REFERENCES = SEE BELOW                                     *
*                                                                     *
*    ROUTINES = SVC 0, SVC 1, SVC 2, SVC 3, SVC 6, SVC 8, SVC 10,     *
*               SVC 11, SVC 13, SVC 34, SVC 35, SVC 48, SVC 56,       *
*               SVC 111, SVC 120, SETLOCK, GETMAIN/FREE MAIN,         *
*               IEFIB600                                              *
*                                                                     *
*    DATA AREAS = SEE $HASPCB MACRO EXPANSION                         *
*                                                                     *
*    CONTROL BLOCKS = SEE $HASPCB MACRO EXPANSION                     *
*                                                                     *
* TABLES = NONE                                                       *
*                                                                     *
* MACROS = EXCP, WAIT, POST, GETMAIN, FREEMAIN, LINK, LOAD, TIME,     *
*          ABEND, WTO, DEQ, ENQ, CALL, PUT, MODESET, RETURN, SETLOCK  *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*     RELEASE 4.0 = OZ00553,OZ00559,OZ00790,OZ02445,OZ02448,OZ02568,  *
*                   OZ03317,OZ03324,OZ03344,OZ04303,OZ04307,OZ04312,  *
*                   OZ04329,OZ04992,OZ05795,OZ05957,OZ06658,OZ06720,  *
*                   OZ07418,OZ07419,OZ07425,OZ07433,OZ07435,OZ08188,  *
*                   OZ08194,OZ08205,OZ08213,OZ08214,OZ08220,OZ08236,  *
*                   OZ09075,OZ09076,OZ09490,OZ10289,OZ10293,OZ10297,  *
*                   OZ10315                                           *
*                                                                     *
*     RELEASE 4.1 = OZ07751,OZ09101,OZ09106,OZ09107,OZ10298,OZ10335,  *
*                   OZ10345,OZ10368,OZ11323,OZ11406,OZ11741,OZ11742,  *
*                   OZ11779,OZ11783,OZ11801,OZ12288,OZ12300,OZ13219,  *
*                   OZ13224,OZ13237,OZ13241,OZ13257,OZ14409,OZ14426,  *
*                   OZ14427,OZ14448,OZ14449,OZ14893,OZ14902,OZ14909,  *
*                   OZ15289,OZ15815,OZ15825,OZ18213                   *
*                                                              @G38ESBB
*     EJE1103     = @G38ESBB 3800 PRINTER ENHANCEMENTS         @G38ESBB
*                                                                     *
***********************************************************************
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE MACRO DEFINITIONS'
*
***** $HASPCB *****           GENERATE HASP CONTROL BLOCKS
*
*
         MACRO
         $HASPCB &DOC=YES,&LIST=YES
         GBLC  &PRINT,&GEN,&DATA
         PUSH  PRINT
         PRINT &PRINT
         $PSA  LIST=&LIST          GENERATE OS PSA DSECT
         $CVT  LIST=&LIST          GENERATE OS CVT DSECT
         $SSCT LIST=&LIST          GENERATE OS SSCT DSECT
         $SSIB LIST=&LIST          GENERATE OS SSIB DSECT
         $SSOB (SO,CS,JS,AL,EN,ET,WT,CM,US,JT,RQ,DM,VS,DA,RR),         C
               LIST=&LIST          GENERATE OS SSOB DSECT
         $ASCB LIST=&LIST          GENERATE OS ASCB DSECT
         $ASVT LIST=&LIST          GENERATE OS ASVT DSECT
         $ASXB LIST=&LIST          GENERATE OS ASXB DSECT      @OZ59924
         $SRB  LIST=&LIST          GENERATE OS SRB DSECT
         $TCB  LIST=&LIST          GENERATE OS TCB DSECT
         $RB   LIST=&LIST          GENERATE OS RB DSECT
         $JSCB LIST=&LIST          GENERATE OS JSCB DSECT
         $PSCB LIST=&LIST          GENERATE OS PSCB DSECT
         $TCT  LIST=&LIST          GENERATE OS TCT DSECT
         $TIOT LIST=&LIST          GENERATE OS TIOT DSECT
         $SIOT LIST=&LIST          GENERATE OS SIOT DSECT
         $JFCB LIST=&LIST          GENERATE OS JFCB DSECT
JFCB     DSECT
         ORG   JFCBDSNM
         SPACE 1
*
*              JOB ENTRY SUBSYSTEM DSNAME CONVENTIONS
*
         SPACE 1
DSNSSNM  DC    CL4'HASP',C'.'      SUBSYSTEM NAME
DSNJBID  DC    0CL8'JOB12345',C'JOB'  JOB IDENTIFIER
DSNJBNR  DC    ZL5'12345',C'.'     JOB NUMBER
DSNDSID  DC    0CL6'SO1234'        DATASET IDENTIFIER
DSNDSTYP DC    CL2'SO'             DATASET FUNCTIONAL TYPE
DSNDSNR  DC    ZL4'1234',C'.'      UNIQUE DATA SET NUMBER
DSNDDNM  DC    CL8'STCINRDR'       DATASET DEFINITION NAME
DSNBLANK EQU   DSNDSNR+L'DSNDSNR,1 PAD WITH BLANKS FROM HERE.
DSNBLNK1 EQU   DSNBLANK+1,L'JFCBDSNM-(DSNBLANK+1-JFCBDSNM)
&SYSECT  CSECT                     RETURN TO MAIN CSECT
         $DCB  LIST=&LIST          GENERATE OS DCB DSECT
         $RPL  LIST=&LIST          GENERATE OS RPL DSECT
         $RMR  LIST=&LIST          GENERATE OS RPL RETURN CODES
         $ACB  LIST=&LIST          GENERATE OS ACB DSECT
ACBINR   EQU   X'04'               DEBIRBAD POINTS TO INTRDR
         $ACBXL LIST=&LIST         GENERATE OS ACBXL DSECT
         $DEB  LIST=&LIST          GENERATE OS DEB DSECT
         $IOSB LIST=&LIST          GENERATE OS IOSB DSECT
         $UCB  LIST=&LIST          GENERATE OS UCB DSECT
         $NEL  LIST=&LIST          GENERATE OS NEL DSECT
         $LCT  LIST=&LIST          GENERATE OS LCT DSECT
         $CSCB LIST=&LIST          GENERATE OS CSCB DSECT
         $UCM  LIST=&LIST          GENERATE OS UCM DSECT
         $WQE  LIST=&LIST          GENERATE OS WQE DSECT
         $ORE  LIST=&LIST          GENERATE OS ORE DSECT
         $SDWA LIST=&LIST          GENERATE OS SDWA DSECT      @OZ36122
         $IOCM LIST=&LIST          GENERATE OS IOCM DSECT
         $SMCA LIST=&LIST          GENERATE OS SMCA DSECT            R4
         $RQE  LIST=&LIST          GENERATE OS RQE DSECT       @OZ43706
         $LCCA LIST=&LIST          GENERATE OS LCCA DSECT      @OZ43706
         $TED  DOC=&DOC            GENERATE HASP TED DSECT
         $TGB  DOC=&DOC            GENERATE HASP TGB DSECT
         $TGM  DOC=&DOC            GENERATE HASP TGM DSECT
         $TAB  DOC=&DOC            GENERATE HASP TAB DSECT           R4
         $SVT  DOC=&DOC            GENERATE HASP SSVT DSECT
         $SJB  DOC=&DOC            GENERATE HASP SJB DSECT
         $SDB  DOC=&DOC            GENERATE HASP SDB DSECT
         $HCT  DOC=&DOC            GENERATE HASP HCT DSECT
         $PCE  DOC=&DOC            GENERATE HASP PCE DSECT
         $LRC  DOC=&DOC            GENERATE HASP LRC DSECT
         $BUFFER DOC=&DOC          GENERATE HASP BUFFER DSECT
         $CMB  DOC=&DOC            GENERATE HASP CMB DSECT
         $JCT  DOC=&DOC            GENERATE HASP JCT DSECT
         $PDDB DOC=&DOC            GENERATE HASP PDDB DSECT
         $IOT  DOC=&DOC            GENERATE HASP IOT DSECT
         $CAT  DOC=&DOC            GENERATE HASP CAT DSECT
         $OCR  DOC=&DOC            GENERATE HASP OCR DSECT
         $OCT  DOC=&DOC            GENERATE HASP OCT DSECT
         $SCAT DOC=&DOC            GENERATE HASP SCAT DSECT
         $RAT  DOC=&DOC            GENERATE HASP RAT DSECT
         $RDT  DOC=&DOC            GENERATE HASP RDT DSECT           R4
         $DCT  DOC=&DOC            GENERATE HASP DCT DSECT
         $CCE  DOC=&DOC            GENERATE HASP CCE DSECT
         $HQR  DOC=&DOC            GENERATE HASP HQR DSECT
         $PSO  DOC=&DOC            GENERATE HASP PSO DSECT
         $CSA  DOC=&DOC            GENERATE HASP CSA DSECT           R4
         $CNVWORK DOC=&DOC         GENERATE HASP CNVWORK DSECT
         $BF   DOC=&DOC            GENERATE HASP BF DSECT
         SPACE 3
         POP   PRINT
         PRINT &GEN,&DATA          SET ASSEMBLY PRINT OPTIONS
         MEND
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE LOCAL MACRO DEFINITIONS'
         MACRO
         $BF   &DOC=NO
         GBLA  &BUFSIZE
         TITLE 'GENERALIZED SUBSYSTEM DATASET BUFFER'
*
*
*              GENERALIZED SUBSYSTEM DATASET BUFFER DSECT
*
*
BFDSECT  DSECT
BFD      EQU   BFDSECT
         SPACE 3
BFID     DS    CL4                 ID - PBF, UBF, OR HBF
BFLENG   DS    AL2(4096)           LENGTH                            R4
BFFL1    DS    B                   FLAG BYTE 1
BFFL2    DS    B                   FLAG BYTE 2
BFBF     DS    A                   CHAIN POINTER
BFTRK    DS    F                   TRACK ADDRESS OF BUFFER
BFTCB    DS    A                   TCB ADDRESS FOR FREEMAIN
BFASCB   DS    A                   ASCB ADDRESS FOR FREEMAIN
BFLOC    DS    A                   CURRENT LOCATION IN BUFFER
BFLEN    DS    0F                  OUTPUT - LENGTH REMAINING
BFECB    DS    F                   INPUT - ECB ON WHICH TO WAIT
BFRBA    DS    D                   RELATIVE BLOCK ADDRESS
BFRCT    DS    F                   RECORD COUNTER
*
*              ONLY THE FOLLOWING DATA IS WRITTEN TO DISK
*
BFIO     EQU   *                   START OF AUXILIARY STORAGE DATA   R4
BFNXT    DS    F                   CHAINING TRACK
BFKEY    DS    0CL6                UNIQUE DATA SET KEY ---
BFJBK    DS    CL4                 4-BYTE JOB KEY BASED ON TOD CLOCK
BFDSK    DS    CL2                 2-BYTE SEQUENTIAL DATA SET KEY
BFDAT    EQU   *                   USER DATA AREA                    R4
         EJECT
*
*              FLAG DEFINITIONS
*
         SPACE 3
*              FLAGS 1 ---
         SPACE 1
BF1EOB   EQU   B'10000000'         END-OF-BUFFER INDICATOR           R4
BF1RSV1  EQU   B'01000000'         RESERVED
BF1RSV2  EQU   B'00100000'         RESERVED
BF1RSV3  EQU   B'00010000'         RESERVED
BF1GSG   EQU   B'00001000'         HGMOVE SPAN ENTRY FLAG
BF1IOC   EQU   B'00000100'         PBF I/O IS COMPLETE
BF1PMV   EQU   B'00000010'         HPMOVE ENTRY FLAG
BF1PSG   EQU   B'00000001'         HPMOVE SPAN ENTRY FLAG
         SPACE 3
*              FLAGS 2 ---
         SPACE 1
BF2IOC   EQU   B'10000000'         UBF NOT PRIMED BY HCEGET    @OZ30886
BF2RSV1  EQU   B'01000000'         RESERVED
BF2RSV2  EQU   B'00100000'         RESERVED
BF2RSV3  EQU   B'00010000'         RESERVED
BF2RSV4  EQU   B'00001000'         RESERVED
BF2RSV5  EQU   B'00000100'         RESERVED
BF2RSV6  EQU   B'00000010'         RESERVED
BF2RSV7  EQU   B'00000001'         RESERVED
         SPACE 6
&SYSECT  CSECT
         MEND
         SPACE 3                                                     R4
         MACRO
&LABEL   CALL  &ARG
&LABEL   L     R15,=A(&ARG)
         BALR  R14,R15
         MEND
         SPACE 3
         MACRO
&L       $PROLOG &FUNC,&LENG,&LOCK=NO,&KEY=0
         GBLB  &B(8)
&B(1)    SETB  ('&LOCK' EQ 'YES')
&B(2)    SETB  ('&LOCK' EQ 'REQ')
&B(3)    SETB  ('&LOCK' EQ 'SDB')
&B(1)    SETB  (&B(1) OR &B(2) OR &B(3))
&L      $ENTRY BASE=R15,ENTRY=NO   PROVIDE ENTRY FOR ROUTINE
         L     R15,=A($PROLOG)
         BALR  R15,R15
         DC    B'&B(1)&B(2)&B(3)&B(4)&B(5)&B(6)&B(7)&B(8)'
         DC    AL1(&FUNC)
         DC    AL2(&LENG)
         DROP  R15
         USING *,R12
         MEND
         MACRO
&L       $EPILOG &KEY=
&L       L     R14,=A($EPILOG)
         BR    R14
         MEND
         MACRO
&L       $ALGN &OP,&R1,&S2
&L       &OP   &R1,0
         ORG   *-2
         DC    S(&S2)
         MEND
         SPACE 3
         MACRO
&L       $GETMAIN &TYPE,&A=,&LV=,&SP=,&KEY=
&L       $MAIN 0,&TYPE,0,&LV,&SP,&KEY
         MEND
         SPACE 3
         MACRO
&L       $FREMAIN &TYPE,&A=,&LV=,&SP=,&KEY=,&TCB=NO
&L       $MAIN 1,&TYPE,&A,&LV,&SP,&KEY,&TCB
         MEND
         SPACE 3
         MACRO
&L       $GETBUF &TYPE=PROT,&A=
         AIF   ('&TYPE' EQ 'PROT').PROT
&L       $MAIN 0,BC,0,4096,229,15  UNPROTECTED                       R4
         MEXIT
.PROT    ANOP
&L       $MAIN 0,BC,0,4096,229,5   PROTECTED                         R4
         MEND
         SPACE 3
         MACRO
&L       $FREEBUF &TYPE=PROT,&A=
         AIF   ('&TYPE' EQ 'PROT').PROT
&L       $MAIN 1,BU,&A,4096,229,15 UNPROTECTED                       R4
         MEXIT
.PROT    ANOP
&L       $MAIN 1,BU,&A,4096,229,5  PROTECTED                         R4
         MEND
         SPACE 3
         MACRO
&L       $MAIN &T,&TYPE,&A,&LV,&SP,&KEY,&TCB
         LCLA  &TYPA,&TYP,&I
         LCLB  &B
         LCLC  &C
* REGISTERS DESTROYED -- R0,R1,R2,R3,R4,R7,R14,R15
.*
.*             TEST REGULAR OR BUFFER TYPE
.*
         AIF   ('&TYPE'(1,1) NE 'B').NOTB  GO IF NOT BUFFER-TYPE.
&TYPA    SETA  &TYPA+64            SHOW BUFFER-TYPE
.NOTB    ANOP
.*
.*             SET &TYPA BIT 2 IF GETMAIN, BIT 3 IF FREEMAIN
.*
&TYPA    SETA  &TYPA+32            ASSUME GETMAIN
         AIF   (NOT &T).NOTFREE    GO IF ASSUMPTION CORRECT.
&TYPA    SETA  &TYPA+16-32         SET FREEMAIN
.NOTFREE ANOP
.*
.*             SET &TYPA BIT 4 IF TCB=YES
.*
         AIF   ('&TCB' NE 'YES').NOTCB   SKIP IF TCB NOT YES.
&TYPA    SETA  &TYPA+8             FLAG TCB=YES.
.NOTCB   ANOP                      CONTINUE.
.*
.*             TEST CONDITIONALITY AND GET/FREE
.*
&B       SETB  ('&TYPE'(2,1) EQ 'U')
&TYP     SETA  &T+2*&B
.*
.*             SET INDEX TO DESCRIBE ARGUMENTS
.*
         AIF   ('&LV' EQ '(R0)').T3  IF LR IS REQUIRED FOR LV=,
&I       SETA  &I+1                ADD 1 TO INDEX
         AIF   ('&LV'(1,1) EQ '(').T3  IF ADCON REQUIRED FOR LV=,
&I       SETA  &I+1                ADD 1 TO INDEX.
.T3      AIF   ('&A' EQ '(R1)').T6  IF SLR OR LR REQUIRED FOR A=,
&I       SETA  &I+3                ADD 3 TO INDEX.
         AIF   (NOT &T OR '&A'(1,1) EQ '(').T6  IF L REQUIRED FOR A=,
&I       SETA  &I+3                ADD 3 TO INDEX.
.T6      ANOP
.*
.*             SET CONDITIONAL NO-OPERATION
.*
         AIF   (&I-&I/2*2 EQ 0).CNOP2  IF INDEX IS ODD,
         CNOP  0,4
         AGO   .LABEL              START ON WD BDRY, ELSE HALFWORD.
.CNOP2   CNOP  2,4
.LABEL   ANOP
.*
.*             SET UP LABEL IF PROVIDED
.*
         AIF   ('&L' EQ '').NOLABEL  GO IF BLANK LABEL
&L       DS    0H
.NOLABEL ANOP
.*
.*             SET UP LENGTH VALUE ARGUMENT LV=
.*
&C       SETC  '012012012'(&I+1,1)  EXTRACT LV= FROM INDEX.
         AIF   (&C EQ 2).A         IF LENGTH TO BE PASSED IN R0,
&TYPA    SETA  &TYPA+128           SHOW SO BY FLAG.
         AIF   (&C EQ 0).A         IF LV=(R0),LENGTH ALREADY LKAY.
&C       SETC  '&LV'(2,K'&LV-2)    ELSE REMOVE PARENTHESES.
         LR    R0,&C
.A       ANOP
.*
.*             SET UP ADDRESS VALUE &A=
.*
&C       SETC  '000111222'(&I+1,1)  EXTRACT A= FROM INDEX.
         AIF   (&T).A0             IF GETMAIN, ZERO ADDRESS REGISTER.
         SLR   R1,R1
         AGO   .A3
.A0      AIF   (&C EQ 0).A3        IF R1 ALREADY SET UP, BRANCH.
         AIF   (&C NE 1).A2        IF LR IS REQUIRED,
&C       SETC  '&A'(2,K'&A-2)      REMOVE PARENTHESES AND LR.
         LR    R1,&C
         AGO   .A3
.A2      L     R1,&A
.A3      ANOP
.*
.*             CALL HGFMAIN
.*
         L     R15,=A(HGFMAIN)
         BALR  R4,R15
.*
.*
.*             DESCRIPTION OF FOLLOWING FULLWORD ---
.*
.*       BYTE 0 ---
.*             BIT 0 IS ON IF LV= OPERAND IS IN R0, OFF IF LV=
.*                 OPERAND IS IN THE FULLWORD FOLLOWING THIS.
.*             BIT 1 IS ON IF $GETBUF/$FREEBUF, OFF IF $GETMAIN/
.*                 $FREMAIN.
.*             BIT 2 IS ON IF $GETMAIN/$GETBUF.
.*             BIT 3 IS ON IF $FREMAIN/$FREEBUF.
.*             BIT 4 IS ON IF TCB SUPPLIED FOR $FREMAIN.
.*             BITS 5-7 ARE RESERVED FOR FUTURE USE.
.*
.*       BYTE 1 ---
.*             BITS 0-3 CONTAIN STORAGE PROTECTION KEY, OR X'F'.
.*                 THE LATTER IS AN INDICATION TO HGFMAIN TO USE
.*                 THE PROTECT KEY FROM TCBPKF.
.*             BITS 4-7 MUST BE ZERO.
.*
.*       BYTE 2 ---
.*             BITS 0-7 CONTAIN SUBPOOL NUMBER.
.*
.*       BYTE 3 ---
.*             BITS 0-7 CONTAIN A CODE USED BY VIRTUAL STORAGE
.*                 SUPERVISOR --
.*                 0 - CONDITIONAL GETMAIN
.*                 1 - CONDITIONAL FREEMAIN
.*                 2 - UNCONDITIONAL GETMAIN
.*                 3 - UNCONDITIONAL FREEMAIN
.*
.*
         DC    AL1(&TYPA,&KEY*16,&SP,&TYP)
.*
.*             ADD LENGTH ADCON IF NOT IN R0
.*
         AIF   (&TYPA GE 128).NOLAD  GO IF LENGTH ALREADY IN REG.
         DC    A(&LV)
.NOLAD   ANOP
         MEND
HASPSSSM START 0                   HASP SUBSYSTEM SUPPORT MODULE
         COPY  $HASPGEN
         TITLE 'OS/HASP CONTROL BLOCKS'
         SPACE 5
HASPSSSM $ENTRY BASE=,CSECT=YES, PROVIDE PROCESSOR ID AND           R41C
               POINTER=(SENTL,SENTRIES) POINTER TO ADCON VECTOR     R41
         SPACE 5
*
*                             DOCUMENTATION OPTIONS FOR THIS ASSEMBLY
*
         SPACE 3
        $SYSPARM (OFF,GEN,NODATA,NO,NO)
         EJECT                                                       R4
*
*                             GENERATE OS/HASP CONTROL BLOCKS
*
         SPACE 3
        $HASPCB DOC=&DOC,LIST=&LIST  GENERATE HASP CONTROL BLOCKS
         TITLE 'HASP EXIT ROUTINE WORK AREA DSECTS'
***********************************************************************
*                                                                     *
*        USER SAVE AREA DSECT                                         *
*                                                                     *
***********************************************************************
USAVE    DSECT
         DS    F
UCALLER  DS    F                   CALLER'S CALLER SAVE
UOURSAV  DS    F                   OUR SAVE
USAVER   DS    15F                 REGISTERS 14,15,0-12
UDENQ    ENQ   (*-*,*-*,E,3,STEP),RET=USE,MF=L                 @OZ34664
UDRN     DS     CL3                RNAME TO SERIALIZE LOGGING  @OZ34664
UESTAE   ESTAE UESTAER,TERM=YES,RECORD=YES,MF=(L)              @OZ36122
ULEN     EQU   *-USAVE             LENGTH OF EXTENDED AREA     @OZ34664
         SPACE 3
         ORG   UOURSAV             REDEFINE FOR SVC 35 WORK AREA
USAVFL   DS    C                   FLAGS BYTE
USAVFLM  EQU   X'80'               MULTIPLE LINE WTO (MLWTO)
USAVFLMI EQU   X'40'               CURRENT WQE IS A MINOR WQE
***********************************************************************
*                                                                     *
*        SVC 35 WORK AREA                                             *
*                                                                     *
***********************************************************************
S35DSECT DSECT
S35DSTRT DS    0D                                              @OZ34664
S35DID   DC    CL4'S35D'           DSECT IDENTIFIER            @OZ34664
         DS    F                   FILLER TO MATCH S34DSECT    @OZ34664
S35DNEXT DS    F                   POINTER TO NEXT BUFFER      @OZ34664
S35DWK   DS    0D                  WORK AREA
S35DSAV  DS    F                   STANDARD SAVE AREA
S35DSAVH DS    F                   POINTER TO CALLERS SAVE
         DS    F
         DS    15F                 REGISTERS
S35DMSGL DS    H                   LENGTH OF TEXT IN LOG BUFFER
S35DMSG  DS    0CL146              MESSAGE AREA
S35DTIME DS    CL8                 HH.MM.SS
         DS    C                   -
S35DJOB  DS    CL8                 JOB NNNN
         DS    C
S35DACTF DS    C                   *
S35HIDL  EQU   9                   SIZE OF HASP ID PORTION OF TEXT   R4
S35DHID  DS    CL(S35HIDL)         HASPXXX-
S35DJOBN DS    CL8                 JOBNAMES
         DS    C                   -
S35DTXTL EQU   (S35DMSG+L'S35DMSG-*)
S35DTXT  DS    CL(S35DTXTL)        HASPSSSM TEXT
S35DMAX  EQU   132                 MAXIMUM LOG LRECL SIZE
*              THIS LINE DELETED BY APAR NUMBER                @OZ34664
*              THIS LINE DELETED BY APAR NUMBER                @OZ34664
*              THIS LINE DELETED BY APAR NUMBER                @OZ34664
         DS    0D
S35DL    EQU   *-S35DSECT          LENGTH OF WORK AREA
S35WQEID EQU   WQETXT+1,1          LOCATION OF HASP $
S35WQEHT EQU   WQETXT+S35HIDL+1    LOCATION OF HASPSSSM WTO TEXT
***********************************************************************
*                                                                     *
*        COMMAND INPUT BUFFER (CBF) DSECT                             *
*                                                                     *
***********************************************************************
CBF      DSECT
CBFCNT   DS    H                   LENGTH OF ENTIRE BUFFER (136)
         DS    H
CBFTEXT  DS    CL140               TEXT AREA
CBFL     EQU   *-CBF
HASPSSSM CSECT
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - SUPPORT ROUTINES '
         USING SSVT,R11            ESTABLISH BASE
         USING USAVE,R13
***********************************************************************
*                                                                     *
*        SUPPORT ROUTINE ENTRY POINTS, MOVED TO SSVT BY HASPINIT      *
*                                                                     *
***********************************************************************
SENTRIES DS    0F
         DC    A(HOSSOUT)          PROCESS SYSOUT
         DC    A(HOSCANC)          TSO CANCEL
         DC    A(HOSSTAT)          TSO STATUS
         DC    A(HOSEOT)           END OF TASK
         DC    A(HOSJBSL)          JOB SELECTION
         DC    A(HOSALLOC)         ALLOCATION
         DC    A(HOSUNAL)          UNALLOCATION
         DC    A(HOSEOM)           END OF MEMORY
         DC    A(HOSWTO)           WTO
         DC    A(HOSCMND)          COMMAND PROCESSING
         DC    A(HOSUSER)          USERID VALIDITY CHECK
         DC    A(HOSTERM)          JOB DELETION
         DC    A(HOSRENQ)          RE-ENQUEUE JOB
         DC    A(HOSOPEN)          OPEN
         DC    A(HOSCLOS)          CLOSE
         DC    A(HOSCKPT)          CHECKPOINT
         DC    A(HOSREST)          RESTART
         DC    A(HOSREQID)         REQUEST JOB ID
         DC    A(HOSRETID)         RETURN JOB ID
***********************************************************************
*                                                                     *
*        SUBROUTINE ENTRY POINTS MOVED TO SSVT                        *
*                                                                     *
***********************************************************************
         DC    A($$POST)           POST HASP TASK
         DC    A(USERDEST)         VERIFY DESTINATION
         DC    A(SSVOPNC)          CONVERTER FAKE OPEN
         DC    A(SSVCLSC)          CONVERTER FAKE CLOSE
         DC    A(TSGCELL)          GET STORAGE CELL
         DC    A(TSGCPOL)          GET CELL POOL
         DC    A(TSFCELL)          FREE CELL BY STORAGE ADDRESS
         DC    A(TSFCELA)          FREE CELL BY SJB/TCB ADDRESS
         DC    A(TSGCMNS)          GET MAIN FOR CELLS
         DC    A($$VFL)            SIMULATE VFL INSTRUCTION          R4
         DC    A(SSMPATCH)         SSSM PATCH SPACE POINTER
SENTL    EQU   *-SENTRIES          SHOULD BE EQUAL TO $SVENTL
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - SVC 34 EXIT'
***********************************************************************
*                                                                     *
*        SVC 34 EXIT - SUBSYSTEM FUNCTION SSOBCMND                    *
*                                                                     *
* FUNCTION                                                            *
*                                                                     *
*    RECEIVE CONTROL FROM THE OPERATING SYSTEM SVC 34 PROCESSING      *
*    ROUTINES FOR THE PURPOSE OF EDITING THE COMMAND BUFFER TEXT,     *
*    COPYING HASP COMMANDS TO CMBS FOR HASP ACTION, AND COPYING       *
*    EDITED REPLY COMMANDS AND QUEUING THEM FOR OUTPUT BY THE SVC     *
*    35 EXIT ROUTINE. THE DESCRIPTION OF OPERATIONS FOLLOW.           *
*                                                                     *
*    (1) BACKSPACE EDIT THE COMMAND TEXT LOCATING THE BEGINNING       *
*        AND CALCULATING THE LENGTH OF SOLID TEXT.                    *
*                                                                     *
*    (2) IF THE COMMAND IS A REPLY COMMAND, PERFORM THE FOLLOWING     *
*                                                                     *
*              GET A STORAGE CELL, FILL IT OUT WITH THE OS FORMAT     *
*              (R NN,TEXT), PROVIDE THE INPUT AREA WITH A COPY        *
*              (TRUNCATED IF NECESSARY), AND TIME STAMP THE CELL.     *
*              IF AN ERROR IS ENCOUNTERED, FREE THE CELL AND GIVE     *
*              THE COMMAND TO OS.                                     *
*                                                                     *
*              GET THE CMS LOCK, LOOK FOR AN ORE WITH MATCHING        *
*              NUMBERS, LOCATE THE CORRESPONDING SJB, QUEUE           *
*              THE CELL TO THE SJB WITH CELL OWNER SET TO THE SJB,    *
*              FREE THE LOCK, AND RETURN GIVING THE COMMAND TO        *
*              OS. IF NO ORE OR SJB FREE THE CELL INSTEAD OF QUEUING  *
*              IT TO THE SJB.                                         *
*                                                                     *
*    (3) IF THE COMMAND STARTS WITH THE HASP COMMAND IDENTIFIER       *
*        AND THE HIGH ORDER 3 BYTES OF SSCMSCID (SVC 34 R0 VALUE)     *
*        ARE ZERO, GET A CMB, REDUCE THE $SVCOMCT COUNT, PLACE THE    *
*        COMMAND AND RESTRICTIONS INTO THE CMB, QUEUE THE CMB TO      *
*        THE $SVCOMMQ QUEUE, AND POST THE HASP TASK. IF THE COMMAND   *
*        IS TOO LONG TO FIT INTO A CMB, THERE ARE NO CMBS IN THE      *
*        $SVCMBFQ OR $SVCMBRQ QUEUES, OR THE $SVCOMCT GOES TO ZERO,   *
*        PROCESSING IS NEGATED AND CONTROL IS RETURNED TO OS WITH     *
*        AN ERROR INDICATION. IF HASP IS NOT UP ON ENTRY PROCESSING   *
*        IS ABORTED AND CONTROL IS RETURNED TO OS WITH R15 INDICATING *
*        HASP NOT UP.                                                 *
*                                                                     *
*    (4) IF THE COMMAND IS NOT NUMERIC OR FOR HASP, IT IS GIVEN       *
*        TO OS.                                                       *
*                                                                     *
* INPUT REGISTERS                                                     *
*                                                                     *
*        R0    = ADDRESS OF SSCVT                                     *
*        R1    = ADDRESS OF SSOB                                      *
*        R13   = SAVE AREA                                            *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
* OUTPUT REGISTERS                                                    *
*                                                                     *
*        R0-R14= UNCHANGED                                            *
*        R15   = RETURN CODE                                          *
*                                                                     *
* NOTES                                                               *
*                                                                     *
*    THE HASP SVC 34 EXIT CONVERTS REPLIES TO STANDARD FORMAT. THE    *
*    FORMATS ARE DESCRIBBED BELOW USING THE FOLLOWING CONVENTIONS.    *
*                                                                     *
*        /XXX/ = XXX IS OPTIONAL                                      *
*        (XXX) = XXX IS REQUIRED                                      *
*        X...  = X IS REPEATED A NUMBER OF TIMES                      *
*        TEXT  = CHARACTER STRING INCLUDING BLANKS GIVEN TO USER      *
*        COMMENT CHARACTER STRING INCLUDING BLANKS IGNORED            *
*                                                                     *
*        INPUT = (REPLY)/ .../(N) /,/TEXT//                           *
*                (R )         (NN)/,'TEXT'/ COMMENT//                 *
*                                 / COMMENT/                          *
*                                                                     *
*        OUTPUT= (R NN)/,/TEXT//                                      *
*                      /,'TEXT'/ COMMENT//                            *
*                      / COMMENT/                                     *
*                                                                     *
*        INPUT = (N) /,// ...//TEXT/                                  *
*                (NN)/ /      /'TEXT'/ COMMENT//                      *
*                                                                     *
*        OUTPUT= (R NN,)/TEXT/                                        *
*                       /'TEXT'/ COMMENT//                            *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        ENTRY TO SVC 34 EXIT - PICK UP PARAMETERS                    *
*                                                                     *
***********************************************************************
HOSCMND  $ENTRY BASE=R15,ENTRY=NO  PROVIDE ENTRY FOR ROUTINE
S34      EQU   HOSCMND
         STM   R14,R12,USAVER      SAVE CALLER'S REGISTERS
         LR    R12,R15             ESTABLISH BASE
         USING S34,R12
         DROP  R15
         LR    R8,R0               POINT TO SSCVT
         USING SSCT,R8
         L     R11,SSCTSSVT        POINT TO SSVT
         LR    R10,R1              POINT TO SSOB
         USING SSOB,R10
         L     R9,SSOBINDV         POINT TO FUNCTION AREA
         L     R2,SSCMBUFF-SSCMBGN(0,R9)   POINT TO COMMAND BUFFER
         EJECT
***********************************************************************
*                                                                     *
*        LOCATE AND BACKSPACE EDIT THE COMMAND                        *
*                                                                     *
***********************************************************************
         USING CBF,R2
         LH    R5,CBFCNT           PICK UP LENGTH OF CIB
         CH    R5,=Y(CBFL)         IS IT STANDARD LENGTH
         BH    S34OEXIT            EXIT IF HIGH
         CLI   CBFTEXT,C' '        TEST FOR VERB AT START OF TEXT
         BE    S34OEXIT            EXIT IF NOT
         AR    R5,R2               END + 1
         BCTR  R5,0                END
S34EBT   CLI   0(R5),C' '          IS IT BLANK
         BNE   S34ENB              IF END NOT BLANK EXIT
         BCT   R5,S34EBT           LOOP
S34ENB   LA    R4,CBFTEXT-1        POINT TO TEXT - 1
         LR    R6,R4               LOAD BSPACE SCANNER
S34BSL   LR    R7,R5               SET LENGTH COUNTER
         SR    R7,R6               GET LENGTH OF REMAINING
         BNP   S34BEND             GIVE BACK TO OS IF NO TEXT
         CLC   $SVBAKSP,1(R6)      CHECK FOR BACKSPACE               R4
         BE    S34BS               BR IF YES
         LA    R6,1(0,R6)          POINT TO NEXT CHARACTER
         B     S34BSL              LOOP
S34BS    BCT   R7,S34BSB           IF COUNT GT 1 BR
         CR    R6,R4               IS THIS FIRST CHARACTER
         BNE   S34BCNF             BR IF NOT
         B     S34BONE             BLANK ONE CHARACTER IF YES
S34BSB   BCTR  R7,0                REDUCE TO MACHINE COUNT
         CR    R6,R4               IS THIS FIRST CHARACTER
         BNE   S34BMC              IF NOT MOVE CHARACTERS
         EX    R7,S34BMVF          MOVE INTO FIRST CHARACTER
         B     S34BONE             BLANK ONE CHARACTER
S34BMC   EX    R7,S34BMVC          MOVE INTO CURRENT CHARACTER
S34BCNF  MVI   0(R5),C' '          SET BLANK
         BCTR  R5,0                ADJUST COMMAND SIZE
         BCTR  R6,0                BACK UP CURRENT CHARACTER SCAN
S34BONE  MVI   0(R5),C' '          SET BLANK
         BCTR  R5,0                ADJUST COMMAND SIZE
         CLI   1(R4),C' '          IS FIRST CHARACTER BLANK
         BNE   S34BSL              LOOP IF NOT
         MVC   1(1,R4),$SVBAKSP    FORCE ANOTHER BACKSPACE           R4
         B     S34BSL              LOOP
S34BEND  SR    R5,R4               GET NEW LENGTH OF COMMAND
         BNP   S34HEXIT            IF NULL CAUSE THROW AWAY
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - SVC 34 EXIT - REPLIES'
***********************************************************************
*                                                                     *
*        TEST FOR AND HANDLE ALL NUMERIC REPLY FORMATS                *
*                                                                     *
***********************************************************************
         CLI   1(R4),C'0'          TEST FOR NUMERIC COMMAND
         BL    S34NN               BR IF NOT NUMERIC
S34REPLY LR    R8,R2               SAVE CBF POINTER
         LR    R6,R4               SAVE POINTER
         LA    R0,2                SET CLAIM ID
         LR    R1,R0               IN BOTH REGISTERS
         LA    R4,S34DL            SET LENGTH
         L     R15,$SVGCELL        POINT TO GET CELL ROUTINE
         BALR  R14,R15             ENTER IT
         B     S34NCELL            NO CELL EXIT             +0
S34GCELL LR    R2,R8               RESTORE CBF POINTER      +4
         LR    R8,R1               POINT TO AREA
         USING S34DSECT,R8
***********************************************************************
*                                                                     *
*        FILL OUT SKELETON OF WORK AREA                               *
*                                                                     *
***********************************************************************
         MVC   S34DTIME-1(S34TL),S34TIME INSERT EDIT PATTERNS
         LR    R7,R6               POINT TO COMMAND-1
         LR    R6,R5               GET LENGTH OF TEXT
         MVC   S34DIGIT+1(1),1(R7) MOVE IN DIGIT
         LA    R7,1(0,R7)          UP ONE
         BCT   R6,*+8              DOWN ONE
         B     S34MINR             SKIP MOVE OUT IF NULL
         CLI   1(R7),C'0'          TEST FOR TWO DIGITS
         BL    S34N1D              BR IF ONE
         MVC   S34DIGIT(2),0(R7)   MOVE IN DIGITS
         LA    R7,1(0,R7)          UP ONE
         BCT   R6,S34N1D           REDUCE TEXT COUNT
         B     S34MINR             SKIP MOVE OUT IF NULL TEXT
S34N1D   LTR   R2,R2               IS THIS OS FORMAT
         BM    S34NMOR             MOVE ALL FOLLOWING THE NUMERIC
         CLI   1(R7),C','          IS FIRST CHARACTER A COMMA
         BE    S34NSCMA            PRETEND BLANK IF SO
S34NNBS  CLI   1(R7),C' '          IS CHARACTER A BLANK
         BNE   S34NREPY            MOVE SOLID TEXT
S34NSCMA LA    R7,1(0,R7)          UP ONE
         BCT   R6,S34NNBS          COUNT AND LOOP
         B     S34MINR             SKIP MOVE IF NULL
         EJECT
***********************************************************************
*                                                                     *
*        MOVE TEXT INTO WORK AREA IF NOT TOO LONG, THEN BACK          *
*                                                                     *
***********************************************************************
S34NMOR  BCTR  R6,0                REDUCE COUNT
         CH    R6,=Y(S34DTL)       TEST FOR MAXIMUM REPLY LENGTH
         BH    S34OEXIA            EXIT IF TOO LONG
         EX    R6,S34NMVCA         MOVE OS FORMAT TEXT
         BCTR  R6,0                REDUCE ONE MORE (COULD GO MINUS)
         B     S34MINR             SKIP NORMAL MOVE
S34NREPY CH    R6,=Y(S34DTL)       TEST FOR MAXIMUM REPLY LENGTH
         BH    S34OEXIA            EXIT IF TOO LONG
         BCTR  R6,0                GET MACHINE COUNT
         EX    R6,S34NMVCO         MOVE REPLY OUT
S34MINR  LH    R5,CBFCNT           PICK UP COUNT
         SH    R5,=H'5'            GET TEXT MACHINE LENGTH
         EX    R5,S34NMVCI         MOVE TEXT BACK IN
         OC    S34DTXT,S34DTXTC    UPPER CASE TEXT PART
         LA    R6,S34DTXT-S34DTIME+1(0,R6) GET FULL LENGTH
         LA    R5,L'S34DTEXT       SET MAXIMUM LENGTH
         CR    R6,R5               CHECK FOR NOT TOO LONG
         BNL   S34RWOK             IF TOO LONG ALLOW TRUNCATE
         LR    R5,R6               SET REAL LENGTH IN R5
S34RWOK  TIME  DEC                 GET TIME OF DAY
         ST    R0,S34DWK           PUT TIME IN WORK
         ED    S34DTIME-1(L'S34DTIME+1),S34DWK EDIT
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        FIND CONTROLLING SJB                                         *
*                                                                     *
***********************************************************************
         L     R3,CVTPTR           POINT TO CVT
         USING CVT,R3
         L     R6,CVTCUCB          POINT TO UCM
         USING UCM,R6
         STM   R11,R14,S34DSAV     SAVE REGISTERS AROUND LOCK
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(ORE,*-*,*-*)
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=(ORE,*-*,*-*)
         LM    R11,R14,S34DSAV     RESTORE REGISTERS
         LA    R6,UCMRPYQ-(ORELKP-OREF) POINT TO HEAD OF REPLY QUEUE
         USING OREF,R6
S34ORES  ICM   R6,15,ORELKP        PICK UP NEXT ORE
         BZ    S34LABRT            EXIT TO LOCKED ABORT
         CLC   OREID,S34DIGIT      CHECK MATCHING DIGITS
         BNE   S34ORES             LOOP
         LH    R1,OREASID          PICK UP ASID
         BAL   R14,SFNDSJB         FIND SJB VIA HAVT
         B     S34LABRT            EXIT NOT FOUND           +0
         B     S34LABRT            EXIT IF $WTO TASK        +4
         LR    R7,R1               POINT TO SJB             +8
         USING SJBDSECT,R7
         L     R1,OREWQE           POINT TO WQE
         TM    WQEROUT2-WQE(R1),WQEROUTI IS SECURITY BIT ON
         BZ    S34SJBF             SKIP SUPPRESSION IF NOT
         MVC   S34DTXT(10),=C'SUPPRESSED'
         LA    R5,S34DTXT-S34DTIME+10 GET LENGTH
S34SJBF  MVC   S34DJOB,SJBJOBID    COPY JOBID
         LA    R1,S34DJOB+3        POINT TO JOB NUMBER
         BAL   R14,SBLKJOB         BLANK HIGH ORDER DIGITS
S34SKBKL STH   R5,S34DMSGL         SET LENGTH OF TEXT
         LA    R5,S34DL            SET
         STH   R5,S34DLN            LENGTH OF ELEMENT
         L     R1,S34DCCEW         POINT TO CCE
         ST    R7,CCESJB-CCEDSECT(,R1) SET OWNER OF CELL
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        QUEUE ELEMENT TO SJB                                         *
*                                                                     *
***********************************************************************
         L     R5,SJBLOGQ          PICK UP LOG QUEUE HEAD
S34RPQS  ST    R5,S34DNEXT         COPY TO OUR ELEMENT
         CS    R5,R8,SJBLOGQ       QUEUE IT
         BNE   S34RPQS             LOOP IF NOT QUEUED
         LR    R5,R13              SAVE CALLERS SAVE
         LR    R6,R12              SAVE OUR BASE
         SETLOCK RELEASE,TYPE=CMS,RELATED=(ORE+SJB,*-*,*-*)
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=(ORE+SJB,*-*,*-*)
         LR    R13,R5              RESTORE SAVE
         LR    R12,R6              RESTORE OUR BASE
         B     S34OEXIT            EXIT
***********************************************************************
*                                                                     *
*        LOCKED ABORT OF REPLY ID SEARCHING EXIT                      *
*                                                                     *
***********************************************************************
S34LABRT DS    0H
*        STM   R11,R14,S34DSAV     SAVE REGISTERS AROUND LOCK
         SETLOCK RELEASE,TYPE=CMS,RELATED=(ORE,*-*,*-*)
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=(ORE,*-*,*-*)
         LM    R11,R14,S34DSAV     RESTORE REGISTERS
         EJECT
***********************************************************************
*                                                                     *
*        EXIT WITH OS MESSAGE                                         *
*                                                                     *
***********************************************************************
S34OEXIA LR    R1,R8               POINT TO AREA
         L     R15,$SVFCELL        POINT TO FREE CELL ROUTINE
         BALR  R14,R15             ENTER IT
S34OEXIT LA    R15,SSCMSCMD        SET RETURN CODE
S34EXIT  ST    R15,SSOBRETN        SET RETURN CODE FOR CALLER
         LM    R14,R12,USAVER      PICK UP CALLER REGISTERS
         LA    R15,SSRTOK          SET NORMAL RETURN
         BR    R14                 EXIT
***********************************************************************
*                                                                     *
*        NO CELL - GET MORE STORAGE                                   *
*                                                                     *
***********************************************************************
S34NCELL L     R15,$SVGCMNS        POINT TO CELL GET MAIN STORAGE
         MODESET EXTKEY=HASP       GET KEY 1
         BALR  R14,R15             ENTER IT
         MODESET EXTKEY=ZERO       GET KEY 0
         LTR   R1,R1               TEST FOR GOTTEN
         BNE   S34GCELL            IF SO CONTINUE
         B     S34OEXIT            EXIT
         SPACE 1                                                     R4
S34NMVCO MVC   S34DTXT(*-*),1(R7)     *** EXECUTE ONLY ***           R4
S34NMVCA MVC   S34DTXT-1(*-*),1(R7)   *** EXECUTE ONLY ***           R4
S34NMVCI MVC   CBFTEXT(*-*),S34DTEXT  *** EXECUTE ONLY ***           R4
         EJECT
***********************************************************************
*                                                                     *
*        NOT NUMERIC FORM OF REPLY TRY 'R ' OR 'REPLY '               *
*                                                                     *
***********************************************************************
S34NN    CLI   1(R4),C'R'          COULD THIS BE A REPLY
         BNE   S34NRPLY            EXIT IF NOT
         LA    R4,1(0,R4)          POINT TO THE R
         ICM   R2,8,*              SET HIGH ORDER BIT ON
         CLC   1(4,R4),=C'EPLY'    TEST FOR 'REPLY'
         BNE   S34NRSK             SKIP REPLY COUNTING
         LA    R0,4                SET COUNT
         AR    R4,R0               UP 4 TO POINT TO THE Y
         SR    R5,R0               DOWN 4
S34NRSK  BCTR  R5,0                REDUCE COUNT
         LTR   R5,R5               INSURE WE HAVE SOME TEXT
         BNP   S34OEXIT            GIVE COMMAND TO OS IF NO MORE
         CLI   1(R4),C' '          IS NEXT CHARACTER BLANK
         BNE   S34OEXIT            GIVE COMMAND TO OS IF NOT
S34NRSBK LA    R4,1(0,R4)          UP 1
         BCT   R5,S34NRTB          TEST FOR MORE BLANKS
         B     S34OEXIT            GIVE COMMAND TO OS IS NO MORE
S34NRTB  CLI   1(R4),C' '          ARE THERE ANY MORE OPTIONAL BLANKS
         BE    S34NRSBK            CONTINUE SCAN IF YES
         CLI   1(R4),C'0'          IS IT NUMERIC
         BNL   S34REPLY            HANDLE NUMERIC PART IF YES
         B     S34OEXIT            GIVE TO OS
S34NRPLY DS    0H
         DROP  R8
         DROP  R7
         DROP  R6
         DROP  R3
         DROP  R2
 TITLE 'HASP SUBSYSTEM SUPPORT MODULE - SVC 34 EXIT - HASP COMMANDS'
***********************************************************************
*                                                                     *
*        TEST FOR HASP COMMAND AND HANDLE ALL HASP COMMANDS           *
*                                                                     *
***********************************************************************
         CLC   1(1,R4),$SVCOMCH    IS THIS A HASP COMMAND
         BNE   S34NH               BR IF NOT HASP
         CH    R5,=Y(L'CMBMSG)     CHECK FOR COMMAND TOO LONG
         BH    S34HER              EXIT IF TOO LONG
         CLC   SSCMSCID-SSCMBGN(3,R9),=XL8'0' CHECK FOR ZEROS
         BNE   S34NH               IF NOT CAN'T BE A UCMID
         L     R1,$SVCMBAC         PICK UP ACTIVITY COUNT
         LA    R0,1(0,R1)          UP THE ACTIVITY
         CS    R1,R0,$SVCMBAC      STORE ACTIVITY
         BNZ   *-8                 LOOP IF NOT SET
         ICM   R1,15,$SVHASP       PICK UP HASP STATUS
         BNZ   S34HNUP             EXIT IF HASP NOT UP
         L     R6,$SVCOMCT         PICK UP CMB COUNT
S34HCTR  LR    R1,R6               PUT INTO WORK
         BCT   R1,S34HMOR          COUNT THE COMMAND
         B     S34HERA             SET RETURN CODE AND EXIT
***********************************************************************
*                                                                     *
*        EXIT WITH UNABLE TO ACCEPT COMMAND                           *
*                                                                     *
***********************************************************************
S34HERR  L     R6,$SVCOMCT         PICK UP COUNT
S34HERRL LA    R1,1(0,R6)          UP THE COUNT
         CS    R6,R1,$SVCOMCT      STORE NEW VALUE
         BNZ   S34HERRL            LOOP UNTIL TAKEN
S34HERA  $$POST TYPE=CMB           POST HASP CMB
S34HNUP  L     R1,$SVCMBAC         PICK UP ACTIVITY COUNT
         LR    R0,R1               COPY
         BCTR  R0,0                REDUCE
         CS    R1,R0,$SVCMBAC      STORE
         BNZ   *-8                 LOOP IF NOT SET
S34HER   LA    R15,SSCMIMSG        SET RETURN CODE
         B     S34EXIT             RETURN
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        GET A CMB                                                    *
*                                                                     *
***********************************************************************
S34HMOR  CS    R6,R1,$SVCOMCT      SET NEW VALUE
         BNE   S34HCTR             IF NO TAKE DO OVER
         LM    R2,R3,$SVCMBFQ      PICK UP CMB Q HEAD
         USING CMBDSECT,R2
S34HQE   LTR   R2,R2               TEST FOR QUEUE EMPTY
         BZ    S34HCBNF            TRY RESERVE BUFFER
         L     R0,CMBCMB           POINT TO NEXT CMB                 R4
         LR    R1,R3               COPY SECURITY WORD
         CDS   R2,R0,$SVCMBFQ      DECHAIN
         BNE   S34HQE              TRY AGAIN IF MISSED
         B     S34HCMBF            GO TO FOUND ROUTINE
S34HCBNF ICM   R2,15,$SVCMBRQ      PICK UP CMB Q HEAD
         BZ    S34HERR             EXIT IF EMPTY
         L     R0,CMBCMB           POINT TO NEXT CMB                 R4
         CS    R2,R0,$SVCMBRQ      REMOVE CMB FROM RESERVE
         BNE   S34HCBNF            LOOP (THIS SHOULD NOT HAPPEN)
S34HCMBF DS    0H
         MVC   CMBFLAG(14),S34HCMBH SET BASIC HEADER FOR CMB         R4
         MVC   CMBFM,$SVTO         SET THIS SYSTEM AS SOURCE         R4
         MVC   CMBUCM,SSCMSCID+3-SSCMBGN(R9) MOVE UCMID INTO CMB     R4
***********************************************************************
*                                                                     *
*        FIND MATCHING UCMID FOR AUTHORITY EXTRACTION                 *
*                                                                     *
***********************************************************************
         L     R6,CVTPTR           POINT TO CVT
         USING CVT,R6
         L     R6,CVTCUCB          POINT TO UCM
         USING UCM,R6
         LM    R7,R9,UCMVEA        PICK UP SEARCH PARMS
         DROP  R6
         USING UCMLIST,R7
S34HUTST CLC   CMBUCM,UCMID        LOOK FOR MATCHING UCMID           R4
         BE    S34HUFND            EXIT IF FOUND
         BXLE  R7,R8,S34HUTST      LOOP
         MVC   CMBDESC,S34HCMBH+(CMBDESC-CMBFLAG) SET DESCRIPTOR CODER4
         B     S34NUCM             SKIP UCM AUTH SETTINGS
***********************************************************************
*                                                                     *
*        SET UCM AUTHORITY - HASP RESTRICTIONS                        *
*                                                                     *
***********************************************************************
S34HUFND SR    R8,R8               ZERO WORK
         IC    R8,UCMAUTH          PICK UP AUTHORIZATION BITS
         SRL   R8,5                ALIGN TO HASP BITS
         STC   R8,CMBFLAG          SET FLAGS                         R4
         XI    CMBFLAG,S34F7+CMBFLAGC+CMBFLAGU RESTRICTIONS AND FLAGSR4
S34NUCM  DS    0H
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        COPY COMMAND INTO CMB                                        *
*                                                                     *
***********************************************************************
         MVI   CMBMSG,C' '         BLANK OUT MESSAGE AREA
         MVC   CMBMSG+1(L'CMBMSG-1),CMBMSG DO REST
         STC   R5,CMBML            STORE MESSAGE LENGTH              R4
         BCTR  R5,0                GET MACHINE LENGTH
         EX    R5,S34HMC           MOVE HASP COMMAND
***********************************************************************
*                                                                     *
*        QUEUE TO COMMAND PROCESSOR                                   *
*                                                                     *
***********************************************************************
         L     R0,$SVCOMMQ         PICK UP QUEUE HEAD
S34HQUE  ST    R0,CMBCMB           SET CHAIN                         R4
         CS    R0,R2,$SVCOMMQ      QUEUE TO COMMAND PROCESSOR
         BNE   S34HQUE             TRY AGAIN IF NOT QUEUED
***********************************************************************
*                                                                     *
*        TELL HASP ABOUT THE COMMAND                                  *
*                                                                     *
***********************************************************************
         $$POST ELMT=$SVCOMM       $$POST COMMAND PROCESSOR
         L     R1,$SVCMBAC         PICK UP ACTIVITY COUNT
         LR    R0,R1               COPY
         BCTR  R0,0                REDUCE
         CS    R1,R0,$SVCMBAC      STORE
         BNZ   *-8                 LOOP IF NOT SET
S34HEXIT LA    R15,SSCMSUBC        SET RETURN CODE
         B     S34EXIT             EXIT
         SPACE 1                                                     R4
S34HMC   MVC   CMBMSG(*-*),1(R4)   *** EXECUTE ONLY ***              R4
S34BMVC  MVC   0(*-*,R6),2(R6)     *** EXECUTE ONLY ***              R4
S34BMVF  MVC   1(*-*,R6),2(R6)     *** EXECUTE ONLY ***              R4
S34HCMBH $WTO  MF=LX,JOB=NO,TYPE=SVC34,ROUTE=B'1000000000000000',    R4C
               CLASS=$ALWAYS,PRI=$HI                                 R4
         DROP  R2
         DROP  R7
         DROP  R10
         DROP  R12
S34NH    EQU   S34OEXIT            EXIT IF NOT HASP COMMAND
         LTORG                                                 @OZ34664
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - SVC 35 EXIT'
***********************************************************************
*                                                                     *
*        SVC 35 EXIT - SUBSYSTEM FUNCTION SSOBWTO                     *
*                                                                     *
* FUNCTION                                                            *
*                                                                     *
*    RECEIVE CONTROL FROM THE OPERATING SYSTEM SVC 35 PROCESSING      *
*    ROUTINES AFTER THE WTO MESSAGE HAS BEEN COPIED TO A WQE FOR      *
*    THE PURPOSE OF EDITING THE FIELDS OF THE WQE AND COPYING JOB     *
*    ASSOCIATED MESSAGES TO THE USERS JOB LOG DATA SET ALONG WITH     *
*    MESSAGES QUEUED TO THE JOB'S SJB BY THE SVC 34 EXIT ROUTINE.     *
*    THE DESCRIPTION OF OPERATIONS FOLLOW.                            *
*                                                                     *
*    (1) DETERMINE THE TYPE OF WQE AND LOCATE THE LENGTH BTYE AND     *
*        TIME STAMP FIELDS FOR THE CURRENT MESSAGE, IF THE MESSAGE    *
*        CONTAINS NO DATA (MLWTO LINE TYPE X'80', X'40', AND X'20'    *
*        FLAGS OFF) NO FURTHER PROCESSING IS PERFORMED. SINCE MINOR   *
*        WQES DO NOT HAVE PRE TEXT FIELDS THE ADDRESS IS PROJECTED    *
*        BASED UPON THE TEXT FIELD OF THE CURRENT MINOR TEXT LINE.    *
*                                                                     *
*    (2) THE USERS ASID IS PICKED UP FROM THE CURRENT ASCB AND        *
*        IS USED TO DETERMINE IF THE WQE REPRESENTS A MESSAGE FROM    *
*        THE HASP COMMUNICATIONS TASK (HASPCON CSECT), THE HASP       *
*        CONVERSION TASK (HASPXEQ CSECT), A USER TASK RUNNING IN      *
*        A MEMORY CONTROLLED BY HASP (THE HAVT HAS SJBS FOR THE       *
*        USER).                                                       *
*                                                                     *
*    (3) IF THE MESSAGE IS FROM THE HASP COMMUNICATIONS TASK, THE     *
*        WQE IS NOT MLWTO, AND THE SVC 35 REQUESTOR IS RUNNING        *
*        OFF THE LAST RB, THEN THE JOB ID FIELD IS MOVED INTO THE JOB *
*        IDENTIFICATION FIELD.                                        *
*                                                                     *
*    (4) IF THE MESSAGE IS FROM THE CONVERSION TASK OR HASP           *
*        CONTROLLED USER TASK, A WORK AREA IS GOTTEN AND THE          *
*        TIME STAMP AND JOB ID FIELDS ARE PRIMMED WITH BLANKS. IF     *
*        THE WQE IS NOT A MINOR, THE USER JOBID IS INSERTED INTO      *
*        THE WQE AND TIME STAMP AND JOB ID ARE COPIED INTO THE        *
*        WORK AREA, IF THE USER TEXT STARTS WITH '$', THE FLAG BYTE   *
*        IS NOT '@', AND THE WQE IS NOT MLWTO, THE WORK AREA TEXT     *
*        IS FILLED WITH THE FLAG BYTE ('*' OR ' '), MESSAGE ID        *
*        ('$ ' OR '$HASPXXX '), JOBNAME (FROM SJB), AND REST OF TEXT. *
*        THE   COMBINED MESSAGE IS COPIED BACK INTO THE WQE AND THE   *
*        LENGTH IS ADJUSTED, IF THE USER TEXT DOES NOT START WITH     *
*        '$' ETC., THE MESSAGE TEXT IS COPIED TO THE WORK AREA.       *
*        IF THE EDITED MESSAGE IS 'IEA960I', ADDITIONAL PROCESSING    *
*        IS SKIPPED. OTHERWISE, A STEP ORIENTED ENQ (Q NAME IN THE    *
*        $SVQNAM FIELD AND R NAME 'WTO') IS ISSUED TO SERIALIZE ON    *
*        THE SJB LOG QUEUE REMOVAL AND USE OF THE SJB LOG DATA SET.   *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        THE 'USE' OPTION IS USED TO CAUSE MESSAGES ISSUED     @OZ34664
*        BECAUSE OF ASYNCHRONOUS PROCESSING TO REMAIN CHAINED  @OZ34664
*        ON SJBLOGQ. IF THE ENQ IS OBTAINED, THE LOG MSGS      @OZ34664
*        ARE COPIED TO THE LOG DATA SET (FREEING THE QUEUE            *
*        ELEMENTS). THE MESSAGE WITHIN THE WORK AREA IS COPIED,       *
*        DEQ ISSUED, AND THE WORK AREA FREED.                         *
*                                                                     *
*    (5) CONTROL IS RETURNED TO OS SVC 35 PROCESSING ALLOWING THE     *
*        DISPLAY OF THE MESSAGE.                                      *
*                                                                     *
* INPUT REGISTERS                                                     *
*        R0    = ADDRESS OF SSCVT                                     *
*        R1    = ADDRESS OF SSOB                                      *
*        R13   = SAVE AREA                                            *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* OUTPUT REGISTERS                                                    *
*                                                                     *
*        R0-R14= UNCHANGED                                            *
*        R15   = RETURN CODE                                          *
*                                                                     *
* NOTES                                                               *
*                                                                     *
*    (1) NULL LINE PROCESSING FOR MLWTO IS NOT USED IN THIS VERSION.  *
*                                                                     *
*    (2) WTO DELETION CAPABILITY IS NOT USED IN THIS VERSION.         *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        ENTRY TO SVC 35 EXIT - PICK UP PARAMETERS                    *
*                                                                     *
***********************************************************************
HOSWTO   $ENTRY BASE=R15,ENTRY=NO  PROVIDE ENTRY FOR ROUTINE
S35      EQU   HOSWTO
         STM   R14,R12,USAVER      SAVE CALLER'S REGISTERS
         LR    R12,R15             ESTABLISH BASE
         USING S35,R12
         DROP  R15
         LR    R8,R0               POINT TO SSCVT
         USING SSCT,R8
         L     R11,SSCTSSVT        POINT TO SSVT
         LR    R10,R1              POINT TO SSOB
         USING SSOB,R10
         L     R5,SSOBINDV         POINT TO PARMS
         USING SSWTBGN,R5
         LM    R5,R7,SSWTWQE       PICK UP PARMS
*                                  R5 = WQE, NORMAL OR MAJOR
*                                  R6 = MINOR WQE OR ZERO
*                                  R7 = ORE OR ZERO
         USING WQE,R5
         MVI   USAVFL,0            ZERO TEMPORARY FLAGS
         EJECT
***********************************************************************
*                                                                     *
*        SETUP FOR NORMAL WQE                                         *
*                                                                     *
***********************************************************************
         LA    R3,WQETS            POINT TO TIME STAMP
         LA    R4,WQENBR+3         POINT TO LENGTH
         TM    WQENBR,WMJMMLWB     IS THIS MAJOR WQE
         BZ    S35NORML            IF NOT MUST BE NORMAL
***********************************************************************
*                                                                     *
*        SETUP FOR MAJOR WQE                                          *
*                                                                     *
***********************************************************************
         MVI   USAVFL,USAVFLM      SET MLWTO FLAG
         LA    R3,WMJMTS           POINT TO TIME STAMP
         LA    R4,WMJMTXTL+1       POINT TO LENGTH
         TM    WMJMLTYP,X'E0'      DOES THE WQE CONTAIN A MESSAGE
         BZ    S35EXIT             EXIT IF NO
         LTR   R5,R6               TEST FOR CURRENT LINE IN MINOR
         BZ    S35NORML            CONTINUE IF NOT MINOR
***********************************************************************
*                                                                     *
*        SETUP FOR MINOR WQE                                          *
*                                                                     *
***********************************************************************
         MVI   USAVFL,USAVFLM+USAVFLMI SET MINOR FLAG
         LA    R2,WMNMLT1          POINT TO LINE TYPE, LINE 1
         LA    R3,WMNMTXT1         POINT TO TEXT, LINE 1
         LA    R0,WQETXT-WQETS     GET OFFSET FOR MINOR
         SLR   R3,R0               POINT TO TIME STAMP, LINE 1
         LA    R4,WMNMTL1          POINT TO LENGTH, LINE 1
         TM    WMNMML2,WMNMML2H    TEST FOR LINE 2 AVAILABLE
         BO    S35MINOR            SKIP NEXT IF YES
         LA    R2,WMNMLT2          POINT TO LINE TYPE, LINE 2
         LA    R3,WMNMTXT2-(WQETXT-WQETS) POINT TO TS, LINE 2
         LA    R4,WMNMTL2          POINT TO LINE LENGTH, LINE 2
S35MINOR TM    0(R2),X'E0'         IS THERE DATA IN LINE
         BZ    S35EXIT             EXIT IF NO
         EJECT
***********************************************************************
*                                                                     *
*        PREPARE TO EDIT WQES                                         *
*                                                                     *
***********************************************************************
S35NORML SLR   R2,R2               ZERO MOVE COUNT
         IC    R2,0(0,R4)          PICK UP LENGTH OF TEXT
         USING WQETS,R3
         L     R1,PSAAOLD-PSA      POINT TO ASCB
         LH    R1,ASCBASID-ASCB(,R1) PICK UP ASID
         BAL   R14,SFNDSJB         FIND SJB VIA HAVT
         B     S35EXIT             IGNORE MESSAGE           +0
         B     S35SHIFT            SHIFT HASP MESSAGE       +4
         LR    R6,R1               POINT TO SJB             +8
         USING SJBDSECT,R6
         B     S35GWK              GET WORK AREA
S35SHIFT L     R1,PSATOLD-PSA      POINT TO TCB                      R4
         L     R14,TCBRBP-TCB(,R1) POINT TO OUR RB
         L     R15,RBGRS1-RBBASIC(,R14) POINT TO POSSIBLE CSA        R4
         L     R14,RBLINK-RBBASIC(,R14) POINT TO WHAT SHOULD BE PRB
         CLM   R1,7,RBLINKB-RBBASIC(R14) DOES IT POINT TO TCB
         BNE   S35EXIT             SKIP EDIT IF NOT
         TM    USAVFL,USAVFLMI     MLWTO MINOR LINE                  R4
         BO    S35EXIT             SKIP EDIT IF YES                  R4
         CLC   $SVTO,CSANFM-CSADSECT(R15) THIS FROM OUR SYSTEM       R4
         BE    S35WQEE             EDIT WQE IF YES                   R4
         MVC   WQETS,CSATS-CSADSECT(R15) CLOBBER OS TIME STAMP       R4
         B     S35SJID             SKIP EDIT                         R4
S35WQEE  BAL   R14,S35HIDS         EDIT WQE                          R4
S35SJID  MVC   WQEJOBNM,CSAJOBID-CSADSECT(R15) SET JOB ID            R4
         B     S35EXIT             EXIT
S35HIDS  MVC   S35WQEID,$SVCOMCH   SET MESSAGE ID SAME AS COMMAND    R4
         CLI   0(R4),S35HIDL       CHECK LENGTH GT MSG ID      @OZ19488
         BNH   S35EXIT4            IF ONLY MSG ID, DELETE WQE  @OZ19488
         TM    $SVSTUS,$SVSTIDS    REQUIRE HASP IDS                  R4
         BOR   R14                 RETURN IF YES                     R4
         LA    R0,S35HIDL+1        SET ADJUSTMENT                    R4
         SLR   R2,R0               SET MACHINE COUNT OF REMAINING TEXT
         EX    R2,S35HIDSM         CLOBBER OUR MESSAGE ID            R4
         LA    R2,3(,R2)           UP TO TRUE MESSAGE LENGTH         R4
         STC   R2,0(,R4)           SET LENGTH                        R4
         LA    R1,WQETXT(R2)       POINT TO RESIDUE                  R4
         MVC   0(S35HIDL-2,R1),=CL(S35HIDL-2)' ' BLANK IT            R4
         BR    R14                 RETURN                            R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        GET WORK AREA                                                *
*                                                                     *
***********************************************************************
S35GWK   LA    R0,S35DL            GET DATA LENGTH
         GETMAIN RC,LV=(0),SP=URASP GET STORE PROTECTED WORK AREA
         LTR   R15,R15             TEST FOR GOTTEN
         BNZ   S35EXIT             IF NOT GOTTEN FORGET IT
         LR    R8,R1               POINT TO AREA
         USING S35DSECT,R8
         MVC   S35DTIME(S35DACTF-S35DTIME),=CL(S35DACTF-S35DTIME)' '
         TM    USAVFL,USAVFLMI     TEST FOR MINOR
         BO    S35NJBTS            SKIP JOB NUMBERING AND TIME STAMPING
         MVC   WQEJOBNM,SJBJOBID   MOVE JOB ID
         LA    R1,WQEJOBNM+3       POINT TO NUMERIC PART
         BAL   R14,SBLKJOB         BLANK HIGH DIGITS
         MVC   S35DTIME(S35DACTF-S35DTIME),WQETS INSERT TIME AND JOB ID
         EJECT                                                 @OZ81035
S35NJBTS LA    R15,S35WQEID        GET WTO ID ADDRESS          @OZ81035
         TM    WQEXA,WQEWTOR       THIS FOR WTOR...            @OZ81035
         BNO   S35NWTOR            NO, SKIP ADJUST             @OZ81035
         LA    R15,3(,R15)         ADJUST FOR WTOR REPLY ID    @OZ81035
         SPACE 1                                               @OZ81035
S35NWTOR CLI   0(R15),C'$'         THIS OF HASP ORIGIN...      @OZ81035
         BE    *+14                BR IF YES                   @OZ30033
         CLC   0(1,R15),$SVCOMCH   MSG EDITED BY $$WTO...      @OZ81035
         BNE   S35NHASP            IF NOT SKIP SPECIAL EDIT
         CLC   PSAAOLD-PSA,$SVPOSTE+4 CHECK FOR HASP ASID            R4
         BE    S35HASP             SKIP NEXT IF HASP ASID      @OZ30033
         L     R1,PSATOLD-PSA      POINT TO TCB                      R4
         L     R14,TCBRBP-TCB(,R1) POINT TO OUR RB                   R4
         L     R14,RBLINK-RBBASIC(,R14) POINT TO CALLING RB          R4
         CLC   RBOPSW+5-RBBASIC(3,R14),=AL3(SENTRIES)  CHECK RANGE   R4
         BL    S35NHASP            SKIP HASPSSSM EDIT IF LOW         R4
         CLC   RBOPSW+5-RBBASIC(3,R14),=AL3(SSMPATCH)  CHECK RANGE   R4
         BH    S35NHASP            SKIP HASPSSSM EDIT IF HIGH        R4
         CLI   WQETXT,C'@'         IS THIS PROBLEM PROGRAM ACTION
         BE    S35NHASP            SKIP SPECIAL EDIT IF YES
         TM    USAVFL,USAVFLM      IS THIS MLWTO
         BO    S35NHASP            NOT SSSM IF MLWTO           @OZ81035
         TM    WQEXA,WQEWTOR       IS THIS A WTOR...           @OZ81035
         BNO   S35HASP             BR IF NOT                   @OZ81035
         SPACE 1                                               @OZ81035
*************************************************************  @OZ81035
*                                                           *  @OZ81035
*        IF THIS IS A WTOR FROM SSSM, IT IS FOR THE JESNEWS *  @OZ81035
*        ($HASP360). SKIP THE JOBNAME EDIT AS IT HAS BEEN   *  @OZ81035
*        INSERTED. EDIT FOR HASP IDS, IF NECESSARY, AND     *  @OZ81035
*        INSERT THE COMMAND CHARACTER.                      *  @OZ81035
*                                                           *  @OZ81035
*************************************************************  @OZ81035
         SPACE 1                                               @OZ81035
         BCTR  R2,0                GET MACHINE LENGTH          @OZ81035
         TM    $SVSTUS,$SVSTIDS    REQUIRE HASP IDS...         @OZ81035
         BO    S35HID              BR IF YES, NO EDIT          @OZ81035
         EX    R2,S35NWSID         REMOVE ID FROM NEWS MSG     @OZ81035
         LA    R0,S35HIDL+1        GET ADJUSTMENT LENGTH       @OZ81035
         SR    R2,R0               MACHINE LEN OF REMAINDER    @OZ81035
         SPACE 1                                               @OZ81035
S35HID   EX    R2,S35MVW           MOVE ENTIRE TEXT            @OZ81035
         MVC   0(1,R15),$SVCOMCH   COMM CHAR TO WTOR WQE       @OZ81035
         B     S35GL               BYPASS FURTHER EDITING      @OZ81035
         SPACE 1                                               @OZ81035
S35HASP  CLI   S35WQEID+1,C' '     HASP ID PRESENT...          @OZ30033
         BNE   S35NSSSM            BR IF YES                   @OZ30033
         CH    R2,=Y(L'S35DACTF+L'S35DHID-7)  COUNT VALID...   @OZ30033
         BNP   S35EXIT5            BR IF NO TO SKIP EDIT       @OZ36122
         MVC   S35DTXT,S35WQEID+1          SHIFT TEXT RIGHT TO @OZ30033
         MVC   S35WQEHT-1(S35DTXTL),S35DTXT ALLOW FOR MSG ID   @OZ30033
         LA    R2,S35HIDL-2(,R2)   UPDATE LENGTH               @OZ30033
         EJECT                                                       R4
S35NSSSM MVC   S35DACTF(L'S35DACTF+L'S35DHID),WQETXT  MOVE HEADER    R4
         MVC   S35DJOBN,SJBJOBNM   MOVE JOB NAME
         LA    R0,L'S35DACTF+L'S35DHID GET ADJUSTMENT
         SR    R2,R0               ADJUST COUNT
         BNP   S35EXIT5            FORGET EDIT                 @OZ36122
         LA    R0,S35DTXTL         GET MAXIMUM COUNT
         CR    R2,R0               TEST MAXIMUM EXCEEDED
         BNH   *+6                 SKIP TRUNCATION IF OK
         LR    R2,R0               TRUNCATE
         EX    R2,S35MVO           MOVE TEXT OUT
         LA    R2,S35DTXT-S35DACTF(,R2) GET TOTAL LENGTH OF TEXT
         STC   R2,0(,R4)           SET NEW LENGTH.
         BCTR  R2,0                REDUCE COUNT
         EX    R2,S35MVI           MOVE TEXT IN
         LR    R15,R2              SAVE MACHINE LENGTH OF TEXT       R4
         LA    R2,1(,R2)           GET TRUE LENGTH                   R4
         BAL   R14,S35HIDS         EDIT WQE                          R4
         TM    $SVSTUS,$SVSTIDS    REQUIRE HASP IDS...         @OZ30033
         BO    S35RLEN             BR IF YES                   @OZ30033
         SH    R2,=H'3'            GET MACHINE LENGTH OF TEXT  @OZ30033
         EX    R2,S35HIDRM         OVERLAY MSG ID              @OZ30033
         LA    R1,S35DACTF+3(R2)   POINT TO RESIDUE            @OZ30033
         MVC   0(S35HIDL-2,R1),=CL(S35HIDL-2)' '  BLANK IT     @OZ30033
S35RLEN  LR    R2,R15              RESTORE MSG LENGTH          @OZ30033
         B     S35GL               SKIP WHOLE TEXT MOVE OUT
S35NHASP BCTR  R2,0                REDUCE COUNT
         EX    R2,S35MVW           MOVE WHOLE TEXT
S35GL    LA    R2,S35DACTF-S35DMSG+1(,R2) GET ENTIRE MESSAGE LENGTH
         LA    R0,S35DMAX          SET MAXIMUM SIZE
         CR    R2,R0               TEST FOR TOO LONG
         BNH   *+6                 IF SAFE SKIP NSI
         LR    R2,R0               TRUNCATE
         STH   R2,S35DMSGL         SET NEW LENGTH
         MVC   S35DID,S35ID        SET BUFFER ID               @OZ34664
         SPACE 2                                               @OZ34664
*************************************************************  @OZ34664
*        QUEUE WTO MESSAGE TO SJBLOGQ FOR POSSIBLE             @OZ34664
*        LATER PROCESSING                                      @OZ34664
*************************************************************  @OZ34664
         L     R5,SJBLOGQ          PICK UP LOG QUEUE HEAD      @OZ34664
S35QLOOP ST    R5,S35DNEXT         COPY TO OUR ELEMENT         @OZ34664
         CS    R5,R8,SJBLOGQ       QUEUE IT                    @OZ34664
         BNE   S35QLOOP            LOOP IF NOT QUEUED          @OZ34664
         EJECT                                                 @OZ34664
***********************************************************************
*                                                                     *
*        CLEAN OUT SJB LOG QUEUE                                      *
*                                                                     *
***********************************************************************
         CLC   WQETXT+1(7),=C'IEA960I' IS THIS ENQ DISASTER MESSAGE
         BE    S35EXIT             SKIP LOG IF SO              @OZ34664
         SPACE 2                                               @OZ34664
         LA    R0,ULEN             GET ENQ/DEQ AREA LENGTH     @OZ34664
         GETMAIN  RC,LV=(0),SP=253 GET STORAGE FOR WORKAREA    @OZ34664
         LTR   R15,R15             TEST RETURN FROM GETMAIN    @OZ34664
         BNZ   S35EXIT             QUIT HERE IF NO STORAGE     @OZ34664
         LR    R8,R1               SAVE WORKAREA ADDRESS       @OZ34664
         ST    R8,UOURSAV          POINT CALLER SAVE TO OURS   @OZ34664
         DROP  R13                 DROP OLD SAVEAREA ADDRESS   @OZ34664
         USING USAVE,R8            ADDRESS OUR WORKAREA        @OZ34664
         ST    R13,UCALLER         POINT TO CALLER SAVE        @OZ34664
         MVC   UDENQ(S35PATL),S35PATRN MOVE PATTERN ENQ        @OZ34664
         ESTAE PARAM=(R8),MF=(E,UESTAE) PROVIDE REC. ENVIRON.  @OZ36122
         ENQ   ($SVQNAM,UDRN),MF=(E,UDENQ) ENQ ON ONE SJB      @OZ34664
         LTR   R15,R15             DO WE HAVE CONTROL
         BNZ   S35FREE             IF NOT, FORGET IT           @OZ34664
         LR    R13,R8              USE OUR SAVE AREA           @OZ34664
S35CLNPT ICM   R5,15,SJBLOGQ       POINT TO QUEUED MESSAGES
         USING S34DSECT,R5
         BZ    S35DEQ              IF EMPTY,PREPARE TO EXIT    @OZ34664
         LA    R4,SJBLOGQ-(S34DNEXT-S34DSECT)
S35QSRLL ICM   R1,15,S34DNEXT      POINT TO NEXT
         BZ    S35QEND             IF END, BR
         LR    R4,R5               BRING UP REAR
         LR    R5,R1               POINT TO NEXT
         B     S35QSRLL            LOOP
S35QEND  CS    R5,R1,S34DNEXT-S34DSECT(R4) REMOVE FROM END
         BNE   S35QSRLL            TRY AGAIN IF NO GO
         CLC   S35ID,S35DID-S35DSECT(R5) SVC35 BUFFER...       @OZ34664
         BE    S35PMSG             YES, GO PUT IT              @OZ34664
*        PUT SVC 34 MESSAGE                                    @OZ34664
         LH    R0,S34DMSGL         PICK UP LENGTH
         USING RPLDSECT,R1
         LA    R1,SJBLRPL          POINT TO RPL
         ST    R0,RPLRLEN          SET LENGTH
         LA    R0,S34DTIME         POINT TO TEXT
         ST    R0,RPLAREA          SET AREA
         TM    SJBFLG2,SJB2INIT    INITIATOR SJB...                 R41
         BO    S35INIT1            SKIP PUT IF YES                  R41
         PUT   RPL=(1)             LOG DATA
         DROP  R1
S35INIT1 DS    0H                                                   R41
         LR    R1,R5               POINT TO AREA
         L     R15,$SVFCELL        POINT TO FREE CELL ROUTINE
         BALR  R14,R15             ENTER IT
         B     S35CLNPT            CLEAN OUT SJB QUEUE
         EJECT
***********************************************************************
*                                                                     *
*        PUT SVC 35 MESSAGE ON LOG DATA SET                           *
*                                                                     *
***********************************************************************
*              THIS LINE DELETED BY APAR NUMBER                @OZ34664
         USING S35DSECT,R5                                     @OZ34664
S35PMSG  LH    R0,S35DMSGL         PICK UP LENGTH
         USING RPLDSECT,R1
         LA    R1,SJBLRPL          POINT TO RPL
         ST    R0,RPLRLEN          SET LENGTH
         LA    R0,S35DTIME         POINT TO DATA
         ST    R0,RPLAREA          SET AREA
         TM    SJBFLG2,SJB2INIT    INITIATOR SJB...                 R41
         BO    S35INIT2            SKIP PUT IF YES                  R41
         PUT   RPL=(1)             LOG DATA
         DROP  R1
S35INIT2 DS    0H                                                   R41
*              THIS LINE DELETED BY APAR NUMBER                @OZ34664
*              THIS LINE DELETED BY APAR NUMBER                @OZ34664
         LA    R0,S35DL            GET LENGTH OF AREA          @OZ34664
         ICM   R0,8,=AL1(URASP)    SET SUBPOOL NUMBER          @OZ34664
         LR    R1,R5               POINT TO AREA               @OZ34664
         FREEMAIN R,LV=(0),A=(1)   FREE AREA                   @OZ34664
         B     S35CLNPT            CLEAN OUT SJB QUEUE         @OZ34664
         SPACE 2                                               @OZ34664
*              THIS LINE DELETED BY APAR NUMBER                @OZ34664
S35DEQ   DS    0H                                              @OZ34664
*        THIS LINE DELETED BY APAR ===>                        @OZ44947
*        THIS LINE DELETED BY APAR ===>                        @OZ44947
         DEQ   RET=NONE,MF=(E,UDENQ) RELEASE SJB               @OZ34664
S35FREE  ESTAE 0                   TERMINATE ESTAE             @OZ36122
         LA    R0,ULEN             GET LENGTH OF ENQ/DEQ AREA  @OZ36122
         ICM   R0,8,=AL1(253)      SET SUBPOOL NUMBER          @OZ34664
         L     R13,UCALLER         RESTORE CALLER'S SAVEAREA   @OZ34664
         DROP  R8                  USE  OUR SAVE AREA          @OZ34664
         USING USAVE,R13           USE  CALLER'S SAVE AREA     @OZ34664
         LR    R1,R8               POINT TO AREA
         FREEMAIN R,LV=(0),A=(1)   FREE AREA
S35EXIT  LA    R15,SSWTRTOK        SET RETURN CODE
S35EXITA ST    R15,SSOBRETN        PUT INTO FEED BACK
         LM    R14,R12,USAVER      RESTORE CALLER REGISTERS
         LA    R15,SSRTOK          SET NORMAL RETURN
         BR    R14                 EXIT
         SPACE 1                                                     R4
S35EXIT4 LA    R15,SSWTNDSP        TELL IEAVVWTO TO            @OZ19488
         B     S35EXITA              DELETE MSG                @OZ19488
*        ERROR FOUND IN FORMATTING S35 WORK AREA               @OZ36122
S35EXIT5 LA    R0,S35DL            GET LENGTH OF AREA          @OZ36122
         ICM   R0,8,=AL1(URASP)    SET SUBPOOL NUMBER          @OZ36122
         LR    R1,R8               POINT TO AREA               @OZ36122
         FREEMAIN R,LV=(0),A=(1)   FREE AREA                   @OZ36122
         B     S35EXIT             RETURN TO CALLER            @OZ36122
         SPACE 1                                               @OZ36122
         USING S35DSECT,R8         ACCESS CURRENT SVC35 BUFF   @OZ34664
S35HIDSM MVC   S35WQEID+1(*-*),S35WQEID+S35HIDL-1  *** EXEC ONLY *** R4
S35NWSID MVC   1(*-*,R15),S35HIDL-1(R15)  *** EXEC ONLY ***    @OZ81035
S35HIDRM MVC   S35DHID+1(*-*),S35DJOBN-1  ***  EXEC ONLY  ***  @OZ30033
S35MVW   MVC   S35DACTF(*-*),WQETXT       *** EXECUTE ONLY ***       R4
S35MVI   MVC   WQETXT(*-*),S35DACTF       *** EXECUTE ONLY ***       R4
S35MVO   MVC   S35DTXT-1(*-*),S35WQEHT-1  *** EXECUTE ONLY ***       R4
URASP    EQU   255                 EXPLICITLY ASSIGNED LSQA    @OZ34664
         DROP  R3
         DROP  R5
         DROP  R6
         DROP  R8
         DROP  R10
         DROP  R12
         DROP  R13                 DROP OLD USAVE ADDRESS.     @OZ36122
         EJECT
***********************************************************************
*                                                                     *
*        MISCELLANEOUS                                                *
*                                                                     *
***********************************************************************
S34F7    EQU   CMBFLAGJ+CMBFLAGD+CMBFLAGS                            R4
CSAFP    EQU   231                 COMMON SERVICE AREA PROTECTED POOL
         EJECT
***********************************************************************
*                                                                     *
*        ITEMS MOVED INTO SVC 34 OR 35 QUEUE WORK AREA                *
*                                                                     *
***********************************************************************
S35PATRN ENQ   (*-*,*-*,E,3,STEP),RET=USE,MF=L                 @OZ34664
         DC    C'WTO'              R NAME FOR WTO LOGGING
         ESTAE UESTAER,TERM=YES,RECORD=YES,MF=(L)              @OZ36122
S35PATL  EQU   *-S35PATRN
S35ID    DC    CL4'S35D'           IDENTIFIER FOR SVC35 BUFF.  @OZ34664
S34TIME  DC    X'F021204B20204B202040'                         @OZ33128
         DC    CL10'JOB'           JOB NNNN--
         DC    C'R 00,'
S34DTXTC DC    CL(L'S34DTXT)' '
S34TL    EQU   *-S34TIME
***********************************************************************
*                                                                     *
*        SUBROUTINE TO BLANK HIGH ORDER ZEROS OF JOB NUMBER           *
*                                                                     *
***********************************************************************
SBLKJOB  LA    R0,4                SUPPRESS UP TO 4 DIGITS
         BALR  R15,0               ESTABLISH BASE
S34BKL   CLI   0(R1),C'0'          IS THIS ZERO
         BCR   NE,R14              SKIP BLANKING
         MVI   0(R1),C' '          BLANK
         LA    R1,1(0,R1)          UP TO NEXT
         BCTR  R0,R15              LOOP
         BR    R14                 RETURN
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO LOCATE SJB FOR SVC 34 AND 35 SUPPORT           *
*                                                                     *
***********************************************************************
SFNDSJB  LR    R0,R1               COPY ASID
         BCTR  R0,0                REDUCE BY ONE
         LTR   R0,R0               INSURE ASID GREATER THAN ONE
         BNPR  R14                 EXIT TO IGNORE ROUTINE
         BALR  R15,0               ESTABLISH BASE
         USING *,R15
         CLC   PSAAOLD-PSA,$SVPOSTE+4 CHECK FOR HASP ASCB
         BNE   SFNDSJBA            DO NORMAL PICK UP IF NOT
         ICM   R0,15,$SVHASP       HASP STILL UP
         BNER  R14                 EXIT TO IGNORE IF NOT
         LR    R0,R1               SAVE ASID
         L     R1,$SVHCT           POINT TO HCT
         CLC   PSATOLD-PSA,$WTOTCBA-HCTDSECT(R1) IS THIS $WTO
         BE    4(0,R14)            RETURN TO $WTO ROUTINE HANDLER
         CLC   PSATOLD-PSA,$CNVTCBA-HCTDSECT(R1) IS THIS CONVERTER
         BNER  R14                 EXIT TO IGNORE ROUTINE
         LR    R1,R0               RESTORE ASID
SFNDSJBA SLL   R1,2                GET ASID * 4 ( WORD/ASID )
         AL    R1,$SVHAVT          POINT TO VECTOR TABLE ENTRY
         L     R0,0(0,R1)          POINT TO SJB
SFNDSJBB LTR   R1,R0               COPY POINTER
         BZR   R14                 RETURN TO IGNORE IF NO SJB
         USING SJBDSECT,R1                                     @OZ64778
         OC    SJBSJB,SJBSJB       TEST FOR NEXT               @OZ64778
         BZ    8(0,R14)            RETURN IF NONE              @OZ64778
         L     R1,SJBSJB           POINT TO BATCH JOB SJB      @OZ64778
         TM    SJBFLG4,SJB4TERM    DONT USE THE BATCH JOBS     @OZ64778
         BZ    8(0,R14)             SJB FOR EDITING IF INIT    @OZ64778
         LR    R1,R0                 SPONTANEOUSLY             @OZ64778
         B     8(0,R14)               TERMINATED IT            @OZ64778
         DROP  R1,R15                                          @OZ64778
         EJECT                                                 @OZ36122
*************************************************************  @OZ36122
*                                                              @OZ36122
*         ESTAE EXIT FOR HOSWTO                                @OZ36122
*                                                              @OZ36122
*************************************************************  @OZ36122
         USING SDWA,R1             PROVIDE SDWA ADDRESS.       @OZ36122
         USING USAVE,R2            PROVIDE USAVE ADDRESS.      @OZ36122
         USING UESTAER,R12         PROVIDE UESTAER ADDRESS.    @OZ36122
UESTAER  LR    R12,R15             TEST TO SEE...              @OZ36122
         C     R0,=F'12'              IF SDWA OBTAINED...      @OZ36122
         BE    UESTA2              BRANCH IF NO.               @OZ36122
         L     R2,SDWAPARM         LOAD R2 WITH @ OF WORKAREA  @OZ36122
UESTA2   LR    R3,R14              SAVE RETURN ADDRESS         @OZ36122
         LR    R4,R1               SAVE SDWA ADDRESS           @OZ36122
         DEQ   RET=HAVE,MF=(E,UDENQ) ISSUE DEQUEUE             @OZ36122
         XR    R15,R15             CLEAR REGISTER 15           @OZ36122
         LR    R1,R4               RESTORE SDWA ADDRESS        @OZ36122
         BR    R3                  RETURN TO CALLER            @OZ36122
         DROP  R1                  DROP ADDRESSIBILITY         @OZ36122
         DROP  R2                  DROP ADDRESSIBILITY         @OZ36122
         DROP  R12                 DROP ADDRESSIBILITY         @OZ36122
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - PROCESS SYSOUT'
***********************************************************************
*                                                                     *
*        PROCESS SYSOUT - SUBSYSTEM FUNCTION SSOBSOUT                 *
*                                                                     *
* FUNCTION                                                            *
*                                                                     *
*    RECEIVE CONTROL FROM THE OPERATING SYSTEM OUTPUT COMMAND         *
*    PROCESSOR OR THE EXTERNAL WRITER FOR THE PURPOSE OF INTERFACING  *
*    WITH THE PROCESS SYSOUT SUPPORT ROUTINES IN HASPXEQ TO RETRIEVE  *
*    DATA SETS QUEUED TO THE HELD DATA SET QUEUE OR READY FOR         *
*    NORMAL OUTPUT AS APPROPRIATE AND DISPOSING OF THOSE DATA SETS    *
*    EITHER BY USE OF DATA MANAGEMENT FACILITIES TO RETRIEVE THE      *
*    DATA OR BY USE OF THIS INTERFACE TO RELEASE OR DELETE THE        *
*    DATA SETS.  THE FUNCTIONAL OPERATIONS ARE DESCRIBED BELOW.       *
*                                                                     *
*    (1) A $PROLOG MACRO INSTRUCTION IS EXECUTED TO GET CONTROL       *
*        OF THE USERS SJB (REQUESTOR MUST BE ONE OF OUR JOBS).        *
*                                                                     *
*    (2) IF THE SJB DOES NOT HAVE A PROCESS SYSOUT (PSO) WORK AREA,   *
*        THE REQUEST IS IGNORED (CONSIDERED A NOP), IF THE SSSOCTRL   *
*        FLAG IS ON AND THE SSSOUFLG BYTE IS ZERO. IF REQUEST NOT     *
*        IGNORED A PSO WORK AREA IS CREATED AND QUEUED TO THE SJB     *
*        USING AN SJB OWNED STORAGE CELL.                             *
*                                                                     *
*    (3) DESTINATION IS CONVERTED TO ROUTE CODE AND JOB ID IS         *
*        CONVERTED TO JOB NUMBER AS REQUESTED.                        *
*                                                                     *
*    (4) THE SJB IS QUEUED TO THE $SVPSOP QUEUE, HASP IS POSTED,      *
*        AND THE USER TASK IS MADE TO WAIT FOR HASP TO RESPOND.       *
*                                                                     *
*    (5) THE RESPONSE IS COPIED TO THE USER PARAMETER AREA, THE       *
*        PSO IS FREED IF THE SSSOCTRL FLAG IS ON OR AN ERROR IS       *
*        INDICATED IN THE RESPONSE WITHOUT HASP SETTING THE HIGH      *
*        ORDER BIT OF THE SJB PSO POINTER ON. CONTROL IS THEN         *
*        RETURNED TO THE USER VIA THE $EPILOG MACRO INSTRUCTION       *
*        WHICH FREES THE SJB FOR OTHERS.                              *
*                                                                     *
*    (6) IF DURING ANY PHASE OF PROCESSING IT IS DETERMINED THAT      *
*        HASP IS NOT UP, THE ROUTINE UNDOES ITS PROCESSING. IF        *
*        THE SJB HAS ALREADY BEEN PLACED ON THE QUEUE AND THE         *
*        OS WAIT MACRO HAS NOT BEEN ISSUED, THE CMS LOCK IS           *
*        OBTAINED AND THE SJB IS REMOVED FROM THE QUEUE (IF STILL     *
*        ON). THE PSO IS FREED AND THE HASP NOT UP DIAGNOSTIC IS      *
*        RETURNED TO THE USER.                                        *
*                                                                     *
*    (7) IF THIS ROUTINE IS PREEMPTED, A RECOVERY ROUTINE IS ENTERED  *
*        TO REMOVE THE SJB FROM THE $SVPSOQ EITHER BY WAITNIG IN      *
*        PLACE OF THE ORIGINAL TCB/RB OR BY DIRECT REMOVAL IF HASP    *
*        ABENDS. THIS ROUTINE MAY BE ENTERED AT ENTRY PSOQUEUE ((4)   *
*        ABOVE) AS A SUBROUTINE OF THE RECOVERY ROUTINE SO HASP CAN   *
*        DISPOSE OF THE DATA SET REPRESENTED BY THE LAST OR CURRENT   *
*        REQUEST. RETURN IS DIRECT TO THE RECOVERY ROUTINE.           *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
* INPUT REGISTERS -                                                   *
*                                                                     *
*        R0    = ADDRESS OF SSCVT                                     *
*        R1    = ADDRESS OF SSOB                                      *
*        R13   = ADDRESS OF SAVE AREA                                 *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* OUTPUT REGISTERS -                                                  *
*                                                                     *
*        R0-R14= UNCHANGED                                            *
*        R1    = ECB ADDRESS FOR WRITER TO WAIT ON DATA SETS          *
*        R15   = RETURN CODE                                          *
*                                                                     *
* NOTES                                                               *
*                                                                     *
*        THERE IS ONE AND ONLY ONE PROCESS SYSOUT (PSO) FOR EACH      *
*        SJB. UNPREDICTABLE RESULTS WILL OCCUR IF MULTIBLE TASKS      *
*        USE THIS INTERFACE ON AN UNCONTROLLED BASIS.                 *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        ENTRY TO PROCESS SYSOUT - PICK UP PARAMETERS                 *
*                                                                     *
***********************************************************************
HOSSOUT  $PROLOG SSOBSOUT,SSSOSIZE,LOCK=REQ  LOCATE AND LOCK SJB
PSOBASE  LA    R8,PSEPILOG         POINT EXIT TO CALL EPILOG
         USING SJBDSECT,R13        SET SJB ADDRESSABILITY
         USING SSSOBGN,R10         SET SSOB ADDRESSABILITY
         NI    SJBTFFG,255-SJBTFFGP RESET ANY REQUEST TO PURGE PSO
         L     R6,SJBPSOP          PICK UP POSSIBLE PSO ADDRESS
         L     R1,$SVHASP          TEST FOR
         LTR   R1,R1               HASP UP
         BZ    PSHASPUP            SKIP NEXT IF UP
         USING PSODSECT,R6                                     @OZ40277
PSNOHASP LA    R5,SSRTNTUP         SET NOT UP RETURN
         LTR   R6,R6               CHECK FOR PSO PRESENT
         BZ    PSXIT               EXIT IF NO PSO
         TM    PSOFLG2,PSOFPURG    IF PSO ALREADY PURGED,      @OZ40277
         BNZ   PSFREE               THEN JUST FREE THE PSO     @OZ40277
         OC    PSOIOTTR,PSOIOTTR   IF NO PRIOR ALLOCATIONS,    @OZ40277
         BZ    PSFREE               THEN JUST FREE THE PSO     @OZ40277
        $GETMAIN RC,SP=241,LV=PSOLNGTH,KEY=1  GET A NEW PSO    @OZ40277
         LTR   R15,R15             CHECK IF PSO GOTTEN         @OZ40277
         BNZ   PSFREE              BRANCH IF NOT               @OZ40277
         OI    PSOFLG2,PSOFDONE+PSOFPURG  INDICATE PSO PURGED  @OZ40277
         LR    R14,R6              COPY PSO ADDRESS            @OZ40277
         LR    R3,R1               SAVE NEW PSO ADDRESS        @OZ40277
         LR    R0,R1               COPY NEW PSO ADDRESS        @OZ40277
         LA    R1,PSOLNGTH         SET MOVE LENGTH             @OZ40277
         LR    R15,R1              MAKE LENGTHS EQUAL          @OZ40277
         MVCL  R0,R14              COPY THE PSO                @OZ40277
         L     R0,$SVPRGQ               QUEUE THE              @OZ40277
         ST    R0,PSONEXT-PSODSECT(,R3)  NEW PSO TO            @OZ40277
         CS    R0,R3,$SVPRGQ              THE PSO              @OZ40277
         BNE   *-12                        PURGE QUEUE         @OZ40277
         B     PSFREE              FREE PSO
         EJECT
***********************************************************************
*                                                                     *
*        CHECK FOR FIRST ENTRY OF SEQUENCE                            *
*                                                                     *
***********************************************************************
*                                  THIS LINE DELETED BY APAR   @OZ40277
PSHASPUP LTR   R6,R6
         BNE   PSMVCIN             MOVE PARAMETERS
         TM    SSSOFLG2,SSSOCTRL   IS THIS FIRST AND LAST
         BZ    PSGPSO              IF NOT GET PSO
         LA    R15,SSSORTOK        SET OK RETURN
         CLI   SSSOUFLG,0          IS THIS A GROUP REQUEST
         BZ    PSEPILOG            IF NOT CONSIDER THIS A NOP
***********************************************************************
*                                                                     *
*        GET WORK AREA FOR NEW SEQUENCE                               *
*                                                                     *
***********************************************************************
PSGPSO   OI    SJBTFFG,SJBTFFGG    SET PSO GOTTEN THIS ENTRY
         LA    R4,PSOLNGTH         GET LENGTH OF PSO
         L     R15,$SVGCELL        POINT TO GET CELL
         BALR  R14,R15             ENTER IT
         B     PSNCELL             EXIT IF NO CELL          +0
         LR    R6,R1               POINT TO CELL            +4
PSCELLG  LA    R5,PSOLNGTH-4       GET LENGTH OF PSO-4
         LA    R4,4(0,R6)          POINT TO OUR PORTION
         SLR   R0,R0               ZERO
         SLR   R1,R1               SOURCE ADDRESS AND LENGTH
         MVCL  R4,R0               ZERO WORK AREA
         ST    R6,SJBPSOP          SET POINTER TO PSO
PSMVCIN  MVC   PSOUFLG(PSOPARML),SSSOUFLG MOVE ALL PARAMETERS
         TM    PSOUFLG,PSOFSETC    IS CLASS TO BE CHANGED      @OZ68580
         BZ    PSOCONT             NO, BYPASS CHECK            @OZ68580
         LA    R2,PSOCLSTB         GET VALID S/O CLASS TABLE   @OZ68580
         SR    R1,R1               USE REQUESTED               @OZ68580
         IC    R1,PSOCLS            SYSOUT CLASS               @OZ68580
         LA    R1,0(R1,R2)           AS INDEX                  @OZ68580
         CLI   0(R1),X'00'            AND CHECK IF VALID       @OZ68580
         BNE   PSOCONT                 CONTINUE IF IT IS       @OZ68580
         NI    PSOUFLG,(FF-PSOFSETC)    ELSE, IGNORE REQUEST   @OZ68580
         SPACE 1                                               @OZ68580
PSOCONT  MVC   PSOTCB,SJBTCB       COPY TCB ADDRESS            @OZ68580
         TIME  BIN                 GET CURRENT DATE/TIME            R41
         ST    R1,PSOCRDT          STORE DATE IN PSO                R41
         EJECT                                                 @OZ68580
***********************************************************************
*                                                                     *
*        CONVERT DESTINATION TO ROUTE - JOB ID TO NUMBER              *
*                                                                     *
***********************************************************************
         TM    PSOUFLG,SSSOROUT    DOES USER WANT TO ROUTE TO DEST
         BO    PSODST              CONVERT IF YES
         TM    PSOFLG1,SSSODST     DID USER SPECIFY USE DESTINATION
         BZ    PSNODST             SKIP CONVERT IF NO
PSODST   DS    0H
         LA    R1,PSODEST          POINT TO DESTINATION FIELD
         SLR   R2,R2               PRESET REG 2 TO                   R4
         IC    R2,$SVTOSYS           FIRST BYTE OF ROUTE CODE        R4
         L     R15,$SVDEST         POINT TO VERIFY DESTINATION AND
         BALR  R14,R15             CONVERT ROUTINE - ENTER IT
         B     PSDEXIT             FREE THE PSO AND EXIT    +0
         STH   R2,PSOROUTE         SET ROUTE CODE           +4
PSNODST  DS    0H
         TM    PSOFLG1,SSSOSJBI    DID USER SPECIFY USE JOB ID
         BZ    PSNOSJBI            SKIP CONVERT IF NO
         LA    R1,PSOJOBI          POINT TO JOB ID FIELD
         L     R15,=A(TSCNVJB)     POINT TO CONVERT ROUTINE
         BALR  R14,R15             CONVERT
         LTR   R0,R0               TEST FOR OK
         BZ    PSJEXIT             FREE THE PSO AND EXIT
         STH   R0,PSOJOBNO         SET JOB NUMBER
PSNOSJBI DS    0H
         EJECT
***********************************************************************
*                                                                     *
*        QUEUE REQUEST TO HASP - POST AND WAIT                        *
*                                                                     *
* NOTE - THIS ROUTINE IS USED AS A SUBROUTINE BY               @OZ44608
*        EOT, EPILOG, EOJ, AND EOM                             @OZ44608
*                                                                     *
***********************************************************************
PSOQUEUE DS    0H
         ICM   R6,7,SJBPSOP+1      POINT TO PSO                @OZ51577
         CLI   PSOUFLG,0           CHECK FOR GROUP REQ         @OZ40281
         BNE   PSOENQ              BRANCH IF YES               @OZ40281
         TM    PSOFLG2,SSSOCTRL    IS REQ FOR TERMINATE        @OZ40281
         BNO   PSOENQ              NO, CONTINUE                @OZ40281
         TM    SJBPSOP,X'40'       DOES HASP WANT PSO...       @OZ49322
         BO    PSOENQ              YES, TELL IT TO FREE        @OZ49322
         OC    PSOIOTTR,PSOIOTTR   IF NO HELD                  @OZ40281
         BNZ   PSOENQ               DATASETS OR                @OZ40281
         CLI   PSOWKOFF,0            JOES ALLOCATED, THEN      @OZ40281
         BE    PSONOQ                 NO NEED TO TELL HASP     @OZ40281
PSOENQ   LA    R4,$SVPSOQ          POINT TO PSO QUEUE          @OZ40281
         L     R15,=A(TSQUEUE)     POINT TO QUEUING ROUTINE
         BALR  R14,R15             ENTER IT
         $$POST ELMT=$SVPSO        POST HASP
         BNZ   PSHABDQ             IF HASP ABENDED DEQUEUE
PSWAIT   WAIT  1,ECB=SJBECB        WAIT
         L     R1,$SVHASP          TEST FOR
         LTR   R1,R1               HASP UP
         BNZ   PSNOHASP            EXIT IF NOT
***********************************************************************
*                                                                     *
*        MOVE THE RESPONSE BACK TO HASP                               *
*                                                                     *
***********************************************************************
PSONOQ   L     R1,PSORETN          PICK UP RETURN CODE         @OZ40281
         LCR   R5,R1               SET RETURN IN NEGATIVE FORM
         TM    SJBTFFG,SJBTFFGP    TEST FOR PSO PURGE ON            R41
         BO    *+10                BR IF YES                        R41
         MVC   SSSOUFLG(PSOPARML),PSOUFLG MOVE ALL PARAMETERS
         CH    R1,=Y(SSSORTOK)     CHECK RETURN CODE
         BNE   PSBADRET            TRY TO FREE AREA AND EXIT
         TM    PSOFLG2,SSSOCTRL    IS THIS LAST OF A SERIES
         BZ    PSXIT               SKIP AREA FREE IF NOT
PSFREE   XC    SJBPSOP,SJBPSOP     ZERO SJB POINTER TO AREA
         LR    R1,R6               POINT TO CELL
         L     R15,$SVFCELL        POINT TO FREE CELL
         BALR  R14,R15             FREE CELL
PSXIT    LCR   R15,R5              COMPLIMENT RETURN CODE
         BR    R8                  RETURN
PSDENOQE LA    R15,SSSOIDST        SET INVALID DESTINATION
         B     PSEPILOG            EXIT
PSJENOQE LA    R15,SSSOINVA        SET INVALID SEARCH ARGUMENTS
         B     PSEPILOG            EXIT
PSLENOQE LA    R15,SSSOUNAV        SET UNABLE TO PROCESS NOW   @OZ55639
*              THIS LINE DELETED BY APAR NUMBER                @OZ55639
         EJECT                                                       R4
PSEPILOG $EPILOG ,                 EXIT THROUGH EPILOG
PSBADRET TM    SJBPSOP,X'40'       DOES HASP WANT PSO...       @OZ38441
         BZ    PSFREE              IF NOT FREE IT              @OZ38441
         B     PSXIT               EXIT
         EJECT
***********************************************************************
*                                                                     *
*        HASP DETERMINED NOT UP AFTER SJB ALREADY ON QUEUE            *
*                                                                     *
***********************************************************************
PSHABDQ  LR    R5,R11              SAVE
         LR    R6,R12              SOME
         LR    R7,R13              REGISTERS
         L     R15,=A(TSETLOCK)    SET CMS
         BALR  R2,R15              LOCK
         LR    R11,R5              RESTORE
         LR    R12,R6              THOSE
         LR    R13,R7              REGISTERS
         L     R15,=A(TSHABDQ)     POINT TO ABNORMAL DEQ ROUTINE     JN
         BALR  R14,R15             ENTER IT
         LR    R3,R2               SAVE DEQUEUED SJB OR ZERO   @OZ69034
         L     R15,=A(TSFRELOK)    FREE CMS
         BALR  R2,R15              LOCK                        @OZ69034
         LR    R11,R5              RESTORE
         LR    R12,R6              THE
         LR    R13,R7              REGISTERS
         L     R6,SJBPSOP          POINT TO PSO CELL           @OZ38443
         LTR   R3,R3               TEST FOR DEQUEUED SJB       @OZ69034
         BZ    PSWAIT              WAIT, HASP GOT TO IT FIRST
         B     PSNOHASP            EXIT
***********************************************************************
*                                                                     *
*        TEXT IN JOB ID OR DESTINATION FIELDS INVALID                 *
*                                                                     *
***********************************************************************
PSDEXIT  LA    R8,PSDENOQE         SET EXIT LOCATION FOR BAD DEST
         B     *+8                 SKIP NEXT INSTRUCTION
PSJEXIT  LA    R8,PSJENOQE         SET EXIT LOCATION FOR JOB ID ERROR
         TM    SJBTFFG,SJBTFFGG    TEST FOR PSO JUST GOTTEN
         BO    PSFREE              IF SO HASP HAS NOTHING TO DO HERE
         OI    PSOFLG2,SSSOCTRL    SET LAST OF SERIES
         B     PSOQUEUE            ENTER QUEUE ROUTINE AS SUBROUTINE
***********************************************************************
*                                                                     *
*        CELL NOT IMMEDIATELY AVAILABLE - ASK HASP TO EXPAND          *
*                                                                     *
***********************************************************************
PSNCELL  ENQ   MF=(E,$SVCENQ)      ENQ
PSNCELLL LA    R4,PSOLNGTH         SET LENGTH AGAIN
         L     R15,$SVGCELL        POINT TO GET CELL
         BALR  R14,R15             TRY GET CELL AGAIN
         B     PSNCELLA            IF NO CELL, BRANCH       +0
         LR    R6,R1               POINT TO CELL            +4
         DEQ   MF=(E,$SVCENQ)      DEQ
         B     PSCELLG             ENTER NORMAL PROCESSING
PSNCELLA ICM   R1,15,$SVHASP       HASP UP
         BNZ   PSDEQNH             EXIT IF NOT
         LA    R0,SJBECB           POINT TO ECB TO POST
         MVI   SJBECB,0            ZERO ECB
         L     R15,$SVGCPOL        POINT TO HASP NOTIFY ROUTINE
         BALR  R14,R15             ENTER IT
         CLI   SJBECB+3,0          TEST ECB FOR ZERO
         BZ    PSNCELLL            LOOP IF OK
         DEQ   MF=(E,$SVCENQ)      DEQ
         B     PSLENOQE            EXIT, UNABLE TO PROCESS     @OZ55639
PSDEQNH  DEQ   MF=(E,$SVCENQ)      DEQ
         B     PSNOHASP            EXIT TO RETURN ERROR
         SPACE 1                                               @OZ68580
PSOCLSTB DC    256X'00'                                        @OZ68580
         ORG   PSOCLSTB+C'A'                                   @OZ68580
         DC    C'ABCDEFGHI'                                    @OZ68580
         ORG   PSOCLSTB+C'J'                                   @OZ68580
         DC    C'JKLMNOPQR'                                    @OZ68580
         ORG   PSOCLSTB+C'S'                                   @OZ68580
         DC    C'STUVWXYZ'                                     @OZ68580
         ORG   PSOCLSTB+C'0'                                   @OZ68580
         DC    C'0123456789'                                   @OZ68580
         ORG   ,                                               @OZ68580
         SPACE 1                                               @OZ68580
         DROP  R6,R10,R12,R13
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - CANCEL/STATUS'
***********************************************************************
*                                                                     *
*        CANCEL/STATUS - SUBSYSTEM FUNCTIONS SSOBCANC/SSOBSTAT        *
*                                                                     *
* FUNCTION                                                            *
*                                                                     *
*    RECEIVE CONTROL FROM THE OPERATING SYSTEM CANCEL AND STATUS      *
*    PROCESSORS FOR THE PURPOSE OF INTERFACING WITH THE HASPXEQ       *
*    CANCEL/STATUS SERVICE ROUTINE FOR CANCELLING A UNIQUELY          *
*    IDENTIFIED JOB OR PROVIDE SELECTED STATUS INFORMATION ON         *
*    JOBS BY UNIQUE IDENTIFICATION, JOB NAME (ALL WITH SAME NAME),    *
*    OR USER IDENTIFICATION (ALL JOBS WITH NAME MATCHING THE USER     *
*    ID WITH ONE ADDITIONAL TRAILLING CHARACTER). THE FUNCTIONAL      *
*    OPERATIONS ARE DESCRIBBED BELOW.                                 *
*                                                                     *
*    (1) A $PROLOG MACRO INSTRUCTION IS EXECUTED TO GET CONTROL       *
*        OF THE USER SJB (REQUESTOR MUST BE ONE OF OUR JOBS).         *
*                                                                     *
*    (2) JOB ID IS CONVERTED TO JOB NUMBER AS REQUESTED.              *
*                                                                     *
*    (3) THE SJB IS QUEUED TO THE $SVTSCS QUEUE, HASP IS POSTED       *
*        AND THE USER TASK IS MADE TO WAIT FOR HASP TO RESPOND.       *
*                                                                     *
*    (4) THE RESPONSE IS COPIED TO THE USER PARAMETER AREA, THE       *
*        STATUS AREA (IF GOTTEN BY HASP) IS FREED, AND CONTROL IS     *
*        RETURNED TO THE USER VIA THE $EPILOG MACRO INSTRUCTION.      *
*                                                                     *
*    (5) IF DURING ANY PHASE OF PROCESSING IT IS DETERMINED THAT      *
*        HASP IS NOT UP, THE ROUTINE UNDOES ITS PROCESSING. IF THE    *
*        SJB HAS ALREADY BEEN PLACED ON THE QUEUE AND THE OS WAIT     *
*        HAS NOT BEEN ISSUED, THE CMS LOCK IS OBTAINED AND THE SJB    *
*        IS REMOVED FROM THE QUEUE (IF STILL ON). THE HASP NOT UP     *
*        DIAGNOSTIC IS RETURNED TO THE USER.                          *
*                                                                     *
*    (6) IF THIS ROUTINE IS PREEMPTED, A RECOVERY ROUTINE IS ENTERED  *
*        TO REMOVE THE SJB FROM THE $SVTSCS QUEUE EITHER BY WAITING   *
*        IN PLACE OF THE ORIGINAL TCB/RB OR DIRECT REMOVAL IF HASP    *
*        ABENDS.                                                      *
*                                                                     *
* INPUT REGISTERS                                                     *
*                                                                     *
*        R0    = ADDRESS OF SSCVT                                     *
*        R1    = ADDRESS OF SSOB                                      *
*        R13   = SAVE AREA                                            *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* OUTPUT REGISTERS                                                    *
*                                                                     *
*        R0-R14= UNCHANGED                                            *
*        R15   = RETURN CODE                                          *
*                                                                     *
         EJECT                                                       R4
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        ENTRY TO CANCEL/STATUS - PICK UP PARAMETERS                  *
*                                                                     *
***********************************************************************
HOSSTAT  $PROLOG SSOBSTAT,0,LOCK=REQ  LOCATE AND LOCK USER'S SJB
TSSTAT   AL    R12,=A(TSCAN-TSSTAT) POINT TO TSCAN
         BR    R12                 ENTER COMMON CODE
HOSCANC  $PROLOG SSOBCANC,0,LOCK=REQ  LOCATE AND LOCK USER'S SJB
TSCAN    LR    R8,R1               POINT TO SSOB (SSIB NOT REQUIRED)
         USING SSOB,R8
         USING SJBDSECT,R13        BASES ARE
         USING SSCSBGN,R10         ESTABLISHED
         USING SSVT,R11            BY PROLOG
         LA    R5,SSRTNTUP         SET HASP NOT UP
         ICM   R1,15,$SVHASP       IS HASP UP
         BNZ   TSRELSE             EXIT IF NOT
         LA    R5,SSRTLERR         SET ABORT RETURN FOR LOGIC ERROR
         EJECT
***********************************************************************
*                                                                     *
*        FILL IN REQUEST PARAMETERS                                   *
*                                                                     *
***********************************************************************
         MVC   SJBTULEN,SSCSULEN   COPY USER ID LENGTH
         MVC   SJBTFUNC,SSOBFUNC   COPY FUNCTION
         MVC   SJBTFLGS,SSCSFLGS
         MVC   SJBTJOBN,SSCSJOBN   COPY JOB NAME
         MVC   SJBTDIMP,SSCSDIMP   COPY ARRAY SIZE
         STH   R5,SJBTRETR         SET DEFAULT RETURN
         SLR   R0,R0               ZERO JOB ID
         ST    R0,SJBTAREA         ZERO AREA POINTER
         STH   R0,SJBTDIMR         ZERO RESPONSE SIZE
         CLI   SSCSJOBI,C' '       DID REQUEST INDICATE JOB ID
         BE    TSNJOBID            IF NOT SKIP CONVERT
         LA    R1,SSCSJOBI         POINT TO JOB ID FIELD
         L     R15,=A(TSCNVJB)     POINT TO CONVERT ROUTINE
         BALR  R14,R15             CONVERT
         LA    R15,SSCSYNTX        SET SYNTAX ERROR RETURN
         LTR   R0,R0               CHECK FOR ERROR
         BZ    TSRELSEA            REJECT REQUEST IF ERROR
TSNJOBID ST    R0,SJBTJOBI         SET JOB ID IN BINARY FORM
***********************************************************************
*                                                                     *
*        FUNCTION ORIENTED SETTINGS                                   *
*                                                                     *
***********************************************************************
         CLC   SSOBFUNC,=Y(SSOBCANC) IS THIS CANCEL
         BE    TSCANC              IF YES, NO MORE TO FILL OUT
         LH    R0,SJBTDIMP         PICK UP AREA SIZE
         CH    R0,=Y(SSCSELSZ)     CHECK FOR AT LEAST ONE ELEMENT
         BL    TSRELSE             ERROR IF NOT
***********************************************************************
*                                                                     *
*        QUEUE REQUEST TO HASP                                        *
*                                                                     *
***********************************************************************
TSCANC   LA    R4,$SVTSCS          POINT TO CANCEL/STATUS QUEUE
         L     R15,=A(TSQUEUE)     POINT TO QUEUING ROUTINE
         BALR  R14,R15             ENTER IT
         $$POST ELMT=$SVJOB        POST HASP
         BZ    TSWAIT              WAIT FOR HASP IF STILL UP
         LR    R5,R11              SAVE
         LR    R6,R12              SOME
         LR    R7,R13              REGISTERS
         L     R15,=A(TSETLOCK)    SET CMS
         BALR  R2,R15              LOCK
         LR    R11,R5              RESTORE SSVT BASE
         LR    R12,R6              PUT BASE BACK
         LR    R13,R7              RESTORE SJB BASE
         L     R15,=A(TSHABDQ)     ADDR ABNORMAL DEQUEUE RTN   @OZ69034
         BALR  R14,R15             ENTER IT
         LR    R3,R2               SAVE DEQUEUED SJB OR ZERO   @OZ69034
         L     R15,=A(TSFRELOK)    FREE CMS
         BALR  R2,R15              LOCK                        @OZ69034
         LR    R11,R5              RESTORE
         LR    R12,R6              THE
         LR    R13,R7              REGISTERS
         LTR   R3,R3               TEST FOR DEQUEUED SJB       @OZ69034
         BZ    TSWAIT              WAIT. HASP GOT TO IT FIRST
         LA    R5,SSRTNTUP         SET HASP NOT UP
         B     TSFREEA             FREE AREA IF PRESENT AND EXIT
         EJECT
***********************************************************************
*                                                                     *
*        WAIT AND FILL IN RESPONSE                                    *
*                                                                     *
***********************************************************************
TSWAIT   WAIT  1,ECB=SJBECB        WAIT
         LA    R5,SSRTNTUP         SET HASP NOT UP
         ICM   R1,15,$SVHASP       TEST ECB FOR HASP UP
         BNZ   TSFREEA             FREE AREA, IF PRESENT AND EXIT
         LH    R5,SJBTRETR         PICK UP R15 RETURN
         CH    R5,=Y(SSRTOK)       CHECK FOR OK RETURN
         BNE   TSFREEA             FREE AREA
         LH    R6,SJBTRETB         PICK UP SSOBRETN CODE
         LCR   R5,R6               SET COMPLIMENT FOR RECOMPLIMENT
         CLI   SJBTFUNC+1,SSOBCANC IS THIS CANCEL
         BE    TSCKSVC             IF YES, TEST FOR SVC 34 REQUIRED
         MVC   SSCSDIMR,SJBTDIMR   SET SIZE OF AREA
         CH    R6,=Y(SSCSMALL)     CHECK FOR AREA TOO SMALL
         BE    TSFREEA             FREE AREA
         L     R0,SJBTAREA         POINT TO WORK AREA
         LH    R1,SJBTDIMR         PICK UP AMOUNT TO MOVE
         LTR   R1,R1               CHECK FOR MOVE
         BZ    TSFREEA             SKIP MOVE IF ZERO
         LA    R2,SSCSARBG         POINT TO START OF ARRAY
         LR    R3,R1               COPY LENGTH
         MVCL  R2,R0               MOVE RESPONSE ARRAY
         EJECT
***********************************************************************
*                                                                     *
*        FREE WORK AREA                                               *
*                                                                     *
***********************************************************************
TSFREEA  L     R1,SJBTAREA         POINT TO AREA
         LTR   R1,R1               CHECK FOR ZERO
         BZ    TSRELSE             RELEASE SJB IF NO AREA
         MVC   0(4,R1),SJBTCCE     PUT CCE POINTER INTO CELL
         L     R15,$SVFCELL        POINT TO FREE CELL ROUTINE
         BALR  R14,R15             FREE CELL
TSRELSE  LCR   R15,R5              SET RETURN FOR EPILOG
TSRELSEA $EPILOG ,                 EXIT THROUGH EPILOG
TSCKSVC  EQU   TSRELSE             NO ACTION REQUIRED FOR CANCEL
         DROP  R8
         DROP  R10
         DROP  R12
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO CONVERT EXTERNAL JOB ID TO JOB NUMBER          *
*                                                                     *
* REGISTERS                                                           *
*                                                                     *
*        R0    = ANSWER OR ZERO                                       *
*        R1    = INPUT TEXT                                           *
*        R2    = WORK                                                 *
*        R3    = WORK                                                 *
*        R4    = WORK                                                 *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
***********************************************************************
TSCNVJB  DS    0H
         USING *,R15
         LA    R2,L'SSCSJOBI-1     SET NUMERIC DIGIT LIMIT
TSCNVJBO SLR   R0,R0               ZERO THE ACCUMULATOR
         SLR   R4,R4               ZERO BASE
         CLI   0(R1),C'J'          IS THIS 'JOB'
         BE    TSCNVJBL            SKIP TO NUMERIC IF YES
         LH    R4,=H'10000'        SET BASE RANGE FOR 'STC'
         CLI   0(R1),C'S'          CHECK FOR 'STC'
         BE    TSCNVJBL            SKIP TO NUMERIC IF YES
         AH    R4,=H'10000'        SET BASE RANGE FOR 'TSU'
         CLI   0(R1),C'T'          CHECK FOR 'TSU'
         BNER  R14                 EXIT WITH ERROR
TSCNVJBL LA    R1,1(0,R1)          UP 1
         CLI   0(R1),C'0'          CHECK FOR NUMERIC
         BNL   TSCNVJBA            IF NOT LOW ASSUME NUMERIC
         BCT   R2,TSCNVJBL         LOOP TO END
         BR    R14                 EXIT WITH ZERO
TSCNVJBN CLI   0(R1),C'0'          CHECK FOR BELOW NUMERIC
         BL    TSCNVCBL            CHECK FOR BLANK OR END
TSCNVJBA IC    R3,0(0,R1)          PICK UP DIGIT
         N     R3,=X'0000000F'     CUT OFF HIGH PART
         MH    R0,=H'10'           MULTIPLY BY 10
         AR    R0,R3               ADD
         CH    R0,=H'9999'         MAKE SURE NOT ABOVE MAX
         BH    TSCNVJBO            RESET JOB NUMBER AND RETURN
TSCNVJCT LA    R1,1(0,R1)          UP TO NEXT DIGIT
         BCT   R2,TSCNVJBN         LOOP
         B     TSCNVEND            EXIT WITH VALUE
TSCNVCBL CLI   0(R1),C' '          IS IT BLANK
         BE    TSCNVJCT            IGNORE IF BLANK
TSCNVEND LTR   R0,R0               CHECK FOR ZERO
         BZR   R14                 EXIT WITH ZERO
         AR    R0,R4               ADD BASE
         BR    R14                 RETURN WITH ANSWER
         DROP  R15
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO QUEUE THE SJB TO ALTERNATE HASP WORK QUEUE     *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = WORK (ON RETURN CONTAINS PREVIOUS QUEUE VALUE)       *
*        R1    = WORK                                                 *
*        R2    = WORK                                                 *
*        R3    = WORK                                                 *
*        R4    = ADDRESS OF QUEUE HEAD                                *
*        R13   = ADDRESS OF SJB                                       *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
***********************************************************************
         USING *,R15
TSQUEUE  DS    0H
         SLR   R0,R0               ZERO
         ST    R0,SJBECB           THE ECB
         OI    SJBTFFG,SJBTFFGM    SET ECB STATUS MEANGINGFULL
         LR    R2,R13              POINT TO SJB
         LM    R0,R1,0(R4)         PICK UP CURRENT QUEUE HEADER
TSQUL    LR    R3,R1               COPY COUNTER
         ST    R0,SJBTCHN          PUT OLD ELEMENTS BEHIND
         BCTR  R3,0                REDUCE
         CDS   R0,R2,0(R4)         QUEUE SJB
         BNZ   TSQUL               LOOP IF NOT QUEUED
         LTR   R0,R0               DO WE TELL HASP
         BR    R14                 RETURN
         DROP  R15
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO SCAN FOR TSO QUEUED SJB ON USER ABEND          *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = WORK                                                 *
*        R1    = WORK - ZERO ON SJB NOT FOUND RETURN (CC SET)         *
*        R4    = ADDRESS OF QUEUE HEAD                                *
*        R13   = ADDRESS OF SJB                                       *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* NOTES -                                                             *
*                                                                     *
*        THIS ROUTINE IS ENTERED FROM THE END OF TASK ROUTINE         *
*        WITH CMS LOCK ON.                                            *
*                                                                     *
***********************************************************************
TSUABQS  DS    0H
         USING *,R15
         MVI   $SVTSLOK,X'FF'      TELL HASP TO SET LOCK
         L     R0,0(0,R4)          PICK UP FIRST SJB
TSUABQSL LTR   R1,R0               COPY AND SET CC
         BZR   R14                 EXIT IF NOT ON THE QUEUE (CC=0)
         L     R0,SJBTCHN-SJBDSECT(,R1) POINT TO NEXT SJB
         CR    R1,R13              IS THIS OUR SJB
         BNE   TSUABQSL            LOOP IF NOT
         MVI   SJBTFLOW,X'FF'      FAKE HASP HAS SEEN
         LTR   R1,R1               SET CC
         BR    R14                 EXIT WITH R1 AND CC NON-ZERO.
         DROP  R15
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO RETRIEVE TSO QUEUED SJB WHEN HASP ABENDS       *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = WORK                                                 *
*        R1    = WORK                                                 *
*        R2    = WORK - ZERO ON RETURN IF SJB NOT DEQUEUED (CC SET)   *
*        R3    = WORK                                                 *
*        R4    = QUEUE POINTER                                        *
*        R13   = ADDRESS OF SJB                                       *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* NOTES -                                                             *
*                                                                     *
*        CMS LOCK IS HELD ON ENTRY. HASP IS EXPECTED TO HOLD CMS      *
*        LOCK WHEN DEQUEUING AND WHEN RESETTING THE HASP NOT UP       *
*        INDICATOR.                                                   *
*                                                                     *
***********************************************************************
TSHABDQ  DS    0H
         USING *,R15
         ICM   R2,15,$SVHASP       INSURE HASP NOT UP
         BZR   R14                 ERROR EXIT
         LM    R2,R3,0(R4)         PICK UP CHAIN INFO
TSHABDQX LTR   R2,R2               TEST END
         BZR   R14                 ERROR EXIT
         CR    R2,R13              IS IT OUR SJB
         BNE   TSHABDQN            TRY NEXT
         L     R0,SJBTCHN-SJBDSECT(,R2) POINT TO NEXT
         LR    R1,R3               COPY SECURITY COUNT
         CDS   R2,R0,0(R4)         TRY TO TAKE SJB OFF
         BNZ   TSHABDQX            LOOP IF NOT OFF
TSHABDQE LTR   R2,R2               SET CC
         BR    R14                 EXIT
TSHABDQN LR    R3,R2               COPY CURRENT POINTER
         ICM   R2,15,SJBTCHN-SJBDSECT(R2) POINT TO NEXT
         BZR   R14                 EXIT IF ERROR
         CR    R2,R13              IS THIS OUR SJB
         BNE   TSHABDQN            LOOP IF NOT
         MVC   SJBTCHN-SJBDSECT(,R3),SJBTCHN-SJBDSECT(R2) DEQUEUE
         B     TSHABDQE            EXIT
         DROP  R15
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO SET LOCK                                       *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R2    = RETURN                                               *
*        R11   = WORK                                                 *
*        R12   = WORK                                                 *
*        R13   = WORK                                                 *
*        R14   = WORK                                                 *
*        R15   = ENTRY BASE - WORK                                    *
*                                                                     *
***********************************************************************
TSETLOCK DS    0H
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(QUEUES,*-*,TSFRC
               ELOK)               ENQ ON TS QUEUES TO HASP
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=(QUEUES,*-*,TSFRELC
               OK)                 ENQ ON HASP TS QUEUES
         BR    R2                  RETURN
         SPACE 1
***********************************************************************
*                                                                     *
*        SUBROUTINE TO FREE LOCK                                      *
*                                                                     *
* REGISTERS -                                                         *
*        R2    = RETURN                                        @OZ69034
*        R11   = WORK                                                 *
*        R12   = WORK                                                 *
*        R13   = WORK                                                 *
*        R14   = WORK                                                 *
*        R15   = ENTRY BASE - WORK                                    *
*                                                                     *
***********************************************************************
TSFRELOK DS    0H
         SETLOCK RELEASE,TYPE=CMS,RELATED=(QUEUES,*-*,TSETLOCK)
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=(QUEUES,*-*,TSETLOCK)
         BR    R2                  RETURN                      @OZ69034
         DROP  R13
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - VERIFY USER ID'
***********************************************************************
*                                                                     *
*        SUBSYSTEM FUNCTION SSOBUSER                                  *
*                                                                     *
* FUNCTION                                                            *
*                                                                     *
*    RECEIVE CONTROL FROM OS ROUTINES TO PROVIDE ACCEPTANCE OR        *
*    REJECTION OF DESTINATION PARAMETERS SUCH AS DEFAULT DESTINATION  *
*    FOR TIME SHARING USERS. THE USERVERF SUBROUTINE IS CALLED AND    *
*    YES OR NO ANSWER IS RETURNED TO THE CALLER.                      *
*                                                                     *
* INPUT REGISTERS                                                     *
*                                                                     *
*        R0    = ADDRESS OF SSCVT                                     *
*        R1    = ADDRESS OF SSOB                                      *
*        R13   = SAVE AREA                                            *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* OUTPUT REGISTERS                                                    *
*                                                                     *
*        R0-R14= UNCHANGED                                            *
*        R15   = RETURN CODE                                          *
*                                                                     *
* WORK AREAS                                                          *
*                                                                     *
*        SSVT EXTENSION - CONTAINS HASP ROUTE CODE INFORMATION        *
*                                                                     *
***********************************************************************
HOSUSER  $ENTRY BASE=R15,ENTRY=NO  PROVIDE ENTRY FOR ROUTINE
USER     EQU   HOSUSER
         USING USAVE,R13
         STM   R14,R12,USAVER      SAVE CALLER'S REGISTERS
         LR    R12,R15             ESTABLISH BASE
         USING USER,R12
         DROP  R15
         LR    R8,R0               POINT TO SSCVT
         USING SSCT,R8
         ICM   R11,15,SSCTSSVT     POINT TO SSVT
         BZ    HOSERROR            EXIT WITH ERROR
         LR    R10,R1              POINT TO SSOB
         USING SSOB,R10
         L     R1,SSOBINDV         POINT TO FUNCTION AREA
         LA    R4,SSUSRTOK         GET OK RETURN CODE
         LA    R1,SSUSUSER-SSUSBGN(0,R1) POINT TO DESTINATION
         SLR   R2,R2               ZERO REGISTER                     R4
         IC    R2,$SVTOSYS         SET DEFAULT FOR BYTE 1            R4
         BAL   R14,USERVERF        ENTER VERIFICATION
         LA    R4,SSUSNOUS         SET INVALID RETURN  (R14)+0
         ST    R4,SSOBRETN         SET RETURN          (R14)+4
         LM    R14,R12,USAVER      PICK UP REGISTERS
         LA    R15,SSRTOK          SET OK COMPLETION
         BR    R14                 RETURN
HOSERROR LM    R14,R12,USAVER      PICK UP REGISTERS                 R4
         LA    R15,SSRTNTUP        SIGNAL HASP NOT UP                R4
         BR    R14                 RETURN                            R4
         DROP  R8
         DROP  R10
         DROP  R12
         EJECT
***********************************************************************
*                                                                     *
*        SUBROUTINE TO CONVERT 'RXXX    '                             *
*        'UXXX    ','LOCAL   ','XXXXXXXX' (USER SPECIFIED) TO         *
*        BINARY ROUTE CODE AND PROVIDE VALIDITY CHECK. 'LOCAL   '     *
*        RESULTS IN 'XX00' ROUTE CODE (XX = SUPPLIED BY CALLER).      *
*        BLANK AND BINARY ZEROS RESULT IN X'0000' ROUTE CODE.         *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = WORK                                                 *
*        R1    = INPUT - ADDRESS OF 8 BYTE DESTINATION                *
*                OUTPUT- UNPREDICTABLE                                *
*        R2    = INPUT - DEFAULT FIRST BYTE OF ROUTE                  *
*              = OUTPUT- X'XXRR' OR '00UU' ROUTE CODE                 *
*        R3    = WORK                                                 *
*        R11   = ADDRESS OF SSVT - SET BY CALLER                      *
*        R14   = RETURN- 0+(R14) - ERROR RETURN                       *
*                        4+(R14) - OK RETURN - ( R2 VALID )           *
*        R15   = BASE  - SET BY CALLER IF ENTRY 'USERDEST'            *
*                                                                     *
***********************************************************************
USERVERF BALR  R15,0               ESTABLISH BASE FOR SUBROUTINE
         USING *,R15
USERDEST DS    0H
         SLL   R2,32-8             ALIGN DEFAULT HIGH BYTE           R4
         LA    R15,0(,R15)         PURIFY BASE                       R4
         OR    R15,R2              COMBINE                           R4
         LA    R14,0(,R14)         PURIFY ADDRESS                    R4
         OR    R14,R2              COMBINE IN CASE NOT NATIVE        R4
         SLR   R2,R2               ZERO                              R4
         CLC   0(8,R1),=CL8' '     BLANKS                            R4
         BE    4(0,R14)            RETURN WITH INDIRECT ROUTE CODE   R4
         CLC   0(8,R1),=XL8'0'     ZERO                              R4
         BZ    4(0,R14)            RETURN WITH INDIRECT ROUTE CODE   R4
         CLC   0(3,R1),=C'RMT'     THIS 'RMT'                        R4
         BNE   USNNA               SKIP IF NOT                       R4
         LA    R1,2(,R1)           SET TO SCAN                       R4
         LA    R0,6                'RMTNNNNN'                        R4
         B     USLR                ENTER COMMON CODE                 R4
USNNA    CLC   0(2,R1),=C'RM'      THIS 'RM'                         R4
         BNE   USNNB               SKIP IF NOT                       R4
         LA    R1,1(,R1)           SET TO SCAN                       R4
         LA    R0,7                'RMNNNNNN'                        R4
         B     USLR                ENTER COMMON CODE                 R4
USNNB    DS    0H                                                    R4
         LA    R0,8                SET COUNTER                       R4
USNN     CLI   0(R1),C'R'          THIS REMOTE                       R4
         BE    USLR                CONVERT REMOTE IF YES             R4
         CLI   0(R1),C'U'          THIS UNIT                         R4
         BNE   USS                 SCAN DESTINATION TABLE IF NOT     R4
         LA    R15,0(,R15)         CLEAR FIRST BYTE                  R4
USLR     LA    R1,1(,R1)           POINT TO NEXT CHARACTER           R4
         BCT   R0,USBR             CHECK FOR BLANK                   R4
         CLM   R15,8,=XL8'0'       UXXX                              R4
         BZ    USUR                TEST FOR VALID RANGE              R4
         CH    R2,$SVROUT          WITHIN REMOTE RANGE               R4
         BH    USS                 TRY DESTINATION TABLE             R4
         IC    R2,$SVROUTM(R2)     PICK UP REMOTE ROUTING            R4
USCR     SRDL  R2,8                PUT REMOTE/UNIT INTO R3           R4
         LR    R2,R15              FIRST BYTE INTO R2                R4
         SRL   R2,32-8             NEXT TO REMOTE                    R4
         SLDL  R2,8                COMBINE THE TWO BYTES             R4
         B     4(0,R14)            RETURN                            R4
USUR     CH    R2,$SVNOUNT         WITHIN UNIT RANGE                 R4
         BH    USS                 TRY DESTINATION TABLE             R4
         LTR   R2,R2               RESULT ZERO                       R4
         BZR   R14                 ERROR EXIT                        R4
         B     4(0,R14)            RETURN                            R4
USBR     CLI   0(R1),C' '          BLANK                             R4
         BE    USLR                LOOP                              R4
         CLI   0(R1),C'0'          ZERO OR ABOVE                     R4
         BL    USS                 TRY DESTINATION TABLE             R4
         IC    R3,0(,R1)           PICK UP NUMERIC                   R4
         N     R3,=A(X'F')         PURIFY NUMBER                     R4
         MH    R2,=H'10'           MULTIPLY BY 10                    R4
         ALR   R2,R3               COMBINE DIGITS                    R4
         CH    R2,=H'255'          THIS TOO HIGH                     R4
         BNH   USLR                LOOP                              R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        SCAN REMOTE DESTINATION TABLE FOR MATCH                      *
*                                                                     *
***********************************************************************
USS      ALR   R1,R0               POINT TO END + 1                  R4
         SH    R1,=H'8'            THEN FIRST                        R4
         LM    R2,R3,$SVRDT        POINT TO FIRST AND LAST OF TABLE  R4
         USING RDTDSECT,R2                                           R4
USLT     CR    R2,R3               ABOVE END                         R4
         BHR   R14                 ERROR EXIT                        R4
         CLC   RDTNAME,0(R1)       SAME NAME                         R4
         BE    USFT                EXIT IF FOUND                     R4
         LA    R2,RDTSIZ(,R2)      POINT TO NEXT                     R4
         B     USLT                LOOP                              R4
USFT     LR    R0,R14              COPY DEFAULT FIRST BYTE           R4
         SRL   R0,32-8             SHIFT OUT UNDESIRABLE BITS        R4
         SLL   R0,8                ALIGN                             R4
         TM    RDTFLAG,RDTFLAGU+RDTFLAGR UXXX OR RXXX                R4
         BZ    USNT                SKIP IF NEITHER                   R4
         IC    R0,RDTRMTNO         SET REMOTE OR UNIT NUMBER         R4
         TM    RDTFLAG,RDTFLAGU    WAS THIS UNIT                     R4
         BO    USUT                SET UNIT                          R4
USNT     TM    RDTFLAG,RDTFLAGN    FIRST BYTE DESIRED                R4
         BZ    USOT                SKIP NEXT IF NOT                  R4
         ICM   R0,2,RDTSYS         SET FIRST BYTE                    R4
USOT     LR    R2,R0               COPY ANSWER                       R4
         ICM   R2,2,=XL8'0'        ZERO FIRST BYTE                   R4
         IC    R0,$SVROUTM(R2)     PICK UP REMOTE ROUTING            R4
         LR    R2,R0               SET ANSWER                        R4
         B     4(0,R14)            RETURN                            R4
USUT     ICM   R0,2,=XL8'0'        ZERO FIRST BYTE                   R4
         LR    R2,R0               SET ANSWER                        R4
         B     4(0,R14)            RETURN                            R4
         DROP  R2                                                    R4
         DROP  R15
         TITLE 'HASP $$POST SUBROUTINE'
***********************************************************************
*                                                                     *
*        $$POST - SUBROUTINE TO TELL HASP TO $POST A PCE AND          *
*        POST THE HASP TASK ( CROSS MEMORY ).                         *
*                                                                     *
* REGISTERS -                                                         *
*        R0    = MASK TO AND WITH $SVECF FIELD IF R1 = 0 - ALTERED    *
*        R1    = ADDRESS OF $$POST ELEMENT - ALTERED                  *
*        R2    = RETURN                                               *
*        R11   = ADDRESS OF SSVT - SET BY CALLER                      *
*        R14   = WORK, UNPREDICTABLE ON EXIT                          *
*        R15   = BASE - SET BY CALLER - ALTERED                       *
*                                                                     *
* NOTES -                                                             *
*                                                                     *
*        CALLER MUST QUEUE WORK REQUEST FOR PCE BEFORE $$POSTING.     *
*                                                                     *
*        THIS ROUTINE EXPECTS THAT THE HASP DISPATCHER WILL           *
*        TEST $SVPOSTW TO DETERMINE IF ANY PCE'S ARE TO BE            *
*        $POSTED ( RESETTING THE FLAG ). IF $POSTS ARE REQUIRED,      *
*        EACH PCE IS $POSTED AS REQUIRED. THE $SVECF FIELD FLAGS      *
*        ARE SET ON AT TESTING, BUT SPECIFIC PCE REQUESTS             *
*        MUST BE RESET BY THE $POSTED PROCESSOR BEFORE FINAL          *
*        TESTS FOR WORK ARE MADE.                                     *
*                                                                     *
***********************************************************************
$$POST   DS    0H
         USING *,R15
         LTR   R1,R1               IS R1 ZERO
         BNZ   SNPECF              IF NOT DO PCE POST
         L     R1,$SVECF           PICK UP OLD ECF
SNPECFL  OR    R0,R1               COMBINE REQUESTS
         CS    R1,R0,$SVECF        TRY TO POST BIT
         BNE   SNPECFL             LOOP IF NO POST
         B     SP                  POST HASP MAIN TASK
         SPACE 1                                                     R4
SNPECF   MVI   0(R1),X'FF'         SET ECF AS PENDING                R4
*                                  SET PENDING AT THIS POINT
SP       L     R14,$SVHECBA        ADDR OF ECB AND $$POST WORK FLAG  R4
         MVI   $SVPOSTW(R14),X'FF' SHOW POST REQUIRED                R4
         L     R0,=X'40000000'     PICK UP POST WORD
         L     R1,0(,R14)          GET CONTENTS OF HASP ECB          R4
SPTEST   LTR   R1,R1               TEST FOR WAITING
         BM    SPLONG              LONG POST IF WAITING
         CS    R1,R0,0(R14)        TRY QUICK POST                    R4
         BNZ   SPTEST              TEST AGAIN IF NO GO
         B     SNTHASP             SKIP LONG POST
SPLONG   CLC   PSAAOLD-PSA,$SVPOSTE+4  ARE WE IN HASP MEMORY...      R4
         BNE   SPLONGXM            DO CROSS MEMORY POST IF NOT
         LR    R1,R14              POST MAIN                         R4
         POST  (1)                  TASK                             R4
         L     R15,$SVHASP         GET HASP STATUS
         LTR   R15,R15             SET CONDITION CODE
         BR    R2                  RETURN
SPLONGXM TM    $SVSTUS,$SVSTUST    IF JES2 NOT UP,             @OZ63531
         BO    SNTHASP              RETURN AND SHOW CALLER.    @OZ63531
         POST  MF=(E,$SVPOSTE)     ELSE, POST HASP             @OZ63531
SNTHASP  L     R15,$SVHASP         SET HASP CONDITION
         LTR   R15,R15             SET CONDITION CODE
         BR    R2                  RETURN TO CALLER
         SPACE 1                                                     R4
         DROP  R13,R15                                               R4
         SPACE 1                                                     R4
         LTORG                                                       R4
         TITLE 'HASP VFL INSTRUCTION SIMULATION ROUTINE'             R4
***********************************************************************
*                                                                     *
*        $VFL  - VFL INSTRUCTION SIMULATION ROUTINE                   *
*                                                                     *
*        R0    - LENGTH OF FIELDS, UNPREDICTABLE ON EXIT              *
*        R1    - ADDRESS OF 'TO' FIELD, UNPREDICTABLE ON EXIT         *
*        R13   - SAVE AREA ADDRESS                                    *
*        R14   - RETURN ADDRESS                                       *
*        R15   - ADDRESS OF 'FROM' FIELD, UNPREDICTABLE ON EXIT       *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         CNOP  0,8                                                   R4
$$VFL    STM   R2,R4,28(R13)       SAVE WORK REGISTERS               R4
         SPACE 1                                                     R4
         BALR  R4,0                PROVIDE LOCAL                     R4
         USING *,R4                 ADDRESSABILITY                   R4
         SPACE 1                                                     R4
         LR    R3,R1               RELOAD 'TO' ADDRESS               R4
         SRL   R1,24               EXTRACT INSTRUCTION INDEX         R4
         LA    R2,256              PROVIDE CONSTANT FOR LOOP         R4
         SPACE 1                                                     R4
VFLCOMPR CLR   R0,R2               IF REMAINING LENGTH LE 256,       R4
         BNH   VFLLAST              BR FOR FINAL OPERATION           R4
         EX    R0,VFLINST1(R1)     OPERATE ON NEXT 256-BYTE SEGMENT  R4
         ALR   R3,R2               POINT TO NEXT                     R4
         ALR   R15,R2               'TO' AND 'FROM' SEGMENTS         R4
         SLR   R0,R2               REDUCE REMAINING FIELD LENGTH     R4
         B     VFLCOMPR             AND BR TO CONTINUE OPERATION     R4
         SPACE 1                                                     R4
         CNOP  0,8                                                   R4
VFLLAST  LR    R2,R0               RELOAD AND DECREMENT              R4
         BCTR  R2,R0                FOR FINAL EXECUTE                R4
         EX    R2,VFLINST2(R1)     OPERATE ON REMAINING BYTES        R4
         LM    R2,R4,28(R13)       RESTORE WORK REGISTERS            R4
         BR    R14                  AND RETURN                       R4
         SPACE 1                                                     R4
         DROP  R4                  KILL LOCAL ADDRESSABILITY         R4
         SPACE 1                                                     R4
VFLINST1 NC    0(256,R3),0(R15)    *** EXECUTE ONLY ***              R4
         OC    0(256,R3),0(R15)    *** EXECUTE ONLY ***              R4
         XC    0(256,R3),0(R15)    *** EXECUTE ONLY ***              R4
         SPACE 1                                                     R4
VFLINST2 NC    0(*-*,R3),0(R15)    *** EXECUTE ONLY ***              R4
         OC    0(*-*,R3),0(R15)    *** EXECUTE ONLY ***              R4
         XC    0(*-*,R3),0(R15)    *** EXECUTE ONLY ***              R4
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE - CELL CONTROL'        R4
***********************************************************************
*                                                                     *
*        $SVGCELL - SUBROUTINE TO GET A FREE CELL                     *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = ADDRESS OF SJB                                       *
*        R1    = ADDRESS OF TCB                                       *
*        R2    = WORK                                                 *
*        R3    = WORK                                                 *
*        R4    = LENGTH - ALTERED TO (LENGTH-1)/256                   *
*        R7    = WORK                                                 *
*        R11   = SSVT                                                 *
*        R14   = RETURN - (R14+0=ERROR, R14+4=OK)                     *
*        R15   = ENTRY BASE                                           *
*                                                                     *
***********************************************************************
         USING CCEDSECT,R7
TSGCELL  DS    0H
         USING *,R15
         BCTR  R4,0                CALCULATE
         SRA   R4,8                (B-1)/256= NUM 256 BYTE BLKS -1
         LA    R7,$SVCELLS-(CCECCE-CCEDSECT) POINT TO CELL 0
TSGCL    L     R7,CCECCE           POINT TO NEXT CELL CONTROL
         LTR   R7,R7               END
         BZR   R14                 EXIT WITH NOT FOUND
         CLM   R4,1,CCECSIZ        CHECK FOR SIZE OK
         BH    TSGCL               GET NEXT CELL IF REQUEST HIGH
         BLR   R14                 EXIT WITH NOT FOUND IF LOW
* TEST CELL FOR AVAILABLE
         LM    R2,R3,CCESJB+CCETCB-CCETCB PICK UP ALLOCATION WORDS
TSGCE    LTR   R2,R2               IS CELL AVAILABLE
         BNZ   TSGCL               LOOP IF NOT
         CDS   R2,R0,CCESJB        CLAIM
         BNZ   TSGCE               LOOP IF NOT CLAIMED
* CELL CLAIMED
         L     R1,CCECLOC-1        POINT TO LOCATION
         LA    R1,0(0,R1)          PURIFY
         ST    R7,0(0,R1)          SET LOCATION FOR FREEING
         B     4(0,R14)            RETURN
         EJECT
***********************************************************************
*                                                                     *
*        $SVGCPOL - SUBROUTINE TO TELL HASP MORE CELLS ARE NEEDED     *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = ADDRESS OF USER ECB                                  *
*        R1    = WORK                                                 *
*        R2    = WORK                                                 *
*        R3    = WORK                                                 *
*        R4    = (LENGTH-1)/256                                       *
*        R7    = WORK                                                 *
*        R11   = ADDRESS OF SSVT                                      *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* NOTES -                                                             *
*                                                                     *
*        AN ENQ USING $SVCENQ LIST MUST BE HELD BEFORE ENTRY.         *
*                                                                     *
***********************************************************************
TSGCPOL  DS    0H
         USING *,R15
         LR    R1,R0               POINT TO ECB
         MVI   0(R1),0             INSURE ZERO
         LR    R1,R11              SAVE SSVT BASE
         LR    R2,R12              SAVE USER BASE
         LR    R3,R13              SAVE SJB OR SAVE AREA BASE
         LR    R7,R14              SAVE RETURN
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=($SVCPOST,*-*,*-C
               *)
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=($SVCPOST,*-*,*-*)
         LR    R11,R1              PUT SSVT BASE BACK
         L     R1,PSAAOLD-PSA      PICK UP ASCB ADDRESS
         ST    R4,$SVCTREQ         SET CELL TYPE
         STM   R0,R1,$SVCPOST      SET ECB AND ASCB ADDRESSES
         LR    R1,R11              RESAVE SSVT BASE
         SETLOCK RELEASE,TYPE=CMS,RELATED=($SVCPOST,*-*,*-*)
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=($SVCPOST,*-*,*-*)
         LR    R11,R1              RESTORE
         LR    R12,R2              SAVED
         LR    R13,R3              REGISTERS
         LR    R3,R0               COPY ECB POINTER
         $$POST ELMT=$SVASYNC      TELL HASP
         LTR   R15,R15             IS HASP STILL UP
         BALR  R15,0               REESTABLISH BASE
         USING *,R15
         BNZ   TSGCPOLA            SKIP WAIT IF NOT
         WAIT  ECB=(R3)            WAIT FOR HASP
TSGCPOLA LR    R14,R7              RESTORE RETURN
         BR    R14                 EXIT
         EJECT
***********************************************************************
*                                                                     *
*        $SVFCELL - SUBROUTINE TO FREE A CELL BY ADDRESS              *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = WORK                                                 *
*        R1    = ADDRESS OF CELL STORAGE                              *
*        R2    = WORK                                                 *
*        R3    = WORK                                                 *
*        R7    = WORK                                                 *
*        R11   = SSVT                                                 *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
***********************************************************************
TSFCELL  DS    0H
         USING *,R15
         L     R7,0(0,R1)          POINT TO CELL CONTROL
         SLR   R0,R0               ZERO FOR SJB
         ST    R0,CCESJB           FREE THE CELL
         CLI   CCECSIZ,(512-1)/256 CHECK FOR LARGE CELL
         BNHR  R14                 EXIT
         MVI   $SVVARF,X'FF'       TELL HASP TO FREE ASAP
         BR    R14                 RETURN
* HASP WILL FREE ON NEXT ASYNC FUNCTION
         EJECT
***********************************************************************
*                                                                     *
*        $SVFCELA - SUBROUTINE TO FREE STORAGE BY SJB/TCB ADDRESS     *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = ADDRESS OF SJB                                       *
*        R1    = ADDRESS OF TCB OR ZERO                               *
*        R2    = WORK                                                 *
*        R3    = WORK                                                 *
*        R7    = WORK                                                 *
*        R11   = ADDRESS OF SSVT                                      *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE (HIGH BYTE ZERO ON ENTRY)                 *
*                                                                     *
***********************************************************************
TSFCELA  DS    0H
         USING *,R15
         LTR   R1,R1               TEST FOR TCB GIVEN
         BZ    *+8                 SKIP NSI IF NOT
         ICM   R15,8,=X'80'        TURN ON TCB REQUIRED FLAG
         SLR   R2,R2               SET UNALLOCATED INDICATOR
         LA    R7,$SVCELLS-(CCECCE-CCEDSECT) POINT TO HEADER
TSFCELAL L     R7,CCECCE           POINT TO NEXT CCE
         LTR   R7,R7               TEST FOR END
         BZR   R14                 EXIT IF END
         C     R0,CCESJB           DOES SJB MATCH
         BNE   TSFCELAL            LOOP IF NOT
         LTR   R15,R15             TEST FOR TCB MATCH REQUIRED
         BP    TSFCELLN            FREE CELL NOW IF NOT
         C     R1,CCETCB           TEST FOR TCB MATCH
         BNE   TSFCELAL            LOOP IF NOT
TSFCELLN ST    R2,CCESJB           UNALLOCATE CELL
         CLI   CCECSIZ,(512-1)/256 CHECK FOR LARGE CELL
         BNH   TSFCELAL            LOOP IF NOT
         MVI   $SVVARF,X'FF'       TELL HASP TO FREE ASAP
         B     TSFCELAL            LOOP
         EJECT
***********************************************************************
*                                                                     *
*        $SVGCMNS - SUBROUTINE TO GET CELLS AND CELL ELEMENTS         *
*                                                                     *
* REGISTERS -                                                         *
*                                                                     *
*        R0    = CLAIM CODE - WORK                                    *
*        R1    = WORK - ON EXIT CONTAINS ADDRESS OF STORAGE OR ZERO   *
*        R2    = WORK                                                 *
*        R3    = WORK                                                 *
*        R4    = (B-1)/256 = NUMBER OF 256 BYTE BLOCKS REQUIRED       *
*        R7    = WORK - ON EXIT CONTAINS ADDRESS OF CCE OR ZERO       *
*        R11   = ADDRESS OF SSVT                                      *
*        R14   = RETURN                                               *
*        R15   = ENTRY BASE                                           *
*                                                                     *
* NOTES -                                                             *
*                                                                     *
*        THIS ROUTINE IS ENTERED IN KEY 1 BY 'SAFE TASKS' WHEN A      *
*        CELL MUST BE GOTTEN WITHOUT WAITING FOR HASP.                *
*                                                                     *
***********************************************************************
TSGCMNS  DS    0H
         USING *,R15
         L     R2,=X'FF000000'     PICK UP FREE STORAGE INDICATION
         LA    R7,$SVCELLS-(CCECCE-CCEDSECT) POINT TO CELL HEAD
TSGCMNSL LR    R1,R7               SAVE PREVIOUS ELEMENT
         L     R7,CCECCE           POINT TO NEXT CCE
         LTR   R7,R7               CHECK FOR END
         BZ    TSGCMNSB            EXIT IF END
         CLM   R4,1,CCECSIZ        TEST CELL SIZE
         BH    TSGCMNSL            LOOP
         BL    TSGCMNSB            BUILD CCE IF BEYOND
         C     R2,CCESJB           TEST FOR FREE
         BNE   TSGCMNSL            LOOP
         L     R3,CCETCB           PICK UP SECOND WORD
         CDS   R2,R0,CCESJB        CLAIM
         BNE   TSGCMNS             LOOP IF NOT CLAIMED
TSGCMNSG LA    R0,1(0,R4)          (B-1)/256+1 = NUMBER 256 BYTE BLOCKS
         SLA   R0,8                STORAGE SIZE
         LR    R3,R14              COPY RETURN REGISTER
         GETMAIN RC,LV=(0),SP=231  GET STORAGE
         LTR   R15,R15             SET CONDITION CODES
         L     R15,$SVGCMNS        ESTABLISH BASE
         LR    R14,R3              ESTABLISH RETURN
         BNZ   TSGCMNSE            ERROR
         ST    R7,0(0,R1)          SET CCE LOCATION
         STCM  R1,7,CCECLOC        SET LOCATION
         BR    R14                 EXIT WITH R7 POINTING TO ELEMENT
TSGCMNSE ST    R2,CCESJB           FREE THE CCE
TSGCMNSX SLR   R7,R7               ZERO R7
         SLR   R1,R1               ZERO R1
         BR    R14                 EXIT
TSGCMNSB LR    R7,R1               BACK UP TO LAST CCE
TSGCMNSQ L     R1,$SVCELLF         POINT TO FIRST FREE QUEUE CCE
TSGCMNST LTR   R1,R1               TEST FOR PRESENT
         BZ    TSGCMNSC            EXIT IF MORE ARE REQUIRED
         L     R3,CCECCE-CCEDSECT(,R1) PICK UP CHAIN FIELD
         CS    R1,R3,$SVCELLF      REMOVE
         BNZ   TSGCMNST            LOOP IF NOT REMOVED
         STC   R4,CCECSIZ-CCEDSECT(,R1) SET SIZE INDICATION
         ST    R0,CCESJB-CCEDSECT(,R1) SET ID
TSGCMNSR L     R3,CCECCE           POINT TO NEXT
         ST    R3,CCECCE-CCEDSECT(,R1) SET INTO CURRENT
         CS    R3,R1,CCECCE        CHAIN CCE
         BNZ   TSGCMNSR            RETRY
         LR    R7,R1               POINT TO CURRENT
         B     TSGCMNSG            GET MAIN FOR ELEMENT
TSGCMNSC LR    R3,R14              SAVE RETURN
         LR    R2,R0               SAVE OWNER ID
         GETMAIN RC,LV=CCEL*64,SP=231 GET ROOM FOR 64 CCES
         LR    R0,R2               RESTORE OWNERSHIP ID
         LR    R14,R3              RESTORE RETURN
         LTR   R15,R15             SET CONDITION CODES
         L     R15,$SVGCMNS        PICK UP BASE
         BNZ   TSGCMNSX            ERROR EXIT
         LA    R3,64               SET NUMBER OF CCES IN BLOCK
TSGCMNSF L     R2,$SVCELLF         POINT TO OLD FREE QUEUE
         ST    R2,CCECCE-CCEDSECT(,R1) PUT OLD BEHIND
         CS    R2,R1,$SVCELLF      PUT NEW ON FRONT
         BNZ   *-8                 LOOP IF NO GO
         LA    R1,CCEL(,R1)        UP 1 CCE
         BCT   R3,TSGCMNSF         LOOP FOR ALL CCES
         L     R2,=X'FF000000'     RESTORE FREE ID
         B     TSGCMNSQ            LOOP
         DROP  R7
         DROP  R15
         LTORG
         TITLE '$PROLOG -- SUBSYSTEM FUNCTION ENTRY ROUTINE'
RSOX     EQU   R10                 DEFINE SSOB EXT BASE REG.
RSVT     EQU   R11                 DEFINE SSVT BASE REGISTER.
RSIB     EQU   R8                  DEFINE SSIB BASE REGISTER.
RSJB     EQU   R13                 DEFINE SJB BASE REGISTER.
$PROLOG  DS    0H
*
*              SAVE REGISTERS AND SET ADDRESSABILITY
*
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         BALR  R12,0               ESTABLISH BASE REGISTER.
SSPLBASE DS    0H
         USING *,R12               SET LOCAL ADDRESSABILITY.
*
*              SAVE ENTRY KEY AND SET KEY ZERO
*
         MODESET EXTKEY=ZERO,SAVEKEY=16(,R13),WORKREG=2  SET KEY.
*
*              SET UP REGISTERS ---
*              RSIB (R8)  POINTS TO SSIB
*              RSOX (R10) POINTS TO SSOB EXTENSION
*              RSVT (R11) POINTS TO SSVT
*
         USING SSOBEGIN,R1         SET MAIN SSOB ADDRESSABILITY.
         L     RSIB,SSOBSSIB       POINT R8 TO SSIB.
         USING SSIBEGIN,RSIB       SET ADDRESSABILITY FOR SSIB.
         L     RSOX,SSOBINDV       POINT R10 TO SSOB EXTENSION.
         LR    RSVT,R0             LET SSCVT BE ADDRESSED.
         L     RSVT,SSCTSSVT-SSCT(,RSVT)  POINT R11 TO SSVT.
         USING SSOBGN,RSOX         SET SSOB EXTENSION ADDRESSAB.
*
*              IF SJB LOCK NOT WANTED, SKIP LOCK LOGIC
*
         TM    0(R15),X'80'        IF NO LOCK WANTED,
         BZ    SSPLRET             GO ENTER SUBSYSTEM FUNCTION.
         CLI   1(R15),SSOBEOT      END-OF-TASK...                   R41
         BNE   SSPLNEOT            BR IF NO (OK)                    R41
         SPACE 1                                               @OZ66371
***********************************************************************
*                                                                     *
*              DETERMINE IF IT IS THE JES2 MAIN TASK THAT             *
*              IS ENDING, IF SO, SET FLAG IN SSVT                     *
*                                                                     *
***********************************************************************
         SPACE 1                                               @OZ66371
         ICM   R0,15,$SVHASP       TEST IF JES2 IS UP          @OZ66371
         BM    SSPLNJ2             BR IF NO                    @OZ66371
         CLC   SSETASCB,$SVPOSTE+4 TEST FOR JES2 ADDR SPACE    @OZ66371
         BNE   SSPLNJ2             BR IF NO                    @OZ66371
         L     R6,$SVDEB           GET DA DEB ADDRESS          @OZ66371
         CLC   SSETCBA+1(3),DEBTCBB-DEBBASIC(R6) JES2 TCB...   @OZ66371
         BNE   SSPLNJ2             BR IF NO                    @OZ66371
         MVC   $SVHASP,=F'-1'      SHOW JES2 ABENDED           @OZ66371
SSPLNJ2  L     R6,PSATOLD-PSA      POINT TO CURRENT TCB        @OZ66371
         USING TCB,R6              PROVIDE TCB ADDRESSABILITY       R41
         L     R6,TCBJSCB          POINT TO JSCB                    R41
         USING JSCB,R6             PROVIDE JSCB ADDRESSABILITY      R41
         L     R6,JSCBACT          POINT TO ACTIVE JSCB             R41
         L     R5,JSCBSSIB         POINT TO SSIB               @OZ57048
         ICM   R6,15,SSIBSUSE-SSIBEGIN(R5)  DOES SJB EXIST...  @OZ57048
         BZ    SSPLRET1            BR IF NO                         R41
         USING SJBDSECT,R6         PROVIDE SJB ADDRESSABILITY       R41
         L     R2,$SVHAVT          GET HAVT                    @OZ57048
         L     R3,PSAAOLD-PSA            GET ASID              @OZ57048
         LH    R3,ASCBASID-ASCBEGIN(,R3)  FOR INDEX            @OZ57048
         SLL   R3,2                        INTO HAVT           @OZ57048
         L     R4,0(R3,R2)         GET SJB FOR THIS ASID       @OZ57048
         LTR   R4,R4               SJB FOR THIS JES2...        @OZ57048
         BZ    SSPLRET1            BR IF NO                    @OZ57048
         CLC   SJBTCBP-SJBDSECT(,R4),PSATOLD-PSA  STC TCB...   @OZ57048
         BNE   SSPLNSTC            BR IF NO                    @OZ57048
         MVC   SSIBSUSE-SSIBEGIN(,R5),=XL4'00'  ZERO SJB ADDR  @OZ57048
         B     SSPLRET1            BR TO RETURN                @OZ57048
SSPLNSTC CLI   SJBXQFN1+1,SSOBJBSL JOB IN JOB SELECT...        @OZ57048
         BE    SSPLRET1            BR IF YES                        R41
         TM    SJBFLG1,SJB1XBMC    XBM CONTINUATION...              R41
         BZ    SSPSJBCK            BR IF NO (OK)                    R41
         SPACE 1                                                    R41
SSPLRET1 MODESET KEYADDR=16(,R13),WORKREG=2 SET CALLER'S KEY        R41
         RETURN (14,12),RC=0       RETURN TO CALLER                 R41
*
*              POINT TO SJB FROM EITHER CURRENT SSIB OR,
*              IF USER REQUIRES, FROM JSCB'S SSIB.
*
SSPLNEOT DS    0H                                                   R41
         L     R6,SSIBSUSE         GET SJB POINTER FROM SSIB.
         LTR   R6,R6               IF NON-ZERO POINTER,
         BNZ   SSPSJBCK            GO CHECK IT.
         TM    0(R15),X'60'        IF LOCK NOT =SDB OR =REQ,
         BZ    SSPNSDB             BRANCH.
         L     R6,PSATOLD-PSA      POINT TO CURRENT TCB.
         USING TCB,R6              GET ADDRESSABILITY.
         L     R6,TCBJSCB          POINT TO JSCB FROM TCB.
         USING JSCB,R6             GET ADDRESSABILITY.
         L     R6,JSCBACT          POINT TO ACTIVE JSCB             R41
         L     R6,JSCBSSIB         POINT TO SSIB FROM JSCB.
         DROP  RSIB                DROP OLD SSIB BASE.
         USING SSIBEGIN,R6         GET ADDRESSABILITY.
         L     R6,SSIBSUSE         POINT TO SJB FROM SSIB.
         USING SJBDSECT,R6         SET SJB ADDRESSABILITY.
         USING SSIBEGIN,RSIB       RESTORE SSIB ADDRESSABILITY.
SSPSJBCK DS    0H
         CLC   SJBSSNM,$SVSSNM     DONT LOCK IF THIS SJB       @OZ15844
         BNE   SSPNSDB              DOES NOT BELONG TO US      @OZ15844
         CLC   SJBID,=CL4'SJB'     IF SJB ID IS OKAY,
         BE    SSPACQL             GO GET THE LOCK.
*
*              IF SJB REQUIRED BUT NOT FOUND, ERROR
*
SSPNSDB  TM    0(R15),X'40'        IS LOCK=REQ...
         BZ    SSPLRET             IF NOT, ENTER SUBSYS FUNCTION.
         MODESET KEYADDR=16(,R13),WORKREG=2  ELSE SET CALLER KEY
         RETURN (14,12),RC=SSRTNSUP  AND GIVE CODE TO CALLER.
         DROP  R1                  DROP SSOB BASE.
         EJECT
*
*        FORMAT OF LOCK HEADER (SJBLOCKH) ---
*              +0 - TCB UNDER WHICH SJB IS LOCKED.  VALID ONLY
*                   IF +4 IS NONZERO.
*              +4 - ZERO MEANS SJB IS UNLOCKED.
*                 - MINUS MEANS SJB LOCKED, NO WAITERS.
*                 - PLUS - POINTS TO MOST-RECENT LOCK ELEMENT.
*
*        FORMAT OF LOCK ELEMENT ---
*              +0 - EVENT CONTROL BLOCK
*              +4 - ZERO IS INVALID
*                 - MINUS MEANS NO MORE WAITERS (ELEMENTS).
*                 - PLUS - POINTS TO NEXT WAITER.
*              +8 - ADDRESS OF WAITING CALLER'S TCB
*             +12 - VALIDATION ADDRESS FOR THIS WAITING RB     @OZ66394
*
SSPACQL  DS    0H
*                                                              @OZ40161
* ASYNCHRONOUS INTERRUPTS MUST BE PROHIBITED WHILE A USER OF   @OZ40161
* HASPSSSM HOLDS OR WAITS FOR THE SJB LOCK.  THIS RESTRICTION  @OZ40161
* PREVENTS AN INTERLOCK SITUATION FROM ARISING IF AN IRB       @OZ40161
* MAKES A SUBSYSTEM REQUEST WHILE A 'BURIED' PRB HOLDS THE     @OZ40161
* LOCK.  BIT TCBFX IN TCBFLGS1, WHICH PREVENTS ASYNCHRONOUS    @OZ40161
* INTERRUPTS, WILL BE RESET TO ITS INITIAL VALUE WHEN THE      @OZ40161
* LOCK IS RELINQUISHED.                                        @OZ40161
*                                                              @OZ40161
         L     R8,PSATOLD-PSA      GET CURRENT TCB             @OZ40161
         L     R1,24(,R13)         GET SSOB ADDRESS AND SAVE   @OZ58745
         USING TCB,R8              SET TCB ADDRESSABILITY      @OZ58745
         USING SSOBEGIN,R1         SET SSOB ADDRESSABILITY     @OZ58745
         LA    R2,SSPLIST          SET POINTER TO LIST AND     @OZ58745
         LA    R3,SSPLEN              NUMBER OF FUNCTIONS.     @OZ58745
SSPFNLP  CLC   SSOBFUNC+1(1),0(R2) DO NOT SET TCBFX IF         @OZ58745
         BE    SSPLK04                CURRENT FUNCTION IS      @OZ58745
         LA    R2,1(,R2)                 ON THE LIST .         @OZ58745
         BCT   R3,SSPFNLP          CHECK THE WHOLE LIST.       @OZ58745
         MVC   SSOBRETN(1),TCBFLGS1 SAVE TCBFLGS1 FOR EXIT     @OZ58745
         MVI   SSOBRETN+1,FF       SHOW TCB WAS CHANGED.       @OZ58745
         CLC   SJBJOBID(3),=C'TSU' TEST FOR TSO USER           @OZ57706
         BNE   SSPLK02             BR IF NOT                   @OZ57706
         TM    TCBTSFLG,TCBATT     IF ATTNS ALREADY DEFERRED,  @OZ57706
         BO    SSPLK02             DO NOT DO STAX.             @OZ57706
         MVI   SSOBRETN+2,FF       ELSE SET FLAG...            @OZ57706
         STAX  DEFER=YES              AND DEFER ATTENTIONS     @OZ57706
SSPLK02  OI    TCBFLGS1,TCBFX      ELSE FORBID INTERRUPTIONS   @OZ58745
         DROP  R8,R1               DROP TCB,SSOB ADDRESSABLE   @OZ58745
*
*              TRY GETTING LOCK BEFORE GETTING LOCK ELEMENT
*
SSPLK04  DS    0H                                              @OZ58745
         SLR   R0,R0               ZERO OUT
         LR    R1,R0               R0 AND R1.
         L     R2,PSATOLD-PSA      POINT R2 TO CURRENT TCB
         LNR   R3,R2               AND MAKE R3 MINUS.
         CDS   R0,R2,SJBLOCKH      IF SJB IS UNLOCKED,
         BNE   SSPLK06             (SJB IS LOCKED, GO WAIT)    @OZ40161
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
         B     SSPLK3              GO TO SERVICE NOW           @OZ40161
SSPLK06  DS    0H                                              @OZ40161
*
*              SJB IS ALREADY LOCKED.  SEE IF PURGE REQUIRED.
*
         LR    R3,R1               SET LOCK CHAINWORD IN R3.
         LR    R1,R0               SET R1=OWNING TCB.
         USING TCB,R1              SET TCB ADDRESSABILITY.
         CLR   R1,R2               IF LOCK HOLDER IS CURRENT TCB,
         BE    SSPLK10             PURGE LOCK HOLDER.
         L     R1,PSAAOLD-PSA      GET CURRENT ASCB            @OZ59924
         L     R1,ASCBASXB-ASCB(,R1) GET ASXB                  @OZ59924
         L     R1,ASXBFTCB-ASXB(,R1) GET FIRST TCB FOR LOOP    @OZ59924
         B     SSPLK08             GO CHECK FIRST TCB          @OZ59924
SSPLK07  ICM   R1,15,TCBTCB        IF NO MORE TCBS ON CHAIN,   @OZ59924
         BZ    SSPLK10               LOCKOWNER IS LONG GONE    @OZ59924
SSPLK08  CR    R1,R0               IF THIS TCB NOT LOCKOWNER,  @OZ59924
         BNE   SSPLK07              BRANCH TO CHECK NEXT TCB   @OZ59924
         TM    TCBFLGS5,TCBFC+TCBABWF  UNLESS HE'S DYING,           R41
         BNZ   SSPLK10             IF SO, PURGE LOCK           @OZ37207
         TM    TCBFLGS1,TCBFA      IF HOLDER NOT IN ABTERM,    @OZ37207
         BZ    SSPLK20             ...GO WAIT FOR LOCK         @OZ37207
SSPLK05  ICM   R1,15,TCBLTC        ELSE EXAMINE SUBTASK CHAIN  @OZ37207
         BZ    SSPLK20             ...NO MORE, WAIT FOR LOCK   @OZ37207
         CLR   R1,R2               IF CURRENT TCB NOT SUBTASK  @OZ37207
         BNE   SSPLK05             TRY NEXT SUBTASK            @OZ37207
         DROP  R1                  DROP TCB ADDRESSABILITY.
*
*              PURGE REQUIRED.  CALL SUBROUTINE TO PURGE.
*
SSPLK10  DS    0H
         LR    R2,R0               SET LOCK OWNER'S TCB IN R2.
         BAL   R4,$TESTLLK         GO PURGE THE LOCK HOLDER.
         BC    8+4,SSPLK04         NO NEW HOLDER, TRY AGAIN    @OZ40161
*
*              $TESTLLK FOUND AND POSTED A GOOD WAITER.
*              THEREFORE WE MUST GET A LOCK ELEMENT.
*
SSPLK20  DS    0H
         $GETMAIN RU,SP=241,LV=16,KEY=0  GET LOCK ELEMENT.
         LR    R5,R1               POINT R5 TO NEW ELEMENT.
         SPACE 2                                               @OZ19265
         CLI   SJBXQFN1+1,SSOBTERM IF NOT IN TERMINATION       @OZ19265
         BNE   SSPLK21             ...CONTINUE                 @OZ19265
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
         LA    R8,X'45'            SET ABORT INDICATOR,        @OZ40161
         B     SSPLK2              AND ESCAPE                  @OZ19265
         SPACE 2                                               @OZ19265
SSPLK21  DS    0H                                              @OZ19265
*
*              NOW WE HAVE AN ELEMENT.  TRY AGAIN FOR LOCK.
*
         L     R1,PSATOLD-PSA      GET CURRENT TCB ADDRESS     @OZ66394
         L     R1,TCBRBP-TCB(,R1)  AND POINTER TO CURRENT RB   @OZ66394
         ST    R1,12(,R5)          SHOW WHO IS WAITING         @OZ66394
         SLR   R0,R0               ZERO REGISTER 0.
         ST    R0,0(,R5)           ZERO OUT ECB.
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
SSPLK1   LR    R1,R0               ZERO REGISTER 1.
         L     R2,PSATOLD-PSA      POINT R2 TO CURRENT TCB.
         LNR   R3,R2               MAKE R3 MINUS.
         CDS   R0,R2,SJBLOCKH      IF SJB IS NOW UNLOCKED,
         LA    R8,0                SET GOOD POST CODE          @OZ19265
         BE    SSPLK2              GET LOCK AND FREE ELEMENT.
         STM   R1,R2,4(R5)         SET CHAIN, TCB IN ELEMENT.
         LR    R2,R0               SET UP CDS SO HDR+0 IS UNCHGD,
         LR    R3,R5               HDR+4 POINTS TO NEW ELEMENT.
         CDS   R0,R2,SJBLOCKH      TRY TO GET ON WAITING CHAIN.
*              THIS LINE DELETED BY APAR OZ66394               @OZ66394
         LA    R0,0                ZERO R0 BUT DON'T TOUCH CC.
         BNE   SSPLK1              IF CDS FAILED, REPEAT.
*
*              WE'RE NOW ON WAITING CHAIN.  ISSUE WAIT.
*
         WAIT  1,ECB=(R5)          WAIT FOR SJB LOCK.
*              THIS LINE DELETED BY APAR OZ66394               @OZ66394
         L     R8,0(,R5)           GET POST CODE               @OZ19265
         LA    R8,0(,R8)           ZERO HIGH ORDER BYTE        @OZ19265
*
*              AFTER WAIT, FREE THE LOCKING ELEMENT.
*
SSPLK2   DS    0H
         LTR   R8,R8               IF ZERO POST CODE,          @OZ58745
         BZ    SSPLK23               WE HAVE THE SJB LOCK      @OZ58745
         L     R7,PSATOLD-PSA      IF NOT, GET TCB ADDRESS,    @OZ58745
         L     R1,24(,R13)            AND SSOB ADDRESS         @OZ58745
         USING SSOBEGIN,R1         SET SSOB ADDRESSABILITY     @OZ58745
         USING TCB,R7              SET TCB ADDRESSABILITY      @OZ58745
         CLI   SSOBRETN+1,FF       IF TCB UNTOUCHED,           @OZ58745
         BNE   SSPLK23             SKIP TEST FOR RESET.        @OZ58745
         TM    SSOBRETN,TCBFX      IF TCBFX WAS ON AT ENTRY,   @OZ58745
         BO    SSPLK2A               DO NOT RESET IT.          @OZ58745
         NI    TCBFLGS1,FF-TCBFX   ELSE TURN OFF TCBFX.        @OZ58745
SSPLK2A  XC    SSOBRETN(2),SSOBRETN RESTORE SSOB RETRN FIELD   @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
         DROP  R7,R1                                           @OZ58745
SSPLK23  DS    0H                                              @OZ40161
         $FREMAIN RU,A=(R5),SP=241,LV=16,KEY=0  FREE ELEMENT.
         LTR   R8,R8               IF POSTED BY TERMINATION    @OZ19265
         BNZ   SSPLRET1            ...WAVE GOODBYE             @OZ19265
SSPLK3   DS    0H
*
*              WE HAVE SJB LOCK. ABORT INTERRUPTED FUNCTIONS
*
         SLR   R15,R15             ZERO USER BASE
         CH    R15,SJBXQFN1        DID WE INTERRUPT A FUNCTION
         BZ    SSPLNFUN            SKIP ABORT ROUTINES IF NO
         CLC   SJBXQFN1,=Y(SSOBRTRN) IS IT TOO BIG
         BH    SSPLNFUN            SKIP ABORT ROUTINES IF YES
         LR    R8,R6               COPY SJB POINTER
         LH    R15,SJBXQFN1        PICK UP FUNCTION
         ALR   R15,R15             DOUBLE
         L     R12,SSPLEOTB        POINT TO ABORT ROUTINE BASE
         LH    R15,HETTAB-HOSEOTB(R15,R12) PICK UP ENTRY
         BAL   R14,0(R15,R12)      ENTER ABORT ROUTINE
         USING *,R14
         L     R12,=A(SSPLBASE)    PICK UP OUR BASE
         DROP  R14
         LR    R6,R8               RETURN SJB POINTER
SSPLNFUN DS    0H
*
*              WE NOW OWN SJB LOCK.  CHAIN SAVE AREAS.
*
         LM    R15,R1,16(R13)      RESTORE REGS 15 THROUGH 1.
         USING SSOBEGIN,R1         SET SSOB ADDRESSABILITY.
         L     RSIB,SSOBSSIB       POINT TO SSIB
         LA    R15,0(,R15)         ZERO REGISTER 15 BYTE 0.
         ST    R6,8(,R13)          BACK-CHAIN SAVE AREA.
         ST    R13,4(,R6)          FORWARD-CHAIN SAVE AREA.
         LR    RSJB,R6             POINT R13 TO SJB SAVE AREA.
         DROP  R6                  DROP OLD SJB BASE.
         USING SJBDSECT,RSJB       USE NEW SJB BASE.
         O     R15,=X'80000000'    SHOW SJB LOCK HELD.
         MVC   SJBXQFN1,SSOBFUNC   SHOW FUNCTION IN PROCESS.
*
*              ENTER SUBSYSTEM FUNCTION HERE
*
SSPLRET  DS    0H
         LA    R12,4               GET CONSTANT FOUR.
         ALR   R12,R15             SET SUBSYS FUNC ADDRESSABILITY.
         BR    R12                 ENTER FUNCTION.
SSPLEOTB DC    0F'0',X'80',AL3(HOSEOTB) END OF TASK BASE
SSPLIST  DC    AL1(SSOBJBSL,SSOBTERM,SSOBEOM)                  @OZ58745
         DC    AL1(SSOBRTRN,SSOBRENQ)                          @OZ58745
SSPLEN   EQU   *-SSPLIST                                       @OZ58745
         TITLE '$EPILOG -- SUBSYSTEM FUNCTION EXIT ROUTINE'
$EPILOG  DS    0H
         USING *,R14               SET LOCAL ADDRESSABILITY.
*
*              SAVE RETURN CODE IN R0 SAVE AREA SLOT
*
         ST    R15,20(,R13)        SAVE RETURN CODE.
*
*              IF NO SJB LOCK, JUST RETURN TO CALLER.
*
         LTR   R12,R12             IF SJB LOCK, R12 IS NEGATIVE.
         BNM   SSENOLK             BRANCH IF NO LOCK HELD.
*
*              SJB LOCK.  SHOW NO FUNCTION ACTIVE.
*
         SLR   R0,R0               ZERO R0 AND MAKE
         STH   R0,SJBXQFN1         SJBXQFN1 ZERO.
*
*              SJB LOCK.  DECHAIN SJB SAVE AREA.  RE-SAVE
*              RETURN CODE.
*
         LR    R4,R13              USE R4 AS SJB POINTER.
         L     R13,4(,R13)         POINT TO ORIGINAL SAVE AREA.
         ST    R15,20(,R13)        RE-SAVE RETURN CODE AT R0.
         DROP  RSJB                SWITCH SJB ADDRESSABILITY
         USING SJBDSECT,R4         TO R4.
         L     R1,SJBFLOW          PICK UP OLD FLOW FLAGS.
SSELKA   TM    SJBTFFG,SJBTFFGP    TEST FOR PURGE ON.
         BO    SSELKB              GO TO PURGE IF YES.
         CS    R1,R0,SJBFLOW       ZERO FLAGS.
         BNZ   SSELKA              LOOP IF NOT SET.
         B     SSELKC              CONTINUE UNLOCK.
*
*              PURGE PSO FROM THE SJB
*
SSELKB   NI    SJBTFFG,255-SJBTFFGM RESET ECB MEANINGFULL.
         MVI   SJBTFLOW,X'0'       RESET QUEUE STATUS.
         ICM   R6,15,SJBPSOP       PICK UP PSO POINTER.
         BZ    SSELKC              EXIT IF EMPTY.
         LR    R13,R4              PUT SJB POINTER BACK IN R13.
         OI    PSOFLG2-PSODSECT(R6),SSSOCTRL SET TERMINATE PSO.
         LA    R8,SSOBSOUT         SET FUNCTION ID                  R41
         STH   R8,SJBXQFN1          IN CASE OF ABEND                R41
         ICM   R12,7,=AL3(PSOBASE) POINT TO PSO QUEUE ROUTINE BASE.
         BAL   R8,PSOQUEUE-PSOBASE(R12) CALL PSO QUEUEING ROUTINE.
         USING *,R8
         L     R14,=A($EPILOG)     GET BASE BACK.
         DROP  R8
         SLR   R0,R0               ZERO R0.
         LR    R4,R13              RESET R4 POINTER TO SJB.
         L     R13,4(,R13)         RESET R13 POINTER TO USER SAVE.
         STH   R0,SJBXQFN1         RESET FUNCTION INDICATOR.
SSELKC   ST    R0,SJBFLOW          RESET FLOW FLAGS.
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*
*              USE SUBROUTINE $TESTLLK TO RELEASE LOCK
*
         LR    R6,R4               POINT R6 TO SJB.
         LM    R2,R3,SJBLOCKH      SET R2, R3 EQUAL TO HEADER.
         BAL   R4,$TESTLLK         CALL $TESTLLK TO RELEASE LOCK.
         BC    4,$TESTLLK          IF CDS FAILED, TRY AGAIN.
         L     R1,24(,R13)         GET SSOB ADDRESS            @OZ58745
         L     R7,PSATOLD-PSA      GET CURRENT TCB             @OZ58745
         USING SSOBEGIN,R1         SET SSOB ADDRESSABILITY     @OZ58745
         USING TCB,R7              SET TCB ADDRESSABILITY      @OZ58745
         CLI   SSOBRETN+1,FF       IF TCB WAS UNTOUCHED,       @OZ58745
         BNE   SSENOLK             DON'T TEST FOR RESET        @OZ58745
         TM    SSOBRETN,TCBFX      IF TCBFX WAS ON AT ENTRY,   @OZ58745
         BO    SSELKD                DO NOT RESET IT NOW.      @OZ58745
         NI    TCBFLGS1,FF-TCBFX   ELSE TURN OFF TCBFX         @OZ58745
SSELKD   XC    SSOBRETN(2),SSOBRETN RESTORE SSOB RETRN FIELD   @OZ58745
         CLI   SSOBRETN+2,FF       TEST IF STAX WAS DONE       @OZ57706
         BNE   SSENOLK             BR IF NOT                   @OZ57706
         MVI   SSOBRETN+2,0        CLEAR SSOB IF SO            @OZ57706
         STAX  DEFER=NO            PERMIT ATTENTIONS NOW       @OZ57706
*
*              RESTORE CALLER KEY AND REGISTERS
*
SSENOLK  DS    0H
         MODESET KEYADDR=16(,R13),WORKREG=2  RESTORE CALLER KEY.
         LM    R14,R12,12(R13)     RESTORE CALLER REGISTERS.
*
*              IF NEGATIVE RETURN CODE, RETURN IT POSITIVE IN R15.
*              ELSE STORE IT IN SSOBRETN AND RETURN R15=0.
*
         LCR   R15,R0              IF NEGATIVE RETURN CODE,
         BPR   R14                 RETURN POSITIVE IN R15.
         ST    R0,SSOBRETN         ELSE RETURN IT IN SSOBRETN,
         SLR   R15,R15             ZERO REGISTER 15,
         BR    R14                 AND RETURN TO USER.
         DROP  ,                   DROP ALL ADDRESSABILITY.
         TITLE '$TESTLLK - PURGE HASP LOCAL LOCK'
*
*
*              PURGE SUBROUTINE FOR HASP LOCAL (SJB) LOCK
*
*
$TESTLLK DS    0H
         BALR  R15,0               SET LOCAL BASE.
         USING *,R15               SET LOCAL ADDRESSABILITY.
         USING SJBDSECT,R6         SET SJB ADDRESSABILITY.
* TEST LOCK HEADER CHAIN WORD TO DETERMINE ACTION
TLL10    DS    0H
         LTR   R3,R3               FIND SIGN OF CHAIN WORD.
* IF MINUS, NO WAITERS EXIST - CLEAR LOCK HEADER
         BM    TLL20               IF MINUS NO WAITERS EXIST.
* IF PLUS, GIVE THE LOCK TO THE FIRST LOCK ELEMENT
         BP    TLL30               IF PLUS R3 POINTS TO LOCK ELM.
* IF ZERO, NOBODY HOLDS THE LOCK
         BZR   R4                  LOCK AVAILABLE - RETURN CC=0.
         SPACE 3
* LOCK HEADER CHAIN WORD IS MINUS
TLL20    DS    0H
         SLR   R0,R0               ZERO R0
         LR    R1,R0               AND R1.
         CDS   R2,R0,SJBLOCKH      TRY TO RELEASE LOCK.
         BR    R4                  IF LOCK RELEASED RETURN CC=0,
*                                  ELSE RETURN CC=1.
         SPACE 3
* LOCK HEADER CHAIN WORD IS PLUS
TLL30    DS    0H
         L     R0,8(,R3)           POINT R0 TO WAITER'S TCB.
         L     R1,4(,R3)           GET NEW CHAIN WORD IN R1.
         CDS   R2,R0,SJBLOCKH      PASS LOCK TO THE WAITER.
         BNER  R4                  IF FAILURE RETURN CC=1.
* THE FOLLOWING TESTS DETERMINE WHETHER A POST WILL GIVE CONTROL
* TO THE WAITING FUNCTION.  THE WAITING FUNCTION WILL NOT
* RECEIVE CONTROL IF ITS TCB IS THE SAME AS THE CURRENT TCB OR IF
* ITS TCBABWF NON-DISPATCHABILITY FLAG IS ON.
         LR    R2,R0               POINT R2 TO THE NEW TCB.
         USING TCB,R2              SET TCB ADDRESSABILITY.
         CL    R2,PSATOLD-PSA      IS NEW TCB SAME AS CURRENT...
         BE    TLL40               IF SO, PURGE.
         TM    TCBFLGS5,TCBABWF    IS NEW TCB IN ABNORMAL WAIT...
         BO    TLL40               IF SO, PURGE.
         L     R5,TCBRBP           POINT TO CURRENT RB.
         USING RBBASIC,R5          SET RB ADDRESSABILITY.
TLL33    DS    0H
         TM    RBSTAB1,RBFTSVRB    IF PRB OR SVRB,
         BNM   TLL36               GO CHECK ITS PSW.
         TM    RBSTAB1,RBFTIRB     IF NOT IRB OR TIRB,
         BZ    TLL36               GO CHECK ITS PSW.
         TM    RBSTAB2,RBTCBNXT    IF TCB IS NEXT SET CC=3.
         L     R5,RBLINK           POINT TO NEXT RB OR TCB.
         BZ    TLL33               BRANCH TO CHECK RB.
         B     TLL40               BUT IF TCB, GO PURGE.
TLL36    DS    0H
*              THIS LINE DELETED BY APAR OZ66394               @OZ66394
         DROP  R5                  THERE GOES RB ADDRESSABILITY.
         CL    R5,12(,R3)          IS THIS RB THE WAITER...    @OZ66394
         BE    TLL50               GO POST ITS WAIT ELEM.      @OZ66394
*              THIS LINE DELETED BY APAR OZ66394               @OZ66394
*              THIS LINE DELETED BY APAR OZ66394               @OZ66394
         SPACE 1
* THE WAITING FUNCTION WILL NOT RECEIVE CONTROL.
* FREE THE STORAGE AND DO NEXT ITEM ON THE CHAIN.
TLL40    DS    0H
         LR    R0,R1               SET UP REGISTERS SO THAT
         LR    R1,R3               R2, R3 SAME AS SJBLOCKH
         LR    R3,R0               AND R1 IS LOCK ELEMENT TO FREE.
         FREEMAIN R,A=(1),SP=241,LV=16  FREE LOCK ELEMENT.
* RE-ESTABLISH R15 ADDRESSABILITY
         BALR  R15,0               SET TEMPORARY LOCAL BASE
         USING *,R15               AND ADDRESSABILITY.
         L     R15,=A(TLL10)       SET LOCAL BASE.
         USING TLL10,R15           SET LOCAL ADDRESSABILITY.
* GO TO THE TOP AGAIN TO GET RID OF ANY OTHER BAD GUYS
         B     TLL10               GO PROCESS NEXT WAITER.
         SPACE 1
* LOOKS LIKE WAITING FUNCTION WILL RECEIVE CONTROL.
* POST NEW LOCK OWNER AND RETURN CC=2 TO CALLER.
TLL50    DS    0H
         POST  0(,R3)              POST NEW LOCK OWNER.
         SLR   R0,R0               SET CONDITION CODE TO 2.
         BR    R4                  RETURN TO CALLER.
         DROP  R2,R6,R15           DROP TCB, SJB, LOCAL BASES.
         TITLE '$SDBINIT -- ROUTINE TO INITIALIZE AN SDB'
*
*        $SDBINIT - ROUTINE TO INITIALIZE AN SDB
*
*        INPUT ---
*              RSDB POINTS TO SDB TO INITIALIZE
*              RSJB POINTS TO SJB TO WHICH SDB BELONGS
*              RSVT POINTS TO HASP SSVT
*
*        OPERATION ---
*              1. THE SDB IS MADE ZERO UP TO SDBCCW1
*              2. SDBID AND SDBLENG ARE SET
*              3. SDBSJB AND SDBSDB ARE SET
*              4. SDBJKEY IS SET
*              4A. SDBOUTLM IS SET TO -1.
*              5. SDBPBFLM IS SET
*              6. THE IOB IS INITIALIZED ---
*                 A. FLG1 IS SET TO X'42'
*                 B. ECB IS POINTED TO SDBECB
*                 C. ST IS POINTED TO SDBCCW1
*                 D  DCB IS POINTED TO SJBDCB
*              7. THE CHANNEL PROGRAM IS INITIALIZED AS SHOWN
*                 IN THE DSECT.
*
*        FIELDS LEFT TO BE INITIALIZED ---
*              FLAGS - SDBFLG1, SDBFLG2
*              SDBPIOT,SDBPDDB,SDBDKEY,SDBAIOT
*              SDBDEB
*              SDBTRKF,SDBTRK, SDBTRKL
*              SDBPBF,SDBUBF
         EJECT
SSDBINIT DS    0H
$SDBINIT EQU   SSDBINIT
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             ESTABLISH
         USING $SDBINIT,R12        ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.          R4
         $GETMAIN RC,LV=SDBLNG,SP=230,KEY=5  GET MAIN FOR SDB.
         ST    R1,60(,R13)         SET R10 IN SAVE AREA.
         BNZ   SDIFAIL             BRANCH IF STORAGE NOT GOT.
         LR    RSDB,R1             ELSE SET SDB BASE REGISTER.
         USING SJBDSECT,RSJB
         USING SDBDSECT,RSDB
* CLEAR THE SDB UP TO SDBCCW1
         L     R4,0(,R1)           SAVE TCB ACROSS CLEAR.
         LR    R0,RSDB             POINT TO AREA
         LA    R1,SDBCCW1-SDBDSECT AND LENGTH TO CLEAR.
         SR    R3,R3               CLEAR TO ZEROES.
         MVCL  R0,R2               CLEAR THE SDB.
* SET SDB IDENTIFIER AND LENGTH
         MVC   SDBID(6),SDIID      SET ID AND LENGTH
* SAVE TCB POINTER TO BE USED FOR FREEMAIN OF SDB
         ST    R4,SDBTCBM          SAVE FREEMAIN TCB POINTER.
* SET SDBSJB AND SDBSDB
         ST    RSJB,SDBSJB         SET SDBSJB.
         MVC   SDBSDB,SJBSDB       CHAIN NEW SDB LIFO ONTO
         ST    RSDB,SJBSDB         THE SJB CHAIN OF SDBS.
         ST    R11,SDBSVT          SET POINTER TO HASP SSVT.
         OI    SDBTAB+(TABFLAG-TABDSECT),TABMINOR SETUP AS MINOR TAB R4
* SET SDBJKEY
         MVC   SDBJKEY,SJBJKEY     SET JOB KEY FROM SJB.
* SET SDBOUTLM TO -1
         L     R0,=F'-1'           SET OUTPUT LIMIT
         ST    R0,SDBOUTLM         TO -1.
* SET SDBPBFLM
         MVI   SDBPBFLM+1,20       SET PROT BUF LIM TO 20.
* INITIALIZE IOB
         MVI   SDBIFLG1,X'42'      SET IOBFLAG1,TO X'42'.
         LA    R15,SDBECB          POINT IOBECB
         ST    R15,SDBIECB         TO SDBECB AND
         MVI   0(R15),X'40'        SET ECB POSTED.
         LA    R0,SDBCCW1          POINT IOBSTART
         ST    R0,SDBIST           TO SDBCCW1.
         LA    R0,SJBDCB           POINT IOBDCBPT
         ST    R0,SDBIDCB          TO SJBDCB.
* INITIALIZE THE CHANNEL PROGRAM
         MVC   SDBCCW1(32),SDICCW1 SET SKELETON CHANNEL PROGRAM.
         LA    R0,SDBCCW1+5        POINT SDBCCW1
         STCM  R0,7,SDBCCW1+1      TO SECTOR NUMBER.
         LA    R0,SDBIFDAD+3       POINT SDBCCW2
         STCM  R0,7,SDBCCW2+1      TO SEARCH ARGUMENT.
         MVC   SDBCCW4+6(2),$SVBFSIZ  SET DATA LENGTH                R4
         LA    R0,SDBCCW2          POINT SDBCCW3
         STCM  R0,7,SDBCCW3+1      TO TIC TARGET ADDRESS.
* RETURN TO CALLER
         SR    R15,R15             SHOW $SDBINIT COMPLETED OKAY.
SDIFAIL  DS    0H
         ST    R15,16(,R13)        SET R15 IN SAVE AREA.
         LTR   R15,R15             TEST RETURN CODE.
         BZ    SDIEXIT             BRANCH IF SUCCESSFUL.
         $MID  357                 ELSE WRITE AN ERROR MESSAGE.
         WTO   '&MID.STORAGE UNAVAILABLE FOR SDB',ROUTCDE=10,          C
               DESC=6
SDIEXIT  DS    0H
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         LTR   R15,R15             SET CC ACCORDING TO R15.
         BR    R14                 RETURN TO CALLER.
         DROP  ,                   DROP ALL BASES.
*
*              DATA AREAS
*
SDIID    DC    0CL6' ',CL4'SDB',AL2(SDBLNG)  SDB IDENTIFIER
SDICCW1  CCW   X'03',0,X'60',1     SKELETON NO-OP/SET-SECTOR
         CCW   X'31',0,X'60',5     SKELETON SEARCH-ID-EQUAL
         DC    FS24'8,0'           SKELETON TIC
         CCW   X'06',0,0,*-*       SKELETON READ                     R4
         TITLE '$SJBINIT -- ROUTINE TO INITIALIZE AN SJB'
*
*        $SJBINIT - ROUTINE TO INITIALIZE AN SJB
*
*        INPUT ---
*              RSJB POINTS TO SJB TO INITIALIZE
*
*        OPERATION ---
*              1. THE SJB IS MADE ZERO UP TO SJBCCW1
*              2. SJBID AND SJBLENG ARE SET
*              3. SJBECBP, SJBASCBP, AND SJBERRET ARE SET
*              4. SJBLOCKH IS MADE ZERO, AND ECBP, ASCBP, AND ERRET
*                 ARE SET UP FOR CROSS-MEMORY POSTING.
*              5. THE IOB IS INITIALIZED
*                 A. FLG1 IS SET TO X'42'
*                 B. ECB IS POINTED TO SJBECB
*                 C. ST IS POINTED TO SJBCCW1
*                 D. DCB IS POINTED TO SJBDCB
*              6. THE CHANNEL PROGRAM IS INITIALIZED AS SHOWN
*                 IN THE DSECT
*              7. THE ACBS, DEBS, AND RPL ARE INITIALIZED
*                 AS SHOWN IN THE DSECT
*              8. THE HASP DCB AND DEB ARE MOVED TO SJBDCB AND SJBDEB
*                 AND ADCONS IN THEM ARE SET CORRECTLY.  DEBAVT IS
*                 POINTED TO HAMAVT.
*
*        FIELDS LEFT TO BE INITIALIZED ---
*              SJBJCT
*              SJBJCTTR
*              SJBIOT
*              SJBPIT, SJBPATID, SJBCLAS, SJBJQE
*              SJBXBSDB, SJBXBJNM
*              SJBJOBID
*              SJBJOBNM
         EJECT
SSJBINIT DS    0H
$SJBINIT EQU   SSJBINIT
         BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
         LR    R6,R14              SAVE RETURN ADDRESS.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         SLR   R1,R1                           COMPUTE               R4
         IC    R1,$SVNUMDA                      STORAGE              R4
         SLL   R1,4                              REQUIRED FOR        R4
         LA    R0,SJBDEB-SJBDSECT+4*(8+4*1)(,R1)  SJB                R4
        $GETMAIN RC,LV=(R0),SP=241,KEY=1  GET MAIN FOR SJB           R4
         BNZ   SJIERR              BRANCH IF GETMAIN FAILED.
         LR    RSJB,R1             SET THE SJB BASE REGISTER.
         USING SJBDSECT,RSJB
* CLEAR SJB FROM SJBFLG1 TO SJBCCW1                                  R4
         LA    R0,SJBFLG1          SET STARTING ADDRESS              R4
         LA    R1,SJBCCW1-SJBFLG1   AND LENGTH FOR CLEAR             R4
         MVCL  R0,R14              R15 MUST BE 0.  CLEAR SJB.
* SET SJB IDENTIFIER AND SJB LENGTH                                 R41
         MVC   SJBID,=CL4'SJB'     SET SJB ID                        R4
         MVC   SJBLENG,4(RSJB)     MOVE LENGTH SET BY HGFMAIN       R41
         MVC   SJBSSNM,$SVSSNM     SET OWNING SUBSYSTEM NAME   @OZ15844
* SET SJBECBP, SJBASCBP, SJBTCBP, AND SJBERRET                 @OZ53355
         LA    R0,SJBECB           POINT ECB POINTER
         ST    R0,SJBECBP          TO ECB.
         L     R1,CVTPTR           POINT TO CVT.
         LA    R0,CVTBRET-CVT(,R1) POINT ERRET TO
         ST    R0,SJBERRET         'BR 14'.
         L     R1,PSATOLD-PSA      GET CURRENT TCB POINTER     @OZ53355
         ST    R1,SJBTCBP          STORE IT IN THE SJB         @OZ53355
         L     R1,PSAAOLD-PSA      GET CURRENT ASCB POINTER.
         ST    R1,SJBASCBP         STORE IT IN THE SJB.
         LH    R1,ASCBASID-ASCB(,R1)  GET CURRENT ASID.
         STH   R1,SJBASID          STORE IT IN THE SJB.
* ADD SJB TO THE HASP ADDRESS SPACE VECTOR TABLE (HAVT)
         ALR   R1,R1               MULTIPLY ASID
         ALR   R1,R1               BY FOUR.
         AL    R1,$SVHAVT          POINT TO ENTRY IN HAVT.
         L     R2,0(,R1)           GET FIRST SJB               @OZ55219
         LTR   R2,R2               IS THERE ONE...             @OZ55219
         BZ    SJI05               NO, CONTINUE                @OZ55219
         TM    SJBFLG2-SJBDSECT(R2),SJB2INIT  IS IT INIT...    @OZ55219
         BZ    SJI05               NO, CONTINUE                @OZ55219
         OI    SJBLKFG-SJBDSECT(R2),SJBPRIM  SET PRIMARY INIT  @OZ56375
SJI05    DS    0H                                              @OZ55219
         SL    R1,=A(SJBSJB-SJBDSECT)  PREPARE TO RUN CHAIN.
         DROP  RSJB                DROP RSJB AS SJB BASE.
         USING SJBDSECT,R1         SET SJB BASE TO R1.
SJI10    DS    0H
         LR    R2,R1               SAVE PREVIOUS SJB POINTER.
         L     R1,SJBSJB           POINT TO NEXT SJB.
         LTR   R1,R1               ARE WE AT CHAIN END...
         BNZ   SJI10               IF NOT, LOOP TILL WE ARE.
         USING SJBDSECT,R2         SET SJB BASE TO R2 (PREV).
         ST    RSJB,SJBSJB         CHAIN SJB ON HAVT SLOT FIFO.
         DROP  R1,R2               DROP TWO SJB BASES.
         USING SJBDSECT,RSJB       SET SJB BASE TO RSJB.
* INITIALIZE THE IOB
         MVI   SJBIFLG1,X'42'      SET IOBFLAG1 TO X'42'.
         LA    R0,SJBECB           POINT IOBECB
         ST    R0,SJBIECB          TO SJBECB.
         LA    R0,SJBCCW1          POINT IOBSTART
         ST    R0,SJBIST           TO SJBCCW1.
         LA    R0,SJBDCB           POINT IOBDCBPT
         ST    R0,SJBIDCB          TO SJBDCB.
* INITIALIZE THE CHANNEL PROGRAM
         MVC   SJBCCW1(32),SJICCW1 SET SKELETON CHANNEL PROGRAM.
         LA    R0,SJBCCW1+5        POINT SJBCCW1
         STCM  R0,7,SJBCCW1+1      TO SECTOR NUMBER.
         LA    R0,SJBIFDAD+3       POINT SJBCCW2
         STCM  R0,7,SJBCCW2+1      TO SEARCH ARGUMENT.
         MVC   SJBCCW4+6(2),$SVBFSIZ  SET DATA LENGTH                R4
         LA    R0,SJBCCW2          POINT SJBCCW3
         STCM  R0,7,SJBCCW3+1      TO TIC TARGET ADDRESS.
* INITIALIZE ACBS, DEBS, RPL
         MVC   SJBLACB(SJBIACB-SJBLACB),SJILACB  SET LOG SKELETONS.
         USING IFGACB,R1           USE THE ACB DSECT.
         USING DEBBASIC,R2         USE THE DEB DSECT.
         LA    R1,SJBLACB          GET ADDRESS OF LOG ACB.
         LA    R2,SJBLDEB          GET ADDRESS OF LOG DEB.
         ST    R1,DEBDCBAD         POINT DEB TO ACB.
         MVI   DEBDEBID,X'0F'      SET DEB ID FIELD.
         ST    R2,ACBDEB-1         POINT ACB TO DEB.
         LA    R2,SJBLRPL          POINT HASP JOB LOG RPL
         ST    R1,RPLDACB-IFGRPL(,R2)  TO ACB.
         MVC   ACBINRTN,=A(HAMNULL)  ALLOW EARLY LOG USE.
         MVC   SJBIACB(SJBMACB-SJBIACB),SJIIACB  SET INT TXT SKELETON.
         LA    R1,SJBIACB          GET ADDRESS OF INTTXT ACB.
         LA    R2,SJBIDEB          GET ADDRESS OF INTTXT DEB.
         ST    R1,DEBDCBAD         POINT DEB TO ACB.
         MVI   DEBDEBID,X'0F'      SET DEB ID FIELD.
         ST    R2,ACBDEB-1         POINT ACB TO DEB.
         MVC   SJBMACB(SJBJACB-SJBMACB),SJIMACB  SET MSGS SKELETON.
         LA    R1,SJBMACB          GET ADDRESS OF MESSAGE ACB.
         LA    R2,SJBMDEB          GET ADDRESS OF MESSAGE DEB.
         ST    R1,DEBDCBAD         POINT DEB TO ACB.
         MVI   DEBDEBID,X'0F'      SET DEB ID FIELD.
         ST    R2,ACBDEB-1         POINT ACB TO DEB.
         MVC   SJBJACB(SJBDCB+40-SJBJACB),SJIJACB  SET JOURNAL SKEL.
         LA    R1,SJBJACB          GET ADDRESS OF JOURNAL ACB.
         LA    R2,SJBJDEB          GET ADDRESS OF JOURNAL DEB.
         ST    R1,DEBDCBAD         POINT DEB TO ACB.
         MVI   DEBDEBID,X'0F'      SET DEB ID FIELD.
         ST    R2,ACBDEB-1         POINT ACB TO DEB.
* INITIALIZE SPOOL DCB AND DEB
         MVC   SJBDCB+40(12),$SVDCB+40  SET SKELETON DCB IN SJB      R4
         SLR   R1,R1               SET                               R4
         IC    R1,$SVNUMDA          SKELETON                         R4
         SLL   R1,4                  DIRECT                          R4
         LA    R1,32+16(,R1)          ACCESS                         R4
         L     R14,$SVDEB              DEB                           R4
         LA    R0,SJBDEB                IN                           R4
         LR    R15,R1                    NEW                         R4
         MVCL  R0,R14                     SJB                        R4
         LA    R1,SJBDEB           GET ADR OF HASP DEB.
         LA    R2,SJBDCB           GET ADR OF HASP DCB.
         USING DEBBASIC,R1         USE DEB DSECT.
         USING DCBDSECT,R2         USE DCB DSECT.
         L     R0,=A(HAMAVT)       SET APPENDAGE VECTOR
         STCM  R0,7,DEBAPPAD+1     TABLE ADDRESS IN DEB.
         ST    R1,DCBDEBAD         SET ADR OF DEB IN DCB.
         ST    R2,DEBDCBAD         SET ADR OF DCB IN DEB.
         MVI   DEBDEBID,X'0F'      SET DEB IDENTIFIER.
* RETURN TO CALLER.
         SR    R15,R15             SHOW NORMAL COMPLETION.
         BR    R6                  RETURN TO CALLER.
*
*
*              ERROR - STORAGE UNAVAILABLE FOR SJB
*
*
SJIERR   DS    0H
         $MID  362                 SET HASP ID FOR MESSAGE.
         WTO   '&MID.STORAGE UNAVAILABLE FOR SJB',ROUTCDE=10,          C
               DESC=6
         LA    R15,4               SET R15 NONZERO.
         LTR   R15,R15             SET CONDITION CODE NONZERO.
         BR    R6                  RETURN TO CALLER.
         DROP  R1,R2,R12,RSJB      DROP BASES.
*
*              DATA AREAS
*
SJICCW1  CCW   X'03',0,X'60',1     SKELETON NO-OP/SET-SECTOR
         CCW   X'31',0,X'60',5     SKELETON SEARCH-ID-EQUAL
         CCW   X'08',0,0,1         SKELETON TIC.
         CCW   X'06',0,0,*-*       SKELETON READ                     R4
SJILACB  ACB   MACRF=(ADR,SEQ,OUT)
         DC    8A(0)               DEB FOR LOG
         RPL   ACB=0
SJIIACB  ACB   MACRF=(ADR,SEQ,IN)
         DC    8A(0)
SJIMACB  ACB   MACRF=(ADR,SEQ,OUT)
         DC    8A(0)
SJIJACB  ACB   MACRF=(ADR,SEQ,DIR,IN,OUT)
         DC    8A(0)
         TITLE '$SVJLOK - ACQUIRE JOB COMMUNICATION QUEUES LOCK'
*
*
*                       $ S V J L O K
*
*
*        ACQUIRE THE JOB COMMUNICATION QUEUES LOCK.  THIS LOCK
*        MUST BE OBTAINED BY ANYBODY MANIPULATING THE $SVJ QUEUES
*        - $SVJPCLS, $SVJPNUM, $SVJXCLS, $SVJXNUM, $SVJTERM,
*        $SVJRENQ.  THIS LOCK MUST BE PROCURED BEFORE REMOVING
*        AN SJB FROM A QUEUE AND MUST NOT BE RELEASED UNTIL THE
*        SJB HAS BEEN RETURNED TO A QUEUE IF APPROPRIATE (FOR
*        REMOVAL FROM $SVJTERM OR $SVJRENQ ONLY, AN SJB MAY BE
*        LEFT OFF ALL QUEUES).
*
*        THE LOCK HEADER IS $SVJLOCK.  ITS FORMAT IS --
*        +0 - ASCB UNDER WHICH RESOURCE IS HELD.  VALID ONLY IF
*              +4 IS NONZERO - OTHERWISE THIS FULLWORD MUST BE
*              ZERO.
*        +4 - ZERO MEANS RESOURCE IS UNLOCKED.
*              MINUS MEANS RESOURCE IS HELD BUT NO WAITERS EXIST.
*              PLUS - POINTS TO MOST-RECENT WAIT ELEMENT
*
*        THE WAIT ELEMENT IS A 32-BYTE CHUNK OF SP241 OR A PRE-
*        ASSEMBLED AREA IN HASPXEQ, FORMATTED AS FOLLOWS ---
*        +0  - IF IN HASPXEQ, CHARACTERS 'HASP'
*              OTHERWISE USED AS ECB
*        +4  - CHAIN WORD AS ABOVE IN $SVJLOCK
*        +8  - ASCB POINTER AS ABOVE
*        +12 - ECB POINTER FOR XMPOST
*        +16 - ASCB POINTER FOR XMPOST
*        +20 - ERROR RETURN ADDRESS FOR XMPOST
*        NOTE - +16 AND +20 ARE SET BY UNLOCK ROUTINE
*        +24 - IF IN HASPXEQ, UNUSED
*              OTHERWISE SJB POINTER
*
*
*
*              ATTEMPT TO LOCK WITHOUT GETMAIN
*
*
$SVJLOK  DS    0H
         SLR   R0,R0               ASSUME LOCKING DOUBLEWORD
         LR    R1,R0               IS ZERO.
         L     R2,PSAAOLD-PSA      WE'LL CHANGE IT TO
         LNR   R3,R2               ASCB PTR AND MINUS NUMBER.
         CDS   R0,R2,$SVJLOCK      ACQUIRE THE LOCK.
         BER   R14                 RETURN IF SUCCESS.
*
*
*              GET MAIN STORAGE FOR A LOCK ELEMENT
*
*
         STM   R14,R12,12(R13)     SAVE REGISTERS IN SJB.
         BALR  R12,0               ESTABLISH ADDRESSABILITY
         USING *,R12               AND TELL THE ASSEMBLER.
         $GETMAIN RU,SP=241,LV=32,KEY=1  GET A LOCK ELEMENT.
         LR    R4,R1               SAVE STORAGE ADDRESS IN R4.
         MVI   0(R1),0             CLEAR THE ECB (+0).
         ST    R1,12(,R1)          SET ECB POINTER (+12).
         ST    RSJB,24(,R1)        SET SJB POINTER (+24).
*
*
*              NOW WE HAVE AN ELEMENT.  TRY AGAIN FOR LOCK
*
*
SVJL10   DS    0H
         SLR   R0,R0               ASSUME AS ABOVE THAT
         LR    R1,R0               LOCK IS NOT HELD.
         L     R2,PSAAOLD-PSA      POINT R2 TO ASCB.
         LNR   R3,R2               MAKE R3 NEGATIVE.
         CDS   R0,R2,$SVJLOCK      TRY AGAIN TO GET LOCK.
         BE    SVJL20              IF SUCCESS, FREE WAIT ELEMENT.
*
*              CAN'T GET LOCK NOW - QUEUE WAIT ELEMENT
*
         STM   R1,R2,4(R4)         SET CHAIN (+4), CUR ASCB (+8).
         LR    R2,R0               USE OWNING ASCB POINTER.
         LR    R3,R4               SET TENTATIVE CHAIN POINTER.
         CDS   R0,R2,$SVJLOCK      TRY TO QUEUE WAIT ELEMENT.
         BNE   SVJL10              BRANCH IF UNSUCCESSFUL.
*
*              WAIT ELEMENT IS QUEUED - WAIT FOR RESOURCE
*
         WAIT  1,ECB=(R4)          WAIT FOR POST.
*
*
*              UPON BEING POSTED, FREE THE WAIT ELEMENT
*
*
SVJL20   DS    0H
         $FREMAIN RU,A=(R4),SP=241,LV=32,KEY=1  FREE LOCK ELEMENT.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
*
*
*              WE HOLD THE RESOURCE.  RETURN TO ITS USER.
*
*
         DROP  R12                 DROP LOCAL ADDRESSABILITY.
         BR    R14                 RETURN TO RESOURCE USER.
         TITLE '$SVJUNLK - RELEASE JOB COMMUNICATION QUEUES LOCK'
*
*
*                       $ S V J U N L K
*
*
* SEE ABOVE FOR DESCRIPTION OF HEADER AND WAIT ELEMENT FORMATS
*
*
*              INSPECT THE LOCK'S CURRENT STATE
*
*
$SVJUNLK DS    0H
         USING *,R15               SET LOCAL ADDRESSABILITY.
         LM    R2,R3,$SVJLOCK      GET LOCK HEADER CONTENTS.
SVJU10   DS    0H
         LTR   R3,R3               TEST CURRENT LOCK STATE.
         BP    SVJU20              BRANCH IF SOMEONE WAITING.
* IF ZERO CHAIN WORD, LOCK RECOVERY - MAKE THE LOCK ZERO.
*
*
*              NO WAITERS EXIST.  RELEASE LOCK AND RETURN.
*
*
         SLR   R0,R0               PREPARE TO ZERO OUT
         LR    R1,R0               THE LOCK HEADER.
         CDS   R2,R0,$SVJLOCK      IF STILL NO WAITERS, UNLOCK.
         BER   R14                 RETURN IF SUCCESSFUL.
         B     SVJU10              ELSE TEST LOCK STATE AGAIN.
*
*
*              SOMEBODY'S WAITING ON THE LOCK.  GIVE HIM THE
*              LOCK AND POST HIM.
*
*
SVJU20   DS    0H
         L     R0,8(,R3)           R0 = NEW OWNER'S ASCB.
         L     R1,4(,R3)           R1 = NEW CHAIN WORD.
         CDS   R2,R0,$SVJLOCK      SWITCH LOCK TO NEW OWNER.
         BNE   SVJU10              IF FAILURE, TEST STATE AGAIN.
         CLC   $SVSSNM,0(R3)       IS LOCK ELEMENT HASP'S...
         BE    SVJU30              BRANCH IF SO
* POST NON-HASP LOCK ELEMENT OWNER
         ST    R0,16(,R3)          ELSE COMPLETE POST ARG LIST
         L     R4,CVTPTR           BY SETTING ASCB POINTER
         LA    R4,CVTBRET-CVT(,R4) AND ERROR RETURN
         ST    R4,20(,R3)          (POINT TO X'07FE' IN CVT).
         POST  MF=(E,12(,R3))      POST THE NEW LOCK OWNER.
         BR    R14                 RETURN TO CALLER.
* POST HASP LOCK ELEMENT OWNER
SVJU30   DS    0H
         LR    R4,R14              SAVE RETURN ADDRESS               R4
         $$POST ELMT=$SVJOB        POST HASP FOR JOB.
         LR    R14,R4              RESTORE RETURN ADDRESS            R4
         BR    R14                 RETURN TO CALLER.
         TITLE '$SJBRQ - MOVE SJB TO A DIFFERENT $SVJ QUEUE'
*
*
*                       $ S J B R Q
*
*
*        REQUIREMENTS -
*        JOB COMMUNICATION QUEUES LOCK MUST BE HELD
*        SJBQUEUE MUST POINT TO HEADER OF QUEUE CURRENTLY CON-
*              TAINING SJB.  ZERO MEANS SJB IS NOT ON ANY QUEUE.
*        R1 MUST POINT TO HEADER OF QUEUE NEWLY TO CONTAIN SJB.
*              IF ZERO, SJB WILL NOT BE RE-ENQUEUED.
*        RSJB MUST POINT TO AN SJB.
*
*
*              REMOVE SJB FROM ITS CURRENT QUEUE
*
*
$SJBRQ   DS    0H
         USING *,R15               SET LOCAL ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB BASE TO RSJB.
         L     R2,SJBQUEUE         GET QUEUE HDR POINTER INTO R2.
         LTR   R2,R2               TEST IT.
         BZ    SJBR20              IF ZERO, SKIP DEQUEUE.
         SL    R2,=A(SJBXQCHN-SJBDSECT)  ELSE PREPARE TO CHAIN.
         DROP  RSJB                DROP RSJB AS SJB BASE.
         USING SJBDSECT,R2         SET SJB BASE TO R2.
SJBR10   DS    0H
         LTR   R3,R2               SAVE AND TEST PREV SJB PTR.
         BZ    SJBR20              IF ZERO, SJB WASN'T ON QUEUE.
         L     R2,SJBXQCHN         POINT R2 TO NEXT SJB.
         CLR   R2,RSJB             IS THIS THE ONE TO DEQUEUE...
         BNE   SJBR10              IF NOT, LOOP ONWARDS.
         L     R0,SJBXQCHN         PICK UP NEXT PTR FROM THIS.
         USING SJBDSECT,R3         SET SJB BASE TO R3 (PREV).
         ST    R0,SJBXQCHN         SET NEXT PTR IN PREV.
         DROP  R2,R3               DROP TWO SJB BASES.
*
*
*              ADD SJB LIFO TO THE NEW QUEUE
*
*
SJBR20   DS    0H
         USING SJBDSECT,RSJB       SET SJB BASE TO RSJB.
         ST    R1,SJBQUEUE         SET QUEUE HEADER PTR IN SJB.
         LTR   R1,R1               IF NO QUEUE HEADER,
         BZR   R14                 RETURN.
         L     R0,0(,R1)           GET CUR Q HEADER VALUE.
         ST    R0,SJBXQCHN         STORE IT IN SJB CHAIN WORD.
         ST    RSJB,0(,R1)         STORE SJB ADR IN Q HEADER.
         BR    R14                 RETURN.
         DROP  RSJB                DROP SJB BASE.
         TITLE '$SJBFREE - RELEASE SJB STORAGE'
*
*
*                       $ S J B F R E E
*
*
*        REQUIREMENTS -
*        SJB LOCK MUST BE HELD (HEADER SJBLOCKH)
*        SVJ LOCK MUST NOT BE HELD (HEADER $SVJLOCK)
*
*
*
*              REMOVE SJB FROM $SVHAVT
*
*
$SJBFREE DS    0H
         USING *,R15               SET LOCAL ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB BASE TO RSJB.
         LR    R5,R15              SAVE BASE ACROSS SVC        @OZ19265
         LR    R4,R14              SAVE RETURN ACROSS SVC      @OZ19265
         SPACE 1                                               @OZ19265
*        POST ANYONE ON THE SJBLOCKH CHAIN WITH X'45'          @OZ19265
         SPACE 1                                               @OZ19265
SJBF01   DS    0H                                              @OZ19265
         TM    SJBFLG2,SJB2EOM     IF ENTRY FROM END OF MEM    @OZ40161
         BO    SJBF09              BRANCH AROUND               @OZ58745
         L     R1,SJBLOCKH+4       GET FIRST WAITER            @OZ19265
         LTR   R1,R1               ANY WAITER...               @OZ19265
         BNP   SJBF09              ...NO, CONTINUE             @OZ19265
         L     R3,4(,R1)           REMOVE WAITER               @OZ19265
         CS    R1,R3,SJBLOCKH+4         FROM THE               @OZ19265
         BNE   SJBF01                        CHAIN             @OZ19265
         LA    R0,X'45'            GET COMPLETION CODE         @OZ19265
         POST  (1),(0)             POST WAITER                 @OZ19265
         LR    R15,R5              RESTORE BASE REG            @OZ19265
         B     SJBF01              GO LOOK FOR ANOTHER         @OZ19265
SJBF09   DS    0H                                              @OZ19265
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
*              THIS LINE DELETED BY APAR NUMBER                @OZ58745
         LR    R14,R4              RESTORE RETURN REG          @OZ19265
         LH    R1,SJBASID          GET ASID FROM SJB.
         ALR   R1,R1               MULTIPLY BY FOUR.
         ALR   R1,R1
         AL    R1,$SVHAVT          POINT TO ENTRY IN HAVT.
         SL    R1,=A(SJBSJB-SJBDSECT)  PREPARE TO CHAIN.
         DROP  RSJB                DROP RSJB AS SJB BASE.
         USING SJBDSECT,R1         SET SJB BASE TO R1.
SJBF10   DS    0H
         LTR   R2,R1               SAVE AND TEST PREV SJB PTR.
         BZ    SJBF20              IF ZERO, SJB WASN'T ON HAVT.
         L     R1,SJBSJB           POINT TO NEXT SJB.
         CLR   R1,RSJB             IS THIS THE ONE TO DECHAIN...
         BNE   SJBF10              IF NOT, LOOP ONWARDS.
         L     R0,SJBSJB           PICK UP NEXT POINTER FROM THIS.
         USING SJBDSECT,R2         SET SJB BASE TO R2.
         ST    R0,SJBSJB           SET NEXT POINTER IN PREVIOUS.
         DROP  R1,R2               DROP TWO SJB BASES.
*
*
*              DECHAIN SJB SAVE AREA AND SHOW UNLOCKED
*
*
SJBF20   DS    0H
         LH    R0,SJBLENG-SJBDSECT(,RSJB)  GET SJB LENGTH            R4
         LR    R1,RSJB             POINT R1 TO THE SJB.
         L     R13,4(,R1)          DECHAIN SJB SAVE AREA.
         N     R12,=X'7FFFFFFF'    SHOW R13 NOT SJB POINTER.
*
*
*              FREE THE STORAGE OCCUPIED BY THE SJB
*
*
         LR    R5,R14              SAVE RETURN ADDRESS.
        $FREMAIN RC,A=(R1),LV=(R0),SP=241,KEY=1  FREE SJB            R4
*
*
*              RETURN TO CALLER
*
*
         BR    R5                  RETURN.
         DROP  R15                 DROP LOCAL BASE.
         TITLE '$SDBFREE -- ROUTINE TO FREE AN SDB'
*
*
*              $SDBFREE -- ROUTINE TO FREE AN SDB
*
*
SSDBFREE DS    0H
$SDBFREE EQU   SSDBFREE
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             ESTABLISH
         USING $SDBFREE,R12        ADDRESSABILITY.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
*
*              IF I/O IS ACTIVE, WAIT
*
         CLI   SDBICMP,X'48'       WAS LAST OP PURGED...       @OZ44636
         BE    SDF05A              BRANCH IF YES..             @OZ44636
         L     R1,SDBECB           LOAD ECB                         R41
SDF05    LR    R2,R1               RELOAD ECB                       R41
         N     R2,=XL4'7F000000'   RESET WAIT BIT                   R41
         CS    R1,R2,SDBECB        REPLACE ECB                      R41
         BNE   SDF05               TRY AGAIN IF UNSUCCESSFUL        R41
         WAIT  1,ECB=SDBECB        WAIT FOR I/O TO COMPLETE.
*
*              FREE ALL BUFFERS
*
SDF05A   DS    0H                                              @OZ44636
         L     R8,SDBSJB           POINT TO CORRECT SJB        @OZ33647
         TM    SDBFLG1,SDB1FOPN    IF INTERNAL DATA SETS,      @OZ40000
         BNZ   SDF06                ALWAYS FREE THE BUFFERS    @OZ40000
         USING SJBDSECT,R8         GET ADDRESSABILITY          @OZ33647
         CLI   SJBXQFN1+1,SSOBUNAL IF ENTRY FROM UNALLOCATION  @OZ33647
         BE    SDF08                DON'T TRY TO FREE BUFFERS  @OZ33647
         CLI   SJBXQFN1+1,SSOBTERM IF ENTRY FROM TERMINATE     @OZ40000
         BE    SDF08                DONT TRY TO FREE BUFFERS   @OZ40000
SDF06    DS    0H                                              @OZ40000
         L     RBUF,SDBPBF         FREE ALL
         BAL   R5,SDFBFREP         PROTECTED BUFFERS.
         L     RBUF,SDBGBF         FREE ALL                    @OZ45166
         BAL   R5,SDFBFREP         PROTECTED BUFFERS.          @OZ45166
         L     RBUF,SDBUBF         FREE ALL
         BAL   R5,SDFBFREU         UNPROTECTED BUFFERS.
         L     RBUF,SDBHBF         FREE ALL
SDF07    DS    0H                                              @OZ41634
         BAL   R5,SDFBFREU         HOLD BUFFERS.
         LTR   RBUF,RBUF           END OF BUFFER CHAIN ?       @OZ41634
         BNZ   SDF07               NO, LOOP BACK               @OZ41634
         L     RBUF,SDBFBF         FREE ALL
         BAL   R5,SDFBFREP         CH-END FREE BUFFERS.
         L     RBUF,SDBPBFX        FREE ALL
         BAL   R5,SDFBFREP         UNWRITTEN PROTECTED BUFFERS.
SDF08    DS    0H                                              @OZ33647
*              THIS LINE DELETED BY APAR NUMBER                @OZ33647
         LA    R1,SJBSDB           SET UP REGISTER 1 TO
         S     R1,=A(SDBSDB-SDBDSECT)  CHAIN SDBS FROM SJB.
SDF10    CL    RSDB,SDBSDB-SDBDSECT(,R1)  IF SUBJECT SDB IS NEXT,
         BE    SDF20               GO DECHAIN IT.
         L     R1,SDBSDB-SDBDSECT(,R1)  ELSE POINT TO NEXT SDB.
         LTR   R1,R1               IF THERE'S A NEXT,
         BNZ   SDF10               GO TEST ITS SDBSDB FIELD.
         B     SDF30               ELSE SKIP DECHAINING.
SDF20    MVC   SDBSDB-SDBDSECT(,R1),SDBSDB  DECHAIN SUBJECT SDB.
SDF30    DS    0H                  POTENTIAL ERROR - SDB NOT ON CHAIN.
         MVC   0(4,RSDB),SDBTCBM   SET FREEMAIN TCB POINTER.
         $FREMAIN RU,A=(RSDB),LV=SDBLNG,SP=230,KEY=5,TCB=YES
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN TO CALLER.
*
*              SUBROUTINES TO FREE BUFFERS
*
SDFBFREU DS    0H
         USING BFD,RBUF            USE BUFFER DSECT.
         LTR   R1,RBUF             IF NO BUFFER TO FREE,
         BZR   R5                  RETURN.
         L     RBUF,BFBF           ELSE POINT TO NEXT BUFFER
         $FREEBUF TYPE=UNPROT,A=(R1)  AND FREE CURRENT.
         BR    R5                  RETURN                      @OZ41634
         SPACE 1
SDFBFREP DS    0H
         LTR   R1,RBUF             IF NO BUFFER TO FREE,
         BZR   R5                  RETURN.
         L     RBUF,BFBF           ELSE POINT TO NEXT BUFFER
         $FREEBUF TYPE=PROT,A=(R1)  AND FREE CURRENT.
         B     SDFBFREP            THEN REPEAT.
         DROP  ,                   DROP ALL BASES.
         TITLE 'LITERAL POOL FOR $PROLOG - $SDBFREE'
         LTORG
         TITLE 'HASP SUBSYSTEM SUPPORT MODULE -- REQUEST/RETURN JOB ID'
***********************************************************************
*                                                                     *
*        REQUEST/RETURN JOB ID - SUBSYSTEM FUNCTIONS SSOBRQST/SSOBRTRN*
*                                                                     *
* INPUT REGISTERS -                                                   *
*                                                                     *
*        R0     = ADDRESS OF SSCVT                                    *
*        R1     = ADDRESS OF SSOB                                     *
*        R13    = SAVE AREA                                           *
*        R14    = RETURN                                              *
*        R15    = ENTRY BASE                                          *
*                                                                     *
* OUTPUT REGISTERS -                                                  *
*                                                                     *
*        R0-R14 = UNCHANGED                                           *
*        R15    = RETURN CODE                                         *
*                                                                     *
***********************************************************************
         SPACE 2
HOSREQID $PROLOG SSOBRQST,SSRRSIZE,LOCK=YES
         SPACE 1
         USING SJBDSECT,RSJB       PROVIDE SJB ADDRESSABILITY
         USING SSRQBGN,RSOX        PROVIDE SSOB EXT'N ADDRESSABILITY
         USING SSIB,RSIB           PROVIDE SSIB ADDRESSABILITY
         USING $SVDSECT,RSVT       PROVIDE SSVT ADDRESSABILITY
         SPACE 1
         LTR   R12,R12             TEST FOR SJB
         BM    HRQ010              BR IF YES
         EJECT
*
*        C R E A T E   A N   S J B
*
         SPACE 1
         LR    R5,SAVE             SAVE ADDRESS OF USER SAVE AREA
         CALL  $SJBINIT            CREATE AN SJB
         BALR  R12,0               RE-ESTABLISH
         USING *,R12               ADDRESSABILITY
         LA    R12,HRQBASE         ON
         USING HRQBASE,R12         RETURN.
         BNZ   HRQFAIL             BR IF SJB NOT BUILT
         ST    RSJB,8(,R5)         CHAIN
         ST    R5,SJBSAVE+4         SAVE AREAS
         L     R0,PSATOLD-PSA      SET LOCK HEADER
         LNR   R1,R0                TO SHOW
         STM   R0,R1,SJBLOCKH       SJB IN USE
         MVI   SJBXQFN1+1,SSOBRQST SHOW REQUEST JOB ID FUNCTION
         ST    RSJB,SSIBSUSE       CHAIN SJB TO SSIB
         ST    RSIB,SJBSSIB         AND SSIB TO SJB
         XC    SJBTCBP,SJBTCBP     CLEAR FOR END OF TASK       @OZ57048
         OI    SJBFLG1,SJB1SJID    SHOW SELECT-BY-JOB-ID
         SPACE 1
*
*        G E T   J O B   I D   F R O M   S U B S Y S T E M
*
         SPACE 1
HRQ010   DS    0H
         BALR  R12,0               ESTABLISH
         USING HRQBASE,R12          ADDRESSABILITY
         SPACE 1
HRQBASE  DS    0H
         MVI   SSIBJBID,1          CAUSE QUEUE TO PENDING-BY-NUM
         MVC   SJBSECB,SSRRSECB    SAVE STOP ECB ADDRESS
         SL    R12,=A(HRQBASE-HJSBASE)  GET JOB SELECT BASE
         BR    R12                 BR TO INTERFACE TO SUBSYSTEM
         SPACE 1
HRQ020   DS    0H
         LA    R15,SSRROK          SET 'GOOD' RETURN CODE
        $EPILOG KEY=0               AND RETURN TO REQUESTER
         SPACE 1
HRQFAIL  DS    0H
         BALR  R12,0               RE-ESTABLISH
         USING *,R12                ADDRESSABILITY
         LA    R12,0(,R12)         SHOW NO SJB
         LA    R15,SSRRFAIL        SET 'FAILED' RETURN CODE
        $EPILOG KEY=0               AND RETURN TO REQUESTER
         EJECT
HOSRETID $PROLOG SSOBRTRN,SSRRSIZE,LOCK=YES
         SPACE 1
         SL    R12,=A(*-HJEBASE)   RETURN JOB ID IS HANDLED
         USING HJEBASE,R12         SET JBTM ADDRESSABILITY
         B     HJERTRN             ENTER TERMINATION
         SPACE 1
         DROP  RSJB,RSOX,RSIB,RSVT,R12
         TITLE 'HOSJBSL - JOB SELECTION SUBSYSTEM FUNCTION'
*
*
*              HASP JOB SELECTION SUBSYSTEM FUNCTION
*
*
HOSJBSL  $PROLOG SSOBJBSL,SSJSIZE,LOCK=YES
         USING BFD,RBUF            SET BUFFER ADDRESSABILITY.
         USING JCTDSECT,R7         SET JCT ADDRESSABILITY.
         USING SSIB,RSIB           SET SSIB ADDRESSABILITY.
         USING SSJSBGN,RSOX        SET SSOB EXT ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         LTR   R12,R12             IF SJB ALREADY EXISTS,
         BM    HJS100              BRANCH.
*
*
*              FIRST INITIATOR CALL - CONSTRUCT AN SJB
*
*
         LR    R5,R13              SAVE USER SAVE AREA POINTER.
         CALL  $SJBINIT            CREATE SUBSYSTEM JOB BLOCK.
         BALR  R12,0               RE-ESTABLISH
         USING *,R12               ADDRESSABILITY
         LA    R12,HJSBASE         ON
         USING HJSBASE,R12         RETURN.
         BNZ   HJS800              ERROR IF NO STORAGE.
         ST    RSJB,8(,R5)         POINT USER SAVE AREA TO SJB.
         ST    R5,SJBSAVE+4        POINT SJB TO USER SAVE AREA.
         L     R0,PSATOLD-PSA      SET R0 = CURRENT TCB, R1 MINUS.
         LNR   R1,R0               SET SJB TO LOOK AS IF
         STM   R0,R1,SJBLOCKH      LOCK WERE OBTAINED.
         MVI   SJBXQFN1+1,SSOBJBSL SHOW SJB LOCKED FOR JOB SELECT.
         ST    RSJB,SSIBSUSE       SAVE SJB POINTER IN SSIB.
         ST    RSIB,SJBSSIB        SET LIFE-OF-JOB SSIB PTR IN SJB
         OI    SJBFLG1,SJB1SJID    ASSUME SELECT-JOB-BY-JOB-ID.
         OI    SJBLKFG,SJBFIRST    SHOW FIRST REQUEST          @OZ35293
*
*
*              SUBSYSTEM JOB BLOCK EXISTS - RE-ESTABLISH ADDR.
*
*
HJS100   DS    0H
         BALR  R12,0               ESTABLISH PERMANENT
         USING *,R12               LOCAL ADDRESSABILITY.
HJSBASE  DS    0H
         O     R12,=X'80000000'    SHOW SJB LOCKED, SAVE AREA          C
                                   CHAINED.
*
*
*              NOW EITHER STOP INITIATOR OR SELECT JOB
*
*
         TM    SJBFLG2,SJB2PNIT    IF WE ARE TO STOP INITIATOR,
         BO    HJS805              BRANCH.
         SPACE 1
         NI    SJBFLG1,SJB1SJID    RESET ALL FLG1 BUT SELECT-ID
         MVI   SJBFLG2,0           AND ALL OF FLG2.
         LM    R0,R1,SSIBJBID      GET REQUESTED JOB ID FROM SSIB
         STM   R0,R1,SJBJOBID      AND PUT IT IN THE SJB.
         ALR   R0,R1               IS ANY JOB ID SPECIFIED...
         BNZ   *+8                 SKIP IF SELECT-BY-ID.
         NI    SJBFLG1,255-SJB1SJID  ELSE SHOW SELECT-BY-CLASS.
         TM    SJBFLG1,SJB1SJID    IF SYSTEM TASK,
         BO    HJS150              DON'T DECREMENT $SVPIDLE.
         TM    SJBLKFG,SJBFIRST    IF NOT FIRST REQUEST        @OZ61523
         BNO   HJS150              DON'T DECREMENT COUNTER     @OZ61523
         L     R0,$SVPIDLE         GET INITIATOR COUNTER.
         SPACE 1                                               @OZ73545
HJS140   DS    0H
         LTR   R1,R0               IF POSITIVE,                @OZ73545
         BP    HJS145               CONTINUE                   @OZ73545
         OI    SJBFLG4,SJB4TERM    TURN ON TERM FLAG           @OZ73545
         B     HJS800              STOP THIS INITIATOR         @OZ73545
         SPACE 1                                               @OZ73545
HJS145   BCTR  R1,0                DECREMENT COUNT BY ONE      @OZ73545
         CS    R0,R1,$SVPIDLE      AND STORE NEW COUNT.
         BNE   HJS140              IF INTERFERENCE, CHECK AGAIN.
         EJECT                                                 @OZ73545
HJS150   DS    0H
* SELECT JOB BY ID OR BY CLASS ACCORDING TO SJB1SJID
         CALL  $SVJLOK             ACQUIRE HASP CMS LOCK.
         NI    SJBFLG2,255-SJB2CNCL  RESET THE CANCEL FLAG.
         LA    R1,$SVJPCLS         ASSUME SELECT-JOB-BY-CLASS.
         TM    SJBFLG1,SJB1SJID    IF SELECT-BY-ID FLAG IS OFF,
         BZ    *+8                 SKIP.
         LA    R1,$SVJPNUM         SET SELECT-BY-ID QUEUE.
         SLR   R0,R0               ZERO OUT
         ST    R0,SJBECB           THE ECB.
         CALL  $SJBRQ              QUEUE SJB PENDING JOB.
         CALL  $SVJUNLK            RELEASE HASP CMS LOCK.
         $$POST ELMT=$SVJOB        POST HASPXEQ FOR JOB.
         WAIT  1,ECB=SJBECB        WAIT TILL HASP SELECTS JOB.
         EJECT                                                 @OZ73545
*
*
*              EXAMINE STATUS AFTER XEQ HAS POSTED US
*
*
         TM    SJBFLG2,SJB2PNIT    IF HASP WANTS INIT STOPPED,
         BO    HJS805              BRANCH.
         TM    SJBFLG2,SJB2JNFD    IF JOB-BY-ID NOT FOUND,
         BO    HJS850              BRANCH.
         NI    SJBFLG4,FF-SJB4TERM ALLOW SVC34, 35 EDITING     @OZ64778
*
*
*              A JOB HAS BEEN FOUND FOR THIS INITIATOR
*
*
HJS200   DS    0H
         TIME  BIN                 GET JOB'S STARTING TIME & DATE.
         STM   R0,R1,SJBDBLWK      SAVE TEMPORARILY IN SJB.
*
*
*              GET STORAGE FOR JCT, IF REQUIRED
*
*
         L     R1,SJBJCT           IS JCT STORAGE
         LTR   R1,R1               ALREADY ASSIGNED...
         BNZ   HJS210              BRANCH IF SO.
         CALL  HCBGM               GET JCT STORAGE.
         BNZ   HJS830              ERROR IF NO STORAGE.
         ST    R1,SJBJCT           SAVE JCT POINTER IN SJB.
HJS210   DS    0H
*
*
*              READ IN THE HASP JOB CONTROL TABLE
*
*
         L     R0,SJBJCTRK         SET R0 = JCT TRACK ADDRESS.
         MVC   SJBFWORD,=CL4'JCT'  INDICATE JCT READ IN SJB    @OZ78293
         CALL  HCBRD               READ IN THE JCT.
         LR    R7,R1               SET JCT ADDRESSABILITY.
         BZ    HJS220              BRANCH IF JCT READ OKAY.
         CALL  HCBFM               ELSE FREE JCT STORAGE.
         SLR   R7,R7               ZERO OUT THE JCT POINTER
         ST    R7,SJBJCT           IN THE SJB.
         B     HJS840              ERROR READING JCT.
         EJECT                                                 @OZ73545
HJS220   DS    0H
*
*
*              MOVE JOB IDENTIFIERS TO SJB AND SSIB
*
*
         TM    JCTJOBFL,JCTNOJNL   TEST FOR JOB JOURNALLING          R4
         BO    SKIP10              BR IF NO                          R4
         OI    SJBFLG2,SJB2JNL      ELSE INDICATE SO IN SJB          R4
SKIP10   MVC   JCTXEQON(8),SJBDBLWK  SET DATE, TIME OF JOB START.
         MVC   SJBJOBNM,JCTJNAME   SET JOB NAME IN SJB.
         TM    SJBFLG1,SJB1XBMC    IF XBM CONTINUATION,
         BO    *+12                 HAVE NO SSIB.
         LM    R0,R1,SJBJOBID      GET HASP JOB IDENTIFIER.
         STM   R0,R1,SSIBJBID      SET IT IN SSIB.
         SLR   R0,R0               ZERO OUT
         ST    R0,SJBLOGQ          SJBLOGQ.
         MVC   JCTPRIO,SJBPRIO     MOVE SELECTION PRTY TO JCT.
         MVC   SJBESTLN,JCTESTLN   SET PRINT AND PUNCH
         MVC   SJBESTPU,JCTESTPU   EXCESSION LIMITS.
         SPACE 1                                               @OZ18212
         SPACE 1                                               @OZ18212
         MVC   JCTCPUID,$SVSID     SET SYS ID IN JMR AND       @OZ18212
         MVC   JCTEXSID,$SVSID      JCT FOR SMF TYPE 26        @OZ18212
         OI    JCTFLAG1,JCT1CKPT   FLAG JCT FOR CHECKPOINT          R41
         CLI   SJBXQFN1+1,SSOBRQST TEST FOR REQUEST-JOB-ID           R4
         BE    HJS250              BR IF YES                         R4
*
*
*              SET CONVERTER RETURN CODE IN THE SSOB EXTENSION
*
*
         TM    SJBFLG1,SJB1SJID    IF THIS JOB IS
         BZ    *+16                SELECT-BY-ID,
         ICM   R0,15,JCTCNVRC      MOVE CONVERTER RETURN CODE
         ST    R0,SSJSSERR         TO SSOB.
         BNZ   HJS560              TERMINATE IF ANY ERROR DETECTED.
         EJECT                                                 @OZ73545
*
*
*              IF EXECUTION BATCH MONITOR CONTINUATION,
*              SET NEW JOB KEY IN ALL SDBS.
*
*
         TM    SJBFLG1,SJB1XBMC    IF NOT XBM CONTINUATION,
         BZ    HJS250              BRANCH.
         L     R0,SJBJKEY          SET R0 = JOB KEY.
         L     R1,SJBSDB           POINT TO FIRST SDB.
HJS230   DS    0H
         LTR   R1,R1               IF END OF SDBS,
         BZ    HJS240              END LOOP.
         USING SDBDSECT,R1         SET SDB ADDRESSABILITY.
         ST    R0,SDBJKEY          SET JOB KEY IN SDB.
         L     R1,SDBSDB           POINT TO NEXT SDB
         B     HJS230              AND LOOP.
HJS240   DS    0H
         DROP  R1                  DROP SDB ADDRESSABILITY.
*
*
*              IF EXECUTION BATCH MONITOR CONTINUATION,
*              READ NEW INPUT IOT, COPY THE 'JCL' PDDB
*              AND TRACK GROUP MAP TO THE OLD 1ST IOT AND
*              GET NEW TRACKS FOR ANY OTHER OLD IOTS.
*
*
         L     RIOT,SJBIOT         SAVE POINTER TO PREVIOUS 1ST IOT.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         LA    R2,JCTIOT           SET TRACK CHAIN POINTER.
         LA    R3,SJBIOT           SET DUMMY STORAGE CHAIN POINTER.
         BAL   R4,HJSRDIOT         READ IN THE ONLY IOT.
         ST    RIOT,SJBIOT         RESTORE POINTER TO PREVIOUS 1ST IOT.
         L     R15,$SVMAPL              COPY                         R4
         LA    R15,TGMAP-TGMDSECT(,R15)  ALL                         R4
         LA    R14,IOTTGMAP               TGM                        R4
         LA    R4,IOTTGMAP-IOTDSECT(,R1)   FIELDS                    R4
         LR    R5,R15                       TO                       R4
         MVCL  R14,R4                        OLD IOT                 R4
         L     RIOT,SJBIOT         RESTORE IOT ADDRESS               R4
         MVC   IOTMSTAB(TABAIOT-TABDSECT),IOTMSTAB-IOTDSECT(R1)     R41
         OI    JCTFLAG1,JCT1CKPT   FLAG JCT FOR CHECKPOINT           R4
         L     R15,$SVPDDB1           MOVE                           R4
         LA    R14,IOTPDBOJ(R15,RIOT)  JCL                           R4
         LA    R4,IOTPDBOJ(R15,R1)      PDDB                         R4
         MVC   0(PDBLENG,R14),0(R4)      TO OLD IOT                  R4
         OI    PDBFLAG1-PDBDSECT(R14),PDB1NSOT  DON'T LET JCL PRINT  R4
         MVC   IOTTRACK,JCTIOT     MOVE NEW IOT TRK ADDR TO OLD IOT.
         CALL  HCBFM               FREE NEW IOT STORAGE
         SLR   R2,R2               SET R2 TO ZERO.
         LA    R4,IOTMSTAB         SET R4 TO MASTER TAB FOR $STRAK   R4
HJS246   DS    0H
         MVC   IOTJBKEY,SJBJKEY    SET KEY IN OUTPUT IOT.
         OI    IOTFLAG1,IOT1CKPT   FLAG IOT FOR CHECKPOINT.
         ST    R2,IOTIOTTR         ZERO TRACK CHAIN POINTER.
         L     R3,IOTIOT           IF NO MORE
         LTR   R3,R3               OUTPUT IOTS,
         BZ    HJS570              CONTINUE WITH XBMC WORK.
         LR    R1,R4               ELSE POINT TO ALLOC TGM &
         CALL  $STRAK              GET TRACK FOR NEXT IOT.
         ST    R1,IOTIOTTR         SET CHAINING TRACK.
         LR    RIOT,R3             POINT TO NEXT IOT.
         ST    R1,IOTTRACK         SET ITS TRACK IN IT.
         B     HJS246              GO DO THIS NEXT IOT.
         EJECT                                                 @OZ73545
*
*
*              FOR NON-EXECUTION BATCH MONITOR CONTINUATION,
*              READ IN THE REGULAR IOT(S)
*
*
HJS250   DS    0H
         LA    R2,JCTIOT           SET TRACK CHAIN POINTER.
         LA    R3,SJBIOT           SET STORAGE CHAIN POINTER.
         BAL   R4,HJSRDIOT         READ ALL REGULAR IOTS.
*
*
*              READ IN JOB'S OUTPUT CONTROL RECORD(S)          @OZ19486
*
*
         L     R1,SJBOCT           GET OCR STORAGE ADDRESS.
         TM    SJBFLG1,SJB1XBM     IF BATCH MONITOR,
         BO    HJS300              DON'T READ OCTS.
         L     R0,JCTOCTTR         GET OCR TRACK ADDRESS.
         LTR   R0,R0               IF JOB HAS NO OCR,
         BZ    HJS310              GO FREE OCR STORAGE.
         LTR   R1,R1               JOB HAS OCR.  IF OCR STORAGE
         BNZ   HJS280              ADDRESS EXISTS, GO READ IT.
         CALL  HCBGM               ELSE GET OCR STORAGE.
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         ST    R1,SJBOCT           SET POINTER TO OCR IN SJB.
HJS280   DS    0H
         MVC   SJBFWORD,=CL4'OCT'  INDICATE OCT READ IN SJB    @OZ78293
         CALL  HCBRD               READ IN THE OCR.
         BNZ   HJS840              ERROR - CAN'T READ OCR.     @OZ19486
         ICM   R0,15,OCTOCTTR-OCTDSECT(R1) TTR OF NXT OCT      @OZ19486
         BZ    HJS320              NO MORE, EXIT LOOP          @OZ19486
         LR    R5,R1               SAVE ADDRESS OF OCT N       @OZ19486
         CALL  HCBGM               GET STORAGE FOR OCT N+1     @OZ19486
         BNZ   HJS830              IF NO STORAGE, ABORT        @OZ19486
         ST    R1,OCTOCT-OCTDSECT(,R5) CHAIN OCT N+1           @OZ19486
         B     HJS280              LOOP TO READ OCT N+1        @OZ19486
         SPACE 2                                               @OZ19486
HJS300   DS    0H
         L     RIOT,SJBIOT         POINT TO THE 1ST IOT.
         AL    RIOT,$SVPDDB1                             DON'T PRINT R4
         OI    IOTPDBOI+PDBFLAG1-PDBDSECT(RIOT),PDB1NSOT  JCL IMAGES R4
HJS310   DS    0H
         CALL  HCBFM               FREE OCR STORAGE
         SLR   R0,R0               AND ZERO
         ST    R0,SJBOCT           OCR POINTER IN SJB.
         EJECT                                                 @OZ73545
HJS320   DS    0H
*
*
*              IF JOB SELECT CODE IS BEING USED BY
*              REQUEST-JOB-ID FUNCTION, RETURN THERE
*
*
         CLI   SJBXQFN1+1,SSOBRQST IF NOT REQUEST-JOB-ID,
         BNE   HJS340              CONTINUE.
         SL    R12,=A(HJSBASE-HRQBASE)  SET BASE TO HOSRQST.
         USING HRQBASE,R12         TELL THE ASSEMBLER.
         B     HRQ020              RETURN TO HOSRQST CODE.
HJS340   DS    0H
         USING HJSBASE,R12         RESET LOCAL ADDRESSABILITY.
*
*
*              PRIOR TO FAKE-OPENS, ALTER ADDRESSABILITY
*
*
         DROP  RSOX                DROP RSOX TO PICK UP RSDB.
         LR    RSIB,RSOX           POINT RSIB (R8) TO SSOB EXT.
         USING SSJSBGN,RSIB        SET SSOB EXT ADDRESSABILITY.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
*
*
*              MOVE CERTAIN INFORMATION TO SSOB EXTENSION
*
*
*                                                                    R4
*                      PERFORM PASSWORD PROCESSING                   R4
*                                                                    R4
         TM    SJBFLG1,SJB1XBM     IF BATCH MONITOR,           @OZ41304
         BO    HJS350              NO PASSWORD USED            @OZ41304
         LA    R3,$JSPSLEN         GET NECESSARY LENGTH FOR PASSWRDS R4
         CH    R3,SSJSLEN          COMPARE TO ACTUAL LENGTH          R4
         BH    HJS350              BR IF NOT LONG ENOUGH             R4
         LA    R3,JCTPASS          GET ADDR OF JCT CURRENT PASS      R4
         LA    R1,SSJSPASS         GET ADDR OF SSOB CURRENT PASS     R4
         BAL   R14,HJS345          BR TO MOVE FROM JCT TO SSOB       R4
         LA    R3,JCTNUPAS         GET ADDR OF JCT NEW PASS          R4
         LA    R1,SSJSPAS2         GET ADDR OF SSOB NEW PASS         R4
         BAL   R14,HJS345          BR TO MOVE FROM JCT TO SSOB       R4
         CLI   JCTNUPAS,X'00'      TEST FOR NEW PASSWORD             R4
         BE    HJS350              BR IF NO NEW PASSWORD             R4
         MVC   JCTPASS,JCTNUPAS    MOVE NEW PASS TO CURRENT FIELD    R4
         XC    JCTNUPAS,JCTNUPAS   ZERO NEW PASSWORD FIELD           R4
         B     HJS350              THEN BR TO CONTINUE               R4
         SPACE 2                                                     R4
*                                                                    R4
*                                                                    R4
*        JOB SELECT SUBROUTINE TO MOVE PASSWORDS FROM JCT TO SSOB    R4
*                                                                    R4
*                                                                    R4
HJS345   LR    R15,R1              SAVE SSOB ADDR                    R4
         MVC   1(8,R1),0(R3)       STORE PASSWRD IN SSOB             R4
         LA    R3,8                GET SIZE OF MAX PASSWORD          R4
         SPACE 1                                                     R4
HJS346   TM    8(R1),X'BF'         CHECK END OF FIELD FOR BLANK/ZERO R4
         BNZ   HJS347              BR IF END OF PASSWORD             R4
         BCTR  R1,0                BACK UP ONE BYTE                  R4
         BCT   R3,HJS346           SUBT TO GET VALID CHAR NUM        R4
         SPACE 1                                                     R4
HJS347   DS    0H                  END OF PASSWORD FOUND             R4
         STC   R3,0(R15)           STORE LENGTH OF PASSWORD          R4
         BR    R14                 RETURN                            R4
         SPACE 1                                                     R4
$JSPSLEN EQU   SSJSPAS2+L'SSJSPAS2-SSJSBGN EXT'N LEN NEEDED FOR PWDS R4
         EJECT                                                       R4
HJS350   DS    0H                                                    R4
         MVC   SSJSSTEP,JCTJSSTP   MOVE RESTART STEP TO SSOBX.
         NI    JCTJSFLG,255-SSRQHOLD  RESET RESTART HOLD FLAG.
         MVC   SSJSFLG1,JCTJSFLG   MOVE RESTART FLAGS TO SSOBX.
         LA    R0,JCTJMR           SET JMR POINTER
         ST    R0,SSJSJMR          IN SSOB EXTENSION.
*
*
*              FAKE-OPEN INTERNAL TEXT DATA SET
*
*
         TM    SJBFLG1,SJB1XBM     IF NOT XBM,
         BZ    *+8                 SKIP.
         OI    JCTJOBFL,JCTNOJNL   PREVENT JOURNALING.
         LA    R3,SJBIACB          POINT TO ACB.
         ST    R3,SSJSTACB         STORE POINTER IN SSOBX.
         L     RIOT,SJBIOT         POINT TO THE 1ST IOT.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOT(RIOT,R15)  INTERNAL TEXT PDDB             R4
         CALL  HFOPSUB             CREATE AN SDB.
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         MVC   SDBDDNM,=CL8'$INTTEXT'  SHOW EBCDIC INTTEXT.
         CALL  HOOLDINP            OPEN INTERNAL TEXT DATA SET.
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         CALL  HCNVFDAD            SET STARTING TRACK IN IOB.
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         EXCP  SDBIOB              PRIME THE DATA SET.
         WAIT  1,ECB=SDBECB        WAIT FOR I/O TO END.
*
*
*              FAKE-OPEN JOB JOURNAL DATA SET
*
*
         TM    JCTJOBFL,JCTNOJNL   IF JOB IS TO JOURNAL,
         BZ    HJS360              BRANCH.
* IF NO JOB JOURNAL EXISTS ---
         SLR   R3,R3               ZERO OUT JOURNAL
         ST    R3,SSJSJACB         ACB POINTER IN SSOBX.
         B     HJS440              ELSE CONTINUE FAKE OPEN.
HJS360   DS    0H
* IF JOB JOURNAL EXISTS ---
         LA    R3,SJBJACB          POINT TO JOURNAL ACB.
         ST    R3,SSJSJACB         SET POINTER IN SSOBX.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBON(RIOT,R15)  JOB JOURNAL PDDB               R4
         CALL  HFOPSUB             CREATE SDB  (R1=PDDB ON RETURN)   R4
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         MVC   SDBDDNM,=CL8'$JOURNAL'  SHOW EBCDIC JOURNAL.
* IF NEW JOURNAL, OPEN FOR OUTPUT
         CLI   SSJSFLG1,0          IF RESTART FLAGS NOT ALL OFF,
         BNE   HJS400              OPEN JOURNAL FOR INPUT.
HJS380   DS    0H
         CALL  HONEWOUT            OPEN JOURNAL FOR OUTPUT.
         BZ    HJS440              CONTINUE IF OKAY.
         B     HJS830              ERROR - NO STORAGE AVAILABLE.
HJS400   DS    0H
* IF OLD JOURNAL, OPEN FOR INPUT, READ, AND WAIT
         USING PDBDSECT,R1         SET PDDB ADDRESSABILITY.
         TM    PDBFLAG1,PDB1NULL   IF JOURNAL NEVER USED,
         BO    HJS380              TRY TO OPEN FOR OUTPUT.
         CALL  HOOLDINP            OPEN JOURNAL FOR INPUT.
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         CALL  HCNVFDAD            SET TRACK ADDRESS IN IOB.
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         EXCP  SDBIOB              START FIRST READ OF JOURNAL.
         WAIT  1,ECB=SDBECB        WAIT FOR ITS COMPLETION.
         TM    SDBFLG2,SDB2IOE     IF NO I/O ERROR,
         BZ    HJS440              CONTINUE.
         NI    SSJSFLG1,255-SSJSWARM  IF MORE THAN WARM START,
         BNZ   HJS440              LEAVE JOURNAL AS INPUT.
* ON WARM START, JOB JOURNAL DIDN'T MAKE IT.  THE JOB NEVER GOT
* INITIATED.  RESET JOURNAL TO OUTPUT.
         $FREEBUF TYPE=PROT,A=SDBPBF  FREE PROTECTED BUFFER.
         SLR   R0,R0               CLEAR REGISTER                    R4
         ST    R0,SDBPBF           CLEAR POINTER TO PBF              R4
         $FREEBUF TYPE=UNPROT,A=SDBUBF  FREE UNPROTECTED BUFFER.
         SLR   R0,R0               ZERO JOURNAL SDB'S
         STH   R0,SDBFLG1          FLAG BYTES 1 AND 2.
         ST    R0,SDBUBF           CLEAR POINTER TO UBF              R4
         L     R7,SJBJCT           RESTORE JCT ADDRESS              R41
         B     HJS380              GO OPEN JOURNAL FOR OUTPUT.
HJS440   DS    0H
*
*
*              FAKE-OPEN SYSTEM MESSAGES DATA SET
*
*
         LA    R3,SJBMACB          POINT TO SYSMSG ACB.
         ST    R3,SSJSMACB         STORE ACB POINTER IN SSOBX.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOM(RIOT,R15)  SYSTEM MESSAGES PDDB           R4
         CALL  HFOPSUB             CREATE SDB  (R1=PDDB ON RETURN)   R4
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         MVC   SDBRECCT,PDBRECCT-PDBDSECT(R1) BEGIN REC CNT    @OZ19451
         OI    SDBFLG1,SDB1OUT     SHOW DATA SET SYSOUT.
         MVC   SDBDDNM,=CL8'$SYSMSGS'  SHOW EBCDIC SYSMSGS.
         NI    PDBFLAG1,255-PDB1NULL  SHOW DATA SET OPENED.          R4
         L     WA,JCTMSGSC         GET CONTINUATION TRACK           R41
         BAL   WE,HJSREOPN         REPOSITION DS IF WARM START      R41
         BNZ   HJSOPNOL            BR IF WARM START                 R41
         SPACE 1                                                    R41
         L     R0,PDBMTTR          GET STARTING MTTR IN R0.
         DROP  R1                  DROP PDDB BASE.
         LA    R1,X'100'           CONVERT MTTR
         SRDL  R0,8                TO RBA AND STORE IN
         STM   R0,R1,SDBTRKF       SDB AS STARTING RBA.
         CALL  HOOLDOUT            OPEN FOR OUTPUT.
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         L     R0,JCTMSGSC         GET SYSMSG CONTINUATION TRACK.
         CALL  HJSRETAB            REBUILD TRACK ALLOC. BLOCK       R41
         LA    R1,X'100'           CHANGE IT TO
         SRDL  R0,8                RBA FORMAT.
         STM   R0,R1,SDBTRK        SET RBA IN SDBTRK.
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         STM   R0,R1,BFRBA         SET RBA IN BFRBA.
*
*
*              FAKE-OPEN HASP JOB LOG DATA SET
*
*
HJSOPNOL DS    0H                                                   R41
         LA    R3,SJBLACB          POINT TO HASP LOG ACB.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOL(RIOT,R15)  HASP JOB LOG PDDB              R4
         CALL  HFOPSUB             CREATE SDB  (R1=PDDB ON RETURN)   R4
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         MVC   SDBRECCT,PDBRECCT-PDBDSECT(R1) BEGIN REC CNT    @OZ19451
         OI    SDBFLG1,SDB1OUT     SHOW DATA SET SYSOUT.
         MVC   SDBDDNM,=CL8'$JES2LOG'  SHOW EBCDIC JES2LOG.
         NI    PDBFLAG1-PDBDSECT(R1),255-PDB1NULL  SHOW DATASET OPENED.
         L     WA,JCTJLOGC         GET CONTINUATION TRACK           R41
         BAL   WE,HJSREOPN         REPOSITION DS IF WARM START      R41
         BNZ   HJS550              BR IF WARM START                 R41
         SPACE 1                                                    R41
         CALL  HOOLDOUT            OPEN DATA SET FOR OUTPUT.
         BNZ   HJS830              ERROR - NO STORAGE AVAILABLE.
         L     R0,JCTJLOGC         GET CONTINUATION TRACK.
         CALL  HJSRETAB            REBUILD TRACK ALLOC. BLOCK       R41
         LA    R1,X'100'           CONVERT IT TO
         SRDL  R0,8                RBA FORMAT.
         STM   R0,R1,SDBTRK        SET RBA IN SDBTRK.
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         STM   R0,R1,BFRBA         SET RBA IN BFRBA.
HJS550   DS    0H                                                   R41
         L     R0,SSJSJACB         IF JOB HAS
         LTR   R0,R0               NO JOURNAL
         BNZ   HJS560              DATA SET, BUT WILL
         CLI   SSJSFLG1,0          WARM START OR RESTART,
         BNE   HJS870              WRITE MESSAGE.
HJS560   DS    0H
*
*
*              CONCLUDE JOB SELECTION
*
*
         TM    SJBFLG1,SJB1SJID    IF SELECT-BY-ID,
         BO    HJS575              BRANCH.
HJS570   DS    0H
         TM    $SVSTUS,$SVSTXST    IF HASP IS NOT MONITORING
         BZ    HJS575              TIME EXCESSIONS, BRANCH.
*
*
*        ALLOW HASP TO MONITOR TIME EXCESSIONS
*
*
         L     R1,JCTETIME         PROVIDE HASP
         LNR   R1,R1                WITH INITIAL
         ST    R1,SJBXSTIM           TIME INTERVAL
         $$POST ELMT=$SVXSTIM      POST HASPTIME FOR WORK
HJS575   DS    0H
         TM    SJBFLG1,SJB1XBMC    IF XBM CONTINUATION,
         BO    HJS600              RETURN TO HAMGET.
*
*
*              CALL IEFIB600, THE SCHEDULER WORK AREA CREATOR
*
*
         TM    SJBFLG1,SJB1SJID    IF NOT SELECT-BY-ID,
         BZ    HJS580              DON'T CHECK CONVERTER CODE.
         L     R0,SSJSSERR         EXAMINE CONVERTER
         LTR   R0,R0               COMPLETION CODE.
         BNZ   HJS830              IF NON-ZERO, SKIP IEFIB600.
HJS580   DS    0H
         TM    SJBFLG1,SJB1XBM     TEST FOR XBM.               @OZ26957
         BZ    HJS582              NOT XBM, SKIP.              @OZ26957
         CALL  HCBGM               GET DUMMY JCT BUFFER.       @OZ26957
         BNZ   HJS830              ERROR IF NO STORAGE.        @OZ26957
*            PREPARE DUMMY JCT TO REPRESENT XBM      *         @OZ26957
         DROP  R7                  DROP PREVIOUS JCT BASE      @OZ26957
         USING JCTDSECT,R1         MAKE NEW JCT ADDRESSABLE    @OZ26957
         MVC   JCTJMRST(L'JCTJMR),JCTJMRST-JCTDSECT(R7)        @OZ26957
         MVC   JCTJMRJN(8),SJBXBJNM   SUBSTITUTE XBM JOBNAME.  @OZ26957
         LR    R7,R1               PRESERVE DUMMY JCT ADDR.    @OZ26957
         DROP  R1                  DROP CURRENT JCT BASE       @OZ26957
         USING JCTDSECT,R7         USE PREV. BASE FOR NEW JCT  @OZ26957
         $TIME                     GET CURRENT TIME AND DATE.  @OZ26957
         STM   R0,R1,JCTRDRON      XBM TIME ON READER          @OZ26957
         STM   R0,R1,JCTRDROF        IS VERY BRIEF.            @OZ26957
         LA    R1,JCTJMR           SET XBM JMR POINTER         @OZ26957
         ST    R1,SSJSJMR            IN SSOB EXT.              @OZ26957
HJS582   DS    0H                                              @OZ26957
         L     R1,4(,R13)          POINT R1
         L     R1,24(,R1)          TO USER'S SSOB.
         SPACE 1
         LINK  EP=IEFIB600         LINK TO IEFIB600.
         SPACE 1
         ST    R15,SSJSSERR        SAVE IEFIB600 RETURN CODE.
         TM    SJBFLG1,SJB1XBM     TEST FOR XBM.               @OZ26957
         BZ    HJS587              SKIP IF NOT.                @OZ26957
         LR    R1,R7               RESTORE DUMMY JCT ADDR.     @OZ26957
         L     R7,SJBJCT           RESTORE USER'S JCT ADDR.    @OZ26957
         CALL  HCBFM               FREE DUMMY JCT BUFFER.      @OZ26957
HJS587   DS    0H                                              @OZ26957
         BAL   R14,HJSMSG1         WTO 'HASP373 STARTED'.
         LA    R1,SJBLRPL          POINT TO RPL                @OZ44947
         ENDREQ RPL=(1)            WRITE JOB LOG TO SPOOL      @OZ44947
         L     R15,SSJSSERR        GET IEFIB600 RETURN CODE.
         LTR   R15,R15             IF CODE IS ZERO,
         BZ    HJS590              CONTINUE.
         TM    SJBFLG1,SJB1SJID    IF NON-ZERO CODE,
         BO    HJS830              END INITIATOR IF SELECT-ID.
         B     HJS840              IN ANY CASE TERMINATE JOB.
HJS590   DS    0H
*
*
*              PROCESS OPERATOR CANCEL AND SET SJBCSCB
*
*
         L     R1,SSJSLCT          POINT TO LINKAGE CONTROL TABLE.
         USING LCTDSECT,R1         SET LCT ADDRESSABILITY.
         L     R1,LCTQDRTY         POINT TO CSCB FROM LCT.
         USING CSCDSECT,R1         SET CSCB ADDRESSABILITY.
         ST    R1,SJBCSCB          SAVE CSCB POINTER IN SJB.
         TM    SJBFLG2,SJB2CNCL    IF NOT OPERATOR CANCEL,
         BZ    HJS595              PROCEED.
         OI    CHACT,CHCLD         SHOW CANCEL OF WHOLE JOB.
         MVC   CHCECB,=X'40000222' POST CANCEL ECB.
         DROP  R1                  DROP CSCB BASE.
HJS595   DS    0H
*
*
*              IF JOURNAL WAS OPEN FOR INPUT, CHANGE IT TO OUTPUT
*
*
         L     RSDB,SSJSJACB       POINT TO JOURNAL ACB.
         LTR   RSDB,RSDB           IF NO JOURNAL,
         BZ    HJS900              JUST RETURN TO INITIATOR.
         USING IFGACB,RSDB         SET ACB ADDRESSABILITY.
         L     RSDB,ACBDEB-1       POINT FROM ACB TO DEB.
         USING DEBBASIC,RSDB       SET DEB ADDRESSABILITY.
         L     RSDB,DEBIRBAD       POINT FROM DEB TO SDB.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         TM    SDBFLG1,SDB1GET     IF JOURNAL NOW OUTPUT,
         BZ    HJS900              JUST RETURN TO INITIATOR.
* CHANGE JOURNAL DATA SET FROM INPUT TO OUTPUT,
* LEAVING UNPROTECTED BUFFER INTACT (SINCE LAST OPERATION
* DONE TO JOURNAL WAS A POINT).
         $FREEBUF TYPE=PROT,A=SDBPBF  FREE PROTECTED BUFFER.
         L     R7,SJBJCT           RESTORE JCT BASE            @OZ40702
         SLR   R0,R0               ZERO PROTECTED-BUFFER
         ST    R0,SDBPBF           POINTER IN SDB.
         XI    SDBFLG1,SDB1GET+SDB1PUT  FLAG SDB FOR OUTPUT.
         MVI   SDBCCW4,X'05'       SET WRITE-DATA CCW.
         B     HJS900              NOW RETURN TO INITIATOR.
HJS600   DS    0H
*
*
*              EXECUTION BATCH MONITOR CONTINUATION -
*              RE-OPEN ALL SUBSYSTEM DATA SETS
*
*
         LA    RSDB,SJBSDB         POINT TO SDB CHAIN.
         SL    RSDB,=A(SDBSDB-SDBDSECT)  SET UP TO CHAIN.
HJS620   DS    0H
         L     RSDB,SDBSDB         POINT TO THE NEXT SDB.
         LTR   RSDB,RSDB           IF NO MORE,
         BZ    HJS660              END OF XBMC FAKE OPEN.
         CLC   SDBDKEY,=AL2(PDBINTXT)  IF INTERNAL TXT DATASET @OZ79713
         BE    HJS620              CONTINUE WITH NEXT SDB.
         NI    SDBFLG2,SDB2XBIN+SDB2MCLS  OF FLAG2 BUT XBIN, MCLS.
         L     R2,SDBPDDB          ESTABLISH PDDB
         USING PDBDSECT,R2          ADDRESSABILITY.
         TM    SDBFLG2,SDB2XBIN    IS THIS BATCH INPUT UNIT...
         BNZ   HJS640              BRANCH IF BATCH INPUT UNIT.
         TM    SDBFLG1,SDB1FOPN    IF INTERNAL DATA SET        @OZ29148
         BO    HJS621              BYPASS NEXT TEST            @OZ29148
         TM    SDBFLG2,SDB2MCLS    IF ORIGINAL OUTPUT CLASS    @OZ29148
         BZ    HJS622               WAS NOT $ OR *, SKIP THIS  @OZ29148
HJS621   DS    0H                                              @OZ29148
         MVC   PDBCLASS,JCTMCLAS   SET CLASS FROM JCT          @OZ29148
         NI    PDBFLAG1,255-PDB1NSOT-PDB1HOLD RESET FLAG BITS  @OZ29148
         NI    PDBFLAG2,255-PDB2TCEL  RESET TRACKCELL          @OZ29148
         SLR   R3,R3               ZERO R3 FOR IC              @OZ29148
         IC    R3,JCTMCLAS         GET MESSAGE CLASS           @OZ29148
         LA    R1,$SVSCAT(R3)      POINT TO ITS SCAT ENTRY     @OZ29148
         TM    PDBFLAG2,PDB2HLDS   IF HOLD=YES ON DD CARD      @OZ29148
         BO    *+12                 DONT CHECK SCATHOLD        @OZ29148
         TM    SCATFLAG-SCADSECT(R1),SCATHOLD  HOLD CLASS...   @OZ29148
         BZ    *+8                 BRANCH IF NOT               @OZ29148
         OI    PDBFLAG1,PDB1HOLD   SHOW HELD DATA SET          @OZ29148
         TM    SCATFLAG-SCADSECT(R1),SCATDUMM  DUMMY CLASS...  @OZ29148
         BZ    *+8                 BRANCH IF NOT               @OZ29148
         OI    PDBFLAG1,PDB1NSOT   MARK AS DUMMY               @OZ29148
         TM    SCATFLAG-SCADSECT(R1),SCATTCEL   IF CLASS NOT   @OZ29148
         BZ    HJS622              TRACKCELLED, THEN BRANCH    @OZ29148
         OI    PDBFLAG2,PDB2TCEL   SHOW TRACKCELLED DATA SET   @OZ29148
HJS622   DS    0H                                              @OZ29148
         TM    PDBFLAG2,PDB2JFMS   IF ORIGINAL FORMS           @OZ29148
         BZ    *+10                 WAS SET FROM JCT           @OZ29148
         MVC   PDBFORMS,JCTFORMS     THEN SET NEW JCTFORMS     @OZ29148
         NI    PDBFLAG1,255-PDB1NULL   RESET NULL              @OZ29148
         TM    PDBFLAG3,PDB3BRST   IF XBM PROC HAS BURST PARM  @OZ55601
         BO    SKIP15                DON'T USE JOBPARM VALUE.  @OZ55601
         NI    PDBFLAG2,255-PDB2BRST   ELSE ASSUME NO BURST.   @OZ55601
         TM    JCTFLAG1,JCTBURST   BUT IF JOB'S DEFAULT IS     @OZ55601
         BZ    SKIP15                 BURST=Y, THEN SET NEW    @OZ55601
         OI    PDBFLAG2,PDB2BRST          JCTBURST.            @OZ55601
SKIP15   DS    0H                                              @OZ55601
         TM    JCTJOBFL,JCTNOUPT   TEST 'NO OUTPUT' OPTION     @OZ29148
         BO    SKIP20              BR TO SET NSOT              @OZ29148
         TM    PDBFLAG1,PDB1LOG    TEST FOR JES2 JOB LOG       @OZ29148
         BZ    HJS625              BRANCH IF NO                @OZ29148
         TM    JCTJBOPT,JCTNOLOG   TEST 'NOLOG' OPTION         @OZ29148
         BZ    HJS625              BRANCH IF NOT SET           @OZ29148
SKIP20   OI    PDBFLAG1,PDB1NSOT   MAKE NON PRINTABLE          @OZ29148
HJS625   DS    0H                                                    R4
         XC    SDBTAB(SDBAIOT-SDBTAB),SDBTAB CLEAR THE TAB     @OZ18630
         OI    SDBTAB+(TABFLAG-TABDSECT),TABMINOR SHOW MINOR   @OZ18630
         TM    PDBFLAG2,PDB2TCEL   IS DATA SET TRACKCELLED     @OZ18630
         BZ    HJS627              BRANCH IF NOT               @OZ18630
         OI    SDBTAB+(TABFLAG-TABDSECT),TABMAJOR SHOW MAJOR   @OZ18630
HJS627   DS    0H                                              @OZ18630
         SLR   R0,R0               ZERO THE SDB'S              @OZ29019
         ST    R0,SDBRECCT           OUTPUT RECORD COUNT       @OZ29019
         BCTR  R0,0                SET OUTPUT LIMIT            @OZ29019
         ST    R0,SDBOUTLM           TO MAXIMUM                @OZ29019
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         LTR   RBUF,RBUF           IF BUFFER PRESENT, DATASET WAS OPEN
         BNZ   HJS630              AT LAST XBM JOB TERMINATE (RE-OPEN).
         OI    PDBFLAG1,PDB1NULL   ELSE, SHOW UNOPENED DATASET - BATCH
         ST    RBUF,PDBMTTR        MONITOR WILL OPEN WHEN NECESSARY.
         B     HJS620              CONTINUE WITH NEXT SDB.
         SPACE 1
* RE-OPEN OUTPUT DATA SET
HJS630   DS    0H
*              THIS LINE DELETED BY APAR NUMBER                @OZ18630
         LA    R1,SDBTAB           POINT TO TRACK ALLOC BLOCK  @OZ18630
         CALL  $STRAK              GET A TRACK FOR DATA SET.
         ST    R1,PDBMTTR          STORE TRACK IN PDDB.
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
         LR    R0,R1               CONVERT
         LA    R1,X'100'           TRACK ADDRESS
         SRDL  R0,8                TO RBA.
         STM   R0,R1,SDBTRKF       SET STARTING TRACK.
         STM   R0,R1,SDBTRK        SET CURRENT TRACK.
         STM   R0,R1,BFRBA         SET RBA IN BUFFER.
*              THIS LINE DELETED BY APAR NUMBER                @OZ29019
*              THIS LINE DELETED BY APAR NUMBER                @OZ29019
*              THIS LINE DELETED BY APAR NUMBER                @OZ29019
*              THIS LINE DELETED BY APAR NUMBER                @OZ29019
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
         CLC   SDBDKEY,=AL2(PDBOUHJL)  IF NOT JES2 JOB LOG,    @OZ79713
         BNE   HJS620              CONTINUE WITH NEXT SDB.
*              THIS LINE DELETED BY APAR NUMBER                @OZ29148
* RE-TITLE THE JES2 JOB LOG
         L     R0,=A(HASPAM)       GET HAM ADDRESS.
         ST    R0,SJBLACB+ACBINRTN-IFGACB  DE-NULLIFY JOB LOG.
         LM    R2,R3,=A(HJLHDR,HJLHDL)  POINT TO TITLE, LENGTH.
         MVC   BFDAT(HJLHDL),0(R2) MOVE TITLE INTO BUFFER.
         L     R0,BFLEN            REDUCE
         SLR   R0,R3               REMAINING LENGTH
         ST    R0,BFLEN            BY TITLE LENGTH.
         AL    R3,BFLOC            INCREASE BUFFER OFFSET
         ST    R3,BFLOC            BY TITLE LENGTH.
         BAL   R14,HJSMSG1         WTO 'HASP373 STARTED'.
         LA    R1,SJBLRPL          POINT TO RPL                @OZ44947
         ENDREQ RPL=(1)            WRITE JOB LOG TO SPOOL      @OZ44947
         B     HJS620              CONTINUE WITH NEXT SJB.
* RE-OPEN THE BATCH INPUT DATA SET
HJS640   DS    0H
         MVC   SDBMTTR,PDBMTTR     MOVE TRK ADR FOR CONVERSION.
         CALL  HCNVFDAD            CONVERT TRACK ADDRESS.
         EXCP  SDBIOB              READ FIRST RECORD.
         WAIT  1,ECB=SDBECB        WAIT TILL IT'S READ.
         B     HJS620              CONTINUE WITH NEXT SDB.
HJS660   DS    0H
*
*
*              RETURN TO HAMGET TO CONTINUE
*              EXECUTION BATCH MONITOR OPERATION
*
*
         CALL  HCBCK               CHECKPOINT CONTROL BLOCKS.
         SL    R12,=A(HJSBASE-SVCHBASE)  ADJUST BASE TO SVCHAM.
         USING SVCHBASE,R12        TELL THE ASSEMBLER.
         B     SX100               RETURN TO SVCXBM.
         USING HJSBASE,R12         RESTORE LOCAL ADDRESSABILITY.
         EJECT
*
*
*              ERROR EXITS FROM JOB SELECT
*
*
HJS800   DS    0H
*
*
*              UNABLE TO ACQUIRE COMMON STORAGE FOR
*              SUBSYSTEM JOB BLOCK,  OR NORMAL INITIATOR STOP,
*              OR CONVERTER/INTERPRETER ERROR IF SELECT-
*              BY-JOB-ID
*
*
         $MID  350                 SET HASP MESSAGE ID.
         WTO   '&MID.INIT STOPPED',ROUTCDE=2,DESC=4 WRITE MSG.
HJS805   DS    0H
         LA    R10,SSJSISTP        ASSUME NORMAL STOP CODE.
         LTR   R12,R12             IF NO SJB COULD BE GOT,
         BNM   HJS820              RETURN NORMAL STOP CODE.
         TM    SJBFLG1,SJB1SJID    IF NOT SELECT-JOB-BY-ID,
         BZ    HJS810              FREE SJB AND RETURN NORMAL.
         L     R0,SSJSSERR         IF NOT ERROR FROM CONVERTER
         LTR   R0,R0               OR INTERPRETER, RETURN
         BZ    HJS810              NORMAL STOP CODE.
         LA    R10,SSJSYSER        ELSE RETURN SYSTEM ERROR.
HJS810   DS    0H
         CALL  $SJBFREE            FREE THE SJB.
HJS820   DS    0H
         LR    R15,R10             SET RETURN CODE IN R15
         B     HJS950              AND RETURN TO INITIATOR.
         SPACE 3
HJS830   DS    0H
*
*
*              INSUFFICIENT COMMON STORAGE OR PRIVATE STORAGE TO
*              INITIATE A JOB.  CAUSE INITIATOR TO TERMINATE
*              AND JOB (UNLESS SELECTED BY ID) TO RERUN.
*
*
         OI    SJBFLG2,SJB2PNIT    CAUSE NEXT SELECT TO END INIT.
         TM    SJBFLG1,SJB1SJID    IF SELECT-JOB-BY-ID,
         BO    HJS840              DON'T RE-RUN JOB.
         OI    SJBFLG1,SJB1EJOB    ELSE CAUSE JOB TO RERUN.
HJS840   DS    0H
*
*
*              TERMINATE JOB BY CALLING HOSTERM
*
*
         SL    R12,=A(HJSBASE-HJEBASE)  ADJUST BASE TO HOSTERM.
         USING HJEBASE,R12         TELL THE ASSEMBLER.
         B     HJEJBSL             TERMINATE THE SELECTED JOB.
         USING HJSBASE,R12         RESTORE LOCAL ADDRESSABILITY.
HJS850   DS    0H
*
*
*              JOB NOT FOUND BUT SELECTED BY ID
*
*
         $MID  361                 SET HASP MESSAGE ID.
         WTO   '&MID.JOB NOT FOUND',ROUTCDE=10,DESC=6
         CALL  $SJBFREE            FREE THE SJB.
         LA    R15,SSJSPERR        SET PROGRAM ERROR CODE.
         B     HJS950              RETURN TO THE INITIATOR.
         SPACE 3
HJS870   DS    0H
*
*
*              JOB JOURNAL ABSENT BUT REQUIRED
*
*
         $MID 374                  SET MESSAGE ID.
         WTO   '&MID. - JOB HAS NO JOURNAL',ROUTCDE=11,DESC=6
         B     HJS840              GO TERMINATE THE JOB.
         EJECT
HJS900   DS    0H
*
*
*              NORMAL RETURN FROM JOB SELECTION TO INITIATOR
*
*
         OI    JCTFLAG1,JCT1CKPT   FLAG JCT FOR CKPT           @OZ31931
         CALL  HCBCK               CHECKPOINT JOB CONTROL BLOCKS.
         SLR   R15,R15             RETURN ZERO CODE - JOB SELECT
*                                  WORKED OKAY.
         SPACE 3
HJS950   DS    0H
         $EPILOG ,                 RETURN TO INITIATOR.
*
*              SUBROUTINE TO WRITE MESSAGE HASP373
*
         $MID  373                 SET MESSAGE ID.
HJSMSG1  DS    0H
         TM    SJBFLG1,SJB1SJID    IF SELECT-BY-CLASS,
         BZ    HJSMSG11            BRANCH.
         WTO   '&MID.STARTED',ROUTCDE=2,DESC=6
         BR    R14                 WRITE SHORT MSG, RETURN.
HJSMSG11 DS    0H
         L     R7,SJBJCT           POINT R7 TO JCT.
         MVC   HJSMSG1Z,HJSMSG1A   MOVE MESSAGE.
         MVC   HJSMSG1Y,SJBPATID   MOVE INITIATOR ID.
         MVC   HJSMSG1X,SJBJCLAS   MOVE CLASS ID.
         MVC   HJSMSG1W,JCTCPUID   MOVE SYSTEM ID.
         WTO   MF=(E,JCTWORK)      WRITE MESSAGE.
         DROP  R7                  DROP JCT BASE.
         BR    R14                 RETURN.
HJSMSG1A WTO   '&MID.STARTED - INIT XX - CLASS Y - SYS ZZZZ',          C
               ROUTCDE=2,DESC=6,MF=L
HJSMSG1B EQU   *
HJSMSG1Z EQU   JCTWORK,HJSMSG1B-HJSMSG1A  MESSAGE
HJSMSG1Y EQU   JCTWORK+4+9+15,2    INITIATOR ID                      R4
HJSMSG1X EQU   JCTWORK+4+9+26,1    CLASS ID                          R4
HJSMSG1W EQU   JCTWORK+4+9+34,4    SYSTEM ID                         R4
         EJECT                                                      R41
         USING JCTDSECT,R7         PROVIDE JCT ADDRESSABILITY       R41
         DROP  RBUF                RE-ESTABLISH                     R41
         USING BFDSECT,WA           BUFFER ADDRESSABILITY           R41
         SPACE 1                                                    R41
HJSREOPN TM    JCTJSFLG,SSJSWARM   TEST FOR WARM START              R41
         BO    *+10                BR IF YES TO REPOSITION          R41
         TM    JCTJBOPT,JCTRERUN   TEST FOR JOB RE-RUN              R41
         BZR   WE                  RETURN IF NO WITH VALID CC       R41
         SPACE 1                                                    R41
         CALL  HOOLDINP            OPEN DATA SET FOR INPUT          R41
         BNZ   HJS830              BR IF INSUFFICIENT STORAGE       R41
         ST    WA,SDBMTTR          SET CONTINUATION TRACK ADDR      R41
         CALL  HCNVFDAD            SET TRACK ADDRESS IN IOB         R41
         L     WA,SDBUBF           POINT TO UNPROTECTED BUFFER      R41
         SPACE 1                                                    R41
HJSIO    DS    0H                                              @OZ41000
         EXCP  SDBIOB              START I/O OPERATION              R41
         WAIT  1,ECB=SDBECB        WAIT FOR I/O COMPLETION          R41
         TM    SDBFLG2,SDB2IOE+SDB2EOD  TEST I/O STATUS             R41
         BNZ   HJSBFLST            BR IF ERROR OR EOD               R41
         OI    BFFL1,BF1EOB        ALLOW UBF REFILL                 R41
         B     HJSIO               BR TO READ NEXT BUFFER           R41
         SPACE 1                                                    R41
HJSBFLST L     R0,SDBMTTR          GET                              R41
         TM    SDBFLG2,SDB2IOE      CONTINUATION                    R41
         BO    HJSRBTAB              TRACK                          R41
         ICM   R0,15,SDBTRK+1         ADDRESS                       R41
         SPACE 1                                                    R41
HJSRBTAB CALL  HJSRETAB            RE-BUILD TRACK ALLOC. BLOCK      R41
         XI    SDBFLG1,SDB1GET+SDB1PUT  RESET FOR OUTPUT            R41
         MVI   SDBCCW4,5           SET CCW FOR DATA WRITES          R41
         MVI   SDBCHEND,SDBCEPUT   SET CHANNEL-END OPTION           R41
         TM    SDBFLG2,SDB2IOE     TEST I/O STATUS                  R41
         BO    HJSIOE              BR IF ERROR (RAN OFF END)        R41
         MVC   SDBMTTR,SDBTRK+1    RESET TRACK ADDRESS              R41
         CLI   BFDAT,LRCBFEND      TEST FOR LOGICALLY EMPTY BFR     R41
         BE    HJSIOE              BR IF SO TO RE-USE BUFFER        R41
         L     R1,=A(HFCMSG)       POINT TO 'JOB DELETED' TEXT      R41
         CLC   BFDAT(HFCMSGL),0(R1)  TEST FOR SAME                  R41
         BE    HJSIOE              BR IF SO TO RE-USE BUFFER        R41
         CALL  HCNVFDAD            SET TRACK ADDRESS IN IOB         R41
         LA    R1,SDBTAB           POINT TO TRACK ALLOC. BLOCK      R41
         CALL  $STRAK              GET TRACK FOR NEXT BUFFER        R41
         L     WA,SDBPBF           POINT TO PROTECTED BUFFER        R41
         ST    R1,BFNXT            SET CHAIN TRACK ADDRESS          R41
         LR    WA,R1               SAVE NEW TRACK ADDRESS           R41
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         EXCP  SDBIOB              START I/O OPERATION              R41
         WAIT  1,ECB=SDBECB        WAIT FOR I/O COMPLETION          R41
         ST    WA,SDBMTTR          SET NEW TRACK ADDRESS            R41
         B     HJSNXTBF            BR TO CONTINUE                   R41
         SPACE 1                                                    R41
HJSIOE  $FREEBUF TYPE=PROT,A=SDBPBF  FREE PROTECTED BUFFER          R41
         L     R7,SJBJCT           RESTORE JCT ADDRESS IN R7        R41
         SLR   R1,R1               CLEAR                            R41
         ST    R1,SDBPBF            BUFFER ADDRESS                  R41
         SPACE 1                                                    R41
HJSNXTBF L     R0,SDBMTTR          GET TRACK ADDRESS                R41
         LA    R1,X'100'           CONVERT TO                       R41
         SRDL  R0,8                 RBA FORMAT                      R41
         L     WA,SDBUBF           POINT TO UNPROTECTED BUFFER      R41
         STM   R0,R1,SDBTRK        SET RBA IN SDB                   R41
         STM   R0,R1,BFRBA          AND IN BUFFER                   R41
         LH    R0,$SVBFSIZ         GET BUFFER SIZE                  R41
         SL    R0,=A(BFDAT+1-BFIO) SET LENGTH                       R41
         ST    R0,BFLEN             OF DATA AREA                    R41
         LA    R1,BFDAT            SET POINTER IN UBF          @OZ25160
         ST    R1,BFLOC            FOR FIRST LOGICAL RECORD    @OZ25160
         SLR   R1,R1               CLEAR                            R41
         ST    R1,BFTRK             TRACK ADDRESS                   R41
         ST    R1,BFNXT              AND CHAIN ADDRESS              R41
         MVC   BFKEY,SDBJKEY       ENSURE VALID DATA SET KEY        R41
         NI    SDBFLG2,255-SDB2EOD-SDB2IOE  RESET FLAGS             R41
         SLR   R15,R15             SET NON-ZERO CONDITION CODE      R41
         BR    WE                  RETURN TO CALLER                 R41
         EJECT                                                      R41
***********************************************************************
*                                                                     *
*        HJSRETAB -- SUBROUTINE TO REBUILD SDB TRK ALLOC'N BLK        *
*                                                                     *
* INPUT  R0    - RESUME MTTR, VALID ON EXIT                           *
*        R10   - SDB ADDRESS                                          *
*        R13   - SAVE AREA ADDRESS                                    *
*        R14   - RETURN ADDRESS                                       *
*        R15   - ENTRY POINT ADDRESS                                  *
*                                                                     *
***********************************************************************
         SPACE 1                                                    R41
         USING TABDSECT,R14        PROVIDE TAB ADDRESSABILITY       R41
         USING HJSRETAB,R15        PROVIDE LOCAL ADDRESSABILITY     R41
         SPACE 1                                                    R41
HJSRETAB STM   R14,R2,12(R13)      SAVE REGISTERS                   R41
         LA    R14,SDBTAB          ADDRESS TAB IN SDB               R41
         LR    R2,R0               COMPUTE                          R41
         SRL   R2,24                TRACK-EXTENT-DATA               R41
         MH    R2,=Y(TEDSIZ)         BLOCK                          R41
         AL    R2,$SVTFRST            ADDRESS                       R41
         LH    R2,TNRT-TEDDSECT(,R2)  SET MAX RECORD                R41
         STC   R2,TABMAXR                NUMBER IN TAB              R41
         ST    R0,TABMTTR          SET MTTR IN TAB                  R41
         MVI   TABSPN,1            INIT SUB-PERM VALUE IN TAB       R41
         IC    R2,$SVRINCR         R2 = &RECINCR                    R41
         IC    R0,=X'01'           MTT1 -- 1ST RECORD ON TRACK      R41
         SLR   R1,R1               CLEAR BUFFER COUNT               R41
         SPACE 1                                                    R41
HRETAB10 IC    R1,$SVTKCEL         SET FOR MAX TRACK-CELL           R41
         SPACE 1                                                    R41
HRETAB20 CLM   R0,1,TABMTTR+3      SEARCH FOR RECORD                R41
         BE    HRETAB40            BR IF FOUND                      R41
         ALR   R0,R2               INCR MTTR BY &RECINCR            R41
         CLM   R0,1,TABMAXR        TOO HIGH FOR TRACK...            R41
         BNH   HRETAB30            BR IF NO                         R41
         IC    R0,TABSPN            ELSE INCR SUB-PERM              R41
         AL    R0,=F'1'              VALUE AND RESET                R41
         STC   R0,TABSPN              TRACK ADDRESS (MTTP)          R41
         SPACE 1                                                    R41
HRETAB30 BCT   R1,HRETAB20         DECR BUFFER COUNT                R41
         B     HRETAB10            NEW TRACK CELL IF ZERO           R41
         EJECT                                                      R41
HRETAB40 MVC   12(1,R13),TABSPN    SAVE SUB-PERM VALUE              R41
         STC   R1,TABUFCNT         SAVE BUFFER COUNT, SO FAR        R41
         SPACE 1                                                    R41
HRETAB50 BCT   R1,HRETAB60         DECR BUFFER COUNT                R41
         B     HRETAB70            BR IF LAST RECORD IN CELL        R41
         SPACE 1                                                    R41
HRETAB60 ALR   R0,R2               INCR MTTR BY &RECINCR            R41
         CLM   R0,1,TABMAXR        TOO HIGH FOR TRACK...            R41
         BNH   HRETAB50            LOOP IF NOT                      R41
         CLM   R2,1,12(R13)        ENTIRE TRACK DEPLETED...         R41
         BNH   HRETAB70            RETURN IF YES -- SHORT CELL      R41
         IC    R0,12(,R13)          ELSE INCR SUB-PERM              R41
         AL    R0,=F'1'              VALUE AND RESET                R41
         STC   R0,12(,R13)            TRACK ADDRESS (MTTP)          R41
         B     HRETAB50            BR TO CONTINUE                   R41
         SPACE 1                                                    R41
HRETAB70 IC    R2,TABUFCNT         SET REMAINING                    R41
         SLR   R2,R1                BUFFER COUNT                    R41
         BCTR  R2,0                  IN                             R41
         STC   R2,TABUFCNT            TAB                           R41
         LM    R14,R2,12(R13)      RESTORE REGISTERS                R41
         BR    R14                 RETURN TO CALLER                 R41
         SPACE 1                                                    R41
         DROP  R15                 KILL LOCAL ADDRESSABILITY        R41
         EJECT                                                      R41
*                                                                   R41
*                                                                   R41
*              JOB SELECT SUBROUTINE TO READ IOTS
*
*
HJSRDIOT DS    0H
         SL    R2,=A(IOTIOTTR-IOTDSECT)  CHAIN TRACK ADDRESS.
         SL    R3,=A(IOTIOT-IOTDSECT)  CHAIN STORAGE ADDRESS.
* R1 POINTS TO NEW IOT
* R2 POINTS TO PREVIOUS IOT OR TO JCT, FOR TRACK ADDRESS
* R3 POINTS TO PREVIOUS IOT OR TO SJB, FOR STORAGE ADDRESS
HJSRI10  DS    0H
         L     R0,IOTIOTTR-IOTDSECT(,R2)  GET NEXT IOT TRACK.
         LTR   R0,R0               IF ZERO, IOT CHAIN
         BZR   R4                  IS COMPLETE - RETURN.
         CALL  HCBGM               GET STORAGE FOR ANOTHER IOT.
         BNZ   HJS830              BRANCH IF NO STORAGE AVAILABLE.
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT READ IN SJB    @OZ78293
         CALL  HCBRD               READ IN THE IOT.
         BNZ   HJSRI20             BRANCH IF READ ERROR.
         ST    R15,IOTIOT-IOTDSECT(,R1)  ZERO IOT CHAIN POINTER.
         ST    R1,IOTIOT-IOTDSECT(,R3)  CHAIN PREV IOT TO THIS.
         LR    R2,R1               POINT TRACK CHAIN REG AND
         LR    R3,R1               STOR CHAIN REG TO THIS IOT.
         B     HJSRI10             TRY FOR ANOTHER IOT.
* ERROR RETURNED FROM READ - FREE LAST IOT AND RETURN
HJSRI20  DS    0H
         CALL  HCBFM               FREE IOT STORAGE.
         B     HJS840              CAUSE JOB TO TERMINATE.
         DROP  ,                   DROP ALL BASES.
         EJECT                                                      R41
         LTORG                                                      R41
         TITLE 'HOSTERM - SUBSYSTEM JOB TERMINATION FUNCTION'
*
*
*              HOSTERM - SUBSYSTEM JOB TERMINATION FUNCTION
*
*
HOSTERM  $PROLOG SSOBTERM,SSJTSIZE,LOCK=REQ
HJEBASE  DS    0H
*
*
*              ENTRY POINT HOSTERM ---
*              TERMINATE REGULAR JOB
*              TERMINATE EXECUTION BATCH MONITOR, WITH OR WITHOUT
*                 USER JOB
*              TERMINATE STARTED TASK
*
*
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         USING SSJTBGN,RSOX        SET SSOB EXT ADDRESSABILITY.
         USING SSIB,RSIB           SET SSIB ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         USING JCTDSECT,R7         SET JCT ADDRESSABILITY.
* SET INITIAL TERMINATION CONTROL FLAGS
         MVI   SJBFLG3,SJB3CLS+SJB3FSDB+SJB3FIOT+SJB3CKPT+SJB3FJCT
         MVI   SJBFLG4,0           ZERO 2D TERMINATION FLAGS.
         L     R7,SJBJCT           LOAD JCT BASE REGISTER.
* IF EXECUTION BATCH MONITOR WITHOUT USER JOB AVOID CLOSE, CKPT
         TM    SJBFLG1,SJB1XBM     IF NOT BATCH MONITOR ENDING,
         BZ    HJET10              GO CHECK STARTED TASK.
         OI    SJBFLG1,SJB1XBMR    CAUSE XBM FLAG TO RESET LATER.
         TM    SJBFLG1,SJB1XBMC+SJB1XBWT  IF MONITOR ENDING WITH
         BZ    HJET20              JOB, TREAT AS ORDINARY.
         NI    SJBFLG3,255-SJB3CLS-SJB3CKPT  ELSE NO CLOSE, CKPT.
         B     HJE000              ENTER TERMINATION.
HJET10   DS    0H
* IF STARTED TASK IS TERMINATING, FREE SJB, NULLIFY JCL PDDB,
* WRITE 'ENDED'
         TM    SJBFLG1,SJB1SJID    IF NOT STARTED TASK,
         BZ    HJET20              GO CHECK RE-EXECUTE FLAG.
         OI    SJBFLG3,SJB3TERM    SHOW JOB READY TO TERMINATE.
         OI    SJBFLG4,SJB4MEND+SJB4FSJB  CAUSE SJB TO FREE.
         B     HJET80              GO MOVE JMR.
HJET20   DS    0H
* IF JOB IS TO RESTART (HASP COMMAND $EJOB), PARTIALLY PURGE
* OUTPUT TRACK GROUPS, WRITE 'QUEUED FOR RE-EXECUTION'
         TM    SJBFLG1,SJB1EJOB    RE-RUN REQUESTED...              R41
         BO    HJERERUN            BR IF YES TO FORCE RE-QUEUE      R41
         TM    JCTJOBFL,JCTRSTRT   IS JOB RESTARTABLE...            R41
         BZ    HJET30              BR IF NO (TERMINATE JOB)         R41
         TM    JCTJSFLG,SSJSWARM   HAD JOB WARM STARTED...          R41
         BZ    HJET30              BR IF NO (TERMINATE JOB)         R41
         TM    JCTJBOPT,JCTRERUN   HAS JOB RE-RUN ALREADY...        R41
         BO    HJET30              BR IF YES (TERMINATE JOB)        R41
         SPACE 1                                                    R41
HJERERUN OI    SJBFLG1,SJB1EJOB    FORCE JOB TO RE-RUN              R41
         OI    JCTJBOPT,JCTRERUN   INDICATE RE-RUN REQUEST          R41
         SLR   R0,R0               GET ZEROS IN REGISTER
         STH   R0,JCTJSSTP         KILL RESTART STEP IN JCT
         STC   R0,JCTJSFLG         KILL RESTART FLAGS IN JCT
         OI    SJBFLG3,SJB3PPOU    ELSE PURGE PARTIAL OUTPUT
         OI    SJBFLG4,SJB4MREX    AND WRITE 'QUEUED FOR RE-EXEC'.
         ICM   R1,7,SSJTJMR+1      POINT TO JMR-IF NO JMR,     @OZ27662
         BZ    HJE000              ENTER TERMINATION.          @OZ27662
         MVC   JCTUSEID,JCTUSEID-JCTJMR(R1)  XFER USER INFO    @OZ27662
         MVC   JCTUCOM,JCTUCOM-JCTJMR(R1)      FROM SWA JMR.   @OZ27662
         B     HJE000              ENTER TERMINATION.
HJET30   DS    0H
* REGULAR JOB END, OR XBM WITH USER JOB - NULLIFY JCL PDDB,
* WRITE 'ENDED'
         OI    SJBFLG3,SJB3TERM    SHOW JOB READY TO TERMINATE.
         OI    SJBFLG4,SJB4MEND    WRITE 'ENDED'.
         B     HJET80              GO MOVE JMR.
HJET80   DS    0H
* MOVE JMR BACK INTO HASP JOB CONTROL TABLE
         TM    SJBFLG1,SJB1XBM     IF BATCH MONITOR ENDING,    @OZ26957
         BO    HJE000              ENTER TERMINATION.          @OZ26957
         L     R1,SSJTJMR          POINT TO JMR TO MOVE.
         LTR   R7,R7               IF NO JCT,
         BZ    HJE000              ENTER TERMINATION.
         LTR   R1,R1               IF JMR DOESN'T EXIST,
         BZ    HJE000              ENTER TERMINATION.
         MVC   JCTJMR,0(R1)        MOVE JMR INTO HASP JCT.
         B     HJE000              ENTER TERMINATION.
         SPACE 3
*
*
*              ENTRY POINT HJERENQ ---
*              RE-ENQUEUE JOB FOR OS RESTART
*
*
HJERENQ  DS    0H
         NI    SJBFLG1,255-SJB1EJOB  RESET POSSIBLE RESTART-JOB.
         MVI   SJBFLG3,SJB3CLS+SJB3FSDB+SJB3FIOT+SJB3CKPT+SJB3FJCT
         MVI   SJBFLG4,SJB4MREQ    WRITE 'RE-ENQUEUED'.
         L     R7,SJBJCT           POINT TO THE JOB'S JCT.
         LTR   R7,R7               IF JCT DOESN'T EXIST,
         BZ    HJE000              ENTER TERMINATION.
         MVC   JCTJSSTP,SSRQSTEP   SAVE RESTART STEP IN JCT.
         MVC   JCTJSFLG,SSRQFLG1   SAVE RESTART FLAGS IN JCT.
         OI    JCTJBOPT,JCTRERUN   INDICATE RE-RUN REQUEST          R41
         TM    JCTJSFLG,SSRQHOLD   IS JOB TO BE HELD...
         BZ    SKIP60              SKIP IF NOT                       R4
         OI    SJBFLG2,SJB2HOLD    INDICATE HOLD IN SJB              R4
         XI    SJBFLG4,SJB4MREQ+SJB4MRQH  RESET MREQ, SET MRQH.
*        UPDATE SMF INFORMATION BEFORE EXITING                 @OZ41529
SKIP60   L     R1,PSATOLD-PSA      FIND CURRENT TCB            @OZ41529
         ICM   R1,7,TCBTCTB-TCB(R1) GET 24-BIT TCT ADDRESS     @OZ41529
         BZ    HJE000              BR IF NO SMF                @OZ41529
         L     R1,TCTJMR-SMFTCT(,R1) GET JMR ADDRESS           @OZ41529
         MVC   JCTUSEID,JCTUSEID-JCTJMR(R1) XFER USER INFO     @OZ41529
         MVC   JCTUCOM,JCTUCOM-JCTJMR(R1)    FROM SWA JMR      @OZ41529
         B     HJE000              ENTER TERMINATION           @OZ41529
         SPACE 3
*
*
*              ENTRY POINT HJEJBSL ---
*              TERMINATE SELECTED REGULAR JOB, USER JOB (XBM),
*                 STARTED TASK, OR CREATED-ID JOB
*              RERUN SELECTED REGULAR OR USER JOB
*
*
HJEJBSL  DS    0H
* RESTORE RSIB AND RSOX TO THEIR CORRECT VALUES
         L     R1,4(,R13)          POINT TO CALLER'S SAVE AREA.
         L     R1,24(,R1)          GET ENTRY REGISTER 1.
         USING SSOBEGIN,R1         SET SSOB ADDRESSABILITY.
         L     RSIB,SSOBSSIB       SET SSIB BASE.
         L     RSOX,SSOBINDV       SET SSOB EXT BASE.
         DROP  R1                  DROP REGISTER 1 AS SSOB BASE.
* SET INITIAL TERMINATION FUNCTION FLAGS
         MVI   SJBFLG3,SJB3CLS+SJB3CKPT  CAUSE CLOSE & CKPT.
         MVI   SJBFLG4,0           ZERO 2D TERMINATION FLAG.
         L     R7,SJBJCT           LOAD JCT BASE REGISTER.
* IF XBM CONTINUATION FLAG OFF, NO NEED TO PRESERVE SDB, IOTS,
* JCT
         TM    SJBFLG1,SJB1XBMC    IF EXECUTION BATCH MON CONT,
         BO    HJES30              GO PROCESS IT.
         OI    SJBFLG3,SJB3FSDB+SJB3FIOT+SJB3FJCT  CAUSE FREEING.
         OI    SJBFLG1,SJB1XBMR    CAUSE RESET OF SJB1XBM.
* IF STARTED TASK, FREE SJB, NULLIFY JCL PDDB, WRITE 'TERMINATED'
         TM    SJBFLG1,SJB1SJID    IF NOT STARTED TASK,
         BZ    HJES10              CHECK FOR RE-EXECUTION.
         OI    SJBFLG3,SJB3TERM    SHOW JOB READY TO TERMINATE.
         OI    SJBFLG4,SJB4MTRM+SJB4FSJB  WRITE 'TERMINATED'.
         B     HJE000              ENTER TERMINATION.
HJES10   DS    0H
* IF JOB IS TO RESTART ($EJOB), PURGE PARTIAL OUTPUT,
* WRITE 'QUEUED FOR RE-EXECUTION'.
         TM    SJBFLG1,SJB1EJOB    IF NO RE-EXECUTION,
         BZ    HJES20              SET UP NORMAL SELECT FAILURE.
         SLR   R0,R0               GET ZEROS IN REGISTER
         STH   R0,JCTJSSTP         KILL RESTART STEP IN JCT
         STC   R0,JCTJSFLG         KILL RESTART FLAGS IN JCT
         OI    SJBFLG3,SJB3PPOU    ELSE PURGE PARTIAL OUTPUT,
         OI    SJBFLG4,SJB4MREX    WRITE 'QUEUED FOR RE-EXEC'.
         B     HJE000              ENTER TERMINATION.
* OTHERWISE NULLIFY JCL PDDB, WRITE 'TERMINATED'
HJES20   DS    0H
         OI    SJBFLG3,SJB3TERM    SHOW JOB READY TO TERMINATE.
         OI    SJBFLG4,SJB4MTRM    WRITE 'TERMINATED'.
         B     HJE000              ENTER TERMINATION.
* XBM CONTINUATION - ONLY WRITE MESSAGE
HJES30   DS    0H
         MVI   SJBFLG3,0           DO NOTHING.
         MVI   SJBFLG4,SJB4MTRM    WRITE 'TERMINATED'.
         TM    SJBFLG1,SJB1EJOB    IF THAT'S CORRECT,
         BZ    HJE000              ENTER TERMINATION.
         MVI   SJBFLG4,SJB4MREX    WRITE 'QUEUED FOR RE-EXEC'.
         B     HJE000              ENTER TERMINATION.
         SPACE 3
*
*
*              ENTRY POINT HJERTRN ---
*              TERMINATE CREATED-ID JOB (E.G., SYSTEM LOG)
*
*
HJERTRN  DS    0H
         MVI   SJBFLG3,SJB3CLS+SJB3FSDB+SJB3FIOT+SJB3CKPT+SJB3FJCT
         MVI   SJBFLG4,SJB4FSJB    CAUSE SJB TO FREE, NO MSG.
         L     R7,SJBJCT           LOAD JCT BASE REGISTER.
         B     HJE000              ENTER TERMINATION.
         SPACE 3
*
*
*        ENTRY POINT HJEXBM ---
*              TERMINATE USER JOB THAT RAN UNDER AN EXECUTION
*                 BATCH MONITOR.  LEAVE ENVIRONMENT SUITABLE FOR
*                 RUNNING ANOTHER USER JOB.
*
*
HJEXBM   DS    0H
         MVI   SJBFLG3,SJB3CLS+SJB3CKPT+SJB3TERM  SET FLAGS.
         MVI   SJBFLG4,SJB4MEND    SET MESSAGE FLAG.
         L     R7,SJBJCT           POINT TO JOB'S JCT.
         B     HJE000              ENTER TERMINATION.
         EJECT
*
*
*              COMMON ENTRY POINT AND MESSAGE WRITER
*
*
HJE000   DS    0H
         LTR   R7,R7               IF NO JCT EXISTS,
         BZ    HJE100              SKIP MESSAGE WRITING.
         CLI   JCTTSUAF,0          WAS NOTIFY REGUESTED
         BE    HJE005              IF NOT SKIP NOTIFY
         CLI   SJBXQFN1+1,SSOBJBSL WAS ENTRY FROM JOB SELECT
         BNE   *+8                 IF NOT BRANCH
         OI    JCTJTFLG,SSJTJFAL   SET JCL ERROR FLAG
         CLI   SJBXQFN1+1,SSOBTERM  WAS ENTRY FROM JOB TERM
         BNE   HJE005              IF NOT SKIP NOTIFY
         CLC   $SVRELNO,=C'02'     TEST OS/VS2 RELEASE NUMBER        R4
         BE    HJE005              IGNORE RETURN CODE IF RELEASE 2   R4
         TM    SSJTFLG1,SSJTJFAL+SSJTCFAL  JOB FAILED CC
         BNO   HJE002              IF NOT SET FLAGS
         L     R1,SSJTPCOD         LOAD POINTER TO CC
         MVC   JCTJTCC(2),0(R1)    MOVE CC TO JCT
         L     R1,SSJTPSN1         LOAD POINTER TO STEPNAME1
         MVC   JCTPSN1(8),0(R1)    MOVE STEPNAME1 TO JCT
         L     R1,SSJTPSN2         LOAD POINTER TO STEPNAME2
         MVC   JCTPSN2(8),0(R1)    MOVE STEPNAME2 TO JCT
HJE002   MVC   JCTJTFLG(1),SSJTFLG1 SET JCT JOB TERM FLAGS
* SELECT MESSAGE TO WRITE AND MOVE IT TO JCTWORK
HJE005   LA    R1,HJEM1            SET UP 'ENDED' MESSAGE.
         TM    SJBFLG4,SJB4MEND    IF CORRECT,
         BO    HJE010              WRITE MESSAGE.
         LA    R1,HJEM2            SET UP 'TERMINATED'.
         TM    SJBFLG4,SJB4MTRM    IF CORRECT,
         BO    HJE010              WRITE MESSAGE.
         LA    R1,HJEM3            SET UP 'RE-ENQUEUED'.
         TM    SJBFLG4,SJB4MREQ    IF CORRECT,
         BO    HJE010              WRITE MESSAGE.
         LA    R1,HJEM35           SET UP 'RE-ENQUEUED & HELD'.
         TM    SJBFLG4,SJB4MRQH    IF CORRECT,
         BO    HJE010              WRITE MESSAGE.
         LA    R1,HJEM4            'QUEUED FOR RE-EXECUTION'.
         TM    SJBFLG4,SJB4MREX    IF CORRECT,
         BO    HJE010              WRITE MESSAGE.
         B     HJE100              NO MESSAGE.
* WRITE THE SELECTED MESSAGE
HJE010   DS    0H
         WTO   MF=(E,(1))          WRITE TERMINATION MESSAGE.
* CONTINUE TO MORE COMMON CODE
         B     HJE100              BRANCH TO START TERMINATION.
         SPACE 3
* MESSAGES ---
         $MID 395                  HASP MESSAGE ID
HJEM1    WTO   '&MID.ENDED',ROUTCDE=2,DESC=6,MF=L
         SPACE 1
         $MID  396                 HASP MESSAGE ID
HJEM2    WTO   '&MID.TERMINATED',ROUTCDE=2,DESC=6,MF=L
         SPACE 1
         $MID  397                 HASP MESSAGE ID
HJEM3    WTO   '&MID.RE-ENQUEUED',ROUTCDE=2,DESC=6,MF=L
         SPACE 1                                                     R4
         $MID  303                 HASP MESSAGE ID                   R4
HJEM35   WTO   '&MID.RE-ENQUEUED AND HELD',ROUTCDE=2,DESC=6,MF=L
         SPACE 1
         $MID  398                 HASP MESSAGE ID
HJEM4    WTO   '&MID.QUEUED FOR RE-EXECUTION',ROUTCDE=2,DESC=6,        C
               MF=L
         EJECT
*
*
*              JOB TERMINATION CONTINUES HERE
*
*
HJE100   DS    0H
*
*              ZERO CSCB POINTER IN SJB
*
         TM    SJBFLG1,SJB1XBMC    IF XBM CONTINUING...        @OZ35973
         BO    HJE110               SKIP THIS                  @OZ35973
         SLR   R0,R0               ZERO OUT
         ST    R0,SJBCSCB          CSCB POINTER.
         SPACE 3
*
*              PURGE PSO IF PRESENT
*
HJE110   DS    0H                                              @OZ35973
         L     R6,SJBPSOP          POINT TO PSO.
         LTR   R6,R6               TEST FOR PRESENT.
         BZ    HJENPSO             SKIP PURGE IF NO PSO.
         OI    PSOFLG2-PSODSECT(R6),SSSOCTRL SET TO TERMINATE PSO.
         STM   R14,R12,SJBDSECT+12 SAVE REGISTERS
         ICM   R12,7,=AL3(HOSEOTB) POINT TO PSO PURGE BASE
         LR    R8,R13              COPY SJB POINTER
         BAL   R14,HETSOUT-HOSEOTB(,R12) ENTER PSO PURGER
         USING *,R14
         ICM   R12,7,=AL3(PSOBASE) POINT TO PSO QUEUEING ROUTINE BASE
         DROP  R14
         LR    R13,R8              RESTORE SJB POINTER
         BAL   R8,PSOQUEUE-PSOBASE(,R12) ENTER PSO TERMINATOR
         LM    R14,R12,SJBDSECT+12 RESTORE NORMAL REGISTERS
         SLR   R0,R0               ZERO
         ST    R0,SJBFLOW          FLOW INDICATORS.
HJENPSO  DS    0H
         LTR   R7,R7               IF NO JCT,
         BZ    HJEA00              DON'T DO ENDING TIME.
         TIME BIN                  GET TIME AND DATE AND
         STM   R0,R1,JCTXEQOF      SAVE THEM IN JCT.
         SPACE 3
HJEA00   DS    0H
*
*
*              CLOSE ALL SUBSYSTEM DATA SETS
*
*
         TM    SJBFLG3,SJB3CLS     ARE WE TO CLOSE DATA SETS...
         BZ    HJEA90              IF NOT, SKIP THIS CODE.
* NULLIFY FAKE-OPENED ACBS
         L     R0,=A(HAMNULL)      GET NULL ADDRESS.
         ST    R0,SJBLACB+ACBINRTN-IFGACB  NULLIFY JOB LOG.
         LTR   R7,R7               IS THERE A JCT...
         BZ    HJEA90              IF NOT, SKIP CLOSING.
         LA    RSDB,SJBSDB         POINT TO FIRST SDB ADDRESS.
         SL    RSDB,=A(SDBSDB-SDBDSECT)  SET UP TO CHAIN.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
HJEA10   DS    0H
         L     RSDB,SDBSDB         POINT TO NEXT SDB.
         LTR   RSDB,RSDB           IF NO MORE,
         BZ    HJEA80              SET UP RSOX AND CONTINUE.
         CALL  HFCLSUB             CLOSE THE DATA SET.
         B     HJEA10              THEN CONTINUE WITH NEXT SDB.
HJEA80   DS    0H
         TM    SJBFLG1,SJB1EJOB    WILL JOB RE-EXECUTE.....    @OZ46680
         BO    HJEA90              YES, DO NOT HOLD DATA.      @OZ46680
         DROP  RSDB                DROP SDB ADDRESSABILITY.
         CALL  HJEAHOLD            HOLD DATA SETS IF REQUIRED.
HJEA90   DS    0H
         SPACE 3
HJEB00   DS    0H
*
*
*              FREE ALL SUBSYSTEM DATASET BLOCKS
*
*
         TM    SJBFLG3,SJB3FSDB    IF NO SDB FREE WANTED,
         BZ    HJEB90              SKIP THIS CODE.
HJEB10   DS    0H
         L     RSDB,SJBSDB         POINT TO FIRST SDB.
         LTR   RSDB,RSDB           IF NO MORE SDBS,
         BZ    HJEB80              SET UP RSOX AND CONTINUE.
         CALL  $SDBFREE            ELSE FREE & DECHAIN SDB.
         B     HJEB10              CONTINUE FREEING SDBS.
HJEB80   DS    0H
         L     RSOX,4(,R13)        POINT TO ORIGINAL SAVE AREA.
         L     RSOX,24(,RSOX)      POINT TO SSOB.
         L     RSOX,SSOBINDV-SSOB(,RSOX)  POINT TO SSOB EXTEN.
         USING SSJTBGN,RSOX        SET SSOB EXT ADDRESSABILITY.
HJEB90   DS    0H
         SPACE 3
HJEC00   DS    0H
*
*
*              SHOW JOB READY TO TERMINATE
*
*
         L     RIOT,SJBIOT         IF NO
         LTR   RIOT,RIOT           REGULAR IOT(S),
         BZ    HJEC90              SKIP PURGE.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         LTR   R7,R7               DOES JCT EXIST...           @OZ19451
         BZ    HJEC86              BRANCH IF NOT               @OZ19451
         TM    SJBFLG1,SJB1EJOB    IS JOB TO BE RERUN...       @OZ19451
         BZ    HJEC86              NO, DONT COUNT LINES        @OZ19451
*        SET JCTLINES/JCTXOUT TO SUM OF RECORD COUNTS FOR      @OZ19451
*        JCL IMAGE, SYSTEM MESSAGE, AND JOB LOG FILES          @OZ19451
         XR    R0,R0               ZERO ACCUMULATOR            @OZ19451
         L     R15,$SVPDDB1        GET OFFSET TO FIRST PDDB    @OZ19451
         LA    R15,IOTPDBOL(,R15)  ADD JOB LOG LINES           @OZ19451
         AL    R0,PDBRECCT-PDBDSECT(R15,RIOT) TO ACCUMULATOR   @OZ19451
         LA    R15,IOTPDBOI-IOTPDBOL(,R15) ADD JCL IMAGE LNS   @OZ19451
         AL    R0,PDBRECCT-PDBDSECT(R15,RIOT) TO ACCUMULATOR   @OZ19451
         LA    R15,IOTPDBOM-IOTPDBOI(,R15) ADD SYS MSG LINES   @OZ19451
         AL    R0,PDBRECCT-PDBDSECT(R15,RIOT) TO ACCUMULATOR   @OZ19451
         ST    R0,JCTLINES         SET PRINT OUTPUT AND        @OZ19451
         ST    R0,JCTXOUT           TOTAL OUTPUT COUNTS        @OZ19451
HJEC86   DS    0H                                              @OZ19451
         TM    SJBFLG3,SJB3TERM    IF JOB NOT TERMINATING,
         BZ    HJEC90              SKIP THIS CODE.
         AL    RIOT,$SVPDDB1        ELSE POINT TO JCL PDDB           R4
         OI    IOTPDBOJ+PDBFLAG1-PDBDSECT(RIOT),PDB1NULL             R4
HJEC90   DS    0H
         SPACE 3
HJED00   DS    0H
*
*
*              PERFORM PARTIAL PURGE OF OUTPUT IOT TRACK GROUPS
*
*
         L     RIOT,SJBIOT         IF JOB HAS
         LTR   RIOT,RIOT           NO IOT(S),
         BZ    HJED90              SKIP PURGE.
         OI    IOTFLAG1,IOT1CKPT   FLAG 1ST IOT FOR CHECKPOINT.
         TM    SJBFLG3,SJB3PPOU    IS PARTIAL OUTPUT PURGE NEEDED
         BZ    HJED90              IF NOT, SKIP THIS CODE.
         LTR   R7,R7               IF NO JCT,
         BZ    HJED90              SKIP THE FUNCTION.
* NEXT, NULLIFY ALL PDDBS ALLOCATED DURING EXECUTION
         LH    R0,JCTPDDBO         GET DD NUMBER OF 1ST OUTPUT PDDB.
         SPACE 1
HJED20   L     R1,$SVPDDB1         GET OFFSET OF 1ST PDDB IN IOT     R4
         USING PDBDSECT,R1         PROVIDE PDDB ADDRESSABILITY.
         SPACE 1
HJED40   CL    R1,IOTPDDBP         IF HAVE LOOKED AT ALL PDDBS
         BNL   HJED60               IN THIS IOT, BR TO TRY NEXT.
         CH    R0,PDBDSKEY-PDBDSECT(R1,RIOT)  IS IT THE ONE...
         BL    HJED50              BR IF ALREADY 1ST SYSOUT         R41
         LA    R1,PDBLENG(,R1)     BUMP IN ANY CASE.
         BH    HJED40              BR IF NOT LAST DD * / DATA       R41
HJED50   DS    0H                                                   R41
         ST    R1,IOTPDDBP         RESET OFFSET IN IOT.
         XC    IOTIOTTR,IOTIOTTR   TRUNCATE THE IOT CHAIN.
         OI    IOTFLAG1,IOT1CKPT   FLAG THE IOT FOR CHECKPOINT.
         B     HJED90              THEN CONTINUE.
         SPACE 1
HJED60   ICM   RIOT,15,IOTIOT      IF ANOTHER IOT,
         BNZ   HJED20              BR TO SCAN IT.
HJED90   DS    0H
         SPACE 3
HJEF00   DS    0H
*
*
*              CHECKPOINT CONTROL BLOCKS AS REQUIRED
*
*
         TM    SJBFLG3,SJB3CKPT    IS CHECKPOINTING CALLED FOR...
         BZ    HJEF90              SKIP THIS CODE IF NOT.
         L     RIOT,SJBIOT         POINT TO THE 1ST IOT.
HJEF10   DS    0H
         LTR   R1,RIOT             IF NO MORE IOTS,
         BZ    HJEF90              BR TO FREE STORAGE.
         TM    IOTFLAG1,IOT1CKPT   IF NO CHECKPOINT REQUIRED,
         BZ    HJEF20              GO TO NEXT IOT.
         NI    IOTFLAG1,255-IOT1CKPT  RESET CHECKPOINT FLAG.
         L     R0,IOTTRACK         GET IOT'S TRACK ADDRESS.
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE THE IOT.
HJEF20   DS    0H
         L     RIOT,IOTIOT         POINT TO NEXT IOT.
         B     HJEF10              LOOP THROUGH ALL IOTS.
HJEF90   DS    0H
         SPACE 1                                               @OZ29966
         TM    SJBFLG1,SJB1XBMC    IF XBM NOT CONTINUING       @OZ29966
         BZ    HJEG00              DON'T NULLIFY PDDB'S        @OZ29966
         ICM   RIOT,15,SJBIOT      PT TO 1ST IOT               @OZ29966
         BZ    HJEG00              SKIP IF NO IOT'S            @OZ29966
         L     R4,$SVPDDB1         PREPARE TO RESET XBM        @OZ29966
         LA    R4,IOTPDBOD-PDBLENG(RIOT,R4) SYSOUT DATASETS    @OZ29966
HJEF95   LA    R4,PDBLENG(,R4)     PT TO NEXT PDDB (IF ANY)    @OZ29966
         L     R1,IOTPDDBP         IF NOT END                  @OZ29966
         LA    R1,IOTDSECT(R1)       OF PDDB'S                 @OZ29966
         CLR   R4,R1                  IN CURRENT IOT           @OZ29966
         BL    HJEF97              GO CHANGE NULL STATUS       @OZ29966
         ICM   RIOT,15,IOTIOT      IF NO MORE IOT'S            @OZ29966
         BZ    HJEG00              GET OUT OF LOOP             @OZ29966
         L     R4,$SVPDDB1         ELSE                        @OZ29966
         ALR   R4,RIOT               PREPARE                   @OZ29966
         SL    R4,=A(PDBLENG)          TO SCAN                 @OZ29966
         B     HJEF95                    NEXT IOT              @OZ29966
         USING PDBDSECT,R4                                     @OZ29966
HJEF97   OI    PDBFLAG1,PDB1NULL   NULLIFY PDDB AGAINST REUSE  @OZ29966
         B     HJEF95              GO TEST NEXT PDDB           @OZ29966
         DROP  R4                                              @OZ29966
HJEG00   DS    0H
*
*
*              FREE STORAGE OCCUPIED BY ALL IOTS
*
*
         TM    SJBFLG3,SJB3FIOT    ARE WE TO FREE IOTS...
         BZ    HJEG90              IF NOT, SKIP THIS CODE.
HJEG10   DS    0H
         L     RIOT,SJBIOT         POINT TO THE 1ST IOT.
         LTR   R1,RIOT             IF NONE,
         BZ    HJEG90              END OF THIS SEGMENT.
         MVC   SJBIOT,IOTIOT       DECHAIN THE IOT.
         CALL  HCBFM               FREE IT.
         B     HJEG10              GO DO ANOTHER IOT.
HJEG90   DS    0H
*
*
*              UNCONDITIONALLY FREE THE OUTPUT CONTROL TABLES
*
*
HJEG100  DS    0H
         L     R1,SJBOCT           POINT TO THE OCT.
         LTR   R1,R1               IS THERE ONE...
         BZ    HJEG110             IF NOT, END OF SECTION.
         USING OCTDSECT,R1         SET OCT ADDRESSABILITY.
         MVC   SJBOCT,OCTOCT       DECHAIN OCT.
         CALL  HCBFM               FREE IT.
         B     HJEG100             GO LOOK FOR ANOTHER.
HJEG110  DS    0H
         DROP  R1                  DROP OCT ADDRESSABILITY.
*
*
*        SET INITIAL OUTPUT PRIORITY                                R41
*
*
         TM    SJBFLG3,SJB3CKPT    IF JCT NOT TO BE WRITTEN,
         BZ    HJEH00              SKIP OUTPUT PRIORITY.
         LTR   R7,R7               IF NO JCT EXISTS,
         BZ    HJEH00              SKIP.
         TM    SJBFLG1,SJB1EJOB    IF JOB NOT TO RERUN,
         BZ    HJEG115             CONTINUE OUTPUT PROPRITY.
         SLR   R0,R0               ZERO REGISTER ZERO.
*              THIS LINE DELETED BY APAR NUMBER                @OZ19451
*              THIS LINE DELETED BY APAR NUMBER                @OZ19451
         ST    R0,JCTPUNCH         PUNCH OUTPUT.
         B     HJEG140             GO WRITE THE JCT.
HJEG115  DS    0H
         LA    R0,1*16             STARTING PRIORITY = 1            R41
         TM    JCTJBOPT,JCTPRICD  IF NOT /*PRIORITY OR 'PRTY=' @OZ36378
         BNO   HJEG130             THEN USE '1'                @OZ36378
         CLI   SJBPRIO,13*16       CHECK FOR 'HIGH' PRIORITY        R41
         BL    HJEG130             USE '1' IF NOT                   R41
         LA    R0,15*16            RESET PRIO TO MAX                R41
         SPACE 1
HJEG130  DS    0H
         STC   R0,JCTIOPRI         STORE INIT OUTPUT PRTY IN JCT.
         STC   R0,SJBPRIO          PUT INITIAL OUTPUT PRTY IN SJB.
HJEG140  DS    0H
         LR    R1,R7               POINT R1 TO JCT.
         L     R0,SJBJCTRK         GET ITS TRACK IN R0.
         MVC   SJBFWORD,=CL4'JCT'  INDICATE JCT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE IT.
         SPACE 3
HJEH00   DS    0H
*
*
*              INVOKE HASPXEQ TO TERMINATE/RE-ENQUEUE THE JOB OR
*              TO CLEAN UP EXECUTION BATCH MONITOR
*
*
* ACQUIRE HASP CROSS-MEMORY-SERVICES LOCK
         CALL  $SVJLOK             GET HASP CMS LOCK.
* ACQUIRE OS LOCAL MEMORY LOCK
HJEHLL   SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE,               C
               RELATED=(HASPSSSM,(HJEHUL))
* ACQUIRE OS CROSS-MEMORY-SERVICES LOCK
HJEHLC   SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=USE,                 C
               RELATED=(HASPSSSM,(HJEHUC))
* SET AND RESET MISCELLANEOUS FLAGS ONLY UNDER LOCK
         TM    SJBFLG1,SJB1XBMR    IF XBM RESET NOT REQUIRED,
         BZ    *+8                 SKIP.
         NI    SJBFLG1,255-SJB1XBM-SJB1XBMR  RESET XBM, XBMR.
         TM    SJBFLG1,SJB1XBM+SJB1XBMC  IF NOT XBM CONTINUE,
         BNO   *+8                 SKIP.
         OI    SJBFLG1,SJB1XBWT    SHOW XBM WAITING FOR JOB.
*              FREE ANY EXTRANEOUS STORAGE CELLS
         LR    R0,R13              SET CELL PURGE
         SLR   R1,R1               PARAMETERS.
         ST    R1,SJBLOGQ          ZERO OUT LOG Q.
         LR    R6,R7               SAVE JCT POINTER
         L     R15,$SVFCELA        POINT TO CELL PURGE.
         BALR  R14,R15             PURGE CELLS.
         LR    R7,R6               RESTORE JCT POINTER
* INCREMENT $SVPIDLE IF NEITHER SJB1XBM NOR SJB1SJID
         TM    SJBFLG1,SJB1XBM+SJB1SJID  IF XBM OR SYSTEM TASK,
         BNZ   HJEH50              SKIP $SVPIDLE INCREMENT.
         L     R1,$SVPIDLE         GET CURRENT PIDLE IN R1,
         LA    R0,1(,R1)           INCREMENT PIDLE IN R0.
         CS    R1,R0,$SVPIDLE      SWITCH THEM.
         BNE   *-8                 IF INTERFERENCE, REPEAT.
HJEH50   DS    0H
* QUEUE SJB ON $SVJTERM OR $SVJRENQ FOR HASPXEQ
         LA    R1,$SVJTERM         ASSUME JOB SHOULD TERMINATE.
         CLI   SJBXQFN1+1,SSOBRENQ IF JOB SHOULD TERMINATE,
         BNE   *+8                 SKIP.
         LA    R1,$SVJRENQ         ELSE SET RE-ENQUEUE QUEUE.
         SLR   R0,R0               ZERO THE
         ST    R0,SJBECB           ECB.
* SET ASCB POINTER IN SJB FOR XMPOST (MIGHT BE EOM)
         MVC   SJBASCBP,PSAAOLD-PSA  RE-SET ASCB POINTER.
         CALL  $SJBRQ              RE-QUEUE THE SJB.
* RELEASE OS CROSS-MEMORY-SERVICES LOCK
HJEHUC   SETLOCK RELEASE,TYPE=CMS,REGS=USE,                            C
               RELATED=(HASPSSSM,(HJEHLC))
* RELEASE OS LOCAL MEMORY LOCK
HJEHUL   SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,                          C
               RELATED=(HASPSSSM,(HJEHLL))
* RELEASE HASP CROSS-MEMORY-SERVICES LOCK
         CALL  $SVJUNLK            RELEASE HASP CMS LOCK.
* POST HASPXEQ FOR JOB AND WAIT TILL IT POSTS US BACK
         $$POST ELMT=$SVJOB        POST HASP.
         WAIT  1,ECB=SJBECB        SHORT WAIT FOR REGULAR.
HJEH70   DS    0H
* SET & RESET MISCELLANEOUS FLAGS
         NI    SJBFLG1,255-SJB1EJOB  RESET RE-EXECUTE FLAG.
* DECREMENT $SVPIDLE IF NEITHER SJB1XBM NOR SJB1SJID           @OZ61523
         TM    SJBFLG1,SJB1XBM+SJB1SJID IF XBM OR SYSTEM TASK  @OZ61523
         BNZ   HJEI00              DON'T INCREMENT COUNTER     @OZ61523
         L     R1,$SVPIDLE         GET CURRENT PIDLE IN R1.    @OZ61523
HJEH75   LTR   R0,R1               AND IN R0.                  @OZ61523
         BNP   HJEI00              SKIP DECREASE IF NOT POS.   @OZ61523
         BCTR  R0,0                DECREMENT COUNT BY ONE.     @OZ61523
         CS    R1,R0,$SVPIDLE      REDUCE COUNTER              @OZ61523
         BNE   HJEH75              TRY AGAIN IF COUNT CHANGED  @OZ61523
         SPACE 2                                               @OZ61523
HJEI00   DS    0H
*
*
*              FREE THE HASP JOB CONTROL TABLE
*
*
         TM    SJBFLG3,SJB3FJCT    SHOULD WE FREE THE JCT...
         BZ    HJEI90              IF NOT, SKIP THIS CODE.
         LTR   R1,R7               IS THERE A JCT TO FREE...
         BZ    HJEI90              BRANCH IF NOT.
         SLR   R7,R7               OTHERWISE
         ST    R7,SJBJCT           ZERO SJB POINTER TO JCT
         CALL  HCBFM               AND FREE THE JCT SPACE.
HJEI90   DS    0H
         SPACE 3
HJEJ00   DS    0H
*
*
*              IF EXECUTION BATCH MONITOR, EXIT HERE
*
*
         TM    SJBFLG1,SJB1XBM     IF NOT BATCH MONITOR,
         BZ    HJEJ90              SKIP THIS CODE.
         TM    SJBFLG1,SJB1XBWT    IF NO JOB SELECTED,
         BO    HJEJ10              RETURN TO SVCXBM.
* RETURN TO HOSJBSL TO SET UP NEW USER JOB
         SL    R12,=A(HJEBASE-HJSBASE)  SET UP JOB SELECT BASE.
         USING HJSBASE,R12         SET JBSL ADDRESSABILITY.
         B     HJS200              ENTER JBSL TO START USER JOB.
         USING HJEBASE,R12         RESTORE JBTM ADDRESSABILITY.
HJEJ10   DS    0H
* RETURN TO SVCXBM TO TERMINATE EXECUTION BATCH MONITOR
         SL    R12,=A(HJEBASE-SVCHBASE)  SET SVCXBM BASE
         USING SVCHBASE,R12        AND ADDRESSABILITY.
         B     SX100               RETURN TO SVCXBM.
         USING HJEBASE,R12         RESTORE JBTM ADDRESSABILITY.
HJEJ90   DS    0H
         SPACE 3
HJEK00   DS    0H
*
*
*              IF JOB SELECTED BY ID (STARTED TASK), EXIT HERE
*
*
         TM    SJBFLG1,SJB1SJID    IF NOT STARTED TASK,
         BZ    HJEK90              SKIP THIS CODE.
* IF SUBSYSTEM FUNCTION IS JOB TERMINATE, EXIT NORMALLY.
         SLR   R15,R15             ASSUME NORMAL END.
         CLI   SJBXQFN1+1,SSOBJBSL IF IN JOB SELECT,           @OZ37780
         BE    HJEK05               SET FOR ERROR              @OZ37780
         CLI   SJBXQFN1+1,SSOBRQST IF NOT REQUEST JOBID        @OZ37780
         BNE   HJEK10               RETURN NORMALLY            @OZ37780
* IF FUNCTION IS JOB SELECT OR REQUEST JOB ID, SHOW ERROR      @OZ37780
HJEK05   DS    0H                                              @OZ37780
         LA    R15,SSJSPERR        ELSE ASSUME PROG ERROR.
* BUT IF SSJSSERR IS NONZERO, SHOW SYSTEM ERROR
         L     R0,SSJSSERR         GET CONV/INTRP CODE.
         LTR   R0,R0               IF ZERO,
         BZ    HJEK10              MUST BE PROGRAM ERROR.
         LA    R15,SSJSYSER        ELSE SHOW SYSTEM ERROR.
* SAVE RETURN CODE IN ORIGINAL SAVE AREA, R0 SLOT
HJEK10   DS    0H
         L     R1,4(,R13)          SAVE RETURN CODE
         ST    R15,20(,R1)         WHILE FREEING SJB.
         L     R1,24(,R1)          GET SSOB ADDRESS                 R41
         USING SSOBEGIN,R1         SET SSOB ADDRESSABILITY          R41
         L     RSIB,SSOBSSIB       GET SSIB ADDRESS                 R41
         XC    SSIBSUSE,SSIBSUSE   CLEAR PTR TO SJB                 R41
* FREE THE SUBSYSTEM JOB BLOCK
         CALL  $SJBFREE            FREE THE SJB.
* RESTORE RETURN CODE TO R15 AND GO TO $EPILOG
         L     R15,20(,R13)        RESTORE RETURN CODE TO R15.
         $EPILOG ,                 RETURN FROM FUNCTION.
HJEK90   DS    0H
         SPACE 3
HJEL00   DS    0H
*
*
*              IF JOB WAS SET FOR OS RESTART OR TERMINATE,
*              EXIT HERE
*
*
         CLI   SJBXQFN1+1,SSOBJBSL WAS ENTRY FROM JOB SELECT...
         BNE   HJEL10              BRANCH IF NOT.
         SL    R12,=A(HJEBASE-HJSBASE)  SET JBSL BASE.
         USING HJSBASE,R12         SET JBSL ADDRESSABILITY.
         L     R1,4(,RSJB)         POINT TO CALLER'S SAVEAREA.
         L     R1,24(,R1)          GET CALLER'S R1.
         USING SSOBEGIN,R1         SET SSOB ADDRESSABILITY.
         L     RSIB,SSOBSSIB       POINT RSIB TO SSIB.
         L     RSOX,SSOBINDV       POINT RSOX TO EXTENSION.
         DROP  R1                  DROP SSOB BASE.
         B     HJSBASE             RETURN TO JOB SELECT.
         USING HJEBASE,R12         SET JBTM ADDRESSABILITY.
HJEL10   DS    0H
         OI    SJBFLG4,SJB4TERM    SHOW BATCH JOB HAS ENDED    @OZ64778
         SLR   R15,R15
         $EPILOG ,                 RETURN WITH NORMAL CODE.
         DROP  R7,RSOX,RIOT,RSIB   DROP BASES.
         TITLE 'LITERAL POOL FOR HOSREQID - HOSTERM'
         LTORG
         TITLE 'HASP CONTROL BLOCK (JCT, IOT, OCT) SUBROUTINES'
*
*
*              GET MAIN STORAGE FOR A HASP CONTROL BLOCK
*
*
HCBGM    DS    0H
         USING *,R12               SET LOCAL ADDRESSABILITY.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET LOCAL BASE.
         LH    R1,$SVBFSIZ               GET                         R4
         LA    R0,IOTSTART-IOTDSECT(,R1)  BUFFER                     R4
        $GETMAIN RC,LV=(R0),SP=230,KEY=5   STORAGE                   R4
         ST    R15,16(,R13)        STORE R15 IN SAVE AREA.
         ST    R1,24(,R13)         STORE R1 IN SAVE AREA.
         BZ    HCBGM9              IF STORAGE GOT, SKIP MESSAGE.
         $MID  359                 WRITE OUT-OF-SP-231 MESSAGE.
         WTO   '&MID.HCBGM - NO STORAGE AVAILABLE IN SP 230',        R4C
               ROUTCDE=10,DESC=6
HCBGM9   DS    0H
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         LTR   R15,R15             SET CONDITION CODE.
         BR    R14                 RETURN TO CALLER.
         EJECT
*
*
*              FREE MAIN STORAGE FOR A HASP CONTROL BLOCK
*
*
* REGISTER 1 POINTS TO SPACE TO FREE
HCBFM    DS    0H
         USING *,R12               SET LOCAL ADDRESSABILITY.
         LTR   R1,R1               IF NO STORAGE TO FREE,
         BZR   R14                 RETURN CONDITION CODE ZERO.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET LOCAL BASE.
         LH    R3,$SVBFSIZ                   CLEAR AND FREE    @OZ41680
         LA    R0,IOTSTART-IOTDSECT(,R3)     BUFFER STORAGE    @OZ41680
         SR    R5,R5               SET TO ZERO FOR CLEAR       @OZ41680
         LA    R2,IOTSTART-IOTDSECT(R1) SET CLEAR ADDRESS      @OZ41680
         MVCL  R2,R4               CLEAR REST OF BUFFER        @OZ41680
        $FREMAIN RC,LV=(R0),SP=230,KEY=5,A=(R1),TCB=YES  STORAGE     R4
         BZ    HCBFM9              SKIP MESSAGE IF OKAY.
         $MID  371                 ELSE WRITE FREEMAIN FAILED.
         WTO   '&MID.HCBFM - FREEMAIN FAILED FOR SP 230',            R4C
               ROUTCDE=10,DESC=4
HCBFM9   DS    0H
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         SR    R15,R15             ZERO R15 AND CONDITION CODE.
         BR    R14                 RETURN TO CALLER.
         DROP  R12                 DROP LOCAL BASE.
         EJECT
*
*
*              CHECKPOINT ALL HASP CONTROL BLOCKS
*              POINTED TO BY AN SJB
*
*
HCBCK    DS    0H
         USING *,R7                SET LOCAL ADDRESSABILITY.
         LR    R7,R15              SET LOCAL BASE.
         LR    R6,R14              SAVE RETURN ADDRESS.
* CHECKPOINT REGULAR IOT(S)
         LA    R5,SJBIOT           SET ARGUMENT.
         BAL   R4,HCBCKIOT         CALL IOT CHAIN CHECKPOINTER.
* CHECKPOINT SPIN IOTS
         LA    R5,SJBSPIOT         SET ARGUMENT.
         BAL   R4,HCBCKIOT         CALL IOT CHAIN CHECKPOINTER.
* CHECKPOINT JCT
         L     R5,SJBJCT           POINT TO THE HASP JCT.
         LTR   R1,R5               IF NO JCT,
         BZR   R6                  JUST RETURN TO CALLER.
         USING JCTDSECT,R5         SET JCT ADDRESSABILITY.
         TM    JCTFLAG1,JCT1CKPT   IF JCT CHECKPOINT NOT REQD,
         BZR   R6                  JUST RETURN TO CALLER.
         NI    JCTFLAG1,255-JCT1CKPT  ELSE RESET CHECKPOINT FLAG.
         L     R0,SJBJCTRK         GET JCT TRACK ADDRESS.
         MVC   SJBFWORD,=CL4'JCT'  INDICATE JCT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE THE JCT.
         BR    R6                  RETURN TO CALLER.
         SPACE 3
*
*              IOT CHECKPOINT SUBROUTINE
*
HCBCKIOT DS    0H
         SL    R5,=A(IOTIOT-IOTDSECT)  ADJUST ARGUMENT.
         USING IOTDSECT,R5         SET IOT ADDRESSABILITY.
HCBCKI1  DS    0H
         L     R5,IOTIOT           POINT TO NEXT IOT.
         LTR   R1,R5               IF END OF CHAIN,
         BZR   R4                  RETURN TO CALLER.
         TM    IOTFLAG1,IOT1CKPT   IF IOT CHECKPOINT NOT REQ'D,
         BZ    HCBCKI1             GO ON TO NEXT IOT.
         NI    IOTFLAG1,255-IOT1CKPT  ELSE RESET CHECKPOINT FLAG.
         L     R0,IOTTRACK         GET IOT TRACK ADDRESS.
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE OUT THE IOT.
         B     HCBCKI1             THEN GO ON TO NEXT IOT.
         DROP  R5                  DROP IOT BASE.
         DROP  R7                  DROP LOCAL BASE.
         EJECT
*
*
*              READ/WRITE A HASP CONTROL BLOCK
*              THE ID OF THE CONTROL BLOCK TO BE READ          @OZ78293
*              OR WRITTEN MUST BE PASSED IN SJBFWORD           @OZ78293
*
*
HCBRD    DS    0H                  READ A CONTROL BLOCK ---
         USING *,R12               SET LOCAL ADDRESSABILITY.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET LOCAL BASE.
         ICM   R1,8,=X'06'         ADD READ COMMAND TO DATA ADR.
         LA    R12,HCBIO           SET COMMON BASE
         BR    R12                 AND BRANCH TO COMMON.
         SPACE 3
HCBWR    DS    0H                  WRITE A CONTROL BLOCK ---
         USING *,R12               SET LOCAL ADDRESSABILITY.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET LOCAL BASE.
         ICM   R1,8,=X'05'         ADD WRITE COMMAND TO DATA ADR.
         LA    R12,HCBIO           SET COMMON BASE.
         SPACE 3
HCBIO    DS    0H
         USING *,R12               COMMON ROUTINE FOR READ/WRITE--
         TM    SJBFLG1,SJB1XBWT    IF XBM HAS NO JOB,
         BO    HCBIO900             PROHIBIT ALL I/O HERE.
         CLM   R1,7,=F'0'          IF ZERO BUFFER POINTER,     @OZ19486
         BZ    HCBIO800            EXIT IMMEDIATELY.
         AL    R1,=A(BUFSTART-BUFDSECT)  COMPUTE READ/WRITE ADR.
         ST    R1,SJBCCW4          SET COMMAND, DATA ADDRESS.
* CONVERT MTTR TO FULL DISK ADDRESS, MBBCCHHR
         CLM   R0,8,$SVNUMDA       IF INCORRECT EXTENT,              R4
         BNL   HCBIO100             BRANCH TO ERROR MESSAGE          R4
         LR    R3,R0               COPY MTTR TO R3.
         LA    R0,0(,R3)           MAKE R0 0TTR.
         XR    R3,R0               MAKE R3 M000.
         ST    R3,SJBIFDAD         SET EXTENT, ZEROES IN IOB.
         STC   R0,SJBIFDAD+7       SET RECORD NUMBER IN IOB.
         SRL   R3,24               FROM EXTENT NUMBER,
         MH    R3,=AL2(TEDSIZ)     CALCULATE ADDRESS OF
         L     R4,$SVTED           TRACK EXTENT                      R4
         ALR   R4,R3               DATA.                             R4
         USING TEDDSECT,R4         SET TED ADDRESSABILITY.
         LR    R2,R0               COPY 0TTR TO R2.
         SRDL  R2,40               SET TT IN R2, R3 FOR DIVIDE.
         L     R0,TNTC             GET NUMBER OF TRACKS/CYL.
         LTR   R0,R0               IF ZERO, SPOOL VOLUME ABSENT -
         BZ    HCBIO100            WRITE ERROR MESSAGE.
         DR    R2,R0               ELSE COMPUTE CYL & HEAD.
         $ALGN STH,R3,SJBIFDAD+3   SET CYLINDER IN IOB.
         $ALGN STH,R2,SJBIFDAD+5   SET HEAD IN IOB.
* SET ROTATIONAL POSITION SENSING
         MVI   SJBCCW1,X'03'       ASSUME NO RPS.
         L     R2,TRPS             POINT TO EXTENT'S RPS TABLE.
         LTR   R2,R2               IF ZERO POINTER,
         BZ    HCBIO10             DEVICE HAS NO RPS.
         SLR   R3,R3               ELSE ZERO R3 FOR IC.
         IC    R3,SJBIFDAD+7       GET RECORD NUMBER FRON IOB.
         IC    R3,0(R3,R2)         GET CORRESPONDING SECTOR NUMB.
         STC   R3,SJBCCW1+5        SET SET-SECTOR DATA
         MVI   SJBCCW1,X'23'       AND SET-SECTOR COMMAND.
* EXECUTE CHANNEL PROGRAM
HCBIO10  EXCP  SJBIOB              START THE CHANNEL PROGRAM.
* ADD ONE TO INPUT/OUTPUT SERVICE MEASURE
         L     R1,PSAAOLD-PSA      POINT TO CURRENT ASCB.
         USING ASCB,R1             SET ASCB ADDRESSABILITY.
         L     R2,ASCBIOSM         GET CURRENT IOSM - BYTES 0,1.
HCBIO15  DS    0H
         LR    R3,R2               MOVE IT TO UPDATE REGISTER.
         AL    R3,=FS16'1'         ADD 1 TO SERVICE MEASURE.
         CS    R2,R3,ASCBIOSM      STORE NEW MEASURE.
         BNE   HCBIO15             REPEAT IF INTERFERENCE.
         DROP  R1                  DROP ASCB ADDRESSABILITY.
* AWAIT COMPLETION
         WAIT  1,ECB=SJBECB        WAIT TILL IT ENDS.
* VERIFY THE I/O OPERATION
         TM    SJBECB,X'20'        IF NOT-PERM-ERROR FLAG IS OFF,
         BZ    HCBIO120            GO WRITE ERROR MESSAGE.
* VALIDITY-CHECK THE CONTROL BLOCK IF READ
         CLI   SJBCCW4,6           IF NOT A CONTROL BLOCK READ,
         BNE   HCBIO900            PERFORM NO VALIDITY CHECK.
         L     R5,24(,R13)         POINT AGAIN TO THE BUFFER.
         USING JCTDSECT,R5         SET JCT ADDRESSABILITY.
         CLC   =CL4'JCT',JCTID     IF CONTROL BLOCK IS JCT,
         BE    HCBIO20             GO CHECK IT.
         CLC   =CL4'IOT',JCTID     IF CONTROL BLOCK IS IOT,
         BE    HCBIO30             GO CHECK IT.
         CLC   =CL4'OCT',JCTID     IF CONTROL BLOCK IS OCT,
         BE    HCBIO40             GO CHECK IT.
         B     HCBIO110            ELSE UNKNOWN CONTROL BLOCK.
* JCT VALIDITY CHECK
HCBIO20  CLC   SJBJQOFF+1(3),JCTJQE+1 IF JQE OFFSET IN JCT     @OZ45359
         BNE   HCBIO110            IS INCORRECT, ERROR.
         MVC   SJBJKEY,JCTJBKEY    ELSE SET JOB KEY IN SJB
         B     HCBIO900            AND RETURN.
* IOT VALIDITY CHECK
         USING IOTDSECT,R5         SET IOT ADDRESSABILITY.
HCBIO30  CLC   SJBJKEY,IOTJBKEY    IF JOB KEY IN IOT IS WRONG,
         BNE   HCBIO110            IOT IS INVALID.
         B     HCBIO900            ELSE RETURN.
* OCT VALIDITY CHECK
         USING OCTDSECT,R5         SET OCT ADDRESSABILITY.
HCBIO40  CLC   SJBJKEY,OCTJBKEY    IF JOB KEY IN OCT IS WRONG,
         BNE   HCBIO110            OCT IS INVALID.
         B     HCBIO900            ELSE RETURN.
         SPACE 3
*
*              WRITE ERROR MESSAGE - INVALID TRACK ADDRESS
*
HCBIO100 DS    0H
         $MID  363                 SET HASP MESSAGE ID.
         WTO   '&MID.HCBIO - INVALID TRACK ADDRESS',ROUTCDE=10,        C
               DESC=6
         B     HCBIO800
         SPACE 3
*
*              ERROR MESSAGE - INVALID CONTROL BLOCK
*
         $MID  364                 SET HASP MESSAGE ID.
HCBIOVMS WTO   '&MID.HCBIO - INVALID CONTROL BLOCK - ********, EXPECTINC
               G *** ',ROUTCDE=10,DESC=6,MF=L                  @OZ78293
HCBIOM1  EQU   HCBIOVMS,*-HCBIOVMS
HCBIOM2  EQU   4+9+32,8            CONTROL BLOCK ID            @OZ78293
HCBIOM7  EQU   4+9+52,4            EXPECTED CTL BLK ID         @OZ78293
*
*              WRITE INVALID CONTROL BLOCK MESSAGE
*
HCBIO110 DS    0H
         GETMAIN R,LV=L'HCBIOM1    GET STORAGE FOR MESSAGE.
         MVC   0(L'HCBIOM1,R1),HCBIOM1  MOVE MESSAGE.
         MVC   HCBIOM7(,R1),SJBFWORD MOVE EXPECTED CTL BLK ID  @OZ78293
         UNPK  SJBFWORD(9),JCTID-JCTDSECT(5,R5)  TRANSLATE ID  @OZ78293
         TR    SJBFWORD(8),HCBXLATE                FIELD       @OZ78293
         MVC   HCBIOM2(,R1),SJBFWORD  ADD XLATED CTL BLK ID    @OZ78293
         LR    R2,R1               SAVE STORAGE ADDRESS.
         WTO   MF=(E,(1))          WRITE MESSAGE.
         FREEMAIN R,LV=L'HCBIOM1,A=(R2)  FREE STORAGE.
         B     HCBIO800            RETURN ERROR CODE.
         SPACE 3
*
*              I/O ERROR READING/WRITING CONTROL BLOCK
*
         $MID  370                 SET HASP MESSAGE ID.
HCBIOERR WTO   '&MID.HCBIO - I/O ERROR ****ING CONTROL BLOCK - ********C
               , EXPECTING *** ',MF=L,ROUTCDE=10,DESC=6        @OZ78293
HCBIOM3  EQU   HCBIOERR,*-HCBIOERR MESSAGE LENGTH
HCBIOM4  EQU   4+9+18,4            READ/WRIT OFFSET, LENGTH          R4
HCBIOM5  EQU   4+9+42,8            CONTROL BLOCK ID            @OZ78293
HCBIOM6  EQU   4+9+62,4            EXPECTED CTL BLK ID         @OZ78293
*
*              WRITE I/O ERROR MESSAGE
*
HCBIO120 DS    0H
         GETMAIN R,LV=L'HCBIOM3    GET STORAGE FOR MESSAGE.
         MVC   0(L'HCBIOM3,R1),HCBIOM3  MOVE MESSAGE.
         MVC   HCBIOM4(,R1),=C'READ'  ASSUME 'READ'ING.
         CLI   SJBCCW4,6           IF READ,
         BE    *+10                SKIP.
         MVC   HCBIOM4(,R1),=C'WRIT'  ELSE SET 'WRIT'ING.
         L     R5,SJBCCW4          GET POINTER TO ID.
         MVC   HCBIOM6(,R1),SJBFWORD MOVE EXPECTED CTL BLK ID  @OZ78293
         UNPK  SJBFWORD(9),0(5,R5) TRANSLATE ID FIELD OF       @OZ78293
         TR    SJBFWORD(8),HCBXLATE  CONTROL BLOCK IN ERROR    @OZ78293
         MVC   HCBIOM5(,R1),SJBFWORD  ADD XLATED CTL BLK ID    @OZ78293
         LR    R2,R1               SAVE STORAGE ADDRESS.
         WTO   MF=(E,(1))          WRITE MESSAGE.
         FREEMAIN R,LV=L'HCBIOM3,A=(R2)  FREE STORAGE.
         B     HCBIO800            RETURN ERROR CODE.
         SPACE 3
*
*              ERROR RETURN
*
HCBIO800 DS    0H
         LA    R15,4               SET R15 TO 4
         B     HCBIO950            AND RETURN.
         SPACE 3
*
*              NORMAL RETURN
*
HCBIO900 DS    0H
         SLR   R15,R15             ZERO REGISTER 15.9
HCBIO950 DS    0H
         ST    R15,16(,R13)        SAVE RETURN CODE IN SAVE AREA.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         LTR   R15,R15             SET CONDITION CODE.
         BR    R14                 RETURN TO CALLER.
         DROP  ,                   DROP ALL BASES.
         SPACE 1                                               @OZ78293
HCBXLATE EQU   *-240                                           @OZ78293
         DC    X'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6'             @OZ78293
         TITLE 'HASP JOB RE-ENQUEUE SUBSYSTEM FUNCTION'
*
*
*              HASP JOB RE-ENQUEUE SUBSYSTEM FUNCTION
*
*
HOSRENQ  $PROLOG SSOBRENQ,SSRQSIZE,LOCK=REQ
         SL    R12,=A(*-HJEBASE)   JOB RE-ENQUEUE IS HANDLED
         USING HJEBASE,R12         SET JBTM ADDRESSABILITY.
         B     HJERENQ             RE-ENQUEUE THE JOB.
         TITLE 'HOSEOT -- END-OF-TASK RECOVERY ROUTINE'
HOSEOT   $PROLOG SSOBEOT,SSETSIZE,LOCK=REQ
HOSEOTB  DS    0H                  END-OF-TASK BASE
*
*
*              ATTEMPT TO SET FLAG SJBTFFGP TO CAUSE $EPILOG
*              TO FREE A POSSIBLE PSO CONTROL BLOCK
*
*
         USING SSETBGN,RSOX        SET SSOX ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
HET100   DS    0H
         L     R15,SJBPSOP         IF NO PSO
         LTR   R15,R15             CONTROL BLOCK EXISTS,
         BZ    HET200              SKIP.
         USING PSODSECT,R15        SET PSO ADDRESSABILITY.
         CLC   PSOTCB,SSETCBA      IF PSO FOR DIFFERENT TASK,
         BNE   HET200              SKIP.
         OI    SJBTFFG,SJBTFFGP    ELSE SET FLAG FOR $EPILOG.
         DROP  R15                 DROP PSO BASE.
*
*
*              CALL SUBROUTINE $SVFCELA TO FREE CELLS ASSOCIATED
*              WITH THIS SJB AND TCB
*
*
HET200   DS    0H
         LR    R0,RSJB             SET ARGUMENTS -
         L     R1,SSETCBA          R0=SJB, R1=TCB.
         L     R15,$SVFCELA        FREE ALL
         BALR  R14,R15             ASSOCIATED CELLS.
*                                                              @OZ69821
*                                                              @OZ69821
*              CHECK FOR DETACHING INITIATOR TCB --            @OZ69821
*              IF SO, SHOW BATCH JOB AS TERMINATED.            @OZ69821
*                                                              @OZ69821
*                                                              @OZ69821
         ICM   R2,15,SJBSJB        IF THERE IS NO LOWER SJB,   @OZ69821
         BZ    HET300                  NO NEED TO FLAG IT      @OZ69821
         CLC   SJBTCBP-SJBDSECT(,R2),PSATOLD-PSA IF NO MATCH,  @OZ69821
         BNE   HET300                 ENDING TCB IS NOT INIT   @OZ69821
         OI    SJBFLG4-SJBDSECT(R2),SJB4TERM ELSE SET FLAG     @OZ69821
*
*
*              COMPLETE PURGED I/O REQUESTS FOR THIS TASK
*
*
HET300   DS    0H
* STOP ALL OTHER TASKS FROM EXECUTING
         ICM   R2,7,SJBTCBP+1      POINT TO INIT OR STC TCB    @OZ57048
         BZ    HET900              BR IF ZERO, MUST BE SYSLOG  @OZ57048
         ICM   R2,7,TCBLTC+1-TCBDSECT(R2)  GET FIRST DAUGHTER  @OZ57048
         BZ    HET900              BR IF NONE                  @OZ57048
         STATUS SET,ND,(2),(4)     SET TCBHNDSP                @OZ53355
         SLR   R0,R0               CLEAR REGS                  @OZ38510
         LR    R1,R0               FOR WORK                    @OZ38510
         LM    R14,R15,$SVTGASC    GET TGB WAITING ASCB,ECB    @OZ38510
         CLM   R14,7,PSAAOLD-PSA+1 ADDR SP WAITING TGKGRP...   @OZ38510
         BNE   HET316              NO,CONTINUE                 @OZ38510
         ICM   R0,7,$SVTGECB+1     GET WAITING RB ADDR         @OZ38510
         ICM   R1,7,PSATOLD-PSA+1  GET OUR TCB                 @OZ38510
         USING TCB,R1                                          @OZ38510
         ICM   R1,7,TCBRBP+1       GET FIRST RB                @OZ38510
HET304   DS    0H                                              @OZ38510
         CR    R0,R1               IS THIS THE RB...           @OZ38510
         BE    HET308              YES, GO POST ECB            @OZ38510
         USING RBBASIC,R1                                      @OZ38510
         ICM   R1,7,RBLINKB        ELSE GET NEXT RB            @OZ38510
         CLM   R1,7,PSATOLD-PSA+1  WAS THIS THE LAST RB...     @OZ38510
         BE    HET316              YES, CONTINUE               @OZ38510
         B     HET304              NO, CHECK NEXT RB           @OZ38510
HET308   DS    0H                                              @OZ38510
         LR    R0,R14              GET ASCB POINTER            @OZ38510
HET311   LR    R1,R15              GET ECB TO CHANGE           @OZ38510
         N     R1,=XL4'7FFFFFFF'   RESET WAIT BIT IN REG       @OZ38510
HET312   CDS   R14,R0,$SVTGASC     RESET WAIT BIT IN ECB       @OZ38510
         BZ    HET316              SWAP COMPLETE, CONTINUE     @OZ38510
         CLM   R14,7,PSAAOLD-PSA+1 DID ASCB CHANGE...          @OZ38510
         BE    HET311              NO, ECB WAS POSTED, REPEAT  @OZ38510
HET316   DS    0H                                              @OZ38510
* RUN THE CHAIN OF SUBSYSTEM DATASET BLOCKS
         L     R8,SJBSDB           POINT TO THE FIRST SDB.
HET320   DS    0H
         LTR   R8,R8               IF NO MORE SDBS,
         BZ    HET420              END OF SECTION.
         USING SDBDSECT,R8         SET SDB ADDRESSABILITY.
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
*              THIS LINE DELETED BY APAR NUMBER                @OZ53355
* DETERMINE TEST TO BE MADE ON THIS SDB
         TM    SDBFLG2,SDB2IOA     IF IOA FLAG OFF,
         BZ    HET340              BRANCH.
* SDB2IOA ON --- IF PURGED WITH HIO, RESTART
         CLI   SDBICMP,X'48'       IF NOT PURGE/HALT-I/O,
         BNE   HET380              DO NEXT SDB.
         B     HET360              ELSE GO COMPLETE I/O.
* SDB2IOA OFF -- IF OUTPUT AND PURGE-QUIESCE, RESTART
HET340   DS    0H
         CLI   SDBCHEND,SDBCEPUT   IF CE APDG NOT HCEPUT,
         BNE   HET380              DO NEXT SDB.
         L     R0,SDBPBF           ELSE IF SDBPBF
         LTR   R0,R0               IS ZERO,
         BZ    HET380              GO DO NEXT SDB.
* SAVE CURRENT CONTENTS OF ECB
HET360   DS    0H
         L     R2,SDBECB           SAVE CURRENT ECB.
         MVI   SDBECB,0            ZERO THE ECB.
* ISSUE EXCP TO RESUME CHANNEL OPERATIONS
         EXCP  SDBIOB              START CHANNEL PROGRAM.
* WAIT FOR COMPLETION OF ALL I/O
         WAIT  1,ECB=SDBECB        WAIT FOR COMPLETION.
* IF SAVED ECB WAS WAITING, RESTORE AND POST IT
         LTR   R2,R2               IF SAVED ECB'S WAIT BIT
         BNM   HET400              IS OFF, BRANCH.
         ST    R2,SDBECB           RESTORE SAVED ECB.
         IC    R0,SDBICMP          GET POST CODE.
         SLL   R0,24               LEFT-JUSTIFY.
         POST  SDBECB,(0)          POST THE SAVED ECB.
         B     HET400              GO LOOK AT NEXT SDB.
* DO A FINAL CHECK ON THIS SDB
HET380   DS    0H
*              THIS LINE DELETED BY APAR NUMBER                @OZ29959
*              THIS LINE DELETED BY APAR NUMBER                @OZ29959
         TM    SDBFLG2,SDB2IOA     IF I/O INACTIVE,
         BZ    HET400              DO NEXT SDB.
         TM    SDBECB,X'C0'        IF WAITING OR POSTED,
         BNZ   HET400              DO NEXT SDB.
         WAIT  1,ECB=SDBECB        WAIT FOR I/O COMPLETION.
* CONTINUE WITH NEXT SDB
         SPACE 1                                                     R4
***********************************************************************
*                                                                     *
*        IF SDB WAS GETMAINED UNDER TASK BEING TERMINATED, IT MUST    *
*        NOW BE DE-CHAINED, SINCE ITS SUBPOOL WILL SOON BE FREED.     *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
HET400   CLC   SSETCBA,SDBTCBM     TEST SDB TCB                      R4
         BNE   HET415              BR IF NOT CURRENT TCB             R4
         LA    R1,SJBSDB              PREPARE TO LOCATE              R4
         SL    R1,=A(SDBSDB-SDBDSECT)  PRECEEDING SDB                R4
         SPACE 1                                                     R4
HET405   C     R8,SDBSDB-SDBDSECT(,R1)  IS NEXT SDB CURRENT SDB      R4
         BE    HET410                   BR IF YES                    R4
         L     R1,SDBSDB-SDBDSECT(,R1)  POINT TO NEXT SDB            R4
         B     HET405                   BR TO TEST IT                R4
         SPACE 1                                                     R4
HET410   MVC   SDBSDB-SDBDSECT(,R1),SDBSDB  DECHAIN CURRENT SDB      R4
         SPACE 1                                                     R4
HET415   L     R8,SDBSDB           POINT TO NEXT SDB                 R4
         B     HET320              AND PROCESS IT.
* END OF SECTION
HET420   DS    0H
         L     R2,SJBTCBP          POINT TO INIT OR STC TCB    @OZ53355
         L     R2,TCBLTC-TCBDSECT(R2)  POINT TO JSTCB          @OZ57048
         STATUS RESET,ND,(2),(4)   SET TCBHNDSP                @OZ53355
         DROP  R8                  DROP SDB BASE.
*
*
*              RETURN FROM END-OF-TASK
*
*
HET900   DS    0H
         SLR   R15,R15             SHOW NORMAL RETURN.
         $EPILOG ,                 RETURN.
         EJECT
*
*
*              TABLE OF HFRR ROUTINE OFFSETS, IN ORDER
*              OF SUBSYSTEM FUNCTION ID.  FIRST ENTRY IS ZERO.
*
HETTAB   DS    0H
         DC    AL2(HETEND-HOSEOTB) ..0 NULL FUNCTION PURGER
         DC    AL2(HETSOUT-HOSEOTB) .1 PROCESS SYSOUT PURGER
         DC    AL2(HETCANC-HOSEOTB) .2 TSO CANCEL PURGER
         DC    AL2(HETSTAT-HOSEOTB) .3 TSO STATUS PURGER
         DC    28AL2(HETEND-HOSEOTB)
*
         EJECT
         DROP  RSJB                DROP NORMAL SJB BASE.
         USING SJBDSECT,R8         SET R8 AS SJB BASE.
***********************************************************************
*                                                                     *
*        END OF TASK WHILE SJB LOCKED FOR PROCESS SYSOUT FUNCTION     *
*                                                                     *
***********************************************************************
HETSOUT  DS    0H
         OI    SJBTFFG,SJBTFFGP    SET PURGE REQUESTED FOR EPILOG
         B     HETSTATA            SKIP FIRST INSTRUCTION OF C/S
***********************************************************************
*                                                                     *
*        END OF TASK WHILE SJB LOCKED FOR CANCEL/STATUS FUNCTION      *
*                                                                     *
***********************************************************************
HETCANC  DS    0H
HETSTAT  DS    0H
         OI    SJBTFFG,SJBTFFGC    SET CANCEL/STATUS PURGING FLAG
HETSTATA DS    0H
         TM    SJBTFFG,SJBTFFGM    IS ECB  MEANINGFULL
         BZR   R14                 EXIT IF NOTHING TO DO
         LR    R3,R11              SAVE SSVT POINTER
         LR    R4,R12              SAVE BASE
         LR    R5,R13              AND
         LR    R6,R14              SOME
         L     R15,=A(TSETLOCK)    POINT TO SET LOCK
         BALR  R2,R15              SET LOCK
         LR    R11,R3              RESTORE SSVT POINTER
         LR    R12,R4              PUT BASE BACK
         SLR   R3,R3               ZERO REGISTER
         L     R4,SJBECB           PICK UP ECB
HETCSCS  CLM   R4,8,=X'40'         HAS ECB BEEN POSTED
         BE    HETCSP              X'40' - POSTED - HASP FINISHED
         CS    R4,R3,SJBECB        TAKE OVER ECB
         BNZ   HETCSCS             LOOP IF NOT ALTERED
         LA    R4,$SVTSCS          POINT TO CANCEL/STATUS QUEUE
         TM    SJBTFFG,SJBTFFGC    IS THIS CANCEL/STATUS
         BO    *+8                 SKIP NSI IF YES
         LA    R4,$SVPSOQ          POINT TO PSO QUEUE
         LR    R13,R8              USE STANDARD SJB POINTER
         L     R15,=A(TSUABQS)     POINT TO QUEUE SCANNER
         BALR  R14,R15             SCAN QUEUE
         BZ    HETCSCKW            IF NOT ON TEST FOR EVER ON
* SJB FOUND ON CANCEL/STATUS QUEUE
         ICM   R1,15,$SVHASP       PICK UP HASP STATUS
         BZ    HETCSULW            IF STILL UP UNLOCK AND WAIT
         L     R15,=A(TSHABDQ)     POINT TO DEQUEUE ROUTINE
         BALR  R14,R15             ENTER IT, R4=QUEUE HEAD ADDRESS
HETCSP   LR    R3,R11              SAVE SSVT POINTER
         LR    R4,R12              SAVE BASE
         L     R15,=A(TSFRELOK)    POINT TO FREE LOCK
         BALR  R2,R15              ENTER IT
         LR    R11,R3              RESTORE SSVT POINTER
         LR    R12,R4              RESTORE BASE
HETCSXIT LR    R13,R5              RESTORE USER SAVE POINTER
         LR    R14,R6              RESTORE RETURN
         BR    R14                 RETURN
HETCSCKW LR    R4,R12              SAVE BASE
         LR    R3,R11              SAVE SSVT POINTER
         L     R15,=A(TSFRELOK)    POINT TO FREE LOCK ROUTINE
         BALR  R2,R15              ENTER IT
         LR    R11,R3              RESTORE SSVT POINTER
         LR    R12,R4              RESTORE BASE
         CLI   SJBTFLOW,X'0'       WAS IT EVER ON THE QUEUE
         BZ    HETCSXIT            EXIT IF NO
HETCSWAT LA    R1,$SVJOB           POINT TO XEQ POST ELEMENT
         TM    SJBTFFG,SJBTFFGC    IS THIS CANCEL/STATUS
         BO    *+8                 SKIP PSO SETTING IF YES
         LA    R1,$SVPSO           POINT TO PSO POST ELEMENT
         $$POST ELMT=(R1)          POST PROBABLE WAITING PROCESSOR
         WAIT  ECB=SJBECB          WAIT FOR POST
         B     HETCSXIT            EXIT
HETCSULW LR    R4,R12              SAVE BASE
         LR    R3,R11              SAVE SSVT POINTER
         L     R15,=A(TSFRELOK)    POINT TO FREE LOCK ROUTINE
         BALR  R2,R15              ENTER IT
         LR    R11,R3              RESTORE SSVT POINTER
         LR    R12,R4              RESTORE BASE
         B     HETCSWAT            WAIT
HETEND   DS    0H
         BR    R14                 NULL HFRR.
         DROP  ,                   DROP ALL BASES.
         TITLE 'HOSEOM -- SUBSYSTEM END-OF-MEMORY FUNCTION'
*
*
*              HOSEOM - END-OF-MEMORY SUBSYSTEM INTERFACE
*
*
HOSEOM   $PROLOG SSOBEOM,SSENSIZE,LOCK=NO
HOSEOMB  DS    0H
         USING SSENBGN,RSOX        SET SSEN ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
*
*
*              IF JES2 MEMORY, SET INDICATORS
*
*
HEN010   DS    0H
         CLC   SSENASCB,$SVPOSTE+4 TEST FOR JES2 MEMORY              R4
         BNE   HEN020              BR IF NO                          R4
         TM    $SVSTUS,$SVSTUST    DID JES2 TERMINATE SELF           R4
         BO    HEN015              BR IF YES                   @OZ35278
         OI    $SVSTUS,$SVSTUST    SHOW JES2 TERMINATION COMPLETE.
         MVC   $SVHASP,=F'-1'      SHOW JES2 ABENDED.
                                   PRINT OFF - SECTION DELETED @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
                                   PRINT ON -- SECTION DELETED @OZ35278
         SPACE 1                                               @OZ35278
HEN015   DS    0H                                              @OZ35278
         L     R1,$SVHECBA         ADDR OF ECB AND $$POST WORK FLAG  R4
         MVI   $SVPOSTW(R1),X'FF'  INHIBIT JES2 XMPOSTING            R4
HEN020   DS    0H
*
*
*              IF ENDING MEMORY HOLDS JCQ LOCK, RELEASE IT.
*
*
HEN100   DS    0H
         L     R1,$SVJLOCK         GET LOCK-HOLDING ASCB ADDRESS.
         LTR   R1,R1               IF JCQ LOCK IS FREE,
         BZ    HEN190              CONTINUE.
         CL    R1,SSENASCB         IF ASCB NOT SAME AS
         BNE   HEN190              ENDING MEMORY'S, CONTINUE.
         CALL  $SVJUNLK            ELSE RELEASE THE JCQ LOCK.
         B     HEN100              THEN CHECK AGAIN.
HEN190   DS    0H
*
*
*              PURGE INTERNAL READERS
*
*
HEN200   DS    0H
         L     R8,$SVIRDRS         POINT TO FIRST INTRDR DCT.
         USING DCTDSECT,R8         SET DCT ADDRESSABILITY.
         SPACE 1                                               @OZ35996
         LH    R3,$SVNINRS         GET INTERNAL READER COUNT   @OZ35996
         SLR   R7,R7               ZERO R7 FOR ZEROING.
         SLR   R6,R6               ZERO R6 FOR COUNTING.
         L     R5,SSENASCB         POINT R5 TO ENDING ASCB.
HEN210   DS    0H
         CL    R5,RIDASCBP         IF INTRDR NOT ENDING MEMORY'S,
         BNE   HEN220              GO CHECK NEXT INTRDR.
         MVI   RIDEOME,0           ZERO ECB POST CODE FOR EOM  @OZ48724
         OI    RIDFLAGS,RIDEOM     INDICATE ADDR SPACE TERM.   @OZ37382
         OI    DCTSTAT,DCTHOLD     SHOW DEVICE HELD            @OZ37382
         MVC   RIDEOMA,PSAAOLD-PSA SET ASCB TO POST            @OZ37382
         ST    R7,RIDUBF           BUFFER POINTERS ZERO.
         NI    RIDFLAGS,255-RIDBUSY SHOW SSSM GIVES UP CONTROL @OZ29612
         OI    RIDFLAGS,RIDEND+RIDPOST SET END AND POST BITS   @OZ29612
         OI    DCTFLAGS,DCTDELET   DELETE JOB ON INTRDR        @OZ29612
         NI    DCTFLAGS,255-DCTSTOP CLEAR POSSIBLE STOP        @OZ29612
         $$POST ELMT=$SVIRDR       POST HASPDISP FOR INTRDR    @OZ29612
         WAIT  1,ECB=RIDEOME       WAIT FOR HASP TO PURGE      @OZ37382
         ST    R7,RIDASCBP         THEN CLEAR ASCB POINTER     @OZ37382
         ST    R7,RIDEOMA            FOR EOM AND NORMAL WAIT   @OZ37382
         ST    R7,RIDEOME          ...AND ECB FOR NEXT USER    @OZ37382
         ST    R7,RIDECB               FOR EOM AND NORMAL      @OZ37382
         XC    RIDJBID(8),RIDJBID  ZERO JOB ID                 @OZ68422
         XC    RIDJNAM(8),RIDJNAM    AND NAME OF OWNER         @OZ68422
         NI    RIDFLAGS,255-RIDALLOC  SHOW NOT ALLOCATED.
         BCTR  R6,0                COUNT ONE.
HEN220   DS    0H
         L     R8,DCTCHAIN         POINT TO NEXT INTRDR.
         BCT   R3,HEN210           BRANCH TO PROCESS IT        @OZ35996
HEN230   DS    0H
         LTR   R6,R6               IF WE DIDN'T UNALLOCATE,
         BZ    HEN290              DON'T POST WAIT ELEMENTS.
         L     R6,$SVIRWT          GET POINTER TO FIRST
         CS    R6,R7,$SVIRWT       WAIT ELEMENT, AND CLEAR
         BNE   *-4                 THE POINTER.
         LTR   R6,R6               IF NO WAIT ELEMENTS,
         BZ    HEN290              END OF INTRDR PURGE.
         L     R5,CVTPTR           POINT TO
         USING CVT,R5              THE ASVT
         L     R5,CVTASVT          FROM THE
         USING ASVT,R5             CVT.
HEN240   DS    0H
         L     R4,12(,R6)          GET WAIT ELM'S ASCB POINTER.
         USING ASCB,R4             SET ASCB ADDRESSABILITY.
         LH    R3,ASCBASID         GET ASID FROM ASCB.
         ALR   R3,R3               MULTIPLY
         ALR   R3,R3               BY FOUR.
         CL    R4,ASVTFRST(R3)     IF ASCB ADDRESS DOESN'T
         BNE   HEN250              MATCH ASVT, BRANCH.
         TM    ASCBFLG1,ASCBTERM+ASCBABNT  IF ASCB TERMINATING,
         BNZ   HEN250              BRANCH.
         POST  MF=(E,8(,R6))       POST WAIT ELEMENT.
         L     R6,0(,R6)           POINT TO NEXT WAIT ELEMENT.
         B     HEN260              CHECK POINTER.
HEN250   DS    0H
         LR    R1,R6               INSTEAD OF POST, FREE W. E.
         L     R6,0(,R6)           AFTER POINTING TO NEXT.
         $FREMAIN RC,A=(R1),LV=32,SP=231,KEY=1  FREE W. E.
HEN260   DS    0H
         LTR   R6,R6               IF ANOTHER WAIT ELEMENT,
         BNZ   HEN240              GO CHECK IT.
         DROP  R8,R5,R4            DROP LOCAL BASES.
HEN290   DS    0H
*
*
*              FIND A SUBSYSTEM JOB BLOCK TO TERMINATE
*
*
HEN300   DS    0H
         LH    R1,SSENASID         GET TERMINATING MEMORY'S ID.
         ALR   R1,R1               MULTIPLY IT
         ALR   R1,R1               BY FOUR.
         AL    R1,$SVHAVT          ADD HAVT ORIGIN.
         L     R1,0(,R1)           POINT TO FIRST SJB THIS MEMORY.
         LTR   R1,R1               IF NO SJBS,
         BZ    HEN900              NO WORK TO DO.
HEN320   DS    0H
         USING SJBDSECT,R1         SET R1 AS SJB BASE.
         L     R2,SJBSJB           FIND THE
         LTR   R2,R2               LAST SUBSYSTEM
         BZ    HEN340              JOB BLOCK
         LR    R1,R2               ON THE CHAIN
         B     HEN320              FOR THIS MEMORY.
*
*
*              CHAIN SJB SAVE AREA TO CALLER'S SAVE AREA
*
*
HEN340   DS    0H
         ST    R1,8(,R13)          POINT CALLER'S SAVE AREA TO SJB
         ST    R13,4(,R1)          POINT SJB TO CALLER'S AREA.
         LR    R13,R1              CHANGE SJB
         DROP  R1                  ADDRESSABILITY FROM
         USING SJBDSECT,RSJB       R1 TO R13 (RSJB).
*
*
*              GET JOB COMMUNICATION QUEUES LOCK.
*              SET END-OF-MEMORY FLAG IN SJB.
*              SET UP FOR XMPOST TO CURRENT MEMORY.
*
*
         CALL  $SVJLOK             ACQUIRE JCQ LOCK.
         OI    SJBFLG2,SJB2EOM+SJB2PNIT  FLAG SJB FOR EOM.
         SLR   R0,R0               ZERO THE
         ST    R0,SJBECB           SJB'S ECB.
         MVC   SJBASCBP,PSAAOLD-PSA  SET NEW POSTING ASCB.
*                                                              @OZ44608
*              PURGE PSO IF PRESENT                            @OZ44608
*                                                              @OZ44608
         L     R6,SJBPSOP          POINT TO PSO.               @OZ44608
         LTR   R6,R6               TEST FOR PRESENT.           @OZ44608
         BZ    HEN350              SKIP PURGE IF NO PSO.       @OZ44608
         CALL  $SVJUNLK            RELEASE THE JCQ LOCK.       @OZ44608
         STM   R14,R12,SJBSAVE+12  SAVE REGISTERS              @OZ44608
         ICM   R12,7,=AL3(HOSEOTB) POINT TO PSO PURGE BASE     @OZ44608
         LR    R8,R13              COPY SJB POINTER            @OZ44608
         OI    PSOFLG2-PSODSECT(R6),SSSOCTRL SET TO TERM. PSO. @OZ44608
         BAL   R14,HETSOUT-HOSEOTB(,R12) ENTER PSO PURGER      @OZ44608
         USING *,R14                                           @OZ44608
         ICM   R12,7,=AL3(PSOBASE) POINT TO PSO QUE. ROUT. BS. @OZ44608
         DROP  R14                                             @OZ44608
         LR    R13,R8              RESTORE SJB POINTER         @OZ44608
         BAL   R8,PSOQUEUE-PSOBASE(,R12) ENTER PSO TERMINATOR  @OZ44608
         LM    R14,R12,SJBSAVE+12  RESTORE NORMAL REGISTERS    @OZ44608
         SLR   R0,R0               ZERO                        @OZ44608
         ST    R0,SJBFLOW          FLOW INDICATORS.            @OZ44608
         CALL  $SVJLOK             ACQUIRE JCQ LOCK            @OZ44608
*
*
*              BRANCH ACCORDING TO VALUE OF SJBQUEUE
*
*
HEN350   DS    0H                                              @OZ44608
         L     R1,SJBQUEUE         GET HEADER ADDRESS
         LTR   R1,R1               OF CURRENT SJB QUEUE.
         BZ    HEN500              IF NOT ON QUEUE, BRANCH.
         LA    R0,$SVJPCLS         GET 1ST Q HEADER ADDRESS.
         SR    R1,R0               COMPUTE CURRENT Q DISPLACEMENT.
         BM    HEN520              BRANCH IF INVALID.
         LA    R0,3                CHECK
         NR    R0,R1               FULLWORD BOUNDARY.
         BNZ   HEN520              BRANCH IF INVALID.
         LA    R0,$SVJRENQ-$SVJPCLS  CHECK
         CLR   R1,R0               MAXIMUM VALUE.              @OZ59659
         BH    HEN520              BRANCH IF INVALID.
* THE FOLLOWING CODE IS DEPENDENT ON THE ORDER OF DEFINITION
* OF THE JOB COMMUNICATION QUEUES IN THE SSVT
         B     *+4(R1)             BRANCH TO VECTOR.
         B     HEN580              PCLS - PENDING BY CLASS
         B     HEN520              PXBM - PENDING FOR XBM
         B     HEN485              PNUM - PENDING BY NUMBER    @OZ59659
         B     HEN400              XCLS - EXECUTING BY CLASS
         B     HEN400              XNUM - EXECUTING BY NUMBER
         B     HEN560              TERM - TERMINATING
         B     HEN560              RENQ - RE-ENQUEUEING
*
*
*              PROCESSING IF TERMINATION REQUIRED
*
*
HEN400   DS    0H
         LA    R1,$SVJTERM         ASSUME TERMINATION QUEUE.
         TM    SJBFLG2,SJB2JNL     TEST FOR JOURNALLED JOB           R4
         BZ    HEN460              BR IF NO                          R4
         LA    R1,$SVJRENQ         SET RE-ENQUEUE QUEUE
HEN460   DS    0H
         CALL  $SJBRQ              PUT SJB ON APPROPRIATE QUEUE.
* RELEASE THE JOB COMMUNICATION QUEUES LOCK
HEN480   DS    0H
         ICM   R15,7,SJBJQOFF+1    SEE IF JQE EXISTS...        @OZ40028
         BZ    HEN490              BRANCH IF NO                @OZ28534
HEN485   DS    0H                                              @OZ59659
         MVI   SJBECB,0            SHOW ECB UNPOSTED.
         CALL  $SVJUNLK            RELEASE JCQ LOCK.
* POST HASPEXEC SHOWING JOB READY
         $$POST ELMT=$SVJOB        FIRE UP HASP.
* WAIT TILL HASP POSTS US BACK
         WAIT  1,ECB=SJBECB        WAIT FOR HASP.
         CALL  $SJBFREE            FREE THE SJB                      R4
         B     HEN300              GO DO NEXT SJB.
HEN490   SLR   R1,R1               ZERO R1, TELL SJBRQ TO      @OZ28534
         CALL  $SJBRQ                DEQUEUE SJB               @OZ28534
* HEN500 - SJB NOT ON ANY QUEUE.  UNLOCK, FREE, & DO NEXT SJB.
HEN500   DS    0H
*        FIRST SEE IF A PIT HAS BEEN VERIFIED BY HASPEXEC      @OZ35293
         TM    SJBFLG1,SJB1SJID    WAS SJB FOR STARTED TASK..  @OZ35293
         BO    HEN510              STC- NO PIT ASSOCIATED      @OZ35293
         TM    SJBLKFG,SJBFIRST    JOB- WAS PIT VERIFIED...    @OZ35293
         BO    HEN510              NO, $P CAN KILL IT.         @OZ35293
         TM    SJBLKFG,SJBDRAIN    IF PIT HAS BEEN DRAINED,    @OZ73682
         BO    HEN510               JUST FREE SJB AND RETURN.  @OZ73682
         TM    SJBFLG2,SJB2CONV    'FAKE' SJB FOR CONVERTER..  @OZ39304
         BO    HEN510              YES, JUST GET RID OF IT     @OZ39304
         LA    R1,$SVJPCLS         ELSE HASP MUST KILL PIT     @OZ35293
         B     HEN580B             GO TO TELL HASP ABOUT IT    @OZ35293
HEN510   DS    0H                                              @OZ35293
         CALL  $SVJUNLK            RELEASE THE JCQ LOCK.
         CALL  $SJBFREE            FREE THE SJB                      R4
* GO DO THE NEXT SJB
         B     HEN300              GO DO NEXT SJB.
HEN520   DS    0H
         LA    R1,$SVJTERM         SET TERMINATION QUEUE.
         B     HEN460              GO REQUEUE THE SJB.
*
*              IF ALREADY ON TERM OR RENQ, RESET SJB2EOM
*
HEN560   DS    0H
         NI    SJBFLG2,255-SJB2EOM RESET SJB2EOM AND CONTINUE
         B     HEN480              BY $$POSTING AND WAITING.
*
*              PENDING-BY-CLASS - RELEASE JCQ LOCK,
*              START ANOTHER INITIATOR, AND FREE EVERYTHING
*
HEN580   DS    0H
         TM    SJBLKFG,SJBFIRST    TEST FOR FIRST JOB REQUEST  @OZ35293
         BO    HEN580C             1ST TIME, A PIT IS WAITING  @OZ35293
HEN580B  CALL  $SJBRQ              ELSE WE MUST KILL A PIT     @OZ35293
         MVI   SJBECB,0            SHOW ECB UNPOSTED           @OZ35293
         CALL  $SVJUNLK            RELEASE THE JCQ LOCK        @OZ35293
* POST HASPEXEC SO AN INACTIVE PIT WILL BE TERMINATED          @OZ35293
         $$POST ELMT=$SVJOB                                    @OZ35293
         WAIT  1,ECB=SJBECB        WAIT FOR HASP TO POST US    @OZ35293
         B     HEN580D                                         @OZ35293
HEN580C  DS    0H                                              @OZ35293
         SLR   R1,R1               TELL $SJBRQ TO DEQUEUE           R41
         CALL  $SJBRQ              CALL $SJBRQ                      R41
         CALL  $SVJUNLK            RELEASE THE JCQ LOCK.
         LA    R1,SJBID            POINT TO COMMAND AREA.
         MVC   0(22,R1),HEN580A    MOVE COMMAND TEXT.
         MVC   18(4,R1),$SVSSNM    MOVE SUBSYSTEM ID.
         SLR   R0,R0               ZERO REGISTER 0.
         SVC   34                  ISSUE START-INIT COMMAND.
HEN580D  DS    0H                                              @OZ35293
         CALL  $SJBFREE            FREE THE SJB                      R4
         B     HEN300              GO DO NEXT SJB                    R4
HEN580A  DC    AL2(22,0),C'S INIT.INIT,,,****'  COMMAND
*
*              END OF END-OF-MEMORY
*
HEN900   DS    0H
         SLR   R15,R15             SHOW NORMAL RETURN.
         $EPILOG ,                 RETURN TO USER.
         SPACE 2
         DROP  ,                   DROP ALL BASES.
         TITLE 'LITERAL POOL FOR HCBXX, HOSRENQ - HOSEOM'
         LTORG
         TITLE 'HASP SUBSYSTEM SUPPORT ROUTINE -- ALLOCATE'
*
*
*              HASP SUBSYSTEM SUPPORT ROUTINE -- ALLOCATE
*
*
HOSALLOC $PROLOG SSOBALOC,SSALSIZE,LOCK=REQ
         USING SSALBGN,RSOX        SET SSAL ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         L     RJFC,SSALJFCB       POINT TO DATA SET'S JFCB.
         USING INFMJFCB,RJFC       SET JFCB ADDRESSABILITY.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         SPACE 2                                                     R4
*
*              CREATE DSNAME IF REQUIRED
*
         SPACE 1
         TM    SSALFLG1,SSALASNM   DOES DSNAME EXIST ALREADY...
         BZ    HAL020              IF SO, GO CHECK IT.
         LA    R14,HALO            ELSE SET RETURN ADDRESS
         B     HALCRDSN            AND CREATE DSNAME.
         SPACE 2                                                     R4
*
*              VALIDIFY DATA SET NAME
*
         SPACE 1                                                     R4
HAL020   DS    0H
         MVC   DSNSSNM,$SVSSNM     SET SUBSYS NAME IN DSN.
         SPACE 1                                                     R4
*
*              BRANCH TO PROPER ALLOCATION ROUTINE
*
         SPACE 1
         LH    R0,DSNDSTYP         GET DATA SET TYPE.
         CH    R0,=C'SI'           IF SYSIN,
         BE    HALI                GO ALLOCATE.
         CH    R0,=C'SO'           IF SYSOUT,
         BE    HALO                GO ALLOCATE.
         CH    R0,=C'PS'           IF PROCESS-SYSOUT,
         BE    HALP                GO ALLOCATE.
         B     HAL800              ERROR - UNRECOGNIZED TYPE.
         EJECT
*
*
*              SYSIN DATA SET ALLOCATION
*
*
         SPACE 1
HALI     DS    0H
         LA    RIOT,SJBIOT         POINT TO THE 1ST IOT.
         BAL   R14,HALFINDP        ATTEMPT TO FIND DATA SET.
         BZ    HAL800              ERROR - DATA SET NOT FOUND.
         LR    RSIB,RSOX           SAVE SSAL ADDRESS IN RSIB.
         CALL  $SDBINIT            CREATE AN SDB FOR DATA SET.
         BNZ   HAL800              ERROR - NO STORAGE.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         ST    R4,SDBPDDB          SET PDDB ADDRESS AND ITS
         ST    RIOT,SDBPIOT        IOT ADDRESS IN THE SDB.
         BAL   R14,HALJMERG        MERGE PDDB INTO JFCB.
         SPACE 3
*
*              IF XBM BATCH INPUT UNIT, STORE SDB ADDRESS
*              IN SJB AND FLAG THE SDB AS BATCH INPUT.
*
         SPACE 1
         TM    SJBFLG1,SJB1XBM     IF NOT BATCH MONITOR INPUT,
         BZ    HAL950              RETURN.
         ST    RSDB,SJBXBSDB       POINT SJB TO BATCH INPUT SDB.
         OI    SDBFLG2,SDB2XBIN    SHOW SDB IS BATCH INPUT.
         B     HAL950              RETURN.
         SPACE 1
         DROP  RSDB                DROP SDB BASE.
         USING SSALBGN,RSOX        RESET SSAL ADDRESSABILITY.
         EJECT
*
*
*              SYSOUT DATA SET ALLOCATION
*
*                                                                    R4
         SPACE 1                                                     R4
HALO     DS    0H                                                    R4
         L     R5,PSATOLD-PSA      FIND CURRENT TCB                  R4
         L     R5,TCBTCT-TCB(,R5)  GET TCT ADDRESS                   R4
         LA    R5,0(,R5)           CLEAR HI-ORDER BYTE               R4
         LTR   R5,R5               TEST FOR SMF                      R4
         BZ    HALO10              BR IF NO                          R4
         L     R5,TCTJMR-SMFTCT(,R5)  GET JMR ADDRESS                R4
         L     R1,SJBJCT              GET JCT ADDRESS                R4
         USING JCTDSECT,R1         PROVIDE JCT ADDRESSABILITY        R4
         CLC   JCTUSEID,JCTUSEID-JCTJMR(R5)  TEST USER SMF INFO      R4
         BE    SKIP80                        BR IF UNCHANGED         R4
         OI    JCTFLAG1,JCT1CKPT             CAUSE JCT CKPT          R4
SKIP80   CLC   JCTUCOM,JCTUCOM-JCTJMR(R5)  TEST USER SMF INFO        R4
         BNE   SKIP90              BR IF CHANGED                     R4
         TM    JCTFLAG1,JCT1CKPT   IS JCT CKPT REQUIRED...           R4
         BZ    HALO10              BR IF NO                          R4
         SPACE 1                                                     R4
*                                                                    R4
*        USER FIELDS IN JMR MODIFIED -- TRANSFER TO JCT AND CKPT     R4
*                                                                    R4
         SPACE 1                                                     R4
SKIP90   MVC   JCTUSEID,JCTUSEID-JCTJMR(R5)  XFER USER SMF INFO      R4
         MVC   JCTUCOM,JCTUCOM-JCTJMR(R5)  XFER USER SMF INFO        R4
         NI    JCTFLAG1,255-JCT1CKPT  RESET CKPT FLAG                R4
         L     R0,SJBJCTRK         GET JCT TRACK ADDRESS             R4
         MVC   SJBFWORD,=CL4'JCT'  INDICATE JCT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE THE JCT                     R4
         DROP  R1                  KILL JCT ADDRESSABILITY           R4
HALO10   DS    0H                                                    R4
         L     R1,SSALPGMN         POINT TO USER WRITER NAME         R4
         CLC   =CL8'INTRDR',0(R1)  IF IT'S 'INTRDR',
         BE    HALR                ALLOCATE INTERNAL READER.
         EJECT                                                 @OZ39639
***************************************************************@OZ39639
*                                                              @OZ39639
*        IF 'JESNEWS' DATA SET -- CONFIRM AUTHORIZATION        @OZ39639
*                                                              @OZ39639
***************************************************************@OZ39639
         SPACE 1                                               @OZ39639
         SLR   R3,R3               ASSUME NOT JESNEWS DATA SET @OZ39639
         CLC   =CL8'JESNEWS',0(R1) JESNEWS...                  @OZ39639
         BNE   HALO15              BR IF NO                    @OZ39639
         SPACE 1                                               @OZ39639
         GETMAIN RC,LV=HALNEWSL    GETMAIN A WORK AREA         @OZ39639
         LTR   R15,R15             STORAGE AVAILABLE...        @OZ39639
         BNZ   HAL800              PASS BACK ERROR IF NOT      @OZ39639
         SPACE 1                                               @OZ39639
         USING HALNEWS,R6          WORK AREA ADDRESSABILITY    @OZ39639
         SPACE 1                                               @OZ39639
         LR    R6,R1               SET BASE                    @OZ39639
         MVC   HALNEWSM,HALNEWSW   MOVE LIST-FORM WTOR         @OZ39639
         MVC   HALNEWSJ+HALNEWSM,SJBJOBNM  INSERT JOBNAME      @OZ39639
         SPACE 1                                               @OZ39639
HALO12   MVI   HALNEWSE,0          RESET ECB                   @OZ39639
         WTOR  ,HALNEWSR,1,HALNEWSE,MF=(E,HALNEWSM)  ASK OPER  @OZ39639
         WAIT  ECB=HALNEWSE        WAIT FOR RESPONSE           @OZ39639
         OI    HALNEWSR,X'40'      FORCE UPPER-CASE            @OZ39639
         CLI   HALNEWSR,C'N'       OPERATOR REPLY 'N'...       @OZ39639
         BE    HALO13              BR IF YES                   @OZ39639
         CLI   HALNEWSR,C'Y'       OPERATOR REPLY 'Y'...       @OZ39639
         BNE   HALO12              ASK AGAIN IF NOT            @OZ39639
         LA    R3,C'N'              ELSE REMEMBER JESNEWS DS   @OZ39639
         OI    SSALFLG1,SSALTRKM     AND FORCE SEPARATE TGM    @OZ39639
         EJECT                                                 @OZ39639
HALO13   FREEMAIN R,LV=HALNEWSL,A=(R6)  FREE WORK AREA         @OZ39639
         LTR   R3,R3               OK TO ALLOCATE JESNEWS...   @OZ39639
         BZ    HAL800              PASS BACK ERROR IF NOT      @OZ39639
         B     HALO15               ELSE BR TO CONTINUE ALLOC  @OZ39639
         SPACE 1                                               @OZ39639
         DROP  R6                  DROP WORK AREA              @OZ39639
         SPACE 8                                               @OZ39639
         $MID 360                  ------ 360 -------          @OZ39639
         SPACE 2                                               @OZ39639
HALNEWSW WTOR  '&MID.******** REQUESTS ACCESS TO JESNEWS (Y OR N)',MF=L
HALNEWSJ EQU   *-44-HALNEWSW,8     JOBNAME INSERT              @OZ39639
HALNEWSN EQU   *-HALNEWSW          LIST-FORM WTOR LENGTH       @OZ39639
         SPACE 4                                               @OZ39639
HALNEWS  DSECT ,                   JESNEWS MESSAGE WORK AREA   @OZ39639
HALNEWSR DS    F                   REPLY AREA                  @OZ39639
HALNEWSE DS    F                   ECB                         @OZ39639
HALNEWSM DS    CL(HALNEWSN)        LIST-FORM WTOR              @OZ39639
HALNEWSL EQU   *-HALNEWS           WORK AREA LENGTH            @OZ39639
HASPSSSM CSECT ,                                               @OZ39639
         EJECT                                                 @OZ39639
*                                                              @OZ39639
*              TEST FLAGS SSALHOLD, SSALTRKM
*
         SPACE 1
HALO15   TM    SSALFLG1,SSALHOLD+SSALTRKM  IF SPIN OR HOLD,    @OZ39639
         BNZ   HALO20              BUILD AN IOT.
         CALL  HALCLASS            IF NOT SCATHOLD,
         BZ    HALO40              SKIP BUILDING IOT.
         SPACE 3
*
*              GET STORAGE FOR, CREATE, AND CHAIN AN IOT
*
         SPACE 1
HALO20   DS    0H
         TM    SJBFLG1,SJB1XBM+SJB1XBMC  IF NOT BATCH MONITOR,
         BZ    HALO30              CONTINUE.
         TM    SSALFLG1,SSALTRKM+SSALASNM  TEST FOR DYNAMIC ALLOCATE
         BZ    HALO40              TREAT AS NON SPIN/HOLD      @OZ20657
         B     HAL800              BUT DISALLOW DYNAMIC ALLOCATE
         SPACE 1
HALO30   DS    0H
         CALL  HCBGM               GET STORAGE FOR IOT.
         BNZ   HAL800              ERROR - NO STORAGE AVAILABLE.
         SPACE 1
         LR    RIOT,R1             SET IOT BASE REGISTER.
         L     R1,SJBIOT           POINT TO ALLOCATION IOT.
         LTR   R1,R1               IF NO ALLOCATION IOT,
         BZ    HALO50              ERROR - CAN'T GET TRACK.
         LA    R1,IOTMSTAB-IOTDSECT(,R1)     POINT TO MASTER TAB     R4
         CALL  $STRAK              GET A TRACK FOR THE IOT.
         L     R15,SJBIOT          GET ALLOCATION IOT ADDRESS  @OZ17477
         OI    IOTFLAG1-IOTDSECT(R15),IOT1CKPT FORCE IOT CHKPT @OZ17477
         SPACE 1
         CALL  HALCRIOT            FORMAT THE IOT.
         LTR   R3,R3               JESNEWS DATA SET...         @OZ39639
         BZ    *+8                 BR IF NO                    @OZ39639
         OI    IOTFLAG1,IOT1NEWS    ELSE SET INDICATION        @OZ39639
         SPACE 1
         CALL  HALCHIOT            CHAIN THE IOT.
         SPACE 1
         B     HALO80              CREATE A PDDB.
         SPACE 3
*
*              IF SSALASNM, DON'T BOTHER SEARCHING PDDBS
*
         SPACE 1
HALO40   DS    0H
         TM    SSALFLG1,SSALASNM   IF DSNAME ASSIGNED HERE,
         BO    HALO60              SKIP PDDB SEARCH.
         SPACE 3
*
*              OTHERWISE SEARCH PDDBS FOR SAME DS KEY
*
         SPACE 1
         LA    RIOT,SJBIOT         POINT TO THE 1ST IOT.
         BAL   R14,HALFINDP        TEST FOR PREV-CREATED PDDB.
         LR    R6,R4               POINT R6 TO PDDB.
         BC    13,HALO45           BRANCH IF PDDB NOT FOUND.
         L     R1,SSALSOUT         POINT TO DATA SET STATUS.
         TM    0(R1),1             IF OLD AND PDDB EXISTS,
         BO    HALO100             GO BUILD AN SDB.
         USING PDBDSECT,R6         SET PDDB ADDRESSABILITY.
         OI    PDBFLAG1,PDB1NULL   NEW.  SHOW NEW PDDB.
         OI    IOTFLAG1,IOT1CKPT   FLAG IOT FOR CHECKPOINT.
         B     HALO100             THEN GO BUILD AN SDB.
HALO45   L     R1,SSALSOUT         POINT TO SCTSBYT3.
         TM    0(R1),1             SINCE PDDB NOT FOUND,
         BO    HAL800              ERROR IF DISP=OLD.
         B     HALO60              CONTINUE IF DISP=NEW.
         SPACE 3
*
*              ERROR ROUTINE TO FREE IOT AND EXIT
*
         SPACE 1
HALO50   DS    0H
         LR    R1,RIOT             POINT R1 TO THE IOT.
         CALL  HCBFM               FREE IT.
         B     HAL800              GO TO ERROR EXIT.
         SPACE 3
*
*              FIND THE LAST IOT ON SJBIOT                           R4
*
         SPACE 1
HALO60   DS    0H
         L     R1,SJBIOT           POINT TO THE 1ST IOT.
HALO70   DS    0H
         LR    RIOT,R1             SET IOT BASE.
         L     R1,IOTIOT           POINT TO THE NEXT IOT.
         LTR   R1,R1               IF IT EXISTS,
         BNZ   HALO70              LOOP TILL LAST IS FOUND.
         SPACE 3
*
*              CREATE A PERIPHERAL DATASET DEFINITION BLOCK
*
         SPACE 1
HALO80   DS    0H
         PACK  SJBDBLWK,DSNDSNR    SET PACKED DS KEY.
         CALL  HALCRPDB            CREATE A PDDB.
         BC    2,HALO30            NO ROOM IN IOT,GET ANOTHER  @OZ20657
         BC    4,HAL820            ERROR - INVALID DESTINATION.
         SPACE 3
*
*              CREATE ADDITIONAL PDDBS FOR MULTIPLE DESTINATIONS
*
         SPACE 1
         TM    PDBFLAG1,PDB1MDES   IF NOT MULTIPLE DESTINATIONS,
         BZ    HALO100             SKIP MULTIPLE PDDBS.
         L     R7,SJBJCT           POINT TO THE HASP JCT.
         USING JCTDSECT,R7         SET JCT ADDRESSABILITY.
         STM   R5,R6,JCTWORK+12    SAVE FIRST IOT & PDDB ADDRS.
         CL    RIOT,SJBIOT         UNLESS THE PDDB'S IOT
         BE    *+8                 IS THE MAIN ALLOCATION IOT,
         NI    IOTFLAG1,255-IOT1ALOC  DON'T USE IT FOR ALLOC.
HALO84   DS    0H
         MVC   JCTWORK(8),JCTWORK+2  GET NEXT DESTINATION.
         LH    R2,JCTWORK          GET IT INTO REGISTER 2.
         LTR   R2,R2               IF IT'S DEFAULT,                  R4
         BE    HALO95              WE'RE AT THE END.
         TM    PDBFLAG1,PDB1PSO    IF CURRENT PDDB IS PSO,
         BO    HALO87              GO BUILD A NEW IOT.
         L     R4,IOTPDDBP         GET OFFSET FOR NEXT PDDB.
         LA    R15,PDBLENG(,R4)    IF THIS IOT                       R4
         CH    R15,IOTLENG         HAS ROOM                          R4
         BNH   HALO90              FOR ANOTHER PDDB, BRANCH.
HALO87   DS    0H
         CALL  HCBGM               GET SPACE FOR AN IOT.
         BNZ   HAL800              ERROR - NO STORAGE AVAILABLE.
         LR    RIOT,R1             SET IOT BASE REGISTER.
         L     R1,SJBIOT           POINT TO ALLOCATION IOT.
         LA    R1,IOTMSTAB-IOTDSECT(,R1)     THENCE TO MASTER TAB    R4
         CALL  $STRAK              GET A TRACK FOR NEW IOT.
         L     R15,SJBIOT          GET ALLOCATION IOT ADDRESS  @OZ17477
         OI    IOTFLAG1-IOTDSECT(R15),IOT1CKPT FORCE IOT CHKPT @OZ17477
         CALL  HALCRIOT            FORMAT THE IOT.
         NI    IOTFLAG1,255-IOT1ALOC  DON'T USE ITS TGM.
         CALL  HALCHIOT            CHAIN THE IOT.
         L     R4,IOTPDDBP         GET OFFSET TO FIRST PDDB.
HALO90   DS    0H
         LA    R1,0(R4,RIOT)       GET ABSOLUTE PDDB ADDRESS.
         MVC   0(PDBLENG,R1),0(R6) MOVE NEW PDDB.
         STH   R2,PDBDEST-PDBDSECT(,R1)  SET NEW DESTINATION.
         LA    R0,PDBLENG(,R4)     GET OFFSET TO NEXT PDDB
         ST    R0,IOTPDDBP         AND STORE IT IN IOT.
         B     HALO84              TRY FOR ANOTHER PDDB.
HALO95   DS    0H
         LR    R6,R1               POINT R6 TO MOST-RECENT PDDB.
         TM    IOTFLAG1,IOT1SPIN   IF SPIN, IOTS ARE CHAINED
         BO    *+8                 LIFO - SDBPIOT AND SDBPDDB
*                                  MUST POINT TO LAST-CREATED.
         LM    R5,R6,JCTWORK+12    RESTORE 1ST PDDB, IOT PTRS.
         DROP  R7                  DROP JCT ADDRESSABILITY.
         L     RJFC,SSALJFCB       POINT TO JFCB.
         USING INFMJFCB,RJFC       SET JFCB ADDRESSABILITY.
         SPACE 3
         SPACE 3
*
*              FINALLY, CREATE A SUBSYSTEM DATASET BLOCK
*
         SPACE 1
HALO100  DS    0H
         LR    RSIB,RSOX           POINT RSIB TO SSAL.
         DROP  RSOX                CHANGE SSAL
         USING SSALBGN,RSIB        ADDRESSABILITY.
         CALL  $SDBINIT            GET STORAGE, FORMAT SDB.
         BNZ   HAL800              ERROR - NO STORAGE AVAILABLE.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         TM    PDBFLAG2,PDB2TCEL   IS THIS A TRAKCELL'ED DATA SET    R4
         BZ    SKIP100             BR IF NO                          R4
         OI    SDBTAB+(TABFLAG-TABDSECT),TABMAJOR  SHOW MAJOR TAB    R4
SKIP100  L     R1,SSALCLAS         IF OUTPUT CLASS
         CLI   0(R1),C'$'          IS DOLLAR-SIGN
         BE    HALO110             OR ASTERISK,
         CLI   0(R1),C' '          OR NULL                          R41
         BE    HALO110                                              R41
         CLI   0(R1),C'*'          SET FLAG SDB2MCLS.
         BNE   HALO120             THIS IS USED BY
HALO110  OI    SDBFLG2,SDB2MCLS    XBM CONTINUATION.
HALO120  DS    0H
         ST    R6,SDBPDDB          POINT SDB TO THE PDDB
         ST    RIOT,SDBPIOT        AND TO ITS IOT.
         L     R1,JFCOUTLI-1       GET OUTPUT LIMIT FROM JFCB.
         LA    R1,0(,R1)           IT'S ONLY 3 BYTES LONG.
         BCTR  R1,0                REDUCE 0 TO -1.
         ST    R1,SDBOUTLM         SET OUTPUT LIMIT IN SDB.
         MVC   SDBAIOT,SJBIOT      SET ALLOCATION IOT DEFAULT.
         TM    IOTFLAG1,IOT1ALOC   IF PDDB'S IOT SAYS ALLOCATE,
         BZ    *+8                 HOWEVER,
         ST    RIOT,SDBAIOT        USE PDDB'S IOT INSTEAD.
         MVC   SDBDKEY,PDBDSKEY    SET DATA SET KEY IN SDB.
         OI    SDBFLG1,SDB1PUT+SDB1OUT  SHOW PUT, SYSOUT.
* TEST FOR RESTART SITUATION
         TM    PDBFLAG1,PDB1NULL   IF PDDB UNOPENED,
         BO    HALO200             SKIP.
         L     R1,SSALSOUT         IF DATA SET SAYS IT'S
         TM    0(R1),1             OLD, THIS IS RESTART.
         BZ    HALO200             SKIP IF NEW.
         MVC   SDBTRK+1(4),PDBMTTR SET UP SDBTRK
         MVC   SDBTRK+5(3),=X'FFFFFF'  FOR POINT IN OPEN.
         MVC   SDBTRKF+1(4),PDBMTTR  SET DATA SET'S
         MVI   SDBTRKF+7,1         STARTING RBA.
HALO200  DS    0H
         B     HAL900              RETURN.
         DROP  R6,RSIB,RSDB        DROP PDDB, SSAL, SDB BASES.
         USING SSALBGN,RSOX        SET SSAL ADDRESSABILITY.
         EJECT
*
*
*              PROCESS-SYSOUT DATA SET ALLOCATION
*
*
         SPACE 1
HALP     DS    0H
         L     R4,SJBPSOP          POINT TO THE PSO BLOCK.
         LTR   R4,R4               IF IT DOESN'T EXIST,
         BZ    HAL800              ERROR - CAN'T ALLOCATE.
         USING PSODSECT,R4         GET PSO ADDRESSABILITY.
         SPACE 3
*
*              BUILD AN SDB FOR THE DATA SET
*
         SPACE 1
         LR    RSIB,RSOX           POINT RSIB TO THE SSAL.
         CALL  $SDBINIT            CREATE AN SDB.
         BNZ   HAL800              ERROR - NO STORAGE AVAILABLE.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         MVC   SDBJKEY,PSOJBKEY    SET JOB KEY IN SDB.
         LA    R4,PSOPDDB          GET PSO PDDB ADDRESS
         USING PDBDSECT,R4         GET PDDB ADDRESSABILITY     @OZ59731
         MVC   JFCRECFM,PDBRECFM   MERGE RECFM FROM PDDB       @OZ59731
         NI    JFCRECFM,JFCASA+JFCMAC  RETAIN C.C.             @OZ59731
         OI    JFCRECFM,JFCUND     FAKE U FOR XWTR OPEN        @OZ59731
         BAL   R14,HALJMERG        MERGE PDDB INTO JFCB.
         ST    R4,SDBPDDB          POINT SDB TO PDDB.
         OI    SDBFLG1,SDB1PSO     SHOW PSO TYPE.
         B     HAL950              RETURN SKIPPING CHECKPOINT.
         DROP  R4,RJFC,RSDB        DROP PDDB, JFCB, SDB BASES.
         EJECT
*
*              INTERNAL READER DATA SET ALLOCATION
*
HALR     DS    0H
         LR    RSIB,RSOX           POINT RSIB TO THE SSAL.
         USING SSALBGN,RSIB        SET SSAL ADDRESSABILITY.
*
*              CHECK AUTHORIZATION, IF NECESSARY
*
         TM    SSALFLG1,SSALASNM   IS THIS DYNAMIC ALLOCATION...
         BZ    HALR10              IF NOT, GO ALLOCATE.
         L     R10,PSATOLD-PSA     DYNAMIC.  POINT TO TCB,
         L     R10,TCBJSCB-TCB(,R10)  THENCE TO JSCB,
         L     R10,JSCBACT-IEZJSCB(,R10) THENCE TO ACTIVE JSCB.     R41
         L     R10,JSCBPSCB-IEZJSCB(,R10)  THENCE TO PSCB.
         LTR   R10,R10             IS THERE A PSCB...
         BZ    HALR10              IF NOT, GO ALLOCATE.
         TM    PSCBATR1-PSCB(R10),PSCBJCL  IF USER IS AUTHORIZED,
         BO    HALR10              GO ALLOCATE AN INTRDR.
         LA    R15,SSALNAUT        SHOW ALLOCATION NOT AUTHORIZED
         $EPILOG KEY=0             AND RETURN.
*
*              IT IS OKAY TO ALLOCATE AN INTERNAL READER
*
HALR10   DS    0H
*
*              ACQUIRE CROSS-MEMORY SERVICES LOCK
*
         LR    R1,R13              SAVE SAVEAREA POINTER
         STM   R11,R13,12(R1)      SAVE REGISTERS 11 THROUGH 13.
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(HALR40,HALR90,HC
               ALR110)             OBTAIN LOCAL LOCK.
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=(HALR40,HALR90,HALC
               R110)               OBTAIN CMS LOCK.
         LM    R11,R13,12(R1)      RESTORE REGISTERS 11 THROUGH 13.
*
*              SEE IF JES2 WAS INITIALIZED WITH INTERNAL READERS     R4
*
HALR19   L     R1,PSAAOLD-PSA      POINT TO CURRENT ASCB.
         L     R10,$SVIRDRS        POINT TO FIRST INTRDR DCT.
         USING DCTDSECT,R10        USE DCT DSECT.
         SPACE 1                                               @OZ35996
         LH    R2,$SVNINRS         GET INTERNAL READER COUNT   @OZ35996
         BCTR  R2,0                REDUCE BY 2 FOR
         BCTR  R2,0                STCINRDR, TSOINRDR.
         L     R10,DCTCHAIN        BYPASS STCINRDR
         L     R10,DCTCHAIN        BYPASS TSOINRDR.
         LTR   R2,R2               ARE THERE ANY INTRDRS AT ALL...
         BZ    HALR90              NO, CAN'T ALLOCATE                R4
         SR    R0,R0               ZERO COUNTER, USED TO SEE IF ALL
*                                  ALLOCATED INTERNAL READERS BELONG
*                                  TO THIS CALLER'S MEMORY.
*
*              FIND AN UNALLOCATED INTERNAL READER
*
HALR20   DS    0H
         TM    RIDFLAGS,RIDALLOC   IS THIS INTRDR ALLOCATED...
         BZ    HALR100             IF NOT, WE'LL TAKE IT.
         CL    R1,RIDASCBP         YES.  IS IT ALLOC'D TO SAME
         BE    *+6                 MEMORY AS REQUESTOR...
         BCTR  R0,0                IF NOT, COUNT A CANDIDATE.
         L     R10,DCTCHAIN        POINT TO NEXT INTRDR DCT.
         BCT   R2,HALR20           BRANCH TO EXAMINE IT.
*
*              ALL INTERNAL READERS ARE ALLOCATED
*
HALR30   DS    0H
         LTR   R0,R0               ARE ALL ALLOCATED TO CALLER'S MEM...
         BZ    HALR90              IF SO, UNABLE TO ALLOCATE.
         TM    SSALFLG1,SSALWAIT   IS CANCEL ECB VALID...
         BZ    HALR90              IF NOT, DO NOT WAIT.
*
*              GET A WAIT ELEMENT
*
         $GETMAIN RC,LV=32,SP=231,KEY=1  GET WAIT ELEMENT.
         BNZ   HALUNSC             BRANCH IF ELEMENT NOT GOT.
*
*        WAIT ELEMENT ---
*              +0  - CHAIN (HEADER IS $SVIRWT)
*              +4  - ECB FOR UNALLOCATE TO POST
*              +8  - ECB POINTER FOR XMPOST
*              +12 - ASCB POINTER FOR XMPOST
*              +16 - ERRET POINTER FOR XMPOST
*              +20 - ECBLIST 1 - POINTER TO CANCEL ECB
*              +24 - ECBLIST 2 - POINTER TO ABOVE ECB
*
*
*              FILL IN THE WAIT ELEMENT
*
         MVI   4(R1),0             CLEAR UNALLOCATE ECB.
         LA    R2,4(,R1)           POINT TO UNALLOCATE ECB.
         ST    R2,8(,R1)           SET POINTER FOR XMPOST.
         ST    R2,24(,R1)          SET POINTER FOR WAIT.
         MVI   24(R1),X'80'        TERMINATE ECBLIST.
         L     R2,CVTPTR           POINT TO CVT,
         L     R3,PSAAOLD-PSA      POINT TO CURRENT ASCB.
         ST    R3,12(,R1)          SAVE ASCB POINTER FOR XMPOST.
         LA    R3,CVTBRET-CVT(,R2) POINT TO 'BR 14'.
         ST    R3,16(,R1)          SET ERRET POINTER FOR XMPOST.
         MVC   20(4,R1),SSALCNCL   SET CANCEL ECB POINTER FOR WAIT.
         L     R0,$SVIRWT          CHAIN NEW
         ST    R0,0(,R1)           WAIT ELEMENT
         CS    R0,R1,$SVIRWT       LAST-IN-FIRST-OUT
         BNE   *-8                 ON HEADER $SVIRWT.
         LR    R3,R1               SAVE WAIT ELEMENT ADDRESS.
*
*              RELEASE CMS LOCK
*
HALR40   DS    0H
         LR    R2,R13              SAVE SAVEAREA POINTER.
         STM   R11,R13,12(R2)      SAVE REGISTERS 11 - 13.
         SETLOCK RELEASE,TYPE=CMS,RELATED=HALR10  RELEASE CMS LOCK.
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=HALR10                     C
                                   RELEASE LOCAL LOCK.
         LM    R11,R13,12(R2)      RESTORE REGISTERS 11 - 13.
*
*              WAIT FOR CANCEL OR UNALLOCATION.
*
         WAIT  1,ECBLIST=20(,R1)   WAIT.
*
*              WHEN POSTED, REESTABLISH CMS LOCK
*
HALR45   SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=(HALR90,HALR110)C
                                   AGAIN OBTAIN CMS LOCK.
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=(HALR90,HALR110)  C
                                   AGAIN OBTAIN LOCAL LOCK.
         LM    R11,R13,12(R2)      RESTORE REGISTERS 11 THROUGH 13.
*
*              DECHAIN AND FREE WAIT ELEMENT.
*
         LR    R1,R3               POINT R1 TO SUBJECT WAIT ELEMENT.
         LA    R2,$SVIRWT          POINT R2 TO HEADER.
HALR50   LR    R3,R2               SAVE PREVIOUS POINTER.
         L     R2,0(,R2)           GET NEXT POINTER.
         LTR   R2,R2               IF ZERO, CHAIN ENDS
         BZ    HALR60              - MERELY FREE SUBJECT ELEMENT.
         CLR   R1,R2               IF NEXT DOESN'T MATCH SUBJECT,
         BNE   HALR50              KEEP TRYING.
         MVC   0(4,R3),0(R1)       DECHAIN SUBJECT.
HALR60   $FREMAIN RU,A=(R1),LV=32,SP=231,KEY=1  FREE WAIT ELEMENT.
*
*              NOW FIND WHY WE WERE POSTED
*
         L     R1,SSALCNCL         POINT TO CANCEL ECB.
         TM    0(R1),X'40'         IS IT POSTED...
         BZ    HALR19              IF NOT, TRY AGAIN TO ALLOCATE.
         LR    R2,R13              CANCEL REQUESTED -
         STM   R11,R13,12(R2)      SAVE REGISTERS 11 - 13 AND
         SETLOCK RELEASE,TYPE=CMS,RELATED=HALR45  UNLOCK FROM CMS.
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=HALR45                     C
                                   RELEASE LOCAL LOCK.
         LM    R11,R13,12(R2)      RESTORE REGISTERS 11 - 13.
         LA    R15,SSALCREQ        SHOW CANCEL REQUEST.
         $EPILOG KEY=0             RETURN TO CALLER.
         SPACE 3
*
*              BRANCH TO HERE IF UNABLE TO ALLOCATE
*
HALR90   DS    0H
         LR    R2,R13              SAVE REGISTERS
         STM   R11,R13,12(R2)      11 THROUGH 13.
         SETLOCK RELEASE,TYPE=CMS,RELATED=(HALR10,HALR45)  UNLOCK CMS.
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=(HALR10,HALR45)            C
                                   RELEASE LOCAL LOCK.
         LM    R11,R13,12(R2)      RESTORE REGISTERS 11 THROUGH 13.
         LA    R15,SSALWTFL        SHOW UNABLE TO ALLOCATE.
         $EPILOG KEY=0             RETURN TO CALLER.
         EJECT
*
*              WE FOUND AN INTERNAL READER.  ALLOCATE IT.
*
HALR100  DS    0H
         MVC   RIDASCBP,PSAAOLD-PSA  POINT DCT TO ASCB.
         OI    RIDFLAGS,RIDALLOC   SHOW INTRDR ALLOCATED.
*              THIS LINE DELETED BY APAR ===>                  @OZ41586
*              THIS LINE DELETED BY APAR ===>                  @OZ41586
*
*              RELEASE CMS LOCK
*
HALR110  DS    0H
         LR    R2,R13              SAVE REGISTERS
         STM   R11,R13,12(R2)      11 THROUGH 13.
         SETLOCK RELEASE,TYPE=CMS,RELATED=(HALR10,HALR45)  UNLOCK CMS.
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=(HALR10,HALR45)            C
                                   RELEASE LOCAL LOCK.
         LM    R11,R13,12(R2)      RESTORE REGISTERS 11 THROUGH 13.
         SPACE 2
*
*              SET DEFAULT OUTPUT CLASS IN INTRDR
*
         L     R7,SJBJCT           POINT TO JCT                      R4
         L     R1,SSALCLAS         POINT TO OUTPUT CLASS.
         LTR   R1,R1               IS POINTER ZERO...
         BZ    HALR120             IF SO, SET CLASS A.
         MVC   DCTMCLAS,0(R1)      ELSE SET SPECIFIED CLASS.
         CLI   DCTMCLAS,C'$'       IF CLASS IS $
         BE    HALR113             OR
         CLI   0(R1),C' '          NULL                             R41
         BE    HALR113             OR                               R41
         CLI   DCTMCLAS,C'*'       IF CLASS IS *,
         BNE   HALR116
HALR113  DS    0H
         USING JCTDSECT,R7         JOB'S MSGCLASS=
         MVC   DCTMCLAS,JCTMCLAS   FOR
         DROP  R7                  ALLOCATED CLASS.
HALR116  DS    0H
         CLI   DCTMCLAS,C'A'       IS CLASS VALID...
         BNL   HALR130             BRANCH IF SO.
HALR120  DS    0H
         MVI   DCTMCLAS,C'A'       SET CLASS A AS DEFAULT.
HALR130  DS    0H
         EJECT                                                 @OZ68422
*                                                              @OZ68422
*        SET OWNING JOBNAME, JOBID IN INTRDR DCT               @OZ68422
*                                                              @OZ68422
         MVC   RIDJBID(8),JCTJOBID-JCTDSECT(R7) MOVE JOBID     @OZ68422
         MVC   RIDJNAM(8),JCTJNAME-JCTDSECT(R7) AND JOBNAME    @OZ68422
         SPACE 2
*
*              SET DEFAULT DESTINATION IN INTRDR
*
         L     R1,SSALDEST         POINT TO ARG DESTINATION.
         CLC   =CL8' ',0(R1)       IF NOT ALL BLANKS,
         BNE   HALR140             GO CONVERT IT.
         L     R1,4(,R13)          ELSE POINT TO PREV SAVEAREA
         L     R1,24(,R1)          & GET CALLER'S REG 1.
         USING SSOB,R1             SET SSOB ADDRESSABILITY.
         L     R1,SSOBSSIB         POINT TO SSIB.
         USING SSIB,R1             SET SSIB ADDRESSABILITY.
         LA    R1,SSIBDEST         POINT TO DEFAULT DESTINATION.
         DROP  R1                  DROP SSIB ADDRESSABILITY.
HALR140  DS    0H
         SLR   R2,R2               CLEAR REGISTER                    R4
         IC    R2,$SVTOSYS         SET DEFAULT FIRST BYTE            R4
         CALL  USERDEST            CONVERT DESTINATION.
         B     HALR190             +0 - INVALID DESTINATION
*                                  +4 - R2 CONTAINS DESTINATION.
         LTR   R2,R2               ANY ROUTE SPECIFIED...            R4
         BNZ   HALR145             BR IF YES                         R4
         ICM   R2,2,$SVTOSYS       SET 'LOCAL   '                    R4
         SPACE 1                                                     R4
HALR145  DS    0H                                                    R4
         STH   R2,DCTPRINT         SET PRINT AND
         STH   R2,DCTPUNCH         PUNCH DESTINATIONS
         B     HAL975              AND RETURN.
         SPACE 2
* INVALID DESTINATION
HALR190  DS    0H
         NI    RIDFLAGS,255-RIDALLOC  UNALLOCATE INTRDR.
         XC    RIDJBID(8),RIDJBID  ZERO JOB ID                 @OZ68422
         XC    RIDJNAM(8),RIDJNAM    AND NAME OF OWNER         @OZ68422
         LA    R15,SSALIDST        SET INVALID DESTINATION     @OZ20021
         $EPILOG                   RETURN                      @OZ20021
         DROP  R10                 DROP DCT BASE.
         EJECT
*
*
*              FAILURE IN ALLOCATION
*
*
HAL800   DS    0H
HALUNSC  EQU   HAL800
         LA    R15,SSALUNAL        SET UNABLE-TO-ALLOCATE.
         B     HAL890              RETURN.
HAL820   DS    0H
         LA    R15,SSALIDST        SET INVALID DESTINATION.
         SPACE 3
HAL890   DS    0H
         LR    R2,R15              SAVE RETURN CODE IN R2.
         CALL  HCBCK               CHECKPOINT MAY BE REQUIRED.
         LR    R15,R2              RESTORE RETURN CODE.
         $EPILOG ,                 RETURN.
         SPACE 3
*
*
*              NORMAL EXIT FROM ALLOCATION
*
*
         SPACE 1
HAL900   DS    0H
         CALL  HCBCK               CHECKPOINT MARKED BLOCKS.
         SPACE 1
HAL950   DS    0H
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         L     R1,SSALDDNM         SAVE DATA SET'S DDNAME
         MVC   SDBDDNM,0(R1)       IN THE SDB.
HAL975   DS    0H
         ST    RSDB,SSALSSCM       POINT SSALSSCM TO SDB/DCT.
         L     R1,SSALSSNM         GET ADDRESS OF SUBSYSTEM NAME.
         MVC   0(4,R1),$SVSSNM     MOVE SUBSYSTEM NAME.
         SLR   R15,R15             SHOW NORMAL EXIT.
         $EPILOG ,                 RETURN.
         DROP  RIOT,RSIB,RSDB      DROP IOT, SSAL, SDB BASES.
         TITLE 'HALCRDSN -- SUBROUTINE TO CREATE DSNAME'
*
*        ROUTINE NAME - HALCRDSN
*
*        PURPOSE - TO CREATE AN APPROPRIATE DATA SET NAME FOR AN
*              OUTPUT SUBSYSTEM DATA SET, INCLUDING DATA SET
*              KEY ASSIGNMENT.
*
*        FUNCTION/OPERATION -
*              1.  MOVE 4-CHARACTER SUBSYSTEM NAME FROM SSVT TO
*                  USER AREA.  FOLLOW IT WITH A PERIOD.
*              2.  MOVE JOB TYPE (JOB, STC, TSU) FROM SJB TO
*                  USER AREA.
*              3.  MOVE NUMERIC JOB ID FROM SJB TO USER AREA,
*                  FOLLOWED BY PERIOD, INSURING THAT LEADING
*                  BLANKS OF ID BECOME EBCDIC ZEROES.
*              4.  MOVE 'SO' TO USER AREA TO SHOW SYSOUT DATA SET.
*              5.  INCREMENT BY ONE THE JCT'S DATA SET KEY AND
*                  SUPPLY THE INCREMENTED VALUE IN EBCDIC TO
*                  USER AREA.
*              6.  BLANK OUT THE REMAINING USER AREA AND RETURN.
*              NOTE - THE USER AREA IS TYPICALLY A JFCB AS
*                  FURNISHED TO THE 'ALLOCATE' SUBSYSTEM
*                  INTERFACE.
*
*        REGISTERS AT ENTRY -
*              R7  = USER AREA, TYPICALLY A JFCB
*              R11 = SUBSYSTEM VECTOR TABLE
*              R13 = SUBSYSTEM JOB BLOCK
*              R14 = RETURN ADDRESS
*
*        REGISTER USAGE IN ADDITION TO THE ABOVE -
*              R1  = HASP JCT
*              R2  = WORK REGISTER
*              NOTE - ADDRESSABILITY IS THE SAME AS HOSALLOC
*
*        REGISTER DIFFERENCES AT EXIT -
*              R1, R2 DESTROYED
*
*        EXIT - NORMAL -
*              ON R14
*
HALCRDSN DS    0H
         USING INFMJFCB,R7         SET JFCB ADDRESSABILITY.
         MVC   DSNSSNM,$SVSSNM     SET SUBSYSTEM NAME.
         MVI   DSNSSNM+4,C'.'      SET PERIOD.
         MVC   DSNJBID(3),SJBJOBID SET JOB TYPE.
         PACK  SJBDBLWK(3),SJBJOBID+3(5)  PACK JOB NUMBER.
         UNPK  DSNJBNR,SJBDBLWK(3) UNPACK IT TO USER AREA.
         MVI   DSNJBID+8,C'.'      SET PERIOD.
         MVC   DSNDSTYP,=C'SO'     SET 'SO' FOR SYSOUT.
         L     R1,SJBJCT           POINT TO THE JCT.
         USING JCTDSECT,R1         SET JCT ADDRESSABILITY.
         L     R2,JCTPDDBK         GET LAST-USED DS KEY.
         AL    R2,=FS16'1'         ADD 1 TO IT.
         ST    R2,JCTPDDBK         STORE IT BACK IN THE JCT.
         OI    JCTFLAG1,JCT1CKPT   REQUIRE JCT CHECKPOINT.
         SRL   R2,16               RIGHT-JUSTIFY DS KEY.
         CVD   R2,SJBDBLWK         CONVERT TO PACKED DECIMAL.
         OI    SJBDBLWK+7,X'0F'    FORCE ZONE TO ALL ONES.
         UNPK  DSNDSNR,SJBDBLWK+5(3)  SET DATA SET NUMBER.
         MVI   DSNBLANK,C' '       PAD DATA SET NAME
         MVC   DSNBLNK1,DSNBLANK   WITH BLANKS.
         DROP  R1,R7               DROP JCT, JFCB BASES.
         BR    R14                 RETURN TO CALLER.
         TITLE 'HALFINDP -- SEARCH IOT CHAIN FOR PDDB'
*
*
*              HALFINDP -- FIND PDDB IN IOT CHAIN BY DATASET KEY
*
*
* THIS SUBROUTINE OPERATES UNDER HOSALLOC ADDRESSABILITY
         SPACE 1
HALFINDP DS    0H
         SL    RIOT,=A(IOTIOT-IOTDSECT)  SET UP FOR CHAINING.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         USING SSALBGN,RSOX        SET SSOB EXT ADDRESSABILITY.
         L     R7,SSALJFCB         POINT TO THE DATA SET'S JFCB.
         USING INFMJFCB,R7         SET JFCB ADDRESSABILITY.
         PACK  SJBDBLWK,DSNDSNR    PACK DATA SET NUMBER.
         CVB   R0,SJBDBLWK         CONVERT IT TO BINAR.
HALFP10  DS    0H
         L     RIOT,IOTIOT         POINT TO THE NEXT IOT.
         LTR   RIOT,RIOT           IF NO MORE IOTS,
         BZR   R14                 RETURN CC=0 - PDDB NOT FOUND.
         L     R1,IOTPDDBP         GET OFFSET AFTER LAST PDDB.
         ALR   R1,RIOT             MAKE IT ABSOLUTE.
         LR    R4,RIOT             POINT TO                          R4
         AL    R4,$SVPDDB1          FIRST PDDB                       R4
         USING PDBDSECT,R4         SET PDDB ADDRESSABILITY.
HALFP20  DS    0H
         CLR   R4,R1               ARE WE PAST PDDBS IN IOT...
         BNL   HALFP10             BRANCH IF SO.
         CH    R0,PDBDSKEY         DOES THIS PDDB MATCH DS KEY...
         BE    HALFP30             BRANCH IF SO.
         LA    R4,PDBLENG(,R4)     POINT TO NEXT PDDB.
         B     HALFP20             AND CHECK IT.
HALFP30  DS    0H
         SLR   R15,R15             CORRECT PDDB FOUND -
         BR    R14                 RETURN TO CALLER WITH CC=2.
         SPACE 1
         DROP  RIOT,RSOX,R7,R4     DROP BASES.
         TITLE 'HALJMERG -- SUBROUTINE TO MERGE PDDB FIELDS INTO JFCB'
*
*
*              HALJMERG - SUBROUTINE TO MERGE JFCB FIELDS
*
*
         SPACE 1
HALJMERG DS    0H
         USING PDBDSECT,R4         SET PDDB ADDRESSABILITY.
         USING INFMJFCB,R7         SET JFCB ADDRESSABILITY.
* MERGE JFCRECFM
         CLI   JFCRECFM,0          IF JFCRECFM NOT ZERO,
         BNE   HJM020              SKIP MERGE.
         MVC   JFCRECFM,PDBRECFM   MERGE JFCRECFM.
* MERGE JFCLRECL AND JFCBLKSI
HJM020   DS    0H
         SLR   R0,R0               ZERO R0 FOR COMPARE.
         LH    R1,PDBLRECL         GET PDBLRECL IN R1
         LR    R15,R1              (AND R15 FOR JFCBLKSI).
         TM    JFCRECFM,JFCUND     BR IF                            R41
         BO    HJM040               RECFM=U                         R41
         TM    JFCRECFM,JFCVAR     BR IF                            R41
         BO    HJM030               RECFM=V                         R41
         OI    JFCRECFM,JFCFIX+JFCRFB  ELSE FORCE RECFM=FB          R41
         B     HJM040              BR TO CONTINUE                   R41
HJM030   DS    0H                                                   R41
         LA    R1,4(,R1)           VARIABLE. SET LRECL, BLKSI
         LA    R15,4(,R1)          SET BLKSI = LRECL+4.
HJM040   DS    0H
         CH    R0,JFCLRECL         IF JFCLRECL NOT ZERO,
         BNE   *+8                 DON'T MERGE.
         STH   R1,JFCLRECL         MERGE JFCLRECL.
         CH    R0,JFCBLKSI         IF JFCBLKSI NOT ZERO,
         BNE   HJM080              DON'T MERGE.
         LH    R0,DSNDSTYP         GET DATA SET TYPE           @OZ60973
         CH    R0,=C'SI'            IF FOR SYSIN DS            @OZ60973
         BNE   HJM050                MOVE JFCLRECL TO          @OZ60973
         LH    R15,JFCLRECL           JFCBLKSI                 @OZ60973
HJM050   STH   R15,JFCBLKSI        MERGE JFCBLKSI              @OZ60973
* MERGE JFCFCBID
HJM080   DS    0H
         L     R0,JFCFCBID         IF JFCFCBID
         LTR   R0,R0               IS NOT ZERO,
         BNZ   HJM100              DON'T MERGE.
         MVC   JFCFCBID,PDBFCB     MERGE JFCFCBID.
* MERGE JFCUCSID
HJM100   DS    0H
         L     R0,JFCUCSID         IF JFCUCSID
         LTR   R0,R0               IS NOT ZERO,
         BNZ   HJM120              DON'T MERGE.
         MVC   JFCUCSID,PDBUCS     MERGE JFCUCSID.
* MERGE JFCFUNC
HJM120   DS    0H
         CLI   JFCFUNC,0           IF JFCFUNC IS NONZERO,
         BNE   HJM140              DON'T MERGE.
         MVC   JFCFUNC,PDBFUNC     MERGE JFCFUNC.
* THAT'S ALL THE MERGES.
HJM140   DS    0H
         BR    R14                 RETURN.
         DROP  R4,R7               DROP PDDB, JFCB BASES.
         TITLE 'HALCRIOT -- SUBROUTINE TO FORMAT AN IOT'
*
*
*              HALCRIOT -- SUBROUTINE TO FORMAT AN IOT
*
*
         SPACE 1
HALCRIOT DS    0H
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         USING *,R12               SET LOCAL ADDRESSABILITY.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET LOCAL BASE.
         SPACE 3
*
*              CLEAR FIRST PART OF IOT
*
         SPACE 1
         LR    R0,RIOT             SET MVCL TO-ADDRESS.
         L     R4,0(,RIOT)         SAVE GETMAIN TCB ADDRESS          R4
         L     R1,$SVPDDB1         CLEAR TO START OF 1ST PDDB        R4
         SLR   R3,R3               CAUSE CLEAR TO ZEROES.
         MVCL  R0,R2               CLEAR FIRST PART OF IOT.
         ST    R4,0(,RIOT)         RESTORE GETMAIN TCB ADDRESS       R4
         SPACE 3
*
*              SET FIELDS IN IOT
*
         SPACE 1
         MVC   IOTID,=CL4'IOT'     SET IOTID.
         LH    R15,$SVBFSIZ                SET                       R4
         LA    R15,IOTSTART-IOTDSECT(,R15)  IOT                      R4
         STH   R15,IOTLENG                   LENGTH.                 R4
         MVI   IOTFLAG1,IOT1CKPT   FLAG IOT FOR CHECKPOINT.
         MVC   IOTJBKEY,SJBJKEY    SET IOTJBKEY.
         MVC   IOTTRACK,24(R13)    SET IOTTRACK.
* CHAINING POINTERS IOTIOTTR AND IOTIOT WILL BE SET DURING
* CHAINING IN SUBROUTINE HALCHIOT
         ST    RSJB,IOTSJB         SET IOTSJB.
         L     R0,$SVPDDB1         SET OFFSET TO 1ST PDDB IN         R4
         ST    R0,IOTPDDBP             IOTPDDBP.
         SPACE 3
*
*              FURTHER SET IOTFLAG1
*
         SPACE 1
         USING SSALBGN,RSOX        SET SSAL ADDRESSABILITY.
         TM    SSALFLG1,SSALHOLD+SSALTRKM+SSALSPIN  IF SPECIAL,
         BNZ   HALCRI20            GO CHANGE FLAGS.
         CALL  HALCLASS            IF NOT SCATHOLD,
         BZ    HALCRI90            LEAVE FLAGS ALONE.
HALCRI20 DS    0H
         TM    SJBFLG1,SJB1XBM     IF BATCH MONITOR,           @OZ28238
         BO    HALCRI90            TREAT AS NON-SPIN/HOLD      @OZ28238
         OI    IOTFLAG1,IOT1SPIN   INDICATE SPIN IOT.
         TM    SSALFLG1,SSALTRKM   IF NEW TRACK MAP NEEDED,
         BZ    HALCRI90            THEN
         OI    IOTFLAG1,IOT1ALOC   SET IOT1ALOC.
         SPACE 3
*
*              RETURN TO CALLER
*
         SPACE 1
HALCRI90 DS    0H
         OI    IOTMSTAB+(TABFLAG-TABDSECT),TABMASTR SETUP MSTR TAB   R4
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN.
         DROP  RIOT,RSOX           DROP IOT, SSAL BASES.
         TITLE 'HALCHIOT -- SUBROUTINE TO CHAIN AN IOT'
*
*
*              HALCHIOT -- SUBROUTINE TO CHAIN AN IOT
*
*
         SPACE 1
HALCHIOT DS    0H
         USING *,R12               SET LOCAL ADDRESSABILITY.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET LOCAL BASE.
         SPACE 3
*
*              DECIDE WHICH TYPE OF CHAINING TO DO
*
         SPACE 1
         L     R7,SJBJCT           POINT TO HASP JCT.
         USING JCTDSECT,R7         SET JCT ADDRESSABILITY.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         TM    IOTFLAG1,IOT1SPIN   IF SPIN IOT,
         BO    HALCHI50            GO CHAIN IT.
         SPACE 3
*
*              CHAIN REGULAR IOT FIFO
*
         SPACE 1
         L     R1,SJBIOT           POINT TO THE 1ST IOT.
HALCHI10 DS    0H
         LR    R2,R1               SAVE PREVIOUS IOT POINTER.
         L     R1,IOTIOT-IOTDSECT(,R1)  POINT TO NEXT IOT.
         LTR   R1,R1               IF IT EXISTS,
         BNZ   HALCHI10            LOOP TILL END OF CHAIN.
         SLR   R0,R0               ZERO OUT
         ST    R0,IOTIOT           IOTIOT
         ST    R0,IOTIOTTR         AND IOTIOTTR.
         MVC   IOTIOTTR-IOTDSECT(,R2),IOTTRACK  CHAIN AUX STOR.
         ST    RIOT,IOTIOT-IOTDSECT(,R2)  CHAIN MAIN STORAGE.
         OI    IOTFLAG1-IOTDSECT(R2),IOT1CKPT  CKPT PREV IOT.
         B     HALCHI90            RETURN.
         SPACE 3
*
*              CHAIN SPIN IOT LIFO
*
         SPACE 1
HALCHI50 DS    0H
         MVC   IOTIOT,SJBSPIOT     POINT THIS IOT TO NEXT.
         ST    RIOT,SJBSPIOT       POINT HEADER TO THIS.
         MVC   IOTIOTTR,JCTSPIOT   DO THE SAME FOR
         MVC   JCTSPIOT,IOTTRACK   AUXILIARY STORAGE CHAIN.
         OI    JCTFLAG1,JCT1CKPT   REQUIRE JCT CHECKPOINT.
         SPACE 3
*
*              RETURN TO CALLER
*
         SPACE 1
HALCHI90 DS    0H
         OI    IOTFLAG1,IOT1CKPT   REQUIRE IOT CHECKPOINT.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN.
         DROP RIOT,R7              DROP IOT, JCT BASES.
         TITLE 'HALCRPDB -- SUBROUTINE TO CREATE A PDDB'
HALCRPDB DS    0H
*
*
*              CREATE PERIPHERAL DATASET DEFINITION BLOCK (PDDB)
*
*
         USING *,R12               SET LOCAL ADDRESSABILITY.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET LOCAL BASE.
* SEE IF THERE'S ENOUGH SPACE IN THE IOT TO HOLD A PDDB
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         L     R6,IOTPDDBP         GET OFFSET PAST LAST PDDB.
         LA    R15,PDBLENG(,R6)    IF NO ROOM                        R4
         CH    R15,IOTLENG         FOR MAX PDDB,                     R4
         BH    HCP800              RETURN CC=2 TO GET IOT.
* MOVE MAXIMUM-LENGTH PDDB BUT DON'T SET IOTPDDBP YET.
         ALR   R6,RIOT             COMPUTE ABSOLUTE PDDB ADDRESS.
         MVC   0(PDBLENG,R6),HALPDDB  MOVE MODEL PDDB.
* IF SSOB EXTENSION EXISTS, VERIFY USER ID
         USING SSALBGN,RSOX        SET SSOB EXT ADDRESSABILITY.
         L     R1,SJBJCT           POINT TO JCT                      R4
         SLR   R2,R2               SET DEFAULT                       R4
         IC    R2,JCTROUTE-JCTDSECT(R1) GET DEFAULT FIRST BYTE       R4
         L     R1,SSALDEST         GET DESTINATION POINTER.
* FOLLOWING CALL DESTROYS R0,R1,R2,R3,R14,R15
         CALL  USERDEST            VALIDIFY AND COMPRESS DEST.
         B     HCP810              +0 - INVALID DESTINATION
*                                  +4 - R2 CONTAINS DESTINATION
HCP100   DS    0H
*              THIS LINE DELETED BY APAR NUMBER                @OZ47891
*              THIS LINE DELETED BY APAR NUMBER                @OZ47891
*              THIS LINE DELETED BY APAR NUMBER                @OZ47891
         USING PDBDSECT,R6         SET NEW PDDB ADDRESSABILITY.
         SPACE 1                                               @OZ39639
* SET INDICATION IF JESNEWS DATA SET                           @OZ39639
         TM    IOTFLAG1,IOT1NEWS   IF JESNEWS DATA SET...      @OZ39639
         BZ    *+8                  SET FLAG AND FORCE TRACK-  @OZ39639
         OI    PDBFLAG2,PDB2NEWS+PDB2TCEL  CELL SPOOLING       @OZ39639
         SPACE 1                                               @OZ39639
*
*              SET PDDB FROM SSOB EXTENSION
*
* SET FORMS IDENTIFIER UNLESS ARGUMENT IS ZERO
         L     R1,SSALFORM         GET POINTER TO FORMS ID.
         MVC   PDBSSOFM,0(R1)      SAVE FOR CHANGE AT UNALLOC  @OZ47891
         L     R1,0(,R1)           GET FORMS ID.
         CL    R1,=CL4' '          IF BLANK FORMS,
         BE    *+8                 DON'T USE IT.
         ST    R1,PDBFORMS         ELSE STORE IT IN PDBFORMS.
* SET FORMS CONTROL BUFFER IDENTIFIER UNLESS ZERO
         L     R7,SSALJFCB         POINT TO JFCB.
         USING INFMJFCB,R7         SET JFCB ADDRESSABILITY.
         L     R1,JFCFCBID         GET FORMS CONTROL BUFFER ID.
         LTR   R1,R1               IF ZERO,
         BZ    *+14                DON'T USE IT.
         ST    R1,PDBFCB           ELSE STORE IT IN PDBFCB.
         OC    PDBFCB,=X'40404040' SET BINARY ZEROES TO BLANKS.
* SET UNIVERSAL CHARACTER SET IDENTIFIER UNLESS ZERO
         L     R1,JFCUCSID         GET UNIV CHAR SET ID.
         LTR   R1,R1               IF ZERO,
         BZ    *+14                DON'T USE IT.
         ST    R1,PDBUCS           ELSE STORE IT IN PDBUCS.
         OC    PDBUCS,=X'40404040' SET BINARY ZEROES TO BLANKS.
* SET 3525 FUNCTION BYTE IRREGARDFUL
         MVC   PDBFUNC,JFCFUNC     SET PDBFUNC.
* SET DESTINATION, COMPUTED EARLIER, NOW IN R2
         STH   R2,PDBDEST          SET DESTINATION.
* SET COPY COUNT UNLESS ZERO
         L     R1,SSALCOPY         POINT TO COPIES= PARM.
         CLI   0(R1),0             TEST COPY COUNT.
         BE    *+10                BR IF NONE PROVIDED.
         MVC   PDBCOPYS,0(R1)      ELSE SET COPIES.
* CHECK FOR DSID APPENDED TO DSNAME                            @Y30O
         LA    R1,DSNDSID+L'DSNDSID  POINT TO DSID EXTENSION         R4
         CLI   0(R1),C'.'          WAS DSID APPENDED...              R4
         BNE   HCP200              BR IF NO TO TEST FOR WTRID        R4
* MOVE DSID TO PDDB                                            @Y30O
         MVC   PDBDSID,1(R1)       MOVE DSID(+ BLANKS) TO PDDB @Y30O
         MVI   0(R1),C' '          CLEAR DSID EXTENSION INDICATOR    R4
         MVC   1(8,R1),0(R1)       BLANK OUT DSID IN DSNAME    @Y30O
         OC    PDBDSID,0(R1)       ENSURE DSID PADDED WITH BLANKS    R4
* FLAG PDDB FOR SPECIAL HANDLING                               @Y30O
         OI    PDBFLAG1,PDB1DSID+PDB1HOLD+PDB1PSO DSID/HOLD/PSO@Y30O
         B     HCP300              BYPASS WTRID TEST           @Y30O
* SET USER WRITER IDENTIFIER (WHETHER OR NOT ZERO)                   R4
HCP200   DS    0H                                                    R4
         L     R1,SSALPGMN         POINT TO USER WRITER NAME.
         MVC   PDBWTRID,0(R1)      MOVE IT TO PDBWTRID.
         EJECT                                                       R4
HCP300   DS    0H
         TM    JFCOPTCD,JFCOPTJ    TEST FOR 3800 OPTCD=J            R41
         BZ    HCPBURST            BR IF NO                         R41
         OI    PDBFLAG2,PDB2OPTJ   ELSE, SET FLAG IN PDDB            R4
HCPBURST L     R1,SJBJCT           POINT TO JCT -- TEST JOB'S       R41
         TM    JCTFLAG1-JCTDSECT(R1),JCTBURST  BURST DEFAULT...     R41
         BZ    *+8                 BR IF BURST=N                    R41
         OI    PDBFLAG2,PDB2BRST    ELSE SET BURST=Y IN PDDB        R41
         TM    JFCUCSOP,JFCBEXTP   TEST FOR 3800 EXTENSION          R41
         BNO   HCP310              BR IF NOT - END MERGE             R4
         SPACE 1                                                     R4
         L     R7,JFCBEXAD-1       ESTABLISH JFCB                    R4
         USING JFCBE-16,R7          EXTENSION ADDRESSABILITY         R4
         SPACE 1                                                     R4
* SET 3800 BURSTER SPECIFICATION                                     R4
         TM    JFCBFLAG,JFCBBST+JFCBCFS INDICATE IF B=Y OR N   @OZ55601
         BZ    SKIP120                   IS SPECIFIED ON       @OZ55601
         OI    PDBFLAG3,PDB3BRST          DD STATEMENT         @OZ55601
         TM    JFCBFLAG,JFCBBST    TEST FOR BURST=YES ON DD          R4
         BNO   *+8                 BR IF NOT                        R41
         OI    PDBFLAG2,PDB2BRST   ELSE, SET BURST=YES IN PDDB       R4
         TM    JFCBFLAG,JFCBCFS    TEST FOR BURST=N ON DD           R41
         BZ    *+8                 BR IF NOT                        R41
         NI    PDBFLAG2,255-PDB2BRST ELSE SET BURST=N IN PDDB       R41
* SET 3800 COPY MODIFICATION IMAGE ID AND TABLE REF CHAR             R4
SKIP120  L     R1,JFCMODIF         GET MODIFY PARAMETER              R4
         CL    R1,=X'40404040'     SET CHARS FROM JFCMODIF TO  @OZ34625
         BE    HCPFLSH             PDBMODF IF SPECIFIED        @OZ34625
         LTR   R1,R1               TEST FOR NOT SPECIFIED            R4
         BZ    HCPFLSH             BRANCH IF NOT SPECIFIED     @OZ34625
         ST    R1,PDBMODF          ELSE, SET PDBMODF                 R4
         OC    PDBMODF,=X'40404040' CONVERT BINARY ZEROS TO BLANKS   R4
         MVC   PDBMODFT,JFCIDTRC   SET PDBMODFT                      R4
* SET 3800 FLASH FRAME ID AND FLASH COUNT                            R4
HCPFLSH  DS    0H                                                    R4
         L     R1,JFCBMAGT         GET FLASH PARAMETER               R4
         CL    R1,=X'40404040'     CHARS FROM                  @OZ36611
         BE    HCPCHARS            JFCB TO                     @OZ36611
         LTR   R1,R1               TEST FOR FLASH SPECIFIED          R4
         BZ    HCPCHARS            BR IF NOT SPECIFIED         @OZ36611
         ST    R1,PDBFLASH         ELSE, SET PDBFLASH                R4
         OC    PDBFLASH,=X'40404040' CONVERT BINARY ZEROS TO BLANKS  R4
         ICM   R1,1,JFCIMTOT       SET FLASH                        R41
         BZ    HCPCHARS             COUNT IF                        R41
         STC   R1,PDBFLSHC           SPECIFIED                      R41
* SET 3800 CHAR1, CHAR2, CHAR3, CHAR4                                R4
HCPCHARS DS    0H                                                    R4
         L     R1,JFCBTRS1         SET                               R4
         CL    R1,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP130              JFCB TO                    @OZ30543
         LTR   R1,R1                PDBCHAR1                         R4
         BZ    SKIP130               IF                        @OZ30543
         ST    R1,PDBCHAR1            SPECIFIED                      R4
         OC    PDBCHAR1,=X'40404040'   AND CNVRT ZEROS TO BLANKS     R4
SKIP130  L     R1,JFCBTRS2         SET                               R4
         CL    R1,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP140              JFCB TO                    @OZ30543
         LTR   R1,R1                PDBCHAR2                         R4
         BZ    SKIP140               IF                        @OZ30543
         ST    R1,PDBCHAR2            SPECIFIED                      R4
         OC    PDBCHAR2,=X'40404040'   AND CNVRT ZEROS TO BLANKS     R4
SKIP140  L     R1,JFCBTRS3         SET                               R4
         CL    R1,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP150              JFCB TO                    @OZ30543
         LTR   R1,R1                PDBCHAR3                         R4
         BZ    SKIP150               IF                        @OZ30543
         ST    R1,PDBCHAR3            SPECIFIED                      R4
         OC    PDBCHAR3,=X'40404040'   AND CNVRT ZEROS TO BLANKS     R4
SKIP150  L     R1,JFCBTRS4         SET                               R4
         CL    R1,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP160              JFCB TO                    @OZ30543
         LTR   R1,R1                PDBCHAR4                         R4
         BZ    SKIP160               IF                        @OZ30543
         ST    R1,PDBCHAR4            SPECIFIED                      R4
         OC    PDBCHAR4,=X'40404040'   AND CNVRT ZEROS TO BLANKS     R4
* SET 3800 COPY GROUPS                                               R4
SKIP160  MVC   PDBCOPYG,JFCGROUP   SET PDBCOPYG                      R4
* END OF JFCB-TO-PDDB MERGE                                          R4
         EJECT                                                       R4
HCP310   DS    0H                                                    R4
* END OF PDDB SETUP FROM SSOB EXTENSION AND JFCB
         SPACE 1                                                    R41
         L     R7,SSALJFCB         RESTORE JFCB                     R41
         USING INFMJFCB,R7          ADDRESSABILITY                  R41
         SPACE 3
*
*              SEARCH FOR OUTPUT CTRL RECORD TO MATCH PDBFORMS
*
         SLR   R3,R3               ASSUME NO OCR               @OZ27530
         TM    PDBFLAG2,PDB2NEWS   JESNEWS DATA SET...         @OZ39639
         BO    HCP495              BR TO IGNORE OCR IF YES     @OZ39639
         ICM   R0,15,PDBFORMS      GET FORMS NUMBER FROM PDDB.
         BZ    HCP495              BR IF NONE PROVIDED         @OZ27530
* SET UP TO CHAIN OUTPUT CONTROL TABLES
         LA    R3,SJBOCT           POINT TO OCT POINTER,
         SL    R3,=A(OCTOCT-OCTDSECT)  SUBTRACT CHAIN OFFSET.
         USING OCTDSECT,R3         SET OCT ADDRESSABILITY.
* POINT TO THE NEXT OUTPUT CONTROL TABLE
HCP320   DS    0H
         L     R3,OCTOCT           POINT TO NEXT OCT.
         LTR   R3,R3               IF NO MORE, SEARCH FAILED -
         BZ    HCP495              SKIP OCR PROCESSING              R41
* SET UP TO SEARCH OUTPUT CONTROL RECORDS
         L     R1,OCTOCROF         GET OFFSET TO LAST OCR.
         ALR   R1,R3               MAKE IT ABSOLUTE.
         LA    R2,OCTOCR           POINT TO FIRST OCR.
* CHECK NEXT OCR IF IT EXISTS
HCP340   DS    0H
         CLR   R2,R1               ARE THERE MORE OCRS...
         BNL   HCP320              IF NOT, GO TO NEXT OCT.
         USING OCRDSECT,R2         SET OCR ADDRESSABILITY.
         CL    R0,OCRCODE          DOES OCR CODE MATCH FORMS...
         BE    HCP400              YES.  THIS IS THE ONE.
         LA    R2,OCREND           NO.  POINT TO NEXT OCR AND
         B     HCP340              TEST IF IT IS ONE.
         SPACE 1
         DROP  R3                  DROP OCT ADDRESSABILITY.
         EJECT                                                       R4
* MATCHING OCR IS FOUND - MERGE STARTS HERE
HCP400   DS    0H
* MERGE OCRFORMS INTO PDBFORMS
*              THIS LINE DELETED BY APAR NUMBER                @OZ47891
         L     R0,OCRFORMS         GET OCR FORMS ID
         ST    R0,PDBFORMS         SET PDBFORMS
*              THIS LINE DELETED BY APAR NUMBER                @OZ47891
* MERGE OCRFCB INTO PDBFCB AND INTO JFCFCBID
         L     R1,OCRFCB           GET OCR FORMS CTRL BUFFER ID.
         LTR   R1,R1               IF NO OCR FCB,
         BZ    *+12                SKIP.
         ST    R1,PDBFCB           SET PDBFCB.
         ST    R1,JFCFCBID         SET JFCFCBID.
* MERGE OCRUCS INTO PDBUCS AND INTO JFCUCSID
         L     R1,OCRUCS           GET OCR UNIVERSAL CHAR SET ID.
         LTR   R1,R1               IF NO OCR UCS,
         BZ    *+12                SKIP.
         ST    R1,PDBUCS           SET PDBUCS.
         ST    R1,JFCUCSID         SET JFCUCSID.
* MERGE OCRRECNT INTO PDBRECCT
         L     R1,OCRRECNT         GET OCR RECORD COUNT FIELD.
         LTR   R1,R1               IF IT IS ZERO,
         BZ    *+8                 SKIP.
         ST    R1,PDBRECCT         SET PDBRECCT.
* MERGE OCRINDEX INTO PDBINDEX
         ICM   R1,8,OCRINDEX       GET OCR 3211 PRINT INDEX.
         BZ    *+8                 IF IT IS ZERO, SKIP.
         STCM  R1,8,PDBINDEX       SET PDBINDEX.
* MERGE OCRCPTN INTO PDBCPTN                                        R41
         MVC   PDBCPTN(1),OCRCPTN  SET PDBCPTN                      R41
* MERGE OCRCKPTP AND OCRCKPTL INTO PDBCKPTP AND PDBCKPTL       @OZ19494
         MVC   PDBCKPTP,OCRCKPTP   SET LOGICAL PAGE/CKPT SIZE  @OZ19494
         MVC   PDBCKPTL,OCRCKPTL   SET LINES/LOGICAL PAGE SIZE @OZ19494
* MERGE OCRDEST1 INTO PDBDEST
         LH    R1,OCRDEST1         GET FIRST OCR DESTINATION.
         LTR   R1,R1               IF IT'S DEFAULT,                  R4
         BE    HCP480              BRANCH.
         STH   R1,PDBDEST          SET PDBDEST.
         L     R1,SSALDEST         AND CLEAR DEST FIELD        @OZ47891
         MVC   0(8,R1),=CL8' '      POINTED TO BY SSOB.        @OZ47891
         LH    R1,OCRDEST2         PICK UP 2D OCR DESTINATION.
         LTR   R1,R1               IF IT'S DEFAULT,                  R4
         BE    HCP480              ONLY ONE DESTINATION.
         OI    PDBFLAG1,PDB1MDES   ELSE SET FLAG PDB1MDES.
         L     R1,SJBJCT           POINT TO THE JCT
         USING JCTDSECT,R1         AND GET ADDRESSABILITY.
         MVC   JCTWORK(8),OCRDEST1 MOVE 4 DESTS TO JCTWORK.
         MVC   JCTWORK+8(2),=X'0000' MOVE TERMINATOR.                R4
         DROP  R1                  DROP JCT ADDRESSABILITY.
HCP480   DS    0H
* MERGE OCRCOPY INTO PDBCOPYS
         ICM   R1,8,OCRCOPY        GET OCR COPY COUNTER.
         BZ    *+8                 IF IT IS ZERO, SKIP.
         STCM  R1,8,PDBCOPYS       SET PDBCOPYS.
         EJECT                                                       R4
*                                                                    R4
*        MERGE 3800 OCR FIELDS WITH PDDB                             R4
*                                                                    R4
* MERGE OCRFLAGS(BURST) INTO PDBFLAG2                                R4
         TM    OCRFLAGS,OCRBRSTY   TEST FOR BURST=YES IN OCR         R4
         BZ    SKIP170             BR IF NOT                         R4
         OI    PDBFLAG2,PDB2BRST   SET PDBFLAG2(PDB2BRST)            R4
SKIP170  TM    OCRFLAGS,OCRBRSTN   TEST FOR BURST=NO IN OCR          R4
         BZ    SKIP180             BR IF NOT                         R4
         NI    PDBFLAG2,255-PDB2BRST  RESET PDBFLAG2(PDB2BRST)       R4
* MERGE OCRMODF/OCRMODFT INTO PDBMODF/PDBMODFT                       R4
SKIP180  L     R1,OCRMODF          GET OCR MODIFY IMAGE ID           R4
         LTR   R1,R1               TEST FOR SPECIFIED                R4
         BZ    HCP490              BR IF NOT                         R4
         ST    R1,PDBMODF          SET PDBMODF                       R4
         ICM   R1,1,OCRMODFT       GET OCR COPY MOD TRC              R4
         BZ    HCP490              BR IF NOT SPECIFIED               R4
         STC   R1,PDBMODFT         SET PDBMODFT                      R4
HCP490   DS    0H                                                    R4
* MERGE OCRFLASH/OCRFLSHC INTO PDBFLASH/PDBFLSHC                     R4
         L     R1,OCRFLASH         GET OCR FLASH FRAME ID            R4
         LTR   R1,R1               TEST FOR SPECIFIED                R4
         BZ    HCP492              BR IF NOT                         R4
         ST    R1,PDBFLASH         SET PDBFLASH                      R4
         ICM   R1,1,OCRFLSHC       GET OCR FLASH COUNT               R4
         BZ    HCP492              BR IF NOT SPECIFIED               R4
         STC   R1,PDBFLSHC         SET PDBFLSHC                      R4
HCP492   DS    0H                                                    R4
* MERGE OCRCHAR1-4 INTO PDBCHAR1-4                                   R4
         L     R1,OCRCHAR1         GET OCR CHAR1                     R4
         LTR   R1,R1               TEST FOR SPECIFIED                R4
         BZ    HCP494              BR IF NOT                         R4
         ST    R1,PDBCHAR1         SET PDBCHAR1                      R4
         L     R1,OCRCHAR2         GET OCR CHAR2                     R4
         LTR   R1,R1               TEST FOR SPECIFIED                R4
         BZ    HCP494              BR IF NOT                         R4
         ST    R1,PDBCHAR2         SET PDBCHAR2                      R4
         L     R1,OCRCHAR3         GET OCR CHAR3                     R4
         LTR   R1,R1               TEST FOR SPECIFIED                R4
         BZ    HCP494              BR IF NOT                         R4
         ST    R1,PDBCHAR3         SET PDBCHAR3                      R4
         L     R1,OCRCHAR4         GET OCR CHAR4                     R4
         LTR   R1,R1               TEST FOR SPECIFIED                R4
         BZ    HCP494              BR IF NOT                         R4
         ST    R1,PDBCHAR4         SET PDBCHAR4                      R4
HCP494   DS    0H                                                    R4
* MERGE OCRCOPYG INTO PDBCOPYG                                       R4
         CLI   OCRCOPYG,0          TEST FOR SPECIFIED                R4
         BZ    HCP495              BR IF NOT                         R4
         MVC   PDBCOPYG,OCRCOPYG   SET PDBCOPYG                      R4
         EJECT                                                       R4
*                                                                    R4
*        IF JFCB EXTENSION EXISTS - MERGE-BACK PDDB TO JFCB          R4
*                                                                    R4
         SPACE 1                                                     R4
HCP495   TM    JFCUCSOP,JFCBEXTP   TEST FOR 3800 EXTENSION          R41
         BZ    HCP500              BR IF NOT - END MERGE             R4
         L     R7,JFCBEXAD-1       ESTABLISH JFCB                    R4
         USING JFCBE-16,R7          EXTENSION ADDRESSABILITY         R4
         SPACE 1                                                     R4
* MERGE PDBFLAG (BURST) INTO JFCBFLAG                                R4
         TM    PDBFLAG2,PDB2BRST   TEST FOR BURST=YES                R4
         BZ    HCP496              BR IF NO                          R4
         OI    JFCBFLAG,JFCBBST    INDICATE BURST=YES                R4
         NI    JFCBFLAG,255-JFCBCFS  IN JFCB                         R4
         B     HCP497                AND BR TO CONTINUE             R41
HCP496   OI    JFCBFLAG,JFCBCFS    INDICATE BURST=NO                 R4
         NI    JFCBFLAG,255-JFCBBST  IN JFCB                         R4
* MERGE PDBFLSHC INTO JFCIMTOT                                 @OZ53399
HCP497   MVC   JFCIMTOT,PDBFLSHC   MOVE FLASH COUNT            @OZ53399
         LTR   R3,R3               TEST FOR OCR PRESENT        @OZ53399
         BZ    HCP500              END MERGE IF NOT                 R41
* MERGE PDBMODF/PDBMODFT INTO JFCMODIF/JFCIDTRC                      R4
HCP498   CLC   PDBMODF,=C'****'    WAS MODIFY SPECIFIED...           R4
         BE    SKIP200             BR IF NOT                         R4
         MVC   JFCMODIF,PDBMODF    MOVE COPY MOD ID                  R4
         MVC   JFCIDTRC,PDBMODFT   MOVE COPY MOD TRC                 R4
* MERGE PDBFLASH INTO JFCBMAGT                                 @OZ53399
SKIP200  CLC   PDBFLASH,=C'****'   TEST FOR FLASH SPECIFIED          R4
         BE    SKIP210             BR IF NOT                         R4
         MVC   JFCBMAGT,PDBFLASH   MOVE FLASH FRAME ID               R4
*              THIS LINE DELETED BY APAR NUMBER                @OZ53399
* MERGE PDBCHAR1-4 INTO JFCBTRS1-4                                   R4
SKIP210  CLC   PDBCHAR1,=C'****'   MERGE CHAR1                       R4
         BE    SKIP220              IF                               R4
         MVC   JFCBTRS1,PDBCHAR1     SPECIFIED                       R4
SKIP220  CLC   PDBCHAR2,=C'****'   MERGE CHAR2                       R4
         BE    SKIP230              IF                               R4
         MVC   JFCBTRS2,PDBCHAR2     SPECIFIED                       R4
SKIP230  CLC   PDBCHAR3,=C'****'   MERGE CHAR3                       R4
         BE    SKIP240              IF                               R4
         MVC   JFCBTRS3,PDBCHAR3     SPECIFIED                       R4
SKIP240  CLC   PDBCHAR4,=C'****'   MERGE CHAR4                       R4
         BE    SKIP250              IF                               R4
         MVC   JFCBTRS4,PDBCHAR4     SPECIFIED                       R4
* MERGE PDBCOPYG INTO JFCGROUP                                       R4
SKIP250  CLI   PDBCOPYG,0          TEST FOR SPECIFIED                R4
         BE    HCP500              BR IF NOT                         R4
         MVC   JFCGROUP,PDBCOPYG   MOVE IN COPY GROUPS               R4
         SPACE 1                                                     R4
         DROP  R7                  SUSPEND JFCBE ADDRESSABILITY      R4
         SPACE 2                                                     R4
HCP500   DS    0H                                                    R4
         EJECT                                                       R4
         SPACE 3
*
*
*              SET CLASS, DATA SET KEY, FLAGS
*
*
         CALL  HALCLASS            GET CLASS, SCATHOLD STATUS.
         STC   R2,PDBCLASS         SET CLASS INTO PDDB.
         BZ    *+16                IF NOT SCATHOLD, SKIP.
         TM    SJBFLG1,SJB1XBM     IF BATCH MONITOR JOB,
         BO    *+8                 SKIP.
         OI    PDBFLAG1,PDB1HOLD   SET HOLD FLAG IN PDDB.
         TM    SCATFLAG-SCADSECT(R1),SCATDUMM  Q. DUMMY CLASS
         BZ    *+8                             BR. IF NO
         OI    PDBFLAG1,PDB1NSOT               MARK AS DUMMY
         TM    SCATFLAG-SCADSECT(R1),SCATTCEL TRAKCELL SYSOUT CLASS  R4
         BZ    SKIP260             NO                                R4
         OI    PDBFLAG2,PDB2TCEL   YES - SHOW TRAKCELL DATA SET      R4
SKIP260  CVB   R1,SJBDBLWK         CONVERT DS NUMBER TO
         STH   R1,PDBDSKEY         BINARY AND SET KEY.
         TM    SSALFLG1,SSALTRKM   IF ALLOC SPECIFIED
         BZ    *+8                 INDIVIDUAL TRACK GROUP MAP,
         OI    PDBFLAG1,PDB1SPIN   SET FLAG PDB1SPIN.
         TM    SSALFLG1,SSALHOLD   IF ALLOC SPECIFIED
         BZ    *+12                HOLD-AT-UNALLOCATION        @OZ29148
         OI    PDBFLAG1,PDB1HOLD   SET PDB1HOLD.
         OI    PDBFLAG2,PDB2HLDS   ALSO SPECIFIC HOLD          @OZ29148
         TM    PDBFLAG1,PDB1SPIN+PDB1HOLD  IF EITHER FLAG
         BZ    *+8                 WAS SET,
         OI    PDBFLAG1,PDB1PSO    SET PDB1PSO.
         L     R7,SJBJCT           GET JCT ADDRESS FROM SJB.
         USING JCTDSECT,R7         PROVIDE JCT ADDRESSABILITY.
         TM    JCTJOBFL,JCTNOUPT   TEST 'NO OUTPUT' OPTION.
         BZ    *+8                 BR IF NO.
         OI    PDBFLAG1,PDB1NSOT   ELSE DON'T LET DATASET PRINT.
         ICM   R1,15,PDBFORMS      GET FINAL FORMS NUMBER.
         BNZ   HCP600              BR IF 'VALID'.
         MVC   PDBFORMS,JCTFORMS   ELSE USE JOB FORMS.
         OI    PDBFLAG2,PDB2JFMS   SHOW PDBFORMS SET BY JCTFORMS    R41
         L     R1,SSALFORM         GET FORMS ID ADDRESS             R41
         MVC   0(4,R1),JCTFORMS    UPDATE FORMS ID FIELD            R41
HCP600   DS    0H
         SPACE 3
*
*
*              UPDATE IOTPDDBP AND RETURN.
*
*
         LA    R0,PDBLENG          GET PDDB LENGTH.
         AL    R0,IOTPDDBP         ADD OLD IOTPDDBP.
         ST    R0,IOTPDDBP         SET NEW IOTPDDBP.
         ST    R6,44(,R13)         SAVE PDDB ADR IN SAVEAREA.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         SR    R15,R15             SET CC=0.
         BR    R14                 RETURN TO CALLER.
         EJECT
*
*
*              NO SPACE - RETURN CC=2 TO GET ANOTHER IOT
*
*
HCP800   DS    0H
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         SLR   R15,R15             SET CC=2.
         BR    R14                 RETURN TO CALLER.
         SPACE 1                                                     R4
*
*
*              INVALID DESTINATION - RETURN CC = 1
*
*
HCP810   DS    0H
         CLI   *,X'FF'             SET CC = 1  (MASK OF 4)           R4
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN TO CALLER.
         EJECT                                                 @OZ19494
*
*
*        DEFAULT FULL-LENGTH PERIPHERAL DATASET DEFINITION BLOCK
*
*
         DS    0F                  FORCE HALPDDB TO FULLWORD.
HALPDDB  DS    0CL(PDBLENG)        MODEL PDDB.
         DC    AL1(PDB1NULL)       FLAG BYTE
         DC    AL1(0)              RECORD FORMAT
         DC    H'0'                MAXIMUM LOGICAL RECORD LENGTH
         DC    F'0'                STARTING TRACK ADDRESS
         DC    H'0'                DATA SET KEY
         DC    C'A'                DEFAULT SYSOUT CLASS
         DC    AL1(1)              DEFAULT COPY COUNT
         DC    X'8000'             DESTINATION
         DC    AL1(0,0,0)          CPU ID, SECURITY, 3211 INDEX
         DC    AL1(JFCFNCBP)       3525 FUNCTION BYTE
         DC    AL1(0)              FLAG BYTE 2                       R4
         DC    X'FF'               DEFAULT COMPACTION TABLE NUMBER  R41
         DC    F'0'                RECORD COUNT
         DC    XL4'00'             FORMS NUMBER
         DC    C'****'             FCB ID
         DC    C'****'             UCS ID
         DC    CL8' '              USER WRITER NAME
         DC    XL8'00'             CHECKPOINT RBA
         DC    CL4'****'           TRANSLATE TABLE 1                 R4
         DC    CL4'****'           TRANSLATE TABLE 2                 R4
         DC    CL4'****'           TRANSLATE TABLE 3                 R4
         DC    CL4'****'           TRANSLATE TABLE 4                 R4
         DC    CL4'****'           FLASH ID                          R4
         DC    CL4'****'           MODIFY ID                         R4
         DC    AL1(255)            FLASH COUNT                      R41
         DC    AL1(0)              TABLE REFERENCE CHARACTER         R4
         DC    AL1(0,0,0,0,0,0,0,0)     COPY GROUPS                  R4
         DC    X'FFFF'             LOGICAL PAGES/CHECKPOINT    @OZ19494
         DC    X'FFFF'             LINES/LOGICAL PAGE          @OZ19494
         DC    XL14'0'             RESERVED                    @OZ19494
         DS    0F                  FORCE TO FULLWORD BOUNDARY  @OZ19494
         EJECT                                                       R4
*
*              TEST SCATHOLD.  R10 POINTS TO SSAL.
*
HALCLASS DS    0H
         USING *,R15               SET LOCAL ADDRESSABILITY.
         L     R1,SJBJCT           POINT TO JOB'S HASP JCT.
         SLR   R2,R2               ZERO R2 FOR IC.
         IC    R2,JCTMCLAS-JCTDSECT(,R1)  GET MESSAGE CLASS.
         LA    R1,$SVSCAT(R2)      POINT TO ITS SCAT ENTRY.
         USING SCADSECT,R1         SET SCAT ADDRESSABILITY.
         TM    SCATFLAG,SCATHOLD   SET CC=0 IF HOLD DISALLOWED.
         BALR  R0,0                SAVE CONDITION CODE.
         L     R1,SSALCLAS         POINT TO DATA SET'S CLASS.
         CLI   0(R1),C'$'          IF CLASS IS $,
         BE    HALCLAS1            USE JCTMCLAS.
         CLI   0(R1),C' '          IF CLASS IS NULL                 R41
         BE    HALCLAS1            USE JCTMCLAS                     R41
         CLI   0(R1),C'*'          IF CLASS IS *,
         BE    HALCLAS1            USE JCTMCLAS.
         IC    R2,0(,R1)           ELSE USE GIVEN CLASS.
         B     HALCLAS2            CHECK FOR HOLD ALLOWED      @OZ45950
HALCLAS1 DS    0H
         CLI   SJBXQFN1+1,SSOBUNAL IF CALLED FROM UNALLOCATE   @OZ45950
         BNE   HALCLAS2             FOR PSO AND SSALCLAS IS    @OZ45950
         CLI   DSNDSTYP-JFCB(RJFC),C'P' BLANK OR ASTERISK,     @OZ45950
         BNE   HALCLAS2                USE DATA SETS           @OZ45950
         IC    R2,PDBCLASS-PDBDSECT(R4)  ORIGINAL CLASS        @OZ45950
HALCLAS2 DS    0H                                              @OZ45950
         SPM   R0                  RESTORE CONDITION CODE.
         LA    R1,$SVSCAT(R2)      POINT TO PROPER SCAT ENTRY.
         BZR   R14                 RETURN IF HOLD DISALLOWED.
         TM    SCATFLAG,SCATHOLD   SET CC ACC. TO SCATHOLD.
         BR    R14                 RETURN CONDITION CODE.
         DROP  ,                   DROP ALL ADDRESSABILITY.
         TITLE 'LITERAL POOL FOR ALLOCATE'                           R4
         LTORG                                                       R4
         TITLE 'HASP SUBSYSTEM SUPPORT ROUTINE -- UNALLOCATE'
*
*
*              HASP SUBSYSTEM SUPPORT ROUTINE -- UNALLOCATE
*
*
         SPACE 1
HOSUNAL  $PROLOG SSOBUNAL,SSALSIZE,LOCK=REQ
         LR    RSIB,RSOX           TRANSFER SSAL ADDRESS TO RSIB.
         USING SSALBGN,RSIB        SET SSAL ADDRESSABILITY.
         L     RJFC,SSALJFCB       POINT TO THE JFCB.
         USING INFMJFCB,RJFC       SET JFCB ADDRESSABILITY.
         L     RSDB,SSALSSCM       POINT TO THE SDB/DCT.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         SPACE 3
*
*              BRANCH ACCORDING TO DATA SET TYPE
*
         SPACE 1
         LH    R0,DSNDSTYP         LOAD DATA SET TYPE.
         CH    R0,=C'SI'           IF SYSIN,
         BE    HUAI                GO UNALLOCATE.
         CH    R0,=C'SO'           IF SYSOUT,
         BE    HUAO                GO UNALLOCATE.
         CH    R0,=C'PS'           IF PROCESS-SYSOUT,
         BE    HUAP                GO UNALLOCATE.
         B     HUA800              ERROR - UNRECOGNIZABLE TYPE.
         EJECT
*
*
*              SYSIN DATA SET UNALLOCATION                          R41
*
*
         SPACE 1
HUAI     DS    0H
         CALL  $SDBFREE            FREE THE SDB.
         B     HUA950              RETURN WITHOUT CHECKPOINT.
         SPACE 1                                                    R41
*                                                                   R41
*                                                                   R41
*              PROCESS-SYSOUT DATA SET UNALLOCATION                 R41
*                                                                   R41
*                                                                   R41
         SPACE 1                                                    R41
         USING PDBDSECT,R4         PROVIDE PDDB ADDRESSABILITY      R41
         SPACE 1                                                    R41
HUAP     CLC   SJBPSOP,=F'0'       PSO STILL PRESENT           @OZ50462
         BNE   HUAP1                YES, POINT TO PDDB         @OZ50462
         CALL  $SDBFREE            FREE SDB                    @OZ50462
         B     HUA950              NORMAL RETURN               @OZ50462
HUAP1    L     R4,SDBPDDB          PDDB IS IN PSO              @OZ50462
         TM    PDBFLAG1,PDB1HOLD   DATA SET ALREADY HELD...         R41
         BZ    HUAO50              BR IF NO (XWTR REQUEST)          R41
         NI    PDBFLAG1,255-PDB1HOLD  RESET HOLD BIT                R41
         B     HUAO20              BR TO UPDATE PDDB                R41
         EJECT
*
*
*              SYSOUT DATA SET UNALLOCATION
*
*
         SPACE 1
HUAO     DS    0H
         L     R1,SSALPGMN         POINT TO USER WRITER NAME.
         CLC   =CL8'INTRDR',0(R1)  IF IT'S INTERNAL READER,
         BE    HUAR                GO UNALLOCATE.
         LTR   RSDB,RSDB           IF NO SDB,
         BZ    HUA950              RETURN NORMALLY.
         CLC   =CL4'SDB',SDBID     IF BAD CONTROL BLOCK ID,
         BNE   HUA800              ERROR - CAN'T UNALLOCATE.
         SLR   R15,R15             SET ZERO RETURN CODE             R41
         TM    SJBFLG1,SJB1XBWT    BIT IF XBM ENDING,
         BO    HUA890              JUST FREE THE SDB                R41
         SPACE 1
*
*              POINT TO PDDB AND ITS IOT
*
         SPACE 1
         L     R1,SJBIOT           IF THERE IS NO
         LTR   R1,R1               PRIMARY ALLOCATION IOT,
         BZ    HUA800              ALLOCATION MAY FAIL.
         MVI   SJBDBLWK+4,0        SET MULT DEST NULL FLAG          R41
         L     RIOT,SDBPIOT        POINT TO PDDB'S IOT.
         L     R4,SDBPDDB          POINT TO PDDB.
         TM    PDBFLAG2,PDB2NEWS   JESNEWS UNALLOCATION...     @OZ39639
         BZ    HUAO10              BR IF NO                    @OZ39639
         OI    SSALFLG1,SSALSPIN    ELSE FORCE SPIN            @OZ39639
         SPACE 1                                               @OZ39639
HUAO10   MVC   PDBRECCT,SDBRECCT   MOVE RECORD COUNT TO PDDB   @OZ39639
         NI    PDBFLAG1,255-PDB1NSOT-PDB1HOLD-PDB1SPIN-PDB1PSO      R41
         SPACE 1                                                    R41
HUAO20   L     R1,SSALDEST         GET DESTINATION ADDRESS          R41
         CLC   =CL8' ',0(R1)       TEST DESTINATION                 R41
         BE    HUAO25              BR IF NOT SPECIFIED              R41
         L     R2,SJBJCT           GET JCT ADDRESS                  R41
         IC    R2,JCTROUTE-JCTDSECT(,R2)  GET DEFAULT DEST          R41
         CALL  USERDEST            VALIDATE USER DESTINATION        R41
         B     HUAO25              BR IF INVALID DESTINATION +0     R41
         STH   R2,PDBDEST          SET NEW DESTINATION       +4     R41
         SPACE 1                                                    R41
*              THIS LINE DELETED BY APAR NUMBER                @OZ45950
*              THIS LINE DELETED BY APAR NUMBER                @OZ45950
*              THIS LINE DELETED BY APAR NUMBER                @OZ45950
*              THIS LINE DELETED BY APAR NUMBER                @OZ45950
         EJECT                                                      R41
HUAO25   LR    RSDB,RSIB           RELOAD SSAL ADDRESS         @OZ45950
         CALL  HALCLASS            GET CLASS, HOLD STATUS           R41
         L     RSDB,SSALSSCM       RESTORE SDB ADDRESS              R41
         BZ    HUAO40              BR IF NON-HOLD CLASS             R41
         CLI   DSNDSTYP,C'P'       TEST FOR PSO REQUEST             R41
         BE    HUAO40              BR IF YES (IGNORE HOLD)          R41
         OI    PDBFLAG1,PDB1HOLD    ELSE SET HOLD FLAG              R41
         SPACE 1                                                    R41
HUAO40   STC   R2,PDBCLASS         SET SYSOUT CLASS                 R41
         TM    SSALFLG1,SSALNHLD   IS NOHOLD SPECIFIED...      @OZ63488
         BZ    *+8                 NO, BYPASS RESET            @OZ63488
         NI    PDBFLAG1,FF-PDB1HOLD  ELSE RESET HOLD FLAG      @OZ63488
         TM    SSALFLG1,SSALHOLD   TEST FOR EXPLICIT HOLD           R41
         BZ    *+8                 BR IF NO                         R41
         OI    PDBFLAG1,PDB1HOLD    ELSE SET HOLD FLAG              R41
         TM    SCATFLAG-SCADSECT(R1),SCATDUMM  DUMMY CLASS...       R41
         BZ    *+8                 BR IF NO                         R41
         OI    PDBFLAG1,PDB1NSOT    ELSE SET NO-PRINT FLAG          R41
         TM    PDBFLAG1,PDB1DSID   TEST FOR DSID                    R41
         BO    HUAO45              BR IF YES (IGNORE WTR ID)        R41
         L     R1,SSALPGMN         GET WTR ID ADDRESS               R41
         CLI   0(R1),C' '          WTR ID SPECIFIED...              R41
         BE    HUAO45              BR IF NO                         R41
         MVC   PDBWTRID,0(R1)      MOVE WTR ID TO PDDB              R41
         SPACE 1                                                    R41
HUAO45   L     R1,SSALFORM         GET FORMS ID ADDRESS             R41
         CLI   0(R1),C' '          FORMS ID SPECIFIED...            R41
         BE    HUAO50              BR IF NO                         R41
         CLC   PDBSSOFM,0(R1)      FORMS CHANGE AT UNALLOC...  @OZ47891
         BE    HUAO50              BRANCH IF NO                @OZ47891
         MVC   PDBFORMS,0(R1)      MOVE FORMS ID TO PDDB            R41
         SPACE 1                                                    R41
HUAO50   TM    SSALFLG1,SSALDELT   TEST FOR EXPLICIT DELETE         R41
         BZ    *+8                 BR IF NO                         R41
         OI    PDBFLAG1,PDB1NSOT    ELSE SET NO-PRINT FLAG          R41
         CLI   DSNDSTYP,C'P'       TEST FOR PSO REQUEST             R41
         BNE   HUAO60              BR IF NO (NORMAL UNALLOC)        R41
         CALL  $SDBFREE             ELSE FREE THE SDB               R41
         B     HUA950              RETURN WITHOUT CHECKPOINTING     R41
         EJECT                                                      R41
HUAO60   OI    IOTFLAG1,IOT1CKPT   FORCE IOT CHECKPOINT             R41
         NI    SJBDBLWK+4,PDB1NULL TEST MULT DEST NULL FLAG         R41
         BZ    *+8                 BR IF NON-NULL DATA SET          R41
         OI    PDBFLAG1,PDB1NULL    ELSE PROPAGATE NULL BIT         R41
         MVC   SJBDBLWK(4),IOTIOT  SAVE ADDRESS OF NEXT IOT         R41
         MVC   SJBDBLWK+4(1),PDBFLAG1  SAVE PDDB FLAG BYTE          R41
         L     R2,SJBJCT           GET JCT ADDRESS                  R41
         TM    JCTJOBFL-JCTDSECT(R2),JCTNOUPT  TEST FOR NO PRNT     R41
         BZ    *+8                 BR IF NO (PRINT ALLOWED)         R41
         OI    PDBFLAG1,PDB1NSOT    ELSE SET NO-PRINT FLAG          R41
         TM    PDBFLAG1,PDB1DSID   TEST FOR DSID                    R41
         BZ    *+8                 BR IF NO                         R41
         OI    PDBFLAG1,PDB1HOLD    ELSE SET HOLD FLAG              R41
         TM    SSALFLG1,SSALSPIN   TEST FOR SPIN REQUEST            R41
         BZ    HUAO63              BR IF NO                    @OZ29364
         SPACE 1                                               @OZ29364
*        UPDATE SMF INFORMATION BEFORE SPINNING                @OZ29364
         USING JCTDSECT,R2                                     @OZ29364
         L     R1,PSATOLD-PSA      FIND CURRENT TCB            @OZ29364
         ICM   R1,7,TCBTCTB-TCB(R1)    GET 24-BIT TCT ADDR.    @OZ29364
         BZ    HUAO62              BR IF NO SMF.               @OZ29364
         L     R1,TCTJMR-SMFTCT(,R1) GET JMR ADDRESS.          @OZ29364
         CLC   JCTUSEID,JCTUSEID-JCTJMR(R1) TEST USER SMF.     @OZ29364
         BNE   HUAO61              BR IF CHANGED.              @OZ29364
         CLC   JCTUCOM,JCTUCOM-JCTJMR(R1) TEST USER SMF COMM.  @OZ29364
         BE    HUAO62              BR IF ALL UNCHANGED         @OZ29364
HUAO61   MVC   JCTUSEID,JCTUSEID-JCTJMR(R1) XFER USER SMF      @OZ29364
         MVC   JCTUCOM,JCTUCOM-JCTJMR(R1) FROM JMR TO JCT.     @OZ29364
         OI    JCTFLAG1,JCT1CKPT   CAUSE JCT CHECKPOINT.       @OZ29364
HUAO62   OI    PDBFLAG1,PDB1SPIN   SET SPIN FLAG.              @OZ29364
HUAO63   DS    0H                  COMMON RETURN               @OZ29364
         DROP  R2                                              @OZ29364
         SPACE 1                                               @OZ29364
         TM    PDBFLAG1,PDB1HOLD+PDB1SPIN  TEST FOR HOLD/SPIN       R41
         BZ    *+8                 BR IF NO                         R41
         OI    PDBFLAG1,PDB1PSO     ELSE SET PSO FLAG               R41
         SPACE 1
*
*              CHECK IF SPIN IOT PRESENT OR REQUIRED
*
         SPACE 1
         TM    IOTFLAG1,IOT1SPIN   IS IOT ALREADY SPIN-TYPE...
         BO    HUAO200             BRANCH IF SO.
         TM    PDBFLAG1,PDB1PSO    SHOULD IOT BE SPIN-TYPE...
         BZ    HUAO280             BR IF NO (ALL FOR THIS PDDB)     R41
         EJECT
*
*              CREATE A SPIN IOT FOR UNALLOCATE
*
         SPACE 1
HUAO100  DS    0H
         CALL  HCBGM               GET STORAGE FOR IOT.
         BNZ   HUA800              ERROR - STORAGE UNAVAILABLE.
         LR    RIOT,R1             SET IOT BASE REGISTER.
         L     R1,SJBIOT           POINT TO ALLOCATION IOT.
         LA    R1,IOTMSTAB-IOTDSECT(,R1)     PT TO THE MASTER TAB    R4
         CALL  $STRAK              ALLOCATE A TRACK FOR IOT.
         L     R15,SJBIOT          GET ALLOCATION IOT ADDRESS  @OZ17477
         OI    IOTFLAG1-IOTDSECT(R15),IOT1CKPT FORCE IOT CHKPT @OZ17477
         LR    RSOX,RSIB           POINT RSOX TO THE SSAL.
         CALL  HALCRIOT            FORMAT THE IOT.
         OI    IOTFLAG1,IOT1SPIN   PUT ON CORRECT CHAIN        @OZ17491
         CALL  HALCHIOT            CHAIN IOT TO SJB, JCT.
         MVC   SJBSPIOT,IOTIOT     DECHAIN IT FROM SJB.
         L     R15,$SVPDDB1            MOVE PDDB                     R4
         LA    RSDB,0(RIOT,R15)         TO NEW                       R4
         MVC   0(PDBLENG,RSDB),PDBDSECT  SPIN IOT                    R4
         L     RSDB,SSALSSCM       RESTORE RSDB.
         OI    PDBFLAG1,PDB1NSOT   DELETE THE OLD PDDB.
         LA    R0,PDBLENG(,R15)    GET OFFSET OF NEXT PDDB           R4
         ST    R0,IOTPDDBP         AND STORE POINTER IN IOT.
         SPACE 1
*
*              WRITE THE IOT AND SPIN IT
*
         SPACE 1
         CALL  HIOTSPIN            SPIN/HOLD THE IOT.
         L     RIOT,SDBPIOT        POINT BACK TO ORIGINAL            R4
         L     R4,SDBPDDB            IOT AND PDDB                    R4
         B     HUAO280             GO CHECK FOR MULTI-DEST           R4
         EJECT
         CNOP  0,8
HUAO200  BAL   R14,HALDCIOT        DE-CHAIN IOT FROM SPIN IOT CHAIN
*  SPIN/HOLD THE IOT IF DATASET SPUN/HELD/DELETE/NOPRINT       @OZ29594
         TM    PDBFLAG1,PDB1SPIN+PDB1HOLD+PDB1NSOT SPIN NOW?   @OZ29594
         BZ    HUAO210             BR IF NOT                         R4
         CALL  HIOTSPIN            SPIN/HOLD THE IOT                 R4
         TM    SDBFLG2,SDB2LOG     IF SYSLOG DS SPIN FAILED,   @OZ58848
         BO    HUAO210             BR TO CONVERT TO REGULAR.   @OZ58848
         TM    SJBDBLWK+4,PDB1MDES IF MULTIPLE DESTINATIONS,         R4
         BO    HUAO285             CONSIDER THE NEXT IOT,            R4
         B     HUAO300             ELSE FREE THE SDB                 R4
         SPACE 1
*
*              SPIN/HOLD DATASET WAS NOT SPUN/HELD
*
         SPACE 1
HUAO210  L     R1,SJBIOT           GET ALLOCATION IOT ADDRESS        R4
         OI    IOTFLAG1-IOTDSECT(R1),IOT1CKPT  REQUEST IOT CHECKPOINT
         MVI   IOTFLAG1,0          RESET SPIN IOT FLAG
         L     R0,$SVMAPL          GET LENGTH OF TRACK GROUP MAP     R4
         LA    R1,IOTTGMAP-IOTDSECT+TGMAP-TGMDSECT(,R1)  MERGE       R4
        $VFL   OC,(R1),IOTTGMAP+TGMAP-TGMDSECT,(R0)       MAPS       R4
         LA    R0,IOTTGMAP+TGMAP-TGMDSECT  CLEAR                     R4
         L     R1,$SVMAPL                   OLD                      R4
         SLR   R15,R15                       TRACK GROUP             R4
         MVCL  R0,R14                         MAP                    R4
         NI    IOTFLAG1,255-IOT1CKPT-IOT1ALOC-IOT1NEWS  RESET  @OZ39639
         OI    PDBFLAG1,PDB1NSOT   NULLIFY PDDB ON SPIN CHAIN  @OZ26752
         L     R0,IOTTRACK         RE-WRITE
         LR    R1,RIOT              CLEANED-UP
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT WRITE IN SJB   @OZ78293
         CALL  HCBWR                 SPIN IOT
         NI    PDBFLAG1,255-PDB1NSOT PRINT ON REGULAR CHAIN    @OZ26752
         LR    R2,RIOT             SAVE PDDB'S IOT ADDRESS
         L     R1,SJBIOT           PREPARE TO FIND LAST REGULAR IOT
         SPACE 1
*
*              RETURN SPIN/HOLD DATASET TO FOLD
*
         SPACE 1
HUAO220  LR    RIOT,R1             RE-LOAD LAST VALID IOT ADDRESS
         L     R1,IOTIOT           GET ADDR OF NEXT OUTPUT IOT
         LTR   R1,R1               TEST FOR VALID IOT ADDRESS
         BNZ   HUAO220             BR IF SO
         SPACE 1
         L     R6,IOTPDDBP         GET OFFSET OF LAST PDDB IN IOT
         LA    R15,PDBLENG(,R6)    ROOM FOR                          R4
         CH    R15,IOTLENG         ANOTHER...                        R4
         BNH   HUAO240             BR IF SO
         EJECT
*
*              USE SPIN/HOLD IOT AS NEXT OUTPUT IOT
*
         SPACE 1
         L     R1,SJBIOT           GET ALLOCATION IOT ADDRESS
         LA    R1,IOTMSTAB-IOTDSECT(,R1)     GET NEW TRACK ADDRESS   R4
         CALL  $STRAK                      FOR NEW OUTPUT IOT
         L     R15,SJBIOT          GET ALLOCATION IOT ADDRESS  @OZ17477
         OI    IOTFLAG1-IOTDSECT(R15),IOT1CKPT FORCE IOT CHKPT @OZ17477
         ST    R1,IOTIOTTR         EXTEND OUTPUT IOT
         ST    R2,IOTIOT            ON SPOOL AND IN STORAGE
         OI    IOTFLAG1,IOT1CKPT   REQUEST IOT CHECKPOINT
         LR    RIOT,R2             RESTORE EX-SPIN IOT ADDRESS
         ST    R1,IOTTRACK         STORE NEW TRACK ADDRESS
         SLR   R0,R0               CLEAR NEW
         ST    R0,IOTIOTTR          OUTPUT IOT
         ST    R0,IOTIOT             CHAIN ADDRESSES
         OI    IOTFLAG1,IOT1CKPT   REQUEST IOT CHECKPOINT      @OZ26752
         B     HUAO280             END FOR THIS PDDB.
         SPACE 1
*
*              MOVE PDDB TO END OF LAST OUTPUT IOT
*
         SPACE 1
         CNOP  0,8
HUAO240  LA    R1,0(R6,RIOT)       MOVE PDDB TO END
         MVC   0(PDBLENG,R1),PDBDSECT  OF LAST OUTPUT IOT
         LR    R1,R2               FREE THE
         CALL  HCBFM                SPIN IOT BUFFER
         LA    R6,PDBLENG(,R6)     UPDATE OFFSET TO
         ST    R6,IOTPDDBP          NEXT PDDB IN IOT
         OI    IOTFLAG1,IOT1CKPT   CAUSE NORMAL IOT CHECKPOINT.
         B     HUAO285             END FOR THIS PDDB.
         EJECT
*
*
*              SELECT NEXT PDDB IF MULTIPLE DESTINATION
*
*
HUAO280  DS    0H
         TM    SJBDBLWK+4,PDB1MDES DID OLD PDDB SAY MDES...
         BZ    HUAO300             IF NOT, END UNALLOCATION.
         L     R1,IOTPDDBP         POINT TO LIMIT OF PDDBS
         ALR   R1,RIOT             IN THIS IOT.
         LA    R4,PDBLENG(,R4)     POINT PAST OLD PDDB.
         CLR   R1,R4               IF THERE'S ANOTHER PDDB
         BH    HUAO290             IN THIS IOT, BRANCH.
HUAO285  DS    0H
         L     RIOT,SJBDBLWK       POINT TO THE NEXT IOT.
         LTR   RIOT,RIOT           IF NO MORE IOTS,
         BZ    HUAO300             END UNALLOCATION.
         ST    RIOT,SDBPIOT        SET SDBPIOT TO NEW IOT.
         L     R4,$SVPDDB1         POINT TO FIRST                    R4
         ALR   R4,RIOT              PDDB IN IT                       R4
HUAO290  DS    0H
         ST    R4,SDBPDDB          SET SDBPDDB TO NEW PDDB.
         CLC   PDBDSKEY,SDBDKEY    IF DATA SET KEY MATCHES,
         BE    HUAO10               BR TO UNALLOCATE IT TOO         R41
*
*
*              FREE THE SUBSYSTEM DATASET BLOCK AND EXIT
*
*
HUAO300  DS    0H
         CALL  $SDBFREE            FREE THE SDB.
         B     HUA900              EXIT NORMALLY.
         EJECT
*
*              INTERNAL READER UNALLOCATION
*
HUAR     DS    0H
         USING DCTDSECT,RSDB       USE DCT DSECT.
         CLI   DCTDEVTP,DCTINR     DOES SSALSSCM POINT TO INT RDR...
         BE    HUAR05              IF SO, CONTINUE             @OZ38453
         LA    R15,SSALWTFL        IF NOT, CAN'T ALLOCATE.
          $EPILOG ,                RETURN FAILURE CODE.
HUAR05   DS    0H                                              @OZ38453
         ICM   R0,7,RIDUBF+1       HAS CLOSE BEEN DONE         @OZ38453
         BZ    HUAR10              IF YES, CONTINUE UNALLOC    @OZ38453
         OI    RIDFLAGS,RIDEOM+RIDEND+RIDPOST N,TELL RDR TO    @OZ38453
         OI    DCTFLAGS,DCTDELET   CLEAN UP                    @OZ38453
         OI    DCTSTAT,DCTHOLD     HOLD DCT                    @OZ38453
         NI    RIDFLAGS,255-RIDBUSY LET RDR HAVE DCT           @OZ38453
         NI    DCTFLAGS,255-DCTSTOP CLEAR POSSIBLE STOP        @OZ38453
         MVC   RIDEOMA,PSAAOLD-PSA SHOW ASCB TO POST           @OZ38453
       $$POST  ELMT=$SVIRDR        POST INTRDR                 @OZ38453
         WAIT  1,ECB=RIDEOME       WAIT FOR RDR TO FINISH      @OZ38453
         XR    R0,R0               CLEAR ZERO                  @OZ38453
         ST    R0,RIDEOMA          CLEAR ASCB                  @OZ38453
         ST    R0,RIDEOME          CLEAR EOM ECB               @OZ38453
         ST    R0,RIDECB           CLEAR ECB                   @OZ38453
*
*              ACQUIRE CMS LOCK
*
HUAR10   DS    0H
         LR    R2,R13              SAVE REGISTERS
         STM   R11,R13,12(R2)      11 THROUGH 13.
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=HUAR30          C
                                   ACQUIRE LOCAL LOCK.
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,RELATED=HUAR30            C
                                   ACQUIRE CMS LOCK.
         LM    R11,R13,12(R2)      RESTORE REGISTERS 11 THROUGH 13.
*
*              UNALLOCATE INTERNAL READER
*
         SLR   R0,R0               ZERO OUT INTERNAL READER'S
         ST    R0,RIDASCBP         ASCB POINTER AND
         ST    R0,RIDUBF           UNPROTECTED-BUFFER POINTER.
         XC    RIDJBID(8),RIDJBID  ZERO JOB ID                 @OZ68422
         XC    RIDJNAM(8),RIDJNAM    AND NAME OF OWNER         @OZ68422
         NI    RIDFLAGS,255-RIDALLOC  SHOW INTERNAL READER NOT ALLOC.
*
*              POST EVERYBODY WAITING ON INTERNAL READER ALLOCATION.
*
         SLR   R0,R0               ZERO R0 FOR ZEROING.
         L     R6,$SVIRWT          POINT TO FIRST WAIT ELEMENT
         CS    R6,R0,$SVIRWT       AND MAKE THE
         BNE   *-4                 CHAIN HEADER ZERO.
HUAR20   DS    0H
         LTR   R6,R6               IS THERE A WAIT ELEMENT...
         BZ    HUAR30              IF NOT, DONE POSTING.
         L     R5,12(,R6)          POINT TO THE ASCB.
         USING ASCB,R5             SET ASCB ADDRESSABILITY.
         TM    ASCBFLG1,ASCBTERM+ASCBABNT  IF MEMORY ENDING,
         BNZ   HUAR25              GO FREE ELEMENT.
         DROP  R5                  DROP ASCB BASE.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R9,R13              ONLY 9, 14 GOOD AFTER CALL.
         L     R15,CVTPTR          POINT TO CVT.
         L     R15,CVT0PT01-CVT(,R15)  POINT THENCE TO IEA0PT01.
         SLR   R10,R10             SHOW ZERO COMPLETION CODE.
         L     R11,8(,R6)          POINT R11 TO ECB.
         O     R11,=X'80000000'    SHOW CROSS-MEMORY POST.
         L     R12,16(,R6)         POINT R12 TO ERRET.
         L     R13,12(,R6)         POINT R13 TO ASCB.
         BALR  R14,R15             GO POST.
         LR    R13,R9              RESTORE R13 FROM R9.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         L     R6,0(,R6)           POINT TO NEXT ELEMENT.
         B     HUAR20              GO CHECK IT.
HUAR25   DS    0H
         LR    R1,R6               INSTEAD OF POST, FREE ELEMENT
         L     R6,0(,R6)           AFTER POINTING TO NEXT ONE.
         $FREMAIN RC,A=(R1),LV=32,SP=231,KEY=1  FREE WAIT ELEMENT.
         B     HUAR20              THEN CHECK NEXT ELEMENT.
*
*              RELEASE CMS LOCK
*
HUAR30   DS    0H
         LR    R2,R13              SAVE REGISTERS
         STM   R11,R13,12(R2)      11 THROUGH 13.
         SETLOCK RELEASE,TYPE=CMS,RELATED=HUAR10                       C
                                   RELEASE CMS LOCK.
         SETLOCK RELEASE,TYPE=LOCAL,RELATED=HUAR10                     C
                                   RELEASE LOCAL LOCK.
         LM    R11,R13,12(R2)      RESTORE REGISTERS 11 THROUGH 13.
*
*              RETURN TO CALLER.
         LA    R15,SSALRTOK        SET NORMAL RETURN CODE.
         $EPILOG KEY=0             RETURN TO CALLER.
         EJECT
*
*
*              FAILURE IN UNALLOCATION
*
*
         SPACE 1
HUA800   DS    0H
         LA    R15,SSALWTFL        SET UNABLE-TO-ALLOCATE.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY           R41
         CLC   =CL4'SDB',SDBID     TEST SDB ID                      R41
         BE    HUA890              BR IF OK                         R41
        $EPILOG ,                   ELSE RETURN                     R41
HUA820   DS    0H
         LA    R15,SSALIDST        SET INVALID DESTINATION.
         SPACE 3
HUA890   DS    0H
         LR    R2,R15              SAVE RETURN CODE.
         CALL  $SDBFREE            FREE THE SDB.
         LR    R15,R2              RESTORE RETURN CODE.
         $EPILOG ,                 RETURN.
         SPACE 3
*
*
*              NORMAL EXIT FROM UNALLOCATION
*
*
         SPACE 1
HUA900   DS    0H
         CALL  HCBCK               CHECKPOINT MARKED BLOCKS.
         SPACE 1
HUA950   DS    0H
         SLR   R15,R15             SHOW NORMAL EXIT.
         $EPILOG ,                 RETURN.
         TITLE 'HALDCIOT -- SUBROUTINE TO DECHAIN IOT'
*
*
*              HALDCIOT -- DECHAIN OUTPUT OR SPIN IOT
*
*
* OUTPUT IOT - IOT IS DECHAINED FROM SJBIOT AND JCTIOT
* SPIN IOT - IOT IS DECHAINED FROM SJBSPIOT AND JCTSPIOT
* THIS SUBROUTINE OPERATES UNDER HOSUNAL ADDRESSABILITY.
         SPACE 1
HALDCIOT DS    0H
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         TM    IOTFLAG1,IOT1SPIN   IS THIS A SPIN IOT...
         BZR   R14                 IGNORE NON-SPIN IOT NOW.
         SPACE 3
*
*              DE-CHAIN SPIN IOT FROM SJBSPIOT ONLY                  R4
*
         SPACE 1
         LA    R1,SJBSPIOT         POINT TO SPIN IOT HEADER.
         SL    R1,=A(IOTIOT-IOTDSECT)  SET UP TO CHAIN.
HALDCI10 DS    0H
         LR    R2,R1               SAVE PREVIOUS IOT POINTER.
         L     R1,IOTIOT-IOTDSECT(,R1)  POINT TO NEXT IOT.
         LTR   R1,R1               IF NO MORE IOTS,
         BZR   R14                 RETURN.
         CLR   RIOT,R1             IF THIS IS NOT THE
         BNE   HALDCI10            ARGUMENT IOT, KEEP GOING.
         MVC   IOTIOT-IOTDSECT(,R2),IOTIOT  DECHAIN ARGUMENT IOT.
         BR    R14                 RETURN.
         DROP  ,                   DROP ALL ADDRESSABILITY.
         TITLE 'LITERAL POOL FOR UNALLOCATE'                         R4
         LTORG
         TITLE 'HJEAHOLD - HOLD SPECIAL DATA SETS IF HELD MSGCLASS'
*
*        ROUTINE NAME - HJEAHOLD
*
*        PURPOSE - TO PUT INTO HOLD STATUS A JOB'S FOUR FAKE-OPENED
*              DATASETS AND/OR XBM JOB'S SYSOUT DATASETS -
*                    JCL DATASET (NORMALLY NOT SYSOUT)
*                    JES2 JOB LOG
*                    JCL IMAGES (NOT SYSOUT IF XBM)
*                    SYSTEM MESSAGES
*                    EXECUTION BATCH MONITOR JOB'S SYSOUT DATASETS.
*
*        FUNCTION - IF AN ATTRIBUTE OF THE JOB'S MESSAGE CLASS IS
*              'HOLD', THIS ROUTINE CALLS HJH100 ONCE FOR EACH OF THE
*              JOB'S FOUR FAKE-OPENED DATASETS.  THEN, FOR XBM JOBS,
*              IT CALLS HJH100 ONCE FOR EACH SYSOUT DATASET WHICH
*              SHOULD BE HELD BY REASON OF CLASS OR ALLOCATION
*              DIRECTIVE.
*
*        OPERATION -
*              1.  IF NO MAIN OUTPUT ALLOCATION IOT EXISTS, RETURN.
*              2.  THE SYSOUT CLASS ATTRIBUTE TABLE IS INDEXED BY
*                  THE BYTE AT JCTMCLAS.  THE ATTRIBUTE 'HOLD' IS
*                  TESTED.  IF NOT 'HOLD' THE NEXT 4 STEPS ARE SKIPPED.
*              3.  HJH100 IS CALLED FOR JCL DATA SET.
*              4.  HJH100 IS CALLED FOR JES2 JOB LOG.
*              5.  HJH100 IS CALLED FOR JCL IMAGES.
*              6.  HJH100 IS CALLED FOR SYSTEM MESSAGES.
*              7.  IF NOT AN XBM JOB, RETURN.
*              8.  FOR EACH XBM SYSOUT DATASET -
*                  A.  IF PDB1HOLD, CALL HJH100. ELSE -
*                  B.  IF JCTMCLAS AND PDBCLASS HAVE 'HOLD' ATTRIBUTE,
*                      CALL HJH100.
*
*        REGISTERS AT ENTRY -
*              R7  = HASP JCT
*              R11 = SUBSYSTEM VECTOR TABLE
*              R13 = SUBSYSTEM JOB BLOCK
*              R14 = RETURN ADDRESS
*              R15 = ADDRESS OF HJEAHOLD
*
*        REGISTER USAGE IN ADDITION TO ABOVE-
*              R1  = SCAT ENTRY
*              R2  = LOCAL BASE, SET FROM R15
*              R3  = IOT CONTAINING PDDB BEING PROCESSED.
*              R4  = PDDB CURRENTLY TO BE PROCESSED
*              R6  = LINK REGISTER
*              R7  = HASP JCT
*              R8  = RETURN REGISTER, SET FROM R14
*              R11 = SUBSYSTEM VECTOR TABLE
*              R13 = SUBSYSTEM JOB BLOCK
*              R14 = RETURN REGISTER, USED TO SET R8
*              R15 = ENTRY REGISTER, USED TO SET R2
*
*        REGISTER DIFFERENCES AT EXIT -
*              R0-R6, R8, R10, R14-R15 DESTROYED
*
*        EXITS - NULL AND NORMAL -
*              ON R8
*
         SPACE 1
HJEAHOLD DS    0H
         USING *,R2                SET LOCAL ADDRESSABILITY.
         LR    R2,R15              SET LOCAL BASE.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         L     R3,SJBIOT           POINT TO ALLOCATION IOT.
         LTR   R3,R3               IF IT DOESN'T EXIST,
         BZR   R14                 NULL RETURN.
         LR    R8,R14              SAVE RETURN IN R8.
         USING JCTDSECT,R7         SET JCT ADDRESSABILITY.
         SLR   R6,R6               ZERO R6 FOR IC.
         IC    R6,JCTMCLAS         GET MSGCLASS FROM JCT.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         LA    R1,$SVSCAT(R6)      POINT TO SCAT ENTRY FOR
         USING SCADSECT,R1         MSGCLASS, SET ADDRESSABILITY.
         TM    SCATFLAG,SCATHOLD   IF MSGCLASS NOT TO BE HELD,
         BZ    HJEAH20             BR TO TEST FOR OTHERS.
         USING IOTDSECT,R3         SET ALLOCATION IOT ADDR.
         L     R4,$SVPDDB1         POINT TO PDDB                     R4
         LA    R4,IOTPDBOJ(R3,R4)   FOR JCL DATA SET                 R4
         BAL   R6,HJH100           CALL HJH100.
         L     R4,$SVPDDB1         POINT TO PDDB                     R4
         LA    R4,IOTPDBOL(R3,R4)   FOR JES2 JOB LOG                 R4
         BAL   R6,HJH100           CALL HJH100.
         L     R4,$SVPDDB1         POINT TO PDDB                     R4
         LA    R4,IOTPDBOI(R3,R4)   FOR JCL IMAGES                   R4
         BAL   R6,HJH100           CALL HJH100.
         L     R4,$SVPDDB1         POINT TO PDDB                     R4
         LA    R4,IOTPDBOM(R3,R4)   FOR SYSTEM MESSAGES              R4
         BAL   R6,HJH100           CALL HJH100.
         SPACE 1
HJEAH20  TM    SJBFLG1,SJB1XBM     IF NOT XBM JOB,
         BZR   R8                   RETURN.
         L     R4,$SVPDDB1                PREPARE TO HOLD            R4
         LA    R4,IOTPDBOD-PDBLENG(R3,R4)  SYSOUT DATA SETS          R4
         SPACE 1
HJEAH40  LA    R4,PDBLENG(,R4)     POINT TO NEXT PDDB (IF ANY).
         L     R1,IOTPDDBP         IF NOT END
         LA    R1,IOTDSECT(R1)      OF PDDBS IN
         CLR   R4,R1                 CURRENT IOT,
         BL    HJEAH60                GO TO TEST HOLD REQUIREMENT.
         ICM   R3,15,IOTIOT        IF NO MORE IOT(S),
         BZR   R8                   RETURN.
         L     R4,$SVPDDB1         ELSE                              R4
         ALR   R4,R3               PREPARE                           R4
         SL    R4,=A(PDBLENG)      TO SCAN                           R4
         B     HJEAH40              NEXT IOT.
         SPACE 1
         USING PDBDSECT,R4         SET PDDB ADDRESSABILITY.
HJEAH60  TM    PDBFLAG1,PDB1HOLD   IF 'HOLD=YES' SPECIFIED,
         BO    HJEAH80              GO TO HOLD THE DATASET.
         SLR   R6,R6               IF MSGCLASS
         IC    R6,JCTMCLAS          OF JOB NOT
         LA    R1,$SVSCAT(R6)        A 'HOLD'
         TM    SCATFLAG,SCATHOLD      CLASS,
         BZ    HJEAH40                 TEST NEXT PDDB.
         IC    R6,PDBCLASS         IF SYSOUT
         LA    R1,$SVSCAT(R6)       CLASS NOT A
         TM    SCATFLAG,SCATHOLD     'HOLD' CLASS,
         BZ    HJEAH40                TEST NEXT PDDB.
         SPACE 1
HJEAH80  BAL   R6,HJH100           CALL HJH100 TO HOLD THE DATASET.
         B     HJEAH40             THEN TEST NEXT PDDB.
         EJECT
*
*        ROUTINE NAME - HJH100
*
*        PURPOSE - TO PUT INTO HOLD STATUS A SUBSYSTEM DATA SET.
*
*        FUNCTION - A NEW IOT IS CREATED AND THE DATA SET'S PDDB
*              IS MOVED INTO IT.  THE OLD PDDB IS NULLIFIED.
*              THE IOT IS CHAINED ON THE SPIN QUEUE FOR FURTHER
*              PROCESSING BY HASPXEQ.
*
*        OPERATION -
*              1.  IF DATASET NULL OR NOT SYSOUT, RETURN.
*              2.  IF NO STORAGE FOR NEW IOT, ERROR RETURN.
*              3.  INITIALIZE THE NEW IOT.
*              4.  COPY THE PDDB TO THE NEW IOT.
*              5.  NULLIFY THE OLD PDDB.
*              6.  TRACK-ADDRESS-CHAIN THE IOT LIFO TO JCTSPIOT.
*              7.  WRITE THE IOT TO ITS ASSIGNED TRACK.
*              8.  MAIN-STORAGE-CHAIN THE IOT LIFO TO $SVSPIOT.
*              9.  NOTIFY HASPXEQ THAT AN ADDITION HAS BEEN MADE TO
*                  $SVSPIOT AND RETURN NORMALLY.
*
*        REGISTERS AT ENTRY -
*              R2  = LOCAL BASE, FROM ROUTINE HJEAHOLD
*              R4  = PDDB TO BE PROCESSED
*              R6  = RETURN ADDRESS
*              R7  = HASP JCT
*              R11 = SUBSYSTEM VECTOR TABLE
*              R13 = SUBSYSTEM JOB BLOCK
*
*        REGISTER USAGE IN ADDITION TO ABOVE -
*              R0  = WORK, SUBROUTINE ARGUMENT
*              R1  = SUBROUTINE ARGUMENT
*              R5  = NEW IOT
*              R14 = SUBROUTINE RETURN
*              R15 = SUBROUTINE ENTRY
*
*        REGISTER DIFFERENCE AT EXIT -
*              R5  = 0
*              R0, R1, R10, R14, R15 DESTROYED
*
*        EXIT - NORMAL
*              ON R6 WITH R5 POINTING TO NEW IOT
*
*        EXIT - ERROR
*              ON R6 WITH MESSAGE HASP376 WRITTEN AND NEW IOT
*                  STORAGE FREED
*
*        EXIT - NULL
*              ON R6 WITH NO ACTION TAKEN
*
         EJECT
HJH100   DS    0H
         TM    PDBFLAG1,PDB1NULL+PDB1NSOT  IF DATA SET IS NULL OR
         BNZR  R6                  NOT FOR SYSOUT, NULL RETURN.
         SLR   RIOT,RIOT           SHOW NO NOW IOT.
         CALL  HCBGM               GET MAIN STORAGE FOR IOT.
         BNZ   HJH800              ERROR RETURN - NO STORAGE.
         LR    RIOT,R1             SHOW NEW IOT ADDRESS.
         L     R1,SJBIOT           POINT TO ALLOCATION IOT.
         LA    R1,IOTMSTAB-IOTDSECT(,R1)     PT TO MASTER TAB        R4
         CALL  $STRAK              GET A TRACK FOR NEW IOT.
         L     R15,SJBIOT          GET ALLOCATION IOT ADDRESS  @OZ17477
         OI    IOTFLAG1-IOTDSECT(R15),IOT1CKPT FORCE IOT CHKPT @OZ17477
         LA    R10,HJHCON          POINT R10 TO FAKE SSAL.
         CALL  HALCRIOT            FORMAT THE NEW IOT.
         USING IOTDSECT,RIOT       SET NEW IOT ADDRESSABILITY.
         L     R15,$SVPDDB1           MOVE PDDB                      R4
         LA    R14,0(R15,RIOT)         TO                            R4
         MVC   0(PDBLENG,R14),PDBDSECT  NEW IOT                      R4
         NI    PDBFLAG1-PDBDSECT(R14),PDB1LOG  CLEAR ALL BUT LOG BIT R4
         OI    PDBFLAG1-PDBDSECT(R14),PDB1HOLD+PDB1PSO               R4
         OI    PDBFLAG1,PDB1NSOT   NULLIFY OLD PDDB.
         LA    R0,PDBLENG(,R15)    SET PDDB LIMIT                    R4
         ST    R0,IOTPDDBP         OFFSET IN NEW IOT.
         MVC   IOTIOTTR,JCTSPIOT   TRACK-ADDRESS CHAIN
         L     R0,IOTTRACK         NEW IOT ONTO
         ST    R0,JCTSPIOT         JCT'S SPIN CHAIN LIFO.
         OI    JCTFLAG1,JCT1CKPT   FLAG JCT FOR CHECKPOINT.
         CALL  HIOTSPIN            SPIN/HOLD THE IOT.
         BR    R6                  NORMAL RETURN.
         DROP  R3,R4,R5            DROP BASES.
HJHCON   EQU   *-(SSALFLG1-SSALBGN)  FAKE SSAL FOR SSALHOLD FLAG.
         DC    AL1(SSALHOLD)       FLAG SSALHOLD IN BYTE SSALFLG1.
         SPACE 2
         $MID  376                 SET HASP MESSAGE ID.
HJH800   WTO   '&MID.- UNABLE TO PROCESS SUBSYSTEM DATA SET FOR HOLD', C
               ROUTCDE=11,DESC=6
         LR    R1,RIOT             POINT R1 TO IOT OR ZERO.
         CALL  HCBFM               FREE NEW IOT STORAGE.
         BR    R6                  ERROR RETURN.
         DROP  ,                   DROP ALL ADDRESSABILITY.
         SPACE 4                                                     R4
         LTORG                                                       R4
         TITLE 'HIOTSPIN - SPIN THE ARGUMENT IOT'
*
*        ROUTINE NAME - HIOTSPIN
*
*        PURPOSE - TO PASS A SPIN/HOLD IOT TO HASPXEQ ON CHAIN
*              $SVSPIOT TO BE SPUN OR HELD
*
HIOTSPIN DS    0H
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         L     R15,SJBJCT          POINT TO THE JCT AND SET
         USING JCTDSECT,R15        TEMPORARY ADDRESSABILITY.
         STM   R14,R12,JCTWORK+12  SAVE REGS IN JCTWORK.
         DROP  R15                 KILL TEMP. JCT ADDRESSABILITY     R4
         USING JCTDSECT,R7         SET NORMAL JCT ADDRESSABILITY     R4
         BALR  R12,0               ESTABLISH
         USING *,R12               LOCAL ADDRESSABILITY.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         LH    R1,$SVBFSIZ              GET SPIN IOT                 R4
         LA    R0,IOTSTART-IOTDSECT(,R1) BUFFER STORAGE              R4
        $GETMAIN RC,LV=(R0),SP=231,KEY=1  IN CSA                     R4
         L     R7,SJBJCT           RESTORE JCT ADDRESS               R4
         BZ    HIS010              BR IF STORAGE OBTAINED            R4
        $MID   358                 SET MESSAGE NUMBER                R4
         WTO   '&MID.HIOTSPIN - NO STORAGE AVAILABLE IN SP 231',     R4C
               ROUTCDE=10,DESC=6                                     R4
         ICM   R1,7,SJBTCBP+1      IF TCB POINTER NOT ZERO,    @OZ58848
         BNZ   HIS005              THIS WAS NOT REQ-JOBID JOB  @OZ58848
         OI    SDBFLG2-SDBDSECT(RSDB),SDB2LOG SHOW SYSLOG...   @OZ58848
         EJECT                                                 @OZ36864
         B     HIS900                 .....ERROR, THEN EXIT    @OZ58848
         SPACE 1                                               @OZ58848
HIS005   DS    0H                                              @OZ58848
         L     R3,$SVPDDB1         POINT TO SPIN               @OZ41600
         ALR   R3,RIOT               DATASET PDDB IN LSQA      @OZ41600
         USING PDBDSECT,R3         GET PDDB ADDRESSABILITY     @OZ41600
         OI    PDBFLAG1,PDB1NSOT   NO PRINT OF LOST DATASET    @OZ41600
         MVC   IOTJQOFF,JCTJQE     STORE JQE OFFSET IN IOT     @OZ41600
         NI    IOTFLAG1,255-IOT1CKPT  RESET CHECKPOINT FLAG    @OZ41600
         L     R0,IOTTRACK         SET TRACK OF IOT            @OZ41600
         LR    R1,RIOT               AND IOT'S STORAGE ADDR    @OZ41600
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE THE IOT               @OZ41600
         CALL  HCBFM               FREE OLD SPIN IOT           @OZ41600
         B     HIS900              THEN EXIT                   @OZ41600
         EJECT                                                 @OZ58848
HIS010   LR    R8,R1               RELOAD IOT ADDRESS          @OZ41600
*
*              FOR HOLD DATA SETS, PERFORM HQT PROCESSING
*
         L     R3,$SVPDDB1         POINT TO                          R4
         ALR   R3,RIOT              SPIN DATA SET PDDB               R4
         USING PDBDSECT,R3         PROVIDE PDDB ADDRESSABILITY       R4
         TM    PDBFLAG1,PDB1NULL+PDB1NSOT  DATA SET PRINTABLE...    R41
         BZ    *+8                 BR IF YES                        R41
         NI    PDBFLAG1,255-PDB1HOLD  DON'T BOTHER HOLDING          R41
         TM    PDBFLAG1,PDB1HOLD   SHOULD DATA SET BE HELD...        R4
         BZ    HIS060              FLAG IS OFF, SKIP AROUND.
         DROP  R3                  KILL PDDB ADDRESSABILITY          R4
SKIP280  SLR   R1,R1               ZERO R1 - WILL BECOME IOTHQT.
         LH    R3,JCTHQRCT         GET CT OF HQRS BEFORE THIS.
         LTR   R4,R3               TEST AND SAVE FOR LATER.
         LA    R6,1(,R3)           INCREMENT HQR COUNT.
         BZ    HIS020              BRANCH IF THIS IS 1ST HQR.
         SLR   R2,R2               ZERO HIGH DIVIDEND.
         D     R2,$SVHQRCT         DIVIDE HQR CT BY HQRS/HQT         R4
         LTR   R2,R2               IF REMAINDER IS ZERO,
         BNZ   HIS040              WE NEED A NEW HQT TRACK.
         B     HIS030              GET NEW HQT TRACK                 R4
* NEW HQT NEEDED - GET A TRACK FOR IT
HIS020   DS    0H
         L     R1,JCTHQT           IF TRACK ADDRESS
         LTR   R1,R1                IN JCTHQT,
         BNZ   HIS040                BR TO USE FOR 1ST HQT.
HIS030   L     R1,SJBIOT           POINT TO MAIN ALLOCATION IOT      R4
         LA    R1,IOTMSTAB-IOTDSECT(,R1)     SET ARG TO $STRAK       R4
         CALL  $STRAK              GET A TRACK FOR NEW HQT.
         EJECT                                                 @OZ36864
* SET HQT INFORMATION IN JCT, IOT, AND HQT                     @OZ36864
         SPACE 1                                               @OZ36864
HIS040   ST    R1,IOTHQT           STORE HQT TRACK ADDRESS     @OZ36864
         MVC   IOTHQT1,JCTHQT       AND PTR TO FIRST HQT       @OZ36864
         STH   R6,JCTHQRCT         UPDATE HQR COUNT IN JCT     @OZ36864
         SPACE 1                                               @OZ36864
* IF FIRST HELD DATA SET, WRITE JCT AT HQT LOCATION            @OZ36864
         SPACE 1                                               @OZ36864
         LTR   R4,R4               FIRST HELD DATA SET...      @OZ36864
         BNZ   HIS045              BR IF NO                    @OZ36864
         ST    R1,JCTHQT           STORE POINTER TO 1ST HQT    @OZ36864
         ST    R1,IOTHQT1           IN JCT AND IN IOT          @OZ36864
         LR    R0,R1               RELOAD HQT TRACK ADDRESS    @OZ36864
         LR    R1,R7               RELOAD JCT ADDRESS          @OZ36864
         MVC   SJBFWORD,=CL4'JCT'  INDICATE JCT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE JCT AT HQT LOCATION   @OZ36864
         SPACE 1                                               @OZ36864
* REWRITE THE JCT, UNLESS CALLED BY THE CONVERTER              @OZ36864
         SPACE 1                                               @OZ36864
HIS045   TM    SJBFLG2,SJB2CONV    CALLED BY CONVERTER...      @OZ36864
         BO    HIS060              BR IF YES                   @OZ36864
         NI    JCTFLAG1,FF-JCT1CKPT  RESET CHECKPOINT FLAG     @OZ36864
         L     R0,SJBJCTRK         GET JCT TRACK ADDRESS       @OZ36864
         LR    R1,R7               RELOAD JCT ADDRESS          @OZ36864
         MVC   SJBFWORD,=CL4'JCT'  INDICATE JCT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE THE JCT               @OZ36864
         B     HIS060              GO WRITE AND QUEUE IOT      @OZ36864
         EJECT                                                 @OZ36864
*
*              FOR SPIN/HOLD DATA SETS, WRITE AND QUEUE THE IOT
*
HIS060   DS    0H
         MVC   IOTJQOFF,JCTJQE     STORE JQE OFFSET IN IOT.
         MVC   IOTHQRCT,JCTHQRCT   SET UNALLOCATION NUMBER IN IOT    R4
         NI    IOTFLAG1,255-IOT1CKPT  RESET CHECKPOINT FLAG         R41
         TM    SJBFLG2,SJB2CONV    CALLED BY CONVERTER...      @OZ36864
         BO    *+8                 BR IF YES                   @OZ36864
         OI    IOTFLAG1,IOT1NTPR   SET NOT PROCESSED FLAG      @OZ35742
         L     R0,IOTTRACK         SET TRACK OF IOT
         LR    R1,RIOT             AND IOT'S STORAGE ADDRESS.
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE THE IOT.
         MVC   JCTWORK+20+RIOT*4(4),IOTIOT  SAVE OLD IOT CHAIN.
         LH    R1,IOTLENG          MOVE                              R4
         LR    R0,R8                SPIN                             R4
         LR    R15,R1                IOT                             R4
         LR    R14,RIOT               TO                             R4
         MVCL  R0,R14                  CSA                           R4
         LR    R1,RIOT             FREE OLD                          R4
         CALL  HCBFM                SPIN IOT                         R4
         LR    RIOT,R8             RELOAD NEW SPIN IOT ADDRESS       R4
         TM    SJBFLG2,SJB2CONV    CALLED BY CONVERTER...      @OZ36864
         BZ    HIS070              BR IF NO                    @OZ36864
         EJECT                                                 @OZ36864
***************************************************************@OZ36864
*                                                              @OZ36864
*        IF CALLED BY CONVERTER SUBTASK, ERRORS WERE FOUND.    @OZ36864
*        THE JOB WILL BE QUEUED FOR OUTPUT BY THE CONVERSION   @OZ36864
*        PROCESSOR UPON RETURN FROM THE CONVERTER SUBTASK.     @OZ36864
*        SUBSYSTEM DATA SETS WHICH ARE TO BE HELD MUST BE      @OZ36864
*        HANDLED BY THE CONVERSION PROCESSOR PRIOR TO ITS      @OZ36864
*        QUEUING THE JOB FOR OUTPUT.  THIS AVOIDS WARM START   @OZ36864
*        CONSIDERATIONS FOR JOBS IN CONVERSION PROCESSING      @OZ36864
*        AND ENSURES THAT THE JOB NOT BE PURGED BY THE         @OZ36864
*        OUTPUT PROCESSOR DURING SPIN/HOLD PROCESSING BY       @OZ36864
*        HASPXEQ OR HASPHOLD.                                  @OZ36864
*                                                              @OZ36864
***************************************************************@OZ36864
         SPACE 1                                               @OZ36864
         LA    R8,$SVXIOTQ-(IOTIOT-IOTDSECT) PREPARE TO SCAN Q @OZ36864
         SPACE 1                                               @OZ36864
HIS065   LR    R1,R8               SAVE LAST IOT ADDRESS       @OZ36864
         ICM   R8,15,IOTIOT-IOTDSECT(R1)  POINT TO NEXT        @OZ36864
         BNZ   HIS065              LOOP UNTIL END OF CHAIN     @OZ36864
         ST    RIOT,IOTIOT-IOTDSECT(,R1)  ADD IOT TO END OF    @OZ36864
         ST    R8,IOTIOT                   PCE HOLD QUEUE      @OZ36864
         OI    IOTFLAG1,IOT1CKPT   FLAG IOT FOR CHECKPOINT     @OZ36864
         B     HIS900              BRANCH TO EXIT              @OZ36864
         SPACE 1                                               @OZ36864
HIS070   L     R0,$SVSPIOT         CHAIN                       @OZ36864
         ST    R0,IOTIOT           IOT                         @OZ36864
         CS    R0,RIOT,$SVSPIOT    ON
         BNE   *-8                 $SVSPIOT.
         $$POST ELMT=$SVJOB        ACTIVATE JES2.
HIS900   LM    R14,R12,JCTWORK+12  RESTORE REGISTERS                 R4
         BR    R14                 AND RETURN.
         DROP  ,                   DROP ALL ADDRESSABILITY.
         LTORG                                                       R4
         TITLE 'HASP SUBSYSTEM SUPPORT ROUTINE -- OPEN'
*
*
*              HASP SUBSYSTEM SUPPORT ROUTINE -- OPEN
*
*
HOSOPEN  $PROLOG SSOBOPEN,SSDASIZE,LOCK=SDB OPEN
HOSOPENB DS    0H                  OPEN BASE LABEL
         SPACE 1
RJFC     EQU   R7                  RJFC IS REGISTER 7.
RDEB     EQU   R6                  RDEB IS REGISTER 6.
*
*              USE SUBROUTINE TO SET UP REGISTERS AND
*              TO DETERMINE TYPE OF OPEN
*
         CALL  HOCSETUP            CALL SUBROUTINE.
         USING DEBBASIC,RDEB       SET DEB ADDRESSABILITY.
         USING INFMJFCB,RJFC       SET JFCB ADDRESSABILITY.
         USING SSDABGN,RSIB        SET SSDA ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         B     HO000               INTERNAL READER
         B     HO100               SUBSYSTEM DATA SET - SI
         B     HO200               SUBSYSTEM DATA SET - SO
         B     HO300               SUBSYSTEM DATA SET - PS
         B     HO400               SUBSYSTEM DATA SET - INVALID
         B     HOERR               ERROR DETECTING TYPE
         EJECT
*
*              O P E N   I N T E R N A L   R E A D E R
*
HO000    DS    0H
         USING DCTDSECT,RSDB       SET DCT ADDRESSABILITY.
         ST    RSDB,DEBIRBAD       SAVE DCT ADDRESS IN DEB.
         MVC   DEBAPPAD,=A(HASPAM) SET HAM ADDRESS IN DEB.
         L     R1,DEBDCBAD         POINT TO OPENING ACB.
         USING IFGACB,R1           SET ACB ADDRESSABILITY.
         MVC   ACBINRTN,=A(HASPAM) POINT ACB TO HASP ACS METH.
         OI    ACBINRTN,ACBINR     SHOW DEB POINTS TO INTRDR.
         SLR   R15,R15             SET NORMAL RETURN CODE.
         ST    R15,RIDUBF          ZERO UNPROTECTED-BUFFER POINTER
         $EPILOG ,                 RETURN TO CALLER.
         DROP  R1                  DROP ACB ADDRESSABILITY.
         EJECT
*
*              O P E N   S Y S I N   D A T A   S E T
*
HO100    DS    0H
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
* IF XBM AND ALREADY OPEN, DON'T OPEN AGAIN.
         TM    SJBFLG1,SJB1XBM     IF NOT XBM,
         BZ    HO107               CONTINUE.
         L     R0,SDBUBF           IF NO UNPROTECTED BUFFER,
         LTR   R0,R0               DATA SET IS NOT OPEN -
         BZ    HO107               CONTINUE.
         BAL   R14,HODEBACB        ELSE SET UP DEB & ACB
         B     HORET               AND RETURN.
* NOT XBM AND/OR NOT OPEN - CONTINUE NORMALLY
HO107    DS    0H
*
*              O P E N   P R O C E S S - S Y S O U T   D A T A   S E T
*
HO300    DS    0H
         L     R0,SDBDEB           GET SDB'S DEB POINTER.
         LTR   R0,R0               IF NO DEB, DATA SET IS
         BZ    HO110               CLOSED.  GO OPEN IT.
         TM    SJBFLG1,SJB1XBM     IF OPEN ALREADY AND XBM,
         BO    HORET               IGNORE OPEN.
         B     HOERR               NOT XBM BUT OPEN - ERROR.
HO110    DS    0H
*
*              OPEN SYSIN DATA SET
*
         CALL  HOOLDINP            GET BUFFERS ETC. FOR DATA SET.
         BNZ   HOERR               BRANCH IF HOOLDINP FAILED.
         SLR   R0,R0               ZERO
         ST    R0,SDBRECCT         SDB RECORD COUNTER.
* TEST FOR CHECKPOINT RESTART
         TM    SSDARESF,SSDAAUTO+SSDADEFR  IF NOT
         BZ    HO140               CHECKPOINT RESTART, BRANCH.
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER
         USING BFD,RBUF            AND SET ADDRESSABILITY.
         L     R1,SSDABUFR         POINT TO RESTART BUFFER.
         MVC   BFRBA,16(R1)        ASSUME AUTOMATIC RESTART.
         TM    SSDARESF,SSDAAUTO   IF AUTOMATIC,
         BO    HO120               CONTINUE.
         MVC   BFRBA(5),SDBTRKF    IF DEFERRED, SET STARTING
         MVC   BFRBA+5(3),25(R1)   TRACK & SAVED RECORD COUNT.
* FOR CHECKPOINT RESTART, POSITION THE DATA SET.
HO120    DS    0H
         DROP  RBUF                DROP BUFFER ADDRESSABILITY.
         BAL   R14,HODEBACB        SET UP DEB AND ACB.
         LCR   R1,R1               COMPLEMENT ACB ADDRESS.
         LA    R0,HSVCPNT          SET SVC FUNCTION = POINT.
         SVC   HAMSVC              ISSUE HAM SVC.
         B     HORET               RETURN TO CALLER.
* FOR STEP RESTART AND NORMAL OPEN, READ.
HO140    DS    0H
         CALL  HCNVFDAD            CONVERT TRACK TO OS FORMAT.
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         BAL   R14,HODEBACB        SET UP DEB AND ACB.
         EXCP  SDBIOB              READ IN FIRST RECORD.
         WAIT  1,ECB=SDBECB        WAIT FOR COMPLETION.
         B     HORET               THEN RETURN.
         EJECT
*
*              O P E N   S Y S O U T   D A T A   S E T
*
HO200    DS    0H
*
*              UP OPEN COUNT.  IF ALREADY OPEN, SET UP & EXIT
*
         L     R1,SDBCCW3+4        GET OPEN COUNT.
         LA    R0,1(,R1)           INCREMENT IT.
         ST    R0,SDBCCW3+4        STORE OPEN COUNT.
         LTR   R1,R1               IF DATA SET WASN'T OPEN,
         BZ    HO203               GO OPEN IT.
         LA    R14,HORET           ELSE SET RETURN ADDRESS
         B     HODEBACB            AND SET UP DEB & ACB.
*
*              OPEN SYSOUT DATA SET
*
HO203    DS    0H
         L     R1,SDBPDDB          POINT TO PDDB FOR DATA SET.
         USING PDBDSECT,R1         USE PDDB DSECT.
         TM    PDBFLAG1,PDB1NULL   IS DATA SET OLD...
         BO    HO210               BRANCH IF NOT.
         DROP  R1                  DROP PDDB BASE.
         CALL  HOOLDOUT            YES.  OPEN FOR OLD OUTPUT.
         BNE   HOERR               ERROR - OPEN FAILED.
*
*              FOR OLD SYSOUT, SET CURRENT RBA
*
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         USING BFD,RBUF            USE THE UBF DSECT.
         LM    R0,R1,SDBTRK        GET RESUME TRACK AND
         STM   R0,R1,BFRBA         SET IT IN BFRBA.
         ALR   R0,R1               ERROR IF ZERO TRACK AND
         BZ    HOERR               PDB1NULL IS OFF.
         BAL   R14,HODEBACB        SET UP DEB AND ACB.
         TM    SSDARESF,SSDAAUTO   IF NOT A RESTART CALL,
         BZ    HO205               GO CHECK CLOSED-AT-CHECKPOINT.
         L     R1,SSDABUFR         POINT TO RESTART DATA.
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         MVC   SDBTRKF(16),8(R1)   SET SDBTRKF, SDBTRK,
         MVC   BFRBA,16(R1)        AND BFRBA FROM RESTART DATA.
         B     HO207               BR TO CONTINUE                   R41
HO205    DS    0H
         CLC   =X'FFFFFF',SDBTRK+5 IF NOT CLOSED-AT-CHECKPOINT,
         BNE   HORET               RETURN TO CALLER.
         LCR   R1,R1               SET ACB COMPLEMENT.
         LA    R0,HSVCPNT          SET FUNCTION REGISTER.
         SVC   HAMSVC              POSITION TO END OF DATA SET.
         CL    R15,=A(HERNOEOD)    IF EOD NOT FOUND,
         BNE   HOERR               ERROR.
         LA    R0,1                OTHERWISE, SET
         STCM  R0,7,SDBTRK+5       RECORD NUMBER ONE
         L     RBUF,SDBUBF         IN SDBTRK
         STCM  R0,7,BFRBA+5        AND IN BFRBA.
         B     HORET               RETAB DONE BY POINT         @OZ35029
HO207    ICM   R0,15,SDBTRK+1      GET RESUME MTTR                  R41
         CALL  HJSRETAB            RE-BUILD TRACK ALLOC. BLOCK      R41
         B     HORET               RETURN.
*
*              OPEN NEW SYSOUT
*
         SPACE 2
HO210    DS    0H
         CALL  HONEWOUT            OPEN NEW SYSOUT DATA SET.
         BNE   HOERR               ERROR IF NO STORAGE.
         BAL   R14,HODEBACB        SET UP DEB AND ACB.
*
*              SET MTTR, RECFM, LRECL, FCB, UCS, AND FUNC
*
         USING IOTDSECT,RIOT       SET IOT AND PDDB
         USING PDBDSECT,R6         ADDRESSABILITY.
         L     RIOT,SDBAIOT        SET CHECKPOINT FLAG
         OI    IOTFLAG1,IOT1CKPT   IN ALLOCATION IOT.
         L     RIOT,SDBPIOT        POINT TO PDDB'S IOT.
         L     R6,SDBPDDB          POINT TO PDDB.
         L     R4,PDBMTTR          SET R4 = STARTING TRACK
         LH    R3,PDBDSKEY         AND R3 = DATA SET KEY.
HO270    DS    0H
* SET PDBRECFM
         MVC   PDBRECFM,JFCRECFM   SET PDBRECFM FROM JFCB.
* SET PDBLRECL
         LH    R0,JFCLRECL         GET LRECL FROM JFCB.
         LTR   R0,R0               IF JFCLRECL IS NONZERO,
         BNZ   *+8                 CONTINUE.
         LH    R0,JFCBLKSI         OTHERWISE USE JFCBLKSI.
         TM    JFCRECFM,JFCFIX     IF RECFM=F,
         BO    HO275               USE IT.
         TM    JFCRECFM,JFCVAR     IF RECFM=U,
         BZ    HO275               USE IT.
         SH    R0,=H'4'            FOR RECFM=V, SUBTRACT 4.
*              THIS LINE DELETED BY APAR OZ59731               @OZ59731
*              THIS LINE DELETED BY APAR OZ59731               @OZ59731
*              THIS LINE DELETED BY APAR OZ59731               @OZ59731
HO275    STH   R0,PDBLRECL         SET PDBLRECL.
* SET PDBUCS
         L     R0,JFCUCSID         GET UCS FROM JFCB.
         LTR   R0,R0               IF ZERO,
         BZ    *+8                 DON'T USE IT.
         ST    R0,PDBUCS           ELSE SET PDBUCS.
* SET PDBFCB
         L     R0,JFCFCBID         GET FCB FROM JFCB.
         LTR   R0,R0               IF ZERO,
         BZ    *+8                 DON'T USE IT.
         ST    R0,PDBFCB           ELSE SET PDBFCB.
* SET PDBFUNC
         MVC   PDBFUNC,JFCFUNC     SET PDBFUNC FROM JFCB.
         EJECT                                                       R4
* SET PDB2OPTJ                                                       R4
         TM    JFCOPTCD,JFCOPTJ    SET OR                           R41
         BZ    SKIP290              RESET                            R4
         OI    PDBFLAG2,PDB2OPTJ     PDB2OPTJ                        R4
         B     SKIP300                BASED UPON                     R4
SKIP290  NI    PDBFLAG2,255-PDB2OPTJ   JFCOPTCD                      R4
         SPACE 1                                                     R4
*                                                                    R4
*        IF 3800 JFCB EXTENSION EXISTS, SET PDDB 3800 FIELDS         R4
*                                                                    R4
SKIP300  TM    JFCUCSOP,JFCBEXTP   TEST FOR 3800 EXTENSION          R41
         BNO   HO279               BR IF NOT                         R4
         SPACE 1                                                     R4
         L     R15,JFCBEXAD-1      ESTABLISH JFCB                    R4
         USING JFCBE-16,R15         EXTENSION ADDRESSABILITY         R4
         SPACE 1                                                     R4
* SET PDB2BRST                                                       R4
         TM    JFCBFLAG,JFCBBST    SET OR                            R4
         BZ    SKIP310              RESET                            R4
         OI    PDBFLAG2,PDB2BRST     PDB2BRST                        R4
         B     SKIP320                BASED UPON                     R4
SKIP310  NI    PDBFLAG2,255-PDB2BRST   JFCBFLAG                      R4
* SET PDBMODF/PDBMODFT                                               R4
SKIP320  L     R0,JFCMODIF         SET                               R4
         CL    R0,=X'40404040'     CHARS FROM                  @OZ34625
         BE    SKIP330             JFCMODIF TO                 @OZ34625
         LTR   R0,R0                PDBMODF,                         R4
         BZ    SKIP330               PDBMODFT                  @OZ34625
         ST    R0,PDBMODF             IF                             R4
         MVC   PDBMODFT,JFCIDTRC       SPECIFIED                     R4
* SET PDBFLASH/PDBFLSHC                                              R4
SKIP330  L     R0,JFCBMAGT         SET                               R4
         CL    R0,=X'40404040'     CHARS FROM                  @OZ36611
         BE    SKIP340             JFCBMAGT TO                 @OZ36611
         LTR   R0,R0                PDBFLASH,                        R4
         BZ    SKIP340             PDBFLSHC                    @OZ36611
         ST    R0,PDBFLASH            IF                             R4
         ICM   R0,1,JFCIMTOT       DONT OVERLAY DEFAULT FLASH  @OZ65667
         BZ    SKIP340               COUNT IF NOT              @OZ65667
         MVC   PDBFLSHC,JFCIMTOT       SPECIFIED                     R4
* SET PDBCHAR1-4                                                     R4
SKIP340  L     R0,JFCBTRS1         SET                               R4
         CL    R0,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP350              JFCB TO                    @OZ30543
         LTR   R0,R0                PDBCHAR1                         R4
         BZ    SKIP350               IF                        @OZ30543
         ST    R0,PDBCHAR1            SPECIFIED
SKIP350  L     R0,JFCBTRS2         SET                               R4
         CL    R0,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP360              JFCB TO                    @OZ30543
         LTR   R0,R0                PDBCHAR2                         R4
         BZ    SKIP360               IF                        @OZ30543
         ST    R0,PDBCHAR2            SPECIFIED                      R4
SKIP360  L     R0,JFCBTRS3         SET                               R4
         CL    R0,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP370              JFCB TO                    @OZ30543
         LTR   R0,R0                PDBCHAR3                         R4
         BZ    SKIP370               IF                        @OZ30543
         ST    R0,PDBCHAR3            SPECIFIED                      R4
SKIP370  L     R0,JFCBTRS4         SET                               R4
         CL    R0,=X'40404040'      CHARS FROM                 @OZ30543
         BE    SKIP380              JFCB TO                    @OZ30543
         LTR   R0,R0                PDBCHAR4                         R4
         BZ    SKIP380               IF                        @OZ30543
         ST    R0,PDBCHAR4            SPECIFIED                      R4
* SET PDBCOPYG                                                       R4
SKIP380  MVC   PDBCOPYG,JFCGROUP   SET PDDB COPY GROUPS              R4
HO279    DS    0H                                                    R4
         EJECT                                                       R4
* MERGE PDBUCS AND PDBCHAR1                                          R4
         CLC   PDBUCS,=C'****'     TEST FOR UCS SPECIFIED            R4
         BNE   SKIP390             BR IF YES                         R4
         MVC   PDBUCS,PDBCHAR1     ELSE USE CHAR1 VALUS              R4
SKIP390  CLC   PDBCHAR1,=C'****'   TEST FOR CHAR1 SPECIFIED          R4
         BNE   SKIP400             BR IF YES                         R4
         MVC   PDBCHAR1,PDBUCS     ELSE USE UCS VALUE                R4
* END OF JFCB-TO-PDDB MERGE
SKIP400  OC    PDBUCS,=X'40404040' SET BINARY ZEROES TO BLANKS.
         OC    PDBCHAR1,=X'40404040' SET ZEROES TO BLANKS.     @OZ25663
         OC    PDBFCB,=X'40404040' SET BINARY ZEROES TO BLANKS.
         OI    IOTFLAG1,IOT1CKPT   FLAG IOT FOR CHECKPOINT.
         TM    PDBFLAG1,PDB1MDES   IF NOT MULTIPLE
         BZ    HO290               DESTINATIONS, SKIP.
         LA    R6,PDBLENG(,R6)     POINT TO NEXT PDDB.
         L     R0,IOTPDDBP         COMPUTE ADDRESS OF
         ALR   R0,RIOT             END OF PDDBS.
         CLR   R6,R0               IS THERE ANOTHER PDDB HERE...
         BL    HO280               BRANCH IF SO.
         L     RIOT,IOTIOT         NO.  POINT TO NEXT IOT.
         LTR   RIOT,RIOT           IS THERE ANOTHER IOT...
         BZ    HO290               BRANCH IF NOT.
         L     R6,$SVPDDB1         YES.  POINT TO                    R4
         ALR   R6,RIOT              FIRST PDDB.                      R4
HO280    DS    0H
         CH    R3,PDBDSKEY         IF DATA SET KEY DIFFERS,
         BNE   HO290               END OF MULT DEST PDDBS.
         ST    R4,PDBMTTR          SET STARTING TRACK AND
         NI    PDBFLAG1,255-PDB1NULL  RESET THE NULL FLAG.
         B     HO270               BRANCH TO SET MORE.
         EJECT                                                       R4
*
*              CHECKPOINT AND RETURN
*
HO290    DS    0H
         CALL  HCBCK               CHECKPOINT AS REQUIRED.
* RETURN TO CALLER
         B     HORET               EXIT TO CALLER.
         DROP  R6,RIOT             DROP PDDB, IOT BASES.
         SPACE 5
*
*              ADD OTHER DATA SET TYPES HERE
*
HO400    DS    0H
         $MID  352
         WTO   '&MID.OPEN FAILED BECAUSE NOT SYSIN, SYSOUT, NOR PROCESSC
               -SYSOUT',ROUTCDE=10,DESC=6
         B     HOERR
         EJECT
*
*              SUBROUTINE TO SET UP DEB AND ACB
*
HODEBACB DS    0H
* ON ENTRY, R8 POINTS TO SSDA, R10 POINTS TO SDB
* ON EXIT, R6 POINTS TO DEB, R1 POINTS TO ACB
* CALL IS BAL R14,HODEBACB
* FIELDS SET - DEBIRBAD, DEBAPPAD, ACBINRTN
         L     RDEB,SSDADEBP       POINT TO THE DEB FROM SSDA.
         USING DEBBASIC,RDEB       SET DEB ADDRESSABILITY.
         ST    RSDB,DEBIRBAD       POINT DEB TO SDB.
         ST    RDEB,SDBDEB         POINT SDB TO DEB.
         L     R0,=A(HASPAM)       GET POINTER TO HASPAM.
         ST    R0,DEBAPPAD         POINT DEB TO HASPAM.
         L     R1,DEBDCBAD         POINT TO THE ACB FROM DEB.
         LA    R1,0(,R1)           CLEAR HIGH-ORDER BYTE.
         USING IFGACB,R1           SET ACB ADDRESSABILITY.
         ST    R0,ACBINRTN         POINT ACB TO HASPAM.
         BR    R14                 RETURN.
         DROP  R1,RDEB             DROP ACB, DEB BASES.
         SPACE 3
*
*              RETURN NORMALLY TO CALLER
*
HORET    DS    0H
         SR    R15,R15             SET RETURN CODE TO ZERO.
         $EPILOG KEY=0             *** TEMPORARY ***
         SPACE 3
*
*              RETURN ABNORMALLY TO CALLER
*
HOERR    DS    0H
         LA    R15,4               NOTE- NO RET CODES ARE DEFINED.
         $EPILOG KEY=0             *** TEMPORARY ***
         DROP  RJFC,RSIB,RSDB,RSJB DROP JFCB, SSAL, SDB, SJB BASES.
         TITLE 'OPEN PROCESSING FOR OLD INPUT DATASET'
*
*
*              OPEN PROCESSING FOR ANY OLD INPUT DATASET
*
*
*        LINKAGE ---
*              CALL HOOLDINP
*
*        INPUT ---
*              RSDB POINTS TO AN SDB
*
*        FIELDS USED ---
*              SDBUBF IS SET
*              SDBPBF IS SET
*              SDBPDDB IS USED
*              SDBTRKF IS SET
*              SDBMTTR IS SET
*              SDBCCW4 IS SET
*
*        OPERATION ---
*              1. AN UNPROTECTED BUFFER IS GOTTEN AND ITS ADDRESS
*                 PLACED IN SDBUBF.
*              2. A PROTECTED BUFFER IS GOTTEN AND ITS ADDRESS
*                 PLACED IN SDBPBF.
*              3. THE TRACK ADDRESS IN THE PDDB IS MOVED TO SDBTRKF.
*
         EJECT
HOOLDINP DS    0H
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
         USING SDBDSECT,RSDB       USE THE SDB DSECT.
*
*              GET A UBF
*
         $GETBUF TYPE=UNPROT       GET A BUFFER.
         BNZ   HOOIFAIL            BRANCH IF GETMAIN FAILED.
         LR    RBUF,R1             USE BUFFER REGISTER
         USING BFD,RBUF            AND BUFFER DSECT.
         MVI   BFID,C'U'           SHOW UNPROTECTED BUFFER.
         OI    BFFL1,BF1EOB        SHOW BUFFER EMPTY.                R4
         ST    RBUF,SDBUBF         SET POINTER TO UBF IN SDB.
*
*              GET A PBF
*
         $GETBUF TYPE=PROT         GET A BUFFER.
         BNZ   HOOIFAIL            BRANCH IF GETMAIN FAILED.
         LR    RBUF,R1             USE BUFFER REGISTER.
         MVI   BFID,C'P'           SHOW PROTECTED BUFFER.
         ST    RBUF,SDBPBF         SET POINTER TO PBF IN SDB.
*
*              SET STARTING TRACK ADDRESS AND KEYS
*
         L     R2,SDBPDDB          POINT TO PDDB.
         USING PDBDSECT,R2         USE ITS DSECT.
         L     R0,PDBMTTR          GET STARTING TRACK.
         LA    R1,X'100'           SET R1 FOR LATER SRDL.
         ST    R0,SDBMTTR          SET SDBMTTR FOR CONVENIENCE.
         SRDL  R0,8                SET UP '0MTTR001'.
         STM   R0,R1,SDBTRKF       SET SDBTRKF = STARTING TRACK.
         MVC   SDBDKEY,PDBDSKEY    SET DATASET KEY IN SDB.
         TM    PDBFLAG2,PDB2NEWS   JESNEWS DATA SET...         @OZ39639
         BZ    *+10                BR IF NO                    @OZ39639
         MVC   SDBKEY,=C'$$NEWS'    ELSE USE SPECIAL KEY       @OZ39639
         LA    R0,BFIO             GET PBF READ START ADDRESS.
         ST    R0,SDBCCW4          SET IT IN CCW4.
         MVI   SDBCCW4,6           SET COMMAND TO READ.
         OI    SDBFLG1,SDB1GET     SHOW GET ALLOWED ON DATASET.
         NI    SDBFLG1,255-SDB1CLOS  RESET THE CLOSE FLAG.
         NI    SDBFLG2,255-SDB2IOE-SDB2EOD  RESET FLAGS.
         SR    R15,R15             SHOW GOOD COMPLETION.
HOOIFAIL ST    R15,16(,R13)        LABEL FOR BAD COMPLETION.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN.
         DROP  R2,RBUF,R12         DROP PDB, BF, LOCAL BASES.
         TITLE 'OPEN PROCESSING FOR NEW OUTPUT DATASET'
*
*
*              OPEN PROCESSING FOR NEW OUTPUT DATASET
*
*
*        LINKAGE ---
*              CALL HONEWOUT
*
*        INPUT ---
*              RSDB POINTS TO AN SDB
*
*        FIELDS USED ---
*              SDBUBF IS SET
*              SDBAIOT IS USED
*              SDBPDDB IS USED
*              SDBPIOT IS USED
*              SDBTRKF IS SET
*              SDBTRK IS SET
*              UBFRBA IS SET
*              PDBMTTR IS SET
*              PDB1NULL IS RESET
*              IOT1CKPT IS SET
*              UBFPDDBK IS SET
*              UBFDSKEY IS SET
*
*        OPERATION ---
*              1. AN UNPROTECTED BUFFER IS GOTTEN AND ITS ADDRESS
*                 PLACED IN SDBUBF.
*              2. AN INITIAL TRACK IS GOTTEN FROM THE IOT POINTED
*                 TO BY SDBAIOT, AND ITS MTTR IS PLACED INTO SDBTRKF,
*                 SDBTRK, UBFRBA, AND PDBMTTR.  THE PDDB KEY IS MOVED
*                 TO THE SDB AND THE UBF.  PDB1NULL IS RESET.
*                 IOT1CKPT IS SET IN THE IOT POINTED TO BY SDBPIOT.
*
         EJECT
*
*
*              SUBROUTINE TO OPEN A NEW OUTPUT DATASET
*
*
HONEWOUT DS    0H
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS.
         BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
         ST    R13,SDBSAVE+4       POINT SDB SAVEAREA TO USER'S.
         ST    RSDB,8(,R13)        POINT USER'S SAVEAREA TO SDB.
         LA    R13,SDBSAVE         SET R13 TO SDB SAVEAREA.
         $GETBUF TYPE=UNPROT       GET A BUFFER.
         BNZ   HONOFAIL            BRANCH IF GETMAIN FAILED.
         LR    RBUF,R1             USE BUFFER REGISTER,
         USING BFD,RBUF            AND SET BUFFER ADDRESSABILITY.
         MVI   BFID,C'U'           SHOW UNPROTECTED BUFFER.
         LA    R0,BFDAT            SET IN BUFFER
         ST    R0,BFLOC            POINTER TO FIRST DATA BYTE.
         LH    R0,$SVBFSIZ         SET IN                            R4
         SL    R0,=A(BFDAT+1-BFIO) BUFFER                            R4
         ST    R0,BFLEN            LENGTH OF DATA SPACE.
         ST    RBUF,SDBUBF         SET POINTER TO UBF IN SDB.
*
*              GET INITIAL TRACK FOR DATASET.
*
         L     R2,SDBPDDB          POINT TO DATA SET'S PDDB.
         USING PDBDSECT,R2         SET PDDB ADDRESSABILITY.
         L     R1,PDBMTTR          IF DS PREVIOUSLY OPENED &
         LTR   R1,R1               CLOSED WITHOUT DATA,
         BNZ   HONO010             USE ORIG. STARTING TRACK.   @OZ56167
         LA    R1,SDBTAB           POINT TO SDB'S TAB                R4
         CALL  $STRAK              GET A TRACK.
         ST    R1,PDBMTTR          SET STARTING TRACK ADDRESS.
         B     HONO020             SKIP RETAB FOR NEW TRACK.   @OZ56167
HONO010  DS    0H                                              @OZ56167
         LR    R0,R1               SET STARTING MTTR.          @OZ56167
         CALL  HJSRETAB            REBUILD TRACK ALLOC. BLK.   @OZ56167
HONO020  DS    0H
         NI    PDBFLAG1,255-PDB1NULL  SHOW PDDB NOT NULL.
         MVC   SDBDKEY,PDBDSKEY    SET DS KEY IN SDB FROM PDDB.
         TM    PDBFLAG2,PDB2NEWS   JESNEWS DATA SET...         @OZ39639
         BZ    *+10                BR IF NO                    @OZ39639
         MVC   SDBKEY,=C'$$NEWS'    ELSE USE SPECIAL KEY       @OZ39639
         MVC   BFKEY,SDBJKEY       SET JOB AND DS KEY IN BUFFER.
         L     RIOT,SDBPIOT        POINT TO PDDB'S IOT.
         USING IOTDSECT,RIOT       USE IOT DSECT.
         OI    IOTFLAG1,IOT1CKPT   SHOW IOT NEEDS A CHECKPOINT.
         LR    R0,R1               SET UP
         LA    R1,X'100'           R0 AND R1
         SRDL  R0,8                TO '0MTTR001'.
         STM   R0,R1,SDBTRKF       SET DATASET FIRST TRACK.
         STM   R0,R1,SDBTRK        SET DATASET CURRENT TRACK.
         STM   R0,R1,BFRBA         SET STARTING RBA IN BUFFER.
         OI    SDBFLG1,SDB1PUT     SHOW PUT ALLOWED ON DATASET.
         NI    SDBFLG1,255-SDB1CLOS  RESET THE CLOSE FLAG.
         MVI   SDBCCW4,5           SET WRITE-DATA COMMAND.
         SR    R15,R15             SHOW GOOD COMPLETION.
HONOFAIL DS    0H                  LABEL FOR BAD COMPLETION.
         L     R13,4(,R13)         POINT TO CALLER'S SAVEAREA.
         ST    R15,16(,R13)        SET R15 FOR RESTORE.
         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS.
         LTR   R15,R15             SET COND CODE ACCORDING TO R15.
         BR    R14                 RETURN.
         DROP  R2,RIOT,RBUF,R12    DROP PDB, IOT, BF, LOCAL BASES.
         TITLE 'OPEN PROCESSING FOR OLD OUTPUT DATASET'
*
*              OPEN PROCESSING FOR OLD OUTPUT DATASET
*
*        LINKAGE ---
*              CALL HOOLDOUT
*
*        INPUT ---
*              RSDB POINTS TO AN SDB
*
*        FIELDS USED ---
*              SDBUBF IS SET
*              SDBPDDB IS USED
*              SDBTRKF IS SET
*              SDBTRK IS SET
*              UBFRBA IS SET
*              PDBMTTR IS USED
*              UBFPDDBK IS SET
*              UBFDSKEY IS SET
*
*        OPERATION ---
*              1. AN UNPROTECTED BUFFER IS GOTTEN AND ITS ADDRESS
*                 PLACED IN SDBUBF.
*                 FIELD UBFDSKEY IS SET.
*              2. FROM THE PDDB, MTTR IS MOVED TO SDBTRKF, SDBTRK,
*                 AND UBFRBA.  PDBDSKEY IS MOVED TO UBFPDDBK AND
*                 TO SDBDKEY.
*
         EJECT
*
*              HOOLDOUT - SUBROUTINE TO OPEN AN OLD OUTPUT DATASET
*
HOOLDOUT DS    0H
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
         $GETBUF TYPE=UNPROT       GET A BUFFER.
         BNZ   HOOOFAIL            BRANCH IF GETMAIN FAILED.
         LR    RBUF,R1             USE BUFFER REGISTER AND
         USING BFD,RBUF            SET BUFFER ADDRESSABILITY.
         MVI   BFID,C'U'           SHOW UNPROTECTED BUFFER.
         LA    R0,BFDAT            SET IN BUFFER
         ST    R0,BFLOC            POINTER TO FIRST DATA BYTE.
         LH    R0,$SVBFSIZ         SET IN                            R4
         SL    R0,=A(BFDAT+1-BFIO) BUFFER                            R4
         ST    R0,BFLEN            LENGTH OF DATA SPACE.
         ST    RBUF,SDBUBF         SET POINTER TO UBF IN SDB.
         L     R2,SDBPDDB          POINT TO PDDB.
         USING PDBDSECT,R2         USE DSECT.
         OI    SDBFLG1,SDB1PUT     SHOW PUT ALLOWED.
         NI    SDBFLG1,255-SDB1CLOS  RESET THE CLOSE FLAG.
         MVC   SDBDKEY,PDBDSKEY    MOVE DATASET KEY TO SDB.
         TM    PDBFLAG2,PDB2NEWS   JESNEWS DATA SET...         @OZ39639
         BZ    *+10                BR IF NO                    @OZ39639
         MVC   SDBKEY,=C'$$NEWS'    ELSE USE SPECIAL KEY       @OZ39639
         MVC   BFKEY,SDBJKEY       SET JOB AND DS KEY IN BUFFER.
         MVI   SDBCCW4,5           SET WRITE-DATA COMMAND.
         SR    R15,R15             SHOW GOOD COMPLETION.
HOOOFAIL DS    0H
         ST    R15,16(,R13)        SET R15 FOR RESTORE.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN.
         DROP  R2,RBUF,R12         DROP BASES.
         TITLE 'FAKE OPEN SERVICE FOR CONVERTER'
*
*        ROUTINE NAME - SSVOPNC
*
*        PURPOSE - TO OPEN THE SUBSYSTEM DATA SETS REQUIRED FOR
*              THE CONVERTER.
*
*        FUNCTION -
*              1.  PROCURE AN SJB AS A BASE FOR THE DATA SETS TO
*                  BE OPENED.
*              2.  FOR EACH DATA SET TO BE OPENED, CALL HFCLSUB
*                  AND EITHER HOOLDINP OR HONEWOUT, EXCEPT -
*              3.  IF CONVERTING FOR EXECUTION BATCH MONITOR,
*                  MOVE FAKE JCL TO BUFFER INSTEAD OF CALLING
*                  HOOLDINP.
*              4.  INITIALIZE JES2 JOB LOG DATA SET WITH TITLE.
*              5.  RETURN TO CALLER.
*
*        OPERATION -
*              1.  SAVE REGISTERS AND SET PROTECT KEY TO ZERO.
*                  SET R11 TO POINT TO SSVT.  PRESERVE SAVE AREA
*                  POINTER IN R5.
*              2.  IF NO SJB HAS BEEN GOT FOR CONVERTER
*                  (JPCESJBP=0), CALL $SJBINIT TO CREATE ONE.
*                  IF FAILURE, TAKE ERROR EXIT.
*                  SET FLAG SJB2CONV TO INDICATE CONVERTER SJB.
*                  STORE PCE POINTER IN SJBSSIB.
*                  STORE SJB POINTER IN JPCESJBP.
*              3.  MOVE JOB KEY, JOB ID, JOB NAME, ESTIMATED
*                  PRINT LINES, AND ESTIMATED PUNCH CARDS TO THE
*                  SJB FROM THE JCT.
*              4.  DOUBLE-CHAIN THE SJB SAVE AREA AND THE
*                  CALLER'S SAVE AREA.  POINT THE SAVE AREA
*                  REGISTER, R13, TO THE SJB.
*              5.  FOR THE JCL DATA SET, CALL HFOPSUB TO CON-
*                  STRUCT AN SDB AND SET POINTERS IN THE ACB AND
*                  DEB.  THIS DATA SET'S ACB IS AT SYMBOL
*                  JPCEJCL.
*              6.  THE JCL DATA SET IS CONSTRUCTED HERE IF THIS
*                  ROUTINE IS OPENING DATA SETS FOR BATCH MONITOR
*                  CONVERSION (JPCEXBNM IS THE BATCH MONITOR
*                  PROCEDURE NAME).  GET AND FORMAT AN UNPROTEC-
*                  TED BUFFER, SAVING ITS ADDRESS IN SDBUBF.
*                  SET FLAG SDB2EOD TO PREVENT HAM ROUTINE HAMGET
*                  FROM INVOKING SVCGET FOR I/O.  SET FLAG
*                  SDB1GET TO SHOW INPUT DATA SET.  MOVE FAKE
*                  JOB, EXEC, AND DD CARDS TO THE BUFFER AND SET
*                  THE CONTENTS OF JPCEXBNM AS JOB NAME AND
*                  PROCEDURE NAME.
*              7.  THE JCL DATA SET IS OPENED AND PRIMED IF
*                  JPCEXBNM IS ZERO.  POINT SDBPDDB TO THE JCL
*                  DATA SET'S PDDB AND CALL HOOLDINP.  TO PRIME,
*                  CALL HCNVFDAD TO CONVERT JES2 TRACK ADDRESS TO
*                  OS TRACK ADDRESS, ISSUE EXCP, AND WAIT.
*              8.  FOR THE JCL IMAGES DATA SET, CALL HFOPSUB.
*                  THE ACB IS AT JPCEJCLI.
*              9.  POINT SDBPDDB TO THE JCL IMAGES PDDB AND CALL
*                  HONEWOUT TO OPEN THE DATA SET.  SET FLAG
*                  SDB1OUT TO SHOW DATA SET IS PRINTABLE.
*              10. FOR THE JES2 JOB LOG DATA SET, CALL HFOPSUB.
*                  THE ACB IS AT SJBLACB.  THIS DATA SET IS NOT
*                  REQUIRED BY THE CONVERTER INTERFACE.
*              11. POINT SDBPDDB TO THIS DATA SET'S PDDB AND CALL
*                  HONEWOUT.  SET FLAG SDB1OUT TO SHOW DATA SET
*                  IS PRINTABLE.  MOVE TITLE TEXT TO DATA SET'S
*                  UNPROTECTED BUFFER AND ADJUST BUFFER POSITION
*                  AND REMAINING LENGTH.
*              12. FOR THE INTERNAL TEXT DATA SET, CALL HFOPSUB.
*                  THE ACB IS AT JPCETXT.
*              13. POINT SDBPDDB TO THIS DATA SET'S PDDB AND CALL
*                  HONEWOUT.
*              14. SET PROTECT KEY BACK TO 'HASP', RESTORE
*                  REGISTERS, AND RETURN TO CALLER WITH CONDITION
*                  CODE ZERO.
*              15. ERROR EXIT - FOR EACH SDB CHAINED FROM CHAIN
*                  WORD SJBSDB, CALL $SDBFREE.  THEN RETURN TO
*                  CALLER WITH CONDITION CODE NONZERO.
*
*        ENTRY -
*              WORD $SVCOPN IN THE SUBSYSTEM VECTOR TABLE POINTS
*                  TO SSVOPNC.
*
*        REGISTERS AT ENTRY -
*              R5  = SUBSYSTEM VECTOR TABLE
*              R8  = CONVERTER PROCESSOR CONTROL ELEMENT
*              R13 = USER-SUPPLIED STANDARD SAVE AREA
*              R14 = RETURN ADDRESS
*              R15 = ENTRY ADDRESS
*
*        REGISTERS USED IN ADDITION TO ABOVE -
*              R0  = WORK, ARGUMENT TO $SJBINIT
*              R1  = WORK, ARGUMENT TO HGFMAIN
*              R2  = WORK FOR HGFMAIN
*              R3  = CURRENT ACB
*              R4  = LINKAGE TO HGFMAIN
*              R5  = CURRENT IOT, FROM JPCEIOT
*              R7  = WORK FOR HGFMAIN
*              R10 = CURRENT SUBSYSTEM DATASET BLOCK
*              R11 = SUBSYSTEM VECTOR TABLE
*              R12 = LOCAL BASE
*              R13 = SUBSYSTEM JOB BLOCK, FROM JPCESJBP
*              R14 = LINK REGISTER FOR CALLS
*              R15 = ENTRY REGISTER FOR CALLS
*
*        REGISTERS CHANGED AT EXIT -
*              R15 CONTAINS RETURN CODE -
*                  0 - SUCCESSFUL COMPLETION
*                  4 - UNABLE TO OPEN ALL DATA SETS
*                  8 - UNABLE TO INITIALIZE SJB
*
*        CONDITION CODE AT EXIT -
*              0 - REGISTER 15 IS ZERO
*              2 - REGISTER 15 IS FOUR OR EIGHT
*
SSVOPNC  DS    0H
         USING *,R15               ESTABLISH ADDRESSABILITY.
         STM   R14,R12,12(R13)     SAVE USER'S REGISTERS.
         MODESET EXTKEY=ZERO       SET KEY ZERO FOR FAKE OPEN.
         USING PCEDSECT,R8         USE PCE DSECT.
         LR    RSVT,R5             HOSCNVT PASSES SSVT IN R5.
         LR    R5,R13              SAVE USER SAVE AREA POINTER.
         ICM   RSJB,15,JPCESJBP    POINT TO CONVERTER SJB.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         BNZ   SOC10               BRANCH IF IT EXISTS.
         LA    R0,24(,R13)         MAKE SAVE AREA A FAKE SSCVT.
         CALL  $SJBINIT            ELSE GO BUILD ONE.
         BALR  R14,0               SET BASE REGISTER
         USING *,R14               PROVIDE TEMPORARY ADDRESSABILITY
         BNZ   SOC820              BRANCH IF SJB NOT BUILT.
         OI    SJBFLG2,SJB2CONV    SHOW CONVERTER SJB.
         ST    RSJB,JPCESJBP       STORE SJB POINTER IN PCE.
         ST    R8,SJBSSIB          POINT SJB TO CONVERTER PCE.
SOC10    BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
         L     R7,PCEJCT           GET JCT ADDRESS FROM PCE.
         ST    R7,SJBJCT           SET JCT POINTER INTO SJB    @OZ26284
         USING JCTDSECT,R7         SET JCT ADDRESSABILITY.
         MVC   SJBJKEY,JCTJBKEY    SET JOB KEY FROM JCT.
         MVC   SJBJOBID,JCTJOBID   SET CONVERTER JOB ID.
         MVC   SJBJOBNM,JCTJNAME   SET CONVERTER JOB NAME.
         MVC   SJBESTLN,JCTESTLN   SET PRINT AND PUNCH
         MVC   SJBESTPU,JCTESTPU   EXCESSION LIMITS.
         ST    RSJB,8(,R5)         CHAIN
         ST    R5,SJBSAVE+4        SAVEAREAS.
         USING IOTDSECT,RIOT       USE THE IOT DSECT.
*
*              OPEN THE JCL DATASET
*
         LA    R3,JPCEJCL          POINT TO ACB.
         L     RIOT,JPCEIOT        POINT TO THE 1ST IOT.
         ST    RIOT,SJBIOT         SAVE ADDRESS IN SJB.
         CALL  HFOPSUB             SET SDB, ACB, DEB.
         BNZ   SSVOFAIL            BRANCH IF HFOPSUB FAILED.
*
*              CREATE BATCH MONITOR JCL IF REQUIRED
*
         LM    R0,R1,JPCEXBNM      GET BATCH MONITOR JOBNAME.
         ALR   R0,R1               IF ZERO,
         BZ    SOC20               OPEN JCL DATA SET.
         $GETBUF TYPE=UNPROT       GET AN UNPROTECTED BUFFER.
         BNZ   SSVOFAIL            ERROR IF NONE AVAILABLE.
         L     R7,PCEJCT           RESTORE JCT ADDRESS IN R7.
         ST    R1,SDBUBF           SAVE UBF ADDRESS IN SDB.
         LR    RBUF,R1             SET UBF REGISTER.
         USING BFD,RBUF            SET UBF ADDRESSABILITY.
         MVI   BFID,C'U'           SET UBF IDENTIFIER.
         OI    SDBFLG2,SDB2EOD     SHOW NO MORE DATA.
         OI    SDBFLG1,SDB1GET     SHOW INPUT DATA SET.
         MVC   BFDAT(L'SOCJCL),SOCJCL  MOVE FAKE JCL TO BUFFER.
         LA    R2,BFDAT            SET ADDRESS OF START
         ST    R2,BFLOC            OF DATA IN BUFFER.
         LM    R0,R1,JPCEXBNM      GET BATCH MONITOR JOB NAME.
         STM   R0,R1,SOCJNM(R2)    SET IT AS JOB NAME.
         STM   R0,R1,SOCPNM(R2)    SET IT AS PROCEDURE NAME.
         B     SOC30               CONTINUE BY OPENING JCLI.
         DROP  RBUF                DROP BUFFER ADDRESSABILITY.
*
*              IF NOT BATCH MONITOR, OPEN JCL DATA SET
*
SOC20    DS    0H
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOJ(RIOT,R15)  JCL PDDB                       R4
         ST    R0,SDBPDDB          SET POINTER IN SDB.
         CALL  HOOLDINP            OPEN OLD INPUT DATASET.
         BNZ   SSVOFAIL            BRANCH IF HOOLDINP FAILED.
         CALL  HCNVFDAD            CONVERT SDBMTTR TO FDAD
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         EXCP  SDBIOB              AND DO INITIAL READ.
         WAIT  1,ECB=SDBECB        WAIT FOR I/O TO END.
SOC30    DS    0H
*
*              OPEN THE JCLI DATASET
*
         LA    R3,JPCEJCLI         POINT TO ACB.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOI(RIOT,R15)  JCL IMAGES PDDB                R4
         CALL  HFOPSUB             SET SDB, ACB, DEB.
         BNZ   SSVOFAIL            BRANCH IF HFOPSUB FAILED.
         CALL  HONEWOUT            OPEN NEW OUTPUT DATASET.
         BNZ   SSVOFAIL            BRANCH IF HONEWOUT FAILED.
         OI    SDBFLG1,SDB1OUT     SHOW DATA SET SYSOUT.
*
*              OPEN THE SYSTEM MESSAGES DATASET
*
         LA    R3,JPCEMSG          POINT TO ACB.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOM(RIOT,R15)  SYSTEM MESSAGES PDDB           R4
         CALL  HFOPSUB             SET SDB, ACB, DEB.
         BNZ   SSVOFAIL            BRANCH IF HFOPSUB FAILED.
         CALL  HONEWOUT            OPEN NEW OUTPUT DATASET.
         BNZ   SSVOFAIL            BRANCH IF HONEWOUT FAILED.
         OI    SDBFLG1,SDB1OUT     SHOW DATA SET SYSOUT.
*
*              OPEN THE HASP JOB LOG DATASET
*
         LA    R3,SJBLACB          POINT TO ACB.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOL(RIOT,R15)  HASP JOB LOG PDDB              R4
         CALL  HFOPSUB             SET SDB, ACB, DEB.
         BNZ   SSVOFAIL            BRANCH IF HFOPSUB FAILED.
         CALL  HONEWOUT            OPEN NEW OUTPUT DATASET.
         BNZ   SSVOFAIL            BRANCH IF HONEWOUT FAILED.
         OI    SDBFLG1,SDB1OUT     SHOW DATA SET SYSOUT.
         L     R3,SDBUBF           POINT TO UNPROTECTED BUFFER.
         USING BFD,R3              SET BUFFER ADDRESSABILITY.
         L     R1,BFLOC            GET PLACE TO PUT JOB LOG HEADER.  R4
         MVC   0(HJLHDL,R1),HJLHDR MOVE 'H A S P   J O B   L O G'.
         LA    R1,HJLHDL(,R1)      UPDATE BUFFER POSITION
         ST    R1,BFLOC            AND SET NEW POSITION.             R4
         LH    R1,$SVBFSIZ              UPDATE LENGTH                R4
         SL    R1,=A(BFDAT-BFIO-HJLHDL)  REMAINING                   R4
         ST    R1,BFLEN                   IN UBF.                    R4
         L     R1,BFRCT            GET BUFFER COUNT            @OZ17756
         LA    R1,1(,R1)           UPDATE                      @OZ17756
         ST    R1,BFRCT             COUNT                      @OZ17756
         DROP  R3                  DROP BUFFER ADDRESSABILITY.
*
*              OPEN THE INTERNAL TEXT DATASET
*
         LA    R3,JPCETXT          POINT TO ACB.
         L     R15,$SVPDDB1          POINT TO                        R4
         LA    R0,IOTPDBOT(RIOT,R15)  INTERNAL TEXT PDDB             R4
         CALL  HFOPSUB             SET SDB, ACB, DEB.
         BNZ   SSVOFAIL            BRANCH IF HFOPSUB FAILED.
         CALL  HONEWOUT            OPEN NEW OUTPUT DATASET.
         BNZ   SSVOFAIL            BRANCH IF HONEWOUT FAILED.
*
*              RETURN TO CALLER
*
         MODESET EXTKEY=HASP       SET HASP KEY BEFORE RETURN.
         L     R13,SJBSAVE+4       POINT TO USER SAVEAREA.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         SR    R15,R15             SHOW CALLER GOOD COMPLETION.
         BR    R14                 RETURN.
         SPACE 3
HJLHDR   DS    0H                  JES2 JOB LOG HEADER
         DC    AL1(0)              ZERO TEXT LENGTH
         DC    AL1(LRC1CCTL+LRC1TMCH)  MACHINE CARRIAGE CONTROL
         DC    AL1(0)              ZERO LRECL
         DC    X'8B'               IMMED SKIP TO CHANNEL 1
HJLT     EQU   *                   TITLE START
         DC    AL1(HJLTL-(LRCSOUT-LRCDSECT))  TEXT LENGTH
         DC    AL1(LRC1CCTL+LRC1TMCH)  MACHINE CARRIAGE CONTROL
         DC    AL1(HJLTL-(LRCSOUT-LRCDSECT))  LRECL
         DC    X'19'               PRINT AND SPACE 3
         DC    CL48' '             CENTER ON 120 WIDTH
         DC    C'J E S 2   J O B   L O G'
HJLTL    EQU   *-HJLT              TITLE LENGTH
HJLHDL   EQU   *-HJLHDR            HEADER LENGTH
         SPACE 3
*
*              RETURN IF CONVERTER OPENS FAILED
*
SOC800   DS    0H                  ERROR CODE 4
SSVOFAIL EQU   SOC800              EQUATE TO OLD LABEL.
         L     RSDB,SJBSDB         POINT TO AN SDB.
         LTR   RSDB,RSDB           IF NO MORE,
         BZ    SOC810              RETURN.
         CALL  $SDBFREE            DECHAIN & FREE BUFS & SDB.
         B     SOC800              TRY FOR ANOTHER SDB.
SOC810   L     R13,4(,R13)         POINT TO CALLER'S SAVE AREA.
         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS.
         LA    R15,4               SET ERROR CODE 4.
         LTR   R15,R15             SET CONDITION CODE 2.
         BR    R14                 RETURN TO CALLER.
         SPACE 3
SOC820   DS    0H                  ERROR CODE 8
         LM    R14,R12,12(R13)     RESTORE CALLER'S REGISTERS.
         LA    R15,8               SET ERROR CODE 8.
         LTR   R15,R15             SET CONDITION CODE 2.
         BR    R14                 RETURN TO CALLER.
         SPACE 3
         DROP  RIOT,R7,R8,R12,R14,R15  DROP BASES.
         SPACE 3
*
*              JCL TO USE WITH BATCH MONITOR
*
*//JPCEXBNM JOB 1,SYS,MSGLEVEL=1
*//FAKE EXEC JPCEXBNM
*//GO.SYSIN DD *
*
* JCL STARTS ---
SOCXBJCL EQU   *
* JOB CARD ---
SOCJ1    DC    AL1(L'SOCJ1A,0,80)
SOCJ1A   DC    C'//******** JOB 1,SYS,MSGLEVEL=1'
* EXECUTE CARD ---
SOCJ2    DC    AL1(L'SOCJ2A,0,80)
SOCJ2A   DC    C'//FAKE EXEC ********'
* SYSIN DD CARD ---
SOCJ3    DC    AL1(L'SOCJ3A,0,80)
SOCJ3A   DC    C'//GO.SYSIN DD *'
* END-OF-BUFFER MARKER ---
SOCJ4    DC    AL1(LRCBFEND)
* EQUATES FOR USE IN EXECUTABLE CODE ---
SOCJCL   EQU   SOCXBJCL,*-SOCXBJCL JCL TO MOVE TO BUFFER
SOCJNM   EQU   SOCJ1A+2-SOCJCL,8   JOB NAME
SOCPNM   EQU   SOCJ2A+12-SOCJCL,8  PROCEDURE NAME
         TITLE 'FAKE OPEN SUBROUTINE'
***********************************************************************
*                                                                     *
*        HFOPSUB -- ACB 'FAKE OPEN' SUBROUTINE -- OBTAIN SDB          *
*                                                                     *
* INPUT  R0    - PDDB ADDRESS                                         *
*        R3    - ACB ADDRESS                                          *
*        RIOT  - IOT ADDRESS                                          *
*        RSJB  - SJB ADDRESS                                          *
*        R14   - RETURN ADDRESS                                       *
*        R15   - ENTRY POINT ADDRESS                                  *
*                                                                     *
* OUTPUT R1    - PDDB ADDRESS                                         *
*        R3    - DEB ADDRESS                                          *
*        RSDB  - SDB ADDRESS                                          *
*                                                                     *
*        CC    -     ZERO = NORMAL COMPLETION                         *
*              - NON-ZERO = ABNORMAL COMPLETION                       *
*                           GETMAIN FAILED FOR SDB                    *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
         USING HFOPSUB,R15         PROVIDE LOCAL ADDRESSABILITY      R4
         USING IFGACB,R3           PROVIDE ACB ADDRESSABILITY        R4
         SPACE 1                                                     R4
         CNOP  0,8                                                   R4
HFOPSUB  DS    0H                                                    R4
         LR    R1,R14              SAVE RETURN ADDRESS.
         CALL  $SDBINIT            CREATE AN SDB.
         BNZR  R1                  RETURN IF SDB NOT BUILT.
         LR    R14,R1              RESTORE RETURN ADDRESS.
         SPACE 1                                                     R4
         BALR  R15,0               RE-ESTABLISH LOCAL                R4
         USING *,R15                ADDRESSABILITY                   R4
         SPACE 1                                                     R4
         OI    ACBOFLGS,ACBOPEN    SHOW THAT ACB IS OPEN.
         MVC   ACBINRTN,=A(HASPAM) POINT ACB TO HASP ACCESS METHOD.
         L     R3,ACBDEB-1         POINT TO DATA SET'S DEB.
         ST    R3,SDBDEB           SET DEB POINTER IN SDB.
         USING DEBBASIC,R3         USE THE DEB DSECT.
         ST    RSDB,DEBIRBAD       POINT THE DEB TO THE SDB.
         MVC   DEBAPPAD,=A(HASPAM) POINT THE DEB TO HASP ACCESS METHOD.
         ST    RIOT,SDBAIOT        POINT SDB TO ALLOCATION IOT
         ST    RIOT,SDBPIOT        AND TO IOT CONTAINING PDDB.
         OI    SDBFLG1,SDB1FOPN    SHOW DATA SET FAKE-OPENED.
         SPACE 1                                                     R4
         LTR   R1,R0               PICK-UP PDDB ADDRESS              R4
         BZ    HFOPEXIT             AND RETURN IF ZERO               R4
         ST    R1,SDBPDDB          SAVE PDDB ADDRESS IN SDB          R4
         TM    PDBFLAG2-PDBDSECT(R1),PDB2TCEL    SET MAJOR TAB FLAG  R4
         BZ    HFOPEXIT                           IN SDB IF PDDB     R4
         OI    SDBTAB+(TABFLAG-TABDSECT),TABMAJOR  IS TRACK-CELLED   R4
         SPACE 1                                                     R4
HFOPEXIT DS    0H                                                    R4
         SR    R15,R15             SHOW GOOD COMPLETION
         BR    R14                 RETURN TO CALLER.
         SPACE 1                                                     R4
         DROP  ,                   SUSPEND ALL ADDRESSABILITY        R4
         SPACE 2                                                     R4
         LTORG ,                                                     R4
         TITLE 'HOCSETUP - OPEN && CLOSE SETUP SUBROUTINE'
*
*              HOCSETUP - OPEN & CLOSE SETUP SUBROUTINE
*
*        REGISTERS ON ENTRY - AS SET BY $PROLOG
*
*        REGISTERS ON EXIT -
*              R6  - DEB POINTER
*              R7  - JFCB POINTER
*              R8  - SSDA POINTER
*              R10 - SDB/DCT POINTER
*              R0-R5,R15 - UNPREDICTABLE                            R41
*              R11-R14 - UNCHANGED                                  R41
*
*        EXIT OFFSETS -
*              +0  - VALID INTERNAL READER
*              +4  - VALID SYSIN DATA SET
*              +8  - VALID SYSOUT DATA SET
*              +12 - VALID PROCESS-SYSOUT DATA SET
*              +16 - VALID UNKNOWN-TYPE DATA SET
*              +20 - ERROR IN VALIDATION
*
HOCSETUP DS    0H
         USING *,R5                ESTABLISH                        R41
         LR    R5,R15                LOCAL ADDRESSABILITY           R41
         LR    RSIB,RSOX           POINT R8 TO SSDA.
         USING SSDABGN,RSIB        SET SSDA ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         L     RJFC,SSDAJFCB       POINT TO JFCB FROM SSDA.
         USING INFMJFCB,RJFC       SET JFCB ADDRESSABILITY.
         L     RDEB,SSDADEBP       POINT TO DEB FROM SSDA.
         USING DEBBASIC,RDEB       SET DEB ADDRESSABILITY.
         L     RSDB,SSDASSCM       POINT TO SDB/DCT FROM SSDA.
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
*
*              VERIFY SJB PRESENT IF REQUIRED
*
         LTR   RSDB,RSDB           IF NO SDB/DCT PRESENT,
         BZ    HOCS60              PROCESS SPECIAL INTRDR.
         LTR   R12,R12             OTHERWISE IF SJB NOT PRESENT,
         BNM   20(,R14)            RETURN +20 - ERROR.
*
*              TEST FOR SUBSYSTEM DATASET BLOCK
*
         CLC   SDBID,=CL4'SDB'     IF SDB ID NOT PRESENT,
         BNE   HOCS40              GO TEST FOR INTRDR ID.
*
*              SDB - IF CLOSE, RESTORE I/O
*
         CLI   SJBXQFN1+1,SSOBCLOS SKIP IF
         BNE   HOCS10              FUNCTION ISN'T CLOSE.
         TM    SDBFLG2,SDB2IOA     IF FLAG SHOWS THAT
         BZ    HOCS10              I/O IS ACTIVE
         CLI   SDBICMP,X'48'       YET IOB COMPLETION CODE
         BNE   HOCS10              SHOWS PURGED,
         MVI   SDBECB,0            CLEAR ECB
         LR    R4,R14              SAVE RETURN REG ACROSS EXCP      R41
         EXCP  SDBIOB              AND RE-EXCP.
         LR    R14,R4              RESTORE RETURN REGISTER          R41
HOCS10   DS    0H
*
*                  TEST FOR SYSOUT
*
         CLI   DSNDSTYP,C'S'       BRANCH IF NEITHER
         BNE   HOCS20              SYSIN NOR SYSOUT.
         CLI   DSNDSTYP+1,C'O'     IF DSTYP IS 'SO',
         BE    8(,R14)             RETURN +8 - SYSOUT.
*
*                  TEST FOR SYSIN
*
         CLI   DSNDSTYP+1,C'I'     IF DSTYP IS 'SI',
         BE    4(,R14)             RETURN +4 - SYSIN.
*
*                  TEST FOR PROCESS-SYSOUT
*
HOCS20   DS    0H
         CLC   DSNDSTYP,=C'PS'     IF DSTYP IS 'PS',
         BE    12(,R14)            RETURN +12 - PSO.
         B     16(,R14)            ELSE RETURN +16 - UNKNOWN.
*
*              TEST FOR NORMAL INTERNAL READER
*
HOCS40   DS    0H
         USING DCTDSECT,RSDB       SET DCT ADDRESSABILITY.
         CLC   =C'INTRDR',DCTDEVN  IF ID IS 'INTRDR',
         BER   R14                 RETURN +0 - INTRDR.
         B     20(,R14)            ELSE RETURN +20 - ERROR.
*
*              TEST FOR SPECIAL INTERNAL READER
*
HOCS60   DS    0H
         CLC   =C'.MSTR    .MS0000.',DSNSSNM+4  IF NOT SPECIAL,
         BNE   20(,R14)            RETURN +20 - ERROR.
         L     RSDB,$SVIRDRS       POINT TO STCINRDR.
         CLC   DSNDDNM,DCTDEVN     IF IT MATCHES DDNAME,
         BER   R14                 RETURN +0 - INTRDR.
         L     RSDB,DCTCHAIN       POINT TO TSOINRDR.
         CLC   DSNDDNM,DCTDEVN     IF IT MATCHES DDNAME,
         BER   R14                 RETURN +0 - INTRDR.
         B     20(,R14)            ELSE RETURN +20 - ERROR.
         SPACE 3
         DROP  ,                   DROP ALL ADDRESSABILITY.
         TITLE 'HASP SUBSYSTEM SUPPORT ROUTINE -- CLOSE'
*
*
*              HASP SUBSYSTEM SUPPORT ROUTINE -- CLOSE
*
*
HOSCLOS  $PROLOG SSOBCLOS,SSDASIZE,LOCK=SDB  CLOSE
         SPACE 1
HOSCLOSB DS    0H                  CLOSE BASE ADDRESS.
*
*              USE SUBROUTINE TO SET UP REGISTERS
*              AND TO DETERMINE TYPE OF CLOSE
*
         CALL  HOCSETUP            CALL SUBROUTINE
         USING DEBBASIC,RDEB       SET DEB ADDRESSABILITY.
         USING INFMJFCB,RJFC       SET JFCB ADDRESSABILITY.
         USING SSDABGN,RSIB        SET SSDA ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.
         B     HC000               INTERNAL READER
         B     HC100               SUBSYSTEM DATA SET - SI
         B     HC200               SUBSYSTEM DATA SET - SO
         B     HC300               SUBSYSTEM DATA SET - PS
         B     HC400               SUBSYSTEM DATA SET - INVALID
         B     HCERR               ERROR DETECTING TYPE
         EJECT
*
*              C L O S E   I N T E R N A L   R E A D E R
*
HC000    DS    0H
         USING DCTDSECT,RSDB       SET DCT ADDRESSABILITY.
         LM    R2,R3,HCIEOF        GET POINTERS TO /*EOF RECORD.
         L     R1,PSATOLD-PSA      POINT TO CURRENT TCB.
         USING TCB,R1              SET TCB ADDRESSABILITY.
         TM    TCBFBYT1,TCBRTM2    SET CC=3 IF TASK ABENDING.
         DROP  R1                  DROP TCB ADDRESSABILITY.
         BZ    *+8                 IF TASK IS ABENDING,
         LM    R2,R3,HCIDEL        GET POINTERS TO /*DEL RECORD.
         L     RACB,DEBDCBAD       POINT TO THE ACB.
         LA    RACB,0(,RACB)       BE SURE HIGH BIT IS OFF.
         AL    R12,=A(HAMBASE-HOSCLOSB)  ADJUST R12 FOR BAL.
         USING HAMBASE,R12         TELL ASSEMBLER ABOUT IT.
         BAL   R14,HINTRDR         CALL INTRDR SUBROUTINE.
         BALR  R15,0               TO RESTORE BASE, ESTABLISH
         USING *,R15               TEMPORARY ADDRESSABILITY.
         SL    R12,=A(HAMBASE-HOSCLOSB)  RE-ADJUST R12.
         DROP  R15                 DROP TEMPORARY BASE.
         USING HOSCLOSB,R12        TELL ASSEMBLER ABOUT IT.
         CLI   RIDJOBID,C'J'       IF USER INTRDR              @OZ29612
         BE    HCRET               MERELY RETURN               @OZ29612
         SLR   R1,R1               ZERO THE ASCB POINTER       @OZ29612
         ST    R1,RIDASCBP         FOR STC AND TSU             @OZ29612
         B     HCRET               RETURN FROM CLOSE.
         DROP  RDEB                DROP DEB ADDRESSABILITY.
         DS    0F
HCIEOF   DC    AL1(RIDCLS),AL3(HCIEOFC),A(5)  /*EOF POINTERS
HCIDEL   DC    AL1(RIDCLS),AL3(HCIDELC),A(5)  /*DEL POINTERS
HCIEOFC  DC    C'/*EOF'            /*EOF TEXT
HCIDELC  DC    C'/*DEL'            /*DEL TEXT
         EJECT
*
*              C L O S E   S Y S I N   D A T A   S E T
*
HC100    DS    0H
*
*              C L O S E   P R O C E S S - S Y S O U T
*
HC300    DS    0H
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         TM    SJBFLG1,SJB1XBM+SJB1XBWT  IF EXEC BATCH MONITOR,
         BM    HCRET               NEVER FREE BUFFERS.
         L     R1,SDBECB           LOAD ECB                         R41
HC305    LR    R2,R1               RELOAD ECB                       R41
         LR    R2,R1               RELOAD ECB                       R41
         N     R2,=XL4'7F000000'   RESET WAIT BIT                   R41
         CS    R1,R2,SDBECB        REPLACE ECB                      R41
         BNE   HC305               TRY AGAIN IF UNSUCCESSFUL        R41
         WAIT  1,ECB=SDBECB        BE SURE I/O IS COMPLETE.
         L     RBUF,SDBPBF         FREE ALL
         BAL   R5,HCFREBP          PROTECTED BUFFERS.
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         MVC   SDBTRK+5(3),BFRBA+5-BFD(RBUF)  SAVE REC NUMBER.
         BAL   R5,HCFREBU          FREE THE BUFFER.
         L     RBUF,SDBHBF         FREE ALL
HC307    DS    0H                                              @OZ41634
         BAL   R5,HCFREBU          UPDATE-HOLD BUFFERS.
         LTR   RBUF,RBUF           END OF HBUF CHAIN ?         @OZ41634
         BNZ   HC307               NO, LOOP BACK               @OZ41634
         SLR   R0,R0               ZERO POINTERS TO
         ST    R0,SDBPBF           PROTECTED,
         ST    R0,SDBUBF           UNPROTECTED, AND
         ST    R0,SDBHBF           HOLD BUFFERS.
         B     HC900               GO CONCLUDE CLOSE.
         EJECT
*
*              C L O S E   S Y S O U T   D A T A   S E T
*
HC200    DS    0H
*
*              1. TRUNCATE AND WRITE BUFFER FOR CLOSE
*
         CLI   SDBCCW3+7,0         DATA SET ALREADY CLOSED...  @G38ESBB
         BE    HCRET               YES, GO RETURN NORMALLY     @G38ESBB
         TM    SJBFLG1,SJB1XBM+SJB1XBWT  IF XBM HAS NO JOB,
         BO    HC210               JUST FREE BUFFERS.
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         USING BFD,RBUF            USE BUFFER DSECT.
         L     R1,BFLOC            GET SPOT FOR NEXT RECORD.
         CLI   SDBCCW3+7,1         DON'T TEST FOR A NULL DS
         BH    HC205               IF TWO OR MORE OPENS.
         LA    R0,BFDAT            IF SOME DATA IN BUFFER,
         CLR   R0,R1               NOT AN EMPTY DATA SET -
         BNE   HC205               PROCEED NORMALLY.
         CLC   SDBTRK,SDBTRKF      IF NOT ORIGINAL TRACK,
         BNE   HC205               PROCEED NORMALLY.
         L     R2,SDBPDDB          NULL DATA SET ---
         OI    PDBFLAG1-PDBDSECT(R2),PDB1NULL  SHOW DS NULL.
         L     R1,SDBPIOT          REWRITE
         L     R0,IOTTRACK-IOTDSECT(,R1)  THE
         NI    IOTFLAG1-IOTDSECT(R1),255-IOT1CKPT  DATASET'S
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT WRITE IN SJB   @OZ78293
         CALL  HCBWR               IOT.
         MVI   SDBCCW3+7,0         ZERO THE OPEN COUNT.
         B     HC210               THEN JUST FREE BUFFERS.
         USING LRCDSECT,R1         NOT NULL.  SET LRC BASE.
HC205    LA    R5,BFIO             GET ADDR OF                 @OZ29839
         AH    R5,$SVBFSIZ           END OF BUFFER.            @OZ29839
         CR    R5,R1               COMPARE BFLOC TO END.       @OZ29839
         BNH   HCERR               ERROR IF BFLOC TOO BIG.     @OZ29839
         CR    RBUF,R1             COMPARE BFLOC TO START.     @OZ29839
         BNL   HCERR               ERROR IF BFLOC TOO SMALL.   @OZ29839
         MVI   LRCTLENG,LRCBFEND   SET END OF BUFFER.          @OZ29839
         L     R2,SSDADEBP         POINT TO THE DEB.
         USING DEBBASIC,R2         AND USE ITS DSECT.
         LA    R0,BFDAT            GET START OF DATA ADDRESS   @OZ30041
         CR    R0,R1               IF NULL BUFFER,             @OZ30041
         BE    HC206                 SKIP FIRST WRITE          @OZ30041
         L     R1,DEBDCBAD         POINT TO THE ACB.
         LA    R1,0(,R1)           ZERO HIGH-ORDER BYTE.
         LNR   R1,R1               SHOW SVC ARG IS ACB.
         LA    R0,HSVCEOBP         SET PUT-END-OF-BLOCK CODE
         SVC   HAMSVC              AND CALL HAMSVC.
         L     R1,SDBECB           RESET THE WAIT BIT          @OZ39533
HC205A   LR    R15,R1               AND WAIT HERE FOR THE      @OZ39533
         N     R15,=XL4'7F000000'    CEA REDRIVE LOOP          @OZ39533
         CS    R1,R15,SDBECB          TO STOP, OR CEA MAY      @OZ39533
         BNE   HC205A                  NOT WRITE THE LAST      @OZ39533
         WAIT  1,ECB=SDBECB             BUFFER                 @OZ39533
         L     R1,BFLOC            GET SPOT FOR NEXT RECORD.
         CR    R5,R1               COMPARE BFLOC TO END.       @OZ29839
         BNH   HCERR               ERROR IF BUFLOC TOO LARGE.  @OZ29839
         CR    RBUF,R1             COMPARE BFLOC TO START.     @OZ29839
         BNL   HCERR               ERROR IF BFLOC TOO SMALL.   @OZ29839
         MVI   LRCTLENG,LRCBFEND   TRUNCATE THE BUFFER.
HC206    DS    0H                                              @OZ30041
         OI    SDBFLG1,SDB1CLOS    SHOW HAMSVC WE'RE CLOSING.
         L     R1,DEBDCBAD         POINT TO THE ACB.
         LA    R1,0(,R1)           ZERO HIGH-ORDER BYTE.
         LNR   R1,R1               SHOW SVC ARG IS ACB.
         LA    R0,HSVCEOBP         SET PUT-END-OF-BLOCK CODE
         SVC   HAMSVC              AND CALL HAMSVC.
         NI    SDBFLG1,255-SDB1CLOS  RESET THE CLOSE FLAG.
         DROP  R1,R2               DROP LRC, DEB BASES.
*
*              2. WAIT TILL ALL BUFFERS ARE WRITTEN
*
HC208    DS    0H                                                    R4
         L     R1,SDBECB           LOAD ECB                         R41
HC218    LR    R2,R1               RELOAD ECB                       R41
         LR    R2,R1               RELOAD ECB                       R41
         N     R2,=XL4'7F000000'   RESET WAIT BIT                   R41
         CS    R1,R2,SDBECB        REPLACE ECB                      R41
         BNE   HC218               TRY AGAIN IF UNSUCCESSFUL        R41
         WAIT  1,ECB=SDBECB        WAIT FOR I/O TO COMPLETE.
         TM    SDBFLG1,SDB1BFXS    CHN PGM ABORTED VIA SWAP-OUT...   R4
         BZ    HC209               BR IF NO                          R4
         ICM   R1,15,SDBPBF        ANY PBFS TO BE WRITTEN...         R4
         BZ    HC209               BR IF NO                          R4
         NI    SDBFLG1,255-SDB1BFXS  RESET EXCESSION ALLOWED         R4
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         EXCP  SDBIOB              ISSUE EXCP                        R4
         B     HC208               WAIT FOR I/O TO COMPLETE          R4
*                                                                    R4
*              LOWER OPEN COUNT.  IF STILL OPEN FOR OTHERS, RETURN
*
HC209    DS    0H                                                    R4
         L     R1,SDBCCW3+4        GET OPEN COUNT.
         BCTR  R1,0                DECREMENT IT.
         ST    R1,SDBCCW3+4        STORE OPEN COUNT.
         LTR   R1,R1               IF STILL OPEN FOR OTHERS,
         BNZ   HCRET               MERELY RETURN.
*
*              3. FREE ALL BUFFERS
*
HC210    DS    0H
         L     RBUF,SDBPBF         FREE ALL
         BAL   R5,HCFREBP          PROTECTED BUFFERS.
         L     RBUF,SDBUBF         FREE ALL
         BAL   R5,HCFREBU          UNPROTECTED BUFFERS.
         L     RBUF,SDBHBF         FREE ALL
HC212    DS    0H                                              @OZ41634
         BAL   R5,HCFREBU          UPDATE-HOLD BUFFERS.
         LTR   RBUF,RBUF           END OF HBUF CHAIN ?         @OZ41634
         BNZ   HC212               NO, LOOP BACK               @OZ41634
         L     RBUF,SDBFBF         FREE ALL
         BAL   R5,HCFREBP          CH END FREE BUFFERS.
         SLR   R0,R0               ZERO POINTERS TO
         ST    R0,SDBPBF           PROTECTED,
         ST    R0,SDBUBF           UNPROTECTED,
         ST    R0,SDBHBF           HOLD, AND
         ST    R0,SDBFBF           FREE BUFFERS.
         STH   R0,SDBPBFCT         SHOW NO PROTECTED BUFFERS.
*
*              4. RETURN TO CALLER
*
         L     R1,SDBAIOT          POINT TO ALLOCATION IOT.
         TM    IOTFLAG1-IOTDSECT(R1),IOT1CKPT  CKPT REQUIRED...
         BZ    HC900               IF NOT, CONCLUDE CLOSE.
         NI    IOTFLAG1-IOTDSECT(R1),255-IOT1CKPT  RESET FLAG.
         L     R0,IOTTRACK-IOTDSECT(,R1)  R0=TRACK ADDRESS.
         MVC   SJBFWORD,=CL4'IOT'  INDICATE IOT WRITE IN SJB   @OZ78293
         CALL  HCBWR               WRITE THE IOT.
         B     HC900               GO CONCLUDE CLOSE.
         EJECT
         SPACE 5
*
*              ADD OTHER DATA SET TYPES HERE
*
HC400    DS    0H
         $MID  353
         WTO   '&MID.CLOSE FAILED BECAUSE NOT SYSIN, SYSOUT, NOR PROCESC
               S-SYSOUT',ROUTCDE=10,DESC=6
         B     HCERR
         DROP  RBUF,RJFC,RSIB      DROP BASES.
         EJECT
*
*              CONCLUDE CLOSE FOR ALL BUT INTRDR.
*
HC900    DS    0H
         SLR   R0,R0               ZERO OUT THE DEB
         ST    R0,SDBDEB           POINTER IN THE SDB.
         SPACE 3
*
*              RETURN NORMALLY TO CALLER
*
HCRET    DS    0H
         SLR   R15,R15             SET RETURN CODE TO ZERO.
         B     HCEXIT              GO RETURN.
         SPACE 3
*
*              RETURN ABNORMALLY TO CALLER
*
HCERR    DS    0H
         LA    R15,4               NOTE- RETURN CODES ARE NOT DEFINED.
         SPACE 3
HCEXIT   DS    0H
         LR    R1,R13              POINT R1 TO SJB/USER SAVE.
         LTR   R12,R12             IF R1 POINTS TO USER SAVE,
         BNM   *+8                 SKIP POINTING FROM SJB.
         L     R1,4(,R1)           POINT TO USER SAVEAREA.
         L     R1,24(,R1)          POINT TO SSOB.
         USING SSOBEGIN,R1         SET BASE.
         L     R1,SSOBINDV         POINT THENCE TO SSDA.
         USING SSDABGN,R1          SET BASE.
         L     R1,SSDADEBP         POINT THENCE TO DEB.
         USING DEBBASIC,R1         SET BASE.
         L     R1,DEBDCBAD         POINT THENCE TO ACB.
         USING IFGACB,R1           SET BASE.
         SLR   R0,R0               ZERO OUT
         ST    R0,ACBINRTN         ACCESS METHOD ADDRESS.
         SPACE 1
        $EPILOG KEY=0              RETURN TO CALLER                  R4
         TITLE 'FAKE CLOSE FOR CONVERTER DATASETS'
*
*
*              FAKE CLOSE FOR CONVERTER DATASETS
*
*
SSVCLSC  DS    0H
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
         MODESET EXTKEY=ZERO       SET KEY ZERO FOR FAKE CLOSE.
         USING PCEDSECT,R8         USE PCE DSECT.
         LR    R2,R13              SAVE USER SAVEAREA POINTER.
         LR    RSVT,R5             HOSCNVT PASSES SSVT IN R5.
         L     RSJB,JPCESJBP       POINT TO CONVERTER SJB.
         ST    RSJB,8(,R2)         POINT USER SAVEAREA TO NEXT.
         ST    R2,SJBSAVE+4        POINT SJB SAVEAREA TO USER'S.
         L     R0,=A(HAMNULL)      GET NULL ADDRESS                  R4
         ST    R0,SJBLACB+ACBINRTN-IFGACB  NULLIFY JOB LOG           R4
*
*              FOR EACH SDB, INVOKE FAKE CLOSE
*
         L     R7,PCEJCT           POINT R7 TO THE JCT.
*              THIS LINE DELETED BY APAR NUMBER                @OZ26284
SSVCC10  DS    0H
         L     RSDB,SJBSDB         POINT TO AN SDB.
         LTR   RSDB,RSDB           ARE WE THROUGH...
         BZ    SSVCC20             IF SO, GO CHECK FOR HOLDING.
         CALL  HFCLSUB             NO.  GO TO FAKE CLOSE.
         CALL  $SDBFREE            FREE THE SDB.
         B     SSVCC10             THEN DO NEXT SDB.
*
*              IF CONVERTER ERROR, PROCESS FOR HOLD
*
SSVCC20  DS    0H
         TM    JCTJOBFL-JCTDSECT(R7),JCTTSCAN  TYPRUN = SCAN...      R4
         BO    SSVCC30             BR IF YES                         R4
         L     R1,4(,R13)          POINT TO CALLER'S SAVE AREA.
         L     R1,20(,R1)          INSPECT CALLER'S REGISTER 0.
         LTR   R1,R1               IF IT WAS ZERO,
         BZ    SSVCC90             CONVERSION WAS SUCCESSFUL.
SSVCC30  DS    0H                                                    R4
         CALL  HJEAHOLD            ELSE PROCESS FOR HOLD.
*
*              RETURN TO CALLER
*
SSVCC90  DS    0H
         MODESET EXTKEY=HASP       SET HASP KEY BEFORE RETURN.
         L     R13,4(,R13)         POINT TO USER SAVEAREA.
         LM    R14,R12,12(R13)     RESTORE REGISTERS.
         BR    R14                 RETURN.
         DROP  R8                  DROP PCE BASE.
         TITLE 'FAKE CLOSE SUBROUTINE'
*
*
*              FAKE CLOSE SUBROUTINE - INPUT AND OUTPUT DATASETS
*
*
HFCLSUB  DS    0H                  L    RSDB,THE SDB TO CLOSE
*                                  L    R7,THE JCT FOR JOB
*                                  CALL HFCLSUB
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         BALR  R12,0               ESTABLISH
HFCLBASE DS    0H                  LOCAL
         USING *,R12               ADDRESSABILITY.
HFCL00   DS    0H
         TM    SDBFLG1,SDB1GET     IF INPUT DATA SET,
         BO    HFCL30              SKIP OUTPUT LOGIC.
         L     RBUF,SDBUBF         ELSE POINT TO UBF.
         LTR   RBUF,RBUF           IF NO UBF (ABNORMAL),
         BZ    HFCL30              SKIP OUTPUT ROUTINES.
         USING BFD,RBUF            USE BUFFER DSECT.
         USING JCTDSECT,R7         USE JCT DSECT.
         L     R3,SDBPDDB          GET PDDB ADDRESS FROM SDB.
         USING PDBDSECT,R3         SET PDDB ADDRESSABILITY.
         LA    R8,BFDAT                 IF
         CL    R8,BFLOC                  DATASET
         BNE   HFCL05                     OPENED
         CLC   SDBTRK,SDBTRKF              BUT NOT
         BNE   HFCL05                       WRITTEN TO,
         OI    PDBFLAG1,PDB1NULL             INDICATE EMPTY
*
*              OUTPUT - TEST FOR CONTINUATION TYPE
*
HFCL05   DS    0H
         LA    R8,JCTJLOGC         ASSUME HASP JOB LOG               R4
         CLC   SDBDKEY,=AL2(PDBOUHJL)  IF SO,                  @OZ79713
         BE    HFCL10              GO DO FIRST TRUNCATION.
         LA    R8,JCTMSGSC         ASSUME SYSTEM MESSAGES            R4
         CLC   SDBDKEY,=AL2(PDBOUMSG)  IF SO,                  @OZ79713
         BE    HFCL10              GO DO FIRST TRUNCATION.
         B     HFCL20              ELSE CLOSE IMMEDIATELY.
         EJECT                                                       R4
*
*              IF HASP JOB LOG OR SYS MSGS, TRUNCATE HERE.
*
HFCL10   DS    0H
         TM    PDBFLAG1,PDB1NULL   IF DATASET EMPTY,
         BO    *+8                  DON'T TRUNCATE TWICE.
         BAL   R14,HFCLTRNC        TRUNCATE BUFFER.
         MVC   0(4,R8),SDBTRK+1    SAVE CONTINUE MTTR IN JCT        R41
         CLC   SDBDKEY,=AL2(PDBOUHJL)  IF NOT JES2 JOB LOG,    @OZ79713
         BNE   HFCL20                BRANCH AROUND                   R4
         TM    SJBFLG2,SJB2CONV    IF NOT FAKE-CLOSE FOR             R4
         BZ    HFCL20                CONVERTER, BRANCH AROUND        R4
         CLI   JCTJOBID,C'J'       IF NOT PLAIN VANILLA BATCH       R41
         BNE   HFCL20                JOB, BRANCH AROUND             R41
         TM    JCTJOBFL,JCTTSCAN   IF 'TYPRUN=SCAN',                R41
         BO    HFCL20                BRANCH AROUND                  R41
         L     R3,4(,R13)          CHECK CONVERTER'S                 R4
         L     R3,20(,R3)            RETURN CODE --                  R4
         LTR   R3,R3                 IF CONVERSION ERROR,            R4
         BNZ   HFCL20                BRANCH AROUND                   R4
         L     R3,BFLOC            PLACE 'JOB DELETED' BLURB IN JOB  R4
         MVC   0(HFCMSGL,R3),HFCMSG  LOG TERMINATOR BUFFER, TO BE    R4
         LA    R3,HFCMSGL(,R3)       OVER-WRITTEN IF JOB GOES        R4
         ST    R3,BFLOC              INTO EXECUTION                  R4
         OI    SDBFLG2,SDB2EOD     SET RECORD COUNT OFF        @OZ43719
*
*              TRUNCATE & CLOSE ALL OUTPUT DATA SETS
*
HFCL20   DS    0H
         CLC   SDBTRK,SDBTRKF      DON'T WAIT IF I/O HAS       @OZ39533
         BE    HFCL25               NEVER BEEN STARTED         @OZ39533
         L     R1,SDBECB           RESET THE WAIT BIT          @OZ39533
HFCL22   LR    R3,R1                AND WAIT HERE FOR THE      @OZ39533
         N     R3,=XL4'7F000000'     CEA REDRIVE LOOP          @OZ39533
         CS    R1,R3,SDBECB           TO STOP, OR CEA MAY      @OZ39533
         BNE   HFCL22                  NOT WRITE THE LAST      @OZ39533
         WAIT  1,ECB=SDBECB             BUFFER                 @OZ39533
HFCL25   DS    0H                                              @OZ39533
         OI    SDBFLG1,SDB1CLOS    CAUSE DATA SET CLOSE.
         BAL   R14,HFCLTRNC        TRUNCATE BUFFER.
         NI    SDBFLG1,255-SDB1CLOS  RESET CLOSE FLAG.
         NI    SDBFLG2,255-SDB2EOD RESET RECORD COUNT OFF      @OZ43719
*
*              BE SURE I/O IS COMPLETE
*
HFCL30   DS    0H
         WAIT  1,ECB=SDBECB        ELSE WAIT TILL I/O INACTIVE.
         TM    SDBFLG1,SDB1GET     TEST FOR INPUT DATA SET           R4
         BO    HFCL50              BR IF YES                        R41
         TM    SDBFLG1,SDB1BFXS    CHN PGM ABORTED VIA SWAP-OUT...   R4
         BZ    HFCL40              BR IF NO                          R4
         ICM   R1,15,SDBPBF        ANY PBFS TO BE WRITTEN...         R4
         BZ    HFCL40              BR IF NO                          R4
         NI    SDBFLG1,255-SDB1BFXS  RESET EXCESSION ALLOWED         R4
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         EXCP  SDBIOB              ISSUE EXCP                        R4
         B     HFCL30              WAIT FOR I/O TO COMPLETE          R4
         EJECT                                                      R41
HFCL40   L     R3,SDBPDDB          MOVE RECORD COUNT                R41
         MVC   PDBRECCT,SDBRECCT    TO PDDB                         R41
         L     R8,SDBPIOT                     FLAG IOT FOR          R41
         OI    IOTFLAG1-IOTDSECT(R8),IOT1CKPT  CHECKPOINT           R41
         SPACE 1                                                    R41
HFCL50   LM    R14,R12,12(R13)     RESTORE REGISTERS                R41
         BR    R14                 RETURN TO CALLER.
         SPACE 1                                                    R41
         DROP  R3,R7,R12           DROP BASES.
         SPACE 3                                                    R41
*
*              TRUNCATION SUBROUTINE
*
         USING HFCLBASE,R12
HFCLTRNC DS    0H
         L     R3,BFLOC            POINT TO CURRENT UBF OFFSET.
         USING LRCDSECT,R3         USE LOGICAL RECORD DSECT.
         MVI   LRCTLENG,LRCBFEND   TRUNCATE THE BUFFER.
         L     R1,SDBDEB           POINT TO DATA SET'S DEB.
         USING DEBBASIC,R1         USE DEB DSECT.
         L     R1,DEBDCBAD         POINT THENCE TO ACB.
         LA    R1,0(,R1)           ZERO HIGH-ORDER BYTE.
         LNR   R1,R1               SHOW HAMSVC ARG IS ACB.
         LA    R0,HSVCEOBP         SET HAMSVC FUNCTION CODE.
         SVC   HAMSVC              USE HAMSVC TO WRITE.
         BR    R14                 RETURN TO CALLER.
         DROP  R1,R3               DROP DEB, LRC BASES.
*                                                                    R4
*        'JOB DELETED' BLURB FOR JOB LOG TERMINATOR BUFFER           R4
*                                                                    R4
HFCMSG   DC    AL1(HFCMSGL-4,LRC1CCTL+LRC1TMCH,HFCMSGL-4,X'09')        *
                                   SET MACHINE CARRIAGE CNTRL  @OZ44796
         DC    C'******** JOB DELETED BY JES2 OR CANCELLED '         R4
         DC    C'BY OPERATOR BEFORE EXECUTION ******** '             R4
HFCMSGL  EQU   *-HFCMSG            LENGTH FOR MOVE                   R4
         EJECT
         SPACE 3
*
*              SUBROUTINES TO FREE BUFFERS
*
HCFREBP  DS    0H
         USING HOSCLOSB,R12        USE MAINLINE CLOSE BASE.
         LTR   R1,RBUF             IF NO BUFFER TO FREE,
         BZR   R5                  RETURN.
         L     RBUF,BFBF           ELSE POINT TO NEXT BUFFER
         $FREEBUF TYPE=PROT,A=(R1)  AND FREE CURRENT.
         B     HCFREBP             THEN REPEAT.
         SPACE 1
HCFREBU  DS    0H
         LTR   R1,RBUF             IF NO BUFFER TO FREE,
         BZR   R5                  RETURN.
         L     RBUF,BFBF           ELSE POINT TO NEXT BUFFER
         $FREEBUF TYPE=UNPROT,A=(R1)  AND FREE CURRENT.
         BR    R5                  RETURN ON REG5              @OZ41634
         DROP  ,                   DROP ALL BASES.
         TITLE 'HOSCKPT -- SUBSYSTEM DATASET CHECKPOINT FUNCTION'
HOSCKPT  $PROLOG SSOBCKPT,SSDASIZE,LOCK=REQ
*
*
*              CHECKPOINT A SUBSYSTEM DATA SET
*
*
*
*              CHECKPOINT AREA IS USED AS FOLLOWS ---
*        BYTE 0-3    JOB KEY, FROM SDBJKEY
*        BYTE 4-5    DATA SET KEY, FROM SDBDKEY
*        BYTE 6      FLAGS AS FOLLOW -
*              BIT 0 INTRDR - NO REPOSITIONING
*              BIT 1 SPIN - NO REPOSITIONING
*              BIT 2 EOD - SHOW EOD AT RESTART
*              BIT 3 I/O ERROR - SHOW I/O ERROR AT RESTART
*              BIT 4 1=OPEN FOR INPUT AT RESTART
*              BIT 5 RESERVED
*              BIT 6 RESERVED
*              BIT 7 RESERVED
*        BYTE 7      RESERVED
*        BYTE 8-15   STARTING RBA, FROM SDBTRKF
*        BYTE 16-23  CURRENT RBA, FROM BFRBA FROM SDBUBF
*        BYTE 24-27  NUMBER OF RECORD NEXT TO READ
*
*
*              LOAD REGISTERS FROM SSOB EXTENSION
*
         USING SSDABGN,RSOX        USE SSOB EXTENSION DSECT.
         L     R7,SSDASSCM         POINT TO DCT/SDB.
         L     R4,SSDABUFR         POINT TO CHECKPOINT BUFFER.
         XC    0(24,R4),0(R4)      CLEAR PART OF BUFFER.
*
*              IF INTERNAL READER, SET FLAG AND EXIT
*
         USING DCTDSECT,R7         USE DCT DSECT.
         CLC   =C'INTRDR',DCTDEVN  IS THIS AN INTERNAL READER...
         BNE   HCK100              BRANCH IF NOT.
         OI    6(R4),X'80'         YES.  SET FLAG
         B     HCK900              AND RETURN.
*
*              VERIFY SDB AND THAT IT'S OPEN
*
HCK100   DS    0H
         USING SDBDSECT,R7         USE R7 AS SDB BASE.
         CLC   SDBID,=CL4'SDB'     IS THIS REALLY AN SDB...
         BNE   HCK800              ERROR IF NOT.
         L     RIOT,SDBPIOT        YES.  POINT TO PDDB'S IOT
         L     RBUF,SDBUBF         AND TO UNPROTECTED BUFFER.
         L     RSVT,SDBSVT         AND POINT TO SSVT.          @OZ29839
         LTR   RBUF,RBUF           IF NO UNPROTECTED BUFFER,
         BZ    HCK800              ERROR.
         LTR   RIOT,RIOT           IF NO PDDB'S IOT,
         BZ    HCK800              ERROR.
*        THIS LINE DELETED BY APAR ===>                        @OZ45546
*        THIS LINE DELETED BY APAR ===>                        @OZ45546
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         USING BFD,RBUF            SET BUF ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY     @OZ29839
*
*              SAVE JOB AND DATA SET KEY
*
         MVC   0(6,R4),SDBJKEY     SAVE JOB AND DATA SET KEYS.
*
*              IF OUTPUT DATA SET, TRUNCATE & WRITE.
*
HCK150   DS    0H
         TM    SDBFLG1,SDB1PUT     IF NOT OUTPUT,
         BZ    HCK200              BRANCH.
         CLI   SDBCCW3+7,0         IF DATA SET NOT OPENED,     @OZ45546
         BE    HCK800              ERROR.                      @OZ45546
         L     R1,BFLOC            POINT TO CURRENT BUFFER LOC.
         LA    R5,BFIO             GET ADDRESS OF              @OZ29839
         AH    R5,$SVBFSIZ           BUFFER END                @OZ29839
         CR    R5,R1               COMPARE BFLOC TO END.       @OZ29839
         BNH   HCK800              ERROR IF BFLOC TOO LARGE.   @OZ29839
         CR    RBUF,R1             COMPARE BFLOC TO START.     @OZ29839
         BNL   HCK800              ERROR IF BFLOC TOO SMALL.   @OZ29839
         MVI   0(R1),LRCBFEND      TRUNCATE THE BUFFER.
         L     R1,SSDADEBP         FROM THE
         USING DEBBASIC,R1         DEB, GET
         L     R1,DEBDCBAD         ACB POINTER
         DROP  R1                  FOR HAMSVC.
         LA    R1,0(,R1)           ZERO HIGH BYTE.
         LNR   R1,R1               SHOW HAMSVC ARG IS ACB.
         LR    R2,R1               SAVE NEGATIVE OF ACB.
         LA    R0,HSVCEOBP         SET FUNCTION REGISTER.
         SVC   HAMSVC              TRUNCATE THE BUFFER.
         LA    R1,BFDAT            PT TO BUF DATA START.
         MVI   0(R1),LRCBFEND      TRUNCATE EMPTY BUFFER.
         L     RIOT,SDBAIOT        FLAG ALLOCATION IOT
         OI    IOTFLAG1,IOT1CKPT   FOR CHECKPOINT BY HCEPUT.
         LR    R1,R2               SET NEGATIVE ACB ADDRESS.
         LA    R0,HSVCEOBP         SET FUNCTION REGISTER.
         SVC   HAMSVC              WRITE TRUNCATED BUFFER.
         B     HCK250              CONTINUE.
*
*              INPUT DATA SET - SET OPEN-FOR-INPUT FLAG
*
HCK200   DS    0H
         CLC   SSDADEBP,SDBDEB     IF DATA SET NOT OPENED,     @OZ45546
         BNE   HCK800              ERROR.                      @OZ45546
         OI    6(R4),X'08'         INPUT - SET FLAG FOR INPUT.
         L     R1,BFRBA+4          GET NR OF NEXT RECORD
         LA    R1,0(,R1)           HAMGET WILL READ.
         AL    R1,SDBRECCT         ADD CT FROM PREV BUFFERS.
         ST    R1,24(,R4)          SAVE CURRENT REC NR.
*
*              IF INPUT IS AT EOD, SET EOD FLAG
*
         TM    SDBFLG2,SDB2EOD     IF NOT AT END-OF-DATA-SET,
         BZ    HCK250              BRANCH.
         TM    BFFL1,BF1EOB        TEST END-OF-BUFFER TOO.           R4
         BZ    HCK250              BRANCH IF NOT EOD.
         OI    6(R4),X'20'         ELSE SET EOD FLAG.
*
*              INPUT AND OUTPUT - TEST I/O ERROR
*
HCK250   DS    0H
         TM    SDBFLG2,SDB2IOE     IF DATA SET NOT AT I/O ERROR,
         BZ    HCK300              BRANCH.
         OI    6(R4),X'10'         ELSE SET I/O ERROR FLAG
         B     HCK900              AND RETURN.
*
*              SAVE CURRENT RBA VALUES
*
HCK300   DS    0H
         MVC   8(8,R4),SDBTRKF     SAVE STARTING RBA.
         MVC   16(8,R4),BFRBA      SAVE CURRENT RBA.
         B     HCK900              RETURN TO CALLER.
*
*              ERROR - SET ERROR CODE AND EXIT
*
HCK800   LA    R15,4               SHOW RETURN CODE 4
         B     HCK950              AND RETURN TO USER.
*
*              RETURN TO USER VIA $EPILOG
*
HCK900   DS    0H
         SLR   R15,R15             SHOW NORMAL RETURN.
HCK950   DS    0H
         $EPILOG ,                 RETURN WITH CODE IN R15.
         DROP  ,                   DROP ALL BASES.
         TITLE 'HOSREST -- SUBSYSTEM DATA SET RESTART FUNCTION'
HOSREST  $PROLOG SSOBREST,SSDASIZE,LOCK=SDB
HOSRESTB DS    0H                  RESTART BASE LABEL
*
*              UNLESS INTERNAL READER, SET SDBTRK, SDBTRKF.
*
         USING SSDABGN,RSOX        USE SSOB EXTENSION DSECT.
         L     R4,SSDABUFR         POINT TO RESTART INFO BUFFER.
         TM    6(R4),X'80'         IF INTERNAL READER,
         BO    HRS100              SKIP SDB LOGIC.
         L     R5,SSDASSCM         POINT TO THE SDB.
         USING SDBDSECT,R5         USE ITS DSECT.
         CLC   SDBID,=CL4'SDB'     IF POINTER IS NOT TO
         BNE   HRS800              AN SDB, ERROR.
         MVC   SDBTRKF(16),8(R4)   ELSE REFRESH 1ST, CURRENT RBA.
*
*              UNLESS EOD OR I/O ERROR USE HOSOPEN
*
HRS100   DS    0H
         TM    6(R4),X'30'         IF EOD OR IOE,
         BNZ   HRS200              DON'T USE HOSOPEN.
         SL    R12,=A(HOSRESTB-HOSOPENB)  ELSE SET OPEN
         BR    R12                 ADDRESSABILITY AND ENTER IT.
*
*              I/O ERROR OR EOD - FAKE RE-OPEN HERE
*
HRS200   DS    0H
         $GETBUF TYPE=UNPROT       GET UNPROTECTED BUFFER.
         BNZ   HRS800              ERROR IF NONE.
         LR    RBUF,R1             SET BUFFER ADDRESSABILITY.
         USING BFD,RBUF            USE BUFFER DSECT.
         MVI   BFID,C'U'           SHOW BUF IS UNPROTECTED.
         ST    RBUF,SDBUBF         SAVE ITS ADDRESS IN SDB.
         OI    BFFL1,BF1EOB        SHOW BUF AT END-OF-BUFFER.        R4
         MVC   SDBDEB,SSDADEBP     SET DEB PTR IN SDB
         L     R4,SSDADEBP         PUT A POINTER TO THE        @OZ72683
         ST    R5,DEBIRBAD-DEBDSECT(0,R4) SDB IN THE DEB.      @OZ72683
         OI    SDBFLG2,SDB2EOD     ASSUME SDB AT EOD.
         L     R4,SSDABUFR         RE-POINT TO RESTART BUFFER.
         TM    6(R4),X'20'         IF EOD, SKIP.
         BO    *+8                 ELSE RESET EOD
         XI    SDBFLG2,SDB2EOD+SDB2IOE  AND SET I/O ERROR.
*
*              SET SDB1PUT OR SDB1GET.  IF SDB1GET GET A PBF.
*
         OI    SDBFLG1,SDB1PUT     ASSUME OUTPUT DATA SET.
         TM    6(R4),X'08'         IF CORRECT,
         BZ    HRS900              RETURN.
         XI    SDBFLG1,SDB1PUT+SDB1GET  ELSE SET INPUT DATA SET.
         $GETBUF TYPE=PROT         INPUT NEEDS A PROTECTED BUFFER.
         BNZ   HRS800              ERROR IF CAN'T GET.
         LR    RBUF,R1             SET BUFFER ADDRESSABILITY.
         MVI   BFID,C'P'           SHOW BUFFER IS PROTECTED.
         ST    RBUF,SDBPBF         SAVE ITS ADDRESS IN SDB.
         B     HRS900              RETURN TO CALLER.
*
*              ERROR DURING DATA SET RESTART
*
HRS800   DS    0H
         LA    R15,4               SET R15=4 FOR ERROR
         B     HRS950              AND RETURN TO CALLER.
*
*              RESTART COMPLETE.  HERE ONLY IF EOD OR IOE.
*
HRS900   DS    0H
         SLR   R15,R15             SET R15=0 FOR NORMAL.
HRS950   DS    0H
         $EPILOG  ,                RETURN TO CALLER.
         SPACE 1
         DROP  ,                   DROP ALL ADDRESSABILITY.
         TITLE 'LITERAL POOL FOR OPEN/CLOSE'
         LTORG
         TITLE 'HASP ACCESS METHOD SVC CODES'
HAMSVC   EQU   111
*
         SPACE 3
*
*                                  HAMSVC OPERATION CODES
*
         SPACE 3
HSVCEOBG EQU   0                        END-OF-BLOCK ON A GET OPERATION
*                                  - IF DATA AWAITS IN A PROTECTED
*                                  BUFFER, HAMSVC WILL MOVE IT TO THE
*                                  UNPROTECTED BUFFER, LINITIALIZING
*                                  FIELDS.  IF NOT, HAMSVC WILL SET
*                                  ONE OF THE FLAGS DDT1IOA, DDT1IOE,
*                                  OR DDT1EOD AND RETURN.  IF BY THE
*                                  NEXT GET THE CE APDG HASN'T RESET
*                                  DDT1IOA, THE GET ROUTINE WILL WAIT
*                                  UPON DDTECB.
         SPACE 1
HSVCEOBP EQU   4                        END-OF-BLOCK ON A PUT OPERA-
*                                  TION.  HAMSVC GETS A PROTECTED
*                                  BUFFER, MOVES TO IT THE UNPROTECTED
*                                  BUFFER, CALLS $TRACK TO FIND ADDRESS
*                                  OF NEXT BUFFER, CHAINS THIS BUFFER
*                                  ON CHAIN OF BUFFERS TO BE WRITTTEN,
*                                  AND ISSUES EXCP IF NECESSARY.  IT
*                                  RE-INITIALIZES THE UNPROTECTED
*                                  BUFFER, RESETS UBFRBA, AND RETURNS
*                                  TO CALLER.
         SPACE 1
HSVCIRD  EQU   8                        INTERNAL READER PUT OPERATION.
*                                  HAMSVC MOVES DATA TO INTERNAL READER
*                                  CONTROL AREA, $POSTS ASSOCIATED
*                                  INTERNAL READER CONTROL AREA'S PCE,
*                                  XMPOSTS HASP, AND WAITS.  WHEN HASP
*                                  XMPOSTS, HAMSVC RETURNS TO ISSUER.
         SPACE 1
HSVCPNT  EQU   12                       POINT OPERATION WAS ISSUED.
*                                  HAMSVC STARTS WITH THE BLOCK ADDRES-
*                                  SED BY THE MTTR PORTION OF THE RPLRB
*                                  AR AND SCANS, READING MORE BLOCKS
*                                  IF NECESSARY, UNTIL THE RECORD-
*                                  NUMBER PORTION OF THE RBA HAS BEEN
*                                  SATISFIED.  UPON RETURN THE DDT AND
*                                  UNPROTECTED BUFFER ARE SET SO THAT A
*                                  GET WILL RETRIEVE THE POINTED-TO
*                                  RECORD.
         SPACE 1
HSVCENDR EQU   20                       ENDREQ OPERATION WAS ISSUED.
*                                  HAMSVC TRUNCATES AND MOVES TO A
*                                  PROTECTED BUFFER TO BE WRITTEN THE
*                                  CURRENT UNPROTECTED BUFFER.
         SPACE 1
HSVCOUTL EQU   24                       OUTPUT LIMIT IS EXCEEDED.
         SPACE 1
HSVCGUPD EQU   32                       GET-UPDATE OPERATION.
         SPACE 1
HSVCPUPD EQU   36                       PUT-UPDATE OPERATION.
         SPACE 1
HSVCXBM  EQU   40                       EXECUTION BATCH MONITOR -
*                                  TERMINATE CURRENT USER JOB
*                                  UNDER EXECUTION BATCH MONITOR
*                                  AND CALL HASPXEQ TO GET
*                                  ANOTHER USER JOB OR TO TERMINA-
*                                  TE THE BATCH MONITOR
         TITLE 'HASPAM - INTERFACE ROUTINE FOR HASP ACCESS METHODS'
RBUF     EQU   R6
RRPL     EQU   R7
RPBF     EQU   R7
RACB     EQU   R8
RSDB     EQU   R10
RIOT     EQU   R5
*                                  THIS LOCATION IS POINTED TO BY
*                                  ACBINRTN, IN THE ACB.
*                                  LINKAGE IS ---
*                                  L     R15,ACBINRTN
*                                  LA    R1,RPL
*                                  BALR  R14,R15
         SPACE 3
HAMNULL  DS    0H                  CLOSED HASP JOB LOG ACB RTN.
         SR    R15,R15             ZERO THE RETURN CODE              R4
         BR    R14                 AND RETURN.
         SPACE 3
HASPAM   DS    0F
         USING *,R15
         B     *+8                 BRANCH AROUND ADCON.
         DC    A(SVCHAM)           ADCON FOR SVC 111.
         STM   R14,R12,12(R13)     SAVE REGISTERS.
         LR    R12,R15             SET HAM LOCAL BASE REGISTER.
HAMBASE  EQU   HASPAM              DEFINE HAM BASE LOCATION.
         USING HAMBASE,R12         SET HAM ADDRESSABILITY.
         DROP  R15                 DROP TEMPORARY BASE.
         USING RPLDSECT,R1         USE RPL DSECT.
*                                  VALIDITY CHECKING -
*                                  RPLREQ MUST BE .LE. 5, ELSE RETURN
*                                  ERROR CODE RPLINVP - INVALID PROCES-
*                                  SING OPTIONS.
*
         CL    R0,=A(RPLERASE)     IS OPTION VALID...
         BH    HERINVP             IF NOT, RETURN.
*
*                                  PUT OTHER VALIDITY CHECING HERE
*
         EJECT
*              SET UP REGISTERS FOR HASP ACCESS METHODS.
*              REGISTER CONVENTIONS ARE ---
*              R0, R1, R15 - WORK REGISTERS AND USED AS ARGUMENTS TO
*                            HAMSVC.
*              R2 - R5 - WORK REGISTERS AND USED WITH MVCL AS FOLLOWS--
*                R2 - HAM BUFFER ADDRESS
*                R3 - HAM DATA LENGTH
*                R4 - USER BUFFER ADDRESS
*                R5 - USER BUFFER LENGTH
*        RBUF  R6 - ADDRESS OF CURRENT HASP BUFFER
*        RRPL  R7 - ADDRESS OF RPL
*        RPBF  R7 - ADDRESS OF PBF
*        RACB  R8 - ADDRESS OF ACB
*              R9 - RESERVED FOR USER MODIFICATIONS
*        RDDT  RA - ADDRESS OF DDT
*              RB - SUBROUTINE BASE
*              RC - MAIN ROUTINE BASE
*              RD - ADDRESS OF USER SAVE AREA
*              RE - LINKAGE REGISTER
         SPACE 3
HAMREDO  LR    RRPL,R1             SET RPL BASE.               @OZ44947
         USING RPLDSECT,RRPL       USE RPL DSECT.
         STC   R0,RPLREQ           SAVE REQUEST TYPE IN RPL.
         DROP  R1                  DROP OLD RPL BASE.
         L     RACB,RPLDACB        POINT TO ACB FROM RPL.
         USING ACBDSECT,RACB       USE ACB DSECT.
         CLI   ACBID,ACBIDVAL      IF ACB DOESN'T LOOK RIGHT,
         BNE   HERBLKER            SHOW CONTROL BLOCK ERROR.
* TEST FOR ACBOPEN FLAG IS UNNECESSARY
         L     RSDB,ACBDEB-1       POINT TO DEB FROM ACB.
         USING DEBBASIC,RSDB       USE DEB DSECT.
         L     RSDB,DEBIRBAD       POINT TO SDB FROM DEB.
         TM    ACBINRTN,ACBINR     IS DATA SET AN INTERNAL RDR...
         BZ    HAM010              IF NOT, PROCESS SDB.
*
*              INTERNAL READER INITIALIZATION
*
         USING DCTDSECT,RSDB       SET INTRDR ADDRESSABILITY.
         L     RSVT,RIDSSVT        POINT TO SUBSYS VECTOR TABLE.
         CLI   RPLREQ,RPLPUT       IS THIS A PUT REQUEST...
         BE    HPIRDR              BRANCH IF SO.
         CLI   RPLREQ,RPLENDRE     IS THIS AN END REQUEST...
         BE    HENDI               BRANCH IF SO.
         B     HERINVP             OTHERWISE INVALID REQUEST.
         EJECT
*
*              NORMAL SUBSYSTEM DATA SET INITIALIZATION
*
HAM010   DS    0H
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         L     RSVT,SDBSVT         POINT TO SUBSYS VECTOR TABLE.
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         USING BFD,RBUF            SET BUFFER ADDRESSABILITY.
         USING $SVDSECT,RSVT       SET SSVT ADDRESSABILITY.          R4
         USING LRCDSECT,R1         SET LOGICAL RECORD ADDR'TY.
*
*              SELECT FUNCTION FROM RPL.
*
*        FUNCTIONS ARE ---
*        0     GET
*        1     PUT
*        2     CHECK
*        3     POINT
*        4     ENDREQ
*        5     ERASE
*
         SPACE 3
         LR    R15,R0              GET REQUEST NUMBER.
         AR    R15,R15             MULTIPLY
         AR    R15,R15             BY 4.
         B     *+4(R15)            BRANCH ACCORDING TO R15 ---
         B     HAMGET                GET
         B     HAMPUT                PUT
         B     HAMCHECK              CHECK
         B     HAMPOINT              POINT
         B     HAMENDRE              ENDREQ
         B     HAMERASE              ERASE
         EJECT
*
*                                  THE FOLLOWING FUNCTIONS RESULT IN AN
*                                  IMMEDIATE NORMAL RETURN TO THE USER.
*
*              HAMCHECK            SINCE RPLECB HAS ALREADY BEEN POSTED
*                                  COMPLETE IN GET AND PUT.
*              HAMERASE            FUNCTION IS NOT SUPPORTED FOR
*                                  JES DATA SETS.
         SPACE 3
HAMCHECK DS    0H
         L     R15,RPLFDBK-1       FOR CHECK, RETURN
         LA    R0,0(,R15)          TO USER THE CONTENTS
         B     HRPLEXIT            OF RPLFDBK.
HAMERASE DS    0H
         SR    R0,R0               SET ZERO RETURN CODE.
         B     HRPLEXIT            RETURN TO CALLER.
         TITLE '''GET'' ACCESS METHOD ROUTINE'
*
*
*              HASP 'GET' ACCESS METHOD ROUTINE
*
*
HAMGET   DS    0H
*
*              PROCESS SEQUENTIAL NON-UPDATE GET
*
         TM    RPLOPT2,RPLUPD      IS THIS AN UPDATE REQUEST...
         BO    HG100               BRANCH IF SO.
         SPACE 1
         TM    SDBFLG1,SDB1GET     DOES DATA SET ALLOW GET...
         BZ    HERINVP             ERROR IF NOT.
         TM    BFFL1,BF1EOB        EOB ON PREVIOUS GET...            R4
         LA    R14,HG010           SET RETURN                        R4
         BO    HGSPEC              BR IF YES (EOB)                   R4
         SPACE 1
HG010    DS    0H
         L     R1,BFLOC            POINT TO CURR LOGICAL RECORD.
         BAL   R14,HGMOVE          MOVE IT TO USER BUFFER.
         LA    R14,HG010           IF NEXT BUFFER NEEDED,
         BC    1,HGSPEC            BRANCH FOR SPECIAL PROCESSING.
         LM    R0,R1,BFRBA         ELSE GET CURRENT RBA.
         STM   R0,R1,RPLRBAR       RETURN IT TO USER IN RPL.
         AL    R1,=F'1'            INCREMENT IT BY ONE
         ST    R1,BFRBA+4          AND SAVE FOR NEXT TIME.
         B     HERNORML            RETURN NORMALLY.
         EJECT
*
*              PROCESS UPDATE-FORM GET
*
HG100    DS    0H
         L     R2,RPLARG           POINT TO RBA TO LOCATE AND
         LM    R2,R3,0(R2)         LOAD IT INTO R2 AND R3.
         CLM   R3,7,=F'0'          IF LLL IS ZERO,
         BZ    HERINRBA            BAD RBA.
         CALL  HFINDRBA            TRY TO FIND RBA IN UBF.
         BNZ   HG110               BRANCH IF NOT FOUND.
* R1 IS SET BY HFINDRBA
         BAL   R14,HGMOVE          MOVE RECORD TO USER.
         BC    1,HERRDERD          SHOW PHYS READ ERR IF CC+3.
         SLR   R0,R0               SHOW NORMAL COMPLETION
         B     HRPLEXIT            AND RETURN TO CALLER.
*
*              RECORD IS SPANNED OR NOT IN BUFFER
*
HG110    LA    R1,BFDAT            IF UNPROTECTED BUFFER
         CL    R1,BFLOC            HAS NOTHING IN IT,
         BE    HG115               CONTINUE.
         L     R1,BFLOC            ELSE TRUNCATE
         MVI   LRCTLENG,LRCBFEND   AND WRITE
         LA    R0,HSVCEOBP         THE
         LR    R1,RRPL             UNPROTECTED BUFFER.
         SVC   HAMSVC              BUFFER.
         MVI   BFDAT,LRCBFEND      SHOW NO DATA IN IT.
HG115    LA    R0,HSVCGUPD         SET HAMSVC FUNCTION REGISTER.
         LR    R1,RRPL             SET HAMSVC ARGUMENT REGISTER.
         SVC   HAMSVC              ISSUE HAMSVC FOR GET-UPDATE.
         LTR   R0,R15              IF HAMSVC FOUND AN ERROR,
         BNZR  R15                 RETURN TO USER.
*
*              RECORD TO UPDATE NOW RESIDES IN ONE OR MORE HBFS
*
         L     RBUF,SDBHBF         POINT TO FIRST HBF.
HG120    DS    0H
         LTR   RBUF,RBUF           IF BUFFER POINTER ZERO,
         BZ    HERRDERD            SHOW PHYS READ ERROR.
         L     R1,SDBHBF           GET FIRST HBF               @OZ43706
         CR    R1,RBUF             IS IT FIRST BUF...          @OZ43706
         BE    HG1203              BRANCH IF YES               @OZ43706
HG1202   CLM   RBUF,7,BFBF+1-BFD(R1) FROM THIS ONE             @OZ43706
         BE    HG1201              YES                         @OZ43706
         L     R1,BFBF-BFD(R1)     GET NEXT BUF                @OZ43706
         B     HG1202              AND LOOP                    @OZ43706
HG1201   EQU   *                                               @OZ43706
         MVC   BFFL1,BFFL1-BFD(R1) MOVE FLAG                   @OZ43706
         NI    BFFL1-BFD(R1),255-BF1GSG RESET IN OLD           @OZ43706
HG1203   EQU   *                                               @OZ43706
         L     R1,BFLOC            POINT TO CORRECT RECORD.
         BAL   R14,HGMOVE          GO MOVE IT TO CALLER.
         LA    R0,0                SET R0 FOR NORMAL COMPLETION.
         L     RBUF,BFBF           GET POINTER TO NEXT HBF.
         BC    1,HG120             IF HGMOVE CC=3,CONTINUE.
         CLR   R0,RBUF             ELSE NEXT BUF PTR MUST BE 0.
         BNE   HERRDERD            SHOW PHYS READ ERROR IF NOT.
         B     HRPLEXIT            ELSE RETURN NORMALLY.
         EJECT
*
*              SPECIAL PROCESSING FOR HAMGET
*
HGSPEC   DS    0H
*
*              IF I/O IS ACTIVE, WAIT FOR IT TO COMPLETE
*
         TM    SDBFLG2,SDB2IOA     IS I/O ACTIVE...
         BZ    HGS020              BRANCH IF NOT               @OZ30886
         TM    SDBFLG2,SDB2IOE     IO ERR DETECTED BY HENDRD.  @OZ30886
         BO    HGS030              YES, GO PROCESS IO ERROR    @OZ30886
         TM    BFECB,X'40'         ELSE CHECK ECB.
         BO    HGS010              IF ALREADY POSTED, SKIP WAIT.
         TM    BFFL2,BF2IOC        HAS CEA LOOP DRIED UP...    @OZ30886
         BO    HGS020              BRANCH IF YES               @OZ30886
         WAIT  1,ECB=BFECB         WAIT FOR I/O COMPLETION.
HGS010   SLR   R0,R0               ZERO OUT
         ST    R0,BFECB            THE ECB.
         TM    BFFL1,BF1EOB        IF UBF NOT YET FILLED,            R4
         BO    HGSPEC              GO WAIT AGAIN               @OZ30886
         TM    SDBFLG2,SDB2EOD     END OF DATA DETECTED...     @OZ30886
         BZR   R14                 NO, RETURN                  @OZ30886
         OI    BFFL2,BF2IOC        SET IOC FOR NEXT TIME       @OZ30886
         BR    R14                 RETURN TO CALLER.
*
*              IF END-OF-BUFFER & I/O INACTIVE, ISSUE SVC
*
HGS020   DS    0H
         NI    BFFL2,255-BF2IOC    RESET IO STOPPED IND.       @OZ30886
         TM    BFFL1,BF1EOB        HAS CEA PRIMED BUFFER...    @OZ30886
         BZ    HGS010              RETURN TO USER IF YES       @OZ30886
         TM    SDBFLG2,SDB2IOE+SDB2EOD  IF EXCEPTIONAL
         BNZ   HGS030              CONDITION, BRANCH.
*              THIS LINE DELETED BY APAR NUMBER                @OZ30886
*              THIS LINE DELETED BY APAR NUMBER                @OZ30886
         LA    R0,HSVCEOBG         SET HAMSVC FUNCTION REGISTER.
         LR    R1,RRPL             SET HAMSVC ARGUMENT REGISTER.
         SVC   HAMSVC              ISSUE HAMSVC.
         LTR   R0,R15              IF HAMSVC FOUND NO ERROR,
         BNZ   HERRDERD            INDICATE ERROR              @OZ30886
         TM    SDBFLG2,SDB2EOD     DID EOD OCCUR...            @OZ30886
         BZR   R14                 NO, RETURN                  @OZ30886
         OI    BFFL2,BF2IOC        SET IOC FOR NEXT TIME       @OZ30886
         BR    R14                 RETURN                      @OZ30886
*
*              TREAT EXCEPTIONAL CONDITIONS HERE
*
HGS030   DS    0H
         TM    SDBFLG2,SDB2EOD     IF NOT END-OF-DATA-SET,
         BZ    HERRDERD            SHOW USER A READ ERROR.
         TM    SDBFLG2,SDB2XBIN    IF NOT XBM BATCH INPUT,
         BZ    HERNOEOD            SHOW USER END-OF-DATA.
*
*              END EXEC BATCH MON USER JOB HERE
*
         LR    R1,RRPL             POINT R1 TO THE RPL
         LA    R0,HSVCXBM          AND SET FUNC CODE IN R0.
         SVC   HAMSVC              CALL HAMSVC TO END JOB.
         B     *+4(R15)            BRANCH ACC TO R15.
         B     HG010               +0 - CONTINUE WITH NEW INPUT.
HGS035   MVI   BFECB,0             +4 - END BATCH MONITOR -    @OZ35973
         WAIT  ECB=BFECB           FAKE WAIT                   @OZ35973
         B     HGS035              SHOULD NEVER BE POSTED      @OZ35973
         TITLE 'HGMOVE - HAM GET SUBROUTINE'
*
*              HAM SUBROUTINE TO MOVE RECORD TO USER
*
HGMOVE   DS    0H
         LR    R4,R1               SET R4 FOR IF END-OF-BUFFER.
         TM    BFFL1,BF1GSG        IF RE-ENTRY FOR SEGMENT,
         BO    HGM100              BRANCH TO RE-ENTRY POINT.
*
*              INITIALIZE TO MOVE ANY RECORD
*
         TM    BFFL1,BF1EOB        IF END-OF-BUFFER OR ERROR,        R4
         BOR   R14                 RETURN CC=3 TO HANDLE.
         TM    LRCTLENG,LRCBFEND   IF NOT END-OF-BUFFER,
         BNO   HGM005              CONTINUE.
         OI    BFFL1,BF1EOB        OTHERWISE SET EOB FLAG,           R4
         TM    *+1,X'FF'           SET CONDITION CODE 3,
         BR    R14                 AND RETURN.
HGM005   DS    0H
         L     R2,RPLAREA          POINT TO USER BUFFER.
*
*              MOVE SIMPLE RECORD TO USER
*
         SLR   R5,R5               ZERO SOURCE LENGTH REG.
         SLR   R3,R3               ZERO SINK LENGTH REG.
         TM    SDBFLG1,SDB1PSO     IF DATA SET IS FOR PSO,
         BO    HGM040              GO PROCESS CARRIAGE CTRL.
         TM    LRCFLAG1,LRC1CCTL+LRC1SPAN+LRC1INUL  BRANCH IF
         BNZ   HGM040              NOT A SIMPLE RECORD.
         LA    R4,LRCTEXT          POINT TO SIMPLE TEXT START
HGM010   DS    0H            ENTRY FROM CARRIAGE-CONTROL.
         IC    R5,LRCTLENG         GET LENGTH TO MOVE.
         ICM   R5,8,=C' '          SET BLANK PAD.
         IC    R3,LRCLRECL         GET LENGTH OF RECORD.
HGM020   DS    0H            ENTRY FROM SINGLE-SEGMENT SPANNED.
         ST    R3,RPLRLEN          RETURN REC LENG TO USER.
         LR    R1,R3               SAVE RECORD LENGTH.
         L     R3,RPLBUFL          GET BUFFER LENGTH.
HGM030   DS    0H            ENTRY FROM PSO CARRIAGE CONTROL
         SLR   R1,R3               COMPUTE (REC LENG)-(BUF LENG).
         MVCL  R2,R4               MOVE RECORD TO BUFFER.
         LTR   R1,R1               IF REC LENG .GT. BUF LENG,
         BP    HERINBUF            ERROR - INVALID BUF SIZE.
         TM    SDBFLG2,SDB2XBIN    IF NOT XBM BATCH INPUT,
         BZ    HGMEND              GO TO EXIT CODE.
         L     R2,RPLAREA          POINT TO DATA JUST MOVED.
         CLC   =CL2'$$',0(R2)      IF NOT '$$',
         BNE   HGMEND              GO TO EXIT CODE.
         LA    R14,HERNOEOD        ELSE FORCE EXIT TO
         B     HGMEND              RETURN TO END-OF-FILE.
         SPACE 3
*
*              MOVE CARRIAGE-CONTROL RECORD TO USER
*
HGM040   DS    0H
         TM    LRCFLAG1,LRC1SPAN   BUT IF SPANNED, GO TO
         BO    HGM050              THE SPANNED-RECORD ROUTINE.
         TM    LRCFLAG1,LRC1INUL   AND IF NULL ON INPUT,
         BO    HGM070              SKIP OVER IT.
         TM    SDBFLG1,SDB1PSO     IF DATA SET IS NOT PSO,
         LA    R4,LRCSOUT          SKIP CARR CTRL CHARACTER
         BZ    HGM010              AND GO GIVE USER RECORD.
* PSO CARRIAGE CONTROL PROCESSING
         TM    LRCFLAG1,LRC1CCTL   IF CARR CTRL CHAR PRESENT,
         IC    R5,LRCCCTL          GET IT INTO REGISTER 5
         BO    HGM045              AND GO STORE IT IF REQ'D.
         LA    R4,LRCTEXT          OTHERWISE RESET TEXT PTR.
         LA    R5,X'40'            SET ASA SPACE-1-&-PRINT.
         TM    ACBCCTYP,ACBCCMCH   IF NOT MACHINE,
         BZ    HGM045              MUST BE ASA OR NONE.
         LA    R5,X'09'            SET MCH PRINT-&-SPACE-1.
HGM045   DS    0H
         TM    ACBCCTYP,ACBCCMCH+ACBCCASA  IF USER WANTS NOT,
         BZ    HGM010              BRANCH.
         STC   R5,0(,R2)           ELSE SET CARR CTRL FOR USER.
         LA    R2,1(,R2)           POINT TO NEXT USER AREA BYTE.
         IC    R3,LRCLRECL         GET LOGICAL RECORD LENGTH
         LA    R0,1(,R3)           & ADD 1 FOR CARR CTRL.
         ST    R0,RPLRLEN          RETURN LENGTH TO USER.
         IC    R5,LRCTLENG         GET TRUNCATED LENGTH.
         ICM   R5,8,=C' '          SET BLANK PADDING.
         LR    R1,R3               SET R1=RPLRLEN-1 FOR HGM030.
         L     R3,RPLBUFL          GET USER AREA LENGTH
         S     R3,=F'1'            (MINUS 1 FOR CARR CTRL)
         BP    HGM030              AND GO MOVE THE RECORD.
         B     HERINBUF            ERROR - USER AREA TOO SMALL.
         SPACE 3
*
*              MOVE SINGLE-SEGMENT SPANNED RECORD TO USER
*
HGM050   DS    0H
         TM    LRCFLAG1,LRC1SBGN   IF NOT FIRST SEGMENT,
         BZ    HERRDERD            SHOW PHYSICAL READ ERROR.
         LA    R4,LRCSFTXT         ELSE POINT TO THE TEXT
         LH    R5,LRCSEGL          AND GET SEGMENT LENGTH.
         LR    R3,R5               SET SINK LENGTH REGISTER.
         TM    LRCFLAG1,LRC1SEND   IF SINGLE-SEGMENT,
         BO    HGM020              GO MOVE IT.
*
*              MULTI-SEGMENT - MOVE FIRST SEGMENT TO USER
*
         LH    R0,LRCSRECL         GET TOTAL RECORD LENGTH.
         ST    R0,RPLRLEN          RETURN IT TO THE USER.
         CL    R0,RPLBUFL          IF BUFFER NOT LARGE ENOUGH,
         BH    HERINBUF            RETURN ERROR CODE.
         OI    BFFL1,BF1GSG        ELSE SET RE-ENTRY FLAG.
HGM060   DS    0H            ENTRY FROM RE-ENTRY CODE
         LR    R3,R5               SET SINK LENGTH TO SOURCE.
         MVCL  R2,R4               MOVE THIS SEGMENT TO USER.
         B     HGMEND              GO CHECK FOR EOB.
         SPACE 3
*
*              SKIP OVER NULL-ON-INPUT RECORD
*
HGM070   DS    0H
         IC    R5,LRCTLENG         GET TEXT LENGTH, POINT TO
         LA    R0,LRCSOUT(R5)      NEXT RECORD ASSUMING CCTL.
         TM    LRCFLAG1,LRC1CCTL   DOES RECORD CONTAIN CCTL...
         BO    *+8                 SKIP IF SO.
         LA    R0,LRCTEXT(R5)      POINT TO NEXT NON-CCTL RECORD.
         LR    R1,R0               SET REGISTER ONE
         B     HGMOVE              AND RE-ENTER HGMOVE.
         SPACE 3
*
*              MOVE NOT-FIRST SEGMENT TO USER
*
HGM100   DS    0H
         CLI   LRCTLENG,0          IF INVALID SPANNED FORMAT,
         BNE   HERRDERD            SHOW PHYS READ ERROR.
         TM    LRCFLAG1,LRC1SPAN   IF SPAN FLAG IS NOT ON,
         BZ    HERRDERD            SHOW PHYS READ ERROR.
         LA    R4,LRCSTEXT         POINT TO SEGMENT'S TEXT
         LH    R5,LRCSEGL          AND GET SEGMENT LENGTH.
         TM    LRCFLAG1,LRC1SEND   IF THIS SEGMENT IS NOT LAST,
         BZ    HGM060              GO MOVE & CHECK END-BUFFER.
         NI    BFFL1,255-BF1GSG    ELSE RESET RE-ENTRY SWITCH
         LR    R3,R5               SET SINK LENGTH REGISTER.
         MVCL  R2,R4               MOVE LAST SEGMENT.
HGMEND   DS    0H
         TM    RPLOPT2,RPLUPD      IF GET-UPDATE,
         BO    HGMEND1             JUST RETURN.
         ST    R4,BFLOC            SAVE NEXT RECORD ADDRESS.
         CLI   0(R4),LRCBFEND      IF IT'S NOT END OF BUF,
         BNE   HGMEND1             JUST RETURN.
         OI    BFFL1,BF1EOB        SET END-OF-BUFFER FLAG.           R4
HGMEND1  DS    0H
         TM    BFFL1,BF1GSG        SET CC=3 IF MORE SEGMENTS.
         BR    R14                 RETURN.
         TITLE '''PUT'' ACCESS METHOD ROUTINE'
*
*
*              HASP 'PUT' ACCESS METHOD
*
*
HAMPUT   DS    0H
         NI    BFFL1,255-BF1PSG-BF1PMV  RESET ENTRY FLAGS
*
*              PROCESS SEQUENTIAL NON-UPDATE PUT
*
         TM    RPLOPT2,RPLUPD      IS THIS AN UPDATE REQUEST...
         BO    HP100               BRANCH IF SO.
         SPACE 1
         TM    SDBFLG1,SDB1PUT     IS PUT VALID ON DATA SET...
         BZ    HERINVP             ERROR IF NOT.
         SPACE 1
         L     R6,SDBUBF           POINT TO UNPROTECTED BUFFER.
         BAL   R14,HPMOVE          LET HPMOVE DO THE WORK.
         ST    R1,BFLOC            SAVE ADR OF NEXT AVL BYTE.
         BC    8,HP020             RETURN TO USER              @OZ43719
*
*              HPMOVE REQUIRES ANOTHER BUFFER TO COMPLETE RECORD
*
         TM    SDBFLG2,SDB2IOE     IF I/O ERROR,
         BO    HERWTERD            RETURN ERROR TO USER.
         MVI   LRCTLENG,LRCBFEND   TRUNCATE CURRENT BUFFER.
         LA    R0,HSVCEOBP         SET HAMSVC FUNCTION REGISTER.
         LR    R1,RRPL             SET HAMSVC ARGUMENT REGISTER.
         SVC   HAMSVC              ISSUE HAMSVC.
         LTR   R15,R15             UNLESS SVC HAD AN ERROR,
         BZ    HPMOVE              TRY AGAIN TO MOVE DATA.
         BR    R15                 ERROR - TELL IT TO THE USER.
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
         PRINT OFF                                             @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
         PRINT ON                                              @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*
*              RETURN RBA TO USER
*
HP020    DS    0H
         L     R3,BFRBA+4          GET RIGHT HALF OF RBA.
         AL    R3,=F'1'            INCREMENT IT BY 1
         ST    R3,BFRBA+4          AND SAVE NEW RBA IN UBF.
*
*              COMPUTE SPACE LEFT IN UBF
*
         L     R2,BFLOC            GET PTR TO NEXT AVAIL BYTE.
         LA    R3,BFIO-1           COMPUTE                           R4
         AH    R3,$SVBFSIZ         SPACE AVAILABLE                   R4
         SLR   R3,R2               IN UBF.                           R4
         ST    R3,BFLEN            SAVE SPACE AVAIL IN UBF.
*
*              RETURN TO USER
*
         B     HERNORML            RETURN TO USER.
         EJECT
*
*              PROCESS PUT-UPDATE REQUEST
*
HP100    DS    0H
         L     R2,RPLARG           POINT TO RBA TO LOCATE AND
         LM    R2,R3,0(R2)         LOAD IT INTO R2 AND R3.
         CALL  HFINDRBA            SEE IF CURRENT UBF HAS THE RBA.
         BNZ   HP110               IF NOT, TRY HBFS.
*
*              MOVE RECORD INTO CURRENT UBF
*
         BAL   R14,HP190           CHECK LENGTH.
         L     R15,BFLOC           SAVE CURRENT BUF OFFSET IN R15.
         ST    R1,BFLOC            SET UPDATE LOCN IN BFLOC
         BAL   R14,HPMOVE          AND USE HPMOVE TO MOVE RECORD.
         ST    R15,BFLOC           RESTORE CURRENT BUFFER OFFSET.
         LA    R0,0                SHOW NORMAL COMPLETION.
         BC    8,HRPLEXIT          RETURN TO USER.
*
*              MOVE RECORD INTO HOLD BUFFERS
*
HP110    DS    0H
         L     RBUF,SDBHBF         POINT TO FIRST HOLD BUFFER.
         LTR   RBUF,RBUF           IF NO HOLD BUFFERS, ERROR -
         BZ    HERINUPD            PUT-UPDATE BEFORE GET-UPDATE.
         L     R1,BFLOC            POINT TO UPDATING RECORD.
         BAL   R14,HP190           VERIFY LENGTH IS CORRECT.
HP120    BAL   R14,HPMOVE          MOVE DATA FROM USER         @OZ16677
         LR    R1,RBUF             SAVE RBUF                   @OZ43706
         L     RBUF,BFBF           POINT TO NEXT HBF.
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
         BC    2,HP1201            REPEAT IF REQUIRED          @OZ43706
         LA    R0,HSVCPUPD         SET HAMSVC FUNCTION REGISTER.
         LR    R1,RRPL             SET HAMSVC ARGUMENT REGISTER.
         SVC   HAMSVC              ISSUE HAMSVC.
         LTR   R0,R15              TRANSFER RETURN CODE TO R0
         B     HRPLEXIT            AND RETURN TO USER.
HP1201   EQU   *                                               @OZ43706
         MVC   BFFL1,BFFL1-BFD(R1) MOVE FLAG                   @OZ43706
         NI    BFFL1-BFD(R1),255-BF1PSG-BF1PMV RESET IN OLDBF  @OZ43706
         L     R1,BFLOC            POINT TO NEXT SEG           @OZ43706
         B     HP120               AND LOOP                    @OZ43706
         SPACE 3
*
*              SUBROUTINE TO VERIFY UPDATE LENGTH
*
HP190    DS    0H
         SLR   R0,R0               ZERO R0 FOR RECORD ELNGTH.
         IC    R0,LRCTLENG         ASSUME NON-SPAN, GET LENGTH.
         TM    LRCFLAG1,LRC1SPAN   IS RECORD SPANNED...
         BZ    *+8                 IF NOT-, LENGTH OKAY.
         LH    R0,LRCSRECL         GET SPANNED-RECORD LENGTH.
         CL    R0,RPLRLEN          IS USER LENGTH CORRECT...
         BER   R14                 RETURN IF SO.
         B     HERDLCER            OTHERWISE DATA LENGTH ERROR.
         TITLE 'PUT/ENDREQ FOR INTERNAL READER'
*
*              ENTRY FOR PUT FOR INTRDR
*
HPIRDR   DS    0H
         USING DCTDSECT,RSDB       ESTABLISH DCT ADDRESSABILITY.
*
*              SET REQUEST TYPE FLAGS
*
*              THIS LINE DELETED BY APAR NUMBER                @OZ24894
         L     R2,RPLAREA          GET POINTER TO USER RECORD
         LA    R2,0(,R2)           CLEAR HI-ORDER BYTE               R4
         L     R3,RPLRLEN          AND GET ITS LENGTH.
         CL    R3,=F'5'            IF LENGTH LESS THAN 5,
         BL    HPI030              CAN'T BE /*EOF OR /*DEL.
         SLR   R0,R0               ZERO REGISTER TO HOLD FLAGS.
         CLC   =C'/*EOF',0(R2)     IS IT /*EOF...
         BNE   HPI010              SKIP IF NOT.
         LA    R0,RIDEOF           YES.  SET FLAG IN R0.
HPI010   CLC   =C'/*DEL',0(R2)     IS IT /*DEL...
         BE    HPI015              BR IF YES                        R41
         CLC   =C'/*PURGE',0(R2)   IS IT /*PURGE...                 R41
         BNE   HPI020              SKIP IF NOT.
HPI015   LA    R0,RIDDEL           SET DEL/PURGE FLAG IN R0         R41
HPI020   SLL   R0,24               SHIFT FLAG TO HIGH BYTE
         OR    R2,R0               AND ADD IT TO REG 2.
HPI030   BAL   R14,HINTRDR         CALL GENERALIZED INTRDR
         B     HRPLEXIT            SUBROUTINE AND RETURN.
         SPACE 3
*
*              ENTRY FOR ENDREQ FOR INTRDR
*
HENDI    DS    0H
*              THIS LINE DELETED BY APAR ===>                  @OZ41586
         LM    R2,R3,HENDIAD       GET DATA START, LENG, FLAGS
         BAL   R14,HINTRDR         AND CALL INTRDR SUBROUTINE.
         MVC   RPLRBAR,RIDJOBID    RETURN JOB ID TO USER IN RPL.
         B     HRPLEXIT            RETURN TO CALLER.
         SPACE 2
HENDIAD  DS    0F
         DC    AL1(RIDERQ)         FLAGS - ENDREQ
         DC    AL3(*+7)            DATA ADDRESS
         DC    A(5)                DATA LENGTH
         DC    C'/*EOF'            DATA
         TITLE 'INTRDR ACCESS METHOD ROUTINE'
*
*              GENERALIZED INTRDR SUBROUTINE
*
HINTRDR  DS    0H
RIDEOF   EQU   X'08'               PUT REQUEST FOR /*EOF
RIDDEL   EQU   X'04'               PUT REQUEST FOR /*DEL OR /*PURGE R41
RIDERQ   EQU   X'02'               ENDREQ REQUEST
RIDCLS   EQU   X'01'               CLOSE REQUEST
*
*              IF NO INTRDR BUFFERS, GET THEM
*
         L     RBUF,RIDUBF         POINT TO BUFFER.
         LTR   RBUF,RBUF           DOES IT EXIST...
         BNZ   HIR010              IF SO, CONTINUE.
         L     R0,HIRCLS           NO BUFFER.  IS THIS
         NR    R0,R2               A CALL FROM CLOSE...
         BNZ   HIREND              IF SO, RETURN.
         BAL   R4,HIRSVC           CALL HAMSVC TO GET BUFFERS.
         L     RBUF,RIDUBF         POINT TO UNPROTECTED BUFFER.
*
*              IF RECORD WON'T FIT, ISSUE HAMSVC
*
HIR010   DS    0H
         STCM  R2,8,BFFL1          SAVE ENTRY FLAGS IN BFFL1.
         CL    R3,=F'254'          IS RECORD TOO LONG...
         BH    HIRERR1             IF SO, ERROR.
         LTR   R3,R3               IF NOT ZERO-LENGTH,
         BNZ   *+16                SKIP.
         LA    R2,=C' '            ELSE SET ONE BLANK,
         ICM   R2,8,BFFL1          INTRDR FLAGS,
         LA    R3,1                AND LENGTH OF ONE.
         LA    R5,LRCTEXT-LRCDSECT(,R3)  COMPUTE REAL REC LENGTH
         CL    R5,BFLEN            AND SEE IF IT WILL FIT.
         BNH   HIR020              IF IT WILL, GO MOVE IT.
         MVI   BFFL1,0             ZERO FLAGS BEFORE USING SVC.
         BAL   R4,HIRSVC           IF IT WON'T, ISSUE SVC.
         STCM  R2,8,BFFL1          RESTORE FLAGS AFTER SVC.
*
*              MOVE RECORD TO BUFFER
*
HIR020   DS    0H
         L     R1,BFLOC            GET LOCATION IN BUFFER.
         LA    R4,BFDAT            GET ADDR OF END             @OZ29839
         AL    R4,=A(RIDBUFSZ-(BFDAT-BFD))  OF BUFFER.         @OZ29839
         CR    R4,R1               COMPARE BFLOC TO END.       @OZ29839
         BNH   HERBLKER            ABEND1FA,BUFLOC TOO LARGE.  @OZ29839
         CR    RBUF,R1             COMPARE BFLOC TO START.     @OZ29839
         BNL   HERBLKER            ABEND1FA,BFLOC TOO SMALL.   @OZ29839
         STC   R3,LRCTLENG         SET TEXT LENGTH.
         STC   R3,LRCLRECL         SET ORIGINAL RECORD LENGTH.
         MVI   LRCFLAG1,0          SET FLAGS TO ZERO.
         LA    R4,LRCTEXT          POINT R4 TO LRCTEXT FOR MVCL.
         LCR   R5,R5               COMPLEMENT REAL LENGTH.
         AL    R5,BFLEN            COMPUTE NEW REMAINING LENGTH
         ST    R5,BFLEN            AND SAVE FOR NEXT TIME.
         LR    R5,R3               SET SINK LENGTH TO SOURCE.
         MVCL  R4,R2               MOVE RECORD TO BUFFER.
         ST    R4,BFLOC            SAVE NEW BUF LOC FOR NEXT TIME.
         EJECT                                                      R41
*
*              IF /*EOF /*DEL /*PURGE ENDREQ OR CLOSE, ISSUE HAMSVC R41
*
         TM    BFFL1,RIDEOF+RIDDEL+RIDERQ+RIDCLS  IF ALL OFF,
         BZ    HIREND              RETURN TO CALLER.
         BAL   R4,HIRSVC           ELSE CALL SVC.
*
*              NORMAL EXIT
*
HIREND   DS    0H
         SLR   R0,R0               SHOW NORMAL COMPLETION.
         BR    R14                 RETURN TO CALLER.
*
*              ERROR EXIT - RECORD TOO LONG
*
HIRERR1  L     R0,=A(RPLINLEN+65536*RPLLOGER)  SET CODE
         BR    R14                 AND RETURN TO CALLER.
*
*              SUBROUTINE TO ISSUE HAMSVC FOR INTRDR
*
HIRSVC   DS    0H
         LA    R0,HSVCIRD          SET HAMSVC FUNCTION REGISTER
         LCR   R1,RACB             AND HAMSVC ARGUMENT REGISTER.
         SVC   HAMSVC              ISSUE HAMSVC.
         LTR   R0,R15              IF NORMAL RETURN FROM SVC,
         BZR   R4                  RETURN TO USER.
         BR    R14                 ELSE RETURN CODE TO CALLER.
*
*              CONSTANTS
*
HIRCLS   DC    0A(0),AL1(RIDCLS),AL3(0)  CONSTANT TO TEST CLOSE
         USING SDBDSECT,RSDB       RE-ESTABLISH SDB BASE.
         TITLE 'HPMOVE - HAM PUT SUBROUTINE'
*
*              HAM SUBROUTINE TO MOVE RECORD FROM USER
*
         CNOP  4,8
HPMOVE   DS    0H
         TM    BFFL1,BF1PSG+BF1PMV TEST FOR RE-ENTRY.
         BO    HPM200              BRANCH IF RE-ENTRY FOR SEGMENT.
         BM    HPM020              BRANCH IF RE-ENTRY FOR RECORD.
         L     R2,RPLAREA          POINT R2 TO USER DATA AREA AND
         LA    R2,0(,R2)           CLEAR HI-ORDER BYTE               R4
         LH    R3,RPLRLEN+2        SET R3 TO USER DATA LENGTH.
         LTR   R3,R3               TEST USER DATA LENGTH.
         BM    HERRECLN            ERROR IF NEGATIVE.
         BP    *+12                OKAY IF POSITIVE.
         LA    R2,=C' '            IF ZERO LENGTH, MAKE
         LA    R3,1                THE TEXT ONE BLANK.
*
*              SHOW INITIAL ENTRY.  CHECK SPAN REQUIREMENTS.
*
         OI    BFFL1,BF1PMV        SHOW INITIAL ENTRY.
         CL    R3,=F'254'          DOES RECORD REQUIRE SPANNING...
         BH    HPM100              BRANCH IF SO.
*
*              TRUNCATE TRAILING BLANKS IF REQUIRED.
*
         TM    SDBFLG1,SDB1OUT     IF DATA SET NOT MARKED SYSOUT,
         BZ    HPM010              NO TRUNCATION REQUIRED.
         LA    R1,0(R2,R3)         R1 = END OF DATA PLUS 1.
         BCTR  R1,0                BACK UP 1 CHARACTER.
         CLI   0(R1),C' '          TEST LAST CHARACTER FOR BLANK.
         BNE   HPM010              BR IF NO.
         LA    R4,7                SET R4 TO VALUE 7.
         CLR   R3,R4               TEST ORIGINAL COUNT.
         BNH   HPM004              BR IF LESS THAN 8 CHARACTERS.
         NR    R4,R1               R4 = BYTES BEYOND LAST DBL-WORD
         SLR   R1,R4               R1 = LAST DBL-WORD WITHIN DATA.
         EX    R4,HPMBLTST         TEST FOR BLANKS AT END OF LINE.
         BNE   HPM010              BR IF NO.
         L     R4,=F'-8'           'INCREMENT' FOR FOLLOWING LOOP.
         LR    R5,R2               R5 = ADDRESS OF FIRST DATA BYTE
         SPACE 1
         BXLE  R1,R4,HPM006        BACK UP 1 DOUBLE-WORD.
         CLC   0(8,R1),HPMBLNKS    TEST FOR DOUBLE-WORD OF BLANKS.
         BE    *-10                BR IF SO.
         B     HPM008              ELSE BR TO GET LINE LENGTH.
*
*        CONSTANTS USED BY BLANK TRUNCATION ROUTINE.
*
HPMBLTST CLC   0(*-*,R1),HPMBLNKS  *** EXECUTE ONLY ***
HPMBLNKS DC    0D'0',CL8' '        DOUBLE-WORD OF BLANKS
*
*        TRUNCATE BLANKS FROM 'SHORT' LINE.
*
HPM002   BCTR  R1,0                BACK UP 1 CHARACTER.
         CLI   0(R1),C' '          TEST FOR BLANK.
         BNE   HPM010              BR IF NO.
HPM004   BCT   R3,HPM002           REDUCE COUNT BY 1.
*
*        SET COUNT FOR ALL-BLANK LINE.
*
HPM005   LA    R3,1                SET COUNT FOR ALL-BLANK LINE.
         B     HPM010              BR TO MOVE LINE.
*
*        TEST FOR ALL-BLANK LINE.
*
         CNOP  0,8
HPM006   CLC   0(8,R5),HPMBLNKS    TEST FOR ALL-BLANK LINE.
         BE    HPM005              BR IF SO.
*
*        COMPUTE LENGTH OF NON-BLANK LINE.
*
HPM008   LA    R3,8(,R1)           LAST KNOWN BLANK CHARACTER.
         SLR   R3,R5               REMAINING CHARACTERS IN RECORD.
*
*              COMPUTE TOTAL LRC LENGTH REQUIRED
*
HPM010   LA    R4,LRCSOUT-LRCDSECT(,R3)  ASSUME CONTROL CHAR.
         L     R5,RPLCCHAR         IF RPLCCHAR DOES NOT
         LTR   R5,R5               POINT TO ZERO,
         BNZ   HPM020              TEXT STARTS AT LRCSOUT.
         LA    R4,LRCTEXT-LRCDSECT(,R3)  TEXT STARTS AT LRCTEXT.
*
*              SEE IF RECORD WILL FIT (RE-ENTER HERE)
*
HPM020   L     R1,BFLOC            POINT TO FIRST AVAILABLE BYTE.
         TM    RPLOPT2,RPLUPD      IF PUT-UPDATE,
         BO    HPM025              DO NOT CHECK LENGTH.
         C     R4,BFLEN            IS SPACE LARGE ENOUGH...
         BHR   R14                 IF NOT, RETURN CC=2.
*
*              COMPUTE FLAG BYTE AND SET LRCCCTL
*
HPM025   DS    0H
         LTR   R5,R5               IF NO CARRIAGE CONTROL,
         BZ    HPM040              FLAG BYTE IS ZERO.
         MVC   LRCCCTL,0(R5)       ELSE SET LRCCCTL FROM USER DATA
         LA    R5,LRC1CCTL         AND FLAG BYTE AS LRC1CCTL.
         TM    ACBCCTYP,ACBCCMCH   IF ACB SPECIFIES
         BZ    HPM030              MACHINE CONTROL CHARACTERS,
         LA    R5,LRC1TMCH(,R5)    SPECIFY ALSO IN FLAG BYTE.
         TM    LRCCCTL,2           TEST FOR 'IMMEDIATE' COMMAND.
         BZ    HPM040              BR IF NO.
         SLR   R3,R3               ELSE SET DATA LENGTH TO ZERO
         LA    R4,LRCSOUT-LRCDSECT AND RESET TOTAL LRC LENGTH.
         B     HPM040              THEN BR TO MOVE DATA.
*
*        TEST FOR ASA CONTROL CHARACTERS.
*
HPM030   TM    ACBCCTYP,ACBCCASA   IF ACB SPECIFIES
         BZ    *+8                 ASA CONTROL CHARACTERS,
         LA    R5,LRC1TASA(,R5)    SPECIFY ALSO IN FLAG BYTE.
*
*              SET LENGTH AND FLAGS, AND MOVE RECORD
*
HPM040   STC   R3,LRCTLENG         SET TEXT LENGTH IN LRC.
         IC    R0,RPLRLEN+3        GET ORIGINAL RECORD LENGTH
         STC   R0,LRCLRECL         AND SAVE IT IN RECORD.
         STC   R5,LRCFLAG1         SET FLAGS IN LRC.
         SLR   R4,R3               COMPUTE LRC HEADER LENGTH.
         ALR   R4,R1               COMPUTE TEXT ADDRESS.
         LR    R5,R3               SET LENGTHS EQUAL,
         NI    BFFL1,255-BF1PSG-BF1PMV  RESET ENTRY FLAGS, AND
         MVCL  R4,R2               MOVE USER TEXT INTO LRC.
         TM    RPLOPT2,RPLUPD      UNLESS THIS IS
         BO    *+10                PUT-UPDATE,
         MVC   RPLRBAR,BFRBA       RETURN RBA TO CALLER.
         LR    R1,R4               RETURN NEXT AVAILABLE BYTE AND
         SR    R0,R0               CONDITION CODE ZERO
         BR    R14                 TO CALLER.
         SPACE 3
*
*              FIRST-SEGMENT SPANNED-RECORD PROCESSING
*
HPM100   DS    0H
         OI    BFFL1,BF1PSG        SHOW FIRST SEGMENT PROCESSED.
         TM    RPLOPT2,RPLUPD      IF PUT-UPDATE,
         BO    HPM110              DO NOT CHECK LENGTH.
         LA    R0,255+LRCSFTXT-LRCDSECT  REQUIRE REASONABLE MINIMUM  R4
         CL    R0,BFLEN            FOR FIRST SEGMENT.
         BL    HPM110              BRANCH IF MIN AVAILABLE.
         NI    BFFL1,255-BF1PSG-BF1PMV  ELSE RESET FLAGS,
         L     R1,BFLOC            SET BFLOC IN R1 FOR CALLER,
         SLR   R0,R0               SET CC = 2,
         BR    R14                 AND RETURN TO CALLER.
*
*              CREATE FIRST SEGMENT
*
HPM110   DS    0H
         L     R1,BFLOC            POINT TO FIRST AVAIL LRC BYTE.
         MVI   LRCTLENG,0          SET ZERO NON-SPAN LENGTH.
         L     R5,BFLEN            GET LENGTH AVAILABLE.
         SL    R5,=A(LRCSFTXT-LRCDSECT)  DECR BY 1ST-SEG HDR LENG.
         MVI   LRCFLAG1,LRC1SPAN+LRC1SBGN  SET FLAGS.
         STH   R3,LRCSRECL         SET TOTAL RECORD LENGTH IN LRC.
         LA    R4,LRCSFTXT         POINT TO FIRST-SEG TEXT START.
         TM    RPLOPT2,RPLUPD      IS THIS PUT OR PUT UPDATE   @OZ16677
         BNO   HPM113              BRANCH IF PUT               @OZ16677
         LH    R5,LRCSEGL          LOAD SEGMENT LENGTH         @OZ16677
         CLR   R3,R5               IS THIS THE ONLY SEGMENT    @OZ16677
         BE    HPM120              BRANCH IF YES               @OZ16677
         B     HPM117              MOVE FIRST SEGMENT          @OZ16677
HPM113   DS    0H                                              @OZ16677
         CLR   R3,R5               WILL WHOLE REC FIT IN SPACE...
         BNH   HPM120              BRANCH IF SO.
         STH   R5,LRCSEGL          NO.  SET FIRST SEGMENT LENGTH.
HPM117   DS    0H                                              @OZ16677
         MVCL  R4,R2               MOVE FIRST SEGMENT TO LRC.
         TM    RPLOPT2,RPLUPD      UNLESS THIS IS
         BO    *+10                PUT-UPDATE,
         MVC   RPLRBAR,BFRBA       RETURN RBA TO CALLER.
         LR    R1,R4               RETURN NEXT BYTE ADR IN R1.
         SLR   R0,R0               SET CC = 2
         BR    R14                 AND RETURN TO CALLER.
*
*              CREATE FIRST AND ONLY SEGMENT
*
HPM120   DS    0H
         MVI   LRCFLAG1,LRC1SPAN+LRC1SBGN+LRC1SMID+LRC1SEND  FLAG
         NI    BFFL1,255-BF1PSG-BF1PMV  RESET ENTRY FLAGS.
         STH   R3,LRCSEGL          SET SEGMENT LENGTH.
         LR    R5,R3               SET SINK LENGTH TO SOURCE LENG.
         MVCL  R4,R2               MOVE ENTIRE RECORD TO LRC.
         TM    RPLOPT2,RPLUPD      TEST FOR PUT UPDATE               R4
         BO    SKIP410             BR IF YES                         R4
         MVC   RPLRBAR,BFRBA       RETURN RBA TO CALLER              R4
SKIP410  LR    R1,R4               RETURN NEXT BYTE ADDRESS IN R1    R4
         SR    R0,R0               SET CC = 0                        R4
         BR    R14                 RETURN TO CALLER                  R4
         SPACE 3
*
*              CREATE SUBSEQUENT SEGMENT (RE-ENTER HERE)
*
HPM200   DS    0H
         L     R1,BFLOC            POINT TO FIRST BYTE AVAILABLE.
         MVI   LRCTLENG,0          SET ZERO NON-SPAN LENGTH.
         LH    R5,LRCSEGL          LOAD R5 FOR PUT-UPDATE      @OZ16677
         TM    RPLOPT2,RPLUPD      IS THIS PUT, OR PUTUPDATE   @OZ16677
         BO    HPM205              BRANCH IF UPDATING          @OZ16677
         L     R5,BFLEN            GET AVAIL LENG AND DECREMENT
         SL    R5,=A(LRCSTEXT-LRCDSECT)  BY NOT-1ST-SEG HDR LENG.
HPM205   DS    0H                                              @OZ16677
         LA    R4,LRCSTEXT         POINT TO NOT-1ST-SEG TEXT.
         MVI   LRCFLAG1,LRC1SPAN+LRC1SMID  SET MIDDLE SEG FLAGS.
         CLR   R3,R5               WILL REST OF RECORD FIT...
         BNH   HPM210              IF SO, BRANCH TO LAST SEG.
         STH   R5,LRCSEGL          SET MIDDLE SEGMENT LENGTH.
         MVCL  R4,R2               MOVE TEXT TO MIDDLE SEGMENT.
         LR    R1,R4               RETURN NEXT BYTE ADR IN R1.
         SLR   R0,R0               SET CC = 2
         BR    R14                 AND RETURN TO CALLER.
*
*              CREATE LAST SEGMENT
*
HPM210   DS    0H
         STH   R3,LRCSEGL          SHOW REMAINING LENG THIS SEG.
         LR    R5,R3               SET SINK LENGTH TO SOURCE LENG.
         XI    LRCFLAG1,LRC1SMID+LRC1SEND  SHOW END SEGMENT.
         NI    BFFL1,255-BF1PSG-BF1PMV  RESET ENTRY FLAGS.
         MVCL  R4,R2               MOVE TEXT TO LAST SEGMENT.
         LR    R1,R4               RETURN TO CALLER WITH R1 = NEXT
         BR    R14                 BYTE AND CC=0 (FROM MVCL).
         TITLE 'HAM ''POINT'' ACCESS METHOD'
*
*
*              HASP 'POINT' ACCESS METHOD
*
*
HAMPOINT DS    0H
*
*              SEE IF UNPROTECTED BUFFER ALREADY CONTAINS RECORD
*
HT00     DS    0H
         L     R1,RPLARG           POINT TO RBA TO POINT TO.
         MVC   BFRBA,0(R1)         MOVE ARG RBA TO BFRBA.
         LA    R0,1                GET CONSTANT 1.
         CLM   R0,7,BFRBA+5        IF LOGICAL RECORD NUMBER
         BNH   *+8                 IS ZERO,
         STCM  R0,7,BFRBA+5        MAKE IT ONE.
         CLC   BFRBA+1(4),=XL4'0'  IF MTTR PORTION NOT ZERO,
         BNE   HT10                CONTINUE.
         MVC   BFRBA+1(4),SDBTRKF+1  ELSE SET TO START OF DS.
HT10     DS    0H
*
*              USE HAMSVC TO READ IN THE CORRECT BLOCK
*
         LA    R0,HSVCPNT          SET HAMSVC FUNCTION REGISTER.
         LR    R1,RRPL             SET HAMSVC ARGUMENT REGISTER.
         SVC   HAMSVC              ISSUE HAMSVC.
         LTR   R0,R15              TRANSFER RETURN CODE TO R0
         BNZR  R15                 ERROR EXIT IF POINT FAILED.
         B     HRPLEXIT            AND EXIT.
         TITLE 'HAM ''ENDREQ'' ACCESS METHOD'
*
*
*              HASP 'ENDREQ' ACCESS METHOD
*
*
HAMENDRE DS    0H
         LR    R1,RRPL             SET RPL REGISTER.
         LA    R0,HSVCENDR         SET FUNCTION REGISTER.
         SVC   HAMSVC              ISSUE SVC FOR ENDREQ.
         LTR   R0,R15              IF R15 CONTAINS A POINTER,
         BNZR  R15                 ERROR - TAKE EXIT.
         SPACE 1                                               @OZ44947
         L     R1,SDBSJB           TEST FOR SYSMSG DATASET     @OZ44947
         LA    RSDB,SJBMACB-SJBDSECT(,R1) BY COMPARING         @OZ44947
         CLM   RSDB,7,RPLDACB+1      ACB ADDRESS               @OZ44947
         BNE   HRPLEXIT               BR IF NOT SYSMSG DS      @OZ44947
         SPACE 1                                               @OZ44947
         LA    R1,SJBLRPL-SJBDSECT(,R1) PT. TO RPL FOR JL DS   @OZ44947
         LA    R0,RPLENDRE          RESET FUNCTION REGISTER    @OZ44947
         B     HAMREDO               AND ISSUE ENDREQ FOR IT   @OZ44947
         TITLE 'HAM -- RPL RETURN PROCESSING'                  @OZ44947
*
*
*              RPL ERROR RETURNS -- LOGICAL
*
*
         SPACE 1
HERNOEOD LA    R0,RPLEODER         END-OF-DATA OCCURRED.
         B     HERLOGER
HERSPACE LA    R0,RPLNOEXT         NO SPOOL SPACE IS LEFT.
         B     HERLOGER
HERINRBA LA    R0,RPLINRBA         BAD RBA - POINT, GET-UPD.
         B     HERLOGER
HERSTOR  LA    R0,RPLNOVRT         GETMAIN FAILED.
         B     HERLOGER
HERINBUF LA    R0,RPLINBUF         NO ROOM IN USER BUF - GET.
         B     HERLOGER
HERINVP  LA    R0,RPLINACC         E.G., GET ON OUTPUT DATA SET.
         B     HERLOGER
HERINUPD LA    R0,RPLINUPD         PUT-UPD BEFORE GET-UPD.
         B     HERLOGER
HERDLCER LA    R0,RPLDLCER         PUT-UPD WOULD CHANGE LENGTH.
         B     HERLOGER
HERRECLN LA    R0,RPLINLEN         E.G., SYSOUT LENGTH GREATER THAN 254
         B     HERLOGER
         SPACE 1
HERLOGER AL    R0,=A(RPLLOGER*65536)  SET LOGICAL ERROR.
         B     HRPLEXIT            START RETURNING TO USER.
         SPACE 3
*
*
*              RPL ERROR RETURNS -- PHYSICAL
*
*
         SPACE 1
HERRDERD LA    R0,RPLRDERD         PHYS RD ERR OR KEY MISMATCH.
         B     HERPHYER
HERWTERD LA    R0,RPLWTERD         PHYSICAL WRITE ERROR.
         SPACE 1
HERPHYER AL    R0,=A(RPLPHYER*65536)  SET PHYSICAL ERROR.
         B     HRPLEXIT            START RETURNING TO USER.
         SPACE 3
*
*
*              RPL ERROR RETURNS -- CONTROL BLOCK
*
*
HERBLKER ABEND X'1FA',DUMP,,SYSTEM  CONTROL BLOCK ERROR.
         SPACE 3
*
*              RPL NORMAL RETURN - NO ERROR
*
HERNORML SLR   R0,R0               SHOW NO ERROR AT ALL.
         EJECT
*
*              HRPLEXIT - RETURN CODE (IN R0) TO CALLER
*
HRPLEXIT DS    0H
         STCM  R0,7,RPLFDBK        SET COMPLETION CODE IN RPL.
         MVI   RPLCMPON,2          SET COMPONENT ID.
         SRL   R0,16               RIGHT-JUSTIFY RPLRTNCD &
         ST    R0,16(,R13)         SET IT IN R15 SLOT.
* POST CALLER'S ECB
         LA    R1,RPLECB           ASSUME INTERNAL ECB.
         TM    RPLOPT1,RPLECBSW    IF INTERNAL ECB,
         BZ    *+8                 SKIP.
         L     R1,RPLECB           POINT TO EXTERNAL ECB.
         MVI   0(R1),X'40'         POST THE ECB.
         LTR   R0,R0               IF NO ERROR INDICATED,
         BZ    HEX200              GO RETURN TO CALLER.
*
*              ERROR INDICATED - SEE IF USER EXIT APPLIES
*
         L     R4,ACBEXLST         POINT TO ACB'S EXIT LIST.
         CL    R4,=F'1'            IF POINTER IS 0 OR 1,
         BNH   HEX200              THERE'S NO EXIT LIST.
         USING IFGEXLST,R4         SET EXLST ADDRESSABILITY.
         CLI   EXLID,EXLIDD        IS IDENTIFIER OKAY...
         BNE   HEX200              IF NOT, IGNORE EXIT LIST.
* ASSUME END-OF-FILE EXIT
         LA    R2,EXLEODF          POINT TO EOD ENTRY.
         LA    R3,EXLEODL          GET MIN LENGTH FOR IT.
         CLI   RPLRTNCD,RPLLOGER   IF NOT LOGICAL ERROR,
         BNE   HEX020              IT MUST BE PHYSICAL ERROR.
         CLI   RPLERRCD,RPLEODER   LOGICAL.  IF EOD,
         BE    HEX100              GO TAKE USER EXIT.
* ASSUME OTHER LOGICAL ERROR THAN END-OF-FILE
         LA    R2,EXLLERF          POINT TO LOGICAL ERROR ENTRY.
         LA    R3,EXLLERL          GET MIN LENGTH FOR IT.
         B     HEX100              GO TAKE USER EXIT.
* ASSUME PHYSICAL ERROR
HEX020   DS    0H
         LA    R2,EXLSYNF          POINT TO PHYSICAL ERROR ENTRY.
         LA    R3,EXLSYNL          GET MIN LENGTH FOR IT.
*
*              IF THE APPROPRIATE EXIT ROUTINE EXISTS, ENTER IT
*
HEX100   DS    0H
         CH    R3,EXLLEN           IS EXIT LIST LONG ENOUGH...
         BH    HEX200              IF NOT, NO USER EXIT.
         USING IFGEXLEF,R2         SET ENTRY ADDRESSABILITY.
         TM    EXLFLAG,EXLPRES+EXLACTV  IF ENTRY NOT PRESENT &
         BNO   HEX200              ACTIVE, NO USER EXIT.
         $ALGN L,R0,EXLEXITP       GET ENTRY'S ADDRESS.
         TM    EXLFLAG,EXLLINK     IF IT POINTS TO EXIT CODE,
         BZ    HEX150              GO TAKE USER EXIT.
         LOAD  EPLOC=(0)           ELSE LOAD USER EXIT ROUTINE.
         $ALGN ST,R0,EXLEXITP      SAVE ADDRESS IN EXLST ENTRY.
         NI    EXLFLAG,255-EXLLINK SHOW ENTRY POINTS TO CODE.
HEX150   DS    0H
         LM    R1,R12,24(R13)      RESTORE R1 THROUGH R12.
         LR    R15,R0              SET R15 = USER EXIT ENTRY PT.
         BALR  R14,R15             TAKE USER EXIT.
HEX200   DS    0H                  IF USER EXIT RETURNS,
         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS
         BR    R14                 AND RETURN TO CALLER.
         SPACE 3
         DROP  ,                   DROP ALL ADDRESSABILITY.
         TITLE 'HAM SUBROUTINE TO FIND RBA IN UBF'
*
*
*              HAM SUBROUTINE TO FIND RBA IN UBF
*
*
HFINDRBA DS    0H
         USING SDBDSECT,RSDB
         USING BFD,RBUF
         USING LRCDSECT,R1
         USING *,R15               SET LOCAL ADDRESSABILITY.
         SR    R0,R0               ZERO OUT LRC LENGTH REGISTER.
         SLDL  R2,8                R2 = MTTR
         SRL   R3,8                R3 = LOGICAL RECORD NR.
         $ALGN S,R2,BFRBA+1        IS THE MTTR CORRECT...
         BNZR  R14                 IF NOT, RETURN NONZERO CC & R2.
         LA    R1,BFDAT            POINT TO FIRST LOGICAL RECORD.
HFR010   DS    0H
         ALR   R1,R0               POINT TO NEXT LOGICAL RECORD.
         TM    LRCTLENG,LRCBFEND   IF IT'S END-OF-BUFFER,
         BOR   R14                 RETURN NONZERO CC.
         SPACE 1
         SR    R5,R5               ZERO R5 FOR IC.
         IC    R5,LRCTLENG         GET TEXT LENGTH IN R5.
         TM    LRCFLAG1,LRC1CCTL+LRC1SPAN  IS IT NOT SYSOUT NOR SPAN...
         LA    R4,LRCTEXT          SET NORMAL TEXT START
         LA    R0,LRCTEXT-LRCDSECT(,R5)  AND OFFSET TO NEXT LR.
         BZ    HFR020              BRANCH IF NORMAL RECORD.
         TM    LRCFLAG1,LRC1CCTL   IS IT SYSOUT...
         LA    R4,LRCSOUT          SET SYSOUT TEXT START
         LA    R0,LRCSOUT-LRCDSECT(,R5)  AND OFFSET TO NEXT LR.
         BO    HFR020              BRANCH IF SYSOUT RECORD.
         LA    R4,LRCSFTXT         GET SPANNED-RECORD START
         LH    R5,LRCSEGL          AND LENGTH
         LA    R0,LRCSFTXT-LRCDSECT(,R5)  AND OFFSET TO NEXT LR.
         TM    LRCFLAG1,LRC1SBGN   IF FIRST SEGMENT,
         BO    HFR020              COUNT RECORD & CONTINUE.
         LA    R0,LRCSTEXT-LRCDSECT(,R5)  IF NOT FIRST SEGMENT,
         B     HFR010              DO NOT COUNT RECORD.
HFR020   BCT   R3,HFR010           COUNT A RECORD.
         SR    R0,R0               REQUESTED RECORD IS FOUND.
         BR    R14                 RETURN ZERO CC.
         DROP ,                    DROP ALL BASES.
         TITLE 'HAM LITERAL POOL'
         LTORG
         TITLE 'HAMSVC --- ENTERED FROM SVC 111'
*
*
*              HASP ACCESS METHOD SUPERVISOR CALL
*
*
SVCHAM   DS    0H
         BALR  R12,0               ESTABLISH
SVCHBASE DS    0H                  LOCAL ADDRESSABILITY.
         USING *,R12
         USING DEBBASIC,R2         USE THE DEB DSECT.
         LR    RRPL,R1             SET RPL BASE REGISTER.
         USING IFGRPL,RRPL         USE RPL ADDRESSABILITY.
         L     RSDB,DEBIRBAD       POINT TO THE SDB.
         LTR   R3,R1               IF R1 IS ACB COMPLEMENT,
         BM    *+8                 SKIP ACB POINTER LOAD.
         L     R3,RPLDACB          POINT TO ACB FROM RPL.
         LPR   R3,R3               MAKE ACB POINTER POSITIVE.
         USING IFGACB,R3           SET ACB ADDRESSABILITY.
         TM    ACBINRTN,ACBINR     IS ACB FOR INTERNAL READER...
         BZ    SVCH10              IF NOT, PROCESS SDB.
         DROP  R3                  DROP ACB ADDRESSABILITY.
*
*              INTERNAL READER INITIALIZATION
*
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY      @OZ41431
         CLC   SDBID,=CL4'SDB '    IS THIS BLOCK A SDB ?       @OZ41431
         BE    SVCERRET            YES, SET ERROR RETURN       @OZ41431
         USING DCTDSECT,RSDB       SET DCT ADDRESSABILITY      @OZ41431
         L     RSVT,RIDSSVT        POINT TO SUBSYS VECTOR TABLE.
         B     SVCIRD              GO PROCESS INTRDR REQUEST.
*
*              NORMAL SUBSYSTEM DATA SET INITIALIZATION
*
SVCH10   DS    0H
         USING SDBDSECT,RSDB       SET SDB ADDRESSABILITY.
         CLC   SDBID,=CL4'SDB '    IS THIS BLOCK A SDB ?       @OZ41431
         BNE   SVCERRET            NO, SET ERROR RETURN.       @OZ41431
         L     RSVT,SDBSVT         POINT TO SUBSYS VECTOR TABLE.
         USING $SVDSECT,RSVT       USE THE SSVT DSECT.
         L     RSJB,SDBSJB         POINT TO THE SJB AND
         USING SJBDSECT,RSJB       SET ADDRESSABILITY.
         TM    SJBFLG1,SJB1XBWT    IF NOT XBM-WITHOUT-JOB,
         BZ    SVCH20              CONTINUE.
         L     RBUF,SDBUBF         FOR XBM WITHOUT JOB,
         LTR   RBUF,RBUF           FIRST VERIFY THAT
         BZ    SVCNORML            UNPROTECTED BUFFER EXISTS.
         USING BFD,RBUF            THEN
         LA    R0,BFDAT            RE-INITIALIZE
         ST    R0,BFLOC            BFDAT
         LH    R0,$SVBFSIZ         AND                               R4
         SL    R0,=A(BFDAT+1-BFIO) ALSO                              R4
         ST    R0,BFLEN            BFLEN
         B     SVCNORML            AND RETURN NORMALLY.
         DROP  RSJB,RBUF           DROP SJB,BUF BASES.
SVCH20   CL    R0,=A(SVCHEND-SVCH30)  TEST R0                        R4
         BNL   SVCERRET            BR IF ILLEGAL TO ERROR RETURN     R4
         LR    R15,R0              RELOAD R0                         R4
         N     R0,=A(X'FF000003')  IF R0 POSITIVE MULTIPLE OF 4,     R4
         BZ    SVCH30(R15)          BR TO PROCESS REQUEST            R4
         B     SVCERRET              ELSE BR TO ERROR RETURN         R4
SVCH30   DS    0H                  START OF BRANCH TABLE             R4
         B     SVCGET              EOB FOR GET
         B     SVCPUT              EOB FOR PUT
         B     SVCIRD              INTERNAL READER PROCESSING
         B     SVCPNT              POINT PROCESSING
         NOP   0                   HSVCENDI (16) OBSOLETE
         B     SVCENDR             ENDREQ PROCESSING
         B     SVCUSO              OUTPUT LIMIT PROCESSING
         NOP   0                   HSVCCLSI (28) OBSOLETE
         B     SVCGUP              GET-UPDATE PROCESSING
         B     SVCPUP              PUT-UPDATE PROCESSING
         B     SVCXBM              EXECUTION BATCH MONITOR
SVCHEND  DS    0H                  END OF BRANCH TABLE               R4
         DROP  R2
         EJECT
*
*
*              HAMSVC - END-OF-BLOCK PROCESSING FOR GET
*
*
SVCGET   DS    0H
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUFFER.
         USING BFD,RBUF            USE BUFFER DSECT.
         TM    SDBFLG1,SDB1BFXS    IF PBF IS NOT REFILLED            R4
         BZ    SVCGET10             BECAUSE OF A PURGE-QUIESCE       R4
         NI    SDBFLG1,255-SDB1BFXS  DETECTED AT HCRETURN,           R4
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         EXCP  SDBIOB                  ISSUE EXCP TO REFILL PBF      R4
         WAIT  1,ECB=SDBECB        WAIT FOR I/O TO COMPLETE          R4
         B     SVCNORML            RETURN WITH UBF REFILLED          R4
SVCGET10 CALL  HENDREAD            YES.  INSPECT COMPLETION.
         TM    SDBFLG2,SDB2IOE     DID I/O ERROR OCCUR...
         BO    SVCNORML            IF SO, RETURN.
         CALL  HMOVEPU             ELSE MOVE PROT TO UNPROT BUF ETC.
         TM    SDBFLG2,SDB2EOD     IS THIS THE LAST OF INPUT...
         BO    SVCNORML            IF SO, RETURN.
         CALL  HCNVFDAD            ELSE SET NEW FDAD IN IOB,
         TM    SDBFLG2,SDB2IOA     IF I/O NOT ACTIVE           @OZ30886
         BZ    SVCGET20            CONTINUE                    @OZ30886
         WAIT  1,ECB=SDBECB        ELSE, WAIT                  @OZ30886
SVCGET20 SLR   R0,R0               ZERO R0                     @OZ30886
         ST    R0,SDBECB           STORE ZERO IN ECB           @OZ30886
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         LA    R0,1                INCREMENT
         A     R0,SDBXCPCT         EXCP
         ST    R0,SDBXCPCT         COUNTER,
         EXCP  SDBIOB              AND START UP I/O.
         B     SVCNORML            THEN RETURN NORMALLY.
         EJECT
*
*
*              HAMSVC - UPDATE PROCESSING FOR GET
*
*
SVCGUP   DS    0H
*
*              QUIESCE I/O
*
         LR    R8,RRPL             SAVE RPL ADDRESS.
         WAIT  1,ECB=SDBECB        WAIT FOR I/O TO COMPLETE.
*
*              FREE BUFFERS ON THE I/O COMPLETE CHAIN
*
         BAL   R5,HSPFBFRE         GO FREE ALL BUT ONE FBF.
         LTR   R1,R1               IS THERE A BUFFER LEFT...
         BNZ   SGU020              BRANCH IF SO.
*
*              GET FIRST PROTECTED BUFFER FOR GET-UPDATE
*
         $GETBUF TYPE=PROT         GET A PROTECTED BUFFER.
         BNZ   SGUSTOR             BRANCH IF NO STORAGE.
         LA    R0,1                ELSE INCREMENT
         AH    R0,SDBPBFCT         PROTECTED-BUFFER
         STH   R0,SDBPBFCT         COUNT.
*
*              INITIALIZE THE PROTECTED BUFFER
*
SGU020   LR    RBUF,R1             SET BUFFER BASE REGISTER.
         MVI   BFID,C'G'           SET ID TO 'GBF'.
         SLR   R0,R0               ZERO
         ST    R0,BFBF             NEXT-BUFFER POINTER.
         ST    RBUF,SDBGBF         POINT TO BUFFER FROM SDBGBF.
*
*              FREE ALL HOLD BUFFERS BUT ONE
*
         L     RBUF,SDBHBF         POINT TO FIRST HBF.
SGU030   LTR   R1,RBUF             DOES IT EXIST...
         BZ    SGU040              BRANCH IF NOT.
         L     RBUF,BFBF           GET POINTER TO NEXT HBF.
         LTR   RBUF,RBUF           IF R1 POINTS TO LAST HBF,
         BZ    SGU050              BRANCH.
         $FREMAIN BU,A=(R1),LV=4096,SP=229,KEY=1  ELSE FREE THIS HBF R4
         B     SGU030              AND EXAMINE NEXT HBF.
*
*              GET A HOLD BUFFER IF REQUIRED
*
SGU040   $GETMAIN BC,LV=4096,SP=229,KEY=1  GET KEY-1 BUFFER.         R4
         BNZ   SGUSTOR             BRANCH IF NO STORAGE.
SGU050   LR    RBUF,R1             SET BUFFER ADDRESSABILITY.
         MVI   BFID,C'H'           SET ID TO 'HBF'.
         SLR   R0,R0               ZERO
         ST    R0,BFBF             NEXT-BUFFER POINTER.
         ST    RBUF,SDBHBF         SAVE HOLD BUFFER ADDRESS.
*
*              CONVERT ARGUMENT ADDRESS TO ABSOLUTE
*
         LR    RRPL,R8             RESTORE RPL ADDRESS.
         L     R1,RPLARG           POINT TO UPDATE ARGUMENT RBA.
         L     R14,PSATOLD-PSA     GET CURRENT TCB ADDRESS     @OZ77665
         SPACE 1                                               @OZ77665
         USING TCB,R14             SET TCB ADDRESSABILITY      @OZ77665
         SPACE 1                                               @OZ77665
         MODESET EXTKEY=RBT234,WORKREG=14  SET TO USER KEY     @OZ77665
         SPACE 1                                               @OZ77665
         LM    R14,R15,0(R1)       GET UPDATE ARGUMENT RBA     @OZ77665
         SPACE 1                                               @OZ77665
         MODESET EXTKEY=ZERO       SET BACK TO KEY ZERO        @OZ77665
         SPACE 1                                               @OZ77665
         DROP R14                  DROP TCB ADDRESSABILITY     @OZ77665
         SPACE 1                                               @OZ77665
         STM   R14,R15,SDBUPRBA    SAVE RBA IN SDB FOR HCEGUP  @OZ77665
         L     R5,SDBMTTR          SAVE SDBMTTR IN R5.
         MVC   SDBMTTR,SDBUPRBA+1  SET SDBMTTR FROM RBA        @OZ77665
         EJECT                                                 @OZ77665
         CALL  HCNVFDAD            CONVERT TO FDAD FORMAT.
*
*              SET UP FOR EXCP, ISSUE IT, AND WAIT
*
         L     R4,SDBCCW4          SAVE SDBCCW4.
         IC    R3,SDBCHEND         SAVE VALUE OF SDBCHEND.
         L     RBUF,SDBGBF         POINT TO UPDATE PROTECTED BUF.
         MVC   BFRBA,SDBUPRBA      SET CURRENT RBA IN BUFFER.
         MVC   BFECB,SDBHBF        POINT IT TO UPDATE UNPROT BUF.
         MVC   BFTRK,SDBMTTR       SET UPDATE MTTR IN IT.
         LA    R1,BFIO             POINT TO I/O AREA IN BUF
         ST    R1,SDBCCW4          AND SET READ-DATA CCW.
         MVI   SDBCCW4,6           SET READ-DATA COMMAND.
         MVI   SDBCHEND,SDBCEGUP   ASK FOR HCEGUP.
         SLR   R0,R0               ZERO OUT
         ST    R0,SDBSAVE          CHANNEL-END ERROR WORD.
         EXCP  SDBIOB              START THE READ.
         WAIT  1,ECB=SDBECB        WAIT TILL HCEGUP IS DONE.
*
*              RESTORE SDB TO STATUS QUO ANTE BELLUM
*
         STC   R3,SDBCHEND         RESTORE SDBCHEND VALUE.
         ST    R4,SDBCCW4          RESTORE SDBCCW4.
         ST    R5,SDBMTTR          RESTORE SDBMTTR.
*
*              RETURN FROM HAMSVC
         L     R15,SDBSAVE         GET CHAN-END ERROR WORD.
         B     SVCEXIT             RETURN IT TO HG100.
* STORAGE UNAVAILABLE FOR BUFFERS
SGUSTOR  B     SVCSTOR             RETURN ADR OF HERSTOR.
         EJECT
*
*
*              HAMSVC - EXECUTION BATCH MONITOR END-OF-JOB
*
*
SVCXBM   DS    0H
*
*
*              VALIDIFY XBM END-JOB REQUEST
*
*
         L     RSJB,SDBSJB         POINT TO SJB FOR THIS JOB.
         USING SJBDSECT,RSJB       SET SJB ADDRESSABILITY.
         CLM   RSDB,7,SJBXBSDB+1   IS THIS THE BATCH-INPUT UNIT...
         BNE   SX800               ERROR IF NOT.
*
*
*              LOCK THE SJB.  ERROR IF ALREADY LOCKED.
*
*
         SLR   R0,R0               ZERO R0 AND R1 TO COMPARE WITH
         LR    R1,R0               CURRENT CONTENTS OF SJBLOCKH.
         L     R2,PSATOLD-PSA      POINT R2 TO CURRENT TCB.
         LNR   R3,R2               SET R3 TO ARBITRARY NEG VALUE.
         CDS   R0,R2,SJBLOCKH      IF SJB IS UNLOCKED, TAKE LOCK.
         BNE   SX800               IF SJB IS LOCKED, ERROR.
         OI    SJBFLG1,SJB1XBMC    SHOW XBM CONTINUATION            R41
         O     R12,=X'80000000'    SHOW SJB LOCK OBTAINED.
*
*
*              TERMINATE THE CURRENT JOB
*
*
         SL    R12,=A(SVCHBASE-HJEBASE)  SET JOB TERM ADDRESSAB.
         USING HJEBASE,R12         TELL THE ASSEMBLER.
         B     HJEXBM              USE JOB TERMINATE.
         USING SVCHBASE,R12        RESTORE SVC ADDRESSABILITY.
*
*
*              RETURN TO HERE FROM JOB TERMINATE/SELECT
*
*
SX100    DS    0H
*
*
*              UNLOCK THE SJB.  ERROR IF ANY WAITERS.
*
*
         SLR   R0,R0               ZERO R0 AND R1 TO SET INTO
         LR    R1,R0               SJBLOCKH.
         L     R2,PSATOLD-PSA      POINT R2 AND R3 TO WHAT SHOULD
         LNR   R3,R2               BE IN SJBLOCKH.
         CDS   R2,R0,SJBLOCKH      IF OKAY, UNLOCK THE SJB.
         BNE   SX800               IF SJB IS NOT OKAY, ERROR.
*
*
*              SET REGISTER 15 ACCORDING TO FLAG SJB1XBWT
*              AND RETURN TO HAMGET.
*
*
         NI    SJBFLG1,255-SJB1XBMC  SHOW NEW JOB SELECTED.
         SLR   R15,R15             ASSUME JOB SELECTED.
         TM    SJBFLG2,SJB2CNCL    TEST FOR OPERATOR CANCEL    @OZ64863
         BO    SX500               YES, CANCEL WHOLE XBM       @OZ64863
         TM    SJBFLG1,SJB1XBWT    IF JOB SELECTED,
         BZ    SVCNORML            RETURN FROM SVC.
SX500    DS    0H                                              @OZ64863
         L     R4,SJBCSCB          ESTABLISH ADDRESSABILITY    @OZ35973
         USING CSCDSECT,R4          TO COMMAND SCHED CB        @OZ35973
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  GET KEY ZERO         @OZ35973
         OI    CHACT,CHCLD         TELL OS TO CANCEL JOB       @OZ35973
         LA    R1,CHCECB           POINT TO CANCEL ECB         @OZ35973
         POST  (1),X'222'          CANCEL WITHOUT DUMP         @OZ35973
         MODESET KEYADDR=(2)       RETURN TO CALLERS KEY       @OZ35973
         DROP  R4                                              @OZ35973
         B     SVCERRET            ELSE CAUSE HAMGET TO EXIT.
*
*
*              ABEND IF PROCESSING ERROR
*
*
SX800    DS    0H
         ABEND X'56F',DUMP,STEP,SYSTEM  KILL THE BATCH MONITOR.
         EJECT
*
*              HAMSVC - END-OF-BLOCK PROCESSING FOR PUT
*
*
SVCPUT   DS    0H
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
         PRINT OFF                                             @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
         PRINT ON                                              @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*
*              GET A TRACK FOR NEXT BUFFER IF NECESSARY
*
         SLR   R1,R1               ZERO R1 FOR CASE OF CLOSE.
         TM    SDBFLG1,SDB1CLOS    IS DATA SET BEING CLOSED...
         BO    SVCP10              BRANCH IF SO.
         LA    R13,SDBSAVE         PROVIDE SAVE AREA FOR $TRACK.
         LA    R1,SDBTAB           A(MAJOR/MINOR TAB)                R4
         CALL  $STRAK              GET A CHAINING TRACK.
SVCP10   LR    R8,R1               SAVE TRACK ADDRESS OR 0 IN R8.
         ST    R3,SDBSAVE+32       SAVE ACB ADDRESS            @OZ43719
*
*              IF ANY PBFS EXIST FOR WHICH I/O IS COMPLETE,
*              FREE ALL BUT ONE OF THEM.
*
SVCP20   BAL   R5,HSPFBFRE         GO FREE ALL BUT ONE BUF.
         LTR   R1,R1               DO WE HAVE A PBF TO USE...
         BNZ   SVCP60              BRANCH IF SO.
*
*              GET A NEW PROTECTED BUFFER
*
         LH    R5,SDBPBFCT         GET CURRENT PBF COUNT.
         TM    SDBFLG1,SDB1BFXS    IF EXCESSION ALLOWED,
         BO    SVCP25              DON'T TEST MAXIMUM.
         CH    R5,SDBPBFLM         IS IT AT MAXIMUM...
         BNL   SVCP30              IF SO, GO WAIT.
SVCP25   $GETBUF TYPE=PROT         GET A NEW BUFFER.
         BE    SVCP50              BRANCH IF SUCCESSFUL.
*
*              IF STORAGE UNAVAILABLE OR BUFFER COUNT IS
*              AT MAXIMUM, WAIT
*
SVCP30   DS    0H
*   GETMAIN AN 8-BYTE WAIT ELEMENT OF THE FOLLOWING FORMAT..   @OZ37582
*        +0   ECB                                              @OZ37582
*        +4   POINTER TO THE NEXT WAITER                       @OZ37582
         $GETMAIN RU,SP=254,LV=8,KEY=0  GET WAIT ELEMENT       @OZ37582
         LR    R4,R1               SAVE WAIT ELEMENT ADDRESS   @OZ37582
         XC    0(4,R4),0(R4)       CLEAR ECB                   @OZ37582
         L     R0,SDBWAITQ         GET WAIT QUEUE HEAD         @OZ37582
SVCP32   ST    R0,4(,R4)           CHAIN WAITERS BEHIND US     @OZ37582
         CS    R0,R4,SDBWAITQ      PUT OUR ELEMENT ON QUEUE    @OZ37582
         BNE   SVCP32              REPEAT IF IT CHANGED.       @OZ37582
         TM    SDBFLG2,SDB2IOA     IF I/O IS ACTIVE,
         BO    SVCP40              WAIT FOR EARLY POST.
         TM    0(R4),X'40'         ELSE SEE IF POST WAS DONE   @OZ37582
*   IF POST WAS NOT DONE, THE CHANNEL-END LOOP DRIED UP        @OZ37582
*   BEFORE WE GOT ON THE CHAIN OF WAITERS. THE WAIT ELEMENT    @OZ37582
*   CANNOT BE FREED IN THIS CASE, AS OTHER ELEMENTS MIGHT      @OZ37582
*   HAVE BEEN ADDED TO THE QUEUE AHEAD OF US.                  @OZ37582
*              THIS LINE DELETED BY APAR OZ70299               @OZ70299
         BNZ   SVCP45              POSTED, FREE AND TRY AGAIN  @OZ70299
SVCP35   L     RBUF,SDBFBF         SEE IF BUFFER...            @OZ37582
         LTR   RBUF,RBUF           WAS FREED BY HCEPUT.
         BNZ   SVCP20              YES, TRY AGAIN              @OZ70299
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
         B     SVCSTOR             NO.  STORAGE UNAVAILABLE.
SVCP40   DS    0H
         CLI   SDBICMP,X'48'       IF IO IS                    @OZ70299
         BNE   SVCP41                 PURGED                   @OZ70299
         MVI   SDBECB,0                 THEN REDRIVE           @OZ70299
         EXCP  SDBIOB                      THE EXCP            @OZ70299
SVCP41   DS    0H                                              @OZ70299
         WAIT  1,ECB=(R4)          WAIT FOR EARLY POST         @OZ37582
SVCP45   $FREMAIN RU,A=(R4),SP=254,LV=8,KEY=0 FREE ELEMENT     @OZ37582
         B     SVCP20              THEN TRY AGAIN.
*
*              INCREMENT PROTECTED BUFFER COUNTER
*
SVCP50   LA    R5,1(,R5)           IF GETMAIN USED, ADD ONE
         STH   R5,SDBPBFCT         TO PROTECTED-BUFFER COUNTER.
*
*              INITIALIZE BUFFER
*
SVCP60   LR    RBUF,R1             SET UP BUFFER BASE REGISTER.
         MVI   BFID,C'P'           SHOW PROTECTED BUFFER.
         MVC   BFTRK,SDBTRK+1      SET TRACK TO WRITE BUFFER ON.
         MVC   BFKEY,SDBKEY        SET JOB AND DS KEY.
         ST    R8,BFNXT            SET CHAINING TRACK.
         MVI   BFFL1,0             SHOW BUFFER NOT YET WRITTEN.
         NI    SDBFLG1,255-SDB1BFXS  RESET EXCESSION-ALLOWED.
*
*              MOVE DATA FROM UNPROTECTED TO PROTECTED BUFFER
*
         L     R2,SDBUBF           POINT TO USER RECORDS
         LA    R2,BFDAT-BFD(,R2)   IN UNPROTECTED BUFFER.
         LH    R3,$SVBFSIZ         SET MAXIMUM                       R4
         SL    R3,=A(BFDAT-BFIO)   SOURCE LENGTH.                    R4
         LA    R4,BFDAT            POINT TO SINK AREA.
         LR    R5,R3               SET SINK LENGTH.
         MVCL  R4,R2               MOVE UNPROTECTED DATA TO PBF.
         USING LRCDSECT,R4                                     @OZ43719
         LA    R4,BFDAT            POINT TO BUFFER DATA        @OZ43719
         SR    R5,R5               ZERO COUNT REG              @OZ43719
         LR    R2,R4               POINT TO BUFFER DATA        @OZ43719
         AH    R2,$SVBFSIZ         POINT TO END OF BUFFER      @OZ43719
SVCP61   DS    0H                                              @OZ43719
         CR    R4,R2               PAST END OF BUFFER          @OZ43719
         BNL   SVCP64              BRANCH IF YES               @OZ43719
         CLI   LRCTLENG,255        END OF BUFFER               @OZ43719
         BE    SVCP64              BRANCH IF YES               @OZ43719
         TM    LRCFLAG1,LRC1SPAN   SPANNED RECORD              @OZ43719
         BZ    SVCP63A             BRANCH IF NO                @OZ43719
*                                                          *   @OZ43719
*        THIS ROUTINE INCREMENTS RECORD COUNT FOR          *   @OZ43719
*        SPANNED RECORDS                                   *   @OZ43719
*                                                          *   @OZ43719
         SR    R1,R1               CLEAR REG1                  @OZ43719
         ICM   R1,3,LRCSEGL        GET SEGMENT LENGTH          @OZ43719
         BZ    SVCP63              BRANCH NO DATA IN RECORD    @OZ43719
         TM    LRCFLAG1,LRC1SEND   LAST SEGMENT                @OZ43719
         BZ    SVCP63              NO, DON'T COUNT             @OZ43719
         LA    R5,1(,R5)           INCREMENT RECORD COUNT      @OZ43719
*              THIS LINE DELETED BY APAR OZ57882               @OZ57882
*              THIS LINE DELETED BY APAR OZ57882               @OZ57882
SVCP63   DS    0H                                              @OZ43719
         LA    R3,LRCSTEXT         SKIP LRCB                   @OZ43719
         TM    LRCFLAG1,LRC1SBGN   FIRST SEGMENT...            @OZ43719
         BZ    SVCP63C             BRANCH NO                   @OZ43719
         LA    R3,LRCSFTXT         INCREMENT PAST FIRST LRCB   @OZ57882
         B     SVCP63C             SKIP RECORD TEXT            @OZ43719
*                                                          *   @OZ43719
*        THIS ROUTINE INCREMENTS RECORD COUNT FOR          *   @OZ43719
*        NON-SPANNED RECORDS                               *   @OZ43719
*                                                          *   @OZ43719
SVCP63A  DS    0H                                              @OZ43719
         LA    R3,LRCTEXT          SKIP LRCB                   @OZ43719
         SR    R1,R1               CLEAR REG1                  @OZ43719
         ICM   R1,1,LRCTLENG       ANY DATA IN RECORD          @OZ43719
*        THIS LINE DELETED BY APAR                             @OZ59839
         LA    R5,1(,R5)           INCREMENT RECORD COUNT      @OZ43719
SVCP63B  DS    0H                                              @OZ43719
         TM    LRCFLAG1,LRC1CCTL   CARRIAGE CONTROL            @OZ43719
         BZ    SVCP63C             NO, DON'T SKIP CC CHAR      @OZ43719
         LA    R3,1(,R3)           SKIP CC CHARACTER           @OZ43719
SVCP63C  DS    0H                                              @OZ43719
         AR    R3,R1               BUMP TO NEXT LRCB           @OZ43719
         LR    R4,R3               ESTABLISH LRCB BASE         @OZ43719
         L     R3,SDBRECCT         GET CURRENT TOTAL LINES     @OZ43719
         ALR   R3,R5               GET CURRENT TOTAL           @OZ43719
         CL    R3,SDBOUTLM         TOTAL EXCEED OUTLIM         @OZ43719
         BNH   SVCP61              NO, CONTINUE                @OZ43719
         TM    SDBFLG1,SDB1CLOS    XBM USER TERMINATING...     @OZ52438
         BO    SVCP61              YES, DO NOT TRUNCATE        @OZ52438
         LA    R0,HSVCOUTL         SET SVCHAM FUNCTION         @OZ52438
         LNR   R0,R0               FORCE DEBCHK IN SVCHAM      @OZ52438
         L     R1,SDBSAVE+32       GET ACB ADDRESS             @OZ52438
         LNR   R1,R1               INDICATE ACB ADDRESS        @OZ52438
         SVC   HAMSVC              ISSUE HAMSVC                @OZ52438
         CL    R3,SDBOUTLM         WAS OUTLIM INCREASED...     @OZ52438
         BNH   SVCP61              YES,CONTINUE                @OZ52438
         MVI   LRCTLENG,255        SET EOB HERE                @OZ43719
SVCP64   DS    0H                                              @OZ43719
         ST    R5,SDBSAVE+40       SAVE BUFFER RECORD COUNT    @OZ43719
         DROP  R4                                              @OZ43719
*              ADD PROTECTED BUFFER TO SDBPBFX CHAIN
*
         L     R1,SDBPBFX          QUEUE THIS NEW PBF,
         ST    R1,BFBF             LAST-IN-FIRST-OUT,
         CS    R1,RBUF,SDBPBFX     ON CHAIN SDBPBFX.
         BNE   *-8                 HCEPUT WILL DO THE REST.
*              THIS LINE DELETED BY APAR OZ43310               @OZ43310
*              THIS LINE DELETED BY APAR OZ43310               @OZ43310
*              THIS LINE DELETED BY APAR OZ43310               @OZ43310
*              THIS LINE DELETED BY APAR OZ43310               @OZ43310
*              THIS LINE DELETED BY APAR OZ43310               @OZ43310
*              THIS LINE DELETED BY APAR OZ43310               @OZ43310
*
*              IF I/O IS INACTIVE, ISSUE EXCP
*
*              THIS LINE DELETED BY APAR OZ43310               @OZ43310
         TM    SDBFLG2,SDB2IOA     IF I/O IS NOT ACTIVE,       @OZ47054
         BZ    SVCP67A             GO TO REISSUE EXCP.         @OZ47054
         CLI   SDBICMP,X'48'       IF NOT PURGED HALT I/O,     @OZ47054
         BNE   SVCP70              ...HCEPUT WILL REDRIVE      @OZ47054
         MVI   SDBECB,0            IF PURGED, CLEAR THE ECB..  @OZ47054
         EXCP  SDBIOB              REDRIVE PURGED I/O, AND     @OZ47054
         B     SVCP70              BR TO CONTINUE PROCESSING.  @OZ47054
         SPACE 1                                               @OZ47054
SVCP67A  DS    0H                                              @OZ47054
         TM    BFFL1,BF1IOC        IS I/O ALREADY COMPLETE...
         BO    SVCP70              IF SO, SKIP EXCP.
SVCP67   L     R0,BFBF             IF RBUF POINTS TO                 R4
         LTR   R0,R0                THE LEAST RECENT BUFFER ON       R4
         BZ    SVCP68                SDBPBFX CHAIN, CONTINUE         R4
         LR    RBUF,R0                ELSE POINT RBUF TO THE LESS    R4
         B     SVCP67                  RECENT BUFFER AND TRY AGAIN   R4
SVCP68   DS    0H                                                    R4
         L     R1,SDBPBF           IF CHAN END APPENDAGE
         LTR   R1,R1               BECAME A VICTIM OF
         BZ    *+6                 PURGE-QUIESCE, RESTART WHERE
         LR    RBUF,R1             IT WOULD HAVE RESTARTED.
         MVC   SDBMTTR,BFTRK       SET TRACK TO WRITE AND
         CALL  HCNVFDAD            CONVERT IT TO ABSOLUTE.
         LA    R0,1                INCREMENT
         AL    R0,SDBXCPCT         THE EXCP
         ST    R0,SDBXCPCT         COUNT.
*              THIS LINE DELETED BY APAR NUMBER                @OZ41000
         LA    R0,BFIO             SET PTR TO DATA TO WRITE
         STCM  R0,7,SDBCCW4+1      INTO WRITE-DATA CCW.
         MVI   SDBCHEND,SDBCEPUT   SET UP FOR CHANNEL END.
         EXCP  SDBIOB              ISSUE EXCP.
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
SVCP70   DS    0H
         L     RBUF,SDBUBF         POINT TO UNPROTECTED BUF    @OZ43719
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
         LTR   R0,R8               IF DATA SET IS CLOSING      @OZ46541
         BZ    SVCP80              DON'T CHANGE SDBTTR         @OZ46541
         LA    R1,256              GET 0010 IN R1              @OZ46541
         SRDL  R0,8                SHIFT FOR 0MTTR001          @OZ46541
         STM   R0,R1,BFRBA         SET NEW RBA IN UBUF         @OZ46541
         STM   R0,R1,SDBTRK        AND IN SDBTRK               @OZ46541
         STM   R0,R1,SDBTRKL       AND IN SDBTRKL              @OZ46541
         ST    R8,BFTRK            SET TRACK TO WRITE NEXT     @OZ46541
SVCP80   DS    0H                                              @OZ46541
         LA    R0,BFDAT            SET POINTER IN UBUF         @OZ46541
         ST    R0,BFLOC            FOR FIRST LOGICAL RECORD    @OZ46541
         LH    R0,$SVBFSIZ         SET LENGTH                  @OZ46541
         SL    R0,=A(BFDAT+1-BFIO) IN UBUF                     @OZ46541
         ST    R0,BFLEN            OF LOGICAL RECORD AREA      @OZ46541
         EJECT
         PUSH  USING               SAVE REGISTER STATUS.
         DROP  RSJB                DROP SJB BASE.
*
*
*              INCREMENT RECORD COUNT, TEST FOR EXCESSION
*
*
         TM    SDBFLG1,SDB1OUT     IF INTERNAL DATA SET,
         BZ    SVCP140             DON'T COUNT ANYTHING.
         TM    SDBFLG2,SDB2EOD     COUNT RECORDS               @OZ43719
         BO    SVCP140             NO, DON'T COUNT             @OZ43719
         SPACE 1
         L     R0,SDBRECCT         UP CURRENT DATA SET'S
         AL    R0,SDBSAVE+40       RECORD COUNT BY NUMBER      @OZ43719
         ST    R0,SDBRECCT         OF RECORDS IN THIS BUFFER.
         SPACE 1
         L     R14,SDBSJB          GET SJB BASE                @OZ43719
         USING SJBDSECT,R14        SET SJB ADDRESSABILITY      @OZ43719
         L     R7,SJBJCT           POINT TO THE JCT FROM SJB.
         USING JCTDSECT,R7         SET JCT ADDRESSABILITY.
         SPACE 1
         L     R0,JCTXOUT          UP OVERALL JOB'S
         LR    R1,R0               OUTPUT COUNT
         AL    R1,SDBSAVE+40       (INCLUDES PRINT & PUNCH)    @OZ43719
         CS    R0,R1,JCTXOUT       BY NUMBER OF RECORDS
         BNE   *-10                IN THIS BUFFER.
         SPACE 1
         LA    R2,JCTLINES         ASSUME PRINTED OUTPUT
         LA    R3,JCTESTLN         AND GET POINTERS TO
         LA    R4,SJBESTLN         CURRENT COUNT, USER ESTIMATE,
         LA    R5,=C'LINE'         CURRENT ESTIMATE, AND CAPTION.
         L     R15,SDBPDDB         POINT TO THE PDDB
         USING PDBDSECT,R15        AND GET ADDRESSABILITY.
         SLR   R1,R1               ZERO R1 FOR IC.
         IC    R1,PDBCLASS         GET CLASS AND INDEX
         LA    R1,$SVSCAT(R1)      SYSOUT CLASS ATTRIBUTES.
         USING SCADSECT,R1         SET SCAT ADDRESSABILITY.
         TM    SCATFLAG,SCATPNCH   IF NOT PUNCH TYPE,
         BZ    SVCP100             IT MUST BE PRINT.
         LA    R2,JCTPUNCH         IT'S A PUNCH DATA SET.
         LA    R3,JCTESTPU         GET POINTERS TO
         LA    R4,SJBESTPU         CURRENT COUNT, USER ESTIMATE,
         LA    R5,=C'CARD'         CURRENT ESTIMATE, AND CAPTION.
         SPACE 1
SVCP100  DS    0H
         L     R0,0(,R2)           UPDATE CURRENT COUNT
         LR    R1,R0               (JCTLINES OR JCTCARDS)
         AL    R1,SDBSAVE+40       BY NUMBER                   @OZ43719
         CS    R0,R1,0(R2)         OF RECORDS
         BNE   *-10                IN THIS BUFFER.
         TM    SDBFLG3,SDB3OUTX    IS OUTLIM EXCEEDED...       @OZ73356
         BO    SVCP127             BR IF YES TO TERMINATE      @OZ73356
         SPACE 1
         CL    R1,0(,R4)           IF CURRENT COUNT IS LESS
         BNH   SVCP140             THAN CURRENT ESTIMATE, BRANCH.
         TM    SDBFLG1,SDB1FOPN    IS IT JOB LOG,MSGS OR JCLI  @OZ17756
         BO    SVCP140             BR IF YES, DON'T WARN       @OZ17756
         TM    SJBFLG1,SJB1XBM+SJB1XBMC  IS XBM TO CONTINUE.   @OZ47091
         BO    SVCP140             IF YES, DO NOT WARN.        @OZ47091
         SPACE 1
         MVC   SPWMSG,SPWTO        SET WTO MESSAGE AND
         MVC   SPWMV,0(R5)         CAPTION INTO UBF FOR WTO.
         SPACE 1
         L     R5,$SVOUTXS         GET INTO REGISTER 5
         LA    R5,0(,R5)           THE OUTPUT EXCESSION INCREMENT.
         L     R0,0(,R4)           UPDATE CURRENT ESTIMATE
         LR    R1,R0               (SJBESTLN OR SJBESTPU)
         ALR   R1,R5               BY THE OUTPUT EXCESSION
         CS    R0,R1,0(R4)         INCREMENT                         R4
         BNE   SVCP140             IF INTERFERENCE, SOMEONE ELSE
*                                  WROTE THE MESSAGE.
         S     R0,0(,R3)           TAKE USER ESTIMATE FROM OLD
*                                  CURRENT ESTIMATE.
         MVC   SPWME,SPWEDIT       SET EDIT MASK.
         CVD   R0,SDBUPRBA         CONVERT EXCESSION AMOUNT
*              THIS LINE DELETED BY APAR NUMBER                @OZ47806
         ED    SPWME,SDBUPRBA+3    AND EDIT NINE DIGITS.       @OZ47806
         CLC   =F'1',0(R3)         SEE IF ESTIMATE IS '1',          R41
         BNE   SVCP110               BRANCH IF NOT                  R41
         MVC   SPWPLURL,SPWPLURL+1 CHANGE PLURAL TO SINGULAR        R41
         MVI   SPWBLNK,C' '        APPEND TRAILING BLANK            R41
         SPACE 1                                                    R41
SVCP110  DS    0H                                                   R41
         LTR   R0,R0               IF OLD CUR EST .GT. USER EST,
         BP    SVCP120             WRITE LONG MESSAGE.
         MVI   SPWMSGL,SPWML1      SET SHORT MESSAGE LENGTH.
         MVC   SPWD1,SPWD2         SHIFT DESC & ROUTCDE.
         SPACE 1
SVCP120  DS    0H
         WTO   MF=(E,SPWMSG)       WRITE SHORT OR LONG MESSAGE.
         L     R1,PSATOLD-PSA      POINT TO CURRENT TCB.
         USING TCB,R1              SET TCB ADDRESSABILITY.
         TM    TCBFBYT1,TCBRTM2    IF RTM2 IS IN CONTROL,
         BO    SVCP140             DO NOT INSPECT &OUTPOPT.
         TM    TCBTCTGF,TCBSMFGF   IF INITIATOR IN CONTROL,          R4
         BNO   SVCP140              DO NOT ABEND                     R4
         TM    SJBFLG2,SJB2CONV    IF CONVERTER IS RUNNING,
         BO    SVCP140             DO NOT ABEND.
         CLI   $SVOUTOP,1          TEST VALUE OF &OUTPOPT.
         BL    SVCP140             0 - DO NOT TERMINATE.
SVCP127  SLR   R0,R0               ZERO OUT UNPROTECTED-       @OZ73356
         ST    R0,BFRCT            BUFFER RECORD COUNT         @OZ32378
         NI    BFFL1,255-BF1EOB    SHOW NOT END-OF-BUFFER      @OZ45753
         L     R2,PSAAOLD-PSA      POINT TO ASCB               @OZ41586
         L     R2,ASCBTSB-ASCB(,R2) IS THIS TSO                @OZ41586
         LTR   R2,R2                   LOGON...                @OZ41586
         BNZ   SVCP130              ...IF SO, CALL S.I.C.      @OZ41586
         L     R3,PSATOLD-PSA      POINT TO TCB,               @OZ41586
         L     R3,TCBJSTCB-TCB(,R3)  THEN JOB STEP TCB         @OZ41586
         L     R2,PSAAOLD-PSA      GET CURRENT ASCB            @OZ24437
         LH    R2,ASCBASID-ASCB(,R2) GET ASID NUMBER           @OZ24437
         LA    R13,SDBSAVE         POINT TO SAVE AREA FOR RTM  @OZ24437
         TM    SDBFLG3,SDB3OUTX    IF OUTLIM NOT EXCEEDED,     @OZ73356
         BNO   SVCP129              PROCEED, ELSE,             @OZ73356
         NI    SDBFLG3,FF-SDB3OUTX RESET EXCEEDED INDICATOR    @OZ73356
         B     SVCP180              AND CANCEL WITH A DUMP.    @OZ73356
SVCP129  CLI   $SVOUTOP,1          RE-ESTABLISH COND CODE      @OZ73356
         BE    SVCP160             1 - TERMINATE WITHOUT DUMP.
         B     SVCP180             2 - TERMINATE WITH DUMP.
         SPACE 1
*                                                              @OZ41586
*        CALL SYSTEM INITIATED CANCEL (S.I.C.) IF TSO LOGON    @OZ41586
*                                                              @OZ41586
SVCP130  NI    SDBFLG3,FF-SDB3OUTX RESET EXCEEDED INDICATOR    @OZ73356
         SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE,       @OZ41586*
               RELATED=SVCP130                                 @OZ41586
         SETLOCK OBTAIN,TYPE=CMS,MODE=UNCOND,REGS=USE,         @OZ41586*
               RELATED=SVCP130                                 @OZ41586
         LA    R0,X'722'           SET ABEND CODE              @OZ41586
         L     R1,PSAAOLD-PSA      ADDR OF ASCB TO BE CAN.     @OZ41586
         LA    R13,SDBSAVE         POINT TO SAVE AREA FOR SIC  @OZ41586
         L     R15,CVTPTR          GET CVT ADDRESS             @OZ41586
         L     R15,CVTSIC-CVT(,R15) GET ADDR OF SIC ROUTINE    @OZ41586
         BALR  R14,R15             CALL S.I.C.                 @OZ41586
         SETLOCK RELEASE,TYPE=CMS,REGS=USE,RELATED=SVCP130     @OZ41586
         SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,RELATED=SVCP130   @OZ41586
         B     SVCERROR            GIVE UP CONTROL             @OZ45753
         SPACE 1                                               @OZ41586
SVCP140  DS    0H
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
         PRINT OFF                                             @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
         PRINT ON                                              @OZ46541
*              THIS LINE DELETED BY APAR OZ46541               @OZ46541
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR OZ43719               @OZ43719
*              THIS LINE DELETED BY APAR NUMBER                @OZ17756
         NI    BFFL1,255-BF1EOB    SHOW NOT END-OF-BUFFER.           R4
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
*              THIS LINE DELETED BY APAR NUMBER              * @OZ52438
         B     SVCNORML            RETURN                      @OZ43719
*
*              EXCESSION MESSAGE
*
         $MID  375                 SET HASP MESSAGE ID.
SPWTO    WTO   '&MID.ESTIMATED ****S EXCEEDED BY NNNNNNNNN',   @OZ47806C
               ROUTCDE=2,DESC=6,MF=L
         SPACE 1
SPWTOL   EQU   *-SPWTO             LENGTH OF WTO MACRO.
SPWEDIT  DC    X'40202020202020202120'   EDIT MASK.            @OZ47806
*
*              MESSAGE SINK DESCRIPTION
*
SPWMSG   EQU   BFDAT,SPWTOL        MESSAGE SINK AREA.
SPWMSGL  EQU   SPWMSG+1,1          MESSAGE LENGTH AREA.
SPWML1   EQU   SPWTOL-4-13         SHORT MESSAGE LENGTH.       @OZ47806
SPWMV    EQU   SPWMSG+4+9+10,4     CAPTION PORTION                   R4
SPWPLURL EQU   SPWMV+4,22          END OF '****S'              @OZ47806
SPWBLNK  EQU   SPWPLURL+L'SPWPLURL,1 SPACE FOR BLANK                R41
SPWME    EQU   SPWMSG+SPWTOL-4-10,10  EDIT PORTION.            @OZ47806
SPWD1    EQU   SPWMSG+SPWTOL-4-13,4  SHORT ROUTCDE & DESC.     @OZ47806
SPWD2    EQU   SPWMSG+SPWTOL-4,4   LONG ROUTCDE & DESC.
*
*              &OUTPOPT=1 - TERMINATE JOB WITHOUT DUMP
*
SVCP160  CALLRTM TYPE=ABTERM,COMPCOD=X'722',ASID=(2),TCB=(3),  @OZ24437C
               DUMP=NO                                         @OZ24437
         B     SVCERROR            GIVE UP CONTROL             @OZ45753
*
*              &OUTPOPT=2 - TERMINATE JOB WITH DUMP
*
SVCP180  CALLRTM TYPE=ABTERM,COMPCOD=X'722',ASID=(2),TCB=(3)   @OZ24437
         B     SVCERROR            GIVE UP CONTROL             @OZ45753
         POP   USING               RESTORE REGISTER STATUS.
         SPACE 1                                                    R41
         DROP  RSJB                DROP SJB ADDRESSABILITY          R41
         EJECT
*
*              HAMSVC - USER SYSOUT LIMIT PROCESSOR
*
SVCUSO   DS    0H
         L     R15,$SVSMFSO        POINT TO IEFUSO.
         CLC   =X'1FFF07FE',0(R15) IF IT'S THE DEFAULT,
         BE    SVCUSOAB            DO AN ABEND 722.
         L     R4,PSATOLD-PSA      POINT TO CURRENT TCB.
         USING TCB,R4              SET TCB ADDRESSABILITY.
         L     R5,TCBTCT           POINT TO THE TCT.
         LTR   R5,R5               IF NO TCT,
         BZ    SVCUSOAB            DO AN ABEND 722.
         USING SMFTCT,R5           SET TCT ADDRESSABILITY.
         L     R6,TCTJMR           POINT TO THE JMR.
         LTR   R6,R6               IF NO JMR,
         BZ    SVCUSOAB            DO AN ABEND 722.
         L     R1,SDBSJB           POINT TO THE SJB FROM SDB.
         USING SJBDSECT,R1         GET ADDRESSABILITY.
         L     R1,SJBJCT           POINT TO THE JCT FROM SJB.
         USING JCTDSECT,R1         GET ADDRESSABILITY.
         TM    JCTSMFLG,JCTNOUSO   IF IEFUSO EXIT NOT TO BE
         BO    SVCUSOAB            TAKEN, DO ABEND 722.
         DROP  R1                  DROP JCT ADDRESSABILITY.
*
*              SET UP FOR AND CALL IEFUSO
*
*              THIS LINE DELETED BY APAR NUMBER ===>           @OZ42340
         GETMAIN R,LV=80,SP=230    GET WORK AREA.
         L     R15,$SVSMFSO        POINT AGAIN TO IEFUSO.
         LR    R13,R1              POINT R13 TO SAVE AREA.
         ST    R6,72(,R13)         SET JMR ADDRESS AS ARGUMENT.
         MVI   72(R13),X'80'       SHOW IT'S THE LAST ARGUMENT.
         SLR   R0,R0               SET DCB ADDRESS TO
         ST    R0,76(,R13)         ZERO JUST IN CASE.
         LA    R1,72(,R13)         POINT R1 TO ARGUMENTS.
         BALR  R14,R15             CALL IEFUSO.
         LR    R2,R15              SAVE RETURNED REGISTER 15.
         LR    R3,R1               SAVE RETURNED REGISTER 1.
         FREEMAIN R,LV=80,SP=230,A=(R13)  FREE WORK AREA.
*              THIS LINE DELETED BY APAR NUMBER ===>           @OZ42340
         LTR   R2,R2               IF R15 WAS ZERO,
         BZ    SVCUSOAB            DO AN ABEND 722.
         CL    R2,=F'4'            IF R15 WAS NOT FOUR,
         BNE   SVCUSOAB            DO AN ABEND 722.
         AL    R3,SDBOUTLM         ELSE INCREASE OUTPUT
         ST    R3,SDBOUTLM         LIMIT BY CONTENTS OF R1.
         B     SVCNORML            THEN RETURN NORMALLY.
         SPACE 1                                               @OZ73356
SVCUSOAB OI    SDBFLG3,SDB3OUTX    SET OUTLIM EXCEEDED         @OZ73356
         B     SVCNORML            RETURN TO SVCHAM            @OZ73356
         SPACE 1                                               @OZ73356
         PUSH  PRINT               TURN PRINT OFF FOR SECTION  @OZ73356
         PRINT OFF                  SECTION DELETED BY APAR    @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
*              THIS LINE DELETED BY APAR OZ73356               @OZ73356
         POP   PRINT               RESET TO PRIOR PRINT OPT.   @OZ73356
         EJECT
*
*
*              SUBROUTINE TO FREE SDBFBF BUFFERS
*
*
HSPFBFRE DS    0H
         L     RBUF,SDBFBF         DEQUEUE ENTIRE
         SLR   R0,R0               CHAIN OF
         CS    RBUF,R0,SDBFBF      TO-BE-FREED BUFFERS
         BNE   *-4                 FROM HEADER SDBFBF.
         LTR   R1,RBUF             IF NO BUFFERS TO FREE,
         BZR   R5                  RETURN WITH R1=0.
         L     RBUF,BFBF           IF ONLY ONE BUFFER
         LTR   RBUF,RBUF           ON TO-BE-FREED CHAIN,
         BZR   R5                  RETURN WITH R1=BUFFER.
         ST    R1,0(,RSDB)         SAVE MOST-RECENT BUFFER ADR.
HSPF010  DS    0H
         LTR   R1,RBUF             IS THERE A BUFFER TO FREE...
         L     RBUF,BFBF           (GET PTR TO NEXT BUFFER.)
         BNZ   HSPF020             IF SO, GO FREE IT.
         L     R1,0(,RSDB)         ELSE RESTORE BUFFER ADDRESS
         BR    R5                  AND RETURN TO CALLER.
HSPF020  DS    0H
         $FREEBUF TYPE=PROT,A=(R1) FREE THE BUFFER.
         LH    R0,SDBPBFCT         DECREMENT
         BCTR  R0,0                PROTECTED-BUFFER
         STH   R0,SDBPBFCT         COUNTER.
         B     HSPF010             GO CHECK FOR MORE BUFFERS.
         EJECT
*
*
*              HAMSVC - UPDATE PROCESSING FOR PUT
*
*
SVCPUP   DS    0H
*
*              MOVE EACH HBF TO ITS GBF AND FREE IT
*
         L     RBUF,SDBGBF         POINT TO FIRST PROTECTED BUFFER
SPU010   LTR   RBUF,RBUF           IF WE'RE AT THE END,
         BZ    SPU020              BRANCH.
         LA    R2,BFDAT            POINT TO PROT BUF DATA AREA.
         LH    R3,$SVBFSIZ         GET DATA                          R4
         SL    R3,=A(BFDAT-BFIO)   LENGTH.                           R4
         L     R1,BFECB            POINT TO CORRESP UNPROT BUF.
         LA    R4,BFDAT-BFD(,R1)   POINT TO UNPROT BUF DATA AREA.
         LR    R5,R3               SET SOURCE LENGTH.
         MVCL  R2,R4               MOVE UNPROT DATA TO PROT.
         $FREMAIN BU,A=(R1),LV=4096,SP=229,KEY=1                     R4
         L     RBUF,BFBF           POINT TO NEXT PROTECTED BUFFER.
         B     SPU010              LOOP TO TRANSFER IT TO PROT BUF
*
*              WRITE OUT THE UPDATE-PROTECTED BUFFERS
*
SPU020   DS    0H
         SLR   R0,R0               ZERO POINTER TO
         ST    R0,SDBHBF           UPDATE-UNPROTECTED BUFFERS.
         L     RBUF,SDBGBF         POINT TO FIRST UPDATE-PROT BUF.
         MVC   SDBGBF,SDBPBF       SAVE NON-UPD PROT BUF POINTER.
         ST    RBUF,SDBPBF         POINT SDBPBF TO UPD-PROT CHAIN.
         L     R5,SDBMTTR          SAVE CURRENT SDBMTTR.
         MVC   SDBMTTR,BFTRK       SET SDBMTTR FROM 1ST
         CALL  HCNVFDAD            UPD-PROT BUF AND CONVERT IT.
         IC    R3,SDBCHEND         SAVE VALUE OF SDBCHEND.
         L     R4,SDBCCW4          SAVE SDBCCW4.
         LA    R0,BFIO             POINT TO I/O AREA IN BUFFER.
         ST    R0,SDBCCW4          SET ADDRESS IN WRITE-DATA CCW.
         MVI   SDBCCW4,5           SET WRITE-DATA COMMAND.
         MVI   SDBCHEND,SDBCEPUT   ASK FOR HCEPUT.
         EXCP  SDBIOB              START THE WRITE.
         WAIT  1,ECB=SDBECB        WAIT FOR COMPLETION.
         STC   R3,SDBCHEND         RESTORE SDBCHEND VALUE.
         ST    R4,SDBCCW4          RESTORE SDBCCW4.
         ST    R5,SDBMTTR          RESTORE SDBMTTR.
         MVC   SDBPBF,SDBGBF       RESTORE SDBPBF.
         SLR   R0,R0               ZERO
         ST    R0,SDBGBF           THE UPDATE-PROT BUF PTR.
         B     SVCNORML            RETURN NORMALLY.
         EJECT
*
*
*              HAMSVC - POINT PROCESSING
*
*
SVCPNT   DS    0H
         L     RBUF,SDBUBF         SET POINT RBA
         L     R14,PSATOLD-PSA     GET CURRENT TCB ADDRESS     @OZ77667
         SPACE 1                                               @OZ77667
         USING TCB,R14             SET TCB ADDRESSABILITY      @OZ77667
         SPACE 1                                               @OZ77667
         MODESET EXTKEY=RBT234,WORKREG=14  SET TO USER KEY     @OZ77667
         SPACE 1                                               @OZ77667
         LM    R14,R15,BFRBA       GET POINT RBA               @OZ81049
         SPACE 1                                               @OZ77667
         MODESET EXTKEY=ZERO       SET BACK TO KEY ZERO        @OZ77667
         SPACE 1                                               @OZ77667
         DROP  R14                 DROP TCB ADDRESSABILITY     @OZ77667
         SPACE 1                                               @OZ77667
         STM   R14,R15,SDBUPRBA    SET POINT RBA IN SDB        @OZ77667
* QUIESCE INPUT/OUTPUT OPERATIONS                              @OZ77667
         WAIT  1,ECB=SDBECB        WAIT FOR I/O COMPLETION.
         SPACE 2
* IF OUTPUT - GET & INITIALIZE A PBF, SET SDBCCW4 TO READ,
* AND SET SDBCHEND TO SDBCEGET.
         TM    SDBFLG1,SDB1PUT     IF NOT OUTPUT DATA SET,
         BZ    SVT060              BRANCH.
         $GETBUF TYPE=PROT         GET A PROTECTED BUFFER.
         BNZ   SVCSTOR             ERROR - STORAGE UNAVAILABLE.
         LR    RBUF,R1             SET BUFFER REGISTER.
         MVI   BFID,C'P'           SET BUFFER ID.
         ST    RBUF,SDBPBF         SAVE BUFFER ADDRESS.
         LA    R0,BFIO             SET BUFFER I/O ADDRESS
         ST    R0,SDBCCW4          IN READ-DATA CCW.
         MVI   SDBCCW4,X'06'       SET COMMAND TO READ.
         SPACE 2
SVT060   DS    0H
* INITIATE A READ FOR THE CORRECT RECORD
         MVC   SDBMTTR,SDBUPRBA+1  SET MTTR AND
         CALL  HCNVFDAD            CONVERT DISK ADDRESS.
         NI    SDBFLG2,255-SDB2EOD-SDB2IOE  RESET ERROR FLAGS.
         MVI   SDBCHEND,SDBCEPNT   SET POINT CH END APDG.
SVT065   DS    0H                                              @OZ35141
         EXCP  SDBIOB              START I/O FOR POINT.
         L     R1,SDBECB           LOAD ECB                    @OZ35141
SVT067   LR    R2,R1               RELOAD ECB                  @OZ35141
         N     R2,=XL4'7F000000'   RESET WAIT BIT              @OZ35141
         CS    R1,R2,SDBECB        REPLACE ECB                 @OZ35141
         BNE   SVT067              TRY AGAIN IF UNSUCCESSFUL   @OZ35141
         WAIT  1,ECB=SDBECB        WAIT TILL DONE.
         TM    SDBFLG1,SDB1BFXS    WERE WE QUIESCED            @OZ35141
         BZ    SVT070              CONTINUE IF NOT             @OZ35141
         NI    SDBFLG1,255-SDB1BFXS  RESET QUIESCE INDICATOR   @OZ35141
         B     SVT065              REDRIVE POINT OPERATION     @OZ35141
SVT070   MVI   SDBCHEND,SDBCEGET   SET GET CH END APDG         @OZ35141
         SPACE 2
* IF OUTPUT - FREE THE PBF AND RESTORE SDBCCW4,SDBCHEND
         TM    SDBFLG1,SDB1PUT     IF NOT OUTPUT DATA SET,
         BZ    SVT080              BRANCH.
         $FREEBUF TYPE=PROT,A=SDBPBF  ELSE FREE THE PBF
         SLR   R0,R0               ZERO OUT
         ST    R0,SDBPBF           PROTECTED BUFFER POINTER.
         MVI   SDBCCW4,X'05'       SET WRITE COMMAND.
         MVI   SDBCHEND,SDBCEPUT   SET CHANNEL END APDG TO PUT.
         LA    R13,SDBSAVE         YES, SET UP SAVE AREA.      @OZ35029
         ICM   R0,15,SDBTRK+1      GET NEW RESUME MTTR.        @OZ35029
         CALL  HJSRETAB            REBUILD TRACK ALLOC. BLK.   @OZ35029
         SPACE 2
SVT080   DS    0H
         L     R15,SDBSAVE         PASS HCEPNT RETURN CODE
         B     SVCEXIT             BACK TO HAMPOINT.
         EJECT
*
*
*              HAMSVC - EXITS AND CONSTANTS
*
*
         SPACE 3
SVCNORML DS    0H
         SR    R15,R15             NORMAL EXIT -
         B     SVCEXIT             RETURN ON CVTEXPRO.
         SPACE 3
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
*              THIS LINE DELETED BY APAR NUMBER                @OZ37582
SVCERRET DS    0H                  LOGICAL ERROR EXIT -
         LA    R15,4               RETURN CODE OF 4.
         B     SVCEXIT             RETURN.
         SPACE 2
SVCSTOR  DS    0H                  NO MAIN STORAGE AVAILABLE
         L     R15,=A(HERSTOR)
         B     SVCEXIT
         SPACE 2
SVCEOD   DS    0H
         L     R15,=A(HERNOEOD)    POINT FOUND END-OF-FILE
         B     SVCEXIT
         SPACE 3
SVCEXIT  DS    0H
         L     R14,CVTPTR          POINT TO THE CVT.
         USING CVT,R14             SET CVT ADDRESSABILITY.
         L     R14,CVTEXPRO        POINT TO EXIT PROLOGUE.
         DROP  R14                 DROP CVT ADDRESSABILITY.
         BR    R14                 BRANCH TO EXIT PROLOGUE.
SVCERROR DS    0H                                              @OZ45753
         MVI   SDBSAVE,0           CLEAR PSEUDO-ECB WAIT/POST  @OZ45753
         LA    R1,SDBSAVE          SET TO WAIT FOREVER         @OZ45753
         WAIT  1,ECB=(R1)          SO RTM CAN RUN              @OZ45753
*        THIS LINE DELETED BY APAR ===>                        @OZ45753
*        THIS LINE DELETED BY APAR ===>                        @OZ45753
         LTORG
         EJECT
*
*
*              HAMSVC - ENDREQ PROCESSING
*
*
SVCENDR  DS    0H
* IF DATA SET NOT OUTPUT, MERELY RETURN
         TM    SDBFLG1,SDB1PUT     IF NOT OUTPUT DATA SET,
         BZ    SVCNORML            RETURN NORMALLY.
* TRUNCATE UNPROTECTED BUFFER
         L     RBUF,SDBUBF         POINT TO UBF FROM SDB.
         L     R1,BFLOC            POINT TO CURRENT LOCATION.
         LA    R5,BFIO             GET ADDRESS OF              @OZ29839
         AH    R5,$SVBFSIZ            BUFFER END.              @OZ29839
         CR    R5,R1               COMPARE BFLOC TO END.       @OZ29839
         BNH   SVCENDRA            ERROR IF BFLOC TOO LARGE.   @OZ29839
         CR    RBUF,R1             COMPARE BFLOC TO START.     @OZ29839
         BL    SVCENDR0            NO ERROR IF BFLOC IN RANGE  @OZ29839
SVCENDRA L     R15,=A(HERBLKER)    SET UP FOR 1FA ABEND.       @OZ29839
         B     SVCEXIT             RETURN TO HAMENDR.          @OZ29839
SVCENDR0 DS    0H                  BUFLOC WITHIN RANGE.        @OZ29839
         MVI   0(R1),LRCBFEND      TRUNCATE THE BUFFER.
* SAVE BFLOC AND BFLEN FOR AFTER SVCPUT RESETS THEM
         LM    R2,R3,BFLOC         SAVE BFLOC, BFLEN
* SET CLOSE FLAG SO DATA SET WILL APPEAR AT END-OF-FILE
         OI    SDBFLG1,SDB1CLOS    CAUSE CLOSE PROCESSING.
* FLAG ALLOCATION IOT SO HCEPUT WILL WRITE IT
         L     RIOT,SDBAIOT        FLAG ALLOCATION IOT FOR
         OI    IOTFLAG1-IOTDSECT(RIOT),IOT1CKPT  CHECKPOINT.
* CALL SVCPUT TO WRITE OUT UNPROTECTED BUFFER CONTENTS
         OI    SDBFLG2,SDB2EOD     SET RECORD COUNT OFF        @OZ43719
         LR    R1,RRPL             SET RPL REGISTER.
         LA    R0,HSVCEOBP         SET FUNCTION REGISTER.
         LNR   R0,R0               FORCE DEBCHK IN IGC111      @OZ41386
         SVC   HAMSVC              START CLOSING.
* RESET THE CLOSE FLAG SO DATA SET CAN CONTINUE WRITING
         NI    SDBFLG1,255-SDB1CLOS  RESET CLOSE FLAG.
         NI    SDBFLG2,255-SDB2EOD RESET RECORD COUNT          @OZ43719
* RESTORE BFLOC AND BFLEN TO RE-ESTABLISH UBF POSITION
         STM   R2,R3,BFLOC         RESTORE BFLOC, BFLEN.
* IF ERROR, RETURN ERROR ADDRESS TO HAMENDR
         LTR   R15,R15             IF ERROR,
         BNZ   SVCEXIT             RETURN CODE TO HAMENDR.
* TEST FOR PURGED I/O AND RESTART EXCP LOOP IF NECESSARY.      @OZ28485
         TM    SDBFLG2,SDB2IOA     IF I/O NOT ACTIVE,          @OZ28485
         BZ    SVCENDR1            NO NEED TO TEST FOR PURGE.  @OZ28485
         CLI   SDBICMP,X'48'       IF ACTIVE AND NOT PURGED,   @OZ28485
         BNE   SVCENDR1            GO WAIT FOR COMPLETION.     @OZ28485
         L     R2,SDBECB           SAVE CURRENT ECB.           @OZ28485
         MVI   SDBECB,0            ZERO THE ECB.               @OZ28485
         EXCP  SDBIOB              START CHANNEL PROGRAM.      @OZ28485
         WAIT  1,ECB=SDBECB        WAIT FOR COMPLETION.        @OZ28485
         LTR   R2,R2               IF SAVED ECB'S WAIT BIT     @OZ28485
         BNM   SVCNORML              IS OFF, BRANCH.           @OZ28485
         ST    R2,SDBECB           ELSE RESTORE IT.            @OZ28485
         IC    R0,SDBICMP          GET POST CODE.              @OZ28485
         SLL   R0,24               LEFT JUSTIFY.               @OZ28485
         POST  SDBECB,(0)          POST THE SAVED ECB.         @OZ28485
         B     SVCNORML            AND DONE.                   @OZ28485
SVCENDR1 DS    0H                                              @OZ28485
* WAIT FOR I/O TO COMPLETE.  THEN RETURN.
         WAIT  1,ECB=SDBECB        WAIT FOR I/O COMPLETION.
         B     SVCNORML            RETURN NORMALLY.
         EJECT
*
*
*              HAMSVC --- INTERNAL READER PROCESSING
*
*
SVCIRD   DS    0H
*
*              IF NO UNPROTECTED BUFFER -
*              GET ONE, $$POST UNIT, AND RETURN
*
         USING DCTDSECT,RSDB       ESTABLISH DCT ADDRESSABILITY.
         SLR   R7,R7               SET ZERO RETURN CODE.
         L     RBUF,RIDUBF         GET UNPROT BUF ADDRESS.
         LTR   RBUF,RBUF           IS THERE ONE...
         BNZ   SVI100              CONTINUE IF SO.
         $GETMAIN BC,SP=229,KEY=15,LV=RIDBUFSZ  ELSE GET ONE.
         BNZ   SVI010              BR IF STORAGE UNAVAILABLE
         LR    RBUF,R1             ELSE SET BUF ADDRESSABILITY.
         ST    RBUF,RIDUBF         SET POINTER IN DCT.
         LA    R0,BFDAT            SET STARTING
         ST    R0,BFLOC            DATA ADDRESS.
         MVC   BFLEN,=A(RIDBUFSZ-(BFDAT+1-BFD))  SET LENGTH.
         XC    RIDEOME,RIDEOME     CLEAR EOM ECB               @OZ48724
         MVC   RIDEOMA,PSAAOLD-PSA  SET ASCB TO POST           @OZ48724
         TM    RIDFLAGS,RIDEOM     IS EOM IN PROGRESS...       @OZ48724
         BZ    SVINEOM             BR IF NOT...ELSE,           @OZ48724
         WAIT  1,ECB=RIDEOME       WAIT FOR RDR TO COMPLETE    @OZ48724
SVINEOM  DS    0H                                              @OZ48724
         NI    DCTSTAT,255-DCTHOLD-DCTDRAIN  RESET DCTHOLD,
         NI    RIDFLAGS,255-RIDEND DCTDRAIN, AND RIDEND.
         MVC   RIDASCBP,PSAAOLD-PSA  SAVE ASCB ADDRESS.
         $$POST TYPE=UNIT          $POST HASP FOR UNIT.
         B     SVCNORML            RETURN NORMALLY.
*
*              IF FAILURE TO GET UNPROTECTED BUFFER -
*              WRITE ERROR MESSAGE AND RETURN
*
SVI010   DS    0H
         BAL   R14,SVIWTO          WRITE ERROR MESSAGE
         B     SVCERRET            *** TEMP RETURN R15=4.
         SPACE 3
*
*              IF UNPROTECTED BUFFER EXISTS,
*              WAIT TILL HASPRDR IS READY
*
SVI100   DS    0H
         L     R1,RIDECB           GET POST ECB                      R4
SKIP420  LR    R2,R1               RELOAD ECB                        R4
         N     R2,=X'7F000000'     RESET WAIT BIT                    R4
         CS    R1,R2,RIDECB        RESET ECB, PRESERVING POST        R4
         BNE   SKIP420             TRY AGAIN, IF UNSUCCESSFUL        R4
         WAIT  1,ECB=RIDECB        ELSE WAIT FOR HASPRDR.
         SLR   R0,R0               THEN
         ST    R0,RIDECB           ZERO OUT THE ECB
*
*              IF PROTECTED BUFFER EXISTS,
*              MOVE DATA TO IT, $$POST IO, AND RETURN
*
SVI110   DS    0H                  TEST PROTECTED BUFFER
         L     R2,RIDPBF           GET PROTECTED BUF ADDRESS.
         LTR   R2,R2               DOES IT EXIST...
         BNZ   SVI120              BRANCH IF SO.
         BAL   R5,SVIFREE          ELSE FREE UNPROT BUFFER,
         BAL   R5,SVIPOST          POST HASP FOR FLAGS,             R41
         BAL   R14,SVIWTO          WRITE MESSAGE,
         B     SVCERRET            AND RETURN ERROR.
SVI120   DS    0H                  MOVE UNPROT BUF TO PROT BUF.
         LA    R2,BFDAT-BFD(,R2)   ELSE GET ITS DATA ADDRESS
         ST    R2,RIDPBFO          AND INITIALIZE RIDPBFO.
         L     R3,=A(RIDBUFSZ-(BFDAT-BFD))  GET LENGTH OF MOVE.
         LA    R4,BFDAT            GET UNPROT DATA ADDRESS.
         L     R1,BFLOC            POINT TO NEXT LRC SPACE.
         LR    R5,R4               GET ADDRESS OF              @OZ29839
         ALR   R5,R3                 BUFFER END.               @OZ29839
         CR    R5,R1               COMPARE BFLOC TO END.       @OZ29839
         BNH   SVIABND             ABEND1FA, BFLOC TOO LARGE.  @OZ29839
         CR    RBUF,R1             COMPARE BFLOC TO START.     @OZ29839
         BNL   SVIABND             ABEND1FA, BFLOC TOO SMALL.  @OZ29839
         USING LRCDSECT,R1         USE LRC DSECT.
         MVI   LRCTLENG,LRCBFEND   TRUNCATE THE BUFFER.
         DROP  R1                  DROP LRC DSECT.
         ST    R4,BFLOC            RE-INITIALIZE UNPROT DATA START
         MVC   BFLEN,=A(RIDBUFSZ-(BFDAT+1-BFD))  AND LENGTH.
         LR    R5,R3               SET SOURCE LENGTH.
         MVCL  R2,R4               MOVE UNPROT TO PROT BUF
         BAL   R5,SVIPOST          AFTER MOVE, POST HASP.
         TM    BFFL1,RIDERQ+RIDCLS IF NOT ENDREQ NOR
         BZ    SVCNORML            CLOSE, JUST RETURN.
         WAIT  1,ECB=RIDECB        WAIT FOR JOB ID FROM HASP.
         BAL   R5,SVIFREE          ELSE FREE UNPROT BUF,
         BAL   R5,SVIPOST          POST HASP FOR FLAGS,
         B     SVCNORML            AND THEN RETURN.
         SPACE 3
*
*              SUBROUTINE TO FREE UNPROTECTED BUFFER
*
SVIFREE  DS    0H                  BAL R5,SVIFREE
         $FREMAIN BC,SP=229,KEY=15,LV=RIDBUFSZ,A=(RBUF)  FREE UBF.
         SLR   R0,R0               ZERO POINTER
         ST    R0,RIDUBF           TO UNPROTECTED BUFFER.
         OI    RIDFLAGS,RIDEND     SHOW INTERNAL READER END
         OI    DCTSTAT,DCTHOLD     AND DEVICE HELD.
         BR    R5                  RETURN TO SUBROUTINE CALLER.
         SPACE 3
*
*              SUBROUTINE TO POST HASP INTERNAL READER
*
SVIPOST  DS    0H                  BAL R5,SVIPOST
         SLR   R0,R0               ZERO OUT ECB
         ST    R0,RIDECB           BEFORE POSTING HASP.
         NI    RIDFLAGS,255-RIDBUSY  SHOW SSSM GIVES UP CONTROL.
         OI    RIDFLAGS,RIDPOST    SHOW HASPDISP WHICH TO POST.
         $$POST ELMT=$SVIRDR       POST HASPDISP FOR INTRDR.
         BR    R5                  RETURN TO SUBROUTINE CALLER.
         SPACE 3
*                                                              @OZ29839
*        IF BUFFER ERROR, FORCE ABEND 1FA                      @OZ29839
*                                                              @OZ29839
SVIABND  ABEND X'1FA',DUMP,,SYSTEM BUFFER ERROR.               @OZ29839
         SPACE 1                                               @OZ29839
*
*              IF ERROR, WRITE ERROR MESSAGE
*
SVIWTO   DS    0H
         L     R7,=A(RPLWTERD+65536*RPLPHYER)  SET ERROR CODE.
         GETMAIN RC,LV=SVIML       GET MESSAGE BUFFER.
         LTR   R15,R15             IF GETMAIN FAILED,
         BNZR  R14                 RETURN TO CALLER.
         LR    R2,R1               ELSE SAVE BUFFER ADDRESS.
         MVC   0(SVIML,R1),SVIM    MOVE MSG TO BUFFER.
         MVC   SVIML1(,R1),DCTDEVN MOVE INTRDR NAME TO MESSAGE.
         WTO   MF=(E,(1))          WRITE THE MESSAGE.
         FREEMAIN RC,LV=SVIML,A=(R2)  FREE THE BUFFER.
         BR    R14                 RETURN TO CALLER.
         $MID  354                 HASP354 IS MESSAGE ID.
SVIM     WTO   '$&MID.******** - STORAGE NOT AVAILABLE FOR BUFFERS',MF=C
               L,ROUTCDE=11,DESC=6
SVIML    EQU   *-SVIM              LENGTH OF MESSAGE BUFFER
SVIML1   EQU   4+1+9,8             LOC, LENGTH OF INTRDR NAME        R4
         USING SDBDSECT,RSDB       RESTORE SDB ADDRESSABILITY.
         LTORG                                                 @OZ32729
         TITLE 'HAM CHANNEL END APPENDAGE'
*
*
*              HASP ACCESS METHOD CHANNEL END APPENDAGE
*
*
HAMCEA   DS    0H
         USING *,R15               ESTABLISH ADDRESSABILITY
         LR    R10,R2              SWITCH IOB ADDRESS TO R10.
         S     R10,=A(SDBIOB-SDBDSECT)  POINT TO SDB.
         CLC   SDBID-SDBDSECT(6,R10),HCSDBID  DOES SDB LOOK OKAY...
         BNER  R14                 NO --- PROBABLY SJB I/O.
         SPACE 3
* SAVE AND SET UP REGISTERS.
         USING SDBDSECT,RSDB       USE THE SDB DSECT.
         L     RSVT,SDBSVT         SET THE SVT BASE REGISTER.
         STM   R0,R15,0(R13)       SAVE REGISTERS.
         BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
HCEBASE  DS    0H
         SPACE 2
         SR    R15,R15             ZERO A REGISTER.
         IC    R15,SDBCHEND        GET DISPLACEMENT FOR CHAN END CODE.
         B     *+4(R15)            BRANCH ACCORDINGLY.
         B     HCEGET              GET
         B     HCEPUT              PUT
         B     HCEPNT              POINT
         B     HCEGUP              GET-UPDATE
HAMAVT   DC    A(*+20,HAMSIO,*+12,HAMCEA,HAMCEX),X'07FE'       @OZ41000
         EJECT                                                 @OZ41000
*                                                              @OZ41000
*        STARTIO  APPENDAGE                                    @OZ41000
*                                                              @OZ41000
HAMSIO   DS    0H                  INDICATE EXCP IN PROCESS    @OZ41000
         USING *,R15               SET LOCAL ADDRESSABILITY    @OZ41000
         STM   R0,R15,0(R13)       SAVE REGISTERS              @OZ41000
         L     R12,=A(HCEBASE)     SET PERMANENT BASE          @OZ41000
         DROP  R15                 DROP TEMPORARY BASE         @OZ41000
         LR    R10,R2              COMPUTE AND SET             @OZ41000
         SL    R10,=A(SDBIOB-SDBDSECT)  SDB POINTER            @OZ41000
         CLC   SDBID,HCSDBID       IF NOT AN SDB,              @OZ41000
         BNE   HAMSIO1                RETURN IMMEDIATELY       @OZ41000
         OI    SDBFLG2,SDB2IOA     SHOW EXCP IN PROGRESS       @OZ41000
HAMSIO1  LM    R0,R15,0(R13)       RESTORE REGISTERS           @OZ41000
         BR    R14                 RETURN TO CONTINUE EXCP     @OZ41000
         SPACE 2                                               @OZ41000
*
*              ABNORMAL CHANNEL END APPENDAGE
*
HAMCEX   DS    0H
         USING *,R15               SET LOCAL ADDRESSABILITY.
         TM    4(R2),X'20'         IF NOT FINAL ENTRY,
         BNZR  R14                 RETURN IMMEDIATELY.
         STM   R0,R15,0(R13)       SAVE REGISTERS.
         L     R12,=A(HCEBASE)     SET PERMANENT BASE.
         DROP  R15                 DROP TEMPORARY BASE.
         LR    R10,R2              COMPUTE AND SET
         SL    R10,=A(SDBIOB-SDBDSECT)  SDB POINTER.
         CLC   SDBID,HCSDBID       IF NOT AN SDB,
         BNER  R14                 RETURN IMMEDIATELY.
         L     RSVT,SDBSVT         SET POINTER TO SSVT.
         OI    SDBFLG2,SDB2IOE     IF SDB, FLAG I/O ERROR
         BR    R12                 AND CONTINUE.
         EJECT
*
*              CHANNEL END GET SERVICES - PERFORMED ONLY IF END-OF-UBUF
*
*
HCEGET   DS    0H
         L     RBUF,SDBUBF         POINT TO THE UNPROTECTED BUFFER.
         USING BFD,RBUF            SET BUFFER ADDRESSABILITY.
         L     R1,BFLENG           PREPARE REGISTERS FOR       @OZ30886
HCEOBTST LR    R2,R1                COMPARE AND SWAP           @OZ30886
         N     R1,=XL4'FFFF7FFF'   RESET BF1EOB IN REG1        @OZ30886
         O     R2,=XL4'00000080'   TURN ON BF2IOC IN R2        @OZ30886
         CS    R1,R2,BFLENG        IF BF1EOB OFF, SET BF2IOC   @OZ30886
         BE    HCEGEND              ON AND BRANCH              @OZ30886
         TM    BFFL1,BF1EOB        DID A DIFFERENT BIT CHANGE  @OZ30886
         BZ    HCEOBTST            TRY AGAIN IF SO             @OZ30886
         CALL  HENDREAD            CHECK COMPLETION ETC.
         TM    SDBFLG2,SDB2IOE     WAS THERE AN I/O ERROR...
         BO    HCRSPEC             BRANCH IF NOT.
         CALL  HMOVEPU             MOVE PROTECTED TO UNPROT ETC.
         TM    SDBFLG2,SDB2EOD     IS THIS LAST OF INPUT...
         BO    HCRSPEC             IF SO, JUST POST ECB.
         CALL  HCNVFDAD            SET NEW FDAD IN IOB.
         LA    R11,BFECB           POINT TO ECB TO POST
         CALL  HPOSTECB            AND GO POST IT.
         LA    R15,8               SET RETURN TO RE-EXCP,
         LA    R0,1                INCREMENT
         A     R0,SDBXCPCT         EXCP
         ST    R0,SDBXCPCT         COUNTER,
         B     HCRETURN            AND RETURN TO IOS.
         SPACE 3
*
*              END OF READ - I/O ERROR OR END-OF-DATA
*
HCRSPEC  DS    0H
         LA    R11,BFECB           POINT TO UNPROT BUF ECB.
         CALL  HPOSTECB            GO POST IT.
HCEGEND  DS    0H
         SLR   R15,R15             SET POST RETURN CODE
         B     HCRETURN            AND RETURN TO IOS.
         EJECT
*
*
*              CHANNEL END SERVICES FOR GET-UPDATE
*
*
HCEGUP   DS    0H
         USING LRCDSECT,R1         USE LOGICAL RECORD DSECT.
*
*              FIND AND VALIDITY-CHECK PROTECTED BUFFER
*
         L     RBUF,SDBGBF         POINT TO FIRST PROT BUFFER.
HCGUV1   L     R1,BFBF             POINT TO NEXT.
         LTR   R1,R1               IF NEXT IS ZERO, WE HAVE
         BZ    HCGUV2              THE BUFFER WE WANT.
         LR    RBUF,R1             ELSE MAKE NEXT CURRENT
         B     HCGUV1              AND LOOP.
HCGUV2   CLC   BFKEY,SDBKEY        IS BUFFER KEY CORRECT...
         BNE   HCGU80              IF NOT, SHOW ERROR.
*
*              MOVE PROTECTED BUFFER TO LAST HOLD BUFFER
*
         LA    R4,BFIO             POINT TO BUFFER I/O PORTION.
         LH    R5,$SVBFSIZ         GET ITS LENGTH.                   R4
         L     R1,BFECB            POINT TO CORRESP UNPROT BUF.
         LA    R2,BFIO-BFD(,R1)    POINT TO ITS I/O PORTION.
         LR    R3,R5               SET SINK LENGTH.
         MVCL  R2,R4               MOVE UPD-PROT TO UPD-UNPROT.
*
*              IF THIS IS FIRST HOLD BUFFER FIND RECORD START
*
         CL    RBUF,SDBGBF         IS THIS FIRST UPDATE BUFFER...
         BNE   HCGU10              BRANCH IF NOT.
         LM    R2,R3,SDBUPRBA      LOAD REQUIRED RBA INTO R2,R3
         CALL  HFINDRBA            FIND REQUESTED LOGICAL RECORD.
         BC    7,HCGU80            SHOW ERROR IF NOT FOUND.
         LR    R2,R1               TRANSFER REC ADR TO R2.
         SLR   R2,RBUF             COMPUTE RECORD OFFSET.
         L     R3,BFECB            POINT R3 TO UNPROT BUFFER.
         ALR   R2,R3               COMPUTE ADR OF IMAGE IN HBF.
         ST    R2,BFLOC-BFD(,R3)   STORE THAT ADDRESS IN HBF.
         SLR   R15,R15             ASSUME RECORD NOT SPANNED.
         TM    LRCFLAG1,LRC1SPAN   IS THIS A SPANNED RECORD...
         BZ    HCRETURN            IF NOT, RETURN TO POST.
         TM    LRCFLAG1,LRC1SEND   YES.  IS THIS LAST SEGMENT...
         BO    HCRETURN            IF SO, RETURN TO POST.
         B     HCGU20              ELSE READ ANOTHER RECORD.
*
*              NOT FIRST HOLD BUFFER - IF END, RETURN
*
HCGU10   L     R3,BFECB            POINT TO HBF (UPDATE-UNPROT).
         LA    R1,BFDAT-BFD(,R3)   SET DATA IMAGE ADDRESS
         ST    R1,BFLOC-BFD(,R3)   IN IT.
         TM    LRCFLAG1,LRC1SPAN   IS THIS A SPANNED RECORD...
         BZ    HCGU80              SHOW ERROR IF NOT.
         SLR   R15,R15             ASSUME LAST SEGMENT.
         TM    LRCFLAG1,LRC1SEND   IS THIS THE LAST SEGMENT...
         BO    HCRETURN            IF SO, RETURN TO POST.
*
*              GET MORE BUFFERS AND READ NEXT RECORD
*
HCGU20   DS    0H
         $GETBUF TYPE=PROT         GET A NEXT PROTECTED BUFFER.
         BNZ   HCGU85              BRANCH IF NO STORAGE.
         ST    R1,BFBF             POINT CURRENT TO NEXT.
         MVI   BFID-BFD(R1),C'G'   SHOW UPDATE-PROTECTED.
         SLR   R0,R0               ZERO NEXT PROTECTED BUFFER'S
         ST    R0,BFBF-BFD(,R1)    CHAIN ADDRESS.
         MVC   BFTRK-BFD(,R1),BFNXT  SET NEXT BUF TRACK ADDRESS.
         $GETBUF TYPE=UNPROT       GET A NEXT UNPROTECTED BUFFER.
         BNZ   HCGU85              BRANCH IF NO STORAGE.
         LR    R5,RBUF             POINT R5 TO CURRENT PROT BUF.
         L     RBUF,BFECB          POINT RBUF TO CURR UNPROT BUF.
         ST    R1,BFBF             POINT CURR TO NEXT UNPROT.
         MVI   BFID-BFD(R1),C'H'   SHOW UPDATE-UNPROTECTED.
         SLR   R0,R0               ZERO NEXT UNPROTECTED BUFFER'S
         ST    R0,BFBF-BFD(,R1)    CHAIN ADDRESS.
         L     RBUF,BFBF-BFD(,R5)  POINT RBUF TO NEXT PROT.
         ST    R1,BFECB            POINT NEXT PROT TO NEXT UNPROT.
         MVC   SDBMTTR,BFTRK       MOVE MTTR FROM NEXT PROT
         CALL HCNVFDAD             FOR CONVERSION, AND CONVERT.
         LA    R1,BFIO             POINT TO I/O AREA           @OZ43706
         ICM   R1,8,SDBCCW4        GET COMMAND CODE            @OZ43706
         ST    R1,SDBCCW4          STORE NEW CCW               @OZ43706
         LA    R15,8               RETURN FROM CE APPENDAGE
         B     HCRETURN            TO CAUSE RE-EXCP.
         SPACE 1
HCGU80   OI    SDBFLG2,SDB2IOE     SHOW I/O ERROR                    R4
         MVC   SDBSAVE,=A(HERRDERD)  SET ERROR ADDRESS.
         SLR   R15,R15             DON'T RESTART.
         B     HCRETURN            RETURN.
HCGU85   DS    0H
         OI    SDBFLG2,SDB2IOE     SHOW I/O ERROR.
         MVC   SDBSAVE,=A(HERSTOR) SET ERROR ADDRESS.
         SLR   R15,R15             DON'T RESTART.
         B     HCRETURN            RETURN.
         EJECT
*
*
*              CHANNEL END PUT SERVICES
*
*
HCEPUT   DS    0H
*
*              ADD BUFFERS FROM SDBPBFX TO CHAIN SDBPBF
*
         L     R1,SDBPBFX          DECHAIN
         SLR   R0,R0               EVERYTHING
         CS    R1,R0,SDBPBFX       ON CHAIN
         BNE   *-4                 SDBPBFX.
         LTR   R1,R1               WAS CHAIN EMPTY...
         BZ    HCEP40              BRANCH IF SO.
         SPACE 1
         LA    RBUF,SDBPBF-(BFBF-BFD)  CHAIN THROUGH
HCEP10   LR    R3,RBUF             THE SDBPBF
         L     RBUF,BFBF           CHAIN TO FIND
         LTR   RBUF,RBUF           THE LAST BUFFER
         BNZ   HCEP10              ON IT.  (R3 PTS TO LAST BUF.)
         SPACE 1
HCEP20   LR    RBUF,R1             SCAN SDBPBFX CHAIN,
         SLR   R5,R5               SAVING 2D-TO-LAST & LAST PTRS.
HCEP30   LR    R4,R5               SAVE 2D-TO-LAST POINTER.
         LR    R5,RBUF             SAVE LAST POINTER.
         L     RBUF,BFBF           IF RBUF IS ZERO,
         LTR   RBUF,RBUF           R4=2D-TO-LAST AND R5=LAST.
         BNZ   HCEP30              IF NOT, LOOP TILL SO.
* R5 POINTS TO LAST BUFFER ON SDBPBFX CHAIN
         ST    R5,BFBF-BFD(,R3)    ADD THE BUF TO SDBPBF CHAIN.
         LR    R3,R5               SET R3 TO LAST BUF ON SDBPBF.
* R4 IS EITHER ZERO (END) OR PTR TO 2D-TO-LAST BUFFER.
         LTR   R4,R4               IF R4 IS ZERO,
         BZ    HCEP40              SDBPBFX CHAIN IS DONE.
         ST    R0,BFBF-BFD(,R4)    ELSE SHOW 2D-LAST BUF IS LAST
         B     HCEP20              AND GO DECHAIN NEW LAST.
*
*              DECHAIN 1ST SDBPBF AND PUT ON SDBFBF
*
HCEP40   DS    0H
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         L     RIOT,SDBAIOT        POINT TO ALLOCATION IOT.
         LA    R0,IOTSTART         POINT TO ITS I/O PORTION.
         CLM   R0,7,SDBCCW4+1      IF WE JUST WROTE IT,
         BE    HCEP50              DON'T FOR GOD SAKES FREE IT.
         DROP  RIOT                DROP IOT BASE.
         L     RBUF,SDBPBF         POINT TO FIRST BUF ON SDBPBF.
         LTR   RBUF,RBUF           IF ALREADY DECHAINED, I/O   @OZ72432
         BZ    HCEP50               WAS REDRIVEN BY EOT        @OZ72432
         MVC   SDBPBF,BFBF         DECHAIN IT FROM SDBPBF.
         OI    BFFL1,BF1IOC        SHOW I/O COMPLETE.
         L     R1,SDBFBF           GET PTR TO OLD LAST SDBFBF.
         ST    R1,BFBF             STORE PTR IN THIS BUF'S CHAIN.
         CS    R1,RBUF,SDBFBF      SET NEW LAST SDBFBF.
         BNE   *-8                 IF INTERFERENCE, STORE AGAIN.
*
*              SHOW I/O COMPLETE AND HONOR EARLY POST REQUEST
*
         ICM   R11,15,SDBWAITQ     ANY WAITS FOR EARLY POST..  @OZ37582
         BZ    HCEP49              BRANCH IF NOT.              @OZ37582
         SLR   R15,R15             YES, CLEAR REG FOR SWAP     @OZ37582
HCEP45   CS    R11,R15,SDBWAITQ    DECHAIN ALL WAITERS         @OZ37582
         BNE   HCEP45              A NEW ONE, TRY AGAIN        @OZ37582
HCEP48   L     R4,4(R11)           SAVE ADDRESS OF NEXT ONE    @OZ37582
         CALL  HPOSTECB            POST CURRENT ONE            @OZ37582
         LTR   R11,R4              IS THERE A NEXT ONE...      @OZ37582
         BNZ   HCEP48              YES, GO POST IT             @OZ37582
HCEP49   L     RSVT,SDBSVT         RESTORE SSVT POINTER.       @OZ37582
*
*              START I/O FOR NEXT PROTECTED BUFFER
*
HCEP50   DS    0H
         L     RIOT,SDBAIOT        POINT TO ALLOCATION IOT.
         LTR   RIOT,RIOT           IF IT DOESN'T EXIST,
         BZ    HCEP55              CONTINUE NORMALLY.
         USING IOTDSECT,RIOT       SET IOT ADDRESSABILITY.
         TM    IOTFLAG1,IOT1CKPT   DOES IT NEED WRITING...
         BZ    HCEP55              IF NOT, CONTINUE NORMALLY.
         NI    IOTFLAG1,255-IOT1CKPT  RESET CHECKPOINT FLAG.
         LA    R0,IOTSTART         SET IOT ADDRESS
         STCM  R0,7,SDBCCW4+1      IN SDBCCW4.
         MVC   SDBMTTR,IOTTRACK    CONVERT
         CALL  HCNVFDAD            TRACK ADDRESS.
         LA    R15,8               SET RETURN TO +8.
         B     HCRETURN            RETURN TO EXCP.
         DROP  RIOT                DROP IOT BASE.
HCEP55   DS    0H
         L     RBUF,SDBPBF         POINT TO NEXT PBF FOR I/O.
         LTR   RBUF,RBUF           CAN WE START AN I/O...
         BZ    HCEP60              BRANCH IF NOT.
         MVC   SDBMTTR,BFTRK       MOVE RELATIVE TRACK AND
         CALL  HCNVFDAD            CONVERT IT TO ABSOLUTE.
         LA    R0,1                INCREMENT
         AL    R0,SDBXCPCT         EXCP
         ST    R0,SDBXCPCT         COUNTER.
         LA    R0,BFIO             SET BUFFER I/O ADDRESS
         STCM  R0,7,SDBCCW4+1      INTO WRITE-DATA CCW.
         LA    R15,8               CAUSE RETURN TO RE-EXCP.
         B     HCRETURN            RETURN TO IOS.
*
*              NO BUFFERS LEFT.  ALLOW SVCPUT TO ISSUE EXCP.
*
HCEP60   DS    0H
         SLR   R15,R15             CAUSE RETURN TO POST.
         B     HCRETURN            RETURN TO IOS.
         EJECT
*
*              CHANNEL END POINT SERVICES
*
HCEPNT   DS    0H
         CALL  HENDREAD            CHECK I/O COMPLETION.
         TM    SDBFLG2,SDB2IOE     IF I/O ERROR,
         BO    HCT800              BRANCH.
* SET SDBTRK, BFRBA (PBF) FROM SDBUPRBA.  FIND RBA IN PBF.
         L     RBUF,SDBPBF         POINT TO PROTECTED BUFFER.
         USING BFD,RBUF            SET BUFFER ADDRESSABILITY.
         LM    R2,R3,SDBUPRBA      GET POINT TARGET RBA.
         STM   R2,R3,SDBTRK        SET SDBTRK FROM IT.
         STM   R2,R3,BFRBA         ALSO PROTECTED BFRBA.
         CALL  HFINDRBA            SEARCH FOR LOGICAL RECORD.
         LA    LINK,HCRETURN       SET EOB & RF EXIT ADDRESS         R4
         BZ    HCT100              BRANCH IF FOUND.
         LA    LINK,HCT820         SET EOB & NRF EXIT ADDRESS        R4
         SPACE 2
* LOGICAL RECORD NOT FOUND IN THIS BUFFER ---
* UPDATE SDBRECCT, THE LOGICAL RECORD COUNTER
         LCR   R2,R3               GET NEG OF DECREMENTED COUNT.
         L     R15,BFRBA+4         UPDATE                            R4
         LA    R15,0(R2,R15)        THE LOGICAL                      R4
         AL    R15,SDBRECCT          RECORD                          R4
         ST    R15,SDBRECCT           COUNTER                        R4
* UPDATE VALUE OF SDBUPRBA FOR NEXT PHYSICAL RECORD
         L     R0,BFNXT            GET NEXT TRACK ADDRESS.
         LTR   R0,R0               IF IT'S ZERO, WE'RE AT EOF.
         BZ    HCT100              GO MOVE PBF TO UBF                R4
         STCM  R0,15,SDBUPRBA+1    ELSE SET NEXT TRACK AND
         STCM  R3,7,SDBUPRBA+5     DECR'D COUNT IN SDBUPRBA.
* EXIT TO READ NEXT PHYSICAL RECORD
         ST    R0,SDBMTTR          SET TRK ADR TO CONVERT.
         CALL  HCNVFDAD            CONVERT TO MBBCCHHR.
         LA    R15,8               SET +8 IOS RETURN.
         B     HCRETURN            RETURN TO RESTART CHAN PROG.
         SPACE 3
* R1 POINTS TO THE TARGET LOGICAL RECORD
HCT100   DS    0H
* MOVE PROTECTED BUFFER TO UNPROTECTED BUFFER
         L     R7,SDBUBF           R7 POINTS TO UNPROT BUFFER.
         LA    R4,BFIO-BFD(,R7)    R4 IS UBF START-OF-MOVE.
         LA    R2,BFIO-BFD(,RBUF)  R2 IS PBF START-OF-MOVE.
         LH    R3,$SVBFSIZ         R3 IS LENGTH OF MOVE.             R4
         LR    R5,R3               SO IS R5.
         MVCL  R4,R2               MOVE PBF TO UBF.
* SET NEXT TRACK ADDRESS FOR CONVERSION.
         MVC   SDBMTTR,BFNXT       SET NEXT TRACK FROM PBF.
* SET UP POINTERS AND FLAGS IN UNPROTECTED BUFFER.
         SLR   R1,R6               SUBTR PBF ADR FROM POSITION.
         ALR   R1,R7               ADD UBF ADR TO POSITION.
         LR    RBUF,R7             SET UBF ADDRESSABILITY.
         ST    R1,BFLOC            SAVE POSITION IN UBF.
         NI    BFFL1,255-BF1EOB    SHOW UBF NOT EMPTY.               R4
         SLR   R7,R1               COMPUTE (UBF START)-(POSN).
         AH    R7,$SVBFSIZ         ADD USABLE                        R4
         AL    R7,=A(BFIO-1-BFD)   BUF LENG.                         R4
         ST    R7,BFLEN            SAVE REMAINING UBF LENGTH.
         MVC   BFRBA,SDBTRK        SET CURRENT RBA IN UBF.
* IF DATA SET WAS OPENED FOR INPUT, READ AGAIN.
* OTHERWISE JUST RETURN FOR IOS TO POST.
         SLR   R15,R15             SET IOS RETURN +0.
         ST    R15,SDBSAVE         SET COMPLETION CODE ZERO.
         TM    SDBFLG2,SDB2EOD     IF INPUT DATA SET AT EOF,
         BOR   LINK                 GO SET UP HAM EXIT               R4
         TM    SDBFLG1,SDB1GET     IF DATA SET NOT INPUT,            R4
         BZ    HCRETURN             RETURN TO POST                   R4
         MVI   SDBCHEND,SDBCEGET   SET HCEGET APPENDAGE.
         CALL  HCNVFDAD            CONVERT NEXT TRACK ADDRESS.
         LA    R15,8               SET IOS RETURN TO +8.
         B     HCRETURN            RETURN TO RESTART CHAN PROG.
         SPACE 3
* I/O ERROR OR BAD DATA SET KEY FOUND BY HENDREAD
HCT800   DS    0H
         L     R0,=A(HERRDERD)     SET ADDRESS OF HAM EXIT.
         B     HCT890              RETURN.
         SPACE 2
* END-OF-DATASET FOUND BEFORE END-OF-POINT
HCT820   DS    0H
         L     R0,=A(HERNOEOD)     SET ADDRESS OF HAM EXIT.
         SPACE 2
* COMMON CODE FOR EXCEPTIONAL EXIT
HCT890   DS    0H
         ST    R0,SDBSAVE          SAVE HAM EXIT ADDRESS.
         SLR   R15,R15             DO NOT RE-EXCP.
         B     HCRETURN            RETURN FOR POSTING.
         EJECT
*
*              EXIT FROM CHANNEL END
*
HCRETURN DS    0H
         LTR   R15,R15             IF NO RESTART,
         BZ    HCRET20             GO RESET I/O-ACTIVE FLAG.
         L     R1,4(,R13)          RESTART.  POINT TO RQE,
         L     R1,28(,R1)          THENCE TO SRB/IOSB,
         L     R1,28(,R1)          GET IOSB ADDRESS                  R4
         L     R1,IOSIPIB-IOSB(,R1)  GET IPIB ADDRESS                R4
         LTR   R1,R1               IF IPIB NOT PRESENT,
         BZ    HCRET40             RESTART IS OKAY.
         OI    SDBFLG1,SDB1BFXS    SHOW BUFFER EXCESSION OKAY.
         SLR   R15,R15             DON'T REDRIVE I/O.
HCRET20  DS    0H
         NI    SDBFLG2,255-SDB2IOA SHOW I/O INACTIVE.
         ICM   R11,15,SDBWAITQ     ANY WAITS FOR EARLY POST..  @OZ37582
         BZ    HCRET40             BR IF NO                    @OZ37582
         SLR   R15,R15             YES, CLEAR REG FOR SWAP     @OZ37582
HCRET25  CS    R11,R15,SDBWAITQ    DECHAIN ALL WAITERS         @OZ37582
         BNE   HCRET25             A NEW ONE, TRY AGAIN        @OZ37582
HCRET30  L     R4,4(R11)           SAVE ADDRESS OF NEXT ONE    @OZ37582
         CALL  HPOSTECB            POST CURRENT ONE            @OZ37582
         LTR   R11,R4              IS THERE A NEXT ONE...      @OZ37582
         BNZ   HCRET30             YES, GO POST IT             @OZ37582
         SLR   R15,R15             RESET FOR NO RESTART        @OZ37582
HCRET40  DS    0H                                                    R4
         LTR   R15,R15             TEST AGAIN FOR RE-EXCP.
         LM    R0,R14,0(R13)       RESTORE REGISTERS BUT R15.
         BZR   R14                 RETURN TO POST COMPLETE.
         USING DEBBASIC,R3         ELSE SET DEB BASE.
         SLR   R10,R10             ZERO R10 FOR IC.
         IC    R10,32(,R2)         GET EXTENT NUMBER FROM IOB.
         SLL   R10,4               MULTIPLY EXTENT BY 16.
         LA    R10,DEBSUCBA+2(R10) DEVELOP DEB EXTENT ADDRESS
         SLR   R7,R7               CLEAR REGISTER
         ICM   R7,3,0(R10)         INSERT UCB ADDRESS
         STH   R7,2(,R1)           SET RQEUCB.
         L     R10,28(,R1)         POINT TO SRB/IOSB.
         L     R10,28(,R10)        GET IOSB ADDRESS                  R4
         ST    R7,IOSUCB-IOSB(,R10)  SET IOSUCB                      R4
         B     0(R14,R15)          RETURN TO OFFSET IN R15.
         DROP  R3                  DROP DEB BASE.
         SPACE 3
*
*        CONSTANTS
*
HCSDBID  DC    CL4'SDB',AL2(SDBLNG)
         DROP  RBUF                DROP BUFFER ADDRESSABILITY.
         EJECT
         LTORG
         TITLE 'SUBROUTINES FOR HAMSVC AND CE APDG'
*
*
*              HENDREAD - VERIFY COMPLETION OF A READ
*
*
HENDREAD DS    0H
         USING *,R15               ESTABLISH ADDRESSABILITY.
         CLI   SDBICMP,X'7F'       WAS COMPLETION NORMAL...
         BNE   HERIOERR            IF NOT, SHOW I/O ERROR.
         L     RPBF,SDBPBF         YES.  POINT TO PROTECTED BUFFER.
         USING BFD,RPBF            USE BUFFER DSECT.
         CLC   SDBKEY,BFKEY        DOES KEY MATCH...
         BNE   HERIOERR            IF NOT, SHOW I/O ERROR.
         L     R1,BFNXT            YES.  NOW CHECK FOR
         LTR   R1,R1               END-OF-DATA-SET.
         BZ    HEREOD              IF ZERO, SHOW END-OF-DATA.
         CLI   BFNXT+3,0           IF RECORD NUMBER NON-ZERO,
         BNER  R14                 RETURN TO CALLER.
*                                  OTHERWISE, I/O ERROR.
         SPACE 3
HERIOERR DS    0H
         OI    SDBFLG2,SDB2IOE     SHOW I/O ERROR
         BR    R14                 AND RETURN.
         SPACE 3
HEREOD   DS    0H
         OI    SDBFLG2,SDB2EOD     SHOW END-OF-DATA
         BR    R14                 AND RETURN.
         SPACE 3
         DROP  R15,RPBF
         EJECT
*
*
*              HPOSTECB - POST AN ECB ACCORDING TO MVM STANDARDS
*
*
HPOSTECB DS    0H
         USING *,R15
*
*        POST ECB IN SAME MEMORY
*
         LR    R2,R14              SAVE RETURN ADDRESS.
         LR    R0,R10              SAVE ADDRESS OF DDT.
         LR    R3,R13              SAVE R13 IN R3.
         L     R10,=X'40000000'    LOAD POST CODE.
         L     R1,0(,R11)          GET ECB.
         LTR   R1,R1               IS ECB WAITING...
         BM    HPE010              BRANCH IF SO, TO POST.
         CS    R1,R10,0(R11)       POST ECB IF STILL UNWAITING.
         BE    HPE020              BRANCH IF OK, TO AVOID POST.
HPE010   L     R15,CVTPTR          POINT TO CVT.
         USING CVTMAP,R15          USE THE CVT DSECT.
         L     R15,CVT0PT01        POINT TO IEA0PT01.
         BALR  R14,R15             POST BY BRANCH ENTRY.
HPE020   LR    R10,R0              RESTORE ADDRESS OF DDT.
         L     RSVT,SDBSVT         RELOAD THE SVT BASE REGISTER.
         LR    R13,R3              RESTORE R13 FROM R3.
         SLR   R15,R15             SET R15 TO ZERO                   R4
         BR    R2                  RETURN TO CALLER.
         DROP  R15                 DROP CVT ADDRESSABILITY.
         EJECT
*
*
*              HMOVEPU - MOVE PROTECTED BUFFER TO UNPROTECTED BUFFER
*
*
HMOVEPU  DS    0H
         USING *,R15
         USING BFD,RBUF            USE THE BUFFER DSECT.
         MVC   SDBTRK+1(4),SDBMTTR SET CURRENT RBA IN DDT.
         LA    R0,1                SET RBA'S RECORD NUMBER
         STCM  R0,7,SDBTRK+5       TO 000001.
         L     R1,BFRBA+4          GET MAX+1 RECORD NR.
         LA    R1,0(,R1)           CLEAN IT UP.
         BCTR  R1,0                COMPUTE MAX REC NR.
         LTR   R1,R1               DON'T USE IT
         BNP   HMOVPU20            UNLESS POSITIVE (IT, NOT YOU).
         AL    R1,SDBRECCT         ADD NR OF RECS READ FROM
         ST    R1,SDBRECCT         PREV BUFFER TO SDBRECCT.
HMOVPU20 DS    0H
         MVC   BFRBA,SDBTRK        SET BFRBA FOR NEXT BUFFER.
         LA    R2,BFDAT            POINT TO UBF DATA AREA AND
         ST    R2,BFLOC            SET ADDRESS IN UBF.
         LA    R2,BFIO             POINT TO START OF MOVE.
         LH    R3,$SVBFSIZ         GET LENGTH OF SINK AREA.          R4
         L     R4,SDBPBF           POINT TO PROTECTED BUFFER AND
         MVC   SDBMTTR,BFNXT-BFD(R4)  MOVE NEXT TRACK AND
         LA    R4,BFIO-BFD(,R4)    THENCE TO SOURCE DATA.
         LR    R5,R3               GET SOURCE LENGTH (SAME AS SINK).
         MVCL  R2,R4               MOVE SOURCE TO SINK.
         NI    BFFL1,255-BF1EOB    SHOW NOT END-OF-BUFFER.           R4
         BR    R14                 RETURN TO CALLER.
         DROP  R15                 DROP LOCAL ADDRESSABILITY.
         EJECT
*
*
*              HCNVFDAD - CONVERT MTTR TO MBBCCHHR
*
*                                  MTTR IS GOT FROM DDTMTTR
*                                  MBBCCHHR IS PUT IN DDTIFDAD
*
*
HCNVFDAD DS    0H
         USING *,R15               ESTABLISH ADDRESSABILITY.
         MVI   SDBIFDAD+1,X'FF'    SET FALSE FDAD TO CAUSE
         CLC   SDBMTTR(1),$SVNUMDA  POST OF X'42' IF                 R4
         BNLR  R14                   INVALID EXTENT.                 R4
         L     R3,SDBMTTR          PREPARE TO SET MBBCCHHR IN IOB.
         LA    R0,0(,R3)           GET MTTR, ISOLATE TTR IN R0.
         XR    R3,R0               ISOLATE M IN R3.
         ST    R3,SDBIFDAD         SET 'M000' IN THE IOB.
         STC   R0,SDBIFDAD+8       SET RECORD NR TOO FAR RIGHT.
         SRL   R3,24               SHIFT EXTENT NR FOR MULTIPLY.
         MH    R3,=AL2(TEDSIZ)     COMPUTE ADR OF EXTENT DATA
         AL    R3,$SVTED           APPLICABLE TO THIS EXTENT.        R4
         USING TEDDSECT,R3         USE DSECT TO ADDRESS IT.
         SRDL  R0,40               SHIFT 'TT' FOR DIVIDE.
         D     R0,TNTC             COMPUTE CYLINDER AND HEAD NUMBERS.
         STH   R1,SDBIFDAD+4       SET CYLINDER NUMBER TOO FAR RIGHT.
         STH   R0,SDBIFDAD+6       SET HEAD NUMBER TOO FAR RIGHT.
         MVC   SDBIFDAD+3(5),SDBIFDAD+4  SHIFT CCHHR LEFT ONE BYTE.
* ADD ONE TO INPUT/OUTPUT SERVICE MEASURE
         L     R4,PSAAOLD-PSA      POINT TO CURRENT ASCB.
         USING ASCB,R4             SET ASCB ADDRESSABILITY.
         L     R0,ASCBIOSM         GET CURRENT IOSM - BYTES 0,1.
HCNVIOSM DS    0H
         LR    R2,R0               MOVE IT TO UPDATE REGISTER.
         AL    R2,=FS16'1'         ADD 1 TO SERVICE MEASURE.
         CS    R0,R2,ASCBIOSM      STORE NEW MEASURE.
         BNE   HCNVIOSM            REPEAT IF INTERFERENCE.
         DROP  R4                  DROP ASCB ADDRESSABILITY.
* SET UP SET-SECTOR COMMAND FOR ROTATIONAL POSITION SENSING
         MVI   SDBCCW1,3           ASSUME NOT RPS.
         L     R1,TRPS             POINT TO EXTENT'S RPS TABLE.
         LTR   R1,R1               IS POINTER ZERO...
         BZR   R14                 IF SO, RETURN.
         SR    R3,R3               THIS IS AN RPS DEVICE.
         IC    R3,SDBMTTR+3        GET RECORD NUMBER AND
         IC    R3,0(R1,R3)         THEN SECTOR NUMBER.
         STC   R3,SDBCCW1+5        PUT SECTOR NUMBER IN 1ST CCW
         MVI   SDBCCW1,X'23'       AND MAKE CCW A SET-SECTOR.
         BR    R14                 THEN RETURN.
         SPACE 1                                                     R4
         LTORG
         DROP  ,
         TITLE 'GETMAIN/FREEMAIN SUBROUTINE'
*
*
*              BRANCH-TYPE GETMAIN/FREEMAIN SUBROUTINE
*
*
HGFMAIN  DS    0H
         USING *,R15
*
*              SET PROTECTION KEY TO ZERO
*
         MODESET EXTKEY=ZERO,SAVEKEY=(2)  SAVE KEY, SET KEY ZERO.
         LA    R4,0(,R4)           SAVE FORMER KEY
         SLL   R2,24               IN REGISTER 4,
         OR    R4,R2               BITS 0-3.
*
*              SAVE REGISTERS PREPARATORY TO SETLOCK
*
         LR    R3,R11              SAVE REGISTER 11 IN REGISTER 3.
         LR    R7,R12              SAVE REGISTER 12 IN REGISTER 7.
         LR    R2,R13              SAVE REGISTER 13 IN REGISTER 2.
*
*              ACQUIRE LOCAL LOCK AND SAVE RETURN CODE
*
HGF010   SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=HGF020
         SLL   R13,24              SAVE SETLOCK RETURN CODE
         OR    R4,R13              IN REGISTER 4 BITS 4-7.
*
*              RESTORE REGISTERS AFTER SETLOCK
*
         LR    R11,R3              RESTORE REGISTER 11 FROM REG 3.
         LR    R12,R7              RESTORE REGISTER 12 FROM REGISTER 7.
         LR    R13,R2              RESTORE REGISTER 13 FROM REGISTER 2.
*
*              LOAD CRBRANCH, TCB, AND ASCB ADDRESSES
*
         LR    R2,R4               SAVE CONTENTS OF R4 IN R2.
         TM    0(R2),X'50'         IS THIS BUFFER FREEMAIN...
         BNO   HGFB10              BRANCH IF NOT.
* BUFFER FREEMAIN - TCB, ASCB ARE USED FROM BUFFER
         USING BFD,R1              USE THE BUFFER DSECT.
         USING PSA,R0              USE PREFIX SAVE AREA DSECT  @OZ42546
         L     R3,PSATOLD          POINT TO CURRENT TCB        @OZ42546
         TM    TCBPKF-TCB(R3),X'80' IF NOT PROBLEM PROGRAM     @OZ42546
         BZ    HGF015                  STATE, BRANCH           @OZ42546
         CLI   1(R2),X'F0'         IS THIS A UBUF...           @OZ42546
         BE    HGFB10              ...BRANCH IF SO             @OZ42546
HGF015   L     R4,BFTCB            R4=TCB ADDRESS.             @OZ42546
         B     HGFB20              CONTINUE.
* OTHER OPERATION - TCB, ASCB ARE USED FROM IEATCBP
*              THIS LINE DELETED BY APAR ===>                  @OZ42546
HGFB10   EQU   *                                               @OZ43706
         ICM   R4,15,PSATOLD       GET CURRENT TCB             @OZ43706
         BNZ   HGFB102             R4=TCB IF TCB MODE          @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
*        GET TCB FROM INPUT RQE IF UNDER SRB FOR CHAN-END      @OZ43706
HGFB101  L     R4,4(R13)           R4=RQE FROM CHANNEL-END     @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
         L     R4,RQETCB-RQE(R4)   R4=TCB FROM RQE             @OZ43706
HGFB102  LR    R3,R4               SAVE R4                     @OZ43706
         USING TCB,R4              SET TCB ADDRESSABILITY.
         L     R4,TCBJSCB          POINT TO TCB'S JSCB.
         USING IEZJSCB,R4          SET JSCB ADDRESSABILITY.
         L     R4,JSCBACT          POINT TO ACTIVE JSCB.
         L     R4,JSCBTCBP         POINT THENCE TO TCB.
         LTR   R4,R4               IF NONZERO POINTER,
         BNZ   *+6                 KEEP IT                     @OZ43706
         LR    R4,R3               RESTORE TCB ADDRESS         @OZ43706
         TM    0(R2),X'18'         IS TCB SUPPLIED FOR FREEMAIN...
         BNO   *+8                 SKIP IF NOT.
         L     R4,0(,R1)           USE USER-SUPPLIED TCB.
         DROP  R4                  DROP JSCB BASE.
HGFB20   L     R7,PSAAOLD          R7 = ASCB ADDRESS.
* SINCE R15 IS OUR BASE, POINT TO CRBRANCH WITH R14.
         L     R3,CVTPTR           POINT TO CVT
         USING CVT,R3              AND USE DSECT.
         L     R14,CVTCRMN         LOAD ADDRESS OF CRBRANCH.
*
*              SET UP ARGUMENTS - R0, R1, AND R3
*
         DROP  R0,R1,R3            DROP ADDRESSABILITIES.
         L     R3,0(,R2)           R3 = KEY, SUBPOOL, TYPE.
         LTR   R3,R3               SET CC=1 IF R0 ALREADY SET.
         LA    R3,0(,R3)           ZERO OUR FLAG BYTE IN R3.
         BM    *+8                 SKIP IF R0 IS ALREADY SET.
         L     R0,4(,R2)           R0 = LENGTH.
* R1 IS ALWAYS SET IN MACRO-EXPANSION.
         CLI   1(R2),X'F0'         ARE WE TO USE TCBPKF AS KEY...
         BNE   HGFB201             NO                          @OZ43706
         ICM   R3,15,PSATOLD-PSA   GET CURRENT TCB             @OZ43706
         BNZ   HGFB203             BR IF IN TCB MODE           @OZ43706
*        GET TCB FROM INPUT RQE IF UNDER SRB FOR CHAN-END      @OZ43706
         L     R3,4(R13)           GET RQE ADDR FROM INPUT     @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
         L     R3,RQETCB-RQE(R3)   GET TCB FROM RQE            @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
*              THIS LINE DELETED BY APAR NUMBER                @OZ43706
HGFB203  EQU   *                                               @OZ43706
         LR    R15,R3              PUT TCB ADDRESS IN R15      @OZ43706
         L     R3,0(,R2)           RESTORE PARM                @OZ43706
         LA    R3,0(,R3)           CLEAR HIGH BYTE             @OZ43706
         USING TCB,R15             USE TCB DSECT,
         ICM   R3,4,TCBPKF         AND PICK UP CURRENT KEY.
         DROP  R15                 DROP TCB ADDRESSABILITY.
*
*              CALL CRBRANCH
*
HGFB201  EQU   *                                               @OZ43706
         LR    R15,R14             R15 POINTS TO CRBRANCH.
         BALR  R14,R15             CALL VIRT STORAGE SUPERVISOR.
         USING *,R3                USE R3 AS LOCAL BASE.
         LR    R3,R14              SET R3 FROM R14 FOR BASE.
*
*              IF BUFFER GETMAIN, INITIALIZE THE
*              FOLLOWING FIELDS ---
*                  BFID   TO C'XBF '
*                  BFLENG TO CONTENTS OF R0
*                  BFTCB  TO CONTENTS OF R4
*                  BFASCB TO CONTENTS OF R7
*                  ALL OTHER FIELDS TO X'00'
*
         LTR   R15,R15             WAS CRBRANCH SUCCESSFUL...
         BNZ   HGFB30              BRANCH IF NOT.
         TM    0(R2),X'20'         WAS THIS A GETMAIN...
         BZ    HGFB30              BRANCH IF NOT.
         ST    R4,0(,R1)           RETURN TCB ADDRESS TO CALLER.
         STH   R0,4(,R1)           RETURN AREA LENGTH TO CALLER.     R4
         TM    0(R2),X'40'         WAS GETMAIN FOR BUFFER...
         BZ    HGFB30              BRANCH IF NOT.
         USING BFD,R1              USE THE BUFFER DSECT.
         XC    0(BFIO-BFD,R1),0(R1)  CLEAR BUFFER UP TO BFIO.
         MVC   BFID,=CL4'XBF'      SET BUFFER IDENTIFIER.
         STH   R0,BFLENG           SET BUFFER LENGTH.
         ST    R4,BFTCB            SET TCB ADDRESS IN BUFFER.
HGFB30   DS    0H                  CONTINUE.
*
*              TEST LOCAL LOCK CONDITION UPON ENTRY
*
         L     R0,=X'0F000000'     DID SETLOCK AT HGF010
         NR    R0,R2               RETURN NONZERO CODE...
         BNZ   HGF030              IF SO, DON'T RELEASE LOCAL LOCK.
*
*              SAVE REGISTERS PREPARATORY TO SETLOCK
*
         LR    R0,R11              SAVE REGISTER 11 IN REGISTER 0.
         LR    R4,R12              SAVE REGISTER 12 IN REGISTER 4.
         LR    R7,R13              SAVE REGISTER 13 IN REGISTER 7.
         LR    R3,R15              SAVE REGISTER 15 IN REGISTER 3.
*
*              RELEASE LOCAL LOCK
*
HGF020   SETLOCK RELEASE,TYPE=LOCAL,RELATED=HGF010
*
*              RESTORE REGISTERS AFTER SETLOCK
*
         LR    R11,R0              RESTORE REGISTER 11 FROM REGISTER 0.
         LR    R12,R4              RESTORE REGISTER 12 FROM REGISTER 4.
         LR    R13,R7              RESTORE REGISTER 13 FROM REGISTER 7.
         LR    R15,R3              RESTORE REGISTER 15 FROM REG 3.
*
*              RESTORE ORIGINAL PROTECT KEY
*
HGF030   DS    0H
         BALR  R3,0                RE-ESTABLISH                      R4
         USING *,R3                 LOCAL BASE                       R4
         LR    R4,R2               RESTORE CALLER'S LINK REGISTER.
         SRL   R2,24               SET KEY IN R2 BITS 24-27.
         MODESET KEYADDR=(2)       RESTORE ORIGINAL PROTECT KEY.
*
*              RETURN TO CALLER WITH CODE IN REGISTER 15
*
         TM    0(R4),X'80'         SET CC=3 IF LENGTH IN R0.
         LA    R4,4(,R4)           BUMP RETURN PAST R3 PARAMETER.
         BO    *+8                 SKIP IF NO ASSEMBLED LENGTH.
         LA    R4,4(,R4)           BUMP RETURN PAST R0 PARAMETER.
         LTR   R15,R15             SET CONDITION CODE
         BR    R4                  AND RETURN TO CALLER.
         DROP  R1,R3               DROP DSECT, BASE.
         SPACE 3
         LTORG
         TITLE 'HASP DIRECT ACCESS SPACE ALLOCATION ROUTINE'
         SPACE 2
***********************************************************************
*                                                                     *
*                                                                     *
* $STRAK - SSSM VERSION OF SPOOL SPACE ALLOCATION                     *
*                                                                     *
*                                                                     *
* FUNCTION ---                                                        *
*                                                                     *
*                                                                     *
*  (1)  IF CALL IS FOR INITIAL ALLOCATION, A TRACK GROUP (TG)         *
*       IS OBTAINED FROM THE TRACK GROUP BLOCK (TGB) MAINTAINED       *
*       BY THE JES-II CHECKPOINT PROCESSOR.                           *
*                                                                     *
*  (2)  IF CALL IS NOT FOR INITIAL ALLOCATION, AN ATTEMPT             *
*       IS MADE TO SUPPLY AN MTTR BASED ON THE TRACK CELL (TAB)       *
*       REFERENCED BY R1.  IF SUCCESSFUL, THE MTTR IS RETURNED        *
*       IN R1.  IF NOT, WE TRY TO OBTAIN A NEW TRACK CELL FROM        *
*       THE CURRENT TRACK GROUP.  IF THIS IS SUCCESSFUL, AN           *
*       MTTR IS RETURNED IN R1.  IF NOT, A SEARCH FOR A NEW TG        *
*       IS PERFORMED USING THE TGB.                                   *
*                                                                     *
*  (3)  IF THE TGB IS EMPTY, THE CALLER IS HELD IN ABEYANCE BY        *
*       ENQ/WAIT LOGIC. THE JES-II CHECKPOINT PROCESSOR IS            *
*       $$POSTED TO CAUSE A REFILLING OF THE TGB.                     *
*                                                                     *
*                                                                     *
* INPUT ---                                                           *
*                                                                     *
*  (1)  R1 CONTAINS THE ADDRESS OF A TRACK ALLOCATION BLOCK (TAB)     *
*                                                                     *
*  (2)  THE THIRD WORD OF THE TAB IS USED TO GET THE ADDRESS OF       *
*       THE ALLOCATION IOT, WHICH IN TURN ALLOWS US TO GET THE        *
*       ADDRESS OF THE TRACK GROUP MAP.  THE                          *
*       FIRST WORD CONTAINS AN MTTR OF THE LAST ALLOCATED             *
*       BUFFER FROM THE TRACK CELL ASSIGNED TO THE TAB.  THE          *
*       SECOND WORD CONTAINS A FLAG BYTE TO TELL WHAT KIND OF         *
*       TAB THIS IS,  THE SUB-PERMUTATION NUMBER ASSOCIATED WITH      *
*       THE CURRENT TRACK CELL, THE MAXIMUM NBR OF RECORDS THAT       *
*       WILL FIT ON A TRACK IN THE CURRENT TRACK CELL, AND THE        *
*       NBR OF BUFFERS LEFT IN THE TRACK CELL.  IF THE BUFFER         *
*       COUNT IS 0, AND THE LAST ALLOCATED BUFFER IS 0, THE CALL      *
*       IS FOR THE INITIAL ALLOCATION OF A BUFFER.                    *
*                                                                     *
*                                                                     *
* OUTPUT ---                                                          *
*                                                                     *
*  (1)  R1 CONTAINS AN UPDATED MTTR. THIS IS THE SAME VALUE AS        *
*        IS SET IN THE FIRST WORD OF THE INPUT TAB.                   *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
*
***********************************************************************
*                                                                     *
*        $STRAK --- GET A NEW MTTR FOR CALLER.                        *
*                                                                     *
***********************************************************************
*                                                                     *
         USING TGMDSECT,R4         TGM ADDRESSABILITY                R4
         USING TABDSECT,R10        TAB ADDRESSABILITY                R4
         USING SSVT,R11            PROVIDE SSVT ADDRESSABILITY       R4
         USING $STRAKWA,R13        SAVE AREA ADDRESSABILITY          R4
         SPACE 1                                                     R4
$STRAK   DS    0H
         SAVE  (14,12)             SAVE REGISTERS.
         BALR  R12,0               ESTABLISH
         USING *,R12               ADDRESSABILITY.
         LR    R10,R1              SETUP TABDSECT                    R4
         SLR   R14,R14             SETUP FOR MINOR TAB USE           R4
         TM    TABFLAG,TABMAJOR    TEST FOR MAJOR TAB                R4
         BZ    T1MINOR             BR IF MINOR -- GO USE MASTER      R4
         TM    TABFLAG,TABMASTR    IS THIS A MASTER TAB              R4
         BO    T1MASTR             YES - GET ADDR OF TGM             R4
         L     R4,TABAIOT          A(ALLOCATION IOT) FROM MAJOR TAB  R4
         LA    R4,IOTTGMAP-IOTDSECT(,R4)     A(TGM) FOR TGMDSECT     R4
         B     T1RETRY             GET READY FOR PROCESSING          R4
T1MINOR  NULL                                                        R4
         LR    R14,R10             SAVE A(MINOR TAB) FOR UPDATTING   R4
         L     R10,TABAIOT         A(ALLOCATION IOT)                 R4
         LA    R10,IOTMSTAB-IOTDSECT(,R10)   A(MASTER TAB)           R4
T1MASTR  NULL                                                        R4
         LR    R4,R10              A(MASTER TAB)                     R4
         LA    R4,IOTTGMAP-IOTMSTAB(,R4)     A(TGM) FOR TGMDSECT     R4
         EJECT                                                       R4
T1RETRY  DS    0H
         LM    R0,R1,TABMTTR       GET OLD VALUES                    R4
T1AGAIN  DS    0H
         LR    R2,R0               GET TABMTTR THAT WE WILL WORK ON  R4
         LR    R3,R1               GET TABSPN ETC. ETC.              R4
         ST    R3,$SKFLD15         SETUP WORK AREA WITH TABFLAG+     R4
*                                  TABSPN+TABMAXR+TABUFCNT           R4
         ICM   R6,1,$SBUFCNT       GET TABUFCNT AND SET CC           R4
         BZ    T1CELL              NO BUFFERS - NEED A NEW TRAKCELL  R4
         BCTR  R6,0                SUBTRACT 1 FOR BUFFER WE'LL USE   R4
         STC   R6,$SBUFCNT         MOVE BACK NEW TABUFCNT            R4
*
*              RECORDS ON A TRACK ARE ASSIGNED IN
*              A PERMUTED ORDER ---
*                  1,
*                  1+&RECINCR,
*                  1+&RECINCR*2,
*                  ....,
*                  2,
*                  2+&RECINCR,
*                  2+&RECINCR*2,
*                  ....,
*                  AND SO ON.
*              ATTEMPT TO ASSIGN THE NEXT RECORD OF A
*              SUB-PERMUTATION BY ADDING &RECINCR TO THE
*              CURRENT RECORD NUMBER.
*
         SLR   R15,R15             CLEAR WORK REG                    R4
         IC    R15,$SVRINCR        PICK UP &RECINCR                  R4
         ALR   R2,R15              ADD TO R OF TABMTTR               R4
         CLM   R2,1,$SBMAXR        COMPARE R OF TABMTTR TO TABMAXR   R4
         BNH   T1SKIP              NEW MTTR IS OK                    R4
*                                  WE'VE RUN OFF THE END OF THE TRACKR4
         IC    R2,$SBSPN           PICK UP TABSPN                    R4
         AL    R2,=F'1'            ADD 1 TO IT                       R4
         STC   R2,$SBSPN           MOVE BACK NEW TABSPN              R4
T1SKIP   NULL                                                        R4
         L     R3,$SKFLD15         GET UPDATTED TABUFCNT+TABSPN      R4
         CDS   R0,R2,TABMTTR       SEE IF TAB CHANGED UNDER US       R4
         BNE   T1AGAIN             YES - TRY AGAIN                   R4
         LTR   R14,R14             DID WE HAVE A MINOR TAB           R4
         BZ    T1EXIT              NO - RETURN                       R4
         ST    R2,0(,R14)          NEW VALUE OF TABMTTR              R4
         STCM  R3,7,5(R14)         NEW VALUE OF TABUFCNT, ETC.       R4
T1EXIT   NULL                                                        R4
         ST    R2,$SKFLD1          PUT TABMTTR IN R1 IN SAVE AREA    R4
         LM    R14,R12,12(R13)     RESTORE REGS                      R4
         SR    R15,R15             SET R15 = 0, CC = 0               R4
         BR    R14                 RETURN TO CALLER                  R4
         EJECT                                                       R4
T1CELL   NULL                                                        R4
         LM    R6,R7,TGMCYMXM      GET OLD VALUES                    R4
         LR    R8,R6               GET TGMCYMXM TO WORK ON           R4
         LTR   R9,R7               GET TGMCELL TO WORK ON            R4
         BZ    TBLOB               NO TRAKCELL - 1ST TIME THRU       R4
         ST    R8,$SKFLD15         PUT TGMCYMXM IN WORK AREA         R4
         CLM   R9,1,$SMMAXR        R OF TGMCELL GT MAX R OF TG       R4
         BH    T1TRACK             YES - NO MORE TRAKCELLS ON TRACK  R4
         SLR   R5,R5               SETUP R5 AS CTR FOR TABUFCNT      R4
         SLR   R15,R15             USE TO HOLD &RECINCR              R4
         IC    R15,$SVRINCR        GET &RECINCR                      R4
T1LOOP   NULL                                                        R4
         ALR   R9,R15              ADD &RECINCR TO TGMCELL TO GET    R4
*                                  MTTR OF NEXT BUFFER               R4
         LA    R5,1(,R5)           INCREASE BUFFER COUNT             R4
T1CHECK  NULL                                                        R4
         CLM   R9,1,$SMMAXR        R GONE PAST MAX R FOR THE TG      R4
         BNH   T1LOOPND            NO - SEE IF WE HAVE &TCELSIZ      R4
         CLM   R8,8,$SVRINCR       IS TGMSPN STILL VALID             R4
         BNL   T1CSTUNT            NO - IS TRAKCELL TOO SMALL        R4
         A     R8,=FS24'1'         ADD 1 TO TGMSPN                   R4
         ST    R8,$SKFLD15         PUT IN WORK AREA                  R4
         IC    R9,$SMSPN           REPLACE R IN TGMCELL BY TGMSPN    R4
         B     T1CHECK             MAKE SURE R STILL VALID           R4
T1LOOPND NULL                                                        R4
         CLM   R5,1,$SVTKCEL       DO WE HAVE A FULL TRAKCELL        R4
         BL    T1LOOP              NO - COUNT ANOTHER BUFFER         R4
T1CEND   NULL                                                        R4
         ST    R14,$SKFLD15        SAVE R14 BECAUSE OF NEXT BAL      R4
         ST    R8,$SKFLD1          SAVE R8 BECAUSE OF NEXT BAL       R4
         BAL   R8,TGETLCL          GET LOCAL LOCK                    R4
         CL    R2,TABMTTR          HAS TAB CHANGED                   R4
         BNE   T1CABORT            YES - TRY AGAIN                   R4
         CL    R6,TGMCYMXM         HAS TGM CHANGED                   R4
         BNE   T1CABORT            YES - TRY AGAIN                   R4
         CL    R7,TGMCELL          HAS TGM CHANGED                   R4
         BE    T1CFINSH            NO - FINISH UP ALLOCATION         R4
T1CABORT NULL                                                        R4
         BAL   R8,TFREELCL         FREE LOCAL LOCK                   R4
         L     R14,$SKFLD15        RESTORE R14                       R4
         B     T1RETRY             TRY IT AGAIN                      R4
T1CFINSH NULL                                                        R4
         MVC   TABMTTR,TGMCELL     MTTR OF 1ST BUFFER IN NEW TRKCEL  R4
         BCTR  R5,0                1ST BUF ALREADY ALLOCATED         R4
         STC   R5,TABUFCNT         MOVE BUFCNT INTO TABUFCNT         R4
         MVC   TABSPN,TGMCYMXM     MOVE IN NEW SUB-PERM NBR          R4
         MVC   TABMAXR,TGMCYMXM+3  MOVE IN MAX R                     R4
         MVC   TGMCYMXM(1),$SKFLD1  MOVE IN NEW SUB-PERM NBR         R4
         ST    R9,TGMCELL          MOVE IN NEW TRAKCELL ADDR         R4
         ICM   R14,15,$SKFLD15     IS THERE A MINOR TAB              R4
         BZ    SKIP430             NO - SKIP COPY                    R4
         MVC   0(4,R14),TABMTTR    COPY OVER DATA                    R4
         MVC   5(3,R14),TABSPN     COPY OVER DATA                    R4
SKIP430  L     R2,TABMTTR          GET MTTR OF ALLOCATED BUFFER      R4
         BAL   R8,TFREELCL         FREE LOCAL LOCK                   R4
         B     T1EXIT              PREPARE TO RETURN                 R4
T1CSTUNT NULL                                                        R4
         TM    TABFLAG,TABMASTR    IS THIS A MASTER TAB              R4
         BO    T1CEND              YES - STUNTED TRAKCELL OK         R4
*                                  NOTE THAT TAKING THIS BRANCH MAKESR4
*                                  R IN TGMCELL INVALID              R4
         LR    R15,R9              R15 = MTTR OF TGMCELL             R4
         SRL   R15,24              R15 = 000M                        R4
         MH    R15,=AL2(TEDSIZ)    R15 = M * TED SIZE                R4
         AL    R15,$SVTFRST        R15 = ADDR OF TED ELEMENT         R4
         CLM   R5,1,TTCM+1-TEDDSECT(R15) COMP BUFCNT & MIN CELL SIZE R4
         BNL   T1CEND              STUNTED TRAKCELL BIG ENOUGH       R4
*                                  NOTE THAT TAKING THE BRANCH MAKES R4
*                                  R IN TGMCELL INVALID              R4
         CDS   R6,R8,TGMCYMXM      SEE IF TGM CHANGED UNDER US       R4
         BNE   T1RETRY             YES - TRY AGAIN                   R4
*                                  NOTE THAT NOW THE STUNTED         R4
*                                  TRAKCELL CANNOT BE ALLOCATED      R4
         LR    R6,R8               RESET WITH                        R4
         LR    R7,R9                NEW VALUES                       R4
T1TRACK  NULL                                                        R4
         CLM   R9,6,$SMTT          TT OF TGMCELL WITH TT OF TGMC
         BNL   TBLOB               NO MORE TRACKS IN TRACK GROUP     R4
         AL    R9,=FS8'1'          ADD 1 TO TT OF TGMCELL            R4
         IC    R9,=X'01'           MAKE R OF TGMCELL 1               R4
         ICM   R8,8,=X'01'         SET SUP-PERM BACK TO 1            R4
         CDS   R6,R8,TGMCYMXM      TGM CHANGED UNDER US              R4
         BNE   T1RETRY             YES - TRY AGAIN                   R4
         B     T1CELL              NO - ALLOCATE A NEW TRAKCELL      R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*              GET LOCAL LOCK TO PREVENT SIMULT ALLOC                 *
*                                                                     *
***********************************************************************
         SPACE 1
TBLOB    NULL                                                        R4
         LR    R2,R0               SAVE ORIGINAL TABMTTR             R4
         ST    R14,$SKFLD1         SAVE BECAUSE OF NEXT BAL          R4
         BAL   R8,TGETLCL          GET LOCAL LOCK                    R4
         CL    R2,TABMTTR          HAS TAB CHANGED                   R4
         BNE   TBLOBOUT            YES - TRY AGAIN                   R4
         CL    R6,TGMCYMXM         HAS TGM CHANGED                   R4
         BNE   TBLOBOUT            YES - TRY AGAIN                   R4
         CL    R7,TGMCELL          HAS TGM CHANGED                   R4
         BE    TBLOBA              NO - GET A NEW TG                 R4
TBLOBOUT NULL                                                        R4
         BAL   R8,TFREELCL         FREE LOCAL LOCK                   R4
         L     R14,$SKFLD1         RESTORE R14                       R4
         B     T1RETRY             TRY IT AGAIN                      R4
         SPACE 1
***********************************************************************
*                                                                     *
*              ALLOCATE MTTR FROM TGB                                 *
*                                                                     *
***********************************************************************
         SPACE 1
TBLOBA   SLR   R2,R2               R2 = 0 (FOR CDS)
         SLR   R3,R3               R3 = 0 (FOR CDS)
         SL    R4,=A(IOTTGMAP-IOTDSECT)       FLAG                   R4
         OI    IOTFLAG1-IOTDSECT(R4),IOT1CKPT  IOT                   R4
         LA    R4,IOTTGMAP-IOTDSECT(,R4)        FOR CKPT             R4
TBLOBB   LM    R5,R7,$SVTTGBA      R5=1ST, R4=SIZE,R6=LAST TGB
         USING TGBDSECT,R5         TGB ADDRESSABILITY
TBLOBC   LM    R0,R1,TGBENTRY      FETCH TGB ENTRY
         LTR   R1,R1               TEST FOR AVAILABLE TGB ENTRY
         BZ    TBLOBD              BRANCH IF NOT AVAILABLE
         CDS   R0,R2,TGBENTRY      TRY TO ALLOCATE ENTRY
         BNE   TBLOBB              BRANCH IF TGB REPLENISHED
         DROP  R5                  FORGET TGB
         SPACE 1
***********************************************************************
*                                                                     *
*              TGB ALLOCATED. ESTABLISH TED ADDR                      *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R2,R1               R2 = MTTR
         SRL   R2,24               R2 = 000M
         MH    R2,=AL2(TEDSIZ)     R2 = M * TED SIZE
         AL    R2,$SVTFRST         R2 = ADDRESS OF TED
         USING TEDDSECT,R2         TED ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
*              SHOW TRACK GROUP ALLOCATION IN USERS MAP               *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R3,R0               R3 = OFFSET & BIT MASK
         SRL   R3,16               R3 = OFFSET TO ALLOCATION BYTE
         IC    R8,TGMAP(R3)        R8 = MAP BYTE
         OR    R8,R0               SHOW ALLOCATION
         STC   R8,TGMAP(R3)         FOR THIS TRACK GROUP
         SPACE 1
***********************************************************************
*                                                                     *
*              DEVELOP NEW PTTR FROM MTTR & TED                       *
*                                                                     *
***********************************************************************
         SPACE 1
         LR    R0,R1               R0 = NEW MTTR
         SRL   R0,8                R0 = 0MTT
         AH    R0,TNTG             R0 = MAX TT + 1
         BCTR  R0,0                R0 = MAX TT
         SLL   R0,8                R0 = MAX TT0
         AH    R0,TNRT             R0 = MAX TTR
         ICM   R0,8,=X'01'         R0 = PTTR
         DROP  R2                  FORGET THE TED
         SPACE 1
***********************************************************************
*                                                                     *
*              STORE NEW PTTR (MAX) & MTTR IN TGM                     *
*                                                                     *
***********************************************************************
         SPACE 1
         LM    R6,R7,TGMCYMXM      GET CURRENT VALUES                R4
         CDS   R6,R0,TGMCYMXM      MOVE IN NEW VALUES                R4
         LM    R0,R1,TABMTTR       GET CURRENT VALUES                R4
         LM    R2,R3,TABMTTR       GET CURRENT VALUES                R4
         BAL   R8,TFREELCL         FREE LOCAL LOCK                   R4
         L     R14,$SKFLD1         RESTORE R14                       R4
         B     T1CELL              ALLOCATE A NEW TRAKCELL           R4
         SPACE 1
***********************************************************************
*                                                                     *
*              PLOW THRU TGB. IF NO ENTRY, WAIT FOR JES-2             *
*                                                                     *
***********************************************************************
         SPACE 1
TBLOBD   BXLE  R5,R6,TBLOBC        SEARCH TGB
         BAL   R8,TFREELCL         RELEASE LOCAL LOCK
         L     R3,$SKFLD1          LOAD SAVED R14 INTO R3           R41
         MVC   $SKFLD15(12),TENQLIST    SET LIST FORM ENQ            R4
         ENQ   ($SVQNAM),MF=(E,$SKFLD15)                             R4
         $$POST TYPE=CKPW          TELL JES-2
         NI    $SVTGECB,X'7F'      RESET WAIT BIT
         MVC   $SVTGASC+1(3),PSAAOLD+1-PSA SET ASCB
         WAIT  1,ECB=$SVTGECB      WAIT FOR CKPT PROCESS
         MVI   $SVTGECB,0          CLEAR ECB
         MVC   $SKFLD15(12),TDEQLIST    SET LIST FORM DEQ            R4
         DEQ   ($SVQNAM),MF=(E,$SKFLD15)                             R4
         BAL   R8,TGETLCL          GET LOCAL LOCK
         LR    R14,R3              RESTORE R14                      R41
         ST    R14,$SKFLD1         SAVE AGAIN IN $SKFLD1            R41
         B     TBLOBA              GO ALLOCATE FROM TGB
         SPACE 1
TENQLIST ENQ   (,T2MINOR,E,L'T2MINOR,SYSTEM),RET=HAVE,MF=L
TDEQLIST DEQ   (,T2MINOR,L'T2MINOR,SYSTEM),MF=L
T2MINOR  DC    C'AWAITING SPOOL SPACE'
         SPACE 2                                                     R4
         DROP  R4,R10,R13          DROP TGMDSECT, TABDSECT, $STRAKWA R4
         SPACE 1                                                     R4
$STRAKWA DSECT                     USE OS SAVE AREA AS A WORK AREA   R4
         DS    CL16                FIRST 4 WORDS                     R4
$SKFLD15 DS    CL4                 R15 SAVE AREA                     R4
         ORG   $SKFLD15            REDEFINE                          R4
$SBFLAG  DS    CL1                 TABFLAG                           R4
$SBSPN   DS    CL1                 TABSPN                            R4
$SBMAXR  DS    CL1                 TABMAXR                           R4
$SBUFCNT DS    CL1                 TABUFCNT                          R4
         ORG   $SKFLD15            REDEFINE                          R4
$SMSPN   DS    CL1                 TGMCYMXM                          R4
$SMTT    DS    CL2                   .  .                            R4
$SMMAXR  DS    CL1                   .  .                            R4
$SKFLD0  DS    CL4                 R0 SAVE AREA                      R4
$SKFLD1  DS    CL4                 R1 SAVE AREA                      R4
HASPSSSM CSECT                                                       R4
         TITLE 'SETLOCK SUBROUTINES'
*
*              SUBROUTINE TO GET LOCAL LOCK
*
TGETLCL  SETLOCK OBTAIN,TYPE=LOCAL,MODE=UNCOND,REGS=USE,               C
               RELATED=($SVTGMAP,HASPSSSM(TFREELCL))
         BR    R8                  RETURN.
                                   PRINT OFF - SECTION DELETED @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
*                                  THIS CARD DELETED BY APAR   @OZ35278
                                   PRINT ON -- SECTION DELETED @OZ35278
*
*              SUBROUTINE TO FREE LOCAL LOCK
*
TFREELCL SETLOCK RELEASE,TYPE=LOCAL,REGS=USE,                          C
               RELATED=($SVTGMAP,HASPSSSM(TGETLCL))
         BR    R8                  RETURN.
         DROP  ,                   DROP ALL ADDRESSABILITY.
         LTORG                     LITERAL POOL
         DS    0D                  DOUBLEWORD BOUNDARY FOR PATCH.
SSMPATCH DC    CL256'PATCH SPACE',CL256' '  PATCH AREA.
$DLENGTH $DLENGTH                  COMPUTE CONTROL SECTION LENGTH
APARNUM  DC    CL5'81035'          APAR NUMBER
         END
