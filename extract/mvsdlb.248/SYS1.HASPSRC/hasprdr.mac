RDR      TITLE 'HASP INPUT SERVICE PROLOG'                     @OZ18212
***********************************************************************
*                                                                     *
* MODULE NAME = HASJES20 ( HASPRDR CSECT )                            *
*                                                                     *
* DESCRIPTIVE NAME = HASPRDR CSECT OF JES2 MAIN MODULE                *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 MVS   --  SEE &VERSION (BELOW) FOR JES2 LEVEL       *
*                                                                     *
* FUNCTION = THE HASPRDR CSECT PROVIDES INPUT SERVICE TO THE JES2     *
*            SUBSYSTEM.  THE FUNCTIONS OF THIS MODULE ARE AS          *
*            FOLLOWS --                                               *
*                                                                     *
*              1.  TO READ CARD IMAGES FROM AN INPUT DEVICE.          *
*                                                                     *
*              2.  TO DETECT AND SCAN JOB CARDS, EXTRACTING PARAM-    *
*                  ETERS FOR JOB ACCOUNTING, JOB CONTROL, AND PRINT   *
*                  AND PUNCH IDENTIFICATION.                          *
*                                                                     *
*              3.  TO DETECT AND PROCESS OTHER CONTROL CARDS, SUCH AS *
*                  THE COMMAND, PRIORITY, ROUTE, SETUP, MESSAGE,      *
*                  JOBPARM, OUTPUT, DD *, AND DD DATA CARDS.          *
*                                                                     *
*              4.  TO ASSIGN A UNIQUE JOB IDENTIFIER (JOBID) TO EACH  *
*                  JOB.                                               *
*                                                                     *
*              5.  TO LOG JOBS INTO THE JES2 SYSTEM.                  *
*                                                                     *
*              6.  TO ASSIGN JOB PRIORITY BASED UPON PRIORITY CARD,   *
*                  JOB CARD, OR JOBPARM CARD PARAMETERS.              *
*                                                                     *
*              7.  TO GENERATE, FROM CARDS READ, A JCL FILE AND INPUT *
*                  DATA FILES, AND TO RECORD THESE FILES ON DIRECT-   *
*                  ACCESS STORAGE DEVICE(S) FOR LATER USE BY THE JOB  *
*                  EXECUTION STAGES (SPOOLING FUNCTION).              *
*                                                                     *
*              8.  TO GENERATE JES2 JOB CONTROL TABLES, INPUT/OUTPUT  *
*                  TABLES, JOB QUEUE ENTRIES, AND OTHER JES2 CONTROL  *
*                  BLOCKS REQUIRED FOR LATER JOB PROCESSING.          *
*                                                                     *
*              9.  TO QUEUE JOBS FOR PROCESSING BY THE JCL CONVERSION *
*                  PROCESSOR.                                         *
*                                                                     *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*    DEPENDENCIES = NONE                                              *
*                                                                     *
*    RESTRICTIONS = NONE                                              *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*    REGISTER CONVENTIONS = R0          = WORK REGISTER               *
*                           R1          = WORK REGISTER               *
*                           R2  = RW    = WORK REGISTER               *
*                           R3  = RBI   = ADDRESS OF INPUT BUFFER     *
*                           R4  = RPI   = ADDR OF NEXT INPUT CARD     *
*                           R5  = RL1   = INTERNAL LINK REGISTER      *
*                           R6  = RL2   = INTERNAL LINK REGISTER      *
*                           R7  = RBASE2= PROCESSOR SECONDARY BASE    *
*                           R8  = BASE3 = SECONDARY BASE REGISTER     *
*                           R9          = UNUSED                      *
*                           R10 = JCT   = ADDRESS OF JES2 JCT         *
*                           R11 = BASE1 = ADDRESS OF HCT              *
*                           R12 = BASE2 = PROCESSOR ADDRESSABILITY    *
*                           R13 = SAVE  = ADDRESS OF INPUT PCE        *
*                           R14 = LINK  = LINK REGISTER               *
*                           R15         = WORK REGISTER               *
*                                                                     *
*    PATCH LABEL = NONE                                               *
*                                                                     *
* MODULE TYPE = PROCESSOR, TABLE ( CSECT TYPE )                       *
*                                                                     *
*    PROCESSOR = ASSEMBLER F                                          *
*                                                                     *
*    MODULE SIZE = SEE $DLENGTH MACRO EXPANSION(S) AT END OF ASSEMBLY *
*                                                                     *
*    ATTRIBUTES = READ ONLY (AFTER PROCESSOR INITIALIZATION) AND      *
*                 HASP REENTRANT                                      *
*                                                                     *
* ENTRY POINTS = $READ    -- PRIMARY PROCESSOR ENTRY POINT            *
*                HASPRJCS -- JOB CONTROL INFORMATION INITIALIZATION   *
*                HASPRSCN -- JOB CARD ACCOUNTING FIELD SCAN           *
*                                                                     *
*    PURPOSE = SEE FUNCTION                                           *
*                                                                     *
*    LINKAGE = STANDARD JES2 PROCESSOR LINKAGE CONVENTIONS            *
*                                                                     *
* INPUT = R0-R10 = ZERO                                               *
*         R11    = ADDRESS OF HCT                                     *
*         R12    = PROCESSOR ADDRESSABILITY                           *
*         R13    = ADDRESS OF INPUT PCE                               *
*         R14    = ZERO                                               *
*         R15    = ADDRESS OF ENTRY POINT                             *
*                                                                     *
* OUTPUT = SEE REGISTER CONVENTIONS                                   *
*                                                                     *
* EXIT-NORMAL = TO JES2 DISPATCHER ($WAIT)                            *
*                                                                     *
* EXIT-ERROR = NONE                                                   *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
* EXTERNAL REFERENCES = SEE BELOW                                     *
*                                                                     *
*    ROUTINES = TIME ROUTINE (SVC 11)                                 *
*               POST ROUTINE (SVC 2)                                  *
*               MISCELLANEOUS JES2 SERVICE ROUTINES IN HASPNUC        *
*                                                                     *
*    DATA AREAS -- COMMUNICATIONS VECTOR TABLE (CVT)                  *
*                  SYSTEM MANAGEMENT CONTROL AREA (SMCA)              *
*                                                                     *
*    CONTROL BLOCKS = MISCELLANEOUS JES2 CONTROL BLOCKS (SEE MACROS)  *
*                                                                     *
* TABLES = RSCANTBL -- CONTROL CARD SCAN TABLE                        *
*                                                                     *
* MACROS = SEE $HASPCB MACRO FOR CONTROL BLOCK MACROS USED            *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*     RELEASE 4.0 = OZ03304,OZ04322,OZ04973,OZ04981,OZ06724,OZ06748,  *
*                   OZ08209,OZ09031,OZ09041                           *
*                                                                     *
*     RELEASE 4.1 = OZ10325,OZ10356,OZ11741,OZ11742,OZ14246,OZ15289,  *
*                   OZ15825                                           *
*                                                                     *
***********************************************************************
         TITLE 'HASP CONTROL BLOCK GENERATION MACRO'
         SPACE 5
*
***** $HASPCB  *****          GENERATE HASP CONTROL BLOCKS
*
*
         MACRO
         $HASPCB &DOC=NO,&LIST=NO
         GBLC  &PRINT,&GEN,&DATA
         PUSH  PRINT
         PRINT &PRINT
         $CVT  LIST=&LIST          GENERATE OS CVT DSECT
         $DCB  LIST=&LIST          GENERATE OS DCB DSECT
         $DEB  LIST=&LIST          GENERATE OS DEB DSECT
         $UCB  LIST=&LIST          GENERATE OS UCB DSECT
         $TGM  DOC=&DOC            GENERATE HASP TGM DSECT
         $TAB  DOC=&DOC            GENERATE HASP TAB DSECT           R4
         $SVT  DOC=&DOC            GENERATE HASP SSVT DSECT
         $HCT  DOC=&DOC            GENERATE HASP HCT DSECT
         $PCE  DOC=&DOC            GENERATE HASP PCE DSECT
         $LRC  DOC=&DOC            GENERATE HASP LRC DSECT
         $SCR  DOC=&DOC            GENERATE HASP SCR DSECT           R4
         $BUFFER DOC=&DOC          GENERATE HASP BUFFER DSECT
         $CMB  DOC=&DOC            GENERATE HASP CMB DSECT
         $JQE  DOC=&DOC            GENERATE HASP JQE DSECT
         $QSE  DOC=&DOC            GENERATE HASP QSE DSECT
         $JCT  DOC=&DOC            GENERATE HASP JCT DSECT
         $PDDB DOC=&DOC            GENERATE HASP PDDB DSECT
         $IOT  DOC=&DOC            GENERATE HASP IOT DSECT
         $CAT  DOC=&DOC            GENERATE HASP CAT DSECT
         $OCR  DOC=&DOC            GENERATE HASP OCR DSECT
         $OCT  DOC=&DOC            GENERATE HASP OCT DSECT
         $SCAT DOC=&DOC            GENERATE HASP SCAT DSECT
         $RAT  DOC=&DOC            GENERATE HASP RAT DSECT
         $DCT  DOC=&DOC            GENERATE HASP DCT DSECT
         $RDRWORK DOC=&DOC         GENERATE INPUT PCE WORK AREA DSECT
         SPACE 3
         POP   PRINT
         PRINT &GEN,&DATA          SET ASSEMBLY PRINT OPTIONS
         MEND
         TITLE 'HASP INPUT SERVICE PROCESSOR'
         SPACE 5
HASPRDR  START 0                   HASP INPUT PROCESSOR
         SPACE 5
*
*                             EXTERNAL REFERENCES
*
         SPACE 3
         ENTRY $RDREND             END OF HASPRDR CSECT
         ENTRY $RDROEND            END OF HASPRDRO CSECT
         SPACE 5
         COPY  $HASPGEN            COPY HASPGEN PARAMETERS
         TITLE 'HASP CONTROL BLOCKS'
HASPRDR  $ENTRY CSECT=YES,BASE=(BASE2,RBASE2)  DEFINE ENTRY POINT    R4
         SPACE 5
*
*                             DOCUMENTATION OPTIONS FOR THIS ASSEMBLY
*
         SPACE 3
        $SYSPARM (OFF,GEN,NODATA,NO,NO)
         SPACE 5
*
*                             GENERATE HASP CONTROL BLOCKS
*
         SPACE 3
        $HASPCB DOC=&DOC,LIST=&LIST  GENERATE HASP CONTROL BLOCKS
         TITLE 'HASP INPUT SERVICE -- CONTROL CARD SCAN TABLE DSECT'
         SPACE 5
RSCANTBL DSECT                     CONTROL CARD SCAN TABLE DSECT
RSCANAME DS    CL7                 KEYWORD NAME (7 CHARACTERS MAX)
RSCANABR DS    C                   KEYWORD ABREVIATION (1 CHARACTER)
RSCANFLG DS    X                   KEYWORD VALUE FLAGS
RSCFLCOM EQU   B'10000000'              MASK IS COMPLEMENTED
RSCFLNUM EQU   B'10000000'              VALUE MUST BE NUMERIC
RSCFLBIN EQU   B'01000000'              CONVERT VALUE TO BINARY
RSCFLEFT EQU   B'00100000'              LEFT ADJUST VALUE
RSCFLBLK EQU   B'00010000'              BLANK-FILL VALUE
RSCFLPCT EQU   B'00001111'              MAXIMUM NUMBER OF VALUES
RSCANMSK DS    0X                  KEYWORD MASK
RSCANLEN DS    AL1                 KEYWORD VALUE LENGTH
RSCANDSP DS    AL2                 KEYWORD VALUE DISPLACEMENT
RSCANEXT DS    0F                  ADDRESS OF NEXT TABLE ENTRY
HASPRDR  CSECT                     END OF CONTROL CARD SCAN DSECT
         TITLE 'HASP INPUT SERVICE PROCESSOR'
*
*                             READER REGISTER DEFINITIONS
*
         SPACE 3
RW       EQU   WA                  WORK REGISTER
RBI      EQU   WB                  INPUT BUFFER
RPI      EQU   WC                  INPUT POINTER                     R4
RL1      EQU   WD                  INTERNAL LINK REGISTER 1          R4
RL2      EQU   WE                  INTERNAL LINK REGISTER 2          R4
RBASE2   EQU   WF                  INPUT SERVICE BASE REGISTER       R4
         SPACE 4
*
*                             READER BUFFER DEFINITIONS
*
         SPACE 3
RBUFTRK  EQU   HDBNXTRK-BUFDSECT   BUFFER CHAIN TRACK DISPLACEMENT
*                                  INPUT BUFFER START DISPLACEMENT
ROBUFST  EQU   HDBSTART-BUFDSECT   OUTPUT BUFFER START DISPLACEMENT
         SPACE 4
*
*                             MISCELLANEOUS DEFINITIONS
*
         SPACE 3
*                               RDRSW                                R4
RJFLUSH  EQU   X'01'               JOB FLUSH SWITCH
RNOSCAN  EQU   X'02'               NO CARD SCAN SWITCH
RDREOFSW EQU   X'04'               END-OF-FILE SWITCH
RJCLSW   EQU   X'08'               JOB CONTROL LANGUAGE SWITCH
RSYSINSW EQU   X'10'               GENERATED DD * PROCESSING SWITCH
RXBJOBSW EQU   X'20'               XEQ BATCH CLASS JOB SWITCH
RJNABORT EQU   X'40'               READER PURGE SWITCH              R41
RJKILL   EQU   X'80'               JOB KILLED VIA RJOBKILL     @OZ19495
RUNIEXCP EQU   X'01'               UNIT EXCEPTION BIT
*                               RDRSW2                               R4
RJCLH    EQU   X'01'               TYPRUN=JCLHOLD                    R4
RTPCPY   EQU   X'08'               TYPRUN=COPY FLAG.           @OZ48524
RCONTEOF EQU   X'20'               READER END-OF-FILE          @OZ73741
RCONTILL EQU   X'40'               ILLEGAL CONTINUATION        @OZ73741
*                                                                    R4
RSIOCSWS EQU   X'10'               SIO CSW STORED BIT
RSIOCC   EQU   X'30'               SIO COMPLETION CODE BITS
RDLMSKIP EQU   LRC1RSV7            DLM TEST BYPASS SWITCH            R4
         TITLE 'HASP INPUT SERVICE -- PROCESSOR INITIALIZATION'
         SPACE 5                                                     R4
         LA    RBASE2,2048(,BASE2)  SET UP                           R4
         LA    RBASE2,2048(,RBASE2)  SECOND BASE REGISTER            R4
         L     R1,=A(RCOMCHAR)     INITIALIZE COMMAND CHARACTER      R4
         MVC   0(1,R1),$RCOMCHR     IN CONTROL CARD ROUTING TABLE    R4
         SPACE 5                                                     R4
         USING BUFDSECT,RBI        ESTABLISH IOB ADDRESSABILITY
$READ   $LINK  HASPRDRI            LINK TO INITIALIZATION MODULE     R4
         EJECT
HASPRDRO CSECT                     DEFINE SUBROUTINE CSECT
HASPRDRI $ENTRY                    DEFINE INITIALIZATION SEGMENT
         L     RL1,PCEDCT          GET ADDRESS OF INPUT DCT    @OZ32566
         USING DCTDSECT,RL1        ESTABLISH DCT ADDRESSABILITY      R4
         SPACE 3
RGETUNIT NULL                      *                                 R4
        $GETUNIT (RL1)             ATTEMPT TO ACQUIRE INPUT DCT      R4
         BNZ   RGOTUNIT            BRANCH IF DEVICE IS AVAILABLE     R4
         SPACE 2                                                     R4
         TM    PCEID,PCERJEID      TEST DEVICE TYPE                  R4
         BO    RJEWAIT             BRANCH IF REMOTE DEVICE           R4
         TM    PCEID,PCEINRID      IS THIS INT RDR...          @OZ37382
         BZ    RGETUN1             BR IF NOT                   @OZ37382
         TM    RIDFLAGS,RIDEOM     IS EOM IN PROGRESS...       @OZ37382
         BZ    RGETUN1             BR IF NOT                   @OZ37382
         NI    RIDFLAGS,255-RIDEOM RESET FLAG BIT              @OZ37382
         MVC   RIDPBFO,$ZEROS      NULLIFY RESIDUAL DATA       @OZ72122
         $XMPOST RIDEOMP             AND POST WAITING TASK     @OZ37382
RGETUN1  DS    0H                                              @OZ37382
        $WAIT  UNIT,INHIBIT=NO     NO, WAIT FOR UNIT RECORD DEVICE   R4
         B     RGETUNIT            GO TRY AGAIN                      R4
         SPACE 3                                                     R4
RJEWAIT $WAIT  WORK                $WAIT FOR RJE DEVICE              R4
         B     RGETUNIT            GO TRY AGAIN                      R4
         EJECT                                                       R4
RGOTUNIT NI    DCTFLAGS,DCTHOLDJ   RESET OPERATOR COMMANDS           R4
        $ACTIVE                    INDICATE PROCESSOR ACTIVE
         TM    PCEID,PCEINRID      IS THIS INTERNAL READER
         BZ    RNOTINR1            BRANCH IF NOT INTERNAL READER     R4
         ICM   RBI,15,RIDPBF       GET ADDRESS OF PROTECTED BUFFER
         BNZ   RINRSTRT            BRANCH IF BUFFER IS RESIDUAL
         GETMAIN RC,SP=231,LV=RIDBUFSZ+256  GET STORAGE FOR BUFFERS
         LTR   R15,R15             TEST SUCCESS OF GETMAIN
         BNZ   RRETURN             BRANCH IF GETMAIN WAS NOT SUCCESSFUL
         LR    RBI,R1              RBI = ADDRESS OF PROTECTED BUFFER
         ST    RBI,RIDPBF          SAVE ADDRESS
RINRSTRT LA    RPI,RIDBUFSZ(,RBI)  GET ADDRESS OF WORK AREA
         B     RRETURN             CONTINUE PROCESSING
         SPACE 1                                                     R4
RNOTINR1 NULL                      *                                 R4
         TM    PCEID,PCERJEID      IS THIS A REMOTE TERMINAL         R4
         BZ    RINBGET             BRANCH IF NOT                     R4
         SPACE 1                                                     R4
ROPEN    OI    DCTSTAT,DCTHOLD     SET DEVICE UNAVAILABLE            R4
        $EXTP  OPEN,(RL1)          OPEN REMOTE TERMINAL FOR INPUT
         LA    RPI,RTPCARD         INITIALIZE ADDRESS OF CARD IMAGE  R4
         B     RRETURN             CONTINUE PROCESSING               R4
         SPACE 1                                                     R4
RINBGET $GETBUF WAIT=YES           GET INPUT BUFFER                  R4
         EJECT                                                       R4
         LR    RBI,R1              RBI = ADDRESS OF INPUT BUFFER     R4
         LA    RW,BUFSTART         RW = START OF CCW CHAIN
         ST    RW,IOBSTART         SET IOBSTART IN INPUT BUFFER
         ST    RBI,DCTBUFAD        SET INPUT BUFFER
         SLR   R0,R0               OBTAIN                            R4
         LH    R1,$BUFSIZE          COUNT                            R4
         D     R0,RF88               OF CCW'S                        R4
         LR    RL2,R1                 PER BUFFER                     R4
         BCTR  RL2,0                   (MINUS 1)                     R4
         SLL   R1,3                      SET UP                      R4
         LA    R0,BUFSTART-BUFDSECT(,R1)  READER                     R4
         ST    R0,RIBUFST                  CCW                       R4
         AL    R0,RDRCCW                    IN R0                    R4
         L     R1,RDRCCW+4                   AND R1                  R4
         L     R15,DCTDCB          R15 = DCB ADDRESS
         L     R15,DCBDEBAD-DCBDSECT(,R15)   R15 = DEB ADDRESS
         L     R15,DEBSUCBA-DEBDSECT(,R15)   R15 = UCB ADDRESS
         CLI   UCBTBYT4-UCBDSECT(R15),UCB2540R  TEST DEVICE TYPE     R4
         BE    SKIP10              SET STACKER 2 IF 2540 READER      R4
         ICM   R0,8,RDRCCW1        SET STACKER 1 IF NOT 2540 READER  R4
SKIP10   ALR   R0,RBI              SET BUFFER ADDRESS IN CCW
         DROP  RL1                 DROP DCT ADDRESSABILITY
         SPACE 1                                                     R4
RCCWBLD  STM   R0,R1,0(RW)         STORE CCW
         LA    RW,8(,RW)           UPDATE CCW LIST ADDRESS
         AL    R0,=F'80'           UPDATE CCW DATA ADDRESS
         BCT   RL2,RCCWBLD         GENERATE CCW CHAIN
         LA    R1,0(,R1)           CLEAR COMMAND CHAIN BIT
         STM   R0,R1,0(RW)         STORE LAST CCW
         ST    JCT,RBIEND          INITIALIZE BUFFER END
         SPACE 2                                                     R4
RRETURN  ST    JCT,PCEIOEWF        INITIALIZE DIRECT-ACCESS DCT
         MVI   RDRSW,RJFLUSH       SET FOR JOB FLUSH
         MVC   RPRIORTY,=CL2' '    SET STANDARD PRIORITY             R4
         MVC   RDRDLM,=CL2'/*'     SET INPUT DATA SET DELIMITER
RDRIRET $RETURN                    RETURN TO MAIN PROCESSOR          R4
         SPACE 3                                                     R4
*
*                             INITIALIZATION CONSTANTS
*
         SPACE 2                                                     R4
RF88     DC    F'88'               CONSTANT                          R4
RDRCCW   DC    0F'0',X'42',AL3(*-*),X'40',AL3(80)  2540 READ CCW     R4
RDRCCW1  DC    X'02'               NON-2540 READ CCW OPERATION       R4
         SPACE 2                                                     R4
         DROP  BASE3               DROP SEGMENT ADDRESSABILITY
         TITLE 'HASP INPUT SERVICE -- MAIN PROCESSOR'
HASPRDR  CSECT                     DEFINE MAIN PROCESSOR RESIDENT
RCRDOUT  BAL   RL1,RPUT            PUT CARD IN OUTPUT BUFFER
RNXTCRD  BAL   RL1,RGET            GET NEXT CARD
         B     RDREND              BRANCH IF EOF
RSCNCONT TM    RDRSW,RNOSCAN       TEST FOR CARD SCAN          @OZ73741
         BO    RDATAC              BRANCH IF NOT.              @OZ48524
         TM    RDRSW,RJCLSW+RXBJOBSW    TEST CURRENT MODE
         BZ    RDATAC              BRANCH IF DATA CARD.        @OZ48524
         MVC   RDRDLM,=CL2'/*'     SET INPUT DATA SET DELIMITER
RDATAC   DS    0H                                              @OZ48524
         CLC   0(2,RPI),RDRDLM     TEST FOR DELIMITER CARD
         BNE   RSCANCHK            BRANCH IF NOT DELIMITER CARD
         NI    RDRSW,255-RNOSCAN   TURN ON CARD SCAN
         CLC   0(2,RPI),=CL2'/*'   TEST FOR HASP CONTROL CARD
         BNE   RNOTCCRD            BR IF NOT HASP CONTROL CARD
         CLI   2(RPI),C' '         TEST FOR HASP CONTROL CARD
         BE    RNOTCCRD            BRANCH IF NOT HASP CONTROL CARD
        $LINK  HASPRCCS            SCAN HASP CONTROL CARD
         BR    RL2                 UPON RETURN RL2 SPECIFIES EXIT
         SPACE 3                                                     R4
RNOTCCRD TM    RDRSW,RXBJOBSW      TEST STATUS
         BO    RCRDOUT             BRANCH IF EXECUTION BATCHING
         TM    RDRSW2,RTPCPY       IF TYPRUN=COPY, BYPASS      @OZ53356
         BO    RCRDOUT              SETTING NULL FLAG          @OZ53356
         OI    RCARDLRC,RDLMSKIP   DON'T COUNT DELIMITER       @OZ53442
         TM    RDRSW,RJCLSW        TEST JCL SWITCH             @OZ53442
         BO    RCRDOUT             BYPASS FURTHER PROC IF SET  @OZ53442
         OI    RCARDLRC,LRC1INUL   ELSE SET NULL-ON-INPUT AND  @OZ53442
         BAL   RL1,RPUT               ADD CARD TO OUTPUT FILE  @OZ53442
         OI    RDRSW,RJCLSW        SET JCL SWITCH
         B     RFLTEST             TERMINATE DATA SET
         SPACE 3                                                     R4
RPRIREAD BAL   RL1,RGET            GET NEXT CARD
         B     RDREND              BRANCH IF END OF FILE
         SPACE 3                                                     R4
RSCANCHK TM    RDRSW,RNOSCAN       TEST FOR CARD SCAN
         BO    RFLTEST             BRANCH IF NO SCAN
         CLC   0(2,RPI),=CL3'//'   TEST COLUMNS 1 AND 2
         BE    RJCLCARD            BRANCH IF '//' CARD
         TM    RDRSW,RJCLSW+RXBJOBSW    TEST CURRENT MODE
         BNM   RFLTEST             PROCESS CARD IF DATA OR BATCH
         TM    RDRSW2,RTPCPY       TEST TYPRUN=COPY FLAG.      @OZ48524
         BO    RFLTEST             BRANCH IF ON.               @OZ48524
         OI    RDRSW,RSYSINSW      INDICATE GENERATED DD *
         ST    RPI,RSAVE1          SAVE ADDRESS OF CURRENT CARD
         LA    RPI,RSYSINCD        GET ADDRESS OF HASP SUPPLIED DD *
         EJECT                                                       R4
RJCLCARD TM    RDRSW,RJCLSW        TEST JCL SWITCH
         BO    RJCLSCAN            START SCAN IF SET
         ST    RPI,RSAVE1          SAVE INPUT POINTER
         LA    RPI,RDRDLM          ADD DELIMITER CARD
         BAL   RL1,RPUT             TO OUTPUT FILE
         L     RPI,RSAVE1          RESTORE INPUT POINTER
         MVC   RDRDLM,=CL2'/*'     SET INPUT DATA SET DELIMITER
         OI    RDRSW,RJCLSW        SET JCL SWITCH
         SPACE 1                                                     R4
RJCLSCAN CLI   2(RPI),C'*'         TEST COLUMN 3
         BE    RFLTEST             BRANCH IF JCL COMMENT
         LA    RW,0(,RPI)          SET 'RW' FOR CARD SCAN
         LA    R14,1               SET INCREMENT FOR SCAN
         LA    R15,65(,RPI)         AND LIMIT FOR END OF CARD
         SPACE 1
RJBTEST  CLI   2(RW),C' '          SEARCH FOR END OF NAME FIELD
         BE    RJBLANK             BRANCH IF BLANK
         BXLE  RW,R14,RJBTEST      ADVANCE TO NEXT COLUMN
         B     RFLTEST             END IF CARD -- IGNORE
         SPACE 1                                                     R4
RJBLANK  CLI   3(RW),C' '          SEARCH FOR START OF OPERATION
         BNE   RDDTEST             BRANCH IF FOUND
         BXLE  RW,R14,RJBLANK      ADVANCE TO NEXT COLUMN
         SPACE 1
RDDTEST  CLC   3(3,RW),=CL3'DD'    TEST FOR DD CARD
         BNE   RJJTEST             BRANCH IF NOT A DD CARD
         TM    RDRSW,RXBJOBSW      TEST XEQ BATCH JOB SWITCH
         BO    RFLTEST             PROCESS DD AS DATA CARD IF SET
         LA    R15,66(,RPI)        SET NEW LIMIT FOR END OF CARD
         SPACE 1                                                     R4
RDDBLANK BXH   RW,R14,RFLTEST      ADVANCE TO NEXT COLUMN
         CLI   4(RW),C' '          SEARCH DATA FIELD START
         BE    RDDBLANK            BRANCH IF NOT FOUND
         CLI   4(RW),C'*'          TEST FOR DD *
         BE    RDDSTAR             BRANCH IF DD *
         CLC   4(4,RW),=CL4'DATA'  TEST FOR DD DATA
         BNE   RCONTCK             BRANCH IF NOT DD DATA       @OZ73741
         OI    RDRSW,RNOSCAN       TURN OFF CARD SCAN                R4
         LA    RW,3(,RW)           ADVANCE INPUT COLUMN              R4
         EJECT                                                 @OZ73741
RDDSTAR $LINK  HASPRDDS            SCAN DD */DATA                    R4
         BR    RL2                 UPON RETURN RL2 SPECIFIES EXIT    R4
         SPACE 1                                               @OZ73741
RCONTCK  CLI   71(RPI),C' '        IS COL 72 BLANK...          @OZ73741
         BE    RFLTEST             BRANCH IF YES               @OZ73741
         SPACE 1                                               @OZ73741
RVALCONT BAL   RL1,RCONTNUE        GET CONTINUATION CARD       @OZ73741
         B     RINVCONT            RETURN FOR INVALID CONT +0  @OZ73741
         B     RCONTCK             CHECK FOR MORE CONT     +4  @OZ73741
         SPACE 1                                               @OZ73741
RINVCONT MVC   RTEMP(L'RDRSW2),RDRSW2  MOVE SWITCHES           @OZ73741
         NI    RDRSW2,FF-RCONTEOF-RCONTILL  RESET SWITCHES     @OZ73741
         TM    RTEMP,RCONTEOF      IS THIS END OF FILE...      @OZ73741
         BO    RDREND              BRANCH IF YES               @OZ73741
         B     RSCNCONT            ELSE, SCAN INVALID CONT     @OZ73741
         SPACE 1                                               @OZ73741
         SPACE 1                                                     R4
RJJTEST  CLC   3(4,RW),=CL4'JOB'   TEST FOR JOB CARD
         BNE   RCONTCK             BRANCH IF NOT A JOB CARD    @OZ73741
        $LINK  HASPRJCS            INITIALIZE JOB CONTROL INFORMATION
         TM    RDRSW2,RCONTILL     ILLEGAL CONTINUATION...     @OZ73741
         BO    RINVCONT            BRANCH IF YES               @OZ73741
         EJECT                                                       R4
RFLTEST  TM    RDRSW,RJFLUSH       TEST FLUSH SWITCH
         BZ    RCRDOUT             BRANCH IF NOT START OF FLUSH
         CLC   2(7,RPI),=CL7'SIGNON'  TEST FOR /*SIGNON CARD
         BE    RCRDOUT             BRANCH IF /*SIGNON CARD
         L     R1,PCEDCT           R1 = READER DCT ADDRESS     @OZ32566
         USING DCTDSECT,R1         ESTABLISH DCT ADDRESSABILITY
         MVC   RMESSAGE(L'RFLMSG),RFLMSG  SET UP READER SKIPPING
         MVC   RMESSAGE+2(8),DCTDEVN       FOR JOB CARD MESSAGE
         DROP  R1                  DROP DCT ADDRESSABILITY
         TM    PCEID,PCERJEID      TEST PROCESSOR TYPE
         BZ    RNOTRJE1            BRANCH IF NOT REMOTE TERMINAL
         ICM   R1,7,DCTDCB+1-DCTDSECT(R1) GET LINE DCT PTR     @OZ31782
         BZ    RDREND              NO LINE DCT PTR, FREE RDR   @OZ31782
         L     R1,MDCTRAT-DCTDSECT(,R1)  GET ADDRESS OF RAT
         SLR   LINK,LINK                     CLEAR AND INSERT
         ICM   LINK,2,RATCONRT+1-RATDSECT(R1) REMOTE CONSOLE ROUTE CODE
         LA    R0,L'RFLMSG(,LINK)  GENERATE LENGTH OF MESSAGE
        $WTO   RMESSAGE,(R0),JOB=NO,         ISSUE SKIPPING MESSAGE  R4C
               RMT=YES,CLASS=$NORMAL,PRI=$ST  TO REMOTE TERMINAL     R4
         SPACE 2                                                     R4
RNOTRJE1 $WTO  RMESSAGE,L'RFLMSG,JOB=NO,  ISSUE SKIPPING MESSAGE     R4C
               ROUTE=$LOG+$UR,CLASS=$NORMAL,PRI=$ST
         MVC   RPRIORTY,=CL2' '    RESET PRIORITY                    R4
         NI    RDRSW,255-RJFLUSH   TURN OFF FLUSH SWITCH
         B     RNXTCRD             GET NEXT CARD
         SPACE 5
RDREND  $LINK  HASPRDRT            LINK TO TERMINATION MODULE
         B     $READ               RETURN TO INITIALIZATION
         TITLE 'HASP INPUT SERVICE -- PROCESSOR TERMINATION'
HASPRDRO CSECT                     DEFINE SUBROUTINE CSECT
HASPRDRT $ENTRY                    DEFINE TERMINATION SEGMENT
         BAL   RL1,RJOBEND         TERMINATE LAST JOB                R4
         L     RW,PCEDCT           GET ADDR OF INTRNAL RDR DCT @OZ32566
         USING DCTDSECT,RW         ESTABLISH DCT ADDRESSABILITY
         TM    PCEID,PCEINRID      IS THIS INTERNAL READER
         BZ    RNOTINR2            BRANCH IF NOT INTERNAL READER     R4
         ST    JCT,RIDPBF          CLEAR BUFFER ADDRESS
         ST    JCT,RIDPBFO          AND BUFFER OFFSET
         LTR   RBI,RBI             TEST FOR PROTECTED BUFFER
         BZ    RUNFREE             BRANCH IF NONE
         FREEMAIN R,SP=231,LV=RIDBUFSZ+256,A=(RBI)  FREE BUFFER STORAGE
         SR    RBI,RBI             INDICATE NO BUFFER
         B     RUNFREE             FREE INTERNAL READER
         SPACE 1                                                     R4
RNOTINR2 TM    PCEID,PCERJEID      TEST FOR REMOTE TERMINAL          R4
         BZ    RNOTRJE2            BRANCH IF NOT                     R4
        $EXTP  CLOSE,(RW)          CLOSE REMOTE TERMINAL
         B     RUNFREE             FREE REMOTE READER DCT
         SPACE 1                                                     R4
RNOTRJE2 $FREEBUF (RBI)            RETURN INPUT BUFFER               R4
         OI    DCTSTAT,DCTHOLD     SET READER UNAVAILABLE
         SPACE 1                                                     R4
RUNFREE $FREUNIT (RW)              FREE INPUT DEVICE
         DROP  RW                  DROP DCT ADDRESSABILITY
        $DORMANT                   INDICATE PROCESSOR INACTIVE
        $RETURN                    RETURN TO MAIN PROCESSOR
         DROP  BASE3               DROP SEGMENT ADDRESSABILITY
         TITLE 'HASP INPUT SERVICE -- CONTROL CARD SCAN ROUTINES'
HASPRDRO CSECT                     DEFINE SUBROUTINE CSECT
HASPRCCS $ENTRY                    DEFINE CONTROL CARD SCAN SEGMENT
         SPACE 5
*
*                             DETERMINE TYPE OF CONTROL CARD
*
         SPACE 3
         LA    RW,RCCTAB           GET ADDR OF CONTROL CARD CODE TABLE
         LA    R14,RCCTBNXT-RCCTAB GET LENGTH OF EACH ENTRY
         LA    R15,RCCTBEND-1      GET END OF CODE TABLE
         SPACE 1                                                     R4
RCCSERCH IC    R1,0(,RW)           GET LENGTH OF CODE WORD
         EX    R1,RCCTBCLC         COMPARE CODE WORD
         BE    RCNTLCRD            BRANCH IF TABLE ENTRY FOUND
         BXLE  RW,R14,RCCSERCH     TRY AGAIN
         SPACE 2                                                     R4
RCNTLCRD L     RL1,0(,RW)          GET ADDRESS FROM CODE TABLE
         BR    RL1                 GO TO APPROPRIATE PROCESSING ROUTINE
         SPACE 5
RCCTBCLC CLC   4(*-*,RW),2(RPI)    TABLE COMPARE INSTRUCTION
         SPACE 3
RCCTAB   DS    0F                  CONTROL CARD ROUTING TABLE
RCOMCHAR EQU   *+4,1               HASP COMMAND CHARACTER
         DC    AL1(0),AL3(RCOMCARD),CL8'$'        HASP COMMAND CARD
RCCTBNXT DS    0F
         DC    AL1(7),AL3(RJBPCARD),CL8'JOBPARM'  HASP JOBPARM CARD
         DC    AL1(7),AL3(RMSGCARD),CL8'MESSAGE'  HASP MESSAGE CARD
         DC    AL1(6),AL3(ROTPCARD),CL8'OUTPUT'   HASP OUTPUT CARD
         DC    AL1(7),AL3(RPRICARD),CL8'PRIORITY' HASP PRIORITY CARD
         DC    AL1(5),AL3(ROUTCARD),CL8'ROUTE'    HASP ROUTE CARD
         DC    AL1(5),AL3(RSETCARD),CL8'SETUP'    HASP SETUP CARD
         DC    AL1(3),AL3(RSPECARD),CL8'DEL'      DEL CARD     @OZ75603
         DC    AL1(3),AL3(RSPECARD),CL8'EOF'      EOF CARD     @OZ75603
         DC    AL1(5),AL3(RSPECARD),CL8'PURGE'    PURGE CARD   @OZ75603
         DC    AL1(4),AL3(RSPECARD),CL8'SCAN'     SCAN CARD    @OZ75603
RCCTBEND DC    A(RCCUNDEF)                        INV. CARD    @OZ64248
         EJECT
*
*                             HASP COMMAND CARD PROCESSING ROUTINE
*
         SPACE 3
RCOMCARD NULL
         LTR   JCT,JCT             TEST FOR JOB                      R4
         BNZ   RILLCCRD            IGNORE COMMAND IF IN A JOB
         SPACE 2                                                     R4
RGETQUE $GETCMB COUNT=1            TRY TO GET CONSOLE MESSAGE BUFFER
         BNZ   RCOMBUF             BRANCH IF SUCCESSFUL
        $WAIT  CMB                 WAIT FOR CONSOLE MESSAGE BUFFER
         B     RGETQUE             TRY AGAIN
         SPACE 1                                                     R4
RCOMBUF  LR    RL1,R1              RL1 = ADDRESS OF CMB
         USING CMBDSECT,RL1        ESTABLISH CMB ADDRESSABILITY
         L     RW,PCEDCT           RW = ADDRESS OF INPUT DCT   @OZ32566
         CLI   71(RPI),C'N'        TEST COLUMN 72
         BE    RCOMQUE             BYPASS WTO IF COLUMN 72 IS 'N'
         MVC   0(2,RL1),RCOMMSG              SET UP
         MVC   2(8,RL1),DCTDEVN-DCTDSECT(RW)  MESSAGE NUMBER
         MVI   10(RL1),C' '                    DEVICE NAME
         MVC   11(69,RL1),2(RPI)                AND COMMAND
        $WTO   (RL1),80,JOB=NO,    LOG COMMAND                         C
               ROUTE=$LOG+$UR+$TP,CLASS=$NORMAL,PRI=$HI
         SPACE 1                                                     R4
RCOMQUE  MVC   CMBFLAG(14),RCOMASK SET HEADER                        R4
         MVN   CMBFLAG,DCTRAUTH-DCTDSECT(RW)  SET RESTRICTION FLAGS  R4
         MVC   CMBFM,$SYSID        SET RESPONSE SYSTEM               R4
         TM    PCEID,PCERJEID      TEST PROCESSOR TYPE
         BZ    RCONRMT             BRANCH IF NOT REMOTE TERMINAL
         ICM   R1,7,DCTDCB+1-DCTDSECT(RW) GET LINE DCT ADDR    @OZ38127
         BZ    RCOMRET             EXIT IF NONE                @OZ38127
         L     R1,MDCTRAT-DCTDSECT(,R1)  GET ADDRESS OF RAT
         MVC   CMBRMT,RATCONRT+1-RATDSECT(R1)  SET RESPONSE REMOTE   R4
         MVI   CMBFLAG,CMBFLAGC+CMBFLAGW+CMBFLAGR  SET REMOTE FLAGS  R4
         EJECT                                                       R4
RCONRMT  MVC   CMBMSG(69),2(RPI)   SET UP COMMAND                    R4
         MVI   CMBMSG+69,C' '      BLANK OUT REST OF BUFFER
         MVC   CMBMSG+70(L'CMBMSG-70),CMBMSG+69
         L     RW,$SSVT            RW = ADDRESS OF SSVT
         USING SSVT,RW             ESTABLISH SSVT ADDRESSABILITY
         L     R0,$SVCOMMQ         GET COMMAND QUEUE HEAD
         SPACE 1                                                     R4
RCOMRQUE ST    R0,CMBCMB           PREPARE TO QUEUE COMMAND          R4
         CS    R0,RL1,$SVCOMMQ     QUEUE TO COMMAND PROCESSOR
         BNE   RCOMRQUE            TRY AGAIN IF NOT QUEUED
         L     R1,$COMMPCE         $POST COMMAND SERVICE             R4
        $POST  (R1),WORK            PROCESSOR
         LA    RL2,RNXTCRD         LOAD ADDRESS OF EXIT
RCOMRET $RETURN                                                @OZ38127
         DROP  RW,RL1              DROP SSVT AND CMB ADDRESSABILITY
         EJECT
*
*                             HASP PRIORITY CARD PROCESSING ROUTINE
*
         SPACE 3
RPRICARD NULL
         BAL   RL1,RJOBEND         TERMINATE PREVIOUS JOB
         LA    R1,RILLPRIC         SET IGNORE/EXIT BRANCH ADDRESS    R4
         TM    $RUNOPTS,$PRIOOPT   IGNORE /*PRIORITY CARD IF         R4
         BZR   R1                    INIT OPTION NOT SELECTED        R4
         CLI   10(RPI),C' '        VERIFY BLANK                     R41
         BNER  R1                   AFTER 'PRIORITY'                R41
         LA    RW,10(,RPI)         SET                              R41
         LA    R14,1                REGISTERS FOR                   R41
         LA    R15,70(,RPI)          CARD SCAN                      R41
         SPACE 1                                                    R41
RPRIBLUP BXH   RW,R14,RILLPRIC     SCAN                             R41
         CLI   0(RW),C' '           FOR FIRST                       R41
         BE    RPRIBLUP              NON-BLANK                      R41
         CLI   0(RW),C'0'          IGNORE IF                        R41
         BLR   R1                    FIRST DIGIT                     R4
         CLI   0(RW),C'9'            NOT ZERO                       R41
         BHR   R1                    THRU NINE                       R4
         CLI   1(RW),C' '          BRANCH IF NEXT                   R41
         BNE   RPRI2                 CHARACTER NOT BLANK             R4
         MVC   RPRIORTY+1(1),0(RW)   SAVE 1-DIGIT PRIORITY          R41
         BR    R1                  BRANCH TO END                     R4
         SPACE 1                                                     R4
RPRI2    CLI   2(RW),C' '          IGNORE IF MORE                   R41
         BNER  R1                    THAN 2 CHARACTERS               R4
         CLI   1(RW),C'0'          IGNORE IF                        R41
         BLR   R1                    SECOND DIGIT                    R4
         CLI   1(RW),C'9'            NOT ZERO                       R41
         BHR   R1                    THRU NINE                       R4
         CLC   =C'15',0(RW)        IGNORE IF OVER                   R41
         BLR   R1                    FIFTEEN                         R4
         MVC   RPRIORTY(2),0(RW)   SAVE 2-DIGIT PRIORITY            R41
         SPACE 1                                                     R4
RILLPRIC OI    RDRSW,RJFLUSH+RJCLSW  SET FLUSH AND JCL SWITCHES
         LA    RL2,RPRIREAD        LOAD ADDRESS OF EXIT
        $RETURN                     AND RETURN
         EJECT
*
*                             HASP ROUTE CARD PROCESSING ROUTINE
*
         SPACE 1                                                     R4
ROUTCARD LTR   JCT,JCT             TEST FOR JOB                      R4
         BZ    RILLCCRD            IGNORE ROUTE CARD IF NOT IN JOB
         OI    RCARDLRC,LRC1INUL+RDLMSKIP  INDICATE SUPERFLUOUS CARD R4
         BAL   RL1,RPUT            ADD ROUTE CARD TO OUTPUT FILE
         TM    RDRSW,RJCLSW        TEST STATUS
         BO    *+12                BRANCH IF JCL FILE
         BAL   RL1,RPUT            TERMINATE DATA SET
         OI    RDRSW,RJCLSW        SET JCL SWITCH
         LA    R1,7(,RPI)          SET                              R41
         LA    R14,1                REGISTERS FOR                   R41
         LA    R15,70(,RPI)          CARD SCAN                 @OZ32101
         SPACE 1                                                    R41
ROUTROUT BXH   R1,R14,RILLROUT     SCAN FOR                         R41
         CLI   0(R1),C' '           FIRST                           R41
         BE    ROUTROUT              NON-BLANK                      R41
*              THIS LINE DELETED BY APAR NUMBER                @OZ32101
*              THIS LINE DELETED BY APAR NUMBER                @OZ32101
         LA    RW,JCTPROUT         ASSUME PRINT ROUTING
         CLC   RPRINT,0(R1)        'PRINT'...                       R41
         BE    ROUTDES             BR IF PRINT ROUTING              R41
         CLC   RPUNCH,0(R1)        'PUNCH'...                       R41
         BNE   RILLROUT            ILLEGAL IF NOT PUNCH ROUTING
         LA    RW,JCTPUOUT         SET FOR PUNCH ROUTING
         SPACE 1                                                    R41
ROUTDES  BXH   R1,R14,RILLROUT     SCAN                             R41
         CLI   0(R1),C' '           PAST                            R41
         BNE   ROUTDES               ROUTING                        R41
         SPACE 1                                                    R41
ROUTDEST BXH   R1,R14,RILLROUT     SCAN                             R41
         CLI   0(R1),C' '           FOR                             R41
         BE    ROUTDEST              DESTINATION                    R41
         SR    RL1,RL1             CLEAR R5                    @OZ32101
         SPACE 1                                               @OZ32101
ROUTNME  LA    RL1,1(RL1)          INCREMENT COUNTER           @OZ32101
         BXH   R1,R14,RILLROUT     SCAN FOR                    @OZ32101
         CLI   0(R1),C' '           INVALID                    @OZ32101
         BNE   ROUTNME               DESTINATION NAME          @OZ32101
         CH    RL1,=H'8'           IS DEST NAME TOO LONG...    @OZ32101
         BH    RILLROUT            BRANCH IF YES               @OZ32101
         SR    R1,RL1              RESET DEST NAME ADDRESS     @OZ32101
         SPACE 1                                               @OZ32101
RPROUTE  BAL   RL1,RDESTSCN        CONVERT DESTINATION TO ROUTE CODE R4
         B     RILLROUT            BRANCH IF INVALID DESTINATION
         B     ROPSHIFT            BRANCH IF VALID   DESTINATION    R41
         EJECT                                                      R41
RILLROUT OI    RCARDLRC,LRC1ONUL+RDLMSKIP SET INTERNALLY GEN   @OZ30530
         BAL   RL1,RPUT            ADD MESSAGE TO OUTPUT FILE  @OZ30530
         OI    RCARDLRC,LRC1CCTL+LRC1TASA SET ASA CAR CONTROL  @OZ30530
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE                R4
         MVI   0(RPI),C'*'         FILL OUT CARD IMAGE               R4
         MVC   1(78,RPI),0(RPI)     WITH ASTERISKS                   R4
         MVI   79(RPI),C' '        ADD TRAILING BLANK                R4
         MVC   (79-22)/2(22,RPI),RRILEGAL+4  MOVE IN ERROR MESSAGE   R4
         BAL   RL1,RPUT            ADD ERROR MESSAGE TO OUTPUT FILE
        $WTO   RRILEGAL,L'RRILEGAL,JOB=YES,               ISSUE ERROR  C
               ROUTE=$LOG+$UR,CLASS=$TRIVIA,PRI=$ST         MESSAGE
         BAL   RL1,RJOBKILL        KILL JOB
         LA    RL2,RFLTEST         LOAD ADDRESS OF EXIT
        $RETURN                     AND RETURN
         EJECT
*
*                             HASP SETUP CARD PROCESSING ROUTINE
*
         SPACE 3
RSETCARD NULL
         LTR   JCT,JCT             TEST FOR JOB                      R4
         BZ    RILLCCRD            IGNORE SETUP CARD IF NOT IN A JOB
         TM    JCTJBOPT,JCTSETUP   TEST FOR PREVIOUS SETUP CARD
         BO    RMSGCARD            TREAT AS MESSAGE CARD IF NOT FIRST
        $WTO   RSETHMSG,L'RSETHMSG,JOB=YES,                ISSUE SETUP C
               ROUTE=$LOG+$TAPE+$MAIN,CLASS=$ACTION,PRI=$ST MESSAGE
         OI    JCTJBOPT,JCTSETUP   INDICATE SETUP CARD(S) PRESENT
         EJECT
*
*                             HASP MESSAGE CARD PROCESSING ROUTINE
*
         SPACE 3
RMSGCARD NULL
         LTR   JCT,JCT             TEST FOR JOB                      R4
         BZ    RMSGSCAN            BRANCH IF NO JOB
         OI    RCARDLRC,LRC1INUL+RDLMSKIP  INDICATE SUPERFLUOUS CARD R4
         BAL   RL1,RPUT            ADD CARD TO OUTPUT FILE
         TM    RDRSW,RJCLSW        TEST STATUS
         BO    *+12                BRANCH IF JCL FILE
         BAL   RL1,RPUT            TERMINATE DATA SET
         OI    RDRSW,RJCLSW        SET JCL SWITCH
         SPACE 1                                                     R4
RMSGSCAN LA    R14,1               SET UP REGISTERS                 R41
         LA    R15,70(,RPI)         FOR CARD SCAN                   R41
         LA    RW,7(,RPI)          STARTING COL. FOR SETUP INFO     R41
         CLI   2(RPI),C'S'         /*SETUP CARD...                  R41
         BE    RMSGSMSG            BR IF YES                        R41
         LA    RW,9(,RPI)           ELSE, STARTING COL. FOR MESSAGE R41
         SPACE 1                                                    R41
RMSGSMSG BXH   RW,R14,RMSGRETN     SUPPRESS                         R41
         CLI   0(RW),C' '           LEADING                         R41
         BE    RMSGSMSG              BLANKS                         R41
         SPACE 1                                                    R41
         USING CMBDSECT,R1         PROVIDE CMB ADDRESSABILITY       R41
         SPACE 1                                                    R41
RMSGCMB $GETCMB ,                  GET A CMB FOR CONSOLE MSG        R41
         BNZ   RMSGBLD             BR IF GOT CMB                    R41
        $WAIT  CMB                  ELSE WAIT FOR A CMB             R41
         B     RMSGCMB             TRY AGAIN                        R41
         SPACE 1                                                    R41
RMSGBLD  LA    R14,71-1(,RPI)      COMPUTE LENGTH -1                R41
         SLR   R14,RW               OF MESSAGE                      R41
         EX    R14,RMSGMOVE        MOVE MESSAGE TO CMB              R41
         SPACE 1                                                    R41
         LA    RW,CMBTEXT          MESSAGE AREA        (JOB-TYPE)   R41
         LA    R0,2+1(,R14)        MESSAGE LENGTH      (JOB-TYPE)   R41
         LA    R15,RMSGJOB         LIST-FORM $WTO      (JOB-TYPE)   R41
         EJECT                                                      R41
         LTR   JCT,JCT             WAS CARD FOUND WITHIN A JOB...   R41
         BNZ   RMSGMID             BR IF YES                        R41
         SPACE 1                                                    R41
         LA    RW,CMBJOBN          MESSAGE AREA        (NOJOB-TYPE) R41
         LA    R0,2+9+1(,R14)      MESSAGE LENGTH      (NOJOB-TYPE) R41
         L     R15,PCEDCT                    INSERT            @OZ32566
         MVC   2(8,RW),DCTDEVN-DCTDSECT(R15)  DEVICE                R41
         MVI   2+8(RW),C' '                    NAME                 R41
         LA    R15,RMSGNJOB        LIST-FORM $WTO      (NOJOB-TYPE) R41
         SPACE 1                                                    R41
RMSGMID  MVC   0(2,RW),RMSGMSG     USE 'MESSAGE' MSG ID             R41
         CLI   2(RPI),C'M'         /*MESSAGE CARD...                R41
         BE    RMSGWTO             BR IF YES                        R41
         MVC   0(2,RW),RSETMSG      ELSE USE 'SETUP' MSG ID         R41
         SPACE 1                                                    R41
RMSGWTO $WTO   (R1),(R0),CMB=YES,MF=(E,0(,R15))  ISSUE CONSOLE MSG  R41
         SPACE 1                                                    R41
RMSGRETN LTR   JCT,JCT             PROCESSING JOB...                R41
         BNZ   ROPSHIFT            CONVERT TO //* IF YES            R41
         LA    RL2,RNXTCRD          ELSE LOAD EXIT                  R41
        $RETURN                      ROUTINE ADDRESS                R41
         SPACE 1                                                    R41
RMSGMOVE MVC   CMBTEXT+2(*-*),0(RW)  *** EXECUTE ONLY ***           R41
         SPACE 1                                                    R41
         DROP  R1                  DROP CMB ADDRESSABILITY          R41
         SPACE 3                                                    R41
RMSGJOB  $WTO  JOB=YES,            LIST-FORM $WTO FOR JOB-TYPE      R41C
               MF=L,               ---------------------------      R41C
               CLASS=$ACTION,PRI=$ST,                               R41C
               ROUTE=$LOG+$TAPE+$MAIN                               R41
         SPACE 3                                                    R41
RMSGNJOB $WTO  JOB=NO,             LIST-FORM $WTO FOR NOJOB-TYPE    R41C
               MF=L,               -----------------------------    R41C
               CLASS=$ACTION,PRI=$ST,                               R41C
               ROUTE=$LOG+$TAPE+$MAIN                               R41
         EJECT
*
*                             HASP JOBPARM CARD PROCESSING ROUTINE
*
         SPACE 3
RJBPCARD NULL
         LTR   JCT,JCT             TEST FOR JOB                      R4
         BZ    RILLCCRD            IGNORE JOBPARM CARD IF NOT IN JOB
         OI    RCARDLRC,LRC1INUL+RDLMSKIP  INDICATE SUPERFLUOUS CARD R4
         BAL   RL1,RPUT            ADD JOBPARM CARD TO OUTPUT FILE
         TM    RDRSW,RJCLSW        TEST STATUS
         BO    *+12                BRANCH IF JCL FILE
         BAL   RL1,RPUT            TERMINATE DATA SET
         OI    RDRSW,RJCLSW        SET JCL SWITCH
         XC    JCTWORK(1+4*7+3),JCTWORK  CLEAR WORK AREA            R41
         LA    R1,RJPTABLE         GET ADDRESS OF JOBPARM SCAN TABLE
         LA    RW,8(,RPI)          SET UP
         LA    R14,1                REGISTERS
         LA    R15,70(,RPI)          FOR SCAN SUBROUTINE
         BAL   RL1,RKEYSCAN        SCAN PARAMETERS                   R4
         B     RILLJOBP            ILLEGAL JOBPARM CARD              R4
         CLI   JCTWORK,0           TEST FOR RESTART OPTION           R4
         BE    RJBURST             BR IF NO                         R41
         CLI   JCTWORK,C'Y'        TEST FOR RESTART=Y                R4
         BNE   RJBNRST             BR IF NO                          R4
         OI    JCTJOBFL,JCTRSTRT    ELSE ALLOW JOB RESTART           R4
         B     RJBURST               AND BR TO CONTINUE             R41
         SPACE 1                                                     R4
RJBNRST  CLI   JCTWORK,C'N'        TEST FOR RESTART=N                R4
         BNE   RILLJOBP            ILLEGAL IF NO                     R4
         NI    JCTJOBFL,255-JCTRSTRT  ELSE DISALLOW JOB RESTART      R4
         SPACE 1                                                    R41
RJBURST  CLI   JCTWORK+31,0        TEST FOR BURST OPTION            R41
         BE    RJBSYSAF            BR IF NO                         R41
         CLI   JCTWORK+31,C'Y'     TEST FOR BURST=Y                 R41
         BNE   RJBNBURS            BR IF NO                         R41
         OI    JCTFLAG1,JCTBURST    ELSE SET BURST SYSOUT FLAG      R41
         B     RJBSYSAF              AND BR TO CONTINUE             R41
         SPACE 1                                                    R41
RJBNBURS CLI   JCTWORK+31,C'N'     TEST FOR BURST=N                 R41
         BNE   RILLJOBP            ILLEGAL IF NO                    R41
         NI    JCTFLAG1,255-JCTBURST  ELSE RESET BURST FLAG         R41
         EJECT                                                      R41
RJBSYSAF CLI   JCTWORK+1,0         TEST FOR SYSAFF PARAMETERS        R4
         BE    ROPSHIFT            BRANCH IF NONE
         MVI   RDRSIAFF,0          CLEAR SYSTEM AFFINITY
         LA    R1,JCTWORK+1        GET ADDRESS OF 1ST PARAMETER      R4
         SPACE 1                                                     R4
RJBPSAF1 CLC   RANY,0(R1)          TEST PARAMETER
         BE    RJBPSAF3            BRANCH IF 'ANY'
         CLC   RIND,0(R1)          TEST PARAMETER AGAIN
         BE    RJBPSAF4            BRANCH IF 'IND'
         CLC   RSTAR,0(R1)         TEST PARAMETER AGAIN
         BE    RJBPSAF5            BRANCH IF '*'
         L     R15,$QSE1           GET ADDRESS OF FIRST QSE          R4
         USING QSEDSECT,R15        ESTABLISH QSE ADDRESSABILITY
         SPACE 1                                                     R4
RJBPSAF2 CLC   QSESID,0(R1)        COMPARE SID WITH PARAMETER
         BE    RJBPSAF6            BRANCH IF QSE FOUND
         TM    QSEFLAGS,QSELAST    TEST FOR LAST QSE
         BO    RILLJOBP            ERROR IF QSE NOT FOUND
         LA    R15,QSELEN(,R15)    GET ADDRESS OF NEXT QSE     @OZ27300
         B     RJBPSAF2            CONTINUE SEARCH
         SPACE 1                                                     R4
RJBPSAF3 OI    RDRSIAFF,QUESYSAF   SET GLOBAL AFFINITY
         B     RJBPSAF7            GET NEXT PARAMETER
         SPACE 3                                                     R4
RJBPSAF4 OI    RDRSIAFF,QUEINDAF   SET INDEPENDENT AFFINITY
         B     RJBPSAF7            GET NEXT PARAMETER
         SPACE 3                                                     R4
RJBPSAF5 LA    R15,$SIDAFF-(QSESIAFF-QSEDSECT)  SET INPUT AFFINITY
         SPACE 1                                                     R4
RJBPSAF6 OC    RDRSIAFF,QSESIAFF   ADD SYSTEM'S AFFINITY BIT
         SPACE 1                                                     R4
RJBPSAF7 LA    R1,4(,R1)           STEP TO NEXT PARAMETER
         CLI   0(R1),0             TEST
         BNE   RJBPSAF1            SCAN NEXT PARAMETER IF NOT DONE
         TM    RDRSIAFF,QUESYSAF   TEST FINAL AFFINITY
         BNZ   ROPSHIFT            BRANCH IF LEGITIMATE AFFINITY
         DROP  R15                 DROP QSE ADDRESSABILITY
         EJECT                                                       R4
RILLJOBP OI    RCARDLRC,LRC1ONUL+RDLMSKIP SET INTERNAL GEN     @OZ30530
         BAL   RL1,RPUT            ADD MESSAGE TO OUTPUT FILE  @OZ30530
         OI    RCARDLRC,LRC1CCTL+LRC1TASA SET ASA CAR CONTROL  @OZ30530
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE                R4
         MVI   0(RPI),C'*'         FILL OUT CARD IMAGE               R4
         MVC   1(78,RPI),0(RPI)     WITH ASTERISKS                   R4
         MVI   79(RPI),C' '        ADD TRAILING BLANK                R4
         MVC   (79-24)/2(24,RPI),RJINVLID+4  MOVE IN ERROR MESSAGE   R4
         BAL   RL1,RPUT            ADD ERROR MESSAGE TO OUTPUT FILE
        $WTO   RJINVLID,L'RJINVLID,JOB=YES,               ISSUE ERROR  C
               ROUTE=$LOG+$UR,CLASS=$TRIVIA,PRI=$ST         MESSAGE
         BAL   RL1,RJOBKILL        KILL JOB
         LA    RL2,RFLTEST         LOAD ADDRESS OF EXIT
        $RETURN                     AND RETURN
         EJECT
*
*                             HASP JOBPARM SCAN TABLE
*
         SPACE 3
RJPTABLE DS    0F
         DC    CL7'  BURST',C'B'   JOB OUTPUT BURST OPTION          R41
         DC    AL1(RSCFLEFT+RSCFLBLK+1,1)                           R41
         DC    AL2(JCTWORK+31-JCTDSECT)                             R41
         DS    0F                                                   R41
         DC    CL7'  CARDS',C'C'   ESTIMATED CARD COUNT
         DC    AL1(RSCFLBIN+1,4),AL2(JCTESTPU-JCTDSECT)        @OZ42746
         DS    0F
         DC    CL7' COPIES',C'N'   JOB COPY COUNT
         DC    AL1(RSCFLBIN+1,1),AL2(JCTCPYCT-JCTDSECT)
         DS    0F
         DC    CL7'  FORMS',C'F'   JOB OUTPUT FORMS
         DC    AL1(RSCFLEFT+RSCFLBLK+1,4),AL2(JCTFORMS-JCTDSECT)
         DS    0F
         DC    CL7' LINECT',C'K'   LINES PER PAGE SPECIFICATION
         DC    AL1(RSCFLBIN+1,1),AL2(JCTLINCT-JCTDSECT)
         DS    0F
         DC    CL7'  LINES',C'L'   ESTIMATED LINE COUNT (THOUSANDS)
         DC    AL1(RSCFLBIN+1,4),AL2(JCTESTLN-JCTDSECT)
         DS    0F
         DC    CL7'  NOLOG',C'J'   NO HASP JOB LOG OPTION
         DC    AL1(0,JCTNOLOG),AL2(JCTJBOPT-JCTDSECT)
         DS    0F
         DC    CL7'PROCLIB',C'P'   PROCEDURE LIBRARY SPECIFICATION
         DC    AL1(RSCFLEFT+RSCFLBLK+1,8),AL2(JCTPROCN-JCTDSECT)
         DS    0F
         DC    CL7'   ROOM',C'R'   ROOM NUMBER
         DC    AL1(RSCFLEFT+RSCFLBLK+1,4),AL2(JCTROOMN-JCTDSECT)
         DS    0F
         DC    CL7' SYSAFF',C'S'   SYSTEM AFFINITY
         DC    AL1(RSCFLEFT+RSCFLBLK+7,4),AL2(JCTWORK+1-JCTDSECT)    R4
         DS    0F
         DC    CL7'   TIME',C'T'   ESTIMATED TIME (MINUTES)
         DC    AL1(RSCFLBIN+1,4),AL2(JCTETIME-JCTDSECT)
         DS    0F
         DC    CL7'RESTART',C'E'   JOB RESTART OPTION                R4
         DC    AL1(RSCFLEFT+RSCFLBLK+1,1),AL2(JCTWORK-JCTDSECT)      R4
         DS    0F                                                    R4
         DC    X'FF'               END OF JOBPARM SCAN TABLE
         EJECT
*
*                             HASP OUTPUT CARD PROCESSING ROUTINE
*
*                              (FORMS CODE '*' FOR CONTINUATION)     R4
*                                                                    R4
ROTPCARD NULL
         LTR   JCT,JCT             TEST FOR JOB                      R4
         BZ    RILLCCRD            IGNORE OUTPUT CARD IF NOT IN JOB
         OI    RCARDLRC,LRC1INUL+RDLMSKIP  INDICATE SUPERFLUOUS CARD R4
         BAL   RL1,RPUT            ADD OUTPUT CARD TO OUTPUT FILE
         TM    RDRSW,RJCLSW        TEST STATUS
         BO    *+12                BRANCH IF JCL FILE
         BAL   RL1,RPUT            TERMINATE DATA SET
         OI    RDRSW,RJCLSW        SET JCL SWITCH
         LA    RW,7(,RPI)          SET UP
         LA    R14,1                REGISTERS
         LA    R15,70(,RPI)          FOR CARD SCAN
         BXH   RW,R14,RILLOUPT     SEARCH FOR
         CLI   1(RW),C' '           START OF
         BE    *-8                   FORMS CODE
         MVC   JCTWORK(5),1(RW)    SET UP FORMS CODE
         MVI   JCTWORK+5,X'BF'     ADD TERMINATOR
         LA    R1,JCTWORK          SEARCH
ROPSCAN  BXH   RW,R14,RILLOUPT      FOR
         LA    R1,1(,R1)             FIRST
         TM    0(R1),X'BF'            BLANK
         BM    ROPSCAN             BRANCH IF NOT BLANK
         BO    RILLOUPT            BRANCH IF MORE THAN FOUR CHARACTERS
         MVC   1(2,R1),0(R1)       BLANK FILL
         SLR   RL1,RL1             SET DEFAULT LEFT INDEX            R4
         SPACE 1                                                     R4
         CLC   RSTAR,JCTWORK       TEST FOR CONTINUATION ('* ')      R4
         BNE   ROPCLEAR            BR IF NOT                         R4
         L     R1,RDROCT           GET OCR ADDRESS                   R4
         LTR   R1,R1               CONTINUATION ILLEGAL IF           R4
         BZ    RILLOUPT             FIRST /*OUTPUT CARD              R4
         SPACE 1                                                     R4
         L     RL2,OCTOCROF-OCTDSECT(,R1)  BACK-UP                   R4
         LA    R0,OCRLENG                   OCR OFFSET               R4
         SLR   RL2,R0                        FOR LATER UPDATE        R4
         ST    RL2,OCTOCROF-OCTDSECT(,R1)     AT ROPTADD             R4
         ALR   RL2,R1                      REFRESH                   R4
         MVC   JCTWORK(OCRLENG),0(RL2)      OCR AREA                 R4
         SPACE 1                                                     R4
         USING OCRDSECT,RL2        PROVIDE OCR ADDRESSABILITY        R4
         LA    RL2,JCTWORK         ADDRESS OCR AREA                  R4
         SPACE 1                                                     R4
         TM    OCRINDEX,X'40'      REFRESH                           R4
         BZ    ROPKSCAN             LEFT-                           R41
         IC    RL1,OCRINDEX          INDEX                           R4
         MVI   OCRINDEX,0             VALUE                          R4
         B     ROPKSCAN            BYPASS CLEAR                     R41
         EJECT                                                      R41
ROPCLEAR LA    RL2,JCTWORK         ADDRESS OCR AREA                 R41
         XC    OCRCODE+4(OCRLENG-4),OCRCODE+4  CLEAR OCR AREA       R41
         MVI   OCRCPTN,X'FF'       SET DEFAULT COMPACTION NUMBER    R41
         MVC   OCRCKPTP,=X'FFFF'   SET CKPTPGS NOT SPECIFIED   @OZ19494
         MVC   OCRCKPTL,=X'FFFF'   SET CKPTLNS NOT SPECIFIED   @OZ19494
         SPACE 1                                                    R41
ROPKSCAN XC    ROWAREA,ROWAREA     CLEAR SCANNER WORK AREA          R41
         STC   RL1,ROWLINDX        SET INITIAL LEFT INDEX VALUE      R4
         LA    R1,ROPTABLE         GET ADDRESS OF OUTPUT SCAN TABLE
         BAL   RL1,RKEYSCAN        SCAN PARAMETERS
         B     RILLOUPT            ILLEGAL OUTPUT CARD       (+0)   R41
         SPACE 1                                                    R41
         LA    RL2,JCTWORK         SET OCR ADDRESS REGISTER  (+4)   R41
         CLI   OCRCPTN,X'FF'       DEFAULT COMPACTION NUMBER...     R41
         BE    ROPCKPTP            BRANCH IF YES               @OZ19494
         CLI   OCRCPTN,99          VALID COMPACTION NUMBER          R41
         BH    RILLOUPT             RANGE IS 0-99              @OZ19494
         SPACE 1                                               @OZ19494
ROPCKPTP CLC   OCRCKPTP,=X'FFFF'   TEST FOR CKPTPGS            @OZ19494
         BE    ROPCKPTL            BRANCH IF NOT SPECIFIED     @OZ19494
         CLC   OCRCKPTP,=H'32767'  TEST CKPTPGS VALUE          @OZ19494
         BH    RILLOUPT            ILLEGAL IF GREATER THAN MAX @OZ19494
         CLC   OCRCKPTP,=H'0'      TEST CKPTPGS VALUE          @OZ19494
         BE    RILLOUPT            ILLEGAL IF ZERO             @OZ19494
ROPCKPTL CLC   OCRCKPTL,=X'FFFF'   TEST FOR CKPTLNS            @OZ19494
         BE    ROPBURST            BRANCH IF NOT SPECIFIED     @OZ19494
         CLC   OCRCKPTL,=H'32767'  TEST CKPTLNS VALUE          @OZ19494
         BH    RILLOUPT            ILLEGAL IF GREATER THAN MAX @OZ19494
         SPACE 1                                               @OZ19494
         SPACE 1                                                    R41
ROPBURST CLI   ROWBURST,0          TEST FOR BURST OPTION            R41
         BE    ROPDEX              BR IF NOT                        R41
         NI    OCRFLAGS,255-OCRBRSTY-OCRBRSTN  RESET BURST FLAGS    R41
         CLI   ROWBURST,C'Y'       TEST FOR BURST=Y                 R41
         BNE   ROPNBURS            BR IF NOT                        R41
         OI    OCRFLAGS,OCRBRSTY    ELSE SET BURST=Y FLAG           R41
         B     ROPDEX                AND CONTINUE                   R41
         SPACE 1                                                    R41
ROPNBURS CLI   ROWBURST,C'N'       TEST FOR BURST=N                 R41
         BNE   RILLOUPT            ILLEGAL IF NOT                   R41
         OI    OCRFLAGS,OCRBRSTN    ELSE SET BURST=N FLAG           R41
         SPACE 1                                                    R41
ROPDEX   NI    OCRINDEX,X'3F'      RESET                            R41
         NI    ROWLINDX,X'3F'       HI-ORDER BITS                    R4
         CLI   ROWLINDX,0          TEST FOR LEFT INDEX               R4
         BE    ROPINDEX            BRANCH IF NO LEFT INDEX
         CLI   OCRINDEX,0          TEST FOR RIGHT INDEX              R4
         BNE   RILLOUPT            ILLEGAL IF BOTH ARE SPECIFIED
         MVC   OCRINDEX,ROWLINDX   RESET INDEX                       R4
         OI    OCRINDEX,X'C0'      INDICATE LEFT INDEX               R4
         EJECT                                                       R4
ROPINDEX TM    OCRINDEX,X'20'      TEST INDEXING BYTE                R4
         BO    RILLOUPT            BRANCH IF ILLEGAL INDEX
         TM    OCRINDEX,X'1F'      TEST INDEXING BYTE                R4
         BZ    *+8                 BRANCH IF NO INDEX SPECIFIED
         XI    OCRINDEX,X'80'      INVERT HI-ORDER BIT               R4
         SPACE 1                                                     R4
         CLI   ROWDESTS,0          BYPASS DEST CONVERSIONS           R4
         BE    ROCTEST              IF NONE SPECIFIED                R4
         LA    R0,4                CONVERT DESTINATIONS TO ROUTE CODES
         LA    R1,ROWDESTS         GET ADDRESS OF DESTINATION VALUES R4
         LA    RW,OCRDEST1-OCRDSECT+JCTWORK  AND ROUTE CODES         R4
         XC    0(4*2,RW),0(RW)     CLEAR ROUTE CODES                 R4
         SPACE 1                                                     R4
         DROP  RL2                 KILL OCR ADDRESSABILITY           R4
         SPACE 1                                                     R4
ROPDEST1 CLI   0(R1),0             TEST NEXT FIELD
         BE    ROCTEST             BR IF NO DESTINATION              R4
         BAL   RL1,RDESTSCN        CONVERT DESTINATION TO ROUTE CODE
         B     RILLOUPT            BRANCH IF INVALID DESTINATION
         LA    R1,8(,R1)           GET ADDRESS OF NEXT DESTINATION
         LA    RW,2(,RW)           GET ADDRESS OF NEXT ROUTE CODE
         BCT   R0,ROPDEST1         PROCESS NEXT DESTINATION
         SPACE 2
ROPDEST2 L     R1,RDROCT           GET ADDR OF OUTPUT CONTROL TABLE  R4
ROCTEST  L     R1,RDROCT           GET OCT ADDRESS                   R4
         USING OCTDSECT,R1         ESTABLISH OCT ADDRESSABILITY
         LTR   R1,R1               TEST
         BNZ   ROPTADD             BRANCH IF OCT IS ALREADY ESTABLISHED
         SPACE 2
ROPCHAIN BAL   RL2,RTRACK          GET TRACK ADDRESS FOR NEXT OCT
         LR    RW,R1               SAVE TRACK ADDRESS
         L     R1,RDROCT           RESTORE OCT ADDRESS
         LTR   R1,R1               TEST
         BNZ   ROPWRITE            BRANCH IF NOT FIRST OCT
         ST    RW,JCTOCTTR         SET TRACK ADDRESS OF FIRST OCT
         B     ROPGETB             GET BUFFER FOR FIRST OCT
         SPACE 1                                                     R4
ROPWRITE ST    RW,OCTOCTTR         SET TRACK ADDRESS OF NEXT OCT
         ST    R1,PCEBUFAD         SET OCT ADDRESS IN DCT
         MVC   PCESEEK,OCTTRACK    SET TRACK ADDRESS IN DCT
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE OF PREVIOUS OCT
         SPACE 1                                                     R4
ROPGETB $GETBUF WAIT=YES           GET BUFFER FOR NEXT OCT           R4
         EJECT                                                       R4
         ST    R1,RDROCT           SAVE ADDRESS OF OCT               R4
         XC    OCTSTART(OCTOCR-OCTSTART),OCTSTART  CLEAR OCT HEADER
         MVC   OCTID,ROCTID        SET OCT NAME
         LH    R0,$BUFLENG         SET BLOCK                         R4
         STH   R0,OCTLENG           LENGTH
         MVC   OCTJBKEY,JCTJBKEY   SET JOB KEY
         ST    RW,OCTTRACK         SET TRACK ADDRESS
         LA    RW,OCTOCR-OCTDSECT  SET INITIAL
         ST    RW,OCTOCROF          OCR OFFSET
         SPACE 2
ROPTADD  L     RW,OCTOCROF         GET CURRENT OCR OFFSET
         LA    R0,OCRLENG(,RW)     INCREMENT                         R4
         CH    R0,OCTLENG          COMPARE WITH MAXIMUM LENGTH
         BH    ROPCHAIN            BRANCH IF OCR EXCEEDS SPACE IN OCT
         ALR   RW,R1               GET ADDRESS OF NEXT OCR ENTRY
         MVC   0(OCRLENG,RW),JCTWORK  MOVE OCR TO OCT                R4
         ST    R0,OCTOCROF         UPDATE OCR OFFSET
         DROP  R1                  DROP OCT ADDRESSABILITY
         SPACE 1                                                    R41
*        ROPSHIFT - ENTRY POINT TO CONVERT CONTROL CARDS TO COMMENTS
         SPACE 1                                                    R41
ROPSHIFT TM    RDRSW2,RTPCPY       TYPRUN=COPY...              @OZ69630
         BO    ROPSHFT2            BYPASS CONVERT IF YES       @OZ69630
         MVC   JCTWORK(79),0(RPI)  CONVERT /* CARD             @OZ69630
         MVC   1(79,RPI),JCTWORK    TO //* CARD                     R41
ROPSHFT2 OI    RCARDLRC,LRC1ONUL   INDICATE INTERNALLY GENED   @OZ74415
         LA    RL2,RJCLCARD        LOAD ADDRESS OF EXIT        @OZ74415
        $RETURN                     AND RETURN
         EJECT                                                 @OZ69630
RILLOUPT OI    RCARDLRC,LRC1ONUL+RDLMSKIP SET INTERNAL GEN     @OZ30530
         BAL   RL1,RPUT            ADD MESSAGE TO OUTPUT FILE  @OZ30530
         OI    RCARDLRC,LRC1CCTL+LRC1TASA SET ASA CAR CONTROL  @OZ30530
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE                R4
         MVI   0(RPI),C'*'         FILL OUT CARD IMAGE               R4
         MVC   1(78,RPI),0(RPI)     WITH ASTERISKS                   R4
         MVI   79(RPI),C' '        ADD TRAILING BLANK                R4
         MVC   (79-23)/2(23,RPI),ROINVLID+4  MOVE IN ERROR MESSAGE   R4
         BAL   RL1,RPUT            ADD ERROR MESSAGE TO OUTPUT FILE
        $WTO   ROINVLID,L'ROINVLID,JOB=YES,               ISSUE ERROR  C
               ROUTE=$LOG+$UR,CLASS=$TRIVIA,PRI=$ST         MESSAGE
         BAL   RL1,RJOBKILL        KILL JOB
         LA    RL2,RFLTEST         LOAD ADDRESS OF EXIT
        $RETURN                     AND RETURN
         EJECT
*
*                             HASP OUTPUT SCAN TABLE
*
         SPACE 3
ROPTABLE DS    0F
         DC    CL7'  BURST',C'B'   DATA SET BURST SPECIFICATION      R4
         DC    AL1(RSCFLEFT+1,1)                                     R4
         DC    AL2(ROWBURST-JCTDSECT)                                R4
         DS    0F                                                    R4
         DC    CL7'  CHARS',C'X'   DATA SET CHARS SPECIFICATION      R4
         DC    AL1(RSCFLEFT+RSCFLBLK+4,4)                            R4
         DC    AL2(OCRCHAR1-OCRDSECT+JCTWORK-JCTDSECT)               R4
         DS    0F                                                    R4
         DC    CL7'CKPTLNS',C'E'   DATASET LINES/LOG PAGE SPEC @OZ19494
         DC    AL1(RSCFLBIN+1,2)                               @OZ19494
         DC    AL2(OCRCKPTL-OCRDSECT+JCTWORK-JCTDSECT)         @OZ19494
         DS    0F                                              @OZ19494
         DC    CL7'CKPTPGS',C'P'   DATASET LOG PAGES/CKPT SPEC @OZ19494
         DC    AL1(RSCFLBIN+1,2)                               @OZ19494
         DC    AL2(OCRCKPTP-OCRDSECT+JCTWORK-JCTDSECT)         @OZ19494
         DS    0F                                              @OZ19494
         DC    CL7' COPIES',C'N'   DATA SET COPY COUNT
         DC    AL1(RSCFLBIN+1,1)
         DC    AL2(OCRCOPY-OCRDSECT+JCTWORK-JCTDSECT)
         DS    0F
         DC    CL7'  COPYG',C'G'   DATA SET CPY GROUPS SPECIFICATION R4
         DC    AL1(RSCFLBIN+8,1)                                     R4
         DC    AL2(OCRCOPYG-OCRDSECT+JCTWORK-JCTDSECT)               R4
         DS    0F                                                    R4
         DC    CL7'   DEST',C'D'   DATA SET DESTINATION(S)
         DC    AL1(RSCFLEFT+RSCFLBLK+4,8)
         DC    AL2(ROWDESTS-JCTDSECT)                                R4
         DS    0F
         DC    CL7'    FCB',C'C'   DATA SET FCB SPECIFICATION
         DC    AL1(RSCFLEFT+RSCFLBLK+1,4)
         DC    AL2(OCRFCB-OCRDSECT+JCTWORK-JCTDSECT)
         DS    0F
         DC    CL7'  FLASH',C'O'   FLASH (FORMS OVERLAY) SPECIF.     R4
         DC    AL1(RSCFLEFT+RSCFLBLK+1,4)                            R4
         DC    AL2(OCRFLASH-OCRDSECT+JCTWORK-JCTDSECT)               R4
         DS    0F                                                    R4
         DC    CL7' FLASHC',C'Q'   FLASH COUNT (QUANTITY) SPECIF.    R4
         DC    AL1(RSCFLBIN+1,1)                                     R4
         DC    AL2(OCRFLSHC-OCRDSECT+JCTWORK-JCTDSECT)               R4
         DS    0F                                                    R4
         DC    CL7'  FORMS',C'F'   DATA SET FORMS SPECIFICATION
         DC    AL1(RSCFLEFT+RSCFLBLK+1,4)
         DC    AL2(OCRFORMS-OCRDSECT+JCTWORK-JCTDSECT)
         DS    0F
         DC    CL7'  INDEX',C'I'   DATA SET INDEX SPECIFICATION
         DC    AL1(RSCFLBIN+1,1)
         DC    AL2(OCRINDEX-OCRDSECT+JCTWORK-JCTDSECT)
         DS    0F
         DC    CL7' LINDEX',C'L'   DATA SET LEFT INDEX SPECIFICATION
         DC    AL1(RSCFLBIN+1,1)
         DC    AL2(ROWLINDX-JCTDSECT)                                R4
         SPACE 1                   THIS LINE DELETED BY APAR   @OZ19494
         SPACE 1                   THIS LINE DELETED BY APAR   @OZ19494
         SPACE 1                   THIS LINE DELETED BY APAR   @OZ19494
         DS    0F
         DC    CL7' MODIFY',C'Y'   DATA SET MODIFY SPECIFICATION     R4
         DC    AL1(RSCFLEFT+RSCFLBLK+1,4)                            R4
         DC    AL2(OCRMODF-OCRDSECT+JCTWORK-JCTDSECT)                R4
         DS    0F                                                    R4
         DC    CL7' MODTRC',C'M'   MODIFY TRC SPECIFICATION          R4
         DC    AL1(RSCFLBIN+1,1)                                     R4
         DC    AL2(OCRMODFT-OCRDSECT+JCTWORK-JCTDSECT)               R4
         DS    0F                                                    R4
         DC    CL7'  RECNT',C'R'   DATA SET ESTIMATED RECORD COUNT
         DC    AL1(RSCFLBIN+1,4)
         DC    AL2(OCRRECNT-OCRDSECT+JCTWORK-JCTDSECT)
         DS    0F
         DC    CL7'    UCS',C'T'   DATA SET UCS SPECIFICATION
         DC    AL1(RSCFLEFT+RSCFLBLK+1,4)
         DC    AL2(OCRUCS-OCRDSECT+JCTWORK-JCTDSECT)
         DS    0F
         DC    CL7'COMPACT',C'Z'   DATASET COMPACTION TABLE NUMBER  R41
         DC    AL1(RSCFLBIN+1,1)                                    R41
         DC    AL2(OCRCPTN-OCRDSECT+JCTWORK-JCTDSECT)               R41
         DS    0F                                                   R41
         DC    X'FF'               END OF OUTPUT SCAN TABLE
         SPACE 4                                                     R4
*                             OUTPUT SCAN WORK AREA DEFINITIONS      R4
         SPACE 3                                                     R4
JCTDSECT DSECT                                                       R4
         ORG   JCTWORK+OCRLENG     DEFINE SCAN WORK AREA             R4
ROWDESTS DS    0CL32                   DESTINATION VALUES            R4
ROWDEST1 DS    CL8                 1ST DESTINATION VALUE             R4
ROWDEST2 DS    CL8                 2ND DESTINATION VALUE             R4
ROWDEST3 DS    CL8                 3RD DESTINATION VALUE             R4
ROWDEST4 DS    CL8                 4TH DESTINATION VALUE             R4
ROWBURST DS    CL1                 BURST VALUE                       R4
ROWLINDX DS    XL1                 LEFT INDEX VALUE                  R4
ROWAREA  EQU   ROWDESTS,*-ROWDESTS WORK AREA EQUATE AND LENGTH       R4
         SPACE 1                                                     R4
HASPRDRO CSECT                                                       R4
         EJECT
***********************************************************************
*                                                                     *
*              RDESTSCN  -  DESTINATION CONVERSION SUBROUTINE         *
*                                                                     *
*                  OUTPUT  --  RW = ADDRESS OF BINARY DESTINATION     *
*                                                                     *
*                  INPUTS  --  R1 = ADDRESS OF DESTINATION            *
*                                                                     *
*                  FUNCTION  --  CONVERT DESTINATION TO ITS BINARY    *
*                                EQUIVALENT                           *
*                                                                     *
*                  RETURNS  --  RL1+0 = ERROR RETURN                  *
*                               RL1+4 = NORMAL RETURN                 *
*                                                                     *
*                  EXTERNAL ROUTINE  --  $SVDEST                      *
*                                                                     *
***********************************************************************
         SPACE 3                                                     R4
RDESTSCN NULL                                                        R4
         TM    0(R1),X'BF'         TEST FIRST BYTE OF DESTINATION    R4
         BZR   RL1                 ERROR IF ZERO OR BLANK            R4
         MVC   RDEST,0(R1)         MOVE DESTINATION TO WORK AREA     R4
         MVI   RDEST+8,C' '        SET SCAN TERMINATOR               R4
         LA    R15,RDEST           SCAN                              R4
SKIP80   LA    R15,1(,R15)          FOR                              R4
         CLI   0(R15),C' '           FIRST                           R4
         BNE   SKIP80                 BLANK                          R4
         MVC   1(6,R15),0(R15)     BLANK OUT REST OF DESTINATION     R4
         STM   R0,R11,PCER0        SAVE REGISTERS                    R4
         L     R1,PCEDCT           GET ADDRESS OF DCT          @OZ32566
         SLR   R2,R2                   SET UP                        R4
         IC    R2,DCTSYS-DCTDSECT(,R1)  SYSTEM ID                    R4
         LA    R1,RDEST            GET ADDRESS OF DESTINATION        R4
         L     R11,$SSVT           GET ADDRESS OF SSVT               R4
         L     R15,$SVDEST-SSVT(,R11)  GET ADDRESS OF ROUTINE        R4
         BALR  R14,R15             CONVERT NAME TO ROUTE CODE        R4
         B     RDESTERR            ERROR RETURN                      R4
         LR    R15,R2              NORMAL RETURN, MOVE CODE TO R15   R4
         LM    R0,R11,PCER0        RESTORE REGISTERS                 R4
         STH   R15,0(,RW)          SET ROUTE CODE                    R4
         B     4(,RL1)              AND RETURN                       R4
         SPACE 3                                                     R4
RDESTERR LM    R0,R11,PCER0        RESTORE REGISTERS                 R4
         BR    RL1                 ERROR RETURN                      R4
         EJECT                                                       R4
************************************************************** @OZ64248
*                                                            * @OZ64248
*        INVALID '/*' CONTROL STATEMENT DETECTED             * @OZ64248
*                                                            * @OZ64248
************************************************************** @OZ64248
         SPACE 1                                               @OZ64248
RCCUNDEF LTR   JCT,JCT             INVALID CARD WITHIN JOB...  @OZ64248
         BZ    RILLCCRD            IGNORE CARD IF NO JOB       @OZ64248
         OI    RCARDLRC,LRC1INUL+RDLMSKIP  ELSE, INDICATE      @OZ64248
*                                           SUPERFLUOUS CARD   @OZ64248
         BAL   RL1,RPUT            ADD CARD TO OUTPUT FILE     @OZ64248
         TM    RDRSW,RJCLSW        ARE WE IN JCL MODE ...      @OZ64248
         BO    RCCUNJCM            YES, BYPASS INPUT TERM.     @OZ64248
         BAL   RL1,RPUT            ELSE, TERM. INPUT FILE      @OZ64248
         OI    RDRSW,RJCLSW        SET READER IN JCL MODE      @OZ64248
         OI    RCARDLRC,LRC1INUL+RDLMSKIP  WRITE NULL/INPUT    @OZ64248
         BAL   RL1,RPUT             CARD TO JCL FILE           @OZ64248
         SPACE 1                                               @OZ64248
RCCUNJCM OI    RCARDLRC,LRC1ONUL+RDLMSKIP  WRITE NULL/OUTPUT   @OZ64248
         BAL   RL1,RPUT             CARD TO JCL FILE           @OZ64248
         OI    RCARDLRC,LRC1CCTL+LRC1TASA  SET ASA CAR. CTL    @OZ64248
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE          @OZ64248
         MVI   0(RPI),C'*'         FILL OUT CARD IMAGE         @OZ64248
         MVC   1(78,RPI),0(RPI)     WITH ASTERISKS             @OZ64248
         MVI   79(RPI),C' '        ADD TRAILING BLANK          @OZ64248
         MVC   (79-30)/2(30,RPI),RCCINVLD+4  COPY ERROR MSG    @OZ64248
         BAL   RL1,RPUT            ADD ERR. MSG TO OUTPUT FILE @OZ64248
         SPACE 1                                               @OZ64248
        $WTO   RCCINVLD,L'RCCINVLD,JOB=YES,         ISSUE ERR. @OZ64248X
               ROUTE=$LOG+$UR,CLASS=$TRIVIA,PRI=$ST  MESSAGE   @OZ64248
         SPACE 1                                               @OZ64248
         BAL   RL1,RJOBKILL        ELSE, KILL JOB              @OZ64248
         LA    RL2,RFLTEST         POINT TO ERROR EXIT         @OZ64248
        $RETURN                     AND RETURN                 @OZ64248
         EJECT ,                                               @OZ64248
RSPECARD LTR   JCT,JCT             SPECIAL JECL WITHIN JOB...  @OZ75603
         BZ    RILLCCRD            IGNORE CARD IF NOT IN JOB   @OZ75603
         TM    RDRSW,RJCLSW        ARE WE IN JCL MODE...       @OZ80882
         BO    RNULCARD            YES, BYPASS INPUT TERM      @OZ80882
         BAL   R5,RPUT             TERMINATE INPUT DATASET     @OZ80882
         OI    RDRSW,RJCLSW        ENSURE JCL MODE             @OZ80882
         SPACE 1                                               @OZ75603
RNULCARD MVC   JCTWORK(79),0(RPI)  CONVERT /*JECL CARD         @OZ80882
         MVC   1(79,RPI),JCTWORK     TO //* CARD               @OZ75603
         OI    RCARDLRC,LRC1ONUL   SET NULL-ON-OUTPUT          @OZ75603
         LA    RL2,RFLTEST         SET RETURN ADDRESS          @OZ75603
         B     RCCEXIT              AND RETURN                 @OZ75603
         SPACE 1                                               @OZ75603
RILLCCRD LA    RL2,RNOTCCRD        LOAD NORMAL RETURN ADDRESS  @OZ75603
         SPACE 1                                               @OZ75603
RCCEXIT  DS    0H                                              @OZ75603
        $RETURN                     AND RETURN
         SPACE 10
         SPACE 3                                               @OZ75603
*                             CONTROL CARD SCAN CONSTANTS
*
         SPACE 3
RH10     DC    H'10'               CONSTANT
ROCTID   DC    CL4'OCT'            OCT IDENTIFIER
RANY     DC    CL4'ANY'            SYSTEM AFFINITY CONSTANTS
RIND     DC    CL4'IND'            *
RSTAR    DC    CL2'*'              *
RPRINT   DC    CL6'PRINT'          ROUTE CONSTANTS
RPUNCH   DC    CL6'PUNCH'          *
RRMT     DC    CL3'RMT'            *                                 R4
         SPACE 3                                                     R4
RCOMASK  $WTO  ,69,MF=LX,TYPE=SVC34,JOB=NO,ROUTE=B'1100000000000000' R4
         EJECT                                                       R4
*
*                             OPERATOR AND ERROR MESSAGES
*
         SPACE 3
RCOMMSG  $MSG  120                 COMMAND MESSAGE NUMBER
RRILEGAL $MSG  111,'-- INVALID /*ROUTE CARD '
ROUTCODE EQU   *-13,7              /*ROUTE EBCDIC CONSTANT
RSETHMSG $MSG  102,'HELD FOR THE FOLLOWING VOLUME(S) --'
RSETMSG  $MSG  103                 SETUP MESSAGE NUMBER
RMSGMSG  $MSG  104                 MESSAGE MESSAGE NUMBER            R4
RJINVLID $MSG  112,'-- INVALID /*JOBPARM CARD '                      R4
ROINVLID $MSG  113,'-- INVALID /*OUTPUT CARD '                       R4
RCCINVLD $MSG  118,'-- INVALID /* CONTROL STATEMENT '          @OZ64248
         SPACE 5                                                     R4
         DROP  BASE3               DROP SEGMENT ADDRESSABILITY       R4
         TITLE 'HASP INPUT SERVICE -- DD * AND DD DATA SCAN ROUTINE' R4
HASPRDRO CSECT                     DEFINE SUBROUTINE CSECT           R4
HASPRDDS $ENTRY                    DEFINE DD*/DATA SCAN OVERLAY      R4
         CLI   5(RW),C' '          TEST NEXT COLUMN                  R4
         BE    RDDSCN14            BRANCH IF NO KEYWORD PARAMETERS   R4
         CLI   5(RW),C','          TEST AGAIN                        R4
         BNE   RDDSCER             BRANCH IF NOT BLANK OR COMMA      R4
         LA    R14,1               RESTORE SCAN INCREMENT            R4
         BCTR  RW,0                PREPARE TO SCAN REST OF DD CARD   R4
         SPACE 2                                                     R4
RDDSCAN1 LA    R15,64(,RPI)        SET LIMIT FOR DD CARD SCAN        R4
         SPACE 1                                                     R4
RDDSCAN2 CLI   6(RW),C' '          SEARCH FOR END OF CARD            R4
         BE    RDDSCN12            BRANCH IF BLANK ENCOUNTERED       R4
         BXH   RW,R14,RDDSCN12     ADVANCE TO NEXT COLUMN            R4
         CLC   RDDSCDLM,1(RW)      TEST FOR DLM KEYWORD              R4
         BNE   RDDSCAN2            BRANCH IF NOT DLM KEYWORD         R4
         CLI   5(RW),C','          TEST FIRST CHARACTER              R4
         BE    RDDSCAN2            IGNORE DLM IF COMMA               R4
         LA    RW,1(,RW)           ADVANCE TO NEXT COLUMN            R4
         CLI   4(RW),C''''         TEST FOR APOSTROPHE               R4
         BNE   RDDSCAN9            BRANCH IF NOT APOSTROPHE          R4
         BXH   RW,R14,RDDSCN15     ADVANCE TO NEXT COLUMN            R4
         LH    R0,4(,RW)           GET TENATIVE DELIMITER            R4
         CLI   4(RW),C'&&'         TEST FIRST CHARACTER              R4
         BNE   RDDSCAN3            BRANCH IF NOT AMPERSAND           R4
         CLI   5(RW),C'&&'         TEST NEXT CHARACTER               R4
         BNE   RDDSCAN6            BRANCH IF NOT DOUBLE AMPERSAND    R4
         CLI   6(RW),C''''         TEST NEXT CHARACTER               R4
         BNE   RDDSCAN4            BRANCH IF NOT APOSTROPHE          R4
         CLI   7(RW),C''''         TEST NEXT CHARACTER               R4
         BE    RDDSCAN4            BRANCH IF DOUBLE APOSTROPHE       R4
         SPACE 1                                                     R4
RDDSCAN3 CLI   4(RW),C''''         TEST FIRST CHARACTER              R4
         BNE   RDDSCAN5            BRANCH IF NOT APOSTROPHE          R4
         CLI   5(RW),C''''         TEST NEXT CHARACTER               R4
         BNE   RDDSCN15            ILLEGAL IF NOT APOSTROPHE         R4
         SPACE 1                                                     R4
RDDSCAN4 BXH   RW,R14,RDDSCN15     SKIP OVER REDUNDANT CHARACTER     R4
         IC    R0,5(,RW)           REPLACE 2ND CHARACTER OF DLM      R4
RDDSCAN5 CLI   5(RW),C'&&'         TEST SECOND CHARACTER             R4
         BNE   RDDSCAN6            BRANCH IF NOT AMPERSAND           R4
         CLI   6(RW),C'&&'         TEST NEXT CHARACTER               R4
         BE    RDDSCAN7            BRANCH IF SECOND AMPERSAND        R4
         SPACE 1                                                     R4
RDDSCAN6 CLI   5(RW),C''''         TEST SECOND CHARACTER             R4
         BNE   RDDSCAN8            BRANCH IF NOT APOSTROPHE          R4
         CLI   6(RW),C''''         TEST NEXT CHARACTER               R4
         BNE   RDDSCN15            ILLEGAL IF NOT APOSTROPHE         R4
         SPACE 1                                                     R4
RDDSCAN7 BXH   RW,R14,RDDSCN15     SKIP OVER REDUNDANT CHARACTER     R4
         SPACE 1                                                     R4
RDDSCAN8 CLI   6(RW),C''''         TEST FOR TERMINATING APOSTROPHE   R4
         BNE   RDDSCN15            IGNORE IF INVALID SYNTAX          R4
         LA    RW,1(,RW)           ADVANCE TO NEXT COLUMN            R4
         B     RDDSCN10            TEST NEXT CHARACTER               R4
         SPACE 3                                                     R4
RDDSCAN9 CLI   5(RW),C' '          TEST SECOND CHARACTER             R4
         BE    RDDSCN15            ILLEGAL IF BLANK                  R4
         CLI   5(RW),C','           OR                               R4
         BE    RDDSCN15              COMMA                           R4
         LH    R0,4(,RW)           GET DELIMITER                     R4
RDDSCN10 CLI   6(RW),C' '          TEST NEXT CHARACTER               R4
         BE    RDDSCN11            ILLEGAL IF NOT BLANK              R4
         CLI   6(RW),C','           OR                               R4
         BNE   RDDSCN15              COMMA                           R4
         SPACE 1                                                     R4
RDDSCN11 STH   R0,RDRDLM           SET DELIMITER SPECIFIED           R4
         OI    RCARDLRC,RDLMSKIP   BYPASS DLM TEST                   R4
         B     RDDSCAN2            CONTINUE SCAN                     R4
         SPACE 3                                                     R4
RDDSCN12 CLI   5(RW),C','          TEST LAST CHARACTER               R4
         BNE   RDDSCN14            BRANCH IF NOT A COMMA             R4
         BAL   RL1,RCONTNUE        GET CONTINUATION CARD             R4
         B     RDDSCN16            ILLEGAL CONTINUATION +0     @OZ73741
         B     RDDSCAN1            SCAN NEXT CARD                    R4
         SPACE 3                                                     R4
RDDSCN13 BAL   RL1,RCONTNUE        GET CONTINUATION CARD             R4
         B     RDDSCN16            ILLEGAL CONTINUATION +0     @OZ73741
         SPACE 2                                                     R4
RDDSCN14 CLI   71(RPI),C' '        TEST COLUMN 72                    R4
         BNE   RDDSCN13            BRANCH IF CONTINUATION INDICATED  R4
         B     RDDSCEND            PROCESS DD CARD                   R4
         SPACE 1                                               @OZ73741
RDDSCN16 NI    RDRSW,255-RNOSCAN   RESET EFFECT OF DD DATA     @OZ73741
         LA    RL2,RINVCONT        LOAD RETURN ADDRESS         @OZ73741
         B     RDDRETN             BRANCH TO RETURN            @OZ73741
         EJECT                                                 @OZ73741
RDDSCN15 NI    RDRSW,255-RNOSCAN   RESET EFFECT OF DD DATA           R4
         SPACE 2                                                     R4
RDDSCEND LTR   JCT,JCT             TEST FOR JOB                      R4
         BZ    RDDRESET            BRANCH IF FLUSHING                R4
         TM    RDRSW,RSYSINSW      TEST FOR GENERATED DD *           R4
         BZ    SKIP130             BRANCH IF NOT                     R4
         OI    RCARDLRC,LRC1ONUL   INDICATE INTERNALLY GENERATED     R4
SKIP130  BAL   RL1,RPUT            ADD CARD TO OUTPUT FILE           R4
         TM    RDRSW2,RTPCPY       TEST TYPRUN=COPY FLAG.      @OZ48524
         BO    RPDBNXEQ            PROCESS DD AS DATA CARD.    @OZ48524
         NI    RDRSW,255-RJCLSW    RESET JCL SWITCH                  R4
         SPACE 2                                                     R4
         USING SCRTEXT,RPI         SET ADDRESSABILITY TO SCR         R4
         ST    RPI,RSAVE2          SAVE ADDRESS OF CURRENT CARD      R4
         LA    RPI,RMESSAGE        GET ADDRESS OF CONTROL RECORD     R4
         MVI   SCRIRCFM,DCBRECF    SET UP CONTROL RECORD             R4
         MVC   SCRILRCL,RCARDLRL   SET RECORD LENGTH                 R4
         TM    RINFLAG1,LRC1CCTL   TEST RECORD CHARACTERISTICS       R4
         BZ    RCRNOCTL            BRANCH IF NO CARRIAGE CONTROL     R4
         OI    SCRIRCFM,DCBRECCA   ASSUME ASA CARRIAGE CONTROL       R4
         TM    RINFLAG1,LRC1TASA   TEST CARRIAGE CONTROL TYPE        R4
         BO    SKIP140             BRANCH IF ASA                     R4
         XI    SCRIRCFM,DCBRECCA+DCBRECCM  NO, MUST BE MACHINE       R4
SKIP140  SLR   R1,R1               ZERO FOR NEXT INSTRUCTION         R4
         IC    R1,SCRILRCL         INCREMENT                         R4
         LA    R1,1(,R1)            LOGICAL RECORD LENGTH            R4
         STC   R1,SCRILRCL           TO INCLUDE CARRIAGE CONTROL     R4
         SPACE 1                                                     R4
RCRNOCTL LH    R1,JCTPDDBK         GET DATA SET NUMBER               R4
         LA    R1,1(,R1)           INCREMENT                         R4
         STH   R1,JCTPDDBK         UPDATE DATA SET NUMBER            R4
         STCM  R1,3,SCRIDSKY       SET IN CONTROL RECORD             R4
         BAL   RL2,RTRACK          GET TRACK ADDR FOR 1ST DATA BLOCK R4
         STCM  R1,15,SCRIMTTR      SAVE TRACK ADDR IN CONTROL RECORD R4
         MVI   SCRITERM,X'FF'      TERMINATE                         R4
         MVC   SCRIBLNK,RKBLANKS     CONTROL RECORD                  R4
         OI    RCARDLRC,LRC1INUL+LRC1ONUL+RDLMSKIP  INDICATE CONTROL R4
         MVC   SCRISAVE,RCARDLRL   SAVE RECORD LENGTH                R4
         MVI   RCARDLRL,9          SET CONTROL RECORD LENGTH         R4
         BAL   RL1,RPUT            ADD CONTROL RECORD TO OUTPUT FILE R4
         MVC   RCARDLRL,SCRISAVE   RESTORE RECORD LENGTH             R4
         SPACE 1                                                     R4
         OI    RCARDLRC,RDLMSKIP   FORCE SYSIN COUNT BYPASS          R4
         MVC   RBOEND,RBONEXT      FORCE END-OR-BUFFER               R4
         DROP  RPI                                                   R4
         L     RPI,RSAVE2          RESTORE ADDR OF CURRENT CARD      R4
         BAL   RL1,RPUT            TERMINATE BUFFER                  R4
         L     R1,RDROBUF          RESET                             R4
         LA    RW,ROBUFST(,R1)      OUTPUT                           R4
         ST    RW,RBONEXT            POINTER                         R4
         MVC   RJCLTRAK,RBUFTRK(R1)  SAVE NEXT JCL TRACK ADDRESS     R4
         USING SCRTEXT,RL1         SET ADDRESSIBILITY FOR SCR        R4
         LA    RL1,RMESSAGE        GET ADDRESS OF SCR RECORD         R4
         MVC   RBUFTRK(,R1),SCRIMTTR   SET DATA BLOCK TRACK ADDRESS  R4
         EJECT                                                 @OZ65152
         L     RW,RDRIOT2          FIND LAST IOT               @OZ65152
         USING IOTDSECT,RW         SET IOT ADDRESSABILITY      @OZ65152
         L     R1,IOTPDDBP         GET PDDB DISPLACEMENT       @OZ65152
         LA    RL2,PDBLENG(,R1)    COMPARE NEW DISPLACEMENT    @OZ65152
         CH    RL2,IOTLENG            WITH MAXIMUM             @OZ65152
         BNH   RPDDBBLD            BRANCH IF ROOM IN IOT       @OZ65152
         SPACE 1                                               @OZ65152
         LH    R1,RDRIOTCT         GET CURRENT COUNT OF IOTS   @OZ65152
         LA    R1,1(,R1)           UP IT BY ONE                @OZ65152
         CH    R1,$NUMBUF          COMPARE TO TOTAL BUFFERS    @OZ65152
         BNL   RDKILL              TOO MANY BUFFERS, KILL JOB  @OZ65152
         STH   R1,RDRIOTCT         ELSE SAVE NEW COUNT         @OZ65152
         BAL   RL2,RTRACK          GET TRACK ADDR FOR NEW IOT  @OZ65152
         ST    R1,IOTIOTTR         SET IOT CHAIN TRACK ADDR.   @OZ65152
         C     RW,RDRIOT           IF CURRENT IOT NOT FIRST,   @OZ65152
         BNE   RPDBIO               DON'T WAIT FOR I/O END     @OZ65152
         SPACE 1                                               @OZ65152
RPDBIOC  CLI   BUFECBCC-BUFDSECT(RW),0  TEST I/O STATUS        @OZ65152
         BNE   RPDBIO              BRANCH IF I/O NOT ACTIVE    @OZ65152
        $WAIT  IO                  OR WAIT FOR I/O COMPLETE    @OZ65152
         B     RPDBIOC             GO BACK AND TRY AGAIN       @OZ65152
         SPACE 1                                               @OZ65152
RPDBIO   ST    RW,PCEBUFAD         SET BUFFER ADDRESS          @OZ65152
         MVC   PCESEEK,IOTTRACK      AND TRACK ADDRESS         @OZ65152
         LA    R1,PCEDADCT         GET DIRECT-ACCESS DCT ADDR  @OZ65152
         ST    R13,PCEIOEWF        TELL CH-END NOT TO FREE     @OZ65152
        $EXCP (R1),WAIT=YES        WRITE OUT THE CURRENT IOT   @OZ65152
         XC    PCEIOEWF,PCEIOEWF   ALLOW FREE OTHER BUFFERS    @OZ65152
         SPACE 1                                               @OZ65152
         L     RL2,IOTIOTTR        SAVE CHAIN POINTER          @OZ65152
         CLC   RDRIOT,RDRIOT2      IF LAST IOT NOT SAME AS     @OZ65152
         BNE   RPDBFMT                 FIRST, JUST FORMAT IT   @OZ65152
        $GETBUF WAIT=YES           GET BUFFER FOR NEW IOT      @OZ65152
         LR    RW,R1               SET ADDRESS OF NEW BUFFER   @OZ65152
         MVI   BUFECBCC-BUFDSECT(RW),X'7F' SIMULATE I/O END    @OZ67953
         ST    R1,RDRIOT2          SAVE ADDRESS OF NEW BUFFER  @OZ65152
         EJECT                                                 @OZ65152
RPDBFMT  LA    R0,IOTSTART         GET ADDRESS                 @OZ65152
         LH    R1,$BUFSIZE                 AND LENGTH OF IOT FIELDS  R4
         SLR   R15,R15             SET TO ZERO FOR CLEARING          R4
         MVCL  R0,R14               AND CLEAR THE IOT                R4
         L     R1,RDRIOT           GET ADDRESS OF 1ST IOT      @OZ65152
*              THIS LINE DELETED BY APAR OZ65152               @OZ65152
         MVC   IOTID(IOTTRACK-IOTID),IOTID-IOTDSECT(R1)  INITIALIZE  R4
         MVI   IOTFLAG1,0                                 NEW IOT    R4
         ST    RL2,IOTTRACK                          FROM OLD  @OZ65152
         L     R1,$IOTPDDB         SET DISPLACEMENT                  R4
         ST    R1,IOTPDDBP           OF FIRST AVAILABLE PDDB         R4
         SPACE 1                                                     R4
RPDDBBLD ALR   RW,R1               GET ADDRESS OF PDDB               R4
         USING PDBDSECT,RW         ESTABLISH PDDB ADDRESSABILITY     R4
         MVC   0(PDBLENG,RW),RPDBMODL  CONSTRUCT                     R4
         MVI   PDBFLAG1,PDB1NSOT        PDDB                         R4
         MVC   PDBRECFM,SCRIRCFM         FOR EACH                    R4
         MVC   PDBLRECL+1(1),SCRILRCL     INPUT                      R4
         MVC   PDBMTTR,SCRIMTTR            DATA SET                  R4
         DROP  RL1                                                   R4
         LH    R1,JCTPDDBK         GET DATA SET NUMBER               R4
         STH   R1,PDBDSKEY         SET DATA SET NUMBER IN PDDB       R4
         MVC   PDBCLASS,JCTMCLAS   SET CLASS TO MSGCLASS             R4
         MVC   PDBRECCT,JCTJOBIN   INITIALIZE CARD COUNT             R4
         MVC   PDBFORMS,JCTFORMS   INITIALIZE FORMS TO JOB FORMS     R4
         DROP  RW                  DROP PDDB ADDRESSABILITY          R4
         TM    PCEID,PCERJEID      TEST PROCESSOR TYPE         @OZ43908
         BZ    RPDBNRJE            BR IF NOT REMOTE TERMINAL   @OZ43908
         ST    RW,RDPDBSV          SAVE PDDB ADDR FOR LRECL    @OZ43908
RPDBNRJE DS    0H                                              @OZ43908
         STH   R1,RDRDSKEY         SET DATA SET KEY                  R4
         L     RW,RDROBUF          GET ADDRESS OF OUTPUT BUFFER      R4
         STH   R1,HDBPDDBK-BUFDSECT(,RW)  CORRECT FIRST DATA BUFFER  R4
RPDBNXEQ DS    0H                                              @OZ48524
         LA    RL2,RNXTCRD         SET UP EXIT                       R4
         B     RDDRETN              TO GET NEXT CARD                 R4
         SPACE 2                                                     R4
RDDSCER  NI    RDRSW,255-RNOSCAN   TURN ON CARD SCAN                 R4
         B     RDDFLTST             AND IGNORE STATEMENT             R4
         SPACE 2                                                     R4
RDDRESET NI    RDRSW,255-RJCLSW    RESET JCL SWITCH                  R4
RDDFLTST LA    RL2,RFLTEST         SET UP FLUSH EXIT                 R4
         B     RDDRETN             AND RETURN                  @OZ65152
         EJECT                                                 @OZ79019
RDKILL   TM    RDRSW,RSYSINSW      SYSTEM GEN DD CARD...       @OZ79019
         BO    RDDKILL             BRANCH IF YES               @OZ79019
         ST    RPI,RSAVE1          SAVE INPUT POINTER          @OZ79019
         SPACE 1                                               @OZ79019
RDDKILL  LA    RPI,RDRDLM          ADD DELIMITER CARD          @OZ79019
         BAL   RL1,RPUT            TO OUTPUT FILE              @OZ65152
         L     RPI,RSAVE1          RESTORE INPUT POINTER       @OZ65152
         MVC   RDRDLM,=CL2'/*'     SET INPUT DATASET DELIM     @OZ65152
         OI    RCARDLRC,LRC1CCTL+LRC1TASA SET ASA CAR CONTROL  @OZ65152
         OI    RDRSW,RJCLSW        RESET TO JCL FILE           @OZ65152
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE          @OZ65152
         MVI   0(RPI),C'*'         FILL OUT CARD IMAGE         @OZ65152
         MVC   1(78,RPI),0(RPI)     WITH ASTERISKS             @OZ65152
         MVI   79(RPI),C' '        ADD TRAILING BLANK          @OZ65152
         MVC   (79-28)/2(28,RPI),RDILEGAL+4 MOVE ERROR MSG     @OZ65152
         BAL   RL1,RPUT            ADD ERROR MSG TO OUTPUT     @OZ65152
        $WTO   RDILEGAL,L'RDILEGAL,JOB=YES,     ISSUE ERROR    @OZ65152*
               ROUTE=$LOG+$UR,CLASS=$ALWAYS,PRI=$ST  MESSAGE   @OZ65152
         BAL   RL1,RJOBKILL        KILL JOB                    @OZ65152
         LA    RL2,RFLTEST         LOAD ADDRESS OF EXIT        @OZ65152
RDDRETN $RETURN                                                @OZ65152
         EJECT                                                 @OZ65152
*                                                                    R4
*                             DD * AND DD DATA SCAN CONSTANTS        R4
*                                                                    R4
         SPACE 3                                                     R4
RDDSCDLM DC    CL4'DLM='           DLM KEYWORD                       R4
RDILEGAL $MSG  129,'-- EXCESS SYSIN DD STATEMENTS '            @OZ65152
         SPACE 5                                                     R4
         DROP  BASE3               DROP SEGMENT ADDRESSABILITY       R4
         TITLE 'HASP INPUT SERVICE -- JOB CARD SCAN ROUTINE'         R4
HASPRDRO CSECT                     DEFINE SUBROUTINE CSECT           R4
HASPRJCS $ENTRY                    DEFINE JOB CARD SCAN OVERLAY      R4
         ST    RW,RSAVE1           SAVE POINTER FOR JOB CARD SCAN    R4
         BAL   RL1,RJOBEND         TERMINATE PREVIOUS JOB            R4
         MVI   RDRSW2,0            ZERO JOB CARD SCAN SWITCHES       R4
         BAL   RL2,RGETBUF         GET A BUFFER FOR THE JCT
         L     JCT,RDROBUF         SET UP JCT ADDRESSABILITY         R4
         LA    R14,JCTSTART        GET ADDR OF START OF JCT FIELDS
         LH    R15,$BUFSIZE         AND LENGTH OF JCT FIELDS         R4
         SLR   R1,R1               SET TO ZERO FOR CLEARING
         MVCL  R14,R0               AND CLEAR THE JCT
         BAL   RL2,RGETBUF         GET A BUFFER FOR THE IOT
         L     RL1,RDROBUF         RL1 = ADDRESS OF IOT              R4
         ST    RL1,RDRIOT          SAVE ADDRESS OF IOT               R4
         ST    RL1,RDRIOT2         SET LAST IOT=FIRST IOT      @OZ65152
         XC    RDRIOTCT,RDRIOTCT   INITIALIZE IOT COUNT        @OZ65152
         USING IOTDSECT,RL1        ESTABLISH IOT ADDRESSABILITY
         LA    R14,IOTSTART        GET ADDR OF START OF IOT FIELDS
         LH    R15,$BUFSIZE         AND LENGTH OF IOT FIELDS         R4
         SLR   R1,R1               SET TO ZERO FOR CLEARING
         MVCL  R14,R0               AND CLEAR THE IOT
         OI    IOTMSTAB+(TABFLAG-TABDSECT),TABMASTR SHOW MASTER TAB  R4
        $TIME                      GET CURRENT TIME
         STM   R0,R1,JCTRDRON      SET JOB ENTRY TIME AND DATE
         SPACE 2
         MVC   JCTJNAME,2(RPI)     MOVE JOB NAME TO JCT
         MVI   JCTJNAME+8,C' '     ADD BLANK TO TERMINATE SCAN
         LA    RW,JCTJNAME-1       SET UP FOR SCAN
RJSETJN  LA    RW,1(,RW)           SCAN JOB NAME
         CLI   0(RW),C' '           FOR FIRST BLANK
         BNE   RJSETJN             BRANCH IF NOT BLANK
         MVC   1(7,RW),0(RW)       BLANK OUT REST OF JOB NAME
         XC    JCTJNAME+8(8),JCTJNAME+8 CLEAR SUPERFLUOUS BLANKS
         SPACE 2
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         L     R1,PCEDCT           GET ADDRESS OF READER DCT   @OZ32566
         USING DCTDSECT,R1         ESTABLISH DCT ADDRESSABILITY
         CLI   DCTJCLAS,CATSTCCL   TEST DEFAULT JOB CLASS
         BNE   RNOTSTC             BRANCH IF NOT STARTED TASK
         LH    RW,$STCNO           GET CURRENT STC NUMBER
         EJECT                                                       R4
RINCSTCN LA    RW,1(,RW)           INCREMENT
         CL    RW,R20000           COMPARE WITH MAXIMUM NUMBER
         BL    *+8                 BRANCH IF MAXIMUM NOT REACHED
         L     RW,R10001           OVERFLOW, RESET TO 10001
        $QLOC  (RW)                TEST FOR DUPLICATE NUMBER
         BNZ   RINCSTCN            BRANCH IF DUPLICATE
         STH   RW,$STCNO           UPDATE MASTER STC NUMBER
         MVC   RJOBVAR,RSTC        PRESET JOBID HEADER
         B     RCRJOBID            CREATE JOBID
         SPACE 1
RNOTSTC  CLI   DCTJCLAS,CATTSUCL   TEST DEFAULT JOB CLASS
         BNE   RNOTTSU             BRANCH IF NOT LOGON               R4
         LH    RW,$TSUNO           GET CURRENT LOGON NUMBER
         SPACE 1
RINCTSUN LA    RW,1(,RW)           INCREMENT
         CL    RW,R30000           COMPARE WITH MAXIMUM NUMBER
         BL    *+8                 BRANCH IF MAXIMUM NOT REACHED
         L     RW,R20001           OVERFLOW, RESET TO 20001
        $QLOC  (RW)                TEST FOR DUPLICATE NUMBER
         BNZ   RINCTSUN            BRANCH IF DUPLICATE
         STH   RW,$TSUNO           UPDATE MASTER LOGON NUMBER
         MVC   RJOBVAR,RTSU        PRESET JOBID HEADER
         B     RCRJOBID            CREATE JOBID
         SPACE 1
RNOTTSU  LH    RW,$JOBNO           GET CURRENT USER JOB NUMBER       R4
         SPACE 1
RINCJOBN LA    RW,1(,RW)           INCREMENT
         CL    RW,R10000           COMPARE WITH MAXIMUM NUMBER
         BL    *+8                 BRANCH IF MAXIMUM NOT REACHED
         LA    RW,1                OVERFLOW, RESET TO 1
        $QLOC  (RW)                TEST FOR DUPLICATE NUMBER
         BNZ   RINCJOBN            BRANCH IF DUPLICATE
         STH   RW,$JOBNO           UPDATE MASTER JOB NUMBER
         MVC   RJOBVAR,=CL4'JOB'   PRESET JOBID HEADER               R4
         DROP  R1                  DROP DCT ADDRESSABILITY
         SPACE 1
RCRJOBID CVD   RW,RTEMP            CONVERT JOB NUMBER TO DECIMAL     R4
         NI    RTEMP+5,X'0F'       FORCE JOB NUMBER MODULO 10000
         MVC   JCTJOBID,RMASK      SET EDIT MASK
         ED    JCTJOBID,RTEMP+4    CONVERT JOB NUMBER TO EBCDIC
         MVC   JCTJOBID(4),RJOBVAR SET JOBID HEADER
         EJECT                                                       R4
         XC    JCTWORK(JQELNGTH),JCTWORK  CLEAR JOB QUEUE ENTRY
         MVI   QUEPRIO+JCTWORK,X'FF'   SET FLUSH PRIORITY
         STH   RW,QUEJOBNO+JCTWORK     SET JOB NUMBER
         MVC   QUEFLAGS+JCTWORK,$SIDBUSY  SET BUSY INDICATION
         L     RW,PCEDCT           RW = ADDRESS OF INPUT DCT   @OZ32566
         MVC   RDRSIAFF,DCTSIAFF-DCTDSECT(RW)  INITIALIZE AFFINITY   R4
         CLI   JCTJOBID,C'J'       TEST JOBID                        R4
         BE    RNOIND              BRANCH IF NOT STC OR TSU          R4
         TM    $STATUS,$INDMODE    TEST SYSTEM STATUS                R4
         BZ    RNOIND              BRANCH IF NOT INDEPENDENT MODE    R4
         OI    RDRSIAFF,QUEINDAF   SET INDEPENDENT AFFINITY          R4
         SPACE 1                                                     R4
RNOIND   MVC   QUEFLAG2+JCTWORK,RDRSIAFF  INITIALIZE AFFINITY        R4
        $TRACK IOTMSTAB            GET TRACK ADDRESS FOR JCT         R4
         ST    R1,QUETRAK+JCTWORK  SET JCT TRACK ADDRESS
         MVC   QUEDEVID+JCTWORK,DCTDEVID-DCTDSECT(RW)  SET DEVICE ID
         MVC   QUEJNAME+JCTWORK,JCTJNAME  MOVE JOB NAME TO JQE
         MVC   QUEPUNRT+JCTWORK,DCTNO-DCTDSECT(RW) SET INPUT RT     R41
         SPACE 2
RJOBQUE $QADD  JCTWORK,$INPUT      ADD JOB QUEUE ENTRY
         BNZ   RJCTINIT            BRANCH IF QUEUE IS NOT FULL
        $WAIT  JOB                 WAIT FOR A JOB QUEUE ELEMENT
         B     RJOBQUE             TRY AGAIN
         SPACE 2
RJCTINIT ST    R1,PCEJQE           SAVE JQE ADDRESS            @OZ32566
         SPACE 1                                                     R4
RJCTINT1 MVC   JCTID,RJCTID        SET JCT NAME                      R4
         LH    R1,$BUFLENG         SET BLOCK                         R4
         STH   R1,JCTLENG           LENGTH
         SPACE 2
         L     R1,$DATAKEY         GET MASTER PERIPHERAL DATA SET KEY
         AL    R1,RONE             INCREMENT
         STCK  RTEMP               STORE CLOCK
         BC    7,RSETKEY           BRANCH IF CLOCK IS NOT VALID
         CL    R1,RTEMP            COMPARE CLOCK WITH KEY
         BNL   RSETKEY             BRANCH IF CLOCK IS NOT GREATER
         L     R1,RTEMP            USE CLOCK AS DATA SET KEY
RSETKEY  ST    R1,$DATAKEY         UPDATE MASTER DATA SET KEY
         ST    R1,JCTJBKEY         STORE AS JOB KEY IN JCT
         MVI   JCTCNVRC+3,JCTCABND PRESET CONVERTER RETURN CODE
         EJECT                                                       R4
        $TRACK IOTMSTAB            GET TRACK ADDRESS FOR IOT         R4
         ST    R1,JCTIOT           SET TRACK ADDRESS OF 1ST IOT
         L     R1,PCEJQE           GET JQE ADDRESS             @OZ32566
         SL    R1,$JOBQPTR         GENERATE RELATIVE ADDRESS
         ST    R1,JCTJQE           SET OFFSET OF JOB QUEUE ENTRY
         LA    R1,100              INITIALIZE
         STH   R1,JCTPDDBK          PDDB KEY
         CLI   RPRIORTY+1,C' '     TEST FOR PRIORITY CARD            R4
         BE    *+8                 BRANCH IF NOT
         OI    JCTJBOPT,JCTPRICD   INDICATE PRIORITY CARD
         MVC   JCTPRTY,RPRIORTY    MOVE PRIORITY OR BLANKS TO JCT    R4
         L     R1,PCEDCT           R1 = ADDRESS OF INPUT DCT   @OZ32566
         USING DCTDSECT,R1         ESTABLISH DCT ADDRESSABILITY
         MVI   JCTPNAME,C' '                     SET PGMR NAME       R4
         MVC   JCTPNAME+1(L'JCTPNAME-1),JCTPNAME  FLD TO BLANKS      R4
         MVC   JCTMCLAS,DCTMCLAS   SET DEFAULT MESSAGE CLASS
         MVC   JCTJCLAS,DCTJCLAS   SET DEFAULT JOB CLASS
         MVC   JCTCLASS,JCTJCLAS   SET DEFAULT CLASS IN JMR
         MVI   JCTIPRIO,C'*'       SET PRIORITY CHARACTER            R4
         MVC   JCTROUTE,DCTNO      SET INPUT ROUTE CODE
         MVC   JCTINDEV,DCTDEVN    SET INPUT DEVICE NAME
         LH    RW,$ESTIME          SET                               R4
         ST    RW,JCTETIME          DEFAULT                          R4
         LH    RW,$ESTLNCT           ESTIMATED                       R4
         ST    RW,JCTESTLN            EXECUTION TIME,                R4
         L     RW,$ESTPUN              LINE AND                      R4
         ST    RW,JCTESTPU              PUNCH OUTPUTS                R4
         CLI   JCTJOBID,C'J'       TEST JOB TYPE                     R4
         BE    SKIP200             BRANCH IF NOT STC OR TSU LOGON    R4
         MVC   JCTETIME(12),RSTUETIM  SET STC/TSU ESTIMATES          R4
         CLC   JCTJNAME,RLOGNAME   IS THIS STC 'SYSLOG'        @OZ43877
         BNE   SKIP200             BR IF NOT                   @OZ43877
         MVC   JCTETIME(12),RLOGETIM  SET SYSLOG ESTIMATES     @OZ43877
SKIP200  MVC   JCTFORMS,$STDFORM   SET STANDARD FORMS                R4
         MVI   JCTCPYCT,1          SET DEFAULT COPY COUNT            R4
         MVC   JCTLINCT,$LINECT    SET DEFAULT PAGE LINE COUNT       R4
         MVC   JCTPROUT,DCTPRINT   SET PRINT AND
         MVC   JCTPUOUT,DCTPUNCH    PUNCH ROUTE CODES
*              THIS LINE DELETED BY APAR                       @OZ38058
         MVC   JCTJMRJN,JCTJNAME   SET JMR JOB NAME
         MVC   JCTRDSID,$SID       SAVE SYSTEM ID FOR SMF TYPE 26
         MVC   JCTCPUID,$SID       SET JMR CPU ID FOR SMF EXITS
         MVC   JCTUSEID,RKBLANKS   BLANK OUT JMR USER IDENTIFICATION
         MVC   JCTINDC,DCTINDC     SET JMR SMF OPTIONS FROM DCT
         TM    PCEID,PCEINRID      TEST PROCESSOR TYPE
         BO    RSETINDC            BRANCH IF INTERNAL READER
         CLI   PCEID+1,PCEXEQID    TEST PROCESSOR TYPE
         BE    RSETINDC            BRANCH IF EXECUTION PROCESSOR
         TM    PCEID,PCERJEID      TEST PROCESSOR TYPE               R4
         BZ    RSETDVTP            BRANCH IF NOT REMOTE TERMINAL     R4
         TM    MDCTTYPE,DCTPSNA    CHECK FOR SNA REMOTE              R4
         BO    RSETINDC            BRANCH IF SNA REMOTE              R4
         L     R1,DCTDCB-DCTDSECT(,R1)  GET ADDRESS OF LINE DCT
RSETDVTP L     R15,DCTDCB          GET ADDRESS OF DCB                R4
         L     R15,DCBDEBAD-DCBDSECT(,R15)   GET ADDRESS OF DEB
         L     R15,DEBSUCBA-DEBDSECT(,R15)   GET ADDRESS OF UCB
         MVC   JCTRDR,UCBTYP+2-UCBDSECT(R15) SET READER DEVICE TYPE
         EJECT                                                       R4
RSETINDC MVC   JCTJMOPT,JCTINDC    SET SMF OPTIONS IN JMR
         MVC   IOTID,RIOTID        SET IOT NAME
         LH    RW,$BUFLENG         GET LENGTH OF IOT                 R4
         STH   RW,IOTLENG           AND STORE IN IOT
         MVI   IOTFLAG1,IOT1ALOC   SET UP IOT FLAGS
         MVC   IOTJBKEY,JCTJBKEY   MOVE JOB KEY FROM JCT TO IOT
         MVC   IOTTRACK,JCTIOT     MOVE IOT TRACK ADDRESS TO IOT
         L     R1,$IOTPDDB         GET OFFSET OF 1ST PDDB            R4
         LA    RW,IOTPDBOD(,R1)    SET DISPLACEMENT                  R4
         ST    RW,IOTPDDBP          OF FIRST AVAILABLE PDDB          R4
         ALR   R1,RL1              POINT TO 1ST PDDB IN IOT          R4
         MVC   0*PDBLENG(1*PDBLENG,R1),RPDBMODL  INITIALIZE          R4
         MVC   1*PDBLENG(2*PDBLENG,R1),0(R1)      FIRST              R4
         MVC   3*PDBLENG(2*PDBLENG,R1),0(R1)       SIX               R4
         MVC   5*PDBLENG(1*PDBLENG,R1),0(R1)        PDDB'S           R4
         MVI   PDBFLAG1+0-PDBDSECT+IOTPDBOJ(R1),PDB1LOG  SET         R4
         MVI   PDBRECFM+0-PDBDSECT+IOTPDBOJ(R1),DCBRECF   UP         R4
         MVI   PDBLRECL+1-PDBDSECT+IOTPDBOJ(R1),80         JCL       R4
         MVI   PDBDSKEY+1-PDBDSECT+IOTPDBOJ(R1),PDBINJCL    PDDB     R4
         OI    PDBFLAG1+0-PDBDSECT+IOTPDBOL(R1),PDB1LOG        SET   R4
         MVI   PDBRECFM+0-PDBDSECT+IOTPDBOL(R1),DCBRECU+DCBRECCM UP  R4
         MVI   PDBLRECL+1-PDBDSECT+IOTPDBOL(R1),133         JOB LOG  R4
         MVI   PDBDSKEY+1-PDBDSECT+IOTPDBOL(R1),PDBOUHJL        PDDB R4
         MVI   PDBRECFM+0-PDBDSECT+IOTPDBOI(R1),DCBRECF  SET UP      R4
         MVI   PDBLRECL+1-PDBDSECT+IOTPDBOI(R1),90        JCL IMAGES R4
         MVI   PDBDSKEY+1-PDBDSECT+IOTPDBOI(R1),PDBOUJCI   PDDB      R4
         MVI   PDBRECFM+0-PDBDSECT+IOTPDBOM(R1),DCBRECV+DCBRECCA SET R4
         MVI   PDBLRECL+1-PDBDSECT+IOTPDBOM(R1),133    UP SYS  @OZ68823
         MVI   PDBDSKEY+1-PDBDSECT+IOTPDBOM(R1),PDBOUMSG   MSGS PDDB R4
         OI    PDBFLAG1+0-PDBDSECT+IOTPDBOT(R1),PDB1NSOT  SET UP INT R4
         MVI   PDBDSKEY+1-PDBDSECT+IOTPDBOT(R1),PDBINTXT   TEXT PDDB R4
         OI    PDBFLAG1+0-PDBDSECT+IOTPDBON(R1),PDB1NSOT  SET UP JOB R4
         MVI   PDBDSKEY+1-PDBDSECT+IOTPDBON(R1),PDBINJNL   JNL PDDB  R4
         CLI   PCEID+1,PCEXEQID    TEST PROCESSOR TYPE
         BE    RJOBRET             BRANCH IF EXECUTION PROCESSOR
         MVC   RDRDSKEY,RONE+2     SET JCL DATA KEY
        $TRACK IOTMSTAB            GET TRACK ADDR FOR 1ST JCL BLOCK  R4
         LR    RW,R1               RW = FIRST TRACK ADDRESS
         BAL   RL2,RGETBUF         GET FIRST OUTPUT BUFFER
         L     R1,$IOTPDDB         GET OFFSET OF 1ST PDDB            R4
         ST    RW,PDBMTTR-PDBDSECT+IOTPDBOJ(R1,RL1)  SET JCL TRACK   R4
         SPACE 2
         ST    JCT,PCEBUFAD        SET JCT BUFFER ADDRESS
         MVC   PCESEEK,QUETRAK+JCTWORK  SET JCT TRACK ADDRESS
         ST    SAVE,PCEIOEWF       PREVENT BUFFER RELEASE
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE OF JCT
         ST    RL1,PCEBUFAD        SET IOT BUFFER ADDRESS
         MVC   PCESEEK,IOTTRACK    SET IOT TRACK ADDRESS
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE OF IOT
         SLR   R1,R1               RESET DIRECT-ACCESS
         ST    R1,PCEIOEWF          EVENT WAIT FIELD
         DROP  RL1                 DROP IOT ADDRESSABILITY
         SPACE 2
         MVC   72(8,RPI),JCTJOBID  SET HASP JOB ID IN COLS 73-80
         TM    PCEID,PCEINRID      IS THIS AN INTERNAL READER
         BZ    RJOBSCAN            BRANCH IF NOT
         OI    JCTJBOPT,JCTINRDR   INDICATE INTERNAL READER
         L     R1,PCEDCT           R1 = ADDRESS OF INPUT DCT   @OZ32566
         MVC   RIDJOBID(3),72(RPI)      SET JOB NUMBER IN DCT
         PACK  RTEMP(3),75(5,RPI)        CHANGING
         UNPK  RIDJOBID+3(5),RTEMP(3)     BLANKS TO ZEROS
         DROP  R1                  DROP DCT ADDRESSABILITY
         SPACE 2
RJOBSCAN L     RW,RSAVE1           RESTORE POINTER FOR JOB CARD SCAN
         NI    RPASPROC,255-$RPASFND-$RJOBERR-$RJOBECD-$RJOBFND        *
                                   SET PASSWORD PROCESS FIELD  @OZ38384
         NI    RPASPROC,255-$RPSWCNT  RESET PSWD CONTINUE FLAG @OZ61577
         OI    RPASPROC,$RJOBFND   JOB CARD BEING PROCESSED    @OZ38384
         LA    R14,1               SET INCREMENT
         LA    R15,65(,RPI)         AND LIMIT FOR SCAN
         LA    R1,JCTWORK-1        ASSUME
         ST    R1,RSAVE1            NO ACCOUNTING FIELD
         BXH   RW,R14,RJOBCONT     FIND                        @OZ75242
         CLI   6(RW),C' '           START OF
         BE    *-8                   ACCOUNTING FIELD
         SPACE 2
         LA    R0,L'JCTWORK        GET LENGTH OF ACCOUNTING FIELD AREA
         LA    R1,JCTWORK          GET ADDRESS OF ACCOUNTING FIELD AREA
         BAL   RL1,RJSCAN          SCAN ACCOUNTING FIELD
         BCT   R1,RJOBACCT         LEGITIMATE ACCOUNTING FIELD
         BCT   RW,RJOBSRCH         SCAN KEYWORDS
         SPACE 2
RJOBACCT ST    R1,RSAVE1           SAVE END ADDRESS FOR LATER SCAN
         LA    R0,L'JCTPNAME       GET LENGTH OF PROGRAMMER NAME AREA
         LA    R1,JCTPNAME         GET ADDRESS OF PROGRAMMER NAME AREA
         LA    RL1,RJSCAN          SCAN PROGRAMMER NAME
         BALR  RL1,RL1              INDICATING APOSTROPHE COMPRESSION
         B     RJOBKYWD            BR IF VALID PROGRAMMER NAME FIELD R4
         MVI   JCTPNAME,C' '                     RESET PGMR NAME     R4
         MVC   JCTPNAME+1(L'JCTPNAME-1),JCTPNAME  FLD TO BLANKS      R4
         SPACE 1                                                     R4
RJOBKYWD BCTR  RW,0                BACK UP ONE CHARACTER             R4
         SPACE 2
RJOBSRCH BCTR  RW,0                BACK UP
         BCTR  RW,0                 TWO CHARACTERS
         LA    R15,62(,RPI)        SET NEW END-OF-CARD LIMIT         R4
         SPACE 1                                                     R4
RJOBKEY  CLI   8(RW),C' '          TEST CURRENT CHARACTER
         BE    RJOBLANK            BRANCH IF BLANK
         CLI   8(RW),C'='          TEST CURRENT CHARACTER
         BNE   RJOBINCR            BRANCH IF NOT EQUAL
         SPACE 2
         CLC   3(5,RW),RCLASS      TEST KEYWORD
         BNE   RJOBTYPR            BRANCH IF NOT 'CLASS'
         CLI   9(RW),C'A'          TEST NEXT CHARACTER               R4
         BL    RJOBINCR            IGNORE IF NOT LEGAL CLASS         R4
         SR    R1,R1               CLEAR REGISTER              @OZ48782
         IC    R1,9(,RW)           GET JOB CLASS               @OZ48782
         AL    R1,=A(RDCAT)        GET ADDRESS OF CLASS TABLE  @OZ48782
         ICM   R1,1,0(R1)          IS CLASS VALID...           @OZ48782
         BZ    RJOBINCR            BRANCH IF INVALID CLASS     @OZ48782
         CLC   0(3,RW),RMSG        TEST KEYWORD
         BE    RJOBMSGC            BRANCH IF 'MSGCLASS'
         CLI   2(RW),C' '          CHECK PREVIOUS CHARACTER    @OZ80227
         BE    RJOBCLAS              FOR BLANK OR COMMA TO     @OZ80227
         CLI   2(RW),C','              INSURE VALID KEYWORD    @OZ80227
         BNE   RJOBINCR            IGNORE IF KEYWORD INVALID   @OZ80227
         SPACE 1                                               @OZ80227
RJOBCLAS CLI   JCTJCLAS,CATSTCCL   IF STARTED TASK,            @OZ80227
         BE    RJOBINCR             OR                         @OZ44737
         CLI   JCTJCLAS,CATTSUCL     TSU LOGON,                @OZ44737
         BE    RJOBINCR               IGNORE CLASS PARAMETER   @OZ44737
         MVC   JCTJCLAS,9(RW)      SET JOB CLASS IN JCT
         MVC   JCTCLASS,JCTJCLAS   SET CLASS IN JMR
         B     RJOBINCR            FIND NEXT KEYWORD
         SPACE 2
RJOBMSGC MVC   JCTMCLAS,9(RW)      SET MSGCLASS IN JCT
         SPACE 1                                                     R4
RJOBTYPR CLC   2(6,RW),RTYPRUN     TEST KEYWORD
         BNE   RJOBNOTI            BRANCH IF NOT 'TYPRUN'
         CLC   9(4,RW),RHOLD       TEST VALUE
         BNE   RJOBTRJH            BRANCH IF NOT 'TYPRUN=HOLD'       R4
         OI    JCTJBOPT,JCTTHOLD   INDICATE 'TYPRUN=HOLD' IN JCT
         B     RJOBINCR            ADVANCE TO NEXT PARAMETER   @OZ24801
         SPACE 1                                                     R4
RJOBTRJH CLC   9(7,RW),RJCLHOLD    TEST VALUE                        R4
         BNE   RJOBTRSC            BRANCH IF NOT 'TYPRUN=JCLHOLD'    R4
         OI    RDRSW2,RJCLH        INDICATE 'TYPRUN=JCLHOLD'         R4
         B     RJOBINCR            ADVANCE TO NEXT PARAMETER   @OZ24801
         SPACE 1                                                     R4
RJOBTRSC CLC   9(4,RW),RSCAN       TEST VALUE
         BNE   RJOBTRCP            BRANCH IF NOT 'TYPRUN=SCAN'
         OI    JCTJOBFL,JCTTSCAN   INDICATE 'TYPRUN=SCAN' IN JCT
         B     RJOBINCR            ADVANCE TO NEXT PARAMETER   @OZ24801
         SPACE 1                                                     R4
RJOBTRCP CLC   9(4,RW),RCOPY       TEST VALUE
         BNE   RILLJOBC            TYPRUN='XXXX' MISPELLED     @OZ24801
         MVI   JCTCNVRC+3,JCTCOK   CLEAR CONVERTER RTN CODE    @OZ25420
         OI    JCTJOBFL,JCTTCOPY   INDICATE 'TYPRUN=COPY' IN JCT
         B     RJOBINCR            ADVANCE TO NEXT PARAMETER   @OZ33013
         SPACE 1                                                     R4
RJOBNOTI CLC   2(6,RW),RNOTIFY     TEST KEYWORD
         BNE   RJOBPRTY            BRANCH IF NOT 'NOTIFY'            R4
         CLI   9(RW),C'$'          CHECK FOR $                       R4
         BE    RJBNOTFY            VALID USERID, CONTINUE            R4
         CLI   9(RW),C'@'          CHECK FOR @                       R4
         BE    RJBNOTFY            VALID USERID, CONTINUE            R4
         CLI   9(RW),C'#'          CHECK FOR #                       R4
         BE    RJBNOTFY            VALID USERID, CONTINUE            R4
         CLI   9(RW),C'A'          CHECK FOR ALPHAMERIC              R4
         BL    RJOBINCR            IGNORE IF NO                      R4
         CLI   9(RW),C'Z'          TEST NEXT CHARACTER
         BH    RJOBINCR            BRANCH IF ILLEGAL USERID
         SPACE 1                                                     R4
RJBNOTFY MVC   RUSERID(8),9(RW)    MOVE USERID TO WORK AREA          R4
         MVI   RUSERID+8,X'BF'     ADD TERMINATOR CHARACTER
         LA    R1,RUSERID+1        PREPARE TO SCAN USERID
         SPACE 1                                                     R4
RJOBNOTS CLI   0(R1),C','          TEST NEXT CHARACTER
         BE    RJOBNOTC            BRANCH IF COMMA
         TM    0(R1),X'BF'         TEST AGAIN
         BO    RJOBINCR            ILLEGAL IF TERMINATOR CHARACTER
         LA    R1,1(,R1)           STEP TO NEXT CHARACTER
         BNZ   RJOBNOTS            SCAN NEXT CHARACTER
         SPACE 1                                                     R4
RJOBNOTC MVI   0(R1),C' '          BLANK OUT
         MVC   1(5,R1),0(R1)        REST OF USERID
         MVC   JCTTSUID,RUSERID    MOVE USERID TO JCT
         MVC   JCTTSUAF,$SIDAFF    MOVE INPUT AFFINITY TO JCT
         SPACE 1                                                     R4
RJOBPRTY CLC   4(4,RW),RPRTY       TEST KEYWORD                      R4
         BNE   RJOBPASS            BRANCH IF NOT 'PRTY'              R4
         LA    R1,RJOBINCR         SET IGNORE/EXIT ADDRESS           R4
         TM    $RUNOPTS,$PRTYOPT   IGNORE PRTY FIELD IF              R4
         BZR   R1                    INIT OPTION NOT SELECTED        R4
         TM    JCTJBOPT,JCTPRICD   IGNORE JOB CARD PRTY IF           R4
         BNZR  R1                    /*PRIORITY CARD PRESENT         R4
         CLI   9(RW),C'0'          IGNORE IF                         R4
         BLR   R1                    FIRST DIGIT                     R4
         CLI   9(RW),C'9'            NOT ZERO                        R4
         BHR   R1                    THRU NINE                       R4
         CLI   10(RW),C' '         HANDLE 2-DIGIT                    R4
         BE    SKIP210               FIELD IF NEXT                   R4
         CLI   10(RW),C','           CHAR IS NOT                     R4
         BNE   RJOBPRT2              BLANK OR COMMA                  R4
SKIP210  MVC   RPRIORTY+1(1),9(RW) SAVE 1-DIGIT PRIORITY             R4
         B     RSETP               MOVE DATA TO JCT                  R4
         SPACE 1                                                     R4
RJOBPRT2 CLI   11(RW),C' '         2-DIGIT PRTY                      R4
         BE    SKIP220               MUST BE                         R4
         CLI   11(RW),C','           FOLLOWED BY                     R4
         BNER  R1                    BLANK OR COMMA                  R4
SKIP220  CLI   10(RW),C'0'         IGNORE IF                         R4
         BLR   R1                    SECOND DIGIT                    R4
         CLI   10(RW),C'9'           NOT ZERO                        R4
         BHR   R1                    THRU NINE                       R4
         CLC   =C'15',9(RW)        IGNORE IF PRTY                    R4
         BL    RILLJOBC            IF OVER 15, KILL JOB        @OZ27970
         MVC   RPRIORTY(2),9(RW)   SAVE 2-DIGIT PRIORITY             R4
         SPACE 1                                                     R4
RSETP    MVC   JCTPRTY,RPRIORTY    MOVE EBCDIC PRTY TO JCT,          R4
         OI    JCTJBOPT,JCTPRICD     SET 'FORCE PRTY' FLAG           R4
         BR    R1                  CONTINUE SCAN                     R4
         EJECT                                                       R4
************************************************************** @OZ62321
*                                                            * @OZ62321
*                    PASSWORD PROCESSING                     * @OZ62321
*                                                            * @OZ62321
*        THE PASSWORD PARAMETER ON THE JOB CARD IS CHECKED   * @OZ62321
*        FOR VALID SYNTAX.  IF THE PASSWORD PARAMETER IS     * @OZ62321
*        VALID, BOTH THE OLD AND NEW PASSWORDS, IF PRESENT,  * @OZ62321
*        ARE PLACED INTO THE JCT, AND THE PASSWORD(S) ARE    * @OZ62321
*        REMOVED FROM THE JCL CARD.  IF THE PASSWORD IS      * @OZ62321
*        DETERMINED TO BE INVALID, THE CODE BRANCHES TO      * @OZ62321
*        LABEL 'RILLJOBC', AND THE JOB CARD IS FLUSHED.      * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE ,                                               @OZ62321
RJOBPASS CLC   0(8,RW),=CL8'PASSWORD'   IF PARAMETER PASSWORD        R4
         BNE   RJOBINCR            BRANCH IF NOT PASSWORD            R4
         EJECT ,                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        SETUP SCAN POINTERS AND CHECK THE FIRST PASSWORD    * @OZ62321
*        CHARACTER.                                          * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPASSWRD LA    RL2,9(,RW)          PT. TO 1ST PSWD CHAR        @OZ62321
         ST    RW,RTEMP            SAVE JOB SCAN POINTER       @OZ62321
         ST    RBI,RTEMP+4         SAVE RBI REGISTER           @OZ62321
         L     R3,=A(RPASTAB)      PT. R3 TO XLATE TABLE       @OZ62321
         LA    R15,71(,RPI)        PT. R15 TO COL. 72          @OZ62321
         CR    RL2,R15             ARE WE AT COL. 72 ...       @OZ62321
         BNL   RPILGJOB            YES, FLUSH JOB              @OZ62321
         LR    RL1,RL2             SAVE PTR TO FIRST CHAR      @OZ62321
         TRT   0(1,RL2),0(R3)      IS FIRST CHAR VALID...      @OZ62321
         BZ    RPASS05             YES, PROCESS PASSWORD       @OZ62321
         CLI   0(R1),C'('          ELSE, WAS '(' FOUND ...     @OZ62321
         BE    RPASS35             YES, PROCESS PSWD IN PARENS @OZ62321
         L     RW,RTEMP            RESTORE JOB SCAN POINTER    @OZ70480
         L     RBI,RTEMP+4         RESTORE RBI                 @OZ70480
         CLI   0(R1),C','          PASSWORD=,   SPECIFIED...   @OZ70480
         BE    RJOBINCR            YES, GO TO NEXT PARAMETER   @OZ70480
         CLI   0(R1),C' '          PASSWORD=    SPECIFIED...   @OZ70480
         BE    RJOBINCR            YES, GO TO NEXT PARAMETER   @OZ70480
         B     RPILGJOB            NO, FLUSH ILLEGAL JOB       @OZ62321
         SPACE 1                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        PROCESS PASSWORDS OF THE FORM 'PASSWORD=NNNN'       * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPASS05  DS    0H                                              @OZ62321
         LA    RL2,1(,RL2)         POINT TO NEXT CHAR          @OZ62321
         LR    R2,R15              POINT R2 TO COL. 72         @OZ62321
         SR    R2,RL2              R2 = LTH TO END OF CARD     @OZ62321
         LTR   R2,R2               LENGTH = 0 ...              @OZ62321
         BNZ   RPASS10             NO, SCAN FOR MORE CHARS     @OZ62321
         EX    R2,RPJCTPMV         MOVE PASSWORD TO JCT        @OZ62321
         BAL   R2,RPREMPAS         REMOVE PASSWORD FROM JCL    @OZ62321
         B     RPASBJCT             TERMINATE PASSWORD SCAN    @OZ62321
         SPACE 1                                               @OZ62321
RPASS10  DS    0H                                              @OZ62321
         C     R2,=A(L'JCTPASS-1)  ROOM FOR MAX PSWD ...       @OZ62321
         BNH   RPASS20             NO, PROCESS SHORT PSWD      @OZ62321
         LA    R2,L'JCTPASS-1      SET R2 TO MAX LENGTH        @OZ62321
         EX    R2,RPVALCHR         CHECK FOR VALID STRING      @OZ62321
         BZ    RPILGJOB            PSWD TOO LONG - ERROR       @OZ62321
         CLI   0(R1),C','          COMMA AFTER PASSWORD ...    @OZ62321
         BE    RPASS15             YES, PROCESS PASSWORD       @OZ62321
         CLI   0(R1),C' '          BLANK AFTER PASSWORD ...    @OZ62321
         BNE   RPILGJOB            NO, FLUSH JOB               @OZ62321
RPASS15  LR    RL2,R1              PT. RL2 BEYOND PSWD         @OZ62321
         SR    R1,RL1              R1 = PASSWORD LENGTH        @OZ62321
         BCTR  R1,0                DEC. LENGTH TO ZERO         @OZ62321
         EX    R1,RPJCTPMV         MOVE PASSWORD INTO JCT      @OZ62321
         BAL   R2,RPREMPAS         REMOVE PASSWORD FROM JCL    @OZ62321
         B     RPASBJCT             AND RETURN                 @OZ62321
         SPACE 1                                               @OZ62321
RPASS20  LR    R0,R2               SAVE MAX. PSWD LENGTH       @OZ62321
         BCTR  R2,0                DEC. MAX. PSWD LENGTH       @OZ62321
         EX    R2,RPVALCHR         SCAN PASSWORD STRING        @OZ62321
         BNZ   RPASS25             BR. TO CHECK END CHAR       @OZ62321
         LR    R2,R0               RESTORE PASSWORD LENGTH     @OZ62321
         LA    R1,0(RL2,R2)        R1 = 1ST CHAR BEYOND PSWD   @OZ62321
         B     RPASS30             PROCESS VALID PASSWORD      @OZ62321
RPASS25  CLI   0(R1),C','          PSWD END WITH COMMA ...     @OZ62321
         BE    RPASS30             YES, PROCESS PASSWORD       @OZ62321
         CLI   0(R1),C' '          PSWD FOLLOWED BY BLANK ...  @OZ62321
         BNE   RPILGJOB            NO, FLUSH ILLEGAL JOB       @OZ62321
RPASS30  LR    RL2,R1              PT. RL2 BEYOND PASSWORD     @OZ62321
         SR    R1,RL1              R1= PASSWORD LENGTH         @OZ62321
         BCTR  R1,0                DEC. LENGTH FOR MOVE        @OZ62321
         EX    R1,RPJCTPMV         MOVE PASSWORD INTO JCT      @OZ62321
         BAL   R2,RPREMPAS         REMOVE PASSWORD FROM JCL    @OZ62321
         B     RPASBJCT            FINISH PSWD PROCESSING      @OZ62321
         SPACE 1                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        PROCESS PASSWORDS OF THE FORM 'PASSWORD=(NNNN)'     * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPASS35  LA    RL2,1(,RL2)         POINT TO NEXT CHAR.         @OZ62321
         LR    RL1,RL2             SAVE PTR TO FIRST CHAR      @OZ62321
         CR    RL2,R15             ARE WE AT COL. 72 ...       @OZ62321
         BNL   RPILGJOB            YES, ERROR                  @OZ62321
         TRT   0(1,RL2),0(R3)      VALID PSWD CHARACTER ...    @OZ62321
         BNZ   RPILGJOB            NO, FLUSH JOB               @OZ62321
RPASS40  LA    RL2,1(,RL2)         POINT TO NEXT CHAR          @OZ62321
         CR    RL2,R15             ARE WE AT COL. 72 ...       @OZ62321
         BNL   RPILGJOB            YES, ERROR                  @OZ62321
         LR    R1,R15              COMPUTE NUMBER OF SPACES    @OZ62321
         SR    R1,RL2               UNTIL COLUMN 72            @OZ62321
         C     R1,=A(L'JCTPASS)    ENOUGH FOR MAX PASSWORD...  @OZ62321
         BNH   RPASS45             BR. IF NO                   @OZ62321
         LA    R1,L'JCTPASS        ELSE, SET MAX PSWD LENGTH   @OZ62321
RPASS45  BCTR  R1,0                DEC. LTH FOR SCAN           @OZ62321
         EX    R1,RPVALCHR         VALIDATE PASSWORD STRING    @OZ62321
         BZ    RPILGJOB            ERROR IF ALL VALID CHARS    @OZ62321
         CLI   0(R1),C','          PSWD END WITH COMMA ...     @OZ62321
         BE    RPASS50             YES, PROCESS PASSWORD       @OZ62321
         CLI   0(R1),C')'          PASSWORD END WITH ')'...    @OZ62321
         BNE   RPILGJOB            NO, FLUSH INVALID JOB       @OZ62321
RPASS50  LR    RL2,R1              SET RL2 BEYOND PASSWORD     @OZ62321
         SR    R1,RL1              R1 = PASSWORD LENGTH        @OZ62321
         BCTR  R1,0                DEC. LENGTH FOR MOVE        @OZ62321
         EX    R1,RPJCTPMV         MOVE PSWD INTO JCT          @OZ62321
         BAL   R2,RPREMPAS         REMOVE PSWD FROM JCL        @OZ62321
         CLI   0(RL2),C','         PASSWORD FOLLOWED BY ','... @OZ62321
         BE    RPASS60             YES, CHECK FOR NEW PSWD     @OZ62321
         SPACE 1                                               @OZ62321
RPASS55  LA    RL2,1(,RL2)         PT. TO NEXT BYTE            @OZ62321
         CR    RL2,R15             ARE WE AT COL. 72 ...       @OZ62321
         BNL   RPASBJCT            YES, TERM PSWD SCAN         @OZ62321
         TRT   0(1,RL2),0(R3)      ELSE, SCAN PSWD CHAR        @OZ62321
         BZ    RPILGJOB            FLUSH IF NOT SPECIAL CHAR   @OZ62321
         CLI   0(R1),C','          COMMA AFTER PASSWORD ...    @OZ62321
         BE    RPASBJCT            YES, END SCAN               @OZ62321
         CLI   0(R1),C' '          BLANK AFTER PSWD ...        @OZ62321
         BE    RPASBJCT            YES, END SCAN               @OZ62321
         B     RPILGJOB            ELSE, FLUSH ILLEGAL JOB     @OZ62321
         SPACE 1                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        A VALID OLD PASSWORD HAS BEEN FOUND.  SCAN FOR      * @OZ62321
*        A NEW PASSWORD.                                     * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPASS60  LA    RL2,1(,RL2)         POINT TO NEXT BYTE          @OZ62321
         CR    RL2,R15             ARE WE AT COLUMN 72 ...     @OZ62321
         BNL   RPASS80             YES, GET CONTINUATION       @OZ62321
         LR    RL1,RL2             SAVE PTR TO 1ST PSWD CHAR   @OZ62321
         TRT   0(1,RL2),0(R3)      SCAN NEXT CHAR              @OZ62321
         BZ    RPASS65             BR. IF VALID CHAR           @OZ62321
         CLI   0(R1),C' '          ELSE, WAS BLANK FOUND ...   @OZ62321
         BE    RPASS80             YES, GET CONTINUATION       @OZ62321
         B     RPILGJOB            INV. CHAR. - FLUSH JOB      @OZ62321
         SPACE 1                                               @OZ62321
RPASS65  LA    RL2,1(,RL2)         POINT TO NEXT BYTE          @OZ62321
         CR    RL2,R15             ARE WE AT COLUMN 72 ...     @OZ62321
         BNL   RPILGJOB            YES, ERROR                  @OZ62321
         LR    R1,R15              COMPUTE LENGTH BETWEEN      @OZ62321
         SR    R1,RL2               CUR. CHAR AND END OF CARD  @OZ62321
         C     R1,=A(L'JCTNUPAS)   ENOUGH ROOM FOR MAX PSWD... @OZ62321
         BNH   RPASS70             BR. IF NO                   @OZ62321
         LA    R1,L'JCTNUPAS       SET R1 TO MAX PSWD LENGTH   @OZ62321
RPASS70  BCTR  R1,0                DEC. COUNT FOR MOVE         @OZ62321
         EX    R1,RPVALCHR         VALIDATE NEW PASSWORD       @OZ62321
         BZ    RPILGJOB            INVALID IF NO TERMINATOR    @OZ62321
         CLI   0(R1),C')'          ')' FOLLOWING NEW PSWD ...  @OZ62321
         BNE   RPILGJOB            NO, FLUSH ILLEGAL JOB       @OZ62321
         LR    RL2,R1              ELSE PT. RL2 BEYOND PSWD    @OZ62321
         SR    R1,RL1              R1 = PASSWORD LENGTH        @OZ62321
         BCTR  R1,0                DEC. LTH FOR MOVE           @OZ62321
         EX    R1,RPJCTNMV         MOVE NEW PSWD INTO JCT      @OZ62321
         BAL   R2,RPREMPAS         DELETE PASSWORD FROM JCL    @OZ62321
         SPACE 1                                               @OZ62321
RPASS75  LA    RL2,1(,RL2)         POINT TO NEXT BYTE          @OZ62321
         CR    RL2,R15             ARE WE AT COL. 72 ...       @OZ62321
         BNL   RPASBJCT            YES, SCAN IS FINISHED       @OZ62321
         CLI   0(RL2),C' '         IS THIS CHAR A BLANK ...    @OZ62321
         BE    RPASBJCT            YES, SCAN IS FINISHED       @OZ62321
         CLI   0(RL2),C','         PSWD FOLLOWED BY ',' ...    @OZ62321
         BE    RPASBJCT            YES, SCAN IS FINISHED       @OZ62321
         B     RPILGJOB            ELSE, FLUSH ILLEGAL JOB     @OZ62321
         EJECT ,                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        A NEW PASSWORD IS NOT ON THE CURRENT CARD.          * @OZ62321
*        GET CONTINUATION CARD, AND CHECK FOR NEW PASSWORD.  * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPASS80  DS    0H                                              @OZ62321
         L     RBI,RTEMP+4         RESTORE RBI BEFORE BAL      @OZ62321
         BAL   RL1,RCONTNUE        GET A CONTINUATION CARD     @OZ62321
         B     RPASS85             ILLEGAL CONTINUATION CARD   @OZ62321
         B     RPASS90             VALID CONTINUATION CARD     @OZ62321
         SPACE 1                                               @OZ62321
RPASS85  ST    RW,RTEMP            SAVE RW POINTER             @OZ62321
         ST    RBI,RTEMP+4         SAVE RBI REGISTER           @OZ62321
         B     RPILGJOB            TAKE ERROR EXIT             @OZ62321
         SPACE 1                                               @OZ62321
RPASS90  ST    RW,RTEMP            SAVE RW POINTER             @OZ62321
         ST    RBI,RTEMP+4         SAVE RBI REGISTER           @OZ62321
         CLI   6(RW),C' '          BLANK IN COLS 4-16 ...      @OZ62321
         BE    RPILGJOB            YES, ILLEGAL CONTINUATION   @OZ62321
         L     R3,=A(RPASTAB)      ELSE, PT R3 TO XLATE TABLE  @OZ62321
         LA    R15,71(,RPI)        PT. R15 TO COLUMN 72        @OZ62321
         LA    RL1,6(,RW)          POINT TO 1ST NON-BLANK      @OZ62321
         LR    RL2,RL1             COPY POINTER INTO RL2       @OZ62321
         SPACE 1                                               @OZ62321
         TRT   0(1,RL2),0(R3)      VALID PASSWORD CHAR ...     @OZ62321
         BNZ   RPILGJOB            NO, FLUSH JOB               @OZ62321
         LA    RL2,1(,RL2)         ELSE, POINT TO NEXT CHAR    @OZ62321
         LA    R1,L'JCTPASS-1      SET LTH FOR MAX PSWD SCAN   @OZ62321
         EX    R1,RPVALCHR         VALIDATE NEW PASSWORD       @OZ62321
         BZ    RPILGJOB            PSWD TOO LONG - ERROR       @OZ62321
         CLI   0(R1),C')'          RIGHT PAREN FOUND ...       @OZ62321
         BNE   RPILGJOB            NO, FLUSH ILLEGAL JOB       @OZ62321
         LR    RL2,R1              ELSE, PT. RL2 BEYOND PSWD   @OZ62321
         SR    R1,RL1              R1 = PASSWORD LENGTH        @OZ62321
         BCTR  R1,0                DEC. LTH FOR MOVE           @OZ62321
         EX    R1,RPJCTNMV         MOVE NEW PSWD INTO JCT      @OZ62321
         BAL   R2,RPREMPAS         REMOVE PSWD FROM JCL        @OZ62321
         SPACE 1                                               @OZ62321
RPASS95  LA    RL2,1(,RL2)         PT TO NEXT BYTE             @OZ62321
         CLI   0(RL2),C','         COMMA FOLLOWING PSWD ...    @OZ62321
         BE    RPASBJCT            YES, FINISH PSWD PROCESS.   @OZ62321
         CLI   0(RL2),C' '         BLANK FOLLOWING PSWD ...    @OZ62321
         BNE   RPILGJOB            NO, FLUSH ILLEGAL JOB       @OZ62321
         SPACE 1                                               @OZ62321
         EJECT ,                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        A VALID PASSWORD HAS BEEN PROCESSED.  BLANK OUT     * @OZ62321
*        TRAILING ZEROES IN THE JCT BEFORE PROCESSING THE    * @OZ62321
*        NEXT JOB CARD PARAMETER.                            * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPASBJCT DS    0H                  PASSWORD SUCCESSFULLY       @OZ62321
*                                   PROCESSED                  @OZ62321
         L     RBI,RTEMP+4         RESTORE RBI REGISTER        @OZ62321
         L     RW,RTEMP            RESTORE RW                  @OZ69755
*              THIS LINE DELETED BY APAR                     * @OZ69755
         OI    RPASPROC,$RPASFND   INDICATE THAT A VALID       @OZ62321
*                                   PASSWORD WAS FOUND         @OZ62321
         CLI   JCTPASS,0           CURRENT PSWD SPECIFIED...   @OZ62321
         BE    RJOBINCR            NO, CONTINUE                @OZ62321
         OC    JCTPASS,$BLANKS     YES, BLANK TRAILING ZEROES  @OZ62321
         CLI   JCTNUPAS,0          NEW PASSWORD SPECIFIED...   @OZ62321
         BE    RJOBINCR            NO, CONTINUE                @OZ62321
         OC    JCTNUPAS,$BLANKS    YES, BLANK TRAILING ZEROES  @OZ62321
         B     RJOBINCR            CONTINUE JOB SCAN           @OZ62321
         SPACE 3                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        AN INVALID PASSWORD PARAMETER HAS BEEN DETECTED.    * @OZ62321
*        RESTORE REGISTERS BEFORE FLUSHING ILLEGAL JOB.      * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPILGJOB DS    0H                  INVALID PSWD SPECIFIED      @OZ62321
         L     RW,RTEMP            RESTORE JOB SCAN POINTER    @OZ62321
         L     RBI,RTEMP+4         RESTORE RBI REGISTER        @OZ62321
         LA    RW,1(,RW)            AND POINT BEYOND PSWD      @OZ62321
         B     RILLJOBC            PROCESS ILLEGAL JOB         @OZ62321
         EJECT ,                                               @OZ62321
************************************************************** @OZ62321
*                                                            * @OZ62321
*        THIS SUBROUTINE IS USED TO EXTRACT PASSWORDS        * @OZ62321
*        FROM JCL CARDS.                                     * @OZ62321
*                                                            * @OZ62321
*        REGISTER USAGE:                                     * @OZ62321
*                                                            * @OZ62321
*        R1              WORK REGISTER                       * @OZ62321
*        R2              RETURN REGISTER                     * @OZ62321
*        RL1 (R5)        PTR. TO FIRST PASSWORD CHAR.        * @OZ62321
*        RL2 (R6)        PTR. TO FIRST CHAR BEYOND PASSWORD  * @OZ62321
*        R15             PTR. TO COLUMN 72 OF JCL CARD       * @OZ62321
*                                                            * @OZ62321
*        BEFORE RETURNING, REGISTERS RL1 AND RL2 ARE SET TO  * @OZ62321
*        POINT TO THE FIRST CHARACTER BEYOND THE PASSWORD    * @OZ62321
*        THAT HAS JUST BEEN DELETED.                         * @OZ62321
*                                                            * @OZ62321
************************************************************** @OZ62321
         SPACE 1                                               @OZ62321
RPREMPAS DS    0H                  REMOVE PSWD FROM JCL        @OZ62321
         LR    R1,R15              PT. R1 TO COL. 72           @OZ62321
         CR    RL2,R1              PSWD REACH COL. 72 ...      @OZ62321
         BNL   RPRMPS1             YES, BLANK IT OUT           @OZ62321
         BCTR  R1,0                ELSE, PT. TO COL. 71        @OZ62321
         SR    R1,RL2              COMPUTE OVERLAY LENGTH      @OZ62321
         EX    R1,RPRMOLAY          AND OVERLAY PASSWORD       @OZ62321
         SPACE 1                                               @OZ62321
RPRMPS1  SR    RL2,RL1             SET RL2 TO PSWD LENGTH      @OZ62321
         LR    R1,R15              COMPUTE BEGIN. OF BLANK     @OZ62321
         SR    R1,RL2               FIELD AND STORE IN R1      @OZ62321
         BCTR  RL2,0               DECREMENT PASSWORD LENGTH   @OZ62321
         EX    RL2,RPRINSB         BLANK OUT END OF JCL CARD   @OZ62321
         SPACE 1                                               @OZ62321
         LR    RL2,RL1             PT. RL2 TO FIRST CHAR.      @OZ62321
*                                   BEYOND PASSWORD            @OZ62321
         BR    R2                  RETURN TO CALLER            @OZ62321
         EJECT ,                                               @OZ62321
RPJCTPMV MVC   JCTPASS(0),0(RL1)   COPY OLD PSWD INTO JCT      @OZ62321
*                                   (EXECUTE ONLY)             @OZ62321
RPJCTNMV MVC   JCTNUPAS(0),0(RL1)  COPY NEW PSWD INTO JCT      @OZ62321
*                                   (EXECUTE ONLY)             @OZ62321
RPVALCHR TRT   0(0,RL2),0(R3)      VALIDATE PASSWORD CHARS.    @OZ62321
*                                   (EXECUTE ONLY)             @OZ62321
RPRMOLAY MVC   0(0,RL1),0(RL2)     OVERLAY PASSWORD WITH       @OZ62321
*                                   ADJACENT JCL (EXEC. ONLY)  @OZ62321
RPRINSB  MVC   0(0,R1),$BLANKS     BLANK OUT END OF JCL CARD   @OZ62321
*                                   (EXECUTE ONLY)             @OZ62321
         EJECT ,                                               @OZ62321
RJOBINCR BXLE  RW,R14,RJOBKEY      ADVANCE TO NEXT COLUMN
         SPACE 1                                                     R4
RJOBLANK CLI   7(RW),C','          TEST LAST COLUMN
         BE    RPASECNM            BRANCH IF CONT. INDICATED   @OZ38384
         SPACE 1                                               @OZ73741
RJOBCONT CLI   71(RPI),C' '        IS COL 72 BLANK...          @OZ73741
         BNE   RGETCONT            IF NOT, GET CONTINUATION    @OZ73741
         OI    RPASPROC,$RJOBECD   END OF CARD MET             @OZ38384
         NI    RPASPROC,255-$RJOBFND END OF JOB CARD PROC.     @OZ38384
         TM    RPASPROC,$RJOBERR   IF JOB CARD ILLEGAL         @OZ38384
         BO    RILLJOBC            CONTINUE OUTPUT PROCESSING  @OZ38384
         B     RJOBCEND            DONE IF NO CONT. INDICATED  @OZ38384
         SPACE 1                                               @OZ73741
RPASECNM BAL   RL1,RCONTNUE        GET CONTINUATION CARD       @OZ38384
         B     RILLJOBC            BRANCH IF ILLEGAL CONTINUATION
         B     RJOBSRCH            NORMAL RETURN, CONTINUE SCAN
         SPACE 1                                               @OZ73741
RGETCONT BAL   RL1,RCONTNUE        GET CONTINUATION            @OZ73741
         B     RILLJOBC            ILLEGAL CONTINUATION +0     @OZ73741
         B     RJOBCONT            CK FOR MORE CONT  +4        @OZ73741
         EJECT                                                 @OZ73741
RJOBCEND L     RW,PCEDCT           RW = ADDRESS OF INPUT DCT   @OZ32566
         USING DCTDSECT,RW         ESTABLISH DCT ADDRESSABILITY
         MVC   RMESSAGE(L'RONMSG),RONMSG     SET UP SIGN-ON MESSAGE
         MVC   RMESSAGE+5(8),DCTDEVN         ADD DEVICE NAME
         MVC   RMESSAGE+17(20),JCTPNAME      ADD PROGRAMMER NAME
         TM    PCEID,PCERJEID      TEST PROCESSOR TYPE
         BZ    RNOTRJE3            BRANCH IF NOT REMOTE TERMINAL
         ICM   R1,7,DCTDCB+1       GET LINE DCT PTR            @OZ31782
         BZ    RDREND              NO LINE DCT PTR, FREE RDR   @OZ31782
         L     R1,MDCTRAT-DCTDSECT(,R1)  GET ADDRESS OF RAT
         SLR   LINK,LINK                     CLEAR AND INSERT
         ICM   LINK,2,RATCONRT+1-RATDSECT(R1) REMOTE CONSOLE ROUTE CODE
         LA    R0,L'RONMSG+20(,LINK)  ADD MESSAGE LENGTH
        $WTO   RMESSAGE,(R0),JOB=YES,               ISSUE MESSAGE TO   C
               RMT=YES,CLASS=$ACTION,PRI=$ST         REMOTE TERMINAL R4
         SPACE 1                                                     R4
RNOTRJE3 NULL                      *                                 R4
        $WTO   RMESSAGE,L'RONMSG+20,JOB=YES,                ISSUE      C
               ROUTE=$LOG+$UR,CLASS=$ACTION,PRI=$ST          MESSAGE
         SPACE 2
         IC    R1,JCTJCLAS         GET JOB CLASS
         N     R1,RJCIMASK         CONVERT TO JOB CLASS INDEX
         SLL   R1,5                MULTIPLY BY 32
         AL    R1,$CATABLE         GET ADDRESS OF CAT ELEMENT
         USING CATDSECT,R1         ESTABLISH CAT ADDRESSABILITY
         MVC   JCTSMFLG,CATSMFLG   SET HASP SMF FLAGS
         OC    JCTJOBFL(2),CATJOBFL  SET JOB FLAGS AND OPTIONS
         NI    JCTJBOPT,255-JCTQHELD  RESET QUEUE HELD INDICATOR
*              THIS LINE DELETED BY APAR                       @OZ38058
         DROP  R1                  DROP CAT ADDRESSABILITY
         SPACE 2
         TM    JCTJOBFL,JCTTCOPY   TEST JOB FLAGS
         BZ    *+8                 BRANCH IF NOT 'TYPRUN=COPY'
         OI    RDRSW2,RTPCPY       SET TYPRUN=COPY FLAG.       @OZ48524
         TM    DCTFLAGS,DCTHOLDJ   TEST DEVICE COMMANDS              R4
         BZ    RNOTHELD            BRANCH IF DEVICE IS NOT 'HELD'    R4
         OI    JCTJBOPT,JCTTHOLD   SIMULATE 'TYPRUN=HOLD'            R4
         DROP  RW                  DROP DCT ADDRESSABILITY           R4
         EJECT                                                       R4
RNOTHELD TM    $RUNOPTS,$XBATCH    IF NO EXECUTION BATCHING,         R4
         BZ    RXBCTEST             DON'T TEST JOB NAME              R4
         CLC   $XBATCHN,JCTJNAME   TEST JOB NAME                     R4
         BNE   RXBCTEST            BRANCH IF NOT RESERVED NAME
         CLI   JCTJOBID,C'J'       ALLOW RESERVED NAME               R4
         BNE   RXBCTEST             IF STARTED TASK OR TSU LOGON     R4
         TM    RDRSW2,RCONTILL     ILLEGAL CONTINUATION...     @OZ73741
         BO    RNOHELD1            DON'T ADD TO OUTPUT FILE    @OZ73741
         BAL   RL1,RPUT            ADD JOB CARD TO OUTPUT FILE
         SPACE 1                                               @OZ73741
RNOHELD1 OI    RCARDLRC,LRC1CCTL+LRC1TASA  SET ASA CARR CNTRL  @OZ73741
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE          @OZ73741
         ST    RPI,RSAVE2          SAVE BUFFER POINTER         @OZ73741
         LA    RPI,RXBERMSG        POINT TO ERROR MESSAGE      @OZ73741
         BAL   RL1,RPUT            ADD MSG TO OUTPUT FILE      @OZ73741
         L     RPI,RSAVE2          RESTORE BUFFER POINTER      @OZ73741
         BAL   RL1,RJOBKILL        KILL JOB
        $RETURN                    RETURN TO MAIN PROCESSOR
         SPACE 1                                                     R4
RXBCTEST TM    JCTJBOPT,JCTXBACH   TEST JOB OPTIONS
         BZ    RNOTXBC             BRANCH IF NOT XBATCH JOB          R4
         OI    RDRSW,RXBJOBSW      SET EXECUTION BATCHING SWITCH
         MVI   JCTCNVRC+3,JCTCOK   CLEAR CONVERTER RTN CODE    @OZ25420
         TM    JCTJBOPT,JCTTHOLD   CHECK FOR 'TYPRUN=HOLD',          R4
         BZ    RNOTXBC               BRANCH IF NOT                   R4
         XI    JCTJBOPT,JCTTHOLD   FORCE 'TYPRUN=HOLD' TO BE         R4
         OI    RDRSW2,RJCLH          'TYPRUN=JCLHOLD' FOR XBATCH     R4
         SPACE 1                                                     R4
RNOTXBC  NI    RDRSW,255-RJFLUSH   TURN OFF FLUSH SWITCH             R4
         CLI   $RJOBOPT,4          TEST JOB CARD SCAN OPTION         R4
         BNL   RJOBRET             BR IF 4 OR GREATER                R4
         CLI   JCTJOBID,C'J'       DO NOT SCAN ACCOUNTING PARAMETERS
         BNE   RJOBRET              IF STARTED TASK OR TSU LOGON
         LA    R0,JCTWORK-1        COMPUTE LENGTH
         SL    R0,RSAVE1            OF ACCOUNTING FIELD
*              THIS LINE DELETED BY APAR NUMBER                @OZ41201
         LA    R1,JCTWORK          GET ADDRESS OF ACCOUNTING FIELD
         LA    RW,JCTJMR           GET ADDRESS OF JMR
        $XCTL  HASPRSCN            SCAN ACCOUNTING FIELD PARAMETERS
         EJECT
RILLJOBC NULL                      ILLEGAL JOB CARD
         TM    RPASPROC,$RPASFND   IF PASSWORD PROCESSED       @OZ38384
         BO    RILLJBCA            CONTINUE OUTPUT PROCESSING  @OZ38384
         TM    RPASPROC,$RJOBECD   HAS END OF CARD BEEN MET..  @OZ38384
         BO    RILLJBCA            IF SO, CONT. OUTPUT PROC.   @OZ38384
         LTR   JCT,JCT             HAS JOB BEEN DELETED...     @OZ38384
         BZ    RILLJBCA            IF SO, CONT. OUTPUT PROC.   @OZ38384
         OI    RPASPROC,$RJOBERR   INDICATE JOB CARD ILLEGAL   @OZ38384
         B     RJOBINCR            ADVANCE TO NEXT COLUMN      @OZ38384
RILLJBCA EQU   *                   CONTINUE OUTPUT PROCESSING  @OZ38384
         LTR   JCT,JCT             TEST ADDRESS OF JCT
         BZ    RJOBRET             BRANCH IF JOB HAS BEEN DELETED
         TM    $RJOBOPT,1          TEST JOB CARD SCAN OPTION         R4
         BO    RJOBCEND            BRANCH IF ODD (1, 3, OR 5)        R4
         TM    RDRSW2,RCONTILL     ILLEGAL CONTINUATION...     @OZ73741
         BO    RILLJBCE            DON'T ADD TO OUTPUT FILE    @OZ73741
         BAL   RL1,RPUT            ADD JOB CARD TO OUTPUT FILE
         SPACE 1                                               @OZ73741
RILLJBCE OI    RCARDLRC,LRC1CCTL+LRC1TASA  SET ASA CARR CNTRL  @OZ73741
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE          @OZ73741
         ST    RPI,RSAVE2          SAVE BUFFER POINTER         @OZ73741
         LA    RPI,RJOBERR         POINT TO ERROR MESSAGE      @OZ73741
         TM    RDRSW2,RCONTILL     ILLEGAL CONTINUATION...     @OZ73741
         BNO   RILLJBCC            IF NOT, BR TO PUT OUT MSG   @OZ73741
         LA    RPI,RCONTILL        ELSE, POINT TO CONT MSG     @OZ73741
         SPACE 1                                               @OZ73741
RILLJBCC BAL   RL1,RPUT            ADD MSG TO OUTPUT FILE      @OZ73741
         L     RPI,RSAVE2          RESTORE BUFFER POINTER      @OZ73741
         SPACE 2
        $WTO   RJERRMSG,L'RJERRMSG,JOB=YES,              NOTIFY        C
               ROUTE=$LOG+$UR,CLASS=$TRIVIA,PRI=$ST       OPERATOR
         SPACE 1                                                     R4
RJOBRETK BAL   RL1,RJOBKILL        KILL JOB                          R4
         SPACE 2                                                     R4
RJOBRET $RETURN                    RETURN TO MAIN PROCESSOR
         EJECT
***********************************************************************
*                                                                     *
*        RJSCAN -- SUBROUTINE TO EXTRACT FIELDS FROM JOB STATEMENT    *
*                                                                     *
*              FUNCTION -- EXTRACT NEXT FIELD FROM JOB STATEMENT      *
*                                                                     *
*              INPUTS -- R0  = LENGTH OF OUTPUT AREA                  *
*                        R1  = ADDRESS OF OUTPUT AREA                 *
*                        RL1 = POSITIVE FOR APOSTROPHE COMPRESSION    *
*                                                                     *
*              OUTPUT -- EXTRACTED FIELD IN OUTPUT AREA               *
*                                                                     *
*              LINK REGISTER -- RL1                                   *
*                                                                     *
*              RETURNS -- RL1+0 - NORMAL RETURN                       *
*                         RL1+4 - KEYWORD PARAMETER ENCOUNTERED       *
*                                                                     *
*              EXTERNAL ROUTINE -- RCONTNUE                           *
*                                                                     *
***********************************************************************
         SPACE 5
RJSCAN   MVC   RJOBPRSW(8),RJOBSWS INITIALIZE RJSCAN SWITCHES        R4
         SPACE 1                                                     R4
RJOBNEXT BXH   RW,R14,RJOBCON1     ADVANCE TO NEXT CHARACTER
         CLI   5(RW),C''''         TEST CURRENT CHARACTER
         BNE   RJOBPR              BRANCH IF NOT APOSTROPHE          R4
         XI    RJOBPRSW+1,X'F0'    INVERT APOSTROPHE SWITCH
         LTR   RL1,RL1             TEST COMPRESSION OPTION
         BM    RJOBMOVE            BRANCH IF NO COMPRESSION
         CLI   4(RW),C''''         TEST LAST CHARACTER
         BNE   RJOBNEXT            BRANCH IF NOT APOSTROPHE
         EX    0,RJOBPRSW          MOVE ODD APOSTROPHES ONLY
         B     RJOBNEXT            IGNORE EVEN APOSTROPHES
         SPACE 3                                                     R4
RJOBPR   EX    R0,RJOBPRSW         BRANCH IF IN LITERAL FIELD        R4
         CLI   5(RW),C' '          TEST CURRENT CHARACTER
         BE    RJOBCON2            BRANCH IF BLANK
         CLI   5(RW),C')'          TEST CURRENT CHARACTER
         EX    R0,RJOBPASW         BR IF NOT MATCHING RIGHT PAREN    R4
         NI    RJOBPASW+1,X'0F'    RESET PARENTHESIS SWITCH
         CLI   5(RW),C','          TEST CURRENT CHARACTER
         BER   RL1                 RETURN IF COMMA
         CLI   5(RW),C'='          TEST CURRENT CHARACTER
         BE    4(,RL1)             INDICATE KEYWORD PARAMETER IF '='
         CLI   5(RW),C'('          TEST CURRENT CHARACTER
         BNE   RJOBMOVE            BRANCH IF NOT LEFT PARENTHESIS
         OI    RJOBPASW+1,16*NE    SET PARENTHESIS SWITCH
         EJECT                                                       R4
RJOBMOVE LTR   R0,R0               TEST REMAINING OUTPUT AREA LENGTH
         BZ    RJOBDECR            BRANCH IF FIELD IS TOO LONG @OZ70070
         MVC   0(1,R1),5(RW)       MOVE CHARACTER TO OUTPUT AREA
         BCTR  R0,0                REDUCE OUTPUT AREA LENGTH
         LA    R1,1(,R1)           ADVANCE OUTPUT AREA ADDRESS
         B     RJOBNEXT            GET NEXT CHARACTER
         SPACE 1                                               @OZ70070
RJOBDECR BCTR  RW,0                BACKUP TO PREVIOUS CHARACTER@OZ70070
         B     RILLJOBC            BRANCH TO ILLEGAL JOB CARD  @OZ70070
         SPACE 3                                                     R4
RJOBCON1 TM    RJOBPRSW+1,X'F0'    TEST APOSTROPHE SWITCH
         BNZ   RILLJOBC            ILLEGAL IF LITERAL FIELD
         SPACE 2                                                     R4
RJOBCON2 BCTR  RW,0                BACK UP ONE CHARACTER
         CLI   5(RW),C','          TEST LAST CHARACTER
         BE    RJOBCON3            GET CONTINUATION IF COMMA
         TM    RJOBPASW+1,X'F0'    TEST PARENTHESIS SWITCH
         BNZ   RILLJOBC            ILLEGAL IF PARENTHESIS FIELD
         BR    RL1                 RETURN IF NOT PARENTHESIS FIELD
         SPACE 3                                                     R4
RJOBCON3 STM   R0,R1,RLSAVE1       SAVE
         ST    RL1,RLSAVE3          REGISTERS
         MVC   RLSAVE2(1),RJOBPASW+1 AND PARENTHESIS SWITCH
         BAL   RL1,RCONTNUE        GET NEXT CARD
         B     RILLJOBC            BRANCH IF ILLEGAL CONTINUATION
         LM    R0,R1,RLSAVE1       RESTORE
         L     RL1,RLSAVE3          REGISTERS
         LA    R15,65(,RPI)        SET LIMIT FOR END OF CARD
         MVC   RJOBPRSW(8),RJOBSWS RESET                             R4
         MVC   RJOBPASW+1(1),RLSAVE2 SWITCHES
         B     RJOBNEXT            GET NEXT CHARACTER
         SPACE 5                                                     R4
RJOBSWS  NOP   RJOBMOVE            *** MODEL EXECUTE STATEMENT ***   R4
         NOP   RJOBMOVE            *** MODEL EXECUTE STATEMENT ***   R4
         SPACE 2                                                     R4
RJOBPRSW EQU   $POSTSAV,4          RJSCAN APOSTROPHE SWITCH          R4
RJOBPASW EQU   $POSTSAV+4,4        RJSCAN PARENTHESIS SWITCH         R4
         EJECT
*
*                             JOB CARD SCAN CONSTANTS AND VARIABLES
*
         SPACE 3
RONE     DC    F'1'                CONSTANT
R10000   DC    F'10000'            *
R10001   DC    F'10001'            *
R20000   DC    F'20000'            *
R20001   DC    F'20001'            *
R30000   DC    F'30000'            *
RSTC     DC    CL4'STC'            *
RTSU     DC    CL4'TSU'            *
RJCIMASK DC    A(X'3F')            CLASS INDEX MASK
RJCTID   DC    CL4'JCT'            JCT NAME
RIOTID   DC    CL4'IOT'            IOT NAME
RSTUETIM DC    AL4(1440,999999,999999)  STC/TSU ESTIMATES
*              THIS LINE DELETED BY APAR                       @OZ38058
RMASK    DC    XL8'4020202020202120'  EDIT MASK
RCLASS   DC    CL5'CLASS'          JOB CARD KEYWORD CONSTANTS
RMSG     DC    CL3'MSG'            *
RTYPRUN  DC    CL6'TYPRUN'         *
RHOLD    DC    CL4'HOLD'           *
RJCLHOLD DC    CL7'JCLHOLD'        *                                 R4
RSCAN    DC    CL4'SCAN'           *
RCOPY    DC    CL4'COPY'           *
RNOTIFY  DC    CL6'NOTIFY'         *
RPRTY    DC    CL4'PRTY'           *                                 R4
RLOGNAME DC    CL8'SYSLOG  '       SYSLOG STC JOBNAME          @OZ43877
RLOGETIM DC    AL4(1440,X'7FFFFFFF',X'7FFFFFFF') SYSLOG ESTIM  @OZ43877
         SPACE 3
RJOBVAR  EQU   $POSTSAV,4          VARIABLE JOBID HEADER             R4
RONMSG   $MSG  100,'ON DEV NAME    '  JOB SIGN-ON MESSAGE
RXBERMSG DC    14C'*',CL20' RESERVED JOB NAME -'               @OZ73741
         DC    CL30' CHANGE 1 OF 1ST 5 CHARACTERS '            @OZ73741
         DC    15C'*',C' '                                     @OZ73741
RJOBERR  DC    30C'*',CL18' ILLEGAL JOB CARD ',31C'*',C' '     @OZ73741
RCONTERR DC    28C'*',CL22' ILLEGAL CONTINUATION ',29C'*',C' ' @OZ73741
         SPACE 5
         DROP  BASE3               DROP SEGMENT ADDRESSABILITY
         TITLE 'HASPRDR      -- CLASS CHARACTERISTICS TABLE'   @OZ48782
         SPACE 5                                               @OZ48782
         ORG   *-3*64              ORG OVER UNUSED SPACE       @OZ48782
RDCAT    DS    0D                  CLASS ATTRIBUTE TABLE       @OZ48782
         ORG   *+3*64              INVALID CLASSES             @OZ48782
         SPACE 1                                               @OZ48782
         DC    01AL1(0)            INVALID CLASS               @OZ48782
         DC    01AL1(CATBATCH)     CLASS A                     @OZ48782
         DC    01AL1(CATBATCH)     CLASS B                     @OZ48782
         DC    07AL1(CATBATCH)     CLASSES C-I                 @OZ48782
         DC    07AL1(0)            INVALID CLASSES             @OZ48782
         DC    01AL1(CATBATCH)     CLASS J                     @OZ48782
         DC    01AL1(CATBATCH)     CLASS K                     @OZ48782
         DC    07AL1(CATBATCH)     CLASSES L-R                 @OZ48782
         DC    08AL1(0)            INVALID CLASSES             @OZ48782
         DC    08AL1(CATBATCH)     CLASSES S-Z                 @OZ48782
         DC    06AL1(0)            INVALID CLASSES             @OZ48782
         DC    10AL1(CATBATCH)     CLASSES 0-9                 @OZ48782
         DC    06AL1(0)            INVALID CLASSES             @OZ48782
         TITLE 'HASP INPUT SERVICE -- ACCOUNTING FIELD SCAN ROUTINE'
************************************************************** @OZ77019
*                                                            * @OZ77019
*        THIS TRANSLATE TABLE IS USED BY THE RJOBPASS        * @OZ77019
*        ROUTINE IN PROCESSING THE PASSWORD PARAMETER.       * @OZ77019
*        THE TABLE DEFINITIONS ARE AS FOLLOWS:               * @OZ77019
*                                                            * @OZ77019
*        X'00' - VALID PASSWORD CHARACTER                    * @OZ77019
*        X'04' - BLANK                                       * @OZ77019
*        X'08' - COMMA                                       * @OZ77019
*        X'0C' - LEFT PAREN                                  * @OZ77019
*        X'10' - RIGHT PAREN                                 * @OZ77019
*        X'FF' - ALL OTHER CHARACTERS (INVALID)              * @OZ77019
*                                                            * @OZ77019
************************************************************** @OZ77019
         SPACE 1                                               @OZ77019
RPASTAB  DC    256X'FF'            INITIALIZE ALL CHARACTERS   @OZ77019
*                                   AS INVALID                 @OZ77019
         SPACE 1                                               @OZ77019
*                                  DEFINE ENTRIES FOR VALID    @OZ77019
*                                   PASSWORD CHARACTERS        @OZ77019
         SPACE 1                                               @OZ77019
         ORG   RPASTAB+C'$'                                    @OZ77019
         DC    X'00'               $                           @OZ77019
         ORG   RPASTAB+C'#'                                    @OZ77019
         DC    XL2'00'             #,@                         @OZ77019
         ORG   RPASTAB+C'A'                                    @OZ77019
         DC    XL9'00'             A - I                       @OZ77019
         ORG   RPASTAB+C'J'                                    @OZ77019
         DC    XL9'00'             J - R                       @OZ77019
         ORG   RPASTAB+C'S'                                    @OZ77019
         DC    XL8'00'             S - Z                       @OZ77019
         ORG   RPASTAB+C'0'                                    @OZ77019
         DC    XL10'00'            0 - 9                       @OZ77019
         SPACE 1                                               @OZ77019
*                                  MISCELLANEOUS ENTRIES       @OZ77019
         SPACE 1                                               @OZ77019
         ORG   RPASTAB+C' '                                    @OZ77019
         DC    X'04'               BLANK                       @OZ77019
         ORG   RPASTAB+C','                                    @OZ77019
         DC    X'08'               COMMA                       @OZ77019
         ORG   RPASTAB+C'('                                    @OZ77019
         DC    X'0C'               LEFT PAREN                  @OZ77019
         ORG   RPASTAB+C')'                                    @OZ77019
         DC    X'10'               RIGHT PAREN                 @OZ77019
         EJECT                                                 @OZ77019
HASPRSCN $ENTRY CSECT=YES          DEFINE ACCOUNTING FIELD SCAN SEGMENT
         SPACE 2
***********************************************************************
*                                                                     *
*        HASPRSCN -- SUBROUTINE TO PROCESS JOB CARD ACCOUNTING FIELD  *
*                                                                     *
*              INPUT -- JCTWORK CONTAINS ENTIRE ACCOUNTING FIELD      *
*                       RSAVE1 CONTAINS ADDRESS OF LAST CHARACTER     *
*                       (OR DELIMITER) OF ACCOUNTING FIELD, OR THE    *
*                       ADDRESS OF JCTWORK-1 IF NO ACCOUNTING FIELD   *
*                       WAS PROVIDED.                                 *
*                                                                     *
*              REGISTERS AVAILABLE FOR USE -- R0-R2,RL1,RL2,R14,R15   *
*                                                                     *
*              REGISTER USAGE --                                      *
*                                                                     *
*                   R0  -- USED TO RETURN EXTRACTED SUB-FIELD         *
*                   R1  -- CURRENT LOCATION WITHIN ACCOUNTING FIELD   *
*                   R2  -- WORK REGISTER                              *
*                   RL1 -- LINK REGISTER                              *
*                   RL2 -- WORK REGISTER                              *
*                   R14 -- WORK REGISTER                              *
*                   R15 -- POINTER TO END OF ACCOUNTING FIELD         *
*                                                                     *
*              EXTERNAL ROUTINES -- 1) RPUT                           *
*                                   2) RNOCMB                         *
*                                   3) RJOBKILL                       *
*                                                                     *
***********************************************************************
         EJECT
         SR    R2,R2               INITIALIZE WORK REG TO ZERO
         LA    R1,JCTWORK+1        ASSUME ACCT FIELD STARTS WITH '('
         L     R15,RSAVE1          LOAD ADDR OF LAST CHAR OF ACCT FLD
         CR    R15,R1              TEST ACCOUNTING FIELD
         BL    *+12                BR IF NULL OR ONE CHAR UNBOUNDED
         CLI   JCTWORK,C'('        TEST FIRST CHAR OF ACCT FIELD
         BE    *+10                BR IF ACCT FLD ENCLOSED IN PARENDS
         BCTR  R1,0                 ELSE ADJUST START OF SCAN
         LA    R15,1(,R15)          AND END OF SCAN
         MVI   0(R15),255          SET SCAN DELIMITER
         CLI   $RJOBOPT,1          TEST JOB CARD SCAN OPTION         R4
         BH    SKIP230             BR IF 2 OR GREATER                R4
         MVI   RSAVE1,X'80'        INDICATE NO ACCT OR RM NUMBER
SKIP230  BAL   RL1,RSCNFLD1        EXTRACT PGM'RS ACCT'G NUMBER
         B     *+8                 BR IF PROVIDED
         B     RSCNTGT1            BR IF FIELD NOT PROVIDED          R4
         ST    R0,JCTACCTN          ELSE STORE
         BAL   RL1,RSCNFLD3        EXTRACT PGM'RS ROOM NUMBER
         B     *+8                 BR IF PROVIDED
         B     RSCNTGT1            BR IF FIELD NOT PROVIDED          R4
         ST    R0,JCTROOMN          ELSE STORE
         CLI   $RJOBOPT,1          TEST JOB CARD SCAN OPTION         R4
         BH    SKIP240             BR IF 2 OR GREATER                R4
         MVI   RSAVE1,0            INDICATE ACCT AND RM NUMBER
SKIP240  BAL   RL1,RSCNFLD2        EXTRACT ESTIMATED EXECUTION TIME
         ST    R0,JCTETIME          STORE IF PROVIDED
         BAL   RL1,RSCNFLD3        EXTRACT ESTIMATED LINE COUNT
         ST    R0,JCTESTLN          STORE IF PROVIDED
         BAL   RL1,RSCNFLD3        EXTRACT ESTIMATED PUNCHED CARD COUNT
         ST    R0,JCTESTPU          STORE IF PROVIDED
         BAL   RL1,RSCNFLD1        EXTRACT SPECIAL FORMS NUMBER
         ST    R0,JCTFORMS          STORE IF PROVIDED
SKIP250  BAL   RL1,RSCNFLD2        EXTRACT JOB OUTPUT COPY COUNT
         B     RSCNCPY             BR IF FIELD PRESENT
         BAL   RL1,RSCNFLD1         OPTION (IF ANY)
         B     RSCNLOG             BR IF FIELD PRESENT
         BAL   RL1,RSCNFLD2        EXTRACT OUTPUT LIMIT
         B     RSCNLIM             BR IF FIELD PRESENT
         B     RSCNRET              AND TERMINATE ACCT FIELD SCAN
         SPACE 3                                                     R4
RSCNTGT1 CLI   $RJOBOPT,2          TEST JOB CARD SCAN OPTION         R4
         BL    RBADACCT            BR IF LESS THAN 2                 R4
         B     12(,RL1)             ELSE CONTINUE                    R4
         EJECT                                                       R4
RSCNLIM  LA    RL2,JCTLINCT        INITIALIZE STORE ADDRESS
         B     RSCNCKDG             AND GO TO CHECK FIELD LENGTH
         SPACE 1                                                     R4
RSCNCPY  LA    RL2,JCTCPYCT        INITIALIZE STORE ADDRESS
RSCNCKDG LR    RW,R0               SAVE VALUE PROVIDED
         SRA   RW,8                TEST VALUE
         BNZ   RSCNTGT3            BR IF VALUE GREATER THAN 255      R4
         STC   R0,0(,RL2)          STORE VALUE PROVIDED
         B     4(,RL1)              AND RESUME ACCT FIELD SCAN
         SPACE 1                                                     R4
RSCNLOG  LTR   R2,R2               TEST FIELD LENGTH
         BNZ   RSCNTGT3            BR IF MORE THAN ONE CHARACTER     R4
         CLI   RTEMP,C'N'          TEST FOR NOLOG OPTION
         BNE   4(,RL1)             RESUME ACCT FIELD SCAN IF NO
         OI    JCTJBOPT,JCTNOLOG   INDICATE NOLOG OPTION SPECIFIED
         B     4(,RL1)              AND RESUME ACCT FIELD SCAN
         SPACE 1                                                     R4
RSCNFLD1 LA    RL2,4               SET BR SW FOR CHARACTER FIELDS
         B     RSCNFLD3             AND BEGIN SCAN
         SPACE 1                                                     R4
RSCNFLD2 SLR   RL2,RL2             SET BR SW FOR NUMERIC FIELDS
RSCNFLD3 CLI   0(R1),255           TEST FOR END OF ACCOUNTING FIELD
         BE    RSCNRET             IF SO, TERMINATE SCAN
         CLI   0(R1),C''''         TEST FIRST CHAR OF FIELD
         BE    RSCNSPEC            BR IF FIELD ENCLOSED IN QUOTES
         LR    R14,R1              SAVE POINTER TO START OF FIELD
         TRT   0(144,R1),RALFATBL  SCAN TO FIRST NON-ALPHAMERIC CHAR
         LR    R0,R1               SAVE ADDRESS OF DELIMETER
         B     *(R2)               USE FUNCTION BYTE AS INDEX VALUE
         B     RSCNTGT2            BR IF INVALID CHARACTER IN FIELD  R4
         B     RSCNSIZE            DON'T INCREMENT IF AT END OF ACCT
         SPACE 1
RSCNNEXT LA    R1,1(,R1)           STEP PAST FIELD DELIMITER
RSCNSIZE SR    R0,R14              DETERMINE SIZE OF FIELD
         BZ    4(,RL1)             RETURN IF NULL FIELD
         BCTR  R0,0                DECREMENT FOR MACHINE LENGTH
         C     R0,RFOUR            TEST FIELD SIZE
         BL    *+8(RL2)            BR TO PROCESS IF VALID FLD SIZE
         B     RSCNTGT3             ELSE BR TO IGNORE FIELD          R4
         B     RSCNDIG             BR IF FIELD SHOULD BE NUMERIC
         MVC   RTEMP+1(3),RKBLANKS INSURE FIELD PADDED TO RIGHT
         LR    R2,R0               USE R2 FOR EXECUTE
         EX    R2,RMVCHAR          MOVE CHARACTERS FROM SUB-FIELD
         L     R0,RTEMP            GET FIELD TO R0
         BR    RL1                  AND RETURN
         SPACE 1
RSCNDIG  MVC   RTEMP(4),RZEROES    MOVE ZEROES TO WORK AREA
         MVZ   RTEMP(4),0(R14)     MOVE ZONES FROM SUB-FIELD
         LR    R2,R0               USE R2 FOR EXECUTES
         EX    R2,RTSTZNS          TEST FOR VALID DIGITS
         BNE   RSCNTGT3            BR IF NON-DIGIT CHARACTER IN FLD  R4
         EX    R2,RPACKNUM         CONVERT FIELD TO PACKED DECIMAL
         CVB   R0,RTEMP             AND THEN TO BINARY
         BR    RL1                 THEN RETURN TO CALLER
         EJECT                                                       R4
RSCNSPEC LA    R14,1(,R1)          SAVE ADDR OF FIRST CHAR AFTER QUOTE
         LA    R1,1(,R1)           POINT TO FIRST CHAR AFTER QUOTE
         TRT   0(144,R1),RSPECTBL  SCAN TO NEXT QUOTE OR DELIMITER
         B     *(R2)               USE FUNCTION BYTE AS INDEX VALUE
         B     RSCNTGT2            BR IF ILLEGAL CHARACTER           R4
         CLI   1(R1),C''''         TEST FOR DOUBLE QUOTES
         BNE   RSPECFLD            BR IF NO TO EXTRACT DATA
         BCTR  R15,0               SHIFT
         LR    R2,R15               REMAINING
         SLR   R2,R1                 CHARACTERS
         EX    R2,RSCNSHFT            LEFT
         B     RSCNSPEC+4          RESUME SCAN
         SPACE 1
RSPECFLD LR    R0,R1               SAVE END-OF-FIELD ADDRESS
         LA    R1,1(,R1)           STEP PAST CLOSING QUOTE
         CLI   0(R1),C','          TEST DELIMITER
         BE    RSCNNEXT            BR IF COMMA
         CLI   0(R1),255           TEST DELIMITER
         BE    RSCNSIZE            BR IF END OF ACCOUNTING FIELD
         SPACE 1                                                     R4
RSCNTGT2 CLI   $RJOBOPT,2          TEST JOB CARD SCAN OPTION         R4
         BNH   RBADACCT            BR IF 2 OR LESS TO ISSUE MSG      R4
         B     RSCNRET              ELSE JUST RETURN                 R4
         SPACE 1                                                     R4
RSCNTGT3 CLI   $RJOBOPT,2          TEST JOB CARD SCAN OPTION         R4
         BNL   4(,RL1)             BR IF 2 OR GREATER                R4
         SPACE 1                                                     R4
RBADACCT CLI   JCTJOBID,C'J'       TEST JOBID
         BNE   RSCNRET             IGNORE ERROR IF STC OR TSU
         BAL   RL1,RPUT            ADD JOB CARD TO OUTPUT FILE
         OI    RCARDLRC,LRC1CCTL+LRC1TASA  SET ASA CARR CNTRL  @OZ73741
         MVI   RDRCCTL,C'0'        FORCE DOUBLE SPACE          @OZ73741
         ST    RPI,RSAVE2          SAVE BUFFER POINTER         @OZ73741
         LA    RPI,RJBERMSG        POINT TO ERROR MESSAGE      @OZ73741
         BAL   RL1,RPUT            ADD MSG TO OUTPUT FILE      @OZ73741
         L     RPI,RSAVE2          RESTORE BUFFER POINTER      @OZ73741
         SPACE 1                                               @OZ73741
        $WTO   RJERRMSG,L'RJERRMSG,JOB=YES,              NOTIFY        C
               ROUTE=$LOG+$UR,CLASS=$TRIVIA,PRI=$ST       OPERATOR
         BAL   RL1,RJOBKILL        KILL JOB
         SPACE 1                                                     R4
RSCNRET  CLI   $RJOBOPT,1          TEST JOB CARD SCAN OPTION         R4
         BH    *+16                BR IF 2 OR MORE TO RETURN         R4
         CLI   RSAVE1,X'80'        TEST FOR ACCT AND RM NUMBERS
         MVI   RSAVE1,0            RESET IN ANY CASE
         BE    RBADACCT            BR IF EITHER FIELD MISSING
        $RETURN                    RETURN TO MAIN PROCESSOR
         EJECT                                                       R4
RALFATBL DC    91AL1(4),AL1(0,4,4,4,4,0),10AL1(4),AL1(12)
         DC    15AL1(4),AL1(0,0),68AL1(4),9AL1(0),7AL1(4),9AL1(0)
         DC    8AL1(4),8AL1(0),6AL1(4),10AL1(0),5AL1(4),AL1(8)
         SPACE 1
RSPECTBL DC    64AL1(4),AL1(0),10AL1(4),AL1(0,4,0,0,4,0),10AL1(4)
         DC    AL1(0,0,0,4,4,0,0),9AL1(4),AL1(0),15AL1(4)
         DC    AL1(0,0,8,0),66AL1(4),9AL1(0),7AL1(4),9AL1(0)
         DC    8AL1(4),8AL1(0),6AL1(4),10AL1(0),6AL1(4)
         SPACE 1
         SPACE 1
RMVCHAR  MVC   RTEMP(*-*),0(R14)       *** EXECUTE ONLY ***
RTSTZNS  CLC   RTEMP(*-*),RZEROES      *** EXECUTE ONLY ***
RSCNSHFT MVC   0(*-*,R1),1(R1)         *** EXECUTE ONLY ***
RPACKNUM PACK  RTEMP,0(*-*,R14)        *** EXECUTE ONLY ***
         SPACE 2
RFOUR    DC    F'4'                CONSTANT
RZEROES  DC    CL4'0000'           *
         SPACE 1                                               @OZ73741
RJBERMSG DC    30C'*',CL18' ILLEGAL JOB CARD ',31C'*',C' '     @OZ73741
         SPACE 5
         DROP  BASE3               DROP SEGMENT ADDRESSABILITY
         EJECT ,                                               @OZ62321
         SPACE 1                                               @OZ77019
         PUSH  PRINT               TURN PRINT OFF FOR          @OZ77019
         PRINT OFF                  SECTION DELETED BY APAR    @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
*              THIS LINE DELETED BY APAR OZ77019               @OZ77019
         POP   PRINT               RESET TO PRIOR PRINT OPT.   @OZ77019
         SPACE 1                                               @OZ77019
         SPACE 3                                               @OZ62321
HASPRDR  CSECT                     DEFINE SUBROUTINES RESIDENT
         TITLE 'HASP INPUT SERVICE -- FIRST LEVEL SUBROUTINES'
***********************************************************************
*                                                                     *
*        RCONTNUE -- SUBROUTINE TO READ CONTINUATION CARDS            *
*                                                                     *
*              FUNCTIONS -- 1) ADD PREVIOUS CARD TO JCL FILE          *
*                           2) GET NEXT CARD                          *
*                           3) VALIDATE COLUMNS 1-3 OF NEXT CARD      *
*                           4) LOCATE START OF VARIABLE FIELD         *
*                                                                     *
*              OUTPUT -- RW = POINTER TO VARIABLE FIELD               *
*                                                                     *
*              LINK REGISTER -- RL1                                   *
*                                                                     *
*              RETURNS -- RL1+0 - ERROR RETURN                        *
*                         RL1+4 - NORMAL REUTRN                       *
*                                                                     *
*              EXTERNAL ROUTINES -- 1) RPUT                           *
*                                   2) RGET                           *
*                                                                     *
***********************************************************************
         SPACE 5
RCONTNUE ST    RL1,RMESSAGE+36     SAVE LINK REGISTER
         BAL   RL1,RPUT            ADD PREVIOUS CARD TO JCL FILE
         BAL   RL1,RGET            GET NEXT CARD
         OI    RDRSW2,RCONTEOF+RCONTILL  INVALID CONT AT EOF   @OZ73741
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
*              THIS LINE DELETED BY APAR NUMBER                @OZ56465
         L     RL1,RMESSAGE+36     RESTORE LINK REGISTER
         OI    RCARDLRC,RDLMSKIP   BYPASS DLM TEST                   R4
         LTR   JCT,JCT             TEST ADDRESS OF JCT
         BZR   RL1                 BRANCH IF JOB HAS BEEN DELETED
         TM    RDRSW2,RCONTEOF     WAS THIS END OF FILE...     @OZ73741
         BO    RCONTNU6            BRANCH IF YES               @OZ76952
         TM    RDRSW,RJCLSW        TEST CURRENT MODE           @OZ56465
         BNO   RCONTNU5            BR IF NOT JCL FILE          @OZ56465
         L     RW,RDRIOT           ADDR OF 1ST IOT             @OZ56465
         AL    RW,$IOTPDDB         ADDR OF 1ST PDDB            @OZ56465
         L     R15,PDBRECCT-PDBDSECT+IOTPDBOJ(,RW) INCREMENT   @OZ56465
         LA    R15,1(,R15)                          JCL FILE   @OZ56465
         ST    R15,PDBRECCT-PDBDSECT+IOTPDBOJ(,RW)   REC CNT   @OZ56465
         EJECT                                                 @OZ56465
RCONTNU5 DS    0H                                              @OZ56465
         CLC   0(3,RPI),=CL3'//*'  CHECK COLUMNS 1-3
         BE    RCONTNUE            IGNORE JCL COMMENT
         CLC   0(3,RPI),=CL3'//'   CHECK COLUMNS 1-3
         BE    RCONTNU2            CONT. IF VALID CONT.        @OZ38384
         OI    RDRSW2,RCONTILL     INDICATE ILLEGAL CONT       @OZ73741
*                                                              @OZ38384
*        IF THE ILLEGAL CONTINUATION IS ON A JOB CARD,         @OZ38384
*        INDICATE END OF JOB CARD PROCESSING.                  @OZ38384
*                                                              @OZ38384
RCONTNU6 TM    RPASPROC,$RJOBFND   IS THIS A JOB CARD...       @OZ76952
         BZR   RL1                 EXIT IF NOT JOB CARD        @OZ38384
         OI    RPASPROC,$RJOBECD   INDICATE END OF CARD PROC.  @OZ38384
         BR    RL1                 AND GO TO OUTPUT PROC.      @OZ38384
         SPACE 2
RCONTNU2 LA    R1,12               GET LNG OF VARIABLE START   @OZ38384
         LA    RW,9(,RPI)          SET UP POINTER
         SR    RW,R1                TO COLUMN 4
         LA    R14,1               SET INCREMENT FOR SCAN
         SPACE 2
RCONTNU1 CLI   6(RW),C' '          SCAN COLUMNS 4-15
         BNE   4(,RL1)              TO DETERMINE
         LA    RW,1(,RW)             START OF
         BCT   R1,RCONTNU1            VARIABLE FIELD
         B     4(,RL1)             NOT FOUND, ASSUME COLUMN 16
         EJECT
***********************************************************************
*                                                                     *
*        RJOBEND -- SUBROUTINE TO COMPLETE JOB INPUT PROCESSING       *
*                                                                     *
*              FUNCTIONS -- 1) TEST FOR ACTIVE JOB                    *
*                           2) TERMINATE JOB                          *
*                           3) PLACE JOB IN EXECUTION QUEUE           *
*                                                                     *
*              LINK REGISTER -- RL1                                   *
*                                                                     *
*              EXTERNAL ROUTINES -- 1) RJCTTERM                       *
*                                   2) RJOBTERM                       *
*                                                                     *
***********************************************************************
         SPACE 5
RJOBEND  LTR   JCT,JCT             TEST FOR ACTIVE JOB
         BZR   RL1                 RETURN IF NO JCT
         SPACE 1                                                     R4
RJOBENDT BAL   RL2,RJCTTERM        PERFORM FINAL UPDATE OF JCT       R4
         IC    RW,JCTIPRIO         SET INITIAL PRIORITY        @OZ29304
         CLI   JCTIPRIO,C'*'       DEFAULT PRIORITY CHANGED..  @OZ29304
         BNE   RPRISET             DO NOT UPDATE               @OZ29304
         SPACE 2
         TM    JCTJBOPT,JCTPRICD   BRANCH IF NEITHER /*PRIO CARD     R4
         BZ    RPRISCH0              NOR JOB CARD PRTY FIELD         R4
         PACK  RTEMP,RPRIORTY      CONVERT EBCDIC PRIROITY           R4
         CVB   RW,RTEMP              TO BINARY                       R4
         B     RPRISET             PROCESS INCR AND LIMIT            R4
         SPACE 2
RPRISCH0 L     R1,$RTIMTAB         PREPARE TO SEARCH                 R4
         B     SKIP260              TIME PRIORITY TABLE              R4
RPRISCH1 LA    R1,4(,R1)           ADVANCE TO NEXT ENTRY
SKIP260  CLC   JCTETIME+1(3),1(R1) COMPARE ESTIMATED EXECUTION TIME
         BH    RPRISCH1            BRANCH IF GREATER THAN TABLE ENTRY
         SR    R0,R0               NO
         IC    R0,0(,R1)           USE ASSOCIATED PRIORITY
         SPACE 2
         L     R1,$SSVT               PREPARE TO SEARCH              R4
         LA    R1,$SVXPRI-SSVT-4(,R1)  OUTPUT PRIORITY TABLE         R4
RPRISCH2 LA    R1,4(,R1)           ADVANCE TO NEXT ENTRY
         CLC   JCTESOUT+1(3),1(R1) COMPARE ESTIMATED OUTPUT
         BH    RPRISCH2            BRANCH IF GREATER THAN TABLE ENTRY
         SR    RW,RW               NO
         IC    RW,0(,R1)           USE ASSOCIATED PRIORITY
         SRL   RW,4                 IN 'PURE' FORM                   R4
         ALR   RW,R0               COMPUTE AVERAGE OF
         SRL   RW,1                 THE TWO PRIORITIES
         EJECT
RPRISET  N     RW,=F'15'           CLEAR EXTRANEOUS BITS
         L     R1,PCEDCT           R1 = ADDRESS OF INPUT DCT   @OZ32566
         USING DCTDSECT,R1         ESTABLISH DCT ADDRESSABILITY
         IC    R0,DCTPRINC         R0 = INPUT DEVICE PRIORITY INCREMENT
         ALR   RW,R0               INCREMENT PRIORITY
         CLM   RW,1,DCTPRLIM       COMPARE PRIORITY WITH LIMIT
         BNH   *+8                 BR IF PRIORITY NOT GREATER
         IC    RW,DCTPRLIM         SET PRIORITY TO LIMIT
         DROP  R1                  DROP DCT ADDRESSABILITY
         SPACE 2
         SLL   RW,4                USE FOUR LOW-ORDER BITS
         STC   RW,JCTIPRIO         SAVE INITIAL EXECUTION PRIORITY
         STC   RW,RMESSAGE         SAVE FOR LATER USE
         SPACE 2
         MVI   RMESSAGE+1,$XEQ     PRESET CONVERTER CLASS
         TM    RDRSW,RXBJOBSW      TEST JOB TYPE
         BZ    RNOXBACH            BRANCH IF NOT EXECUTION BATCHING
         OC    RMESSAGE+1(1),JCTJCLAS  SET JOB QUEUE TYPE
         NI    RMESSAGE+1,QUECLASS RESET HIGH-ORDER BYTE
         SPACE 2
RNOXBACH NULL                      *                                 R4
SKIP270  TM    JCTJOBFL,JCTTCOPY   TEST JOB FLAGS                    R4
         BZ    *+12                BRANCH IF NOT 'TYPRUN=COPY'
         NI    RDRSW2,255-RTPCPY   RESET TYPRUN=COPY FLAG.     @OZ48524
         MVI   RMESSAGE+1,$OUTPUT  RESET QUEUE TYPE TO OUTPUT
         BAL   RL2,RJOBTERM        TERMINATE JOB
         SPACE 2                                                     R4
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         L     R1,PCEJQE           GET JQE ADDRESS             @OZ32566
         USING JQEDSECT,R1         ESTABLISH JQE ADDRESSABILITY
         MVC   JQEPRIO,RMESSAGE    SET NEW PRIORITY
         MVC   JQEFLAG2,RDRSIAFF   RESET SYSTEM AFFINITY
         SR    R0,R0               GET NEXT
         IC    R0,RMESSAGE+1        JOB QUEUE TYPE
        $QMOD  (R1),(R0)           QUEUE JOB FOR EXECUTION SERVICES
         DROP  R1                  DROP JQE ADDRESSABILITY
         SR    R0,R0               CLEAR ADDRESS
         ST    R0,PCEJQE            OF JOB QUEUE ELEMENT       @OZ32566
         BR    RL1                   AND RETURN
         EJECT
***********************************************************************
*                                                                     *
*        RGET -- SUBROUTINE TO GET NEXT CARD FROM INPUT BUFFER        *
*                                                                     *
*              FUNCTION -- SET INPUT POINTER TO NEXT CARD             *
*                                                                     *
*              OUTPUT -- RPI = ADDRESS OF NEXT CARD IMAGE             *
*                                                                     *
*              LINK REGISTER -- RL1                                   *
*                                                                     *
*              RETURNS -- RL1+0 - END OF FILE RETURN                  *
*                         RL1+4 - NORMAL RETURN                       *
*                                                                     *
*              EXTERNAL ROUTINE -- RJOBKILL                           *
*                                                                     *
***********************************************************************
         SPACE 5
RGET     TM    RDRSW,RSYSINSW      TEST FOR GENERATED DD *
         BZ    RGET1               BRANCH IF NOT
         L     RPI,RSAVE1          YES, RESTORE ORIGINAL POINTER
         NI    RDRSW,255-RSYSINSW  RESET INDICATION
         B     4(,RL1)              AND RETURN
         SPACE 3                                                     R4
RGET1    LTR   JCT,JCT             TEST FOR ACTIVE JOB
         BZ    RGETNOCT            DO NOT COUNT IF NO JCT
         L     RW,JCTCARDS         INCREMENT
         LA    RW,1(,RW)            CARD
         ST    RW,JCTCARDS           COUNT
         SPACE 1                                                     R4
RGETNOCT MVI   RCARDLRL,80         PRESET CARD LENGTH TO 80          R4
         TM    PCEID,PCERJEID      TEST DEVICE TYPE                  R4
         BO    RJEGET              BRANCH IF REMOTE READER           R4
         TM    PCEID,PCEINRID      NO, TEST AGAIN                    R4
         BZ    RDRGET              BRANCH IF NOT INTERNAL READER     R4
         EJECT                                                       R4
*                                                                    R4
*                             INTERNAL READER PROCESSING             R4
*                                                                    R4
         L     RW,PCEDCT           RW = ADDRESS OF INTRDR DCT  @OZ32566
         USING DCTDSECT,RW         ESTABLISH DCT ADDRESSABILITY      R4
         SPACE 1                                                     R4
RINRLOOP DS    0H
         L     R1,PCEJQE           GET JQE ADDRESS             @OZ32566
         LTR   R1,R1               TEST
         BZ    RINRTEST            BRANCH IF NO ACTIVE JOB
         USING JQEDSECT,R1         ESTABLISH JQE ADDRESSABILITY
         TM    JQEFLAGS,QUEOPCAN   TEST JOB QUEUE FLAGS
         BO    RINRDEL             BRANCH IF JOB CANCEL
         DROP  R1                  DROP JQE ADDRESSABILITY
         SPACE 2                                                     R4
RINRTEST TM    DCTFLAGS,DCTDELET+DCTRSTRT TEST FOR OPERATOR COMMANDS
         BNZ   RINRDEL             BRANCH IF OPERATOR CANCEL
         TM    RDRSW,RDREOFSW      TEST END-OF-FILE SWITCH
         BOR   RL1                 RETURN IF ON
         L     RL2,RIDPBFO         GET NEXT RECORD POINTER
         LTR   RL2,RL2             TEST
         BZ    RINRWAIT            BRANCH IF ZERO
         USING LRCDSECT,RL2        ESTABLISH LOGICAL RECORD ADDR.
         CLI   LRCTLENG,LRCBFEND   TEST RECORD LENGTH
         BE    RINRWAIT            BRANCH IF END-OF-BLOCK
         MVC   RINFLAG1,LRCFLAG1   SAVE RECORD CHARACTERISTICS       R4
         NI    RINFLAG1,LRC1CCTL+LRC1CTYP  ISOLATE CARRIAGE CONTROL  R4
         MVC   RCARDLRL,LRCLRECL   SAVE LOGICAL RECORD LENGTH
         LR    R0,RPI              R0 = ADDRESS OF INTRDR WORK AREA
         LA    R1,256              LENGTH OF INTRDR WORK AREA  @OZ61967
         LA    R14,LRCTEXT         R14 = ADDRESS OF BLOCKED RECORD
         TM    LRCFLAG1,LRC1CCTL   TEST RECORD CONTROL BYTE
         BZ    RINRNOCC            BRANCH IF NO CARRIAGE CONTROL     R4
         MVC   RDRCCTL,0(R14)      SAVE CARRIAGE CONTROL CHARACTER   R4
         LA    R14,1(,R14)         SPACE OVER CARRIAGE CONTROL CHAR.
RINRNOCC CLR   R14,RPI             TEST ADDRESS                      R4
         BNL   RINRWAIT            BRANCH IF INVALID
         L     R15,=XL4'40000000'  R15 = BLANK PAD CHARACTER
         IC    R15,LRCTLENG        ADD LOGICAL RECORD LENGTH
         MVCL  R0,R14              MOVE RECORD TO INTRDR WORK AREA
         ST    R14,RIDPBFO         UPDATE RECORD POINTER
         DROP  RL2                 DROP LOGICAL RECORD ADDRESSABILITY
         CLC   0(6,RPI),=CL6'/*EOF'  TEST FOR INTERNAL READER EOF
         BE    RINREOF             BRANCH IF YES
         CLC   0(7,RPI),=CL7'/*SCAN'  TEST FOR INTERNAL READER SCAN
         BE    RINRSCAN            BRANCH IF NOT
         CLC   0(6,RPI),=CL6'/*DEL'  TEST FOR INTERNAL READER DELETE
         BE    RINRDELP            BRANCH IF YES                    R41
         CLC   0(8,RPI),=CL8'/*PURGE' TEST FOR INTERNAL RDR PURGE   R41
         BNE   4(,RL1)             TAKE NORMAL RETURN IF NOT
         OI    RDRSW,RJNABORT      SET PURGE FLAG                   R41
         SPACE 1                                                    R41
RINRDELP NI    RDRSW,255-RNOSCAN   TURN ON CARD SCAN                R41
         EJECT                                                       R4
*
*                             DELETE JOB ON INTERNAL READER
*
RINRDEL  DS    0H
         ST    RL1,RLSAVE1         SAVE RETURN REGISTER
         BAL   RL1,RJOBKILL        DELETE JOB
         L     RL1,RLSAVE1         RESTORE RETURN REGISTER
         L     RW,PCEDCT           RESTORE ADDRESS OF DCT      @OZ32566
         NI    DCTFLAGS,255-DCTDELET-DCTRSTRT  RESET OPERATOR FLAGS
         B     RINRTEST            GET NEXT RECORD
*
*                             SCAN JOB ON INTERNAL READER
*
RINRSCAN DS    0H
         LTR   JCT,JCT             TEST FOR ACTIVE JOB
         BZ    RINRTEST            BRANCH IF NO JCT
         OI    JCTJOBFL,JCTTSCAN   FORCE 'TYPRUN=SCAN'
         B     RINRLOOP            GET NEXT RECORD
*
*                             WAIT FOR DIRECTION FROM SSSM
*
RINRWAIT DS    0H
         TM    RIDFLAGS,RIDEOM     IF SSSM IN MEMORY TERM.     @OZ37382
         BO    RINREOF             GO TO CLEAN UP              @OZ37382
         OI    RIDFLAGS,RIDBUSY    PERMIT SSSM TO OPERATE
         $XMPOST RIDECBP           POST SSSM
RINRW1   $WAIT IO                  $WAIT FOR INPUT FROM SSSM
         TM    RIDFLAGS,RIDEND     DID SSSM TERMINATE INTRDR
         BO    RINREOF             BRANCH IF YES
         TM    RIDFLAGS,RIDBUSY    HAS SSSM COMPLETED ITS WORK
         BZ    RINRLOOP            GET NEXT RECORD IF SO
         B     RINRW1              OTHERWISE WAIT AGAIN
*
*                             END-OF-FILE ON INTERNAL READER
*
RINREOF  OI    RDRSW,RDREOFSW      SET END-OF-FILE SWITCH
         B     RINRTEST            GO CHECK FOR CANCEL         @OZ29612
         DROP  RW                  DROP DCT ADDRESSABILITY           R4
         EJECT                                                       R4
RJEGET   TM    RDRSW,RDREOFSW      TEST END-OF-FILE SWITCH           R4
         BNZR  RL1                 RETURN IF ON                      R4
         MVI   RTPCARD,C' '        BLANK OUT INPUT AREA        @OZ43908
         MVC   RTPCARD+1(255),RTPCARD                          @OZ43908
        $EXTP  GET,PCEDCT,RTPCARD  GET CARD IMAGE FROM RTAM    @OZ32566
         BP    RDCKCOM             BRANCH IF SUCCESSFUL              R4
         OI    RDRSW,RDREOFSW      SET END-OF-FILE SWITCH            R4
         B     RDCKCOM             CHECK FOR OPERATOR COMMANDS       R4
         SPACE 1                                                     R4
RDRGET   LA    RPI,80(,RPI)        ADVANCE INPUT PTR TO NEXT CARD    R4
         SPACE 1                                                     R4
RGETEST  CL    RPI,RBIEND          TEST FOR END OF BUFFER
         BNH   4(,RL1)             BRANCH IF NOT END OF BUFFER
         TM    RDRSW,RDREOFSW      TEST FOR READER EOF
         BNZR  RL1                 RETURN IF READER EOF
         CLI   BUFECBCC,X'7F'      TEST FOR CARD READER ERROR
         BE    READ                BRANCH IF NO ERROR
         ST    RL1,RLSAVE1         SAVE LINK REGISTER
         BAL   RL1,RJOBKILL        KILL JOB IN ERROR
         L     RL1,RLSAVE1         RESTORE LINK REGISTER
         TM    IOBCSW+4,X'3F'      CHANNEL ERRORS...           @OZ48423
         BNZ   RDABORT             BR IF YES...STOP READER     @OZ48423
         L     R1,PCEDCT           GET ADDRESS OF INPUT DCT    @OZ32566
         L     R1,DCTDCB-DCTDSECT(,R1)  GET ADDRESS OF DCB
         L     R1,DCBDEBAD-DCBDSECT(,R1)  GET ADDRESS OF DEB
         L     R1,DEBSUCBA-DEBDSECT(,R1)  GET ADDRESS OF UCB
         TM    UCBFLB-UCBDSECT(R1),UCBIORST  TEST UCB STATUS
         BZ    READ                BR IF DEVICE STILL ACCESSIBLE     R4
         CLC   $RELSE,=C'02'       TEST OS/VS2 RELEASE NUMBER  @OZ35278
         BE    RDABORT             BR IF RELEASE 2                   R4
         L     R15,CVTPTR          GET ADDRESS OF CVT                R4
         CLC   CVTCRCA-CVT(,R15),=XL4'0'  TEST RECOVERY MODE         R4
         BE    RDABORT             BR IF DEVICE NOT ACCESSIBLE       R4
         SPACE 1                                                     R4
READ    $EXCP  PCEDCT              INITIATE CARD READ PROGRAM  @OZ32566
         SPACE 1                                                     R4
RWAIT   $WAIT  IO                  WAIT FOR COMPLETION OF READ
         SPACE 1                                                     R4
RDCKCOM  L     R1,PCEDCT           R1 = READER DCT ADDRESS     @OZ32566
         USING DCTDSECT,R1         ESTABLISH DCT ADDRESSABILITY
         TM    DCTFLAGS,DCTSTOP    TEST FOR STOP COMMAND
         BO    RWAIT               BRANCH IF STOP COMMAND
         TM    DCTFLAGS,DCTDELET+DCTRSTRT    TEST FOR DELETE
         BNZ   RDELETE             BRANCH IF DELETE OR RESTART
         TM    PCEID,PCERJEID      IF LOCAL READER...          @OZ31782
         BZ    RAROUND1            ...THIS IS VALID            @OZ31782
         TM    MDCTSTAT,DCTABORT   IS REMOTE DISCONNECTED...   @OZ31782
         BO    RDELETE             YES, THIS IS NOT VALID      @OZ31782
RAROUND1 DS    0H                                              @OZ31782
         L     R15,PCEJQE          GET JQE ADDRESS             @OZ32566
         LTR   R15,R15             TEST
         BZ    RDNOCOM             BRANCH IF NO ACTIVE JOB
         USING JQEDSECT,R15        ESTABLISH JQE ADDRESSABILITY
         TM    JQEFLAGS,QUEOPCAN   TEST JOB QUEUE FLAGS
         BZ    RDNOCOM             BRANCH IF NO JOB CANCEL
         DROP  R15                 DROP JQE ADDRESSABILITY
         SPACE 2                                                     R4
RDELETE  DS    0H                                                    R4
SKIP310  NI    DCTFLAGS,255-DCTDELET-DCTRSTRT    TURN OFF FLAGS      R4
*                                  THIS LINE DELETED BY APAR   @OZ29180
         ST    RL1,RLSAVE1         SAVE LINK REGISTER
         BAL   RL1,RJOBKILL        DELETE JOB
         L     RL1,RLSAVE1         RESTORE LINK REGISTER
         SPACE 1                                                     R4
RDNOCOM  TM    PCEID,PCERJEID      IS THIS A REMOTE TERMINAL         R4
         BZ    RNOTRJE4            BRANCH IF NOT                     R4
         MVC   RCARDLRL,MDCTRECL   SET RECORD LENGTH           @OZ29180
         ST    RL1,RLSAVE4         SAVE LINK REG               @OZ43908
         ICM   RL1,15,RDPDBSV      GET SAVED PDDB ADDRESS      @OZ43908
         BZ    RDNOPDB             NO PDDB, DON'T UPDATE IT    @OZ43908
         MVC   PDBLRECL+1-PDBDSECT(1,RL1),RCARDLRL FIX LRECL   @OZ43908
         XC    RDPDBSV,RDPDBSV     CLEAN UP PDDB SAVE AREA     @OZ43908
RDNOPDB  L     RL1,RLSAVE4         RESTORE LINK REG            @OZ43908
         TM    RDRSW,RDREOFSW      TEST END-OF-FILE SWITCH           R4
         BZ    4(,RL1)             NORMAL RETURN IF NO END-OF-FILE   R4
         BR    RL1                 OTHERWISE, TAKE END OF FILE RETURN
         SPACE 1                                               @OZ29180
         DROP  R1                  KILL DCT BASE               @OZ29180
         SPACE 3                                                     R4
RNOTRJE4 TM    BUFECBCC,X'7F'      TEST FOR READ COMPLETE            R4
         BZ    RWAIT               BRANCH IF READ NOT COMPLETE
         TM    IOBCSW+4,X'3F'      CHANNEL ERRORS...           @OZ48423
         BZ    RNTCHERR            BR IF NOT                   @OZ48423
         MVI   IOBCSW+3,X'00'      ENSURE I/O ERROR MSG        @OZ48423
         B     RCHERR              ENSURE BUFFER READ STOPS    @OZ48423
RNTCHERR DS    0H                                              @OZ48423
         XI    IOBSIOCC,RSIOCSWS   TEST FOR
         TM    IOBSIOCC,RSIOCC     SUCCESSFUL SIO
         BNZ   RDTEST              BRANCH IF NO CSW STORED
RCHERR   DS    0H                                              @OZ48423
         XC    IOBCSW(3),IOBCSW    INSURE COMMAND ADDRESS IS ZERO
         MVI   BUFECBCC,X'41'      INSURE UNSUCCESSFUL READ COMPLETION
         SPACE 1                                                     R4
RDTEST   CLI   BUFECBCC,X'7F'      TEST COMPLETION CODE
         BE    RCOMP               BRANCH IF SUCCESSFUL READ COMPLETION
         TM    IOBCSW+3,RUNIEXCP   TEST CSW IN IOB FOR UNIT EXCEPTION
         BZ    RDERR               BR IF READ ERROR                 R41
         SPACE 1                                                     R4
RDABORT  OI    RDRSW,RDREOFSW      SET READER END-OF-FILE SWITCH
         B     RCOMP               CONTINUE PROCESSING              R41
         SPACE 1                                                     R4
RDERR   $IOERROR (R3)              LOG I/O ERROR                    R41
         SPACE 1                                               @OZ48423
RCOMP    L     RW,IOBCSW-1         GET CSW CMD ADDR FROM IOB CSW
         LA    RW,0(,RW)           CLEAR HIGH-ORDER BYTE
         LTR   RW,RW               TEST COMMAND ADDRESS
         BZ    RCOMPZ              BRANCH IF ZERO
         AL    RW,=F'-8'           ADJUST TO POINT TO LAST COMMAND
         L     R1,0(,RW)           GET COMMAND DATA ADDRESS
         AH    R1,6(RW)            ADD COMMAND BYTE COUNT
         SH    R1,IOBCSW+5         SUBTRACT BYTE COUNT RESIDUE
         SL    R1,=F'80'           COMPUTE ADDRESS OF LAST CARD
         LA    RW,0(,R1)           CLEAR HIGH-ORDER BYTE
         SPACE 1                                                     R4
RCOMPZ   ST    RW,RBIEND           SAVE FOR COMPARE
         L     RPI,RIBUFST         SET INPUT POINTER                 R4
         ALR   RPI,RBI              TO FIRST CARD                    R4
         B     RGETEST             GO BACK AND TEST
         EJECT
***********************************************************************
*                                                                     *
*        RPUT -- SUBROUTINE TO ADD CARD TO OUTPUT BUFFER              *
*                                                                     *
*              FUNCTIONS -- 1) IF OUTPUT BUFFER IS FULL, TERMINATE    *
*                              WRITE, AND START NEXT OUTPUT BUFFER    *
*                           2) ADD CARD TO OUTPUT BUFFER              *
*                                                                     *
*              LINK REGISTER -- RL1                                   *
*                                                                     *
*              EXTERNAL ROUTINE -- RGETBUF                            *
*                                                                     *
***********************************************************************
         SPACE 3                                                    R41
RPUT     LTR   JCT,JCT             TEST FOR JOB                      R4
         BZ    RESETYPE            BRANCH IF FLUSHING
         TM    RPASPROC,$RJOBFND+$RJOBECD IS THIS A JOB CARD   @OZ59443
         BZ    RPUT1               GO ADD TO OUTPUT IF NOT     @OZ59443
         SPACE 1                                               @OZ61577
         L     R15,=A(RPUTSCAN)    GO CHECK FOR AND CROSS OUT  @OZ61577
         BALR  R14,R15              ANY 'PASSWORD=' PARAMETER  @OZ61577
         SPACE 1                                               @OZ59443
         NI    RPASPROC,X'FF'-$RJOBECD  RESET END-OF-JOB-CARD  @OZ61577
*                                        FLAG                  @OZ61577
         SPACE 1                                               @OZ61577
RPUT1    DS    0H                                              @OZ59443
         L     R1,RBONEXT          GET OUTPUT POINTER
         TM    RCARDLRC,RDLMSKIP   TEST DELIMITER BYPASS SWITCH      R4
         BO    RPUTNOCT            IGNORE DELIMITER IF SET           R4
         CLC   0(2,RPI),RDRDLM     TEST FOR DELIMITER CARD           R4
         BNE   RPUTEST             BRANCH IF NOT                     R4
         TM    RDRSW2,RTPCPY       IF TYPRUN=COPY, BYPASS      @OZ53356
         BO    RPUTNOCT             COUNT UPDATE               @OZ53356
         TM    RDRSW,RXBJOBSW      TEST FOR EXECUTION BATCHING
         BZ    RPUTERM             BRANCH IF NOT
         SPACE 2
RPUTEST  TM    RDRSW,RJCLSW        TEST CURRENT MODE
         BNO   RPUTINCR            BR IF NOT JCL FILE               R41
         L     RW,RDRIOT           ADDR OF 1ST IOT                  R41
         AL    RW,$IOTPDDB         ADDR OF 1ST PDDB                 R41
         L     R15,PDBRECCT-PDBDSECT+IOTPDBOJ(,RW)  INCREMENT       R41
         LA    R15,1(,R15)                           JCL FILE       R41
         ST    R15,PDBRECCT-PDBDSECT+IOTPDBOJ(,RW)    RECORD COUNT  R41
         B     RPUTNOCT            BR TO CONTINUE                   R41
         SPACE 1                                                    R41
RPUTINCR L     RW,JCTJOBIN         INCREMENT                        R41
         LA    RW,1(,RW)            SYSIN
         ST    RW,JCTJOBIN           COUNT
         SPACE 2
RPUTNOCT NI    RCARDLRC,255-RDLMSKIP  RESET DLM BYPASS SWITCH        R4
         LA    R15,0(,RPI)         ELIMINATE TRAILING BLANKS         R4
         BCTR  R15,0               SET SCAN LIMIT
         L     R14,=F'-8'          SET SCAN DECREMENT TO -8
         LA    RW,80               ASSUME JCL FILE
         TM    RDRSW,RJCLSW        TEST CURRENT MODE
         BO    RPUTJCL             FORCE JCL LRECL TO 80
         IC    RW,RCARDLRL         GET LOGICAL RECORD LENGTH
         LA    RW,7(,RW)            AND
         NR    RW,R14                ROUND TO DOUBLE WORD
         TM    RCARDLRC,LRC1INUL+LRC1ONUL  TEST RECORD CONTROL BYTE  R4
         BO    RPUTJCL             BRANCH IF CONTROL RECORD          R4
         OC    RCARDLRC,RINFLAG1   ADD INPUT FLAGS TO LRC            R4
         SPACE 1                                               @OZ59443
RPUTJCL  LA    RW,0(RW,RPI)        SET SCAN POINTER TO END OF RECORD
         BXLE  RW,R14,RPUTBLNK     DECREMENT POINTER BY EIGHT
         CLC   0(8,RW),RKBLANKS    CHECK FOR DOUBLE WORD OF BLANKS
         BE    *-10                IF EIGHT BLANKS, KEEP GOING
         SLR   RW,R14              NO, INCREMENT POINTER BY EIGHT
         L     R14,=F'-1'          RESET SCAN DECREMENT TO -1
         BXLE  RW,R14,RPUTBLNK     DECREMENT POINTER BY ONE
         CLI   0(RW),C' '          CHECK FOR BLANK
         BE    *-8                 IF BLANK, KEEP GOING
         SR    RW,R15              GENERATE TRUNCATED LENGTH
         BP    *+8                 BYPASS SPECIAL PROCESSING
RPUTBLNK LA    RW,1                FORCE ALL-BLANK CARD TO ONE BLANK
         STC   RW,RCARDLEN         SET CARD LENGTH
         TM    RCARDLRC,LRC1CCTL   TEST RECORD CONTROL BYTE          R4
         BZ    SKIP320             BRANCH IF NO CARRIAGE CONTROL     R4
         LA    RW,1(,RW)           BUMP LENGTH FOR CARRIAGE CONTROL  R4
SKIP320  ALR   RW,R1               ADD CURRENT POINTER
         CL    RW,RBOEND           TEST FOR END OF OUTPUT BUFFER
         BL    RPUTCOPY            BRANCH IF NOT END OF BUFFER
         MVI   0(R1),X'FF'         SET LAST RCB
         BAL   RL2,RTRACK          GET NEXT TRACK ADDRESS
         L     RW,RDROBUF          GET ADDRESS OF BUFFER             R4
         ST    RW,PCEBUFAD         SET BUFFER ADDRESS FOR $EXCP      R4
         MVC   PCESEEK,RBUFTRK(RW)  SET TRACK ADDRESS FOR $EXCP      R4
         ST    R1,RBUFTRK(,RW)     SET CHAIN TRACK                   R4
         LR    RW,R1               SAVE NEXT TRACK
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE
         BAL   RL2,RGETBUF         GET NEXT BUFFER
         SPACE 2                                                     R4
RPUTCOPY MVC   0(3,R1),RCARDLEN    SET RECORD LENGTH, LRC, AND LRECL R4
         TM    RDRSW,RJCLSW        TEST CURRENT MODE                 R4
         BZ    RPUTNJCL            BRANCH IF NOT JCL FILE            R4
         MVI   LRCLRECL-LRCDSECT(R1),80  FORCE JCL LRECL TO 80       R4
         TM    RCARDLRC,LRC1CCTL   TEST RECORD CONTROL BYTE          R4
         BZ    RPUTNOCC            BRANCH IF NO CARRIAGE CONTROL     R4
         MVI   LRCLRECL-LRCDSECT(R1),80  FORCE LRECL TO 80.    @OZ26206
         SPACE 1                                                     R4
RPUTNJCL TM    RCARDLRC,LRC1CCTL   TEST RECORD CONTROL BYTE          R4
         BZ    RPUTNOCC            BRANCH IF NO CARRIAGE CONTROL     R4
         MVC   LRCCCTL-LRCDSECT(,R1),RDRCCTL  SET CARRIAGE CONTROL   R4
         LA    R1,1(,R1)           INCREMENT TEXT ADDRESS            R4
         SPACE 1                                                     R4
RPUTNOCC SLR   R15,R15             CLEAR REGISTER                    R4
         IC    R15,RCARDLEN        GET CARD LENGTH                   R4
         EX    R15,RPUTMOVE        MOVE TEXT                         R4
         LA    R1,3(R1,R15)        ADVANCE                           R4
         ST    R1,RBONEXT           OUTPUT POINTER                   R4
         SPACE 1                                                     R4
RESETYPE MVI   RCARDLRC,0          RESET CARD TYPE
         BR    RL1                 RETURN
         SPACE 1                                               @OZ59443
RPUTERM  MVI   0(R1),X'FF'         SET LAST RCB
         L     R1,RDROBUF          GET BUFFER ADDRESS                R4
         ST    R1,PCEBUFAD         SET BUFFER ADDRESS FOR $EXCP      R4
         MVC   PCESEEK,RBUFTRK(R1)  SET TRACK ADDRESS FOR $EXCP      R4
         SR    RW,RW               TERMINATE
         ST    RW,RBUFTRK(,R1)      TRACK CHAIN                      R4
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE
         L     R1,RDRIOT2          GET LAST IOT PRODUCED       @OZ65152
*              THIS LINE DELETED BY APAR OZ65152               @OZ65152
*              THIS LINE DELETED BY APAR OZ65152               @OZ65152
*              THIS LINE DELETED BY APAR OZ65152               @OZ65152
*              THIS LINE DELETED BY APAR OZ65152               @OZ65152
         L     RW,IOTPDDBP-IOTDSECT(,R1)  RW = ADDRESS OF
         ALR   RW,R1                       CURRENT PDDB
         L     R0,JCTJOBIN         GET CURRENT CARD COUNT
         S     R0,PDBRECCT-PDBDSECT(,RW)  COMPUTE DATA SET CARD COUNT
         ST    R0,PDBRECCT-PDBDSECT(,RW)   AND STORE IN PDDB
         LA    RW,PDBLENG(,RW)     ADVANCE TO NEXT PDDB
         SLR   RW,R1               GET DISPLACEMENT
         ST    RW,IOTPDDBP-IOTDSECT(,R1)  SAVE PDDB DISPLACEMENT
         MVC   RDRDSKEY,=H'1'      SET JCL DATA KEY
         L     RW,RJCLTRAK         RW = NEXT JCL TRACK
         BAL   RL2,RGETBUF         GET NEXT JCL BUFFER
         BR    RL1                 RETURN
         PRINT OFF                                             @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
         PRINT ON                                              @OZ61577
         SPACE 3                                               @OZ59443
*        EXECUTE  ONLY                                               R4
RPUTMOVE MVC   3(*-*,R1),0(RPI)    INSTRUCTION TO MOVE TEXT          R4
*        THIS LINE DELETED BY APAR NUMBER                      @OZ61577
         EJECT
***********************************************************************
*                                                                     *
*        RKEYSCAN -- SUBROUTINE TO SCAN AND PROCESS KEYWORD VALUES    *
*                                                                     *
*              FUNCTIONS -- 1) SCAN AND IDENTIFY KEYWORD FROM CALLER  *
*                              PROVIDED CONTROL CARD SCAN TABLE       *
*                           2) SCAN KEYWORD VALUE AND CONVERT         *
*                              ACCORDING TO CONTROL CARD SCAN ENTRY   *
*                           3) STORE CONVERTED VALUE IN CALLER        *
*                              PROVIDED OUTPUT TABLE                  *
*                                                                     *
*              INPUTS -- R1  = ADDRESS OF CONTROL CARD SCAN TABLE     *
*                        RW  = POINTER TO PARAMETER FIELD             *
*                        R14 = BINARY 1                               *
*                        R15 = ADDRESS OF END OF INPUT FIELD          *
*                                                                     *
*              LINK REGISTER -- RL1                                   *
*                                                                     *
*              RETURNS -- RL1+0 - ERROR RETURN                        *
*                         RL1+4 - NORMAL RETURN                       *
*                                                                     *
***********************************************************************
         SPACE 5
RKEYSCAN NULL                      TABLE DIRECTED KEYWORD SCAN ROUTINE
         ST    R1,PCER1            SAVE INPUT REGISTER
         ST    RL1,PCEWA           SAVE LINK REGISTER
         BXH   RW,R14,4(RL1)       SEARCH FOR
         CLI   1(RW),C' '           START OF
         BE    *-8                   PARAMETERS
         MVC   RKEYMASK(20),RKEYSWS  INITIALIZE RKEYSCAN SWITCHES    R4
         SPACE 3
RKEYNEXT LM    R0,R1,RKBLANKS      INITIALIZE SCAN REGISTERS
         MVI   RKSCANSW+1,X'4A'    SET FOR ALPHAMERIC SCAN
         BAL   RL1,RKSCAN          SCAN KEYWORD
         B     RKEYEXIT            EXIT IF END OF CARD
         STM   R0,R1,RTEMP         SAVE KEYWORD
         CLI   RTEMP+7,C' '        TEST FOR NULL KEYWORD
         BE    RKEYNEXT            IGNORE NULL KEYWORDS
         CLI   RTEMP,C' '          TEST FOR OVERFLOW
         BNE   RKERROR             BRANCH IF MORE THAN 7 CHARACTERS
         L     RL2,PCER1           RL2 = ADDRESS OF SCAN TABLE
         USING RSCANTBL,RL2        ESTABLISH SCAN TABLE ADDRESSABILITY
         EJECT                                                       R4
RKSERCH1 CLI   RSCANAME,X'FF'      TEST FOR END OF SCAN TABLE
         BE    RKERROR             BRANCH IF KEYWORD NOT FOUND
         CLC   RSCANAME,RTEMP+1    COMPARE TABLE KEYWORD
         BE    RKFOUND             BRANCH IF KEYWORD MATCHES
         CLI   RTEMP+6,C' '        TEST KEYWORD LENGTH
         BNE   RKSERCH2            BRANCH IF NOT SINGLE CHARACTER
         CLC   RSCANABR,RTEMP+7    COMPARE TABLE ABBREVIATION
         BE    RKFOUND             BRANCH IF ABBREVIATION MATCHES
         SPACE 1
RKSERCH2 LA    RL2,RSCANEXT        GET ADDRESS OF NEXT ENTRY
         B     RKSERCH1             AND CONTINUE SEARCHING
         SPACE 2
RKFOUND  LH    R1,RSCANDSP         GET DISPLACEMENT FROM SCAN TABLE
         ALR   R1,JCT              ADD ADDRESS OF OUTPUT TABLE
         IC    RL1,RSCANFLG        ISOLATE
         N     RL1,=A(RSCFLPCT)     MAXIMUM NUMBER OF VALUES
         BNZ   RKVALUE             BRANCH IF VALUES EXPECTED
         MVI   RKEYMASK,X'96'      PRESET OPERATION CODE TO 'OI'
         TM    RSCANFLG,RSCFLCOM   TEST OPTION BYTE
         BZ    *+8                 BRANCH IF NO COMPLEMENTATION
         MVI   RKEYMASK,X'94'      SET OPERATION CODE TO 'NI'
         MVC   RKEYMASK+1(1),RSCANMSK   SET MASK
         EX    R0,RKEYMASK         SET KEYWORD INDICATION            R4
         B     RKEYNEXT            PROCESS NEXT KEYWORD
         SPACE 2
RKVALUE  CLI   0(RW),C'='          TEST CURRENT CHARACTER
         BNE   RKERROR             ILLEGAL IF NOT EQUAL SIGN
         CLI   1(RW),C' '          TEST NEXT CHARACTER         @OZ29274
         BE    RKERROR             ILLEGAL IF BLANK            @OZ29274
         CLI   1(RW),C'('          TEST NEXT CHARACTER
         BNE   *+8                 BRANCH IF NOT LEFT PAREN
         ALR   RW,R14              ADVANCE TO NEXT COLUMN
         LCR   RL1,RL1             NEGATE FOLLOWING INSTRUCTION
         LCR   RL1,RL1             SET COUNT NEGATIVE IF NO PAREN
         SPACE 1                                                     R4
RKNXTVAL ST    R1,PCEWB            SAVE ADDRESS OF OUTPUT VALUE
         ST    RL1,PCEWC           SAVE VALUE COUNT
         SR    R0,R0               CLEAR
         LR    R1,R0                REGISTERS
         TM    RSCANFLG,RSCFLBLK   TEST OPTION BYTE
         BZ    *+8                 BRANCH IF NO BLANK FILL
         LM    R0,R1,RKBLANKS      INITIALIZE SCAN REGISTERS
         TM    RSCANFLG,RSCFLNUM+RSCFLBIN    TEST OPTION BYTE
         BZ    *+8                 BRANCH IF ALPHAMERIC SCAN
         MVI   RKSCANSW+1,C'0'     SET FOR NUMERIC SCAN
         BAL   RL1,RKSCAN          SCAN NEXT VALUE
         B     RKERROR             BRANCH IF END OF CARD
         TM    RSCANFLG,RSCFLBIN   TEST OPTION BYTE
         BZ    RKEBCDIC            BRANCH IF NO BINARY CONVERSION
         STM   R0,R1,RTEMP         STORE VALUE                 @OZ42746
         CLC   RSCANAME,=CL7'  CARDS' CARDS PARAMETER USED...  @OZ42746
         BNE   RKCKLNE             NO, CHECK FOR 'LINES'       @OZ42746
         LA    R0,7                SETUP INPUT LENGTH          @OZ42746
         B     RKCKLEN             GO CHECK INPUT LENGTH       @OZ42746
RKCKLNE  DS    0H                                              @OZ42746
         CLC   RSCANAME,=CL7'  LINES' LINES PARAMETER USED...  @OZ42746
         BNE   RKNTLNE             IF NOT, CONTINUE            @OZ42746
         SR    R0,R0               CLEAR WORK REG              @OZ42746
         IC    R0,RSCANLEN         PICK UP LENGTH VALUE        @OZ42746
RKCKLEN  DS    0H                                              @OZ42746
         LA    RL1,RTEMP+7         COMPUTE ADDRESS OF          @OZ42746
         SLR   RL1,R0               FIRST BYTE TO BE ZERO      @OZ42746
         CLI   0(RL1),X'00'        SHOULD BE A ZERO.......     @OZ42746
         BNE   RKERROR               IF NOT INPUT TOO LARGE    @OZ42746
RKNTLNE  OI    RTEMP+7,X'F0'       CONVERT EBCDIC              @OZ42746
         PACK  RTEMP,RTEMP           VALUE
         SR    R0,R0                  TO
         CVB   R1,RTEMP                BINARY
         EJECT                                                       R4
RKEBCDIC STM   R0,R1,RTEMP         SAVE VALUE
         SR    R0,R0               GET
         IC    R0,RSCANLEN          VALUE LENGTH
         BCTR  R0,0                DECREMENT LENGTH
         STC   R0,RKSETMVC+1       SET MOVE LENGTH
         LA    RL1,RTEMP+6         COMPUTE ADDRESS OF
         SLR   RL1,R0               FIRST BYTE OF VALUE - 1
         CLI   RSCANLEN,8          IF MAX LENGTH IS EIGHT,           R4
         BE    SKIP330              SKIP OVERFLOW TEST               R4
         TM    0(RL1),X'BF'        TEST FOR OVERFLOW
         BNZ   RKERROR             BRANCH IF VALUE IS TOO LARGE
SKIP330  TM    RSCANFLG,RSCFLEFT   TEST OPTION BYTE
         BZ    RKSETVAL            BRANCH IF NO LEFT JUSTIFICATION
         TM    RTEMP+7,X'BF'       TEST LOW-ORDER BYTE
         BZ    RKSETVAL            BRANCH IF NULL VALUE
         STC   R0,RKLFSHFT+1       SET SHIFT LENGTH
         IC    R1,RTEMP            GET FILL CHARACTER
         SPACE 1
RKLFTADJ TM    1(RL1),X'BF'        TEST FIRST CHARACTER
         BNZ   RKSETVAL            BRANCH IF NOT NULL VALUE
         EX    R0,RKLFSHFT         SHIFT LEFT ONE CHARACTER          R4
         STC   R1,RTEMP+7          ADD FILL CHARACTER
         B     RKLFTADJ            TRY AGAIN
         SPACE 2
RKSETVAL L     R1,PCEWB            GET ADDRESS OF OUTPUT VALUE
         EX    R0,RKSETMVC         SET OUTPUT VALUE                  R4
         L     RL1,PCEWC           GET VALUE COUNT
         LTR   RL1,RL1             TEST
         BNP   RKEYNEXT            BRANCH IF SINGLE VALUE
         CLI   0(RW),C')'          TEST NEXT CHARACTER
         BE    RKEYNEXT            BRANCH IF LAST VALUE
         ALR   R1,R0               ADVANCE
         ALR   R1,R14               VALUE ADDRESS
         BCT   RL1,RKNXTVAL        DECREMENT VALUE COUNT AND CONTINUE
         SPACE 3
RKERROR  L     RL1,PCEWA           RESTORE LINK REGISTER
         BR    RL1                 INDICATE SCAN ERROR
         SPACE 3
RKEYEXIT L     RL1,PCEWA           RESTORE LINK REGISTER
         B     4(,RL1)             INDICATE NORMAL END OF CONTROL CARD
         DROP  RL2                 DROP SCAN TABLE ADDRESSABILITY
         EJECT
RKSCAN   NULL                      CONTROL CARD FIELD SCAN SUBROUTINE
         BXH   RW,R14,0(RL1)       GET NEXT CHARACTER
         SPACE 3
RKSCAN1  CLI   0(RW),C','          TEST NEXT CHARACTER
         BE    4(,RL1)             BRANCH IF COMMA
         CLI   0(RW),C'='          *
         BE    4(,RL1)             BRANCH IF EQUAL SIGN
         CLI   0(RW),C')'          *
         BE    4(,RL1)             BRANCH IF RIGHT PAREN
         CLI   0(RW),C' '          *
         BNE   RKSCNTST            BRANCH IF NOT BLANK               R4
         LR    R15,RW              RE-DEFINE END OF CARD
         B     4(,RL1)             INDICATE END OF FIELD
         SPACE 3                                                     R4
RKSCNTST EX    R0,RKSCANSW         COMPARE WITH LOWER LIMIT          R4
         BL    RKERROR             ILLEGAL IF LESS
         CLI   0(RW),C'9'          COMPARE WITH UPPER LIMIT
         BH    RKERROR             ILLEGAL IF GREATER
         ST    R0,RTEMP            TEST
         TM    RTEMP,X'BF'          HIGH-ORDER CHARACTER
         BNZ   RKERROR             BRANCH IF OVERFLOW
         SLDL  R0,8                SHIFT PARAMETER
         IC    R1,0(,RW)           ADD CURRENT CHARACTER
         BXLE  RW,R14,RKSCAN1      GET NEXT CHARACTER
         B     4(,RL1)             END OF CONTROL CARD
         SPACE 5                                                     R4
RKEYMASK EQU   $POSTSAV,4          *** MODEL EXECUTE STATEMENT ***   R4
RKLFSHFT EQU   $POSTSAV+4,6        *** MODEL EXECUTE STATEMENT ***   R4
RKSETMVC EQU   $POSTSAV+10,6       *** MODEL EXECUTE STATEMENT ***   R4
RKSCANSW EQU   $POSTSAV+16,4       *** MODEL EXECUTE STATEMENT ***   R4
         SPACE 2                                                     R4
RKEYSWS  OI    0(R1),*-*           SET KEYWORD INDICATION            R4
         MVC   1(*-*,RL1),2(RL1)   SHIFT LEFT ONE CHARACTER          R4
         MVC   0(*-*,R1),1(RL1)    SET OUTPUT VALUE                  R4
         CLI   0(RW),*-*           COMPARE WITH LOWER LIMIT          R4
         EJECT
***********************************************************************
*                                                                     *
*        RJOBKILL -- SUBROUTINE TO DELETE CURRENT JOB                 *
*                                                                     *
*              FUNCTIONS -- 1) TEST FOR ACTIVE JOB                    *
*                           2) NOTIFY OPERATOR OF DELETION            *
*                           3) TERMINATE JOB                          *
*                           4) PLACE JOB IN PRINT QUEUE               *
*                                                                     *
*              LINK REGISTER -- RL1                                   *
*                                                                     *
*              EXTERNAL ROUTINES -- 1) RJCTTERM                       *
*                                   2) RJOBTERM                       *
*                                                                     *
***********************************************************************
         SPACE 3
RJOBKILL LTR   JCT,JCT             KILL JOB NOW BEING READ
         BZR   RL1                 RETURN IF NO JCT
        $WTO   RDELMSG,L'RDELMSG,JOB=YES,           NOTIFY OPERATOR    C
               ROUTE=$LOG+$UR,CLASS=$ALWAYS,PRI=$ST OF JOB KILL     R41
         MVI   JCTOPRIO,X'FF'      SET OUTPUT PRIORITY IN JCT
         ICM   RL2,15,RDRIOT       IS IOT THERE...             @OZ65152
         BZ    RJOBNIOT            BR IF NO                    @OZ24650
         MVC   IOTIOTTR-IOTDSECT(,RL2),$ZEROS CUT IOT CHAIN    @OZ65152
         BAL   RL2,RJCTTERM        PERFORM FINAL UPDATE OF JCT
         OI    RDRSW,RJKILL        INDICATE KILLED HERE        @OZ19495
         BAL   RL2,RJOBTERM        TERMINATE JOB
         NI    RDRSW,X'FF'-RJKILL  RESET SW                    @OZ19495
RJOBNIOT OI    RDRSW,RJFLUSH       TURN ON FLUSH SWITCH        @OZ24650
        $QSUSE                     REQUEST ACCESS TO CHECKPOINT DATA
         L     R1,PCEJQE           GET JQE ADDRESS             @OZ32566
         USING JQEDSECT,R1         ESTABLISH JQE ADDRESSABILITY
         NI    JQEFLAGS,255-QUEHOLD1  RESET JOB HOLD STATUS
         LA    R0,$OUTPUT          SET UP FOR QUEUE TO $OUTPUT      R41
         TM    RDRSW,RJNABORT      PURGE INSTEAD...                 R41
         BZ    RJOBKQ              BR IF NO                         R41
         LA    R0,$PURGE            ELSE SET UP FOR QUEUE TO $PURGE R41
         SPACE 1                                                    R41
RJOBKQ  $QMOD  (R1),(R0)           PLACE JOB IN OUTPUT OR PURGE Q   R41
         MVC   PCEJQE,$ZEROS       CLEAR JQE ADDRESS           @OZ32566
         DROP  R1                  DROP JQE ADDRESSABILITY
         BR    RL1                 RETURN
         TITLE 'HASP INPUT SERVICE -- SECOND LEVEL SUBROUTINES'
***********************************************************************
*                                                                     *
*        RJCTTERM -- SUBROUTINE TO PERFORM FINAL UPDATE OF JCT        *
*                                                                     *
*              FUNCTIONS -- 1) CONVERT TIME ESTIMATE TO SECONDS       *
*                           2) COMPUTE OUTPUT ESTIMATE FROM LINE      *
*                              AND CARD ESTIMATES                     *
*                           3) MOVE NJE-RELATED INFO FOR SMF          *
*                                                                     *
*              LINK REGISTER -- RL2                                   *
*                                                                     *
***********************************************************************
         SPACE 5
RJCTTERM L     R1,JCTETIME         CONVERT TIME ESTIMATE
         M     R0,=F'60'            FROM MINUTES
         ST    R1,JCTETIME           TO SECONDS
         SPACE 2
         L     R1,JCTESTLN         MULTIPLY
         M     R0,=F'1000'          ESTIMATED LINE COUNT
         ST    R1,JCTESTLN           BY 1000
         AL    R1,JCTESTPU            AND ADD ESTIMATED CARD COUNT
         ST    R1,JCTESOUT             FOR ESTIMATED OUTPUT
         BR    RL2                 RETURN
         EJECT
***********************************************************************
*                                                                     *
*        RJOBTERM -- SUBROUTINE TO TERMINATE JOB                      *
*                                                                     *
*              FUNCTIONS -- 1) ADD TERMINATION MESSAGE                *
*                           2) TERMINATE AND WRITE LAST OUTPUT BUFFER *
*                           3) COMPLETE JOB CONTROL TABLE             *
*                           4) WRITE JCT                              *
*                           5) WRITE IOT                              *
*                                                                     *
*              LINK REGISTER -- RL2                                   *
*                                                                     *
*              EXTERNAL ROUTINE -- RPUT                               *
*                                                                     *
***********************************************************************
         SPACE 5
RJOBTERM ST    RL1,RLSAVE2         SAVE
         ST    RL2,RLSAVE3          RETURN REGISTERS
         ICM   RPI,8,RCARDLRL      SAVE CURRENT CARD LENGTH
         ST    RPI,RSAVE2           AND ADDRESS
         TM    JCTJOBFL,JCTTCOPY   TEST JOB FLAGS
         BO    RTRCOPY             BRANCH IF 'TYPRUN=COPY'
         LA    RPI,RDRDLM          GET ADDRESS OF DELIMITER CARD
         TM    RDRSW,RJCLSW        TEST JCL SWITCH
         BO    *+8                 BRANCH IF PROCESSING JCL
         BAL   RL1,RPUT            ADD DELIMITER CARD TO OUTPUT FILE
         TM    RDRSW,RXBJOBSW      TEST FOR EXECUTION BATCHING       R4
         BZ    RNOBATCH            BRANCH IF NOT EXECUTION BATCHING  R4
         OI    RCARDLRC,LRC1ONUL   INDICATE INTERNALLY GENERATED     R4
         LA    RPI,=CL80'//'       GET ADDRESS OF NULL CARD          R4
         BAL   RL1,RPUT            ADD NULL CARD TO OUTPUT FILE
         OI    JCTJOBFL,JCTNOJNL   FORCE NO JOURNAL
         SPACE 1                                                     R4
RNOBATCH LA    RPI,RJOBDOC         GET ADDRESS OF MESSAGE            R4
         OI    RCARDLRC,LRC1CCTL+LRC1TASA+LRC1INUL+RDLMSKIP SET TYPE R4
         MVI   RDRCCTL,C'-'        FORCE TRIPLE SPACE                R4
         MVI   RCARDLRL,80         SET CARD LENGTH TO 80
         MVI   RINFLAG1,0          CLEAR 'INPUT' FLAG                R4
         BAL   RL1,RPUT            ADD JOB DELETED OR CANCELLED MESSAGE
         SPACE 2
RTRCOPY  L     R1,RBONEXT          SET
         MVI   0(R1),X'FF'          LAST RCB
         L     RW,RDROBUF          GET BUFFER ADDRESS                R4
         ST    RW,PCEBUFAD         SET BUFFER ADDRESS FOR $EXCP      R4
         MVC   PCESEEK,RBUFTRK(RW)  SET TRACK ADDRESS FOR $EXCP      R4
         XC    RBUFTRK(,RW),RBUFTRK(RW)  ZERO CHAIN TRACK            R4
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE
         EJECT                                                       R4
         L     R1,RDROCT           GET ADDRESS OF OCT
         LTR   R1,R1               TEST
         BZ    RNOOCT              BRANCH IF NO OCT
         ST    R1,PCEBUFAD         SET BUFFER ADDRESS
         MVC   PCESEEK,OCTTRACK-OCTDSECT(R1)  SET TRACK ADDRESS
         LA    R1,PCEDADCT         SET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE OF OCT
         SR    R1,R1               INDICATE
         ST    R1,RDROCT            NO OUTPUT CONTROL TABLE
         SPACE 1                                                    R41
RNOOCT   L     R1,RDRIOT           GET ADDRESS OF FIRST IOT
         AL    R1,$IOTPDDB         GET ADDRESS OF FIRST PDDB         R4
         SR    R15,R15             GET
         IC    R15,JCTMCLAS         MESSAGE CLASS
         STC   R15,PDBCLASS-PDBDSECT+IOTPDBOJ(,R1)  SET IN JCL PDDB, R4
         STC   R15,PDBCLASS-PDBDSECT+IOTPDBOL(,R1)   JOB LOG PDDB,   R4
         STC   R15,PDBCLASS-PDBDSECT+IOTPDBOI(,R1)    JCL IMGS PDDB, R4
         STC   R15,PDBCLASS-PDBDSECT+IOTPDBOM(,R1)     AND MSGS PDDB R4
         L     R14,$SSVT           GET ADDRESS OF SSVT
         LA    R15,$SVSCAT-SSVT(R14,R15)  GET ADDRESS OF SCAT ENTRY
         TM    RDRSW,RJKILL        JOB BEING KILLED...         @OZ19495
         BO    *+12                BR IF YES                   @OZ19495
         TM    JCTJOBFL,JCTTCOPY   TYPRUN=COPY SPECIFIED...         R41
         BZ    RNOCOPY1            BR IF NO                         R41
         TM    SCATFLAG-SCADSECT(R15),SCATHOLD  TEST MSGCLASS       R41
         BZ    RNOCOPY1            BR IF NOT HELD CLASS             R41
         OI    PDBFLAG1-PDBDSECT+IOTPDBOJ(R1),PDB1HOLD HOLD JCL     R41
         SPACE 1                                                    R41
RNOCOPY1 TM    SCATFLAG-SCADSECT(R15),SCATDUMM  TEST MSGCLASS       R41
         BO    RMCLDUMM            BRANCH IF MESSAGE CLASS IS DUMMY
         TM    SCATFLAG-SCADSECT(R15),SCATTCEL  TEST FOR TRACK-CELL  R4
         BNO   RNOOCT1             BR IF NOT                         R4
         OI    PDBFLAG2-PDBDSECT+IOTPDBOI(R1),PDB2TCEL  TRACK-CELL   R4
         OI    PDBFLAG2-PDBDSECT+IOTPDBOM(R1),PDB2TCEL   SYSTEM      R4
         OI    PDBFLAG2-PDBDSECT+IOTPDBOL(R1),PDB2TCEL    PDDB'S     R4
RNOOCT1  DS    0H                                                    R4
         TM    JCTJOBFL,JCTNOUPT   TEST JOB FLAGS
         BO    RMCLDUMM            BRANCH IF NO OUTPUT OPTION
         TM    JCTJBOPT,JCTNOLOG   TEST JOB OPTIONS
         BO    RNOLOG              BRANCH IF NOLOG OPTION
         B     RFORMS              SET JOB FORMS
         EJECT                                                      R41
RMCLDUMM OI    PDBFLAG1-PDBDSECT+IOTPDBOJ(R1),PDB1NSOT PRINT NO JCL, R4
         OI    PDBFLAG1-PDBDSECT+IOTPDBOI(R1),PDB1NSOT  JCL IMAGES,  R4
         OI    PDBFLAG1-PDBDSECT+IOTPDBOM(R1),PDB1NSOT   OR SYS MSGS R4
         SPACE 1                                                     R4
RNOLOG   OI    PDBFLAG1-PDBDSECT+IOTPDBOL(R1),PDB1NSOT  NO JOB LOG   R4
         SPACE 1                                                     R4
RFORMS   L     R15,JCTFORMS        GET JOB FORMS
         ST    R15,PDBFORMS-PDBDSECT+IOTPDBOJ(,R1)  SET IN JCL PDDB, R4
         ST    R15,PDBFORMS-PDBDSECT+IOTPDBOL(,R1)   JOB LOG PDDB,   R4
         ST    R15,PDBFORMS-PDBDSECT+IOTPDBOI(,R1)    JCL IMAGES,    R4
         ST    R15,PDBFORMS-PDBDSECT+IOTPDBOM(,R1)     AND SYS MSGS  R4
         SPACE 1                                                    R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOJ(R1),PDB2JFMS  SHOW FORMS  R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOL(R1),PDB2JFMS   SET        R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOI(R1),PDB2JFMS    FROM      R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOM(R1),PDB2JFMS     JCT      R41
         SPACE 1                                                    R41
         TM    JCTFLAG1,JCTBURST   GET DEFAULT BURST OPTION         R41
         BZ    RJQECKP             BR IF NO, ELSE SET B=Y IN        R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOJ(R1),PDB2BRST  JCL PDDB    R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOL(R1),PDB2BRST  JOB LOG     R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOI(R1),PDB2BRST  JCL IMG     R41
         OI    PDBFLAG2-PDBDSECT+IOTPDBOM(R1),PDB2BRST  AND SMB     R41
         SPACE 1                                                    R41
RJQECKP $QSUSE                     REQUEST ACCESS TO CKPT DATA      R41
         L     R1,PCEJQE           GET JQE ADDRESS             @OZ32566
         USING JQEDSECT,R1         ESTABLISH JQE ADDRESSABILITY
        $QCKPT (R1)                FORCE CKPT OF JQE                 R4
         TM    RDRSW,RXBJOBSW      TEST FOR XBM                @OZ33423
         BZ    RNOTXBM             BRANCH IF NOT               @OZ33423
         TM    JCTJBOPT,JCTSETUP   TEST FOR XBM WITH SETUP     @OZ33423
         BZ    RNOTXBM             BRANCH IF NOT               @OZ33423
         OI    JQEFLAGS,QUEHOLD1   ELSE SET JQE HOLD           @OZ33423
RNOTXBM  DS    0H                                              @OZ33423
         MVC   JQEPRTRT,JCTPROUT   SET PRINT AND
         MVC   JQEPUNRT,JCTPUOUT    PUNCH ROUTE CODES
         TM    RDRSW2,RJCLH        IF IMMEDIATE HOLD                 R4
         BZ    RNOHOLD               SPECIFIED, TURN ON JQE          R4
         OI    JQEFLAGS,QUEHOLD1     HOLD BIT & ISSUE $WTO           R4
        $WTO   RJOBHELD,L'RJOBHELD,JOB=YES, ISSUE 'JOB HELD' MSG     R4C
               ROUTE=$LOG+$UR+$MAIN,CLASS=$NORMAL,PRI=$ST            R4
         DROP  R1                  KILL JQE ADDRESSABILITY          R41
         EJECT                                                      R41
RNOHOLD  TM    RDRSW,RJKILL        JOB BEING KILLED...         @OZ19495
         BO    *+12                BR IF YES                   @OZ19495
         TM    JCTJOBFL,JCTTCOPY   TYPRUN=COPY SPECIFIED...    @OZ19495
         BZ    RNOCOPY2            BR IF NO                         R41
         TM    RDRSW,RJNABORT      ARE WE PURGING...           @OZ19495
         BO    RNOCOPY2            IF YES SKIP HOLD ROUTINE    @OZ19495
         L     RL2,RDRIOT          GET ADDR OF 1ST IOT              R41
         USING IOTDSECT,RL2        PROVIDE IOT ADDRESSABILITY       R41
         LA    RW,IOTPDBOJ(,RL2)   GET IOT ADDR + PDDB DISPL        R41
         AL    RW,$IOTPDDB         GET ADDR OF JCL PDDB             R41
         USING PDBDSECT,RW         PROVIDE PDDB ADDRESSABILITY      R41
         TM    PDBFLAG1,PDB1HOLD   DATA SET TO BE HELD...           R41
         BZ    RNOCOPY2            BR IF NO                         R41
         TM    PDBFLAG1,PDB1NSOT   DATA SET PRINTABLE...            R41
         BO    RNOCOPY2            BR IF NO                         R41
         NI    PDBFLAG1,255-PDB1HOLD  RESET HOLD INDICATOR          R41
         LH    R0,IOTLENG          GET CSA                          R41
*              THIS LINE DELETED BY APAR NUMBER              * @OZ20045
         GETMAIN RC,LV=(R0),SP=231   NEW (SPIN) IOT            @OZ20045
         LTR   R15,R15             GETMAIN SUCCESSFUL...            R41
         BNZ   RNOCOPY2            BR IF NO                         R41
         LR    RL1,R1              RELOAD NEW IOT ADDRESS           R41
         LR    R0,RL1              COPY 1ST IOT                     R41
         LH    R1,IOTLENG           (UP TO TRACK                    R41
         LR    R14,RL2               GROUP MAP)                     R41
         LA    R15,IOTTGMAP-IOTDSECT  TO NEW                        R41
         MVCL  R0,R14                  (SPIN) IOT                   R41
        $BFRBLD  (RL1)             REFRESH IOB                 @OZ20045
        $TRACK IOTMSTAB            GET TRACK ADDR FOR HQT           R41
         ST    R1,JCTHQT           SET HQT TRACK ADDR IN JCT        R41
         DROP  RL2                 RE-SET IOT ADDRESSABILITY        R41
         USING IOTDSECT,RL1         FOR NEW IOT                     R41
         XI    IOTFLAG1,IOT1ALOC+IOT1SPIN  SHOW SPIN/NON-ALLOC      R41
         LR    R1,RL1                MOVE JCL                       R41
         AL    R1,$IOTPDDB            DATA SET PDDB                 R41
         MVC   0(PDBLENG,R1),PDBDSECT  TO NEW IOT                   R41
         OI    PDBFLAG1-PDBDSECT(R1),PDB1SPIN+PDB1HOLD+PDB1PSO      R41
         OI    PDBFLAG1,PDB1NSOT   NULLIFY PDDB IN OLD IOT          R41
         L     R0,JCTHQT           GET HQT TRACK ADDRESS            R41
         ST    R0,IOTHQT1          SET HQT TRK ADDR IN IOT          R41
         ST    R0,IOTHQT           INDICATE 1ST HQT                 R41
         LA    R1,PDBLENG(,R1)     SET POINTER                      R41
         SLR   R1,RL1               TO NEXT                         R41
         ST    R1,IOTPDDBP           AVAILABLE PDDB                 R41
         LA    R1,1                INITIALIZE HQR                   R41
         STH   R1,JCTHQRCT          COUNT IN JCT                    R41
         STH   R1,IOTHQRCT           AND IN IOT                     R41
         MVC   IOTJQOFF,JCTJQE     SET OFFSET OF JQE IN IOT FOR XEQ R41
         SPACE 1                                                    R41
RIOTTRK  LA    R1,IOTMSTAB-IOTDSECT(,RL2)  GET ADDR OF 1ST IOT      R41
        $TRACK (R1)                GET TRACK ADDR FOR NEW IOT       R41
         ST    R1,JCTSPIOT         SET SPIN IOT TRK ADDR IN JCT     R41
         ST    R1,IOTTRACK          AND IN OWN IOT                  R41
         ST    R1,PCESEEK          SET TRACK ADDRESS FOR $EXCP      R41
         ST    RL1,PCEBUFAD        SET BUFFER ADDRESS FOR $EXCP     R41
         LA    R1,PCEDADCT         GET DIRECT ACCESS DCT ADDRESS    R41
         ST    R13,PCEIOEWF        TELL CHANNEL END NOT TO FREE@OZ20045
        $EXCP  (R1),WAIT=YES       WRITE SPIN IOT                   R41
         BM    RIOTTRK             BR IF I/O ERROR TO GET NEW TRACK R41
         XC    PCEIOEWF(4),PCEIOEWF  CLEAR EWF                 @OZ20045
         L     RW,$SSVT            GET SSVT ADDRESS                 R41
         USING SSVT,RW             PROVIDE SSVT ADDRESSABILITY      R41
         L     R0,$SVSPIOT         GET SPIN/HOLD IOT QUEUE HEAD     R41
         SPACE 1                                                    R41
RQUEHOLD ST    R0,IOTIOT           QUEUE NEW                        R41
         CS    R0,RL1,$SVSPIOT      IOT TO                          R41
         BNE   RQUEHOLD              SPIN/HOLD QUEUE                R41
         SPACE 1                                                    R41
         OI    $SVJOB,X'80'        SIMULATE                         R41
         L     R1,$EXECPCE          HASPXEQ                         R41
        $POST  (R1),JOB              $$POST                         R41
         EJECT                                                 @OZ36864
***************************************************************@OZ36864
*                                                              @OZ36864
*        WAIT FOR SPIN/HOLD PROCESSING TO COMPLETE.  THIS      @OZ36864
*        ENSURES THAT THE JOB CANNOT PURGE DURING SPIN/HOLD    @OZ36864
*        PROCESSING.                                           @OZ36864
*                                                              @OZ36864
***************************************************************@OZ36864
         SPACE 1                                               @OZ36864
RQTEST   LA    R15,$SVSPIOT-(IOTIOT-IOTDSECT) SCAN $SVSPIOT    @OZ36864
RQTEST1  ICM   R15,15,IOTIOT-IOTDSECT(R15) IF QUEUE EMPTY...   @OZ36864
         BZ    RQTEST2             ...BR TO TEST $SVFIFOQ      @OZ36864
         CLC   JCTJQE,IOTJQOFF-IOTDSECT(R15) IOT FOR THIS JOB  @OZ36864
         BE    RQWAIT              YES, BR TO WAIT             @OZ36864
         B     RQTEST1             NO, CHECK REMAINING IOTS    @OZ36864
         SPACE 1                                               @OZ36864
RQTEST2  LA    R15,$SVFIFOQ-(IOTIOT-IOTDSECT) SCAN $SVFIFOQ    @OZ36864
RQTEST3  ICM   R15,15,IOTIOT-IOTDSECT(R15)  IF QUEUE EMPTY...  @OZ36864
         BZ    RNOCOPY2            GO QUEUE JOB FOR OUTPUT     @OZ36864
         CLC   JCTJQE,IOTJQOFF-IOTDSECT(R15) IOT FOR THIS JOB  @OZ36864
         BNE   RQTEST3             NO, CHECK REMAINING IOTS    @OZ36864
         SPACE 1                                               @OZ36864
RQWAIT  $WAIT  ABIT                WAIT A BIT                  @OZ36864
         B     RQTEST              BR TO TRY AGAIN             @OZ36864
         SPACE 1                                               @OZ36864
         DROP  RL1,RW              KILL IOT/SSVT ADDRESSABILITY@OZ36864
         SPACE 1                                               @OZ36864
RNOCOPY2 XC    JCTJOBIN,JCTJOBIN   CLEAR JCTJOBIN                   R41
        $TIME                      GET CURRENT TIME
         STM   R0,R1,JCTRDROF      SET READER END TIME AND DATE
         SPACE 2
RJCTCK   CLI   BUFECBCC-BUFDSECT(JCT),0  TEST I/O STATUS OF JCT
         BNE   RJCTWR              BRANCH IF I/O IS NOT ACTIVE
        $WAIT  IO                  WAIT FOR I/O TO COMPLETE
         B     RJCTCK              GO BACK AND TRY AGAIN
         SPACE 2                                                     R4
RJCTWR   ST    JCT,PCEBUFAD        SET BUFFER ADDRESS FOR $EXCP
         L     R1,PCEJQE           GET JQE ADDRESS             @OZ32566
         USING JQEDSECT,R1         ESTABLISH JQE ADDRESSABILITY
         MVC   PCESEEK,JQETRAK     SET TRACK ADDRESS FOR $EXCP
         DROP  R1                  DROP JQE ADDRESSABILITY
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE OF JCT
         SLR   JCT,JCT             INDICATE NO JCT
         L     R1,RDRIOT           GET ADDRESS OF IOT                R4
         SPACE 2                                                     R4
RIOTCK   CLI   BUFECBCC-BUFDSECT(R1),0  TEST I/O STATUS
         BNE   RIOTWR              BRANCH IF I/O IS NOT ACTIVE
        $WAIT  IO                  WAIF FOR I/O TO COMPLETE
         B     RIOTCK              GO BACK AND TRY AGAIN
         SPACE 2                                                     R4
RIOTWR   ST    R1,PCEBUFAD         SET BUFFER ADDRESS          @OZ65152
         MVC   PCESEEK,IOTTRACK-IOTDSECT(R1) SET TRACK ADDR    @OZ65152
         LA    R1,PCEDADCT         GET ADDR DIRECT-ACCESS DCT  @OZ65152
        $EXCP  (R1)                WRITE FIRST IOT             @OZ65152
         CLC   RDRIOT,RDRIOT2      IF ONLY ONE IOT,            @OZ65152
         BE    RSYNCH                 WAIT FOR I/O COMPLETION  @OZ65152
         CLC   PCEBUFAD,RDRIOT2    ELSE SEE IF ON LAST IOT     @OZ65152
         BE    RSYNCH                 YES, WAIT FOR COMPLETE   @OZ65152
         L     R1,RDRIOT2          ELSE GET ADDR OF LAST IOT   @OZ65152
         B     RIOTCK                 AND WRITE IT OUT         @OZ65152
*              THIS LINE DELETED BY APAR OZ65152               @OZ65152
*              THIS LINE DELETED BY APAR OZ65152               @OZ65152
         SPACE 2                                                     R4
RSYNCH   CLI   PCEBUFCT,0          TEST ACTIVE BUFFER COUNT
         BE    RTERMJOB            BRANCH IF ZERO
        $WAIT  BUF                 WAIT FOR COMPLETION OF ALL I/O
         B     RSYNCH              TRY AGAIN
         SPACE 2
RTERMJOB MVC   RPRIORTY,=CL2' '    RESET PRIORITY                    R4
         NI    RDRSW,255-RXBJOBSW  RESET XEQ BATCH JOB SWITCH
         L     RPI,RSAVE2          RESTORE INPUT POINTER
         STCM  RPI,8,RCARDLRL       AND CARD LENGTH
         LA    RPI,0(,RPI)         CLEAR HIGH-ORDER BYTE
         L     RL1,RLSAVE2         RESTORE
         L     RL2,RLSAVE3          RETURN REGISTERS
         BR    RL2                   AND RETURN
         DROP  RBI                 KILL IOB ADDRESSABILITY
         EJECT
***********************************************************************
*                                                                     *
*        RTRACK -- SUBROUTINE TO ACQUIRE TRACK ADDRESS                *
*                                                                     *
*              FUNCTION -- TO ACQUIRE TRACK ADDRESS AND CHECKPOINT    *
*                          ALLOCATION IOT WHEN NECESSARY              *
*                                                                     *
*              OUTPUT -- R1 = TRACK ADDRESS                           *
*                                                                     *
*              LINK REGISTER -- RL2                                   *
*                                                                     *
***********************************************************************
         SPACE 5
RTRACK   L     R1,RDRIOT           GET ADDRESS OF ALLOCATION IOT
         LA    R1,IOTMSTAB-IOTDSECT(,R1) GET ADDR OF MASTER TAB      R4
        $TRACK (R1)                GET NEXT TRACK ADDRESS
         BNZR  RL2                 RETURN IF NOT NEW TRACK GROUP
         SPACE 2
         L     R1,RDRIOT           GET ADDRESS OF ALLOCATION IOT
RTRACKCK CLI   BUFECBCC-BUFDSECT(R1),0  TEST I/O STATUS
         BNE   RTRACKWR            BRANCH IF I/O IS NOT ACTIVE
        $WAIT  IO                  WAIT FOR I/O TO COMPLETE
         B     RTRACKCK            GO BACK AND TRY AGAIN
         SPACE 3                                                     R4
RTRACKWR ST    R1,PCEBUFAD         SET IOT BUFFER ADDRESS
         MVC   PCESEEK,IOTTRACK-IOTDSECT(R1)  SET TRACK ADDRESS
         ST    SAVE,PCEIOEWF       PREVENT BUFFER RELEASE
         LA    R1,PCEDADCT         GET ADDRESS OF DIRECT-ACCESS DCT
        $EXCP  (R1)                INITIATE WRITE OF IOT
         SLR   R1,R1               RESET DIRECT-ACCESS
         ST    R1,PCEIOEWF          EVENT WAIT FIELD
         L     R1,RDRIOT           RESTORE TRACK ADDRESS TO OUTPUT
         L     R1,TABMTTR-TABDSECT+IOTMSTAB-IOTDSECT(,R1)  REGISTER  R4
         BR    RL2                 RETURN
         EJECT
***********************************************************************
*                                                                     *
*        RGETBUF -- SUBROUTINE TO INITIALIZE OUTPUT BUFFERS           *
*                                                                     *
*              FUNCTION -- ACQUIRE AND INITIALIZE OUTPUT BUFFER       *
*                                                                     *
*              INPUT -- RW = TRACK ADDRESS                            *
*                                                                     *
*              OUTPUT -- RBO = ADDRESS OF OUTPUT BUFFER               *
*                                                                     *
*              LINK REGISTER -- RL2                                   *
*                                                                     *
***********************************************************************
         SPACE 5                                               @OZ36957
RGETBUF  CLI   PCEBUFCT,20         IS BUF COUNT UP TO 20...    @OZ36957
         BNH   RGETOK              BR IF NO TO GET BUFFER      @OZ36957
        $WAIT  BUF                 WAIT IF 20 BUFFS THIS D/T   @OZ36957
         B     RGETBUF             TRY AGAIN                   @OZ36957
RGETOK  $GETBUF WAIT=YES           GET OUTPUT BUFFER           @OZ36957
         ST    R1,RDROBUF          SAVE BUFFER ADDRESS               R4
         LA    R14,IOTSTART-IOTDSECT(,R1) SET CLEAR REG        @OZ41701
         LH    R15,$BUFSIZE        SET BUFFER LENGTH           @OZ41701
         SR    R1,R1               CLEAR WORK REG              @OZ41701
         MVCL  R14,R0              CLEAR OUTPUT BUFFER         @OZ41701
         L     R1,RDROBUF          RESTORE REG1                @OZ41701
         ST    RW,RBUFTRK(,R1)     SET TRACK ADDRESS IN BUFFER       R4
         LTR   JCT,JCT             TEST FOR JCT
         BZ    *+10                BRANCH IF NO JCT
         MVC   HDBJBKEY-BUFDSECT(,R1),JCTJBKEY  SET JOB KEY          R4
         MVC   HDBPDDBK-BUFDSECT(,R1),RDRDSKEY   AND DATA SET KEY    R4
         LA    R15,BUFSTART-BUFDSECT-3(,R1)  COMPUTE END             R4
         AH    R15,$BUFSIZE                   OF BUFFER              R4
         ST    R15,RBOEND          SAVE FOR TEST                     R4
         LA    R1,ROBUFST(,R1)     SET UP                            R4
         ST    R1,RBONEXT           OUTPUT POINTER
         BR    RL2                 RETURN
         TITLE 'HASP INPUT SERVICE -- CONSTANTS AND OPERATOR MESSAGES'
*
*                             READER CONSTANTS AND OPERATOR MESSAGES
*
         SPACE 3
RUSERID  EQU   $POSTSAV,9          TSU USERID WORK AREA              R4
RDEST    EQU   $POSTSAV,8          DESTINATION WORK AREA             R4
         DS    0D                                                    R4
RKBLANKS DC    CL8' '              BLANK CONSTANT                    R4
RSYSINCD DC    CL80'//SYSIN     DD *               GENERATED STATEMENT'
RJOBHELD $MSG  101,'HELD'          JOB HELD MSG                      R4
RFLMSG   $MSG  125,'DEV NAME SKIPPING FOR JOB CARD'
RJERRMSG $MSG  110,'-- ILLEGAL JOB CARD '
RDELMSG  $MSG  119,'DELETED'
RJOBDOC  DC    C'******** JOB DELETED BY JES2 OR CANCELLED'          R4
         DC    C' BY OPERATOR BEFORE EXECUTION ******** '            R4
         EJECT                                                 @OZ19494
*
*                             MODEL FOR PDDB
*
         SPACE 3
RPDBMODL DS    0D
         DC    AL1(PDB1NULL)       FLAG BYTE
         DC    AL1(0)              RECORD FORMAT
         DC    H'0'                MAXIMUM LOGICAL RECORD LENGTH
         DC    F'0'                STARTING TRACK ADDRESS
         DC    H'0'                DATA SET KEY
         DC    C'A'                DEFAULT SYSOUT CLASS              R4
         DC    AL1(1)              DEFAULT COPY COUNT
         DC    AL1(0,0)            DESTINATION                       R4
         DC    AL1(0,0,0)          CPU ID, SECURITY, 3211 INDEX
         DC    AL1(DCBFNCBI)       3525 FUNCTION BYTE
         DC    AL1(0)              FLAG BYTE 2                       R4
         DC    X'00'               DEFAULT COMPACTION TABLE NUMBER  R41
         DC    F'0'                RECORD COUNT
         DC    XL4'00'             FORMS NUMBER
         DC    C'****'             FCB ID
         DC    C'****'             UCS ID
         DC    CL8' '              USER WRITER NAME
         DC    XL8'00'             CHECKPOINT RBA
         DC    6CL4'****'          N/I PRINT CHAR1-4, FLASH, MODF    R4
         DC    X'FF'               N/I PRINT FLASHC            @OZ39629
         DC    AL1(0)              MODFT                       @OZ39629
         DC    8AL1(0)             N/I PRINT COPY GROUPS             R4
         DC    X'FFFF'             LOGICAL PAGES/CHECKPOINT    @OZ19494
         DC    X'FFFF'             LINES/LOGICAL PAGE          @OZ19494
         DC    XL14'0'             RESERVED                    @OZ19494
         DS    0F                  FORCE TO FULLWORD BOUNDARY  @OZ19494
         EJECT
         DS    0D                  INPUT PROCESSOR LITERAL POOL
         LTORG
        TITLE 'HASP INPUT SERVICE  --  REMOVE PASSWORDS FROM JCL CARDS'
************************************************************** @OZ61577
*                                                            * @OZ61577
*                     ** RPUTSCAN **                         * @OZ61577
*                                                            * @OZ61577
*        THIS ROUTINE IS ENTERED WHEN WRITING JOB CARDS      * @OZ61577
*        TO THE JCL DATASET.                                 * @OZ61577
*                                                            * @OZ61577
*        THE PURPOSE OF THIS ROUTINE IS TO LOCATE A VALID    * @OZ61577
*        'PASSWORD=' PARAMETER, AND REMOVE ANY OLD AND/OR    * @OZ61577
*        NEW PASSWORDS THAT MAY HAVE BEEN SPECIFIED.         * @OZ61577
*                                                            * @OZ61577
*        REGISTER USAGE:                                     * @OZ61577
*          R0              -  UNUSED                         * @OZ61577
*          R1              -  WORK REGISTER                  * @OZ61577
*          R2              -  WORK REGISTER                  * @OZ61577
*          R3              -  POINTER TO CURRENT CHAR.       * @OZ61577
*                             BEING ANALYZED.                * @OZ61577
*          R4 (RPI)        -  POINTER TO JCL CARD            * @OZ61577
*          R5              -  WORK REGISTER                  * @OZ61577
*          R6              -  WORK REGISTER                  * @OZ61577
*          R7              -  RPUTPSRM RETURN REGISTER       * @OZ61577
*          R8-R10          -  UNUSED                         * @OZ61577
*          R11             -  HCT POINTER                    * @OZ61577
*          R12 (BASE2)     -  LOCAL BASE REGISTER            * @OZ61577
*          R13             -  PCE POINTER                    * @OZ61577
*          R14             -  RETURN REGISTER                * @OZ61577
*          R15             -  WORK REGISTER                  * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 3                                               @OZ61577
RPUTSCAN LR    R12,R15             SETUP LOCAL BASE REGISTER   @OZ61577
         USING RPUTSCAN,R12        ESTABLISH LOCAL ADDRES'TY   @OZ61577
         ST    R3,RMESSAGE+16      SAVE RBI REGISTER           @OZ61577
         ST    R5,RMESSAGE+20      SAVE RL1 REGISTER           @OZ61577
         ST    R7,RMESSAGE+24      SAVE REGISTER 7             @OZ61577
         SPACE 1                                               @OZ61577
         TM    RPASPROC,$RPSWCNT   ARE WE LOOKING FOR A        @OZ61577
*                                   PASSWORD CONTINUATION...   @OZ61577
         BO    RPUTPS42            BR. IF YES                  @OZ61577
         SPACE 1                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*        LOCATE 'PASSWORD=' STRING WITHIN JCL CARD           * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS03 LA    R3,3(,RPI)          PT. TO COL. 4 OF CARD       @OZ61577
         LA    R15,61(,RPI)        PT. TO COL. 62 OF CARD      @OZ61577
         SPACE ,                                               @OZ61577
RPUTPS06 CLC   0(9,R3),=C'PASSWORD='  'PASSWORD=' FOUND...     @OZ61577
         BE    RPUTPS09            BR IF YES                   @OZ61577
         LA    R3,1(,R3)           ELSE, BUMP TO NEXT BYTE     @OZ61577
         CR    R3,R15              AT END OF CARD ...          @OZ61577
         BH    RPUTPRTN            YES, RETURN                 @OZ61577
         B     RPUTPS06            ELSE, KEEP CHECKING         @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS09 LA    R3,9(,R3)           PT TO 1ST CHAR AFTER        @OZ61577
*                                   '=' SIGN                   @OZ61577
         LR    R6,R3               SAVE PTR TO FIRST CHAR      @OZ61577
         LA    R15,71(,RPI)        PT TO COLUMN 72 OF CARD     @OZ61577
         CLI   0(R3),C'('          'PASSWORD=(' FOUND ...      @OZ61577
         BE    RPUTPS18            BR IF YES                   @OZ61577
         TRT   0(1,R3),RPUTPSTB    ELSE, TEST FOR VALID CHAR   @OZ61577
         BZ    RPUTPS15            BLANK OUT INVALID PSWD      @OZ77291
         SPACE ,                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*        SCAN FOR REMAINING PASSWORD CHARACTERS WHERE THE    * @OZ61577
*        PASSWORD IS OF THE FORM 'PASSWORD=NNNN'.            * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE ,                                               @OZ61577
         LA    R5,7                SET R5 TO MAX PSWD LENGTH   @OZ61577
RPUTPS12 LA    R3,1(,R3)           PT TO NEXT CHAR             @OZ61577
         CR    R3,R15              IS THIS COL. 72 ...         @OZ61577
         BNL   RPUTPS15            YES, EXIT                   @OZ61577
         CLI   0(R3),C','          ELSE, IS COMMA SPECIFIED... @OZ61577
         BE    RPUTPS15            YES, END OF PASSWORD        @OZ61577
         CLI   0(R3),C' '          IS BLANK SPECIFIED...       @OZ61577
         BE    RPUTPS15            YES, END OF PASSWORD        @OZ61577
         TRT   0(1,R3),RPUTPSTB    VALID ID CHARACTER ...      @OZ61577
         BZ    RPUTPS15            BLANK OUT INVALID PSWD      @OZ77291
         BCT   R5,RPUTPS12         CONTINUE SCAN               @OZ61577
         SPACE 1                                               @OZ61577
         LA    R3,1(,R3)           POINT TO  9TH PSWD CHAR     @OZ61577
         CR    R3,R15              ARE WE AT COLUMN 72 ...     @OZ61577
         BNL   RPUTPS15            YES, REMOVE PASSWORD        @OZ61577
         CLI   0(R3),C' '          IS PSWD FOLL'D BY BLANK ... @OZ61577
         BE    RPUTPS15            YES, REMOVE VALID PSWD      @OZ61577
         CLI   0(R3),C','          IS PSWD FOLL'D BY COMMA ... @OZ61577
         BNE   RPUTPRTN            NO, INVALID PSWD - EXIT     @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS15 BAL   R7,RPUTPSRM         REMOVE PSWD FROM JCL        @OZ61577
         B     RPUTPRTN             AND RETURN                 @OZ61577
         EJECT ,                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*        SCAN FOR PASSWORDS OF THE FORM 'PASSWORD=(NNNN)'    * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS18 LA    R3,1(,R3)           PT TO NEXT BYTE ON JCL CARD @OZ61577
         LR    R6,R3               SAVE PTR TO FIRST PSWD CHAR @OZ61577
         CR    R3,R15              ARE WE AT COLUMN 72 ...     @OZ61577
         BNL   RPUTPRTN            YES, TERMINATE TRANSLATION  @OZ61577
         TRT   0(1,R3),RPUTPSTB    IS THIS VALID PSWD CHAR...  @OZ61577
         BZ    RPUTPS24            BLANK OUT INVALID PSWD      @OZ77291
         SPACE 1                                               @OZ61577
         LA    R5,7                SET R5 TO MAX. CHARS-1      @OZ61577
RPUTPS21 LA    R3,1(,R3)           PT. TO NEXT CHARACTER       @OZ61577
         CR    R3,R15              ARE WE AT COLUMN 72 ...     @OZ61577
         BNL   RPUTPRTN            YES, EXIT                   @OZ61577
         CLI   0(R3),C','          ELSE, IS COMMA PRESENT...   @OZ61577
         BE    RPUTPS24            YES, REMOVE OLD PASSWORD    @OZ61577
         CLI   0(R3),C')'          IS ')' PRESENT ...          @OZ61577
         BE    RPUTPS27            YES, REMOVE PASSWORD        @OZ61577
         TRT   0(1,R3),RPUTPSTB    IS PSWD CHAR VALID ...      @OZ61577
         BZ    RPUTPS24            BLANK OUT INVALID PSWD      @OZ77291
         BCT   R5,RPUTPS21         GO CHECK NEXT CHARACTER     @OZ61577
         SPACE 1                                               @OZ61577
         LA    R3,1(,R3)           POINT TO NEXT BYTE          @OZ61577
         CR    R3,R15              IS THIS COLUMN 72 ...       @OZ61577
         BNL   RPUTPRTN            YES, TAKE ERROR EXIT        @OZ61577
         CLI   0(R3),C')'          RIGHT PAREN AFTER PSWD ...  @OZ61577
         BNE   *+12                NO, CHECK FOR COMMA         @OZ61577
         BAL   R7,RPUTPSRM         YES, REMOVE PASSWORD        @OZ61577
         B     RPUTPRTN             AND RETURN                 @OZ61577
         CLI   0(R3),C','          IS COMMA AFTER PSWD ...     @OZ61577
         BNE   RPUTPRTN            NO, INVALID PSWD - EXIT     @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS24 BAL   R7,RPUTPSRM         REMOVE OLD PASSWORD         @OZ61577
         B     RPUTPS30             AND SCAN FOR NEW PASSWORD  @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS27 BAL   R7,RPUTPSRM         REMOVE ONLY PASSWORD        @OZ61577
         B     RPUTPRTN             AND RETURN                 @OZ61577
         EJECT ,                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*        CHECK FOR A NEW PASSWORD                            * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS30 LA    R3,1(,R3)           PT TO NEXT CHARACTER        @OZ61577
         LR    R6,R3               SAVE PTR TO FIRST CHAR      @OZ61577
         CR    R3,R15              ARE WE AT COLUMN 72 ...     @OZ61577
         BNL   RPUTPS39            YES, PREP FOR CONTINUATION  @OZ61577
         CLI   0(R3),C' '          BLANK FOLLOWING COMMA ...   @OZ61577
         BE    RPUTPS39            YES, PREP FOR CONTINUATION  @OZ61577
         TRT   0(1,R3),RPUTPSTB    IS CURRENT CHAR VALID ...   @OZ61577
         BZ    RPUTPS36            BLANK OUT INVALID PSWD      @OZ77291
         SPACE ,                                               @OZ61577
         LA    R5,7                SET R5 TO MAX CHARS-1       @OZ61577
RPUTPS33 LA    R3,1(,R3)           POINT TO NEXT CHAR          @OZ61577
         CR    R3,R15              ARE WE AT COLUMN 72 ...     @OZ61577
         BNL   RPUTPRTN            YES, EXIT                   @OZ61577
         CLI   0(R3),C')'          ELSE, IS ')' FOUND ...      @OZ61577
         BE    RPUTPS36            YES, REMOVE NEW PASSWORD    @OZ61577
         TRT   0(1,R3),RPUTPSTB    VALID PASSWORD CHAR ...     @OZ61577
         BZ    RPUTPS36            BLANK OUT INVALID PSWD      @OZ77291
         BCT   R5,RPUTPS33         CHECK NEXT PSWD CHAR        @OZ61577
         SPACE 1                                               @OZ61577
         LA    R3,1(R3)            LOOK AT 9TH CHAR            @OZ61577
         CR    R3,R15              ARE WE AT COLUMN 72 ...     @OZ61577
         BNL   RPUTPRTN            YES, TAKE ERROR EXIT        @OZ61577
         CLI   0(R3),C')'          ELSE, ')' AFTER PSWD ...    @OZ61577
         BNE   RPUTPRTN            NO, TAKE ERROR EXIT         @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS36 BAL   R7,RPUTPSRM         REMOVE NEW PSWD FROM JCL    @OZ61577
         B     RPUTPRTN             AND RETURN TO CALLER       @OZ61577
         SPACE 1                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*        A NEW PASSWORD IS ASSUMED TO BE SPECIFIED AND TO    * @OZ61577
*        BE CONTAINED ON A CONTINUATION JCL CARD.            * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS39 OI    RPASPROC,$RPSWCNT   SET PSWD CONTINUATION FLAG  @OZ61577
         B     RPUTPRTN             AND RETURN                 @OZ61577
         EJECT ,                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*        CONTROL IS PASSED TO THIS LOCATION WHEN SCANNING    * @OZ61577
*        FOR A NEW PASSWORD ON A CONTINUATION JCL CARD.      * @OZ61577
*        THAT IS, A NEW PASSWORD OF THE FORM '    NNNN)'     * @OZ61577
*        WILL BE REMOVED FROM THE JCL CARD.                  * @OZ61577
*                                                            * @OZ61577
*        IF THE JCL CARD DOES NOT CONTAIN A VALID PASSWORD   * @OZ61577
*        CONTINUATION, CONTROL IS PASSED TO LABEL RPUTPS03   * @OZ61577
*        WHERE THE ENTIRE CARD IS SCANNED FOR THE            * @OZ61577
*        'PASSWORD=' PARAMETER.                              * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS42 CLC   0(3,RPI),=C'//*'    COMMENT STATEMENT ...       @OZ61577
         BE    RPUTPRTN            YES, WAIT FOR CONTINUE      @OZ61577
         NI    RPASPROC,X'FF'-$RPSWCNT  NO, RESET CONT. FLAG   @OZ61577
         CLC   0(3,RPI),=C'// '    VALID CONTINUE STATEMENT... @OZ61577
         BNE   RPUTPS03            NO, RE-SCAN JCL CARD        @OZ61577
         SPACE 1                                               @OZ61577
         LA    R3,2(,RPI)          ELSE, SET R3 AND R5 TO      @OZ61577
         LA    R5,13                PASS OVER PRECEDING BLANKS @OZ61577
         LA    R15,71(,RPI)        POINT R15 TO COLUMN 72      @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS45 LA    R3,1(,R3)           POINT TO NEXT CHARACTER     @OZ61577
         CLI   0(R3),C' '          NON-BLANK FOUND ...         @OZ61577
         BNE   RPUTPS48            YES, GO PROCESS             @OZ61577
         BCT   R5,RPUTPS45         ELSE, CHECK NEXT CHAR       @OZ61577
         B     RPUTPS03            INV. CARD - RESCAN IT       @OZ61577
         SPACE 1                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*        VALIDATE AND REMOVE A NEW PASSWORD FROM A           * @OZ61577
*        CONTINUATION CARD.                                  * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS48 LR    R6,R3               SAVE PTR TO 1ST CHAR        @OZ61577
         TRT   0(1,R3),RPUTPSTB    VALID CHAR ...              @OZ61577
         BZ    RPUTPS03            NO, RE-SCAN WHOLE CARD      @OZ61577
         SPACE 1                                               @OZ61577
         LA    R5,7                ELSE, SET R5 TO MAX         @OZ61577
*                                   CHARACTERS - 1             @OZ61577
RPUTPS51 LA    R3,1(,R3)           POINT TO NEXT CHAR.         @OZ61577
         CLI   0(R3),C')'          RIGHT PAREN. FOUND ...      @OZ61577
         BE    RPUTPS54            YES, REMOVE PASSWORD        @OZ61577
         TRT   0(1,R3),RPUTPSTB    NO, VALID PSWD CHAR ...     @OZ61577
         BZ    RPUTPS03            NO, RE-SCAN WHOLE CARD      @OZ61577
         BCT   R5,RPUTPS51         YES, CHECK FOR MORE CHARS   @OZ61577
         SPACE 1                                               @OZ61577
         LA    R3,1(,R3)           POINT TO 9TH CHAR.          @OZ61577
         CLI   0(R3),C')'          IS IT RIGHT PAREN. ...      @OZ61577
         BNE   RPUTPS03            NO, RE-SCAN WHOLE CARD      @OZ61577
         SPACE 1                                               @OZ61577
RPUTPS54 BAL   R7,RPUTPSRM         REMOVE NEW PSWD FROM JCL    @OZ61577
         SPACE 3                                               @OZ61577
RPUTPRTN DS    0H                  SETUP FOR RETURN TO CALLER  @OZ61577
         L     R3,RMESSAGE+16      RESTORE RBI                 @OZ61577
         L     R5,RMESSAGE+20      RESTORE RL1                 @OZ61577
         L     R7,RMESSAGE+24      RESTORE R7                  @OZ61577
         L     R12,=A(HASPRDR)     RESTORE HASPRDR BASE        @OZ61577
         BR    R14                 RETURN                      @OZ61577
         EJECT ,                                               @OZ61577
************************************************************** @OZ61577
*                                                            * @OZ61577
*                   ** RPUTPSRM **                           * @OZ61577
*                                                            * @OZ61577
*        THE PURPOSE OF THIS SUBROUTINE IS TO REMOVE         * @OZ61577
*        PASSWORDS FROM JCL CARDS.  THE PASSWORD IS          * @OZ61577
*        REMOVED BY OVERLAYING IT WITH THE JCL TEXT THAT     * @OZ61577
*        IS IMMEDIATELY TO THE RIGHT OF THE PASSWORD.        * @OZ61577
*        BLANKS ARE THEN INSERTED AT THE FAR RIGHT OF THE    * @OZ61577
*        JCL CARD (UP THROUGH COLUMN 71) TO MAKE UP FOR      * @OZ61577
*        THE PASSWORD CHARACTERS WHICH HAVE BEEN DELETED.    * @OZ61577
*                                                            * @OZ61577
*        REGISTER USAGE                                      * @OZ61577
*                                                            * @OZ61577
*           R1   -  WORK REGISTER                            * @OZ61577
*           R2   -  WORK REGISTER                            * @OZ61577
*           R3   -  POINTS TO FIRST CHAR BEYOND PASSWORD     * @OZ61577
*                   OR FIRST INVALID CHARACTER               * @OZ77291
*           R6   -  POINTS TO FIRST PASSWORD CHARACTER       * @OZ61577
*           R7   -  SUBROUTINE RETURN REGISTER               * @OZ61577
*           R15  -  POINTS TO COLUMN 72 OF JCL CARD          * @OZ61577
*                                                            * @OZ61577
*        NOTE, R3 IS RESET SO THAT IT STILL POINTS TO        * @OZ61577
*        THE FIRST CHARACTER BEYOND THE PASSWORD THAT        * @OZ61577
*        HAS JUST BEEN DELETED.                              * @OZ61577
*                                                            * @OZ61577
************************************************************** @OZ61577
         SPACE 2                                               @OZ61577
RPUTPSRM DS    0H                  SUBROUTINE TO REMOVE CHAR.  @OZ61577
*                                   STRINGS FROM JCL CARDS     @OZ61577
         SPACE 1                                               @OZ61577
         LR    R1,R15              PT. R1 TO COLUMN 72         @OZ61577
         CR    R3,R1               PSWD EXTEND TO COL. 72 ...  @OZ61577
         BNL   RPUTPSR1            YES, BLANK IT OUT           @OZ61577
         BAL   R2,RPUTPSR2         FIND THE END OF THE PSWD    @OZ77291
         BCTR  R1,0                ELSE, PT. R1 TO COL. 71     @OZ61577
         SR    R1,R3               COMPUTE OVERLAY LENGTH      @OZ61577
         EX    R1,RPUTOLAY         OVERLAY PASSWORD            @OZ61577
         SPACE 1                                               @OZ61577
RPUTPSR1 LR    R1,R3               COMPUTE PASSWORD LENGTH     @OZ61577
         SR    R1,R6                AND STOR IN R1             @OZ61577
         LTR   R1,R1               IF NO PASSWORD              @OZ78752
         BZR   R7                    RETURN TO CALLER          @OZ78752
         LR    R2,R15              COMPUTE BEGINNING OF BLANK  @OZ61577
         SR    R2,R1                FIELD AND STORE IN R2      @OZ61577
         BCTR  R1,0                DECREMENT PASSWORD LENGTH   @OZ61577
         EX    R1,RPUTINSB         BLANK OUT END OF JCL CARD   @OZ61577
         SPACE 1                                               @OZ61577
         LR    R3,R6               PT R3 TO NEW 'END'          @OZ61577
*                                   OF PASSWORD FIELD          @OZ61577
         BR    R7                  RETURN TO CALLER            @OZ61577
         EJECT ,                                               @OZ61577
RPUTPSR2 CLI   0(R3),C','          FIND THE                    @OZ77291
         BER   R2                   DELIMITER OF               @OZ77291
         CLI   0(R3),C' '            THE PASSWORD              @OZ77291
         BER   R2                     FIELD AND                @OZ77291
         CLI   0(R3),C')'              RETURN TO               @OZ77291
         BER   R2                       BLANK IT OUT           @OZ77291
         CR    R3,R1               AT COL 72 YET...            @OZ77291
         BNL   RPUTPSR1            YES, BLANK OUT END OF CARD  @OZ77291
         LA    R3,1(,R3)           POINT TO NEXT CHARACTER     @OZ77291
         B     RPUTPSR2            KEEP LOOKING                @OZ77291
         SPACE 3                                               @OZ77291
RPUTOLAY MVC   0(0,R6),0(R3)       OVERLAY PSWD IN JCL CARD    @OZ77291
*                                   (EXECUTE ONLY)             @OZ61577
RPUTINSB MVC   0(0,R2),=CL8' '     BLANK OUT END OF JCL CARD   @OZ61577
*                                   (EXECUTE ONLY)             @OZ61577
         SPACE 3                                               @OZ61577
RPUTPSTB DC    256X'00'            TRANSLATE                   @OZ61577
         ORG   RPUTPSTB+C'$'        TABLE                      @OZ61577
         DC    C'$'                  USED                      @OZ61577
         ORG   RPUTPSTB+C'#'          TO                       @OZ61577
         DC    C'#@'                   VALIDATE                @OZ61577
         ORG   RPUTPSTB+C'A'            PASSWORD               @OZ61577
         DC    C'ABCDEFGHI'              CHARACTERS            @OZ61577
         ORG   RPUTPSTB+C'J'                 "                 @OZ61577
         DC    C'JKLMNOPQR'                  "                 @OZ61577
         ORG   RPUTPSTB+C'S'                 "                 @OZ61577
         DC    C'STUVWXYZ'                   "                 @OZ61577
         ORG   RPUTPSTB+C'0'                 "                 @OZ61577
         DC    C'0123456789'                 "                 @OZ61577
         ORG   ,                             "                 @OZ61577
         SPACE 2                                               @OZ61577
         LTORG ,                                               @OZ61577
         SPACE 3
$RDREND  DS    0D                  DEFINE END OF CSECT
$DLENGTH $DLENGTH                  COMPUTE CONTROL SECTION LENGTH
HASPRDRO CSECT                     DEFINE SUBROUTINE CSECT
$RDROEND DS    0D                  DEFINE END OF CSECT
$OLENGTH $DLENGTH HEADER=O         COMPUTE CONTROL SECTION LENGTH
HASPRSCN CSECT                     DEFINE ACCOUNTING FIELD SCAN CSECT
$SLENGTH $DLENGTH HEADER=S         COMPUTE CONTROL SECTION LENGTH
APARNUM  DC    CL5'72122'          APAR NUMBER
         END
APARNUM  DC    CL5'80882'          APAR NUMBER
*        THIS LINE DELETED BY APAR NUMBER                      @OZ64248
