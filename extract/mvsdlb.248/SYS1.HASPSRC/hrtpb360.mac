HRTP     TITLE 'SYSTEM/360 WORK STATION PROGRAM - PROLOGUE'
***********************************************************************
*                                                                     *
* MODULE NAME = HRTPB360                                              *
*                                                                     *
* DESCRIPTIVE NAME = SYSTEM/360 WORK STATION PROGRAM                  *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 RELEASE 2, LEVEL 0                                  *
*                                                                     *
* FUNCTION = TO PROVIDE THE SYSTEM/360 WORK STATION COMPONENT FOR RJE *
*            IMPLEMENTATION USING THE MULTI-LEAVING DISCIPLINE OF     *
*            RTAM.  THIS PROGRAM EXTENDS TO THE REMOTE LOCATION THE   *
*            FACILITIES OF LOCAL DEVICES SUCH AS OPERATOR CONSOLE     *
*            TYPEWRITER, CARD READER(S), CARD PUNCH(ES), HIGH SPEED   *
*            LINE PRINTER(S).  THE MODULE OPERATES IN A STAND-ALONE   *
*            ENVIRONMENT AND REQUIRES NO EXTERNAL SUPPORT PROGRAM.    *
*            THE SOURCE CODE IS ASSEMBLED USING THE OS/VS2 ASSEMBLER  *
*            F PROGRAM IN ORDER TO SHARE THE GENERATION PARAMETERS    *
*            USED TO QUALIFY THE HOST SYSTEM.  FOR AN EXPLANATION OF  *
*            THE INTERNAL PROGRAM OPERATION SEE OS/VS2 JES2 LOGIC.    *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*    DEPENDENCIES = RTAM MULTI-LEAVING PROTOCOL                       *
*                                                                     *
*    RESTRICTIONS = NONE                                              *
*                                                                     *
*    REGISTER CONVENTIONS = SEE *SYMBOLIC REGISTER DEFINITIONS*       *
*                                                                     *
*    PATCH LABEL = NONE                                               *
*                                                                     *
* MODULE TYPE = STAND-ALONE PROGRAM                                   *
*                                                                     *
*    PROCESSOR = ASSEMBLER F                                          *
*                                                                     *
*    MODULE SIZE = AS SPECIFIED BY RMTGEN PARAMETER &CORESIZ          *
*                                                                     *
*    ATTRIBUTES = STAND-ALONE                                         *
*                                                                     *
* ENTRY POINT = REPLOAD                                               *
*                                                                     *
*    PURPOSE = SEE FUNCTION                                           *
*                                                                     *
*    LINKAGE = ENTERED FROM SYSTEM/360 LOAD PROGRAM VIA END CARD LABEL*
*                                                                     *
* INPUT = (1) OS/VS2 JOBSTREAM VIA 80 COLUMN CARD READER              *
*         (2) OPERATOR COMMANDS VIA TYPEWRITER KEYBOARD OR CARD READE *
*         (3) MULTI-LEAVING BLOCKS VIA T/P LINE FROM HOST PROCESSOR   *
*                                                                     *
* OUTPUT = (1) SYSTEM DIRECTED OUTPUT FROM HOST PROCESSOR VIA HIGH    *
*              SPEED LINE PRINTER OR 80 COLUMN CARD PUNCH             *
*          (2) RESPONSES TO OPERATOR COMMANDS VIA TYPEWRITER PRINTER  *
*          (3) MULTI-LEAVING BLOCKS VIA T/P LINE TO HOST PROCESSOR    *
*          (4) LOCALLY GENERATED OPERATOR MESSAGES                    *
*                                                                     *
* EXIT-NORMAL = NONE                                                  *
*                                                                     *
* EXIT-ERROR = NONE                                                   *
*                                                                     *
* EXTERNAL REFERENCES = NONE                                          *
*                                                                     *
*    ROUTINES = NONE                                                  *
*                                                                     *
*    DATA AREAS = NONE                                                *
*                                                                     *
*    CONTROL AREAS = NONE                                             *
*                                                                     *
* TABLES = (1) ERROR MESSAGE TABLE - SEE LABEL $LOGTAB                *
*          (2) TOTAL CONTROL TABLES                                   *
*                  CONTROL PROCESSOR - SEE LABEL $CTLTCT              *
*                  CONSOLE - SEE LABEL $CONTCT                        *
*                  PRINTER - SEE LABEL $PCOM1                         *
*                  READER - SEE LABEL $RCOM1                          *
*                  PUNCH - SEE LABEL $UCOM1                           *
*                                                                     *
* MACROS = ALL MACROS ARE LOCAL TO THE ASSEMBLY                       *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*     RELEASE 4.0 = OZ04986,OZ07448,OZ07454,OZ09048,OZ09109           *
*                                                                     *
*     RELEASE 4.1 = OZ12280,OZ13217,OZ13240,OZ15819                   *
*                                                                     *
***********************************************************************
         TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(MODEL 20 INSTS.)'
*
*****   BAS    *****          BRANCH AND STORE
*
         MACRO
&NAME    BAS   &R,&LOC
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'4D'
         DC    AL1(&R*16)
         DC    S(&LOC)
         AGO   .END
.ANOT20  ANOP
         BAL   &R,&LOC
.END     MEND
         SPACE 4
*
*****   BASR   *****          BRANCH AND STORE (R)
*
         MACRO
&NAME    BASR  &R1,&R2
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'0D'
         DC    AL1(&R1*16+&R2)
         AGO   .END
.ANOT20  ANOP
         BALR  &R1,&R2
.END     MEND
         SPACE 4
*
*****   CIO    *****          CONTROL I/O
*
         MACRO
&NAME    CIO   &A,&B
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'9B'
         DC    AL1(&B)
         DC    S(&A)
         AGO   .END
.ANOT20  ANOP
         BAL   R7,$IOSIM
         DC    X'9B'
         DC    AL1(&B)
         DC    S(&A)
.END     MEND
         EJECT
*
*        DIALS                     READ MOD 20 DIALS
*                                  DATA 1,2 IN LOC 252
*                                  ADDRESS 1,2,3,4 IN 253-254 DEC
         MACRO
&NAME    DIALS &NULL
&NAME    DS    0H
         DC    X'83000300' 
         MEND
         SPACE 4
*
*****   HPR    *****          HALT AND PROCEED
*
*
         MACRO
&NAME    HPR   &NUM
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'9900',S(&NUM)
         AGO   .END
.ANOT20  ANOP
.END     MEND
         SPACE 4
*
*****   TIOB   *****          TEST I/O AND BRANCH
*
*
         MACRO
&NAME    TIOB  &A,&B
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    X'9A'
         DC    AL1(&B)
         AIF   ('&A' EQ '*').A2
         DC    S(&A)
         AGO   .END
.A2      ANOP
         DC    S(*-2)
         AGO   .END
.ANOT20  ANOP
         MNOTE 12,'***ERROR*** INVALID 360 INSTRUCTION'
.END     MEND
         EJECT
         SPACE 16
*
*****   XIO    *****          TRANSFER I/O
*
*
         MACRO
&NAME    XIO   &A,&B
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE EQ 20).A20
         MNOTE 12,'***ERROR*** INVALID 360 INSTRUCTION'
.A20     ANOP
         MVC   &A,&B     XIOXIOXIOXIOXIOXIO
         ORG   *-6       XIOXIOXIOXIOXIOXIO
         DC    X'D0'     XIOXIOXIOXIOXIOXIO
         ORG   *+5       XIOXIOXIOXIOXIOXIO
.END     MEND
 TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(SYSTEM DEPENDENT AIDS)'
*
*        $AA                       ADD ADDRESS TO REGISTER(CONSTANT)
*
         MACRO
&NAME    $AA   &REG,&AMT
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).A1
&NAME    LA    &REG,&AMT.(&REG)
         MEXIT
.A1      ANOP
&NAME    AH    &REG,=Y(&AMT)
         MEND
         SPACE 1
*
*****    $ACON  *****              DEFINE AN ADDRESS CONST
*
         MACRO
&NAME    $ACON &ADDR
         GBLA  &HICORE
         AIF   (T'&ADDR EQ 'O').ZERO BR IF OPERAND OMITTED
         AIF   (&HICORE GT 32).FULL  BR IF ADDR WILL EXCEED 32K
         AIF   ('&ADDR'(1,1) NE '(').RA
&NAME    DC    Y&ADDR
         MEXIT
.RA      ANOP
&NAME    DC    Y(&ADDR)
         MEXIT
.FULL    ANOP
         AIF   ('&ADDR'(1,1) NE '(').RB
&NAME    DC    A&ADDR
         MEXIT
.RB      ANOP
&NAME    DC    A(&ADDR)
         MEXIT
.ZERO    ANOP
         AIF   (&HICORE GT 32).FULLZ BR IF ADDR WILL EXCEED 32K
&NAME    DC    Y(0)
         MEXIT
.FULLZ   ANOP
&NAME    DC    A(0)
         MEND
         SPACE 1
*
*        $ACONS                    DEFINE STORAGE FOR ADDRESS CONSTANT
*
         MACRO
&NAME    $ACONS &NULL
         GBLA  &HICORE
         AIF   (&HICORE GT 32).FULL
&NAME    DS    H
         MEXIT
.FULL    ANOP
&NAME    DS    F
         MEND
         EJECT
*
*****    $BCTR *****               BRANCH ON COUNT (RR)
*
*
         MACRO
&NAME    $BCTR &RA,&RB
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).S360
         AH    &RA,=H'-1'
         AIF   ('&RB' EQ '0' OR '&RB' EQ 'R0').END
         BCR   7,&RB
.END     MEXIT
.S360    ANOP
         BCTR  &RA,&RB
         MEND
         SPACE 4
*
*        $BITOFF                   TURN CORRESPONDING BIT OFF
*
         MACRO
&NAME    $BITOFF &A,&B,&R
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).A1
&NAME    OC    &A,&B
         XC    &A,&B
         MEXIT
.A1      ANOP
&NAME    $OC   &A,&B
         LH    &R,&A
         SH    &R,&B
         STH   &R,&A
         MEND
         SPACE 4
*
*        $CA                       COMPARE REG TO STORAGE
*
         MACRO
&NAME    $CA   &REG,&ADDR
         GBLA  &HICORE
         AIF   (&HICORE LE 32).C1
&NAME    C     &REG,&ADDR
         MEXIT
.C1      ANOP
&NAME    CH    &REG,&ADDR
         MEND
         EJECT
*
*****   $CCW   *****          DEFINE A CHANNEL COMMAND WORD
*
         MACRO
&NAME    $CCW  &OP,&AD,&BITS,&CT
&NAME    DC    0D'0',AL1(&OP),AL3(&AD),AL1(X'&BITS'),AL3(&CT) CCW
         MEND
         SPACE 1
*
******   COUNT *****          A DEBUG MACRO TO COUNT EVENTS
*
*
         MACRO
&NAME    COUNT &COM
         GBLA  &DEBUG
         AIF   (&DEBUG EQ 0).END
&NAME    AP    *+10(6),=X'1C'
         B     *+10
         DC    XL6'0C'
         MNOTE *,'COUNT OF &COM ***************'
.END     MEND
         SPACE 1
*
****     $LA                       LOAD ADDRESS MACRO FOR 20'S
*
*
         MACRO
&NAME    $LA   &REG,&LOC
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).NOT20
&NAME    LH    &REG,=Y(&LOC)
         MEXIT
.NOT20   ANOP
&NAME    LA    &REG,&LOC
         MEND
         SPACE 1
*
*        $LMHA                     LOAD AND MULTIPLY HALF WORD ADDRESS
*                                  ASSUMES SMALL NUMBERS AND NOT ZERO
         MACRO
&NAME    $LMHA &REG1,&REG2,&ADDR1,&ADDR2
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).S1
&NAME    LH    &REG1,&ADDR1
         MH    &REG1,&ADDR2
         MEXIT
.S1      ANOP
&NAME    SR    &REG1,&REG1
         LH    &REG2,&ADDR2
         AH    &REG1,&ADDR1
         AH    &REG2,=H'-1'
         BH    *-8
         MEND
         EJECT
*
******  $LOAD  *****               LOAD MACRO
*
*
         MACRO
&NAME   $LOAD  &REG,&ADDR
&NAME    LH    &REG,&ADDR
         MEND
         SPACE 4
*
*****    $LTR  *****               LOAD REGISTER AND SET CC
*
*
         MACRO
&NAME    $LTR  &RA,&RB
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).S360
         AIF   ('&RA' EQ '&RB').RSAME
         SR    &RA,&RA
         AR    &RA,&RB
         MEXIT
.RSAME   ANOP
&NAME    AH    &RA,=H'0'
         MEXIT
.S360    ANOP
&NAME    LTR   &RA,&RB
         MEND
         SPACE 4
*
*****    $OC   *****               STORAGE-TO-STORAGE OR
*
*
         MACRO
&NAME    $OC   &A,&B
         GBLA  &MACHINE
&NAME    NULL  *
         AIF   (&MACHINE NE 20).S360
*        NOTE THAT THIS IS A VERY RESTRICTIVE
*        SIMULATION OF THE 'OC' INSTRUCTION FOR THE MODEL 20
         MVC   *+7(1),&B
         OI    &A,*-*
         MVC   *+7(1),&B+1
         OI    &A+1,*-*
         MEXIT
.S360    ANOP
         OC    &A,&B
         MEND
         EJECT
*
*****   NULL   *****          DEFINE A SYMBOLIC LOCATION
*
*
         MACRO
&NAME    NULL
         AIF   ('&NAME' NE '').X
         MEXIT
.X       ANOP
&NAME    DS    0H
         MEND
         SPACE 4
*
***** $RESTORE *****     RESTORE SAVED REGISTERS
*
*
         MACRO
&NAME    $RESTORE &R1,&RN,&LOC
         GBLA  &MACHINE
         LCLA  &A,&B,&C
         LCLC  &D,&E
         AIF   (&MACHINE NE 20).M30
&NAME    NULL
&D       SETC  '&R1'(2,K'&R1-1)
&A       SETA  &D
&D       SETC  '&RN'(2,K'&RN-1)
&B       SETA  &D
&C       SETA  0
.N       LH    R&A,&LOC+&C
&C       SETA  &C+2
&A       SETA  &A+1
         AIF   ('R&A' LE '&RN').N
         MEXIT
.M30     ANOP
&NAME    LM    &R1,&RN,&LOC
         MEND
         SPACE 4
*
*        $SA                       SUBTRACT ADDRESS
*
         MACRO
&NAME    $SA   &REG,&ADDR
         GBLA  &HICORE
         AIF   (&HICORE GT 32).S1
&NAME    SH    &REG,=Y(&ADDR)
         MEXIT
.S1      ANOP
&NAME    S     &REG,=A(&ADDR)
         MEND
         EJECT
         SPACE 6
*
*****   $SAVE  *****          SAVE REGISTERS
*
*
         MACRO
&NAME    $SAVE &R1,&RN,&LOC
         GBLA  &MACHINE
         LCLA  &A,&B,&C
         LCLC  &D,&E
&NAME    NULL
         AIF   (&MACHINE NE 20).N20
&D       SETC  '&R1'(2,K'&R1-1)
&A       SETA  &D
&D       SETC  '&RN'(2,K'&RN-1)
&B       SETA  &D
&C       SETA  0
.N       STH   R&A,&LOC+&C
&C       SETA  &C+2
&A       SETA  &A+1
         AIF   ('R&A' LE '&RN').N
         AGO   .END
.N20     STM   &R1,&RN,&LOC
.END     MEND
         SPACE 6
*
*****   SPSW   *****          SET PSW
*
*
         MACRO
&NAME    SPSW  &LOC
         GBLA  &MACHINE
&NAME    NULL
         AIF   (&MACHINE NE 20).ANOT20
         DC    AL4(&LOC) SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         ORG   *-4       SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         DC    X'8100'   SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         ORG   *+2       SPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSWSPSW
         AGO   .END
.ANOT20  ANOP
         LH    R7,&LOC+2
         LPR   R7,R7
         BR    R7
.END     MEND
         EJECT
*
*****   $SSM   *****          CONTROL MACHINE INTERRUPT STATUS
*
*
         MACRO
&NAME   $SSM   &MASK
         GBLA  &MACHINE
         AIF   (&MACHINE NE 20).X
&NAME    SPSW  *+4
         AIF   ('&MASK' EQ '0').OFF
         DC    AL2(X'0100')
         DC    Y(*+2)
         AGO   .END
.OFF     ANOP
         DC    AL4(*+4)
         AGO   .END
.X       ANOP
&NAME    SSM   =X'&MASK'
.END     MEND
         SPACE 4
*
*        $STO                      STORE REG INTO ADDRESS CONSTANT
*
         MACRO
&NAME   $STO  &REG,&ADDR
&NAME    STH   &REG,&ADDR
         MEND
         SPACE 4
*
*****    $SUB  *****               SUBTRACT MACRO
*
*
         MACRO
&NAME    $SUB  &REG,&ADDR
         GBLA  &HICORE
         AIF   (&HICORE GT 32).FULL  BR IF ADDR WILL EXCEED 32K
&NAME    SH    &REG,&ADDR
         MEXIT
.FULL    ANOP
&NAME    S     &REG,&ADDR
         MEND
         EJECT
         SPACE 6
*
*****    $TRACE  *****      TRACE PROGRAM FLOW
*
*
         MACRO
&NAME    $TRACE &TYPE=,&SSM=YES
         GBLA  &MACHINE
         GBLA  &TRACE
&NAME    NULL
         AIF   (&TRACE EQ 0).NONE
         AIF   (&MACHINE NE 20).TRACE
         BASR  12,12 *****************S U P E R T R A C E *************
         AGO   .TRACE1
.TRACE   ANOP
         SVC   X'CC' *****************S U P E R T R A C E *************
.TRACE1  ANOP
         DC    H'0'  *****************S U P E R T R A C E *************
         AIF   ('&SSM' NE 'YES').NOSSM
         $SSM  FF
.NOSSM   ANOP
.NONE    MEND
         SPACE 6
*
*****    $WCON  *****   DEFINE CONSTANT FOR MACHINE WORD SIZE
*
*
         MACRO
&NAME    $WCON &ADDR
         GBLA  &HICORE
         LCLA  &T
&T       SETA  &HICORE
&HICORE  SETA  64
&NAME    $ACON &ADDR
&HICORE  SETA  &T
         MEND
 TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(DATA MANAGEMENT)'
         SPACE 10
*
*  $CHAIN  -  ADD AN ITEM TO THE END OF A CHAIN
*
*
         MACRO
&NAME    $CHAIN &SOC,&R,&SSM
         LCLC  &WR
&NAME    NULL
&WR      SETC  'R8'
         AIF   ('&R' NE 'R8').ROK
&WR      SETC  'R9'
.ROK     ANOP
         AIF   ('&SSM' NE '').NOSSM
         $SSM  0
.NOSSM   ANOP
         $TRACE SSM=NO
         AIF   ('&SOC'(1,1) NE '(').NORM
&WR      SETC  '&SOC(1)'
         AGO   .REG
.NORM    ANOP
         $STO  &WR,$CHNTEMP
         LH    &WR,=Y(&SOC)
.REG     ANOP
         CLI   0(&WR),0
         BE    *+12
         LH    &WR,0(0,&WR)
         B     *-12
         STH   &R,0(0,&WR)
         MVC   0(2,&R),=H'0'
         AIF   ('&SOC'(1,1) EQ '(').REGA
         $LOAD &WR,$CHNTEMP
.REGA    ANOP
         AIF   ('&SSM' NE '').END
         $SSM  FF
.END     MEND
         EJECT
         SPACE 8
*
*        $CHECK                    CHECKS FOR I/O COMPLETION
*
         MACRO
&NAME    $CHECK &PRE,&ERR,&EOF,&T=
         GBLA  &MACHINE,&A
         LCLC  &R
&R       SETC  '&PRE'
         AIF   ('&T' EQ '').R4
&R       SETC  '&T'
.R4      ANOP
         AIF   (&MACHINE NE 20).R1
&A       SETA  &A+1
&NAME    MVC   $&PRE.COMM1+2(2),&PRE.ACN&A
&PRE.LOC&A TIOB $&PRE.COMM1+4,&R.BUSY
         AIF   ('&ERR' EQ '').R2
         TIOB  &ERR,&R.ERROR
         AIF   ('&EOF' EQ '').R2
         TIOB  &EOF,&R.EOF
.R2      ANOP
         MEXIT
.R1      ANOP
&NAME    BAL   R14,$IOCK
         AIF   ('&ERR' EQ '').R3
         BC    3,&ERR
         AIF   ('&EOF' EQ '').R3
         BC    4,&EOF
.R3      ANOP
         MEND
         EJECT
         SPACE 6
*
*  $DCHAIN  -  REMOVE THE FIRST ITEM FROM A CHAIN
*
*
         MACRO
&NAME    $DCHAIN &SOC,&R,&SSM,&EMPTY=
         GBLA  &MACHINE
         GBLA  &HICORE
         LCLA  &L
&NAME    NULL
         AIF   ('&SSM' NE '').NOSSM
         $SSM  0
.NOSSM   ANOP
         AIF   (&HICORE GT 32).CLC
&L       SETA  2
         CLI   &SOC,0
         AGO   .CLCEND
.CLC     CLC   &SOC,=F'0'
&L       SETA  4
.CLCEND  ANOP
         AIF   ('&SSM' EQ '').BREL
         AIF   ('&EMPTY' EQ '').BREL
         BE    &EMPTY
         AGO   .BREL1
.BREL    BE    *+14
.BREL1   ANOP
         $LOAD &R,&SOC
         MVC   &SOC.(&L),0(&R)
         AIF   ('&SSM' NE '').END
         AIF   (&MACHINE NE 20).NOCC
         MVI   *+16,X'31'
         BNZ   *+8
         MVI   *+8,X'01'
.NOCC    ANOP
         $SSM  FF
         MEXIT
         AIF   ('&EMPTY' EQ '').END
         BE    &EMPTY
.END     MEND
         EJECT
         SPACE 6
*
*  $FREE  -  ADD AN ITEM TO THE BEGINING OF A CHAIN
*
*
         MACRO
&NAME    $FREE &SOC,&R,&SSM
&NAME    NULL
         AIF   ('&SSM' NE '').NOSSM
         $SSM  0
.NOSSM   ANOP
        $TRACE SSM=NO
         MVC   0(2,&R),&SOC
         STH   &R,&SOC
         AIF   ('&SOC' NE '$TANKPOL').NONTANK
         MVI   $TPGETCM+1,X'F0'    OPEN TPGET GATE
.NONTANK ANOP
         AIF   ('&SSM' NE '').END
         $SSM  FF
.END     MEND
         SPACE 6
*
*        $GETTNK                   GET A TANK AND POST COMPLETION
*
         MACRO
&NAME    $GETTNK &PRE,&REG,&REGA,&EMPTY=WAIT
         GBLA  &MACHINE
         AIF   ('&EMPTY' EQ 'WAIT').A1
&NAME    $DCHAIN &PRE.CTTANK,&REG,ENBL,EMPTY=&EMPTY
         AGO   .A2
.A1      AIF   (&MACHINE EQ 20).A3
&NAME    BAL   R14,$GETTNK         REG R8 WILL HAVE TANK ADDR ON RETURN
         MEXIT
.A3      ANOP
&NAME    $DELAY &PRE,TYPE=SETUP,TIME=LONG
         $DCHAIN &PRE.CTTANK,&REG,ENBL,EMPTY=&PRE.CTRTN
         $OPEN &PRE,&REGA
.A2      $TCTPOST &PRE,&REGA
         MEND
         EJECT
         SPACE 4
*
*          $INTREQ                 INTERVENTION REQUIRED
*
         MACRO
&NAME    $INTREQ &PRE,&COM,&PREVLOC=
         GBLA  &MACHINE,&CONSOLE
         AIF   (&MACHINE EQ 20).R1
&NAME    MVI   &PRE.CTECB,TCTBUSY      SET UP TO WAIT ON DEV END
         AIF   ('&PREVLOC' EQ '').R3
         B     &PREVLOC
         MEXIT
.R1      ANOP
         AIF   (&CONSOLE EQ 0).R2
&NAME    OI    &PRE.CTSTAT,TCTSTOP     SET STOP STATUS
         $SSM  0
         MVI   $LOGINFO+2,&PRE.ADR     LOG UNIT CHECK
         $LOG  XUNITCHK
         $SSM  FF
         $DELAY &PRE,TIME=SHORT,TYPE=SETUP
         TM    &PRE.CTSTAT,TCTSTOP     TEST FOR OPERATOR RESPONSE
         BO    $&PRE.COMM1+4           WAIT IF NO ACTION
         AGO   .R5
         MEXIT
.R2      ANOP
&NAME    HPR   &PRE.ADR                WAIT FOR OPERATOR TO STOP UNIT
.R5      AIF   ('&PREVLOC' EQ '').R3
         B     &PREVLOC
.R3      MEND
         SPACE 4
*
*****   $LOG   *****          LOG A COMMUNICATIONS ERROR
*
*
         MACRO
&NAME    $LOG  &TYPE,&SAVE
&NAME    NULL
         AIF   ('&SAVE' NE 'SAVE').DOIT
        $STO   R15,$LOGSAVE
.DOIT    BAS   R15,$LOG
         DC    AL2(&TYPE*(LOGEND-LOGDSECT))
         AIF   ('&SAVE' NE 'SAVE').END
        $LOAD  R15,$LOGSAVE
.END     MEND
         EJECT
         SPACE 6
*
*        $PUT                      GIVES TANK TO COMPRESSION ROUTINES
*
         MACRO
&NAME    $PUT  &PRE,&ADDR
         GBLA  &A
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).M20
&NAME    LA    R8,&ADDR         ****DESTROYS R8,R15
         BAL   R14,$PUT
         MEXIT
.M20     ANOP
&A       SETA  &A+1
&NAME    MVC   $&PRE.COMM1+2(2),&PRE.ACN&A
         BAS   R14,$PUT            *** DESTROYS R8,R15
&PRE.LOC&A BAS   R14,$PUTA
         $ACON (&ADDR)
         $ACON (&PRE.TCT)              ADDRESS OF TCT
         B     $&PRE.COMM1+4       RETURN TO COMMUTATOR
         MEND
         SPACE 6
*
*****    $SIO  *****          START FOR /360 MACHINES
*
         MACRO
&NAME    $SIO  &CCW
&NAME    BAL   R15,$SIO
         DC    AL4(&CCW)
         MEND
         EJECT
*
*        $READ                     INITIATES I/O ON UNIT REC DEV
*
         MACRO
&NAME    $READ &PRE,&AREA,&BASE,&CTADDR=,&OP=,&T=R,&S=
         GBLA  &RDEV(7)
         GBLA  &UDEV(7)
         GBLA  &MACHINE,&A
         GBLB  &R(10)              CONFIGURATION SCOREBOARD
         LCLC  &LOP,&ADDR
         AIF   (&MACHINE NE 20).R1
&A       SETA  &A+1
         AIF   ('&CTADDR' EQ '').R2
         MVC   &PRE.LOC&A+5(1),1+&CTADDR
.R2      ANOP
&ADDR    SETC  '0'
         AIF   ('&AREA' EQ '').R10
&ADDR    SETC  '&AREA'
         AIF   ('&AREA' NE '(R8)').R3
         STH   R8,&PRE.LOC&A+2
         AGO   .R10
.R3      AIF   ('&BASE' EQ '').R10
         AH    R8,=Y(&AREA-&BASE)
         STH   R8,&PRE.LOC&A+2
.R10     ANOP
&LOP     SETC  '&PRE'.'OPCODE'
         AIF   ('&OP(1)' EQ '' OR '&OP(2)' NE '').R4
&LOP     SETC  '&OP(1)'
.R4      ANOP
&NAME    MVC   $&PRE.COMM1+2(2),&PRE.ACN&A
         AIF   ('&T' EQ 'R').R12
         AIF   ('&PRE' NE 'U' AND '&PRE' NE 'R').R12
         AIF   (&UDEV(1) NE 2560 AND &R(7)).R12
         CIO   UPOC,USTACK         SELECT POCKET FOR CARD TO BE PUNCHED
.R12     ANOP
         AIF   ('&S' EQ '').R14
&S       DS    0H
.R14     ANOP
&PRE.LOC&A XIO &ADDR.(&LOP+1),&PRE.CT
         BC    7,$&PRE.COMM1+4
         AIF   ('&T' NE 'R' OR '&PRE' NE 'R').R13
         AIF   (&RDEV(1) NE 2560 AND &R(7)).R13
         CIO   RPOC,RSTACK         SELECT POCKET FOR CARD READ
.R13     MEXIT
.R1      ANOP
         AIF   ('&CTADDR' EQ '').R6
         MVC   &PRE.CTCCWCT+1(1),1+&CTADDR
.R6      ANOP
         AIF   ('&AREA' EQ '').R7
         AIF   ('&AREA' EQ '(R8)').R8
         LA    R8,&AREA            *** DESTROYS R8
.R8      ANOP
         ST    R8,&PRE.CTCCW
.R7      ANOP
         AIF   ('&OP(1)' EQ '' OR '&OP(2)' NE '' AND &R(2) AND         C
               &R(3)).R9
         AIF   ('&OP(2)' EQ '').R11
         MVC   &PRE.CTCCW,&OP(1)
&NAME    BAL   R14,$XIOA
         MEXIT
.R11     MVI   &PRE.CTCCW,&OP(1)
&NAME    BAL   R14,$XIOA
         MEXIT
.R9      ANOP
&NAME    BAL   R14,$XIO
         MEND
         SPACE 6
*
*        $WRITE                    INITIATES I/O ON UNIT REC DEV
*
         MACRO
&NAME    $WRITE &PRE,&AREA,&BASE,&CTADDR=,&OP=,&S=
&NAME    $READ &PRE,&AREA,&BASE,CTADDR=&CTADDR,OP=&OP,T=W,S=&S
         MEND
 TITLE 'H A S P / R T P  *MACRO DEFINITIONS*(TASK MANAGEMENT)'
         SPACE 20
*
*        $CLOSE                    CLOSE COMMUTATOR GATE AND EXIT
*
         MACRO
&NAME    $CLOSE &PRE
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).A1
&NAME    B     $CLOSTCT            CLOSE GATE AND RETURN TO COMMUTATOR
         MEXIT
.A1      ANOP
&NAME    NI    $&PRE.COMM1+1,X'0F'      CLOSE GATE
         B     $&PRE.COMM1+4           RETURN TO COMMUTATOR
         MEND
         EJECT
*
*        $DELAY                    WAIT ONE TIME AROUND COMMUTATOR
*                                  ESTABLISH REENTRY POINT
         MACRO
&NAME    $DELAY &PRE,&ADR,&TYPE=BRANCH,&TIME=SHORT,&PREVLOC=*
         GBLA  &MACHINE,&A
         LCLC  &COM
&COM     SETC  '&ADR'
         AIF   ('&ADR' NE '').R3
&COM     SETC  '&PRE'
.R3      ANOP
&A       SETA  &A+1
         AIF   (&MACHINE NE 20).R1
&NAME    MVC   $&COM.COMM1+2(2),&PRE.ACN&A
         AIF   ('&TYPE' EQ 'BRANCH').R10
         AIF   ('&TIME' EQ 'SHORT').R5
&PRE.LOC&A NI  $&COM.COMM1+1,X'0F'     CLOSE GATE INTERCEPT REENTRY
         AGO   .R7
.R10     AIF   ('&TIME' EQ 'SHORT').R5
         NI    $&COM.COMM1+1,X'0F'     CLOSE GATE REENTER ELSEWARE
.R5      ANOP
         AIF   ('&TYPE' NE 'BRANCH').R2
         B     $&COM.COMM1+4
         AGO   .R2
.R1      ANOP
&NAME    MVC   &COM.CTENTY(2),&PRE.ACN&A
         AIF   ('&TYPE' EQ 'BRANCH').R9
         AIF   ('&TIME' EQ 'SHORT').R6
&PRE.LOC&A $LOAD R8,&COM.CTCOM       CLOSE GATE INTERCEPT REENTRY
         NI    1(R8),X'0F'
         AGO   .R8
.R9      AIF   ('&TIME' EQ 'SHORT').R6
         $LOAD R8,&COM.CTCOM           CLOSE GATE REENTER ELSEWARE
         NI    1(R8),X'0F'
.R6      ANOP
         AIF   ('&TYPE' NE 'BRANCH').R2
         B     &COM.CTRTN
.R2      ANOP
&PRE.LOC&A EQU &PREVLOC
.R8      ANOP
.R7      ANOP
         MEND
         EJECT
*
*        ENDPROC                   USED TO BUILD REENTRY PTS TO
*                                  PROCESSORS
         MACRO
         $ENDPROC &PRE
         GBLA  &A
         LCLA  &B
&B       SETA  1
.E2      AIF   (&B GT &A).E1
&PRE.ACN&B DC  S(&PRE.LOC&B)
&B       SETA  &B+1
         AGO   .E2
.E1      ANOP
         MEND
         SPACE 6
*
*        $OPEN                     OPENS THE DESIGNATED COMMUTATOR
*
         MACRO
&NAME    $OPEN &PRE
         GBLA  &MACHINE
         AIF   (&MACHINE EQ 20).R1
&NAME    $LOAD R9,&PRE.CTCOM           FIND COMMUTATOR FROM TCT
         OI    1(R9),X'F0'
         MEXIT
.R1      ANOP
&NAME    OI    $&PRE.COMM1+1,X'F0'
         MEND
         SPACE 6
*
*        $TCTPOST                  POST $TPGET TO QUE MORE TANKS
*
         MACRO
&NAME    $TCTPOST &PRE,&REG
&NAME    LH    &REG,&PRE.CTTNKLM         REDUCES COUNT IN TNKCT
         $BCTR &REG,0
         STH   &REG,&PRE.CTTNKLM
         OI    &PRE.CTSTAT,TCTACT      SIGNAL WE HAVE RECEIVED TANK
         OI    $TPGETCM+1,X'F0'    OPEN THE GATE TO TPGET ROUTINE
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $CONFIG'
*
*        $CONFIG                   SETS GLOBALS AND CREATES EQUATES
*
         MACRO
&NAME    $CONFIG
         GBLA  &MACHINE,&PDEV(7),&RDEV(7),&UDEV(7),&WDEV(1),&A,&B,&S(7)
         GBLA  &D,&T,&NUMPRT,&NUMRDR,&NUMPUN,&CONSOLE,&WTOSIZE
         GBLA  &LOCCOM
         GBLB  &R(10)              CONFIGURATION SCOREBOARD
         GBLC  &PADR(7),&RADR(7),&UADR(7),&WADR(1)
         AIF   (&MACHINE NE 20).SS1
*        &R(6) SET TO 0 THIS IS A MOD 20
PADR     EQU   &PADR(1)                   DESIGNATOR FOR PRINTER
RADR     EQU   &RADR(1)                   DESIGNATOR FOR READER
UADR     EQU   &UADR(1)                   DESIGNATOR FOR PUNCH
&R(6)    SETB  0                   SYSTEM IS A MOD 20
.SS1     ANOP
&A       SETA  1
         AIF   (&PDEV(1) EQ 0).SETPRT
.PLOOP   AIF   (&PDEV(&A) NE 1443).SKPP4
*        EQUATES FOR 1443 PRINTER SUPPORT
P1443    EQU   X'01'               BASIC PRINT OPCODE FOR 1443
P14431   EQU   X'01'               BASIC PRINT OPCODE FOR 1443
PF1443   EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
         AGO   .SKPP3
.SKPP4   AIF   (&PDEV(&A) NE 1403).SKPP5
*        EQUATES FOR 1403 PRINTER SUPPORT
         AIF   (&MACHINE EQ 20).SKPP6
P1403    EQU   X'01'               BASIC PRINT OPCODE FOR 1403
P14031   EQU   X'01'               BASIC PRINT OPCODE FOR 1403
PF1403   EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
         AGO   .SKPP3
.SKPP6   ANOP
POPCODE  EQU   X'40'               PRINT OPCODE FOR 1403
PBUSY    EQU   X'40'               TEST FOR BUSY ON 1403
PERROR   EQU   X'41'               TEST FOR ERROR ON 1403
         AGO   .SKPP3
.SKPP5   AIF   (&PDEV(&A) NE 2203).SKPP3X
*        EQUATES FOR 2203 PRINTER SUPPORT
POPCODE  EQU   X'40'               PRINT OPCODE FOR 2203
PBUSY    EQU   X'40'               TEST FOR BUSY ON 2203
PERROR   EQU   X'41'               TEST FOR ERROR ON 2203
         AGO   .SKPP3
.SKPP3X  AIF   (&MACHINE EQ 20).SKPP3
         AIF   (&PDEV(&A) NE 3211).SKPP3A
*        EQUATES FOR 3211 PRINTER SUPPORT
P3211    EQU   X'01'               BASIC PRINT OPCODE FOR 3211
P32111   EQU   X'01'               BASIC PRINT OPCODE FOR 3211
PF3211   EQU   X'20'               FLAGS FOR SUPPRESS WRONG LENGTH
         AGO   .SKPP3
.SKPP3A  AIF   (&PDEV(&A) NE 3203).SKPP3B
*        EQUATES FOR 3203 PRINTER SUPPORT
P3203    EQU   X'01'               BASIC PRINT OPCODE FOR 3203
P32031   EQU   X'01'               BASIC PRINT OPCODE FOR 3203
PF3203   EQU   X'20'               FLAGS FOR SUPPRESS WRONG LENGTH
&R(9)    SETB  1                   NOTE 3203 PRINTER PRESENT
         AGO   .SKPP3
.SKPP3B  AIF   (&PDEV(&A) NE 5203).SKPP3
*        EQUATES FOR 5203 PRINTER SUPPORT
P5203    EQU   X'01'               BASIC PRINT OPCODE FOR 5203
P52031   EQU   X'01'               BASIC PRINT OPCODE FOR 5203
PF5203   EQU   X'20'               FLAGS FOR SUPPRESS WRONG LENGTH
&R(10)   SETB  1                   NOTE 5203 PRINTER PRESENT
.SKPP3   ANOP
&A       SETA  &A+1
         AIF   (&A GT 7).SETPRT
         AIF   (&PDEV(&A) EQ 0).SETPRT
&T       SETA  0
&B       SETA  1
.SKPP2   AIF   (&PDEV(&A) NE &PDEV(&B)).SKPP1
&T       SETA  1
.SKPP1   ANOP
&B       SETA  &B+1
         AIF   (&B LT &A).SKPP2
         AIF   (&T EQ 0).PLOOP
         AGO   .SKPP3
.SETPRT  ANOP
&NUMPRT  SETA  &A-1
RSIZE    EQU   80                  LENGTH OF CARD
&A       SETA  1
&D       SETA  0
         AIF   (&RDEV(1) EQ 0).SETRDR
         AGO   .SKPR20
.RLOOP   AIF   (&RDEV(&A) NE 1442).SKPR6
*        EQUATES FOR 1442 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
R1442    EQU   X'42'               NORMAL READ OPCODE FOR 1442
R14421   EQU   X'42'               READ OPCODE FOR 1442 NON DUAL
RF1442   EQU   X'00'               FLAGS FOR CCW WRONG LENGTH CHECK
         AGO   .SKPR5
.SKPR6   AIF   (&RDEV(&A) NE 2501).SKPR7
*        EQUATES FOR 2501 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPRA1
R2501    EQU   X'02'               NORMAL READ OPCODE FOR 2501
R25011   EQU   X'02'               READ OPCODE FOR 2501
RF2501   EQU   X'00'               FLAGS FOR CCW WRONG LENGTH CHECK
         AGO   .SKPR5
.SKPRA1  ANOP
ROPCODE  EQU   X'12'               READ OPCODE FOR 2501
RBUSY    EQU   X'10'               TEST FOR BUSY ON 2501
RERROR   EQU   X'11'               TEST FOR ERROR ON 2501
REOF     EQU   X'14'               END OF FILE TEST ON 2501
         AGO   .SKPR5
.SKPR7   AIF   (&RDEV(&A) NE 2520).SKPR8
*        EQUATES FOR 2520 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPRA5
R2520    EQU   X'42'               NORMAL READ OPCODE FOR 2520
R25201   EQU   X'42'               READ OPCODE FOR 2520 NON DUAL
RF2520   EQU   X'00'               FLAGS FOR CCW WRONG LENGTH CHECK
         AGO   .SKPR5
.SKPRA5  ANOP
ROPCODE  EQU   X'22'               READ OPCODE FOR 2520
RSTACK   EQU   X'20'               STACKER SELECT FOR 2520 READ
RBUSY    EQU   X'20'               TEST FOR READER BUSY ON 2520
RERROR   EQU   X'21'               TEST FOR READER ERROR ON 2520
REOF     EQU   X'24'               END OF FILE TEST ON 2520
RPOC     EQU   X'02'               POCKET FOR 2520 READ
         AGO   .SKPR5
.SKPR8   AIF   (&RDEV(&A) NE 2540).SKPR9
*        EQUATES FOR 2540 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
R2540    EQU   X'42'               NORMAL READ OPCODE FOR 2540
R25401   EQU   X'42'               READ OPCODE FOR 2540
RF2540   EQU   X'00'               FLAGS FOR CCW WRONG LENGTH CHECK
         AGO   .SKPR5
.SKPR9   AIF   (&RDEV(&A) NE 2560).SKPR10
*        EQUATES FOR 2560 READ SUPPORT &R(1) SET TO 0
&R(1)    SETB  0                   NON DUAL READER ON SYSTEM
ROPCODE  EQU   X'22'               READ OPCODE FOR 2560
RBUSY    EQU   X'20'               TEST FOR BUSY ON 2560
RERROR   EQU   X'21'               TEST FOR ERROR ON 2560
REOF     EQU   X'24'               TEST FOR END OF FILE ON 2560
RPOC     EQU   X'02'               POCKET FOR 2560 READ
RSTACK   EQU   X'20'               STACK OPCODE FOR 2560
         AGO   .SKPR5
.SKPR10  AIF   (&RDEV(&A) NE 25200).SKPR11
*        EQUATES FOR 2520 DUAL READ/PUNCH SUPPORT &R(2) SET TO 0
&R(2)    SETB  0                   2520 DUAL READ/PUNCH ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPRA2
R25200   EQU   X'C2'               INITIAL READ OPCODE FOR 2520 DUAL
R252001  EQU   X'49'               NORMAL PUNCH OPCODE FOR 2520 DUAL
R252002  EQU   X'02'               NORMAL READ OPCODE FOR 2520 DUAL
R252003  EQU   X'23'               STACKER SEL OPCODE FOR 2520 DUAL
RF25200  EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
         AGO   .SKPR5
.SKPRA2  ANOP
ROPCODE  EQU   X'22'               READ OPCODE FOR 2520 DUAL READ/PUNCH
RBUSY    EQU   X'20'               TEST FOR BUSY ON 2520 DUAL
RERROR   EQU   X'21'               TEST FOR ERROR ON 2520 DUAL
REOF     EQU   X'24'               TEST FOR END OF FILE ON 2520 DUAL
UEOF     EQU   X'24'               TEST FOR END OF FILE WHILE PUNCHING
UOPCODE  EQU   X'24'               PUNCH OPCODE FOR DUAL 2520
UBUSY    EQU   X'22'               TEST FOR BUSY ON 2520 DUAL
UERROR   EQU   X'23'               TEST FOR ERROR ON 2520 DUAL
UFEED    EQU   X'25'               TEST FOR FEED ERROR
         AGO   .SKPR5
.SKPR11  AIF   (&RDEV(&A) NE 14420).SKPR12
*        EQUATES FOR 1442 DUAL READ/PUNCH SUPPORT &R(3) SET TO 0
&R(3)    SETB  0                   1442 DUAL READ/PUNCH ON SYSTEM
R14420   EQU   X'02'              NORMAL READ OPCODE FOR 1442 DUAL
R144201  EQU   X'41'               NORMAL PUNCH OPCODE FOR 1442 DUAL
RF14420  EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
         AGO   .SKPR5
.SKPR12  AIF   (&RDEV(&A) NE 25600).SKPR5
*        EQUATES FOR 2560 DUAL READ/PUNCH SUPPORT &R(7) SET TO 0
&R(7)    SETB  0                   2560 DUAL READ/PUNCH ON SYSTEM
ROPCODE  EQU   X'22'               READ CARD ON 2560 (PRMARY FEED)
RBUSY    EQU   X'20'               TEST FOR BUSY ON 2560
RERROR   EQU   X'21'               TEST FOR ERROR ON 2560
REOF     EQU   X'24'               END OF FILE TEST ON 2560
RFEED    EQU   X'25'               TEST FOR FEED ERROR
RPOC     EQU   X'02'               POCKET FOR 2560 READ DUAL
RSTACK   EQU   X'20'               STACKER SELECT FOR 2560 INPUT
UOPCODE  EQU   X'27'               PUNCH OPCODE FOR 2560 DUAL
UPOC     EQU   X'03'               POCKET FOR 2560 DUAL PUNCH
USTACK   EQU   X'21'               STACKER SELECT FOR 2560 PUNCH
UBADPOC  EQU   X'04'               BAD CARD POCKET FOR 2560 PUNCH
UNSTACK  EQU   X'22'               PUNCH CARD STACKER SELECT FOR 2560
&NUMRDR  SETA  1
&NUMPUN  SETA  0
&D       SETA  0
         AGO   .LOOKWTO
.SKPR5   ANOP
&A       SETA  &A+1
         AIF   (&A GT 7).SETRDR
         AIF   (&RDEV(&A) EQ 0).SETRDR
.SKPR20  ANOP
&B       SETA  1
&S(&A)   SETA  0
.SKPR2   AIF   ('&RADR(&A)' EQ '&UADR(&B)').SKPR1
&B       SETA  &B+1
         AIF   (&B LE 7).SKPR2
.SKPR13  AIF   (&A EQ 1).RLOOP
&T       SETA  0
&B       SETA  1
.SKPR4   AIF   (&RDEV(&A) NE &RDEV(&B)).SKPR3
&T       SETA  1
.SKPR3   ANOP
&B       SETA  &B+1
         AIF   (&B LT &A).SKPR4
         AIF   (&T EQ 0).RLOOP
         AGO   .SKPR5
.SKPR1   ANOP
&RDEV(&A) SETA &RDEV(&A)*10
&UDEV(&B) SETA &UDEV(&B)*10
&D       SETA  &D+1
&S(&A)   SETA  &B
         AGO   .SKPR13
.SETRDR  ANOP
&NUMRDR  SETA  &A-1
&A       SETA  1
         AIF   (&UDEV(1) EQ 0).SETPUN
.ULOOP   AIF   (&UDEV(&A) NE 1442).SKPU4
*        EQUATES FOR 1442 PUNCH SUPPORT &R(8) SET TO 0
&R(8)    SETB  0                   SINGLE POCKET 1442 ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPU5
U14421   EQU   X'81'               PUNCH OPCODE FOR 1442 NON DUAL
U1442    EQU   X'81'               PUNCH OPCODE FOR 1442 NON DUAL
UF1442   EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
         AGO   .SKPU3
.SKPU5   ANOP
UOPCODE  EQU   X'36'               PUNCH OPCODE ON 1442
UBUSY    EQU   X'32'               TEST PUNCH BUSY ON 1442
UERROR   EQU   X'33'               TEST FOR ERROR ON 1442
         AGO   .SKPU3
.SKPU4   AIF   (&UDEV(&A) NE 2520).SKPU6
*        EQUATES FOR 2520 PUNCH SUPPORT &R(5) SET TO 0
&R(5)    SETB  0                   NON DUAL PUNCH DEVICE ON SYSTEM
         AIF   (&MACHINE EQ 20).SKPU7
U2520    EQU   X'41'               PUNCH OPCODE FOR 2520 NON DUAL
U25201   EQU   X'41'               PUNCH OPCODE FOR 2520 NON DUAL
UF2520   EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
         AGO   .SKPU3
.SKPU7   ANOP
UOPCODE  EQU   X'26'               PUNCH OPCODE FOR 2520
UBUSY    EQU   X'22'               TEST PUNCH BUSY ON 2520
UERROR   EQU   X'23'               TEST PUNCH ERROR ON 2520
UFEED    EQU   X'25'               TEST FOR FEED ERROR
         AGO   .SKPU3
.SKPU6   AIF   (&UDEV(&A) NE 2540).SKPU8
*        EQUATES FOR 2540 PUNCH SUPPORT &R(4) SET TO 0
&R(4)    SETB  0                   2540 PUNCH ON SYSTEM
U2540    EQU   X'41'               PUNCH OPCODE FOR 2540
U25401   EQU   X'41'               PUNCH OPCODE FOR 2540
UF2540   EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
         AGO   .SKPU3
.SKPU8   AIF   (&UDEV(&A) NE 2560).SKPU3
*        EQUATES FOR 2560 PUNCH SUPPORT &R(5) SET TO 0
&R(5)    SETB  0                   NON DUAL PUNCH DEVICE ON SYSTEM
UOPCODE  EQU   X'27'               PUNCH OPCODE FOR 2560 (SECONDARY)
UBUSY    EQU   X'20'               TEST FOR BUSY ON 2560
UERROR   EQU   X'21'               TEST FOR ERROR ON 2560
UFEED    EQU   X'25'               TEST FOR FEED ERROR
UPOC     EQU   X'03'               POCKET FOR 2560 PUNCH
USTACK   EQU   X'21'               STACK OPCODE FOR 2560
UBADPOC  EQU   X'04'               BAD CARD POCKET FOR 2560 PUNCH
UNSTACK  EQU   X'22'               PUNCH CARD STACKER SELECT FOR 2560
.SKPU3   ANOP
&A       SETA  &A+1
         AIF   (&A GT 7).SETPUN
         AIF   (&UDEV(&A) EQ 0).SETPUN
&T       SETA  0
&B       SETA  1
.SKPU2   AIF   (&UDEV(&A) NE &UDEV(&B)).SKPU1
&T       SETA  1
.SKPU1   ANOP
&B       SETA  &B+1
         AIF   (&B LT &A).SKPU2
         AIF   (&T EQ 0).ULOOP
         AGO   .SKPU3
.SETPUN  ANOP
&NUMPUN  SETA  &A-1
.LOOKWTO ANOP
         AIF   (&WDEV(1) EQ 0).SKPSETW
*        EQUATES FOR OPERATOR CONSOLE SUPPORT
WSIZE    EQU   &WTOSIZE            LENGTH OF CONSOLE PRINT LINE
         AIF   (&MACHINE EQ 20).SKP1
W1052    EQU   X'09'               WRITE OPCODE FOR CONSOLE
W10521   EQU   X'09'               WRITE OPCODE FOR CONSOLE
W10522   EQU   X'0A'               READ OPCODE FOR CONSOLE
WF1052   EQU   X'20'               FLAGS FOR CCW SUPPRESS WRONG LENGTH
WREAD    EQU   X'0A'               READ FROM KEYBOARD
         AGO   .SETWTO
.SKP1    ANOP
*        &LOCCOM SET TO 1 *LOCAL COMMAND SUPPORT IS REQUIRED*
&LOCCOM  SETA  1
WREAD    EQU   X'E1'               READ OPCODE FOR CONSOLE
WREQ     EQU   X'E3'               TEST FOR INQUIRY REQUEST
WENABLE  EQU   X'E2'               ENABLE OPCODE FOR INQUIRY REQUESTS
WOPCODE  EQU   X'E3'               WRITE OPCODE FOR CONSOLE
WBUSY    EQU   X'E0'               TEST FOR BUSY ON CONSOLE
WERROR   EQU   X'E2'               TEST ANY CHECK ON CONSOLE
.SETWTO  ANOP
&CONSOLE SETA  1
.SKPSETW MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS*  DEFTCT'
*
*        DEFTCT                    DEFINE TCT SYMBOLS FOR
*                                  DSECT AND ABS ADDRS
         MACRO
         DEFTCT &PRE
         GBLA  &LOCCOM,&CONSOLE
         GBLA  &MACHINE,&CCT,&A,&UDEV(7)
         GBLB  &R(10)              CONFIGURATION SCOREBOARD
         LCLC  &SIZ
&SIZ     SETC  '&PRE'
         AIF   ('&PRE' NE 'U').TCTUDF
&SIZ     SETC  'R'
.TCTUDF  ANOP
&PRE.TCT DS    0H
         AIF   (&MACHINE EQ 20).TCTSKP1
&PRE.CTSTRT DS CL2                 B TO PROPER PROCESSOR ENTRY
&PRE.CTENTY DS CL2                 ADR PORTION ***MODIFIED BY PROCESSOR
&PRE.CTRTN DS  CL4                 B TO NEXT PROCESSOR VIA COMMUTATOR
&PRE.CTCCW DS  CL1                 CCW FOR DEVICE OP-CODE
&PRE.CTDATA DS AL3                 ADDRESS OF DATA TRANSFERRED
&PRE.CTFLAG DS CL1                 FLAGS ON CCW
&PRE.CTOPCOD DS CL1                 SAVE AREA FOR CCW OP-CODE
&PRE.CTCCWCT DS AL2                 CCW COUNT OF DATA TRANSFERRED
         AIF   ('&PRE' NE 'P').TCT01
&PRE.CTSENSE DS AL1                 SENSE INFO FOR ERROR RECOVERY
&PRE.CTINDEX DS AL1                 FCB INDEX INFORMATION BYTE
         AGO   .TCT02
.TCT01   ANOP
&PRE.CTSENSE DS AL2                 SENSE INFO FOR ERROR RECOVERY
.TCT02   ANOP
&PRE.CTUCB DS  AL2                 DEVICE ADDRESS
&PRE.CTECB DS  CL1                 EVENT CONTROL
&PRE.CTALTOP DS CL1                 PUNCH OP-CODE FOR READER/PUNCH
&PRE.CTSAV1 $ACONS ,                   SAVE AREA FOR PROCESSOR ROUTINES
.TCTSKP1 ANOP
&PRE.CTNEXT $ACONS ,                   NEXT TCT IN CHAIN
&PRE.CTFCS DS  AL2                 FUNCTION CONTROL SEQUENCE MASK
&PRE.CTRCB DS  CL1                 RECORD CONTROL BLOCK MASK
&PRE.CTSTAT DS CL1                 STATUS FLAGS
&PRE.CTCOM $ACONS ,                   POINTER BACK TO COMMUTATOR
         AIF   (&LOCCOM EQ 0).TCT4
&PRE.CTID DS   CL2                 ID OF DEVICE
.TCT4    ANOP
         AIF   (NOT(&R(2) AND &R(3) AND &R(7))).TCT1
&PRE.CTINRCB EQU &PRE.CTRCB              READER RCB IDENTIFICATION
.TCT1    AIF   (&R(2) AND &R(3) AND &R(7)).TCT2
&PRE.CTINRCB DS CL1                 READER RCB IDENTIFICATION
.TCT2    ANOP
         AIF   ('&PRE' EQ 'R' AND &R(2) AND &R(3) AND &R(7)).TCTSKP3
*
*        NORMAL DEVICE EXTENTION
*
&PRE.CTTANK $ACONS ,                    NEXT TANK TO OUTPUT
&PRE.CTBUFER $ACONS ,                   ADDR OF CURRENT BUFFER
*
*              TNKLM,TNKCT AND BUFLM,BUFCT MUST APPEAR IN SEQ AND STRT
*                                  ON HALF WORD BOUNDARIES
&PRE.CTTNKLM DS CL1                 MAX NUM OF TANKS ASSIGNABLE TO DEV
&PRE.CTTNKCT DS CL1                 CURRENT NUM ASSIGNED
&PRE.CTBUFLM DS CL1                 MAX NUM OF BUFFERS ASSIGNABLE TO DV
&PRE.CTBUFCT DS CL1                 CURRENT NUM ASSIGNED
.TCTSKP3 AIF   ('&PRE' NE 'W' AND '&PRE' NE 'R' AND ('&PRE' NE 'U'     C
               OR &R(2) AND &R(3))).TCTSKP2
         AIF   ('&PRE' EQ 'W' AND &CONSOLE EQ 0).TCTSKP2
*
*        TANK EXTENTIONS FOR READER AND CONSOLE PROCESSORS
*
&PRE.CTTANK1 $ACONS ,                   TANKCHN AND WORK AREA ONE
&PRE.CTTRCB1 DS CL1                 RCB IDENTIFICATION
&PRE.CTTSRC1 DS CL1                 SRCB IDENTIFICATION
&PRE.CTTCT1 DS H                   NUMBER OF DATA CHARACTERS
&PRE.CTTDTA1 DS CL(&SIZ.SIZE+&CCT)
         AIF   ('&PRE' EQ 'W').TCTSKP2
&PRE.CTTANK2 $ACONS ,                   TANKCHN AND WORK AREA TWO
&PRE.CTTRCB2 DS CL1                 RCB IDENTIFICATION
&PRE.CTTSRC2 DS CL1                 SRCB IDENTIFICATION
&PRE.CTTCT2 DS H                   NUMBER OF DATA CHARACTERS
&PRE.CTTDTA2 DS CL(&SIZ.SIZE+&CCT)
.TCTSKP2 AIF   ('&PRE'  NE  'U'  OR &R(4)  AND ( NOT &R(6) OR &R(2)    C
               AND &R(3))).TCTSKP4
&PRE.CTHOLD $ACONS ,                 PTR TO TANK HELD FOR PUNCH ERRORS
.TCTSKP4 ANOP
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $GENCOM'
*
*        $GENCOM                   GENERATES ALL COMMUTATOR ENTRIES
*
         MACRO
&NAME    $GENCOM
         GBLA  &NUMRDR,&NUMPUN,&CONSOLE,&MACHINE,&NUMPRT,&PRTCONS
         GBLA  &UDEV(7)
         LCLA  &A
         LCLC  &ENT
&ENT     SETC  'COM'
         AIF   (&MACHINE NE 20).COMA
&ENT     SETC  'RTN'
.COMA    ANOP
&NAME    NULL
$CONTCOM NOP   $CONTROL            CONTROL RECORD PROCESSOR
$TPGETCM NOP   $TPGET              INPUT BUFFER MANAGER
&A       SETA  1
.C1      AIF   (&A GT &NUMPRT).C2
$PCOMM&A NOP   $P&ENT&A              ENTRY POINT TO PRINT
&A       SETA  &A+1
         AGO   .C1
.C2      ANOP
&A       SETA  1
.C3      AIF   (&A GT &NUMRDR).C4
$RCOMM&A B     $R&ENT&A              ENTRY POINT TO READ CARD
&A       SETA  &A+1
         AGO   .C3
.C4      ANOP
&A       SETA  1
.C5      AIF   (&A GT &NUMPUN).C6
         AIF   (&UDEV(&A) GT 9999).C8
$UCOMM&A NOP   $U&ENT&A              ENTRY TO PUNCH CARD
         AGO   .C9
.C8      AIF   (&MACHINE NE 20).C9
$UCOMM1  EQU   $RCOMM1
.C9      ANOP
&A       SETA  &A+1
         AGO   .C5
.C6      ANOP
         AIF   (&CONSOLE NE 1 AND &PRTCONS EQ 0).C7
$WCOMM1  NOP   $W&ENT.1              TYPE ON CONSOLE
.C7      ANOP
$COMCOM  NOP   $COMSUP             COMMUNICATIONS SUPERVISOR
         AIF   (&MACHINE NE 20).C10
         B     &NAME               LOOK FOR ADDITIONAL WORK
         MEXIT
.C10     ANOP
         SSM   *+1                 DISABLE
         MVC   COMWORK,COMTEST     GET GATE TEST MASK
         NC    COMWORK,&NAME       ARE ANY GATES OPEN
         BNZ   $START-4                                        @OZ40561
         LPSW  COMWAIT             OTHERWISE ENABLE AND WAIT
         SSM   COMWAIT             ENABLE                            R4
         B     &NAME               LOOP AGAIN                        R4
COMWORK  DS    XL($COMCOM-$START+4)                            @OZ40561
COMTEST  DC    (L'COMWORK/4)X'00F00000'  GATE TEST MASK
COMWAIT  DC    0D'0',X'FF020000',A(&NAME)  WAIT STATE PSW
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $GENTANK'
         SPACE 10
*
*****   $GENTANK   *****     GENERATE DECOMPRESSION TANKS
*
*
         MACRO
&NAME    $GENTANK
         GBLA  &NUMTANK,&TEMP,&CCT,&PRTSIZE
         LCLA  &TEMP1
&TEMP    SETA  1
.TANK    ANOP
&TEMP1   SETA  &TEMP+1
$TANK&TEMP $ACON $TANK&TEMP1
         DC    AL1(0) 
         DC    AL1(0) 
         DC    AL2(0) 
         DC    &PRTSIZE.C' ' 
         DC    (&CCT)C' ' 
&TEMP    SETA  &TEMP+1
         AIF   (&TEMP LE &NUMTANK).TANK
$TANK&TEMP1 EQU 0                      END CHAIN
&NAME    EQU   $TANK1              EXTERNAL NAME
         MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $GENTCT'
*
*        $GENTCT MACRO             GENERATE A TCT
*
         MACRO
&NAME    $GENTCT &PRE,&FCS,&RCB,&ADR,&DEV,&TLM,&BLM,&ACS,&ACB
         GBLA  &LOCCOM,&CONSOLE
         GBLA  &A,&B,&MACHINE,&T,&CCT,&D
         GBLB  &R(10)              CONFIGURATION SCOREBOARD
         AIF   ('&PRE' EQ 'U' AND '&DEV' GT '9999').TCT12
         AIF   (&MACHINE EQ 20).TCT1
         CNOP  6,8
$&PRE.COM&A BALR R7,0                ENTRY FROM COMMUTATOR TO PROCESSOR
.TCT1    ANOP
$TCT&B   DS    0H                  ORIGIN OF TOTAL CONTROL TABLE
         AIF   (&A NE 1).TCT2
*
*        SYMBOLIC DEFINITIONS USED BY PROCESSOR TO REFER TO TCT
*
         AIF   (&D LT 2).TCTORG
&PRE.CTDSECT DSECT
         DEFTCT &PRE
HASPRTP  CSECT
         AGO   .TCT2
.TCTORG  ANOP
         DEFTCT &PRE
         ORG   $TCT&B
.TCT2    ANOP
*
*        STORAGE ALLOCATION AND INITIAL VALUES FOR TCT
*
&B       SETA  &B+1
&NAME    DS    0H
         AIF   (&MACHINE EQ 20).TCT11
         B     $&PRE.RTN1              BASE REG IS SET GO TO PROCESSOR
         B     $&PRE.COMM&A.+4           ON RETURN GO TO COMMUTATOR
         DC    X'0',AL3(*-*),AL1(&PRE.F&DEV),AL1(&PRE&DEV),AL2(80)
         AIF   (&MACHINE EQ 20 OR '&PRE' NE 'P').TCT02
         DC    X'00'               SENSE INFORMATION
         AIF   (&DEV EQ 3203 OR &DEV EQ 5203).TCT01
         DC    X'01'               FCB INDEX BYTE ALLOWED
         AGO   .TCT03
.TCT01   ANOP
         DC    X'00'               FCB INDEX BYTE NOT ALLOWED
         AGO   .TCT03
.TCT02   ANOP
         DC    H'0'                SENSE INFORMATION
.TCT03   ANOP
         DC    X'&ADR' 
         DC    X'00' 
         DC    AL1(&PRE&DEV.1)
         $ACON ,                SAVE AREA
.TCT11   ANOP
         $ACON ($TCT&B)
         DC    AL2(&FCS)
         DC    AL1(&RCB)
         DC    AL1(TCT&DEV)
         $ACON ($&PRE.COMM&A)           COMMUTATOR ENTRY FOR THIS TCT
         AIF   (&LOCCOM EQ 0).TCT6
         DC    C'&PRE.&A' 
.TCT6    ANOP
         AIF   (&R(2) AND &R(3) AND &R(7)).TCT3
         DC    AL1(&ACB)
.TCT3    ANOP
         AIF   ('&PRE' EQ 'R' AND &R(2) AND &R(3) AND &R(7)).TCT4
*        NORMAL EXTENTION TO TOTAL CONTROL TABLE
         $ACON ,                TANK Q
         $ACON ,                BUFFER Q
         DC    AL1(&TLM)
         DC    X'00' 
         DC    AL1(&BLM)
         DC    X'00' 
.TCT4    AIF   ('&PRE' NE 'R' AND '&PRE' NE 'W').TCT5
         AIF   ('&PRE' EQ 'W' AND &CONSOLE EQ 0).TCT5
*        INPUT TANKS FOR READER AND CONSOLE
         $ACON ,
         DC    AL1(&ACB)
         DC    X'80' 
         DC    H'80' 
         DC    CL(&PRE.SIZE+&CCT)' '
         AIF   ('&PRE' NE 'R').TCT13
         $ACON ,
         DC    AL1(&ACB)
         DC    X'80' 
         DC    H'80' 
         DC    CL(&PRE.SIZE+&CCT)' '
.TCT5    AIF   (  NOT ('&PRE' EQ 'U' AND '&DEV' EQ '2540' OR  &R(6)    C
               AND  '&PRE' EQ  'R' AND ('&DEV' EQ '25200' OR '&DEV'    C
               EQ '14420'))).TCT13
         $ACON (1)                  HOLD TANK PTR
         MEXIT
.TCT12   AIF   (&A NE 1).TCT13
         AIF   (&D EQ 1).TCTOG
&PRE.CTDSECT DSECT
         DEFTCT U
HASPRTP CSECT
         AGO   .TCT13
.TCTOG   ANOP
         ORG   $TCT&T
         DEFTCT U
         ORG
.TCT13   MEND
 TITLE 'H A S P / R T P  *GLOBAL SYMBOL AND STORAGE MACROS* $LOGENT'
         SPACE 12
*
*****    $LOGENT *****             GENERATE A LOG TABLE ENTRY
*
*
         MACRO
&NAME    $LOGENT &ID=,&CLASS=,&TEXT=
         GBLA  &LOGID
&LOGID   SETA  &LOGID+1
&ID      EQU   &LOGID
&NAME    DS    0H
         DC    AL1(&ID)
         DC    AL1(&CLASS)
         DC    H'0'
         DC    CL(L'LOGTEXT)&TEXT
         MEND
         PRINT ON
         TITLE 'H A S P / R J E  * GLOBAL DEFINITIONS * '
         SPACE 10
         GBLA  &RMTID              REMOTE'S IDENTIFICATION
         GBLA  &TPBFSIZ            COMMUNICATIONS ADAPTER BUFFER SIZE
         GBLA  &MLBFSIZ            MULTI-LEAVING BUFFER SIZE
         GBLA  &NUMBUFS            NUMBER OF CA BUFFERS
         GBLA  &NUMTANK            NUMBER OF DECOMPRESSION TANKS
         GBLA  &MACHINE            TYPE OF MACHINE FOR THIS ASSEMBLY
         GBLA  &SUBMOD             SUB-MODEL NUMBER IF MODEL 20
         GBLA  &LINESPD            COMMUNICATION LINE SPEED
         GBLA  &DEBUG              DEBUG MODE SWITCH
         GBLA  &TRACE              TRACE MODE
         GBLA  &CORESIZ            MODEL 20 CORE SIZE
         GBLC  &XPARENT            TRANSPARENCY FEATURE INDICATOR
         GBLA  &ERRMSGN            MAX NUM ERROR MESSAGES QUEUED
         GBLA  &ERRTXTL            LENGTH OF TEXT FOR ERR MSG+1
         GBLA  &HICORE             MAXIMUM STORAGE ADDRESS IN HRTP
         GBLA  &HRTPORG            PROGRAM ORIGIN
         GBLA  &CMPTYPE            COMPRESSION TECHNIQUE UTILIZED
         GBLA  &CCT                IDENTICAL CHARACTER COMPRESSION CT
         GBLA  &REP                PATCH LOADER SWITCH
         GBLA  &TEMP               TEMPORARY SET SYMBOL
         GBLA  &TEMP2              2ND TEMP SET SYMBOL
         GBLA  &A,&B               TEMPORARY VARIABLES
         GBLA  &LOGCLAS
         GBLA  &LOGID              ERROR LOG ID ASSIGNMENT
         GBLA  &NUMPRT
         GBLA  &NUMRDR
         GBLA  &NUMPUN
         GBLA  &CONSOLE
         GBLA  &PRTSIZE            MAXIMUM LENGTH OF PRINT LINE
         GBLA  &WTOSIZE            LENGTH OF CONSOLE INPUT AREA
         GBLA  &PRTCONS            OPTION FOR PRINTING MESSAGES
         GBLA  &LOCCOM             LOCAL COMMAND OPTION
         GBLA  &HOME               INDICATOR FOR HOME LOOP TESTING
         GBLA  &CFCS               CONTROL RECORD FCS
         GBLA  &PFCS(7)            FUNCTION MASK DEFINITIONS
         GBLA  &RFCS(7)            FUNCTION MASK DEFINITIONS
         GBLA  &UFCS(7)            FUNCTION MASK DEFINITIONS
         GBLA  &WFCS(1)            FUNCTION DEFINITIONS
         GBLA  &CRCB               CONTROL RECORD CONTROL BYTE
         GBLA  &PRCB(7)            STREAM DEFINITIONS
         GBLA  &RRCB(7)            STREAM DEFINITIONS
         GBLA  &URCB(7)            STREAM DEFINITIONS
         GBLA  &WRCB(1)            STREAM DEFINITIONS
         GBLA  &CTLM               CONTROL RECORD TANK LIMITS
         GBLA  &PTLM(7)            NUM PRINTER TANK LIMITS
         GBLA  &UTLM(7)            NUM PUNCH TANK LIMITS
         GBLA  &WTLM(1)            CONSOLE TANK LIMITS OUTPUT ONLY
         GBLA  &CBLM               CONTROL RECORD BUFFER LIMITS
         GBLA  &PBLM(7)            NUM PRINTER BUFFER LIMITS
         GBLA  &UBLM(7)            NUM PUNCH BUFFER LIMITS
         GBLA  &WBLM(1)            NUM CONSOLE LIMITS
         GBLA  &PDEV(7)            DEVICE TYPE FOR PRINTERS
         GBLA  &RDEV(7)            DEVICE TYPE FOR READERS
         GBLA  &UDEV(7)            DEVICE TYPE FOR PUNCHES
         GBLA  &WDEV(1)            DEVICE TYPE FOR CONSOLE
         GBLA  &OFCS(1)            OPERATOR COMMAND FCS
         GBLA  &ORCB(1)            OPERATOR COMMAND RCB
         GBLA  &D                  NUMBER OF DUAL READ/PUNCH DEVICES
         GBLA  &S(7)               READ/PUNCH CROSS REFERENCE
         GBLA  &T                  CONFIGURATION WORK VARIABLE
         GBLA  &L                  LENGTH ATTRIBUTE OF ADDR CONSTANTS
         GBLB  &R(10)              CONFIGURATION SCOREBOARD
         GBLC  &PADR(7)            DEVICE ADDRESSES OF PRINTERS
         GBLC  &RADR(7)            DEVICE ADDRESSES OF READERS
         GBLC  &UADR(7)            DEVICE ADDRESSES OF PUNCHES
         GBLC  &WADR(1)            DEVICE ADDRESSES OF CONSOLE
         GBLC  &ADAPT              COMMUNICATIONS ADAPTER
         GBLC  &NUM
         GBLC  &GEN
         ACTR  500
         TITLE 'H A S P / R J E  *HASPGEN VARIABLES*  '
         SPACE 5
*
*                   CONFIGURATION VARIABLES
*
&RMTID   SETA  1                   REMOTE'S IDENTIFICATION
&MACHINE SETA  20                  MODEL OF REMOTE TERMINAL CPU
&SUBMOD  SETA  2                   SUB-MODEL 2 (MODEL 20)
&LINESPD SETA  2000                COMMUNICATION LINE SPEED
&CORESIZ SETA  8                   AMOUNT OF CORE AVAILABLE TO PROGRAM
&XPARENT SETC  'YES'               ADAPTER TRANSPARENCY FEATURE
&HICORE  SETA  &CORESIZ            HIGHEST CORE LOCATION AVAILABLE
&HRTPORG SETA  X'80'               ORIGIN OF PROGRAM
&ERRMSGN SETA  10                  MAX NUM ERROR MSG QUEUED
&ERRTXTL SETA  13                  LENGTH OF TEXT + BLANK
*
*        CONFIGURATION
*
&PDEV(1) SETA  2203                PRINTER 1 MACHINE NUMBER
&PDEV(2) SETA  0                   PRINTER 2 MACHINE NUMBER
&PDEV(3) SETA  0                   PRINTER 3 MACHINE NUMBER
&PDEV(4) SETA  0                   PRINTER 4 MACHINE NUMBER
&PDEV(5) SETA  0                   PRINTER 5 MACHINE NUMBER
&PDEV(6) SETA  0                   PRINTER 6 MACHINE NUMBER
&PDEV(7) SETA  0                   PRINTER 7 MACHINE NUMBER
&PADR(1) SETC  '4'                 PRINTER 1 ADDRESS
&PADR(2) SETC  '00F'               PRINTER 2 ADDRESS
&PADR(3) SETC  'FFF'               PRINTER 3 ADDRESS
&PADR(4) SETC  'FFF'               PRINTER 4 ADDRESS
&PADR(5) SETC  'FFF'               PRINTER 5 ADDRESS
&PADR(6) SETC  'FFF'               PRINTER 6 ADDRESS
&PADR(7) SETC  'FFF'               PRINTER 7 ADDRESS
&RDEV(1) SETA  2501                READER 1 MACHINE NUMBER
&RDEV(2) SETA  0                   READER 2 MACHINE NUMBER
&RDEV(3) SETA  0                   READER 3 MACHINE NUMBER
&RDEV(4) SETA  0                   READER 4 MACHINE NUMBER
&RDEV(5) SETA  0                   READER 5 MACHINE NUMBER
&RDEV(6) SETA  0                   READER 6 MACHINE NUMBER
&RDEV(7) SETA  0                   READER 7 MACHINE NUMBER
&RADR(1) SETC  '1'                 READER 1 ADDRESS
&RADR(2) SETC  'FFF'               READER 2 ADDRESS
&RADR(3) SETC  'FFF'               READER 3 ADDRESS
&RADR(4) SETC  'FFF'               READER 4 ADDRESS
&RADR(5) SETC  'FFF'               READER 5 ADDRESS
&RADR(6) SETC  'FFF'               READER 6 ADDRESS
&RADR(7) SETC  'FFF'               READER 7 ADDRESS
&UDEV(1) SETA  1442                PUNCH 1 MACHINE NUMBER
&UDEV(2) SETA  0                   PUNCH 2 MACHINE NUMBER
&UDEV(3) SETA  0                   PUNCH 3 MACHINE NUMBER
&UDEV(4) SETA  0                   PUNCH 4 MACHINE NUMBER
&UDEV(5) SETA  0                   PUNCH 5 MACHINE NUMBER
&UDEV(6) SETA  0                   PUNCH 6 MACHINE NUMBER
&UDEV(7) SETA  0                   PUNCH 7 MACHINE NUMBER
&UADR(1) SETC  '3'                 PUNCH 1 ADDRESS
&UADR(2) SETC  'FFF'               PUNCH 2 ADDRESS
&UADR(3) SETC  'FFF'               PUNCH 3 ADDRESS
&UADR(4) SETC  'FFF'               PUNCH 4 ADDRESS
&UADR(5) SETC  'FFF'               PUNCH 5 ADDRESS
&UADR(6) SETC  'FFF'               PUNCH 6 ADDRESS
&UADR(7) SETC  'FFF'               PUNCH 7 ADDRESS
&WDEV(1) SETA  0                   CONSOLE MACHINE NUMBER
&WADR(1) SETC  '01F'               CONSOLE ADDRESS
&ADAPT   SETC  '020'               ADDRESS OF COMMUNICATIONS ADAPTER
         AIF   (&HICORE GT 32).HISKP1
&L       SETA  2                   LENGTH ATTRIBUTE OF ACONS
         AGO   .HISKP
.HISKP1  ANOP
&L       SETA  4                   LENGTH ATTRIBUTE OF ACONS
.HISKP   ANOP
&R(1)    SETB  1                   NO NON DUAL READER
&R(2)    SETB  1                   NO DUAL 2520
&R(3)    SETB  1                   NO DUAL 1442
&R(4)    SETB  1                   NO 2540 PUNCH
&R(5)    SETB  1                   NO NON DUAL PUNCH
&R(6)    SETB  1                   NOT MOD 20
&R(7)    SETB  1                   NO DUAL 2560
&R(8)    SETB  1                   NO SINGLE POCKET 1442
&PRTSIZE SETA  132                 MAXIMUM PRINT LINE SIZE
&WTOSIZE SETA  120                 LENGTH OF CONSOLE INPUT AREA
*
*                   INTERNAL VARIABLES
*
&NUMBUFS SETA  8                   NUMBER OF TP BUFFERS
&TPBFSIZ SETA  400                 DEFAULT BUFFER SIZE
&MLBFSIZ SETA  400                 MULTI-LEAVING BUFFER SIZE
&TPBFSIZ SETA  &MLBFSIZ            TRANSMISSION BUFFER SIZE
&TPBFSIZ SETA  &TPBFSIZ+&TPBFSIZ-&TPBFSIZ/2*2    FORCE BUFSIZE EVEN
&NUMTANK SETA  5                   NUMBER OF DECOMPRESSION TANKS
&CMPTYPE SETA  2                   COMPRESSION TECHNIQUE INDICATOR
*                                  (0 = NO COMPRESSION )
*                                  (1 = TRAILING BLANK ELIMINATION )
*                                  (2 = BLANK COMPRESSION ONLY )
*                                  (3 = COMPRESS ALL IDENTICAL CHARS )
&CCT     SETA  4                   MINIMUM EQUAL CHARACTERS TO COMPRESS
&LOGCLAS SETA  0                   LOWEST ERROR SEVERITY TO LOG
&GEN     SETC  'GEN'
&PRTCONS SETA  0                   PRINT CONSOLE MESSAGES OPTION
&LOCCOM  SETA  0                   LOCAL COMMAND OPTION
&HOME    SETA  0                   HOME LOOP OFF
*
*        FUNCTION CONTROL MASKS FOR TCTS
*
&CFCS    SETA  X'0000'             CONTROL RECORD PROCESSOR
&PFCS(1) SETA  X'0800'             PRINTER 1
&PFCS(2) SETA  X'0400'             PRINTER 2
&PFCS(3) SETA  X'0200'             PRINTER 3
&PFCS(4) SETA  X'0100'             PRINTER 4
&PFCS(5) SETA  X'0008'             PRINTER 5
&PFCS(6) SETA  X'0004'             PRINTER 6
&PFCS(7) SETA  X'0002'             PRINTER 7
&UFCS(1) SETA  X'0001'             PUNCH 1
&UFCS(2) SETA  X'0002'             PUNCH 2
&UFCS(3) SETA  X'0004'             PUNCH 3
&UFCS(4) SETA  X'0008'             PUNCH 4
&UFCS(5) SETA  X'0100'             PUNCH 5
&UFCS(6) SETA  X'0200'             PUNCH 6
&UFCS(7) SETA  X'0400'             PUNCH 7
&WFCS(1) SETA  X'0040'             CONSOLE
&OFCS(1) SETA  X'0000'             OPERATOR COMMAND FCS
&RFCS(1) SETA  X'0800'             READER FUNCTION 1
&RFCS(2) SETA  X'0400'             READER FUNCTION 2
&RFCS(3) SETA  X'0200'             READER FUNCTION 3
&RFCS(4) SETA  X'0100'             READER FUNCTION 4
&RFCS(5) SETA  X'0008'             READER FUNCTION 5
&RFCS(6) SETA  X'0004'             READER FUNCTION 6
&RFCS(7) SETA  X'0002'             READER FUNCTION 7
*        RECORD CONTROL BYTES
*
&CRCB    SETA  X'80'               CONTROL RECORD CONTROL BYTE
&PRCB(1) SETA  X'94'               STREAM 1 PRINT RECORDS
&PRCB(2) SETA  X'A4'               STREAM 2 PRINT RECORDS
&PRCB(3) SETA  X'B4'               STREAM 3 PRINT RECORDS
&PRCB(4) SETA  X'C4'               STREAM 4 PRINT RECORDS
&PRCB(5) SETA  X'D4'               STREAM 5 PRINT RECORDS
&PRCB(6) SETA  X'E4'               STREAM 6 PRINT RECORDS
&PRCB(7) SETA  X'F4'               STREAM 7 PRINT RECORDS
&URCB(1) SETA  X'95'               STREAM 1 PUNCH RECORDS
&URCB(2) SETA  X'A5'               STREAM 2 PUNCH RECORDS
&URCB(3) SETA  X'B5'               STREAM 3 PUNCH RECORDS
&URCB(4) SETA  X'D5'               STREAM 3 PUNCH RECORDS
&URCB(4) SETA  X'C5'               STREAM 4 PUNCH RECORDS
&URCB(5) SETA  X'D5'               STREAM 5 PUNCH RECORDS
&URCB(6) SETA  X'E5'               STREAM 6 PUNCH RECORDS
&URCB(7) SETA  X'F5'               STREAM 7 PUNCH RECORDS
&WRCB(1) SETA  X'91'               MESSAGE TO TERM OPERATOR
&ORCB(1) SETA  X'92'               OPERATOR COMMAND RCB
&RRCB(1) SETA  X'93'               STREAM 1 TO HASP
&RRCB(2) SETA  X'A3'               STREAM 2 TO HASP
&RRCB(3) SETA  X'B3'               STREAM 3 TO HASP
&RRCB(4) SETA  X'C3'               STREAM 4 TO HASP
&RRCB(5) SETA  X'D3'               STREAM 5 TO HASP
&RRCB(6) SETA  X'E3'               STREAM 6 TO HASP
&RRCB(7) SETA  X'F3'               STREAM 7 TO HASP
*
*        THE FOLLOWING VALUES REPRESENT THE LIMIT OF QUEUING
*        FOR EACH INDICATED DEVICE.
*        THE 'BL' VALUES REPRESENT THE MAXIMUM NUMBER OF BUFFERS
*        FROM HASP WHICH WILL BE QUEUED ON THE DEVICE.
*        THE 'TL' VALUES REPRESENT THE NUMBER OF DECOMPRESSED
*        RECORDS WHICH WILL BE QUEUED.NOTE THAT SINCE ONE
*        DECOMPRESSED RECORD WILL ALWAYS BE IN PROCESS,THE DEVICE
*        WILL REQUIRE ONE TANK MORE THAN THE TANK LIMIT(A 2540
*        PUNCH REQUIRES 2 MORE FOR ERROR RECOVERY PURPOSES).
*
         SPACE 3
*
*        DECOMPRESSION TANK LIMITS
*
*              PRINTERS
&PTLM(1) SETA  1                   PRINTER 1-DECOMPRESSION LIMIT
&PTLM(2) SETA  &PTLM(1)            PRINTER 2-DECOMPRESSION LIMIT
&PTLM(3) SETA  &PTLM(1)            PRINTER 3-DECOMPRESSION LIMIT
&PTLM(4) SETA  &PTLM(1)            PRINTER 4-DECOMPRESSION LIMIT
&PTLM(5) SETA  &PTLM(1)            PRINTER 5-DECOMPRESSION LIMIT
&PTLM(6) SETA  &PTLM(1)            PRINTER 6-DECOMPRESSION LIMIT
&PTLM(7) SETA  &PTLM(1)            PRINTER 7-DECOMPRESSION LIMIT
*              PUNCHES
&UTLM(1) SETA  1                   PUNCH 1 - DECOMPRESSION LIMIT
&UTLM(2) SETA  &UTLM(1)            PUNCH 2 - DECOMPRESSION LIMIT
&UTLM(3) SETA  &UTLM(1)            PUNCH 3 - DECOMPRESSION LIMIT
&UTLM(4) SETA  &UTLM(1)            PUNCH 4 - DECOMPRESSION LIMIT
&UTLM(5) SETA  &UTLM(1)            PUNCH 5 - DECOMPRESSION LIMIT
&UTLM(6) SETA  &UTLM(1)            PUNCH 6 - DECOMPRESSION LIMIT
&UTLM(7) SETA  &UTLM(1)            PUNCH 7 - DECOMPRESSION LIMIT
*              CONSOLE
&WTLM(1) SETA  &NUMTANK-2          CONSOLE DECOMPRESSION LIMIT
*              CONTROL RECORD PROCESSOR
&CTLM    SETA  &NUMTANK            CONTROL DECOMPRESSION LIMIT
*
*        BUFFER QUEUING LIMITS
*
*              PRINTERS
&PBLM(1) SETA  2                   PRINTER 1-BUFFER QUEUING LIMIT
&PBLM(2) SETA  &PBLM(1)            PRINTER 2-BUFFER QUEUING LIMIT
&PBLM(3) SETA  &PBLM(1)            PRINTER 3-BUFFER QUEUING LIMIT
&PBLM(4) SETA  &PBLM(1)            PRINTER 4-BUFFER QUEUING LIMIT
&PBLM(5) SETA  &PBLM(1)            PRINTER 5-BUFFER QUEUING LIMIT
&PBLM(6) SETA  &PBLM(1)            PRINTER 6-BUFFER QUEUING LIMIT
&PBLM(7) SETA  &PBLM(1)            PRINTER 7-BUFFER QUEUING LIMIT
*              PUNCHES
&UBLM(1) SETA  2                   PUNCH 1 - BUFFER QUEUING LIMIT
&UBLM(2) SETA  &UBLM(1)            PUNCH 2 - BUFFER QUEUING LIMIT
&UBLM(3) SETA  &UBLM(1)            PUNCH 3 - BUFFER QUEUING LIMIT
&UBLM(4) SETA  &UBLM(1)            PUNCH 4 - BUFFER QUEUING LIMIT
&UBLM(5) SETA  &UBLM(1)            PUNCH 5 - BUFFER QUEUING LIMIT
&UBLM(6) SETA  &UBLM(1)            PUNCH 6 - BUFFER QUEUING LIMIT
&UBLM(7) SETA  &UBLM(1)            PUNCH 7 - BUFFER QUEUING LIMIT
*              CONSOLE
&WBLM(1) SETA  3                   CONSOLE BUFFER QUEUING LIMIT
*              CONTROL RECORD PROCESSOR
&CBLM    SETA  &NUMBUFS            CONTROL BUFFER QUEUING LIMIT
         PRINT &GEN
 TITLE ' L O A D E R  --  PUNCHES M/20 OR NON 20 LOADER DECKS'
         SPACE 20
         AIF   (&MACHINE EQ 20).LOAD20
         PUNCH '
         AGO   .SKIP
.LOAD20  ANOP
         PUNCH '}+
               K{
.SKIP    ANOP
 TITLE 'G L O B A L   S Y M B O L   D E F I N I T I O N S'
         SPACE 3
HASPRTP  START 0
*
*                   DEBUGGING VARIABLES
*
&DEBUG   SETA  1
&TRACE   SETA  0                   NO TRACE DEGRADATION
&REP     SETA  1                   PATCH MODE ON
*
*        CONFIGURATION DEPENDENT EQUATES
*
         $CONFIG
&A       SETA  1
*
*        SYMBOLIC DEFINITIONS USED TO REFER TO TCT LOCATIONS
*        ** SEE GLOBAL STORAGE FOR UNIQUE PROCESSORS EQUIVALENT DEFS
*
TCTDSECT DSECT
         DEFTCT T                  DEFINE TCT SYMBOLS
*
*        TCTSTAT BIT DEFINITIONS
*
TCT1403  EQU   X'08'               TCT STATUS FLAGS FOR 1403, SW ON
TCT1443  EQU   X'08'               TCT STATUS FLAGS FOR 1443, SW ON
TCT2203  EQU   X'08'               TCT STATUS FLAGS FOR 2203, SW ON
TCT3211  EQU   X'08'               TCT STATUS FLAGS FOR 3211, SW ON
TCT3203  EQU   X'08'               TCT STATUS FLAGS FOR 3203, SW ON
TCT5203  EQU   X'08'               TCT STATUS FLAGS FOR 5203, SW ON
TCT2501  EQU   X'00'               TCT STATUS FLAGS FOR 2501
TCT2520  EQU   X'00'               TCT STATUS FLAGS FOR 2520
TCT25200 EQU   X'01'               TCT STATUS FLAGS FOR 2520 DUAL
TCT1442  EQU   X'08'               TCT STATUS FLAGS FOR 1442
TCT14420 EQU   X'02'               TCT STATUS FLAGS FOR 1442 DUAL
TCT2540  EQU   X'04'               TCT STATUS FLAGS FOR 2540
TCT25600 EQU   X'02'               TCT STATUS FLAGS FOR 2560 DUAL
TCT2560  EQU   X'00'               TCT STATUS FLAGS FOR 2560
TCT1052  EQU   X'10'               TCT STATUS FLAGS FOR 1052
TCT2152  EQU   X'10'               TCT STATUS FLAGS FOR 2152
TCTREL   EQU   X'04'               INTERLOCK RELEASE REQ FOR CONSOLE
TCTDUAL  EQU   TCT14420+TCT25200   EITHER DUAL DEVICE
TCTOPEN  EQU   X'80'               TCT OPEN BIT
TCTACT   EQU   X'40'               ACTION REQUIRED ON THIS TCT
TCTREQ   EQU   X'08'               CONSOLE REQUEST BIT
TCTPRTSW EQU   X'08'               PRINTER AVAILABLE FOR CONSOLE
TCTSTOP  EQU   X'20'               TCT IS IN STOPPED STATE
*                                  .S COMMAND REQUIRED TO START UP
*        TCTUCB BIT DEFINITIONS
         SPACE 2
TCTNOINT EQU   X'80'               NO INTERRUPTS ON DEVICE ALLOWED
         SPACE 2
*        DUMMY TCT DEVICE DEFINITIONS FOR CTLTCT
         SPACE 2
C0       EQU   X'00'               DUMMY OPCODE FOR CONTROL
C01      EQU   X'00'               DUMMY OPCODE FOR CONTROL
CF0      EQU   X'00'               DUMMY FLAGS FOR CCW
TCT0     EQU   0                   DUMMY DEVICE STATUS
         SPACE 2
***      TCTECB BIT DEFINITIONS
         SPACE 2
TCTBUSY  EQU   X'10'               DEVICE BUSY BIT
         SPACE 2
***      TCTSENSE BIT DEFINITIONS (FIRST BYTE)
         SPACE 1
TCTINREQ EQU   X'40'               INTERVENTION REQUIRED BIT
         SPACE 1
***      TCTINDEX BIT DEFINITIONS
         SPACE 1
INDEXOK  EQU   X'01'               FCB INDEX BYTE ALLOWED
         SPACE 2
 TITLE '                                   COMMUNICATIONS BUFFER DSECT'
         SPACE 20
BUFDSECT DSECT                     TRANSMISSION BUFFER DSECT
BUFBEGIN DS    0F                  BEGINNING OF THE BUFFER
BUFCHAIN $ACON 0                   BUFFER CHAIN FIELD
BUFCOUNT DS    H                   COUNT OF BYTES TO TRANSMIT
BUFSTAT  DS    C                   BUFFER STATUS BYTE
BUFSTART DS    CL2                 TRANSMISSION CONTROL BYTES
BUFBCB   DS    C                   BLOCK CONTROL BYTE
BUFFCS   DS    CL2                 FUNCTION CONTROL SEQUENCE
BUFDATA  DS    (&TPBFSIZ-5)C       DATA PORTION OF TP BUFFER
BUFEND   DS    0F                  FULL ALIGNMENT FOR THE NEXT
         SPACE  8
*
*              BUFFER STATUS BIT DEFINITIONS
*
         SPACE 2
BUFFAKE  EQU   X'01'               DUMMY BUFFER INDICATOR
BUFRESP  EQU   X'02'               RESPONSE ONLY IN BUFFER
BUFNAK   EQU   X'04'               NAK RESPONSE BEING SENT
BUFTEXT  EQU   X'08'               BUFFER CONTAINS TEXT INFORMATION
BUFUCHEK EQU   X'10'               UNIT CHECK EXPECTED
 TITLE '                                   DECOMPRESSION TANK DSECT'
         SPACE 20
TANKDSEC DSECT                     UNIT RECORD TANK DSECT
TANKCHN  $ACON ,                   TANK CHAIN FIELD
TANKRCB  DS    C                   TANK RECORD CONTROL BYTE
TANKSRCB DS    C                   TANK SUB-RECORD CONTROL BYTE
TANKCNT  DS    H                   COUNT OF DATA BYTES IN TANK
TANKDATA DS    CL&PRTSIZE          DATA AREA IN THE TANK
         SPACE 20
 TITLE '                                 LOG TABLE DSECT'
         SPACE 20
LOGDSECT DSECT                     LOG DESECT
LOGID    DS    C                   LOG IDENTIFICATION
LOGCLASS DS    C                   SEVERITY  CODE OF MESSAGE
LOGCOUNT DS    H                   COUNT OF TOTAL ERRORS
LOGTEXT  DS    CL(&ERRTXTL-1)      TEXT OF MESSAGE
LOGEND   DS    0C                  END OF DSECT
 TITLE ' H A S P / R J E  *ORIGIN AND LOAD CONTROL*'
         SPACE 5
HASPRTP  CSECT
         AIF   (&MACHINE EQ 20).ORG20
*        THE FOLLOWING CODE GENERATES THE 360 MODE LOADER FOR RTP.
*        THE CODE IS VERY LOCATION SENSITIVE AND SHOULD BE MODIFIED
*        ONLY WITH GREAT CARE....
         DC    X'02000008A0000010' CCW TO SKIP 16 COLS OF CARD
         DC    X'0200005060000038' LOAD TEXT OF FIRST CARD
         DC    X'02000008B0000010' SKIP 16 COLS OF NEXT
         DC    X'0200008820000038' LOAD TEXT OF SECOND CARD
         SR    R15,R15             INITIALIZE
         BALR  R14,0               LOOP RETURN ADDR
         LA    R15,1024(R15)       UP ONE K
         OI    0(R15),0            TEST END OF CORE
         BR    R14                 CONTINUE IF NOT
         NOPR  R0                  SPACER
         DC    A(X'18')            CAW
         DC    AL4(56)             CARD TEXT COUNT
         DC    X'FFFFFFFF'         JUST IN TIME
         SH    R15,X'4E'           BACK UP TEXT LENGTH WORTH
         ST    R15,X'20'           SET TEXT READ ADDR
         MVI   X'24',X'20'         AND KILL CHAINING
         LH    R1,2                LOAD UNIT ADDR
         B     X'AC'               AND CONTINUE
         DC    X'0000000000000054' PI NEW
         BALR  R14,0               READ ADDRESS(ABILITY)
         USING *,R14               *
         SIO   0(R1)               READ A CARD
         BCR   7,R14               LOOP UNTIL ACCEPTED
         TIO   0(R1)               TEST COMPLETE
         BC    3,*-4               LOOP IF NOT
         CH    R3,68               TEST FOR ERROR
         BNE   *                   LOOP IF READER ERROR
         L     R13,12              GET ADDR FROM CARD
         CLI   10,C'N'             IS THIS AN END CARD
         BCR   8,R13               BR TO PROGRAM IF YES
         CLI   9,C'T'              IS THIS TEXT CARD
         BCR   7,R14               IGNORE IF NO
         IC    R2,19               GET TEXT COUNT
         BCTR  R2,0                ADJUST
         STC   R2,*+5              AND SET IN MVC
         MVC   0(*-*,R13),0(R15)   LOAD TEXT
         BR    R14                 AND CONTINUE
         DROP  R14
         NOPR  R0                  SPACER
         MVC   X'54'(X'AC'-X'70'),X'70' MOVE PROGRAM
         LA    R3,2048             ERROR TEST CODE
         B     X'54'               START LOADING
.ORG20   ANOP
         ORG   HASPRTP             TO BEGINNING OF CSECT
         DS    (&HRTPORG)C         PROGRAM ORIGIN
 TITLE 'H A S P / R J E  *SYMBOLIC REGISTER DEFINITIONS* '
HASPRJE  EQU   *
         AIF   (&MACHINE EQ 20).EIGHTR  SKIP FIRST 8 REGS IF 360/20
R0       EQU   0                   *
R1       EQU   1                   *
R2       EQU   2                   *
R3       EQU   3                   *
R4       EQU   4                   *
R5       EQU   5                   *
R6       EQU   6                   *
R7       EQU   7                   *
.EIGHTR  ANOP                      MODEL 20 BEGIN
R8       EQU   8                   *
R9       EQU   9                   *
R10      EQU   10                  *
R11      EQU   11                  *
R12      EQU   12                  *
R13      EQU   13                  *
R14      EQU   14                  *
R15      EQU   15                  *
TCTR     EQU   7                   TCT BASE REGISTER
         SPACE 3
*
*              REGISTER ASSIGNMENTS AND/OR TYPICAL ASSIGNMENTS
*
         SPACE 3
*              R15 = WORK REG (SECONDARY LINK OR PARAMETER REGISTER)
*              R14 = LINK REG
*              R13 = BUFFER POINTER
*              R12 = RESERVED
*              R11 = WORK
*              R10 = WORK
*              R9  = WORK
*              R8  = PARAMETER REGISTER
         AIF   (&MACHINE EQ 20).X1
*              R7  = WORK          READER ONLY
*              R6  = WORK
*              R5  = WORK
*              R4  = WORK
*              R3  = BASE REGISTER
*              R2  = BASE REGISTER
*              R1  = BASE REGISTER
*              R0  = ALTERNATE PARAMETER REG
.X1      AIF   (&MACHINE EQ 20).BASOK1
         USING HASPRJE-&HRTPORG,R0,R1,R2,R3 PROVIDE FOR 16K
         AGO   .BASOK2
.BASOK1  ANOP
         USING HASPRJE-&HRTPORG,0,1,2,3 PROVIDE FOR 16K
         DS    (X'24')C            SPACER FOR MODEL 20
.BASOK2  ANOP
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).ERRLOG
 TITLE 'ERROR MESSAGE LOG TABLE'
         SPACE 10
         AIF   (&ERRMSGN GE 8).ERRLOGA
&ERRMSGN SETA  8
.ERRLOGA ANOP
         SPACE 5
*
*        ERROR MESSAGE LOG TABLE AND POINTERS
*
         SPACE 3
$LOGTAB  DS    &ERRMSGN.XL4        ERROR MESSAGE LOG TABLE
$LOGEND  $ACON (*)                 END OF LOG TABLE
$LOGOUT  $ACON ($LOGTAB-4)         ADDRESS OF LAST MESSAGE WRITTEN
$LOGLAST $ACON ($LOGTAB-4)         ADDRESS OF LAST MESSAGE LOGGED
.ERRLOG  ANOP
         TITLE 'H A S P / R T P  * C O M M U T A T O R  *  '
         SPACE 12
         PRINT GEN
         AIF   (&MACHINE EQ 20).STRT1                          @OZ40559
         SSM   COMWAIT             ENABLE                      @OZ40559
.STRT1   ANOP                                                  @OZ40559
$START   $GENCOM
         PRINT &GEN
         SPACE 3
$CHNTEMP $ACON 0                   DISABLED TEMPORARY WORK
$LOGINFO DC    A(0)                INFORMATION TO BE LOGGED
$LOGSAVE $ACON 0                   $LOG REG SAVE AREA
$COMDCOM DS    0C
$INPCOM  DS    0C
$DATCOM  DS    0C
$ROUCOM  DS    0C
 TITLE 'CONTROL PROCESSOR TOTAL CONTROL TABLE  --  C T C T'
         PRINT GEN
         SPACE 10
&B       SETA  1                   SET SYMB TO CHAIN TCTS TOGETHER
&A       SETA  1
&D       SETA  1                   SIGNAL ORG TO GENTCT
$CTLTCT  $GENTCT C,&CFCS,&CRCB,FFF,0,&CTLM,&CBLM,&CFCS,&CRCB CONT TCT
&A       SETA  1
&D       SETA  &CONSOLE            SIGNAL DSECT OR ORG TO GENTCT
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).TCTWTO
 TITLE 'CONSOLE TOTAL CONTROL TABLE  -- W T C T'
$CONTCT  $GENTCT W,&WFCS(&A),&WRCB(&A),&WADR(&A),&WDEV(&A),&WTLM(&A),  C
               &WBLM(&A),&OFCS(&A),&ORCB(&A) CONSOLE TCT
.TCTWTO  ANOP
&D       SETA  &NUMPRT             SIGNAL DSECT OR ORG TO GENTCT
.TCTPRTL AIF   (&A GT &NUMPRT).TCTPRT
 TITLE 'PRINTER TOTAL CONTROL TABLES'
         $GENTCT P,&PFCS(&A),&PRCB(&A),&PADR(&A),&PDEV(&A),&PTLM(&A),  C
               &PBLM(&A),&PFCS(&A),&PRCB(&A) PRINTER TCT
&A       SETA  &A+1
         AGO   .TCTPRTL
.TCTPRT  ANOP
&A       SETA  1
&D       SETA  &NUMRDR             SIGNAL DSECT OR ORG TO GENTCT
.TCTRDRL AIF   (&A GT &NUMRDR).TCTRDR
 TITLE 'READER TOTAL CONTROL TABLES'
         AIF   (&S(&A) NE 0).TCTRDR1
         $GENTCT R,&RFCS(&A),&RRCB(&A),&RADR(&A),&RDEV(&A),0,0,        C
               &RFCS(&A),&RRCB(&A) READER TCT
         AGO   .TCTRDR2
.TCTRDR1 ANOP
&T       SETA  &S(&A)
         $GENTCT R,&UFCS(&T),&URCB(&T),&RADR(&A),&RDEV(&A),&UTLM(&T),  C
               &UBLM(&T),&RFCS(&A),&RRCB(&A) DUAL READER TCT
&T       SETA  &B-1
.TCTRDR2 ANOP
&A       SETA  &A+1
         AGO   .TCTRDRL
.TCTRDR  ANOP
&A       SETA  1
&D       SETA  &NUMPUN             SIGNAL DSECT OR ORG TO GENTCT
.TCTPUNL AIF   (&A GT &NUMPUN).TCTPUN
 TITLE 'PUNCH TOTAL CONTROL TABLES  --  U T C T'
         $GENTCT U,&UFCS(&A),&URCB(&A),&UADR(&A),&UDEV(&A),&UTLM(&A),  C
               &UBLM(&A),&UFCS(&A),&URCB(&A) PUNCH TCT
&A       SETA  &A+1
         AGO   .TCTPUNL
.TCTPUN  ANOP
 TITLE 'MISCELLANEOUS GLOBAL STORAGE'
$TCT&B   EQU   0                   LAST TCT POINTS TO ZERO
         PRINT &GEN
         SPACE 3
*
*              E R R O R  L O G  T A B L E
*
LOGTABLE DS    0H
         ORG   *+X'92'             ORG OVER THE LOG TABLE
$ERRTAB  EQU   LOGTABLE-LOGEND+LOGDSECT ERROR LOG TABLE FOR CE
 SPACE 3
*
*                  BEGINNING OF QUEUE CHAINS
*
 SPACE 3
$TEMP    DC    H'0'                GLOBAL TEMPORARY WORK
$TPBFSIZ DC    AL2(&TPBFSIZ)       RJE BUFFER SIZE                   R4
$BUFPOOL $ACON $1STBUF             BUFFER POOL CHAIN CONTROL WORD
$TANKPOL $ACON $1STTANK            TANK QUEUE CONTROL WORD
$OUTBUF  $ACON 0                   XMISSION BUFFER CHAIN CTL WORD
$CORESIZ $ACON 0                   SYSTEM MEMORY SIZE
$FCSOUT  DS    0H                  OUTGOING FUNCTION CONTROL SEQUENCE
         DC    X'8FCF'             ALL FUNCTIONS PERMITTED
$FCSIN   DC    X'8FCF'             INCOMING FCS FROM HASP
         AIF   (&MACHINE NE 20).N20CON
$WAITCON DC    H'160'              DELAYING CONSTANT FOR MOD 20
         AGO   .N30CON
.N20CON  ANOP
$WAITCON DC    H'1500'             DELAYING CONSTANT FOR MODEL 30
.N30CON  ANOP
 TITLE '$ C O N T R O L  -- INPUT CONTROL RECORD PROCESSOR  '
*
*
$CRTN1   NULL
$CCOMM1  EQU   $CONTCOM
CFLAGS   EQU   0                   DUMMY CCW
COPCODE  EQU   0                   DUMMY CCW
*
$CONTROL NULL  *                   ENTRY POINT
        $LA    R13,$CTLTCT         GET CONTROL TCT
         USING TCTDSECT,R13        *
        $DCHAIN TCTTANK,R8,NOSSM   GET A TANK OF DATA
         BNZ   MPROCESS            BR IF GOTTEN
         MVI   $CONTCOM+1,0        NONE... CLOSE ENTRY
         B     $CONTCOM+4          AND EXIT
*
*              PROCESS A CONTROL RECORD
*
         SPACE 3
MPROCESS NULL  *                   *
         $TCTPOST T,R10            SHOW TANK GOTTEN
         DROP  R13                 DONE FOR NOW
         USING TANKDSEC,R8         *
         UNPK  MTEMP+1(1),TANKRCB(1) SWAP DIGITS
         NI    MTEMP+1,7           TURN OFF CTL BIT                  R4
         LH    R10,MTEMP           GET CTL FUNCTION TYPE
         AR    R10,R10             DOUBLE IT
         $LA   R9,MCONTTAB-2       START OF CTL TYPE TABLE
         AR    R9,R10              R9 = CORRECT TABLE ENTRY
         LH    R9,0(0,R9)          R9 = CONTROL ADDRESS
         STH   R9,*+6              ENTER ROUTINE
         B     *-*
         EJECT
*
*              SUBROUTINE TO FIND TCT CORRESPONDING TO SRCB FUNCTION
*                R14=RETURN , CC NE 0 -R13 CONTAINS TCT,CC=0-NOT FOUND
         SPACE 3
MTCTFIND NULL  *                   ENTRY POINT
        $LA    R13,$TCT1           FIRST TCT
         USING TCTDSECT,R13        ADDRESSABILITY
MNEXTTCT NULL  *                   *
         CLC   TCTRCB,TANKSRCB     IS THIS CORRECT TCT
         BE    MTCTOK              BR IF YES
         AIF   (&R(2) AND &R(3) AND &R(7)).MDUAL
         CLC   TCTINRCB,TANKSRCB   TEST FOR CORRECT TCT HERE
         BE    MTCTOK              BR IF YES
.MDUAL   ANOP
        $LOAD  R13,TCTNEXT         NO... TO NEXT
        $LTR   R13,R13             IS THIS ALL...
         BNZ   MNEXTTCT            BR IF MORE
         BR    R14                 RETURN WITH COND. CODE = 0
MTCTOK  $LTR   R14,R14             SET COND. CODE NON-ZERO
         BR    R14                 AND RETURN
         EJECT
         SPACE 5
*
*              SUBROUTINE TO $TPPUT AN ANSWERING CTL RECORD
*                   R8 = TANKADDR
         SPACE 3
MPUT     NULL  *                   ENTRY POINT
         BAS   R14,$TPPUT          GO PUT RECORD
         BNZ   MEXIT               EXIT IF ACCEPTED
         MVC   $CONTCOM+2(2),MREPUTA    SET COMUTATOR RE-ENTRY
        $STO   R8,MTANK            SAVE TANK ADDR
         B     $CONTCOM+4          EXIT TO COMUTATOR
MREPUT   NULL  *                   RETRY PUTTING RECORD
        $LOAD  R8,MTANK            RESTORE TANK ADDR
         BAS   R14,$TPREPUT        TRY IT
         BZ    $CONTCOM+4          CYCLE IF STILL NOT ACCEPTED
MEXIT    NULL  *                   ENTRY AT END OF PROCESSING
        $FREE  $TANKPOL,R8,NOENB   FREE TANK
         MVC   $CONTCOM+2(2),MCONTROL     RESET COMUTATOR
         B     $CONTROL            AND TRY NEXT TANK
MTANK   $ACON  0                   TANK REG STORAGE
MTEMP    DC    H'0'                TEMP STORAGE (HI-BYTE ALWAYS ZERO)
MREPUTA  DC    S(MREPUT)           COMMUTATOR ADJUSTMENT ADDR
MCONTROL DC    S($CONTROL)         COMMUTATOR ADJUSTMENT ADDR
MCONTTAB NULL  *                   CONTROL TYPE BRANCH TABLE
*        DC    S(MC0)         000  RESERVED
         DC    S(MC1)         001  START FUNCTION REQUEST
         DC    S(MC2)         010  START FUNCTION PERMISSION
         DC    S(MC3)         011  RESERVED
         DC    S(MC4)         100  RESERVED
         DC    S(MC5)         101  RESERVED
         DC    S(MC6)         110  RESERVED
         DC    S(MC7)         111  GENERAL CONTROL TYPE
         EJECT
         SPACE 3
*
* MC0          CONTROL RECORD , TYPE = 000 (RESERVED)
*
         SPACE 3
*
*              RESERVED FOR FUTURE USE
*
MC0      EQU   MEXIT               TO DEFINE SYMBOL
         SPACE 3
*
* MC1          CONTROL RECORD , TYPE = 001(REQUEST TO START FUNCTION)
*
         SPACE 3
MC1      NULL  *                   *
*
         BAS   R14,MTCTFIND        GO FIND TCT
         BNZ   MTCTSET             BR IF FOUND
        $TRACE SSM=YES
         B     MEXIT               IGNORE REQUEST
MTCTSET  NULL  *                   CORRECT TCT FOUND
         NI    TCTSTAT,255-TCTOPEN SHOW USE
         MVZ   TANKRCB,=X'A0'      CHANGE REQUEST TO PERMISSION
         B     MPUT                AND SEND IT
         SPACE 3
*
* MC2          CONTROL RECORD , TYPE = 010(PERMISSION TO START FCN)
*
         SPACE 3
MC2      NULL  *                   ENTRY POINT
        $TRACE SSM=YES
         BAS   R14,MTCTFIND        GO LOOK-UP TCT
         BZ    MEXIT               IGNORE IF NOT FOUND
        $LOAD  R14,TCTCOM          GET COMUTATOR ENTRY
         MVI   1(R14),X'F0'        OPEN IT
         NI    TCTSTAT,255-TCTOPEN SHOW OPEN
         B     MEXIT               AND EXIT
         SPACE 3
*
* MC3          CONTROL RECORD , TYPE = 011 (RESERVED)
         SPACE 3
MC3      EQU   MEXIT               NOT YET DEFINED
         SPACE 3
*
* MC4          CONTROL RECORD , TYP = 100 (RESERVED)
*
         SPACE 3
MC4      EQU   MEXIT               NOT YET DEFINED
         SPACE 3
*
* MC5          CONTROL RECORD , TYPE = 101 (RESERVED)
*
         SPACE 3
MC5      EQU   MEXIT               TO DEFINE SYMBOL
*                                  FUNCTION IS NOT YET SUPPORTED
         SPACE 3
*
* MC6          CONTROL RECORD , TYPE = 110(RESERVED)
*
         SPACE 3
*
*              THIS CONTROL TYPE IS CURRENTLY UNDEFINED BUT IS
*              RESERVED FOR FUTURE USE.
*
MC6      EQU   MEXIT               TO DEFINE SYMBOL
         SPACE 3
*
* MC7          CONTROL RECORD , TYPE = 111 (GENERALIZED CONTROL)
*                                          (TYPE INDICATED IN SRCB)
*
         SPACE 3
MC7      EQU   MEXIT               ENTRY POINT
*
*              CURRENTLY NO FUNCTIONS ARE IMPLEMENTED FOR THIS
*              CONTROL FUNCTION. THE TYPE OF CONTROL RECORD, SUCH
*              AS ACCOUNTING,SIGN-ON,INITIALIZATION,ETC, IS
*              INDICATED IN THE SRCB.
*              THE SRCB IDENTIFICATION CHARACTERS 'A' THRU 'R'
*              AND '0' THRU '9' ARE RESERVED FOR FUTURE HASP
*              DEVELOPMENT. ALL OTHER EBCDIC CHARACTERS , WHICH
*              ARE TRANSMISSION COMPATIBLE ARE AVAILABLE TO THE
*              USER TO ADD ADDITIONAL CONTROL FUNCTIONS.
*
         SPACE 3
         DROP  R8,R13
         PRINT &GEN
         AIF   (&NUMPRT EQ 0).PRTNSKP
 TITLE '$ P R T N 1  --  PRINT SERVICE PROCESSOR'
&A       SETA  0
*
*        BASE REGISTER ASSIGNMENT
*
         USING TANKDSEC,R8
         AIF   (&NUMPRT EQ 1).PSK1
         USING PCTDSECT,TCTR
.PSK1    ANOP
$PRTN1   NULL
PNEXT    EQU   *                   BASIC LOOP
         $GETTNK P,R8,R9,EMPTY=WAIT GET NEXT TANK TO PRINT
         AH    R8,=Y(TANKDATA-TANKDSEC) GET TO DATA                @N30
         STH R8,PCTCCW+2           PUT DATA ADDRESS IN CCW         @N30
         SH    R8,=Y(TANKDATA-TANKDSEC) GET TO START OF TANK       @N30
         CLI   TANKCNT+1,0         TEST FOR END OF JOB
         AIF   (&PRTCONS EQ 0).PSK5
         BNE   PTSTEOF             BRANCH IF NON ZERO COUNT        @N30
         MVI   PEOFSW,X'FF'        INDICATE END OF FILE            @N30
         OI    PCTSTAT,TCTPRTSW    SET PRINTER AVAILABLE
         OI    $WCOMM1+1,X'F0'     TURN ON CONSOLE COMMUTATOR GATE
         MVI   TANKSRCB,X'B1'      FORCE SKIP                      @N30
         B     PSETCC              GO PRINT BLANK AND SUPPRESS     @N30
PEOFSW   DC    AL1(*-*,*-*)        END OF FILE SWITCH              @N30
PTSTEOF  CLI   PEOFSW,0            END OF FILE SW ON...            @N30
         BE    PTSTRCB             TEST TYPE IF NOT                @N30
         CLC   TANKCNT(3),=AL1(0,1,X'40') PRINT BLANK LINE...      @N30
         BNE   PTSTRCB             ALLOW PRINT IF NOT              @N30
         OI    TANKSRCB,X'20'      FORCE IMMEDIATE COMMAND         @N30
         CLI   TANKSRCB,X'B1'      COMMAND EJECT...                @N30
         BE    PSKIO               SUPPRESS EJECT IF SO            @N30
PTSTRCB  CLC   TANKRCB,PCTRCB      IS THIS A PRINTERS RCB...       @N30
         BNE   PTCON               NO, DO CONSOLE PROCESSING       @N30
         MVI   PEOFSW,X'00'        SET OFF END OF FILE SWITCH      @N30
         NI    PCTSTAT,255-TCTPRTSW RESET PRINTER AVAILABLE        @N30
         TM    PCTSTAT,TCTREL      LAST PRINT FOR CONSOLES...      @N30
         BZ    PSETCC              NO, NO NEED TO EJECT            @N30
         NI    PCTSTAT,255-TCTREL  RESET CONSOLE ACTIVE            @N30
         NI    TANKSRCB,X'7F'      FORCE EJECT BEFORE PRINTING     @N30
         B     PSETCC              GO AND PRINT                    @N30
PTCON    TM    PCTSTAT,TCTREL      WAS PRINT FOR CONSOLES...       @N30
         BO    PSETCC              YES - GO AHEAD AND PRINT        @N30
         OI    PCTSTAT,TCTREL     INDICATE CONSOLE PROCESSING      @N30
PSETCC   DS    0H
         AGO   .PSK5A
.PSK5    ANOP
         BE    PFREE               FREE THE TANK IF END OF JOB
.PSK5A   ANOP
         CLI   TANKSRCB,X'8E'      LOOK FOR CHANGE IN FORMS
         AIF   (&CONSOLE EQ 0).PSK5B
         BE    PFREE               IGNORE THIS LINE IF FORMS MSG
         AGO   .PSK5C
.PSK5B   BNE   *+8                 SKIP SRCB MODIFICATION IF NO
         MVI   TANKSRCB,X'91'      INSERT PRINT AND EJECT SRCB
.PSK5C   ANOP
         MVC   PCTCCWCT+1(1),TANKCNT+1 SET THE LINE IN CCW
*
*        SET UP CARRIAGE CONTROL
*
         AIF   (&MACHINE EQ 20).PSK2
         LA    R9,TANKDATA         LOCATE THE DATA
         ST    R9,PCTCCW           SAVE IT IN THE CCW
         IC    R9,TANKSRCB         PICK UP CARRIAGE CONTROL INFO
         SLL   R9,3                ALIGN CC BITS FOR OPCODE
         STC   R9,PCTOPCOD         SET CARRIAGE CONTROL IN OPCODE
         TM    TANKSRCB,PSKIMM     TEST FOR SKIP IMMEDIATE
         BZ    PNOTIMM             NO IF ON SO PRINT WITH DELAYED SKIP
         OI    PCTOPCOD,PCCOP      SET CCW OP-CODE FOR CC EXECUTE
         $WRITE P                  PERFORM THE CARRIAGE CONTROL
         $CHECK P                  CHECK FOR OK
         L     R8,PCTCCW           PICK UP AREA
PRINT    IC    R9,=AL1(POPCODEI)   SET PRINT SPACE 1 AFTER PRINT
PNOTIMM  STC   R9,PCTOPCOD         STORE CC BITS IN OP-CODE SAVE
         OI    PCTOPCOD,POPCODE    SET TO PRINT A LINE
         CLI   PCTOPCOD,X'61'      Q. IF FCB LOAD REQUEST
         BNE   PLINE               BR. IF NO
         OI    PCTOPCOD,X'02'      CONVERT COMMAND TO X'63'
         AIF   (&R(9) EQ 0 AND &R(10) EQ 0).PSK3  NO 3203 OR 5203
         AIF   (&NUMPRT EQ 1).PSK3A  ONLY ONE PRINTER ON SYSTEM
         TM    PCTINDEX,INDEXOK    Q. IF INDEX BYTE ALLOWED
         BO    PLINE               BR. IF YES
.PSK3A   ANOP
         LM    R8,R9,PCTCCW        PICK UP CCW
         LA    R8,1(0,R8)          INCREMENT OVER INDEX BYTE
         BCTR  R9,0                REDUCE BYTE COUNT BY ONE
         STM   R8,R9,PCTCCW        REPLACE CCW
         AGO   .PSK3
.PSK2    ANOP
         MVC   PCIO+3(1),TANKSRCB  PICK UP CARRIAGE CONTROL INFO
         MVI   PCIO+1,X'44'        RESET CONTROL OPCODE
         TM    PCIO+3,PSKIMM       CK FOR SKIP IMMEDIATE
         BO    PSKIM               IF YES GO AROUND DELAY SETTING
         OI    PCIO+1,X'02'        SET SKIP AFTER PRINT 44=46
PSKIM    TM    PCIO+3,X'10'        CK FOR SKIP NOT SPACE
         BZ    PSKLNS              IF OFF SPACE
         OI    PCIO+1,X'01'        SET SKIP 44=45, 46=47
PSKLNS   DS    0H                                                  @N30
         TM    PCIO+3,X'80'        IS SPECIAL EJECT REQD...        @N30
         BO    PNOEJECT            SKIP NEXT IF NOT                @N30
         $DELAY P,TYPE=SETUP       PREPARE FOR WAITING             @N30
         CIO   1,X'45'             EJECT IMMEDIATE                 @N30
         BC    7,$PCOMM1+4         WAIT FOR START                  @N30
         $CHECK P                  WAIT FOR FINISH                 @N30
PNOEJECT DS    0H                                                  @N30
         OI    PCTCCW+1,X'01'      SPACE SUPPRESS BIT ON
         TM    PCIO+3,X'3F'        DO WE SPACE SUPPRESS
         BZ    PLINE               IF SO SKIP OVER CARRIAGE CONTROL
         NI    PCTCCW+1,255-X'01'  TURN SPACE SUPPRESS OFF
         $DELAY P,TYPE=SETUP       PREPARE FOR WAITING
PCIO     CIO   *-*,*-*             PERFORM CARRIAGE CONTROL OPERATION
         BC    7,$PCOMM1+4         WAIT AND TRY LATER IF NO START
         $CHECK P                  WAIT FOR FINISH
         TM    PCIO+1,X'02'        IMMEDIATE CARRIAGE CMD...       @N30
         BZ    PSKIO               YES, SKIP PRINT                 @N30
.PSK3    ANOP
PLINE    $WRITE P,S=PCTCCW         PRINT THE LINE
         $CHECK P                  CHECK FOR FINISHED
PSKIO    DS    0H                                                  @N30
         $LOAD R8,PCTCCW+4-&L      PICK UP AREA FROM CCW
         AIF   (&MACHINE EQ 20).PSK6                           @OZ84440
         CLI   PCTOPCOD,X'63'      FCB LOAD REQUEST...         @OZ84440
         BNE   PSKTANK              NO, BRANCH TO FREE TANK    @OZ84440
         AIF   (&R(9) EQ 0 AND &R(10) EQ 0).PSK6  NO 3203 OR   @OZ84440
         AIF   (&NUMPRT EQ 1).PSK6A  5203 & ONLY ONE PRINTER   @OZ84440
         TM    PCTINDEX,INDEXOK    INDEX BYTE ALLOWED...       @OZ84440
         BO    PSKTANK             BRANCH IF YES, OTHERWISE    @OZ84440
.PSK6A   ANOP                                                  @OZ84440
         BCTR  R8,0                 BACKUP TO INCLUDE INDEX    @OZ84440
         AGO   .PSK6                                           @OZ84440
.PSK6    ANOP                                                  @OZ84440
PSKTANK  SH    R8,=Y(TANKDATA-TANKDSEC) GET START OF TANK      @OZ84440
PFREE    $FREE $TANKPOL,R8,ENBL    RELEASE THE TANK ENABLED
         B     PNEXT               PRINT NEXT LINE
         AIF   (&NUMPRT EQ 1).PRTN1
         DROP  TCTR
.PRTN1   ANOP
         $ENDPROC P                END OF PRINT PROCESSOR
*
*        EQUATES FOR PRINT PROCESSOR
*
PSKIMM   EQU   X'20'               SRCB FLAG TO SKIP IMMEDIATE
         AIF   (&MACHINE EQ 20).PSK4
POPCODEI EQU   X'09'               PRINT OP-CODE SPACE 1 AFTER
PFLAGS   EQU   X'20'               NO CHAINING,SUPPRESS WRONG LENGTH CK
POPCODE  EQU   X'01'               CCW PRINT LINE OPCODE NO SPACE
PCCOP    EQU   X'03'               CARRIAGE CONTROL OP-CODE
         AGO   .PRTNSKP
.PSK4    ANOP
PCT      EQU   132                 LINE LENGTH AS ASSEMBLED
PCTCCWCT EQU   PCTCCW+4            LOCATION OF COUNT FIELD
PCTRTN   EQU   $PCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.PRTNSKP ANOP
         AIF   (&NUMRDR EQ 0).RRTNSKP
 TITLE ' $ R R T N 1  -- INPUT SERVICE PROCESSOR'
&A       SETA  0
*
*        INPUT SERVICE PROCESSOR
*
*        GENERATION LOGIC VARIBLE MEANINGS
*        &R(1) = 0 FOR 1442,2501,2520,2540,2560 READ DEVICES
*        &R(2) = 0 FOR 2520 READ/PUNCH DEVICES
*        &R(3) = 0 FOR 1442 READ/PUNCH DEVICES
*        &R(6) = 0 FOR MOD 20
*        &R(7) = 0 FOR 2560 READ/PUNCH DEVICE
         AIF   (&NUMRDR EQ 1).RRTN1                     1+2+3+6+7
         USING RCTDSECT,TCTR       WE HAVE MULTIPLE READ TCTS
.RRTN1   AIF   (&R(7)).RRTN2
         USING TANKDSEC,R8         DATA TANKS FOR 2560 PUNCH ROUTINE
.RRTN2   ANOP                                           1+2+3+6+7
$RRTN1   NULL                      INITIAL ENTRY AT IPL TIME
RDSTART  DS    0H                  ENTRY AFTER EOF, LOOP FOR DUAL PUNCH
         AIF   (&R(2) AND &R(3) OR NOT &R(6)).RRTN18
         MVI   RCTCCWCT+1,80       MAKE SURE COUNT IS 80
.RRTN18  ANOP
READ1    $READ R,RCTTDTA1          PERFORM THE INITIAL READ
RCK1     $CHECK R,RDERR1,RDEOF1    MAKE SURE IN OK
         AIF   (&R(2) AND &R(3) OR &R(1)).RRTN3           (2+3)*1
         TM    RCTSTAT,TCTDUAL     TEST FOR SINGLE FEED DUAL DEVICE
         BZ    ROPEN               IF NOT GO AHEAD OPEN THE SERVICE
.RRTN3   AIF   (&R(2) AND &R(3)).RRTN4                        2+3
         CLC   RCTTDTA1(80),RCTTDTA2 CHECK FOR ALL BLANK CARD
         BE    RTESTPUN            LOOK FOR PUNCH DATA IF BLANK
.RRTN4   AIF   (&R(2) OR &R(3)).RRTN5
         TM    RCTSTAT,TCT25200    DO WE HAVE A 2520 READ/PUNCH
         BZ    ROPEN               IF NOT NO NEED TO STACKER SELECT
.RRTN5   AIF   (&R(2) OR NOT &R(6)).RRTN6                          2*-6
         $WRITE R,OP=R252003       SELECT POCKET 1 FOR READ JOB STREAM
         MVI   RCTOPCOD,R252002    SET UP FOR READING CARDS
.RRTN6   ANOP                                           1+2+3+6+7
ROPEN    $LA   R8,RCTTANK1         LOCATE TANK IN PARAMETER REG
         AIF   (&HOME EQ 1).RHOME
         BAS   R14,$TPOPEN         REQUEST HASP TO RECEIVE STREAM
         BZ    RREOPEN             IF NOT SENT TO HASP WAIT
         AIF   (&LOCCOM EQ 0).RRTN7A
         NI    RCTID,255-C' '      PREVENT OPERATOR ACTION
.RRTN7A  AIF   (&MACHINE EQ 20).RRTN7
         OI    RCTUCB,TCTNOINT     DISABLE INTERRUPTS ON DEVICE
         $DELAY R,TIME=LONG,TYPE=BRANCH WAIT FOR HASP TO RESPOND
         NI    RCTUCB,255-TCTNOINT ENABLE INTERRUPTS ON DEVICE
         AGO   .RRTN8
.RRTN7   ANOP                                            -(1+2+3)
         $DELAY R,TIME=LONG,TYPE=BRANCH WAIT FOR HASP TO RESPOND
.RRTN8   AIF   (&LOCCOM EQ 0).RRTN8A
         OI    RCTID,C' '          ALLOW OPERATOR ACTION
.RRTN8A  ANOP
*              WE MUST GO BACK TO COMMUTATOR FOR GATE TO BE OPENED
.RHOME   ANOP
RDLOOP   DS    0H                  BASIC READ LOOP
         $READ R,RCTTDTA2          READ A CARD
         MVC   RCTTCT1,=H'80'      SET LENGTH INTO TANK COUNT
         $PUT  R,RCTTANK1          SEND PREVIOUS TANK DATA TO HASP
         $CHECK R,RDERR,RDEOF      CHECK FOR CARD IN OK
         $READ R,RCTTDTA1          READ A CARD
         MVC   RCTTCT2,=H'80'      SET LENGTH INTO TANK COUNT
         $PUT  R,RCTTANK2          SEND PREVIOUS TANK DATA TO HASP
RCHECK   DS    0H                  REENTRY AFTER ERRORS
         $CHECK R,RDERR,RDEOF      CHECK FOR CARD IN OK
         B     RDLOOP              IF SO CONTINUE TO READ CARDS
RDEOF    MVC   RCTTCT1,=F'0'       SET END OF FILE INDICATOR
         $DELAY R,TYPE=SETUP       PREPARE FOR REJECT ON SENDING
         $LA   R8,RCTTANK1         PUT TANK ADDR IN PARAMETER REG
         BAS   R14,$TPPUT          SEND TO HASP EOF SIGNAL
         BZ    RCTRTN              IF NOT PREPARED FOR SEND WAIT RETRY
         AIF   (&R(2) AND &R(3)).RRTN9                      2+3
         MVI   RCTTDTA2,C' '       INSERT A BLANK IN THE DATA AREA
         MVC   RCTTDTA2+1(79),RCTTDTA2  BLANK REST. USED FOR COMPARE
.RRTN9   AIF   (&MACHINE EQ 20).RRTN10                     -(6+7)
         OI    RCTECB,TCTBUSY      SET READER BUSY FOR WAITING
         AIF   (&R(2) OR &R(1) AND &R(3)).RRTN11          2*(1+3)
         TM    RCTSTAT,TCT25200    TEST FOR DUAL 2520
         BZ    RDSTART             IF NO GO TO START OF ROUTINE
.RRTN11  AIF   (&R(2)).RRTN10                                -6*2
         MVI   RCTOPCOD,R25200     RESET THE INITIAL READ OPCODE
.RRTN10  AIF   (&R(7)).RRTN14                                   7
         B     RDEOF1              ATTEMPT TO PUNCH
         AGO   .RRTN15
.RRTN14  ANOP                                                  -7
         B     RDSTART             GO BACK TO START OF PROCESSOR
.RRTN15  ANOP                                           1+2+3+6+7
RDERR    $INTREQ R,RDR             PREPARE TO WAIT ON OPERATOR
         $READ  R,RCTTDTA1         READ AGAIN
         B     RCHECK              SEE IF IN PROPERLY
RREOPEN  $DELAY R,TIME=SHORT,TYPE=BRANCH,PREVLOC=ROPEN WAIT, TRY AGAIN
RDERR1   $INTREQ R,RDR,PREVLOC=READ1 PREPARE TO WAIT ON OPERATOR, READ
         AIF   (&R(7)).RRTN12                                   7
RDEOF1   $GETTNK R,R8,R9,EMPTY=RTEST NO CARDS TO READ TRY PUNCHING
         CLI   TANKCNT+1,0         TEST FOR END OF JOB
         BE    RDFREE              FREE THE TANK IF END OF JOB
RDPUNCH  $WRITE R,TANKDATA,TANKDSEC,OP=UOPCODE,CTADDR=TANKCNT,S=RDPCH
         $CHECK R,RDPUNCHA         CHECK IF OK, PUNCH AGAIN IF NOT
         DC    X'9A',AL1(RFEED),S(RDPUNCHA)  TEST FEED ERROR
         LH    R8,RDPCH+2          PICK UP I/O AREA
         SH    R8,=Y(TANKDATA-TANKDSEC) GET TO START OF TANK
RDFREE   $FREE $TANKPOL,R8,ENBL    FREE THE TANK
         LH    R8,RDCTR            LOAD READ TIMER COUNT
         AH    R8,=H'-1'           SUBTRACT 1
         STH   R8,RDCTR            SAVE RESULTS
         BNE   RDEOF1              IF NOT ZERO CONTINUE PUNCHING
         MVC   RDCTR,RDCT          REPLENISH MAX COUNT
RTEST    MVC   RDCTRR,RDCTAR       SET UP FOR MULTIPLE READ TESTS
RTESTB   $DELAY R                  WAIT ONE TIME AROUND
         XIO  RCTTDTA1(ROPCODE+1),RCT TRY READING
         BC    7,RDTESTA           IF NO START DEC COUNT
         CIO   RPOC,RSTACK         STACK THE CARD
         $CHECK R,RDERR1,RDTESTA   CHECK FOR COMPLETION
         B     ROPEN               IF IN OK OPEN UP INPUT SERVICE
RDTESTA  LH    R8,RDCTRR           LOAD READ TEST COUNT
         AH    R8,=H'-1'           REDUCE
         STH   R8,RDCTRR           SAVE RESULTS
         BNE   RTESTB              WAIT SOME MORE
         B     RDEOF1              TRY PUNCHING
RDPUNCHA CIO   UBADPOC,UNSTACK     SELECT BAD POCKET
         B     RDPUNCH
RDCT     DC    H'100'              CONSTANTS FOR DELAY OF READ TEST
RDCTR    DC    H'100'              WHILE PUNCHING
RDCTAR   DC    H'190'              DELAY TO RECOGNIZE
RDCTRR   DC    H'190'              INPUT STREAM
         AGO   .RRTN13
.RRTN12  AIF   (NOT &R(6)).RRTN12A
RDEOF1   EQU   RDERR1              HANDLE EOF AS ERROR
         AGO   .RRTN13
.RRTN12A ANOP
RDEOF1   EQU   RDSTART             IGNORE EOF
.RRTN13  AIF   (&R(2) AND &R(3)).RRTN16                             2+3
*
*        ROUTINE TO PREPARE TO PUNCH CARDS ON A DUAL READ/PUNCH DEVICE
*
RTESTPUN NULL
         AIF   (&MACHINE EQ 20).RRTN19
         MVI   RCTECB,0            REMOVE DEVICE END INDICATION
RTEST    TM    RCTECB,DEVEND       TEST FOR DEVICE END
         BO    RDSTART             OPERATOR INSERTED NEW CARDS IF YES
         AGO   .RRTN20
.RRTN19  AIF   (&CONSOLE EQ 0).RRTN21
         OI    RCTSTAT,TCTSTOP     SET STOP STATUS
RTEST    TM    RCTSTAT,TCTSTOP     TEST FOR OPERATOR RESPONSE
         BZ    RDSTART             OPERATOR RESPONDED
.RRTN20  ANOP
         CLI   RCTTNKCT,0          TEST FOR A PUNCH TANK AVAILABLE
         BNE   $URTN1              IF SO PREPARE TO PUNCH
         $DELAY R,TYPE=BRANCH,TIME=LONG,PREVLOC=RTEST WAIT, LOOP BACK
         AGO   .RRTN16
.RRTN21  ANOP
         $DELAY R,TIME=SHORT,TYPE=SETUP PREPARE FOR WAIT
         BAS   R14,$DIAL           REQUEST DIAL READING
         DC    Y(RADR*2+$DIALTAB)
         B     RTEST               IF NO RESPONSE TEST FOR TANK
         B     RDSTART             OPERATOR RESPONDED
RTEST    MVC   RADR*2+$DIALTAB(2),=Y(YODNULL) REPLACE TABLE ELEMENT
         CLI   RCTTNKCT,0          TEST FOR TANK
         BNE   $URTN1              PUNCH CARD IF TANK
         B     $RCOMM1+4           WAIT IF NO TANK
.RRTN16  ANOP
         AIF   (&NUMRDR EQ 1).RRTN17
         DROP  TCTR
.RRTN17  ANOP
         $ENDPROC R                END OF READ PROCESSOR
         AIF   (&MACHINE NE 20).RRTNSKP
*
*        INPUT PROCESSOR EQUATES
*
RCT      EQU   80                  LENGTH OF CARD
RCTRTN   EQU   $RCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.RRTNSKP ANOP
         AIF   (&NUMPUN EQ 0).URTNSKP
 TITLE '$ U R T N 1  --  PUNCH SERVICE PROCESSOR'
&A       SETA  0
*
*        PUNCH SERVICE PROCESSOR
*
*        GENERATION LOGIC VARIABLE MEANINGS
*        &R(2) = 0 FOR 2520 READ/PUNCH DEVICES
*        &R(3) = 0 FOR 1442 READ/PUNCH DEVICES
*        &R(4) = 0 FOR 2540 PUNCH DEVICES
*        &R(5) = 0 FOR 2520,2560 PUNCH DEVICES
*        &R(6) = 0 FOR MOD 20
*        &R(7) = 0 FOR 2560 READ/PUNCH DEVICE
*        &R(8) = 0 FOR 1442 SINGLE POCKET PUNCH DEVICES
         USING TANKDSEC,R8
         AIF   (&NUMPUN EQ 1).URTN1
         USING UCTDSECT,TCTR
.URTN1   ANOP                                               2+3+4+5+6+8
$URTN1   NULL                      INITIAL ENTRY AT IPL TIME,DUAL PUNCH
USTART   DS    0H                  LOOP ENTRY TO CONTINUE PUNCHING
         $GETTNK U,R8,R9,EMPTY=WAIT GET OUTPUT TANK WITH PUNCH RECORD
         CLI   TANKCNT+1,0         TEST FOR END OF JOB
         BE    UFREE               IF SO FREE TANK
UOUTPUT  DS    0H                  PUNCH THE CARD
UPUNCH   $WRITE U,TANKDATA,TANKDSEC,OP=(UCTALTOP,D),CTADDR=TANKCNT,    C
               S=UCTCCW            PUNCH THE CARD
         AIF   (&R(4) OR &R(2) AND &R(3) AND &R(5) AND &R(8)).URTN2
         TM    UCTSTAT,TCT2540     TEST FOR 2540 PUNCH
         BZ    UCHECK              IF NOT GO CHECK I/O OK
.URTN2   AIF   (&R(4)).URTN3                                          4
         TM    UCTHOLD+&L-1,1      TEST FOR ODD ADDRESS IN HOLD (EMPTY)
         BO    USAVHOLD            IF SO HOLD THE CURRENT TANK
         $CHECK U,UBAD             CHECK FOR I/O COMPLETE
         $LOAD R8,UCTHOLD          PICK UP OLD TANK
         $FREE $TANKPOL,R8,ENBL    RELEASE THE TANK
USAVHOLD $LOAD R8,UCTCCW+4-&L      PICK UP TANK ADDRESS
         SH    R8,=Y(TANKDATA-TANKDSEC) GET TO START OF TANK
         $STO  R8,UCTHOLD          SAVE FOR NEXT TIME
         B     USTART              LOOK TO PUNCH NEXT CARD
UBAD     $LOAD R8,UCTHOLD          PICK UP THE HELD TANK (OLD)
         $LOAD R9,UCTCCW+4-&L      PICK UP THE CURRENT TANK (NEW)
         SH    R9,=Y(TANKDATA-TANKDSEC) GET TO START OF NEW TANK
         $STO  R9,UCTHOLD          HOLD THE NEW TANK
UBADP    $WRITE U,TANKDATA,CTADDR=TANKCNT PUNCH THE OLD TANK
         $CHECK U,UBADP            CHECK FOR OK
         $LOAD R8,UCTHOLD          PICK UP THE NEW TANK
         $LOAD R9,UCTCCW+4-&L      PICK UP THE OLD TANK
         SH    R9,=Y(TANKDATA-TANKDSEC) GET TO START OF OLD TANK
         $STO  R9,UCTHOLD          HOLD THE OLD TANK
         B     UOUTPUT             REPUNCH THE CARD
.URTN3   AIF   (&R(2) AND &R(3) AND &R(5) AND &R(8)).URTN4
UCHECK   $CHECK U,UERR             CHECK FOR IN OK
         AIF   (&R(2) AND &R(5) AND &R(7) OR &MACHINE NE 20).URTN3A
         DC    X'9A',AL1(UFEED),S(UERR) TEST FEED ERROR
.URTN3A  ANOP
         $LOAD R8,UCTCCW+4-&L      PICK UP DATA ADDRESS
         SH    R8,=Y(TANKDATA-TANKDSEC) GET TO START OF TANK
.URTN4   ANOP
UFREE    $FREE $TANKPOL,R8,ENBL    RELEASE THE TANK
         AIF   (&R(2) AND &R(3) OR &R(5) AND &R(8) AND &R(4)).URTN5
         TM    UCTSTAT,TCT25200+TCT14420 TEST FOR A DUAL DEVICE
         BNZ   $RRTN1              READ NEXT CARD, CHECK FOR BLANK
         AGO   .URTN6
.URTN5   AIF   (&R(2) AND &R(3)).URTN6                              2+3
         B     $RRTN1              READ NEXT CARD, CHECK FOR BLANK
.URTN6   AIF   (&R(4) OR &R(2) AND &R(3) AND &R(5) AND &R(8)).URTN7
         TM    UCTSTAT,TCT2540     TEST FOR 2540 PUNCH
         BZ    USTART              IF NOT GET NEXT TANK
.URTN7   AIF   (&R(4)).URTN8                                          4
         $LOAD R8,UCTHOLD          PICK UP OLD TANK
         OI    UCTHOLD+&L-1,1      MAKE IT EMPTY
         $FREE $TANKPOL,R8,ENBL    FREE 2540 TANK
.URTN8   AIF   (NOT(&R(2) AND &R(3)) AND &R(4) AND &R(5) AND &R(8)).UR9
         B     USTART              GO BACK TO START OF PROCESSOR
.UR9     AIF   (NOT(&R(8) AND &R(2) AND &R(3)) OR &R(5)).URTN10
         AIF   (&UDEV(1) NE 2560).URTN10A
UERR     CIO   UBADPOC,UNSTACK     SELECT BAD POCKET
         B     UPUNCH              RETRY PUNCH
         AGO   .URTN10
.URTN10A ANOP
UERR     EQU   UPUNCH              ON ERROR REPUNCH THE CARD
.URTN10  AIF   (&R(2) AND &R(3) AND &R(8)).URTN11                 2+3+8
UERR     DS    0H                  PUNCH I/O ERROR ENTRY
.URTN11  AIF   (&R(2) AND &R(3) OR &R(5) OR &R(8)).URTN12     (2+3)*5*8
         TM    UCTSTAT,TCT25200+TCT14420+TCT1442 TEST FOR SPECIAL
         BZ    UPUNCH              IF NOT REPUNCH THE CARD
.URTN12  AIF   (&R(2) AND &R(3) AND &R(5) OR &R(8)).URTN13    (2+3+5)*8
         TM    UCTSTAT,TCT1442     TEST FOR SINGLE POCKET 1442
         BZ    UEDUAL              IF NOT SKIP 1442 ERROR ROUTINE
         AIF   (NOT(&R(2) AND &R(3))).URTN13
UEDUAL   EQU   UPUNCH              REPUNCH THE CARD
.URTN13  AIF   (&R(8)).URTN17
         $INTREQ U,PUN,PREVLOC=UPUNCH
.URTN17  AIF   (&R(2) AND &R(3) OR &R(5) OR NOT &R(8)).URTN14
         TM    UCTSTAT,TCT25200+TCT14420 TEST FOR DUAL READ/PUNCH
         BZ    UPUNCH              REPUNCH THE CARD IF NO
.URTN14  AIF   (&R(2) AND &R(3)).URTN15                             2+3
UEDUAL   DS    0H                  ERROR ON DUAL READ/PUNCH UNIT
         AIF   (&MACHINE EQ 20).URTN14A
         MVC   UCTHOLD,UCTCCW+4-&L SAVE BAD CARD POINTER
         MVI   UCTCCWCT+1,80       SET DATA LENGTH TO 80
UEDUALA  DS    0H
         $READ U,UCTTDTA1          READ A CARD FROM DUAL UNIT
         $CHECK U,URERR,URERR      CHECK TO MAKE SURE IN OK
         $LOAD R8,UCTHOLD          PICK UP DATA ADDRESS
         SH    R8,=Y(TANKDATA-TANKDSEC) POINT TO TANK
         CLC   UCTTDTA1(80),UCTTDTA2 CHECK FOR ALL BLANK CARD
         BE    UOUTPUT             IF SO GO PUNCH AGAIN
         AGO   .URTN14B
.URTN14A ANOP
UEDUALA  DS    0H
         $READ U,UCTTDTA1,OP=ROPCODE READ A CARD FROM DUAL UNIT
         $CHECK U,URERR,URERR,T=R  CHECK FOR IN OK
         CLC   UCTTDTA1(80),UCTTDTA2 CHECK FOR ALL BLANK CARD
         BE    UPUNCH              IF SO PUNCH AGAIN
.URTN14B ANOP
URERR    $INTREQ U,PUN,PREVLOC=UEDUALA WAIT FOR OPERATOR
.URTN15  AIF   (&NUMPUN EQ 1).URTN16
         DROP  TCTR                DROP BASE FOR NEXT PROCESSOR
.URTN16  ANOP
         $ENDPROC U                END OF PUNCH PROCESSOR
         AIF   (&MACHINE NE 20).URTNSKP
*
*        PUNCH PROCESSOR EQUATES
*
UCT      EQU   80                  LENGTH OF CARD
UCTRTN   EQU   $UCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.URTNSKP ANOP
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).WRTNSKP
 TITLE '$ W R T N 1  -- CONSOLE PROCESSOR'
&A       SETA  0
*
*        BASE REGISTER ASSIGNMENT
*
         USING TANKDSEC,R8
         AIF   (&CONSOLE LT 2).WSK1
         USING WCTDSECT,TCTR
.WSK1    ANOP
         AIF   (&PRTCONS EQ 0).WSK12
         AIF   (&CONSOLE NE 0).WSK15
$WRTN1   NULL
.WSK15   ANOP
*
*        ROUTINE TO PREPARE MESSAGES FOR PRINTING ON 1403-1443-2203
*
WPLOOP   DS    0H                  ENTRY POINT TO PASS MSG TO PRINTER
         AIF   (&NUMPRT LT 2).WSK14
         $LA   R10,$PCOM1+2        PICK UP PRINTER 1 TCT
         USING PCTDSECT,R10
.WSK14   ANOP
         CLI   WCTTNKCT,0          TEST FOR MESSAGES
         BE    WPTLOG              IF NONE TEST FOR ERROR LOG
WPLOG    TM    PCTSTAT,TCTPRTSW    TEST FOR PRINTER AVAILIABLE
         BZ    WPCONS              LOOK FOR PRINTING MESSAGES
WPSCANA  $LA   R9,PCTTANK          PICK UP PRINTER TANK Q ADDR
WPSCAN   $LOAD R8,0(0,R9)          PICK UP NEXT OR ZERO
         CH    R8,=H'0'            TEST FOR END OF Q
         BE    WPINSERT            INSERT CONSOLE TANKS BEHIND
         CLI   TANKRCB,&WRCB(1)    IS THIS A MESSAGE RCB
         BNE   WPINSERT            IF NOT INSERT CONSOLE TANKS HERE
         $LTR  R9,R8               PULL SCAN POINTER UP ONE
         B     WPSCAN              SCAN SOME MORE
WPINSERT MVC   0(&L,R9),WCTTANK    INSERT CONSOLE TANK
         $LOAD R9,0(0,R9)          MOVE TO INSERTED TANK
         MVI   TANKSRCB-TANKDSEC(R9),X'81' INSERT SPACE 1 AFTER
WPFORCE  MVC   WCTTANK,0(R9)       MAKE NEXT HEAD OF CONSOLE CHAIN
         $STO  R8,0(0,R9)          PUT PRINTER CHAIN ON BEHIND
         LH    R14,PCTTNKLM        PICK UP PRINTER TANK COUNT
         AH    R14,=H'1'           ADD 1
         STH   R14,PCTTNKLM        SAVE IT
         LH    R14,WCTTNKLM        PICK UP CONSOLE COUNT
         AH    R14,=H'-1'          SUB 1
         STH   R14,WCTTNKLM        SAVE IT
         CLI   WCTTNKCT,0          TEST FOR MORE
         BNE   WPINSERT            INSERT SOME MORE
         OI    $PCOMM1+1,X'F0'     LET PRINTER PRINT
         OI    WCTSTAT,TCTACT      TURN ON ACTIVITY INDICATOR
         B     $WCOMM1+4           WAIT ONE TIME AROUND
         AIF   (&PRTCONS NE 2).WSK12A
WPCONS   $GETTNK W,R8,R9,EMPTY=WPCLOS GET THE TANK
         $FREE $TANKPOL,R8,ENBL    FREE THE TANK
         B     WPCONS              LOOP BACK FOR MORE
         AGO   .WSK12B
.WSK12A  ANOP
WPCONS   CLI   WCTTNKCT,&WTLM(1)   DO WE HAVE OUR LIMIT
         BL    WPCLOS              IF NOT WE ARE OK
         $LOAD R9,WCTTANK          PICK UP FIRST TANK
         NI    TANKSRCB-TANKDSEC(R9),X'7F' FRC EJECT BEFORE PRT    @N30
         $LOAD R8,PCTTANK          PICK UP PRINTER TANK Q
         $STO  R9,PCTTANK          CHAIN FIRST TANK ONTO PRINTER
         OI    PCTSTAT,TCTPRTSW    SET PRINTER AVAILABLE
         B     WPFORCE             FORCE MESSAGES OUT
.WSK12B  ANOP
WPCLOS   $CLOSE W                  WAIT AWHILE
WPTLOG   CLC   $LOGOUT,$LOGLAST    ANY ERROR MESSAGES
         BE    WPCLOS              IF NOT CLOSE GATE AND LOOP
         $DCHAIN $TANKPOL,R8,ENBL,EMPTY=$WCOMM1+4 GET A TANK
         $FREE WCTTANK,R8,ENBL     PUT TANK INTO CONSOLE Q
         MVI   WCTTNKCT,1          SET A VALUE OF 1 IN COUNT
         AIF   (&CONSOLE EQ 0).WSK2
         B     WLOGB               PREPARE LOG INFO
.WSK12   ANOP
$WRTN1   NULL
WINIT    DS    0H                  CONSOLE LOOP ENTRY POINT
WTESTREL TM    WCTSTAT,TCTREL      DO WE HAVE POSSIBLE INTERLOCK
         BO    WPUT                IF SO ATTEMPT TO RELEASE IT
         NI    $WCOMM1+1,X'0F'     CLOSE THE COMMUTATOR GATE
         TM    WCTSTAT,TCTREQ      DO WE HAVE OPERATOR REQUEST
         BO    WREADOP             IF SO READ FROM CONSOLE
WTANKTST CLI   WCTTNKCT,0          TEST FOR TANK
         BNE   WGETTANK            IF WE HAVE ONE GET IT
         $DELAY W,TYPE=SETUP,PREVLOC=WINIT SET UP FOR WAIT
         CLC   $LOGOUT,$LOGLAST    TEST FOR ERRORS TO LOG
         BE    WCTRTN              WAIT ONE TIME AROUND COMMUTATOR
         AIF   (&MACHINE NE 20).WSK2
         $OPEN W,R9                OPEN THE GATE WE HAVE WORK
.WSK2    ANOP
WLOGB    $SSM  0                   DISABLE INTERRUPTS
         $LOAD R9,$LOGOUT          PICK UP LOG INFO POINTER
WLOGGA   $AA   R9,4                INCREMENT TO NEXT ENTRY
         $CA   R9,$LOGEND          TEST FOR END OF TABLE
         BL    WLOG                IF NOT PREPARE TO TYPE
         BH    WLOGG               BR IF $LOG CHASED US OUT OF TABLE
         $LA   R9,$LOGTAB          PICK UP START OF TABLE
WLOG     $STO  R9,$LOGOUT          SAVE POINTER FOR NEXT TIME
         MVC   WBUFFP,0(R9)        MOVE LOG INFO TO WORK AREA
         $SSM  FF                  ENABLE INTERRUPTS
         AIF   (&ERRTXTL EQ 0).WSK3
         $LMHA R9,R8,WPREFIX,=Y(LOGEND-LOGDSECT) FIND ENTRY
         $AA   R9,$ERRTAB          ADD TO ENTRY THE TABLE ORIGIN
.WSK3    ANOP
         UNPK  WBUFF,WBUFFP(5)     SPREAD THE HEX DIGITS
         TR    WBUFF(8),WEBCDIC    CONVERT TO EBCDIC
         AIF   (&ERRTXTL EQ 0).WSK4
         USING LOGDSECT,R9
         MVC   WTEXT,LOGTEXT       MOVE IN TEXT PORTION OF ERROR MSG
         DROP  R9
         MVI   WBUFF+8,C' '        BLANK OUT IN FRONT OF TEXT
.WSK4    ANOP
         AIF   (&PRTCONS EQ 0 OR &CONSOLE EQ 0).WSK13
* CHANGE FOLLOWING TO NOP TO LOG ON PRINTER, CHANGE COMMUTATOR/WTCT
*              TO ENTER AT WPLOOP
         B     WLOGC
.WSK13   AIF   (&PRTCONS EQ 0).WSK11
         $LOAD R8,WCTTANK
         MVC   TANKDATA(8+&ERRTXTL),WBUFF MOVE MESSAGE TO TANK
         MVC   TANKRCB(4),WLOGHD   INSERT RCB,SRCB,AND COUNT
         B     WPLOG
WLOGHD   DC    AL1(&WRCB(1)),X'80',AL2(8+&ERRTXTL) RCB,SRCB,COUNT
.WSK11   AIF   (&CONSOLE EQ 0).WSKLOCA
WLOGC    DS    0H
         AIF   (&MACHINE EQ 20).WSK5
         MVI   WCTCCWCT+1,8+&ERRTXTL INSERT COUNT IN CCW
WLOGERR  $WRITE W,WBUFF            WRITE ERROR MESSAGE
         AGO   .WSK6
.WSK5    ANOP
WLOGERR  $DELAY W,TYPE=SETUP,TIME=SHORT PREPARE FOR WAITING
         XIO   WBUFF(WOPCODE+1),8+&ERRTXTL TYPE THE MESSAGE
         BC    7,$WCOMM1+4         WAIT FOR START
.WSK6    ANOP
         $CHECK W                  CHECK FOR I/O COMPLETE,IGNORE ERRORS
         B     WINIT               LOOP TO START OF PROCESSOR
WGETTANK $GETTNK W,R8,R9,EMPTY=WAIT GET A TANK
WTYPE    $WRITE W,TANKDATA,TANKDSEC,CTADDR=TANKCNT TYPE MESSAGE
         $CHECK W                  CHECK FOR COMPLETE, IGNORE ERRORS
         $LOAD R8,WCTCCW+4-&L      PICK I/O AREA FROM COMMAND
         SH    R8,=Y(TANKDATA-TANKDSEC) LOCATE START OF TANK
         $FREE $TANKPOL,R8,ENBL    FREE TANK
         B     WINIT               GO BACK FOR MORE WORK
WREADOP  NI    WCTSTAT,255-TCTREQ  REMOVE THE REQUEST BIT
         AIF   (&MACHINE NE 20).WSK7
         $OPEN W,R9                OPEN OUR GATE WE HAVE WORK
.WSK7    ANOP
         MVC   WCTTCT1,=Y(&WTOSIZE) SET TANK DATA LENGTH
WOVER    MVI   WCTTDTA1,C' '       INSERT BLANK IN AREA
         MVC   WCTTDTA1+1(&WTOSIZE-1),WCTTDTA1 FILL THE AREA
         AIF   (&MACHINE EQ 20).WSK8
         MVI   WCTCCWCT+1,&WTOSIZE INSERT FULL SIZE COUNT IN CCW
.WSK8    ANOP
         $READ W,WCTTDTA1,OP=WREAD READ FROM CONSOLE
         AIF   (&MACHINE EQ 20).WSK9
         $CHECK W                  WAIT FOR COMPLETE
         BC    7,WOVER             IF ERROR OR CANCEL KEY DO OVER
         AGO   .WSK9A
.WSK9    ANOP
         $CHECK W,WOVER            IF ERROR OR CANCEL KEY DO OVER
.WSK9A   ANOP
         AIF   (&LOCCOM EQ 0).WSKLOC
         CLI   WCTTDTA1,C'.'       TEST FOR LOCAL COMMAND
         BE    WLOCALW             IF SO PROCESS
.WSKLOC  ANOP
$WOFF    NOP   WTANKTST            CHECK FOR OUTPUT
WPUT     $PUT  W,WCTTANK1          SEND IT TO HASP
         B     WTANKTST            CHECK FOR OUTPUT
         AIF   (&LOCCOM EQ 0).WSKLOCA
WLOCALW  MVC   $COMMAND,WCTTDTA1+1 MOVE COMMAND TO WORK AREA
         BAS   R14,$WLOCAL         PROCESS LOCAL COMMAND
         B     WTANKTST            CHECK FOR OUTPUT
.WSKLOCA ANOP
WLOGG    $LOAD R9,$LOGLAST         PICK UP LAST LOGGED
         B     WLOGGA              JUMP BACK IN AHEAD OF $LOG
*
*        ERROR MESSAGE WORK AREAS
*
WPREFIX  DS    0H
         DC    X'00'               PADDING FOR ID OFFSET
WBUFFP   DC    CL4' '              WORK AREA FOR ERROR MSG
         DC    X'0F'               POSITIVE DECIMAL ZERO
WBUFF    DC    CL9' '              EBCDIC VERSION OF ERROR
WTEXT    DS    CL(&ERRTXTL-1)      LENGTH OF TEXT OF MESSAGE
WEBCDIC  EQU   *-X'F0'             SHORT TRANSLATE TABLE
         DC    C'0123456789ABCDEF' FOR HEX DIGITS TO EBCDIC
         $ENDPROC W                END OF CONSOLE PROCESSOR
         AIF   (&MACHINE NE 20 OR &CONSOLE EQ 0).WRTNSKP
WCT      EQU   &WTOSIZE            LENGTH OF CONSOLE LINE
WCTCCW   EQU   WTYPE+6             LOCATION OF XIO INSTRUCTION
WCTRTN   EQU   $WCOMM1+4           LOCATION OF NEXT COMMUTATOR ENTRY
.WRTNSKP ANOP
         AIF   (&LOCCOM EQ 0).WXX1
 TITLE 'L O C A L   C O M M A N D   P R O C E S S I N G'
***********************************************************************
*                                                                     *
*        COMMANDS ARE OF THE FORM                                     *
*              .VP1...PN    WHERE  . IS ID IN FIRST POSITION          *
*                                  V= VERB, SINGLE CHARACTER IN POS 2 *
*                                  P1...PN ARE PARAMETERS FOR COMMAND *
*                                       PROCESSORS. (NO BLANKS)       *
*                                                                     *
*        DATA AREAS                                                   *
*   $VERBTAB   VERB TABLE LIST OF SINGLE CHARACTER COMMAND VERBS      *
*              APPEARING IN COLLATING SEQUENCE, ENDING WITH X'FF'     *
*   $LOCCOM    LOCAL COMMAND PROCESSOR LIST, ENTRY POINT OF COMMAND   *
*              PROCESSOR TO INITIALLY HANDLE THE COMMAND.             *
*   $COMMAND   WORK AREA CONTAINING VERB AND PARAMETERS.              *
*                                                                     *
***********************************************************************
$VERBTAB DS    0C                  VERB TABLE
         DC    C'S'                START COMMAND
         DC    X'FF'               END OF TABLE
$LOCCOM  DS    0F                  LOCAL COMMAND PROCESSOR POINTERS
         $ACON WXS                 START COMMAND
$COMMAND DC    CL4' '              WORK AREA FOR COMMAND PROCESSORS
WXXSAV   $ACON 0                   I/O PROCESSOR RETURN POINT
         USING TCTDSECT,R15
$WLOCAL  DS    0H                  ENTRY TO FIND COMMAND'S PROCESSOR
         $STO  R14,WXXSAV          SAVE RETURN ADDRESS
         OI    $COMMAND,C' '       SET EXPECTED CHAR UPPER CASE
         OI    $COMMAND+1,C' '     SET EXPECTED CHAR UPPER CASE
         $LA   R14,$VERBTAB        PICK UP COMMAND VERB TABLE
WXXLOOP  CLC   0(1,R14),$COMMAND   LOOK FOR MATCHING VERB
         BE    WXXLOC              FOUND MATCH IF EQUAL
         BH    WXXRET              NOT IN TABLE IF HI (IGNORE)
         $AA   R14,1               BUMP TO NEXT ENTRY
         B     WXXLOOP             LOOK AGAIN
WXXRET   $LOAD R14,WXXSAV          RETURN TO USER
         BR    R14                 AT NSI
WXXLOC   $SA   R14,$VERBTAB        CREATE OFFSET
         AIF   (&HICORE GT 32).WXX2
         AR    R14,R14             DOUBLE IT
         AGO   .WXX2A
.WXX2    ANOP
         SLL   R14,2               CREATE ADCON OFFSET
.WXX2A   ANOP
         $AA   R14,$LOCCOM         ADD ORIGIN OF COMMAND TABLE
         $LOAD R14,0(0,R14)        PICK UP COMMAND PROCESSOR ENTRY
         BR    R14                 GO TO COMMAND PROCESSOR
         EJECT
*
*        AIDS FOR COMMAND PROCESSORS
*
*        FIND CORRESPONDING TCT -- ID IN POS 2 OF $COMMAND AREA
WXXFIND  DS    0H
         $LA   R15,$TCT1           PICK UP TCT CHAIN
WXXFL    CLC   TCTID,$COMMAND+1    CHECK FOR MATCH
         BE    4(0,R14)            RETURN IF FOUND
         $LOAD R15,TCTNEXT         PICK UP NEXT TCT
         $LTR  R15,R15             TEST FOR END OF CHAIN
         BNE   WXXFL               LOOP BACK IF NOT END
         BR    R14                 ERROR RETURN
*
*        COMMAND PROCESSORS        COMMANDS THAT DO NOT ISSUE WAITS
*
*                                  FIRST LEVEL COMMAND PROCESSORS
WXS      DS    0H                  START COMMAND
         BAS   R14,WXXFIND         FIND TCT
         B     WXXRET              RETURN TCT NOT FOUND
         NI    TCTSTAT,255-TCTSTOP START THE TCT
         $LOAD R15,TCTCOM          PICK UP COMMUTATOR ENTRY
         OI    1(R15),X'F0'        OPEN THE GATE
         B     WXXRET              RETURN
*
*        SECOND LEVEL COMMAND PROCESSORS REQUIRING COMMUTATOR GATES
*                                  MUST HAVE A CORRESPONDING FIRST
*                                  LEVEL COMMAND PROCESSOR
         DROP  R15
.WXX1    ANOP
         PRINT GEN
 TITLE '$ P U T   --  TPPUT INTERFACE ROUTINE'
*
*        $PUT  ROUTINE             INTERFACE WITH $TPPUT
*
&A       SETA  0
OXDUM    DSECT                     SYMBOLIC AID FOR PUT ROUTINE
         AIF   (&MACHINE EQ 20).OXB
OXGDRET  DS    H                   RETURN ADDR TO USER
         AGO   .OXAB
.OXB     ANOP
OXTNK    DS    H                   TANK ADDRESS
OXTCT    DS    H                   TCT ADDRESS
OXBADRET DS    2H                  WAIT RETURN
OXGDRET  DS    2H                  RETURN ADDR TO USER
.OXAB    ANOP
HASPRTP  CSECT
         USING OXDUM,R14
         USING TANKDSEC,R8
         AIF   (&MACHINE EQ 20).OX1
*        R8 POINTS TO TANK, R14 POINTS TO RETURN, TCTR POINTS TO TCT
         USING TCTDSECT,TCTR
$PUT     NULL
         $STO  R14,TCTSAV1         SAVE RETURN ADDRESS
OXSAV    EQU   TCTSAV1             LOCAL SYMBOL FOR SAVE AREA
         $STO  R8,TCTCCW+4-&L      SAVE TANK ADDRESS
         AGO   .OXA1
.OX1     ANOP
*        R14 POINTS TO USER CALLING SEQ WITH TANK AND TCT ADDRESS
         USING TCTDSECT,R9
$PUT     NULL
         AH    R14,=H'4'           SKIP OVER INITIAL BAS INST
         STH   R14,OXSAV           SAVE RETURN ADDRESS (OFFSET)
         LH    R8,OXTNK            PICK UP ADDRESS OF TANK
         LH    R9,OXTCT            PICK UP ADDRESS OF TCT
.OXA1    AIF   (&CONSOLE EQ 0).OX2
OXLOOP   TM    WCTSTAT,TCTREL      IS INTERLOCK RELEASE ON
         BZ    OXPUT               IF NOT DO NORMAL $TPPUT
         $LA   R8,WCTTANK1         PICK UP CONSOLE TANK ADDRESS
         BAS   R14,$TPREPUT        ATTEMPT TO SEND TO HASP
         $LOAD R14,OXSAV           PICK UP RETURN ADDR
         AIF   (&MACHINE NE 20).OX3
         LH    R9,OXTCT            PICK UP TCT ADDR
.OX3     ANOP
         BNE   OXFINTST            IF TANK OK TEST FOR MORE WORK
         TM    TCTSTAT,TCT1052     IF NOT OK TEST FOR USER ID
         BO    OXGDRET             IF CONSOLE RETURN
         AIF   (&MACHINE EQ 20).OX4
         $DELAY O,T,PREVLOC=OXLOOP IF NOT WAIT AND TRY AGAIN
         AGO   .OXA4
.OX4     ANOP
         B     OXNORMA             IF NOT THEN FORGET IT PUT USERS
.OXA4    ANOP
OXFINTST NI    WCTSTAT,255-TCTREL  RESET INTERLOCK RELEASE
         TM    TCTSTAT,TCT1052     CHECK USER ID
         BO    OXGDRET             IF CONSOLE RETURN
         AIF   (&MACHINE EQ 20).OX5
         $LOAD R8,TCTCCW+4-&L      PICK UP TANK
         AGO   .OXA5
.OX5     ANOP
OXNORMA  LH    R8,OXTNK            PICK UP TANK
.OXA5    ANOP
.OX2     ANOP
OXPUT    BAS   R14,$TPPUT          SUBMIT TANK FOR TRANSMISSION
         $LOAD R14,OXSAV           RESTORE RETURN POINTER
         AIF   (&MACHINE NE 20).OX7
         LH    R9,OXTCT            PICK UP TCT ADDR
.OX7     ANOP
         BNE   OXGDRET             IF TANK WENT OK THEN RETURN
         AIF   (&CONSOLE EQ 0).OX8
         TM    TCTSTAT,TCT1052     IF NOT TEST FOR CONSOLE
         BZ    OXWAIT              IF NOT CONSOLE WAIT
         OI    WCTSTAT,TCTREL      SET INTERLOCK RELEASE INDICATOR
         B     OXGDRET             RETURN TO USER
OXWAIT   DS    0H                  WAIT TO RESUBMIT TANK
.OX8     AIF   (&MACHINE EQ 20).OX9
         $DELAY O,T                WAIT ONE TIME AROUND COMMUTATOR
         $LOAD R8,TCTCCW+4-&L      PICK UP TANK ADDRESS
         BAL   R14,$TPREPUT        RESUBMIT TANK FOR TRANSMISSION
         $LOAD R14,OXSAV           PICK UP USER RETURN POINT
         BE    TCTRTN              IF IT DIDN'T GO WAIT AGAIN
         AGO   .OXA9
.OX9     ANOP
         B     OXBADRET            WAIT ONE TIME AROUND COMMUTATOR
OXSAV    DC    H'0'                SAVE AREA
$PUTA    STH   R14,OXSAV           REENTRY AFTER A WAIT
         LH    R8,OXTNK            PICK UP TANK ADDR
         BAS   R14,$TPREPUT        RESUBMIT TANK FOR TRANSMISSION
         LH    R14,OXSAV           PICK UP RETURN POINTER
         BE    OXBADRET            IF IT DIDN'T GO WAIT AGAIN
.OXA9    ANOP
         B     OXGDRET             RETURN
         DROP  R14,R8
         AIF   (&MACHINE NE 20).OXC
         DROP  R9
.OXC     ANOP
         AIF   (&MACHINE EQ 20).OX50
 TITLE '$ G E T T N K  --  $ C L O S T C T  -- PROCESSOR ASSISTS'
*
*        $GETTNK                   ROUTINE TO GET A TANK FOR PROCESSOR
*
$GETTNK  NULL
         $STO  R14,TCTSAV1         SAVE USER REG FOR POSSIBLE WAIT
         $DELAY O,T,TYPE=SETUP     SET REENTRY FOR POSSIBLE WAIT
         $DCHAIN TCTTANK,R8,ENBL,EMPTY=$CLOSTCT GET TANK OUT OF Q
         $TCTPOST T,R9             POST COMPLETION
         $LOAD R14,TCTSAV1         PICK UP USER
         BR    R14                 RETURN TO HIM
*
*        $CLOSTCT                  ROUTINE TO CLOSE GATE AND RETURN
*
$CLOSTCT NULL
         $LOAD R9,TCTCOM           PICK UP COMMUTATOR
         NI    1(R9),X'0F'         CLOSE GATE
         B     4(R9)               RETURN TO COMMUTATOR
.OX50    ANOP
         $ENDPROC O                END OF PUT ROUTINE
 TITLE 'HRTP  $ L O G  --  LOG SUBROUTINE'
         USING LOGDSECT,R15
$LOG     NULL
         $STO  R14,LOG14SAV        SAVE R14
         $STO  R15,LOGRTN          STORE RTN REG
         LH    R15,0(0,R15)        PICK UP ERROR ENTRY OFFSET
         $AA   R15,$ERRTAB         ADD ERROR TABLE ORIGIN
         LH    R14,LOGCOUNT        LOAD ERROR COUNT
         AH    R14,=H'1'           UP COUNT BY ONE
         STH   R14,LOGCOUNT        STORE NEW COUNT
         AIF   (&TRACE EQ 0).LNOTRC
         $LOAD R14,$TRACUR         PICK UP CURRENT TRACE ADDR
         AH    R14,=H'4'           INCREMENT TO NEXT POSITION
         CH    R14,$TRAEND         IS THIS THE END OF THE TABLE
         BNH   LOGADD              BR LOW OR EQUAL TO ADD ENTRY
         $LOAD R14,$TRASTRT        LOAD ADDR OF FIRST ENTRY
LOGADD   NULL
         MVC   0(1,R14),LOGID      MOVE LOG ID TO TRACE TABLE
         MVC   1(3,R14),$LOGINFO   MOVE IN 3 BYTES OF INFORMATION
         $STO  R14,$TRACUR         UP DATE CURRENT POINTER
.LNOTRC  AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).LOGNOT
         CLI   LOGCLASS,&LOGCLAS   TEST FOR LOGABLE ERROR
         BL    LRTN                SKIP ADDING TO LOG TAB IF NOT
         $LOAD R14,$LOGLAST        GET ADDRESS OF LAST ENTRY
         $AA   R14,4               INCREMENT TO NEXT ENTRY
         $CA   R14,$LOGEND         ARE WE AT END OF TABLE
         BL    LOGOUT              IF NOT LOG INTO THE TABLE
         $LA   R14,$LOGTAB         IF SO RESET TO BEGINNING OF TABLE
LOGOUT   $STO  R14,$LOGLAST        SAVE ENTRY
         MVC   0(1,R14),LOGID      BUILD MESSAGE TO BE LOGGED,ID
         MVC   1(3,R14),$LOGINFO   HEX BYTES, FORGET TEXT
         OI    $WCOMM1+1,X'F0'     OPEN THE CONSOLE GATE
         $CA   R14,$LOGOUT         HAVE WE LAPPED CONSOLE LOGGING
         BNE   LRTN                IF NOT RETURN
         $AA   R14,4               IF SO CHASE IT AHEAD 1 ENTRY
         $STO  R14,$LOGOUT         SAVE IT FOR CONSOLE
.LOGNOT  ANOP
LRTN     $LOAD R14,LOG14SAV        RESTORE R14
         $LOAD R15,LOGRTN          PICK UP CALLER
         MVC   $LOGINFO,=F'0'      ZERO OUT LOG INFO FOR NEXT LOG
         B     2(0,R15)            RETURN
LOG14SAV $ACON
LOGRTN   $ACON
$LOGCLAS EQU   &LOGCLAS
         DROP  R15
 TITLE '$ T P P U T  -- BUILDS BUFFERS FOR TRANSMISSION TO HASP '
*
*  ENTRY - $TPPUT
*                 REGISTERS - R8=RECORD TANK 2(R8)=RCB,3(R8)=SRCB
*                            R14=RETURN ADDR ,CC=0 - RECORD NOT TAKEN
*                                             CC.NE.0-RECORD ACCEPTED
*                            R15 IS CONSIDERED VOLITILE
*
*
$TPPUT   NULL
        $TRACE SSM=YES
         $STO  R14,OSAVR14         SAVE RETURN
         STH   R10,OSAVR10
         STH   R9,OSAVR9
        $STO   R8,OINADD           SAVE INPUT TANK ADDR
         LH    R15,=H'1'           CONSTANT FOR SPEED
        $LOAD  R10,OINADD          COMPRESSION WORK AREA
         AH    R10,=Y(TANKRCB-TANKDSEC) SKIP TO CTL BYTES
         USING TANKDSEC,R8         *
         LH    R9,TANKCNT          TANK DATA COUNT
         CH    R9,=H'0'            IS THIS A NULL RECORD
         BE    OEOINPUT            BR IF YES TO ADD TO BUFFER
         AIF   (&CMPTYPE LE 1).ONOCOMP TEST NONE OR TRAILING COMP
         AR    R9,R8               INCLUDE TANK ADDR
        $STO   R9,OINEND           TO SAFE STORAGE
         CLI   OTS(R8),2           IS THIS A TEXT CARD
         BNE   OGOA                BR IF NO
*                   SKIP ATTEMPTING TO COMPRESS A TEXT CARD
         LH    R9,TANKCNT          INPUT COUNT
        $LTR   R11,R8              INPUT ADDR
         AR    R8,R9               END OF RECORD
         AH    R9,OD200            COUNT FORMAT
         B     OSQUEEZE            GO PROCESS RECORD
OGOA     NULL
         MVI   OTS(R9),0           SETUP ENDING CHARACTER
         AIF   (&CMPTYPE EQ 2).ONB8
         CLI   OTS-1(R9),0         DOES ENDING MATCH LAST DATA CHAR
         BNE   *+8                 BR IF NOT
         MVI   OTS(R9),255         YES...USE ANOTHER
.ONB8    ANOP
         MVC   OTS+1(&CCT-1,R9),OTS(R9) PROPAGATE FOR DUPLICATION
OGO      NULL
        $LA    R14,OGO1            LOAD FOR SPEED
        $LA    R13,OSQUEEZE        LOAD FOR SPEED
         LH    R9,OD200            INITIAL COUNTER FOR MVC
        $LTR   R11,R8              INPUT AREA TO R11
OGO1     NULL
         AIF   (&CMPTYPE NE 2).ONB1
         CLI   OTS+&CCT-1(R8),64   IS LOOK-AHEAD A BLANK
         BNE   OSKIPUP             BR IF NO
.ONB1    ANOP
         CLC   OTS(&CCT-1,R8),OTS+1(R8) CHECK FOR COMPRESSABILITY
         BCR   8,R13               BR IF COMPRESSABLE (TO OSQUEEZE)
         AR    R8,R15              UP DATA PTR
         AR    R9,R15              AND CHAR COUNT
         BR    R14                 CONTINUE (TO OGO1)
         AIF   (&CMPTYPE NE 2).ONB2
OSKIPUP  NULL  *                   SKIP &CCT CHARACTERS
         AH    R8,=Y(&CCT)         ON INPUT
         AH    R9,=Y(&CCT)         BUT COUNT IT
         CH    R8,OINEND           IS THIS EOD
         BCR   4,R14               BR IF NO
         SH    R8,OINEND           CALCULATE OVERSHOOT
         SR    R9,R8               ADJUST STRING COUNT
        $LOAD  R8,OINEND           RESET FOR TERMINATION
*              FALL THROUGH TO OSQUEEZE
.ONB2    ANOP
*
* OSQUEEZE - &CCT IDENTICAL CHARACTERS FOUND
*
*
OSQUEEZE NULL                      *
         CH    R9,OD200            IS A CHARACTER STRING ACTIVE
         BE    OCOMPTST            BR IF NO TO COMPRESS
         CH    R9,OD263            DOES STRING EXCEED SCB
         BH    OBIGMOVE            BR IF YES
         STH   R9,*+4              SET MOVE AND COUNT
         MVC   3(*-*,R10),OTS(R11) MOVE CHAR STRING (+1)
         MVC   2(1,R10),*-5        SET SCB COUNT
         OI    2(R10),X'C0'        SET SCB ID BITS
         SH    R9,OD200            REDUCE TO ACTUAL COUNT
         AR    R10,R9              FIX OUTPUT POINTER
         AR    R10,R15             COUNT SCB
OCOMPTST NULL  *                   TEST FOR EOI
         CH    R8,OINEND           ARE WE DONE...
         BNL   OEOINPUT            BR IF YES
OCOMP    NULL
        $LA    R14,OCOMP1          FOR LOOP SPEED
        $LA    R13,OCMPSTOP        FOR LOOP SPEED
         LH    R9,=Y(&CCT)         START COMPRESSION COUNTER
OCOMP1   NULL  *                   CONTINUE COMPRESSION TESTING
         AIF   (&CMPTYPE NE 2).ONB3
         CLI   &CCT+OTS(R8),64     IS NEXT A BLANK
         AGO   .ONB4               BLANKS ONLY
.ONB3    ANOP
         CLC   (&CCT+OTS-1)(1,R8),(&CCT+OTS)(R8) DOES MATCH CONTINUE
.ONB4    ANOP
         BCR   7,R13               BR IF NO (TO CMPSTOP)
         AR    R9,R15              ANOTHER MATCH... COUNT IT
         AR    R8,R15              UP TO NEXT CHAR
         BR    R14                 CONTINUE (TO OCOMP1)
OCMPSTOP NULL  *                   IDENTICAL STRING ENDED
         CH    R9,=H'31'           DOES IT EXCEED SCB...
         BH    OBIGPROP            BR IF YES
         STH   R9,$TEMP            TO TEMPORARY STORAGE
         OI    $TEMP+1,X'80'       SET SCB ALWAYS BIT
         MVC   2(1,R10),$TEMP+1    SET SCB
         AIF   (&CMPTYPE EQ 2).ONB5
         CLI   (&CCT+OTS-1)(R8),C' ' ARE WE SQUEEZING BLANKS
         BE    OBLANK              BR IF YES
         MVC   3(1,R10),(&CCT+OTS-1)(R8) SET DUPLICATION CHAR
         OI    2(R10),X'20'        SHOW NON-BLANK DUPLICATION
         AR    R10,R15             SKIP SAMPLE CHAR
.ONB5    ANOP
OBLANK   NULL
         AR    R10,R15             COUNT SCB
         AH    R8,=Y(&CCT)         COUNT INPUT FIELD
         B     OGO                 AND CONTINUE RECORD
OBIGPROP NULL  *                   DUPLICATION COUNT EXCEEDS SCB
         MVI   2(R10),X'9F'        SHOW MAX SCB
         AIF   (&CMPTYPE EQ 2).ONB6
         CLI   (&CCT+OTS-1)(R8),C' ' IS THIS BLANKS
         BE    OBIGBLNK            BR IF YES
         MVC   3(1,R10),(&CCT+OTS-1)(R8) SET SAMPLE CHAR
         OI    2(R10),X'20'        SHOW NON-BLANK
         AR    R10,R15             COUNT SAMPLE
.ONB6    ANOP
OBIGBLNK NULL  *                   EXCESSIVE COUNT BLANKS
         AR    R10,R15             COUNT SCB
         SH    R9,=H'31'           ADJUST COUNT
         B     OCMPSTOP            AND TRY AGAIN
OBIGMOVE NULL                      STRING COUNT EXCEEDS SCB MAXIMUM
         MVC   3(63,R10),OTS(R11)  MOVE MAX
         MVI   2(R10),X'FF'        SET MAX SCB
         AH    R10,=H'64'          COUNT STRING AND SCB
         AH    R11,=H'63'          UPDATE FROM POINTER
         SH    R9,=H'63'           REDUCE COUNT
         B     OSQUEEZE            AND TRY AGAIN
         AGO   .OSKNCMP
.ONOCOMP ANOP
OBIGMOVE NULL  *                   MOVE MAXIMUM SCB COUNT
         AIF   (&CMPTYPE NE 1).ONB7
        $LA    R14,ONXTBLK         LOAD FOR SPEED
        $LA    R13,ONONBLK         LOAD FOR SPEED
         AR    R9,R8               R9 = EOR+1
ONXTBLK  NULL  *                   PROCESS NEXT CHARACTER
         CLI   OTS-1(R9),64        IS CHARACTER BLANK
         BCR   7,R13               BR IF NO (TO XNONBLK)
         SR    R9,R15              YES...REDUCE COUNT
         BR    R14                 AND CONTINUE (AT ONXTBLK)
ONONBLK  NULL  *                   LAST TRAILING BLANK OUT
         SR    R9,R8               REDUCE TO TRUE COUNT
         BP    *+8                 BR IF ANY NON-BLANKS
         LH    R9,=H'1'            RECORD IS ALL BLANK...FORCE 1
.ONB7    ANOP
         CH    R9,=H'63'           IS COUNT MAX OR GT
         BL    OENDER              BR IF NO
         MVC   3(63,R10),OTS(R8)   YES...MOVE MAX
         MVI   2(R10),255          SET MAX SCB
         AH    R10,=H'64'          COUNT ADDITION
         AH    R8,=H'63'           COUNT FROM
         SH    R9,=H'63'           REDUCE COUNT
         BZ    OEOINPUT            BR IF NO MORE
         B     OBIGMOVE            OTHERWISE CONTINUE
OENDER   NULL  *                   MOVE RESIDUAL COUNT
         STH   R9,$TEMP            SET COUNT
         MVC   *+7(1),$TEMP+1      AND PUT IN MVC
         MVC   3(*-*,R10),OTS(R8)  MOVE REST
         MVC   2(1,R10),*-5        SET SCB COUNT
         OI    2(R10),X'C0'        SET TYPE BITS
         AR    R10,R9              ADJUST OUTPUT POINTER
         AR    R10,R15             COUNT SCB
.OSKNCMP ANOP
*
*              END OF INPUT RECORD - TERMINATE AND ADD TO BUFFER
*
OEOINPUT MVI   2(R10),0            END-OF-RECORD SCB
         AR    R10,R15             COUNT IT
        $LOAD  R8,OINADD           STARTING ADDR OF COMPRESSED REC
         SR    R10,R8              REDUCE TO ACTUAL COUNT
         SH    R10,=Y(L'TANKCHN-2) COMPENSATE FOR FULL CHAIN WORD
         STH   R10,TANKCHN         SAVE COUNT IN TANK FOR $TPREPUT
OREENT   NULL                      RE-ENTRY POINT FROM $TPREPUT
        $LOAD  R9,OBUFPTR          GET ADDR OF ACTIVE BUFFER
         CH    R9,=H'0'            IS THERE ONE
         BE    OGETBUF             BR IF NO
OBUFOK   NULL  *                   VALID BUFFER
         CH    R10,OBUFCNT         WILL THIS RECORD FIT...
         BH    OBUFFULL            BR IF NO
         STH   R10,$TEMP           FOR STC
         MVC   *+7(1),$TEMP+1      SET IN MOVE
         MVC   0(*-*,R9),L'TANKCHN(R8) MOVE RECORD
         AR    R9,R10              UPDATE CURRENT PTR
        $STO   R9,OBUFPTR          AND RESET
         LH    R9,OBUFCNT          REMAINING COUNT
         SR    R9,R10              REDUCE BY THIS RECORD
         STH   R9,OBUFCNT          AND RESET
         CH    R10,=H'3'           WAS THIS A NULL RECORD
         BE    OFLUSH              BR IF YES TO WRITE BUFFER
         CLI   TANKRCB,&ORCB(1)    IS THIS OPER CMD TO HASP
         BE    OFLUSH              BR IF YES TO SEND BUFFER
ORETOK   NULL  *                   POSITIVE RETURN ENTRY
         OI    OFLSW+1,X'F0'       OPEN NORMAL GATE AND SET COND CODE
ORETURN  NULL                      RETURN--COND. CODE ALREADY SET
         LH    R8,OINADD           RESTORE TANK ADDR
         LH    R9,OSAVR9           RESTORE
         LH    R10,OSAVR10         RESTORE
         $LOAD R14,OSAVR14         GET RETURN
         BR    R14                 AND DO IT
OGETBUF  NULL  *
         SR    R9,R9               SET COND CODE
$TPPNONE NOP   ORETURN             SW SET BY COMSUP TO STOP BUFFERING
        $DCHAIN $BUFPOOL,R9        GET A BUFFER
         BZ    ORETURN             BR IF NONE (NOTE COND. CODE SET)
        $STO   R9,OACTBUF          SET BUFFER ADDR
         AH    R9,=Y(BUFDATA-BUFDSECT)  TO USABLE AREA
        $STO   R9,OBUFPTR          SET CURRENT POINTER
         LH    R14,$TPBFSIZ               SET                        R4
         SH    R14,=Y(BUFDATA+2-BUFSTART)  CURRENT                   R4
         STH   R14,OBUFCNT                  COUNT                    R4
         B     OBUFOK              AND GO FIT RECORD
*
*              BUFFER IS FULL--SEND IT TO HASP
*
OFLUSH   NULL  *                   ENTRY TO WRITE A PARTIAL BUFFER
         MVI   OFLSW+1,0           SET FLUSH SWITCH
OBUFFULL NULL
         $LOAD R9,OBUFPTR          GET CURRENT BUFFER POINTER
        $LOAD  R13,OACTBUF         FOR $EXTP
         USING BUFDSECT,R13
         MVI   0(R9),0             SET EOB
         SR    R9,R13              SUBTRACT SOB
         SH    R9,=Y(BUFSTART-BUFDSECT-1) MAKE COUNT ACTUAL
         STH   R9,BUFCOUNT         SET COUNT
         SR    R9,R9               ZERO
        $STO   R9,OBUFPTR          AND SHOW NO BUFFER
         BAS   R14,$EXTP           GO DO I/O
OFLSW    NOP   OGETBUF             FLUSH SWITCH
         B     ORETOK              JUST RETURN IF FLUSH
         DROP  R13
*
*              RE-ENTRY POINT IF ORIGINAL $TPPUT NOT ACCEPTED
*                R8=ORIGINAL TANK , R14= RETURN
$TPREPUT NULL
        $STO   R8,OINADD           SET FOR RESTORE
         $STO  R14,OSAVR14         RESET RETURN
         STH   R10,OSAVR10         SAVE
         STH   R9,OSAVR9           SAVE
         LH    R15,=H'1'           CONSTANT
         LH    R10,TANKCHN         COMPRESSED COUNT
         B     OREENT              ENTER FLOW
         EJECT
*
*
*
*
OSAVR9   $ACON 0                   REG SAVE
OSAVR10  $ACON 0                   REG SAVE
OSAVR14  $ACON 0                   RETURN ADDR SAVE
OINADD   $ACON 0                   INPUT TANK ADDR
OINEND   $ACON 0                   LAST VALID DATA BYTE IN TANK
OACTBUF  $ACON 0                   ACTIVE BUFFER ADDR
OBUFPTR  $ACON 0                   CURRENT POINTER IN BUFFER
OBUFCNT  DC    H'0'                REMAING SPACE COUNT IN BUFFER
OD200    DS    0H
         DC    X'D200'             CONSTANT FOR MVC COUNT
OD263    DS    0H
         DC    X'D23F'             MAX SCB CNT + MVC
OTS      EQU   TANKDATA-TANKDSEC
         DROP  R8                  DISCONTINUE TANK REG
 TITLE ' $ T P G E T  --DEBLOCKS BUFFERS RECEIVED FROM HASP  '
*
*
$TPGET   NULL  *                   ENTERED FROM COMUTATOR
         MVI   $TPGETCM+1,0        CLOSE COMMUTATOR
        $LA    R13,$TCT1           BEGINNING OF TCT'S
         USING TCTDSECT,R13        **
GTEST    NULL  *                   *
         TM    TCTSTAT,TCTACT      IS ACTION REQUESTED
         BO    GSERVICE            BR IF YES
GNEXTTCT NULL
        $LOAD  R13,TCTNEXT         TO NEXT TCT
        $LTR   R13,R13             IS THIS END
         BNZ   GTEST               BR IF NO
*
*              ALL TCT'S HAVE BEEN SERVICED...
*
GWAIT    B     $TPGETCM+4          EXIT
         EJECT
*
*              SERVICE TCT WITH ACTION BIT ON
*
GSERVICE NULL  *
         CLI   TCTBUFCT,0          ARE ANY BUFFERS AVAILABLE
         BNE   GTTANK              BR IF YES
GNOACT   NI    TCTSTAT,255-TCTACT  NO... TURN OFF ACTION
         B     GNEXTTCT            AND CONTINUE
GTTANK   NULL  *                   A BUFFER IS PRESENT
         CLC   TCTTNKCT,TCTTNKLM   ARE SUFFICIENT TANKS QUEUED
         BNL   GNOACT              BR IF YES
*                   A DECOMPRESSION IS REQUIRED
        $DCHAIN $TANKPOL,R10,NOENB GET A TANK
         BZ    GWAIT               BR IF NONE
         USING TANKDSEC,R10        *
        $LOAD  R8,TCTBUFER         CURRENT BUFFER
         AH    R8,(BUFCOUNT-BUFDSECT)(0,R8) TO DATA
        $STO   R10,GTANK           SAVE TANK ADDR.
         MVC   TANKRCB(2),0(R8)    MOVE RCB AND SRCB
         LH    R15,=H'1'           CONSTANT FOR SPEED
GDECOMP  NULL  *                   PROCESS AN SCB
         MVC   GSCB(1),2(R8)       SET SCB
         NI    GSCB,X'7F'          TURN OFF HIGH-BIT
         BZ    GENDREC             END-OF-RECORD
         TM    GSCB,X'40'          IS THIS A CHAR STRING...
         BZ    GPROP               BR IF NOT
         NI    GSCB,X'3F'          TURN OFF STRING BIT
         MVC   TANKDATA(*-*),3(R8) MOVE STRING (+1)
GSCB     EQU   *-5                 SCB AND COUNT
         LH    R9,GSCB-1           GET MOVE COUNT
         SH    R9,GD200            REMOVE MOVE
         AR    R8,R9               COUNT INPUT STRING
GCONT    AR    R10,R9              COUNT OUTPUT STRING
         AR    R8,R15              COUNT SCB
         B     GDECOMP             CONTINUE WITH RECORD
GPROP    NULL  *                   PROPGATION REQUIRED
         TM    GSCB,X'20'          IS THIS BLANKS...
         BZ    GBLANKS             BR IF YES
         NI    GSCB,X'1F'          NO .. REMOVE INDICATOR
         MVC   TANKDATA(1),3(R8)   SET SAMPLE CHARACTER
         MVC   GMOV+1(1),GSCB      SET COUNT
GMOV     MVC   TANKDATA+1(*-*),TANKDATA  PROPAGATE COUNT (+2)
         LH    R9,GSCB-1           PROPAGATION COUNT
         SH    R9,GD200            LESS MOVE
         AR    R8,R15              COUNT SAMPLE CHAR
         B     GCONT               AND ENTER FLOW
GBLANKS  NULL                      BLANK PROPAGATION REQUIRED
         MVI   TANKDATA,C' '       SET BLANK SAMPLE
         MVC   *+7(1),GSCB         SET COUNT
         MVC   TANKDATA+1(*-*),TANKDATA PROPAGATE BLANKS
         LH    R9,GSCB-1           GET MOVE COUNT
         SH    R9,GD200            LESS MVC
         B     GCONT               ENTER FLOW
GENDREC  NULL                      END OF LOGICAL RECORD
        $LOAD  R9,GTANK            TANK ADDR
         SR    R10,R9              FROM END PTR                       X
         DROP  R10
         USING TANKDSEC,R9
         STH   R10,TANKCNT         SET COUNT IN TANK
        $LA    R10,TCTTANK-TCTDSECT TANK CHAIN DISPLACEMENT
         AR    R10,R13             R10 = ABSOLUTE TANK CHAIN PTR
        $CHAIN (R10),R9,NOENB      ADD TO TANK QUEUE
         AH    R8,=H'3'            UPDATE TO NEXT RCB
         LH    R10,TCTTNKLM        LIMIT AND COUNT
         AR    R10,R15             INCREMENT COUNT
         STH   R10,TCTTNKLM        AND RESET
        $LOAD  R10,TCTCOM          GET COMMUTATOR ENTRY
         MVI   1(R10),X'F0'        OPEN PROCESSOR GATE
        $LOAD  R9,TCTBUFER         CURRENT BUFFER ADDR
         CLC   TCTRCB,0(R8)        IS NEXT RECORD SAME
         BNE   GSWITCH             BR IF NO
         SR    R8,R9               REDUCE TO DATA DISPLACEMENT
         $STO  R8,BUFCOUNT-BUFDSECT(0,R9) AND SAVE
         B     GTTANK              AND CONTINUE
GSWITCH  NULL  *                   DIFFERENT RCB ENCOUNTERED
         $SSM  0                   DISABLE INTERRUPTS
         MVC   TCTBUFER,0(R9)      UPDATE CHAIN
         $FREE $BUFPOOL,R9,NOENB   FREE THE BUFFER
         LH    R8,TCTBUFLM         BUFFER LIMIT AND COUNT
        $BCTR  R8,0                REDUCE COUNT
         STH   R8,TCTBUFLM         AND RESET
         CLC   TCTBUFCT,TCTBUFLM   IS ANOTHER BUFFER REQUIRED
         BNL   GENABLE             ENABLE INTERRUPTS
        $OC    $FCSOUT,TCTFCS      SHOW NEXT BUFFER PERMITTED
         MVI   $FCSHOT+1,X'F0'     SHOW FCS CHANGE
GENABLE  $SSM  FF                  ALLOW INTERRUPTS
         B     GSERVICE            AND CONTINUE
GTANK    $ACON 0                   TANK ADDR
GD200    EQU   OD200               SHARE CONSTANT
         DROP  R9                  DISCONTINUE TANK REG
 TITLE 'C O M S U P  --  $TPOPEN (OBTAINS PERMISSION TO BEGIN SENDING)'
$TPOPEN  NULL  *
        $TRACE SSM=YES
        $STO   R14,TSAVA           SAVE CALLER'S
        $STO   R8,TSAVB             REGS
         MVC   TTANK+TANKSRCB-TANKDSEC(1),TANKRCB-TANKDSEC(R8) SET FCN
        $LOAD  R8,TANKCON          FOR $TPPUT
         BAS   R14,$TPPUT          GO PUT RECORD
        $LOAD  R8,TSAVB            CALLER'S
        $LOAD  R14,TSAVA           REGS
         BR    R14                 RETURN TO CALLER
*                                  DUMMY TANK
TTANK   $ACON  0                   CHAIN
         DC    X'90'               RCB FOR FUNCTION CTL RECORD
         DC    X'00'               USER'S SRCB (FUNCTION TYPE)
         DC    H'0'                TANK COUNT
TSAVA   $ACON  0
TSAVB   $ACON  0
TANKCON $ACON  TTANK
 TITLE 'C O M S U P  --  $EXTP (ENTRY TO TRANSMIT A BUFFER TO HASP)'
*
*$EXTP - R14 = RETURN , R13 = BUFFER ADDR
*
         SPACE 3
$EXTP    NULL  *                   WRITE ENTRY POINT
         USING BUFDSECT,R13        BUFFER ADDR IS IN R13
         AIF   ('&XPARENT' EQ 'YES').NONXP1
         $SAVE R14,R15,CTPREGS     SAVE WORK REGISTERS         @OZ27704
         AIF   (&MACHINE EQ 20).BUFA                                R41
        $LA    R14,BUFDATA         LOCATE START OF BUFFER DATA       R4
.BUFA    AIF   (&MACHINE NE 20).BUFB                                R41
        $LA    R14,BUFDATA-BUFDSECT  GET BUFFER DATA OFFSET         R41
         AR    R14,R13             LOCATE START OF BUFFER DATA      R41
.BUFB    ANOP                                                       R41
         LH    R15,$TPBFSIZ        OBTAIN BUFFER                     R4
         SH    R15,=H'4'            DATA LENGTH                      R4
         SPACE 1                                                     R4
TR1      CH    R15,=H'256'         IF REMAINING LENGTH NOT GT 256,   R4
         BNH   TR2                  BR TO FINISH TRANSLATION         R4
         TR    0(256,R14),$NONXPAR   ELSE TRANSLATE 256 BYTES        R4
        $AA    R14,256             THEN UPDATE BUFFER ADDRESS        R4
         SH    R15,=H'256'         REDUCE BUFFER LENGTH              R4
         BZ    TR2+6     ZERO BUFFER REMAINDER                 @OZ27715
         B     TR1                  AND BR TO CONTINUE TRANSLATION   R4
         SPACE 1                                                     R4
&TEMP    SETA  0                                               @OZ27715
&TEMP2   SETA  (&TPBFSIZ-4)/256   GET MULT FACTOR              @OZ27715
TR2      EQU   *                                               @OZ27715
         AIF   (&TPBFSIZ-4 GE 256).LARGE BUFFER TRANSLATE      @OZ27715
&TEMP    SETA  &TPBFSIZ-4                                      @OZ27715
         AGO   .LAST                                           @OZ27715
.LARGE   ANOP                                                  @OZ27715
&TEMP    SETA  &TPBFSIZ-4-(256*&TEMP2) GET REMAINDER OF BUFF   @OZ27715
.LAST    ANOP                                                  @OZ27715
         SPACE 1                                               @OZ27715
         TR    0(&TEMP,R14),$NONXPAR TRANSLATE REMAINDER       @OZ27715
         $RESTORE R14,R15,CTPREGS RESTORE WORK REGISTERS       @OZ27704
.NONXP1  ANOP
         AIF   (&HOME EQ 0).EXTPOK
*              LOCAL PROCESSING MODE SELECTED..............
         $SAVE R14,R15,CREGS       SAVE SOME REGS
         B     CHOMASGN            ASSIGN BUFFER TO TCT
         AGO   .EXTPFK
.EXTPOK  ANOP
        $LA    R9,$OUTBUF          QUEUE CONTROL WORD
.EXTPFK  ANOP
        $CHAIN (R9),R13            QUEUE FOR TRANSMISSION
         BR    R14                 RETURN TO CALLER
         AIF   ('&XPARENT' EQ 'YES').NONXP2
$NONXPAR DC    64X'00'             TAKE OUT CTL CHARS
         DC    192AL1(*-$NONXPAR)  NON-CTL CHARS
.NONXP2  ANOP
         DROP  R13                 KILL BUFFER ADDRESSABILITY
 TITLE 'C O M S U P  -- INTERRUPT PROCESSOR (DEFINITIONS)  '
         SPACE 3
*                        CONTROL CHARACTERS
         SPACE 2
XSOH     EQU   X'01'               START OF HEADING
XSTX     EQU   X'02'               START OF TEXT
XETX     EQU   X'03'               END OF TEXT
XDLE     EQU   X'10'               DATA LINK ESCAPE
XETB     EQU   X'26'               END OF TEXT BLOCK
XENQ     EQU   X'2D'               ENQUIRY
XSYN     EQU   X'32'               SYNCHRONIZATION
XEOT     EQU   X'37'               LOST BLOCK ALARM
XNAK     EQU   X'3D'               NEGATIVE ACKNOWLEDGEMENT
XACK1    EQU   X'61'               POSITIVE ACKNOWLEDGEMENT-CONDITIONAL
XACK0    EQU   X'70'               POSITIVE ACKNOWLEDGEMENT
         AIF   ('&XPARENT' EQ 'YES').XPARA
XLDR     EQU   XSOH                NON-TRANSPARENCY HEADER
XTRL     EQU   XSYN                NON-TRANSPARENCY TRAILER
XCHN     EQU   X'A0'               NON-TRANSPARENT CCW CHAINING BITS
         AGO   .XPARB
.XPARA   ANOP
XLDR     EQU   XDLE                TRANSPARENT HEADER
XTRL     EQU   XDLE                TRANSPARENT TRAILER
XCHN     EQU   X'60'               TRANSPARENT CCW CHAINING BITS
.XPARB   ANOP
         SPACE 5
         AIF   (&MACHINE NE 20).D1
         SPACE 5
*                        COMMUNICATIONS ADAPTER ADDRESSES
         SPACE 2
CAINTID  EQU   X'56'               BSCA INTERRUPT IDENTIFIER
CAREAD   EQU   X'54'+1             BSCA RECEIVE CODE
CAWRITE  EQU   X'58'+1             BSCA TRANSMIT CODE
CASENSE  EQU   X'57'               BSCA SENSE CODE
CAERROR  EQU   X'50'               BSCA ERROR TEST CODE
CASCA    EQU   X'56'               BSCA STORE CURRENT ADDRESS
CAENABLE EQU   X'52'               BSCA ENABLE CODE
CADISABL EQU   X'53'               BSCA DISABLE CODE
CARECI   EQU   X'51'+1             BSCA RECEIVE INITIAL CODE
CAWRTRD  EQU   X'50'+1             BSCA TRANSMIT-RECEIVE CODE
         AGO   .D2
.D1      ANOP
         SPACE 5
*                        /360 MACHINE CHARACTERISTICS
         SPACE 2
$ADAPTER EQU   X'&ADAPT'           ADDRESS OF COMMUNICATIONS ADAPTER
$EXTOLD  EQU   X'18'               EXTERNAL OLD PSW
$IOOLD   EQU   X'38'               I/O OLD PSW
$CSW     EQU   X'40'               CHANNEL STATUS WORD
$CAW     EQU   X'48'
$TIMER   EQU   X'50',4             INTERVAL TIMER
.D2      ANOP
         SPACE 2
*                        BLOCK CONTROL BYTE INDICATORS
         SPACE 2
BCBIGNRE EQU   X'10'               IGNORE BLOCK COUNT INDICATOR
BCBRESET EQU   X'20'               RESET BLOCK COUNT INDICATOR
 TITLE 'C O M S U P  -- INTERRUPT PROCESSOR (ENTRY POINT)             '
         AIF   (&MACHINE EQ 20).FRL000
$EXTINT  NI    $EXTOLD+1,X'FD'     EXTERNAL INTERRUPTS ENTER HERE
         LPSW  $EXTOLD             RESET WAIT STATE AND RESUME
         SPACE 5
.FRL000  ANOP
$IOINT   NULL  *                   ALL INTERRUPTS ENTER HERE
         AIF   (&MACHINE NE 20).X2
         CLI   145,CAINTID         IS THIS BSCA
         BNE   $NOTTP              BR IF NO
$COMBUSY B     CEXIT               RETURN IF NO ACTIVITY
         TIOB  CERROR,CAERROR      BR IF ANY ERROR
CREADREQ B     CENDREAD            BR IF READ ENDING
CRDRESP  XIO   *-*(CAREAD),&TPBFSIZ OTHERWISE START READ
CREADCT  EQU   *-2                 READ COUNT FIELD
         BC    7,*-6               WAIT FOR READ TO TAKE
         MVI   CREADREQ+1,X'F0'    SHOW READ ACTIVE
         SPSW  144                 AND EXIT
CREXIT   NULL
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).ITRA
        $RESTORE R12,R15,CREGS     RESTORE INTERRUPTED REGISTERS
         AGO   .ITRB
.ITRA    ANOP
        $RESTORE R13,R15,CREGS     RESTORE INTERRUPTED REGS
.ITRB    ANOP
CEXIT    NULL
         SPSW  144                 RETURN TO INTERRUPTED LOCATION
         AGO   .X3
.X2      ANOP
         NI    $IOOLD+1,X'FD'      RESET WAIT STATE
         CLC   $IOOLD+2(2),=AL2($ADAPTER)    IS THIS SDA
         BNE   $NOTTP              BR IF NO
$COMBUSY NOP   CEXIT               BR IF NO COMMUNICATIONS I/O ACTIVE
        $SAVE  R13,R15,CREGS       SAVE INTERRUPTED REGS
         $LOAD R13,CBUFFER         GET CURRENT BUFFER ADDR
CUWFAKE  NOP   CWRTSIO             *** DUMMY READ SWITCH ***
         TM    $CSW+5,X'BF'        TEST FOR UNEXPECTED ERRORS
         BNZ   CBADERR             BR IF ANY
         TM    $CSW+4,X'F3'        TEST OTHER UNUSUAL ENDINGS
         BNZ   CERROR              BR IF ANY
*              CHANNEL-END , DEVICE-END ASSUMED
.X3      ANOP
 TITLE 'C O M S U P  -- CENDREAD (PROCESS NORMAL READ COMPLETION) '
         SPACE 3
$ENDREAD NULL  *                   EXTERNAL ENTRY POINT
CENDREAD NULL  *                   EXAMINE CONTROL INFORMATION
         AIF   (&MACHINE NE 20).X21
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).ITRC
        $SAVE  R12,R15,CREGS       SAVE INTERRUPTED REGS
         $LOAD R12,=Y($SVC)        SET TRACE ENTRY
         AGO   .ITRD
.ITRC    ANOP
        $SAVE  R13,R15,CREGS       SAVE INTERRUPTED REGS
.ITRD    ANOP
        $LOAD  R13,CBUFFER         GET ACTIVE BUFFER
.X21     ANOP
         USING BUFDSECT,R13        *
         SPACE 3
         B     CNOLOGAL            AVOID LOG OVERHEAD
         SPACE 2
*              NOP THE ABOVE BRANCH TO LOG EVERY BLOCK RECEIVED
         SPACE 2
         MVC   $LOGINFO(3),BUFSTART+1 RESPONSE LEADERS
        $LOG   XTPREAD             LOG RECEIVED DATA
CNOLOGAL NULL  *                   ENTRY TO SKIP LOGGING EVERYTHING
         MVC   CRESP,BUFSTART      GET FIRST RESPONSE BYTE
         CLI   CRESP,XDLE          IS IT DLE LEADER...
         BNE   *+10                BR IF NO
         MVC   CRESP,BUFSTART+1    YES... GET REAL RESPONSE
         CLI   CRESP,XSOH          IS THIS NON-XPARENT LEADER...
         BE    CINBUF              BR IF YES TO PROCESS TEXT
         CLI   CRESP,XSTX          IS THIS DATA
         BE    CINBUF              BR IF YES TO PROCESS
         CLI   CRESP,XACK0         IS THIS WRITE ACKNOWLEDGEMENT
         BE    CACKED              BR IF YES
         CLI   CRESP,XNAK          WERE WE NAK'ED
         BE    CNAKED              BR IF YES
         B     CRESPBAD            UNKNOWN RESPONSE RECEIVED
 TITLE 'C O M S U P  -- CWRTOK   (INITIATE NEXT WRITE)   '
*
*              POSITIVE ACKNOWLEDGEMENT OF LAST WRITE RECEIVED
*
         SPACE 3
CACKED   NULL  *                   ACKNOWLEDGEMENT WAS ACK
         NI    $FCSIN,255-X'40'    TURN OFF WAIT-A-BIT
CWRTOK   NULL
         TM    BUFSTAT,BUFFAKE     IS THIS A DUMMY BUFFER
         BO    CWRTNEXT            BR IF YES
         MVI   BUFSTAT,0           RESET STATUS BYTE
        $FREE  $BUFPOOL,R13,NOENB  RELEASE WRITTEN BUFFER
CWRTNEXT NOP   CREXIT              RESTORE INTERUPT REGS             R4
         LH    R14,$WAITCON        LOAD DELAYING CONSTANT
         AIF   (&MACHINE EQ 20).FRL00
CSWT1    NOP   *+10                BR. IF INTERVAL TIMER IS OFF
         MVC   $TIMER,=A(2*300*X'100')  SET 2 SECOND VALUE
.FRL00   ANOP
         MVC   CREADCT(2),$TPBFSIZ SET READ COUNT TO FULL            R4
CYCLE    NULL  *                   COMMUTATOR CYCLE POINT
         TM    $FCSIN,X'40'        IS WAIT-A-BIT SET
         BO    CWAITBIT            BR IF YES
         MVI   $TPPNONE+1,0        RESET BUFFERING STOP
        $DCHAIN $OUTBUF,R13,NOENB  OTHERWISE CHECK WRITE QUEUE
         BNZ   CSTNDWRT            BR IF WRITE BUFFER GOTTEN
$FCSHOT  NOP   CRESPOND            SW TO FORCE FCS RESPONSE
         BAS   R15,CSETCOM         CYCLE COMMUTATOR AGAIN
         AIF   (&MACHINE EQ 20).FRL10
CSWT2    NOP   *+16                BR. IF INTERVAL TIMER IS OFF
         TM    $TIMER,X'80'        TEST INTERVAL TIMER
         BZ    CYCLE               BRANCH IF NOT EXPIRED
         B     CRESPOND            BRANCH TO WRITE RESPONSE
.FRL10   ANOP
         AH    R14,=H'-1'          DECREMENT DELAY COUNT
         BP    CYCLE               BR IF NOT EXHAUSTED
         B     CRESPOND            DELAY TIME UP...SEND RESPONSE
CSTNDWRT NULL  *                   ENTRY FOR BUFFER WRITE WITH BCB
         MVC   BUFSTART,XSTXSEQ    SET START OF TEXT HEADER
         OI    BUFSTAT,BUFTEXT     SHOW TEXT BUFFER
         MVC   CSETBCB+1(1),CBCBCNTO BCB FOR CURRENT BUFFER
         LH    R15,CBCBCNTO-1      GET CURRENT COUNT
         AH    R15,=H'1'           INCREMENT TO NEXT
         STH   R15,CBCBCNTO-1      AND SAVE
         NI    CBCBCNTO,X'80'+15   MODULO 16
         B     CNWRITE             GO WRITE BUFFER
         SPACE 3
*
*              WAIT-A-BIT SEQUENCE RECEIVED FROM HASP
*
CWAITBIT NULL  *                   *
         MVI   $TPPNONE+1,X'F0'    STOP ALL BUFFERING
        $TRACE SSM=NO
         B     $FCSHOT             GO IDLE
 TITLE 'C O M S U P  -- CINBUF   (PROCESS INPUT BUFFER FROM HASP)  '
         SPACE 3
CINBUF   NULL  *                   *
         AIF   (&MACHINE EQ 20).CCOM20
         LA    R15,BUFSTART-1      POSITION TO                       R4
         AH    R15,$TPBFSIZ         END OF BUFFER                    R4
         SH    R15,$CSW+6          REDUCE BY RESIDUAL COUNT
         AGO   .CCOMN20            ENTER COMMON CODE
.CCOM20  ANOP
         CIO   CALASTPO,CASCA      LAST ADDR USED +1
         LH    R15,CALASTPO        TO REG
         AH    R15,=H'-1'          REDUCE TO LAST ADDR
.CCOMN20 ANOP
         CLI   0(R15),XETB         WAS ENDING SEQUENCE CORRECT
         BNE   CRESPBAD            BR IF YES TO LOG AND NAK
         MVC   $FCSIN,BUFFCS       SET NEW FUNCTION CONTROL
*              VERIFY BLOCK CONTROL BYTE COUNT
         MVC   CBCB(1),BUFBCB      GET BCB COUNT
CBCB     EQU   *+1                 COUNT BYTE
         CLI   CBCBCNTI,*-*        DOES RECEIVED MATCH EXPECTED
         BNE   CBCBCHEK            BR IF NO
         LH    R15,CBCBCNTI-1      GET CURRENT COUNT
         AH    R15,=H'1'           TO NEXT EXPECTED
         STH   R15,CBCBCNTI-1      AND RESET
         NI    CBCBCNTI,X'80'+15   MOLULO 16
CBCBOK   NULL  *                   ENTRY FROM IGNORE
         TM    BUFSTAT,BUFFAKE     IS THIS DUMMY BUFFER
         BO    CWRTOK              BR IF YES TO IGNORE
CHOMASGN $LA   R14,$TCT1           POINT TO FIRST TCT
         USING TCTDSECT,R14
COMPTCT  CLC   TCTRCB,BUFDATA      DOES BUFFER AND TCT RCBS MATCH
         BE    CASSIGN             IF SO ASSIGN BUFFER
         $LOAD R14,TCTNEXT         GO TO NEXT TCT
         $LTR  R14,R14             TEST FOR END
         BNZ   COMPTCT             COMPARE AGAINST TCT
         AIF   (&HOME NE 0).HOMCTL
         CLI   BUFDATA,0           ZERO RCB
         BE    CWRTOK              FREE BUFFER
         TM    BUFDATA,15          IS IT A CONTROL RECORD
         BNZ   CWRTOK              FREE BUFFER IF NOT
         CLI   BUFDATA+1,C'B'      Q. IF SIGN-OFF RECORD FROM HASP
         BNE   CNOTOFF             BR. IF NO
         AIF   (&CONSOLE EQ 0).IOFF01
         OI    $WOFF+1,X'F0'       SET -DISCONNECTED- SWITCH
.IOFF01  AIF   (&MACHINE NE 20).IOFF02
         CIO   1,CADISABL          TURN OFF BSCA
         AGO   .IOFF03
.IOFF02 $SIO   CCWOFF              DISABLE SDA-II
.IOFF03  MVC   $RCOMM1+1(3),=AL3($RCOMM1+4)  DISABLE CARD READER
         OI    $COMBUSY+1,X'F0'    SHOW NO T/P ACTIVITY
         OI    CWRTNEXT+1,X'F0'    SET -DISCONNECTED- SWITCH
         MVI   BUFDATA,X'91'       MAKE LOOK LIKE WTO FROM HASP
         B     CHOMASGN            PLACE BUFFER ON CONSOLE TCT
CNOTOFF  NULL  *
.HOMCTL  ANOP
         $LA   R14,$CTLTCT         POINT TO CONTROL TCT
CASSIGN  $LA   R15,TCTBUFER-TCTDSECT GET BUFFER POINTER OFFSET
         AR    R15,R14             POINT TO TCT BUFFER CHAIN
         MVI   $TPGETCM+1,X'F0'    OPEN TPGETS GATE
         MVI   BUFSTAT,0           RESET BUFFER STATUS BITS
        $CHAIN (R15),R13,NOENB     QUEUE FOR PROCESSING
         $LA   R15,BUFDATA-BUFDSECT GET RCB OFFSET
         STH   R15,BUFCOUNT        SAVE OFFSET TO FIRST RCB
         LH    R15,TCTBUFLM        PICK LIMIT AND COUNT
         $AA   R15,1               ADD 1 TO COUNT
         STH   R15,TCTBUFLM        SAVE
         OI    TCTSTAT,TCTACT      SHOW ACTION REQUIRED ON TCT
         AIF   (&HOME EQ 0).HOMASGN
         $RESTORE R14,R15,CREGS    RESTORE REGS
         BR    R14                 RETURN TO CALLER
.HOMASGN ANOP
         CLC   TCTBUFCT,TCTBUFLM   IS BUFFER MAXIMUM EXCEEDED
         BL    CASMORE             IF NOT ALLOW MORE
         $BITOFF $FCSOUT,TCTFCS,R15 TURN FCS BIT OFF
         DROP  R14
         B     CWRTNEXT            CONTINUE TRANSMISSION
CASMORE  MVI   $FCSHOT+1,X'F0'     SHOW FCS ACTIVE
         B     CWRTNEXT            AND CONTINUE XMISSION
*
*              RECEIVED BCB CHECK COUNT NOT CORRECT
*
CBCBCHEK NULL  *                   DETERMINE DAMAGE
         TM    CBCB,BCBIGNRE       IS THE IGNORE BIT ON
         BO    CBCBOK              BR IF YES
         TM    CBCB,BCBRESET       IS THIS A RESET REQUEST
         BZ    CBCBBAD             BR IF NO
         MVN   CBCBCNTI(1),CBCB    YES... DO IT
         B     CBCBOK              AND PROCESS RECORD
CBCBBAD  NULL  *                   BLOCK COUNTS DO NOT AGREE
         MVN   $LOGINFO(1),CBCB    SET FOR ERROR LOG
         MVN   $LOGINFO+1(1),CBCBCNTI SET FOR LOG
        $LOG   XBCBCHEK
         MVC   CTEMP+1(1),CBCB     ISOLATE RECEIVED CNT
         LH    R15,CBCBCNTI-1      GET EXPECTED CNT
         SH    R15,CTEMP           LESS RECEIVED
         BP    *+8                 BR IF TOO LOW
         AH    R15,=H'16'          MAKE DIFFERENCE POSITIVE
         CH    R15,CMAXDUP         IS DIFFERENCE REASONABLE
         BH    CBLKLOST            BR IF NO
         B     CWRTOK              IGNORE BLOCK
         SPACE 2
CBLKLOST NULL  *                   ONE OR MORE BLOCKS ARE LOST
         MVN   CLOSTBCB,CBCB       SET RECEIVED BLOCK COUNT
         MVN   CLSTSRCB,CBCBCNTI   SET EXPECTED BLOCK COUNT
         MVC   BUFCOUNT(CLOSTEND-CLOSTBLK),CLOSTBLK  SET BAD BLOCK
         MVC   CSETBCB+1(1),CLOSTBCB  SET RESTORE BCB INSTRUCTION
         B     CNWRITE             GO TELL HASP ABOUT BAD BCB
         SPACE 2
*              PROTOTYPE CTL RECORD TO TELL HASP THAT BLOCKS ARE LOST
         SPACE 2
CLOSTBLK NULL  *                   START
         DC    AL2(CLOSTEND-CLOSTBS) BUFCOUNT
         DC    AL1(BUFTEXT)        BUFSTAT
CLOSTBS  DC    AL1(XLDR,XSTX)      BUFSTART
CLOSTBCB DC    AL1(X'80'+BCBIGNRE) BUFBCB(RECEIVED BLOCK CT ADDED
CLOSTFCS DC    AL2(0)              FCS
         DC    AL1(X'E0')          RCB (CTL REC,TYPE=LOST DATA)
CLSTSRCB DC    AL1(X'80')          SRCB(EXPECTED BLK CT ADDED)
         DC    AL1(0)              SCB (NULL RECORD)
         DC    AL1(0)              RCB (END OF BLOCK)
CLOSTEND EQU   *                   END OF PROTOTYPE
 TITLE 'C O M S U P  -- COMIDLE   (NO DATA TO SEND TO HASP)  '
         SPACE 3
CRESPOND NULL  *                   ENTRY TO RESPOND TO HASP
         MVI   $FCSHOT+1,0         RESET HOT SWITCH
        $DCHAIN $BUFPOOL,R13,NOENB GET A BUFFER TO USE
         BNZ   CBUFGOTN            BR IF GOTTEN
CSTOPIN  NULL  *                   ENTRY TO STOP ALL INPUT
        $LA    R13,CDUMMY          USE DUMMY BUFFER
         MVI   BUFDATA,0           SET NULL BUFFER RCB
         MVI   BUFSTAT,BUFFAKE     FORCE STATUS TO DUMMY
         MVC   CREADCT(2),=Y(CDUMCT) SET READ COUNT TO SHORT
         B     CSTNDWRT            GO DO NORMAL WRITE
CBUFGOTN NULL  *
         MVI   BUFDATA,0           SET NULL BUFFER RCB
         MVC   BUFCOUNT,=AL2(CDUMEND-CDUMSTRT) SET WRITE COUNT
         CLC   CFCSOUT,$FCSOUT     HAS FCS BEEN CHANGED
         BNE   CSTNDWRT            BR IF YES TO DO NORMAL WRITE
         MVC   BUFSTART,XACKSEQ    SETUP STANDARD SEQUENCE
CSENDRES NULL                      *
         OI    BUFSTAT,BUFRESP     SHOW RESPONSE BUFFER
         B     CNWRITE             AND GO WRITE
CDUMMY   $ACON 0                   NO CHAIN
         DC    AL2(CDUMEND-CDUMSTRT) COUNT
         DC    AL1(BUFFAKE)        BUFSTAT
CDUMSTRT DC    AL1(XLDR,XSTX)      BUFSTART
         DC    AL1(X'80'+BCBIGNRE) BUFBCB
         DC    AL2(0)              FCS
         DC    AL1(0)              RCB (EOB)
CDUMEND  EQU   *                   END OF DUMMY BUFFER
         AIF   (&MACHINE NE 20).CNOPAD
         DC    AL2(0)              SPACE FOR ENDING SEQUENCE
.CNOPAD  ANOP
CDUMCT   EQU   *-CDUMSTRT          MAXIMUM ACCEPTABLE COUNT
 TITLE 'C O M S U P  -- CNAKED   (PROCESS ERROR REPLY FROM HASP)  '
*
*              A NEGATIVE RESPONSE RECEIVED FROM HASP
*
         SPACE 3
CNAKED   NULL  *                   PREPARE TO RETRANSMIT
        $LOG   XNAKREC             LOG NEGATIVE REPLY
         TM    BUFSTAT,BUFNAK      WERE WE SENDING A NAK
         BO    CNAKNAK             BR IF YES
         MVI   BUFSTART,XLDR       RESET LEADER CHARACTER
         TM    BUFSTAT,BUFTEXT     WAS THIS A TEXT BUFFER
         BO    CREWRITE            BR IF YES TO RETRY
         MVC   BUFSTART,XACKSEQ    SET RESPONSE LEADER AND ACK      R41
         B     CWRTXIO             AND GO WRITE IT
CNAKNAK  NULL                      OUR NAK WAS NAK'ED
         TM    BUFSTAT,BUFTEXT     WAS ORIGINAL BUFFER TEXT...
         BZ    CWRTOK              NO...FORGET IT
*                                  YES...PREPARE TO RESEND
         MVC   BUFSTART,XSTXSEQ    RESET TEXT LEADERS
         NI    BUFSTAT,255-BUFNAK-BUFRESP RESET STATUS
         B     CNWRITE             WRITE BUFFER AGAIN
         SPACE 5
*
*              UNKNOWN RESPONSE FROM HASP... RESEND LAST DATA
*
CRESPBAD NULL
         MVC   $LOGINFO(2),BUFSTART SHOW BAD RESPONSE
         $LOG  XUNKRES             LOG ERROR
         B     CSENDNAK            GO REPLY NAK
         SPACE 3
*
*              SEND A NEGATIVE RESPONSE TO HASP
*
CSENDNAK NULL  *                   ENTRY
         MVC   BUFSTART,XNAKSEQ    SET NAK SEQUENCE
         OI    BUFSTAT,BUFRESP+BUFNAK SHOW NAK RESPONSE
         B     CNWRITE             AND GO WRITE IT
 TITLE 'C O M S U P  -- CSETCOM  (COMMUTATOR LINKAGE CONTROL)  '
*
*              COMSUP IS EXITING WITHOUT I/O ACTIVE
*              PREPARE FOR RE-ENTRY THROUGH COMUTATOR
*
         SPACE 3
CSETCOM  NULL  *                   *
         MVI   $COMCOM+1,X'F0'     OPEN GATE
         MVI   $COMBUSY+1,X'F0'    SHOW NO ACTIVITY
        $SAVE  R13,R15,CRETREGS    SAVE SOME REGISTERS
         B     CREXIT              AND RETURN TO INTERRUPTED LOC
$COMSUP  NULL
        $SSM   0                   DISABLE
         MVI   $COMCOM+1,0         CLOSE COMUTATOR ENTRY
        $RESTORE R13,R15,CRETREGS  RESTORE
         AIF   (&MACHINE NE 20).CA
         MVC   146(2),=Y($COMCOM+4) SET EXIT TO COMUTATOR
         AGO   .CB
.CA      ANOP
         MVC   $IOOLD+5(3),=AL3($COMCOM+4) SET EXIT TO COMUTATOR
.CB      ANOP
         MVI   $COMBUSY+1,0        ALLOW COMMUNICATIONS INTERRUPTS
         BR    R15                 RE-ENTER COMSUP
CRETREGS $WCON (0,0,0)             REGISTER SAVE
 TITLE 'C O M S U P  -- CNWRITE  (COMMUNICATIONS WRITE SUBROUTINE)  '
         SPACE 3
CNWRITE  NULL
         AIF   (&MACHINE NE 20).X4
         LH    R15,=Y(BUFSTART-BUFDSECT) DATA DISPLACEMENT
         AR    R15,R13             R15 = BEGINNING OF DATA
         STH   R15,CRDRESP+2       SET RETURN READ
         STH   R15,COMWRITE+2      SET WRITE ADDR
         TM    BUFSTAT,BUFRESP     IS THIS A RESPONSE SEQUENCE...
         BZ    CSETEND             BR IF NO
         MVC   COMWRITE+4(2),=H'2' YES...SET RESPONSE COUNT
         B     CWRTXIO             AND WRITE IT
CSETEND  NULL  *                   ADD BSC ENDING SEQUENCE
         LH    R15,BUFCOUNT        DATA COUNT
         AH    R15,=H'11'          FIX FOR XPARENCY
         STH   R15,COMWRITE+4      SET COUNT
         AR    R15,R13             INCLUDE BUFFER
         AH    R15,=Y(BUFSTART-BUFDSECT) ADJUST FOR HEADING
         SH    R15,=H'11'          AVOIDS ASSEMBLER ERROR
         MVC   0(2,R15),XETBSEQ    SET ENDING
CREWRITE NULL  *                   RE-WRITE TEXT ENTRY
         TM    BUFSTAT,BUFRESP     IS THIS A RESPONSE
         BO    CWRTXIO             BR IF YES TO SKIP FCS SET
         MVC   BUFFCS,$FCSOUT      SET CURRENT FCS
         MVC   CFCSOUT,$FCSOUT     SAVE LAST FCS SENT
CSETBCB  MVI   BUFBCB,*-*          SET BCB INTO BUFFER
         MVC   COLDRCB+1(1),BUFDATA SAVE RCB
         TM    BUFSTAT,BUFFAKE     IS THIS A DUMMY BUFFER
         BZ    *+8                 BR IF NO
         OI    BUFFCS,X'40'        YES...SET WAIT-A-BIT
CWRTXIO  NULL  *                   WRITE BUFFER
         MVI   CREADREQ+1,0        SHOW READ REQUIRED
         STH   R13,CBUFFER         SET BUFFER ADDR
         B     CNWLOG              NOP THIS TO LOG EVERY WRITE
         MVC   $LOGINFO(3),BUFSTART+1 SET LOG INFO
         $LOG  XTPWRITE            AND DO IT
CNWLOG   NULL  *                   WRITE LOG BYPASS
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).TRX
        $RESTORE R12,R15,CREGS     RESTORE BEFORE I/O IN CASE 40KB
         AGO   .TRZ
.TRX     ANOP
        $RESTORE R13,R15,CREGS     RESTORE BEFORE I/O IN CASE 40KB
.TRZ     ANOP
         MVI   $COMBUSY+1,0        SHOW ACTIVITY
         AIF   (&MACHINE NE 20 OR &LINESPD LT 19200).CL
         AIF   (&SUBMOD GE 5).CL
         TIOB  *,PBUSY             WAIT ON PRINTER CARRIAGE CYCLE
.CL      ANOP
COMWRITE XIO   *-*(CAWRITE),0      ISSUE WRITE
         BC    7,*-6               WAIT UNTIL ACCEPTED
         SPSW  144                 EXIT (QUICKLY)
         AGO   .X5
.X4      ANOP
         LA    R15,BUFSTART        TO XMISSION POINT
         ST    R15,CCWA            INTO CCW
         MVI   CCWA,1              RESET OP
         ST    R15,CCWC            SET RETURN DATA ADDR
         MVI   CCWC,2              RESET OP
         MVC   CCWA+6(2),BUFCOUNT  SET WRITE COUNT
         MVI   CCWA+4,XCHN         SET PROPER CCW CHAINING
         $STO  R13,CBUFFER         SAVE BUFFER ADDR
         MVI   CCWB,1              RESET OP FOR ENDING SEQ
         TM    BUFSTAT,BUFRESP     IS THIS JUST A RESPONSE
         BZ    CREWRITE            BR IF NO
         MVI   CCWA+4,X'60'        SET COMMAND CHAINING
         MVC   CCWA+6(3),=X'000203' SET COUNT AND 2ND CCW OP
         B     CWRTSIO             GO START WRITE
CREWRITE NULL  *                   ENTRY TO RETRY WRITE
         MVC   CFCSOUT,$FCSOUT     SAVE LAST FCS SENT
         MVC   BUFFCS,$FCSOUT      SET CURRENT FCS
CSETBCB  MVI   BUFBCB,*-*          SET BCB INTO BUFFER
         MVC   COLDRCB+1(1),BUFDATA SAVE RCB
         TM    BUFSTAT,BUFFAKE     IS THIS A DUMMY BUFFER
         BZ    *+8                 BR IF NO
         OI    BUFFCS,X'40'        YES...SET WAIT-A-BIT
CWRTXIO  NULL  *                   START THE WRITE
CWRTSIO  MVI   CUWFAKE+1,X'00'     MAKE SURE DUMMY READ NOT ON
         SPACE 3
         B     CNWLOG              NOP THIS TO LOG ALL WRITES
         MVC   $LOGINFO(3),BUFSTART+1  SET LOG DATA
        $LOG   XTPWRITE            AND DO IT
CNWLOG   NULL  *                   WRITE LOG BYPASS
        $SIO   CCWA                START I/O
         SPACE 3
*
*              INTERRUPT EXIT ROUTINE
*
         SPACE 3
CREXIT   NULL
        $RESTORE R13,R15,CREGS     RESTORE INTERRUPTED REGS
CEXIT    NULL
         LPSW  $IOOLD
.X5      ANOP
 TITLE 'C O M S U P  -- CERROR   (COMMUNICATIONS ERROR PROCESSOR)  '
*
*
*
         SPACE 3
CERROR   NULL  *
         AIF   (&MACHINE NE 20).X10
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).ITRE
        $SAVE  R12,R15,CREGS       SAVE INTERRUPTED REGS
         $LOAD R12,=Y($SVC)        SET TRACE ENTRY
         AGO   .ITRF
.ITRE    ANOP
        $SAVE  R13,R15,CREGS       SAVE INTERRUPTED REGS
.ITRF    ANOP
        $LOAD  R13,CBUFFER         GET CURRENT BUFFER
         CIO   CENSE,CASENSE       STORE SENSE BYTES
CENSE    EQU   *+1
         MVI   $LOGINFO,*-*        SET FOR LOG PROCESSING
         $LOG  XUNITCHK            LOG ERROR
         CLI   CENSE,X'7F'         TEST I/O TYPE (CLI FASTER)
         BNH   CREWRITE            BR IF WRITE TO RE-TRY
*              PROCESS READ ERROR
COLDRCB  CLI   BUFDATA,*-*         CHECK VALIDITY OF DATA (RCB)
         BE    *+8                 BR. IF MATCH
         NI    BUFSTAT,255-BUFTEXT OTHERWISE FORGET TEXT
         TM    CENSE,B'00010000'   Q. IF TIMEOUT PROBLEM
         BNO   CSENDNAK            GO TO NAK HASP IF NOT            N30
         TM    CENSE,B'00011000'   Q. IF LOST DATA W/ TIMEOUT      @N30
         BO    CSENDNAK            GO NAK HASP IF YES              @N30
        $RESTORE R13,R15,CREGS     RESTORE INTERUPTED REGS           R4
         B     CRDRESP             THEN BR. TO REINSTATE READ        R4
         AGO   .X12
.X10     ANOP
         MVC   CCSW,$CSW           PRESERVE CSW AROUND SENSE AND LOG
         TM    $CSW+4,2            TEST UNIT CHECK
         BO    CUNITCHK            BR IF YES
         TM    $CSW+4,1            TEST UNIT EXCEPTION
         BO    CUNITEXC            BR IF YES
CBADERR  NULL  *                   ENTRY FOR UNUSUAL ERROR
         MVC   $LOGINFO(2),$CSW+4  SET INFO BYTES
        $LOG   XUNSLERR            LOG ERROR
         B     CHECKCCW            GO DETERMINE I/O TYPE
CUNITCHK NULL  *                   ENTRY FOR UNIT CHECK
        $SIO   CCWSENS             STORE SENSE BYTE
         LA    R15,CENSEWAT        LOCATE INTERRUPT POINT
         ST    R15,$IONEW+4        SET NEW PSW TO SENSE WAIT
         LM    R14,R15,$IOOLD      SAVE ORIGINAL PSW
         SSM   =X'FF'              ENABLE FOR INTERRUPT
         B     *                   WAIT FOR COMPLETION OF SENSE
CENSEWAT CLC   $IOOLD+2(2),=AL2($ADAPTER)  IS IT SDA
         BNE   $NOTTP              BRANCH IF NOT
         STM   R14,R15,$IOOLD      RESTORE ORIGINAL PSW
         LA    R15,$IOINT          LOCATE NORMAL ENTRY
         ST    R15,$IONEW+4        SET INTERRUPT ADDRESS
CENSE    EQU   *+1
         MVI   $LOGINFO,*-*        SET FOR LOG PROCESSING
        $LOG   XUNITCHK            LOG ERROR
CHECKCCW LA    R14,CREWRITE
         L     R15,CCSW            GET COMMAND ADDR
         LTR   R15,R15             IS IT ZERO...
         BCR   8,R14               BR IF YES TO TRY REWRITE
         TM    CCSW+5,4            TEST CHANNEL CONTROL CHECK
         BCR   1,R14               YES... GUESS AT REWRITE
         S     R15,=F'8'           OTHERWISE BACK UP TO FAILED CC
         CLI   0(R15),1            WAS IT A WRITE
         BCR   8,R14               BR IF YES TO RETRY IT
COLDRCB  CLI   BUFDATA,*-*         CHECK VALIDITY OF DATA (RCB)
         BE    *+8                 BR. IF MATCH
         NI    BUFSTAT,255-BUFTEXT OTHERWISE FORGET TEXT
         TM    CENSE,B'00000001'   Q. IF TIMEOUT PROBLEM
         BZ    CSENDNAK            BR. IF NO - SEND A NAK TO HASP
         SPACE 3
         B     CNRLOG              NOP THIS TO LOG ALL READS
         SPACE 3
         MVC   $LOGINFO(3),BUFSTART+1  SET LOG DATA
        $LOG   XTPREAD             LOG READ REQUEST
CNRLOG   NULL  *
        $SIO   CCWC                REINSTATE READ COMMAND
         B     CREXIT              BR. TO RETURN FROM INTERRUPT
         DS    0F                  FORCE FULL-WORD ALIGNMENT
CCSW     DC    XL8'00'             TEMPORARY STORAGE FOR CSW
         SPACE 5
*
*              UNIT EXCEPTION SET
*
         SPACE 3
CUNITEXC NULL
         L     R15,$CSW            GET CSW ADDR
         S     R15,=F'8'           BACK UP TO CMD IN ERROR
         MVC   CUNITCMD(1),0(R15)  SAVE COMMAND CODE
CUNITCMD EQU   *+1                 COMMAND CODE STORAGE
         MVI   $LOGINFO,*-*        SHOW COMMAND TYPE
         MVC   $LOGINFO+1(2),BUFSTART LOG BUFFER LEADERS
        $LOG   XUNITEXP            LOG ERROR
         CLI   CUNITCMD,1          WAS THIS A WRITE...
         BNE   CSENDNAK            BR IF NO TO FORCE RESEND (EOT REC)
CUFAKERD DS    0H                                              @OZ75904
         MVI   CUWFAKE+1,X'F0'     SET SWITCH TO IGNORE ERROR
        $SIO   CCWD                START READ
         B     CREXIT              AND EXIT TO AWAIT INT
 TITLE 'C O M S U P  -- $SIO     (START I/O SUBROUTINE FOR SDA-II) '
$SIO     NULL
         MVC   $CAW(4),0(R15)      SET CCW ADDR.
         MVC   CLASTCAW,0(R15)     SAVE
        $TRACE SSM=NO
CSIOAGIN SIO   $ADAPTER            DO IT
         BC    8,4(R15)            RETURN IF ACCEPTED
         BC    3,CSIOBNOP          BR IF BUSY OR NOT OPER.     @OZ75904
         TM    $CSW+4,X'01'        TEST FOR UNIT EXCEPTION     @OZ75904
         BO    CUFAKERD            BR IF YES, ISSUE READ       @OZ75904
CSIOBNOP DS    0H                                              @OZ75904
         ST    R15,CSIOSAV         SAVE
         BALR  R15,0               GET CURRENT PSW
         SRL   R15,28              ADJUST CONDITION CODE
         STC   R15,$LOGINFO        AND SET FOR LOG
         MVC   $LOGINFO+1(2),$CSW+4 LOG CSW ALSO
        $LOG   XSIOBAD             AND LOG IT
         L     R15,CSIOSAV         RESTORE
         B     CSIOAGIN            AND TRY AGAIN
CSIOSAV  DC    F'0'                LINK SAVE
CLASTCAW DC    F'0'                CCW ADDR SAVE
.X12     ANOP
 TITLE 'C O M S U P  -- INTERRUPT PROCESSOR (STORAGE)      '
         SPACE  5
CBUFFER $ACON  0                   ACTIVE COMUNICATIONS BUFFER
$BUFFER  EQU   CBUFFER             EXTERNAL REFERENCE NAME
CFCSOUT  DC    H'0'                LAST FCS TRANSMITTED TO HASP
CTEMP    DC    H'0'                TEMPORARY STORAGE
CMAXDUP  DC    H'3'                MAX REPEATED BLOCKS
         DC    AL1(0)              FIRST BYTE OF HALF-WORD
CBCBCNTO DC    AL1(X'80')          BLOCK CHECK COUNT OUT
         DC    AL1(0)              SPACER
CBCBCNTI DC    AL1(X'80')          BLOCK COUNT CHARACTER EXPECTED
         DC    H'0'                *
$INQCNT  EQU   *-1                 COUNT OF QUEUED INPUT BUFFERS
CRESP    DC    AL1(0)              RESPONSE CHARACTER RECEIVED
         AIF   (&TRACE EQ 0 OR &MACHINE NE 20).TRG
CREGS    $WCON (0,0,0,0)           REGISTER SAVE AREA
         AGO   .TRH
.TRG     ANOP
CREGS    $WCON (0,0,0)             REGISTER SAVE AREA
CTPREGS  $WCON (0,0)               $EXTP SAVE AREA             @OZ27704
.TRH     ANOP
CALASTPO DC    H'0'                LAST ADDR STORAGE
         SPACE 5
*                        CONTROL SEQUENCES
XSTXSEQ  DC    AL1(XLDR,XSTX)      START-OF-TEXT SEQUENCE
XETBSEQ  DC    AL1(XTRL,XETB)      END-OF-TEXT-BLOCK SEQUENCE
XACKSEQ  DC    AL1(XDLE,XACK0)     POSITIVE ACKNOWLEDGEMENT SEQUENCE
XNAKSEQ  DC    AL1(XSYN,XNAK)      NEGATIVE ACKNOWLEDGEMENT SEQUENCE
         AIF   (&MACHINE EQ 20).S1
         SPACE 5
*                        CHANNEL CONTROL WORDS
         SPACE 2
*                   NORMAL DATA WRITE WITH RETURN DATA READ
         SPACE 1
CCWA    $CCW   1,*-*,60,*-*        WRITE BUFFER
COMWRITE EQU   CCWA                FOR DEBUGGING AID PAGE
CCWB    $CCW   1,XETBSEQ,60,2      WRITE ENDING SEQUENCE
CCWC    $CCW   2,*-*,20,&TPBFSIZ   READ RETURN DATA
CREADCT  EQU   *-2                 READ COUNT FIELD
         SPACE 3
*                   DUMMY READ TO TURN OFF LOST DATA SENSE
         SPACE 1
CCWD    $CCW   2,*,30,65000        NON-READ A BUNCH
         SPACE 3
*                   SDA-II SENSE COMMAND
         SPACE 1
CCWSENS $CCW   4,CENSE,20,1        SENSE
         SPACE 3
*                   SDA-II DISABLE COMMAND
         SPACE 1
CCWOFF  $CCW   X'2F',0,20,1        DISABLE
.S1      ANOP
         DROP  R13                 KILL BUFFER ADDRESSABILITY
         AIF   (&MACHINE EQ 20).YOSKP1
 TITLE '$ X I O  -- UNIT RECORD I/O SUPERVISOR'
*
*        BASE REGISTER ASIGNMENT
*
         USING TANKDSEC,R8
         USING TCTDSECT,TCTR
         SPACE 3
&A       SETA  0
*
*        ENTRY TO INITIATE I/O ON UNIT RECORD DEVICES
*              TCTR POINTS TO THE DEVICE TCT REG R14 POINTS TO USER
*
$XIO     NULL
         MVC   TCTCCW,TCTOPCOD     SET NORMAL OP-CODE FROM SAVE
$XIOA    $STO  R14,TCTSAV1         SAVE RETURN ADDRESS
         $DELAY Y,T,TYPE=SETUP     PREPARE TO DELAY/WAIT,SET REENTRY
         SSM   *+1                 DISABLE INTERRUPTS
         TM    TCTECB,TCTBUSY      IS DEVICE BUSY
         BO    YOCLOSE             HANG IN A LOOP AND WAIT FOR DEV END
         MVI   TCTECB,TCTBUSY      SET ECB FOR START I/O
         MVI   TCTSENSE,0          ZERO OUT SENSE BYTE
         LA    R8,TCTCCW           PICK UP CCW ADDR
         ST    R8,CAW              PUT IN CAW
YBUSY    LH    R14,TCTUCB          LOAD UP THE DEVICE ADDRESS        R4
         SIO   0(R14)              START I/O
         $LOAD R14,TCTSAV1         PREPARE FOR RETURN TO USER
         BC    8,YOENBL            I/O WENT OK GO TO USER
         BC    4,YOCSWSTO          CSW STORED
         BC    2,YBUSY             ISSUE SIO AGAIN IF BUSY           R4
YOCLOSE  $LOAD R14,TCTCOM          CLOSE COMMUTATOR
         NI    1(R14),X'0F'        CHANGE BR TO NOP
*              IF DEVICE BUSY DEVICE END INTERRUPT WILL CLEAR
*              IF DEVICE NOT  READY DEVICE END WILL CLEAR
YOENBL   SSM   =X'FF'              ALLOW INTERRUPTS
         BR    R14                 RETURN TO CALLER
YOEOF    MVI   TCTECB,DEVEOF       SIGNAL END OF FILE
         B     YOENBL              RETURN TO USER
YOCSWSTO TM    CSW+5,X'FF'         ANY SERIOUS PROBLEMS
         BNZ   YONOSTRT            SET I/O NOT STARTED PSW
         CLI   CSW+4,DEVEOF        TEST FOR END OF FILE ONLY
         BE    YOEOF               RETURN TO USER
         TM    CSW+4,DEVUCK+DEVATN+DEVMOD TEST FOR NO START CONDITIONS
         BNZ   YONOSTRT            SET I/O NOT STARTED PSW
YOSETPSW STH   R14,IOOLDPSW+6      SET TO RETURN TO USER I/O STARTED
         LR    R15,TCTR            SET INTERRUPT TCT REG
         B     YODEVFND            PROCESS AS INTERRUPT
YONOSTRT LA    R14,TCTRTN          PICK RETURN TO COMMUTATOR
         B     YOSETPSW            SET PSW TO LOOP BACK TO SIO
*
*        $IOCK                     ENTRY POINT TO PASS TO USER CODES
*
$IOCK    $STO  R14,TCTSAV1         SAVE USER RETURN ADDRESS
         $DELAY Y,T,TYPE=SETUP     GET READY FOR DELAY
         SSM   *+1                 DISABLE I/O INTERRUPTS
         TM    TCTECB,TCTBUSY      TEST FOR BUSY
         BNZ   YOCLOSE             WAIT FOR INTERRUPT
         IC    R14,TCTECB          PICK UP I/O COMPLETION
         SLL   R14,4               ALIGN UNIT CHECK AND UNIT EXECPTION
         STC   R14,YOPSW+4         SET COMPLETION CODES
         LPSW  YOPSW               LOAD PSW
YOCKRET  $LOAD R14,TCTSAV1         PICK UP USER ADDRESS
         BR    R14                 RETURN
         $ENDPROC Y                END OF SIO IOCK USER INTERFACE
         DROP  TCTR
         USING TCTDSECT,R15
 TITLE '$ N O T T P  -- UNIT RECORD INTERRUPT HANDLER'
$NOTTP   STM   R13,R15,YOREGSAV    SAVE REGS USED
         LA    R15,$TCT1           PICK UP START OF TCT CHAIN
         LH    R14,IOOLDPSW+2      DEVICE ADDRESS
YOTCTLOP CH    R14,TCTUCB          CHECK FOR MATCH
         BE    YODEVFND            EXAMINE THE INTERRUPT
         $LOAD R15,TCTNEXT         PICK UP NEXT TCT
         LTR   R15,R15             TEST FOR END OF CHAIN
         BNZ   YOTCTLOP            LOOP BACK TO TEST DEV ADDR
YORTN    LM    R13,R15,YOREGSAV    RESTORE USER REGS
YOLPSW   LPSW  IOOLDPSW            RETURN
YODEVFND TM    CSW+4,DEVEND        DO WE HAVE DEVICE END
         BZ    YOCKLOG             IF NOT SKIP RESET BUSY
         $LOAD R13,TCTCOM          GET COMMUTATOR
         OI    1(R13),X'F0'        OPEN GATE
         NI    TCTECB,255-TCTBUSY  RESET BUSY
YOCKLOG  OC    TCTECB,CSW+4        SET ECB WITH STATUS
         TM    CSW+5,X'FF'         TEST ANY LOGABLE ERRORS
         BNZ   YOLOG               IF SO LOG THEM
         TM    CSW+4,DEVUCK        TEST FOR UNIT CHECK
         BO    YOSENSE             IF SO SENSE AND LOG
         TM    CSW+4,DEVATN        TEST FOR ATTENTION
         BZ    YORTN               RETURN IF NO
         OI    TCTSTAT,TCTREQ      TURN ON REQUEST FLAG
         $LOAD R13,TCTCOM          GET COMMUTATOR ENTRY
         OI    1(R13),X'F0'        OPEN GATE
         B     YORTN               RETURN
YOSENSE  MVC   CAW(4),=A(YOSENCCW) SET UP FOR SENSE
         LH    R14,TCTUCB          PICK UP DEVICE ADDR
YOSSIO   SIO   0(R14)              SENSE INTO LOG AREA
         BC    2,YOSSIO            TRY AGAIN IF BUSY
YOTEST   TIO   0(R14)              TEST I/O
         BC    2,YOTEST            WAIT UNTIL FINISHED
         MVC   TCTSENSE(1),$LOGINFO SAVE SENSE INFO
         MVC   $LOGINFO+1(2),TCTUCB MOVE IN DEVICE ADDR
         $LOG  XUNITCHK,SAVE       LOG UNIT CHECK
         B     YORTN               RETURN
YOLOG    MVC   $LOGINFO(1),CSW+5   PREPARE LOG INFO
         MVC   $LOGINFO+1(2),TCTUCB MOVE IN DEVICE ADDR
        $LOG   XUNSLERR,SAVE       LOG ERROR
         B     YORTN               RETURN
*
*        UNIT RECORD I/O SUPERVISOR EQUATES
*
DEVEOF   EQU   X'01'               UNIT EXCEPTION
DEVUCK   EQU   X'02'               UNIT CHECK
DEVATN   EQU   X'80'               ATTENTION
DEVMOD   EQU   X'40'               STATUS MODIFIER
DEVEND   EQU   X'04'               DEVICE END
YOREGSAV DC    3F'0'               INTERRUPT REG SAVE AREA
YOSENCCW DS    0D
CAW      EQU   X'48'               LOCATION OF CHANNEL ADDRESS WORD
CSW      EQU   X'40'               LOCATION OF CHANNEL STATUS WORD
IOOLDPSW EQU   X'38'               LOCATION OF I/O OLD PSW
         DC    X'04',AL3($LOGINFO),X'20',AL3(1) SENSE CCW
YOPSW    DC    X'FF',X'04',AL2(0),AL1(0),AL3(YOCKRET)
         AGO   .YOSKP3
.YOSKP1  ANOP
 TITLE '$ N O T T P  --  UNIT RECORD INTERRUPT HANDLER'
         AIF   (&CONSOLE EQ 0).YOSKP2
$NOTTP   NULL  ,                   INTERRUPT ENTRY POINT
         CLI   145,WREQ            TEST FOR INQUIRY REQUEST
         BNE   YORET               IF NOT IGNORE INTERRUPT
         OI    WCTSTAT,TCTREQ      TURN ON REQUEST FLAG
         OI    $WCOMM1+1,X'F0'     OPEN GATE TO CONSOLE
YORET    SPSW  144                 RETURN TO INTERRUPTED LOCATION
         AGO   .YOSKP3
.YOSKP2  ANOP
$NOTTP   NULL
YORET    SPSW  144                 RETURN TO INTERRUPTED LOCATION
         AIF   (&R(2)).YOSKP3
*
*        $DIAL                     READS DIALS AND CHECKS FOR CHANGE
*
*                                  DESTROYS ALL REGISTERS
*
$DIAL    NULL
         LH    R8,0(0,R14)         PICK LOCATION TO STORE REQUEST
         STH   R14,0(0,R8)         STORE REQUESTORS RETURN LOCATION
         $SSM  0                   DISABLE INTERRUPTS
         MVC   YODSAV,252          SAVE THE READ IN AREA
         DIALS ,                   READ THE DIALS
         MVC   YODIALS,252         MOVE REQUIRED DIAL INFO TO WORK
         MVC   252(3),YODSAV       RESTORE READ IN LOCATIONS
         MVC   YODIAL2+1(1),YODIALS SEPARATE DATA DIALS
         $SSM  X'FF'               ENABLE INTERRUPTS
         NI    YODIALS,X'10'       MASK OUT DIAL 2 PLUS HIGH 3 BITS
         CLC   YODOLD,YODIALS      COMPARE FOR CHANGE IN DATA 1
         BE    2(0,R14)            IF NO CHANGE RETURN TO USER
         MVC   YODOLD,YODIALS      SET DATA 1 FOR FUTURE READS
         NI    YODIAL2+1,X'0F'     MASK OUT DIAL 1
         LH    R8,YODIAL2          PICK UP DATA DIAL 2
         AR    R8,R8               DOUBLE IT
         AH    R8,=Y(YODTAB)       LOCATE REQUEST ENTRY
         LH    R15,0(0,R8)         PICK RESPONSE RETURN POINT
         LH    R9,=Y(YODNULL)      PICK UP ADDR OF NULL RTN
         STH   R9,0(0,R8)          PUT IT IN RESPONSE TABLE
         B     6(0,R15)            RETURN WITH POSITIVE ANSWER
$DIALTAB DS    0H                  DIAL RESPONSE TABLE POINTERS
YODTAB   DC    Y(YODNULL)          0    DIAL OFFSET TABLE
         DC    Y(YODNULL)          1
         DC    Y(YODNULL)          2
         DC    Y(YODNULL)          3
         DC    Y(YODNULL)          4
         DC    Y(YODNULL)          5
         DC    Y(YODNULL)          6
         DC    Y(YODNULL)          7
         DC    Y(YODNULL)          8
         DC    Y(YODNULL)          9
         DC    Y(YODNULL)          A
         DC    Y(YODNULL)          B
         DC    Y(YODNULL)          C
YODNULL  DS    0H                  NULL ROUTINE OFFSET BY -6
         DC    Y(YODNULL)          D
         DC    Y(YODNULL)          E
         DC    Y(YODNULL)          F
         B     2(0,R14)            NULL RTN, RETURN TO USER
YODSAV   DC    CL3' '              SAVE AREA FOR READ IN AREA
YODOLD   DC    CL1' '              OLD DATA DIAL 1
YODIAL2  DC    H'0'                DATA DIAL 2 ISOLATED
YODIALS  DC    CL1' '              WORK AREA FOR DIALS
.YOSKP3  ANOP
 TITLE 'IT''S A BIRD... IT''S A PLANE... IT''S  S U P E R T R A C E'
$SVC     NULL  *                   SVC NEW ENTRY POINT
         AIF   (&TRACE EQ 0).TRASKIP
         $SSM  0                   TRACE MUST RUN DISABLED
        $STO   R12,SVCSAV          PRESERVE
         $LOAD R12,$TRACUR         CURRENT TRACE LOC
         AH    R12,=H'4'           TO NEXT ENTRY
         CH    R12,$TRAEND         IS THIS END
         BNH   *+8                 BR NO
         $LOAD R12,$TRASTRT        YES...GET START
         $STO  R12,$TRACUR         RESET PTR
         MVI   0(R12),0            CLEAR HIGH BYTE
         AIF   (&MACHINE EQ 20).TR20
         MVC   1(3,R12),37         SET TRACE LOCATION
         L     R12,36              SVC OLD ADDR
         CLI   35,X'CC'            IS THIS REGULAR TRACE
         BNE   TRACNTNO            BR IF NO
         LH    R12,0(R12)          GET COUNT FIELD
         CH    R12,=H'32767'       IS TRACE ALREADY MAXIMUM
         BE    *+8                 BR IF YES
         LA    R12,1(R12)          INCREMENT
         STH   R12,TRACNT          SAVE
         L     R12,36              GET SVC OLD
         MVC   0(2,R12),TRACNT     SET COUNT
         B SVCRET                  BACK TO CALLER
TRACNTNO NULL  *                   TRACE COUNT NOT REQUIRED
         MVZ   SVCBRN+1(1),35      SET BRA CONDITION
         SPM   R12                 GET PROGRAM MASK
         MVC   38(2),0(R12)        SET POSSIBLE BRA
SVCBRN   BC    *-*,SVCRETA         DO WHAT USER INTENDED
SVCRET   NULL  *                   NORMAL-SEQUENTIAL RETURN
         LA    R12,2(R12)          NEXT INST
         STH   R12,38              NO BRA...SET RETURN
SVCRETA  NULL  *                   BR RETURN
         L     R12,SVCSAV          RESTORE 12
         LPSW  32                  RETURN TO CALLER
SVCSAV   DC    F'0'                TEMP SAVE
TRACNT   DC    H'0'                TEMPORARY TRACE COUNT
         AGO   .TRNOT20
.TR20    ANOP
         MVC   2(2,R12),SVCSAV     SET TRACED LOCATION
         MVI   1(R12),0            CLEAR 2ND BYTE OF TRACE
         LH    R12,SVCSAV          RESTORE LINKAGE
         AH    R12,=H'2'           ADJUST RETURN
         STH   R12,SVCRET          SET EXIT
         LH    R12,SVCSAV          RESTORE
         LH    R12,0(0,R12)        GET COUNT FIELD
         CH    R12,=H'32767'       WATCH FOR OVERFLOW
         BE    SVCSAV+2            EXIT IF MAX
         AH    R12,=H'1'           COUNT ENTRY
         STH   R12,*-*             RESET COUNT
SVCSAV   EQU   *-2                 STORAGE
         LH    R12,=Y($SVC)        SET FOR NEXT TIME
         B     *-*                 RETURN
SVCRET   EQU   *-2                 RETURN STORAGE
.TRNOT20 ANOP
         EJECT
         SPACE 10
*
*              T R A C E  T A B L E  (AND POINTERS)
*
         SPACE 5
$TRACUR  $ACON (TRACETAB-4)        CURRENT TRACE ENTRY
*
*
$TRASTRT $ACON (TRACETAB)          BEGINNING OF TRACE TABLE
*
*
$TRAEND  $ACON (TRACETAB+&TRACE*4-4) END OF TRACE TABLE
*
*
TRACETAB DC    (&TRACE)F'0'        T R A C E  T A B L E
*
*
.TRASKIP ANOP
         LTORG                                                 @OZ16672
 TITLE '$ T A N K P O L  --  DECOMPRESSION TANK POOL '
$1STTANK $GENTANK
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).TANKSKP
         ORG   $TANK1              OVERLAY TANK ONE WITH MESSAGE
         DC    H'0',AL1(&WRCB(1)),X'80',H'26' TANK CONTROL BYTES
         DC    CL26'COMMUNICATIONS ESTABLISHED' MESSAGE
         ORG   ,                   RESUME NORMAL COUNTER
.TANKSKP ANOP
         EJECT
*              THIS LINE DELETED BY APAR NUMBER              * @OZ16672
$END     DS    0H                  END OF PERMANENT CODE
 TITLE '$ I N I T I 8  --  DYNAMIC BUFFER POOL CONSTRUCTION '
$1STBUF  DS    0F
*
*              THE FOLLOWING SECTION WILL DYNAMICALLY BUILD THE
*              COMMUNICATIONS BUFFER POOL OVER THE INITIALIZATION
*              INSTRUCTIONS.   BUFFERS WILL BE CONSTRUCTED TO THE
*              EXTENT OF MEMORY OR UNTIL '&NUMBUFS' HAS BEEN BUILT.
         SPACE 2                                                     R4
         ORG   *+(BUFSTART-BUFBEGIN)  ORG AFTER BUF CNTRL INFO
P$1STBUF $ACON $1STBUF
BUFLN1   DC    0H'0',AL2(BUFEND-BUFBEGIN)
BUFLN2   DC    0H'0',AL2(2*(BUFEND-BUFBEGIN))
BUFZEROS DC    F'0'
BCOREND  DC    0H'0',AL2(1024*&HICORE-1)
BONE     DC    H'1'
BNUMBUFS DC    H'&NUMBUFS'
IBLDBUFS NULL
         AIF   (&MACHINE NE 20).NINTANK                        @OZ16672
         MVC   INCONTIN+5(135),INCONTIN+4  BLANK OUT TANK 2    @OZ16672
.NINTANK ANOP                                                  @OZ16672
         $LOAD R11,P$1STBUF        LOAD ADDR OF 1ST BUFFER
         LH    R10,P$1STBUF        LOAD ADDR OF 1ST BUFFER
         LH    R9,BNUMBUFS         LOAD MAX NUMBER OF BUFFERS
         AIF   (&MACHINE EQ 20).FRL30
         CLC   $TIMER,=F'-1'       Q. IF TIMER IS WORKING
         BNE   BULDMORE            BR. IF YES
*                                  THIS LINE DELETED BY APAR   @OZ40560
         OI    CSWT1+1,X'F0'       SET TIMET WORKING SWITCH
         OI    CSWT2+1,X'F0'       SET TIMET WORKING SWITCH
.FRL30   ANOP
BULDMORE NULL
         AH    R10,BUFLN2          INCREASE R10 BY 2 BUFLENGTHS
         $CA   R10,BCOREND         IS THERE ROOM FOR 2 MORE BUFS
         BH    BUFSDONE            BR IF NO
         SH    R9,BONE             SUB ONE FROM BUFFER COUNT
         BZ    BUFSDONE            BR IF LAST BUBBER
         SH    R10,BUFLN1          BACK UP TO NEXT BUFF ADDR
         $STO  R10,0(0,R11)        STORE POINTER IN PREV BUF
         MVC   L'BUFCHAIN((BUFSTART-BUFCOUNT),R11),BUFZEROS  MOVE IN
*                                  INITIAL VALUES
         LH    R11,0(0,R11)        UPDATE R11 TO NEXT BUFFER
         B     BULDMORE            BR TO BUILD ANOTHER BUFF
BUFSDONE NULL
         $LOAD R10,BUFZEROS        LOAD CHAIN TERMINATOR
         $STO  R10,0(0,R11)        STORE IT IN THE LAST BUFFER
         MVC   L'BUFCHAIN((BUFSTART-BUFCOUNT),R11),BUFZEROS  MOVE IN
*                                  INITIAL VALUES
         AIF   (&HOME EQ 0).IHOMB
         $SSM  FF                  ENABLE INTERRUPTS
         B     $START              GO TO COMMUTATOR DIRECT
.IHOMB   ANOP
 TITLE '$ I N I T I 8  --  ESTABLISH HASP SYNCHRONIZATION '
         $DCHAIN $BUFPOOL,R13,NOENB GET A BUFFER
         USING BUFDSECT,R13        *
         MVC   BUFCOUNT(ICTLE-ICTLS),ICTLS SETUP CONTROL REPLY
         $CHAIN $OUTBUF,R13,NOENB STAGE FOR WRITE
         $DCHAIN $BUFPOOL,R13,NOENB GET ANOTHER
         $STO  R13,$BUFFER         SET FOR I/O ROUTINES
         MVC   BUFSTART,XACKSEQ    FAKE AN ACK
         B     $ENDREAD            FAKE AN INTERRUPT
ICTLS    DS    0H                  CONTROL INFO FOR BUFFER
         DC    AL2(ICTLE-*-3)      BUFCOUNT
         DC    X'00'               BUFSTAT
         DC    AL1(XLDR,XSTX)      BUFSTART
         DC    AL1(X'80'+BCBRESET) BUFBCB (RESETS EXPECTED BLOCK CT)
         DC    AL2(0)              FCS
         DC    X'F0'               GENERAL CONTROL TYPE RCB
         DC    C'A'                SIGN-ON ID
ICTXT    DS    0CL80
         DC    CL21'/*SIGNON       REMOTE'
         DC    CL59'&RMTID'        REMOTE IDENTIFICATION
         DC    AL1(0)              EOR
ICTLE    EQU   *
         LTORG
         TITLE 'H A S P / R J E  * ABSOLUTE PATCH LOADER * '
$REPLOAD NULL                      ENTRY POINT
ZEP1     NULL  *                   READ REP CARD
         AIF   (&MACHINE EQ 20).REP20
         LA    R1,4095             PICK UP MAXIMUM DISPLACEMENT
         LA    R1,1(0,R1)          SET R1 TO X'1000'  4- 8K
         LA    R2,0(R1,R1)         SET R2 TO X'2000'  8-12K
         LA    R3,0(R1,R2)         SET R3 TO X'3000' 12-16K
         MVC   $TIMER,=F'-1'       INITIALIZE TIMER                  R4
         MVC   $CAW(4),=A(IREADCCW)   SET CCW
         SIO   X'&RADR(1)'         READ
         BC    7,*-4               LOOP UNTIL TAKEN
         TIO   X'&RADR(1)'         TEST COMPLETE
         BC    3,*-4               LOOP BACK UNTIL I/O CHAN END
         NC    $CSW+4(2),=X'F3FF'  TURN GOOD BITS OFF
         BNZ   *                   STOP ON ERROR BITS ON
         AGO   .REP360A
.REP20   ANOP
         XIO   ZEPCARD(ROPCODE+1),80 READ REP CARD
         BC    7,*-6               *
ZEP2     NULL
         TIOB  *,RBUSY             WAIT
ZEP3     NULL
         TIOB  ZEP1,RERROR         ERROR
ZEP4     NULL
         TIOB  ZEPEND,REOF         EOF
         XIO   ZEPCARD(POPCODE+1),80 PRINT REP CARD
         BC    7,*-6               WAIT UNTIL TA-EN
         AGO   .REP20A
.REP360A ANOP
ZEP360   NULL  *                   360 ENTRY
         MVC   $CAW(4),=A(IPRTCCW) SET CCW
         SIO   X'&PADR(1)'         PRINT IT
         BC    7,*-4               LOOP UNTIL TAKEN
         TIO   X'&PADR(1)'         TEST COMPLETE
         BC    7,*-4               LOOP IF NO
.REP20A  ANOP
         CLC   ZEPCARD(4),=C'    ' IS THIS BLANK
         BE    ZEPEND              BR IF YES TO END OF REPS
         CLC   ZEPCARD(8),ICTXT    IS THIS SIGNON CARD
         BE    ZEPENDA             IF SO MOVE SIGNON
         CLC   ZEPCARD(8),=C'&&MLBFSIZ'  IS THIS &MLBFSIZ      @OZ27487
         BE    ZEPMLBF             BR IF SO                          R4
         CLC   ZEPCARD(8),=C'&&NUMBUFS'  IS THIS &NUMBUFS      @OZ27487
         BE    ZEPBUFS             BR IF SO                          R4
         CLC   ZEPCARD+1(3),=C'REP'   IS THIS REP
         BNE   ZEP1                BR IF NO... TO READ AGAIN
         CLC   ZEPCARD+8(4),=C'    ' IS LOC FIELD BLANK...
         LH    R8,=Y(ZEPCARD+16)   LOAD ADDR OF DATA
         BE    Z1                  BR IF BLANK TO CONT. OLD LOC
         LH    R8,=Y(ZEPCARD+8)    ADDR OF LOC FIELD
         BAS   R9,ZTRAN            GO DECODE
         STH   R10,ZWK+1           SIMULATE
         LH    R11,ZWK+1           LR  11,10
         LH    R8,=Y(ZEPCARD+16)   FIRST DATA WORD
Z1       BAS   R9,ZTRAN            GO DECODE
         STH   R10,0(0,R11)        AND STORE
         AH    R11,=H'2'           BUMP LOC CTR
         CLI   4(R8),C','          IS THERE MORE
         BNE   ZEP1                BR IF NO TO NEXT CARD
         AH    R8,=H'5'            UP CARD POINTER
         B     Z1                  AND GO AGAIN
         EJECT                                                       R4
ZEPMLBF  LH    R8,=Y(ZEPCARD+9)    LOAD ADDR OF BUFFER SIZE          R4
         BAS   R9,ZCNVT             AND CONVERT NUMBER TO BINARY     R4
        $AA    R10,1               ADD 1 TO BUFFER SIZE              R4
         STH   R10,$TPBFSIZ        ENSURE &TPBFSIZ                   R4
         NI    $TPBFSIZ+1,X'FE'     A MULTIPLE                       R4
         LH    R10,$TPBFSIZ          OF TWO BYTES                    R4
         STH   R10,CREADCT         INITIALIZE BUFFER READ COUNT      R4
        $AA    R10,BUFDATA-5-BUFBEGIN+3  INTERNAL BUF LEN + 3        R4
         STH   R10,BUFLN1          ENSURE INTERNAL                   R4
         NI    BUFLN1+1,X'FD'       BUFFER LENGTH A MULTIPLE         R4
         LH    R10,BUFLN1            OF FOUR BYTES                   R4
         AR    R10,R10             COMPUTE AND STORE                 R4
         STH   R10,BUFLN2           INTERNAL BUF LEN TIMES 2         R4
         SPACE 1                                                     R4
         AIF   ('&XPARENT' EQ 'YES').REP20B                          R4
         LH    R10,$TPBFSIZ        SET COUNT                         R4
         SH    R10,=H'5'            FOR FINAL                        R4
         STH   R10,$TEMP             TRANSLATE                       R4
         MVC   TR2+1(1),$TEMP+1       IN $EXCP                       R4
.REP20B  ANOP                                                        R4
         SPACE 1                                                     R4
         B     ZEP1                THEN BR TO READ ANOTHER CARD      R4
         SPACE 3                                                     R4
ZEPBUFS  LH    R8,=Y(ZEPCARD+9)    LOAD ADDR OF NEW BUFFER COUNT     R4
         BAS   R9,ZCNVT             AND CONVERT NUMBER TO BINARY     R4
         STH   R10,BNUMBUFS        STORE NUMBER OF BUFFERS           R4
         MVC   CCTBUFLM,BNUMBUFS+1  AND SET IN CTCT                  R4
         B     ZEP1                THEN BR TO READ ANOTHER CARD      R4
         EJECT                                                       R4
***********************************************************************
*                                                                     *
*        ZCNVT - CONVERT 4-DIGIT (OR LESS) NUMBER TO BINARY           *
*                                                                     *
*        R8    - ADDRESS OF NUMBER TO BE CONVERTED                    *
*        R9    - RETURN ADDRESS                                       *
*        R10   - NUMBER IN BINARY FORM ON EXIT                        *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
ZCNVT    SR    R10,R10             INITIALIZE COUNT TO ZERO          R4
         MVC   ZWORK+1(4),0(R8)    MOVE NUMBER TO WORK AREA          R4
         SPACE 1                                                     R4
ZCNVDIG  MVC   ZWORK(5),ZWORK+1    SHIFT NUMBER LEFT 1 DIGIT         R4
         CLI   ZWORK,C' '          IF END OF NUMBER FIELD,           R4
         BER   R9                   RETURN                           R4
         STH   R10,ZWORKA          PLACE R10 IN WORK AREA A    @OZ65879
        $LMHA  R10,R8,ZWORKA,=H'10'  SHIFT LEFT ONE 'DIGIT'    @OZ65879
         NI    ZWORK,X'0F'         LEAVE ONLY NUMERIC PORTION        R4
         AH    R10,ZDIGIT          ADD NEW DIGIT TO TOTAL            R4
         B     ZCNVDIG              AND BR TO TEST FOR MORE          R4
         SPACE 1                                                     R4
ZDIGIT   DC    0H'0',X'00',CL6' '  ZCNVT WORK AREA                   R4
ZWORK    EQU   ZDIGIT+1,6          REDEFINITION OF WORK AREA         R4
         DS    0H                                              @OZ65879
ZWORKA   DC    H'0'                ZCNVT WORK AREA A           @OZ65879
         SPACE 3                                                     R4
***********************************************************************
*                                                                     *
*        ZTRAN - CONVERT EBCDIC HEX TO BINARY                         *
*                                                                     *
*        R8    - ADDRESS OF NUMBER TO BE CONVERTED                    *
*        R9    - RETURN ADDRESS                                       *
*        R10   - NUMBER IN BINARY FORM ON EXIT                        *
*                                                                     *
***********************************************************************
         SPACE 1                                                     R4
ZTRAN    MVC   ZWK(4),0(R8)        MOVE DATA                         R4
         TR    ZWK(4),ZTAB         TRANSLATE A LITTLE
         PACK  ZWK(4),ZWK(4)       PACK IT UP
         MVO   ZWK(4),ZWK(4)       SHIFT IT
         LH    R10,ZWK+1           LOAD RESULT--- INTO REG
         BR    R9                  AND RETURN
         DS    0H
         DC    X'00'
ZWK      DC    AL3(0)
         DC    X'00'               SPACER
ZEPCARD  DS    80C
ZTAB     EQU   *-X'C1'                  -
         DC    X'0A0B0C0D0E0F'
         DC    (X'F0'-X'C6')X'00'
         DC    X'010203040506070809'
         AIF   (&MACHINE EQ 20).REP360C
IREADCCW $CCW  2,ZEPCARD,20,80     CARD READ CCW
IPRTCCW $CCW   9,ZEPCARD,20,80     PRINT CARD CCW
.REP360C ANOP
         SPACE 1                                                     R4
ZEPENDA  MVC   ICTXT,ZEPCARD       MOVE SIGNON INTO DEFAULT          R4
         SPACE 1                                                     R4
ZEPEND   DS    0H                  END OF REP/PARM CARDS             R4
 TITLE '$ I N I T I 8  --  INITIALIZATION PROCESSOR '
$INITI8  NULL  *                   ENTRY POINT
         AIF   (&CONSOLE EQ 0 AND &PRTCONS EQ 0).ISKPTNK
*
*        SETUP FOR COMMUNICATIONS ESTABLISHED MESSAGE
*
         MVC   WCTTANK,$TANKPOL    SET MESSAGE TANK FOR OUTPUT
         MVI   WCTTNKCT,1          SET TANK COUNT
         MVC   $TANKPOL,=Y($TANK2) SET TANK TWO FIRST
         OI    $WCOMM1+1,X'F0'     OPEN COMMUTATOR GATE
.ISKPTNK ANOP
         SPACE 5
*
*        HASP ENVIRONMENT RECORDING ERROR PRINTOUT (HEREP)
*
INIHEREP NULL
         CLC   ILOGTABL+4(L'LOGTEXT),LOGTABLE+4 IS THE TABLE GOOD
         BNE   INEWTABL            BR NO TO INITIALIZE NEW TABLE
         AIF   (&MACHINE EQ 20).INI1
         SSM   *+1                 DISABLE
         MVC   CAW(4),INICAW1      MVC ADDR OF SKIP TO CHAN 1 CCW
*                                  TO THE CAW
         BAL   R8,INIPRINT         BR TO PRINT
         MVC   CAW(4),INICAW2      MVC ADDR OF TITLE CCW TO CAW
         BAL   R8,INIPRINT         BR TO PRINT
         MVC   CAW(4),INICAW3      MVC ADDR OF SPACE 3 CCW TO CAW
         BAL   R8,INIPRINT         BR TO PRINT
         MVC   CAW(4),INICAW3      SPACE 3 MORE
         BAL   R8,INIPRINT         BR TO PRINT
.INI1    AIF   (&MACHINE NE 20).INI2
         $SSM  0                   DISABLE I/O INTERRUPTS
         CIO   1,X'45'             SKIP TO CHANELL 1
         BC    7,*-4               BR UNTILL EXCEPTED
         XIO   INITITLE(POPCODE+1),90 PRINT TITLE
         BC    7,*-6               BR UNTIL EXCEPTED
         CIO   3,X'44'             SPACE 3
         BC    7,*-4               BR UNTIL EXECTPED
         CIO   3,X'44'             SPACE 3
         BC    7,*-4               BR UNTIL EXCEPTED
.INI2    ANOP
         USING LOGDSECT,R9
         $LA   R9,LOGTABLE         R9 BASE FOR FIRST ENTRY
INPRTOUT NULL
         CLI   LOGID,X'00'         IS THIS THE END
         BE    INEWTABL            BR YES INITIALIZE NEW TABLE
         MVC   INILTEXT,LOGTEXT    MVC LOGTEXT TO PRINT BUFFER
         LH    R10,LOGCOUNT        LOAD ERROR COUNT INTO R10
         AIF   (&MACHINE EQ 20).INI3
         CVD   R10,INICVD          CONVERT TO PACKED DECIMAL
.INI3    AIF   (&MACHINE NE 20).INI4
         MVC   INICVD,INIPZERO     MVC PACKED ZERO
INCVDLOP NULL
         SH    R10,=H'1'           SUBTRACT ONE
         BM    INCVDONE            BR NEGATIVE TO EDIT
         AP    INICVD,INIPONE      ADD ONE TO THE CONVERT FIELD
         B     INCVDLOP            LOOP
.INI4    ANOP
INCVDONE NULL
         UNPK  INIERCNT,INICVD      CONVERT THE NUMBER TO EBCDIC
         $LA   R10,INIERCNT         PICK UP START OF OUTPUT AREA
*                                  FOR LEADING ZERO SUPPRESSION
INIEDIT  NULL
         CLI   0(R10),C'0'         TERT FOR A LEADING ZERO
         BNE   INIWRITE            BR  NO TO WRITE THE LINE
         MVI   0(R10),C' '         REPLACE WIT A BLANK
         AH    R10,=H'1'           POINT TO NEXT CHARACTER
         B     INIEDIT             GO CHECK FOR ANOTHER BLANK
INIWRITE NULL
         OI    INIERCNT+6,X'F0'     CORRECT LOW ORDER DIGIT ZONE
         AIF   (&MACHINE EQ 20).INI5
         MVC   CAW(4),INICAW4      SET UP CAW TO PRINT THE LINE
         BAL   R8,INIPRINT         PRINT IT
.INI5    AIF   (&MACHINE NE 20).INI6
         XIO   INIBUFF(POPCODE+1),L'LOGTEXT+37 PRINT THE LINE
         BC    7,*-6               BR UNTIL EXCEPTED
.INI6    ANOP
         AH    R9,=Y(LOGEND-LOGID) UPDATE R9 TO NEXT LOG ENTRY
         B     INPRTOUT            BR TO PROCESS THE NEXT ENTRY
         SPACE 3
INEWTABL NULL
         MVC   LOGTABLE(X'92'),ILOGTABL RECREATE THE LOG TABLE
         B     INCONTIN            CONTINUE
ILOGTABL DS    0H
         $LOGENT ID=XBCBCHEK,CLASS=10,TEXT='BLOCK SEQ CK'
         $LOGENT ID=XNAKREC,CLASS=7,TEXT='ERROR REPLY'
         $LOGENT ID=XUNKRES,CLASS=10,TEXT='INVALID RESP'
         $LOGENT ID=XUNITEXP,CLASS=10,TEXT='UNIT EXCPTN'
         $LOGENT ID=XUNITCHK,CLASS=7,TEXT='UNIT CHECK'
         $LOGENT ID=XUNSLERR,CLASS=15,TEXT='UNUSUAL END'
         $LOGENT ID=XSIOBAD,CLASS=12,TEXT='SIO FAILURE'
         $LOGENT ID=XTPWRITE,CLASS=1,TEXT='W' LOG OF WRITES
         $LOGENT ID=XTPREAD,CLASS=1,TEXT='R' LOG FOR ALL READS
         DC    X'00'               END OF LOG TABLE
ILTABEND DS    0C                  END OF THE TABLE
         AIF   (&MACHINE EQ 20).INI7
         SPACE 3
PRINTER EQU    X'00E'
INIPRINT NULL
         SIO   X'&PADR(1)'         START THE OPERATION
         BC    3,*-4               WAIT UNTIL TAKEN
         BC    4,INICSWS           BR IF CSW STORED
         TIO   X'&PADR(1)'         TEST COMPLETION
         BC    3,*-4               LOOP UNTIL COMPLETE
         BR    R8                  AND RETURN
INICSWS  NULL  *                   CSW STORED ON START I/O
         NC    68(2),=X'F3FF'      ELIMINATE CE,DE
         BNZ   INIPRINT            BR IF ERROR TO RETRY
         BR    R8                  OTHERWISE RETURN
         SPACE 3
*
*        HEREP CCW'S AND CAW'S FOR NON-20'S
*
         SPACE 5
INICAW1  DC    A(INICCW1)          CAW TO SKIP TO TOP OF PAGE
INICAW2  DC    A(INICCW2)          CAW TO PRINT TITLE AND SPACE 3
INICAW3  DC    A(INICCW3)          CAW TO SPACE 3
INICAW4  DC    A(INICCW4)          NORMAL HEREP LINE
         SPACE 3
INICCW1  CCW   X'8B',INITITLE,X'20',1 SKIP IMMEDIATE TO CHAN 1
INICCW2  CCW   X'19',INITITLE,X'20',90 PRINT TITLE AND SPACE 3
INICCW3  CCW   X'1B',INITITLE,X'20',1 SPACE 3 LINES IMMEDIATELY
INICCW4  CCW   X'11',INIBUFF,X'20',(L'LOGTEXT+37)
.INI7    ANOP
INITITLE DC  45C' ',C'HASP ENVIRONMENT RECORDING ERROR PRINTOUT'
INIHEAD  DC    20C' ',C'ERROR ID',14C' '
         DC    C'COMULATIVE COUNT SINCE THE LAST IPL'
INIBUFF  DS    0CL(L'LOGTEXT+37)
         DC    20C' '
INILTEXT DC    CL(L'LOGTEXT)' '
         DC    10C' '
INIERCNT DC    C'0000000'
INICVD   DC    0D'0',PL8'0'
INIPZERO DC    PL8'0'
INIPONE  DC    P'1'
         EJECT
         EJECT
         AIF   (&MACHINE NE 20).INMOD30                        @OZ16672
         ORG   $TANK2+2            PUT INIT CODE IN TANK 2     @OZ16672
.INMOD30 ANOP                                                  @OZ16672
INCONTIN NULL
         AIF   (&MACHINE EQ 20).IMOD20
         MVC   CAW(4),INICAW1      SET UP FOR SKIP TO CHAN 1
         BAL   R8,INIPRINT         BR TO INITIALIZATION PRINT
         MVC   $EXTNEW(40),IPSWS   SETUP ALL PSW'S
         SSM   *+1
         AIF   (&HOME NE 0).IHOMA
ISIO     NULL  ,                   ESTABLISH COMMUNICATIONS WITH HASP
         LA    R9,INITCCW          INITIALIZATION CCW STRING
         BAL   R8,I27XXIO          GO START I/O
         MVI   INITCCW,4           CHANGE DISABLE TO SENSE
         MVI   INITCCWS,3          NOP SET MODE
         BNZ   ISIO                RETRY IF PREVIOUS I/O BAD
         CLC   IREADRES,=AL1(XDLE,XACK0) WAS ACK RECEIVED
         BNE   ISIO                START AGAIN IF NO
.IHOMA   ANOP
         MVC   $IOOLD(8),INTFAKE   SET FAKE INTERRUPT
         MVC   $IONEW+4(4),=A($IOINT)  SET NORMAL INTERRUPT ENTRY
         B     IBLDBUFS            GO CONSTRUCT BUFFER POOL
INTFAKE  DC    X'FF04',AL2($ADAPTER),AL4($START) FAKE OLD PSW
         DS    0D                  *
INITCCW  $CCW  X'2F',INITCCW+5,60,1 DISABLE  (CHANGED TO SENSE)
INITCCWS $CCW  X'23',ISETMODE,60,1  SET MODE (CHANGED TO A NOP)
         $CCW  X'27',0,60,1        ENABLE
INITCCWR $CCW  1,INITSEQ,60,2      WRITE RESPONSE SEQUENCE
         $CCW  2,IREADRES,20,2     READ ANSWER FROM HASP
INITSEQ  DC    AL1(XSOH,XENQ)      PRE SIGN ON RESPONSE
IREADRES DC    AL2(0)              RESPONSE CHARACTERS FROM HASP
*
*              SUBROUTINE TO PERFORM I/O OPERATIONS ON THE 27XX
*               R8=RETURN,R9=CCW ADDR,CC=Z=NORMAL CE,DE--NZ=BAD
*
I27XXIO  NULL  *                   ENTRY
         ST    R9,$CAW             SETUP CCW ADDR
         SIO   $ADAPTER            START OPERATION
         BC    7,*-4               LOOP UNTIL TAKEN
INITENB  SSM   =X'FF'              ENABLE INTERRUPTS
         B     *                   WAIT FOR INTERRUPT
$INITWAT CLC   $IOOLD+2(2),=AL2($ADAPTER)  IS THIS SDA
         BNE   INITENB             LOOP IF NOT SDA
         CLC   $CSW+4(2),=X'0C00'  SET COND CODE FOR CALLER
         BR    R8                  AND RETURN
ISETMODE DC    X'00'               SET MODE BYTE
IPSWS    NULL  *                   NEW PSW'S
         DC    X'00040000',AL4($EXTINT)  EXTERNAL
         DC    X'00040000',AL4($SVC) SVC
         DC    X'0002000000111111' PROGRAM INTERRUPT
         DC    X'00020000',X'00FFFFFF' MACHINE CHECK
         DC    X'00040000',AL4($INITWAT)  I/O NEW
$IONEW   EQU   120                 I/O NEW
$EXTNEW  EQU   88                  EXTERNAL NEW PSW
         AGO   .IMODXX
.IMOD20  ANOP
         CIO   1,X'45'             SKIP TO CHAN 1
         BC    7,*-4               WAIT UNTIL ACCEPTED
         $LOAD R12,=Y($SVC)        ESTABLISH TRACE ENTRY
         AIF   (&CONSOLE EQ 0).IMOD20A
         CIO   1,WENABLE           ENABLE CONSOLE REQUESTS
         AGO   .IMOD20B
.IMOD20A AIF   (&R(2)).IMOD20B
         MVC   YODSAV,252          SAVE DIAL AREA
         DIALS ,                   READ DIALS
         MVC   YODOLD,252          SET DATA DIALS TO INITIAL VALUE
         NI    YODOLD,X'10'        REMOVE DIAL 2 PLUS HIGH 3 BITS
         MVC   252(3),YODSAV       RESTORE AREA
.IMOD20B ANOP
         AIF   (&HOME EQ 0).IHOMIA
         B     IHOMSKP
.IHOMIA  ANOP
         CIO   1,CAENABLE          TURN ON BSCA
IREDOIT  MVC   148(4),=AL4(INITINT) SET NEW PSW
IAGAIN   NULL  *                   TRY AGAIN
         XIO   IWRDRES(CAWRTRD),4  SEND PRE-SIGNON, REC DLE ACK0
         BC    7,IAGAIN            TRY AGAIN IF NOT STARTED
         $SSM  FF                  PREPARE FOR INTERRUPT
         B     *                   LOOP UNITL INTERRUPT
INTFAKE  DC    X'01',AL1(CAINTID),Y($START),AL4($IOINT) FAKE AND REAL
INITINT  NULL  *                   INITIALIZATION INTERRUPT PROCESSOR
         CLI   145,CAINTID         IS THIS BSCA
         BNE   IBACK               BR IF NO TO IGNORE
         TIOB  IAGAIN,CAERROR      RETRY IF ANY ERROR
         CLC   IREADRES,=AL1(XDLE,XACK0) WAS ACK RECEIVED
         BNE   IAGAIN              START OVER IF NOT
IHOMSKP  DS    0H
         MVC   144(8),INTFAKE      SETUP FAKE OLD AND GOOD NEW PSW
         MVI   INCONTIN,0           RE-INITIALIZE TANK 2       @OZ16672
         MVC   INCONTIN+1(3),INCONTIN    WITH A WORD OF ZEROS  @OZ16672
         MVI   INCONTIN+4,C' '     SET UP BLANK TO PROPOGATE   @OZ16672
         B     IBLDBUFS            GO BUILD BUFFERS AND SIGN-ON
IWRDRES  DC    AL1(XSOH,XENQ)      IDENTIFY AS CPU TERMINAL
IREADRES DC    AL2(0)              RESPONSE CHARACTERS FROM HASP
IBACK    NULL  *                   NOT BSCA INTERRUPT
         SPSW  144                 RETURN
         ORG   INIPONE+2                                       @OZ16672
.IMODXX  ANOP
         EJECT
         LTORG
         EJECT
         SPACE 20
$L       EQU   *-HASPRJE+&HRTPORG
$L1      EQU   $L/100000*100000
$L2      EQU   ($L-$L1)/10000*10000
$L3      EQU   ($L-$L1-$L2)/1000*1000
$L4      EQU   ($L-$L1-$L2-$L3)/100*100
$L5      EQU   ($L-$L1-$L2-$L3-$L4)/10*10
$L6      EQU   $L-$L1-$L2-$L3-$L4-$L5
         SPACE 3
*
*                  THE FOLLOWING VALUE OF $DLENGTH INDICATES THE
*                  MINIMUM MEMORY SIZE TO CONTAIN THIS PROGRAM.
*                  THE VALUE REPRESENTS THE DECIMAL VALUE
*
$DLENGTH EQU   $L1/100000*1048576+$L2/10000*65536+$L3/1000*4096+$L4/100C
               *256+$L5/10*16+$L6
 TITLE 'H A S P REMOTE TERMINAL PROCESSOR DEBUGGING AID PAGE '
***********************************************************************
         SPACE 1
*                       SIGNIFICANT LOCATION ADDRESSES
         SPACE 1
$01   EQU   CBUFFER           CURRENTLY ACTIVE COMMUNICATIONS BUFFER  $
         AIF   (&TRACE EQ 0).INFO1
$02   EQU   $TRACUR           CURRENT LOCATION IN TRACE TABLE         $
.INFO1   ANOP
$03   EQU   $TANK1            START OF DECOMPRESSION TANKS            $
$04   EQU   $1STBUF           BEGINNING OF COMMUNICATIONS BUFFER POOL $
$05   EQU   $BUFPOOL          FREE BUFFER CHAIN START                 $
$06   EQU   $TANKPOL          FREE DECOMPRESSION TANK CHAIN START     $
$08   EQU   $OUTBUF           BUFFERS AWAITING TRANSMISSION           $
$09      EQU   $FCSOUT             FUNCTION-CONTROL-SEQUENCE          $
$10   EQU   COMWRITE          LAST TP WRITE COMMAND                   $
$11   EQU   $LOGCLAS          ERROR LOG CLASS LEVEL                   $
         SPACE 1
***********************************************************************
         SPACE 2
*                       M O D E L  2 0  -  BSCA SENSE BYTES           $
         SPACE 1
*              00 = UNDEFINED
*              01 = DATA OVER-RUN ON A WRITE
*              02 = CPU-BSCA PARITY CHECK ON WRITE
*              04 = MAIN STORAGE EXCEEDED ON WRITE
*              08 = NO ENDING SEQUENCE FOUND ON WRITE
*              10 = NOT DEFINED
*              20 = NOT DEFINED
*              40 = EOT RECEIVED WHILE WRITING
*              80 = NOT DEFINED
*              81 = DATA OVER-RUN ON READ
*              82 = NOT DEFINED
*              84 = MAIN STORAGE EXCEEDED ON READ
*              88 = LOST DATA ON READ
*              90 = READ TIMEOUT
*              A0 = DATA CHECK ON READ
*              C0 = EOT RECEIVED ON READ
         SPACE 2
*                       H A S P  E R R O R  L O G  C O D E S
         SPACE 1
*              00 = TRACE ENTRY (NOT LOGGED)
*              01 = BLOCK COUNT CHECK
*              02 = NEGATIVE ACKNOWLEDGEMENT RECEIVED
*              03 = UNKNOWN RESPONSE RECEIVED
*              04 = EOT RECEIVED
*              05 = UNIT CHECK
*              06 = UNUSUAL CHANNEL END
*              07 = SIO FAILURE (360 ONLY)
*              08 = ADAPTER WRITE LOGGING ( 360 ONLY )
*              09 = ALL COMMUNICATIONS INTERRUPTS
         EJECT
         SPACE 5
***********************************************************************
*                                                                     *
*        EIGHT CHARACTER ERROR MESSAGE CODES                          *
*                                                                     *
*              01 = BLOCK COUNT CHECK (DUPLICATE OR LOST RECORDS)     *
*                   01IIEE00         II= INPUT BLOCK CHECK FROM HASP  *
*                                    EE= EXPECTED BLOCK CHECK         *
*                                                                     *
*              02 = NEGATIVE ACKNOWLEDGEMENT RECEIVED                 *
*                   02000000                                          *
*                                                                     *
*              03 = UNKNOWN RESPONSE RECEIVED                         *
*                   03IIII00       IIII= DATA BYTES 1,2 OF INPUT.     *
*                                  ( IF CORRECT CONTROL SEQUENCE      *
*                                  ENDING SEQUENCE IS INVALID )       *
*                                                                     *
*              04 = UNIT EXCEPTION - EOT RECEIVED                     *
*                   0400AAAA       AAAA= DEVICE ADDRESS. 0 FOR BSCA   *
*                                                                     *
*              05 = UNIT CHECK                                        *
*                   05SSAAAA         SS= SENSE BYTE                   *
*                                  AAAA= DEVICE ADDRESS. 0 FOR BSCA   *
*                                                                     *
*              06 = UNUSUAL END                                       *
*                   06CCAAAA         CC= CSW BYTE 5                   *
*                                  AAAA= DEVICE ADDRESS. 0 FOR BSCA   *
*                                                                     *
*              07 = SIO FAILURE                                       *
*                   07000000                                          *
*                                                                     *
*              08 = ADAPTER WRITE LOGGING                             *
*                   08OOOOOO       OOOOOO= BYTES 2,3,4 OF OUTPUT DATA *
*                                                                     *
*              09 = ALL COMMUNICATION ADAPTER INTERRUPTS              *
*                   09IIIIII       IIIIII= BYTES 2,3,4 OF INPUT DATA  *
*                                                                     *
***********************************************************************
         EJECT
APARNUM  DC    CL5'84440'          APAR NUMBER
         END   $REPLOAD
