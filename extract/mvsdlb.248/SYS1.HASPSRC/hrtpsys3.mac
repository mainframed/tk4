         TITLE 'HASP SYSTEM/3 REMOTE JOB ENTRY WORKSTATION'
***********************************************************************
*                                                                     *
* MODULE NAME = HRTPSYS3                                              *
*                                                                     *
* DESCRIPTIVE NAME = SYSTEM/3 WORK STATION PROGRAM                    *
*                                                                     *
* COPYRIGHT = NONE                                                    *
*                                                                     *
* STATUS = OS/VS2 RELEASE 2, LEVEL 0                                  *
*                                                                     *
* FUNCTION = TO PROVIDE THE SYSTEM/3 WORK STATION COMPONENT FOR RJE   *
*            IMPLEMENTATION USING THE MULTI-LEAVING DISCIPLINE OF     *
*            RTAM.  THIS PROGRAM EXTENDS TO THE REMOTE LOCATION THE   *
*            FACILITIES OF LOCAL DEVICES SUCH AS OPERATOR CONSOLE     *
*            TYPEWRITER, CARD READER(S), CARD PUNCH(ES), HIGH SPEED   *
*            LINE PRINTER.  THE MODULE OPERATES IN A STAND-ALONE      *
*            ENVIRONMENT AND REQUIRES NO EXTERNAL SUPPORT PROGRAM.    *
*            THE SOURCE CODE IS ASSEMBLED USING THE OS/VS2 ASSEMBLER  *
*            F PROGRAM IN ORDER TO SHARE THE GENERATION PARAMETERS    *
*            USED TO QUALIFY THE HOST SYSTEM.  FOR AN EXPLANATION OF  *
*            THE INTERNAL PROGRAM OPERATION SEE OS/VS2 JES2 LOGIC.    *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*    DEPENDENCIES = RTAM MULTI-LEAVING PROTOCOL                       *
*                                                                     *
*    RESTRICTIONS = NONE                                              *
*                                                                     *
*    REGISTER CONVENTIONS = SEE SYMBOLIC REGISTERS UNDER GENERAL      *
*                           EQUATES                                   *
*                                                                     *
*    PATCH LABEL = NONE                                               *
*                                                                     *
* MODULE TYPE = STAND-ALONE PROGRAM                                   *
*                                                                     *
*    PROCESSOR = ASSEMBLER F                                          *
*                                                                     *
*    MODULE SIZE = AS SPECIFIED BY RMTGEN PARAMETER &MACHSIZ          *
*                                                                     *
*    ATTRIBUTES = STAND-ALONE                                         *
*                                                                     *
* ENTRY POINT = $INIT                                                 *
*                                                                     *
*    PURPOSE = SEE FUNCTION                                           *
*                                                                     *
*    LINKAGE = ENTERED FROM SYSTEM/3 LOAD PROGRAM VIA END CARD LABEL  *
*                                                                     *
* INPUT = (1) OS/VS2 JOBSTREAM VIA 96 OR 80 COL. CARD READER          *
*         (2) OPERATOR COMMANDS VIA TYPEWRITER KEYBOARD OR CARD READE *
*         (3) MULTI-LEAVING BLOCKS VIA T/P LINE FROM HOST PROCESSOR   *
*                                                                     *
* OUTPUT = (1) SYSTEM DIRECTED OUTPUT FROM HOST PROCESSOR VIA HIGH    *
*              SPEED LINE PRINTER, 80, OR 96 COL. CARD PUNCH          *
*          (2) RESPONSES TO OPERATOR COMMANDS VIA TYPEWRITER PRINTER  *
*              OR HIGH SPEED LINE PRINTER                             *
*          (3) MULTI-LEAVING BLOCKS VIA T/P LINE TO HOST PROCESSOR    *
*          (4) LOCALLY GENERATED OPERATOR MESSAGES                    *
*                                                                     *
* EXIT-NORMAL = NONE                                                  *
*                                                                     *
* EXIT-ERROR = NONE                                                   *
*                                                                     *
* EXTERNAL REFERENCES = NONE                                          *
*                                                                     *
*    ROUTINES = NONE                                                  *
*                                                                     *
*    DATA AREAS = NONE                                                *
*                                                                     *
*    CONTROL AREAS = NONE                                             *
*                                                                     *
* TABLES = (1) FUNCTION BLOCK - SEE LABEL FBD                         *
*          (2) HOPPER CONTROL AREA - SEE LABEL HCD                    *
*                                                                     *
* MACROS = ALL MACROS ARE LOCAL TO THE ASSEMBLY                       *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*     RELEASE 4.0 = NONE                                              *
*                                                                     *
*     RELEASE 4.1 = OZ13263                                           *
*                                                                     *
***********************************************************************
         PRINT OFF
         TITLE 'SYSTEM/3 MACROES'
         MACRO
&N       $X1   &A,&B,&L,&OP
         GBLC  &BASE
         LCLB  &O1,&O2,&OX,&OY,&LX
         LCLC  &BA,&BB
         LCLC  &XA,&XB,&XC,&YA,&YB,&YC
         LCLC  &Z
.*
.*
.*
         AIF   (T'&L NE 'O').AST
&Z       SETC  '0'
         AGO   .SETLX
.AST     AIF   ('&L' NE '*-*').NUM
&Z       SETC  '0'
         AGO   .SETLX
.NUM     AIF   (&OP NE 8).ZRO
&Z       SETC  '&L'
         AGO   .SETLX
.ZRO     AIF   (T'&L NE 'N').NOTLX
         AIF   (&L NE 0).NOTLX
.SETLX   ANOP
&LX      SETB  1
.NOTLX   ANOP
&O1      SETB  (N'&A EQ 2)
&O2      SETB  (N'&B EQ 2)
&OX      SETB  (N'&A EQ 1)
&OY      SETB  (N'&B EQ 1)
.*
.*
.*
         AIF   (&O1 OR &OX).OK1
         MNOTE 8,'ILLEGAL FIRST OPERAND - &A'
         AGO   .ERROR
.OK1     AIF   (&O2 OR &OY).OK2
         MNOTE 8,'ILLEGAL SECOND OPERAND - &B'
         AGO   .ERROR
.*
.*
.*
.OK2     AIF   (&OX).B                 BR IF NO BASE IN OP 1
         $BASE &A(2)                   SEE IF THERE'S A 'USING'
         AIF   ('&BASE' EQ '0').B      BR IF NO CORRESPOINDNG 'USING'
&XA      SETC  '-('
&XB      SETC  '&BASE'
&XC      SETC  ')'
.*
.*
.*
.B       AIF   (&OY).C                 BR IF NO BASE IN OP 2
         $BASE &B(2)                   SEE IF THERE'S A 'USING'
         AIF   ('&BASE' EQ '0').C      NOPE - BRANCH.
&YA      SETC  '-('
&YB      SETC  '&BASE'
&YC      SETC  ')'
.*
.*
.*
.C       AIF   (&O1 AND &O2).BOTH
         AIF   (&O1).FIRST
         AIF   (&O2).SECOND
.*
.*
.*
         AIF   (&LX).NONE0
&N       DC    YL1(&OP,&L-1),YL2(&A,&B)
         MEXIT
.NONE0   ANOP
&N       DC    YL1(&OP,&Z),YL2(&A,&B)
         MEXIT
.*
.*
.*
.BOTH    AIF   (&LX).BOTH0
&N       DC    YL.2(&A(2),&B(2)),YL.4(&OP),YL1(&L-1,&A(1)&XA&XB&XC,&B(1C
               )&YA&YB&YC)
         MEXIT
.BOTH0   ANOP
&N       DC    YL.2(&A(2),&B(2)),YL.4(&OP),YL1(&Z,&A(1)&XA&XB&XC,&B(1)&C
               YA&YB&YC)
         MEXIT
.*
.*
.*
.FIRST   AIF   (&LX).FIRST0
&N       DC    YL.2(&A(2),0),YL.4(&OP),YL1(&L-1,&A(1)&XA&XB&XC),YL2(&B)
         MEXIT
.FIRST0  ANOP
&N       DC    YL.2(&A(2),0),YL.4(&OP),YL1(&Z,&A(1)&XA&XB&XC),YL2(&B)
         MEXIT
.*
.*
.*
.SECOND  AIF   (&LX).SECOND0
&N       DC    YL.2(0,&B(2)),YL.4(&OP),YL1(&L-1),YL2(&A),YL1(&B(1)&YA&YC
               B&YC)
         MEXIT
.SECOND0 ANOP
&N       DC    YL.2(0,&B(2)),YL.4(&OP),YL1(&Z),YL2(&A),YL1(&B(1)&YA&YB&C
               YC)
         MEXIT
.ERROR   ANOP
&N       DC    XL6'0'              *****  E R R O R  *****
         MEND
         MACRO
&N       $Y    &A,&B,&OP
         GBLC  &BASE
         LCLC  &XA,&XB,&XC
         AIF   (N'&A EQ 1).ONE     NO BASE SPECIFIED
         AIF   (N'&A EQ 2).TWO     BSE IS SPECIFIED.
         MNOTE 8,'ILLEGAL FIRST OPERAND - &A'
&N       DC    AL4(0)              *****  E R R O R  *****
         MEXIT
.ONE     ANOP
&N       DC    YL.4(3,&OP),YL1(&B),YL2(&A)
         MEXIT
.TWO     $BASE &A(2)
         AIF   ('&BASE' EQ '0').DOIT
&XA      SETC  '-('
&XB      SETC  '&BASE'
&XC      SETC  ')'
.DOIT    ANOP
&N       DC    YL.4(3+&A(2)*4,&OP),YL1(&B,&A(1)&XA&XB&XC)
         MEND
         MACRO
&N       $Z    &A,&B,&OP
         GBLC  &BASE
         LCLC  &XA,&XB,&XC
         AIF   (N'&A EQ 1).ONE     NO BASE SPECIFIED.
         AIF   (N'&A EQ 2).TWO     BASE IS SPECIFIED.
         MNOTE 8,'ILLEGAL FIRST OPERAND - &A'
&N       DC    AL4(0)              *****  E R R O R  *****
         MEXIT
.ONE     ANOP
&N       DC    YL.4(12,&OP),YL1(&B),YL2(&A)
         MEXIT
.TWO     $BASE &A(2)
         AIF   ('&BASE' EQ '0').DOIT
&XA      SETC  '-('
&XB      SETC  '&BASE'
&XC      SETC  ')'
.DOIT    ANOP
&N       DC    YL.4(12+&A(2),&OP),YL1(&B,&A(1)&XA&XB&XC)
         MEND
         MACRO
         $USING &A,&B
         GBLC  &X(2),&Y(2)
         LCLA  &N
         LCLC  &W
         AIF   ('&Y(1)' NE '&B' AND '&Y(2)' NE '&B').OK
&N       SETA  1
         AIF   ('&Y(1)' EQ '&B').SET
&N       SETA  2
         AGO   .SET
.OK      ANOP
&N       SETA  &N+1
         AIF   (&N GT 2).ERR
         AIF   ('&X(&N)' NE '').OK
&Y(&N)   SETC  '&B'
.SET     AIF   ('&A'(1,1) NE '*').NA
&W       SETC  '&A'(2,K'&A-1)
$&SYSNDX EQU   *&W
&X(&N)   SETC  '$&SYSNDX'
         MEXIT
.ERR     MNOTE 8,'MORE THAN 2 CHARACTERS IN ''&B''.  ''$USING'' IGNOREDC
               .'
         MEXIT
.NA      AIF   (K'&A LE 8 AND K'&A GT 0).DO
         MNOTE 8,'MORE THAN 8 CHARACTERS IN ''&A''.  ''$USING'' IGNOREDC
               .'
         MEXIT
.DO      ANOP
&X(&N)   SETC  '&A'
         MEND
         MACRO
         $DROP &A,&B
         GBLC  &X(2),&Y(2)
         LCLA  &M,&N
         LCLC  &S(2)
         LCLC  &C(2)
&C(1)    SETC  '&A'
&C(2)    SETC  '&B'
&M       SETA  1
.GO      ANOP
&N       SETA  &N+1
         AIF   (&N GT 2).ERR
         AIF   ('&C(&M)' NE '&Y(&N)').GO
&X(&N)   SETC  ''
&Y(&N)   SETC  ''
         AGO   .NXT
.ERR     MNOTE 4,'SYMBOL ''&C(&M)'' IS NOT A BASE SYMBOL'
.NXT     AIF   (&M EQ 2).END
&M       SETA  2
&N       SETA  0
         AGO   .GO
.END     MEND
         MACRO
         $BASE &A
         GBLC  &BASE,&X(2),&Y(2)
&BASE    SETC  '0'
         AIF   ('&Y(1)' EQ '&A').ONE
         AIF   ('&Y(2)' EQ '&A').TWO
         MEXIT
.ONE     ANOP
&BASE    SETC  '&X(1)'
         MEXIT
.TWO     ANOP
&BASE    SETC  '&X(2)'
         MEND
         MACRO
         $QBYTE &DA,&M,&N
         GBLA  &S3BSCA
         GBLC  &QBYTE
         LCLA  &A
&QBYTE   SETC  '(&DA)*16+(&M)*8+(&N)'
         AIF   (T'&DA NE 'N' OR T'&M NE 'N' OR T'&N NE 'N').END
&A       SETA  &DA*16+&M*8+&N
&QBYTE   SETC  '&A'
         AIF   (&DA NE 8).END
&A       SETA  &DA*16+(&S3BSCA-1)*8+&N
&QBYTE   SETC  '&A'
.END     MEND
         MACRO
&N       $ALC  &A,&B,&L                $ALC   - ADD LOGICAL CHARACTERS
&N       $X1   &A,&B,&L,14
         MEND
         MACRO
&N       $SLC  &A,&B,&L                $SLC   - SUBTRACT LOGICAL CHARAC
&N       $X1   &A,&B,&L,15
         MEND
         MACRO
&N       $MVX  &A,&B,&Q                $MVX   - MOVE HEX CHARACTERS
&N       $X1   &A,&B,&Q,8
         MEND
         MACRO
&N       $MVC  &A,&B,&L                $MVC   - MOVE CHARACTERS
&N       $X1   &A,&B,&L,12
         MEND
         MACRO
&N       $ED   &A,&B,&L1               $ED    - EDIT
&N       $X1   &A,&B,&L1,10
         MEND
         MACRO
&N       $ITC  &A,&B,&L1               $ITC   - INSERT & TEST CHARS
&N       $X1   &A,&B,&L1,11
         MEND
         MACRO
&N       $CLC  &A,&B,&L                $CLC   - COMPARE LOGICAL CHARS
&N       $X1   &A,&B,&L,13
         MEND
         MACRO
&N       $J    &A                      $J     - JUMP UNCONDITIONAL
&N       $JC   &A,0
         MEND
         MACRO
&N       $JH   &A                      $JH    - JUMP IF HIGH
&N       $JC   &A,132
         MEND
         MACRO
&N       $JL   &A                      $JL    - JUMP IF LOW
&N       $JC   &A,130
         MEND
         MACRO
&N       $JE   &A                      $JE    - JUMP IF EQUAL
&N       $JC   &A,129
         MEND
         MACRO
&N       $JNH  &A                      $JNH   - JUMP IF NOT HIGH
&N       $JC   &A,4
         MEND
         MACRO
&N       $JNL  &A                      $JNL   - JUMP IF NOT LOW
&N       $JC   &A,2
         MEND
         MACRO
&N       $JNE  &A                      $JNE   - JUMP IF NOT EQUAL
&N       $JC   &A,1
         MEND
         MACRO
&N       $JOZ  &A                      $JOZ   - JUMP IF OVERFLOW ZONED
&N       $JC   &A,136
         MEND
         MACRO
&N       $JOL  &A                      $JOL   - JUMP IF OVFLOW LOGICAL
&N       $JC   &A,160
         MEND
         MACRO
&N       $JNOZ &A                      $JNOZ  - JUMP NOT OVERFLOW ZONED
&N       $JC   &A,8
         MEND
         MACRO
&N       $JNOL &A                      $JNOL  - JUMP NOT OVFLOW LOGICAL
&N       $JC   &A,32
         MEND
         MACRO
&N       $JT   &A                      $JT    - JUMP IF TRUE
&N       $JC   &A,16
         MEND
         MACRO
&N       $JF   &A                      $JF    - JUMP IF FALSE
&N       $JC   &A,144
         MEND
         MACRO
&N       $JP   &A                      $JP    - JUMP IF PLUS
&N       $JC   &A,132
         MEND
         MACRO
&N       $JM   &A                      $JM    - JUMP IF MINUS
&N       $JC   &A,130
         MEND
         MACRO
&N       $JZ   &A                      $JZ    - JUMP IF ZERO
&N       $JC   &A,129
         MEND
         MACRO
&N       $JNP  &A                      $JNP   - JUMP IF NOT PLUS
&N       $JC   &A,4
         MEND
         MACRO
&N       $JNM  &A                      $JNM   - JUMP IF NOT MINUS
&N       $JC   &A,2
         MEND
         MACRO
&N       $JNZ  &A                      $JNZ   - JUMP IF NOT ZERO
&N       $JC   &A,1
         MEND
         MACRO
&N       $NOPJ &A                      $NOPJ  - NEVER JUMP
&N       $JC   &A,128
         MEND
         MACRO
&N       $A    &R,&A                   $A     - ADD TO REGISTER
&N       $Y    &A,&R,6
         MEND
         MACRO
&N       $MVI  &A,&I                   $MVI   - MOVE LOGICAL IMMEDIATE
&N       $Y    &A,&I,12
         MEND
         MACRO
&N       $SBN  &A,&M                   $SBN   - SET BITS ON
&N       $Y    &A,&M,10
         MEND
         MACRO
&N       $SBF  &A,&M                   $SBF   - SET BITS OFF
&N       $Y    &A,&M,11
         MEND
         MACRO
&N       $ST   &R,&A                   $ST    - STORE REGISTER
&N       $Y    &A,&R,4
         MEND
         MACRO
&N       $L    &R,&A                   $L     - LOAD REGISTER
&N       $Y    &A,&R,5
         MEND
         MACRO
&N       $LA   &R,&A                   $LA    - LOAD ADDRESS
&N       $Z    &A,&R,2
         MEND
         MACRO
&N       $CLI  &A,&I                   $CLI   - COMPARE LOGICAL IMMED
&N       $Y    &A,&I,13
         MEND
         MACRO
&N       $TBN  &A,&M                   $TBN   - TEST BITS ON
&N       $Y    &A,&M,8
         MEND
         MACRO
&N       $TBF  &A,&M                   $TBF   - TEST BITS OFF
&N       $Y    &A,&M,9
         MEND
         MACRO
&NA      $SNS  &DA,&M,&N,&A            $SNS   - SENSE INPUT/OUTPUT
         GBLC  &QBYTE
         $QBYTE &DA,&M,&N
&NA      $Y    &A,&QBYTE,0
         MEND
         MACRO
&NA      $LIO  &DA,&M,&N,&A            $LIO   - LOAD INPUT/OUTPUT
         GBLC  &QBYTE
         $QBYTE &DA,&M,&N
&NA      $Y    &A,&QBYTE,1
         MEND
         MACRO
&NA      $TIO  &DA,&M,&N,&A            $TIO   - TEST INPUT/OUTPUT
         GBLC  &QBYTE
         $QBYTE &DA,&M,&N
&NA      $Z    &A,&QBYTE,1
         MEND
         MACRO
&N       $JC   &A,&Q                   $JC    - JUMP ON CONDITION
&N       DC    AL1(242,&Q,&A-*-1)
         MEND
         MACRO
&N       $BC   &A,&Q                   $BC    - BRANCH ON CONDITION
&N       $Z    &A,&Q,0
         MEND
         MACRO
&NA      $SIO  &DA,&M,&N,&CC           $SIO   - START INPUT/OUTPUT
         GBLC  &QBYTE
         $QBYTE &DA,&M,&N
&NA      DC    AL1(243,&QBYTE,&CC)
         MEND
         MACRO
&NA      $APL  &DA,&M,&N               $APL   - ADVANCE PROGRAM LEVEL
&NA      DC    X'F1',AL.4(&DA),AL.1(&M),AL.3(&N),X'0'
         MEND
         MACRO
&N       $B    &A                      $B     - BRANCH UNCONDITIONAL
&N       $BC   &A,0
         MEND
         MACRO
&N       $BH   &A                      $BH    - BRANCH IF HIGH
&N       $BC   &A,132
         MEND
         MACRO
&N       $BL   &A                      $BL    - BRANCH IF LOW
&N       $BC   &A,130
         MEND
         MACRO
&N       $BE   &A                      $BE    - BRANCH IF EQUAL
&N       $BC   &A,129
         MEND
         MACRO
&N       $BNH  &A                      $BNH   - BRANCH IF NOT HIGH
&N       $BC   &A,4
         MEND
         MACRO
&N       $BNL  &A                      $BNL   - BRANCH IF NOT LOW
&N       $BC   &A,2
         MEND
         MACRO
&N       $BNE  &A                      $BNE   - BRANCH IF NOT EQUAL
&N       $BC   &A,1
         MEND
         MACRO
&N       $BOZ  &A                      $BOZ   - BRANCH OVERFLOW ZONED
&N       $BC   &A,136
         MEND
         MACRO
&N       $BOL  &A                      $BOL   - BRANCH OVERFLOW LOGICAL
&N       $BC   &A,160
         MEND
         MACRO
&N       $BNOZ &A                      $BNOZ  - BRANCH NOT OVFLOW ZONED
&N       $BC   &A,8
         MEND
         MACRO
&N       $BNOL &A                      $BNOL  - BRANCH NOT OFLO LOGICAL
&N       $BC   &A,32
         MEND
         MACRO
&N       $BT   &A                      $BT    - BRANCH IF TRUE
&N       $BC   &A,16
         MEND
         MACRO
&N       $BF   &A                      $BF    - BRANCH IF FALSE
&N       $BC   &A,144
         MEND
         MACRO
&N       $BP   &A                      $BP    - BRANCH IF PLUS
&N       $BC   &A,132
         MEND
         MACRO
&N       $BM   &A                      $BM    - BRANCH IF MINUS
&N       $BC   &A,130
         MEND
         MACRO
&N       $BZ   &A                      $BZ    - BRANCH IF ZERO
&N       $BC   &A,129
         MEND
         MACRO
&N       $BNP  &A                      $BNP   - BRANCH IF NOT PLUS
&N       $BC   &A,4
         MEND
         MACRO
&N       $BNM  &A                      $BNM   - BRANCH IF NOT MINUS
&N       $BC   &A,2
         MEND
         MACRO
&N       $BNZ  &A                      $BNZ   - BRANCH IF NOT ZERO
&N       $BC   &A,1
         MEND
         MACRO
&N       $NOPB &A                      $NOPB  - NEVER BRANCH
&N       $BC   &A,128
         MEND
         MACRO
&N       $MZZ  &A,&B                   $MZZ   - MOVE TO ZONE FROM ZONE
&N       $X1   &A,&B,0,8
         MEND
         MACRO
&N       $MNZ  &A,&B                   $MNZ   - MOVE TO NUM FROM ZONE
&N       $X1   &A,&B,2,8
         MEND
         MACRO
&N       $MZN  &A,&B                   $MZN   - MOVE TO ZONE FROM NUM
&N       $X1   &A,&B,1,8
         MEND
         MACRO
&N       $MNN  &A,&B                   $MNN   - MOVE TO NUM FROM NUM
&N       $X1   &A,&B,3,8
         MEND
         MACRO
&L       $WAIT &EVENT
&L       $SBN  (FBEWF,FBR),EWF&EVENT
         $B    $COMRET
         MEND
         MACRO
&L       $DC
         LCLA  &N
.GO      ANOP
&N       SETA  &N+1
         DC    &SYSLIST(&N)
         AIF   (N'&SYSLIST GT &N).GO
         AIF   ('&L' EQ '').END
&L       EQU   *-1
.END     MEND
         MACRO
&L       $DS
         LCLA  &N
.GO      ANOP
&N       SETA  &N+1
         DS    &SYSLIST(&N)
         AIF   (N'&SYSLIST GT &N).GO
         AIF   ('&L' EQ '').END
&L       EQU   *-1
.END     MEND
         MACRO
&L       $POST &FB,&EVENT
         AIF   ('&FB' EQ '*').ASTER
&L       $SBF  FBEWF+&FB-FBD,EWF&EVENT
         MEXIT
.ASTER   ANOP
&L       $SBF  (FBEWF,FBR),EWF&EVENT
         MEND
         MACRO
&L       $HPL  &A
         LCLC  &C(22),&D(22),&X
         LCLA  &N
&C(01)   SETC  '1'
&C(02)   SETC  '2'
&C(03)   SETC  '3'
&C(04)   SETC  '4'
&C(05)   SETC  '5'
&C(06)   SETC  '6'
&C(07)   SETC  '7'
&C(08)   SETC  '8'
&C(09)   SETC  '9'
&C(10)   SETC  '0'
&C(11)   SETC  'A'
&C(12)   SETC  'B'
&C(13)   SETC  'C'
&C(14)   SETC  'D'
&C(15)   SETC  'E'
&C(16)   SETC  'F'
&C(17)   SETC  'H'
&C(18)   SETC  'J'
&C(19)   SETC  'L'
&C(20)   SETC  'P'
&C(21)   SETC  'U'
&C(22)   SETC  '*'
&D(01)   SETC  '28'
&D(02)   SETC  '76'
&D(03)   SETC  '57'
&D(04)   SETC  '1B'
&D(5)    SETC  '5D'
&D(06)   SETC  '7D'
&D(07)   SETC  '07'
&D(08)   SETC  '7F'
&D(09)   SETC  '5F'
&D(10)   SETC  '6F'
&D(11)   SETC  '3F'
&D(12)   SETC  '78'
&D(13)   SETC  '6C'
&D(14)   SETC  '73'
&D(15)   SETC  '7C'
&D(16)   SETC  '3C'
&D(17)   SETC  '3B'
&D(18)   SETC  '63'
&D(19)   SETC  '68'
&D(20)   SETC  '3E'
&D(21)   SETC  '6B'
&D(22)   SETC  '00'
.*
.*
.*
         AIF   (K'&A EQ 2 AND N'&SYSLIST EQ 1).ONE
         MNOTE 8,'*** INVALID $HPL ARGUMENT ***'
         MEXIT
.ONE     ANOP
&N       SETA  &N+1
         AIF   ('&A'(1,1) EQ '&C(&N)').ONE1
         AIF   (&N LT 22).ONE
.ERR     MNOTE 8,'*** INVALID $HPL CODE ***'
&L       DC    X'F07373'
         MEXIT
.ONE1    ANOP
&X       SETC  '&D(&N)'
&N       SETA  0
.TWO     ANOP
&N       SETA  &N+1
         AIF   ('&A'(2,1) EQ '&C(&N)').TWO1
         AIF   (&N LT 22).TWO
         AGO   .ERR
.TWO1    ANOP
&L       DC    X'F0&X&D(&N)'
         MEND
         MACRO
&NAME    $FB   &ENT=,&R1=0,&EWF=0,&SHORT=NO,&FLG=0,&BUF=0,&BMX=1,      C
               &FCS=0,&RCB=0,&WORK=0
         GBLA  &FBNR,&FBN
&FBNR    SETA  &FBNR+1
&FBN     SETA  &FBNR+1
         SPACE 5
$FB&FBNR EQU   *
         AIF   ('&NAME' EQ '').FB
$FB&NAME EQU   *
         MNOTE *,'* * *  FUNCTION BLOCK FOR &NAME  * * *'
         SPACE 2
.FB      DC    YL2($FB&FBN)        POINTER TO NEXT FUNCTION BLOCK.
         DC    YL2(&ENT)           ENTRY ADDRESS FOR THIS FUNCTION.
         DC    YL2(&R1)            SAVE AREA FOR REGISTER 1.
         DC    YL1(&EWF)           EVENT WAIT FIELD.
         AIF   ('&SHORT' NE 'NO').END
         DC    YL1(&FLG)           FUNCTION FLAGS BYTE.
         DC    YL2(0)              SUBROUTINE RETURN ADDRESS SAVE.
         DC    YL2(&BUF)           BUFFER QUEUEING POINTER.
         DC    YL1(0)              CURRENT COUNT OF BUFFERS.
         DC    YL1(&BMX)           MAXIMUM COUNT OF BUFFERS.
         DC    YL2(&FCS)           FUNCTION CONTROL SEQUENCE BIT.
         DC    YL1(&RCB)           RECORD CONTROL BYTE.
         DC    (&WORK)X'0'         OPTIONAL WORK AREA.
.END     MEND
         MACRO
&L       $HCA  &DEV=,&RDB=,&PUB=,&FLG=0,&LOG=,&RDS=,&PUS=,&TIO=,       C
               &LOG1=,&LOG2=
&L       EQU   *
         DC    YL2(0)              HCFBP - POINTER TO LOGICAL DEVICE FB
         DC    YL2(&RDB)           HCRDB - POINTER TO READ BUFFER
         DC    YL2(&PUB)           HCPUB - POINTER TO PUNCH BUFFER
         DC    YL1(&FLG)           HCFLG - FLAG BYTE
         DC    &TIO                HCTIO - DA, M, N FOR TIO
         DC    YL2(0,0,0,0)        HCRETX - FOUR RETURN ADDRESSES
         DC    YL2(0)              HCSNS - AREA FOR STATUS BYTES
         AIF   ('&DEV' EQ '1442').EIGHTY   BR IF 1442 READER/PUNCH.
         DC    YL2(&LOG,0,0)       HCLOG - ARGUMENTS TO $LOG
         DC    &RDS                HCRDS - Q, CC FOR READ SIO
         DC    &PUS                HCPUS - Q, CC FOR PUNCH SIO
         DC    YL2(0)              HCSIO - Q, CC FOR CURRENT SIO
         MEXIT
.EIGHTY  DC    YL2(0)              HCPLN - NUMBER OF BYTES TO PUNCH
         DC    AL3(&LOG1),AL4(0)   HCLOG1 - FIRST $LOG ARGUMENT LIST
         DC    AL3(&LOG2),AL4(0)   HCLOG2 - SECOND $LOG ARGUMENT LIST
         MEND
         MACRO
&L       $IHMSG &A,&B
         LCLA  &K,&X
&K       SETA  K'&B-3              LENGTH-1 OF CHARS WITHIN QUOTES
         AIF   ('&A' EQ 'T').TITLE BRANCH IF THIS IS TITLE TEXT.
&L       DC    YL1(&K),C'&A',C&B
         MEXIT
.TITLE   ANOP
&K       SETA  &K+128
&X       SETA  48+K'&B/2
&L       DC    YL1(&K),YL2(LPDA+&X)
         DC    C&B
         MEND
         MACRO
         $END  &START=
ORG&SYSNDX EQU *
         ORG   &SYSECT
         AIF   ('&START' EQ '').NOOP
         DC    A(&START),C'$$$$ PSEUDO-END CARD $$$$'
         ORG   ORG&SYSNDX
         MEXIT
.NOOP    DC    C'    $$$$ PSEUDO-END CARD $$$$'
         ORG   ORG&SYSNDX
         MEND
         MACRO
&L       $SIGNON &REMOTE=,&PASSWD=,&DIAL=
         LCLC  &R,&P
*                                                                     *
***********************************************************************
*                                                                     *
*                      DEFAULT /*SIGNON CARD                          *
*                                                                     *
***********************************************************************
*                                                                     *
&L       DC    X'0102A08F8F'       SOH, STX, BCB, FCS, FCS
         DC    YL1(X'F0',C'A')     RCB, SRCB
         AIF   (&REMOTE GE 10).RMT10
&R       SETC  ' '
.RMT10   ANOP
&P       SETC  '        '(1,8-K'&PASSWD)
$SIGNON  EQU   *
         AIF   ('&DIAL' EQ '').NODIAL
         DC    CL80'/*SIGNON       REMOTE&REMOTE&R &PASSWD&P DIAL &DIALC
               ',YL1(ETB)
         MEXIT
.NODIAL  DC    CL80'/*SIGNON       REMOTE&REMOTE&R &PASSWD&P',YL1(ETB)
.*
         MEND
         PRINT ON
         TITLE 'HRTPSYS3 - GLOBAL SYMBOL DEFINITIONS'
*                                                                     *
***********************************************************************
*                                                                     *
*              HARDWARE DEFINITIONS                                   *
*                                                                     *
***********************************************************************
*                                                                     *
         GBLA  &MACHSIZ            SIZE OF CORE STORAGE
         GBLA  &S3BSCA             BSC ADAPTER NUMBER
         GBLB  &S3XPAR             HARDWARE TRANSPARENCY
         GBLB  &S35424             5424 MFCU
         GBLB  &S31442             1442 CARD READ-PUNCH
         GBLB  &S35471             5471 PRINTER-KEYBOARD
         GBLB  &S35475             5475 DATA ENTRY KEYBOARD
*                                                                     *
***********************************************************************
*                                                                     *
*              PRINTER SPECIFICATION                                  *
*                                                                     *
***********************************************************************
*                                                                     *
         GBLA  &S3FORML            LENGTH OF FORMS
         GBLA  &PC(12)             CARRIAGE CONTROL
         GBLA  &PRTCONS            5203 PRINTER AS OUTPUT CONSOLE
*                                                                     *
***********************************************************************
*                                                                     *
*              TELECOMMUNICATION SPECIFICATIONS                       *
*                                                                     *
***********************************************************************
*                                                                     *
         GBLA  &RMTID              HASP REMOTE NUMBER
         GBLA  &TPBFSIZ            HASP RJE BUFFER SIZE
         GBLA  &MLBFSIZ            HASP MULTILEAVING BUFFER SIZE
         GBLC  &PASSWD             SECURITY PASSWORD
         GBLC  &DIAL,&DIAL1        AUTO CALL FEATURE - TELEPHONE NUMBER
*                                                                     *
***********************************************************************
*                                                                     *
*              SOFTWARE OPTIONS                                       *
*                                                                     *
***********************************************************************
*                                                                     *
         GBLA  &COMP               COMPRESSION OPTION
         GBLA  &S3NRDRS            NR OF SIMULTANEOUS READERS
         GBLA  &S3NPUNS            NR OF SIMULTANEOUS PUNCHES
         GBLB  &S3OBJDK            OS OBJECT DECK SUPPORT
         GBLB  &S396COL            S/3 LOAD MODE SUPPORT
         GBLB  &DEBUG              MAINTENANCE FEATURES
         GBLB  &S3SIP              S/3 CARD SYSTEM
         GBLA  &S3TRACE            INTERNAL MESSAGE TABLE SIZE
         GBLB  &S3CMDS             LOCAL COMMANDS OPTION
*                                                                     *
***********************************************************************
*                                                                     *
*              INTERNAL VARIABLE SYMBOLS                              *
*                                                                     *
***********************************************************************
*                                                                     *
         GBLA  &FBN,&TEMP,&TMP,&TM,&CCT,&CCB
         TITLE 'HRTPSYS3 - GLOBAL SYMBOL VALUES'
&MACHSIZ SETA  8192                SIZE OF CORE STORAGE
&S3BSCA  SETA  1                   BSC ADAPTER NUMBER
&S3XPAR  SETB  0                   TRANSPARENCY FEATURE
&S35424  SETB  1                   5424 MFCU
&S31442  SETB  0                   1442 CARD READ-PUNCH
&S35471  SETB  0                   5471 PRINTER-KEYBOARD
&S35475  SETB  0                   5475 DATA ENTRY KEYBOARD
&S3FORML SETA  66                  PRINTER FORMS LENGTH
&PC(1)   SETA  1                   CARRIAGE CHANNEL 1
&PC(2)   SETA  0                   CARRIAGE CHANNEL 2
&PC(3)   SETA  0                   CARRIAGE CHANNEL 3
&PC(4)   SETA  0                   CARRIAGE CHANNEL 4
&PC(5)   SETA  0                   CARRIAGE CHANNEL 5
&PC(6)   SETA  0                   CARRIAGE CHANNEL 6
&PC(7)   SETA  0                   CARRIAGE CHANNEL 7
&PC(8)   SETA  0                   CARRIAGE CHANNEL 8
&PC(9)   SETA  0                   CARRIAGE CHANNEL 9
&PC(10)  SETA  0                   CARRIAGE CHANNEL 10
&PC(11)  SETA  0                   CARRIAGE CHANNEL 11
&PC(12)  SETA  &S3FORML-5          CARRIAGE CHANNEL 12
&PRTCONS SETA  2                   5203 AS OUTPUT CONSOLE
&RMTID   SETA  1                   HASP REMOTE TERMINAL NUMBER
&TPBFSIZ SETA  400                 HASP RJE BUFFER SIZE
&MLBFSIZ SETA  400                 MULTI-LEAVING BUFFER SIZE
&PASSWD  SETC  ''                  PASSWORD
&DIAL    SETC  ''                  TELEPHONE NUMBER
&DIAL1   SETC  ''                  TELEPHONE NUMBER CONTINUED
&COMP    SETA  2                   COMPRESSION OPTION
&CCB     SETA  2                   INTERNAL
&CCT     SETA  3                   INTERNAL
&S3NRDRS SETA  1                   NUMBER OF LOGICAL READERS
&S3NPUNS SETA  1                   NUMBER OF LOGICAL PUNCHES
&S3OBJDK SETB  0                   2-FOR-1 OPTION
&S396COL SETB  0                   1-FOR-2 OPTION
&DEBUG   SETB  0                   DEBUG OPTION
&S3SIP   SETB  0                   S/3 CARD SYSTEM
&S3TRACE SETA  10                  INTERNAL MESSAGE TABLE SIZE
&S3CMDS  SETB  0                   LOCAL COMMANDS OPTION
         TITLE 'GENERAL EQUATES'
         AIF   (&S35424).NOBOOT
         PUNCH 'B
               
.NOBOOT  ANOP
*
*
*              GENERAL EQUATES ---
*
*
         SPACE 3
*
*              SYMBOLIC REGISTERS
*
R1       EQU   1
R2       EQU   2
PSR      EQU   4
ARR      EQU   8
IAR      EQU   16
IAR1     EQU   32
IAR2     EQU   64
*
HCR      EQU   R1
FBR      EQU   R2
         SPACE 3
*
*              INTERRUPT LEVEL REGISTERS
*
IL0      EQU   128+0
IL1      EQU   128+64
IL2      EQU   128+32
IL3      EQU   128+16
IL4      EQU   128+8
         SPACE 3
*
*              EVENT WAIT FIELD BITS
*
EWFUNIT  EQU   1
EWFWORK  EQU   2
EWFPERM  EQU   4
EWFPOST  EQU   128                 EARLY POST FLAG.  NOT IN EWFALL.
EWFALL   EQU   EWFUNIT+EWFWORK+EWFPERM
         SPACE 3
*
*              ADDRESSABILITY
*
         $USING HCD,HCR
         $USING FBD,FBR
         TITLE 'FUNCTION BLOCK DSECT'
*
*
*              FUNCTION BLOCK DSECT.
*
*
FBD      DSECT
FBNEXT   $DS   YL2                 POINTER TO NEXT FUNCTION BLOCK.
FBENT    $DS   YL2                 NEXT ENTRY POINT FOR FUNCTION.
FBREG1   $DS   YL2                 SAVE-AREA FOR REGISTER 1.
FBEWF    $DS   X                   FUNCTION BLOCK EVENT WAIT FIELD.
*
*              SHORT FUNCTION BLOCK ENDS HERE.
*
FBFLG    $DS   X                   FLAG BYTE.
FFLAST   EQU   128                   LAST-FB-OF-THIS-TYPE FLAG.
FBRET1   $DS   YL2                 SUBROUTINE RETURN ADDRESS SAVE.
FBBUF    $DS   YL2                 BUFFER POINTER.
FBBCT    $DS   X                   CURRENT NR OF BUFFERS CHAINED.
FBBMX    $DS   X                   MAX BUFFER CT, FOR LITTLE WAITABIT.
FBFCS    $DS   XL2                 FUNCTION CONTROL SEQUENCE.
FBFCS1   EQU   FBFCS-1
FBFCS2   EQU   FBFCS
FCSPR1   EQU   X'0800'             FCS FOR PRINTER 1
FCSPR2   EQU   X'0400'             FCS FOR PRINTER 2
FCSPR3   EQU   X'0200'             FCS FOR PRINTER 3
FCSPR4   EQU   X'0100'             FCS FOR PRINTER 4
FCSPR5   EQU   X'0008'             FCS FOR PRINTER 5
FCSPR6   EQU   X'0004'             FCS FOR PRINTER 6
FCSPR7   EQU   X'0002'             FCS FOR PRINTER 7
FCSPU7   EQU   X'0400'             FCS FOR PUNCH 7
FCSPU6   EQU   X'0200'             FCS FOR PUNCH 6
FCSPU5   EQU   X'0100'             FCS FOR PUNCH 5
FCSPU4   EQU   X'0008'             FCS FOR PUNCH 4
FCSPU3   EQU   X'0004'             FCS FOR PUNCH 3
FCSPU2   EQU   X'0002'             FCS FOR PUNCH 2
FCSPU1   EQU   X'0001'             FCS FOR PUNCH 1
FBRCB    $DS   X                   RECORD CONTROL BYTE.
RCBPR1   EQU   X'94'               RCB FOR PRINTER 1
RCBPR2   EQU   X'A4'               RCB FOR PRINTER 2
RCBPR3   EQU   X'B4'               RCB FOR PRINTER 3
RCBPR4   EQU   X'C4'               RCB FOR PRINTER 4
RCBPR5   EQU   X'D4'               RCB FOR PRINTER 5
RCBPR6   EQU   X'E4'               RCB FOR PRINTER 6
RCBPR7   EQU   X'F4'               RCB FOR PRINTER 7
RCBPU1   EQU   X'95'               RCB FOR PUNCH 1
RCBPU2   EQU   X'A5'               RCB FOR PUNCH 2
RCBPU3   EQU   X'B5'               RCB FOR PUNCH 3
RCBPU4   EQU   X'C5'               RCB FOR PUNCH 4
RCBPU5   EQU   X'D5'               RCB FOR PUNCH 5
RCBPU6   EQU   X'E5'               RCB FOR PUNCH 6
RCBPU7   EQU   X'F5'               RCB FOR PUNCH 7
*
*              NORMAL FUNCTION BLOCK ENDS HERE.
*
FBWORK   EQU   *                   START OF OPTIONAL WORKAREA.
FBRET2   $DS   XL2                 ALTERNATE RETURN ADDR SAVEAREA.
FBXR1    $DS   XL2                 ALTERNATE R1 SAVE AREA.
FBAREA   $DS   XL2                 POINTER TO SOURCE OR SINK AREA.
FBSRCB   $DS   XL1                 SRCB RETURNED TO CALLER.
FBCSEQ   EQU   FBSRCB              3-BYTE CMD SEQ WORKAREA.
FBCLNG   EQU   FBREG1              LENGTH TO COMPRESS.
FBHCP    $DS   XL2                 POINTER TO HOPPER CONTROL AREA.
FBCURL   $DS   XL2                 CURRENT POSITION IN CURRENT BUFFER.
FB40SV   $DS   XL40                40-BYTE AREA FOR 2-FOR-1 CARDS.
FB48SV   $DS   XL8                 8 MORE BYTES FOR 1-FOR-2 CARDS.
         TITLE 'DSECT FOR HOPPER CONTROL AREA'
*
*              HOPPER CONTROL AREA (HCA) DSECT
*
*
HCD      DSECT
HCFBP    $DS   YL2                 POINTER TO LOGICAL DEVICE FB.
HCRDB    $DS   YL2                 POINTER TO READ BUFFER.
HCPUB    $DS   YL2                 POINTER TO PUNCH BUFFER.
HCFLG    $DS   YL1                 FLAG BYTE ---
HFRBB    EQU   1                     READ BUFFER IS BUSY.
HFPBB    EQU   2                     PUNCH BUFFER IS BUSY.
HFEOF    EQU   4                     END-OF-FILE.
HFLCD    EQU   8                     LAST-CARD SWITCH ON 1442.
HF5424   EQU   16                    DEVICE-IS-5424 FLAG.
HCTIO    $DS   YL1                 5424&1442 - DA, M, N BYTE OF TIO.
HCRET1   $DS   YL2                 1ST-LEVEL-SUBROUTINE RETURN.
HCRET2   $DS   YL2                 2ND-LEVEL-SUBROUTINE RETURN.
HCRET3   $DS   YL2                 3RD-LEVEL-SUBROUTINE RETURN.
HCRET4   $DS   YL2                 4TH-LEVEL-SUBROUTINE RETURN.
HCSNS    $DS   YL2                 AREA FOR STATUS BYTES.
HCLOG    $DS   3YL2                CONTIGUOUS AREA FOR $LOG.
HCRDS    $DS   YL2                 5424 - LAST 2 BYTES OF READ SIO.
HCPUS    $DS   YL2                 5424 - LAST 2 BYTES OF PUNCH SIO.
HCSIO    $DS   YL2                 5424 - CURRENT SIO.
         ORG   HCSNS+1             ORG BACK FOR 1442-UNIQUE FIELDS.
HCPLN    $DS   YL2                 1442 - NR OF BYTES TO PUNCH.
HCLOG1   DS    XL7                 1442 - FIRST $LOG ARGUMENT.
HCLOG2   DS    XL7                 1442 - SECOND $LOG ARGUMENT.
HRTPSYS3 CSECT
         ENTRY FEIBM
FEIBM    EQU   HRTPSYS3+X'60'      'PGM 360D51014, FE SVC NO 000103.'
         SPACE 5
         ORG   HRTPSYS3+256*(1+&S3SIP)
*                                  IF &S3SIP, DO NOT OVERLAY THE 256
*                                  BYTES BETWEEN X'100' AND X'1FF',
*                                  FOR PURPOSES OF THE SYSTEM/3 CARD
*                                  SYSTEM INITIALIZATION PROGRAM.
         AIF   (NOT &S35424).NOMFCUA
         TITLE 'MFCU - HOPPER CONTROL AREAS'
*
*              HCA FOR HOPPER 1 (PRIMARY HOPPER)
*
H1PUB    DC    CL98' '             PUNCH BUFFER NUMBER 1.
HCA1     $HCA  DEV=5424,FLG=HF5424,RDB=H1RDB,PUB=H1PUB,LOG=LOG5424,    C
               RDS=X'F105',PUS=X'F706',TIO=X'F0'
H1RDB    DS    CL96' '             READ BUFFER NUMBER 1.
*
*
*              HCA FOR HOPPER 2 (SECONDARY HOPPER)
*
         ORG   H1RDB+128
H2PUB    DC    CL98' '             PUNCH BUFFER NUMBER 2.
HCA2     $HCA  DEV=5424,FLG=HF5424,RDB=H2RDB,PUB=H2PUB,LOG=LOG5424,    C
               RDS=X'F904',PUS=X'FF07',TIO=X'F8'
H2RDB    DS    CL96' '             READ BUFFER NUMBER 2.
         SPACE 5
*
*
*              PRINT BUFFER FOR MFCU.
*
*
HPRB     EQU   HRTPSYS3            256-BYTE AREA FOR LEFT AND
*                                  RIGHT MFCU PRINT BUFFERS.
.NOMFCUA ANOP
         TITLE '5203 PRINTING AREA AND CHAIN IMAGE'
         SPACE 5
*                                                                     *
***********************************************************************
*                                                                     *
*        LINE PRINTER DATA AND CHAIN IMAGE AREA                       *
*                                                                     *
***********************************************************************
*                                                                     *
         SPACE 5
         AIF   (NOT &S35424).NOMFCUB
         ORG   H2PUB+256
.NOMFCUB ANOP
LPIA     DC    CL124' '            AREA FOR PRINT CHAIN IMAGE.
LPDA     DC    CL134'COMMUNICATION ESTABLISHED'  AREA FOR PRINT LINE.
         TITLE 'INITIALIZATION - HEREP SECTION'
IHEREP   EQU   *
         $LIO  14,0,0,IHFORMS      SPECIFY FORMS LENGTH.
         $MVC  LPIA+47,IHLC,48     SET 48-CHAR PRINT CHAIN.
         $SNS  14,0,3,IHSNS        GET STATUS TO CHECK PRINT CHAIN.
         $TBN  IHSNS,4             IS 48-CHAR CHAIN MOUNTED...
         $JT   IHSTART             JUMP IF SO.
         $MVC  LPIA+119,IHPN,120   NO.  SET 120-CHAR PRINT CHAIN.
IHSTART  EQU   *
         $CLC  LOGID,IHID,4        IS LOG AREA INTACT...
         $JE   IHGO                PROBABLY.  CONTINUE.
         $B    IHCLEAR             NO.  CLEAR THE PRINT LINE,
         $MVC   LPDA+60,IHERROR,33  SET UP ERROR MESSAGE,
         $B    IHTITLE             GO PRINT IT, AND
         $J    IHEND               CLEAR THE LOG AREA.
IHGO     $LA   R2,ICAPTION         POINT TO FIRST CAPTION.
IH01     $B    IHCLEAR             CLEAR THE PRINT LINE.
         $CLI  (0,R2),0            IS THIS NED OF CAPTIONS...
         $JE   IHEND               IF SO, EXIT FROM THIS SECTION.
         $TBN  (0,R2),X'80'        IS THIS A TITLE LINE...
         $JF   IHCT                JUMP IF NOT-  COUNT LINE.
IHTTL    $SBF  (0,R2),X'80'        TITLE PRINTING - RESET TITLE BIT,
         $L    R1,(2,R2)           AND SET TO-LOCATION FOR TITLE.
         $MVC  IHWK,(0,R2)         PUT LENGTH-1 OF TITLE IN WORKAREA
         $MVC  IHTMV+1,(0,R2)      AND IN MVC LENGTH FIELD.
         $A    R2,IHWK             POINT R2 TO LAST
         $LA   R2,(3,R2)           CHARACTER OF TITLE.
IHTMV    $MVC  (0,R1),(0,R2),*-*   MOVE TITLE TO PRINT LINE.
         $LA   R2,(1,R2)           POINT R2 TO THE NEXT CAPTION.
         $B    IHTITLE             GO PRINT THE TITLE.
         $B    IH01                THEN CHECK NEXT CAPTION.
IHCT     $MVC  LPDA+73,IHCCAP,14   SET UP BIT-NUMBER CAPTION.
         $MVC  LPDA+68,(1,R2)      SET BIT NUMBER INTO CAPTION.
         $LA   R1,LPDA+58          SET RIGHTMOST BYTE FOR MVC.
         $MVC  IHWK,(0,R2)         7OVE LENGTH-1 TO WORKAREA
         $MVC  IHCMV+1,(0,R2)      AND TO LENGTH FIELD OF MVC.
         $A    R2,IHWK             POINT R2 TO LAST
         $LA   R2,(2,R2)           CHARACTER OF CAPTION.
IHCMV    $MVC  (0,R1),(0,R2),*-*   MOVE REMAINDER OF CAPTION.
         $LA   R2,(1,R2)           THEN POINT R2 TO NEXT CAPTION.
IHC01    $ALC  IHBITS,IHBITS,IHBITL  IS THIS COUNTER SIGNIFICANT...
         $JC   IHC02,32+128        JUMP IF SO (CARRY OCCURRED).
         $ALC  IHC02+3,IHTWO,2     POINT TO NEXT COUNTER
         $B    IHC01               AND LOOP.
IHC02    $L    R1,LOGID+2          GET COUNTER INTO R1,
         $B    IDIVIDE             CONVERT TO DECIMAL,
         $B    IHPRINT             GO PRINT.
         $ALC  IHC02+3,IHTWO,2     POINT TO THE NEXT COUNTER.
         $B    IH01                THEN GO CHECK NEXT CAPTION.
IHEND    $MVC  LOGID,IHID,4        SET LOG ID TO C'HASP'.
         $MVI  LOGEND,0            SET LOW-ORDER BYTE TO ZERO.
         $MVC  LOGEND-1,LOGEND,LOGLEN-1  SET REMAINING BYTES TO ZERO.
         $MVC  LPDA+24,IHCOM,25    SET UP 'COMM ESTAB' MESSAGE.
         $B    0                   THEN GO LOAD MORE CARDS.
IHCCAP   $DC   C'--- BIT N --- '   PART OF DETAIL LINE CAPTION.
IHID     $DC   C'HASP'             LOG AREA IDENTIFIER.
IHTWO    $DC   YL2(2)              CONSTANT OF TWO.
IHWK     $DC   YL2(0)              WORKAREA, INITIALIZED TO ZERO.
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO CONVERT TO DECIMAL AND SET PRINT LINE          *
*                                                                     *
***********************************************************************
*                                                                     *
IDIVIDE  $ST   ARR,IDRET+3         SAVE RETURN ADDRESS.
         $ST   R2,IDR2+3           SAVE REGISTER 2.
         $LA   R2,IDTAB            POINT R2 TO THE DIVISION TABLE.
         $MVC  HERDEC+4,IDZERO,5   SET RESULT TO C'00000'.
         $MVC  IDIV1A+3,IDIV3+3,2  SET HI-ORD RESULT ADDRESS.
IDIV1    $A    R1,(1,R2)           SUBTRACT 10000 (,1000,...,1).
         $JC   IDIV2,32            JUMP IF NO CARRY.
IDIV1A   $ALC  *-*,IDTAB+19        ELSE ADD ONE TO A DECIMAL DIGIT,
         $B    IDIV1               AND GO SUBTRACT AGAIN.
IDIV2    $A    R1,(11,R2)          ADD BACK IN 10000 (,1000,...,1).
         $LA   R2,(2,R2)           POINT TO THE NEXT ADDEND.
         $ALC  IDIV1A+3,IDTAB+19,2 UP THE DEC DIGIT PTR BY ONE.
         $CLC  IDIV1A+3,IDIVLIM,2  IS IT AT ITS LIMIT...
         $BNE  IDIV1               IF NOT, WORK ON THE NEXT DIGIT.
IDIV3    $ITC  HERDEC,HERDEC-1,4   BLANK NONSIGNIFICANT DIGITS,
IDR2     $LA   R2,*-*              RESTORE REGISTER 2,
IDRET    $B    *-*                 AND RETURN TO CALLER.
IDZERO   $DC   C'00000'            CONSTANT OF DECIMAL ZEROES.
IDTAB    DC    HL2'-10000,-1000,-100,-10,-1'  TABLE FOR DIVISION
         DC    HL2'10000,1000,100,10,1'   OF A 16-BIT VALUE.
HERDEC   EQU   LPDA+74
IDIVLIM  $DC   YL2(HERDEC+5)
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO PRINT TITLE LINE                               *
*                                                                     *
***********************************************************************
*                                                                     *
IHTITLE  $ST   ARR,IHRET+3         SAVE RETURN ADDRESS.
IHTI00   $NOPJ IHTI1               FIRST-TIME SWITCH
         $MVI  IHTI00+1,0          FOR CARRIABE EJECT.
         $SIO  14,0,4,1            SKIP TO CHANNEL 1.
         $TIO  14,0,6,*-2          WAIT TILL NOT BUSY.
IHTI1    $SIO  14,0,0,2            SPACE 2 BEFORE TITLE.
         $TIO  14,0,6,*-2          WAIT TILL NOT BUSY.
IHTI2    $LIO  14,0,6,IHPCDA       THEN SET DATA ADDRESS REGISTER.
         $LIO  14,0,4,IHPCIA       SPECIFY CHAIN IMAGE ADDRESS.
         $SIO  14,0,2,2            AND PRINT AND SPACE 2.
         $TIO  14,0,6,*-2          WAIT TILL NOT BUSY.
         $J    IHRET               RETURN TO CALLER.
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO PRINT DETAIL LINE                              *
*                                                                     *
***********************************************************************
*                                                                     *
IHPRINT  $ST   ARR,IHRET+3         SAVE RETURN ADDRESS.
         $LIO  14,0,6,IHPCDA       SET DATA ADDRESS REGISTER.
         $LIO  14,0,4,IHPCIA       SPECIFY CHAIN IMAGE ADDRESS.
         $SIO  14,0,2,1            PRINT AND SPACE 1.
         $TIO  14,0,6,*-2          WAIT TILL NOT BUSY.
         $J    IHRET               THEN RETURN TO CALLER.
IHFORMS  $DC   YL1(&S3FORML,0)     FORMS LENGTH REGISTERS.
IHPCDA   $DC   YL2(LPDA)           ADCON FOR PRINTER DATA AREA.
IHPCIA   $DC   YL2(LPIA)           ADCON FOR PRINTER IMAGE AREA.
IHCOM    $DC   C'COMMUNICATION ESTABLISHED'
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO CLEAR THE PRINT LINE                           *
*                                                                     *
***********************************************************************
*                                                                     *
IHCLEAR  $ST   ARR,IHRET+3         SAVE RETURN ADDRESS.
         $MVI  LPDA+131,C' '       BLANK THE LOW-ORDER BYTE.
         $MVC  LPDA+130,LPDA+131,131  BLANK THE REMAINING BUTES.
IHRET    $B    *-*                 THEN RETURN TO CALLER.
         TITLE 'INITIALIZATION - HEREP CAPTIONS'
ICAPTION EQU   *
         $IHMSG T,'H E R E P  ---  HASP ENVIRONMENTAL RECORDING AND EDIC
               TING PROGRAM  ---  H E R E P'
         AIF   (NOT &S35424).NOMFCUC
         $IHMSG T,'5424 MULTI-FUNCTION CARD UNIT --- STATUS BYTE 1'
         $IHMSG 0,'READ CHECK'
         $IHMSG 1,'PUNCH CHECK'
         $IHMSG 2,'PUNCH INVALID'
         $IHMSG 3,'PRINT DATA CHECK'
         $IHMSG 4,'PRINT CLUTCH CHECK'
         $IHMSG 5,'HOPPER CHECK'
         $IHMSG 6,'FEED CHECK'
         $IHMSG 7,'NO-OP'
.NOMFCUC ANOP
         $IHMSG T,'5203 PRINTER --- STATUS BYTE 1'
         $IHMSG 0,'CHAIN SYNCHRONIZATION CHECK'
         $IHMSG 1,'INCREMENTER SYNC CHECK'
         $IHMSG 2,'THERMAL CHECK'
         $IHMSG 6,'UNPRINTABLE CHARACTER'
         $IHMSG 7,'CE SNS BIT'
         $IHMSG T,'5203 PRINTER --- STATUS BYTE 2'
         $IHMSG 0,'CARRIAGE SYNC CHECK'
         $IHMSG 1,'CARRIAGE SPACE CHECK'
         $IHMSG 2,'FORMS JAM CHECK'
         $IHMSG 3,'INCREMENTER FAILURE CHECK'
         $IHMSG 4,'CE SNS BIT LATCHED'
         $IHMSG 5,'HAMMER ECHO CHECK'
         $IHMSG 6,'ANY HAMMER ON CHECK'
         $IHMSG 7,'NO-OP'
         $IHMSG T,'BINARY SYNCHRONOUS COMMUNICATIONS ADAPTER --- STATUSC
                BYTE 2'
         $IHMSG 0,'TIMEOUT'
         $IHMSG 1,'CYCLIC REDUNDANCY CHECK'
         $IHMSG 2,'ADAPTER CHECK DURING TRANSMIT'
         $IHMSG 3,'ADAPTER CHECK DURING RECEIVE'
         $IHMSG 4,'BAD ASCII'
         $IHMSG 5,'ABORTIVE DISCONNECT'
         $IHMSG 6,'DISCONNECT TIMEOUT'
         AIF   (NOT &S31442).IHMEND  *
         $IHMSG T,'1442 CARD READ PUNCH --- STATUS BYTE 1'
         $IHMSG 0,'READ COMPARE'
         $IHMSG 2,'PUNCH CHECK'
         $IHMSG 3,'DATA OVERRUN'
         $IHMSG 5,'NO-OP LATCH'
         $IHMSG 6,'FEED CHECK'
         $IHMSG 7,'INVALID CARD CODE'
         $IHMSG T,'1442 CARD READ PUNCH --- STATUS BYTE 2'
         $IHMSG 3,'READ STATION JAM'
         $IHMSG 4,'HOPPER MISFEED'
         $IHMSG 5,'FEED CLUTCH'
         $IHMSG 6,'PUNCH STATION JAM'
         $IHMSG 7,'TRANSPORT JAM'
.IHMEND  DC    X'0'                LAST-CAPTION INDICATOR.
IHERROR  $DC   C'HEREP COUNTERS HAVE BEEN ALTERED.'
IHBIT1   EQU   *
         AIF   (NOT &S35424).NOMFCUD
         DC    B'11111111'         5424 VALID COUNTERS
.NOMFCUD ANOP
         DC    B'1110001111111111' 5203 VALID COUNTERS
         DC    B'11111110'         BSCA VALID COUNTERS
         AIF   (NOT &S31442).IHB1442  *
         DC    B'1011011100011111' 1442 VALID COUNTERS
.IHB1442 ANOP                      *
IHBITS   EQU   *-1                 ADDRESS OF BIT PATTERN.
IHBITL   EQU   IHBITS-IHBIT1+1     LENGTH OF BIT PATTERN.
IHSNS    $DC   YL2(0)              PRINTER SENSE BYTES FOR HEREP.
IHLC     $DC   C'1234567890#@/STUVWXYZ&&,%JKLMNOPQR-$*ABCDEFGHI+.'''
IHPN     $DC   2C'1234567890XY/STUVW:_",=JKLMNOPQR-Z(ABCDEFGHI+.)%$*#&C
               &@<;^''?>'
         $END  START=IHEREP
         ORG   IHEREP
         TITLE 'HRTPSYS3 - COMMUTATOR'
*
*
*              MAIN COMMUTATOR
*
*
$COM     $LA   FBR,$FB1            POINT TO FIRST FUNCTION BLOCK.
COMM1    $TBF  (FBEWF,FBR),EWFALL  IS FUNCTION DISPATCHABLE...
         $JF   COM2                IF NOT, JUMP.
         $L    R1,(FBREG1,FBR)     YES.  RESTORE REGISTER 1
         $L    IAR,(FBENT,FBR)     AND GIVE THE FUNCTION CONTROL.
$COMRET  $ST   ARR,(FBENT,FBR)     ON RETURN, SAVE NEXT ENTRY POINT,
$COMRETA $ST   R1,(FBREG1,FBR)     AND SAVE REGISTER 1.
COM2     $CLI  (FBNEXT-1,FBR),0    SET CC TO INDICATE IF END OF CHAIN.
$COMRETB EQU   COM2
         $L    FBR,(FBNEXT,FBR)    POINT TO NEXT FUNCTION BLOCK.
         $BNE  COMM1               IF IT EXISTS, CHECK DISPATCHABILITY.
         $B    $COM                OTHERWISE START AGAIN AT TOP.
         TITLE 'MFCU - HOPPER DRIVER'
         AIF   (NOT &S35424).NOMFCUE
$MFCU    EQU   *
         $B    HREAD               GO READ A CARD.
         $B    HBLANK              CHECK CARD FOR BLANK.
         $JE   HAP                 IF BLANK, GO AWAIT PUNCH.
         AIF   (NOT &S3CMDS).NOCMDM
*
*              CHECK FOR LOCAL COMMANDS
*
         $L    R1,(HCRDB,HCR)      POINT TO THE READ BUFFER.
         $B    $CMDSCAN            GO CHECK LOCAL COMMANDS.
         $L    R1,(FBREG1,FBR)     RESTORE HOPPER POINTER.
         $BE   $MFCU               IF COMMAND, GO READ AGAIN.
.NOCMDM  ANOP
*
*              AWAITING-READ ROUTINE
*
HAR      $MVC  (HCFBP,HCR),A$FBRD1,2  SET ARG TO ALLOCATE.
         $B    HGET                GO TO ALLOCATION SUBROUTINE.
         $BNE  $MFCU               IF HOP NOT READY, MAKE DORMANT.
*
*              READING ROUTINE
*
HRD      $SBN  (HCFLG,HCR),HFRBB   SHOW READ BUFFER BUSY.
         $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY ADDRESS.
         $TBF  (HCFLG,HCR),HFRBB   DID LOGICAL READER FREE BUFFER...
         $BF   $COMRETA            NON-PROCESS-EXIT IF NOT.
         $TBN  (HCFLG,HCR),HFEOF   DID LOGICAL READER SET EOF...
         $BT   $MFCU               MAKE HOPPER DORMANT IF SO.
         $B    HREAD               OTHERWISE READ THE NEXT CARD
         $B    HRD                 AND WAIT FOR IT TO BE PROCESSED.
*
*              AWAITING-PUNCH ROUTINE
*
HAP      $MVC  (HCFBP,HCR),A$FBPU1,2  SET ARG TO ALLOCATE.
         $B    HGET                GO TO ALLOCATION SUBROUTINE.
         $BNE  $MFCU               IF HOP NOT READY, MAKE DORMANT.
*
*              PUNCHING ROUTINE
*
HPU      $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY ADDRESS.
         $TBF  (HCFLG,HCR),HFPBB+HFEOF  DID LOGICAL PCH RTN SET A FLAG.
         $BT   $COMRETA            NON-PROCESS-EXIT IF NOT.
         $TBN  (HCFLG,HCR),HFEOF   DID HE SAY END-OF-FILE...
         $BT   HAP                 IF SO, GO AWAIT PUNCH AGAIN.
HPU1     $MVC  (HCSIO,HCR),(HCPUS,HCR),2  SET UP RD-PU-PRT SIO.
         $B    HEXCP               GO ISSUE THE SIO.
         $JE   HPU2                IF NO ERRORS, SHOW PU BUF FREE.
         $TBF  (HCSNS,HCR),X'47'   IF PU CK, HOP CK, FEED CK, OR NO-OP,
         $JF   HPU3                SKIP FREEING PUNCH BUFFER.
HPU2     $SBF  (HCFLG,HCR),HFPBB   OTHERWISE FREE PUNCH BUFFER.
         $L    R1,(HCPUB,HCR)      POINT TO THE PUNCH BUFFER.
         $MVI  (95,R1),C' '        SET LOW-ORDER CHAR TO BLANK.
         $MVC  (94,R1),(95,R1),95  PROPAGATE IT TO CLEAR THE BUFFER.
         $L    R1,(FBREG1,FBR)     THEN RESTORE INDEX REGISTER 1.
HPU3     $TBF  (HCSNS,HCR),X'81'   IF NO READ CHECK NOR NO-OP,
         $JT   HPU5                GO CHECK CARD FOR BLANKS.
HPU4     $B    HREAD               OTHERWISE READ ANOTHER CARD.
HPU5     $B    HBLANK              GO CHECK CARD FOR BLANKS.
         $BE   HPU                 IF BLANK, GO TO THE TOP.
         $B    HPU4                IF NOT BLANK, READ ANOTHER CARD.
         EJECT
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO CHECK FOR A BLANK READ BUFFER                  *
*                                                                     *
***********************************************************************
*                                                                     *
HBLANK   $ST   ARR,(HCRET1,HCR)    SAVE RETURN ADDRESS.
         $L    R1,(HCRDB,HCR)      POINT TO FIRST BYTE OF READ BUFFER.
         $CLI  (95,R1),C' '        IF LOW-ORDER BYTE IS NOT BLANK,
         $JNE  HBLRET              GO RETURN CONDITION NOT-EQUAL.
         $CLC  (94,R1),(95,R1),95  ELSE TEST THE REMAINING BYTES TOO.
HBLRET   $L    R1,(FBREG1,FBR)     THEN RESTORE REGISTER 1 AND
         $L    IAR,(HCRET1,HCR)    RETURN CONDITION EQUAL OR NOT-EQUAL.
.NOMFCUE ANOP
         SPACE 5
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO ALLOCATE LOGICAL DEVICE ROUTINE                *
*                                                                     *
***********************************************************************
*                                                                     *
HGET     $ST   ARR,(HCRET1,HCR)    SAVE RETURN ADDRESS.
         $ST   R2,(HCRET2,HCR)     SAVE REGISTER 2.
         $SBF  (HCFLG,HCR),HFPBB+HFEOF+HFLCD  RESET VARIOUS FLAGS.
         $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY ADDRESS.
         $B    HTIO                GO SEE IF HOPPER IS READY.
         $JNE  HGNOT               IF NOT, RETURN CONDITION NOT-EQUAL.
         $L    R2,(HCFBP,HCR)      ELSE POINT TO FIRST FB.
HGET1    $TBN  (FBEWF,FBR),EWFUNIT IS IT WAITING FOR UNIT...
         $JT   HGOT                IF SO, GO ASSIGN UNIT.
         $TBN  (FBFLG,FBR),FFLAST  IF NOT, IS IT LAST OF ITS TYPE...
         $JF   HGET2               IF NOT, GO POINT TO THE NEXT ONE.
         $L    R2,(HCRET2,HCR)     LAST OF TYPE, SO NON-PROCESS-
         $B    $COMRETA            EXIT AND TRY AGAIN NEXT TIME.
HGET2    $L    R2,(FBNEXT,FBR)     NOT LAST.  POINT TO NEXT FB AND
         $B    HGET1               SEE IF IT'S WAITING FOR A UNIT.
HGOT     $ST   R1,(FBHCP,FBR)      ALLOCATE - POINT FB TO HCA
         $ST   R2,(HCFBP,HCR)      AND POINT HCA TO FB,
         $POST *,UNIT              POST THE FB FOR UNIT,
         $L    R2,(HCRET2,HCR)     RESTORE INDEX REGISTER 2,
         $CLI  *-1,0               SET CONDITION CODE EQUAL,
HGNOT    $L    IAR,(HCRET1,HCR)    AND RETURN WITH CORRECT CONDITION.
         SPACE 1
A$FBRD1  $DC   YL2($FBRD1)         ADR OF FIRST LOGICAL READER FB.
A$FBPU1  $DC   YL2($FBPU1)         ADR OF FIRST LOGICAL PUNCH FB.
         SPACE 5
*                                                                     *
         AIF   (NOT &S35424).NOMFCUF
***********************************************************************
*                                                                     *
*        SUBROUTINE TO READ A SINGLE CARD                             *
*                                                                     *
***********************************************************************
*                                                                     *
HREAD    $ST   ARR,(HCRET1,HCR)    SAVE RETURN ADDRESS.
         $MVC  (HCSIO,HCR),(HCRDS,HCR),2  SET UP READ SIO.
         $B    HEXCP               GO READ A CARD.
         $JNE  HEXCP1              REREAD IF ERROR.
         $L    IAR,(HCRET1,HCR)    RETURN CONDITION EQUAL.
         EJECT
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO DO AND CHECK ANY INPUT/OUTPUT OPERATION.       *
*                                                                     *
***********************************************************************
*                                                                     *
HEXCP    $ST   ARR,(HCRET2,HCR)    SAVE RETURN ADDRESS.
HEXCP1   $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY ADDRESS.
         $B    HTIO                GO TIO FOR READY.
         $BE   HSIO                IF READY, GO TRY TO ISSUE SIO.
         $BNE  $COMRETA            EXIT IF SIO WAS NOT ISSUED.
         $B    $COMRET             ELSE EXIT & SET NEXT ENTRY ADDRESS.
         $TIO  15,0,7,$COMRETA     THEN EXIT TILL NOT BUSY.
         $B    HSNS                WHEN NOT BUSY, TEST COMPLETION.
         $L    IAR,(HCRET2,HCR)    THEN RETURN CONDITION TO CALLER.
         SPACE 5
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO START INPUT/OUTPUT FOR THE MFCU                *
*                                                                     *
***********************************************************************
*                                                                     *
HSIO     $ST   ARR,(HCRET3,HCR)    SAVE RETURN ADDRESS.
HSERROR  $NOPJ HSRETF              RETURN FALSE IF ERROR RECOVERY.
         $TIO  15,0,7,HSRETF       RETURN FALSE IF BUSY.
HSHURRY  $J    HSSNS               JUMP TO SENSE IF NO HURRY.
         $TBF  (HCSIO-1,HCR),6     HURRY SWITCH IS SET.  IF THIS IS NOT
         $JF   HSRETF              READ-ONLY, RETURN CONDITION FALSE.
HSSNS    $SNS  15,0,3,(HCSNS,HCR)  OTHERWISE READ THE STATUS BYTES.
HSSTK    $CLI  (HCSIO,HCR),*-*     IS SAME STACKER REQUESTED...
         $JE   HS01                IF SO, PROCEED WITH THE SIO.
         $TBF  (HCSNS-1,HCR),3     IF NOT, IS THE TRANSPORT CLEAR...
         $JT   HS00                SWITCH STACKERS IF IT IS.
         $TBF  (HCSIO-1,HCR),6     ELSE SEE IF THIS IS A READ-ONLY SIO.
         $JF   HSRETF              IF NOT READ-ONLY, WAIT NORMALLY.
         $MVI  HSHURRY+1,128       OTHERWISE SET THE HURRY SWITCH
         $J    HSRETF              AND RETURN CONDITION FALSE.
HS00     $MVI  HSHURRY+1,0         STACKER CHANGE.  RESET THE HURRY
         $MVC  HSSTK+1,(HCSIO,HCR) SWITCH AND SET NEW STACKER NUMBER.
HS01     EQU   *
         $MVC  HSSIO+2,(HCSIO,HCR),2  SET UP THE IN-LINE $SIO.
         $TBN  (HCSIO-1,HCR),4     IS PRINT REQUIRED...
         $JF   HS11                JUMP IF NOT.
         $TBN  (HCSNS-1,HCR),X'C0' IS ANY PRINT BUFFER FREE...
         $JT   HSRETF              IF NOT, RETURN CONDITION FALSE.
         $SBF  HS03+3,X'80'        ASSUME PRINT BUFFER 1 FREE.
         $TBF  (HCSNS-1,HCR),X'80' IS PRINT BUFFER 1 FREE...
         $JT   HS02                JUMP IF SO.
         $SBN  HS03+3,X'80'        ELSE SET $MVC FOR BUFFER 2
         $SBN  HSSIO+2,X'80'       AND $SIO FOR BUFFER 2.
HS02     $L    R1,(HCPUB,HCR)      SET $MVC FROM-ADDRESS.
HS03     $MVC  HPRB+95,(95,R1),96  MOVE PUNCH BUFFER TO PRINT BUFFER.
         $L    R1,(FBREG1,FBR)     RESTORE R1 TO POINT TO HCA.
HS11     $LIO  15,0,5,(HCRDB,HCR)  LOAD THE MFCU READ DATA ADDRESS REG
         $LIO  15,0,6,(HCPUB,HCR)  AND THE MFCU PUNCH ADDRESS REGISTER.
         $B    HTIO                MAKE SURE THE HOPPER'S READY.
         $JF   HSRET               IF NOT, RETURN CONDITION FALSE.
HSSIO    $SIO  0,0,0,0             ISSUE THE START-I/O.
         $CLI  *-1,0               SET CONDITION EQUAL.
         $L    IAR,(HCRET3,HCR)    RETURN WITH CONDITION EQUAL.
HSRETF   $CLI  *,0                 SET CONDITION NOT-EQUAL.
HSRET    $L    IAR,(HCRET3,HCR)    RETURN CONDITION TO CALLER.
         SPACE 5
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO PERFORM MFCU ERROR DETECTION AND LOGGING       *
*                                                                     *
***********************************************************************
*                                                                     *
HSNS     $ST   ARR,(HCRET3,HCR)    SAVE RETURN ADDRESS.
         $B    HTIO                GO SEE IF HOPPER IS READY.
         $JE   HSNSRT              IF READY, RETURN CONDITION EQUAL.
         $SNS  15,0,3,(HCSNS,HCR)  OTHERWISE READ IN STATUS BYTES.
         $CLI  (HCSNS,HCR),1       CHECK THE MFCU ERROR STATUS.
         $JL   HSNSRTE             IF ALL BITS ARE OFF, RETURN EQUAL.
         $JE   HSNSRTF             IF ONLY NO-OP, RETURN UNEQUAL.
         $MVC  HSMSG+2,(HCSNS,HCR),2  MOVE STATUS BYTES TO MESSAGE.
         $LA   R1,HSMSG            POINT TO MESSAGE WITH R1.
         $B    $MSG                GO PUT MSG INTO TRACE TABLE.
         $L    R1,(FBREG1,FBR)     THEN RESTORE REGISTER 1.
         $MVC  HSNS1+1,(HCSNS,HCR) SAVE THE ERROR STATUS BYTE.
         $LA   R1,(HCSNS,HCR)      SET R1 AS ARGUMENT TO $LOG.
         $B    $LOG                GO LOG THE ERROR BITS.
         $L    R1,(FBREG1,FBR)     THEN RESTORE R1, AND
HSNS1    $MVI  (HCSNS,HCR),*-*     RESTORE THE ERROR STATUS BYTE.
         $TBF  (HCSNS,HCR),X'C7'   IF ONLY PUN INVALID OR PRT CHK,
         $JF   HSNS2               DO NOT JUMP HERE, BUT
HSNSRTE  $CLI  *-1,0               SET CONDITION EQUAL
         $L    IAR,(HCRET3,HCR)    AND RETURN.
HSNS2    $MVI  HSERROR+1,0         ELSE SET THE ERROR RECOVERY FLAG.
         $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY ADDRESS.
         $SNS  15,0,3,(HCSNS+4,HCR)  READ IN THE MFCU STATUS BYTES.
         $TBF  (HCSNS+4,HCR),X'FE'   CHECK ALL ERROR BITS BUT NOP.
         $BF   $COMRETA            IF NOT ALL OFF, NON-PROCESS EXIT.
         $MVI  HSERROR+1,128       THEN RESET THE ERROR RECOVERY FLAG,
HSNSRTF  $CLI  *,0                 SET CONDITION NOT-EQUAL, AND
HSNSRT   $L    IAR,(HCRET3,HCR)    RETURN CONDITION TO CALLER.
HSMSG    DC    X'0500000F'         BASIC STATUS MESSAGE FOR 5424.
.NOMFCUF ANOP
         SPACE 5
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO TEST I/O FOR NOT READY/UNIT CHECK              *
*                                                                     *
***********************************************************************
*                                                                     *
HTIO     $ST   ARR,(HCRET4,HCR)    SAVE RETURN ADDRESS.
         $MVC  HTIO1+1,(HCTIO,HCR) SET UP THE TIO INSTRUCTION.
         $CLI  *,0                 SET CONDITION NOT-EQUAL.
HTIO1    $TIO  0,0,0,HTIO2         BRANCH IF HOPPER NOT READY.
         $CLI  *-1,0               ELSE SET CONDITION EQUAL.
HTIO2    $L    IAR,(HCRET4,HCR)    RETURN CONDITION TO CALLER.
         AIF   (NOT &S31442).NO1442  *
         TITLE '1442 CARD READ/PUNCH DRIVER'
*
*              1442 HOPPER CONTROL AREA AND DATA AREA.
*
HCA1442  $HCA  DEV=1442,RDB=GDATA,PUB=GPDATA,TIO=X'50',                C
               LOG1=LOG1442A,LOG2=LOG1442B
         AIF   (NOT &S35424).NOMFCUG
GDATA    DS    CL82                READ BUFFER.
GPDATA   DS    CL82                PUNCH BUFFER.
         AGO   .NOMFCUH
.NOMFCUG ANOP
GDATA    EQU   HRTPSYS3            READ BUFFER.
GPDATA   EQU   GDATA+82            PUNCH BUFFER.
.NOMFCUH ANOP
         SPACE 10
*
*              UNASSIGNED-1442 ROUTINE.
*
$1442    EQU   *
GDOR     $B    GSIORD              GO READ A CARD.
         $BNE  GDOR                IF ERROR, GO READ AGAIN.
         $CLI  GDATA,C' '          IS THE CARD BLANK...
         $JNE  GAR                 NO.  GO TO AWAITING-READ.
         $CLC  GDATA+78,GDATA+79,79  MAYBE.  CHECK ALL COLUMNS.
         $JNE  GAR                 IF BLANK, FALL THROUGH.
*
*              AWAITING-PUNCH ROUTINE.
*
GAP      $MVC  (HCFBP,HCR),A$FBPU1,2  SET ARGUMENT TO ALLOCATE.
         $B    HGET                GO TO ALLOCATION SUBROUTINE.
         $BNE  GDOR                IF NOT READY, MAKE DORMANT.
*
*              ACTIVELY-PUNCHING ROUTINE.
*
GPU      $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY ADDRESS.
         $TBF  (HCFLG,HCR),HFPBB+HFEOF  DO WE HAVE WORK TO DO...
         $BT   $COMRETA            IF NOT, NON-PROCESS-EXIT.
         $TBN  (HCFLG,HCR),HFEOF   IS IT END-OF-FILE...
         $BT   GAP                 IF SO, GO AWAIT PUNCH AGAIN.
GPU1     $B    GSIOPU              NO, PUNCH BUFFER BUSY.  GO PUNCH.
         $BNE  GPU1                IF ERROR, GO RE-PUNCH.
         $SBF  (HCFLG,HCR),HFPBB   OTHERWISE RESET PUNCH-BUSY
         $B    GPU                 AND GO WAIT FOR NEXT CARD.
*
*              AWAITING-READ ROUTINE.
*
GAR      EQU   *
         AIF   (NOT &S3CMDS).NOCMDG
*
*              BUT FIRST, CHECK LOCAL COMMANDS
*
         $L    R1,(HCRDB,HCR)      POINT TO THE READ BUFFER.
         $B    $CMDSCAN            GO CHECK LOCAL COMMANDS.
         $L    R1,(FBREG1,FBR)     RESTORE HOPPER POINTER.
         $BE   $1442               IF COMMAND, GO READ AGAIN.
.NOCMDG  $MVC  (HCFBP,HCR),A$FBRD1,2  SET ARG TO ALLOCATE.
         $B    HGET                GO TO ALLOCATION SUBROUTINE.
         $BNE  HGET1-3             IF UNREADY, ALLOCATE NEVERTHELESS.
*
*              ACTIVELY-READING ROUTINE.
*
GRD      $SBN  (HCFLG,HCR),HFRBB   SHOW READ BUFFER BUSY.
         AIF   (NOT &S3OBJDK).GNOOBJ  *
         $MVI  GDATA+80,0          AVOID APPEARANCE OF 2-FOR-1 CARD.
.GNOOBJ  $TBN  (HCSNS,HCR),X'40'   IS THE LAST-CARD SWITCH ON...
         $JF   GRD1                IF NOT, SKIP LAST-CARD CODE.
         $SBN  (HCFLG,HCR),HFLCD   ALSO SET THE LAST-CARD FLAG.
GRD1     $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY LOCATION.
         $TBF  (HCFLG,HCR),HFRBB   IS THE READ BUFFER FREE YET...
         $BF   $COMRETA            IF STILL BUSY, NON-PROCESS EXIT.
         $MVI  (HCSNS,HCR),0       MAKE SURE THE LAST-CARD BIT'S OFF.
         $TBF  (HCFLG,HCR),HFEOF+HFLCD  DID LOGICAL RDR SET EOF ETC...
         $JF   GRD3                YES, ONE OR THE OTHER.  SO JUMP.
GRD2     $B    GSIORD              NO, SO GO READ THE NEXT CARD.
         $BNE  GRD2                IF ERROR IN THE READ, READ IT AGAIN.
         $B    GRD                 OTHERWISE GO SHOW BUFFER BUSY.
GRD3     $TBN  (HCFLG,HCR),HFEOF   DID LOGICAL READER SEE AN EOF...
         $BT   $1442               IF HE DID, MAKE THIS READER DORMANT.
         $SBN  (HCFLG,HCR),HFEOF   NO, WE PREVIOUSLY SET LAST-CARD.
         $B    GRD                 SHOW EOF AND TELL IT TO $READER.
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO START I/O FOR ANY OPERATION AND SNS IF REQUIRED*
*                                                                     *
***********************************************************************
*                                                                     *
GSIORD   $LIO  5,0,4,(HCRDB,HCR)   READ EBCDIC - LOAD DATA ADDRESS REG,
         $MVI  GSIO1+1,X'51'       AND SET $SIO TO READ-EBCDIC.
         $J    GSIO                THEN JUMP TO COMMON ROUTINE.
GSIOPU   $LIO  5,0,4,(HCPUB,HCR)   PUNCH AND FEED - LOAD DATA ADR REG,
         $LIO  5,0,0,(HCPLN,HCR)   SET 128 MINUS PUNCH COUNT,
         $MVI  GSIO1+1,X'52'       AND SET $SIO TO PUNCH-AND-FEED.
GSIO     $ST   ARR,(HCRET3,HCR)    SET RETURN ADDRESS.
         $ST   IAR,(FBENT,FBR)     SET NEXT ENTRY ADDRESS.
         $TIO  5,0,2,$COMRETA      NON-PROCESS-EXIT IF BUSY.
         $TIO  5,0,0,$COMRETA      NON-PROCESS-EXIT TILL READY.
GSIO1    $SIO  5,0,*-*,1           $SIO AND SPECIFY STACKER 2.
         $ST   IAR,(FBENT,FBR)     THEN SET NEXT ENTRY ADDRESS
         $TIO  5,0,2,$COMRETA      AND NON-PROCESS-EXIT TILL NOT BUSY.
         $CLI  GSIO1+1,X'50'       WAS THE $SIO MERELY A RUN-OUT...
         $JE   GSNSRT              IF YES, RETURN TO THE CALLER.
         $B    HTIO                ELSE GO TEST FOR NOT-READY/UNIT-CHK.
         $SNS  5,0,3,(HCSNS,HCR)   READ IN THE STATUS BYTES.
         $JNE  GSIO2               LOG MESSAGE UNLESS READY.
         $TBN  (HCSNS,HCR),X'40'   IF READY, CHECK LAST CARD.
         $JF   GSNSRT              RETURN IF NOT-LAST-CARD.
         $MVI  GSIO1+1,X'50'       LAST CARD - SET FEED-ONLY
         $B    GSIO+3              AND RUN OUT LAST CARD.
GSIO2    EQU   *
         $MVC  GSMSG+2,(HCSNS,HCR),2  MOVE STATUS BYTES TO MESSAGE.
         $LA   R1,GSMSG            POINT R1 TO THE MESSAGE
         $B    $MSG                AND PUT IT IN THE TRACE TABLE.
         $L    R1,(FBREG1,FBR)     THEN RESTORE R1.
         $MVC  (HCLOG1,HCR),(HCSNS,HCR) SET UP STATUS BYTE 1 AND
         $MVC  (HCLOG2,HCR),(HCSNS-1,HCR)  STATUS BYTE 2 FOR LOGGING.
         $LA   R1,(HCLOG1,HCR)     POINT ARGUMENT REGISTER TO LOG ARGS
         $B    $LOG                FOR BYTE 1 AND GO $LOG.
         $LA   R1,(7,R1)           POINT ARGUMENT REGISTER TO LOG ARGS
         $B    $LOG                FOR BYTE 2 AND GO $LOG.
         $L    R1,(FBREG1,FBR)     THEN RESTORE REGISTER 1.
         $CLI  *-1,0               SET CONDITION EQUAL.
         $TBF  (HCSNS,HCR),X'B7'   ARE THERE ERRORS...
         $JT   GSNSRT              JUMP IF NOT.
         $CLI  *,0                 ELSE SET CONDITION NOT-EQUAL.
GSNSRT   $L    IAR,(HCRET3,HCR)    RETURN TO CALLER WITH CONDITION.
GSMSG    DC    X'05000005'         BASIC STATUS MESSAGE FOR 1442.
.NO1442  $DROP HCR                 DISESTABLISH ADDRESSABILITY.
         TITLE '5203 LINE PRINTER CONTROL AREA'
         $USING PCA,PCR            ESTABLISH ADDRESSABILITY.
*
*              5203 LINE PRINTER CONTROL AREA
*
PCA      EQU   *                   CONTROL AREA LOCATION.
PCR      EQU   R1                  CONTROL AREA BASE.
*
*              FOLLOWING 4 BYTES ARE SIO CONTROL CODES FOR SPACE 0,
*              SPACE 1, SPACE 2, AND SPACE 3.  THEY MUST APPEAR AT
*              PCA+0.
*
         DC    YL1(0,1,2,3)        CONTROL CODES FOR SPACING.
PCDA     $DC   YL2(LPDA)           ADCON FOR PRINTER DATA AREA.
PCIA     $DC   YL2(LPIA)           ADCON FOR PRINTER IMAGE AREA.
*
*              FOLLOWING 4 BYTES ARE SIO N-CODES FOR PRINT AND SPACE,
*              PRINT AND SKIP, SPACE ONLY, AND SKIP ONLY.  THEY MUST
*              START AT PCA+8.
*
         DC    YL1(2,6,0,4)        N-CODES FOR ALL CASES.
PCFLG    DC    X'0'                PRINTER FLAG BYTE.
PFBSY    EQU   1                     PRINT DATA AREA BUSY BIT.
PFASG    EQU   2                     PRINTER-ASSIGNED BIT.
PCCC     DC    X'0'                PRINTER SUB-RECORD CONTROL BYTE.
PCSNS    $DC   YL2(0)              PRINTER STATUS BYTES.
*
*              FOLLOWING 16 BYTES ARE THE EQUIVALENT OF A 12-CHAN
*              CARRIAGE CONTROL TAPE.  EACH SPECIFIES A LINE NUMBER
*              TO WHICH PAPER WILL BE SKIPPED WHEN THE SRCB SO
*              SPECIFIES.  THEY MUST START AT PCA+16.
*
PCCCTL   EQU   *
         DC    YL1(0,&PC(1),&PC(2),&PC(3),&PC(4),&PC(5),&PC(6),&PC(7),&C
               PC(8),&PC(9),&PC(10),&PC(11),&PC(12),&S3FORML,0,0)
PCSKIP   DC    X'0'                SAVE AREA FOR SKIP LINE NR.
PCLOGA   DC    X'0',YL2(LOG5203A,0,0)  LOG STATUS BYTE 1.
PCLOGB   DC    X'0',YL2(LOG5203B,0,0)  LOG STATUS BYTE 2.
PCMSG    DC    X'0500000E'         BASIC STATUS MESSAGE FOR 5203.
         TITLE '5203 LINE PRINTER DRIVER'
$5203    EQU   *
         $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TBN  (PCFLG,PCR),PFBSY   NON-PROCESS EXIT TILL LINE
         $BF   $COMRETB            PRINTER DATA AREA IS BUSY.
*
*              A LINE AWAITS PRINTING.  COMPLETE THE SIO Q-BYTE.
*
         $MNZ  (LP10+3,PCR),(PCCC,PCR)  SET SRCB ZONE IN MNN.
LP10     $MNN  (LP40+1,PCR),(*-*,R1)  SET SIO Q-BYTE FROM TABLE.
*
*              NOW COMPLETE THE CONTROL-CODE BYTE.
*
         $MVC  (LP20+3,PCR),(PCCC,PCR)  MOVE SRCB TO MVC INSTRUCTION.
         $SBF  (LP20+3,PCR),X'E0'  RESET ALL BUT BITS 3-7.
LP20     $MVC  (LP40+2,PCR),(*-*,R1)  SET CONTROL CODE IN THE SIO.
         $TBN  (LP40+1,PCR),4      DOES SIO SAY SKIP...
         $JF   LP30                JUMP IF NOT. ELSE
         $MVC  (PCSKIP,PCR),(LP40+2,PCR) SAVE LINE NR AND
         $SBF  (LP40+1,PCR),4      CHANGE THE SKIP
         $MVI  (LP40+2,PCR),X'01'  TO A SPACE-1.
*
*              NON-PROCESS EXIT TILL PRINTER IS READY.
*
LP30     $TIO  14,0,0,(LP70,PCR)   BRANCH IF NOT READY/UNIT CHECK.
*
*              PRINTER IS READY.  NOW LOAD REGISTERS AND PRINT.
*              THEN NON-PROCESS EXIT TILL PRINTER IS NOT BUSY.
*
         $LIO  14,0,4,(PCDA,PCR)   LOAD MPDAR.
         $LIO  14,0,6,(PCIA,PCR)   LOAD MPIAR.
LP40     $SIO  14,0,0,0            START I/O AS SET UP ABOVE.
         $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TIO  14,0,6,$COMRETB     NON-PROCESS EXIT TILL NOT BUSY.
*
*              CHECK PRINTER STATUS AND RE-ISSUE SIO IF NECESSARY.
*
         $MVI  (PCSNS-1,PCR),0     ZERO STATUS BYTE 1 BEFORE TIO.
         $TIO  14,0,0,(LP70,PCR)   BRANCH IF NOT READY/UNIT CHECK.
         $TBF  (PCSNS-1,PCR),X'16' IF INCREMENTER OR HAMMER CHECK,
         $BF   (LP30,PCR)          GO PRINT THE LINE AGAIN.
         $CLI  (PCSKIP,PCR),0      WAS SKIP CALLED FOR...
         $JE   LP60                JUMP IF NOT.
         $MVI  (LP40+1,PCR),X'E4'  YES. SET SKIP-ONLY
         $MVC  (LP40+2,PCR),(PCSKIP,PCR)  AND LINE NUMBER,
         $MVI  (PCSKIP,PCR),0      ZERO LINE NUMBER,
         $B    (LP30,PCR)          AND GO SKIP.
*
*              PRINTING IS COMPLETE.  FREE THE DATA AREA AND WAIT.
*
LP60     EQU   *
         $SBF  (PCFLG,PCR),PFBSY   SHOW THE DATA AREA FREE.
         $B    $5203               GO WAIT TILL IT AGAIN COMES BUSY.
*
*              POSSIBLE UNIT CHECK.  SENSE AND LOG STATUS.
*
LP70     $ST   ARR,(LP79+3,PCR)    SAVE RETURN ADDRESS.
         $SNS  14,0,3,(PCSNS,PCR)  READ IN THE STATUS BYTES.
         $MVC  (PCMSG+2,PCR),(PCSNS,PCR),2  MOVE STATUS TO MESSAGE.
         $LA   R1,(PCMSG,PCR)      POINT R1 TO MESSAGE
         $B    $MSG                AND PUT IT IN THE TRACE TABLE.
         $L    R1,(FBREG1,FBR)     THEN RESTORE R1.
         $MVC  (PCLOGA,PCR),(PCSNS,PCR)  SET UP STATUS BYTE 1 AND
         $MVC  (PCLOGB,PCR),(PCSNS-1,PCR)  STATUS BYTE 2 FOR LOGGING.
         $LA   R1,(PCLOGA,PCR)     GO TO $LOG SUBROUTINE
         $B    $LOG                  FOR STATUS BYTE 1.
         $LA   R1,(7,R1)           GO TO $LOG SUBROUTINE
         $B    $LOG                  FOR STATUS BYTE 2.
         $LA   R1,PCA              RESTORE REGISTER 1.
LP78     $ST   IAR,(FBENT,FBR)     STORE LOCATION AND NON-
         $TIO  14,0,0,$COMRETB       PROCESS-EXIT TILL 5203 IS READY.
LP79     $B    *-*                 THEN RETURN TO CALLER.
         $DROP PCR                 DISESTABLISH ADDRESSABILITY.
         TITLE 'LOGICAL-READER FUNCTION'
*
*
*              LOGICAL READER - WAIT FOR WORK.
*
*
$READER  $WAIT UNIT                WAIT TO BE POSTED BY MFCU OR 1442.
         $USING HCD,HCR            SET BASE FOR HOPPER CONTROL DSECT.
         $B    $REQ                REQUEST PERMISSION FROM HASP.
         $L    R1,(FBHCP,FBR)      POINT REG 1 TO HOPPER CONTROL AREA.
*
*
*              WAIT FOR PERMISSION TO SEND.  THEN ANALYZE CARDS.
*
*
         $WAIT PERM                WAIT FOR PERMISSION TO SEND.
RDRIO    $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TBN  (HCFLG,HCR),HFRBB   IS THERE A CARD TO PROCESS...
         $BF   $COMRETA            IF NOT, RETURN TO COMMUTATOR.
         $L    R2,(HCRDB,HCR)      POINT R2 TO CARD COLUMN 1.
*
*
*              ANALYZE THE CARD JUST READ.
*
*
RDRCK1   $CLC  (4,R2),LOGEOF,5     IS IT LOGICAL END-OF-FILE...
         $JE   RDREOF              JUMP IF SO.
         AIF   (NOT &S31442).RDX1442  *
         $TBN  (HCFLG,HCR),HFEOF   FOR 1442, WAS LAST CARD READ...
         $JT   RDREOF              JUMP IF SO.
.RDX1442 AIF   (NOT &S3OBJDK).RDR10  *
         $CLI  (80,R2),C'1'        IS IT FIRST 2-FOR-1 CARD...
         $JE   RDRTWO              JUMP IF SO.
.RDR10   ANOP                      *
         EJECT
*
*
*              NORMAL CARD PROCESSING.
*
*
RDR10    $L    R2,(HCFBP,HCR)      POINT R2 TO THE FUNCTION BLOCK.
         $MVC  (FBAREA,FBR),(HCRDB,HCR),2  SET SOURCE AREA ADDRESS.
         $MVC  (FBCLNG,FBR),EIGHTY,2  SET LENGTH OF SOURCE.
         $MVC  (FBSRCB,FBR),(FBRCB,FBR)  SET RCB TO SEND.
         $B    $CMPR               GO COMPRESS AND PUT IN BUFFER.
         $SBF  (HCFLG,HCR),HFRBB   SHOW HOPPER'S READ BUFFER FREE,
         $B    RDRIO               AND WAIT FOR THE NEXT CARD TO READ.
EIGHTY   $DC   YL2(80)             LENGTH OF AN INPUT CARD TO SEND.
         AIF   (NOT &S3OBJDK).RDREOF *
         EJECT
*
*
*              TWO - FOR - ONE  CARD PROCESSING.
*
*
*
*
*              SQUEEZE CARD 1 INTO FIRST 40 BYTES OF PUNCH BUFFER.
*
*
RDRTWO   $ST   R1,RDT10+3          SAVE HOP CTRL AREA POINTER.
         $L    R1,(HCPUB,HCR)      POINT TO THE PUNCH BUFFER.
         $B    RDSQUEZE            GO SQUEEZE THE CARD.
RDT10    $LA   R1,*-*              RESTORE HCA POINTER.
         $L    R2,(HCFBP,HCR)      RESTORE FB POINTER.
         $SBF  (HCFLG,HCR),HFRBB   SHOW READ BUFFER FREE.
         $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TBN  (HCFLG,HCR),HFRBB   WAS A CARD READ...
         $BF   $COMRETA            RETURN TO COMMUTATOR IF NOT.
         $L    R2,(HCRDB,HCR)      POINT R2 TO READ BUFFER.
         $CLI  (80,R2),C'2'        CHECK FOR 2D-CARD INDICATOR.
         $BNE  RDRCK1              IF ABSENT, GO TREAT AS NORMAL.
*
*
*              SQUEEZE CARD 2 INTO PUNCH BUFFER + 40.
*
*
         $ST   R1,RDT30+3          SAVE HCA POINTER.
         $L    R1,(HCPUB,HCR)      POINT R1 TO THE
         $LA   R1,(40,R1)          PUNCH BUFFER PLUS FORTY.
         $B    RDSQUEZE            SQUEEZE THIS CARD.
RDT30    $LA   R1,*-*              RESTORE HCA POINTER.
         $L    R2,(HCRDB,HCR)      POINT R2 TO THE READ BUFFER.
         $L    R1,(HCPUB,HCR)      POINT R1 TO THE PUNCH BUFFER.
         $MVC  (79,R2),(79,R1),80  MOVE CARD INTO READ BUFFER.
         $L    R1,RDT30+3          RESTORE R1 AGAIN
         $B    RDR10               AND TREAT THE CARD AS NORMAL.
.RDREOF  ANOP                      *
*
*
*              END - OF - FILE  PROCESSING.
*
*
RDREOF   $L    R2,(HCFBP,HCR)      POINT R2 TO FUNCTION BLOCK.
         $B    $LEOF               SHOW HASP LOGICAL END-OF-FILE.
         $L    R1,(FBHCP,FBR)      AGAIN POINT TO HOP CTRL AREA.
         $SBN  (HCFLG,HCR),HFEOF   SHOW HOPPER THE END-OF-FILE.
         $SBF  (HCFLG,HCR),HFRBB   RESET THE READ-BUF-BUSY FLAG.
         $B    $READER             THEN WAIT AGAIN FOR WORK.
         AIF   (NOT &S3OBJDK).RDSQUEZ  *
         EJECT
*
*
*              SQUEEZE  SUBROUTINE.
*
*
RDSQUEZE $ST   ARR,RDSQEND+3       SAVE RETURN ADDRESS.
         $MVI  RDSQCT,40           SET COUNT OF 40.
RDSQ0    $CLI  (0,R2),C'0'         CHECK BYTE FOR NUMERIC.
         $JNL  RDSQ1               JUMP IF WITHIN NUMERIC.
         $ALC  (0,R2),FIFTY7       OTHERWISE ADD 57 - THIS MAKES
*                                  C1 THRU C6 GO TO FA THRU FF.
RDSQ1    $CLI  (1,R2),C'0'         DO THE SAME FOR
         $JNL  RDSQ2               THE SECOND BYTE.
         $ALC  (1,R2),FIFTY7
RDSQ2    $MZN  (0,R1),(0,R2)       THEN MOVE THE TWO HALVES
         $MNN  (0,R1),(1,R2)       TO A SINGLE OUTPUT BYTE.
         $LA   R2,(2,R2)           POINT TO NEXT INPUT
         $LA   R1,(1,R1)           AND NEXT OUTPUT BYTES.
         $SLC  RDSQCT,ONE          REDUCE COUNT BY 1.
         $BNE  RDSQ0               LOOP FOR 40 COUNTS.
RDSQEND  $B    *-*                 THEN RETURN TO CALLER.
.RDSQUEZ $DROP HCR                 DROP BASE FOR HOPPER CONTROL DSECT.
         EJECT
*
*
*              CONSTANTS FOR THE LOGICAL READER ---
*
*
FIFTY7   $DC   YL1(57)             57 FOR SQUEEZE ROUTINE.
RDSQCT   $DS   &S3OBJDK.X          SQUEEZE LOOP COUNTER.
RDLEOF   $DC   X'008000'           LOGICAL EOF - RCB, SRCB, SCB.
LOGEOF   $DC   C'/*EOF'            LOGICAL END-OF-FILE INDICATOR.
         SPACE 5
MTWO     $DC   HL2'-2'
ONE      $DC   HL2'1'
WORK     $DS   HL2
         TITLE 'LOGICAL PRINTER FUNCTION'
*
*
*              WAIT FOR PERMISSION.  THEN SEND TO HASP A 'PERMISSION-
*              RECEIVED' SEQUENCE.
*
*
$PRINTER $WAIT PERM                WAIT FOR HASP TO REQUEST PERMISSION.
         $TBF  PCFLG,PFASG         IS THE PRINTER AVAILABLE...
         $BF   $COMRETA            NON-PROCESS EXIT IF NOT.
PRPERM   EQU   *
         $SBN  PCFLG,PFASG         SHOW PRINTER ASSIGNED.
         $B    $PERM               SEND PERMISSION TO HASP.
*
*              SET UP PRINT LINE AND WAIT TILL IT'S PRINTED.
*
PR       $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TBF  PCFLG,PFBSY         IS PRINT BUFFER FREE...
         $BF   $COMRETA            RETURN IF NOT.
         $MVC  LPDA+131,LPDA+132,132  CLEAR PRINTER DATA AREA.
         $MVC  (FBAREA,FBR),PCDA,2 SET OUTPUT AREA FOR $DCOM.
         $B    $DCOM               GO FILL THE PRINT BUFFER.
         $J    PREOF               IF EOF, GO CLEAN UP.
         $MVC  PCCC,(FBSRCB,FBR)   SET SRCB FOR CARRIAGE CTL.
         AIF   (&S35471).PR71
         $CLI  (FBSRCB,FBR),X'8E'  IS THIS THE FORMS MOUNT MESSAGE...
         $JNE  PR1                 JUMP IF NOT.
         $MVI  PCCC,X'83'          YES.  CHANGE SRCB TO PRINT & SPACE 3
         $SBN  PCFLG,PFBSY         AND SHOW PRINT BUFFER BUSY.
         $ST   IAR,(FBENT,FBR)     WAIT TILL
         $TBF  PCFLG,PFBSY         PRINT BUFFER
         $BF   $COMRETA            IS FREE.
         $MVI  PCCC,X'A3'          THEN SET SPACE 3 IMMEDIATE.
PR1      EQU   *
         AGO   .PR71X
.PR71    $CLI  (FBSRCB,FBR),X'8E'  IF THIS IS FORMS MOUNT MESSAGE,
         $BE   PR                  DON'T PRINT IT.
.PR71X   ANOP
         $SBN  PCFLG,PFBSY         SHOW LINE TO BE PRINTED.
         $B    PR                  GO WAIT FOR IT TO COMPLETE.
*
*              LOGICAL END-OF-FILE ON PRINTER.
*
PREOF    $SBF  PCFLG,PFASG         UNASSIGN THE PRINTER.
         $TBF  (FBEWF,FBR),EWFPOST HAS HASP ASKED PERMISSION AGAIN...
         $BT   PRPERM              YES.  GO GIVE HASP PERMISSION.
         $B    $PRINTER            NO.  WAIT TILL HASP ASKS.
         TITLE 'LOGICAL PUNCH FUNCTION'
*
*
*              LOGICAL PUNCH - AWAIT PERMISSION FROM ANY HOPPER ROUTINE
*              TO SEND HASP PERMISSION TO SEND COMPRESSED CARD IMAGES
*              TO US.
*
*
$PUNCH   $WAIT PERM                WAIT FOR HASP TO REQUEST PERMISSION.
PUPERM   EQU   *
         $WAIT UNIT                THEN WAIT FOR MFCU OR 1442.
         $USING HCD,HCR            SET BASE FOR HOPPER CONTROL DSECT.
         $B    $PERM               SEND PERMISSION TO HASP.
*
*              IF PUNCH BUFFER FREE, DECOMPRESS A CARD.
*
PUN      $L    R1,(FBHCP,FBR)      POINT R1 TO HOPPER CONTROL AREA.
PUN20    $ST   IAR,(FBENT,FBR)     SAVE LOCATION FOR NON-PROCESS EXIT.
         $TBF  (HCFLG,HCR),HFPBB   IS PUNCH BUFFER FREE...
         $BF   $COMRETA            NON-PROCESS-EXIT IF NOT.
PUN30    $MVC  (FBAREA,FBR),(HCPUB,HCR),2  SET DECOMPRESSION ARGUMENT.
         $B    $DCOM               DECOMPRESS NEXT CARD.
         $J    PUEOF               JUMP IF END-OF-FILE.
         $SBN  (HCFLG,HCR),HFPBB   OTHERWISE SHOW PUNCH BUFFER BUSY.
         AIF   (NOT &S35424).NOMFCUI
         AIF   (NOT &S31442).PUX1442
         $TBN  (HCFLG,HCR),HF5424  IF DEVICE IS A 5424,
         $JT   PUN40               SKIP LENGTH SPECIFICATION.
.NOMFCUI ANOP
         $MVC  (HCPLN,HCR),(HCPUB,HCR),2  OTHERWISE
         $SLC  (HCPLN,HCR),(FBAREA,FBR),2  CALCULATE
         $SBF  (HCPLN,HCR),X'80'   128-(NR OF COLUMNS TO PUNCH).
         $B    PUN20               THEN WAIT FOR PUNCH TO COMPLETE.
         AIF   (NOT &S35424).NOMFCUJ
PUN40    EQU   *
.PUX1442 $L    R1,(HCPUB,HCR)      POINT TO THE CARD IMAGE.
         $CLI  (0,R1),X'6A'        IS IT A JOB SEPARATOR CARD...
         $JNE  PUNOTJS             JUMP IF NOT.
         $MVC  (31,R1),PUJOBNR,32  YES.  SET SKELETON S/3 HEADER.
         $CLI  (41,R1),X'6A'       IS THOUSANDS OF JOB NR BLANK...
         $JE   PUJN1               JUMP IF YES.
         $MNN  (16,R1),(41,R1)     ELSE SET THOUSANDS IN CARD.
PUJN1    $CLI  (51,R1),X'6A'       IS HUNDREDS OF JOB NR BLANK...
         $JE   PUJN2               JUMP IF YES.
         $MNN  (17,R1),(51,R1)     ELSE SET HUNDREDS IN CARD.
PUJN2    $CLI  (61,R1),X'6A'       IS TENS OF JOB NR BLANK...
         $JE   PUJN3               JUMP IF YES.
         $MNN  (18,R1),(61,R1)     ELSE SET TENS IN CARD.
PUJN3    $MNN  (19,R1),(71,R1)     SET UNITS IN CARD.
         $MVI  (95,R1),C' '        BLANK OUT
         $MVC  (94,R1),(95,R1),63  COLUMNS 33-96.
         $B    PUN                 THEN WAIT FOR PUNCH TO COMPLETE.
PUNOTJS  EQU   *
         AIF   (NOT &S396COL).PUNO96
         $CLI  (72,R1),X'80'       IS THIS HALF A 1-FOR-2 CARD...
         $JNE  PUNOT96             JUMP IF NOT.
         $TBN  (79,R1),1           IS THIS THE FIRST HALF...
         $JF   PU96E               JUMP IF NOT.
         $MVC  (FB48SV,FBR),(49,R1),48  SAVE FIRST HALF.
         $L    R1,(FBHCP,FBR)      RESTORE HCA POINTER.
         $SBF  (HCFLG,HCR),HFPBB   SHOW PUNCH BUFFER NOT BUSY.
         $B    PUN30               GO DECOMPRESS HEXT HALF.
PU96E    $MVC  (95,R1),(49,R1),48  SECOND HALF.  MOVE IT TO COLS 49-96
         $MVC  (47,R1),(FB48SV,FBR),48  AND FIRST HALF TO COLS 1-48.
         $B    PUN                 THEN WAIT FOR PUNCH TO COMPLETE.
PUNOT96  EQU   *
.PUNO96  AIF   (NOT &S3OBJDK).PUNOOBJ
         $CLI  (0,R1),X'02'        IS THIS AN OS OBJECT DECK CARD...
         $JE   PUNTWO              JUMP IF SO.
.PUNOOBJ $B    PUN                 GO WAIT FOR PUNCH TO COMPLETE.
         AIF   (NOT &S3OBJDK).PUEOF
*
*              2-FOR-1 PROCESSING.  CREATE FIRST CARD OF TWO.
*
*
PUNTWO   $MVC  (FB40SV,FBR),(79,R1),40  SAVE LAST 40 CARD COLUMNS.
         $MVC  (79,R1),(39,R1),40  SHIFT CARD RIGHT 40 BYTES.
         $MVI  (80,R1),C'1'        SHOW THIS CARD IS 1ST OF 2.
         $B    PUEXPAND            EXPAND THE CARD.
         $L    R1,(FBHCP,FBR)      RESTORE HOPPER CONTROL AREA POINTER.
         $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TBF  (HCFLG,HCR),HFPBB   IS PUNCH BUFFER FREE YET...
         $BF   $COMRETA            IF NOT, RETURN TO COMMUTATOR.
*
*
*              2-FOR-1 - CREATE SECOND CARD OF TWO.
*
*
         $SBN  (HCFLG,HCR),HFPBB   SHOW CARD READY TO PUNCH.
         $L    R1,(HCPUB,HCR)      THEN POINT TO PUNCH BUFFER.
         $MVC  (79,R1),(FB40SV,FBR),40  MOVE LAST 40 COLUMNS TO BUFFER.
         $MVI  (80,R1),C'2'        MARK THIS CARD AS SECOND CARD.
         $B    PUEXPAND            EXPAND CARD IN PUNCH BUFFER.
         $B    PUN                 THEN RETURN TO NORMAL PROCESSING.
         EJECT
.PUEOF   ANOP                      *
.NOMFCUJ ANOP
*
*              LOGICAL END-OF-FILE.
*
PUEOF    $SBN  (HCFLG,HCR),HFEOF   SHOW LOGICAL EOF.
         $TBF  (FBEWF,FBR),EWFPOST HAS HASP ASKED PERMISSION AGAIN...
         $BT   PUPERM              YES.  GO GIVE HASP PERMISSION.
         $B    $PUNCH              NO.  WAIT TILL HASP ASKS.
         AIF   (NOT &S3OBJDK).PUXPAND  *
*
*
*              EXPAND CARDS TO TWO-FOR-ONE.
*
*
PUEXPAND $ST   ARR,PUXRET+3        SAVE RETURN ADDRESS.
         $ST   R2,PUX90+3          SAVE REGISTER 2.
         $LA   R2,(0,R1)           LOAD R2 FROM R1.
         $MVI  PUEXCT,40           SET COUNT TO 40.
PUX20    $MNZ  (0,R2),(40,R1)      SET NUMERIC PORTION OF BYTE.
         $SBN  (0,R2),X'F0'        MAKE ZONE BITS ALL 1.
         $CLI  (0,R2),C'9'         IF F0 THROUGH F9, IT'S
         $JNH  PUX30               CORRECT AS IS.
         $SLC  (0,R2),FIFTY7       MAKE FA THRU FF INTO C1 THRU C6.
PUX30    $MNN  (1,R2),(40,R1)      SET NUMERIC PORTION OF 2D BYTE.
         $SBN  (1,R2),X'F0'        SET ALL ZONE BITS ON.
         $CLI  (1,R2),C'9'         IF F0 THRU F9,
         $JNH  PUX40               IT'S ALL RIGHT AS IS.
         $SLC  (1,R2),FIFTY7       OTHERWISE MAKE IT C1 THROUGH C6.
PUX40    $LA   R2,(2,R2)           POINT TO 2D NEXT SINK BYTE
         $LA   R1,(1,R1)           AND TO NEXT SOURCE BYTE.
         $SLC  PUEXCT,ONE          IF COUNT NOT EXPIRED,
         $BNE  PUX20               LOOP TO DO THE REST.
PUX90    $LA   R2,*-*              OTHERWISE RESTORE REGISTER 2
PUXRET   $B    *-*                 AND RETURN TO THE CALLER.
PUEXCT   $DS   X                   LOOP COUNTER BYTE.
.PUXPAND $DROP HCR                 DROP BASE FOR HOPPER CONTROL DSECT.
         AIF   (NOT &S35424).NOMFCUK
PUJOBNR  $DC   C'**********  JOB 0000  **********'  JOB SEPARATOR CARD.
.NOMFCUK ANOP
         AIF   (NOT &S35471).NO5471  *
         TITLE 'CONSOLE CONTROL AREA FOR 5471 PRINTER/KEYBOARD'
CCR      EQU   R1
CCA      EQU   *
         $USING CCA,CCR
*                                                                     *
***********************************************************************
*                                                                     *
*              CONSOLE CONTROL AREA                                   *
*                                                                     *
***********************************************************************
*                                                                     *
CCFLG    DC    YL1(CFOUT+CFPBSY)   FLAG BYTE.
CFPBSY   EQU   128                   PRINTER IS BUSY.
CFPREQ   EQU   64                    REQUEST TO SIO ON PRINTER.
CFKREQ   EQU   32                    REQUEST TO SIO ON KEYBOARD.
CFCREQ   EQU   16                    REQUEST TO CARRIAGE-RETURN.
CFOUT    EQU   8                     OUTPUT IS BEING PROCESSED.
CFREQ    EQU   4                     REQUEST-PENDING LIGHT IS LIT.
CFINP    EQU   2                     PROCEED LIGHT IS LIT.
CFACT    EQU   1                     5471 IS AVAILABLE.
*                                                                     *
***********************************************************************
*                                                                     *
*              KEYBOARD SECTION                                       *
*                                                                     *
***********************************************************************
*                                                                     *
CCKSN1   $DC   YL2(0)              KEYBOARD STATUS BYTES.
CCKSN0   EQU   CCKSN1-1
CCKCMD   DC    X'0'                COMMAND ASSOC WITH CFKREQ.
CCKD     DC    CL120'COMMUNICATION ESTABLISHED'
CCKC     $DC   YL2(CCKD)           POINTER TO CURRENT BYTE.
CCKF     $DC   YL2(CCKD)           POINTER TO FIRST BYTE.
CCKL     $DC   YL2(CCKD+L'CCKD-1)  POINTER TO LAST AVL BYTE.
*                                                                     *
***********************************************************************
*                                                                     *
*              KEYBOARD COMMANDS                                      *
*                                                                     *
***********************************************************************
*                                                                     *
CCKTB    EQU   *              THESE FOUR RESET AND ALLOW PROCEED.
         DC    X'05'               ENABLE REQUEST KEY, NO LIGHTS.
         DC    X'21'               REQUEST LIGHT, ALL KEYS DISABLED.
         DC    X'17'               PROCEED LIGHT, ALL KEYS ENABLED.
         DC    X'33'               BOTH LIGHTS, ONLY 'OTHER' KEYS ENB.
*                                                                     *
***********************************************************************
*                                                                     *
*              PRINTER SECTION                                        *
*                                                                     *
***********************************************************************
*                                                                     *
CCPSN1   $DC   YL2(0)              PRINTER STATUS BYTES.
CCPCMD   DC    X'0'                COMMAND ASSOC WITH CFPREQ.
CCPCHAR  DC    X'0'                CHARACTER TO PRINT.
CCPD     EQU   CCKD                PRINTER DATA AREA.
CCPF     EQU   CCKF                POINTER TO FIRST BYTE.
CCPC     EQU   CCKC                POINTER TO CURRENT BYTE.
CCPL     $DC   YL2(CCPD+25)        POINTER TO LAST+1 BYTE TO PRINT.
*                                                                     *
***********************************************************************
*                                                                     *
*              PRINTER COMMANDS                                       *
*                                                                     *
***********************************************************************
*                                                                     *
CCPTB    EQU   *
         DC    X'85'               PRINT, ENABLE, AND RESET.
         DC    X'45'               CARRIAGE RETURN, ENABLE, AND RESET.
*                                                                     *
***********************************************************************
*                                                                     *
*              MISCELLANEOUS                                          *
*                                                                     *
***********************************************************************
*                                                                     *
CCBUF    $DC   YL2(0)              STOLEN-BUFFER POINTER.
CCFOUR   $DC   YL2(4)              CONSTANT OF FOUR.
CCMSGP   $DC   YL2(MSGFIRST)       INTERNAL-MESSAGE POINTER.
CCM4     $DC   HL2'-4'             CONSTANT OF MINUS 4.
*                                                                     *
***********************************************************************
*                                                                     *
*              SUBROUTINE TO START INPUT/OUTPUT                       *
*                                                                     *
***********************************************************************
*                                                                     *
CCSIOZ   $MVI  (CCSIO2+1,CCR),0    SET TO RESTORE REGISTERS.
CCSIO    $ST   ARR,(CCSIOR+3,CCR)  SAVE RETURN ADDRESS.
         $MVC  (CCSIOX+2,CCR),(0,R2)  SET SIO CC-BYTE.
         $SBF  (CCSIOX+1,CCR),8    ASSUME SIO IS FOR KEYBOARD.
         $TBF  (0,R2),X'C0'        IS SIO FOR KEYBOARD...
         $JT   CCSIO2              JUMP IF SO.
         $SBN  (CCSIOX+1,CCR),8    NO, SIO IS FOR PRINTER.
CCSIO1   $LIO  1,1,0,(CCPCHAR+1,CCR)  LOAD CHARACTER FOR PRINTING.
         $SBN  (CCFLG,CCR),CFPBSY  SHOW PRINTER BUSY.
CCSIO2   $NOPB (CCRR,CCR)          RESTORE REGISTERS IF SET TO $B.
         $MVI  CCSIO2+1,X'80'      RESET $B TO $NOPB.
CCSIOX   $SIO  1,*-*,0,*-*         START THE KEYBOARD OR PRINTER.
CCSIOR   $B    *-*                 THEN RETURN TO CALLER.
*                                                                     *
***********************************************************************
*                                                                     *
*              SUBROUTINE TO RESTORE REGISTERS                        *
*                                                                     *
***********************************************************************
*                                                                     *
CCRR     $ST   ARR,(CCARR,CCR)     SAVE RETURN ADDRESS.
         $LA   R2,*-*              RESTORE REGISTER 2.
CCR2     EQU   *-1
         $L    PSR,(CCPSR,CCR)     RESTORE PROGRAM STATUS REGISTER.
         $LA   R1,*-*              RESTORE REGISTER 1.
CCR1     EQU   *-1
         $B    *-*                 RETURN TO CALLER.
CCARR    EQU   *-1
CCPSR    $DC   YL2(0)              PROGRAM STATUS REGISTER SAVEAREA.
*                                                                     *
***********************************************************************
*                                                                     *
*              SUBROUTINE TO POST CONSOLE PROCESSOR                   *
*                                                                     *
***********************************************************************
*                                                                     *
CCPOST   $ST   ARR,(CCPEND+3,CCR)  SAVE RETURN ADDRESS.
         $SBN  (CCFLG,CCR),CFACT   TURN ON THE ACTION BIT.
         $POST $FBCON,WORK+EWFPOST POST CONSOLE PROCESSOR.
CCPEND   $B    *-*                 RETURN TO CALLER.
*                                                                     *
***********************************************************************
*                                                                     *
*              START-UP-THE-KEYBOARD ROUTINE                          *
*                                                                     *
***********************************************************************
*                                                                     *
CIKGO    $LA   R2,(CCKTB,CCR)      POINT TO TABLE OF KEYBOARD COMMANDS,
CIKCMD   $LA   R2,(*-*,R2)         AND SELECT THE CORRECT ONE.
         $B    (CCSIOZ,CCR)        THEN GO START THE KEYBOARD.
*      LABEL CINT MUST FOLLOW IMMEDIATELY
         TITLE 'CONSOLE INTERRUPT ROUTINE FOR 5471 PRINTER/KEYBOARD'
*                                                                     *
***********************************************************************
*                                                                     *
*              CONTROL STARTS HERE FOR ALL 5471 INTERRUPTS            *
*                                                                     *
***********************************************************************
*                                                                     *
CINT     $ST   R1,CCR1             SAVE REGISTER 1.
         $LA   R1,CCA              SET CONTROL AREA ADDRESSABILITY.
         $ST   R2,(CCR2,CCR)       SAVE REGISTER 2.
         $ST   PSR,(CCPSR,CCR)     SAVE PROGRAM STATUS REGISTER.
         $JF   *+1                 RESET TEST-FALSE INDICATOR.
         $SNS  1,0,1,(CCKSN1,CCR)  READ KEYBOARD INFORMATION.
         $TBF  (CIKCMD+2,CCR),1    IF REQ KEY INTERRUPTS ARE ENABLED
         $TBN  (CCKSN1,CCR),X'80'  AND THIS IS A REQUEST,
         $JT   CIRQUEST            GO TAKE CARE OF IT.
         $TBN  (CIKCMD+2,CCR),2    IF OTHER KEY INTERRUPTS ARE ENABLED
         $TBN  (CCKSN1,CCR),X'40'  AND THIS IS END/CANCEL,
         $JT   CICANCEL            GO TAKE CARE OF IT.
         $TBN  (CIKCMD+2,CCR),2    IF OTHER KEY INTERRUPTS ARE DISABLED
         $TBN  (CCKSN1,CCR),8      OR THIS IS NOT RETURN/DATA,
         $JF   CIPRT               IT MUST BE A PRINTER INTERRUPT.
         $TBN  (CCKSN1,CCR),4      IF THIS IS THE RETURN KEY,
         $JT   CIEND               TREAT IT LIKE THE END KEY.
*                                                                     *
***********************************************************************
*                                                                     *
*              DATA KEY INTERRUPT                                     *
*                                                                     *
***********************************************************************
*                                                                     *
         $MVC  (CCPCHAR,CCR),(CCKSN0,CCR)  SET CHARACTER FOR PRINTING.
         $LA   R2,(CCPTB,CCR)      SET SIO ARGUMENT.
         $B    (CCSIO,CCR)         GO START PRINTING.
         $L    R2,(CCKC,CCR)       POINT TO PLACE IN BUFFER.
         $MVC  (0,R2),(CCPCHAR,CCR)  MOVE CHARACTER TO BUFFER.
         $LA   R2,(1,R2)           UP PLACE POINTER BY 1
         $ST   R2,(CCKC,CCR)       AND SAVE IT.
         $CLC  (CCKC,CCR),(CCKL,CCR),2  ARE WE OUT OF BUFFER...
         $BNH  (CIKGO,CCR)         IF NOT, GO START KEYBOARD.
         $SBN  (CCFLG,CCR),CFCREQ  REQUEST CARRIAGE RETURN.
         $J    CIEND1              SKIP IMMEDIATE CARRIAGE RETURN.
*                                                                     *
***********************************************************************
*                                                                     *
*              CANCEL KEY INTERRUPT                                   *
*                                                                     *
***********************************************************************
*                                                                     *
CICANCEL EQU   *
         $TBN  (CCKSN1,CCR),X'10'  END/CANCEL.  IS IT END KEY...
         $JT   CIEND               JUMP IF SO.  OTHERWISE CANCEL.
         $MVI  (CCPCHAR,CCR),C'*'  SHOW CANCEL WITH ASTERISK.
         $LA   R2,(CCPTB,CCR)      SET SIO ARGUMENT.
         $B    (CCSIO,CCR)         GO PRINT ASTERISK.
         $SBN  (CCFLG,CCR),CFCREQ  REQUEST CARRIAGE RETURN.
         $MVC  (CCKC,CCR),(CCKF,CCR),2  RESET BUFFER POINTER.
         $B    (CIKGO,CCR)         THEN GO START THE KEYBOARD.
*                                                                     *
***********************************************************************
*                                                                     *
*              END KEY OR RETURN KEY INTERRUPT                        *
*                                                                     *
***********************************************************************
*                                                                     *
CIEND    $LA   R2,(CCPTB+1,CCR)    SET SIO ARG FOR CARRIAGE RETURN.
         $B    (CCSIO,CCR)         GO START CARRIAGE RETURN.
CIEND1   $SBF  (CIKCMD+2,CCR),2    RESET PROCEED IN KEYBOARD COMMAND,
         $B    (CCPOST,CCR)        POST CONSOLE PROCESSOR,
         $B    (CIKGO,CCR)         AND GO START THE KEYBOARD.
*                                                                     *
***********************************************************************
*                                                                     *
*              REQUEST KEY INTERRUPT                                  *
*                                                                     *
***********************************************************************
*                                                                     *
CIRQUEST $SBN  (CIKCMD+2,CCR),1    CHANGE THE KEYBOARD COMMAND.
         $SBN  (CCFLG,CCR),CFREQ   SHOW REQUEST TO CONSOLE PROCESSOR.
         $TBF  (CCFLG,CCR),CFINP+CFOUT  IF NOTHING IS HAPPENING,
         $BT   (CCPOST,CCR)        POST THE CONSOLE PROCESSOR.
         $B    (CIKGO,CCR)         ANYWAY, GO START THE KEYBOARD.
*                                                                     *
***********************************************************************
*                                                                     *
*              INTERRUPT FROM THE PRINTER                             *
*                                                                     *
***********************************************************************
*                                                                     *
CIPRT    $SBF  (CCFLG,CCR),CFPBSY  RESET PRINTER-BUSY BIT.
CIP1     $TBN  (CCFLG,CCR),CFCREQ  IS CARRIAGE RETURN REQUEST PENDING..
         $JT   CIP3                YES.  GO START CARRIAGE RETURN.
CIP2     $TBN  (CCFLG,CCR),CFOUT   IS THE PRINTER PROCESSING OUTPUT...
         $JF   CIP4                JUMP IF NOT.
         $L    R2,(CCPC,CCR)       YES.  POINT TO PLACE IN BUFFER.
         $LA   R2,(1,R2)           UP THE POINTER BY 1,
         $ST   R2,(CCPC,CCR)       AND SAVE IT.
         $MVC  (CCPCHAR,CCR),(0,R2)  MOVE THE CHARACTER FOR PRINTING.
         $LA   R2,(CCPTB,CCR)      SET SIO ARGUMENT TO PRINT.
         $CLC  (CCPC,CCR),(CCPL,CCR),2  IS THE OUTPUT COMPLETE...
         $JL   CIPSIO              JUMP IF NOT TO START PRINTER.
         $SBF  (CCFLG,CCR),CFOUT   YES.  RESET OUTPUT FLAG
         $B    (CCPOST,CCR)        AND POST CONSOLE PROCESSOR.
CIP3     $SBF  (CCFLG,CCR),CFCREQ  RESET CARRIAGE-RETURN BIT, AND
         $LA   R2,(CCPTB+1,CCR)    SET SIO ARG FOR CARRIAGE RETURN.
CIPSIO   $B    (CCSIOZ,CCR)        GO START THE PRINTER.
         $B    CINT                ON INTERRUPT, GO TO THE TOP.
CIP4     $B    (CCRR,CCR)          RESTORE REGISTERS,
         $SIO  1,1,0,1             RESET AND DISABLE PRINTER,
         $B    CINT                AND GO TO THE TOP ON INTERRUPT.
         TITLE 'CONSOLE PROCESSOR FOR 5471 PRINTER/KEYBOARD'
*                                                                     *
***********************************************************************
*                                                                     *
*              5471 CONSOLE PROCESSOR                                 *
*                                                                     *
***********************************************************************
*                                                                     *
$CON     $ST   IAR,(FBENT,FBR)     STORE LOC FOR NON-PROCESS EXIT.
         $TBF  (FBEWF,FBR),EWFPOST HAVE WE BEEN POSTED...
         $BF   $COMRETA            IF NOT, NON-PROCESS-EXIT.
         $SBN  (FBEWF,FBR),EWFPOST OTHERWISE RESET POST FLAG.
*                                                                     *
***********************************************************************
*                                                                     *
*              COMPLETED INPUT IS PROCESSED HERE.                     *
*                                                                     *
***********************************************************************
*                                                                     *
         $TBN  (CCFLG,CCR),CFACT+CFINP  HAS 5471 JUST COMPLETED INPUT..
         $JF   CONREQ              JUMP IF NOT.
         $SBF  (CCFLG,CCR),CFINP   YES.  RESET INPUT FLAG.
         $L    R1,(CCBUF,CCR)      REPLACE STOLEN
         $MVC  (0,R1),$MLPOOL,2      MULTILEAVING BUFFER
         $ST   R1,$MLPOOL              IN BUFFER POOL.
         $L    R1,(FBREG1,FBR)     RESTORE REGISTER 1.
         $SLC  (CCKC,CCR),(CCKF,CCR),2  COMPUTE INPUT LENGTH.
         $JZ   CONREQ              IF NO INPUT, JUMP.
         $MVC  (FBAREA,FBR),(CCKF,CCR),2  SET COMPRESSION SOURCE AREA.
         $MVC  (FBCLNG,FBR),(CCKC,CCR),2  SET LENGTH TO COMPRESS.
         $MVI  (FBSRCB,FBR),X'92'  SET RCB TO SEND.
         $B    $CMPR               COMPRESS AND PUT INTO BUFFER.
         $B    $BFLUSH             FLUSH THE BUFFER.
         $LA   CCR,CCA             RESTORE R1.
*                                                                     *
***********************************************************************
*                                                                     *
*              REQUEST FOR INPUT IS PROCESSED HERE.                   *
*                                                                     *
***********************************************************************
*                                                                     *
CONREQ   $TBN  (CCFLG,CCR),CFREQ+CFACT  IS THE REQUEST LIGHT LIT...
         $JF   CONOUT              JUMP IF NOT.
         $CLI  $MLPOOL-1,0         CAN WE STEAL A TELEPROCESSING BUFFER
         $JE   CONOUT              JUMP IF NOT.
         $L    R1,$MLPOOL          YES.  STEAL A
         $MVC  $MLPOOL,(0,R1),2      TELEPROCESSING BUFFER
         $ST   R1,CCBUF                AND RESTORE
         $LA   R1,CCA                    REGISTER 1.
         $SBF  (CCFLG,CCR),CFREQ+CFACT  RESET REQUEST AND ACTION FLAGS.
         $SBN  (CCFLG,CCR),CFINP   SET INPUT FLAG.
         $MVC  (CCKC,CCR),(CCKF,CCR),2  RESET 5471 BUFFER POINTER.
         $SIO  1,0,0,0             DISABLE THE KEYBOARD.
         $MVI  (CIKCMD+2,CCR),2    SET COMMAND TO PROCEED.
         $SIO  1,0,0,X'17'         ENABLE ALL KEYS, SHOW PROCEED LIGHT.
*                                                                     *
***********************************************************************
*                                                                     *
*              CHECK IF WE CAN START OUTPUT NOW.                      *
*                                                                     *
***********************************************************************
*                                                                     *
CONOUT   $TBF  (CCFLG,CCR),CFOUT+CFINP  IS ANYTHING HAPPENING...
         $JF   CONEND              YES.  RETURN TO THE TOP.
         $SNS  1,1,1,(CCPSN1,CCR)  GET 5471 PRINTER STATUS.
         $TBN  (CCPSN1,CCR),4      IS END-OF-FORMS BIT ON...
         $JT   CONEND              YES.  RETURN TO THE TOP.
         $CLC  MSGPLACE,(CCMSGP,CCR),2  ARE WE UP TO DATE ON MESSAGES..
         $JE   CNOMSG              JUMP IF WE ARE.
*                                                                     *
***********************************************************************
*                                                                     *
*              PROCESS INTERNAL (8-CHARACTER) MESSAGES HERE           *
*                                                                     *
***********************************************************************
*                                                                     *
         $MVI  (CCPD+7,CCR),C'0'   SET 1ST 8 DATA BYTES
         $MVC  (CCPD+6,CCR),(CCPD+7,CCR),7  TO CHARACTER '0'.
         $ALC  (CCMSGP,CCR),FOUR,2 UP MESSAGE POINTER BY 4.
         $CLC  (CCMSGP,CCR),AMSGLAST,2  IS POINTER PAST END OF MESSAGES
         $JNH  *+1+5               JUMP IF NOT.
         $MVC  (CCMSGP,CCR),AMSGFRST,2  YES.  RESET THE POINTER.
         $L    R2,(CCMSGP,CCR)     SET SOURCE REG TO LAST BYTE PREV MSG
         $A    R2,(CCM4,CCR)       BACK UP TO THE RIGHT MESSAGE.
         $LA   R1,(CCPD,CCR)       AND SINK REGISTER TO START OF BUF.
         $MVI  CMSGK,4             SET LOOP COUNT TO 4.
CMSGL    $LA   R2,(1,R2)           POINT TO NEXT SOURCE BYTE.
         $MNZ  (0,R1),(0,R2)       MOVE ZONE FROM SOURCE TO SINK.
         $MNN  (1,R1),(0,R2)       MOVE NUM FROM SOURCE TO SINK+1.
         $CLI  (0,R1),C'9'         IS SINK BYTE NUMERIC...
         $JNH  CML1                JUMP IF YES.
         $SLC  (0,R1),FIFTY7       NO.  MAKE IT A THROUGH F.
CML1     $CLI  (1,R1),C'9'         SAME FOR
         $JNH  CML2                  THE SECOND
         $SLC  (1,R1),FIFTY7           SINK BYTE.
CML2     $LA   R1,(2,R1)           POINT TO NEXT PAIR OF SINK BYTES.
         $SLC  CMSGK,ONE           REDUCE COUNTER BY 1.
         $BNZ  CMSGL               LOOP 4 TIMES.
         $ST   R1,CCPL             SET LOC OF LAST+1 SINK BYTE.
         $LA   R1,CCA              RESTORE REGISTER 1 AS BASE.
         $LA   R2,$FBCON           RESTORE REGISTER 2 AS FB POINTER.
         $J    CONMSG              AND THEN START PRINTING.
CMSGK    DS    X                   LOOP COUNTER.
*                                                                     *
***********************************************************************
*                                                                     *
*              PROCESS MESSAGES FROM HASP HERE                        *
*                                                                     *
***********************************************************************
*                                                                     *
CNOMSG   $CLI  (FBBUF-1,FBR),0     IS THERE A MESSAGE FROM HASP...
         $JE   CONEND              JUMP IF NOT.
         $MVC  (FBAREA,FBR),(CCPF,CCR),2  SHOW SINK AREA ADDRESS.
         $B    $DCOM               DECOMPRESS A MESSAGE.
         $NOPJ *+1                 $DCOM RETURNS TO *+3 IF NOT EOF.
         $MVC  (CCPL,CCR),(FBAREA,FBR),2  SAVE ADR OF LAST+1 BYTE.
*                                                                     *
***********************************************************************
*                                                                     *
*              START PRINTING EITHER MESSAGE TYPE HERE.               *
*                                                                     *
***********************************************************************
*                                                                     *
CONMSG   $ST   IAR,(FBENT,FBR)     NON-PROCESS EXIT
         $TBN  (CCFLG,CCR),CFPBSY    TILL PRINTER IS
         $BT   $COMRETA                NOT BUSY.
         $MVC  (CCPC,CCR),(CCPF,CCR),2  SHOW MESSAGE STARTING ADDRESS.
         $SBN  (CCFLG,CCR),CFOUT+CFPBSY  THEN SET OUTPUT AND PRINTER
         $SBF  (CCFLG,CCR),CFACT   BUSY FLAGS, RESET ACTION FLAG.
         $LIO  1,1,0,(CCPD+1,CCR)  LOAD FIRST CHARACTER FOR PRINTING.
         $SIO  1,1,0,X'85'         AND START THE PRINTER.
CONEND   $B    $CON                THEN RETURN TO THE TOP.
         $DROP CCR                 DISESTABLISH ADDRESSABILITY.
         AGO   .NOCONP             *
.NO5471  AIF   (NOT &S35475).NO5475  *
         TITLE '5475 DATA ENTRY KEYBOARD CONTROL AREA'
*                                                                     *
***********************************************************************
*                                                                     *
*              5475 DATA ENTRY KEYBOARD CONTROL AREA                  *
*                                                                     *
***********************************************************************
*                                                                     *
CCA      EQU   *                   START OF CONTROL AREA.
CCR      EQU   R1                  BASE REGISTER FOR CONTROL AREA.
         $USING CCA,CCR            ESTABLISH ADDRESSABILITY.
CCR1     $DS   YL2                 SAVE AREA FOR REGISTER 1.
CCR2     $DS   YL2                 SAVE AREA FOR REGISTER 2.
CCPSR    $DS   YL2                 SAVE AREA FOR PROGRAM STATUS REG.
CCKF     $DC   YL2(CCKD)           POINTER TO 1ST BYTE OF BUFFER.
CCKL     $DC   YL2(CCKD+L'CCKD)    POINTER TO LAST+1 BYTE OF BUFFER.
CCKC     $DC   YL2(CCKD)           POINTER TO CURRENT BYTE OF BUFFER.
CCDC     $DC   XL2'EE24'           CURRENT DISPLAY INDICATORS.
CCDF     $DC   XL2'EE24'           INITIAL DISPLAY INDICATORS.
CCDT     DC    X'EE24BAB674D6DEA4FEF6'  DISPLAY INDICATORS TABLE.
CCEC     $DC   C'01'               CURRENT EBCDIC INDICATORS.
CCEF     $DC   C'01'               INITIAL DISPLAY INDICATORS.
CCKD     DC    CL120' '            BUFFER.
CCS1     $DS   YL2                 SENSE BYTES FOR N = 1.
CCS2     $DS   YL2                 SENSE BYTES FOR N = 2.
         TITLE '5475 DATA ENTRY KEYBOARD INTERRUPT HANDLER'
*                                                                     *
***********************************************************************
*                                                                     *
*              5475 DATA ENTRY KEYBOARD INTERRUPT HANDLER             *
*                                                                     *
***********************************************************************
*                                                                     *
CINT     $ST   R1,CCR1             SAVE REGISTER 1.
         $LA   R1,CCA              SET ADR OF CONSOLE CONTROL AREA.
         $ST   R2,(CCR2,CCR)       SAVE REGISTER 2
         $ST   PSR,(CCPSR,CCR)     AND PROGRAM STATUS REGISTER.
         $JF   *+1                 RESET TEST-FALSE INDICATOR.
         $SNS  1,0,1,CCS1          GET FOUR
         $SNS  1,0,2,CCS2            STATUS BYTES.
         $TBN  (CCS2,CCR),1        IS THIS A FUNCTION KEY INTERRUPT...
         $JT   CIFUNC              JUMP IF SO.
         $TBN  (CCS1,CCR),1        IS THIS A DATA KEY INTERRUPT...
         $JF   CIERROR             IF MULTI-PUNCH OR NONE, ERROR.
*                                                                     *
***********************************************************************
*                                                                     *
*              DATA KEY INTERRUPT                                     *
*                                                                     *
***********************************************************************
*                                                                     *
         $TBF  (CCS1,CCR),4        IF MULTI-PUNCH TOO,
         $TBF  CISIO+2,X'20'       OR IF THE ERROR LIGHT WAS ON,
         $JF   CIERROR             SHOW AN ERROR.
         $L    R2,(CCKC,CCR)       GET POINTER TO CURRENT CHARACTER.
         $MVC  (0,R2),(CCS1-1,CCR) MOVE KEYED DATA TO IT.
         $LA   R2,(1,R2)           POINT TO NEXT CHARACTER.
         $ST   R2,(CCKC,CCR)       SAVE THE POINTER.
         $CLC  (CCKC,CCR),(CCKL,CCR),2  ARE WE AT BUFFER END...
         $JNL  CIEND               JUMP IF SO.
         DC    X'5601',YL2(CCEC-CCA,CCEF-CCA) $AZ CCEC,CCEF,2
*                                  ADD ONE TO EBCDIC COUNTER.
         $MNN  CID1+3,(CCEC-1,CCR)  SET MVC FOR LEFT DISPLAY.
         $MNN  CID2+3,(CCEC,CCR)  SET MVC FOR RIGHT DISPLAY.
         $LA   R2,(CCDT,CCR)       POINT TO DISPLAY TABLE.
CID1     $MVC  (CCDC-1,CCR),(*-*,R2)  SET LEFT DISPLAY CHARACTER.
CID2     $MVC  (CCDC,CCR),(*-*,R2)  SET RIGHT DISPLAY CHARACTER.
         $J    CIEXIT              RETURN FROM INTERRUPT.
*                                                                     *
***********************************************************************
*                                                                     *
*              FUNCTION KEY INTERRUPT                                 *
*                                                                     *
***********************************************************************
*                                                                     *
CIFUNC   $TBF  (CCS1,CCR),5        IF MULTIPCH OR DATA KEY ALSO,
         $JF   CIERROR             SHOW AN ERROR.
         $TBN  (CCS2-1,CCR),4      IF NOT ERROR RESET KEY,
         $JF   CIF1                SKIP.
         $MVI  CISIO+2,X'4F'       OTHERWISE RESET ERROR.
CIF1     $TBN  CISIO+2,X'20'       IF ERROR LIGHT NOT OFF,
         $JT   CIERROR             SHOW ERROR AGAIN.
         $TBN  (CCS2-1,CCR),8      IF NOT FIELD ERASE KEY,
         $JF   CIF2                JUMP.
*                                                                     *
***********************************************************************
*                                                                     *
*              FUNCTION KEY -- FIELD ERASE KEY FUNCTION               *
*                                                                     *
***********************************************************************
*                                                                     *
         $MVC  (CCEC,CCR),(CCEF,CCR),2  REFRESH EBCDIC COUNTER.
         $MVC  (CCDC,CCR),(CCDF,CCR),2  REFRESH DISPLAY COUNTER.
         $MVI  (CCKD+119,CCR),C' '  SET INPUT BUFFER
         $MVC  (CCKD+118,CCR),(CCKD+119,CCR),119   TO BLANKS.
         $MVC  (CCKC,CCR),(CCKF,CCR),2  REFRESH INPUT BUFFER POINTER.
         $J    CIEXIT              EXIT FROM INTERRUPT.
*                                                                     *
***********************************************************************
*                                                                     *
*              FUNCTION KEY -- RELEASE KEY FUNCTION                   *
*                                                                     *
***********************************************************************
*                                                                     *
CIF2     $TBN  (CCS2-1,CCR),16     IF NOT RELEASE KEY,
         $JF   CIEXIT              JUMP.
CIEND    $SBF  $FBCON+FBEWF-FBD,EWFWORK  POST $FBCON FOR WORK.
         $MVI  CISIO+2,9           SET SIO TO DISABLE KEYBOARD.
         $J    CIEXIT              GO EXIT.
*                                                                     *
***********************************************************************
*                                                                     *
*              LIGHT THE ERROR LIGHT                                  *
*                                                                     *
***********************************************************************
*                                                                     *
CIERROR  $MVI  CISIO+2,X'2B'       SET ERROR LIGHT, LOCK DATA KEYS.
*                                                                     *
***********************************************************************
*                                                                     *
*              EXIT FROM INTERRUPT ROUTINE                            *
*                                                                     *
***********************************************************************
*                                                                     *
CIEXIT   $LIO  1,0,0,(CCDC,CCR)    SET DISPLAY INDICATORS.
         $L    R2,(CCR2,CCR)       RESTORE R2.
         $L    PSR,(CCPSR,CCR)     RESTORE PSR.
         $L    R1,(CCR1,CCR)       RESTORE R1.
CISIO    $SIO  1,0,0,X'4F'         START THE KEYBOARD.
         $B    CINT                BRANCH ON NEXT INTERRUPT.
         TITLE '5475 DATA ENTRY KEYBOARD INPUT PROCESSOR'
*                                                                     *
***********************************************************************
*                                                                     *
*              5475 DATA ENTRY KEYBOARD INPUT PROCESSOR               *
*                                                                     *
***********************************************************************
*                                                                     *
$CON     $WAIT WORK                WAIT FOR WORK.
         $SLC  (CCKC,CCR),(CCKF,CCR),2  COMPUTE INPUT LENGTH.
         $JZ   CONEND              IF NO INPUT, JUMP.
         $MVC  (FBAREA,FBR),(CCKF,CCR),2  SET COMPRESSION SOURCE AREA.
         $MVC  (FBCLNG,FBR),(CCKC,CCR),2   SET LENGTH TO COMPRESS.
         $MVI  (FBSRCB,FBR),X'92'  SET RCB TO SEND.
         $B    $CMPR               COMPRESS AND PUT INTO BUFFER.
         $B    $BFLUSH             FLUSH THE BUFFER.
         $LA   CCR,CCA             RESTORE R1.
CONEND   $MVC  (CCEC,CCR),(CCEF,CCR),2  REFRESH EBCDIC COUNTER.
         $MVC  (CCDC,CCR),(CCDF,CCR),2  REFRESH DISPLAY COUNTER.
         $MVC  (CCKC,CCR),(CCKF,CCR),2   REFRESH INPUT BUFFER POINTER.
         $MVI  CISIO+2,X'4F'       REFRESH SIO.
         $LIO  1,0,0,ZERO          DON'T BURN OUT THE '01' LIGHTS.
         $SIO  1,0,0,X'4F'         UNLOCK THE KEYBOARD.
         $B    $CON                GO WAIT FOR NEXT MESSAGE.
         $DROP CCR
.NO5475  AIF   (&PRTCONS NE 1 AND &PRTCONS NE 2).NOCONP
         TITLE 'CONSOLE MESSAGE SUPPORT FOR 5203 PRINTER'
         $USING PCA,PCR            ESTABLISH ADDRESSABILITY
$CONP    $WAIT WORK                WAIT FOR BUFFERS OR LOCAL MESSAGES.
CP00     $TBN  (PCFLG,PCR),PFASG   IS PRINTER ASSIGNED...
         $JF   CP10                JUMP IF NOT.
         AIF   (&PRTCONS EQ 1).CP2 *
CP01     $CLI  (FBBUF-1,FBR),0     IS A BUFFER QUEUED...
         $BE   $CONP               EXIT IF NOT.
         $B    $FREEBUF            YES.  FREE THE BUFFER
         $B    CP01                AND CHECK FOR MORE BUFFERS.
         AGO   .CP3                *
.CP2     $CLC  (FBBCT,FBR),(FBBMX,FBR)  YES.  SHOULD WE FORCE MESSAGES
         $JNL  CP05                JUMP IF SO.
         $B    $COMRET             OTHERWISE NON-PROCESS-EXIT
         $B    CP00                AND TRY AGAIN.
CP05     $B    CPEJECT             EJECT A PAGE ON THE PRINTER.
.CP3     ANOP                      *
CP10     $SBN  FBEWF-FBD+$FBPR1,EWFUNIT  LOCK THE LOGICAL PRINTER.
CP20     $B    CPWAIT              WAIT TILL PRINTER ISN'T BUSY.
         $MVC  LPDA+131,LPDA+132,132  CLEAR PRINTER DATA AREA.
         $CLI  (FBBUF-1,FBR),0     ARE THERE HASP MESSAGES...
         $JE   CP30                JUMP IF NOT.
         $MVC  (FBAREA,FBR),(PCDA,PCR),2  YES.  SET PRINT LINE ADDRESS.
         $B    $DCOM               DECOMPRESS MESSAGE TO PRINT LINE.
         $NOPJ *+1                 $DCOM RETURNS TO *+3 IF NOT EOF.
         $J    CPPRINT             THEN GO PRINT.
CP30     $CLC  MSGPLACE,CMSGP,2    ARE WE UP TO DATE ON LOCAL MSGS...
         $JE   CP40                JUMP IF SO.
         $ALC  CMSGP,FOUR,2        NO.  POINT TO NEXT.
         $CLC  CMSGP,AMSGLAST,2    ARE WE OUT OF RANGE...
         $JNH  CP31                JUMP IF NOT.
         $MVC  CMSGP,AMSGFRST,2    YES.  POINT TO START OF CIRCLE.
CP31     $L    R1,(PCDA,PCR)       POINT R1 TO PRINT LINE.
         $MVI  (7,R1),X'F0'        SET FIRST 8 BYTES
         $MVC  (6,R1),(7,R1),7       TO EBCDIC ZERO.
         $MVI  CPCT,4              SET LOOP COUNT TO 4.
CP32     $LA   R2,MSGFIRST         POINT TO LOW-ORDER MESSAGE BYTE.
CMSGP    EQU   CP32+3
         $A    R2,MTHREE           LOWER THE PTR TO HI-ORD MSG BYTE.
CP33     $MNZ  (0,R1),(0,R2)       SET SINK CHARACTER FROM ZONE.
         $CLI  (0,R1),X'FA'        IS IT NUMERIC...
         $JL   CP34                JUMP IF YES.
         $SLC  (0,R1),FIFTY7       NO.  MAKE IT ALPHABETIC.
CP34     $MNN  (1,R1),(0,R2)       SET SINK CHARACTER FROM NUMERIC.
         $CLI  (1,R1),X'FA'        IS IT NUMERIC...
         $JL   CP35                JUMP IF YES.
         $SLC  (1,R1),FIFTY7       NO.  MAKE IT ALPHABETIC.
CP35     $LA   R1,(2,R1)           UP SINK REGISTER BY 2
         $LA   R2,(1,R2)           AND SOURCE REGISTER BY 1.
         $SLC  CPCT,ONE            REDUCE LOOP COUNT BY 1.
         $BNZ  CP33                LOOP IF MORE TO DO.
         $LA   R2,$FBCONP          OTHERWISE RESTORE
         $L    R1,(FBREG1,FBR)     BOTH REGISTERS.
CPPRINT  $MVI  (PCCC,PCR),X'81'    SET SINGLE-SPACE.
         $SBN  (PCFLG,PCR),PFBSY   SHOW PRINT BUFFER BUSY.
         $B    CP20                GO WAIT TILL IT'S FREE.
*
*              NO MORE WORK.  FREE THE LOGICAL PRINTER.
*
CP40     $TBN  (PCFLG,PCR),PFASG   DID WE INTERRUPT PRINTING...
         $BT   CPEJECT             YES.  EJECT A PAGE.
         $POST $FBPR1,UNIT         IN ANY CASE, UNLOCK THE LOGICAL
         $B    $CONP               PRINTER AND WAIT TO BE POSTED AGAIN.
*                                                                     *
***********************************************************************
*                                                                     *
*              SUBROUTINE TO EJECT A PAGE.                            *
*                                                                     *
***********************************************************************
*                                                                     *
CPEJECT  $ST   ARR,CPEJEND+3       SAVE RETURN ADDRESS.
         $B    CPWAIT              WAIT TILL PRINTER IS READY.
         $SBN  (PCFLG,PCR),PFBSY   SHOW PRINT BUFFER BUSY.
         $MVI  (PCCC,PCR),X'B1'    SPECIFY IMMEDIATE EJECT.
         $B    CPWAIT              WAIT TILL IT'S DONE.
CPEJEND  $B    *-*                 THEN RETURN TO THE CALLER.
*                                                                     *
***********************************************************************
*                                                                     *
*              SUBROUTINE TO WAIT TILL PRINT BUFFER IS FREE.          *
*                                                                     *
***********************************************************************
*                                                                     *
CPWAIT   $ST   ARR,CPWEND+3        SAVE RETURN ADDRESS.
         $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TBF  (PCFLG,PCR),PFBSY   IF PRINT BUFFER ISN'T FREE,
         $BF   $COMRETA            NON-PROCESS-EXIT.
CPWEND   $B    *-*                 OTHERWISE RETURN TO CALLER.
CPCT     DS    X                   LOOP COUNTER.
MTHREE   $DC   HL2'-3'             CONSTANT OF -3.
         $DROP PCR                 DISESTABLISH ADDRESSABILITY.
.NOCONP  ANOP                      *
         TITLE 'BSCA CONTROL AREA'
BCA      EQU   *
BCR      EQU   R1
         $USING BCA,BCR
*
*
*              BSCA CONTROL AREA
*
*
BIRESTOR $ST   ARR,(BIRXIT,BCR)    SAVE RETURN ADDRESS.
         $L    PSR,(BIPSR,BCR)     RESTORE PROGRAM STATUS REGISTER.
         $LA   R1,*-*              RESTORE INDEX REGISTER 1.
BIR1     EQU   *-1                 SAVE AREA FOR REGISTER 1.
         $LA   R2,*-*              RESTORE INDEX REGISTER 2.
BIR2     EQU   *-1                 SAVE AREA FOR REGISTER 2.
         $B    *-*                 RETURN TO CALLER.
BIRXIT   EQU   *-1                 SAVE AREA FOR RETURN ADDRESS.
BIPSR    $DS   YL2                 SAVE AREA FOR PROG STAT REGISTER.
*
*
*              FLAG BYTES.
*
*
BCF1     $DC   X'0'                FLAG BYTE.
BFWAIT   EQU   128                 $BSCA WAIT FLAG.
BFPOST   EQU   64                  $BSCA POST FLAG.
BFCSON   EQU   32                  FCS-BIT-TURNED-ON FLAG.
BFCSOFF  EQU   16                  FCS-BIT-TURNED-OFF FLAG.
BFWAB    EQU   8                   WE-SENT-WAIT-A-BIT FLAG.
BFMSG    EQU   4                   MESSAGE-PENDING FLAG.
BFRCVE   EQU   2                   RECEIVE-END FLAG.
BF2SEC   EQU   1                   2-SEC-TIMEOUT-END FLAG.
*
*
*              SENSE DATA
*
*
BCSNS    $DC   YL2(0)              BSCA STATUS BYTES.
BCLEN    $DC   YL2(0)              COMPUTED LENG OF RECEIVED DATA.
BCLOG    DC    X'0',YL2(LOGBSCA,0,0)  $LOG PARAMETER LIST.
BCMSG    DC    AL4(0)              ARGUMENT TO $MSG.
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO SAVE REGS AND SENSE IF NECESSARY               *
*                                                                     *
***********************************************************************
*                                                                     *
BISAV    $ST   ARR,BIARR+3         SAVE RETURN ADDRESS.
         AIF   (&S3BSCA EQ 1).BSCA1
         DC    X'C184',YL2(*+2)    TEST BSCA#1 OP END.
.BSCA1   ANOP
BISAV1   $TIO  8,0,3,BIITB         BR IF INTERMEDIATE-TEXT-BLOCK.
         $TIO  8,0,1,BIOPE         BR IF OPERATION-END.
         AIF   (NOT &DEBUG).BIS1   *
         $ST   PSR,BIDBUG          SAVE PSR ACROSS THE $ALC.
         $ALC  BIUINT,ONE,2        UP UNSOLICITED-INTERRUPT CTR BY 1.
         $L    PSR,BIDBUG          RESTORE THE PSR.
         $J    BIGNORE             IGNORE IF NOT OP-END.
.BIS1    ANOP                      *
BIITB    EQU   *
         AIF   (NOT &DEBUG).BIS2   *
         $ST   PSR,BIDBUG          SAVE PSR ACROSS THE $ALC.
         $ALC  BIIINT,ONE,2        UP ITB-INTERRUPT COUNTER BY 1.
         $L    PSR,BIDBUG          RESTORE PSR.
BIGNORE  EQU   *
.BIS2    ANOP                      *
         $SIO  8,0,0,3             IF NOT OP-END, RESET AND ENABLE.
         $B    BISAV1              NEXT INTERRUPT, GO DO IT AGAIN.
         AIF   (NOT &DEBUG).BIS3   *
BIDBUG   $DC   YL2(0)              DEBUG PSR SAVEAREA.
BIUINT   $DC   YL2(0)              UNSOLICITED-INTERRUPT COUNTER.
BIIINT   $DC   YL2(0)              ITB-INTERRUPT COUNTER.
.BIS3    ANOP                      *
BIOPE    $ST   R1,BIR1             SAVE REGISTER 1.
         $LA   R1,BCA              SET R1 AS BCA BASE REGISTER.
         $ST   R2,(BIR2,BCR)       SAVE REGISTER 2.
         $ST   PSR,(BIPSR,BCR)     SAVE PROGRAM STATUS REGISTER.
         $JF   *+1                 RESET TEST-FALSE INDICATOR.
         $SNS  8,0,3,(BCSNS,BCR)   READ IN THE STATUS BYTES.
         $TBF  (BCSNS-1,BCR),X'FF' IF ALL UNIT CHECK BITS ARE OFF,
         $JT   BIARR               RETURN TO CALLER.
         $MVC  (BCLOG,BCR),(BCSNS-1,BCR)  SET BYTE FOR LOGGING.
         $LA   R1,(BCLOG,BCR)      POINT TO LOG PARAMETER AREA.
         $B    $LOG                GO LOG STATUS BYTE 2.
         $LA   R1,BCA              AGAIN SET R1.
         $MVC  (BCMSG+2,BCR),(BCSNS,BCR),2  SET SENSE BYTES IN MSG.
         $MVI  (BCMSG,BCR),5       SET MSG NR = 5 (UNIT CHECK).
         $SBN  (BCF1,BCR),BFMSG    SET MESSAGE-PENDING FLAG,
BIARR    $B    *-*                 AND GO RETURN TO CALLER.
*                                                                     *
***********************************************************************
*                                                                     *
*              ADCONS FOR TRANSMIT/RECEIVE                            *
*                                                                     *
*        NOTE - BCRCV1 THROUGH BCXMT2 AND BCSSEQ ARE SET INITIALLY    *
*        FOR TRANSMISSION OF THE /*SIGNON CARD.  BCRCV2 WILL BE       *
*        FURTHER INITIALIZED WITH &MLBFSIZ BY $ALC.                   *
*                                                                     *
***********************************************************************
*                                                                     *
*                                                                     *
BCRWB1   $DC   YL2(BCWAB2)         WAITABIT - START OF RECEIVE.
BCRWB2   $DC   YL2(BCWAB3)         WAITABIT - END+1 OF RECEIVE.
BCXWB1   $DC   YL2(BCWAB1)         WAITABIT - START OF TRANSMIT.
BCXWB2   $DC   YL2(BCWAB2)         WAITABIT - END+1 OF TRANSMIT.
*
BCR1     $DC   YL2($MLB1+1)        START OF RECEIVE.
BCR2     $DC   YL2($MLB1+1+0)      END+1 OF RECEIVE.
BCX1     $DC   YL2($MLB1+1)        START OF TRANSMIT.
BCX2     $DC   YL2($MLB1+1+88)     END+1 OF TRANSMIT.
BCX1S    $DC   YL2($MLB1+1)        $BSCA START OF TRANSMIT.
BCX2S    $DC   YL2($MLB1+1+88)     $BSCA END+1 OF TRANSMIT.
*
BCSSEQ   $DC   XL5'0102A08F8F'     SAVE AREA FOR STARTING SEQUENCE.
*
*
*              BCB, FCS, AND MISCELLANEOUS STUFF.
*
*
BCRFCS   $DC   YL2(0)              RECEIVED FUNCTION CONTROL SEQUENCE.
BCRBCB   $DC   X'0'                EXPECTED BLOCK CTRL BYTE (BITS 4-7).
BCXFCS   $DC   X'8F8F'             MOST-RECENTLY-TRANSMITTED FCS.
BCXBCB   $DC   X'0'                NEXT-TO-XMIT BCB (BITS 4-7).
$FCS     $DC   X'8FCF'             $FCS - BITS TURNED OFF BY $BSCA,
*                                    TURNED BACK ON BY $FREEBUF.
$FCS1    EQU   $FCS-1
$FCS2    EQU   $FCS
BCWK1    $DC   X'0'                FIRST BCB WORKAREA.
BCWK2    $DC   X'0'                SECOND BCB WORKAREA.
BC16     $DC   YL1(16)             CONSTANT OF 16.
BCFIVE   $DC   YL2(5)              CONSTANT OF FIVE.
BMLBFSIZ $DC   YL2(0)              SIZE OF MULTILEAVING BUFFER,
BCADR    $DC   YL2(BSXOPE)         ADCON FOR $BSCA.
*                                  INITIALIZED WITH &MLBFSIZ BY $MVC.
*
*
*              EBCDIC CHARACTERS USED BY TP HARDWARE.                 *
*
*
DLE      EQU   X'10'               DATA LINK ESCAPE.
ACK      EQU   X'70'               POSITIVE ACKNOWLEDGE ZERO.
NAK      EQU   X'3D'               NEGATIVE ACKNOWLEDGE.
STX      EQU   X'02'               START OF TEXT.
ETB      EQU   X'26'               END OF TEXT BLOCK.
         AIF   (&S3XPAR).BCXPAR    *
SOH      EQU   X'01'               NON-TRANSPARENT SOH.
         AGO   .SOH                *
.BCXPAR  ANOP                      *
SOH      EQU   DLE                 TRANSPARENT SOH - USE DLE.
.SOH     ANOP                      *
*
*
*              HASP CHARACTERS USED
*
*
BCB      EQU   X'80'               BCB (BITS 4-7 FILLED IN LATER).
FCS      EQU   X'80'               FCS (BITS 4-7 FILLED IN LATER).
WAB      EQU   X'40'               WAB (ADDED TO FIRST FCS).
EOB      EQU   X'00'               END-OF-BLOCK RCB.
SRCB     EQU   X'80'               SUB-RECORD CONTROL BLOCK.
SKP      EQU   X'10'               FLAG IN BCB TO IGNORE COUNT.
RCBERR   EQU   X'E0'               RCB FOR BCB-ERROR RECORD.
*
*
*              WAIT-A-BIT SEQUENCE
*
*
BCWAB1   EQU   *
         DC    YL1(SOH,STX,BCB+SKP,FCS+WAB,FCS,EOB,EOB,EOB,ETB)
BCWAB2   EQU   *
         DC    XL9'0'              RECEIVE AREA AFTER WAB SENT.
BCWAB3   EQU   *
*
*
*              BCB-ERROR CONTROL RECORD - EXPECTED COUNT GOES IN
*              SRCB, RECEIVED COUNT GOES IN BCB.
*
*
BCBERR   $DC   YL1(SOH,STX,BCB+SKP,FCS,FCS,RCBERR,SRCB,EOB,ETB)
*
*
*              START-OF-TEXT SEQUENCE
*
*
BCSTXSEQ $DC   YL1(SOH,STX)
STXSEQ   EQU   BCSTXSEQ
*
*
*              END-OF-TEXT-BLOCK SEQUENCE
*
*
ETBSEQ   $DC   YL1(EOB,ETB)
*
*
*              POSITIVE ACKNOWLEDGMENT SEQUENCE
*
*
ACKSEQ   $DC   YL1(DLE,ACK)
         TITLE 'BSCA INTERRUPT ROUTINE'
*                                                                     *
***********************************************************************
*                                                                     *
*        PREPARE FUNCTION CONTROL SEQUENCE BEFORE TRANSMITTING        *
*                                                                     *
***********************************************************************
*                                                                     *
BIXMTF   EQU   *
         $L    R2,(BCX1,BCR)       POINT TO FIRST BYTE TO XMIT.
         $CLI  (1,R2),STX          ARE WE SENDING TEXT...
         $JNE  BIXMT               IF NOT, FORGET ABOUT THE FCS.
         $MVC  (4,R2),($FCS,BCR),2 MOVE FCS INTO ITS SPOT.
         $MVC  (BCXFCS,BCR),($FCS,BCR),2  SAVE FCS LAST-XMITTED.
         $TBN  (BCF1,BCR),BFWAB    CHECK THE WAIT-A-BIT FLAG.
         $JF   BIXMT               SKIP IF IT'S OFF.
         $SBN  (3,R2),WAB          OTHERWISE SET WAB IN FCS1.
*                                                                     *
***********************************************************************
*                                                                     *
*        START A TRANSMIT OPERATION.                                  *
*                                                                     *
***********************************************************************
*                                                                     *
BIXMT    $LIO  8,0,4,(BCX1,BCR)    SET CURRENT ADDRESS REGISTER.
         $LIO  8,0,2,(BCX2,BCR)    SET TRANSITION ADDRESS REGISTER.
         $LIO  8,0,1,(BCX2,BCR)    SET STOP ADDRESS REGISTER.
         $B    (BIRESTOR,BCR)      RESTORE R1, R2, PSR.
         $SIO  8,0,2,3             START TRANSMIT-ONLY, RESET, ENABLE.
*                                                                     *
***********************************************************************
*                                                                     *
*        PROCESS INTERRUPT AFTER COMPLETION OF TRANSMIT.              *
*                                                                     *
***********************************************************************
*                                                                     *
BSXOPE   $B    BISAV               SAVE R1, R2, PSR. SENSE IF REQ'D.
         $TBF  (BCSNS-1,BCR),X'26' CK FOR DISCONNECTS, ADAPT CHECK.
         $JT   BIRCV               IF ALL OFF, GO START RECEIVE.
         $B    BIDISCON            OTHERWISE USE DISCONNECT SUBRTN.
         $B    BIXMT               THEN TRY TO RE-TRANSMIT.
         SPACE
*                                                                     *
***********************************************************************
*                                                                     *
*        START A RECEIVE OPERATION.                                   *
*                                                                     *
***********************************************************************
*                                                                     *
BIRCV    $LIO  8,0,4,(BCR1,BCR)    SET CURRENT ADDRESS REGISTER.
         $LIO  8,0,1,(BCR2,BCR)    SET STOP ADDRESS REGISTER.
         $B    (BIRESTOR,BCR)      RESTORE R1, R2, PSR.
         $SIO  8,0,1,3             START RECEIVE-ONLY, RESET, ENABLE.
*                                                                     *
***********************************************************************
*                                                                     *
*        PROCESS INTERRUPT AFTER COMPLETION OF RECEIVE.               *
*                                                                     *
***********************************************************************
*                                                                     *
         $B    BISAV               SAVE R1, R2, PSR. SENSE IF REQ'D.
         $SNS  8,0,4,BCESQ+3       READ CURRENT ADDRESS REGISTER.
         $SNS  8,0,4,(BCLEN,BCR)   READ IT AGAIN TO COMPUTE LENGTH.
         $SLC  (BCLEN,BCR),(BCR1,BCR),2  COMPUTE RECEIVED LENGTH.
         $SLC  BCESQ+3,ONE,2       COMPUTE ADR OF LAST RCVD BYTE.
*                                                                     *
***********************************************************************
*                                                                     *
*        CHECK FOR AND PROCESS UNIT CHECKS HERE.                      *
*                                                                     *
***********************************************************************
*                                                                     *
         $TBF  (BCSNS-1,BCR),X'D6' CHECK FOR DISCONNECTS, TIMEOUT,
*                                  BCC CHECK, OR ADAPTER CHECK.
         $JT   BCROK               IF ALL OFF, JUMP.
         $B    BIDISCON            GO TAKE CARE OF POSSIBLE DISCONNECT.
         $J    BINAKA              THEN SEND TO HASP A NAK.
*                                                                     *
***********************************************************************
*                                                                     *
*        IF NO UNIT CHECK, THIS CODE EXAMINES START AND END SEQ'S.    *
*                                                                     *
***********************************************************************
*                                                                     *
BCROK    $L    R2,(BCR1,BCR)       POINT R2 TO 1ST RCVD BYTE.
         $CLI  (0,R2),NAK          IF NAK WAS RECEIVED,
         $JE   BIRNAK                GO PROCESS IT.
         $CLC  (1,R2),(ACKSEQ,BCR),2  IF DLE-ACK WAS RECEIVED,
         $JE   BIACK0              GO PROCESS IT.
         $CLI  (1,R2),STX          IF STX WAS NOT RECEIVED,
         $JNE  BISEQERR               GO HANDLE THE ERROR.
BCESQ    $CLI  *-*,ETB             IF DLE-STX AND ETB ALL OKAY,
         $JE   BIBCB               GO EXAMINE THE HASP CONTROL BYTES.
BISEQERR EQU   *                   ERROR IN STARTING OR ENDING SEQ.
         $MVC  (BCMSG+2,BCR),(1,R2),2  MOVE START SEQ TO MESSAGE.
         $MVI  (BCMSG,BCR),3       SET CODE 3 = SEQUENCE ERROR.
         $SBN  (BCF1,BCR),BFMSG    SHOW MESSAGE PENDING.
*                                                                     *
***********************************************************************
*                                                                     *
*        THIS CODE SENDS A NEGATIVE ACKNOWLEDGEMENT TO HASP.          *
*                                                                     *
***********************************************************************
*                                                                     *
BINAKA   EQU   *
         $TBN  (BCF1,BCR),BFWAB    IS THIS THE WAB SEQUENCE...
         $JT   BINAKB              YES.  SKIP THE FOLLOWING.
         $CLC  (BCLEN,BCR),(BCFIVE,BCR),2  IF 5 OR FEWER BYTES RCVD,
         $JNH  BINAKB              TEST FOR TIMEOUT                @N30
*                                       SINCE MORE THAN 5 BYTES HAVE
*                                  BEEN RECEIVED, WE HAVE NO CHOICE BUT
*                                  TO ASSUME HASP RECEIVED OUR TRANS-
*                                  MISSION CORRECTLY.
         $L    R2,(BCX1,BCR)       SET STOP ADDRESS
         $LA   R2,(2,R2)             TO START ADDRESS
         $ST   R2,(BCX2S,BCR)          PLUS TWO.
         $MVC  (BCSSEQ-3,BCR),(ACKSEQ,BCR),2  SET DLE ACK AS SAVED SEQ.
BINAKB   EQU   *
         $TBN  (BCSNS-1,BCR),X'80' IF TIMEOUT,
         $BT   BIRCV               MERELY START RECEIVE AGAIN.
         $TBN  (BCF1,BCR),BFWAB    IF WE WERE SENDING WAB,
         $BT   BIXMTF              SEND WAB AGAIN, NOT NAK.
BINAK    EQU   *                   SEND A NAK TO HASP.
         $L    R2,(BCX1,BCR)       POINT TO 1ST TRANSMIT BYTE.
         $MVI  (0,R2),NAK          SET IT TO NAK.
         $LA   R2,(1,R2)           ESTABLISH AND
         $ST   R2,(BCX2,BCR)         SET STOP ADDRESS.
         $B    BIXMT               GO START TRANSMISSION.
*                                                                     *
***********************************************************************
*                                                                     *
*        THIS CODE HANDLES A NAK RECEIVED FROM HASP.                  *
*                                                                     *
***********************************************************************
*                                                                     *
BIRNAK   EQU   *
         $MVC  (BCMSG+2,BCR),ZERO,2  ZERO OUT MIDDLE MESSAGE BYTES.
         $MVI  (BCMSG,BCR),2       SET MESSAGE CODE TO 2 = RCVD NAK.
         $SBN  (BCF1,BCR),BFMSG    SHOW MESSAGE PENDING.
         $TBN  (BCF1,BCR),BFWAB    DID HASP NAK OUR WAB SEQUENCE...
         $BT   BIXMTF              YES.  GO SEND IT AGAIN.
         $MVC  (4,R2),(BCSSEQ,BCR),5  NO, REGULAR XMISSION.  REFRESH
         $MVC  (BCX2,BCR),(BCX2S,BCR),4  TRANSMIT LIMITS AND
         $B    BIXMTF              FIRST 5 BYTES AND RE-XMIT.
*                                                                     *
***********************************************************************
*                                                                     *
*        THIS CODE HANDLES DLE-ACK RECEIVED FROM HASP.                *
*                                                                     *
***********************************************************************
*                                                                     *
BIACK0   $SBF  (BCRFCS-1,BCR),WAB  IF REAL DLE-ACK, RESET RCVD WAB.
BIACK    EQU   *
         $SBN  (BCF1,BCR),BFPOST+BFRCVE  SET POST FLAG, SHOW RCV END.
         $B    (BIRESTOR,BCR)      RESTORE REGISTERS.
         $SIO  8,0,0,7             START A 2-SECOND TIMEOUT.
         $TIO  8,0,1,*+2           RESET OP-END INTERRUPT LATCH.
         $SBN  BCF1,BF2SEC         SHOW 2-SEC TIMEOUT ENDED.
         $SIO  8,0,0,1             CLEAR THE INTERRUPT.
*                                                                     *
***********************************************************************
*                                                                     *
*        THIS CODE TAKES CARE OF RECEIVED-TEXT RECORDS.               *
*                                                                     *
***********************************************************************
*                                                                     *
BIBCB    EQU   *
         $MVC  (BCRFCS,BCR),(4,R2),2  SAVE RECEIVED FCS.
         $TBN  (2,R2),X'20'        IS RESET-BCB FLAG ON...
         $JF   BISKP               JUMP IF NOT.
         $MNN  (BCRBCB,BCR),(2,R2) YES.  RESET BCB AS INDICATED.
BISKP    $TBF  (2,R2),X'30'        IF EITHER RESET-BCB OR IGNORE-BCB,
         $BF   BIACK               END BCB PROCESSING.
         $MNN  (BCWK1,BCR),(2,R2)  MOVE RECEIVED AND EXPECTED
         $MNN  (BCWK2,BCR),(BCRBCB,BCR)  BCB'S TO WORKAREAS.
         $SLC  (BCWK2,BCR),(BCWK1,BCR)  COMPUTE EXPECTED MINUS RECEIVED
         $JNZ  BIBAD               IF NOT THE SAME, JUMP.
         $ALC  (BCRBCB,BCR),ONE    ELSE UP EXPECTED-BCB BY ONE
         $B    BIACK               AND END BCB PROCESSING.
         SPACE 2
*                                                                     *
***********************************************************************
*                                                                     *
*        THIS CODE HANDLES BLOCK-CONTROL-BYTE ERRORS.                 *
*                                                                     *
***********************************************************************
*                                                                     *
BIBAD    $MVI  (1,R2),X'FF'        SIGNAL $BSCA TO THROW BUFFER AWAY.
         $JP   BIPLUS              JUMP IF DIFFERENCE WAS POSITIVE.
         $ALC  (BCWK2,BCR),(BC16,BCR)  ELSE MAKE DIFFERENCE MODULO 16.
BIPLUS   $CLI  (BCWK2,BCR),2       COMPARE WITH MAX ALLOWED DIFFERENCE.
         $BNH  BIACK               BR IF NOT BCB ERROR.
         $MVC  (BCMSG+1,BCR),(2,R2)  SHOW RECEIVED BCB IN MESSAGE.
         $MVI  (BCMSG+2,BCR),X'80' SHOW HI BIT OF EXPECTED AND FILL
         $MNN  (BCMSG+2,BCR),(BCRBCB,BCR)  IN BITS 4-7 OF EXPECTED BCB.
         $MVI  (BCMSG,BCR),1       SET CODE OF 1 = BCB CHECK,
         $SBN  (BCF1,BCR),BFMSG      AND SET MESSAGE-PENDING FLAG.
         $MNN  (BCBERR-6,BCR),(BCWK1,BCR) TELL HASP ABOUT BCB ERROR ---
         $MNN  (BCBERR-2,BCR),(BCRBCB,BCR)  GIVE HIM EXPECTED & RCVD.
         $MVC  (8,R2),(BCBERR,BCR),9  MOVE BCB ERR SEQ TO RCV AREA.
         $ST   R2,(BCX1,BCR)       SET TRANSMIT ADDRESS.
         $LA   R2,(9,R2)           ADD 9 TO IT.
         $ST   R2,(BCX2,BCR)       SET STOP ADDRESS.
         $B    BIXMTF              THEN TRANSMIT WITH FCS.
*                                                                     *
***********************************************************************
*                                                                     *
*        SUBROUTINE TO TAKE CARE OF DISCONNECT STATUS BITS.           *
*                                                                     *
***********************************************************************
*                                                                     *
BIDISCON $ST   ARR,BIDRET+3        SAVE RETURN ADDRESS.
         $TBF  (BCSNS-1,BCR),6     IS A DISCONNECT BIT ON...
         $JT   BIDRET              IF NOT, RETURN TO CALLER.
         $SIO  8,0,0,X'82'         IF SO, DISABLE BSCA AND
         $SIO  8,0,0,X'C2'         ENABLE BSCA.
BID1     $B    (BIRESTOR,BCR)      RESTORE REGISTERS
         $SIO  8,0,0,7             AND START 2-SECOND TIMEOUT.
         $B    BISAV               THEN SAVE REGISTERS AND SENSE.
         $TBN  (BCSNS,BCR),2       IF THE DATASET IS NOT READY,
         $BF   BID1                DO IT ALL OVER AGAIN.
BIDRET   $B    *-*                 OTHERWISE RETURN TO CALLER.
         TITLE '$BSCA - MAIN PROCESSOR FOR BSCA'
$BSCA    EQU   *
*
*
*              $BSCA DOESN'T USE FBEWF BUT RATHER BFWAIT AND BFPOST
*              IN THE BSCA CONTROL AREA.
*
*
*
         $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $TBF  (BCF1,BCR),BFPOST+BFMSG  POSTED OR MESSAGE...
         $BT   $COMRETA            IF NOT, RETURN TO COMMUTATOR.
         $TBN  (BCF1,BCR),BFMSG    IS A MESSAGE SPECIFIED...
         $SBF  (BCF1,BCR),BFMSG    (RESET THE MESSAGE SWITCH.)
         $JF   BS000               IF NOT, END OF RECEIVE.
         $LA   R1,(BCMSG,BCR)      OTHERWISE POINT TO MESSAGE
         $B    $MSG                AND ADD IT TO TRACE TABLE.
         $B    $COMRETB            THEN RETURN WITHOUT CHANGING FBREG1.
BS000    EQU   *
         $SBF  (BCF1,BCR),BFWAIT+BFPOST  SET OFF THE WAIT & POST BITS.
*
*
*              EXAMINE THE BUFFER FOR WHICH A RECEIVE OPERATION
*              HAS JUST COMPLETED.
*
*
         $TBN  (BCF1,BCR),BFRCVE   IS RECEIVE ENDED...
         $BF   $BSCA               IF NOT, EXIT.
         $TBN  (BCF1,BCR),BFWAB    WAS THIS WAIT-A-BIT SEQUENCE...
         $JT   BS100               IF SO, BYPASS RCVD-BUFFER CODE.
         $L    R1,(FBBUF,FBR)      POINT TO THE BUFFER.
         $MVC  (FBRCB,FBR),(2,R1)  SAVE THE STARTING SEQUENCE.
         $CLI  (2,R1),STX          DOES THE BUFFER CONTAIN TEXT...
         $JNE  BS030               NO, ACK.  GO FREE IT.
*
*              BUFFER CONTAINS TEXT.  QUEUE IT ON THE
*              APPROPRIATE PROCESSOR.
*
         $LA   R2,$FBFRSTE         POINT TO FIRST ELIGIBLE FB.
         $MVC  BS010+1,(6,R1)      ASSUME RECORD IS TEXT.
         $TBF  (6,R1),X'0F'        IS IT A CONTROL RECORD...
         $JF   BS010               SKIP IF NOT.
         $MVC  BS010+1,(7,R1)      YES.  MOVE SRCB TO CLI INSTRUCTION.
         $CLI  (6,R1),0            DOES RCB INDICATE END-OF-BLOCK...
         $JE   BS029               IF SO, MERELY FREE THE BUFFER.
         $CLI  (7,R1),C'B'         UNLESS TERMINATION RECORD,
         $JNE  BS010               CONTINUE.
         $SIO  8,0,0,X'80'         DISABLE BSCA AND INTERRUPTS.
         $MVI  BS010+1,X'91'       SET CONSOLE OUTPUT RCB.
         $MVI  $FBBSCA+6,X'FF'     SET $BSCA PERMANENT WAIT.
         $MVI  (6,R1),X'91'        SET CONSOLE OUTPUT RCB.
         $MVI  (7,R1),X'83'        SET SRCB FOR PRT & SPACE 3.
BS010    $CLI  (FBRCB,FBR),*-*     IS THIS THE RIGHT FB...
         $JE   BS011               JUMP IF SO.
         $CLI  (FBNEXT-1,FBR),0    NO.  IS THERE ANOTHER FB...
         AIF   (&DEBUG).BSD1
         $JE   BS029               IF NOT, GO FREE THE BUFFER.
         AGO   .BSD2
.BSD1    $BE   ABEND               DUMP IF UNKNOWN RCB.
.BSD2    $L    R2,(FBNEXT,FBR)     YES.  POINT TO NEXT FB.
         $B    BS010                 AND GO LOOP.
BS011    $TBF  (6,R1),X'0F'        IS THIS A CONTROL RECORD...
         $JT   BS028               JUMP IF SO.
*                                                                     *
***********************************************************************
*                                                                     *
*        THIS CODE HANDLES BUFFERS CONTAINING ALL TEXT RECORDS        *
*                                                                     *
***********************************************************************
*                                                                     *
         $ALC  (FBBCT,FBR),ONE     UP FB'S BUFFER COUNT BY ONE.
         $CLC  (FBBCT,FBR),(FBBMX,FBR)  IS BUFFER CT .GE. MAXIMUM...
         $JL   BS015               JUMP IF NOT.
         $MVC  BS013+1,(FBFCS1,FBR)  OTHERWISE
BS013    $SBF  $FCS1,*-*               TURN OFF
         $MVC  BS014+1,(FBFCS2,FBR)      THE APPROPRIATE
BS014    $SBF  $FCS2,*-*                   BIT IN $FCS.
         $SBN  BCF1,BFCSOFF        SHOW FCS BIT TURNED OFF.
BS015    $POST *,WORK              POST THE FB FOR WORK.
         $TBN  (FBFLG,FBR),BFCSON  DID THIS FB SET FCS RECENTLY...
         $SBF  (FBFLG,FBR),BFCSON  (SHOW IT DIDN'T.)
         $JF   *+1+4               SKIP IF NOT.
         $SBF  BCF1,BFCSON         YES.  DON'T HASTEN TRANSMISSION
         AIF   (NOT &S35471).BS71
         $CLI  (FBRCB,FBR),X'91'   IS THIS BUFFER FOR THE 5471...
         $JNE  *+1+3               JUMP IF NOT.
         $SBF  (FBEWF,FBR),EWFPOST YES.  RESET THE POST BIT TOO.
.BS71    ANOP
         $LA   R2,(FBBUF,FBR)      POINT TO FB'S BUFFER CHAIN WORD.
BS016    $CLC  (0,R2),ZERO,2       LOOP - IS THIS END-OF-CHAIN...
         $JE   BS017               JUMP IF SO.
         $L    R2,(0,R2)           OTHERWISE POINT TO NEXT BUFFER
         $B    BS016               AND GO TO START OF LOOP.
BS017    $ST   R1,(0,R2)           PUT THIS BUFFER ON END OF CHAIN.
         $LA   R2,$FBBSCA          THEN
         $MVC  (FBBUF,FBR),(0,R1),2  REMOVE BUFFER FROM OUR OWN
         $MVC  (0,R1),ZERO,2           CHAIN AND ZERO ITS CHAIN WORD.
         $SLC  (FBBCT,FBR),ONE     REDUCE OUR BUFFER CT BY ONE.
         AIF   (NOT &DEBUG).BS018  *
         $BM   ABEND               ABEND IF COUNT IS NEGATIVE.
.BS018   $J    BS100               SKIP OVER THE $FREEBUF CALL.
*                                                                     *
***********************************************************************
*                                                                     *
*        THIS CODE HANDLES CONTROL BUFFERS (REQUEST AND PERMISSION)   *
*                                                                     *
***********************************************************************
*                                                                     *
BS028    $POST *,PERM+EWFPOST      POST LOGICAL READER FOR PERMISSION
*                                  OR LOGICAL PRINTER OR PUNCH FOR
*                                  REQUEST (AND SET EARLY-POST FLAG).
*
*              FREE THE BUFFER.
*
BS029    $LA   R2,$FBBSCA          POINT TO OUR OWN FB.
BS030    $B    $FREEBUF            GO FREE OUR TOP BUFFER.
*                                                                     *
***********************************************************************
*                                                                     *
*              DECISION-MAKING BEFORE TRANSMIT                        *
*                                                                     *
***********************************************************************
*                                                                     *
BS100    $L    R1,(FBREG1,FBR)     RESTORE R1 TO POINT TO BCA.
         $CLI  (FBEWF,FBR),X'FF'   IF $BSCA PERMANENT WAIT,
         $BE   $BSCA               JUST RETURN.
BS101    $TBN  (BCRFCS-1,BCR),WAB  IF HASP SENT US WAIT-A-BIT,
         $JT   BS108               GO CHECK FOR A FREE BUFFER.
         $CLI  (FBBUF-1,FBR),0     IF THERE'S A TEXT BUFFER TO SEND,
         $JNE  BSD                 GO SEND IT.
         $CLI  $MLPOOL-1,0         IF THERE'S NO FREE BUFFER,
         $JE   BS106               GO NON-PROCESS EXIT.
         $TBN  (BCF1,BCR),BFCSON   WAS AN FCS BIT TURNED ON...
         $JT   BSB                 IF SO, REPORT IT IMMEDIATELY.
         $TBN  (BCF1,BCR),BFCSOFF  WAS AN FCS BIT TURNED OFF...
         $JT   BS106               IF SO, WAIT A LITTLE.
         $CLI  (FBRCB,FBR),STX     IF HASP HAS JUST SENT US TEXT
         $JE   BSB                 ACKNOWLEDGE IMMEDIATELY.
BS106    $ST   IAR,(FBENT,FBR)     NON-PROCESS EXIT HERE,
         $TBF  (BCF1,BCR),BFPOST+BF2SEC  WAITING FOR EITHER BFPOST
         $BT   $COMRETA            OR BF2SEC TO COME ON.
         $TBN  (BCF1,BCR),BFPOST   IF WE GOT POSTED,
         $SBF  (BCF1,BCR),BFPOST   RESET POST FLAG AND
         $BT   BS101               GO CHECK WHY.
BS108    $CLI  $MLPOOL-1,0         IF 2-SEC AND A BUFFER IS FREE,
         $JNE  BSB                 ACKNOWLEDGE.
*                                                                     *
***********************************************************************
*                                                                     *
*              SEND WAIT-A-BIT TO HASP                                *
*                                                                     *
***********************************************************************
*                                                                     *
BSA      $MVC  (BCX2,BCR),(BCXWB2,BCR),8  SET WAB XMIT/RCV ARGS,
         $SBN  (BCF1,BCR),BFWAB    SHOW WE'VE SENT WAIT-A-BIT,
         $J    BSF                 AND GO FILL IN THE FCS.
*                                                                     *
***********************************************************************
*                                                                     *
*              SEND LOGICAL ACKNOWLEDGMENT TO HASP                    *
*                                                                     *
***********************************************************************
*                                                                     *
BSB      $B    BSGBUF              GET THE FREE BUFFER.
         $CLC  ($FCS,BCR),(BCXFCS,BCR),2  HAS FCS CHANGED...
         $JE   BSC                 SEND DLE-ACK0 IF NOT.
         $MVC  (6,R2),(ETBSEQ,BCR),2 SET UP THE ENDING SEQUENCE,
         $LA   R2,(7,R2)           AND SPECIFY
         $ST   R2,(BCX2,BCR)       TRANSMIT STOP ADDRESS.
         $J    BSE                 THEN GO SET UP STARTING SEQ.
*                                                                     *
***********************************************************************
*                                                                     *
*              SEND PHYSICAL ACK (DLE-ACK0) TO HASP                   *
*                                                                     *
***********************************************************************
*                                                                     *
BSC      EQU   *
         $MVC  (1,R2),(ACKSEQ,BCR),2  SET UP THE PHYSICAL ACK,
         $LA   R2,(2,R2)           AND SPECIFY
         $ST   R2,(BCX2,BCR)       TRANSMIT STOP ADDRESS.
         $J    BSX                 THEN GO START TRANSMISSION.
*                                                                     *
***********************************************************************
*                                                                     *
*              SEND THE TEXT BUFFER TO HASP                           *
*                                                                     *
***********************************************************************
*                                                                     *
BSD      $L    R1,(FBBUF,FBR)      POINT TO THE TEXT BUFFER.
         $B    BSGADR              FILL IN SOME ADDRESSES,
         $L    R2,(1,R2)           GET XMIT STOP ADR-3 (SET BY $CKLEN),
         $LA   R2,(3,R2)           ADD 3 TO IT, AND
         $ST   R2,(BCX2,BCR)       SPECIFY TRANSMIT STOP ADDRESS.
*                                                                     *
***********************************************************************
*                                                                     *
*              SET UP STX SEQUENCE                                    *
*                                                                     *
***********************************************************************
*                                                                     *
BSE      $L    R2,(BCX1,BCR)       POINT TO THE BUFFER.
         $MVC  (1,R2),(STXSEQ,BCR),2  SET UP THE STARTING SEQUENCE.
         $MVI  (2,R2),BCB          SET SKELETON BLOCK CTRL BYTE.
         $MNN  (2,R2),(BCXBCB,BCR) FILL IN MOD-16 BLOCK COUNT.
         $ALC  (BCXBCB,BCR),ONE    UP BLOCK COUNTER BY ONE.
*                                                                     *
***********************************************************************
*                                                                     *
*              FILL IN FUNCTION CONTROL SEQUENCE                      *
*                                                                     *
***********************************************************************
*                                                                     *
BSF      $L    R2,(BCX1,BCR)       POINT TO FIRST XMIT BYTE.
         $MVC  (4,R2),($FCS,BCR),2 SET CURRENT BCS IN BUFFER.
         $MVC  (BCXFCS,BCR),($FCS,BCR),2  SHOW LAST FCS TRANSMITTED.
         $TBN  (BCF1,BCR),BFWAB    IS THIS THE WAB SEQUENCE...
         $JF   BSX                 IF NOT, GO TRANSMIT.
         $SBN  (3,R2),WAB          YES.  SHOW WAB IN FCS.
*                                                                     *
***********************************************************************
*                                                                     *
*              START TRANSMIT HERE                                    *
*                                                                     *
***********************************************************************
*                                                                     *
BSX      $MVC  (BCX2S,BCR),(BCX2,BCR),4  SAVE TRANSMIT START AND END.
         $L    R2,(BCX1,BCR)       POINT TO 1ST BYTE TO TRANSMIT.
         $MVC  (BCSSEQ,BCR),(4,R2),5  SAVE FIRST 5 BYTES.
         $LA   R2,$FBBSCA          POINT R2 TO OUR FB.
         $SNS  8,0,3,(BCSNS,BCR)   GET THE BSCA STATUS DATA.
         $TBF  (BCSNS-1,BCR),6     ARE BOTH DISCONNECT BITS OFF...
         $JT   BSY                 GO TRANSMIT IF SO.
         $SIO  8,0,0,X'80'         IF NOT, DISABLE BSCA
         $SIO  8,0,0,X'C0'         AND ENABLE BSCA.
         $ST   IAR,(FBENT,FBR)     THEN STORE LOCATION.
         $SNS  8,0,3,(BCSNS,BCR)   GET THE BSCA STATUS DATA.
         $TBN  (BCSNS,BCR),2       IS DATA SET NOW READY...
         $BF   $COMRETA            NON-PROCESS EXIT IF NOT.
BSY      $LIO  8,0,4,(BCX1,BCR)    LOAD CURRENT,
         $LIO  8,0,2,(BCX2,BCR)    TRANSITION, AND
         $LIO  8,0,1,(BCX2,BCR)    STOP ADDRESSES.
         $SIO  8,0,2,1             START XMIT AND RESET INTERRUPTS.
         $SBF  (BCF1,BCR),BFPOST+BF2SEC+BFRCVE+BFCSON+BFCSOFF
         $L    IL2,(BCADR,BCR)     SET INTERRUPT ADDRESS,
         $SIO  8,0,0,2             AND ENABLE BSCA INTERRUPTS.
         $B    $BSCA               THEN GO TO THE TOP.
BS200    EQU   BSY                 ENTRY FOR INITIALIZATION.
*                                                                     *
***********************************************************************
*                                                                     *
*              SUBROUTINE TO GET A FREE BUFFER                        *
*                                                                     *
***********************************************************************
*                                                                     *
BSGBUF   $L    R1,$MLPOOL          GET A FREE BUFFER.
         $MVC  $MLPOOL,(0,R1),2    DEQUEUE IT FROM POOL.
         $MVC  (0,R1),(FBBUF,FBR),2  QUEUE IT LAST-IN-FIRST-OUT
         $ST   R1,(FBBUF,FBR)      ON THE BSCA BUFFER QUEUE.
         $ALC  (FBBCT,FBR),ONE     UP THE BSCA BUFFER COUNT BY ONE.
BSGADR   $LA   R2,(1,R1)           LET R2 POINT TO THE BUFFER.
         $LA   R1,BCA              LET R1 POINT TO THE BCA.
         $ST   R2,(BCX1,BCR)       SET TRANSMIT STARTING ADR.
         $ST   R2,(BCR1,BCR)       SET RECEIVE STARTING ADR.
         $ST   R2,(BCR2,BCR)       SET RECEIVE ENDING
         $ALC  (BCR2,BCR),(BMLBFSIZ,BCR),2   ADDRESS.
         $SBF  (BCF1,BCR),BFWAB    RESET XMIT-WAITABIT FLAG.
         $ST   ARR,BSGEND+3        SET RETURN ADDRESS.
BSGEND   $B    *-*                 RETURN TO CALLER.
         AIF   (NOT &S3CMDS).NOCMDS
         TITLE 'LOCAL COMMAND HANDLING SUBROUTINE'
$CMDSCAN EQU   *
         $ST   ARR,CMDARR          SAVE RETURN ADDRESS.
         $ST   R2,CMDR2            SAVE CALLER'S R2.
         $CLC  (9,R1),CMD01,10     IS THIS /*CARRIAGE...
         $JNE  CMD020              GO TEST NEXT COMMAND IF NOT.
         SPACE 1
         $LA   R1,(9,R1)           POINT TO LAST CHAR OF CMD.
CMD01A   $LA   R1,(1,R1)           POINT TO NEXT CHAR.
         $CLI  (0,R1),C' '         IS IT A BLANK...
         $BE   CMD01A              LOOP TILL A NONBLANK.
         SPACE 1
         $CLI  (0,R1),C'L'         IS OPERAND NR-OF-LINES...
         $JNE  CMD01B              JUMP IF NOT.
         $MVI  CMD01T,13           YES.  USE CARRIAGE CHAN 13.
         $LA   R1,(2,R1)           POINT JUST PAST 'L='.
         $J    CMD01C              GO GET 2D SUBOPERAND.
         SPACE 1
CMD01B   $B    $CVB                GET 1ST SUBOPERAND= CHAN NR.
         $CLI  (0,R1),C'='         IS DELIMITER AN EQUAL...
         $JNE  CMDSYN              SYNTAX ERROR IF NOT.
         $CLI  $CVBANS,12          IF CHANNEL .GT. 12,
         $JH   CMDOPD              OPERAND ERROR.
         $MVC  CMD01T,$CVBANS,1    1ST SUBOP OK.  SAVE IT.
         SPACE 1
         $LA   R1,(1,R1)           POINT JUST PAST '='
CMD01C   $B    $CVB                AND GET 2D SUBOPERAND.
         $CLI  (0,R1),C','         IS DELIMITER A COMMA...
         $JE   CMD01D              JUMP IF SO.
         $CLI  (0,R1),C' '         IS DELIMITER A BLANK...
         $JNE  CMDSYN              SYNTAX ERROR IF NEITHER.
         $CLI  $CVBANS,112         IF LINE NR .GT. 112,
         $JH   CMDOPD              OPERAND ERROR.
         SPACE 1
CMD01D   $LA   R2,PCCCTL           POINT TO PRINTER CARRIAGES.
         $LA   R2,(*-*,R2)         POINT TO SELECTED CHAN.
CMD01T   EQU   *-1
         $MVC  (0,R2),$CVBANS,1    SET NEW CHAN LINE NUMBER.
         $CLC  (0,R2),PCCCTL+13    IF LINE NR .GT. FORM LENGTH,
         $JH   CMDOPD              OPERAND ERROR.
         SPACE 1
         $CLI  CMD01T,13           WAS OPERAND NR-OF-LINES...
         $JNE  CMD01E              JUMP IF NOT.
         $LIO  14,0,0,PCCCTL+14    YES.  LOAD FORMS LENGTH REG.
         $MVC  PCCCTL+12,PCCCTL+13,12  SET ALL CHAN'S TO LINE-NR.
         SPACE 1
CMD01E   $CLI  (0,R1),C' '         WAS PREVIOUS OPERAND LAST...
         $LA   R1,(1,R1)           POINT JUST PAST COMMA.
         $BNE  CMD01B              B IF NOT LAST OPERAND.
         $J    CMDEND              ELSE EXIT.
CMDOPD   $LA   R1,CMDOPDMS         OPERAND ERROR.
         $J    CMDEND+4            PRINT 'C0DE0002'.
CMDOPDMS DC    X'C0DE0002'
CMDSYN   $LA   R1,CMDSYNMS         SYNTAX ERROR.
         $J    CMDEND+4            PRINT 'C0DE0001'.
CMDSYNMS DC    X'C0DE0001'
CMDENDMS DC    X'C0DE0000'         NORMAL END.
CMDEND   $LA   R1,CMDENDMS         PRINT 'C0DE0000'.
         $B    $MSG                GO LOG MESSAGE.
         $CLI  *-1,X'00'           SET CONDITION CODE EQUAL.
CMD020   EQU   *                   START PROCESSING COMMAND 2.
         $LA   R2,*-*              RESTORE REGISTER 2.
CMDR2    EQU   *-1
         $B    *-*                 RETURN TO CALLER.
CMDARR   EQU   *-1
CMD01    $DC   C'/*CARRIAGE'
         EJECT
*
*              SUBROUTINE TO CONVERT TO BINARY
*
$CVB     $ST   ARR,CVBE1+3         SAVE RETURN ADDRESS.
         $CLI  (0,R1),X'F0'        IS FIRST DIGIT NUMERIC...
         $BL   CMDSYN              SYNTAX ERROR IF NOT.
         SPACE 1
CVBA     $LA   R1,(1,R1)           FIND LOW-ORDER DIGIT.
         $CLI  (0,R1),X'F0'        IS THIS CHAR NUMERIC...
         $BNL  CVBA                LOOP IF SO.
         $ST   R1,CVBE+3           SAVE ADR OF NON-NUMERIC CHAR
         SPACE 1
CVBB     $SLC  $CVBANS,$CVBANS,2   ZERO OUT ANSWER SPOT.
         $LA   R2,CVBTAB-2         POINT TO TABLE MINUS 2.
         SPACE 1
CVBC     $LA   R2,(2,R2)           POINT TO NEXT TABLE ENTRY
         $A    R1,MONE             AND TO NEXT-HIGHER-ORD DIGIT
         $CLI  (0,R1),X'F0'        IS DIGIT NUMERIC...
         $JL   CVBE                IF NOT, END OF CONVERSION.
         SPACE 1
CVBD     $SLC  (0,R1),ONE          REDUCE DIGIT BY 1.
         $CLI  (0,R1),X'F0'        WAS THE DIGIT ZERO...
         $BL   CVBC                IF SO, DO NEXT DIGIT.
         $ALC  $CVBANS,(1,R2),2    ELSE ADD ITS PLACE-VALUE
         $B    CVBD                AND LOOP.
         SPACE 1
CVBE     $LA   R1,*-*              POINT R1 TO NON-NUMERIC CHAR
CVBE1    $B    *-*                 AND RETURN TO CALLER.
         SPACE 1
CVBTAB   DC    HL2'1,10,100,1000,10000'  PLACE-VALUE TABLE.
         SPACE 1
$CVBANS  $DC   YL2(0)              BINARY ANSWER.
.NOCMDS  ANOP
         TITLE '$LEOF, $PERM, $REQ --- COMMAND SEQUENCE SUBROUTINES'
*
*              SEND LOGICAL END-OF-FILE TO HASP.
*
$LEOF    EQU   *
         $MVC  (FBCSEQ-2,FBR),(FBRCB,FBR)  SET UP RCB.
         $MVI  (FBCSEQ-1,FBR),X'80'  SET UP SRCB = X'80'.
         $J    COMMON2             JUMP TO COMMON CODE.
*
*              SEND PERMISSION-GRANTED TO HASP.
*
$PERM    EQU   *
         $MVI  (FBCSEQ-2,FBR),X'A0'  SET 'PERMISSION' COMMAND CODE.
         $SBN  (FBEWF,FBR),EWFPOST RESET (SET TO 1) THE EARLY POST FLAG
         $J    COMMON1             JUMP TO COMMON CODE.
*
*              SEND REQUEST-PERMISSION TO HASP.
*
$REQ     EQU   *
         $MVI  (FBCSEQ-2,FBR),X'90'  SET 'REQUEST' COMMAND CODE.
*
*              COMMON CODE FOR ABOVE THREE SUBROUTINES.
*
COMMON1  $MVC  (FBCSEQ-1,FBR),(FBRCB,FBR)  SET RCB AS BYTE 2 OF SEQ.
COMMON2  $MVI  (FBCSEQ,FBR),0      SET ZERO AS BYTE 3 OF SEQUENCE.
         $ST   ARR,(FBRET2,FBR)    SAVE ARR IN ALTERNATE ARR SAVEAREA.
         $LA   R1,3                SPECIFY LENGTH OF SEQUENCE.
         $B    $CKLEN              GO GET SPACE FOR IT IN CUR BUFFER.
         $MVC  (0,R1),(FBCSEQ,FBR),3  MOVE SEQUENCE TO BUFFER.
         $B    $BFLUSH             THEN TRUNCATE THE BUFFER.
         $L    IAR,(FBRET2,FBR)    FINALLY, RETURN TO THE CALLER.
         TITLE 'DECOMPRESSION'
*                                                                     *
***********************************************************************
*                                                                     *
*        $DCOM UNBLOCKS ANOTHER RECORD INTO CALLER'S OUTPUT AREA.     *
*                                                                     *
*                                                                     *
*        VARIOUS LOCATIONS IN THE FB ARE USED AS FOLLOWS ---          *
*                                                                     *
*        FBRET1 - RETURN ADDRESS SAVE AREA.                           *
*        FBXR1  - INDEX REGISTER 1 SAVE AREA.                         *
*        FBCURL - POINTER TO CURRENT LOCATION IN CURRENT BUFFER,      *
*           MAINTAINED BY $DCOM.                                      *
*        FBSRCB - LOGICAL RECORD'S SRCB, RETURNED TO THE CALLER       *
*           BY $DCOM.                                                 *
*        FBAREA - POINTER TO THE DECOMPRESSION AREA, SUPPLIED         *
*           BY THE CALLER TO $DCOM.  ON OUTPUT, POINTER TO LAST+1     *
*           BYTE OF DECOMPRESSED LOGICAL RECORD.                      *
*        FBBUF  - BUFFER CHAIN ORIGIN.  BUFFERS ARE ADDED TO THE      *
*           CHAIN BY $BSCA AND FREED BY $DCOM.                        *
*                                                                     *
*        OPERATION ---                                                *
*                                                                     *
*             IF NO CURRENT BUFFER EXISTS, MAKE THE BUFFER            *
*        POINTED TO BY FBBUF CURRENT.  IF FBBUF IS ZERO, NON-         *
*        PROCESS-EXIT.                                                *
*             DECOMPRESS THE LOGICAL RECORD POINTED TO BY             *
*        FBCURL.                                                      *
*             IF RECORD IS NOT LOGICAL EOF, CHECK NEXT RCB.           *
*        IF IT IS ZERO, SHOW NO CURRENT BUFFER AND FREE THE           *
*        CURRENT BUFFER.  IN ANY CASE, RETURN TO +3.                  *
*             IF RECORD IS LOGICAL EOF SHOW NO CURRENT BUFFER,        *
*        FREE THE CURRENT BUFFER, AND RETURN TO +0.                   *
*                                                                     *
***********************************************************************
*                                                                     *
$DCOM    $ST   ARR,(FBRET1,FBR)    SAVE RETURN ADDRESS.
         $ST   R1,(FBXR1,FBR)      SAVE INDEX REGISTER 1.
         $L    R1,(FBCURL,FBR)     POINT TO CURRENT LOC IN BUFFER.
         $CLI  (FBCURL-1,FBR),0    ARE WE WORKING ON A BUFFER...
         $JNE  DCGO                JUMP IF SO.
         $ST   IAR,(FBENT,FBR)     STORE LOCATION.
         $CLI  (FBBUF-1,FBR),0     IS THERE ANOTHER BUFFER...
         $BE   $COMRETA            NON-PROCESS EXIT IF NOT.
         $L    R1,(FBBUF,FBR)      POINT TO THE BUFFER.
         $LA   R1,(6,R1)           POINT TO ITS FIRST RCB.
DCGO     EQU   *                   EXAMINE NEXT REC IN BUF.
         $CLI  (2,R1),0            IS THE SCB ZERO (LOGICAL EOF)...
         $JE   DCFRET              JUMP IF SO TO RETURN.
         $ALC  (FBRET1,FBR),THREE,2  OTHERWISE UP RETURN ADDRESS BY 3.
         $ST   R2,DCR2             SAVE REGISTER 2 ACROSS DECOMPRESS.
         $MVC  (FBSRCB,FBR),(1,R1) MOVE SRCB TO THE FB.
         $LA   R1,(2,R1)           POINT TO THE FIRST STRING CTL BYTE.
         $L    R2,(FBAREA,FBR)     POINT TO DECOMPRESSION AREA.
*
*              EXAMINE STRING CONTROL BYTE AND GO TO EITHER
*                END-OF-LOGICAL-RECORD CODE,
*                DUPLICATE-CHARACTER-STRING CODE, OR
*                NONDUPLICATE-CHARACTER-STRING CODE.
*              R1 POINTS TO STRING CONTROL BYTE.
*              R2 POINTS TO NEXT AVAILABLE BYTE IN OUTPUT AREA.
*
DC01     $TBF  (0,R1),X'80'        IF END-OF-LOGICAL-RECORD,
         $JT   DCEOR               GO TO EOR CODE.
         $MVC  DCWK,(0,R1)         OTHERWISE SAVE SCB.
         $TBF  (0,R1),X'40'        IF THIS IS A DUPLICATE STRING,
         $JT   DCDUP               GO TO DUPLICATE-STRING CODE.
*
*              PROCESS A NONDUPLICATE CHARACTER STRING.
*
         $SBF  DCWK,X'C0'          ISOLATE STRING COUNT.
         $A    R1,DCWK             POINT R1 TO NEXT SCB MINUS 1.
         $A    R2,DCWK             POINT R2 TO (CUR OUTPUT LOC)+LENGTH.
         $MVC  DCMV1+1,DCWK        SET MVC TO MOVE LENGTH+1.
DCMV1    $MVC  (0,R2),(1,R1),*-*   MOVE FROM BUFFER TO OUTPUT AREA.
         $J    DCLOOP              GO LOOP TO DO NEXT SCB.
*
*              PROCESS A DUPLICATE STRING OF CHARACTERS OR BLANKS.
*
DCDUP    $SBF  DCWK,X'E0'          ISOLATE DUPLICATE COUNT.
         $A    R2,DCWK             POINT R2 TO (CUR OUTPUT LOC)+COUNT.
         $MVI  (1,R2),C' '         ASSUME BLANK DUPLICATION.
         $TBF  (0,R1),X'20'        IS THIS ASSUMPTION CORRECT...
         $JT   DCBLK               IF SO, GO SET UP THE MVC.
         $LA   R1,(1,R1)           NO.  POINT TO CHAR TO BE DUPED.
         $MVC  (1,R2),(0,R1)       SET DUP CHAR INSTEAD OF BLANK.
DCBLK    $MVC  DCMV2+1,DCWK        SET LENGTH FOR MVC.
DCMV2    $MVC  (0,R2),(1,R2),*-*   OVERLAP FIELDS FOR DUPLICATION.
DCLOOP   $LA   R1,(1,R1)           NOW POINT TO NEXT SCB
         $B    DC01                AND GO PROCESS IT.
*
*              END OF LOGICAL RECORD.
*
DCEOR    $ST   R2,WORK             TEMP SAVE PTR TO LAST+1 BYTE.
         $MVI  (0,R2),C' '         SET THE TWO GARBAGE BYTES
         $MVI  (1,R2),C' '           AT END OF OUTPUT TO ZERO.
         $LA   R2,*-*              RESTORE THE FB REGISTER.
DCR2     EQU   *-1                 SAVEAREA FOR R2.
         $MVC  (FBAREA,FBR),WORK,2 SET PTR TO LAST+1 OUTPUT BYTE.
         $LA   R1,(1,R1)           POINT TO THE NEXT RCB
         $ST   R1,(FBCURL,FBR)       AND SAVE ITS LOCATION.
         $CLI  (0,R1),0            IS IT END-OF-BUF RCB...
         $JNE  DCRET               JUMP IF NOT.
*
*              END OF MULTILEAVING BUFFER
*              OR LOGICAL END-OF-FILE
*
DCFRET   $MVI  (FBCURL-1,FBR),0    SHOW NO CURRENT BUFFER.
         $B    $FREEBUF            FREE CURRENT BUFFER.
*
*              EXIT TO CALLER
*
DCRET    $L    R1,(FBXR1,FBR)      RESTORE R1
         $L    IAR,(FBRET1,FBR)      AND RETURN.
DCWK     $DC   YL2(0)              WORKING LOCATION.
THREE    $DC   YL2(3)              CONSTANT OF THREE.
 TITLE 'COMPRESS'
*                                                                     *
***********************************************************************
*                                                                     *
*        $CMPR COMPRESSES DATA FROM USER'S INPUT AREA INTO A          *
*              TRANSMISSION BUFFER.                                   *
*                                                                     *
*        VARIOUS LOCATIONS IN THE FB ARE USED AS FOLLOWS ---          *
*                                                                     *
*        FBRET2 - RETURN ADDRESS SAVE AREA.                           *
*        FBENT  - NON-PROCESS-EXIT REENTRY ADDRESS SAVE AREA.         *
*        FBXR1  - REGISTER 1 SAVE AREA.                               *
*        FBAREA - ADDRESS OF FIRST (HIGH-ORDER) TEXT BYTE, SET BY USE *
*        FBCLNG - LENGTH OF TEXT TO COMPRESS, SET BY USER.            *
*        FBSRCB - RECORD CONTROL BYTE (RCB) FOR COMPRESSED RECORD,    *
*          SET BY USER.  (NOTE- SRCB WILL ALWAYS BE SET TO X'80'.)    *
*                                                                     *
*        INPUT AREA - MUST BE 2 BYTES LONGER THAN MAXIMUM LENGTH      *
*          SPECIFIED IN FBCLNG.  THE INPUT AREA IS DESTROYED BY $CMPR.*
*                                                                     *
*        OPERATION ---                                                *
*                                                                     *
*        1. $CMPR USES AN INTERNAL WORKAREA.  IF THIS AREA IS IN USE, *
*           NON-PROCESS-EXIT TILL IT BECOMES FREE.                    *
*        2. COMPRESS THE USER'S TEXT INTO THE INTERNAL WORKAREA.      *
*        3. SET THE 2 BYTES IN FRONT OF THE WORKAREA TO THE RCB       *
*           (FROM FBSRCB) AND THE SRCB (X'80').                       *
*        4. CALL $CKLEN TO GET SPACE IN A TRANSMISSION BUFFER.        *
*           $CKLEN MAY NON-PROCESS-EXIT IF NO SPACE IS AVAILAB.E      *
*        5. SHOW THE INTERNAL WORKAREA FREE AND RETURN TO THE CALLER. *
*                                                                     *
***********************************************************************
*                                                                     *
$CMPR    $ST   ARR,(FBRET2,FBR)    SAVE RETURN ADDRESS.
         $ST   R1,(FBXR1,FBR)      SAVE INDEX REGISTER 1.
         $ST   IAR,(FBENT,FBR)     PREPARE TO NON-PROCESS EXIT.
CMPNOP   $NOPB $COMRETB            EXIT IF COMPRESSION AREA IN USE.
         $SBF  CMPNOP+1,X'80'      SET ABOVE NO-OP TO BRANCH.
         $ST   R2,COREG2+3         SAVE INDEX REGISTER 2.
         $MVC  COACC,(FBAREA,FBR),2  SET SOURCE AREA ADDRESS.
         $L    R1,(FBCLNG,FBR)     GET COUNT TO COMPRESS.
         $ST   R1,COEND            SAVE TO END TRUNC.
         $A    R1,(FBAREA,FBR)     POINT TO LO-ORD+1 BYTE.
         AIF   (&COMP EQ 0).COMP0  *
COTRUNC  $A    R1,MONE             POINT TO PREVIOUS BYTE.
         $CLI  (0,R1),C' '         IS THE BYTE BLANK...
         $JNE  CONOTADJ            IF NOT, END OF TRUNCATION.
         $ALC  COEND,MONE,2        REDUCE TRUNCATION CTR BY 1.
         $BNZ  COTRUNC             LOOP UNLESS COL 1 BLANK.
         AIF   (&COMP GE 2).CMPBLK *
CONOTADJ $LA   R1,(1,R1)           POIKNT TO LAST+1 CHARACTER.
         AGO   .COMP0              *
.CMPBLK  $LA   R1,(&CCB,R1)        SHOW RECORD AS MIN BLANKS.
* FORCE LAST CHARACTER 'X' TO BE FOLLOWED BY 'X+1', 'X'.
CONOTADJ $MVI  (1,R1),1            SET LAST+1 TO '1'.
         $ALC  (1,R1),(0,R1)       SET LAST+1 TO 'LAST'+'1'.
         $MVC  (2,R1),(0,R1)       SET LAST+2 TO LAST+0.
         $LA   R1,(1,R1)           POINT R1 TO LAST+1 NONBLANK BYTE.
         $ST   R1,COEND            SAVE THIS LOCATION.
         $LA   R1,COSINK           POINT R1 TO SINK AREA.
         $L    R2,(FBAREA,FBR)     POINT R2 TO SOURCE AREA.
         $DROP FBR                 FB IS NO LONGER ADDRESSABLE.
COOP     EQU   *                   BEGIN A STRING
         $ST   R2,COORG            SET START OF STRING
         AIF   (NOT(&COMP EQ 2 OR &COMP EQ 3 AND &CCB EQ 2)).COMP1
*GHP IF BLANK ONLY OR BOTH WITH SMALL COUNT
* LOOK FOR BLANK STRING
         $CLC  (&CCB-1,R2),COBLANK,&CCB IS THIS MINIMUM LENGTH BLANKS
         $JNE  CONOTBL             IF NOT BLANK EXIT COMPRESSION
*
*        BLANK COMPRESSION
*
COMPBNK  $MVC  COCHSAV,(31,R2),1   SAVE CURRENT LIMIT CHARACTER
         $MVI  (31,R2),1           SET TO NON-BLANK
         $LA   R2,(&CCB,R2)        POINT TO FIRST UNCHECKED CHARACTER
COMPBNKL $CLI  (0,R2),C' '         TEST FOR BLANK
         $JNE  COFINBNK            IF NOT FINISH UP STRING
         $LA   R2,(1,R2)           INCREMENT TO NEXT CHARACTER
         $B    COMPBNKL            CONTINUE
COFINBNK $ST   R2,COACC            SAVE REG FOR COUNT CALC
         $L    R2,COORG            PICK UP START OF STRING
         $MVC  (31,R2),COCHSAV,1   RESTORE SAVED CHARACTER
         $L    R2,COACC            PICK SCAN POINTER UP
         $SLC  COACC,COORG,2       CALCULATE LENGTH OF BLANK STRING
         $MVC  (0,R1),COACC,1      INSERT LENGTH INTO SCB
         $SBN  (0,R1),X'80'        FLAG AS BLANK STRING
         $LA   R1,(1,R1)           POINT TO NEXT SCB
         $B    COOP                BEGIN NEXT STRINT
CONOTBL  EQU   *
.COMP1   AIF   (&COMP NE 3).COMP2
*GHP IF DUPLICATE CHARACTER COMPRESS OF ANY KIND
* LOOK FOR DUPLICATE CHARACTER STRING
         $CLC  (&CCT-1,R2),(&CCT-2,R2),&CCT-1 DO WE HAVE DUPLICATES
         $JNE  CONODUP             IF NOT EXIT COMPRESSION
*
*        DUPLICATE CHARACTER COMPRESSION
*
COMPDUP  $MVC  COCHSAV,(31,R2),1   SAVE CURRENT LIMIT CHARACTER
         $MVI  (31,R2),1           SET TO VALUE OF 1
         $ALC  (31,R2),(0,R2),1    INSURE CHARACTER NOT SAME
         $MVC  COCH,(0,R2),1       SET COMPARE CHARACTER
         $LA   R2,(&CCT,R2)        POINT TO FIRST UNCHECKED CHARACTER
COCH     EQU   *+1
COMPDUPL $CLI  (0,R2),C' '         TEST FOR DUPLICATE CHARACTER
         $JNE  COFINDUP            IF NOT FINISH UP STRING
         $LA   R2,(1,R2)           INCREMENT TO NEXT CHARACTER
         $B    COMPDUPL            LOOP FOR NEXT
COFINDUP $ST   R2,COACC            SAVE REG FOR COUNT CALC
         $L    R2,COORG            PICK UP START OF STRING
         $MVC  (31,R2),COCHSAV,1   RESTORE SAVED CHARACTER
         $L    R2,COACC            PICK SCAN POINTER UP
         $SLC  COACC,COORG,2       CALCULATE LENGTH OF STRING
         $MVC  (0,R1),COACC,1      INSERT LENGTH INTO SCB
         AIF   (&COMP NE 3 OR &CCB LT 3).COMP2A
*GHP IF DUPLICATE AND BLANK BUT NOT SHORT &CCB
         $CLI  COCH,C' '           LOOK FOR BLANK STRING
         $JNE  CODUALNB            IF NOT EXIT TO DUPLICATE STRING
         $SBN  (0,R1),X'80'        FLAG AS BLANK STRING
         $LA   R1,(1,R1)           POINT TO NEXT SCB
         $B    COOP                BEGIN NEXT STRING
CODUALNB EQU   *
.COMP2A  ANOP
         $SBN  (0,R1),X'A0'        FLAG AS DUPLICATE STRING
         $MVC  (1,R1),COCH,1       SET DUPLICATE CHARACTER
         $LA   R1,(2,R1)           POINT TO NEXT SCB
         $B    COOP                BEGIN NEXT STRING
CONODUP  EQU   *
.COMP2   ANOP
*
*        CREATE CHARACTER STRING
*
         $LA   R2,(63,R2)          POINT TO END OF MAXIMUM STRING+1
         $ST   R2,COLIM            SAVE FOR END CALCULATION
         $CLC  COLIM,COEND,2       TEST FOR END OF RECORD
         $JNH  COCHLOP             IF NOT DEVELOP CHARACTER STRING
         $L    R2,COEND            PICK END SEQUENCE
         $ST   R2,COLIM            SAVE FOR FINISH OF STRING
         $CLC  COORG,COEND,2       CAN WE DO MORE SEARCHING
         $JL   COCHLOP             IF SO DEVELOP STRING
         $MVI  (0,R1),0            SET STRING CONTROL TO END OF RECORD
.COEND   ANOP                      *
COREG2   $LA   R2,*-*              RESTORE REGISTER 2.
         $USING FBD,FBR            MAKE THE FUNCTION BLK ADDRESSABLE.
         $ST   R1,COMVC1+4         SET UP THE MVC FROM-LOCATION.
         $A    R1,COSINK2          SUBTRACT THE ADCON (COSINK-2).
         $ST   R1,(FBAREA,FBR)     SAVE TEMPORARILY THE LENGTH-1.
         $MVC  COMVC1+1,(FBAREA,FBR)  SET LENGTH-1 INTO THE MVC.
         $LA   R1,(1,R1)           SET TRUE LENGTH INTO R1.
         $MVC  COSINK-2,(FBSRCB,FBR)  SET RCB INTO RECORD.
         $MVI  COSINK-1,X'80'      SET SRCB INTO RECORD.
         $B    $CKLEN              GO GET SPACE IN BUFFER.
COMVC1   $MVC  (0,R1),*-*,*-*      MOVE RECORD TO BUFFER.
         $SBN  CMPNOP+1,X'80'      SHOW WE'RE DONE WITH WORKAREA.
         $L    R1,(FBXR1,FBR)      RESTORE REGISTER 1
         $L    IAR,(FBRET2,FBR)      AND RETURN TO CALLER.
         AIF   (&COMP LT 2).COMP00 *
CORETURN $B    *-*                 RETURN TO CALLER
*
*        STRING SEARCH LOOP
*
COCHLOP  $MVC  COCHSAV,(&CCB-1,R2),&CCB SAVE CHARACTER STRING
         $MVC  (&CCB-1,R2),COBLANK,&CCB INSERT BLANKS TO STOP SCAN
         $L    R2,COORG PICK UP START OF STRING
COCHLOOP $LA   R2,(1,R2)           POINT TO NEXT CHARACTER
         AIF   (NOT(&COMP EQ 2 OR &COMP EQ 3 AND &CCB EQ 2)).COMP3
* GHP IF BLANK ONLY OR BOTH WITH SMALL COUNT
         $CLC  (&CCB-1,R2),COBLANK,&CCB IS THIS MINIMUM LENGTH BLANK
         AIF   (&COMP EQ 2).COMP4
*GHP IF SHORT BLANK AND DUPLICATE COMPRESS
         $JE   COCHFIN             IF MATCH FINISH STRING
.COMP3   ANOP
*GHP IF DUPLICATE CHARACTER COMPRESS OF ANY KIND
         $CLC  (&CCT-1,R2),(&CCT-2,R2),&CCT-1 DO WE HAVE DUPLICATES
.COMP4   ANOP
         $BNE  COCHLOOP            IF NOT CONTINUE
*
*        MOVE CHARACTER STRING
*
COCHFIN  EQU   *
         $ST   R2,COACC            PREPARE TO CALCULATE STRING LENGTH
         $L    R2,COLIM            PICK UP START OF MODIFIED STRING
         $MVC  (&CCB-1,R2),COCHSAV,&CCB RESET CHARACTER STRING
         $L    R2,COACC            PICK UP START OF NEXT STRING
         $SLC  COACC,COORG,2       STRING LENGTH
         $MVC  (0,R1),COACC,1      SET STRING COUNT
         $SBN  (0,R1),X'C0'        SET STRING CONTROL BYTE
         $A    R1,COACC            POINT TO LAST OF STRING RECEIVER
         $LA   R1,(1,R1)           PLUS ONE, NEXT SCB
         $MVC  COMVC+1,COACC,1     SET MOVE COUNT
COMVC    $MVC  (0,R1),(0,R2),*-*   MOVE STRING PLUS ONE
         $B    COOP                LOOK AT NEXT STRING
COLIM    $DC   HL2'0'              ADDRESS OF END OF MAXIMUM STRING+
COBLANK  $DC   CL(&CCB)' '         BLANK STRING FOR COMPARE
COCHSAV  $DC   CL(&CCB)' '         SAVE CHARACTERS
         AGO   .COMP00
.COMP0   ANOP
*GHP NO COMPRESSION OPTION
*
*        MOVE MAXIMUM LENGTH STRINGS
*
         $ST   R1,COEND            SAVE LOC OF LAST+1 CHARACTER.
         $LA   R1,COSINK           POINT R1 TO COMPRESSION AREA.
         $L    R2,(FBAREA,FBR)     POINT R2 TO SOURCE AREA.
COOP     $ST   R2,COORG            SAVE START OF STRING
         $LA   R2,(63,R2)          POINT TO END OF STRING+1
         $ST   R2,COACC            SAVE FOR END TEST
         $CLC  COACC,COEND,2       DO WE EXTEND BEYOND DATA
         $JNL  COLST               IF BEYOND MOVE LAST STRING
         $MVI  (0,R1),X'C0'+63     SET SCB COUNT TO 63
         $LA   R1,(64,R1)          POINT TO LAST CHARACTER+1
         $MVC  (0,R1),(0,R2),64    MOVE FULL STRING IN
         $B    COOP                LOOP FOR MORE
COLST    $L    R2,COEND            SET UPPER LIMIT+1
         $SLC  COEND,COORG,2       CALCULATE LENGTH
         $MVC  (0,R1),COEND,1      SET LENGTH IN SCB
         $SBN  (0,R1),X'C0'        INSERT STRING ID
         $A    R1,COEND            POINT TO END SCB
         $LA   R1,(1,R1)
         $MVC  COMVC+1,COEND,1     SET MOVE INSTRUCTION
COMVC    $MVC  (0,R1),(0,R2),*-*   MOVE CHARACTER STRING
         $MVI  (0,R1),X'00'        SET END OF RECORD SCB
         AGO   .COEND              *
.COMP00  ANOP
COEND    $DC   HL2'0'              ADDRESS OF END OF RECORD+1-&CCT
COORG    $DC   HL2'0'              ADDRESS OF START OF STRING
COACC    $DC   HL2'0'              WORK AREA
MONE     $DC   HL2'-1'             CONSTANT OF '-1'.
COSINK2  $DC   YL2(2-COSINK)       ADCON TO SUBTRACT.
         DC    YL2(0)              2 BYTES BEFORE THE AREA.
COSINK   DC    XL(128+&CCB)'0'     COMPRESSION AREA.
         TITLE '$CKLEN - RETURN ADDRESS FOR ML BUFFER STUFFING'
***********************************************************************
*                                                                     *
*                                                                     *
*        ROUTINE $CKLEN SPECIFIES TO CALLER AN ADDRESS IN A MULTI-    *
*        LEAVING BUFFER INTO WHICH THE USER WILL MOVE A COMPLETE LOGIC*
*        AL RECORD.                                                   *
*                                                                     *
*        INPUT FROM CALLER -                                          *
*              IN XR1, THE LENGTH OF THE CALLER'S COMPLETE LOGICAL    *
*              RECORD.                                                *
*              IN XR2, THE ADDRESS OF THE CALLER'S FB.                *
*                                                                     *
*        OUTPUT TO CALLER -                                           *
*              IN XR1, THE ADDRESS OF THE LOW-ORDER (HIGH-ADDRESS) BYT*
*              OF THE AREA (WITHIN A ML BUFFER) THAT HAS BEEN ASSIGNED*
*              TO THE CALLER.                                         *
*                                                                     *
*        SYSTEM LOCATIONS USED -                                      *
*              $CURMLB POINTS TO CHAIN FIELD OF CURRENT ML BUFFER.    *
*              $CURMLL POINTS TO LAST USABLE BYTE OF DITTO.           *
*              $CURMLP POINTS TO LAST-USED BYTE OF DITTO.             *
*              $MLPOOL POINTS TO A CHAIN OF FREE ML BUFFERS.          *
*                                                                     *
*        OPERATION -                                                  *
*                                                                     *
*      THE ROUTINE ATTEMPTS TO GET SPACE IN THE CURRENT BUFFER.  IF   *
* SUCCESSFUL, IT RETURNS TO THE CALLER.  IF NOT ENOUGH SPACE EXISTS   *
* IN THE CURRENT BUFFER, THE ROUTINE QUEUES IT ON $FBBSCA.  ALSO, IF  *
* NOT ENOUGH SPACE EXISTS OR UPON ENTRY THERE WAS NO CURRENT BUFFER,  *
* THE ROUTINE TRIES TO GET ANOTHER BUFFER.  IF SUCCESSFUL, IT INIT-   *
* IALIZES THE POINTERS TO THE NEW CURRENT BUFFER AND AGAIN ATTEMPTS   *
* TO GET SPACE.  IF UNSUCCESSFUL AT GETTING A NEW CURRENT BUFFER, IT  *
* TAKES A NON-PROCESS EXIT AND ON REENTRY TRIES AGAIN TO GET A        *
* BUFFER.                                                             *
*                                                                     *
*      $BFLUSH ---                                                    *
*                                                                     *
*      THIS ENTRY IS FOR TRUNCATING AND QUEUEING THE CURRENT BUFFER.  *
* WHEN $BFLUSH IS CALLED, THERE MUST BE A CURRENT BUFFER.  AFTER THE  *
* ROUTINE HAS QUEUED THE BUFFER, IT TRIES TO GET ANOTHER BUFFER.  IF  *
* SUCCESSFUL, IT INITIALIZES POINTERS TO THE NEW CURRENT BUFFER.  BUT *
* IF THERE ARE NO FREE BUFFERS, THE ROUTINE RETURNS TO THE CALLER     *
* RATHER THAN DO A NON-PROCESS EXIT.                                  *
*                                                                     *
***********************************************************************
*                                                                     *
*              ENTRY TO TRUNCATE CURRENT BUFFER.                      *
*                                                                     *
$BFLUSH  $ST   ARR,(FBRET1,FBR)    SAVE RETURN ADDRESS.
         $LA   R1,0                SHOW ZERO AS THE LENGTH TO GET.
         $J    CKL30               GO QUEUE THE CURRENT BUFFER.
*
*              ENTRY TO OBTAIN SPACE IN THE CURRENT BUFFER.
*
$CKLEN   $ST   ARR,(FBRET1,FBR)    SAVE RETURN ADDRESS.
         $ST   R1,(FBREG1,FBR)     SAVE LENGTH REQUIRED BY CALLER.
         $ST   IAR,(FBENT,FBR)     SAVE REENTRY POINT FOR NO BUFFERS.
         $CLI  $CURMLB-1,0         IS THERE NOW A CURRENT BUFFER...
         $JE   CKL40               IF NOT, GO TRY TO GET ONE.
*
*
*              IF ENOUGH SPACE IS AVAILABLE IN CURRENT ML BUFFER,
*              ASSIGN THAT SPACE TO THE CALLER AND RETURN.
*
*
CKL21    $ALC  (FBREG1,FBR),$CURMLP,2  ADD TO IT THE CURRENT POINTER.
         $CLC  (FBREG1,FBR),$CURMLL,2  IS SUM .LE. ADR OF LAST AVL BYTE
         $JH   CKL30               JUMP IF NOT TO QUEUE CUR ML BUFFER.
         $L    R1,(FBREG1,FBR)     SET OUTPUT TO CALLER IN R1,
         $ST   R1,$CURMLP          AND UPDATE $CURMLP.
         $L    IAR,(FBRET1,FBR)    THEN RETURN TO CALLER.
*
*
*              NOT ENOUGH SPACE IS LEFT IN CURRENT ML BUFFER TO SATISFY
*              THE CALLER'S REQUEST.  QUEUE THE CURRENT ML BUFFER
*              FOR TRANSMISSION.
*
*
CKL30    EQU   *
         $ST   R1,(FBREG1,FBR)     SAVE R1 IN THE FB.
         $LA   R1,$FBBSCA+FBBUF-FBD POINT TO XMIT BUF QUEUEING FIELD.
CKL31    $CLC  (0,R1),ZERO,2       ARE WE AT END-OF-CHAIN...
         $JZ   CKL32               JUMP IF YES.
         $L    R1,(0,R1)           NO, NOT YET.  GO TO NEXT LINK.
         $B    CKL31               CHECK NEXT LINK FOR END-OF-CHAIN.
CKL32    $MVC  (0,R1),$CURMLB,2    STICK CUR BUF ON END OF CHAIN.
         $L    R1,$CURMLB          POINT R1 TO CURRENT BUFFER.
         $MVC  (2,R1),$CURMLP,4    BYTES 1-4 TO AL2(0,LAST BYTE USED).
         $MVI  $CURMLB-1,0         SHOW NO CURRENT BUFFER.
         $L    R1,(2,R1)           POINT TO THE LAST BYTE USED.
         $MVC  (2,R1),ETBSEQ,2     MOVE IN EOB AND ETB AS END SEQUENCE.
         $ALC  $FBBSCA+FBBCT-FBD,ONE  UP $BSCA BUFFER CTR BY ONE.
         $SBN  BCF1,BFPOST         POST THE BSCA PROCESSOR.
*
*
*              GET A NEW ML BUFFER, INITIALIZE FOR IT, AND
*              GO BACK TO SATISFY CALLER'S REQUEST.
*
*
CKL40    $CLC  (FBREG1,FBR),ZERO,2 IF ENTRY WAS NOT VIA $BFLUSH,
         $JNE  CKL50               GO TRY TO GET ANOTHER BIFFER.
         $L    IAR,(FBRET1,FBR)    OTHERWISE RETURN TO CALLER.
CKL50    $L    R1,$MLPOOL          GET ADDRESS OF A NEW BUFFER
         $ST   R1,$CURMLB          AND SHOW IT AS OUR CURRENT BUFFER.
         $CLI  $MLPOOL-1,0         WAS A BUFFER AVAILABLE...
         $BE   $COMRETB            IF NOT, NON-PROCESS EXIT.
         $MVC  $MLPOOL,(0,R1),2    DEQUEUE BUFFER FROM FREE POOL.
         $LA   R1,(5,R1)           POINT TO THE SPOT FOR FCS2.
         $ST   R1,$CURMLP          SET LAST-USED BYTE.
         $A    R1,CKLLAST          UP R1 TO LAST AVAILABLE BYTE.
         $ST   R1,$CURMLL          SET LAST AVAILABLE BYTE.
         $L    R1,(FBREG1,FBR)     SET R1 AS ON ENTRY.
         $B    CKL21               NOW GO ALLOCATE FOR THE USER.
*
*
*              CONSTANTS AND SYSTEM CELLS.
*
*
ZERO     $DC   YL2(0)              HALFWORD CONSTANT OF ZERO.
$CURMLP  $DC   YL2(0)              POINTER TO CURRENT BUFFER'S FCS2.
$CURMLL  $DC   YL2(0)              POINTER TO LAST AVAILABLE BYTE.
$CURMLB  $DC   YL2(0)              POINTER TO CUR ML BUF CHAIN WORD.
CKLLAST  $DC   YL2(0-7)            CONSTANT TO COMPUTE $CURMLL,
*                                  INITIALIZED WITH &MLBFSIZ BY $ALC.
$MLPOOL  $DS   YL2                 POOL POINTER - SET BY INITIALIZATION
         TITLE '$FREEBUF - FREE A ML BUFFER'
*
*
*              $FREEBUF - DEQUEUE A ML BUFFER FROM A FUNCTION BLOCK,
*        REDUCE THE FUNCTION BLOCK'S COUNT OF BUFFERS BY ONE, AND
*        QUEUE THE FREED BUFFER ON $MLPOOL.
*
*
$FREEBUF $ST   ARR,FRERET+3        SAVE RETURN ADDRESS.
         $ST   R1,FRER1+3          SAVE REGISTER 1.
         $SLC  (FBBCT,FBR),ONE     REDUCE BUFFER COUNT BY 1.
         AIF   (NOT &DEBUG).FREBUG *
         $BM   ABEND               IF NEGATIVE, ABEND.
.FREBUG  $CLC  (FBBCT,FBR),(FBBMX,FBR)  CAN WE TAKE MORE BUFFERS...
         $JNL  FRE1                JUMP IF NOT.
         $MVC  FFCB1+1,(FBFCS1,FBR)  OTHERWISE
FFCB1    $SBN  $FCS1,*-*               TURN ON
         $MVC  FFCB2+1,(FBFCS2,FBR)      THE APPROPRIATE
FFCB2    $SBN  $FCS2,*-*                   BIT IN $FCS.
         $SBN  BCF1,BFCSON+BFPOST  SHOW FCS BIT ON, POST BSCA.
         $SBN  (FBFLG,FBR),BFCSON  SHOW THIS FB TURNED FCS ON.
FRE1     $L    R1,(FBBUF,FBR)      POINT TO CURRENT BUFFER.
         $MVC  (FBBUF,FBR),(0,R1),2  DEQUEUE IT FROM FUNCTION BLOCK.
         $MVC  (0,R1),$MLPOOL,2    QUEUE IT ONTO
         $ST   R1,$MLPOOL          THE FREE BUFFER CHAIN.
         AIF   (NOT &S35471).F71   *
         $POST $FBCON,WORK+EWFPOST POST 5471 PROCESSOR.
.F71     ANOP                      *
FRER1    $LA   R1,*-*              RESTORE REGISTER 1
FRERET   $B    *-*                 AND RETURN TO CALLER.
         AIF   (NOT &DEBUG).NOABEND  *
         TITLE 'ABNORMAL END DUMP SUBROUTINE'
ABEND    EQU   *
         $ST   ARR,1               DUMP ARR
         $ST   R1,3                DUMP R1
         $ST   R2,5                DUMP R5
         $SIO  14,0,4,1            EJECT A PAGE.
         $MVC  DCUR,ZERO,2         START DUMPING AT ZERO
D1       $L    R2,DCUR             GET DUMP START.
         $L    R1,DLN              POINT TO START OF LINE.
         $MVI  (131,R1),C' '       SET PRINT LINE
         $MVC  (130,R1),(131,R1),131                   TO BLANKS.
         $CLC  DCUR,DLIM,2         IS THERE MORE CORE TO DUMP...
         $JL   D3                  JUMP IF YES.
D2       $HPL  HA                  HALT IF NO.
         $B    ABEND+12            RESTART IF REQUESTED.
D3       $MVI  DFC,2               DUMP 2 BYTES OF LINE ADR
         $LA   R2,DCUR-1           SHOW WHERE ADDRESS IS.
         $B    DFORMAT             GO DO IT.
         $LA   R1,(2,R1)           ADD 2 BLANKS.
         $L    R2,DCUR             NOW DUMP THE CORE,
         $MVI  DFC,4               4 BYTES AT A TIME.
         $B    DFORMAT             BYTES 0-3
         $B    DFORMAT             BYTES 4-7
         $B    DFORMAT             BYTES 8-11
         $B    DFORMAT             BYTES 12-15
         $LA   R1,(1,R1)           ADD A BLANK
         $B    DFORMAT             BYTES 16-19
         $B    DFORMAT             BYTES 20-23
         $B    DFORMAT             BYTES 24-27
         $B    DFORMAT             BYTES 28-31
         $LA   R1,(1,R1)           ADD A BLANK
         $MVI  (0,R1),C'*'         ASTERISK
         $L    R2,DCUR             POINT TO SOURCE
         $MVC  (32,R1),(31,R2),32  MOVE FOR EBCDIC.
         $MVI  (33,R1),C'*'        ASTERISK
         $SNS  14,0,3,WORK         FIND LENGTH OF CHAIN IMAGE.
         $LA   R2,48               ASSUME 48-CHARACTER CHAIN.
         $TBN  WORK,4              IS IT 48-CHAR
         $JT   DE1                 JUMP YES
         $LA   R2,60               NO, 120
DE1      $ST   R2,DCC              SAVE COUNT.
         $MVI  DCCC,32             SAVE CT OF CHARS TO CK.
         $MVC  DCCK,DCCC           SET NR OF CHARS TO CK.
DE10     $L    R2,DIM              POINT TO 1ST IMAGE BYTE.
         $MVC  DCK,DCC             SET IMAGE LENGTH.
         $LA   R1,(1,R1)           GET A BYTE OF DUMP.
         $MVC  DE11+1,(0,R1)       MOVE IT INTO CLI.
DE11     $CLI  (0,R2),*-*          CHECK CHARACTER.
         $JE   DE12                JUMP IF PRINTABLE.
         $LA   R2,(1,R2)           ELSE PT TO NEXT IMAGE CHAR.
         $SLC  DCK,ONE             REDUCE IMAGE CT BY 1.
         $BNZ  DE11                CK AGAIN IF NOT ZERO.
         $MVI  (0,R1),C' '         ELSE SET TO BLANK.
DE12     $SLC  DCCK,ONE            MORE CHARS TO CHECK...
         $BNZ  DE10                B IF SO.
         $MVI  DDP+1,X'80'         ALLOW DUP-LINE ASTERISKS.
DPRINT   $LIO  14,0,4,DIM          SET PRINTER IMAGE ADR.
         $LIO  14,0,6,DLN          SET PRINTER DATA ADDRESS.
         $SIO  14,0,2,1            PRINT
         $APL  14,0,2              WAIT
DA       $L    R2,DCUR             POINT TO CURRENT SOURCE.
         $ALC  DCUR,DC32,2         UP CUR PTR BY 32.
         $CLC  DCUR,DLIM,2         IF AT LIMIT,
         $BNL  D2                  GO HALT.
         $CLC  (31,R2),(63,R2),32  CHECK DUPLICATE LINE.
         $BNE  D1                  IF NOT, DUMP IT.
DDP      $NOPB DA                  B IF AST ALREADY PRINTED.
         $MVI  DDP+1,0             SET $NOPB TO $B.
         $L    R2,DLN              NO.  GET ADDR OF LINE.
         $MVI  (131,R2),C' '       DLEAR THE
         $MVC  (130,R2),(131,R2),131  LINE.
         $MVC  (3,R2),DAST,4       SET ASTERISKS.
         $B    DPRINT              PRINT ASTERISKS.
         SPACE 5
DFORMAT  $ST   ARR,DFEND+3         SAVE RETURN ADDRESS.
         $MVC  DFK,DFC             DON'T DESTROY CALLER'S COUNT.
DF0      $MNZ  (0,R1),(0,R2)       SINK A ZONE.
         $MNN  (1,R1),(0,R2)       SINK A NUMERIC.
         $SBN  (0,R1),X'F0'        SET ALL ZONE BITS IN
         $SBN  (1,R1),X'F0'        BOTH SINK BYTES.
         $CLI  (0,R1),C'9'         IS LEFT BYTE NUMERIC...
         $JNH  DF1                 JUMP YES.
         $SLC  (0,R1),FIFTY7       NO.  ADJUST IT.
DF1      $CLI  (1,R1),C'9'         IS RIGHT BYTE NUMERIC...
         $JNH  DF2                 JUMP YES.
         $SLC  (1,R1),FIFTY7       NO.  ADJUST IT.
DF2      $LA   R1,(2,R1)           UP SINK REGISTER BY 2.
         $LA   R2,(1,R2)           UP SOURCE REGISTER BY 1.
         $SLC  DFK,ONE             REDUCE COUNT BY 1.
         $BNZ  DF0                 BR IF MORE TO DO.
         $LA   R1,(1,R1)           OTHERWISE LEAVE A BLANK
DFEND    $B    *-*                 AND RETURN.
         SPACE 5
DLN      $DC   YL2(LPDA)
DIM      $DC   YL2(LPIA)
DLIM     $DC   YL2(&MACHSIZ-1)
DCUR     $DS   YL2
DC32     $DC   HL2'32'
DAST     $DC   C'****'
DFK      DS    X
DFC      DS    X
DCK      DS    X
DCC      DS    X
DCCK     DS    X
DCCC     DS    X
.NOABEND ANOP                      *
         TITLE '$LOG - HASP ERROR RECORDING'
*                                                                     *
***********************************************************************
*                                                                     *
*        $LOG COUNTS THE 1-BITS IN A STATUS BYTE.                     *
*                                                                     *
*        INPUT IS R1 POINTING TO A 7-BYTE AREA ---                    *
*           BYTE 0   - THE STATUS BYTE (DESTROYED ON OUTPUT)          *
*           BYTE 1,2 - POINTER TO FIRST COUNTER (TRANSPARENT)         *
*           BYTE 3-6 - 4-BYTE WORK AREA (GARBAGE).                    *
*                                                                     *
*        R1 AND R2 ARE TRANSPARENT TO THE CALLER.                     *
*                                                                     *
***********************************************************************
*                                                                     *
         SPACE 3
$LOG     $ST   ARR,(4,R1)          SAVE RETURN ADDRESS.
         $ST   R2,(6,R1)           SAVE REGISTER 2.
         $L    R2,(2,R1)           POINT R2 TO FIRST COUNTER.
LOG1     $ALC  (0,R1),(0,R1)       ADD THE STATUS BYTE TO ITSELF.
         $JC   LOG2,X'20'          SKIP IF NO CARRY.
         $ALC  (1,R2),ONE,2        OTHERWISE UP A COUNTER BY ONE.
LOG2     $LA   R2,(2,R2)           POINT R2 TO THE NEXT COUNTER.
         $BC   LOG1,162            B IF CARRY OR IF NO CARRY & NOT ZERO
         $L    R2,(6,R1)           OTHERWISE, RESTORE R2
         $L    IAR,(4,R1)          AND RETURN TO CALLER.
         SPACE 5
LOGEND   EQU   &MACHSIZ-1
         AIF   (NOT &S31442).LOG1442  *
LOG1442B EQU   &MACHSIZ-16         1442 STATUS BYTE 2 COUNTERS
LOG1442A EQU   &MACHSIZ-32         1442 STATUS BYTE 1 COUNTERS
&MACHSIZ SETA  &MACHSIZ-32         *
.LOG1442 ANOP                      *
LOGBSCA  EQU   &MACHSIZ-16         BSCA STATUS BYTE 2 COUNTERS
LOG5203B EQU   &MACHSIZ-32         5203 STATUS BYTE 2 COUNTERS
LOG5203A EQU   &MACHSIZ-48         5203 STATUS BYTE 1 COUNTERS
         AIF   (NOT &S35424).NOMFCUL
LOG5424  EQU   &MACHSIZ-64         5424 STATUS BYTE 1 COUNTERS
.NOMFCUL ANOP
&MACHSIZ SETA  &MACHSIZ-48-&S35424*16
LOGLEN   EQU   LOGEND-&MACHSIZ+1   LENGTH OF LOG COUNTERS
LOGID    EQU   &MACHSIZ-1          ADDRESS OF LOG ID
&MACHSIZ SETA  &MACHSIZ-5          LEAVE SPACE FOR 'HASP'
         TITLE '$MSG --- MESSAGE-TRACING SUBROUTINE'
$MSG     $ST   ARR,MSGXIT+3        SAVE RETURN ADDRESS.
         $ALC  MSGPLACE,FOUR,2     UP MSG TRACE ADR BY 4.
         $CLC  MSGPLACE,AMSGLAST,2 COMPARE WITH THE MAXIMUM.
         $JNH  MSG01               JUMP IF STILL WITHIN BOUNDS.
         $MVC  MSGPLACE,AMSGFRST,2 ELSE RESET TRACE ADR TO FIRST.
MSG01    $MVC  MSGFIRST,(3,R1),4   PUT MESSAGE IN TRACE BABLE.
         AIF   (NOT &S35471).MSGP  *
         $POST $FBCON,WORK+EWFPOST POST 5471 PROCESSOR FOR WORK.
         AGO   .MNOPRT             *
         $POST $FBCONP,WORK        POST CONSOLE PRINTER FOR WORK.
.MSGP    AIF   (&PRTCONS NE 1 AND &PRTCONS NE 2).MNOPRT  *
         $POST $FBCONP,WORK        POST PRTCON PROCESSOR FOR WORK.
.MNOPRT  ANOP                      *
MSGPLACE EQU   MSG01+3             ADR OF LOW-ADDRESS TRACE ENTRY.
MSGXIT   $B    *-*                 RETURN TO CALLER.
         SPACE 5
MESSAGES DC    XL(4*&S3TRACE)'0'   MESSAGE TRACE TABLE
MSGFIRST EQU   MESSAGES+3          ADR OF FIRST ENTRY
MSGLAST  EQU   MESSAGES+L'MESSAGES-1  ADR OF LAST ENTRY
FOUR     $DC   YL2(4)              CONSTANT OF 4.
AMSGFRST $DC   YL2(MSGFIRST)       POINTER TO FIRST ENTRY
AMSGLAST $DC   YL2(MSGLAST)        POINTER TO LAST ENTRY
         TITLE 'FUNCTION BLOCKS'
         AIF   (NOT &S35424).NOMFCUM
A5424    $FB   ENT=$MFCU,SHORT=YES,R1=HCA1
B5424    $FB   ENT=$MFCU,SHORT=YES,R1=HCA2
.NOMFCUM ANOP
         AIF   (NOT &S31442).FB5203  *
#1442    $FB   ENT=$1442,SHORT=YES,R1=HCA1442
.FB5203  ANOP
#5203    $FB   ENT=$5203,SHORT=YES,R1=PCA
BSCA     $FB   ENT=BS200,R1=BCA,BMX=0
$FBFRSTE EQU   *                   FIRST FB ELIGIBLE FOR RCVD BUFFERS.
         AIF   (NOT &S35471).CON75 *
CON      $FB   ENT=$CON,R1=CCA,WORK=11,RCB=X'91',BMX=255,EWF=EWFPOST
         AGO   .CONEND
.CON75   AIF   (NOT &S35475).CONP
CON      $FB   ENT=CONEND,R1=CCA,WORK=11
.CONP    AIF   (&PRTCONS NE 1 AND &PRTCONS NE 2).CONEND
CONP     $FB   ENT=$CONP,R1=PCA,WORK=11,RCB=X'91',BMX=255
.CONEND  ANOP
&TEMP    SETA  &S3NRDRS            *
&TMP     SETA  1
.RD      AIF   (&TEMP LE 0).RDE    *
RD&TMP   $FB   ENT=$READER,RCB=X'83'+16*&TMP,WORK=9,                   C
               FLG=FFLAST*(&TMP/&S3NRDRS)
&TEMP    SETA  &TEMP-1
&TMP     SETA  &TMP+1
         AGO   .RD
.RDE     ANOP
PR1      $FB   ENT=$PRINTER,                                           C
               BMX=NBUFPR,WORK=11,RCB=RCBPR1,FCS=FCSPR1
&TEMP    SETA  &S3NPUNS            *
&TMP     SETA  1
.PU      AIF   (&TEMP LE 0).PUE    *
PU&TMP   $FB   ENT=$PUNCH,FLG=FFLAST*(&TMP/&S3NPUNS),                  C
               WORK=11+40*&S3OBJDK+48*&S396COL-40*&S3OBJDK*&S396COL,   C
               BMX=NBUFPU,RCB=RCBPU&TMP,FCS=FCSPU&TMP
&TEMP    SETA  &TEMP-1
&TMP     SETA  &TMP+1
         AGO   .PU
.PUE     ANOP
         SPACE 5
$FB&FBN  EQU   0                   END OF FUNCTION BLOCKS.
NBUF     EQU   (&MACHSIZ-(*-HRTPSYS3))/(&MLBFSIZ+2)  NR OF T P BUFFERS.
NBUFPR   EQU   1+NBUF/3            BUFS PER PRINTER
NBUFPU   EQU   1+NBUF*2/9          BUFS PER PUNCH
         TITLE 'BUFFER INITIALIZATION'
*                                                                     *
***********************************************************************
*                                                                     *
*        BUFFER INITIALIZATION AND /*SIGNON SETUP                     *
*                                                                     *
***********************************************************************
*                                                                     *
$MLB1    $DC   YL2(0)              1ST BUF, TO BE QUEUED TO $FBBSCA.
         $SIGNON REMOTE=&RMTID,PASSWD=&PASSWD,DIAL=&DIAL&DIAL1
         SPACE 3
*                                                                     *
***********************************************************************
*                                                                     *
*        INITIALIZE VARIOUS LOCATIONS WITH &MLBFSIZ                   *
*                                                                     *
***********************************************************************
*                                                                     *
IBUF     $LA   R1,BFSZ             POINT TO &MLBFSIZ.
         $MVC  BMLBFSIZ,(0,R1),2   SET BUFFER SIZE IN BSCA.
         $ALC  CKLLAST,(0,R1),2    ADD BUFFER SIZE IN $CKLEN.
         $ALC  BCR2,(0,R1),2       ADD BUFFER SIZE FOR /*SIGNON BUF.
         $ALC  IBUF0+3,(0,R1),2    ADD BUF SIZE FOR BUFFER INITIALIZ.
         $SLC  IMCHSZ,(0,R1),2     SUBTRACT BUF SIZE FOR BUF INIT.
         $ALC  IBFSZ,(0,R1),2      ADD BUFFER SIZE FOR BUFFER INIT.
         $LA   R2,$MLPOOL          POINT TO BUF POOL POINTER.
IBUF0    $LA   R1,$MLB1+0+2        AND R1 TO SECOND BUFFER.  THIS
*                            INSTRUCTION INITIALIZED WITH &MLBFSIZ.
*                                                                     *
***********************************************************************
*                                                                     *
*        MOVE REMAINING BUFFER INITIALIZATION CODE TO LOW CORE.       *
*                                                                     *
***********************************************************************
*                                                                     *
         $MVC  X'80'+IBUF3-IBUF1-1,IBUF3-1,IBUF3-IBUF1
         $B    X'80'
*                                                                     *
***********************************************************************
*                                                                     *
*        CODE FROM HERE TO IBUF3 GETS EXECUTED IN LOW CORE.           *
*                                                                     *
***********************************************************************
*                                                                     *
IBUF1    $ST   R1,WORK             PUT R1 IN STORAGE FOR COMPARE.
         $CLC  WORK,IMCHSZ,2       IS 2D (3D,...) BUF WITHIN BOUNDS...
         $JH   IBUF2               IF NOT, JUMP TO ZERO PREV BUF PTR.
         $ST   R1,(0,R2)           YES.  POINT PREV BUFFER TO IT,
         $LA   R2,(0,R1)           MAKE IT THE PREVIOUS BUFFER,
         $A    R1,IBFSZ            AND POINT R1 TO NEXT BUFFER.
         $B    X'80'               THEN DO IT AGAIN.
IBUF2    $MVC  (0,R2),ZERO,2       ZERO PREVIOUS BUFFER POINTER.
*                                                                     *
***********************************************************************
*                                                                     *
*        QUEUE ONTO $FBBSCA THE BUFFER CONTAINING /*SIGNON CARD       *
*                                                                     *
***********************************************************************
*                                                                     *
         $LA   R2,$MLB1            POINT TO THE SIGNON BUFFER.
         $ST   R2,FBBUF+$FBBSCA-FBD  QUEUE SIGNON BUFFER ON $FBBSCA.
         $MVI  FBBCT+$FBBSCA-FBD,1 SET $FBBSCA BUFFER COUNTER TO 1.
         $B    $COM                READY, SET, GO.
IMCHSZ   $DC   YL2(&MACHSIZ-0-2)   MAX STARTING ADDRESS OF A BUFFER,
*                                  INITIALIZED WITH &MLBFSIZ BY $SLC.
IBFSZ    $DC   YL2(0+2)            MULTI-LEAVING BUFFER SIZE,
*                                  INITIALIZED WITH &MLBFSIZ BY $ALC.
IBUF3    EQU   *
         TITLE 'INITIALIZATION'
         SPACE 20
$INIT    DS    0H                  AVOID POSSIBLE 'END' CARD ERROR.
         SPACE 5
         $MVC  FEIBM+31,FESVCNO,32 SET IBM FE SERVICE NUMBER.
         $MVC  LPIA+47,ILC,48      SET 48-CHAR PRINT CHAIN.
         $SNS  14,0,3,ISNS         GET STATUS TO CHECK PRINT CHAIN.
         $TBN  ISNS,4              IS 48-CHAR CHAIN MOUNTED...
         $JT   REP                 JUMP IF SO.
         $MVC  LPIA+119,IPN,120    NO.  SET 120-CHAR PRINT CHAIN.
         $J    REP                 THEN JUMP OVER CONSTATNS.
ISNS     $DC   YL2(0)              PRINTER STATUS BYTES.
ILC      $DC   C'1234567890#@/STUVWXYZ&&,%JKLMNOPQR-$*ABCDEFGHI+.'''
IPN      $DC   2C'1234567890XY/STUVW:_",=JKLMNOPQR-Z(ABCDEFGHI+.)%$*#&C
               &@<;^''?>'
         TITLE 'REP PROCESSOR'
*
*
*              REP PROCESSOR.
*
*
         AIF   (NOT &S35424).NOMFCUN
REP      $APL  15,0,0              HANG IF PRIMARY MFCU NOT READY.
         $LIO  15,0,5,AREPD        LOAD MFCU READ DATA ADR REG.
         $SIO  15,0,1,0            READ A CARD FROM PRIMARY HOPPER.
         $APL  15,0,7              WAIT TILL MFCU NOT BUSY.
         $SNS  15,0,3,REPSNS       GET MFCU STATUS BYTES.
         $TBN  REPSNS-1,X'80'      DID CARD READ OKAY...
         $JF   RP01                JUMP IF SO.
         AGO   .NOMFCUO
.NOMFCUN ANOP
REP      $APL  5,0,0               HANG IF 1442 NOT READY.
         $LIO  5,0,4,AREPD         LOAD 1442 DATA ADR REG.
         $SIO  5,0,1,1             READ EBCDIC FROM 1442.
         $APL  5,0,2               HANG TILL 1442 NOT BUSY.
         $SNS  5,0,3,REPSNS        GET 1442 STATUS BYTES.
         $TBN  REPSNS,X'40'        IS LAST-CARD BIT ON...
         $JF   RP00                JUMP IF NOT.
         $SIO  5,0,0,1             YES.  RUN OUT LAST CARD.
RP00     $TBF  REPSNS,X'97'        WERE THERE ANY ERRORS...
         $JT   RP01                JUMP IF NOT.
.NOMFCUO ANOP
         $HPL  F3                  NO.  HALT SHOWING A READ CHECK.
         $B    REP                 THEN GO READ AGAIN.
*
*
*              CHECK FOR /*SIGNON, &MLBFSIZ=, EOR, REP.
*
*
RP01     $CLC  REPD+3,RPEOR,3      IS THE CARD END-OF-REP...
         $JE   REPEOR              JUMP IF SO.
         $CLC  AMPMLB,REPD+8,9     IS THE CARD &MLBFSIZ=...
         $BE   BUFFERSZ            JUMP IF SO.
         $CLC  REPD+7,RPSIGN,8     IS THE CARD SIGNON...
         $JE   REPSIGN             JUMP IF SO.
         $CLC  REPD+3,RPREP,3      IS THE CARD A REP CARD...
         $BNE  REP                 IF NOT, GO READ ANOTHER.
*
*
*              PROCESS A REP CARD.
*
*
         $LA   R1,REPD+16          POINT TO BYTE 1 OF REP DATA.
         $CLI  REPD+11,C' '        IS NO ADDRESS SPECIFIED...
         $JE   RP20                JUMP IF SO.
         $LA   R2,REPD+8           NO.  POINT TO FIRST BYTE.
         $CLI  (0,R2),C'0'         TRANSLATE
         $JNL  RP10                  FIRST CHARACTER
         $ALC  (0,R2),FIFTY7           TO HEX CHARACTER.
RP10     $CLI  (1,R2),C'0'         TRANSLATE
         $JNL  RP11                  SECOND CHARACTER
         $ALC  (1,R2),FIFTY7           TO HEX CHARACTER.
RP11     $CLI  (2,R2),C'0'         TRANSLATE
         $JNL  RP12                  THIRD CHARACTER
         $ALC  (2,R2),FIFTY7           TO HEX CHARACTER.
RP12     $CLI  (3,R2),C'0'         TRANSLATE
         $JNL  RP13                  FOURTH CHARACTER
         $ALC  (3,R2),FIFTY7           TO HEX CHARACTER.
RP13     $MZN  RPMVI+2,(0,R2)      SET BEGINNING
         $MNN  RPMVI+2,(1,R2)        ADDRESS INTO
         $MZN  RPMVI+3,(2,R2)          THE
         $MNN  RPMVI+3,(3,R2)            $MVI.
         SPACE 5
*
*
*              PROCESS THE REP DATA.
*
*
RP20     $CLI  (0,R1),C' '         IS THIS THE END OF THE REP CARD...
         $BE   REP                 YES.  GO GET THE NEXT CARD.
         $CLI  (0,R1),C','         IS THIS END-OF-OPERAND...
         $JNE  RP21                NO.  GO PROCESS 2 COLUMNS.
         $LA   R1,(1,R1)           YES.  GO TO NEXT COLUMN
         $B    RP20                AND CHECK IT.
RP21     $CLI  (0,R1),C'0'         IS THE COL '0' THROUGH '9'...
         $JNL  RP22                JUMP IF YES.
         $ALC  (0,R1),FIFTY7       ELSE MAKE IT X'FA' THROUGH X'FF'.
RP22     $CLI  (1,R1),C'0'         DO THE SAME
         $JNL  RP23                  FOR THE
         $ALC  (1,R1),FIFTY7           SECOND CHARACTER.
RP23     $MZN  RPMVI+1,(0,R1)      SET UP THE BYTE
         $MNN  RPMVI+1,(1,R1)        TO REPLACE.
RPMVI    $MVI  *-*,*-*             REP THE LOC TO THE BYTE.
         $ALC  RPMVI+3,ONE,2       UP THE REP ADDRESS BY ONE.
         $LA   R1,(2,R1)           POINT TO NEXT 2 CARD COLUMNS.
         $B    RP20                GO INSPECT THEM.
         SPACE 5
*                                                                     *
***********************************************************************
*                                                                     *
*        END OF REP AND CONTROL CARD PROCESSING.                      *
*                                                                     *
***********************************************************************
*                                                                     *
REPSIGN  $MVC  $SIGNON+79,REPD+79,80  OVERLAY DEFAULT SIGNON CARD.
REPEOR   $LIO  14,0,0,IFORMS       SPECIFY 5203 FORMS LENGTH.
         AIF   (NOT &S35424).NOMFCUP
         $LIO  15,0,4,AHPRB        SPECIFY 5424 PRINT BUFFER ADDRESS.
.NOMFCUP ANOP
*                                                                     *
***********************************************************************
*                                                                     *
*        ENABLE DATASET AND WAIT FOR DATASET READY.                   *
*                                                                     *
***********************************************************************
*                                                                     *
IBSCA    $SIO  8,0,0,X'80'         DISABLE BSCA.
         $SIO  8,0,0,X'C0'         ENABLE BSCA.
*                                                                     *
***********************************************************************
*                                                                     *
*              CHECK FOR TELEPHONE NUMBER TO CALL.                    *
*                                                                     *
***********************************************************************
*                                                                     *
         $LA   R1,$SIGNON+33       POINT TO WHERE 'DIAL ' SHOULD BE.
         $CLC  (0,R1),IDIAL,5      IS IT THERE...
         $JNE  IBSCA1              JUMP IF NOT.
         $LA   R1,(4,R1)           YES.  SEARCH FOR START.
ID1      $LA   R1,(1,R1)           POINT TO NEXT CHARACTER.
         $CLI  (0,R1),C' '         IS IT BLANK...
         $BE   ID1                 LOOP IF SO.
         $ST   R1,IDCA             SAVE ADR FOR CUR ADR REG.
ID2      $LA   R1,(1,R1)           LOOK FOR END OF NUMBER.
         $CLI  (0,R1),C' '         IS THIS END OF NUMBER...
         $BNE  ID2                 LOOP IF NOT.
         $ST   R1,IDPA             SAVE ADR FOR STOP ADR REG.
ID3      $SNS  8,0,3,IBSCSNS       GET BSCA STATUS.
         $TBN  IBSCSNS,1           IF DATA LINE IS OCCUPIED,
         $JT   IBSCA1              ASSUME OPERATOR DIALED.
         $LIO  8,0,4,IDCA          SET CURRENT ADDRESS REGISTER.
         $LIO  8,0,1,IDPA          SET STOP ADDRESS REGISTER.
         $SIO  8,0,4,1             AUTO CALL, RESET INTERRUPTS.
ID3A     $TIO  8,0,1,ID3B          BRANCH IF OP-END INTERRUPT.
         $B    ID3A                OTHERWISE LOOP.
ID3B     $SNS  8,0,3,IBSCSNS       GET BSCA STATUS.
         $TBF  IBSCSNS-1,X'80'     IS THE TIMEOUT BIT OFF...
         $JT   IBSCA1              JUMP IF SO.
ID4      $HPL  CA                  HALT CA = CALL ABORTED.
         $B    IBSCA               IF OPR SAYS START, TRY AGAIN.
IDPA     $DS   YL2                 TEL. NR. STOP ADDRESS.
IDCA     $DS   YL2                 TEL. NR. START ADDRESS.
IDIAL    $DC   C'DIAL '            CONSTANT OF 'DIAL '.
IBSCA1   $SNS  8,0,3,IBSCSNS       GET THE STATUS BYTES.
         $TBN  IBSCSNS,2           IS DATASET REALLY READY...
         $BF   IBSCA1              IF NOT, LOOP TILL READY.
*                                                                     *
***********************************************************************
*                                                                     *
*        SEND TO HASP THE SEQUENCE SOH-ENQ.                           *
*                                                                     *
***********************************************************************
*                                                                     *
IBSCENQ  $LIO  8,0,4,IBIA1         SET CURRENT ADDRESS REGISTER.
         $LIO  8,0,2,IBIA2         SET TRANSITION ADDRESS REGISTER.
         $LIO  8,0,1,IBIA3         SET STOP ADDRESS REGISTER.
         $SIO  8,0,2,1             START TRANSMIT/RECEIVE.
IBSCQ1   $TIO  8,0,1,IBSCQ2        BRANCH IF OP-END INTERRUPT.
         $B    IBSCQ1              OTHERWISE LOOP.
IBSCQ2   $SIO  8,0,0,1             RESET OP-END INTERRUPT.
         $SNS  8,0,3,IBSCSNS       THEN GET STATUS BYTES.
         $TBF  IBSCSNS-1,X'FF'     ARE THERE ANY ERRORS...
         $JT   IBSCACK             JUMP IF NOT.
         $TBF  IBSCSNS-1,X'7F'     YES.  IS IT ONLY TIMEOUT...
         $BT   IBSCENQ             IF SO, GO SEND SOH-ENQ AGAIN.
         AIF   (NOT &DEBUG).IBNOBUG  *
         $SNS  0,0,0,IBSCKNOB      READ IN THE KNOBS.
         $TBN  IBSCKNOB,1          IS LOW-ORDER KNOB ODD...
         $BF   IBSCA               NO.  DO NOT HALT.
         $MNZ  IBH1+4,IBSCSNS-1    YES.  SET ZONE AND NUMERIC
         $MNN  IBH2+4,IBSCSNS-1    OF STATUS BYTE 2.
         $LA   R1,IBHTAB           POINT TO HALT INDICATOR TABLE.
IBH1     $MVC  IBHPL+1,(*-*,R1)    SET LEFT HALT INDICATOR.
IBH2     $MVC  IBHPL+2,(*-*,R1)    SET RIGHT HALT INDICATOR.
IBHPL    $HPL  **                  HALT PROGRAM LEVEL.
         $B    IBSCA               THEN GO TO THE TOP.
IBHTAB   DC    X'6F0376571B5D7D077F5F3F796C737C3C'
IBSCKNOB $DC   YL2(0)              KNOB READ-IN AREA.
.IBNOBUG $B    IBSCA               GO TO THE TOP.
IBI1     DC    X'012D'             SOH, ENQ.
IBI2     DC    X'0000'             SPACE FOR DLE, ACK0.
IBI3     EQU   *                   STOP ADDRESS LOCATION.
IBIA1    $DC   YL2(IBI1)           CURRENT ADDRESS.
IBIA2    $DC   YL2(IBI2)           TRANSITION ADDRESS.
IBIA3    $DC   YL2(IBI3)           STOP ADDRESS.
IBSCSNS  $DC   YL2(0)              BSCA STATUS BYTES.
IBSCACK  $CLC  IBI2+1,ACKSEQ,2     DID HASP SAY DLE-ACK0...
         $BNE  IBSCENQ             IF NOT, GO DO SOH-ENQ AGAIN.
         $TIO  14,0,0,IBSCP        IF PRINTER NOT READY, SKIP PRINT.
         $SIO  14,0,4,1            EJECT A PAGE.
         $LIO  14,0,4,PCIA         LOAD PRINTER IMAGE ADDRESS.
         $LIO  14,0,6,PCDA         LOAD PRINTER DATA ADDRESS.
         $SIO  14,0,2,3            PRINT 'COMM ESTAB',SPACE 3.
         $SIO  14,0,0,3            SPACE ANOTHER 3.
IBSCP    EQU   *
         AIF   (NOT &S35471).INO71 *
         $L    IL1,AINT            SET 5471 INTERRUPT ADDRESS.
         $LIO  1,1,0,CCPD+1        LOAD 1ST CHAR TO PRINT.
         $SIO  1,1,0,X'85'         START PRINTING 'COMM ESTAB'.
         $SIO  1,0,0,5             ENABLE REQUEST KEY INTERRUPTS.
         $B    IBUF                GO INITIALIZE BUFFERS.
AINT     $DC   YL2(CINT)           ADDRESS OF 5471 INTERRUPT ROUTINE.
         AGO   .INO75              *
.INO71   AIF   (NOT &S35475).INO75 *
         $L    IL1,AINT            SET 5475 INTERRUPT ADDRESS.
         $B    IBUF                GO INITIALIZE BUFFERS.
AINT     $DC   YL2(CINT)           ADDRESS OF 5475 INTERRUPT ROUTINE.
.INO75   ANOP                      *
*                                                                     *
***********************************************************************
*                                                                     *
*        CONVERT-TO-BINARY ROUTINE FOR &MLBFSIZ=.                     *
*                                                                     *
***********************************************************************
*                                                                     *
         $B    IBUF                GO INITIALIZE BUFFERS.
BUFFERSZ $LA   R2,MULTAB           POINT TO MULTIPLICATION TABLE.
         $MVC  BFSZ,ZERO,2         CLEAR DEFAULT BUFFER SIZE.
         $L    R1,AREPD            POINT TO THE CARD IMAGE.
BU1      $CLI  (0,R1),C' '         SEARCH
         $JE   BU2                   FOR
         $LA   R1,(1,R1)               LEFTMOST
         $B    BU1                       BLANK.
BU2      $A    R1,MONE             POINT TO NEXT-LEFT DIGIT.
         $CLI  (0,R1),C'='         IS IT RATHER EQUAL-SIGN...
         $BE   BU5                 YES.  END OF CONVERSION.
BU3      $SLC  (0,R1),ONE          NO.  REDUCE DIGIT BY
         $CLI  (0,R1),X'F0'          ONE AND JUMP IF IT'S
         $JL   BU4                 GONE BELOW X'F0'.
         $ALC  BFSZ,(1,R2),2       IF NOT, ADD THE PROPER FACTOR
         $B    BU3                   TO THE TOTAL, AND THEN LOOP.
BU4      $LA   R2,(2,R2)           BELOW X'F0'.  POINT TO NEXT FACTOR
         $B    BU2                   AND GO TO OUTER LOOP START.
BU5      EQU   REP                 &MLBFSIZ= CARD MAY APPEAR ANYWHERE
*                                  BEFORE THE ' EOR' OR '/*SIGNON' CARD
BFSZ     $DC   YL2(&MLBFSIZ)       DEFAULT BUFFER SIZE.
AMPMLB   $DC   C'&&MLBFSIZ='       MLBFSIZ CONTROL CARD.
MULTAB   DC    HL2'1,10,100,1000,10000'
         TITLE 'INITIALIZATION - MISCELLANEOUS CONSTANTS'
         AIF   (NOT &S35424).NOMFCUS
AHPRB    $DC   YL2(HPRB)           ADCON FOR MFCU PRINT BUFFER.
.NOMFCUS ANOP
         SPACE 5
IFORMS   $DC   YL1(&S3FORML,0)     FORMS LENGTH REGISTERS.
AREPD    $DC   YL2(REPD)           POINTER TO REP CARD READ AREA.
         AIF   (NOT &S35424).NOMFCUQ
REPD     EQU   H1RDB               REP READ-IN AREA.
         AGO   .NOMFCUR
.NOMFCUQ ANOP
REPD     EQU   GDATA               REP READ-IN AREA.
.NOMFCUR ANOP
REPSNS   $DC   YL2(0)              REP STATUS BYTES.
RPREP    $DC   C'REP'              REP CARD INDICATOR.
RPSIGN   $DC   C'/*SIGNON'         SIGN-ON CARD INDICATOR.
RPEOR    $DC   C'EOR'              END-OF-REP INDICATOR.
FESVCNO  $DC   C'PGM 360D51014, FE SVC NO 000103.'
         END   $INIT               INITIAL ENTRY IS $INIT.
