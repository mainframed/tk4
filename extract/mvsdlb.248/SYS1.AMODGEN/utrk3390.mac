UTRK3390 TITLE 'IEC0SCR1 3390 support'
UTRK3390 CSECT ,
***********************************************************************
*<TRKCALC 3390>
***********************************************************************
*
*  Function:  IBM TRKCALC macro support for 3390 devices
*             called by UTRKCALC usermod (which is invoked by
*             a zap to IBM's IEC0SCR1 CSECT, part of IGC018 LMOD).
*
*  Device attributes:   see IECZDTAB CSECT (part of Stage2 sysgen)
*             The 3390 device allocates space on a track in
*             multiples of cells, which are 34 bytes in length.
*             See the Formulas section for how this happens.
*
*  Only usable regs:  R0, R1, R9, R10, R11, R14, R15
*  We're not allowed to touch the other regs
*
*        Entry                     Usage (see Notation below)
*        ------------------------- ------------------------------------
*        R0        scratch         Kb;CDb (usually)
*        R1  ->    STAR parmlist   unchanged
*        R9  ->    DVCT entry      DVCT ignored; usually contains Rb
*        R10       scratch         scratch
*        R11       scratch         scratch
*        R14 ->    return address  unchanged
*        R15 ->    UTRKCALC        unchanged
*
*  Notes:
*
*        R0 is partitioned to contain
*           Kb  in bits  0:11,
*           CDb in bits 12:31.
*           Bitwise R0: kkkk.kkkk.kkkk.dddd.dddd.dddd.dddd.dddd
*        This works out OK (or should) since 0 <= KL < 256, and
*        the largest possible Kb = 612 = x'264'; while
*        0 <= DL < 65536, hence the largest possible CDb is
*        67898 = x'1093A'.  Yes, x'FFFF' is a larger record than
*        can be written on a 3390 track, but the caller can pass
*        that value, so we try to deal with it.  This might not seem
*        very significant, but this code is *very* short of usable
*        registers.  As it turns out, we don't need CDb from R0,
*        but it's nice to have around for maintenance.
*
*        We ignore the DVCT pointer since we're so short on regs,
*        and instead of fetching values from the DVCT, we just
*        use local values.  Kinda cheating, but avoids all that
*        ugly "resetting base reg" nonsense.
*
*        A driver for testing UTRK3390 may be generated by
*        specifying 'SYSPARM(TEST)' as a parm to the assembler.
*
*  Notation:
*        C     Count cells = 10
*        Cb    Bytes consumed by Count (cell integral) = 10 * 34
*        KL    Key length
*        KN    (KL + 6) / 232, rounded up; cells
*        K     9 + ( (KL + (KN * 6) + 6) / 34), rounded up; cells
*        DL    Data length
*        Kb    Bytes consumed by Key (cell integral) = K * 34
*        Db    Bytes consumed by Data (cell integral) = D * 34
*        CDb   Bytes consumed by Count + Data = Cb + Db
*        Rb    Bytes consumed by Count + Key + Data = Cb + Kb + Db
*        Tb    Bytes available for use on track = 57876
*              (when standard IBM R0 is present on track)
*        TBb   Bytes remaining on track (track balance)
*
*  Formulas:
*        Each record on a 3390 (Count, [Key,] Data) is allocated
*        as follows (units represent cells):
*
*        Record cells = C + K + D
*
*        Count = 10 cells = 340 bytes
*
*        KN = (KL + 6) / 232, round up to integer
*        K = 0 when no key is present, else
*        K = 9 + ((KL + (6 *KN) + 6) / 34), round up to integer
*
*        DN = (DL + 6) / 232, round up to integer
*        D = 9 + ((DL + (6 * DN) + 6) / 34), round up to integer
*
*  The count area contains 8 bytes that identify the location
*  of the record by cylinder, head, and record number.  The count
*  record also specifies the key length (zero when not present),
*  and the data record length.
*
*  An IBM Standard R0 (record zero) is assumed to be present on
*  each track.  When this record is present on the track, there
*  are 1729 cells; without it, there are 1749 cells.  The IBM
*  Standard R0 is also called a track descriptor record, or a
*  capacity record.
*
*  Data records begin with Record 1.
*
*  An EOF record consumes 20 cells.
*
*  Track Balance represents the amount of free space remaining
*  on a partially written track.
*
*        |<--already-written---------->|<--free-space-->|
*        +-----------------------------+----------------+
*        |      Data                   | Track Balance  |
*        +-----------------------------+----------------+
*        |<----------------3390-track------------------>|
*
***********************************************************************
         EJECT ,
R0       EQU   0
R1       EQU   1
R9       EQU   9
R10      EQU   10
R11      EQU   11
R14      EQU   14
R15      EQU   15
         USING UTRK3390,R15
         USING STAR,R1
***********************************************************************
*  Validate 3390s are generated in the system
***********************************************************************
         L     R10,CVTPTR              @ CVT
         L     R10,CVTZDTAB-CVT(,R10)  @ IECZDTAB   (CVTZDTAB)
         SLR   R11,R11
         IC    R11,15(,R10)       index for 3390s
         LTR   R11,R11            valid?
         BZ    NO3390             no, bail
***********************************************************************
*  Calculate number of bytes occupied by Count, [Key,] Data
***********************************************************************
         SLR   R0,R0              R0 becomes Kb;CDb
*
*  Compute number of bytes occupied by Key portion of record
*
CALCKEY  DS    0H
         CLI   STARKL,0           key specified?
         BE    CALCDATA           no, skip to calc data
*
         SLR   R11,R11
         ICM   R11,1,STARKL       KL
         LA    R11,6(,R11)        KL + 6
         SLR   R10,R10
         D     R10,=F'232'        (KL + 6) / 232 = KN
         LTR   R10,R10            remainder?
         BZ    *+8                no, skip rounding up
         LA    R11,1(,R11)        round KN up
         M     R10,=F'6'          R11 = KN * 6
         LA    R11,6(,R11)        R11 = (KN * 6) + 6
         SLR   R10,R10
         IC    R10,STARKL
         AR    R11,R10            R11 = KL + (KN*6) + 6
         SLR   R10,R10
         D     R10,=F'34'         R11 = (KL+(KN*6)+6)/34 = K - 9
         LTR   R10,R10            remainder?
         BZ    *+8                no, skip rounding up
         LA    R11,1(,R11)        round (K - 9) up
         LA    R11,9(,R11)        R11 + 9 = K
         M     R10,=F'34'         R11 = K * 34 = Kb
         LR    R0,R11             R0 = 00.00.Kb.Kb
*
*  Compute number of bytes occupied by Count + Data portion of record
*
CALCDATA DS    0H
         SLR   R11,R11
         ICM   R11,3,STARDL       R11 = DL
         A     R11,=F'6'          R11 = DL + 6
         SLR   R10,R10
         D     R10,=F'232'        R11 = (DL+6)/232 = DN
         LTR   R10,R10            remainder?
         BZ    *+8
         LA    R11,1(,R11)        round DN up
         M     R10,=F'6'          R11 = DN * 6
         LA    R11,6(,R11)        R11 = (DN*6) + 6
         SLR   R10,R10
         ICM   R10,3,STARDL
         AR    R11,R10            R11 = DL + (DN*6) + 6
         SLR   R10,R10
         D     R10,=F'34'         R11 = (DL+(DN*6)+6)/34 = D - 9
         LTR   R10,R10            remainder?
         BZ    *+8
         LA    R11,1(,R11)        round (D - 9) up
         LA    R11,9(,R11)        R11 + 9 = D
         M     R10,=F'34'         R11 = D * 34 = Db
*
         A     R11,=A(10*34)      add Count bytes (10 cells)
*                                 R11 = CDb
*
*  Preserve a copy of Count + [Key +] Data bytes in R9
*
         LR    R9,R0              R9 = 00.00.Kb.Kb
         AR    R9,R11             R9 = Rb = Cb + Kb + Db
*
*  Preserve a copy of Kb;CDb in R0
*
         SLL   R0,16+4
         OR    R0,R11             R0(0:11)=Kb;R0(12:31)=CDb
         AIF   ('&SYSPARM' NE 'TEST').NOSAVR0
         STCM  R0,15,ZKBCDB       <debug> R0(0:11)=Kb;R0(12:31)=CDb
.NOSAVR0 ANOP
         EJECT ,
***********************************************************************
*  Calculate track balance or use value user provided in STARBAL
***********************************************************************
CALCTBAL DS    0H
         CLI   STARR,1            star Record=1?
         BNE   CTBN1              no, br
*
*  Calc trkbal: r=1
*
         L     R11,=A(1729*34)    3390 track length w/ standard IBM R0
         STCM  R11,3,STARBAL      return full track length to caller
         TM    STARFLGS,STARREMV  REMOVE=YES?
         BNO   CKFUNCTN           deal with REMOVE=NO later
*
         LR    R0,R11             return track length to caller
         SLR   R15,R15            return code = 0
         BR    R14                return to caller
*----------------------------------------------------------------------
*
*  Calc trkbal: not r=1
*
CTBN1    DS    0H                 not star r=1
         TM    STARFLGS,STARUBAL  caller provided us with balance?
         BO    CKFUNCTN           yes, use it; br
*
*  Caller didn't provide track balance, calculate it for STARR recs
*
         SLR   R11,R11
         IC    R11,STARR          caller-provided R#
         TM    STARFLGS,STARREMV  REMOVE=YES?
         BO    *+6                yes; br
         BCTR  R11,0              R# - 1
         MR    R10,R9             R11 = bytes used by records
         L     R10,=A(1729*34)    track length -
         SR    R10,R11            used bytes = track balance
         STCM  R10,3,STARBAL      return track balance to caller
         EJECT ,
***********************************************************************
*  Check which TRKCALC FUNCTN= was specified
***********************************************************************
CKFUNCTN DS    0H
         SLR   R11,R11
         ICM   R11,3,STARBAL      R11 = track balance
         TM    STARFLGS,STARFUNC  FUNCTN=TRKCAP?
         BNO   TRKBAL             no, FUNCTN=TRKBAL; br
         SPACE 3
***********************************************************************
*  TRKCALC FUNCTN=TRKCAP
*  Returns R0 = # fixed length records that will fit on track balance
***********************************************************************
TRKCAP   DS    0H
         SLR   R10,R10
         DR    R10,R9             R11 = recs that fit in TBb
         LTR   R0,R11             how many was that?
         BNP   TCNOFIT            none?  br
*
TCFIT    DS    0H
         SLR   R15,R15            TRKCAP rc=0
         BR    R14                return to caller
*----------------------------------------------------------------------
TCNOFIT  DS    0H
         SLR   R0,R0              can't fit any records in TBb
         LA    R15,4              trkcap rc=4
         BR    R14                return to caller
*----------------------------------------------------------------------
         EJECT ,
***********************************************************************
*  TRKCALC FUNCTN=TRKBAL
***********************************************************************
TRKBAL   DS    0H
         TM    STARFLGS,STARREMV  REMOVE=YES specified?
         BNO   TBLEAVE            no, leave record there; br
*
         AR    R11,R9             reclaim removed rec's space
         STCM  R11,3,STARBAL      return new balance to caller
         LR    R0,R11             return new balance to caller
         SLR   R15,R15            TRKBAL rc=0
         BR    R14
*----------------------------------------------------------------------
TBLEAVE  DS    0H
         CR    R11,R9             record fits within balance?
         BL    TBCKMAX
*
         SR    R11,R9             fits, calc new balance
         STCM  R11,3,STARBAL      return new balance to caller
         LR    R0,R11             return new balance to caller
         SLR   R15,R15            TRKBAL rc=0
         BR    R14
*----------------------------------------------------------------------
TBCKMAX  DS    0H                 record doesn't fit, check MAXSIZE
         TM    STARFLGS,STARMAXS  MAXSIZE=YES specified?
         BNO   TBNOFIT            no, br
*
*  The record doesn't fit, but caller specified MAXSIZE=YES.
*
*  Calculate how much data will fit within track balance,
*  and return that to caller with rc=8.
*
*  Note that neither Count nor Key overhead is returned to caller
*  (in R0) although those values are considered in the calculation.
*  The value returned represents the number of bytes which the
*  caller may write in the remaining free space on the track,
*  and implicity includes 3390 overhead.
*
*  STARBAL is not updated in this instance, since the caller may
*  not think too much of our suggestion and might need a good STARBAL.
*
         S     R11,=A(10*34)      R11 = TBb - Cb
         BNP   TBNOFIT            no room for any data in TBb, br
         LR    R10,R0             R10 = Kb;CDb
         SRL   R10,16+4           R10 = Kb
         SR    R11,R10            R11 = TBb - Cb - Kb
         BNP   TBNOFIT            no room for any data in TBb, br
         S     R11,=A(9*34)       need 9 cells for D overhead
         BNP   TBNOFIT            no room for any data in TBb, br
*
*  Round the remaining Free Space (R11) down to cell boundaries,
*  in case the caller is confused and gave us a wacky TRKBAL.
*
         SLR   R10,R10
         D     R10,=F'34'         R11 = Space in cells
         M     R10,=F'34'         R11 = Space in bytes
*
*  Figure out how the remaining Free Space is partitioned between
*  Data and Overhead (OVH).  Free Space refers to the amount of
*  space in Track Balance, minus space needed for Count, Key,
*  and 6 bytes of fixed overhead for a data record.
*
*        |<----------free-space------------------------>|
*        +-----------------------------+----------+-----+
*        |      DL                     |  6 * DN  |  6  |
*        +-----------------------------+----------+-----+
*        |<------data----------------->|<---overhead--->|
*
*  Before we do anything, remove the 6 bytes of fixed overhead
*  from our consideration:
*
         S     R11,=F'6'          fixed overhead annoyance gone
         LR    R0,R11             save free space
*
         EJECT ,
*                                       DL + 6
*  We know FreeSpace = DL + 6(DN); DN = ------ + R
*                                         232
*  R is the round-up factor: 0 <= R < 1
*
*       FS
*  DN = --- + R
*       238
*
         SLR   R10,R10
         D     R10,=F'238'        FS / 238
         LTR   R10,R10            remainder?
         BZ    *+8                no, skip rounding
         LA    R11,1(,R11)        round DN up
         M     R10,=F'6'          6 * DN
*
*  DL = FS - 6DN
*
         SR    R0,R11             how's the fit now?
         BNP   TBNOFIT            no room for data in FreeSpace, br
*
         LA    R15,8              TRKBAL MAXSIZE=YES rc=8
         BR    R14                return to caller
*----------------------------------------------------------------------
TBNOFIT  DS    0H                 FUNCTN=TRBAL rec doesn't fit
         SLR   R0,R0              doesn't fit
         LA    R15,4              TRKBAL rc=4
         BR    R14                return to caller
*----------------------------------------------------------------------
NO3390   DS    0H                 no 3390s gen'd in system
         SLR   R0,R0
         LA    R15,12             TRKBAL rc=12
         BR    R14                return to caller
*----------------------------------------------------------------------
         EJECT ,
***********************************************************************
*  Data areas
***********************************************************************
         LTORG ,
*
         PRINT DATA
PATCH    DC    32S(*)
*
         AIF   ('&SYSPARM' NE 'TEST').SKIPDRV
         COPY QTRKCALC                 generate UTRK3390 test driver
.SKIPDRV ANOP
         EJECT ,
***********************************************************************
*  DSECTs
***********************************************************************
         IHADVCT2 ,               MVS38j IHADVCT macro + modulo support
         EJECT ,
STAR     DSECT ,
         TRKCALC MF=D             TRKCALC parmlist (STAR)
*
         PUSH  PRINT
         PRINT NOGEN
         CVT   DSECT=YES
         POP   PRINT
         END   ,
