         MACRO
         SGDEBCHK &DEBTSIZ=0,&DEBTINC=0
         TITLE 'IFGDEBCK                        DEB VALIDITY CHECK ROUTI
               INE'
.**********************************************************************
.*
.*             VS2 RELEASE 038 CHANGES
.*
.*$01=OZ79269,EDM1102,,FEGHA:  ABEND16E                            @01A
.*$02=OZ85799,EDM1102,,FEGHA:  ABEND16E                            @02A
.*$03=OZ96652,EDM1102,,ISGGHA: INTEGRITY AND CLEANUP               @03A
.*$04=OY02405,EDM1102,,ISGRJV: PE OZ96652 - ABEND0C4               @04A
.*
.**********************************************************************
.*
.* STATUS - NOT APPLICABLE
.*
.* FUNCTION -
.*
.*       THE SGDEBCHK MACRO WILL BE EXPANDED AT SYSGEN TO PRODUCE
.*       THE IFGDEBCK ROUTINE WHICH WILL PROVIDE DEB VALIDITY
.*       CHECKING.  (THE DESCRIPTION OF THIS ROUTINE APPEARS IN
.*       THE PROLOGUE OF THE ASSEMBLED MODULE.)
.*
.*       THE USER MAY SPECIFY TWO PARAMETERS AT SYSGEN WHICH
.*       PREVIOUSLY AFFECTED THE SIZE OF THE DEB TABLE BUT WHICH
.*       ARE NOW IGNORED: DEBTSIZE, INITIAL SIZE OF DEB TABLE
.*       (VALID VALUES: 8 - 32,760 BYTES); DEBTINCR, INCREMENTAL
.*       SIZE TO THE THE TABLE WHEN IT IS FULL (VALID VALUES:
.*       8 - 32,752 BYTES).
.*
.*       INSTEAD, IFGDEBCK ASSIGNS VALUES OF DEBTSIZE=24 AND
.*       DEBTINCR=24.
.*
.*       THE DEB VALIDITY ROUTINE WILL BE LINK EDITED INTO
.*       IEANUC01 IN SYS1.NUCLEUS AT SYSGEN PHASE III VIA
.*       GROUP III MACRO SGIEC3FB.
.*
.* ENTRY POINTS -
.*
.*       SGDEBCHK (GROUP 0 SYSGEN MACRO) IS CALLED VIA MACRO
.*       CALL FROM THE SYSGEN GROUP 0 ASSEMBLY PHASE VIA
.*       PUNCHED OUTPUT FROM THE GROUP II MACRO SGIEC2DT.
.*       THE DEB VALIDITY ROUTINE WILL BE LINK EDITED INTO
.*       IEANUC01 IN SYS1.NUCLEUS AT SYSGEN PHASE III VIA
.*       INCLUDE CARD PUNCHED FROM GROUP III MACRO SGIEC3FB.
.*
.* INPUT - NONE
.*
.* OUTPUT -
.*
.*       THIS MACRO EXPANDS AN ASSEMBLED DEB VALIDITY CHECK ROUTINE.
.*
.* EXTERNAL REFERENCES -
.*
.*       THIS MACRO CALLS THE FOLLOWING MACROS VIA MACRO CALL:
.*
.*       IECRES
.*       IECDSECS
.*       XCTLTABL
.*       DEBCHK
.*       TESTAUTH
.*       MODESET
.*       RETURN
.*       ABEND
.*
.* EXITS,NORMAL -
.*
.*       THIS MACRO EXPANDS THE DEB VALIDITY CHECK SVC ROUTINE AND
.*       DEB VALIDITY CHECK BRANCH ENTRY ROUTINE WITH AN END CARD
.*       AND THEN RETURNS TO THE ASSEMBLER VIA MEND STATEMENT.
.*
.* EXITS,ERROR - NONE
.*
.* TABLES/WORKAREAS - NONE
.*
.* ATTRIBUTES - NOT APPLICABLE
.*
.* CHARACTER CODE DEPENDENCY - NOT APPLICABLE
.*
.* NOTES -
.*
.*       ASSEMBLER XF OR COMPARABLE ASSEMBLER MUST BE USED IN
.*       CONJUNCTION WITH THIS MACRO TO ASSEMBLE 370 INSTRUCTIONS.
.*
.*       A DESCRIPTION OF THE DEB VALIDITY CHECK ROUTINE FOLLOWS
.*       IN THE PROLOGUE BELOW.
.*
.**********************************************************************
.**********************************************************************
*/*IFGDEBCK:
*/*      CHART (AMODE)                  DEB VALIDITY CHECK ROUTINE   */
         SPACE
IGC117   CSECT                                                  YM01216
         SPACE
         ENTRY IFGDEBCK
         ENTRY IFGDEBVR
IFGDEBCK EQU   *                        SECONDARY ENTRY POINT    Y02080
         SPACE
***********************************************************************
***********************************************************************
*
* STATUS - NOT APPLICABLE
*
* FUNCTION -
*
*        DEB VALIDITY CHECKING PREVENTS A USER FROM UNAUTHORIZED
*        ACCESS TO DATA ON AN EXTERNAL DEVICE AND ALLEVIATES
*        SEVERAL POSSIBILITIES OF TRANSFERRING CONTROL IN THE
*        SUPERVISOR STATE TO AN UNAUTHORIZED ROUTINE.
*
*        THE FOLLOWING FUNCTION IS PROVIDED:
*
*           1. A JOBSTEP TABLE IN PROTECTED STORAGE CONTAINING
*              POINTERS TO ALL VALID USER DEBS.
*
*           2. A METHOD BY WHICH ANY SYSTEM FUNCTION WHICH
*              CREATES A USER DEB CAN ENTER THE POINTER TO
*              THAT DEB IN THE DEB TABLE.
*
*           3. A METHOD BY WHICH ANY SYSTEM FUNCTION WHICH
*              DELETES A USER DEB CAN REMOVE THE POINTER
*              TO THAT DEB FROM THE TABLE.
*
*           4. A METHOD BY WHICH ANY FUNCTION WHICH DEPENDS
*              ON THE INTEGRITY OF THE DEB CAN VALIDATE THAT DEB.
*
*        DEB VALIDITY CHECKING IS ACCOMPLISHED VIA A DEB VALIDITY
*        CHECK ROUTINE WHICH MAINTAINS AND UPDATES A TABLE OF
*        VALID DEB POINTERS IN PROTECTED CORE (LSQA). THIS FUNCTION
*        IS PROVIDED IN ADDITION TO THE EXISTING DEB VALIDITY
*        CHECKING SCHEME.
*
*        THE DEB VALIDITY CHECK SVC ROUTINE (DEBCHK) IS
*        IMPLEMENTED IN THE NUCLEUS AS A TYPE II RESIDENT
*        REENTRANT SVC. IT IS ENTERED DISABLED USING THE DEBCHK
*        MACRO WHICH GENERATES AN SVC 117.
*
*        INITIALIZATION:
*
*        TESTAUTH IS USED TO DETERMINE IF THE CALLING ROUTINE IS
*        AUTHORIZED. IF THE CALLING ROUTINE IS AUTHORIZED, A
*        POINTER IS INITIALIZED TO A SET OF AUTHORIZED BXLE MASKS
*        WHICH WILL CONTROL PROGRAM FLOW. IF THE CALLING ROUTINE
*        IS NOT AUTHORIZED, A POINTER IS INITIALIZED TO A SET
*        OF UNAUTHORIZED BXLE MASKS WHICH WILL CONTROL PROGRAM FLOW.
*
*        TYPE FUNCTION CHECK:
*
*        THE INPUT REGISTER 0 IS VALIDITY CHECKED FOR TYPE FUNCTION
*        AND USED AS AN INDEX TO AN APPROPRIATE TYPE FUNCTION BXLE
*        MASK. IF THE TYPE FUNCTION IS NOT VERIFY (0), ADD (1),
*        DELETE (2), OR PURGE (3), THE VERIFY FUNCTION BXLE MASK
*        IS LOADED AND THE ERROR EXIT IS TAKEN. IF A VALID TYPE
*        FUNCTION IS SPECIFIED, A CHECK IS MADE TO DETERMINE IF
*        THE CALLER IS AUTHORIZED FOR THE FUNCTION (I.E. CALLER
*        MUST BE AUTHORIZED FOR TYPE: ADD, DELETE, PURGE).
*
*        DCB - DEB CHECK:
*
*        THIS ROUTINE IS BYPASSED FOR TYPE=PURGE. FOR
*        TYPE=VERIFY/ADD/DELETE, THE DEB ADDRESS IS LOADED INTO A
*        REGISTER FROM THE DCBDEBAD FIELD OF THE DCB, POINTED TO BY
*        THE INPUT REGISTER 1. THE HI-ORDER BYTE IS CLEARED AND THE
*        DCB ADDRESS IS EXTRACTED FROM THE DEBDCBAD FIELD OF THE
*        DEB. THE DCB ADDRESS PASSED IS COMPARED TO THE DCB ADDRESS
*        EXTRACTED. THE DEB ADDRESS IS LOADED INTO REGISTER 1 AND
*        IF THE DCB ADDRESSES ARE NOT EQUAL THE ERROR EXIT IS TAKEN.
*
*        ACCESS METHOD CHECK:
*
*        IF TYPE=ADD IS SPECIFIED, THE ACCESS METHOD CHECK IS
*        BYPASSED AND CONTROL IS PASSED TO THE ADD ROUTINE. IF THE
*        ACCESS METHOD VALUE (AM) IN THE HI-ORDER BYTE OF INPUT
*        REGISTER 0 IS NOT SPECIFIED (0), THE ACCESS METHOD CHECK
*        IS BYPASSED AND CONTROL IS PASSED TO THE VERIFY ROUTINE.
*        IF THE ACCESS METHOD VALUE IS SPECIFIED, THE VALUE IS
*        COMPARED TO THE ACCESS METHOD VALUE IN THE DEBAMTYP FIELD
*        IN THE DEB. IF THE VALUES ARE EQUAL, CONTROL IS PASSED TO
*        THE VERIFY ROUTINE FOR FURTHER VALIDATION. IF THE VALUES
*        ARE NOT EQUAL, CONTROL IS PASSED TO THE ERROR ROUTINE.
*
*        VERIFY:
*
*        IF NO ERRORS ARE DETECTED BY THE THE FUNCTION CHECK
*        ROUTINE, THE DCB-DEB CHECK ROUTINE, OR THE ACCESS METHOD
*        CHECK ROUTINE, CONTROL WILL BE PASSED TO THIS ROUTINE IF
*        TYPE=VERIFY/DELETE/PURGE WAS SPECIFIED. ON ENTRY, THIS
*        ROUTINE LINKS TO THE BRANCH ENTRY VERIFY ROUTINE AT THE
*        SECONDARY ENTRY POINT (IFGDEBVR) TO VERIFY THE DEB
*        POINTER IN REGISTER 1. ON NORMAL RETURN FROM THE VERIFY
*        BRANCH ENTRY ROUTINE, CONTROL IS PASSED TO THE DELETE
*        ROUTINE. ON ERROR RETURN FROM THE VERIFY BRANCH ENTRY
*        ROUTINE, THE ERROR EXIT IS TAKEN.
*
*        ADD:
*
*        THIS ROUTINE WILL GET CONTROL WHEN TYPE=ADD IS SPECIFIED.
*        A TEST IS MADE TO DETERMINE IF THE DEBAMTYP FIELD AND THE
*        DEBTBLOF FIELD OF THE DEB ARE ZERO. IF NOT ZERO, THE ERROR
*        EXIT IS TAKEN. OTHERWISE, THE DEB TABLE POINTER IS TESTED
*        TO DETERMINE IF THE DEB TABLE EXISTS. IF IT DOES NOT EXIST,
*        A NEW TABLE IS CREATED. OTHERWISE, THE EMPTY QUEUE OFFSET
*        FROM THE EXISTING DEB TABLE IS TESTED TO DETERMINE IF ANY
*        EMPTY ENTRIES EXIST IN THE TABLE. IF NO EMPTY ENTRIES
*        EXIST, A NEW TABLE IS CREATED, THE OLD TABLE IS MOVED INTO
*        THE NEW TABLE, AND THE OLD TABLE IS FREED UP. IF THE NEW
*        TABLE WOULD REQUIRE IT TO EXCEED 32760 BYTES THE ERROR EXIT
*        IS TAKEN. GETMAIN/FREEMAIN WILL ABEND THE TASK IF IT
*        ENCOUNTERS AN ERROR CONDITION. WHEN AN EMPTY ENTRY IS
*        AVAILABLE, ITS FULLWORD OFFSET FROM THE BEGINNING OF THE
*        TABLE IS PLACED INTO THE DEBTBLOF FIELD OF THE DEB, THE
*        OFFSET OF THE NEXT EMPTY ENTRY IS PLACED IN THE TABLE
*        CONTROL FIELD, AND THE VALIDATED DEB ADDRESS IS INSERTED
*        INTO THE EMPTY ENTRY. CONTROL IS THEN PASSED TO THE
*        NORMAL EXIT ROUTINE.
*
*        DELETE/PURGE:
*
*        IF TYPE=VERIFY IS SPECIFIED, THE NORMAL EXIT IS TAKEN.
*        IF TYPE=DELETE OR TYPE=PURGE IS SPECIFIED, THE VALIDATED
*        DEB POINTER IS DELETED FROM THE TABLE BY MOVING THE
*        POINTER OF THE FIRST EMPTY ENTRY FROM THE CONTROL FIELD
*        INTO THE FIRST TWO BYTES OF THE DEB TABLE ENTRY. THE
*        SECOND TWO BYTES OF THE DEB TABLE ENTRY ARE PADDED WITH
*        BINARY ONES (THIS WILL INSURE A COMPLETELY INVALID ENTRY).
*        THE OFFSET OF THE NEWLY DELETED TABLE ENTRY IS STORED
*        INTO THE CONTROL FIELD TO COMPLETE THE EMPTY ENTRY CHAIN.
*        THIS ROUTINE GIVES CONTROL TO THE NORMAL EXIT ROUTINE.
*
*        IFGDEBVR BRANCH ENTRY - VERIFY
*
*        THE IOS BRANCH ENTRY VERIFY ROUTINE IS POINTED TO BY
*        THE CVTDEBCK FIELD OF THE AOS CVT EXTENSION. THE
*        ENTRY POINT TO THE ROUTINE IS LABELED IFGDEBVR.
*        THE IOS BRANCH ENTRY VERIFY ROUTINE CONTAINS FROM FORTY NONE
*        TO FIFTY TWO INSTRUCTIONS IF COMPLETED NORMALLY.
*        IOS PASSES THE ROUTINE FIVE REGISTERS.
*        THE FUNCTION OF THE ROUTINE IS TO VERIFY THAT THE
*        DEB PASSED TO IT IS ENTERED IN THE JOBSTEP DEB TABLE
*        AT THE OFFSET INDICATED BY THE DEBTBLOF FIELD OF THE
*        DEB. IF THE VALIDATE FAILS, THE ERROR EXIT IS TAKEN
*        BY RETURNING TO AN OFFSET FOUR PAST THE RETURN REGISTER
*        14 WITH A FOUR IN REGISTER 15. IF THE POINTER TO THE
*        DEB IS ENTERED IN THE DEB TABLE THE NORMAL EXIT IS
*        TAKEN BY BRANCHING ON THE RETURN REGISTER 14 WITH A
*        ZERO IN REGISTER 15.
*        ALTHOUGH INTENDED SPECIFICALLY FOR USE BY IOS, THE VERIFY
*        BRANCH ENTRY ROUTINE CAN BE USED BY ANY ROUTINE WHICH
*        CONFORMS TO THE CALLING SEQUENCE REGISTER CONVENTIONS.
*        HOWEVER, ALL CALLERS MUST BE AWARE THAT A PROGRAM CHECK
*        COULD OCCUR AND SHOULD BE PREPARED TO HANDLE IT.
*
* ENTRY POINTS -
*
*        IN ORDER TO ADD, DELETE, OR PURGE A DEB POINTER,
*        THE CALLER OF THE DEBCHK MACRO INSTRUCTION MUST
*        BE AN AUTHORIZED FUNCTION (SUPERVISOR STATE, KEY 0,
*        OR AUTHORIZED PROGRAM).
*
*        OPEN/OPENJ
*
*        OPEN EXECUTORS (SAM/PAM/DAM/ISAM/EXCP/VSAM/GAM/BTAM/
*        VTAM/SUBSYSTEM) WILL BUILD THE DEB AND CHAIN IT TO THE
*        TCB AND DCB AND ISSUE THE DEBCHK MACRO WITH TYPE=ADD.
*        ON RETURN FROM THE DEBCHK ROUTINE, OPEN EXECUTORS
*        WILL STORE THE VALIDATED DEB ADDRESS IN THE DCBDEBAD
*        FIELD OF THE DCB.
*
*        EOV/FEOV
*
*        EOV AND FEOV WILL VERIFY THE DEB AFTER ENTRY USING:
*        DEBCHK TYPE=VERIFY, AND WILL POINT THE DEB TO THE COPIED
*        DCB UNTIL EOV/FEOV RETURNS TO THE CALLER.  IF A NEW
*        DEB IS TO BE BUILT, THE OLD DEB IS DELETED USING:
*        DEBCHK TYPE=DELETE AND A NEW DEB IS ADDED USING:
*        DEBCHK TYPE=ADD. IF A USER EXIT IS TAKEN, THE DEB NEED
*        NOT BE REVERIFIED, AS IT POINTS TO THE COPIED DCB.
*
*        AN EXCEPTION TO THE ABOVE OCCURS IN THE CASE OF
*        RECORD FORMAT VBS DATA SETS OPEN FOR UPDATE. WHEN
*        THE OLD DEB IS SAVED IN THE IOB, ITS POINTER IS NOT
*        DELETED FROM THE DEB TABLE. INSTEAD, THE LAST BIT OF
*        THE DEBDCBAD FIELD IS FLIPPED (USING AN XI INSTRUCTION)
*        SO THE DEB CAN NOT BE USED AFTER EOV. WHEN FEOV IS
*        ISSUED TO DELETE THIS DEB, IT IS DELETED USING DEBCHK
*        TYPE=DELETE. WHEN FEOV IS ISSUED TO ACTIVATE THE SAVED
*        DEB THE BRANCH ENTRY VERIFY ROUTINE POINTED TO BY THE
*        SECONDARY CVT IS USED TO INSURE THAT THE DEB SAVED IN
*        THE IOB IS STILL VALID. IF VALID, THE LAST BIT OF THE
*        DEBDCBAD FIELD IS FLIPPED AGAIN AND THE OLD DEB IS
*        DELETED USING DEBCHK TYPE=DELETE.
*
*        CLOSE:
*
*        IN ADDITION TO THE REGULAR VERIFICATION, CLOSE WILL
*        VERIFY THE DEB AFTER ENTRY USING: DEBCHK TYPE=VERIFY.
*        THE DEB IS DELETED ON RETURN FROM THE ACCESS METHOD
*        EXECUTORS USING: DEBCHK TYPE=DELETE.  IF A USER EXIT
*        IS TAKEN OR IF AN EXIT IS MADE TO DO I/O, THE DEB NEED
*        NOT BE REVERIFIED AS IT IS NO LONGER IN THE DEB TABLE.
*
*        TCLOSE:
*
*        TCLOSE WILL VERIFY THE DEB AFTER ENTRY USING: DEBCHK
*        TYPE=VERIFY, AND WILL POINT THE DEB TO THE COPIED DCB
*        UNTIL TCLOSE RETURNS TO THE CALLER.  IF A USER EXIT
*        IS TAKEN, THE DEB NEED NOT BE REVERIFIED, AS IT
*        POINTS TO THE COPIED (PROTECTED) DCB.
*
*        SAM/PAM/DAM DEB VALIDITY CHECKING
*
*        THE SVC ROUTINES LISTED WILL VALIDITY CHECK THE DEB
*        ON ENTRY USING DEBCHK TYPE=VERIFY: STOW, FREEDBUF.
*
*        ISAM DEB VALIDITY CHECKING
*
*        DISABLE SVC(IGC054) AND BISAM ASYNCHROUNOUS MODULES
*        WILL USE DEBCHK TYPE=VERIFY UPON ENTRY.
*
*        ISAM CLOSE EXECUTORS:
*
*        WHENEVER A BRANCH WILL BE TAKEN TO AN ADDRESS TAKEN
*        FROM THE DEB, DEBCHK WILL BE USED TO GET
*        ADDRESSABILITY TO THE DEB AND/OR SYNCH WILL BE USED
*        TO PASS CONTROL TO THE ADDRESS IN THE DEB.
*
*        LINK/LOAD/XCTL/ATTACH DEB VALIDITY CHECKING
*
*        LINK/LOAD/XCTL/ATTACH WILL VERIFY THE DEB ADDRESS USING
*        DEBCHK TYPE=VERIFY.
*
*        RESTART DEB VALIDITY CHECKING
*
*        AT RESTART TIME: DEBCHK TYPE=ADD WILL BE ISSUED AGAINST
*        EACH DEB REBUILT. THIS WILL ENSURE THAT EACH DEB GETS
*        ENTERED INTO THE DEB TABLE.
*
*        UTILITIES DEB VALIDITY CHECKING
*
*        IEHDASDR - IGC0008B: DEBCHK TYPE=ADD AND TYPE=DELETE
*        ARE USED TO ADD AND DELETE ITS DEB FROM THE DEB TABLE.
*
*        OLTEP - A DEB IS BUILT BY IGC0005I (SVC59) AND USED
*                BY OLTEP. DEBCHK TYPE=ADD AND TYPE=DELETE
*                ARE USED TO ADD AND DELETE THE DEB FROM THE
*                DEB TABLE.
*
*        IOS DEB VALIDITY CHECKING
*
*        IOS USES A SPECIAL BRANCH ENTRY INTERFACE INTO THE
*        DEB VALIDITY CHECK VERIFY ROUTINE TO VERIFY THE DEB
*        POINTER ASSOCIATED WITH AN EXCP OPERATION. WHEN AN
*        EXCP IS ISSUED IOS GAINS CONTROL AND DISABLES ALL
*        INTERRUPTS. A 'RING' CHECK (THE DCB POINTER IN THE
*        IOB IS COMPARED TO THE DCB POINTER IN THE DEB) AND
*        KEY 0 TEST ARE MADE ON THE DCB/DEB POINTERS AS AN
*        INITIAL VALIDITY CHECK OF THE CONTROL BLOCKS. THEN
*        BEFORE SIO IS ISSUED, THE FINAL VALIDITY CHECK IS
*        MADE USING THE DEB VALIDITY CHECK VERIFY BRANCH
*        ENTRY WITH THE FOLLOWING CALLING SEQUENCE:
*
*              TEST FOR EXCP ISSUED FROM KEY 0 ROUTINE:
*              BZ   CONTINUE         IF KEY ZERO, AVOID DEBCHK
*              LR   R10,RTCB         RQE'S TCB IN REGISTER 10
*              LR   R1,RDEB          DEB POINTER IN REGISTER 1
*              L    R15,=V(IFGDEBVR) ENTRY POINT IN REGISTER 15
*              BALR R14,R15          LINK TO DEBCHK VERIFY
*              B    CONTINUE         NORMAL RETURN (REG 15 = 0)
*              B    ERROR            INVALID DEB (REG 15 = 4)
*
*
*        VSAM SUBTASK DEB VALIDITY CHECKING
*
*        VSAM DATA SETS ALWAYS CHAIN THEIR DEB OFF THE 'MOTHER' TCB.
*        WHEN SUBTASKING, AND THE 'JSCB=' PARM IS, USED THE DEB
*        POINTER FOR THE SUBTASK WILL BE CHAINED OFF THIS 'MOTHER' TCB,
*        NOT THE 'CURRENT' TCB. IN THE DEBCHK VERIFY ROUTINE, WE
*        SEARCH THE DEBTABLE OFF THE CURRENT TCB FOR THE
*        DEB POINTER. IF THE POINTER IS NOT FOUND,
*        WE WILL SEE IF THERE IS A MOTHER TCB.
*        IF THERE IS, WE WILL SEARCH THE DEB TABLE OFF THIS TCB
*        FOR THE POINTER. IF NOT FOUND, WE WILL RETURN WITH RC4.
*
*
*        ABEND/STAE DEB VALIDITY CHECKING
*
*        DURING ABEND/STAE PROCESSING, EACH OPEN DATA SET
*        ASSOCIATED WITH A TASK IS CLOSED. IF CLOSE ABENDS,
*        A RECURSIVE ABEND SITUATION DEVELOPS. TO ALLEVIATE
*        THIS PROBLEM, ABEND WILL PURGE THE DEB FROM THE DEB
*        TABLE AND THEN UNCHAIN IT FROM THE TCB. ABEND WILL
*        PASS THE DEB ADDRESS TO DEBCHK TYPE=PURGE. ON
*        NORMAL RETURN REGISTER 15 IS SET TO ZERO.  IF AN
*        ERROR CONDITION IS ENCOUNTERED CONTROL WILL BE
*        RETURNED TO ABEND/STAE WITH A NON-ZERO RETURN
*        CODE IN REGISTER 15 (SEE RETURN CODES UNDER
*        DESCRIPTION OF EXITS,ERROR). DEBCHK WITH THE
*        DELETE OPTION SPECIFIED IS NOT USED FOR TWO
*        REASONS:
*
*              1. THE DCB POINTED TO BY THE DEB MAY HAVE
*                 HAD ITS DCBDEBAD FIELD OVERLAID, THUS
*                 PREVENTING DEBCHK FROM OBTAINING THE DEB
*                 ADDRESS AND CAUSING EITHER A PROGRAM CHECK
*                 OR A 16E ABEND, EITHER OF WHICH IS A
*                 RECURSIVE ABEND SITUATION.
*
*              2. FOR REASONS OTHER THAN ABOVE DEBCHK MAY
*                 ABEND WITH A 16E COMPLETION CODE CAUSING
*                 ANOTHER RECURSIVE ABEND SITUATION.
*
* INPUT -
*
*        IFGDEBCK SVC ROUTINE
*
*        REGISTER 0: BITS 0-7: ACCESS METHOD VALUE: ISAM   = X'80'
*                                                   BDAM   = X'40'
*                                                   SAM    = X'20'
*                                                   BPAM   = X'20'
*                                                   TAM    = X'10'
*                                                   GAM    = X'08'
*                                                   TCAM   = X'04'
*                                                   EXCP   = X'02'
*                                                   VSAM   = X'01'
*                                                   SUBSYS = X'81'
*                                                   VTAM   = X'82'
*                                                   TCAMAP = X'84'
*                                                   NONE   = X'00'
*                    BITS 8-31: TYPE FUNCTION CODE: VERIFY = 0
*                                                   ADD    = 1
*                                                   DELETE = 2
*                                                   PURGE  = 3
*        REGISTER 1: BITS 0-7: X'00'
*                    BITS 8-31: DCB POINTER IF TYPE NOT PURGE
*                               DEB POINTER IF TYPE=PURGE
*        REGISTER 3: CVT POINTER (INITIALIZED BY SVC HANDLER)
*        REGISTER 4: TCB POINTER (INITIALIZED BY SVC HANDLER)
*        REGISTER 5: RB  POINTER (INITIALIZED BY SVC HANDLER)
*
*        IFGDEBVR BRANCH ENTRY VERIFY ROUTINE
*
*        REGISTER  1 CONTAINS A DEB POINTER (HI BYTE = 0).
*        REGISTER 10 CONTAINS THE TCB ADDRESS FROM THE RQE
*        REGISTER 11 CONTAINS NOTHING TO BE SAVED.
*        REGISTER 14 CONTAINS THE RETURN ADDRESS OF A BRANCH TABLE.
*        REGISTER 15 CONTAINS THE ENTRY POINT TO DEBCHK VERIFY.
*
* OUTPUT -
*
*        ON NORMAL EXIT FROM THE IFGDEBCK SVC ROUTINE:
*
*        RETURN (BR 14) TO EXIT PROLOGUE
*
*        REGISTER  0: UNRELIABLE
*        REGISTER  1: BITS 0-7: X'00'
*                     BITS 8-31: DEB POINTER
*        REGISTER 15: BITS 0-31: X'00'
*        REGISTERS 2 - 14: RESTORED
*
*        ON ERROR EXIT FROM THE IFGDEBCK SVC ROUTINE:  -  ABEND 16E
*
*        REGISTER  0: UNRELIABLE
*        REGISTER  1: UNRELIABLE
*        REGISTER 15: RETURN CODE - SEE ERROR EXIT
*        REGISTERS 2 - 14: RESTORED
*
*        ON NORMAL EXIT FROM THE IFGDEBVR
*        BRANCH ENTRY VERIFY ROUTINE  -   RETURN (BR 14)
*
*        REGISTER  1 CONTAINS A VERIFIED DEB POINTER.
*        REGISTER 10 CONTAINS THE DEB TABLE POINTER.
*        REGISTER 11 CONTAINS THE DEB TABLE OFFSET.
*        REGISTER 14 CONTAINS THE RETURN ADDRESS.
*        REGISTER 15 CONTAINS ZERO (0).
*        REGISTERS 0-9 AND 12-14 REMAIN UNCHANGED.
*
*        ON ERROR EXIT FROM THE IFGDEBVR
*        BRANCH ENTRY VERIFY ROUTINE  -   B   0(R15,R14)
*
*        REGISTER  1 CONTAINS AN INVALID DEB POINTER.
*        REGISTER 10 UNRELIABLE
*        REGISTER 11 UNRELIABLE
*        REGISTER 14 CONTAINS THE RETURN ADDRESS.
*        REGISTER 15 CONTAINS FOUR (4).
*        REGISTERS 0-9 AND 12-14 REMAIN UNCHANGED.
*
* EXTERNAL REFERENCES -
*
*        CVT:
*              CVTDEBCK - BRANCH ENTRY POINT TO DEBCHK VERIFY
*              CVTEXPRO - BRANCH ENTRY TO PROLOGUE
*              CVTDMSR  - BRANCH ENTRY TO IFG019RA TO GET/FREE CORE
*        TCB:
*              TCBJSCB  - POINTER TO JSCB
*        SVRB:
*              RBEXSAVE - SAVE AREA FOR 12 REGISTERS
*        JSCB:
*              JSCBDBTB - POINTER TO DEBCHK DEB TABLE (SUBPOOL 254)
*        DEB:
*              DEBAMTYP - ACCESS METHOD VALUE AS SPECIFIED
*                         BY AM= WITH DEBCHK TYPE=ADD
*              DEBTBLOF - HALFWORD OFFSET TO PROTECTED
*                         DEB POINTER IN THE DEB TABLE
*
* EXITS,NORMAL -
*
*        REGISTER 15 IS SET TO 0 AND EXIT IS INVOKED (RETURN - BR 14).
*
* EXITS,ERROR -
*
*        IFGDEBCK - SVC ROUTINE ERROR EXIT
*
*        REGISTER 15 IS LOADED WITH AN ERROR CODE INDICATING
*        THE CAUSE OF THE ERROR AND:
*
*              - IF THE CALLER IS AUTHORIZED AND TYPE=ADD,
*                DELETE, OR VERIFY IS SPECIFIED, ABEND IS
*                INVOKED WITH A 16E COMPLETION CODE.
*
*              - IF THE CALLER IS NOT AUTHORIZED, OR IF
*                TYPE=PURGE IS SPECIFIED, EXIT IS INVOKED,
*                RETURN (BR 14) TO EXIT PROLOGUE, R15 = CODE.
*
*        THE ERROR CONDITIONS AND THE ERROR RETURN CODES PASSED
*        IN REGISTER 15 ARE:
*
*               4 IFGDEBVR RETURNED WITH REGISTER 15 = 4
*               8 INVALID TYPE SPECIFIED (MACRO NOT USED)
*              12 CALLER NOT AUTHORIZED: TYPE NOT VERIFY
*              16 DEBDCBAD DOES NOT POINT TO DCB PASSED
*              20 AM VALUE DOES NOT EQUAL DEBAMTYP VALUE
*              24 DEB NOT ON TCB CHAIN FOR TYPE=ADD
*              28 DEBAMTYP OR DEBTBLOF NOT 0 FOR TYPE=ADD
*              32 DEB TABLE CONTAINS 32760 BYTES AND TYPE=ADD
*
*        IFGDEBVR - VERIFY BRANCH ENTRY ERROR EXIT
*
*        IF AN ERROR CONDITION IS DETECTED BY THE BRANCH
*        ENTRY ROUTINE, CONTROL IS RETURNED TO AN OFFSET FOUR
*        PAST THE RETURN REGISTER 14 WITH A FOUR IN REGISTER 15.
*        THE ERROR CONDITIONS WHICH CAUSE AN ERROR EXIT ARE:
*
*              1. THE JOBSTEP DEB TABLE DOES NOT EXIST.
*              2. A ZERO OR NEGATIVE DEBTBLOF FIELD IN THE DEB.
*              3. DEBTBLOF IS LARGER THAN THE DEB TABLE.
*              4. THE DEB POINTER AND DEB TABLE ENTRY ARE NOT EQUAL.
*
*        IF THE CALLER IS NOT AUTHORIZED, THE MODESET MACRO WILL
*        RESULT IN AN ABEND.
*
* TABLES/WORKAREAS -
*
*        THE DEB TABLE IS MAINTAINED AND UPDATED BY THE DEB
*        VALIDITY CHECK ROUTINE. THERE WILL BE ONE DEB TABLE
*        FOR EACH JOBSTEP TCB IN THE SYSTEM WITH AT LEAST ONE
*        OPEN DATA SET (OLTEP AND DASDR EXCEPTED). THE DEB
*        TABLE IS POINTED TO BY THE JSCBDBTB FIELD OF THE JSCB.
*        IT IS FIRST CREATED WHEN THE FIRST DEBCHK TYPE=ADD IS
*        ISSUED BY THE JOBSTEP IN SUBPOOL 255 (KEY 5),
*        USUALLY WHEN THE FIRST OPEN IS ISSUED (OLTEP AND
*        DASDR EXCEPTED). THE SPACE IS RETURNED TO THE SYSTEM
*        BY THE DATA RESOURCE MANAGER AT TASK TERMINATION.
*        WHEN THE DEB TABLE BECOMES FULL AND ANOTHER ENTRY IS
*        REQUESTED, A NEW LARGER TABLE IS OBTAINED, THE OLD TABLE
*        IS MOVED INTO THE NEW TABLE (THE UNUSED ENTRIES ARE
*        ZEROED OUT), THE OLD TABLE IS FREED, AND THE JSCBDBTB
*        FIELD OF THE JSCB IS UPDATED TO POINT TO THE NEW TABLE.
*              NOTE: WHEN A NEW DEB TABLE IS CREATED, THE OLD
*              DEB TABLE IS NOT FREED UNTIL ITS ENTRIES ARE
*              TRANSFERRED TO THE NEW DEB TABLE.
*        THE DEB TABLE MAY GROW IN SIZE UNTIL IT REACHES A
*        MAXIMUM OF 32760 BYTES. ACTUALLY IT MAY REACH 32792
*        BYTES, HOWEVER, THE EXTRA 32 BYTES ARE FOR IDENTIFICATION
*        PURPOSES AND ARE OTHERWISE IGNORED. THE DEB TABLE
*        CONSISTS OF CONSECUTIVE FOUR BYTE ENTRIES:
*
*        CONTROL FIELD:
*              THE FIRST FOUR BYTES OF THE DEB TABLE ARE
*              RESERVED FOR THE CONTROL FIELD (I.E. 0 IS
*              AN INVALID OFFSET): THE FIRST TWO BYTES
*              INDICATES THE LENGTH IN BYTES OF THE TABLE.
*              THE SECOND TWO BYTES IS A BYTE OFFSET TO
*              THE FIRST EMPTY ENTRY.
*
*        DEB TABLE ENTRY:
*              A DEB TABLE ENTRY IS EITHER AN EMPTY ENTRY
*              OR IT CONTAINS A DEB POINTER WITH THE
*              HI-ORDER BYTE SET TO ZERO.
*
*        DEB TABLE EMPTY ENTRY:
*              AN EMPTY ENTRY IS EITHER FOUR BYTES OF BINARY
*              ZEROS (USED IF THE ENTRIES ARE AT THE END OF
*              THE TABLE AND HAVE NEVER BEEN USED) OR 1) THE
*              FIRST TWO BYTES ARE A BYTE OFFSET TO THE NEXT
*              EMPTY ENTRY (ZERO IF IT'S THE LAST) 2) THE
*              SECOND TWO BYTES ARE BINARY ONES (USED IF THE
*              ENTRY WAS PREVIOUSLY DELETED).
*
*        THE INITIAL SIZE OF THE DEB TABLE IS 80 DECIMAL BYTES.
*
*        THE 48 BYTES OF THE RBEXSAVE FIELD OF THE SVRB ARE USED
*        AS A SAVE AREA FOR REGISTERS.
*
* ATTRIBUTES -
*
*        TYPE II SVC
*        RE-ENTRANT
*        DISABLED (LOCAL LOCK)
*        RESIDENT
*        SUPERVISOR STATE
*        KEY 0 AND KEY 5
*
* CHARACTER CODE DEPENDENCY - NOT APPLICABLE
*
* NOTES -
*
*        ISAM APPENDAGES
*
*        ISAM APPENDAGES GET THE DEB ADDRESS FROM THE RQE.
*
*        CHECKPOINT/RESTART DEB VALIDITY CHECKING
*
*        AT CHECKPOINT TIME A MODESET WILL BE ISSUED TO
*        ASSUME THE PROTECT KEY OF THE CALLER WHEN I/O IS
*        PERFORMED AGAINST THE CHECKPOINT DCB. THIS WILL
*        ENSURE THAT IOS WILL ISSUE A DEBCHK AGAINST THE
*        USER'S DEB WHEN EXCP IS ISSUED.
*
*        UTILITIES DEB VALIDITY CHECKING
*
*        IEHDASDR - WILL BE PROTECTED FROM UNAUTHORIZED
*                   ROUTINES BY THE APF FACILITY.
*        IEHATLAS - DEB VALIDITY CHECKING IS NOT BE REQUIRED
*                   FOR ATLAS SVC86 BECAUSE EXECUTES IN
*                   SUPERVISOR STATE AND IS ISOLATED FROM
*                   USER MODIFICATION.
*        OLTEP IGC0005I - WILL BE PROTECTED FROM
*                         UNAUTHORIZED ROUTINES
*                         BY THE APF FACILITY.
*
*        SCHEDULER INITIATOR SUPPORT FOR DEB VALIDITY CHECKING
*
*        IN SUPPORT OF DATA SETS OPENED BY THE INITIATOR WHICH
*        ARE TO BE AVAILABLE TO THE PROBLEM PROGRAM (I.E. JOBLIB,
*        STEPLIB, *.PGM), THE INITIATOR WILL BUILD A NEW JSCB
*        EACH TIME A TASK IS INITIATED TO AVOID REUSING AN OLD
*        DEBTABLE FREED AT TASK TERMINATION INSTEAD OF VIA
*        THE DATA RESOURCE MANAGER.
*
*        ATTACH SUPPORT FOR DEB VALIDITY CHECKING
*
*        ANY ROUTINE USING THE ATTACH JSTCB=YES FUNCTION MUST
*        FOLLOW THE FOLLOWING CONVENTION IN SUPPORT OF DEB
*        VALIDITY CHECKING:
*
*              A SEPARATE JSCB MUST BE CREATED FOR THE NEW
*              TASK (I.E. THE JSCB FOR THE NEW TASK MAY NOT
*              BE DEFAULTED.). THE JSCBDBTB FIELD OF THE
*              CREATED JSCB MUST BE SET TO ZERO. IF THE
*              MOTHER TASK EXPECTS TO SHARE DCBS WITH THE
*              DAUGHTER TASK.
*
***********************************************************************
***********************************************************************
         EJECT
***********************************************************************
*              REGISTER ASSIGNMENTS
***********************************************************************
         SPACE
R0       EQU   0                        REGISTER 0
R1       EQU   1                        REGISTER 1
R2       EQU   2                        REGISTER 2
R3       EQU   3                        REGISTER 3
R4       EQU   4                        REGISTER 4
R5       EQU   5                        REGISTER 5
R6       EQU   6                        REGISTER 6
R7       EQU   7                        REGISTER 7
R8       EQU   8                        REGISTER 8
R9       EQU   9                        REGISTER 9
RA       EQU   10                       REGISTER A
RB       EQU   11                       REGISTER B
RC       EQU   12                       REGISTER C
RD       EQU   13                       REGISTER D
RE       EQU   14                       REGISTER E
RF       EQU   15                       REGISTER F
         SPACE
***********************************************************************
*              SYMBOLIC REGISTER ASSIGNMENTS
***********************************************************************
         SPACE
RI0      EQU   R0                       INPUT REGISTER (TYPE-FUNCTION)
RI1      EQU   R1                       INPUT REGISTER (DCB-DEB)
RCVT     EQU   R3                       CVT POINTER
RTCB     EQU   R4                       CURRENT TCB POINTER
RSVRB    EQU   R5                       SVRB POINTER
RNOTUSED EQU   R6                       UNUSED REGISTER
RBXLE    EQU   R7                       BXLE MASK REGISTER
RNEW     EQU   R8                       NEW DEB TABLE POINTER
RNEWLGTH EQU   R9                       NEW DEB TABLE LENGTH
RTABLE   EQU   RA                       CURRENT DEB TABLE POINTER
ROFFSET  EQU   RB                       OFFSET TO DEB TABLE ENTRY
RW1      EQU   RC                       WORK REGISTER ONE
RW2      EQU   R2                       WORK REGISTER TWO
RBASE    EQU   RD                       BASE REGISTER
RETURN   EQU   RE                       RETURN REGISTER
R15      EQU   RF                       ENTRY POINT REGISTER
RETCODE  EQU   RF                       RETURN CODE REGISTER
         SPACE
***********************************************************************
*              EQUATED CONSTANTS
***********************************************************************
         SPACE
K0       EQU   0                        ZERO
K1       EQU   1                        ONE
K2       EQU   2                        TWO
K3       EQU   3                        THREE
K4       EQU   4                        FOUR
K8       EQU   8                        EIGHT
K32      EQU   32                       THITRY TWO               Y02080
M7       EQU   7                        MASK SEVEN
M8       EQU   8                        MASK EIGHT
SP255    EQU   255                      DEB TABLE SUBPOOL ID     Y02080
XFF      EQU   X'FF'                    FLAG
KEY0     EQU   0                        KEY OF DEBTABLE          Y02080
         SPACE
***********************************************************************
*              EQUATED ERROR CONDITIONS
***********************************************************************
         SPACE
ERRORV   EQU   4                        ERROR RETURN FROM VERIFY
ERROR1   EQU   8                        INVALID FUNCTION REQUESTED
ERROR2   EQU   12                       UNAUTHORIZED FUNCTION REQUESTED
ERROR3   EQU   16                       INVALID DCB-DEB POINTERS
ERROR4   EQU   20                       DEBAMTYP NOT EQUAL TO AM
ERROR5   EQU   24                       ASYNCHRONOUS DCB MODIFICATION
ERROR6   EQU   28                       DEBAMTYP OR DEBTBLOF NOT 0
ERROR7   EQU   32                       DEB TABLE HAS EXCEEDED 32760
         SPACE
***********************************************************************
         EJECT
***********************************************************************
*/*
*/*      COMMENT (2,2,H)                INITIALIZATION ROUTINE
*/*                                                                  */
***********************************************************************
         SPACE
*/*DCK00000:
*/*      E                              INITIALIZATION
*/*                                                                  */
         SPACE
DCK00000 BALR  RBASE,R0                 ESTABLISH BASE ADDRESS AT ENTRY
         USING *,RBASE                  ESTABLISH ADDRESSABILITY
         B     DCK00001                 GO AROUND ID           @ZA31908
         DC    CL8'IFGDEBCK'            ID                     @ZA31908
         DC    CL8'@ZA47942'            LAST CHANGE ACTIVITY   @ZA47942
         DC    CL8'09/26/80'            LAST CHANGE DATE       @ZA47942
DCK00001 DS    0H                                              @ZA31908
         LA    RI1,K0(R0,RI1)           CLEAR HI-ORDER BYTE OF R1
         SPACE
*/*
*/*      M                              INITIALIZE BXLE MASK TO
*/*                                     AUTHORIZED BXLE MASK        */
         SPACE
         LA    RBXLE,BXLEMSKS           AUTHORIZED MASKS         Y02080
         SPACE
*/*
*/*      S     (YES,,NO,%DCK0100)       TESTAUTH: IS CALLER
*/*                                     AUTHORIZED? */           Y02080
         SPACE
         USING RBSECT,RSVRB             RSVRB POINTS TO SVRB     Y02080
         STM   RA,R5,RBEXSAVE           SAVE REGS 10-5           Y02080
*        TESTAUTH FCTN=1,STATE=YES,KEY=YES,BRANCH=YES            Y02080
         TESTAUTH FCTN=1,STATE=YES,KEY=YES,BRANCH=YES            Y02080
         LM    RA,RE,RBEXSAVE           RESTORE REGS 10-14     @ZA02852
         LM    R0,R5,RBEXSAVE+24        RESTORE REGS 0-5       @ZA02852
         DROP  RSVRB                                             Y02080
         LTR   RF,RF                    TEST RETURN CODE       @ZA02852
         BZ    DCK00100                 BRANCH IF AUTHORIZED     Y02080
         SPACE
*/*
*/*      M                              INITIALIZE BXLE MASK TO
*/*                                     UNAUTHORIZED BXLE MASK       */
         SPACE
         LA    RBXLE,BXLEMSKP           UNAUTHORIZED MASKS       Y02080
         EJECT
***********************************************************************
*/*%DCK0100:
*/*      N                              FUNCTION CHECK ROUTINE
*/*                                                                  */
***********************************************************************
         SPACE
*/*DCK00100:
*/*      M                              LOAD BXLE MASK FOR ERROR EXIT
*/*                                     ROUTINE                      */
         SPACE
DCK00100 ICM   RBASE,M8,K0(RBXLE)       SET UP EXIT ROUTINE MASKS
         SPACE
*/*
*/*      D     (YES,,NO,%DCK1000)       VALID TYPE SPECIFIED? (0-1-2-3)
*/*                                                                  */
         SPACE
         CLM   RI0,M7,THREE             TEST FOR VALID TYPE (0-1-2-3)
         LA    RETCODE,ERROR1           ERROR CODE FOR INVALID FUNCTION
         BH    DCK01000                 BRANCH IF INPUT INVALID
         SPACE
*/*
*/*      M                              LOAD BXLE FUNCTION MASK
*/*                                                                  */
         SPACE
         ALR   RBXLE,RI0                INCREMENT TO FUNCTION TYPE MASK
         ICM   RBASE,M8,K0(RBXLE)       SAVE BXLE MASK FOR EXIT
         LR    RBXLE,RBASE              LOAD BXLE FUNCTION MASK
         SPACE
*/*
*/*      D     (YES,,NO,%DCK1000)       CALLER AUTHORIZED FOR TYPE
*/*                                     SPECIFIED ?                  */
         SPACE
         LA    RETCODE,ERROR2           ERROR CODE FOR UNAUTH FUNCTION
         BXLE  RBXLE,RBXLE,DCK01000     BRANCH IF UNAUTHORIZED TYPE
         EJECT
***********************************************************************
*/*
*/*      N                              DCB - DEB VALIDITY CHECK
*/*                                     ROUTINE                      */
***********************************************************************
         SPACE
*/*
*/*      D     (NO,,YES,%DCK0200)       TYPE=PURGE SPECIFIED?
*/*                                                                  */
         SPACE
         BXLE  RBXLE,RBXLE,DCK00200     BRANCH FOR TYPE=PURGE
         SPACE
*/*
*/*      D     (YES,,NO,%DCK1000)       VALID DCB-DEB POINTERS?
*/*                                                                  */
         SPACE
DCK00110 EQU   *                        DCB-DEB VALIDITY CHECK         C
                                        ROUTINE                 YM01224
         USING TCB,RTCB                 ESTABLISH TCB          @ZA31908
         CLM   RI0,M7,DBCHKADD    IS THIS AN ADD REQUEST?      @ZA47942
         BE    DCK00120           YES,STAY IN KEY ZERO         @ZA47942
         L     RW2,TCBJSCB        ADDRESS THE JSCB             @ZA47942
         USING IEZJSCB,RW2                                     @ZA47942
         TM    JSCBOPTS,JSCBAUTH  IS USER AUTHORIZED?          @ZA47942
         BO    DCK00120           YES, BRANCH                  @ZA47942
         DROP  RW2                                             @ZA47942
         CLI   TCBPKF,X'80'       IS USER IN A SUPVR KEY?      @ZA47942
         BL    DCK00120           YES,BRANCH                   @ZA47942
*        MODESET EXTKEY=TCB,WORKREG=2       USE USER KEY       @ZA31908
         MODESET EXTKEY=TCB,WORKREG=2       USE USER KEY       @ZA31908
DCK00120 DS    0H                                              @ZA47942
         USING IHADCB,RI1               RI1 PTS TO DCB AT ENTRY@ZA38025
         L     RW1,DCBDEBAD             LOAD POINTER TO DEB    @ZA38025
         DROP  RI1                                             @ZA38025
         USING DEBBASIC,RW1             RW1 POINTS TO DEB
*                                       *                      @ZA31908
         L     RW2,DEBDCBAD             LOAD POINTER TO DCB
*        MODESET EXTKEY=SUPR            CHANGE BACK TO OUR KEY @ZA31908
         MODESET EXTKEY=SUPR            CHANGE BACK TO OUR KEY @ZA31908
         LA    RW2,K0(R0,RW2)           CLEAR HI-ORDER BYTE FOR COMPARE
         CR    RI1,RW2                  VALIDITY CHECK DCB-DEB POINTERS
         LA    RI1,DEBBASIC             RI1=DEB POINTER AT ANY EXIT
         DROP  RW1
         LA    RETCODE,ERROR3           ERROR CODE FOR INVALID DCB-DEB
         BNE   DCK01000                 BRANCH IF BAD DCB-DEB POINTERS
         EJECT
***********************************************************************
*/*%DCK0200:
*/*      N                              ACCESS METHOD VALIDITY CHECK
*/*                                     ROUTINE                      */
***********************************************************************
         SPACE
*/*DCK00200:
*/*      D     (NO,,YES,%DCK0400)       IS TYPE=ADD SPECIFIED?
*/*                                                                  */
         SPACE
DCK00200 BXLE  RBXLE,RBXLE,DCK00400     BRANCH IF TYPE=ADD
         SPACE
*/*
*/*      D     (YES,,NO,%DCK0300)       IS AM SPECIFIED?
*/*                                                                  */
         SPACE
         CLM   RI0,M8,ZERO              CHECK ACCESS METHOD SPECIFIED
         BZ    DCK00300                 BRANCH IF NOT SPECIFIED
         SPACE
*/*
*/*      D     (YES,,NO,%DCK1000)       IS AM VALUE = DEBAMTYP VALUE?
*/*                                                                  */
         SPACE
DCK00210 EQU   *                        AM VALIDITY CHK ROUTINE YM01224
         LA    RW1,DEBBASIC-DEBAMTYP    LOAD NEGATIVE OFFSET
         SR    RI1,RW1                  DECREMENT TO NEGATIVE OFFSET
         USING DEBAMTYP,RI1             RI1 POINTS TO DEB - 3
         L     RW2,TCBJSCB        ADDRESS THE JSCB             @ZA47942
         USING IEZJSCB,RW2                                     @ZA47942
         TM    JSCBOPTS,JSCBAUTH  IS USER AUTHORIZED?          @ZA47942
         BO    DCK00220           YES, BRANCH                  @ZA47942
         DROP  RW2                                             @ZA47942
         CLI   TCBPKF,X'80'       IS USER IN A SUPVR KEY?      @ZA47942
         BL    DCK00220           YES,BRANCH                   @ZA47942
*        MODESET EXTKEY=TCB,WORKREG=2      USE USER KEY        @ZA31908
         MODESET EXTKEY=TCB,WORKREG=2      USE USER KEY        @ZA31908
DCK00220 DS    0H                                              @ZA47942
         CLM   RI0,M8,DEBAMTYP          TEST ACCESS METHOD TYPE
*        MODESET EXTKEY=SUPR            GO BACK TO OUR KEY     @ZA31908
         MODESET EXTKEY=SUPR            GO BACK TO OUR KEY     @ZA31908
         DROP  RTCB                                            @ZA31908
         LA    RI1,DEBBASIC             INCREMENT TO NORMAL DEB POINTER
         DROP  RI1
         LA    RETCODE,ERROR4           ERROR CODE FOR INVALID AM
         BNE   DCK01000                 BRANCH IF INVALID ACCESS METHOD
         EJECT
***********************************************************************
*/*%DCK0300:
*/*      N                              DEB VALIDITY CHECK ROUTINE
*/*                                                                  */
***********************************************************************
         SPACE
*/*DCK00300:
*/*      S     (GOOD,%DCK0500,BAD,)     IFGDEBVR: DEB VALIDITY CHECK
*/*                                     BRANCH ENTRY                 */
         SPACE
DCK00300 EQU   *                        VALIDATE DEB ADDRESS
         LR    RTABLE,RTCB              LOAD TCB POINTER         Y02080
         LA    R15,IFGDEBVR             LOAD POINTER TO VERIFY ROUTINE
         BALR  RETURN,R15               LINK TO VALIDATE DEB
         B     DCK00500                 VALIDITY CHECK NORMAL RETURN
         B     DCK01000                 VALIDITY CHECK ERROR RETURN
         EJECT
***********************************************************************
*/*%DCK0400:
*/*      N                              DEB VALIDITY CHECK ADD ROUTINE
*/*                                                                  */
***********************************************************************
         SPACE
*/*DCK00400:
*/*      D     (NO,,YES,%DCK1000)       WAS THE DEB ADDRESS MODIFIED ?
*/*                                                                  */
         SPACE
DCK00400 EQU   *                        ADD DEB TO TABLE
         SPACE
         LA    RETCODE,ERROR5           ERROR CODE FOR ASYNCHRONOUS
*                                       MODIFICATION
         USING TCB,RTCB                 RTCB POINTS TO TCB
DCK00402 L     RW1,TCBDEB               LOAD POINTER TO CHAIN OF DEBS
         DROP  RTCB
         SPACE
         USING DEBBASIC,RW1             RW1 POINTS TO DEB
DCK00403 LA    RW1,DEBBASIC             CLEAR HI-ORDER BYTE
         CR    RI1,RW1                  CHECK FOR DEB ON TCB CHAIN
         BE    DCK00406                 BRANCH IF DEB ON CHAIN
         C     RW1,ZERO                 TEST FOR END OF CHAIN
         BE    DCK00404                 BRANCH IF DEB NOT FOUND  Y02080
         L     RW1,DEBDEBAD             LOAD POINTER TO NEXT ON CHAIN
         DROP  RW1
         B     DCK00403                 BRANCH TO CHECK NEXT DEB
         SPACE 1                                                 Y02080
DCK00404 CLM   RI0,M8,VSAM              CHECK FOR VSAM           Y02080
         BNE   DCK01000                 BRANCH IF NOT VSAM       Y02080
         SPACE 1                                                 Y02080
         USING TCB,RTCB                 RTCB POINTS TO TCB       Y02080
         CLM   RTCB,M7,TCBJSTCB+1       TEST FOR JOBSTEP TCB     Y02080
         BE    DCK01000                 BRANCH IF JOBSTEP TCB    Y02080
         L     RTCB,TCBJSTCB            LOAD JOBSTEP TCB POINTER Y02080
         B     DCK00402                 BRANCH, CHK JOBSTEP TCB  Y02080
         DROP  RTCB                                              Y02080
         SPACE
*/*DCK00406:
*/*      D     (YES,,NO,%DCK1000)       IS DEBAMTYP OR DEBTBLOF VALUE 0
*/*                                     ?                            */
         SPACE
DCK00406 LA    RW1,DEBBASIC-DEBAMTYP    LOAD NEGATIVE DEB OFFSET
         SR    RI1,RW1                  CALCULATE NEGATIVE OFFSET
         USING DEBAMTYP,RI1             RI1 POINTS TO DEB
         CLC   DEBAMTYP(3),ZERO         TEST FOR PREVIOUS ACCESS METHOD
         LA    RETCODE,ERROR6           ERROR CODE FOR NON-ZERO FIELDS
         BNZ   DCK01000                 BRANCH IF NOT ZERO
         SPACE
*/*
*/*      D     (YES,,NO,DCK00440)       DOES A DEB TABLE EXIST?
*/*                                                                  */
         SPACE
         USING TCB,RTCB                 RTCB POINTS TO TCB       Y02080
         L     RTABLE,TCBJSCB           LOAD TASK JSCB POINTER   Y02080
         DROP  RTCB                                              Y02080
         USING IEZJSCB,RTABLE           RTABLE POINTS TO JSCB
         L     RTABLE,JSCBDBTB          LOAD DEBTABLE POINTER
         DROP  RTABLE
         LTR   RTABLE,RTABLE            TEST FOR EXISTING DEB TABLE
         BZ    DCK00440                 BRANCH IF NONE EXISTS
         SPACE
*/*
*/*      D     (YES,,NO,DCK00450)       ARE ANY EMPTY ENTRIES IN DEB
*/*                                     TABLE?                       */
         SPACE
         USING DEBTABLE,RTABLE          RTABLE POINTS TO DEB TABLE
         LH    ROFFSET,TABLEQUE         LOAD EMPTY QUE OFFSET
         LTR   ROFFSET,ROFFSET          TEST FOR NO EMPTY ENTRIES
         BZ    DCK00450                 BRANCH IF NO EMPTY ENTRIES
         SPACE
*/*DCK00410:
*/*      P                              STORE FULLWORD OFFSET OF EMPTY
*/*                                     ENTRY IN DEBTBLOF FIELD      */
         SPACE
DCK00410 SRL   ROFFSET,K2               SHIFT TO FULLWORD OFFSET
         STH   ROFFSET,DEBTBLOF         SAVE TABLE OFFSET IN DEB
         SPACE
*/*
*/*      P                              STORE AM VALUE IN DEBAMTYP
*/*                                     FIELD OF DEB                 */
         SPACE
         STCM  RI0,M8,DEBAMTYP          STORE AM VALUE IN DEB
         OI    DEBFLGS1,X'10'           SET DEBEXCPA ON        @ZA20762
         CLM   RI0,M8,VSAM              TEST FOR VSAM          @ZA20762
         BE    DCK00412                 BRANCH IF AM IS VSAM   @ZA20762
         CLM   RI0,M8,ISAM              TEST FOR ISAM          @ZA20762
         BE    DCK00412                 BRANCH IF AM IS ISAM   @ZA20762
         CLM   RI0,M8,TCAMAP            TEST FOR TCAM          @ZA20762
         BE    DCK00412                 BRANCH IF AM IS TCAM   @ZA20762
         CLM   RI0,M8,SUBSYS            TEST FOR SUBSYSTEM     @ZA20762
         BNE   DCK00414                 BRANCH IF NOT SUBSYS   @ZA20762
DCK00412 NI    DEBFLGS1,X'FF'-DEBEXCPA  SET DEBEXCPA OFF           @03C
DCK00414 EQU   *                                               @ZA20762
         LA    RI1,DEBBASIC             INCREMENT POINTER TO MAIN DEB
         DROP  RI1
         SLL   ROFFSET,K2               SHIFT BACK TO BYTE OFFSET
         SPACE
*/*
*/*      D     (YES,,NO,DCK00490)       IS THE DEB TABLE EMPTY ENTRY
*/*                                     FORMATTED ?                  */
         SPACE
         LA    RW1,DEBTABLE(ROFFSET)    LOAD POINTER TO DEB TABLE ENTRY
         USING TBLENTRY,RW1             RW1 POINTS TO EMPTY ENTRY
         CLC   NEXTEQUE,ZERO            TEST FOR EMPTY CHAIN
         BZ    DCK00490                 BRANCH IF NO CHAIN EXISTS
         SPACE
*/*DCK00420:
*/*      P                              UPDATE EMPTY ENTRY CHAIN IN
*/*                                     CONTROL FIELD                */
         SPACE
DCK00420 MVC   TABLEQUE,NEXTEQUE        MOVE NEXT TO CURRENT
         SPACE
*/*DCK00430:
*/*      P     (,%DCK2000)              STORE VALIDATED DEB POINTER IN
*/*                                     THE DEB TABLE                */
         SPACE
DCK00430 ST    RI1,TBLENTRY             STORE VALIDATED DEB IN TABLE
         DROP  RTABLE,RW1
         B     DCK02000                 RETURN TO CALLER
         SPACE
*/*DCK00440:
*/*      M     (,DCK00460)              INITIALIZE TO GET CORE FOR AND
*/*                                     ZERO A NEW DEB TABLE         */
         SPACE
DCK00440 EQU   *                        BUILD INITIAL DEB TABLE
         XR    ROFFSET,ROFFSET          ZERO LENGTH TO ZERO NEW TABLE
         LH    RNEWLGTH,DEBTSIZE        LOAD INITIAL DEB TABLE SIZE
         B     DCK00460                 BRANCH TO GET TABLE
         SPACE
*/*DCK00450:
*/*      M                              INITIALIZE TO MOVE THE OLD DEB
*/*                                     TABLE TO A NEW DEB TABLE     */
         SPACE
DCK00450 EQU   *                        BUILD A LARGER DEB TABLE
         USING DEBTABLE,RTABLE          RTABLE POINTS TO DEB TABLE
         LH    ROFFSET,TABLELEN         SAVE NEW OFFSET AND OLD LENGTH
         DROP  RTABLE
         LR    RNEWLGTH,ROFFSET         LOAD SIZE OF OLD TABLE
         AH    RNEWLGTH,DEBTINCR        ADD INCREMENTAL TABLE LENGTH
         SPACE
*/*DCK00460:
*/*      D     (NO,,YES,%DCK1000)       IS THE NEW TABLE LENGTH GT
*/*                                     32760 ?                      */
         SPACE
DCK00460 EQU   *                        PREPARE TO GET DEB TABLE
         LTR   RNEWLGTH,RNEWLGTH        TEST IF DEB TABLE IS    YA02826X
                                        GREATER THAN 32767      YA02826
         LA    RETCODE,ERROR7           ERROR IF NEGATIVE       YA02826
         BM    DCK01000                 BRANCH IF NEGATIVE      YA02826
         LH    RF,DEBTMAXL              GET MAXIMUM LENGTH      YA02826
         CR    RNEWLGTH,RF              COMPARE TO MAX LENGTH   YA02826
         LA    RETCODE,ERROR7           ERROR CODE FOR TABLE TOO LONG
         BH    DCK01000                 BRANCH IF LONGER THAN MAXIMUM
         SPACE
*/*
*/*      S                              GETMAIN: GET LSQA CORE FOR NEW
*/*                                     TABLE                        */
         SPACE
         USING RBSECT,RSVRB             RSVRB POINTS TO SVRB
         STM   R0,RB,RBEXSAVE           SAVE REGISTERS 0-11      Y02080
         DROP  RSVRB                                             Y02080
         LR    R0,RNEWLGTH              SAVE LENGTH              Y02080
         LR    R8,RSVRB                 SAVE REGISTER RSVRB      Y02080
         LR    R9,RC                    SAVE REGISTER 12         Y02080
         LR    RA,RD                    SAVE REGISTER 13         Y02080
         XR    R1,R1                    SET PREFIX INDICATOR     Y02080
*        IECRES GET,WLH,LV=(0),SP=SP255,KEY=KEY0,A=(1),ID=DEBT,  Y02080X
               PREFIX=YES                                        Y02080
         IECRES GET,WLH,LV=(0),SP=SP255,KEY=KEY0,A=(1),ID=DEBT,  Y02080X
               PREFIX=YES                                        Y02080
         LR    RC,R9                    RESTORE REGISTER 12      Y02080
         LR    RD,RA                    RESTORE REGISTER 13      Y02080
         USING RBSECT,R8                R8 POINTS TO SVRB        Y02080
         ST    R1,RBEXSAVE+K32          UPDATE REGISTER RNEW     Y02080
         LM    R0,RB,RBEXSAVE           RESTORE REGISTERS 0-11   Y02080
         DROP  R8                                                Y02080
         SPACE
*/*
*/*      D     (YES,,NO,DCK00470)       IS THERE AN OLD DEB TABLE?
*/*                                                                  */
         SPACE
         LTR   RTABLE,RTABLE            TEST FOR OLD TABLE       Y02080
         BZ    DCK00470                 BRANCH IF NO OLD TABLE   Y02080
         SPACE
*/*
*/*      P                              MOVE OLD DEB TABLE TO NEW
*/*                                     DEB TABLE                    */
         SPACE
         LR    RNEWLGTH,ROFFSET         GET OLD LENGTH           Y02080
         MVCL  RNEW,RTABLE              MOVE OLD TO NEW          Y02080
         USING RBSECT,RSVRB             RSVRB POINTS TO SVRB     Y02080
         LM    R0,RB,RBEXSAVE           RESTORE REGISTERS 0-11   Y02080
         DROP  RSVRB
         B     DCK00480                 BRANCH TO CHAIN TABLE    Y02080
         SPACE
*/*DCK00470:
*/*      M                              MODIFY EMPTY QUE OFFSET
*/*                                     INDICATOR                    */
         SPACE
DCK00470 EQU   *                        INITIALIZE OFFSET        Y02080
         LA    ROFFSET,TBLENTRY-DEBTABLE LOAD EMPTY QUE OFFSET   Y02080
         SPACE
*/*DCK00480:
*/*      P     (,DCK00410)              INITIALIZE CONTROL FIELD IN THE
*/*                                     NEW DEB TABLE                */
         SPACE
DCK00480 EQU   *                        INITIALIZE CONTROL FIELD Y02080
         USING DEBTABLE,RNEW            RNEW POINTS TO DEB TABLE Y02080
         STH   RNEWLGTH,TABLELEN        LENGTH OF NEW DEB TABLE  Y02080
         STH   ROFFSET,TABLEQUE         INITIALIZE EMPTY QUE     Y02080
         DROP  RNEW                                              Y02080
         USING TCB,RTCB                 RTCB POINTS TO TCB       Y02080
         L     RW1,TCBJSCB              LOAD TASK JSCB POINTER   Y02080
         DROP  RTCB                                              Y02080
         USING IEZJSCB,RW1              RW1 POINTS TO TASK JSCB  Y02080
         ST    RNEW,JSCBDBTB            STORE NEW DEB TABLE      Y02080
         DROP  RW1                                               Y02080
         SPACE
*/*
*/*      D     (YES,,NO,DCK00485)       IS THERE AN OLD DEB TABLE?
*/*                                                                  */
         SPACE
         LTR   RTABLE,RTABLE            TEST FOR OLD TABLE
         BZ    DCK00485                 BRANCH IF NO OLD TABLE   Y02080
         SPACE
*/*
*/*      S                              FREEMAIN: FREE UP THE OLD DEB
*/*                                     TABLE                        */
         SPACE
         LR    R1,RTABLE                POINTER TO OLD TABLE     Y02080
         LR    R8,RSVRB                 SAVE REGISTER RSVRB      Y02080
         LR    R9,RC                    SAVE REGISTER 12         Y02080
         LR    RA,RD                    SAVE REGISTER 13         Y02080
*        IECRES FREE,WLH,A=(1),PREFIX=YES                        Y02080
         IECRES FREE,WLH,A=(1),PREFIX=YES                        Y02080
*        MODESET EXTKEY=ZERO            GET BACK TO KEY ZERO     Y02080
         MODESET EXTKEY=ZERO            GET BACK TO KEY ZERO     Y02080
         LR    RC,R9                    RESTORE REGISTER 12      Y02080
         LR    RD,RA                    RESTORE REGISTER 13      Y02080
         USING RBSECT,R8                R8 POINTS TO SVRB        Y02080
         LM    R0,RB,RBEXSAVE           RESTORE REGISTERS 0-11   Y02080
         DROP  R8                                                Y02080
         SPACE
*/*DCK00470:
*/*      M                              RESTORE AND RETURN
*/*                                                                  */
         SPACE
DCK00485 EQU   *                        RESTORE & RETURN         Y02080
         LR    RTABLE,RNEW              POINTER TO NEW TABLE     Y02080
         B     DCK00410                 RETURN TO ADD ROUTINE
         SPACE
*/*DCK00490:
*/*      D     (YES,,NO,DCK00420)       IS THE NEXT ENTRY WITHIN THE
*/*                                     DEB TABLE ?                  */
         SPACE
DCK00490 EQU   *                        CHECK FOR UNFORMATTED ENTRY
         LA    ROFFSET,K4(R0,ROFFSET)   INCREMENT OFFSET TO NEXT ENTRY
         USING DEBTABLE,RTABLE          RTABLE POINTS TO DEB TABLE
         CH    ROFFSET,TABLELEN         TEST FOR ENTRY IN TABLE
         BNL   DCK00420                 BRANCH IF NOT IN TABLE
         SPACE
*/*
*/*      D     (YES,,NO,DCK00420)       IS NEXT ENTRY AN UNFORMATTED
*/*                                     ENTRY?                       */
         SPACE
         USING TBLENTRY,RW1             RW1 POINTS TO TABLE ENTRY
         CLC   TBLENTRY+K4(K4),ZERO     TEST NEXT ENTRY FOR ZERO Y02080
         BNZ   DCK00420                 BRANCH IF NOT ZERO
         SPACE
*/*
*/*      P     (,DCK00430)              UPDATE THE EMPTY CHAIN WITH
*/*                                     THE UNFORMATTED EMPTY ENTRY  */
         SPACE
         STH   ROFFSET,TABLEQUE         STORE OFFSET IN EMPTY QUE
         DROP  RTABLE,RW1
         B     DCK00430                 RETURN TO ADD ROUTINE
         EJECT
***********************************************************************
*/*%DCK0500:
*/*         N                              DEB VALIDITY CHECK DELETE
*/*                                        AND PURGE ROUTINE         */
***********************************************************************
         SPACE
*/*DCK00500:
*/*      D     (NO,,YES,%DCK2000)       IS TYPE=VERIFY SPECIFIED?
*/*                                                                  */
         SPACE
DCK00500 BXLE  RBXLE,RBXLE,DCK02000     BRANCH FOR TYPE=VERIFY
         SPACE
*/*
*/*      P                              DELETE AND FORMAT DEB TABLE
*/*                                     ENTRY                        */
         SPACE
         USING DEBTABLE,RTABLE          RTABLE POINTS TO DEB TABLE
         LA    RW1,DEBTABLE(ROFFSET)    VALIDATED DEB TABLE ENTRY
         USING TBLENTRY,RW1             RW1 POINTS TO TABLE ENTRY
         MVI   TBLDELTE,XFF             FLAG FOR DELETE/PURGE
         MVI   TBLDELTE+K1,XFF          FLAG FOR DELETE/PURGE
         SPACE
*/*
*/*      P                              CHAIN FORMATTED EMPTY ENTRY TO
*/*                                     EMPTY CHAIN                  */
         SPACE
         MVC   NEXTEQUE,TABLEQUE        CHAIN PUSH DOWN EMPTY QUE
         STH   ROFFSET,TABLEQUE         STORE OFFSET TO FIRST IN CHAIN
         DROP  RTABLE,RW1
         EJECT
***********************************************************************
*/*%DCK2000:
*/*      N                              DEBCHK NORMAL RETURN - REGISTER
*/*                                     15 = 0                       */
***********************************************************************
         SPACE
*/*DCK02000:
*/*      M                              SET RETURN CODE TO ZERO
*/*                                                                  */
         SPACE
DCK02000 XR    RETCODE,RETCODE          SET RETURN CODE TO ZERO
         SPACE
*/*DCK02100:
*/*      R                              EXIT
*/*                                                                  */
         SPACE
         USING CVT,RCVT                 CVT ADDRESSABILITY       Y02080
DCK02100 L     RE,CVTEXPRO              LOAD EXIT PROLOGUE ADDR  Y02080
         DROP  RCVT                                              Y02080
*        RETURN ,                       RETURN TO CALLER         Y02080
         RETURN ,                       RETURN TO CALLER         Y02080
         SPACE
***********************************************************************
*/*%DCK1000:
*/*      N                              DEBCHK ERROR RETURN - REGISTER
*/*                                     15 = ERROR CODE              */
***********************************************************************
         SPACE
*/*DCK01000:
*/*      D     (NO,,YES,DCK02100)       PROBLEM STATE OR TYPE=PURGE?
*/*                                                                  */
         SPACE
DCK01000 EQU   *                        ERROR RETURN ROUTINE
         LR    RBXLE,RBASE              LOAD FUNCTION TYPE MASK
         SRL   RBXLE,K1                 SHIFT TO GET EXIT INDICATOR
         BXLE  RBXLE,RBXLE,DCK02100     BRANCH IF TYPE=PURGE
         SPACE
*/*
*/*      R                              ABEND 16E
*/*                                                                  */
         SPACE
         L     RI1,ABNDCODE             LOAD ABEND PARAMETERS
         SPACE
*        ABEND (1),DUMP,,SYSTEM                                  Y02080
         ABEND (1),DUMP,,SYSTEM                                  Y02080
         DROP  RBASE
         SPACE
*/*IFGDEBCK:
*/*      END                                                         */
         EJECT
***********************************************************************
*/*IFGDEBVR:
*/*      CHART (AMODE)                  DEBCHK BRANCH ENTRY VERIFY
*/*                                     ROUTINE                      */
***********************************************************************
         SPACE
*/*
*/*      E                              BRANCH ENTRY (IOS)
*/*                                                                  */
         SPACE
IFGDEBVR EQU   *                        BRANCH ENTRY DEB VERIFY ROUTINE
         USING *,RETCODE                                       @ZA47942
         SPACE
*/*
*/*      M                              LOAD THE DEB TABLE OFFSET FROM
*/*                                     THE DEB                      */
         SPACE
         LA    ROFFSET,K3               MASK FOR FULL WORD CK  @ZA26208
         NR    ROFFSET,RI1              IS DEB ON FULL WORD?   @ZA26208
         BZ    DBV01000           YES, BRANCH TO CONTINUE      @ZA47942
         LA    RETCODE,ERRORV     ERROR CODE FOR BAD DEB       @ZA47942
         B     0(RETCODE,RETURN)  RETURN WITH ERROR            @ZA47942
DBV01000 DS    0H                                              @ZA47942
         USING TCB,RTABLE               ESTABLISH TCB          @ZA31908
         L     ROFFSET,TCBJSCB    ADDRESS THE JSCB             @ZA47942
         USING IEZJSCB,ROFFSET                                 @ZA47942
         TM    JSCBOPTS,JSCBAUTH  IS USER AUTHORIZED?          @ZA47942
         DROP  ROFFSET                                         @ZA47942
         LA    ROFFSET,0          SET KEY TO SUPERVISOR        @ZA47942
         BO    DBV01100           BRANCH IF USER IS AUTHORIZED @ZA47942
         CLI   TCBPKF,X'80'       IS USER IN A SUPVR KEY?      @ZA47942
         BL    DBV01100           YES, BRANCH TO USE KEY ZERO  @ZA47942
         IC    ROFFSET,TCBPKF     USE USERS KEY                @ZA47942
DBV01100 DS    0H                                              @ZA47942
         DROP  RETCODE                                         @ZA47942
         LR    R15,R2              SAVE REG 2                  @ZA31908
*                                       GET USERS KEY          @ZA31908
*        MODESET SAVEKEY=(2)                                   @ZA47942
         MODESET SAVEKEY=(2)                                   @ZA47942
         SLL   R2,8               SAVE CALLERS KEY             @ZA47942
         OR    R2,ROFFSET         GET USERS KEY                @ZA47942
*        MODESET KEYADDR=(2)                                   @ZA47942
         MODESET KEYADDR=(2)                                   @ZA47942
         SRL   R2,8               RESTORE CALLERS KEY          @ZA47942
         LA    ROFFSET,4                                       @ZA31908
         LCR   ROFFSET,ROFFSET                                 @ZA31908
         AR    ROFFSET,RI1              BACKUP DEB PTR BY FOUR @ZA31908
         USING DEBLNGTH,ROFFSET         ROFFSET POINTS TO DEB - 4
         LH    ROFFSET,DEBTBLOF         LOAD DEB TABLE FULLWORD OFFSET
         DROP  ROFFSET
*        MODESET KEYADDR=(2)            RETURN TO CALLERS KEY  @ZA31908
         MODESET KEYADDR=(2)            RETURN TO CALLERS KEY  @ZA31908
         LR    R2,R15                   RESTORE REG 2          @ZA31908
         SPACE
         BALR  RETCODE,R0                                          @03M
         USING *,RETCODE                                           @03M
*/*
*/*      D                              IS THE OFFSET POSITIVE?
*/*                                                                  */
         LTR   ROFFSET,ROFFSET          TEST FOR INVAL. OFFSET     @03M
         BNP   DBV01160                 OFFSET IS BAD,ABEND        @03M
         EJECT
*/****** DUE TO REGISTER RESTRICTIONS THE BASE REGISTER IS ***********/
*/******  BEING USED TO SAVE AND RESTORE THE TCB POINTER.  ***********/
*/*                                                                  */
*/*      M                              BACKUP TCB POINTER           */
*/*                                                                  */
         LR    R15,RTABLE               SAVE TCB REGISTER          @03A
*/*                                                                  */
*/*      M                              INITIALIZE JSCB POINTER      */
*/*                                                                  */
         L     RTABLE,TCBJSCB           LOAD POINTER TO JSCB         */
         DROP  RTABLE                                                */
*/*                                                                  */
*/*      M                              INITIALIZE DEB TABLE POINTER */
*/*                                                                  */
         USING IEZJSCB,RTABLE           RTABLE POINTS TO JSCB        */
         L     RTABLE,JSCBDBTB          LOAD POINTER TO DEB TABLE    */
         DROP  RTABLE                                                */
*/*                                                                  */
*/********************************************************************/
         SPACE 4
*/****** DUE TO REGISTER RESTRICTIONS THE BASE REGISTER IS ***********/
*/******  BEING USED TO SAVE AND RESTORE THE TCB POINTER.  ***********/
*/*                                                                  */
*/*      D                              DOES THE DEB TABLE EXIST?    */
*/*                                                                  */
         LTR   RTABLE,RTABLE            TEST FOR EXISTING DEB TABLE  */
*/*                                                                  */
         LR    RTABLE,R15               RESTORE TCB REGISTER       @03A
         BALR  RETCODE,R0               SET NEW BASE               @03A
         USING *,RETCODE                                           @03A
*/*                                                                  */
         BZ    DBV01125                 NO TABLE, CK JOB STEP TCB  @03C
*/*                                                                  */
*/********************************************************************/
         EJECT
*/****** DUE TO REGISTER RESTRICTIONS THE BASE REGISTER IS ***********/
*/******  BEING USED TO SAVE AND RESTORE THE TCB POINTER.  ***********/
*/*                                                                  */
*/*      M                              BACKUP TCB POINTER           */
*/*                                                                  */
         LR    R15,RTABLE               SAVE TCB REGISTER          @03A
*/*                                                                  */
*/*      M                              INITIALIZE JSCB POINTER      */
*/*                                                                  */
         USING TCB,RTABLE               ESTABLISH TCB              @03A
         L     RTABLE,TCBJSCB           LOAD POINTER TO JSCB       @03A
         DROP  RTABLE                                              @03A
*/*                                                                  */
*/*      M                              INITIALIZE DEB TABLE POINTER */
*/*                                                                  */
         USING IEZJSCB,RTABLE           RTABLE POINTS TO JSCB      @03A
         L     RTABLE,JSCBDBTB          LOAD POINTER TO DEB TABLE  @03A
         DROP  RTABLE                                              @03A
*/*                                                                  */
*/********************************************************************/
         SPACE 4
*/****** DUE TO REGISTER RESTRICTIONS THE BASE REGISTER IS ***********/
*/******  BEING USED TO SAVE AND RESTORE THE TCB POINTER.  ***********/
*/*                                                                  */
*/*      D                              OFFSET LONGER THAN DEB TABLE */
*/*                                     LENGTH?                      */
         USING DEBTABLE,RTABLE          RTABLE POINTS TO DEB TABLE   */
         SLL   ROFFSET,K2               ALIGN TO BYTE OFFSET       @04M
         CH    ROFFSET,TABLELEN         TEST FOR OFFSET TO LARGE     */
         DROP  RTABLE                                              @03A
*/*                                                                  */
         LR    RTABLE,R15               RESTORE TCB REGISTER       @03A
         BALR  RETCODE,R0               SET NEW BASE               @03A
         USING *,RETCODE                                           @03A
*/*                                                                  */
         BNL   DBV01125                 TO BIG, CK JOB STEP TCB    @03C
*/*                                                                  */
*/********************************************************************/
         EJECT
*/****** DUE TO REGISTER RESTRICTIONS THE BASE REGISTER IS ***********/
*/******  BEING USED TO SAVE AND RESTORE THE TCB POINTER.  ***********/
*/*                                                                  */
*/*      M                              BACKUP TCB POINTER           */
*/*                                                                  */
         LR    R15,RTABLE               SAVE TCB REGISTER          @03A
*/*                                                                  */
*/*      M                              INITIALIZE JSCB POINTER      */
*/*                                                                  */
         USING TCB,RTABLE               ESTABLISH TCB              @03A
         L     RTABLE,TCBJSCB           LOAD POINTER TO JSCB       @03A
         DROP  RTABLE                                              @03A
*/*                                                                  */
*/*      M                              INITIALIZE DEB TABLE POINTER */
*/*                                                                  */
         USING IEZJSCB,RTABLE           RTABLE POINTS TO JSCB      @03A
         L     RTABLE,JSCBDBTB          LOAD POINTER TO DEB TABLE  @03A
         DROP  RTABLE                                              @03A
*/*                                                                  */
*/********************************************************************/
         SPACE 4
*/****** DUE TO REGISTER RESTRICTIONS THE BASE REGISTER IS ***********/
*/******  BEING USED TO SAVE AND RESTORE THE TCB POINTER.  ***********/
*/*                                                                  */
*/*      D                              IS THE DEB POINTER IN THE    */
*/*                                     DEB TABLE?                   */
*/*                                                                  */
         USING DEBTABLE,RTABLE          RTABLE POINTS TO DEB TABLE @03A
         C     RI1,DEBTABLE(ROFFSET)    TEST FOR VALID DEB POINTER   */
         DROP  RTABLE                                                */
*/*                                                                  */
         LR    RTABLE,R15               RESTORE TCB REGISTER       @03A
         BALR  RETCODE,R0               SET NEW BASE               @03A
         USING *,RETCODE                                           @03A
*/*                                                                  */
         BNE   DBV01125                 NOT VALID, CK JOB STEP TCB @03C
*/*                                                                  */
*/*      M                              INITIALIZE JSCB POINTER      */
*/*                                                                  */
         USING TCB,RTABLE               ESTABLISH TCB              @03A
         L     RTABLE,TCBJSCB           LOAD POINTER TO JSCB       @03A
         DROP  RTABLE                                                */
*/*                                                                  */
*/*      M                              INITIALIZE DEB TABLE POINTER */
*/*                                                                  */
         USING IEZJSCB,RTABLE           RTABLE POINTS TO JSCB      @03A
         L     RTABLE,JSCBDBTB          LOAD POINTER TO DEB TABLE  @03A
         DROP  RTABLE                                              @03A
*/*                                                                  */
         B     DBV01150                 PTR VALID, RETURN          @03A
*/*                                                                  */
*/********************************************************************/
         EJECT
*/********************************************************************/
DBV01125 DS    0H                                                  @01A
*/*                                                              9 @03D
         BALR  RETCODE,R0               RESTORE BASE               @03A
         USING *,RETCODE                                           @03A
*/*                                                                  */
*/*      D                              DOES THE JOB STEP TCB EXIST? */
*/*                                                                  */
         USING TCB,RTABLE               ESTABLISH TCB              @01A
         CLM   RTABLE,B'0111',TCBJSTCA  TEST FOR JOBSTEP TCB       @03A
         BE    DBV01160                 NO JOBSTEP TCB, ERROR      @03A
         L     RTABLE,TCBJSTCB          POINT TO JOBSTEP TCB       @03A
         L     RTABLE,TCBJSCB           PT TO JSCB IN JOBSTEB TCB  @01A
         DROP  RTABLE                                              @01A
*/*                                                                @01D
         USING IEZJSCB,RTABLE                                      @01A
         L     RTABLE,JSCBDBTB          POINT RTABLE TO DEBTBL     @01A
         DROP  RTABLE                                              @01A
*/*                                                                  */
*/*      D                              DOES THE DEB TABLE EXIST?    */
*/*                                                                  */
         LTR   RTABLE,RTABLE            TEST FOR EXIST. DEBTBL     @01A
         BZ    DBV01160                 NO TABLE, RET W/ERROR      @01A
*/*                                                                  */
*/*      M                              RESTORE REGB                 */
*/*                                                                  */
         USING DEBTABLE,RTABLE                                     @01A
         LA    ROFFSET,DEBBASIC-DEBLNGTH PUT 4 IN REGB             @03A
         LCR   ROFFSET,ROFFSET          CHANGE TO -4               @03A
         AR    ROFFSET,RI1              BACKUP DEBPTR BY 4         @03A
         USING DEBLNGTH,ROFFSET         ROFFSET POINTS TO DEB-4    @03A
         LH    ROFFSET,DEBTBLOF         LOAD DEBTBL FULLWRD OFFSET @03A
         DROP  ROFFSET                                               */
*/*
*/*      D                              IS THE OFFSET POSITIVE?
*/*                                                                  */
         LTR   ROFFSET,ROFFSET          TEST FOR INVAL. OFFSET     @04A
         BNP   DBV01160                 OFFSET IS BAD,ABEND        @04A
*/*                                                                  */
*/*      D                              OFFSET LONGER THAN DEB TABLE */
*/*                                     LENGTH?                      */
         SLL   ROFFSET,K2               ALIGN TO BYTE OFFSET       @04A
         CH    ROFFSET,TABLELEN         TEST FOR OFFSET TO BIG     @01A
         BNL   DBV01160                 INVALID OFFSET, ERROR      @01A
*/*                                                                  */
*/*      D                              IS THE DEB POINTER IN THE    */
*/*                                     DEB TABLE?                   */
         C     RI1,DEBTABLE(ROFFSET)    TEST FOR VALID DEB PTR     @01A
         DROP  RTABLE                                              @01A
*/*                                                                  */
         BNE   DBV01160                 PTR NOT VALID, RET.        @01A
*/*                                                                  */
*/********************************************************************/
         EJECT
*/********************************************************************/
*/*                                                                  */
DBV01150 DS    0H                                                  @01A
*/*                                                                  */
*/*      M                              SET RETURN CODE TO ZERO      */
*/*                                                                  */
         XR    RETCODE,RETCODE          SET RETURN CODE TO ZERO      */
*/*                                                                  */
*/*      R                              BR 14   (R15 = 0)            */
*/*                                                                  */
         RETURN ,                       NORMAL RETURN TO CALLER  Y02080
*/*                                                                  */
*/********************************************************************/
         SPACE 4
*/********************************************************************/
*/*                                                                @03D
DBV01160 DS    0H                                                  @01A
*/*                                                                  */
*/*      M                              SET RETURN CODE TO FOUR      */
         DROP  RETCODE                                             @01A
         LA    RETCODE,ERRORV           ERR CODE FOR BAD RET       @01A
*/*                                                                  */
         B     K0(RETCODE,RETURN)       RETURN,ERROR (R15 = 4)     @01A
*/*                                                                  */
*/*IFGDEBVR:                                                         */
*/*      END                                                         */
         EJECT
***********************************************************************
*        CONSTANTS
***********************************************************************
BXLEMSKS DS    0F                       AUTHORIZED BXLE MASKS    Y02080
         DC    BL1'00001001'            TYPE=VERIFY MASK
         DC    BL1'00010001'            TYPE=ADD MASK
         DC    BL1'00000001'            TYPE=DELETE MASK
         DC    BL1'10100001'            TYPE=PURGE MASK
         SPACE
BXLEMSKP DS    0F                       UNAUTHORIZED BXLE MASKS  Y02080
         DC    BL1'10001001'            TYPE=VERIFY MASK
         DC    BL1'11000001'            TYPE=ADD MASK
         DC    BL1'11000001'            TYPE=DELETE MASK
         DC    BL1'11000001'            TYPE=PURGE MASK
         SPACE
*VSAM    DEBCHK AM=VSAM,MF=L            VSAM ACCESS METHOD PARM  Y02080
VSAM     DEBCHK AM=VSAM,MF=L            VSAM ACCESS METHOD PARM  Y02080
ISAM     DC    XL1'80'                  ISAM AM CODE           @ZA42565
SUBSYS   DC    XL1'81'                  SUBSYSTEM AM CODE      @ZA42565
TCAMAP   DC    XL1'84'                  TCAMAP AM CODE         @ZA20762
THREE    DC    AL3(K3)                  THREE
TRES     DC    A(K3)                    THREE IN 4 BYTES       @ZA79269
DBCHKADD DC    AL3(1)             ADD REQUEST                  @ZA47942
ZERO     DC    A(K0)                    ZERO                     Y02080
ABNDCODE DC    XL4'0000016E'            ABEND PARAMETER LIST     Y02080
DEBTMAXL DC    AL2(32760)               MAXIMUM LENGTH OF DEB TABLE
DEBTSIZE DC    H'24'                    INITIAL DEB TABLE SIZE   YM3882
DEBTINCR DC    H'24'                    DEB TABLE INCREMENT      YM3882
***********************************************************************
*        PATCH AREA
***********************************************************************
*        XCTLTABL SVC=117,BRT=YES,LENGTH=                        Y02080
         XCTLTABL SVC=117,BRT=YES,LENGTH=                        Y02080
         EJECT
DEBTABLE DSECT
TABLELEN DS    H                        LENGTH OF TABLE IN BYTES
TABLEQUE DS    H                        OFFSET OF EMPTY QUE IN BYTES
TBLENTRY EQU   *                        TABLE ENTRY
NEXTEQUE DS    H                        BYTE OFFSET OF NEXT EMPTY ENTRY
TBLDELTE DS    H                        DELETION FLAG BYTES
         SPACE 2                                                 YM2377
*        IECDSECS CVT,TCB,JSCB,RB,PSA,DCB,IEZDEB,EXPAND=YES      Y02080
         IECDSECS CVT,TCB,JSCB,RB,PSA,DCB,IEZDEB,EXPAND=YES      Y02080
         MEND
         END
