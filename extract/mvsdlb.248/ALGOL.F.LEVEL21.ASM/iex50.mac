X50      TITLE 'IEX50 - COMPILATION PHASE, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        THIS MODULE PERFORMS THE REAL TRANSLATION OF THE SOURCE
*        PROGRAM INTO SYSTEM/360 INSTRUCTIONS. THE SOURCE
*        PROGRAM IS AT MODIFICATION LEVEL 2 AND CONSISTS OF A
*        SEQUENCE OF ONE BYTE OPERATORS AND FIVE BYTE OPERANDS,
*        WHICH IS SCANNED SEQUENTIALLY. THE STATUS OF RECOGNITION
*        OF THE SOURCE PROGRAM IS DESCRIBED BY -
*        1. A SEQUENCE OF CONTEXTS (SEE BELOW)
*        2. A SEQUENCE OF STACKED OPERATORS (THE OPERATOR STACK)
*
*        THE ACTION OF THE COMPILER IS DETERMINED BY THE
*        OPERATOR PAIR STACK-SOURCE OPERATOR AND THE CURRENT
*        CONTEXT. THE OPERATOR PAIR DETERMINES AN ELEMENT IN A
*        DECISION MATRIX, WHICH IS DETERMINED BY THE CONTEXT. THE
*        MATRIX ELEMENTS REPRESENT ADDRESSES OF THE COMPILER
*        PROGRAMS, WHICH PERFORM THE ACTIONS REQUESTED BY ALL
*        POSSIBLE OPERATOR PAIRS.
*
*        THERE ARE THREE CONTEXTS, PROGRAM, STATEMENT, AND
*        EXPRESSION CONTEXT, AND THE CURRENT CONTEXT IS INDICATED
*        BY A REGISTER. SWITCHING ING FROM ONE CONTEXT TO
*        ANOTHER IS IN MOST CASES DETERMINED BY THE STACK-SOURCE
*        OPERATOR PAIR, IE THE COMPILER PROGRAM ACTIVATED JUST
*        PERFORMS THE CHANGE OF CONTEXT, BUT IN A FEW CASES THE
*        SOURCE OPERATOR ALONE DETERMINES THE NEW CONTEXT. IN
*        THIS LATTER CASE THE OPERATOR IS STACKED TOGETHER WITH A
*        CONTEXT OPERATOR, INDICATING THE PRECEDING CONTEXT.
*
*        BESIDES THE COMPILER PROGRAMS THERE ARE OTHER ROUTINES
*        PROVIDING DIFFERENT SERVICES. THE MOST IMPORTANT ARE
*        (THOSE MARKED WITH * ARE USED AS SUBROUTINES BY THE
*        COMPILER PROGRAMS) -
*
*        SUBSTART - SCAN TO NEXT OPERATOR IN SOURCE PROGRAM
*        COMP     - CHOOSE COMPILER PROGRAM AND BRANCH
*        JBUFFER  - READ A NEW SOURCE PROGRAM RECORD
*       *NXTOPT   - GET NEXT ENTRY OF OPTAB
*       *SERR     - GENERATE AN ERROR PATTERN
*        CPEND    - NORMAL TERMINATION
*        CPERRI   - ABNORMAL TERMINATION
*       *GENERATE - GENERATE TXT AND RLD RECORDS
*
*        A COMPILER PROGRAM IS ALWAYS FOLLOWED BY SUBSTART OR COMP
*        OR A BRANCH TO ANOTHER COMPILER PROGRAM
*
*        THE MODULE CONSISTS OF SEVEN CONTROL SECTIONS
*        IEX50000 - INITIALIZATION AND SUBROUTINES
*        IEX50001 - DECISION MATRIXES
*        IEX50002 - COMPILER PROGRAMS HANDLING FOR STATEMENTS
*                   AND SUBSCRIPT OPTIMIZATION
*        IEX50003 - COMPILER PROGRAMS HANDLING BEGIN AND END OF
*                   COMPOUND STATEMENTS AND BLOCKS, PROCEDURE
*                   DECLARATIONS, ARRAY DECLARATIONS, SWITCH
*                   DECLARATIONS, GOTO STATEMENTS, SUBSCRIPTED
*                   VARIABLES AND SWITCH DESIGNATORS, SEMICOLON
*                   COUNTER
*        IEX50004 - COMPILER PROGRAMS HANDLING ASSIGNMENTS,
*                   PROCEDURE CALLS, STANDARD PROCEDURE CALLS
*        IEX50005 - COMPILER PROGRAMS HANDLING ERRONEOUS CASES,
*                   BOOLEAN OPERATIONS, ARITHMETIC MINUS, IF,
*                   THEN, ELSE
*        IEX50006 - COMPILER PROGRAM HANDLING ARITHMETICAL
*                   OPERATIONS
*
*        ENTRY POINT -
*        IEX50000 - COMPILATION PHASE XCTL EP=IEX50
*        THE MODULE IS ENTERED FROM IEX40
*
*        INPUT -
*        THE SOURCE PROGRAM IS READ FROM SYSUT2
*        OPTAB IS READ FROM SYSUT3
*
*        OUTPUT -
*
*        THE MAIN PART OF THE OBJECT MODULE IS OUTPUT TO SYSLIN
*        AND/ OR SYSPUNCH IF THE OPTIONS 'LOAD' AND/OR 'DECK' ARE
*        SPECIFIED
*
*        EXTERNAL ROUTINES - N/A
*
*        EXIT - NORMAL -
*        IF NO TERMINATING ERROR HAS OCCURRED, CONTROL IS GIVEN
*        TO THE TERMINATING MODULE BY MEANS OF XCTL EP=IEX51000
*
*        EXIT - ERROR -
*        IF A TERMINATING ERROR HAS OCCURED, CONTROL IS GIVEN TO
*        THE TERMINATING MODULE BY MEANS OF XCTL EP=IEX51ER1
*
*        TABLES/WORKAREAS -
*        SCPTAB  - COMPILER PROGRAM ADDR TABLE USED BY ROUTINE
*                  COMP
*        TXTT    - INFORMATION FOR TXT RECORDS USED BY ROUTINE
*                  GENERATE
*        RLDT    - INFORMATION FOR RLD RECORDS USED BY ROUTINE
*                  GENERATE
*        DECAREA - DECISION MATRIXES USED BY ROUTINE COMP
*
*        THE PART OF COMMON WORKAREA STARTING AT SYSUT1 IS
*        INITIALIZED BY THE PRECEDING LOAD MODULE AND USED BY
*        THIS AND THE NEXT LOAD MODULE
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
IEX50000 CSECT
*
*        R6                            REL ADDR IN OBJ PROGRAM
*        R7                            DISP IN OBJECT TIME STACK
*        R8                            SOURCE PROGRAM POINTER
*        R9                            OPERAND STACK POINTER
*        R10                           OPERATOR STACK POINTER
*        R11                           INDICATES CURRENT CONTEXT
*        R12                           BASE ADDR OF COMP PROGRAMS
*
*        OBJECT TIME REGISTER DEFINITIONS
*
FPR0     EQU   0                       *
FPR2     EQU   2                       *
GPRA     EQU   3                       *   VARIABLE USE
GPRB     EQU   5                       *
GPRC     EQU   6                       *
ADR      EQU   8                       FOR TRANSFER OF ADDRS
CDSA     EQU   10                      ADDRS CURRENT DSA
GDSA     EQU   9                       ADDRS GLOBAL DSA
PBT      EQU   11                      ADDRS PROGRAM BLOCK TABLE
LAT      EQU   12                      ADDRS LABEL ADDR TABLE (LAT)
FSA      EQU   13                      ADDRS FIXED STORAGE AREA
ENTRY    EQU   15                      ENTRY PT OF LIBRARY SUBRTNS
BRR      EQU   15                      LINK REGISTER
*
*        INITIALIZATION
*
*        THIS ROUTINE PERFORMS THE REMAINING INITIALIZATION
*        THE MAIN PART IS MADE IN IEX40001
*
         IEXENTRY 'IEX50000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX50000,R15            USE ENTRY POINT REG AS BASE
         USING WORKAREA,R13
         LA    R5,SUBSTART             LOAD BASE REG FOR SUBSTART
         DROP  R15
         USING SUBSTART,R5
         LA    R4,CPERR1               PROVIDE DIRECTORY
         ST    R4,ERET                 RETURN ADDR
         L     R11,DECAADD             LOAD ADDR OF CCT
         LA    R4,JB3                  PROVIDE
         ST    R4,EODUT2               EOD ADDR
         LA    R4,NX4                  FOR UT2
         ST    R4,EODUT3               AND UT3
         CNOP  0,8
*
*        START OF SUBROUTINE POOL
*
*        SCAN SOURCE INPUT TO NEXT OPERATOR
*
SUBSTART NI    COMPFLGS,255-OPERAND    OPERAND FLAG OFF
ABC1     CLI   1(R8),XFZETA            TEST SOURCE
         BL    ABD3                    OPERATOR
         BH    ABD1                    OPERAND
         BAL   R4,JBUFFER              BUFFER CHANGE
         B     ABC1                    CONTINUE
*
ABD3     LA    R8,1(,R8)               INCR SOURCE PTR
         B     COMP                    CHOOSE CP
*
ABD1     OI    COMPFLGS,OPERAND        OPERAND FLAG ON
         SH    R9,KH5                  SOURCE OPERAND
         CR    R10,R9                  TO
         BNL   STACKOFL                STACK
         MVC   0(5,R9),1(R8)
         LA    R8,5(,R8)               SOURCE REG INCREASE
         B     ABC1                    CONTINUE
*
*        AN OPERAND IS NOT ALLOWED IN SOURCE
*
SPECTEST CLI   1(R8),XFZETA            SPECIAL TEST
         BL    ABD3                    OPERATOR
         BH    ABD5                    OPERAND
         BAL   R4,JBUFFER              BUFFER CHANGE
         B     SPECTEST
*
ABD5     LA    R8,6(R8)                SOURCE REG INCREASE
         BAL   R4,SERR3
ERROR    DC    H'191'
*
         BCTR  R8,0                    SOURCE PTR MINUS ONE
         B     SPECTEST
*
*        CHOOSE CP PROGRAM
*
COMP     SR    R1,R1
         LR    R2,R1
         IC    R1,0(,R8)               FETCH SOURCE OPERATOR
         IC    R1,0(R1,R11)            COLUMN VECTOR
         IC    R2,0(,R10)              FETCH STACK OPERATOR
         IC    R2,50(R2,R11)           ROW VECTOR
         AR    R1,R2
         IC    R1,100(R1,R11)
         SLL   R1,2(0)                 COMPILER PROGRAM FROM MATRIX
         L     R12,SCPTAB(R1)          FIND BASE ADDR
         BR    R12                     BRANCH TO COMPILER PROGRAM
*
***********************************************************************
*
*        JBUFFER - READ INPUT BUFFER
*
***********************************************************************
*
* CALL   BAL   R4,JBUFFER              (FROM SUBSTART)
*        BAL   R4,JBUFFER              (FROM COMPILER PROGRAMS)
*
*        REGISTER DEFINITIONS
*
*        R3                            SYSUT2 DCB
*        R2                            ADDR OF CURRENT BUFFER
*        R8                            ADDR OF CURRENT INPUT BUFFER
*
JBUFFER  L     R3,AUT2DCB              R2 -> SYSUT2 DCB
         L     R2,SOURCEB              GET ADDR OF CURRENT BUFFER
JB1      B     JB2                     NO CHECK FIRST TIME
*
         CHECK SRCECO                  CHECK PREVIOUS READ
*
JB2      READ  SRCECO,SF,(R3),(R2)
*
JB3      L     R8,RSRCB                GET ADDR OF OLD READ BUFFER
         ST    R2,RSRCB                CHANGE ADDRS
         ST    R8,SOURCEB
         BCTR  R8,0                    GET START ADDR - 1
         IC    R3,NUMBBL               STEP
         LA    R3,1(,R3)                    RECORD
         STC   R3,NUMBBL                           COUNTER
         MVI   JB1+1,X'00'             CHANGE BRANCH CONDITION
         BR    R4                      RETURN
*
***********************************************************************
*
*        NXTOPT - ACQUIRES NEXT ENTRY OF OPTAB
*
***********************************************************************
*
* CALL   BAL   R4,NXTOPT
*
NXTOPT   L     R2,OPBUFB               GET ADDR OF CURRENT BUFFER
         L     R3,OPREL                GET REL ADDR OF NEW ENTRY
         LA    R3,14(,R3)
         C     R3,OPTABS               A NEW BUFFER REQUIRED ?
         BNL   NX1                     YES
         AR    R2,R3                   NO, STORE
         ST    R2,AOPTABE              ADDR OF NEW ENTRY
         B     NX3
*
NX1      B     NX2                     NO CHECK FIRST TIME
*
         CHECK OPTCO                   CHECK PREVIOUS READ
*
NX2      L     R3,AUT3DCB              R3 -> SYSUT3 DCB
*
         READ  OPTCO,SF,(R3),(R2),'S'  READ OPTAB RECORD
*
         MVI   NX1+1,X'00'             CHANGE BRANCH CONDITION
NX4      L     R1,ROPTB                GET ADDR OF OLD READ BUFFER
         ST    R1,OPBUFB               CHANGE
         ST    R2,ROPTB                       ADDRS
         ST    R1,AOPTABE              STORE
         SR    R3,R3                         ADDRS OF
NX3      ST    R3,OPREL                                   NEW ENTRY
         BR    R4                      RETURN
*
OPREL    DC    F'0'                    REL ADDR IN CURRENT BUFFER
*
*        CONSTANTS LOCATED IN SUBROUTINE POOL
*
KH2      DC    H'2'
KH4      DC    H'4'
KH5      DC    H'5'
KH8      DC    H'8'
KH9      DC    H'9'
KH10     DC    H'10'
KH15     DC    H'15'
KH20     DC    H'20'
KH290    DC    H'290'
KH324    DC    H'324'
KH614    DC    H'614'
API      DC    X'91FF01000000'
*
TYPETEST DC    F'3'
SWVAL    DC    H'0'
SWREL    DC    H'0'
GREGN    DC    H'0'
         DC    0F'0'
DECAADD  DC    A(DECAREA)               ADDR OF DECISION AREA
*                                       ADDR OF PROG CONTEXT COL VECTOR
HEXFFF   DC    X'00000FFF'
STC      DC    A(ADRSTC)                ADDR OF STMT CONTEXT COL VECTOR
EXC      DC    A(ADREXC)                ADDR OF EXPR CONTEXT COL VECTOR
*
***********************************************************************
*
*        COMPILER PROGRAM ADDR TABLE
*
***********************************************************************
*
         DC    0F'0'
SCPTAB   DC    A(CP0,CP1,CP84,CP3)
         DC    A(CP4,CP84,CP6,CP7)
         DC    A(CP8,CP84,CP84,CP84)
         DC    A(CP12,CP84,CP84,CP84)
         DC    A(CP16,CP17,CP18,CP19)
         DC    A(CP20,CP21,CP22,CP23)
         DC    A(CP24,CP25,CP26,CP27)
         DC    A(CP28,CP29,CP30,CP31)
         DC    A(CP84,CP33,CP34,CP84)
         DC    A(CP36,CP84,CP38,CP84)
         DC    A(CP40,CP41,CP84,CP43)
         DC    A(CP84,CP45,CP84,CP47)
         DC    A(CP84,CP49,CP84,CP51)
         DC    A(CP52,CP84,CP54,CP84)
         DC    A(CP56,CP57,CP84,CP59)
         DC    A(CP84,CP61,CP62,CP63)
         DC    A(CP64,CP65,CP66,CP67)
         DC    A(CP68,CP69,CP70,CP71)
         DC    A(CP72,CP73,CP74,CP75)
         DC    A(CP76,CP77,CP78,CP79)
         DC    A(CP80,CP81,CP84,CP83)
         DC    A(CP84,CP85,CP86,CP87)
*
*        NON EXISTANT COMPILER PROGRAMS
*
*        CP2,  CP5,  CP9,  CP10, CP11, CP13, CP14, CP15, CP32,
*        CP35, CP37, CP39, CP42, CP44, CP46, CP48, CP50, CP53,
*        CP55, CP58, CP60, CP82
*
***********************************************************************
*
*        ERROR PATTERN GENERATION
*
***********************************************************************
*
* CALL   BAL   R4,SERRX                X=1, 2, 3, 4, SP
*        DC    H'N'                    N=MSG NUMBER
*
*        ENTRY BOTH OPERATORS
*
SERR4    LA    R3,2
         LA    R2,6                     GET LENGTH OF ENTRY
         B     ER2
*
*        ENTRY STACK OPERATOR
*
SERR2    LA    R3,3
         B     ER1
*
*        ENTRY SOURCE OPERATOR
*
SERR3    LA    R3,1
ER1      LA    R2,5                    GET LENGTH OF ENTRY
ER2      L     R15,NEXTERR             GET ADDR OF POOL ENTRY
         STC   R2,0(,R15)              INSERT LENGTH OF ENTRY
         LA    R2,4                    SET POINTER FOR OPERATOR INSERT
         BCT   R3,ER4                  BRANCH IF STACK OR BOTH
*
ER3      MVC   EP212+3(1),0(R8)        GET SOURCE OP
         OI    EP212+3,X'80'           PUT A TAG
         IC    R1,EP212+3              INSERT SOURCE OPERATOR
         B     ER5
*
ER4      IC    R1,0(,R10)              FETCH STACK OPERATOR
ER5      STC   R1,0(R2,R15)            INSERT OPERATOR
         LA    R2,1(,R2)               INCREASE POINTER
         BCT   R3,ER6                  STACK OR SOURCE, BRANCH
         B     ER3                     BOTH
*
*        SPECIAL ENTRY FOR MSG 214
*
SERRSP   L     R15,NEXTERR             GET ADDR OF POOL ENTRY
         LH    R3,SPBNST               GET CURRENT PBN
         CVD   R3,ERDOUBLE             BINARY
         UNPK  ERDOUBLE(3),ERDOUBLE+6(2)       TO
         MVZ   ERDOUBLE+2(1),ERDOUBLE              CHARACTER
         MVC   4(3,R15),ERDOUBLE       MOVE TO ERROR PATTERN
         LA    R2,7                    SET LENGTH OF ENTRY
         STC   R2,0(,R15)
         B     ER6
*
*        ENTRY NO OPERATOR
*
SERR1    L     R15,NEXTERR
         LA    R2,4                    INSERT LENGTH OF ENTRY
         STC   R2,0(,R15)
ER6      MVC   2(2,R15),SEMCNT         INSERT SEMICOLON COUNTER
         IC    R3,1(,R4)               INSERT ERROR NUMBER
         STC   R3,1(,R15)
         LA    R15,0(R2,R15)           UPDATE PTR TO NEXT ENTRY
         ST    R15,NEXTERR
         C     R15,ENDPOOL             POOL FULL ?
         BNH   ER7                     NO
         MVC   EP212+2(2),SEMCNT       YES, MOVE PATTERN FOR M212
         MVC   0(4,R15),EP212
         LA    R15,4(0,R15)            UPDATE PTR TO NEXT ENTRY
         ST    R15,NEXTERR
         B     CPERR1                  GOTO TERMINATION
*
ER7      OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         LA    R3,2                    STEP RETURN ADDR
         AR    R4,R3
         BR    R4                      R4 TO CALLER
*
EP212    DC    X'04D40000'             ERROR PATTERN FOR MSG 212
ERDOUBLE DC    D'0'
*
*        OPERAND/OPERATOR STACK OVERFLOW
*
* CALL   B STACKOFL
*
STACKOFL BAL   R4,SERR1
         DC    H'186'
*
         B     CPERR1
*
*        NORMAL TERMINATION
*
CPEND    TM    COMPFLGS+2,SPIC         SOURCE IN STORE ?
         BO    CPEND1                  YES
         BAL   R4,JBUFFER              NO, CHECK LAST READ
CPEND1   TM    NX1+1,X'F0'             OPTAB READ IN IEX50 ?
         BO    CPEND2                  NO
         BAL   R4,NXTOPT               NO, CHECK LAST READ
*
CPEND2   XCTL  EP=IEX51000             XCTL TO NEXT MODULE
*
*        DIRECTORY RETURN ADDR
*
CPERR1   TM    JB1+1,X'F0'             READ TO INPUT BUFFERS
         BO    CPERR10                 NO
*
         CHECK SRCECO                  CHECK LAST READ
*
CPERR10  TM    NX1+1,X'F0'             OPTAB READ
         BO    CPERR11                 NO
*
         CHECK OPTCO                   CHECK LAST READ
*
CPERR11  XCTL  EP=IEX51ER1             ERROR MSG EDITING AND TERM
*
         DC    0H'0'
*
***********************************************************************
*
*        CONVERSION - INTEGER TO REAL
*
***********************************************************************
*
*        GENERATES CALL OF CONVERSION ROUTINE FROM INTEGER TO
*        REAL AFTER LOCATING THE OPERAND
*        RESERVES ONE OBJECT STACK TIME ENTRY
*        SETS RIR
*        INTRODUCES OPERAND ADDRS INTO RUTR
*        ADJUSTS OPERAND
*
* CALL   BAL   R4,TRINRE
*
TRINRE   ST    R4,RETADR               STORE RETURN ADDR
         LA    R4,HQF21
         BAL   R3,ROUTIN15
         SR    R1,R1
         IC    R1,3(R9)                PREPARE INSTRUCTION
         SRL   R1,4
         LA    R2,1
         SLL   R2,0(R1)
         STC   R2,HQD2+1
         XI    HQD2+1,X'FF'
HQD2     NI    RII+1,X'00'
         BAL   R4,ROUTINE8             RELILO
         MVN   HQG1+1(1),VPLACE
         BAL   R2,GENTXT2
HQG1     LR    R14,0                   ***GENERATE***
HQH1     TM    RIR+1,X'01'             FPRO FREE ?
         BZ    HQJ1                    YES, BRANCH
         BAL   R4,ROUTIN14             STFPR0
HQJ1     TM    RII,X'01'               ADR FREE ?
         BZ    HQJ11
         BAL   R4,ROUTIN10
HQJ11    BAL   R2,GENTXT4              CALL CONVERSION ROUTINE
*        BAL   ADR,CNVIRD(0,FSA)       ***GENERATE***
         BAL   R8,X'120'(,13)          ***NEW GENERATED ***
         OI    0(R9),X'80'             ADJUST R9 ENTRY
         NI    0(R9),X'9F'
         OI    1(R9),X'32'
         NI    1(R9),X'FE'
         MVC   2(1,R9),SPBNST+1
         AH    R7,ONEENTRY             INCR OF 4(SHORT) OR 8(LONG)
         STH   R7,WORKPL
         MVC   3(2,R9),WORKPL          INTRODUCE STACK ADDR
         ST    R9,RUTR                 INTRODUCE R9 ADDR IN RUTR
         OI    RIR+1,X'01'             SET RIR TO ONE
         MVI   CIR+1,0                 CIR=0
         L     R4,RETADR               LOAD RETURN ADDR
         BR    R4
*
HQF21    MVN   HQG2+1(1),VPLACE        PREPARE INSTRUCTION
         MVC   HQG2+2(2),WPLACE
         BAL   R2,GENTXT4
HQG2     L     R14,0(0,0)              ***GENERATE***
         B     HQH1
*
***********************************************************************
*
*        CONVERSION - REAL TO INTEGER
*
***********************************************************************
*
*        SUBROUTINE TO GENERATE CODE TO CALL REAL TO INTEGER
*        CONVERSION ROUTINE
*
* CALL   BAL   R4,TRREIN
*
*        AT OBJECT TIME THE INTEGER VALUE IS IN R14 AFTER CONVERSION
*
*        BIT PATTERNS
*
OBJSTM   EQU   X'C0'                   OBJECT STACK MASK
RADRFREM EQU   X'01'                   REG ADDR FREE MASK
FPROOCM  EQU   X'01'                   FPR0 MASK
OPDVALUM EQU   X'20'                   VALUE MASK
OPDREGM  EQU   X'40'                   REGISTER MASK
*
TRREIN   ST    R4,SAVTRREI             SAVE RETURN ADDR
         TM    RIR+1,FPROOCM           FPR0 OCCUPIED ?
         BZ    TRREIN1                 NO
         C     R9,RUTR                 OPERAND IN FPR0
         BE    TRREIN8                 YES, RELEASE FPR0
         BAL   R4,ROUTIN14             STORE FPR0
         NI    RIR+1,255-FPROOCM       MARK FPR0 FREE
TRREIN1  LA    R3,TRREIN4              ADDR IF VALUE IN REG
         BAL   R4,ROUTIN15             FIND DISPL AND REG
TRREIN2  MVN   TRREIN3+1(1),VPLACE     INSERT REGISTER AND
         MVC   TRREIN3+2(2),WPLACE     DISPLACEMENT IN LOAD INSTRUCTION
         BAL   R2,GENTXTP4             GENERATE A LOAD FPR0
TRREIN3  LD    FPR0,0(0,0)             *INSTRUCTION, FLOATING POINT *
TRREIN6  TM    RII,RADRFREM            REG ADDR FREE
         BZ    TRREIN9                 YES
         BAL   R4,ROUTIN10             STORE ADDR AND RETURN
         NI    RII,255-RADRFREM
TRREIN9  BAL   R2,GENTXT4              GENERATE A CALL TO THE REAL-
*        BAL   ADR,CNVRDI(FSA,0)       *INTEGER CONVERSION ROUTINE
         BAL   8,X'14C'(13)            ***NEW GENERATED CODE***
         L     R4,SAVTRREI
         BR    R4
*
TRREIN4  MVN   TRREIN5+1(1),VPLACE
         BAL   R2,GENTXTP2             GENERATE A LOAD  FPR0
TRREIN5  LDR   FPR0,0                  *INSTRUCTION FLOATING POINT *
TRREIN8  BAL   R4,ROUTIN12             RELEASE REG CONTAINING OPD
         B     TRREIN6
*
SAVTRREI DC    F'0'                    SAVE AREA FOR RETURN
*
***********************************************************************
*
*        S U B R O U T I N E   G E N E R A T E
*
***********************************************************************
*
*        GENERATE RLD RECORDS
*
* CALL   L     R2,                     VALUE OF PROGRAM POINTER
*        BAL   R14,GENRLD
*        DC    H' '                    LENGTH OF ADDR TABLE
*        DC    H'  '                   ESID OF RELOCATION FACTOR R
*        DC    H'  '                   ESID OF POSITION IDENTIFIER P
*        ---                           RETURN AFTER CALL GENERATE
*
*        GENERATE TXT RECORDS SIX DIFFERENT CALLS
*
*        BAL   R2,GENTXT2
*        RR FORMAT INSTRUCTION OR DATA 2 BYTES LONG
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXTP2
*        RR FORMAT FLOATING POINT LONG FORM INSTRUCTION
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXT4
*        INSTRUCTION(S) OR DATA 4 BYTES LONG
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXTP4
*        RX  FORMAT FLOATING POINT LONG FORM INSTRUCTION
*        ---                           RETURN AFTER CALL GENERATE
*
*        BAL   R2,GENTXT6
*        INSTRUCTIONS OR DATA 6 BYTES LONG
*        ---                           RETURN AFTER CALL GENERATE
*
*        LA    R2,                     ADDR OF CODE TO BE GENERATED
*        BAL   R14,GENTXT8
*        DC    H'  '                   LENGTH OF CODE IN BYTES
*        ---                           RETURN AFTER CALL GENERATE
*
*        REGISTER DEFINITIONS
*
*        R1                            OUTPUT RECORD POINTER
*        R2                            ADDR OF DATA
*        R3                            TYPE OF RECORD TO BE GENERATED
*        R4                            RETURN REGISTER
*        R14                           LENGTH OF DATA FROM CALL
*        R15                           LENGTH WITHIN RECORD
*
*        BIT PATTERNS
*
SDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION
LDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION
RLDFLAG  EQU   B'00001100'             FLAG USED IN RLD ENTRY
*
*        GENERATE RLD RECORDS
*
GENRLD   LA    R4,6(,R14)              COMPUTE RETURN ADDR
         LA    R3,RLDT                 INDICATE RLD CALL
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         SLL   R14,1                   DOUBLE LENGTH
         B     GEN1                    CONTINUE COMMON PART
*
*        GENERATE TXT RECORDS
*
GENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         B     GEN2                    CONTINUE TXT ENTRY
*
*        GENERATE RX OR RS INSTRUCTION, CHANGE PRECISION
*
GENTXTP4 XI    GENTXT6+7,X'06'         MODIFY LENGTH INSTRUCTION
*
*        GENERATE RR INSTRUCTION, CHANGE PRECISION
*
GENTXTP2 OC    0(1,R2),PRECMASK        MODIFY INSTRUCTION, L OR S
*
*        GENERATE TXT RECORD,2
*
GENTXT2  XI    GENTXT6+7,X'06'         MODIFY LENGTH INSTRUCTION
*
*        GENERATE TXT RECORD,4
*
GENTXT4  XI    GENTXT6+7,X'02'         MODIFY LENGTH INSTRUCTION
*
*        GENERATE TXT RECORD,6
*
GENTXT6  ST    R14,PLACE14             SAVE LENGTH REGISTER
         LA    R14,6                   LENGTH = 2, 4 OR 6
         MVI   GENTXT6+7,X'06'         RESTORE MODIFIED INSTRUCTION
         LA    R4,0(R2,R14)            COMPUTE RETURN ADDR
GEN2     LA    R3,TXTT                 INDICATE TXT CALL
GEN1     L     R1,SAVOUTA              FETCH OLD OUTPUT RECORD ADDR
         TM    COMPFLGS+1,NLOAD+NDECK  LOAD OR DECK SPECIFIED ?
         BO    GEN4A                   NO, OUT OF GENERATE
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    GEN4A
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL FOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0 = LENGTH OF DATA IN REC
         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUGH SPACE LEFT ?
         BL    *+6                     NO
         LR    R15,R14                 YES, R15 = R14 FROM CALL
         AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES
*
GEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?
         BH    GEN3                    YES
GEN4A    L     R14,PLACE14             NO, RESTORE R14
         BR    R4                      RETURN
*
*        NEW OUTPUT RECORD
*
GEN3     ST    R14,SAVELT              SAVE LENGTH
         TM    COMPFLGS+1,NLOAD+NDECK  BOTH LOAD AND DECK SPECIFIED ?
         BZ    BOTH                    YES
         TM    COMPFLGS+1,NDECK        DECK ONLY ?
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB
         BZ    PUT1                    YES
PUT$1    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH
*
         ST    R1,SAVOUTA              SYSPUNCH OR SYSLIN ADDR
         L     R14,SAVELT              RESTORE LENGTH
         B     PUNCHOUT                OUT OF ROUTINE PUNCH
*
BOTH     L     R14,OUTAREA2            COPY SYSLIN DATA TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
PUT2     L     R1,APCHDCB              R1 -> SYSPUNCH DCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT$1                   GOTO PUT SYSLIN
*
PUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             STEP SEQUENCE NUMBER
         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P
         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?
         BNE   GEN6                    NO
         ST    R6,4(R1)                YES INSERT R6
         MVI   4(R1),C' '
         B     GEN6
*
*        TXT RECORD
*
         DC    0H'0'
TXTT     DC    X'02'                   RECORD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        MOVE TXT INFORMATION TO OUTAREA
*
GEN8     BCTR  R15,0                   DECR LENGTH
         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE
         MVC   16(0,R1),0(R2)          MOVE DATA TO OUTAREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    OUT OF MOVE TXT ROUTINE
*
*        RLD RECORD
*
         DC    0H'0'
RLDT     DC    X'02'                   RECORD CODE
         DC    C'RLD'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    C'  '
RANDP    DC    H'1',H'1'               R AND P ESID ARE 1 AT START
         DC    H'56'                   MAXIMUM LENGTH IN RECORD
*
*        MOVE RLD INFORMATION TO OUTAREA
*
GEN9     AR    R15,R1                  INDICATE LAST ENTRY
GEN5     MVC   16(4,R1),RANDP
         ST    R2,20(,R1)              MOVE PROGRAM POINTER VALUE AND
         MVI   20(R1),RLDFLAG          FLAG TO OUTAREA
         LA    R1,8(,R1)               NEXT ENTRY
         LA    R2,4(,R2)               NEXT PROGRAM POINTER VALUE
         CR    R1,R15                  LAST COLUMN FILLED
         BL    GEN5                    NO, CONTINUE
         B     GEN4                    OUT OF MOVE RLD ROUTINE
*
*        VARIABLES AND CONSTANTS
*
SAVELT   DC    F'0'                    SAVE AREA FOR LENGTH
KP1      DC    PL2'1'                  FOR INCREMENTING CARD COUNT
*
***********************************************************************
*
*        SUBROUTINE CLEAR REGISTERS
*
***********************************************************************
*
* CALL   BAL   R4,CLEARRG
*
*        GENERATES STORE INSTRUCTIONS FOR ALL REGISTERS THAT
*        CONTAIN VALID INFORMATION - SET CII, CIR, RII, RIR
*
CLEARRG  MVI   GPBN+1,X'FF'            DESTROY GDSA
         ST    R4,RETADR               STORE RETURN ADDR
         SR    R14,R14
         BCTR  R14,0
         BCTR  R14,0
         LH    R2,RIR
KIF22    LA    R14,2(,R14)
         LTR   R2,R2
         BZ    KIF21                   YES, BRANCH
         SRDL  R2,1
         LTR   R3,R3
         BNM   KIF22                   NO, BRANCH
         ST    R2,RETADR+64
         BAL   R4,ROUTIN13
         L     R2,RETADR+64
         B     KIF22
*
KIF21    MVI   CIR,0
         MVI   CIR+1,X'06'
         MVC   RIR(2),ZEROHW           CLEAR RIR
         SR    R14,R14
         BCTR  R14,0
         LH    R2,RII
KIF25    LA    R14,1(,R14)
         LTR   R2,R2
         BZ    KIF24                   BRANCH IF YES
         SRDL  R2,1
         LTR   R3,R3
         BNM   KIF25                   BRANCH IF NO
         ST    R2,RETADR+64
         BAL   R4,ROUTINE9
         L     R2,RETADR+64
         B     KIF25
*
KIF24    MVI   CII,0
         MVI   CII+1,X'07'
         MVC   RII(2),ZEROHW           CLEAR RII
         L     R4,RETADR               LOAD RETURN ADDR
         BR    R4
*
***********************************************************************
*
*        O P E R A N D   R E C O G N I Z E R
*
***********************************************************************
*
* CALL   BAL   R4,OPDREC
*
*        CHECK IF OPERAND IN STACK IS A FORMAL PARAMETER OR A
*        PROCEDURE WITHOUT PARAMETERS
*        OPDREC GENERATES AN ACTUAL PARAMETER OR A PROCEDURE CALL
*
*        IF OPERAND IS A FORMAL PARAMETER CALLED BY VALUE LABEL
*        OR ARRAY OPDREC GENERATES LOAD OF REGISTERS GDSA AND/OR ADR
*
*        ADDR DISPLACEMENTS
*
TYPS     EQU   1                       SECOND BYTE TYPE IN IDENTIFIER
NUMP     EQU   3                       NO OF PARAMETERS IN IDENTIFIER
PBNP     EQU   2                       DISP OF PBN IN IDENTIFIER
TYPF     EQU   0                       FIRST BYTE TYPE IN IDENTIFIER
RUTIADR  EQU   4*8                     ENTRY IN RUTI TABLE FOR ADR
*
*        BIT PATTERNS
*
VARIAM   EQU   X'30'                   MASK FOR VARIABLE
INTRVM   EQU   X'7F'                   INTERMIDIATE VALUE IN STACK
INTRRM   EQU   X'60'                   INTERMIDIATE VALUE ADDR IN REG
DESTROY  EQU   X'FF'                   INDICATE THAT GDSA IS NOT VALID
ARRAYM   EQU   X'04'                   ARRAY IDENTIFIER MASK
LABARRM  EQU   X'0C'                   LABEL OR ARRAY IDENTIFIER MASK
RIIADRM  EQU   X'01'                   RII MASK FOR RESERVATION OF ADR
FORMPM   EQU   X'30'                   FORMAL PARAMETER MASK
PROCM    EQU   X'C0'                   PROCEDURE MASK
STPROCM  EQU   X'40'                   STANDARD PROCEDURE MASK
PARAM    EQU   X'F0'                   NUMBER OF PARAMETER MASK
FUNCPM   EQU   X'03'                   FUNCTION PROCEDURE MASK
VALUEM   EQU   X'20'                   VALUE PARAMETER SPEC
REGADRM  EQU   ADR*16                  REGISTER ADR MASK
*
OPDREC   TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?
         BNOR  R4                      NO, RETURN
         TM    TYPS(R9),FORMPM         OPERAND FORMAL PARAMETER ?
         ST    R4,SAVRT                SAVE RETURN ADDR
         BM    OPDREC1                 YES, FORMAL
         TM    TYPS(R9),PROCM          PROCEDURE IDENTIFIER ?
         BZR   R4                      NO, RETURN
         TM    TYPS(R9),STPROCM        STANDARD PROCEDURE ?
         BZR   R4                      YES, RETURN
         TM    NUMP(R9),PARAM          PARAMETERLESS PROCEDURE ?
         BNZR  R4                      NO, RETURN
*
*        PARAMETERLESS PROCEDURE FOUND
*
         BAL   R4,CLEARRG              CLEAR ALL OBJ TIME REGISTERS
         MVC   PPCODE+2(2),NUMP(R9)    INSERT DISPLACEMENT OF LABEL
         MVC   PPCODE+5(1),PBNP(R9)    INSERT PROGRAM BLOCK NUMBER
         LA    R2,PPCODE               GENERATE A PARAMETERLESS
         BAL   R14,GENTXTS             PROCEDURE
         DC    H'12'                   CALL
         TM    TYPS(R9),FUNCPM         FUNCTION PROCEDURE
         L     R4,SAVRT
         BZR   R4                      NO, RETURN
*                                      PARAMETERLESS FUNCTION
*                                      PROC FOUND
         B     OPDREC4
*
*        FORMAL PARAMETER FOUND
*
OPDREC1  TM    TYPS(R9),VALUEM         CALLED BY NAME ?
         BO    OPDREC3                 NO
*                                      FORMAL PARAMETER CALLED BY NAME
         BAL   R4,CLEARRG              CLEAR ALL OBJ TIME REGISTERS
         SR    R3,R3
         IC    R3,PBNP(,R9)            PROCEDURE PBN FROM IDENTIFIER
         SLL   R3,3                    DISPLACEMENT IN PBT
         STH   R3,CAP+4                INSERTED IN CAP CODE
         LH    R3,SPBNST               CURRENT PBN
         SLL   R3,3                    DISPLACEMENT IN PBT
         STH   R3,CAP+6                INSERTED IN CAP CODE
         MVC   CAP+10(2),NUMP(R9)      INSERT FORMAL PARAM DISPL
         LA    R2,CAP                  GENERATE CALL ACTUAL PARAMETER
         BAL   R14,GENTXTS             CODE
         DC    H'12'
*
         TM    TYPS(R9),PROCM          PROCEDURE
         BZ    OPDREC4                 NO
         TM    PROCWPS,X'80'
         BO    OPDREC4                 NOT PARAMETERLESS, SET IN CP57
         LA    R2,OPDREC6              GENERATE
         BAL   R14,GENTXTS             CHECK FOR PARAMETERLESS
         DC    H'10'                   PROCEDURE
*
OPDREC4  AH    R7,ONEENTRY             RESERVE ONE ENTRY IN OBJ STACK
         STH   R7,SPBNST+2             INSERT NEW DISPL AND
         MVC   PBNP(3,R9),SPBNST+1     PBN IN INTERNAL NAME
         XI    TYPF(R9),INTRRM         ADDR OF OPERAND IN REGISTER
         OI    NUMP(R9),REGADRM        INDICATE REGISTER ADR
         ST    R9,RUTI+RUTIADR         GPR CONTROL ENTRY RUTI
         OI    RII,RIIADRM             GPR CONTROL ENTRY RII
         L     R4,SAVRT
         TM    TYPS(R9),ARRAYM
         BOR   R4
         TM    TYPS(R9),X'03'
         BZR   R4
         MVI   PBNP(R9),X'00'          INDICATE SPECIAL ADDR ADR
*                                      MAY POINT TO FCTVALST IN FSA
*                                      ROUTINE 9 CHECK THIS
         BR    R4                      RETURN
*
*        FORMAL PARAMETER CALLED BY VALUE
*
OPDREC3  TM    TYPS(R9),LABARRM        LABEL OR ARRAY IDENTIFIER
         BNMR  R4                      NO, RETURN
         BAL   R4,ROUTINE3             GENERATE LOAD ADR
         AH    R7,ONEENTRY             OBJECT TIME STACK NOT RELEASED
         TM    TYPS(R9),ARRAYM         ARRAY IDENTIFIER
         BO    OPDREC4                 YES, INTERNAL NAME AND REG CONTR
         LA    R3,4
         AH    R3,GRD3+2               ADD 4 TO DISP, GRD3 IN ROUTINE3
         STH   R3,OPDREC5+2            INSERT DISP+4 (CDSA OR GDSA)
         MVN   OPDREC5+1(1),GRD3+1     IN LOAD GDSA INSTRUCTION
         BAL   R2,GENTXT4              GENERATE A LOAD GDSA
OPDREC5  L     GDSA,4(0,0)             INSTRUCTION
         MVI   GPBN+1,DESTROY          NOTE THAT GDSA IS DESTROYED
         B     OPDREC4                 INTERNAL NAME AND REG CONTROL
*
*        CONSTANTS AND VARIABLES
*
PPCODE   L     ADR,0(LAT,0)            PARAMETERLESS PROCEDURE CALL
         MVI   PROLPBN(FSA),0          CODE, DISP INSERTED
         BAL   BRR,PROLOG(,FSA)        CODE IS 12 BYTES
*
*        CALL ACTUAL PARAMETER, GENERATED CODE
*        DISPL, PBNP AND PBNC INSERTED
*
CAP      BAL   BRR,CAP1(,FSA)          TO CAP SUBROUTINE FIRST PART
         DC    H'0'                    PBNP, PBN DISP OF PROCEDURE
         DC    H'0'                    PBNC, PBN DISP OF CURRENT BLOCK
         L     ADR,0(CDSA,0)           THUNK ADDR FROM PROCEDURE DSA
OPDREC6  LA    R14,FCTVALST(FSA)       CHECK THAT ACTUAL
         CR    R14,ADR                 PARAMETER PROCEDURE
         BNE   OERR21(FSA)             IS PARAMETERLESS
*
SAVRT    DC    F'0'                    SAVE AREA FOR RETURN
PROCWPS  DC    X'00'                   SWITCH TO AVOID PARAMETERLESS
*                                      PROCEDURE CHECK
*
***********************************************************************
*
*        S U B R O U T I N E   M A X C H E C K
*
***********************************************************************
*
*        SUBROUTINE TO CHECK THAT OBJECT TIME STACK POINTER
*        VALUE IS LESS THAN MAX VALUE PLACED IN WORKPL BY CALLING
*        ROUTINE
*
* CALL   BAL   R4,MAXCH
*
MAXCH    STM   R15,R4,MCHSAV           SAVE REGISTERS
         LH    R4,WORKPL               FETCH CHECKVALUE FROM WORKAREA
         LH    R3,SPBNST               CURRENT PBN FROM WORKAREA
         SLL   R3,2                    PBT DISPLACEMENT
         CH    R4,PBTAB3(R3)           R4 < MAX IN PBTAB3 ?
         BNH   MAXCH1                  YES, RETURN
         STH   R4,PBTAB3(R3)           INSERT R4 AS NEW MAX
         CH    R4,MAXOVERF             OVERFLOW OF OBJECT TIME STACK ?
         BNH   MAXCH1                  NO, RETURN
         CR    R7,R4                   R7 ALREADY BEEN RESET ?
         BL    MAXCH1                  YES, NO ERROR MSG
         SR    R7,R7                   NO, RESET R7 TO ZERO
         BAL   R4,SERRSP               ERROR PATTERN GENERATION
         DC    H'214'                  ERROR 214
*
MAXCH1   LM    R15,R4,MCHSAV           RESTORE REGISTERS
         BR    R4                      RETURN
*
*        VARIABLES AND CONSTANTS
*
MCHSAV   DC   6F'0'                    SAVE AREA FOR REGISTERS
*
***********************************************************************
*
*        SEMICOLON COUNTER HANDLING
*
***********************************************************************
*
* CALL   BAL R4,SCHDL
*
*        SET SEMICOLON COUNTER AND MOVE SOURCE POINTER IN SOURCE
*        STRING
*
*        GENERATES SEMICOLON TRACE IF OPTION SPECIFIED
*
SCHDL    ST    R4,SCHDLR               SAVE RETURN ADDR
         MVC   SEMCNT,1(R8)            STORE SEMICOLON NUMBER
         LA    R8,2(R8)                STEP SOURCE POINTER
*
*        GENERATE BRANCH TO TRACE ROUTINE
*
         MVC   SCHDL1(2),SEMCNT        SEMICOLON NUM TO GENERATED CODE
         TM    COMPFLGS+2,NOTEST
         BO    SCHDL1+2                NO SEMICOLON TRACE GEN
         BAL   R2,GENTXT6
         BAL   BRR,TRACE(FSA)          **GENERATED CODE**
SCHDL1   DC    H'0'                    **GENERATED CODE**
*
         L     R4,SCHDLR
         BR    R4
*
SCHDLR   DC    F'0'                    SAVE RETURN ADDR
*
***********************************************************************
*
*        ROUTINE NUMBER 1
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE1
*
*        LOAD IN W-PLACE THE DISPLACEMENT OF AN OPERAND THAT IS
*        NOT AN ADDR
*        LOAD IN V-PLACE AA OR 99 DEPENDING ON WHERE THE
*        VARIABLE, CONSTANT OR INTERMEDIATE RESULT IS AND
*        GENERATES A LOADING OF GDSA IF NECESSARY
*
ROUTINE1 MVC   WPLACE(2),3(R9)         MOVE DISPLACEMENT OF LO TO W
GPE2     MVI   VPLACE,X'AA'            MOVE CDSA REG TO V
         CLC   2(1,R9),SPBNST+1        PBN OF LO CDSA ?
         BER   R4                      YES, RETURN IF CURRENT DSA
GPE3     MVI   VPLACE,X'99'            MOVE GLOBAL DSA REG TO V
         CLI   GPBN+1,X'FF'            C(GDSA) DESTROYED ?
         BE    GPC3                    YES, BRANCH IF DESTROYED
         CLC   GPBN(1),2(R9)           GDSA = PBN OF LO
         BER   R4                      EQUAL, RETURN
GPC31    SR    R1,R1                   CLEAR R1
         ST    R4,RETADR+4             STORE RETURN ADDR
         MVC   GPBN(1),2(R9)           KEEP NEW LOADED GDSA
         IC    R1,2(,R9)               LOAD IN R1 PBN OF LO
         SLA   R1,3                    MULTIPLY BY 8
         STH   R1,WORKPL               PREPARE INSTRUCTION
         MVC   GPC4+2(2),WORKPL
         BAL   R2,GENTXT4              GENERATE
GPC4     L     GDSA,0(PBT,0)
         L     R4,RETADR+4             LOAD RETURN ADDR
         BR    R4                      RETURN
*
GPC3     MVI   GPBN+1,0                RECONSTRUCT GDSA
         B     GPC31
*
***********************************************************************
*
*        ROUTINE NUMBER 2
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE2
*
*        GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDR
*        ADJUSTS THE OPERAND
*        STORES OPERAND STACK ADDR INTO RUTR
*
ROUTINE2 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE3             BRANCH TO ROUTINE NUMBER 3
GQE3     SLL   R14,1                   INTRODUCE R9 ADDR IN RUTR
         ST    R9,RUTR(R14)
         SLL   R14,3                   PREPARE INSTRUCTION
         STC   R14,GQD3+1
         MVN   GQD3+1(1),VPLACE
         MVC   GQD3+2(2),WPLACE
         BAL   R2,GENTXTP4
GQD3     LD    0,0(0,0)                ***GENERATE***
GQF3     SRL   R14,4
         SH    R9,KH5                  REDUCE R9
         STH   R7,WORKPL               INTROD R7 INTO R9 ENTRY
         MVC   8(2,R9),WORKPL
         MVZ   8(1,R9),GQD3+1          INTROD REG NUMBER
         MVC   7(1,R9),SPBNST+1        INTROD PBN
         OI    5(R9),X'80'             ADJUST R9 ENTRY
         NI    5(R9),X'9F'
         L     R4,RETADR+8             LOAD RETURN ADDR
         BR    R4
*
***********************************************************************
*
*        ROUTINE NUMBER 3
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE3
*
*        LOAD IN W-PLACE ZERO
*        LOAD IN V-PLACE 88
*        GENERATE A LOADING OF ADR IF NECCESSARY, IN THIS CASE
*        THE OPERAND IS AN ADDR
*
ROUTINE3 ST    R4,RETADR+12            STORE RETURN ADDR
         TM    0(R9),X'40'             ADDR OF LO IN ADR ?
         BO    GRC3                    NO, NOT
         MVI   RII,0                   CLEAR RIT OF ADR
GRE3     SH    R7,ONEENTRY             REDUCE R7 BY 8
GRG2     MVI   VPLACE,X'88'            V EQUAL ADR
         MVC   WPLACE(2),ZEROHW        W EQUAL ZERO
         L     R4,RETADR+12            LOAD RETURN ADDR
         BR    R4                      RET
*
GRC3     TM    RII,X'01'               ADR FREE ?
         BZ    GRD31                   YES, BRANCH
GRC4     ST    R14,RETADR3
         BAL   R4,ROUTIN10
         L     R14,RETADR3
GRD31    BAL   R4,ROUTINE1             CALL ROUTINE1
         MVC   GRD3+2(2),WPLACE        MOVE DISPLACEMENT
         MVN   GRD3+1(1),VPLACE        MOVE BASE REG
         BAL   R2,GENTXT4              GENERATE
GRD3     L     ADR,0(0,0)              ***GENERATE***
         ST    R9,RUTI+32
         B     GRE3
*
RETADR3  DC    F'0'
*
***********************************************************************
*
*        ROUTINE NUMBER 4
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE4
*
*        GENERATES A LOAD INSTRUCTION INTO THE FLOATING POINT
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDR
*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR
*        INTO RUTR
*
ROUTINE4 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         OI    1(R9),X'30'             SET TO VARIABLE
         B     GQE3                    BRANCH TO ENTRY PT IN RTN NO 2
*
***********************************************************************
*
*        ROUTINE NUMBER 5
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE5
*
*        GENERATES A LOAD INSTRUCTION INTO A GENERAL PURPOSE
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS NOT AN ADDR
*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR
*        INTO RUTI
*
ROUTINE5 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE1             CALL ROUTINE NUMBER 1
         OI    1(R9),X'30'             SET TO VARIABLE
GTE3     SLL   R14,2                   INTRODUCE R9 ADDR IN RUTI
         ST    R9,RUTI(R14)
         SLL   R14,2                   PREPARE INSTRUCTION
         STC   R14,GTD3+1
         STC   R14,GQD3+1
         MVN   GTD3+1(1),VPLACE
         MVC   GTD3+2(2),WPLACE
         BAL   R2,GENTXT4
GTD3     L     0,0(0,0)                ***GENERATE***
         B     GQF3                    BRANCH TO ENTRY PT IN RTN NO 2
*
***********************************************************************
*
*        ROUTINE NUMBER 6
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE6
*
*        GENERATES A LOAD INSTRUCTION INTO A GENRAL PURPOSE
*        REGISTER SPECIFIED BY R14 OF AN OPERAND THAT IS AN ADDR
*        ADJUSTS THE OPERAND AND STORES THE OPERAND STACK ADDR
*        INTO RUTI
*
ROUTINE6 ST    R4,RETADR+8             STORE RETURN ADDR
         LA    R9,5(,R9)               INCREASE R9
         BAL   R4,ROUTINE3             CALL ROUTINE NUMBER 3
         B     GTE3                    BRANCH TO ENTRY PT IN RTN NO 5
*
***********************************************************************
*
*        ROUTINE NUMBER 7
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE7
*
*        LOADS INTO R14 THE NUMBER OF THE NEXT GENERAL PURPOSE
*        REGISTER TO BE USED ACCORDING TO CII
*        IF IT IS OCCUPIED IT BRANCHES TO ROUTINE NUMBER 9 THAT
*        GENERATES A STORE INSTRUCTION
*        CII AND RII ARE SET
*        RESERVES ONE OBJECT TIME STACK ENTRY
*
ROUTINE7 SR    R14,R14
         CLI   CII+1,X'07'             CII IS 7 ?
         BE    GVC2                    YES, BRANCH
         IC    R14,CII+1(0)            INCREASE CII BY ONE
         LA    R14,1(,R14)
GVC2     STC   R14,CII+1
         LA    R15,1                   LOAD ONE INTO R15
         SLL   R15,0(R14)              GENERATE MASK
         STC   R15,GVC21+1
GVC21    TM    RII+1,0                 GPR OCCUPIED ?
         BZ    GVE2                    NO, BRANCH
         ST    R4,RETADR+28            STORE RETURN ADDR
         BAL   R4,ROUTINE9             CALL ROUTINE9
         L     R4,RETADR+28            LOAD RETURN ADDR
GVE2     OC    RII+1(1),GVC21+1        SET TO ONE RII
GVF2     AH    R7,ONEENTRY             INCREASE R7 BY 4 OR 8
         BR    R4
*
***********************************************************************
*
*        ROUTINE NUMBER 8
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE8
*
*        THE LAST GENERAL PURPOSE REGISTER RESERVED IS RELEASED
*        CII AND RII ARE SET
*        ONE OBJECT STACK ENTRY IS RELEASED
*
ROUTINE8 SR    R14,R14                 CLEAR R14
         IC    R14,CII+1               LOAD CII INTO R14
         LA    R15,1                   CLEAR RII OF LO
         SLL   R15,0(R14)
         STC   R15,GWD51+1
         XI    GWD51+1,X'FF'
GWD51    NI    RII+1,0
         SH    R7,ONEENTRY             REDUCE R7
GWD5     CLI   CII+1,0                 CII = ZERO
         BE    GWD3                    YES, BRANCH
         BCTR  R14,0                   REDUCE BY ONE
         STC   R14,CII+1               STORE NEW CII
         SRL   R15,1                   GPR INDICATED BY
GWD6     STC   R15,GWD4+1              CII FREE
GWD4     TM    RII+1,0
         BZ    GWD5                    FREE, BRANCH
         BR    R4                      RETURN
*
GWD3     MVI   CII+1,X'07'             MAKE CII = 7
         LA    R14,7
         CLI   RII+1,0                 ALL GPR FREE ?
         BER   R4                      YES, RETURN
         LA    R15,128                 LOAD MASK
         B     GWD6
*
***********************************************************************
*
*        ROUTINE NUMBER 10
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN10
*
*        CLEARS RII OF ADR
*        LOADS 8 INTO R14
*        FALLS THROUGH TO ROUTINE NUMBER 9
*
ROUTIN10 MVI   RII,X'00'
         LH    R14,KH8
*
***********************************************************************
*
*        ROUTINE NUMBER 9
*
***********************************************************************
*
* CALL   BAL   R4,ROUTINE9
*
*        GENERATE CODE TO STORE GENERAL PURPOSE REGISTER
*        SPECIFIED BY R14 IF THE PBN IS NOT ZERO
*        IF THE PBN IS ZERO IT GENERATES A MOVE INSTRUCTION
*        THE OPERAND IS ADJUSTED
*
ROUTINE9 ST    R4,RETADR+36            STORE RETURN ADDR
         SLL   R14,2                   MULTIPLY BY 4
         LA    R15,RUTI                LOAD ADDR OF RUTI
         L     R15,0(R14,R15)          LOAD ADDR OF OPD TO STORE
         SLL   R14,2                   PREPARE INSTRUCTION
         NI    3(R15),X'0F'
         ST    R15,RETADR+48
         TM    2(R15),X'FF'
         BZ    GXC4
         LA    R14,10(,R14)
         STC   R14,GXC3+1
         MVC   GXC3+2(2),3(R15)        PREPARE INSTRUCTION
         BAL   R2,GENTXT4
GXC3     ST    0,0(CDSA,0)             ***GENERATE***
         B     HBC2
*
GXC4     MVC   GXC5+2(2),3(R15)
         OI    GXC5+2,X'A0'
         MVI   GXC5+1,X'07'
         TM    COMPFLGS,LNG
         BO    GXC6
         MVI   GXC5+1,X'03'
GXC6     NI    0(R15),X'DF'
         MVC   2(1,R15),SPBNST+1
         BAL   R2,GENTXT6
GXC5     MVC   0(4,CDSA),0(ADR)        *** GENERATE ***
         B     HBC2
*
***********************************************************************
*
*        ROUTINE NUMBER 11
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN11
*
*        LOADS INTO R14 THE NUMBER OF THE NEXT FLOATING POINT
*        REGISTER TO BE USED ACCORDING TO CIR
*        IF IT IS OCCUPIED IT CALLS ROUTINE NUMBER 13 THAT
*        GENERATES A STORE INSTRUCTION
*        CIR AND RIR ARE SET
*        ONE OBJECT TIME ENTRY IS RESERVED
*
ROUTIN11 SR    R14,R14                 CLEAR R14
         CLI   CIR+1,X'06'             CIR = 6 ?
         BE    GZC2                    YES, BRANCH
         IC    R14,CIR+1               LOAD CIR INTO R14
         LA    R14,2(,R14)             INCR CIR BY 2
GZC2     STH   R14,CIR                 STORE NEW CIR
         SRL   R14,1                   DIVIDE R14 BY 2
         LA    R15,1                   LOAD ONE INTO R15
         SLL   R15,0(R14)              GENERATE MASK
         SLL   R14,1
         STC   R15,GZC21+1
GZC21    TM    RIR+1,0                 FPR OCCUPIED ?
         BZ    GZE2                    FREE, BRANCH
         ST    R4,RETADR+44            STORE RETURN ADDR
         BAL   R4,ROUTIN13             CALL ROUTIN13
         L     R4,RETADR+44            LOAD RETURN ADDR
GZE2     OC    RIR+1(1),GZC21+1
GZF2     AH    R7,ONEENTRY             INCREASE R7 BY 4 OR 8
         BR    R4
*
***********************************************************************
*
*        ROUTINE NUMBER 12
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN12
*
*        THE LAST FLOATING POINT REGISTER RESERVED IS RELEASED
*        CIR AND RIR ARE SET
*        ONE OBJECT STACK ENTRY IS RELEASED
*
ROUTIN12 LH    R14,CIR                 LOAD INTO R14 CIR
         LA    R15,1                   CLEAR RIR OF BLO
         SRL   R14,1
         SLL   R15,0(R14)
         STC   R15,HAD4+1
         XI    HAD4+1,X'FF'
HAD4     NI    RIR+1,0
         SH    R7,ONEENTRY             REDUCE R7
         SLL   R14,1
HAD1     CLI   CIR+1,0                 ZERO ?
         BE    HAD3                    YES, BRANCH
         SH    R14,KH2
         STC   R14,CIR+1
         SRL   R15,1
HAD0     STC   R15,HAD2+1
HAD2     TM    RIR+1,0
         BZ    HAD1
         BR    R4
*
HAD3     MVI   CIR+1,X'06'             SET CIR = 6
         LH    R14,CIR
         CLI   RIR+1,0                 ZERO ?
         BER   R4                      YES, BRANCH
         LA    R15,8
         B     HAD0
*
***********************************************************************
*
*        ROUTINE NUMBER 14
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN14
*
*        LOAD ZERO INTO R14
*        FALL THROUGH TO ROUTINE NUMBER 13
*
ROUTIN14 SR    R14,R14
*
***********************************************************************
*
*        ROUTINE NUMBER 13
*
***********************************************************************
*
*        GENERATE CODE TO STORE FLOATING POINT REGISTER
*        SPECIFIED BY R14
*        THE OPERAND IS ADJUSTED
*
ROUTIN13 ST    R4,RETADR+36            STORE RETURN ADDR
         SLL   R14,1                   MULTIPLY R14 BY 2
         LA    R15,RUTR                LOAD ADDR OF RUTR
         L     R15,0(R14,R15)          LOAD R9 ADDR OF OPERAND
         SLL   R14,3                   SHIFT REG NO TO OREOARE INSTRUC
         LA    R14,10(,R14)            INTRODUCE CDSA
         STC   R14,HBC3+1
         NI    3(R15),X'0F'
         MVC   HBC3+2(2),3(R15)
         ST    R15,RETADR+48
         BAL   R2,GENTXTP4
HBC3     STD   0,0(CDSA,0)             *** GENERATE ***
HBC2     L     R15,RETADR+48
         XI    0(R15),X'C0'
         MVC   WORKPL(2),3(R15)
         BAL   R4,MAXCH
         SRL   R14,4
         L     R4,RETADR+36            LOAD RETURN ADDR
         BR    R4                      RETURN
*
***********************************************************************
*
*        ROUTINE NUMBER 15
*
***********************************************************************
*
* CALL   BAL   R4,ROUTIN15
*
*        IF THE OPERAND IS AN ADDR BRANCH TO ROUTINE NUMBER 3
*        IF THE OPERAND IS NOT AN ADDR AND IS IN A REGISTER GET
*        THE REGISTER NUMBER TO V-PLACE, ELSE IT BRANCHES TO
*        ROUTINE NUMBER 1
*
ROUTIN15 TM    0(R9),X'20'
         BO    ROUTINE3
         TM    0(R9),X'40'
         BZ    ROUT151
         TM    0(R9),X'80'
         BO    ROUTINE1
         SH    R7,ONEENTRY
         B     ROUTINE1
*
ROUT151  IC    R15,3(,R9)              GET
         SRL   R15,4                       REG
         STC   R15,VPLACE                      NUMBER
         MVZ   VPLACE(1),3(R9)                  TO VPLACE
         BR    R3                      RETURN
*
***********************************************************************
*
*        DECOMP
*
***********************************************************************
*
* CALL   BAL   R4,DECOMP
*
*        DECOMPOSE OPERAND BY MOVING ITS PARTS INTO LOW ENDS OF
*        HALFWORDS
*
DECOMP   MVC   OPDPBN+1(1),2(R9)       MOVE PBN
         MVC   OPDADR(2),3(R9)         MOVE ADDR
         LH    R1,OPDADR
         N     R1,HEXFFF
         STH   R1,OPDLN                LABEL NUMBER
         BR    R4
*
***********************************************************************
*
*        STACKAPI
*
***********************************************************************
*
* CALL   BAL   R4,STACKAPI
*
*        STACK ALL PURPOSE IDENTIFIER (API)
*
STACKAPI SH    R9,KH5
         CR    R10,R9
         BNL   STACKOFL
         MVC   0(5,R9),API
         BR    R4
*
***********************************************************************
*                                                                     *
*        PROGRAM BLOCK NUMBER HANDLING                                *
*                                                                     *
***********************************************************************
*
* CALL   BAL   R4,PBNHDL
*
*        PROGRAM BLOCK NUMBER HANDLING INSERTS NEW PBN IN
*        WORKAREA, SPBNST
*        SAVE R7 IN PBTAB2
*        INSERT NEW OBJECT TIME STACK POINTER VALUE TO R7
*
PBNHDL   SR    R2,R2
         IC    R2,3(,R8)
         CLI   0(R8),X'0D'             SOURCE OPERATOR BETA ?
         BE    PBNHDL1                 YES
         CLI   0(R8),X'2A'             SOURCE OPERATOR EPSILON ?
         BNE   PBNHDL2                 NO
*                                      (=BRANCH IF OPTR IS PI OR PHI)
*
*        OPERATOR IS BETA OR EPSILON
*
PBNHDL1  IC    R2,1(,R8)
         LA    R8,1(,R8)
PBNHDL2  LH    R1,SPBNST               STORE
         SLL   R1,1                    OLD
         STH   R7,PBTAB2(R1)           P-VALUE
         STC   R2,SPBNST+1             INSERT NEW PBN
         SLL   R2,1                    GET DISP IN PBTAB2
         LH    R7,PBTAB2(R2)           LOAD NEW P VALUE
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BOR   R4                      YES, RETURN
         B     CLEARRG                 CLEAR REGISTERS RETURN DIRECT
*
***********************************************************************
*
*        PLPRST - PARAMETERLESS PROCEDURE STATEMENT HANDLING
*
***********************************************************************
*
* CALL   BAL   R4,PLPRST
*
*        CHECKS THAT OPERAND IS A PARAMETERLESS PROCEDURE
*
PLPRST   ST    R4,STRETURN             SAVE RETURN ADDR
         BAL   R4,DECOMP               DECOMPOSE OPERAND
         TM    1(R9),X'C0'             PROCEDURE IDENTIFIER ?
         BZ    PLPRST4                 NO, ERROR
         LH    R4,OPDADR
         SRL   R4,12                   GET NUMBER OF PARAMETERS
         LTR   R4,R4                   NUMBER ZERO ?
         BZ    PLPRST1                 YES, BRANCH
PLPRST0  BAL   R4,SERR1                ERROR
         DC    H'187'
*
         B     PLPRST3
*
PLPRST4  BAL   R4,SERR3                ERROR
         DC    H'183'
*
         B     PLPRST3
*
PLPRST1  TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    PLPRST3                 YES, BRANCH
         BAL   R4,OPDREC               OPERAND RECOGNIZER
         TM    3(R9),REGADRM           OPERAND IN ADR
         BZ    PLPRST3                 NO
         SH    R7,ONEENTRY             RELEASE STACK
         XI    RII,RIIADRM             ADR NOT OCCUPIED
PLPRST3  L     R4,STRETURN             LOAD RETURN ADDR
         BR    R4
*
***********************************************************************
*
*        SUBROUTINE - LOAD VPLACE, WPLACE
*
***********************************************************************
*
* CALL   BAL   R4,LDVWPLC
*
LDVWPLC  ST    R4,LDRET
         BAL   R4,OPDREC               ERAND RECOGNIZER
         TM    0(R9),X'20'             ADDR OR VALUE ?
         BO    LDVW1                   ADDR
         TM    0(R9),X'40'             VALUE IN REG ?
         BO    LDVW3                   NO
         SR    R4,R4
         IC    R4,3(,R9)               GET REG NUMBER
         SRL   R4,4
         SLL   R4,1                    DOUBLE IT
         TM    1(R9),X'01'             VALUE INTEGER ?
         BZ    LDVW4                   NO
         SLL   R4,1                    YES, 4 TIMES REG NUMBER
         ST    R9,RUTI(R4)             INTRODUCE CORRECT R9 ADDR
         B     LDVW3
*
LDVW4    ST    R9,RUTR(R4)             INTRODUCE CORRECT R9 ADDR
LDVW3    BAL   R4,CLEARRG              CLEAR REGISTERS
         BAL   R4,ROUTINE1             USE ROUTINE 1 TO LOAD VW-PLACE
         B     LDVWR
*
LDVW1    CLI   2(R9),X'00'             FUNCTION VALUE IN FSA
         BNE   LDVW1A
         ST    R9,RUTI+32              INTRODUCE CORRECT R9 ADDR
         CLI   0(R8),XFCOMMA           SOURCE OPERATOR COMMA
         BE    LDVW3                   YES
LDVW1A   TM    0(R9),X'40'             ADDR IN STACK ?
         BO    LDVW2                   YES
         MVI   VPLACE,X'88'            ADDR IN REG ADDR
         MVC   WPLACE(2),ZEROHW
         B     LDVWR
*
LDVW2    MVI   VPLACE,X'AA'            ADDR
         MVC   WPLACE(2),3(R9)         IN STACK
LDVWR    L     R4,LDRET
         BR    R4
*
LDRET    DC    F'0'
*
***********************************************************************
*
*        SUBROUTINES FOR MOVING STACK POINTERS
*
***********************************************************************
*
*        ENTRY FOR MOVING OPERATOR STACK PTR
*
MOVEOPTK LA    R10,1(R10)
         B     MOVERET
*
*        ENTRY FOR MOVING OPDSTACK POINTER
*
MOVEOPDK SH    R9,KH5
MOVERET  CR    R10,R9
         BNL   STACKOFL
         BR    R4
*
***********************************************************************
*
*        TARITHM
*
***********************************************************************
*
* CALL   BAL   R4,TARITHM
*
*        RETURN TO RETURN IF OPERAND INTEGER OR REAL
*        ELSE RETURN TO RETURN+4 AFTER ERROR MESSAGE 163 IS
*        GIVEN
*        CHECK FOR ARRAY OR PROCEDURE IDENTIFIER
*
APIMASK  EQU   X'10'
*
*        TEST IF OPERAND IS ARITHMETIC
*
TARITHM  TM    0(R9),APIMASK           API IN STACK
         BOR   R4                      YES, RETURN NO ERROR
         TM    1(R9),X'03'             OPERAND ARITHMETIC
         BM    PROGARR                 YES, CONTINUE CHECK
         ST    R4,SAVTRREI             SAVE RETURN
         BAL   R4,SERR2
         DC    H'163'                  ERROR 163
*
         L     R4,SAVTRREI
         B     4(R4)                   RETURN ERROR MESSAGE 163 GIVEN
*
PROGARR  LA    R1,4(R4)
         ST    R1,SAVTRREI             ERROR RETURN FROM ARRTEST
         B     ARRTESTA                CHECK FOR PROCEDURE OR ARRAY
*
***********************************************************************
*
*        LATRES
*
***********************************************************************
*
* CALL   BAL   R4,LATRES
*
*        RESERVE ONE ENTRY IN LABEL ADDR TABLE (LAT)
*        CHECK IF OVERFLOW
*
LATRES   LH    R1,LN                   GET CURRENT LN
         LA    R1,4(,R1)               ADD ONE ENTRY
         STH   R1,LN                   STORE NEW LN
*
*        CHECK IF LAT OVERFLOW
*
LATOVFLO TM    LN,X'F0'                LAT FULL ?
         BZR   R4                      NO
         ST    R4,LDRET                SAVE RETURN ADDR
         BAL   R4,SERR1                GENERATE ERROR PATTERN
         DC    H'216'
*
         LA    R1,LATBEG               RESET POINTER
         STH   R1,LN                   TO FIRST ENTRY
         L     R4,LDRET
         BR    R4
*
***********************************************************************
*
*        ARRAY AND PROCEDURE TEST
*
***********************************************************************
*
* CALL   BAL   R4,ARRTEST1
*
ARRTEST1 ST    R4,SAVTRREI             SAVE RETURN
*
*        ENTRY POINT FROM TARITHM
*
ARRTESTA TM    0(R9),APIMASK           OPERAND API ?
         BOR   R4                      YES, RETURN
         TM    1(R9),X'C0'             PROCEDURE ?
         BNM   ARRTESTT
         TM    1(R9),X'40'             STANDARD PROCEDURE
         BZ    PROCTES1                YES, ERROR
ARRTESTT TM    0(R9),X'C0'             IDENTIFIER FROM ITAB ?
         BNOR  R4                      NO, RETURN
         TM    1(R9),X'04'
         BZ    PROCTEST                NO, ARRAY CONTINUE TEST
         BAL   R4,SERR3
         DC    H'196'
*
ARRTEST3 L     R4,SAVTRREI             RESTORE RETURN
         BR    R4
*
PROCTEST TM    1(R9),X'C0'             PROCEDURE ?
         BZR   R4                      NO, RETURN
         TM    3(R9),X'F0'             PARAMETERLESS ?
         BZR   R4                      YES, RETURN
PROCTES1 BAL   R4,SERR1                ERROR 187
         DC    H'187'
*
         B     ARRTEST3
*
ARRTEST2 ST    R4,RETARR2
         LA    R9,5(,R9)
         BCTR  R10,0
         BAL   R4,ARRTEST1
         LA    R10,1(,R10)
         SH    R9,KH5
         L     R4,RETARR2
         B     ARRTEST1
*
RETARR2  DC    F'0'
*
***********************************************************************
*
*        OPERAND TEST
*
***********************************************************************
*
* CALL   BAL   R4,OPDTEST
*
*        GIVE ERROR MESSAGE 162 IF OPERAND IS MISSING
*        STACK ALL PURPOSE IDENTIFIER
*        RETURN VIA R4 IF NO ERROR RETURN VIA R3
*
OPDTEST  TM    COMPFLGS,OPERAND        OPERAND PRESENT ?
         BOR   R3                      YES, RETURN
         ST    R4,STRETURN
         BAL   R4,SERR4                ERROR 162
         DC    H'162'
*
         L     R4,STRETURN
         OI    COMPFLGS,OPERAND        OPERAND SWITCH ON
         B     STACKAPI                STACK API RETURN DIRECT
*
ERR166   ST    R4,RETADR               STORE RETURN ADDR
         TM    COMPFLGS,OPERAND        OPDT ?
         BZ    BYB2                    NO, BRANCH
         LA    R9,5(,R9)               CLOPD
         NI    COMPFLGS,255-OPERAND    OPDFL=FALSE
BYB2     BAL   R4,SERR1                ERROR 166
         DC    H'166'
*
         L     R4,RETADR               LOAD RETURN ADDR
         BR    R4                      RETURN
*
         TITLE 'IEX50 - COMPILATION PHASE, DECISION MATRIXES'
*
*        DECISION MATRICIES
*
*        START OF DECISION AREA
*
***********************************************************************
*
*        PROGRAM CONTEXT COLUMN VECTOR
*
***********************************************************************
*
DECAREA  DC    X'0A0A0A0A0A0A09120703030B000002020A0A0A0A0A0A080404'
         DC    X'121212120512060A0A0A0A0A121201120C0D0E0F1110000000'
*
***********************************************************************
*
*        PROGRAM CONTEXT ROW VECTOR
*
***********************************************************************
*
         DC    X'ABABABABABABABABABAB853926131313ABABABABABAB72ABAB'
         DC    X'ABABAB98ABABABABABABABAB00AB4C5FABABABABABAB000030'
*
***********************************************************************
*
*        PROGRAM CONTEXT MATRIX
*
***********************************************************************
*
         DC    X'00010454545454545454545454545454540354'
         DC    X'0001040407074B0707074B191810545453544B'
         DC    X'00011D1D06084B290C404B191C54541054544B'
         DC    X'00011A1A06084B290C404B171C17171754544B'
         DC    X'00011A1A064B11290C404B121C12121254544B'
         DC    X'00011A1A06084B290C404B121C12121254544B'
         DC    X'1B1E1A1A1B131429151616141C14141454544B'
         DC    X'5454545454545454555454541C545454545454'
         DC    X'00011D1D06084B290C404B1A1C54515454544B'
         DC    X'1F1E1F1F1F1F1F1F1F1F1F1F1C1F1F1F545416'
*
***********************************************************************
*
*        STATEMENT CONTEXT COLUMN VECTOR
*
***********************************************************************
*
ADRSTC   DC    X'090909090909010D030F0F0C0F0F0F0F0A0A0A0A0A0A060F0F'
         DC    X'0708070B000F0C0A0A0A0A0A05020F040E0C0C0C0F0F000000'
*
***********************************************************************
*
*        STATEMENT CONTEXT ROW VECTOR
*
***********************************************************************
*
         DC    X'D0D0D0D0D0D0D0B03040D0D0D0D0D0D0D0D0D0D0D0D0D00060'
         DC    X'8090A0D0D0D0D0D0D0D0D0D0D0D0D0D02050D0C07010000033'
*
***********************************************************************
*
*        STATEMENT CONTEXT MATRIX
*
***********************************************************************
*
         DC    X'22384B294B4B4B4B4B4B4B4B3E4B1C1B'
         DC    X'22384B294B3B544B4B4B4B4B1B543B1B'
         DC    X'224039294B394B4B4B21214B1B4B1C1B'
         DC    X'22404B2926264B4B4B214B4B1B4B1C1B'
         DC    X'5454543454345454545454541B543654'
         DC    X'22403D294B3D4B4B4B21214B1B4B1C1B'
         DC    X'4B4B4B294B4B284B4B4B4B1B1B4B1C1B'
         DC    X'22404B294B2B4B2B4B214B2B1B4B1C1B'
         DC    X'22404B294B4B4B4B2D214B1B1B4B1C1B'
         DC    X'22404B294B2F4B4B4B214B2F1B4B1C1B'
         DC    X'22404B294B314B4B4B2121311B4B1C1B'
         DC    X'22404B2933334B4B4B214B4B1B4B1C1B'
         DC    X'22404B294B4B544B4B214B4B1B241C1B'
         DC    X'224B4B4B4B4B4B4B4B4B4B4B474B1C47'
*
***********************************************************************
*
*        EXPRESSION CONTEXT COLUMN VECTOR
*
***********************************************************************
*
ADREXC   DC    X'0B0B0C0C0C0D050F070F0F0F0F0F0F0F0E0E0E0E0E0E0F0F0F'
         DC    X'0F0F0F0F08090A00020304010F060F0F0F0F0F0F0F0F000000'
*
***********************************************************************
*
*        EXPRESSION CONTEXT ROW VECTOR
*
***********************************************************************
*
         DC    X'A0A0B0B0B0C050E0E0E0E0E0E0E0E0E0D0D0D0D0D0D0E0E0E0'
         DC    X'E0E0E0E06070800020304010E060E0E0E0E090E0E0E000003F'
*
***********************************************************************
*
*        EXPRESSION CONTEXT MATRIX
*
***********************************************************************
*
         DC    X'4B4D4D4D4D404D29494D4D424343434D'
         DC    X'414C434343404C29494C4C424343434C'
         DC    X'414C4C4343404C29494C4C424343434C'
         DC    X'414C4C4C43404C29494C4C424343434C'
         DC    X'414C4C4C4C404C29494C4C424343434C'
         DC    X'4143434343404429501B1B424343431B'
         DC    X'4143434343404B29414E56424343431B'
         DC    X'4143434343404B29494B57424343431B'
         DC    X'4143434343404F29414F48424343434F'
         DC    X'4B3F3F3F3F403F29493F3F3F3F433F3F'
         DC    X'4B454545454045294945454543434545'
         DC    X'4B454545454045294945454545434545'
         DC    X'4B454545454045294945454545454545'
         DC    X'4B454545454045294945454243434A45'
         DC    X'4143434343404629464B464243434346'
*
         TITLE 'IEX50 - COMPILATION PHASE, WORKAREA DSECT'
*
*        THIS MODULE HAD ITS OWN INLINE VERSION OF THE WORKAREA
*        WHICH HAD ITS OWN VARIABLES APPENDED ONTO THE END LIKE
*        IEX40. THE INLINE VERSION HAS BEEN DELETED AND HAVE
*        INSTEAD INSERTED A COPY WORKAREA. THIS WILL NEED TO HAVE
*        ADDITIONAL VARIABLES APPENDED AS THEY ARE DISCOVERED BY
*        DISASSEMBLY AND PICKED UP FROM IEX40
*
WORKAREA DSECT
*
         COPY  WORKAREA
         COPY  WAEXT
         ORG   SAVEAREA
         COPY  FSAREA                  COPY RUNTIME DSECT
*                                      FOR OP CODE GENERATION OFFSETS
         COPY  IEX50002                IEX50002 (RECOVERED)
         COPY  IEX5000C                IEX50003 (RECOVERED) INIT
         COPY  IEX50003                IEX50003 CONTINUATION
         COPY  IEX50004                IEX50004
         COPY  IEX50005                IEX50005
         COPY  IEX50006                IEX50006
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
