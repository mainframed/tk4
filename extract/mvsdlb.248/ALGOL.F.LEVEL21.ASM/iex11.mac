X11      TITLE 'IEX11 - SCAN I/II, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        TO TRANSFORM THE SOURCE PROGRAM TO MODIFICATION LEVEL 1,
*        WHICH INCLUDES A ONE FOR ONE TRANSLATION OF ALL
*        CHARACTERS, THE REPLACEMENT OF ALL ALGOL DELIMITERS BY
*        ONE BYTE OPERATORS AND THE REMOVAL OR MODIFICATION OF
*        ALL DECLARATIONS
*        1. TABULATE AND CLASSIFY ALL VALID IDENTIFIERS
*        2. ASSIGN A SERIAL PROGRAM BLOCK NUMBER TO ALL BLOCKS
*           AND PROCEDURES AND A SERIAL GROUP NUMBER TO ALL BLOCKS,
*           PROCEDURES AND FOR STATEMENTS
*        3. RECOGNIZE SYNTACTICAL ERRORS IN THE SOURCE PROGRAM
*           AND TO GENERATE APPROPRIATE ERROR PATTERNS
*        4. PRINT A LISTING ON SYSPRINT OF THE SOURCE PROGRAM IF
*           OPTION SOURCE IS SPECIFIED
*        5. PREPARE TABLES TO BE USED BY THE SUCCEEDING PHASES.
*           THE TABLES ARE PBTAB1, GROUPTABLE, AND SCOPETABLE
*
*        ENTRY POINTS -
*        IEX11000 SCAN I/II XCTL EP=IEX11000
*
*        INPUT - THE SOURCE PROGRAM IS READ IN FROM SYSIN
*
*        OUTPUT -
*        1. THE SOURCE PROGRAM, MODIFICATION LEVEL 1, IS WRITTEN
*           ON SYSUT1
*        2. AN ITAB RECORD IS WRITTEN FOR EACH BLOCK ON SYSUT3
*        3. ESD CARD FOR THE OBJECT MODULE AND TXT CARDS FOR THE
*           CONSTANTS 0 THROUGH 15 AND THE STRINGS IN THE CONSTANT
*           POOL ARE WRITTEN ON SYSLIN AND OR SYSPUNCH IF THE
*           OPTIONS LOAD AND OR DECK IS SPECIFIED
*        4. THE SOURCE PROGRAM IS LISTED ON SYSPRINT IF THE
*           SOURCE OPTION IS SPECIFIED
*
*        EXITS - NORMAL -
*        CONTROL IS GIVEN TO ITAB MANIPULATION, XCTL EP=IEX20000
*        IF NO TERMINATING ERROR HAS BEEN DETECTED
*
*        EXITS - ERROR -
*        IF A TERMINATING ERROR HAS BEEN DETECTED CONTROL IS
*        GIVEN TO THE ERROR MESSAGE HANDLING PHASE XCTL
*        EP=IEX21000
*
*        EXTERNAL ROUTINES - THE PRINT ROUTINE IN IEX00 IS USED
*
*        TABLES/WORKAREAS -
*        BPRTAB   - BRANCH ADDR TABLE
*        TESTTABL - FOR MAINLOOP SCANNING
*        TRINTEXT - FOR TRANSLATION FROM INTERNAL TO EBCDIC
*                   CHARACTER SET
*        COMTABLE - USED BY COMMENT PROGRAM
*        STRTABLE - USED BY STRING PROGRAM
*        BTABLE   - USED BY BLANK PROGRAM
*        KEYTAB   - USED BY TRANSOP
*        PTTABLE  - USED BY POINT AND POINT IN LIST PROGRAMS
*        TREXTINT - FOR TRANSLATION FROM EBCDIC TO INTERNAL
*                   CHARACTER SET
*        KFCONST  - CONTAIN THE FULL WORD CONSTANTS 0 THROUGH 15
*        ATABLE   - USED BY APOSTROF
*        SCTAB    - USED TO SAVE THE STARTING SEMICOLON COUNTER
*                   FOR THE BLOCKS
*        KEYWTAB  - TABLE OF ALGOL KEYWORDS
*        KWLUTAB  - DISPLACEMENTS INTO KEYWTAB
*        DELPRGTB - BRANCH ADDR TABLE AFTER A DELIMITER HAS
*                   BEEN FOUND
*        ARTABLE  - USED BY LIST PROGRAM
*        WA       - 80 BYTE WORKAREA WITH 17 PRECEEDING CHARACTERS,
*                   USED FOR INPUT RECORDS. THE 17 EXTRA BYTES USED
*                   TO OVERLAP BETWEEN ONE RECORD AND THE NEXT ONE
*        STACK    - USED FOR THE SCOPE STRUCTURE HANDLING
*        ITAB     - USED TO TABULATE ALL VALID IDENTIFIERS
*        SAVEPRT  - DUMMY PRINTAREA. USED TO PICK UP STRINGS FROM
*                   IN EBCDIC FORM IF THE OPTION 'NOSOURCE'
*                   IS SPECIFIED
*
*        NOTES -
*        CHARACTER CODE DEPENDENCE IF THE SOURCE PROGRAM IS IN
*        ISO CODE A SCAN IS MADE IN THE PROGRAM CIB TO EXCHANGE
*        THE CHARACTERS -
*        4C, 7B, 7C, 6C, 50,
*        WITH THE EBCDIC CHARACTERS -
*        5D, 7E, 7D, 4D, 4E
*        THEN WHEN THE SOURCE PROGRAM IN WA IS IN EBCDIC FORM IT
*        IS TRANSFERRED TO THE PRINTBUFFER, POSSIBLY THE DUMMY
*        PRINTAREA. THE SOURCE PROGRAM IN WA IS THEN TRANSLATED
*        TO INTERNAL CODE BY MEANS OF THE HEXADECIMAL TABLE
*        TREXTINT. THE INVERSE TABLE, TRANSLATING FROM INTERNAL TO
*        EBCDIC CODE, IS CALLED TRINTEXT AND IS IN CHARACTER FORM.
*        THE TRANSFER OF PRECOMPILED AND CODE PROCEDURE NAMES,
*        THE TRANSFER OF STRINGS AND CONSTANTS TO THE CONSTANT
*        POOL AND THE OPERATION OF THE ROUTINE GENERATE DEPENDS
*        ON AN INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER
*        SET WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY
*        TIME. THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND
*        UPON A PARTICULAR INTERNAL REPRESENTATION OF THE
*        EXTERNAL CHARACTER SET
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER.
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
*        INITIALIZATION
*        MAINLOOP AND ITS SUBPROGRAMS
*        BLANK
*        TRANSOP (*,/,(,>,<,NOT,)
*        RIGHTPAR
*        POINT
*        COLON
*        LABEL
*        LETDEL
*        ASSIGN
*        APOSTROPHE
*        SCALE
*        BLKAPOS
*        ZETAAPOS
*        NPAFAPO (NOT PERMITTED)
*        SOME GENERAL ROUTINES
*        STATE (STATEMENT PROGRAM)
*        ERROR ROUTINES
*        ITABCLEA
*        IDCHCK1
*        FINDSEMCO
*        AND TABLES AND CONSTANTS OUTSIDE CWA
*
*        COB (CHANGE OUTPUT BUFFER)
*        CIB (CHANGE INPUT BUFFER)
*        DELIMITER EROUT (DELIMITER ERROR ROUTINE)
*        NORMAL (/ OR AND NOT STEP LESS IMPL UNTIL WHILE POWER
*        EQUIU
*        NOTLESS GREATER NOTEQUAL NOT GREATER)
*        BOLCON ('TRUE', 'FALSE')
*        GIF (GOTO, IF)
*        TED (THEN, ELSE, DO)
*        BEGIN
*        BEGI (BLOCKHEAD)
*        END
*        FOREND
*        PBLCKEND
*        COM (COMMENT)
*        FOR
*        TYPE (REAL, INTEGER, BOOLEAN)
*        IER (IDENT ERROR ROUTINE)
*        CODE
*
*        IDCHECK (SPECIFIED IDENTIFIERS)
*        VALUE
*        TYPEARRAY
*        ARRAY
*        TRATE (ARRAY AND SWITCH LIST)
*        PONTLST
*        SEMCLST
*        LEFTPARL
*        RIGHTPARL
*        SLASHLST
*        COMMALST
*        COLONLST
*        SWITCH
*        STRING
*        TYPPROC
*        PROCEDURE
*        PROCEDEL (PROC LETTERSTRING)
*        ENDMISSIN (UNBALANCED BEGIN END COUNT)
*
*        TERMINATION
*
IEX11000 CSECT
*
*        R3                       OUTPUT POINTER
*        R4                       POINTS TO FIRST APOSTROPHE
*        R4                       TRANSOP REGISTER
*        R4                       LINK REGISTER FOR PRGBLOCKEND
*        R4                       LINK REGISTER FOR FDREND
*        R6                       RETURN REG FROM ERROR ROUTINES
*        R7                       ITAB POINTER
*        R8                       BASE REGISTER
*        R9                       RETURN REGISTER FROM BEGI
*        R10                      TESTLOOP AND LIST MAIN RETURN REG
*        R11                      BASE REGISTER
*        R12                      SPECIFICATION HANDLING
*        R12                      RETURN REG FROM COB
*        R14                      LABEL POINTER
*
*        INITIALIZATION
*
*        GETMAIN FOR -
*        1. KOPOOL
*        2. STACK
*        3. ITABBUF
*        4. OUTPUTAREA2
*        5. ITAB
*        ALPHA 00 IS PUT IN STACK AND SP (STACK POINTER) IS MADE
*        TO POINT TO NEXT BYTE
*        ADDR OF THE FIRST O/P AREA IS TAKEN FROM CWA AND PUT
*        IN ADDARI. THE ADDR OF SECOND O/P AREA (FROM
*        GETMAIN) IS PUT IN ADDARI+4
*        AITAB, LIGP, LPBP, AITAB AND ELI ARE INITILIZED IN
*        ITAB. HEADLINE FOR PB0 IS CREATED.
*        AITAB, LPBP, LIGP WILL POINT TO PB0 HEAD
*        AITL TO NEXT FREE ENTRY
*        ELI TO LAST POSITION+1 OF ITAB
*        APE WILL POINT TO LAST POSITION IN FIRST OUTPUT BUFFER
*        WADDARI (CURRENT OUTPUT BUFFER) WILL POINT TO FIRST
*        OUTPUT BUFFER
*        R3 WILL POINT TO FIRST O/P BUFFER
*        PRINTING OF HEADLINES IS INITIALIZED IF SOURCE WAS
*        SPECIFIED
*        SWITCHES ARE SET TO ZERO
*        FIRST ENTRIES IN TABLES ARE SET TO ZERO
*
         IEXENTRY 'IEX11000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX11000,R5,R8,R11
         LR    R5,R15
         LA    R8,2048(,R5)
         LA    R8,2048(,R8)
         LA    R11,2048(,R8)
         LA    R11,2048(,R11)
*
         USING WORKAREA,R13
         LA    R12,SLUT2
         ST    R12,ERET                INTERUPT BEFORE GETMAIN
         LH    R1,KH4096               KOPOOL
         LA    R1,1000(,R1)            STACK
         A     R1,SRCE1S               O/P BUFFER 1
         A     R1,ITAB10S              ITAB
         LA    R1,2000(,R1)            ITAB BUF
         ST    R1,POOLLEN              STORE TOTAL LENGTH
         LR    R0,R1
*
         GETMAIN R,LV=(0)              GET AREAS NEEDED
*
         ST    R1,POOLLOC              SAVE LOCATION
         LA    R12,ENDMISS             END OF DATA ADDR
         ST    R12,EODIN
         LA    R12,EODADIN
         ST    R12,ERET                ADDR AFTER GETMAIN
         ST    R1,AKOPOOL              ADDR OF KOPOOL
         LA    R1,4095(,R1)
         MVC   1(4,R1),KF0             INITIALIZE STACK
         LA    R1,2(,R1)
         ST    R1,SP                   ADDR OF SECOND BYTE IN STACK
         LA    R1,999(,R1)
         ST    R1,AITABBUF             INITIALIZE ITAB BUFFER
         LA    R1,2000(,R1)
         ST    R1,ADDARI+4                       OUTPUTAREA 2
         A     R1,SRCE1S
         ST    R1,AITAB                          ITAB
         ST    R1,LIGP                 SURROUNDING GROUP ADDR
         ST    R1,LPBP                             BLOCK ADDR
         MVI   0(R1),0                 CLEAR FIRST TWO ITAB ENTRIES
         MVC   1(21,R1),0(R1)
         MVI   3(R1),X'FF'             CONSTRUCT CONTINUATION
         MVI   5(R1),XFBLANK           LINE FOR PB0
         LA    R12,11(,R1)
         ST    R12,AITL                ADDR OF FIRST FREE ENTRY
         A     R1,ITAB10S
         ST    R1,ELI                  END OF ITAB
         L     R3,SRCE1ADD             ADDR OF FIRST OUTPUT BUFFER
         A     R3,SRCE1S
         BCTR  R3,0
         ST    R3,APE                  END OF FIRST O/P BUFFER
         L     R3,SRCE1ADD             OUTPUT AREAS CONSTANTS
         MVC   ADDARI(4),SRCE1ADD
         MVC   WADDARI(4),ADDARI       CURRENT O/P AREA ADDR
         LA    R12,SAVEPRNT            APRNTAR INITIALIZED WITH
         ST    R12,APRNTAR             DUMMY PRINT AREA ADDR
*
*        SETUP HEADING TEXT
*
         MVC   PAGEHD1D+30(L'HEAD1),HEAD1
         MVC   PAGEHD2D+4(L'HEAD2),HEAD2
         MVI   LINCNT+1,255            FORCE HEADINGS
         BAL   R9,CIB                  GET FIRST RECORD AND ADDR
*                                      OF FIRST PRINTAREA
         SR    R2,R2                   ZERO REG
         STC   R2,ONC                  ZERO COUNTERS
         STC   R2,DISP                 ZERO SWITCHES
         LA    R12,64
         ST    R12,PRPT                PROGRAM POINTER
         STH   R2,IGC                  ZERO ITAB GROUP COUNTER
         ST    R2,MGESITL
         STC   R2,PBC                  ZERO PROGRAM BLOCK COUNTER (PBC)
         STC   R2,ONC                  ZERO OUTPUT RECORD COUNTER (ONC)
         STC   R2,BITS1                ZERO SWITCHBITS
         STC   R2,BITS2
         STC   R2,BITS3
         STH   R2,SEMCNT               ZERO SEMICOLON COUNTER
         STC   R2,FSN                  ZERO FSN
         STC   R2,PBTAB1               ZERO PB0
         ST    R2,GPTAB+3              ZERO GROUP AND SCOUP TABLE
         STC   R2,SPTAB
         STC   R2,0(,R3)               FIRST BYTE IN FIRST OUTPUTRECD
         ST    R3,OPIN
         ST    R3,LAPIN                SET LABEL POINTERS
         STC   R2,OPIN+4
         LA    R12,GPTAB
         ST    R12,AGT                 ADDR TO GROUPTABLE
         L     R12,AITABBUF
         BCTR  R12,0
         ST    R12,ATOPSTAK            HIGHEST BYTE IN STACK TO USE
         B     TESTLOOP                GOTO START PROCESSING
*
EXMVC    MVC   0(1,R3),0(R4)
*
*        MAINLOOP
*
*        SCANS THE INPUT STREAM WHICH IS IN INTERNAL CODE
*
*        EVERYTHING PRECEDING THE FIRST REAL ALGOL WORD WILL BE
*        SKIPPED WITH THE HELP OF THE FALG BITS2, X'20'
*
TESTLOOP BALR  R10,0
         LR    R9,R10                  RETURN ADDR FOR CIB PROGRAM
         LR    R4,R1
         SR    R2,R2
         TRT   0(73,R1),TESTTABL       SCAN INTERNAL CODE WITH TESTTABL
         TM    BITS2,X'20'             FIRST BEGIN FOUND ?
         BZ    FIRSTSTR                NO
CONT     LR    R15,R1                  FIND LENGTH OF SCANNED BYTES
         SR    R15,R4
         BZ    SUBROUT
         BAL   R12,COB
         LA    R0,0(R15,R3)
         C     R0,APE                  SPACE LEFT IN O/P BUFFER ?
         BH    MSBLOOP
         BCTR  R15,0
         EX    R15,EXMVC               MOVE SCANNED BYTES
         LR    R3,R0                   INCREASE OUTPUT POINTER
SUBROUT  L     R6,BPRTAB(R2)
         BR    R6                      BRANCH TO PROGRAM
*
*        MSBLOOP
*
*        USED WHEN SCANNED BYTES HAS TO BE PLACED IN TWO O/P AREAS
*
MSBLOOP  L     R6,APE
         SR    R6,R3
         BCTR  R6,0
         EX    R6,EXMVC                MOVE TO FIRST O/P AREA
         LA    R3,1(R6,R3)
         BAL   R12,COBSPEB             CHANGE O/P BUFFER
         LA    R12,1(R6,R4)
         SR    R15,R6
         BCTR  R15,0
         BCTR  R15,0
         EX    R15,MOVERST             MOVE TO 2ND O/P BUFFER
         LA    R3,1(R15,R3)
         B     SUBROUT                 RETURN
*
MOVERST  MVC   0(1,R3),0(R12)
FIRSTSTR CLI   0(R1),XFQUOTE           QUOTE ?
         BE    APOSTROF
         CLI   0(R1),XFZETA            ZETA ?
         BE    CIB
         LA    R1,1(,R1)               IF NEITHER- CONTINUE SCANNING
         B     TESTLOOP
*
*        BLANK
*
*        SCANS TO THE NEXT NONBLANK CHARACTER
*        ALL BLANK CHARACTER WILL BE SKIPPED
*        USED BY MAIN LOOP AND ARRAYLIST
*
BLANK    LA    R1,1(,R1)               INCREASE INPUT POINTER
         CLI   0(R1),XFBLANK           BLANK ?
         BNER  R10                     NO, RETURN
         LA    R1,1(,R1)               YES, INCREASE INPUT POINTER
         SR    R2,R2
         TRT   0(73,R1),BTABLE         SCAN INPUT TO NEXT DELIMITER
         BR    R10                     RETURN
*
*        TRANSOP
*
*        CHECKS THE NEXT BYTE IN THE INPUT AREA AGAINS A
*        KEY IE IF ( FOUND, NEXT BYTE WILL BE CHECKED FOR /, IF
*        A SLASH IS FOUND A LEFT SQUARE BRACKET WILL BE
*        TRANSFERED OTHERWISE A (
*        USED BY MAIN LOOP AND ARRAYLIST
*
TRANSOP  LA    R4,KEYTAB(R2)           GET CORRECT ENTRY IN TABLE
INCR     LA    R1,1(,R1)
INCRA    CLC   0(1,R1),3(R4)           INPUT EQUAL EXPECTED ONE ?
         BE    TROE                    YES, TAKE SUBSTITUTE CHAR
         CLI   0(R1),XFBLANK           BLANK ?
         BE    INCR
         CLI   0(R1),XFZETA            ZETA ?
         BNE   TRONE                   IF NEITHER TAKE CHAR IN I/P
         LA    R9,INCRA
         B     CIB
*
TRONE    BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),2(R4)           TAKE CHAR FOUND IN INPUT
         LA    R3,1(,R3)
         BR    R10                     RETURN
*
TROE     BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),1(R4)           TAKE SUBSTITUTE CHAR FROM TABLE
         L     R12,BRACKET
         CLI   0(R3),XFRSQBR           RIGHT SQUARE BRACKET ?
         BNE   TSTMORE                 NO
         BCTR  R12,0                   YES, SUBTRACT 1 FROM CTR
         B     NOUPDAT
*
TSTMORE  CLI   0(R3),XFLSQBR           LEFT SQUARE BRACKET ?
         BNE   NOUPDAT                 NO
         LA    R12,1(,R12)             YES, INCR COUNTER
NOUPDAT  ST    R12,BRACKET
         LA    R3,1(,R3)
         LA    R1,1(,R1)
         BR    R10                     RETURN
*
*        RIGHTPAR
*
*        INSERTS A ) IN O/P, SETS THE LABEL POINTERS
*
RIGHTPAR BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFRBRAC           TRANSFER ) TO OUTPUT BUFFER
         ST    R3,OPIN                 NOTE ITS POSITION
         MVI   OPINCHAR,XFRBRAC
         MVC   OPIN+4(1),ONC           AND THE OUTPUT RECORD NUMBER
         LA    R3,1(,R3)
         ST    R3,LAPIN                NOTE POSITION WHERE LETTERSTRING
         LA    R1,1(,R1)               MAY START
         B     TESTLOOP
*
*        POINT
*
*        SCANS FOR -
*        DECPOINT
*        ERROR
*        COLON
*        SEMICOLON
*        ASSIGN
*        USED BY MAIN LOOP AND ARRAYLIST
*
POINT    LA    R1,1(,R1)               SCAN SOURCE STRING
         LA    R9,*                    RETURN ADDR FOR CIB PROGRAM
         SR    R2,R2                   CLEAR FUNCTION BYTE REG
         TRT   0(73,R1),PTTABLE        TO NEXT DELIMITER
         L     R6,BPRTAB(R2)           BRANCH TO SELECTED
         BR    R6                      SUBROUTINE
*
*        DECPOINT
*
*        TRANSFERS A DECIMAL POINT
*
DECPOINT BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFDECPT           TRANSFER DECIMAL POINT
         LA    R3,1(,R3)
         BR    R10
*
*        ASSIGN
*
*        TRANSFERS A ASSIGN CHAR TO O/P
*        RETURNS VIA STATEMENT
*
ASSIGN   BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFASSIGN          TRANSFER .= TO OUTPUTBUFFER
         LA    R1,1(,R1)               INCR INPUT POINTER
         LA    R3,1(,R3)               INCR OUTPUT POINTER
         B     STATE                   BRANCH TO STATEMENT PROGRAM
*
*        STATE
*
*        1. CHECKS WITH PROBIT IF FIRST LABEL, FOR, IF, GOTO OR
*           ASSIGN STATMENT AFTER A PROCEDURE
*        2. CHECKS THAT ALL PARAMETERS HAVE BEEN SPECIFIED
*        3. TURNS OFF THE PROBIT AND THE BEGBIT, POSSIBLE
*           PROCEEDING BEGIN WILL BE COMPOUND BEGIN
*
STATE    NI    BITS1,X'7F'             BEGBIT = 0
         L     R15,SP
         CLI   0(R15),X'0C'            PROC IN STACK ?
         BNER  R10                     IF NO RETURN
         MVI   0(R15),X'14'
         NI    BITS1,X'BF'             PROBIT.=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BER   R10                     YES, RETURN
         BAL   R12,ERROR10             NO, GENERATE E10
         BR    R10                     RETURN
*
*        APOSTROF
*
*        SCANS FOR -
*        SCALE
*        BLANK
*        ZETA
*        NOT PERMITTED
*        ONE MORE APOSTROPHE (DELIMITER)
*        R4 WILL POINT TO THE APOSTROPHE
*        USED BY TESTLOOP AND LIST
*
APOSTROF MVI   FBYTE,0                 ZERO FBYTE
ENTRAPR  LR    R4,R1                   R4 WILL POINT TO FIRST APOST
         LA    R1,1(,R1)
         BALR  R9,0
         SR    R2,R2
         TRT   0(73,R1),ATABLE         SOURCE STRING IS SCANNED TO
*                                      THE NEXT SIGNIFICANT DELIMITER
         L     R6,BPRTAB(R2)           R6 -> SELECTED SUBROUTINE
         BR    R6                      BRANCH TO ROUTINE SELECTED
*
*        SCALE
*
*        CORRECT ONLY DIRECT AFTER TESTLOOP OR LIST
*        CHECK THAT THE APOSTROPHE IS ONLY ONE CHAR IN FRONT OF
*        DIGIT
*
SCALE    TM    FBYTE,X'FF'
         BO    COMCEE2                 COMMENT UNDER PROCESS
         BM    TYPESPEC                DECLARATION UNDER PROCESS
SCALEOK  LR    R6,R1
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    TESTLOOP                NO, RETURN
         BCTR  R6,0
         CLI   0(R6),XFQUOTE           QUOTE ONE BYTE BEFORE SIGN
*                                      OR DIGIT ?
         BNE   EROUT                   IF NO, BRANCH TO ERROR ROUTINE
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
MOVETEN  MVI   0(R3),X'3F'             MOVE SCALE FACTOR TO OUTPUT REC
         LA    R3,1(,R3)               INCREASE OUTPUT
         BR    R10                     RETURN
*
*        BLKAPOS
*
*        SHIFT THE BLANK OR BLANKS AWAY AND MOVES THE QUOTE
*        AND VALID CHARACTERS UP TO THE RIGHT
*
*        SETS R4 TO POINT NEW LOCATION OF THE QUOTE
*        USED BY MAINLOOP AND INDIRECT BY THE ARRYLIST AND THE
*        NPAFTAPO
*
BLKAPOS  LR    R15,R1                  NOTE POSITION OF FIRST BLANK
BLKAPOSA TRT   0(73,R1),BTABLE
         LR    R6,R1                   CALC NUMBER OF BLANKS
         SR    R6,R15                  NUMBER OF BLANKS IN R6
         LR    R14,R15
         SR    R14,R4
         C     R14,KF11                BYTES EXCEED THE LIMIT ALREADY ?
         BH    EROUT
         BCTR  R14,0                   NUMBER OF BYTES TO BE SHIFTED
         LA    R15,0(R6,R4)            COMPUTE NEW POSITION OF QUOTE
         EX    R14,MAPOS               MOVE QUOTE AND SCANNED CHARS
         EX    R14,MAPOS2
         LR    R4,R15                  NOTE NEW POSITION OF QUOTE
         BR    R9                      RETURN
*
MAPOS    MVC   BUCKET(1),0(R4)
MAPOS2   MVC   0(1,R15),BUCKET
*
BUCKET   DC    11X'00'
*
*        ZETAAPO
*
*        MOVES SCANNED BYTES AND APOSTROPHE IN FRONT OF WA AND
*        PUTS R4 TO NEW START LOCATION OF POSSIBLE DELIMITER
*        USED BY MAINLOOP AND ARRAYLIST
*
ZETAAPO  LR    R15,R4                  COMPUTE
         LR    R14,R1                  NUMBER OF SCANNED
         SR    R14,R4                  BYTES
         C     R14,KF11                EXCEED LIMIT ?
         BH    EROUT                   YES
         LA    R4,WA                   NO, CALCULATE WHERE TO MOVE
         SR    R4,R14                  CHAR STRING
         BCTR  R14,0
         EX    R14,MOVBEFWA            MOVE CHAR IN FRONT OF WA
         B     CIB                     CHANGE INPUT BUFFER
*
MOVBEFWA MVC   0(1,R4),0(R15)
*
*        NPAFAPO
*
*        GIVES ERROR MESSAGE AND UTILIZES BLANKAPO TO SHIFT THE
*        INVALID CHARACTER AWAY
*        USED BY MAINLOOP AND ARRAYLIST
*
NPAFTAPO TM    FBYTE,X'FF'
         BM    TYPESPEC                INVALID IDENTIFIER
         BO    COMCED2                 COMMENT UNDER PROCESS
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    NPAFTAPA                NO, BYPASS ERROR MSG
         BAL   R6,ERR7
*
         DC    X'0401'                 E1
*
NPAFTAPA LR    R15,R1
         LA    R1,1(,R1)               GOTO BLKAPOS TO SHIFT AWAY
         B     BLKAPOSA                INVALID CHARACTER
*
*        COLON
*
*        ENTERD FROM MAINLOOP OR POINT
*        CHECKS FOR   :=  ASSIGN
*                     :(  DELIMITER
*                         LABEL
*
COLON    LR    R6,R1                   STORE PRECEEDING 6 CHARACTERS
         S     R6,KF6                  TO BE USED ONLY IF INCORRECT
         MVC   BUCKET(6),0(R6)         USE OF COLON E3
COLON2   LA    R1,1(,R1)               R1 -> NEXT INPUT CHAR
EQUAL    CLI   0(R1),XFEQUAL           COLON FOLLOWED BY EQUAL SIGN ?
         BE    ASSIGN                  BRANCH TO ASSIGN PROGRAM
         CLI   0(R1),XFLBRAC           COLON FOLLOWED BY LEFT BRACKET ?
         BE    LETDEL                  BRANCH TO DELIMITER PROCESSING
         CLI   0(R1),XFBLANK           COLON FOLLOWED BY BLANK ?
         BE    COLON2                  REPEAT SEARCH
         CLI   0(R1),XFZETA            COLON FOLLOWED BY ZETA ?
         BNE   LABEL01                 NO, BRANCH TO LABEL PROCESSING
         LA    R9,EQUAL                YES, PROVIDE RETURN ADDR
         B     CIB                     GET NEW INPUT BUFFER
*
*        LABEL
*
*        OPIN POINTS TO LAST OPERATOR WHICH MIGHT BE
*        FOLLOWED BY A LABEL
*        R14 IS THE POINTER, STEPPING UP BETWEEN LAPIN AND
*        THE COLON POINTED TO BY R3
*        OPIN+4 CONTAINS THE O/P REC NUMBER WHEN OPIN WAS SET
*        LABEL IS CHECKED FOR VALIDITY. THE FIRST 6 CHAR
*        ARE MOVED TO OUTPUT AND ITAB
*        CHECKS IF THE LABEL IS SPLIT OVER MORE THAN ONE
*        O/P BUFFER
*
*        IF THE LABEL IS SPLIT BY ONE O/P BUFFER END THE HANDLING
*        IS THE SAME AS IF NOT EXECPT THAT WHEN ZETA
*        IS FOUND R14 IS UPDATED TO THE FIRST CHARACTER OF THE
*        CURRENT O/P REC
*
*        E3 IF THERE IS NO LABEL
*        E6 IF LABEL LONGER THAN 1024 BYTES
*        E7 IF LABEL CONTAINS INVALID CHARACTER
*        E8 IF LABEL STARTS WITH INVALID CHAR
*
LABEL01  CLC   ONC,OPIN+4              LABEL EXCEEDS ONE O/P REC ?
         BE    LABEL                   NO
         SR    R4,R4
         IC    R4,OPIN+4
         LA    R4,1(,R4)
         IC    R2,ONC
         CR    R2,R4                   LABEL EXCEEDS 2 O/P REC ?
         BE    LABEL                   NO
         BAL   R6,ERR4
*
         DC    X'0406'                 TERMINATING ERROR
*
LABEL    L     R14,LAPIN
         CR    R3,R14                  ANY IDENTIFIER ?
         BE    ERROR3                  E3 COLON DELETED
         CLI   OPINCHAR,XFRBRAC        LABEL PROCEEDED BY RIGHT BRACK ?
         BE    ERROR3                  YES, E3 IS GIVEN
LABNAME  CLI   0(R14),XFA              FIRST CHAR SPECIAL OR NUMERIC ?
         BL    LABNAMER                YES, BRANCH, NOT LETTER
         L     R7,AITL                 NO, LETTER
         MVC   0(1,R7),0(R14)          MOVE CONTENTS OF R14 TO ITAB
         LA    R7,1(,R7)               INCR R7
         LA    R2,1                    INITIALIZE R2 WITH 1
LABID    LA    R14,1(,R14)             GET NEXT CHAR
         CR    R14,R3                  R14 = R3 ?
         BE    LABEND
LABCHECK CLI   0(R14),XFZETA           ZETA ?
         BNE   LABCHK1                 NO, BRANCH
         L     R14,WADDARI             GET START OF CURRENT O/P AREA
         B     LABCHECK
*
LABCHK1  BL    ERROR7
         C     R2,KF6                  R2 = 6 ?
         BE    LABID                   YES, DON'T MOVE MORE CHAR TO
*                                      ITAB
         MVC   0(1,R7),0(R14)          MOVE CONTENT OF PINTOIN
         LA    R7,1(,R7)               INCR R7, R2
         LA    R2,1(,R2)
         B     LABID
*
LABNAMER CLI   0(R14),XFZETA           ZETA ?
         BNE   LABNAM01                NO, BRANCH
         L     R14,WADDARI             UPDATE R14 TO CURRENT O/P BUFFER
         B     LABNAME
*
LABNAM01 CLI   0(R14),XFBLANK          BLANK ?
         BE    LABNAME                 YES, BRANCH
         BAL   R6,ERR7
*
         DC    X'0408'                 E8
*
         B     ERROR7A
*
ERROR7   BAL   R6,ERR2
*
         DC    X'0007'                 E7 INCORRECT LABEL
*
ERROR7A  L     R15,AITL
         BAL   R12,ITABCLEC            CLEAR THE ITAB ENTRY
         BR    R10
*
*        LABEND
*
*        IF (LABEL:LABELX) THE LN (LABEL NUMBER) WILL ONLY BE
*        INCREASED ONCE
*        INTERNAL NAME IS CREATED AND LN INSERTED
*        X'27' IS MOVED TO THE O/P TO INDICATE LABEL OPIN,
*        OPIN+4 AND LAPIN ARE UPDATED
*        ITABCLEA IS ACTIVATED TO PREPARE NEXT ITABENTRY
*
LABEND   CLI   OPINCHAR,XFLABEL        +. LABEL PRECEEDED BY LABEL
         BE    LABLAHEI                YES, DO NOT UPDATE LN
         LH    R15,LN                  LN = LN+4
         LA    R15,4(,R15)
LABCREAT CLC   LN(2),KH4096            LN = 2**12 ?
         BL    LABCRT01
         BAL   R6,ERR7
*
         DC    X'04D8'                 E216
*
         LA    R15,LATBEG              RESET LN
LABCRT01 STH   R15,LN
LABLAHEI L     R15,AITL
         MVI   6(R15),X'CC'            CREATE INTERNAL NAME
         MVI   7(R15),X'08'
         L     R14,LPBP
         MVC   8(1,R15),10(R14)        PROGRAM BLOCK NR AITL + 7
         MVC   9(2,R15),LN             LN IN AITL+9
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLABEL           MOVE LABEL IND TO O/P
         ST    R3,OPIN                 SET LABEL POINTERS
         MVI   OPINCHAR,XFLABEL
         MVC   OPIN+4(1),ONC
         LA    R3,1(,R3)
         ST    R3,LAPIN
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         B     STATE                   RETURN VIA STATEMENT PCM
*
*        LETDEL
*
*        :( HAS BEEN FOUND IN THE I/P
*        IF OPIN POINTS TO A RIGHT PARENTHESIS IT SHOULD BE
*        LETTER DELIMITER, WHICH SHOULD BE REMOVED AND REPLACED
*        BY A COMMA
*        IT IS CHECKED THAT ALL CHARACTERS ARE LETTERS OTHERWISE
*        E3 IS GIVEN
*
LETDEL   CLI   OPINCHAR,XFRBRAC        OPIN POINTS TO A RIGHT BRACKET ?
         BNE   ERROR3                  NO, E3, COLON DELETED
         CLC   ONC(1),OPIN+4           LETDEL EXCEEDS ONE O/P REC ?
         BNE   LETDELB2                YES
         L     R14,OPIN
         LA    R6,1(,R14)
         CR    R6,R3                   AT LEAST ONE CHAR ?
         BE    ERROR3                  NO, E3 DELETE COLON
LETDELE1 LA    R14,1(,R14)             OTHER CHAR THAN
         CLI   0(R14),XF9              LETTERS ?
         BNH   ERROR3
         LA    R6,1(,R14)
         CR    R6,R3                   ALL CHAR CHECKED ?
         BNE   LETDELE1                NO, CHECK NEXT
         L     R3,OPIN                 SET O/P POINTER TO BEGINING OF
         MVI   0(R3),XFCOMMA           THE STRING, MOVE IN A COMMA
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT CHAR
         BR    R10
*
*        DELIMITER EXCEEDS ONE O/P RECORD
*
LETDELB2 SR    R6,R6                   DOES THE STRING
         IC    R6,OPIN+4               EXCEED 2 O/P RECORDS ?
         LA    R6,1(,R6)
         IC    R2,ONC
         CR    R6,R2
         BE    LETDEL01                NO
         BAL   R6,ERR4
*
         DC    X'0404'                 E4  GOES TO COMPFIN
*
LETDEL01 L     R14,OPIN                MAKE R14 POINT TO LETTER DEL
LETDELB3 LA    R14,1(,R14)
         CLI   0(R14),XFA              LETTER ?
         BNL   LETDELB3                YES
         CLI   0(R14),XFZETA           NO, ZETA ?
         BNE   ERROR3
         L     R14,WADDARI             CHANGE BACK SO R14 POINT
*                                      TO CURR.O/P
LETDELF4 CLI   0(R14),XFA              LETTER ?
         BL    ERROR3                  E3 DELETE COLON
         LA    R14,1(,R14)             SKIP ALL LETTERS
         CR    R14,R3                  UNTIL END OF DELIMITERS
         BNE   LETDELF4
         L     R3,WADDARI              LOAD ADDR OF CURRENT O/P REC
         MVI   0(R3),X'3D'             MOVE IN $ RHO
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT CHAR
         BR    R10
*
*        SEMCO
*
*        IF THE DELTA BIT IS ON, THE DELTA AND SEMICOLON COUNTER
*        (SEMCNT) IS MOVED TO THE OUTPUT
*        IF THE DELTABIT IS OFF THE STACK IS INSPECTED
*
*        BEGIN, BETA OR PROC* -
*        A SEMICOLON AND THE SEMCNT IS MOVED TO THE O/P AND
*        PROCESSING IS CONTINUES VIA TEST
*
*        FOR -
*        THE FORSTATMENT IS COMPLETE, THE FOREND PROGRAM IS
*        ACTIVATED
*        THE RETURN IS TO STACKTST TO SEE IF ONE MORE FOR
*        STATEMENT OR A PROC** HAS ENDED AT THE SAME TIME
*
*        PROC -
*        A PROCEDURE CONSISTING OF ONLY ONE STATMENT OR A DUMMY
*        STATMENT HAS ENDED IT IS CHECKED THAT ALL PARAMETERS
*        HAVE BEEN SPECIFIED, AND THE PROC** PGM IS JOINED
*
*        PROC** -
*        A PROCEDURE CONSISTING OF ONE LABELED STATEMENT OR ONE
*        FOR, IF, GOTO OR ASSIGN STATEMENT HAS ENDED
*        THE PROGRAM BLOCKEND PROGRAM IS ACTIVATED AND A DELTA
*        AND THE SEMCNT IS MOVED OUT
*
*        THE FINAL EXIT IS IN ALL CASES TO TEST
*
SEMC60   OI    COMPFLGS+2,SET60        SET SWITCH FOR 60 CHAR SET
SEMCO    LH    R4,SEMCNT
         C     R4,SCOVFL               TEST SEMICOLON OVERFLOW
         BL    SEMCO01
         BAL   R6,ERR7
*
         DC    X'0411'                 E17
*
         MVC   SEMCNT,KF0              ZERO SEMICOLON COUNT
SEMCO01  LA    R4,1(,R4)               INCR SEMICOLON COUNTER
         STH   R4,SEMCNT
         LA    R0,3(,R3)               PROVIDE 3 BYTES IN OUTPUT BUF
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         NI    BITS3,FMOFF
         TM    BITS1,X'20'             TEST DELTABIT
         BO    DELTA                   ON, BRANCH TO DELTA TRANSFER
         LA    R4,STACKTST             RETURN REG (FOREND, PBLCKEND)
         L     R15,SP
         IC    R2,0(,R15)              SELECT BRANCH ADDR
         L     R6,PROG2(R2)            DEPENDING ON WHAT IS IN STACK
         BR    R6
*
PROG2    DC    A(ERR8)                 +00 ALPHA   SHOULD NOT OCCUR
         DC    A(SCTRANS)              +04 BETA
         DC    A(SCTRANS)              +08 BEGIN
         DC    A(SEMPROC)              +12 PROC
         DC    A(SCTRANS)              +16 PROC*
         DC    A(SEMPROC2)             +20 PROC**
         DC    A(FOREND)               +24 FOR
*
DELTA    NI    BITS1,X'DF'             DELTA BIT= 0
         MVI   0(R3),XFDELTA           TRANSFER DELTA
         B     SCTRANSA
*
SCTRANS  MVI   0(R3),XFSCOLON          TRANSFER SEMICOLON
SCTRANSA MVI   OPINCHAR,XFSCOLON
         ST    R3,OPIN                 NOTE POS OF SEMICOLON IN OPIN
         MVC   OPIN+4(1),ONC           AND O/P NO
         MVC   1(2,R3),SEMCNT          TRANSFER SEMICOLON COUNTER
         LA    R3,3(,R3)               INCREASE OUTPUT POINTER
         ST    R3,LAPIN
         NI    BITS1,X'7F'             BEGBIT.=0
         LA    R1,1(,R1)               INCREASE INPUT POINTER
         B     TESTLOOP
*
SEMPROC  NI    BITS1,X'BF'             PROBIT.=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED
         BE    SEMPROC2
         BAL   R12,ERROR10
SEMPROC2 BAL   R4,PBLCKEND
         LA    R0,3(,R3)               PROVIDE 3 BYTES IN OUTPUT BUF
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),XFDELTA           TRANSFER DELTA
         B     SCTRANSA
*
STACKTST CLI   0(R15),X'14'
         BE    SEMPROC2                PROC**
         BH    FOREND                  FOR
         LA    R0,3(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         B     SCTRANS
*
*        ERROR ROUTINE
*
*        GENERATES ERROR PATTERNS
*
*        MAINLY CLOSED SUBROUTINES, ENTERED WITH BAL R6
*        FOLLOWED BY TWO BYTES. FIRST BYTE SPECIFIES THE LENGTH,
*        IF KNOW AND SECOND BYTE ERROR NUMBER.
*        USES ERROR1 TO CHECK FOR ERRORPOL OVERFLOW AND TO
*        INSERT NUMBER, LENGTH AND SEMCNT
*
*        ERR0
*
*        GENERATES E212 PATTERN
*        EXITS TO COMFIN
*
ERR0     MVI   0(R15),X'02'
         MVI   1(R15),X'D4'            E212
         LA    R15,2(,R15)
         ST    R15,NEXTERR
         B     COMPFIN
*
*        ERR1
*
*        E1
*        ACTIVATES ERR7, SKIPS INVALID CHARACTER AND RETURNS TO
*        EITHER TESTLOOP OR LIST
*        ENTERED VIA BPRTAB WHEN USED BY TESTLOOP OR LIST
*        INVALID CHARACTER FOLLOWING AN APOSTROPHE IS TREATED
*        SPECIALLY IN NPAFTAPO
*
ERR1     BAL   R6,ERR7                 NOT PERMITTED CHARACTER
*
         DC    X'0401'                 E1
*
         LA    R1,1(,R1)
         BR    R10                     RETURN TO TEST OR TRATE
*
*        ERR2
*
*        ERR2      7, 16, 31, 32, 33, 34
*             ENTERED   ERROR7, IER, ARRAYERR, SWITCHERR
*                       SLASHERR, SEMCLST, SEMCLER, ARRYSLSH
*                       SLASHLST, PNAMERR
*             NAME TAKE FROM AITL
*        ERR2B          10, 36, 37
*                       ERROR10, PROCFIN, ERROP37
*             NAME TAKEN FROM LPBP-11
*        ERR2C     14
*                       EROUT
*             DELIMITER TAKEN FROM BUCKET
*        ERR2E     16, 26, 27, 30
*                       IDVALCHK, VALDLB2, IDSELSE, NOTFOUND
*             NAME TAKEN FROM IDBUCKET
*        ERR2D UTILISES ERROR2 TO FIND LENGTH
*                       ERROR1 TO CREATE MESSAGE
*                       MOVES IN INFORMATION
*                       RETURNS TO CALLING SEQUENCE
*
ERR2     L     R7,AITL                 NAME FROM AITL
         B     ERR2D
*
ERR2B    L     R7,LPBP                 NAME FRM LPBP-11
         S     R7,KF11
         B     ERR2D
*
ERR2C    MVC   BUCKET(6),1(R4)         DELIMITER FROM BUCKET
         LA    R7,BUCKET
         B     ERR2D
*
ERR2E    LA    R7,IDBUCKET             E26 NAME FROM IDBUCKET
ERR2D    STM   R12,R15,ERRSAVE
         BAL   R12,ERROR2              GET NAME AND LENGTHS
         BAL   R12,ERROR1              CREATE ENTRY IN ERRPOOL
         EX    R2,ERRMOVE              MOVE THE NAME
         LM    R12,R15,ERRSAVE
         B     2(,R6)
*
*        ERROR3
*
*        GENERATES PATTERN FOR E3
*        ENTERED FROM LABEL, COLONLST
*        TAKES INFORMATION FROM BUCKET
*
ERROR3   STM   R12,R15,ERRSAVE         GET PARAMETER FIELD
         LA    R6,PARAM3
         BAL   R12,ERROR1              CREATE PATTERN
         MVC   4(6,R15),BUCKET         MOVE IN INFORMATION
         LM    R12,R15,ERRSAVE
         BR    R10
*
PARAM3   DC    X'0A03'
*
*        ERR4
*
*        PROCESS ALL TERMINATING ERRORS THAT ARE 4 BYTTES LONG
*
*        NO - 4, 6, 20, 22, 38, 41, 44, 213, 215, 216
*        ENTERED FROM - LABEL, ITABCLEA, COB, BEGIN, BEG1,
*                       PBLCKEND, FOR, PROCEDUR, ENDMISS
*        EXITS TO COMPFIN
*
ERR4     BAL   R12,ERROR1
*
*        COMPFIN
*
*        TERMINATING ERROR HAS BEEN FOUND
*        SETS TERR IN COMPFLGS
*        EXITS TO KOPOOLRL IN TERMINATION
*
COMPFIN  OI    COMPFLGS,TERR           SET TERMINATING ERROR BIT
         B     KOPOOLRL                EXIT TO TERMINATION
*
*        ERR5
*
*        ERR5A     E35  FROM BPRTAB, DISP IN TESTTABL
*        ERR5      E2   FROM BPRTAB, DISP IN ARTABLE
*        GENERATES ERROR PATTERN RETURNS TO TESTLOOP OR LIST
*
ERR5A    LA    R6,PPARLST              GET PARAMETER FIELD
         B     ERR5B
*
ERR5     LA    R6,PONTPAR              GET PARAMETER FIELD
ERR5B    STM   R12,R15,ERRSAVE
         BAL   R12,ERROR1              GENERATE PATTERN
         LM    R12,R15,ERRSAVE
         BR    R10                     RETURN TO TESTLOOP OR LIST
*
PPARLST  DC    X'0423'
PONTPAR  DC    X'0402'                 E2
*
*        ERR6
*
*        GENERATES PATTERN FOR E6
*        TESTS IF PROGRAM STARTED IF NOT, NO ERROR MESSAGE
*        TEST IF IN COMMENT OR IDENTIFIER PROGRAM
*        TAKES THE 6 CHARACTERS PRECEEDING THE FIRST QUOTE
*        RETURNS TO APOSTROPHE PROGRAM TO TEST ON SECOND
*        QUOTE
*
ERR6     TM    BITS2,X'20'             FIRST BEGIN FOUND YET ?
         BZ    TESTLOOP                NO
         TM    FBYTE,X'FF'
         BO    ENTRAPR                 INVALID IDENTIFIER
         BZ    ERR6A                   COMMENT
         LA    R1,1(,R1)
         B     TPSPECER
*
ERR6A    BCTR  R1,0
         STM   R12,R15,ERRSAVE
         BAL   R12,ERROR1
         S     R1,KF6                  SUBTRACT 6
         MVC   4(6,R15),0(R1)          MOVE OUT INFORMATION TO POOL
         LA    R1,7(,R1)
         LM    12,15,ERRSAVE
         B     ENTRAPR                 RETURN TO TEST SECOND APOST
*
*        ERR7
*
*        TAKES CARE OF ALL SERIOUS AND WARNING MESSAGES THAT ARE
*        4 BYTES LONG
*
*        ENTERED FROM -
*        ERR1, IERSPEC, ARNAMSE, SWITCHNSE, PNAMESE, LABNAMER,
*        CODE, SEMCO, ERR18 ERR23, CODE, SPEC, VALUE, VALDLB2,
*        FIRSTBEG, ERR9, LABEL, PROCEDURE, SWITCH, COM
*        1, 5, 8, 15, 17, 18, 23, 24, 25, 28, 29, 42, 43, 216
*        RETURNS TO CALLING SEQUENCE
*
ERR7     STM   R12,R15,ERRSAVE
         BAL   R12,ERROR1              CREATE ENTRY
         LM    R12,R15,ERRSAVE
         B     2(,R6)
*
*        ERR8
*
*        GENERATES ERROR PATTERN E11 ONCE
*
*        IF FOUND DELIMITER IS COMMENT E18 IS GIVEN INSTEAD
*        ENTERED FROM - TYPESPEC, STARTDEL
*        EXITS TO TESTLOOP
*
ERR8     TM    BITS3,E11BIT            MESSAGE ALLREADY GIVEN ONCE ?
         LA    R1,1(,R1)               GET NEXT CHARACTER
         BO    TESTLOOP                YES, RETURN
         CLI   BCHAR,X'38'             COMMENT FOUND ?
         BE    E18                     YES GENERATE E18 INSTEAD
         OI    BITS3,E11BIT            SET E11BIT
         BAL   R6,ERR7                 GENERATE E11 PATTERN
*
         DC    X'040B'
*
         B     E18A
*
E18      BAL   R6,ERR7
*
         DC    X'0412'
*
E18A     BR    R10                     RETURN
*
*        ERR9
*
*        GENERATE E9 PATTERN
*
*        ENTERED FROM - TED, END, READROUT
*        EXITS TO EODADIN
*
ERR9     BAL   R6,ERR7                 PROGRAM CONT AFTER LAST END
*
         DC    X'042B'
*
         B     EODADIN
*
*        ERROR10
*
*        GENERATES E10 PATTERN
*
*        INSERTS IN THE NOT SPECIFID PARAMETERS AN ALL PURPOSE
*        IDENTIFIER
*        RETURNS TO CALLING PROGRAM
*
ERROR10  BAL   R6,ERR2B
*
         DC    X'000A'                 E10
*
         L     R6,LPBP
FINDEMTY LA    R6,11(,R6)              GET FIRST PARAMETER
         C     R6,AITL                 ALL PARAMETERS CHECKED ?
         BER   R12                     WHEN ALL CHECKED RETURN
         CLI   6(R6),0                 INSERT ALL PURPOSE IDENTIFIER
         BNE   FINDEMTY                IN EMPTY INTERNAL NAMES
         MVC   6(5,R6),ALLPUPOS
         B     FINDEMTY
*
ALLPUPOS DC    X'91FF010000'
*
*        ERR13
*
*        GENERATES E13 PATTERN
*        PICKS UP THE DELIMITER FROM KEYWTAB
*
ERR13    STM   12,15,ERRSAVE
         LA    R12,5(,R14)             INCREASE TO GET WHOLE LENGTH
         STC   R12,0(R6)
         BAL   R12,ERROR1
         L     R14,ERRSAVE+8           GET LENGTH OF DELIMITER
         LA    R7,1(,R4)               GET START ADDR OF DELIMITER
         EX    R14,ERRMOVE             MOVE DELIMITER TO ERROR PATTERN
         LM    12,15,ERRSAVE
         B     2(0,R6)                 RETURN
*
*        ERROR21
*
*        GENERATES E21 PATTERN
*        PICKS UP DELIMITER FROM DELIMITER TABLE
*        EXITS TO PROGRAM WHICH CALLED FOR BEG1
*
ERROR21  STM   12,15,ERRSAVE
         LA    R6,5(,R14)              INCREASE L TO GET WHOLE LENGTH
         STC   R6,E21PAR
         LA    R6,E21PAR
         BAL   R12,ERROR1
         L     R7,SAVE1                GET DEK FROM DELIMITER TABLE
         L     R14,ERRSAVE+8           LENGTH FROM SAVEAREA
         EX    R14,ERRMOVE             MOVE IN DEK IN ERROR MESSAGE
         LA    R3,1(,R3)               SUBSTITUTE BEG1 DECREASION
         LM    12,15,ERRSAVE           BEGIN WILL REMAIN COMPOUND
         BR    R9                      RETURN
*
E21PAR   DC    X'0015'                 E21
*
*        ERROR1
*
*        CHECKS IF SPACE LEFT IN ERRORPOOL
*        INSERTS LENGTH, SEMCNT, ERROR NUMBER
*        RETURNS TO CALLIN ERROR PUTINE
*
ERROR1   MVC   ERRMOD1+3(1),0(R6)      MOVES IN THE LENGTH AND
         MVC   ERRMOD2+1(1),0(R6)      ERROR NUMBER IN THE FOLLOWING
         MVC   ERRMOD3+1(1),1(R6)      INSTRUCTIONS
         L     R15,NEXTERR
ERRMOD1  LA    R14,0(,R15)
         C     R14,ENDPOOL             ROOM LEFT IN ERRORPOOL ?
         BNH   *+8                     FOR THIS MESSAGE
         B     ERR0                    NO, GENERATE E212
*
         L     R15,NEXTERR
         ST    R14,NEXTERR             CORRECT NEXTERR POINTER
ERRMOD2  MVI   0(R15),0                MOVE IN LENGTH
ERRMOD3  MVI   1(R15),0                        ERRORNUMBER
         MVC   2(2,R15),SEMCNT                 SEMICOLON COUNTER
         LR    R14,R1                  MAKE R14 POINT TO SIX CHAR
         SH    R14,KH7                 BEFORE CURRENT INPUT POINTER
         BR    R12
*
*        ERROR2
*
*        FINDS FIRST NONZERO CHAR IN BUCKET, ITAB, IDBUCKET OR
*        BUCKET
*
ERROR2   LA    R2,5                    INITIALIZE R2 FOR THE LOOP
ERROR2A  STC   R2,ERRKCAL+3
ERRKCAL  CLI   0(R7),0                 LOOP TO FIND THE FIRST 0 CHAR
         BNE   ERRKC01                 OR END OF EXTERNALNAME
         BCT   R2,ERROR2A
ERRKC01  LA    R15,5(,R2)              INCREASE TO GET THE WHOLE
         STC   R15,0(,R6)              ERROR MESSAGE LENGTH
         BR    R12
*
         CNOP  0,4
ERRMOVE  MVC   4(1,R15),0(R7)
*
KH7      DC    X'0007'
*
*        IDCHECK1
*
*        CHECKS IDENTIFIER NAMES FOR ARRAY, PROCEDURE AND SWITCH
*
*        MOVES THE FIRST 6 CHARACTERS OF THE NAME TO ITAB AND THE
*        OUTPUT
*        RETURNS VIA R6 WHEN A CHARACTER IS FOUND THAT IS NOT
*        LETTER, DIGIT, BLANK OR ZETA
*
IDCHECK1 BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),0(R1)           MOVE OUT FIRST CHAR
         LA    R3,1(,R3)
         L     R7,AITL                 GET ITAB POINTER
         MVC   0(1,R7),0(R1)           MOVE IN FIRST CHAR TO ITAB
         LA    R7,1(,R7)
         LA    R2,1                    INITIALIZE R2
         LA    R9,IDCHECK3
IDCHECK2 LA    R1,1(,R1)               GET NEXT CHAR
IDCHECK3 CLI   0(R1),XFZETA            WHAT IS CHAR ?
         BLR   R6                      NOT LETTER
         BE    CIB                     ZETA
         C     R2,KF6                  LETTER, 6 CHAR MOVED ALREADY ?
         BE    IDCHECK2                YES, SKIP ADDITIONAL CHAR
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVC   0(1,R3),0(R1)           MOVE CHAR TO OUTPUT
         LA    R3,1(,R3)
         MVC   0(1,R7),0(R1)           TO ITAB
         LA    R7,1(,R7)               INCREASE
         LA    R2,1(,R2)               POINTERS
         B     IDCHECK2                GO AND CHECK NEXT CHAR
*
*        FINDSEMC
*
*        CHECKS FOR SEMICOLON OR POINT
*        COMMA BLANKS AND I/P BUFFER CHANGE IS HANDLED
*        IF SEMICOLON IS FOUND THE RETURN IS VIA R12 IF NOT
*        THE RETURN IS VIA R6
*
FINDSEMA LA    R1,1(,R1)
FINDSEMC LA    R9,*
         CLI   0(R1),XFSCOLON          SEMICOLON ?
         BE    0(,R12)                 YES, SEMICOLON FOUND
         CLI   0(R1),XFPERIOD          POINT ?
         BE    FINDCOMA                YES, LOOK FOR COMMA
         CLI   0(R1),XFBLANK           BLANK ?
         BE    FINDSEMA                YES, BACK TO START
         CLI   0(R1),XFZETA
         BE    CIB
         BR    R6                      ERROR, NO SEMICOLON
*
FINDCOMA LA    R9,*+8
FINDCOMB LA    R1,1(,R1)
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    0(,R12)                 YES, SEMICOLON FOUND
         CLI   0(R1),XFBLANK           BLANK ?
         BE    FINDCOMB
         CLI   0(R1),XFZETA
         BE    CIB
         BR    R6                      ERROR, NO SEMICOLON
*
*        ITABCLEA
*
*        CHECKS FOR ITAB OVERFLOW AND CLEARS THE NEXT ENTRY
*
ITABCLEA L     R15,AITL
         LA    R15,11(,R15)
ITABCLEC C     R15,ELI                 ROOM FOR ONE MORE ITAB ENTRY ?
         BL    ITABCLEB
         BAL   R6,ERR4
*
         DC    X'04D5'                 E213
*
ITABCLEB LR    R7,R15                  INCREASE ITAB POINTERS
         ST    R15,AITL
         MVI   0(R15),0                CLEAR NEXT
         MVC   1(10,R15),0(R15)        ITAB ENTRY
         BR    R12                     RETURN
*
*        COB
*
*        CHECKS IF NEW O/P BUFFER IS NEEDED
*
*        ENTRY IS TO COBSPEC IF TWO OR MORE CONTINIOUS BYTES ARE
*        NEEDED
*        THE CHANGE OF ADDR BETWEEN THE TWO BUFFERS IS DONE
*        WITH DISP. DISP IS EITHER 0 OR 4 SO ADDARI+DISP WILL
*        PICK UP EITHER ADDARI OR THE ADDR OF THE ALTERNATE
*        O/P BUFFER
*        WADDARI POINTS TO THE FIRST BYTE OF THE CURRENT O/P
*        BUFFER
*        R3 IS THE CURRENT O/P POINTER
*        APE POINTS TO THE LAST BYTE OF THE CORRENT BUFFER
*        ONC CONTAINS THE CURRENT O/P RECORD NUMBER
*        ZETA IS THE BUFFER END INDICATION
*
COBSPEC  C     R0,APE                  SPACE LEFT FOR X MORE BYTES ?
         BLR   R12                     YES, RETURN
         B     COBSPEB                 NO CHANGE OUTPUT BUFFER FIRST
*
COB      C     R3,APE                  SPACE LEFT FOR ONE MORE BYTE ?
         BLR   R12                     YES, RETURN
COBSPEB  MVI   0(R3),XFZETA            MOVE ZETA TO O/P BUFFER
         STM   R14,R2,SAVE1            SAVE REGISTERS
         ST    R6,SAVE1+24
         CLI   ONC,255                 ALREADY 256 OUTPUT RECORDS ?
         BL    COBSPED                 NO, BYPASS ERROR MSG
         BAL   R6,ERR4                 YES, TERMINATE COMPILATION
*
         DC    X'04D7'                 E215
*
COBSPED  L     R3,WADDARI              LOAD ADDR OF CURRENT O/P REC
         LA    R6,SYSUT1               R6 -> SYSUT1 DCB ADDR
         CLI   ONC,0                   FIRST OUTPUT RECORD ?
         BE    WRITEOB                 YES, SKIP CHECK
*
         CHECK ODECB                   CHECK IF BEFORE LAST RECORD IS
*                                      WRITTEN
WRITEOB  WRITE ODECB,SF,(R6),(R3)
*
         XI    DISP,X'04'              CHANGE ADDR DISPLACEMENT
         IC    R2,DISP
         L     R3,ADDARI(R2)           COMPUTE VALID O/P BUFFER ADDR
         ST    R3,WADDARI              STORE IN WADDARI
         LR    R14,R3                  COMPUTE ADDR OF LAST BYTE IN
         A     R14,SRCE1S              THE NEW OUTPUT AREA
         BCTR  R14,0
         ST    R14,APE                 SAVE IN APE
         IC    R2,ONC                  INCREASE OUTPUT RECORD COUNTER
         LA    R2,1(,R2)
         STC   R2,ONC
         L     R6,SAVE1+24
         LM    R14,R2,SAVE1
         BR    R12                      RETURN TO CALLING SEQUENCE
*
*        CIB
*
*        GET NEXT RECORD AND PRINTS IT WITH THE SEMICOLON COUNTER
*
*        IF ISO CODE IS SPECIFIED A TRANSLATION IS FIRST MADE TO
*        EBCDIC
*        THE RECORD IS TRANSLATED AND THE RECORD END INDICATION
*        ZETA IS INSERTED
*
CIB      STM   R14,R2,SAVE1            SAVE REGS
         SH    R1,KH7                  MOVE SEVEN CHAR INFRONT
         MVC   WABEFOR(7),0(R1)        OF WORKAREA
         TM    COMPFLGS+1,NSRCE        NOSOURCE SPECIFIED ?
         BO    GETREC                  YES, SKIP PRINTING
         L     R15,PRTRTADD            PRINT
         BALR  R14,R15
         ST    R1,APRNTAR              SAVE NEW PRINT BUFFER ADDR
GETREC   L     R1,ASYSDCB              R1 -> SYSIN DCB ADDR
*
         GET   (1),WA                  GET NEXT RECORD
*
TESTISO  TM    COMPFLGS+1,ISO          ISO INPUT ?
         BO    ISOTRANS                YES, TRANSLATE ISO TO EBCDIC
         L     R1,APRNTAR
         TM    COMPFLGS+1,NSRCE        NOSOURCE SPECIFIED ?
         BO    NOPRINT                 YES, MOVE TO DUMMY PRINTAREA
         LH    R15,SEMCNT              CONVERT SEMICOLON COUNTER
         CVD   R15,DOUBLE
         MVC   0(L'SCPATTN,R1),SCPATTN  MOVE IN SEMICOLON COUNT PATTERN
         ED    0(L'SCPATTN,R1),DOUBLE+5  FORMAT SEMICOLON COUNT
         MVC   10(80,R1),WA            MOVE RECORD TO PRINT BUFFER
         B     PRNTREC
*
NOPRINT  MVC   SAVEPRNT+8(72),WA       IF NSRCE MOVE WA TO DUMMY PRINT
PRNTREC  LM    R14,R2,SAVE1
         LA    R1,WA                   SET INPUT POINTER
         TR    WA(72),TREXTINT         TRANSLATE RECORD
         MVI   72(R1),XFZETA           MOVE RECORD END IDENTIFIER
         BR    R9                      RETURN
*
ISOTRANS ST    R6,SAVE1+24
         LA    R6,WA                   GET START OF WA
         LA    R15,79(,R6)             GET END OF WA
LOOP     CLI   0(R6),X'4C'             )
         BE    IRPAR
         CLI   0(R6),X'7B'             =
         BE    IEQUAL
         CLI   0(R6),X'7C'             '
         BE    IAPOST
         CLI   0(R6),X'6C'             (
         BE    ILPAR
         CLI   0(R6),X'50'             &
         BNE   LOOPEND
         MVI   0(R6),X'4E'             +
         B     LOOPEND
*
IRPAR    MVI   0(R6),X'5D'             )
         B     LOOPEND
*
IEQUAL   MVI   0(R6),X'7E'             =
         B     LOOPEND
*
IAPOST   MVI   0(R6),X'7D'             '
         B     LOOPEND
*
ILPAR    MVI   0(R6),X'4D'             (
LOOPEND  LA    R6,1(,R6)
         CR    R6,R15                  ALL CHAR CHECKED IN WA ?
         BNH   LOOP                    NO, CHECK NEXT
         L     R6,SAVE1+24             YES, RETURN
         B     TESTISO+8
*
*        DELTMIT
*
*        TWO QUOTES HAVE BEEN FOUND
*
*        IT IS CHECKED THAT THE LENGTH IS NOT ZERO OR EXCEED THE
*        MAXIMUM LIMIT FOR A DELIMITER (10 CHARACTERS)
*        R4 POINTS TO THE FIRST AND R1 TO THE LAST QUOTE
*        THE LENGTH IS USED TO GET A DISPLACEMENT FROM THE KWLUTAB
*        FOR A SECTION IN THE KEYWTAB. A SECTION IN THE KEYWTAB
*        CONTAINS ALL DELIMITERS OF THE SAME LENGTH.
*        1. THE FIRST BYTE IN EACH SECTION SAYS HOW MANY ENTRIES
*           THERE ARE IN THE SECTION. THEREAFTER A DELIMITER PLUS 3
*           BYTES OF INTERNAL CODE MAKES A SUBSECTION.
*        2. THE FIRST 2 BYTES OF THE INTERNAL CODE IS
*           CHARECTERISTCS FOR THE DELIMITER.
*        3. THE THIRD BYTE IS A DISPLACEMENT TO THE DELPRGTB,
*           WHERE THE ADDR IS PICKED UP TO THE PROGRAM TO HANDLE
*           THE DELIMITER.
*        A CHECK IS MADE WHEN A DELIMITER IS FOUND IF IT IS THE
*        FIRST FOUND IN THE PROGRAM. THE EXIT IS THEN TO
*        STARTDEL. THE TEST IS ON BITS2 X'20'. IF NO DELIMITER IS
*        FOUND THE EXIT IS TO THE EROUT PROGRAM.
*        FBYTE - SWITCH -
*        1. THE FBYTE IS FF IF AN APOSTROPHE IS FOUND IN THE
*           COMMENT PROGRAM
*        2. THE FBYTE IS F0 IF AN APOSTROPHE IS FOUND IN THE TYPE
*           PROGRAM INSTEAD OF THE FIRST CHARACTER OF THE NAME
*        3. OTHERWISE IT IS 00
*
DELIMIT  SR    R15,R15
         LR    R14,R1
         BCTR  R14,0
         SR    R14,R4                  COMPUTE LENGTH OF KEYWORD
         BP    DELIM01                 > ZERO ?
         BAL   R6,ERR6                 ZERO, ERROR
*
         DC    X'0A0C'                 E12 DELETE FIRST APOSTROPHE
*
DELIM01  C     R14,KF11                LIMIT EXEEDED ALREADY ?
         BH    EROUT                   BRANCH TO ERROR ROUTINE
         BCTR  R14,0
         LA    R9,KWLUTAB
         TM    FBYTE,X'FF'             TEST FBYTE
         BO    COMSPEC
         BM    TYPESPEC
         SLA   R14,2                   START OF LOOKUP STRING
         L     R9,0(R14,R9)
         IC    R15,0(,R9)              NUMBER OF ENTRIES IN THIS SECT
         LA    R9,1(,R9)               AND ADDR OF FIRST WORD ENTRY
         SRA   R14,2(0)
CLCLOOP  EX    R14,EXCLC               DELIMITER FOUND ?
         BNE   NOMATCH                 NO, TRY NEXT IN SAME SECTION
         IC    R2,3(R14,R9)            YES, MATCH
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BO    DELIM02                 YES
         B     STARTDEL                NO, CHECK FOR CORRECT START
*
DELIM02  L     R6,DELPRGTB(R2)         BRANCH TO APPROPRIATE SUBPGM
         BR    R6                      DEPENDING ON DISP IN KEYWTAB
*
NOMATCH  LA    R9,4(R14,R9)            GET NEXT DELIMITER
         BCT   R15,CLCLOOP             ANY DELIMITERS LEFT TO CHECK ?
         B     EROUT                   BRANCH TO ERROR ROUTINE
*
EXCLC    CLC   1(1,R4),0(R9)           EXECUTED INSTRUCTION
*
*        EROUT
*
*        CHECKS ALL SECTIONS OF THE KEYWTAB FOR AN EQUAL DELIMITER
*        TO THE ONE IN I/P, DISREGARDING LENGTH
*
*        IF NO EQUAL FOUND E14 IS GENERATED AND THE FIRST
*        APOSTROPHE IS DELETED. EXIT IS THEN TO TEST.
*        IF AN EQUAL IS FOUND E13 IS GENERATED AND AN BRANCH IS
*        TAKEN TO THE APPROPRIATE SUBPROGRAM
*
EROUT    TM    FBYTE,X'FF'
         BM    TYPESPEC                INVALID IDENTIFIER
         BO    COMCEE2                 COMMENT
EROUTOK  LA    R2,10                   GO THROUGH ALL POSSIBILITIES
         SR    R15,R15                 ZERO R14, R15
         SR    R14,R14
EROUT2   SLA   R14,2
         LA    R9,KWLUTAB
         L     R9,0(R14,R9)            GET SECTION IN KEYWTAB
         IC    R15,0(,R9)              NUMBER OF ENTRIES IN STRING
         LA    R9,1(,R9)               FIRST ENTRY
         SRA   R14,2
CLCERR   EX    R14,EXCLC               DELIMITER FOUND ?
         BNE   EROUT3                  NO
         TM    BITS2,STARTBIT          YES, PROGRAM STARTED YET ?
         BZ    STARTDEL                NO, CHECK FOR A CORRECT START
         BAL   R6,ERR13
*
         DC    X'000D'                 E13
*
         LA    R1,1(R14,R4)            SET R1 TO ONE BEYOND DELIMITER
         IC    R2,3(R14,R9)            GET DISPLACEMENT OF PROGRAM
         L     R6,DELPRGTB(R2)         IN DELPRGTB
         BR    R6                      BRANCH TO PROGRAM
*
EROUT3   LA    R9,4(R14,R9)            NOW GET NEXT DELIMITER
         BCT   R15,CLCERR              ALL DEL IN STRING CHECKED ?
         LA    R14,1(,R14)             YES, GET NEXT STRING
         BCT   R2,EROUT2
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    TESTLOOP                NO, RETURN TO MAINLOOP SCANNING
         BAL   R6,ERR2C
*
         DC    X'0A0E'                 E14
*
         LA    R1,1(,R4)               GET NEXT CHAR
         BR    R10                     RETURN
*
*        TYPESPEC
*
*        'REAL'' OR 'INTEGER'' OR 'BOOLEAN'' HAS BEEN FOUND
*
*        THE ONLY VALID DELIMITERS ARE AT THIS POINT ARRAY OR
*        PROCEDURE
*
TYPESPEC CLC   1(L'KWPROC,R4),KWPROC   PROCEDURE ?
         BE    TYPPROC                 YES
         TM    BITS2,X'20'             PROGRAM STARTED YET ?
         BZ    ERR8                    NO, GENERATE E11
         CLC   1(L'KWARRAY,R4),KWARRAY  ARRAY ?
         BE    TYPEARRY                YES
*                                      INVALID IDENTIFIER HAS BEEN
*                                      FOUND GOTO IER SPEC
TPSPECER TM    BITS1,X'40'             SPECIFICATION ?
         BO    TPSPEC01
         LA    R15,TYPEDAFI            NO, SET RETURN TO TYPE PGM
         B     IERSPEC
*
TPSPEC01 LA    R15,IDCHECK             YES, SET RETURN TO IDCHECK
         B     IERSPEC
*
*        COMSPEC
*
*        TWO APOSTROPHES HAVE BEEN FOUND IN A COMMENT
*
*        VALID DELIMITERS TO END A COMMENT ARE END OR ELSE
*
COMSPEC  LA    R9,KWELSE
         CLC   1(L'KWELSE,R4),KWELSE   COMMENT ENDING WITH ELSE ?
         BNE   COMSPECN                NO
         C     R14,KF3                 YES, CHECK CORRECT LENGTH
         BE    TED                     ELSE
         B     ENTRAPR                 R10 TO FIND ANOTHER QUOTE
*
COMSPECN CLC   1(L'KWEND,R4),KWEND     COMMENT ENDED WITH END ?
         BNE   ENTRAPR                 NO, R10 TO FIND ANOTHER QUOTE
         C     R14,KF2                 YES, CHECK CORRECT LENGTH
         BE    END                     END
         B     ENTRAPR                 R10 TO FIND ANOTHER QUOTE
*
*        STARTDEL
*
*        THE ONLY VALID DELIMITERS TO START A PROGRAM IS BEGIN
*        OR IF PRECOMPILED PROCEDURE IS SPECIFIED PROCEDURE OR
*        TYPE PROCEDURE
*
STARTDEL STC   R2,BCHAR                GET DELIMITERS CHARACTERISTIC
*                                      FROM KEYWTAB
         CLI   BCHAR,X'24'             BEGIN FOUND ?
         BE    FIRSTBEG                YES
         TM    COMPFLGS,PROC           PRECOMPILED SPECIFIED ?
         BZ    ERR8                    NO, GENERATE E11
         CLI   BCHAR,X'3C'             FOUND WORD IS PROCEDURE ?
         BNE   TYPEPR01                NO
         B     PROCEDUR                YES
*
TYPEPR01 CLI   BCHAR,X'18'             TYPE FOUND ?
         BNE   ERR8                    NO
TYPEPREC LA    R1,1(,R1)               LOOK FOR QUOTE TYPE PROC
TYPEPREA CLI   0(R1),XFQUOTE           QUOTE FOUND ?
         BNE   TYPEPR02                NO, BRANCH
         BCTR  R1,0                    YES, DECREASE TO LET TYPE PGM
         B     TYPE                    FIND THE QUOTE AGAIN
*
TYPEPR02 CLI   0(R1),XFBLANK           BLANK ?
         BE    TYPEPREC
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ERR8                    NEITHER, GENERATE E11
         ST    R9,SAVE1+20             CHANGE I/P AND LOOK AGAIN
         BAL   R9,CIB
         L     R9,SAVE1+20
         B     TYPEPREA
*
*        NORMAL
*
*        INSERTS IN THE O/P THE INTERNAL CODE FROM KEYWTAB
*
NORMAL   BAL   R12,COB                 CHECK IF O/P AREA FILLED
         LA    R9,1(R14,R9)            COMPUTE ADDR OF CODE
         MVC   0(1,R3),0(R9)           MOVE CODE TO OUTPUT BUFFER
         LA    R3,1(,R3)               INCREASE OUTPUT AND
         LA    R1,1(,R1)               INPUT POINTERS
         BR    R10
*
*        BOLCON
*
*        MOVES OUT SIX BYTES OF INTERNAL CODE FOR FALSE OR TRUE
*
BOLCON   LA    R0,6(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVC   0(5,R3),INT             TRANSFER FIRST PART
*                                      OF INTERNAL NAME
         LA    R7,1(R14,R9)            AND
         MVC   5(1,R3),0(R7)           LAST PART
         LA    R3,6(,R3)               INCR OUTPUT POINTER
         LA    R1,1(,R1)               INCR INPUT POINTERS
         BR    R10
*
*        GIF
*
*        TRANSFERS INTERNAL CODE BYTE AND EXITS TO THE STATEMENT
*        PROGRAM TO CHECK IF A PROCEDURE BOBY HAS STARTED
*
GIF      BAL   R12,COB                 CHECK IF O/P AREA FILLED
         LA    R7,1(R14,R9)            TRANSFER INTERNAL CODE
         MVC   0(1,R3),0(R7)
         LA    R3,1(,R3)               INCR OUTPUT POINTER
         LA    R1,1(,R1)               INCR INPUT POINTER
         B     STATE                   BRANCH TO STATEMENT PROGRAM
*
*        TED
*
*        TRANSFERS INTERNAL CODE
*        SETS POSSIBLE LABEL POINTERS
*
TED      TM    BITS2,ENDBIT            ELSE ENDED FINAL END COMMENT ?
         BO    ERR9                    YES
         BAL   R12,COB
         LA    R9,1(R14,R9)
         MVC   0(1,R3),0(R9)           TRANSFER INTERNAL CODE
         ST    R3,OPIN                 SET LABEL POINTERS
         MVC   OPIN+4(1),ONC
         MVC   OPINCHAR(1),0(R9)
         LA    R3,1(,R3)
         ST    R3,LAPIN
         LA    R1,1(,R1)
         NI    BITS2,X'FE'             SET ENDELSE BIT TO ZERO
         BR    R10
*
*        BEGIN
*
*        TEST IF PROC IN STACK
*
*        TRANSFERS 'BEGIN' TO OUTPUT AND STACK
*        SETS OPIN, OPIN+4, LAPIN, BEGBIT
*        BEGBIT IS USED TO DISTINGUISH BETWEEN COMPOUND BEGIN
*        AND BLOCK BEGIN. IF A DECLARATION IS FOUND WHEN THE
*        BEGBIT IS ON IT'S A BLOCK BEGIN THE BEGBIT IS TURNED OF
*        BY THE STATEMENT PROGRAM AND THE BEG1 PROGRAM
*
BEGIN    L     R15,SP
         CLI   0(R15),X'0C'            PROC IN STACK ?
         BE    BEGPROC                 YES, BRANCH TO PROC PROCESSING
         LA    R0,4(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'0C'             TRANSFER BEGIN TO O/P
         MVI   OPINCHAR,X'0C'          SET LABELSAVE
         ST    R3,OPIN                 NOTE ITS POSITION IN OPIN AND
         MVC   OPIN+4(1),ONC           THE NUMBER OF THE OUTPUT BUFFER
         LA    R3,1(,R3)               INCREASE OUTPUT POINTER
         ST    R3,LAPIN                NOTE WHERE LABEL MAY START
         OI    BITS1,X'80'             BEGBIT.= 1
         LA    R15,1(,R15)             INCR STACK POINTER
         C     R15,ATOPSTAK
         BL    BEGINAA
         BAL   R6,ERR4                 STACK OVERFLOW
*
         DC    X'0414'                 E20
*
BEGINAA  MVI   0(R15),X'08'            PUT BEGIN IN STACK
         ST    R15,SP
BEGINAB  LA    R1,1(,R1)
         B     TESTLOOP
*
*        BEGPROC
*
*        PROCEDURE - SPECIFICATIONS - BEGIN HAS BEEN FOUND
*
*        PROC BODY IS TO COME. PROC IS CHANGED TO PROC*
*        ITS CHECKED THAT ALL PARAMETERS HAVE BEEN SPECIFIED
*        THE RETURN IS TO TEST VIA THE BEGIN PROGRAM
*
BEGPROC  MVI   0(R15),X'10'            CONVERT PROC INTO PROC*
         NI    BITS1,X'BF'             PROBIT=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BE    BEGINAB                 YES
         BAL   R12,ERROR10             NO, GENERATE E11
         B     BEGINAB
*
*        FIRSTBEG
*
*        THE FIRST BEGIN IS CONSIDERED AS A BLOCK BEGIN
*        THE START BIT IS TURNED OFF
*        THE BEG1 PROGRAM IS JOINED
*        IF PRECOMPILED PROCEDURE HAS BEEN SPECIFID E42 IS GIVEN
*        AS A WARNING AND THE BEGIN IS DISREGARDED
*
FIRSTBEG TM    COMPFLGS,PROC           PRECOMPILED PROCEDURE ?
         BZ    FIRSTB01                NO, BRANCH
         BAL   R6,ERR7                 YES, GIVE WARNING MESSAGE
*
         DC    X'042A'
*
         LA    R1,1(,R1)               DISREGARD THE BEGIN
         B     TESTLOOP
*
FIRSTB01 OI    BITS2,X'20'             NO, TURN STARTBIT OFF
         LA    R9,TESTLOOP             MAKE RETURN FROM BEGI BE TEST
         LA    R1,1(,R1)
         B     BEG1FRST                FIRST BEGIN = BLOCK BEGIN
*
*        BEGI
*
*        BLOCK BEGIN PROGRAM
*
*        CHANGES BEGIN TO BETA IN STACK AND OUTPUT
*        INCREASES ITAB GROUP NUMBER AND PROGRAM BLOCK NUMBER
*        ENTRIES ARE MADE IN -
*        GROUPTABEL
*        SURROUNDING BLOCKS IG. NR
*        PBTAB1
*        SURROUNDING PBN
*        SCTAB - CURRENTSC COUNTER
*        ITAB
*        ADDRS OF SURROUNDING BLOCK AND IG HEAD ENTRIES, NEW
*        PBN AND IGN
*        LPBP (ADDR OF CURRENT PROGRAM BLOCK HEAD ENTRY)
*        AND
*        LIGP (ADDR OF CURRENT ITAB GROUP HEAD ENTRY)
*        ARE UPDATED
*        PUTS BETA + NEW PBN AND IGN TO OUTPUT REC.
*
BEG1     BCTR  R3,0
         NI    BITS1,BEGOFF            BEGBIT 0
         CLI   0(R3),X'0C'             BEGIN IN O/P ?
         BNE   ERROR21                 NO, DECLARATION INCORRECT PLACE
BEG1FRST MVI   0(R3),X'0D'             MOVE BETA TO O/P
         L     R15,SP                  AND
         MVI   0(R15),X'04'            STACK
         SR    R6,R6
         LH    R6,IGC
         LA    R6,1(,R6)               INCREASE ITAB GROUP NUMBER
         STH   R6,IGC
         AR    R6,R6                   ENTRY IS TO GO INTO
         AH    R6,IGC                  A(GT)+3*(IGC)
         A     R6,AGT
         L     R7,LIGP
         MVC   0(2,R6),8(R7)           ENTRY INTO GROUPTABLE
         MVI   2(R6),0
         NI    0(R6),X'7F'             CLEAR POSSIBLE PHI IND
         CLI   PBC,255                 MORE THAN 255 BLOCKS ?
         BNE   BEG1FAAA
         BAL   R6,ERR4
*
         DC    X'0416'                 E22
*
BEG1FAAA IC    R2,PBC
         LA    R2,1(,R2)               INCR PROGRAM BLOCK NUMBER
         STC   R2,PBC
         L     R7,LPBP
         LA    R6,PBTAB1
         AR    R6,R2
         MVC   0(1,R6),10(R7)          ENTRY INTO PROGRAM BLOCK TABLE
         STC   R2,1(,R3)               TRANSFER PBN TO O/P
         AR    R2,R2                   MAKE ENTRY OF CURRENT
         LA    R6,SCTAB(R2)            SEMCNT COUNTER IN SCTAB
         MVC   0(2,R6),SEMCNT
         MVC   2(2,R3),IGC             IGN IN OUTPUT BUFFER
         LA    R3,4(,R3)
         ST    R3,LAPIN                SET LABEL POINTERS
         L     R15,AITL                MAKE BLOCK HEAD IN ITAB
         MVC   0(4,R15),LIGP
         MVC   4(4,R15),LPBP
         MVC   8(2,R15),IGC
         MVC   10(1,R15),PBC
         ST    R15,LPBP                UPDATE LIGP AND LPBP
         ST    R15,LIGP
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         BR    R9
*
*        END
*
*        ACTION DEPENDS ON WHAT IS IN THE STACK
*
*        TURNS IN ALL CASES OFF THE DELTABIT AND THE END ELSE
*        BIT
*        GENERAL RETURN POINT IS CSPEND IF RETURN ADDR, IN
*        R4, IS NOT CHANGED
*        FINAL RETURN IS TO TEST VIA SEMCO OR COMMENT PROGRAM
*        PROC** IN STACK ACTIVATES PBLOCKEND AND RETURNS TO END
*        TO INSPECT THE STACK AGAIN
*
END      NI    BITS1,X'DF'             DELTABIT.=0
         TM    BITS2,ENDBIT            END FINISHED FINAL END COMMENT ?
         BO    ERR9                    YES
         NI    BITS2,X'FE'             SET ENDELSE BIT TO ZERO
CSPEND   LA    R4,*                    RETURN FOR PBLCKEND, FOREND
         L     R15,SP
         IC    R2,0(,R15)              BRANCH
         L     R6,PROG1(R2)            DEPENDING ON TOP BYTE
         BR    R6                      OF THE STACK
*
PROG1    DC    A(ERR8)                 +00 E11 IF ALPHA
         DC    A(BLOCKEND)             +04 BETA
         DC    A(COMPDEND)             +08 BEGIN
         DC    A(PREND)                +12 PROC
         DC    A(STAREND)              +16 PROC*
         DC    A(PBLCKEND)             +20
         DC    A(FOREND)               +24 FOR
*
*        STAREND
*
*        PROC* HAS ENDED
*
*        ACTIVATES THE PBLOCK END PROGRAM AND RETURNS AFTERWARDS
*        TO TEST VIA COMMENT PROGRAM
*
STAREND  OI    BITS1,X'20'             DELTABIT= 1
         LA    R4,COMMEND              LOAD ADDR OF END ENTRY
*                                      INTO COMMENT PROGRAM
         B     PBLCKEND
*
*        PREND
*        PROC HAS ENDED
*
*        CHECKS IF ALL PARAMETERS SPECIFIED.
*        TURNS OFF THE PROBIT.
*        A PROC THAT ENDS WITH 'END' IS NOT CORRECTED, THEREFORE
*        THE STACK IS AGAIN INSPECTED AFTER THE PBLOCKEND PROGRAM
*        HAS BEEN ACTIVATED
*
PREND    NI    BITS1,X'BF'             PROBIT.=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BE    PBLCKEND                YES, ACTIVATE PBLCKEND
         BAL   R12,ERROR10             NO, GENERATE E10 FIRST
         B     PBLCKEND
*
*        COMPDEND
*
*        A COMPOUND STATMENT HAS ENDED
*
*        TRANSFERS END '2C' TO OUTPUT AND RELEASES BEGIN IN
*        STACK
*        THEN IT CHECKS IF THE END OF THIS COMPOUND STATEMENT
*        INDICATES THE END OF ANY FOR STATMENT(S) OR PROC**
*        THIS IS DONE WITH BITS2 X'01' AND THE COMMENT PROGRAM.
*        IF THE END IS FOLLOWED BY A ; OR 'END' THE STACK IS
*        INSPECTED AGAIN
*        IF THE END IS FOLLOWED BY AN 'ELSE' THE COMPOUND
*        STATMENT ITSELF IS ALL THAT HAS ENDED AT THIS POINT
*
COMPDEND BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFEND             TRANSFER END TO OUTPUT BUFFER
         LA    R3,1(,R3)               INCR OUTPUT POINTER
         L     R15,SP                  RELEASE BEGIN IN
         BCTR  R15,0                   STACK
         ST    R15,SP
COMPENDI CLI   0(R15),X'00'            ALPHA IN STACK ?
         BE    PGMEND                  YES, LOGICAL PROGRAM END
         CLI   0(R15),X'14'            PROC** ?
         BL    COMMEND                 BRANCH TO COM-PROGRAM, END-ENTRY
*                                      FOR BEGIN OR BETA OR PROC*
*                                      IN STACK
         OI    BITS2,X'01'             SET END-ELSE BIT
         B     COMMEND                 CHECK HOW END COMMENT ENDS
*                                      DCOMMENT ENDED WITH A SEMICOLON
COMPEND2 NI    BITS2,X'FE'             RESET END ELSE BIT
         L     R15,SP                  INSPECT STACK AGAIN
         CLI   0(R15),X'14'            PROC** OR FOR IN STACK ?
         BE    COMPEND3                PROC**
         LA    R4,COMPEND4             FOR GOTO FORENS AND THEN
         B     FOREND                  TEST AGAIN - COMPEND4
*
COMPEND3 OI    BITS1,X'20'             PROC**- SET DELTABIT
         LA    R4,SEMCO                RETURN FROM PBLCKEND
         B     PBLCKEND                BLOCKEND FOR PROC**
*
COMPEND4 CLI   0(R15),X'14'            PROC**,FOR OR SE ?
         BE    COMPEND3                PROC**
         BH    FOREND                  FOR
         B     SEMCO                   SOMETHING ELSE
*
*        BLOCKEND
*
*        A BETA BLOCK HAS ENDED
*
*        THE RETURN AFTER THE PBLOCKEND PROGRAM IS TO THE
*        COMPENDI TO CHECK IF SOME MORE ITAB GROUP SHOULD END AT
*        THIS POINT
*
BLOCKEND BAL   R4,PBLCKEND             EXECUTE PROGRAM BLOCKEND
         B     COMPENDI
*
*        FOREND
*
*        CORRECTS THE LIGP POINTER
*
*        INSERTS A CONTINUATION LINE IN ITAB IF THE FORSTATMENT
*        CONTAINED ANY LABEL.
*        IF THE FORSTATMENT DID NOT CONTAIN ANY DEKLARATIONS THE
*        PREVIOUSC CREATED FOR HEADENTRY IS ERASED.
*        IF ONE CONTINUATION LINE IS CREATED, FOLLOWING
*        ENCLOSING FORSTATEMENTS WILL OVERLAY THE FIRST
*        CONTINUATION LINE, IF LABELS OR NOT ETA AND SURROVNDING
*        ITABGROUPS IG NR. IS MOVED TO THE OUTPUT
*        FOR IS RELEASED IN THE STACK
*
*        ENTERED FROM SEMCO, END
*        EXITS TO END, COMPEND4, STACKTST (IN SEMCO)
*
FOREND   L     R6,LIGP
         MVC   LIGP(4),0(R6)           GET PREVIOUS LIGP HEAD
         L     R15,AITL                CURRENT ENTRY
         S     R15,KF11                MINUS ELEVEN
         TM    6(R15),X'FF'            CONTINUATION LINE NEEDED ?
         BZ    EMPTYFOR                NO
         BO    FORENDAA                OVERLAY PREVIOUS CONT LINE
         LA    R15,11(,R15)            CREATE NEW CONT LINE
FORENDAA L     R6,LIGP
         MVC   8(2,R15),8(R6)          COPY IG NUMBER
         MVI   6(R15),X'FF'            CONTINUATION LINE INDICATOR
         NI    8(R15),X'7F'            CLEAR POSSIBLE PHI INDICATOR
         MVI   5(R15),XFBLANK
         BAL   R12,ITABCLEA+4          CLEAR NEXT ENTRY
         B     EMPTYFAA
*
EMPTYFOR BAL   R12,ITABCLEC            CLEAR FORHEAD FOR EMPTY FORGROUP
EMPTYFAA LA    R0,3(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),XFBLANK           INSERT ETA
         L     R6,LIGP
         MVC   1(2,R3),8(R6)           AND CURRENT IGN IN OUTPUT BUFFER
         NI    1(R3),X'7F'             CLEAR EVENTUALLY PHI
         LA    R3,3(,R3)
         L     R15,SP                  RELEASE FOR IN STACK
         BCTR  R15,0
         ST    R15,SP
         BR    R4                      RETURN
*
*        PBLCKEND
*
*        ERASES EMPTY CONTINUATION LINES
*        WRITES OUT THE PROGRAM BLOCK TO SYSUT3
*        LENGTH IS CALCULATED AND SAVED IN ITABLEN AND STORED IN
*        THE FIRST TWO BYTES OF THE ITAB RECORD
*        SEMCNT IS PICKED UP FROM SCTAB AND ENTERED IN BYTES 6+7
*        THE BLOCK IS MOVED TO THE ITAB BUFFER WHERE IT
*        IS WRITTEN OUT
*        THE SURROUNDING BLOCKS NEW DECLARATIONS WILL BE
*        OVERLAYING THE OUTWRITTEN RECORD
*        AITL WILL POINT TO THE HEADENTRY'S PLACE OF THE BLOCK
*        WHICH NOW WAS WRITTEN OUT
*        LPBP TO THE SURROUNDING BLOCKS HEADENTRY
*        LIGP TO THE SURROUNDING ITABGROUPS HEADENTRY
*        AITL, LPBP AND LIGP WILL BE MODIFIED ACCORDINLY
*        EPSILON, THE SURROUNDING BLOCKS PBN AND IGN WILL BE PUT
*        TO THE OUTPUT
*        THE BLOCK INDICATOR IN THE STACK WILL BE RELEASED IF
*        STACK NOW IS EMPTY - ALPHA IN STACK - PGMEND WILL SET
*        THE END BIT AND CHANGE END OF DATA EXIT TO EODADIN. THIS
*        WILL CAUSE THE COMMENT PROGRAM TO CHECK FOR AN CORRECT
*        ENDCOMMENT BUT NOTHING MORE IS TO BE PROCESSED.
*        FOR PROGRAM BLOCK 0, IF ANY, THE BLOCK WILL ONLY BE
*        WRITTEN OUT AND NO FURTHER ACTIONS TAKEN.
*
*        ENTERED FROM END (BETA, PROC*), SEMCO (PROC, PROC**)
*
*        EXITS TO COMMEND (NORMAL), COMPEND4 (PROC OR PROC**
*        FOLLOWED BY END), TERMINATION (NOPBN0)
*
PBLCKEND L     R15,AITL
PBLCKEAA S     R15,KF11                SUBTRACT 11 TO EARSE
         CLI   6(R15),0                EMPTY
         BE    PBLCKEAA                CONTINUATION
         LA    R15,11(,R15)
WRTITAB  S     R15,LPBP                COMPUTE LENGTH OFITAB SECTION
         ST    R15,ITABLEN
         C     R15,KF2000              ITAB SECTION TOO LONG ?
         BL    WRTITABA                NO, BYPASS ERROR
         BAL   R6,ERR4
*
         DC    X'0426'                 E38 MORE THAN 184 IDENTIFIERS
*
WRTITABA MVC   AITL(4),LPBP            UPDATE AITL
         L     R6,LPBP
         MVC   LIGP(4),0(R6)           UPDATE LIGP
         MVC   LPBP(4),4(R6)           UPDATE LPBP
         MVC   0(2,R6),ITABLEN+2       INSERT LENGTH IN HEADENTRY
         MVI   5(R6),XFBLANK
         STM   R14,R3,SAVE1            SAVE REGISTERS
         SR    R2,R2
         IC    R2,10(,R6)              GET CORRENT PBN
         AR    R2,R2                   INSERT SEMCNT AT BLOCKSTART
         LA    R7,SCTAB(R2)            IN HEADING
         MVC   6(2,R6),0(R7)
         TM    BITS2,X'08'             PB0 ?
         BZ    WRTITABB                NO
         MVI   6(R6),0                 CORRECT SEMCNT
         MVI   7(R6),0                 FOR PB0
WRTITABB TM    BITS3,FRSITB            FIRST BLOCK TO BE WRITTEN ?
         BZ    WRT1                    YES, DO NOT CHECK
         STM   R14,R15,ERRSAVE         CHECK PREVIOUS WRITE
*
         CHECK ITABC
*
         LM    R14,R15,ERRSAVE
WRT      L     R7,AITABBUF             ADDR OF BUFFER
COMPARE1 C     R15,KF256               MORE THAN 256 BYTES TO MOVE ?
         BL    EXMVC1                  NO, MOVE ALL AT ONCE
COMPARE2 MVC   0(256,R7),0(R6)         YES, MOVE A SECTION OF 256
         LA    R6,256(,R6)             BYTES AT A TIME
         LA    R7,256(,R7)
         S     R15,KF256
         C     R15,KF256               STILL MORE THAN 256 LEFT ?
         BH    COMPARE2                YES, MOVE NEXT SECTION
EXMVC1   EX    R15,MOVE4               MOVE A SECTION OF LESS THAN 256
         LA    R3,0(R15,R7)
         L     R7,AITABBUF             LOAD ADDR OF ITAB BUFFER
         L     R15,AUT3DCB                          SYSUT3 DCB
         L     R14,ITABLEN                          LENGTH
*
         WRITE ITABC,SF,(R15),(R7),(R14)
*
         LM    R14,R3,SAVE1
         TM    BITS2,X'08'             PB0 WAS WRITTEN ?
         BOR   R4                      BRANCH BACK IF TERBIT ON
         L     R6,AITL                 CLEAR
         MVI   0(R6),0                 NEXT
         MVC   1(10,R6),0(R6)          ITABENTRY
         LA    R0,4(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'2A'             INSERT EPSILON
         L     R6,LPBP
         MVC   1(1,R3),10(R6)                 PBN
         L     R6,LIGP
         MVC   2(2,R3),8(R6)                  IGN
         NI    2(R3),X'7F'             CLEAR FIRST BIT OF IGN (PHI IND)
         LA    R3,4(,R3)
         L     R15,SP                  RELEASE
         BCTR  R15,0                   TOPBYTE
         ST    R15,SP                  IN STACK
         TM    BITS1,X'01'             TERMINATION BIT ON ?
         BOR   R4                      YES, RETURN TO ENDMISS PGM
         CLI   0(R15),0                STACK EMPTY ?
         BE    PGMEND                  YES, LOGICAL PROGRAM ENP
         BR    R4                      RETURN
*
PGMEND   OI    BITS2,ENDBIT            SET ENDBIT
         LA    R12,EODADIN             NEW EOD ADDR
         ST    R12,EODIN
         B     COMMEND
*
WRT1     OI    BITS3,FRSITB            DON'T CHECK FIRST TIME
         B     WRT
*
MOVE4    MVC   0(1,R7),0(R6)           PBLCKEND MOVE FOR ITAB
*
SCTAB    DC    XL256'00'
         DC    XL254'00'
*
*        COMMENT
*
*        THREE ENTRIES -
*        1. COM FOR THE ALGOL WORD COMMENT
*           SETS CODIT=1, CHECKS THAT COMMENT IS IN A LEGAL
*           POSITION
*        2. COMERR FOR ERRORS IN DECLARATIONS
*           ALL CHARACTERS TO NEXT SEMICOLON WILL BE SKIPPED
*           SET COBIT AND DELTABIT = 1
*        3. COMMEND ENTERED AFTER AN END IS FOUND
*           SKIPS ALL CHARACTERS TO NEXT ; OR END OR ELSE SETS
*           THE COBIT = 0
*
COMERR   OI    BITS2,X'40'             SET COBIT AND
         OI    BITS1,X'20'             DELTABIT ON
         B     COMCEE2
*
COMMEND  NI    BITS2,X'BF'             SET COBIT TO 0
         B     COMCED2
*
COM      OI    BITS2,X'40'             SET COBIT TO I
         LR    R4,R3
         BCTR  R4,0
         CLI   0(R4),X'0C'             BEGIN IN O/P ?
         BE    COMCED2
         BCTR  R4,0
         BCTR  R4,0
         CLI   0(R4),X'0B'             BETA IN O/P ?
         BE    COMCED2
         CLI   0(R4),XFDELTA           DELTA IN O/P ?
         BE    COMCED2
         BCTR  R4,0
         CLI   0(R4),X'0D'             SEMICOLON IN O/P ?
         BE    COMCED2
         BAL   R6,ERR7                 E18
*
         DC    X'0412'
*
COMCED2  LA    R1,1(,R1)               INCR R1
COMCEE2  BALR  R9,0
         SR    R2,R2
         TRT   0(73,R1),COMTABLE       SCAN THE COMMENT
         LA    R4,0(R2,R9)             BRANCH WITH OFFSET FROM COMTABLE
         BR    R4                      TO APPROPRIATE ROUTINE
*
***********************************************************************
*
*        ROUTINES COMAPOST, COMZETA, COMPOINT AND COMSEMCO
*        ARE ADDRESSED AS OFFSETS FROM COMCEE2 VIA COMTABLE
*
*        COMAPOST
*
*        IF AN END COMMENT IS PROCESSED, COBIT= 0, CHECK IF
*        APOSTROPHE IS THE START OF END OR ELSE OTHERWISE RETURN
*        TO SCAN THE COMMENT AGAIN
*
COMAPOST TM    BITS2,X'40'             COBIT ON ?
         BO    COMCED2                 YES, RETURN TO SCANNING AGAIN
         MVI   FBYTE,X'FF'             SET FBYTE
         B     ENTRAPR                 RETURN TO APOSTROE PROGRAM
*
COMZETA  B     CIB                     ZETA - RETURN TO COMERR
*
*        COMPOINT
*
*        CHECK FOR SEMICOLON ; IF NOT RETURN
*
COMPOINT LA    R6,COMCEE2               RETURN IF NOT SEMCOLON
         BAL   R12,FINDSEMC
*
*        COMSEMCO
*
*        ENDELSE BIT ON -
*        END COMMENT AFTER BEGIN OR BETA ENDED WITH A ., MEANS
*        THAT THE END MIGHT ALSO CLOSE AN FOR STATEMENT OR A
*        PROCEDURE.
*        ENDBIT ON -
*        FINAL END HAS BEEN REACHED NOTHING IS TO FOLLOW THIS
*        COMMENT IN THE CORRECT CASE.
*        AN SEMICOLON AFTER AN COMMENT IS NOT TO BE COUNTED THAT
*        IS COBIT= 1 AND DELTABIT=0 RETURN TO TEST OTHERWISE
*        RETURN VIA SEMICOLON PROGRAM
*
COMSEMCO TM    BITS2,X'01'             END ELSE BIT ?
         BO    COMPEND2                YES
         TM    BITS2,ENDBIT            FINAL END COMMENT HAS ENDED ?
         BO    READROUT                YES, OK
         TM    BITS2,X'40'             COMMENT ?
         BZ    SEMCO                   NO
         TM    BITS1,X'20'             DELIMITER ERROR ?
         BO    SEMCO                   YES
         LA    R1,1(,R1)               FOR A COMMENT SKIP SEMICOLON
         B     TESTLOOP
*
***********************************************************************
*
*        FOR
*
*        INCREASES IG AND FSN NUMBER
*        MAKES ENTRIES IN SCOPE AND GROUPTABE
*        MOVES FOR (18) TO OUTPUT FOLLOWED BY NEW IG NUMBER
*        CHECKS IF PROC IN STACK, IF YES PROC IS CHANGED TO
*        PROC**
*        PUTS FOR IN STACK
*        AN FORHEAD ENTRY IS MADE IN ITAB
*        THE RETURN IS TO TEST
*
FOR      LA    R0,3(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         LH    R15,IGC                 INCREASE ITAB GROUP NUMBER
         LA    R15,1(,R15)
         MVI   0(R3),XFFOR             MOVE 'FOR'
         STH   R15,IGC                 AND IGN
         MVC   1(2,R3),IGC
         LA    R3,3(,R3)               TO OUTPUT BUFFER
         CLI   FSN,255                 > 255 FOR STATEMENTS ?
         BNE   FORAA
         BAL   R6,ERR4
*
         DC    X'0429'                 E41
*
FORAA    IC    R2,FSN                  INCREASE FSN
         LA    R2,1(,R2)
         STC   R2,FSN
         LA    R12,SPTAB-1
         AR    R12,R2
         L     R15,LPBP
         MVC   0(1,R12),10(R15)        MAKE ENTRY IN SCOUP TABLE
         NI    BITS1,X'7F'             BEGBIT= 0
         L     R12,SP
         C     R12,ATOPSTAK            STACK OVERFLOW ?
         BL    FORBB
         BAL   R6,ERR4
*
         DC    X'0414'                 E20
*
FORBB    CLI   0(R12),X'0C'            PROC IN STACK ?
         BNE   NOPROCBY                NO
         MVI   0(R12),X'14'            MAKE PROC BE PROC**
         NI    BITS1,X'BF'             PROBIT=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BE    NOPROCBY                YES
         BAL   R12,ERROR10             NO, GENERATE E10
NOPROCBY L     R12,SP
         LA    R12,1(,R12)             INCR STACK POINTER
         MVI   0(R12),XFFOR            PUT FOR INTO STACK
         ST    R12,SP
         LH    R12,IGC
         AR    R12,R12
         AH    R12,IGC
         A     R12,AGT
         L     R15,LIGP
         MVC   0(2,R12),8(R15)         ENTRY INTO GROUP TABLE
         STC   R2,2(R12)
         NI    0(R12),X'7F'            CLEAR POSSIBLE PHI IND
         L     R15,AITL
         MVC   0(4,R15),LIGP           CONSTRUCT FOR HEAD ENTRY IN ITAB
         MVI   5(R15),X'2B'
         MVC   8(2,R15),IGC
         ST    R15,LIGP                UPDATE LIGP
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITAB ENTRY
         LA    R1,1(,R1)
         B     TESTLOOP
*
*        TYPE
*
*        ENTRED FOR INTEGER, REAL AND BOOLEAN.
*        TESTS FOR NEWBLOCK, BEGBIT, AND IF IDENTIFIER IS
*        SPECIFIED, PROBIT.
*        MOVES INTERNAL NAME CHARACTERISTICS AND PBN TO ITAB.
*        CHECKS THE IDENTIFIER FOR VALIDITY AND MOVES UP TO 6
*        CHARACTERS TO ITAB EXTERNAL NAME.
*        IF THE FIRST CHARACTER FOUND IS AN APOSTROPHE THE CHECK
*        IS VIA APOSTROF, DELIMITER AND TYPESPEC FOR ARRAY OR
*        PROCEDURE (FBYTE=F0)
*
TYPE     TM    BITS1,X'40'             PROBIT = 1 ?
         BO    SPECENT                 YES
         TM    BITS1,X'80'             BEGBIT = 1 ?
         BZ    TYPEAA
         ST    R9,SAVE1                IF YES GOTO BEGI PGM
         BAL   R9,BEG1
         L     R9,SAVE1
TYPEAA   L     R15,AITL                MOVE CHARACTERISTICS TO ITAB
         MVI   6(R15),X'C0'            TO THE 7TH AND 8TH
         MVI   7(R15),X'30'            BYTE OF THE ENTRY
         LA    R6,2(R14,R9)            MODIFIY THE LAST 4 BITS WITH
         MVN   7(1,R15),0(R6)          INFORMATION FROM THE KEYWTAB
         L     R6,LPBP
         MVC   8(1,R15),10(R6)         MOVE IN PROGRAM BLOCK NUMBER
TYPEDAFI LA    R1,1(,R1)               GET NEXT CHARACTER
         CLI   0(R1),XFA               CHAR A LETTER ?
         BNL   TYPENAME                YES
         CLI   0(R1),XFBLANK           BLANK ?
         BE    TYPEDAFI
         CLI   0(R1),XFZETA            ZETA ?
         BNE   TYPEBB
         LA    R9,TYPEDAFI+4           CHANGE INPUT
         B     CIB                     BUFFER
*
TYPEBB   CLI   0(R1),XFQUOTE           QUOTE ?
         BE    TYPECC
         LA    R15,TYPEDAFI            STORE RETURN ADDR
         B     IERSPEC                 GOTO ERROR ROUTINE
*
TYPECC   MVI   FBYTE,X'F0'             MOVE F0 TO FBYTE
         B     ENTRAPR                 CHECK FOR TYPE ARRAY OR PROC
*
TYPENAME L     R7,AITL                 GET ITAB POINTER
         MVC   0(1,R7),0(R1)           MOVE FIRST CHAR TO ITAB
         LA    R7,1(,R7)               INCREASE POINTER
         LA    R2,1                    INITIALIZE COUNTER
         LA    R9,TYPENM03             RTN IF CHANGE OF I/P BUF NEEDED
TYPENM02 LA    R1,1(,R1)               GET NEXT CHAR
TYPENM03 CLI   0(R1),XFZETA            LETTER, ZETA OR SOMETHING ELSE ?
         BE    CIB                     CHANGE I/P BUFFER
         BL    TLISTSE                 CHECK FURTHER
         C     R2,KF6                  6 CHAR ALREADY MOVED IN ?
         BE    TYPENM02                YES
         MVC   0(1,R7),0(R1)           NO, MOVE IN NEXT CHAR
         LA    R7,1(,R7)               INCREASE
         LA    R2,1(,R2)               POINTERS
         B     TYPENM02                TAKE NEXT CHAR
*
TLISTSE  CLI   0(R1),XFBLANK           BLANK ?
         BE    TYPENM02
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    TYPECOMA
         LA    R15,TYPEDAFI            RETURN ADDR FOR IER
         LA    R6,IER                  RETURN ADDR IF NO SEMICOLON
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
*
*        TYPESEMC
*
*        SEMICOLON FOUND
*        END OF THIS DECLARATION
*        DELTABIT IS TURNED ON AND THE RETURN TO TEST IS VIA
*        SEMCO
*
TYPESEMC BAL   R12,ITABCLEA            CLEAR NEXT ITAB ENTRY
         OI    BITS1,X'20'             SET DELTABIT TO ONE
         B     SEMCO                   GO TO SEMICOLON PROGRAM
*
*        TYPECOMA
*
*        AN COMMA ENDED THE IDENTIFIER
*        THE INTERNAL NAME IS COPIED AND TYPE PROGRAM UTILIZED
*        AGAIN
*
TYPECOMA L     R9,AITL
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS
         B     TYPEDAFI                RETURN TO CHECK NEXT IDENTIFIER
*
*        IER
*
*        IDENTIFIER ERROR ROUTINE
*
*        HAS 2 ENTRIES -
*        1. IERSPEC IF FIRST CHARACTER IS IN ERROR, E5
*        2. IER ANY OTHER CHARACTER, E16
*        RETURN -
*        1. VIA R15 IF AN COMMA IS FOUND AFTER
*           THE IDENTIFIER IN ERROR.
*        2. TO TEST VIA SEMCO IF AN SEMICOLON IS FOUND.
*        3. TO PROCFIN IF AN RIGHT PARENTHESIS IS FOUND AND THE
*        FMBIT IS ON WHICH INDICATES THAT THE FORMAL PARAMETER
*        LIST OF A PROCEDURE IS UNDER PROCESS
*
*        R15 MIGHT LEAD TO TYPEDAFI, IDCHECK, PROCID
*
IERSPEC  BAL   R6,ERR7
*
         DC    X'0405'                 E5
*
         B     IERSPECA
*
IER      BAL   R6,ERR2
*
         DC    X'0010'                 E16
*
IERSPECA L     R7,AITL                 RESET R7 TO START
         MVI   0(R7),0                 CLEAR EXTERNAL NAME PART
         MVC   1(5,R7),0(R7)
IERCOMMA LA    R1,1(,R1)
         LA    R6,IERSELSE             RETURN IF NO SEMICOLON FOUND
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
IERSEMCO L     R15,AITL                SEMICOLON FOUND - END OF DCL
         BAL   R12,ITABCLEC            CLEAR ITAB ENTRY
         TM    BITS3,FMBIT             FORMAL PARAMETER LIST PROCESSED?
         BO    SCYES3-8                YES, RETURN TO PROCEDURE END
         OI    BITS1,X'20'             DELTABIT = 1
         NI    BITS2,X'EF'             VALBIT=0
         MVC   KB(2),KF0               CKB = 00
         B     SEMCO                   RETURN TO TEST VIA SEMCO
*
IERSELSE CLI   0(R1),XFCOMMA           COMMA ?
         BER   R15                     RETURN IF COMMA FOUND
         TM    BITS3,FMBIT             FORMAL PARAMETER LIST PROCESSED?
         BZ    IERCOMMA                NO
         CLI   0(R1),XFRBRAC           RIGHT BRACKET ?
         BE    PROCFIN                 YES, GOTO PROCEDURE END HANDLING
         B     IERCOMMA                CONTINUE CHECKING NEXT CHAR
*
*        CODE
*
*        SETS THE PROBIT TO ZERO
*        CHECKS THAT CODE IS IN THE CORRECT PLACE AND IS
*        FOLLOWED BY A SEMICOLON
*        CORRECTS THE INTERNAL NAME OF THE PROCEDURE
*        TRANSFER THE NAME IN EXTERNAL FORM TO OUTPUT
*        RETURNS VIA PROGRAM BLOCK END TO TEST
*
CODE     NI    BITS1,X'BF'             PROBIT=0
         CLI   PZ,0                    ALL PARAMETERS SPECIFIED ?
         BZ    CODEAA                  YES
         BAL   R12,ERROR10             NO, GENERATE E10
CODEAA   L     R15,SP
         CLI   0(R15),X'0C'            PROC IN STACK ?
         BNE   CODERR                  IF NO BRANCH TO ERROR
         LR    R14,R3
         S     R14,KF3
         CLI   0(R14),XFDELTA          DELTA IN O/P ?
         BNE   CODERR                  IF NO  BRANCH TO ERROR
         L     R15,LPBP
         S     R15,KF11                GET PROCEDURE NAME
         XI    7(R15),X'80'            INTERNAL NAME IS CORRECTED
         TM    19(R15),X'80'           TYPE PROCEDURE ?
         BZ    CODEBB
         XI    29(R15),X'80'           YES, CORRECT SECOND NAME ENTRY
CODEBB   LA    R0,9(,R3)
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'3C'             TRANSFER GAMMA
         MVC   1(6,R3),0(R15)          TRANSFER NAME AND
         TR    1(6,R3),TRINTEXT        CONVERT TO EXTERNAL CODE
         MVI   7(R3),C' '              MOVE IN EXTERNAL BLANK
         MVI   8(R3),C' '              MOVE IN EXTERNAL BLANK
         LA    R3,9(,R3)
         OI    BITS1,X'20'             DELTABIT = 1
SEARCH   LA    R6,NOSEMC               RETURN IF NO SEMICOLON FOUND
         LA    R4,SEMCO                RETURN ADDR FOR PBLCKEND
         LA    R1,1(,R1)
         BAL   R12,FINDSEMC            SEMICOLON FOLLOWS ?
         B     PBLCKEND                SEMICOLON FOUND, GOTO PBLCKEND
*
NOSEMC   BAL   R6,ERR7
*
         DC    X'040F'                 E15
*
         LA    R6,FINDSEMC             PERIOD FOUND ?
         CR    R6,R9
         BE    PBLCKEND                NO
         BCTR  R1,0                    YES
         MVI   0(R1),XFPERIOD          MOVE IN A PERIOD
         BCTR  R1,0                    DECREASE R1, WILL BE INCREASED
         B     PBLCKEND                BY SEMCO. RETURN VIA PBLCKEND
*
CODERR   BAL   R6,ERR7
*
         DC    X'0418'                 E24
*
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
*        SPEC
*
*        ENTERED FOR LABEL AND STRING
*        CHECKS THAT THEY ARE IN PROCEDURE HEAD
*
SPEC     TM    BITS1,X'40'             PROBIT ON ?
         BO    SPECENT                 YES, PROCESS SPECIFIED
*                                      LABEL OR STRING
         BAL   R6,ERR7
*
         DC    X'0419'                 E25
*
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
*        SPECENT
*
*        ENTERED FOR SPECIFICATIONS FROM -
*        TYPE
*        SPEC
*        ARRAY
*        SWITCH
*        PROCEDURE
*        SAVES IN KB THE CHARACTERISTICS TAKEN FROM THE
*        DELIMITER TABLE
*
SPECENT  LA    R15,1(R14,R9)           MOVE IN IDFIELD
         MVC   KB(2),0(R15)
*
*        IDCHECK
*
*        ENTERED FROM -
*        VALUE
*        TYPEARRAY
*        TYPEPROCEDURE
*        SPECENT
*        CHECKS THE NAME FOR FORMAL PARAMETERS
*        FINDS THE ENTRY IN ITAB AND INSERTS THERE THE
*        CHARACTERISTICS AND PROGRAM BLOCK NUMBER.
*        DECREASES THE PARAMETER COUNT PZ BY ONE FOR EACH
*        CORRECT PARAMETER FOUND .
*        IF A COMMA ENDS THE IDENTIFIER IDCHECK WILL BE
*        ACTIVATED AGAIN.
*        IF A SEMICOLON ENDS THE DELIMITER THE RETURN IS TO TEST
*        VIA SEMICOLON PROGRAM
*
IDCHECK  LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XF9               LETTER ?
         BNH   IDNOLETR                NO
         MVC   IDBUCKET(6),KF0         CLEAR BUCKET WITH ZEROS
         LA    R7,IDBUCKET
         LA    R14,1
         MVC   0(1,R7),0(R1)           MOVE FIRST CHAR TO BUCKET
         LA    R7,1(,R7)
         LA    R9,IDLOOPAA             RETURN IF CIB NEEDED
IDLOOP   LA    R1,1(,R1)               GET NEXT CHAR
IDLOOPAA CLI   0(R1),XFZETA            ZETA ?
         BE    CIB                     YES
         BL    IDSEARCH                SOMETHING ELSE
         C     R14,KF6                 LETTER OR DIGIT
         BE    IDLOOP                  6 CHAR MOVED ALREADY YES ?
         MVC   0(1,R7),0(R1)           NO, MOVE CHAR
         LA    R7,1(,R7)               INCREASE POINTERS
         LA    R14,1(,R14)
         B     IDLOOP                  TAKE NEXT CHAR
*                                      FIRST CHAR WAS NOT LETTER
IDNOLETR CLI   0(R1),XFBLANK           BLANK ?
         BE    IDCHECK                 YES, GET NEXT CHAR
         CLI   0(R1),XFZETA            ZETA ?
         BNE   IDNOLETA                NO
         LA    R9,IDCHECK+4            YES, CHANGE I/P-BUFFER
         B     CIB                     BUFFER
*
IDNOLETA CLI   0(R1),XFQUOTE           QUOTE ?
         BE    IDNOLETB                YES
         LA    R15,IDCHECK             NO, SET RETURN ADD AND GOTO
         B     IERSPEC                 IDENTIFIER ERROR ROUTINE
*
IDNOLETB MVI   FBYTE,X'F0'             SET FBYTE, LOOK FOR TYPE
         B     ENTRAPR                 ARRAY OR TYPE PROC
*
IDSELSE  BAL   R6,ERR2E
*
         DC    X'0010'                 E16
*
         LA    R15,IDCHECK             RETURN ADDR FOR IER
         B     IERCOMMA                GOTO IDENTIFIER ERROR ROUTINE
*
IDBUCKET DC    6X'00'
*
IDSEARCH CLI   0(R1),XFBLANK           BLANK ?
         BE    IDLOOP                  YES, BRANCH
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    IDCOMMA                 YES, BRANCH
         LA    R6,IDSELSE              IF NOT SEMICOLON FOUND
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
         OI    BITS1,X'20'             SEMICOLON FOUND SET DELTABIT
IDCOMMA  CLC   PRIMPAR(4),KF0          ARE THERE ANY PARAMETERS ?
         BE    NOTFOUND                NO
         L     R12,PRIMPAR             GET FIRST PARAMETER
*
*        COMPID
*
*        A LOOP TO FIND THE PARAMETER IN ITAB
*
COMPID   CLC   IDBUCKET(6),0(R12)      CHECK IF IDENTIFIER FOUND
         BE    IDVALCHK                FOUND
         LA    R12,11(,R12)            NOT FOUND. TRY NEXT PARAMETER
         C     R12,AITL                IF THERE ARE ANY LEFT
         BNE   COMPID                  YES
NOTFOUND BAL   R6,ERR2E
*
         DC    X'001B'                 E27
*
         B     IDENDER
*
IDVALCHK TM    BITS2,X'10'             VALUE CALL ?
         BO    VALDLB2                 YES, GOTO VAL ROUTINE
         TM    6(R12),X'06'            SPECIAL USE BITS ON ?
         BZ    IDCHKEND                NO
         BAL   R6,ERR2E                YES, CREATE
*
         DC    X'001A'                 E26
*
         B     IDENDER                 GET NEXT IDENTIFIER
*
*        IDCHKEND
*
*        INSERTS CHARACTERISTICS AND PBN, DECRESES PZ.
*        IF BOTH VALUE AND NAME BIT ON BYTE 7 EQVALS 30 A VALUE
*        SPECIFICATION HAS BEEN MADE EARLIER SO IT IS CORRECTED
*        TO BE A CALL BY VALUE.
*
IDCHKEND L     R6,LPBP
         MVC   8(1,R12),10(R6)         INSERT PBN
         OC    6(2,R12),KB
         IC    R6,PZ                   CORRECT IDFIELD IS CREATED
         BCTR  R6,0                    PZ = PZ-1
         STC   R6,PZ
         TM    7(R12),X'30'            VALUE BIT ON ?
         BM    IDENDER
VALCALL  NI    7(R12),X'EF'            YES, ZERO NAME BIT
IDENDER  TM    BITS1,X'20'             DELTABIT ON ?
         BZ    IDCHECK                 NO, GET NEXT IDENT
         MVC   KB(2),KF0               YES, CLEAR IDFIELD
         NI    BITS2,X'EF'             SET VALBIT TO ZERO
         B     SEMCO                   GOTO SEMICOLON PROGRAM
*
*        VALUE
*
*        CHECKS THAT SPECIFICATION IS IN A PROCEDURE HEAD
*        EXITS FIRST TO IDCHECK TO FIND THE PARAMETER WILL THEN
*        RETURN TO VALDLB2 FOR FUTHER CHECKS AND TO INSERT THE
*        VALUE BIT IN THE INTERNAL NAME
*
VALUE    TM    BITS1,X'40'             PROCEDURE ?
         BZ    VALUERR                 NO, ERROR
         OI    BITS2,X'10'             YES, SET VALUE BIT TO ONE
         B     IDCHECK                 AND GO TO IDCHEK
*
VALUERR  BAL   R6,ERR7                 E28 VALVE
*
         DC    X'041C'                 OUTSIDE PROC
*
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
VALDLB2  TM    7(R12),X'20'            VALUE BIT ON IN IDENTIFIER ?
         BZ    VALDLB3                 NO
         BAL   R6,ERR2E
*
         DC    X'001E'                 E30
*
         B     IDENDER                 GET NEXT IDENTIFIER
*
VALDLB3  TM    6(R12),X'06'            SPECIAL USE BIT ENTERED ?
         BZ    VALDLB4                 NO
         BAL   R6,ERR7
*
         DC    X'041D'                 E29
*
         XI    7(R12),X'30'            MOVE IN IDFIELD
         B     IDENDER                 GET NEXT IDENTIFIER
*
VALDLB4  MVI   7(R12),X'30'            CORRECT - MOVE IN IDFIELD
         B     IDENDER                 GET NEXT IDENTIFIER
*
*        TYPEARRAY
*
*        ENTERED FROM TYPESPEC
*        TEST FOR PROBIT, BEGBIT
*        INSERTS CHARACTERISTICS IN INTERNAL NAME WITHOUT
*        DESTROYING THE TYPE SPECIFICATIONS ENTERED BY THE TYPE
*        PROGRAM
*        JOINS ARRAY PROGRAM FOR A SPECIFIED TYPEARRAY THE EXIT
*        IS TO IDCHECK
*
TYPEARRY TM    BITS1,X'40'             PROBIT ON ?
         BO    TARYDHB3                YES, SPECIFICATION
         TM    BITS1,X'80'             BEGBIT ON ?
         BZ    TYPEARAA
         ST    R9,SAVE1                YES
         BAL   R9,BEG1                 GO AND PROCESS PROGRAMBLOCK HEAD
         L     R9,SAVE1
TYPEARAA L     R7,AITL
         MVI   6(R7),X'C8'             MOVE IN
         XI    7(R7),X'34'             ID FIELD
         B     ARRYDME1                GOTO ARRAY PROCECING
*
TARYDHB3 MVI   KB,X'CA'                MOVE IN
         OI    KB+1,X'04'              TYPE ARRAY SPECIFICATION ID
         B     IDCHECK
*
*        ARRAY
*
*        TESTS FOR PRO AND BEGBIT
*        ENTERS CHARACTERISTICS IN INTERNAL NAME
*        TYPEARRAY JOINS HERE
*        PBN IS ENTERED IN INTERNAL NAME
*        09 FOR ARRAY IS MOVED TO OUTPUT
*        THE NAME IS CHECKED AND MOVED TO OUTPUT AND ITAB SHOULD
*        BE FOLLOWED BY A COMMA OR LEFT PARENTHISIS
*        SETS N (NUMBER OF ARRAYS WITH SAME DIMENSIONS) TO ONE
*
ARRAY    TM    BITS1,X'40'             PROBIT ON ?
         BO    SPECENT                 YES
         TM    BITS1,X'80'             BEGBITI ON ?
         BZ    ARRAYAA
         ST    R9,SAVE1                YES, PROCESS PROGRAM BLOCK HEAD
         BAL   R9,BEG1
         L     R9,SAVE1
ARRAYAA  L     R7,AITL
         MVI   6(R7),X'C8'             MOVE IN
         MVI   7(R7),X'06'             IO FIELD
ARRYDME1 L     R6,LPBP
         MVC   8(1,R7),10(R6)          MOVE IN PROGRAM BLOCK NUMBER
         LA    R6,9(,R7)               MOVE ADDR OF AITL+9
         ST    R6,DIM                  TO DIM
         BAL   R12,COB
         MVI   0(R3),X'09'             MOVE ARRAY ID TO O/P
         LA    R3,1(,R3)
ARRYNAME LA    R1,1(,R1)               GET FIRST CHAR
         CLI   0(R1),XF9               LETTER ?
         BNH   ARNAMESE                NO
         TM    BITS1,X'04'             LISTBIT ON ?
         BO    ARRYMULT                YES
         MVC   N(1),KF1+3              SET N=1
ARRYID   BAL   R6,IDCHECK1             CHECK, MOVE IDENT TO ITAB
ARRYSE   CLI   0(R1),XFBLANK           O/P BLANK ?
         BE    IDCHECK2
         CLI   0(R1),XFLBRAC           LEFT BRACKET ?
         BE    ARRYLPAR                YES, BRANCH
         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ?
         BE    ARRYLPAR                YES, BRANCH
         CLI   0(R1),XFCOMMA           COMMA ?
         BE    ARCOMMA
ARRAYERR BAL   R6,ERR2                 SOMETHING ELSE FOUND
*
         DC    X'0010'                 E16
*
         BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
ARYEXIT  L     R15,AITL
         BAL   R12,ITABCLEA+8          CLEAR ITAB-ENTRY
ARYEXITA NI    BITS1,X'F7'             TURN OFF ARBIT
         LA    R10,TESTLOOP            RESET RETURN REG TO MAINLOOP
         B     COMERR                  SKIP TO NEXT SEMICOLON
*
ARNAMESE CLI   0(R1),XFBLANK           NAME STARTS WITH BLANK ?
         BE    ARRYNAME                YES, BRANCH
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ARNAMEAA
         LA    R9,ARRYNAME+4
         B     CIB
*
ARNAMEAA BAL   R6,ERR7                 FIRST CHAR OF NAME IN ERROR
*
         DC    X'0405'
*
         B     ARYEXIT                 DELETE DECLARATION
*
*        ARRAYPAR
*
*        ENTERED WHEN A LEFT BRACKET OR LEFT SQUARE BRACKET IS
*        FOUND AFTER THE NAME
*        INITIALIZES D DIMENSION COUNTER=0
*        SETS THE ARBIT C PARENTHESIS COUNT=1
*        SEARCHES FOR A SLASH
*        MOVES OUT SUBSCRIPT BRACKETS TO OUTPUT
*        EXITS TO ARRAYLIST
*
ARRYLPAR OI    BITS1,X'08'             ARBIT = 1
         LA    R12,1
         STH   R12,C                   C=1
         LA    R12,0
         STC   R12,D                   D=0
         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ON ENTRY ?
         BE    ARRYLSQB                YES, BRANCH
         LA    R1,1(,R1)               GET NEXT CHAR
ARRYSLSH CLI   0(R1),XFSLASH           SLASH ?
         BE    ARRYLSQB                YES, MOVE IN LEFT SQUARE BRACKET
         CLI   0(R1),XFBLANK           BLANK ?
         BE    ARRYSLSH-4              YES, GET NEXT CHAR
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ARRYSLAA                NO, GOTO ERROR ROUTINE
         LA    R9,ARRYSLSH             YES, CHANGE
         B     CIB                     INPUT BUFFER
*
ARRYSLAA BAL   R6,ERR2
*
         DC    X'001F'                 E31
*
         BCTR  R1,0
ARRYLSQB BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLSQBR           MOVE IN LEFT SQUARE BRACKET
         LA    R3,1(,R3)               INCR
         LA    R1,1(,R1)               POINTERS
         B     LIST                    GOTO PROCESS ARRAY LIST
*
*        ARCOMMA
*
*        COPIES INTERNAL PART OF ITAB ENTRY SETS THE LISBIT
*        EXITS TO ARRAYNAME TO CHECK FIRST CHARACTER OF NEXT NAME
*        THE LIST BIT WILL THEN CAUSE ARRAYMULT TO BE
*        EXECUTED BEFORE THE REST OF THE NAME IS CHECKED
*        INCREASES N, NUMBER OF ARRAYS WITH THE SAME DIMENSIONS,
*        BY ONE
*
ARCOMMA  L     R9,AITL                 SAVE AITL
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS
         IC    R6,N                    INCREASE
         LA    R6,1(,R6)               N
         STC   R6,N                    BY ONE
         OI    BITS1,X'04'             SET LISTBIT TO ONE
         B     ARRYNAME                GET NEXT EXTERNAL NAME
*
*        ARRAYMULT
*
*        MOVES OUT THE COMMA PREVIOUSLY FOUND
*        SETS THE LISTBIT TO ZERO
*        RETURNS TO ARRAYID (AVOIDS RESETING N TO ONE)
*
ARRYMULT BAL   R12,COB
         MVI   0(R3),XFCOMMA           MOVE OUT THE COMMA
         LA    R3,1(,R3)
         NI    BITS1,X'FB'             SET LISTBIT TO ZERO
         B     ARRYID
*
*        LIST
*
*        USED FOR ARRAY AND SWITCH LIST PROCESSING
*        MAKES THE TRT AGAINST ARTABLE AND UTILIZES MAINLOOP TO
*        MOVE SCANNED BYTES AND BRANCH TO THE APPROPRIATE
*        PROGRAM, EITHER A LIST PROGRAM OR ONE OF THE COMMON
*        PROGRAMS. THE RETURN WILL BE TO LIST VIA R10
*        R10 WILL POINT TO LIST UNTIL CHANGED BY ENDLIST TO
*        POINT TO TESTLOOP AGAIN
*
LIST     BALR  R10,0                   SET RETURN REGISTER
         LR    R4,R1                   START CHAR IN SCAN
         LR    R9,R10                  RETURN FROM CIB
         SR    R2,R2
         TRT   0(73,R1),ARTABLE        SCAN AGAINST AR TABLE
         B     CONT                    UTILIZE TESTLOOP
*
*        PONTLST
*
*        USES THE SAME POINTABEL AS MAINLOOP BUT ADDS 56 TO THE
*        DISPLACEMENTS
*
PONTLST  LA    R1,1(,R1)               GET NEXT CHAR
         SR    R2,R2
         TRT   0(73,R1),PTTABLE        SCAN TO NEXT DELIMITER
         LA    R6,BPRTAB               IN PTTABLE
         L     R6,56(R6,R2)
         BR    R6                      BRANCH ACCORDING TO 56+
*                                      DISP+ BPRTAB
PZETA    LA    R9,PONTLST+4            ZETA IN POINTLIST
         B     CIB
*
*        RIGTPARL
*
*        MOVES OUT THE RIGHT PARENTHESIS
*        DECREASES THE PARENTHESIS COUNT AND RETURNS TO LIST
*
RIGTPARL BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFRBRAC           MOVE IN RIGHT BRACKET
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT  CHAR
         LH    R6,C
         BCTR  R6,0                    DECREASE PARENTHESIS COUNT
         STH   R6,C
         BR    R10
*
*        LEFTPARL
*
*        INCREASES THE PARENTHESIS COUNT
*        CHECKS IF NEXT CHARACTER IS A SLASH, IF IT IS MOVES A
*        SUBSCRIPT BRACKET OUTPUT, IF NOT MOVES A SIMPLE
*        PARENTHESIS
*
LEFTPARL LH    R6,C                    INCREASE PARENTHESIS COUNT
         LA    R6,1(,R6)
         STH   R6,C
         CLI   0(R1),XFLSQBR           LEFT SQUARE BRACKET ON INPUT ?
         BE    LPARDQAA                YES, BRANCH
LPARDQC3 LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XFSLASH           SLASH ?
         BNE   SIMPLPAR                NO, SIMPLE PARENTHESIS
LPARDQAA BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLSQBR           YES, MOVE IN SQUARE BRACKET
LPARDQ63 LA    R1,1(,R1)               INCREASE POINTERS
         LA    R3,1(,R3)
         BR    R10                     RETURN
*
SIMPLPAR CLI   0(R1),XFBLANK           NEXT CHAR BLANK ?
         BE    LPARDQC3                YES
         CLI   0(R1),XFZETA            NO, ZETA ?
         BNE   SIMPLPAA
         LA    R9,LPARDQC3+4
         B     CIB
*
SIMPLPAA BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLBRAC           MOVE IN LEFT PARENTHESIS
         B     LPARDQ63+4
*
*        COMMALST
*
*        INCREASES THE DIEMSION COUNTER D IF C THE PARENTHESIS
*        COUNTER IS 1 FOR ARRAY OR 0 FOR SWITCH LIST
*
COMMALST TM    BITS1,X'08'             AR BIT = 0 ?
         BZ    COMMAG3
         CLC   C(2),KF1+2              C=1 ?
         BNE   COMMAJ2                 NO
COMMAH2  IC    R2,D                    INCREASE D-COUNTER
         LA    R2,1(,R2)
         STC   R2,D
COMMAJ2  BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT
         LA    R3,1(,R3)               INCREASE POINTERS
         LA    R1,1(,R1)
         BR    R10
*
COMMAG3  CLC   C(2),KF0                C=0 ?
         BE    COMMAH2
         B     COMMAJ2
*
*        COLONLST
*
*        CORRECT ONLY FOR AN ARRAY LIST
*
COLONLST TM    BITS1,X'08'             ARBIT ON ?
         BZ    ERROR3                  E3 COLON DELETE D
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFCOLON           MOVE COLON TO O/P
         LA    R3,1(,R3)
         LA    R1,1(,R1)               GET NEXT CHAR
         BR    R10                     AND RETURN
*
*        SEMCLST
*
*        IS ONLY VALID FOR AN SWITCH IN WHICH CASE INDICATES
*        THE END OF THE SWITCH LIST
*        THE NUMBER OF COMPONENTS IS INSERTED IN THE INTERNAL
*        NAME
*        EXIT IS TO ENDLIST
*
SEMCLST  TM    BITS1,X'08'             ARBIT=1 ?
         BO    SEMCLER                 YES, ERROR
*
*        END OF SWITCH HANDLING
*
         CLI   D,16                    MORE THAN 15 COMPONENTS ?
         BL    SEMCLAA
         BAL   R6,ERR2
*
         DC    X'0021'                 E33
*
         B     COMPFIN
*
SEMCLAA  L     R7,AITL                 INSERT DIMENSION COUNTER
         SR    R6,R6
         IC    R6,D
         SLA   R6,4                    IN LEFTMOST 4 BYTES
         STC   R6,D
         MVZ   9(1,R7),D               IN DECLARATION
         B     ENDLIST                 GO TO ENDLIST
*
*        SEMCLER
*
*        ENTERED IF A SEMICOLON IS FOUND IN AN ARRAY LIST
*        GIVES E32, CLEAR THE ITAB ENTRY SETS THE ARBIT OFF,
*        DELTABIT ON AND RETURNS TO TEST VIA SEMCO
*
SEMCLER  BAL   R6,ERR2
*
         DC    X'0020'                 E32
*
         L     R15,AITL
         BAL   R12,ITABCLEC            CLEAR THE ENTRY
         OI    BITS1,X'20'             DELTABIT ON
         NI    BITS1,X'F7'             ARRAYBIT OFF
         B     SEMCO                   RETURN TO SEMCO, WILL RESET R10
*
*        SLASHLST
*
*        CHECKS IF NEXT CHARACTER IS A RIGHT PARENTHESIS
*        IT IS NOT MOVES OUT A SLASH
*        IF IT IS MOVES OUT A RIGHT SQUARE BRACKET
*        DECREASES THE PARENTHESIS COUNT
*        RETURNS TO LIST IF EITHER AN SWITCH LIST IS PROCESSED
*        OR THE PARENTHESIS COUNT NOT IS 0
*
SLASHLST CLI   0(R1),XFRSQBR           RIGHT SQUARE BRACKET ON ENTRY ?
         BE    SLASHRSB                YES, BRANCH
         LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XFRBRAC           RIGHT BRACKET ?
         BNE   SLASHSE                 NO SOMETHING ELSE
SLASHRSB BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFRSQBR           TRANSFER A RIGHT SQUARE BRACKET
         LA    R3,1(,R3)
         LA    R1,1(,R1)
         LH    R6,C                    DECREASE PARENTHESIS COUNT
         BCTR  R6,0
         STH   R6,C
         TM    BITS1,X'08'             ARBIT = 1 ?
         BZ    0(,R10)                 NO, RETURN
         CLC   C(2),KF0                C=0 ?
         BNE   0(,R10)                 NO, RETURN
*
*        ARRAY END HANDLING
*
*        INSERT THE DIMENSION COUNTERS IN THE INTERNAL NAME OR
*        NAMES IF MORE THAN ONE ARRAY WITH THE SAME DIMENSIONS
*
*        IF A COMMA FOLLOWS THE CHARACTERISTICS AND THE PBN IS
*        COPIED AND THE NEXT ARRAY NAME IS HANDLED
*        IF A SEMICOLON FOLLOWS ENDLIST IS ACTIVATED
*
         IC    R2,D
         CLI   D,16                    MORE THAN 16 DIMENSIONS ?
         BL    SLASHLAA
         BAL   R6,ERR2
*
         DC    X'0021'                 EOO
*
         B     COMPFIN
*
SLASHLAA SLA   R2,4                    SHIFT DIMENSION COUNTER
         STC   R2,D
SLASHREP L     R6,DIM
         MVZ   0(1,R6),D               INSERT DIMENSION COUNTER
         LA    R6,11(,R6)              INCREASE DIM POINTER
         ST    R6,DIM
         IC    R12,N                   DECREASE
         BCTR  R12,0                   REP DECLARATION COUNTER
         STC   R12,N
         CLC   N(1),KF0                ZERO ?
         BNE   SLASHREP                NO, INSERT DIM IN NEXT
         B     SLASHEND+4              ITAB ENTRY
*
SLASHSE  CLI   0(R1),XFBLANK           BLANK ?
         BE    SLASHLST
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SLASHLBB
         LA    R9,SLASHLST+4
         B     CIB
*
SLASHLBB BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFSLASH           MOVE IN A SLASH
         LA    R3,1(,R3)
         BR    R10
*
SLASHEND LA    R1,1(,R1)               GET NEXT CHAR
         CLI   0(R1),XFCOMMA           COMMA ?
         BNE   SLSHENSE                NO SOMETHING ELSE
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFCOMMA           MOVE IN A COMMA
         LA    R3,1(,R3)
         L     R9,AITL                 SAVE AITL
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         MVC   6(3,R15),6(R9)          COPY ID AND PBN FIELDS
         B     ARRYNAME                GET NEXT NAME
*
SLSHENSE CLI   0(R1),XFBLANK           BLANK ?
         BE    SLASHEND
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SLASHLCC
         LA    R9,SLASHEND+4
         B     CIB
*
SLASHLCC LA    R6,SLASHERR             RETURN IF NO SEMICOLON FOUND
         BAL   R12,FINDSEMC            LOOK FOR SEMICOLON
*
*        ENDLIST
*
*        SETS DELTABIT TO ONE, ARBIT TO ZERO, CLEARS NEXT ITABENTRY
*
*        RESETS THE RETUN REGISTER TO TEST
*        RETURNS TO TESTLOOP VIA SEMCO
*
ENDLIST  OI    BITS1,X'20'             DELTA BIT =1
         NI    BITS1,X'F7'             ARBIT= 0
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         LA    R10,TESTLOOP            RESET RETURN REG TO MAINLOOP
         B     SEMCO                   GO TO SEMICOLON PROGRAM
*
SLASHERR BAL   R6,ERR2
*
         DC    X'0022'                 E34
*
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         B     ARYEXITA                CLEAR ENTRY IN ITAB AND RETURN
*
*        SWITCH
*
*        TESTS ON PROBIT (SPECIFICATION) AND BEGBIT (PROGRAM
*        BLOCK HEAD)
*        INSERTS CHARACTERISTICS AND PBN IN INTERNAL NAME
*        INCREASES AND INSERTS LABELNUMBER LN
*        MOVES 0A SWITCH TO OUTPUT
*        SETS ARBIT TO ZERO
*        CHECKS THE NAME FOR VALIDITY AND MOVES FIRST 6
*        CHARACTERS TO OUTPUT AND ITAB VIA IDCHECK
*        SEARCHES FOR ASSIGN TO FOLLOW THE SWITCHNAME
*        INITIALIZES C PARENTHESIS COUNT AND D DIMENSION COUNT
*        WITH ZERO AND N WITH ONE
*        EXITS TO LIST
*
SWITCH   TM    BITS1,X'40'             PROCEDURE HEAD ?
         BO    SPECENT                 YES
         TM    BITS1,X'80'             BLOCK START ?
         BZ    SWITCHAA
         ST    R9,SAVE1
         BAL   R9,BEG1                 YES, PROCESS BLOCK BEGIN
         L     R9,SAVE1
SWITCHAA L     R15,AITL                MOVE IN ID FIELDS
         MVI   6(R15),X'CC'
         MVI   7(R15),X'0C'
         L     R12,LPBP
         MVC   8(1,R15),10(R12)        AND PBN- NUMBER
         LH    R12,LN                  INCREASE LABEL NUMBER
         LA    R12,4(,R12)
         CLC   LN(2),KH4096            LN OVERFLOW ?
         BL    SWITCHBB
         BAL   R6,ERR7
*
         DC    X'04D8'                 E216
*
         LA    R12,LATBEG              RESET LN
SWITCHBB STH   R12,LN
         MVC   9(2,R15),LN             MOVE IN LABEL NUMBER
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),X'0A'             MOVE IN $ SWITCH
         LA    R3,1(,R3)
         NI    BITS1,X'F7'             SET ARBIT TO ZERO
SWTCHB3  LA    R1,1(,R1)               GET FIRST CHAR
         CLI   0(R1),XF9               LETTER ?
         BL    SWTCHNSE                NO
         BAL   R6,IDCHECK1             INITIALIZE N WITH ONE
SWITCHSE CLI   0(R1),XFBLANK           BLANK ?
         BE    IDCHECK2
         CLI   0(R1),XFCOLON           COLON ?
         BE    SWCOLON
         CLI   0(R1),XFPERIOD          PERIOD ?
         BNE   SWITCHER
SWPOINT  LA    R1,1(,R1)               ONE POINT HAS BEEN FOUND
         CLI   0(R1),XFPERIOD          ONE MORE PERIOD ?
         BE    SWCOLON
         CLI   0(R1),XFEQUAL           EQUAL ?
         BE    EQUALOK
         CLI   0(R1),XFBLANK           BLANK ?
         BE    SWPOINT
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SWITCHER
         LA    R9,SWPOINT+4
         B     CIB
*
SWCOLON  LA    R1,1(,R1)               A COLON OR TWO POINTS ARE FOUND
         CLI   0(R1),XFEQUAL           EQUAL ?
         BE    EQUALOK                 YES '= OR  = OR  = ARE FOUND
         CLI   0(R1),XFBLANK           BLANK ?
         BE    SWCOLON
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SWITCHER
         LA    R9,SWCOLON+4
         B     CIB
*
EQUALOK  BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFASSIGN          MOVE IN ASSIGNMENT
         LA    R3,1(,R3)               INCREASE O/P POINTER
         SR    R6,R6
         STH   R6,C                    C=0
         MVI   N,X'01'                 N=1
         STC   R6,D                    D=0
         LA    R1,1(,R1)               GET NEXT CHAR
         B     LIST                    GO TO PROCESS LIST
*
SWTCHNSE CLI   0(R1),XFBLANK           BLANK ?
         BE    SWTCHB3
         CLI   0(R1),XFZETA            ZETA ?
         BNE   SWTCHNAA
         LA    R9,SWTCHB3+4
         B     CIB
*
SWTCHNAA BAL   R6,ERR7
*
         DC    X'0405'                 E5
*
         B     SWTCHNBB
*
SWITCHER BAL   R6,ERR2
*
         DC    X'0010'                 E16
*
         BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
SWTCHNBB L     R6,AITL                 CLEAR ITAB-ENTRY
         MVI   0(R6),0
         MVC   1(10,R6),0(R6)
         B     COMERR                  COM-PRGM ERROR-ENTRY
*
*        STRING
*
*        MOVES INTERNAL NAME TO OUTPUT
*
*        START ADDR IS IN PRPT THE STRINGS TWO FIRST BYTES
*        SPECIFIES ITS LENGTH THE TRT TESTS ONLY FOR APOSTROPHE
*        AND ZETA
*
*        NOTE -
*        THE STRING IS TAKEN FROM THE PRINT AREA (OR DUMMY) AND
*        MOVED TO KOPOOL TO CAPTURE THE STRING IN EBCDIC
*
STRING   LA    R0,6(,R3)               PROVIDE 6 BYTES IN O/P
         BAL   R12,COBSPEC
         MVC   0(4,R3),SINT            MOVE FIRST 4 BYTES OF INTERNAL
         MVC   4(2,R3),PRPT+2          NAME AND LAST TWO BYTES IN O/P
         LA    R3,6(,R3)
         L     R14,PRPT                GET CURRENT DISP WITHIN KOPOOL
         LA    R14,2(,R14)             INCREASE FOR LEN SPECIFICATION
         C     R14,KF4095              STRING POOL OVERFLOW ?
         BNH   STRAAA
         BAL   R12,E23
STRAAA   LA    R1,1(,R1)
         MVC   SQC,KF1                 STRINQUOTE=1
CDE2     LA    R9,*                    PROVIDE RETURN ADDR FOR CIB
         LR    R4,R1
         SR    R2,R2
         TRT   0(73,R1),STRTABLE       SCAN STRING
         LR    R7,R1                   COMPUTE NUMBER OF SCANNED BYTES
         SR    R7,R4
         BZ    SROUT
         LA    R0,0(R7,R14)            STRINGPOOL OVERFLOW ?
         C     R0,KF4095
         BNH   STRBBB
         BAL   R12,E23
STRBBB   BCTR  R7,0                    MOVE SCANNED BYTES TO KOPOOL
         L     R6,AKOPOOL
         LA    R15,0(R6,R14)           COMPUTE NEW KOPOOL ADDR
         LA    R0,WA                   COMPUTE ADDR
         LR    R12,R4                  OF STRING IN
         SR    R12,R0                  PRINT BUFFER
         L     R6,APRNTAR              R6 -> PRINT BUFFER
         LA    R12,10(R6,R12)          GET STRING FROM PRINT BUFFER
         EX    R7,MV1
         LA    R14,1(R7,R14)           INCREASE PRPT
SROUT    L     R12,BPRTAB(R2)          BRANCH TO APPROPRIATE
         BR    R12                     SUBROUTINE
*
*        QUOTE
*
*        CHECKS IF THE APOSTROPHE IS THE START OF A QUOTE SIGN
*
*        USES REPL TO MOVE THE FOUND CHARACTER(S) TO KOPOOL
*        REPL+1 WILL BE A LEFT OR RIGHT PARENTHESIS
*        HOW MUCH OF REPL THAT IS TO BE MOVED TO KOPOOL IS KEPT
*        TRACK OF IN R7
*        IF A COMPLETE LEFT STRING QUOTE IS FOUND THE STRING
*        QUOTE COUNTER IS INCREASED AND THE REPL MOVED TO
*        KOPOOL
*        IF A COMPLETE RIGHT STRING QUOTE IS FOUND IT IS CHECKED
*        IF IT IS THE CLOSING ONE FOR THE STRING (SQC=0) IF IT
*        IS ENDSTRING IS ACTIVATED IF NOT REPL IS MOVED TO KOPOOL
*        AFTER SQC IS DECREASED
*        IF NO COMPLETE QUOTE IS FOUND THE CHARACTER(S) FOUND
*        ARE MOVED TO KOPOOL FROM REPL, LENGTH SPECIFIED BY R7
*        AND THE SCANNING OF THE STRING IS REASSUMED
*
QUOTE    LA    R1,1(,R1)
         LA    R9,*+4
         CLI   0(R1),XFRBRAC           RIGHT BRACKET IN SOURCE ?
         BNE   NORIP                   NO, BRANCH
         MVI   REPL+1,C')'             MAKE REPL A RIGHT STRING QUOTE
         B     TESTAPOS                LOOK FOR APOSTROPHE
*
NORIP    CLI   0(R1),XFLBRAC           LEFT BRACKET ?
         BNE   TESTZETA                NO
         MVI   REPL+1,C'('             MAKE REPL A LEFT STRING QUOTE
         B     TESTAPOS                LOOK FOR APOSTROPHE
*
TESTZETA CLI   0(R1),XFZETA            ZETA ?
         BE    CIB                     YES
         LA    R7,1                    NO MOVE STRING ONLY FIRST QUOTE
         B     CID1                    MOVE REPL
*
TESTAPOS LA    R1,1(,R1)
         LA    R9,*+4                  NEW RETURN FOR CIB
         CLI   0(R1),XFQUOTE           SECOND QUOTE ?
         BE    CID                     YES
         CLI   0(R1),XFZETA            ZETA
         BE    CIB                     YES
         LA    R7,2                    NO, MOVE TO STRING ONLY FIRST
         B     CID1                    QUOTE AND THE BRACKET
*
CID      LA    R1,1(,R1)
         L     R12,SQC
         CLI   REPL+1,C'('             LEFT STRING QUOTE ?
         BNE   CIDAA                   NO
         LA    R12,1(,R12)             YES, INCREASE STRING QUOTE COUNT
         B     CIDBB
*
CIDAA    S     R12,KF1                 RIGHT QUOTE DECREASE QUOTE COUNT
         BNP   ENDSTRIN                BRANCH IF LAST QUOTE
CIDBB    ST    R12,SQC
         LA    R7,3
CID1     LA    R0,0(R7,R14)
         C     R0,KF4095               STRING POOL OVERFLOW ?
         BNH   CIDCC
         BAL   R12,E23
CIDCC    L     R6,AKOPOOL
         LA    R6,0(R6,R14)            COMPUTE NEW KOPOOL ADDR
         BCTR  R7,0
         EX    R7,MV2                  MOVE CONTENTS OF REPL TO KOPOOL
         LA    R14,1(R7,R14)           INCREASE PRPT
         B     CDE2                    RESUME SCAN OF STRING
*
*        ENDSTRIN
*
*        INCREASES PRPT
*        PUTS THE LENGTH OF THE STRING (DIFFERENCE BETWEEN NEW
*        AND OLD PRPT) AS TWO FIRST BYTES IN THE STRING
*
ENDSTRIN L     R9,PRPT                 COMPUTE LENGTH AND PUT IT
         STH   R14,PRPT+2              AS THE FIRST 2 BYTES IN STRING
         L     R6,AKOPOOL              AND
         LA    R12,0(R6,R9)            STORE NEW DISPLACEMENT
         SR    R14,R9                  IN PRPT
         STCM  R14,B'0011',0(R12)
         BR    R10                     RETURN TO TESTLOOP
*
E23      NOP   E23AA                   NO BRANCH FIRST TIME
         BAL   R6,ERR7                 RECORD ERROR
*
         DC    X'0417'                 E23
*
E23AA    OI    E23+1,X'F0'             NO ERROR RECORDING NEXT
         LA    R14,64
         ST    R14,PRPT                RESET PRPT TO 64 AGAIN
         BR    R12                     RESUME STRING PROCESSING
*
MV1      MVC   0(1,R15),0(R12)
MV2      MVC   0(1,R6),REPL
*
SQC      DC    F'0'                    STRING QUOTE COUNTER (AFTER MV2
SINT     DC    X'2EC90000'             STRING INTERNAL NAME OF
*                                      THE CONSTANT POOL NAMED KOPOOL
REPL     DC    C''' '''                BUCKET TO BUILD STRING QUOTES
*
*        TYPPROC
*
*        TEST PRO AND BEGBIT (FORMAL PARAMETER, BLOCKSTART)
*        MOVE PHI TO OUTPUT
*        INSERT CHARACTERISTICS IN INTERNAL NAME
*        JOIN PROCEDURE PROGRAM
*
TYPPROC  TM    BITS1,X'40'             PROCEDURE PROCEDED ?
         BZ    TYPPROCA                NO
         MVI   KB,X'CA'                YES, MOVE IN IDFIELD
         OI    KB+1,X'C0'
         B     IDCHECK
*
TYPPROCA TM    BITS1,X'80'             BEGBIT ON ?
         BZ    TYPPROCB                NO
         ST    R9,SAVE1
         BAL   R9,BEG1                 GOTO PROCESS PROGRAM BLOCK HEAD
         L     R9,SAVE1
TYPPROCB LA    R0,4(,R3)               PROVIDE FOUR BYTES IN OUTPUT
         BAL   R12,COBSPEC             CHECK IF ENOUGH SPACE IN O/P
         MVI   0(R3),X'0F'             MOVE PHI TO O/P
         L     R15,AITL
         XI    7(R15),X'F0'            MOVE IN THE IDCODE
         MVI   6(R15),X'CA'            TO ITAB
         B     PROCEAG1                JOIN THE PROCEDURE PROGRAM
*
*        PROCEDURE
*
*        TEST PRO AND BEGBIT
*        MOVE PI TO OUTPUT
*        INSERT CHARACTERISTICS IN INTERNAL NAME
*        TYPE PROCEDURE JOINS PROCEDURE PROGRAM AT THIS POINT
*        IF ALPHA IN STACK, PRECOMPILED PROCEDURE, THE STARTBIT
*        IS TURNED ON.
*        PROC IS PUT IN STACK.
*        PROGRAM BLOCK AND ITAB GROUP NUMBER ARE INCREASED.
*        THE NEW PBN IS INSERTED IN THE INTERNAL NAME.
*        LABELNUMBER IS INCREASED AND INSERTED IN THE INTERNAL
*        NAME.
*        THE SURRONDING BLOCKNUMBET IS ENTERED IN PBTAB1.
*        THE SURROUNDING ITAB GROUP NUMBER IN GROUPTABLE
*        SEMCNT IS ENTERED IN SCTAB
*        PROBIT AND IDBIT ARE SET TO ONE
*        PROBIT WILL STAY AS ONE TILL THE WHOLE PROCEDURE HEAD
*        IS PROCESSED. THE IDBIT IS ONLY ONE WHILE THE PROCEDURE
*        NAME IS PROCESSED
*        THE FM (FORMAL PARAMETER) BIT IS ONE WHEN THE FORMAL
*        PARAMETER LIST IS PROCESSED
*        THE ITAB GROUP NUMBER IS MOVED TO O/P
*
PROCEDUR TM    BITS1,X'40'             PROBIT ON ?
         BO    SPECENT                 YES, GOTO IDCHECK VIA SPECENT
         TM    BITS1,X'80'             BEGBIT ON ?
         BZ    PROCEDAA                NO
         ST    R9,SAVE1
         BAL   R9,BEG1                 GOTO PROCESS PROGRAM BLOCK HEAD
         L     R9,SAVE1
PROCEDAA LA    R0,4(,R3)               PROVIDE FOUR BYTES IN OUTPUT
         BAL   R12,COBSPEC
         MVI   0(R3),X'0E'             TRANSFER PI IN OUTPUT BUFFER
         L     R15,AITL
         MVI   6(R15),X'CA'            CONSTRUCT FIRST PART
         MVI   7(R15),X'C0'            INTERNAL NAME ?
PROCEAG1 L     R14,SP
         CLI   0(R14),0                ALPHA IN STACK ?
         BNE   L3
         OI    BITS2,X'20'             TURN ON THE STARTBIT
         OI    BITS3,PROCESD
L3       LA    R14,1(,R14)             INCREASE STACK POINTER
         C     R14,ATOPSTAK            STACK OVERFLOW ?
         BL    L3AA                    NO, BYPASS ERROR
         BAL   R6,ERR4
*
         DC    X'0414'                 E20
*
L3AA     MVI   0(R14),X'0C'            PUT PROC IN STACK
         ST    R14,SP
         CLI   PBC,X'FF'               PBN OVERFLOW ?
         BNE   L3BB                    NO
         BAL   R6,ERR4
*
         DC    X'0416'                 E22
*
L3BB     IC    R2,PBC
         LA    R2,1(,R2)               INCR PROGRAM BLOCK NUMBER
         STC   R2,8(,R15)              INSERT PBN IN INTERVAL NAME
         STC   R2,PBC
         LA    R14,PBTAB1(R2)          CONSTRUCTION
         L     R6,LPBP                 PBTAB1-ENTRY
         MVC   0(1,R14),10(R6)
         AR    R2,R2
         LA    R14,SCTAB(R2)
         MVC   0(2,R14),SEMCNT         MAKE ENTRY IN SCTAB
         LH    R14,LN                  INCREASE
         LA    R14,4(,R14)             LABEL NUMBER BY 4
         CLC   LN(2),KH4096            LN OVERFLOW ?
         BL    L3CC
         BAL   R6,ERR7
*
         DC    X'04D8'                 E216
*
         LA    R14,LATBEG              RESET LN
L3CC     STH   R14,LN
         L     R15,AITL
         MVC   9(2,R15),LN             PUT LN IN INTERNAL NAME
         LH    R15,IGC                 INCREASE
         LA    R15,1(,R15)             ITAB GROUP NUMBER
         STH   R15,IGC
         MVC   1(2,R3),IGC             INSERT IT IN OUTPUT BUFFER
         LA    R3,3(,R3)
         AR    R15,R15
         AH    R15,IGC
         A     R15,AGT
         L     R7,LIGP
         MVC   0(2,R15),8(R7)          CONSTRACT ENTRY
         MVI   2(R15),0                IN GROUP TABLE
         NI    0(R15),X'7F'            CLEAR POSSIBLE PHI IND.
         MVC   PRIMPAR(4),KF0          CLEAR PRIMPAR WITH ZEROS
         OI    BITS1,X'50'             PROBIT =1,IDBIT =1
         MVI   PZ,0                    SET PARAMTER COUNT TO ZERO
*
*        PROCID
*
*        PROCESSES PROCEDURE NAME (IDBIT=1) AND THE FORMAL
*        PARAMETER LIST (IDBIT=0).
*        CHECKS THE NAMES FOR VALIDITY AND MOVES THEM TO ITAB
*        AND OUTPUT. THIS IS DONE VIA IDCHECK1.
*
PROCID   LA    R1,1(,R1)
         CLI   0(R1),XFA               IDENTIFIER STARTS WITH LETTER ?
         BL    NOLETTER
         BAL   R6,IDCHECK1             CHECK AND MOVE IDENTIFIER
*                                      TO O/P AND ITAB
         CLI   0(R1),XFBLANK           BLANK ?
         BE    IDCHECK2
         TM    BITS1,X'10'             IDBIT ONE ?
         BZ    EDA1                    GOTO PROCESS FORMAL PARAM NAME
*
*        PROCEDURE NAME
*
*        CHECKS IF NAME IS FOLLOWED BY A FORMAL PARAMETER LIST
*        FOLLOWS OR ; NO PARAMETERS.
*        CHECKS IF PROCEDURE IS TO BE PRECOMPILED, IF YES THE
*        NAME IN EXTERNAL FORM AND EXPANDED WITH TWO ZEROS IS PUT
*        FOR AN ESDCARD IF SYLIN OR DECK HAS BEEN SPECIFIED
*        THE NEW BLOCK ENTRY IS DONE IN ITAB
*        ADDR OF SURROUNDING BLOCK AND ITAB GROUP, PBN AND IGN
*        ARE INSERTED
*        IF TYPEPROCEDURE, BIT 0 IN BYTE 8 IS TURNED ON AND A
*        SECOND ENTRY OF THE NAME IS DONE AFTER THE HEAD ENTRY
*        IDBIT IS SET TO ZERO, FMBIT TO ONE
*        IF THE NAME WAS FOLLOWED BY A SEMICOLON THE SEMCO IS
*        ACTIVATED
*        IF THE NAME WAS FOLLOWED BY A (PROCID IS ACTIVATED TO
*        PROCESS THE NAME IN THE LIST
*
         CLI   0(R1),XFLBRAC           IDENTIFIER FOLLOWED BY ) ?
         BE    EBF4
         LA    R6,ERROR16              RETURN IF NOT SEMICOLON
         BAL   R12,FINDSEMC            SEMICOLON ?
         OI    BITS1,X'20'             YES, DELTABIT = 1
EBF4     TM    BITS3,PROCESD
         BZ    DEL1                    NO
         NI    BITS3,PROCOFF
         TM    COMPFLGS+1,NLOAD+NDECK  DECK AND OR LOAD SPECIFIED ?
         BO    DEL1                    NO, NO NEED FOR ESD CARD
         L     R15,AITL
         MVC   ESDNAME(6),0(R15)       MOVE IN AND
         TR    ESDNAME(6),TRINTEXT     TRANSLATE EXTERNAL NAME
DEL1     TM    BITS1,X'20'             DELTABIT = 1 ?
         BO    ECA3
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         MVI   0(R3),XFLBRAC           INSERT )
         LA    R3,1(,R3)
ECA3     BAL   R12,ITABCLEA
         MVC   0(4,R15),LIGP           MOVE ADDR HEADING ENTRY OF
*                                      EMBRACING ITAB GROUP
         MVC   4(4,R15),LPBP           AND PBLOCK TO ENTRY
         MVC   8(2,R15),IGC            INSERT CURRENT IGN
         MVC   10(1,R15),PBC           AND CURRENT PBN
         ST    R15,LIGP                NEW VALUE OF LIGP
         ST    R15,LPBP                AND LPBP
         S     R15,KF11                DECREASE R15 BY 11
         TM    7(R15),X'03'            TYPE PROCEDURE ?
         BNZ   TPROHEAD
         LA    R15,22(,R15)            IF NO INCREASE ITAB POINTER
ECJ3     BAL   R12,ITABCLEC
         OI    BITS3,FMBIT             FMBIT
         TM    BITS1,X'20'             DELTABIT = 1 ?
         BO    SEMCO                   YES, BRANCH TO SEMICOLON PROGRAM
         NI    BITS1,X'EF'             IDBIT'= 0
         B     PROCID                  CHECK NEXT IDENTIFIER
*
*        CONSTRUCT TYPE PROCEDURE ENTRIES
*
TPROHEAD OI    19(R15),X'80'           FLAGBIT IN IGN IS SET ON
         LA    R0,22(,R15)             ONE MORE ENTRY IN ITAB AVAIL
         C     R0,ELI
         BNE   TPROHEAA
         BAL   R6,ERR4
*
         DC    X'04D5'                 E213
*
TPROHEAA MVC   22(11,R15),0(R15)       ENTER PROCEDURE NAME ONCE MORE
         XI    28(R15),X'08'           NO-ASSIGNMENTBIT IS SWITCHED OFF
         LA    R15,33(,R15)            INCREASE ITAB POINTER
         B     ECJ3                    BRANCH BACK TO MAIN PROGRAM
*
NOLETTER CLI   0(R1),XFBLANK           BLANK INSTEAD OF LETTER ?
         BE    PROCID
         LA    R9,PROCID+4
         CLI   0(R1),XFZETA            ZETA ?
         BE    CIB                     CHANGE INPUT BUFFER
         TM    BITS1,X'10'
         BO    ERROR16A
         LA    R15,PROCID              LOAD RETURN ADDR
         B     IERSPEC                 BRANCH TO IDENTIFIER ERROR RTN
*
ERROR16  BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
         TM    BITS1,X'10'             PROC NAME UNDER PROCESS ?
         BO    PNAMERR                 YES
         LA    R15,PROCID              LOAD RETURN ADDR
         B     IER                     GO TO IDENTIFIER ERROR ROUTINE
*
ERROR16A BAL   R6,ERR7
*
         DC    X'0405'                 E5
*
         B     PNAMERRA
*
PNAMERR  BAL   R6,ERR2
*
         DC    X'0010'                 E16
*
PNAMERRA L     R7,AITL
         MVI   0(R7),0                 CLEAR ERRONEOUS NAME
         MVC   1(5,R7),0(R7)
         LA    R6,PROCIDSE             THE PROCEDURE HEAD SHOULD
         BAL   R12,FINDSEMC
         B     EBF4-4                  BE FOLLOWED BY EITHER  ( OR .,
*
PROCIDSE CLI   0(R1),X'06'             KEEP LOOPING UNTIL :-
         BE    EBF4                    LEFT PARENTHESIS FOUND
         BAL   R12,FINDSEMC-4
         B     EBF4-4                  SEMICOLON FOUND
*
*        FORMAL PARAMETER LIST
*
*        IF A COMMA TERMINATES THE NAME, THE COMMA IS TRANSFERED
*        TO OUTPUT AND THE PARAMETER COUNT (PZ) IS INCREASED BY
*        ONE. AND PROCID IS ACTIVATED AGAIN TO TAKE NEXT NAME.
*        IF A ) FOLLOWED BY A SEMICOLON TERMINATES THE NAME
*        PROCFIN IS ACTIVATED.
*        IF A ) BUT NO SEMICOLON TERMINATES THE NAME PROCDEL IS
*        ACTIVATED.
*        IS SOMETHING ELSE IS FOUND RHA IS MOVED TO OUTPUT, THE
*        PARAMETER COUNT IS NOT INCREASED AND IER ACTIVATED
*        (NOLETTER, ERROR16).
*
EDA1     CLI   0(R1),XFCOMMA           COMMA TERMINATES IDENTIFIER ?
         BNE   PAR
PROCEND  IC    R2,PZ                   INCREASE
         LA    R2,1(,R2)               PARAMETER
         STC   R2,PZ                   COUNT BY ONE
         BAL   R12,ITABCLEA            CHECK AND CLEAR NEXT ITABENTRY
         BAL   R12,COB                 CHECK IF O/P AREA FILLED
         CLI   0(R1),XFCOMMA           COMMA ?
         BNE   PROCFIN
         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT BUFFER
         LA    R3,1(,R3)               INCREASE OUTPUT POINTER
         B     PROCID                  BRANCH TO CHECK THE
*                                      NEXT IDENTIFIER
PAR      CLI   0(R1),XFRBRAC           ) TERMINATES IDENTIFIER ?
         BE    PROCEND
         BAL   R12,COB
         MVI   0(R3),X'3D'             MOVE IN RHA
         LA    R3,1(,R3)
         LA    R15,PROCID              NOTE RETURN ADDR
         B     IER                     BRANCH TO IER
*
*        PROCFIN
*
*        THE PARAMETER LIST HAS BEEN COMPLETLY CHECKED
*        THE RIGHT PARENTHESIS IS MOVED TO OUTPUT
*        DELTABIT IS SET TO ONE
*        THE PARENTHESIS COUNT IS INSERTED IN THE PROCEDURE NAME
*        (NAMES IF TYPEPROCEDURE)
*        FMBIT IS TURNED OFF
*        THE RETURN TO TEST IS VIA SEMCO
*        IF SOMETHING ELSE, E5 OR E16 IS GENERATED AND
*        EVERYTHING SKIPPED TILL A (OR A; IS FOUND (NOLETTER,
*        PNAMERR)
*
PROCFIN  LA    R1,1(,R1)
         LA    R6,PROCDEL              RETURN IF NO SEMICOLON
         BAL   R12,FINDSEMC            SEMICOLON ?
         BAL   R12,COB
         LA    R14,SEMCO               EXIT FROM PROCEDUR
SCYES3   MVI   0(R3),XFRBRAC           MOVE RIGHT PARENTHESIS
         LA    R3,1(,R3)
         OI    BITS1,X'20'             DELTABIT'=1
         CLI   PZ,16                   MORE THAN 15 PARAMETERS ?
         BL    SCYES3A
         BAL   R6,ERR2B
*
         DC    X'0024'                 E36
*
         B     COMPFIN
*
SCYES3A  L     R15,LPBP
         S     R15,KF11                R15 CONTAINS ADDR OF PROC ENTRY
         SR    R6,R6
         IC    R6,PZ
         SLA   R6,4(0)
         STC   R6,PZ
         MVZ   9(1,R15),PZ             INSERT NUMBER OF PARAMETERS INTO
*                                      INTERNAL NAME OF THE PROCEDURE
         SRA   R6,4
         STC   R6,PZ                   NOTE NUMBER OF PARAMETER
         NI    BITS3,FMOFF             FMBIT=0
         TM    19(R15),X'80'           TYPE PROCEDURE ?
         BZ    TESTPAR                 NO
         MVZ   31(1,R15),9(R15)        INSERT NUMBER OF PARAMETERS INTO
*                                      SECOND NAME ENTRY IN ITAB
         LA    R15,33(,R15)            GET ADDR OF FIRST PARAMETER
         B     TESTPARA
*
TESTPAR  LA    R15,22(,R15)
TESTPARA CLI   PZ,0                    ANY PARAMETERS ?
         BER   R14                     NO, BRANCH TO SEMCO OR COMERR
         ST    R15,PRIMPAR             YES, SAVE ADDR OF FIRST
         BR    R14                     BRANCH TO SEMCO OR COMERR
*
*        PROCDEL
*
*        A RIGHT PARENTHESIS HAS BEEN FOUND IN THE LIST THAT NOT
*        WAS FOLLOWED BY A .,
*        IF A LETTERSTRING IS FOUND, NOTHING BUT LETTERS AND
*        BLANKS FOLLOWED BY ..(A COMMA IS MOVED TO OUTPUT AND
*        PROCID ACTIVATED TO TAKE NEXT NAME.
*        IF ANYTHING ELSE IS FOUND E37 IS GENERATED AND COMERR
*        ACTIVATED TO SKIP TO NEXT SEMICOLON
*        ADDR OF COMERR IS PUT IN R14
*
PROCDEL  LA    R9,DELCHECK+4
DELCHECK LA    R1,1(,R1)
         CLI   0(R1),XFA               LETTER ?
         BNL   DELCHECK
         CLI   0(R1),XFZETA            ZETA ?
         BE    CIB
         CLI   0(R1),XFCOLON           COLON ?
         BE    DELCOLON
         CLI   0(R1),XFBLANK
         BE    DELCHECK
         CLI   0(R1),XFPERIOD          PERIOD ?
         BNE   ERROR37
DELPOINT LA    R1,1(,R1)
         CLI   0(R1),XFPERIOD          ONE MORE PERIOD ?
         BE    DELCOLON
         CLI   0(R1),XFBLANK
         BE    DELPOINT
         CLI   0(R1),XFZETA            ZETA ?
         BNE   ERROR37
         LA    R9,DELPOINT+4
         B     CIB
*
DELCOLON LA    R1,1(,R1)
         CLI   0(R1),XFLBRAC           LEFT BRACKET ?
         BE    DELPAREN
         CLI   0(R1),XFBLANK           BLANK ?
         BE    DELCOLON
         CLI   0(R1),XFZETA            ZETA ?
         BNE   DELCOLAA
         LA    R9,DELCOLON+4
         B     CIB
*
DELCOLAA BCTR  R1,0                    NO BRACKETS FOLLOWS THE COLON
         B     ERROR37                 RESET R1 AND GOTO ERROR 37
*
DELPAREN BAL   R12,COB
         MVI   0(R3),XFCOMMA           MOVE COMMA TO OUTPUT INSTEAD OF
         LA    R3,1(,R3)               DELIMITER INCREASE O/P POINTER
         B     PROCID                  RETURN TO PROCEDURE CHECKING
*
ERROR37  BAL   R6,ERR2B
*
         DC    X'0025'                 E37
*
         LA    R14,COMERR
         B     SCYES3
*
*        ENDMISS
*
*        ENTERED IF END OF DATA FOUND BEFORE LOGICAL
*        PROGRAM END IS FOUND BY SCAN I/II
*        CLOSES WHAT REMAINS OPEN IN STACK
*        GENERATES PATTERN FOR ERROR MESSAGE 39
*
ENDMISS  TM    BITS2,STARTBIT          FIRST BEGIN FOUND ?
         BO    ENDMISSA                YES
         BAL   R6,ERR4
*
         DC    X'042C'                 E44 NOTHING PROCESSED
*
ENDMISSA OI    BITS1,TERBIT
TERMSEAC LA    R4,TERMSEAC             RETURN FOR PBLCKEND PROG
         L     R15,SP                  GET STACK POINTER
         CLI   0(R15),X'04'            BETA IN STACK ?
         BE    STEPUP
         CLI   0(R15),X'08'            BEGIN ?
         BE    STEPUP
         CLI   0(R15),X'10'            PROC* ?
         BNE   TERMBRNC
STEPUP   LH    R6,ENDCOUNT             INCREASE END COUNT
         LA    R6,1(,R6)
         STH   R6,ENDCOUNT
TERMBRNC IC    R2,0(,R15)
         L     R6,TERMTAB(R2)          BRANCH ACORDING TO STACK BYTE
         BR    R6
*
TERMTAB  DC    A(ERROR39)              +00
         DC    A(PBLCKEND)             +04 BEGIN
         DC    A(TERMBGN)              +08 BETA
         DC    A(PBLCKEND)             +12 PROC
         DC    A(PBLCKEND)             +16 PROC*
         DC    A(PBLCKEND)             +20 PROC**
         DC    A(FOREND)               +24 FOR
*
TERMBGN  BAL   R12,COB
         MVI   0(R3),XFEND             MOVE OUT END TO O/P
         LA    R3,1(,R3)
         L     R15,SP
         BCTR  R15,0                   RELEASE BEGIN IN STACK
         ST    R15,SP
         B     TERMSEAC
*
*        SLUT2
*
*        ENTERED FROM IEX00 IF INTERUPT OCCURS BEFORE GETMAIN
*
SLUT2    OI    BITS3,NOFREE             INTERUPT OCCURED PRIOR
         B     SCANEND                  GOTO PROCESS TERMINATING PART
*
*        READROUT
*
*        ENTERED AFTER FINAL END COMMENT HAS BEEN CHECKED SHOULD
*        EXIT TO EODADIN VIA OS EOD ROUTINE
*
READROUT LA    R1,1(,R1)
         LA    R9,*+4
         TRT   0(73,R1),BTABLE         ONLY VALID CHARACTER AFTER
         CLI   0(R1),XFZETA            FINAL END COMMENT IS ZETA ?
         BE    CIB
         B     ERR9                    ANYTHING ELSE FOUND
*
E39PAR   DC    X'0727'                 E39
*
ERROR39  LA    R6,E39PAR
         BAL   R12,ERROR1              CREATE E39 PATTERN
         LH    R6,ENDCOUNT
         CVD   R6,DOUBLE
         UNPK  SAVE1(4),DOUBLE+5(3)
         OI    SAVE1+3,X'F0'           INSERT NUMBER OF ENDS MISSING
         MVC   4(3,R15),SAVE1+1        IN ERROR PATTERN
*
*        EODADIN
*
*        FALL THROUGH TO TERMINATION SECTION
*
*        TERMINATION
*
*        WRITES PB0 ITAB BLOCK FOR A PRECOMPILED PROCEDURE
*        WRITES LAST O/P REC IF MORE THAN ONE O/P RECORD
*        CORRECTS PRPT AND MOVES THE CONSTANTS 0 TROUGH 15 TO
*        THE CONSTANT POOL
*        IF NO TERMINATION ERROR AND EITHER DECK OR LOAD IS
*        SPECIFIED ESD CARD AND TXT CARDS ARE GENERATED WITH
*        GENERATE
*        CHECKS LAST ITAB RECORD WRITTEN, IF ANY
*        CLOSES SYSIN, SYSUT1, SYSUT3
*        MAKES A FREEMAIN
*        EXITS -
*        IEX20 IF NO TERMINATING ERROR
*        IEX21 IF TERMINATING ERROR
*
EODADIN  TM    COMPFLGS,TERR           TERMINATING ERROR ?
         BO    KOPOOLRL                YES, DO NOT WRITE OUT ANYTHING
         L     R1,AITAB                CHECK IF PB0
         LA    R1,11(,R1)              CONTAINS ANYTHING
         C     R1,AITL
         BE    NOPBN0                  NO PB0
         L     R15,AITL
         OI    BITS2,X'08'             SET SWITCH
         BAL   R4,WRTITAB              WRITE OUT PB0
NOPBN0   BAL   R12,COB
         MVI   0(R3),X'2D'             MOVE OMEGA TO O/P
         LA    R3,1(,R3)
         CLI   ONC,0                   ONLY ONE O/P RECORD ?
         BE    NOPBN0A                 YES, BRANCH
         BAL   R12,COBSPEB             NO, WRITE LAST O/P BUFFER
         B     KOPOOLRL
*                                      SOURCE PROGRAM IN STORAGE
NOPBN0A  OI    COMPFLGS+2,SPIC         LEAVE THE SINGLE BUFFER IN CORE
KOPOOLRL L     R7,POOLLOC
         MVC   0(64,R7),KFCONST        MOVE THE CONSTANTS 0 TO 15
         L     R6,PRPT
         A     R6,KF7                  MAKE PRPT POINT
         ST    R6,PRPT                 TO THE NEAREST
         NI    PRPT+3,X'F8'            DOUBLE WORD BOUNDARY
         MVC   PBN+1(1),PBC            SAVE NUMBER OF BLOCKS
         IC    R1,FSN
         BCTR  R1,0                    CORRECT FSN
         STC   R1,ZFSNMAX              SET FOR SCAN 3
         CLC   MGESITL,KF25000         WILL ITAB OVER FLOW ?
         BL    KOPOOLAA
         BAL   R6,ERR7
*
         DC    X'0413'                 E 19
*
KOPOOLAA TM    COMPFLGS+1,NDECK+NLOAD  DECK AND OR LOAD SPECIFIED
         BO    SCANEND                 NO, SKIP ESD CARD GENERATION
         SR    R6,R6
         MVC   ESDPARM,ESDNAME         SET NAME OF PROCEDURE/BEGIN
KOPOOLBB BAL   R2,GENESD               GENERATE ESD RECORD
*
ESDPARM  DC    CL8' '                  ESD NAME
         DC    X'0000'                 ESD TYPE SD
*
         MVC   29(3,R1),KF0            CORRECT FIRST ESD CARD
         L     R2,AKOPOOL
         MVC   GENTLEN,PRPT+2          GET LENGTH OF KOPOOL FOR TXT
         BAL   R14,GENTXTS             GENERATE TXT CARD
*
GENTLEN  DC    H'0'                    UPDATED PRIOR TO GENTXTS CALL
*
SCANEND  TM    BITS3,FRSITB
         BZ    CLSYSUT3
*
         CHECK ITABC
*
CLSYSUT3 L     R6,AUT3DCB
*
         CLOSE ((R6),REREAD),TYPE=T    RESET SYSUT3
*
         L     R6,ASYSDCB              CLOSE SYSIN
*
         CLOSE ((R6))
*
         FREEPOOL (R6)
*
         L     R6,AUT1DCB
         TM    COMPFLGS,TERR           TERMINATING ERROR ?
         BO    CLSPERM                 YES, CLOSE SYSUT1 FOR GOOD
*
         CLOSE ((R6),REREAD),TYPE=T    RESET SYSUT1
*
         B     FREE
*
CLSPERM  CLOSE ((R6),REREAD)           CLOSE SYSUT1
*
FREE     TM    BITS3,NOFREE            INTERUPT BEFORE GETMAIN ?
         BO    GETERRPH                YES, DO NOT MAKE FREEMAIN
         L     R0,POOLLEN
         L     R1,POOLLOC
*
         FREEMAIN R,LV=(0),A=(1)
*
         OI    COMPFLGS+2,NOSC         SET SWITCH FOR ERROR MESSAGES
         TM    COMPFLGS,TERR           TERMINATING ERROR ?
         BO    GETERRPH                YES, CALL IEX21
         ICM   R6,B'1111',BRACKET      BRACKET COUNTER ZERO ?
         BZ    NEXTMOD                 YES, BRANCH
         OI    COMPFLGS,COMPMODE+SERR  NO, SET SYNTAX MODE
*
NEXTMOD  XCTL  EP=IEX20000             GOTO ITAB MANIPULATION
*
GETERRPH XCTL  EP=IEX21000             GOTO ERROR MESSAGE HANDLING
*
*        GENERATE
*
*        REGISTER DEFINITIONS
*
*        R1                            OUTPUT RECORD POINTER
*        R2                            ADDR OF INFORMATION
*        R3                            TYPE OF RECORD TO BE GENERATED
*        R4                            RETURN REG
*        R14                           L'INFORMATION FROM CALL
*        R15                           L'WITHIN RECORD
*
*        BIT PATTERNS
*
SDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION
LDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION
RLDFLAG  EQU   B'00001101'             FLAG USED IN RLD ENTRY
*
*        ADDR DISPLACEMENTS
*
GENESD   LA    R14,16                  R14 ALWAYS 16
         LA    R3,ESDT                 INDICATE ESD CALL
         MVC   PIDENT,0(R2)            NAME TO IDENT PART
         B     GEN3                    CALL FOR FIRST OUT REC
*
GENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD R14 GIVEN IN CALL
GEN2     LA    R3,TXTT                 INDICATE TXT CALL
*
GEN1     L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL IOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0 = L'INFORMATION IN REC
         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUTH SPACE LEFT ?
         BL    GEN6A                   NO
         LR    R15,R14                 YES R15=R14 FROM CALL
GEN6A    AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
*
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES
*
GEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?
         BH    GEN3                    YES
         BR    R4
*
GEN3     EQU   *                       CALL FOR NEW OUTPUT RECORD
PUNCH    ST    14,ERRSAVE
         TM    COMPFLGS+1,NLOAD+NDECK  BOTH DECK AND LOAD SPECIFIED ?
         BZ    BOTH                    YES
         L     R1,APCHDCB              R1- > SYSPUNCH DCB
         TM    COMPFLGS+1,NDECK        DECK ?
         BZ    PUT1                    YES
PUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH IF
*
         ST    R1,SAVOUTA              ONLY SYSPUNCH SPECIFIED
         L     14,ERRSAVE
         B     PUNCHOUT
*
BOTH     TM    BITS2,X'02'             FIRST PUT ?
         BZ    FIRSTPUT                YES
         L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
PUT2     L     R1,APCHDCB              R1- > SYSPUNCH DCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT1A                   GOTO PUT SYSLIN
*
FIRSTPUT OI    BITS2,X'02'
         B     PUT2
*
PUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             INCR CARD COUNT
         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P
         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?
         BNE   GEN6                    NO
         ST    R6,4(R1)                YES, INSERT R6
         MVI   4(R1),C' '
         B     GEN6
*
*        TABLES AND MOVE ROUTINES
*
*        ESD RECORD
*
ESDT     DC    X'02'                   RECORD CODE
         DC    C'ESD'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    C'      '
         DC    H'48'                   MAXIMUM LENTH IN RECORD
*
*        MOVE ESD INFORMATION TO OUTPUT
*
GEN7     MVC   16(9,R1),0(R2)          MOVE ESD NAME AND ESD TYPE SD TO
*                                      ESD OUTPUT RECORD
         MVC   25(L'ESDCON,R1),ESDCON  CHANGE LAST PART OF ENTRY
         LA    R3,1                    SET ESID NUMBER TO 1
         STH   R3,14(R1)               INSERT ESID NUMBER
         B     10(,R2)                 RETURN TO CALLING ROUTINE
*
*        TXT RECORD
*
TXTT     DC    X'02'                   RECORD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        MOVE TXT INFORMATION TO OUTPUT
*
GEN8     BCTR  R15,0                   DECR R15
         STC   R15,*+5                 INSERT LENGTH TO MOVE IN MVC
         MVC   16(0,R1),0(R2)          MOVE INFORMATION TO OUTAREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    EXIT MOVE TXT ROUTINE
*
*        BPRTAB
*
*        CONTAINS ADDR CONSTANTS OF PROGRAMS UTILIZED BY -
*        TEST
*        LIST
*        POINT
*        APOSTROF
*        POINTLST
*
*        THE ADDRESSES ARE PICKED UP WITH DISPLACEMENTS FROM -
*        TESTTABL
*        ARTABLE
*        PTTABLE
*        ATABLE
*        PTTABLE FOR POINTLST 56 IS ADDED TO DISP GIVEN
*
BPRTAB   DC    A(0)              + 00
         DC    A(TRANSOP)        + 04
         DC    A(TRANSOP)        + 08
         DC    A(TRANSOP)        + 12
         DC    A(TRANSOP)        + 16
         DC    A(TRANSOP)        + 20
         DC    A(TRANSOP)        + 24
         DC    A(COLON)          + 28  COLON
         DC    A(SEMCO)          + 32  SEMICOLON
         DC    A(RIGHTPAR)       + 36
         DC    A(BLANK)          + 40
         DC    A(ERR1)           + 44
         DC    A(POINT)          + 48
         DC    A(APOSTROF)       + 52
         DC    A(CIB)            + 56
         DC    A(ASSIGN)         + 60
         DC    A(DECPOINT)       + 64
         DC    A(ERR5)           + 68  ERROR AFTER POINT
         DC    A(BLKAPOS)        + 72  BLANK AFTER APOSTROPHE
         DC    A(NPAFTAPO)       + 76  NOT PERMITTED AFTER APOSTR
         DC    A(SCALE)          + 80  DIGIT OR SIGN AFTER APOSTROPHE
         DC    A(COLONLST)       + 84  COLON IN LIST
         DC    A(SEMCLST)        + 88  SEMICOLON IN LIST
         DC    A(DELIMIT)        + 92  DELIMITER PROGRAM
         DC    A(ZETAAPO)        + 96  ZETA AFTER APOSTROPHE
         DC    A(EROUT)          +100  ERROR (FROM W1,W2OR W3 TAB)
         DC    A(LEFTPARL)       +104  LEFT PARENTHESIS IN LIST
         DC    A(RIGTPARL)       +108  RIGHT PARENTHESIS IN LIST
         DC    A(PZETA)          +112  ZETA AFTER POINT IN LIST
         DC    A(ASSIGN)         +116  ASSIGNMENT POINT IN LIST
         DC    A(DECPOINT)       +120  DECPOINT IN LIST
         DC    A(ERR5A)          +124  POINT ERROR IN LIST
         DC    A(COMMALST)       +128  COMMA IN LIST
         DC    A(PONTLST)        +132  POINT IN LIST
         DC    A(SLASHLST)       +136  SLASH IN LIST
         DC    A(QUOTE)          +140  QUOTE
         DC    A(SEMC60)         +144
*
*        PTTABLE
*
*        USED BY -
*        POINT
*        PONTLST
*        GIVES DISPLACEMENTS TO BPRTAB
*        WHEN USED BY PONTLST 56 IS ADDED TO ORIGINAL DISP
*
PTTABLE  DC    AL1(68)                +00   XFPLUS
         DC    AL1(68)                +01   XFMINUS
         DC    AL1(68)                +02   XFASTER
         DC    AL1(68)                +03   XFSLASH
         DC    AL1(0)                 +04
         DC    AL1(0)                 +05
         DC    AL1(68)                +06   XFLBRAC
         DC    AL1(68)                +07   XFCOLON
         DC    AL1(0)                 +08   XFLSQBR
         DC    AL1(0)                 +09
         DC    AL1(0)                 +0A
         DC    AL1(68)                +0B   XFSCOLON
         DC    AL1(0)                 +0C
         DC    AL1(0)                 +0D
         DC    AL1(0)                 +0E
         DC    AL1(0)                 +0F
         DC    AL1(60)                +10   XFEQUAL
         DC    AL1(68)                +11   XFLT
         DC    AL1(68)                +12   XFGT
         DC    AL1(0)                 +13
         DC    AL1(0)                 +14
         DC    AL1(0)                 +15
         DC    AL1(0)                 +16
         DC    AL1(0)                 +17
         DC    AL1(0)                 +18
         DC    AL1(0)                 +19
         DC    AL1(0)                 +1A
         DC    AL1(0)                 +1B
         DC    AL1(0)                 +1C
         DC    AL1(0)                 +1D
         DC    AL1(0)                 +1E
         DC    AL1(0)                 +1F
         DC    AL1(68)                +20   XFNOT
         DC    AL1(0)                 +21
         DC    AL1(68)                +22   XFOR
         DC    AL1(68)                +23   XFAMPER
         DC    AL1(0)                 +24
         DC    AL1(32)                +25   XFCOMMA
         DC    AL1(68)                +26   XFRBRAC
         DC    AL1(0)                 +27
         DC    AL1(0)                 +28   XFRSQBR
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(0)                 +2B   XFBLANK
         DC    AL1(68)                +2C
         DC    AL1(28)                +2D   XFPERIOD
         DC    AL1(68)                +2E   XFQUOTE
         DC    AL1(56)                +2F
         DC    AL1(64)                +30   XF0
         DC    AL1(64)                +31   XF1
         DC    AL1(64)                +32   XF2
         DC    AL1(64)                +33   XF3
         DC    AL1(64)                +34   XF4
         DC    AL1(64)                +35   XF5
         DC    AL1(64)                +36   XF6
         DC    AL1(64)                +37   XF7
         DC    AL1(64)                +38   XF8
         DC    AL1(64)                +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(68)                +40   XFA
         DC    AL1(68)                +41   XFB
         DC    AL1(68)                +42   XFC
         DC    AL1(68)                +43   XFD
         DC    AL1(68)                +44   XFE
         DC    AL1(68)                +45   XFF
         DC    AL1(68)                +46   XFG
         DC    AL1(68)                +47   XFH
         DC    AL1(68)                +48   XFI
         DC    AL1(68)                +49   XFJ
         DC    AL1(68)                +4A   XFK
         DC    AL1(68)                +4B   XFL
         DC    AL1(68)                +4C   XFM
         DC    AL1(68)                +4D   XFN
         DC    AL1(68)                +4E   XFO
         DC    AL1(68)                +4F   XFP
         DC    AL1(68)                +50   XFQ
         DC    AL1(68)                +51   XFR
         DC    AL1(68)                +52   XFS
         DC    AL1(68)                +53   XFT
         DC    AL1(68)                +54   XFU
         DC    AL1(68)                +55   XFV
         DC    AL1(68)                +56   XFW
         DC    AL1(68)                +57   XFX
         DC    AL1(68)                +58   XFY
         DC    AL1(68)                +59   XFZ
         DC    AL1(68)                +59   XFDOLLAR
         DC    AL1(68)                +59   XFUNDER
         DC    AL1(68)                +59   XFHASH
         DC    AL1(68)                +59   XFAT
*
*        ATABLE
*
*        USED BY THE APOSTROPHE PROGRAM
*        GIVES DISPLACEMENTS TO BPRTAB
*
ATABLE   DC    AL1(80)                +00   XFPLUS
         DC    AL1(80)                +01   XFMINUS
         DC    AL1(100)               +02   XFASTER
         DC    AL1(0)                 +03   XFSLASH
         DC    AL1(0)                 +04
         DC    AL1(0)                 +05
         DC    AL1(0)                 +06   XFLBRAC
         DC    AL1(100)               +07   XFCOLON
         DC    AL1(0)                 +08   XFLSQBR
         DC    AL1(0)                 +09
         DC    AL1(0)                 +0A
         DC    AL1(100)               +0B   XFSCOLON
         DC    AL1(0)                 +0C
         DC    AL1(0)                 +0D
         DC    AL1(0)                 +0E
         DC    AL1(0)                 +0F
         DC    AL1(100)               +10   XFEQUAL
         DC    AL1(100)               +11   XFLT
         DC    AL1(100)               +12   XFGT
         DC    AL1(0)                 +13
         DC    AL1(0)                 +14
         DC    AL1(0)                 +15
         DC    AL1(0)                 +16
         DC    AL1(0)                 +17
         DC    AL1(0)                 +18
         DC    AL1(0)                 +19
         DC    AL1(0)                 +1A
         DC    AL1(0)                 +1B
         DC    AL1(0)                 +1C
         DC    AL1(0)                 +1D
         DC    AL1(0)                 +1E
         DC    AL1(0)                 +1F
         DC    AL1(100)               +20   XFNOT
         DC    AL1(0)                 +21
         DC    AL1(100)               +22   XFOR
         DC    AL1(100)               +23   XFAMPER
         DC    AL1(0)                 +24
         DC    AL1(100)               +25   XFCOMMA
         DC    AL1(100)               +26   XFRBRAC
         DC    AL1(0)                 +27
         DC    AL1(0)                 +28   XFRSQBR
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(72)                +2B   XFBLANK
         DC    AL1(76)                +2C
         DC    AL1(100)               +2D   XFPERIOD
         DC    AL1(92)                +2E   XFQUOTE
         DC    AL1(96)                +2F
         DC    AL1(80)                +30   XF0
         DC    AL1(80)                +31   XF1
         DC    AL1(80)                +32   XF2
         DC    AL1(80)                +33   XF3
         DC    AL1(80)                +34   XF4
         DC    AL1(80)                +35   XF5
         DC    AL1(80)                +36   XF6
         DC    AL1(80)                +37   XF7
         DC    AL1(80)                +38   XF8
         DC    AL1(80)                +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(0)                 +40   XFA
         DC    AL1(0)                 +41   XFB
         DC    AL1(0)                 +42   XFC
         DC    AL1(0)                 +43   XFD
         DC    AL1(0)                 +44   XFE
         DC    AL1(0)                 +45   XFF
         DC    AL1(0)                 +46   XFG
         DC    AL1(0)                 +47   XFH
         DC    AL1(0)                 +48   XFI
         DC    AL1(0)                 +49   XFJ
         DC    AL1(0)                 +4A   XFK
         DC    AL1(0)                 +4B   XFL
         DC    AL1(0)                 +4C   XFM
         DC    AL1(0)                 +4D   XFN
         DC    AL1(0)                 +4E   XFO
         DC    AL1(0)                 +4F   XFP
         DC    AL1(0)                 +50   XFQ
         DC    AL1(0)                 +51   XFR
         DC    AL1(0)                 +52   XFS
         DC    AL1(0)                 +53   XFT
         DC    AL1(0)                 +54   XFU
         DC    AL1(0)                 +55   XFV
         DC    AL1(0)                 +56   XFW
         DC    AL1(0)                 +57   XFX
         DC    AL1(0)                 +58   XFY
         DC    AL1(0)                 +59   XFZ
         DC    AL1(0)                 +5A   XFDOLLAR
         DC    AL1(0)                 +5B   XFUNDER
         DC    AL1(0)                 +5C   XFHASH
         DC    AL1(0)                 +5D   XFAT
*
*        BTABLE
*
*        BLANK TABLES - SCANS FOR FIRST NONBLANK CHARACTER
*        USED BY -
*        BLANK
*        BLKAPOS BLANK AFTER APOSTROPHE
*        READROUT IN TERMINATION
*
BTABLE   DC    X'FF'                  +00   XFPLUS
         DC    X'FF'                  +01   XFMINUS
         DC    X'FF'                  +02   XFASTER
         DC    X'FF'                  +03   XFSLASH
         DC    X'00'                  +04
         DC    X'00'                  +05
         DC    X'FF'                  +06   XFLBRAC
         DC    X'FF'                  +07   XFCOLON
         DC    X'FF'                  +08   XFLSQBR
         DC    X'00'                  +09
         DC    X'00'                  +0A
         DC    X'FF'                  +0B   XFSCOLON
         DC    X'00'                  +0C
         DC    X'00'                  +0D
         DC    X'00'                  +0E
         DC    X'00'                  +0F
         DC    X'FF'                  +10   XFEQUAL
         DC    X'FF'                  +11   XFLT
         DC    X'FF'                  +12   XFGT
         DC    X'00'                  +13
         DC    X'00'                  +14
         DC    X'00'                  +15
         DC    X'00'                  +16
         DC    X'00'                  +17
         DC    X'00'                  +18
         DC    X'00'                  +19
         DC    X'00'                  +1A
         DC    X'00'                  +1B
         DC    X'00'                  +1C
         DC    X'00'                  +1D
         DC    X'00'                  +1E
         DC    X'00'                  +1F
         DC    X'FF'                  +20   XFNOT
         DC    X'00'                  +21
         DC    X'FF'                  +22   XFOR
         DC    X'FF'                  +23   XFAMPER
         DC    X'00'                  +24
         DC    X'FF'                  +25   XFCOMMA
         DC    X'FF'                  +26   XFRBRAC
         DC    X'00'                  +27
         DC    X'FF'                  +28   XFRSQBR
         DC    X'00'                  +29
         DC    X'00'                  +2A
         DC    X'00'                  +2B   XFBLANK
         DC    X'FF'                  +2C
         DC    X'FF'                  +2D   XFPERIOD
         DC    X'FF'                  +2E   XFQUOTE
         DC    X'FF'                  +2F
         DC    X'FF'                  +30   XF0
         DC    X'FF'                  +31   XF1
         DC    X'FF'                  +32   XF2
         DC    X'FF'                  +33   XF3
         DC    X'FF'                  +34   XF4
         DC    X'FF'                  +35   XF5
         DC    X'FF'                  +36   XF6
         DC    X'FF'                  +37   XF7
         DC    X'FF'                  +38   XF8
         DC    X'FF'                  +39   XF9
         DC    X'00'                  +3A
         DC    X'00'                  +3B
         DC    X'00'                  +3C
         DC    X'00'                  +3D
         DC    X'00'                  +3E
         DC    X'00'                  +3F
         DC    X'FF'                  +40   XFA
         DC    X'FF'                  +41   XFB
         DC    X'FF'                  +42   XFC
         DC    X'FF'                  +43   XFD
         DC    X'FF'                  +44   XFE
         DC    X'FF'                  +45   XFF
         DC    X'FF'                  +46   XFG
         DC    X'FF'                  +47   XFH
         DC    X'FF'                  +48   XFI
         DC    X'FF'                  +49   XFJ
         DC    X'FF'                  +4A   XFK
         DC    X'FF'                  +4B   XFL
         DC    X'FF'                  +4C   XFM
         DC    X'FF'                  +4D   XFN
         DC    X'FF'                  +4E   XFO
         DC    X'FF'                  +4F   XFP
         DC    X'FF'                  +50   XFQ
         DC    X'FF'                  +51   XFR
         DC    X'FF'                  +52   XFS
         DC    X'FF'                  +53   XFT
         DC    X'FF'                  +54   XFU
         DC    X'FF'                  +55   XFV
         DC    X'FF'                  +56   XFW
         DC    X'FF'                  +57   XFX
         DC    X'FF'                  +58   XFY
         DC    X'FF'                  +59   XFZ
         DC    X'FF'                  +5A   XFDOLLAR
         DC    X'FF'                  +5B   XFUNDER
         DC    X'FF'                  +5C   XFHASH
         DC    X'FF'                  +5D   XFAT
*
*        TESTTABL
*
*        USED BY MAIN LOOP SCANNING - GIVES DISPLACEMENTS TO BPRTAB
*
TESTTABL DC    AL1(0)                 +00   XFPLUS
         DC    AL1(0)                 +01   XFMINUS
         DC    AL1(4)                 +02   XFASTER
         DC    AL1(8)                 +03   XFSLASH
         DC    AL1(0)                 +04
         DC    AL1(0)                 +05
         DC    AL1(12)                +06   XFLBRAC
         DC    AL1(28)                +07   XFCOLON
         DC    AL1(0)                 +08   XFLSQBR
         DC    AL1(0)                 +09
         DC    AL1(0)                 +0A
         DC    AL1(144)               +0B   XFSCOLON
         DC    AL1(0)                 +0C
         DC    AL1(0)                 +0D
         DC    AL1(0)                 +0E
         DC    AL1(0)                 +0F
         DC    AL1(0)                 +10   XFEQUAL
         DC    AL1(16)                +11   XFLT
         DC    AL1(20)                +12   XFGT
         DC    AL1(0)                 +13
         DC    AL1(0)                 +14
         DC    AL1(0)                 +15
         DC    AL1(0)                 +16
         DC    AL1(0)                 +17
         DC    AL1(0)                 +18
         DC    AL1(0)                 +19
         DC    AL1(0)                 +1A
         DC    AL1(0)                 +1B
         DC    AL1(0)                 +1C
         DC    AL1(0)                 +1D
         DC    AL1(0)                 +1E
         DC    AL1(0)                 +1F
         DC    AL1(24)                +20   XFNOT
         DC    AL1(0)                 +21
         DC    AL1(0)                 +22   XFOR
         DC    AL1(0)                 +23   XFAMPER
         DC    AL1(0)                 +24
         DC    AL1(0)                 +25   XFCOMMA
         DC    AL1(36)                +26   XFRBRAC
         DC    AL1(0)                 +27
         DC    AL1(0)                 +28   XFRSQBR
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(40)                +2B   XFBLANK
         DC    AL1(44)                +2C
         DC    AL1(48)                +2D   XFPERIOD
         DC    AL1(52)                +2E   XFQUOTE
         DC    AL1(56)                +2F
         DC    AL1(0)                 +30   XF0
         DC    AL1(0)                 +31   XF1
         DC    AL1(0)                 +32   XF2
         DC    AL1(0)                 +33   XF3
         DC    AL1(0)                 +34   XF4
         DC    AL1(0)                 +35   XF5
         DC    AL1(0)                 +36   XF6
         DC    AL1(0)                 +37   XF7
         DC    AL1(0)                 +38   XF8
         DC    AL1(0)                 +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(0)                 +40   XFA
         DC    AL1(0)                 +41   XFB
         DC    AL1(0)                 +42   XFC
         DC    AL1(0)                 +43   XFD
         DC    AL1(0)                 +44   XFE
         DC    AL1(0)                 +45   XFF
         DC    AL1(0)                 +46   XFG
         DC    AL1(0)                 +47   XFH
         DC    AL1(0)                 +48   XFI
         DC    AL1(0)                 +49   XFJ
         DC    AL1(0)                 +4A   XFK
         DC    AL1(0)                 +4B   XFL
         DC    AL1(0)                 +4C   XFM
         DC    AL1(0)                 +4D   XFN
         DC    AL1(0)                 +4E   XFO
         DC    AL1(0)                 +4F   XFP
         DC    AL1(0)                 +50   XFQ
         DC    AL1(0)                 +51   XFR
         DC    AL1(0)                 +52   XFS
         DC    AL1(0)                 +53   XFT
         DC    AL1(0)                 +54   XFU
         DC    AL1(0)                 +55   XFV
         DC    AL1(0)                 +56   XFW
         DC    AL1(0)                 +57   XFX
         DC    AL1(0)                 +58   XFY
         DC    AL1(0)                 +59   XFZ
         DC    AL1(0)                 +5A   XFDOLLAR
         DC    AL1(0)                 +5B   XFUNDER
         DC    AL1(0)                 +5C   XFHASH
         DC    AL1(0)                 +5D   XFAT
*
*        ARTABLE
*
*        USED BY LIST EQUIVALENT TO THE USE OF TESTTABLE BY TESTLOOP
*        GIVES DISPLACEMENT TO BPRTAB
*
ARTABLE  DC    AL1(0)                 +00   XFPLUS
         DC    AL1(0)                 +01   XFMINUS
         DC    AL1(4)                 +02   XFASTER
         DC    AL1(136)               +03   XFSLASH <-------
         DC    AL1(0)                 +04                  
         DC    AL1(0)                 +05                  
         DC    AL1(104)               +06   XFLBRAC <--    
         DC    AL1(84)                +07   XFCOLON       
         DC    AL1(104)               +08   XFLSQBR <--    
         DC    AL1(0)                 +09                  
         DC    AL1(0)                 +0A                  
         DC    AL1(88)                +0B   XFSCOLON       
         DC    AL1(0)                 +0C                  
         DC    AL1(0)                 +0D                  
         DC    AL1(0)                 +0E                  
         DC    AL1(0)                 +0F                  
         DC    AL1(0)                 +10   XFEQUAL        
         DC    AL1(16)                +11   XFLT           
         DC    AL1(20)                +12   XFGT           
         DC    AL1(0)                 +13                  
         DC    AL1(0)                 +14                  
         DC    AL1(0)                 +15                  
         DC    AL1(0)                 +16                  
         DC    AL1(0)                 +17                  
         DC    AL1(0)                 +18                  
         DC    AL1(0)                 +19                  
         DC    AL1(0)                 +1A                  
         DC    AL1(0)                 +1B                  
         DC    AL1(0)                 +1C                  
         DC    AL1(0)                 +1D                  
         DC    AL1(0)                 +1E                  
         DC    AL1(0)                 +1F                  
         DC    AL1(24)                +20   XFNOT          
         DC    AL1(0)                 +21                  
         DC    AL1(0)                 +22   XFOR           
         DC    AL1(0)                 +23   XFAMPER        
         DC    AL1(0)                 +24                  
         DC    AL1(128)               +25   XFCOMMA        
         DC    AL1(136)               +26   XFRBRAC        
         DC    AL1(0)                 +27                  
         DC    AL1(136)               +28   XFRSQBR <-------
         DC    AL1(0)                 +29
         DC    AL1(0)                 +2A
         DC    AL1(40)                +2B   XFBLANK
         DC    AL1(44)                +2C
         DC    AL1(132)               +2D   XFPERIOD
         DC    AL1(52)                +2E   XFQUOTE
         DC    AL1(56)                +2F
         DC    AL1(0)                 +30   XF0
         DC    AL1(0)                 +31   XF1
         DC    AL1(0)                 +32   XF2
         DC    AL1(0)                 +33   XF3
         DC    AL1(0)                 +34   XF4
         DC    AL1(0)                 +35   XF5
         DC    AL1(0)                 +36   XF6
         DC    AL1(0)                 +37   XF7
         DC    AL1(0)                 +38   XF8
         DC    AL1(0)                 +39   XF9
         DC    AL1(0)                 +3A
         DC    AL1(0)                 +3B
         DC    AL1(0)                 +3C
         DC    AL1(0)                 +3D
         DC    AL1(0)                 +3E
         DC    AL1(0)                 +3F
         DC    AL1(0)                 +40   XFA
         DC    AL1(0)                 +41   XFB
         DC    AL1(0)                 +42   XFC
         DC    AL1(0)                 +43   XFD
         DC    AL1(0)                 +44   XFE
         DC    AL1(0)                 +45   XFF
         DC    AL1(0)                 +46   XFG
         DC    AL1(0)                 +47   XFH
         DC    AL1(0)                 +48   XFI
         DC    AL1(0)                 +49   XFJ
         DC    AL1(0)                 +4A   XFK
         DC    AL1(0)                 +4B   XFL
         DC    AL1(0)                 +4C   XFM
         DC    AL1(0)                 +4D   XFN
         DC    AL1(0)                 +4E   XFO
         DC    AL1(0)                 +4F   XFP
         DC    AL1(0)                 +50   XFQ
         DC    AL1(0)                 +51   XFR
         DC    AL1(0)                 +52   XFS
         DC    AL1(0)                 +53   XFT
         DC    AL1(0)                 +54   XFU
         DC    AL1(0)                 +55   XFV
         DC    AL1(0)                 +56   XFW
         DC    AL1(0)                 +57   XFX
         DC    AL1(0)                 +58   XFY
         DC    AL1(0)                 +59   XFZ
         DC    AL1(0)                 +5A   XFDOLLAR
         DC    AL1(0)                 +5B   XFUNDER
         DC    AL1(0)                 +5C   XFHASH
         DC    AL1(0)                 +5D   XFAT
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        TRINTEXT
*
*        CONVERT TABLE FOR INTERNAL CODE TO EBCDIC
*
*        USED BY CODE TO TRANSLATE PROCEDURE NAME PROCEDURE TO
*        TRANSLATE PROCEDURE NAME FOR ESD CARD IF PRECOMPILED
*        SPECIFIED
*
TRINTEXT DC    96C' '
         ORG   TRINTEXT+XFBLANK
         DC    C' '
         ORG   TRINTEXT+XF0
         DC    C'0123456789'
         ORG   TRINTEXT+XFA
         DC    C'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
         ORG   TRINTEXT+XFDOLLAR
         DC    C'$_#@'
         ORG
*
*        KWLUTAB
*
*        USED TO REFERENCE ENTRIES IN KEYWTAB FOR KEYWORDS
*
KWLUTAB  DC    A(KEYWDL01)             KEY WORDS LENGTH OF 1
         DC    A(KEYWDL02)             KEY WORDS LENGTH OF 2
         DC    A(KEYWDL03)             KEY WORDS LENGTH OF 3
         DC    A(KEYWDL04)             KEY WORDS LENGTH OF 4
         DC    A(KEYWDL05)             KEY WORDS LENGTH OF 5
         DC    A(KEYWDL06)             KEY WORDS LENGTH OF 6
         DC    A(KEYWDL07)             KEY WORDS LENGTH OF 7
         DC    A(KEYWDL08)             KEY WORDS LENGTH OF 8
         DC    A(KEYWDL09)             KEY WORDS LENGTH OF 9
         DC    A(KEYWDL10)             KEY WORDS LENGTH OF 10
*
*        KEYWTAB
*
*        CONTAINS ALL KEYWORDS, EACH FOLLOWED BY 3 BYTES OF
*        INFORMATION BEING 2 BYTES OF CHARACTERISTICS AND A
*        DISPLACEMENT INTO DELPRGTB
*        FOR A SECTION IN THE KEYWTAB. A SECTION CONTAINS
*        ALL THE KEYWORDS OF THE SAME LENGTH
*        1. THE FIRST BYTE IN EACH SECTION SAYS HOW MANY ENTRIES
*           THERE ARE IN THE SECTION. THEREAFTER THE DELIMITER PLUS 3
*           BYTES OF INTERNAL CODE MAKES A SUBSECTION
*        2. THE FIRST 2 BYTES OF THE INTERNAL CODE IS
*           CHARECTERISTCS FOR THE DELIMITER
*        3. THE THIRD BYTE IS A DISPLACEMENT TO THE DELPRGTB,
*           WHERE THE ADDR IS PICKED UP TO THE PROGRAM TO HANDLE
*           THE KEYWORD
*
KEYWTAB  EQU   *
KEYWDL01 DC    AL1(2)                  NUMBER OF ENTRIES
         IEXCGEN DC,'/'                /
         DC    XL2'0400',XL1'00'
         IEXCGEN DC,'('                (
         DC    XL2'0000',XL1'04'       LEFT BRACKET (STRING)
*
KEYWDL02 DC    AL1(3)                  NUMBER OF ENTRIES
         IEXCGEN DC,'DO'               DO
         DC    XL2'1C00',XL1'08'
         IEXCGEN DC,'IF'               IF
         DC    XL2'1D00',XL1'0C'
         IEXCGEN DC,'OR'               OR
         DC    XL2'2200',XL1'00'
*
KEYWDL03 DC    AL1(4)                  NUMBER OF ENTRIES
KWEND    IEXCGEN DC,'END'              END
         DC    XL2'0000',XL1'10'
         IEXCGEN DC,'FOR'              FOR
         DC    XL2'0000',XL1'14'
         IEXCGEN DC,'AND'              AND
         DC    XL2'2300',XL1'00'
         IEXCGEN DC,'NOT'              NOT
         DC    XL2'2000',XL1'00'
*
KEYWDL04 DC    AL1(9)                  NUMBER OF ENTRIES
         IEXCGEN DC,'REAL'             REAL
         DC    XL2'C212',XL1'18'
         IEXCGEN DC,'STEP'             STEP
         DC    XL2'1900',XL1'00'
         IEXCGEN DC,'THEN'             THEN
         DC    XL2'1E00',XL1'08'
KWELSE   IEXCGEN DC,'ELSE'             ELSE
         DC    XL2'1F00',XL1'08'
         IEXCGEN DC,'GOTO'             GOTO
         DC    XL2'1700',XL1'0C'
         IEXCGEN DC,'TRUE'             TRUE
         DC    XL2'0700',XL1'1C'
         IEXCGEN DC,'LESS'             LESS
         DC    XL2'1100',XL1'00'
         IEXCGEN DC,'CODE'             CODE
         DC    XL2'0000',XL1'20'
         IEXCGEN DC,'IMPL'             IMPL
         DC    XL2'2100',XL1'00'
*
KEYWDL05 DC    AL1(10)                 NUMBER OF ENTRIES
         IEXCGEN DC,'BEGIN'            BEGIN
         DC    XL2'0000',XL1'24'
         IEXCGEN DC,'UNTIL'            UNTIL
         DC    XL2'1A00',XL1'00'
KWARRAY  IEXCGEN DC,'ARRAY'            ARRAY
         DC    XL2'CA16',XL1'28'
         IEXCGEN DC,'VALUE'            VALUE
         DC    XL2'0000',XL1'2C'
         IEXCGEN DC,'LABEL'            LABEL
         DC    XL2'CA18',XL1'30'
         IEXCGEN DC,'WHILE'            WHILE
         DC    XL2'1B00',XL1'00'
         IEXCGEN DC,'FALSE'            FLASE
         DC    XL2'0000',XL1'1C'
         IEXCGEN DC,'POWER'            POWER
         DC    XL2'0500',XL1'00'
         IEXCGEN DC,'EQUAL'            EQUAL
         DC    XL2'1000',XL1'00'
         IEXCGEN DC,'EQUIV'            EQUIV
         DC    XL2'2400',XL1'00'
*
KEYWDL06 DC    AL1(2)                  NUMBER OF ENTRIES
         IEXCGEN DC,'SWITCH'           SWITCH
         DC    XL2'CA1C',XL1'34'
         IEXCGEN DC,'STRING'           STRING
         DC    XL2'CB10',XL1'30'
*
KEYWDL07 DC    AL1(5)
         IEXCGEN DC,'INTEGER'          INTEGER
         DC    XL2'C211',XL1'18'
         IEXCGEN DC,'BOOLEAN'          BOOLEAN
         DC    XL2'C213',XL1'18'
         IEXCGEN DC,'COMMENT'          COMMENT
         DC    XL2'0000',XL1'38'
         IEXCGEN DC,'NOTLESS'          NOTLESS
         DC    XL2'1500',XL1'00'
         IEXCGEN DC,'GREATER'          GREATER
         DC    XL2'1200',XL1'00'
*
KEYWDL08 DC    AL1(1)                  NUMBER OF ENTRIES
         IEXCGEN DC,'NOTEQUAL'         NOTEQUAL
         DC    XL2'1300',XL1'00'
*
KEYWDL09 DC    AL1(1)                  NUMBER OF ENTRIES
KWPROC   IEXCGEN DC,'PROCEDURE'        PROCEDURE
         DC    XL2'CAD0',XL1'3C'
*
KEYWDL10 DC    AL1(1)                  NUMBER OF ENTRIES
         IEXCGEN DC,'NOTGREATER'       NOTGREATER
         DC    XL2'1400',XL1'00'
*
*        DELPRGTB
*
*        BRANCH ADDR TABLE USED AFTER A KEYWORD HAS BEEN FOUND
*
DELPRGTB DC    A(NORMAL)               +00
         DC    A(STRING)               +04
         DC    A(TED)                  +08
         DC    A(GIF)                  +12
         DC    A(END)                  +16
         DC    A(FOR)                  +20
         DC    A(TYPE)                 +24
         DC    A(BOLCON)               +28
         DC    A(CODE)                 +32
         DC    A(BEGIN)                +36
         DC    A(ARRAY)                +40
         DC    A(VALUE)                +44
         DC    A(SPEC)                 +48
         DC    A(SWITCH)               +52
         DC    A(COM)                  +56
         DC    A(PROCEDUR)             +60
         DC    A(TYPEARRY)             +64
         DC    A(TYPPROC)              +68
*
*        COMTABLE
*
*        USED BY COMMENT PROGRAM
*        TESTS FOR SEMICOLON, PERIOD, QUOTE AND ZETA
*        GIVES DISPLACEMENT TO PROGRAMS FROM COMCEE2+2
*
COMTABLE DC    XL96'00'
         ORG   COMTABLE+XFSCOLON
         DC    AL1(42)                 COMCEE2+2+42
         ORG   COMTABLE+XFPERIOD
         DC    AL1(34)                 COMCEE2+2+34
         ORG   COMTABLE+XFQUOTE
         DC    AL1(14)                 COMCEE2+2+14
         ORG   COMTABLE+XFZETA
         DC    AL1(30)                 COMCEE2+2+30
         ORG   ,
*
*        STRTABLE
*
*        USED BY STRING PROGRAM
*        SCANS FOR QUOTE OR ZETA
*        PROVIDES DISPLACEMENTS TO BPRTAB
*
STRTABLE DC    XL96'00'
         ORG   STRTABLE+XFQUOTE
         DC    AL1(140)
         ORG   STRTABLE+XFZETA
         DC    AL1(56)
         ORG   ,
*
*        KEYTAB
*
*        USED BY TRANSOP
*        BYTE 3 IS EXPECTED BYTE, IF THAT ONE MATCHES CHAR IN
*        INPUT BYTE 1 IS PUT OUT OTHERWISE BYTE 2
*        THE DISPLACEMENT FROM TESTTABL OR ATABLE IS USED TO GET
*        THE APPROPRIATE ENTRY IN KEYTAB
*        USED WHEN -
*                   FOUND                    EXPECTED
*                   *                        *
*                   /                        )
*                   (                        /
*                   <                        =
*                   >                        =
*                   ^                        =
*
KEYTAB   DC    X'00000000'                                  +00
         DC    X'00',AL1(XFPOWER),AL1(XFASTER),AL1(XFASTER) +04 XFASTER
         DC    X'00',AL1(XFRSQBR),AL1(XFSLASH),AL1(XFRBRAC) +08 XFSLASH
         DC    X'00',AL1(XFLSQBR),AL1(XFLBRAC),AL1(XFSLASH) +12 XFLBRAC
         DC    X'00',AL1(20),AL1(XFLT),AL1(XFEQUAL)         +16 XFLT
         DC    X'00',AL1(21),AL1(XFGT),AL1(XFEQUAL)         +20 XFGT
         DC    X'00',AL1(19),AL1(XFNOT),AL1(XFEQUAL)        +24 XFNOT
*
*        TREXTINT
*
*        USED IN CIB TO TRANSLATE FROM EBCDIC TO INTERNAL CODE
*
TREXTINT DC    256AL1(XFEND)
         ORG   TREXTINT+C' '
         DC    AL1(XFBLANK)
         ORG   TREXTINT+C'.'
         DC    AL1(XFPERIOD),AL1(XFLT),AL1(XFLBRAC),AL1(XFPLUS)
         DC    AL1(XFOR),AL1(XFAMPER)
         ORG   TREXTINT+C'$'
         DC    AL1(XFDOLLAR)
         ORG   TREXTINT+C'*'
         DC    AL1(XFASTER),AL1(XFRBRAC),AL1(XFSCOLON),AL1(XFNOT)
         DC    AL1(XFMINUS),AL1(XFSLASH)
         ORG   TREXTINT+C','
         DC    AL1(XFCOMMA)
         ORG   TREXTINT+C'_'
         DC    AL1(XFUNDER)
         ORG   TREXTINT+C'>'
         DC    AL1(XFGT)
         ORG   TREXTINT+C':'
         DC    AL1(XFCOLON)
         ORG   TREXTINT+C'#'
         DC    AL1(XFHASH),AL1(XFAT)
         ORG   TREXTINT+C''''
         DC    AL1(XFQUOTE),AL1(XFEQUAL)
         ORG   TREXTINT+X'81'          LOWER CASE A
         DC    AL1(XFA),AL1(XFB),AL1(XFC),AL1(XFD),AL1(XFE),AL1(XFF)
         DC    AL1(XFG),AL1(XFH),AL1(XFI)
         ORG   TREXTINT+X'91'          LOWER CASE J
         DC    AL1(XFJ),AL1(XFK),AL1(XFL),AL1(XFM),AL1(XFN),AL1(XFO)
         DC    AL1(XFP),AL1(XFQ),AL1(XFR)
         ORG   TREXTINT+X'A2'          LOWER CASE S
         DC    AL1(XFS),AL1(XFT),AL1(XFU),AL1(XFV),AL1(XFW),AL1(XFX)
         DC    AL1(XFY),AL1(XFZ)
         ORG   TREXTINT+C'['
         DC    AL1(XFLSQBR)
         ORG   TREXTINT+C']'
         DC    AL1(XFRSQBR)
         ORG   TREXTINT+C'A'
         DC    AL1(XFA),AL1(XFB),AL1(XFC),AL1(XFD),AL1(XFE),AL1(XFF)
         DC    AL1(XFG),AL1(XFH),AL1(XFI)
         ORG   TREXTINT+C'J'
         DC    AL1(XFJ),AL1(XFK),AL1(XFL),AL1(XFM),AL1(XFN),AL1(XFO)
         DC    AL1(XFP),AL1(XFQ),AL1(XFR)
         ORG   TREXTINT+C'S'
         DC    AL1(XFS),AL1(XFT),AL1(XFU),AL1(XFV),AL1(XFW),AL1(XFX)
         DC    AL1(XFY),AL1(XFZ)
         ORG   TREXTINT+C'0'
         DC    AL1(XF0),AL1(XF1),AL1(XF2),AL1(XF3),AL1(XF4),AL1(XF5)
         DC    AL1(XF6),AL1(XF7),AL1(XF8),AL1(XF9)
         ORG   ,                       RESTORE LOCATION COUNTER
*
*        KFCONST
*
*        KEEPS THE CONSTANTS 0 THROUGH 15
*        THE CONSTANTS ARE USED WITHIN SCAN 1/2 FOR CALCULATION
*        AND ARE THEN INSERTED AS THE FIRST 64 BYTES OF THE
*        CONSTANT POOL
*
KFCONST  DC    0F'0'
KF0      DC    F'0'                    +00
KF1      DC    F'1'                    +04
KF2      DC    F'2'                    +08
KF3      DC    F'3'                    +12
KF4      DC    F'4'                    +16
KF5      DC    F'5'                    +20
KF6      DC    F'6'                    +24
KF7      DC    F'7'                    +28
KF8      DC    F'8'                    +32
KF9      DC    F'9'                    +36
KF10     DC    F'10'                   +40
KF11     DC    F'11'                   +44
KF12     DC    F'12'                   +48
KF13     DC    F'13'                   +52
KF14     DC    F'14'                   +56
KF15     DC    F'15'                   +60
*
*        VARIABLES AND CONSTANTS
*
KF25000  DC    F'25000'
KF2000   DC    F'2000'
KF4095   DC    F'4095'
KH4096   DC    H'4096'
DOUBLE   DC    D'0'
KF256    DC    F'256'
INT      DC    X'2EC8030000'           COMMON PART OF THE INTERNAL
*                                      NAMES OF BOOLEAN CONSTANTS
ENDCOUNT DC    H'0'
ERRSAVE  DC    4F'0'
*
ESDNAME  DC    CL8'PROGRAM'
KP1      DC    PL1'1'                  CARD COUNT INCREMENT
*
HEAD1    DC    C'SOURCE PROGRAM'
HEAD2    DC    C'SC     SOURCE STATEMENT'
*
OPINCHAR DC    C'0'
BRACKET  DC    F'0'                    BRACKET COUNTER
ESDCON   DC    X'00000040404040'       ESD CONSTANT 7 BYTES
SCPATTN  DC    XL6'402020202020'       SEMICOLON EDIT PATTERN
*
SAVE1    DC    7F'0'
SAVEPRNT DC    CL88' '
SCOVFL   DC    F'65535'                (2**16)-1
*
         LTORG
*
WORKAREA DSECT
*
         COPY  WORKAREA                COMMON WORKAREA
*
C        DS    H                  PARENTHESIS COUNT
KB       DS    H                  HOLDS ID FIELD FOR SPECIFICATIONS
POOLLEN  DS    F                  LENGTH OF AREA GOTTEN FROM GETMAIN
POOLLOC  DS    F                  START LOC OF AREA FROM GETMAIN
AITABBUF DS    F                  ADDR OF ITAB BUFFER
ELI      DS    F                  ADDR OF ONE LOC  BEYOND ITAB AREA
ADDARI   DS    A                  ADDR OF FIRST O/P BUFFER
         DS    A                  ADDR OF SECOND O/P BUFFER
DISP     DS    C                  DISPLACEMENT TO ADDARI
D        DS    C                  DIMENSION COUNTER
SP       DS    F                  CURRENT STACK POINTER
APE      DS    F                  LAST AVAILABLE BYTE IN CURRENT O/P
WASAVE   DS    CL12
WABEFOR  DS    CL7
WA       DS    CL80               READIN AREA FOR SYSIN SOURCE RECORDS
APRNTAR  DS    A                  ADDR OF CURRENT PRINT BUFFER
ATOPSTAK DS    A                  LAST BYTE IN THE STACK
IGC      DS    H                  ITAB GROUP COUNTER
AGT      DS    A                  ADDR OF GROUPE TAB -3
AKOPOOL  DS    A                  ADDR OF THE CONSTANT POOL (0)
LAPIN    DS    A                  ADDR OF LAST POSSIBLE LABEL START
DIM      DS    A                  ADDR FOR DIMENSION IN ITAB NAME
PRIMPAR  DS    A                  ADDR OF FIRST SPECIFICATION
AITAB    DS    A                  START ADDR OF ITAB
AITL     DS    A                  CURRENT ITAB ENTRY ADDR
LIGP     DS    A                  POINTER TO CURRENT IG HEAD ENTRY
LPBP     DS    A                  POINTER TO CURRENT PBHEADING
WADDARI  DS    A                  CURRENT O/P BUFFER ADD
ITABLEN  DS    F                  ITAB LENGTH
MGESITL  DS    F                  ACCUMULATED ITAB LENGTH
BCHAR    DS    C                  SAVE CHAR
FBYTE    DS    CL1                SWITCH BYTE FOR APOSTROPHE
FSN      DS    C                  FOR STATEMENT COUNTER
ZFSNMAX  DS    C
PBC      DS    C                  PROGRAM BLOCK COUNTER
ONC      DS    C                  O/P REC COUNTER
N        DS    C                  NUMBER OF ARRAYS WITH SAME DIM
OPIN     DS    A                  POINTS TO LAST LABEL OPERATER
         DS    C                  O/P REC NO WHEN OPIN WAS SET
PZ       DS    C                  COUNTS NUMBER OF PARMETERS
BITS1    DS    C                  INTERNAL SWITCHES
BEGBIT   EQU   X'80'              BLOCK BEGIN
BEGOFF   EQU   X'7F'
PROBIT   EQU   X'40'              PROCEDURE HEAD PROCESSING
DELTABIT EQU   X'20'              SEMICOLON FOUND AFTER DECLARATION
IDBIT    EQU   X'10'              PROCEDURE NAME
ARBIT    EQU   X'08'              ARRAY PROCESSED
LISTBIT  EQU   X'04'              COMMA FOUND AFTER ARRAY NAME
TERBIT   EQU   X'01'              RETURN TO TERM AFTER PBLCKEND
BITS2    DS    C
ENDBIT   EQU   X'80'              LOGICAL END HAS BEEN FOUND
COBIT    EQU   X'40'              COMMENT
STARTBIT EQU   X'20'              ZERO UNTIL FIRST BEGIN FOUND
VALBIT   EQU   X'10'              VALUE
PB0BIT   EQU   X'08'              WRITE PB0 FOR PRE COMP PROC
FRSTPUT  EQU   X'02'              FIRST PUT IN GENERATE
ENDELSE  EQU   X'01'              END MAY CLOSE FOR OR PROC**
BITS3    DS    C
E11BIT   EQU   X'80'              E11 HAS BEEN GENERATED ONCE
FMBIT    EQU   X'40'              FORMAL PARAMETER BIT
FMOFF    EQU   X'BF'
NOFREE   EQU   X'20'              INTERUPT BEFORE GETMAIN
FRSITB   EQU   X'10'              FIRST ITAB REC IS WRITTEN
PROCESD  EQU   X'08'              WRITE SED CARD FOR PRE COMP PROC
PROCOFF  EQU   X'F7'
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END   IEX11000
