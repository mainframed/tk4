X30      TITLE 'IEX30 - SCAN III, ALGOL F'
*
*        COMPONENT ID - 360S-AL-531 ALGOL F COMPILER
*
*        FUNCTION/OPERATION -
*        EXTERNAL NAMES OF IDENTIFIERS ARE REPLACED BY THE
*        INTERNAL NAMES CONTAINED IN THE ITAB ENTRY OF THE
*        IDENTIFIER, AND CONSTANTS ARE REPLACED BY INTERNAL NAMES
*        CONSTRUCTED IN IEX30
*        OBJECT CODE IS PRODUCED FROM THE CONSTANT POOL IF
*        PARAMETERS DECK OR LOAD ARE SPECIFIED IN THE
*        EXEC STATEMENT
*        FOR STATEMENTS ARE CLASSIFIED FOR FURTHER USE BY IEX50
*        THE SUBSCRIPT TABLE (SUTAB) AND THE LEFT VARIABLE TABLE
*        (LVTAB) ARE CONSTRUCTED FOR FURTHER USE BY IEX40
*        SOURCE PROGRAM ERRORS CAUSES GENERATION OF ERROR
*        PATTERNS FOR FUTHER USE BY 1EX31
*
*        ENTRY POINT - IEX30000 FROM IEX21000 VIA XCTL
*
*        INPUT -
*        THE SOURCE PROGRAM MODIFICATION LEVEL 1 IS READ FROM
*        SYSUT1
*        THE IDENTIFIER TABLE (ITAB) IS READ FROM SYSUT3
*
*        OUTPUT -
*        THE SOURCE PROGRAM MODIFICATION LEVEL 2 IS WRITTEN OUT
*        ON SYSUT2
*        OBJECT TXT RECORDS IS WRITTEN ON SYSLIN OR/AND SYSPUNCH
*        IF THE PARAMETERS LOAD OR/AND DECK ARE SPECIFIED IN THE
*        EXEC CARD
*        THE SUBSCRIPT TABLE (SUTAB) IS WRITTEN OUT ON SYSUT3
*        A LINEAR SUBSCRIPT EXPRESSION ENCOUNTED IN A FOR
*        STATEMENT THAT IS OPTIMIZABLE IN REGARD TO SUBSCRIPTS
*        WILL GENERATE AN ENTRY IN THIS TABLE
*        THE LEFT VARIABLE TABLE (LVTAB) IS WRITTEN OUT ON
*        SYSUT3. INTEGER LEFT VARIABLES ENCOUNTED IN FOR
*        STATEMENT THAT IS OPTIMIZABLE IN REGARD TO SUBSCRIPTS
*        WILL GENERATE AN ENTRY IN THIS TABLE
*
*        EXTERNAL ROUTINES -
*        THE INTERRUPT ROUTINE OF IEX00 ARE USED FOR ALL
*        INTERRUPTS EXCEPT FLOATING POINT OVERFLOW
*
*        EXITS - NORMAL -
*        CONTROL IS ALWAYS GIVEN TO IEX31 BY MEANS OF XCTL
*        EP=IEX31
*
*        TABLES/WORKAREAS -
*        GROUP TABLE (GPTAB) CONSTRUCTED IN IEX11, USED TO
*        DIAGNOSE BRANCHES INTO FOR STATEMENTS.
*        SCOPE TABLE (SPTAB) CONSTRUCTED IN IEX11, USED TO CHECK
*        SUBSCRIPT EXPRESSIONS FOR POSSIBLE OPTIMIZATION
*        FOR STATEMENT TABLE (FSTAB) CONSTRUCTED IN IEX30
*        COMPLEATED IN IEX40 AND FINALLY USED IN IEX50, CONTAINS
*        A CLASSIFICATION BYTE FOR EVERY FOR STATEMENT
*        ERROR POOL CONSTRUCTED IN IEX30 AND USED IN IEX31,
*        CONTAINS ERROR PATTERNS GENERATED FROM SOURCE PROGRAM
*        ERRORS
*        CONSTANT POOL INTERNAL TABLE IN IEX30. THE FIRST
*        APPEARANCE OF A CONSTANT IN THE SOURCE STREAM GENERATES
*        AN ENTRY IN THE TABLE. THE RELATIVE ADDRESS OF THE
*        CONSTANT POOL ENTRY IS USED IN CONSTRUCTING THE
*        INTERNAL NAME OF A CONSTANT CRITICAL VARIABLE TABLE
*        (CRIDTAB) INTERNAL TABLE IN IEX30
*        DURING THE TREATMENT OF A FOR STATEMENT THE TABLE
*        CONTAINS ENTRIES CORRESPONDING TO THE IDENTIFIERS IN THE
*        FOR LIST
*
*        NOTES -
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND ON ANY
*        SPECIAL REPRESENTATION OF THE CHARACTER SET. THIS MODULE
*        IS ONLY INTENDED TO BE EXECUTED IN CONNECTION WITH THE
*        OTHER MODULES OF THE ALGOL COMPILER. IN PARTICULAR IT
*        REQUIRES THE COMMON WORKAREA
*
IEX30000 CSECT
*
*        R3                            INPUT RECORD POINTER REGISTER
*        R4                            OUTPUT RECORD POINTER REGISTER
*
*        BIT PATTERNS
*
SARRAY   EQU   X'80'                   HANDLING ARRAY DECLARATION
SSWITCH  EQU   X'40'                   HANDLING SWITCH DECLARATION
FF       EQU   X'FF'
*                                      SCALE FACTOR MASKS
SFSIGN   EQU   X'80'                   SIGNED SCALE FACTOR
SFL0     EQU   X'40'                   LEADING ZERO IN SCALE FACTOR
SF19     EQU   X'20'                   SIGNIFICANT DIGIT IN SCALE FAC
SF       EQU   X'10'                   SCALE FACTOR PRESENT
SFDIGIT  EQU   X'60'
SFLSIGN  EQU   X'E0'
PRECERR  EQU   X'08'                   REAL CONSTANT EXCEEDS PRECISION
*
*        CLASSIFICATION MASKS OF I/O STATUS ON SYSUT3
*
READM    EQU   X'80'                   UNCHECKED READ OPERATION
WRITEM   EQU   X'40'                   UNCHECKED WRITE OPERATION
READC    EQU   X'20'                   CHECKED READ OPERATION
WRITEC   EQU   X'10'                   CHECKED WRITE OPERATION
*
*        FOR STATEMENT CLASSIFICATION MASKS
*
NOCOUNT  EQU   X'80'                   COUNTING LOOP IMPOSSIBLE
NOSUOP   EQU   X'40'                   NO SUBSCRIPT OPTIMIZATION
OUTOFFOR EQU   X'20'                   BRANCH OUT OF FOR STATEMENT
NORMAL   EQU   X'F0'                   NORMAL LOOP
STEPM    EQU   X'08'                   STEP IN FORLIST
WHILEM   EQU   X'84'                   WHILE IN FOR LIST
*
         IEXENTRY 'IEX30000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX30000,R10,R11,R12
         LR    R10,R15
         LA    R11,2048(,R15)
         LA    R11,2048(,R11)
         LA    R12,2048(,R11)
         LA    R12,2048(,R12)
*
         USING WORKAREA,R13
*
         LA    R5,TERM1                ERROR EXIT ADDR
         ST    R5,ERET
         LA    R5,LOMEGA6              PROVIDE EOD ADDR
         ST    R5,EODUT1               FOR UT1
         MVC   SEMCNT,ZERO             ZERO SEMICOLON COUNTER
*
         SPIE  INTERUPT,((1,7),9,11,12,15)
*
         ST    R1,OLDSPIE              SAVE ADDR OF OLD PICA
*
*        ALLOCATE STORAGE FOR TABLESD
*
         LH    R0,KH4096               CONSTANT POOL SIZE
         A     R0,ITAB30S              ITABSIZE
         A     R0,SRCE1S               INPUT BUFFER SIZE
         A     R0,SRCE3S               OUTPUT BUFFER SIZE
         A     R0,SRCE3S               OUTPUT BUFFER SIZE
         A     R0,CRIDTABS             CRIDTAB SIZE
         A     R0,SUTAB30S             SUTAB SIZE
         A     R0,LVTAB30S             LVTAB SIZE
         AH    R0,KH8                  RECORD KEY LENGTH
         ST    R0,TABSIZE              SAVE TABLE AREA LENGTH
*
         GETMAIN R,LV=(0)              ALLOCATE STORAGE
*
         LA    R5,TERM2                ERROR RETURN ADDR
         ST    R5,ERET
         ST    R1,ZKOPOOL              CONSTANT POOL START ADDR
         AH    R1,KH4096
         ST    R1,ZIBSTAO              ITAB START ADDR
         A     R1,ITAB30S
         ST    R1,ZIBREAD              SECOND INPUT BUFFER START ADDR
         A     R1,SRCE1S
         ST    R1,ZOBWORK              OUTPUT BUFFER START ADDR
         A     R1,SRCE3S
         ST    R1,ZOBWRITE             OUTPUT BUFFER START ADDR
         A     R1,SRCE3S
         ST    R1,ZFOCRI               CRIDTAB START ADDR
         A     R1,CRIDTABS
         ST    R1,SUSTRT               SUTAB START ADDR
         A     R1,SUTAB30S
         LA    R1,4(,R1)
         ST    R1,LVSTRT               LVTAB START ADDR
*
*        INITIALIZE INPUT BUFFERS
*
         L     R3,SRCE1ADD             ADDR OF FIRST INPUT BUFFER
         ST    R3,ZIBRUN
         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?
         BO    INCORE                  YES
         BAL   R15,ICHAI               READ FIRST RECORD
*
*        ITAB POINTERS INITIALIZATION
*
INCORE   L     R1,ZIBSTAO              ITAB START ADDR
         MVC   0(256,R1),FIXITAB       INSERT ITAB FIXED PART
         MVC   256(FIXITABL-256,R1),FIXITAB+256
         LA    R5,FIXITABL-11(,R1)     R5 -> LAST FIXED ENTRY
         ST    R5,ZCURITEN             STORE IN ZCURITEN
         LA    R5,11(,R5)              ADDR FIRST FREE ITAB ENTRY
         ST    R5,ZITREC
         A     R1,ITAB30S              ITAB END ADDR PLUS 1
         ST    R1,ZITEND
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
*
         NOTE  (1)                     ID OF LAST ITAB BLOCK
*
         ST    R1,SULTSTRT             TRANSFER TO SUBSCRIPT HANDLING
         ST    R1,NOTEW                PREPARE WRITE OF SUTAB OR LVTAB
         L     R5,AUT3DCB              R5 -> SYSUT3 DCB
*
         CLOSE ((R5),REREAD),TYPE=T    TEMPORARY CLOSE
*
         BAL   R15,ITABREAD            READ FIRST ITAB RECORD
*
*        INITIALIZE OUTPUT BUFFERS
*
         L     R4,ZOBWORK              START OF ACTIVE OUTPUT BUFFER
         L     R5,SRCE3S               LENGTH OF OUTPUT BUFFER
         SH    R5,KH12                 SET BUFFER END PTRS
         AR    R5,R4
         ST    R5,ZFILE9
         LA    R5,3(,R5)
         ST    R5,ZFILE6
         LA    R5,1(,R5)
         ST    R5,ZFILE5
         LA    R5,2(,R5)
         ST    R5,ZFILE3
         LA    R5,1(,R5)
         ST    R5,ZFILE2
         LA    R5,1(,R5)
         ST    R5,ZFILE1
         BCTR  R4,0
*
*        CRIDTAB AND FSTAB INITIALIZATION
*
         L     R1,ZFOCRI               CRIDTAB START ADDR
         SH    R1,KH9                  INITIALIZE PTRS
         ST    R1,PFANO
         ST    R1,PFA                  CURRENT CRIDTAB PTR
         A     R1,CRIDTABS             GET ADDR OF LAST ENTRY
         ST    R1,PFAMAX               END PTR
         MVI   ZFOSTA,0                ZERO FSTAB
         MVC   ZFOSTA+1(254),ZFOSTA
         LA    R5,FSTAB-1              START ADDR OF FSTAB -1
         ST    R5,ZFSPTR               INITIALIZE FORSTATEMENT ZERO
*
*        SUTAB INITIALIZATION
*
         L     R1,SUSTRT               SUTAB START ADDR
         MVC   0(4,R1),SUKEY           SET SUTAB KEY
         SH    R1,KH10                 INITIALIZE PTRS
         ST    R1,ZSUDAD               START PTR
         ST    R1,ZSUTAPO              CURRENT PTR
         A     R1,SUTAB30S
         ST    R1,ZSUTMAX              END PTR
*
*        LVTAB INITIALIZATION
*
         L     R1,LVSTRT               LVTAB START ADDR
         MVC   0(4,R1),LVKEY           SET LVTAB KEY
         ST    R1,ZLESTA               START PTR
         ST    R1,ZLEVA                CURRENT PTR
         A     R1,LVTAB30S
         ST    R1,ZLEMAX               END PTR
*
*        LITERAL HANDLING INITIALIZATION
*
         TM    COMPFLGS,LNG            LONG PRECISION ?
         BNZ   INLIT2                  YES
         LA    R5,4
         ST    R5,LREAL
         LA    R5,7
         ST    R5,NREAL                MAXIMAL PRECISION
*
*        CONSTANT POOL INITALIZATION
*
INLIT2   L     R1,ZKOPOOL              CONSTANT POOL START ADDR
         LH    R5,KH4096               LENGTH OF CONSTANT POOL
         AR    R5,R1                   CONSTANT POOL END ADDR
         ST    R5,ZKOPEND              END PTR
         A     R1,PRPT
         ST    R1,ZWP                  WORD PTR
         ST    R1,ZDWP                 DOUBLE WORD PTR
         ST    R1,ZLITSTA              START ADDR OF ACTIVE POOL
         AH    R1,TXTPUT               TXT OUTPUT PTR
         ST    R1,ZTEXTCO
         MVC   ZKBNMAX(2),PBN          PREPARE CONSTANT POOL EXCHANGE
         MVC   KBN(2),ZERO             CURRENT POOL NUMBER
*
*        START READ INTO ALTERNATE INPUT BUFFER IF NECESSARY
*
         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?
         BO    INITEND                 YES
         BAL   R15,ICHA
INITEND  NI    COMPFLGS+2,255-NOSC     SET SEMICOLON COUNTER VALID
         TM    COMPFLGS,PROC           PRECOMPILED PROCEDURE ?
         BZ    GENTEST                 NO
         BAL   R15,ITABMOVE            YES, GET ITAB RECORD
         B     GENTEST
*
GENTEST1 LA    R3,1(,R3)
GENTEST  SR    R2,R2
         TRT   0(80,R3),GENER
         B     *(R2)
         B     LETTER                  + 04
         B     DIGIT19                 + 08
         B     DIGIT0                  + 12
         B     DECPOIN                 + 16
         B     SCAFACT                 + 20
         B     QUOTE                   + 24
         B     BETA                    + 28
         B     PIPHI                   + 32
         B     FOR                     + 36
         B     EPSILON                 + 40
         B     ETA                     + 44
         B     DO                      + 48
         B     WHILE                   + 52
         B     SEMIDELT                + 56
         B     OPBRACK                 + 60
         B     COMMA                   + 64
         B     CLOBRACK                + 68
         B     ZETA                    + 72
         B     GAMMA                   + 76
         B     OMEGA                   + 80
         B     OTHOP                   + 84
         B     RHO                     + 88
         B     STEP                    + 92
         B     ARRAY                   + 96
         B     SWITCH                  +100
         B     DIPOW                   +104
*
*        STRING OR LOGICAL VALUE
*
QUOTE    C     R4,ZFILE5               OUTPUT BUFFER EXCHANGE ?
         BH    LQUOT2                  YES
LQUOT3   MVC   1(5,R4),1(R3)           OUTPUT INTERNAL NAME
         LA    R3,6(,R3)
         CLI   0(R3),X'2E'             FOLLOWS AN OPERATOR ?
         BNL   LQUOT1                  PROBABLY NOT, MIGHT BE ZETA
LQUOT5   LA    R4,5(,R4)               STEP OUTPUT PTR
         B     GENTEST                 BRANCH TO GENTEST
*
LQUOT2   BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LQUOT3                  BRANCH TO LQUOT3
*
LQUOT1   CLI   0(R3),XFZETA            ZETA ?
         BNE   LQUOT4                  NO, GIVE ERROR MESSAGE
         BAL   R15,ICHA                CHANGE INPUT BUFFER
         CLI   0(R3),X'2E'             FOLLOWS OPERATOR ?
         BL    LQUOT5                  YES
LQUOT4   MVC   ZIDEX(6),ZPOINT         REPLACE OPERAND BY SIX POINTS
         LA    R8,ZIDEX+6
         LA    R0,ZIDEX+12
         MVC   ZERRONU,INVOP
         B     INCOROP                 INCORRECT OPERAND ERROR ROUTINE
*
*        PROGRAM BLOCK BEGIN
*
BETA     CLI   LETTER+1,X'F0'          PROCEDURE BLOCK TO READ ?
         BE    LBETA4                  YES
BETA1    BAL   R15,ITABMOVE            READ ITAB BLOCK
LBETA2   C     R4,ZFILE2               COMPARE ZOUT WITH ZFILE(2)
         BH    LBETA1                  BRANCH IF HIGH
LBETA3   MVC   1(2,R4),0(R3)
         LA    R4,2(,R4)               INCR ZOUT BY 2
         MVC   ZIGN(2),2(R3)           IGN IS RECOGNIZED AND STORED
         LA    R3,4(,R3)               INCR ZIN BY 4
         B     GENTEST                 BRANCH TO GENTEST
*
LBETA1   BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LBETA3                  BRANCH TO LBETA 2
*
LBETA4   BAL   R15,ITABMOP             READ PROCEDURE BLOCK
         B     BETA1
*
*        PROCEDURE BLOCK BEGIN
*
PIPHI    NI    IDENT4+1,X'0F'          PROC HEAD SWITCH ON
         CLI   LETTER+1,X'F0'          PROCEDURE BLOCK TO READ ?
         BE    LPIPHI6
PIPHI1   MVC   ZIGN(2),1(R3)           SAVE CURRENT IGN
         C     R4,ZFILE6               SPACE IN OUTPUT BUFFER ?
         BH    LPIPHI1                 BRANCH IF HIGH
LPIPHI2  MVC   1(1,R4),0(R3)           OPERATOR IS MOVED TO O-BUFFER
         LA    R4,1(,R4)               INCR ZOUT BY 1
         LA    R3,3(,R3)               INCR ZIN BY 3
LPIPHI3  CLI   0(R3),XFA               LETTER FOLLOWS IN SOURCE INPUT ?
         BL    LPIPHI4                 NO
         OI    LETTER+1,X'F0'          YES, SET PROCEDURE SWITCH
         B     LETTER                  GET IDENT AND READ ITAB
*
LPIPHI4  CLI   0(R3),XFZETA            ZETA IN SOURCE INPUT ?
         BE    LPIPHI5                 YES
         BAL   R15,ITABMOVE            NO, READ ITAB BLOCK
         B     GENTEST
*
LPIPHI5  BAL   R15,ICHA                GET NEXT INPUT RECORD
         B     LPIPHI3
*
LPIPHI1  BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LPIPHI2                 BRANCH TO LPIPHI2
*
LPIPHI6  BAL   R15,ITABMOP             READ PROCEDURE BLOCK
         B     PIPHI1
*
*        FOR STATEMENT BEGIN
*
FOR      MVI   ZFORTEST,X'C0'          ZFORTEST IS SET TO X'C0'
         L     R5,ZFSPTR               UPDATE PTR TO FSTAB ENTRY
         LA    R5,1(,R5)
         ST    R5,ZFSPTR
         LA    R6,FSTAB                GET FOR STATEMENT NUMBER
         SR    R5,R6
         STC   R5,ZFSN
LFOR3    MVC   ZIGN(2),1(R3)           IGN IS RECOGNIZED AND STORED
         C     R4,ZFILE1               TEST IF SPACE IN OUTPUT BUFFER
         BH    LFOR1                   BRANCH IF HIGH
LFOR4    MVC   1(1,R4),0(R3)
         LA    R4,1(,R4)               INCR ZOUT
         LA    R3,3(,R3)               INCR ZIN BY 3
         B     GENTEST                 BRANCH TO GENTEST
*
LFOR1    BAL   R15,OUCHA               CALL SUBROUTINE OUCHA
         B     LFOR4                   BRANCH TO LFOR2
*
*        END OF PROGRAM OR PROCEDURE BLOCK
*
EPSILON  CLI   LETTER+1,X'F0'          ITAB BLOCK TO READ ?
         BE    EPSILON2                YES
EPSILON1 L     R6,ZCURITEN             ADDR LAST ITAB ENTRY
         SH    R6,ZCURITLE             ZCURITEN = ZCURITEN - ZCURITLE
         ST    R6,ZCURITEN             ZCURITEN IS STORED
         MVC   ZCURITLE(2),17(R6)      ZCURITLE IS UPDATED
         B     LBETA2                  BRANCH TO LBETA2
*
EPSILON2 BAL   R15,ITABMOP             READ ITAB BLOCK
         B     EPSILON1
*
*        FOR STATEMENT END
*
ETA      MVI   ZFORTEST,0              ZERO ZFORTEST
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    LFOR3                   YES
         BAL   R15,CRIFODEL            CALL CRIFODEL
         B     LFOR3                   BRANCH TO LFOR3
*
*        FOR LIST END
*
DO       MVI   ZFORTEST,0              ZERO ZFORTEST
LDO3     C     R4,ZFILE1               COMPARE ZOUT WITH ZFILE
OTHOP    EQU   LDO3
         BH    LDO1                    HIGH, BRANCH
LDO2     MVC   1(1,R4),0(R3)           OPERATOR IS MOVED TO O BUFFER
         LA    R4,1(,R4)               INCR ZOUT
         B     GENTEST1
*
LDO1     BAL   R15,OUCHA               BRANCH TO SUBROUTINE OUCHA
         B     LDO2                    BRANCH TO LDO2
*
*        WHILE
*
WHILE    L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),WHILEM            INDICATE 'WHILE HAS APPEARED'
         B     LDO3
*
*        STEP OPERATOR
*
STEP     L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),STEPM             INDICATE 'STEP HAS APPEARED'
         B     LDO3
*
*        DIVIDE AND POWER ROUTINE
*
DIPOW    CLI   ZFORTEST,0              OPERATOR IN FOR LIST ?
         BE    OTHOP                   NO, MOVE TO OUTPUT STREAM
         L     R5,ZFSPTR               YES, ADDR FSTAB ENTRY
         OI    0(R5),NOCOUNT           COUNTING LOOP IMPOSSIBLE
         B     OTHOP                   MOVE TO OUTPUT STREAM
*
*        SEMICOLON OR DELTA
*
SEMIDELT MVC   SEMCNT,1(R3)            SAVE SEMICOLON COUNTER
         OI    IDENT4+1,X'F0'          PROC HEAD SWITCH OFF
         C     R4,ZFILE3               COMPARE ZOUT WITH ZFILE(3)
         BH    LSEM1                   HIGH, BRANCH
LSEM2    MVC   1(3,R4),0(R3)           OPERATOR,SC ARE MOVED TO O-BUFF
         LA    R4,3(,R4)               ZOUT IS INCREASED BY 3
         LA    R3,3(,R3)               ZIN IS INCREASED BY 3
         MVI   STATUS,0                TURN OFF SWITCH OR ARRAY BITS
         B     GENTEST                 BRANCH TO GENTEST
*
LSEM1    BAL   R15,OUCHA               CALL SUBROUTINE OUCHA
         B     LSEM2                   BRANCH TO LSEM2
*
SWITCH   OI    STATUS,SSWITCH          SET ON SWITCH SWITCH
         B     OTHOP
*
ARRAY    OI    STATUS,SARRAY           SET ON ARRAY SWOTCH
         MVC   BRCNT(2),ZERO           ZERO BRACKET COUNTER
         B     OTHOP                   OUTPUT OPERATOR
*
*        PROGRAM END
*
OMEGA    MVC   1(1,R4),0(R3)
         OI    COMPFLGS+2,NOSC         SET SEMICOLON COUNTER NOT VALID
         TM    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE ?
         BO    LOMEGA6                 YES, BRANCH
*
         CHECK SREAD
*
LOMEGA6  L     R5,AUT1DCB              R5 -> SYSUT1 DCB
*
         CLOSE ((R5))                  CLOSE SYSUT1 FINALY
*
         CLC   KH1,ZOUTCOT             ZOUTCOT = 1 ?
         BE    LOMEGA1                 YES, BRANCH
         LA    R4,1(,R4)               SAVE OMEGA FROM OVERLAY
         BAL   R15,OUCHA               WRITE LAST RECORD
         NI    COMPFLGS+2,255-SPIC     OUTPUT ON SECONDARY STORAGE
*
         CHECK SWRITE                  CHECK LAST OUTPUT RECORD
*
*        WRITE OUT CONSTANT POOL
*
LOMEGA3  L     R9,ZDWP                 ADDR OF FREE BYTE IN CONST POOL
         LR    R5,R9
         AH    R5,TXTPUT               MORE TXT TO WRITE ?
         C     R5,ZTEXTCO
         BE    LOMEGA2
         BAL   R14,TXTTRAF             YES, WRITE REST OF CONST POOL
*
LOMEGA2  EQU   *
TERM2    EQU   *
         SR    R5,R5
         IC    R5,ZFSN
         STH   R5,FSNMAX
         MVC   SUCOUNT(2),SUCNT        NUMBER OF SUTAB RECORDS
         MVC   LVCOUNT(2),LVCNT        NUMBER OF LVTAB RECORDS
         L     R1,SULENGTH             GET FULL LENGTH OF SUTAB
         A     R1,ZSUTAPO
         S     R1,ZSUDAD
         ST    R1,ZSUTEN               LENGTH OF SUTAB
         BZ    LOMEGA4
         CLC   ZSUTAPO(4),ZSUDAD       ANYTHING IN SUTAB BUFFER ?
         BE    LOMEGA5                 NO
         BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3
         L     R5,SUSTRT               WRITE START ADDR
         L     R6,SUTAB30S             LENGTH OF RECORD
         BAL   R15,WRITE               WRITE
*
LOMEGA5  L     R1,LVLENGTH             GET FULL LENGTH OF LVTAB
         A     R1,ZLEVA
         S     R1,ZLESTA
         ST    R1,ZLEVEN               LENGTH OF LVTAB
         BZ    LOMEGA4
         CLC   ZLEVA(4),ZLESTA         ANYTHING IN LVTAB BUFFER ?
         BE    LOMEGA4                 NO
         BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3
         L     R5,LVSTRT               LVTAB BUFFER START ADDR
         L     R6,LVTAB30S             LENGTH OF LVTAB BUFFER
         BAL   R15,WRITE               WRITE
*
LOMEGA4  BAL   R5,CHECK                CHECK LAST I/O OPERATION ON UT3
         L     R5,AUT2DCB              R5 -> SYSUT2
*
         CLOSE ((R5),REREAD),TYPE=T    CLOSE SYSUT2 TEMPORARILY
*
         L     R0,TABSIZE              RELEASE MAIN STORAGE
         L     R1,ZKOPOOL
*
         FREEMAIN R,LV=(0),A=(1)
*
TERM1    L     R1,OLDSPIE
*
         SPIE  MF=(E,(1))
*
         XCTL  EP=IEX31                TRANSFER TO NEXT PHASE
*
LOMEGA1  OI    COMPFLGS+2,SPIC         SOURCE PROG IN STORAGE
         L     R1,SRCE1ADD             ADDR OF RESIDENT BUFFER
         L     R2,ZOBWORK              ADDR OF OUTPUT BUFFER
         L     R5,SRCE1S               BUFFER LENGTH
         BCTR  R5,0
         LR    R6,R5
         SRA   R6,8                    GET MULTIPLE OF 256
         LTR   R6,R6                   MAXIMUM 256 ?
         BZ    LOMEGA12                YES
LOMEGA11 MVC   0(256,R1),0(R2)         MOVE BLOCK OF 256
         LA    R1,256(,R1)
         LA    R2,256(,R2)
         BCT   R6,LOMEGA11
LOMEGA12 EX    R5,ONERM                MOVE REST OF BUFFER
         B     LOMEGA3
*
ONERM    MVC   0(0,R1),0(R2)           LENGTH IN R5
*
*        CODE PROCEDURE
*
GAMMA    C     R4,ZFILE9               COMPARE ZOUT WITH ZFILE9
         BH    LGAMMA1                 HIGH, BRANCH
LGAMMA2  MVI   1(R4),X'2E'             NEW CODE FOR GAMMA IS SET
         MVC   2(8,R4),1(R3)           OPT, EXTERNAL NAME TO O-BUFF
         LA    R3,9(,R3)               INCR ZIN BY 9
         LA    R4,9(,R4)
         B     GENTEST                 BRANCH TO GENETEST
*
LGAMMA1  BAL   R15,OUCHA
         B     LGAMMA2                 BRANCH TO LGAMMA2
*
*        END OF INPUT BUFFER
*
ZETA     BAL   R15,ICHA                BRANCH TO SUBROUTINE ICHA
         B     GENTEST                 BRANCH TO GENTEST
*
*        OPENING BRACKET
*
OPBRACK  TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?
         BO    LOPBRA5                 YES
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    OTHOP                   YES
         L     R7,ZITAN                ZITEAN IS LOADED INTO R7
         TM    7(R7),X'08'             AN ARRAY IDENTIFIER ?
         BO    LDO3                    NO
         TM    7(R7),X'04'
         BZ    LDO3
         CLC   PFA(4),PFANO            PFA = PFANO ?
         BE    LDO3                    YES, BRANCH
         CLI   ZLVOV,X'FF'             TABLE OVERFLOW ?
         BE    LDO3                    YES
         CLC   ZARSPO(4),ZARNO         COMPARE ZARSPO WITH ZARNO
         BE    LOPBRA4                 NO SUBSCRIPT NESTING
         BAL   R15,SUCRIDEL
         L     R8,ZARSPO               ZARSPO IS SET INTO R8
         C     R8,ZARMAX               ZARSPO EQUAL TO ZARMAX ?
         BE    LOPBRA4                 YES, BRANCH
         MVC   10(1,R8),ZPOSIX+1       NUMBER OF COMMAS TO ARIDSTACK
         LA    R8,7(,R8)               ADDR NEXT ENTRY
LOPBRA3  ST    R8,ZARSPO               ZARSPO IS SET TO ZARSTACK
         MVC   0(3,R8),8(R7)           ARRAY IDENTIFIER IS STORED
         LA    R0,1(,R4)
         ST    R0,ZBRACK               ZBRACK IS SET TO ZOUT+1
         S     R0,ZOBWORK
         ST    R0,ALIGN                RELATIVE BUFFER ADDR
         MVC   5(2,R8),ALIGNH
         MVC   4(1,R8),ZOUTCOT+1       RECORD COUNTER TO ARIDSTAB
         MVC   ZPOSIX(2),ZERO          ZPOSIX IS SET TO 0
         MVI   ZCLOBRA,X'00'           ZCLOBRA IS SET TO X'00'
         B     LDO2                    PUT OUT OPERATOR
*
LOPBRA4  LA    R8,ZARSTACK             START ADDR OF ARIDSTAB
         B     LOPBRA3                 BRANCH TO LOPBRA3
*
LOPBRA5  LH    R5,BRCNT                INCREASE BRACKET COUNTER
         LA    R5,1(0,R5)
         STH   R5,BRCNT
         B     OTHOP                   OUTPUT OPERATOR
*
*        COMMA
*
COMMA    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    OTHOP                   YES
         CLC   ZARSPO(4),ZARNO         ZARSPO = ZARNO ?
         BE    LDO3                    YES, BRANCH
         CLC   ZPOSIX(2),KH15          ZPOSIX = 15 ?
         BE    LCOMMA1                 YES, BRANCH
         CLI   ZCLOBRA,0               ZCLOBRA = X'FF' ?
         BNE   LCOMMA2                 NO, BRANCH
         L     R7,ZBRACK               ZBRACK IS SET INTO R7
         LA    R7,18(,R7)
         CR    R4,R7                   COMPARE ZOUT AND ZBRACK+18
         BH    LCOMMA3
         BAL   R9,SUSCRITE             OPTIMIZATION POSSIBLE ?
LCOMMA4  LH    R7,ZPOSIX               ZPOSIX IS SET INTO R7
         LA    R7,1(,R7)               INCR ZPOSIX BY 1
         STH   R7,ZPOSIX
         LA    R7,1(,R4)
         ST    R7,ZBRACK               ZBRACK IS SET TO ZOUT+1
         B     LDO2                    PUT OUT OPERATOR
*
LCOMMA1  OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     LDO3                    BRANCH TO LDO3
*
LCOMMA2  MVI   ZCLOBRA,0               ZERO ZCLOBRA
LCOMMA3  BAL   R15,SUCRIDEL
         B     LCOMMA4                 BRANCH TO LCOMMA4
*
*        CLOSING BRACKET
*
CLOBRACK TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?
         BO    CLOBRA3
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    OTHOP                   YES
         CLC   ZARSPO(4),ZARNO         THERE AN ARIDSTAB ENTRY ?
         BE    LDO3                    NO
         CLI   ZCLOBRA,0               PRECEEDING SUBSCR OPER CLOBRA ?
         BNE   CLOBRA1                 YES
         L     R7,ZBRACK               SUBSCRIPT MORE THAN 18 BYTES ?
         LA    R7,18(,R7)
         CR    R4,R7
         BH    CLOBRA1                 YES, NO OPTIMIZATION
         BAL   R9,SUSCRITE             TEST IF OPTIMIZABLE
CLOBRA2  L     R7,ZARSPO               UPDATE CURRENT ARIDSTAB PTR
         SH    R7,KH7
         ST    R7,ZARSPO
         C     R7,ZARNO                ARIDSTAB EMPTY
         BE    LDO3                    YES
         MVC   ZPOSIX+1(1),10(R7)      RESET SUBSC POSITION CNTR
         LA    R7,1(,R4)               SET ZBRACK
         ST    R7,ZBRACK
         MVI   ZCLOBRA,X'FF'           LAST SUBSCR OPER CLOBRACK
         B     LDO3
*
CLOBRA1  BAL   R15,SUCRIDEL            NO OPTIMIZATION POSSIBLE
         B     CLOBRA2
*
CLOBRA3  LH    R5,BRCNT                DECREASE BRACKET COUNTER
         BCTR  R5,0
         STH   R5,BRCNT
         B     OTHOP                   OUTPUT OPERATOR
*
*        LETTER
*
*        SCAN FOR END OF IDENTIFIER
*        BRANCH TO IDENT TO SEARCH FOR THE IDENTIFIER IN ITAB
*        REPLACE IDENTIFIER BY INTERNAL NAME
*
*        INITIALIZED REG = IDENTIFIER START ADDR
*        SUBROUTINE LINK IDENTX
*
LETTER5  BAL   R15,ITABMOP             READ ITAB RECORD
         B     LETTERP
*
LETTER   NOP   LETTER5                 BRANCH TO READ ITAB RECORD
LETTERP  LA    R8,ZIDEX
         LA    R0,ZIDEX+6
LETTER4  LR    R9,R3
         SR    R2,R2
         SR    R1,R1
LETTER6  TRT   0(256,R3),IDENTI
         BZ    LETTER0                 STILL SAME IDENTIFIER
         LR    R3,R1                   UPDATE R3
         B     *(R2)
         B     ZETALET                 +04
         B     RHO                     +08
         B     ERROR1                  +12
*                                      END OF IDENTIFIER IS FOUND
         B     IDENT                   ITAB SEARCH
*
LETTER1  ST    R7,ZITAN                SAVE POINTER TO LAST IDENTIFIER
         C     R4,ZFILE5               SPACE IN OUTPUT BUFFER
         BH    LETTER2                 NO SPACE
LETTER3  MVC   1(5,R4),6(R7)           MOVE INTERNAL NAME TO OUTPUT BUF
         LA    R4,5(,R4)
         B     GENTEST
*
LETTER2  BAL   R15,OUCHA
         B     LETTER3
*
LETTER0  LA    R3,256(,R3)             UPDATE INPUT PTR
         B     LETTER6
*
*        END OF INPUT BUFFER IN THE MIDDLE OF AN IDENTIFIER
*
ZETALET  BAL   R15,MOVE
         BAL   R15,ICHA
         B     LETTER4
*
*        LETTER STRING USED AS PARAMETER DELIMITER
*        REPLACE STRING BY COMMA
*
RHO      CLI   0(R4),XFRBRAC           RIGHT BRACKET ?
         BNE   GENTEST1                NO
         MVI   0(R4),XFCOMMA           REPLACE RIGHT BRACKET BY COMMA
         B     GENTEST1
*
*        INVALID CHARACTER IN IDENTIFIER
*
ERROR1   BAL   R15,MOVE
         MVC   ZERRONU,INVOP
         B     INCOROP
*
*        IDENT
*
*        A SEARCH THRU ITAB FOR THE IDENTIFIER WITH THE START
*        ADDRESS IN ZIDSTAR IS DONE. IF FOUND BRANCH TO ROUTINE
*        FOL1 FOR TYPECHECK, IF NOT REPLACE IDENTIFIER WITH ALL
*        PURPOSE IDENTIFIER
*
*        RECEIVED REG = ADDR OF IDENTIFIER START
*        INITIALIZED R7
*
IDENT    BAL   R15,MOVE                MOVE IDENTIFIER
         MVC   0(5,R8),ZERO            FILL UP WITH ZERO
*                                      START ITAB SEARCH
         L     R7,ZCURITEN             ADDR OF LAST ITAB ENTRY
         L     R1,ZIBSTAO              ITAB START ADDR
         LA    R0,11
         LCR   R0,R0                   MINUS ELEVEN
IDENT2   LA    R5,IDENT4
IDENT3   CLC   0(6,R7),ZIDEX           IDENTIFIER SEARCH
         BER   R5                      FOUND
IDENT6   BXH   R7,R0,IDENT3            PROCEED SEARCH, IF NOT
         MVC   ZBEGERR,OPSTART
         ST    R8,ZENDERR
         MVC   ZERRONU,UNDEFOP
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         LA    R7,ZALLPU               ALL PURPOSE IDENTIFIER
         B     LETTER1
*
IDENT4   B     IDENT5                  BRANCH IF NOT PROC HEAD
*
         TM    6(R7),X'02'             PROC OR FORMAL PARAMETER ?
         BZ    IDENT6                  NO, CONTINUE SEARCH
         CLC   8(1,R7),CURPBN          DECLARED IN LAST BLOCK ?
         BNE   IDENT6                  NO, CONTINUE SEARCH
IDENT5   TM    STATUS,SARRAY           HANDLING ARRAY DECLARATION ?
         BZ    FOLI                    NO
         CLC   BRCNT(2),ZERO           IDENTIFIER IN ARRAY LIST ?
         BE    FOLI                    NO, ARRAY IDENTIFIER
         CLC   8(1,R7),CURPBN          DECLARED IN LAST BLOCK ?
         BL    FOLI                    NO
         MVC   ZSTO(2),6(R7)           IDENT CHARACTERISTIC
         NC    ZSTO(2),ZSTO1
         CLC   ZSTO(2),ZSTO2           FUNCTION PROCEDURE ?
         BE    IDENT7                  YES
         CLI   ZSTO,X'02'              FORMAL PARAM OR PROC ?
         BE    FOLI                    YES
IDENT7   MVC   ZBEGERR,OPSTART         GIVE WARNING MESSAGE
         ST    R8,ZENDERR
         MVC   ZERRONU,ARRAYERR
         BAL   R15,MOVERRO
         AR    R7,R0                   PROCEED SEARCH FOR IDENTIFIER
         B     IDENT2
*
*        FOLI
*
*        CHECK TYPE OF IDENTIFIER
*
FOLI     IC    R5,6(,R7)               ISOLATE SPECIAL USE BITS
         N     R5,SPECUSE              X'00000006'
         AR    R5,R5                   SPECIAL USE BITS MULTIPLIED BY 4
         B     *+4(R5)
         B     NOCRI               +00 NON-CRITICAL IDENTIFIER
         B     PROFU               +04 PROCEDURE OR FORMAL PARAMETER
         B     SWILA               +08 LABEL OR SWITCH
         B     CRITI               +12 CRITICAL IDENTIFIER
*
NOCRI    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    LETTER1
         CLI   ZFORTEST,X'00'          APPEARS IDENT BETWEEN FOR - DO
         BNE   NOCRI1                  YES
*                                      SHOULD ENTRY TO LVTAB BE DONE ?
         CLC   PFA(4),PFANO            FOR-STATMENT
         BE    LETTER1                 NO, NO LVTAB-ENTRY
         CLI   0(R3),X'16'             IDENTIFIER FOLLOWED BY ASSIGN ?
         BNZ   LETTER1                 NO, NO LVTEB-ENTRY
         TM    7(R7),X'02'             INTEGER ?
         BO    LETTER1                 NO, NO LVTAB-ENTRY
         BAL   R9,LETRAF               MAKE ENTRY IN LVTAB
         B     LETTER1                 RETURN
*
NOCRI1   BAL   R14,CRIMA               MAKE CRIDTAB ENTRY
         B     LETTER1
*
*        PROFU
*
*        BECAUSE OF POSSIBLE SIDE EFFECTS OF A PROCEDURE,
*        OPTIMIZATION OF SUBSCRIPTS AND FOR-STATEMENTS IS
*        INHIBITED
*
*        SUBROUTINE LINK VIA R15
*
PROFU    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    LETTER1                 YES
         MVC   ZARSPO(4),ZARNO         SKIP ARIDSTAB
         CLI   ZFORTEST,X'C0'          CONTROLLED VARIABLE ?
         BNE   PROFU1                  NO
         L     R5,ZFSPTR               YES, CLASSIFIED NORMAL
         OI    0(R5),NORMAL
PROFU1   MVI   ZFORTEST,X'00'          TURN OFF FOR-SWITCH
         CLC   PFA(4),PFANO            CRIDTAB EMPTY ?
         BE    LETTER1                 YES, RETURN
         BAL   R15,DELCRIV             DELETE ALL CRIDTAB-ENTRIES
         B     LETTER1                 RETURN
*
*        SWILA
*
*        IN CASE OF SWITCH OF LABEL DECLARATION NO ACTION IS
*        TAKEN. IF USED IN A GO-TO-STATEMENT A TEST IS DONE IF
*        THE ALGOL RULES ARE FOLLOWED. IF NOT GIVE MESSAGE
*
*        RECEIVED R7
*        WORK REG R1, SIGNEMBR, R1, R9
*
SWILA    LR    R1,R7                   START SEARCH FOR HEADING ENTRY
SWILA1   SH    R1,KH11
         CLI   5(R1),X'2B'             HEADING TEST
         BNE   SWILA1                  NO HEADING
         MVC   ALIGNH(2),8(R1)
         L     R9,ALIGN
         LH    R2,ZIGN                 ACTUAL IGN
         LA    R1,ZFOSTA-1             ADDR OF BYTE PRECEED FSTAB
SWILA2   CR    R2,R9                   COMPARE DECLAR AD AND CUR IGN
         BH    SWILA3                  CHECK EMBRACING IGN TO CUR IGN
         BE    LETTER1
         TM    STATUS,SSWITCH          IN SWITCH DECLARATION ?
         BZ    SWILA21                 NO, SERIOUS ERROR
         MVC   ZBEGERR,OPSTART         YES, GIVE WARNING MESSAGE
         ST    R8,ZENDERR
         MVC   ZERRONU,SWITCHER
         BAL   R15,MOVERRO
         B     LETTER1
*
SWILA21  MVC   ZERRONU,GOTOFOR
         B     INCOROP
*
SWILA3   LR    R5,R2                   COMPUTE ADDR OF IGN-TAB-ENTR
         AR    R5,R2
         AR    R5,R2                   3+ZIGNEMB
         LA    R5,GPTAB(R5)            GPTAB+3*ZIGNEMB
         CLI   2(R5),0                 TEST IF FORGROUP
         BE    SWILA4                  NO
         MVC   *+9(1),2(R5)            ADDR ACTUAL ENTRY IN FSTAB
         OI    0(R1),X'20'             SET BIT IND BRANCH OUT OF FS
SWILA4   MVC   ALIGNH(2),0(R5)
         L     R2,ALIGN                LOAD EMBRACING IGN
         B     SWILA2
*
*        CRITI
*
*        ROUTINE ENTRED WHEN A CRITICAL IDENTIFIER IS FOUND IN
*        ITAB. IF THE IDENTIFIER APPEARS BETWEEN FOR AND DO A NEW
*        CHAINED CRIDTAB-ENTRY IS MADE. OTHERWISE ONLY THE
*        FSTAB-ENTRY IS TREATED
*
*        WORK REG R1,R8
*
CRITI    CLI   ZFORTEST,X'00'          CRITICAL IDENTIFIER IN FOR-LIST?
         BNE   CRITIF                  YES
*                                      IDENTIFIER NOT FOR-LIST-ELEMENT
         CLC   ZARSPO(4),ZARNO         CURRENTLY HANDLING SUBSCR EXPR?
         BC    7,LETTER1               YES
         L     R1,PFA                  POINTER TO LAST CRIDTAB ENTRY
CRITI1   CLC   1(3,R1),8(R7)           SCAN CRIDTAB FOR LAST ENTRY
         BE    CRITI2                  FOUND
         SH    R1,KH9
         B     CRITI1
*
CRITI2   CLI   0(R3),X'16'             IDENTIFIER FOLLOWED BY ASSIGN ?
         BE    CRITI3                  YES
         TM    4(R1),X'80'             CONTROLLED VARIABLE ?
         BZ    LETTER1                 NO, RETURN
         SR    R5,R5                   ADDR FSTAB ENTRY
         IC    R5,0(,R1)
         LA    R5,ZFOSTA(R5)
         OI    0(R5),X'80'             ELEMENTARY LOOP
         B     LETTER1                 RETURN
*
*        IDENTIFIER FOLLOWED BY ASSIGNMENT
*
CRITI3   SR    R5,R5                   GET ADDR OF FSTAB ENTRY
         IC    R5,0(,R1)
         LA    R5,ZFOSTA(R5)
         TM    4(R1),X'80'             CONTROLLED VARIABLE ?
         BO    CRITI4                  YES
         OI    0(R5),NORMAL            NORMAL LOOP
         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?
         BZ    LETTER1                 NO, RETURN
         MVC   ALIGNH(2),5(R1)         GET ADDR OF NEXT ENTRY
         L     R1,ALIGN
         A     R1,ZFOCRI
         B     CRITI3                  HANDLE NEXT ENTRY
*
CRITI4   OI    0(R5),X'40'             INDICATE ASSIGN TO CTR VAR
         B     LETTER1
*
*        TREATMENT OF CRIT ID IN FOR-LIST
*
CRITIF   BAL   R14,CRIMA               MAKE CRIDTAB ENTRY
         L     R8,PFA                  PTR TO LAST CRIDTAB ENTRY
         LR    R1,R8                   START SCAN FOR PREVIOUS ENTRY
CRITIF1  SH    R1,KH9
         C     R1,PFANO                THERE A PREVIOUS ENTRY ?
         BNH   LETTER1                 NO, DELETED AT CRIDTAB OVERFLOW
         CLC   1(3,R1),1(R8)           PREVIOUS ENTRY ?
         BNE   CRITIF1                 NO
*                                      PREVIOUS ENTRY IN CRIDTAB FOUND
         BAL   R15,PUTCHAIN            CHAIN NEW ENTRY TO PREVIOUS
         TM    4(R8),X'80'             NEW ENTRY CONTROLLED VARIABLE
         BZ    CRITIN                  NO
*
*        TREATMENT OF CONTROLLED VARIABLE
*
CRITIC   SR    R5,R5
         IC    R5,0(,R1)               FSN OF CHAINED CRIDTAB ENTRY
         LA    R5,ZFOSTA(R5)           ADDR OF CHAINED FSTAB ENTRY
         TM    4(R1),X'80'             CHAINED ENTRY CONTROLLED ?
         BO    CRITIC1                 YES
         OI    0(R5),NORMAL            INDICATE NORMAL LOOP
         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?
         BZ    LETTER1                 NO, RETURN
         MVC   ALIGNH(2),5(R1)         GET ADDR OF NEXT CHAINED ENTRY
         L     R1,ALIGN
         A     R1,ZFOCRI
         B     CRITIC
*
CRITIC1  OI    0(R5),X'40'             BIT FOR ASSIGN TO CONTROL VAR
         B     LETTER1
*
*        TREATMENT OF NON-CONTROLLED VARIABLE
*
CRITIN   TM    4(R1),X'80'             CHAINED ENTRY CONTROLLED ?
         BO    CRITIN1                 YES
         TM    4(R1),X'40'             MORE CHAINED ENTRIES ?
         BZ    LETTER1                 NO
         MVC   ALIGNH(2),5(R1)         GET ADDR OF CHAINED ENTRY
         L     R1,ALIGN
         A     R1,ZFOCRI
         B     CRITIN
*
CRITIN1  SR    R5,R5                   GET ADDR OF CHAINED FSTAB ENTRY
         IC    R5,0(,R1)
         LA    R5,ZFOSTA(R5)
         CLC   0(1,R1),ZFSN            CHAINED ENTRY PART OF ACTIVE FOR
         BE    CRITIN2                 YES
         CLC   ZARSPO(4),ZARNO         CURRENTLY HANDLING A SUBSCRIPT ?
         BNE   LETTER1                 YES, RETURN
         OI    0(R5),X'80'             SET ELEMENTARY LOOP
         B     LETTER1
*
CRITIN2  OI    0(R5),NORMAL            INDICATE NORMAL LOOP
         B     LETTER1
*
*        PUTCHAIN
*
*        ROUTINE TO CHAIN NEW CRIDTAB ENTRY TO PREVIOUS
*
*        RETURN VIA R15
*        RECEIVED REG R8, R1
*
PUTCHAIN OI    4(R8),X'40'             BIT FOR PREVIOUS CRITICAL IDENT
         OI    4(R1),X'20'             BIT FOR SUBSEQUENT CRIT IDENT
         L     R6,ZFOCRI               CRIDTAB START ADDR
         LR    R5,R1                   GET BACKWARD CHAIN
         SR    R5,R6
         ST    R5,ALIGN
         MVC   5(2,R8),ALIGNH
         LR    R5,R8                   GET FORWARD CHAIN
         SR    R5,R6
         ST    R5,ALIGN
         MVC   7(2,R1),ALIGNH
         BR    R15                     RETURN
*
*        CRIMA
*
*        SUBROUTINE TO MAKE A NEW CRIDTAB ENTRY
*
*        IN CASE OF CRIDTAB OVERFLOW THE ROUTINE CRIFLOW IS
*        ENTRED TO DELETE FROM CRIDTAB ALL ENTRIES BELONG TO THE
*        MOST EMBRACING FOR-STATEMENT. CRIFODEL IS ENTERED IF AN
*        ARRAY ELEMENT IS HANDLED
*
*        RETURN VIA R14
*        RECEIVED REG R7 POINTER TO ACTUELL ITAB ENTRY
*        WORK REG R8
*        SUBROUTINE CRIFLOW, LETRAF, CRIFODEL, SUCRIDEL
*
CRIMA    TM    7(R7),X'04'             ARRAY ?
         BO    CRIMA1                  YES, NO OPTIMIZATION POSSIBLE
         L     R8,PFA                  CURRENT CRIDTAB PTR
         TM    ZFORTEST,X'C0'          CONTROLLED VARIABLE ?
         BO    CRIMAC                  YES
*
*        TREATMENT OF 'NOT CONTROLLED' VARIABLE
*
         C     R8,PFAMAX               CRIDTAB OVERFLOW ?
         BE    CRIMAN1                 YES
CRIMAN2  LA    R8,9(,R8)               UPDATE CURRENT PTR
         MVI   4(R8),X'00'             FLAG BYTE SHOWS NO CNTL VARIABLE
         TM    7(R7),X'02'             INTEGER ?
         BZ    CRIMA2                  YES
         L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),NOCOUNT           CLASSIFY AS NOT COUNTING LOOP
*
CRIMA2   MVC   1(3,R8),8(R7)           MOVE ADDR PART TO CRIDTAB
         MVC   0(1,R8),ZFSN            MOVE FSN TO CRIDTAB
         LR    R5,R7                   GET RELATIVE ADDR IN ITAB
         S     R5,ZIBSTAO
         ST    R5,ALIGN                ITAB RELATIVE ADDR
         MVC   5(2,R8),ALIGNH
         OI    6(R7),X'06'             TURN ON SPECIAL USE BITS
         ST    R8,PFA                  SAVE CURRENT PTR
         BR    R14                     RETURN
*
CRIMAN1  BAL   R15,CRIFLOW             DELETE MOST EMBRACING FOR-STAT
         C     R8,PFANO                ALL CRIDTAB DELETED ?
         BNE   CRIMAN2                 NO
         MVI   ZFORTEST,0              NO MORE CRIDTAB ENT TO BE DONE
         BR    R14
*
CRIMAC   TM    7(R7),X'02'             INTEGER ?
         BZ    CRIMAC1                 YES
         L     R5,ZFSPTR               CURRENT FSTAB PTR
         OI    0(R5),X'80'             SET BIT FOR ELEMENTARY LOOP
CRIMAC4  C     R8,PFAMAX               OVERFLOW ?
         BE    CRIMAC2                 YES
CRIMAC3  LA    R8,9(,R8)               UPDATE CURRENT PTR
         MVI   ZFORTEST,X'80'          INDICATE CONTROL VAR TREATED
         MVI   4(R8),X'80'             SET BIT FOR CONTROLLED VAR
         B     CRIMA2
*
CRIMAC1  C     R8,PFANO                NESTED FOR STATEMENT ?
         BE    CRIMAC3                 NO
         BAL   R9,LETRAF               MAKE LVTAB ENTRY
         B     CRIMAC4
*
CRIMAC2  BAL   R15,CRIFLOW             CRIDTAB OVERFLOW
         B     CRIMAC3
*
CRIMA1   L     R5,ZFSPTR               CURRENT FSTAB PTR
         OI    0(R5),NORMAL            NORMAL LOOP
         MVI   ZFORTEST,0              NO MORE CRIDTAB ENTRIES
         BR    R14                     RETURN
*
*        CRIFLOW
*
*        THE SUBROUTINE IS ENTERED AT CRIDTAB OVERFLOW TO
*        DELETE ALL CRIDTAB ENTRIES BELONGING TO THE MOST
*        EMBRACING FOR STATEMENT
*
*        RETURN VIA R15
*        WORK REG R1, R2, R9
*
CRIFLOW  L     R2,ZFOCRI               CRIDTAB START ADDR
         CLC   0(1,R2),0(R8)           ALL ENTRIES FROM SAME FOR ST ?
         BE    DELCRIV                 YES, DELETE WHOLE CRIDTAB
         MVC   FSNEMBR(1),0(R2)        SAVE MOST EMBRACING FSN
CRIFLOW1 CLC   0(1,R2),FSNEMBR         ENTRY OF MOST EMBRACING FOR ST ?
         BNE   CRIFLOW2                NO
         TM    4(R2),X'20'             SUBSEQUENT CHAINED ENTRY ?
         BO    CRIFLOW3                YES
         MVC   ALIGNH(2),5(R2)         ADDR ITAB ENTRY
         L     R5,ALIGN
         A     R5,ZIBSTAO
         NI    6(R5),X'F9'             SET SPECIAL USE BITS TO 00
CRIFLOW4 LA    R2,9(0,R2)              ADDR NEXT CRIDTAB ENTRY
         B     CRIFLOW1
*
CRIFLOW3 MVC   ALIGNH(2),7(R2)         ADDR CHAINED ENTRY
         L     R5,ALIGN
         A     R5,ZFOCRI
         NI    4(R5),X'B0'             TURN OFF BIT FOR PRECEED ENTRY
         MVC   5(2,R5),5(R2)           INSERT RELATIVE ITAB ADDR
         B     CRIFLOW4
*
CRIFLOW2 SR    R5,R5                   ADDR FSTAB ENTRY OF DEL FOR
         IC    R5,FSNEMBR
         LA    R5,ZFOSTA(R5)
         OI    0(R5),NORMAL            NORMAL LOOP
         L     R9,ZFOCRI               CRIDTAB START ADDR
         LR    R1,R2
         SR    R1,R9                   GET LENGTH OF DELETED PART
*
CRIFLOW5 TM    4(R2),X'40'             PRECEEDING CRIDTAB ENTRY ?
         BZ    CRIFLOW6                NO
         MVC   ALIGNH(2),5(R2)         DECREASE CHAIN ADDR
         L     R5,ALIGN
         SR    R5,R1
         ST    R5,ALIGN
         MVC   5(2,R2),ALIGNH
CRIFLOW6 TM    4(R2),X'20'             SUBSEQUENT CRITAB ENTRY ?
         BZ    CRIFLOW7
         MVC   ALIGNH(2),7(R2)         DECREASE CHAIN ADDR
         L     R5,ALIGN
         SR    R5,R1
         ST    R5,ALIGN
         MVC   7(2,R2),ALIGNH
CRIFLOW7 MVC   0(9,R9),0(R2)           MOVE ENTRY DOWN IN CRIDTAB
         CR    R2,R8                   LAST ENTRY ?
         BE    CRIFLOW8                YES
         LA    R2,9(,R2)               ADDR NEXT ENTRY
         LA    R9,9(,R9)
         B     CRIFLOW5
*
CRIFLOW8 SR    R8,R1                   GET ADDR OF LAST CRIDTAB-ENT
         BR    R15
*
*        DELCRIV
*
*        ROUTINE TO DELETE ALL ENTRIES IN CRIDTAB AND TURN OFF
*        THE SPECIAL USE BITS OF CORRESPONDING ITAB ENTRY. ALL
*        FOR-STATEMENTS WITH CRIDTAB ENTRIES WILL BE CLASSIFIED
*        NORMAL
*
*        RETURN VIA R15
*        INITIALIZED REG R8
*
DELCRIV  L     R5,ZFOCRI               CRIDTAB START ADDR
DELCRIV1 SR    R6,R6                   ADDR FSTAB ENTRY
         IC    R6,0(,R5)
         LA    R6,ZFOSTA(R6)
         OI    0(R6),NORMAL            CLASSIFIED NORMAL
         TM    4(R5),X'40'             IDEN CRIT IN EMBR FOR-STAT ?
         BO    DELCRIV2                YES, ITAB ENTRY ALREADY NON CRI
         MVC   ALIGNH(2),5(R5)         ADDR ITAB ENTRY
         L     R6,ALIGN
         A     R6,ZIBSTAO
         NI    6(R6),X'F9'             CLEAR SPEC USE BITS
DELCRIV2 C     R5,PFA                  LAST CRIDTAB ENTRY ?
         BE    DELCRIV3                YES
         LA    R5,9(,R5)               ADDR NEXT CRIDTAB ENTRY
         B     DELCRIV1
*
DELCRIV3 L     R8,PFANO
         ST    R8,PFA
         BR    R15
*
*        CRIFODEL
*
*        ROUTINE TO DELETE THE CRIDTAB ENTRIES OF THE LAST FOR
*        STATEMENT
*
*        RETURN VIA R15 WORK REG R8
*
CRIFODEL L     R8,PFA                  POINTER TO LAST CRIDTAB-ENTRY
         MVC   CRIFODS+1(1),0(R8)      INSERT FOR STATEMENT NUMBER
CRIFOD1  C     R8,PFANO                CRIDTAB EMPTY ?
         BE    CRIFOD4                 YES, RETURN
CRIFODS  CLI   0(R8),0                 NEW FORSTATEMENT, OLD FSN INSER
         BNE   CRIFOD4                 YES, RETURN
         TM    4(R8),X'40'             IDENTIFIER USED IN EMBR FOR-ST
         BO    CRIFOD2                 YES
         MVC   ALIGNH(2),5(R8)         CLEAR SPEC USE BITS IN CRIDTAB
         L     R5,ALIGN
         A     R5,ZIBSTAO              ABSOLUTE ITAB ADDR
         NI    6(R5),X'F9'             CLEAR SPECIAL USE BITS IN ITAB
CRIFOD3  SH    R8,KH9                  POINT TO PRECEEDING ENTRY
         B     CRIFOD1
*
CRIFOD2  L     R5,ZFOCRI               TURN OFF BIT FOR SUBSEQ ENTRY
         MVC   ALIGNH(2),5(R8)         ADDR OF PREVIOUS CRIDTAB-ENT
         A     R5,ALIGN
         NI    4(R5),X'CF'             TURN OFF BIT FOR SUBSEQ ENTRY
         B     CRIFOD3                 GET NEXT ENTRY
*
CRIFOD4  ST    R8,PFA
         BR    R15
*
*        SUCRIDEL
*
*        THE SUBROUTINE IS ENTERED WHEN UNOPTIMIZABLE SUBSCRIPT
*        EXPRESSION IS FOUND. A SCAN BETWEEN THE TWO LAST
*        SUBSCRIPT OPERATORS IS DONE IN THE OUTPUT BUFFER. IF A
*        CONTROLLED CRITICAL IDENTIFIER IS FOUND, CORRESPONDING
*        ENTRY IN FSTAB IS MADE ELEMENTARY. OTHERWISE NO ACTION
*
*        RETURN VIA R15
*        WORK REG R1, R2, R14
*
SUCRIDEL CLC   PFA(4),PFANO            CRIDTAB EMPTY
         BER   R15                     YES, RETURN
         LA    R2,1(,R4)               ADDR OF LAST SUBSCR OPERAND
         L     R1,ZBRACK               ADDR OF FIRST SUBSCR OPERAND
SUCRID1  LA    R1,1(,R1)               CHECK NEXT BYTE
SUCRID2  CR    R1,R2                   END OF SCAN ?
         BNLR  R15                     YES, RETURN
         TM    0(R1),X'80'             AN OPERAND FOUND ?
         BZ    SUCRID1                 NO
         TM    0(R1),X'06'             CRITICAL IDENTIFIER ?
         BO    SUCRID4                 YES
SUCRID3  LA    R1,5(,R1)               ADDR NEXT ELEMENT
         B     SUCRID2
*
*        TREATMENT OF CRITICAL IDENTIFIERS
*
SUCRID4  L     R14,PFA                 ADDR OF LAST CRIDTAB ENTRY
         LA    R14,9(,R14)
SUCRID5  SH    R14,KH9                 FIND IDENTIFIER IN CRIDTAB
         CLC   1(3,R14),2(R1)          IDENTIFIER FOUND ?
         BNE   SUCRID5                 NO
*
SUCRID6  TM    4(R14),X'80'            CONTROLLED VARIABLE ?
         BZ    SUCRID7                 NO
         LA    R5,ZFOSTA               ADDR OF FSTAB
         MVC   *+9(1),0(R14)           DISPLACEMENT EQUALS FOR NUMBER
         OI    0(R5),X'80'             ELEMENTARY LOOP
         B     SUCRID3
*
*        FIND CHAINED CONTROLLED VARIABLE
*
SUCRID7  TM    4(R14),X'40'            ANY CHAINING ?
         BZ    SUCRID3                 NO
         MVC   ALIGNH(2),5(R14)        CRIDTAB CHAIN
         L     R14,ALIGN
         A     R14,ZFOCRI              ADDR CHAINED ENTRY
         B     SUCRID6
*
*        LETRAF
*
*        MAKE ENTRIES IN LVTAB CORRESPONDING TO ALL
*        SUBSCRIPTABLE NESTED FOR-STATEMENTS
*
*        RETURN VIA R9
*        RECIEVED REG R7, WORK REG R1, R2, R6
*
LETRAF   CLI   ZLVOV,X'FF'             TABLE OVERFLOW OCCURED ?
         BER   R9                      YES
         L     R1,PFA                  ADDR OF LAST CRIDTAB ENTRY
LETRAF1  LR    R2,R1
         LA    R5,ZFOSTA
         MVC   *+9(1),0(R1)            ADDR ACTUAL FSTAB ENTRY
         TM    0(R5),NOSUOP
         BO    LETRAF2
         L     R6,ZLEVA
         C     R6,ZLESTA               WRITE BEEN ISSUED ?
         BNE   LETRAF5                 NO
         BAL   R5,CHECK                YES, CHECK
         CLC   LVLENGTH(4),LVTAB40S    MORE OUTPUT ALLOWED ?
         BNL   LETRAF4                 NO
         LH    R5,LVCNT                STEP RECORD COUNTER
         LA    R5,1(,R5)
         STH   R5,LVCNT
LETRAF5  LA    R6,4(,R6)
         MVC   0(1,R6),0(R1)           PLUG IN FS NUMBER
         MVC   1(3,R6),8(R7)           PLUG IN ADDR PART OF CUR ID
         C     R6,ZLEMAX               LVTAB FILLED UP ?
         BE    LETRAF3                 YES
LETRAF6  ST    R6,ZLEVA
LETRAF2  SH    R1,KH9                  GET NEXT CRIDTAB ENTRY
         C     R1,PFANO                BEGINNING OF CRIDTAB ?
         BER   R9                      YES, RETURN
         CLC   0(1,R1),0(R2)           AN ENTRY IN SAME FS ?
         BE    LETRAF2                 SAME
         B     LETRAF1                 NEW
*
LETRAF3  BAL   R5,CHECK                CHECK POSSIBLE WRITE
         L     R5,LVSTRT               WRITE START ADDR
         L     R6,LVTAB30S             LENGTH OF WRITE
         BAL   R15,WRITE               WRITE
         L     R5,LVLENGTH             LENGTH OF LVTAB
         A     R5,LVTAB30S             BUFFER LENGTH
         ST    R5,LVLENGTH
         L     R6,ZLESTA               START ADDR OF LVTAB
         B     LETRAF6
*
LETRAF4  BAL   R15,TABOFLO
         BAL   R15,MOVERRO
         BR    R9
*
*        SUSCRITE
*
*        ROUTINE TO CHECK IF AN SUBSCRIPT EXPRESSION IS
*        OPTIMIZABLE IN WHAT CASE AN SUTAB-ENTRY IS DONE, OTHER
*        SUBROUTINE SUCRIDEL IS ENTERED BEFORE RETURN
*
*        RETURN VIA R9
*        WORK REG R2, R1, R2, R7, R8, R1
*        SUBROUTINE LINKS R15, R14, R14
*
SUSCRITE L     R1,ZBRACK               INITIALIZE CURRENT POINTER
         LR    R5,R4                   ADDR OF LAST BYTE OF SUBSCR
         SH    R5,KH5                  ADDR OPERATOR BEFOR LAST OPD
         ST    R5,SUBEND
         CLI   1(R1),XFMINUS           SUBSCRIPT START WITH + OR -
         BH    SUB1                    NO
         LA    R1,1(,R1)               POINT TO BYTE BEFORE OPERAND
SUB1     C     R1,SUBEND               ANY OPERAND IN SUBSCRIPT ?
         BHR   R9                      NO, RETURN
         BAL   R15,OPERANDR            TEST OPERAND
         C     R1,SUBEND               END OF SUBSCRIPT
         BE    SUBONE
         CLI   6(R1),XFASTER           WHAT FOLLOWS FIRST OPERAND
         BL    SUBPM                   PLUS OR MINUS ?
         BE    SUBAST                  ASTERISK
*
*        UNOPTIMIZABLE SUBSCRIPT EXPRESSION
*
SUBNOOP  BAL   R15,SUCRIDEL            HANDLE UNOPTIMIZABLE EXPRESSION
         BR    R9                      RETURN
*
*        ONLY ONE OPERAND
*
SUBONE   LTR   R8,R2                   CONTROLLED VARIABLE ?
         BP    SUBONE3                 YES
         MVC   ADDEND(6),0(R1)         OPERAND IS ADDEND
         MVC   FACTOR(6),ZEROELEM      SET FACTOR TO ZERO
         L     R8,ZFOCRI               ADDR OF LAST CRIDTAB ENTRY
         L     R2,ZARSPO               ADDR CURRENT ARIDSTAB ENTRY
SUBONE1  SR    R5,R5                   GET FSN
         IC    R5,0(,R8)
         STC   R5,OLDFSN
         LA    R6,ZFOSTA(R5)           ADDR FSTAB ENTRY
         TM    0(R6),X'40'             SUBSCRIPT OPTIMIZATION POSSIBLE
         BO    SUBONE2
         L     R2,ZARSPO               ADDR LAST ARIDSTACK ENTRY
         LA    R6,SPTAB(R5)            ADDR SPTAB ENTRY
         CLC   0(1,R6),0(R2)           SCOPE OF ARRAY OK
         BL    SUBONE2                 NO
         TM    ADDEND+2,X'30'          CONSTANT ?
         BZ    SUBONE4                 YES
         CLC   0(1,R6),ADDEND+3        SCOPE TEST OF ADDEND
         BL    SUBONE2                 NOT OK
SUBONE4  BAL   R14,SUTABENT            MAKE SUTAB ENTRY
SUBONE2  C     R8,PFA                  END OF CRIDTAB
         BER   R9                      YES, RETURN
         LA    R8,9(,R8)               FIND ENCLOSED FOR STATEMENT
OLDFSN   EQU   *+1
         CLI   0(R8),0                 ENTRY TO SAME FOR STATEMENT ?
         BE    SUBONE2                 YES, CHECK NEXT ENTRY
         B     SUBONE1                 NO, POSSIBLY NEW SUTAB ENTRY
*
*        OPERAND IS CONTROLLED VARIABLE
*
SUBONE3  MVC   FACTOR(1),0(R1)         OPERATOR TO FACTOR
         MVC   FACTOR+1(5),ONEELEM+1   SET FACTOR TO ONE
SUBONE5  MVC   ADDEND(6),ZEROELEM      SET ADDEND TO ZERO
         B     SUBFIN1
*
*        FIRST OPERAND FOLLOWED BY + OR -
*
SUBPM    MVC   ADDEND(6),0(R1)         FIRST OPERAND PROBABLY ADDEND
         LR    R7,R2                   SAVE CRIDTAB POINTER
         LA    R1,6(0,R1)              ADDR SIGN OF SECOND OPERAND
         BAL   R15,OPERANDR            CHECK SECOND OPERAND
         C     R1,SUBEND               END OF SUBSCRIPT ?
         BE    SUBPM1                  YES
         CLI   6(R1),XFASTER           ASTERISK SHOULD FOLLOW
         BNE   SUBNOOP                 NOT OPTIMIZABLE
         BAL   R14,SUBMULT             CHECK MULTIPLICATION
         B     SUBFIN                  TERMINATE
*
SUBPM1   CR    R2,R7                   WHAT IS SECOND OPERAND ?
         BL    SUBPM3                  ADDEND
         BE    SUBPM4                  NOT OPTIMIZABLE EXPRESSION
         LR    R8,R2                   ADDR CRIDTAB ENTRY OF CONTR
         MVC   FACTOR(1),0(R1)         SIGN OF FACTOR
SUBPM2   MVC   FACTOR+1(5),ONEELEM+1   SET FACTOR TO ONE
         B     SUBFIN
*
SUBPM3   LR    R8,R7                   SECOND OPERAND ADDEND, SHIFT
         LR    R7,R2
         MVC   FACTOR(1),ADDEND        SIGN OF FACTOR
         MVC   ADDEND(6),0(R1)
         B     SUBPM2
*
SUBPM4   LTR   R8,R7                   CONTROLLED VARIABLE ?
         BZR   R9                      NO
         B     SUBFIN4                 YES
*
*        FIRST OPERAND FOLLOWED BY ASTERISK
*
SUBAST   BAL   R14,SUBMULT             CHECK MULTIPLICATION
         C     R1,SUBEND               END OF SUBSCRIPT ?
         BE    SUBONE5                 YES, SET ADDEND TO ZERO
         CLI   6(R1),XFMINUS           PLUS OR MINUS
         BH    SUBNOOP                 NO, NO SUBSCRIPT OPTIMIZATION
         LA    R1,6(,R1)               ADDR SIGN
         BAL   R15,OPERANDR            CHECK OPERAND
         MVC   ADDEND(6),0(R1)         SAVE ADDEND
         LR    R7,R2                   LAST OPERAND WAS ADDEND
*
SUBFIN   LTR   R7,R7                   ADDEND CONTROLLED VARIABLE ?
         BZ    SUBFIN1                 NO
         SR    R5,R5                   YES, INDICATE ELEMENTARY LOOP
         IC    R5,0(,R7)
         LA    R6,ZFOSTA(R5)
         OI    0(R6),X'80'
         CR    R8,R7                   OPTIMIZATION POSSIBLE ?
         BNH   SUBFIN4                 NO
SUBFIN1  SR    R5,R5                   FSN OF CONTROLLED VAR TO RE6
         IC    R5,0(0,R8)
         L     R2,ZARSPO               ADDR LAST ARIDSTAB-ENTRY
         LA    R6,ZFOSTA(R5)           ADDR FSTAB-ENTRY
         TM    0(R6),X'40'             SUBSCRIPT OPTIMIZATION POSS ?
         BO    SUBFIN4                 NO, NO OPTIMIZATION
         LA    R6,SPTAB(R5)            ADDR SPTAB-ENTRY
         CLC   0(1,R6),0(R2)           SCOPE OF ARRAY OK ?
         BL    SUBFIN4                 NO, NO OPTIMIZATION
         TM    FACTOR+2,X'30'          FACTOR CONSTANT ?
         BZ    SUBFIN2                 YES
         CLC   0(1,R6),FACTOR+3        SCOPE OF FACTOR OK
         BL    SUBFIN4                 NO, NO OPTIMIZATION
SUBFIN2  TM    ADDEND+2,X'30'          ADDEND CONSTANT ?
         BZ    SUBFIN3                 YES
         CLC   0(1,R6),ADDEND+3        SCOPE OF ADDEND OK ?
         BL    SUBFIN4                 NO, NO OPTIMIZATION
SUBFIN3  BAL   R14,SUTABENT            MAKE SUTAB ENTRY
         BR    R9                      RETURN
*
SUBFIN4  SR    R5,R5
         IC    R5,0(0,R8)              FSN OF CONTROLLED VARIABLE
         LA    R6,ZFOSTA(R5)           ADDR FSTAB ENTRY
         OI    0(R6),X'80'             ELEMENTARY LOOP
         BR    R9
*
*        OPERANDR
*
*        SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN
*        OPERATOR IF NOT AN INTEGER OPERAND AN ERROR EXIT IS
*        TAKEN. ELSE THE SETTING OF REGISTER R2 SHOWS TYPE OF
*        OPERAND
*
*        INITIALIZED REG R2
*
OPERANDR TM    1(R1),X'80'             OPERAND ?
         BZ    SUBNOOP                 NO
         TM    2(R1),X'CE'             INTEGER ?
         BM    SUBNOOP                 NO
         TM    1(R1),X'06'             CRITICAL IDENTIFIER ?
         BO    OPERAND1                YES
OPERAND4 SR    R2,R2                   INDICATE NO-CONTROLLED VARIABLE
         BR    R15                     RETURN
*
*        OPERAND CONTROLLED VARIABLE ?
*
OPERAND1 L     R2,PFA                  ADDR OF LAST CRIDTAB ENTRY
         LA    R2,9(,R2)               INITIALIZE LOOP
OPERAND2 SH    R2,KH9                  GET NEXT ENTRY
         CLC   1(3,R2),3(R1)           OPERAND FOUND
         BNE   OPERAND2                NO, GET NEXT CRIDTAB ENTRY
*
OPERAND3 TM    4(R2),X'80'             CONTROLLED VARIABLE ?
         BOR   R15                     YES
         TM    4(R2),X'40'             PRECEEDING CRITICAL IDENTIFIER ?
         BZ    OPERAND4                NO
         MVC   ALIGNH(2),5(R2)         GET CRIDTAB CHAIN
         L     R2,ALIGN                GET ADDR OF CHAINED ENTRY
         A     R2,ZFOCRI
         B     OPERAND3                CHECK THIS ENTRY
*
*        SUBMULT
*
*        SUBROUTINE TO SUSCRITE TO CHECK WHAT FOLLOWS AN
*        ASTERISK IF NOT INTEGER FACTOR TIMES INTEGER CONTROLLED
*        VARIABLE AN ERROR EXIT IS TAKEN. OTHERWISE REGISTER R8
*        AND BUCKET FACTOR ARE INITIALIZED
*
*        INITIALIZED R8
*
SUBMULT  MVC   FACTOR(6),0(R1)         MOVE OPERAND TO FACTOR
         LR    R8,R2                   SAVE PTR
         LA    R1,6(,R1)               ADDR NEXT OPERAND
         BAL   R15,OPERANDR            CHECK SECOND OPERAND
         CR    R2,R8                   WHICH OPERAND IS FACTOR ?
         BH    SUBMULT2                FIRST
         BE    SUBNOOP                 NONE, NO OPTIMIZATION
         MVC   FACTOR+1(5),1(R1)       SECOND, MOVE OPERAND TO FACTOR
SUBMULT1 LTR   R2,R2                   FACTOR CONTROLLED VARIABLE
         BZR   R14                     NO, RETURN
         SR    R5,R5                   SET FOR-LOOP OF FACTOR ELEMENT
         IC    R5,0(0,R2)              FSN OF FACTOR
         LA    R6,ZFOSTA(R5)           ADDR FSTAB-ENTRY
         OI    0(R6),X'80'             MAKE LOOP ELEMENTARY
         BR    R14                     RETURN
*
SUBMULT2 LR    R5,R2                   EXCHANGE REGISTERS
         LR    R2,R8
         LR    R8,R5
         B     SUBMULT1
*
*        SUTABENT
*
*        SUBROUTINE TO SUBSCRITE TO MAKE AN SUTAB ENTRY
*
SUTABENT L     R1,ZSUTAPO              CURRENT SUTAB PTR
         C     R1,ZSUDAD               A WRITE MACRO BEEN GIVEN ?
         BNE   SUTAB1                  NO
         BAL   R5,CHECK                CHECK LAST OPERATION ON SYSUT3
         CLC   SULENGTH(4),SUTAB40S    TABLE OVERFLOW ?
         BNL   SUTAB4                  YES
         LH    R5,SUCNT                STEP RECORD COUNTER
         LA    R5,1(,R5)
         STH   R5,SUCNT
SUTAB1   LA    R1,14(,R1)              ADDR NEW SUTAB-ENTRY
         ST    R1,ZSUTAPO              SAVE SUTAB PTR
*                                      MAKE SUTAB ENTRY
         MVC   0(1,R1),0(R8)           INSERT FSN
         MVC   1(3,R1),0(R2)           ADDR PART OF ARRAY
         MVC   4(3,R1),FACTOR+3        ADDR PART OF FACTOR
         MVC   7(3,R1),ADDEND+3        ADDR PART OF ADDEND
         MVC   10(1,R1),ZPOSIX+1       SUBSCRIPT NUMBER
         CLI   FACTOR,XFMINUS          SIGN OF FACTOR MINUS ?
         BNE   SUTAB2                  NO
         OI    10(R1),X'80'            YES, SET 1 BIT TO ONE
SUTAB2   CLI   ADDEND,XFMINUS          SIGN OF ADDEND MINUS ?
         BNE   SUTAB3                  NO
         OI    10(R1),X'40'            YES, SET 2 BIT TO ONE
SUTAB3   MVC   11(3,R1),4(R2)          POSITION OF OPENING BRACKET
         C     R1,ZSUTMAX              SUTAB FILLED UP
         BLR   R14
         BAL   R5,CHECK                CHECK POSSIBLE WRITE
         L     R5,SUSTRT               WRITE START ADDR
         L     R6,SUTAB30S             LENGTH OF WRITE
         BAL   R15,WRITE               WRITE
         L     R5,SULENGTH             GET FULL SUTAB LENGTH
         A     R5,SUTAB30S
         ST    R5,SULENGTH
         MVC   ZSUTAPO(4),ZSUDAD       INITIALIZE CURRENT SUTAB PTR
         BR    R14
*
SUTAB4   BAL   R15,TABOFLO             HANDLE TABLE OVERFLOW
         BAL   R15,MOVERRO
         B     SUBFIN4                 NO OPT, MAKE LOOP ELEMENTARY
*
OUCHA    STM   R14,R2,REGSAVE          SAVE REGISTERS
LOUCHAF  B     LOUCHA7                 BRANCH ONLY IF FIRST RECORD
*
         CHECK SWRITE
*
LOUCHA6  CLC   ZARSPO(4),ZARNO         BUFFER EXCHANGE IN SUBSCR EXPR ?
         BNE   LOUCHA1                 YES
LOUCHA5  MVI   1(R4),XFZETA            ZETA TERMINATES O-BUFFER
         L     R4,ZOBWRITE
         LR    R6,R4
         BCTR  R4,0                    INITIALIZE R4
LOUCHA4  L     R5,SRCE3S               OUTPUT BUFFER LENGTH
         SH    R5,KH12                 SET END PTRS
         AR    R5,R6
         ST    R5,ZFILE9
         LA    R5,3(,R5)
         ST    R5,ZFILE6
         LA    R5,1(,R5)
         ST    R5,ZFILE5
         LA    R5,2(,R5)
         ST    R5,ZFILE3
         LA    R5,1(,R5)
         ST    R5,ZFILE2
         LA    R5,1(,R5)
         ST    R5,ZFILE1
         MVC   ZOBWRITE(4),ZOBWORK     ZOBWRITE = ZOBWORK
         ST    R6,ZOBWORK              START ADDR OF NEW OUT BUFFER
         LH    R5,ZOUTCOT              OUTPUT RECORD COUNTER
         CH    R5,KH255                TOO MUCH SOURCE OUTPUT ?
         BE    LOUCHA8                 YES
         LA    R5,1(,R5)
         STH   R5,ZOUTCOT
         L     R5,AUT2DCB              R5 -> SYSUT2 DCB
         L     R6,ZOBWRITE             AREA ADDR
*
         WRITE SWRITE,SF,(R5),(R6)
*
         LM    R14,R2,REGSAVE          RESTORE REGS
         BR    R15
*
LOUCHA1  L     R5,ZBRACK               GET CURRENT LEN OF SUBSCRIPT
         LR    R6,R4
         SR    R6,R5                   SUBSCRIPT LENGTH
         BM    LOUCHA5                 NOTHING TO SAVE
         CH    R6,KH18                 SUBSCRIPT ALREADY TOO LONG ?
         BH    LOUCHA2                 YES
         STC   R6,LOUCHAM+1            LENGTH OF SUBSCRIPT
         STC   R6,LOUCHAL+3
         L     R6,ZOBWRITE             START ADDR OF NEW OUT-BUFFER
LOUCHAM  MVC   0(1,R6),0(R5)           SAVE SUBSCRIPT
         MVI   0(R5),XFZETA            REPLACE OPENING BRACKET BY ZETA
LOUCHAL  LA    R4,0(0,R6)              DISPLACEMENT LENGTH OF SUB
         ST    R6,ZBRACK               ADDR OF OPENING BRACKET
         CLI   0(R6),XFLSQBR           SUBSCRIPT OPERATOR OPEN BRAC ?
         BNE   LOUCHA4                 NO
         L     R5,ZARSPO               YES, UPDATE ARIDSTAB ENTRY
         LH    R6,ZOUTCOT              OUTPUT RECORD COUNTER
         LA    R6,1(,R6)               UPDATE
         STC   R6,4(,R5)               STORE RECORD COUNTER
         MVC   5(2,R5),ZERO            SET RELATIVE ADDR TO ZERO
         L     R6,ZOBWRITE             START ADDR OF NEW BUFFER
         B     LOUCHA4
*
LOUCHA2  BAL   R15,SUCRIDEL
         MVI   ZCLOBRA,X'FF'           ZCLOBRA IS SET TO X'FF'
         L     R5,ZOBWRITE             START ADDR OF NEW BUFFER
         BCTR  R5,0
         ST    R5,ZBRACK
         B     LOUCHA5                 BRANCH TO LOUCHA5
*
LOUCHA7  MVI   LOUCHAF+1,X'00'         TURN OFF SWITCH
         B     LOUCHA6
*
LOUCHA8  MVC   ZERRONU,TOOLONG
         MVC   ZBEGERR,ZENDERR
         BAL   R15,MOVERRO
         B     LOMEGA3
*
*        ICHA
*
*        THE ROUTINE IS ENTERED WHEN OPERATOR ZETA (END OF INPUT
*        BUFFER) IS FOUND. IF NECESSARY A PART OF THE OLD BUFFER
*        IS SAVED IMMEDIATLY BEFORE THE NEW BUFFER. START
*        ADDR OF SAVED AREA IS STORED IN ZIBWORK
*
*        RETURN VIA R15
*
ICHA     STM   R14,R2,REGSAVE          SAVE REGISTERS
*
         CHECK SREAD                   CHECK LAST READ
*
ICHA1    L     R5,AUT1DCB              R5 -> SYSUT1 DCB
         L     R6,ZIBRUN               AREA ADDR
*
         READ  SREAD,SF,(R5),(R6)
*
         LM    R14,R2,REGSAVE          RESTORE REGISTERS
         L     R3,ZIBREAD              BEGIN OF ACTIVITED BUFFER
         MVC   ZIBREAD(4),ZIBRUN       EXCHANGE POINTERS
         ST    R3,ZIBRUN
         BR    R15
*
ICHAI    STM   R14,R2,REGSAVE
         B     ICHA1
*
*        ITABMOVE
*
*        ITABMOVE IS ENTERED AT THE BEGINNING OF A NEW PROGRAM
*        BLOCK AND DURING INITIALIZATION. THE READ OF NEXT ITAB-
*        RECORD IS ALREADY INITIALIZED. IF A MOVE OF NEXT RECORD
*        IS NECESSARY IT IS DONE BY THE SUBROUTINE ITABM. ALL
*        CURRENT ITAB-POINTERS IS UPDATED
*
*        RETURN VIA R15
*        WORKREG R7, R8
*        SUBROUTINE ITABM, MOVERRO
*
ITABMOP  MVI   LETTER+1,X'00'          TURN OFF PROCEDURE SWITCH
ITABMOVE STM   R14,R2,REGSAVE
         CLI   IOBYTE,READM            INITIALIZED READ OPERATION ?
         BNE   ITAB4                   NO
*
         CHECK RITAB                   YES, CHECK
*
         MVI   IOBYTE,READC            SET READ CHECK MASK
ITAB4    L     R7,ZITREC               ADDR OF BLOCKBEGIN
         MVC   6(2,R7),ZCURITLE        ITAB REC LENGTH OF EMBR BLOCK
         MVC   ZCURITLE(2),0(R7)       LENGTH OF BLOCK
         L     R8,ZCURITEN             A MOVE IS NECESSARY ?
         LA    R8,11(,R8)
         CR    R8,R7
         BE    ITAB1                   NO, MOVE
*
*        MOVE ITAB RECORD
*
         LH    R6,ZCURITLE             LENGTH OF ITAB RECORD
         EX    R6,ITABMEX              MOVE FIRST PART
         LR    R5,R6
         AR    R7,R5                   END ADDR OF MOVED RECORD
         AR    R5,R8                   END ADDR OR UNMOVED RECORD
         SH    R7,KH1792               PREPARE MOVE
         SH    R5,KH1792               PREPARE MOVE
         SRA   R6,8                    PREPARE BRANCH
         SLA   R6,2
         B     *+4(R6)
*
         B     ITABM8                  +00
         B     ITABM7                  +04
         B     ITABM6                  +08
         B     ITABM5                  +12
         B     ITABM4                  +16
         B     ITABM3                  +20
         B     ITABM2                  +24
         MVC   0(256,R5),0(R7)         +28
*
ITABM2   MVC   256(256,R5),256(R7)
ITABM3   MVC   512(256,R5),512(R7)
ITABM4   MVC   768(256,R5),768(R7)
ITABM5   MVC   1024(256,R5),1024(R7)
ITABM6   MVC   1280(256,R5),1280(R7)
ITABM7   MVC   1536(256,R5),1536(R7)
ITABM8   EQU   *
*
ITAB1    LH    R5,ZCURITLE             GET ADDR OF LAST ITAB ENTRY
         A     R5,ZCURITEN             ACTUAL RECORD LENGTH + PREV ADD
         ST    R5,ZCURITEN
         LA    R5,11(,R5)              ADDR OF FIRST FREE BYTE
         ST    R5,ZITREC
         CLC   10(1,R8),PBN+1          LAST ITAB RECORD ?
         BE    ITAB7                   YES
         MVC   ALIGNH(2),2(R8)         LENGTH OF NEXT BLOCK
         A     R5,ALIGN                END ADDR OF NEXT BLOCK
         C     R5,ZITEND               ITAB OVERFLOW ?
         BH    ITAB10                  YES
         CLI   IOBYTE,READC            WHICH I/O STATUS ?
         BE    ITAB6                   CHECKED READ OPERATION
         BL    ITAB5                   CHECKED WRITE OPERATION
*
         CHECK TWRITE                  INITIALIZED WRITE OPERATION
*
ITAB5    EQU   *
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
*
         NOTE  (1)                     SAVE ID OF LAST BLOCK
*
         ST    R1,NOTEW
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
         MVI   NOTER+3,X'01'           ADDR NEXT ITAB BLOCK
*
         POINT (1),NOTER
*
ITAB6    L     R5,AUT3DCB              R5 -> SYSUT3 DCB
         L     R6,ZITREC               READ START ADDR
*
         READ  RITAB,SF,(R5),(R6),'S'
*
         MVI   IOBYTE,READM            SET ITAB READ
ITAB7    LM    R14,R2,REGSAVE          RESTORE REGS
         MVC   CURPBN(1),10(R8)        SAVE CURRENT PBN
         BR    R15                     RETURN
*
ITAB10   ST    R3,ZBEGERR              ERROR EDIT
         ST    R3,ZENDERR
         MVC   ZERRONU,ITABOVER
         BAL   R15,MOVERRO
         B     LOMEGA3
*
ITABREAD STM   R14,R2,REGSAVE
         LA    R8,GENER                 ADDR DUMMY HEADER
         B     ITAB6
*
ITABMEX  MVC   0(1,R8),0(R7)
*
*        INVALID OPERAND FOUND
*
*        SET SYNTAX CHECK MODE AND GIVE ERROR MESSAGE
*
INCOROP  OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         LA    R0,ZIDEX+12
INCOROP5 LR    R9,R3
INCOROP1 CLI   0(R3),X'2E'             END OF OPERAND ?
         BL    INCOROP2                YES
         BE    INCOROP3                STRING OR LOGICAL VALUE
         CLI   0(R3),XFZETA            END OF INPUT BUFFER ?
         BE    INCOROP4                YES
         LA    R3,1(,R3)               PROCEED SCAN FOR OPERAND END
         B     INCOROP1
*
INCOROP4 LR    R1,R3
         BAL   R15,MOVE
         BAL   R15,ICHA
         B     INCOROP5
*
INCOROP2 LR    R1,R3
         BAL   R15,MOVE
         ST    R8,ZENDERR
         MVC   ZBEGERR,OPSTART
         BAL   R15,MOVERRO
         LA    R7,ZALLPU               REPLACE INCOR ID  BY ALL PUB ID
         B     LETTER1
*
INCOROP3 MVC   0(6,R3),ZPOINT          REPLACE INT NAME BY SIX PERIODS
         LA    R3,6(,R3)
         B     INCOROP1
*
*        MOVERRO
*
*        ERROR EDITING ROUTINE
*
*        OUTPUTS ALWAYS FIXED PART CONTAINING LENGTH OF ENTRY,
*        ERROR NUMBER AND SEMICOLON COUNTER. SOMETMES VARIABLE
*        PART WHOSE START ADDR IS STORED IN ZBEGERR AND (END
*        ADDR + 1) IN ZENDERR
*
*        RETURN VIA R15
*
MOVERRO  L     R5,NEXTERR
         C     R5,ENDPOOL              ERROR POOL OVERFLOW ?
         BH    MOVERRO2                YES
         L     R6,ZENDERR              GET LENGTH OF VARIABLE PART
         S     R6,ZBEGERR
         CH    R6,KH12                 LENGTH EXCEEDS MAXIMUM ?
         BNH   MOVERRO1                NO
         LH    R6,KH12                 YES, SET LENGTH TO MAX
MOVERRO1 LA    R6,4(,R6)               LENGTH OF FULL ERROR ENTRY
         AR    R5,R6                   GET ADDR OF NEXT ERROR ENTRY
         ST    R5,NEXTERR
         SR    R5,R6
         STC   R6,0(,R5)               FIXED PART OF ERROR ENTRY, LEN
         MVC   1(1,R5),ZERRONU+1       ERROR NUMBER
         MVC   2(2,R5),SEMCNT          SEMICOLON COUNTER
         SH    R6,KH5                  ANY VARIABLE PART ?
         BM    MOVERRO3                NO
         STC   R6,MOVERROM+1           LENGTH OF MOVE
         L     R6,ZBEGERR              START ADDR OF ADDITIONAL PART
MOVERROM MVC   4(1,R5),0(R6)           MOVE ADDITIONAL PART
MOVERRO3 BR    R15
*
MOVERRO2 MVI   0(R5),X'04'             TERMINATING ERROR ENTRY
         MVI   1(R5),TOOMANY
         MVC   2(2,R5),SEMCNT
         LA    R5,4(,R5)
         ST    R5,NEXTERR
         B     LOMEGA3
*
MOVEP    LR    R5,R3                   FIELD OF ONE BYTE
         SR    R5,R9
         BNZ   MOVE
         LTR   R7,R7                   POINT FOLLOWED BY ZERO ?
         BMR   R15                     YES, NO SYNTAX ERROR
         LA    R5,NUMBER(R7)           ADDR IMPLIED POINT
         CR    R5,R8                   POINT TERMINATE NUMBER
         BE    QTORLT1                 YES
*
MOVE     SR    R1,R9                   LENGTH OF MOVE
         LR    R5,R8                   CALCULATE END ADDR
         AR    R5,R1
         CR    R5,R0                   FULL MOVE POSSIBLE ?
         BH    MOVE1                   NO
         EX    R1,MOVEEX               MOVE
         LR    R8,R5                   STEP PTR
         BR    R15                     RETURN
*
MOVE1    LR    R5,R0                   CALCULATE LEN OF POSSIBLE MOVE
         SR    R5,R8
         EX    R5,MOVEEX
         LR    R8,R0
         BR    R15                     RETURN
*
MOVEEX   MVC   0(0,R8),0(R9)
*
CHECK    CLI   IOBYTE,WRITEM           INITIALIZED WRITE OPERATION
         BNER  R5                      NO, RETURN
         STM   R14,R2,REGSAVE          SAVE REGS
*
         CHECK TWRITE                  CHECK LAST WRITE
*
         MVI   IOBYTE,WRITEC           SET WRITE CHECK MASK
         LM    R14,R2,REGSAVE          RESTORE REGS
         BR    R5
*
WRITE    STM   R14,R2,REGSAVE
         CLI   IOBYTE,READC            WHICH I/O STATUS ?
         BL    WRITE2                  CHECKED WRITE OPERATION
         BE    WRITE1                  CHECKED READ OPERATION
*
         CHECK RITAB                   INITIALIZED READ OPERATION
*
WRITE1   L     R1,AUT3DCB              R1 -> SYSUT3 DCB
*
         NOTE  (1)                     SAVE ID OF LAST BLOCK
*
         ST    R1,NOTER
         L     R1,AUT3DCB              R1 -> SYSUT3 DCB
         MVI   NOTEW+3,X'01'           ADDR NEXT OUTPUT BLOCK
*
         POINT (1),NOTEW
*
WRITE2   EQU   *
         L     R0,AUT3DCB              R0 -> SYSUT3 DCB
         LA    R6,4(,R6)               ADD KEY LENGTH
*
         WRITE TWRITE,SF,(R0),(R5),(R6)
*
         MVI   IOBYTE,WRITEM           SET WRITE MASK
         LM    R14,R2,REGSAVE
         BR    R15
*
TABOFLO  L     R5,PFA                  ADDR OF LAST CRIDTAB ENTRY
TABOFLO1 SR    R6,R6
         IC    R6,0(,R5)               FOR STATEMENT NUMBER
         LA    R6,FSTAB(R6)            ADDR FOR STATEMENT ENTRY
         OI    0(R6),NOSUOP
         SH    R5,KH9
         C     R5,PFANO                END OF CRIDTAB ?
         BNH   TABOFLO1                NO
         MVI   ZLVOV,X'FF'             SET ERROR SWITCH
         MVC   ZARSPO(4),ZARNO         SKIP ALL ARIDSTAB ENTRIES
         ST    R3,ZBEGERR              ERROR EDITING
         ST    R3,ZENDERR
         MVC   ZERRONU,TABOVER
         BR    R15
*
DIGIT19  LA    R8,NUMBER
         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1
         SR    R7,R7
         LR    R9,R3                   SET FIELD START
         MVI   SCATEST,0
DIG191   LA    R1,1(,R3)               TRT START
DIG192   SR    R2,R2
DIG193   TRT   0(256,R1),DIG19
         BZ    DIGL19                  MORE THAN 256 BYTES
         LR    R3,R1                   UPDATE R3
         B     *(R2)                   BRANCH TABLE
         B     DECPTM                  +04
         B     SCAFACTM                +08
         B     QTORLT                  +12
         B     ZETAM                   +16
         B     RHO                     +20
         B     OTHER                   +24
*
DECPTM   BAL   R15,MOVE
         AR    R7,R1                   EXPONENT CORRECTION
         B     DECPOIN1
*
SCAFACTM BAL   R15,MOVE
         AR    R7,R1                   EXPONENT CORRECTION
         B     SCA1
*
QTORLT   BAL   R15,MOVE
         AR    R7,R1                   NUMBER OF INTEGERS
QTORLT1  ST    R7,ZEXCORR
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,INVOP
         B     INCOROP
*
ZETAM    BAL   R15,MOVE
         AR    R7,R1                   EXPONENT CORRECTION
         BAL   R15,ICHA
         LR    R1,R3
         LR    R9,R3
         B     DIG192
*
OTHER    C     R8,NSTART               BUFFER EXCHANGE WITHIN INTEGER ?
         BNE   OTHER1                  YES
         LR    R7,R3                   COMPUTE NUMBER OF DIGITS
         SR    R7,R9
         B     INTCON
*
OTHER1   BAL   R15,MOVE
         AR    R7,R1                   GET NUMBER OF DIGITS
         LR    R1,R8                   ADJUST POINTERS
         LA    R9,NUMBER
         B     INTCON
*
DIGL19   LA    R1,256(,R1)             UPDATE INPUT PTR
         B     DIG193
*
DIGIT0   LA    R8,NUMBER
         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1
         SR    R7,R7
         MVI   SCATEST,0
         LA    R1,1(,R3)
DIG01    SR    R2,R2
DIG02    TRT   0(256,R1),DIG0
         BZ    DIGL0                   MORE THAN 256 BYTES
         LR    R3,R1
         LR    R9,R3
         B     *(R2)
         B     DIG191                  +04
         B     QTORLT                  +08
         B     DECPOIN1                +12
         B     SCA0                    +16
         B     ZETA0                   +20
         B     RHO                     +24
         B     OTHOP0                  +28
*
SCA0     LD    0,ZEROFLOA              FLOATING ZERO
         B     SCA1
*
ZETA0    BAL   R15,ICHA                CHANGE INPUT BUFFER
         LR    R1,R3
         B     DIG01
*
OTHOP0   C     R4,ZFILE5               OUTPUT BUFFER FULL ?
         BNH   OTHOP01                 NO
         BAL   R15,OUCHA               YES
OTHOP01  MVC   3(3,R4),ZERO            ADDR PART OF INTERNAL NAME
         MVC   1(2,R4),ZINTYP          INDICATE INTEGER
         LA    R4,5(,R4)
         B     GENTEST
*
DIGL0    LA    R1,256(,R1)             UPDATE INPUT PTR
         B     DIG02
*
DECPOIN  LA    R8,NUMBER
         LA    R0,NUMBER+19            MAX LENGTH OF CONSTANT + 1
         SR    R7,R7
         MVI   SCATEST,0
DECPOIN1 LA    R9,1(,R3)
DECPOIN2 LA    R1,1(,R3)
DECPOIN3 SR    R2,R2
DECPOIN4 TRT   0(256,R1),DECPO
         BZ    DECPOINL                MORE THAN 256 BYTES
         LR    R3,R1
         B     *(R2)
         B     DECP0                   +04 ZERO
         B     QTORLTP                 +08
         B     DECPSCA                 +12 SCALE FACTOR
         B     DECPZETA                +16 ZETA
         B     DECPOT                  +20 OTHER OPERATOR
*
DECP0    CR    R9,R3                   ZERO FOLLOWING POINT ?
         BNE   DECPOIN2                NO
         C     R8,NSTART               PRECEEDING SIGNIFICANT DIGIT ?
         BNE   DECPOIN2                YES
         BCTR  R7,0                    NO, DECREASE EXPONENT
         B     DECPOIN1
*
QTORLTP  BAL   R15,MOVE
         B     QTORLT1
*
DECPSCA  BAL   R15,MOVEP               SYNTAX CHECK AND MOVE
         C     R8,NSTART               ZERO ?
         BNE   SCA1                    NO
         LD    0,ZEROFLOA              YES, FLOATING ZERO
         B     SCA1
*
DECPZETA BAL   R15,MOVE
         BAL   R15,ICHA
         LR    R9,R3
         LR    R1,R3
         B     DECPOIN3
*
DECPOT   ST    R7,ZEXCORR
         BAL   R15,MOVEP               SYNTAX CHECK AND MOVE
         C     R8,NSTART               ZERO ?
         BNE   REALCON                 NO, CONVERT NUMBER
         LD    0,ZEROFLOA              YES, NUMBER IS FLOATING ZERO
         B     REALHAN                 MAKE A CONSTANT POOL ENTRY
*
DECPOINL LA    R1,256(,R1)             UPDATE INPUT PTR
         B     DECPOIN4
*
SCAFACT  SR    R7,R7
         LD    0,ZONEFLOA              MANTISSA SET TO ONE
         LA    R8,NUMBER               NO MANTISSA DIGIT
SCA1     ST    R8,ZTO
         ST    R7,ZEXCORR
         LA    R8,SCAWORK
         LA    R0,SCAWORK+9
         MVI   SCATEST,X'10'           SCALE FACTOR PRESENT
         MVI   SCALE,0                 CLEAR OLD SIGN
SCA20    LA    R9,1(,R3)
SCA2     LA    R1,1(,R3)
SCA3     SR    R2,R2
SCA4     TRT   0(256,R1),SCAFAC
         BZ    SCAL                    MORE THAN 256 BYTES
         LR    R3,R1
         B     *(R2)
         B     SCA19                   +04
         B     SCAZERO                 +08
         B     SCASIGN                 +12
         B     SCAQL                   +16
         B     SCAZETA                 +20
         B     SCAOT                   +24
*
SCA19    OI    SCATEST,SF19            SIGNIFICANT DIGIT PRESENT
         B     SCA2
*
SCAZERO  TM    SCATEST,SF19            ANY SIGNIFICANT DIGIT ?
         BO    SCA2                    YES
         OI    SCATEST,SFL0            LEADING ZERO
         B     SCA20
*
SCASIGN  EQU   *
         TM    SCATEST,SFLSIGN         LEADING SIGN ?
         BNZ   SCAOT                   NO, TREAT AS OTHER OPERATOR
         MVC   SCALE(1),0(R3)          SAVE SIGN
         OI    SCATEST,SFSIGN          SIGNED SCALE FACTOR
         B     SCA20
*
SCAZETA  BAL   R15,MOVE                SAVE FIELD
         BAL   R15,ICHA
         LR    R1,R3
         LR    R9,R3
         B     SCA3
*
SCAOT    TM    SCATEST,SFDIGIT         ANY DIGIT ?
         BZ    SCAQL                   NO, ERROR MESSAGE
         TM    SCATEST,SF19            ANY SIGNIFICANT DIGIT ?
         BZ    SCAOT1                  NO
         BAL   R15,MOVE
         S     R8,SCAWORKA
         EX    R8,SCAPACK
         MVN   ZPACK+7(1),SREF         SET SIGN TO PLUS
         CLI   SCALE,XFMINUS           MINUS SIGN ?
         BNE   *+10                    NO
         MVN   ZPACK+7(1),SREF+1       YES, REPLACE PLUS SIGN
         CVB   R5,ZPACK                CONVERT
         AR    R7,R5                   GET EXPONENT
*
SCAOT1   ST    R8,ZTOSCA
         L     R8,ZTO
         B     REALCON
*
SCAPACK  PACK  ZPACK(8),SCAWORK(0)
*
SCAQL    BAL   R15,MOVE
         S     R8,SCAWORKA             SCALE FACTOR LENGTH
         ST    R8,ZTOSCA
         L     R8,ZTO
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,INVOP
         B     INCOROP
*
SCAL     LA    R1,256(,R1)             UPDATE INPUT PTR
         B     SCA4
*
*        CONSTANT ERROR ROUTINE
*
CERR     TM    SCATEST,PRECERR         CONSTANT ALREADY REBUILT ?
         BOR   R2                      YES
         L     R5,ZEXCORR              NUMBER OF INTEGERS IN MANTISSA
         LTR   R5,R5                   LEADING ZEROS AFTER POINT ?
         BM    CERR1                   YES
         CH    R5,KH12                 CONSTANT TOO LONG ?
         BNH   CERRA                   NO
         LH    R5,KH12                 SET MAXIMAL LENGTH
CERRA    EX    R5,CERREX               MOVE CONSTANT INTEGERS
         A     R5,OPSTART              ADDR DECIMAL POINT
         MVI   0(R5),XFDECPT           INSERT POINT
         BCTR  R8,0
         CR    R8,R5                   ANY DECIMAL POINT ?
         BE    *+8                     NO
         LA    R8,1(,R8)               PREVENT POINT OVERLAY
         B     CERR2
*
CERR1    MVI   ZIDEX,XFDECPT           INSERT POINT
CERR2    TM    SCATEST,SF              SCALE FACTOR PRESENT ?
         BZ    CERR3                   NO
         LA    R0,NUMBER+21
         MVC   0(2,R8),SCALEQ          INSERT QUOTE AND SIGN
         TM    SCATEST,SFSIGN          SIGNED SCALE FACTOR ?
         BO    *+6                     YES
         BCTR  R8,0
         LA    R8,2(,R8)
         L     R1,ZTOSCA
         LA    R1,1(,R1)               SCALE FACTOR LENGTH
         LA    R9,SCAWORK
         AR    R1,R9                   SCALE FACTOR END ADDR
         BAL   R15,MOVE                MOVE SCALE FACTOR
*
CERR3    LA    R5,ZIDEX+12
         CR    R8,R5                   MORE THAN 12 CHARACTERS ?
         BNH   *+6                     NO
         LR    R8,R5                   YES, SET LENGTH TO 12
         ST    R8,ZENDERR
         MVC   ZBEGERR,OPSTART
         BR    R2
*
CERREX   MVC   ZIDEX(0),NUMBER
*
INTCON   CH    R7,KH10                 NUMBER OF DIGITS ?
         BL    INTCON1                 NO
         BH    INTCON2                 YES, REAL CONSTANT
         CLC   0(10,R9),MAXINT         MAXIMAL INTEGER
         BH    INTCON2                 GREATER, REAL CONSTANT
INTCON1  BCTR  R7,0
         EX    R7,INTPACK              PACK
         MVN   ZPACK+7(1),SREF         SET PLUS SIGN
         CVB   R2,ZPACK                PACK
         B     INTHAN
*
INTCON2  ST    R9,ZBEGERR              GIVE ERROR MESSAGE
         ST    R1,ZENDERR
         MVC   ZERRONU,RANGEINT
         BAL   R15,MOVERRO
         ST    R7,ZEXCORR
         L     R8,NSTART
         BAL   R15,MOVE
         B     REALCON
*
INTPACK  PACK  ZPACK(8),0(0,R9)        LENGTH IN R1
*
REALCON  LR    R6,R8                   GET LENGTH OF CONSTANT
         S     R6,NSTART
         BZ    REALCON7
*
*        CONVERT MANTISSA TO FLOATING FORM
*
         LD    0,ZEROFLOA              ZERO REG
         LR    R9,R6                   NUMBER OF DIGITS
         SR    R7,R9                   UPDATE EXPONENT CORRECTION
         CH    R9,KH9                  CONVERSION IN ONE STEP ?
         BH    REALCON1                NO
         BCTR  R9,0
         EX    R9,REPACK               PACK
REALCON2 MVN   ZPACK+7(1),SREF         SET PLUS SIGN
         CVB   R5,ZPACK                CONVERT TO BINARY
         ST    R5,ZFLOFIEL+4           CONVERT TO FLOATING FORM
         AD    0,ZFLOFIEL              GET NORMALIZED FLOATING NUMBER
         C     R6,NREAL                MORE DIGITS THAN ALLOWED ?
         BNH   REALCON3                NO
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,PRECREAL
         BAL   R15,MOVERRO
         OI    SCATEST,PRECERR         INDICATE PRECISION ERROR
         B     REALCON3
*
*        CONVERT EXPONENT TO FLOATING FORM
*
REALCON7 LTDR  0,0
         BZ    REALHAN                 NUMBER OF DIGITS
REALCON3 LPR   R9,R7                   UPDATE EXPONENT CORRECTION
         BZ    REALHAN                 CONVERSION IN ONE STEP ?
         LR    R1,R9                   NO
         LA    R2,ZEXTABP-8
         LTR   R7,R7                   PACK
         BP    REALCON6                SET PLUS SIGN
         LA    R2,ZEXTABN-8            CONVERT TO BINARY
REALCON6 CH    R9,KH64                 CONVERT TO FLOATING FORM
         BNL   REALCON5                GET NORMALIZED FLOATING NUMBER
         N     R9,SCALEMSK
         BZ    REALCON8                MORE DIGITS THAN ALLOWED ?
         MD    0,56(R9,R2)             NO
REALCON8 SLA   R1,3
         N     R1,SCALEMSK
         BZ    REALCON9                INDICATE PRECISION ERROR
         MD    0,0(R1,R2)
REALCON9 LTDR  0,0                     EXPONENT UNDERFLOW
         BZ    REALERR1
         B     REALHAN
*
REALCON5 MD    0,120(,R2)              10 ** +- 64
         LTDR  0,0
         BZ    REALERR1
         SH    R9,KH64                 ADJUST EXPONENT
         B     REALCON6
*
REALCON1 SH    R9,KH10
         CH    R9,KH9                  CONSTANT TOO LONG ?
         BL    REALCONA                NO
         BCTR  R9,0                    YES, SKIP THE NINETEENTH DIGIT
         AH    R7,KH1                  UPDATE R7
REALCONA EX    R9,REPACK               PACK FIRST PART
         MVN   ZPACK+7(1),SREF         SET PLUS SIGN
         CVB   R5,ZPACK                CONVERT TO BINARY
         ST    R5,ZFLOFIEL+4           CONVERT TO FLOATING FORM
         AD    0,ZFLOFIEL              NORMALIZE
         MD    0,ZTEN9                 MULTIPLY BY 10 ** 9
         LA    R9,NUMBER+1(R9)         ADDR SECOND PART
         PACK  ZPACK(8),0(9,R9)        PACK SECOND PART
         B     REALCON2                TERMINATE CONVERSION
*
REPACK   PACK  ZPACK(8),NUMBER(0)      LENGTH OF NUMBER IN R9
*
REALERR  LA    R5,REALHAN              SET EXIT ADDR
         ST    R5,ZSTO
         MVC   9(3,R1),ZSTO+1          MODIFIED OLD PSW IN PIE
         BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,RANGEREA
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         BR    R14
*
REALERR1 BAL   R2,CERR                 REBUILD CONSTANT
         MVC   ZERRONU,RANGEREA
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     REALHAN
*
*        INTEGER HANDLING
*
INTHAN   C     R4,ZFILE5               SPACE ENOUGH IN OUTPUT BUFFER ?
         BNH   INTHANA                 YES
         BAL   R15,OUCHA               NO, CHANGE BUFFER
INTHANA  MVC   1(2,R4),ZINTYP          FIRST TWO BYTES OF INTERNAL NAME
INTHANR  CH    R2,KH15                 NUMBER GREATER THAN 15 ?
         BH    INTHAN2                 YES
         SLA   R2,2                    NO, MULTIPLY BY 4
         STH   R2,ZLIRE
         MVI   3(R4),0                 OUTPUT
         MVC   4(2,R4),ZLIRE           FIELD
         LA    R4,5(,R4)               UPDATE OUTPUT POINTER
         B     GENTEST                 RETURN
*
INTHAN2  TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    INTHAN1                 YES
         LA    R14,INTHAN6             INITIALIZE INTEGER SEARCH
         LA    R8,4
         L     R9,ZWP
         L     R7,ZDWP
         L     R1,ZLITSTA
         SR    R1,R8
         SR    R9,R8
INTHAN6  BXH   R1,R8,INTHAN3           EXIT FOR END OF SEARCH
         C     R2,0(,R1)               INTEGER FOUND ?
         BNER  R14                     NO, PROCEED SEARCH
*
INTHAN1  S     R1,ZKOPOOL              GET REL ADDR
         STH   R1,ZLIRE                IN CONST POOL
         MVC   3(1,R4),KBN+1           INSERT CONSTANT BLOCK NUMBER
         MVC   4(2,R4),ZLIRE           DISPLACEMENT ADDR
         LA    R4,5(,R4)
         B     GENTEST
*
INTHAN3  AR    R9,R8
         CR    R9,R7                   DOUBLE WORD BOUNDARY ?
         BE    INTHAN9                 YES
*
INTHAN4  LA    R1,4(,R1)               SCAN REST OF CONSTANT POOL
         CR    R1,R7                   CURRENT END OF CONSTANT POOL ?
         BE    INTHAN10                YES
         C     R2,0(,R1)               LITERAL FOUND ?
         BNE   INTHAN4                 NO
         BE    INTHAN1
*
INTHAN10 LR    R1,R9
         LR    R9,R7
INTHAN7  ST    R9,ZWP                  SAVE PTR
         ST    R2,0(,R1)               MAKE LITERAL POOL ENTRY
         B     INTHAN1
*
INTHAN9  C     R9,ZKOPEND              END OF LITERAL POOL ?
         BNL   INTHAN8
         C     R9,ZTEXTCO              WRITE TXT CARD ?
         BL    INTHAN5                 NO
         BAL   R14,TXTTRAF             WRITE
INTHAN5  LA    R9,4(,R9)               UPDATE POINTERS
         A     R7,LREAL
         ST    R7,ZDWP                 SAVE UPDATE ZDWP
         B     INTHAN7
*
INTHAN8  CLC   ZKBNMAX(2),KH255        LAST CONST POOL
         BE    INTHAN11                YES, GIVE ERROR MESSAGE
         L     R9,ZDWP
         BAL   R14,TXTTRAF             OUTPUT TXT RECORD
         BAL   R14,CPOLEX              CONSTANT POOL EXCHANGE
         L     R1,ZKOPOOL              START ADDR OF CONSTANT POOL
         LA    R9,4(,R1)               UPDATE POINTERS
         LR    R7,R1
         A     R7,LREAL
         ST    R9,ZWP
         ST    R7,ZDWP
         ST    R1,ZLITSTA
         ST    R2,0(,R1)
         B     INTHAN1
*
INTHAN11 ST    R1,ZBEGERR              GIVE
         ST    R1,ZENDERR              ERROR
         MVC   ZERRONU,MANYCON
         BAL   R15,MOVERRO             GOTO ERROR RTN
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     INTHAN1
*
REALHAN  C     R4,ZFILE5               SPACE ENOUGH IN OUTPUT BUFFER ?
         BNH   REALHANA                YES
         BAL   R15,OUCHA               NO, CHANGE BUFFER
REALHANA MVC   1(2,R4),ZREALTYP        FIRST TWO BYTES OF INTERNAL NAME
         CLI   ZFORTEST,0              IN FOR LIST ?
         BE    REALHAN1                NO
         L     R5,ZFSPTR               ADDR FSTAB ENTRY
         OI    0(R5),NOCOUNT           CLASSIFY AS NO COUNTING LOOP
REALHAN1 TM    COMPFLGS,LNG            LONG PRECISION ?
         BO    REALH                   YES, BRANCH
         STE   0,ZSTO                  START ROUNDING
         MVC   ROUND(1),ZSTO
         AD    0,ROUND                 ROUND
         STE   0,ZSTO                  SHORT, TREAT AS INTEGER
         L     R2,ZSTO
         B     INTHANR
*
REALH    L     R1,ZLITSTA              INITIALIZE LITERAL SEARCH
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    INTHAN1                 YES
         LA    R6,8
         LR    R8,R6
         SR    R1,R6
         L     R9,ZWP
         L     R7,ZDWP
         CR    R9,R7
         BE    REALH2
         SR    R7,R6
         LA    R14,REALH3
REALH3   BXH   R1,R8,REALH4            EXIT AT END OF SEARCH
         CD    0,0(,R1)                LITERAL FOUND ?
         BNER  R14                     NO
*
REALH4   LA    R14,REALH5
         SR    R1,R6
REALH5   BXH   R1,R6,REALH6            EXIT AT END OF SCAN
         CD    0,0(,R1)                CONSTANT FOUND ?
         BNER  R14                     NO
         B     INTHAN1                 YES
*
REALH6   AR    R7,R6
         C     R7,ZKOPEND              END OF LITERAL POOL ?
         BNL   REALH10                 YES
REALH8   AR    R7,R6                   UPDATE ZDWP
         ST    R7,ZDWP
         STD   0,0(,R1)
         B     INTHAN1
*
REALH7   BAL   R14,TXTTRAF             OUTPUT TXT
REALH9   AR    R8,R7                   UPDATE ZWP
         ST    R8,ZWP
         B     REALH8
*
REALH2   LA    R14,REALH21
         SR    R7,R6
REALH21  BXH   R1,R6,REALH22           EXIT AT END OF SCAN
         CD    0,0(,R1)                LITERAL FOUND ?
         BNER  R14                     NO
         B     INTHAN1                 YES
*
REALH22  AR    R7,R6
         C     R7,ZKOPEND              END OF LITERAL POOL
         BNL   REALH10
         C     R7,ZTEXTCO              TXT TO BE PUT OUT ?
         BL    REALH9                  NO
         B     REALH7                  YES
*
REALH10  CLC   ZKBNMAX(2),KH255        LAST CONSTANT POOL ?
         BE    REALH11                 YES
         L     R9,ZDWP
         BAL   R14,TXTTRAF             OUTPUT TXT
         BAL   R14,CPOLEX              CONSTANT POOL EXCHANGE
         L     R1,ZKOPOOL              START ADDR OF CONSTANT POOL
         LA    R7,8(,R1)               UPDATE PTRS
         ST    R7,ZDWP
         ST    R7,ZWP
         ST    R1,ZLITSTA
         STD   0,0(,R1)                LITERAL ENTRY
         B     INTHAN1
*
REALH11  ST    R3,ZBEGERR              TOO MANY LITERALS, MESSAGE
         ST    R3,ZENDERR
         MVC   ZERRONU,MANYCON
         BAL   R15,MOVERRO
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         B     INTHAN1
*
*        CONSTANT POOL EXCHANGE
*
CPOLEX   L     R15,ZKOPOOL             UPDATE
         ST    R15,ZLITSTA
         AH    R15,TXTPUT
         ST    R15,ZTEXTCO             TXT RECORD POINTER
         LH    R15,ZKBNMAX
         LA    R15,1(,R15)
         STH   R15,ZKBNMAX             CONSTANT POOL
         STH   R15,KBN                 NUMBER
         BR    R14                     RETURN
*
*        TRANSFER TXT RECORD
*
TXTTRAF  STM   R14,R6,TXTSAV           SAVE REGS
         L     R2,ZTEXTCO
         SH    R2,TXTPUT               ADDR OUTPUT TXT
         LR    R5,R9                   CALCULATE LENGTH OF TXT
         SR    R5,R2
         STH   R5,TXTLE
         LR    R5,R9                   GET NEW PUT ADDR
         AH    R5,TXTPUT
         ST    R5,ZTEXTCO
         L     R6,PRPT                 LOAD PROGRAM PTR
         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK ?
         BO    TXTLE2                  YES, BRANCH
         BAL   R14,GENTXT              OUTPUT OF TEXT
TXTLE    DC    H'0'                    INSERT LENGTH OF TEXT
TXTLE1   ST    R6,PRPT                 STORE PROGRAM PTR
         LM    R14,R6,TXTSAV           RESTORE REGS
         BR    R14                     RETURN
*
TXTLE2   AR    R6,R5                   UPDATE PROGRAM PTR
         B     TXTLE1
*
*        GENERATE TXT RECORDS
*
GENTXT   LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         LA    R3,TXTT                 INDICATE TXT CALL
         L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL IOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0 = LENGTH OF DATA IN REC
         SR    R15,R0                  R15 = EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUGH SPACE LEFT ?
         BL    GEN6A                   NO
         LR    R15,R14                 YES, R15 = LENGTH FROM CALL
GEN6A    AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     GEN8                    GOTO MOVE TEXT
*
GEN4     LTR   R14,R14                 MORE INFORMATION TO BE MOVED ?
         BZR   R4                      NO, RETURN TO CALLING ROUTINE
*
*        OUTPUT NEW RECORD
*
GEN3     ST    R14,SAVELT              SAVE LENGTH
         TM    COMPFLGS+1,NLOAD+NDECK  BOTH DECK AND LOAD SPECIFIED ?
         BZ    BOTH                    YES, BRANCH
         TM    COMPFLGS+1,NDECK        ONLY DECK ?
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB
         BZ    PUT1                    YES
PUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH
*
         ST    R1,SAVOUTA              IF ONLY SYSPUNCH SPECIFIED
         L     R14,SAVELT              RESTORE LENGTH
         B     PUNCHOUT
*
SAVELT   DC    F'0'                    SAVE AREA FOR LENGTH
BOTH     L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
         L     R1,APCHDCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT1A                   GOTO PUT SYSLIN
*
PUNCHOUT EQU   *
         MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             STEP SEQUENCE NUMBER
         UNPK  76(4,R1),CARDCNT        UNPACK INTO RECORD
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID+R AND P
         ST    R6,4(0,R1)
         MVI   4(R1),C' '
         B     GEN6
*
*        TXT RECORD
*
TXTT     DC    X'02'                   CARD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        TXT MOVE ROUTINE
*
GEN8     BCTR  R15,0                   DECR R15
         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE
         MVC   16(0,R1),0(R2)          MOVE DATA TO OUT AREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    OUT OF MOVE TXT ROUTINE
*
*        AREAS AND CONSTANTS LOCAL FOR GENTXT
*
TXTSAV   DC    9F'0'                   REGISTER SAVE AREA
KP1      DC    PL1'1'                  CARD COUNT INCREMENT
*
INTERUPT CLI   7(R1),X'0C'             FLOATING POINT OVERFLOW ?
         BE    REALERR                 YES
         L     R5,OLDSPIE              NO, USE DIRECTORY ROUTINE
         L     R15,0(,R5)              ADDR ERROR ROUTINE OF DIREC
         BR    R15                     ENTER ERROR ROUTINE
*
ZERO     DC    3H'0'
KH1      DC    H'1'
KH5      DC    H'5'
KH7      DC    H'7'
KH8      DC    H'8'
KH9      DC    H'9'
KH10     DC    H'10'
KH11     DC    H'11'
KH12     DC    H'12'
KH15     DC    H'15'
KH18     DC    H'18'
KH56     DC    H'56'
KH64     DC    H'64'
KH255    DC    H'255'
KH1792   DC    H'1792'
KH4096   DC    H'4096'
*
*        ERROR MESSAGE NUMBERS
*
INVOP    DC    H'80'                   SYNTAX ERROR IN OPERAND
UNDEFOP  DC    H'81'                   UNDEFINED IDENTIFIER
RANGEREA DC    H'82'                   REAL CONSTANT OUT OF RANGE
RANGEINT DC    H'83'                   INTEGER OUT OF RANGE
PRECREAL DC    H'84'                   PRECISION OF REAL TOO GREAT
GOTOFOR  DC    H'85'                   GO TO INTO FOR STATEMENT
MANYCON  DC    H'86'                   TOO MANY CONSTANTS
TABOVER  DC    H'87'                   OPTIMIZATION TABLE OVERFLOW
ARRAYERR DC    H'88'                   INVALID ARRAY LIST IDENTIFIER
SWITCHER DC    H'89'                   SWITCH DECLARATION ERROR
ITABOVER DC    H'213'                  ITAB OVERFLOW
TOOMANY  EQU   212                     TOO MANY ERRORS
TOOLONG  DC    H'215'                  TOO MUCH SOURCE OUTPUT
*
*        SUBSCRIPT TABLE
*
ZSUTAPO  DC    A(0)                    CURRENT SUTAB PT
ZSUDAD   DC    A(0)                    ADDR OF FIRST SUTAB ENTRY
ZSUTMAX  DC    A(0)                    SUTAB END PT
SUSTRT   DC    A(0)                    START ADDR OF SUTAB RECORD
SUKEY    DC    C'SUTB'                 SUTAB RECORD IDENTIFICATION
SULENGTH DC    F'0'                    ACCUMULATED LENGTH OF SUTAB
SUCNT    DC    H'0'                    NUMBER OF WRITTEN SUTAB RECORDS
*
*        LEFT VARIABLE TABLE
*
ZLESTA   DC    A(0)                    ADDR OF FIRST LVTAB ENTRY
ZLEVA    DC    A(0)                    CURRENT LVTAB PT
ZLEMAX   DC    A(0)                    LVTAB END PT
LVSTRT   DC    A(0)                    START ADDR OF LVTAB RECORD
LVKEY    DC    C'LVTB'                 LVTAB RECORD IDENTIFICATION
LVLENGTH DC    F'0'                    ACCUMULATED LENGTH OF LVTAB
LVCNT    DC    H'0'                    NUMBER OF WRITTEN LVTAB RECORDS
*
*        INPUT RECORD
*
ZIBRUN   DC    A(0)                    START OF ACTIVE INPUT BUF
ZIBREAD  DC    A(0)                    START OF NEXT INPUT BUFFER
*
*        OUTPUT RECORD
*
ZOBWORK  DC    A(0)                    START OF ACTIVE OUTPUT BUFFER
ZOBWRITE DC    A(0)                    START OF LAST OUTPUT BUFFER
ZFILE1   DC    A(0)                    OUTPUT RECORD END - 1
ZFILE2   DC    A(0)                    OUTPUT RECORD END - 2
ZFILE3   DC    A(0)                    OUTPUT RECORD END - 3
ZFILE5   DC    A(0)                    OUTPUT RECORD END - 5
ZFILE6   DC    A(0)                    OUTPUT RECORD END - 6
ZFILE9   DC    A(0)                    OUTPUT RECORD END - 9
ZOUTCOT  DC    H'1'                    OUTPUT RECORD NUMBER
*
*        IDENTIFIER TABLE
*
ZIBSTAO  DC    A(0)                    ITAB START ADDR
ZITAN    DC    A(0)                    ADDR OF ITAB ENTRY OF LAST ID
ZCURITEN DC    A(0)                    ADDR OF LAST ITAB ENTRY
ZITREC   DC    A(0)                    START OF NEXT ITAB RECORD
ZITEND   DC    A(0)                    ITAB END ADDR
ZCURITLE DC    H'0'                    LENGTH OF LAST ITAB RECORD
*
*        ERROR MESSAGES
*
ZBEGERR  DC    F'0'                    START OF VARIABLE INFORMATION
ZENDERR  DC    F'0'                    END OF VARIABLE INFORMATION
ZERRONU  DC    H'0'                    ERROR NUMBER
*
*        ARRAY IDENTIFIER STACK
*
ZARMAX   DC    A(ZARSTACK+28)          END ADDR IN ARIDSTACK
ZARNO    DC    A(ZARSTACK-7)           START ADDR OF ARIDSTACK
ZARSPO   DC    A(ZARSTACK-7)           CURRENT POINT IN ARIDSTACK
ZPOSIX   DC    H'0'                    COMPONENT NUMBER IN ARRAY
ZARSTACK DC    XL35'00'                ARIDSTACK
*
*        SUBSCRIPT TEST ROUTIN2
*
SUBEND   DC    A(0)                    SUBSCRIPT END ADDR
ADDEND   DC    3H'0'                   SAVE AREA FOR ADDEND
FACTOR   DC    3H'0'                   SAVE AREA FOR FACTOR
ZEROELEM DC    XL6'00C801000000'       INTERNAL CODE FOR +0
ONEELEM  DC    XL6'00C801000004'       INTERNAL CODE FOR +1
ZBRACK   DC    A(0)                    SUBSCRIPT START ADDR - 1
*
ZSTO     DC    F'0'                    TEMPORARY STORAGE
ZSTO1    DC    X'0670'
ZSTO2    DC    X'0240'
ZIGN     DC    H'0'                    CURRENT IDENTIFIER GROUP NUMBER
ZPOINT   DC    6AL1(XFDECPT)
ZALLPUP  DC    X'91FF010000'           ALL PURPOSE IDENTIFIER
ZALLPU   EQU   ZALLPUP-6
ZIDEX    DC    37X'00'                 WORKAREA
NUMBER   EQU   ZIDEX+1
OPSTART  DC    A(ZIDEX)
*
BRCNT    DC    H'0'                    BRACKET COUNTER IN ARRAY DECL
STATUS   DC    X'00'                   STATUS BYTE
CURPBN   DC    C' '                    PBN OF LAST BLOCK
ZCLOBRA  DC    X'00'                   SUBSCRIPT TEST BYTE
ZFORTEST DC    X'00'                   FOR STATEMENT TEST BYTE
ZLVOV    DC    X'00'                   SET X'FF' IF NO MORE SUBSC OPT
ZFSN     DC    C' '                    CURRENT FOR STATEMENT NUMBER
FSNEMBR  DC    C' '                    NUMBER OR EMBRACING BLOCK
IOBYTE   DC    C' '                    STATUS BYTE FOR SYSUT3
NOTEW    DC    F'0'                    ID OF LAST WRITTEN RECORD
NOTER    DC    F'0'                    ID OF LAST READ ITAB RECORD
*
*        CRITICAL VARIABLE TABLE
*
PFA      DC    A(0)                    CURRENT CRIDTAB PT
PFANO    DC    A(0)                    START ADDR OF CRIDTAB
PFAMAX   DC    A(0)                    END ADDR OF CRIDTAB
ZFSPTR   DC    A(0)                    POINT TO CURRENT FSTAB ENTRY
ZFOCRI   DC    A(0)
*
*        CONSTANT POOL
*
ZKOPOOL  DC    A(0)                    START ADDR OF POOL
ZKOPEND  DC    A(0)                    END ADDR OF POOL
ZLITSTA  DC    A(0)                    START ADDR OF USED PART
ZTEXTCO  DC    A(0)                    END ADDR OF TXT PIECE
ZKBNMAX  DC    H'0'                    NUMBER OF NEXT POOL
TXTPUT   DC    H'56'                   LENGTH OF TXT PIECE
*
ZPACK    DC    D'0'                    WORKAREA TO PACK NUMBERS
ZEROFLOA DC    D'0.0'
ZONEFLOA DC    D'1.0'
ZTEN9    DC    D'1.0E+9'
ZFLOFIEL DC    X'4E00000000000000'     WORKAREA FOR FLOATING CONVERS
ROUND    DC    X'0000000080000000'     USED TO ROUND SHORT FORM REAL
ZWP      DC    A(0)                    WORD POINTT IN CONSTANT POOL
ZDWP     DC    A(0)                    DOUBLE WORD PT IN CONSTANT POOL
NSTART   DC    A(NUMBER)               PTR TO NUMBER
SCALEMSK DC    XL4'38'
LREAL    DC    F'8'                    SHORT PREC 4, LONG PREC 8
NREAL    DC    F'18'                   SHORT PREC 7, LONG PREC 18
ZLIRE    DC    H'0'
ZINTYP   DC    X'C801'                 ID OF INTEGER CONSTANT
ZREALTYP DC    X'C802'                 ID OF REAL CONSTANT
SREF     DC    P'+1'                   PLUS
         DC    P'-1'                   MINUS, MUST FOLLOW SREF
SCATEST  DC    C' '                    SCALE FACTOR TEST BYTE
SCALEQ   DC    AL1(XFQUOTE),X'00'
SCALE    EQU   SCALEQ+1
MAXINT   IEXCGEN DC,'2147483647'       MAX INTEGER IN INTERNAL CODE
SCAWORK  DC    10X'00'                 STORE FOR SCALE FACTOR
ZTO      DC    F'0'
ZEXCORR  DC    F'0'
ZTOSCA   DC    F'0'
SCAWORKA DC    A(SCAWORK+1)
*
OLDSPIE  DC    A(0)                    ADDR OF OLD PICA
TABSIZE  DC    F'0'                    ACCUMULATED SIZE OF TABLES
REGSAVE  DC    5F'0'                   SAVEAREA FOR REGISTERS
SPECUSE  DC    XL4'06'
ALIGN    DC    F'0'                    FULL WORD ALIGNMENT
ALIGNH   EQU   ALIGN+2                 HALF WORD ALIGNMENT
*
ZEXTABP  DC    D'1.0E+1'
         DC    D'1.0E+2'
         DC    D'1.0E+3'
         DC    D'1.0E+4'
         DC    D'1.0E+5'
         DC    D'1.0E+6'
         DC    D'1.0E+7'
         DC    D'1.0E+8'
         DC    D'1.0E+16'
         DC    D'1.0E+24'
         DC    D'1.0E+32'
         DC    D'1.0E+40'
         DC    D'1.0E+48'
         DC    D'1.0E+56'
         DC    D'1.0E+64'
*
ZEXTABN  DC    D'1.0E-1'
         DC    D'1.0E-2'
         DC    D'1.0E-3'
         DC    D'1.0E-4'
         DC    D'1.0E-5'
         DC    D'1.0E-6'
         DC    D'1.0E-7'
         DC    D'1.0E-8'
         DC    D'1.0E-16'
         DC    D'1.0E-24'
         DC    D'1.0E-32'
         DC    D'1.0E-40'
         DC    D'1.0E-48'
         DC    D'1.0E-56'
         DC    D'1.0E-64'
*
GENER    DC    X'5454546854685454'
         DC    X'3C606438541C2020'
         DC    8X'54'
         DC    X'245C543430'
         DC    8X'54'
         DC    X'4054544438282C545018480C'
         DC    9X'08'
         DC    X'00004C581014'
         DC    30X'04'
*
IDENTI   DC    45X'10'
         DC    X'000C04'
         DC    13X'00'
         DC    X'080C0C'
         DC    30X'00'
*
DIG19    DC    45X'18'
         DC    X'000C10'
         DC    13X'00'
         DC    X'140408'
         DC    30X'0C'
*
DIG0     DC    45X'1C'
         DC    X'00081400'
         DC    9X'04'
         DC    X'000000180C10'
         DC    30X'08'
*
DECPO    DC    45X'14'
         DC    X'00081004'
         DC    13X'00'
         DC    X'080C'
         DC    30X'08'
*
SCAFAC   DC    X'0C0C'
         DC    43X'18'
         DC    X'00101408'
         DC    9X'04'
         DC    4X'00'
         DC    32X'10'
*
*        ITAB ENTRIES FOR STANDARD PROCEDURES
*
FIXITAB  DC    X'013F0000002B'         HEADER FOR PBN O
         DC    X'0000',X'000000'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ABS'              ABS
         ORG
         DC    X'8882',X'002080'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SIGN'             SIGN
         ORG
         DC    X'8881',X'0020C0'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'LENGTH'           LENGTH
         ORG
         DC    X'8881',X'0000E0'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SYSACT'           SYSACT
         ORG
         DC    X'8A80',X'911203'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SQRT'             SQRT
         ORG
         DC    X'8882',X'002004'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'SIN'              SIN
         ORG
         DC    X'8882',X'002008'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'COS'              COS
         ORG
         DC    X'8882',X'00200C'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ARCTAN'           ARCTAN
         ORG
         DC    X'8882',X'002010'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'LN'               LN
         ORG
         DC    X'8882',X'002014'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'EXP'              EXP
         ORG
         DC    X'8882',X'002018'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ENTIER'           ENTIER
         ORG
         DC    X'8881',X'0020F0'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INSYMB'           INSYMB
         ORG
         DC    X'8A80',X'90181F'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INREAL'           INREAL
         ORG
         DC    X'8A80',X'0A1822'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'ININTE'           ININTE
         ORG
         DC    X'8A80',X'091826'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INBOOL'           INBOOL
         ORG
         DC    X'8A80',X'0B182A'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INARRA'           INARRA
         ORG
         DC    X'8880',X'0E182E'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INTARR'           INTARR
         ORG
         DC    X'8880',X'0D1832'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'INBARR'           INBARR
         ORG
         DC    X'8880',X'071836'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTSYM'           OUTSYM
         ORG
         DC    X'8880',X'10143B'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTREA'           OUTREA
         ORG
         DC    X'8880',X'02143E'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTINT'           OUTINT
         ORG
         DC    X'8880',X'011442'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTBOO'           OUTBOO
         ORG
         DC    X'8880',X'031446'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTARR'           OUTARR
         ORG
         DC    X'8880',X'06144A'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTTAR'           OUTTAR
         ORG
         DC    X'8880',X'05144E'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTBAR'           OUTBAR
         ORG
         DC    X'8880',X'071452'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'OUTSTR'           OUTSTR
         ORG
         DC    X'8880',X'001456'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'PUT'              PUT
         ORG
         DC    X'8A80',X'04115A'
*
         DC    XL6'00'
         ORG   *-6
         IEXCGEN DC,'GET'              GET
         ORG
         DC    X'8A80',X'04115E'
*
FIXITABL EQU   *-FIXITAB               L'FIXITAB
*
         LTORG
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
ZFOSTA   EQU   FSTAB
*
         ORG   SYSUT1
*
FSNMAX   DS    H
LVCOUNT  DS    H
SUCOUNT  DS    H
ZLEVEN   DS    F
ZSUTEN   DS    F
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END   IEX30000
