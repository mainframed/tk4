X51      TITLE 'IEX51 - TERMINATION OF COMPILATION, ALGOL F'
*
*        FUNCTION/OPERATION -
*        THE TABLES NEEDED AT OBJECT TIME ARE PREPARED AND
*        INCLUDED IN THE OBJECT MODULE. THEY ARE PROGRAM BLOCK
*        TABLE, LABEL ADDRESS TABLE, AND DATASET TABLE. ESD
*        RECORDS FOR THE REQUIRED LIBRARY ROUTINES ARE GENERATED.
*        THE INFORMATION REQUIRED TO START THE EXECUTION,
*        INCLUDING THE END STMT, IS GENERATED. A TABLE CONTAINING
*        THE DSA SIZES FOR THE PROGRAM BLOCKS IS PREPARED AND
*        TOGETHER WITH THE OBJECT MODULE SIZE OUTPUT TO
*        SYSPRINT
*
*        CSECT IEX60000 -
*        THE ERROR PATTERNS GENERATED DURING COMPILATION PHASE
*        ARE HANDLED AND THE CORRESPONDING DIAGNOSTIC MESSAGES
*        ARE GENERATED
*
*        CSECT IEX51002 -
*        ALL AREAS RESERVED ARE RELEASED AND THE DCBS
*        NOT CLOSED EARLIER ARE CLOSED, THE ORIGINAL PICA IS
*        RESTORED, THE RETURN CODE IS FOUND. CONTROL IS
*        RETURNED TO COMPILER DIRECTORY IEX00
*
*        ENTRY POINTS -
*        IEX51000 - NORMAL END OF COMPILATION
*                   XCTL EP=IEX51000 THE MODULE IS
*                   NORMALLY ENTERED FROM IEX40
*        IEX51ER1 - ABNORMAL END OF COMPILATION
*                   XCTL EP=IEX51ER1 IS USED BY IEX40
*                   AND IEX50
*        IEX51ER2 - ABNORMAL END OF COMPILATION
*                   XCTL EP=IEX51ER2 IS USED BY IEX40
*        IEX51002 - ABNORMAL END OF COMPILATION
*                   XCTL EP=IEX51002 IS USED BY IEX00,
*                   IEX21, AND IEX31
*
*        INPUT - N/A
*
*        OUTPUT -
*        PART OF THE OBJECT MODULE IS GENERATED AND OUTPUT ON
*        SYSLIN AND/OR SYSPUNCH
*        STORAGE REQUIREMENTS AND DIAGNOSTIC MESSAGES ARE
*        OUTPUT ON SYSPRINT
*
*        EXTERNAL ROUTINES -
*        THE PRINT ROUTINE IN IEX00 IS USED
*
*        EXIT - NORMAL-
*        CONTROL IS GIVEN TO COMPILER DIRECTORY, IEX00, BY MEANS
*        OF THE RETURN MACRO INSTRUCTION
*
*        EXIT - ERROR -
*        AFTER PROGRAM INTERRUPTS AND I/O ERRORS THE MODULE GETS
*        CONTROL BACK AND EXITS NORMALLY
*
*        TABLES/WORKAREAS -
*        THE MESSAGE TEXTS WITH CORRESPONDING ADDRESS TABLE ARE
*        IN THE LOAD MODULE IEX51M
*        THE ERROR MESSAGE EDITING ROUTINE, CSECT IEX60000, ALSO
*        USES THE FOLLOWING TABLES -
*        WINTEBC  - TRANSLATION OF INTERNAL CHARACTERS TO EBCDIC
*        WSYMBSRC - TRANSLATION OF SOURCE OPERATORS
*        WSYMBSTK - TRANSLATION OF INTERNAL SYMBOLS TO EBCDIC
*        WORDSEBC - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN
*                   EBCDIC
*        WORDSISO - TRANSLATION OF COMPOUND SYMBOLS IF SOURCE IN
*                   ISOCODE
*        WEBCDIC  - TRANSLATION EBCDIC-EBCDIC
*        A WORKAREA OF 270 BYTES, WAREA, IS USED FOR BUILDING
*        THE MESSAGES
*
*        FOR THE EXTERNAL REFERENCES TO THE LIBRARY ROUTINES ONE
*        OF THE TABLES SHRTAB AND LNGTAB, CONTAINING THE MODULE
*        NAMES, IS USED. THE GENERATE ROUTINE USES THREE TABLES,
*        ESDT, TXTT, AND RLDT, FOR GENERATION OF THE DIFFERENT
*        TYPES OF OBJECT RECORDS.
*
*        THE PART OF COMMON WORKAREA STARTING AT SYSUT1 IS
*        INITIALIZED BY THE LOAD MODULE IEX40 AND IS USED BY THIS
*        AND THE PRECEDING LOAD MODULE
*
*        ATTRIBUTES - NONE
*
*        NOTES -
*        CHARACTER CODE DEPENDENCE -
*
*        CSECT IEX51000 -
*        THE OPERATION OF THE ROUTINES GENERATE AND PRINT
*        STORAGE REQUIREMENTS DEPENDS UPON AN INTERNAL
*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS
*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.
*
*        CSECT IEX60000 -
*        FOR THE BUILDING OF A MESSAGE (CODE PART BETWEEN COT03
*        AND COT12) THE FOLLOWING APPLIES -
*        IN CASE NO SOURCE INFORMATION IS TO BE INSERTED
*        (COT31), OR IF THE INFORMATION IS EBCDIC-CHARACTERS
*        (COT07), THE OPERATION OF CSECT IEX60000 DEPENDS UPON AN
*        INTERNAL REPRESENTATION OF THE EXTERNAL CHARACTER SET
*        WHICH IS EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME.
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        CHARACTERS (COT33) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLE 'WINTEBC'.
*        IF THE SOURCE INFORMATION TO BE INSERTED IS INTERNAL
*        ALGOL SYMBOLS (COT10) THE OPERATION OF CSECT IEX60000
*        DEPENDS UPON A TRANSLATION FROM THE INTERNAL
*        REPRESENTATION TO THE EBCDIC CHARACTER SET BY MEANS OF
*        THE TABLES 'WSYMBSTK'/'WSYMBSRC' AND 'WORDSISO'/
*        'WORDSEBC'.
*
*        FOR THE OUTPUT OF A MESSAGE (CODE PART BETWEEN COT12
*        AND COT21) THE FOLLOWING APPLIES -
*        WHEN A MESSAGE HAS BEEN BUILT IN EBCDIC, AN EBCDIC-
*        EBCDIC TRANSLATION IS PERFORMED BEFORE OUTPUT BY MEANS
*        OF THE TABLE 'WEBCDIC'. THUS THE OUTPUT MAY BE MODIFIED
*        BY MAKING CHANGES IN THIS TABLE.
*
*        THE OPERATION OF THE OTHER PARTS DOES NOT DEPEND UPON A
*        PARTICULAR INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET.
*
*        THIS MODULE WILL BE LINKED TOGETHER WITH THE MODULE
*        IEX51M TO FORM THE MODULE IEX51
*
*        THIS MODULE IS ONLY INTENDED TO BE EXECUTED IN
*        CONNECTION WITH THE OTHER MODULES OF THE ALGOL COMPILER
*        IN PARTICULAR IT REQUIRES THE COMMON WORKAREA
*
IEX51000 CSECT
*
*        DEFINITIONS
*
RASLGT   EQU   2048                    LENGTH OF RETURN ADDR STACK
LPGCF    EQU   28                      LENGTH OF PUT/GET CONTROL FIELD
*
*        ENTRY POINTS
*
         ENTRY IEX51ER1
         ENTRY IEX51ER2
*
         IEXENTRY 'IEX51000 LEVEL 2.1 &SYSDATE &SYSTIME'
*
         USING IEX51000,R10
         USING WORKAREA,R13
*
         LR    R10,R15
         SR    R8,R8
*
*        TEST MODE
*
TRM1     LA    R2,IEX51ER1             GIVE DIRECTORY
         ST    R2,ERET                 RETURN ADDR
         OI    COMPFLGS+2,NOSC         INDICATE NO SC AVAILABLE
         TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    TRM10                   YES, BYPASS ALL CODE GENERATION
         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK SPECIFIED ?
         BO    TRM10                   YES, NO CODE GENERATION
*
*        GENERATE LAT, TXT RECORDS
*
TRM8     ST    R6,PRPTAR               SET
         TM    PRPTAR+3,X'02'          PRPOINTER
         BZ    TRM4                    TO
         LA    R2,ZEROHW               FULL WORD BOUNDARY
         BAL   R14,GENTXTS
         DC    H'2'                    GENERATE 2 BYTES
*
TRM4     ST    R6,ALAT                 SAVE PRPOINTER AT LAT-BEGIN
         L     R2,LATAB                GET ADDR OF LAT
         LH    R3,LN                   GET DISPLACEMENT OF LAST LABEL
         LA    R3,4(,R3)               LENGTH OF LAT
         STH   R3,TRM39                STORE LENGTH IN TRM39
         BAL   R14,GENTXTS             GENERATE TXT RECORDS
TRM39    DC    H'0'                    LENGTH OF LAT
*
*        RLD RECORDS FOR LAT
*
TRM40    LH    R3,TRM39                GET LENGTH OF LAT
         LA    R4,LATBEG+4             GET LENGTH OF 1ST PART
         SR    R3,R4                   GET LENGTH OF LAST PART
         BNP   TRM42                   ^> ZERO, BRANCH
         STH   R3,TRM41                STORE LENGTH OF LAST PART
         L     R2,ALAT                 GET PRPOINTER AT LAT BEGIN
         LA    R2,LATBEG+4(,R2)        PRPOINTER AT LAST PART
         BAL   R14,GENRLD              GENERATE RLD RECORD
TRM41    DC    H'0'                    LENGTH OF LAST PART
         DC    H'1'
         DC    H'1'
*
*        ESD RECORDS FOR LAT
*
TRM42    L     R5,LATAB                GET ADDR OF LAT
         LA    R7,LATNR                GET NO OF ENTRIES FOR ST FUNCTS
         LA    R9,SHRTAB               ADDR TABLE FOR SHORT PREC
         TM    COMPFLGS,LNG            LONG PRECISION  ?
         BZ    TRM44                   NO, BRANCH
         LA    R9,LNGTAB               LONG, CHANGE ADDR
TRM44    CLI   0(R5),0                 ROUTINE USED ?
         BNE   TRM45                   NO
         MVC   TRM43+3(5),0(R9)        YES, MOVE NAME TO ESD CALL
         BAL   R2,GENESD               GENERATE ESD RECORD
TRM43    DC    CL8'IHI     '
         DC    X'02'
*
TRM45    LA    R5,4(,R5)               STEP
         LA    R9,5(,R9)               ADDRS
         BCT   R7,TRM44                HANDLE NEXT ENTRY IF ANY
*
*        RLD RECORDS FOR ESD ENTRIES IN LAT
*
TRM46    L     R11,ALAT                GET PRPOINTER AT LAT BEGIN
         L     R5,LATAB                GET ADDR OF LAT
         LA    R7,LATNR                GET NO OF ENTRIES FOR ST FUNCS
         LA    R9,1                    INIT REG FOR R ESID FOR RLDCALL
*
TRM49    CLI   0(R5),0                 ROUTINE USED ?
         BNE   TRM48                   NO
         LA    R9,1(,R9)               YES, GET ESID FOR R
         STH   R9,TRM47                GIVE TO RLD-CALL
         LR    R2,R11
         BAL   R14,GENRLD              GENERATE RLD RECORD
         DC    H'4'                    LENGTH OF ADDR TABLE
TRM47    DC    H'0'                    ESID OF RELOC FACTOR R
         DC    H'1'                    ESID OF POSITION IDENTIFIER P
*
TRM48    LA    R11,4(,R11)             STEP
         LA    R5,4(,R5)               ADDRS
         BCT   R7,TRM49                HANDLE NEXT ENTRY IF ANY
*
*        GENERATE PBTAB, 4TH VERSION, TXT RECORDS
*
TRM2     ST    R6,APBT                 STORE PRPOINTER
         LA    R3,PBTAB3+4             GET START
         L     R4,APBTAB4              ADDRS
         ST    R8,0(,R4)               SET ZEROES
         LH    R2,PBN                  GET NUMBER OF PROGRAM BLOCKS
         LA    R4,4(,R4)               STEP ADDR
         MVC   0(4,R4),PIDENT          INSERT PROGRAM IDENTIFICATION
TRM5     ST    R8,4(,R4)               INSERT ZEROES
         LA    R4,8(,R4)               STEP ADDR
         L     R11,0(,R3)              TAKE PBTAB3 ENTRY
         LH    R5,ONEENTRY             ADD
         SLL   R5,16                   SIZE OF
         AR    R11,R5                  ONE ENTRY
         ST    R11,0(,R4)              IN DSA
         LA    R3,4(,R3)               STEP ADDR
         BCT   R2,TRM5                 MOVE NEXT IF ANY
         LA    R4,4(,R4)
         LH    R2,KBN                  GET NUMBER
         LTR   R2,R2                   OF LAST CONST BLOCK
         BZ    TRM7                    NO MORE BLOCK THAN NR ZERO
         SH    R2,PBN                  GET NO OF CONST BLKS EXCEPT 0
         LH    R3,KH4096               GET LENGTH OF CONST BLOCK
         LR    R5,R3
         ST    R8,4(,R4)               INSERT ZEROES
TRM6     ST    R3,0(,R4)               STORE DISP OF CONST BLOCK
         LA    R4,8(,R4)               STEP ADDR
         AR    R3,R5                   INCREASE DISPLACEMENT
         BCT   R2,TRM6                 STORE NEXT IF ANY
*
TRM7     L     R2,APBTAB4              GET ADDR OF PBTAB4
         LR    R5,R4                   COMPUTE
         SR    R5,R2                   LENGTH OF
         STH   R5,TRM7AA               PBTAB4
         BAL   R14,GENTXTS             GENERATE TXT RECORDS
TRM7AA   DC    H'0'                    LENGTH OF PBTAB4
*
*        RLD RECODS FOR PBTAB4
*
TRM52    L     R7,APBT                 GET PRPOINTER AT PBTAB4 BEGIN
         B     TRM53                   GENERATE RLD RECORD
*
TRM70    NI    TRM71+1,X'0F'           CHANGE BRANCH CONDITION
         LH    R5,KBN                  GET NUMBER OF LAST CONST BLOCK
         CR    R8,R5                   ZERO ?
         BE    TRM10                   YES
         LH    R2,PBN                  NO, GET NUMBER OF
         SR    R5,R2                   CONST BLKS EXC 0
         SLL   R2,3                    GET PRPOINTER
         LA    R7,8(R2,R7)             AT SECOND CONST BLK
TRM53    LR    R2,R7
         BAL   R14,GENRLD
         DC    H'4'
         DC    H'1'
         DC    H'1'
*
TRM71    B     TRM70                   BRANCH AFTER FIRST RECORD
         LA    R7,8(,R7)               STEP ADDR
         BCT   R5,TRM53                HANDLE NEXT ENTRY IF ANY
*
*        CONSTRUCT DATASET TABLE
*
TRM10    LA    R2,DSTAB                GET ADDR OF DSTAB
         ST    R6,DSTABPRP             STORE PRPOINTER
         LA    R7,IOTAB                GET ADDR OF IOTAB
         LA    R5,15                   LOAD MAX DS NUMBER
         TM    16(R7),X'FF'            UNDET DS NO OCCURRED ?
         BNZ   TRM12A                  YES, MDSN=15
         LA    R3,15                   DETERMINE
         LA    R11,1
TRM11    LA    R4,0(R3,R7)
         CLI   0(R4),0
         BNE   TRM11A                  MAX
         BCTR  R3,0                    DS
         CR    R3,R11
         BNE   TRM11
TRM11A   LR    R5,R3                   NUMBER USED
         STH   R3,MDSN                 USED
TRM12A   BCTR  R5,0                    GET MAX DS NUMBER MINUS ONE
TRM12    LA    R3,36                   CALC
         MH    R3,MDSN                 LGT OF DSTAB
         LA    R3,40(,R3)              WITHOUT PGCF
         STH   R3,DSTABLGT
         LA    R3,0(R3,R6)             STORE
         ST    R3,0(,R2)               PGCF-POINTER
         SR    R11,R11                 LOAD DS NO FOR ERROR PATTERN
         TM    0(R7),X'70'             CORRECT SPEC FOR SYSIN
         LA    R14,TRM19               GET RETURN ADDR FOR ERROR RTN
         BNZ   ERR188                  NO, GENERATE ERROR PATTERN
         MVC   4(DSTABLEL,R2),DSTABLE  YES, INSERT STANDARD DSTABLE
         LA    R11,1                   LOAD DS NR FOR ERROR PATTERN
         TM    1(R7),X'A0'             CORRECT SPEC FOR SYSPRINT
         BNZ   ERR188                  NO, GENERATE ERROR PATTERN
         MVC   40(DSTABLEL,R2),DSTABLE YES, INSERT STANDARD DSTABLE
         MVI   66(R2),X'02'            CHANGE DS FIELD
         MVI   74(R2),X'02'
TRM19    LR    R3,R5                   GET MAX DS NUMBER MINUS ONE
         LTR   R3,R3                   ZERO ?
         BZ    TRM22                   YES, BYPASS MANIP ON BYTES 2-15
         NI    16(R7),X'EF'            RESET SYSACT8 BIT
         TM    16(R7),X'01'            PRE COMP PROCEDURE ?
         BZ    TRM192                  NO
         LA    R4,76(,R2)              GET ADDR OF DS2 IN DSTAB
TRM191   MVC   0(DSTABLEL,R4),DSTABLE  MOVE STANDARD DSTABLE
         MVI   26(R4),X'42'            CHANGE DS FIELD
         MVI   34(R4),X'42'
         LA    R4,DSTABLEL(,R4)        NEXT DS NUMBER IN DSTAB
         BCT   R3,TRM191
         B     TRM22
*
TRM192   TM    16(R7),X'FF'            BYTE 16 ZERO ?
         BZ    TRM15                   YES
TRM14    LA    R4,1(R3,R7)             NO, OR
         TM    0(R4),X'10'                    BYTE 16
         BO    TRM14A                                 INTO BYTES NOT
         OC    0(1,R4),16(R7)          CONTAINING
TRM14A   BCT   R3,TRM14                           SYSACT8 INDICATION
TRM15    LR    R3,R5                   GET MAX DS NUMBER MINUS ONE
TRM16    LA    R4,1(R3,R7)             INDICATE
         TM    0(R4),X'C0'                      SYSACT4/13
         BNO   TRM16A                                   IN BYTES
         OI    0(R4),X'20'             WITH INPUT AND OUTPUT INDIC
TRM16A   BCT   R3,TRM16
         LR    R3,R5                   GET MAX DS NR MINUS ONE
TRM17    LA    R4,1(R3,R7)
         LA    R11,1(,R3)              LOAD DS NUMBER FOR ERROR PATTERN
         TM    0(R4),X'10'             SYSACT8 INDICATED ?
         BZ    TRM18                   NO
         TM    0(R4),X'A0'             YES, INPUT OR SYSACT4/13 IND ?
         BZ    TRM17A                  NO
         LA    R14,TRM18               YES, GENERATE ERROR PATTERN
         B     ERR188
*
TRM17A   NI    0(R4),X'F7'             RESET UNDET SYSACT BIT
TRM18    BCT   R3,TRM17                EXAMINE NEXT BYTE IF ANY
         LR    R3,R5                   GET MAX DS NR MINUS ONE
         LA    R4,76(,R2)              GET ADDR OF DS2 IN DSTAB
         LA    R1,2(,R7)               GET ADDR OF 2ND BYTE IN IOTAB
TRM20    MVC   0(DSTABLEL,R4),DSTABLE  MOVE STANDARD MASK
         TM    0(R1),X'28'             SYSACT4/13 OR UND SA IND ?
         BNZ   TRM21                   YES
         TM    0(R1),X'40'             NO, OUTPUT INDICATED ?
         BZ    TRM211
         MVI   26(R4),X'02'            YES, CHANGE DS FIELD
         MVI   34(R4),X'02'
         B     TRM211
*
TRM21    TM    0(R1),X'40'             OUTPUT INDICATED ?
         BO    TRM21A                  YES
         MVI   26(R4),X'40'            NO, CHANGE DS FIELD
         MVI   34(R4),X'40'
         B     TRM211
*
TRM21A   MVI   26(R4),X'42'            CHANGE DS FIELD
         MVI   34(R4),X'42'
TRM211   LA    R4,36(,R4)              NEXT DS NUMBER IN DSTAB
         LA    R1,1(,R1)               NEXT BYTE IN IOTAB
         BCT   R3,TRM20
TRM22    TM    17(R7),X'FF'            BYTE 17 ZERO ?
         BZ    TRM27                   YES
         LH    R3,DSTABLGT             NO, GET ADDR OF PGCFIELD
         LA    R3,0(R3,R2)
         MVI   0(R3),0                 INSERT ZEROES IN PGCF
         MVC   1(27,R3),0(R3)
         LA    R4,2048                 INITIATE BE-FIELD
         ST    R4,16(,R3)
         B     TRM23
*
TRM27    MVI   0(R2),X'80'             INDICATE NO PUT/GET
*
*        GENERATE DSTABLE, TXT RECORDS
*
TRM23    TM    COMPFLGS,COMPMODE       SYNTAX CHECK MODE ?
         BO    TRM37                   YES, BYPASS CODE GENERATION
         TM    COMPFLGS+1,NLOAD+NDECK  NOLOAD AND NODECK SPECIFIED ?
         BO    TRM37                   YES, NO CODE GENERATION
         TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM24                   YES
         LH    R3,DSTABLGT             GET LEN OF DSTAB WITHOUT PGCF
         CLI   0(R2),X'80'             THERE A PGCF ?
         BE    TRM23A                  NO
         LA    R3,LPGCF(,R3)           YES, ADD PGCF LENGTH
TRM23A   STH   R3,TRM23B               STORE LENGTH IN CALLING SEQ
         BAL   R14,GENTXTS             GENERATE TXT RECORDS
TRM23B   DC    H'0'                    LENGTH OF DSTAB
*
*        RLD RECORD FOR PGCF ADDR IN DSTAB
*
TRM32    L     R2,DSTABPRP             GET PRPOINTER AT DSTAB BEGIN
         BAL   R14,GENRLD              GENERATE RLD RECORD
         DC    H'4'                    LENGTH OF ADDR
TRM32ID  DC    H'1'                    ESD ID
         DC    H'1'
*
*        GENERATE TXT RECORDS ADDR TABLE
*
TRM24    MVC   ASTART(3),PRPT+1        GET PRPOINTER AT FIRST INSTR
         TM    COMPFLGS,LNG            LONG PRECISION ?
         BZ    TRM24A                  NO, SHORT, BRANCH
         MVI   SW,0                    LONG, CHANGE MASK
TRM24A   ST    R6,ADRPRP               STORE PRPOINTER AT ADR TABLE
         LA    R2,APBT                 GET ADDR OF TEXT
         BAL   R14,GENTXTS
         DC    H'12'                   LENGTH OF TEXT
*
*        ESD RECORD FOR FSA ADDR
*
TRM28    TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM54                   YES
         BAL   R2,GENESD               GENERATE ESD RECORD
TRM29    DC    C'IHIFSAIN'
         DC    X'0200'
*
*        RLD RECORDS FOR ADDR TABLE
*
TRM54    L     R2,ADRPRP               GET PRPOINTER AT ADDR TABLE
         BAL   R14,GENRLD              GENERATE RLD RECORDS
         DC    H'12'
         DC    H'1'
         DC    H'1'
*
*        ESD RECORD, LD ENTRY, FOR ENTRY INFO
*
TRM25    TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM35                   YES, BYPASS NEXT TWO RECORDS
         MVC   TRM26(3),ADRPRP+1       MOVE PRPOINTER TO CALL
         BAL   R2,GENESD
         DC    CL8'IHIENTIF'           NAME
         DC    X'01'
TRM26    DC    X'000000'               PRPOINTER
         DC    C' '
         DC    X'000001'
*
*        ESD RECORD, LD ENTRY, FOR DSTAB
*
TRM56    MVC   TRM57(3),DSTABPRP+1     MOVE PRPOINTER TO CALL
         BAL   R2,GENESD
         DC    CL8'IHIDSTAB'           NAME
         DC    X'01'
TRM57    DC    X'000000'               PRPOINTER
         DC    C' '
         DC    X'000001'
*
*        GENERATE END RECORD
*
TRM35    TIME
*
         ST    R1,SV                   USE A SAVEAREA AS A WORKAREA
         UNPK  ENDRECD,SV+1(3)         DATE OF COMPILE
         ST    R6,ENDRECL              STORE LENGTH OF CSECT IN ENDREC
         TM    COMPFLGS,PROC           PROCEDURE COMPILATION ?
         BO    TRM34                   YES, BRANCH
         MVC   ENDRECN,TRM29           MOVE IN ENTRY POINT ESD NAME
         B     TRM33
*
TRM34    MVC   ENDRECA,ADRPRP+1        ADDR TABLE IS ENTRY POINT
         MVC   ENDRECID,TRM32ID        GET ESD ID FOR ENTRY POINT
TRM33    MVC   ENDRECK,PIDENT          INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             INCR SEQUENCE NUMBER
         UNPK  ENDRECC,CARDCNT         CONVERT TO CHARACTER
         OI    ENDRECC+3,X'F0'         MAKE PRINTABLE
         TM    COMPFLGS+1,NLOAD        NOLOAD ?
         BO    TRM50A                  YES, BRANCH
         L     R1,ALINDCB              R1 -> SYSLIN DCB

         PUT   (R1)                    PUT FOR SYSLIN

         MVC   0(L'ENDREC,R1),ENDREC
TRM50A   TM    COMPFLGS+1,NDECK        NODECK ?
         BO    TRM51                   YES, BRANCH
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB

         PUT   (R1)                    PUT FOR SYSPUNCH

         MVC   0(L'ENDREC,R1),ENDREC
*
*        PRINT STORAGE REQUIREMENTS
*
TRM51    MVI   LINCNT+1,255            FORCE HEADINGS TO BE PRINTED
         MVI   PAGEHD1C+1,C' '         BLANK FIRST HEADING LINE
         MVC   PAGEHD1C+2(109),PAGEHD1C+1
         MVC   PAGEHD2D(L'PAGEHD2D),PAGEHD1D  BLANK SEC HEADING LINE
         MVC   PAGEHD3D(L'PAGEHD3D),PAGEHD1D  BLANK 3RD HEADING LINE
         MVC   PAGEHD1D+35(L'HEAD1),HEAD1
         CVD   R6,DEC                  CONVERT LENGTH OF OBJECT MODULE
         BAL   R14,EDNR                EDIT TO PRINTABLE FORMAT
         MVC   KOBJSZB,EDAREA+2        MOVE OBJ SIZE INTO MSG
         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER
         MVC   0(KOBJSZL,R1),KOBJSZ    MOVE MSG INTO BUFFER
         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER
         MVC   0(L'KDSA,R1),KDSA       SECOND PRINT LINE
         BAL   R14,PRINTT              OBTAIN OUTPUT BUFFER
         LA    R2,5                    GET NO OF ENTRIES IN ONE LINE
TRM60    MVC   0(L'KPBN,R1),KPBN       BUILD THIRD PRINT LINE
         LA    R1,L'KPBN+7(,R1)        BUMP BUFFER POINTER
         BCT   R2,TRM60                LOOP 5 TIMES
         BAL   R14,PRINTT
         L     R3,APBTAB4              INITIATE
         LH    R8,PBN                           REGISTERS
         SR    R4,R4                                      FOR TABLE
TRM62    LA    R2,5                    INITIATE FOR EACH PRINT LINE
TRM61    LA    R4,1(,R4)                                 ENTRY
         CVD   R4,DEC                  CONVERT
         UNPK  BLNR,DEC+6(2)                   AND MOVE
         OI    BLNR+2,X'F0'                             BLOCK
         MVC   0(L'BLNR,R1),BLNR                              NUMBER
         LA    R3,8(,R3)               GET PBTAB ENTRY
         LH    R11,4(,R3)              GET DSA SIZE
         CVD   R11,DEC                 CONVERT TO DECIMAL
         BAL   R14,EDNR                EDIT
         MVC   6(5,R1),EDAREA+3        MOVE IN VALUE
TRM65    BCTR  R8,0
         LTR   R8,R8                   ALL PBTAB ENTRIES HANDLED ?
         BZ    TRM37                   YES
         LA    R1,18(,R1)              MAKE NEXT ENTRY
         BCT   R2,TRM61                IF LINE NOT FULL
         BAL   R14,PRINTT              OBTAIN PRINT BUFFER
         B     TRM62
*
*        OBTAIN OUTPUT BUFFER
*
*        ON RETURN R1 -> BUFFER
*
PRINTT   STM   R14,R15,SV              SAVE R14 AND R15
         L     R15,PRTRTADD
         BALR  R14,R15                 CALL PRINT ROUTINE
         LM    R14,R15,SV              RESTORE REGS
         BR    R14
*
*        EDIT DECIMAL NUMBER
*
EDNR     MVC   EDAREA,EDPTRN           MOVE PATTERN
         ED    EDAREA,DEC+4            EDIT
         BR    R14
*
*        DIRECTORY RETURN BEFORE FREEMAIN
*
IEX51ER1 EQU   *
TRM37    L     R2,FREEMSIZ             GET INFO FOR AREA RELEASE
         L     R1,FREEMADR
*
         FREEMAIN R,LV=(2),A=(1)       RELEASE AREA
*
         BALR  R15,0                   LOAD NEW BASE REGISTER
*
IEX51ER2 EQU   *                       TERMINATION
         USING *,R15
*
TRM38    L     R2,=A(IEX60000)         R2 -> IEX60000
         L     R14,=A(IEX51002)        LOAD RETURN ADDR
         LA    R1,ERRINFO              ADDR INFO FOR ERROR ED ROUT
         BR    R2                      GOTO ERROR MESSAGE EDITING
*
*        LTORG
*
         LTORG
*
         DROP  R15
*
*        GENERATE A PATTERN FOR ERROR MSG 188
*
ERR188   SR    R9,R9
         LA    R9,10
         CR    R11,R9                  DS NUMBER 9 OR LOWER
         BL    ER1                     YES
         SR    R11,R9                  NO, SUBTRACT 10
         STC   R11,EP188+11            STORE
         TR    EP188+11(1),NRTRA       CONVERT TO CHARACTER
         MVI   EP188+10,C'1'           INSERT FIRST DIGIT
         LA    R9,13                   GET L'ENTRY
         B     ER2
*
ER1      STC   R11,EP188+10            STORE NUMBER
         TR    EP188+10(1),NRTRA       CONVERT IT
         MVI   EP188+11,C'.'           INSERT PERIOD
         LA    R9,12                   GET LENGTH OF ENTRY
ER2      STC   R9,EP188                INSERT LENGTH OF ENTRY
         OI    EP188,X'80'             PUT A TAG FOR BLANK SC
         BCTR  R9,0                    DECREASE BY ONE
         STC   R9,ER3+1                STORE LENGTH IN MOVE INSTR
         L     R11,NEXTERR             GET NEXT ENTRY IN POOL
ER3      MVC   0(0,R11),EP188          MOVE PATTERN
         LA    R11,1(R9,R11)           UPDATE PTR TO NEXT FREE ENTRY
         ST    R11,NEXTERR
         C     R11,ENDPOOL             POOL FULL ?
         BH    ER4                     YES
         OI    COMPFLGS,COMPMODE       SET SYNTAX CHECK MODE
         BR    R14                     RETURN
*
ER4      MVC   0(4,R11),EP0            MOVE PATTERN EP0
         LA    R11,4(,R11)             UPDATE PTR
         ST    R11,NEXTERR             STORE IT
         B     TRM37                   TERMINATE COMPILATION
*
*        CONSTANTS AND AREAS
*
PRPTAR   DC    A(0)                    AREA TO HANDLE PRPOINTER
DSTABPRP DC    A(0)                    PRPOINTER AT DSTAB BEGIN
AFSAPRP  DC    A(0)                    PRPOINTER AT AFSA
ADRPRP   DC    A(0)                    PRPOINTER AT APBT
MDSN     DC    H'15'                   MAX DS NUMBER
KH4096   DC    H'4096'                 LENGTH OF CONSTANT BLOCK
*
*        GENERATE MODEL DATASET TABLE ENTRY
*
         DSTABLE  DSECT=NO
*
DSTABLGT DC    H'0'                    LENGTH OF DSTAB WITHOUT PGCF
*
*        END RECORD
*
         DC    0F'0'
ENDREC   DC    CL80' '             *   IMAGE FOR END RECORD
         ORG   ENDREC              ×   COLS
         DC    X'02'               ×   1
         DC    C'END'              ×   2-4
         DC    C' '                ×   5
ENDRECA  DC    C'   '              ×   6-8   ENTRY ADDR
         DC    C'      '           ×   9-14
ENDRECID DC    C'  '               ×   15-16 ESDID OF ENTRY POINT
ENDRECN  DC    C'        '         ×   17-24
         DC    C'    '             ×   25-28
ENDRECL  DC    C'    '             ×   29-32 CSECT LENGTH
         DC    C'1'                ×   33    NUMBER OF IDR ITEMS
         DC    C'360SAL531 '       ×   34-43 TRANSLATOR PRODUCT IDR
         DC    C'0201'             ×   44-47 VERSION AND RELEASE NUMBER
ENDRECD  DC    C'99999'            ×   48-52 PROCESSING DATE
         ORG   ENDREC+72           ×
ENDRECK  DC    CL4' '              ×   73-76 DECK ID
ENDRECC  DC    CL4' '              V   77-80 RECORD COUNT
         ORG   ,
*
APBT     DC    A(0)                    ADDR OF PBT
ALAT     DC    A(0)                    ADDR OF LAT
SW       DC    X'20'                   SWITCH FOR LONG/SHORT PREC
ASTART   DC    AL3(0)                  ADDR OF FIRST INSTRUCTION
*
HEAD1    DC    C'STORAGE REQUIREMENTS (DECIMAL)'
*
KOBJSZ   DC    C'OBJECT MODULE SIZE'
KOBJSZB  DC    CL6' '
         DC    C' BYTES'
KOBJSZL  EQU   *-KOBJSZ                L'OBJECT SIZE MESSAGE
*
KDSA     DC    C'DATA STORAGE AREA SIZES'
KPBN     DC    C'PBN   BYTES'
DEC      DC    D'0'                    FOR CONVERSION OF NUMBERS
EDPTRN   DC    X'4020202020202020'     PATTERN FOR EDITING
EDAREA   DC    CL8' '                  EDITING OF NUMBERS
BLNR     DC    CL3' '                  FOR CONVERSION OF BLOCK NUMBER
SV       DC    2F'0'                   SAVE AREA
*
EP188    DC    X'00BC0000'             ERROR PATTERN FOR MESSAGE 188
         DC    C'DSN = 00.'
*
EP0      DC    X'04000000'             ERROR PATTERN FOR MESSAGE 0
*
NRTRA    DC    C'0123456789'           TRANSLATION OF DS NUMBER
*
ERRINFO  DC    V(IEX51M00)             ADDR OF MESSAGE TEXTS
         DC    V(IEX51M01)             ADDR OF ADDR TABLE
         DC    H'12'                   MODIFICATION NUMBER
*
         DC    0F'0'
*
*        LIBRARY ROUTINES - SHORT
*
SHRTAB   DC    C'SYSCT'
         DC    C'SSQ  '
         DC    C'SSCS '
         DC    C'SSCC '
         DC    C'SAT  '
         DC    C'SLO  '
         DC    C'SEX  '
         DC    C'ISYMB'
         DC    C'IDEIR'
         DC    C'IDEII'
         DC    C'IBOOL'
         DC    C'IARRY'
         DC    C'IARRT'
         DC    C'IBARR'
         DC    C'OSYMB'
         DC    C'SOREL'
         DC    C'OINTG'
         DC    C'OBOOL'
         DC    C'OARRY'
         DC    C'OTARR'
         DC    C'OBARR'
         DC    C'OSTRG'
         DC    C'GPRPT'
         DC    C'GPRGT'
         DC    C'FII  '
         DC    C'FRI  '
         DC    C'FRR  '
*
*        LIBRARY ROUTINES - LONG
*
LNGTAB   DC    C'SYSCT'
         DC    C'LSQ  '
         DC    C'LSCS '
         DC    C'LSCC '
         DC    C'LAT  '
         DC    C'LLO  '
         DC    C'LEX  '
         DC    C'ISYMB'
         DC    C'IDEIR'
         DC    C'IDEII'
         DC    C'IBOOL'
         DC    C'IARRY'
         DC    C'IARRT'
         DC    C'IBARR'
         DC    C'OSYMB'
         DC    C'LOREL'
         DC    C'OINTG'
         DC    C'OBOOL'
         DC    C'OARRY'
         DC    C'OTARR'
         DC    C'OBARR'
         DC    C'OSTRG'
         DC    C'GPRPT'
         DC    C'GPRGT'
         DC    C'FII  '
         DC    C'FDI  '
         DC    C'FDD  '
*
***********************************************************************
*
*        S U B R O U T I N E   G E N E R A T E
*
***********************************************************************
*
*        REGISTER DEFINITIONS
*
*        R1                            OUTPUT RECORD POINTER
*        R2                            ADDR OF DATA
*        R3                            TYPE OF RECORD TO BE GENERATED
*        R4                            RETURN REGISTER
*        R14                           LENGTH OF DATA FROM CALL
*        R15                           LENGTH WITHIN RECORD
*
*        BIT PATTERNS
*
SDENTRY  EQU   X'00'                   SD ENTRY IDENTIFICATION
LDENTRY  EQU   X'01'                   LD ENTRY IDENTIFICATION
RLDFLAG  EQU   B'00001100'             FLAG USED IN RLD ENTRY
*
*        GENERATE ESD RECORDS
*
GENESD   LA    R14,16                  LENGTH ALWAYS 16
         LA    R3,ESDT                 INDICATE ESD CALL
         B     GEN1
*
*        GENERATE TXT RECORDS
*
GENTXTS  LA    R4,2(,R14)              COMPUTE RETURN ADDR
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
GEN2     LA    R3,TXTT                 INDICATE TXT CALL
         B     GEN1                    CONTINUE COMMON PART
*
*        GENERATE RLD RECORDS
*
GENRLD   LA    R4,6(,R14)              COMPUTE RETURN ADDR
         LA    R3,RLDT                 INDICATE RLD CALL
         MVC   RANDP(4),2(R14)         INSERT NEW R AND P
         LH    R14,0(,R14)             LOAD LENGTH GIVEN IN CALL
         SLL   R14,1                   DOUBLE LENGTH
GEN1     L     R1,SAVOUTA              LOAD ADDR OF OUT RECORD
         CLC   1(3,R1),1(R3)           RECORD RIGHT TYPE ?
         BNE   GEN3                    NO, CALL FOR NEW
         CLC   10(2,R1),12(R3)         RECORD FILLED ?
         BNL   GEN3                    YES, CALL FOR NEW
GEN6     LA    R15,56
         LH    R0,10(,R1)              R0=LENGTH OF DATA IN REC
         SR    R15,R0                  R15=EMPTY POS LEFT IN RECORD
         CR    R15,R14                 ENOUGH SPACE LEFT ?
         BL    *+6                     NO
         LR    R15,R14                 YES, R15=LENGTH FROM CALL
         AR    R15,R0
         STH   R15,10(,R1)             INSERT NEW LENGTH INTO RECORD
         SR    R15,R0
         AR    R1,R0                   START ADDR WITHIN RECORD
         SR    R14,R15                 REMAINING LENGTH
         B     14(,R3)                 TO DIFFERENT MOVE ROUTINES
*
GEN4     LTR   R14,R14                 MORE INFORMATION MUST BE MOVED ?
         BH    GEN3                    YES
         BR    R4                      NO, RETURN
*
*        CALL FOR NEW OUTPUT RECORD
*
GEN3     ST    R14,SAVELT              SAVE LENGTH
         TM    COMPFLGS+1,NLOAD+NDECK  DECK AND LOAD SPECIFIED ?
         BZ    BOTH                    YES
         TM    COMPFLGS+1,NDECK        ONLY DECK ?
         L     R1,APCHDCB              R1 -> SYSPUNCH DCB
         BZ    PUT1                    YES
PUT1A    L     R1,ALINDCB              R1 -> SYSLIN DCB
*
PUT1     PUT   (R1)                    PUT FOR SYSLIN AND SYSPUNCH IF
*
         ST    R1,SAVOUTA              ONLY SYSPUNCH SPECIFIED
         L     R14,SAVELT              RESTORE LENGTH
         B     PUNCHOUT
*
BOTH     L     R14,OUTAREA2            COPY SYSLIN BUFFER TO SYSPUNCH
         L     R1,SAVOUTA
         MVC   0(80,R14),0(R1)         BUFFER
PUT2     L     R1,APCHDCB              R1 -> SYSPUNCH DCB
*
         PUT   (R1)                    PUT FOR SYSPUNCH WHEN BOTH HAS
*
         ST    R1,OUTAREA2             BEEN SPECIFIED
         B     PUT1A                   GOTO PUT SYSLIN
*
PUNCHOUT MVC   0(4,R1),0(R3)           INSERT FIRST 4 BYTES
         MVI   4(R1),C' '              INSERT ONE BLANK
         MVC   5(67,R1),4(R1)          BLANK OUTPUT RECORD
         MVC   72(4,R1),PIDENT         INSERT PROGRAM IDENT
         AP    CARDCNT,KP1             INCR SEQUENCE NUMBER
         UNPK  76(4,R1),CARDCNT        CONVERT TO CHARACTER
         OI    79(R1),X'F0'            MAKE PRINTABLE
         MVC   10(2,R1),4(R3)          INSERT INITIAL LENGTH
         MVC   14(6,R1),6(R3)          INSERT ESID + R AND P
         CLC   TXTT+1(3),1(R3)         TXT RECORD PROCESSED ?
         BNE   GEN6                    NO
         ST    R6,4(R1)                YES, INSERT R6
         MVI   4(R1),C' '
         B     GEN6
*
*        ESD RECORD
*
         DC    0H'0'
ESDT     DC    X'02'                   RECORD CODE
         DC    C'ESD'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    C'      '
         DC    H'48'                   MAXIMUM LENTH IN RECORD
*
*        MOVE ESD INFORMATION TO OUTAREA
*
GEN7     MVC   16(16,R1),0(R2)         MOVE DATA TO OUTAREA
         CLI   8(R2),LDENTRY           LD ENTRY MOVED ?
         BE    16(R2)                  YES, RETURN TO CALLING ROUTINE
         MVC   25(L'ESDCON,R1),ESDCON  CHANGE LAST PART OF ENTRY
         LH    R3,ESID
         LA    R3,1(,R3)               INCR ESD ID
         STH   R3,ESID                 STORE NEW ESID NUMBER
         SR    R1,R0
         CLI   14(R1),C' '             FIRST SD OR ER ENTRY ?
         BNE   10(R2)                  NO, RETURN TO CALLING ROUTINE
         STH   R3,14(R1)               YES, INSERT ESID NUMBER
         B     10(R2)                  RETURN TO CALLING ROUTINE
*
*        TXT RECORD
*
         DC    0H'0'
TXTT     DC    X'02'                   RECORD CODE
         DC    C'TXT'                  IDENTIFICATION
         DC    H'0'                    INITIAL LENGTH 0
         DC    H'1'                    ESID
         DC    C'    '
         DC    H'56'                   MAXIMUM LENGTH
*
*        MOVE TXT INFORMATION OUTAREA
*
GEN8     BCTR  R15,0                   DECR LENGTH
         STC   R15,*+5                 INSERT PROPER LENGTH TO MOVE
         MVC   16(0,R1),0(R2)          MOVE DATA TO OUTAREA
         LA    R6,1(R15,R6)            INCREASE PROGRAM POINTER
         LA    R2,1(R15,R2)            MODIFY DATA ADDR
         B     GEN4                    OUT OF MOVE TXT ROUTINE
*
*        RLD RECORD
*
         DC    0H'0'
RLDT     DC    X'02'                   RECORD CODE
         DC    C'RLD'                  IDENTIFICATION
         DC    H'0'
         DC    C'  '
RANDP    DC    C'    '                 R AND P
         DC    H'56'                   MAXIMUM LENGTH IN RECORD
*
*        MOVE RLD INFORMATION TO OUTAREA
*
GEN9     AR    R15,R1                  INDICATE LAST ENTRY
GEN5     MVC   16(4,R1),RANDP          INSERT R AND P
         ST    R2,20(,R1)              MOVE PROGRAM POINTER VALUE
         MVI   20(R1),RLDFLAG          FLAG TO OUTAREA
         LA    R1,8(,R1)               NEXT ENTRY
         LA    R2,4(,R2)               NEXT PROGRAM POINTER VALUE
         CR    R1,R15                  LAST COLUMN FILLED ?
         BL    GEN5                    NO, CONTINUE
         B     GEN4                    OUT OF MOVE RLD ROUTINE
*
*        VARIABLES AND CONSTANTS
*
SAVELT   DC    F'0'                    SAVE AREA FOR LENGTH
ESID     DC    H'1'                    ESID VARIABLE 1 AT START
ESDCON   DC    X'00000040404040'       ESD CONSTANT 7 BYTES
KP1      DC    PL1'1'                  INCREMENT CARD COUNTER
*
         TITLE 'IEX51 - TERMINATION OF COMPILATION, ERROR MSG EDITING'
*
         COPY  IEX60000
*
         TITLE 'IEX51 - TERMINATION OF COMPILATION'
*
IEX51002 CSECT
*
         BALR  R2,0
         USING *,R2
*
         OI    COMPFLGS+1,TERM         INDICATE THIS ROUTINE IS ENTERED
         LA    R0,CLOSEDCB             PROVIDE DIRECTORY
         ST    R0,ERET                 RETURN ADDR
*
*        FREE THE STORAGE OF THE ERROR POOL AND SOURCE PROG
*        BUFFER 1
*
         TM    COMPFLGS+1,NOBUF        GETMAIN FOR BUFFERS ISSUED ?
         BO    CLOSEDCB                NO, BRANCH
         L     R0,POOLS                SIZE OF ERROR POOL
         A     R0,SRCE1S               SIZE OF SOURCE PROG BUFFER 1
         L     R1,ERRPOOL              ADDR OF ERROR POOL
*
         FREEMAIN R,LV=(0),A=(1)
*
*        CLOSE THE DCBS AND FREE THE BUFFER POOLS
*
CLOSEDCB BALR  R2,0
         USING *,R2
         LA    R0,SPIE                 PROVIDE NEW DIR RETURN ADDR
         ST    R0,ERET
         LM    R3,R12,DCBTABLE         LOAD DCB ADDRS
         USING IHADCB,R8               R8 -> SYSPRINT DCB
         TM    DCBOFLGS,DCBOFOPN       SYSPRINT OPEN ?
         DROP  R8
         BO    CLOSEB                  YES, BRANCH
         OI    SWITCH+1,X'F0'
*
CLOSEB   CLOSE ((3),,(8),,(9),,(11),,(12))
*
         TM    COMPFLGS+1,NLOAD
         BO    FRPPCH                  IF NOLOAD OPTION
         LR    R1,R3                   R1 -> SYSLIN DCB
*
         FREEPOOL (1)                  FREE SYSLIN BUFFERS
*
FRPPCH   TM    COMPFLGS+1,NDECK
         BO    FRPPRT                  IF NODECK OPTION
         LR    R1,R9                   R1 -> SYSPUNCH DCB
*
         FREEPOOL (1)                  FREE SYSPUNCH BUFFERS
*
FRPPRT   LR    R1,R8                   R1 -> SYSIN DCB
SWITCH   NOP   SPIE
*
         FREEPOOL (1)                  FREE SYSIN BUFFERS
*
*        EXECUTE SPIE MACRO
*
SPIE     BALR  R2,0
         USING *,R2
         L     R4,PICAADD
*
         SPIE  MF=(E,(R4))
*
*
*        FIND THE RETURN CODE AND RETURN TO IEX00
*
RTNCODE  TM    COMPFLGS,TERR
         BZ    NOTERM                  IF NO TERMINAL ERROR
         LA    R15,16
         B     RETURNN
*
NOTERM   TM    COMPFLGS,SERR
         BZ    NOSER                   IF NO SERIOUS ERROR
         LA    R15,8
         B     RETURNN
*
NOSER    SR    R15,R15
         TM    COMPFLGS,WERR
         BZ    RETURNN
         LA    R15,4
RETURNN  L     R13,SAVEAREA+4
*
         RETURN (14,12),RC=(15)
*
         LTORG
*
*        DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=(PS),DEVD=(DA)
*
         PRINT GEN
*
WORKAREA DSECT
*
         COPY  WORKAREA
*
*        AREA USED BY COMPILATION PHASE
*
         ORG   SYSUT1
*
RETADR   DS    17F                     SAVE AREA
PLACE14  DS    F                          -''-
RUTI     DS    9F                      GPR CONTROL
RUTR     DS    4F                      FLREG CONTROL
GPROLN   DS    H                       LABEL NR OF OBJ PRG ENTRY POINT
KONSUM   DS    H                       WORKPLACE
WORKPL   DS    F                       WORKPLACE
IBUF1    EQU   SRCE1ADD                ADDR OF FIRST SOURCE BUFFER
IBUF2    DS    A                         -''  SECOND    -''-
SOURCEB  DS    A                         -''  CURRENT   -''-
RSRCB    DS    A                         -''  READ      -''-
OPBUF1   DS    A                       ADDR OF FIRST OPTAB BUFFER
OPBUF2   DS    A                         -''-  SECOND    -''-
OPBUFB   DS    A                         -''-  CURRENT   -''-
ROPTB    DS    A                         -''-  READ      -''-
AOPTABE  DS    A                       ADDR OF CURRENT OPTAB ENTRY
LATAB    DS    A                       ADDR OF LABEL ADDR TABLE
APBTAB4  EQU   LATAB                   ADDR OF PBTAB4
SUTABCA  DS    A                       ADDR OF LAST USED SUTAB ENTRY
STRETURN DS    F                       RETURN ADDR
FREEMADR DS    A                       ADDR FOR FREEMAIN IN 50000
FREEMSIZ DS    F                       SIZE          -''-
*
PBTAB3   DS    1024C                   PROGRAM BLOCK TABLE, 3RD VERS
*
IOTAB    DC    18X'00'                 LIST OF DATASETS
CII      DC    H'0'                    REGISTER CONTROL
CIR      DC    H'0'                         -''-
RII      DC    H'0'                         -''-
RIR      DC    H'0'                         -''-
OPDPBN   DC    H'0'                    PROGRAM BLOCK NR (BYTE 2 OF OPD
OPDADR   DC    H'0'                    BYTES 3 AND 4 OF OPERAND
OPDLN    DC    H'0'                    LABEL NUMBER TIMES FOUR
ZEROHW   DC    H'0'                    ZEROES
CFSN     DC    X'00'                   CURRENT FS NUMBER
MAXFSN   DC    X'FF'                   MAX FS NUMBER
CLEARDIS DC    X'F000'                 FOR CLEARING OF DISPLACEMT PART
ONEENTRY DC    H'4'                    SHORT, FOR INCR OF OT STACK PTR
         ORG   ONEENTRY
         DC    H'8'                    LONG            -''-
PRECMASK DC    X'10'                   SHORT, TO MODIFY INSTRUCTIONS
         ORG   PRECMASK
         DC    X'00'                   LONG            -''-
NUMBBL   DC    X'00'                   RECORD COUNTER
         DS    H
SPBNST   DC    H'0'                    CURRENT PBN
         DS    H                                   AND DISPLACEMENT
GPBN     DC    H'255'                  GLOBAL DSA CONTROL
MAXOVERF DC    H'4092'                 SHORT, TO CHECK OT STACK OVERFL
         ORG   MAXOVERF
         DC    H'4088'                 LONG            -''-
HALFW    DS    H                       WORKPLACE
USPEI2   DS    H                       FOR ARRAY DECLA-
USPEI4   DS    H                                       RATION HANDLING
WPLACE   DS    H                       FOR INSTRUCTION GENERATION
XPLACE   DS    H
YPLACE   DS    H
UPLACE   DS    H
VPLACE   DS    C                                   -''-
STRDNAME DS    5C                      TO STORE OPERAND
CBVTAB   DS    48C                     CALLED-BY-VALUE TABLE
SUTABC   DS    768C
         ORG   SUTABC
DSTAB    DS    608C                    DATASET TABLE
*
*        REGISTER EQUATES
*
         IEZREGS
*
*        CHARACTER EQUATES
*
         IEXCHAR
*
         END
