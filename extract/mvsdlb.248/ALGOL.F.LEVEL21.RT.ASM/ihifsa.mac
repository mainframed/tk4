FSA      TITLE 'IHIFSA, RUNTIME FIXED STORAGE AREA, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        FUNCTION/OPERATION -
*        IHIFSA IS A COLLECTION OF ABOUT 20 ROUTINES WHICH ARE
*        REQUIRED FOR THE EXECUTION OF ALGOL PROGRAMS. THE ENTRY
*        POINT AND PURPOSE OF EACH ROUTINE IS LISTED UNDER ENTRY
*        POINTS BELOW DETAILED INFORMATION ON THE FUNCTION,
*        CALLING SEQUENCE, TRANSMISSION OF PARAMETERS ETC CAN BE
*        FOUND IN THE COMMENTARY WHICH PRECEDES THE PROGRAM
*        LISTING FOR EACH ROUTINE
*
*        THE MODULE CONSISTS OF TWO CONTROL SECTIONS, IHIFSARA
*        AND IHIFSARB.
*        IHIFSARA CONTAINS THE ROUTINES, TABLES AND OTHER
*        INFORMATION USED DURING THE EXECUTION OF THE ALGOL
*        OBJECT PROGRAM
*        IHIFSARB CONTAINS MAINLY THE INITIALIZATION AND
*        TERMINATION ROUTINES WITH THEIR ASSOCIATED TABLES AND
*        WORK AREAS
*
*        R13 - BASE FOR IHIFSARA
*        R7  - BASE FOR IHIFSARB
*
*        ENTRY POINTS -
*        MOST OF THE ENTRY POINTS LISTED HERE ARE COLLECTED IN A
*        BRANCH LIST LOCATED AT BRLIST. THE ENTRY POINTS
*        CONTAINED IN THIS BRANCH LIST ARE MARKED WITH AN
*        ASTERISK AFTER THE NAME IN THE LISTING BELOW
*
*        CAP1*     - CALL ACTUAL PARAMETER
*                    PART 1. ENTER THUNK ROUTINE FROM A PROCEDURE
*        CAP2*     - CALL ACTUAL PARAMETER
*                    PART 2. RETURN FROM THE THUNK ROUTINE TO
*                    THE PROCEDURE
*        PROLOGP*  - ENTER A PROCEDURE WHEN IT IS CALLED VIA AN
*                    ACTUAL PARAMETER
*        PROLOG*   - ENTER A BLOCK OR A PROCEDURE
*        RETPROG*  - LEAVE A BLOCK OR PROCEDURE VIA A 'GO TO'
*                    STATEMENT
*        EPILOGP*  - RETURN FROM A PROCEDURE VIA THE 'END'
*                    STATEMENT
*        EPILOGB*  - LEAVE A BLOCK VIA THE 'END' STATEMENT
*        FRDSA     - FREE STORAGE FOR DSA AND ARRAYS
*                    SYNONYM FOR EPILOGB WHEN USED AS A SUBROUTINE
*                    BY THE ERROR ROUTINE IHIERROR
*        CSWE1*    - CALL SWITCH ELEMENT, PART 1
*        CSWE2*    - CALL SWITCH ELEMENT, PART 2
*        LOADPP*   - LOAD A PRECOMPILED PROCEDURE
*        SPDECL    - STANDARD PROCEDURE DECLARATION ROUTINE
*                    (ENTERED VIA THE PROLOG ROUTINE)
*        VALUCALL* - HANDLE FORMAL PARAMETERS CALLED BY VALUE
*        GETMSTO*  - GET MAIN STORAGE FOR ARRAYS
*        CNVIRD    - CONVERT INTEGER TO REAL
*        CNVRDI    - CONVERT REAL TO INTEGER
*        ENTIER    - EXECUTE ALGOL ENTIER FUNCTION
*        TRACE*    - STORE THE CURRENT SEMICOLON NUMBER
*        IHGFSAIN  - INITIALIZE FOR PROGRAM EXECUTION AND GIVE
*                    CONTROL TO THE OBJECT MODULE
*        TERMNTE*  - TERMINATE THE EXECUTION
*        PIEROUT   - PROGRAM INTERRUPT ROUTINE
*        FSAERR    - STORE ERROR NUMBER AND CALL THE ERROR
*                    ROUTINE IHIERROR
*
*        INPUT -
*        IF THE TRACE OPTION IS USED, THE TERMINATION ROUTINE MAY
*        READ A TABLE OF SEMICOLON NUMBERS, WHICH HAS BEEN
*        WRITTEN ON SYSUT1 BY THE TRACE ROUTINE
*
*        OUTPUT -
*        IF THE TRACE OPTION IS USED, THE TRACE ROUTINE MAY WRITE
*        A TABLE OF SEMICOLON NUMBERS ON SYSUT1. THIS TABLE IS
*        READ AND THEN WRITTEN ON SYSPRINT IN EDITED FORMAT BY
*        THE TERMINATION ROUTINE.
*        THE MESSAGE 'END OF ALGOL PROGRAM EXECUTION' IS WRITTEN
*        ON SYSPRINT AS THE FINAL OUTPUT FROM THE EXECUTION.
*
*        EXTERNAL ROUTINES -
*        IHIIOROP - OPEN A DATASET (USED ONLY FOR SYSPRINT)
*        IHIIORCL - CLOSE A DATASET (USED ONLY FOR SYSPRINT)
*        IHIIORCP - CLOSE ALL OPEN DATASETS (EXCEPT SYSUT1)
*        IHIIORNX - HANDLE THE NEXT I/O RECORD
*        IHIERROR - EDIT AND PRINT AN ERROR MESSAGE AND, IF
*                   REQUESTED, AN ALGOL STORAGE DUMP.
*                   (ENTERED BY CALL)
*
*        THE FOLLOWING TWO EXTERNAL TABLES ARE IN THE OBJECT
*        MODULE -
*        IHIENTIF - INFORMATION NEEDED FOR ENTERING THE OBJECT MODULE
*             FORMAT -
*             IHIENTIF DC A(PBTAB)  ADDR OF PROGRAM BLOCK TABLE
*                      DC A(LATAB)  ADDR OF LABEL ADDR TABLE
*                      DC X'02' OR X'00' FOR SHORT/LONG PREC
*                      DC AL3(ENTRYPOINT)  ADDR OF FIRST INSTRUCTION
*
*        IHIDSTAB - INFORMATION ABOUT THE STATUS OF EACH DATASET USED
*             FORMAT AND USE -
*             SEE THE DSECT DSTABLE AND THE LISTING OF
*             THE I/O SUBROUTINE MODULE IHIIORTN
*
*        EXITS - NORMAL -
*        THE TERMINATION ROUTINE IS ENTERED BY A BRANCH TO
*        TERMNTE, AND A FINAL RETURN IS BY A RETURN MACRO WITH
*        THE RETURN CODE ZERO IN R15
*
*        EXITS - ERRORS -
*        ON RETURN FROM THE ERROR ROUTINE IHIERROR, THE
*        TERMINATION ROUTINE IS ENTERED BY A BRANCH TO ALGTRMA,
*        AND A FINAL RETURN IS MADE BY A RETURN MACRO WITH THE
*        RETURN CODE 16 IN R15
*
*        TABLES/WORK AREAS -
*        THE LOWER PART OF IHIFSARA CONTAINS A BLOCK OF WORK
*        AREAS AND CONSTANTS WHICH ARE USED IN COMMON BY SEVERAL
*        ROUTINES.
*        THE MOST IMPORTANT ARE -
*        SAVE     - STANDARD SAVEAREA USED BY ALL FIRST LEVEL
*                   SUBROUTINES EXCEPT THOSE CONTAINED IN THIS MODULE
*        ASAVE    - SAVE AREA USED BY SOME ROUTINES IN THIS MODULE
*        FCTVALST - STORAGE FOR THE RESULT OF AN ALGOL FUNCTION
*        PROLPBN  - PROGRAM BLOCK NUMBER OF A BLOCK OR PROCEDURE
*                   TO BE ENTERED VIA THE PROLOG ROUTINE
*        PGOPSW   - THE OLD PSW IN CASE OF A PROGRAM INTERRUPT
*        SCRCS    - THE CURRENT SEMICOLON NUMBER
*        OPTSW    - FLAG BITS REPRESENTING EXECUTION TIME OPTIONS
*                   AND SWITCHES FOR CONTROLLING THE PROGRAM FLOW
*        FSAERCOD - ERROR NUMBER IDENTIFYING AN EXECUTION ERROR
*        IHIFSARS - FOUR POINTERS FOR CONTROLLING THE RETURN
*                   ADDR STACK
*        BRLIST   - A LIST OF ENTRY POINTS TO MOST OF THE ROUTINES
*                   MENTIONED UNDER 'ENTRY POINTS'. THE LIST CONSISTS
*                   MAINLY OF BRANCH INSTRUCTIONS
*        IHIFSAER - A LIST OF BAL INSTRUCTIONS, EACH
*                   CORRESPONDING TO ONE TYPE OF ERROR, THE
*                   NUMBER OF WHICH IS DETERMINED BY ITS POSITION
*                   IN THE LIST
*
*        OTHER WORK AREAS AND CONSTANTS OF GENERAL
*        INTEREST ARE -
*        PARMLIST - A LIST OF THE VALID EXECUTION OPTION
*                   PARAMETERS
*        TRBUF    - BUFFER POINTERS AND RECORD COUNTER FOR
*                   CONTROLLING THE OUTPUT OF TRACING
*                   INFORMATION ON SYSUT1
*        PIETAB   - A LIST OF 16 ADDR CONSTANTS EACH POINTING
*                   TO AN ENTRY IN IHIFSAER, WHICH CORRESPONDS
*                   TO A TYPE OF PROGRAM INTERRUPT
*        FPINST   - A LIST OF FLOATING POINT INSTRUCTIONS USED BY
*                   THE VALUCALL AND SPDECL ROUTINES
*        CNVINSTE - INSTRUCTIONS TO BE INSERTED INTO THE CONVERT
*                   ROUTINE FOR SHORT PRECISION
*        CNVINSTD - INSTRUCTIONS TO BE INSERTED INTO THE CONVERT
*                   ROUTINE FOR LONG PRECISION
*
*        ATTRIBUTES - THIS MODULE IS SERIALLY REUSABLE
*
*        NOTES -
*        THIS MODULE IS ONLY INTENDED TO BE USED WHEN LINKAGE
*        EDITED TOGETHER WITH AN OS/360 ALGOL OBJECT MODULE AND
*        WITH THE OS/360 ALGOL I/O ROUTINES. FOR REASONS OF
*        EFFICIENCY CERTAIN LOCAL CONVENTIONS ARE OBEYED IN THE
*        COMMUNICATION BETWEEN THESE MODULES
*        REGISTER SAVING AND RESTORING IS ONLY DONE WHEN
*        REQUIRED AND THEN GENERALLY IN A NON STANDARD FASHION
*
*        USE OF GENERAL REGISTERS WHEN COMMUNICATING WITH THE
*        OBJECT MODULE -
*        R8 (ADR)    MAY BE USED AS RETURN REGISTER AND
*                    PARAMETER POINTER
*        R10 (CDSA)  -> CURRENT ACTIVE DATA STORAGE AREA
*        R11 (PBT)   -> PROGRAM BLOCK TABLE IN THE OBJECT MODULE
*        R12 (LAT)   -> LABEL ADDR TABLE IN THE OBJECT MODULE
*        R13 (FSA)   SERVES BOTH AS THE STANDARD SAVE AREA
*                    REGISTER AND AS BASE REGISTER FOR THE
*                    CSECT IHIFSARA
*        R14         TRANSMIT INTEGER VALUES TO OR
*                    FROM CONVERT ROUTINES
*        R15         RETURN REGISTER AND PARAMETER POINTER
*        FP0         TRANSMIT REAL VALUES TO OR FROM CONVERT ROUTINES
*
*        USE OF GENERAL REGISTERS WHEN COMMUNICATING WITH THE
*        I/O ROUTINES -
*
*        R5      (DSN)    -> RELEVANT ENTRY IN THE DATASET TABLE
*        R6      (DSNR)      DATASET NUMBER
*        R12     (FSAA)      BASE ADDR OF IHIFSARA
*
*        PARAMETER VALUES AND OTHER INFORMATION ARE OFTEN
*        TRANSMITTED IMPLICITLY VIA THE COMMONLY ACCESSIBLE
*        WORKING STORAGE IN THE LOWER PART OF IHIFSARA AND (FOR
*        I/O ROUTINES) VIA THE DATASET TABLE IN THE OBJECT
*        MODULE
*
*        THE MODULE WORKS FOR EITHER SINGLE OR DOUBLE FLOATING
*        POINT PRECISION. IT SENSES THE PRECISION FOR WHICH THE
*        OBJECT MODULE WAS COMPILED AND INITIALIZES ITSELF
*        ACCORDINGLY. THE AREAS AFFECTED ARE THE LIST OF FLOATING
*        POINT INSTRUCTIONS AT FPINST AND THE BLOCK OF
*        INSTRUCTIONS STARTING AT CNVINST IN THE CONVERT
*        ROUTINES
*
*        THE OPERATION OF THIS MODULE DEPENDS UPON AN INTERNAL
*        REPRESENTATION OF THE EXTERNAL CHARACTER SET WHICH IS
*        EQUIVALENT TO THE ONE USED AT ASSEMBLY TIME
*
IHIFSARA CSECT
*
*        REGISTERS FOR COMMUNICATION WITH THE OBJECT MODULE
*
*        R8                            ADDRESSING REGISTER
GDSA     EQU   9                       GLOBAL DSA
CDSA     EQU   10                      CURRENT DSA
PBT      EQU   11                      PROGRAM BLOCK TABLE
LAT      EQU   12                      LABEL ADDR TABLE
*        R13                           IHIFSARA BASE REGISTER
*
*        REGISTERS FOR COMMUNICATION WITH I/O SUBROUTINES
*
*        R5                            -> DATASET TABLE ENTRY
*        R6                            DATASET NUMBER
FSAA     EQU   12                      ALTERNATE FSA BASE REGISTER
*
*        REGISTERS USED BY TRACE AND TERMINATION ROUTINES
*
*        R4                            BYTE POINTER IN TRACE BUFFER
*        R5                            SEMICOLON NUMBER
*        R6                            LOWER TRACE LIMIT
*        R7                            UPPER TRACE LIMIT
*        R8                            TRACE BUFFER ADDR
*        R9                            ALTERNATE TRACE BUFFER ADDR
*        R10                           LENGTH OF TRACE BUFFER
*        R11                           NUMBER OF TRACE RECORDS
*
*        FLOATING POINT REGISTER
*
FPR0     EQU   0
*
*        BIT PATTERNS
*
BETABM   EQU   X'0C'                   MASK FOR BETA BLOCK FLAG IN PBT
CODEPRM  EQU   X'10'                   MASK FOR CODE PROCEDURE IN PBT
PIMASK   EQU   X'04'                   MASK FOR PI PROCEDURE IN PBT
RASLOADM EQU   X'FE'                   LOAD PROCEDURE ENTRY IN RAS
RASPARMM EQU   X'00'                   CAP OR CSWE ENTRY IN RAS
SHORTBIT EQU   X'10'                   FP OPCODE MODIFIER
*
*        SWITCHES IN OPTSW
*
DPSW     EQU   X'80'                   DUMP  OPTION SWITCH
TRSW     EQU   X'40'                   TRACE OPTION SWITCH
SHSW     EQU   X'20'                   SHORT PRECISION OPTION SWITCH
TERMSW   EQU   X'10'                   TERMINATION ROUTINE ENTERED
ERROR    EQU   X'08'                   ERROR ROUTINE ENTERED
UT1ERR   EQU   X'04'                   ERROR ON SYSUT1
PRNTERR  EQU   X'02'                   ERROR ON SYSPRINT
UCTRSW   EQU   X'41'                   UNCONDITIONAL TRACE OPTION
PPTRSW   EQU   X'01'                   TRACE PRECOMP PROCEDURES
*
*        ESD SYMBOLS
*
         ENTRY IHIFSAIN
*
         EXTRN IHIENTIF
         EXTRN IHIIOROP,IHIIORCL,IHIIORNX,IHIIORCI,IHIIOREV
         EXTRN IHIIOROQ,IHIIOREN,IHIIORGP,IHIIORCP,IHIIORER
*
         COPY  FSAREA
*
         COPY  FSACONV
*
         ORG   FSAREA+ADSTAB
         DC    V(IHIDSTAB)            DS TABLE GENERATED BY COMPILATION
*
***********************************************************************
*
*        INSTRUCTIONS/DATA INSERTED INTO THE FSA AT BRLIST
*
***********************************************************************
*
         ORG   BRLIST
         USING IHIFSARA,R13
*
         B     CAP1A                   CAP1
         B     CAP2A                   CAP2
         B     PROLP                   PROLOGP
         B     PROL                    PROLOG
         B     RETPROGA                RETPROG
         B     EPILP                   EPILOGP
         B     EPILB                   EPILOGB
         B     EPIL3                   EPILPR3
         B     CSWE1A                  CSWE1
         B     CSWE2A                  CSWE2
         B     LOADPPA                 LOADPP
*
*        TRACE
*
         MVC   SCRCS(2,R13),0(R15)     INSERT SEMICOLON NUMBER
         B     2(R15)                  MODIFIED TO NOP IF TRACE
         B     TRACEA
         B     TERMN                   TERMNTE
         NOPR  R15                     BCR
         B     GETMAIN                 GETMSTO
         B     VALUCAL                 VALUCALL
*
*        COMMON I/O ROUTINES IHIIOR @ IORLST
*
         DC    A(ADRLST)
*
***********************************************************************
*
*        EXITS FOR EXECUTION ERRORS
*
***********************************************************************
*
*
*        ENTRY POINTS FOR ALL TYPES OF EXECUTION ERRORS
*
*        STORE THE ERROR NUMBER AND LINK TO THE ERROR
*        ROUTINE IHIFSAER
*        THE NUMBER OF EACH ERROR IS DETERMINED BY ITS POSITION
*        IN THE BRANCH LIST
*
*        CALLING SEQUENCE -
*        BC    ERRORCONDITION,FSAERR+4*ERRORNUMBER(R13)
*
         ORG   FSAERR+FSAREA
*
IHIFSAER BAL   R1,FSAERRL               0
         BAL   R1,FSAERRL               1
         BAL   R1,FSAERRL               2
         BAL   R1,FSAERRL               3
         BAL   R1,FSAERRL               4
         BAL   R1,FSAERRL               5
         BAL   R1,FSAERRL               6
         BAL   R1,FSAERRL               7
         BAL   R1,FSAERRL               8
         BAL   R1,FSAERRL               9
         BAL   R1,FSAERRL              10
         BAL   R1,FSAERRL              11
         BAL   R1,FSAERRL              12
         BAL   R1,FSAERRL              13
         BAL   R1,FSAERRL              14
         BAL   R1,FSAERRL              15
         BAL   R1,FSAERRL              16
         BAL   R1,FSAERRL              17
NOMAIN   EQU   *-FSAREA                     GETMAIN FAILURE
         BAL   R1,FSAERRL              18
         BAL   R1,FSAERRL              19
ERROR20  EQU   *
OERR20   EQU   *-FSAREA
PARERR   EQU   *-FSAREA
         BAL   R1,FSAERRL              20
ERROR21  BAL   R1,FSAERRL              21
         BAL   R1,FSAERRL              22
         BAL   R1,FSAERRL              23
         BAL   R1,FSAERRL              24
         BAL   R1,FSAERRL              25
         BAL   R1,FSAERRL              26
ERROR27  BAL   R1,FSAERRL              27
ERROR28  BAL   R1,FSAERRL              28    0C8 FROM SPIE
ERROR29  BAL   R1,FSAERRL              29    0CC FROM SPIE
ERROR30  BAL   R1,FSAERRL              30    0C9 FROM SPIE
ERROR31  BAL   R1,FSAERRL              31
ERROR32  BAL   R1,FSAERRL              32
ERROR33  BAL   R1,FSAERRL              33    0CX FROM SPIE
ERROR34  EQU   *
SWDMERR  EQU   *-FSAREA
         BAL   R1,FSAERRL              34
ERROR35  BAL   R1,FSAERRL              35
ERROR36  EQU   *
RASOVERF EQU   *-FSAREA
         BAL   R1,FSAERRL              36
         BAL   R1,FSAERRL              37
         BAL   R1,FSAERRL              38
         BAL   R1,FSAERRL              39
         BAL   R1,FSAERRL              40
DDERROR  EQU   *-FSAREA
         BAL   R1,FSAERRL              41
INVOPT   EQU   *-FSAREA
         BAL   R1,FSAERRL              42
         BAL   R1,FSAERRL              43
*
*        CALL ERROR ROUTINE IHIERROR
*
FSAERRL  LA    R1,0(,R1)               ZERO HIORDER BYTE
         S     R1,=A(IHIFSAER+4)       SUBTRACT BAL ADDR
         STC   R1,FSAERCOD(,R13)       SAVE ERROR CODE
         TM    OPTSW(R13),ERROR        TO PREVENT ENTERING
         BO    TERMAA                  ERROR ROUTINE
         OI    OPTSW(R13),ERROR        MORE THAN ONCE
*
         CALL  IHIERROR,                                               X
               (FRDSA,SPDAP,IHIIOROP,IHIIORCP,IHIIORNX)
*
         USING IHIFSARB,R7
*
*        ABNORMAL TERMINATION
*
TERMA    L     R7,=A(IHIFSARB)
         TM    OPTSW(R13),TERMSW
         BO    ALGTRMAA                IF ERROR IN TERM ROUTINE
         B     ALGTRMA
*
*        VERY ABNORMAL TERMINATION
*
TERMAA   L     R7,=A(IHIFSARB)
         B     ALGTRMAA
*
*        NORMAL TERMINATION
*
TERMN    L     R7,=A(IHIFSARB)
         B     ALGTRM0
*
         DROP  R7
         ORG
*
***********************************************************************
*
*        INSTRUCTIONS FOR SHORT OR LONG FLOATING POINT PRECISION
*
***********************************************************************
*
*        THE FOLLOWING INSTRUCTIONS ARE MODIFIED BY THE
*        INITIALIZATION ROUTINE FOR SHORT OR LONG PRECISION AS
*        REQUIRED
*
FPINST   EQU   *
*                                       USED BY VALUCALL
VALLD    LE    0,0(R1)
VALST    STE   0,0(R2)
*                                       USED BY SPDECL
LINSTR   LE    0,0(R2)
STINSTR  STE   0,FCTVALST(,R13)
LTRINSTR LTER  0,0
         NOPR  0
FPINSTE  EQU   *
LPRINSTR LPER  0,0
*
FPINSTAD DC    A(FPINST,4,FPINSTE)
*
*        ONE OF THE FOLLOWING SETS OF INSTRUCTIONS IS INSERTED
*        INTO THE CONVERT ROUTINE BY THE INITIALIZATION ROUTINE
*        IN ORDER TO SET UP FOR LONG OR SHORT PRECISION AS
*        REQUIRED
*
*        SHORT PRECISION
*
CNVINSTE STD   FPR0,CNVBUF2
         MVC   CNVBUF2+1(3),CNVCNST1+1
         AD    FPR0,CNVBUF2
         BR    R8
*
         STE   FPR0,CNVBUF3
         LD    FPR0,CNVBUF3
         B     ENTIER1
*
         STE   FPR0,CNVBUF3
         LD    FPR0,CNVBUF3
*
*        LONG PRECISION
*
CNVINSTD BR    R8
*
         DC    14X'FF'
         B     ENTIER1
*
         DC    8X'FF'
         AD    FPR0,CNVCNST2
         B     ENTIER1
*
CNVINSTL EQU   *-CNVINSTD
*
***********************************************************************
*
*        GETMAIN ROUTINE
*
***********************************************************************
*
*        ISSUE A CONDITIONAL GETMAIN IN RESPONSE TO A REQUEST BY
*        THE OBJECT MODULE FOR STORAGE FOR AN ARRAY. IF STORAGE
*        IS NOT AVAILABLE, AN ERROR EXIT IS TAKEN
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        BAL   R8,GETMSTO(R13)         LENGTH OF AREA IN R0
*        ---                           RETURN WITH ADDR IN R1
*
GETMAIN  LR    R2,R0                   LENGTH VALUE
*
         GETMAIN EC,LV=(R2),A=STORAGE
*
         LTR   R15,R15                 GETMAIN SUCESSFULL ?
         BNZ   NOMAIN(,R13)            NO, BRANCH TO ERROR RTN
         L     R1,STORAGE              YES, R1 -> STORAGE
         BR    R8                      RETURN TO CALLING PROG
*
STORAGE  DC    A(0)                    ADDR OF THE AREA GETMAINED
*
***********************************************************************
*
*        CALL ACTUAL PARAMETER ROUTINE
*
***********************************************************************
*
*
*        THIS ROUTINE IS AN INTERMEDIATE LINK BETWEEN A PROCEDURE
*        AND THE THUNK FOR AN ACTUAL PARAMETER TO THE PROCEDURE.
*        IT SEARCHES THE DSA CHAIN FOR THE DSA OF THE PROCEDURE
*        DECLARATION. THEN IT LOADS THE THUNK ADDR FROM THIS
*        DSA, LOADS CDSA WITH THE DSA ADDR OF THE ENCLOSING
*        BLOCK AND BRANCHES TO THE THUNK
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        BAL   R15,CAP1(R13)
*        DC    H'PBN1'                 PBN OF PROCEDURE
*        DS    H
*        L     R8,DISPL(CDSA)          LOAD ADDR OF THUNK
*        ---                           RETURN FROM THUNK VIA CAP2
*                                      WITH PARAM ADDR IN R8
*
CAP1A    EQU   *
CAPA     L     R14,RASPT(,R13)         RAS POINTER FROM TOP
         ST    R15,12(,R14)            SAVE RETURN ADDR IN RAS
         LH    R1,0(,R15)              PBN OF PROCEDURE
         LA    R1,0(R1,PBT)            PROCEDURE ENTRY IN PBT
CAPI1    LA    R14,8(,R14)             RESERVE ONE ENTRY IN RAS
         C     R14,RASPB(,R13)         STACK OVERFLOW ?
         BNL   RASOVERF(,R13)
         ST    CDSA,0(,R14)            SAVE DSA POINTER IN RAS
         AH    PBT,8(,CDSA)            ADDR OF CURRENT PBT ENTRY
         L     R2,0(,CDSA)             LAST GENERATION DSA POINTER
         ST    R2,0(,PBT)              IS STORED IN PBT ENTRY
         CR    R1,PBT                  RIGHT PROCEDURE REACHED
         EX    0,4(,R15)               LOAD ADDR OF THUNK
         L     CDSA,4(,CDSA)           LOAD DYNAMICALLY ENCLOSING DSA
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         ST    R14,RASPT(,R13)         SAVE RAS TOP POINTER
         BZR   R8                      TO THUNK OF ACTUAL PARAM
*                                      IF RIGHT BLOCK REACHED
         SR    R2,R2                   ZERO TO RETURN ENTRY IN
         ST    R2,12(,R14)             RAS INSTEAD OF R15
         B     CAPI1
*
*        HANDLE THE TRANSFER FROM THE THUNK BACK TO THE PROCEDURE
*
*        RELOAD CDSA WITH THE ADDR OF THE DSA THAT WAS ACTIVE
*        WHEN CAP1 WAS ENTERED
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        B     CAP2(R13)
*
CAP2A    EQU   *
CAPB     EQU   *
         L     R14,RASPT(,R13)         RAS POINTER FROM TOP
CAPI3    L     CDSA,0(,R14)            DSA POINTER FROM RAS
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         L     R15,4(R14)              RETURN ADDR FROM RAS
         SH    R14,EIGHT(,R13)         RELEASE ONE ENTRY IN RAS
         LH    R1,8(,CDSA)             PROGRAM BLOCK NUMBER TO REG
         ST    CDSA,0(R1,PBT)          CURRENT DSA POINTER TO PBT
         LTR   R15,R15                 CALLING BLOCK REACHED
         BZ    CAPI3                   NO CONTINUE
CAPI4    ST    R14,RASPT(R13)          SAVE RAS TOP POINTER
         B     8(,R15)                 RETURN TO CALLING SEQUENCE
*
***********************************************************************
*
*        PROLOGUE PROGRAM
*
***********************************************************************
*
*        THIS ROUTINE IS EXECUTED WHENEVER A BLOCK OR PROCEDURE
*        IS TO BE ENTERED
*
*        IT CREATES AND INITIALIZES A NEW DSA. FOR A PROCEDURE
*        WITH PARAMETERS IT MOVES THE PARAMETER LIST TO THE DSA
*        AND CHECKS IT AGAINST THE FORMAL PARAMETER LIST IN THE
*        PROCEDURE DECLARATION. THEN IT ENTERS THE BLOCK OR
*        PROCEDURE
*        THE ENTRY POINT PROLOGP IS USED ONLY WHEN THE PROCEDURE
*        IS CALLED VIA AN ACTUAL PARAMETER TO ANOTHER
*        PROCEDURE
*
*        CALLING SEQUENCE (ENTRY VIA BRLIST)
*        BAL   R15,PROLOG(R13)
*        MVI   PROLPBN(R13),PBN         PBN OF BLOCK TO BE ENTERED
*                                       PARAMETER LIST FOR PROCEDURE
*        DC    A(THUNK1)                ADDR OF THUNK FOR 1ST PARAM
*        DC    H'CH'                    CHARACTERISTICS OF 1ST PARAM
*        DC    H'N'                     NUMBER OF PARAMETERS
*         .
*         .
*         .
*        DC    A(THUNKN)                ADDR OF THUNK FOR LAST PARAM
*        DC    H'CH'
*        DC    H'0'
*
PROLP    MVI   PROLPBN-1(R13),X'00'
*
*        SET OFF SW SET BY GENERATE PROG TO DETECT ERROR
*        SEE BELOW
*
         LM    PBT,LAT,PROLREG(R13)    UPDATE PBT AND LAT
*
PROL     LH    R3,PROLPBN-1(,R13)      CALLED PROGRAM BLOCK NUMBER
         SLL   R3,3                    CALCULATE PBT DISPLACEMENT
         LTR   R2,R3                   STANDARD PROCEDURE CALLED ?
         BZ    SPDECL(,R13)            YES, BRANCH
         BM    OERR21(,R13)            ERROR, ACTUAL PROCEDURE
*
*        PARAMETER IS PARAMETERLESS WHILE FORMAL PROCEDURE IS
*        CALLED WITH PARAMETERS
*        PROLPBN-1 WAS SET TO X'FF' BY GENERATED PROG BEFORE CAP1
*        WAS CALLED
*
         AR    R3,PBT                  ADDR OF PBT ENTRY
         TM    6(R3),BETABM            PROCEDURE CALLED ?
         BZ    PROLOG1                 NO
         C     R8,ASTLOC(,R13)         COMP CONT OF ADDR WITH ADDR OF
*                                      FUNCTION VALUE STORAGE
         BE    OERR21(,R13)            EQUAL, BRANCH
         TM    6(R3),CODEPRM           CODE PROCDURE CALLED ?
         BO    PROLOG2                 YES.
PROLOG1  LH    R0,4(,R3)               LENGTH OF DSA TO REG 0
         LR    R4,R15                  SAVE R15 DURING GETMAIN
*
         GETMAIN R,LV=(0)              GETMAIN FOR DSA
*
         LR    R15,R4
         L     R0,0(R2,PBT)            LOAD POINTER OF LAST GENERATION
         ST    R0,0(,R1)               STORE IT IN DSA
         ST    CDSA,4(,R1)             STORE POINTER OF EMBRACING PB
         STH   R2,8(,R1)               STORE PBT DISPLACEMENT
         MVI   10(R1),0                ZEROS TO VALUE ARRAY AND
         MVC   11(5,R1),10(R1)         ARRAY POINTERS
         ST    R1,0(R2,PBT)            STORE CURR DSA POINTER IN PBT
         LR    CDSA,R1                 SET CDSA POINTER
         STM   PBT,LAT,16(CDSA)
         L     R14,RASPT(R13)          RAS-POINTER TOP
         LA    R14,8(,R14)             RESERVE ONE ENTRY
         C     R14,RASPB(R13)          COMPARE WITH RAS-POINTER BOTTOM
         BNL   RASOVERF(R13)           STACK OVERFLOW
         ST    CDSA,0(,R14)
         MVI   0(R14),X'FF'
         ST    R14,RASPT(R13)          SAVE POINTER
         TM    6(R3),BETABM            PROCEDURE CALLED ?
         BZR   R15                     NO, USUAL BLOCK RETURN, EXIT 1
A4       CLI   7(R3),0                 ANY FORMAL PARAMETERS ?
         BE    F4                      ZERO, BRANCH
         CLC   7(1,R3),7(R15)          COMP NO OF FORM AND ACT PARAM
         BNE   OERR21(,R13)            ^=, BRANCH
         SR    R2,R2
         IC    R2,7(,R3)               FETCH NUMBER OF PARAMETERS
         LR    R4,R2                   SAVE NUMBER IN R4
         SLL   R2,3                    CALCULATE LENGTH OF PARAMETER
         BCTR  R2,0                    ENTRY-1
         LA    R1,24(CDSA)             START OF PARAM IF PROC
         TM    6(R3),PIMASK            FUNCTION PROCEDURE CALLED
         BZ    PROLOG3                 YES
         EX    R2,PIMOVE
         B     LOOP
*
PIMOVE   MVC   24(1,CDSA),0(R15)       MOVE PROCEDURE PARAMETERS
PHIMOVE  MVC   32(1,CDSA),0(R15)       MOVE FUNCTION PARAMETERS
PROLOG3  EX    R2,PHIMOVE
         LA    R1,8(R1)                START OF PARAM. IF TYPE
LOOP     TM    0(R8),X'01'             FORM PAR 'STRING' ?
         BO    STRTST                  YES, GOTO STRINGTEST
         CLI   1(R8),X'D0'             FORM PAR 'PROC' WITHOUT TYP ?
         BE    PROTST                  YES, GOTO PROCEDURE TEST
         CLI   1(R8),X'1C'             FORM PAR 'SWITCH' ?
         BE    SWTTST                  YES, GOTO SWITCH TEST
         TM    1(R8),X'08'             FORM PAR 'LABEL' ?
         BO    LBLTST                  YES, GOTO LABEL TEST
         TM    1(R8),X'04'             FORM PAR 'ARRAY' ?
         BO    ARRTST                  YES, GOTO ARRAY TEST
         TM    1(R8),X'C0'             FORM PAR A TYP PROCEDURE ?
         BO    TPRTST                  YES, GOTO TYP PROCEDURE TEST
         TM    5(R15),X'04'            ACT PAR 'ARRAY' ?
         BO    OERR20(,R13)            YES, ERR 20
TYPTST   TM    1(R8),X'03'             TEST TYP
         BM    ARITST                  IF ARITHM TYP GOTO ARITH TEST
         TM    5(R15),X'03'            ACT PAR BOOL ?
         BO    ASSFLAG                 YES, SPECIAL ASSIGNMENT TEST
         B     OERR20(,R13)            NO, GOTO ERR 20
*
STRTST   TM    4(R15),X'01'            ACT PAR 'STRING' ?
         BO    EXIT                    YES, TEST NEXT PAR
         B     OERR20(,R13)            NO, BRANCH TO OBJEXT TIME ERR 20
*
PROTST   TM    5(R15),X'C0'            ACT PAR IS 'PROCEDURE' ?
         BZ    OERR20(,R13)            NO, ERR 20
         B     EXIT                    YES, TEST NEXT PAR
*
SWTTST   TM    5(R15),X'0C'            ACT PAR 'SWITCH' ?
         B     STRTST+4                BRANCH TO STRTST+4 TO TEST CC
*
LBLTST   TM    5(R15),X'08'            ACT PAR 'LABEL' ?
         BZ    OERR20(,R13)            NO, ERR 20
         TM    5(R15),X'04'            ACT PAR 'SWITCH' ?
         BO    OERR20(,R13)            YES, ERR 20
         B     EXIT                    TEST NEXT PAR
*
ARRTST   TM    5(R15),X'04'            ACT PAR 'ARRAY' ?
         BZ    OERR20(0,R13)           NO, ERR 20
         B     TYPTST                  YES, GOTO TYP TEST
*
TPRTST   TM    5(R15),X'C0'            ACT PAR 'PROCEDURE' ?
         BZ    OERR20(0,R13)           NO, ERR 20
         B     TYPTST                  YES, GOTO TYP TEST
*
ARITST   TM    5(R15),X'03'            ACTUAL PAR ARITHMETIC ?
         BNM   OERR20(R13)             NO
         TM    1(R8),X'10'             FORMAL PARAMETER CALLED BY NAME?
         BZ    PARAMPR                 NO
         TM    1(R8),X'02'             FORMAL PARAMETER REAL TYPE ?
         BZ    INTTST                  NO, INTEGER TYPE
         TM    5(R15),X'02'            ACTUAL PARAMETER REAL ?
         BZ    OERR20(R13)             NO, ERROR
         B     ASSFLAG2                SPECIAL ASSIGNMENT TEST
*
INTTST   TM    5(R15),X'01'            ACTUAL PARAMETER INTEGER ?
         BZ    OERR20(R13)             NO, ERROR
*
*        SPECIAL TEST IF ACTUAL PARAMETER IS FORMAL BY NAME AND
*        THEN MOVE THE ASGNMENT FLAG FR ACT PARAMETER ENT IN DSA
*        TO THE NEW PARAMETER ENT IN DSA OF BLK TO BE ENTERED
*
*        NOTE: THIS CODE IS EXTREMELY DEPENDENT ON CODE
*        GENERATED FOR FORMAL PARAMETERS CALLED BY NAME
*
ASSFLAG  TM    1(R8),X'10'             FORMAL PARM BY NAME ?
         BZ    PARAMPR                 NO
ASSFLAG2 TM    5(R15),X'10'            ACT IS TYPE CALLED BY NAME ?
         BZ    PARAMPR
         TM    5(R15),X'20'            IF NOT GOTO SPECIAL
         BO    PARAMPR                 PARAMETERLESS PR TEST
         L     R2,4(CDSA)              DSA OF CALLING SEQUENSE
         L     R2,16(,R2)              PBT ADDR OF CALLING SEQ
         L     R3,0(,R1)               ADDR OF THUNK OF ACT PARM
*                                      WHICH IS FORMAL
         MVC   ORI+5(1),11(R3)         MOVE DISPL OF PARAM FOUND
*                                      IN THUNK CODE TO OR INST
         IC    R3,4(,R3)               DISPLACEMENT OF
         N     R3,MASKFF               PROCEDURE IN PBT
         L     R3,0(R3,R2)             ADDR OF DSA OF PROCEDURE
         LA    R3,4(,R3)               ADDR CHARACTERISTIC PART
*                                      OF PARAMETER ENTRY
ORI      OC    4(1,R1),0(R3)           MOVE ASGNMENT BIT FROM
*                                      CALLING PARAMETER ENT IN
*                                      DSA TO NEW DSA ENT
*
*        TEST IF ACTUAL PARAMETER IS PARAMETERLESS PROCEDURE
*
PARAMPR  TM    5(R15),X'C0'            ACTUAL PARAMETER PROCEDURE ?
         BZ    EXIT                    NO
         TM    5(R15),X'30'
         BM    EXIT
         TM    1(R8),X'D0'             FORMAL PROC CALLED BY NAME ?
         BO    EXIT                    YES, EXIT
         TM    4(R15),X'C0'            PROCEDURE CALLED ?
         BO    OERR20(R13)
EXIT     LA    R15,8(,R15)             GET NEXT ACT PAR ADDR
         LA    R8,2(,R8)               GET NEXT FORM PAR ADDR
         LA    R1,8(,R1)               NEXT PARAMETER IN DSA
         BCT   R4,LOOP                 IF A NEXT PAR OCCURS GOTO LOOP
F4       ST    R15,4(,R14)             STORE RETURN ADDR IN RAS
         BR    R8                      EXIT 2
*
*        PRECOMPILED PROCEDURE CALLED
*
PROLOG2  L     R1,0(,R3)               ADDR OF PRECOMP PR CONST
         LM    PBT,LAT,0(R1)           LOAD NEW PBT AND LAT ADDRS
         CLC   7(1,R3),15(PBT)         PARAMETER DEFINITION IN CODE
*                                      PROCEDURE SAME AS IN LOADED
*                                      PRECOMPILED PROCEDURE ?
         BNE   OERR21(R13)             NO, ERROR 21
         L     R8,8(,R1)               PROCEDURE DECLAR ENTRY POINT
         MVI   PROLPBN(R13),1          PBN OF PROCEDURE IS 1
         B     PROLOG(R13)             CALL PRECOMPILED PROCEDURE
*
MASKFF   DC    X'000000FF'             MASK TO CLEAR 3 BYTES OF REG
*
***********************************************************************
*
*        VALUE CALL ROUTINE
*
***********************************************************************
*
*        SUBROUTINE FOR HANDLING FORMAL PARAMETERS
*
*        CALLED BY VALUE
*
*        USED FOR FORMAL PARAMETERS OF TYPE REAL, INTEGER OR
*        BOOLEAN, INCLUDING ARRAYS
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        CALL  ACTUAL PARAMETER
*        BAL   R15,VALUCALL(R13)
*        DC    H'DISPL'                FORMAL PARAMETER DISPLACEMENT
*        DC    XL2'  '                 CHARACTERISTIC OF PARAMETER
*        ---                           RETURN FROM VALUCALL
*
*        DISPL(CDSA) CONTAINS IF PARAMETER IS AN ARRAY ADDR OF
*        SMF OTHERWISE VALUE OF THE ACTUAL PARAMETER, CONVERTED
*        IF NECESSARY
*
VALUCAL  MVI   CONVFL,0                ZERO TO CONVERSION FLAG
         ST    R15,BRRSAVE             SAVE R15, R8
         ST    R8,ADRSAVE
         LH    R1,0(,R15)
VALUC10  LA    R14,0(R1,CDSA)
*
*        INSERT COMPONENT SIZE OF ORIGINAL
*
         MVI   CSIZORIG+1,X'01'        ONE TO COMP SIZE INCASE BOOLEAN
         TM    5(R14),X'03'            TEST ACTUAL PARAMETER TYPE
         BO    VALUC12                 BOOLEAN, BRANCH
         MVI   CSIZORIG+1,X'04'        FOUR TO COMPONENT SIZE
         TM    5(R14),X'01'            ACTUAL PAR INTEGER ?
         BO    VALUC00                 INTEGER, BRANCH
         TM    OPTSW(R13),X'20'        PRECISION ?
         BO    VALUC00                 SHORT PRECISION, BRANCH
         MVI   CSIZORIG+1,X'08'        LONG, EIGHT TO COMPONENT SIZE
*
VALUC00  TM    5(R14),X'02'            ACTUAL PARAMETER REAL
         BO    VALUC11                 YES, BRANCH
*
*        ACTUAL PARAMETER INTEGER
*
         TM    3(R15),X'01'            FORMAL PAR INTEGER ?
         BO    VALUC12                 YES, BRANCH
*
         MVI   CONVFL,X'01'            1 (= INTEGER TO REAL) TO FLAG
         B     VALUC12
*
*        ACTUAL PARAMETER REAL
*
VALUC11  TM    3(R15),X'02'            FORMAL PAR REAL ?
         BO    VALUC12                 YES, BRANCH
         MVI   CONVFL,X'03'            3 (=REAL TO INTEGER) TO FLG
VALUC12  MVC   CSIZCOPY+1(1),CSIZORIG+1  COPY COMPONENT SIZE
         TM    3(R15),X'04'            ARRAY ?
         BO    VALUC21                 YES, BRANCH
VALUC13  MVC   0(8,R14),0(R8)          MOVE CONT OF R8 TO CDSA
         LR    R1,R14                  ADDR OF FORMAL PARAM ENTRY
         LR    R2,R1                   STORE BACK AFTER CONVERSION
         LA    R5,4(,R15)              RETURN ADDR
VALUC14  TM    CONVFL,X'03'            CONVERSION NECESSARY ?
         BZR   R5                      NO, RETURN
         BO    VALUC15                 REAL INTEGER
*
*        CALL INTEGER REAL CONVERSION ROUTINE
*
         L     R14,0(,R1)
         BAL   R8,CNVIRD(R13)
         EX    0,VALST
         BR    R5                      RETURN
*
*        CALL REAL-INTEGER CONVERSION ROUTINE
*
VALUC15  EX    0,VALLD
         BAL   R8,CNVRDI(R13)
         ST    R14,0(,R2)
         BR    R5                      RETURN
*
*        HANDLE VALUE CALL OF ARRAY
*
VALUC21  MVC   SIZEARR(4),16(R8)       SIZE OF ORIGINAL ARRAY
         L     R15,8(,R8)
         S     R15,4(,R8)              DIFF (ADDRLOWCOMP - ADRZEROCOMP)
         ST    R15,DIFFLZ
*
         MVI   SMFFL,0                 ZERO TO SMF FLAG
*
         TM    OPTSW(R13),X'20'        PRECISION ?
         BO    VALUC31                 SHORT PRECISION, BRANCH
         TM    CONVFL,X'03'            LONG, TEST CONV FLAG
         BZ    VALUC31                 NO CONV NEEDED, BRANCH
         MVC   SMFFL(1),CONVFL         CONV FLAG TO SMF FLAG
         L     R15,SIZEARR
         L     R14,DIFFLZ
         LH    R1,CSIZCOPY
         BO    VALUC25
*
*        INCREMENT 'SIZE OF ARRAY', DIFF AND COMPONENT SIZE
*
         SLA   R15,1
         SLA   R14,1
         SLA   R1,1
         B     VALUC26
*
*        DECREMENT 'SIZE OF ARRAY', DIFF AND COMPONENT SIZE
*
VALUC25  SRA   R15,1
         SRA   R14,1
         SRA   R1,1
VALUC26  ST    R15,SIZEARR
         ST    R14,DIFFLZ
         STH   R1,CSIZCOPY
*
*        EXECUTE SUBROUTINE WITH GETMAIN
*
VALUC31  SR    R15,R15
         IC    R15,0(R8)               NUMBER OF SUBSCRIPTS
         LA    R15,5(R15)
         SLA   R15,2
         CLI   CSIZCOPY+1,X'08'        REAL ARRAY LONG ?
         BNE   VALUC32                 NO
         TM    0(R8),X'01'             SMF LENGTH DOUBLE WORDS
         BO    VALUC32                 YES
         LA    R15,4(,R15)             FORCE ARRAY TO DOUBLE WORD
VALUC32  STC   R15,SIZESMF+1           INSERT SIZE OF SMF
         LH    0,SIZESMF
         A     0,SIZEARR               NUMBER OF BYTES REQUESTED
         BAL   R8,GETMSTO(R13)
*
*        COPY SMF
*
         L     R8,ADRSAVE
VALUC33  MVC   0(1,R1),0(R8)
*
*        INSERT FIRST FOUR WORDS INTO SMF COPY
*
         MVC   2(2,R1),10(CDSA)        CHAIN DISPL FROM DSA
         L     R15,BRRSAVE
         LH    R2,0(,R15)              DISPL OF FORMAL PARAM ENTRY
         STH   R2,10(,CDSA)            CHAIN DISPL
         ST    R1,0(R2,CDSA)           ADDR OF VALUE ARRAY
*                                      TO FORMAL PARAMETER ENTRY
         LR    R15,R1
         AH    R15,SIZESMF
         ST    R15,8(,R1)
         S     R15,DIFFLZ
         ST    R15,4(,R1)
         A     R15,DIFFLZ
         A     R15,SIZEARR
         ST    R15,12(,R1)
*
*        COPY DOUBLE OR HALF P-VALUES INTO NEW SMF
*
         LA    R15,16(,R1)
         LA    R2,16(,R8)
*
VALUC35  L     R14,0(R2)
         TM    SMFFL,X'03'             TEST IF P-VALUES MUST CHANGE
         BZ    VALUC36
         SLL   R14,1
         BM    VALUC36                 BR IF FLAG=1 (INCREM IS OK)
         SRL   R14,2                   DECREMENT INSTEAD
VALUC36  ST    R14,0(,R15)
         LA    R15,4(,R15)
         LA    R2,4(,R2)
         C     R15,8(,R1)
         BL    VALUC35
*
*        COPY ARRAY
*
*        INITIALIZE COPYING
*
VALUC41  L     R3,SIZEARR              SIZE OF ARRAY
         L     R2,8(,R1)               ADDR OF COPY ARRAY
         L     R1,8(,R8)               ADDR OF ORIGINAL ARRAY
         TM    CONVFL,X'03'            CONVERSION NECESSARY ?
         BZ    VALUC61                 NO, MOVE ARRAY
VALUC51  BAL   R5,VALUC14              CONVERT ONE ELEMENT, STORE IT
         AH    R1,CSIZORIG             NEXT ELEMENT FROM ORIGINAL
         AH    R2,CSIZCOPY             NEXT ELEMENT FROM COPY
         SH    R3,CSIZCOPY
         BP    VALUC51                 CONTINUE IF ELEMENTS LEFT
VALUC52  L     R15,BRRSAVE
         B     4(,R15)                 RETURN
*
VALUC61  LA    R4,255                  MAX IN ONE MOVE
VALUC61A BCTR  R3,0                    SIZE-1
         CR    R3,R4
         BNH   VALUC62                 NOT MORE THAN 256 BYTES
         EX    R4,VALUC63              MOVE 256 BYTES
         SR    R3,R4                   REDUCE SIZE
         LA    R1,256(,R1)
         LA    R2,256(,R2)
         B     VALUC61A                CONTINUE
*
VALUC62  EX    R3,VALUC63              MOVE LAST PART OF ARRAY
         B     VALUC52                 RETURN
*
VALUC63  MVC   0(0,R2),0(R1)           ORIGINAL ARRAY TO COPY
*
*        WORK AREA
*
BRRSAVE  DC    F'0'                    STORAGE OF R15
ADRSAVE  DC    F'0'                    STORAGE OF R8
DIFFLZ   DC    F'0'                    DIFFERENCE BETWEEN LOW
*                                      AND ZERO COMPONENTS
SIZEARR  DC    F'0'                    SIZE OF ARRAY
SIZESMF  DC    H'0'                    SIZE OF SMF
CSIZORIG DC    H'0'                    COMPONENT SIZE, ORIGINAL
CSIZCOPY DC    H'0'                    COMPONENT SIZE, COPY
CONVFL   DC    X'00'                   CONVERSION FLAG
SMFFL    DC    X'00'                   ARRAY SIZE FLAG
*
***********************************************************************
*
*        RETURN PROGRAM
*
***********************************************************************
*
*        THIS ROUTINE IS ENTERED WHEN A BRANCH IS MADE OUT OF A
*        BLOCK OR PROCEDURE BY MEANS OF A 'GO TO' STATEMENT
*
*        IT SEARCHES RAS FOR AN ENTRY POINTING TO THE DSA OF THE
*        TARGET BLOCK. FOR EACH BLOCK THAT IS BYPASSED, THE
*        FREEDSA ROUTINE IS INVOKED TO RELEASE STORAGE FOR DSA
*        AND ARRAYS. CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        B     RETPROG(R13)
*
RETPROGA BALR  R15,0                   SET RETURN REGISTER
         L     R14,RASPT(R13)          FETCH RAS TOP POINTER
RETPR1   CLI   0(R14),RASPARMM         RAS PARAMETER ENTRY ?
         BNE   PBNENTRY                NO
         SH    R14,EIGHT(,R13)         CLEAR PARAMETER ENTRY
         B     RETPR1                  TEST NEXT ENTRY
*
PBNENTRY IC    R1,0(R14)               SAVE FLAG
         MVI   0(R14),0                CLEAR FLAG
         L     CDSA,0(,R14)            UPDATE DSA REG
         C     GDSA,0(,R14)            COMPARE DSA ADDR
         STC   R1,0(,R14)              RESTORE FLAG
         ST    R14,RASPT(R13)          SAVE RAS POINTER
         BER   R8                      EQUAL, EXIT TO ADDR IN R8
         B     FREEDSA(R13)            FREE DSA SUBROUTINE IN EPILOG
*
***********************************************************************
*
*        EPILOGUE PROGRAM
*
***********************************************************************
*
*        THIS ROUTINE IS EXECUTED WHENEVER AN EXIT IS MADE FROM
*        A PROCEDURE (ENTRY POINT EPILOGP) OR BLOCK (ENTRY POINT
*        EPILOGB) VIA THE 'END' STATEMENT
*
*        CLEAR THE CORRESPONDING ENTRY FROM RAS AND FREES
*        THE STORAGE FOR DSA AND ARRAYS. IF THE EXIT WAS FROM A
*        PRECOMPILED PROCEDURE, THE PROCEDURE IS DELETED
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        B     EPILOGP(R13)
*
EPILP    MVC   FCTVALST(8,R13),24(CDSA) FUNCTION VALUE TO FSA
         LA    R8,FCTVALST(R13)         FUNCTION VALUE ADDR TO R8
         BAL   R15,FREEDSA(R13)         LEAVE BLOCK AND UPDATE REG
         L     R14,RASPT(R13)
         L     R15,12(,R14)             RETURN ADDR FROM RAS
         BR    R15                      RETURN
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        B     EPILOGB(R13)
*
EPILB    EQU   *
FREEDSA  EQU   EPILOGB                 LEAVE A BLOCK
FRDSA    EQU   *                       FREEMAIN UPDATE REG
         ST    R15,BRRST(R13)          SAVE RETURN ADDR
         L     R14,RASPT(R13)          FETCH RAS POINTER
         SH    R14,EIGHT(R13)          REDUCE RETURN ADDR STACK
         ST    R14,RASPT(R13)          SAVE RAS POINTER
         CLI   8(R14),RASLOADM         LOAD PROCEDURE ENTRY ?
         BNE   VTEST                   NO
         L     R1,RASPB(R13)           FETCH ADDR OF NAME OF
         LR    R0,R1                   PROCEDURE TO BE DELETED
         LA    R1,8(,R1)               CLEAR PRECOMPILED PROCEDURE
         ST    R1,RASPB(R13)           NAME FROM RAS
*
         DELETE  EPLOC=(0)
*
         B     FRDSA+4                 CONTINUE
*
*        VALUE ARRAY HANDLING
*
EPIL3    EQU   *
VTEST    ICM   R0,B'0011',10(CDSA)     TEST VALUE ARRAY FIELD
         BZ    ATEST                   ZERO, GOTO NEXT TEST
         LH    R2,10(,CDSA)            LOAD LAST VALUE ARRAY DISPL
         L     R1,0(R2,CDSA)           LOAD ADDR OF STOR MAP FCT
         L     R0,16(,R1)              LOAD LENGTH OF ARRAY
         LH    R2,2(,R1)               LOAD BEFORE LAST VALUE
*                                      ARRAY DISPLACEMENT
         STH   R2,10(,CDSA)            STORE BEFORE LAST VALUE
*                                      ARRAY DISPLACEMENT
         SR    R2,R2                   CLEAR A WORK REGISTER
         IC    R2,0(,R1)
         LA    R2,1(,R2)               CALCULATE LENGTH OF STORAGE
         SLL   R2,2                    MAPPING FUNCTION
         LA    R2,16(,R2)
         AR    R0,R2                   ADD ST MAP FUNCT LENGTH
*                                      AND ARRAY LENGTH
*                                      FREEMAIN FOR VAL ARRAY
         FREEMAIN R,LV=(0),A=(1)       INCL ST MAP FCT
*
         B     VTEST                   RETURN TO VALUE ARRAY TEST
*
*        ARRAY HANDLING
*
ATEST    SR    R2,R2                   CLEAR WORK REGISTER
         ICM   R2,B'0011',14(CDSA)     TEST LAST ARRAY DISPLACEMENT
         BZ    DSAHDL                  ZERO, GOTO DSAHDL
         LH    R3,2(R2,CDSA)           LOAD BEFORE LAST ARRAY DISPL
         STH   R3,14(,CDSA)            STORE BEFORELAST ARRAY DISPL
         L     R1,8(R2,CDSA)           LOAD ADDR OF LOWEST COMPON
         L     R0,16(R2,CDSA)          LOAD LENGTH OF ARRAY
*
         FREEMAIN R,LV=(0),A=(1)       FREEMAIN FOR ARRAY
*
         B     ATEST                   RETURN TO ARRAY TEST
*
*        DSA HANDLING
*
DSAHDL   LR    R1,CDSA                 LOAD DSA ADDR
         LH    R2,8(,CDSA)             LOAD PBT DISPL
         L     R3,0(,CDSA)             UPDATE DSA ADDR
         ST    R3,0(R2,PBT)            IN PBT
         LH    R0,4(R2,PBT)            LENGTH OF DSA TO R0
         L     CDSA,4(,CDSA)           RESET CDSA POINTER
         LM    PBT,LAT,16(CDSA)        UPDATE PBT AND LAT REGISTERS
*
         FREEMAIN R,LV=(0),A=(1)       FREEMAIN FOR DSA
*
         L     R15,BRRST(R13)          RESTORE RETURN ADDR
         BR    R15                     BRANCH
*
***********************************************************************
*
*        STANDARD PROCEDURE DECLARATION ROUTINE
*
***********************************************************************
*
*
*        ENTERED FROM THE PROLOG ROUTINE IF PBN IS ZERO, IE A
*        STANDARD PROCEDURE IS CALLED VIA AN ACTUAL PARAMETER TO
*        AN ANOTHER PROCEDURE
*
*        ON ENTRY, R15 CONTAINS THE ADDR OF THE PARAMETER
*        LIST, WHILE R8 CONTAINS THE INTERNAL NAME OF THE
*        STANDARD PROCEDURE.
*        THE ROUTINE BUILDS THE PARAMETER LIST AND EXECUTES THE
*        CALL IN THE SAME WAY AS WOULD NORMALLY BE DONE BY THE
*        GENERATED OBJECT CODE. SINCE THE ROUTINE MAY BE ENTERED
*        REPEATEDLY DURING THE EVALUATION OF THE ACTUAL
*        PARAMETERS, THE PARAMETER LIST AND OTHER INFORMATION IS
*        STORED IN A DYNAMIC AREA CALLED SPDA.
*
         DS    0H
SPDECL   EQU   *-FSAREA
*
*        TEST FOR AUXILIARY ROUTINE INPUT OR OUTPUT
*
         LTR   R8,R8
         BPR   R8                      TO ROUTINE INPUT OR OUTPUT
*
*        GET DYNAMIC STORAGE AREA
*
SPDECL00 LR    R2,R15                  SAVE R15 DURING GETMAIN
*
         GETMAIN R,LV=SPDALG
*
         LR    R15,R2
         MVC   0(4,R1),SPDAP           INSERT CHAIN ADDR
         ST    R1,SPDAP                STORE CURRENT AREA POINTER
         LR    R5,R1
         USING SPDA,R5
         ST    R8,PRID
         LR    R4,LAT                  R4 IS NOW LAT POINTER
         LR    R0,R8
         LR    R2,R0
         SRL   R2,12
         N     R0,=F'3'                NUMBER OF FORMAL PARAMETERS
         BNZ   *+8                     ZERO MEANS ONE PARAMETER
         LA    R0,1
         CH    R0,6(,R15)              COMPARE NUMBER OF ACTUAL PARAM
         BNE   ERROR21
*
*        INITIALIZE FOR CREATING PARAMETER LIST
*
         LA    R1,PARLIST
         LA    R3,PARAMS
         MVI   0(R1),0
         MVC   1(11,R1),0(R1)          RESET PARAMETER LIST
SPDECL02 STC   R2,FPTYPA
         STC   R2,FPTYP
         XC    FPTYP,5(R15)            COMPARE WITH ACTUAL PAR CHAR
         TM    FPTYP,X'07'
         BZ    SPDECL15                IDENTICAL TYPES
         BO    PARERR(R13)             NOT COMPATIBLE TYPES
*
*        TYPES ARE NOT IDENTICAL BUT MAY BE COMPATIBLE
*
         TM    FPTYPA,X'08'            TEST FOR VALUE OR NAME
         BO    PARERR(R13)             CALL BY NAME AND NOT SAME TYPE
         TM    FPTYP,X'03'             TEST IF REAL-INTEGER COMPATIBLE
         BNO   PARERR(R13)
         TM    5(R15),X'03'            TEST ACTUAL PARAMETER
         BNM   PARERR(R13)             IF NOT REAL OR INTEGER
         OI    0(R1),X'80'             SET TYPE CONVERSION FLAG
*
*        ACTIVATE THUNK TO GET ADDR OF ACTUAL PARAMETER
*
SPDECL15 STM   R15,R4,SPSAVE
         MVC   SPTHAD(4),0(R15)        THUNK ADDR TO FULLWORD LOCATION
         L     R3,RASPT(R13)
         LA    R3,8(,R3)               NEXT ENTRY IN RAS
         C     R3,RASPB(R13)
         BNL   RASOVERF(R13)           IF RAS FULL
         ST    R3,RASPT(R13)
         ST    CDSA,0(,R3)             DSA POINTER TO RAS
         LM    PBT,LAT,16(CDSA)
         LA    R2,SPDECL17-8
         ST    R2,4(,R3)               ADDR USED BY CAP2
         L     R15,SPTHAD              ADDR OF THUNK
         BR    R15                     BRANCH TO THUNK
*
*        RETURN HERE VIA CAP2
*        R8 CONTAINS ADDR OF ACTUAL PARAM
*
SPDECL17 L     R5,SPDAP                RESTORE SPDA POINTER
         LM    R15,R4,SPSAVE           RESTORE REGISTERS
         C     R8,ASTLOC(R13)
         BNE   SPDECL19
         MVC   0(8,R3),0(R8)           SAVE PARAM VALUE IN SPDA
         LR    R8,R3
SPDECL19 O     R8,0(,R1)               COMBINE FLAGS AND PARAM ADDR
         ST    R8,0(,R1)               STORE PARAM ADDR IN PARLIST
         TM    PRID,X'03'              I/O PROCEDURE ?
         BNZ   SPDECL01                NO, BRANCH
*
*        I/O PROCEDURE
*
         TM    PRID+2,X'02'            SYSACT ?
         BZ    SPDECL01                NO, BRANCH
         CH    R0,=H'1'                TEST IF THIRD PARAM
         BNE   SPDECL01                NO, BRANCH
         TM    4(R15),X'08'            ASSIGNMENT POSSIBLE ?
         BZ    SPDECL01                YES, BRANCH
         OI    0(R1),X'40'             SET NO ASSIGNMENT FLAG
*
SPDECL01 LA    R1,4(,R1)               STEP PARLIST POINTER
         LA    R3,8(,R3)               STEP PARAMETER POINTER
         LA    R15,8(,R15)             STEP ACTUAL PARAMETER POINTER
         SRL   R2,4
         BCT   R0,SPDECL02             BRANCH IF MORE PARAMETERS
*
*        PARAMETER LIST COMPLETE - ACTIVATE THE PROCEDURE
*
         ST    R15,SPSAVE              SAVE RETURN ADDR
         LA    R1,PARLIST
         TM    PRID+3,X'80'            ABS/SIGN/LENGTH/ENTIER ?
         BO    SPDECL03                YES, BRANCH
         IC    R2,PRID+3
         N     R2,=X'000000FC'         GET DISPLACEMENT IN LAT
         L     R15,0(R2,R4)            LOAD ADDR OF PROCEDURE
         TM    PRID,X'03'              I/O PROCEDURE ?
         BNZ   SPDECL04                NO, BRANCH
*
*        I/O PROCEDURE EXIT
*
         BALR  R14,R15
         B     SPDECL18
*
SPDECL03 TM    PRID+3,X'50'
         BNM   SPDECL04                BR IF ABS OR ENTIER FUNCTION
         TM    PRID+3,X'20'
         BZ    SPDECL05                BR IF SIGN FUNCTION
*
*        LENGTH FUNCTION
*
         L     R1,0(R1)
         MVC   HW(2,R13),0(R1)
         LH    R0,HW(R13)              LENGTH OF ENTIRE STRING FIELD
         BCTR  R0,0                    REDUCE BY TWO TO GET
         BCTR  R0,0                    ACTUAL STRING LENGTH
         ST    R0,FCTVALST(R13)
         B     SPDECL13
*
*        SIGN FUNCTION
*
SPDECL05 L     R2,0(,R1)               LOAD PARAMETER ADDR
         SR    R0,R0                   INITIALIZE OUTPUT VALUE
         TM    0(R1),X'80'             TYPE CONVERSION ?
         BO    SPDECL06                YES, BRANCH
         EX    0,LINSTR                VALUE TO FPR0
         EX    0,LTRINSTR              TEST SIGN
         B     SPDECL07
*
SPDECL06 ICM   R0,B'1111',0(R2)        VALUE TO R0
SPDECL07 BZ    SPDECL08                TEST SIGN
         LA    R0,1                    FUNCTION VALUE=1
         BP    SPDECL08
         LCR   R0,R0                   FUNCTION VALUE=-1
SPDECL08 ST    R0,FCTVALST(,R13)
         B     SPDECL13
*
*        MATHEMATICAL FUNCTIONS (INCLUDING ABS, ENTIER)
*
SPDECL04 L     R2,0(,R1)
         TM    0(R1),X'80'             TYPE CONVERSION ?
         BZ    SPDECL09
         L     R14,0(,R2)              LOAD PARAMETER VALUE
         BAL   R8,CNVIRD(R13)
         EX    0,STINSTR
         MVC   0(4,R1),ASTLOC(R13)     CHANGE PARAMETER ADDR
         B     SPDECL10
*
SPDECL09 EX    0,LINSTR
SPDECL10 CLI   PRID+3,X'80'            ABS ?
         BNE   SPDECL11                NO, BRANCH
*
*        ABS FUNCTION
*
         EX    0,LPRINSTR              ABS VALUE TO FPR0
         B     SPDECL14
*
SPDECL11 CLI   PRID+3,X'F0'            ENTIER ?
         BNE   SPDECL12                NO, BRANCH
*
*        ENTIER FUNCTION
*
         BAL   R8,ENTIER(R13)
         ST    R14,FCTVALST(R13)
         B     SPDECL13
*
*        ALL OTHER FUNCTIONS
*
SPDECL12 BALR  R14,R15                 CALL SUBROUTINE
SPDECL14 EX    0,STINSTR
SPDECL13 L     R8,ASTLOC(R13)          ADDR OF FUNCTION VALUE
*
*        COMMON EXIT
*
SPDECL18 LR    R1,R5
         MVC   SPDAP(4),0(R1)          RESTORE PREV DA POINTER
         L     R2,SPSAVE               LOAD RETURN ADDR (PREV R15)
*
         LA    R0,SPDALG
*
         FREEMAIN R,A=(1),LV=(0)
*
         LM    PBT,LAT,16(CDSA)
         BR    R2                      RETURN TO CALLING PROGRAM
*
         DROP  R5
*
*        CONSTANTS AND WORK AREAS
*
SPTHAD   DC    F'0'                    TEMP STORAGE FOR THUNK ADDR
SPDAP    DC    F'0'                    POINTER TO CURRENT DYNAMIC AREA
FPTYP    DC    X'00'                   TYPE OF FORMAL PARAMETER
FPTYPA   DC    X'00'                   SAVE AREA FOR FPTYP
*
*        DYNAMIC STORAGE AREA
*
SPDA     DSECT
         DS    F                       LINK TO LOWER DA
SPSAVE   DS    6F                      REGS R15, R0, R1, R2, R3, R4
PRID     DS    F                       PROCEDURE IDENTIFICATION
PARLIST  DS    3F                      PARAMETER LIST
PARAMS   DS    3D                      PARAMETER VALUES
SPDALG   EQU   *-SPDA
*
IHIFSARA CSECT
*
***********************************************************************
*
*        CALL SWITCH ELEMENT SUBROUTINE
*
***********************************************************************
*
*        THIS ROUTINE IS AN INTERMEDIATE LINK BETWEEN A SWITCH
*        DESIGNATOR AND A SWITCH LIST
*
*        IT SEARCHES THE DSA CHAIN FOR THE DSA OF THE SWITCH LIST
*        AND BRANCHES TO THE CALLED SWITCH LIST ENTRY
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        ADDR OF SWITCH LIST IN R8, ADDR OF DSA FOR
*        BLOCK IN WHICH SWITCH IS DECLARED IN REG GDSA AND THE
*        SWITCH ELEMENT NUMBER IN R15
*
*
*        BAL   R14,CSWE1(R13)
*        ---                           RETURN VIA CSWE2 WITH BRANCH
*                                      ADDR IN R8 AND ADDR OF
*                                      DSA IN GDSA
*
CSWE1A   LTR   R15,R15                 ELEMENT NUMBER POSITIVE ?
         BNH   SWDMERR(R13)            NO, DIMENSION ERROR
         CH    R15,2(,R8)              COMPARE NO WITH SWITCH LIST NO
         BH    SWDMERR(R13)            DIMENSION ERROR
         SLL   R15,2
         L     R3,RASPT(R13)           RAS POINTER FROM TOP
CSWEI1   LA    R3,8(R3)                RESERVE ONE ENTRY IN RAS
         C     R3,RASPB(R13)           STACK OVERFLOW ?
         BNL   RASOVERF(R13)
         ST    CDSA,0(,R3)             STORE CDSA IN RAS
         ST    R14,4(,R3)              SAVE RETURN ADDR IN STACK
         SR    R14,R14                 NOT CALLING BLOCK INDICATION
         CR    CDSA,GDSA               SWITCH BLOCK REACHED ?
         BNE   CSWEI2                  NO
         ST    R3,RASPT(R13)           SAVE RAS TOP POINTER
         L     R15,0(R15,R8)           ADDR OF SWITCH ELEMENT
         BR    R15
*
CSWEI2   LH    R1,8(,CDSA)             PROGRAM BLOCK DISPL TO REG
         L     R2,0(,CDSA)             LAST GENERATION DSA POINTER IS
         ST    R2,0(R1,PBT)            STORED IN PROGRAM BLOCK TABLE
         L     CDSA,4(,CDSA)           LOAD DYNAMICALLY ENCLOSING DSA
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         B     CSWEI1                  CONTINUE
*
*        THIS ROUTINE HANDLES THE TRANSFER FROM THE SWITCH LIST
*        BACK TO THE SWITCH DESIGNATOR
*
*        IT RELOADS CDSA WITH THE ADDR OF THE DSA THAT WAS
*        ACTIVE WHEN CSWEU WAS ENTERED
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*        B     CSWE2(R13)
*
CSWE2A   L     R3,RASPT(R13)           RAS POINTER FROM TOP
CSWEI3   L     R14,4(,R3)              RETURN ADDR FROM STACK
         SH    R3,EIGHT(R13)           RELEASE ONE ENTRY IN RAS
         ST    R3,RASPT(R13)           SAVE RAS TOP POINTER
         LTR   R14,R14                 RETURN ADDR FOUND ?
         BNZR  R14                     YES, RETURN
         L     CDSA,0(,R3)             NEW DSA POINTER FROM RAS
         LH    R1,8(,CDSA)             PROGRAM BLOCK DISPL TO REG
         ST    CDSA,0(R1,PBT)          CURRENT DSA POINTER TO PBT
         LM    PBT,LAT,16(CDSA)        PBT AND LAT CAN BE DIFFERENT
         B     CSWEI3                  CONTINUE
*
***********************************************************************
*
*        LOAD PRECOMPILED PROCEDURE
*
***********************************************************************
*
*        ENTERED FROM THE DECLARATION OF A 'CODE' PROCEDURE
*
*        SEARCH THE BOTTOM PART OF RAS FOR THE NAME OF THE
*        PROCEDURE. IF IT IS NOT FOUND, THE PRECOMPILED PROCEDURE
*        WITH THE SAME NAME IS LOADED AND ENTRIES ARE MADE IN
*        RAS FOR THE NAME AND FOR THE ENTRY POINT
*
*        THE ENTRY POINT ADDR IS STORED IN THE PROGRAM BLOCK TABLE
*
*        CALLING SEQUENCE - (ENTRY VIA BRLIST)
*
*        BAL   R8,LOADPP(R13)
*        DC    CL8(PPNAME)             NAME OF PRECOMPILED PROCEDURE
*        DC    H'PBN'                  PROG BLOCK NUMBER
*
LOADPPA  LM    R3,R4,RASEND(R13)       RASEND AND RASPB TO REG
         LA    R2,8                    SET TO 8
LOADPP2  CR    R3,R4
         BNH   LOADPP1                 BRANCH IF STACK EMPTY
         CLC   0(8,R4),0(R8)           PROCEDURE ALREADY LOADED ?
         LA    R4,8(,R4)               STEP TO NEXT PP NAME
         BNE   LOADPP2                 NO, NAME NOT FOUND
         L     R3,RASPT(R13)           RAS POINTER FROM TOP
         S     R4,RASPB(R13)
         SRL   R4,3                    NAME FOUND IN ENTRY NR R4
LOADPP3  SR    R3,R2
         CLI   8(R3),RASLOADM          LOAD PROCEDURE ENTRY ?
         BNE   LOADPP3                 NO, CONTINUE SEARCH
         BCT   R4,LOADPP3              LOOP TO FIND RIGHT ENTRY
         L     R0,12(,R3)              FETCH ADDR OF CONSTANTS
         B     LOADPP4
*
*        PROCEDURE MUST BE LOADED
*
LOADPP1  L     R3,RASPT(R13)
         L     R4,RASPB(R13)
         AR    R3,R2                   RESERVE ONE ENTRY FROM TOP
         SR    R4,R2                   RESERVE ONE ENTRY FROM BOTTOM
         CR    R3,R4                   STACK OVERFLOW ?
         BNL   RASOVERF(R13)
         ST    R4,RASPB(R13)           STORE UPDATED STACK POINTER
         ST    R3,RASPT(R13)
         MVC   0(8,R4),0(R8)           ENTER NAME IN STACK
         LR    R0,R4                   R0 -> NAME
*
         LOAD  EPLOC=(0)
*
         ST    CDSA,0(,R3)             SAVE CDSA IN RAS ENTRY
         MVI   0(R3),RASLOADM          INSERT LOAD PROCEDURE FLAG
         ST    R0,4(,R3)               STORE ADDR TO ENTRY CONSTANT
LOADPP4  LH    R3,8(,R8)               FETCH PBN CODE PROCEDURE
         ST    R0,0(R3,PBT)            ADDR OF PRECOMPILED PROCEDURE
*                                      CONSTANT TO CODE PROC.PBT ENTRY
*                                      CONSTANT A(PBT),A(LAT),A(ENTRY)
         B     10(,R8)                 RETURN TO DECLARATION END
*
***********************************************************************
*
*        TRACE ROUTINE
*
***********************************************************************
*
*        EXECUTED WHENEVER THE END OF AN ALGOL STATEMENT IS REACHED
*
*        IF ANY OF THE PARAMETERS TRACE, TRBEG OR TREND WAS
*        SPECIFIED. IT CHECKS IF THE SEMICOLON NUMBER IS WITHIN A
*        TRACE AREA AND, IF THIS IS THE CASE, STORES IT IN A
*        BUFFER FOR OUTPUT ON SYSUT1 WHEN THE BUFFER OVERFLOWS.
*        WHEN A DISCONTINUITY IS ENCOUNTERED (TRANSFER INTO A
*        TRACE AREA OR BETWEEN THE MAIN PROGRAM AND A PRECOMPILED
*        PROCEDURE), THE NAME OF THE ACTIVE MODULE IS ALSO
*        STORED IN THE BUFFER
*
*        THE FORMAT OF THE INFORMATION IN THE BUFFER IS -
*
*        DC    H'LENGTH'               POINTER TO NEXT FREE PLACE
*        DS    H                       NOT USED
*        DC    H'SC'                   SEMICOLON NUMBER
*         .
*         .
*        DC    H'0'                    FLAG FOR MODULE NAME
*        DC    CL4'NAME'               MODULE NAME (FIRST 4 CHAR)
*        DC    H'SC'                   SEMICOLON NUMBER
*         .
*         .
*
*        THE ROUTINE IS ENTERED VIA INSTRUCTIONS IN THE BRANCH
*        LIST AT BRLIST. THESE INSTRUCTIONS STORE THE SEMICOLON
*        NUMBER AND THEN EXECUTE A BRANCH EITHER TO THIS ROUTINE
*        OR, IF TRACE WAS NOT REQUESTED, DIRECTLY BACK TO THE
*        ALGOL PROGRAM.
*
*        CALLING SEQUENCE -
*
*        BAL   R15,TRACE(R13)
*        DC    H'SC'                   SEMICOLON NUMBER
*        ---                           (RETURN POINT)
*
TRACEA   STM   R14,R12,ASAVE+12(R13)   SAVE REGS IN SECOND SAVEAREA
         L     R3,=A(IHIFSARB)
         USING IHIFSARB,R3
         LR    R1,PBT
         LM    R6,R7,TRBEG             LOAD TRACE LIMITS
         LM    R8,R11,TRBUF            LOAD BUFFER PARAMETERS
         LH    R4,0(,R8)               LOAD BYTE POINTER
         LH    R2,TRL1                 LENGTH OF NORMAL TRACE ITEM
*
         CLC   4(4,R1),TRMPNAME        MAINP OR PRECOMP PROC ?
         BE    TRACE10                 MAINP
         TM    OPTSW(R13),PPTRSW       TRACE IN PRECOMP PROC ?
         BZ    TRACE6                  NO, PP TRACE
         TM    TRFLAG,X'03'            PP CALLED FROM TRACE AREA ?
         BM    TRACE0                  YES, TRACE REQUIRED
         B     TRACE6                  CONDITIONAL - NO PP TRACE
*
TRACE10  LH    R5,SCRCS(R13)           LOAD CURRENT SEMICOLON NUMBER
         CR    R7,R6                   TEST INTERVAL LIMITS
         BNH   TRACE13                 SINGLE INTERVAL
         CR    R5,R6                   CHECK SC AGAINST LIMITS
         BL    TRACE15                 OUTSIDE INTERVAL
         CR    R5,R7
         BH    TRACE15                 OUTSIDE INTERVAL
         B     TRACE16                 INSIDE INTERVAL
*
TRACE13  CR    R5,R7                   DOUBLE INTERVAL
         BH    TRACE14
TRACE16  MVI   TRFLAG1,1               INSIDE LOWER INTERVAL
         B     TRACE18
*
TRACE14  CR    R5,R6
         BL    TRACE15                 OUTSIDE BOTH INTERVALS
         MVI   TRFLAG1,2               INSIDE HIGHER INTERVAL
TRACE18  CLC   TRFLAG1,TRFLAG          BORDER BEEN CROSSED ?
         BE    TRACE0                  NO, SAME INTERVAL AS BEFORE
         MVC   TRFLAG,TRFLAG1
         B     TRACE5
*
TRACE15  MVI   TRFLAG,0                NO TRACE THIS TIME
         B     TRACE6
*
TRACE0   CLC   4(4,R1),TRPGID+2        PROGID CHANGED ?
         BE    TRACE1                  NO, BRANCH
TRACE5   MVC   TRPGID+2(4),4(R1)       STORE NEW PROGID
         LH    R2,TRL2                 LENGTH OF ITEM WITH PROGID
TRACE1   LR    R0,R2                   BUFFER FILLED ?
         AR    R0,R4
         CR    R0,R10
         BL    TRACE2                  STILL ROOM, BRANCH
         LTR   R11,R11                 IF NO RECORDS WRITTEN
         BZ    TRACE4                  BYPASS CHECK
*
         CHECK TRCHECK
*
TRACE4   WRITE TRCHECK,SF,,(R8),MF=E
*
         LR    R0,R8
         LR    R8,R9                   SWITCH BUFFERS
         LR    R9,R0
         LA    R4,4                    RESET POINTER
         LA    R11,1(,R11)             INCR RECORD COUNTER
*
TRACE2   CH    R2,TRL1                 TEST FOR NEW PROGID
         BE    TRACE3
*
         LR    R1,R8
         AR    R1,R4
         MVC   0(6,R1),TRPGID          PROGID TO BUFFER
         LA    R4,6(,R4)
*
TRACE3   LR    R1,R8
         AR    R1,R4
         MVC   0(2,R1),SCRCS(R13)      SEMICOLON COUNTER TO BUFFER
         LA    R4,2(,R4)
         STH   R4,0(,R8)
         STM   R8,R11,TRBUF
TRACE6   LM    R14,R12,ASAVE+12(R13)
         B     2(,R15)                 RETURN TO ALGOL PROGRAM
*
         CNOP  2,4
TRL1     DC    H'2'                    LENGTH OF SEMICOLON FIELD
TRL2     DC    H'8'                    LENGTH OF NEW NAME + SEMICOLON
TRPGID   DC    H'0'                    FLAG FOR PROGID
         DC    2H'0'                   FIRST FOUR BYTES OF PROG NAME
         DC    X'FFFF'                 INITIAL VALUE FOR TREND
TRBEG    DC    F'0'                    BEGINNING OF TRACE AREA
TREND    DC    F'0'                    END OF TRACE AREA
TRFLAG   DC    X'00'                   STATUS INDICATOR
*                                        00 - OUTSIDE BOTH TRACE AREAS
*                                        01 - INSIDE LOWER AREA
*                                        02 - INSIDE HIGHER AREA
TRFLAG1  DC    X'00'                   PREVIOUS VALUE OF TRFLAG
TRMPNAME DC    CL4' '                  NAME OF MAIN PROGRAM
*
         DROP  R3
*
***********************************************************************
*
*        PROGRAM INTERRUPT ROUTINE
*
***********************************************************************
*
*        USE INTERRUPT CODE TO LOAD ENTRY FROM PIETAB TO PASS
*        CONTROL TO FSA ERROR ROUTINE BY UPDATING THE OLD PSW
*        AND RETURNING FROM SPIE
*
         USING PIEROUT,R15
PIEROUT  L     R13,=A(IHIFSARA)
         MVC   PGOPSW(8,R13),4(R1)     MOVE BC MODE PSW TO PGOPSW
         IC    R2,PGOPSW+3(,R13)       LOAD INTERRUPTION CODE
         N     R2,PGCMASK              REMOVE IMPRECISE CODES (M/91)
         SLA   R2,2                    CONVERT INTERRUPT CODE
         LA    R2,PIETAB(R2)           FOR TABLE LOOKUP
PIEROUT2 MVC   9(3,R1),1(R2)           CHANGE RETURN ADDR IN OLD PSW
         BR    R14                     RETURN FROM SPIE RTN
*
         DROP  R15
*
         DC    0F'0'
PGCMASK  DC    X'0000000F'             MASK FOR INTERRUPT CODE
*
PIETAB   DC    A(ERROR33)              MOD/91 ONLY
         DC    A(ERROR33)              OPERATION        - 0C1
         DC    A(ERROR33)              PRIVILAGE        - 0C2
         DC    A(ERROR33)              EXECUTE          - 0C3
         DC    A(ERROR33)              PROTECTION       - 0C4
         DC    A(ERROR33)              ADDRESSING       - 0C5
         DC    A(ERROR33)              SPECIFICATION    - 0C6
         DC    A(ERROR33)              DATA             - 0C7
         DC    A(ERROR28)              FIXED PT OVFL    - 0C8
         DC    A(ERROR30)              FIXED PT DIVIDE  - 0C9
         DC    A(ERROR33)              DECIMAL OVFL     - 0CA
         DC    A(ERROR33)              DECIMAL DIVIDE   - 0CB
         DC    A(ERROR29)              EXPONENT OVFL    - 0CC
         DC    A(ERROR33)              EXPONENT UNDERFL - 0CD
         DC    A(ERROR33)              FP SIGNIFICANCE  - 0CE
         DC    A(ERROR31)              FP DIVIDE        - 0CF
*
***********************************************************************
*
*        ENTRY POINTS IN IHIIOR USED BY I/O ROUTINES
*
***********************************************************************
*
ADRLST   DC    A(IHIIORCI)             +00
         DC    A(IHIIORCL)             +04
         DC    A(IHIIOREV)             +08
         DC    A(IHIIORNX)             +12
         DC    A(IHIIOROP)             +16
         DC    A(IHIIOROQ)             +20
         DC    A(IHIIOREN)             +24
         DC    A(IHIIORGP)             +28
         DC    A(IHIIORER)             +32
*
***********************************************************************
*
*        INITIAL ENTRY POINT
*
***********************************************************************
*
         DROP  R13
         USING IHIFSAIN,R15
*
IHIFSAIN SAVE  (14,12),,'IHIFSAIN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         L     FSAA,=A(IHIFSARA)
         ST    R13,4(,FSAA)            LINK SAVE AREAS TOGETHER
         ST    FSAA,8(,R13)
         LR    R13,FSAA
         L     R7,=A(IHIFSARB)
         USING IHIFSARB,R7
         B     ALGIN                   TO INITIALIZATION ROUTINE
*
         DROP  R15
         DROP  R7
*
IHIFSARB CSECT
*
***********************************************************************
*
*        INITIALIZATION ROUTINE
*
***********************************************************************
*
*        THIS IS THE FIRST ROUTINE EXECUTED WHEN AN ALGOL
*        PROGRAM IS EXECUTED OR CALLED VIA A PROGRAM
*
*        PERFORM INITIALIZING FUNCTIONS AND TRANSFER CONTROL TO
*        THE ALGOL OBJECT PROGRAM
*
         USING IHIFSARA,R13
         USING IHIFSARB,R7
*
ALGIN    SPIE  PIEROUT,((1,9),12,15)   EXIT FOR RELEVANT PROG CHECKS
*
         ST    R1,FSAPICA(,R13)
*
*        GET STORAGE FOR RETURN ADDR STACK
*        INITIALIZE RAS POINTERS
*
         GETMAIN R,LV=2048
*
         SH    R1,EIGHT(,R13)
         ST    R1,RASPT(,R13)
         ST    R1,RASSTART(,R13)
         LA    R1,2056(,R1)
         ST    R1,RASPB(,R13)
         ST    R1,RASEND(,R13)
         SR    CDSA,CDSA               ZERO R10
*
*        INITIALIZE ALL DS ENTRIES FOR
*        S P K Q
*        FIRST, INIT OPTIONAL GET/PUT DSTABLE ENTRY
*
         L     R5,ADSTAB(,R13)         R5 -> IHIDSTAB IN OBJECT CODE
         L     R2,0(,R5)
         LA    R5,4(,R5)
         LTR   R2,R2                   THERE A PUT/GET CONTROL FILE ?
         BM    ALGIN01A                NO, BRANCH
         LA    R1,2048                 YES
         ST    R1,16(,R2)              INSERT BE LENGTH
         ST    CDSA,24(,R2)            INITIALIZE S, TYP IN PGCF
*
*        INIT ALL GENERATED DSTABLE ENTRIES
*
ALGIN01A LA    R2,0(,R2)               CLEAR HIGH ORDER BYTE
ALGIN01  CR    R2,R5                   ALL DSTABLE ENTRIES INITED ?
         BE    ALGIN02                 YES, BRANCH
         XC    0(DSTABLEL,R5),0(R5)    ZERO DSTABLE ENTRY
         MVC   S-ADCB(L'DSINIT,R5),DSINIT
         LA    R5,DSTABLEL(,R5)        INCR TO TEXT DSTABLE ENTRY
         B     ALGIN01                 LOOP BACK TO ALGIN01
*
ALGIN02  STH   CDSA,TRPGID             INITIALIZE TRACE COUNTERS
         ST    CDSA,TRPGID+2
         STC   CDSA,TRFLAG
         MVI   TRPGID+6,X'FF'
         MVI   TRPGID+7,X'FF'
         STH   CDSA,SCRCS(,R13)        INIT SEMICOLON COUNT TO ZERO
         ST    CDSA,ANOTTAB(,R13)      RESET NOTE TABLE ADDR TO ZERO
         ST    CDSA,SPDAP              RESET SPECIAL DECL POINTER
*
*        EXECUTION TIME OPTIONS AND SET SWITCHES
*
*        TEST FOR SHORT/LONG PRECISION
*
         L     R2,=A(IHIENTIF)         GET S/L SWITCH
         MVC   OPTSW(1,R13),8(R2)      FROM THE OBJECT MODULE
         MVC   CNVINST(CNVINSTL),CNVINSTE  ASSUME SHORT
         LA    R2,SETSHORT
         TM    OPTSW(R13),SHSW
         BO    ALGIN4                  IF SHORT
         MVC   CNVINST(CNVINSTL),CNVINSTD    MODIFY CONVERT ROUTINE
         LA    R2,4(,R2)
ALGIN4   LM    R3,R5,FPINSTAD          MODIFY FLOATING POINT
ALGIN4A  EX    0,0(R2)                 INSTRUCTIONS
         BXLE  R3,R4,ALGIN4A
*
*        CHECK EXECUTION PARAMETERS DUMP AND TRACE
*
ALGIN0   OI    TRACE+7(R13),X'F0'      DEACTIVATE BRANCH TO TRACE RT
         MVC   TRPGID+2(4),TRPGID+1    RESET PROGID FOR TRACE
         MVC   TRBEG(8),TRPGID         INITIALIZE TRACE LIMITS
         L     R2,4(,R13)
         ICM   R2,B'1111',24(R2)       R2 -> PARAMETER LIST
         BZ    ALGIN1                  BRANCH IF NO PARAMETERS
         L     R2,0(,R2)               ADDR OF PARAMETER FIELD
         LA    R2,0(,R2)               RESET HIGH ORDER BYTE
         LH    R3,0(,R2)
         LTR   R3,R3                   LENGTH OF PARAMETER FIELD
         BZ    ALGIN1                  NO PARAMETERS
         AR    R3,R2                   END OF PARAMETER FIELD
         LA    R5,LASTPARM             END OF PARAMETER LIST
         SR    R6,R6
FNDCOMMA CLI   2(R2),C','
         BNE   FNDPAR
STEP1    LA    R2,1(,R2)
COMP1    CR    R2,R3
         BL    FNDCOMMA
         B     ALGIN2                  WHOLE PARM FIELD SCANNED
*
FNDPAR   LA    R4,PARMLIST
         USING PARMLIST,R4
NXTPAR   IC    R6,PARMLG               LENGTH OF PARAMETER
         EX    R6,COMPINST             COMPARE WITH ENTRY IN LIST
         BNE   NOTFOUND
         LA    R1,1(R2,R6)
         EX    0,PABRANCH
CHKCOMMA CLI   2(R1),C','              CHECK FOR COMMA AFTER PARAM
         BE    SETBIT
         CR    R1,R3                   IF NO COMMA CHECK FOR END OF
         BL    STEP1                   PARAMETER FIELD
SETBIT   LR    R2,R1
         EX    0,PARMSET
         B     COMP1
*
NOTFOUND CR    R4,R5                   CHECK FOR END OF LIST
         LA    R4,PARLG(,R4)
         BL    NXTPAR                  NEXT ENTRY IN LIST
         B     INVOPT(R13)             OPTION NOT FOUND IN LIST
*
COMPINST CLC   2(0,R2),PARM
         DROP  R4
*
*        EVALUATE TRBEG OR TREND PARAMETER
*
TRLIM1   LA    R8,TRBEG
         B     TRLIM2A
*
TRLIM2   LA    R8,TREND
TRLIM2A  CLI   2(R1),C'='
         BNE   INVOPT(R13)
         LA    R9,5(,R1)               END OF NUMBER FIELD
         SR    R10,R10                 RESET NUMBER ACCUMULATOR
TRLIM4   LA    R1,1(,R1)               STEP TO NEXT DIGIT
         CR    R1,R3
         BNL   TRLIM3                  END OF WHOLE PARAM FIELD, BRANCH
         CLI   2(R1),C','
         BE    TRLIM3                  END OF THIS PARAMETER, BRANCH
         CR    R1,R9
         BH    INVOPT(R13)             TOO MANY DIGITS, BRANCH
         CLI   2(R1),C'0'              CHECK FOR VALID DIGIT
         BL    INVOPT(R13)
         CLI   2(R1),C'9'
         BH    INVOPT(R13)
         MVN   TRLDIG+1(1),2(R1)       EXTRACT NEW DIGIT
         MH    R10,=H'10'
         AH    R10,TRLDIG              ACCUMULATE SUM
         B     TRLIM4
*
TRLIM3   ST    R10,0(,R8)              STORE AS TRBEG OR TREND
         B     SETBIT
*
TRLDIG   DC    H'0'                    TEMP STORAGE FOR DIGIT
*
*        PREPARE FOR PROGRAM TRACING
*
ALGIN2   TM    DTSW(R13),TRSW          TRACE REQUESTED ?
         BZ    ALGIN1
*
         OPEN  (SYSUT1,(OUTIN))        OPEN SYSUT1 FOR USE BY TRACE
*
         LA    R3,SYSUT1
         USING IHADCB,R3
         TM    DCBOFLGS,DCBOFOPN       SYSUT1 OPENED ?
         BO    ALGIN3
         NI    DTSW(R13),255-TRSW      TRACE SWITCH OFF
         LA    R6,17                   SET DATASET NUMBER TO 17
         B     DDERROR(R13)
*
ALGIN3   NI    TRACE+7(R13),X'0F'      ACTIVATE BRANCH TO TRACE ROUT
         LH    R0,DCBBLKSI             GET BLOCK SIZE FROM DCB
         DROP  R3
         ST    R0,TRBUFL               STORE AS BUFFER LENGTH
         AR    R0,R0
*
         GETMAIN R,LV=(0)              GET TWO BUFFERS FOR SYSUT1
*
         ST    R1,TRBUF                R1 -> FIRST BUFFER
         SR    R0,R0
         ST    R0,TRCNT                RESET RECORD COUNTER
         LA    R0,4                    SET BYTE POINTER
         STH   R0,0(,R1)
         A     R1,TRBUFL
         ST    R1,TRBUFA               ALTERNATE BUFFER
*
*        INITIALIZE REGISTERS AND ENTER OBJECT MODULE
*
ALGIN1   SR    CDSA,CDSA
         L     R15,=A(IHIENTIF)
         LM    PBT,LAT,0(R15)
         L     R2,16                   R2 -> CVT ADDR
         L     R2,0(,R2)
         L     R2,4(,R2)               R2 -> TCB
         L     R2,0(,R2)               R2 -> RB ADDR
         L     R2,12(,R2)              INSERT RB NAME INTO PBTAB
         MVC   4(4,PBT),8(R2)
         MVC   TRMPNAME,8(R2)
         L     R15,8(,R15)
         BR    R15                     ENTER ALGOL PROGRAM
*
*        DCB EXIT ROUTINE FOR SYSUT1
*
         USING IHADCB,R1
SYSUT1X  LH    R2,DCBBLKSI
         LTR   R2,R2                   BLKSIZE SPECIFIED ?
         BNZ   DCBEXIT1                YES, BRANCH
DCBEXIT2 LA    R2,TRBUFST              ELSE USE STANDARD SIZE
         STH   R2,DCBBLKSI
*
DCBEXIT3 RETURN
*
DCBEXIT1 CH    R2,TRBUFMIN             CHECK BLKSIZE
         BL    DCBEXIT2                IF TOO LOW OR TOO HIGH,
         CH    R2,TRBUFMAX             USE STANDARD SIZE
         BH    DCBEXIT2
         B     DCBEXIT3
*
         DROP  R1
*
TRBUFMIN DC    H'14'                   MINIMUM TRACE BUFFER SIZE
TRBUFMAX DC    H'32760'                MAXIMUM TRACE BUFFER SIZE
*
TRBUFST  EQU   2048                    STANDARD TRACE BUFFER SIZE
*
*        DSTAB INITIALIZATION STRING
*
DSINIT   DC    XL6'00'
         ORG   DSINIT
         DC    AL2(1)                  S
         DC    AL2(80)                 P
         DC    AL1(2)                  K
         DC    AL1(0)                  Q
*
SETSHORT OI    0(R3),SHORTBIT          MODIFY FP INSTR FOR SHORT
         NI    0(R3),255-SHORTBIT      OR LONG PR
*
*        TABLE FOR DECODING OPTION PARAMETERS
*
PARMLIST DC    0H'0'
PARMLG   DC    AL1(3)                  (LENGTH - 1) OF KEYWORD
PARM     DC    CL5'DUMP'               OPTION KEYWORD
*
PABRANCH B     CHKCOMMA                EXIT TO EVALUATION ROUTINE
*
PARMSET  OI    DTSW(R13),DPSW          SET FLAG BIT
PARLG    EQU   *-PARMLG
         DC    AL1(4)
         DC    CL5'TRACE'
         B     CHKCOMMA
*
         OI    DTSW(R13),UCTRSW
         DC    AL1(4)
         DC    CL5'TRBEG'
         B     TRLIM1
*
         OI    DTSW(R13),TRSW
LASTPARM DC    AL1(4)
         DC    CL5'TREND'
         B     TRLIM2
*
         OI    DTSW(R13),TRSW
*
***********************************************************************
*
*        TERMINATION ROUTINE
*
***********************************************************************
*
*        ROUTINE IS ENTERED EITHER FROM THE ALGOL PROGRAM
*        UPON PASSING THE FINAL 'END' STATEMENT (NORMAL
*        TERMINATION) OR FROM THE ERROR ROUTINE (ABNORMAL
*        TERMINATION)
*
*        IN EITHER CASE IT EDITS AND PRINTS THE TRACE INFORMATION
*        IF ANY, CLOSES ALL DATASETS AND RESTORES THE REGISTERS
*        AS THEY WERE AT THE TIME OF ENTRY TO THE ALGOL PROGRAM
*
*        RETURN IS TO OS OR THE CALLING PROGRAM
*        THE COMPLETION CODE IS SET TO ZERO (NORMAL) OR 16
*        (ABNORMAL TERMINATION)
*
ALGTRMA  MVI   COMPCODE+3,16           ENTRY IN CASE OF ERROR
*
*        NORMAL ENTRY
*
ALGTRM0  LR    FSAA,R13                PREPARE FOR
         L     R5,ADSTAB(,R13)         OUTPUT TO SYSPRINT
         LA    R5,DSTABLEL+4(,R5)      BY MEANS OF I/O ROUTINES
         LA    R6,1                    DATASET 1 (ALGLDD01/SYSPRINT)
         USING DSTABLE,R5
         OI    DSF+1,DS15              FLAG CLOSE FROM IHIFSA
         L     R15,=V(IHIIORCP)        CLOSE ALL DATASETS USED
         BALR  R14,R15
ALGTRM00 OI    OPTSW(R13),TERMSW       FLAG TERM ROUTINE ENTERED
         TM    OPTSW(R13),PRNTERR      SYSPRINT OK ?
         BZ    ALGTRM16                YES, BRANCH
*
         WTO   MF=(E,WTOTRM)           NO, WRITE END EXEC MESSAGE
*
         B     ALGTRM10
*
*        OPEN SYSPRINT FOR TRACE AND TERM OUTPUT
*
ALGTRM16 OI    DSF+1,DS11              SET OPEN SYSPRINT FLAG
         OI    DSF,DS2+DS3             SET OUTPUT FLAGS, DATA IN BLOCK
         L     R15,=V(IHIIOROP)
         BALR  R14,R15                 OPEN SYSPRINT
*
ALGTRM1B BAL   R14,BLANK
         OI    DSF,DS3                 SET DATA IN BLOCK
         L     R15,=V(IHIIORNX)        CALL NEXT RECORD ROUTINE
         BALR  R14,R15
ALGTRM1  TM    DTSW(R13),TRSW
         BZ    ALGTRM11                NO TRACE OPTION, BRANCH
         TM    OPTSW(R13),UT1ERR
         BO    ALGTRM18                IF SYSUT1 ERROR
         LM    R8,R11,TRBUF            LOAD BUFFER PARAMETERS
         LTR   R11,R11
         BZ    ALGTRM2                 NO RECORDS WRITTEN, BRANCH
*
         CHECK TRCHECK                 CHECK LAST RECORD WRITTEN
*
         LH    R4,0(,R8)
         CH    R4,=H'4'
         BNH   ALGTRM3                 CURRENT BUFFER EMPTY, BRANCH
*
         WRITE TRCHECK,SF,,(R8),MF=E   WRITE LAST RECORD
*
         CHECK TRCHECK
*
         LA    R11,1(,R11)
*
ALGTRM3  CLOSE (SYSUT1,REREAD),TYPE=T  CLOSE TEMPORARY
*
         READ  TRCHECK,SF,,(R8),MF=E   READ FIRST RECORD
*
*        PRINT TRACE HEADLINES
*
ALGTRM2  BAL   R14,TRHEAD
ALGTRM4  LTR   R11,R11
         BNZ   ALGTRM9                 IF RECORDS ON SYSUT1
         LR    R9,R8
         B     ALGTRM5
*
ALGTRM9  CHECK TRCHECK                 CHECK PREVIOUS READ
*
         LM    R8,R9,TRBUF
         LR    R1,R8                   SWITCH BUFFERS
         LR    R8,R9
         LR    R9,R1
         STM   R8,R9,TRBUF
         BCT   R11,ALGTRM6             DECR RECORD COUNTER
         B     ALGTRM5                 NO MORE RECORDS, BRANCH
*
ALGTRM6  READ  TRCHECK,SF,,(R8),MF=E
*
ALGTRM5  LH    R4,0(,R9)               LOAD BYTE COUNT
         AR    R4,R9                   ADDR OF LAST BYTE PLUS ONE
         LA    R9,4(,R9)               R9 IS NOW BYTE POINTER
         L     R2,R                    SYSPRINT BYTE POINTER
         B     ALGTRM7
*
ALGTRM8  CLC   0(2,R9),TRPGID          NEXT ITEM A PROGID ?
         BNE   ALGTRM12                NO, BRANCH
         MVC   PROGID(4),2(R9)         STORE PROGID
         LA    R9,6(,R9)
         B     ALGTRM15
*
ALGTRM12 LA    R3,6(,R2)               ROOM FOR
         C     R3,RE                   ONE MORE OUTPUT ITEM ?
         BL    ALGTRM13                YES, BRANCH
ALGTRM15 OI    DSF,DS3                 SET DATA IN BLOCK
         L     R15,=V(IHIIORNX)
         BALR  R14,R15
         CLC   S(2),=H'1'              NEW PAGE ?
         BNE   ALGTRM14                NO, BRANCH
         BAL   R14,TRHEAD              PRINT PAGE HEADINGS
         B     ALGTRM15
*
ALGTRM14 L     R2,R
         BAL   R14,BLANK               INITIALIZE WITH BLANKS
         MVC   0(10,R2),PIDFIELD       PROGID AT START OF NEW LINE
         MVC   PROGID(4),PROGID-1      BLANKS TO RPOGID
         LA    R2,PIDLGTH(,R2)
ALGTRM13 LH    R3,0(,R9)
         LA    R9,2(,R9)               CONVERT SEMICOLON COUNTER
         CVD   R3,CONVBUF              PRINT AREA
         MVC   0(L'SCPATTN,R2),SCPATTN    MOVE IN PATTERN
         ED    0(L'SCPATTN,R2),CONVBUF+5  FORMAT SC COUNT
         LA    R2,6(,R2)               STEP OUTPUT BUFFER POINTER
         ST    R2,R
ALGTRM7  CR    R9,R4
         BL    ALGTRM8                 NOT END OF SYSUT1 REC, BRANCH
         LTR   R11,R11
         BNZ   ALGTRM9                 MORE RECORDS TO READ, BRANCH
         OI    DSF,DS3                 PRINT LAST LINE, DATA IN BLOCK
         L     R15,=V(IHIIORNX)        CALL NEXT RECORD ROUTINE
         BALR  R14,R15
*
*        CLOSE SYSUT1 AND FREE BUFFER AREA
*
ALGTRM18 CLOSE (SYSUT1)
*
         LM    R8,R9,TRBUF             GET LOWER
         LR    R1,R8                   BUFFER ADDR
         CR    R8,R9
         BL    *+6
         LR    R1,R9
         L     R0,TRBUFL
         SLA   R0,1
*
         FREEMAIN R,LV=(0),A=(1)       FREE SYSUT1 BUFFER
*
*        PRINT EXECUTION END MESSAGE
*
ALGTRM11 L     R2,R                    BYTE POINTER
         MVC   0(TML,R2),TRMSG         MOVE TERMINATION MESSAGE
         LA    R2,TML(,R2)
         ST    R2,R                    UPDATE BYTE POINTER
         LA    R2,2                    LOOP COUNTER FOR BLANK LINES
ALGTRM19 BAL   R14,BLANK
         OI    DSF,DS3                 DATA IN BLOCK
         L     R15,=V(IHIIORNX)        CALL NEXT RECORD ROUTINE
         BALR  R14,R15
         BCT   R2,ALGTRM19             ONE EXTRA BLANK LINE
         OI    DSF+1,DS15              FLAG CLOSE FROM IHIFSA
         L     R15,=V(IHIIORCL)        CLOSE SYSPRINT
         BALR  R14,R15
*
*        FINAL CLEAN-UP
*
ALGTRM10 L     R1,RASSTART(R13)        FREE RETURN ADDR STACK
         LA    R1,8(,R1)
*
         FREEMAIN R,LV=2048,A=(1)
*
ALGTRM17 L     R2,FSAPICA(,R13)
*
         SPIE  MF=(E,(R2))             RESTORE PICA
*
ALGTRMAA L     R13,4(,R13)
         L     R15,COMPCODE            RETURN CODE INTO R15
*
         RETURN (14,12),RC=(15)        TO OS OR THE CALLING PROGRAM
*
*        ROUTINE FOR FILLING A SYSPRINT RECORD WITH BLANKS
*
BLANK    STM   R2,R3,BLANKS
         L     R2,R                    CURRENT BYTE POINTER
         L     R3,RE                   RECORD END POINTER
BLANKA   CR    R2,R3
         BNL   BLANKB                  RECORD END, BRANCH
         MVI   0(R2),C' '              INSERT ONE BLANK
         LA    R2,1(,R2)               STEP TO NEXT BYTE
         B     BLANKA                  LOOP TO PROCESS NEXT CHAR
*
BLANKB   ST    R2,R                    UPDATED BYTE POINTER
         LM    R2,R3,BLANKS
         BR    R14
*
BLANKS   DC    2F'0'
*
*        ROUTINE FOR PRINTING TRACE OUTPUT HEADING
*
TRHEAD   STM   R14,R12,ASAVE+12(R13)   USE SECOND SAVE AREA
         LM    R2,R4,TRHADR            COUNTER FOR HEADLINES
TRHEAD1  L     R1,R
         BAL   R14,BLANK               INITIALIZE WITH BLANKS
         EX    0,0(R4)                 MOVE TEXT, OR NOP
         OI    DSF,DS3                 DATA IN BLOCK
         L     R15,=V(IHIIORNX)        CALL NEXT RECORD ROUTINE
         BALR  R14,R15
         BXLE  R4,R2,TRHEAD1
         BAL   R14,BLANK               BLANK LINE AFTER HEADING
         LM    R14,R12,ASAVE+12(R13)
         BR    R14
*
TRHADR   DC    A(6,TRHEND,TRHLIST)
*
TRHLIST  NOP   0                       BLANK LINE
         NOPR  0
         MVC   0(L'TRHEADA,R1),TRHEADA
         NOP   0                       BLANK LINE
         NOPR  0
TRHEND   MVC   0(L'TRHEADB,R1),TRHEADB
*
TRHEADA  DC    C'  ALGOL PROGRAM TRACE'         FIRST HEADLINE
*
TRHEADB  DC    C'MODULE     SEMICOLON NUMBERS'  SECOND HEADLINE
*
SCPATTN  DC    X'402020202020'         FORMAT SEMICOLON COUNT VALUE
*
WTOTRM   WTO   'END OF ALGOL PROGRAM EXECUTION',ROUTCDE=11,DESC=7,MF=L
*
TRMSG    EQU    WTOTRM+4
TML      EQU   *-TRMSG-4
*
*        ERROR AND END OF DATA ROUTINE FOR SYSUT1
*
ENDUT1   OI    OPTSW(R13),UT1ERR       SYSUT1 ERROR SWITCH ON
         LA    R6,17                   DUMMY DS NUMBER FOR SYSUT1
         B     ERROR32
*
*        PARAMETER LIST USED BY BOTH READ AND WRITE MACROS FOR
*        SYSUT1
*
         WRITE TRCHECK,SF,SYSUT1,MF=L
*
*        PARAMETERS FOR TRACE BUFFER
*
TRBUF    DC    F'0'                    -> CURRENT BUFFER
TRBUFA   DC    F'0'                    -> ALTERNATE BUFFER
TRBUFL   DC    F'0'                    L'BUFFER
TRCNT    DC    F'0'                    RECORD COUNTER
*
*        THE BYTE POINTER IS CONTAINED IN THE FIRST TWO BYTES OF
*        THE RECORD AND SERVES AS RECORD LENGTH FIELD
*
COMPCODE DC    F'0'                    COMPLETION CODE (0 OR 16)
*
*        WORK STORAGE FOR EDITING THE TRACE LISTING
*
PIDFIELD DC    CL2' '
PROGID   DC    CL4' '                  MODULE NAME
         DC    CL4' '
PIDLGTH  EQU   *-PIDFIELD
CONVBUF  DC    D'0'                    FOR CONVERTING SEMICOLON NUMBER
*
*        SYSUT1 DCB
*
SYSUT1   DCB   DSORG=PS,MACRF=(R,W),DDNAME=SYSUT1,RECFM=F,             X
               EODAD=ENDUT1,EXLST=EXLUT1,SYNAD=ENDUT1
*
EXLUT1   DC    X'85',AL3(SYSUT1X)
*
*        LTORG
*
*        DATASET TABLE ENTRY
*
         DSTABLE DSECT=YES
*
         PRINT NOGEN
*
         DCBD  DSORG=(BS),DEVD=(DA,TA)
*
         PRINT GEN
*
*        REGISTER EQUATES
*
         IEZREGS
*
         END
