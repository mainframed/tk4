IOR      TITLE 'IHIIORTN, LIBRARY I/O SERVICE ROUTINES, ALGOL F LIB'
*
*        COMPONENT ID - 360S-LM-532 ALGOL F LIBRARY
*
*        THE CODE HAS BEEN UPDATED -
*
*        1. ALL HARDCODED LENGTH CALCULATIONS FOR GETMAINED
*           AREAS USED FOR DCB, DECB ETC ARE NOW CALCULATED
*        2. ALL REFERENCES TO VARIOUS DCB FIELDS UTILIZE THE
*           MAPPING SYMBOLS PROVIDED BY DCBD
*        3. ALL REFERENCES TO VARIOUS JFCB FIELDS UTILIZE THE
*           MAPPING SYMBOLS PROVIDED BY IEFJFCBN
*        4. THE DCBS FOR SYSIN, SYSPRINT AND ALGLIB01 ARE OPENED
*           WITH OPEN OPTIONS SUITABLE FOR JES2/3 DATASETS
*           THIS WILL PREVENT 013-BC ABENDS THAT OCCURRED WITH THE
*           PREVIOUS RELEASE
*        5. NOTE/POINT CALLS ARE BYPASSED FOR JES2/3 DATASETS
*        6. ALL NUMERIC BRANCH CONDITIONS ARE RATIONALIZED TO USE
*           STANDARD ASSEMBLER MNEMONICS
*        7. MINOR CODE AND COMMENT CHANGES FOR IMPROVED READABILITY
*
*        FUNCTION/OPERATION -
*        THIS MODULE CONTAINS A SET OF SERVICE ROUTINES USED BY
*        OTHER I/O MODULES AS SUBROUTINES
*        THEY PERFORM THE FOLLOWING -
*        OPEN DATASET
*        CHANGE TO NEXT RECORD
*        CLOSE DATASET
*        CLOSE ALL DATASETS
*        CLEAR NOTTAB
*        ENTRY NOTTAB
*        EVALUATE DATASET NUMBER
*        END OF DATA HANDLING
*        SYNCHRONOUS ERROR HANDLING
*        CONVERT REAL TO INTEGER
*        MORE DETAIL BEFORE EACH ROUTINE
*
*        ENTRY POINTS -
*        IHIIOROP - OPEN A SYSIN/SYSOUT DATASET
*        IHIIOROQ - OPEN A DATASET
*        IHIIORNX - NEXTREC - CHANGE TO NEXT RECORD
*        IHIIORCL - CLOSE A DATASET
*        IHIIORCP - CLOSE ALL DATASETS
*        IHIIORCN - CLEAR NOTTAB
*        IHIIOREN - MAKE NOTTAB ENTRY
*        IHIIOREV - EVALUATE DATASET NUMBER
*        IHIIORCI - CONVERSION TO INTEGER
*        IHIIORED - DCB END OF DATA EXIT
*        IHIIORER - DCB SYNAD EXIT
*        ALL INVOKED BY BALR R14,R15
*        DIFFERENCE EXPLAINED BEFORE EACH ROUTINE
*
*        INPUT - SEE EACH ROUTINE
*
*        OUTPUT - SEE EACH ROUTINE
*
*        EXTERNAL ROUTINES - IHIGPR - CLOSE DATASET FOR PUT/GET
*
*        EXITS - NORMAL - ALL ROUTINES EXCEPT END OF DATA AND
*                         SYNAD RELOAD REGISTERS AND BR 14
*              - ERROR  - NO  EXPLANATION
*                         --  -----------
*                         0   DATASET NUMBER OUT OF RANGE
*                         1   REAL NUMBER TO BE CONVERTED OUT OF
*                             INTEGER RANGE
*                         2   INCOMPATIBLE ACTIONS ON SAME DATASET
*                         3   INPUT BEYOND LAST OUTPUT
*                         4   OVERFLOW OF NOTTAB
*                         5   INPUT REQUEST BEYOND END OF DATASET
*                         7   DATA SECTIONED AND NO CTRL CHARACTER
*                             SPECIFIED
*                         32  UNRECOVERABLE I/O ERROR
*                         37  BLOCKSIZE NOT A MULTIPLE OF RECORD
*                             LENGTH
*                         41  DDCARD INCORRECT OR MISSING
*              - ACTION - BRANCH TO IHGFSA
*                         LA 13,IHGFSA
*                         B  FSAERR+XX*4(13)  XX ERROR NUMBER
*
*        TABLES/WORK AREAS -
*        NOTTAB, FOR STORING OF RECORD IDENTIFICATION USING WHEN
*        REPOSITIONING, IS CREATED DYNAMICALLY WHEN OPEN A DATASET
*        WITH UNBLOCKED RECORD FORMAT SIZE OF 1024 BYTES
*
*        ATTRIBUTES - SERIALLY REUSABLE
*
*        NOTES -
*        THE OPERATION OF THIS MODULE DOES NOT DEPEND UPON A
*        SPECIAL INTERNAL REPRESENTATION OF THE EXTERNAL
*        CHARACTER SET
*
*        REGISTER USAGE
*
*        R5  -> RELEVANT ENTRY IN DSTAB
*        R6   = DATASET NUMBER
*        R7     PROGRAM BASE REGISTER
*        R8  -> DCB AND DECB'S
*        R12 -> FSA
*        R13 -> SAVE AREA
*        R14 -> RETURN
*        R15 -> ROUTINE
*
IHIIORTN CSECT
*
         ENTRY IHIIOROP
         ENTRY IHIIOROQ
         ENTRY IHIIORNX
         ENTRY IHIIORCL
         ENTRY IHIIORCP
         ENTRY IHIIORGP
         ENTRY IHIIORCN
         ENTRY IHIIOREN
         ENTRY IHIIOREV
         ENTRY IHIIORED
         ENTRY IHIIORCI
         ENTRY IHIIORER
*
*        DISPLACEMENT IN FSA
*
ADSTAB   EQU   X'AC'
ANOTTAB  EQU   X'B0'
OPTSW    EQU   X'C2'
FSAERR   EQU   X'1CC'
*
*----------------------------------------------------------------------
*
*        OPEN A DATASET
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        RESERVE STORAGE FOR AND COMPLETE A DCB AND TWO I/O BUFFERS
*
*        COMPLETE DSTAB FIELDS IN GENERATED OBJECT MODULE
*
*        STAB HAS AN ENTRY AND INDICATOR STATUS FOR EVERY DATASET
*        USED IN THE PROGRAM
*
*        INPUT -
*        IF DATASET SHOULD PERFORM ONLY INPUT OR OUTPUT BLOCKED
*        RECORD FORMAT IS USED ELSE UNBLOCKED FORMAT - ACCESS
*        METHOD BSAM.
*        IN CASE OF INPUT TWO RECORDS OR BLOCKS READ TO I/O
*        BUFFERS. BLOCKED RECORD FORMAT IS USED ONLY WHEN
*        BLOCKING FACTOR > 1
*
*        OUTPUT - N/A
*
*        NOTES -
*        R8 -> DCB THROUGH ALL I/O MODULES
*
*        ROUTINE IHIIOROQ IS ENTERED FROM SYSACT 12
*
IHIIOROQ SAVE  (14,12),,'IHIIOROQ LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R4,R15
         USING IHIIOROQ,R4
         LA    R7,IHIIOROP
         USING IHIIOROP,R7
         ST    R13,SAVAR+4
         LA    R13,SAVAR
         USING DSTABLE,R5              DSN RELEVANT ENTRY IN DSTABLE
         CH    R6,=H'1'                DATASET NUMBER 0 OR 1 ?
         BNH   OPEN00                  YES, BRANCH TO IHIIOROP
*        TM    DSF+1,DS14              DATASET BEEN OPEN BEFORE ?
*        BO    OPEN00                  YES
*
*        OPEN DATASET FOR THE FIRST TIME
*
*        GETMAIN AREA FOR DCB, DECB AND JFCB
*        EXAMINE THE DISP PARAMETER IN JFCB IF NEW OPEN THE
*        DATASET FOR OUTIN ELSE FOR INOUT
*
         LA    R0,DCBAREAL
*
         GETMAIN R,LV=(0)
*
         LR    R8,R1
         ST    R8,ADCB                 SAVE DCB ADDR IN DSTABLE
         USING IHADCB,R8
         MVC   0(DCBMODLN,R8),DCBMODEL  MOVE DCBMODEL INTO GETMAIN AREA
*
*        CONVERT BINARY DATASET NUMBER INTO CHARACTER TO
*        MOVE INTO THE DDNAME
*
         CVD   R6,DWORD
         UNPK  DWORD(2),DWORD+6(2)     EXTRACT LAST TWO DIGITS
         OI    DWORD+1,X'F0'           ADJUST SIGN
         MVC   DCBDDNAM+6(2),DWORD     MOVE INTO DCB DDNAME NUMBER
         LA    R3,JFCB
         STCM  R3,B'0111',ADCBEXIT+5   STORE JFCB AREA ADDR
*
         RDJFCB ((R8))
*
         TM    JFCBTSDM,JFCSDS         SYSIN/SYSOUT DATASET ?
         BZ    ROQA                    NO, BRANCH
*
*        SUBSYSTEM DATASET - NOT DATASET 0 OR DATASET 1
*        NO NOTE/POINT OPTION FOR JES2/3 DATASETS
*
         TM    JFCBIND2,JFCMOD         NEW OR MOD DATASET ?
         BO    ROQB                    YES, MUST BE SYSOUT
         MVC   DCBMACRF,=AL1(DCBMRRD,0)  NO POINT OPTION FOR SUBSYS DS
         B     ROQD
*
ROQB     MVC   DCBMACRF,=AL1(0,DCBMRWRT) NO POINT OPTION FOR SUBSYS DS
         OI    DSF,DS6                 SET OPEN FOR OUTPUT
         B     ROQD
*
*        NON SUBSYSTEM DATASET
*
ROQA     TM    JFCBIND2,JFCMOD         NEW OR MOD DATASET ?
         BZ    ROQD                    NO, BRANCH
         OI    DSF,DS6                 YES, SET OPEN FOR OUTPUT
*
*        FREE UP THE JFCB AREA AT THE END OF THE DCBAREA AS ITS NO
*        LONGER NEEDED
*
ROQD     LA    R1,JFCB                 R1 -> JFCB AREA
         LA    R0,JFCBLEN
*
         FREEMAIN R,LV=(0),A=(1)
*
         B     OPEN20
*
*----------------------------------------------------------------------
*
*        OPEN A SYSIN/SYSOUT DATASET
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        SPECIFIC PROCESSING FOR DATASET 0 (SYSIN) OR 1 (SYSOUT)
*
IHIIOROP SAVE  (14,12),,'IHIIOROP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         ST    R13,SAVAR+4
         LA    R13,SAVAR
*
*        BRANCH ENTRY FROM IHIIOROQ
*
*PEN00   CH    R6,=H'1'                SYSOUT DATASET ?
*        BNE   OPEN01                  NO, MUST BE SYSIN
*
*        DATASET NUMBER = 1 (SYSOUT) EITHER ALGLDD01 OR SYSPRINT
*        IF DATASET HAS BEEN OPENED BEFORE (DS14=1)
*        SET DS0 = 1 AND GO BACK. IF NOT OPEN THE DATASET
*
*        TM    DSF+1,DS14              PREVIOUSLY OPENED ?
*        BZ    OPEN01                  NO, BRANCH
*        OI    DSF,DS0                 SET DATASET OPEN
*        B     OPENRET
*
*        GETMAIN FOR DCB AND DECB, NO JFCB NEEDED AS SYSIN/SYSOUT
*
OPEN00   OI    DSF,DS0                 SET DATASET OPEN
         LA    R0,DCBAREAL-JFCBLEN
*
         GETMAIN R,LV=(0)
*
         ST    R1,ADCB
         LR    R8,R1                    R8 -> DCB
         MVC   0(DCBMODLN,R8),DCBMODEL  MOVE IN MODEL DCB
         CH    R6,=H'1'                 TEST DATASET NUMBER
         BL    DSIN                     0, SYSIN
         BE    DSPRINT                  1, ALGLDD01 OR SYSPRINT
*
*        CONVERT BINARY DSNUMBER TO CHAR IF NOT DATASET 0 OR 1
*
         CVD   R6,DWORD                DATASET NUMBER TO DDNAME
         UNPK  DWORD(2),DWORD+6(2)     EXTRACT LAST TWO DIGITS
         OI    DWORD+1,X'F0'
         MVC   DCBDDNAM+6(2),DWORD     MOVE IN DCB DDNAME NUMBER
         B     OPEN2
*
*        OPEN SYSIN DATASET
*
DSIN     MVC   DCBDDNAM,=CL8'SYSIN   '
         MVC   DCBMACR,=AL1(DCBMRRD,0)  NO POINT OPTION FOR SYSIN
*
         OPEN  ((R8),(INPUT))          INPUT ONLY FOR SYSIN
*
         B     OPEN300
*
*        OPEN SYSOUT DATASET
*
*        DS11 = 0 OPEN DATASET ALGLDD01
*        DS11 = 1 OPEN DATASET SYSPRINT
*
DSPRINT  TM    DSF+1,DS11             SYSPRINT ?
         BO    DSPR2                  YES, BRANCH
         MVC   DCBDDNAM+6(2),=CL2'01'  NO, LAST 2 CHARS OF DDNAME
         B     DSPR2A
*
DSPR2    MVC   DCBDDNAM,=CL8'SYSPRINT'
DSPR2A   MVC   DCBMACR(2),=AL1(0,DCBMRWRT)  NO POINT OPT FOR SYSOUT DS
         OI    DSF,DS6                 SET OPEN FOR OUTPUT
*
         OPEN  ((R8),(OUTPUT))        OUTPUT ONLY FOR SYSOUT
*
         B     OPEN300
*                                     SET MACRF=(RP,WP)
OPEN2    MVC   DCBMACR,=AL1(DCBMRRD+DCBMRPT1,DCBMRWRT+DCBMRPT2)
OPEN20   ICM   R2,B'1111',ANOTTAB(R12)  NOTE TABLE INITIALIZED ?
         BNZ   OPEN3                    YES, BRANCH
*
*        GETMAIN AND INITIALIZE NOTTAB
*
         LA    R0,1024
*
         GETMAIN R,LV=(0)              REQ STORAGE FOR NOTE TABLE
*
         ST    R1,ANOTTAB(R12)         SAVE ADDR OF STORAGE
         LR    R2,R1                   R2 -> ANOTTAB
         LR    R3,R1                   R3 -> ANOTTAB
         LA    R3,8(,R3)               STORE ADDR OF FIRST ENTRY +0
         ST    R3,0(,R2)               STORE POINTER NXE IN NOTTAB
         LA    R3,1016(,R3)
         ST    R3,4(,R2)               STORE LAST ADDR AT +4
OPEN3    TM    DSF,DS6                 OUTPUT POSSIBLE ?
         BO    OPEN30                  YES
*
         OPEN  ((R8),(INOUT))
*
OPEN300  TM    DCBOFLGS,DCBOFOPN       OPEN SUCCESSFUL ?
         BO    OPEN355                 YES, BRANCH
         NI    DSF+1,255-DS14          NO, SET DS14 = 0 DS NOT OPEN
         LR    R13,R12                 DD STMT INCORRECT OR MISSING
         B     FSAERR+41*4(,R12)
*
OPEN30   OPEN  ((R8),(OUTIN))
*
         B     OPEN300                 CONTINUE
*
OPEN355  TM    EXERFLAG,X'11'          ERROR FLAG SET IN DCBEXIT ?
         BZ    OPEN301                 NO ERRORS, BRANCH
*
*        ERROR SET IN DCB OPEN EXIT
*
*        CLOSE DATASET AND FREEMAIN FOR DCB AND DECB
*
         CLOSE ((R8))
*
         FREEMAIN R,LV=DCBAREAL-JFCBLEN,A=(R8)
*
         LR    R13,R12
         TM    EXERFLAG,X'01'          ERROR 7 IN DCBEXIT ?
         MVI   EXERFLAG,X'00'          CLEAR FLAG
         BZ    OPEN350
         B     FSAERR+7*4(,R12)        ERROR 7
*
OPEN350  B     FSAERR+37*4(,R12)       ERROR 37
*
*        OPEN SUCCESSFULLY COMPLETED
*
OPEN301  OI    DSF,DS0                 SET DATASET OPEN
         OI    DSF+1,DS14              SET DATASET OPENED
         CH    R6,=H'1'                DATASET NUMBER = 0 OR 1 ?
         BNH   OPEN301A                YES, BRANCH
         OI    STORFLAG+1,DS14         SET DS14 ON IN STORFLAGS
OPEN301A LH    R0,DCBBLKSI             GET DCBBLKSI
         AR    R0,R0                   DOUBLE IT
*
         GETMAIN R,LV=(0)              GET AREA FOR TWO BUFFERS
*
         ST    R1,BB                   STORE GETMAINED ADDR IN BB
         LR    R2,R1                   R2 -> FIRST BUFFER
         AH    R1,DCBBLKSI             ADD L'BUFFER
         ST    R1,NBB                  STORE ALTERNATE BUFFER ADDR
         TM    DSF,DS6                 OPENED FOR OUTPUT ?
         BO    OPEN4                   YES, BRANCH
         OI    DSF+1,DSOREAD           INDICATE READ ISSED BY OPEN
*
OPEN311  READ  DECBIO,SF,(R8),(R2),MF=E  READ FIRST BLK INTO FIRST BUFF
*
         CHECK DECBIO                  EOF MAY BE RAISED AT THIS POINT
*
         MVI   DECBIO+8,255            MARK AS COMPLETED
         TM    DSF,DS7                 END OF FILE ?
         BO    OPENRET                 YES, RETURN TO CALLER TO PROCESS
         NI    DSF+1,255-DSOREAD       RESET READ ISSUED BY OPEN FLAG
*
*        DETERMINE LENGTH OF BLOCK READ
*
         LH    R1,DCBBLKSI             R1 = DCBBLKSI
         LA    R4,DECBIO               R4 -> DECB
         USING DECB,R4
         L     R4,DECIOBPT             R4 -> IOB
         DROP  R4
         USING IOB,R4
         SH    R1,IOB-IOBSTDRD+IOBCSW+5   SUB RESIDUAL CSW LENGTH
         DROP  R4
         STH   R1,BL                   SET RESULT AS BLOCK LENGTH
*
*        DETERMINE IF NOTE ENTRY REQUIRED
*
         SR    R1,R1                   ZERO R1 FOR NOTE BYPASS
         TM    DCBNOTE+3,1             NOTE/POINT SPECIFIED IN DCB ?
         BO    OPEN312                 NO, BRANCH AROUND NOTE
*
         NOTE  (R8)
*
OPEN312  ST    R1,NOTEADR
*
*        READ INTO ALTERNATE BUFFER
*
         L     R3,NBB                  R3 -> ALTERNATE BUFFER
*
         READ  DECBIO,SF,(R8),(R3),MF=E  READ SECOND BLOCK
*
         B     OPEN5
*
OPEN4    TM    DSF+1,DS9               DATASET SECTIONED ?
         BZ    OPEN5                   NO, BRANCH
         MVI   0(R2),C'1'              YES, INSERT FIRST ASA CNTL CHAR
         LA    R2,1(,R2)               INCR CHARACTER POINTER
OPEN5    ST    R2,R                    STORE FIRST BUFFER ADDR
*                                      IN CHARACTER POINTER
         AH    R2,P                    ADD RECORD LENGTH
         ST    R2,RE                   STORE END CHARACTER POINTER
OPENRET  L     R13,SAVAR+4
         RETURN (14,12)                RETURN
*
*----------------------------------------------------------------------
*
*        DCB OPEN EXIT ROUTINE
*
*----------------------------------------------------------------------
*
IHIIORDX TM    DSF+1,DS11              OPEN FOR SYSPRINT ?
         BZ    EXIT3                   NO, BRANCH
*
*        EXIT ROUTINE FOR SYSPRINT
*
*        CONVERT ALGLDD01 FOR USE AS SYSPRINT FOR ISSUING ERROR
*        MESSAGES AND TRACE DATA
*
*        SET DSTABLE ENTRY AND DCB TO CORRECT VALUES FOR SYSPRINT
*
         MVI   Q,50                    RECORD IS SECTIONED Q=50
         LA    R4,90                   RECORD LENGTH P=90
         STH   R4,P                    R4 = L'RECORD
         MVI   DCBRECFM,DCBRECF+DCBRECCA  SET RECORD FORMAT=FA
         OI    DSF+1,DS9               SET FLAG REC CONT CONTR CHAR
         LA    R4,1(,R4)               INCR L'RECORD FOR CONTROL CHAR
         STH   R4,DCBLRECL             MAKE DCBLRECL = P+1
*
*        EXAMINE DCBBLKSI
*
         SR    R3,R3
         ICM   R3,B'0011',DCBBLKSI     R3 = DCBBLKSI
         BZ    EXITA                   DCBBLKSI = 0, BRANCH
         SR    R2,R2
         DR    R2,R4                   DCBBLKSI/DCBLRECL
         LTR   R3,R3                   DCBBLKSI < LRECL ?
         BZ    EXITA                   YES, BRANCH
         BCT   R3,EXITB                DCBBLKSI MULTIPLE OF LRECL ?
*                                      YES, BRANCH
EXITA    STH   R4,DCBBLKSI             NO, SET DCBBLKSI TO DCBLRECL
         NI    DSF,255-DS1             SET FLAG DATASET UNBLOCKED
EXITC    MVC   BL,DCBBLKSI             SAVE BLKSIZE VALUE
         B     RETEX                   RETURN TO OPEN
*
EXITB    LA    R3,1(,R3)               DCBBLKSI MULTIPLE OF DCBLRECL
         MH    R3,DCBLRECL             ENSURE DCBBLKSI IS A MULTIPLE
         STH   R3,DCBBLKSI             OF DCBLRECL
         OI    DCBRECFM,DCBRECBR       SET RECORD FORMAT=FBA
         OI    DSF,DS1                 SET FLAG DATASET BLOCKED
         B     EXITC
*
*        STANDARD EXIT ROUTINE
*
EXIT0    TM    DCBRECFM,X'FF'          RECFM PROVIDED ?
         BZ    EXIT1                   NO, BRANCH
         TM    DCBRECFM,DCBRECF+DCBRECCA  YES, RECFM = FA OR FBA ?
         BO    EXIT4                   YES, BRANCH
         CLI   Q,0                     RECORDS PER SECTION PROVIDED ?
         BE    RETEX                   NO, BRANCH
         OI    EXERFLAG,X'01'          DATASET SPLIT INTO SECTIONS
         B     RETEX                   AND NO CTL CHARACTER ERROR NO 7
*
*        NO RECFM PROVIDED
*
EXIT1    OI    DCBRECFM,DCBRECF        SET RECFM = F
         TM    DSF,DS1                 DATASET BLOCKED ?
         BO    EXIT12                  YES, BRANCH
         OI    DCBRECFM,DCBRECBR       NO, SET RECFM = BLOCKED
EXIT12   TM    DSF+1,DS9               DATASET SECTIONED ?
         BZ    RETEX                   NO, BRANCH
         OI    DCBRECFM,DCBRECCA       YES, SET RECFM = ASA CNTL
         B     RETEX                   RETURN TO OPEN
*
EXIT4    OI    DSF+1,DS9               SET DATASET SECTIONED
         B     RETEX                   RETURN TO OPEN
*
*        EXAMINE LRECL
*
EXIT3    OI    DSF,DS1                 SET DATASET BLOCKED FLAG
         CLI   Q,0                     DATASET SECTIONED ?
         BZ    EXIT3A                  NO, BRANCH
         OI    DSF+1,DS9               YES, SET DATASET SECTIONED FLAG
EXIT3A   SR    R4,R4
         ICM   R4,B'0011',DCBLRECL     R4 = DCBLRECL
         BZ    EXIT2                   DCBLRECL NOT PROVIDED, BRANCH
         TM    DSF+1,DS9               DATASET SECTIONED ?
         BO    EXIT5                   YES, BRANCH
         STH   R4,P                    NO, SET P TO DCBLRECL
         B     EXIT6
*
*        DATASET SECTIONED
*
EXIT5    BCTR  R4,0                    ALLOW FOR ASA CNTL IN RECORD
         STH   R4,P                    SET P TO DCBLRECL-1
         LA    R4,1(,R4)               RESTORE R4
         B     EXIT6
*
*        NO DCBLRECL VALUE PROVIDED
*
EXIT2    TM    DSF+1,DS9               DATASET SECTIONED ?
         BO    EXIT7                   YES, BRANCH
         LH    R4,P
         STH   R4,DCBLRECL             SET DCBLRECL VALUE TO P
         B     EXIT6
*
*        NO DCBLRECL VALUE PROVIDED, DATASET SECTIONED
*
EXIT7    LH    R4,P
         LA    R4,1(,R4)               P+1 TO LRECL
         STH   R4,DCBLRECL
*
*        EXAMINE BLKSIZE
*
EXIT6    LH    R3,DCBBLKSI             R3 = DCBBLKSI
         LTR   R3,R3                   DCBBLKSI = 0 ?
         BZ    EXIT8                   YES, BRANCH
         CR    R4,R3                   DCBBLKSI = DCBLRECL ?
         BE    EXIT61A                 YES, BRANCH
         SR    R2,R2
         DR    R2,R4                   DCBBLKSI/DCBLRECL
         LTR   R2,R2                   ANY REMAINDER ?
         BZ    EXIT61                  NO, BRANCH
         OI    EXERFLAG,X'10'          YES, BLOCKSIZE NOT A MULTIPLE OF
         B     RETEX                   LRECL LENGTH ERROR NO 37
*
EXIT61   NI    DSF,255-DS1             SET FLAG UNBLOCKED FORMAT
EXIT61A  MVC   BL,DCBBLKSI             SET BL TO DCBBLKSI
         B     EXIT0                   BACK THROUGH EXIT PROCESSING
*
EXIT8    STH   R4,DCBBLKSI             SET DCBBLKSI = DCBLRECL
         STH   R4,BL                   SET BL = DCBLRECL
         B     EXIT0                   BACK THROUGH EXIT PROCESSING
*
RETEX    RETURN ,                      RETURN TO OPEN
*
*----------------------------------------------------------------------
*
*        NEXTREC - CHANGE TO NEXT RECORD
*
*----------------------------------------------------------------------
*
*        INPUT -
*        IN CASE OF AN IN-MODULE CALLING NEXTREC, LAST I/O
*        OPERATION IS CHECKED FOR COMPLETION AND ONE BLOCK OR
*        RECORD IS READ TO THE OTHER I/O BUFFER
*
*        OUTPUT -
*        IN CASE OF AN OUT-MODULE CALLING NEXTREC, LAST I/O
*        OPERATION IS CHECKED FOR COMPLETION AND ONE BLOCK OR
*        RECORD IS WRITTEN TO THE DATASET
*
*
IHIIORNX SAVE  (14,12),,'IHIIORNX LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIORNX,R7
         ST    R13,SAVAR+4
         LA    R13,SAVAR
*
*        SPECIAL ENTRY POINT FROM IHIIORCL
*
CLOSENT  L     R8,ADCB                 R8 -> DCB
         TM    DSF,DS2+DS6             LAST I/O OUT + OPEN FOR OUTPUT ?
         BZ    NXIN1                   NO, BRANCH TO INPUT PROCESSING
         BO    NXUT1                   DS2 AND DS6 ON, BRANCH
*
*        DS6=0 DS2=1
*        CURRENT BLOCK WAS READ AND SHOULD BE WRITTEN BACK
*
         CHECK DECBIO
*
         MVI   DECBIO+8,255            MARK AS COMPLETED
         MVC   BL,DCBBLKSI             SET BLOCK LENGTH TO DCBBLKSI
         TM    DCBPOINT+3,1            POINT SPECIFIED IN THE DCB ?
         BO    NXUT1A                  NO, BRANCH AROUND POINT
*
         POINT (8),NOTEADR
*
NXUT1A   OI    DSF,DS6                 SET OPEN FOR OUTPUT
*
*        DS6=1 DS2=1 WRITE BLOCK IF LAST RECORD
*
NXUT1    TM    DSF,DS1                 DATASET BLOCKED ?
         BZ    NXUT2                   NO, BRANCH
*
*        CHANGE BUFFERS
*
NXUT3    L     R2,BB                   R2 -> CURRENT BUFFER
         L     R4,NBB                  R4 -> ALTERNATE BUFFER
         ST    R4,BB                   SWAP CURRENT BUFFER WITH
         ST    R2,NBB                  ALTERNATE BUFFER
         ST    R4,R                    SET THE NEW CHARACTER POINTER
         AH    R4,P                    ADD THE L'RECORD
         ST    R4,RE                   SET THE END OF RECORD PTR
         NI    DSF,255-DS3             SET OFF DATA IN BLOCK FLAG
NXUT4    C     R8,DECBIO+8             DECB DCB ADDR = CURRENT DCB ?
         BNE   NXUT41                  NO, BRANCH
*
         CHECK DECBIO
*
         MVI   DECBIO+8,255            MARK DECB AS COMPLETED
*
NXUT41   WRITE DECBIO,SF,(R8),(R2),MF=E
*
*        CLEAR NOTTAB IF BACKWARD REPOSITIONING HAS OCCURED
*
NXUT5    TM    DSF,DS5                 BACKWARD POSITIONING ?
         BZ    NXUT6                   NO, BRANCH
         L     R15,VIORCN              YES, R15 -> IHIIORCN
         BALR  R14,R15                 CALL IHIIORCN
         NI    DSF,255-DS5
*
*        INSERT NOTTAB ENTRY IF REQUESTED
*
NXUT6    TM    DSF,DS4                 NOTE TABLE ENTRY REQUESTED ?
         BZ    NXUT7                   NO, BRANCH
*
         CHECK DECBIO
*
         MVI   DECBIO+8,255            MARK DECB AS COMPLETED
         SR    R1,R1                   ZERO R1 IN CASE NOTE BYPASSED
         TM    DCBNOTE+3,1             NOTE SPECIFIED IN DCB ?
         BO    NXUT6A                  NO, BYPASS NOTE
*
         NOTE  (R8)
*
NXUT6A   ST    R1,NOTEADR
         L     R15,VIOREN              R15 -> IHIIOREN
         BALR  R14,R15                 CALL IHIIOREN
         NI    DSF,255-DS4
*
*        INSERT CONTROL CHARACTER IF SECTIONED
*
NXUT7    TM    DSF+1,DS9               SECTIONED ?
         BZ    NXRET                   NO, BRANCH
         L     R4,R                    R4 = CHARACTER POINTER
         CLC   S+1(1),Q                RECORD PTR > NO OF SECTION RECS?
         BL    NXUT8                   NO, BRANCH
         SR    R2,R2                   YES, NEW PAGE
         STH   R2,S                    SET RECORD POINTER TO ZERO
         MVI   0(R4),C'1'              MOVE ASA CNTL INTO BUFFER
         B     NXUT9
*
*        SETUP VALUES FOR NEW BUFFER AFTER BUFFER SWAP
*
NXUT8    MVI   0(R4),C' '              SET ASA CNTL TO BLANK
NXUT9    LA    R4,1(,R4)               INCR CHARACTER POINTER
         ST    R4,R                    STORE UPDATED VALUE
         AH    R4,P                    ADD RECORD LENGTH
         ST    R4,RE                   SET NEW END OF BUFFER ADDR
*
*        INCREASE RECORD POINTER AND RETURN
*
NXRET    LH    R2,S
         LA    R2,1(,R2)
         STH   R2,S
*
NXRETEOD L     R13,SAVAR+4
         RETURN (14,12)
*
*        BLOCKED FORMAT
*        CHECK IF LAST RECORD IND IF NOTTAB ENTRY REQUIRED
*
NXUT2    L     R2,BB                   R2-> CURRENT BUFFER
         AH    R2,BL                   ADD L'BUFFER
         C     R2,RE                   END OF BUFFER = RECORD END ?
         BE    NXUT3                   YES, BRANCH
         L     R4,RE                   NO, R4 -> RECORD END
         ST    R4,R                    SET CHARACTER POINTER TO RE
         AH    R4,P                    ADD L'RECORD
         ST    R4,RE                   STORE AS NEW RECORD END
         TM    DSF,DS4                 NOTE TABLE ENTRY REQUESTED ?
         BZ    NXUT7                   NO, BRANCH
         NI    DSF,255-DS6             YES, SET OFF OPEN FOR OUTPUT
         L     R2,BB                   R2 -> CURRENT BUFFER
         B     NXUT4
*
*        INPUT PROCESSING
*
*        DATASET NOT OPEN FOR OUTPUT
*        DS6=0 DS2=0
*        CHECK IF NOTTAB ENTRY REQUIRED
*        STORE ADDR OF LAST BLOCK IN NOTEADR AND READ NEXT BLOCK
*
NXIN1    TM    DSF,DS4                 NOTE TABLE ENTRY REQUESTED ?
         BZ    NXIN2                   NO, BRANCH
         L     R1,NOTEADR              YES, MAKE A NOTE TABLE ENTRY
         L     R15,VIOREN
         BALR  R14,R15
         NI    DSF,255-DS4             SET OFF NOTE TABLE ENTRY REQ
NXIN2    TM    DSF,DS1                 DATASET BLOCKED ?
         BZ    NXIN5                   NO, BRANCH
*
NXIN3    CHECK DECBIO
*
         MVI   DECBIO+8,255            MARK DECB AS COMPLETED
         TM    DSF,DS7                 END OF FILE ?
         BO    NXRETEOD                YES, RETURN TO CALLER TO PROCESS
*
*        DETERMINE LENGTH OF BLOCK READ
*
         LH    R1,DCBBLKSI             R1 = DCBBLKSI
         LA    R4,DECBIO               R4 -> DECB
         USING DECB,R4
         L     R4,DECIOBPT             R4 -> IOB
         DROP  R4
         USING IOB,R4
         SH    R1,IOB-IOBSTDRD+IOBCSW+5   SUB RESIDUAL CSW LENGTH
         DROP  R4
         STH   R1,BL                   SET RESULT AS BLOCK LENGTH
*
*        DETERMINE IF NOTE ENTRY TO BE MADE
*
         SR    R1,R1                   ZERO R1 FOR NOTE BYPASS
         TM    DCBNOTE+3,1             NOTE OPTION SPECIFIED IN DCB ?
         BO    NXIN6A                  NO, BRANCH TO BYPASS NOTE
*
         NOTE  (R8)
*
NXIN6A   ST    R1,NOTEADR
         L     R2,BB                   R2 - > FIRST BUFFER
*
         READ  DECBIO,SF,(R8),(R2),MF=E   ISSUE READ FOR NEXT RECORD
*
*        CHANGE BUFFERS
*
NXIN6    L     R2,BB                   SWAP BUFFER ADDRS
         L     R4,NBB
         ST    R4,BB
         ST    R4,R                    SET NEW CHARACTER POINTER
         AH    R4,P                    CALC NEW BUFFER END ADDR
         ST    R4,RE
         ST    R2,NBB
         B     NXRET
*
*        BLOCKED FORMAT
*
NXIN5    L     R2,BB
         AH    R2,BL
         C     R2,RE
         BE    NXIN3
         L     R4,RE
         ST    R4,R
         AH    R4,P
         ST    R4,RE
         B     NXRET
*
*----------------------------------------------------------------------
*
*        CLOSE A DATASET
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        CLOSE A DATASET
*        RELEASE STORAGE FOR I/O BUFFERS AND DCB
*        CALL CLEAR NOTTAB ROUTINE
*
*        OUTPUT -
*        IN CASE OF OUTPUT WRITE LAST BLOCK TO DATASET
*
IHIIORCL SAVE  (14,12),,'IHIIORCL LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIORCL,R7
         ST    R13,SAVAR+4             SAVE REGISTER
         LA    R13,SAVAR
         L     R8,ADCB                 R8 -> DCB
         CH    R6,=H'1'                DATASET 1 (ALGLDD01/SYSPRINT) ?
         BNE   CLOSE01                 NO, BRANCH
*
*        DATASET 1
*
*        IF DS15 = 0 FILL CURRENT BLOCK WITH BLANKS AND CALL
*        ROUTINE IHIIORNX TO WRITE THE BLOCK
*
         TM    DSF+1,DS15              YES, CLOSE REQUEST FROM IHIERR ?
         BO    CLOSE01                 YES, BRANCH
         OI    DSF,DS2+DS6             NO, SET LAST I/O OUTPUT AND
*                                      OPENED FOR OUTPUT
         NI    DSF,255-DS0             SET OFF DATASET OPEN
         LH    R2,BL
         A     R2,BB                   CALCULATE PADDING REQUIRED
         L     R3,R
         ST    R2,R
         SR    R2,R3
         BZ    CLOSE02
CLOSE03  MVI   0(R3),C' '              PAD RECORD
         LA    R3,1(,R3)
         BCT   R2,CLOSE03              LOOP TO END OF RECORD
CLOSE02  NI    S,X'00'
         MVC   S+1(1),Q
         L     R7,VIORNX               R15 -> IHIIORNX
*                                      USE SPECIAL ENTRY POINT INTO
*                                      IHIIORNX
         B     CLOSENT-IHIIORNX(,R7)   CALL IHIIORNX
*
CLOSE01  TM    DSF,DS7                 END OF DATA REACHED
         BO    CLOSE1                  YES, BRANCH
         TM    DSF+1,DSIOERR           I/O ERROR ?
         BO    CLOSE1                  YES, GO CLOSE DCB
         C     R8,DECBIO+8             CHECK PENDING FOR I/O ?
         BNE   CLOSE2                  NO, BRANCH
         OI    DSF+1,DS8               SET DS8=1 FOR NO MORE DATA
*
CLOSE0   CHECK DECBIO                  LAST I/O FINISHED
*
         MVI   DECBIO+8,255            MARK DECB AS FREE
CLOSE2   TM    DSF,DS2                 LAST I/O OUTPUT ?
         BZ    CLOSE1
         TM    DSF,DS6                 BLOCK BEEN READ ?
         BO    WRITE2
         TM    DCBPOINT+3,1            POINT OPTION SPECIFIED IN DCB ?
         BO    WRITE1                  NO, BRANCH
*
         POINT (8),NOTEADR             NO BLANKS
*
         B     WRITE1
*
WRITE2   TM    DSF,DS3                 OUTPUT DATA IN BLOCK ?
         BZ    CLOSE1                  NO, CLOSE
*
*        OUTPUT HAS OCCURED, FILL BUFFER WITH BLANKS AND WRITE
*
WRITE1   LH    R2,BL                   R2 = L'BLOCK
         L     R3,R                    R3 -> CHARACTER POINTER
         S     R2,R                    CALC NUMBER OF BYTES OD DATA
         A     R2,BB                   ADD TO BUFFER ADDR
         BZ    CLOSE21                 NO PADDING REQUIRED, BRANCH
CLOSE22  MVI   0(R3),C' '              PAD WITH BLANKS
         LA    R3,1(,R3)               INCR POINTER
         BCT   R2,CLOSE22              LOOP
*
*        WRITE BUFFER
*
CLOSE21  L     R2,BB
*
CLOSE211 WRITE DECBIO,SF,(R8),(R2),MF=E
*
         CHECK DECBIO
*
         MVI   DECBIO+8,255            MARK DECB AS COMPLETED
CLOSE1   ICM   R1,B'1111',BB           R1 -> BUFFER
         BZ    CLOSE1A                 NO BUFFER OR ALREADY FREED
         C     R1,NBB                  FIND FIRST BUFFER
         BL    *+8                     THE LOWEST ADDR TO R1
         L     R1,NBB
         SR    R0,R0
         ST    R0,BB                   MARK BUFFERS AS FREED
         ICM   R0,B'0011',DCBBLKSI     BUFFER LEN TO R0
         BZ    CLOSE1A                 NO BLKSIZE, BRANCH
         AR    R0,R0                   FREE TWO BUFFERS
*
*        FREEMAIN FOR RECORD BUFFERS
*
         FREEMAIN  R,LV=(0),A=(1)
*
*        CLOSE DATASET
*
CLOSE1A  TM    DCBOFLGS,DCBOFOPN       DATASET NOT OPEN ?
         BNO   CLOSE1X                 YES, NOT OPEN, BYPASS CLOSE
*
         CLOSE ((R8),REREAD)
*
*        FREEMAIN FOR DCB AND DECB
*
         LA    R0,DCBAREAL-JFCBLEN
*
CLOSE1X  FREEMAIN R,LV=(0),A=(R8)
*
*        RESTORE DSTABLE ENTRY
*
         LA    R2,1
         STH   R2,S                     SET RECORD PTR TO ONE
         MVC   P(2),=H'80'              P=80
         LTR   R2,R6                    DATASET ZERO (SYSIN) ?
         BZ    CLOSE3                   YES, BRANCH
         BCT   R2,CLOSE4                IF DATASET 1 THEN BYPASS
*                                       CLEAR NOTETAB CALL
         B     CLOSE3
*
CLOSE4   L     R15,VIORCN               FREE NOTE TABLE ENTRIES
         BALR  R14,R15                  CLEAR NOTTAB FOR DATASET
CLOSE3   MVC   DSF,STORFLAG             RESTORE DATASET FLAGS
         L     R13,SAVAR+4
*
         RETURN (14,12)
*
*----------------------------------------------------------------------
*
*        CLOSE ALL DATASETS
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        CALL ROUTINE CLOSE FOR ALL OPEN DATASETS AND ROUTINE
*        CLOSEGP IN IHIGPR MODULE
*
*        THIS ROUTINE IS CALLED FROM IHIFSA AND IHIERR. IN BOTH
*        CASES R5 CONTAINS THE ADDR OF THE ENTRY IN DSTABLE
*        FOR DATASET ONE IE DSTABLE+40
*
IHIIORCP SAVE  (14,12),,'IHIIORCP LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIORCP,R7             SAVE REGISTER
         ST    R13,SAVCLO+4
         LA    R13,SAVCLO
         SR    R6,R6                   ZERO DSNR REG
         SH    R5,=H'40'               DSN TO DSTABLE START
         ICM   R2,B'1111',0(R5)        TEST APGCF
         BP    CLOSEPE4                PUT/GET ENTRY IN DSTABLE
*
*        PROCESS DATASETS 0-15
*
         LA    R2,0(,R2)               ZERO HIGH ORDER BYTE
CLOSEPE0 LA    R5,4(,R5)               R5 -> FIRST DSTABLE ENTRY
CLOSEPE2 CR    R2,R5                   ALL DATASETS CLOSED ?
         BE    CLOSEPE3                YES, BRANCH
         NI    STORFLAG+1,255-DS6      NO, SET OFF DS6 IN STORFLAG
CLOSEPE7 TM    DSF,DS0                 NO, DATASET OPEN ?
         BZ    CLOSEPE1                NO, BYPASS CLOSE ROUTINE
*
*        CALL CLOSE DATASET ROUTINE
*
CLOSEPE6 L     R8,ADCB                 R8 -> DCB
         L     R15,ACLOSE              CALL IHIIORCL FOR DATASET
         BALR  R14,R15
CLOSEPE1 LA    R5,DSTABLEL(,R5)        NEXT ENTRY IN DSTAB
         LA    R6,1(,R6)               INCR DATASET NUMBER
         B     CLOSEPE2                LOOP TO NEXT DATASET
*
*        PUT/GET DATASET PROCESSING
*
CLOSEPE4 TM    27(R2),X'80'            PUT/GET DATASET OPEN ?
         BZ    CLOSEPE2-4              DATASET CLOSED
         L     R15,IHIIORGP
         BALR  R14,R15                 CLOSE PUT/GET DATASET
         B     CLOSEPE0                RETURN TO PROCESS DATASETS 0-15
*
*        ALL DATASETS ARE CLOSED
*
CLOSEPE3 ICM   R1,B'1111',ANOTTAB(R12) NOTE TABLE GETMAINED ?
         BZ    RETCLOSP                NO, BYPASS FREEMAIN
*
         LA    R0,1024
*
         FREEMAIN R,LV=(0),A=(1)       FREE NOTTAB
*
RETCLOSP L     R13,SAVCLO+4
*
         RETURN (14,12)
*
SAVCLO   DC    18F'0'
*
*        EXTERNAL ADDR
*
ACLOSE   DC    A(IHIIORCL)
*
IHIIORGP DC    A(0)
*
*----------------------------------------------------------------------
*
*        CLEAR NOTTAB
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        ALL ENTRIES IN NOTTAB FOR RECORDS EQUAL OR GREATER THAN
*        ACTUAL RECORD COUNTERS ARE CLEARED BY INSERTING INVALID
*        FLAG
*
IHIIORCN SAVE  (14,12),,'IHIIORCN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15                  DEFINE BASE REGISTER
         USING IHIIORCN,R7
         ICM   R9,B'1111',ANOTTAB(R12)
         BZ    RETCLEAR                NOTE TABLE PRESENT ?, NO BRANCH
         LR    R4,R9                   R4 -> NOTE TABLE
CLNOTB1  LA    R4,8(,R4)               R4 -> ENTRY IN NOTE TAB
         C     R4,0(,R9)               FIRST ENTRY = CURRENT ENTRY ?
         BE    RETCLEAR                YES, NOTTAB CLEARED, NO ENTRIES
         LR    R2,R6                   DATASET NUMBER TO R2
         CH    R6,0(,R4)               THIS ENTRY FOR THIS DATASET ?
         BNE   CLNOTB1                 NO, LOOP TO NEXT ENTRY
         CLC   S,2(R4)                 YES, COMPARE RECORD POINTERS
         BH    CLNOTB1                 S > NOTE TAB ENTRY, BRANCH
         MVI   0(R4),X'80'             S ^> NOTE TAB ENTRY, MARK
*                                      NOTE TAB ENTRY AS INVALID
         B     CLNOTB1                 CONTINUE TO LOOP THROUGH ENTRIES
*
RETCLEAR RETURN (14,12)
*
*----------------------------------------------------------------------
*
*        MAKE NOTTAB ENTRY
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        AN ENTRY FOR RECORD JUST HANDLED IS MADE IN NOTTAB
*
*        NOTES - ON ENTRY R1 = NOTEADR FROM DSTABLE
*
*
IHIIOREN SAVE  (14,12),,'IHIIOREN LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIOREN,R7
         ICM   R9,B'1111',ANOTTAB(R12)  R9 -> NOTE TAB
         BZ    ENNOTB4                 NO NOTE TAB INITIALIZED, EXIT
         LR    R4,R9                   R4 -> NOTE TAB
ENNOTB1  LA    R4,8(,R4)               R4 -> NOTE TAB ENTRY
         C     R4,0(,R9)               FIRST ENTRY = CURRENT ENTRY ?
         BNE   ENNOTB3                 NO, BRANCH
         L     R2,0(,R9)               YES, R2 -> NEXT ENTRY LOCATION
         LA    R2,8(,R2)               INCR NXE BY EIGHT
         ST    R2,0(,R9)               SAVE NEW NEXT ENTRY LOCATION
         C     R2,4(,R9)               NEW NEXT LOCATION = END OF TAB?
         BE    ENNERR4                 YES, NOTE TAB OVERFLOW, ERROR
ENNOTB2  STH   R6,0(,R4)               STORE NEW ENTRY DSN
         MVC   2(2,R4),S               STORE RECORD POINTER TO NOTTAB
         ST    R1,4(,R4)               STORE NOTEADR
ENNOTB4  RETURN (14,12)                RETURN TO CALLER
*
ENNOTB3  TM    0(R4),X'80'             NOTTAB ENTRY INVALID ?
         BO    ENNOTB2                 YES, USE IT
         B     ENNOTB1
*
ENNERR4  LR    R13,R12                 OVERFLOW OF RECORD IDENT AREA
         B     FSAERR+4*4(,R12)
*
*----------------------------------------------------------------------
*
*        EVALUATE DATASET NUMBER
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION -
*        ADDR OF DSTABLE IN GENERATED OBJECT MODULE IS OBTAINED
*        FROM FSA
*        L R4,ADSTAB(,R12)
*        ACTUAL DATASET NUMBER LOADED IN BINARY FORM TO R6,
*        ADDR OF ACTUAL ENTRY IN DSTABLE TO R5, THESE REGISTERS
*        ARE KEPT THROUGH ALL I/O MODULES IN ORDER TO ADDR
*        POINTERS AND FLAGS IN DSTAB
*
*        ENTRY POINT -
*        DATA IS PASSED VIA NAME
*        LA   R1,PARMLIST
*        BALR R14,R15
*
IHIIOREV SAVE  (14,12),,'IHIIOREV LEVEL 2.1 &SYSDATE &SYSTIME'
*
         LR    R7,R15
         USING IHIIOREV,R7
         ST    R13,SAVAR+4
         LA    R13,SAVAR
*
*        PARAMETER LIST ADDR IN R1
*
         ICM   R5,B'1111',0(R1)
         BP    DSNINT
         TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         BO    EVD1                    SHORT
         LD    FPR0,0(,R5)             LONG
         B     EVD1+4
*
EVD1     LE    FPR0,0(,R5)             SHORT
         L     R15,VIORCI              R15 -> IHIIORCI
         BALR  R14,R15                 CALL IHIIORCI
         B     DSNINTA
*
DSNINT   L     R0,0(,R5)
DSNINTA  LR    R5,R0                   DATASET NUMBER IN R5
         N     R0,RANGEDSN             DATASET NUMBER OUT OF RANGE
         BM    EVDERR0
         LR    R6,R5
         LA    R0,DSTABLEL             L'DSTABLE ENTRY
         MR    R4,R0
         L     R4,ADSTAB(,R12)
         LA    R5,4(R5,R4)             ENTRY TO DSTABLE IN R5
         L     R13,SAVAR+4
         LM    R14,R4,12(R13)          RETURN R5 AND R6 TO CALLER
         LM    R7,R12,48(R13)
         BR    R14                     RETURN
*
EVDERR0  LR    R13,R12                 DATASET NUMBER OUT OF RANGE
         B     FSAERR(,R12)
*
RANGEDSN DC    F'-16'                  SCOPE OUTSIDE RANGE OF DSN
*
VIORCI   DC    V(IHIIORCI)             ADDR OF CONVERSION ROUTINE
*
*----------------------------------------------------------------------
*
*        DCB END OF DATA EXIT
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION - INVOKED VIA CHECK MACRO
*
*        EXITS - NORMAL - CHECK FROM SYSACT4 OR CLOSE RELOAD
*                         REGISTERS AND RETURN TO CALLING PROGRAM
*                         VIA BR14
*              - CHECK FROM NEXTREC - BLOCKED FORMAT SET FLAG DS7 IN
*                         DSTABLE AND BRANCH TO END OF NEXTREC
*              - UNBLOCKED FORMAT OUTPUT - RETURN TO NEXTREC TO WRITE
*                         BACK CURRENT RECORD
*              - UNBLOCKED FORMAT INPUT - SET FLAG DS7 IN DSTABLE AND
*                         RETURN TO NEXTREC TO UPDATE PTR IN DSTABLE
*              - ERROR -  CHECK FROM OPEN
*                         INPUT REQUEST BEYOND END OF DATASET
*
*
IHIIORED SAVE  (14,12)
         BALR  R7,0
         USING *,R7
         ST    R13,SAVEOD+4
         LA    R13,SAVEOD
         OI    DSF,DS7                 SET EOD FLAG
         TM    DSF+1,DSOREAD           READ ISSUED FROM OPEN ?
         BNO   END00                   NO, BRANCH
*                                      YES, NO DATA IN DATASET
         NI    DSF,255-(DS2+DS3+DS6)   SET FLAGS FOR A CORRECT CLOSE
         LR    R13,R12
         B     FSAERR+5*4(,R13)        INPUT REQUEST BEYOND EOD
*
END00    CLOSE ((R8),LEAVE),TYPE=T
*
         TM    DSF+1,DS8               CHECK FROM CLOSE OR SYSACT4 ?
         BZ    END02                   NO, BRANCH
END11    L     R13,SAVEOD+4            YES, RETURN TO ISSUING SYSACT4
         RETURN (14,12)                OR CLOSE ROUTINE
*
END02    TM    DSF,DS2                 LAST I/O OUTPUT ?
         BZ    END03                   NO, BRANCH
         B     END11                   YES
*
END03    MVI   DECBIO+8,255            MARK DECB AS COMPLETED
         L     R13,SAVEOD+4            RETURN TO CALLING NEXTREC
         RETURN (14,12)
*
*        INTERNAL ADDRESSES
*
SAVEOD   DC    18F'0'
*
*----------------------------------------------------------------------
*
*        CONVERSION TO INTEGER
*
*----------------------------------------------------------------------
*
*        FUNCTION/OPERATION - CONVERT REAL LONG OR SHORT TO INTEGER
*
*        NOTES - CALLED BY BALR 14,15
*        DATA PASSED BY VALUE IN FPR0
*        RESULT IN R0
*
IHIIORCI TM    OPTSW(R12),X'20'        LONG OR SHORT PRECISION ?
         USING IHIIORCI,R15
         BZ    LONG
         STE   FPR0,BUFF3
         LD    FPR0,BUFF3
*
LONG     AD    FPR0,CONST2
         STD   FPR0,BUFF4
         CE    FPR0,CONST3
         BNL   ERROR1
         AW    FPR0,CONST1
         BP    LABEL
         CLC   BUFF4(8),CONST4
         BH    ERROR1
LABEL    STD   FPR0,BUFF2
         L     R0,BUFF2+4
         X     R0,CONST1+4
         SD    FPR0,CONST1
         CD    FPR0,BUFF4
         BNHR  R14
         BCTR  R0,R14
ERROR1   LR    R13,R12
         B     FSAERR+1*4(,R12)
*
*        INTERNAL CONSTANTS AND STORAGE
*
         DC    0D'0'
CONST1   DC    X'4E00000080000000'
CONST2   DC    X'4080000000000000'
BUFF2    DC    D'0'
BUFF3    DC    D'0'
CONST4   DC    X'C880000000000000'
BUFF4    DC    D'0'
CONST3   DC    X'48800000'
*
*        DCB SYNAD EXIT
*
*        EXIT - NORMAL - BRANCH ERROR UNRECOVERABLE I/O ERROR
*
IHIIORER LR    R7,R15
         USING IHIIORER,R7
         OI    DSF+1,DSIOERR           SET MARK FOR CORRECT CLOSE
         LR    R13,R12
         B     FSAERR+32*4(,R12)       I/O ERROR
*
*        MODEL DCB
*
DCBMODEL DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=ALGLDD,NCP=2,             X
               EODAD=IHIIORED,                                         X
               EXLST=ADCBEXIT,                                         X
               SYNAD=IHIIORER
*
DCBMODLN EQU   *-DCBMODEL              LENGTH OF DCBMODEL FOR MVC
*
*        OPEN EXIT PARAMETER LIST
*
         DC    0F'0'
ADCBEXIT DC    X'05'                   DCB OPEN EXIT REQUESTED
         DC    AL3(IHIIORDX)           OPEN EXIT ROUTINE ADDR
         DC    X'87',AL3(0)            JFCB ADDR UPDATED WHEN GETMAINED
*
DWORD    DC    D'0'                    WORK AREA FOR DSN
SAVAR    DC    18F'0'
EXERFLAG DC    X'00'                   ERROR FLAGS SET BY OPEN EXIT
*
*        INTERNAL ADDRS
*
VIORCN   DC    A(IHIIORCN)
VIOREN   DC    A(IHIIOREN)
VIORNX   DC    A(IHIIORNX)
*
         LTORG
*
*        SEE GC28-6615 ALGOL LANGUAGE PAGE 82 FOR A DETAILED
*        DESCRIPTION OF THE DSTABLE FIELDS MAINTAINED FOR EACH
*        DATASET
*
         DSTABLE  DSECT=YES
*
*        SYMBOLIC NAMES FOR DCB
*
         PRINT NOGEN
*
         DCBD  DSORG=BS,DEVD=DA
*
         PRINT GEN
*
*        DECB
*
         READ  DECBIO,SF,MF=L
*
JFCB     DS    22D
         ORG   JFCB
*
         IEFJFCBN ,                    MAP THE JFCB
*
JFCBLEN  EQU   *-JFCB
*
*        CALCULATE TOTAL GETMAINED AREA FOR DCBAREA WITH DECB AND JFCB
*
DCBAREAL EQU   *-IHADCB
*
         PRINT NOGEN
*
*        IHADECB
*
         IHADECB
*
*        IEZIOB
*
         IEZIOB
*
         PRINT GEN
*
*        REGISTER EQUATES
*
         IEZREGS
*
FPR0     EQU   0
*
         END
