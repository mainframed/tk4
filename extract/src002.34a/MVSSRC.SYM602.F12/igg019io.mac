         TITLE 'IGG019IO - APPEND-PART 1, VLR, WC AND NO WC'        
IGG019IO CSECT                                                      
*        RELEASE OS/VS2-02 DELETIONS
*C341400                                                        YM03024
*                                                               YM05920
* A164932-164938                                                ZA00748
*              RELEASE 3 CHANGES
* C164932-164938                                                XM00622
*        RELEASE 21 DELETIONS
*1233064800,067800                                               S21045
*1233                                                            A33533
*1233125700-126100,652400                                        A44835
*1233428400,429000                                               A48173
*1233114600,170400,303000,304200-305400,367800,421200,430200,    A48560
*1233431400,432600,435100,441600,462000,474200                   A48560
*XXXX                                                            A49403
*123352331                                                       A52331
*1233064200                                                      A50670
*              CHANGES SINCE VSW-3.7                                  *
*A070400-070600,A652460-652520                                 @ZA26522
*
*STATUS CHANGE LEVEL 004
*
* FUNCTION/OPERATION- APPENDAGE ROUTINES FOR BISAM
*        WHEN WRITE KN IS USED WITH OR WITHOUT READ AND UPDATE
*        (PART 1)
*
*        CEND  - IF CHANNEL PROGRAM ENDS
*                **WITHOUT ERROR, EITHER
*                    PROCESSING COMPLETION WILL BE SCHEDULED,
*                    PROCESSING CONTINUATION WILL BE SCHEDULED,
*                    OR PROCESSING WILL CONTINUE.
*                **WITH A LENGTH CHECK, TESTS DETERMINE WHETHER
*                    OR NOT TO TREAT THE SITUATION AS A REAL
*                    ERROR.
*                **ANY OTHER ERROR, IN GENERAL, 'UNREACHABLE
*                    BLOCK' IS INDICATED IN THE DECB, AND
*                    PROCESSING COMPLETION WILL BE SCHEDULED.
*
*        ABEND - IF CHANNEL PROGRAM ENDS ABNORMALLY BECAUSE OF
*                **PERMANENT ERROR, 'UNCORRECTABLE I/O ERROR'
*                    IS INDICATED IN THE DECB, AND PROCESSING
*                    COMPLETION WILL BE SCHEDULED.
*                    USE OF WRITE VALIDITY CHECKING OPTION
*                    ALLOWS A LIMITED NUMBER OF RE-EXECUTIONS
*                    BEFORE INDICATING AN ERROR.
*                **NON-PERMANENT ERROR, ONE RE-TRY IS MADE
*                    BEFORE INDICATING A PERMANENT ERROR.
*                **FILE PROTECTION, TESTS DETERMINE WHETHER
*                    OR NOT TO TREAT THE SITUATION AS A REAL
*                    ERROR.
*                **ANY OTHER ERROR, IN GENERAL, 'UNREACHABLE
*                    BLOCK' IS INDICATED IN THE DECB, AND
*                    PROCESSING COMPLETION WILL BE SCHEDULED.
* ENTRY POINTS-
*        ENTRY POINT               FUNCTION
*        -----------               --------
*        APPCEND                   CEND
*        APPABEND                  ABEND
* INPUT - N/A
* OUTPUT - N/A
* EXTERNAL ROUTINES - N/A
*
* EXITS- 1. RETURN TO IOS VIA THE APPENDAGE RETURN VECTOR TABLE POINTED
*            TO BY REGISTER 14.  SEE THE DSECT LABELED    APPRV FOR THE
*            FORMAT OF THIS TABLE AND THE USE OF EACH EXIT.
*           USED TO CONTINUE PROCESSING.
*        2. SCHEDULE AN ASYNCHRONOUS ROUTINE - BRANCH VIA THE EXIT
*            EFFECTOR ADDRESS IN THE COMMUNICATION VECTOR TABLE.
*           USED TO SCHEDULE PROCESSING COMPLETION OR CONTINUATION.
*        3. IF THE DESIRED APPENDAGE ROUTINE IS IN PART 2, BRANCH TO
*            THAT ROUTINE VIA THE PART 2 VECTOR TABLE.  THE POINTER TO
*            THE MODULE IS IN DCBWKPT5.  SEE THE DSECT LABELED
*            IHAPART2 FOR RELATIVE ADDRESSES AND USES OF THE ROUTINES.
*
* TABLES/WORK AREAS - DECB, DCB, IOB AND EXTENTION, DCB WA (DCW), DEB,
*        CVT, PART 2 VECTOR TABLE.
*        SEE DSECTS AT END OF MODULE FOR FORMAT AND DESCRIPTIONS.
*
* ATTRIBUTES- REENTRANT. DISABLED.
* NOTES - NONE
         EJECT
* GENERAL REGISTERS ARE USED AS FOLLOWS
*
R0       EQU   0                   *    -----
R1       EQU   1                   *    12* ADDRESS
R2       EQU   2                   *    IOB
R3       EQU   3                   *    DEB
R4       EQU   4                   *    DCB
BASEXXXX EQU   5                        BASE FOR CLEANUP RTN     Y02072
R6       EQU   6                   *    -----
R7       EQU   7                   *    UCB
SAVEXXXX EQU   8                        SAVE AREA FOR CLEANUP    Y02072
R9       EQU   9                   #    WORK REGISTER
R10      EQU   10                       CHANNEL PROGRAM POINTER
R11      EQU   11                       DECB
R12      EQU   12                       WORK REGISTER
R13      EQU   13                       WORK REGISTER
R14      EQU   14                       IOS RETURN VECTOR TABLE
R15      EQU   15                       BASE REGISTER
*
*        * MEANS THIS REGISTER IS SET UP UPON ENTRY FROM IOS,
*          AND ITS CONTENTS MUST BE RESTORED UPON RETURN TO IOS
*        # MEANS THIS REGISTER MAY BE CHANGED, BUT UPON RETURN TO IOS
*          MUST CONTAIN ZEROES IN THE THREE HIGH ORDER BYTES
*
PERRMASK EQU   X'20'          TO TEST FOR PERMANENT ERROR, TEST
PERRYES  EQU   8               IOBECBAD, B2. IF OFF (CONDITION CODE 8)
PERRNO   EQU   7               THERE IS A PERM ERR. ELSE B2 ON ( CD 7)
EIGHT    EQU   PERRYES                  8
ONE      EQU   1                        1
SEVEN    EQU   PERRNO                   7
FOUR     EQU   4                        4
FIVE     EQU   5                        5
L16      EQU   16                       16
CCOFF    EQU   X'BF'                    MASK FOR CC OFF
ABENTRY  EQU   X'01'                    ABEND ENTRY INDICATOR    A50670
DATACHK  EQU   X'08'                    DATA CHECK IOB SENSE     A50670
NORMAL   EQU   0                        RETURN TO IOS/NORMAL     A50670
*
SKIPX    EQU   4                        SKIP RETURN TO IOS       Y02072
REEXCP   EQU   8                        REEXCP RETURN TO IOS     Y02072
BYPASS   EQU   12                       BYPASS RETURN TO IOS     Y02072
FMVIOL   EQU   X'04'                    FILE MASK VIOLATION      Y02072
NOTSEEK  EQU   8                        CC - SEEK TEST SENSE B0  Y02072
SEEKCHK  EQU   X'01'                    SEEK CHECK INDICATOR     Y02072
         EJECT
         USING RQE,R1                   RQE ADDRESSABILITY       Y02072
         USING IHAIOB,R2                IOB POINTER
         USING IHADEB,R3                DEB POINTER
         USING IHADCB,R4                DCB POINTER
         USING IHAWKNCP,R10             CHANNEL PROGRAM POINTER
         USING IHADECB,R11              DECB POINTER
         USING IHADCW,R12               DCB WA POINTER ONLY AS WORK REG
         USING APPRV,R14                IOS RETURN VECTOR TABLE POINTER
         SPACE 3
*                             APPENDAGE VECTOR TABLE
APP      DC    A(APPCEND-APP)          CHANNEL END-   USED BY WKN
         DC    A(APPABEND-APP)          ABNORMAL END  -     USED BY WKN
APPNO    EQU   *
         USING APPCEND,R15
APPCEND  NI    IOBINDCT,X'FE'          INDICATE CEND ENTRY
         B     SETUPREG                 BRANCH TO SET UP REGISTERS
APPABEND EQU   *                                                 A50670
         USING APPABEND,R15
*                                                                A50670
*        IF THIS IS A CORRECTABLE DATA CHECK FROM AN RPS         A50670
*        DEVICE THEN RETURN TO IOS FOR ERP HANDLING              A50670
*                                                                A50670
         TM    IOBECBAD,PERRMASK        PERMANENT ERROR          A50670
         BZ    NOCDACK                  YES CONTINUE AS USUAL    A50670
         TM    IOBSENS1,FMVIOL          WAS IT A SEEK CHECK      Y02072
         BCR   NOTSEEK,R14              NO - RETURN TO ERPS      Y02072
NOCDACK  EQU   *                                                 A50670
         OI    IOBINDCT,ABENTRY         INDICATE ABEND ENTRY     A50670
SETUPREG L     R15,DEBEXPTR              GET ADDR OF DEB         S21045
*                                       EXTENSION PTR            S21045
         USING DEBEXT,R15                                        S21045
         L     R15,DEBWKPT4              R15  BASE               S21045
         DROP  R15
         USING APP,R15
         SPACE 3
*   SAVE IOS REGISTERS AND SET UP ADDRESSABILITY TO RETURN TO SPECIAL
*   CLEANUP ROUTINE.
         SPACE 2
         STM   R14,R12,0(R13)           SAVE REGISTERS           Y02072
         LR    SAVEXXXX,R13             SAVE SAVE AREA PTR       Y02072
         LA    R14,IOSRETS              RETURN TO RETURN TO IOS  Y02072
         LR    BASEXXXX,R14             BASE REG FOR RETURN      Y02072
         SPACE 2
         MODESET KEYADDR=RQEPRT,WORKREG=13 ACQUIRE USER KEY      Y02072
         SPACE 3
         L     R10,IOBCCWAD             R10  CP
         LA    R10,0(R10)               CLEAR HIGH ORDER BYTE    A49403
         MVC   IOBECBAD+1(3),IOBBCHAD+1 RESTORE ECB              A33533
         L     R11,IOBECBAD             R11  DECB
         L     R13,DEBEXPTR              GET ADDR OF DEB         S21045
*                                       EXTENSION PTR            S21045
         USING DEBEXT,R13                                        S21045
         L     R13,DEBWKPT5              R13  BASE, PART 2       S21045
         DROP  R13                                               S21045
         USING IHAPART2,R13
         L     R12,IOBCSW               R12  ADDRESS OF LAST CCW + 8
         LA    R12,0(0,R12)
         IC    R9,IOBAPP                R9   RELATIVE ADDRESS IN
         CH    R9,TWOFOUR               IS APP CODE GT 24?     @ZA26522
         BH    INVAPPCD                 IF YES-GO PROG CHK     @ZA26522
         SLL   R9,2                            APPENDAGE TABLE
         TM    IOBINDCT,X'01'
         BO    APPABENT(R9)            IF ABEND, BRANCH VIA ABEND TABLE
         B     APPCENDT(R9)            IF CEND, BRANCH VIA THAT TABLE
         EJECT
***********************************************************************
*****              CHANNEL END APPENDAGE VECTOR TABLE             *****
***********************************************************************
APPCENDT EQU   *              CODE      FOR COMPLETION OF
         B     APPABA2   0             CP4/CP5, READ
         B     APPABA2   1             CP4/CP5, WRITE
         B     APPADB2   2             CP7W
         B     APPAAB2   3             CP1 OR CP2, READ AND UPDATE
         B     APPRVNOR  4             NOT USED
         B     APPACA2   5             CP6
         B     APPAHB2   6             CP4/CP5 WRITE CHECK
         B     APPM67CE  7             CP1 OR CP2, WRITE KN
         B     APPN3B21
         B     APPN7B2   9              CP14EOF EXT
         B     APPN8B2                  NORMAL END 2ND PART CP14
         B     APPRVNOR  11            NOT USED
         B     APPM4A2   12            CP14W - SETUPS 1, 2, OR 5
         B     APPM5A2   13            CP14W - SETUPS 3, 4, OR 6
APPCEN14 B     APPN3B21
         B     APPM2B2   15            CP16 - SITUATION 2
         B     APPM3B2   16            CP16 - SITUATION 3
         B     APPM17    17            CP 14W  PRIME ENTRU ONLY
         B     APPRVNOR  18            NOT USED
         B     APPN9A2   19            CP17W - HIGHER LEVELS ONLY
         B     APPM20    20            CP 12AV
         B     APPM21    21            CP12BV
         B     APPM22    22            CP123WV
         B     APPRVNOR  23            NOT USED
         B     APPRVNOR  24            NOT USED
         EJECT
***********************************************************************
*****             ABNORMAL END APPENDAGE VECTOR TABLE             *****
***********************************************************************
APPABENT EQU   *              CODE      FOR COMPLETION OF
         B     APPABD2   0             CP4/CP5, READ
         B     APPABD2   1             CP4/CP5, WRITE
         B     APPAIB2   2             CP7
         B     APPAAA2   3             CP1 OR CP2, READ AND UPDATE
         B     APPRVNOR  4             NOT USED
         B     APPACE2   5             CP6
         B     APPAHD2   6             CP4/CP5 WRITE CHECK
         B     APPM67AE  7             CP1 OR CP2, WRITE KN
         B     APPN3E2     8            CP8
         B     APPJ3B2   9              CP14EOF EXT
         B     APPN3C2                  ABNORMAL END 2ND PART CP
         B     APPRVNOR  11            NOT USED
         B     APPJ5B2   12            CP14W - SETUPS 1, 2, OR 5
         B     APPJ6B2   13            CP14W - SETUPS 3, 4, OR 6
         B     APPM1J2   14            CP15
         B     APPM2H2   15            CP16 - SITUATION 2
         B     APPM2H2   16            CP16 - SITUATION 3
         B     APPAB17   17            CP14W  PRIME ENTRY ONLY
         B     APPRVNOR  18            NOT USED
         B     APPJ7B2   19            CP17W - HIGHER LEVELS ONLY
         B     APPU4B2   20            CP13A
         B     APPU4G2   21            CP13B
         B     APPJAE2   22            CP123W
         B     APPRVNOR  23            NOT USED
         B     APPRVNOR  24            NOT USED
         DROP  R13
         USING CVT,R13                  COMMUNICATION VECTOR TABLE
         EJECT
*   SPECIAL IOS RETURN CLEANUP ROUTINE INTERCEPTS ALL RETURNS TO
*   IOS AND RESTORES REGISTERS AND SETS PROTECTION KEY TO 0.
         SPACE 2                                                 Y02072
IOSRETS  EQU   *                        RETURN POINT             Y02072
         USING *,BASEXXXX               ADDRESSABILITY           Y02072
         B     NORMRET                  NORMAL RETURN            Y02072
         B     SKIPRET                  SKIP POST RETURN         Y02072
         B     REEXCPRT                 REEXCP RETURN            Y02072
         SPACE 2
BYPASRET EQU   *                        BYPASS POST RETURN       Y02072
         BAL   R12,IOSRETX              RESTORE REGS AND KEY     Y02072
         LA    R14,APPRVBYP             SCHEDULE ASYNCH ROUTINE  Y02072
         L     R13,CVTPTR               CVT ADDRESSABILITY       Y02072
         L     R13,CVTEXEF              ASYNCH SCHED ROUTINE     Y02072
         BR    R13                      GO TO ROUTINE            Y02072
         SPACE 2
REEXCPRT EQU   *                        REEXCP RETURN            Y02072
         BAL   R12,IOSRETX              RESTORE REGS AND KEY     Y02072
         B     REEXCP(R14)              RETURN - REEXCP          Y02072
         SPACE 2
SKIPRET  EQU   *                        RETURN - SKIP            Y02072
         BAL   R12,IOSRETX              RESTORE REGS AND KEY     Y02072
         B     SKIPX(R14)               RETURN - SKIP            Y02072
         SPACE 2
NORMRET  EQU   *                        RETURN - NORMAL          Y02072
         BAL   R12,IOSRETX              RESTORE REGS AND KEY     Y02072
         BR    R14                      RETURN                   Y02072
         SPACE 2
IOSRETX  EQU   *                        RESTORE REGS AND KEY     Y02072
         SPACE 1
         MODESET KEYADDR=KEY0,WORKREG=13   SET KEY = 0           Y02072
         SPACE 2
         LM    R14,R11,0(SAVEXXXX)      RESTORE REGISTERS        Y02072
         BR    R12                      RETURN                   Y02072
         DROP  BASEXXXX                 RESET ADDRESSABILITY     Y02072
         EJECT                                                   Y02072
*              CHANNEL  END CP8,    APPENDAGE CODE  8,         CHART N3
APPN3B2  EQU   *                        *
*
         LA    R13,CB8A+EIGHT           DID CHANNEL PROGRAM END ON
         CLR   R12,R13                  CB8A
         BNE   APPAOS22                 NO, CONTINUE
         TM    CB8A+FIVE,CC             WAS CB8A CHAINED
         BZ    APPAOS22                 NO, CP UNCHANGED
         NI    CB8A+FIVE,CCOFF          RESET CHAIN IND.
         OI    CB8A+FOUR,CC             TURN CC BACK ON
         CLI   CB12,SEEKHH              CB12 SET FOR HEAD SEEK
         BNE   APPN3F3                  NO,  FILE PROTECT
         LA    R13,CB16                 RESET IOBSTART
         ST    R13,IOBSTART-ONE         START CP WITH SETSECT
         MVC   IOBDADAD,CB10+SEVEN      RESET IOBSEEK
         B     APPRVXCP                 SECHDULE EXCP IOS RETURN
APPAOS22 EQU   *                        *
*                                       ERROR                    A48560
*
         LA    R13,CB21+EIGHT           DID CHAN PROG STOP AT CB21
         CLR   R12,R13                  BE MEANS YES, BNE MEANS NO
         BNE   APPN3A3                  NO - CHECK FOR LENGTH    A48560
*
*              THE FOLLOWING SECTION THRU HALF4 IS VARIABLE ONLY CODE
*
*        IN THE FOLLOWING CODE FOR VLR, THE CCW:
*    CH8E+6 IN CP14 IS USED TO ACCUMULATE THE NO. OF RECORDS THAT
*    OVERFLOW FROM THE TRACK BEING REWRITTEN;
*    CH6+4 IN CP14 IS USED TO ACCUMULATE THE NO. OF RECORDS BEING
*    REWRITTEN FOR THAT TRACK;
*    EACH COPY OF CE4+4 IN CP12BV IS USED TO ACCUMULATE THE NO.
*    OF RECORDS FOR THAT BLOCK AND EACH PREVIOUS BLOCK THAT IS
*    BEING REWRITTEN.
*
*   CP8 NORMAL STOP ON CB21 - SET UP CP12AV  AND PORTIONS OF CP12BV
*   AND CP123WV IF WRITE CHECKING
*
         SR    R9,R9
         IC    R9,CB23+7
         BCTR  R9,R0
         STC   R9,CB23+7               STORE SEARCH R
         L     R12,DCBWKPT2            R12=A(DCW AREA)
         NI    DCWWKNI,X'EF'           TURN ADD TO END SWITCH OFF
         MVC   IOBDADAD+4(4),CB23+4    INITIALIZE IOB
APPENTRY MVI   IOBAPP,X'14'            APPENDAGE CODE=20
         OI    IOBFLAG1,X'40'          USE COMMAND CHAIN
         NI    IOBFLAG1,X'7F'          DON'T USE DATA CHAIN
         MVC   CD0(4),IOBDADAD+3        SET UP S.A. FOR R0       A44835
         LA    R13,8                                             A44835
         ST    R13,CD0+4                CCHH0008                 A44835
         LA    R13,CD0A1                START AT CD0A            A44835
         STH   R13,IOBSTART+1
         SRL   R13,16
         STC   R13,IOBSTART
         CLI   IOBDADAD+7,X'00'        TEST IF READING FULL TRACK
         BE    APPNV002                B=YES
         LA    R12,CD1                  FULL TRACK               S20201
*                                       CD0C TICS TO CD1
         LA    R13,CEA-CP123           CP123W-CEA2 TICS TO CEA   S20201
         B     APPNV003
*
*  READING FULL TRACK WITH CP12AV
*
APPNV002 EQU   *                                                 S20201
         LA    R12,CD3                  NOT FULL TRACK           S20201
*                                       CD0C TICS TO CD3
         LA    R13,CED-CP123           CP123W-CEA2 TICS TO CED   S20201
*
*  EITHER FULL TRACK OR LESS
*
APPNV003 ST    R12,CD0C                 SET UP TIC ADDR          S20201
         MVI   CD0C,TIC                 RESTORE COMMAND CODE     S20201
         LA    R12,IOBDADAD+3          PLACE ADDRESS OF          S20201
*                                       IOBDADAD+3 IN            S20201
         STH   R12,CD1+2               CD1
         SRL   R12,16
         STC   R12,CD1+1
         LA    R12,CD2B                 PERFORM READ KEY TO SKIP S20201
*                                       R0                       S20201
         ST    R12,CD2A
         MVI   CD2A,TIC                                          S20201
         L     R12,CD2+4               R12=A(CP12BV)
         USING CP12B,R12                                         S20201
         MVC   CE1+1(3),CD1+1           MOVE A(IODDADAD+3) TO    S20201
*                                       CP12B                    S20201
         LA    R9,CE4                                            S20201
         ST    R9,CB18                 SET A(CE4) IN 12B POINTER
         L     R12,CB2+4              *R12=A(CP123WV)
         USING CP123,R12                                         S20201
         MVC   CEA+1(3),CD1+1                                    S20201
         AR    R13,R12                *R13= TIC ADDRESS FOR CEA2
         STH   R13,CEA2+2                                        S20201
         SRL   R13,16                 *
         STC   R13,CEA2+1                                        S20201
         USING IHADCW,R12                                        S20201
         SR    R12,R12                 CLEAR R12
         IC    R12,DCBHIRPD            CALCULATE ADDR OF  1ST CE4
         SLL    R12,3                   WHICH IS EQUAL TO
         SR    R9,R9                   8HIRPD+KEYLE
         IC    R9,DCBKEYLE             +MSWA
         AR    R12,R9
         A     R12,DCBMSWA             WORK AREA ADDR
         L     R9,CB18                  1ST CE4
         ST    R12,16(R9)
         LA    R12,4(R12)              INITIALIZE RECEIVE ADDRESS FOR
         ST    R12,CB17+4              OUTPUT BLOCK-'CURRREC'
         SR    R12,R12
         IC    R13,IOBDADAD+7          R13= R OF SEARCH BLOCK
         IC    R12,CB11+6              R12= R OF HI REC ON TRACK
         SR    R12,R13                 R12= NUM BLOCKS TO BE READ
         LA    R13,1(R13)              R13= R OF INSERT BLOCK
         L     R9,DCBMSWA              R9= A(MSWA)
         AH    R9,CD2B+6               ADD KEYLENGTH TO R9
         MVC   0(4,R9),IOBDADAD+3      MOVE CCHH FOR 1ST COUNT
         STC   R13,4(R9)               STORE R FOR 1ST COUNT
         MVC   5(1,R9),CD2B+7          MOVE KL FOR 1ST COUNT
         CH    R12,CD0C+6              COMP NUM TO BE READ VS NUM READ
*                                      CCW'S IN CP12AV
         BNH   APPNV004                B= ONLY ONE PASS OF CP12AV
         OI    CD0A+3,X'80'            SET 1ST TIME SWITCH ON
         LH    R12,CD0C+6              R12= NUM READ CCWS  IN CP12AV
         MVC   CK9+2(2),CD0C+6         AUXCURR=NO BLKS READ THIS TIME=N
APPNV004 LA    R13,CD3                 R13= A(1ST READ CCW)
         MVC   CD3+1(3),CD0A+5         PLACE ADDR'X' IN CD3
         L     R9,CD3
APPNV006 BCT   R12,APPNV005
         NI    4(R13),X'BF'            CC OFF IN LAST READ CCW
         MVC   SIX(2,R13),DCBBLKSI      RESET LENGTH             XM5271
         AH    R9,DCBBLKSI              ADD BLKSIZE TO DATA ADDR XM5271
         LA    R9,0(R9)                 CLEAR HIGH ORDER BYTE   YM05920
         L     R12,DCBMSWA              ADDR WKN WORK AREA      YM05920
         LA    R12,0(R12)               CLEAR HIGH ORDER BYTE   YM05920
         LH    R3,DCBSMSW               LOAD WORK AREA SIZE     ZM00622
         SLL   R3,L16                   CLEAR HI TWO BYTES      ZM00622
         SRL   R3,L16                   RESTORE BYTE POSITIONS  ZM00622
         AR    R12,R3                   PT END OF WKN WORK AREA ZM00622
         CR    R9,R12                   RCD EXTEND PAST WA      YM05920
         BL    APPNV007                 BRANCH IF NO             XM5271
         SH    R9,DCBBLKSI              POINT TO LAST DATA RCD   XM5271
         SR    R12,R9                   NO. BYTES FOR LAST READ  XM5271
         DROP  R13
         USING CCWCD3,R13               LAST CD3 CCW ADDRESS     XM5271
         STH   R12,CCWDL                DATA LENGTH FOR READ     XM5271
         DROP  R13                      END CCW CD3 ADDR         XM5271
         B     APPNV007
APPNV005 OI    4(R13),X'40'            CC ON IN NON LAST READ CCW
         MVC   SIX(2,R13),DCBBLKSI      RESET LENGTH             XM5271
         LA    R13,8(R13)              NEXT CCW
         AH    R9,DCBBLKSI             ADD BLKSIZE TO INPUT DATA ADDR
         ST    R9,0(R13)
         B     APPNV006
APPNV007 MVI   IOBCOUNT,X'0A'          ERROR COUNT=10
         L     R12,CB18                LOAD A(CE4) TO R12
         MVC   22(2,R12),HALF4
         MVC   CH6+FOUR(HW),HALF0       SET REC COUNT TO 0       A48560
         XC    CD0A2+4(4),CD0A2+4       CLEAR REC KNT & OFLOW KNT 
         NI    CD0A+3,X'BF'            SATISFY SWITCH OFF
         SR    R9,R9
         B     APPRVXCP
HALF4    DC    X'0004'
APPN3B3  OI    DECBEXC1,X'04'           RECORD IS UNREACHABLE
APPN3B4  MVI   IOBASYN,X'08'            SCHEDULE PROCESSING COMPLETION
APPN3B5  B     APPRVBYP                 SCHEDULE ASYNCH ROUTINE  Y02072
         EJECT
*              ABNORMAL END CP8,    APPENDAGE CODE  8,         CHART N3
APPN3E2  TM    IOBSENSE+1,X'04'         WAS ABEND DUE TO FILE PROTECT
         BO    APPN3F2                  YES
         TM    IOBECBAD,PERRMASK        WAS ABEND DUE TO PERM ERROR
         BC    PERRYES,APPN3B3          YES  B3, NO NORM IOS RETURN
         B     APPRVNOR                 NO   RETURN TO IOS
APPN3F2  LA    R13,CB12+8               DID CHAN PROG STOP AT CB12
         CLR   R12,R13                  BE MEANS YES, BNE MEANS NO
         BNE   APPN3B3                  NO - RECORD IS UNREACHABLE
*
APPN3F3  EQU   *                        *
*
         MVI   IOBFLAG1,X'02'           RESTORE IOB FLAGS AND ERR CTR
         MVI   IOBFLAG2,X'00'            UNRELATED FLAG ON
         MVI   IOBCSW,X'00'              OTHERS OFF
         XC    IOBERRCT,IOBERRCT
         TM    CB11+7,X'10'             WAS OFLO TRACK INDEX ENTRY READ
         BZ    APPN3G3                  BZ IF NO
         TM    CB11+7,X'20'
         BO    APPN3G3                  BO IF NO
         MVC   CJ11(7),IOBDADAD        SAVE TRACK INDEX MBBCCHH
         MVI   IOBAPP,X'10'             SET APPENDAGE CODE TO 16
         NI    IOBFLAG1,X'7F'           DONT USE DATA CHAINING
         OI    IOBFLAG1,X'40'           USE COMMAND CHAINING
         LA    R13,CJ1                  START AT CJ1
         ST    R13,IOBSTART-1
         MVC   IOBDADAD,CB10+7          PUT CB10 MBBCCHHR IN IOB
         LA    R13,IOBDADAD+3           PUT SEEK ADDRESS IN CJ1 AND CJ5
         IC    R9,CJ1
         ST    R13,CJ1
         STC   R9,CJ1
         MVC   CJ5+1(3),CJ1+1           MOVE IN ADDR OF SEEK     S20201
         MVC   CJ3+1(3),DECBKEY+1       MOVE IN ADDR OF KEY      S20201
         MVC   CJ7+1(3),DECBKEY+1                                S20201
         L     R12,DCBWKPT2             SET ON FIRST TIME ONLY SWITCH
         USING IHADCW,R12                                        S20201
         OI    DCWWKNI,X'40'
         LA    R12,0(R0,R0)             IS FIRST OFLO ON SAME MODULE
         IC    R12,CB10+7                      GET M OF OFLO ENTRY
         SLL   R12,4(R0)                       MULT BY 16
         L     R12,DEBUCBAD(R12)        LOAD UCB ADDR FROM DEB   S20201
         LA    R12,0(R0,R12)            COMP WITH UCB AD IN 7    S20201
         CR    R12,R7
         BE    APPRVXCP                 SAME MODULE - EXCP RTRN TO IOS
         MVI   IOBASYN,X'01'            DIFFERENT MODULE - MUST EXCP
         B     APPN3B5                   IN ASYNCHRONOUS ROUTINE
APPN3A3  TM    IOBCSW+5,X'40'           DID CHAN PROG HAVE LENGTH ERROR
         BZ    APPN3B3                  BZ IF NO
         TM    CB11+7,X'30'             WAS ENTRY INACTIVE
         BO    APPN3B3                  BO IF YES
APPN3G3  TM    CB11+7,X'20'             VERIFY ADD-TO-END SITUATION
         BZ    APPN3B3                  BZ IF DUMMY OR INACTIVE
         CLI   DCBNLEV,X'00'            ERROR IF 2 OR MORE INDEX LEVELS
         BNE   APPN3B3                  BNE IF MORE THAN 1 INDEX LEVEL
APPN3G5  MVI   IOBAPP,X'0E'             SET APPENDAGE CODE TO 14
         MVC   IOBDADAD(3),DCBLPDA      SEEK TO DCBLETI'S CYLINDER
         MVC   IOBDADAD+3(4),DCBLETI   CCHH TO IOB
         OC    IOBDADAD+6(1),DCBFIRSH+3  MASK OUT TRACK VALUE
         XC    IOBDADAD+6(1),DCBFIRSH+3   TO REDUCETO CYL BOUNDRY
         MVI   IOBDADAD+7,X'00'        R=0
         LA    R12,CI1                  START AT CI1
         ST    R12,IOBSTART-1
         NI    IOBFLAG1,X'7F'           DON'T USE DATA CHAINING
         OI    IOBFLAG1,X'40'           USE COMMAND CHAINING
         LA    R12,IOBDADAD+3           PUT SEEK ADDRESS IN CI1
         IC    R9,CI1
         ST    R12,CI1
         STC   R9,CI1
         MVC   CI5+2(5),DCBLETI         PUT LETI CCHHR IN CI5    S20201
         MVC   CI5(2),DCBLPDA+1         MOVE IN BB FOR HEAD SEEK S20201
         B     APPRVXCP
         EJECT
*
*              THE FOLLOWING SECTION THRU APPU1A3 IS VARIABLE ONLY CODE
*
*              CHANNEL END  CP12AV   APPENDAGE 20
APPM20   L     R12,IOBCSW              TEST IF STOP A READ CCW
         LA    R12,0(R12)
         LA    R9,8(R0)
         SR    R12,R9
         CLI   0(R12),X'06'
         BNE   APPN3B3                 B=NO UNREACHABLE RECORD
         ST    R14,CH8F                SAVE R14
*
*              1ST PASS ON INPUT RECORDS-MERGE INTO NEW BLOCKS AND ADD
*              BACK TO TRACK CAPACITY-DROP ALL DELETES-COUNT RECORDS
*              IN NEW BLOCKS
*
         LA    R13,CD3
         CLI   4(R13),X'60'            TEST IF LAST BLOCK OF SEND REC
         BE    APPNL1                  B=NOT LAST
         OI    CD0A+3,X'20'            TURN LAST BLOCK SW ON
APPNL1   ST    R13,CB18+4              STORE A(CD3) IN 12A POINTER
         L     R13,0(R13)              R13= A(IST DATA BLOCK INPUT)
         MVC   CH8E(2),0(R13)          MOVE BLOCK COUNT TO'SENDBLOCK'
         LH    R14,CH8E                R14= SEND BLOCK COUNT
         MVC   CH8E+2(2),4(R13)        MOVE LENGTH OF RECORD TO 'SURE2'
         SH    R14,CH8E+2              R14= BLK LENGTH-REC LENGTH
         STH   R14,CH8E                STORE SEND BLOCK COUNT
         BAL   R14,APPADDB             GO TO ADDBACK SUBROUTINE
         LA    R13,4(R13)              R13= A(1ST LOGICAL RECORD IN BLK
APPDELCO ST    R13,CB10                SAVE CURR SEND ADDR
         MVC   CB10+4(2),0(R13)        SAVE CURR REC LGTH
         TM    DCBOPTCD,X'02'          TEST IF DELETE OPTION
         BZ    APPOKSND                B=NO SEND RECORD OK
         CLI   4(R13),X'FF'            TEST IF THIS RECORD A DELETE
         ST    R13,CB10                SAVE CURRENT SEND ADDRESS
         BNE   APPOKSND
         L     R3,DCBNREC
         BCTR  R3,R0
         TM    CD0A+3,X'20'            LAST BLK
         BZ    DELLY
         TM    CD0A+3,X'80'            NOT FIRST TIME
         BO    DELLY
         CLC   CH8E(2),HALF4           LAST REC IN BLK
         BNE   DELLY
         CLC   CB11+5(1),DCBLDT+1      LDT
         BE    APPEOCFF           EOC KEEP DELETE                   
         CLC   CB10+7(7),DCBLPDA        IS IT LAST TRK OF DATA
         BE    APPEOCFF                 YES, DO NOT DELETE
DELLY    MVC   CH8E+2(2),0(R13)
         ST    R3,DCBNREC
         AH    R13,CH8E+2              ADD RECORD LENGTH TO SEND REC PT
APPNUSND CLC   CH8E(2),HALF4           TEST IF SEND BLOCK FINISHED
         BE    APPNXTBL                B=YES GO FOR NEXT BLOCK
*                                      NO-GO TO NEXT RECORD THIS BLOCK
         LH    R3,CH8E                 R3=SEND BLOCK COUNT
         MVC   CH8E+2(2),0(R13)        MOVE NEXT RECORD LENGTH TO SURE2
         SH    R3,CH8E+2               REDUCE BLOCK COUNT BY REC LENGTH
         STH   R3,CH8E                 STORE SEND BLOCK COUNT
         B     APPDELCO
APPEOCFF OI    DECBLGTH,X'80'     SET EOC DELETE SW                 
         B     APPOKSND                                             
APPNXTBL TM    CD0A+3,X'20'            TEST IF PREV BLOCK WAS LAST
         BO    APPNOMO                 B=YES - NO MORE BLOCKS
         L     R9,CB18+4               R9= 12A POINTER
         LA    R9,8(R9)                R9 POINTS TO NEXT READ CCW
         CLI   4(R9),X'60'             TEST IF THIS BLOCK IS LAST
         BE    APPNL2                  B=NOT LAST
         OI    CD0A+3,X'20'            SET LAST BLOCK SW ON
APPNL2   ST    R9,CB18+4               STORE 12A POINTER
         L     R13,0(R9)               R13= A(NEXT DATA BLOCK)
         BAL   R14,APPADDB             GO TO ADD BACK SUBROUTINE
         MVC   CH8E(2),0(R13)          MOVE BLK COUNT TO 'SENDBLOCK'
         LA    R13,4(R13)              R13 POINTS TO 1ST LOGICAL RECORD
         B     APPNUSND
*
*              KEY COMPARE INSTRUCTION FOR EXECUTE
*
APPKEYCO CLC   0(1,R12),0(R13)         COMPARE INSERT KEY VS SEND KEY
*
APPOKSND TM    CD0A+3,X'40'            TEST IF SATISFY SW ON-IF SO NO
         BO    APPUSEND                NEED TO COMPARE KEYS-USE SEND
         L     R9,DECBAREA             R9= A(USER RECORD AREA)
         LA    R12,16(R9)              R12= A(INSERT RECORD)
         AH    R12,DCBRKP              R12= A(INSERT KEY)
         AH    R13,DCBRKP              R13= A(SEND KEY)
         SR    R3,R3
         IC    R3,DCBKEYLE
         BCTR  R3,R0
         EX    R3,APPKEYCO             COMPARE KEYS
         BH    APPUS
         BL    APPUSINS
         LH    R3,DECBLGTH             EQUAL-TEST IF WRITE KEY REPLACE
         LTR   R3,R3
         BZ    APPU1A3                 NOT WKR DUPLICATE RECORD ERR
         B     APPWKR                  OK REPLACE EQUAL REC WITH NEW
APPUSINS OI    CD0A+3,X'10'            SET USE INSERT SW ON
APPWKNR  EQU   *                       UPDATE NREC               A52331
         LA    R13,1(R0)               ADD ONE TO NO. PRIME REC IN
         A     R13,DCBNREC             DATA SET-INSERT MADE
         ST    R13,DCBNREC
APPWKR   OI    CD0A+3,X'40'            SET SATISFY SW ON
         LA    R13,16(R9)              R13= A(INSERT RECORD)
         B     APPFINDR
APPUS    SH    R13,DCBRKP
APPUSEND NI    CD0A+3,X'EF'            USE INSERT SW OFF
APPFINDR L     R9,CB18                 LOAD 12B POINTER TO R9
         LH    R3,22(R9)               R3= RECEIVE BLOCK SIZE
         NI    DECBLGTH,X'7F'     CLEAR EOC DELETE SW               
         MVC   CH8E+2(2),0(R13)        MOVE RECORD LENGTH TO SURE2
         AH    R3,CH8E+2               ADD RECORD LENGTH TO REC BLKSIZE
         TM    DCBRECFM,X'10'          TEST IF BLOCKED
         BZ    APPUB1                  IF UNBLOCKED FORCE 1 REC PER BLK
         CH    R3,DCBBLKSI             TEST IF RECORD FITS IN NEW BLOCK
         BNH   APPMOVE                 B=YES
         B     APPUB2                  NO-BEGIN NEW BLOCK
APPUB1   CLC   HALF4,22(R9)            TEST IF 1ST MOVE-IF SO ALLOW
         BE    APPMOVE                 RECORD IN BLOCK
APPUB2   L     R12,16(R9)              CLOSE OLD BLK-R12= A(DATA BLOCK)
         MVC   0(2,R12),22(R9)         MOVE BLOCK SIZE TO DATA BLOCK
         MVI   2(R12),X'00'
         MVI   3(R12),X'00'
         LA    R9,24(R9)               INCREMENT 12B POINTER
         ST    R9,CB18                 STORE 12B POINTER
         L     R12,CB17+4              R12= RECEIVE ADDRESS
         LA    R3,4(R0,R0)
         AH    R3,CH8E+2               ADD SURE2(REC LENGTH) TO R3
         MVC   17(3,R9),CB17+5         MOVE DATA ADDRESS TO NEXT WRITE
*                                      CCW IN CP12BV
         LA    R12,4(R12)              INCREMENT RECEIVE ADDRESS
         ST    R12,CB17+4              STORE  RECEIVE ADDRESS
APPMOVE  L     R12,CB17+4              R12= RECEIVE ADDRESS
         STH   R3,22(R9)               STORE NEW RECEIVE BLOCKSIZE
         BAL   R14,APPMOVER            GO TO MOVE SUBROUTINE
         L     R14,CB17+4              R14=A(LAST DATA RECORD MOVED)
         AH    R14,DCBRKP              R14=A(LAST K IN REC BLOCK
         L     R9,CB18                 LOAD 12B POINTER TO R9
         ST    R14,8(R9)               PLACE KEY ADDR IN WRITE KEY CCW
         ST    R12,CB17+4              STORE NEXT RECEIVE ADDRESS
         LH    R3,CD0A2+4               SAVE REC COUNT FOR CASE NB
         LA    R3,1(R3)                 GTR THAN 255              
         STH   R3,CD0A2+4                                         
         SR    R3,R3
         LH    R3,CH6+FOUR              R3=REC COUNT FOR OUTPUT  A48560
*                                       REC                      A48560
         LA    R3,1(R3)
         STH   R3,FOUR(R9)              PLACE HI REC NUM IN      A48560
*                                       BLOCK                    A48560
*                                       IN WRITE CCW FOR THAT BLOCK
         STH   R3,CH6+FOUR              STORE REC COUNT          A48560
         L    R13,CB10                 R13 PTS TO LAST SEND REC
         MVC   CH8E+2(2),CB10+4         OVE LAST REC L TO SURE2
         TM    CD0A+3,X'10'            TEST IF TRUE INSERT
         BO    APPOKSND                YES-USE LAST SEND
         AH    R13,CH8E+2              R13 PTS TO NEXT SEND
         B     APPNUSND
*
*              MOVE INSTRUCTION FOR EXECUTE IN MOVE SUBROUTINE
*
APPMOVE4 MVC   0(1,R12),0(R13)
*
APPNOMO  TM    CD0A+3,X'40'            TEST SATISFY SW-IF NOT ON GO
         BO    APPNOMO2                BACK AND INCLUDE INSERT RECORD
         L     R9,DECBAREA
         B     APPWKNR                 UPDATE NREC               A52331
APPNOMO2 TM    CD0A+3,X'80'            TEST IF 1ST TIME SW ON
         BZ    APPALLIN                NO- ALL RECORDS READ
         NI    CD0A+3,X'5F'            TURN 1ST TIME + LAST BLK SWS OFF
*
*              IF ALL RECORDS NOT IN  READ REMAINDER OF THE TRACK
*              INITIALIZE  CP12AV  AGAIN
*
         LA    R3,CD1
         STH   R3,IOBSTART+1
         SRL   R3,16
         STC   R3,IOBSTART             CP12 STARTS AT CD1
         L     R3,DCBMSWA              R3=A(MSWA)
         LA    R3,0(R3)
         AH    R3,DCBSMSW              R3=A(END OF MSWA)
         ST    R3,CB6+4                STORE END ADDRESS OF MSWA
         SR    R12,R12
         LR    R13,R12
         IC    R13,IOBDADAD+7          R13= SEARCH R FOR PREV USE CP12A
         AH    R13,CK9+2               ADD NO BLKS READ LAST TIME
         IC    R12,CB11+6              R12= HI R ON TRACK
         LA    R3,CD3
         L     R9,CD2A
         LA    R9,0(R9)
         CR    R3,R9
         BE    APPNOKEY
         SR    R12,R13                 R12= NUM BLOCKS REMAINING TO RD
         LA    R13,1(R13)              R13= NEW SEARCH R
         ST    R3,CD2A
         MVI   CD2A,X'08'
         B     APPKEYS
APPNOKEY LA    R12,1(R12)
         SR    R12,R13
APPKEYS  STC   R13,IOBDADAD+7
         MVC   CD3+1(3),CB17+5         MOVE 1ST AVAILABLE DATA ADDRESS
         LA    R13,CD3
         L     R9,CD3
         LA    R9,0(R9)
         AH    R9,DCBBLKSI             R9=DATA ADDR FOR 2ND BLOCK
         LA    R3,1(R0)                R3=NO BLKS SCHED SO FAR=1
APPV006  BCT   R12,APPV005
*
*              DETERMINE IF LAST BLOCK EXTENDS PAST END OF WORK AREA.
*              IF SO, SET DATA LENGTH OF LAST READ CCW TO THE
*              DIFFERENCE BETWEEN THE DATA ADDRESS OF THE CCW AND END
*              ADDRESS OF THE WORK AREA.
*
         C     R9,CB6+4                 RCD EXTEND PAST WA      YM03024
         BL    APPNI                    BRANCH IF NO            YM03024
         SH    R9,DCBBLKSI              POINT TO LAST DATA ADDR YM03024
         L     R12,CB6+4                END OF WORK AREA ADDR+1 YM03024
         SR    R12,R9                   NO. BYTES FOR LAST READ YM03024
         USING CCWCD3,R13               LAST CD3 CCW ADDR       YM03024
         STH   R12,CCWDL                DATA LENGTH FOR READ    YM03024
         DROP  R13                      END CCW CD3 ADDR        YM03024
APPNI    NI    4(R13),X'BF'            CC OFF IN LAST READ CCW
         B     APPV007
APPV005  CH    R3,CD0C+6               TEST NO SCHED SO FAR VS NO CCWS
         BE    APPSHORT                EQUAL-CAN'T SCHED ANY MORE
         ST    R9,8(R13)               STORE DATA ADDR IN  NEXT CCW
         MVI   8(R13),X'06'            RESTORE OP
         AH    R9,DCBBLKSI             R9=DATA ADDR OF NEXT BLOCK
         C     R9,CB6+4                DOES THIS BLOCK GO TOO FAR
         BNL   APPSHORT                B=YES                    YM03024
         LA    R3,1(R3)                NO-SCHED THIS BLOCK
         OI    4(R13),X'40'            PREV BLOCK IS NOT LAST
         LA    R13,8(R13)
         B     APPV006
APPSHORT OI    CD0A+3,X'80'            NOT FINISHED-SET 1ST TIME SW
         STH   R3,CK9+2                STORE NO READ THIS TIME
         B     APPNI
APPV007  MVI   IOBCOUNT,X'0A'          ERROR COUNT=10
         B    APPVX
*
*              ALL RECORDS IN AND MERGED
*
APPALLIN L     R9,CB18                 LOAD 12B POINTER
         NI    CD0A+3,X'5F'            TURN 1ST TIME + LAST BLK SWS OFF
         L     R12,16(R9)              R12= LAST DATA BLOCK ADDR
         MVC   0(2,R12),22(R9)         MOVE LAST BLOCK SIZE TO DATA BLK
         MVI   2(R12),X'00'
         MVI   3(R12),X'00'
         L     R9,CD2+4                RESET POINTERS
         L     R12,CB2+4              *
         USING CP12B,R9                                          S20201
         USING CP123,R12                                         S20201
         LA    R9,CE4                   FIRST CE4                S20201
         ST    R9,CB18                 STORE 12B POINTER
         L     R13,DCBMSWA
         AH    R13,14(R9)              R13= A(MSWA+KL)
         MVC   CD0C+5(1),4(R13)        SAVE 1ST R OF BLKS TO BE WRITTEN
         LA    R12,CEE                  POINT TO CEE             S20201
         ST    R12,CB18+4             *STORE 123W POINTER
*
*              2ND PASS OF RECORDS NOW IN OUTPUT BLOCK-DECIDE HOW MANY
*              BLOCKS CAN BE WRITTEN WITHOUT EXCEEDING CAPACITY OR
*              HIRPD
*
         L     R3,CH8F+4               LOAD DEVICE TABLE POINTER
APPNIDOT LH    R13,14(R9)              R13=KL
         AH    R13,22(R9)              R13= KL+BL
         LR    R14,R13
         MH    R14,10(R3)              R14=TOL(KL+BL)
         SRA   R14,9                   DIVIDE BY 512
         L     R12,DCBWKPT2             WORK AREA ADDRESSABILITY S20201
         USING IHADCW,R12                                        S20201
         AH    R14,DCWIPG               R12=NID0                 S20201
         LH    R12,CD0A                R12=CAPACITY
         SR    R12,R14                 TEST IF BLK FITS AS NON LAST
         BM    APPLIDOT                B=NO
APPNIDOF STH   R12,CD0A                BLOCK FITS-STORE CAP
         STH   R14,CH8E+4              SAVE LAST NIDO + TOL(KL+BL)
         CLC   CH6+FOUR(HW),FOUR(R9)    DOES THIS BLOCK HAVE     A48560
*                                       LAST REC                 A48560
         BE    APPRECDN                B=YES ALL RECORDS FIT
         CLC   CD0C+5(1),DCBHIRPD      IS THIS LAST BLOCK ALLOWED
         BE    APPRECDN                B=YES HI R HAS BEEN REACHED
         SR    R14,R14
         IC    R14,CD0C+5              R14= R OF THIS BLOCK
         LA    R14,1(R14)              ADD 1
         STC   R14,CD0C+5
         OI    20(R9),X'40'            CC ON IN WRITE CCW FOR THIS BLK
         LA    R9,24(R9)               INCREMENT R9 TO NEXT CE4
         B     APPNIDOT
*
*              BLOCK DOES NOT FIT AS NON-LAST  DOES IT FIT AS LAST
*
APPLIDOT L     R12,DCBWKPT2
         TM    DCWWKNI,X'10'           TEST IF ADD TO END
         BZ    APPLIDOG                B=NO
         OI    DCBST,X'03'             IF ADD TO END SET BLK + TRACK
*                                      FULL INDICATORS
APPLIDOG L     R12,DCBWKPT2             WORK AREA ADDRESSABILITY S20201
         AH    R13,DCWLPG               R13=LIDO+KL+BL           S20201
         LH    R12,CD0A                R12=CAPACITY
         SR    R12,R13                 TEST IF BLOCK FITS AS LAST
         BM    APPAET                  B=NO MUST DROP OFF LOGICAL
*                                      RECORDS TO FIND LAST ON WHICH
*                                      FITS
APPLIDOF STH   R12,CD0A                BLOCK FITS AS LAST-STORE CAPACIT
         NI    20(R9),X'BF'            CC OFF IN LAST CE6
         B     APPREST
APPRECDN LH    R12,CD0A                PREV BLOCK WAS LAST-REDUCE CAP
         AH    R12,CH8E+4              BY LIDO AMOUNT NOT NIDO AMOUNT
         XC    CH8E+4(2),CH8E+4        CLEAR LAST NIDO
         STH   R12,CD0A                BACK TO SUBTRACT LIDO AMOUNT
         B     APPLIDOG
*
*              R12 HERE CONTAINS  CAP-LIDO-KL-BL FOR LAST BLOCK
*              RESULT WAS MINUS
*
APPDROP  AR    R12,R13                 ADD BACK LIDO+KL+BL
         DROP  R12                                               S20201
         L     R14,DCBWKPT2             WORK AREA ADDRESSABILITY S20201
         USING IHADCW,R14                                        S20201
         LH    R14,DCWLPG               R14=LIDO                 S20201
         DROP  R14                                               S20201
         USING IHADCW,R12                                        S20201
         USING APPRV,R14                IOS RETURN VECTOR PTR    S20201
         AH    R14,14(R9)              ADD KL
         L     R13,16(R9)              R13= A(LAST DATA BLOCK)
         LH    R3,22(R9)               R3= SIZE OF LAST DATA BLOCK
         MVC   CH8E+2(2),4(R13)        MOVE REC LENGTH OF 1ST LOGICAL
*                                      RECORD IN LAST BLOCK TO SURE2
         STH   R14,22(R9)              SAVE LIDO+KL
         LA    R14,4(R14)              R14=4+LIDO+KL
         AH    R14,CH8E+2              ADD RECORD LENGTH
         CR    R14,R12                 WILL LAST BLOCK FIT WITH 1 REC
         BNH   APPWF2                  B=YES
*
*              NO PORTION OF LAST BLOCK WILL FIT-ALL RECORDS WILL BE
*              OVERFLOWS-GO BACK TO MAKE PREV BLOCK THE LAST
*
         STH   R3,22(R9)               RESTORE BLOCK LENGTH
         L     R3,CH8F+4               LOAD DEV PTR
         LA    R9,0(R9)
         L     R12,CB18
         LA    R12,0(R12)              R12= A (1ST CE4)
         CR    R12,R9                  TEST IF A PREV BLOCK
         BE    APPNR1                  B=NO  WILL NOT USE CP12BV
         LA    R12,24(R0,R0)
         SR    R9,R12                  GO BACK TO PREV BLOCK
         LH    R13,14(R9)              R13=KL PREV
         AH    R13,22(R9)              R13=KL + BL PREV
         B     APPRECDN
APPWF2   LA    R13,4(R13)
APPWF3   AH    R13,DCBRKP              R13=A(KEY OF REC WHICH FITS)
         ST    R13,8(R9)
         SH    R13,DCBRKP
         AH    R13,CH8E+2              ADD REC LENGTH
         MVC   CH8E+2(2),0(R13)        MOVE NEXT REC LENGTH TO SURE2
         AH    R14,CH8E+2              ADD TO BLOCK LENGTH
         CR    R12,R14                 WILL THIS RECORD FIT
         BNL   APPWF3                  B=YES
         SH    R14,CH8E+2              R14= AMOUNT TAKEN BY FINAL BLOCK
         SR    R12,R14
         STH   R12,CD0A                STORE FINAL CAPACITY
         SH    R14,22(R9)              SUBTRACT LIDO+KL
         STH   R14,22(R9)              STORE FINAL BLOCK SIZE
         L     R12,16(R9)              R12=LAST BLOCK ADDRESS
         MVC   0(2,R12),22(R9)         MOVE BLOCKSIZE TO LAST BLOCK
         MVI   2(R12),X'00'
         MVI   3(R12),X'00'
         LR    R12,R3                  R12= PREV SIZE OF FINAL BLOCK
         SR    R12,R14                 R12= SIZE OF ALL OFLOW RECORDS
*                                      LEFT IN BLOCK
         LR    R3,R13     STORE ADDR OF FIRST OFLOW                 
         STH   R3,42(R9)                                            
         SRL   R3,16                                                
         STC   R3,41(R9)                                            
         NI    20(R9),X'BF'            CC OF THIS CE6
APPSHR2  LA    R3,1(R0,R0)
APPSHR3  EQU   *                        *                        A48560
         STH   R3,CH8E+SIX              STORE NUM OF OVFLOWS     A48560
         SH    R12,CH8E+2              SUBTRACT LENGTH OF THIS RECORD
         BZ    APPNOFLO                B= NO MORE OFLOW RECORDS
         AH    R13,CH8E+2              GO TO NEXT RECORD
         LA    R3,1(R3)                ADD 1 TO NUMBER OF OFLOWS
         MVC   CH8E+2(2),0(R13)        NEXT REC LENGTH TO SURE2
         B     APPSHR3
APPNOFLO AH    R13,CH8E+2
         STH   R3,CD0A2+6               SAVE OFLOW TOTAL          
         B     APPRS1
APPREST  SR    R3,R3
         L     R13,40(R9)              R13=A(NEXT BLOCK)IF ANY
APPRS1   EQU   *                       *                         A48173
         SR    R14,R14                 NO- ONE MORE BLOCK
         LH    R14,CH6+FOUR             LOAD REC COUNT           A48560
         AR    R3,R14
         LH    R14,FOUR(R9)             NUM OF RECORDS           A48560
         SR    R3,R14                  R3=TOTAL NUMBER OF OVERFLOWS
         STH   R3,CH8E+SIX              STORE NUM OF OVERFLOWS   A48560
         STH   R3,CD0A2+6               SAVE GALF WORD            
         L     R12,DCBNREC             REDUCE NO PRIME REC BY THE
         SR    R12,R3                  NUMBER OF OVERFLOWS
         ST    R12,DCBNREC
         CLC   CH6+FOUR(HW),FOUR(R9)    IS ALL REC ACCOUNTED FOR A48560
*                                       FOR                      A48173
         BE    APPWOW                  B=YES                     A48173
         LR    R12,R13                 R12=A(NEXT BLOCK)
         LA    R13,4(R12)              R13=A(1ST LOGICAL REC IN BLOCK)
         MVC   CH8E+2(2),0(R12)        MOVE BLK SIZE TO SURE2
APPLHT   LH    R14,CH8E+2              SET UP TO MOVE RECORDS 4 BYTES
         SH    R14,HALF4               LEFT TO ELIMINATE BLOCK SIZE
         STH   R14,CH8E+2              FIELD
         ST    R9,CH10+4               SAVE R9
         BAL   R14,APPMOVER            GO TO MOVE SUBROUTINE
         L     R9,CH10+4               RESTORE R9
         LA    R9,24(R9)
         CLC   CH6+FOUR(HW),FOUR(R9)    LAST BLOCK               A48560
         BE    APPWOW
         MVC   CH8E+2(2),0(R13)
         LA    R13,4(R13)
         B     APPLHT
APPNR1   LH    R12,22(R9)              R12= BLOCK SIZE OF UNUSED  BLOCK
         SH    R12,HALF4               LESS BLOCK SIZE FIELD
         AH    R13,HALF4               R13= A(1ST LOGICAL REC)=A(1ST
         ST    R13,16(R9)              OVERFLOW)
         B     APPSHR2
APPWOW   L     R12,CB18+4              LOAD 123W POINTER
         CLC   CD0A2+4(2),CD0A2+6       TEST IF ALL RECS OFLOW    
         BNE   APPDOWRT                B=NO
         L     R3,RQEDEB                RESTORE DEB POINTER      Y02072
         MVC   CD0A+2(1),CB23+7         HIGH R IS BLOCK BEFORE   A38807
         MVC   CB11+6(1),CB23+7         * INSERT.                A38807
         MVC   CH7+1(3),DCBMSWA+1      HI K  ADDRESS-KEY OF BLK BEFORE
         L     R12,CB2+4               INSERT
         USING CP123,R12                                         S20201
         NI    CEA1+4,X'FF'-CC          TURN OFF CC              S20201
         L     R9,CD2+4                 R9=A(CP12BV)             S20201
         USING CP12B,R9                                          S20201
         NI    CE0B+4,X'FF'-CC          TURN OFF CC              S20201
         LA    R9,CE3A                  SAVE 1ST CE3A ADDR       S20201
         ST    R9,CH21+4               FOR ASYN RTN
         B     APPST12B
APPDOWRT L     R9,CB18                 R9=A(1ST CE4)
         L     R13,DCBMSWA
         AH    R13,14(R9)              R13= A(MSWA+KL)
*
*              3RD PASS OF MERGED RECORDS-ESTABLISH COUNTS FOR 12B
*              TRANSFER DATA FROM 12B TO CORRESPONDING CCWS OF 123W.
*
         LA    R3,0(R0,R0)            *
APPTOP   MVC   5(1,R13),15(R9)         MOVE KL TO COUNT FIELD
         MVC   6(2,R13),22(R9)         MOVE BL TO COUNT FIELD
         AH    R3,14(R9)              *R3=KL + BL +  ZERO OR 8 DEPENDNG
         AH    R3,22(R9)              *ON WHETHER CEE OR OTHER 123W CCW
         MVC   FOUR(FOUR,R9),DCDL       RESET DC AND COUNT       A48560
         STH   R3,6(R12)              *BL TO CCW OF 123W
         TM    20(R9),X'40'            TEST IF LAST BLOCK IN 12B
         BZ    APPFINIS                B=LAST BLOCK
         OI    4(R12),X'40'           *CC ON IF NON LAST BLK-CP123W
         MVC   8(6,R13),0(R13)         MOVE COUNT SKELETON FOR NEXT BLK
         SR    R3,R3
         IC    R3,4(R13)               ADD ONE TO R OF PREV COUNT
         LA    R3,1(R3)
         STC   R3,12(R13)              STORE R OF NEXT COUNT
         LA    R13,8(R13)              ADD TO POINTERS
         LA    R9,24(R9)
         LA    R12,8(R12)             *
         LA    R3,8(R0,R0)            *
         B     APPTOP
APPFINIS EQU   *                                                 S20201
         NI    4(R12),X'BF'           *CC OFF IN LAST CCW-CP123W
         ST    R9,CH21+4               SAVE ADDR OF LAST CE4
         MVC   IOBDADAD+7(1),CB23+7    SEARCH R FOR 12B
         MVC   CD0A+2(1),4(R13)        HI R OF NEW TRACK
         MVC   CB11+6(1),4(R13)
         MVC   CH7+1(3),9(R9)          HI K OF NEW TRACK
APPST12B L     R12,CD2+4
         CLC   CH8E+SIX(HW),HALF0       TEST IF ANY OVERFLOWS    A48560
         BE    APPST12V                 NO
         MVI   IOBASYN,X'09'            YES SCHEDULE A SYN=9
         B     APPU1A4                  PREPARE FOR ASYNCH RTN   S20201
APPST12V MVI   IOBCOUNT,X'01'           ERROR COUNT = 1
         MVI   CH29+6,X'10'
APPST12  OI    IOBFLAG1,X'C0'          DC ON CC ON
         MVI   IOBAPP,X'15'            APPENDAGE CODE=21
         MVC   IOBSTART,CD2+5          CP12B STARTS AT CE0
         CLC   IOBDADAD(7),DCBLPDA     TEST IF LAST TRACK
         BNE   APPVX0                  BRANCH = NO               S20201
         MVC   DCBLPDA+7(1),CD0A+2     R OF LPDA=HI R
APPVX0   EQU   *                        RESTORE CP8              S20201
         LA    R14,CB18B                RESTORE CB18             S20201
         ST    R14,CB18                                          S20201
         MVI   CB18,TIC                 RESTORE COMMAND CODE     S20201
         MVC   CB17+4(4),RESTORE        MOVE IN CC AND SKIP      S20201
*                                       FLAGS                    S20201
APPVX    SR    R9,R9                   CLEAR R9 FOR RETURN TO IOS
         L     R14,CH8F                RESTORE R14
         B     APPRVXCP
APPAET   LR    R14,R12                 SAVE CONTENTS OF R12
         L     R12,DCBWKPT2
         USING IHADCW,R12                                        S20201
         TM    DCWWKNI,X'10'           TEST IF ADD TO END
         BO    APPAET2                 B= YES EXECUTE ASYNC=10
         LR    R12,R14
         B     APPDROP
APPAET2  MVI   IOBASYN,X'0A'           ASYNC CODE=10
         NI    IOBINDCT,X'DF'          MARK OFLOW IN USER AREA
         B     APPU1A4                  PREPARE FOR ASYNCH RTN   S20201
*
*              MOVE RECORD SUBROUTINE
*              ENTER BY   BAL  R14,APPMOVER
*              NUMBER OF BYTES TO BE MOVED IS IN SURE2 (CH8E+2)
*              R13 CONTAINS ADDR OF 1ST SEND BYTE
*              R12 CONTAINS ADDR OF 1ST RECEIVE BYTE
*
*              ON EXIT R13 CONTAINS ADDR OF LAST SEND BYTE + 1
*                      R12 CONTAINS ADDR OF LAST RECEIVE BYTE +1
*
APPMOVER EQU   *                       MOVE RECORDS              S20201
         LH    R3,CH8E+2               R3= NUM BYTES TO BE MOVED
         BCTR  R3,R0
         LA    R9,255(R0,R0)           R9=255                    S20201
APPMOVE2 CLR   R3,R9                   TEST IF REMAINING BYTES TO BE
         BNH   APPMOVE3                MOVED LESS THAN OR EQUAL 255
         MVC   0(255,R12),0(R13)       MOVE 255 BYTES
         SR    R3,R9                   SUBTRACT 255 FROM NUM TO MOVE
         AR    R12,R9                  INCREMENT RECEIVE ADDR
         AR    R13,R9                  INCREMENT SEND ADDR
         B     APPMOVE2
APPMOVE3 EX    R3,APPMOVE4             MOVE REMAINING BYTES
         LA    R13,1(R13,R3)
         LA    R12,1(R12,R3)
         BR    R14                     RETURN
*
*              ADDBACK SUBROUTINE  TO  ADD AMOUNT OF TRACK SPACE USED
*              BY BLOCKS READ BY CP12AV BACK INTO TRACK  CAPACITY
*              FOR NON LAST BLOCK ADD  NIDO + TOL(KL + BL )
*              FOR LAST BLOCK ADD  LIDO + KL + BL
*              ENTRY BY  BAL R14,APPADDB
*
APPADDB  L     R3,CH8F+4               LOAD DEVICE TABLE POINTER
         SR    R9,R9
         SR    R12,R12
         IC    R9,DCBKEYLE
         MVC   CH8E+2(2),0(R13)        MOVE BLOCK LENGTH TO SURE2
         AH    R9,CH8E+2               R9= KL + BL
         TM    CD0A+3,X'80'            TEST IF 1ST TIME CP12A
         L     R12,DCBWKPT2             WORK AREA ADDRESSABILITY S20201
         BO    APPOTHER                B=YES
         TM    CD0A+3,X'20'            TEST IF LAST BLOCK
         BZ    APPOTHER                B=NO
APPLASTL LH    R12,DCWLPG               R12=LIDO                 S20201
         B     APPOUT
APPOTHER LH    R12,DCWIPG               R13=NIDO                 S20201
         MH    R9,10(R3)               R9= TOL(KL + BL)
         SRA   R9,9
APPOUT   AR    R9,R12                  R9= ADDBACK AMOUNT
         AH    R9,CD0A                 ADD CAPACITY TO R9
         STH   R9,CD0A                 STORE CAPACITY
         BR    R14                     RETURN
APPU1A3  L     R10,DCBWKPT3             RESTORE CP8 POINTER
         NI    CD0A+3,X'0F'            TURN OFF ALL SWITCHES
         OI    DECBEXC1,X'01'           DUPLICATE RECORD         S20201
         MVI   IOBASYN,X'08'            SET ASYNCHRONOUS CODE TO S20201
*                                       8                        S20201
APPU1A4  L     R3,RQEDEB                RESTORE DEB POINTER      Y02072
         LA    R3,0(R0,R3)
         SR    R9,R9                   CLEAR R9 FOR RETURN TO IOS
         LA    R14,CB18B                RESTORE CB18             S20201
         ST    R14,CB18                                          S20201
         MVI   CB18,TIC                 RESTORE COMMAND CODE     S20201
         MVC   CB17+4(4),RESTORE        MOVE IN CC AND SKIP      S20201
*                                       FLAGS                    S20201
         L     R14,CH8F                RESTORE R14
         B     APPN3B5                  SCHEDULE ASYNCHRONOUS ROUTINE
*
*              CHANNEL END CP12B  APPENDAGE CODE 21
*                        VARIABLE ONLY CODE
*
APPM21   L     R13,IOBCSW
         LA    R13,0(R0,R13)
         L     R12,CD2+4               R12=A(CP12B)              S20201
         USING CP12B,R12                                         S20201
         OI    CE0B+4,CC                TURN ON CC AT CE0B       S20201
         LA    R12,CE0B+8                                        S20201
         CR    R12,R13
         BE    APPONLY1
         LA    R12,24(R0,R0)
         SR    R13,R12
         ST    R13,CH8F                SAVE ADDR OF LAST CE4 USED
         CLI   20(R13),X'00'           TEST IF CC OFF ON LAST CCW
         BNE   APPN3B3                 B= NO  UNREACHABLE
         B     APPONLY2               *
APPONLY1 LA    R12,24(R12)
         ST    R12,CH8F                SAVE ADDRESS OF 1ST CE3A
APPONLY2 MVC   IOBSTART,CB2+5         *START ADDRESS OF CP123W
         OI    IOBFLAG1,X'C0'         *CC ON  DC ON
         MVI   IOBAPP,X'16'           *APPENDAGE CODE= 22
         TM    DCBOPTCD,X'80'          TEST IF WRITE CHECK
         BZ    APPREENT                BRANCH = NO
         B     APPRVXCP               *START UP CP123W
APPREENT EQU   *                       APPENDAGE 22 RETURNS HERE AFTER
*                                      WRITE CHECK
         TM    CH29+6,X'10'             ANY OVERFLOW RECORDS
         BZ    APPUX                    YES
APPTRACK EQU   *                       IF NO OVER FLOWS USE CP14 TO
*                                      WRITE UPDATED PRIME TRACK INDEX
*                                      ENTRY
         LA    R12,CH5
         STH   R12,IOBSTART+1
         SRL   R12,16
         STC   R12,IOBSTART            CP14 STARTS AT CH5
         OI    IOBFLAG1,X'C0'          CC ON  DC ON
         MVI   IOBCOUNT,X'0A'          ERROR COUNT =10
         TM    CB26,X'08'
         BO    APP8C
         MVC   CH12+1(3),CH7+1
         LA    R12,CH12
         ST    R12,CH10
         MVI   CH10,X'08'
         OI    CH8G5,X'80'                                       S20201
         TM    DCBOPTCD,X'80'
         BO    APPVV16
         NI    CH13+4,X'BF'
         B     APPVV2
APPUX    MVI   IOBAPP,X'0A'             UPDATE INDICES
         MVC   IOBSTART,CH13B+5         START ADDRESS
         MVC   IOBDADAD(8),CH14         SEEK ADDR
         MVI   CH14,X'03'               SET UP NOP WITH CC OFF
         MVI   CH14+4,X'20'             SILI BIT ON
         MVI   CH14+7,X'01'             COUNT=1
         B     APPRVXCP
APPVV16  NI    CH13C+4,X'BF'
         B     APPVV2
APP8C    TM    DCBOPTCD,X'80'
         BO    APPVV1                  BRANCH=YES
         NI    CH8+4,X'BF'             CC OFF IN CH8
         B    APPVV2
APPVV1   NI    CH8C+4,X'BF'            CC OFF IN CH8C
APPVV2   MVI   IOBAPP,X'11'            APPENDAGE CODE =17
         MVC   IOBDADAD+5(3),CB23      SEARCH ADDRESS IS TRACK INDEX
*                                      PRIME ENTRY
         NI    CH55,X'FF'-MT            MT OFF- CH55             S20201
         B     APPRVXCP
*              ABNORMAL END CP12A    APPENDAGE CODE 20              
APPU4B2  TM    IOBECBAD,PERRMASK        WAS ABEND DUE TO PERM ERROR
         BC    PERRNO,APPRVNOR          NO.  NORMAL RETURN TO IOS
         TM    IOBSENSE,X'08'           CONTINUE IF CAUSE DATA CHECK
         BZ    APPN3B3                  OTHERWISE, RECORD IS UNRCHBLE
         LA    R13,CD2A+8                                           
         CLR   R12,R13
         BNH   APPN3B3                  NO.  RECORD UNRCHBLE, BRANCH
APPU4E2  OI    DECBEXC1,X'08'           YES. UNCORRECTABLE I/O ERROR
         B     APPN3B4
         EJECT
*              ABNORMAL END CP12B  APPENDAGE CODE 21
APPU4G2  TM    IOBECBAD,PERRMASK        WAS ABEND DUE TO PERM ERROR
         BC    PERRNO,APPRVNOR          NO.  NORMAL RETURN TO IOS
         TM    IOBSENSE,X'08'           WAS CAUSE DATA CHECK
         BZ    APPN3B3                  NO.  BRANCH UNREACHABLE
         L     R12,IOBCSW               DID CP STOP AT WR CCW
         L     R13,IOBSTART-1           CG1 ADDRESS
         LA    R13,72(R0,R13)          CE4 ADDRESS                  
         LA    R12,0(R0,R12)
         CLR   R12,R13
         BL    APPN3B3                  BRANCH IF NOT TO UNRCHBLE
         B     APPU4E2
         EJECT
*              CHANNEL  END CP123W, APPENDAGE CODE 22,         CHART JA
*                        VARIABLE ONLY CODE
APPJAC2  LA    R9,8
APPM22   L     R12,IOBCSW
         LA    R12,0(R12,R0)
         L     R13,CB2+4
         USING CP123,R13                                         S20201
         OI    CEA1+4,CC                CC ON IN CEA1            S20201
         LA    R13,CEA1+8                                        S20201
         CR    R12,R13                 TEST STOP AT CEA1
         BE    APPREENT                B=YES
         LA    R13,8(R0,R0)
         SR    R12,R13
         CLI   0(R12),X'0E'            TEST IF STOP ON A READ CCW
         BE    APPTESTC                B=YES
         CLI   0(R12),X'1E'
         BNE   APPN3B3                 B=NO  UNREACHABLE
APPTESTC TM    4(R12),X'40'            TEST IF CC OFF
         BZ    APPREENT                B= YES OK GO BACK TO APPEND 21
         B     APPN3B3
         EJECT
*              ABNORMAL END CP123W, APPENDAGE CODE 22,         CHART JA
APPJAE2  TM    IOBECBAD,PERRMASK        ABEND DUR TO PERM ERROR
         BC    PERRNO,APPRVNOR          NO-NORM RET TO IOS
         TM    IOBSENSE+1,X'04'         NO RECORD FOUND
         BO    APPJAE3                  IF YES-REEXECUTE CP12B
         TM    IOBSENSE,X'08'           ABEND DUE TO DATA CHECK
         BZ    APPN3B3                  NO-RECORD IS UNREACHABLE
         B     APPJAH3                  POST UNCORRECTABLE I/O E
APPJAE3  SR    R12,R12
         IC    R12,IOBCOUNT
         BCTR  R12,R0                   REDUCE COUNTER BY 1
         STC   R12,IOBCOUNT
         LTR   R12,R12                  IS COUNTER ZERO
         BZ    APPJAH3                  YES - UNCORRECTABLE I/O ERROR
         NI    IOBFLAG1,X'FB'           RESET EXCEPTION FLAG
         ST    R14,CH8F     STORE REG FOR RESTORE                 
         B     APPST12                 RETRY-RETURN TO APPENDAGE 20 
APPJAH3  OI    DECBEXC1,X'08'           UNCORRECTABLE I/O ERROR
         B     APPN3B4                  SCHEDULE PROCESSING COMPLETION
         EJECT
*              CHANNEL  END CP15,   APPENDAGE CODE 14,         CHART M1
APPM1B2  LA    R13,CI4+8                DID CHAN PROG STOP AT CI4
         CLR   R12,R13                  BE MEANS YES, BNE MEANS NO
         BNE   APPM1B3                  NO - RECORD IS UNREACHABLE
*              SIMULATE CHART U5 SUBROUTINE
         L     R12,DCBWKPT2
         USING IHADCW,R12                                        S20201
         OI    DCWWKNI,X'10'            SET ADD-TO-END INDICATOR ON
*
*              VARIABLE ONLY CODE FROM HERE THRU APPM1C2
*
         TM    CB26,X'08'              ANY ON CHAIN
         BO    APPM1C2                 B=YES
         TM    DCBST,X'01'             TEST IF LAST TRACK FULL
         BO    APPM1C2                 B=YES
         MVC   IOBDADAD,DCBLPDA
         SR    R12,R12
         IC    R12,IOBDADAD+7
         BCTR  R12,R0
         STC   R12,IOBDADAD+7          R IN IOBDADAD+7 = R OF BLOCK
*                                      BEFORE LPDA
         MVC   CB23+3(5),IOBDADAD+3
         MVC   CD0(4),IOBDADAD+3                                 S20201
         MVI   CD0+4,X'00'              POINT TO R0              S20201
         MVC   CB22+6(5),DCBLETI
         MVC   CB10+7(8),DCBLPDA
         MVI   CB11+7,X'00'
         MVI   CB12,X'1B'
         L     R12,DCBWKPT2             RESTORE WKAREA BASE      S20201
         B     APPENTRY
APPM1C2  EQU   *
         TM    CB26,X'08'               WAS ENTRY READ IN CB25 OFLO END
         BZ    APPM1D3                  YES  M1D3
         MVC   IOBDADAD,CB25            MOVE CB25 MBBCCHHR TO IOB
         MVI   IOBAPP,X'0F'             SET APPENDAGE CODE TO 15
         NI    IOBFLAG1,X'7F'           DONT USE DATA CHAINING
         OI    IOBFLAG1,X'40'           USE COMMAND CHAINING
         LA    R12,CJ1                  START AT CJ1
         ST    R12,IOBSTART-1
         LA    R12,IOBDADAD+3           MOVE IOB ADDRESS TO CJ1 AND CJ5
         ST    R12,CJ1
         MVI   CJ1,SIDEQ                                         S20201
         MVC   CJ5+1(3),CJ1+1           MOVE IN ADDR OF SEEK     S20201
         MVC   CJ3+1(3),DECBKEY+1       MOVE IN ADDR OF KEY      S20201
         MVC   CJ7+1(3),DECBKEY+1                                S20201
         SR    R12,R12                  CMP TRK IX VS OFLO RCD   S20201
*                                       MODL                     S20201
         IC    R12,CB25                  ARE THEY THE SAME
         SLL   R12,4(R0)
         L     R12,DEBUCBAD(R12)                                 S20201
         LA    R12,0(R0,R12)
         CLR   R12,R7
         BE    APPRVXCP                 YES - EXCP RETURN TO IOS
         MVI   IOBASYN,X'01'
         B     APPM1D4                  EXCP IN ASYNCHRONOUS ROUTINE
APPM1D3  MVI   IOBASYN,X'0A'            SET ASYNCHRONOUS CODE TO 10
APPM1D4  NI    IOBINDCT,X'DF'           INDICATE OFLO RECORD IN AREA
         B     APPM1B5                  SCHEDULE ASYNCHRONOUS ROUTINE
APPM1B3  OI    DECBEXC1,X'04'           RECORD IS UNREACHABLE
APPM1B4  MVI   IOBASYN,X'08'            SCHEDULE PROCESSING COMPLETION
APPM1B5  B     APPRVBYP                 SCHEDULE ASYNCH ROUTINE  Y02072
APPN3B21 EQU   *                        BEGIN TO SET CB22 TO CYL Y02072
APPMRKS  CH    R9,RKSWORK
         BNE   APPN3B2
         B     APPM1B2
RKSWORK  DC    AL2(APPCEN14-APPCENDT)
APPRVXCP SR    R12,R12
         IC    R12,IOBDADAD
         SLL   R12,4
         L     R3,RQEDEB                RESTORE DEB POINTER      Y02072
         LA    R12,32(R3,R12)
         MVC   IOBDADAD+1(2),4(R12)           MOVE IN BB
         XC    IOBFLAG2(3),IOBFLAG2                               15924
         XC    IOBCSW(9),IOBCSW                                   15924
         XC    IOBERRCT(2),IOBERRCT                               15924
         NI    IOBFLAG1,X'C2'                                     15924
         B     EXCP
         SPACE 2
*              ABNORMAL END CP15,   APPENDAGE CODE 14,         CHART M1
APPM1J2  TM    IOBECBAD,PERRMASK        WAS ABEND DUE TO PERM ERROR
         BC    PERRNO,APPRVNOR          NO   CONTINUE, NORMAL IOS
         B     APPM1B3                  YES  M1B3
         SPACE 2
HW       EQU   2                        LENGTH OF A HALFWORD     A48560
SIX      EQU   6                        LAST HALF WORD OFFSET IN A48560
*                                       CCW                      A48560
HALF0    DC    X'0000'                  HALF WORD 0              A48560
DCDL     DC    X'80000008'              DC,COUNT=8               A48560
RESTORE  DC    X'70',AL3(1)             CB17+4                   A44835
INVAPPCD DC    H'0'                PROG CHK FOR BAD APP CODE   @ZA26522
TWOFOUR  DC    X'0018'             MAX VALUE FOR APP CODE      @ZA26522
*                                       (CB17+4)                 S20201
KEY0     EQU   HALF0                    STORAGE PROTECT KEY 0    Y02072
         EJECT
*                        ADDRESS OF COMMUNICATION VECTOR TABLE
CVTPTR   EQU   16
*
MODID    DC    C'IGG019IO'              MODULE NAME            @ZA26522
DATE     DC    CL8'&SYSDATE'            FIX DATE               @ZA26522
FIX      DC    C' OZ26522'              LATEST FIX             @ZA26522
PATCH    DC    XL((*-IGG019IO)/20)'00'  ZEROED PATCH AREA        Y02072
*
*                             RETURN TO IOS VECTOR TABLE
APPRV    DSECT
APPRVNOR DS    F         NORMAL
APPRVSKP DS    F         SKIP POST
EXCP     DS    F      EXCP
APPRVBYP DS    F         BYPASS
IHAPART2 DS    0D                       PART 2 VECTOR TABLE
*        ROUTINE FOR          CODE      CEND COMPLETION OF
APPM67CE DS    CL6            7         CP1 OR CP2, WRITE KN
APPN7B2  DS    CL6            9,23      CP10AW
APPN8B2  DS    CL6      10         CP14 PART 2
APPM4A2  DS    CL6            12        CP14W - SETUPS 1, 2, OR 5
APPM5A2  DS    CL6            13        CP14W - SET UPS 3, 4, OR 6
APPM2B2  DS    CL6            15        CP16 - SITUATION 2
APPM3B2  DS    CL6            16        CP16 - SITUATION 3
APPM17   DS    CL6            17        CP14W- PRIME ENTRY ONLY     
APPN9A2  DS    CL6            19        CP17W                       
*        ROUTINE FOR          CODE     ABEND COMPLETION OF
APPM67AE DS    CL6            7         CP1 OR CP2, WRITE KN
APPJ3B2  DS    CL6            9,23      CP10AW
APPN3C2  DS    CL6       10       CP14 PART 2
APPJ5B2  DS    CL6            12        CP14W -SETUPS 1, 2, OR 5
APPJ6B2  DS    CL6            13        CP14W -SETUPS 3, 4, OR 6
APPM2H2  DS    CL6            15,16     CP16
APPAB17  DS    CL6            17        CP14W- PRIME ENTRY ONLY     
APPJ7B2  DS    CL6            19        CP17W                       
APPN7A3  DS    CL4            CONTINUATION OF ROUTINES BEGUN IN
APPN7B4  DS    CL4                 PART 1
*        ROUTINE FOR          CODE      CEND COMPLETION OF
APPABA2  DS    CL6            0,1       CP4/CP5
APPADB2  DS    CL6            2         CP7W
APPAAB2  DS    CL6            3         CP1 OR CP2, READ AND UPDATE
APPACA2  DS    CL6            5         CP6W
APPAHB2  DS    CL6            6         CP4/CP5W, WRITE CHECK
*        ROUTINE FOR          CODE     ABEND COMPLETION OF
APPABD2  DS    CL6            0,1       CP4/CP5W
APPAIB2  DS    CL6            2         CP7W
APPAAA2  DS    CL6            3         CP1 OR CP2, READ AND UPDATE
APPACE2  DS    CL6            5         CP6W
APPAHD2  DS    CL6            6         CP4/CP5W, WRITE CHECK
CVT      DSECT
         DS    F         COMMUNICATION VECTOR TABLE EXIT EFFECTOR
CVTEXEF  DS    F          USED WITH REG 13 TO SCHED ASYNC ROUTINES
         EJECT
RQE      IECDRQE ,                      RQE                      Y02072
         EJECT
*        WRITE KEY NEW CHANNEL PROGRAM REFERENCES (WRITE CHECK)
IHAWKNCP IGGWKNCP  OPTCD=VW                                      S20201
*              VARIABLE CPS 12A,12B,123W FOLLOW
CP12A    DS    0D                                                S20201
         IGGCP12A OPTCD=V                                        S20201
CP12B    DSECT
         IGGCP12B OPTCD=V                                        S20201
CP123    DSECT
         IGGCP123 OPTCD=V                                        S20201
CCWCD3   DSECT                          CCW CD3 DSECT           YM03024
CCWOPCD  DS    XL1                      COMMAND CODE            YM03024
CCWADDR  DS    AL3                      DATA ADDRESS            YM03024
CCWFLAGS DS    XL1                      FLAGS                   YM03024
         DS    XL1                      UNUSED                  YM03024
CCWDL    DS    XL2                      BYTE COUNT              YM03024
         EJECT
*              DATA EVENT CONTROL BLOCK
IHADECB  DSECT
         DS    0F
DECBECB  DS    CL4                      EVENT CONTROL BLOCK (ECB)
DECBTYP1 DS    BL1                      TYPE B6 - 1 IF LENGTH IS S
*                                            B7 - 1 IF AREA IS S
DECBTYP2 DS    BL1                           B0 - 1 IF READ K
*                                            B1 - 1 IF READ KX
*                                            B2 - 1 IF READ KU
*                                            B4 - 1 IF WRITE K
*                                            B5 - 1 IF WRITE KN
DECBLGTH DS    CL2                      LENGTH OF BLOCK
DECBDCBA DS    A                        POINTER TO DCB
DECBAREA DS    A                        ADDRESS OF AREA
DECBLOGR DS    A                        POINTER TO LOGICAL RECORD
DECBKEY  DS    A                        POINTER TO KEY
DECBEXC1 DS    BL1                      EXCPTN CD B0-RECORD NOT FOUND
*                                                 B1-RECORD LGTH CHK
*                                                 B2-NO SPACE
*                                                 B3-INVALID REQUEST
*                                                 B4-UNCORRECTABLE IO
*                                                 B5-UNREACHABLE BLOCK
*                                                 B6-OVERFLOW RECORD
*                                                 B7-DUPLICATE
DECBEXC2 DS    BL1                                B7-READ KU
         EJECT
         DCBD  DSORG=(IS)
         EJECT
IHAIOB   IGGIOBD
         EJECT
IHADCW   IGGBISAM  OPTCD=V                                       S20201
         EJECT
IHADEB   IGGDEBD
         END
