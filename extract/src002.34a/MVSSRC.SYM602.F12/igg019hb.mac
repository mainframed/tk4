         TITLE 'IGG019HB - GET MODULE'
IGG019HB CSECT
*          RELEASE OS/VS2-02 CHANGES                             Y02072
*D                                                               Y02072
*                                                               YM03876
*                                                               YM05395
*                                                               YM05971
*                                                               YM06516
*                                                               YM07002
*              OS/VS2 RELEASE 030 CHANGES
* A294500                                                       OZ05912
* A138220,C149904                                               OZ05933
*A103000                                                       @ZA07607
*
*          RELEASE 21 DELETIONS                                       *
*0693                                                            A39794
*0693117200,124200,125000,126600,130600,131200,146200,175800,    S21045
*0693199400,289200                                               S21045
*0693                                                            A36373
*    149400-149760                                               A48519
*A138300-138340,141500-141520,C144800                           SA66297
*                                                                     *
* STATUS CHANGE LEVEL 012
*
*FUNCTION/OPERATION- THIS MODULE CONTAINS ROUTINES FOR THE SETL B(D), *
*   ESETL, PUTX, AND RELSE MACROS AS WELL AS GET. IT ALSO CONTAINS    *
*   SUBROUTINES USED BY THESE MACROS AND USED AS EXTERNAL ROUTINES BY *
*   SETL K(D), SETL I(D), AND CLOSE. AT THE BEGINNING OF THE GET      *
*   MODULE IS A VECTOR TABLE OF UNRELOCATED ADDRESSES CONTAINING THE  *
*   ENTRY POINTS TO THE VARIOUS MACRO ROUTINES AND SUBROUTINES. THIS  *
*   TABLE PROVIDES ACCESS TO THE ROUTINES BY EACH OTHER AND BY OTHER  *
*   MODULES. THE PUTX AND RELSE ADDRESSES ARE IN BRANCH INSTRUCTIONS  *
*   BECAUSE OF THE MACRO EXPANSION METHOD OF OBTAINING ENTRY POINTS   *
*   FOR THESE MACROS. EACH ROUTINE AND SUBROUTINE IS DISCUSSED        *
*   INDIVIDUALLY.                                                     *
*                                                                     *
*   GET - IS THE CENTRAL MACRO OF SCAN MODE. THE OBJECT OF THE GET    *
*   ROUTINE IS TO GIVE THE USER ACCESS TO THE NEXT LOGICAL RECORD.    *
*   THIS IS ACCOMPLISHED BY UPDATING THE POINTER 'W1CBF' (BY MEANS OF *
*   THE END OF BUFFER ROUTINE WHEN NECESSARY) AND MOVING THE NEW RCD  *
*   TO THE USER SPECIFIED AREA (MOVE MODE) OR POINTING TO THE NEW RCD *
*   IN REGISTER 1 (LOCATE MODE). BEFORE RETURNING A RECORD TO THE USER*
*   A CHECK FOR DELETED OR PADDING RECORDS IS MADE, BOTH TYPES BEING  *
*   BYPASSED. GET ALSO CONTROLS READ AND WRITE SCHEDULING. IF A READ  *
*   OPERATION HAS COMPLETED SINCE THE LAST GET OR THE LAST ATTEMPT AT *
*   INPUT SCHEDULING WAS UNSUCCESSFUL, THE GET ROUTINE ATTEMPTS TO    *
*   INITIATE ANOTHER READ USING THE SCHEDULE SUBROUTINE. EACH TIME    *
*   CONTROL GOES TO END OF BUFFER,IF AT LEAST HALF OF THE BUFFERS ARE *
*   WAITING TO BE WRITTEN, A WRITE IS INITIATED. THE GET ROUTINE ALSO *
*   CHECKS WHETHER I/O ERRORS HAVE BEEN DETECTED AND SENDS CONTROL TO *
*   THE USERS SYNCHRONOUS ERROR ADDRESS BY MEANS OF THE EINFO SUB-    *
*   ROUTINE.                                                          *
*                                                                     *
*                                                                     *
*   PUTX - THE PUTX MACRO ROUTINE SETS AN INDICATOR IN THE CHANNEL    *
*   PROGRAM ASSOCIATED WITH THE BUFFER TO BE WRITTEN. THIS INDICATOR  *
*   IS INTEROGATED BY THE END OF BUFFER ROUTINE.                      *
*                                                                     *
*                                                                     *
*   RELSE - THE FUNCTION OF THIS MACRO IS TO BYPASS THE REMAINING     *
*   LOGICAL RECORDS OF THE CURRENT BLOCK. THIS IS ACCOMPLISED BY USING*
*   THE END OF BUFFER ROUTINE. NO ACTION IS TAKEN IF THERE HAS BEEN NO*
*   INTERCEDING GET SINCE THE LAST RELSE OR SETL, NOR IF THE MOST     *
*   RECENT GET OBTAINED THE LAST RECORD OF A BLOCK. RELSE ALSO CHECKS *
*   IF ANY WRITE ERRORS OCCURRED ON THE LAST WRITE,AND IF SO INFORMS  *
*   THE USER BY MEANS OF THE ERROR SUBROUTINE(EINFO).                 *
*                                                                     *
*                                                                     *
*   SETL B(D) - THE PURPOSE OF THE MACRO IS TO ENABLE THE USER TO     *
*   START TO SEQUENTIALLY RETRIEVE HIS RECORDS AT THE FIRST RECORD    *
*   OF HIS DATA SET. IF SETL BD IS SPECIFIED, ONLY THE DATA PORTION   *
*   OF THE UNBLOCKED RECORDS ARE RETRIEVED. THE SETL B MACRO CAN GAIN *
*   CONTROL DIRECTLY THROUGH THE USER (IF HE ISSUES THE MACRO), OR    *
*   THROUGH THE GET MACRO. IF NO SETL IS GIVEN THEN A SETL B IS       *
*   ASSUMED. THE ROUTINE WILL INFORM THE USER IF THERE WERE ANY       *
*   PREVIOUS WRITE ERRORS, SET THE CHANNEL PROGRAMS TO READ COMMANDS  *
*   AND SCHEDULE  A READ WHICH WILL MAKE THE FIRST RECORDS AVAILABLE  *
*   TO THE USER.                                                      *
*                                                                     *
*                                                                     *
*   ESETL - THE ESETL MACRO INSTRUCTION ENDS THE SCANNING OF AN       *
*   INDEXED SEQUENTIAL DATA SET. IF AT THE TIME OF THE ESETL, THERE   *
*   WERE RECORDS ON THE PUTX QUEUE (WAITING TO BE WRITTEN), A WRITE   *
*   IS INITIATED. IF THERE WERE WRITE ERRORS, THE ROUTINE SEND CONTROL*
*   TO THE USER'S SYNCHRONOUS ERROR ADDRESS BY MEANS OF THE EINFO     *
*   ROUTINE. THE ESETL ALSO MOVES ANY BUFFERS REMAINING ON ANY OTHER  *
*   QUEUE TO THE FREE QUEUE. IF A READ WAS IN PROGRESS, IT WAITS FOR  *
*   ITS COMPLETION AND MOVES READ QUEUE BUFFERS TO THE FREE QUEUE. THE*
*   ESETL REINITIALIZES CERTAIN WORKAREA FIELDS BEFORE RETURNING TO   *
*   THE USER.                                                         *
*                                                                     *
*   SCHEDULE  - THIS ROUTINE SETS UP CHANNEL PROGRAMS FOR READING AND *
*    INITIATES THE READ. IT DETERMINES WHETHER THE NEXT RECORD TO BE  *
*    READ IS A PRIME DATA OR OVERFLOW RECORD, WHETHER AN EXTENT OR A  *
*    CYLINDER BOUNDARY IS BEING CROSSED, AND WHETHER THE NUMBER OF    *
*    FREE BUFFERS SATISFIES THE CONDITIONS FOR INITIATING A READ, AND *
*    PROCEEDS ACCORDINGLY. IT ALSO SCHEDULES THE READING OF TRACK     *
*    INDEX ENTRIES WHEN A TRACK BOUNDARY IS CROSSED. THE SCHEDULING   *
*    BIT (W1OSBIT2, BIT 5) IS ON AT THE EXIT FROM THIS ROUTINE IF NO  *
*    READ COULD BE SCHEDULED.                                         *
*                                                                     *
*   QUEUE  - THIS ROUTINE IS USED TO MOVE BUFFERS FROM QUEUE TO QUEUE.*
*    ON ENTRY TO THIS ROUTINE R5 CONTAINS THE NUMBER OF BUFFERS TO BE *
*    MOVED(0-255), R3 CONTAINS THE ADDRESS OF THE 'TO' QUEUE AND R4   *
*    CONTAINS THE ADDRESS OF THE'FROM' Q. ALL QUEUES ARE CONSIDERED TO*
*    HAVE AN R (RESIDUE) FIELD ALTHOUGH ONLY THE READ Q CAN HAVE AN   *
*    R NOT EQUAL TO 0. THE FORMAT OF A QUEUE IS - 1ST WORD, ADDRESS OF*
*    1ST CHANNEL PROGRAM ON Q, 2ND WORD, ADDRESS OF LAST CP ON Q, 3RD *
*    WORD BYTES 0-1, NUMBER ON UNUSED CP'S ON Q, BYTES 2-3, NUMBER(C) *
*    OF USED CP'S ON Q. INTERMEDIATE BUFFERS ARE CHAINED TOGETHER BY  *
*    MEANS OF THE TIC ADDRESS IN CN5 OF THE CORRESPONDING CP.         *
*                                                                     *
*                                                                     *
*   END OF BUFFER - THE PURPOSE OF THE END OF BUFFER ROUTINE IS TO    *
*   ADVANCE TO THE NEXT BUFFER IF THE CURRENT BUFFER HAS ALREADY      *
*   BEEN PROCESSED. IF THE CURRENT USER BUFFER WAS MARKED FOR WRITING *
*   (PUTXED), THIS BUFFER IS MOVED TO THE PUTX QUEUE. IF THERE ARE    *
*   N/2 BUFFERS ON THE PUTX QUEUE NOW, THE ROUTINE INITIATES A WRITE. *
*   IF AT THIS TIME THERE STILL IS AT LEAST ONE BUFFER ON THE USER Q, *
*   THE ROUTINE ADJUSTS THE CURRENT AND END OF BUFFER POINTERS (W1CBF *
*   AND W1EOB,RESPECTIVELY) AND EXITS. IF NO USER QUEUE BUFFERS WERE  *
*   PRESENT, END OF BUFFER MOVES READ QUEUE BUFFERS TO THE USER QUEUE,*
*   OR SCHEDULES A READ (TO GET BUFFERS FOR THE READ QUEUE) AND THEN  *
*   MOVES THESE READ QUEUE BUFFERS TO THE USER QUEUE.                 *
*                                                                     *
*                                                                     *
*   SETC4- THE FUNCTION OF THIS ROUTINE IS TO PREPARE ALL THE WRITE   *
*   QUEUE SETS FOR OUTPUT. A SET CAN CONSIST OF ONE (IN THE CASE OF   *
*   OVERFLOW RECORDS) OR MANY BUFFERS (PRIME DATA RECORDS FALLING ON  *
*   THE SAME TRACK). THE LAST RECORD ON A PRIME DATA TRACK ALWAYS     *
*   DESIGNATES THE END OF A SET. THE COMMAND CODES OF ALL THE CHANNEL *
*   PROGRAMS ARE SET FOR WRITING. WHEN THE END OF THE WRITE Q HAS BEEN*
*   REACHED, THE SEEK ADDRESS IN THE IOB (W1ODAD), IS SET EQUAL TO    *
*   THE MBBCCHHR OF THE FIRST CHANNEL PROGRAM OF THE FIRST SET. THE   *
*   ACTUAL WRITE COMMAND (EXCP) IS GIVEN IN THE MAINLINE CODING.      *
*                                                                     *
*                                                                     *
*   CHECK - THIS ROUTINE IS ENTERED FOR EACH LOGICAL RECORD TO SEE IF *
*   THE BUFFER WAS READ WITHOUT ERROR. IF AN ERROR DID OCCUR CHECK    *
*   USES EINFO TO SET THE REGISTERS AND GIVE CONTROL TO THE USER'S    *
*   SYNAD ROUTINE. CHECK SETS THE EXCD CODE TO INDICATE UNREADABLE OR *
*   UNREACHABLE.                                                      *
*                                                                     *
*   EINFO - THIS ROUTINE SERVES 2 PURPOSES- 1- WHEN A WRITE ERROR HAS *
*   BEEN DISCOVERED, EINFO IS ENTERED AT 'SISSGF1', AND IT DETERMINES *
*   WHICH BUFFER(S) ON THE WRITE Q IS(ARE) IN ERROR AND SETS THE EXCD *
*   CODE UNWRITEABLE OR UNREACHABLE AS INDICATED BY THE FLAG BIT OF   *
*   THE CHANNEL PROGRAM ASSOCIATED WITH THE BAD BUFFER. 2-FROM        *
*   'SISSGG4' THE ROUTINE IS ALSO USED BY CHECK TO SET REGISTERS TO   *
*   GIVE ERROR INFORMATION TO THE USER.                               *
*                                                                     *
*ENTRY POINTS- THE ENTRY POINTS AND CALLING SEQUENCES FOR THE MACROS  *
*   CONTAINED IN THE MODULE ARE-
*        'SISCTSA' -GET-       LA 1,DCB (LOCATE)  LA 0,TOAREA  (MOVE) *
*                              L  15,48(0,1)      LA 1,DCB            *
*                              BALR 14,15         L  15,48(0,1)       *
*                                                 BALR 14,15          *
*        'SISSAH1' -PUTX-      LA 1,DCB                               *
*                              L 15,48(0,15)                          *
*                              BAL 14,4(0,15)                         *
*        'SISCTRE' -RELSE-     LA 1,DCB                               *
*                              L 15,48(0,15)                          *
*                              BAL 14,8(0,15)                         *
*        'SISCTBS' -SETL B(D)- LA  1,DCB                              *
*                              L   15,76(0,1)                         *
*                              BALR 14,15                             *
*        'SISCTES' -ESETL-     LA  1,DCB                              *
*                              L   15,84(0,1)                         *
*                              BALR 14,15                             *
*                                                                     *
*INPUT- REGISTER 1, DCB ADDRESS, REGISTER 14, RETURN ADDRESS, REGISTER*
*   13, SAVE AREA ADDRESS, REGISTER 15, ENTRY POINT. FOR SETL B(D)    *
*   AND THE MOVE MODE OF GET,THE CONTENTS OF REGISTER 0 ARE ALSO      *
*   MEANINGFUL. BYTE 0 IS 10 FOR SETL B, 18 FOR SETL BD. THE ADDRESS  *
*   OF THE USER WORK AREA IS IN REGISTER 0 FOR THE MOVE MODE OF GET.  *
*                                                                     *
*OUTPUT- SAME AS INPUT FOR NORMAL EXIT EXCEPT-                        *
*   GET, LOCATE MODE, REGISTER 1 POINTS TO THE DATA PORTION OF THE    *
*   NEXT SEQUENTIAL LOGICAL RECORD (REGISTER 0 POINTS TO THE KEY      *
*   PORTION OF THIS RECORD IF THE RECORDS ARE UNBLOCKED AND KEY AND   *
*   DATA HAVE BEEN SPECIFIED IN THE LATEST SETL). IN THE MOVE MODE OF *
*   GET THE NEXT LOGICAL RECORD HAS BEEN MOVED TO THE USER WORK AREA. *
*                                                                     *
*   OUTPUT FOR ERROR EXIT FOR READ OR WRITE ERROR, REGISTER 0 POINTS  *
*   TO I-O STATUS INDICATORS, REGISTER 1 POINTS TO THE BUFFER IN ERROR*
*   REGISTER 15 CONTAINS THE USER SYNAD ROUTINE ADDRESS, AND PROPER   *
*   DCBEXCD BIT IS SET. FOR SETL ERRORS ONLY REGISTER 15 AND THE EXCD *
*   BITS ARE SET.
*                                                                     *
*EXTERNAL ROUTINES- N/A                                               *
*                                                                     *
*EXITS-NORMAL                                                         *
*        'GETOUT' RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION AFTER THE*
*   GET MACRO EXPANSION.                                              *
*        'PUTXOUT' RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION AFTER   *
*   THE PUTX MACRO EXPANSION.                                         *
*        'SISRED2' RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION AFTER   *
*   THE RELSE MACRO EXPANSION.                                        *
*        'SISBSH5' RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION AFTER   *
*   THE SETL B(D) MACRO EXPANSION.                                    *
*        'SISESG1' RETURNS TO THE NEXT SEQUENTIAL INSTRUCTION AFTER   *
*   THE ESETL MACRO EXPANSION.                                        *
*        'SISSEOUT' RETURNS TO THE USER SPECIFIED END OF DATA ADDRESS.*
*                                                                     *
*   ERROR EXITS TO USER SYNCHRONOUS ERROR ROUTINE-                    *
*        'SISBSE1', ERROR IN SPECIFYING SETL B(D).                    *
*        'ERROUT', READ OR WRITE ERROR.                               *
*   ABEND EXITS IF NO SYNAD ROUTINE SPECIFIED                         *
*        'SISBSAB', ERROR IN SPECIFYING SETL B(D).                    *
*        'SISSGAB', READ OR WRITE ERROR.                              *
*   ABEND EXIT IF NO END OF DATA ADDRESS SPECIFIED IN THE DCB         *
*        'SISSEABE', END OF DATA SET                                  *
*                                                                     *
*TABLES AND WORKAREAS- DATA EXTENT BLOCK(DEB) DESCRIBED BY SISDEB     *
*   DSECT, WORKAREA DESCRIBED BY SISWORK1 DSECT, DATA CONTROL BLOCK   *
*   DESCRIBED BY IHADCB DSECT.                                        *
*                                                                     *
*ATTRIBUTES- REENTRANT, READ ONLY.                                    *
*                                                                     *
*NOTES-REGISTER USAGE IS CONSISTENT IN ALL SCAN MODE MACRO TIME       *
*   MODULES.  IN THIS MODULE R15 IS THE BASE REGISTER FOR GET, PUTX,  *
*   RELSE, SETL B, AND ESETL, R12 FOR END OF BUFFER, R11 FOR SCHEDULE,*
*   SETC4, CHECK, AND EINFO, R10 FOR QUEUE.  R9 IS THE RETURN REGISTER*
*   FROM SUBROUTINES.  R3, R4, AND R5 ARE USED AS PARAMETER REGISTERS *
*   FOR THE QUEUE ROUTINE. R6,R7,AND R8 ARE ALWAYS WORK REGISTERS AND *
*   ANY REGISTER LOWER THAN THE BASE OF THE ROUTINE IS USUALLY        *
*   AVAILABLE AS A WORK REGISTER.                                     *
         EJECT
         USING IHADCB,R1                BASE FOR DCB
         USING SISDEB,R8                BASE FOR DEB
         USING SISCP22,R3               BASE FOR REFERENCES TO
*                                       CP22A OR CP22B
         USING SISWORK1,R2              BASE FOR WORKAREA
         USING *,R15
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
K3       EQU   3                        CONSTANT                 S20201
L4       EQU   4                        LENGTH                   S20201
K16      EQU   16                       CONSTANT                 S20201
L2       EQU   2                        CONSTANT                 S20201
K1       EQU   1                        CONSTANT                 S20201
L3       EQU   3                        LENGTH                   S20201
THIRTY   EQU   30                       LIMIT WRITE CP'S
         SPACE 3
*********************************************************************
*****                             VECTOR TABLE
*********************************************************************
         SPACE 2
*                                       ROUTINE             OFFSET
SISCTSA  B     SISSAB1                  GET                  0
         B     SISSAH1                  PUTX                 4
         B     SISCTRE                  RELSE                8
         DC    A(SISCTSGE-SISCTSA)      EINFO(ERROR)        12
         DC    A(SISCTSD-SISCTSA)       QUEUE               16
         DC    A(SISCTSB-SISCTSA)       SCHEDULE            20
         DC    A(SISCTSF-SISCTSA)       SETC4               24
         DC    A(SISCTSE-SISCTSA)       END OF BUFFER       28
         DC    A(SISCTSGC-SISCTSA)      CHECK               32
         DC    A(SISCTBS-SISCTSA)       SETL B(D)           36
         DC    A(SISCTES-SISCTSA)       ESETL               40
         EJECT
*                                       ***************
*                                       *             *
*                                       *  GET MACRO  *
*                                       *             *
*                                       ***************
*
* TEST FOR WRITE ERRORS
*
SISSAB1  STM   R2,R12,28(R13)           SAVE REGISTERS
         L     R2,DCBWKPT1              SET UP R2 WITH ADDR OF WORKAREA
         SPACE 2
         NIL   W1OSBIT2,ONES-RELSE,    SET OFF BIT FOR RELSE    YM03876X
               REF=W1OSBIT1,WREGS=(R6,R9,R11)                   YM03876
         SPACE 2
         ST    R0,W1TEMPSA             SAVE SO IOS WONT DESTROY
         TM    W1OSBIT2,X'80'           ANY WRITE ERRORS
         BZ    SISSAA2                  NO
*                                       YES, GO TO EINFO TO TELL USER
         L     R11,CTSGE(R15)           PICK UP OFFSET
         AR    R11,R15                  ADD BASE
         BALR  R9,R11                   GO TO EINFO  ROUTINE
         SPACE 1
*
* HAS A SCAN BEEN INITIATED BY A SETL
*
SISSAA2  XC    DCBEXCD1(2),DCBEXCD1    SET EXCD'S TO ZERO
         TM    W1OSBIT1,X'80'           IS SCAN MODE IND ON
         BO    SISSAB3                  YES
*                                       NO, SETL B MUST BE EXECUTED
*
*CHECK FOR NULL DATA SET
*
          CLC   DCBNREC(4),EMPTYCON     IS DATA SET EMPTY        A27355
         BNE   SISSAB2                  NO                       A27355
         LA    R12,SISCTSE              ADDRESABILITY            A27355
         B     SISSEG2                  BRANCH TO END OF FILE    A27355
SISSAB2  OI    W1OSBIT2,X'08'           INDICATE TO SETL B THAT  A27355
*                                       GET                      A27355
*                                       INITIATED SETL
         L     R0,SISSACN2              SET CODE FOR B,KD TYPE OF SETL
         LA    R15,SISCTBS
         LM    R2,R12,28(R13)         RESTORE BEFORE GOING TO SETL
         BR    R15                      SETL WILL RETURN TO SISSAB1
         SPACE 1
*
* UPDATE POINTER TO CURRENT RECORD
*
SISSAB3  L     R6,W1CBF                 UPDATE CURRENT BUFFER LENGTH
         AH    R6,W1CURLEN              WITH LENGTH OF CURRENT LOG REC
         ST    R6,W1CBF
SISSAC3  CLC   W1CBF,W1EOB              ARE WE FINISHED WITH THIS BUF
         BNH   SISSAB31                 NO
*                                       YES, GO TO EOB SUB-ROUTINE
SISSAC31 L     R12,CTSE(0,R15)          PICK UP OFFSET
         AR    R12,R15                  ADD BASE
         BALR  R9,R12
        SPACE 1
*
* IS THIS BUFFER OK
*
SISSAB31 TM    DCBRECFM,X'80'           FIXED RECS
         BO    SISSAB32                 YES
         MVC   W1CURLEN,0(R6)           NO, MOVE LOGICAL RCD LENGTH OF
*                                       CURRENT RCD TO W1CURLEN
SISSAB32 L     R11,CTSGC(R15)           GO TO CHK RTN TO SEE IF
         AR    R11,R15                  THERE HAS BEEN A READ ERROR
         BALR  R9,R11                   OF THE CURRENT BUFFER
*                                       IF SO CHECK GOES TO USER
         SPACE
*
* CHECK FOR DELETED RECORD OR PADDING
*
SISTAB2  TM    DCBOPTCD,X'02'           WAS DELETE OPTION SPECIFIED
         BO    SISTAB3                  YES, SEE IF THIS RCD WAS DELETD
SISTAC2  L     R3,W1US1ST               NO, IS THIS LAST BLOCK
         CLC   CN6,DCBLPDA              DISK ADDR OF CURRENT BUFFER=CN6
         BNE   SISSAD3                  NOT LAST BLOCK
SISTAD2  TM    DCBST,X'02'              YES, IS LAST BLOCK FULL
         BO    SISSAD3                  YES
*                                       NO, TEST FOR PADDING RECORD
SISTAE2  LH    R6,W1CURLEN              R6=BYTE LEN OF CURRENT RECORD
         L     R7,W1CBF                 LRECL IF FIXED, CHAR CNT IF VAR
         AR    R6,R7                    R6=END OF RECORD + 1
SISTAE22 BCTR  R6,0                    SUB  1
         CLI   DCBRECFM,X'80'          IF FIXED FORMAT
         BE    SISSAD3                 DO NOT TEST PADDING
         TM    0(R6),X'FF'              LOOP TESTING ALL BITS FOR 1
         BC    12,SISSAD3              TILL START OF RECORD
SISTAE23 CR    R6,R7                    ARE WE AT END OF RECORD
         BNE   SISTAE22                 NO, LOOP
         B     SISSAC31                 YES, ALL BITS=1, PADDING
         SPACE 2
*  DELETE CHECK
*
SISTAB3  L     R7,W1CBF                 IF REC IS FIXED LENGTH 1ST BYTE
         TM    DCBRECFM,X'80'          IS TESTED FOR ALL ONES, IF
         BO    SISTAB31                 VARIABLE 5TH BYTE IS TESTED
         LA    R7,4(R7)                ADD  4 TO STARTING BYTE
SISTAB31 TM    0(R7),X'FF'              WAS THIS RCD DELETED
         BO    SISSAB3                  YES, GET NEXT RECORD
*                                       NO
         EJECT
*
* WHAT MODE OF GET
*
SISSAD3  L     R3,W1US1ST               CURRENT BUFFER
         TM    DCBMACRF,X'10'           IS IT MOVE MODE
         BO    SISSAD4                  YES
*                                       NO, LOCATE MODE
         MVC   W1REGSAV,W1CBF           SAVE BUFFER ADDRESS TO
*                                       BE RETURNED TO USER
         SPACE
         TM    CN2+4,X'20'              WAS KEY-DATA SPECIFIED
         BZ    SISSAE3                  NO, DATA ONLY
         MVC   W1TEMPSA,CN7+4           YES, KEY ADDR MUST BE SAVED TO
         B     SISSAE3                  RETURN TO USER
         SPACE 1
*
* MOVE ROUTINE
*
SISSAD4  L     R7,W1TEMPSA              USERS AREA ADDRESS
         TM    CN2+4,X'20'              ARE KEY AND DATA READ
         BZ    SISSAD4A                 NO, DATA ONLY
         SR    R6,R6
         IC    R6,DCBKEYLE              YES, MOVE KEY FIRST
         L     R8,CN7+4                 R8 = KEY ADDRESS
         EX    R6,SISSAD43              MOVE KEYLEN+1 CHARACTERS
         AR    R7,R6                    UPDATE TO ADDRESS
SISSAD4A LH    R6,W1CURLEN              R6=NUMBER CHARS TO BE MOVED
         L     R8,W1CBF                 R8= FROM ADDRESS IN CUR BUFFER
SISSAD41 CH    R6,SISSACN1              IS REC OR REMAINDER OF REC
*                                       GREATER THAN 256 BYTES %LIMIT
*                                       OF MOVE INST<
         SPACE
         BNH   SISSAD42                 NO,MOVE LAST %OR ONLY< PORTION
*                                       OF RECORD
         SPACE
         MVC   0(256,R7),0(R8)          MOVE GREATEST AMOUNT POSSIBLE
         SH    R6,SISSACN1              FIND HOW MANY BYTES LEFT
         AH    R7,SISSACN1              UPDATE TO AND FROM ADDRS
         AH    R8,SISSACN1
         B     SISSAD41                 LOOP
SISSAD42 BCTR  R6,0                    SUB 1 FOR WAY MOVE WORKS
         EX    R6,SISSAD43              EXECUTE MOVE OF REMAINING CHARS
         ST    R1,W1REGSAV              STORE R1 SO THAT DCB ADDRESS
*                                       WILL BE RETURNED IN R1
         EJECT
*
* CHECK FOR OVERFLOW, COMPLETED WRITES AND COMPLETED READS
*
         SPACE
SISSAE3  TM    CN2+4,X'40'              IS THIS AN OVERFLOW RD
         BZ    SISSAE31                 NO
         OI    DCBEXCD2,X'10'           YES,INDICATE TO USER
SISSAE31 TM    W1OSBIT1,X'01'          IS IOBO COMPLETE BIT ON
         BZ    SISSAG3                  NO, EITHER STILL IN PROGRESS
*                                       OR TAKEN CARE OF ALREADY
*                                       YES
         TM    W1OSBIT2,X'80'           ANY UNWRITEABLE RCDS
         BO    SISSAG3                  YES, LEAVE THEM FOR NEXT GET
SISSAF3  LA    R3,W1FR1ST               NO, MOVE BUFFERS FROM
         LA    R4,W1WR1ST               WRITE Q TO FREE Q
         LH    R5,W1WRITEC
         L     R10,CTSD(R15)            GO TO QUEUE ROUTINE
         AR    R10,R15
         BALR  R9,R10
         SPACE 2
         NIL   W1OSBIT1,ONES-IOBOC,     SET OFF IOB-O COMPLETE  YM03876X
               REF=W1OSBIT1,WREGS=(R9,R10,R11)   BIT            YM03876
         SPACE 2
SISSAG3  TM    W1OSBIT1,X'02'           IS IOB-I COMPLETE BIT ON
         BO    SISSAH3                  YES, FULL BUFFERS ON READ Q
         TM    W1OSBIT2,X'04'           NO, WAS LAST TRY AT SCHEDULING
*                                       UNSUCCUSSFUL BECAUSE OF LACK
*                                       OF BUFFERS
         BO    SISSAK3                  YES TRY AGAIN
         B     SISSAK4                  NO
SISSAH3  LA    R3,W1US1ST               MOVE BUFFERS FROM
         LA    R4,W1RD1ST               READ Q TO USER Q
         LH    R5,W1READC
         L     R10,CTSD(0,R15)
         AR    R10,R15
         BALR  R9,R10                   GO TO QUEUE ROUTINE
         SPACE 2
         NIL   W1OSBIT1,ONES-IOBIC,     SET OFF COMPLETE IOBI   YM03876X
               REF=W1OSBIT1,WREGS=(R9,R10,R11)   INDICATOR      YM03876
         SPACE 2
SISSAK3  L     R11,CTSB(0,R15)          SCHEDULE
         AR    R11,R15
         BALR  R9,R11
SISSAK4  L     R0,W1TEMPSA             FORMER CONTENTS OR KEY ADDR
         L     R1,W1REGSAV             DCB OR BUFFER ADDR
         LM    R2,R12,28(R13)
GETOUT   BR    R14                      RETURN TO USER
         SPACE
         DS    0F
*                                  ***** CONSTANTS *****
SISSACN2 DC    X'10000000'
SISSACN1 DC    H'256'
         SPACE 1
SISSAD43 MVC   0(1,R7),0(R8)            USED BY EXECUTE INST TO MOVE
*                                       DATA TO USERS AREA
         EJECT
*                                       ***************
*                                       *             *
*                                       * PUTX MACRO  *
*                                       *             *
*                                       ***************
         SPACE 5
SISSAH1  STM   R2,R12,28(R13)           PUTX ENTRY POINT, SAVE REGS
         TM    DCBMACRF+1,X'44'         WAS PUTX SPECIFIED        15407
         BZ    NOPUTX                   NO--TAKE SYNAD,IF ANY     15407
         L     R2,DCBWKPT1
         CLI   W1USERC+1,X'00'          IS A BUFFER ON USER QUEUE 7M265
         BE    PUTXOUT                  NO--EXIT, PREVIOUS GET    7M265
*                                       RESULTED IN SYNAD ENTRY   7M265
         L     R3,W1US1ST               SET R3 TO CURRENT BUFFER CP
         OI    CN2+4,X'80'              SET PUTX FLAG
PUTXOUT  EQU   *                                                  7M265
         LM    R2,R12,28(R13)          RESTORE REGS
         BR    R14                      RETURN TO USER            7M265
NOPUTX   L     R2,PUTXCON               GET ERROR RTN OFFSET      15407
         LA    R15,SISCTBS              SET FOREIGN BASE          15407
         AR    R2,R15                                             15407
         BR    R2                       BRANCH TO ERROR EXIT      15407
PUTXCON  DC    A(SISBSB1-SISCTBS)       OFFSET TO ERROR RTN       15407
         EJECT
SISCTRE  EQU   *
*                                     * *************
*                                     *             *
*                                     * RELSE MACRO *
*                                     *             *
*                                     ***************
         SPACE 3
SISREA2  STM   R2,R12,28(R13)           SAVE REGS  2-12 IN R13
         L     R2,DCBWKPT1              SET R2 WITH WKPT1 ADDRESS
         XC    DCBEXCD1(2),DCBEXCD1    SET EXCD'S TO ZERO
SISREA3  TM    W1OSBIT2,X'80'           WRITE Q ERROR
         BZ    SISREB3                  BRANCH IF NO
SISREA4  L     R11,CTSGE(0,R15)         YES, GO TO EINFO TO TELL USER
         AR    R11,R15
         BALR  R9,R11
SISREB3  TM    W1OSBIT2,X'02'           IS RELSE BIT ON
*                                       (ON IF NO GET FOLLOWING A SETL
*                                         OR LAST RELSE)
         BO    SISREC2                  YES, TAKE NO ACTION
         SPACE 2
         OIL   W1OSBIT2,RELSE,          SET RELEASE BIT ON      YM03876X
               REF=W1OSBIT1,WREGS=(R6,R7,R9)                    YM03876
         SPACE 2
         L     R6,W1CBF                 IS CURRENT RCD LAST IN BUFFER
         AH    R6,W1CURLEN
         L     R7,W1EOB
         CR    R7,R6
         BL    SISREC2                  YES, TAKE NO ACTION
*                                       NO
SISREB2  L     R12,CTSE(0,R15)         GO TO EOB SUBROUTINE
         AR    R12,R15                  TO BYPASS REMAINING RCDS IN BLK
         BALR  R9,R12
         L     R3,W1CBF                 RESET CBF SO THAT SUBSEQUENT
         SH    R3,W1CURLEN              GET WILL RETURN 1ST RCD IN
         ST    R3,W1CBF                 BLOCK TO USER
SISREC2  LM    R2,R12,28(R13)           RESTORE REGISTERS
SISRED2  BR    R14                      RETURN TO USER
         EJECT
*                                     ****************
*                                     *              *
*                                     * SETL B MACRO *
*                                     *              *
*                                     ****************
         SPACE
         SPACE
         USING *,R15
SISCTBS  B     SISBSA2
         SPACE 2
*                                  ***** CONSTANTS *****
EMPTYCON DC    F'0'
ONECON   DC    F'1'
         SPACE 3
SISBSA2  STM   R2,R12,28(R13)           SAVE REGS. 2-12
         L     R2,DCBWKPT1              LOAD R2 WITH WORK AREA ADDRESS
         ST    R0,W1REGSAV              SAVE TYPE OF SETL
         XC    DCBEXCD1(2),DCBEXCD1    SET EXCD'S TO ZERO
         TM    W1DCBFA,X'80'           TEST FOR DISP=SHR         A35340
         BZ    CNTINU                  BR IF NOT TO CONTINUE RTN A35340
         SVC   54                      IF SHR, ISSUE SVC 54 TO   A35340
*                                       REFRESH                  A35340
*                                      DCB FIELDS
CNTINU   EQU   *                                                 A35340
         CLC   DCBNREC(4),EMPTYCON      CHECK FOR NULL DATA SET  A27355
         BE    SISBSH4                  BRANCH ON NULL           A27355
SISBSA3  TM    W1ECBO,X'40'             IS WRITE IN PROGRESS
         BZ    SISBSA4                  YES
*                                       NO
SISBSB3  CLI   W1WRITEC+1,X'00'        WRITE Q EMPTY
         BNE   SISBSB4                  NO
SISBSB2  TM    W1OSBIT1,X'80'           TEST SCAN MODE INDICATOR
         BZ    SISBSC2                  OFF,NOT IN SCAN MODE
*                                       ALREADY ON
SISBSB1  OI    DCBEXCD1,X'10'           SET ON INVAL REQUEST BIT
         TM    DCBSYNAD+3,X'01'         WAS A SYNAD ADDRESS SPECIFIED
         BO    SISBSF1                  NO
SISBSC1  L     R15,DCBSYNAD             LOAD USER'S SYNAD ADDR. TO R15
         LA    R0,W1IOBI                LOAD IOB ADDR          @ZA07607
SISBSD1  LM    R2,R12,28(R13)           RESTORE REGS 2-12
SISBSE1  BR    R15                      TAKE SYNAD EXIT
         SPACE 2
*                                       GIVE 031 ABEND, NO       Y02072
SISBSF1  ABEND X'031',DUMP,,SYSTEM      SYNAD PROVIDED           Y02072
         SPACE 2
*  SET UP CHANNEL PROGRAMS
         SPACE 2
SISBSC2  EQU   *
         L     R3,W1FR1ST               GET FIRST CP1 ON FREE Q
         LA    R8,8                     SET UP FOR
         SR    R9,R9                    CP 22B
         TM    DCBRECFM,X'10'           BLOCKED RECORDS
         BO    SISBSD2                  YES, INITIALIZE CP22B IN CASE
*                                       A PREVIOUS OPERATION HAS TAKEN
*                                       PLACE
SISBSC3  TM    W1REGSAV,X'08'           UNBLOCKED KEY AND DATA (22A)
         BO    SISBSD2                  DATA ONLY REQUESTED
         SPACE
*                        SETL OF KEY AND DATA TYPE HAS BEEN REQUESTED
*                        IF BUFFER SIZE IS LARGE ENOUGH TO ALLOW FOR
*                        THIS TYPE, OPEN SETS ON  OSBIT3, BYTE 0
         SPACE
         LA    R8,14                   CHAN PROGRAMS
         LA    R9,32                   WILL BE CP22A
         TM    W1OSBIT3,X'80'           IS THERE ROOM FOR KEY AND DATA
         BZ    SISBSB1                  NO
         BO    SISBSD2B
         SPACE 2
*              INITIALIZE ALL CN3 ADDR FOR CP22B
SISBSD2  LA    R7,CN4
SISBSD2A ST    R7,CN3
         STC   R8,CN3                  STORE OP CODE
         STC   R9,CN2+4                SET FLAG BIT INDICATORS
         CLC   CN5+1(3),EMPTYCON        LAST CP ON QUEUE
         BE    SISBSE3                  YES
         L     R3,CN5                   NO, GET NEXT CP ON Q
         TM    DCBRECFM,X'10'           BLOCKED RECORDS
         BO    SISBSD2                  YES, CP 22B
         TM    W1REGSAV,X'08'          DATA ONLY TO BE READ
         BO    SISBSD2                 YES
SISBSD2B L     R7,CN7+4                CN3 ADDR FOR CP22A
         B     SISBSD2A
         SPACE
         SPACE
* FIND DISK ADDRESS OF START OF DATA SET
         SPACE
SISBSE3  L     R8,DCBDEBAD              LOAD R8 WITH DEB ADDRESS
         MVI   W1LPDR,X'01'            M=1
         MVC   W1LPDR+K3(L4),DEBSTRCC+K16 CCHH FROM DEB TO LPDR  S20201
         OC    W1LPDR+6(1),DCBFIRSH+1   PUT FIRST DATA TRK INTO LPDR
SISBSF3  IC    R4,DCBFIRSH+2            R OF FIRSH, ONE IS SUBTRACTED
         BCTR  R4,0                    BECAUSE SCHEDULE ADDS 1 TO R OF
*                                       LPDR TO GET RECORD TO BE READ
         STC   R4,W1LR                  STORE'NEW' R IN R OF LPDR
SISBSG3  OI    W1OSBIT1,X'90'    SET ON SCAN AND READ TRK INDEX BITS
SISBSG1  NI    W1OSBIT1,X'DF'           SET OVERFLOW MODE INDIC OFF
         OI    W1OSBIT2,X'20'           SET CYLINDER INDICATOR ON
         MVC   W1WCNXDM(4),W1LPDR+3    MOVE CCHH FOR READING TRK IX
         OC    W1WCNXDM+3(1),DCBFIRSH+3 REDUCE TO A
         XC    W1WCNXDM+3(1),DCBFIRSH+3     CYL BOUNDRY
         MVI   W1WCNXDM+4,X'01'        R=1
         IC    R12,W1ICNOT              SAVE ICNOT
         MVI   W1ICNOT,X'01'            SET TO 1 TO FILL 1 BUFFER
         CLI   DCBFIRSH+2,X'01'         IS THIS A SHARED TRACK
         BE    SISBSH1                  NO
         OI    W1OSBIT2,X'10'           INDICATE SHARED TRACK
         SPACE 2
*  READ 1ST RECORD AND TRACK INDEX ENTRIES
         SPACE 2
SISBSH1  L     R11,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R11                                        S21045
         L     R11,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R11                                        S21045
         L     R11,DEBGET               LOAD GET RTN ADDR        S21045
         DROP  R11                                               S21045
         A     R11,CTSB(R11)
         BALR  R9,R11                   GO TO SCHEDULE ROUTINE
         STC   R12,W1ICNOT              REPLACE ICNOT
         TM    W1ECBI,X'40'             IS A WAIT NECESSARY
         BO    SISBSJ2                  NO
SISBSJ1  LR    R10,R1                   YES, WAIT FOR READ TO COMPLETE
         LA    R1,W1ECBI
         LR    R3,R15                   SAVE R15
         WAIT  ECB=(1)
         LR    R15,R3                   RESTORE R15
         LR    R1,R10                   RESTORE R1
         SPACE 3
SISBSJ2  MVI   W1EOB,X'00'              ZERO HIGH ORDER W1EOB
         MVC   W1CBF,W1EOB              TO FORCE ENTRY TO EOB ROUTINE
SISBSH3  TM    W1OSBIT2,X'08'           WAS SETL B ENTERED FROM GET
         BO    SISBSH3A                 YES, PREPARE TO RETURN TO GET
*                                       NO, FROM USER
SISBSH4  OI    W1OSBIT2,X'02'           SET ON RELSE BIT
         LM    R2,R12,28(R13)           RESTORE REGS 2-12
SISBSH5  BR    R14                      BRANCH TO USER
         SPACE 3
*  WRITING FROM LAST SCAN NOT COMPLETED
         SPACE
SISBSA4  LR    R6,R1                    SAVE R1
         LA    R1,W1ECBO                SET R1 WITH ECBO ADDRESS
         LR    R3,R15                   SAVE R15
         WAIT  ECB=(1)                  WAIT FOR LAST WRITE
         LR    R15,R3                   RESTORE R15
         LR    R1,R6
SISBSB4  TM    W1OSBIT2,X'80'           ANY WRITE ERRORS
         BO    SISBSB5                  YES
SISBSC4  LA    R3,W1FR1ST               NO,MOVE ENTIRE WRITE Q
         LA    R4,W1WR1ST                TO FREE Q
         LH    R5,W1WRITEC
         L     R10,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R10                                        S21045
         L     R10,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R10                                        S21045
         L     R10,DEBGET               LOAD GET RTN ADDR        S21045
         DROP  R10                                               S21045
         A     R10,CTSD(R10)            GO TO QUEUE ROUTINE
         BALR  R9,R10
         B     SISBSB2
SISBSB5  L     R11,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R11                                        S21045
         L     R11,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R11                                        S21045
         L     R11,DEBGET               LOAD GET RTN ADDR        S21045
         DROP  R11                                               S21045
         A     R11,CTSGE(R11)
         BALR  R9,R11                   INFORM USER OF WRITE ERRORS
         B     SISBSB2
         SPACE 2
*  RETURN TO GET
         SPACE
SISBSH3A NI    W1OSBIT2,X'F7'           SET OFF GET RETURN INDICATOR
         L     R15,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R15                                        S21045
         L     R15,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R15                                        S21045
         L     R15,DEBGET               LOAD GET RTN ADDR        S21045
         DROP  R15                                               S21045
         L     R0,W1TEMPSA              RESTORE R0 FOR GET
         LM    R2,R12,28(R13)           RESTORE REGS. 2-12
         BR    R15                      RETURN TO GET MODULE
         EJECT
*                                     *****************
*                                     *               *
*                                     * ESETL MACRO   *
*                                     *               *
*                                     *****************
         USING *,R15
SISCTES  EQU  *
*
*
         SPACE
SISESA2  STM   R2,R12,28(R13)           SAVE REGS. 2 TO 12 IN R13
         L     R2,DCBWKPT1(0)           LOAD R2 WITH WORKAREA ADDRESS
SISESA3  TM    W1OSBIT2,X'80'           ANY WRITE Q ERRORS
         BZ    SISESB2                  NO
*                                       YES
SISESA4  L     R11,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R11                                        S21045
         L     R11,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R11                                        S21045
         L     R11,DEBGET               LOAD EINFO RTN ADDR      S21045
         DROP  R11                                               S21045
         A     R11,CTSGE(R11)
         BALR  R9,R11                   GO TO EINFO SUBROUTINE
SISESB2  L     R10,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R10                                        S21045
         L     R10,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R10                                        S21045
         L     R10,DEBGET               LOAD QUEUE RTN ADDR      S21045
         DROP  R10                                               S21045
         A     R10,CTSD(R10)
         CLI   W1USERC+1,X'00'         IS USER Q EMPTY
         BE    SISESD2                  YES
         L     R3,W1US1ST               NO, POINT TO 1ST BUFFER ON USER
         TM    CN2+4,X'80'              WAS THIS BUFFER PUTXED
         BZ    SISESC3                  NO
SISESB3  LA    R3,W1PX1ST               YES, MOVE ONE BUFFER
         LA    R4,W1US1ST               FROM USER QUEUE
         LA    R5,1                    TO PUTX Q
         BALR  R9,R10                   GO TO QUEUE RTN
SISESC3  LA    R3,W1FR1ST
         LA    R4,W1US1ST               MOVE USER QUEUE BUFFERS
         LH    R5,W1USERC               TO THE FREE QUEUE
         BALR  R9,R10                   GO TO QUEUE RTN
SISESD2  CLI   W1READC+1,X'00'         IS C OF READ Q EMPTY
         BNE   SISESD3                  NO
         CLI   W1READR+1,X'00'         IS R OF READ Q EMPTY
         BE    SISESE2                  YES, THEN READ Q IS EMPTY
SISESD3  TM    W1ECBI,X'40'             IS A READ IN PROGRESS
         BO    SISESE4                  NO
SISESD4  LR    R6,R1                    YES,WAIT FOR IT
         LA    R1,W1ECBI
         LR    R3,R15                   SAVE R15 AND WAIT TO COMPLETE
         WAIT  ECB=(1)
         LR    R15,R3                   RESTORE R15
         LR    R1,R6                    RESTORE R1
SISESE4  LA    R3,W1FR1ST               MOVE READ Q BUFFERS
         LA    R4,W1RD1ST               TO THE  FREE Q
         LH    R5,W1READC
         AH    R5,W1READR               TO GET ALL BUFS OFF READ Q
         STH   R5,W1READC
         BALR  R9,R10                   GO TO QUEUE RTN
         MVC   W1READR,W1READC          ZERO READ R FOR NEXT SCAN
SISESE2  CLI   W1PUTXC+1,X'00'         IS PUTX Q EMPTY
         BNE   SISESF2                  NO, SO A WRITE IS NECESSARY
SISESE1A EQU   *                                                OZ05933
         TM    W1ECBO,X'40'             IS WRITE IN PROCESS?    SA66297
         BO    SISESE1                  NO, RESET DCBWA FIELDS  SA66297
         BAL   R11,SISESF3              YES, WAIT ON COMPLETION SA66297
*                                       RESET WORKAREA FIELDS
SISESE1  SR    R9,R9                    SET OFF ALL OVERALL     YM03876
         STC   R9,W1OSBIT1              STATUS EXCEPT WRITE     YM03876
         SPACE 2
         NIL   W1OSBIT2,UNWRITE+WAPBIT, CONDITIONS              YM03876X
               REF=W1OSBIT1,WREGS=(R9,R10,R11)                  YM03876
         SPACE 2
         XC    W1LPDR(8),W1LPDR         ZERO OUT FOR LATER GETS   10384
         XC    W1WCOUNT(36),W1WCOUNT    SET TRK IX AREA TO ZERO   10384
         TM    DCBEXCD2,X'20'           DID CONTROL COME FROM CLOSE
         BO    SISESG1A                 YES
*                                       NO
SISESF1  LM    R2,R12,28(R13)           RESET REGS. R2-R12 FROM R13
SISESG1  BR    R14                      RETURN TO USER
         SPACE 2
SISESG1A OIL   W1OSBIT3,CLSESETL,       INDICATE THAT CLOSE     YM03876X
               REF=W1OSBIT1,WREGS=(R9,R10,R11)  WENT TO ESETL   YM03876
         SPACE 2
         LM    R2,R12,28(R13)
         BR    R14                      RETURN TO CLOSE
*   IF CLOSE WAS IN PROCESS THEN R14 WAS SET FOR RETURN TO CLOSE
         SPACE 3
*  PUTX Q NOT EMPTY, WRITE MUST BE INITIATED
         SPACE 2
SISESF2  EQU   *
         LA    R11,SISESH2              SETUP ROUTINE BRANCH    SA66297
         TM    W1ECBO,X'40'             ARE WRITES IN PROCESS
         BO    SISESG2                  NO
*                                       YES
SISESF3  LR    R6,R1                    SAVE R1 AND WAIT FOR
         LA    R1,W1ECBO                WRITES TO COMPLETE
         LR    R3,R15                   SAVE R15
         WAIT  ECB=(1)
         LR    R15,R3                   RESTORE R15
         LR    R1,R6                    RESTORE R1
SISESG3  TM    W1OSBIT2,X'80'           WERE THERE WRITE ERRORS
         BO    SISESA4                  YES,GO TO EINFO
*                                       NO
         LA    R3,W1FR1ST               MOVE WRITE
         LA    R4,W1WR1ST               QUEUE BUFFERS
         LH    R5,W1WRITEC              TO FREE QUEUE
         BALR  R9,R10                   GO TO QUEUE RTN
         BR    R11                      AND BRANCH              SA66297
SISESG2  CLI   W1WRITEC+1,X'00'        IS WRITE Q EMPTY
         BNE   SISESG3                  NO
SISESH2  SR    R5,R5                     CLEAR REG                10386
         L     R11,W1PX1ST               GET 1ST CP POINTER       10386
SISESH2A LA    R5,1(R5)                  INCRE BUFFER COUNT       10386
         LA    R3,40(R11)                POINT TO MBBCC           10386
         L     R11,32(R11)          GET NEXT CP ADDR. (IF ANY)    10386
         LA    R11,0(R11)                CLEAR HI ORDER BYTE      10386
         LTR   R11,R11                   ANY MORE CHANNEL PROGS   10386
         BZ    SISESH2B                  NO BRANCH                10386
         LA    R4,40(R11)                POINT TO NEXT MBBCC      10386
         CLC   0(7,R3),0(R4)            ARE TWO MBBCCHH'S EQUAL   22662
         BE    SISESH2A                  YES, GO COMP NEXT MBBCC  10386
SISESH2B LA    R3,W1WR1ST              NO, GO SET UP AND DO EXCP  10386
*                                   ON THE BUFFERS ON SAME CYL    10386
*   LIMIT NUMBER OF BUFFERS WRITTEN IN ORDER TO PREVENT CHANNEL
*   PROGRAMS LONGER THAN 224 CCW'S.
         LA    R4,THIRTY                LIMIT WRITE BUFFERS
         CR    R4,R5                    TOO MANY WRITE BUFFERS
         BH    AOS000                   NO - NUMBER O.K.
         LR    R5,R4                    LIMIT NUMBER OF BUFFERS
AOS000   EQU   *                        *
         LA    R4,W1PX1ST               MOVE PUTX QUEUE
         BALR  R9,R10                   GO TO QUEUE RTN
SISESJ2  L     R11,DCBDEBAD             DEB ADDRES               S21045
         USING SISDEB,R11                                        S21045
         L     R11,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R11                                        S21045
         L     R11,DEBGET               GET RTN ADDR             S21045
         DROP  R11                                               S21045
         A     R11,CTSF(R11)            GET SETC4 ADDR. AND PREPARE
         BALR  R9,R11                   WRITE QUEUE FOR OUTPUT
*
*
*
SISESK1  MVI   W1OEXTEN+1,X'08'        SET APP CODE FOR WRITING
         SR    R6,R6                   CLEAR WORK AREA
         IC    R6,W1ODAD               SET M FROM IOB
         SLL   R6,4                    M X 16
         L     R7,DCBDEBAD             GET DEB ADDR
         LA    R6,32(R6,R7)            R6 POINT TO EXTENT OF 7
         MVC   W1ODAD+1(2),4(R6)       MOVE BB FROM DEB TO IOB
         LR    R6,R1                    SAVE R1
         LR    R7,R15                   SAVE R15
         EXCP  W1IOBO
         WAIT  ECB=W1ECBO                                         10386
         LR    R1,R6                     RESTORE REGISTE9S        10386
         LR    R15,R7                                             10386
         CLI   W1PUTXC+1,X'00'           PUTX Q EMPTY            A48519
         BE    SISESE1A                  YES DON'T WAIT         OZ05933
         LA    R11,SISESH2              SET RETURN ADDRESS      YM05971
         B     SISESG3               GO GET MORE PUTX BUFFERS     10386
         EJECT
*                                       ***************
*                                       *             *
*                                       * SCHEDULE    *
*                                       *             *
*                                       ***************
         SPACE 2
         USING *,R11                    R11 SET AS BASE BY CALLING RTN
SISCTSB  TM    W1OSBIT1,X'40'           ARE WE AT END OF DATA SET
         BCR   7,R9                    YES, NO MORE SCHEDULING
SISSBB1  LH    R6,W1FREEC               C OF FREE Q
         AH    R6,W1READR               R OF READ Q
*                                       R6 = TOTAL AVAILABLE BUFFERS
         ST    R9,W1REGSV2              SAVE EXIT ADDR
         SPACE 2
         OIL   W1OSBIT2,SCHED,          SET ON SCHEDULING BIT   YM03876X
               REF=W1OSBIT1,WREGS=(R5,R9,R10)                   YM03876
         SPACE 2
SISSBA2  TM    W1OSBIT1,X'20'           OVERFLOW INDICATOR
         BO    SISSBA3                  ON, OVERFLOW TO BE READ
*                                       OFF, READ PRIME DATA
SISSBB2  TM    W1OSBIT2,X'20'           CYLINDER INDICATOR
         BO    SISSBC2                  ON, NEXT RCD ON SAME CYLINDER
*                                       OFF, GO TO NEW CYLINDER
         SPACE 2
*        CHANGE TO NEW CYLINDER
*
SISSBB3  CH    R6,SISSBCN4           IS THERE AT LEAST ONE BUFFER
*                                       (FOR THE CASE OF SHARED TRACK)
         BL    SISSBD5                  NO, EXIT WITHOUT SCHEDULING
         SPACE 2
         OIL   W1OSBIT2,CYLIND,         SET ON CYLINDER         YM03876X
               REF=W1OSBIT1,WREGS=(R5,R9,R10)  INDICATOR        YM03876
         SPACE 2
         MVI   W1WDNXDM+8,X'00'        RESET DUMMY IND
         SR    R7,R7
         L     R8,DCBDEBAD             GET DEB ADDR
         SR    R5,R5
         SR    R6,R6
         IC    R5,W1LMBBCC             PICK UP M FROM LPDR
         SLL R5,4                      M X 16
         LA    R5,32(R8,R5)            R5 POINTS TO EXTENT OF M
         OC    W1LPDR+6(1),DCBFIRSH+3  USE MASK TO MAKE TRK MAX VALUE
         CLC   W1LPDR+6(1),13(R5)      LAST TRK OF CYL OR EXTENT
         BL    SISSBB34                NO, GO INCREM TRK NO
         CLC   W1LPDR+3(3),10(R5)      LAST TRK OF EXTENT
         BNE   SISSBB33                NO, GO TO INCREM CCH
         IC    R6,W1LPDR               GO TO NEXT EXTENT
         LA    R6,1(R6)                M  +  1
         STC   R6,W1LPDR               STORE BACK INTO LPDR
         CLC   W1LPDR(1),DEBNPEE       ANY MORE PRIME EXTENTS
         BH    SISSBD51                NO, SET OFF SCHEDULE BIT
         B     SISSBB31
*
SISSBB33 EQU   *                        *
         MVC   W1WCNXDM(L2),W1LPDR+K3   MOVE CC TO HWORD BDY     S20201
         LH    R6,W1WCNXDM              GET CYL VALUE            S20201
         LA    R6,K1(R0,R6)             ADD ONE TO IT            S20201
         STH   R6,W1WCNXDM              STORE IT BACK            S20201
         MVC   W1LPDR+K3(L2),W1WCNXDM   MOVE IT BACK TO FIELD    S20201
SISSBB34 IC    R6,W1LPDR+6             INCREMENT TRK NO
         LA    R6,1(R6)                (MAY BE INCREMENTING FROM
         STC   R6,W1LPDR+6             MINUS 1 TO ZERO)
SISSBB32 MVC   W1WCNXDM(4),W1LPDR+3    MOVE CCHH INTO WCNXDM
         OC    W1LPDR+6(1),DCBFIRSH+1  MOVE IN FIRSH TRACK
         IC    R7,DCBFIRSH+2           GET FIRSH R
         BCTR  R7,0                    R-1
         STC   R7,W1LPDR+7             STORE R INTO LPDR
         MVI   W1WCNXDM+4,X'01'        R=1
         LH    R6,W1FREEC               C OF FREE Q
         AH    R6,W1READR               R OF READ Q
         SPACE 2
         OIL   W1OSBIT1,TRKINDX,        SET ON READ TRACK       YM03876X
               REF=W1OSBIT1,WREGS=(R5,R7,R9)  INDEX BIT         YM03876
         SPACE 2
         CLI   DCBFIRSH+2,X'01'         IS THIS A SHARED TRACK
         BE    SISSBC2                  NO
         SPACE 2
         OIL   W1OSBIT2,SHRDTRK,        SET ON SHARED TRACK     YM03876X
               REF=W1OSBIT1,WREGS=(R5,R7,R9)  INDICATOR         YM03876
         SPACE 2
         SR    R7,R7
         IC    R7,DCBHIRSH              PRESET R7
         LA    R5,1                    FOR SHARED TRK, USE ONLY 1
*                                       RCD SINCE TRACK INDEX HAS NOT
*                                       BEEN READ, AND IF AN OVERFLOW
*                                       RCD HAS BEEN ADDED TO THE 1ST
*                                       TRACK, IT COULD BE BYPASSED IF
*                                       ICNOT IS GREATER THAN THE NUM
*                                       OF PRIME DATA RCDS ON THE 1ST
*                                       TRACK.
         B     SISSBE5                  TO SET UP TO READ
         SPACE 3
*
* GET NEW EXTENT
*
SISSBB31 LA    R5,16(0,R5)             ADD 16 FOR NEXT EXTENT
         MVC   W1LPDR+3(4),6(R5)       MOVE IN NEW CCHH
         B     SISSBB32                 GO BACK TO SET HHR'S
         SPACE 1
*
* DETERMINE WHAT IS TO BE READ
*
         SPACE 1
SISSBC2  SR    R7,R7                    CLEAR R7
SISSBD2  IC    R7,DCBHIRPD              HI R OF NON-SHARED PRIME TRACK
         TM    W1OSBIT2,X'10'           SHARED TRACK IND
         BZ    SISSBE2                  OFF
SISSBD3  IC    R7,DCBHIRSH              ON, SET R7=HI R SHARED TRACK
SISSBE2  SR    R8,R8                    CLEAR R8
         IC    R8,W1LR                  R FROM LPDR (LAST RCD READ)
         SR    R5,R5                    CLEAR R5
         IC    R5,W1ICNOT
         AR    R8,R5                    R8 = R(OF LPDR) + ICNOT
         CR    R8,R7                R(LPDR) + ICNOT G.E. HI DATA R
         BL    SISSBE3                  NO, NOW CHECK AVAILABLE BUFFERS
*                                       YES, LESS THAN N/2 BLKS ON TRK
SISSBF2  TM    W1WOVFL+8,X'18'          DOES THIS TRACK HAVE OVERFLOW
         BO    SISSBG2                  YES
SISSBF3  TM    W1WDNXDM+8,X'20'         NO, IS THIS LAST TRK OF CYLINDR
         BO    SISSBG3                  YES
*                                   NO, IF BUFFERS AVAILABLE CAN READ
*                                   END OF THIS TRACK AND PART OF NEXT
SISSBE3  CR    R6,R5                    ARE FREE BUFS LESS THAN ICNOT
         BL    SISSBD5                  YES
*                                       NO, READ ICNOT BUFFERS
*
SISSBE5  LA    R3,W1RD1ST               MOVE FROM FREE TO READ Q
         LA    R4,W1FR1ST
         STH   R5,W1CPNUM               SAVE SO AS TO KNOW HOW MANY
*                                       CHANNEL PROGRAMS TO SET UP
         STH   R7,W1SAV7                R7 IS DESTROYED BY QUEUE RTN
         L     R10,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R10                                        S21045
         L     R10,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R10                                        S21045
         L     R10,DEBGET               LOAD QUEUE RTN ADDR      S21045
         DROP  R10                                               S21045
         A     R10,CTSD(R10)
         BALR  R9,R10                   GO TO Q SUBROUTINE
         SR    R5,R5                    CLEAR TO USE AS COUNTER
         LH    R7,W1SAV7                R7=HIGH R OF CURRENT TRACK
         SPACE
*        CHART SC
         SPACE 2
*
* SET UP CHANNEL PROGRAMS FOR READING PRIME DATA RECORDS.
*
         SPACE 2
SISSCA2  L     R3,W1RD1ST               SET BASE FOR CP22 DSECT
         MVC   W1ICPS+1(3),W1RD1ST+1    INIT IOBI CP POINTER TO 1ST CP
*                                       ON READ Q
SISSCB2  SR    R6,R6
         IC    R6,W1LR                  R OF LPDR
SISSCB21 CR    R6,R7                    AT END OF TRACK
         BE    SISSCB3                  YES
         LA    R6,1(R6)                NO, ADD 1 TO R OF LPDR
         STC   R6,W1LR
         TM    W1OSBIT1,X'10'           IS READ TRK INDEX SWITCH ON
*                                        (ON FROM SETL B OR NEW CYLIND)
         BO    SISSCB31                 YES
*                                       NO
SISSCD2  SR    R8,R8
         IC    R8,W1LPDR                SETUP BB MOVE INTO CN6
         SLL   R8,4
         ST    R8,CN6                   REGS SCARCE SO MUST REUSE
         L     R8,DCBDEBAD
         LA    R8,32(R8)
         A     R8,CN6
         MVC   CN6,W1LPDR
         MVC   CN6+1(2),4(R8)
         MVC   CN4+1(3),CN7+1           SET ALL CPS FOR PRIME DATA READ
         LH    R8,DCBBLKSI              RESET COUNT TO BLOCKSIZE
         STH   R8,CN4+6
         MVI   CN4,X'06'                SET CN4 TO READ
         NI    CN2+4,X'20'              SET OFF ALL FLAGS BUT D-KD
         OI    CN1,X'80'               SET ON MT BIT
         LA    R5,1(R5)                ADD 1 TO COUNT OF CP'S INIT'ZED
         CLI   CN3,X'08'               CP22A OR 22B
         BE    SISSCE2                  22B
         MVI   CN3,X'0E'                22A, SET CN3 FOR READ KD
SISSCE2  CH    R5,W1CPNUM               ARE WE AT END OF CHAIN
         BNE   SISSCF2                  NO
         NI    CN4+4,X'BF'              YES, SET OFF CC BIT
         L     R3,W1RD1ST
         NI    CN1,X'7F'               SET OFF MT BIT IN 1ST CP
         MVC   W1IDAD,CN6               SET IOB + 32 FOR IOS
         CLC   W1ICPS+1(3),W1RD1ST+1    ARE TRACK INDICES TO BE READ
         BE    SISSBC5                  NO
         MVC   W1IDAD+3(5),W1WCOUNT     YES, SET CCHHR OF IOB+32 TO
*                                 CCHHR OF NEXT TRACK INDEX RECORD
         LA    R6,CN6+1                 SET SEEK ADDR IN READ TRACK
         ST    R6,W1CN14                INDEX CP TO CN1 OF 1ST CP ON
         MVI   W1CN14,X'1B'             READ Q. REPLACE SEEK COMMAND
         NI    W1CN8,X'7F'              SET OFF MT BIT
         B     SISSBC5                  GO TO EXECUTE EXCP
         SPACE 2
SISSCF2  OI    CN4+4,X'40'              SET ON CC BIT
         L     R3,CN5                   ADVANCE TO NEXT CP ON READ Q
         B     SISSCB21                 AND SET IT UP
         SPACE 3
*
* TRACK INDEX TO BE READ
*
SISSCB3  MVC   W1LPDR(8),W1WDNXDM       MOVE DATA PORTION OF NEXT
*                                       NORMAL ENTRY IN TRACK INDEX
*                                       TO LPDR
         SPACE 2
         NIL   W1OSBIT2,ONES-SHRDTRK,   SET OFF SHARED TRACK    YM03876X
               REF=W1OSBIT1,WREGS=(R8,R9,R10)  INDICATOR        YM03876
         SPACE 2
         MVI   W1LR,X'01'               SET R OF LPDR TO 1
         IC    R6,W1LR                  SET R6 TO R OF NEW LPDR
         SPACE 2
SISSCB31 NIL   W1OSBIT1,ONES-TRKINDX,   SET OFF READ TRACK      YM03876X
               REF=W1OSBIT1,WREGS=(R8,R9,R10)  INDEX INDICATOR  YM03876
         SPACE 2
         LA    R9,W1CP24                PUT CP24 ADDR IN IOBI POINTER
         ST    R9,W1ICPS                CHAIN IT TO 1ST CP22 ON READ Q
         MVC   W1CN15+1(3),W1RD1ST+1
         LM    R8,R9,W1WCNXDM           UPDATE COUNT FIELD FOR NEXT
         STM   R8,R9,W1WCOUNT           INDEX READ
         B     SISSCD2                  TO SET UP FOR READING NEW TRK
         SPACE 2
*
* OVERFLOW AND END OF CYLINDER
*
         SPACE 2
SISSBG2  OIL   W1OSBIT1,OVRFLOW,        SET ON OVERFLOW         YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)  INDICATOR        YM03876
         SPACE 2
SISSBH2  SR    R8,R5                    R8 NOW = R OF LPDR
         CR    R7,R8                    HAVE WE ALREADY READ THE LAST
*                                       RECORD ON THIS TRACK
         BNE   SISSRKSI
         TM    W1OSBIT1,X'40'           NO, GO FINISH TRACK
         BC    1,SISSBD5                EOD, EXIT
         BC    15,SISSBA2               END OF CYL, GET NEXT CYL
SISSRKSI LR    R5,R7
         SR    R5,R8                    R5=NUMBER LEFT ON CURRENT TRACK
         CR    R6,R5                    ARE THERE ENOUGH BUFFERS
         BNL   SISSBE5                 YES, READ THE REST
         SPACE 2
         NIL   W1OSBIT1,ONES-OVRFLOW,   NO-SET OFF OVRFLOW, NXT YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)  RCD NOT OVERFLOW YM03876
         SPACE 2
SISSBK3  OIL   W1OSBIT2,CYLIND,         SET ON CYL BIT          YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)                   YM03876
         SPACE 2
*                                       SCHEDULE BIT IS ON SO THAT NEXT
         B     SISSBD5                  GET WILL TRY AGAIN
*
SISSBG3  TM    W1WDNXDM+8,X'10'         IS THIS AN INACTIVE ENTRY
         BO    SISSBG31
         SPACE 2
         NIL   W1OSBIT2,ONES-CYLIND,    SET OFF SAME CYL IND    YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)                   YM03876
         SPACE 2
         B     SISSBH2                  GO TO COMMON PROCESSING
SISSBG31   CR  R6,R5                    ENOUGH BUFFERS
         BL    SISSBD5                  NO
         SPACE 2
         OIL   W1OSBIT1,EOD,            SET ON END OF DATA      YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)  INDICATOR        YM03876
         SPACE 2
         B     SISSBH2
         SPACE 3
*
* SET CHANNEL PROGRAMS TO READ OVERFLOW RECORDS
*
SISSBA3  CH    R6,SISSBCN4              ARE THERE AT LEAST 2 FREE BUFS
         BH    SISSBA4                  YES
*                                       NO, TEST
         SR    R5,R5                   FOR SPECIAL CASE WHERE ICNOT
         IC    R5,W1ICNOT               IS 1
         CR    R6,R5
         BL    SISSBK3                  NOT ENOUGH BUFFERS
SISSBA4  LH    R5,W1FREEC               MOVE ALL FREE Q TO READ Q
         AH    R5,W1READR               TO INSURE MOVING ALL OF FREE Q
*                                        RATHER THAN %FREE C<-%READ R<
         LA    R3,W1RD1ST
         LA    R4,W1FR1ST
         L     R10,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R10                                        S21045
         L     R10,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R10                                        S21045
         L     R10,DEBGET               LOAD QUEUE RTN ADDR      S21045
         DROP  R10                                               S21045
         A     R10,CTSD(R10)
         BALR  R9,R10
SISSBA5  MVC   W1READR,W1READC          SET READ R = READ C
         L     R3,W1RD1ST               PUT DISK ADDR OF NEXT OVERFLOW
*                                       RECORD IN CN6 OF 1ST CP
SISSBB5  SR    R8,R8
         IC    R8,W1WOVFL
         SLL   R8,4
         ST    R8,CN6                   REGS SCARCE SO JUST REUSE
         L     R8,DCBDEBAD
         LA    R8,32(R8)
         A     R8,CN6
         MVC   CN6,W1WOVFL
         MVC   CN6+1(2),4(R8)
         NI    CN2+4,X'20'              SET OFF ALL FLAGS BUT D-KD
         OI    CN2+4,X'40'              SET ON OVERFLOW
         NI    CN1,X'7F'                SET OFF MT
         NI    CN4+4,X'BF'              SET OFF CC  SINCE OVERFLOW RCDS
*                                       ARE READ ONE AT A TIME
         MVC   W1ICPS+1(3),W1RD1ST+1    SET CP POINTER IN IOBI TO 1ST
*                                       C.P. ON READ Q
         MVC   W1IDAD,W1WOVFL           SET IOB+32 FOR IOS
*                                       SET CHANNEL PROGRAMS FOR
SISSBB51 L     R8,CN7                   READING OVERFLOW RECORDS
         SH    R8,SISSBCN1              SET BUFD ADDR TO 10 LESS TO
         ST    R8,CN4                   ALLOW FOR LINK FIELD
         LH    R8,DCBLRECL              SET COUNT TO RCD LENGTH + 10
         AH    R8,SISSBCN1               FOR LINK
         STH   R8,CN4+6
         MVI   CN4,X'06'                SET OP CODE TO READ
         CLI   CN3,X'08'               CP22A OR 22B
         BE    SISSBB52                 22B
         MVI   CN3,X'0E'                FOR 22A  TO READ KD ALSO
SISSBB52 CLC   CN5+1(3),SISSBCN2+1      ARE  WE AT END OF CHAIN
         BE    SISSBC5                  YES
         L     R3,CN5                   NO, GET NEXT CP ADDR AND LOOP
         B     SISSBB51
         SPACE 3
*
* INITIATE READ
*
         SPACE 2
SISSBC5  MVI   W1IEXTEN+1,X'00'         SET APP CODE FOR READ
         OI    W1IF1,X'80'              SET ON DC BIT
         SR    R6,R6                   CLEAR WORK REG
         IC    R6,W1IDAD               GET M FROM IOB
         SLL   R6,4                    M X 16
         L     R3,DCBDEBAD             GET DEB ADDR
         LA    R6,32(R6,R3)            R6 POINTS TO EXTENT OF M
         MVC   W1IDAD+1(2),4(R6)       MOVE BB INTO IOBI
         LR    R6,R1                    SAVE  R1
         LR    R3,R15                   SAVE R15
         EXCP  W1IOBI
         LR    R15,R3
         LR    R1,R6                    RESTORE R1
         SPACE 2
SISSBD51 NIL   W1OSBIT2,ONES-SCHED,     SET OFF SCHEDULE BIT    YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10) AS SCHED WAS SUCC YM03876
         SPACE 2
SISSBD5  L     R9,W1REGSV2              PICK UP EXIT ADDR
         BR    R9
         SPACE 2
* CONSTANTS FOR SB AND SC
*
*
CVTPTR   EQU   16
CVTZDTAB EQU   64
SISSBCN2 DC    F'0000'
SISSBCN4 DC    X'0001'
SISSBCN1 DC    H'10'
         EJECT
*                                       ***************
*                                       *             *
*                                       *    QUEUE    *
*                                       *             *
*                                       ***************
         USING *,R10
*
SISCTSD  EQU   *
         SPACE 1
*        ON ENTERING THE QUEUEING ROUTINE
*        R3 CONTAINS THE ADDRESS OF THE TO   QUEUE
*        R4 CONTAINS THE ADDRESS OF THE FROM QUEUE
*        R5 CONTAINS THE NUMBER OF ENTRIES TO BE MOVED %N<
*        REGISTERS DESTROYED- R6,R7
*        POINTERS TO CHANNEL PROGRAMS MAY HAVE X'08' IN BYTE 0. THIS
*        CAN BE MASKED OUT IF IT INTERFERES.
         SPACE 1
SISSDD2  CH    R5,SISSDCN1              IS N = 0
         BNE   SISSDD21                 NO
         BR    R9                       YES, RETURN WITHOUT MOVING Q'S
SISSDD21 LH    R6,8(R0,R3)              R OF TO Q
         CR    R6,R5                    COMPARE NUMBER TO BE MOVED AND
*                                       RESIDUE
         BL    SISSDF2                  NOT ENOUGH IN RESIDUE
SISSDE1  SR    R6,R5                    ENOUGH ARE ON Q, SET R=R-N
         STH   R6,8(R0,R3)
         LH    R6,10(R0,R3)             C OF TO Q
         AR    R6,R5
         STH   R6,10(R0,R3)             C=C+N
         BR    R9                       RETURN
*
*
SISSDF2  L     R7,0(R0,R4)              SET R7 TO ADDR OF 1ST CP ON
*                                       FROM QUEUE
         CLC   SISSDCN1(4),8(R3)        ARE C AND R OF TO Q ZERO
         BE    SISSDF3                  YES
*                                       NO, MUST CHAIN NEW ADDRESSES TO
*                                       THOSE ALREADY ON Q
         L     R6,4(R0,R3)              R6=ADDR OF LAST CP ON TO Q
         MVC   33(3,R6),1(R4)           MOVE ADDRESS OF 1ST CP ON FROM
*                                       Q TO TIC ADDRESS IN CN5 OF
*                                       LAST CP ON TO Q
         SH    R5,8(R3)             N=N-R
         LH    R6,10(R3)           C=C+R
         AH    R6,8(R3)
         STH   R6,10(R3)
         MVC   8(2,R3),SISSDCN1        ZERO R
SISSDG1  CH    R5,10(R4)              IS N G.T. C OF FROM Q
         BNH   SISSDJ2                  NO
SISSDH2  LH    R5,10(R4)                YES, SET N = C OF FROM QUEUE
SISSDJ2  CH    R5,SISSDCN3              IS N=1
         BE    SISSDJ3                  YES
*
*                                       NO
*        *****                MOVE LINK ADDR OF %N-1<TH ENTRY IN FROM Q
*        *****                TO THE 'LAST' FIELD OF THE TO Q
         SPACE
         LR    R6,R5                    SET R6 TO N-1
         SH    R6,SISSDCN3
*
*                                       R7 IS ORIGINALLY ADDR OF 1ST
*                                       CP ON FROM Q
         SPACE
SISSDK2  L     R7,32(R7)                LOOP UNTIL R7 WILL
         BCT   R6,SISSDK2               PICK UP LINK FIELD  OF (N-1) TH
*                                       (POINTING TO ADDR OF NTH CP)
         SPACE
Q1ST     EQU   4                        DISPLACEMENT TO FIRST    S20201
*                                       * Q POINTER
SISSDJ3  ST    R7,Q1ST(R3)              MOVE TO 'LAST' FIELD OF  S20201
*                                       * 'TO' Q
         USING CN1,R7                   ADDRESSABILITY ON CP22   S20201
         CLI   CN5,TIC                  RPS FORM OF CP           M5092
         BE    SISSDA4                  NO DON'T CORRECT TIC     M5092
         MVI   CN5,TIC                  RESTORE TIC              S20201
         XC    CN5+K1(L3),CN5+K1        TIC ADDRESS = 0          S20201
SISSDA4  L     R6,CN5                   SET NEW 1ST FIELD IN     S20201
*                                       FROM Q                   S20201
         DROP  R7                                                S20201
         ST    R6,0(R4)                 WITH LINK FIELD OF NTH FROM CP
         MVC   33(3,R7),SISSDCN1        SET NTH LINK (NEW 'LAST' FIELD
*                                       ON TO Q) TO 0
         LH    R6,10(R4)                C OF FROM Q = C - N
         SR    R6,R5
         STH   R6,10(R0,R4)
         LH    R6,10(R3)                C OF TO Q = C + N
         AR    R6,R5
         STH   R6,10(R0,R3)
         BR    R9                       RETURN TO CALLING ROUTINE
         SPACE
SISSDF3  L     R6,0(R4)                 WHEN TO Q EMPTY, MOVE 'FIRST'
         ST    R6,0(R0,R3)              FROM FIELD TO 'FIRST' TO FIELD
         B     SISSDG1
*
* CONSTANTS
*
         DS    0F
SISSDCN1 DC    X'00000000'
SISSDCN3 DC    X'0001'
         EJECT
*                                     *******************
*                                     *                 *
*                                     * END OF BUFFER   *
*                                     *                 *
*                                     *******************
         USING *,R12
         SPACE 3
SISCTSE  EQU  *
         SPACE 2
SISSEA2  L     R3,W1US1ST
         ST    R9,W1REGSV3              SAVE R9 IN ORDER TO EXIT
         TM    W1USERC+1,X'FF'          USER Q EMPTY
*                                       (SPECIAL CASE ON 1ST GET
*                                        FOLLOWING A SETL)
         BZ    SISSEA4                  YES
         TM    CN2+4,X'10'              IS THIS EOD BUFFER, CLOSE WILL
*                                       WRITE IT IF PUTXED
         BO    SISSEG2                  YES, GO TO EOD EXIT
         TM    CN2+4,X'80'              NO, WAS CURRENT BUFFER PUTXED
         BZ    SISSEB2                  NO
*                                       YES
SISSEA3  LA    R3,W1PX1ST               MOVE CURRENT USER
         LA    R4,W1US1ST               QUEUE BUFFER TO
         LA    R5,1                    TO PUTX Q
         L    R10,CTSD(R15)            GO TO QUEUE SUBROUTINE
         AR    R10,R15
         BALR  R9,R10
         B     SISSEC3
SISSEB2  LA    R3,W1FR1ST               MOVE NON PUTXED USER
         LA    R4,W1US1ST               BUFFER TO THE
         LA    R5,1                    FREE Q
         L    R10,CTSD(R15)             GET QUEUE ROUTINE OFFSET
         AR    R10,R15
         BALR  R9,R10                   BRANCH TO Q SUB AND RETURN
SISSEC3  CLC   W1PUTXC+1(1),W1ICNOT     CAN A WRITE BE SCHEDULED
         BL    SISSED3                  NO, NOT N/2 PUTX Q BUFFERS
         TM    W1WRITEC+1,X'FF'         YES, IS WRITE Q EMPTY
         BZ    SISSEC1A                 YES
*                                       NO, IS WRITING COMPLETE
SISSEC2  TM    W1OSBIT1,X'01'           TEST IOB-O COMPLETE INDIC
         BZ    SISSED3                  WRITING IS STILL GOING ON
*                                       WRITING COMPLETE
SISSEC2A TM    W1OSBIT2,X'80'           ANY WRITE ERRORS
         BO    SISSED3                  YES, TELL USER ON NEXT GET
*                                       NO
         SPACE 2
         NIL   W1OSBIT1,ONES-IOBOC,     SET OFF IOBO COMPLETE   YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)  BIT              YM03876
         SPACE 2
SISSEC1  LA    R3,W1FR1ST
         LA    R4,W1WR1ST               MOVE WRITE QUEUE
         LH    R5,W1WRITEC              BUFFERS TO FREE QUEUE
         L    R10,CTSD(R15)
         AR    R10,R15
         BALR  R9,R10                   BRANCH TO Q SUB AND RETURN
SISSEC1A SR    R5,R5                     CLEAR REGISTERS          10386
         CLI   W1PUTXC+1,0              IS PUTX Q MT             A36373
         BE    SISSED3                  BIF YES                  A36373
         L     R10,W1PX1ST               GET 1ST CP ADDR          10386
SISSEC1B LA    R5,1(R5)                  INCRE BUFFER COUNT       10386
         LA    R3,40(R10)                POINT TO MBBCC           10386
         L     R10,32(R10)          GET NEXT CP ADDR. (IF ANY)    10386
         LA    R10,0(R10)                CLEAR HI ORDER BYTE      10386
         LTR   R10,R10                   ANY MORE CHANNEL PROGS   10386
         BZ    SISSEC1C                  NO, BRANCH               10386
         LA    R4,40(R10)                POINT TO NEXT MBBCC      10386
         CLC   0(7,R3),0(R4)            ARE TWO MBBCCHH'S EQUAL   22662
         BE    SISSEC1B                  YES, GO TO 5573-42233    10386
SISSEC1C LA    R3,W1WR1ST                NO, GO SET UP AND DO EXCP10386
*                                         ON THE BUFFERS ON THE   10386
*                                        SAME CYLINDER            10386
         LA    R4,W1PX1ST               MOVE PUTX QUEUE
*
*   LIMIT NUMBER OF BUFFERS WRITTEN IN ORDER TO PREVENT CHANNEL
*   PROGRAMS LONGER THAN 224 CCW'S.
*
         LA    R10,THIRTY               LIMIT WRITE BUFFERS
         CR    R10,R5                   TOO MANY WRITE BUFFERS
         BH    AOS001                   NO - NUMBER O.K.
         LR    R5,R10                   LIMIT NUMBER OF BUFFERS
AOS001   EQU   *                        *
         L    R10,CTSD(R15)
         AR    R10,R15
         BALR  R9,R10                   BRANCH AND RETURN FROM Q SUB.
SISSEE1  L     R11,CTSF(R15)            GO TO SETC4 SUBROUTINE
         AR    R11,R15                  TO PREPARE WRITE Q
         BALR  R9,R11                   BUFFERS FOR OUTPUT
         SPACE 2
*  INITIATE WRITE
         SPACE 2
SISSEF1  MVI   W1OEXTEN+1,X'08'        SET APP CODE FOR WRITING
         SR    R6,R6                   CLEAR WORK REG
         IC    R6,W1ODAD               GET M FROM IOB
         SLL   R6,4                    M X 16
         L     R7,DCBDEBAD             GET DEB ADDR
         LA    R6,32(R6,R7)            R6 POINTS TO EXTENT OF M
         MVC   W1ODAD+1(2),4(R6)       MOVE BB INTO IOBO
         LR    R6,R1                    SAVE R1
         LR    R7,R15                  SAVE R15
         EXCP  W1IOBO                   INITIATE WRITING
         LR    R1,R6                    RESTORE R1
         LR    R15,R7                   RESTORE R15
         CLI   W1PUTXC+1,X'00'           PUTX Q 5MPTY             10386
         BE    SISSED3                   YES DON'T WAIT           10386
         LR    R6,R1                     SAVE REGISTERS           10386
         LR    R7,R15                                             10386
         WAIT  ECB=W1ECBO                                         10386
         LR    R1,R6                     RESTORE REGISTERS        10386
         LR    R15,R7                                             10386
         B     SISSEC2A                                           10386
         SPACE
*                                       AT END OF DATA SET
SISSEG2  TM    DCBEODAD+3,X'01'         WAS AN EOD ADDRESS SPECIFIED
         BO    SISSEG2A                 NO
*                                       YES
         LM    R2,R12,28(R13)           RESTORE REGS 2-12 FOR USER
         L     R1,DCBEODAD              GET USER'S EOD ADDRESS
SISSEOUT BR    R1                       GO TO END OF DATA EXIT
         SPACE 2
*                                       GIVE 039 ABEND, NO       Y02072
SISSEG2A ABEND X'039',DUMP,,SYSTEM      EOD ADDR GIVEN           Y02072
         SPACE 2
SISSED3  CLI   W1USERC+1,X'01'         IS USER Q EMPTY
         BL    SISSEA4                  YES
SISSEF3  L     R3,W1US1ST         END OF DS BUF TEST. COMPARE MBBCC
         CLC   CN6,DCBLPDA        HHR OF LPDA WITH CN6 OF CP1 USERQ
         BNE   SISSEF3A                 NOT LAST BLOCK
*                                       LAST PRIME DATA RCD NEXT TO BE
*                                       PROCESSED
         TM    W1WOVFL+8,X'08'          DOES OVERFLOW CHAIN REMAIN TO
*                                       BE READ
         BO    SISSEF3A                 YES
         OI    CN2+4,X'10'              NO, MARK THIS AS EOD BUFFER
         SPACE 3
* SET CBF AND EOB POINTERS
         SPACE 2
SISSEF3A TM    CN2+4,X'40'              IS CURRENT RECORD AN OVERFLOW
         BO    SISSEH3                  YES
*                                       NO
         TM    W1OSBIT2,X'01'           IS BLOCKED SW. FROM SETL K ON
         BZ    SISSEF3B                 NO
         MVC   W1CBF,W1KEYBLK           YES,MOVE REC SAVED BY SETL K
*                                       TO CBF
         B     SISSEF3C
SISSEF3B MVC   W1CBF+1(3),CN4+1         SET CBF FOR NORMAL CASE
SISSEF3C L     R5,CN4
         LA    R5,0(R5)                CLEAR HIGH ORDER BYTE
         TM    DCBRECFM,X'80'           ARE THESE FIXED RECS
         BZ    SISSEG3                  NO, VARIABLE RECORDS
         AH    R5,DCBBLKSI              FIXED, GET EOB ADDRESS
SISSEJ5  BCTR  R5,0                    TO POINT TO LAST BYTE OF BUFF
         ST    R5,W1EOB                 SET W1EOB
         SPACE 2
         NIL   W1OSBIT2,ONES-SETLKBLK,  SET OFF SETLK BLK BIT   YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)                   YM03876
         SPACE 2
         L     R9,W1REGSV3
         BR    R9                       EXIT
         SPACE 3
*                             VARIABLE
SISSEG3  LR    R6,R5                    LOAD BUFFER ADDRESS TO R6
         LA    R6,4(R6)                SET R6 TO 1ST RECORD IN BLOCK
         TM    W1OSBIT2,X'01'           SETL K BLK BIT ON
         BO    SISSEG3A                 YES
         ST    R6,W1CBF                 SET CBF TO 1ST REC IN BUFFER
SISSEG3A AH    R5,0(R6)                 ADD BLK LEN
         B     SISSEJ5
         SPACE 3
SISSEH3  L     R5,CN4                   OVERFLOW PROCESSING
         LA    R5,10(R5)
         TM    DCBRECFM,X'80'           FIXED OR VARIABLE
         BZ    SISSEG3                  VARIABLE
*                                       FIXED
         ST    R5,W1CBF                 SET W1CBF FOR OVERFLOW RECORD
         AH    R5,DCBLRECL              TO FIND END OF BUFFER
         B     SISSEJ5
         SPACE 3
*                                       FILL USER QUEUE
SISSEA4  TM    W1ECBI,X'40'             ARE ANY READS IN PROCESS
         BZ    SISSEC4                  YES WAIT FOR THEM
*                                       NO
         TM    W1OSBIT1,X'02'           HAVE WE USED LAST READ BUFFERS
         BO    SISSEA5                  NO, MOVE THEM TO USER Q
         B     SISSED5                  YES,GET BUFFERS FROM WRITE Q
         SPACE 3
*                                       WAIT FOR LAST READ
SISSEC4  LR    R6,R1                    SAVE R1
         LA    R1,W1ECBI
         LR    R3,R15                   SAVE R15
         WAIT  ECB=(1)
         LR    R15,R3                   RESTORE R15
         LR    R1,R6                    RESET R1
SISSEA5  LA    R3,W1US1ST
         LA    R4,W1RD1ST               MOVE READ QUEUE
         LH    R5,W1READC               BUFFERS TO USER QUEUE
         L     R10,CTSD(0,R15)
         AR    R10,R15
         BALR  R9,R10                   BRANCH TO Q ROUT AND RETURN
         SPACE 1
*           SET ON SCHEDULE BIT SO THAT AN ATTEMPT
*           TO SCHEDULE WILL BE MADE AT NEXT GET
*
         SPACE 2
         OIL   W1OSBIT2,SCHED,          SET SCHED BIT ON        YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10)                   YM03876
         SPACE 2
         NIL   W1OSBIT1,ONES-IOBIC,     SET IOBI COMP BIT TO    YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10) ZERO              YM03876
         SPACE 2
         CLI   W1USERC+1,X'00'          USER Q STILL EMPTY        7M265
         BE    SISSEG2                  YES--EXIT, EOF WAS READ   7M265
         B     SISSEF3
         SPACE 3
*                                       TO FILL USER Q BUFFERS MUST BE
*                                       OBTAINED FROM WRITE Q THROUGH
*                                       FREE TO READ TO USER QUEUES
SISSED5  TM    W1ECBO,X'40'             IS WAIT NECESSARY
         BO    SISSEE5                  NO
         LR    R6,R1                    YES, SAVE R1 AND R15
         LR    R3,R15
         WAIT  ECB=W1ECBO
         LR    R15,R3                   RESTORE R1 AND R15
         LR    R1,R6
SISSEE5  TM    W1OSBIT2,X'80'           ANY WRITE ERRORS
         BZ    SISSEE5A                 NO
         L     R11,CTSGE(R15)           YES, MUST GO TO EINFO NOW
         AR    R11,R15
         BALR  R9,R11                   GO TO EINFO
SISSEE5A LA    R3,W1FR1ST               MOVE WRITE Q TO FREE Q
         LA    R4,W1WR1ST
         LH    R5,W1WRITEC
         L     R10,CTSD(0,R15)          GO TO QUEUE ROUTINE
         AR    R10,R15
         BALR  R9,R10                   SET RETURN REG. FROM QUEUE
SISSEF5  TM    W1OSBIT1,X'40'           AT END OF DATA SET       A36373
         BO    SISSEG2                  YES-NO SCHED POSSIBLE    A36373
*                                       NOW HAVE FREE BUFS, SCHEDULE A
*                                       READ
         L     R11,CTSB(0,R15)          GET SCHED RTN OFFSET      7M265
         AR    R11,R15
         BALR  R9,R11                   BRANCH TO SCHEDULE INPUT
         TM    W1OSBIT2,X'04'           SCHEDULING SUCCESSFUL    A25968
         BO    SISSEC1A                 NO, USE PUTX Q BUFFERS   A25968
SISSEG5  TM    W1ECBI,X'40'             IS INPUT COMPLETED
         BO    SISSEA5                  YES
         B     SISSEC4                  WAIT
         DS    0F
         EJECT
*                                     ********************
*                                     *                  *
*                                     * SETC4 SUBROUTINE *
*                                     *                  *
*                                     ********************
         SPACE 1
         USING *,R11
SISCTSF  EQU  *
*
         SPACE 1
SISSFA2  L     R3,W1WR1ST
         NI    CN1,X'7F'                SET OFF MT BIT IN CP1 OF QUEUE
         ST    R3,W1FCPS                SET FCPS TO 1ST CP OF QUEUE
SISSFB2  CLI   CN3,X'08'                IS THE CN3 A TIC
         BE    SISSFB2A                 YES(CP22B)
*                                       NO (CP22A)
         MVI   CN3,X'0D'                SET THE CN3 OF CP22A TO WR KD
SISSFB2A MVI   CN4,X'05'                SET THE CN4 TO WR DATA
SISSFC2  TM    CN2+4,X'40'              IS THIS AN OVERFLOW RECORD
         BO    SISSFD3                  YES
*                                       NO
SISSFD2  CLC   CN6+7(1),DCBHIRPD        IS RECORD LAST OF TRACK
         BE    SISSFE3                  YES
         CLC   CN6+7(1),DCBHIRSH
         BE    SISSFE3                  YES
         CLC   CN5+1(3),LASTITEM        NO, ARE WE AT END OF QUEUE
         BE    SISSFE3                  YES
*                                       NO
         L     R8,CN5                   GET NEXT CHANNEL PROGRAM
         TM    12(R8),X'40'             IS THIS ONE AN OVERFLOW RCD
         BO    SISSFE3                  YES
         CLC   CN6(7),40(R8)            NEXT REC ON SAME TRACK    22662
         BNE   SISSFE3                  NO,BRANCH-CAN'T CHAIN CP  22662
SISSFF2  OI    CN4+4,X'40'              CHAIN THIS CP ON TO THE SET
SISSFH2  L     R3,CN5                   GET THE NEXT CHANNEL PROGRAM
         B     SISSFB2                  GO BACK TO CHANGE THIS CP
SISSFD3  NI    CN2+4,X'BF'              SET OFF OVERFLOW INDICATOR
SISSFE3  NI    CN4+4,X'BF'              INDIC. END OF SET.(OVFLO OR PD)
         CLC   CN5+1(3),LASTITEM       END OF Q
         BE    SISSFF4                  YES
*                                       NO
         L     R8,CN5                   GET THE NEXT CHANNEL PROGRAM
         NI    0(R8),X'7F'              SET OFF ITS MT BIT SINCE 1ST OF
         B     SISSFH2                  A SET
SISSFF4  L     R3,W1WR1ST               GET  CP1 ON WRITE QUEUE
         MVC   W1ODAD,CN6               SET IOB SEEK TO CN6 OF CP1
         MVC   W1OCPS,W1WR1ST           SET OCPS TO INITIATE THE WRITE
         BR    R9                      RETURN
LASTITEM DC    X'00000000'             CONSTANT TO TEST FOR END OF Q
         EJECT
         USING *,R11
SISCTSGC EQU   *                        ***************
*                                       *             *
*                                       * CHECK RTN   *
*                                       *             *
*                                       ***************
         SPACE 2
         SPACE
SISSGA2  L     R3,W1US1ST               1ST CP ON USER QUEUE
         TM    CN2+4,X'08'              INPUT ERROR
         BO    SISSGB3                  YES
*                                       NO
         TM    CN2+4,X'02'              UNREACHABLE BLOCK
         BO    SISSGC3                  YES
         BR    R9                       NO,RETURN RECORD IS OK
SISSGC3  OI    DCBEXCD1,X'02'           SET ON EXCD FOR UNREACHABLE BLK
         B     SISSGD3
SISSGB3  OI    DCBEXCD1,X'08'           SET ON EXCD FOR UNREADABLE BLK
SISSGD3  LA    R10,SISSGG4
         L     R11,CTSGE(R15)           SET UP EINFO BASE
         AR    R11,R15
         L     R4,W1CBF                 SO THAT BAD BUFFER WILL BE
*                                       POINTED TO
         BR    R10                      GO TO END OF EINFO RTN
         EJECT
         USING *,R11
SISCTSGE EQU   *                        ***************
*                                       *             *
*                                       * EINFO  RTN  *
*                                       *             *
*                                       ***************
         SPACE 2
SISSGF1  LR    R8,R9                    SAVE EXIT
SISSGF2  TM    W1WRITEC+1,X'FF'        IS WRITE Q EMPTY
         BZ    SISSGF3                  YES, ALL BAD RCDS TAKEN CARE OF
         L     R3,W1WR1ST               NO, CHECK 1ST WRITE Q BUFFER
         L     R4,CN7                   SET R4 TO BUFFER ADDRESS
         TM    CN2+4,X'04'              IS THIS RCD UNWRITEABLE
         BO    SISSGG3                  YES
*                                       NO
         TM    CN2+4,X'02'              IS BUFFER UNREACHABLE
         BZ    SISSGF21                 NO
         OI    DCBEXCD1,X'01'           YES, SET ON UNREACHABLE OP BIT
         B     SISSGG31
         SPACE
*                                       THIS BUFFER OK
SISSGF21 LA    R3,W1FR1ST               MOVE 1 BUFFER TO FREE Q
         LA    R5,1
         LA    R4,W1WR1ST
         L     R10,DCBDEBAD             DEB ADDRESS              S21045
         USING SISDEB,R10                                        S21045
         L     R10,DEBEXPTR             EXTENSION ADDRESS        S21045
         USING DEBEXT,R10                                        S21045
         L     R10,DEBGET               LOAD BASE                S21045
         DROP  R10                                               S21045
         A     R10,CTSD(R10)            ADD OFFSET
*              GO TO QUEUE ROUTINE
         BALR  R9,R10
         B     SISSGF2                  TEST NEXT CP
         SPACE 2
SISSGF3  NIL   W1OSBIT2,ONES-(UNWRITE+WAPBIT), SET OFF ERR IND  YM03876X
               REF=W1OSBIT1,WREGS=(R4,R9,R10) USER NOTIFIED     YM03876
         SPACE 2
         TM    DCBEXCD2,X'20'           DID CONTROL COME FROM CLOSE
         BCR   8,R8                    RETURN
SISSGF31 LM    R3,R4,W1CN11             LOAD CLOSE BASE AND ENTRY POINT
         LM    R5,R8,W1CN9              RESTORE REGS 5-8         A39794
         L     R15,DCBWKPT1             RESTORE DSECT BASE
         LR    R2,R1                    RESTORE DCB REGISTER      7M265
         BR    R4                       RETURN TO CLOSE
         SPACE 2
SISSGG3  OI    DCBEXCD1,X'04'           SET ON UNCORRECTABLE O/P ERROR
SISSGG31 NI    CN2+4,X'20'              SET OFF ALL FLAG BITS BUT D-KD
         EJECT
*        USED IN COMMON WITH CHECK TO SET INDICATORS FOR ERROR EXIT
         SPACE
SISSGG4  TM    DCBSYNAD+3,X'01'         DID USER SPECIFY A SYNAD RTN
         BZ    SISSGH4                  YES
         SPACE 2
*        TEST FOR NORMAL TASK TERMINATION.  IF IN TERMINATION, CLOSE
*        EXECUTOR IGG02029 WILL ISSUE DMABCOND MACRO TO CAUSE 031
*        ABEND AND WRITING OF MESSAGE IEC203I.
         SPACE 2
         L     R5,DCBDEBAD              DEB ADDRESS             YM06516
         LA    R5,0(R5)                 CLEAR HIGH ORDER BYTE   YM06516
         SH    R5,ISL8                  PT TO DEB EXTENSION PTR YM06516
         L     R5,0(R5)                 ADDRESS DEB EXTENSION   YM06516
         USING DEBXTN,R5                DEB EXT. ADDRESSABILITY YM06516
         TM    DEBXFLG1,DEBXTSKC        TASK CLOSE CLOSING DCB  YM06516
         BO    SISSGH4                  YES, GO TO 2029 FOR MSG YM07002
         DROP  R5                       END DEB EXTENSION USING YM06516
         SPACE 2
*
SISSGAB  ABEND X'031',DUMP,,SYSTEM      NO, GIVE 031 ABEND       Y02072
         SPACE
*                                       SET REGISTERS ACCORDING TO CPS
SISSGH4  L     R15,DCBSYNAD             SET R15 WITH ADDR OF SYNAD RTN
*        RESTORE FIRST 16 BYTES OF IOB FOR USER
         MVC   W1TEMPSA,CN5+4           SAVE FIRST FOUR IOB BYTES
         ST    R2,W1REGSV2              STORE ECB PTR           OZ05912
         MVC   W1REGSAV(8),CN6          SAVE BYTES 8 TO 16 OF IOB
         LA    R0,W1TEMPSA              POINT TO IO STATUS INDICATORS
         TM    DCBEXCD2,X'20'           WAS EINFO ENTERED FROM CLOSE
         BO    SISSGJ4                  YES, LET CLOSE GO TO USER
         LR    R1,R4                    POINT TO RCD OR BUFFER IN ERROR
         LM    R2,R12,28(R13)           RESTORE REGS
ERROUT   BR    R15                      GO TO SYNAD
SISSGJ4  L     R3,W1CN11                RESTORE CLOSE BASE
         L     R8,W1CN12                RETURN POINT
         L     R15,DCBWKPT1             SET BASE FOR WORKAREA
         LR    R2,R1                    RESTORE DCB REG FOR CLOSE 22662
         LR    R1,R4                    POINT TO BUFFER
         BR    R8                       RETURN TO CLOSE FOR SYNAD EXIT
         DS    0F
*
*                                  ***** CONSTANTS *****
         SPACE 4
CTSGE    EQU   12                       OFFSETS FOR INTER-CHART
CTSD     EQU   16                        COMMUNICATION
CTSB     EQU   20                                *
CTSF     EQU   24                                *
CTSE     EQU   28                               ***
CTSGC    EQU   32                                *
INCLOSE  EQU   X'20'                    ENTERED FROM CLOSE      YM05395
ISL8     DC    H'8'                     DECR DEB PTR TO EXT PTR YM06516
*
CLSESETL EQU   X'40'                    IND. CLOSE ISSUED ESETL YM03876
CYLIND   EQU   X'20'                    SAME CYLINDER INDICATOR YM03876
EOD      EQU   X'40'                    END OD DATA INDICATOR   YM03876
IOBIC    EQU   X'02'                    INPUT IOB COMPLETION    YM03876
IOBOC    EQU   X'01'                    OUTPUT IOB COMPLETION   YM03876
ONES     EQU   X'FF'                    MASK OF ALL ONES        YM03876
OVRFLOW  EQU   X'20'                    OVERFLOW RCD INDICATOR  YM03876
RELSE    EQU   X'02'                    RELEASE BUFFER IND.     YM03876
SCHED    EQU   X'04'                    SCHEDULING BIT          YM03876
SETLKBLK EQU   X'01'                    SETL K BLKD BIT         YM03876
SHRDTRK  EQU   X'10'                    SHARED TRK INDICATOR    YM03876
TRKINDX  EQU   X'10'                    READ TRK INDES IND.     YM03876
UNWRITE  EQU   X'80'                    UNWRITABLE RECORD       YM03876
WAPBIT   EQU   X'40'                    WRITE APPEND WORK BIT   YM03876
*
PATCH    DC    XL((*-IGG019HB)/20)'00'  ZEROED PATCH AREA        Y02072
*
         EJECT
SISWORK1 IGGSCAN                SCAN MODE WORK AREA              A35340
*                                  ****END OF FIXED LENGTH FIELDS ****
*                                  THE NO. OF CP 22'S IS DEPENDENT ON
*                                  THE NO. OF BUFFERS (DCBBUFNO)
         EJECT
SISCP22  DSECT
         IGGCP22
         EJECT
SISDEB   IGGDEBD
*                             ***********************************
DEBMODID DS    BL4                      2 BYTE IDS OF LOADED MODULES
DEBXTN   DSECT
DEBXLNGH  DS   H                        LENGTH DEB EXTENSION
DEBXFLG1  DS   B                        FLAG BYTE
DEBXTSKC EQU   X'40'                    TASK CLOSE CLOSING DCB
         EJECT
         DCBD  DSORG=(IS)
         END
