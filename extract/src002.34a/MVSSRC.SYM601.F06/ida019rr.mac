         TITLE 'IDA019RR - VSAM RELATIVE RECORD DRIVER                 *
                        '
IDA019RR CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00001-@MAINENT)
         DC    AL1(16)                                             0001
         DC    C'IDA019RR  78.172'                                 0001
IDARRDRL DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00270-IDARRDRL)
         ENTRY IDARRDRL
IDAGXCTL DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00415-IDAGXCTL)
         ENTRY IDAGXCTL
         DROP  @15
@PROLOG  BALR  @11,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@11                                         0001
         AH    @15,4(,@15)                                         0001
         BR    @15                                                 0001
@EP00001 DS    0H                                                  0002
         IDASVR14
*   PLHLRECL=AMDLRECL;              /* INIT. PLH REC. LENGTH.        */
         L     @10,AMBDSB(,RAMB)                                   0155
         L     @10,AMDLRECL(,@10)                                  0155
         ST    @10,PLHLRECL(,RPLH)                                 0155
*   IF AMBCREAT=ON&RPLREQ^=RPLPUT THEN/* CREATE MODE & NOT PUT     0156
*                                      REQUEST.                      */
         TM    AMBCREAT(RAMB),B'10000000'                          0156
         BNO   @RF00156                                            0156
         CLI   RPLREQ(RRPL),1                                      0156
         BE    @RF00156                                            0156
*     DO;                                                          0157
*       RPLERREG='08'X;             /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0158
*       RPLERRCD=RPLINLRQ;          /* SET INVALID CREATE REQ. ERROR.*/
         MVI   RPLERRCD(RRPL),X'74'                                0159
*       CALL MODEXIT;               /* EXIT FROM MODULE.             */
         BAL   @14,MODEXIT                                         0160
*     END;                                                         0161
*   IF RPLREQ=RPLPUT×RPLREQ=RPLERASE THEN/* PUT OR ERASE REQ.        */
@RF00156 CLI   RPLREQ(RRPL),1                                      0162
         BE    @RT00162                                            0162
         CLI   RPLREQ(RRPL),5                                      0162
         BNE   @RF00162                                            0162
@RT00162 DS    0H                                                  0163
*     DO;                                                          0163
*I01:                                                              0164
*       DO;                         /* IDACALL(IDA019RQ)             */
I01      DS    0H                                                  0165
*         CALL IDA019RQ;            /* EXIT TO IDA019RQ              */
         L     @15,@CV00909                                        0165
         BALR  @14,@15                                             0165
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I01;                    /* CALL PUT/ERASE ROUTINES.      */
*       CALL MODEXIT;               /* EXIT FROM MODULE.             */
         BAL   @14,MODEXIT                                         0171
*     END;                                                         0172
*                                                                  0173
*   /*****************************************************************/
*   /*                                                               */
*   /* GET SEQUENTIAL REQUEST ---                                    */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0173
*   IF RPLREQ=RPLGET&RPLSEQ=ON THEN /* GET SEQ REQUEST.              */
@RF00162 CLI   RPLREQ(RRPL),0                                      0173
         BNE   @RF00173                                            0173
         TM    RPLSEQ(RRPL),B'00100000'                            0173
         BNO   @RF00173                                            0173
*     DO;                           /* GET SEQ REQUEST.              */
*       IF PLHEFLGS=PLHVALID THEN   /* PLH IS VALID.                 */
         CLC   PLHEFLGS(2,RPLH),@CB00797                           0175
         BNE   @RF00175                                            0175
*         CALL ADVPLH;              /* ADVANCE TO NEXT RECORD.       */
         BAL   @14,ADVPLH                                          0176
*       ELSE                        /* PLH NOT VALID.                */
*         CALL PLHEXP;              /* PROCESS EXCEPTIONAL CONDITION */
         B     @RC00175                                            0177
@RF00175 BAL   @14,PLHEXP                                          0177
*       IF RPLERREG^='00'X THEN     /* ERROR OCCURRED.               */
@RC00175 CLI   RPLERREG(RRPL),0                                    0178
         BE    @RF00178                                            0178
*         CALL MODEXIT;             /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0179
*       PLHSAVE1=BUFCDDDD+PLHRECP-BUFCBAD;/* SET RECORD RBA.         */
@RF00178 L     @10,PLHDBUFC(,RPLH)                                 0180
         L     @05,BUFCDDDD(,@10)                                  0180
         AL    @05,PLHRECP(,RPLH)                                  0180
         SL    @05,BUFCBAD(,@10)                                   0180
         ST    @05,PLHSAVE1(,RPLH)                                 0180
*       IF RPLUPD=ON&BUFCEXC=OFF THEN/* UPD REQ & BUFFER NOT IN    0181
*                                      EXCLUSIVE CONTROL.            */
         TM    RPLUPD(RRPL),B'00000010'                            0181
         BNO   @RF00181                                            0181
         TM    BUFCEXC(@10),B'00000010'                            0181
         BNZ   @RF00181                                            0181
*         DO;                                                      0182
*           CALL IDAGXCTL;          /* GET BFR IN EXCL CONTROL.      */
         L     @15,@CA00914                                        0183
         BALR  @14,@15                                             0183
*           IF RPLERREG^='00'X THEN /* ERROR.                        */
         CLI   RPLERREG(RRPL),0                                    0184
         BE    @RF00184                                            0184
*             CALL MODEXIT;         /* EXIT FROM MODULE.             */
         BAL   @14,MODEXIT                                         0185
*         END;                                                     0186
@RF00184 DS    0H                                                  0187
*       PLHRRN=((PLHSAV1X/AMDCINV)*AMDNSLOT)+((PLHSAV1X//AMDCINV)/ 0187
*           PLHLRECL)+ONE;          /* CONVERT REC RBA TO REL. REC.
*                                      NO. AND SAVE          @ZA10887*/
@RF00181 L     @10,PLHKEYPT(,RPLH)                                 0187
         L     @05,PLHSAV1X(,RPLH)                                 0187
         L     @15,AMBDSB(,RAMB)                                   0187
         L     @14,AMDCINV(,@15)                                   0187
         LR    @07,@05                                             0187
         SLR   @06,@06                                             0187
         DR    @06,@14                                             0187
         M     @06,AMDNSLOT(,@15)                                  0187
         LR    @09,@05                                             0187
         SLR   @08,@08                                             0187
         DR    @08,@14                                             0187
         LR    @15,@08                                             0187
         SLR   @14,@14                                             0187
         D     @14,PLHLRECL(,RPLH)                                 0187
         ALR   @07,@15                                             0187
         AL    @07,@CF00053                                        0187
         ST    @07,PLHRRN(,@10)                                    0187
*       ARGFIELD=PLHRRN;            /* SET RRN IN RPL ARG.           */
         L     @10,RPLARG(,RRPL)                                   0188
         ST    @07,ARGFIELD(,@10)                                  0188
*       CALL COMGET;                /* PROCESS COMMON GET FUNCTION.  */
         BAL   @14,COMGET                                          0189
*       CALL MODEXIT;               /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0190
*     END;                          /* END GET SEQ REQUEST.          */
*                                                                  0192
*   /*****************************************************************/
*   /*                                                               */
*   /* GET SKIP/DIRECT REQUEST ---                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0192
*   IF RPLREQ=RPLGET THEN           /* GET REQ-HAS TO BE SKP/DIR.    */
@RF00173 CLI   RPLREQ(RRPL),0                                      0192
         BNE   @RF00192                                            0192
*     DO;                           /* GET SKP/DIR REQUEST.          */
*       IF RPLSKP=ON&RPLBWD=ON THEN /* SKP & BWD REQUEST.            */
         TM    RPLSKP(RRPL),B'00010000'                            0194
         BNO   @RF00194                                            0194
         TM    RPLBWD(RRPL),B'00010000'                            0194
         BNO   @RF00194                                            0194
*         DO;                       /* SKP NOT ALLOWED IN BWD MODE.  */
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0196
*           RPLERRCD=RPLINVP;       /* SET INVALID RPL OPTIONS ERROR.*/
         MVI   RPLERRCD(RRPL),X'68'                                0197
*           CALL MODEXIT;           /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0198
*         END;                                                     0199
*       IF RPLLRD=ON THEN           /* LAST RECORD SPECIFIED.        */
@RF00194 TM    RPLLRD(RRPL),B'00001000'                            0200
         BNO   @RF00200                                            0200
*         DO;                       /* SEARCH FOR LAST RECORD.       */
*           IF RPLBWD=OFF THEN      /* FORWARD DIRECTION.            */
         TM    RPLBWD(RRPL),B'00010000'                            0202
         BNZ   @RF00202                                            0202
*             DO;                   /* LRD & FWD NOT ALLOWED.        */
*               RPLERREG='08'X;     /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0204
*               RPLERRCD=RPLINVP;   /* SET INVALID RPL OPTIONS ERROR.*/
         MVI   RPLERRCD(RRPL),X'68'                                0205
*               CALL MODEXIT;       /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0206
*             END;                  /* END LRD/BWD ERROR.            */
*           CALL LRD;               /* POSITION TO LAST RECORD.      */
@RF00202 BAL   @14,LRD                                             0208
*         END;                      /* END SEARCH LAST RECORD.       */
*       ELSE                        /* LAST RECORD NOT SPECIFIED.    */
*         DO;                       /* PROCESS GET WITH ARD.         */
         B     @RC00200                                            0210
@RF00200 DS    0H                                                  0211
*           IF ARGFIELD=ZERO×ARGFIELD>AMDMAXRR THEN/* INVALID RRN.   */
         L     @10,RPLARG(,RRPL)                                   0211
         L     @10,ARGFIELD(,@10)                                  0211
         LTR   @10,@10                                             0211
         BZ    @RT00211                                            0211
         L     @05,AMBDSB(,RAMB)                                   0211
         CL    @10,AMDMAXRR(,@05)                                  0211
         BNH   @RF00211                                            0211
@RT00211 DS    0H                                                  0212
*             DO;                                                  0212
*               RPLERREG='08'X;     /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0213
*               RPLERRCD=RPLIRRNO;  /* SET INVALID RRN ERROR.        */
         MVI   RPLERRCD(RRPL),X'C0'                                0214
*               CALL MODEXIT;       /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0215
*             END;                                                 0216
*           PLHSAVE1=AMDCINV*((ARGFIELD-ONE)/AMDNSLOT)+PLHLRECL*(( 0217
*               ARGFIELD-ONE)//AMDNSLOT);/* CONVERT RRN TO RBA.      */
@RF00211 L     @10,AMBDSB(,RAMB)                                   0217
         L     @05,RPLARG(,RRPL)                                   0217
         L     @05,ARGFIELD(,@05)                                  0217
         BCTR  @05,0                                               0217
         L     @15,AMDNSLOT(,@10)                                  0217
         LR    @07,@05                                             0217
         SLR   @06,@06                                             0217
         DR    @06,@15                                             0217
         M     @06,AMDCINV(,@10)                                   0217
         LR    @09,@05                                             0217
         SLR   @08,@08                                             0217
         DR    @08,@15                                             0217
         LR    @15,@08                                             0217
         M     @14,PLHLRECL(,RPLH)                                 0217
         ALR   @07,@15                                             0217
         ST    @07,PLHSAVE1(,RPLH)                                 0217
*           CALL IDARRDRL;          /* CALL DIRECT RECORD LOCATE.    */
         L     @15,@CA00913                                        0218
         BALR  @14,@15                                             0218
*         END;                      /* END POINT WITH ARD.           */
*       IF RPLERREG^='00'X THEN     /* ERROR.                        */
@RC00200 CLI   RPLERREG(RRPL),0                                    0220
         BE    @RF00220                                            0220
*         CALL MODEXIT;             /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0221
*       IF RPLBWD=OFF THEN          /* FORWARD DIRECTION.            */
@RF00220 TM    RPLBWD(RRPL),B'00010000'                            0222
         BNZ   @RF00222                                            0222
*         PLHBWD=OFF;               /* SAVE IN PLH.                  */
         NI    PLHBWD(RPLH),B'11101111'                            0223
*       ELSE                        /* BACKWARD DIRECTION.           */
*         PLHBWD=ON;                /* SAVE IN PLH.                  */
         B     @RC00222                                            0224
@RF00222 OI    PLHBWD(RPLH),B'00010000'                            0224
*       IF RPLLRD=OFF THEN          /* NOT LRD.                      */
@RC00222 TM    RPLLRD(RRPL),B'00001000'                            0225
         BNZ   @RF00225                                            0225
*         PLHRRN=ARGFIELD;          /* SAVE ARG RRN IN PLH.          */
         L     @10,PLHKEYPT(,RPLH)                                 0226
         L     @05,RPLARG(,RRPL)                                   0226
         L     @05,ARGFIELD(,@05)                                  0226
         ST    @05,PLHRRN(,@10)                                    0226
*       CALL COMGET;                /* PROCESS COMMON GET FUNCTION.  */
@RF00225 BAL   @14,COMGET                                          0227
*       CALL MODEXIT;               /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0228
*     END;                          /* END GET SKP/DIR REQUEST.      */
*                                                                  0230
*   /*****************************************************************/
*   /*                                                               */
*   /* POINT REQUEST ---                                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0230
*   IF RPLREQ=RPLPOINT THEN         /* POINT REQUEST.                */
@RF00192 CLI   RPLREQ(RRPL),3                                      0230
         BNE   @RF00230                                            0230
*     DO;                           /* PROCESS POINT REQUEST.        */
*       IF RPLLRD=ON THEN           /* LAST RECORD SPECIFIED.        */
         TM    RPLLRD(RRPL),B'00001000'                            0232
         BNO   @RF00232                                            0232
*         DO;                       /* SEARCH FOR LAST RECORD.       */
*           IF RPLBWD=OFF THEN      /* FORWARD DIRECTION.            */
         TM    RPLBWD(RRPL),B'00010000'                            0234
         BNZ   @RF00234                                            0234
*             DO;                   /* LRD & FWD NOT ALLOWED.        */
*               RPLERREG='08'X;     /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0236
*               RPLERRCD=RPLINVP;   /* SET INVALID RPL OPTIONS ERROR.*/
         MVI   RPLERRCD(RRPL),X'68'                                0237
*               CALL MODEXIT;       /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0238
*             END;                  /* END LRD/BWD ERROR.            */
*           CALL LRD;               /* POSITION TO LAST RECORD.      */
@RF00234 BAL   @14,LRD                                             0240
*         END;                      /* END SEARCH LAST RECORD.       */
*       ELSE                        /* LAST RECORD NOT SPECIFIED.    */
*         DO;                       /* PROCESS POINT WITH ARD.       */
         B     @RC00232                                            0242
@RF00232 DS    0H                                                  0243
*           IF ARGFIELD=ZERO×ARGFIELD>AMDMAXRR THEN/* INVALID RRN.   */
         L     @10,RPLARG(,RRPL)                                   0243
         L     @10,ARGFIELD(,@10)                                  0243
         LTR   @10,@10                                             0243
         BZ    @RT00243                                            0243
         L     @05,AMBDSB(,RAMB)                                   0243
         CL    @10,AMDMAXRR(,@05)                                  0243
         BNH   @RF00243                                            0243
@RT00243 DS    0H                                                  0244
*             DO;                                                  0244
*               RPLERREG='08'X;     /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0245
*               RPLERRCD=RPLIRRNO;  /* SET INVALID RRN ERROR.        */
         MVI   RPLERRCD(RRPL),X'C0'                                0246
*               CALL MODEXIT;       /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0247
*             END;                                                 0248
*           PLHSAVE1=AMDCINV*((ARGFIELD-ONE)/AMDNSLOT)+PLHLRECL*(( 0249
*               ARGFIELD-ONE)//AMDNSLOT);/* CONVERT RRN TO RBA.      */
@RF00243 L     @10,AMBDSB(,RAMB)                                   0249
         L     @05,RPLARG(,RRPL)                                   0249
         L     @05,ARGFIELD(,@05)                                  0249
         BCTR  @05,0                                               0249
         L     @15,AMDNSLOT(,@10)                                  0249
         LR    @07,@05                                             0249
         SLR   @06,@06                                             0249
         DR    @06,@15                                             0249
         M     @06,AMDCINV(,@10)                                   0249
         LR    @09,@05                                             0249
         SLR   @08,@08                                             0249
         DR    @08,@15                                             0249
         LR    @15,@08                                             0249
         M     @14,PLHLRECL(,RPLH)                                 0249
         ALR   @07,@15                                             0249
         ST    @07,PLHSAVE1(,RPLH)                                 0249
*           CALL IDARRDRL;          /* CALL DIRECT RECORD LOCATE.    */
         L     @15,@CA00913                                        0250
         BALR  @14,@15                                             0250
*         END;                      /* END POINT WITH ARD.           */
*       IF RPLERREG^='00'X&RPLERRCD^=RPLEODER THEN/* ERROR, BUT NOT
*                                      END-OF-DATA.                  */
@RC00232 CLI   RPLERREG(RRPL),0                                    0252
         BE    @RF00252                                            0252
         CLI   RPLERRCD(RRPL),4                                    0252
         BE    @RF00252                                            0252
*         CALL MODEXIT;             /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0253
*       PLHNOADV=ON;                /* SET PLH NO ADVANCE.           */
@RF00252 OI    PLHNOADV(RPLH),B'00001000'                          0254
*       PLHUPD=OFF;                 /* TURN OFF GET UPDATE FLAG.     */
         NI    PLHUPD(RPLH),B'01111111'                            0255
*       IF RPLBWD=OFF THEN          /* FORWARD DIRECTION.            */
         TM    RPLBWD(RRPL),B'00010000'                            0256
         BNZ   @RF00256                                            0256
*         PLHBWD=OFF;               /* SAVE IN PLH.                  */
         NI    PLHBWD(RPLH),B'11101111'                            0257
*       ELSE                        /* BACKWARD DIRECTION.           */
*         PLHBWD=ON;                /* SAVE IN PLH.                  */
         B     @RC00256                                            0258
@RF00256 OI    PLHBWD(RPLH),B'00010000'                            0258
*       IF RPLLRD=OFF THEN          /* NOT LAST RECORD.              */
@RC00256 TM    RPLLRD(RRPL),B'00001000'                            0259
         BNZ   @RF00259                                            0259
*         PLHRRN=ARGFIELD;          /* SAVE ARG RRN IN PLH.          */
         L     @10,PLHKEYPT(,RPLH)                                 0260
         L     @05,RPLARG(,RRPL)                                   0260
         L     @05,ARGFIELD(,@05)                                  0260
         ST    @05,PLHRRN(,@10)                                    0260
*       RPLDDDD=PLHSAVE1;           /* SET RECORD RBA IN RPL.        */
@RF00259 L     @10,PLHSAVE1(,RPLH)                                 0261
         ST    @10,RPLDDDD(,RRPL)                                  0261
*       PLHRCODE=RPLREQ;            /* SAVE REQUEST CODE.            */
         IC    @10,RPLREQ(,RRPL)                                   0262
         STC   @10,PLHRCODE(,RPLH)                                 0262
*       CALL MODEXIT;               /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0263
*     END;                          /* END POINT REQUEST.            */
*                                                                  0265
*   /*****************************************************************/
*   /*                                                               */
*   /* INVALID REQUEST ---                                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0265
*   ELSE                            /* INVALID REQUEST.              */
*     DO;                           /* SET INVALID REQUEST ERROR.    */
         B     @RC00230                                            0265
@RF00230 DS    0H                                                  0266
*       RPLERREG='08'X;             /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0266
*       RPLERRCD=RPLINVP;           /* SET INVALID REQUEST.          */
         MVI   RPLERRCD(RRPL),X'68'                                0267
*       CALL MODEXIT;               /* RETURN FROM MODULE.           */
         BAL   @14,MODEXIT                                         0268
*     END;                          /* END INVALID REQ. ERROR.       */
*                                                                  0269
*   /*****************************************************************/
*   /*                                                               */
*   /* END OF VSAM RELATIVE RECORD DRIVER HI-LEVEL.                  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0270
*IDARRDRL:                                                         0270
*                                                                  0270
*   /*****************************************************************/
*   /*                                                               */
*   /* DIRECT RECORD LOCATE ROUTINE --- RETRIEVES CI OF REQUESTED RBA*/
*   /* FOR GET, PUT, OR POINT REQUEST. PERFORMS SEQUENCE CHECK IF SKP*/
*   /* REQUEST. IF POINT KGE & RBA IS GT HURBA, SETS END-OF- DATA. IF*/
*   /* POINT KGE & SLOT IS EMPTY SEARCHES FORWARD FOR NEXT VALID     */
*   /* RECORD. IF GET & SLOT IS EMPTY SETS NO RECORD FOUND ERROR. ---*/
*   /* INPUT - PLHSAVE1 = RBA OF RECORD TO BE RETRIEVED, RPL ARG(IF  */
*   /* SKP REQ) = RRN OF REQUESTED RECORD, PLHDBUFC = CURRENT DATA   */
*   /* BUFC, PLHRRN(IF SKP REQ) = PREVIOUS REQUEST RRN. --- OUTPUT - */
*   /* PLHDBUFC = BUFC OF RETRIEVED RECORD, PLHRECP, PLHFSP, PLHRDF =*/
*   /* POINTER TO REQUESTED RECORD IN DATA BUFFER.                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0270
*   ENTRY;                                                         0270
@EP00270 DS    0H                                                  0270
@EC00270 DS    0H                                                  0271
*   GEN(IDASVR14);                  /* SAVE REGISTER 14.             */
         IDASVR14
*   IF PLHINVAL=OFF&RPLSKP=ON&RPLREQ^=RPLPOINT&PLH1ST=OFF&PLHBWD=OFF
*     THEN                          /* VALID POSITION & SKP & NOT  0272
*                                      POINT & NOT 1ST REQ & NOT PREV
*                                      BWD                           */
         TM    PLHINVAL(RPLH),B'00000010'                          0272
         BNZ   @RF00272                                            0272
         TM    RPLSKP(RRPL),B'00010000'                            0272
         BNO   @RF00272                                            0272
         CLI   RPLREQ(RRPL),3                                      0272
         BE    @RF00272                                            0272
         TM    PLH1ST(RPLH),B'01000000'                            0272
         BNZ   @RF00272                                            0272
         TM    PLHBWD(RPLH),B'00010000'                            0272
         BNZ   @RF00272                                            0272
*     DO;                           /* SEQUENCE CHECK REQ.           */
*       IF ARGFIELD<PLHRRN THEN     /* ARG RRN IS LT PREV RRN.       */
         L     @10,RPLARG(,RRPL)                                   0274
         L     @05,PLHKEYPT(,RPLH)                                 0274
         CLC   ARGFIELD(4,@10),PLHRRN(@05)                         0274
         BNL   @RF00274                                            0274
*         DO;                                                      0275
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0276
*           RPLERRCD=RPLSEQCK;      /* SET SEQUENCE ERROR.           */
         MVI   RPLERRCD(RRPL),X'0C'                                0277
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0278
*         END;                                                     0279
*       ELSE                        /* ARG RRN IS GTE PREV RRN.      */
*         IF ARGFIELD=PLHRRN THEN   /* ARG RRN IS EQ PREV RRN.       */
         B     @RC00274                                            0280
@RF00274 L     @10,RPLARG(,RRPL)                                   0280
         L     @05,PLHKEYPT(,RPLH)                                 0280
         CLC   ARGFIELD(4,@10),PLHRRN(@05)                         0280
         BNE   @RF00280                                            0280
*           IF PLHRCODE^=RPLPOINT&^(RPLREQ=RPLPUT&PLHRCODE=RPLERASE)
*             THEN                  /* NOT PREV POINT & NOT PUT &  0281
*                                      PREV ERASE.                   */
         CLI   PLHRCODE(RPLH),3                                    0281
         BE    @RF00281                                            0281
         CLI   RPLREQ(RRPL),1                                      0281
         BNE   @RT00281                                            0281
         CLI   PLHRCODE(RPLH),5                                    0281
         BE    @RF00281                                            0281
@RT00281 DS    0H                                                  0282
*             DO;                                                  0282
*               RPLERREG='08'X;     /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0283
*               RPLERRCD=RPLSEQCK;  /* SET SEQUENCE ERROR.           */
         MVI   RPLERRCD(RRPL),X'0C'                                0284
*               CALL EXIT;          /* RETURN.                       */
         BAL   @14,EXIT                                            0285
*             END;                                                 0286
*     END;                          /* END SEQUENCE CHECK REQ.       */
@RF00281 DS    0H                                                  0287
@RF00280 DS    0H                                                  0287
@RC00274 DS    0H                                                  0288
*   PLHASKBF=ON;                    /* SET PLH ASK BUFFER.           */
@RF00272 OI    PLHASKBF(RPLH),B'00100000'                          0288
*   IF PLHSAVE1>=ARDHRBA THEN       /* REQ IS PAST END OF DATA SET.  */
         L     @10,AMBDSB(,RAMB)                                   0289
         L     @10,AMDPARDB(,@10)                                  0289
         CLC   PLHSAVE1(4,RPLH),ARDHRBA(@10)                       0289
         BL    @RF00289                                            0289
*     DO;                                                          0290
*       RPLERREG='08'X;             /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0291
*       IF RPLREQ=RPLPOINT&RPLKGE=ON&RPLBWD=OFF THEN/* POINT KGE FWD.*/
         CLI   RPLREQ(RRPL),3                                      0292
         BNE   @RF00292                                            0292
         TM    RPLKGE(RRPL),B'00000100'                            0292
         BNO   @RF00292                                            0292
         TM    RPLBWD(RRPL),B'00010000'                            0292
         BNZ   @RF00292                                            0292
*         DO;                                                      0293
*           RPLERRCD=RPLEODER;      /* SET EOD ERROR.                */
         MVI   RPLERRCD(RRPL),X'04'                                0294
*           PLHEFLGS=PLHVALID;      /* MAKE PLH VALID.               */
         MVC   PLHEFLGS(2,RPLH),@CB00797                           0295
*           PLHRSTRT=ON;            /* SET PLH RESTART FLAG.         */
         OI    PLHRSTRT(RPLH),B'10000000'                          0296
*         END;                                                     0297
*       ELSE                        /* NOT POINT KGE FWD.            */
*         DO;                                                      0298
         B     @RC00292                                            0298
@RF00292 DS    0H                                                  0299
*           RPLERRCD=RPLNOREC;      /* SET NO RECORD FOUND ERROR.    */
         MVI   RPLERRCD(RRPL),X'10'                                0299
*           PLHINVAL=ON;            /* MAKE PLH INVALID.             */
         OI    PLHINVAL(RPLH),B'00000010'                          0300
*         END;                                                     0301
*       CALL EXIT;                  /* RETURN.                       */
@RC00292 BAL   @14,EXIT                                            0302
*     END;                                                         0303
*   IF RPLREQ=RPLPOINT&RPLSEQ=ON THEN/* POINT SEQ REQ.               */
@RF00289 CLI   RPLREQ(RRPL),3                                      0304
         BNE   @RF00304                                            0304
         TM    RPLSEQ(RRPL),B'00100000'                            0304
         BNO   @RF00304                                            0304
*     DO;                                                          0305
*       RPARM1=ZERO;                /* ADD MAX NO. OF BFRS.          */
         SLR   RPARM1,RPARM1                                       0306
*I02:                                                              0307
*       DO;                         /* IDACALL(IDAABF)               */
I02      DS    0H                                                  0308
*         CALL IDAABF;              /* EXIT TO IDAABF                */
         L     @15,@CV00904                                        0308
         BALR  @14,@15                                             0308
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I02;                    /* CALL ADD BUFFER.              */
*     END;                                                         0314
*   IF RPLUPD=ON×RPLREQ=RPLPUT THEN /* UPDATE OR PUT REQUEST.        */
@RF00304 TM    RPLUPD(RRPL),B'00000010'                            0315
         BO    @RT00315                                            0315
         CLI   RPLREQ(RRPL),1                                      0315
         BNE   @RF00315                                            0315
@RT00315 DS    0H                                                  0316
*     PLHRDEXC=ON;                  /* SET PLH READ EXCLUSIVE.       */
         OI    PLHRDEXC(RPLH),B'00001000'                          0316
*   ELSE                            /* NOT UPDATE REQUEST.           */
*     PLHRDEXC=OFF;                 /* CLEAR PLH READ EXCLUSIVE.     */
         B     @RC00315                                            0317
@RF00315 NI    PLHRDEXC(RPLH),B'11110111'                          0317
*   RPLDDDD=PLHSAV1X-(PLHSAV1X//AMDCINV);/* CI RBA OF REQ. RECORD. 0318
*                                                            @ZA10887*/
@RC00315 L     @10,PLHSAV1X(,RPLH)                                 0318
         L     @05,AMBDSB(,RAMB)                                   0318
         LR    @07,@10                                             0318
         SLR   @06,@06                                             0318
         D     @06,AMDCINV(,@05)                                   0318
         SLR   @10,@06                                             0318
         ST    @10,RPLDDDD(,RRPL)                                  0318
*   IF AMBSPEED=ON&RPLREQ=RPLPUT THEN/* SPEED & PUT REQ.             */
         TM    AMBSPEED(RAMB),B'00001000'                          0319
         BNO   @RF00319                                            0319
         CLI   RPLREQ(RRPL),1                                      0319
         BNE   @RF00319                                            0319
*     DO;                           /* BUFFER FOR SPEED MODE.        */
*       IF^(BUFCDDDD=RPLDDDD&BUFCMW=ON&BUFCVAL=ON) THEN/* BUFFER   0321
*                                      DOESN'T CONTAIN CI OR HAS BEEN
*                                      WRITTEN.                      */
         L     @05,PLHDBUFC(,RPLH)                                 0321
         CL    @10,BUFCDDDD(,@05)                                  0321
         BNE   @RT00321                                            0321
         TM    BUFCMW(@05),B'10000000'                             0321
         BNO   @RT00321                                            0321
         TM    BUFCVAL(@05),B'00000100'                            0321
         BO    @RF00321                                            0321
@RT00321 DS    0H                                                  0322
*         DO;                       /* CI NOT IN CURRENT BUFFER.     */
*           IF BUFCINS=ON THEN      /* CUR. BUFC IS INSERT BUFC.     */
         L     @10,PLHDBUFC(,RPLH)                                 0323
         TM    BUFCINS(@10),B'00100000'                            0323
         BNO   @RF00323                                            0323
*             DO;                                                  0324
*               RBUFC=PLHDBUFC;     /* POINT TO CURRENT BUFC.        */
         LR    RBUFC,@10                                           0325
*I03:                                                              0326
*               DO;                 /* IDACALL(IDASBF)               */
I03      DS    0H                                                  0327
*                 CALL IDASBF;      /* EXIT TO IDASBF                */
         L     @15,@CV00911                                        0327
         BALR  @14,@15                                             0327
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I03;            /* SUBTRACT INSERT BUFC.         */
*             END;                                                 0333
*           ELSE                    /* CUR. BUFC IS NOT INSERT BUFC. */
*             IF PLHBFRNO>ONE THEN  /* NO. BUFFERS GT 1.             */
         B     @RC00323                                            0334
@RF00323 CLI   PLHBFRNO(RPLH),1                                    0334
         BNH   @RF00334                                            0334
*               DO;                                                0335
*                 PLHDBUFC=BUFCNXT2;/* POINT TO NEXT LOG. BUFC TO  0336
*                                      FORMAT WRT BFRS IN CORRECT  0336
*                                      SEQUENCE.                     */
         L     @10,PLHDBUFC(,RPLH)                                 0336
         L     @10,BUFCNXT2-1(,@10)                                0336
         LA    @10,0(,@10)                                         0336
         ST    @10,PLHDBUFC(,RPLH)                                 0336
*                 RBUFC=PLHDBUFC;   /* POINT TO CUR BUFC.            */
         LR    RBUFC,@10                                           0337
*I04:                                                              0338
*                 DO;               /* IDACALL(IDAWRBFR)             */
I04      DS    0H                                                  0339
*                   CALL IDAWRBFR;  /* EXIT TO IDAWRBFR              */
         L     @15,@CV00907                                        0339
         BALR  @14,@15                                             0339
*                   GEN(BALR @11,0);/* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                   GEN(USING *,@11);/* ESTABLISH ADDRESSING         */
         USING *,@11
*                   GEN(L     @11,=A(@PSTART));/* RELOAD BASE        */
         L     @11,=A(@PSTART)
*                   GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING   */
         USING @PSTART,@11
*                 END I04;          /* WRT BUFFERS TO INSURE NORMAL
*                                      BFR CHAIN GETS WRITTEN.       */
*               END;                                               0345
*           IF RPLERREG^='00'X THEN /* ERROR.                        */
@RF00334 DS    0H                                                  0346
@RC00323 CLI   RPLERREG(RRPL),0                                    0346
         BE    @RF00346                                            0346
*             DO;                                                  0347
*               PLHINVAL=ON;        /* SET PLH INVALID.              */
         OI    PLHINVAL(RPLH),B'00000010'                          0348
*               CALL EXIT;          /* RETURN.                       */
         BAL   @14,EXIT                                            0349
*             END;                                                 0350
*           IF PLHSAVE1<PLHHIREC THEN/* CUR RBA LT HI-REC RBA.       */
@RF00346 CLC   PLHSAVE1(4,RPLH),PLHHIREC(RPLH)                     0351
         BNL   @RF00351                                            0351
*             DO;                                                  0352
*I05:                                                              0353
*               DO;                 /* IDACALL(IDAAIBF)              */
I05      DS    0H                                                  0354
*                 CALL IDAAIBF;     /* EXIT TO IDAAIBF               */
         L     @15,@CV00910                                        0354
         BALR  @14,@15                                             0354
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I05;            /* ADD INSERT BUFFER.            */
*               PLHDBUFC=RBUFC;     /* POINT PLH TO INSERT BUFC.     */
         ST    RBUFC,PLHDBUFC(,RPLH)                               0360
*               BUFCINS=ON;         /* SET INSERT BFR FLAG BACK ON.  */
         L     @10,PLHDBUFC(,RPLH)                                 0361
         OI    BUFCINS(@10),B'00100000'                            0361
*             END;                                                 0362
*         END;                      /* END CI NOT IN CUR BFR.        */
@RF00351 DS    0H                                                  0364
*     END;                          /* END BUFFER FOR SPEED MODE.    */
@RF00321 DS    0H                                                  0365
*   RPARM1=RPLDDDD;                 /* SET CI RBA OF REQ RECORD.     */
@RF00319 L     RPARM1,RPLDDDD(,RRPL)                               0365
*I06:                                                              0366
*   DO;                             /* IDACALL(IDAGRB)               */
I06      DS    0H                                                  0367
*     CALL IDAGRB;                  /* EXIT TO IDAGRB                */
         L     @15,@CV00906                                        0367
         BALR  @14,@15                                             0367
*     GEN(BALR @11,0);              /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*     GEN(USING *,@11);             /* ESTABLISH ADDRESSING          */
         USING *,@11
*     GEN(L     @11,=A(@PSTART));   /* RELOAD BASE                   */
         L     @11,=A(@PSTART)
*     GEN(USING @PSTART,@11);       /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*   END I06;                        /* GET CI OF REQ RBA.            */
*   IF RPLERREG^='00'X THEN         /* ERROR.                        */
         CLI   RPLERREG(RRPL),0                                    0373
         BE    @RF00373                                            0373
*     DO;                                                          0374
*       PLHINVAL=ON;                /* SET PLH INVALID.              */
         OI    PLHINVAL(RPLH),B'00000010'                          0375
*       CALL EXIT;                  /* RETURN.                       */
         BAL   @14,EXIT                                            0376
*     END;                                                         0377
*   RFY                                                            0378
*     RWORK1 RSTD;                  /* GET WORK REG.                 */
@RF00373 DS    0H                                                  0379
*   RWORK1=PLHSAVE1-BUFCDDDD;       /* OFFSET INTO CI.               */
         L     @10,PLHDBUFC(,RPLH)                                 0379
         L     RWORK1,PLHSAVE1(,RPLH)                              0379
         SL    RWORK1,BUFCDDDD(,@10)                               0379
*   PLHRDFP=BUFCBAD+AMDCINV-LENGTH(IDACIDF)-(((RWORK1/PLHLRECL)+ONE)*
*       LENGTH(IDARDF));            /* POINT TO RDF OF REQ. RECORD   */
         L     @10,BUFCBAD(,@10)                                   0380
         L     @15,AMBDSB(,RAMB)                                   0380
         LR    @00,@10                                             0380
         AL    @00,AMDCINV(,@15)                                   0380
         SL    @00,@CF00067                                        0380
         L     @14,PLHLRECL(,RPLH)                                 0380
         LR    @07,RWORK1                                          0380
         SLR   @06,@06                                             0380
         DR    @06,@14                                             0380
         AL    @07,@CF00053                                        0380
         MH    @07,@CH00157                                        0380
         SLR   @00,@07                                             0380
         ST    @00,PLHRDFP(,RPLH)                                  0380
*   PLHRECP=BUFCBAD+RWORK1;         /* POINT TO REQ. RECORD.         */
         LR    @09,RWORK1                                          0381
         ALR   @09,@10                                             0381
         ST    @09,PLHRECP(,RPLH)                                  0381
*   PLHFSP=BUFCBAD+(AMDNSLOT*PLHLRECL);/* POINT TO PLH FSP.          */
         LR    @07,@14                                             0382
         M     @06,AMDNSLOT(,@15)                                  0382
         ALR   @10,@07                                             0382
         ST    @10,PLHFSP(,RPLH)                                   0382
*   RFY                                                            0383
*     RWORK1 UNRSTD;                /* FREE WORK REG.                */
*   IF RPLREQ^=RPLPUT&RDFEMPTY=ON&PLHDSCAN=OFF THEN/* NOT PUT REQ. &
*                                      EMPTY REC & NOT PREV RD EXCL
*                                      ERR                           */
         CLI   RPLREQ(RRPL),1                                      0384
         BE    @RF00384                                            0384
         LR    @10,@00                                             0384
         TM    RDFEMPTY(@10),B'00000100'                           0384
         BNO   @RF00384                                            0384
         TM    PLHDSCAN(RPLH),B'00000001'                          0384
         BNZ   @RF00384                                            0384
*     DO;                           /* SEARCH FOR RECORD.            */
*       IF^(RPLREQ=RPLPOINT&RPLKGE=ON&RPLBWD=OFF) THEN/* NOT POINT 0386
*                                      KGE FWD REQ.                  */
         CLI   RPLREQ(RRPL),3                                      0386
         BNE   @RT00386                                            0386
         TM    RPLKGE(RRPL),B'00000100'                            0386
         BNO   @RT00386                                            0386
         TM    RPLBWD(RRPL),B'00010000'                            0386
         BZ    @RF00386                                            0386
@RT00386 DS    0H                                                  0387
*         DO;                                                      0387
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0388
*           RPLERRCD=RPLNOREC;      /* SET NO RECORD FOUND ERROR.    */
         MVI   RPLERRCD(RRPL),X'10'                                0389
*           PLHINVAL=ON;            /* SET PLH INVALID.              */
         OI    PLHINVAL(RPLH),B'00000010'                          0390
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0391
*         END;                                                     0392
*RECSRCH:                                                          0393
*       PLHRECP=PLHRECP+PLHLRECL;   /* POINT TO NEXT RECORD.         */
@RF00386 DS    0H                                                  0393
RECSRCH  L     @10,PLHRECP(,RPLH)                                  0393
         AL    @10,PLHLRECL(,RPLH)                                 0393
         ST    @10,PLHRECP(,RPLH)                                  0393
*       IF PLHRECP=>PLHFSP THEN     /* END OF CI.                    */
         C     @10,PLHFSP(,RPLH)                                   0394
         BL    @RF00394                                            0394
*         DO;                                                      0395
*           PLHRAHD=ON;             /* ALLOW READ AHEAD.             */
         OI    PLHRAHD(RPLH),B'01000000'                           0396
*           CALL ADVCI;             /* ADVANCE TO NEXT CI & SEARCH 0397
*                                      FOR RECORD.                   */
         BAL   @14,ADVCI                                           0397
*           PLHRAHD=OFF;            /* RESET READ AHEAD FLAG.        */
         NI    PLHRAHD(RPLH),B'10111111'                           0398
*         END;                                                     0399
*       ELSE                        /* NOT END OF CI.                */
*         DO;                                                      0400
         B     @RC00394                                            0400
@RF00394 DS    0H                                                  0401
*           PLHRDFP=PLHRDFP-LENGTH(IDARDF);/* POINT TO NEXT RDF.     */
         L     @10,PLHRDFP(,RPLH)                                  0401
         SL    @10,@CF00157                                        0401
         ST    @10,PLHRDFP(,RPLH)                                  0401
*           IF RDFEMPTY=ON THEN     /* EMPTY RECORD.                 */
         TM    RDFEMPTY(@10),B'00000100'                           0402
         BO    @RT00402                                            0402
*             GOTO RECSRCH;         /* CONTINUE SEARCH.              */
*         END;                                                     0404
*       IF RPLERREG='00'X×(RPLERREG='08'X&RPLERRCD=RPLEODER) THEN/*
*                                      NO ERROR OR END-OF-DATA.      */
@RC00394 CLI   RPLERREG(RRPL),0                                    0405
         BE    @RT00405                                            0405
         CLI   RPLERREG(RRPL),8                                    0405
         BNE   @RF00405                                            0405
         CLI   RPLERRCD(RRPL),4                                    0405
         BNE   @RF00405                                            0405
@RT00405 DS    0H                                                  0406
*         DO;                                                      0406
*           PLHSAVE1=BUFCDDDD+PLHRECP-BUFCBAD;/* SET RECORD RBA TO 0407
*                                      ADVANCED POSITION.            */
         L     @10,PLHDBUFC(,RPLH)                                 0407
         L     @05,BUFCDDDD(,@10)                                  0407
         AL    @05,PLHRECP(,RPLH)                                  0407
         SL    @05,BUFCBAD(,@10)                                   0407
         ST    @05,PLHSAVE1(,RPLH)                                 0407
*           PLHEFLGS=PLHVALID;      /* MAKE PLH VALID.               */
         MVC   PLHEFLGS(2,RPLH),@CB00797                           0408
*           PLHRSTRT=ON;            /* SET PLH RESTART FLAG.         */
         OI    PLHRSTRT(RPLH),B'10000000'                          0409
*         END;                                                     0410
*       ELSE                        /* ERROR, BUT NOT END-OF-DATA.   */
*         PLHINVAL=ON;              /* MAKE PLH INVALID.             */
         B     @RC00405                                            0411
@RF00405 OI    PLHINVAL(RPLH),B'00000010'                          0411
*     END;                          /* END SEARCH FOR RECORD.        */
*   ELSE                            /* PUT REQ. OR NON-EMPTY RECORD. */
*     PLHEFLGS=PLHVALID;            /* MAKE PLH VALID.               */
         B     @RC00384                                            0413
@RF00384 MVC   PLHEFLGS(2,RPLH),@CB00797                           0413
*   CALL EXIT;                      /* RETURN.                       */
@RC00384 BAL   @14,EXIT                                            0414
*IDAGXCTL:                                                         0415
*                                                                  0415
*   /*****************************************************************/
*   /*                                                               */
*   /* GET EXCLUSIVE CONTROL ROUTINE --- SETS READ EXCLUSIVE CONTROL */
*   /* & CALLS DIRECT RECORD LOCATE TO OBTAIN BUFFER IN EXCLUSIVE    */
*   /* CONTROL. IF EXCLUSIVE CONTROL NOT OBTAINED, PLHDSCAN IS SET   */
*   /* ON.                                                           */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0415
*   ENTRY;                                                         0415
@EP00415 DS    0H                                                  0416
*   GEN(IDASVR14);                  /* SAVE REGISTER 14.             */
         IDASVR14
*   IF PLHNOADV=ON THEN             /* NO ADVANCE IS ON.             */
         TM    PLHNOADV(RPLH),B'00001000'                          0417
         BNO   @RF00417                                            0417
*     PLHSVADV=ON;                  /* REMEMBER NO ADVANCE.          */
         OI    PLHSVADV(RPLH),B'00000010'                          0418
*   ELSE                            /* NO ADVANCE IS OFF.            */
*     PLHSVADV=OFF;                 /* REMEMBER ADVANCE.             */
         B     @RC00417                                            0419
@RF00417 NI    PLHSVADV(RPLH),B'11111101'                          0419
*   CALL IDARRDRL;                  /* CALL DIRECT RECORD LOCATE.    */
@RC00417 L     @15,@CA00913                                        0420
         BALR  @14,@15                                             0420
*   IF RPLERREG='00'X THEN          /* NO ERROR.                     */
         CLI   RPLERREG(RRPL),0                                    0421
         BNE   @RF00421                                            0421
*     DO;                           /* PROCESS ERROR.                */
*       PLHDSCAN=OFF;               /* TURN OFF SCAN DATA FLAG.      */
         NI    PLHDSCAN(RPLH),B'11111110'                          0423
*       IF PLHSVADV=ON THEN         /* NO ADVANCE ON BEFORE.         */
         TM    PLHSVADV(RPLH),B'00000010'                          0424
         BNO   @RF00424                                            0424
*         PLHNOADV=ON;              /* SET PLH NO ADVANCE.           */
         OI    PLHNOADV(RPLH),B'00001000'                          0425
*       ELSE                        /* NO ADVANCE OFF BEFORE.        */
*         PLHNOADV=OFF;             /* TURN OFF NO ADVANCE.          */
         B     @RC00424                                            0426
@RF00424 NI    PLHNOADV(RPLH),B'11110111'                          0426
*     END;                          /* END NO ERROR.                 */
*   ELSE                            /* ERROR.                        */
*     IF RPLERREG='08'X&RPLERRCD=RPLEXCL THEN/* READ EXCL ERROR.     */
         B     @RC00421                                            0428
@RF00421 CLI   RPLERREG(RRPL),8                                    0428
         BNE   @RF00428                                            0428
         CLI   RPLERRCD(RRPL),20                                   0428
         BNE   @RF00428                                            0428
*       DO;                                                        0429
*         PLHDSCAN=ON;              /* SET SCAN DATA FLAG.           */
*         PLHINVAL=OFF;             /* TURN OFF INVALID POS.         */
         OI    PLHDSCAN(RPLH),B'00000001'                          0431
         NI    PLHINVAL(RPLH),B'11111101'                          0431
*       END;                                                       0432
*   CALL EXIT;                      /* RETURN.                       */
@RF00428 DS    0H                                                  0433
@RC00421 BAL   @14,EXIT                                            0433
*COMGET:                                                           0434
*                                                                  0434
*   /*****************************************************************/
*   /*                                                               */
*   /* COMMON GET ROUTINE ---                                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0434
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0434
         B     @PB00002                                            0434
COMGET   DS    0H                                                  0435
*   GEN(IDASVR14);                  /* SAVE REGISTER 14.             */
         IDASVR14
*   RPLRLEN=PLHLRECL;               /* SET RECORD LENGTH IN RPL.     */
         L     @10,PLHLRECL(,RPLH)                                 0436
         ST    @10,RPLRLEN(,RRPL)                                  0436
*   RPLDDDD=PLHSAVE1;               /* SET RECORD RBA IN RPL.        */
         L     @10,PLHSAVE1(,RPLH)                                 0437
         ST    @10,RPLDDDD(,RRPL)                                  0437
*   PLHRCODE=RPLREQ;                /* SAVE REQUEST CODE.            */
         IC    @10,RPLREQ(,RRPL)                                   0438
         STC   @10,PLHRCODE(,RPLH)                                 0438
*   IF RPLLOC=ON THEN               /* LOCATE MODE.                  */
         TM    RPLLOC(RRPL),B'10000000'                            0439
         BNO   @RF00439                                            0439
*     RPLAREA->AREA=PLHRECP;        /* SET RECORD ADR IN RPLAREA   0440
*                                      FIELD.                        */
         L     @10,RPLAREA(,RRPL)                                  0440
         L     @05,PLHRECP(,RPLH)                                  0440
         ST    @05,AREA(,@10)                                      0440
*   ELSE                            /* MOVE MODE.                    */
*     DO;                           /* PROCESS MOVE MODE.            */
         B     @RC00439                                            0441
@RF00439 DS    0H                                                  0442
*       IF RPLBUFL=>PLHLRECL THEN   /* USER AREA IS LARGE ENOUGH.    */
         L     @10,PLHLRECL(,RPLH)                                 0442
         C     @10,RPLBUFL(,RRPL)                                  0442
         BH    @RF00442                                            0442
*         DO;                       /* MOVE RECORD TO USER.          */
*           RFY                                                    0444
*            (RWORK2,                                              0444
*             RWORK3,                                              0444
*             RWORK4,                                              0444
*             RWORK5) RSTD;         /* RESTRICT REGS.                */
*           RWORK2=RPLAREA;         /* TO ADDRESS.                   */
         L     RWORK2,RPLAREA(,RRPL)                               0445
*           RWORK4=PLHRECP;         /* FROM ADDRESS.                 */
         L     RWORK4,PLHRECP(,RPLH)                               0446
*           RWORK3=PLHLRECL;        /* TO LENGTH.                    */
         LR    RWORK3,@10                                          0447
*           RWORK5=RWORK3;          /* FROM LENGTH.                  */
         LR    RWORK5,RWORK3                                       0448
*           GEN(MVCL RWORK2,RWORK4);/* MOVE RECORD TO USER AREA.     */
         MVCL RWORK2,RWORK4
*           RFY                                                    0450
*            (RWORK2,                                              0450
*             RWORK3,                                              0450
*             RWORK4,                                              0450
*             RWORK5) UNRSTD;       /* DROP REGS.                    */
*         END;                      /* END MOVE RECORD.              */
*       ELSE                        /* USER AREA TOO SMALL.          */
*         DO;                       /* AREA LENGTH ERROR.            */
         B     @RC00442                                            0452
@RF00442 DS    0H                                                  0453
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0453
*           RPLERRCD=RPLINBUF;      /* SET AREA TOO SMALL ERROR.     */
         MVI   RPLERRCD(RRPL),X'2C'                                0454
*           IF RPLDIR=ON&RPLNSP=OFF THEN/* REQ IS DIR & NOT NSP.     */
         TM    RPLDIR(RRPL),B'01000000'                            0455
         BNO   @RF00455                                            0455
         TM    RPLNSP(RRPL),B'00000001'                            0455
         BNZ   @RF00455                                            0455
*             DO;                                                  0456
*               PLHINVAL=ON;        /* SET PLH INVALID.              */
         OI    PLHINVAL(RPLH),B'00000010'                          0457
*               RBUFC=PLHDBUFC;     /* POINT TO DATA BUFC.           */
         L     RBUFC,PLHDBUFC(,RPLH)                               0458
*I07:                                                              0459
*               DO;                 /* IDACALL(IDAFREEB)             */
I07      DS    0H                                                  0460
*                 CALL IDAFREEB;    /* EXIT TO IDAFREEB              */
         L     @15,@CV00908                                        0460
         BALR  @14,@15                                             0460
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I07;            /* FREE DATA BUFFER.             */
*             END;                                                 0466
*           ELSE                    /* REQ. NOT DIR & NSP OR UPD.    */
*             PLHNOADV=ON;          /* SET PLH NO ADVANCE.           */
         B     @RC00455                                            0467
@RF00455 OI    PLHNOADV(RPLH),B'00001000'                          0467
*           CALL EXIT;              /* RETURN.                       */
@RC00455 BAL   @14,EXIT                                            0468
*         END;                      /* END AREA LENGTH ERROR.        */
*     END;                          /* END OF MOVE MODE.             */
@RC00442 DS    0H                                                  0471
*   IF RPLDIR=ON&RPLUPD=OFF&RPLNSP=OFF&RPLLOC=OFF THEN/* DIR & NUP &
*                                      MVE REQUEST.                  */
@RC00439 TM    RPLDIR(RRPL),B'01000000'                            0471
         BNO   @RF00471                                            0471
         TM    RPLUPD(RRPL),B'00000011'                            0471
         BNZ   @RF00471                                            0471
         TM    RPLLOC(RRPL),B'10000000'                            0471
         BNZ   @RF00471                                            0471
*     DO;                           /* RELEASE POISITION.            */
*       PLHINVAL=ON;                /* SET PLH INVALID.              */
         OI    PLHINVAL(RPLH),B'00000010'                          0473
*       RBUFC=PLHDBUFC;             /* POINT TO DATA BUFC.           */
         L     RBUFC,PLHDBUFC(,RPLH)                               0474
*I08:                                                              0475
*       DO;                         /* IDACALL(IDAFREEB)             */
I08      DS    0H                                                  0476
*         CALL IDAFREEB;            /* EXIT TO IDAFREEB              */
         L     @15,@CV00908                                        0476
         BALR  @14,@15                                             0476
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I08;                    /* FREE DATA BUFFER.             */
*     END;                          /* END RELEASE POSITION.         */
*   ELSE                            /* NOT DIR NUP MVE REQUEST.      */
*     DO;                           /* RETAIN POSITION.              */
         B     @RC00471                                            0483
@RF00471 DS    0H                                                  0484
*       IF RPLUPD=ON THEN           /* UPDATE REQUEST.               */
         TM    RPLUPD(RRPL),B'00000010'                            0484
         BNO   @RF00484                                            0484
*         PLHUPD=ON;                /* SAVE IN PLH.                  */
         OI    PLHUPD(RPLH),B'10000000'                            0485
*       ELSE                        /* NOT UPDATE REQUEST.           */
*         PLHUPD=OFF;               /* SAVE IN PLH.                  */
         B     @RC00484                                            0486
@RF00484 NI    PLHUPD(RPLH),B'01111111'                            0486
*       PLHNOADV=OFF;               /* CLEAR NO ADVANCE FLAG.        */
@RC00484 NI    PLHNOADV(RPLH),B'11110111'                          0487
*       PLHRSTRT=OFF;               /* CLEAR RESTART FLAG.           */
         NI    PLHRSTRT(RPLH),B'01111111'                          0488
*     END;                          /* END RETAIN POSITION.          */
*   AMDRETR=AMDRETR+ONE;            /* INCR RETRIEVE COUNT STATISTICS*/
@RC00471 L     @10,AMBDSB(,RAMB)                                   0490
         LA    @05,1                                               0490
         AL    @05,AMDRETR(,@10)                                   0490
         ST    @05,AMDRETR(,@10)                                   0490
*   IF AMBJRN=ON THEN               /* JOURNAL EXIT.                 */
         TM    AMBJRN(RAMB),B'00000010'                            0491
         BNO   @RF00491                                            0491
*     DO;                                                          0492
*       PLHJCODE=PLHJGET;           /* SET JOURN CODE = GET.         */
         MVI   PLHJCODE(RPLH),B'00000000'                          0493
*I09:                                                              0494
*       DO;                         /* IDACALL(IDATJXIT)             */
I09      DS    0H                                                  0495
*         CALL IDATJXIT;            /* EXIT TO IDATJXIT              */
         L     @15,@CV00912                                        0495
         BALR  @14,@15                                             0495
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I09;                    /* CALL JOURNAL EXIT ROUTINE.    */
*     END;                                                         0501
*   CALL EXIT;                      /* RETURN.                       */
@RF00491 BAL   @14,EXIT                                            0502
*   END COMGET;                     /* END PROC. COMGET.             */
@EL00002 DS    0H                                                  0503
@EF00002 DS    0H                                                  0503
@ER00002 BR    @14                                                 0503
*ADVPLH:                                                           0504
*                                                                  0504
*   /*****************************************************************/
*   /*                                                               */
*   /* ADVANCE PLH ROUTINE --- FOR SEQUENTIAL PROCESSING, ADVANCES   */
*   /* POSITIONING TO NEXT VALID RECORD. SKIPS OVER EMPTY RECORDS.   */
*   /* ADVANCES IN BACKWARD DIRECTION IF USER SPECIFIED BACKWARD     */
*   /* PROCESSING IN RPL.                                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0504
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0504
ADVPLH   DS    0H                                                  0505
*   GEN(IDASVR14);                  /* SAVE REGISTER 14.             */
         IDASVR14
*   IF RPLBWD=OFF THEN              /* FORWARD REQUEST.              */
         TM    RPLBWD(RRPL),B'00010000'                            0506
         BNZ   @RF00506                                            0506
*     DO;                           /* ADVANCE FORWARD.              */
*       IF PLHBWD=ON THEN           /* PREVIOUS REQ. WAS BACKWARD.   */
         TM    PLHBWD(RPLH),B'00010000'                            0508
         BNO   @RF00508                                            0508
*         DO;                       /* POSITIONING ERROR.            */
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0510
*           RPLERRCD=RPLNOPTR;      /* SET POSITIONING ERROR.        */
         MVI   RPLERRCD(RRPL),X'58'                                0511
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0512
*         END;                      /* END POSITIONING ERROR.        */
*       IF PLHSKPER=ON THEN         /* READ SKIP FLAG ON.            */
@RF00508 TM    PLHSKPER(RPLH),B'00100000'                          0514
         BNO   @RF00514                                            0514
*         DO;                       /* SKIP ERROR CI.                */
*           PLHSKPER=OFF;           /* CLEAR SKIP ERROR FLAG.        */
         NI    PLHSKPER(RPLH),B'11011111'                          0516
*           CALL ADVCI;             /* ADVANCE TO NEXT CI & SEARCH 0517
*                                      FOR NEXT VALID RECORD.        */
         BAL   @14,ADVCI                                           0517
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0518
*         END;                      /* END SKIP ERROR CI.            */
*NXTRCD:                                                           0520
*       PLHRECP=PLHRECP+PLHLRECL;   /* ADVANCE RECORD POINTER.       */
@RF00514 DS    0H                                                  0520
NXTRCD   L     @10,PLHRECP(,RPLH)                                  0520
         AL    @10,PLHLRECL(,RPLH)                                 0520
         ST    @10,PLHRECP(,RPLH)                                  0520
*       IF PLHRECP<PLHFSP THEN      /* NOT END OF CI.                */
         C     @10,PLHFSP(,RPLH)                                   0521
         BNL   @RF00521                                            0521
*         DO;                       /* NEXT RECORD.                  */
*           PLHRDFP=PLHRDFP-LENGTH(IDARDF);/* POINT TO NEXT RDF.     */
         L     @10,PLHRDFP(,RPLH)                                  0523
         SL    @10,@CF00157                                        0523
         ST    @10,PLHRDFP(,RPLH)                                  0523
*           IF RDFEMPTY=ON THEN     /* RECORD IS EMPTY.              */
         TM    RDFEMPTY(@10),B'00000100'                           0524
         BO    @RT00524                                            0524
*             GOTO NXTRCD;          /* GO CHECK NEXT RECORD.         */
*         END;                      /* END NEXT RECORD.              */
*       ELSE                        /* END OF CI.                    */
*         CALL ADVCI;               /* ADVANCE TO NEXT CI & SEARCH 0527
*                                      FOR NEXT VALID RECORD.        */
         B     @RC00521                                            0527
@RF00521 BAL   @14,ADVCI                                           0527
*       CALL EXIT;                  /* RETURN.                       */
@RC00521 BAL   @14,EXIT                                            0528
*     END;                          /* END ADVANCE FORWARD.          */
*   ELSE                            /* BACKWARD REQUEST.             */
*     DO;                           /* ADVANCE BACKWARD.             */
         B     @RC00506                                            0530
@RF00506 DS    0H                                                  0531
*       IF PLHBWD=OFF THEN          /* PREVIOUS REQ. WAS FORWARD.    */
         TM    PLHBWD(RPLH),B'00010000'                            0531
         BNZ   @RF00531                                            0531
*         DO;                       /* POSITIONING ERROR.            */
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0533
*           RPLERRCD=RPLNOPTR;      /* SET POSITIONING ERROR.        */
         MVI   RPLERRCD(RRPL),X'58'                                0534
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0535
*         END;                      /* END POSITIONING ERROR.        */
*       IF PLHSKPER=ON THEN         /* READ SKIP FLAG ON.            */
@RF00531 TM    PLHSKPER(RPLH),B'00100000'                          0537
         BNO   @RF00537                                            0537
*         DO;                       /* SKIP ERROR CI.                */
*           PLHSKPER=OFF;           /* CLEAR SKIP ERROR FLAG.        */
         NI    PLHSKPER(RPLH),B'11011111'                          0539
*           CALL ADVCI;             /* ADVANCE TO PREVIOUS CI &    0540
*                                      SEARCH FOR NEXT VALID RECORD. */
         BAL   @14,ADVCI                                           0540
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0541
*         END;                      /* END SKIP ERROR CI.            */
*PRVRCD:                                                           0543
*       IF PLHRECP>BUFCBAD THEN     /* NOT BEGINNING OF CI.          */
@RF00537 DS    0H                                                  0543
PRVRCD   L     @10,PLHRECP(,RPLH)                                  0543
         L     @05,PLHDBUFC(,RPLH)                                 0543
         C     @10,BUFCBAD(,@05)                                   0543
         BNH   @RF00543                                            0543
*         DO;                       /* PREVIOUS RECORD.              */
*           PLHRECP=PLHRECP-PLHLRECL;/* BACKUP RECORD POINTER.       */
         SL    @10,PLHLRECL(,RPLH)                                 0545
         ST    @10,PLHRECP(,RPLH)                                  0545
*           PLHRDFP=PLHRDFP+LENGTH(IDARDF);/* POINT TO PREVIOUS RDF. */
         LA    @10,3                                               0546
         AL    @10,PLHRDFP(,RPLH)                                  0546
         ST    @10,PLHRDFP(,RPLH)                                  0546
*           IF RDFEMPTY=ON THEN     /* EMPTY RECORD.                 */
         TM    RDFEMPTY(@10),B'00000100'                           0547
         BO    @RT00547                                            0547
*             GOTO PRVRCD;          /* GO CHECK PREVIOUS RECORD.     */
*         END;                      /* END PREVIOUS RECORD.          */
*       ELSE                        /* BEGINNING OF CI.              */
*         CALL ADVCI;               /* ADVANCE TO PREVIOUS CI &    0550
*                                      SEARCH FOR NEXT VALID RECORD. */
         B     @RC00543                                            0550
@RF00543 BAL   @14,ADVCI                                           0550
*       CALL EXIT;                  /* RETURN.                       */
@RC00543 BAL   @14,EXIT                                            0551
*     END;                          /* END ADVANCE BACKWARD.         */
*   END ADVPLH;                     /* END PROC. ADVPLH.             */
@EL00003 DS    0H                                                  0553
@EF00003 DS    0H                                                  0553
@ER00003 BR    @14                                                 0553
*ADVCI:                                                            0554
*                                                                  0554
*   /*****************************************************************/
*   /*                                                               */
*   /* ADVANCE CI ROUTINE ---                                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0554
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0554
ADVCI    DS    0H                                                  0555
*   GEN(IDASVR14);                  /* SAVE REGISTER 14.             */
         IDASVR14
*   IF PLHASKBF=ON THEN             /* ASK BUFFER IS ON.             */
         TM    PLHASKBF(RPLH),B'00100000'                          0556
         BNO   @RF00556                                            0556
*     DO;                                                          0557
*       RPARM1=ZERO;                /* ADD MAX. NO. OF BUFFERS.      */
         SLR   RPARM1,RPARM1                                       0558
*I10:                                                              0559
*       DO;                         /* IDACALL(IDAABF)               */
I10      DS    0H                                                  0560
*         CALL IDAABF;              /* EXIT TO IDAABF                */
         L     @15,@CV00904                                        0560
         BALR  @14,@15                                             0560
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I10;                    /* CALL ADD BUFFER.              */
*     END;                                                         0566
*   IF RPLUPD=ON THEN               /* UPDATE REQ.                   */
@RF00556 TM    RPLUPD(RRPL),B'00000010'                            0567
         BNO   @RF00567                                            0567
*     PLHRDEXC=ON;                  /* SET READ EXCLUSIVE FLAG.      */
         OI    PLHRDEXC(RPLH),B'00001000'                          0568
*   ELSE                            /* NOT UPDATE REQ.               */
*     PLHRDEXC=OFF;                 /* CLEAR READ EXCLUSIVE FLAG.    */
         B     @RC00567                                            0569
@RF00567 NI    PLHRDEXC(RPLH),B'11110111'                          0569
*GNXTCI:                                                           0570
*   RBUFC=PLHDBUFC;                 /* POINT TO DATA BUFC.           */
@RC00567 DS    0H                                                  0570
GNXTCI   L     RBUFC,PLHDBUFC(,RPLH)                               0570
*I11:                                                              0571
*   DO;                             /* IDACALL(IDAFREEB)             */
I11      DS    0H                                                  0572
*     CALL IDAFREEB;                /* EXIT TO IDAFREEB              */
         L     @15,@CV00908                                        0572
         BALR  @14,@15                                             0572
*     GEN(BALR @11,0);              /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*     GEN(USING *,@11);             /* ESTABLISH ADDRESSING          */
         USING *,@11
*     GEN(L     @11,=A(@PSTART));   /* RELOAD BASE                   */
         L     @11,=A(@PSTART)
*     GEN(USING @PSTART,@11);       /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*   END I11;                        /* FREE DATA BUFFER.             */
*I12:                                                              0578
*   DO;                             /* IDACALL(IDAGNXT)              */
I12      DS    0H                                                  0579
*     CALL IDAGNXT;                 /* EXIT TO IDAGNXT               */
         L     @15,@CV00905                                        0579
         BALR  @14,@15                                             0579
*     GEN(BALR @11,0);              /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*     GEN(USING *,@11);             /* ESTABLISH ADDRESSING          */
         USING *,@11
*     GEN(L     @11,=A(@PSTART));   /* RELOAD BASE                   */
         L     @11,=A(@PSTART)
*     GEN(USING @PSTART,@11);       /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*   END I12;                        /* GET NEXT CI.                  */
*   IF RPLERREG^='00'X THEN         /* BUFFER ERROR.                 */
         CLI   RPLERREG(RRPL),0                                    0585
         BE    @RF00585                                            0585
*     DO;                           /* PROCESS ERROR.                */
*       IF RPLERREG='08'X&RPLERRCD=RPLEXCL THEN/* EXCL CTL ERR.      */
         CLI   RPLERREG(RRPL),8                                    0587
         BNE   @RF00587                                            0587
         CLI   RPLERRCD(RRPL),20                                   0587
         BNE   @RF00587                                            0587
*         PLHDSCAN=ON;              /* SET SCANDATA FLAG.            */
         OI    PLHDSCAN(RPLH),B'00000001'                          0588
*       IF RPLBWD=ON THEN           /* BACKWARD REQ.                 */
@RF00587 TM    RPLBWD(RRPL),B'00010000'                            0589
         BNO   @RF00589                                            0589
*         PLHSAVE1=RPARM1+((AMDNSLOT-1)*PLHLRECL);/* SAVE    @ZA07544
*                                      RBA OF LAST REC IN PREV CI.   */
         L     @10,AMBDSB(,RAMB)                                   0590
         L     @07,AMDNSLOT(,@10)                                  0590
         BCTR  @07,0                                               0590
         M     @06,PLHLRECL(,RPLH)                                 0590
         ALR   @07,RPARM1                                          0590
         ST    @07,PLHSAVE1(,RPLH)                                 0590
*       ELSE                        /* FORWARD REQ.                  */
*         PLHSAVE1=RPARM1;          /* SAVE RBA OF NEXT CI.  @ZA07544*/
         B     @RC00589                                            0591
@RF00589 ST    RPARM1,PLHSAVE1(,RPLH)                              0591
*       PLHNOADV=ON;                /* DO NOT ADVANCE PLH.   @ZA07544*/
@RC00589 OI    PLHNOADV(RPLH),B'00001000'                          0592
*       CALL EXIT;                  /* RETURN.                       */
         BAL   @14,EXIT                                            0593
*     END;                          /* END PROCESS ERROR.            */
*   PLHFSP=BUFCBAD+(AMDNSLOT*PLHLRECL);/* SET PLH FS PTR.            */
@RF00585 L     @10,PLHDBUFC(,RPLH)                                 0595
         L     @10,BUFCBAD(,@10)                                   0595
         L     @05,AMBDSB(,RAMB)                                   0595
         L     @07,AMDNSLOT(,@05)                                  0595
         M     @06,PLHLRECL(,RPLH)                                 0595
         ALR   @07,@10                                             0595
         ST    @07,PLHFSP(,RPLH)                                   0595
*   IF RPLBWD=OFF THEN              /* FORWARD DIRECTION.            */
         TM    RPLBWD(RRPL),B'00010000'                            0596
         BNZ   @RF00596                                            0596
*     DO;                           /* ADVANCE FORWARD.              */
*       PLHRDFP=BUFCBAD+AMDCINV-LENGTH(IDACIDF)-LENGTH(IDARDF);/*  0598
*                                      POINT TO 1ST RDF.             */
         LR    @00,@10                                             0598
         AL    @00,AMDCINV(,@05)                                   0598
         SL    @00,@CF00288                                        0598
         ST    @00,PLHRDFP(,RPLH)                                  0598
*       PLHRECP=BUFCBAD;            /* POINT TO 1ST RECORD.          */
         ST    @10,PLHRECP(,RPLH)                                  0599
*       DO WHILE RDFEMPTY=ON;       /* LOOP ON EMPTY RECORDS.        */
         B     @DE00600                                            0600
@DL00600 DS    0H                                                  0601
*         PLHRDFP=PLHRDFP-LENGTH(IDARDF);/* POINT TO NEXT RDF.       */
         L     @10,PLHRDFP(,RPLH)                                  0601
         SL    @10,@CF00157                                        0601
         ST    @10,PLHRDFP(,RPLH)                                  0601
*         PLHRECP=PLHRECP+PLHLRECL; /* POINT TO NEXT RECORD.         */
         L     @10,PLHRECP(,RPLH)                                  0602
         AL    @10,PLHLRECL(,RPLH)                                 0602
         ST    @10,PLHRECP(,RPLH)                                  0602
*         IF PLHRECP=>PLHFSP THEN   /* END OF CI.                    */
         C     @10,PLHFSP(,RPLH)                                   0603
         BNL   @RT00603                                            0603
*           GOTO GNXTCI;            /* GO TO NEXT CI.                */
*       END;                        /* END OF LOOP.                  */
@DE00600 L     @10,PLHRDFP(,RPLH)                                  0605
         TM    RDFEMPTY(@10),B'00000100'                           0605
         BO    @DL00600                                            0605
*     END;                          /* END ADVANCE FORWARD.          */
*   ELSE                            /* ADVANCE BACKWARD.             */
*     DO;                                                          0607
         B     @RC00596                                            0607
@RF00596 DS    0H                                                  0608
*       PLHRDFP=BUFCBAD+AMDCINV-LENGTH(IDACIDF)-(AMDNSLOT*LENGTH(IDARDF
*           ));                     /* POINT TO LAST RDF.            */
         L     @10,PLHDBUFC(,RPLH)                                 0608
         L     @05,AMBDSB(,RAMB)                                   0608
         L     @10,BUFCBAD(,@10)                                   0608
         AL    @10,AMDCINV(,@05)                                   0608
         SL    @10,@CF00067                                        0608
         L     @05,AMDNSLOT(,@05)                                  0608
         MH    @05,@CH00157                                        0608
         SLR   @10,@05                                             0608
         ST    @10,PLHRDFP(,RPLH)                                  0608
*       PLHRECP=PLHFSP-PLHLRECL;    /* POINT TO LAST RECORD.         */
         L     @10,PLHFSP(,RPLH)                                   0609
         SL    @10,PLHLRECL(,RPLH)                                 0609
         ST    @10,PLHRECP(,RPLH)                                  0609
*       DO WHILE RDFEMPTY=ON;       /* LOOP ON EMPTY RECORDS.        */
         B     @DE00610                                            0610
@DL00610 DS    0H                                                  0611
*         IF PLHRECP=<BUFCBAD THEN  /* BEGINNING OF CI.              */
         L     @10,PLHRECP(,RPLH)                                  0611
         L     @05,PLHDBUFC(,RPLH)                                 0611
         C     @10,BUFCBAD(,@05)                                   0611
         BNH   @RT00611                                            0611
*           GOTO GNXTCI;            /* GO TO NEXT CI.                */
*         PLHRDFP=PLHRDFP+LENGTH(IDARDF);/* POINT TO PREV. RDF.      */
         LA    @05,3                                               0613
         AL    @05,PLHRDFP(,RPLH)                                  0613
         ST    @05,PLHRDFP(,RPLH)                                  0613
*         PLHRECP=PLHRECP-PLHLRECL; /* POINT TO PREV. RECORD.        */
         SL    @10,PLHLRECL(,RPLH)                                 0614
         ST    @10,PLHRECP(,RPLH)                                  0614
*       END;                        /* END OF LOOP.                  */
@DE00610 L     @10,PLHRDFP(,RPLH)                                  0615
         TM    RDFEMPTY(@10),B'00000100'                           0615
         BO    @DL00610                                            0615
*     END;                          /* END ADVANCE BACKWARD.         */
*   CALL EXIT;                      /* RETURN.                       */
@RC00596 BAL   @14,EXIT                                            0617
*   END ADVCI;                      /* END PROC. ADVCI.              */
@EL00004 DS    0H                                                  0618
@EF00004 DS    0H                                                  0618
@ER00004 BR    @14                                                 0618
*PLHEXP:                                                           0619
*                                                                  0619
*   /*****************************************************************/
*   /*                                                               */
*   /* PLH EXCEPTION ROUTINE ---                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0619
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0619
PLHEXP   DS    0H                                                  0620
*   GEN(IDASVR14);                  /* SAVE REGISTER 14.             */
         IDASVR14
*   IF PLH1ST=ON THEN               /* 1ST REQ AFTER OPEN.           */
         TM    PLH1ST(RPLH),B'01000000'                            0621
         BNO   @RF00621                                            0621
*     DO;                           /* PROCESS 1ST REQ.              */
*       IF RPLBWD=ON THEN           /* BACKWARD DIRECTION.           */
         TM    RPLBWD(RRPL),B'00010000'                            0623
         BNO   @RF00623                                            0623
*         DO;                       /* BWD FOR 1ST REQ NOT ALLOWED.  */
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0625
*           RPLERRCD=RPLNOPTR;      /* SET NO POSITION ERROR.        */
         MVI   RPLERRCD(RRPL),X'58'                                0626
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0627
*         END;                      /* END BWD ERROR.                */
*       PLHASKBF=ON;                /* SET PLH ASK BUFFER.           */
@RF00623 OI    PLHASKBF(RPLH),B'00100000'                          0629
*       RPARM1=ZERO;                /* ADD MAX NO. OF BUFFERS.       */
         SLR   RPARM1,RPARM1                                       0630
*I13:                                                              0631
*       DO;                         /* IDACALL(IDAABF)               */
I13      DS    0H                                                  0632
*         CALL IDAABF;              /* EXIT TO IDAABF                */
         L     @15,@CV00904                                        0632
         BALR  @14,@15                                             0632
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I13;                    /* CALL ADD BUFFER.              */
*       IF RPLUPD=ON THEN           /* UPDATE REQUEST.               */
         TM    RPLUPD(RRPL),B'00000010'                            0638
         BNO   @RF00638                                            0638
*         PLHRDEXC=ON;              /* SET PLH READ EXCLUSIVE.       */
         OI    PLHRDEXC(RPLH),B'00001000'                          0639
*       RPARM1=ZERO;                /* RBA OF 1ST CI.                */
@RF00638 SLR   RPARM1,RPARM1                                       0640
*I14:                                                              0641
*       DO;                         /* IDACALL(IDAGRB)               */
I14      DS    0H                                                  0642
*         CALL IDAGRB;              /* EXIT TO IDAGRB                */
         L     @15,@CV00906                                        0642
         BALR  @14,@15                                             0642
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I14;                    /* GET CI BY RBA.                */
*       IF RPLERREG^='00'X THEN     /* ERROR.                        */
         CLI   RPLERREG(RRPL),0                                    0648
         BE    @RF00648                                            0648
*         DO;                                                      0649
*           IF RPLERREG='0C'X THEN  /* I/O ERROR.                    */
         CLI   RPLERREG(RRPL),12                                   0650
         BNE   @RF00650                                            0650
*             PLH1ST=OFF;           /* ALLOW SKIPPING 1ST CI.        */
         NI    PLH1ST(RPLH),B'10111111'                            0651
*           CALL EXIT;              /* RETURN.                       */
@RF00650 BAL   @14,EXIT                                            0652
*         END;                                                     0653
*       PLH1ST=OFF;                 /* TURN OFF 1ST REQ. FLAG.       */
@RF00648 NI    PLH1ST(RPLH),B'10111111'                            0654
*       PLHRECP=BUFCBAD;            /* SET REC. PTR TO 1ST RECORD.   */
         L     @10,PLHDBUFC(,RPLH)                                 0655
         L     @10,BUFCBAD(,@10)                                   0655
         ST    @10,PLHRECP(,RPLH)                                  0655
*       PLHRDFP=BUFCBAD+AMDCINV-LENGTH(IDACIDF)-LENGTH(IDARDF);/* SET
*                                      RDF PTR.                      */
         L     @05,AMBDSB(,RAMB)                                   0656
         LR    @00,@10                                             0656
         AL    @00,AMDCINV(,@05)                                   0656
         SL    @00,@CF00288                                        0656
         ST    @00,PLHRDFP(,RPLH)                                  0656
*       PLHFSP=BUFCBAD+(AMDNSLOT*PLHLRECL);/* SET PLH FS PTR.        */
         L     @07,AMDNSLOT(,@05)                                  0657
         M     @06,PLHLRECL(,RPLH)                                 0657
         ALR   @10,@07                                             0657
         ST    @10,PLHFSP(,RPLH)                                   0657
*RECLOOP:                                                          0658
*       IF RDFEMPTY=ON THEN         /* EMPTY RECORD.                 */
RECLOOP  L     @10,PLHRDFP(,RPLH)                                  0658
         TM    RDFEMPTY(@10),B'00000100'                           0658
         BNO   @RF00658                                            0658
*         DO;                                                      0659
*           PLHRDFP=PLHRDFP-LENGTH(IDARDF);/* POINT TO NEXT RDF.     */
         SL    @10,@CF00157                                        0660
         ST    @10,PLHRDFP(,RPLH)                                  0660
*           PLHRECP=PLHRECP+PLHLRECL;/* ADVANCE RECORD PTR.          */
         L     @10,PLHRECP(,RPLH)                                  0661
         AL    @10,PLHLRECL(,RPLH)                                 0661
         ST    @10,PLHRECP(,RPLH)                                  0661
*           IF PLHRECP<PLHFSP THEN  /* NOT END OF CI.                */
         C     @10,PLHFSP(,RPLH)                                   0662
         BL    @RT00662                                            0662
*             GOTO RECLOOP;         /* GO CHECK NEXT RECORD.         */
*           CALL ADVCI;             /* ADVANCE TO NEXT CI & SEARCH 0664
*                                      FOR RECORD.                   */
         BAL   @14,ADVCI                                           0664
*         END;                                                     0665
*       CALL EXIT;                  /* RETURN.                       */
@RF00658 BAL   @14,EXIT                                            0666
*     END;                          /* END PROCESS 1ST REQ.          */
*   ELSE                            /* NOT 1ST REQ AFTER OPEN.       */
*     DO;                           /* PROCESS NON-1ST REQ.          */
         B     @RC00621                                            0668
@RF00621 DS    0H                                                  0669
*       IF PLHEODX=ON THEN          /* EOD ON PREVIOUS REQ.          */
         TM    PLHEODX(RPLH),B'00000100'                           0669
         BNO   @RF00669                                            0669
*         DO;                                                      0670
*           RPLERREG='08'X;         /* SET LOGICAL ERROR IN RPL.     */
         MVI   RPLERREG(RRPL),X'08'                                0671
*           RPLERRCD=RPLEODER;      /* SET EOD ERROR.                */
         MVI   RPLERRCD(RRPL),X'04'                                0672
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0673
*         END;                                                     0674
*       IF PLHSKPER=ON THEN         /* SKIP CI FLAG ON.              */
@RF00669 TM    PLHSKPER(RPLH),B'00100000'                          0675
         BNO   @RF00675                                            0675
*         DO;                                                      0676
*           CALL ADVPLH;            /* CALL ADVANCE PLACEHOLDER.     */
         BAL   @14,ADVPLH                                          0677
*           CALL EXIT;              /* RETURN.                       */
         BAL   @14,EXIT                                            0678
*         END;                                                     0679
*       IF PLHDSCAN=ON THEN         /* PREV READ EXCL CONTROL ERROR. */
@RF00675 TM    PLHDSCAN(RPLH),B'00000001'                          0680
         BNO   @RF00680                                            0680
*         DO;                                                      0681
*           CALL IDAGXCTL;          /* GET BUFFER IN EXCL CONTROL.   */
         L     @15,@CA00914                                        0682
         BALR  @14,@15                                             0682
*           IF RPLERREG^='00'X THEN /* ERROR.                        */
         CLI   RPLERREG(RRPL),0                                    0683
         BE    @RF00683                                            0683
*             CALL EXIT;            /* RETURN.                       */
         BAL   @14,EXIT                                            0684
*           IF RDFEMPTY=ON THEN     /* RECORD IS EMPTY.              */
@RF00683 L     @10,PLHRDFP(,RPLH)                                  0685
         TM    RDFEMPTY(@10),B'00000100'                           0685
         BNO   @RF00685                                            0685
*             CALL ADVPLH;          /* SEARCH FOR NEXT RECORD.       */
         BAL   @14,ADVPLH                                          0686
*           CALL EXIT;              /* RETURN.                       */
@RF00685 BAL   @14,EXIT                                            0687
*         END;                                                     0688
*       IF PLHNOADV=ON THEN         /* NO ADVANCE IS ON.             */
@RF00680 TM    PLHNOADV(RPLH),B'00001000'                          0689
         BNO   @RF00689                                            0689
*         DO;                                                      0690
*           IF PLHRECP=>PLHFSP THEN /* REC PTR AT END OF CI.         */
         CLC   PLHRECP(4,RPLH),PLHFSP(RPLH)                        0691
         BL    @RF00691                                            0691
*             CALL ADVPLH;          /* CALL ADVANCE PLACEHOLDER.     */
         BAL   @14,ADVPLH                                          0692
*         END;                                                     0693
*       ELSE                        /* NO ADVANCE IS OFF.            */
*         IF PLHINVAL=ON THEN       /* PLH IS INVALID.               */
         B     @RC00689                                            0694
@RF00689 TM    PLHINVAL(RPLH),B'00000010'                          0694
         BNO   @RF00694                                            0694
*           DO;                                                    0695
*             RPLERREG='08'X;       /* SET LOGICAL IN RPL.           */
         MVI   RPLERREG(RRPL),X'08'                                0696
*             RPLERRCD=RPLNOPTR;    /* SET NO POSITION ERROR.        */
         MVI   RPLERRCD(RRPL),X'58'                                0697
*           END;                                                   0698
*     END;                          /* END NON-1ST REQUEST.          */
@RF00694 DS    0H                                                  0699
@RC00689 DS    0H                                                  0700
*   CALL EXIT;                      /* RETURN.                       */
@RC00621 BAL   @14,EXIT                                            0700
*   END PLHEXP;                     /* END PROC. PLHEXP.             */
@EL00005 DS    0H                                                  0701
@EF00005 DS    0H                                                  0701
@ER00005 BR    @14                                                 0701
*LRD:                                                              0702
*                                                                  0702
*   /*****************************************************************/
*   /*                                                               */
*   /* LAST RECORD ROUTINE ---                                       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0702
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0702
LRD      DS    0H                                                  0703
*   GEN(IDASVR14);                                                 0703
         IDASVR14
*   PLHASKBF=ON;                    /* SET PLH ASK BUFFER.           */
         OI    PLHASKBF(RPLH),B'00100000'                          0704
*   IF RPLUPD=ON THEN               /* UPDATE REQUEST.               */
         TM    RPLUPD(RRPL),B'00000010'                            0705
         BNO   @RF00705                                            0705
*     PLHRDEXC=ON;                  /* SET PLH READ EXCLUSIVE.       */
         OI    PLHRDEXC(RPLH),B'00001000'                          0706
*   ELSE                            /* NOT UPDATE REQUEST.           */
*     PLHRDEXC=OFF;                 /* CLEAR PLH READ EXCLUSIVE.     */
         B     @RC00705                                            0707
@RF00705 NI    PLHRDEXC(RPLH),B'11110111'                          0707
*   RPARM1=ARDHRBA-AMDCINV;         /* RBA OF LAST CI OF DATA SET.   */
@RC00705 L     @10,AMBDSB(,RAMB)                                   0708
         L     @05,AMDPARDB(,@10)                                  0708
         L     RPARM1,ARDHRBA(,@05)                                0708
         SL    RPARM1,AMDCINV(,@10)                                0708
*I15:                                                              0709
*   DO;                             /* IDACALL(IDAGRB)               */
I15      DS    0H                                                  0710
*     CALL IDAGRB;                  /* EXIT TO IDAGRB                */
         L     @15,@CV00906                                        0710
         BALR  @14,@15                                             0710
*     GEN(BALR @11,0);              /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*     GEN(USING *,@11);             /* ESTABLISH ADDRESSING          */
         USING *,@11
*     GEN(L     @11,=A(@PSTART));   /* RELOAD BASE                   */
         L     @11,=A(@PSTART)
*     GEN(USING @PSTART,@11);       /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*   END I15;                        /* GET CI BY RBA.                */
*   IF RPLERREG^='00'X THEN         /* ERROR.                        */
         CLI   RPLERREG(RRPL),0                                    0716
         BE    @RF00716                                            0716
*     DO;                                                          0717
*       PLHINVAL=ON;                /* SET PLH INVALID.              */
         OI    PLHINVAL(RPLH),B'00000010'                          0718
*       CALL EXIT;                  /* RETURN.                       */
         BAL   @14,EXIT                                            0719
*     END;                                                         0720
*   PLHRDFP=BUFCBAD+AMDCINV-LENGTH(IDACIDF)-(AMDNSLOT*LENGTH(IDARDF));
@RF00716 L     @10,PLHDBUFC(,RPLH)                                 0721
         L     @10,BUFCBAD(,@10)                                   0721
         L     @05,AMBDSB(,RAMB)                                   0721
         LR    @00,@10                                             0721
         AL    @00,AMDCINV(,@05)                                   0721
         SL    @00,@CF00067                                        0721
         L     @05,AMDNSLOT(,@05)                                  0721
         LR    @15,@05                                             0721
         MH    @15,@CH00157                                        0721
         SLR   @00,@15                                             0721
         ST    @00,PLHRDFP(,RPLH)                                  0721
*                                   /* POINT TO LAST RDF.            */
*   PLHFSP=BUFCBAD+(AMDNSLOT*PLHLRECL);/* SET PLH FS PTR.            */
         L     @15,PLHLRECL(,RPLH)                                 0722
         LR    @07,@05                                             0722
         MR    @06,@15                                             0722
         ALR   @10,@07                                             0722
         ST    @10,PLHFSP(,RPLH)                                   0722
*   PLHRECP=PLHFSP-PLHLRECL;        /* POINT TO LAST RECORD.         */
         SLR   @10,@15                                             0723
         ST    @10,PLHRECP(,RPLH)                                  0723
*RCDLOOP:                                                          0724
*   IF RDFEMPTY=ON THEN             /* EMPTY RECORD.                 */
RCDLOOP  L     @10,PLHRDFP(,RPLH)                                  0724
         TM    RDFEMPTY(@10),B'00000100'                           0724
         BNO   @RF00724                                            0724
*     IF PLHRECP>BUFCBAD THEN       /* NOT BEGINNING OF CI.          */
         L     @05,PLHRECP(,RPLH)                                  0725
         L     @15,PLHDBUFC(,RPLH)                                 0725
         C     @05,BUFCBAD(,@15)                                   0725
         BNH   @RF00725                                            0725
*       DO;                                                        0726
*         PLHRDFP=PLHRDFP+LENGTH(IDARDF);/* POINT TO PREV RDF.       */
         AL    @10,@CF00157                                        0727
         ST    @10,PLHRDFP(,RPLH)                                  0727
*         PLHRECP=PLHRECP-PLHLRECL; /* POINT TO PREV RECORD.         */
         SL    @05,PLHLRECL(,RPLH)                                 0728
         ST    @05,PLHRECP(,RPLH)                                  0728
*         GOTO RCDLOOP;             /* CONTINUE SEARCH.              */
         B     RCDLOOP                                             0729
*       END;                                                       0730
*     ELSE                          /* BEGINNING OF CI.              */
*       DO;                                                        0731
@RF00725 DS    0H                                                  0732
*         PLHRAHD=ON;               /* ALLOW READ AHEAD.             */
         OI    PLHRAHD(RPLH),B'01000000'                           0732
*         CALL ADVCI;               /* ADVANCE TO NEXT CI & SEARCH 0733
*                                      FOR RECORD.                   */
         BAL   @14,ADVCI                                           0733
*         PLHRAHD=OFF;              /* RESET READ AHEAD FLAG.        */
         NI    PLHRAHD(RPLH),B'10111111'                           0734
*         IF RPLERREG='08'X&RPLERRCD=RPLEODER THEN/* EOD - HIT     0735
*                                      BEGINNING OF DATA SET.        */
         CLI   RPLERREG(RRPL),8                                    0735
         BNE   @RF00735                                            0735
         CLI   RPLERRCD(RRPL),4                                    0735
         BNE   @RF00735                                            0735
*           RPLERRCD=RPLNOREC;      /* SET NO RECORD FOUND ERROR.    */
         MVI   RPLERRCD(RRPL),X'10'                                0736
*       END;                                                       0737
@RF00735 DS    0H                                                  0738
*   IF RPLERREG='00'X THEN          /* NO ERROR.                     */
@RF00724 CLI   RPLERREG(RRPL),0                                    0738
         BNE   @RF00738                                            0738
*     DO;                                                          0739
*       PLHSAVE1=BUFCDDDD+PLHRECP-BUFCBAD;/* SET RECORD RBA.         */
         L     @10,PLHDBUFC(,RPLH)                                 0740
         L     @05,BUFCDDDD(,@10)                                  0740
         AL    @05,PLHRECP(,RPLH)                                  0740
         SL    @05,BUFCBAD(,@10)                                   0740
         ST    @05,PLHSAVE1(,RPLH)                                 0740
*       PLHEFLGS=PLHVALID;          /* MAKE PLH VALID.               */
         MVC   PLHEFLGS(2,RPLH),@CB00797                           0741
*     END;                                                         0742
*   ELSE                            /* ERROR.                        */
*     PLHINVAL=ON;                  /* MAKE PLH INVALID.             */
         B     @RC00738                                            0743
@RF00738 OI    PLHINVAL(RPLH),B'00000010'                          0743
*   CALL EXIT;                      /* RETURN.                       */
@RC00738 BAL   @14,EXIT                                            0744
*   END LRD;                        /* END PROC. LRD.                */
@EL00006 DS    0H                                                  0745
@EF00006 DS    0H                                                  0745
@ER00006 BR    @14                                                 0745
*EXIT:                                                             0746
*                                                                  0746
*   /*****************************************************************/
*   /*                                                               */
*   /* EXIT ROUTINE --- RESTORES REGISTER 14 FROM PLH PUSHDOWN LIST &*/
*   /* RETURNS TO CALLER.                                            */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0746
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0746
EXIT     DS    0H                                                  0747
*   GEN(IDARST14);                  /* RESTORE REGISTER 14.          */
         IDARST14
*   RETURN;                         /* RETURN TO CALLER.             */
@EL00007 DS    0H                                                  0748
@EF00007 DS    0H                                                  0748
@ER00007 BR    @14                                                 0748
*   END EXIT;                       /* END PROC. EXIT.               */
*MODEXIT:                                                          0750
*                                                                  0750
*   /*****************************************************************/
*   /*                                                               */
*   /* MODULE EXIT ROUTINE --- RESTORES REGISTER 14 & RETURNS TO     */
*   /* CALLER OF MODULE.                                             */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0750
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0750
MODEXIT  DS    0H                                                  0751
*   GEN(IDARST14);                  /* RESTORE REG 14                */
         IDARST14
*   RETURN;                         /* EXIT FROM MODULE.             */
@EL00008 DS    0H                                                  0752
@EF00008 DS    0H                                                  0752
@ER00008 BR    @14                                                 0752
*   END MODEXIT;                    /* END PROC. MODEXIT.            */
@PB00008 DS    0H                                                  0754
*   GEN(IDAPATCH);                  /* DEFINE PATCH AREA.            */
         IDAPATCH
*   END IDA019RR                    /* END MODULE IDA019RR.          */
*                                                                  0755
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (IDAREGS )                                       */
*/*%INCLUDE SYSLIB  (IDARMRCD)                                       */
*/*%INCLUDE SYSLIB  (IFGRPL  )                                       */
*/*%INCLUDE SYSLIB  (IFGACB  )                                       */
*/*%INCLUDE SYSLIB  (IDAAMBL )                                       */
*/*%INCLUDE SYSLIB  (IDAAMB  )                                       */
*/*%INCLUDE SYSLIB  (IDAAMDSB)                                       */
*/*%INCLUDE SYSLIB  (IDAPLH  )                                       */
*/*%INCLUDE SYSLIB  (IDABUFC )                                       */
*/*%INCLUDE SYSLIB  (IDAARDB )                                       */
*/*%INCLUDE SYSLIB  (IDACIDF )                                       */
*/*%INCLUDE SYSLIB  (IDARDF  )                                       */
*                                                                  0755
*       ;                                                          0755
@EL00001 DS    0H                                                  0755
@EF00001 DS    0H                                                  0755
@ER00001 BR    @14                                                 0755
@DATA    DS    0H
@DATD    DSECT
         DS    0F
IDA019RR CSECT
         DS    0F
@CF00053 DC    F'1'
@CF00157 DC    F'3'
@CH00157 EQU   @CF00157+2
@CF00067 DC    F'4'
@CF00288 DC    F'7'
@DATD    DSECT
         DS    0D
IDA019RR CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
@CA00913 DC    A(IDARRDRL)
@CA00914 DC    A(IDAGXCTL)
@CV00904 DC    V(IDAABF)
@CV00905 DC    V(IDAGNXT)
@CV00906 DC    V(IDAGRB)
@CV00907 DC    V(IDAWRBFR)
@CV00908 DC    V(IDAFREEB)
@CV00909 DC    V(IDA019RQ)
@CV00910 DC    V(IDAAIBF)
@CV00911 DC    V(IDASBF)
@CV00912 DC    V(IDATJXIT)
         DS    0D
HWORD4   DC    H'4'
@CB00797 DC    X'0000'
@DATD    DSECT
*                                                          /*@X04SVLC*/
RDFCTNUA EQU   X'40'                    COMPLEX RDF INDICATOR
RDFCTNUX EQU   X'FF'-RDFCTNUA           RESET COMPLEX MASK
RDFREPLA EQU   X'08'                    COUNT RDF INDICATOR
RDFREPLX EQU   X'FF'-RDFREPLA           RESET COUNT MASK
RDFEMPTI EQU   X'04'                    EMPTY RECORD       /*@X04SVLC*/
RDFLEN   EQU   3                        LENGTH OF RDF
RDFLLOFF EQU   1                        OFFSET WITHIN RDF TO LL
RDFSGLR  EQU   X'00'                   MASK FOR SINGLE RECORD RDF
RDFGRP   EQU   RDFCTNUA                 MASK FOR LL RDF OF A GROUP RDF
RDFCNT   EQU   RDFREPLA                 MASK FOR COUNT RDF
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IDA019RR CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
RRPL     EQU   @01
RPLH     EQU   @02
RAMB     EQU   @03
RBUFC    EQU   @04
RWORK1   EQU   @05
RWORK2   EQU   @06
RWORK3   EQU   @07
RWORK4   EQU   @08
RWORK5   EQU   @09
RPARM1   EQU   @12
RWORK0   EQU   @00
R1       EQU   @01
R10      EQU   @10
R11      EQU   @11
R13      EQU   @13
R14      EQU   @14
R15      EQU   @15
IFGRPL   EQU   0
RPLCOMN  EQU   IFGRPL
RPLIDWD  EQU   RPLCOMN
RPLREQ   EQU   RPLIDWD+2
RPLLEN   EQU   RPLIDWD+3
RPLECB   EQU   RPLCOMN+8
RPLFDBWD EQU   RPLCOMN+12
RPLFDBK  EQU   RPLFDBWD+1
RPLRTNCD EQU   RPLFDBK
RPLERREG EQU   RPLRTNCD
RPLCNDCD EQU   RPLFDBK+1
RPLCMPON EQU   RPLCNDCD
RPLFDB2  EQU   RPLCMPON
RPLERRCD EQU   RPLCNDCD+1
RPLFDB3  EQU   RPLERRCD
RPLKEYLE EQU   RPLCOMN+16
RPLDACB  EQU   RPLCOMN+24
RPLAREA  EQU   RPLCOMN+32
RPLARG   EQU   RPLCOMN+36
RPLOPTCD EQU   RPLCOMN+40
RPLOPT1  EQU   RPLOPTCD
RPLLOC   EQU   RPLOPT1
RPLDIR   EQU   RPLOPT1
RPLSEQ   EQU   RPLOPT1
RPLSKP   EQU   RPLOPT1
RPLKGE   EQU   RPLOPT1
RPLECBSW EQU   RPLOPT1
RPLOPT2  EQU   RPLOPTCD+1
RPLADR   EQU   RPLOPT2
RPLBWD   EQU   RPLOPT2
RPLLRD   EQU   RPLOPT2
RPLUPD   EQU   RPLOPT2
RPLNSP   EQU   RPLOPT2
RPLOPT3  EQU   RPLOPTCD+2
RPLNXTRP EQU   RPLCOMN+44
RPLRLEN  EQU   RPLCOMN+48
RPLBUFL  EQU   RPLCOMN+52
RPLOPTC2 EQU   RPLCOMN+56
RPLOPT5  EQU   RPLOPTC2
RPLWRTYP EQU   RPLOPT5
RPLOPT6  EQU   RPLOPTC2+1
RPLUNTYP EQU   RPLOPT6
RPLOPT7  EQU   RPLOPTC2+2
RPLCNOPT EQU   RPLOPT7
RPLOPT8  EQU   RPLOPTC2+3
RPLRBAR  EQU   RPLCOMN+60
RPLAIXID EQU   RPLRBAR+2
RPLDDDD  EQU   RPLRBAR+4
RPLEXTDS EQU   RPLCOMN+68
RPLEXTD1 EQU   RPLEXTDS
IFGACB   EQU   0
ACBCOMN  EQU   IFGACB
ACBLENG  EQU   ACBCOMN+2
ACBLENG2 EQU   ACBLENG
ACBAMBL  EQU   ACBCOMN+4
ACBJWA   EQU   ACBAMBL
ACBMACRF EQU   ACBCOMN+12
ACBMACR1 EQU   ACBMACRF
ACBADR   EQU   ACBMACR1
ACBCNV   EQU   ACBMACR1
ACBMACR2 EQU   ACBMACRF+1
ACBBUFPL EQU   ACBCOMN+20
ACBMACR3 EQU   ACBBUFPL
ACBRECFM EQU   ACBCOMN+24
ACBCCTYP EQU   ACBCOMN+25
ACBOPT   EQU   ACBCOMN+26
ACBDSORG EQU   ACBOPT
ACBCROPS EQU   ACBDSORG
ACBEXLST EQU   ACBCOMN+36
ACBDDNM  EQU   ACBCOMN+40
ACBAMETH EQU   ACBDDNM+3
ACBOFLGS EQU   ACBCOMN+48
ACBEXFG  EQU   ACBOFLGS
ACBIOSFG EQU   ACBOFLGS
ACBINFLG EQU   ACBCOMN+50
ACBUJFCB EQU   ACBCOMN+52
ACBBLKSZ EQU   ACBCOMN+60
IDAAMBL  EQU   0
AMBLEOV  EQU   IDAAMBL+12
AMBLEFLG EQU   AMBLEOV
AMBLDDNM EQU   IDAAMBL+16
AMBLIDF  EQU   AMBLDDNM
AMBLQ    EQU   AMBLIDF+7
AMBLVC   EQU   IDAAMBL+28
AMBLTYPE EQU   IDAAMBL+30
AMBLSHAR EQU   IDAAMBL+33
AMBLFLG1 EQU   IDAAMBL+35
AMBLFLG2 EQU   IDAAMBL+36
IDAAMB   EQU   0
AMBDSB   EQU   IDAAMB+20
AMBEOVR  EQU   IDAAMB+24
AMBFLG0  EQU   AMBEOVR
AMBFLG1  EQU   IDAAMB+25
AMBCREAT EQU   AMBFLG1
AMBSPEED EQU   AMBFLG1
AMBJRN   EQU   AMBFLG1
AMBDSORG EQU   IDAAMB+26
AMBIOBAD EQU   IDAAMB+28
AMBINFL  EQU   IDAAMB+42
AMBDEBPT EQU   IDAAMB+44
AMBOFLGS EQU   IDAAMB+48
AMBFLG2  EQU   IDAAMB+49
AMBEOVPT EQU   IDAAMB+56
AMBCSWD1 EQU   IDAAMB+84
AMBAFLG  EQU   AMBCSWD1
IDAAMDSB EQU   0
AMDATTR  EQU   IDAAMDSB+1
AMDNEST  EQU   IDAAMDSB+4
AMDCINV  EQU   IDAAMDSB+20
AMDLRECL EQU   IDAAMDSB+24
AMDHLRBA EQU   IDAAMDSB+28
AMDNSLOT EQU   AMDHLRBA
AMDSSRBA EQU   IDAAMDSB+32
AMDMAXRR EQU   AMDSSRBA
AMDPARDB EQU   IDAAMDSB+36
AMDATTR3 EQU   IDAAMDSB+40
AMDSTAT  EQU   IDAAMDSB+48
AMDRETR  EQU   AMDSTAT+28
IDAPLHDR EQU   0
IDAPLH   EQU   0
PLHFLG1  EQU   IDAPLH+2
PLHASKBF EQU   PLHFLG1
PLHRDEXC EQU   PLHFLG1
PLHFLG2  EQU   IDAPLH+3
PLHUPD   EQU   PLHFLG2
PLHSVADV EQU   PLHFLG2
PLHEFLGS EQU   IDAPLH+4
PLH1ST   EQU   PLHEFLGS
PLHSKPER EQU   PLHEFLGS
PLHNOADV EQU   PLHEFLGS
PLHEODX  EQU   PLHEFLGS
PLHINVAL EQU   PLHEFLGS
PLHDSCAN EQU   PLHEFLGS
PLHRSTRT EQU   PLHEFLGS+1
PLHFLG3  EQU   IDAPLH+6
PLHRAHD  EQU   PLHFLG3
PLHBWD   EQU   PLHFLG3
PLHAFLGS EQU   IDAPLH+7
PLHBFRNO EQU   IDAPLH+15
PLHCRBA  EQU   IDAPLH+28
PLHJORBA EQU   PLHCRBA
PLHJCODE EQU   IDAPLH+40
PLHRCODE EQU   IDAPLH+41
PLHLRECL EQU   IDAPLH+48
PLHDBUFC EQU   IDAPLH+52
PLHRECP  EQU   IDAPLH+60
PLHFSP   EQU   IDAPLH+64
PLHRDFP  EQU   IDAPLH+68
PLHDIOB  EQU   IDAPLH+76
PLHSAVE1 EQU   IDAPLH+84
PLHRETO  EQU   IDAPLH+116
PLHRET1  EQU   IDAPLH+120
PLHEOVPT EQU   IDAPLH+180
PLHIXSPL EQU   IDAPLH+200
PLHSSRBA EQU   PLHIXSPL
PLHHIREC EQU   PLHSSRBA
PLHWAX   EQU   IDAPLH+232
PLHKEYPT EQU   IDAPLH+248
PLHEND   EQU   IDAPLH+280
PLHRRN   EQU   0
IDABUFDR EQU   0
BUFDRCIX EQU   IDABUFDR+9
BUFDRFLG EQU   IDABUFDR+11
IDABUFC  EQU   0
BUFCAVL  EQU   IDABUFC
BUFCFLG1 EQU   IDABUFC+1
BUFCINS  EQU   BUFCFLG1
BUFCVAL  EQU   BUFCFLG1
BUFCEXC  EQU   BUFCFLG1
BUFCIOFL EQU   IDABUFC+2
BUFCMW   EQU   BUFCIOFL
BUFCFLG2 EQU   IDABUFC+3
BUFCPLH  EQU   IDABUFC+4
BUFCDDDD EQU   IDABUFC+8
BUFCBAD  EQU   IDABUFC+20
BUFCINV  EQU   IDABUFC+28
BUFCNXT2 EQU   IDABUFC+37
IDAARDB  EQU   0
ARDTYPE  EQU   IDAARDB+1
ARDHRBA  EQU   IDAARDB+12
ARDPRF   EQU   IDAARDB+28
IDACIDF  EQU   0
CIDFLL   EQU   IDACIDF+2
IDARDF   EQU   0
RDFRBYTE EQU   IDARDF
RDFSEG   EQU   RDFRBYTE
RDFEMPTY EQU   RDFRBYTE
IDADATA  EQU   0
IDAKEY   EQU   0
ARGFIELD EQU   0
AREA     EQU   0
PLHKEY   EQU   0
PLHPDL   EQU   0
PLHPDLE  EQU   0
PLHEXTEN EQU   PLHEND
PLHBMWRK EQU   PLHEXTEN+5
PLHSAV1X EQU   PLHSAVE1
BUFCRSC1 EQU   BUFCAVL
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
PLHBMSV5 EQU   PLHEXTEN+24
PLHBMSV4 EQU   PLHEXTEN+20
PLHBMSV3 EQU   PLHEXTEN+16
PLHBMSV2 EQU   PLHEXTEN+12
PLHBMSV1 EQU   PLHEXTEN+8
PLHRDCNT EQU   PLHEXTEN+6
PLHBMSOV EQU   PLHBMWRK
PLHBEUC  EQU   PLHBMWRK
PLHBMRDF EQU   PLHBMWRK
@NM00042 EQU   PLHEXTEN+4
PLHRESR1 EQU   PLHEXTEN
KEY      EQU   IDAKEY
AMDATA   EQU   IDADATA
RDFLL    EQU   IDARDF+1
RDFREPL  EQU   RDFRBYTE
RDF1ST   EQU   RDFSEG
RDFNOT1  EQU   RDFSEG
RDFCTNU  EQU   RDFRBYTE
RDFTYPE  EQU   RDFRBYTE
@NM00047 EQU   CIDFLL
CIDFBUSY EQU   CIDFLL
CIDFOSET EQU   IDACIDF
ARDKEYS  EQU   IDAARDB+29
@NM00046 EQU   ARDPRF
ARDPRFMT EQU   ARDPRF
ARDPRSS  EQU   ARDPRF
ARDRELNO EQU   IDAARDB+26
ARDVOLSR EQU   IDAARDB+20
ARDERBA  EQU   IDAARDB+16
ARDHKRBA EQU   IDAARDB+8
ARDNPTR  EQU   IDAARDB+4
ARDLEN   EQU   IDAARDB+2
ARDUSED  EQU   ARDTYPE
ARDEOD   EQU   ARDTYPE
ARDUOVFL EQU   ARDTYPE
ARDSS    EQU   ARDTYPE
ARDHLI   EQU   ARDTYPE
ARDKR    EQU   ARDTYPE
ARDID    EQU   IDAARDB
BUFCEND  EQU   IDABUFC+64
BUFCUCDN EQU   IDABUFC+60
BUFCUCUP EQU   IDABUFC+56
BUFCMDBT EQU   IDABUFC+52
BUFCHAIN EQU   IDABUFC+48
BUFXORBA EQU   IDABUFC+44
BUFXIRBA EQU   IDABUFC+40
BUFCIDXL EQU   IDABUFC+36
BUFCDSPC EQU   IDABUFC+32
BUFCWLEN EQU   BUFCINV
BUFCNXT1 EQU   IDABUFC+24
BUFCCPA  EQU   IDABUFC+16
BUFCORBA EQU   IDABUFC+12
BUFCAMB  EQU   BUFCPLH
@NM00045 EQU   BUFCFLG2
BUFCEOD  EQU   BUFCFLG2
BUFCBSYW EQU   BUFCFLG2
BUFCBSYR EQU   BUFCFLG2
BUFCNLAS EQU   BUFCFLG2
BUFCXDDR EQU   BUFCFLG2
BUFCFIX  EQU   BUFCIOFL
BUFCPFCP EQU   BUFCIOFL
BUFCXEDB EQU   BUFCIOFL
BUFCWC   EQU   BUFCIOFL
BUFCREAL EQU   BUFCIOFL
BUFCRRD  EQU   BUFCIOFL
BUFCFMT  EQU   BUFCIOFL
BUFCEPT  EQU   BUFCFLG1
BUFCER2  EQU   BUFCFLG1
BUFCER1  EQU   BUFCFLG1
BUFCSEG  EQU   BUFCFLG1
BUFCUPG  EQU   BUFCFLG1
BUFCUCNT EQU   BUFCAVL
@NM00044 EQU   IDABUFDR+16
BUFDBUFC EQU   IDABUFDR+12
@NM00043 EQU   BUFDRFLG
BUFDRAVL EQU   BUFDRFLG
BUFDRREL EQU   BUFDRFLG
BUFDRTSB EQU   IDABUFDR+10
BUFDRMAX EQU   BUFDRCIX
BUFDRPFN EQU   IDABUFDR+8
BUFDRPFB EQU   IDABUFDR+4
BUFDRLEN EQU   IDABUFDR+2
BUFDRNO  EQU   IDABUFDR+1
BUFDRID  EQU   IDABUFDR
PLHERRET EQU   IDAPLH+276
PLHASCB  EQU   IDAPLH+272
PLHECB   EQU   IDAPLH+268
@NM00041 EQU   IDAPLH+265
PLHDRMSK EQU   IDAPLH+264
PLHR13   EQU   IDAPLH+260
PLHPARM1 EQU   IDAPLH+256
PLHDRRSC EQU   IDAPLH+252
PLHSLRBA EQU   IDAPLH+244
PLHSRCSG EQU   IDAPLH+242
PLHNOSEG EQU   IDAPLH+240
PLHLLOR  EQU   IDAPLH+236
PLHXPLH  EQU   PLHWAX
@NM00040 EQU   PLHIXSPL+8
PLHIXBFC EQU   PLHIXSPL+4
PLHISPLP EQU   IDAPLH+196
PLHRBUFC EQU   IDAPLH+192
PLHIBUFC EQU   IDAPLH+188
PLHNRBA  EQU   IDAPLH+184
PLHDDDD  EQU   PLHEOVPT
PLHAR14  EQU   IDAPLH+176
@NM00039 EQU   IDAPLH+172
@NM00038 EQU   IDAPLH+168
PLHASAVE EQU   IDAPLH+164
PLHRETOS EQU   IDAPLH+118
PLHCHAIN EQU   IDAPLH+112
PLHAMB   EQU   IDAPLH+108
PLHSAVE6 EQU   IDAPLH+104
PLHSAVE5 EQU   IDAPLH+100
PLHSAVE4 EQU   IDAPLH+96
PLHSAVE3 EQU   IDAPLH+92
PLHSAVE2 EQU   IDAPLH+88
PLHARET  EQU   IDAPLH+80
PLHIIOB  EQU   PLHDIOB
PLHSRSID EQU   IDAPLH+74
PLHRDFC  EQU   IDAPLH+72
PLHNBUFC EQU   IDAPLH+56
PLHARDB  EQU   IDAPLH+44
@NM00037 EQU   IDAPLH+43
PLHEOVR  EQU   IDAPLH+42
PLHUCODE EQU   PLHJCODE
PLHJNRBA EQU   IDAPLH+36
PLHJRNLL EQU   IDAPLH+32
PLHUPECB EQU   PLHJORBA
PLHDSIDA EQU   IDAPLH+24
PLHCRPL  EQU   IDAPLH+20
PLHMRPL  EQU   IDAPLH+16
PLHFRCNT EQU   IDAPLH+14
PLHRMIN  EQU   IDAPLH+13
PLHDSTYP EQU   IDAPLH+12
PLHACB   EQU   IDAPLH+8
PLHRAE   EQU   PLHAFLGS
PLHRABWD EQU   PLHAFLGS
PLHIOSID EQU   PLHAFLGS
PLHDBDC  EQU   PLHAFLGS
PLHVAMB  EQU   PLHAFLGS
PLHIOSRQ EQU   PLHAFLGS
PLHDRLM  EQU   PLHAFLGS
PLHEOVDF EQU   PLHFLG3
PLHRVRS  EQU   PLHFLG3
PLHSLVLD EQU   PLHFLG3
PLHSRBSG EQU   PLHFLG3
@NM00036 EQU   PLHEFLGS+1
PLHSRINV EQU   PLHEFLGS
PLHNOSPC EQU   PLHEFLGS
PLHIWAIT EQU   PLHFLG2
PLHCIINS EQU   PLHFLG2
PLHKRE   EQU   PLHFLG2
PLHADDTE EQU   PLHFLG2
PLHKEYMD EQU   PLHFLG2
PLHSQINS EQU   PLHFLG2
@NM00035 EQU   PLHFLG1
PLHDRPND EQU   PLHFLG1
PLHASYRQ EQU   PLHFLG1
PLHSSR   EQU   PLHFLG1
PLHENDRQ EQU   PLHFLG1
PLHEOVW  EQU   PLHFLG1
PLHATV   EQU   IDAPLH+1
PLHAVL   EQU   IDAPLH
PLHIOSDQ EQU   IDAPLHDR+12
PLHDRCUR EQU   IDAPLHDR+10
PLHDRMAX EQU   IDAPLHDR+8
PLHDRREQ EQU   IDAPLHDR+4
PLHELTH  EQU   IDAPLHDR+2
PLHCNT   EQU   IDAPLHDR+1
PLHID    EQU   IDAPLHDR
AMDEXCP  EQU   AMDSTAT+44
AMDNCAS  EQU   AMDSTAT+40
AMDNCIS  EQU   AMDSTAT+36
AMDASPA  EQU   AMDSTAT+32
AMDUPR   EQU   AMDSTAT+24
AMDIREC  EQU   AMDSTAT+20
AMDDELR  EQU   AMDSTAT+16
AMDNLR   EQU   AMDSTAT+12
AMDNEXT  EQU   AMDSTAT+10
AMDNIL   EQU   AMDSTAT+8
AMDSTSP  EQU   AMDSTAT
@NM00034 EQU   IDAAMDSB+41
@NM00033 EQU   AMDATTR3
AMDLM    EQU   AMDATTR3
AMDWAIT  EQU   AMDATTR3
AMDBIND  EQU   AMDATTR3
AMDFAULT EQU   AMDATTR3
AMDUNQ   EQU   AMDATTR3
AMDFSCI  EQU   IDAAMDSB+16
AMDFSCA  EQU   IDAAMDSB+14
AMDCIPCA EQU   IDAAMDSB+12
AMDPCTCI EQU   IDAAMDSB+11
AMDPCTCA EQU   IDAAMDSB+10
AMDKEYLN EQU   IDAAMDSB+8
AMDRKP   EQU   IDAAMDSB+6
AMDAXRKP EQU   AMDNEST
AMDLEN   EQU   IDAAMDSB+2
AMDSPAN  EQU   AMDATTR
AMDRRDS  EQU   AMDATTR
AMDRANGE EQU   AMDATTR
AMDORDER EQU   AMDATTR
AMDREPL  EQU   AMDATTR
AMDSDT   EQU   AMDATTR
AMDWCK   EQU   AMDATTR
AMDDST   EQU   AMDATTR
AMDSBID  EQU   IDAAMDSB
AMBTRACE EQU   IDAAMB+120
AMBVIOT  EQU   IDAAMB+116
AMBSZCP  EQU   IDAAMB+114
AMBSZFW  EQU   IDAAMB+112
AMBSZWR  EQU   IDAAMB+110
AMBSZRD  EQU   IDAAMB+108
AMBEXEX  EQU   IDAAMB+100
AMBWSHD  EQU   IDAAMB+96
AMBCPA   EQU   IDAAMB+92
AMBBM2SH EQU   IDAAMB+88
AMBRDCNT EQU   AMBCSWD1+2
@NM00032 EQU   AMBCSWD1+1
@NM00031 EQU   AMBAFLG
AMBCFX   EQU   AMBAFLG
AMBSIS   EQU   AMBAFLG
AMBDFR   EQU   AMBAFLG
AMBICI   EQU   AMBAFLG
AMBGSR   EQU   AMBAFLG
AMBLSR   EQU   AMBAFLG
@NM00030 EQU   AMBAFLG
AMBUPLH  EQU   IDAAMB+80
AMBPAMBL EQU   IDAAMB+76
AMBPIXP  EQU   IDAAMB+72
@NM00029 EQU   IDAAMB+68
AMBIWA   EQU   IDAAMB+64
AMBWKA   EQU   IDAAMB+60
AMBAMBXN EQU   AMBEOVPT
AMBEDB   EQU   IDAAMB+52
AMBRPT   EQU   IDAAMB+50
AMBPUG   EQU   AMBFLG2
AMBBUSY  EQU   AMBOFLGS
AMBEXFG  EQU   AMBOFLGS
@NM00028 EQU   AMBOFLGS
AMBOPEN  EQU   AMBOFLGS
@NM00027 EQU   AMBOFLGS
AMBDEBAD EQU   AMBDEBPT+1
AMBIFLGS EQU   AMBDEBPT
AMBAMETH EQU   IDAAMB+43
AMBUPX   EQU   AMBINFL
AMBUCRA  EQU   AMBINFL
AMBSCRA  EQU   AMBINFL
AMBCAT   EQU   AMBINFL
@NM00026 EQU   AMBINFL
@NM00025 EQU   AMBINFL
AMBTIOT  EQU   IDAAMB+40
@NM00024 EQU   IDAAMB+38
AMBDDSN  EQU   IDAAMB+35
AMBCDSN  EQU   IDAAMB+32
AMBIOMB  EQU   AMBIOBAD
@NM00023 EQU   AMBDSORG+1
AMBDORGA EQU   AMBDSORG+1
@NM00022 EQU   AMBDSORG
AMBINBUF EQU   AMBFLG1
AMBUBF   EQU   AMBFLG1
AMBPCAT  EQU   AMBFLG1
AMBMCAT  EQU   AMBFLG1
AMBTYPE  EQU   AMBFLG1
@NM00021 EQU   AMBFLG0
AMBPSDS  EQU   AMBFLG0
AMBCACB  EQU   IDAAMB+16
AMBPH    EQU   IDAAMB+12
AMBBUFC  EQU   IDAAMB+8
AMBLINK  EQU   IDAAMB+4
AMBLEN   EQU   IDAAMB+2
AMBRSC   EQU   IDAAMB+1
AMBID    EQU   IDAAMB
AMBLCMB  EQU   IDAAMBL+64
AMBLBIB  EQU   IDAAMBL+60
AMBLIX   EQU   IDAAMBL+56
AMBLDTA  EQU   IDAAMBL+52
AMBLMIDS EQU   IDAAMBL+42
AMBLNIDS EQU   IDAAMBL+41
@NM00020 EQU   IDAAMBL+40
AMBLNUM  EQU   IDAAMBL+38
AMBLNST  EQU   IDAAMBL+37
@NM00019 EQU   AMBLFLG2
AMBLSTAG EQU   AMBLFLG2
@NM00018 EQU   AMBLFLG2
AMBLDUMY EQU   AMBLFLG1
AMBLCAT  EQU   AMBLFLG1
AMBLUCRA EQU   AMBLFLG1
AMBLSCRA EQU   AMBLFLG1
AMBLVVIC EQU   AMBLFLG1
AMBLUPD  EQU   AMBLFLG1
AMBLCINV EQU   AMBLFLG1
AMBLFULL EQU   AMBLFLG1
AMBLLEN  EQU   IDAAMBL+34
@NM00017 EQU   AMBLSHAR
AMBLWRIT EQU   AMBLSHAR
AMBLCATO EQU   AMBLSHAR
AMBLPRIM EQU   AMBLSHAR
AMBLID   EQU   IDAAMBL+32
@NM00016 EQU   IDAAMBL+31
@NM00015 EQU   AMBLTYPE
AMBLFIX  EQU   AMBLTYPE
AMBLBASE EQU   AMBLTYPE
AMBLAIX  EQU   AMBLTYPE
AMBLUPGR EQU   AMBLTYPE
AMBLPATH EQU   AMBLTYPE
AMBLENO  EQU   AMBLVC+1
AMBLVRT  EQU   AMBLVC
AMBLXPT  EQU   IDAAMBL+24
AMBLDFR  EQU   AMBLQ
AMBLESDS EQU   AMBLQ
AMBLKSDS EQU   AMBLQ
AMBLUBF  EQU   AMBLQ
AMBLFSTP EQU   AMBLQ
AMBLLSR  EQU   AMBLQ
AMBLGSR  EQU   AMBLQ
AMBLDDC  EQU   AMBLQ
AMBLDCI  EQU   AMBLIDF+4
AMBLCACB EQU   AMBLIDF
@NM00014 EQU   AMBLEOV+2
AMBLCOMP EQU   AMBLEOV+1
AMBLESET EQU   AMBLEFLG
AMBLWAIT EQU   AMBLEFLG
AMBLACB  EQU   IDAAMBL+8
AMBLSCHN EQU   IDAAMBL+4
AMBLPCHN EQU   IDAAMBL
ACBAPID  EQU   ACBCOMN+72
ACBCBMWA EQU   ACBCOMN+68
ACBUAPTR EQU   ACBCOMN+64
ACBLRECL EQU   ACBCOMN+62
ACBMSGLN EQU   ACBBLKSZ
ACBBUFSP EQU   ACBCOMN+56
@NM00013 EQU   ACBUJFCB+1
ACBOPTN  EQU   ACBUJFCB
ACBVVIC  EQU   ACBINFLG
ACBUCRA  EQU   ACBINFLG
ACBSCRA  EQU   ACBINFLG
ACBCAT   EQU   ACBINFLG
ACBIJRQE EQU   ACBINFLG
ACBJEPS  EQU   ACBINFLG
@NM00012 EQU   ACBINFLG
ACBERFLG EQU   ACBCOMN+49
ACBBUSY  EQU   ACBIOSFG
ACBLOCK  EQU   ACBEXFG
@NM00011 EQU   ACBOFLGS
ACBDSERR EQU   ACBOFLGS
ACBOPEN  EQU   ACBOFLGS
ACBEOV   EQU   ACBOFLGS
@NM00010 EQU   ACBOFLGS
ACBDEB   EQU   ACBDDNM+5
ACBERFL  EQU   ACBDDNM+4
ACBAM    EQU   ACBAMETH
ACBINFL  EQU   ACBDDNM+2
ACBTIOT  EQU   ACBDDNM
ACBUEL   EQU   ACBEXLST
ACBPASSW EQU   ACBCOMN+32
ACBMSGAR EQU   ACBCOMN+28
@NM00009 EQU   ACBDSORG+1
ACBDORGA EQU   ACBDSORG+1
@NM00008 EQU   ACBDSORG
ACBCRNRE EQU   ACBCROPS
ACBCRNCK EQU   ACBCROPS
ACBASA   EQU   ACBCCTYP
@NM00007 EQU   ACBCCTYP
ACBRECAF EQU   ACBRECFM
ACBJBUF  EQU   ACBBUFPL+2
ACBMACR4 EQU   ACBBUFPL+1
@NM00006 EQU   ACBMACR3
ACBNCFX  EQU   ACBMACR3
ACBSIS   EQU   ACBMACR3
ACBDFR   EQU   ACBMACR3
ACBICI   EQU   ACBMACR3
ACBGSR   EQU   ACBMACR3
ACBLSR   EQU   ACBMACR3
@NM00005 EQU   ACBMACR3
ACBBUFNI EQU   ACBCOMN+18
ACBBUFND EQU   ACBCOMN+16
ACBSTRNO EQU   ACBCOMN+15
ACBBSTNO EQU   ACBCOMN+14
ACBAIX   EQU   ACBMACR2
ACBDSN   EQU   ACBMACR2
ACBRST   EQU   ACBMACR2
ACBLOGON EQU   ACBMACR2
ACBSKP   EQU   ACBMACR2
@NM00004 EQU   ACBMACR2
ACBUBF   EQU   ACBMACR1
ACBOUT   EQU   ACBMACR1
ACBIN    EQU   ACBMACR1
ACBDIR   EQU   ACBMACR1
ACBSEQ   EQU   ACBMACR1
ACBBLK   EQU   ACBCNV
ACBADD   EQU   ACBADR
ACBKEY   EQU   ACBMACR1
ACBINRTN EQU   ACBCOMN+8
ACBIBCT  EQU   ACBJWA
ACBLEN2  EQU   ACBLENG2
ACBSTYP  EQU   ACBCOMN+1
ACBID    EQU   ACBCOMN
RPLERMSA EQU   RPLCOMN+72
RPLEMLEN EQU   RPLCOMN+70
RPLACTIV EQU   RPLCOMN+69
RPLBRANC EQU   RPLEXTD1
RPLNIB   EQU   RPLEXTD1
@NM00003 EQU   RPLEXTD1
RPLEXIT  EQU   RPLEXTD1
RPLNEXIT EQU   RPLEXTD1
RPLEXSCH EQU   RPLEXTD1
@NM00002 EQU   RPLRBAR+3
@NM00001 EQU   RPLAIXID
RPLAXPKP EQU   RPLAIXID
RPLAIXPC EQU   RPLRBAR
RPLRSV88 EQU   RPLOPT8
RPLUNCON EQU   RPLOPT8
RPLACTV  EQU   RPLOPT8
RPLSESS  EQU   RPLOPT8
RPLPEND  EQU   RPLOPT8
RPLODPRM EQU   RPLOPT8
RPLODACP EQU   RPLOPT8
RPLODACQ EQU   RPLOPT8
RPLRSV78 EQU   RPLOPT7
RPLRSV77 EQU   RPLOPT7
RPLRLSOP EQU   RPLOPT7
RPLTPOST EQU   RPLOPT7
RPLQOPT  EQU   RPLOPT7
RPLCNIMM EQU   RPLCNOPT
RPLCNANY EQU   RPLCNOPT
RPLCNALL EQU   RPLCNOPT
RPLRSV68 EQU   RPLOPT6
RPLRSV67 EQU   RPLOPT6
RPLLOCK  EQU   RPLOPT6
RPLNCOND EQU   RPLOPT6
RPLCOND  EQU   RPLOPT6
RPLEOT   EQU   RPLUNTYP
RPLEOM   EQU   RPLUNTYP
RPLEOB   EQU   RPLUNTYP
RPLWROPT EQU   RPLOPT5
RPLNODE  EQU   RPLOPT5
RPLERACE EQU   RPLWRTYP
RPLEAU   EQU   RPLWRTYP
RPLNERAS EQU   RPLWRTYP
RPLPSOPT EQU   RPLOPT5
RPLSSNIN EQU   RPLOPT5
RPLDLGIN EQU   RPLOPT5
RPLCHAIN EQU   RPLNXTRP
RPLOPT4  EQU   RPLOPTCD+3
RPLALIGN EQU   RPLOPT3
RPLFMT   EQU   RPLOPT3
RPLFLD   EQU   RPLOPT3
RPLVFY   EQU   RPLOPT3
RPLBLK   EQU   RPLOPT3
RPLSFORM EQU   RPLOPT3
RPLEODS  EQU   RPLOPT3
RPLWAITX EQU   RPLOPT2
RPLCNV   EQU   RPLOPT2
RPLADD   EQU   RPLADR
RPLKEY   EQU   RPLOPT2
RPLECBIN EQU   RPLECBSW
RPLGEN   EQU   RPLOPT1
RPLASY   EQU   RPLOPT1
RPLDAF   EQU   RPLARG+2
RPLSAF   EQU   RPLARG
RPLTCBPT EQU   RPLCOMN+28
RPLCCHAR EQU   RPLCOMN+20
RPLSTRID EQU   RPLCOMN+18
RPLKEYL  EQU   RPLKEYLE
RPLRDSOH EQU   RPLFDB3
RPLRLG   EQU   RPLFDB3
RPLLGFRC EQU   RPLFDB3
RPLREOT  EQU   RPLFDB3
RPLREOM  EQU   RPLFDB3
RPLREOB  EQU   RPLFDB3
RPLSV32  EQU   RPLFDB3
RPLUINPT EQU   RPLFDB3
RPLSTSAV EQU   RPLFDB2
RPLCUERR EQU   RPLFDB2
RPLDLGFL EQU   RPLFDB2
RPLIOERR EQU   RPLFDB2
RPLDVUNS EQU   RPLFDB2
RPLATND  EQU   RPLFDB2
RPLRVID  EQU   RPLFDB2
RPLERLK  EQU   RPLFDB2
RPLSTAT  EQU   RPLFDBWD
RPLPOST  EQU   RPLECB
RPLWAIT  EQU   RPLECB
RPLPLHPT EQU   RPLCOMN+4
RPLLEN2  EQU   RPLLEN
RPLSTYP  EQU   RPLIDWD+1
RPLID    EQU   RPLIDWD
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RC00230 EQU   @EC00270
@RT00402 EQU   RECSRCH
@RC00405 EQU   @RC00384
@RC00424 EQU   @RC00421
@RT00524 EQU   NXTRCD
@RT00547 EQU   PRVRCD
@RC00506 EQU   @EL00003
@RT00603 EQU   GNXTCI
@RT00611 EQU   GNXTCI
@RT00662 EQU   RECLOOP
@RF00691 EQU   @RC00689
@PB00007 EQU   @PB00008
@PB00006 EQU   @PB00007
@PB00005 EQU   @PB00006
@PB00004 EQU   @PB00005
@PB00003 EQU   @PB00004
@PB00002 EQU   @PB00003
@ENDDATA EQU   *
         END   IDA019RR,(C'PLS2121',0701,78172)
