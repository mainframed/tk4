         TITLE 'IDA019R1 VALIDATE AND DECODE                           *
                        '
IDA019R1 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IDA019R1  78.209'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @11,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@11                                         0001
*   R15SAVE=ZERO;                   /* NO ERRORS YET                 */
         SLR   @10,@10                                             0174
         ST    @10,R15SAVE(,R13)                                   0174
*   RAMB=AMBLDTA;                   /* SET AMB REG                   */
         L     @10,RPLDACB(,RRPL)                                  0175
         L     @10,ACBAMBL(,@10)                                   0175
         L     RAMB,AMBLDTA(,@10)                                  0175
*   GEN(LA RRPL,0(RRPL));           /* CLEAR HI ORDER BYTE   @ZA14827*/
         LA RRPL,0(RRPL)
*/* FIRST CHECK FOR GET OR PUT.  IF EITHER, GO TO GET/PUT ROUTINE.   */
*/* OTHERWISE, MASK OFF REGISTER ZERO AND GO THROUGH BRANCH TABLE.   */
*                                                                  0177
*   IF RWORK0<=RPLPUT THEN          /* GET OR PUT?           @X04SVMR*/
         CL    RWORK0,@CF00053                                     0177
         BNH   @RT00177                                            0177
*     GO TO PUT;                    /* YES, PROCESS.         @X04SVMR*/
*   ELSE                            /* NOT GET OR PUT        @0X4SVMR*/
*     DO;                                                          0179
*       RPARM1=RWORK0;              /* SAVE REG 0            @X04SVMR*/
         LR    RPARM1,RWORK0                                       0180
*       RWORK0=RWORK0&ANDCON;       /* MASK 3 HIGH BYTES     @X04SVMR*/
         N     RWORK0,@CF01256                                     0181
*       DO;                         /* CASE(RWORK0)NAMES(PUT,CHECK,PO
*                                      INT,ENDREQ,ERASE,VERIFY,INVALI
*                                      D,PFMTD,PFMTI,FRCIO,GETIX,PUTI
*                                      X,SCHBFR,MRKBFR,WRTBFR,INVALID
*                                      ,INVALID,INVALID,TERMRPL)     */
*         DCL                                                      0183
*           CL0001@ LABEL BASED(CP0001@(RWORK0)) VALUERANGE(PUT,CHECK,
*               POINT,ENDREQ,ERASE,VERIFY,INVALID,PFMTD,PFMTI,FRCIO,
*               GETIX,PUTIX,SCHBFR,MRKBFR,WRTBFR,INVALID,INVALID,  0183
*               INVALID,TERMRPL);   /* BRANCH TARGET                 */
*         DCL                                                      0184
*           CP0001@(19) PTR(31) INIT(ADDR(PUT),ADDR(CHECK),ADDR(POINT),
*               ADDR(ENDREQ),ADDR(ERASE),ADDR(VERIFY),ADDR(INVALID),
*               ADDR(PFMTD),ADDR(PFMTI),ADDR(FRCIO),ADDR(GETIX),ADDR(
*               PUTIX),ADDR(SCHBFR),ADDR(MRKBFR),ADDR(WRTBFR),ADDR(
*               INVALID),ADDR(INVALID),ADDR(INVALID),ADDR(TERMRPL));
*         GOTO CL0001@;             /* BRANCH TO SELECTED CASE       */
         LR    @10,RWORK0                                          0185
         SLL   @10,2                                               0185
         L     @10,CP0001@-4(@10)                                  0185
         BR    @10                                                 0185
*CHECK:                                                            0186
*         DO;                       /* SUBCASE                       */
*                                                                  0186
CHECK    DS    0H                                                  0187
*           /*********************************************************/
*           /*                                                       */
*           /* DO WORK FOR A CHECK                                   */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0187
*           IF(RPLERREG='08'X&      /* SEE IF NO PLH                 */
*               RPLERRCD=RPLNOPLH)× /* WAS FOUND ON PRIOR REQ        */
*               RPLACTIV=CZERO      /* OR IF RPL NOT ACTIVE.         */
*             THEN                  /* IF SO, RETURN.        @X04SVMR*/
         CLI   RPLERREG(RRPL),8                                    0187
         BNE   @GL00001                                            0187
         CLI   RPLERRCD(RRPL),64                                   0187
         BE    @RT00187                                            0187
@GL00001 CLI   RPLACTIV(RRPL),B'00000000'                          0187
         BNE   @RF00187                                            0187
@RT00187 DS    0H                                                  0188
*             R15SAVE=RPLERREG;                                    0188
         SLR   @10,@10                                             0188
         IC    @10,RPLERREG(,RRPL)                                 0188
         ST    @10,R15SAVE(,R13)                                   0188
*           ELSE                    /* HERE IF PRIOR OK      @X04SVMR*/
*             DO;                                                  0189
         B     @RC00187                                            0189
@RF00187 DS    0H                                                  0190
*               CALL FINDOPLH;      /* GO LOCATE PLH         @X04SVMR*/
         BAL   @14,FINDOPLH                                        0190
*               RFY                                                0191
*                 R15 RSTD;         /* GET RETURN CODE               */
*               IF R15=ZERO THEN    /* IF NO ERROR,          @X04SVMR*/
         LTR   R15,R15                                             0192
         BNZ   @RF00192                                            0192
*                 DO;               /* PROCESS CHECK         @X04SVMR*/
*                   RFY                                            0194
*                     R15 UNRSTD;   /* DROP RETURN CODE              */
*                   CALL R1CHECK;   /* GO PERFORM CHECK RTN          */
         BAL   @14,R1CHECK                                         0195
*                 END;              /* END, PLH FOUND        @X04SVMR*/
*               ELSE                /* NO PLH FOUND          @ZA14801*/
*                 R15SAVE='04'X;    /* CNTL BLOCKS BAD       @ZA14801*/
         B     @RC00192                                            0197
@RF00192 LA    @10,4                                               0197
         ST    @10,R15SAVE(,R13)                                   0197
*             END;                  /* END PRIOR OK          @X04SVMR*/
*           GOTO CE0001@;           /* BRANCH TO END OF CASE         */
         B     CE0001@                                             0199
*         END CHECK;                /* END OF SUBCASE                */
*ENDREQ:                                                           0201
*         DO;                       /* SUBCASE                       */
ENDREQ   DS    0H                                                  0202
*           IF RPLERREG='08'X&      /* SEE IF NO PLH         @X04SVMR*/
*               RPLERRCD=RPLNOPLH THEN/* FOUND BEFORE        @X04SVMR*/
         CLI   RPLERREG(RRPL),8                                    0202
         BNE   @RF00202                                            0202
         CLI   RPLERRCD(RRPL),64                                   0202
         BNE   @RF00202                                            0202
*             R15SAVE=RPLERREG;     /* SET USER R15          @X04SVMR*/
         SLR   @10,@10                                             0203
         IC    @10,RPLERREG(,RRPL)                                 0203
         ST    @10,R15SAVE(,R13)                                   0203
*           ELSE                    /* HERE IF OK            @X04SVMR*/
*             DO;                                                  0204
         B     @RC00202                                            0204
@RF00202 DS    0H                                                  0205
*               CALL FINDOPLH;      /* GO LOCATE PLH         @X04SVMR*/
         BAL   @14,FINDOPLH                                        0205
*               RFY                                                0206
*                 R15 RSTD;         /* GET RETURN CODE               */
*               IF R15=ZERO THEN    /* IF NO ERROR,          @X04SVMR*/
         LTR   R15,R15                                             0207
         BNZ   @RF00207                                            0207
*                 DO;               /* PROCESS ENDREQ        @X04SVMR*/
*                   RFY                                            0209
*                     R15 UNRSTD;   /* DROP RETURN CODE              */
*                   IF AMBLPATH=ON THEN/* IF PATH ACB, CALL  @X04SVMR*/
         L     @10,RPLDACB(,RRPL)                                  0210
         L     @10,ACBAMBL(,@10)                                   0210
         TM    AMBLPATH(@10),B'10000000'                           0210
         BNO   @RF00210                                            0210
*I05:                                                              0211
*                     DO;           /* IDACALL(IDA019RX)             */
I05      DS    0H                                                  0212
*                       CALL IDA019RX;/* EXIT TO IDA019RX            */
         L     @15,@CV01241                                        0212
         BALR  @14,@15                                             0212
*                       GEN(BALR @11,0);/* LOAD ADDR OF REENTRY      */
         BALR @11,0
*                       GEN(USING *,@11);/* ESTABLISH ADDRESSING     */
         USING *,@11
*                       GEN(L     @11,=A(@PSTART));/* RELOAD BASE    */
         L     @11,=A(@PSTART)
*                       GEN(USING @PSTART,@11);/* ESTABLISH        0216
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                     END I05;      /* PATH PROCESSOR.       @X04SVMR*/
*                   ELSE            /* NOT PATH,             @X04SVMR*/
*I06:                                                              0218
*                     DO;           /* IDACALL(IDAENDRQ)             */
         B     @RC00210                                            0218
@RF00210 DS    0H                                                  0218
I06      DS    0H                                                  0219
*                       CALL IDAENDRQ;/* EXIT TO IDAENDRQ            */
         L     @15,@CV01238                                        0219
         BALR  @14,@15                                             0219
*                       GEN(BALR @11,0);/* LOAD ADDR OF REENTRY      */
         BALR @11,0
*                       GEN(USING *,@11);/* ESTABLISH ADDRESSING     */
         USING *,@11
*                       GEN(L     @11,=A(@PSTART));/* RELOAD BASE    */
         L     @11,=A(@PSTART)
*                       GEN(USING @PSTART,@11);/* ESTABLISH        0223
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                     END I06;      /* PERFORM ENDREQ        @X04SVMR*/
*                   IF ACBIOSFG=OFF THEN/* IF NOT CLOSE,     @ZA14801*/
@RC00210 L     @10,RPLDACB(,RRPL)                                  0225
         TM    ACBIOSFG(@10),B'00000001'                           0225
         BNZ   @RF00225                                            0225
*                     RPLFDBWD=ZERO;/* CLEAR PRIOR ERROR     @ZA14801*/
         SLR   @10,@10                                             0226
         ST    @10,RPLFDBWD(,RRPL)                                 0226
*                 END;              /* END, PLH FOUND        @X04SVMR*/
*             END;                  /* END, NO PRIOR ERR     @X04SVMR*/
*           GOTO CE0001@;           /* BRANCH TO END OF CASE         */
         B     CE0001@                                             0229
*         END ENDREQ;               /* END OF SUBCASE                */
*TERMRPL:                                                          0231
*         DO;                       /* SUBCASE TERMRPL       @ZA32757*/
TERMRPL  DS    0H                                                  0232
*/********************************************************************/
*/*  SUBCASE FOR TERMRPL                                             */
*/*  INPUT - RPL ADDRESS IN REGISTER 1.                              */
*/*        - DATA AMB ADDRESS IN REGISTER 3.                         */
*/*  OUTPUT - R15, RPLFDBWD.                                         */
*/********************************************************************/
*                                                                  0232
*           CALL FINDOPLH;          /* VALIDITY CHECK PLH    @ZA32757*/
         BAL   @14,FINDOPLH                                        0232
*           RFY                                                    0233
*             R15 RSTD;             /* RESTRICT REGISTER     @ZA32757*/
*           IF R15=ZERO THEN        /* PLH VALID?            @ZA32757*/
         LTR   R15,R15                                             0234
         BNZ   @RF00234                                            0234
*             DO;                   /* YES                   @ZA32757*/
*               RFY                                                0236
*                 R15 UNRSTD;       /* UNRESTRICT REG.       @ZA32757*/
*I09:                                                              0237
*               DO;                 /* IDACALL(IDA019SN)             */
I09      DS    0H                                                  0238
*                 CALL IDA019SN;    /* EXIT TO IDA019SN              */
         L     @15,@CV01253                                        0238
         BALR  @14,@15                                             0238
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I09;            /* CALL TERMINATE RPL    @ZA32757*/
*               R15SAVE=RPLERREG;   /* SET R15 = RPLERREG    @ZA32757*/
         SLR   @10,@10                                             0244
         IC    @10,RPLERREG(,RRPL)                                 0244
         ST    @10,R15SAVE(,R13)                                   0244
*             END;                  /* END OF PLH VALID      @ZA32757*/
*           ELSE                                                   0246
*             R15SAVE='04'X;        /* ELSE CONTROL BLOCK ERROR, SET
*                                      FEEDBACK CODE         @ZA32757*/
         B     @RC00234                                            0246
@RF00234 LA    @10,4                                               0246
         ST    @10,R15SAVE(,R13)                                   0246
*           GOTO CE0001@;           /* BRANCH TO END OF CASE         */
         B     CE0001@                                             0247
*         END TERMRPL;              /* END OF SUBCASE                */
*PUT:                                                              0249
*POINT:                                                            0249
*ERASE:                                                            0249
*VERIFY:                                                           0249
*INVALID:                                                          0249
*PFMTD:                                                            0249
*PFMTI:                                                            0249
*FRCIO:                                                            0249
*GETIX:                                                            0249
*PUTIX:                                                            0249
*         DO;                       /* SUBCASE                       */
PUT      DS    0H                                                  0249
POINT    DS    0H                                                  0249
ERASE    DS    0H                                                  0249
VERIFY   DS    0H                                                  0249
INVALID  DS    0H                                                  0249
PFMTD    DS    0H                                                  0249
PFMTI    DS    0H                                                  0249
FRCIO    DS    0H                                                  0249
GETIX    DS    0H                                                  0249
PUTIX    DS    0H                                                  0250
*GET:                                                              0250
*                                                                  0250
*/*  PROCESS GET, PUT, POINT, ETC.                           @X04SVMR*/
*                                                                  0250
*           RFY                                                    0250
*             RWORK1 RSTD;          /* GET WORK REG          @X04SVMR*/
GET      DS    0H                                                  0251
*           RWORK1=RRPL;            /* SAVE FIRST RPL ADDR           */
         LR    RWORK1,RRPL                                         0251
*           DO UNTIL RRPL=ZERO;     /* SET UP ALL RPLS       @X04SVMR*/
@DL00252 DS    0H                                                  0253
*/* SEE IF RPL STILL ACTIVE AND IF SO ERROR                          */
*                                                                  0253
*             TS(RPLACTIV);         /* SEE IF RPL IN USE             */
         TS    RPLACTIV(RRPL)                                      0253
*             BC(8,SETCODE);        /* IF NOT,MAKE ACTIVE & BR       */
         BC    8,SETCODE                                           0254
*INVRPL:                                                           0255
*             RPARM1=RRPL;          /* LAST RPL CHAIN PTR            */
INVRPL   LR    RPARM1,RRPL                                         0255
*             RRPL=RWORK1;          /* FIRST RPL TO FREE             */
         LR    RRPL,RWORK1                                         0256
*             CALL R1TERM;          /* RELEASE RPLS JUST GOT         */
         BAL   @14,R1TERM                                          0257
*             RETURN CODE('04'X);   /* RETURN TO USER                */
         LA    @15,4                                               0258
         L     @14,12(,@13)                                        0258
         LM    @00,@12,20(@13)                                     0258
         BR    @14                                                 0258
*SETCODE:                                                          0259
*             IF RWORK1->RPLDACB^=RPLDACB/* IF DIFFERENT ACB,        */
*               THEN                /* SET ERROR CONDITION.          */
SETCODE  CLC   RPLDACB(4,RWORK1),RPLDACB(RRPL)                     0259
         BNE   @RT00259                                            0259
*               GO TO INVRPL;       /* ERROR EXIT                    */
*             RPLREQ=RWORK0;        /* SET REQUEST CODE              */
         STC   RWORK0,RPLREQ(,RRPL)                                0261
*/* CHECK FOR ECB IN RPL                                             */
*                                                                  0262
*             IF RPLECBSW=ON        /* IS IT IN RPL          @X04SVMR*/
*               THEN                /* NO                    @X04SVMR*/
         TM    RPLECBSW(RRPL),B'00000001'                          0262
         BNO   @RF00262                                            0262
*               USERECB=ZERO;       /* CLEAR ECB             @X04SVMR*/
         L     @10,RPLECBPT(,RRPL)                                 0263
         SLR   @15,@15                                             0263
         STCM  @15,15,USERECB(@10)                                 0263
*             ELSE                  /* IN RPL                @X04SVMR*/
*               RPLECB=ZERO;        /* CLEAR ECB             @X04SVMR*/
         B     @RC00262                                            0264
@RF00262 SLR   @10,@10                                             0264
         ST    @10,RPLECB(,RRPL)                                   0264
*             RPLFDBWD=ZERO;        /* CLEAR ERROR FIELD     @X04SVMR*/
@RC00262 SLR   @10,@10                                             0265
         ST    @10,RPLFDBWD(,RRPL)                                 0265
*             IF RWORK1->RPLASY=ON  /* SEE IF MASTER                 */
*               THEN                /* RPL IS ASYNCH                 */
         TM    RPLASY(RWORK1),B'00001000'                          0266
         BNO   @RF00266                                            0266
*               RPLASY=ON;                                         0267
         OI    RPLASY(RRPL),B'00001000'                            0267
*             ELSE                  /* YES, PROPAGATE CODE           */
*               RPLASY=OFF;                                        0268
         B     @RC00266                                            0268
@RF00266 NI    RPLASY(RRPL),B'11110111'                            0268
*             RRPL=RPLCHAIN;        /* GET NEXT RPL IN CHAIN         */
@RC00266 L     RRPL,RPLCHAIN(,RRPL)                                0269
*           END;                    /* END, CHAINED RPLS             */
@DE00252 LTR   RRPL,RRPL                                           0270
         BNZ   @DL00252                                            0270
*           RRPL=RWORK1;            /* RESTORE 1ST RPL PTR           */
         LR    RRPL,RWORK1                                         0271
*           CALL FINDPLH;           /* LOCATE PLACEHOLDER            */
         BAL   @14,FINDPLH                                         0272
*           RFY                                                    0273
*             R15 RSTD;             /* GET RETURN CODE               */
*           IF R15^=ZERO            /* IF ANY ERROR,                 */
*             THEN                  /* RELEASE ALL RPLS IN           */
         LTR   R15,R15                                             0274
         BZ    @RF00274                                            0274
*             DO;                   /* THE CHAIN.                    */
*NOPLHFND:                                                         0276
*               RPARM1=ZERO;        /* SET FREE ALL INDICATOR        */
NOPLHFND SLR   RPARM1,RPARM1                                       0276
*               IF RPLASY=OFF THEN  /* IF SYNCHRONOUS REQUEST        */
         TM    RPLASY(RRPL),B'00001000'                            0277
         BNZ   @RF00277                                            0277
*                 R15SAVE=R15;      /* SET RETURN CODE               */
         ST    R15,R15SAVE(,R13)                                   0278
*               CALL R1TERM;        /* FREE RPL CHAIN                */
@RF00277 BAL   @14,R1TERM                                          0279
*               RETURN;             /* SYNCHRONOUS--LOGIC. ERR       */
@EL00001 DS    0H                                                  0280
@EF00001 DS    0H                                                  0280
@ER00001 LM    @14,@12,12(@13)                                     0280
         BR    @14                                                 0280
*             END;                  /* END OF RPL RELEASE            */
*           RFY                                                    0282
*             R15 UNRSTD;           /* DROP RETURN CODE              */
@RF00274 DS    0H                                                  0283
*           RFY                                                    0283
*             RWORK1 UNRSTD;        /* DROP RPL SAVE REG     @X04SVMR*/
*           IF AMBUBF=ON&           /* USER BUFFERING        @ZA14798*/
*               (RPLADR=ON×RPLKEY=ON) THEN/* AND NOT CNV     @ZA14798*/
         TM    AMBUBF(RAMB),B'00000100'                            0284
         BNO   @RF00284                                            0284
         TM    RPLADR(RRPL),B'11000000'                            0284
         BZ    @RF00284                                            0284
*             DO;                   /*                       @ZA14798*/
*               RPLERRCD=RPLINVP;   /* SET INV. PRMS         @ZA14798*/
         MVI   RPLERRCD(RRPL),X'68'                                0286
*               GO TO ERRORX;       /* GO SET LOG.ERR        @ZA14798*/
         B     ERRORX                                              0287
*             END;                  /*                       @ZA14798*/
*           RESPECIFY                                              0289
*             RWORK0 UNRESTRICTED;  /* DROP REGISTER                 */
@RF00284 DS    0H                                                  0290
*                                                                  0290
*/*  PROCESS THE RPLS IN THE CHAIN UNTIL ALL ARE DONE OR AN ENDREQ   */
*/*       IS ISSUED                                                  */
*                                                                  0290
*           DO UNTIL RRPL=ZERO;     /* PROCESS RPLS          @X04SVMR*/
@DL00290 DS    0H                                                  0291
*             RPARM1=ACBAMBL;       /* POINT TO AMBL                 */
         L     @10,RPLDACB(,RRPL)                                  0291
         L     RPARM1,ACBAMBL(,@10)                                0291
*             RFY                                                  0292
*               IDAAMBL BASED(RPARM1);/* RESET AMBL BASE             */
*             PLHCRPL=RRPL;         /* SET CURRENT RPL               */
         ST    RRPL,PLHCRPL(,RPLH)                                 0293
*             RPLPLHPT=RPLH;        /* SAVE PTR TO PLH@0X02679       */
         ST    RPLH,RPLPLHPT(,RRPL)                                0294
*             IF RPLWAITX=ON&       /* IF WAITX OPTION       @ZA07549*/
*                 AMBGSR=OFF&       /* AND NOT GSR OR        @ZA07549*/
*                 AMBLSR=OFF THEN   /* LSR OPTIONS           @ZA07549*/
         TM    RPLWAITX(RRPL),B'00000100'                          0295
         BNO   @RF00295                                            0295
         TM    AMBGSR(RAMB),B'01100000'                            0295
         BZ    @RT00295                                            0295
*               GOTO INVACC;        /* EXIT WITH ERROR       @ZA07549*/
*/*  IF THE REQUEST IS THROUGH A PATH AMBL CALL THE PATH PROCESSOR   */
*/*  FOR ALTERNATE INDEX ACCESS.                             @X04SVMR*/
*                                                                  0297
*             IF AMBLPATH=ON THEN   /* TEST FOR PATH         @X04SVMR*/
@RF00295 TM    AMBLPATH(RPARM1),B'10000000'                        0297
         BNO   @RF00297                                            0297
*               DO;                                                0298
*                 RFY                                              0299
*                   RWORK0 RSTD;    /* GET REQUEST CODE      @X04SVMR*/
*                 RWORK0=RPLREQ;    /* SET REQ CODE REG      @X04SVMR*/
         SLR   RWORK0,RWORK0                                       0300
         IC    RWORK0,RPLREQ(,RRPL)                                0300
*I12:                                                              0301
*                 DO;               /* IDACALL(IDA019RX)             */
I12      DS    0H                                                  0302
*                   CALL IDA019RX;  /* EXIT TO IDA019RX              */
         L     @15,@CV01241                                        0302
         BALR  @14,@15                                             0302
*                   GEN(BALR @11,0);/* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                   GEN(USING *,@11);/* ESTABLISH ADDRESSING         */
         USING *,@11
*                   GEN(L     @11,=A(@PSTART));/* RELOAD BASE        */
         L     @11,=A(@PSTART)
*                   GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING   */
         USING @PSTART,@11
*                 END I12;          /* CALL PATH RTN         @X04SVMR*/
*                 RFY                                              0308
*                   RWORK0 UNRSTD;  /* DROP REQUEST REG      @X04SVMR*/
*               END;                /* END OF PATH CODE      @X04SVMR*/
*             ELSE                  /* HERE IF NOT PATH      @X04SVMR*/
*/* CHECK FOR KEYED ACCESS                                           */
*                                                                  0310
*               IF RPLKEY=ON        /* KEY PROCESSING                */
*                 THEN              /* YES                           */
         B     @RC00297                                            0310
@RF00297 TM    RPLKEY(RRPL),B'10000000'                            0310
         BNO   @RF00310                                            0310
*                 DO;                                              0311
*                                                                  0311
*                   /*************************************************/
*                   /*                                               */
*                   /* COME HERE FOR KEYED ACCESSING REQUESTS.       */
*                   /*                                               */
*                   /*************************************************/
*                                                                  0312
*/*  MAKE SURE DATA SET IS KEYED AND ANY USER-SUPPLIED KEY LENGTH  0312
*        IS VALID                                                    */
*                                                                  0312
*                   IF AMDDST='0'B× /* CHRONOLOGIC DATA SET          */
*                       AMBLNUM=ONE /* OR PROCESSING AS DATA         */
*                     THEN          /* YES INVALID COMBO             */
         L     @10,AMBDSB(,RAMB)                                   0312
         TM    AMDDST(@10),B'10000000'                             0312
         BZ    @RT00312                                            0312
         CLC   AMBLNUM(2,RPARM1),@CH00053                          0312
         BNE   @RF00312                                            0312
@RT00312 DS    0H                                                  0313
*                     DO;                                          0313
*                                                                  0313
*                       /*********************************************/
*                       /*                                           */
*                       /* A KEYED REQUEST IS NOT AN ERROR IF IT IS  */
*                       /* TO A RELATIVE RECORD DATA SET.    @X04SVMR*/
*                       /*                                           */
*                       /*********************************************/
*                                                                  0314
*                       IF AMDRRDS=ON THEN/* SEE IF REL RCD DS     0314
*                                                            @X04SVMR*/
         L     @10,AMBDSB(,RAMB)                                   0314
         TM    AMDRRDS(@10),B'00000010'                            0314
         BNO   @RF00314                                            0314
*I13:                                                              0315
*                         DO;       /* IDACALL(IDA019RR)             */
I13      DS    0H                                                  0316
*                           CALL IDA019RR;/* EXIT TO IDA019RR        */
         L     @15,@CV01240                                        0316
         BALR  @14,@15                                             0316
*                           GEN(BALR @11,0);/* LOAD ADDR OF REENTRY  */
         BALR @11,0
*                           GEN(USING *,@11);/* ESTABLISH ADDRESSING */
         USING *,@11
*                           GEN(L     @11,=A(@PSTART));/* RELOAD BASE*/
         L     @11,=A(@PSTART)
*                           GEN(USING @PSTART,@11);/* ESTABLISH    0320
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                         END I13;  /* CALL RELATIVE RCD     @X04SVMR*/
*                       ELSE        /* HERE IF NOT RRDS      @X04SVMR*/
*                         DO;                                      0322
         B     @RC00314                                            0322
@RF00314 DS    0H                                                  0323
*                           RPLERRCD=RPLINKEY;/* SET INV KEY REQUEST */
         MVI   RPLERRCD(RRPL),X'48'                                0323
*                           RPLERREG='08'X;/* SET LOGICAL ERROR      */
         MVI   RPLERREG(RRPL),X'08'                                0324
*                         END;      /* END OF NON-RRDS       @X04SVMR*/
*                     END;          /* END, CSDS PROCESSING          */
*                   ELSE            /* HERE IF KSDS                  */
*                     DO;                                          0327
         B     @RC00312                                            0327
@RF00312 DS    0H                                                  0328
*                       IF RPLGEN=ON&/* SEE IF GENERIC SEARCH        */
*                           RPLREQ^=RPLPUT&/* PUT USES AMDKEYL     0328
*                                                            @ZA16103*/
*                           ((RPLSEQ=OFF×/* AND IF NOT SEQ REQ       */
*                           RPLREQ=RPLPOINT)&/* OR IF A POINT REQUEST*/
*                           (RPLKEYL<=ZERO×/* IF NO KEYLENGTH SPECD  */
*                           RPLKEYL>AMDKEYLN))/* OR IF IT EXCEEDS MAX*/
*                         THEN      /* SET ERROR CODE                */
         TM    RPLGEN(RRPL),B'00000010'                            0328
         BNO   @RF00328                                            0328
         CLI   RPLREQ(RRPL),1                                      0328
         BE    @RF00328                                            0328
         TM    RPLSEQ(RRPL),B'00100000'                            0328
         BZ    @GL00009                                            0328
         CLI   RPLREQ(RRPL),3                                      0328
         BNE   @RF00328                                            0328
@GL00009 LH    @10,RPLKEYL(,RRPL)                                  0328
         LTR   @10,@10                                             0328
         BNP   @RT00328                                            0328
         L     @05,AMBDSB(,RAMB)                                   0328
         CH    @10,AMDKEYLN(,@05)                                  0328
         BNH   @RF00328                                            0328
@RT00328 DS    0H                                                  0329
*                         DO;                                      0329
*                           RPLERREG='08'X;/* SET LOGICAL ERROR CODE */
         MVI   RPLERREG(RRPL),X'08'                                0330
*                           RPLERRCD=RPLKEYLC;/* SET BAD KEYLENGTH   */
         MVI   RPLERRCD(RRPL),X'70'                                0331
*                         END;      /* END INVALID KEY               */
*                       ELSE        /* HERE IF KEY LENGTH OK         */
*                         DO;       /* CALL KEYED DRIVER             */
         B     @RC00328                                            0333
@RF00328 DS    0H                                                  0334
*I14:                                                              0334
*                           DO;     /* IDACALL(IDA019R4)             */
I14      DS    0H                                                  0335
*                             CALL IDA019R4;/* EXIT TO IDA019R4      */
         L     @15,@CV01248                                        0335
         BALR  @14,@15                                             0335
*                             GEN(BALR @11,0);/* LOAD ADDR OF REENTRY*/
         BALR @11,0
*                             GEN(USING *,@11);/* ESTABLISH        0337
*                                      ADDRESSING                    */
         USING *,@11
*                             GEN(L     @11,=A(@PSTART));/* RELOAD 0338
*                                      BASE                          */
         L     @11,=A(@PSTART)
*                             GEN(USING @PSTART,@11);/* ESTABLISH  0339
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                           END I14;                               0340
*                         END;      /* KEYED REQUEST THRU            */
*                     END;          /* END, KSDS ROUTINE             */
*                 END;              /* END, KEYED PROCESSING         */
*                                                                  0344
*/*   HERE IF IT IS NOT KEYED ACCESSING.                             */
*                                                                  0344
*               ELSE                                               0344
*                 DO;                                              0344
         B     @RC00310                                            0344
@RF00310 DS    0H                                                  0345
*                   IF RPLSKP=ON THEN/* SKIP SEQUENTIAL VALID        */
         TM    RPLSKP(RRPL),B'00010000'                            0345
         BO    @RT00345                                            0345
*                     GO TO INVACC; /* ONLY WITH KEYED REQ           */
*                   IF RPLADD=ON    /* SEE IF ADDR REQ               */
*                     THEN          /* YES, COME HERE                */
         TM    RPLADD(RRPL),B'01000000'                            0347
         BNO   @RF00347                                            0347
*                     DO;           /* PROCESS ADDRESSED REQUESTS    */
*/*  PROHIBIT ADDRESSED PUTS FOR INSERT FOR KEYED DATA SETS AND      */
*/*   ERASES FOR NON-KEYED DATA SETS                                 */
*                                                                  0349
*                       IF AMDDST='1'B/* IF DATA SET IS KEYED,       */
*                         THEN      /* PUT INSERT NOT ALLOWED        */
         L     @10,AMBDSB(,RAMB)                                   0349
         TM    AMDDST(@10),B'10000000'                             0349
         BNO   @RF00349                                            0349
*                         DO;                                      0350
*                           IF RPLREQ=RPLPUT&/* IF THIS IS A PUT     */
*                               RPLUPD=OFF/* FOR INSERT--SET AN      */
*                             THEN  /* ERROR CODE.                   */
         CLI   RPLREQ(RRPL),1                                      0351
         BNE   @RF00351                                            0351
         TM    RPLUPD(RRPL),B'00000010'                            0351
         BNZ   @RF00351                                            0351
*                             DO;                                  0352
*                               RPLERRCD=RPLINADR;/* INVALID INSERT
*                                      TO KSDS                       */
         MVI   RPLERRCD(RRPL),X'4C'                                0353
*                               GO TO ERRORX;/* TAKE ERROR EXIT.     */
         B     ERRORX                                              0354
*                             END;  /* END OF PUT INSERT ERROR       */
*                         END;      /* END OF KSDS CODE              */
*                       ELSE        /* HERE IF NOT KSDS@X04SVMR      */
*                         DO;                                      0357
*                                                                  0357
         B     @RC00349                                            0357
@RF00349 DS    0H                                                  0358
*                           /*****************************************/
*                           /*                                       */
*                           /* IF THIS IS A RELATIVE RECORD DATA SET */
*                           /* A NON-KEYED REQUEST IS AN ERROR.      */
*                           /*                               @X04SVMR*/
*                           /*                                       */
*                           /*****************************************/
*                                                                  0358
*                           IF AMDRRDS=ON THEN/* IF AN RRDS, @X04SVMR*/
         L     @10,AMBDSB(,RAMB)                                   0358
         TM    AMDRRDS(@10),B'00000010'                            0358
         BNO   @RF00358                                            0358
*                             DO;                                  0359
*                               RPLERRCD=RPLRRADR;/* SET INVAL ADDR
*                                                            @X04SVMR*/
         MVI   RPLERRCD(RRPL),X'C4'                                0360
*                               GO TO ERRORX;/* TAKE ERROR EXIT.     */
         B     ERRORX                                              0361
*                             END;  /* END OF RRDS ERROR     @X04SVMR*/
*                         END;      /* END OF CSDS CODE              */
@RF00358 DS    0H                                                  0364
*                       IF RPLDIR=ON THEN/* SEE IF DIRECT REQ        */
@RC00349 TM    RPLDIR(RRPL),B'01000000'                            0364
         BNO   @RF00364                                            0364
*                         RPLDDDD=RBA;/* IF SO, PUT RBA IN RPL       */
         L     @10,RPLARG(,RRPL)                                   0365
         L     @10,RBA(,@10)                                       0365
         ST    @10,RPLDDDD(,RRPL)                                  0365
*I15:                                                              0366
*                       DO;         /* IDACALL(IDA019R4)             */
@RF00364 DS    0H                                                  0366
I15      DS    0H                                                  0367
*                         CALL IDA019R4;/* EXIT TO IDA019R4          */
         L     @15,@CV01248                                        0367
         BALR  @14,@15                                             0367
*                         GEN(BALR @11,0);/* LOAD ADDR OF REENTRY    */
         BALR @11,0
*                         GEN(USING *,@11);/* ESTABLISH ADDRESSING   */
         USING *,@11
*                         GEN(L     @11,=A(@PSTART));/* RELOAD BASE  */
         L     @11,=A(@PSTART)
*                         GEN(USING @PSTART,@11);/* ESTABLISH      0371
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                       END I15;    /* CALL ADDRESSED DRIVER         */
*                     END;          /* END, ADDRESS ACCESSING        */
*                   ELSE            /* HERE IF NOT ADDR              */
*                     DO;                                          0374
         B     @RC00347                                            0374
@RF00347 DS    0H                                                  0375
*                       IF RPLCNV=ON/* SEE IF CINV ACCESSING         */
*                         THEN      /* HERE IF SO                    */
         TM    RPLCNV(RRPL),B'00100000'                            0375
         BNO   @RF00375                                            0375
*I16:                                                              0376
*                         DO;       /* IDACALL(IDA019R8)             */
I16      DS    0H                                                  0377
*                           CALL IDA019R8;/* EXIT TO IDA019R8        */
         L     @15,@CV01251                                        0377
         BALR  @14,@15                                             0377
*                           GEN(BALR @11,0);/* LOAD ADDR OF REENTRY  */
         BALR @11,0
*                           GEN(USING *,@11);/* ESTABLISH ADDRESSING */
         USING *,@11
*                           GEN(L     @11,=A(@PSTART));/* RELOAD BASE*/
         L     @11,=A(@PSTART)
*                           GEN(USING @PSTART,@11);/* ESTABLISH    0381
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                         END I16;  /* CALL CINV DRIVER              */
*                                                                  0383
*/*  IF NOT A KEYED, ADDRESSED, OR CONTROL INTERVAL REQUEST, INDICATE*/
*/*   AN ERROR UNLESS IT IS A SPECIAL REQUEST                        */
*                                                                  0383
*                       ELSE        /* HERE IF NOT CNV               */
*                         IF RPLREQ=RPLPFMTD×/* IF THIS IS A DATA OR */
*                             RPLREQ=RPLPFMTI THEN/* AN INDEX      0383
*                                      PREFORMAT                     */
         B     @RC00375                                            0383
@RF00375 CLI   RPLREQ(RRPL),8                                      0383
         BE    @RT00383                                            0383
         CLI   RPLREQ(RRPL),9                                      0383
         BNE   @RF00383                                            0383
@RT00383 DS    0H                                                  0384
*                           CALL R1PREFMT;/* REQUEST, CALL PREFORMAT */
         BAL   @14,R1PREFMT                                        0384
*                         ELSE      /* OTHERWISE, SEE IF THIS        */
*                           IF RPLREQ=RPLFRCIO THEN/* IS A FORCE I/O
*                                      REQUEST.                      */
         B     @RC00383                                            0385
@RF00383 CLI   RPLREQ(RRPL),10                                     0385
         BNE   @RF00385                                            0385
*                             CALL R1FRCIO;/* IF SO, DO FORCE I/O.   */
         BAL   @14,R1FRCIO                                         0386
*                           ELSE    /* HERE FOR UNKNOWN REQ          */
*                             DO;                                  0387
         B     @RC00385                                            0387
@RF00385 DS    0H                                                  0388
*INVACC:                                                           0388
*                               RPLERRCD=RPLINVP;/* NOT KEY, ADR, CNV*/
INVACC   MVI   RPLERRCD(RRPL),X'68'                                0388
*ERRORX:                                                           0389
*                               RPLERREG='08'X;/* SET LOGICAL ERROR  */
ERRORX   MVI   RPLERREG(RRPL),X'08'                                0389
*                             END;  /* END, UNKNOWN ACCESS           */
*                     END;          /* END, NON-ADDR ACCESSING       */
@RC00385 DS    0H                                                  0391
@RC00383 DS    0H                                                  0391
@RC00375 DS    0H                                                  0392
*                 END;              /* END, NON-KEYED ACCESS         */
@RC00347 DS    0H                                                  0393
*             RFY                                                  0393
*               IDAAMBL BASED(ACBAMBL);/* RESET AMBL BASE            */
@RC00310 DS    0H                                                  0393
@RC00297 DS    0H                                                  0394
*/*  POST RPL COMPLETE                                               */
*                                                                  0394
*POSTRPL:                           /* POST RPL ECB                  */
*             IF RPLERREG='0C'X&    /* IF AN I/O ERROR,      @ZA06117*/
*                 AMBLSR=OFF&       /* NOT LOCAL SHR,        @ZA06117*/
*                 AMBGSR=OFF        /* AND NOT GLOBAL,       @ZA06117*/
*               THEN                /* ERROR MESSAGE         @ZA06117*/
POSTRPL  CLI   RPLERREG(RRPL),12                                   0394
         BNE   @RF00394                                            0394
         TM    AMBLSR(RAMB),B'01100000'                            0394
         BNZ   @RF00394                                            0394
*I17:                                                              0395
*               DO;                 /* IDACALL(IDA019R5)             */
I17      DS    0H                                                  0396
*                 CALL IDA019R5;    /* EXIT TO IDA019R5              */
         L     @15,@CV01250                                        0396
         BALR  @14,@15                                             0396
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I17;            /* IS NEEDED.            @ZA06117*/
*             CALL R1ARSTRT;        /* TRY RESTART.          @ZA06117*/
@RF00394 BAL   @14,R1ARSTRT                                        0402
*             RFY                                                  0403
*               RWORK4 RSTD;        /* GET WORK REG          @ZA14801*/
*             RWORK4=RPLCHAIN;      /* NEXT RPL IN CHAIN     @ZA14801*/
         L     RWORK4,RPLCHAIN(,RRPL)                              0404
*             RAMB=AMBLDTA;         /* POINT TO DATA AMB     @ZA14801*/
         L     @10,RPLDACB(,RRPL)                                  0405
         L     @10,ACBAMBL(,@10)                                   0405
         L     RAMB,AMBLDTA(,@10)                                  0405
*             RFY                                                  0406
*               RWORK1 RSTD;        /* GET WORK REG          @X04SVMR*/
*             RWORK1=R1;            /* SAVE REGISTER 1               */
         LR    RWORK1,R1                                           0407
*             IF RPLECBSW=ON THEN   /* SEE IF ECB IN RPL     @X04SVMR*/
         TM    RPLECBSW(RRPL),B'00000001'                          0408
         BNO   @RF00408                                            0408
*               R1=ADDR(USERECB);   /* NO, PTR TO USER       @X04SVMR*/
         L     R1,RPLECBPT(,RRPL)                                  0409
*             ELSE                  /* YES, PTR TO VSAM      @X04SVMR*/
*               R1=ADDR(RPLECB);                                   0410
         B     @RC00408                                            0410
@RF00408 LA    @10,RPLECB(,RRPL)                                   0410
         LR    R1,@10                                              0410
*             RFY                                                  0411
*              (RWORK2,                                            0411
*               RWORK3) RSTD;       /* GET WORK REGS         @X04SVMR*/
@RC00408 DS    0H                                                  0412
*             IF RWORK1->RPLASY=OFF THEN/* IF SYN, NO POST   @ZA06117*/
         TM    RPLASY(RWORK1),B'00001000'                          0412
         BNZ   @RF00412                                            0412
*               DO;                 /* IS NEEDED.            @ZA06117*/
*                 ECB=POSTED;       /* SET POST FLAG         @ZA06117*/
         MVC   ECB(4,R1),POSTED                                    0414
*                 RWORK2=PLHMRPL;   /* INDICATE SYNCH.       @ZA06117*/
         L     RWORK2,PLHMRPL(,RPLH)                               0415
*               END;                /* END SYN               @ZA06117*/
*             ELSE                  /* HERE FOR ASY          @ZA06117*/
*               DO;                 /*                       @ZA06117*/
         B     @RC00412                                            0417
@RF00412 DS    0H                                                  0418
*                 RWORK2=ZERO;      /* GET COMPARAND         @ZA06117*/
         SLR   RWORK2,RWORK2                                       0418
*                 RWORK3=POSTED;    /* VALUE TO SET          @X04SVMR*/
         L     RWORK3,POSTED                                       0419
*                 CS(RWORK2,RWORK3,ECB);/* POST IF ZERO      @X04SVMR*/
         CS    RWORK2,@07,ECB(R1)                                  0420
*                 BC(8,NOPOST);     /* IF OK, SKIP SVC       @X04SVMR*/
         BC    8,NOPOST                                            0421
*                 IF PSAAOLD^=PLHASCB THEN/* IF IN DIFFERENT @Y30SSMR*/
         CLC   PSAAOLD(4),PLHASCB(RPLH)                            0422
         BE    @RF00422                                            0422
*                   DO;             /* MEMORY, SWITCH.       @Y30SSMR*/
*                     PLHECB=R1;    /* SET ECB ADDRESS       @Y30SSMR*/
         ST    R1,PLHECB(,RPLH)                                    0424
*                     PLHERRET=ADDR(BADPOST);/* SET ERROR EXIT     0425
*                                                            @Y30SSMR*/
         LA    @10,BADPOST                                         0425
         ST    @10,PLHERRET(,RPLH)                                 0425
*                     R1=ADDR(PLHECB);/* GET ADDR OF PARML   @Y30SSMR*/
         LA    R1,PLHECB(,RPLH)                                    0426
*                     GEN(POST  MF=(E,(1)));/* XMEMORY POST  @Y30SSMR*/
         POST  MF=(E,(1))
*                   END;            /* END OF XMEMORY        @Y30SSMR*/
*                 ELSE              /* SAME MEMORY           @Y30SSMR*/
*                   GEN(POST  (1)); /* ISSUE POST SVC                */
         B     @RC00422                                            0429
@RF00422 DS    0H                                                  0429
         POST  (1)
*NOPOST:                            /* ECB POSTED            @X04SVMR*/
*                 RWORK2=ZERO;      /* SET ASY FLAG          @ZA06117*/
@RC00422 DS    0H                                                  0430
NOPOST   SLR   RWORK2,RWORK2                                       0430
*               END;                /* END OF ASY CODE       @ZA06117*/
*/*  THE CODE FROM HERE UNTIL EXIT MUST NOT USE THE RPL BECAUSE THE  */
*/*  ECB HAS BEEN POSTED AND AN ASY RPL MAY HAVE BEEN REUSED.@ZA14801*/
*                                                                  0432
*             R1=RWORK1;            /* RESTORE REG. 1                */
@RC00412 LR    R1,RWORK1                                           0432
*             RFY                                                  0433
*              (RWORK1,                                            0433
*               RWORK3) UNRSTD;     /* RELEASE REGS          @ZA06117*/
*             RRPL=RWORK4;          /* NEXT IN CHAIN         @ZA14801*/
         LR    RRPL,RWORK4                                         0434
*             RFY                                                  0435
*               RWORK4 UNRSTD;      /* RELEASE WORK REG      @ZA14801*/
*             IF RRPL^=ZERO THEN    /* CHAINED RPLS?         @X04SVMR*/
         LTR   RRPL,RRPL                                           0436
         BZ    @RF00436                                            0436
*               DO;                                                0437
*                                                                  0437
*/*  IF ANY ERRORS, STOP PROCESSING THE CHAIN IN ORDER TO ALLOW THE  */
*/*  USER NOT TO RETURN TO VSAM FROM THE ERROR EXIT ROUTINE.         */
*                                                                  0438
*                 IF PLHCRPL->RPLERREG^='00'X THEN/* ANY ERROR?      */
         L     @10,PLHCRPL(,RPLH)                                  0438
         CLI   RPLERREG(@10),0                                     0438
         BE    @RF00438                                            0438
*                   DO;             /* YES, STOP CHAIN.      @ZA14801*/
*                     RPLPLHPT=RPLH;/* POINT RPL TO PLH.     @ZA14801*/
         ST    RPLH,RPLPLHPT(,RRPL)                                0440
*                     GO TO POSTRPL;/* POST NEXT RPL.        @ZA14801*/
         B     POSTRPL                                             0441
*                   END;            /* END OF ERROR CODE     @ZA14801*/
*/*  MAKE SURE THAT LOC MODE IS NOT USED WITH CHAINED RPLS.  @X04SVMR*/
*                                                                  0443
*                 IF RPLLOC=ON      /* SEE IF LOCATE         @X04SVMR*/
*                   THEN            /* IF SO, SET ERROR.             */
@RF00438 TM    RPLLOC(RRPL),B'10000000'                            0443
         BNO   @RF00443                                            0443
*                   DO;                                            0444
*                     RPLERRCD=RPLINLOC;/* SET INVALID LOCATE REQ.   */
         MVI   RPLERRCD(RRPL),X'54'                                0445
*                     GO TO ERRORX; /* TAKE ERROR EXIT               */
         B     ERRORX                                              0446
*                   END;            /* END OF INVALID LOCATE         */
*                 IF(RPLREQ<RPLPFMTD×/* IF NOT I/O SUP-      @X04SVMR*/
*                     RPLREQ>=RPLGETIX) THEN/* PORT REQUEST  @X04SVMR*/
@RF00443 CLI   RPLREQ(RRPL),8                                      0448
         BL    @RT00448                                            0448
         CLI   RPLREQ(RRPL),11                                     0448
         BL    @RF00448                                            0448
@RT00448 DS    0H                                                  0449
*                   IF PLHENDRQ=ON THEN/* IF ENDREQ ISSUED,  @X04SVMR*/
         TM    PLHENDRQ(RPLH),B'01000000'                          0449
         BNO   @RF00449                                            0449
*                     RRPL=ZERO;    /* CAUSE LOOP EXIT       @X04SVMR*/
         SLR   RRPL,RRPL                                           0450
*               END;                /* END CHAINED RPLS      @X04SVMR*/
@RF00449 DS    0H                                                  0451
@RF00448 DS    0H                                                  0452
*           END;                    /* END, DO UNTIL         @X04SVMR*/
@RF00436 DS    0H                                                  0452
@DE00290 SLR   @10,@10                                             0452
         CR    RRPL,@10                                            0452
         BNE   @DL00290                                            0452
*                                                                  0453
*/*  IF THIS IS A SYNCHRONOUS REQUEST, CALL THE CHECK ROUTINE ON     */
*/*   BEHALF OF THE USER                                             */
*                                                                  0453
*           IF RWORK2^=ZERO THEN    /* IF SYNCH, CHECK       @ZA06117*/
         CLR   RWORK2,@10                                          0453
         BE    @RF00453                                            0453
*             DO;                   /*                       @ZA06117*/
*               RRPL=RWORK2;        /* POINT TO PLHMRPL      @ZA06117*/
         LR    RRPL,RWORK2                                         0455
*               CALL R1CHECK;       /* SYNCHRONIZE I/O       @ZA06117*/
         BAL   @14,R1CHECK                                         0456
*             END;                  /* END SYN               @ZA06117*/
*           RFY                                                    0458
*             RWORK2 UNRSTD;        /* DROP WORK REG         @ZA06117*/
*           GOTO CE0001@;           /* BRANCH TO END OF CASE         */
         B     CE0001@                                             0459
*         END;                      /* END OF SUBCASE                */
*                                                                  0461
*/*  DB/DC REQUEST HANDLING                                  @X04SVMR*/
*                                                                  0461
*WRTBFR:                                                           0461
*MRKBFR:                                                           0461
*SCHBFR:                                                           0461
*         DO;                       /* SUBCASE                       */
WRTBFR   DS    0H                                                  0461
MRKBFR   DS    0H                                                  0461
SCHBFR   DS    0H                                                  0462
*           RFY                                                    0462
*             RWORK0 RSTD;          /* GET REGISTER          @X04SVMR*/
*/*  SEE IF RPL IS AVAILABLE                                 @X04SVMR*/
*                                                                  0463
*           TS(RPLACTIV);           /* TEST AND SET          @X04SVMR*/
         TS    RPLACTIV(RRPL)                                      0463
*           BC(8,SETCODE2);         /* BRANCH IF OK          @X04SVMR*/
         BC    8,SETCODE2                                          0464
*           RPARM1=RRPL;            /* SET LAST RPL PTR      @X04SVMR*/
         LR    RPARM1,RRPL                                         0465
*           CALL R1TERM;            /* RELEASE RPL           @X04SVMR*/
         BAL   @14,R1TERM                                          0466
*           RETURN CODE('04'X);     /* MAKE ERROR RETURN     @X04SVMR*/
         LA    @15,4                                               0467
         L     @14,12(,@13)                                        0467
         LM    @00,@12,20(@13)                                     0467
         BR    @14                                                 0467
*SETCODE2:                                                         0468
*           RPLREQ=RWORK0;          /* SAVE REQ TYPE         @X04SVMR*/
SETCODE2 STC   RWORK0,RPLREQ(,RRPL)                                0468
*           IF RPLECBSW=ON THEN     /* SEE WHERE ECB IS      @X04SVMR*/
         TM    RPLECBSW(RRPL),B'00000001'                          0469
         BNO   @RF00469                                            0469
*             USERECB=ZERO;         /* CLEAR USER ECB        @X04SVMR*/
         L     @10,RPLECBPT(,RRPL)                                 0470
         SLR   @05,@05                                             0470
         STCM  @05,15,USERECB(@10)                                 0470
*           ELSE                    /* INTERNAL ECB          @X04SVMR*/
*             RPLECB=ZERO;          /* CLEAR VSAM ECB        @X04SVMR*/
         B     @RC00469                                            0471
@RF00469 SLR   @10,@10                                             0471
         ST    @10,RPLECB(,RRPL)                                   0471
*           RPLFDBWD=ZERO;          /* CLEAR ERROR FLGS      @X04SVMR*/
@RC00469 SLR   @10,@10                                             0472
         ST    @10,RPLFDBWD(,RRPL)                                 0472
*           RPARM1=RPARM1/256;      /* SHIFT RT 1 BYTE       @X04SVMR*/
         SRL   RPARM1,8                                            0473
*           IF RPLREQ^=RPLMRKB THEN /* TEST FOR MRKBFR       @X04SVMR*/
         CLI   RPLREQ(RRPL),14                                     0474
         BE    @RF00474                                            0474
*             DO;                                                  0475
*                                                                  0475
*               /*****************************************************/
*               /*                                                   */
*               /* HERE IF NOT A MRKBFR REQUEST              @X04SVMR*/
*               /*                                                   */
*               /*****************************************************/
*                                                                  0476
*               RPLH=RPLPLHPT;      /* POINT TO PLH          @OZ04909*/
         L     RPLH,RPLPLHPT(,RRPL)                                0476
*               IF RPLH=ZERO×PLHIOSID=OFF THEN/* IF NOT HERE,      0477
*                                                            @OZ04909*/
         CR    RPLH,@10                                            0477
         BE    @RT00477                                            0477
         TM    PLHIOSID(RPLH),B'00001000'                          0477
         BNZ   @RF00477                                            0477
@RT00477 DS    0H                                                  0478
*                 DO;               /* FIND A PLH            @X04SVMR*/
*                   CALL FINDPLH;   /* LOCATE A PLH          @X04SVMR*/
         BAL   @14,FINDPLH                                         0479
*                   RFY                                            0480
*                     R15 RSTD;     /* GET RETURN CODE       @X04SVMR*/
*                   IF R15^=ZERO THEN/* TEST FOR PLH         @X04SVMR*/
         LTR   R15,R15                                             0481
         BNZ   @RT00481                                            0481
*                     GO TO NOPLHFND;/* NONE--ERROR EXIT     @X04SVMR*/
*                   RFY                                            0483
*                     R15 UNRSTD;   /* DROP R15              @X04SVMR*/
*                 END;              /* END NON-CLOSE         @X04SVMR*/
*               PLHCRPL=RRPL;       /* PTR TO CURR RPL       @X04SVMR*/
@RF00477 ST    RRPL,PLHCRPL(,RPLH)                                 0485
*               RPLPLHPT=RPLH;      /* SET PTR TO PLH        @X04SVMR*/
         ST    RPLH,RPLPLHPT(,RRPL)                                0486
*               IF RPLSTRID>MAXID×  /* IF TRANSID TOO        @X04SVMR*/
*                   RPLSTRID<ZERO×  /* SMALL OR TOO          @X04SVMR*/
*                   (AMBLSR=OFF&AMBGSR=OFF)/* BIG OR NOT SHR @X04SVMR*/
*                 THEN              /* SET INVALID REQ       @X04SVMR*/
         LH    @10,RPLSTRID(,RRPL)                                 0487
         C     @10,@CF00036                                        0487
         BH    @RT00487                                            0487
         LTR   @10,@10                                             0487
         BM    @RT00487                                            0487
         TM    AMBLSR(RAMB),B'01100000'                            0487
         BZ    @RT00487                                            0487
*                 GO TO INVACC2;    /* TAKE ERROR EXIT       @X04SVMR*/
*               IF RPLREQ=RPLWRTB THEN/* IF WRTBFR, HERE     @X04SVMR*/
@RF00487 CLI   RPLREQ(RRPL),15                                     0489
         BNE   @RF00489                                            0489
*                 DO;                                              0490
*                   RBUFC=PLHDBUFC; /* CURRENT BUFC PTR      @X04SVMR*/
         L     RBUFC,PLHDBUFC(,RPLH)                               0491
*                   IF RBUFC^=ZERO THEN/* WRTBFR--IMPLICIT   @X04SVMR*/
         LTR   RBUFC,RBUFC                                         0492
         BZ    @RF00492                                            0492
*I20:                                                              0493
*                     DO;           /* IDACALL(IDAFREEB)             */
I20      DS    0H                                                  0494
*                       CALL IDAFREEB;/* EXIT TO IDAFREEB            */
         L     @15,@CV01244                                        0494
         BALR  @14,@15                                             0494
*                       GEN(BALR @11,0);/* LOAD ADDR OF REENTRY      */
         BALR @11,0
*                       GEN(USING *,@11);/* ESTABLISH ADDRESSING     */
         USING *,@11
*                       GEN(L     @11,=A(@PSTART));/* RELOAD BASE    */
         L     @11,=A(@PSTART)
*                       GEN(USING @PSTART,@11);/* ESTABLISH        0498
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                     END I20;      /* FREE BUFFER           @X04SVMR*/
*                                                                  0499
*                   /*************************************************/
*                   /*                                               */
*                   /* PROCESS WRTBFR REQUESTS               @X04SVMR*/
*                   /*                                               */
*                   /*************************************************/
*                                                                  0500
*                   RWORK0=RPARM1;  /* SAVE LRU N            @X04SVMR*/
@RF00492 LR    RWORK0,RPARM1                                       0500
*                   RPARM1=RPARM1&ANDCON;/* ZERO ALL BUT Q   @X04SVMR*/
         N     RPARM1,@CF01256                                     0501
*                   IF RPARM1=DS THEN/* SEE IF DS REQ        @X04SVMR*/
         LTR   RPARM1,RPARM1                                       0502
         BNZ   @RF00502                                            0502
*                     DO;                                          0503
*                                                                  0503
*                       /*********************************************/
*                       /*                                           */
*                       /* HERE FOR WRTBFR TYPE EQUALS DS    @X04SVMR*/
*                       /*                                           */
*                       /*********************************************/
*                                                                  0504
*I21:                                                              0504
*                       DO;         /* IDACALL(IDAWRTBF)             */
I21      DS    0H                                                  0505
*                         CALL IDAWRTBF;/* EXIT TO IDAWRTBF          */
         L     @15,@CV01243                                        0505
         BALR  @14,@15                                             0505
*                         GEN(BALR @11,0);/* LOAD ADDR OF REENTRY    */
         BALR @11,0
*                         GEN(USING *,@11);/* ESTABLISH ADDRESSING   */
         USING *,@11
*                         GEN(L     @11,=A(@PSTART));/* RELOAD BASE  */
         L     @11,=A(@PSTART)
*                         GEN(USING @PSTART,@11);/* ESTABLISH      0509
*                                      ADDRESSING                    */
         USING @PSTART,@11
*                       END I21;    /* CALL WRTBFR RTN       @X04SVMR*/
*                       IF RPLERREG^='00'X×/* IF ERROR OR    @X04SVMR*/
*                           AMDDST^='1'B×/* NOT A KSDS       @X04SVMR*/
*                           AMBLNUM=ONE THEN/* OR NOT PROCESSED    0511
*                                                            @X04SVMR*/
         CLI   RPLERREG(RRPL),0                                    0511
         BNE   @RT00511                                            0511
         L     @10,AMBDSB(,RAMB)                                   0511
         TM    AMDDST(@10),B'10000000'                             0511
         BNO   @RT00511                                            0511
         L     @10,RPLDACB(,RRPL)                                  0511
         L     @10,ACBAMBL(,@10)                                   0511
         CLC   AMBLNUM(2,@10),@CH00053                             0511
         BE    @RT00511                                            0511
*                         GO TO POSTRPL2;/* AS KSDS, EXIT    @X04SVMR*/
*                       RAMB=AMBLIX;/* POINT TO IX AMB       @X04SVMR*/
         L     RAMB,AMBLIX(,@10)                                   0513
*                     END;          /* END OF DS CODE        @X04SVMR*/
*                   ELSE            /* NOT TYPE = DS         @X04SVMR*/
*                     IF RPARM1=LRU THEN/* IF LRU, SHIFT RT  @X04SVMR*/
         B     @RC00502                                            0515
@RF00502 C     RPARM1,@CF00067                                     0515
         BNE   @RF00515                                            0515
*                       RWORK0=RWORK0/256;/* R0 = LRU N      @X04SVMR*/
         SRL   RWORK0,8                                            0516
*I22:                                                              0517
*                   DO;             /* IDACALL(IDAWRTBF)             */
@RF00515 DS    0H                                                  0517
@RC00502 DS    0H                                                  0517
I22      DS    0H                                                  0518
*                     CALL IDAWRTBF;/* EXIT TO IDAWRTBF              */
         L     @15,@CV01243                                        0518
         BALR  @14,@15                                             0518
*                     GEN(BALR @11,0);/* LOAD ADDR OF REENTRY        */
         BALR @11,0
*                     GEN(USING *,@11);/* ESTABLISH ADDRESSING       */
         USING *,@11
*                     GEN(L     @11,=A(@PSTART));/* RELOAD BASE      */
         L     @11,=A(@PSTART)
*                     GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING */
         USING @PSTART,@11
*                   END I22;        /* CALL WRTBFR RTN       @X04SVMR*/
*                 END;              /* END OF WRTBFR         @X04SVMR*/
*               ELSE                /* HERE FOR SCHBFR       @X04SVMR*/
*                 DO;                                              0525
         B     @RC00489                                            0525
@RF00489 DS    0H                                                  0526
*I23:                                                              0526
*                   DO;             /* IDACALL(IDASCHBF)             */
I23      DS    0H                                                  0527
*                     CALL IDASCHBF;/* EXIT TO IDASCHBF              */
         L     @15,@CV01242                                        0527
         BALR  @14,@15                                             0527
*                     GEN(BALR @11,0);/* LOAD ADDR OF REENTRY        */
         BALR @11,0
*                     GEN(USING *,@11);/* ESTABLISH ADDRESSING       */
         USING *,@11
*                     GEN(L     @11,=A(@PSTART));/* RELOAD BASE      */
         L     @11,=A(@PSTART)
*                     GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING */
         USING @PSTART,@11
*                   END I23;        /* CALL SCHBFR RTN       @X04SVMR*/
*                   IF RPLERREG='00'X THEN/* IF NO ERROR,    @X04SVMR*/
         CLI   RPLERREG(RRPL),0                                    0533
         BNE   @RF00533                                            0533
*                     DO;           /* SET PROPER FDBK.      @X04SVMR*/
*                       R0SAVE=RPARM1;/* SET USER BFRNO      @X04SVMR*/
         ST    RPARM1,R0SAVE(,R13)                                 0535
*                       PLHBMSV1=RPARM1;/* SET USER BFRNO    @X04SVMR*/
         ST    RPARM1,PLHBMSV1(,RPLH)                              0536
*                       RPLRLEN=AMDCINV;/* SET DATA LENGTH   @X04SVMR*/
         L     @10,AMBDSB(,RAMB)                                   0537
         L     @10,AMDCINV(,@10)                                   0537
         ST    @10,RPLRLEN(,RRPL)                                  0537
*                       PLHINVAL=OFF;/* RETAIN PLH           @X04SVMR*/
         NI    PLHINVAL(RPLH),B'11111101'                          0538
*                     END;          /* END, NON-ERROR        @X04SVMR*/
*                 END;              /* END, SCHBFR CODE      @X04SVMR*/
*             END;                  /* END, NON-MRKBFR       @X04SVMR*/
*           ELSE                    /* HERE FOR MRKBFR       @X04SVMR*/
*             DO;                                                  0542
         B     @RC00474                                            0542
@RF00474 DS    0H                                                  0543
*               CALL FINDOPLH;      /* SET PLH PTR           @X04SVMR*/
         BAL   @14,FINDOPLH                                        0543
*               RFY                                                0544
*                 R15 RSTD;         /* GET RETURN CODE       @X04SVMR*/
*               IF R15^=ZERO THEN   /* TEST FOR NO PLH       @X04SVMR*/
         LTR   R15,R15                                             0545
         BZ    @RF00545                                            0545
*                 DO;                                              0546
*                   RPLERRCD=RPLNOPLH;/* SET NO PLH CODE     @X04SVMR*/
         MVI   RPLERRCD(RRPL),X'40'                                0547
*                   RPLERREG='08'X; /* SET LOGICAL ERROR     @X04SVMR*/
         MVI   RPLERREG(RRPL),X'08'                                0548
*                   GO TO NOPLHFND; /* IF NONE, ERROR        @X04SVMR*/
         B     NOPLHFND                                            0549
*                 END;              /* END OF NO PLH         @X04SVMR*/
*               RFY                                                0551
*                 R15 UNRSTD;       /* RELEASE REG 15        @X04SVMR*/
@RF00545 DS    0H                                                  0552
*               PLHCRPL=RRPL;       /* PTR TO CURR RPL       @X04SVMR*/
         ST    RRPL,PLHCRPL(,RPLH)                                 0552
*               IF RPLSTRID>MAXID×  /* IF TRANSID TOO        @X04SVMR*/
*                   RPLSTRID<ZERO×  /* SMALL OR TOO          @X04SVMR*/
*                   (AMBLSR=OFF&AMBGSR=OFF)/* BIG OR NOT SHR @X04SVMR*/
*                 THEN              /* SET INVALID REQ       @X04SVMR*/
         LH    @10,RPLSTRID(,RRPL)                                 0553
         C     @10,@CF00036                                        0553
         BH    @RT00553                                            0553
         LTR   @10,@10                                             0553
         BM    @RT00553                                            0553
         TM    AMBLSR(RAMB),B'01100000'                            0553
         BNZ   @RF00553                                            0553
@RT00553 DS    0H                                                  0554
*                 DO;                                              0554
*INVACC2:                                                          0555
*                   RPLERRCD=RPLINVP;/* SET INVALID RPL      @X04SVMR*/
INVACC2  MVI   RPLERRCD(RRPL),X'68'                                0555
*                   RPLERREG='08'X; /* SET LOGICAL ERROR     @X04SVMR*/
         MVI   RPLERREG(RRPL),X'08'                                0556
*                   GO TO POSTRPL2; /* POST RPL              @X04SVMR*/
         B     POSTRPL2                                            0557
*                 END;              /* END OF ERROR          @X04SVMR*/
*               PLHRETO=PLHRETOS;   /* RESET OFFSET          @ZA16007*/
@RF00553 LH    @10,PLHRETOS(,RPLH)                                 0559
         STH   @10,PLHRETO(,RPLH)                                  0559
*               RBUFC=PLHDBUFC;     /* PTR TO CURR BUFC      @X04SVMR*/
         L     RBUFC,PLHDBUFC(,RPLH)                               0560
*               IF RBUFC=ZERO THEN  /* IF NO CURR BUFC       @X04SVMR*/
         LTR   RBUFC,RBUFC                                         0561
         BZ    @RT00561                                            0561
*                 GO TO INVACC2;    /* SET INVALID REQ       @X04SVMR*/
*I24:                                                              0563
*               DO;                 /* IDACALL(IDAMRKBF)             */
I24      DS    0H                                                  0564
*                 CALL IDAMRKBF;    /* EXIT TO IDAMRKBF              */
         L     @15,@CV01239                                        0564
         BALR  @14,@15                                             0564
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I24;            /* CALL MRKBFR RTN       @X04SVMR*/
*             END;                  /* END, MRKBFR CODE      @X04SVMR*/
*/*  POST RPL COMPLETE                                       @X04SVMR*/
*                                                                  0571
*POSTRPL2:                          /* POST RPL ECB          @X04SVMR*/
*           CALL R1ARSTRT;          /* TRY TO RESTART        @ZA19635*/
@RC00474 DS    0H                                                  0571
POSTRPL2 BAL   @14,R1ARSTRT                                        0571
*           RFY                                                    0572
*             RWORK1 RSTD;          /* GET WORK REG          @X04SVMR*/
*           RWORK1=R1;              /* SAVE REGISTER 1       @X04SVMR*/
         LR    RWORK1,R1                                           0573
*           IF RPLECBSW=ON          /* SEE IF ECB IN RPL     @X04SVMR*/
*             THEN                  /* NO, PTR TO USER       @X04SVMR*/
         TM    RPLECBSW(RRPL),B'00000001'                          0574
         BNO   @RF00574                                            0574
*             R1=ADDR(USERECB);                                    0575
         L     R1,RPLECBPT(,RRPL)                                  0575
*           ELSE                    /* YES, PTR TO VSAM      @X04SVMR*/
*             R1=ADDR(RPLECB);                                     0576
         B     @RC00574                                            0576
@RF00574 LA    @10,RPLECB(,RRPL)                                   0576
         LR    R1,@10                                              0576
*           RFY                                                    0577
*            (RWORK2,                                              0577
*             RWORK3) RSTD;         /* GET WORK REGS         @X04SVMR*/
@RC00574 DS    0H                                                  0578
*           IF RWORK1->RPLASY=OFF THEN/* TEST FOR SYN        @ZA06117*/
         TM    RPLASY(RWORK1),B'00001000'                          0578
         BNZ   @RF00578                                            0578
*             DO;                   /*                       @ZA06117*/
*               ECB=POSTED;         /* POST ECB              @ZA06117*/
         MVC   ECB(4,R1),POSTED                                    0580
*               R1=RWORK1;          /* RESET RPL REG         @ZA06117*/
         LR    R1,RWORK1                                           0581
*               CALL R1CHECK;       /* PERFORM CHECK         @ZA06117*/
         BAL   @14,R1CHECK                                         0582
*             END;                  /* END SYN CODE          @ZA06117*/
*           ELSE                    /* ASY                   @ZA06117*/
*             DO;                   /*                       @ZA06117*/
         B     @RC00578                                            0584
@RF00578 DS    0H                                                  0585
*               RWORK2=ZERO;        /* FIELD TO COMPARE      @X04SVMR*/
         SLR   RWORK2,RWORK2                                       0585
*               RWORK3=POSTED;      /* VALUE TO SET          @X04SVMR*/
         L     RWORK3,POSTED                                       0586
*               CS(RWORK2,RWORK3,ECB);/* POST IF ZERO        @X04SVMR*/
         CS    RWORK2,@07,ECB(R1)                                  0587
*               BC(8,NOPOST2);      /* IF OK, SKIP SVC       @X04SVMR*/
         BC    8,NOPOST2                                           0588
*               IF PSAAOLD^=PLHASCB THEN/* IF IN DIFFERENT   @Y30SSMR*/
         CLC   PSAAOLD(4),PLHASCB(RPLH)                            0589
         BE    @RF00589                                            0589
*                 DO;               /* MEMORY, SWITCH.       @Y30SSMR*/
*                   PLHECB=R1;      /* SET ECB ADDRESS       @Y30SSMR*/
         ST    R1,PLHECB(,RPLH)                                    0591
*                   PLHERRET=ADDR(BADPOST);/* SET ERROR EXIT @Y30SSMR*/
         LA    @10,BADPOST                                         0592
         ST    @10,PLHERRET(,RPLH)                                 0592
*                   R1=ADDR(PLHECB);/* GET ADDR OF PARML     @Y30SSMR*/
         LA    R1,PLHECB(,RPLH)                                    0593
*                   GEN(POST  MF=(E,(1)));/* XMEMORY POST    @Y30SSMR*/
         POST  MF=(E,(1))
*                 END;              /* END OF XMEMORY        @Y30SSMR*/
*               ELSE                /* SAME MEMORY           @Y30SSMR*/
*                 GEN(POST  (1));   /* ISSUE POST SVC        @X04SVMR*/
         B     @RC00589                                            0596
@RF00589 DS    0H                                                  0596
         POST  (1)
*NOPOST2:                           /* ECB POSTED            @X04SVMR*/
*             END;                  /* END OF ASY            @ZA06117*/
*           RFY                                                    0598
*            (RWORK1,                                              0598
*             RWORK2,                                              0598
*             RWORK3) UNRSTD;       /* RELEASE REGS          @X04SVMR*/
*           GOTO CE0001@;           /* BRANCH TO END OF CASE         */
         B     CE0001@                                             0599
*         END;                      /* END OF SUBCASE                */
*CE0001@:                                                          0601
*       END;                        /* END OF CASE                   */
CE0001@  DS    0H                                                  0602
*R1EXIT:                                                           0602
*       IF AMBTRACE^=ZERO THEN      /* IS IDATRACE ACTIVE@ZA29388    */
R1EXIT   L     @10,AMBTRACE(,RAMB)                                 0602
         LTR   @10,@10                                             0602
         BZ    @RF00602                                            0602
*         DO;                       /*                       @ZA29388*/
*           CALL IDA019ST;          /* CALL IDATRACE         @ZA29388*/
         L     @15,@CV01387                                        0604
         BALR  @14,@15                                             0604
*           GEN(DC X'0001');        /* TRACE ID              @ZA29388*/
         DC X'0001'
*         END;                      /*                       @ZA29388*/
*       RETURN;                     /* RETURN TO CALLER      #X04SVMR*/
         B     @EL00001                                            0607
*     END;                          /* END, ALL REQUESTS     #X04SVMR*/
*   GO TO R1EXIT;                   /* EXIT                  @XM01683*/
*                                                                  0610
*/* R1CHECK -- CHECK ROUTINE                                         */
*/*01  FUNCTION = WAIT FOR REQUEST COMPLETION AND TAKE ANY EXITS     */
*/*    (EODAD, LERAD, OR SYNAD) NECESSARY.                           */
*/*01  INPUT = STANDARD REGISTERS AND RPL FEEDBACK.                  */
*/*01  OUTPUT = ECB POSTED AND EXITS TAKEN.                          */
*                                                                  0610
*R1CHECK:                                                          0610
*   PROC OPTIONS(DONTSAVE,NOSAVEAREA);/* CHECK ROUTINE               */
R1CHECK  DS    0H                                                  0611
*/*  PROCESS ALL RPLS IN THE CHAIN                                   */
*                                                                  0611
*   DO UNTIL RRPL=ZERO;             /* WAIT FOR ALL RPLS     @X04SVMR*/
@DL00611 DS    0H                                                  0612
*     RFY                                                          0612
*       RWORK1 RSTD;                /* GET REGISTER                  */
*/*  WAIT FOR REQUEST COMPLETION                                     */
*                                                                  0613
*     RWORK1=R1;                    /* SAVE REGISTER ONE             */
         LR    RWORK1,R1                                           0613
*     IF RPLECBSW=OFF               /* SEE WHERE ECB IS              */
*       THEN                        /* POINT TO IT IN RPL            */
         TM    RPLECBSW(RRPL),B'00000001'                          0614
         BNZ   @RF00614                                            0614
*       R1=ADDR(RPLECB);                                           0615
         LA    @10,RPLECB(,RRPL)                                   0615
         LR    R1,@10                                              0615
*     ELSE                          /* OR IN USER AREA               */
*       R1=ADDR(USERECB);                                          0616
         B     @RC00614                                            0616
@RF00614 L     R1,RPLECBPT(,RRPL)                                  0616
*     IF ECBPOST=OFF THEN           /* SEE IF POSTED YET             */
@RC00614 TM    ECBPOST(R1),B'01000000'                             0617
         BNZ   @RF00617                                            0617
*       GEN(WAIT ECB=(1));          /* IF NOT, ISSUE WAIT            */
         WAIT ECB=(1)
*     R1=RWORK1;                    /* RESTORE REGISTER ONE          */
@RF00617 LR    R1,RWORK1                                           0619
*/*  IF I/O ERROR, TAKE EXCEPTION EXIT BEFORE PLH DISCONN.   @ZA14801*/
*                                                                  0620
*     IF RPLERREG='0C'X&AMBEXEX(ONE)^=ZERO THEN/*            @ZA14801*/
         CLI   RPLERREG(RRPL),12                                   0620
         BNE   @RF00620                                            0620
         CLI   AMBEXEX(RAMB),0                                     0620
         BE    @RF00620                                            0620
*       DO;                         /*                       @ZA14801*/
*         GEN SETS(PLHRETO,PLHRET1)(IDASVR14);/*             @ZA14801*/
         IDASVR14
*I27:                                                              0623
*         DO;                       /* IDACALL(IDAEXEX)              */
I27      DS    0H                                                  0624
*           CALL IDAEXEX;           /* EXIT TO IDAEXEX               */
         L     @15,@CV01252                                        0624
         BALR  @14,@15                                             0624
*           GEN(BALR @11,0);        /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*           GEN(USING *,@11);       /* ESTABLISH ADDRESSING          */
         USING *,@11
*           GEN(L     @11,=A(@PSTART));/* RELOAD BASE                */
         L     @11,=A(@PSTART)
*           GEN(USING @PSTART,@11); /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*         END I27;                  /* TAKE ERROR EXIT       @ZA14801*/
*         GEN(IDARST14);            /*                       @ZA14801*/
         IDARST14
*       END;                        /*                       @ZA14801*/
*     RRPL=RPLCHAIN;                /* GET NEXT RPL          @X04SVMR*/
@RF00620 L     RRPL,RPLCHAIN(,RRPL)                                0632
*   END;                            /* END OF WAIT LOOP      @X04SVMR*/
@DE00611 LTR   RRPL,RRPL                                           0633
         BNZ   @DL00611                                            0633
*   RRPL=PLHMRPL;                   /* RESTORE RPL PTR               */
         L     RRPL,PLHMRPL(,RPLH)                                 0634
*   IF RPLREQ=RPLSRCHB THEN         /* IF SEARCH BFR         @ZA14801*/
         CLI   RPLREQ(RRPL),13                                     0635
         BNE   @RF00635                                            0635
*     R0SAVE=PLHBMSV1;              /* PASS BACK BFRNO.      @ZA14801*/
         L     @10,PLHBMSV1(,RPLH)                                 0636
         ST    @10,R0SAVE(,R13)                                    0636
*/*  DISCONNECT THE PLACEHOLDER IF ITS POSITIONAL INFORMATION IS     */
*/*  INCORRECT                                               @ZA14801*/
*                                                                  0637
*   IF PLHINVAL=ON                  /* IF INVALID PLH                */
*     THEN                          /* THEN DISCONNECT IT            */
@RF00635 TM    PLHINVAL(RPLH),B'00000010'                          0637
         BNO   @RF00637                                            0637
*     DO;                                                          0638
*       IF AMBCREAT=OFF×            /* IF CREATE MODE        @ZA11564*/
*           RPLERRCD^=RPLINLRQ&     /* IF INVALID REQUEST    @ZA20491*/
*           PLH1ST=OFF THEN         /* NOT FIRST TIME        @ZA20491*/
         TM    AMBCREAT(RAMB),B'10000000'                          0639
         BZ    @RT00639                                            0639
         CLI   RPLERRCD(RRPL),116                                  0639
         BE    @RF00639                                            0639
         TM    PLH1ST(RPLH),B'01000000'                            0639
         BNZ   @RF00639                                            0639
@RT00639 DS    0H                                                  0640
*         DO;                       /*                       @ZA11564*/
*           PLHIWAIT=ON;            /* FORCE SYNCHRONOUS     @ZA14801*/
         OI    PLHIWAIT(RPLH),B'00000001'                          0641
*           PLHCRPL=RRPL;           /* ENSURE PROPER PTR     @X04SVMR*/
         ST    RRPL,PLHCRPL(,RPLH)                                 0642
*           GEN(IDASVR14);          /* SAVE RETURN REG       @X04SVMR*/
         IDASVR14
*           RBUFC=ZERO;             /* INDICATE ALL          @X04SVMR*/
         SLR   RBUFC,RBUFC                                         0644
*I28:                                                              0645
*           DO;                     /* IDACALL(IDASBF)               */
I28      DS    0H                                                  0646
*             CALL IDASBF;          /* EXIT TO IDASBF                */
         L     @15,@CV01235                                        0646
         BALR  @14,@15                                             0646
*             GEN(BALR @11,0);      /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*             GEN(USING *,@11);     /* ESTABLISH ADDRESSING          */
         USING *,@11
*             GEN(L     @11,=A(@PSTART));/* RELOAD BASE              */
         L     @11,=A(@PSTART)
*             GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING         */
         USING @PSTART,@11
*           END I28;                /* SUBTRACT BFRS         @X04SVMR*/
*           GEN REFS(HWORD4)(IDARST14);/* RESTORE RETURN     @X04SVLC*/
         IDARST14
*           PLHFLG1=CZERO;          /* RESET PLH FLAGS               */
         MVI   PLHFLG1(RPLH),B'00000000'                           0653
*           PLHFLG2=CZERO;          /*                               */
         MVI   PLHFLG2(RPLH),B'00000000'                           0654
*           PLHFLG3=CZERO;          /*                       @X04SVMR*/
         MVI   PLHFLG3(RPLH),B'00000000'                           0655
*           PLHEFLGS=C2ZERO;        /* CLEAR EXCEPTION FLAGS         */
         MVC   PLHEFLGS(2,RPLH),C2ZERO                             0656
*           PLHINVAL=ON;            /* RESET INVALID FLAG            */
         OI    PLHINVAL(RPLH),B'00000010'                          0657
*           PLHARDB=ZERO;           /* UNKNOWN ARDB          @X04SVMR*/
         SLR   @10,@10                                             0658
         ST    @10,PLHARDB(,RPLH)                                  0658
*         END;                      /*                       @ZA11564*/
*       ELSE                        /* IF ONE OF THE ABOVE   @ZA11564*/
*         PLHINVAL=OFF;             /* RESET PLH             @ZA11564*/
         B     @RC00639                                            0660
@RF00639 NI    PLHINVAL(RPLH),B'11111101'                          0660
*       PLHMRPL=ZERO;               /* DISCONNECT RPL        @X04SVMR*/
@RC00639 SLR   @10,@10                                             0661
         ST    @10,PLHMRPL(,RPLH)                                  0661
*       IF PLHIOSID=OFF THEN        /* IF NORMAL PLH,        @X04SVMR*/
         TM    PLHIOSID(RPLH),B'00001000'                          0662
         BNZ   @RF00662                                            0662
*         PLHDRCUR=PLHDRCUR-ONE;    /* DECRE CURR PLH        @X04SVMR*/
         L     @10,AMBPH(,RAMB)                                    0663
         LH    @15,PLHDRCUR(,@10)                                  0663
         BCTR  @15,0                                               0663
         STH   @15,PLHDRCUR(,@10)                                  0663
*       PLHAVL=CZERO;               /* MAKE PLH AVAILABLE            */
@RF00662 MVI   PLHAVL(RPLH),B'00000000'                            0664
*       GEN(BR    0);               /* SYNCHRONIZE MP        @Y30SSMR*/
         BR    0
*     END;                          /* END, PLH DISCONNECT   @ZA14801*/
*   RFY                                                            0667
*    (R14,                                                         0667
*     RWORK1,                                                      0667
*     RWORK2) RSTD;                 /* GET REGS              @ZA14801*/
@RF00637 DS    0H                                                  0668
*   DO UNTIL RRPL=ZERO;             /* ERR CHK FOR ALL RPLS  @X04SVMR*/
@DL00668 DS    0H                                                  0669
*     IF RPLERREG^='00'X            /* IF AN EXCEPTIONAL             */
*       THEN                        /* CONDITION EXISTS,             */
         CLI   RPLERREG(RRPL),0                                    0669
         BE    @RF00669                                            0669
*       DO;                         /* TAKE EXIT IF HERE     @ZA14801*/
*         RWORK2=R14;               /* SAVE REG 14           @ZA14801*/
         LR    RWORK2,R14                                          0671
*I29:                                                              0672
*         DO;                       /* IDACALL(IDALOCEX)             */
I29      DS    0H                                                  0673
*           CALL IDALOCEX;          /* EXIT TO IDALOCEX              */
         L     @15,@CV01246                                        0673
         BALR  @14,@15                                             0673
*           GEN(BALR @11,0);        /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*           GEN(USING *,@11);       /* ESTABLISH ADDRESSING          */
         USING *,@11
*           GEN(L     @11,=A(@PSTART));/* RELOAD BASE                */
         L     @11,=A(@PSTART)
*           GEN(USING @PSTART,@11); /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*         END I29;                  /* LOCATE USER EXIT      @ZA14801*/
*         R14=RWORK2;               /* RESTORE REG 14        @ZA14801*/
         LR    R14,RWORK2                                          0679
*         IF RPARM1^=ZERO THEN      /* WAS EXIT FOUND?       @ZA14801*/
         LTR   RPARM1,RPARM1                                       0680
         BZ    @RF00680                                            0680
*           DO;                     /* IF SO, FREE RPL.      @ZA14801*/
*                                                                  0681
*             /*******************************************************/
*             /*                                                     */
*             /* MAKE CURR AND REST OF RPLS IN THE CHAIN INACTIVE.   */
*             /*                                             @ZA14801*/
*             /*                                                     */
*             /*******************************************************/
*                                                                  0682
*             RWORK1=RRPL;          /* POINT TO CURRENT      @ZA14801*/
         LR    RWORK1,RRPL                                         0682
*             DO UNTIL RWORK1=ZERO; /* FOLLOW CHAIN          @ZA14801*/
@DL00683 DS    0H                                                  0684
*               RWORK1->RPLACTIV=CZERO;/* RELEASE RPL        @ZA14801*/
         MVI   RPLACTIV(RWORK1),B'00000000'                        0684
*               RWORK1=RWORK1->RPLCHAIN;/* NEXT RPL IN CHAIN @ZA14801*/
         L     RWORK1,RPLCHAIN(,RWORK1)                            0685
*             END;                  /* END RPL CHAIN         @ZA14801*/
@DE00683 LTR   RWORK1,RWORK1                                       0686
         BNZ   @DL00683                                            0686
*             GO TO IDAEXITR;       /* TAKE EXIT FOUND       @ZA14801*/
         L     @15,@CV01247                                        0687
         BR    @15                                                 0687
*           END;                    /* END, EXIT FOUND       @ZA14801*/
*         R15SAVE=RPLERREG;         /* REG 15 = RETURN CODE  @ZA14801*/
@RF00680 SLR   @15,@15                                             0689
         IC    @15,RPLERREG(,RRPL)                                 0689
         ST    @15,R15SAVE(,R13)                                   0689
*       END;                        /* END OF ERROR CODE     @ZA14801*/
*     RWORK1=RRPL;                  /* SAVE PREV RPL PTR     @ZA14801*/
@RF00669 LR    RWORK1,RRPL                                         0691
*     RRPL=RPLCHAIN;                /* GET NEXT RPL                  */
         L     RRPL,RPLCHAIN(,RRPL)                                0692
*     RWORK1->RPLACTIV=CZERO;       /* RELEASE PREVIOUS RPL  @ZA14801*/
         MVI   RPLACTIV(RWORK1),B'00000000'                        0693
*   END;                            /* END OF ERR CHK LOOP   @X04SVMR*/
@DE00668 LTR   RRPL,RRPL                                           0694
         BNZ   @DL00668                                            0694
*   RFY                                                            0695
*    (RWORK1,                                                      0695
*     RWORK2,                                                      0695
*     R14) UNRSTD;                  /* RELEASE REGS          @ZA14801*/
*   END R1CHECK;                    /* END OF CHECK ROUTINE          */
@EL00002 DS    0H                                                  0696
@EF00002 DS    0H                                                  0696
@ER00002 BR    @14                                                 0696
*                                                                  0697
*/* FINDPLH -- FIND A PLACEHOLDER FOR AN RPL                         */
*/*01  FUNCTION = FIND THE PLACEHOLDER THAT BELONGS TO AN RPL OR     */
*/*    FIND AN AVAILABLE PLACEHOLDER FOR AN RPL.                     */
*/*01  INPUT = STANDARD REGISTERS, RPLH = ?                          */
*/*01  OUTPUT = SAME REGISTERS, RPLH = A(PLH), RETURN CODE SET TO    */
*/*    INDICATE THE RESULT OF THE PLACEHOLDER SEARCH.                */
*                                                                  0697
*FINDPLH:                                                          0697
*   PROC OPTIONS(DONTSAVE,NOSAVEAREA);/* FIND PLACEHOLDER            */
FINDPLH  DS    0H                                                  0698
*   RESPECIFY                                                      0698
*     R14 RESTRICTED;               /* SAVE RETURN REGISTER          */
*/*  IF THE RPL HAS A VALID PLH PTR USE IT TO SEE IF THE PLACE-      */
*/*   HOLDER INDICATED BELONGS TO THE RPL                    @X04SVMR*/
*                                                                  0699
*   RPLH=RPLPLHPT;                  /* GET PLH PTR           @X04SVMR*/
         L     RPLH,RPLPLHPT(,RRPL)                                0699
*   IF RPLH^=ZERO                   /* PLH HERE BEFORE?      @X04SVMR*/
*     THEN                          /* IF SO, COME HERE              */
         SLR   @15,@15                                             0700
         CR    RPLH,@15                                            0700
         BE    @RF00700                                            0700
*     DO;                                                          0701
*       IF RPLREQ>=RPLPFMTD&        /* IF I/O SUPPORT        @X04SVMR*/
*           RPLREQ<RPLGETIX         /* REQUEST,              @X04SVMR*/
*         THEN                      /* BYPASS CHECKING FOR           */
         CLI   RPLREQ(RRPL),8                                      0702
         BL    @RF00702                                            0702
         CLI   RPLREQ(RRPL),11                                     0702
         BNL   @RF00702                                            0702
*         DO;                       /* ACTIVITY ON THE PLH.          */
*           PLHSLVLD=OFF;           /* NO 2ND LEVEL IX       @X04SVMR*/
         NI    PLHSLVLD(RPLH),B'11011111'                          0704
*           IF PLHCRPL^=ZERO THEN   /* PRIOR RPL?            @X04SVMR*/
         L     @10,PLHCRPL(,RPLH)                                  0705
         CR    @10,@15                                             0705
         BE    @RF00705                                            0705
*             PLHSLRBA=PLHCRPL;     /* YES, SAVE IT          @X04SVMR*/
         ST    @10,PLHSLRBA(,RPLH)                                 0706
*           ELSE                    /* NO PRIOR RPL          @X04SVMR*/
*             PLHSLRBA=RRPL;        /* SAVE CURRENT          @X04SVMR*/
         B     @RC00705                                            0707
@RF00705 ST    RRPL,PLHSLRBA(,RPLH)                                0707
*           PLHMRPL=RRPL;           /* SET MASTER RPL                */
@RC00705 ST    RRPL,PLHMRPL(,RPLH)                                 0708
*           PLHCRPL=RRPL;           /* SET MASTER RPL                */
         ST    RRPL,PLHCRPL(,RPLH)                                 0709
*           PLHASCB=PSAAOLD;        /* SAVE ASCB PTR         @Y30SSMR*/
         L     @15,PSAAOLD                                         0710
         ST    @15,PLHASCB(,RPLH)                                  0710
*           RETURN CODE(ZERO);      /* EXIT, PLH FOUND       @X04SVMR*/
         SLR   @15,@15                                             0711
@EL00003 DS    0H                                                  0711
@EF00003 DS    0H                                                  0711
@ER00003 BR    @14                                                 0711
*         END;                      /* END FINDPLH--SPCL REQ         */
*       RPLH=AMBPH+LENGTH(IDAPLHDR);/* POINT TO 1ST PLH      @X04SVMR*/
@RF00702 LA    RPLH,16                                             0713
         AL    RPLH,AMBPH(,RAMB)                                   0713
*       DO UNTIL RPLH=ZERO;         /* LOCATE PROPER PLH     @X04SVMR*/
@DL00714 DS    0H                                                  0715
*         IF PLHMRPL=RRPL&PLHAVL^=ZERO THEN/* IF FOUND,      @X04SVMR*/
         C     RRPL,PLHMRPL(,RPLH)                                 0715
         BNE   @RF00715                                            0715
         CLI   PLHAVL(RPLH),0                                      0715
         BNE   @RT00715                                            0715
*           GO TO OLDPLH;           /* REUSE SAME PLH.       @X04SVMR*/
*         RPLH=PLHCHAIN;            /* NEXT PLH IN POOL      @X04SVMR*/
@RF00715 L     RPLH,PLHCHAIN(,RPLH)                                0717
*       END;                        /* END OF SEARCH         @X04SVMR*/
@DE00714 LTR   RPLH,RPLH                                           0718
         BNZ   @DL00714                                            0718
*     END;                          /* END, RPLSTRID CHECK           */
*FINDNPLH:                                                         0720
*                                                                  0720
*/*  SEARCH THE POOL OF PLACEHOLDERS FOR ONE THAT IS AVAILABLE       */
*                                                                  0720
*   RPLH=AMBPH+LENGTH(IDAPLHDR);    /* POINT TO FIRST PLH            */
@RF00700 DS    0H                                                  0720
FINDNPLH LA    RPLH,16                                             0720
         AL    RPLH,AMBPH(,RAMB)                                   0720
*   DO UNTIL RPLH=ZERO;             /* AVAIL PLH SEARCH      @X04SVMR*/
@DL00721 DS    0H                                                  0722
*     TS(PLHAVL);                   /* SEE IF PLH AVAIL      @X04SVMR*/
         TS    PLHAVL(RPLH)                                        0722
*     BC(8,AVLPLH);                 /* YES, BRANCH           @X04SVMR*/
         BC    8,AVLPLH                                            0723
*     RPLH=PLHCHAIN;                /* TRY NEXT PLH          @X04SVMR*/
         L     RPLH,PLHCHAIN(,RPLH)                                0724
*   END;                            /* END, PLH SEARCH               */
@DE00721 LTR   RPLH,RPLH                                           0725
         BNZ   @DL00721                                            0725
*   IF AMBCREAT=OFF&                /* IF NOT CREATE AND     @X04SVMR*/
*       AMBLSR=OFF&                 /* IF NOT LSR AND        @X04SVMR*/
*       AMBGSR=OFF THEN             /* NOT GSR, ADD PLH.     @X04SVMR*/
         TM    AMBCREAT(RAMB),B'10000000'                          0726
         BNZ   @RF00726                                            0726
         TM    AMBLSR(RAMB),B'01100000'                            0726
         BNZ   @RF00726                                            0726
*     DO;                           /*                       @X04SVMR*/
*       RBUFC=R14;                  /* SAVE RETURN REG       @ZA16062*/
*                                                                  0728
         LR    RBUFC,R14                                           0728
*       /*************************************************************/
*       /*                                                           */
*       /* DYNAMIC STRING ADDITION                           @X04SVMR*/
*       /*                                                           */
*       /*************************************************************/
*                                                                  0729
*I30:                                                              0729
*       DO;                         /* IDACALL(IDAXGPLH)             */
I30      DS    0H                                                  0730
*         CALL IDAXGPLH;            /* EXIT TO IDAXGPLH              */
         L     @15,@CV01249                                        0730
         BALR  @14,@15                                             0730
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I30;                    /* ADD MORE STRINGS      @X04SVMR*/
*       R14=RBUFC;                  /* RESTORE R14           @ZA16062*/
         LR    R14,RBUFC                                           0736
*       RPLFDBWD=ZERO;              /* CLEAR FEEDBACK        @X04SVMR*/
         SLR   @15,@15                                             0737
         ST    @15,RPLFDBWD(,RRPL)                                 0737
*       IF RPLH^=ZERO THEN          /* IF PLH FOUND,         @X04SVMR*/
         CR    RPLH,@15                                            0738
         BE    @RF00738                                            0738
*         RETURN CODE(ZERO);        /* GOOD RETURN           @X04SVMR*/
         BR    @14                                                 0739
*     END;                          /* END OF D.S.A.         @X04SVMR*/
@RF00738 DS    0H                                                  0741
*/*  IF NO PLACEHOLDERS ARE FREE, AN ERROR MUST BE INDICATED         */
*                                                                  0741
*NOPLH:                                                            0741
*   RPLERRCD=RPLNOPLH;              /* SET NO PLH FOUND              */
@RF00726 DS    0H                                                  0741
NOPLH    MVI   RPLERRCD(RRPL),X'40'                                0741
*   RPLERREG='08'X;                 /* INDICATE PLH ERROR            */
         LA    @15,8                                               0742
         STC   @15,RPLERREG(,RRPL)                                 0742
*   RETURN CODE(RPLERREG);          /* RETURN TO CALLER              */
         BR    @14                                                 0743
*/*  IF AN AVAILABLE PLACEHOLDER WAS FOUND, POINT IT TO THE FIRST    */
*/*  RPL IN THE CHAIN                                                */
*                                                                  0744
*AVLPLH:                                                           0744
*   PLHMRPL=RRPL;                   /* SET UP RPL ADDRESS            */
AVLPLH   ST    RRPL,PLHMRPL(,RPLH)                                 0744
*   PLHDRCUR=PLHDRCUR+ONE;          /* ADD ONE TO CURR       @X04SVMR*/
         L     @15,AMBPH(,RAMB)                                    0745
         LA    @10,1                                               0745
         AH    @10,PLHDRCUR(,@15)                                  0745
         STH   @10,PLHDRCUR(,@15)                                  0745
*   IF PLHDRCUR>PLHDRMAX THEN       /* IF NEW HIGH,          @X04SVMR*/
         CH    @10,PLHDRMAX(,@15)                                  0746
         BNH   @RF00746                                            0746
*     PLHDRMAX=PLHDRCUR;            /* SET NEW MAX ACTIV     @X04SVMR*/
         STH   @10,PLHDRMAX(,@15)                                  0747
*OLDPLH:                                                           0748
*   RBUFC=ADDR(IFGACB);             /* LOAD PTR TO ACB       @ZA30396*/
@RF00746 DS    0H                                                  0748
OLDPLH   L     RBUFC,RPLDACB(,RRPL)                                0748
*   GEN(LA RBUFC,0(RBUFC));         /* DROP HI ORD BYTE      @ZA30396*/
         LA RBUFC,0(RBUFC)
*   PLHACB=RBUFC;                   /* SET PLH PTR           @ZA30396*/
         ST    RBUFC,PLHACB(,RPLH)                                 0750
*   PLHASCB=PSAAOLD;                /* SAVE ASCB PTR         @Y30SSMR*/
         L     @15,PSAAOLD                                         0751
         ST    @15,PLHASCB(,RPLH)                                  0751
*   PLHRETO=PLHRETOS;               /* RESET OFFSET          @ZA16007*/
         LH    @15,PLHRETOS(,RPLH)                                 0752
         STH   @15,PLHRETO(,RPLH)                                  0752
*   PLHRSCS=CZERO;                  /* CLEAR RESOURCE OWNERSHIP BITS
*                                      FOR TERMRPL           @ZA32757*/
         MVI   PLHRSCS(RPLH),B'00000000'                           0753
*   PLHTMRPL=CZERO;                 /* CLEAR TERMRPL PROCESS BITS  0754
*                                                            @ZA32757*/
         MVI   PLHTMRPL(RPLH),B'00000000'                          0754
*   RETURN CODE(ZERO);              /* EXIT WITH NO ERROR            */
         SLR   @15,@15                                             0755
         BR    @14                                                 0755
*   RESPECIFY                                                      0756
*     R14 UNRESTRICTED;             /* DROP REGISTER                 */
*   RESPECIFY                                                      0757
*     RWORK0 UNRESTRICTED;          /* DROP REGISTER                 */
*   END FINDPLH;                    /* END OF LOCATE PLH             */
*                                                                  0759
*/*                       FINDOPLH                                   */
*/*FUNCTION = FIND OLD PLH FOR CHECK, ENDREQ, MRKBFR, OR TERMRPL.    */
*/*INPUT = STANDARD REGISTERS, RPLH = ?                              */
*/*OUTPUT = STANDARD REGISTERS, RPLH SET, RETURN CODE IN R15.        */
*                                                                  0759
*FINDOPLH:                                                         0759
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);/* FINDOPLH              @X04SVMR*/
FINDOPLH DS    0H                                                  0760
*   RFY                                                            0760
*    (R14,                                                         0760
*     RWORK0) RSTD;                 /* GET REGS              @X04SVMR*/
*   RFY                                                            0761
*     RWORK1 RSTD;                  /*                       @ZA28981*/
*   RPLH=RPLPLHPT;                  /* POINT TO PLH FR RPL   @ZA28981*/
         L     RPLH,RPLPLHPT(,RRPL)                                0762
*   RWORK1=AMBPH+LENGTH(IDAPLHDR);  /* POINT TO 1ST PLH      @ZA28981*/
         LA    RWORK1,16                                           0763
         AL    RWORK1,AMBPH(,RAMB)                                 0763
*   DO UNTIL RWORK1=0;              /* LOOP THRU PLHS        @ZA28981*/
@DL00764 DS    0H                                                  0765
*     IF RWORK1=RPLH THEN           /* PLH FR RPL MATCH      @ZA28981*/
         CR    RWORK1,RPLH                                         0765
         BNE   @RF00765                                            0765
*       RWORK1=0;                   /* YES-FORCE EXIT        @ZA28981*/
         SLR   RWORK1,RWORK1                                       0766
*     ELSE                          /* NO-                   @ZA28981*/
*       DO;                         /*                       @ZA28981*/
         B     @RC00765                                            0767
@RF00765 DS    0H                                                  0768
*         RWORK1=RWORK1->PLHCHAIN;  /* NEXT PLH              @ZA30746*/
         L     RWORK1,PLHCHAIN(,RWORK1)                            0768
*         IF RWORK1=0 THEN          /* IF NONE               @ZA28981*/
         SLR   @15,@15                                             0769
         CR    RWORK1,@15                                          0769
         BNE   @RF00769                                            0769
*           RPLPLHPT=0;             /* PLH FR RPL INVALID    @ZA28981*/
         ST    @15,RPLPLHPT(,RRPL)                                 0770
*       END;                        /*                       @ZA28981*/
@RF00769 DS    0H                                                  0772
*   END;                            /*                       @ZA28981*/
@RC00765 DS    0H                                                  0772
@DE00764 SLR   @15,@15                                             0772
         CR    RWORK1,@15                                          0772
         BNE   @DL00764                                            0772
*   RPLH=RPLPLHPT;                  /* POINT TO PLH          @X04SVMR*/
         L     RPLH,RPLPLHPT(,RRPL)                                0773
*   IF RPLH=ZERO×                   /* IF NO PLH PTR,        @X04SVMR*/
*       PLHMRPL^=RRPL×              /* OR WRONG RPL,         @X04SVMR*/
*       PLHAVL=ZERO THEN            /* OR PLH NOT BUSY       @X04SVMR*/
         CR    RPLH,@15                                            0774
         BE    @RT00774                                            0774
         C     RRPL,PLHMRPL(,RPLH)                                 0774
         BNE   @RT00774                                            0774
         CLI   PLHAVL(RPLH),0                                      0774
         BNE   @RF00774                                            0774
@RT00774 DS    0H                                                  0775
*     RETURN CODE('08'X);           /* ERROR RETURN          @X04SVMR*/
         LA    @15,8                                               0775
@EL00004 DS    0H                                                  0775
@EF00004 DS    0H                                                  0775
@ER00004 BR    @14                                                 0775
*   ELSE                            /* R15 = 0 IF OK         @X04SVMR*/
*     RETURN CODE(ZERO);            /* NORMAL RETURN         @X04SVMR*/
@RF00774 SLR   @15,@15                                             0776
         BR    @14                                                 0776
*   END FINDOPLH;                   /* END OF FINDOPLH       @X04SVMR*/
*                                                                  0778
*/* R1ARSTRT -- ASYNCHRONOUS RESTART OF DEFERRED REQUESTS            */
*/* FUNCTION = CHECK FOR AND RESTART DEFERRED REQUESTS.              */
*/* INPUT = STANDARD VSAM REGISTERS.                         @ZA14801*/
*/* OUTPUT = STANDARD VSAM REGISTERS.                        @ZA06117*/
*                                                                  0778
*R1ARSTRT:                                                         0778
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);/* RESTART ROUTINE       @X04SVMR*/
R1ARSTRT DS    0H                                                  0779
*   RFY                                                            0779
*     R14 RSTD;                     /* SAVE RETURN ADDR      @X04SVMR*/
*/*  IF THE REQUEST HAD CONTROL OF A NON-SHAREABLE RESOURCE, OTHER   */
*/*  PLACEHOLDERS MUST BE EXAMINED TO SEE IF ONE OF THEM HAD ITS     */
*/*  PROCESSING DEFERRED. IF SO, AN ATTEMPT MUST BE MADE TO RESTART  */
*/*  THE DEFERRED REQUEST.                                           */
*                                                                  0780
*   IF(AMBPH^=0&                    /* IF AMBPH PTR PRESENT  @X04SVLC*/
*       PLHDRREQ^=ZERO)×            /* SEE IF DEFERRED       @X04SVLC*/
*       (AMBUPLH^=0&                /* IF AMBUPLH PTR PRES   @X04SVLC*/
*       AMBUPLH->PLHDRREQ^=ZERO) THEN/* SEE IF DEFERRED      @X04SVLC*/
         SLR   @15,@15                                             0780
         L     @10,AMBPH(,RAMB)                                    0780
         CR    @10,@15                                             0780
         BE    @GL00031                                            0780
         C     @15,PLHDRREQ(,@10)                                  0780
         BNE   @RT00780                                            0780
@GL00031 SLR   @15,@15                                             0780
         L     @10,AMBUPLH(,RAMB)                                  0780
         CR    @10,@15                                             0780
         BE    @RF00780                                            0780
         C     @15,PLHDRREQ(,@10)                                  0780
         BE    @RF00780                                            0780
@RT00780 DS    0H                                                  0781
*     DO;                           /*                       @X04SVMR*/
*       GEN(IDASVR14);              /* SAVE REG 14           @ZA14801*/
         IDASVR14
*I31:                                                              0783
*       DO;                         /* IDACALL(IDARSTRT)             */
I31      DS    0H                                                  0784
*         CALL IDARSTRT;            /* EXIT TO IDARSTRT              */
         L     @15,@CV01245                                        0784
         BALR  @14,@15                                             0784
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I31;                    /* ATTEMPT RESTART       @ZA14801*/
*       GEN(IDARST14);              /* RESTORE REG 14        @ZA14801*/
         IDARST14
*     END;                          /* END OF RESTART TRY    @X04SVMR*/
*   END R1ARSTRT;                   /* END OF RESTART        @X04SVMR*/
@EL00005 DS    0H                                                  0792
@EF00005 DS    0H                                                  0792
@ER00005 BR    @14                                                 0792
*                                                                  0793
*/* R1PREFMT -- PREFORMAT DATA OR INDEX                              */
*/*01 FUNCTION = PREFORMAT A CONTROL AREA OF DATA OR PREFORMAT A     */
*/*              TRACK OF INDEX.                                     */
*/*01 INPUT = RRPL POINTS TO THE RPL, RPLDDDD HAS THE STARTING RBA,  */
*/*           RPLSTRID HAS PLH POINTER, RAMB IS THE DATA AMB.        */
*/*01 OUTPUT = RRPL IS UNCHANGED, RPLH IS SET, RAMB ADDRESSES        */
*/*            EITHER THE INDEX OR THE DATA AMB.                     */
*                                                                  0793
*R1PREFMT:                                                         0793
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);/* PREFORMAT ROUTINE             */
R1PREFMT DS    0H                                                  0794
*   RFY                                                            0794
*     R14 RSTD;                     /* GUARD RETURN REGISTER         */
*   GEN(IDASVR14);                  /* SAVE REGISTER 14              */
         IDASVR14
*   RFY                                                            0796
*     R14 UNRSTD;                   /* RELEASE R14 FOR USE           */
*   IF RPLREQ=RPLPFMTI&AMBLNUM>ONE  /* IF THIS IS AN INDEX   @XM01683*/
*     THEN                          /* REQUEST, CHANGE AMB.          */
         CLI   RPLREQ(RRPL),9                                      0797
         BNE   @RF00797                                            0797
         L     @10,RPLDACB(,RRPL)                                  0797
         L     @10,ACBAMBL(,@10)                                   0797
         LH    @15,AMBLNUM(,@10)                                   0797
         C     @15,@CF00053                                        0797
         BNH   @RF00797                                            0797
*     RAMB=AMBLIX;                                                 0798
         L     RAMB,AMBLIX(,@10)                                   0798
*   RPARM1=RPLDDDD;                 /* GET STARTING RBA              */
@RF00797 L     RPARM1,RPLDDDD(,RRPL)                               0799
*I32:                                                              0800
*   DO;                             /* IDACALL(IDA019RK)             */
I32      DS    0H                                                  0801
*     CALL IDA019RK;                /* EXIT TO IDA019RK              */
         L     @15,@CV01237                                        0801
         BALR  @14,@15                                             0801
*     GEN(BALR @11,0);              /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*     GEN(USING *,@11);             /* ESTABLISH ADDRESSING          */
         USING *,@11
*     GEN(L     @11,=A(@PSTART));   /* RELOAD BASE                   */
         L     @11,=A(@PSTART)
*     GEN(USING @PSTART,@11);       /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*   END I32;                        /* CALL PREFORMAT ROUTINE        */
*   GEN(IDARST14);                  /* RESTORE RETURN REGISTER       */
         IDARST14
*   END R1PREFMT;                   /* END OF PREFORMAT REQ.         */
@EL00006 DS    0H                                                  0808
@EF00006 DS    0H                                                  0808
@ER00006 BR    @14                                                 0808
*                                                                  0809
*/* R1FRCIO -- FORCE I/O COMPLETION AND DEFERRED WRITE INITIATION    */
*/* FUNCTION = FORCE WRITE THE DATA AND THE INDEX.                   */
*/* INPUT = RRPL, RPLSTRID, AND RAMB ARE SET AS FOR R1PREFMT.        */
*/* OUTPUT = RRPL IS SET, RPLH IS SET, RAMB ADDRESSES DATA OR INDEX. */
*                                                                  0809
*R1FRCIO:                                                          0809
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);                               0809
R1FRCIO  DS    0H                                                  0810
*   RFY                                                            0810
*     R14 RSTD;                     /* GUARD RETURN REGISTER         */
*   GEN(IDASVR14);                  /* SAVE REGISTER 14              */
         IDASVR14
*   RFY                                                            0812
*     R14 UNRSTD;                   /* MAKE REG.14 AVAILABLE         */
*   RBUFC=PLHDBUFC;                 /* POINT TO DATA BUFC            */
         L     @10,PLHDBUFC(,RPLH)                                 0813
         LR    RBUFC,@10                                           0813
*   IF BUFCMW=ON THEN               /* MAKE SURE RBAS AGREE          */
         TM    BUFCMW(RBUFC),B'10000000'                           0814
         BNO   @RF00814                                            0814
*     DO;                           /*                       @X04SVMR*/
*       BUFCDDDD=BUFCORBA;          /* FOR DATA INSERT.              */
         L     @15,BUFCORBA(,RBUFC)                                0816
         ST    @15,BUFCDDDD(,RBUFC)                                0816
*/*  CAUSE DATA I/O TO BE DONE                                       */
*                                                                  0817
*       RBUFC=PLHDBUFC->BUFCNXT2;   /* GET OLDEST BFR        @ZA10851*/
         L     RBUFC,BUFCNXT2-1(,@10)                              0817
         LA    RBUFC,0(,RBUFC)                                     0817
*I33:                                                              0818
*       DO;                         /* IDACALL(IDAWRBFR)             */
I33      DS    0H                                                  0819
*         CALL IDAWRBFR;            /* EXIT TO IDAWRBFR              */
         L     @15,@CV01236                                        0819
         BALR  @14,@15                                             0819
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I33;                    /* WRITE DATA                    */
*       RBUFC=PLHDBUFC;             /* POINT DATA            @ZA19099*/
         L     RBUFC,PLHDBUFC(,RPLH)                               0825
*       IF RPLERREG='00'X THEN      /* IF NO ERROR, OX05143          */
         CLI   RPLERREG(RRPL),0                                    0826
         BNE   @RF00826                                            0826
*         BUFCMW=ON;                /* FORCE WRITE OX05143           */
         OI    BUFCMW(RBUFC),B'10000000'                           0827
*     END;                          /* END OF MW ON          @X04SVMR*/
*   ELSE                            /* BUFCMW OFF            @X04SVMR*/
*     DO;                           /*                       @ZA10851*/
         B     @RC00814                                            0829
@RF00814 DS    0H                                                  0830
*       RBUFC=PLHDBUFC->BUFCNXT2;   /* GET OLDEST BFR        @ZA10851*/
         L     @10,PLHDBUFC(,RPLH)                                 0830
         L     RBUFC,BUFCNXT2-1(,@10)                              0830
         LA    RBUFC,0(,RBUFC)                                     0830
*I34:                                                              0831
*       DO;                         /* IDACALL(IDAWRBFR)             */
I34      DS    0H                                                  0832
*         CALL IDAWRBFR;            /* EXIT TO IDAWRBFR              */
         L     @15,@CV01236                                        0832
         BALR  @14,@15                                             0832
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I34;                    /* FLUSH I/O             @ZA10851*/
*     END;                          /*                       @ZA10851*/
*   IF RPLERREG='00'X&              /* IF DATA WAS WRITTEN OK        */
*       AMDDST='1'B&                /* AND AN INDEX EXISTS,          */
*       AMBLNUM>ONE                 /* (NOT DATA ONLY PROC)          */
*     THEN                          /* WRITE IT TOO.                 */
@RC00814 CLI   RPLERREG(RRPL),0                                    0839
         BNE   @RF00839                                            0839
         L     @10,AMBDSB(,RAMB)                                   0839
         TM    AMDDST(@10),B'10000000'                             0839
         BNO   @RF00839                                            0839
         L     @10,RPLDACB(,RRPL)                                  0839
         L     @10,ACBAMBL(,@10)                                   0839
         LH    @15,AMBLNUM(,@10)                                   0839
         C     @15,@CF00053                                        0839
         BNH   @RF00839                                            0839
*     DO;                                                          0840
*                                                                  0840
*       /*************************************************************/
*       /*                                                           */
*       /* SET UP FOR AN INDEX WRITE                                 */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0841
*       RAMB=AMBLIX;                /* POINT TO INDEX AMB            */
         L     RAMB,AMBLIX(,@10)                                   0841
*       RBUFC=PLHIBUFC;             /* POINT TO INDEX BUFC           */
*                                                                  0842
         L     RBUFC,PLHIBUFC(,RPLH)                               0842
*       /*************************************************************/
*       /*                                                           */
*       /* CAUSE INDEX TO BE WRITTEN IF NECESSARY                    */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0843
*       IF BUFCMW=ON                /* IF INDEX RECORD NOT           */
*         THEN                      /* WRITTEN, WRITE IT.            */
         TM    BUFCMW(RBUFC),B'10000000'                           0843
         BNO   @RF00843                                            0843
*         DO;                                                      0844
*I35:                                                              0845
*           DO;                     /* IDACALL(IDAWRBFR)             */
I35      DS    0H                                                  0846
*             CALL IDAWRBFR;        /* EXIT TO IDAWRBFR              */
         L     @15,@CV01236                                        0846
         BALR  @14,@15                                             0846
*             GEN(BALR @11,0);      /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*             GEN(USING *,@11);     /* ESTABLISH ADDRESSING          */
         USING *,@11
*             GEN(L     @11,=A(@PSTART));/* RELOAD BASE              */
         L     @11,=A(@PSTART)
*             GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING         */
         USING @PSTART,@11
*           END I35;                /* WRITE INDEX RECORD            */
*           IF RPLERREG='00'X THEN  /* IF OK, CAUSE A REWRITE        */
         CLI   RPLERREG(RRPL),0                                    0852
         BNE   @RF00852                                            0852
*             BUFCMW=ON;            /* IN CASE RECORD UPDATED.       */
         OI    BUFCMW(RBUFC),B'10000000'                           0853
*         END;                      /* END OF INDEX WRITE            */
@RF00852 DS    0H                                                  0855
*       RAMB=AMBLDTA;               /* POINT BACK TO DATA            */
@RF00843 L     @10,RPLDACB(,RRPL)                                  0855
         L     @10,ACBAMBL(,@10)                                   0855
         L     RAMB,AMBLDTA(,@10)                                  0855
*     END;                          /* END OF INDEX EXISTS           */
*   GEN(IDARST14);                  /* RESTORE RETURN REG            */
@RF00839 DS    0H                                                  0857
         IDARST14
*   END R1FRCIO;                    /* END OF FORCE I/O RTN          */
@EL00007 DS    0H                                                  0858
@EF00007 DS    0H                                                  0858
@ER00007 BR    @14                                                 0858
*                                                                  0859
*/* R1TERM -- TERMINATE REQUEST                                      */
*/*01  FUNCTION = RELEASE RPLS FOR REUSE BY POSTING THEM AND MAKING  */
*/*              THEM INACTIVE.                                      */
*/*01  INPUT = RRPL IS THE FIRST RPL TO RELEASE, RPARM1 IS THE CHAIN */
*/*            PTR OF THE LAST RPL TO RELEASE (ZERO IF ALL RELEASED).*/
*/*01  OUTPUT = RPLS FREED AND POSTED, RWORK1 CHANGED, RRPL IS THE   */
*/*             LAST RPL FREED, AND RPARM1 IS UNCHANGED.             */
*                                                                  0859
*R1TERM:                                                           0859
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);/* TERMINATE REQUEST             */
R1TERM   DS    0H                                                  0860
*   RFY                                                            0860
*    (RWORK1,                                                      0860
*     R14) RSTD;                    /* GET REGISTERS                 */
*   DO WHILE RRPL^=RPARM1;          /* FREE ALL RPLS DESIRED         */
         B     @DE00861                                            0861
@DL00861 DS    0H                                                  0862
*     RWORK1=R1;                    /* SAVE REGISTER ONE             */
         LR    RWORK1,R1                                           0862
*     IF RPLECBSW=OFF               /* IF THE ECB IS LOCAL,          */
*       THEN                        /* POINT TO IT.                  */
         TM    RPLECBSW(RRPL),B'00000001'                          0863
         BNZ   @RF00863                                            0863
*       R1=ADDR(RPLECB);                                           0864
         LA    @15,RPLECB(,RRPL)                                   0864
         LR    R1,@15                                              0864
*     ELSE                          /* OTHERWISE, GET EXT. ECB       */
*       R1=ADDR(USERECB);                                          0865
         B     @RC00863                                            0865
@RF00863 L     R1,RPLECBPT(,RRPL)                                  0865
*     GEN(POST  (1));               /* POST ECB COMPLETE             */
@RC00863 DS    0H                                                  0866
         POST  (1)
*     R1=RWORK1;                    /* RESTORE REGISTER ONE          */
         LR    R1,RWORK1                                           0867
*     RPLACTIV=CZERO;               /* MAKE RPL INACTIVE             */
         MVI   RPLACTIV(RRPL),B'00000000'                          0868
*     RRPL=RPLCHAIN;                /* NEXT RPL IN CHAIN             */
         L     RRPL,RPLCHAIN(,RRPL)                                0869
*   END;                            /* END OF RPL FREEING            */
@DE00861 CR    RRPL,RPARM1                                         0870
         BNE   @DL00861                                            0870
*BADPOST:                                                          0871
*   RETURN;                         /* RETURN TO CALLER              */
@EL00008 DS    0H                                                  0871
@EF00008 DS    0H                                                  0871
@ER00008 BR    @14                                                 0871
*   END R1TERM;                     /* ALL RPLS DESIRED FREE         */
         B     @EL00008                                            0872
*   GEN(IDAPATCH);                  /* DEFINE A PATCH AREA           */
         IDAPATCH
*   END IDA019R1                    /* END OF DECODE                 */
*                                                                  0874
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (LCGPLSSW)                                       */
*/*%INCLUDE SYSLIB  (IDAREGS )                                       */
*/*%INCLUDE SYSLIB  (IFGRPL  )                                       */
*/*%INCLUDE SYSLIB  (IDARMRCD)                                       */
*/*%INCLUDE SYSLIB  (IHAPSA  )                                       */
*/*%INCLUDE SYSLIB  (IFGACB  )                                       */
*/*%INCLUDE SYSLIB  (IDAAMBL )                                       */
*/*%INCLUDE SYSLIB  (IDAAMB  )                                       */
*/*%INCLUDE SYSLIB  (IDAAMDSB)                                       */
*/*%INCLUDE SYSLIB  (IDAPLH  )                                       */
*/*%INCLUDE SYSLIB  (IDABUFC )                                       */
*/*%INCLUDE SYSLIB  (IDABLPRM)                                       */
*                                                                  0874
*       ;                                                          0874
         B     @EL00001                                            0874
@DATA    DS    0H
@DATD    DSECT
         DS    0F
IDA019R1 CSECT
         DS    0F
@CF00053 DC    F'1'
@CH00053 EQU   @CF00053+2
@CF00067 DC    F'4'
@CF00036 DC    F'31'
@CF01256 DC    XL4'000000FF'
@DATD    DSECT
         DS    0D
IDA019R1 CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
@CV01235 DC    V(IDASBF)
@CV01236 DC    V(IDAWRBFR)
@CV01237 DC    V(IDA019RK)
@CV01238 DC    V(IDAENDRQ)
@CV01239 DC    V(IDAMRKBF)
@CV01240 DC    V(IDA019RR)
@CV01241 DC    V(IDA019RX)
@CV01242 DC    V(IDASCHBF)
@CV01243 DC    V(IDAWRTBF)
@CV01244 DC    V(IDAFREEB)
@CV01245 DC    V(IDARSTRT)
@CV01246 DC    V(IDALOCEX)
@CV01247 DC    V(IDAEXITR)
@CV01248 DC    V(IDA019R4)
@CV01249 DC    V(IDAXGPLH)
@CV01250 DC    V(IDA019R5)
@CV01251 DC    V(IDA019R8)
@CV01252 DC    V(IDAEXEX)
@CV01253 DC    V(IDA019SN)
@CV01387 DC    V(IDA019ST)
         DS    0D
HWORD4   DC    H'4'
         DS    CL2
POSTED   DC    X'40000000'
C2ZERO   DC    X'0000'
         DS    CL2
CP0001@  DC    AL4(PUT)
         DC    AL4(CHECK)
         DC    AL4(POINT)
         DC    AL4(ENDREQ)
         DC    AL4(ERASE)
         DC    AL4(VERIFY)
         DC    AL4(INVALID)
         DC    AL4(PFMTD)
         DC    AL4(PFMTI)
         DC    AL4(FRCIO)
         DC    AL4(GETIX)
         DC    AL4(PUTIX)
         DC    AL4(SCHBFR)
         DC    AL4(MRKBFR)
         DC    AL4(WRTBFR)
         DC    AL4(INVALID)
         DC    AL4(INVALID)
         DC    AL4(INVALID)
         DC    AL4(TERMRPL)
@DATD    DSECT
TWENTY8  EQU   28                       OFFSET TO REG 2
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IDA019R1 CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
RWORK0   EQU   @00
RRPL     EQU   @01
R1       EQU   @01
RPLH     EQU   @02
RAMB     EQU   @03
RBUFC    EQU   @04
RWORK1   EQU   @05
RWORK2   EQU   @06
RWORK3   EQU   @07
RWORK4   EQU   @08
RPARM1   EQU   @12
R13      EQU   @13
R14      EQU   @14
R15      EQU   @15
RWORK5   EQU   @09
R10      EQU   @10
R11      EQU   @11
PSA      EQU   0
FLCRNPSW EQU   PSA
FLCROPSW EQU   PSA+8
FLCICCW2 EQU   PSA+16
PSAEEPSW EQU   PSA+132
PSAESPSW EQU   PSA+136
FLCSVILC EQU   PSAESPSW+1
PSAEPPSW EQU   PSA+140
FLCPIILC EQU   PSAEPPSW+1
FLCPICOD EQU   PSAEPPSW+2
PSAPICOD EQU   FLCPICOD+1
FLCTEA   EQU   PSAEPPSW+4
FLCPER   EQU   PSA+152
FLCMCLA  EQU   PSA+168
FLCIOEL  EQU   FLCMCLA+4
FLCIOA   EQU   FLCMCLA+16
FLCFSA   EQU   FLCMCLA+80
PSAAOLD  EQU   PSA+548
PSASUPER EQU   PSA+552
PSASUP1  EQU   PSASUPER
PSASUP2  EQU   PSASUPER+1
PSASUP3  EQU   PSASUPER+2
PSASUP4  EQU   PSASUPER+3
PSACLHT  EQU   PSA+640
PSALKSA  EQU   PSA+696
PSAHLHI  EQU   PSA+760
PSADSSFL EQU   PSA+836
PSADSSF1 EQU   PSADSSFL
PSADSSF3 EQU   PSADSSFL+2
PSADSSF4 EQU   PSADSSFL+3
PSARSVT  EQU   PSA+896
IFGRPL   EQU   0
RPLCOMN  EQU   IFGRPL
RPLIDWD  EQU   RPLCOMN
RPLREQ   EQU   RPLIDWD+2
RPLLEN   EQU   RPLIDWD+3
RPLPLHPT EQU   RPLCOMN+4
RPLECB   EQU   RPLCOMN+8
RPLFDBWD EQU   RPLCOMN+12
RPLFDBK  EQU   RPLFDBWD+1
RPLRTNCD EQU   RPLFDBK
RPLERREG EQU   RPLRTNCD
RPLCNDCD EQU   RPLFDBK+1
RPLCMPON EQU   RPLCNDCD
RPLFDB2  EQU   RPLCMPON
RPLERRCD EQU   RPLCNDCD+1
RPLFDB3  EQU   RPLERRCD
RPLKEYLE EQU   RPLCOMN+16
RPLKEYL  EQU   RPLKEYLE
RPLSTRID EQU   RPLCOMN+18
RPLDACB  EQU   RPLCOMN+24
RPLARG   EQU   RPLCOMN+36
RPLOPTCD EQU   RPLCOMN+40
RPLOPT1  EQU   RPLOPTCD
RPLLOC   EQU   RPLOPT1
RPLDIR   EQU   RPLOPT1
RPLSEQ   EQU   RPLOPT1
RPLSKP   EQU   RPLOPT1
RPLASY   EQU   RPLOPT1
RPLGEN   EQU   RPLOPT1
RPLECBSW EQU   RPLOPT1
RPLOPT2  EQU   RPLOPTCD+1
RPLKEY   EQU   RPLOPT2
RPLADR   EQU   RPLOPT2
RPLADD   EQU   RPLADR
RPLCNV   EQU   RPLOPT2
RPLWAITX EQU   RPLOPT2
RPLUPD   EQU   RPLOPT2
RPLOPT3  EQU   RPLOPTCD+2
RPLNXTRP EQU   RPLCOMN+44
RPLCHAIN EQU   RPLNXTRP
RPLRLEN  EQU   RPLCOMN+48
RPLOPTC2 EQU   RPLCOMN+56
RPLOPT5  EQU   RPLOPTC2
RPLWRTYP EQU   RPLOPT5
RPLOPT6  EQU   RPLOPTC2+1
RPLUNTYP EQU   RPLOPT6
RPLOPT7  EQU   RPLOPTC2+2
RPLCNOPT EQU   RPLOPT7
RPLOPT8  EQU   RPLOPTC2+3
RPLRBAR  EQU   RPLCOMN+60
RPLAIXID EQU   RPLRBAR+2
RPLDDDD  EQU   RPLRBAR+4
RPLEXTDS EQU   RPLCOMN+68
RPLEXTD1 EQU   RPLEXTDS
RPLACTIV EQU   RPLCOMN+69
IFGACB   EQU   0
ACBCOMN  EQU   IFGACB
ACBLENG  EQU   ACBCOMN+2
ACBLENG2 EQU   ACBLENG
ACBAMBL  EQU   ACBCOMN+4
ACBJWA   EQU   ACBAMBL
ACBMACRF EQU   ACBCOMN+12
ACBMACR1 EQU   ACBMACRF
ACBADR   EQU   ACBMACR1
ACBCNV   EQU   ACBMACR1
ACBMACR2 EQU   ACBMACRF+1
ACBBUFPL EQU   ACBCOMN+20
ACBMACR3 EQU   ACBBUFPL
ACBRECFM EQU   ACBCOMN+24
ACBCCTYP EQU   ACBCOMN+25
ACBOPT   EQU   ACBCOMN+26
ACBDSORG EQU   ACBOPT
ACBCROPS EQU   ACBDSORG
ACBEXLST EQU   ACBCOMN+36
ACBDDNM  EQU   ACBCOMN+40
ACBAMETH EQU   ACBDDNM+3
ACBOFLGS EQU   ACBCOMN+48
ACBEXFG  EQU   ACBOFLGS
ACBIOSFG EQU   ACBOFLGS
ACBINFLG EQU   ACBCOMN+50
ACBUJFCB EQU   ACBCOMN+52
ACBBLKSZ EQU   ACBCOMN+60
IDAAMBL  EQU   0
AMBLEOV  EQU   IDAAMBL+12
AMBLEFLG EQU   AMBLEOV
AMBLDDNM EQU   IDAAMBL+16
AMBLIDF  EQU   AMBLDDNM
AMBLQ    EQU   AMBLIDF+7
AMBLVC   EQU   IDAAMBL+28
AMBLTYPE EQU   IDAAMBL+30
AMBLPATH EQU   AMBLTYPE
AMBLSHAR EQU   IDAAMBL+33
AMBLFLG1 EQU   IDAAMBL+35
AMBLFLG2 EQU   IDAAMBL+36
AMBLNUM  EQU   IDAAMBL+38
AMBLDTA  EQU   IDAAMBL+52
AMBLIX   EQU   IDAAMBL+56
IDAAMB   EQU   0
AMBPH    EQU   IDAAMB+12
AMBDSB   EQU   IDAAMB+20
AMBEOVR  EQU   IDAAMB+24
AMBFLG0  EQU   AMBEOVR
AMBFLG1  EQU   IDAAMB+25
AMBCREAT EQU   AMBFLG1
AMBUBF   EQU   AMBFLG1
AMBDSORG EQU   IDAAMB+26
AMBIOBAD EQU   IDAAMB+28
AMBINFL  EQU   IDAAMB+42
AMBDEBPT EQU   IDAAMB+44
AMBOFLGS EQU   IDAAMB+48
AMBFLG2  EQU   IDAAMB+49
AMBEOVPT EQU   IDAAMB+56
AMBUPLH  EQU   IDAAMB+80
AMBCSWD1 EQU   IDAAMB+84
AMBAFLG  EQU   AMBCSWD1
AMBLSR   EQU   AMBAFLG
AMBGSR   EQU   AMBAFLG
AMBEXEX  EQU   IDAAMB+100
AMBTRACE EQU   IDAAMB+120
IDAAMDSB EQU   0
AMDATTR  EQU   IDAAMDSB+1
AMDDST   EQU   AMDATTR
AMDRRDS  EQU   AMDATTR
AMDNEST  EQU   IDAAMDSB+4
AMDKEYLN EQU   IDAAMDSB+8
AMDCINV  EQU   IDAAMDSB+20
AMDHLRBA EQU   IDAAMDSB+28
AMDSSRBA EQU   IDAAMDSB+32
AMDATTR3 EQU   IDAAMDSB+40
AMDSTAT  EQU   IDAAMDSB+48
IDAPLHDR EQU   0
PLHDRREQ EQU   IDAPLHDR+4
PLHDRMAX EQU   IDAPLHDR+8
PLHDRCUR EQU   IDAPLHDR+10
IDAPLH   EQU   0
PLHAVL   EQU   IDAPLH
PLHFLG1  EQU   IDAPLH+2
PLHENDRQ EQU   PLHFLG1
PLHFLG2  EQU   IDAPLH+3
PLHIWAIT EQU   PLHFLG2
PLHEFLGS EQU   IDAPLH+4
PLH1ST   EQU   PLHEFLGS
PLHINVAL EQU   PLHEFLGS
PLHFLG3  EQU   IDAPLH+6
PLHSLVLD EQU   PLHFLG3
PLHAFLGS EQU   IDAPLH+7
PLHIOSID EQU   PLHAFLGS
PLHACB   EQU   IDAPLH+8
PLHMRPL  EQU   IDAPLH+16
PLHCRPL  EQU   IDAPLH+20
PLHCRBA  EQU   IDAPLH+28
PLHJORBA EQU   PLHCRBA
PLHJCODE EQU   IDAPLH+40
PLHRSCS  EQU   IDAPLH+43
PLHARDB  EQU   IDAPLH+44
PLHDBUFC EQU   IDAPLH+52
PLHDIOB  EQU   IDAPLH+76
PLHCHAIN EQU   IDAPLH+112
PLHRETO  EQU   IDAPLH+116
PLHRETOS EQU   IDAPLH+118
PLHRET1  EQU   IDAPLH+120
PLHEOVPT EQU   IDAPLH+180
PLHIBUFC EQU   IDAPLH+188
PLHIXSPL EQU   IDAPLH+200
PLHSSRBA EQU   PLHIXSPL
PLHWAX   EQU   IDAPLH+232
PLHSLRBA EQU   IDAPLH+244
PLHKEYPT EQU   IDAPLH+248
PLHTMRPL EQU   IDAPLH+265
PLHECB   EQU   IDAPLH+268
PLHASCB  EQU   IDAPLH+272
PLHERRET EQU   IDAPLH+276
PLHEND   EQU   IDAPLH+280
IDABUFDR EQU   0
BUFDRCIX EQU   IDABUFDR+9
BUFDRFLG EQU   IDABUFDR+11
IDABUFC  EQU   0
BUFCAVL  EQU   IDABUFC
BUFCFLG1 EQU   IDABUFC+1
BUFCIOFL EQU   IDABUFC+2
BUFCMW   EQU   BUFCIOFL
BUFCFLG2 EQU   IDABUFC+3
BUFCPLH  EQU   IDABUFC+4
BUFCDDDD EQU   IDABUFC+8
BUFCORBA EQU   IDABUFC+12
BUFCINV  EQU   IDABUFC+28
BUFCNXT2 EQU   IDABUFC+37
IDABLPRM EQU   0
BLPBUFLP EQU   IDABLPRM+4
BLPUACB  EQU   BLPBUFLP
BLPFLAGS EQU   IDABLPRM+10
BLPFLAG1 EQU   BLPFLAGS
BLPFLAG2 EQU   BLPFLAGS+1
BLPCORE  EQU   IDABLPRM+16
BLPGFLG  EQU   BLPCORE
BLPIOACB EQU   IDABLPRM+24
BLPBUFL  EQU   0
BLPBRLFG EQU   BLPBUFL+4
RBA      EQU   0
ECB      EQU   0
ECBPOST  EQU   ECB
USERECB  EQU   0
R15SAVE  EQU   16
R0SAVE   EQU   20
CL0001@  EQU   0
CORE     EQU   0
PLHKEY   EQU   0
PLHPDL   EQU   0
PLHPDLE  EQU   0
PLHRRN   EQU   0
R1SAVE   EQU   24
USEREXIT EQU   0
PSARSVTE EQU   PSARSVT
PLHEXTEN EQU   PLHEND
PLHBMWRK EQU   PLHEXTEN+5
PLHBMSV1 EQU   PLHEXTEN+8
RPLECBPT EQU   RPLECB
BUFCRSC1 EQU   BUFCAVL
FLC      EQU   PSA
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
PLHBMSV5 EQU   PLHEXTEN+24
PLHBMSV4 EQU   PLHEXTEN+20
PLHBMSV3 EQU   PLHEXTEN+16
PLHBMSV2 EQU   PLHEXTEN+12
PLHRDCNT EQU   PLHEXTEN+6
PLHBMSOV EQU   PLHBMWRK
PLHBEUC  EQU   PLHBMWRK
PLHBMRDF EQU   PLHBMWRK
@NM00068 EQU   PLHEXTEN+4
PLHRESR1 EQU   PLHEXTEN
PSARSAV  EQU   PSARSVTE+60
PSARSTK  EQU   PSARSVTE+56
PSAESAV3 EQU   PSARSVTE+52
PSAESTK3 EQU   PSARSVTE+48
PSAESAV2 EQU   PSARSVTE+44
PSAESTK2 EQU   PSARSVTE+40
PSAESAV1 EQU   PSARSVTE+36
PSAESTK1 EQU   PSARSVTE+32
PSAPSAV  EQU   PSARSVTE+28
PSAPSTK  EQU   PSARSVTE+24
PSAMSAV  EQU   PSARSVTE+20
PSAMSTK  EQU   PSARSVTE+16
PSASSAV  EQU   PSARSVTE+12
PSASSTK  EQU   PSARSVTE+8
PSANSTK  EQU   PSARSVTE+4
PSACSTK  EQU   PSARSVTE
ECBWAIT  EQU   ECB
BLPBFLCT EQU   BLPBUFL+6
@NM00077 EQU   BLPBUFL+5
@NM00076 EQU   BLPBRLFG
BLPBFLST EQU   BLPBRLFG
BLPBUFSZ EQU   BLPBUFL
BLPERFLG EQU   IDABLPRM+51
@NM00075 EQU   IDABLPRM+49
BLPOFLGS EQU   IDABLPRM+48
@NM00074 EQU   IDABLPRM+28
BLPDSORG EQU   BLPIOACB+3
@NM00073 EQU   BLPIOACB
BLPGAD   EQU   BLPCORE+5
BLPGSP   EQU   BLPCORE+4
BLPGSZ   EQU   BLPCORE+1
BLPGPG   EQU   BLPGFLG
BLPGREQ  EQU   BLPGFLG
BLPOACB  EQU   IDABLPRM+13
BLPOCODE EQU   IDABLPRM+12
BLPFRSTR EQU   BLPFLAG2
BLPFIOSR EQU   BLPFLAG2
BLPFINDX EQU   BLPFLAG2
BLPFDATA EQU   BLPFLAG2
BLPFPRIM EQU   BLPFLAG2
BLPFPATH EQU   BLPFLAG2
BLPFUPGR EQU   BLPFLAG2
BLPFPART EQU   BLPFLAG2
BLPFSTAD EQU   BLPFLAG1
BLPFBFRF EQU   BLPFLAG1
BLPFIOBF EQU   BLPFLAG1
BLPFGSR  EQU   BLPFLAG1
BLPFLSR  EQU   BLPFLAG1
BLPFDEL  EQU   BLPFLAG1
BLPFBLD  EQU   BLPFLAG1
BLPFDBDC EQU   BLPFLAG1
BLPSTRNO EQU   IDABLPRM+9
BLPKEYLN EQU   IDABLPRM+8
BLPIOPLH EQU   BLPUACB
@NM00072 EQU   IDABLPRM+2
BLPACBST EQU   IDABLPRM+1
BLPACBID EQU   IDABLPRM
BUFCEND  EQU   IDABUFC+64
BUFCUCDN EQU   IDABUFC+60
BUFCUCUP EQU   IDABUFC+56
BUFCMDBT EQU   IDABUFC+52
BUFCHAIN EQU   IDABUFC+48
BUFXORBA EQU   IDABUFC+44
BUFXIRBA EQU   IDABUFC+40
BUFCIDXL EQU   IDABUFC+36
BUFCDSPC EQU   IDABUFC+32
BUFCWLEN EQU   BUFCINV
BUFCNXT1 EQU   IDABUFC+24
BUFCBAD  EQU   IDABUFC+20
BUFCCPA  EQU   IDABUFC+16
BUFCAMB  EQU   BUFCPLH
@NM00071 EQU   BUFCFLG2
BUFCEOD  EQU   BUFCFLG2
BUFCBSYW EQU   BUFCFLG2
BUFCBSYR EQU   BUFCFLG2
BUFCNLAS EQU   BUFCFLG2
BUFCXDDR EQU   BUFCFLG2
BUFCFIX  EQU   BUFCIOFL
BUFCPFCP EQU   BUFCIOFL
BUFCXEDB EQU   BUFCIOFL
BUFCWC   EQU   BUFCIOFL
BUFCREAL EQU   BUFCIOFL
BUFCRRD  EQU   BUFCIOFL
BUFCFMT  EQU   BUFCIOFL
BUFCEPT  EQU   BUFCFLG1
BUFCEXC  EQU   BUFCFLG1
BUFCVAL  EQU   BUFCFLG1
BUFCER2  EQU   BUFCFLG1
BUFCER1  EQU   BUFCFLG1
BUFCINS  EQU   BUFCFLG1
BUFCSEG  EQU   BUFCFLG1
BUFCUPG  EQU   BUFCFLG1
BUFCUCNT EQU   BUFCAVL
@NM00070 EQU   IDABUFDR+16
BUFDBUFC EQU   IDABUFDR+12
@NM00069 EQU   BUFDRFLG
BUFDRAVL EQU   BUFDRFLG
BUFDRREL EQU   BUFDRFLG
BUFDRTSB EQU   IDABUFDR+10
BUFDRMAX EQU   BUFDRCIX
BUFDRPFN EQU   IDABUFDR+8
BUFDRPFB EQU   IDABUFDR+4
BUFDRLEN EQU   IDABUFDR+2
BUFDRNO  EQU   IDABUFDR+1
BUFDRID  EQU   IDABUFDR
@NM00067 EQU   IDAPLH+266
@NM00066 EQU   PLHTMRPL
PLHTMIOB EQU   PLHTMRPL
PLHTMINX EQU   PLHTMRPL
PLHTMDTA EQU   PLHTMRPL
PLHTMDIW EQU   PLHTMRPL
PLHTMBUF EQU   PLHTMRPL
PLHTERM  EQU   PLHTMRPL
PLHDRMSK EQU   IDAPLH+264
PLHR13   EQU   IDAPLH+260
PLHPARM1 EQU   IDAPLH+256
PLHDRRSC EQU   IDAPLH+252
PLHSRCSG EQU   IDAPLH+242
PLHNOSEG EQU   IDAPLH+240
PLHLLOR  EQU   IDAPLH+236
PLHXPLH  EQU   PLHWAX
@NM00065 EQU   PLHIXSPL+8
PLHIXBFC EQU   PLHIXSPL+4
PLHHIREC EQU   PLHSSRBA
PLHISPLP EQU   IDAPLH+196
PLHRBUFC EQU   IDAPLH+192
PLHNRBA  EQU   IDAPLH+184
PLHDDDD  EQU   PLHEOVPT
PLHAR14  EQU   IDAPLH+176
@NM00064 EQU   IDAPLH+172
@NM00063 EQU   IDAPLH+168
PLHASAVE EQU   IDAPLH+164
PLHAMB   EQU   IDAPLH+108
PLHSAVE6 EQU   IDAPLH+104
PLHSAVE5 EQU   IDAPLH+100
PLHSAVE4 EQU   IDAPLH+96
PLHSAVE3 EQU   IDAPLH+92
PLHSAVE2 EQU   IDAPLH+88
PLHSAVE1 EQU   IDAPLH+84
PLHARET  EQU   IDAPLH+80
PLHIIOB  EQU   PLHDIOB
PLHSRSID EQU   IDAPLH+74
PLHRDFC  EQU   IDAPLH+72
PLHRDFP  EQU   IDAPLH+68
PLHFSP   EQU   IDAPLH+64
PLHRECP  EQU   IDAPLH+60
PLHNBUFC EQU   IDAPLH+56
PLHLRECL EQU   IDAPLH+48
@NM00062 EQU   PLHRSCS
PLHDBPER EQU   PLHRSCS
PLHDSERR EQU   PLHRSCS
PLHASYER EQU   PLHRSCS
@NM00061 EQU   PLHRSCS
PLHBUFHD EQU   PLHRSCS
PLHINEOV EQU   PLHRSCS
PLHEOVR  EQU   IDAPLH+42
PLHRCODE EQU   IDAPLH+41
PLHUCODE EQU   PLHJCODE
PLHJNRBA EQU   IDAPLH+36
PLHJRNLL EQU   IDAPLH+32
PLHUPECB EQU   PLHJORBA
PLHDSIDA EQU   IDAPLH+24
PLHBFRNO EQU   IDAPLH+15
PLHFRCNT EQU   IDAPLH+14
PLHRMIN  EQU   IDAPLH+13
PLHDSTYP EQU   IDAPLH+12
PLHRAE   EQU   PLHAFLGS
PLHRABWD EQU   PLHAFLGS
PLHDBDC  EQU   PLHAFLGS
PLHVAMB  EQU   PLHAFLGS
PLHIOSRQ EQU   PLHAFLGS
PLHDRLM  EQU   PLHAFLGS
PLHEOVDF EQU   PLHFLG3
PLHRVRS  EQU   PLHFLG3
PLHBWD   EQU   PLHFLG3
PLHRAHD  EQU   PLHFLG3
PLHSRBSG EQU   PLHFLG3
@NM00060 EQU   PLHEFLGS+1
PLHRSTRT EQU   PLHEFLGS+1
PLHDSCAN EQU   PLHEFLGS
PLHEODX  EQU   PLHEFLGS
PLHNOADV EQU   PLHEFLGS
PLHSRINV EQU   PLHEFLGS
PLHSKPER EQU   PLHEFLGS
PLHNOSPC EQU   PLHEFLGS
PLHSVADV EQU   PLHFLG2
PLHCIINS EQU   PLHFLG2
PLHKRE   EQU   PLHFLG2
PLHADDTE EQU   PLHFLG2
PLHKEYMD EQU   PLHFLG2
PLHSQINS EQU   PLHFLG2
PLHUPD   EQU   PLHFLG2
@NM00059 EQU   PLHFLG1
PLHDRPND EQU   PLHFLG1
PLHASYRQ EQU   PLHFLG1
PLHRDEXC EQU   PLHFLG1
PLHSSR   EQU   PLHFLG1
PLHASKBF EQU   PLHFLG1
PLHEOVW  EQU   PLHFLG1
PLHATV   EQU   IDAPLH+1
PLHIOSDQ EQU   IDAPLHDR+12
PLHELTH  EQU   IDAPLHDR+2
PLHCNT   EQU   IDAPLHDR+1
PLHID    EQU   IDAPLHDR
AMDEXCP  EQU   AMDSTAT+44
AMDNCAS  EQU   AMDSTAT+40
AMDNCIS  EQU   AMDSTAT+36
AMDASPA  EQU   AMDSTAT+32
AMDRETR  EQU   AMDSTAT+28
AMDUPR   EQU   AMDSTAT+24
AMDIREC  EQU   AMDSTAT+20
AMDDELR  EQU   AMDSTAT+16
AMDNLR   EQU   AMDSTAT+12
AMDNEXT  EQU   AMDSTAT+10
AMDNIL   EQU   AMDSTAT+8
AMDSTSP  EQU   AMDSTAT
@NM00058 EQU   IDAAMDSB+41
@NM00057 EQU   AMDATTR3
AMDLM    EQU   AMDATTR3
AMDWAIT  EQU   AMDATTR3
AMDBIND  EQU   AMDATTR3
AMDFAULT EQU   AMDATTR3
AMDUNQ   EQU   AMDATTR3
AMDPARDB EQU   IDAAMDSB+36
AMDMAXRR EQU   AMDSSRBA
AMDNSLOT EQU   AMDHLRBA
AMDLRECL EQU   IDAAMDSB+24
AMDFSCI  EQU   IDAAMDSB+16
AMDFSCA  EQU   IDAAMDSB+14
AMDCIPCA EQU   IDAAMDSB+12
AMDPCTCI EQU   IDAAMDSB+11
AMDPCTCA EQU   IDAAMDSB+10
AMDRKP   EQU   IDAAMDSB+6
AMDAXRKP EQU   AMDNEST
AMDLEN   EQU   IDAAMDSB+2
AMDSPAN  EQU   AMDATTR
AMDRANGE EQU   AMDATTR
AMDORDER EQU   AMDATTR
AMDREPL  EQU   AMDATTR
AMDSDT   EQU   AMDATTR
AMDWCK   EQU   AMDATTR
AMDSBID  EQU   IDAAMDSB
AMBVIOT  EQU   IDAAMB+116
AMBSZCP  EQU   IDAAMB+114
AMBSZFW  EQU   IDAAMB+112
AMBSZWR  EQU   IDAAMB+110
AMBSZRD  EQU   IDAAMB+108
AMBWSHD  EQU   IDAAMB+96
AMBCPA   EQU   IDAAMB+92
AMBBM2SH EQU   IDAAMB+88
AMBRDCNT EQU   AMBCSWD1+2
@NM00056 EQU   AMBCSWD1+1
@NM00055 EQU   AMBAFLG
AMBCFX   EQU   AMBAFLG
AMBSIS   EQU   AMBAFLG
AMBDFR   EQU   AMBAFLG
AMBICI   EQU   AMBAFLG
@NM00054 EQU   AMBAFLG
AMBPAMBL EQU   IDAAMB+76
AMBPIXP  EQU   IDAAMB+72
@NM00053 EQU   IDAAMB+68
AMBIWA   EQU   IDAAMB+64
AMBWKA   EQU   IDAAMB+60
AMBAMBXN EQU   AMBEOVPT
AMBEDB   EQU   IDAAMB+52
AMBRPT   EQU   IDAAMB+50
AMBPUG   EQU   AMBFLG2
AMBBUSY  EQU   AMBOFLGS
AMBEXFG  EQU   AMBOFLGS
@NM00052 EQU   AMBOFLGS
AMBOPEN  EQU   AMBOFLGS
@NM00051 EQU   AMBOFLGS
AMBDEBAD EQU   AMBDEBPT+1
AMBIFLGS EQU   AMBDEBPT
AMBAMETH EQU   IDAAMB+43
AMBUPX   EQU   AMBINFL
AMBUCRA  EQU   AMBINFL
AMBSCRA  EQU   AMBINFL
AMBCAT   EQU   AMBINFL
@NM00050 EQU   AMBINFL
@NM00049 EQU   AMBINFL
AMBTIOT  EQU   IDAAMB+40
@NM00048 EQU   IDAAMB+38
AMBDDSN  EQU   IDAAMB+35
AMBCDSN  EQU   IDAAMB+32
AMBIOMB  EQU   AMBIOBAD
@NM00047 EQU   AMBDSORG+1
AMBDORGA EQU   AMBDSORG+1
@NM00046 EQU   AMBDSORG
AMBINBUF EQU   AMBFLG1
AMBJRN   EQU   AMBFLG1
AMBSPEED EQU   AMBFLG1
AMBPCAT  EQU   AMBFLG1
AMBMCAT  EQU   AMBFLG1
AMBTYPE  EQU   AMBFLG1
@NM00045 EQU   AMBFLG0
AMBPSDS  EQU   AMBFLG0
AMBCACB  EQU   IDAAMB+16
AMBBUFC  EQU   IDAAMB+8
AMBLINK  EQU   IDAAMB+4
AMBLEN   EQU   IDAAMB+2
AMBRSC   EQU   IDAAMB+1
AMBID    EQU   IDAAMB
AMBLCMB  EQU   IDAAMBL+64
AMBLBIB  EQU   IDAAMBL+60
AMBLMIDS EQU   IDAAMBL+42
AMBLNIDS EQU   IDAAMBL+41
@NM00044 EQU   IDAAMBL+40
AMBLNST  EQU   IDAAMBL+37
@NM00043 EQU   AMBLFLG2
AMBLSTAG EQU   AMBLFLG2
@NM00042 EQU   AMBLFLG2
AMBLDUMY EQU   AMBLFLG1
AMBLCAT  EQU   AMBLFLG1
AMBLUCRA EQU   AMBLFLG1
AMBLSCRA EQU   AMBLFLG1
AMBLVVIC EQU   AMBLFLG1
AMBLUPD  EQU   AMBLFLG1
AMBLCINV EQU   AMBLFLG1
AMBLFULL EQU   AMBLFLG1
AMBLLEN  EQU   IDAAMBL+34
@NM00041 EQU   AMBLSHAR
AMBLWRIT EQU   AMBLSHAR
AMBLCATO EQU   AMBLSHAR
AMBLPRIM EQU   AMBLSHAR
AMBLID   EQU   IDAAMBL+32
@NM00040 EQU   IDAAMBL+31
@NM00039 EQU   AMBLTYPE
AMBLFIX  EQU   AMBLTYPE
AMBLBASE EQU   AMBLTYPE
AMBLAIX  EQU   AMBLTYPE
AMBLUPGR EQU   AMBLTYPE
AMBLENO  EQU   AMBLVC+1
AMBLVRT  EQU   AMBLVC
AMBLXPT  EQU   IDAAMBL+24
AMBLDFR  EQU   AMBLQ
AMBLESDS EQU   AMBLQ
AMBLKSDS EQU   AMBLQ
AMBLUBF  EQU   AMBLQ
AMBLFSTP EQU   AMBLQ
AMBLLSR  EQU   AMBLQ
AMBLGSR  EQU   AMBLQ
AMBLDDC  EQU   AMBLQ
AMBLDCI  EQU   AMBLIDF+4
AMBLCACB EQU   AMBLIDF
@NM00038 EQU   AMBLEOV+2
AMBLCOMP EQU   AMBLEOV+1
AMBLESET EQU   AMBLEFLG
AMBLWAIT EQU   AMBLEFLG
AMBLACB  EQU   IDAAMBL+8
AMBLSCHN EQU   IDAAMBL+4
AMBLPCHN EQU   IDAAMBL
ACBAPID  EQU   ACBCOMN+72
ACBCBMWA EQU   ACBCOMN+68
ACBUAPTR EQU   ACBCOMN+64
ACBLRECL EQU   ACBCOMN+62
ACBMSGLN EQU   ACBBLKSZ
ACBBUFSP EQU   ACBCOMN+56
@NM00037 EQU   ACBUJFCB+1
ACBOPTN  EQU   ACBUJFCB
ACBVVIC  EQU   ACBINFLG
ACBUCRA  EQU   ACBINFLG
ACBSCRA  EQU   ACBINFLG
ACBCAT   EQU   ACBINFLG
ACBIJRQE EQU   ACBINFLG
ACBJEPS  EQU   ACBINFLG
@NM00036 EQU   ACBINFLG
ACBERFLG EQU   ACBCOMN+49
ACBBUSY  EQU   ACBIOSFG
ACBLOCK  EQU   ACBEXFG
@NM00035 EQU   ACBOFLGS
ACBDSERR EQU   ACBOFLGS
ACBOPEN  EQU   ACBOFLGS
ACBEOV   EQU   ACBOFLGS
@NM00034 EQU   ACBOFLGS
ACBDEB   EQU   ACBDDNM+5
ACBERFL  EQU   ACBDDNM+4
ACBAM    EQU   ACBAMETH
ACBINFL  EQU   ACBDDNM+2
ACBTIOT  EQU   ACBDDNM
ACBUEL   EQU   ACBEXLST
ACBPASSW EQU   ACBCOMN+32
ACBMSGAR EQU   ACBCOMN+28
@NM00033 EQU   ACBDSORG+1
ACBDORGA EQU   ACBDSORG+1
@NM00032 EQU   ACBDSORG
ACBCRNRE EQU   ACBCROPS
ACBCRNCK EQU   ACBCROPS
ACBASA   EQU   ACBCCTYP
@NM00031 EQU   ACBCCTYP
ACBRECAF EQU   ACBRECFM
ACBJBUF  EQU   ACBBUFPL+2
ACBMACR4 EQU   ACBBUFPL+1
@NM00030 EQU   ACBMACR3
ACBNCFX  EQU   ACBMACR3
ACBSIS   EQU   ACBMACR3
ACBDFR   EQU   ACBMACR3
ACBICI   EQU   ACBMACR3
ACBGSR   EQU   ACBMACR3
ACBLSR   EQU   ACBMACR3
@NM00029 EQU   ACBMACR3
ACBBUFNI EQU   ACBCOMN+18
ACBBUFND EQU   ACBCOMN+16
ACBSTRNO EQU   ACBCOMN+15
ACBBSTNO EQU   ACBCOMN+14
ACBAIX   EQU   ACBMACR2
ACBDSN   EQU   ACBMACR2
ACBRST   EQU   ACBMACR2
ACBLOGON EQU   ACBMACR2
ACBSKP   EQU   ACBMACR2
@NM00028 EQU   ACBMACR2
ACBUBF   EQU   ACBMACR1
ACBOUT   EQU   ACBMACR1
ACBIN    EQU   ACBMACR1
ACBDIR   EQU   ACBMACR1
ACBSEQ   EQU   ACBMACR1
ACBBLK   EQU   ACBCNV
ACBADD   EQU   ACBADR
ACBKEY   EQU   ACBMACR1
ACBINRTN EQU   ACBCOMN+8
ACBIBCT  EQU   ACBJWA
ACBLEN2  EQU   ACBLENG2
ACBSTYP  EQU   ACBCOMN+1
ACBID    EQU   ACBCOMN
RPLERMSA EQU   RPLCOMN+72
RPLEMLEN EQU   RPLCOMN+70
RPLBRANC EQU   RPLEXTD1
RPLNIB   EQU   RPLEXTD1
@NM00003 EQU   RPLEXTD1
RPLEXIT  EQU   RPLEXTD1
RPLNEXIT EQU   RPLEXTD1
RPLEXSCH EQU   RPLEXTD1
@NM00002 EQU   RPLRBAR+3
@NM00001 EQU   RPLAIXID
RPLAXPKP EQU   RPLAIXID
RPLAIXPC EQU   RPLRBAR
RPLRSV88 EQU   RPLOPT8
RPLUNCON EQU   RPLOPT8
RPLACTV  EQU   RPLOPT8
RPLSESS  EQU   RPLOPT8
RPLPEND  EQU   RPLOPT8
RPLODPRM EQU   RPLOPT8
RPLODACP EQU   RPLOPT8
RPLODACQ EQU   RPLOPT8
RPLRSV78 EQU   RPLOPT7
RPLRSV77 EQU   RPLOPT7
RPLRLSOP EQU   RPLOPT7
RPLTPOST EQU   RPLOPT7
RPLQOPT  EQU   RPLOPT7
RPLCNIMM EQU   RPLCNOPT
RPLCNANY EQU   RPLCNOPT
RPLCNALL EQU   RPLCNOPT
RPLRSV68 EQU   RPLOPT6
RPLRSV67 EQU   RPLOPT6
RPLLOCK  EQU   RPLOPT6
RPLNCOND EQU   RPLOPT6
RPLCOND  EQU   RPLOPT6
RPLEOT   EQU   RPLUNTYP
RPLEOM   EQU   RPLUNTYP
RPLEOB   EQU   RPLUNTYP
RPLWROPT EQU   RPLOPT5
RPLNODE  EQU   RPLOPT5
RPLERACE EQU   RPLWRTYP
RPLEAU   EQU   RPLWRTYP
RPLNERAS EQU   RPLWRTYP
RPLPSOPT EQU   RPLOPT5
RPLSSNIN EQU   RPLOPT5
RPLDLGIN EQU   RPLOPT5
RPLBUFL  EQU   RPLCOMN+52
RPLOPT4  EQU   RPLOPTCD+3
RPLALIGN EQU   RPLOPT3
RPLFMT   EQU   RPLOPT3
RPLFLD   EQU   RPLOPT3
RPLVFY   EQU   RPLOPT3
RPLBLK   EQU   RPLOPT3
RPLSFORM EQU   RPLOPT3
RPLEODS  EQU   RPLOPT3
RPLNSP   EQU   RPLOPT2
RPLLRD   EQU   RPLOPT2
RPLBWD   EQU   RPLOPT2
RPLECBIN EQU   RPLECBSW
RPLKGE   EQU   RPLOPT1
RPLDAF   EQU   RPLARG+2
RPLSAF   EQU   RPLARG
RPLAREA  EQU   RPLCOMN+32
RPLTCBPT EQU   RPLCOMN+28
RPLCCHAR EQU   RPLCOMN+20
RPLRDSOH EQU   RPLFDB3
RPLRLG   EQU   RPLFDB3
RPLLGFRC EQU   RPLFDB3
RPLREOT  EQU   RPLFDB3
RPLREOM  EQU   RPLFDB3
RPLREOB  EQU   RPLFDB3
RPLSV32  EQU   RPLFDB3
RPLUINPT EQU   RPLFDB3
RPLSTSAV EQU   RPLFDB2
RPLCUERR EQU   RPLFDB2
RPLDLGFL EQU   RPLFDB2
RPLIOERR EQU   RPLFDB2
RPLDVUNS EQU   RPLFDB2
RPLATND  EQU   RPLFDB2
RPLRVID  EQU   RPLFDB2
RPLERLK  EQU   RPLFDB2
RPLSTAT  EQU   RPLFDBWD
RPLPOST  EQU   RPLECB
RPLWAIT  EQU   RPLECB
RPLLEN2  EQU   RPLLEN
RPLSTYP  EQU   RPLIDWD+1
RPLID    EQU   RPLIDWD
@NM00027 EQU   PSA+3668
PSASTAK  EQU   PSA+3072
@NM00026 EQU   PSA+1048
PSAUSEND EQU   PSA+1048
PSARV062 EQU   PSA+1044
PSACDAL  EQU   PSA+1040
PSAWTCOD EQU   PSA+1036
PSAATCVT EQU   PSA+1032
PSAPCPSW EQU   PSA+1024
PSAPIR2  EQU   PSA+1020
PSARV059 EQU   PSA+1018
PSASVC13 EQU   PSA+1016
PSALSFCC EQU   PSA+1012
PSASFACC EQU   PSA+1008
PSASTOP  EQU   PSA+992
PSASTART EQU   PSA+976
PSARSPSW EQU   PSA+968
PSASRPSW EQU   PSA+960
PSARV045 EQU   PSA+892
PSARV044 EQU   PSA+888
PSARV043 EQU   PSA+884
PSARV042 EQU   PSA+880
PSARV041 EQU   PSA+876
PSARV040 EQU   PSA+872
PSARV025 EQU   PSA+868
PSADSSED EQU   PSA+868
PSADSSPR EQU   PSA+864
PSADSSFW EQU   PSA+860
PSADSS14 EQU   PSA+856
PSADSSPP EQU   PSA+848
PSADSSRP EQU   PSA+840
PSADSS05 EQU   PSADSSF4
PSADSS10 EQU   PSADSSF4
PSADSSVE EQU   PSADSSF4
PSADSSDE EQU   PSADSSF4
PSADSSC0 EQU   PSADSSF4
PSADSSIE EQU   PSADSSF4
PSADSS12 EQU   PSADSSF4
PSADSSRC EQU   PSADSSF4
PSARV057 EQU   PSADSSF3
PSARV056 EQU   PSADSSF3
PSARV055 EQU   PSADSSF3
PSADSSMC EQU   PSADSSF3
PSADSSRW EQU   PSADSSF3
PSADSSNM EQU   PSADSSF3
PSADSSES EQU   PSADSSF3
PSADSSGP EQU   PSADSSF3
PSADSSF2 EQU   PSADSSFL+1
PSADSSPI EQU   PSADSSF1
PSADSSOI EQU   PSADSSF1
PSADSSSP EQU   PSADSSF1
PSADSSTP EQU   PSADSSF1
PSADSSDW EQU   PSADSSF1
PSADSSDD EQU   PSADSSF1
PSADSSDM EQU   PSADSSF1
PSADSSMV EQU   PSADSSF1
PSADSSTS EQU   PSA+816
PSADSSWK EQU   PSA+812
PSADSSR3 EQU   PSA+808
PSADSSR2 EQU   PSA+804
PSADSSRS EQU   PSA+800
PSASTOR  EQU   PSA+796
PSACPUSA EQU   PSA+794
PSAVSTAP EQU   PSA+792
PSAWKVAP EQU   PSA+788
PSAWKRAP EQU   PSA+784
PSAMCHIC EQU   PSA+783
PSARV061 EQU   PSA+782
PSASYMSK EQU   PSA+781
PSAMCHFL EQU   PSA+780
PSACR0   EQU   PSA+776
PSAPSWSV EQU   PSA+768
PSALITA  EQU   PSA+764
PSACLHS  EQU   PSAHLHI
PSALKR15 EQU   PSALKSA+60
PSALKR14 EQU   PSALKSA+56
PSALKR13 EQU   PSALKSA+52
PSALKR12 EQU   PSALKSA+48
PSALKR11 EQU   PSALKSA+44
PSALKR10 EQU   PSALKSA+40
PSALKR9  EQU   PSALKSA+36
PSALKR8  EQU   PSALKSA+32
PSALKR7  EQU   PSALKSA+28
PSALKR6  EQU   PSALKSA+24
PSALKR5  EQU   PSALKSA+20
PSALKR4  EQU   PSALKSA+16
PSALKR3  EQU   PSALKSA+12
PSALKR2  EQU   PSALKSA+8
PSALKR1  EQU   PSALKSA+4
PSALKR0  EQU   PSALKSA
PSARV023 EQU   PSACLHT+52
PSALOCAL EQU   PSACLHT+48
PSACMSL  EQU   PSACLHT+44
PSAOPTL  EQU   PSACLHT+40
PSATPACL EQU   PSACLHT+36
PSATPDNL EQU   PSACLHT+32
PSATPNCL EQU   PSACLHT+28
PSAIOSLL EQU   PSACLHT+24
PSAIOSUL EQU   PSACLHT+20
PSAIOSCL EQU   PSACLHT+16
PSAIOSSL EQU   PSACLHT+12
PSASALCL EQU   PSACLHT+8
PSAASML  EQU   PSACLHT+4
PSADISPL EQU   PSACLHT
PSASRSA  EQU   PSA+636
PSARV050 EQU   PSA+634
PSADSSGO EQU   PSA+633
PSARECUR EQU   PSA+632
PSAHLHIS EQU   PSA+628
PSAIPCSA EQU   PSA+624
@NM00025 EQU   PSA+621
PSAIPCDM EQU   PSA+620
PSAIPCD  EQU   PSA+616
@NM00024 EQU   PSA+613
PSAIPCRM EQU   PSA+612
PSAIPCR  EQU   PSA+608
PSAMCHEX EQU   PSA+600
PSAMPSW  EQU   PSA+592
PSAEXPS2 EQU   PSA+584
PSAEXPS1 EQU   PSA+576
PSAPIREG EQU   PSA+572
PSARSREG EQU   PSA+568
PSAGPREG EQU   PSA+556
PSARV022 EQU   PSASUP4
PSARV021 EQU   PSASUP4
PSARV020 EQU   PSASUP4
PSARV019 EQU   PSASUP4
PSARV018 EQU   PSASUP4
PSARV017 EQU   PSASUP4
PSARV016 EQU   PSASUP4
PSARV015 EQU   PSASUP4
PSARV014 EQU   PSASUP3
PSAULCMS EQU   PSASUP3
PSARV012 EQU   PSASUP3
PSAESTA  EQU   PSASUP3
PSASPR   EQU   PSASUP3
PSAPSREG EQU   PSASUP3
PSAPI2   EQU   PSASUP3
PSAIOSUP EQU   PSASUP3
PSALCR   EQU   PSASUP2
PSARTM   EQU   PSASUP2
PSAACR   EQU   PSASUP2
PSAIPCE2 EQU   PSASUP2
PSAIPCES EQU   PSASUP2
PSAIPCEC EQU   PSASUP2
PSAGTF   EQU   PSASUP2
PSAIPCRI EQU   PSASUP2
PSATYPE6 EQU   PSASUP1
PSATCTL  EQU   PSASUP1
PSADISP  EQU   PSASUP1
PSALOCK  EQU   PSASUP1
PSAPI    EQU   PSASUP1
PSAEXT   EQU   PSASUP1
PSASVC   EQU   PSASUP1
PSAIO    EQU   PSASUP1
PSAANEW  EQU   PSA+544
PSATOLD  EQU   PSA+540
PSATNEW  EQU   PSA+536
PSALCCAR EQU   PSA+532
PSALCCAV EQU   PSA+528
PSAPCCAR EQU   PSA+524
PSAPCCAV EQU   PSA+520
PSACPULA EQU   PSA+518
PSACPUPA EQU   PSA+516
PSAPSA   EQU   PSA+512
FLCHDEND EQU   PSA+512
FLCCRSAV EQU   FLCMCLA+280
FLCGRSAV EQU   FLCMCLA+216
FLCFPSAV EQU   FLCMCLA+184
FLCFLA   EQU   FLCMCLA+88
FLCRGNCD EQU   FLCMCLA+84
FLCFSAA  EQU   FLCFSA+1
@NM00023 EQU   FLCFSA
@NM00022 EQU   FLCMCLA+72
FLCMCIC  EQU   FLCMCLA+64
@NM00021 EQU   FLCMCLA+20
FLCIOAA  EQU   FLCIOA+1
@NM00020 EQU   FLCIOA
@NM00019 EQU   FLCMCLA+15
@NM00018 EQU   FLCMCLA+14
@NM00017 EQU   FLCMCLA+12
FLCLCL   EQU   FLCMCLA+8
FLCIOELA EQU   FLCIOEL+1
@NM00016 EQU   FLCIOEL
FLCCHNID EQU   FLCMCLA
@NM00015 EQU   PSA+160
FLCMTRCD EQU   PSA+157
@NM00014 EQU   PSA+156
FLCPERA  EQU   FLCPER+1
@NM00013 EQU   FLCPER
@NM00012 EQU   PSA+151
FLCPERCD EQU   PSA+150
FLCMCNUM EQU   PSA+149
@NM00011 EQU   PSA+148
FLCTEAA  EQU   FLCTEA+1
@NM00010 EQU   FLCTEA
PSAPIPC  EQU   PSAPICOD
PSAPIMC  EQU   PSAPICOD
PSAPIPER EQU   PSAPICOD
PSARV049 EQU   FLCPICOD
FLCPILCB EQU   FLCPIILC
@NM00009 EQU   FLCPIILC
@NM00008 EQU   PSAEPPSW
FLCSVCN  EQU   PSAESPSW+2
FLCSILCB EQU   FLCSVILC
@NM00007 EQU   FLCSVILC
@NM00006 EQU   PSAESPSW
FLCEICOD EQU   PSAEEPSW+2
PSASPAD  EQU   PSAEEPSW
@NM00005 EQU   PSA+128
FLCINPSW EQU   PSA+120
FLCMNPSW EQU   PSA+112
FLCPNPSW EQU   PSA+104
FLCSNPSW EQU   PSA+96
FLCENPSW EQU   PSA+88
FLCTRACE EQU   PSA+84
FLCTIMER EQU   PSA+80
FLCCVT2  EQU   PSA+76
FLCCAW   EQU   PSA+72
FLCCSW   EQU   PSA+64
FLCIOPSW EQU   PSA+56
FLCMOPSW EQU   PSA+48
FLCPOPSW EQU   PSA+40
FLCSOPSW EQU   PSA+32
FLCEOPSW EQU   PSA+24
@NM00004 EQU   FLCICCW2+4
FLCCVT   EQU   FLCICCW2
FLCICCW1 EQU   FLCROPSW
FLCIPPSW EQU   FLCRNPSW
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00177 EQU   PUT
@RC00187 EQU   CE0001@
@RC00192 EQU   CE0001@
@RC00202 EQU   CE0001@
@RF00207 EQU   CE0001@
@RF00225 EQU   CE0001@
@RC00234 EQU   CE0001@
@RT00259 EQU   INVRPL
@RT00295 EQU   INVACC
@RC00312 EQU   @RC00310
@RC00328 EQU   @RC00310
@RT00345 EQU   INVACC
@RF00351 EQU   @RC00349
@RF00453 EQU   CE0001@
@RT00481 EQU   NOPLHFND
@RT00487 EQU   INVACC2
@RT00511 EQU   POSTRPL2
@RC00489 EQU   @RC00474
@RF00533 EQU   @RC00474
@RT00561 EQU   INVACC2
@RC00578 EQU   CE0001@
@RC00589 EQU   CE0001@
NOPOST2  EQU   CE0001@
@RF00602 EQU   @EL00001
@RT00715 EQU   OLDPLH
@RF00780 EQU   @EL00005
@RF00826 EQU   @RC00814
BADPOST  EQU   @EL00008
@RC00314 EQU   @RC00312
@ENDDATA EQU   *
         END   IDA019R1,(C'PLS1750',0701,78209)
