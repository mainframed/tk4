         TITLE 'IDA019RM--VSAM DATA INSERT                             *
                        '
IDA019RM CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00001-@MAINENT)
         DC    AL1(16)                                             0001
         DC    C'IDA019RM  78.172'                                 0001
IDACHKKR DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL2(@EP00430-IDACHKKR)
         ENTRY IDACHKKR
         DROP  @15
@PROLOG  BALR  @11,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@11                                         0001
         AH    @15,4(,@15)                                         0001
         BR    @15                                                 0001
@EP00001 DS    0H                                                  0002
         IDASVR14
*   IF PLHARDB=ZERO THEN            /* IF NOT SET,           @X04SVMR*/
         L     @10,PLHARDB(,RPLH)                                  0156
         LTR   @10,@10                                             0156
         BNZ   @RF00156                                            0156
*     PLHARDB=AMDPARDB;             /* SET PLHARDB           @X04SVMR*/
         L     @10,AMBDSB(,RAMB)                                   0157
         L     @10,AMDPARDB(,@10)                                  0157
         ST    @10,PLHARDB(,RPLH)                                  0157
*   IF(AMBCREAT=ON×AMDDST='0'B)&    /* IF CREATE AND         @ZA02289*/
*       PLHLRECL>(AMDCINV-LENGTH(IDACIDF)-/* LAST RECORD     @ZA02289*/
*       LENGTH(IDARDF))&            /* SPANNED AND           @ZA02289*/
*       AMDRANGE=OFF THEN           /* NOT KEY RANGE         @ZA02289*/
@RF00156 TM    AMBCREAT(RAMB),B'10000000'                          0158
         BO    @GL00002                                            0158
         L     @10,AMBDSB(,RAMB)                                   0158
         TM    AMDDST(@10),B'10000000'                             0158
         BNZ   @RF00158                                            0158
@GL00002 L     @10,AMBDSB(,RAMB)                                   0158
         L     @15,AMDCINV(,@10)                                   0158
         SL    @15,@CF00289                                        0158
         C     @15,PLHLRECL(,RPLH)                                 0158
         BNL   @RF00158                                            0158
         TM    AMDRANGE(@10),B'00000100'                           0158
         BNZ   @RF00158                                            0158
*     DO;                           /* CALL CI INIT.         @ZA02289*/
*I01:                                                              0160
*       DO;                         /* IDACALL(IDA019SA)             */
I01      DS    0H                                                  0161
*         CALL IDA019SA;            /* EXIT TO IDA019SA              */
         L     @15,@CV00932                                        0161
         BALR  @14,@15                                             0161
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I01;                    /*                       @ZA02289*/
*       IF RPLERREG^=ZERO THEN      /* ERROR                 @ZA02289*/
         CLI   RPLERREG(RRPL),0                                    0167
         BE    @RF00167                                            0167
*         CALL EXIT;                /* YES, LEAVE            @ZA02289*/
         BAL   @14,EXIT                                            0168
*     END;                          /*                       @ZA02289*/
@RF00167 DS    0H                                                  0170
*DISTART:                           /* START OF DATA INSERT          */
*                                                                  0170
*   /*****************************************************************/
*   /*                                                               */
*   /* LOCATE ARDB AND PERFORM KEY RANGE VERIFICATION FOR KEY RANGE  */
*   /* DATA SET.                                                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0170
*   IF AMDRANGE=ON&PLHCIINS=OFF THEN/* KEY RANGE CHECK NEEDED        */
@RF00158 DS    0H                                                  0170
DISTART  L     @10,AMBDSB(,RAMB)                                   0170
         TM    AMDRANGE(@10),B'00000100'                           0170
         BNO   @RF00170                                            0170
         TM    PLHCIINS(RPLH),B'00000100'                          0170
         BNZ   @RF00170                                            0170
*     DO;                           /* YES.                          */
*       RWORK1=RPLAREA+AMDRKP;      /* POINT TO KEY                  */
         LH    RWORK1,AMDRKP(,@10)                                 0172
         AL    RWORK1,RPLAREA(,RRPL)                               0172
*       RWORK2=AMDKEYLN;            /* PICK UP KEY LENGTH            */
         LH    RWORK2,AMDKEYLN(,@10)                               0173
*       IF AMBCREAT=ON THEN         /* CREATE MODE                   */
         TM    AMBCREAT(RAMB),B'10000000'                          0174
         BNO   @RF00174                                            0174
*         DO;                       /* YES.                          */
*           RWORK3=PLHARDB;         /* CURRENT ARDB                  */
         L     RWORK3,PLHARDB(,RPLH)                               0176
*           IF RWORK1->KEY(1:RWORK2)</* NEW KEY LESS THAN            */
*               RWORK3->ARDKEYS(1:RWORK2) THEN/* ARDB LOW KEY        */
         LR    @10,RWORK2                                          0177
         BCTR  @10,0                                               0177
         EX    @10,@SC01005                                        0177
         BNL   @RF00177                                            0177
*             DO;                   /* YES. ERROR                    */
*KRERROR:                                                          0179
*               RPLERREG='08'X;     /* LOGICAL ERROR                 */
KRERROR  MVI   RPLERREG(RRPL),X'08'                                0179
*               RPLERRCD=RPLNOKR;   /* NO KEY RANGE FOR RECORD       */
         MVI   RPLERRCD(RRPL),X'24'                                0180
*               CALL EXIT;          /* RETURN                @ZA02289*/
         BAL   @14,EXIT                                            0181
*             END;                  /* END OF ERROR CODE             */
*           IF RWORK1->KEY(1:RWORK2)>/* NEW KEY GREATER THAN         */
*               RWORK3->ARDKEYS(RWORK2+1:2*RWORK2) THEN/* ARDB HIGH  */
@RF00177 LR    @10,RWORK2                                          0183
         ALR   @10,@10                                             0183
         SLR   @10,RWORK2                                          0183
         BCTR  @10,0                                               0183
         LR    @15,RWORK3                                          0183
         ALR   @15,RWORK2                                          0183
         EX    @10,@SC01007                                        0183
         BNH   @RF00183                                            0183
*             DO;                   /* YES.                          */
*               IF RWORK3->ARDNPTR=ZERO THEN/* LAST KEY RANGE        */
         L     @10,ARDNPTR(,RWORK3)                                0185
         LTR   @10,@10                                             0185
         BZ    @RT00185                                            0185
*                 GO TO KRERROR;    /* YES. ERROR                    */
*               PLHKRE=ON;          /* INDICATE ENY OF KEY R.        */
         OI    PLHKRE(RPLH),B'00001000'                            0187
*               PLHKEY(1:RWORK2)=RWORK3->/* PUT END OF KEY RANGE     */
*                   ARDKEYS(RWORK2+1:2*RWORK2);/* VALUE IN PLHKEY    */
         L     @10,PLHKEYPT(,RPLH)                                 0188
         LR    @15,RWORK2                                          0188
         BCTR  @15,0                                               0188
         LR    @14,RWORK3                                          0188
         ALR   @14,RWORK2                                          0188
         EX    @15,@SM01009                                        0188
*               IF PLHLRECL^>(AMDCINV-/* WAS LAST RECD       @ZA02289*/
*                   LENGTH(IDACIDF)-/* A SPANNED             @ZA02289*/
*                   LENGTH(IDARDF)) THEN/* RECORD            @ZA02289*/
         L     @10,AMBDSB(,RAMB)                                   0189
         L     @10,AMDCINV(,@10)                                   0189
         SL    @10,@CF00289                                        0189
         C     @10,PLHLRECL(,RPLH)                                 0189
         BNL   @RT00189                                            0189
*                 GO TO CIFULL;     /* NO, NEW CI NEEDED             */
*             END;                  /* END OF NEW KEY RANGE          */
*           IF PLHLRECL>(AMDCINV-   /* IF LAST RECORD        @ZA02289*/
*               LENGTH(IDACIDF)-    /* WAS A SPANNED         @ZA02289*/
*               LENGTH(IDARDF)) THEN/* RECORD                @ZA02289*/
@RF00183 L     @10,AMBDSB(,RAMB)                                   0192
         L     @10,AMDCINV(,@10)                                   0192
         SL    @10,@CF00289                                        0192
         C     @10,PLHLRECL(,RPLH)                                 0192
         BNL   @RF00192                                            0192
*             DO;                   /* THEN                  @ZA02289*/
*I02:                                                              0194
*               DO;                 /* IDACALL(IDA019SA)             */
I02      DS    0H                                                  0195
*                 CALL IDA019SA;    /* EXIT TO IDA019SA              */
         L     @15,@CV00932                                        0195
         BALR  @14,@15                                             0195
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I02;            /* CALL CI INIT.         @ZA02289*/
*               PLHKRE=OFF;         /* ASSURE KR OFF         @ZA02289*/
         NI    PLHKRE(RPLH),B'11110111'                            0201
*               IF RPLERREG^=ZERO THEN/* ERROR               @ZA02289*/
         CLI   RPLERREG(RRPL),0                                    0202
         BE    @RF00202                                            0202
*                 CALL EXIT;        /* YES, GET OUT          @ZA02289*/
         BAL   @14,EXIT                                            0203
*             END;                  /*                       @ZA02289*/
*         END;                      /* END OF CREATE TESTING         */
*       ELSE                        /* NON-CREATE MODE               */
*         CALL IDACHKKR;            /* GO CHECK KEY RANGE            */
         B     @RC00174                                            0206
@RF00174 L     @15,@CA00969                                        0206
         BALR  @14,@15                                             0206
*     END;                          /* END OF KEY RANGE TEST         */
@RC00174 DS    0H                                                  0208
*   RWORK1=RPLRLEN;                 /* PICK UP RECORD LENGTH         */
@RF00170 L     RWORK1,RPLRLEN(,RRPL)                               0208
*   RWORK2=PLHDBUFC->BUFCBAD+AMDCINV/* LOCATE CIDF                   */
*       -LENGTH(IDACIDF);           /*                               */
         L     @10,PLHDBUFC(,RPLH)                                 0209
         L     @15,AMBDSB(,RAMB)                                   0209
         L     RWORK2,BUFCBAD(,@10)                                0209
         AL    RWORK2,AMDCINV(,@15)                                0209
         SL    RWORK2,@CF00069                                     0209
*   PLHSAVE6=RWORK2;                /* SAVE PTR TO CIDF              */
         ST    RWORK2,PLHSAVE6(,RPLH)                              0210
*   RWORK0=RWORK2->CIDFLL;          /* PICK UP FREE SPACE LTH        */
         LH    RWORK0,CIDFLL(,RWORK2)                              0211
*   RESPECIFY                                                      0212
*     IDAARDB BASED(PLHARDB);                                      0212
*   IF PLHCIINS=OFF THEN            /* CALLED BY CI SPLIT            */
         TM    PLHCIINS(RPLH),B'00000100'                          0213
         BNZ   @RF00213                                            0213
*     DO;                           /* NO.                           */
*       IF(AMDDST='0'B×             /* END OF DATA?          @X04SVMR*/
*           (PLHRECP=PLHFSP&BUFXIRBA=ARDHKRBA)) THEN/* YES.  @X04SVMR*/
         TM    AMDDST(@15),B'10000000'                             0215
         BZ    @RT00215                                            0215
         CLC   PLHRECP(4,RPLH),PLHFSP(RPLH)                        0215
         BNE   @RF00215                                            0215
         L     @15,PLHARDB(,RPLH)                                  0215
         CLC   BUFXIRBA(4,@10),ARDHKRBA(@15)                       0215
         BNE   @RF00215                                            0215
@RT00215 DS    0H                                                  0216
*         PLHADDTE=ON;              /* SET ADD TO END FLAG           */
         OI    PLHADDTE(RPLH),B'00010000'                          0216
*       ELSE                        /*                               */
*         PLHADDTE=OFF;             /* RESET ADD TO END              */
         B     @RC00215                                            0217
@RF00215 NI    PLHADDTE(RPLH),B'11101111'                          0217
*       IF RWORK1>AMDCINV-(LENGTH(IDACIDF)/* IS RECORD A     @ZA02289*/
*           +LENGTH(IDARDF)) THEN   /* SPANNED RECORD        @ZA02289*/
@RC00215 L     @10,AMBDSB(,RAMB)                                   0218
         L     @10,AMDCINV(,@10)                                   0218
         SL    @10,@CF00289                                        0218
         CR    RWORK1,@10                                          0218
         BNH   @RF00218                                            0218
*         DO;                       /* YES, CALL RT          @ZA02289*/
*I03:                                                              0220
*           DO;                     /* IDACALL(IDA019RT)             */
I03      DS    0H                                                  0221
*             CALL IDA019RT;        /* EXIT TO IDA019RT              */
         L     @15,@CV00930                                        0221
         BALR  @14,@15                                             0221
*             GEN(BALR @11,0);      /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*             GEN(USING *,@11);     /* ESTABLISH ADDRESSING          */
         USING *,@11
*             GEN(L     @11,=A(@PSTART));/* RELOAD BASE              */
         L     @11,=A(@PSTART)
*             GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING         */
         USING @PSTART,@11
*           END I03;                /*                       @ZA02289*/
*           CALL EXIT;              /* RETURN                @ZA02289*/
         BAL   @14,EXIT                                            0227
*         END;                      /*                       @ZA02289*/
*       IF RWORK2->CIDFOSET^=ZERO THEN/* INSERT TO EMPTY CI          */
@RF00218 LH    @10,CIDFOSET(,RWORK2)                               0229
         LTR   @10,@10                                             0229
         BZ    @RF00229                                            0229
*         DO;                       /*                               */
*           IF RPLSEQ=ON&           /* SEQ REQ AND           @X04SVMR*/
*               RPLUPD=OFF&         /* INSERT AND            @X04SVMR*/
*               PLHRECP=PLHFSP THEN /* AT END OF CI,         @X04SVMR*/
         TM    RPLSEQ(RRPL),B'00100000'                            0231
         BNO   @RF00231                                            0231
         TM    RPLUPD(RRPL),B'00000010'                            0231
         BNZ   @RF00231                                            0231
         CLC   PLHRECP(4,RPLH),PLHFSP(RPLH)                        0231
         BNE   @RF00231                                            0231
*             RWORK1=RWORK1+AMDFSCI;/* ADD FREE SPACE                */
         L     @10,AMBDSB(,RAMB)                                   0232
         AL    RWORK1,AMDFSCI(,@10)                                0232
*         END;                      /* END OF NON-EMPTY TEST         */
@RF00231 DS    0H                                                  0234
*     END;                          /* END NOT CI SPLIT CALL         */
@RF00229 DS    0H                                                  0235
*   IF RWORK1>RWORK0×               /* IF RECORD TOO BIG     @ZA18985*/
*       PLHRDFP->RDFNOT1=ON×        /* OR SPANNED            @ZA18985*/
*       PLHRDFP->RDF1ST=ON THEN     /* RECORD SEGMENT        @ZA18985*/
@RF00213 CLR   RWORK1,RWORK0                                       0235
         BH    @RT00235                                            0235
         L     @10,PLHRDFP(,RPLH)                                  0235
         TM    RDFNOT1(@10),B'00110000'                            0235
         BNZ   @RT00235                                            0235
*     GO TO CIFULL;                 /* NO ROOM OR S.R.       @ZA05900*/
*   ELSE                            /* THERE IS ENOUGH SPACE @ZA14788*/
*     PLHSAVE1=RWORK0-RWORK1;       /* ROOM FOR RDF          @ZA19548*/
         LR    @10,RWORK0                                          0237
         SLR   @10,RWORK1                                          0237
         ST    @10,PLHSAVE1(,RPLH)                                 0237
*   IF BUFCMW=ON THEN               /* MUST WRITE ON         @ZA19548*/
         L     @10,PLHDBUFC(,RPLH)                                 0238
         TM    BUFCMW(@10),B'10000000'                             0238
         BNO   @RF00238                                            0238
*     RWORK3=BUFCORBA;              /* USE OUTPUT RBA        @ZA19548*/
         L     RWORK3,BUFCORBA(,@10)                               0239
*   ELSE                            /* NO                    @ZA19548*/
*     RWORK3=BUFCDDDD;              /* USE INPUT RBA         @ZA19548*/
         B     @RC00238                                            0240
@RF00238 L     @10,PLHDBUFC(,RPLH)                                 0240
         L     RWORK3,BUFCDDDD(,@10)                               0240
*   RPLDDDD=RWORK3+(PLHRECP-BUFCBAD);/* SET RECORD RBA       @ZA19548*/
@RC00238 L     @10,PLHDBUFC(,RPLH)                                 0241
         L     @15,PLHRECP(,RPLH)                                  0241
         SL    @15,BUFCBAD(,@10)                                   0241
         ALR   @15,RWORK3                                          0241
         ST    @15,RPLDDDD(,RRPL)                                  0241
*   IF AMBUPX=ON&                   /* IF UPGRADE AND        @ZA19548*/
*       AMDDST='0'B THEN            /* ESDS AND              @ZA19548*/
         TM    AMBUPX(RAMB),B'00000010'                            0242
         BNO   @RF00242                                            0242
         L     @10,AMBDSB(,RAMB)                                   0242
         TM    AMDDST(@10),B'10000000'                             0242
         BNZ   @RF00242                                            0242
*     DO;                           /*                       @ZA19548*/
*                                                                  0243
*       /*************************************************************/
*       /*                                                           */
*       /* IF UPGRADE OF ESDS THEN ENSURE ROOM FOR RDF               */
*       /*                                                           */
*       /*************************************************************/
*                                                                  0244
*       IF PLHSAVE1<LENGTH(IDARDF) THEN/* NO ROOM FOR MAXIMUM RDFS   */
         LA    @10,3                                               0244
         C     @10,PLHSAVE1(,RPLH)                                 0244
         BNH   @RF00244                                            0244
*         DO;                                                      0245
*                                                                  0245
*           /*********************************************************/
*           /*                                                       */
*           /* IF THERE IS NOT ROOM FOR 1 RDF THEN FOR RECORD TO FIT */
*           /* THE LAST RECORDS IN THE CI MUST BE REPEATED AND THE   */
*           /* SAME LENGTH AS THE RECORD TO BE INSERTED.             */
*           /*                                                       */
*           /*********************************************************/
*                                                                  0246
*           RWORK3=RWORK0+RWORK2->CIDFOSET;/* PT LAST RDF    @ZA19548*/
         LR    RWORK3,RWORK0                                       0246
         LH    @15,CIDFOSET(,RWORK2)                               0246
         ALR   RWORK3,@15                                          0246
*           IF RWORK3->RDFREPL=OFF× /* IF NO REPEATS         @ZA19548*/
*               (RWORK3+LENGTH(IDARDF))->RDFLL^=RPLRLEN THEN/* NEW 0247
*                                      RECORD NOT EQUAL      @ZA19548*/
         TM    RDFREPL(RWORK3),B'00001000'                         0247
         BZ    @RT00247                                            0247
         ALR   @10,RWORK3                                          0247
         SLR   @15,@15                                             0247
         ICM   @15,3,RDFLL(@10)                                    0247
         C     @15,RPLRLEN(,RRPL)                                  0247
         BNE   @RT00247                                            0247
*             GOTO CIFULL;          /* SPLIT CI NOW          @ZA19548*/
*         END;                      /*                       @ZA19548*/
*                                                                  0249
*       /*************************************************************/
*       /*                                                           */
*       /* UPGRADE ANY ALTERNATE INDEX THAT MAY EXIST BEFORE DOING   */
*       /* THE INSERT OF THE RECORD INTO A BASE ESDS. (KSDS UPGRADE  */
*       /* IS CALLED BY IDA019R4.)                           @ZA19548*/
*       /*                                                           */
*       /*************************************************************/
*                                                                  0250
*I04:                                                              0250
*       DO;                         /* IDACALL(IDA019RU)             */
@RF00244 DS    0H                                                  0250
I04      DS    0H                                                  0251
*         CALL IDA019RU;            /* EXIT TO IDA019RU              */
         L     @15,@CV00931                                        0251
         BALR  @14,@15                                             0251
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I04;                    /* DO THE UPGRADE.       @ZA19548*/
*                                                                  0256
*       /*************************************************************/
*       /*                                                           */
*       /* RESTORE REGISTERS TO BUILD RDF                    @ZA19548*/
*       /*                                                           */
*       /*************************************************************/
*                                                                  0257
*       RWORK2=PLHSAVE6;            /* RESTORE CIDF PTR      @ZA19548*/
         L     RWORK2,PLHSAVE6(,RPLH)                              0257
*       RWORK0=RWORK2->CIDFLL;      /* RESTORE FREE SPACE    @ZA19548*/
         LH    RWORK0,CIDFLL(,RWORK2)                              0258
*       IF RPLERREG^=ZERO THEN      /* IF ERROR              @ZA19548*/
         CLI   RPLERREG(RRPL),0                                    0259
         BE    @RF00259                                            0259
*         DO;                       /*                       @ZA19548*/
*           IF RWORK2->CIDFOSET=0&  /* INSERT BEGINNING      @ZA19548*/
*               ARDHRBA=RPLDDDD+AMDCINV THEN/* IF ADDING NEW         */
         LH    @10,CIDFOSET(,RWORK2)                               0261
         LTR   @10,@10                                             0261
         BNZ   @RF00261                                            0261
         L     @10,PLHARDB(,RPLH)                                  0261
         L     @15,ARDHRBA(,@10)                                   0261
         L     @14,AMBDSB(,RAMB)                                   0261
         L     @14,AMDCINV(,@14)                                   0261
         L     @09,RPLDDDD(,RRPL)                                  0261
         ALR   @09,@14                                             0261
         CLR   @15,@09                                             0261
         BNE   @RF00261                                            0261
*             DO;                   /* CI AT END OF ESDS     @ZA19548*/
*               ARDHRBA=ARDHRBA-AMDCINV;/* BACK UP EOD       @ZA19548*/
         SLR   @15,@14                                             0263
         ST    @15,ARDHRBA(,@10)                                   0263
*               BUFCMW=OFF;         /* FORCE NO WRITE        @ZA19548*/
         L     @10,PLHDBUFC(,RPLH)                                 0264
         NI    BUFCMW(@10),B'01111111'                             0264
*               BUFCVAL=OFF;        /* BUFFER IS INVALID     @ZA19548*/
         NI    BUFCVAL(@10),B'11111011'                            0265
*             END;                  /*                       @ZA19548*/
*           CALL EXIT;              /* EXIT MODULE.          @ZA19548*/
@RF00261 BAL   @14,EXIT                                            0267
*         END;                      /*                       @ZA19548*/
*     END;                          /*                       @ZA19548*/
@RF00259 DS    0H                                                  0270
*   RESPECIFY                                                      0270
*    (RWORK4,                                                      0270
*     RWORK5,                                                      0270
*     R10,                                                         0270
*     R14,                                                         0270
*     R15) RSTD;                                                   0270
@RF00242 DS    0H                                                  0271
*   GEN REFS(PLHRDFP,PLHSAVE2,PLHRDFC,RDFRBYTE);                   0271
*
*        BUILD RDF PROCESSING
*
C1       EQU   1                            CONSTANT 1
TWO      EQU   2                            CONSTANT 2
D0       EQU   0                            CONSTANT 0
C3       EQU   3                            CONSTANT 3
C4       EQU   4                            CONSTANT 4
C7       EQU   7                            CONSTANT 7
         L     RWORK1,RPLRLEN(,RRPL)        PICK UP NEW RECORD LENGTH
         SR    R15,R15                      CLEAR REGISTER
*  RWORK2 CONTAINS POINTER TO CIDF
*  RWORK0 CONTAINS CIDFLL VALUE
         L     RWORK4,PLHDBUFC(,RPLH)       POINT TO BUFC
         A     RWORK0,BUFCBAD(,RWORK4)      ADD BUF START TO LL
         AH    RWORK0,CIDFOSET(,RWORK2)     LOCATION OF LAST RDF
*  RWORK0 NOW CONTAINS POINTER TO LAST RDF
         CLC   PLHRECP(C4,RPLH),PLHFSP(RPLH) INSERT TO END OF CI
         BNE   BLD00050                     NO.
         SR    RPARM1,RPARM1                OFFSET TO PREVIOUS RDF
         LR    R10,RWORK0                   SET LAST RDF PTR IN R10
         ST    R10,PLHRDFP(,RPLH)           PUT PTR IN PLH
         B     BLD00215                     GO TEST FOR BEGINNING INSRT
BLD00050 L     R10,PLHRDFP(,RPLH)           LOAD PTR TO CURRENT RDF
         TM    RDFRBYTE(R10),RDFREPLA       CURRENT RDF A GROUP
         BNO   BLD00200                     NO.
         ICM   R15,C3,RDFLEN+RDFLLOFF(R10)  GET LL FROM COMPLEX RDF
         CR    RWORK1,R15                   NEW RECORD LTH =
         BNE   BLD00100                     NO.
         ICM   R15,C3,RDFLLOFF(R10)         INCREMENT
         LA    R15,C1(,R15)                 COUNT
         STCM  R15,C3,RDFLLOFF(R10)         BY 1.
         B     BLDEXIT                      EXIT
BLD00100 CLC   PLHRDFC(TWO,RPLH),RDFLLOFF(R10) POSITIONED BEFORE GROUP
         BNE   BLD00110                     NO.
         LA    RPARM1,TWO*RDFLEN            OFFSET TO PREVIOUS RDF
         B     BLD00215                     GO TEST FOR BEGINNING INSRT
BLD00110 CLC   RDFLLOFF(TWO,R10),=H'2'      IS THIS A 2 RECORD GROUP
         BNE   BLD00120                     NO.
         LA    RPARM1,RDFLEN                ASK FOR RDFLEN BYTES
         BAL   R14,GETRDFSP                 GET RDF SPACE
         NI    TWO*RDFLEN(R10),RDFCTNUX     RESET COMPLEX RDF INDICATOR
         ICM   R15,C7,TWO*RDFLEN(R10)       COPY
         STCM  R15,C7,D0(R10)               RDF
         B     BLD00150                     GO BUILD RDF FOR INSERT
BLD00120 ICM   R15,C3,RDFLLOFF(R10)         PICK UP GROUP COUNT
         BCTR  R15,D0                       REDUCE BY ONE
         CH    R15,PLHRDFC(,RPLH)           POSITIONED 1 REC. FROM END
         BNE   BLD00130                     NO.
*              ONE RECORD MUST BE REMOVED FROM THE GROUP RDF.
*              THE INSERT RECORD RDF WILL BE PLACED BETWEEN THE
*              REMAINING GROUP RDF AND THE SINGLE RECORD RDF.
         LA    RPARM1,TWO*RDFLEN            ASK FOR 2*RDFLEN BYTES
         BAL   R14,GETRDFSP                 GET RDF SPACE
         MVC   D0(TWO*RDFLEN,R10),TWO*RDFLEN(R10) COPY RDF
         STCM  R15,C3,RDFLLOFF(R10)         SET COUNT=OLD COUNT - 1
         NI    C3*RDFLEN(R10),RDFCTNUX      RESET COMPLEX RDF INDICATOR
         B     BLD00150                     GO BUILD RDF FOR INSERT
BLD00130 LA    RPARM1,C1                    SEE IF PTR IS 1 RECORD
         CH    RPARM1,PLHRDFC(,RPLH)        FROM END OF GROUP
         BNE   BLD00140                     NO.
*              SIMILAR TO PREVIOUS CASE. ONE RECORD MUST BE REMOVED
*              FROM THE GROUP RDF. IN THIS CASE THE SINGLE RECORD RDF
*              AND FOLLOWING RDF FOR INSERT RECORD WILL PRECEDE THE
*              REMAINING GROUP RDF.
*              R15  CONTAINS THE GROUP COUNT NEW VALUE.
         LA    RPARM1,TWO*RDFLEN            ASK FOR 2*RDFLEN BYTES
         BAL   R14,GETRDFSP                 GET RDF SPACE
         STCM  R15,C3,TWO*RDFLEN+RDFLLOFF(R10) STORE DECREMENTED COUNT
         ICM   R15,C7,C3*RDFLEN(R10)        PICK UP RDF WITH LL
         STCM  R15,C7,D0(R10)               STORE AS SINGLE RECORD RDF
         NI    D0(R10),RDFCTNUX             RESET COMPLEX RDF INDICATOR
         LA    RPARM1,RDFLEN                SET OFFSET FOR NEW RDF
         B     BLD00150                     GO BUILD RDF FOR INSERT
BLD00140 DS    0H
*        THE GROUP RDF MUST BE SPLIT INTO TWO GROUP RDFS AND
*              THE INSERT RECORD RDF PLACED BETWEEN THE TWO.
         LA    RPARM1,C3*RDFLEN             ASK FOR 3*RDFLEN BYTES
         BAL   R14,GETRDFSP                 GET RDF SPACE
         MVC   D0(TWO*RDFLEN,R10),C3*RDFLEN(R10) COPY RDF
         LH    RPARM1,PLHRDFC(,RPLH)        PICK UP PLH COUNT
         ICM   R15,C3,RDFLLOFF(R10)         PICK UP GROUP COUNT
         SR    R15,RPARM1                   COUNT VALUE FOR LEFT RDF
         STCM  RPARM1,C3,RDFLLOFF(R10)      = PLHRDFC
         STCM  R15,C3,C3*RDFLEN+RDFLLOFF(R10) SET RIGHT RDF COUNT
         LA    RPARM1,TWO*RDFLEN            OFFSET FOR INSERT REC. RDF
BLD00150 DS    0H
*              BUILD SINGLE RECORD RDF FOR INSERT RECORD.
*              RPARM1 CONTAINS OFFSET TO BE ADDED TO R10 TO
*              LOCATE POSITION AT WHICH RDF WILL BE PLACED.
         AR    R10,RPARM1                   INSERT RDF POSITION
         MVI   RDFRBYTE(R10),RDFSGLR        SET SINGLE RECORD R-BYTE
         STCM  RWORK1,C3,RDFLLOFF(R10)      SET INSERT REC. LENGTH
         B     BLDEXIT                      FINISHED
BLD00200 DS    0H
*              INSERT IS NOT TO THE END OF CONTROL INTERVAL AND
*              RDF OF RECORD FOLLOWING INSERT IS NOT A GROUP RDF
         ICM   R15,C3,RDFLLOFF(R10)         PICK UP LL OF NEXT RECORD
         CR    R15,RWORK1                   LL SAME AS INSERT REC. LL
         BNE   BLD00210                     NO.
BLD00205 LA    RPARM1,RDFLEN                ASK FOR RDFLEN BYTES
         BAL   R14,GETRDFSP                 GET RDF SPACE
         OI    RDFLEN+RDFRBYTE(R10),RDFCTNUA SET COMPLEX RDF FLAG
         MVI   RDFRBYTE(R10),RDFCNT         SET COUNT R-BYTE
         LA    R15,TWO                      COUNT VALUE = 2
         STCM  R15,C3,RDFLLOFF(R10)         SET VALUE IN RDF
         B     BLDEXIT                      EXIT
BLD00210 DS    0H
*              NEW RECORD LENGTH IS NOT EQUAL TO LENGTH
*              OF NEXT RECORD IN CONTROL INTERVAL.
         LA    RPARM1,RDFLEN                OFFSET TO PREVIOUS RDF
BLD00215 AR    R10,RPARM1                   POINT TO PREVIOUS RDF
         L     RWORK4,PLHDBUFC(,RPLH)       PTR TO DATA BUFC
         L     RWORK4,BUFCBAD(,RWORK4)      PTR TO BUFFER
         C     RWORK4,PLHRECP(,RPLH)        INSERT PTR = START OF BUF
         BE    BLD00230                     YES.
*              INSERT IS NOT OT BEGINNING OF CONTROL INTERVAL.
*              COMPARE INSERT RECORD LL WITH PREVIOUS RECORD LL.
         TM    RDFRBYTE(R10),RDFREPLA       PREVIOUS RDF A COUNT
         BNO   BLD00220                     NO.
         ICM   R15,C3,RDFLEN+RDFLLOFF(R10)  PICK UP LL OF GROUP
         CR    RWORK1,R15                   NEW RECORD LL = GROUP LL
         BNE   BLD00230                     NO.
*              NEW RECORD LENGTH IS = TO LENGTH OF PREVIOUS RECORD IN
*              CONTROL INTERVAL. PREVIOUS RECORD IS 1ST OF A GROUP.
*              NEED ONLY INCREMENT GROUP COUNT BY 1.
         ICM   R15,C3,RDFLLOFF(R10)         PICK UP GROUP COUNT
         LA    R15,C1(,R15)                 ADD1
         STCM  R15,C3,RDFLLOFF(R10)         STORE NEW COUNT
         B     BLDEXIT                      EXIT
BLD00220 ICM   R15,C3,RDFLLOFF(R10)         PICK UP PREVIOUS RECORD LL
         CR    RWORK1,R15                   NEW RECORD LL = PREVIOUS LL
         BE BLD00205                        YES.
BLD00230 DS    0H
*              A SINGLE RECORD RDF MUST BE BUILD FOR THE
*              INSERT RECORD.
         LA    RPARM1,RDFLEN                ASK FOR RDFLEN BYTES
         BAL   R14,GETRDFSP                 GET RDF SPACE
         MVI   RDFRBYTE(R10),RDFSGLR        SET SINGLE RECORD R-BYTE
         STCM  RWORK1,C3,RDFLLOFF(R10)      SET NEW RECORD LL
         B     BLDEXIT                      EXIT
*              GETRDFSP SUBROUTINE
*        INPUT -
*              REG  R10 -POINTER TO RDF, RDFS TO THE LEFT OF THE
*                        PTR ARE TO BE MOVED LEFT TO PROVIDE
*                        REQUESTED SPACE.
*              REG  RPARM1 - NUMBER OF BYTES REQUESTED
*              REG  RWORK2 - POINTER TO CIDF
*              PLHSAVE1 - NUMBER OF BYTES AVAILABLE IN CI FOR RDFS
*        OUTPUT -
*              REG  R10 -POINTER TO RDF SPACE OBTAINED
*              PLHRDFP  -SET = R10 OUTPUT VALUE
*              CIDFLL   -DECREMENED BY NUMBER OF BYTES REQUESTED
*        WORK REGISTERS - RWORK3,RWORK4,RWORK5
*        ALL OTHER REGISTERS REMAIN SAME AS ON ENTRY.
*         EXITS- BR R14 IF SPACE AVAILABLE
*              - B  CIFULL IF SPACE NOT AVAILABLE
*
GETRDFSP DS    0H
         C     RPARM1,PLHSAVE1(,RPLH)
         BH    CIFULL                       CI IS FULL
         LR    RWORK4,RWORK0                POINT RWORK4 TO LAST RDF
         LR    RWORK5,R10                   COPY CURRENT RDF PTR
         SR    RWORK5,RWORK4                NUMBER OF BYTES TO MOVE
         LH    RWORK3,CIDFLL(,RWORK2)       CURRENT CIDFLL
         SR    RWORK3,RPARM1                REDUCE BY REQUEST AMOUNT
         STH   RWORK3,CIDFLL(,RWORK2)       STORE NEW CIDFLL VALUE
         ST    RWORK2,PLHSAVE2(,RPLH)       SAVE PTR TO CIDF
         LR    RWORK2,RWORK4                COPY PTR TO LAST RDF
         SR    RWORK2,RPARM1                BACKUP BY REQUEST AMOUNT
         LR    RWORK3,RWORK5                COPY MOVE LENGTH
         MVCL  RWORK2,RWORK4                MOVE RDFS LEFT
         L     RWORK2,PLHSAVE2(,RPLH)       RESTORE PTR TO CIDF
         SR    R10,RPARM1                   BACKUP R10
         L     RWORK3,PLHRDFP(,RPLH)        PICK UP RDF PTR
         SR    RWORK3,RPARM1                BACKUP BY REQUEST AMOUNT
         ST    RWORK3,PLHRDFP(,RPLH)        SET NEW VALUE IN PLH
         BR    R14                          RETURN
BLDEXIT  DS    0H
*   RESPECIFY                                                      0272
*    (RWORK4,                                                      0272
*     RWORK5,                                                      0272
*     R10,                                                         0272
*     R14,                                                         0272
*     R15) UNRSTD;                                                 0272
*                                                                  0273
*   /*****************************************************************/
*   /*                                                               */
*   /* MOVE DATA TO RIGHT WITHIN CONTROL INTERVAL TO FORM SPACE FOR  */
*   /* INSERT.                                                       */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0273
*   IF PLHFSP^=PLHRECP THEN         /* ANY DATA TO MOVE              */
         L     @10,PLHFSP(,RPLH)                                   0273
         L     @15,PLHRECP(,RPLH)                                  0273
         CR    @10,@15                                             0273
         BE    @RF00273                                            0273
*     DO;                           /* YES.                          */
*       RWORK0=RPLRLEN;             /* INSERT LENGTH                 */
         L     RWORK0,RPLRLEN(,RRPL)                               0275
*       RBUFC=PLHFSP;               /* SET TO PTR                    */
         LR    RBUFC,@10                                           0276
*       RPARM1=RBUFC-PLHRECP;       /* TOTAL AMOUNT TO MOVE          */
         LCR   @15,@15                                             0277
         ALR   @15,RBUFC                                           0277
         LR    RPARM1,@15                                          0277
*PARTMOVE:                                                         0278
*       DO WHILE RPARM1=>RWORK0;    /* MOVE PARTS                    */
PARTMOVE B     @DE00278                                            0278
@DL00278 DS    0H                                                  0279
*         RWORK2=RBUFC-RWORK0;      /* SET FROM PTR                  */
         LR    RWORK2,RBUFC                                        0279
         SLR   RWORK2,RWORK0                                       0279
*         PLHSAVE1=RWORK2;          /* SAVE FROM PTR                 */
         ST    RWORK2,PLHSAVE1(,RPLH)                              0280
*         RWORK1=RWORK0;            /* MVCL LENGTH                   */
         LR    RWORK1,RWORK0                                       0281
*         RWORK3=RWORK0;            /* COPY LENGTH                   */
         LR    RWORK3,RWORK0                                       0282
*         GEN(MVCL RBUFC,RWORK2);   /* MOVE DATA RIGHT               */
         MVCL RBUFC,RWORK2
*         RBUFC=PLHSAVE1;           /* NEXT TO PTR                   */
         L     RBUFC,PLHSAVE1(,RPLH)                               0284
*         RPARM1=RPARM1-RWORK0;     /* AMOUNT LEFT TO MOVE           */
         SLR   RPARM1,RWORK0                                       0285
*       END PARTMOVE;               /* END OF MOVE PARTS             */
@DE00278 CLR   RPARM1,RWORK0                                       0286
         BNL   @DL00278                                            0286
*       RWORK2=PLHRECP;             /* SET FROM PTR                  */
         L     RWORK2,PLHRECP(,RPLH)                               0287
*       RBUFC=RWORK2+RWORK0;        /* SET TO PTR                    */
         LR    RBUFC,RWORK2                                        0288
         ALR   RBUFC,RWORK0                                        0288
*       RWORK1=RPARM1;              /* MVCL LENGTH                   */
         LR    RWORK1,RPARM1                                       0289
*       RWORK3=RPARM1;              /* COPY LENGTH                   */
         LR    RWORK3,RPARM1                                       0290
*       GEN(MVCL RBUFC,RWORK2);     /* MOVE LAST PART                */
         MVCL RBUFC,RWORK2
*     END;                          /* END OF MOVE RIGHT             */
*                                                                  0292
*   /*****************************************************************/
*   /*                                                               */
*   /* MOVE NEW RECORD INTO BUFFER                                   */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0293
*   RWORK1=RPLRLEN;                 /* NEW RECORD LENGTH             */
@RF00273 L     RWORK1,RPLRLEN(,RRPL)                               0293
*   RWORK3=RWORK1;                  /* COPY FOR MVCL                 */
         LR    RWORK3,RWORK1                                       0294
*   RBUFC=PLHRECP;                  /* MVCL TO PTR                   */
         L     RBUFC,PLHRECP(,RPLH)                                0295
*   RWORK2=RPLAREA;                 /* MVCL FROM PTR                 */
         L     RWORK2,RPLAREA(,RRPL)                               0296
*   GEN(MVCL RBUFC,RWORK2);         /* MVCL RECORD TO BUFFER         */
*                                                                  0297
         MVCL RBUFC,RWORK2
*   /*****************************************************************/
*   /*                                                               */
*   /* ADJUST CIDF TO REFLECT INSERTED RECORD                        */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0298
*   RWORK1=RPLRLEN;                 /* RE-LOAD RECORD LENGTH         */
         L     RWORK1,RPLRLEN(,RRPL)                               0298
*   RWORK2=PLHSAVE6;                /* RESTORE PTR TO CIDF           */
         L     RWORK2,PLHSAVE6(,RPLH)                              0299
*   RWORK2->CIDFOSET=RWORK2->CIDFOSET+RWORK1;                      0300
         LR    @10,RWORK1                                          0300
         AH    @10,CIDFOSET(,RWORK2)                               0300
         STH   @10,CIDFOSET(,RWORK2)                               0300
*   RWORK2->CIDFLL=RWORK2->CIDFLL-RWORK1;                          0301
*                                                                  0301
         LH    @10,CIDFLL(,RWORK2)                                 0301
         SLR   @10,RWORK1                                          0301
         STH   @10,CIDFLL(,RWORK2)                                 0301
*   /*****************************************************************/
*   /*                                                               */
*   /* ADVANCE PLH RECORD POSITION BEYOND INSERT                     */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0302
*   PLHFSP=PLHFSP+RWORK1;           /* ADJUST FREE SPACE PTR         */
         LR    @10,RWORK1                                          0302
         AL    @10,PLHFSP(,RPLH)                                   0302
         ST    @10,PLHFSP(,RPLH)                                   0302
*   IF RPLBWD=OFF THEN              /* FORWARD DIRECTION     @ZA02289*/
         TM    RPLBWD(RRPL),B'00010000'                            0303
         BNZ   @RF00303                                            0303
*     DO;                           /* YES                   @ZA02289*/
*       PLHNOADV=ON;                /* SET NOADV FOR RETRIEVE        */
         OI    PLHNOADV(RPLH),B'00001000'                          0305
*       PLHRECP=PLHRECP+RWORK1;     /* ADJUST RECORD PTR             */
         LR    @10,RWORK1                                          0306
         AL    @10,PLHRECP(,RPLH)                                  0306
         ST    @10,PLHRECP(,RPLH)                                  0306
*     END;                          /*                       @XO4SVES*/
*   ELSE                            /* BACKWARD MODE         @ZA02289*/
*     DO;                           /* YES, ASSURE CORRECT RDFC AND
*                                      RDFP                  @ZA02289*/
         B     @RC00303                                            0308
@RF00303 DS    0H                                                  0309
*       PLHRDFP=PLHFSP+RWORK2->CIDFLL/* SET RDFP TO          @ZA02289*/
*           -LENGTH(IDARDF);        /* LEFT OF LEFTMOST RDF  @ZA02289*/
         L     @10,PLHFSP(,RPLH)                                   0309
         LH    @15,CIDFLL(,RWORK2)                                 0309
         ALR   @15,@10                                             0309
         SL    @15,@CF00158                                        0309
         ST    @15,PLHRDFP(,RPLH)                                  0309
*       PLHRDFC=ONE;                /* START COUNT           @ZA02289*/
         MVC   PLHRDFC(2,RPLH),@CH00056                            0310
*       RWORK2=PLHFSP;              /* START AT END          @ZA02289*/
         LR    RWORK2,@10                                          0311
*       DO WHILE RWORK2>PLHRECP;    /* SEARCH TO CURRENT RECORD    0312
*                                      POSITION              @ZA02289*/
         B     @DE00312                                            0312
@DL00312 DS    0H                                                  0313
*         IF PLHRDFC=ONE THEN       /* GROUP FINISHED        @ZA02289*/
         CLC   PLHRDFC(2,RPLH),@CH00056                            0313
         BNE   @RF00313                                            0313
*           DO;                     /* YES                   @ZA02289*/
*             PLHRDFP=PLHRDFP+LENGTH(IDARDF);/* MOVE TO NEXT RDF AT
*                                      THE RIGHT             @ZA02289*/
         LA    @10,3                                               0315
         L     @15,PLHRDFP(,RPLH)                                  0315
         ALR   @15,@10                                             0315
         ST    @15,PLHRDFP(,RPLH)                                  0315
*             IF PLHRDFP->RDFCTNU=ON THEN/* IS THIS LENGTH RDF OF A
*                                      GROUP                 @ZA02289*/
         TM    RDFCTNU(@15),B'01000000'                            0316
         BNO   @RF00316                                            0316
*               PLHRDFP=PLHRDFP+LENGTH(IDARDF);/* YES        @ZA02289*/
         ALR   @15,@10                                             0317
         ST    @15,PLHRDFP(,RPLH)                                  0317
*             IF PLHRDFP->RDFREPL=ON THEN/* IS THIS THE COUNT RDF OF
*                                      A GROUP               @ZA02289*/
@RF00316 L     @10,PLHRDFP(,RPLH)                                  0318
         TM    RDFREPL(@10),B'00001000'                            0318
         BNO   @RF00318                                            0318
*               DO;                 /* YES                   @ZA02289*/
*                 RPARM1=PLHRDFP+LENGTH(IDARDF);/* YES, POINT TO THE
*                                      LENGTH RDF            @ZA02289*/
         LA    RPARM1,3                                            0320
         ALR   RPARM1,@10                                          0320
*                 PLHLRECL=RPARM1->RDFLL;/* SET LENGTH       @ZA02289*/
         SLR   @15,@15                                             0321
         ICM   @15,3,RDFLL(RPARM1)                                 0321
         ST    @15,PLHLRECL(,RPLH)                                 0321
*                 PLHRDFC=PLHRDFP->RDFLL;/* SET COUNT        @ZA02289*/
         MVC   PLHRDFC(2,RPLH),RDFLL(@10)                          0322
*               END;                /*                       @ZA02289*/
*             ELSE                  /*                       @ZA02289*/
*               DO;                 /*                       @ZA02289*/
         B     @RC00318                                            0324
@RF00318 DS    0H                                                  0325
*                 PLHLRECL=PLHRDFP->RDFLL;/* SET LENGTH      @ZA02289*/
         L     @10,PLHRDFP(,RPLH)                                  0325
         SLR   @15,@15                                             0325
         ICM   @15,3,RDFLL(@10)                                    0325
         ST    @15,PLHLRECL(,RPLH)                                 0325
*                 PLHRDFC=ONE;      /* SET COUNT AT 1        @ZA02289*/
         MVC   PLHRDFC(2,RPLH),@CH00056                            0326
*               END;                /*                       @ZA02289*/
*           END;                    /*                       @ZA02289*/
*         ELSE                      /* IN A GROUP SO         @ZA02289*/
*           PLHRDFC=PLHRDFC-ONE;    /* REDUCE COUNT          @ZA02289*/
         B     @RC00313                                            0329
@RF00313 LH    @10,PLHRDFC(,RPLH)                                  0329
         BCTR  @10,0                                               0329
         STH   @10,PLHRDFC(,RPLH)                                  0329
*         RWORK2=RWORK2-PLHLRECL;   /* MOVE TO NEXT RECORD   @ZA02289*/
@RC00313 SL    RWORK2,PLHLRECL(,RPLH)                              0330
*       END;                        /*                       @ZA02289*/
@DE00312 CL    RWORK2,PLHRECP(,RPLH)                               0331
         BH    @DL00312                                            0331
*     END;                          /*                       @ZA02289*/
*   RESPECIFY                                                      0333
*     RWORK0 UNRESTRICTED;                                         0333
@RC00303 DS    0H                                                  0334
*   IF PLHCIINS=OFF THEN            /* CI SPLIT CALL                 */
         TM    PLHCIINS(RPLH),B'00000100'                          0334
         BNZ   @RF00334                                            0334
*     DO;                           /* NO.                           */
*       IF AMBCREAT=ON×AMDDST='0'B THEN/* CREATE MODE        @ZA02289*/
         TM    AMBCREAT(RAMB),B'10000000'                          0336
         BO    @RT00336                                            0336
         L     @10,AMBDSB(,RAMB)                                   0336
         TM    AMDDST(@10),B'10000000'                             0336
         BNZ   @RF00336                                            0336
@RT00336 DS    0H                                                  0337
*         PLHLRECL=RWORK1;          /* SAVE LL               @ZA02289*/
         ST    RWORK1,PLHLRECL(,RPLH)                              0337
*       IF BUFCMW=OFF THEN          /* INSURE MUST WRITE IS ON       */
@RF00336 L     @10,PLHDBUFC(,RPLH)                                 0338
         TM    BUFCMW(@10),B'10000000'                             0338
         BNZ   @RF00338                                            0338
*         DO;                       /*                       @ZA17187*/
*           BUFXORBA=BUFCDDDD;      /* EXCL OUT RBA          @ZA17187*/
         L     @15,BUFCDDDD(,@10)                                  0340
         ST    @15,BUFXORBA(,@10)                                  0340
*           DO;                     /* SET UPDATED BFR               */
*             BUFCORBA=BUFCDDDD;                                   0342
         ST    @15,BUFCORBA(,@10)                                  0342
*             BUFCMW=ON;                                           0343
         OI    BUFCMW(@10),B'10000000'                             0343
*           END;                                                   0344
*         END;                      /*                       @ZA17187*/
*       IF AMBJRN=ON THEN           /* JOURNAL EXIT                  */
@RF00338 TM    AMBJRN(RAMB),B'00000010'                            0346
         BNO   @RF00346                                            0346
*         DO;                       /* YES.                          */
*           RWORK2=PLHFSP-PLHRECP;  /* MOVED DATA AMOUNT             */
         L     RWORK2,PLHFSP(,RPLH)                                0348
         SL    RWORK2,PLHRECP(,RPLH)                               0348
*           IF RPLBWD=ON THEN       /* BACKWARD DIRECTION    @ZA02289*/
         TM    RPLBWD(RRPL),B'00010000'                            0349
         BNO   @RF00349                                            0349
*             RWORK2=RWORK2-RWORK1; /* ADJUST PTR            @ZA02289*/
         SLR   RWORK2,RWORK1                                       0350
*           IF RWORK2>ZERO THEN     /* ANY MOVED                     */
@RF00349 CL    RWORK2,@CF00061                                     0351
         BNH   @RF00351                                            0351
*             DO;                   /* YES.                          */
*               PLHJRNLL=RWORK2;    /* AMOUNT MOVED                  */
         ST    RWORK2,PLHJRNLL(,RPLH)                              0353
*               PLHJORBA=RPLDDDD;   /* OLD RBA                       */
         L     @10,RPLDDDD(,RRPL)                                  0354
         ST    @10,PLHJORBA(,RPLH)                                 0354
*               PLHJNRBA=RPLDDDD+RPLRLEN;/* NEW RBA                  */
         AL    @10,RPLRLEN(,RRPL)                                  0355
         ST    @10,PLHJNRBA(,RPLH)                                 0355
*               PLHJCODE=PLHJRBAC;  /* RBA CHANGE REQUEST            */
         MVI   PLHJCODE(RPLH),B'00001100'                          0356
*I06:                                                              0357
*               DO;                 /* IDACALL(IDATJXIT)             */
I06      DS    0H                                                  0358
*                 CALL IDATJXIT;    /* EXIT TO IDATJXIT              */
         L     @15,@CV00928                                        0358
         BALR  @14,@15                                             0358
*                 GEN(BALR @11,0);  /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*                 GEN(USING *,@11); /* ESTABLISH ADDRESSING          */
         USING *,@11
*                 GEN(L     @11,=A(@PSTART));/* RELOAD BASE          */
         L     @11,=A(@PSTART)
*                 GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING     */
         USING @PSTART,@11
*               END I06;                                           0363
*             END;                  /* END DATA MOVED                */
*         END;                      /* END JOURNAL EXIT              */
@RF00351 DS    0H                                                  0366
*     END;                          /* END NOT CI SPLIT CALL         */
@RF00346 DS    0H                                                  0367
*   RFY                                                            0367
*     R15 RSTD;                     /* PROTECT R15           @ZA02289*/
@RF00334 DS    0H                                                  0368
*   R15=ZERO;                       /* SET RETURN CODE@ZA02289       */
         SLR   R15,R15                                             0368
*   CALL EXIT;                      /* RETURN                @ZA02289*/
         BAL   @14,EXIT                                            0369
*   RFY                                                            0370
*     R15 UNRSTD;                   /* RELEASE R15           @ZA02289*/
*                                                                  0371
*   /*****************************************************************/
*   /*                                                               */
*   /* RECORD WILL NOT FIT IN CONTROL INTERVAL. CALL IDA019RE (      */
*   /* CONTROL INTERVAL SPLIT ) OR CALL IDA019SA ( CONTROL INTERVAL  */
*   /* INITIALIZATION )                                              */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0371
*CIFULL:                            /* NEED NEW CI                   */
*   IF PLHCIINS=ON THEN             /* CALLED BY CI SPLIT            */
CIFULL   TM    PLHCIINS(RPLH),B'00000100'                          0371
         BNO   @RF00371                                            0371
*     DO;                           /* YES.                          */
*       RFY                                                        0373
*         R15 RSTD;                 /* PROTECT R15           @ZA02289*/
*       R15=CIFULLCD;               /* SET RETURN CODE@ZA02289       */
         LA    R15,4                                               0374
*       CALL EXIT;                  /* RETURN                @ZA02289*/
         BAL   @14,EXIT                                            0375
*       RFY                                                        0376
*         R15 UNRSTD;               /* RELEASE R15           @ZA02289*/
*     END;                          /* END OF CALL BY CI SPLIT       */
*   RESPECIFY                                                      0378
*     IDAARDB BASED(PLHARDB);                                      0378
@RF00371 DS    0H                                                  0379
*   IF AMBCREAT=ON×                 /* SEE IF CREATE         @X04SVMR*/
*       AMDDST='0'B THEN            /* OR ESDS.              @X04SVMR*/
         TM    AMBCREAT(RAMB),B'10000000'                          0379
         BO    @RT00379                                            0379
         L     @10,AMBDSB(,RAMB)                                   0379
         TM    AMDDST(@10),B'10000000'                             0379
         BNZ   @RF00379                                            0379
@RT00379 DS    0H                                                  0380
*     DO;                           /* YES                   @ZA02289*/
*I07:                                                              0381
*       DO;                         /* IDACALL(IDA019SA)             */
I07      DS    0H                                                  0382
*         CALL IDA019SA;            /* EXIT TO IDA019SA              */
         L     @15,@CV00932                                        0382
         BALR  @14,@15                                             0382
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I07;                    /* CALL CI INIT.         @X04SVMR*/
*       PLHKRE=OFF;                 /* RESET END OF KEY RANGE      0388
*                                                            @ZA02289*/
         NI    PLHKRE(RPLH),B'11110111'                            0388
*       IF RPLERREG^=ZERO THEN      /* ERROR                 @ZA02289*/
         CLI   RPLERREG(RRPL),0                                    0389
         BE    @RF00389                                            0389
*         CALL EXIT;                /* YES, LEAVE            @ZA02289*/
         BAL   @14,EXIT                                            0390
*       GO TO DISTART;              /* GO INSERT RECD        @ZA02289*/
         B     DISTART                                             0391
*     END;                          /*                       @ZA02289*/
*   ELSE                            /* NO, CI SPLIT          @X04SVMR*/
*     DO;                           /*                       @X04SVMR*/
*                                                                  0393
@RF00379 DS    0H                                                  0394
*       /*************************************************************/
*       /*                                                           */
*       /* IF SHARED RESOURCES FREE THE SEQUENCE SET IF IT IS OWNED. */
*       /* THIS PREVENTS A DEADLOCK FROM OCCURRING BETWEEN SEQ AND   */
*       /* DIR INSERTS. DEADLOCK WOULD OCCUR BETWEEN THE SEQUENCES 1)*/
*       /* GET DIWA, 2) GET SEQ SET (SEQ INSERT) AND 1) GET SEQ SET, */
*       /* 2) GET DIWA (DIR INSERT). NOTE THAT CI SPLIT WILL         */
*       /* REACQUIRE THE SEQUENCE SET BUFFER FOR EXCL CNTL.  @X04SVMR*/
*       /*                                                           */
*       /*************************************************************/
*                                                                  0394
*       IF AMBLSR=ON×AMBGSR=ON THEN /* IF SHARED             @X04SVMR*/
         TM    AMBLSR(RAMB),B'01100000'                            0394
         BZ    @RF00394                                            0394
*         DO;                       /* RESOURCES,            @X04SVMR*/
*           RBUFC=PLHIBUFC;         /* POINT TO SS           @X04SVMR*/
         L     RBUFC,PLHIBUFC(,RPLH)                               0396
*           IF RBUFC^=ZERO THEN     /* OWNED BY PLH?         @X04SVMR*/
         LTR   RBUFC,RBUFC                                         0397
         BZ    @RF00397                                            0397
*I08:                                                              0398
*             DO;                   /* IDACALL(IDAFREEB)             */
I08      DS    0H                                                  0399
*               CALL IDAFREEB;      /* EXIT TO IDAFREEB              */
         L     @15,@CV00985                                        0399
         BALR  @14,@15                                             0399
*               GEN(BALR @11,0);    /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*               GEN(USING *,@11);   /* ESTABLISH ADDRESSING          */
         USING *,@11
*               GEN(L     @11,=A(@PSTART));/* RELOAD BASE            */
         L     @11,=A(@PSTART)
*               GEN(USING @PSTART,@11);/* ESTABLISH ADDRESSING       */
         USING @PSTART,@11
*             END I08;              /* YES, FREE IT.         @X04SVMR*/
*         END;                      /* END OF FREE SS        @X04SVMR*/
@RF00397 DS    0H                                                  0406
*LOCKDIWA:                          /* LOCK DATA INSERT WA           */
*       RPARM1=ADDR(DIWATV);        /* POINT TO LOCK BYTE            */
@RF00394 DS    0H                                                  0406
LOCKDIWA L     RPARM1,AMBIWA(,RAMB)                                0406
         LA    RPARM1,DIWATV(,RPARM1)                              0406
*       GEN(TS 0(RPARM1));          /* TEST AND SET                  */
         TS 0(RPARM1)
*       BC(8,HAVEDIWA);             /* OBTAINED DIWA         @X04SVMR*/
         BC    8,HAVEDIWA                                          0408
*       RFY                                                        0409
*         RWORK0 RSTD;              /* RESTRICT RWORK0               */
*       RWORK0=DEFR0;               /* DATA INSERT REQUEST           */
         SLR   RWORK0,RWORK0                                       0410
*I09:                                                              0411
*       DO;                         /* IDACALL(IDADRQ)               */
I09      DS    0H                                                  0412
*         CALL IDADRQ;              /* EXIT TO IDADRQ                */
         L     @15,@CV00933                                        0412
         BALR  @14,@15                                             0412
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I09;                                                   0417
*       GO TO LOCKDIWA;             /* TRY LOCK AGAIN                */
         B     LOCKDIWA                                            0418
*HAVEDIWA:                          /* LOCK SUCCESSFUL               */
*       DIWPLH=RPLH;                /* IDENTIFY LOCKING PLH          */
HAVEDIWA L     @10,AMBIWA(,RAMB)                                   0419
         ST    RPLH,DIWPLH(,@10)                                   0419
*I10:                                                              0420
*       DO;                         /* IDACALL(IDA019RE)             */
I10      DS    0H                                                  0421
*         CALL IDA019RE;            /* EXIT TO IDA019RE              */
         L     @15,@CV00929                                        0421
         BALR  @14,@15                                             0421
*         GEN(BALR @11,0);          /* LOAD ADDR OF REENTRY          */
         BALR @11,0
*         GEN(USING *,@11);         /* ESTABLISH ADDRESSING          */
         USING *,@11
*         GEN(L     @11,=A(@PSTART));/* RELOAD BASE                  */
         L     @11,=A(@PSTART)
*         GEN(USING @PSTART,@11);   /* ESTABLISH ADDRESSING          */
         USING @PSTART,@11
*       END I10;                                                   0426
*       DIWATV=CZERO;               /* RELEASE DIWA                  */
         L     @10,AMBIWA(,RAMB)                                   0427
         MVI   DIWATV(@10),B'00000000'                             0427
*       CALL EXIT;                  /* RETURN                @ZA02289*/
         BAL   @14,EXIT                                            0428
*     END;                          /*                       @X04SVMR*/
*                                                                  0430
*   /*****************************************************************/
*   /*                                                               */
*   /* IDACHKKR SUBROUTINE CHECKS KEY FOR VALIDITY AND SETS PLHARDB  */
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0430
*IDACHKKR:                          /* ENTRY NAME                    */
*   ENTRY;                          /*                               */
@EP00430 DS    0H                                                  0431
*   RFY                                                            0431
*    (RWORK1,                                                      0431
*     RWORK2,                                                      0431
*     RWORK3,                                                      0431
*     R14) RSTD;                    /*                               */
*   DO;                             /*                               */
*     RWORK3=AMDPARDB;              /* START WITH 1ST ARDB           */
         L     @15,AMBDSB(,RAMB)                                   0433
         L     RWORK3,AMDPARDB(,@15)                               0433
*NXKR:                                                             0434
*     IF RWORK1->KEY(1:RWORK2)<     /* NEW KEY LESS THAN             */
*         RWORK3->ARDKEYS(1:RWORK2) THEN/* ARDB LOW KEY              */
NXKR     LR    @15,RWORK2                                          0434
         BCTR  @15,0                                               0434
         EX    @15,@SC01005                                        0434
         BL    @RT00434                                            0434
*       GO TO KRERROR;              /* YES. ERROR                    */
*     IF RWORK1->KEY(1:RWORK2)>     /* NEW KEY GREATER THAN          */
*         RWORK3->ARDKEYS(RWORK2+1:2*RWORK2) THEN/* ARDB HIGH KEY    */
         LR    @15,RWORK2                                          0436
         ALR   @15,@15                                             0436
         SLR   @15,RWORK2                                          0436
         BCTR  @15,0                                               0436
         LR    @10,RWORK3                                          0436
         ALR   @10,RWORK2                                          0436
         EX    @15,@SC01016                                        0436
         BNH   @RF00436                                            0436
*       DO;                         /* YES.                          */
*         RWORK3=RWORK3->ARDNPTR;   /* NEXT ARDB                     */
         L     RWORK3,ARDNPTR(,RWORK3)                             0438
*         IF RWORK3=ZERO THEN       /* END OF DATA SET               */
         LTR   RWORK3,RWORK3                                       0439
         BZ    @RT00439                                            0439
*           GO TO KRERROR;          /* YES. ERROR                    */
*         GO TO NXKR;               /* LOOK AT NEXT ARDB             */
         B     NXKR                                                0441
*       END;                        /* END OF KEY GREATER            */
*     PLHARDB=RWORK3;               /* SET PTR TO ARDB               */
@RF00436 ST    RWORK3,PLHARDB(,RPLH)                               0443
*     RETURN;                       /*                               */
@EL00001 DS    0H                                                  0444
@EF00001 DS    0H                                                  0444
@ER00001 BR    @14                                                 0444
*   END;                            /* END OF NON-CREATE             */
*   RFY                                                            0446
*    (RWORK1,                                                      0446
*     RWORK2,                                                      0446
*     RWORK3,                                                      0446
*     R14) UNRSTD;                  /*                               */
*                                                                  0447
*   /*****************************************************************/
*   /*                                                               */
*   /* * * * * * * * * * * * * * * * * * * * * * * * * *     @ZA02289*/
*   /*                                                       @ZA02289*/
*   /* EXIT SUBROUTINE                                       @ZA02289*/
*   /* FUNCTION - RESTORES REGISTER 14 FROM PLH              @ZA02289*/
*   /* PUSHDOWN LIST AND RETURNS                             @ZA02289*/
*   /*                                                       @ZA02289*/
*   /* * * * * * * * * * * * * * * * * * * * * * * * * *     @ZA02289*/
*   /*                                                               */
*   /*****************************************************************/
*                                                                  0447
*EXIT:                                                             0447
*   PROC OPTIONS(NOSAVE,NOSAVEAREA);/*                       @ZA02289*/
EXIT     DS    0H                                                  0448
*   GEN(IDARST14);                  /* RESTORE REG 14        @ZA02289*/
         IDARST14
*   END EXIT;                       /* RETURN                @ZA02289*/
@EL00002 DS    0H                                                  0449
@EF00002 DS    0H                                                  0449
@ER00002 BR    @14                                                 0449
*   GEN(IDAPATCH);                  /* DEFINE PATCH AREA     @X04SVMR*/
         IDAPATCH
*   END IDA019RM                    /* END DATA INSERT       @X04SVMR*/
*                                                                  0451
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.     */
*/*%INCLUDE SYSLIB  (IDAREGS )                                       */
*/*%INCLUDE SYSLIB  (IDARMRCD)                                       */
*/*%INCLUDE SYSLIB  (IFGRPL  )                                       */
*/*%INCLUDE SYSLIB  (IFGACB  )                                       */
*/*%INCLUDE SYSLIB  (IDAAMBL )                                       */
*/*%INCLUDE SYSLIB  (IDAAMB  )                                       */
*/*%INCLUDE SYSLIB  (IDAPLH  )                                       */
*/*%INCLUDE SYSLIB  (IDABUFC )                                       */
*/*%INCLUDE SYSLIB  (IDAAMDSB)                                       */
*/*%INCLUDE SYSLIB  (IDADIWA )                                       */
*/*%INCLUDE SYSLIB  (IDAARDB )                                       */
*/*%INCLUDE SYSLIB  (IDACIDF )                                       */
*/*%INCLUDE SYSLIB  (IDARDF  )                                       */
*                                                                  0451
*       ;                                                          0451
         B     @EL00001                                            0451
@DATA    DS    0H
@CH00056 DC    H'1'
@SC01005 CLC   KEY(0,RWORK1),ARDKEYS(RWORK3)
@SC01007 CLC   KEY(0,RWORK1),ARDKEYS(@15)
@SM01009 MVC   PLHKEY(0,@10),ARDKEYS(@14)
@SC01016 CLC   KEY(0,RWORK1),ARDKEYS(@10)
@DATD    DSECT
         DS    0F
IDA019RM CSECT
         DS    0F
@CF00061 DC    F'0'
@CF00158 DC    F'3'
@CF00069 DC    F'4'
@CF00289 DC    F'7'
@DATD    DSECT
         DS    0D
IDA019RM CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
@CA00969 DC    A(IDACHKKR)
@CV00928 DC    V(IDATJXIT)
@CV00929 DC    V(IDA019RE)
@CV00930 DC    V(IDA019RT)
@CV00931 DC    V(IDA019RU)
@CV00932 DC    V(IDA019SA)
@CV00933 DC    V(IDADRQ)
@CV00985 DC    V(IDAFREEB)
         DS    0D
HWORD4   DC    H'4'
@DATD    DSECT
*                                                          /*@X04SVLC*/
RDFCTNUA EQU   X'40'                    COMPLEX RDF INDICATOR
RDFCTNUX EQU   X'FF'-RDFCTNUA           RESET COMPLEX MASK
RDFREPLA EQU   X'08'                    COUNT RDF INDICATOR
RDFREPLX EQU   X'FF'-RDFREPLA           RESET COUNT MASK
RDFEMPTI EQU   X'04'                    EMPTY RECORD       /*@X04SVLC*/
RDFLEN   EQU   3                        LENGTH OF RDF
RDFLLOFF EQU   1                        OFFSET WITHIN RDF TO LL
RDFSGLR  EQU   X'00'                   MASK FOR SINGLE RECORD RDF
RDFGRP   EQU   RDFCTNUA                 MASK FOR LL RDF OF A GROUP RDF
RDFCNT   EQU   RDFREPLA                 MASK FOR COUNT RDF
@DATD    DSECT
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IDA019RM CSECT
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
RWORK0   EQU   @00
RRPL     EQU   @01
RPLH     EQU   @02
RAMB     EQU   @03
RBUFC    EQU   @04
RWORK1   EQU   @05
RWORK2   EQU   @06
RWORK3   EQU   @07
RWORK4   EQU   @08
RWORK5   EQU   @09
R10      EQU   @10
RPARM1   EQU   @12
R14      EQU   @14
R15      EQU   @15
R1       EQU   @01
R11      EQU   @11
R13      EQU   @13
IFGRPL   EQU   0
RPLCOMN  EQU   IFGRPL
RPLIDWD  EQU   RPLCOMN
RPLLEN   EQU   RPLIDWD+3
RPLECB   EQU   RPLCOMN+8
RPLFDBWD EQU   RPLCOMN+12
RPLFDBK  EQU   RPLFDBWD+1
RPLRTNCD EQU   RPLFDBK
RPLERREG EQU   RPLRTNCD
RPLCNDCD EQU   RPLFDBK+1
RPLCMPON EQU   RPLCNDCD
RPLFDB2  EQU   RPLCMPON
RPLERRCD EQU   RPLCNDCD+1
RPLFDB3  EQU   RPLERRCD
RPLKEYLE EQU   RPLCOMN+16
RPLDACB  EQU   RPLCOMN+24
RPLAREA  EQU   RPLCOMN+32
RPLARG   EQU   RPLCOMN+36
RPLOPTCD EQU   RPLCOMN+40
RPLOPT1  EQU   RPLOPTCD
RPLSEQ   EQU   RPLOPT1
RPLECBSW EQU   RPLOPT1
RPLOPT2  EQU   RPLOPTCD+1
RPLADR   EQU   RPLOPT2
RPLBWD   EQU   RPLOPT2
RPLUPD   EQU   RPLOPT2
RPLOPT3  EQU   RPLOPTCD+2
RPLNXTRP EQU   RPLCOMN+44
RPLRLEN  EQU   RPLCOMN+48
RPLOPTC2 EQU   RPLCOMN+56
RPLOPT5  EQU   RPLOPTC2
RPLWRTYP EQU   RPLOPT5
RPLOPT6  EQU   RPLOPTC2+1
RPLUNTYP EQU   RPLOPT6
RPLOPT7  EQU   RPLOPTC2+2
RPLCNOPT EQU   RPLOPT7
RPLOPT8  EQU   RPLOPTC2+3
RPLRBAR  EQU   RPLCOMN+60
RPLAIXID EQU   RPLRBAR+2
RPLDDDD  EQU   RPLRBAR+4
RPLEXTDS EQU   RPLCOMN+68
RPLEXTD1 EQU   RPLEXTDS
IFGACB   EQU   0
ACBCOMN  EQU   IFGACB
ACBLENG  EQU   ACBCOMN+2
ACBLENG2 EQU   ACBLENG
ACBAMBL  EQU   ACBCOMN+4
ACBJWA   EQU   ACBAMBL
ACBMACRF EQU   ACBCOMN+12
ACBMACR1 EQU   ACBMACRF
ACBADR   EQU   ACBMACR1
ACBCNV   EQU   ACBMACR1
ACBMACR2 EQU   ACBMACRF+1
ACBBUFPL EQU   ACBCOMN+20
ACBMACR3 EQU   ACBBUFPL
ACBRECFM EQU   ACBCOMN+24
ACBCCTYP EQU   ACBCOMN+25
ACBOPT   EQU   ACBCOMN+26
ACBDSORG EQU   ACBOPT
ACBCROPS EQU   ACBDSORG
ACBEXLST EQU   ACBCOMN+36
ACBDDNM  EQU   ACBCOMN+40
ACBAMETH EQU   ACBDDNM+3
ACBOFLGS EQU   ACBCOMN+48
ACBEXFG  EQU   ACBOFLGS
ACBIOSFG EQU   ACBOFLGS
ACBINFLG EQU   ACBCOMN+50
ACBUJFCB EQU   ACBCOMN+52
ACBBLKSZ EQU   ACBCOMN+60
IDAAMBL  EQU   0
AMBLEOV  EQU   IDAAMBL+12
AMBLEFLG EQU   AMBLEOV
AMBLDDNM EQU   IDAAMBL+16
AMBLIDF  EQU   AMBLDDNM
AMBLQ    EQU   AMBLIDF+7
AMBLVC   EQU   IDAAMBL+28
AMBLTYPE EQU   IDAAMBL+30
AMBLSHAR EQU   IDAAMBL+33
AMBLFLG1 EQU   IDAAMBL+35
AMBLFLG2 EQU   IDAAMBL+36
IDAAMB   EQU   0
AMBPH    EQU   IDAAMB+12
AMBDSB   EQU   IDAAMB+20
AMBEOVR  EQU   IDAAMB+24
AMBFLG0  EQU   AMBEOVR
AMBFLG1  EQU   IDAAMB+25
AMBCREAT EQU   AMBFLG1
AMBJRN   EQU   AMBFLG1
AMBDSORG EQU   IDAAMB+26
AMBIOBAD EQU   IDAAMB+28
AMBINFL  EQU   IDAAMB+42
AMBUPX   EQU   AMBINFL
AMBDEBPT EQU   IDAAMB+44
AMBOFLGS EQU   IDAAMB+48
AMBFLG2  EQU   IDAAMB+49
AMBEOVPT EQU   IDAAMB+56
AMBIWA   EQU   IDAAMB+64
AMBCSWD1 EQU   IDAAMB+84
AMBAFLG  EQU   AMBCSWD1
AMBLSR   EQU   AMBAFLG
AMBGSR   EQU   AMBAFLG
IDAPLHDR EQU   0
IDAPLH   EQU   0
PLHFLG1  EQU   IDAPLH+2
PLHFLG2  EQU   IDAPLH+3
PLHADDTE EQU   PLHFLG2
PLHKRE   EQU   PLHFLG2
PLHCIINS EQU   PLHFLG2
PLHEFLGS EQU   IDAPLH+4
PLHNOADV EQU   PLHEFLGS
PLHFLG3  EQU   IDAPLH+6
PLHAFLGS EQU   IDAPLH+7
PLHCRBA  EQU   IDAPLH+28
PLHJORBA EQU   PLHCRBA
PLHJRNLL EQU   IDAPLH+32
PLHJNRBA EQU   IDAPLH+36
PLHJCODE EQU   IDAPLH+40
PLHARDB  EQU   IDAPLH+44
PLHLRECL EQU   IDAPLH+48
PLHDBUFC EQU   IDAPLH+52
PLHRECP  EQU   IDAPLH+60
PLHFSP   EQU   IDAPLH+64
PLHRDFP  EQU   IDAPLH+68
PLHRDFC  EQU   IDAPLH+72
PLHDIOB  EQU   IDAPLH+76
PLHSAVE1 EQU   IDAPLH+84
PLHSAVE2 EQU   IDAPLH+88
PLHSAVE6 EQU   IDAPLH+104
PLHRETO  EQU   IDAPLH+116
PLHRET1  EQU   IDAPLH+120
PLHEOVPT EQU   IDAPLH+180
PLHIBUFC EQU   IDAPLH+188
PLHIXSPL EQU   IDAPLH+200
PLHSSRBA EQU   PLHIXSPL
PLHWAX   EQU   IDAPLH+232
PLHKEYPT EQU   IDAPLH+248
PLHDRRSC EQU   IDAPLH+252
PLHEND   EQU   IDAPLH+280
PLHKEY   EQU   0
IDABUFDR EQU   0
BUFDRCIX EQU   IDABUFDR+9
BUFDRFLG EQU   IDABUFDR+11
IDABUFC  EQU   0
BUFCAVL  EQU   IDABUFC
BUFCFLG1 EQU   IDABUFC+1
BUFCVAL  EQU   BUFCFLG1
BUFCIOFL EQU   IDABUFC+2
BUFCMW   EQU   BUFCIOFL
BUFCFLG2 EQU   IDABUFC+3
BUFCPLH  EQU   IDABUFC+4
BUFCDDDD EQU   IDABUFC+8
BUFCORBA EQU   IDABUFC+12
BUFCBAD  EQU   IDABUFC+20
BUFCINV  EQU   IDABUFC+28
BUFXIRBA EQU   IDABUFC+40
BUFXORBA EQU   IDABUFC+44
IDAAMDSB EQU   0
AMDATTR  EQU   IDAAMDSB+1
AMDDST   EQU   AMDATTR
AMDRANGE EQU   AMDATTR
AMDNEST  EQU   IDAAMDSB+4
AMDRKP   EQU   IDAAMDSB+6
AMDKEYLN EQU   IDAAMDSB+8
AMDFSCI  EQU   IDAAMDSB+16
AMDCINV  EQU   IDAAMDSB+20
AMDHLRBA EQU   IDAAMDSB+28
AMDSSRBA EQU   IDAAMDSB+32
AMDPARDB EQU   IDAAMDSB+36
AMDATTR3 EQU   IDAAMDSB+40
AMDSTAT  EQU   IDAAMDSB+48
IDADIWA  EQU   0
DIWATV   EQU   IDADIWA+1
DIWFLG1  EQU   IDADIWA+4
DIWFLG2  EQU   IDADIWA+5
DIWPLH   EQU   IDADIWA+16
DIWSAVE  EQU   IDADIWA+28
IDAARDB  EQU   0
ARDTYPE  EQU   IDAARDB+1
ARDNPTR  EQU   IDAARDB+4
ARDHKRBA EQU   IDAARDB+8
ARDHRBA  EQU   IDAARDB+12
ARDPRF   EQU   IDAARDB+28
ARDKEYS  EQU   IDAARDB+29
IDACIDF  EQU   0
CIDFOSET EQU   IDACIDF
CIDFLL   EQU   IDACIDF+2
IDARDF   EQU   0
RDFRBYTE EQU   IDARDF
RDFCTNU  EQU   RDFRBYTE
RDFSEG   EQU   RDFRBYTE
RDFNOT1  EQU   RDFSEG
RDF1ST   EQU   RDFSEG
RDFREPL  EQU   RDFRBYTE
RDFLL    EQU   IDARDF+1
IDADATA  EQU   0
IDAKEY   EQU   0
KEY      EQU   IDAKEY
PLHPDL   EQU   0
PLHPDLE  EQU   0
PLHRRN   EQU   0
RSRCBYTE EQU   0
PLHEXTEN EQU   PLHEND
PLHBMWRK EQU   PLHEXTEN+5
BUFCRSC1 EQU   BUFCAVL
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
PLHBMSV5 EQU   PLHEXTEN+24
PLHBMSV4 EQU   PLHEXTEN+20
PLHBMSV3 EQU   PLHEXTEN+16
PLHBMSV2 EQU   PLHEXTEN+12
PLHBMSV1 EQU   PLHEXTEN+8
PLHRDCNT EQU   PLHEXTEN+6
PLHBMSOV EQU   PLHBMWRK
PLHBEUC  EQU   PLHBMWRK
PLHBMRDF EQU   PLHBMWRK
@NM00040 EQU   PLHEXTEN+4
PLHRESR1 EQU   PLHEXTEN
AMDATA   EQU   IDADATA
RDFEMPTY EQU   RDFRBYTE
RDFTYPE  EQU   RDFRBYTE
@NM00058 EQU   CIDFLL
CIDFBUSY EQU   CIDFLL
@NM00057 EQU   ARDPRF
ARDPRFMT EQU   ARDPRF
ARDPRSS  EQU   ARDPRF
ARDRELNO EQU   IDAARDB+26
ARDVOLSR EQU   IDAARDB+20
ARDERBA  EQU   IDAARDB+16
ARDLEN   EQU   IDAARDB+2
ARDUSED  EQU   ARDTYPE
ARDEOD   EQU   ARDTYPE
ARDUOVFL EQU   ARDTYPE
ARDSS    EQU   ARDTYPE
ARDHLI   EQU   ARDTYPE
ARDKR    EQU   ARDTYPE
ARDID    EQU   IDAARDB
@NM00056 EQU   IDADIWA+92
@NM00055 EQU   IDADIWA+88
@NM00054 EQU   IDADIWA+84
@NM00053 EQU   IDADIWA+80
@NM00052 EQU   IDADIWA+76
@NM00051 EQU   IDADIWA+72
@NM00050 EQU   IDADIWA+68
@NM00049 EQU   IDADIWA+64
@NM00048 EQU   IDADIWA+60
@NM00047 EQU   IDADIWA+56
DIWINRBA EQU   IDADIWA+52
DIWRKCT  EQU   IDADIWA+48
DIWSAVE5 EQU   DIWSAVE+16
DIWSAVE4 EQU   DIWSAVE+12
DIWSAVE3 EQU   DIWSAVE+8
DIWSAVE2 EQU   DIWSAVE+4
DIWSAVE1 EQU   DIWSAVE
DIWSPLTP EQU   IDADIWA+24
DIWBUFC  EQU   IDADIWA+20
DIWHRBA  EQU   IDADIWA+12
DIWLRBA  EQU   IDADIWA+8
@NM00046 EQU   IDADIWA+6
DIWFSPF  EQU   DIWFLG2
DIW1ST   EQU   DIWFLG1
DIWNOT1  EQU   DIWFLG1
DIWSHIFT EQU   DIWFLG1
DIWGSPC  EQU   DIWFLG1
DIWEOKR  EQU   DIWFLG1
DIWPFERR EQU   DIWFLG1
DIWCISPL EQU   DIWFLG1
DIWCAS   EQU   DIWFLG1
DIWLEN   EQU   IDADIWA+2
DIWID    EQU   IDADIWA
AMDEXCP  EQU   AMDSTAT+44
AMDNCAS  EQU   AMDSTAT+40
AMDNCIS  EQU   AMDSTAT+36
AMDASPA  EQU   AMDSTAT+32
AMDRETR  EQU   AMDSTAT+28
AMDUPR   EQU   AMDSTAT+24
AMDIREC  EQU   AMDSTAT+20
AMDDELR  EQU   AMDSTAT+16
AMDNLR   EQU   AMDSTAT+12
AMDNEXT  EQU   AMDSTAT+10
AMDNIL   EQU   AMDSTAT+8
AMDSTSP  EQU   AMDSTAT
@NM00045 EQU   IDAAMDSB+41
@NM00044 EQU   AMDATTR3
AMDLM    EQU   AMDATTR3
AMDWAIT  EQU   AMDATTR3
AMDBIND  EQU   AMDATTR3
AMDFAULT EQU   AMDATTR3
AMDUNQ   EQU   AMDATTR3
AMDMAXRR EQU   AMDSSRBA
AMDNSLOT EQU   AMDHLRBA
AMDLRECL EQU   IDAAMDSB+24
AMDFSCA  EQU   IDAAMDSB+14
AMDCIPCA EQU   IDAAMDSB+12
AMDPCTCI EQU   IDAAMDSB+11
AMDPCTCA EQU   IDAAMDSB+10
AMDAXRKP EQU   AMDNEST
AMDLEN   EQU   IDAAMDSB+2
AMDSPAN  EQU   AMDATTR
AMDRRDS  EQU   AMDATTR
AMDORDER EQU   AMDATTR
AMDREPL  EQU   AMDATTR
AMDSDT   EQU   AMDATTR
AMDWCK   EQU   AMDATTR
AMDSBID  EQU   IDAAMDSB
BUFCEND  EQU   IDABUFC+64
BUFCUCDN EQU   IDABUFC+60
BUFCUCUP EQU   IDABUFC+56
BUFCMDBT EQU   IDABUFC+52
BUFCHAIN EQU   IDABUFC+48
BUFCNXT2 EQU   IDABUFC+37
BUFCIDXL EQU   IDABUFC+36
BUFCDSPC EQU   IDABUFC+32
BUFCWLEN EQU   BUFCINV
BUFCNXT1 EQU   IDABUFC+24
BUFCCPA  EQU   IDABUFC+16
BUFCAMB  EQU   BUFCPLH
@NM00043 EQU   BUFCFLG2
BUFCEOD  EQU   BUFCFLG2
BUFCBSYW EQU   BUFCFLG2
BUFCBSYR EQU   BUFCFLG2
BUFCNLAS EQU   BUFCFLG2
BUFCXDDR EQU   BUFCFLG2
BUFCFIX  EQU   BUFCIOFL
BUFCPFCP EQU   BUFCIOFL
BUFCXEDB EQU   BUFCIOFL
BUFCWC   EQU   BUFCIOFL
BUFCREAL EQU   BUFCIOFL
BUFCRRD  EQU   BUFCIOFL
BUFCFMT  EQU   BUFCIOFL
BUFCEPT  EQU   BUFCFLG1
BUFCEXC  EQU   BUFCFLG1
BUFCER2  EQU   BUFCFLG1
BUFCER1  EQU   BUFCFLG1
BUFCINS  EQU   BUFCFLG1
BUFCSEG  EQU   BUFCFLG1
BUFCUPG  EQU   BUFCFLG1
BUFCUCNT EQU   BUFCAVL
@NM00042 EQU   IDABUFDR+16
BUFDBUFC EQU   IDABUFDR+12
@NM00041 EQU   BUFDRFLG
BUFDRAVL EQU   BUFDRFLG
BUFDRREL EQU   BUFDRFLG
BUFDRTSB EQU   IDABUFDR+10
BUFDRMAX EQU   BUFDRCIX
BUFDRPFN EQU   IDABUFDR+8
BUFDRPFB EQU   IDABUFDR+4
BUFDRLEN EQU   IDABUFDR+2
BUFDRNO  EQU   IDABUFDR+1
BUFDRID  EQU   IDABUFDR
PLHERRET EQU   IDAPLH+276
PLHASCB  EQU   IDAPLH+272
PLHECB   EQU   IDAPLH+268
@NM00039 EQU   IDAPLH+265
PLHDRMSK EQU   IDAPLH+264
PLHR13   EQU   IDAPLH+260
PLHPARM1 EQU   IDAPLH+256
PLHSLRBA EQU   IDAPLH+244
PLHSRCSG EQU   IDAPLH+242
PLHNOSEG EQU   IDAPLH+240
PLHLLOR  EQU   IDAPLH+236
PLHXPLH  EQU   PLHWAX
@NM00038 EQU   PLHIXSPL+8
PLHIXBFC EQU   PLHIXSPL+4
PLHHIREC EQU   PLHSSRBA
PLHISPLP EQU   IDAPLH+196
PLHRBUFC EQU   IDAPLH+192
PLHNRBA  EQU   IDAPLH+184
PLHDDDD  EQU   PLHEOVPT
PLHAR14  EQU   IDAPLH+176
@NM00037 EQU   IDAPLH+172
@NM00036 EQU   IDAPLH+168
PLHASAVE EQU   IDAPLH+164
PLHRETOS EQU   IDAPLH+118
PLHCHAIN EQU   IDAPLH+112
PLHAMB   EQU   IDAPLH+108
PLHSAVE5 EQU   IDAPLH+100
PLHSAVE4 EQU   IDAPLH+96
PLHSAVE3 EQU   IDAPLH+92
PLHARET  EQU   IDAPLH+80
PLHIIOB  EQU   PLHDIOB
PLHSRSID EQU   IDAPLH+74
PLHNBUFC EQU   IDAPLH+56
@NM00035 EQU   IDAPLH+43
PLHEOVR  EQU   IDAPLH+42
PLHRCODE EQU   IDAPLH+41
PLHUCODE EQU   PLHJCODE
PLHUPECB EQU   PLHJORBA
PLHDSIDA EQU   IDAPLH+24
PLHCRPL  EQU   IDAPLH+20
PLHMRPL  EQU   IDAPLH+16
PLHBFRNO EQU   IDAPLH+15
PLHFRCNT EQU   IDAPLH+14
PLHRMIN  EQU   IDAPLH+13
PLHDSTYP EQU   IDAPLH+12
PLHACB   EQU   IDAPLH+8
PLHRAE   EQU   PLHAFLGS
PLHRABWD EQU   PLHAFLGS
PLHIOSID EQU   PLHAFLGS
PLHDBDC  EQU   PLHAFLGS
PLHVAMB  EQU   PLHAFLGS
PLHIOSRQ EQU   PLHAFLGS
PLHDRLM  EQU   PLHAFLGS
PLHEOVDF EQU   PLHFLG3
PLHRVRS  EQU   PLHFLG3
PLHBWD   EQU   PLHFLG3
PLHSLVLD EQU   PLHFLG3
PLHRAHD  EQU   PLHFLG3
PLHSRBSG EQU   PLHFLG3
@NM00034 EQU   PLHEFLGS+1
PLHRSTRT EQU   PLHEFLGS+1
PLHDSCAN EQU   PLHEFLGS
PLHINVAL EQU   PLHEFLGS
PLHEODX  EQU   PLHEFLGS
PLHSRINV EQU   PLHEFLGS
PLHSKPER EQU   PLHEFLGS
PLH1ST   EQU   PLHEFLGS
PLHNOSPC EQU   PLHEFLGS
PLHIWAIT EQU   PLHFLG2
PLHSVADV EQU   PLHFLG2
PLHKEYMD EQU   PLHFLG2
PLHSQINS EQU   PLHFLG2
PLHUPD   EQU   PLHFLG2
@NM00033 EQU   PLHFLG1
PLHDRPND EQU   PLHFLG1
PLHASYRQ EQU   PLHFLG1
PLHRDEXC EQU   PLHFLG1
PLHSSR   EQU   PLHFLG1
PLHASKBF EQU   PLHFLG1
PLHENDRQ EQU   PLHFLG1
PLHEOVW  EQU   PLHFLG1
PLHATV   EQU   IDAPLH+1
PLHAVL   EQU   IDAPLH
PLHIOSDQ EQU   IDAPLHDR+12
PLHDRCUR EQU   IDAPLHDR+10
PLHDRMAX EQU   IDAPLHDR+8
PLHDRREQ EQU   IDAPLHDR+4
PLHELTH  EQU   IDAPLHDR+2
PLHCNT   EQU   IDAPLHDR+1
PLHID    EQU   IDAPLHDR
AMBTRACE EQU   IDAAMB+120
AMBVIOT  EQU   IDAAMB+116
AMBSZCP  EQU   IDAAMB+114
AMBSZFW  EQU   IDAAMB+112
AMBSZWR  EQU   IDAAMB+110
AMBSZRD  EQU   IDAAMB+108
AMBEXEX  EQU   IDAAMB+100
AMBWSHD  EQU   IDAAMB+96
AMBCPA   EQU   IDAAMB+92
AMBBM2SH EQU   IDAAMB+88
AMBRDCNT EQU   AMBCSWD1+2
@NM00032 EQU   AMBCSWD1+1
@NM00031 EQU   AMBAFLG
AMBCFX   EQU   AMBAFLG
AMBSIS   EQU   AMBAFLG
AMBDFR   EQU   AMBAFLG
AMBICI   EQU   AMBAFLG
@NM00030 EQU   AMBAFLG
AMBUPLH  EQU   IDAAMB+80
AMBPAMBL EQU   IDAAMB+76
AMBPIXP  EQU   IDAAMB+72
@NM00029 EQU   IDAAMB+68
AMBWKA   EQU   IDAAMB+60
AMBAMBXN EQU   AMBEOVPT
AMBEDB   EQU   IDAAMB+52
AMBRPT   EQU   IDAAMB+50
AMBPUG   EQU   AMBFLG2
AMBBUSY  EQU   AMBOFLGS
AMBEXFG  EQU   AMBOFLGS
@NM00028 EQU   AMBOFLGS
AMBOPEN  EQU   AMBOFLGS
@NM00027 EQU   AMBOFLGS
AMBDEBAD EQU   AMBDEBPT+1
AMBIFLGS EQU   AMBDEBPT
AMBAMETH EQU   IDAAMB+43
AMBUCRA  EQU   AMBINFL
AMBSCRA  EQU   AMBINFL
AMBCAT   EQU   AMBINFL
@NM00026 EQU   AMBINFL
@NM00025 EQU   AMBINFL
AMBTIOT  EQU   IDAAMB+40
@NM00024 EQU   IDAAMB+38
AMBDDSN  EQU   IDAAMB+35
AMBCDSN  EQU   IDAAMB+32
AMBIOMB  EQU   AMBIOBAD
@NM00023 EQU   AMBDSORG+1
AMBDORGA EQU   AMBDSORG+1
@NM00022 EQU   AMBDSORG
AMBINBUF EQU   AMBFLG1
AMBUBF   EQU   AMBFLG1
AMBSPEED EQU   AMBFLG1
AMBPCAT  EQU   AMBFLG1
AMBMCAT  EQU   AMBFLG1
AMBTYPE  EQU   AMBFLG1
@NM00021 EQU   AMBFLG0
AMBPSDS  EQU   AMBFLG0
AMBCACB  EQU   IDAAMB+16
AMBBUFC  EQU   IDAAMB+8
AMBLINK  EQU   IDAAMB+4
AMBLEN   EQU   IDAAMB+2
AMBRSC   EQU   IDAAMB+1
AMBID    EQU   IDAAMB
AMBLCMB  EQU   IDAAMBL+64
AMBLBIB  EQU   IDAAMBL+60
AMBLIX   EQU   IDAAMBL+56
AMBLDTA  EQU   IDAAMBL+52
AMBLMIDS EQU   IDAAMBL+42
AMBLNIDS EQU   IDAAMBL+41
@NM00020 EQU   IDAAMBL+40
AMBLNUM  EQU   IDAAMBL+38
AMBLNST  EQU   IDAAMBL+37
@NM00019 EQU   AMBLFLG2
AMBLSTAG EQU   AMBLFLG2
@NM00018 EQU   AMBLFLG2
AMBLDUMY EQU   AMBLFLG1
AMBLCAT  EQU   AMBLFLG1
AMBLUCRA EQU   AMBLFLG1
AMBLSCRA EQU   AMBLFLG1
AMBLVVIC EQU   AMBLFLG1
AMBLUPD  EQU   AMBLFLG1
AMBLCINV EQU   AMBLFLG1
AMBLFULL EQU   AMBLFLG1
AMBLLEN  EQU   IDAAMBL+34
@NM00017 EQU   AMBLSHAR
AMBLWRIT EQU   AMBLSHAR
AMBLCATO EQU   AMBLSHAR
AMBLPRIM EQU   AMBLSHAR
AMBLID   EQU   IDAAMBL+32
@NM00016 EQU   IDAAMBL+31
@NM00015 EQU   AMBLTYPE
AMBLFIX  EQU   AMBLTYPE
AMBLBASE EQU   AMBLTYPE
AMBLAIX  EQU   AMBLTYPE
AMBLUPGR EQU   AMBLTYPE
AMBLPATH EQU   AMBLTYPE
AMBLENO  EQU   AMBLVC+1
AMBLVRT  EQU   AMBLVC
AMBLXPT  EQU   IDAAMBL+24
AMBLDFR  EQU   AMBLQ
AMBLESDS EQU   AMBLQ
AMBLKSDS EQU   AMBLQ
AMBLUBF  EQU   AMBLQ
AMBLFSTP EQU   AMBLQ
AMBLLSR  EQU   AMBLQ
AMBLGSR  EQU   AMBLQ
AMBLDDC  EQU   AMBLQ
AMBLDCI  EQU   AMBLIDF+4
AMBLCACB EQU   AMBLIDF
@NM00014 EQU   AMBLEOV+2
AMBLCOMP EQU   AMBLEOV+1
AMBLESET EQU   AMBLEFLG
AMBLWAIT EQU   AMBLEFLG
AMBLACB  EQU   IDAAMBL+8
AMBLSCHN EQU   IDAAMBL+4
AMBLPCHN EQU   IDAAMBL
ACBAPID  EQU   ACBCOMN+72
ACBCBMWA EQU   ACBCOMN+68
ACBUAPTR EQU   ACBCOMN+64
ACBLRECL EQU   ACBCOMN+62
ACBMSGLN EQU   ACBBLKSZ
ACBBUFSP EQU   ACBCOMN+56
@NM00013 EQU   ACBUJFCB+1
ACBOPTN  EQU   ACBUJFCB
ACBVVIC  EQU   ACBINFLG
ACBUCRA  EQU   ACBINFLG
ACBSCRA  EQU   ACBINFLG
ACBCAT   EQU   ACBINFLG
ACBIJRQE EQU   ACBINFLG
ACBJEPS  EQU   ACBINFLG
@NM00012 EQU   ACBINFLG
ACBERFLG EQU   ACBCOMN+49
ACBBUSY  EQU   ACBIOSFG
ACBLOCK  EQU   ACBEXFG
@NM00011 EQU   ACBOFLGS
ACBDSERR EQU   ACBOFLGS
ACBOPEN  EQU   ACBOFLGS
ACBEOV   EQU   ACBOFLGS
@NM00010 EQU   ACBOFLGS
ACBDEB   EQU   ACBDDNM+5
ACBERFL  EQU   ACBDDNM+4
ACBAM    EQU   ACBAMETH
ACBINFL  EQU   ACBDDNM+2
ACBTIOT  EQU   ACBDDNM
ACBUEL   EQU   ACBEXLST
ACBPASSW EQU   ACBCOMN+32
ACBMSGAR EQU   ACBCOMN+28
@NM00009 EQU   ACBDSORG+1
ACBDORGA EQU   ACBDSORG+1
@NM00008 EQU   ACBDSORG
ACBCRNRE EQU   ACBCROPS
ACBCRNCK EQU   ACBCROPS
ACBASA   EQU   ACBCCTYP
@NM00007 EQU   ACBCCTYP
ACBRECAF EQU   ACBRECFM
ACBJBUF  EQU   ACBBUFPL+2
ACBMACR4 EQU   ACBBUFPL+1
@NM00006 EQU   ACBMACR3
ACBNCFX  EQU   ACBMACR3
ACBSIS   EQU   ACBMACR3
ACBDFR   EQU   ACBMACR3
ACBICI   EQU   ACBMACR3
ACBGSR   EQU   ACBMACR3
ACBLSR   EQU   ACBMACR3
@NM00005 EQU   ACBMACR3
ACBBUFNI EQU   ACBCOMN+18
ACBBUFND EQU   ACBCOMN+16
ACBSTRNO EQU   ACBCOMN+15
ACBBSTNO EQU   ACBCOMN+14
ACBAIX   EQU   ACBMACR2
ACBDSN   EQU   ACBMACR2
ACBRST   EQU   ACBMACR2
ACBLOGON EQU   ACBMACR2
ACBSKP   EQU   ACBMACR2
@NM00004 EQU   ACBMACR2
ACBUBF   EQU   ACBMACR1
ACBOUT   EQU   ACBMACR1
ACBIN    EQU   ACBMACR1
ACBDIR   EQU   ACBMACR1
ACBSEQ   EQU   ACBMACR1
ACBBLK   EQU   ACBCNV
ACBADD   EQU   ACBADR
ACBKEY   EQU   ACBMACR1
ACBINRTN EQU   ACBCOMN+8
ACBIBCT  EQU   ACBJWA
ACBLEN2  EQU   ACBLENG2
ACBSTYP  EQU   ACBCOMN+1
ACBID    EQU   ACBCOMN
RPLERMSA EQU   RPLCOMN+72
RPLEMLEN EQU   RPLCOMN+70
RPLACTIV EQU   RPLCOMN+69
RPLBRANC EQU   RPLEXTD1
RPLNIB   EQU   RPLEXTD1
@NM00003 EQU   RPLEXTD1
RPLEXIT  EQU   RPLEXTD1
RPLNEXIT EQU   RPLEXTD1
RPLEXSCH EQU   RPLEXTD1
@NM00002 EQU   RPLRBAR+3
@NM00001 EQU   RPLAIXID
RPLAXPKP EQU   RPLAIXID
RPLAIXPC EQU   RPLRBAR
RPLRSV88 EQU   RPLOPT8
RPLUNCON EQU   RPLOPT8
RPLACTV  EQU   RPLOPT8
RPLSESS  EQU   RPLOPT8
RPLPEND  EQU   RPLOPT8
RPLODPRM EQU   RPLOPT8
RPLODACP EQU   RPLOPT8
RPLODACQ EQU   RPLOPT8
RPLRSV78 EQU   RPLOPT7
RPLRSV77 EQU   RPLOPT7
RPLRLSOP EQU   RPLOPT7
RPLTPOST EQU   RPLOPT7
RPLQOPT  EQU   RPLOPT7
RPLCNIMM EQU   RPLCNOPT
RPLCNANY EQU   RPLCNOPT
RPLCNALL EQU   RPLCNOPT
RPLRSV68 EQU   RPLOPT6
RPLRSV67 EQU   RPLOPT6
RPLLOCK  EQU   RPLOPT6
RPLNCOND EQU   RPLOPT6
RPLCOND  EQU   RPLOPT6
RPLEOT   EQU   RPLUNTYP
RPLEOM   EQU   RPLUNTYP
RPLEOB   EQU   RPLUNTYP
RPLWROPT EQU   RPLOPT5
RPLNODE  EQU   RPLOPT5
RPLERACE EQU   RPLWRTYP
RPLEAU   EQU   RPLWRTYP
RPLNERAS EQU   RPLWRTYP
RPLPSOPT EQU   RPLOPT5
RPLSSNIN EQU   RPLOPT5
RPLDLGIN EQU   RPLOPT5
RPLBUFL  EQU   RPLCOMN+52
RPLCHAIN EQU   RPLNXTRP
RPLOPT4  EQU   RPLOPTCD+3
RPLALIGN EQU   RPLOPT3
RPLFMT   EQU   RPLOPT3
RPLFLD   EQU   RPLOPT3
RPLVFY   EQU   RPLOPT3
RPLBLK   EQU   RPLOPT3
RPLSFORM EQU   RPLOPT3
RPLEODS  EQU   RPLOPT3
RPLNSP   EQU   RPLOPT2
RPLWAITX EQU   RPLOPT2
RPLLRD   EQU   RPLOPT2
RPLCNV   EQU   RPLOPT2
RPLADD   EQU   RPLADR
RPLKEY   EQU   RPLOPT2
RPLECBIN EQU   RPLECBSW
RPLGEN   EQU   RPLOPT1
RPLKGE   EQU   RPLOPT1
RPLASY   EQU   RPLOPT1
RPLSKP   EQU   RPLOPT1
RPLDIR   EQU   RPLOPT1
RPLLOC   EQU   RPLOPT1
RPLDAF   EQU   RPLARG+2
RPLSAF   EQU   RPLARG
RPLTCBPT EQU   RPLCOMN+28
RPLCCHAR EQU   RPLCOMN+20
RPLSTRID EQU   RPLCOMN+18
RPLKEYL  EQU   RPLKEYLE
RPLRDSOH EQU   RPLFDB3
RPLRLG   EQU   RPLFDB3
RPLLGFRC EQU   RPLFDB3
RPLREOT  EQU   RPLFDB3
RPLREOM  EQU   RPLFDB3
RPLREOB  EQU   RPLFDB3
RPLSV32  EQU   RPLFDB3
RPLUINPT EQU   RPLFDB3
RPLSTSAV EQU   RPLFDB2
RPLCUERR EQU   RPLFDB2
RPLDLGFL EQU   RPLFDB2
RPLIOERR EQU   RPLFDB2
RPLDVUNS EQU   RPLFDB2
RPLATND  EQU   RPLFDB2
RPLRVID  EQU   RPLFDB2
RPLERLK  EQU   RPLFDB2
RPLSTAT  EQU   RPLFDBWD
RPLPOST  EQU   RPLECB
RPLWAIT  EQU   RPLECB
RPLPLHPT EQU   RPLCOMN+4
RPLLEN2  EQU   RPLLEN
RPLREQ   EQU   RPLIDWD+2
RPLSTYP  EQU   RPLIDWD+1
RPLID    EQU   RPLIDWD
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RT00185 EQU   KRERROR
@RT00189 EQU   CIFULL
@RF00192 EQU   @RC00174
@RF00202 EQU   @RC00174
@RT00235 EQU   CIFULL
@RT00247 EQU   CIFULL
@RC00318 EQU   @RC00313
@RF00389 EQU   DISTART
@RT00434 EQU   KRERROR
@RT00439 EQU   KRERROR
@ENDDATA EQU   *
         END   IDA019RM,(C'PLS2054',0701,78172)
