         TITLE 'LOGIC FOR IEDTPEDT MACRO'
IEDTEDIT CSECT
*
*        VS1 APAR = VS2 APAR
*         OX02569 = OY02458
*
***********************************************************************
* FUNCTION     PROVIDES PROGRAM LOGIC FOR IEDTPEDT MACRO. EDITS DATA
*              FROM 50 MDI
*
* INPUT        REGISTER 1 CONTAINS A POINTER TO A PARAMETER LIST
*              PROVIDED BY THE USER
*
*              REGISTER 0 CONTAINS A POINTER TO THE EDIT OPTIONS
*              SPECIFIED IN THE IEDTPEDT MACRO
*
*              REGISTER 13 CONTAINS A POINTER TO A 72 BYTE SAVE AREA
*
*              REGISTER 14 CONTAINS THE RETURN ADDRESS
*
* OUTPUT       REGISTER 1 CONTAINS A POINTER TO A PARAMETER LIST WHICH
*              CONTAINS THE RECORD ADDRESS AND ADDRESS OF THE RECORD
*              LENGTH
*
* ENTRY        THE FIRST EXECUTABLE INSTRUCTION
*
* EXITS        USER ERROR EXIT ROUTINE IF ONE IS SPECIFIED
*
* ATTRIBUTES   REENTRANT
*
***********************************************************************
         SR    RTCDRG,RTCDRG       ZERO REG 15
         STM   RETRNRG,BASERG,12(SAVERG) SAVE USERS REGISTERS
         BALR  BASERG,0            LOAD BASE REGISTER
         USING *,BASERG
         USING PARMLIST,PRMLSTRG   SET UP AND LOAD
         B     A
         DC    CL8'IEDTEDIT'            MODULE IDENTIFIER
         DC    XL2'7354'                REVISION DATE
         DS    CL48                     PATCH AREA
A        DS    0F
         LR    PRMLSTRG,PARMRG1    DSECT REG FOR USER PARM LIST
         USING EDITPARM,EDTPRMRG   SET UP AND LOAD
         LR    EDTPRMRG,PARMRG0    DSECT REG FOR MACRO PARMS
         USING WORKSTOR,WRKSTRG    SET UP AND LOAD
         SR    WRKRG2,WRKRG2       ZERO REG FOR COMPARE
         CL    WRKRG2,PRMWRKAD     IS PTR TO WORK AREA ZERO
         BNE   LOADRG              BR IF NO TO LOAD REG FOR DSECT BASE
         L     WRKRG2,PRMMXRCL     GET MAX RCD LNG
         LA    WRKRG2,96(WRKRG2)   ADD FIXED NO BYTES RQD
         TM    EDTTYPSW,HEX08      IS USER EXIT SPECIFIED
         BO    NOEXIT              BR IF NO
         LA    WRKRG2,76(WRKRG2)
NOEXIT   TM    EDTTYPSW,HEX40      DOES RECFM = V
         BZ    RECFMNTU            BR IF NO
         LA    WRKRG2,4(WRKRG2)
RECFMNTU SRL   WRKRG2,3            DIVIDE BY 8
         SLL   WRKRG2,3            MULTIPLY BY 8
         LR    PARMRG0,WRKRG2      PUT CORE RQMT IN REG 0 FOR GETMAIN
         GETMAIN R,LV=(0)
         ST    PARMRG1,PRMWRKAD    SAVE PTR TO CORE OBTAINED
         OI    PRMMXRCL,HEX40      INDICATE GETMAIN ISSUED
LOADRG   L     WRKSTRG,PRMWRKAD    LOAD DSECT REG FOR WORK STORAGE
         TM    PRMMXRCL,HEX80      IS THIS THE BEGINING OF CARTRIDGE
         BO    NOFORMAT            BR IF NO
*
* * *  FORMAT WORKING STORAGE  * * *
*
FORMAT   XC    WRKADRRC(84),WRKADRRC ZERO OUT CONSTANT AREA
         OI    PRMMXRCL,HEX80      IND NOT BEG OF CARTRIDGE
         ST    WRKRG2,WRKLNGSV     SAVE LENGTH OF CORE OBTAINED
         MVI   WRKLEVST,CHAR0      RESET LEVEL STATUS
         LA    PARMRG1,WRKSVLZJ+8  GET ADDR OF RCD LNG
         ST    PARMRG1,WRKSVLZJ+4  SAVE ADDR OF RCD LNGTH
         LA    PARMRG1,WRKMACSV    POINT TO END OF RCD LENGTH
         TM    EDTTYPSW,HEX08      IS USER EXIT SPECIFIED
         BO    HUITCLOS            BR IF NO
         LA    PARMRG1,76(PARMRG1)
HUITCLOS TM    EDTTYPSW,HEX40      DOES RECFM = V
         BZ    RECFMU              BR IF NO
         LA    PARMRG1,4(PARMRG1)
RECFMU   ST    PARMRG1,WRKNXAVW    SAVE PTR TO NEXT AVAIL WORK
         AH    PARMRG1,PRMMXRCL+2  POINT TO END OF WORK + 1
         ST    PARMRG1,WRKENWRK    SAVE PTR TO END OF WORK
         SH    PARMRG1,PRMMXRCL+2  RESTORE PTR TO BEG OF WORK
         ST    PARMRG1,WRKADRRC    SAVE PTR TO RCD
         OI    WRKEDSW1,HEX0A      EXPECT SOR AND DO NOT ALLOW DUP
         L     PARMRG1,PRMINPUT    GET PTR TO INPUT
         ST    PARMRG1,WRKADNXB    SAVE PTR TO INPUT
NOFORMAT TM    WRKEDSW2,HEX08      WAS INPUT EMPTY AFTER LAST REC
         BO    CKPARRCD            BR IF NO
         L     PARMRG1,WRKADNXB    GET PTR TO NEXT BUFFER
         LTR   PARMRG1,PARMRG1     ANY BUFFERS LEFT
         BNZ   GETBUF              BR IF YES
         L     PARMRG1,PRMINPUT    GET POINTER TO INPUT
         ST    PARMRG1,WRKADNXB    SAVE PTR TO NEXT BUFFER
GETBUF   OI    WRKEDSW2,HEX08      INDICATE INPUT NOT EMPTY
         AH    PARMRG1,PRMIPTLN+2  POINT TO INPUT END + 1
         ST    PARMRG1,WRKENIPT    AND SAVE
         SH    PARMRG1,PRMIPTLN+2  RESTORE PTR TO INPUT
         TM    EDTTYPSW,HEX10      ARE USING BTAM BUFFERS
         BZ    NOBUF1              BR IF NO
         L     WRKRG2,0(PARMRG1)   PICK UP PTR TO NEXT BUFFER
         LA    WRKRG2,0(WRKRG2)    ZERO HIGH ORDER BYTE
         ST    WRKRG2,WRKADNXB     SAVE PTR TO NEXT AVAIL BUFFER
         LA    PARMRG1,4(PARMRG1)  INCR PAST CHAIN FIELD
NOBUF1   BCTR  PARMRG1,0           DECRE INPUT POINTER
         ST    PARMRG1,WRKNXAVI    AND SAVE
CKPARRCD TM    WRKEDSW2,HEX01      WAS LAST RCD A PARTIAL RCD
         BO    PTAGN               BR IF YES
ZROTYPST MVI   WRKTYPST,HEX00      ZERO TYPE STATUS
         SR    WRKRG2,WRKRG2
         STH   WRKRG2,WRKLZFCT     ZERO PREVIOUS COUNT OF LZF
PTAGN    BAL   LNKRG8,PTINPUT      GO POINT TO NEXT AVAIL IN INPUT
         NI    WRKEDSW2,HEXFE      RESET POSSIBLE PARTIAL RCD INDICATOR
         CLI   0(PARMRG1),HEX19    END OF DATA CODE
         BE    ENDDATA             BR IF YES
         CLI   0(PARMRG1),DLE      IS FIRST CHAR A DLE
         BE    PTAGN               BR IF YES TO POINT TO NEXT BYTE
         CLI   0(PARMRG1),STX      IS FIRST CHAR A STX
         BE    PTAGN               BR IF YES
         CLI   0(PARMRG1),ETB      IS THIS BSC END CHAR
         BE    BSCCHARS            BR IF YES
         CLI   0(PARMRG1),HEX03    IS THIS BSC END CHAR
         BE    BSCCHARS            BR IF YES
         TM    WRKEDSW2,HEX10      IN LEFT ZERO MODE?          @XA02569
         BO    CMPRLZF             BR IF YES                   @XA02569
         TM    WRKEDSW1,HEX08 *    IS SOR EXPECTED
         BZ    CONTSCAN            BR IF NO TO CONTINUE SCAN
         NI    WRKEDSW1,HEXF7      RESET EXPECTED SOR SW
         SR    WRKRG4,WRKRG4
         IC    WRKRG4,0(PARMRG1)   GET CHAR IN SOR LOCATION
         LA    WRKRG3,HEX78+1
         LA    WRKRG5,HEX71-1      INIT SCAN FOR PROGRAM LEVEL CODES
SCNPGMLV LA    WRKRG5,1(WRKRG5)
         CLR   WRKRG5,WRKRG4       IS THIS BYTE A PROG LEVEL CODE
         BE    PGMLVFND            BR IS YES
         CLR   WRKRG5,WRKRG3       HAS SCAN EXCEEDER RANGE OF PL CODES
         BL    SCNPGMLV            BR IF NO TO CONT SCAN
         CLI   0(PARMRG1),HEXCAN   IS THIS A CANCEL CODE
         BE    CANFND              BR IF YES
         CLI   0(PARMRG1),HEXGS    IS THIS A GS CODE
         BE    GSFND               BR IF YES
         OI    WRKTYPST,HEX01      INDICATE SOR/EOR ERROR IN TYPE STAT
         MVI   WRKSORSV,HEX0E      SET SOR ERROR IN ERROR DESCRIPTION
         B     CKKPSOR1
CANFND   OI    WRKEDSW1,HEX82      SET ON DELET SW AND DO NOT ALLOW DUP
         MVI   WRKLEVST,HEXF0      RESET LEVEL STATUS
         B     PTAGN               BR TO CONT SCAN
GSFND    OI    WRKEDSW1,HEX08      SET EXPECT SOR SWITCH ON
         B     PTAGN
CONTSCAN L     WRKRG3,WRKENIPT     GET INPUT END + 1
         SR    WRKRG3,PARMRG1      GET LNG OF BUFFER REMAINING
         LTR   WRKRG3,WRKRG3       IS INPUT EMPTY
         BP    L256CK              BR IF NO
         BCTR  PARMRG1,0           DECR PTR TO NXT AVAIL IN IPT
         B     NOCDS1
L256CK   C     WRKRG3,LGT256       ARE THERE MORE THAN 256 BYTES LEFT
         BNH   DECRRG              BR IF NO
         L     WRKRG3,LGT256       SET LENGTH TO 256
DECRRG   BCTR  WRKRG3,0            DECR LENGTH
         LR    WRKRG5,PARMRG1      ADDR OF FIRST BYTE TO BE SCANNED
         AR    WRKRG5,WRKRG3       PLUS SCAN LNG - 1
         ST    WRKRG5,WRKNXAVI     GIVES INPUT PTR IF NO SPECIAL CODES
         ST    WRKRG5,WRKENSCN     STORE AS END OF SCANNED
         SR    WRKRG2,WRKRG2       PREPARE FOR TRT
         EX    WRKRG3,TRTTBL       TRANSLATE AND TEST
         BC    8,NOSPECCD          BR IF NO SPECIAL CODES FOUND
         ST    PARMRG1,WRKNXAVI    SAVE LAST SCANNED AS INPUT PTR
         TM    WRKEDSW1,HEX80      IS THIS RECORD BEING DELETED
         BZ    BRTBL               BR IS NO
         CH    WRKRG2,TWOOH        IS THIS END OF DELETED RECORD
         BL    PTAGN
BRTBL    B     BRNCHTBL-4(WRKRG2)  BR TO BR TABLE TO HANDLE NONZERO
NOSPECCD L     PARMRG1,WRKENSCN    GET END OF SCANNED
         L     WRKRG6,WRKENIPT     IS END OF SCANNED NOW
         BCTR  WRKRG6,0            POINTING AT LAST
         CR    WRKRG6,PARMRG1      BYTE IN THIS BUFFER
         BNE   CKCANRCD            BR IF NO
NOCDS1   OI    WRKEDSW2,HEX01      IND PARTIAL RCD
         NI    WRKEDSW2,HEXF7      INDICATE IPT EMPTY
         TM    WRKEDSW1,HEX80      IS  RCD BEING DELETED
         BZ    SETRTURN            BR IF NO
         TM    EDTTYPSW,HEX10      ARE USING BTAM BUFFERS
         BZ    DELETRCD            BR IF NO
         L     PARMRG1,WRKADNXB    GET PTR TO NEXT BUFFER
         LTR   PARMRG1,PARMRG1     ARE ANY BUFFERS LEFT
         BNZ   GETBUF              BR IF YES TO POINT TO NEXT BUFFEÖ
DELETRCD MVI   19(SAVERG),HEX08    IND IPT EMPTY RCD NOT AVAIL
         B     RETURNX
CKCANRCD TM    WRKEDSW1,HEX80      IS RECORD BEING DELETED
         BO    PTAGN               BR IF YES
         B     SETRTURN            GO MOVE IT OUT
*
* * *  BRANCH TABLE * * *
*
TRTTBL   TRT   0(0,PARMRG1),TRNSTBLE
BRNCHTBL B     LEFTZROF *          LEFT ZERO FILL
         B     DUP      *          DUP
         B     LFTZROST *          LEFT ZERO START
         B     CANCEL   *          CANCEL
         B     PTAGN    *          GROUP SEPARATOR CODES
         B     BSCCHARS *          BCS CHARS
         B     DATACK   *          DATA CHECK -2772 REPLACE CHARACTER
         B     ENDDATA             END OF DATA ON CARTRIDGE
         B     RMORVOK  *          RECORD MARK OR VERIFY OK
         B     PGMLEVEL *          PROGRAM LEVEL 1-8
*
* * * END OF BRANCH TABLE * * *
*
* *  HANDLE LEFT ZERO FILL CODES
LEFTZROF TM    WRKEDSW1,HEX40      HAS A LEFT ZERO START BEEN FOUND
         BZ    NOLZSFND            BR IF NO
LZFCNT   LH    WRKRG2,WRKLZFCT     PICK UP COUNT OF LA FIL CHARS
         LA    WRKRG2,1(WRKRG2)    INCR COUNT OF LZF
         STH   WRKRG2,WRKLZFCT     AND SAVE
         MVC   0(1,PARMRG1),EDTREPCR  MOVE IN REP CHAR IN CASE FLD
         OI    WRKEDSW2,HEX10      INDICATE LZF FOUND
*                                     REMAINS UNJUSTIFIED
         BAL   LNKRG8,MOVERTN      GO MOVE IT OUT
         BAL   LNKRG8,PTINPUT      GO POINT TO NEXT BYTE
         TM    WRKEDSW2,HEX08      IS INPUT EMPTY
         BZ    RETURNX             BR IF YES
         CLI   0(PARMRG1),ETB      IS THIS BSC END CHAR
         BE    BSCCHARS            BR IF YES
         CLI   0(PARMRG1),HEX03    IS THIS BSC END CHAR
         BE    BSCCHARS            BR IF YES
CMPRLZF  CLI   0(PARMRG1),HEXLZF   IS THIS ALSO A LEFT ZERO FILL
         BE    LZFCNT              BR IF YES TO CONT SCAN FOR LZF
         OI    WRKEDSW1,HEX20      INDICATE END OF LZ FIELD
         NI    WRKEDSW2,HEXEF      RESET LZ MODE SW
         BCTR  PARMRG1,0           DECR INPUT POINTER
         ST    PARMRG1,WRKNXAVI    STORE INPUT POINTER
         B     SETRTURN            GO SET UP FOR ADJUST
NOLZSFND MVC   0(1,PARMRG1),EDTREPCR REPLACE FIELD ERROR BYTE
         OI    WRKTYPST,HEX04      INDICATE FIELD ERROR IN TYPE STATUS
         B     SETRTURN            GO MOVE IT OUT
         SPACE 1
* * HANDLE DUP CODES
DUP      NI    WRKEDSW1,HEX9F      RESET POSSIBLE LEFT ZERO
         BCTR  PARMRG1,0           DECR INPUT POINTER
         ST    PARMRG1,WRKNXAVI    STORE PREV ADDR AS INPUT POINTER
         BAL   LNKRG8,MOVERTN      GO MOVE OUT ALL UP TO DUP
         BAL   LNKRG8,PTINPUT      POINT TO DUP AGAIN
         OI    WRKEDSW1,HEX01      INDICATE DUP FOUND IN THIS RECORD
         TM    WRKEDSW1,HEX02      IS DUP ALLOWED
         BO    NOLZSFND            BR IF NO
         L     WRKRG5,WRKNXAVW     GET NEXT AVAIL IN WORK
         L     WRKRG6,WRKLDBPV     GET PTR TO LAST DATA BYTE PREV RCD
         TM    EDTTYPSW,HEX80      ARE TO KEEP SOR/EOR CHARS
         BZ    CMPR8               BR IF NO
         BCTR  WRKRG6,0            DECR PTR TO LAST DATA BYTE PREV RCD
CMPR8    CR    WRKRG5,WRKRG6       IS DUP BEYOND END OF PREV RCD
         BH    NOLZSFND            BR IF YES TO INDICATE FIELD ERROR
         CLC   0(WRKRG5),EDTREPCR  IS BYTE TO BE DUPED A REPLACE CHAR
         BE    NOLZSFND            BR IS YES
         MVC   0(1,PARMRG1),0(WRKRG5) PERFORM DUPLICATION
         B     SETRTURN            GO MOVE IT OUT
         SPACE 1
* *  HANDLE LEFT ZERO START CODES
LFTZROST BCTR  PARMRG1,0           DO NOT MOVE LEFT ZERO START
         BAL   LNKRG8,MOVERTN      MOVE OUT ALL UP TO LEFT ZERO START
         OI    WRKEDSW1,HEX40      INDICATE LZ START
         MVC   WRKFBLZF,WRKNXAVW   SAVE ADDR OF START OF LZ FIELD
         B     PTAGN
         SPACE 1
* *  HANDLE VERIFY OK OR RECORD MARK
RMORVOK  NI    WRKEDSW1,HEX9F      RESET POSSIBLE LZ MODE
         OI    WRKEDSW1,HEX08      SET EXPECT SOR SWITCH ON
         TM    WRKEDSW1,HEX80      IS THIS RECORD BEING DELETED
         BO    RECDEL              BR IF YES
         MVI   WRKEORSV,CVOK       SET VOK IND IN ERROR DESCRIPTION
         CLI   0(PARMRG1),HEXVOK   WAS EOR AN IRS(VOK) CODE
         BE    VOK                 BR IF YES
         MVI   WRKEORSV,CRM        SAVE RM INDICATOR IN EDW
         TM    EDTTYPSW,HEX20      MUST EOR BE VOK
         BZ    VOK                 BR IF NO
         OI    WRKTYPST,HEX01      INDICATE SOR/EOR ERROR IN EDW
VOK      TM    EDTTYPSW,HEX80      IS EOR TO BE RETAINED
         BO    EORRTAIN            BR IF YES
         BCTR  PARMRG1,0           DECR INPUT PTR SO EOR NOT MOVED OUT
EORRTAIN B     SETRTURN            GO MOVE IT OUT
RECDEL   NI    WRKEDSW1,HEX7F      SET OFF DELETE SWITCH
         B     PTAGN               GO CONT SCAN
         SPACE 1
* *  HANDLE PROGRAM LEVEL CODES
PGMLEVEL TM    WRKEDSW1,HEX80      IS THIS RECORD BEING DELETED
         BZ    CANCEL              BR IF NO TO FORCE END OF PREV RCD
         NI    WRKEDSW1,HEX7F      SET OFF DELETE SW
PGMLVFND MVC   WRKSORSV(1),0(PARMRG1) SAVE IT AS SOR IN EDW
         NI    WRKSORSV,HEX0F      PUT IN FORM OF HEX 0X
CKKPSOR1 TM    EDTTYPSW,HEX80      SOR TO BE RETAINED
         BZ    PTAGN               BR IF NO TO CONT SCAN
         ST    PARMRG1,WRKFBSCN    SAVE AS START
         B     SETRTURN            GO MOVE IT OUT
CANCEL   OI    WRKEDSW1,HEX08      SET EXPECT SOR SW ON
         NI    WRKEDSW1,HEX9F      RESET POSSIBLE LZ MODE
         OI    WRKTYPST,HEX01      INDICATE SOR/EOR ERROR
         MVI   WRKEORSV,CHE        IND EOR ERROR IN EDW
         BCTR  PARMRG1,0           DECR INPUT POINTER
         ST    PARMRG1,WRKNXAVI    STORE INPUT POINTER
         TM    EDTTYPSW,HEX80      EOR TO BE RETAINED
         BO    NOEOR               BR IF YES
         BCTR  PARMRG1,0           DECR INPUT PTR SO EOR NOT MOVED
NOEOR    OI    WRKEDSW1,HEX04      INDICATE EOR FORCED
         B     SETRTURN            GO MOVE IT OUT
         SPACE 1
* *  HANDLE DATA CHECK  - 2772 REPLACE CHARS X'3F'
DATACK   MVC   0(1,PARMRG1),EDTREPCR REPLACE DATA CK IND WITH REP CHAR
         OI    WRKTYPST,HEX08      IND DATA CHECK IN TYPE STATUS
         BAL   LNKRG8,MOVERTN      GO MOVE IT OUT
         BAL   LNKRG8,PTINPUT      POINT TO NEXT BYTES
         CLI   0(PARMRG1),HEX3F    IS THIS DATA CK BYTE ALSO
         BO    DBLDC               BR IF YES
         BCTR  PARMRG1,0           DECR INPUT POINTER
         ST    PARMRG1,WRKNXAVI    STORE INPUT POINTER
         B     PTAGN
DBLDC    MVC   0(1,PARMRG1),EDTREPCR REPLACE DATA CK IND WITH REP CHAR
         OI    WRKEDSW2,HEX02      INDICATE DOUBLE DATA CK
         B     SETRTURN            GO MOVE IT OUT
         SPACE 1
* *  HANDLE BSC CHARACTERS
BSCCHARS OI    WRKEDSW2,HEX04      INDICATE BSC END CHAR FOUND
         BCTR  PARMRG1,0           DECR PTR TO IPT
         TM    WRKEDSW1,HEX08      IS SOR EXPECTED
         BZ    NOCDS1
         NI    WRKEDSW2,HEXF7      IND IPT EMPTY
         MVI   19(SAVERG),HEX08    IND IPT EMPTY RCD NOT AVAIL
         B     RETURN
         SPACE 1
* * HANDLE END OF DATA CODE
ENDDATA  TM    WRKEDSW1,HEX08      IS SOR EXPECTED
         BZ    CANCEL              BR IF NO TO FORCE END OF PREV RCD
         MVI   19(SAVERG),HEX0C    IND LAST RCD
         NI    PRMMXRCL,HEX7F      IND BEG OF CARTRIDGE
         TM    PRMMXRCL,HEX40      WAS GETMAIN ISSUED
         BZ    RETRNZ              BR IF NO
         L     PARMRG1,PRMWRKAD    GET PTR TO CORE OBTAINED VIA GETMAIN
         L     PARMRG0,WRKLNGSV    GET LNG OF CORE OBTAINED
         SR    WRKRG2,WRKRG2
         ST    WRKRG2,PRMWRKAD     ZERO PTR TO WORK STORAGE
         FREEMAIN R,LV=(0),A=(1)
RETRNZ   NI    PRMMXRCL,HEXBF      RESET GETMAIN SW
         B     RETURNX             RETURN TO USER
SETRTURN LA    LNKRG8,PTAGN        SET RETURN ADDR FROM MOVE RTN
*
* * *  MOVE ROUTINE  * * *
*
MOVERTN  L     WRKRG5,WRKNXAVW     GET ADDR OF NEXT AVAIL IN WORK
         L     WRKRG7,WRKFBSCN     GET ADDR OF FIRST BYTE SCANNED
         LR    WRKRG4,PARMRG1      ADDR OF LAST BYTE SCANNED
         LA    WRKRG4,1(WRKRG4)    GET END OF SCANNED +1
         SR    WRKRG4,WRKRG7       CALC LENGTH OF SCANNED
         BNP   NOBYTES             BR IF NO BYTES TO BE MOVED
         L     WRKRG6,WRKENWRK     GET END OF WORK AREA + 1
         SR    WRKRG6,WRKRG5       CALC NO BYTES AVAIL IN WORK AREA
         CR    WRKRG4,WRKRG6       WILL ALL SCANNED BYTES FIT IN WORK
         BNH   MVSCN               BR IF YES TO MOVE SCANNED
         OI    WRKEDSW1,HEX10      INDICATE NOT ALL FIT
         NI    WRKEDSW2,HEXFE      RESET POSSIBLE PARTIAL RCD IND
         LTR   WRKRG4,WRKRG6       WILL ANY BYTES FIT
         BNP   RCDTOOLG            BR IF NO
MVSCN    BCTR  WRKRG4,0            DECR LNG FOR EXECUTE
         EX    WRKRG4,MOVESCND     MOVE SCANNED FROM INPUT TO WORK AREA
         LA    WRKRG4,1(WRKRG4)    RESTORE LNG
         AR    WRKRG7,WRKRG4       CALC ADDR OF FIRST BYTE NOT MOVED
         ST    WRKRG7,WRKFBSCN     FROM INPUT TO WORK AREA
         TM    EDTTYPSW,HEX80      ARE TO KEEP SOR/EOR CHARS
         BZ    DONOTKP             BR IF NO
         BCTR  WRKRG7,0            DECR POINTER TO NXT AV IPT
DONOTKP  AR    WRKRG5,WRKRG4       CALC NEXT AVAIL WORK
         ST    WRKRG5,WRKNXAVW     SAVE ADDR OF NEXT AVAIL WORK
         TM    WRKEDSW1,HEX10      DID ALL SCANNED FIT
         BO    RCDTOOLG            BR IF NO
NOFCREOR TM    WRKEDSW1,HEX08      WAS END OF RECORD FOUND
         BO    ENDRCFND            BR IF YES
         TM    WRKEDSW2,HEX01      IS THIS A PARTIAL RCD
         BO    ENDRCFND            BR IF YES
         TM    WRKEDSW1,HEX20      WAS END OF LZ FIELD FOUND
         BCR   8,LNKRG8            BR IF NO TO CALLING RTN
         SPACE 1
* * LEFT ZERO JUSTIFICATION
LZJSTRTN NI    WRKEDSW1,HEX9F      SET OFF LZ MODE
         L     WRKRG4,WRKFBLZF     GET ADDR OF START OF LZ FIELD
         LH    WRKRG3,WRKLZFCT     GET COUNT OF LZ FILLS
         SR    WRKRG5,WRKRG4       CALC FIELD LNG
         CH    WRKRG5,HLF15        DOES FIELD LNG EXCEED 15
         BNH   ADJUST              BR IF NO TO ADJUST
         OI    WRKTYPST,HEX04      INDICATE FIELD ERROR
         BR    LNKRG8              RETURN TO CALLING RTN
ADJUST   SR    WRKRG5,WRKRG3       GET NO OF SIGNIFICANT DIGITS
         BCTR  WRKRG5,0            DECR LNG FOR EXECUTE
         LR    WRKRG6,WRKRG4       ADDR OF START OF LZ FIELD IN WORK
         AR    WRKRG6,WRKRG3       FIELD START + LZ FILL COUNT
         EX    WRKRG5,MVSIGDGT     MOVE SIGNIFICANT DIGITS TO HOLD AREA
         EX    WRKRG5,MVDGTWRK     MOVE SIGNIFICANT DIGITS TO RIGHT
MVZROFIL MVI   0(WRKRG4),HEXF0     MOVE ZERO FILL
         LA    WRKRG4,1(WRKRG4)    INCR WORK ADDR
         BCT   WRKRG3,MVZROFIL     BR IF NOT ALL FILLED
         STH   WRKRG3,WRKLZFCT     ZERO COUNT FIELD
         BR    LNKRG8              RETURN TO CALLING ROUTINE
MVSIGDGT MVC   WRKSVLZJ(0),0(WRKRG4) USED BY EXECUTE TO
MVDGTWRK MVC   0(0,WRKRG6),WRKSVLZJ  RIGHT JUSTIFY FIELD
         SPACE 1
* *  THIS ROUTINE IS ENTERED FOR RECORDS WHICH EXCEED USER SPECIFIED *
* *      RECORD  LENGTH
RCDTOOLG OI    WRKTYPST,HEX03      INDICATE SOR/EOR AND LENGTH ERROR
         MVI   WRKEORSV,CHE        SET EOR ERROR IN ERROR DESCRIPTION
         OI    WRKEDSW1,HEX08      SET EXPECT SOR SW ON
         OI    WRKEDSW2,HEX08      IND IPT NOT EMPTY
         ST    WRKRG7,WRKNXAVI     SAVE ADDR AS INPUT POINTER
         TM    WRKEDSW1,HEX40      IN LZ MODE
         BZ    ENDRCFND            BR IF NO
         SR    PARMRG0,PARMRG0     ZERO REG FOR COMPARE
         CH    PARMRG0,WRKLZFCT    ANY LZ FILLS FOUND
         BE    ENDRCFND            BR IF NO
         ST    PARMRG0,WRKLZFCT    SET CNT FIELD TO ZERO
         BCTR  WRKRG5,0            POINT TO LAST BYTE MOVED TO WORKAREA
         CLC   0(1,WRKRG5),EDTREPCR WAS LAST MOVED A FILL CHAR
         BNE   CKKPSOR             BR IF NO
         OI    WRKTYPST,HEX04      INDICATE A FIELD ERROR IN TYPE STAT
CKKPSOR  TM    EDTTYPSW,HEX80      RETAIN SOR/EOR BYTES SPECIFIED
         BZ    SETUP               BR IF NO
         BCTR  WRKRG5,0            POINT TO LAST MOVED TO WORK
         B     SETUP               GO SET UP TO OUTPUT RCD
NOBYTES  TM    EDTTYPSW,HEX80      PRE TO KEEP SOR/EOR CHARS
         BO    NOFCREOR            BR IF YES
         TM    WRKEDSW1,HEX04      WAS EOR FORCED
         BZ    NOFCREOR            BR IF NO
         BCTR  WRKRG5,0            DECR ADDR NEXT WORK SO BAD
         ST    WRKRG5,WRKNXAVW     EOR NOT RETAINED AS PART OF RCD
ENDRCFND BCTR  WRKRG5,0            POINT TO LAST MOVED TO WORK
SETUP    L     PARMRG1,WRKNXAVI    GET POINTER TO INPUT
         LA    PARMRG1,1(PARMRG1)  POINT NEXT AVAIL BYTE
BALROUT  BAL   LNKRG8,CKINPUT      GO SET STATUS OF INPUT
         TM    WRKEDSW2,HEX08      IS INPUT EMPTY
         BZ    IPTNTEPT            BR IF NO
         BCTR  PARMRG1,0           DECR POINTER TO INPUT
         ST    PARMRG1,WRKNXAVI    SAVE AS NEXT AVAIL IN INPUT
IPTNTEPT TM    WRKEDSW2,HEX01      IS THIS PARTIAL RCD
         BO    RETURN              BR IF YES
         L     PARMRG0,WRKADRRC    GET ADDR OF RCD
         L     PARMRG1,WRKNXAVW    GET PTR TO NEXT AVAIL IN WORK
         ST    PARMRG0,WRKNXAVW    REINIT PTR TO NEXT AVAIL WORK
         SR    PARMRG1,PARMRG0     CAL LENGTH OF RCD
         TM    EDTTYPSW,HEX80      ARE SOR/EOR CHARS TO BE RETAINED
         BO    CKLNFR3             BR IF YES
         LTR   PARMRG1,PARMRG1     IS RCD LENGTH AT LEAST ONE
         BZ    CKPARRCD            BR IF NO
         BP    SVLSTBYT            BR IF YES TO PASS IT
DONTPASS OI    WRKEDSW1,HEX02      RESET EDT SW AND DO NOT ALLOW DUP
         NI    WRKEDSW1,HEX0A      RESET EDIT SW
         NI    WRKEDSW2,HEX88
         MVI   WRKLEVST,CHAR0      RESET LEVEL STATUS
         B     ZROTYPST            GO ZERO TYPE STATUS
CKLNFR3  CH    PARMRG1,THREE       IS RCD LENGTH AT LEAST 3
         BL    DONTPASS            BR IF NO
SVLSTBYT ST    WRKRG5,WRKLDBPV     SAVE LAST DATA BYTE IN RCD
         ST    PARMRG1,WRKSVLZJ+8  SAVE LNG OF RCD
*
* * *  OUTPUT ROUTINE  * * *
OUTPUT   TM    WRKEDSW2,HEX01      IS THIS PARTIAL RCD
         BO    RETURN              BR IF YES
         CLI   WRKSORSV,HEX0E      WAS SOR IN ERROR
         BO    WRNGLN              BR IF YES
         SR    WRKRG4,WRKRG4       SET TO ZERO FOR COMPARE
         SR    WRKRG5,WRKRG5       SET TO ZERO FOR CALC
         IC    WRKRG5,WRKSORSV     GET SOR CHAR
         AR    WRKRG5,WRKRG5       DOUBLE IT TO INDEX TABL
         CH    WRKRG4,WRKSVPGL-2(WRKRG5) HAS LENGTH BEEN SAVED
         BNE   CKLNGPL             BE IF YES
         TM    WRKTYPST,HEX0F      DOES RCD HAVE INDENTIFIABLE ERROR
         BNZ   IDENTER             BR IF YES
         STH   PARMRG1,WRKSVPGL-2(WRKRG5) SAVE LNG FOR THIS LEVEL
         BO    IDENTER             BYPASS LNG CHECK
CKLNGPL  CH    PARMRG1,WRKSVPGL-2(WRKRG5) CK LNG WITH SAVED LNG
         BE    IDENTER             BR IF LNG OK
         OI    WRKTYPST,HEX02      INDICATE WRONG LNG RCD
IDENTER  TM    WRKTYPST,HEX02      WAS IT A WRONG LNG RCD
         BO    WRNGLN              BR IF YES
         TM    WRKEDSW2,HEX02      WAS DOUBLE DATA CHECK FOUND
         BO    WRNGLN              BR IF YES
         CLI   WRKLEVST,CHAR0      IS LEVEL STATUS ZERO
         BE    RESETSW             BR IF YES
         TM    WRKEDSW1,HEX01      WAS DUP ENCOUNTERED
         BO    MKLEVST2            BR IF YES
         MVI   WRKLEVST,CHAR0      RESET LEVEL STATUS
         B     RESETSW             GO RESET EDIT SWITCHES
WRNGLN   CLI   WRKLEVST,CHAR0      IS LEVEL STATUS ZERO
         BNE   MKLEVST2            BR IF NO
         MVI   WRKLEVST,CHAR1      MAKE IT 1
         B     RESETSW             GO RESET EDIT SWITCHES
MKLEVST2 MVI   WRKLEVST,CHAR2      MAKE IT 2
RESETSW  NI    WRKEDSW1,HEX08      RESET EDIT SWITCHES
         NI    WRKEDSW2,HEX88
         CH    PARMRG1,EDTMINLN    CHECK MINIMUM LENGTH
         BNL   MINLNOK             BR IF NOT SHORT
         OI    WRKTYPST,HEX02      INDICATE LENGTH ERROR
MINLNOK  TR    WRKTYPST(2),TREDW   MAKE TYPE AND LEVEL STATUS PRNTABLE
RETURN1  LR    WRKRG3,PARMRG0      PTR TO RCD
         LA    PARMRG0,HEX04       SET UP REG FOR SUB
         TM    EDTTYPSW,HEX08      USER ERROR EXIT SPECIFIED
         BO    CKVFRMT1            BR IF NO
         CLC   WRKSVEDW(2),CHAR00  IS THIS AN ERROR RECORD
         BE    CKVFRMT1            BR IF NO
         SR    WRKRG3,PARMRG0      DECR PTR TO RCD
         MVC   0(4,WRKRG3),WRKSVEDW APPEND EDW TO BEG OF RCD
         LA    PARMRG1,4(PARMRG1)  INCR LENGTH OF RCD TO INCLUDE EDW
CKVFRMT1 TM    EDTTYPSW,HEX40      DOES RECFM=V
         BZ    RECFMU1             BR IF NO
         LA    PARMRG1,4(PARMRG1)  INCR RCD LENGTH TO INCLUDE V-FIELD
         SR    WRKRG3,PARMRG0      DECR PTR TO RCD
         STH   PARMRG1,0(WRKRG3)   SAVE LENGTH IN V-FIELD
         XC    2(2,WRKRG3),2(WRKRG3) SET SECOND HALF TO ZERO
RECFMU1  ST    PARMRG1,WRKSVLZJ+8  SAVE RECORD LENGTH
         ST    WRKRG3,WRKSVLZJ     SAVE RECORD ADDR
         LA    WRKRG3,WRKSVLZJ+8
         ST    WRKRG3,WRKSVLZJ+4
         TM    EDTTYPSW,HEX08      IS USER ERROR EXIT SPEC
         BO    RETURN              BR IF NO
         CLC   WRKSVEDW(2),CHAR00  IS THIS AN ERROR RECORD
         BE    RETURN              BR IF NO
         LR    WRKRG2,SAVERG       SAVE PTR TO USER SAVE AREA
         LA    SAVERG,WRKMACSV     POINT TO SAVE AREA
         L     RTCDRG,EDTUSRXT     GET ADDR OF USER EXIT RTN
         LA    PARMRG1,WRKSVLZJ    POINT TO PARM LIST
         BALR  RETRNRG,RTCDRG      GO TO USER EXIT ROUTINE
         LR    SAVERG,WRKRG2       RESTORE PTR SAVE AREA
         L     PARMRG1,WRKSVLZJ+8  GET RCD LNG
         LA    PARMRG0,HEX04       SET UP RG FOR SUB
         SR    PARMRG1,PARMRG0     DECR RCD LNG
         ST    PARMRG1,WRKSVLZJ+8  SAVE RCD LNG
         L     WRKRG3,WRKSVLZJ                                    M4292
         LA    WRKRG3,4(WRKRG3)    INCR RCD ADDR
         TM    EDTTYPSW,HEX40      RECFM=V
         BZ    NORCFM3             BR IF NO
         MVC   0(4,WRKRG3),0(WRKRG7) MOVE V FIELD
         STH   PARMRG1,0(WRKRG3)   SAVE RCD LNG IN V-FIELD
NORCFM3  ST    WRKRG3,WRKSVLZJ     SAVE RCD ADDR IN PARM LIST
         LTR   RTCDRG,RTCDRG       ARE TO PASS RCD
         BNZ   NOFORMAT            BYPASS RCD
RETURN   LA    WRKRG3,WRKSVLZJ     POINT TO PARMLIST
         ST    WRKRG3,24(SAVERG)   AND SAVE
RETURNX  LM    RETRNRG,BASERG,12(SAVERG) RESTORE USERS REGS
         BR    RETRNRG
PTINPUT  L     PARMRG1,WRKNXAVI    POINT TO
         LA    PARMRG1,1(PARMRG1)  NEXT BYTE
         ST    PARMRG1,WRKNXAVI    IN INPUT
SVSCBST  ST    PARMRG1,WRKFBSCN    SAVE SCAN START ADDR
CKINPUT  C     PARMRG1,WRKENIPT    ANY BYTES LEFT IN INPUT
         BNL   IPTBSC              BR IF NO
         TM    WRKEDSW2,HEX04      WAS BSC END CHAR FOUND
         BO    IPTBSC              BR IF YES
         OI    WRKEDSW2,HEX08           INPUT NOT EMPTY          A35755
         MVI   19(SAVERG),HEX04    INDICATE INPUT NOT EMPTY RCD AVAIL
         BR    LNKRG8              RETURN TO CALLING ROUTINE
IPTBSC   NI    WRKEDSW2,HEXFB      RESET BSC END CHAR FOUND SW
         TM    WRKEDSW1,HEX08      SOR EXPECTED
         BO    CKBTAMBF
         OI    WRKEDSW2,HEX01      IND PARTIAL RCD
CKBTAMBF TM    EDTTYPSW,HEX10      ARE USING BTAM BUFFERS
         BZ    NOBUF2              BR IF NO
         L     PARMRG1,WRKADNXB    GET PTR TO NEXT BUFFER IN CHAIN
         LTR   PARMRG1,PARMRG1     ARE ANY MORE BUFFERS IN CHAIN
         BZ    NOBUF2              BR IF NO
         NI    WRKEDSW2,HEXF7      IND BUFFER EMPTY
         TM    WRKEDSW2,HEX01      IS THIS A PARTIAL RCD
         BO    GETBUF              BR IF YES
         MVI   19(SAVERG),HEX04    IND IPT NOT EMPTY RCD NOT AVAIL
         BR    LNKRG8              RETURN TO CALLING RTN
NOBUF2   NI    WRKEDSW2,HEXF7      INDICATE INPUT EMPTY
         MVI   19(SAVERG),HEX00    IND IPT EMPTY RCD AVAIL
         TM    WRKEDSW1,HEX08      SOR EXPECTED
         BCR   1,LNKRG8
         MVI   19(SAVERG),HEX08    IND INPUT EMPTY RCD NOT AVAIL
         BR    LNKRG8              RETURN TO CALLING RTN
*
* * *  REGISTER EQUATES * * *
*
PARMRG0  EQU   0
PARMRG1  EQU   1
WRKRG2   EQU   2
WRKRG3   EQU   3
WRKRG4   EQU   4
WRKRG5   EQU   5
WRKRG6   EQU   6
WRKRG7   EQU   7
LNKRG8   EQU   8
WRKSTRG  EQU   9
EDTPRMRG EQU   10
PRMLSTRG EQU   11
BASERG   EQU   12
SAVERG   EQU   13
RETRNRG  EQU   14
RTCDRG   EQU   15
*
* * *  EQUATES USED AS CONSTANTS  * * *
*
HEX00    EQU   X'00'
HEX01    EQU   X'01'
HEX02    EQU   X'02'
HEX03    EQU   X'03'
HEX04    EQU   X'04'
HEX08    EQU   X'08'
HEX0A    EQU   X'0A'
HEX0C    EQU   X'0C'
HEX10    EQU   X'10'
HEX20    EQU   X'20'
HEX40    EQU   X'40'
HEX80    EQU   X'80'
DLE      EQU   X'10'
STX      EQU   X'02'
HEXF7    EQU   X'F7'
HEX71    EQU   X'71'
HEX78    EQU   X'78'
HEXCAN   EQU   X'18'
HEXGS    EQU   X'1D'
HEX0E    EQU   X'0E'
HEX82    EQU   X'82'
HEXF0    EQU   X'F0'
HEXLZF   EQU   X'00'
HEX9F    EQU   X'9F'
CRM      EQU   C'U'
HEX7F    EQU   X'7F'
CVOK     EQU   C'V'
HEX0F    EQU   X'0F'
CHE      EQU   C'E'
HEX3F    EQU   X'3F'
CHAR0    EQU   C'0'
CHAR1    EQU   C'1'
CHAR2    EQU   C'2'
HEXFE    EQU   X'FE'
HEXFB    EQU   X'FB'
HEXDUP   EQU   X'11'
ETB      EQU   X'26'
HEX19    EQU   X'19'
HEXVOK   EQU   X'1E'
HEXRM    EQU   X'3C'
HEX12    EQU   X'12'
HEX88    EQU   X'88'
HEX16    EQU   X'16'
HEXBF    EQU   X'BF'
HEXEF    EQU   X'EF'
*
* * *  CONSTANTS  * * *
*
LGT256   DC    F'256'
TWOOH    DC    H'20'
HLF15    DC    H'15'
THREE    DC    H'3'
TREDW    DC    C'01234567'         USED TO MAKE EDW
         DC    C'89ABCDEF'         PRINTABLE
CHAR00   DC    C'00'
MOVESCND MVC   0(0,WRKRG5),0(WRKRG7) USED BY EXECUTE IN MOVE RTN
*
* * *  TRANSLATE AND TEST TABLE  * * *
*
TRNSTBLE DC    256X'00'
         ORG   TRNSTBLE+HEXLZF
         DC    X'04' *             LEFT ZERO FILL
         ORG   TRNSTBLE+HEXDUP
         DC    X'08'               DUP
         ORG   TRNSTBLE+HEX12
         DC    X'0C'               LEFT ZERO START
         ORG   TRNSTBLE+HEXCAN
         DC    X'10'               CANCEL
         ORG   TRNSTBLE+HEX0C
         DC    X'14'               GROUP SEPARATOR
         ORG   TRNSTBLE+ETB
         DC    X'18'               ETB
         ORG   TRNSTBLE+HEX03
         DC    X'18'               ETX
         ORG   TRNSTBLE+HEX3F
         DC    X'1C'               DATA CHECK
         ORG   TRNSTBLE+HEX19
         DC    X'20'               END DATA
         ORG   TRNSTBLE+HEXVOK
         DC    X'24'               VERIFY OK
         ORG   TRNSTBLE+HEXRM
         DC    X'24'               RECORD MARK
         ORG   TRNSTBLE+HEX71
         DC    8X'28'              PROGRAM LEVEL 1-8
         ORG
PARMLIST DSECT
PRMINPUT DS    A *                 ADDR OF INPUT
PRMIPTLN DS    A *                 LENGTH OF INPUT
PRMWRKAD DS    A *                 ADDR OF WORK AREA
PRMMXRCL DS    A *                 MAXIMUM RECORD LENGTH
EDITPARM DSECT
EDTTYPSW DS    B *                 EDIT SWS INDICATING USER OPTIONS
EDTREPCR DS    X *                 REPLACE CHARACTER
EDTMINLN DS    H *                 MINIMUN ACCEPTABLE RECORD LENGTH
EDTUSRXT DS    V *                 USER ERROR EXIT ROUTINE
WORKSTOR DSECT
WRKADRRC DS    A *                 ADDR OF RECORD
WRKADNXB DS    A *                 POINTER TO NEXT BUFFER
WRKENWRK DS    A *                 PTR TO END OF WORK + 1
WRKNXAVW DS    A *                 PTR TO NEXT AVAIL IN WORK AREA
WRKNXAVI DS    A *                 PTR TO NEXT AVAIL IN INPUT
WRKENIPT DS    A *                 PTR TO END OF INPUT + 1
WRKFBSCN DS    A *                 PTR TO FIRST BYTE SCANNED
WRKENSCN DS    A *                 PTR TO LAST BYTE SCANNED
WRKLDBPV DS    A *                 PTR TO LAST DATA BYTE OF PREV RCD
WRKFBLZF DS    A *                 PTR TO FIRST BYTE OF LZ FIELD
WRKSVLZJ DS    4F *                SAVE AREA FOR LZ JUSTIFICATION RTN
WRKSVEDW DS    F *                 ERROR DESCRIPTION WORD
         ORG   WRKSVEDW *
WRKLEVST DS    C *                 LEVEL STATUS
WRKTYPST DS    B *                 TYPE STATUS
WRKSORSV DS    X *                 SOR
WRKEORSV DS    X *                 EOR
WRKSVPGL DS    8H *                SAVE AREA FOR LNG OF PGM LEVEL CODES
WRKLZFCT DS    H *                 COUNT OF LZ FILL CHARS
         SPACE 1
*      THE BITS IN WRKEDSW1 ARE USED AS FOLLOWS
*      BIT 0  ON INDICATES DELETE THIS RECORD
*      BIT 1  ON INDICATES LEFT ZERO START CODE FOUND
*      BIT 2  ON INDICATES END OF LEFT ZERO FIELD FOUND
*      BIT 3  ON INDICATES ALL SCANNED NOT FIT IN WORK AREA
*      BIT 4  ON INDICATES SOR CHARACTER EXPECTED
*      BIT 5  ON INDICATES END OF RECORD FORCED
*      BIT 6  ON INDICATES DUP NOT ALLOWED IN THIS RECORD
*      BIT 7  ON INDICATES DUP FOUND IN THIS RECORD
WRKEDSW1 DS    B *                 EDIT SWITCHES
         SPACE 1
*      THE BITS IN WRKEDSW2 ARE USED AS FOLLOWS
*      BITS 0-3  RESERVED
*      BIT 4  ON INDICATES INPUT IS NOT EMPTY
*     BIT 5 ON INDICATES BSC END CHARACTER FOUND
*      BIT 6  ON INDICATES DOUBLE DATA CHECK FOUND IN THIS RECORD
*      BIT 7  ON INDICATES THIS RECORD IS A PARTIAL RECORD
WRKEDSW2 DS    B *                 EDIT SWITCH
WRKLNGSV DS    F *                 SAVE FOR LENGTH OF WORK AREA
WRKMACSV DS    F *                 BEGIN OF SAVE AREA IF PRESENT
         END
