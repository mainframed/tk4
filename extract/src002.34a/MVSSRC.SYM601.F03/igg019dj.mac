         TITLE 'IGG019DJ -- SAM-SI QSAM PROCESSOR                      *
                        '
IGG019DJ CSECT ,                                                   0001
@PROLOG  DS    0H                                                  0002
         EJECT
         EJECT
         EJECT
         EJECT
         EJECT
         EJECT
         EJECT
EIGHT    EQU   8                        SYMBOLIC EQUATE
TWELVE   EQU   12                       SYMBOLIC EQUATE
TWENTY   EQU   20                       SYMBOLIC EQUATE
*
         DC    A(GETENTRY)              ADDR FOR GET IN BRANCH TABLE
         DC    A(PUTENTRY)              ADDR FOR PUT IN BRANCH TABLE
         DC    A(CNTRLENT)              ADDR FOR CNTRL IN TABLE  XM3766
*                                                                   **
*********************************************************************/
*                                                                   */
*   ENTRY BRANCH TABLE                                              */
*                                                                   */
**********************************************************************
*                                                                   **
         USING GETENTRY,R15             /* ENTRY ADDRESSABILITY     */
         USING @DATD-CIWK1,RCICB
GETENTRY B     GETROUTN                 /* ENTRY FOR GET            */
         B     NOOPRTN                  /* DUMMY ENTRY -- INVALID   */
         B     RELSERTN                 /* BRANCH TO RELSE EP       */
         DROP  R15
         USING PUTENTRY,R15             /* TEMP ADDRESSABILITY      */
PUTENTRY B     PUTROUTN                 /* ENTRY FOR USER PUT       */
         B     PUTXRTN                  /* BRANCH TO PUTX EP        */
         B     TRUNCRTN                 /* BRANCH TO TRUNC EP       */
         DROP  R15
         USING CNTRLENT,R15             TEMORARY ADDRESSABILITY  XM3766
CNTRLENT B     CNTRLRTN                 BRANCH TO CNTRL ROUTINE  XM3766
         DROP  R15                                               XM3766
         USING GETENTRY,R11             /* RESET BASE ADDRESS       */
         EJECT
GETROUTN STM R14,R12,12(R13)
*        RDCB = R1;                     /* ESTABLISH DCB BASE       */
         LR    RDCB,R1                                             0102
*        RCICB = DCBCICB;               /* ESTABLISH CICB BASE      */
         L     RCICB,DCBCICB(,RDCB)                                0103
*        R11 = R15;                     /* ESTABLISH BASE REGISTER  */
         LR    R11,R15                                             0104
*        CIREGBC = R13;                 /* KEEP USER SAVE POINTER   */
         ST    R13,CIREGBC(,RCICB)                                 0105
*        R13 = ADDR(CIREGSAV);          /* SET CI SAVE ADDRESS      */
         LA    R13,CIREGSAV(,RCICB)                                0106
*        RRPL = ADDR(CIRPL);            /* ESTABLISH RPL BASE       */
         LA    RRPL,CIRPL(,RCICB)                                  0107
*        RPLRLEN = ZERO;                /* ZERO LENGTH FIELD        */
*                                                                  0108
         MVC   RPLRLEN(4,RRPL),ZERO                                0108
*        IF DCBMACRF(5)   = '1'B THEN   /* GET-LOCATE MODE ?         */
         TM    DCBMACRF(RDCB),B'00001000'                          0109
         BNO   @RF00109                                            0109
*                                       /* YES, BUFR PTR ALREADY SET */
*          IF DCBRECFM(1:2) = '01'B THEN/* IS IT ALSO V FORMAT ?     */
         TM    DCBRECFM(RDCB),B'01000000'                          0110
         BNO   @RF00110                                            0110
         TM    DCBRECFM(RDCB),B'10000000'                          0110
         BNZ   @RF00110                                            0110
*            RPLAREA = RPLAREA + FOUR;  /* THEN ADJUST BUFR PTR TO 0111
*                                       ALLOW SPACE FOR AN RDW.      */
         LH    @10,FOUR                                            0111
         AL    @10,RPLAREA(,RRPL)                                  0111
         ST    @10,RPLAREA(,RRPL)                                  0111
*          ELSE;                        /* NOT V, USE BUFR PTR AS IS.*/
@RF00110 DS    0H                                                  0113
*        ELSE                           /* NOT LOCATE,IS MOVE OR SUBS*/
*          IF DCBRECFM(1:2) = '01'B THEN/* V FORMAT ?                */
         B     @RC00109                                            0113
@RF00109 TM    DCBRECFM(RDCB),B'01000000'                          0113
         BNO   @RF00113                                            0113
         TM    DCBRECFM(RDCB),B'10000000'                          0113
         BNZ   @RF00113                                            0113
*            RPLAREA = R0 + FOUR;       /* YES, SET BUFR PTR TO CALLERS
*                                       AREA AND LEAVE ROOM FOR RDW. */
         LR    @10,R0                                              0114
         AH    @10,FOUR                                            0114
         ST    @10,RPLAREA(,RRPL)                                  0114
*          ELSE                         /* IS U OR F FORMAT          */
*            RPLAREA = R0;              /* USE CALLERS BUFR PTR      */
*                                                                  0115
         B     @RC00113                                            0115
@RF00113 ST    R0,RPLAREA(,RRPL)                                   0115
*/*******************************************************************/
*JESGET: GEN   (GET RPL=(RRPL));        /* JES GET REQUEST          */
@RC00113 DS    0H                                                  0116
@RC00109 DS    0H                                                  0116
JESGET   GET RPL=(RRPL)
*/*******************************************************************/
*                                                                  0117
*        IF R15 = 0 THEN                /* NORMAL JES RETURN ? Y02082*/
         LTR   R15,R15                                             0117
         BNZ   @RF00117                                            0117
*          IF DCBRECFM(1:2) = '10'B &   /* BUT IF F FORMAT AND Y02082*/
*          RPLRLEN ^= RPLBUFL THEN      /* NOT EXACT LENGTH,   Y02082*/
         TM    DCBRECFM(RDCB),B'10000000'                          0118
         BNO   @RF00118                                            0118
         TM    DCBRECFM(RDCB),B'01000000'                          0118
         BNZ   @RF00118                                            0118
         CLC   RPLRLEN(4,RRPL),RPLBUFL(RRPL)                       0118
         BE    @RF00118                                            0118
*            DO;                        /* FORCE LOGICAL ERROR Y02082*/
*              RPLRTNCD = 8;            /* SET LOGICAL ERR     Y02082*/
         MVI   RPLRTNCD(RRPL),X'08'                                0120
*              RPLERRCD = RPLINBUF;     /* SET LENGTH ERR      Y02144*/
         MVC   RPLERRCD(1,RRPL),RPLINBUF                           0121
*            END;                       /*                     Y02082*/
*          ELSE                         /* VALID NORMAL RETURN Y02082*/
*            GO TO FINGET;              /* RESUME NORMAL PATH  Y02082*/
*        ELSE                           /* ABNORMAL JES RETURN Y02082*/
*          IF RPLRTNCD = 8              /* IS IT LOGICAL ERR,  Y02082*/
*          & RPLERRCD = RPLEODER        /* DUE TO END OF DATA  Y02144*/
*          & DCBIFLGS(1:2) ^= '11'B THEN/* FOR FIRST TIME?   @ZA15667*/
         B     @RC00117                                            0124
@RF00117 CLI   RPLRTNCD(RRPL),8                                    0124
         BNE   @RF00124                                            0124
         CLC   RPLERRCD(1,RRPL),RPLEODER                           0124
         BNE   @RF00124                                            0124
         TM    DCBIFLGS(RDCB),B'11000000'                          0124
         BNO   @RT00124                                            0124
*             GO TO EODADDR;            /* BRANCH IF END OF FILE     */
*          ELSE;                        /* MUST BE A REAL ERROR      */
*                                                                  0126
@RF00124 DS    0H                                                  0127
*        /* SET THE ERROR INDEX FOR SYNAD HANDLER                    */
*        IF RPLRTNCD = '08'X            /* FOR LOGICAL ERROR   Y02144*/
*        & RPLERRCD = RPLINBUF THEN     /* DUE TO WRONG LEN    Y02144*/
@RC00117 CLI   RPLRTNCD(RRPL),8                                    0127
         BNE   @RF00127                                            0127
         CLC   RPLERRCD(1,RRPL),RPLINBUF                           0127
         BNE   @RF00127                                            0127
*          CIFLAG1 = ERR4;              /* SET QSAM LEN ERROR  Y02144*/
         MVC   CIFLAG1(1,RCICB),ERR4                               0128
*        ELSE                           /* FOR ANY OTHER,      Y02144*/
*          CIFLAG1 = ERR5;              /* SET QSAM READ ERROR Y02144*/
*                                                                  0129
         B     @RC00127                                            0129
@RF00127 MVC   CIFLAG1(1,RCICB),ERR5                               0129
*        IF DCBEROPT(2)   = '1'B THEN   /* IF USER EROPT=SKIP        */
@RC00127 TM    DCBEROPT(RDCB),B'01000000'                          0130
         BNO   @RF00130                                            0130
*          RETREG = ADDR(JESGET);       /* SET FOR ANOTHER GET       */
         LA    RETREG,JESGET                                       0131
*        ELSE                           /* YES                       */
*          RETREG = ADDR(FINGET);       /* OTHERWISE TO FINISH       */
*                                                                  0132
         B     @RC00130                                            0132
@RF00130 LA    RETREG,FINGET                                       0132
*        GO TO ERROR;                   /* GO TO SUBROUTINE          */
*                                                                  0133
*                                                                  0133
         B     ERROR                                               0133
*FINGET: IF DCBRECFM(1:2) = '01'B       /* VARIABLE LENGTH RECORD   */
*          THEN                         /* IF YES,                  */
FINGET   TM    DCBRECFM(RDCB),B'01000000'                          0134
         BNO   @RF00134                                            0134
         TM    DCBRECFM(RDCB),B'10000000'                          0134
         BNZ   @RF00134                                            0134
*            DO;                        /* DO THE FOLLOWING         */
*              RPLAREA = RPLAREA - FOUR;/* MOVE BUFFER POINTER TO   */
         LH    @10,FOUR                                            0136
         L     @09,RPLAREA(,RRPL)                                  0136
         SLR   @09,@10                                             0136
         ST    @09,RPLAREA(,RRPL)                                  0136
*                                       /*   INCLUDE RDW            */
*              RDW = RPLRLEN + FOUR;    /*PUT REC LGTH IN RDW YM5231*/
         AL    @10,RPLRLEN(,RRPL)                                  0137
         STH   @10,RDW(,@09)                                       0137
*            END;                       /* END OF VLR DO GROUP      */
*          ELSE;                        /* NOT VLR RECORD           */
*                                                                  0139
*                                                                  0139
@RF00134 DS    0H                                                  0140
*/*******************************************************************/
*/*          RETURN TO USER                                         */
*/*******************************************************************/
*                                                                  0140
*        R13 = CIREGBC;                 /* GET POINTER TO USER SAVE */
         L     R13,CIREGBC(,RCICB)                                 0140
*        CIREGSV1 = RPLAREA;            /* SET POINTER TO RECORD    */
         MVC   CIREGSV1(4,R13),RPLAREA(RRPL)                       0141
*        IF DCBRECFM(1:2) = '10'B       /* IF RECFM IS FIXED    */ 0142
*          THEN                         /* YES, FIXED               */
         TM    DCBRECFM(RDCB),B'10000000'                          0142
         BNO   @RF00142                                            0142
         TM    DCBRECFM(RDCB),B'01000000'                          0142
         BZ    @RT00142                                            0142
*            GO TO FIXRCD;              /* DO NOT UPDATE DCBLRECL   */
*        IF DCBRECFM(1:2) = '01'B  /*IF RECFM VARIABLE @ZA02426*/  0144
*          THEN                         /*@ZA02426*/               0144
@RF00142 TM    DCBRECFM(RDCB),B'01000000'                          0144
         BNO   @RF00144                                            0144
         TM    DCBRECFM(RDCB),B'10000000'                          0144
         BNZ   @RF00144                                            0144
*            DCBLRECL=RDW;              /*@ZA02426*/               0145
         L     @10,RPLAREA(,RRPL)                                  0145
         MVC   DCBLRECL(2,RDCB),RDW(@10)                           0145
*        ELSE DCBLRECL=RPLRLEN;         /*@ZA02426*/               0146
         B     @RC00144                                            0146
@RF00144 MVC   DCBLRECL(2,RDCB),RPLRLEN+2(RRPL)                    0146
*FIXRCD:                                /* END OF RETURN SETUP      */
*        GEN (LM R14,R12,12(R13));      /* RESTORE USERS REGISTERS  */
@RC00144 DS    0H                                                  0147
FIXRCD   LM R14,R12,12(R13)
*        GEN (BR R14);                  /* RETURN TO USER           */
         BR R14
*/*******************************************************************/
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
         EJECT
*                                                                  0150
*                                                                  0150
*/*******************************************************************/
*/*     END OF DATA EXIT TO QSAM GERR MODULE                        */
*/*******************************************************************/
*                                                                  0150
*EODADDR:                                                          0150
*        DCBIFLGS (1:2) = '11'B;        /* SET ERROR FLAGS  @ZA15667*/
EODADDR  OI    DCBIFLGS(RDCB),B'11000000'                          0150
*        R15 = DCBGERR;                 /* QSAM GERR ADDRESS        */
         SLR   R15,R15                                             0151
         ICM   R15,7,DCBGERR(RDCB)                                 0151
*        R13 = CIREGBC;                 /* GET POINTER TO USER SAVE */
         L     R13,CIREGBC(,RCICB)                                 0152
*        GEN;                                                      0153
         L     R14,TWELVE(R13)          USER RETURN ADDR
         LM    @0,R12,TWENTY(R13)       RESTORE USERS REGS
         STM   R14,@8,TWENTY(R13)       STORE USER REGS FOR GERR
         LR    @2,@1                    DCB ADDR TO R2 FOR GERR
         BR    R15                      BR TO QSAM GERR
*/*******************************************************************/
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
         EJECT
*                                                                  0155
*                                                                  0155
*/*******************************************************************/
*/*                                                                 */
*/* PUT ENTRY FROM USER                                             */
*/*                                                                 */
*/*******************************************************************/
*                                                                  0155
*PUTROUTN:                                                         0155
*        GEN   (STM R14,R12,12(R13));   /* SAVE USER'S REGISTERS    */
PUTROUTN STM R14,R12,12(R13)
*        RDCB = R1;                     /* ESTABLISH DCB BASE       */
         LR    RDCB,R1                                             0156
*        RCICB = DCBCICB;               /* ESTABLISH CICB BASE      */
         L     RCICB,DCBCICB(,RDCB)                                0157
*        RBUF = R0;                     /* SAVE USER BUF ADDRESS    */
         LR    RBUF,R0                                             0158
*        GEN   (LA RBUF,0(RBUF));       /* CLEAR HI BYTE    @ZA08245*/
         LA RBUF,0(RBUF)
*        R11 = R15;                     /* CHANGE BASE REGISTER     */
         LR    R11,R15                                             0160
*        GEN;                                                      0161
         LA    R7,PUTENTRY-GETENTRY     DISPLACEMENT-ENTRY TO BASE
         SR    R11,R7                   POINT TO GETENTRY
*/*******************************************************************/
*                                                                  0162
*        IF CIFCLOSE = '1'B             /* ENTRY FROM CLOSE         */
*          THEN                         /* YES                      */
         TM    CIFCLOSE(RCICB),B'01000000'                         0162
         BNO   @RF00162                                            0162
*            CIWK2 = R14;               /* SAVE REG 14 FOR CLOSE    */
         ST    R14,CIWK2(,RCICB)                                   0163
*        CIREGBC = R13;                 /* KEEP POINTER TO USER SAVE*/
@RF00162 ST    R13,CIREGBC(,RCICB)                                 0164
*        R13 = ADDR(CIREGSAV);          /* POINTER TO CI SAVE AREA  */
         LA    R13,CIREGSAV(,RCICB)                                0165
*        RRPL = ADDR(CIRPL);            /* ESTABLISH RPL BASE       */
*                                                                  0166
         LA    RRPL,CIRPL(,RCICB)                                  0166
*/*******************************************************************/
*/*      TEST FOR LOCATE MODE, RECORD FORMAT TYPE                   */
*/*******************************************************************/
*                                                                  0167
*        IF DCBMACRF(13)  = '1'B        /* LOCATE MODE              */
*          THEN                         /* YES                      */
         TM    DCBMACRF+1(RDCB),B'00001000'                        0167
         BNO   @RF00167                                            0167
*            RBUF = RPLAREA;            /* SET RBUF = DATA AREA ADR */
         L     RBUF,RPLAREA(,RRPL)                                 0168
*          ELSE                         /* NO, PUT MOVE MODE        */
*            GO TO PUTMOVE;             /* GO TO PROCESS IT         */
*                                       /* LOCATE MODE, CONTINUE    */
*        IF CIFFSTP = '0'B              /* TEST IF FIRST PASS       */
*          THEN                         /* YES, CALLER HAS PROVIDED */
         TM    CIFFSTP(RCICB),B'10000000'                          0170
         BNZ   @RF00170                                            0170
*            DO;                        /* NO DATA FOR PUT YET      */
*              CIFFSTP = '1'B;          /* CLEAR FIRST PASS CONDIT  */
         OI    CIFFSTP(RCICB),B'10000000'                          0172
*              GO TO GOBACK;            /* AND RETURN TO CALLER     */
         B     GOBACK                                              0173
*            END;                       /* END OF FIRST PASS LOGIC  */
*                                       /* NOT FIRST PASS, CONTINUE */
*        IF DCBRECFM(1:2) = '10'B × DCBRECFM(1:2) = '11'B/*        0175
*                                          U OR F FORMAT ?          */
*          THEN                         /* YES, PERFORM CHECKING    */
@RF00170 TM    DCBRECFM(RDCB),B'10000000'                          0175
         BNO   @GL00005                                            0175
         TM    DCBRECFM(RDCB),B'01000000'                          0175
         BZ    @RT00175                                            0175
@GL00005 TM    DCBRECFM(RDCB),B'11000000'                          0175
         BNO   @RF00175                                            0175
@RT00175 DS    0H                                                  0176
*            DO;                        /* SEQUENCE REQD FOR COBOL  */
*              IF DCBRECAD ^= DCBEOBAD  /* TEST 'EOB' CONDITION     */
*                THEN                   /* NOT 'EOB'                */
         L     @10,DCBRECAD(,RDCB)                                 0177
         C     @10,DCBEOBAD(,RDCB)                                 0177
         BNE   @RT00177                                            0177
*                  GO TO GOBACK;        /* SUPPRESS PUT             */
*              IF DCBRECFM(1:2) = '11'B /* U FORMAT ?               */
*                THEN                   /* YES, CALC RECORD SIZE    */
         TM    DCBRECFM(RDCB),B'11000000'                          0179
         BNO   @RF00179                                            0179
*                  RPLRLEN = DCBRECAD - RPLAREA; /* FROM RECAD VALUE*/
         SL    @10,RPLAREA(,RRPL)                                  0180
         ST    @10,RPLRLEN(,RRPL)                                  0180
*              GO TO JESPUT;            /* GO TO ISSUE PUT          */
         B     JESPUT                                              0181
*            END;                       /* END OF U, F GROUP        */
*                                       /* NOT U OR F, CONTINUE     */
*        IF DCBRECFM(1:2) = '01'B       /* V FORMAT ?               */
*          THEN                         /* YES, VARIABLE LENGTH     */
@RF00175 TM    DCBRECFM(RDCB),B'01000000'                          0183
         BNO   @RF00183                                            0183
         TM    DCBRECFM(RDCB),B'10000000'                          0183
         BNZ   @RF00183                                            0183
*            IF DCBRECFM(5)   = '1'B    /* SPANNED RECORDS ?        */
*              THEN                     /* YES, VS                  */
         TM    DCBRECFM(RDCB),B'00001000'                          0184
         BO    @RT00184                                            0184
*                GO TO SPANNED;         /* GO PROCESS SEGMENT       */
*              ELSE                     /* NO, V ONLY               */
*                GO TO LENTEST;         /* GO TEST RDW              */
         B     LENTEST                                             0186
*                                       /* NOT V FORMAT, RECFM=?    */
*        GO TO PUTMOVE;                 /* DEFAULT TO PUT-MOVE      */
         B     PUTMOVE                                             0187
*/*******************************************************************/
*/*      PROCESS VARIABLE-SPANNED RECORD SEGMENTS (LOCATE MODE)     */
*/*******************************************************************/
*                                                                  0188
*SPANNED:                                                          0188
*        IF RDW < FOUR THEN             /* IF A NULL RECORD?  XA01145*/
SPANNED  LH    @10,FOUR                                            0188
         L     @09,RPLAREA(,RRPL)                                  0188
         LH    @06,RDW(,@09)                                       0188
         CR    @06,@10                                             0188
         BL    @RT00188                                            0188
*          GO TO GOBACK;                /* RETURN...NO DATA   XA01145*/
*        CISEGLEN = RDW - FOUR;         /* COMPUTE SEGMENT LENGTH   */
         SLR   @06,@10                                             0190
         ST    @06,CISEGLEN(,RCICB)                                0190
*        IF SEGCC = '00'B               /* IS SEGMENT COMPLETE ?    */
*          THEN                         /* YES                      */
         TM    SEGCC(@09),B'00000011'                              0191
         BNZ   @RF00191                                            0191
*            DO;                        /* PROCESS COMPLETE RECORD  */
*              RPLRLEN = 0;             /* SET RECD LENGTH TO 0     */
         SLR   @10,@10                                             0193
         ST    @10,RPLRLEN(,RRPL)                                  0193
*              GO TO COMPLRCD;          /* GO TO WRITE RECORD       */
         B     COMPLRCD                                            0194
*            END;                       /* END OF COMPL RCD GROUP   */
*                                       /* NOT COMPLETE RECORD      */
*        IF SEGCC = '01'B               /* FIRST SEGMENT OF RECORD ?*/
*          THEN                         /* YES                      */
@RF00191 L     @10,RPLAREA(,RRPL)                                  0196
         TM    SEGCC(@10),B'00000001'                              0196
         BNO   @RF00196                                            0196
         TM    SEGCC(@10),B'00000010'                              0196
         BNZ   @RF00196                                            0196
*            DO;                        /* PROCESS FIRST SEGMENT    */
*              RPLRLEN = 0;             /* INITIALIZE RECORD LENGTH */
         SLR   @10,@10                                             0198
         ST    @10,RPLRLEN(,RRPL)                                  0198
*CONTIN01:                              /* POINT TO LAST WORD OF SEG*/
*              RPLAREA = RPLAREA + CISEGLEN;                       0199
CONTIN01 L     @10,CISEGLEN(,RCICB)                                0199
         L     @09,RPLAREA(,RRPL)                                  0199
         ALR   @09,@10                                             0199
         ST    @09,RPLAREA(,RRPL)                                  0199
*              CIRECPTR = RPLAREA;      /* SAVE POINTER             */
         ST    @09,CIRECPTR(,RCICB)                                0200
*                                       /* SAVE LAST WORD OF SEG    */
*              CILWAREA = RPLAREA -> SEGMENT(1:4);                 0201
         MVC   CILWAREA(4,RCICB),SEGMENT(@09)                      0201
*              RPLRLEN = RPLRLEN + CISEGLEN;  /* UPDATE RECORD LEN  */
         AL    @10,RPLRLEN(,RRPL)                                  0202
         ST    @10,RPLRLEN(,RRPL)                                  0202
*              RBUF = RPLAREA;          /* PTR FOR NEXT SEGMENT     */
         LR    RBUF,@09                                            0203
*              GO TO GOBACK;            /* RETURN TO USER           */
         B     GOBACK                                              0204
*            END;                       /* END OF 1ST SEGMENT GROUP */
*                                                                  0205
*          ELSE                         /* NOT 1ST SEGMT OF RECORD  */
*            DO;                        /* SEE IF LAST OR INTERMED  */
@RF00196 DS    0H                                                  0207
*              IF SEGCC = '11'B         /* INTERMEDIATE SEGMENT ?   */
*                THEN                   /* YES                      */
         L     @10,RPLAREA(,RRPL)                                  0207
         TM    SEGCC(@10),B'00000011'                              0207
         BO    @RT00207                                            0207
*                  GO TO CONTIN01;      /* PREPARE RETURN TO USER   */
*                ELSE                   /* NO, MUST BE LAST SEGMENT */
*                  DO;                                             0209
*                    /* RESTORE LAST WORD OF PRECEDING SEGMENT      */
*                    CIRECPTR -> SEGMENT(1:4) = CILWAREA;          0210
*                                                                  0210
         L     @10,CIRECPTR(,RCICB)                                0210
         MVC   SEGMENT(4,@10),CILWAREA(RCICB)                      0210
*COMPLRCD:           /* POINT TO BEGINNING OF RECORD                */
*                    RPLAREA = CIRAREA + 4;                        0211
*                                                                  0211
COMPLRCD L     @10,CIRAREA(,RCICB)                                 0211
         LA    @09,4                                               0211
         ALR   @09,@10                                             0211
         ST    @09,RPLAREA(,RRPL)                                  0211
*                    RBUF = CIRAREA;    /* INIT RECORD POINTER      */
*                                                                  0212
         LR    RBUF,@10                                            0212
*                    /* UPDATE RECORD LENGTH                        */
*                    RPLRLEN = RPLRLEN + CISEGLEN;                 0213
*                                                                  0213
         L     @10,RPLRLEN(,RRPL)                                  0213
         AL    @10,CISEGLEN(,RCICB)                                0213
         ST    @10,RPLRLEN(,RRPL)                                  0213
*                    GO TO JESPUT;      /* GO TO WRITE RECORD       */
         B     JESPUT                                              0214
*                  END;                 /* END OF LAST SEGMT GROUP  */
*            END;                       /* END OF NOT 1ST SEG GRP   */
*/*******************************************************************/
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
         EJECT
*                                                                  0218
*                                                                  0218
*/*******************************************************************/
*/*       THIS ROUTINE HANDLES MOVE MODE OF PUT                     */
*/*******************************************************************/
*                                                                  0218
*PUTMOVE:                                                          0218
*                                                                  0218
*        RPLAREA = RBUF;                /* STORE BUFFER PTR IN RPL  */
PUTMOVE  ST    RBUF,RPLAREA(,RRPL)                                 0218
*        IF DCBRECFM(1:2) = '01'B       /* VARIABLE LENGTH RECORD   */
*          THEN                         /* YES                      */
         TM    DCBRECFM(RDCB),B'01000000'                          0219
         BNO   @RF00219                                            0219
         TM    DCBRECFM(RDCB),B'10000000'                          0219
         BNZ   @RF00219                                            0219
*            DO;                        /* DO FOLLOWING FOR VLR     */
*              IF DCBMACRF(10)  = '1'B & DCBMACRF(16) = '1'B/*     0221
*                                               DATA MODE SPECIFIED */
*                THEN                   /* YES                      */
         TM    DCBMACRF+1(RDCB),B'01000001'                        0221
         BNO   @RF00221                                            0221
*                  DO;                                             0222
*                    RPLRLEN = DCBPRECL;/* GET DATA RECORD LENGTH   */
         LH    @10,DCBPRECL(,RDCB)                                 0223
         ST    @10,RPLRLEN(,RRPL)                                  0223
*                    GO TO JESPUT;      /* GO TO ISSUE PUT          */
         B     JESPUT                                              0224
*                  END;                 /* END OF DATA MODE GROUP   */
*                ELSE                   /* NOT DATA MODE            */
*                  GO TO LENTEST;       /* GO TEST RDW LENGTH       */
*            END;                       /* END OF DO GROUP          */
*          ELSE                         /* NOT VLR                  */
*            DO;                        /* DO THE FOLLOWING         */
@RF00219 DS    0H                                                  0229
*              RPLRLEN = DCBLRECL;      /* SET UP RPL LENGTH        */
         SLR   @10,@10                                             0229
         ICM   @10,3,DCBLRECL(RDCB)                                0229
         ST    @10,RPLRLEN(,RRPL)                                  0229
*              GO TO JESPUT;            /* BRANCH TO ISSUE JES PUT  */
         B     JESPUT                                              0230
*             END;                      /* END OF DO GROUP          */
*                                                                  0231
*/********************************************************************/
*/*     TEST FOR EXCESS LENGTH FOR VARIABLE LENGTH RECORD            */
*/*     NOTE: LOCATE MODE SPANNED RECORDS NOT CHECKED HERE           */
*/********************************************************************/
*                                                                  0232
*LENTEST:                               /* EXAMINE CALLER'S RDW      */
*                                                                  0232
*        IF RDW < ZERO THEN             /* IS RDW NEGATIVE   @ZA09636*/
LENTEST  L     @10,RPLAREA(,RRPL)                                  0232
         LH    @10,RDW(,@10)                                       0232
         C     @10,ZERO                                            0232
         BNL   @RF00232                                            0232
*          GEN (DMABCOND 213,SVC=YES,DCB=(RDCB)); /* YES -         0233
*                                          REQUEST 002 ABEND @ZA09636*/
*                                                                  0233
         DMABCOND 213,SVC=YES,DCB=(RDCB)
*        IF RDW < FOUR THEN             /* IS IT A NULL RECORD ?     */
@RF00232 LH    @10,FOUR                                            0234
         L     @09,RPLAREA(,RRPL)                                  0234
         LH    @09,RDW(,@09)                                       0234
         CR    @09,@10                                             0234
         BL    @RT00234                                            0234
*          GO TO GOBACK;                /* YES, BYPASS PUT PROCESS   */
*                                                                  0235
*        IF DCBRECFM(1:2) = '01'B & DCBRECFM(5)   = '1'B THEN/*    0236
*                                          SPANNED RECORDS SPECIFIED */
         TM    DCBRECFM(RDCB),B'01000000'                          0236
         BNO   @RF00236                                            0236
         TM    DCBRECFM(RDCB),B'10000000'                          0236
         BNZ   @RF00236                                            0236
         TM    DCBRECFM(RDCB),B'00001000'                          0236
         BNO   @RF00236                                            0236
*          DO;                          /* YES DO SPANNED LEN CHECK  */
*            IF RDW > DCBLRECL THEN     /* TEST RDW VALUE            */
         SLR   @06,@06                                             0238
         ICM   @06,3,DCBLRECL(RDCB)                                0238
         CR    @09,@06                                             0238
         BNH   @RF00238                                            0238
*              DO;                      /* RDW IS TOO LARGE          */
*                RPLRLEN=DCBLRECL-FOUR; /* TRUNC TO LRECL SIZE       */
         SLR   @06,@10                                             0240
         ST    @06,RPLRLEN(,RRPL)                                  0240
*                GO TO LENTEST3;        /* GO PREPARE FOR JESPUT     */
         B     LENTEST3                                            0241
*              END;                     /* END OF OVERSIZE RECORD    */
*            ELSE GO TO LENTEST2;       /* RDW IS ACCEPTABLE         */
*          END;                         /* END SPANNED LEN CHECK     */
*        ELSE;                          /* NOT SPANNED RECORDS       */
*                                                                  0245
@RF00236 DS    0H                                                  0246
*        IF RDW > DCBBLKSI - FOUR THEN  /* RDW > MAX ALLOWED ?       */
         L     @10,RPLAREA(,RRPL)                                  0246
         SLR   @09,@09                                             0246
         ICM   @09,3,DCBBLKSI(RDCB)                                0246
         SH    @09,FOUR                                            0246
         CH    @09,RDW(,@10)                                       0246
         BNL   @RF00246                                            0246
*          GEN (DMABCOND 213,SVC=YES,DCB=(RDCB)); /* YES,      Y02144
*                                       REQUEST 002 ABEND            */
         DMABCOND 213,SVC=YES,DCB=(RDCB)
*        ELSE;                          /* RDW ^> MAX ALLOWED        */
*                                                                  0248
@RF00246 DS    0H                                                  0249
*LENTEST2:                                                         0249
*        RPLRLEN = RDW - FOUR;          /* PUT RECORD LENGTH IN RPL  */
LENTEST2 L     @10,RPLAREA(,RRPL)                                  0249
         LH    @10,RDW(,@10)                                       0249
         SH    @10,FOUR                                            0249
         ST    @10,RPLRLEN(,RRPL)                                  0249
*LENTEST3:                                                         0250
*        RPLAREA = RPLAREA + FOUR;      /* POINT BUFFER PAST RDW     */
LENTEST3 LH    @10,FOUR                                            0250
         AL    @10,RPLAREA(,RRPL)                                  0250
         ST    @10,RPLAREA(,RRPL)                                  0250
*/*******************************************************************/
*                                                                  0251
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
         EJECT
*                                                                  0252
*                                                                  0252
*/*******************************************************************/
*/*  ISSUE JES PUT REQUEST                                          */
*/*******************************************************************/
*                                                                  0252
*JESPUT:                                                           0252
*                                                                  0252
*/*******************************************************************/
*/* TEST FOR CONTROL CHARACTER SPECIFIED IN DCB                     */
*/*******************************************************************/
*                                                                  0252
*        IF DCBRECFM(6:7) = '10'B × DCBRECFM(6:7) = '01'B          0252
*          THEN DO;                                                0252
JESPUT   TM    DCBRECFM(RDCB),B'00000100'                          0252
         BNO   @GL00007                                            0252
         TM    DCBRECFM(RDCB),B'00000010'                          0252
         BZ    @RT00252                                            0252
@GL00007 TM    DCBRECFM(RDCB),B'00000010'                          0252
         BNO   @RF00252                                            0252
         TM    DCBRECFM(RDCB),B'00000100'                          0252
         BNZ   @RF00252                                            0252
@RT00252 DS    0H                                                  0253
*            RPLCCHAR = RPLAREA;        /* PTR TO CONTROL CHARACTER */
         L     @10,RPLAREA(,RRPL)                                  0254
         ST    @10,RPLCCHAR(,RRPL)                                 0254
*            RPLAREA = RPLAREA + ONE;   /* STORE BUFFER POINTER     */
         LH    @09,ONE                                             0255
         ALR   @10,@09                                             0255
         ST    @10,RPLAREA(,RRPL)                                  0255
*            RPLRLEN = RPLRLEN - ONE;   /* STORE ADJUSTED LENGTH    */
         LCR   @09,@09                                             0256
         AL    @09,RPLRLEN(,RRPL)                                  0256
         ST    @09,RPLRLEN(,RRPL)                                  0256
*               END;                    /* END OF DO GROUP          */
*          ELSE;                                                   0258
@RF00252 DS    0H                                                  0259
*/*******************************************************************/
*                                                                  0259
*        GEN (PUT RPL=(RRPL));          /* JES PUT REQUEST          */
*                                                                  0259
         PUT RPL=(RRPL)
*/*******************************************************************/
*/*  LOAD BUFFER ADDRESS INTO REGISTER ONE AND RETURN               */
*/*******************************************************************/
*                                                                  0260
*        IF R15 ^= 0 THEN               /* ABNORMAL RETURN          */
         LTR   R15,R15                                             0260
         BZ    @RF00260                                            0260
*          DO;                                                     0261
*            CIFLAG1 = ERR6;            /* SET QSAM WRITE ERR  Y02144*/
         MVC   CIFLAG1(1,RCICB),ERR6                               0262
*            RETREG = ADDR(GOBACK);     /* SET SUBROUTINE RETURN    */
         LA    RETREG,GOBACK                                       0263
*            GOTO ERROR;                /* AND GO TO SUBROUTINE     */
         B     ERROR                                               0264
*          END;                                                    0265
*                                                                  0265
*GOBACK:                                                           0266
*        R13 = CIREGBC;                 /* GET PTR TO USER SAVE AREA */
@RF00260 DS    0H                                                  0266
GOBACK   L     R13,CIREGBC(,RCICB)                                 0266
*        CIREGSV1 = RBUF;               /* SAVE BUFFER ADDR IN USERS
*                                          REG 1 LOCATION.           */
*                                                                  0267
         ST    RBUF,CIREGSV1(,R13)                                 0267
*        IF DCBMACRF(13)  = '1'B        /* PUT LOCATE MODE          */
*          THEN                         /* YES                      */
         TM    DCBMACRF+1(RDCB),B'00001000'                        0268
         BNO   @RF00268                                            0268
*            DO;                        /* DO FOLLOWING             */
*                                                                  0269
*              IF DCBRECFM(1:2) = '01'B THEN/*                     0270
*                                          IF V FORMAT,       XA01145*/
         TM    DCBRECFM(RDCB),B'01000000'                          0270
         BNO   @RF00270                                            0270
         TM    DCBRECFM(RDCB),B'10000000'                          0270
         BNZ   @RF00270                                            0270
*                RBUF -> RDW = 0;       /* CLEAR OUT RDW      XA01145*/
*                                                                  0271
         SLR   @10,@10                                             0271
         STH   @10,RDW(,RBUF)                                      0271
*              IF DCBRECFM(1:2) = '01'B & DCBRECFM(5)   = '1'B/*   0272
*                                          SPANNED RECORDS ?        */
*                THEN                   /* YES, SPANNED RECORDS     */
@RF00270 TM    DCBRECFM(RDCB),B'01000000'                          0272
         BNO   @RF00272                                            0272
         TM    DCBRECFM(RDCB),B'10000000'                          0272
         BNZ   @RF00272                                            0272
         TM    DCBRECFM(RDCB),B'00001000'                          0272
         BNO   @RF00272                                            0272
*                  /* RETURN REMAINDER OF BLOCK TO USER IN R0. THIS */
*                  /* IS USED FOR SPANNED RECORDS ONLY.             */
*                  CIREGSV0 = CIRAREA + RPLBUFL - RBUF;            0273
         L     @10,CIRAREA(,RCICB)                                 0273
         AL    @10,RPLBUFL(,RRPL)                                  0273
         SLR   @10,RBUF                                            0273
         ST    @10,CIREGSV0(,R13)                                  0273
*                ELSE;                  /* NOT SPANNED RECORDS      */
@RF00272 DS    0H                                                  0275
*              IF DCBRECFM(1:2) = '10'B × DCBRECFM(1:2) = '11'B/*  0275
*                                          F OR U FORMAT ?          */
*                THEN                   /* YES, MAINTAIN DCB FIELDS */
         TM    DCBRECFM(RDCB),B'10000000'                          0275
         BNO   @GL00009                                            0275
         TM    DCBRECFM(RDCB),B'01000000'                          0275
         BZ    @RT00275                                            0275
@GL00009 TM    DCBRECFM(RDCB),B'11000000'                          0275
         BNO   @RF00275                                            0275
@RT00275 DS    0H                                                  0276
*                  DO;                  /* FOR COBOL PROGRAMS       */
*                    DCBRECAD = RBUF + DCBLRECL; /* SET 'NEXT' BUFR */
         LR    @10,RBUF                                            0277
         SLR   @09,@09                                             0277
         ICM   @09,3,DCBLRECL(RDCB)                                0277
         ALR   @10,@09                                             0277
         ST    @10,DCBRECAD(,RDCB)                                 0277
*                    DCBEOBAD = DCBRECAD;  /* SET 'EOB' CONDITION   */
         ST    @10,DCBEOBAD(,RDCB)                                 0278
*                  END;                 /* END OF U/F GROUP         */
*              RPLRLEN = DCBLRECL;      /* SET LENGTH FOR NEXT PUT  */
@RF00275 SLR   @10,@10                                             0280
         ICM   @10,3,DCBLRECL(RDCB)                                0280
         ST    @10,RPLRLEN(,RRPL)                                  0280
*              RPLAREA = RBUF;          /* RESET PTR TO RPLAREA     */
         ST    RBUF,RPLAREA(,RRPL)                                 0281
*            END;                       /* END OF DO GROUP          */
*/*******************************************************************/
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
@RF00268 DS    0H                                                  0283
         EJECT
*                                                                  0284
*                                                                  0284
*/*******************************************************************/
*/* IF PUT REQUEST IS FROM CLOSE, REGISTERS ARE NOT RESTORED        */
*/*******************************************************************/
*                                                                  0284
*                                                                  0284
*        IF CIFCLOSE = '1'B             /* WAS ENTRY FROM CLOSE RTN */
*          THEN                         /* YES                      */
         TM    CIFCLOSE(RCICB),B'01000000'                         0284
         BNO   @RF00284                                            0284
*            DO;                                                   0285
*              R14 = CIWK2;             /* RESTORE REGISTER 14      */
         L     R14,CIWK2(,RCICB)                                   0286
*              GOTO CLOSE;              /* GO RETURN TO CLOSE       */
         B     CLOSE                                               0287
*            END;                       /* END OF DO GROUP          */
*          ELSE;                                                   0289
@RF00284 DS    0H                                                  0290
*          GEN;                                                    0290
         LM    R14,R12,TWELVE(R13)      /* RESTORE USER'S REGSISTER */
*/*******************************************************************/
*CLOSE:  GEN   (BR R14);                /*   RETURN TO USER         */
CLOSE    BR R14
*/*******************************************************************/
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
         EJECT
*                                                                  0293
*                                                                  0293
*/*******************************************************************/
*/*  SEE IF ERROR PROCESSING IS REQUIRED                            */
*/*******************************************************************/
*                                                                  0293
*ERROR:                                                            0293
*        IF CIFCLOSE = '1'B THEN        /* ENTRY FROM CLOSE  XA00008*/
ERROR    TM    CIFCLOSE(RCICB),B'01000000'                         0293
         BNO   @RF00293                                            0293
*          GOTO RETREG;                 /* YES - DON'T GO    XA00008*/
         BR    RETREG                                              0294
*                                       /* TO SYNAD ROUTINE  XA00008*/
*                                                                  0295
*        IF CIFERROR = '0'B THEN        /* SYNAD RTN NOT YET INVOKED*/
@RF00293 TM    CIFERROR(RCICB),B'00000100'                         0295
         BNZ   @RF00295                                            0295
*          DO;                          /* NO                       */
*            R0 = ADDR(CISYNNAM);       /* COMING FROM INTERF. RTN  */
         LA    R0,CISYNNAM(,RCICB)                                 0297
*            GEN  (LOAD  EPLOC=(0));    /* LOAD SYNAD ROUTINE       */
         LOAD  EPLOC=(0)
*            R15 = R0;                  /* SET UP ADDRESS FOR CALL  */
         LR    R15,R0                                              0299
*            R1 = RRPL;                 /* SET UP LINKAGE AS IF     */
         LR    R1,RRPL                                             0300
*            GEN (BALR R14,R15);        /* GO TO SYNAD ROUTINE      */
         BALR R14,R15
*            R0 = ADDR(CISYNNAM);       /* POINT TO NAME AGAIN      */
         LA    R0,CISYNNAM(,RCICB)                                 0302
*            GEN (DELETE EPLOC=(0));    /* AND DELETE SYNAD MODULE  */
         DELETE EPLOC=(0)
*          END;                         /* END OF PROCESSING FOR NOT*/
*        CIFERROR = '0'B;               /* TURN OFF 'SYNAD ENTERED' */
@RF00295 NI    CIFERROR(RCICB),B'11111011'                         0305
*        GOTO RETREG;                   /* AND EXIT ERROR PROCESSING*/
         BR    RETREG                                              0306
*/*******************************************************************/
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
         EJECT
*                                                                  0308
*                                                                  0308
*/********************************************************************/
*/*                                                                  */
*/* ENTRY POINTS FOR RELSE, CNTRL,  AND TRUNC                        */
*/*                                                                  */
*/********************************************************************/
*                                                                  0308
*RELSERTN:                              /* RELSE EP                  */
*TRUNCRTN:                              /* TRUNC EP                  */
*CNTRLRTN:                              /* CNTRL EP            XM3766*/
*NOOPRTN:                               /* INVALID EP (NO-OP)        */
*                                                                  0308
*/********************************************************************/
*/* BECAUSE NO FUNCTION IS PERFORMED BY CI, CONTROL IS RETURNED      */
*/*                                          TO THE USER.            */
*/********************************************************************/
*                                                                  0308
*                                                                  0308
*        GEN   (BR 14);                 /* RETURN TO USER OR CLOSE   */
RELSERTN DS    0H                                                  0308
TRUNCRTN DS    0H                                                  0308
CNTRLRTN DS    0H                                                  0308
NOOPRTN  BR 14
*/********************************************************************/
*        GEN   (EJECT);                 /* SKIP TO A NEW PAGE       */
         EJECT
*                                                                  0310
*                                                                  0310
*/*******************************************************************/
*/*                                                                 */
*/*  PUTX ROUTINE                                                   */
*/*                                                                 */
*/*******************************************************************/
*                                                                  0310
*PUTXRTN:                                                          0310
*        GEN (STM R14,R12,12(R13));     /* SAVE USERS REGISTERS     */
PUTXRTN  STM R14,R12,12(R13)
*        RBUF = R0;                     /* SAVE POINTER TO INPUT DCB*/
         LR    RBUF,R0                                             0311
*        RDCB = R1;                     /* ESTABLISH DCB BASE       */
         LR    RDCB,R1                                             0312
*        RCICB = DCBCICB;               /* ESTABLISH CICB BASE      */
         L     RCICB,DCBCICB(,RDCB)                                0313
*        R11 = R15;                     /* SET UP BASE REGISTER     */
         LR    R11,R15                                             0314
*        GEN;                                                      0315
         LA    R7,PUTENTRY-GETENTRY     DISPLACEMENT-ENTRY TO BASE
         SR    R11,R7                   POINT TO GETENTRY
*/*******************************************************************/
*                                                                  0316
*        CIREGBC = R13;                 /* BACK POINTER TO USER SAVE*/
         ST    R13,CIREGBC(,RCICB)                                 0316
*        R13 = ADDR(CIREGSAV);          /* SET CI SAVE ADDRESS      */
         LA    R13,CIREGSAV(,RCICB)                                0317
*        RRPL = ADDR(CIRPL);            /* ESTABLISH RPL BASE       */
*                                                                  0318
         LA    RRPL,CIRPL(,RCICB)                                  0318
*/*******************************************************************/
*/* RBUF POINTS TO THE INPUT DCB, WHICH CONTAINS THE ADDRESS OF THE */
*/* INPUT RECORD TO BE WRITTEN OUT BY PUTX FOR SIMPLE BUFFERING,    */
*/* OR THE ADDR OF A CCW WHICH POINTS TO THE RECORD FOR EXCHANGE    */
*/* BUFFERING.                                                      */
*/* THIS ROUTINE PUTS THE BUFFER ADDR IN RBUF AND BRANCHES TO THE   */
*/* PUT MOVE ROUTINE.                                               */
*/*******************************************************************/
*                                                                  0319
*        R7 = RBUF;                     /* INPUT DCB ADDR           */
         LR    R7,RBUF                                             0319
*        RBUF = R7 ->DCBRECAD;          /* ADDR OF INPUT BUFFER     */
         L     RBUF,DCBRECAD(,R7)                                  0320
*        IF R7 ->DCBCIND1(8) = '1'B     /* EXCH BUFFERING SUPPORTED?*/
*         THEN                          /* YES, DCBRECAD POINTS TO  */
         TM    DCBCIND1(R7),B'00000001'                            0321
         BNO   @RF00321                                            0321
*          DO;                          /* CCW WHICH POINTS TO THE  */
*           RBUF = RBUF -> IOBCCW;      /* THE BUFFER               */
         L     RBUF,IOBCCW(,RBUF)                                  0323
*          END;                                                    0324
*        GO TO PUTMOVE;                 /* GO TO PUT MOVE ROUTINE   */
         B     PUTMOVE                                             0325
*/*******************************************************************/
*        END   IGG019DJ                 /* END OF QSAM PUT MODULE   */
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IFGSDCB )                                        *
*/*%INCLUDE SYSLIB  (IFGJCICB)                                        *
*/*%INCLUDE SYSLIB  (IFGRPL  )                                        *
*/*%INCLUDE SYSLIB  (IDARMRCD)                                        *
*;                                                                 0326
@EL00001 DS    0H                                                  0326
@EF00001 DS    0H                                                  0326
@ER00001 BR    @14                                                 0326
@DATA    DS    0H
@DATD    DSECT
         DS    0F
@ZTEMPS  DS    C
@ZTEMPND EQU   *
@ZLEN    EQU   @ZTEMPND-@ZTEMPS
@TEMPS   EQU   @ZTEMPS
@L       EQU   @ZLEN
IGG019DJ CSECT
         DS    0F
@DATD    DSECT
         DS    0D
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
@DATEND  EQU   *
IGG019DJ CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
@SIZ001  EQU   @SIZDATD
         DS    0D
GREQTYP  DC    XL4'00000000'
PREQTYP  DC    XL4'00000001'
ZERO     DC    F'0'
ONE      DC    AL2(1)
FOUR     DC    AL2(4)
RPLDVOL  DC    AL1(4)
RPLMOKEY DC    AL1(8)
RPLWTBFR DC    AL1(12)
RPLEODER DC    AL1(4)
RPLDUP   DC    AL1(8)
RPLSEQCK DC    AL1(12)
RPLNOREC DC    AL1(16)
RPLEXCL  DC    AL1(20)
RPLNOMNT DC    AL1(24)
RPLNOEXT DC    AL1(28)
RPLINRBA DC    AL1(32)
RPLNOKR  DC    AL1(36)
RPLNOVRT DC    AL1(40)
RPLINBUF DC    AL1(44)
RPLNOPLH DC    AL1(64)
RPLINACC DC    AL1(68)
RPLINKEY DC    AL1(72)
RPLINADR DC    AL1(76)
RPLERSER DC    AL1(80)
RPLINLOC DC    AL1(84)
RPLNOPTR DC    AL1(88)
RPLINUPD DC    AL1(92)
RPLKEYCH DC    AL1(96)
RPLDLCER DC    AL1(100)
RPLINVP  DC    AL1(104)
RPLINLEN DC    AL1(108)
RPLKEYLC DC    AL1(112)
RPLINLRQ DC    AL1(116)
RPLINTCB DC    AL1(120)
RPLSRLOC DC    AL1(132)
RPLARSRK DC    AL1(136)
RPLSRISG DC    AL1(140)
RPLNBRCD DC    AL1(144)
RPLNXPTR DC    AL1(148)
RPLNOBFR DC    AL1(152)
RPLIRRNO DC    AL1(192)
RPLRRADR DC    AL1(196)
RPLPAACI DC    AL1(200)
RPLPUTBK DC    AL1(204)
RPLRDERD DC    AL1(4)
RPLRDERI DC    AL1(8)
RPLRDERS DC    AL1(12)
RPLWTERD DC    AL1(16)
RPLWTERI DC    AL1(20)
RPLWTERS DC    AL1(24)
RPLBASER DC    AL1(0)
RPLBASUM DC    AL1(1)
RPLAIXER DC    AL1(2)
RPLAIXUM DC    AL1(3)
RPLUPGER DC    AL1(4)
RPLUPGUM DC    AL1(5)
ERR4     DC    AL1(4)
ERR5     DC    AL1(5)
ERR6     DC    AL1(6)
PATCH    DC    CL60' '
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
@0       EQU   00
@1       EQU   01
@2       EQU   02
@3       EQU   03
@4       EQU   04
@5       EQU   05
@6       EQU   06
@7       EQU   07
@8       EQU   08
@9       EQU   09
@A       EQU   10
@B       EQU   11
@C       EQU   12
@D       EQU   13
@E       EQU   14
@F       EQU   15
R0       EQU   @00
R1       EQU   @01
RRPL     EQU   @02
RCICB    EQU   @03
RDCB     EQU   @04
RBUF     EQU   @05
R7       EQU   @07
RETREG   EQU   @08
R11      EQU   @11
R12      EQU   @12
R13      EQU   @13
R14      EQU   @14
R15      EQU   @15
IFGSDCB  EQU   0
DCBBUFCB EQU   IFGSDCB+20
DCBIOBAD EQU   IFGSDCB+28
@NM00003 EQU   IFGSDCB+32
DCBHIARC EQU   @NM00003
DCBBFTEK EQU   DCBHIARC
DCBRECFM EQU   IFGSDCB+36
DCBDDNAM EQU   IFGSDCB+40
DCBMACRF EQU   DCBDDNAM+2
DCBIFLGS EQU   DCBDDNAM+4
DCBREAD  EQU   IFGSDCB+49
DCBWRITE EQU   DCBREAD
DCBGET   EQU   DCBWRITE
DCBPUT   EQU   DCBGET
DCBCHECK EQU   IFGSDCB+53
DCBGERR  EQU   DCBCHECK
DCBCIND1 EQU   IFGSDCB+60
DCBBLKSI EQU   IFGSDCB+62
DCBIOBA  EQU   IFGSDCB+68
DCBCICB  EQU   DCBIOBA
DCBEOBAD EQU   IFGSDCB+72
DCBLCCW  EQU   DCBEOBAD
DCBEOBR  EQU   DCBLCCW
@NM00004 EQU   IFGSDCB+76
DCBEOBW  EQU   @NM00004
DCBRECAD EQU   DCBEOBW
DCBDIRCT EQU   IFGSDCB+80
DCBLRECL EQU   IFGSDCB+82
@NM00005 EQU   IFGSDCB+84
DCBEROPT EQU   @NM00005
DCBCNTRL EQU   @NM00005+1
DCBNOTE  EQU   DCBCNTRL
DCBPRECL EQU   IFGSDCB+90
IFGJCICB EQU   0
CIDUMIOB EQU   IFGJCICB
CISYNNAM EQU   IFGJCICB+108
CIREGSAV EQU   IFGJCICB+116
CIREGBC  EQU   CIREGSAV+4
CIFLAGS  EQU   IFGJCICB+188
CIFLAG1  EQU   CIFLAGS
CIFLAG2  EQU   CIFLAGS+1
CIFLAG3  EQU   CIFLAGS+2
CIFFSTP  EQU   CIFLAG3
CIFCLOSE EQU   CIFLAG3
CIFERROR EQU   CIFLAG3
CIRPL    EQU   IFGJCICB+192
CILWAREA EQU   IFGJCICB+304
CIIOCNT  EQU   IFGJCICB+308
CISEGLEN EQU   CIIOCNT
CIRAREA  EQU   IFGJCICB+316
CIRECPTR EQU   IFGJCICB+320
CIWK2    EQU   IFGJCICB+332
CISVCLST EQU   IFGJCICB+336
CISYNADA EQU   CISVCLST
CIBLDL   EQU   CISVCLST+4
CIBSP    EQU   CISVCLST+8
CIFEOV   EQU   CISVCLST+12
CISTOW   EQU   CISVCLST+16
IFGRPL   EQU   0
RPLCOMN  EQU   IFGRPL
RPLIDWD  EQU   RPLCOMN
RPLLEN   EQU   RPLIDWD+3
RPLECB   EQU   RPLCOMN+8
RPLFDBWD EQU   RPLCOMN+12
RPLFDBK  EQU   RPLFDBWD+1
RPLRTNCD EQU   RPLFDBK
RPLCNDCD EQU   RPLFDBK+1
RPLCMPON EQU   RPLCNDCD
RPLFDB2  EQU   RPLCMPON
RPLERRCD EQU   RPLCNDCD+1
RPLFDB3  EQU   RPLERRCD
RPLKEYLE EQU   RPLCOMN+16
RPLCCHAR EQU   RPLCOMN+20
RPLAREA  EQU   RPLCOMN+32
RPLARG   EQU   RPLCOMN+36
RPLOPTCD EQU   RPLCOMN+40
RPLOPT1  EQU   RPLOPTCD
RPLECBSW EQU   RPLOPT1
RPLOPT2  EQU   RPLOPTCD+1
RPLADR   EQU   RPLOPT2
RPLOPT3  EQU   RPLOPTCD+2
RPLNXTRP EQU   RPLCOMN+44
RPLRLEN  EQU   RPLCOMN+48
RPLBUFL  EQU   RPLCOMN+52
RPLOPTC2 EQU   RPLCOMN+56
RPLOPT5  EQU   RPLOPTC2
RPLWRTYP EQU   RPLOPT5
RPLOPT6  EQU   RPLOPTC2+1
RPLUNTYP EQU   RPLOPT6
RPLOPT7  EQU   RPLOPTC2+2
RPLCNOPT EQU   RPLOPT7
RPLOPT8  EQU   RPLOPTC2+3
RPLRBAR  EQU   RPLCOMN+60
RPLAIXID EQU   RPLRBAR+2
RPLEXTDS EQU   RPLCOMN+68
RPLEXTD1 EQU   RPLEXTDS
BUFFER   EQU   0
ALLROW   EQU   BUFFER
RDW      EQU   ALLROW
@NM00016 EQU   ALLROW+2
SEGCC    EQU   @NM00016
REGSAVE  EQU   0
CIREGSV0 EQU   REGSAVE+20
CIREGSV1 EQU   REGSAVE+24
SEGMENT  EQU   0
IOBCCW   EQU   0
*                                      START UNREFERENCED COMPONENTS
CIREGSV7 EQU   REGSAVE+48
@NM00019 EQU   REGSAVE+28
CIREGSVF EQU   REGSAVE+16
@NM00018 EQU   REGSAVE
BUFREC   EQU   BUFFER+4
FILLER   EQU   ALLROW+3
@NM00017 EQU   @NM00016
RPLERMSA EQU   RPLCOMN+72
RPLEMLEN EQU   RPLCOMN+70
RPLACTIV EQU   RPLCOMN+69
RPLBRANC EQU   RPLEXTD1
RPLNIB   EQU   RPLEXTD1
@NM00015 EQU   RPLEXTD1
RPLEXIT  EQU   RPLEXTD1
RPLNEXIT EQU   RPLEXTD1
RPLEXSCH EQU   RPLEXTD1
RPLDDDD  EQU   RPLRBAR+4
@NM00014 EQU   RPLRBAR+3
@NM00013 EQU   RPLAIXID
RPLAXPKP EQU   RPLAIXID
RPLAIXPC EQU   RPLRBAR
RPLRSV88 EQU   RPLOPT8
RPLUNCON EQU   RPLOPT8
RPLACTV  EQU   RPLOPT8
RPLSESS  EQU   RPLOPT8
RPLPEND  EQU   RPLOPT8
RPLODPRM EQU   RPLOPT8
RPLODACP EQU   RPLOPT8
RPLODACQ EQU   RPLOPT8
RPLRSV78 EQU   RPLOPT7
RPLRSV77 EQU   RPLOPT7
RPLRLSOP EQU   RPLOPT7
RPLTPOST EQU   RPLOPT7
RPLQOPT  EQU   RPLOPT7
RPLCNIMM EQU   RPLCNOPT
RPLCNANY EQU   RPLCNOPT
RPLCNALL EQU   RPLCNOPT
RPLRSV68 EQU   RPLOPT6
RPLRSV67 EQU   RPLOPT6
RPLLOCK  EQU   RPLOPT6
RPLNCOND EQU   RPLOPT6
RPLCOND  EQU   RPLOPT6
RPLEOT   EQU   RPLUNTYP
RPLEOM   EQU   RPLUNTYP
RPLEOB   EQU   RPLUNTYP
RPLWROPT EQU   RPLOPT5
RPLNODE  EQU   RPLOPT5
RPLERACE EQU   RPLWRTYP
RPLEAU   EQU   RPLWRTYP
RPLNERAS EQU   RPLWRTYP
RPLPSOPT EQU   RPLOPT5
RPLSSNIN EQU   RPLOPT5
RPLDLGIN EQU   RPLOPT5
RPLCHAIN EQU   RPLNXTRP
RPLOPT4  EQU   RPLOPTCD+3
RPLALIGN EQU   RPLOPT3
RPLFMT   EQU   RPLOPT3
RPLFLD   EQU   RPLOPT3
RPLVFY   EQU   RPLOPT3
RPLBLK   EQU   RPLOPT3
RPLSFORM EQU   RPLOPT3
RPLEODS  EQU   RPLOPT3
RPLNSP   EQU   RPLOPT2
RPLUPD   EQU   RPLOPT2
RPLWAITX EQU   RPLOPT2
RPLLRD   EQU   RPLOPT2
RPLBWD   EQU   RPLOPT2
RPLCNV   EQU   RPLOPT2
RPLADD   EQU   RPLADR
RPLKEY   EQU   RPLOPT2
RPLECBIN EQU   RPLECBSW
RPLGEN   EQU   RPLOPT1
RPLKGE   EQU   RPLOPT1
RPLASY   EQU   RPLOPT1
RPLSKP   EQU   RPLOPT1
RPLSEQ   EQU   RPLOPT1
RPLDIR   EQU   RPLOPT1
RPLLOC   EQU   RPLOPT1
RPLDAF   EQU   RPLARG+2
RPLSAF   EQU   RPLARG
RPLTCBPT EQU   RPLCOMN+28
RPLDACB  EQU   RPLCOMN+24
RPLSTRID EQU   RPLCOMN+18
RPLKEYL  EQU   RPLKEYLE
RPLRDSOH EQU   RPLFDB3
RPLRLG   EQU   RPLFDB3
RPLLGFRC EQU   RPLFDB3
RPLREOT  EQU   RPLFDB3
RPLREOM  EQU   RPLFDB3
RPLREOB  EQU   RPLFDB3
RPLSV32  EQU   RPLFDB3
RPLUINPT EQU   RPLFDB3
RPLSTSAV EQU   RPLFDB2
RPLCUERR EQU   RPLFDB2
RPLDLGFL EQU   RPLFDB2
RPLIOERR EQU   RPLFDB2
RPLDVUNS EQU   RPLFDB2
RPLATND  EQU   RPLFDB2
RPLRVID  EQU   RPLFDB2
RPLERLK  EQU   RPLFDB2
RPLERREG EQU   RPLRTNCD
RPLSTAT  EQU   RPLFDBWD
RPLPOST  EQU   RPLECB
RPLWAIT  EQU   RPLECB
RPLPLHPT EQU   RPLCOMN+4
RPLLEN2  EQU   RPLLEN
RPLREQ   EQU   RPLIDWD+2
RPLSTYP  EQU   RPLIDWD+1
RPLID    EQU   RPLIDWD
CISTOWRC EQU   CISTOW
CIFEOVRC EQU   CIFEOV
CIBSPRC  EQU   CIBSP
CIBLDLRC EQU   CIBLDL
CISYNRC  EQU   CISYNADA
CIWK1    EQU   IFGJCICB+328
CISAMWA  EQU   IFGJCICB+324
CIBLKPTR EQU   IFGJCICB+312
CIFDBCK  EQU   IFGJCICB+284
CIRPLEXT EQU   IFGJCICB+268
CIFLAG4  EQU   CIFLAGS+3
@NM00012 EQU   CIFLAG3
CIFPOINT EQU   CIFLAG3
CIFVSEOB EQU   CIFLAG3
CIFVSRI  EQU   CIFLAG3
CIFRAGM  EQU   CIFLAG3
@NM00011 EQU   CIFLAG2
CIFMDEVT EQU   CIFLAG2
CIFMDSOR EQU   CIFLAG2
CIREGS   EQU   CIREGSAV+12
CIREGFC  EQU   CIREGSAV+8
@NM00010 EQU   CIREGSAV
CIACBED  EQU   IFGJCICB+88
CIACBD   EQU   IFGJCICB+32
CIDCBPTR EQU   CIDUMIOB+28
@NM00009 EQU   CIDUMIOB+24
CIRESID  EQU   CIDUMIOB+20
@NM00008 EQU   CIDUMIOB+16
CIECBPTR EQU   CIDUMIOB+12
CIIOB    EQU   CIDUMIOB+8
@NM00007 EQU   CIDUMIOB+5
CIECBCD  EQU   CIDUMIOB+4
CINXTIOB EQU   CIDUMIOB
DCBEOB   EQU   IFGSDCB+92
@NM00006 EQU   IFGSDCB+88
DCBPOINT EQU   DCBNOTE
DCBQSWS  EQU   DCBDIRCT
DCBCCCW  EQU   DCBRECAD
DCBNCP   EQU   DCBEOBR
DCBOFFSW EQU   IFGSDCB+67
DCBOFFSR EQU   IFGSDCB+66
DCBWCPL  EQU   IFGSDCB+65
DCBWCPO  EQU   IFGSDCB+64
DCBCIND2 EQU   IFGSDCB+61
DCBSYNAD EQU   IFGSDCB+57
DCBIOBL  EQU   IFGSDCB+56
DCBPERR  EQU   DCBGERR
DCBOPTCD EQU   IFGSDCB+52
DCBMACR  EQU   DCBPUT+1
DCBIFLG  EQU   DCBPUT
DCBOFLGS EQU   IFGSDCB+48
DCBDEBAD EQU   DCBDDNAM+5
DCBTIOT  EQU   DCBDDNAM
DCBEXLST EQU   IFGSDCB+37
DCBEODAD EQU   IFGSDCB+33
DCBBFALN EQU   DCBBFTEK
DCBSVCXL EQU   DCBIOBAD
DCBDSORG EQU   IFGSDCB+26
DCBBUFL  EQU   IFGSDCB+24
DCBBUFNO EQU   DCBBUFCB
@NM00002 EQU   IFGSDCB+16
@NM00001 EQU   IFGSDCB
*                                      END UNREFERENCED COMPONENTS
@RF00118 EQU   FINGET
@RT00124 EQU   EODADDR
@RC00130 EQU   ERROR
@RT00142 EQU   FIXRCD
@RF00167 EQU   PUTMOVE
@RT00177 EQU   GOBACK
@RF00179 EQU   JESPUT
@RT00184 EQU   SPANNED
@RF00184 EQU   LENTEST
@RF00183 EQU   PUTMOVE
@RT00188 EQU   GOBACK
@RT00207 EQU   CONTIN01
@RF00221 EQU   LENTEST
@RT00234 EQU   GOBACK
@RF00238 EQU   LENTEST2
@RF00321 EQU   PUTMOVE
@EL01    EQU   @EL00001
@ENDDATA EQU   *
         END   IGG019DJ,(C'PLS1815',0701,76336)
