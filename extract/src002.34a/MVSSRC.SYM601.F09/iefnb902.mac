         TITLE 'IEFVAMP - AMP PARAMETER INTERPRETER                    *
                        '
IEFNB902 CSECT ,                                                   0001
@MAINENT DS    0H                                                  0001
         USING *,@15                                               0001
         B     @PROLOG                                             0001
         DC    AL1(16)                                             0001
         DC    C'IEFNB902  76.254'                                 0001
         DROP  @15
@PROLOG  STM   @14,@12,12(@13)                                     0001
         BALR  @12,0                                               0001
@PSTART  DS    0H                                                  0001
         USING @PSTART,@12                                         0001
         EJECT
         EJECT
         EJECT
*        /* THIS IS THE ROOT SEGMENT OF IEFVAMP                     */
*    CALL INITIALZ;                         /* CORE FOR THE DATA    */
         BAL   @14,INITIALZ                                        0012
*                                           /* AREA MUST BE GOTTEN  */
*                                           /* AND THE REGISTERS    */
*                                           /* INITIALIZED          */
*    GEN(USING  @DATD,DATAPTR);             /* INITIALZ GETS DATA   */
         USING  @DATD,DATAPTR
*                                           /* CODE AND INIT DATAPTR*/
*                                           /* USING MUST BE PLACED */
*                                           /* AT START OF IEFVAMP  */
*    IF REG15 = 0 THEN                      /* CHECK FOR SUCCESS INI*/
         LTR   REG15,REG15                                         0014
         BNZ   @RF00014                                            0014
*      DO;                                  /* PROCEED IF OK GETCORE*/
*                                                                  0015
*        DO WHILE STRINGPT < PARMLENG;      /* CONTINUE PROCESSING  */
         B     @DE00016                                            0016
@DL00016 DS    0H                                                  0017
*                                           /* UNTIL END OF STRING  */
*          CALL GETWORD;                    /* GET A WORD FROM THE  */
         BAL   @14,GETWORD                                         0017
*                                           /* PARAMETER STRING     */
*                                                                  0018
*          IF LENGST = 0 THEN               /* IF 0 THEN A NULL WORD*/
         LTR   LENGST,LENGST                                       0018
         BNZ   @RF00018                                            0018
*                                           /* WAS DISCOVERED ,     */
*            DO;                            /* INDICATE ERROR TYPE  */
*                                           /* AND GOTO ERROR RTN   */
*              MSGCODE = 1;                 /* INVALID KEYWORD MSG  */
         MVC   MSGCODE(4,DATAPTR),@CF00045                         0020
*              CALL ERROR;                  /* BUILD ERROR MSG RTN  */
         BAL   @14,ERROR                                           0021
*            END;                           /* END PROCESSING FOR   */
*                                           /* THIS KEYWORD OF ,    */
*                                                                  0023
*          ELSE                             /* WORD FOUND, BEGIN    */
*            DO;                            /* NORMAL PROCESSING    */
         B     @RC00018                                            0023
@RF00018 DS    0H                                                  0024
*              ENTRYPTR = ADDR(TABLE1);     /* POINT TO MAIN KEYWORD*/
         LA    ENTRYPTR,TABLE1                                     0024
*                                           /* TABLE                */
*              CALL FINDKEY;                /* SEARCH TABLE FOR KEY */
         BAL   @14,FINDKEY                                         0025
*              IF FINDERR = '1'B THEN       /* IF END THEN NO KEY   */
         TM    FINDERR(DATAPTR),B'10000000'                        0026
         BNO   @RF00026                                            0026
*                DO;                        /* WAS FOUND IN TABLE   */
*                  CALL ERROR;              /* BUILD ERROR MSG RTN  */
         BAL   @14,ERROR                                           0028
*                END;                       /* END PROCESSING FOR   */
*                                           /* THIS KEYWORD         */
*              ELSE                         /* CHECKS FLAGS FOR TYPE*/
*                DO;                        /* OF PROCESSING REQUIRD*/
         B     @RC00026                                            0030
@RF00026 DS    0H                                                  0031
*                  IF SUBWORDS = '1'B   THEN/* KEYWORD HAVE KEYWORD */
         TM    SUBWORDS(ENTRYPTR),B'10000000'                      0031
         BNO   @RF00031                                            0031
*                    DO;                    /* PROCESS SUB KEYWORDS */
*                      ENTRYPTR = ENTCHAIN; /* GET SUB KEYS TABLE   */
         L     ENTRYPTR,ENTCHAIN(,ENTRYPTR)                        0033
*                      CALL GETWORD;        /* GET THE SUB KEYWORD  */
         BAL   @14,GETWORD                                         0034
*                      CALL FINDKEY;        /* CHECK IF DEFINED     */
         BAL   @14,FINDKEY                                         0035
*                      IF FINDERR= '1'B THEN/*                     0036
*                                             WAS KEY FOUND @Y30LSPS*/
         TM    FINDERR(DATAPTR),B'10000000'                        0036
         BNO   @RF00036                                            0036
*                        DO;                /* ERROR IF NOT FOUND   */
*                          CALL ERROR;      /* BUILT THE ERROR MSG  */
         BAL   @14,ERROR                                           0038
*                        END;               /* END IF NOT FOUND     */
*                                                                  0039
*                      ELSE                 /* IF A KEYWORD ENTRY   */
*                                           /* WAS FOUND, THE BIT IN*/
*                        DO;                /* THE JFCB FOR THIS KEY*/
         B     @RC00036                                            0040
@RF00036 DS    0H                                                  0041
*                                           /* WILL BE UPDATED      */
*                          IF OVERFLOW = '1'B   THEN/*             0041
*                                                     JFCB EXTENSION*/
         TM    OVERFLOW(ENTRYPTR),B'00000010'                      0041
         BNO   @RF00041                                            0041
*                            CALL ADDJFCB;  /* GET EXT IF JFCB OVER */
         BAL   @14,ADDJFCB                                         0042
*                          ELSE JFCBREG = JFCBPTR; /* USE JFCB IF OK*/
         B     @RC00041                                            0043
@RF00041 L     JFCBREG,JFCBPTR(,PARMPTR)                           0043
*                                           /* ORING IN OF A BIT IS */
*                                           /* THE ONLY TYPE OF OP  */
*                                           /* SUPPORTED            */
*                                           /* IF MORE THAN ONE KEY */
*                                           /* CAN BE SPECIFIED, IT */
*                                           /* IS HANDLED UNDER     */
*                                           /* POSITIONAL KEYWORDS  */
*                          WORKREG = JFCBREG + JFCBDISP -1; /*  ADDR*/
@RC00041 LR    WORKREG,JFCBREG                                     0044
         SLR   @09,@09                                             0044
         IC    @09,JFCBDISP(,ENTRYPTR)                             0044
         ALR   WORKREG,@09                                         0044
         BCTR  WORKREG,0                                           0044
*                                           /* IF BIT TO OR INTO    */
*                          GEN(OC  0(1,WORKREG),BYTEMASK(ENTRYPTR));
         OC  0(1,WORKREG),BYTEMASK(ENTRYPTR)
*                                           /* THE BYTEMASK IN THE  */
*                                           /* ENTRY MUST BE ORED IN*/
*                                           /* TO THE JFCB          */
*                        END;               /* END VALID SUB KEYWORD*/
*                    END;                   /* END SUB KEYWORDS RTN */
*                                                                  0047
*                  ELSE                     /* CHECK FOR OR REQUEST */
*                    IF ORMASK = '1'B   THEN/* OR A BIT INTO JFCB RQ*/
         B     @RC00031                                            0048
@RF00031 TM    ORMASK(ENTRYPTR),B'01000000'                        0048
         BNO   @RF00048                                            0048
*                      DO;                  /* OR BITS INTO THE JFCB*/
*                        IF OVERFLOW = '1'B   THEN/*               0050
*                                                   JFCB EXTENSION  */
         TM    OVERFLOW(ENTRYPTR),B'00000010'                      0050
         BNO   @RF00050                                            0050
*                          CALL ADDJFCB;    /* GET EXT IF OVERFLOW  */
         BAL   @14,ADDJFCB                                         0051
*                        ELSE JFCBREG = JFCBPTR; /* USE JFCB IF OK  */
*                                                                  0052
         B     @RC00050                                            0052
@RF00050 L     JFCBREG,JFCBPTR(,PARMPTR)                           0052
*                        WORKREG = JFCBREG + JFCBDISP -1; /*   ADDR */
@RC00050 LR    WORKREG,JFCBREG                                     0053
         SLR   @09,@09                                             0053
         IC    @09,JFCBDISP(,ENTRYPTR)                             0053
         ALR   WORKREG,@09                                         0053
         BCTR  WORKREG,0                                           0053
*                                           /* OF BYTE TO OR INTO   */
*                        GEN(OC  0(1,WORKREG),BYTEMASK(ENTRYPTR)); 0054
         OC  0(1,WORKREG),BYTEMASK(ENTRYPTR)
*                                           /* THE BYTEMASK IN THE  */
*                                           /* ENTRY MUST BE ORED IN*/
*                                           /* TO THE JFCB          */
*                      END;                 /* END OF OR REQUEST    */
*                                                                  0055
*                    ELSE                   /* CHECK IF MOVE REQUEST*/
*                      IF MOVECHAR = '1'B   THEN/*                 0056
*                                                 MOVE WORD TO JFCB */
         B     @RC00048                                            0056
@RF00048 TM    MOVECHAR(ENTRYPTR),B'00100000'                      0056
         BNO   @RF00056                                            0056
*                        DO;                /* GET CHARACTER AND MOV*/
*                          CALL GETWORD;    /* GET A WORD FROM STRNG*/
         BAL   @14,GETWORD                                         0058
*                          IF LENGST = 0 THEN     /* CHECK FOR NULL */
         LTR   LENGST,LENGST                                       0059
         BNZ   @RF00059                                            0059
*                            DO;            /* ERROR OF NULL WORD   */
*                              MSGCODE = 1;   /* NULL OR INVALID MSG*/
         MVC   MSGCODE(4,DATAPTR),@CF00045                         0061
*                              CALL ERROR;  /* BUILD THE ERROR MSG  */
         BAL   @14,ERROR                                           0062
*                            END;           /* END NULL PROCESSING  */
*                                                                  0063
*                          ELSE             /* MOVE 8 CHARATERS INTO*/
*                            DO;            /* JFCB OR JFCB EXTENSIO*/
         B     @RC00059                                            0064
@RF00059 DS    0H                                                  0065
*                              IF OVERFLOW = '1'B   THEN/*         0065
*                                                         JFCB EXT  */
         TM    OVERFLOW(ENTRYPTR),B'00000010'                      0065
         BNO   @RF00065                                            0065
*                                CALL ADDJFCB; /* GET EXT IF OFL    */
         BAL   @14,ADDJFCB                                         0066
*                              ELSE JFCBREG = JFCBPTR; /* USE JFCB  */
         B     @RC00065                                            0067
@RF00065 L     JFCBREG,JFCBPTR(,PARMPTR)                           0067
*                              JFCB(JFCBDISP:JFCBDISP+SIZE-1)=KEYBUF8;
@RC00065 SLR   @09,@09                                             0068
         IC    @09,JFCBDISP(,ENTRYPTR)                             0068
         ALR   @09,JFCBREG                                         0068
         BCTR  @09,0                                               0068
         SLR   @15,@15                                             0068
         IC    @15,SIZE(,ENTRYPTR)                                 0068
         BCTR  @15,0                                               0068
         EX    @15,@SM00739                                        0068
*                            END;           /* END VALID MVC        */
*                                           /* THE JFCB FROM THE    */
*                                           /* KEYWORD BUFFER       */
*                        END;               /* END OF MOVE CHAR PROC*/
*                                                                  0070
*                      ELSE                 /* CHECK IF VALUE       */
*                        IF CONVERT = '1'B   THEN/*                0071
*                                                  CONVERT TO BINARY*/
         B     @RC00056                                            0071
@RF00056 TM    CONVERT(ENTRYPTR),B'00010000'                       0071
         BNO   @RF00071                                            0071
*                          DO;              /* VALIDITY CHECK AND   */
*                            CALL GETWORD;  /* GET THE VALUE FROM ST*/
         BAL   @14,GETWORD                                         0073
*                            IF LENGST = 0 THEN    /* CHECK FOR NULL*/
         LTR   LENGST,LENGST                                       0074
         BNZ   @RF00074                                            0074
*                              DO;          /* ERROR OF NULL WORD   */
*                                MSGCODE = 1;   /* NULL INVALID MSG */
         MVC   MSGCODE(4,DATAPTR),@CF00045                         0076
*                                CALL ERROR; /* BUILD THE ERROR MSG */
         BAL   @14,ERROR                                           0077
*                              END;         /* END NULL PROCESSING  */
*                            ELSE CALL VALUE; /* CHECK CVB, AND MVC */
         B     @RC00074                                            0079
@RF00074 BAL   @14,VALUE                                           0079
*                          END;             /* END DECIMAL VALUE P  */
*                                                                  0080
*                        ELSE               /* CHECK IF POSITIONAL  */
*                          IF POSITKEY = '1'B   THEN/*             0081
*                                                      POSITIONL KEY*/
         B     @RC00071                                            0081
@RF00071 TM    POSITKEY(ENTRYPTR),B'00001000'                      0081
         BNO   @RF00081                                            0081
*                            CALL POSITINL; /* THE FOR PROCESSING   */
*                                                                  0082
         BAL   @14,POSITINL                                        0082
*                          ELSE             /* CHECK IF AND BITS OFF*/
*                            IF ANDIT = '1'B THEN/*                0083
*                                                  AND INDICATOR    */
         B     @RC00081                                            0083
@RF00081 TM    ANDIT(ENTRYPTR),B'00000001'                         0083
         BNO   @RF00083                                            0083
*                              DO;          /* AND THE BITS OFF     */
*                                WORKREG = JFCBPTR + JFCBDISP - 1; 0085
         SLR   WORKREG,WORKREG                                     0085
         IC    WORKREG,JFCBDISP(,ENTRYPTR)                         0085
         AL    WORKREG,JFCBPTR(,PARMPTR)                           0085
         BCTR  WORKREG,0                                           0085
*                             GEN(NC 0(1,WORKREG),BYTEMASK(ENTRYPTR));
         NC 0(1,WORKREG),BYTEMASK(ENTRYPTR)
*                              END;         /* END IF AND BITS OFF  */
*                            ELSE;          /* NO MORE BITS DEFINED */
*                                                                  0088
@RF00083 DS    0H                                                  0089
*                END;                       /* END OF PROCESS IF IN */
@RC00081 DS    0H                                                  0089
@RC00071 DS    0H                                                  0089
@RC00056 DS    0H                                                  0089
@RC00048 DS    0H                                                  0089
@RC00031 DS    0H                                                  0090
*                                           /* THE KEYWORD TABLE    */
*                                                                  0090
*            END;                           /* END OF NORMAL PROCESS*/
@RC00026 DS    0H                                                  0091
*                                           /* FOR THIS JCL KEYWORD */
*                                                                  0091
*        END;                               /* END OF DO WHILE LOOP */
@RC00018 DS    0H                                                  0091
@DE00016 L     @09,STRINGS(,PARMPTR)                               0091
         CH    STRINGPT,PARMLENG(,@09)                             0091
         BL    @DL00016                                            0091
*        /* THIS LOOP WILL CONTINUE UNTIL THE ENTIRE STRING PASSED  */
*        /* TO THIS MODULE BY THE SCHEDULER HAS BEEN PROCESSED      */
*                                                                  0092
*        /* IF A JFCB EXTENSION HAS BEEN GOTTEN, THE JFCB TTR OFSET */
*        /* FOR THE TTR POINTER TO THE EXTENSION MUST BE SET IN LIST*/
*        IF OVERPTR ^= 0 THEN               /* IS THERE A EXTENSION */
         L     @09,OVERPTR(,PARMPTR)                               0092
         LTR   @09,@09                                             0092
         BZ    @RF00092                                            0092
*          JFCBOFST = ADDR(JFCAMPTR) - ADDR(INFMJFCB); /* JFCB FOR  */
         MVC   JFCBOFST(2,PARMPTR),@CH00737                        0093
*                                           /* TTR PTR TO EXTENSION */
*                                                                  0094
*        /* THE CORE GOTTEN DURING INITIALIZATION MUST BE FREED     */
*        LENGST = LENGTH(DATAREA);          /* GET LENGTH OF CORE   */
@RF00092 LA    LENGST,83                                           0094
*        WORKREG = RETCODE;                 /* SAVE IEFVAMP RET CODE*/
         L     WORKREG,RETCODE(,DATAPTR)                           0095
*        ENTRYPTR = SUBPONL;                /* GET SUBPOOL NUMBER   */
         SLR   ENTRYPTR,ENTRYPTR                                   0096
         IC    ENTRYPTR,SUBPONL(,PARMPTR)                          0096
*        GEN(FREEMAIN  R,LV=(LENGST),A=(DATAPTR),SP=(ENTRYPTR));   0097
         FREEMAIN  R,LV=(LENGST),A=(DATAPTR),SP=(ENTRYPTR)
*        REG15 = WORKREG;                   /* PUT RET CODE IN 15   */
         LR    REG15,WORKREG                                       0098
*                                           /* IF AN ERROR IS FOUND */
*                                           /* THE RETURN CODE IS 4 */
*                                           /* FOR NO ERROR IT IS 0 */
*                                                                  0099
*      END;                                 /* END IF INITIAL OK    */
*    ELSE;                                  /* NOTHING IF INIT   BAD*/
@RF00014 DS    0H                                                  0101
*    REG1 = PARMPTR;                        /* POINT TO PARM LIST   */
         LR    REG1,PARMPTR                                        0101
*    RETURN CODE(REG15);                     /* EXIT FROM IEFVAMP    */
         L     @14,12(,@13)                                        0102
         LM    @00,@12,20(@13)                                     0102
         BR    @14                                                 0102
*        GEN(EJECT);                                               0103
*                                                                  0103
*                                                                  0103
         EJECT
*ADDJFCB:         /* THE ADDJFCB INTERNAL PROCEDURE                 */
*PROC   OPTIONS(NOSAVEAREA,DONTSAVE,RETREG);                       0104
*                                                                  0104
         B     @PB00002                                            0104
ADDJFCB  DS    0H                                                  0105
*        /* THE ADDJFCB INTERNAL PROCEDURE IS CALLED TO PUT THE     */
*        /* ADDRESS OF AN AVAILABLE JFCB EXTENSION INTO JFCBREG     */
*        /* WHEN A JFCB EXTENSION IS TO BE UPDATED. IF NO JFCB      */
*        /* EXTENSION IS AVAILABLE, A GETMAIN IS ISSUED TO OBTAIN   */
*        /* A NEW ONE.                                              */
*                                                                  0105
*        JFCBREG = ADDR(OVERPTR);           /* GET FIRST EXTENSION  */
         LA    JFCBREG,OVERPTR(,PARMPTR)                           0105
*        DO WHILE OVERFULL = '1'B   &       /* FIND LAST EXTENSION  */
*                 JFCBCHAN ^= 0;            /* STOP AT LAST EXT     */
         B     @DE00106                                            0106
@DL00106 DS    0H                                                  0107
*          JFCBREG = JFCBCHAN;              /* GET NEXT EXTENSION   */
         L     JFCBREG,JFCBCHAN(,JFCBREG)                          0107
*        END;                               /* END OF FIND LAST     */
*                                                                  0108
@DE00106 TM    OVERFULL(JFCBREG),B'10000000'                       0108
         BNO   @DC00106                                            0108
         L     @09,JFCBCHAN(,JFCBREG)                              0108
         LTR   @09,@09                                             0108
         BNZ   @DL00106                                            0108
@DC00106 DS    0H                                                  0109
*        IF OVERFULL = '1'B   THEN          /* IS LAST ALSO FULL    */
         TM    OVERFULL(JFCBREG),B'10000000'                       0109
         BNO   @RF00109                                            0109
*          DO;                              /* GET NEW IF FULL      */
*            REG1 = ADDR(GETLIST);          /* POINT TO GETMAIN LIST*/
         LA    REG1,GETLIST(,DATAPTR)                              0111
*            WORKREG = ADDR(JFCBCHAN);      /* RESULT IN EXT CHAIN  */
         LR    WORKREG,JFCBREG                                     0112
*            GEN(GETMAIN A=(WORKREG),MF=(E,(1)),LV=180); /* GET EXT */
         GETMAIN A=(WORKREG),MF=(E,(1)),LV=180
*            IF REG15 = 0 THEN              /* IF GETMAIN SUCCESSFUL*/
         SLR   @14,@14                                             0114
         CR    REG15,@14                                           0114
         BNE   @RF00114                                            0114
*              DO;                          /* POINT TO NEW EXTENSN */
*                JFCBREG = JFCBCHAN;        /* GET NEW GOTTEN EXT   */
         L     JFCBREG,JFCBCHAN(,JFCBREG)                          0116
*                JFCBCHAN = 0;              /* INDICATE THIS IS LAST*/
         ST    @14,JFCBCHAN(,JFCBREG)                              0117
*                OVERFULL = '0'B;           /* INDICATE EMPTY       */
         NI    OVERFULL(JFCBREG),B'01111111'                       0118
*              END;                         /* END SUCCESSFUL GET   */
*            ELSE RETCODE = 4;              /* NO CORE FOR NEW EXT  */
         B     @RC00114                                            0120
@RF00114 MVC   RETCODE(4,DATAPTR),@CF00083                         0120
*          END;                             /* END OF LAST WAS FULL */
*                                                                  0121
*        ELSE;                              /* LAST WAS NOT FULL, NO*/
@RF00109 DS    0H                                                  0123
*                                           /* GETMAIN NECESSARY    */
*        END   ADDJFCB;                     /* END OF THE PROCEDURE */
@EL00002 DS    0H                                                  0123
@EF00002 DS    0H                                                  0123
@ER00002 BR    @14                                                 0123
@PB00002 DS    0H                                                  0124
*                                           /* JFCBREG POINTS TO A  */
*                                           /* AVAILABLE EXTENSION  */
*                                                                  0124
*        GEN(EJECT);                                               0124
         EJECT
*ERROR:           /* THE ERROR MESSAGE INTERNAL PROCEDURE           */
*PROC   OPTIONS(NOSAVEAREA,DONTSAVE,RETREG);                       0125
*                                                                  0125
         B     @PB00003                                            0125
ERROR    DS    0H                                                  0126
*        /* THE ERROR PROCEDURE IS CALLED WHENEVER AN ERROR IS      */
*        /* DISCOVERED. IT DOES A GETMAIN FOR 88 BYTES AND BUILDS   */
*        /* AN ERROR MESSAGE IN THE GOTTEN CORE. RETURN IS THEN     */
*        /* PASSED TO THE CALLER                                    */
*        /* THIS ROUTINE MAY CALL GETWORD AS AN INTERNAL PROCEDURE  */
*                                                                  0126
*        LINKSAV3 = REG14;                  /* SAVE THE RETURN REG  */
         ST    REG14,LINKSAV3(,DATAPTR)                            0126
*        REG1 = ADDR(GETLIST);              /* POINT TO GETMAIN LIST*/
         LA    REG1,GETLIST(,DATAPTR)                              0127
*        LENGST = LENGTH(MESSAGE);          /* GET LENGTH OF MSG    */
         LA    LENGST,88                                           0128
*        WORKREG = ADDR(RETURNS);           /* POINT TO RETURN AREA */
         LA    WORKREG,RETURNS(,DATAPTR)                           0129
*        GEN(GETMAIN A=(WORKREG),MF=(E,(1)),LV=(LENGST)); /* GET MSG*/
*                                                                  0130
         GETMAIN A=(WORKREG),MF=(E,(1)),LV=(LENGST)
*        /* THE SYSTEM RETURNS A POINTER TO 88 BYTES OF CORE IN     */
*        /* RETURNS IF THE GETMAIN WAS SUCCESSFUL, OTHERWISE        */
*        /* REGISTER 15 CONTAINS A NON ZERO VALUE                   */
*                                                                  0131
*        IF REG15 = 0 THEN                  /* CHECK IF SUCCESSFUL  */
         LTR   REG15,REG15                                         0131
         BNZ   @RF00131                                            0131
*          DO;                              /* BUILD MSG IF OK      */
*            WORKREG = ADDR(JFCBPTR);       /* GET FIRST MSG FROM   */
         LA    WORKREG,JFCBPTR(,PARMPTR)                           0133
*                                           /* PARAMETER LIST       */
*            DO WHILE MSGCHAIN ^= 0;        /* FIND LAST ENTRY      */
         B     @DE00134                                            0134
@DL00134 DS    0H                                                  0135
*              WORKREG = MSGCHAIN;          /* CONTINUE DOWN CHAIN  */
         L     WORKREG,MSGCHAIN(,WORKREG)                          0135
*            END;                           /* REMAIN IN DO WHILE   */
@DE00134 SLR   @09,@09                                             0136
         C     @09,MSGCHAIN(,WORKREG)                              0136
         BNE   @DL00134                                            0136
*                                           /* LOOP UNTIL END       */
*            MSGCHAIN = RETURNS;            /* CHAIN NEW BUFFER TO  */
         L     @15,RETURNS(,DATAPTR)                               0137
         ST    @15,MSGCHAIN(,WORKREG)                              0137
*                                           /* PREVIOUS CHAIN       */
*            WORKREG = MSGCHAIN;            /* POINT TO NEW BUFFER  */
         LR    WORKREG,@15                                         0138
*            MSGCHAIN = 0;                  /* MAKE THIS BUFFER LAST*/
         ST    @09,MSGCHAIN(,WORKREG)                              0139
*            MSGLEN = LENGTH(MESSAGE);      /* PUT LENGTH IN MSG BUF*/
         MVC   MSGLEN(2,WORKREG),@CH00737                          0140
*            MSGZERO = 0;                   /* RESERVED FIELD ZERO  */
*                                                                  0141
         STH   @09,MSGZERO(,WORKREG)                               0141
*        /* CHECK FOR THE ERROR TYPE AND GET THE APPROPRIATE        */
*        /* SKELETON FOR THE MESSAGE                                */
*            MSGPREF = MSGP1;               /* GET IEFXXXI PREFIX   */
         MVC   MSGPREF(21,WORKREG),MSGP1                           0142
*            MSGNOTE = MSGP9;               /* GET STEP NOT EXECUTED*/
*                                                                  0143
         MVC   MSGNOTE(19,WORKREG),MSGP9                           0143
*            IF MSGCODE = 1 THEN            /* INVALID KEYWORD MSG  */
         CLC   MSGCODE(4,DATAPTR),@CF00045                         0144
         BNE   @RF00144                                            0144
*              DO;                          /* SETUP THE MSG        */
*                MSGWORD = KEYBUFER;        /* GET THE KEYWORD      */
         MVC   MSGWORD(9,WORKREG),KEYBUFER(DATAPTR)                0146
*                MSGNBR  = MSGNBR1;         /* GET THE MSG NUMBER   */
         MVC   MSGNBR(7,WORKREG),MSGNBR1                           0147
*                MSGMDLE = MSGMDL1;         /* GET INVALID MSG      */
         MVC   MSGMDLE(31,WORKREG),MSGMDL1                         0148
*              END;                         /* END OF THE INVALID   */
*                                           /* KEYWORD MSG PROCESS  */
*            ELSE                                                  0150
*              IF MSGCODE = 2 THEN          /* TOO LARGE VALUE MSG  */
         B     @RC00144                                            0150
@RF00144 CLC   MSGCODE(4,DATAPTR),@CF00104                         0150
         BNE   @RF00150                                            0150
*                DO;                        /* SETUP THE MSG        */
*                  MSGWORD = KEYWORD;       /* GET THE KEYWORD      */
         MVC   MSGWORD(9,WORKREG),KEYWORD(ENTRYPTR)                0152
*                  MSGNBR  = MSGNBR2;       /* GET THE MSG NUMBER   */
         MVC   MSGNBR(7,WORKREG),MSGNBR2                           0153
*                  MSGMDLE = MSGMDL2;       /* GET VALUE ERROR MSG  */
         MVC   MSGMDLE(31,WORKREG),MSGMDL2                         0154
*                  MSGVAL = KEYBUFER;       /* GET THE KEYWORD      */
         MVC   MSGVAL(9,WORKREG),KEYBUFER(DATAPTR)                 0155
*                END;                       /* END OF THE INVALID   */
*                                           /* KEYWORD MSG PROCESS  */
*              ELSE                                                0157
*                IF MSGCODE = 3 THEN        /* INVALID VALUE MSG    */
         B     @RC00150                                            0157
@RF00150 CLC   MSGCODE(4,DATAPTR),@CF00109                         0157
         BNE   @RF00157                                            0157
*                  DO;                      /* SETUP THE MSG        */
*                    MSGWORD = KEYWORD;     /* GET THE KEYWORD      */
         MVC   MSGWORD(9,WORKREG),KEYWORD(ENTRYPTR)                0159
*                    MSGNBR  = MSGNBR3;     /* GET THE MSG NUMBER   */
         MVC   MSGNBR(7,WORKREG),MSGNBR3                           0160
*                    MSGMDLE = MSGMDL3;     /* GET DECIMAL ERROR MSG*/
         MVC   MSGMDLE(31,WORKREG),MSGMDL3                         0161
*                  END;                     /* END OF THE INVALID   */
*                                           /* KEYWORD MSG PROCESS  */
*                ELSE                                              0163
*                  IF MSGCODE = 4 THEN      /* IF DUPLICATE MESSAGE */
         B     @RC00157                                            0163
@RF00157 CLC   MSGCODE(4,DATAPTR),@CF00083                         0163
         BNE   @RF00163                                            0163
*                    DO;                    /* BUILD THE DUP MSG    */
*                      MSGWORD = KEYWORD;   /* GET KEYWORD IN ERROR */
         MVC   MSGWORD(9,WORKREG),KEYWORD(ENTRYPTR)                0165
*                      MSGNBR = MSGNBR4;    /* PUT MSG NUMBER IN    */
         MVC   MSGNBR(7,WORKREG),MSGNBR4                           0166
*                      MSGMDLE = MSGMDL4;   /* GET TEXT OF MESSAGE  */
         MVC   MSGMDLE(31,WORKREG),MSGMDL4                         0167
*                    END;                   /* END DUP OR CONFLICT  */
*                  ELSE;                    /* MSG 5 NOT YET DEFINED*/
@RF00163 DS    0H                                                  0170
*          END;                             /* END OF MSG PROCESSING*/
*                                                                  0170
*        ELSE;                                                     0171
*                                                                  0171
@RF00131 DS    0H                                                  0172
*        /* THE ERROR KEYWORD AND PARAMETERS MUST BE FLUSHED        */
*        TEMPSAVE = PARENCNT;               /* SAVE START ( COUNT   */
@RC00131 L     @09,PARENCNT(,DATAPTR)                              0172
         ST    @09,TEMPSAVE(,DATAPTR)                              0172
*        DO WHILE STRING(STRINGPT-1) ^= ',' & /* SCAN FOR A ,       */
*                 STRINGPT < PARMLENG;      /* DO NOT EXCEED STRING */
         B     @DE00173                                            0173
@DL00173 DS    0H                                                  0174
*          CALL GETWORD;                    /* SCAN FOR A WORD      */
         BAL   @14,GETWORD                                         0174
*        END;                               /* END WHEN , FOUND     */
*                                                                  0175
@DE00173 L     @09,STRINGS(,PARMPTR)                               0175
         LR    @01,@09                                             0175
         ALR   @01,STRINGPT                                        0175
         CLI   STRING-2(@01),C','                                  0175
         BE    @DC00173                                            0175
         CH    STRINGPT,PARMLENG(,@09)                             0175
         BL    @DL00173                                            0175
@DC00173 DS    0H                                                  0176
*        DO WHILE PARENCNT > TEMPSAVE &     /* FIND TERMINATING )   */
*                 STRINGPT < PARMLENG;      /* DO NOT EXCEED STRING */
         B     @DE00176                                            0176
@DL00176 DS    0H                                                  0177
*          CALL GETWORD;                    /* SCAN FOR A WORD      */
         BAL   @14,GETWORD                                         0177
*        END;                               /* THE ERROR HAS BEEN   */
@DE00176 L     @09,PARENCNT(,DATAPTR)                              0178
         C     @09,TEMPSAVE(,DATAPTR)                              0178
         BNH   @DC00176                                            0178
         L     @09,STRINGS(,PARMPTR)                               0178
         CH    STRINGPT,PARMLENG(,@09)                             0178
         BL    @DL00176                                            0178
@DC00176 DS    0H                                                  0179
*                                           /* FLUSHED FROM STRING  */
*        RETCODE = 4;                       /* INDICATE THAT A ERROR*/
         MVC   RETCODE(4,DATAPTR),@CF00083                         0179
*                                           /* HAS OCCURED IN THE   */
*                                           /* AMP JCL PROCESSING   */
*                                                                  0180
*        REG14 = LINKSAV3;                  /* RESTORE RETURN REG   */
         L     REG14,LINKSAV3(,DATAPTR)                            0180
*        END ERROR;                         /* END OF THIS INTERNAL */
@EL00003 DS    0H                                                  0181
@EF00003 DS    0H                                                  0181
@ER00003 BR    @14                                                 0181
@PB00003 DS    0H                                                  0182
*                                           /* PROCEDURE            */
*        GEN(EJECT);                                               0182
*                                                                  0182
         EJECT
*FINDKEY:         /* THE FINDKEY INTERNAL PROCEDURE                 */
*PROC    OPTIONS(NOSAVEAREA,DONTSAVE,RETREG);                      0183
*                                                                  0183
         B     @PB00004                                            0183
FINDKEY  DS    0H                                                  0184
*        /* THE FINDKEY PROCEDURE IS CALLED TO SEARCH THE INTERNAL  */
*        /* KEYWORD TABLES FOR A KEYWORD ENTRY CORESPONDING TO THE  */
*        /* WORD PASSED IN THE KEYBUFFER                            */
*                                                                  0184
*        FINDERR = '0'B;                    /*  RESET FINDKEY ERROR */
         NI    FINDERR(DATAPTR),B'01111111'                        0184
*        DO WHILE KEYBUFER ^= KEYWORD &     /* SCAN TABLE FOR WORD  */
*                 FLAGS1 ^= 'FF'X;          /* STOP AT END OF TABLE */
         B     @DE00185                                            0185
@DL00185 DS    0H                                                  0186
*          ENTRYPTR = ENTRYPTR + LENGTH(TENTRY);                   0186
         AL    ENTRYPTR,@CF00210                                   0186
*                                           /* THIS ROUTINE         */
*                                           /* INCREMENTS THROUGH   */
*                                           /* A TABLE UNTIL A MATCH*/
*                                           /* IS FOUND OR THE END  */
*                                           /* OF THE TABLE IS      */
*                                           /* REACHED              */
*        END;                               /* END OF THE SCAN LOOP */
*                                                                  0187
@DE00185 CLC   KEYBUFER(9,DATAPTR),KEYWORD(ENTRYPTR)               0187
         BE    @DC00185                                            0187
         CLI   FLAGS1(ENTRYPTR),X'FF'                              0187
         BNE   @DL00185                                            0187
@DC00185 DS    0H                                                  0188
*        IF FLAGS1 = 'FF'X THEN             /* CHECK IF NOT FOUND   */
         CLI   FLAGS1(ENTRYPTR),X'FF'                              0188
         BNE   @RF00188                                            0188
*          DO;                              /* SET MSG CODE AND ERRO*/
*            FINDERR = '1'B;                /* SET ERROR ON FIND    */
         OI    FINDERR(DATAPTR),B'10000000'                        0190
*            MSGCODE = 1;                   /* SET INVALID KEYWORD  */
         MVC   MSGCODE(4,DATAPTR),@CF00045                         0191
*          END;                             /* END IF NOT FOUND     */
*                                                                  0192
*        ELSE                               /* A KEYWORD WAS FOUND  */
*          DO;                              /* CHECK FOR CONFLICTS  */
         B     @RC00188                                            0193
@RF00188 DS    0H                                                  0194
*            TEMPFLD = DUPBITS & CONFLICT;  /* CHECK FOR DUP BITS   */
         MVC   TEMPFLD(4,DATAPTR),DUPBITS(DATAPTR)                 0194
         NC    TEMPFLD(4,DATAPTR),CONFLICT(ENTRYPTR)               0194
*            IF TEMPFLD = '00000000'X THEN  /* NO ERROR OR CONFLICT */
         CLC   TEMPFLD(4,DATAPTR),@CB00127                         0195
         BNE   @RF00195                                            0195
*              DO;                          /* NO CONFLICTS FOUND   */
*                TEMPFLD2 = COMPAT & DSORGS; /* COMPARE COMPAT DSORG*/
         MVC   TEMPFLD2(1,DATAPTR),COMPAT(DATAPTR)                 0197
         NC    TEMPFLD2(1,DATAPTR),DSORGS(ENTRYPTR)                0197
*                IF TEMPFLD2 ^= 0 THEN      /* ANY POSSIBLE DSORGS  */
         CLI   TEMPFLD2(DATAPTR),0                                 0198
         BE    @RF00198                                            0198
*                  DO;                      /* PROCEED IF POSSIBLE  */
*                    COMPAT = TEMPFLD2;     /* GET NEW COMPATIBLE   */
         MVC   COMPAT(1,DATAPTR),TEMPFLD2(DATAPTR)                 0200
*                    DUPBITS = DUPBITS × CONFLICT; /* OR NEW DUP BIT*/
         OC    DUPBITS(4,DATAPTR),CONFLICT(ENTRYPTR)               0201
*                  END;                     /* END IF STILL COMPATBL*/
*                ELSE                       /* NO POSSIBLE COMPATIBL*/
*                  DO;                      /* INDICATE ERROR       */
         B     @RC00198                                            0203
@RF00198 DS    0H                                                  0204
*                    MSGCODE = 4;           /* CONFLICT MSG  @Y30LSPS*/
         MVC   MSGCODE(4,DATAPTR),@CF00083                         0204
*                    FINDERR = '1'B;        /* ERROR ON FIND KEY    */
         OI    FINDERR(DATAPTR),B'10000000'                        0205
*                  END;                     /* END IF NO COMPATIBLE */
*              END;                         /* END IF NO CONFLICTS  */
*                                                                  0207
*            ELSE                           /* A CONFLICT WAS FOUND */
*              DO;                          /* SETUP FOR CONFLICT ER*/
         B     @RC00195                                            0208
@RF00195 DS    0H                                                  0209
*                MSGCODE = 4;               /* DUP OR CONFLICT MSG  */
         MVC   MSGCODE(4,DATAPTR),@CF00083                         0209
*                FINDERR = '1'B;            /* ERROR ON FIND KEY    */
         OI    FINDERR(DATAPTR),B'10000000'                        0210
*              END;                         /* END IF DUP OR CONFLIC*/
*          END;                             /* END CHECK FOR CONFLCT*/
*        END FINDKEY;                       /* END OF THIS INTERNAL */
@EL00004 DS    0H                                                  0213
@EF00004 DS    0H                                                  0213
@ER00004 BR    @14                                                 0213
@PB00004 DS    0H                                                  0214
*                                           /* PROCEDURE     @Y30LSPS*/
*        GEN(EJECT);                                               0214
*                                                                  0214
         EJECT
*GETWORD:         /* THE GETWORD FROM THE STRING INTERNAL PROCEDURE */
*PROC    OPTIONS(NOSAVEAREA,DONTSAVE,RETREG);                      0215
*                                                                  0215
         B     @PB00005                                            0215
GETWORD  DS    0H                                                  0216
*        /* THE GETWORD PROCEDURE IS CALLED TO PUT THE NEXT WORD IN */
*        /* CHARACTER STRING PASSED TO IEFVAMP UPON ENTRY INTO THE  */
*        /* KEYBUFFER. THIS ROUTINE ALSO KEEPS TRACK OF PARENTHESES */
*                                                                  0216
*        LINKSAV4 = REG14;                  /* SAVE THE RETURN REG  */
         ST    REG14,LINKSAV4(,DATAPTR)                            0216
*        LENGST = 1;                        /* INITIALIZE TO FIRST  */
         LA    LENGST,1                                            0217
*        MSGCODE = 0;                       /* CLEAR ERROR CODE     */
         SLR   @09,@09                                             0218
         ST    @09,MSGCODE(,DATAPTR)                               0218
*        KEYBUFER = ' ';                    /* CLEAR THE KEYWORD BUF*/
         MVI   KEYBUFER+1(DATAPTR),C' '                            0219
         MVC   KEYBUFER+2(7,DATAPTR),KEYBUFER+1(DATAPTR)           0219
         MVI   KEYBUFER(DATAPTR),C' '                              0219
*        /* LEADING PARENTHESES MUST BE REMOVED AND A COUNT KEPT    */
*        DO WHILE STRING(STRINGPT) = '(';   /* SCAN AND COUNT 9     */
         B     @DE00220                                            0220
@DL00220 DS    0H                                                  0221
*          STRINGPT = STRINGPT + 1;         /* INCR STRING POINTER  */
         LA    @09,1                                               0221
         ALR   STRINGPT,@09                                        0221
*          PARENCNT = PARENCNT + 1;         /* INCR PARENTH COUNT   */
         AL    @09,PARENCNT(,DATAPTR)                              0222
         ST    @09,PARENCNT(,DATAPTR)                              0222
*        END;                               /* END OF LEADING       */
@DE00220 L     @09,STRINGS(,PARMPTR)                               0223
         ALR   @09,STRINGPT                                        0223
         CLI   STRING-1(@09),C'('                                  0223
         BE    @DL00220                                            0223
*                                           /* PARENTHESES REMOVAL  */
*                                                                  0224
*        /* CHARACTERS ARE PLACED IN THE KEYBUFFER UNTIL A          */
*        /* TERMINATING CHARACTER IS DISCOVERED OR UNTIL THE BUFFER */
*        /* IS FULL                                                 */
*        DO WHILE STRINGPT^> PARMLENG &     /* END OF STRING @ZA11651*/
*                 STRING(STRINGPT) ^= ',' & /* A COMA IS A TERMINATE*/
*                 STRING(STRINGPT) ^= ')' & /* A PAREN TERMINATES   */
*                 STRING(STRINGPT) ^= '(' & /* SAME AS ABOVE        */
*                 STRING(STRINGPT) ^= '=';  /* = IS A LAST CHARACTER*/
*                                                                  0224
         B     @DE00224                                            0224
@DL00224 DS    0H                                                  0225
*          KEYBUF(LENGST) = STRING(STRINGPT); /* MOVE VALID CHARACTR*/
         LR    @09,DATAPTR                                         0225
         ALR   @09,LENGST                                          0225
         L     @01,STRINGS(,PARMPTR)                               0225
         ALR   @01,STRINGPT                                        0225
         MVC   KEYBUF-1(1,@09),STRING-1(@01)                       0225
*          STRINGPT = STRINGPT + 1;         /* INCR STRING POINTER  */
         LA    @09,1                                               0226
         ALR   STRINGPT,@09                                        0226
*          LENGST = LENGST + 1;             /* INCR BUFFER INDEX    */
         ALR   LENGST,@09                                          0227
*          IF LENGST > LENGTH(KEYBUFER) THEN /* CHECK FOR FULL BUFER*/
         LA    @15,9                                               0228
         CR    LENGST,@15                                          0228
         BNH   @RF00228                                            0228
*            DO;                            /* ERROR MSG IF TOO LONG*/
*              MSGCODE = 1;                 /* KEYWORD TOO LONG MSG */
         ST    @09,MSGCODE(,DATAPTR)                               0230
*              LENGST = LENGTH(KEYBUFER);   /* REUSE LAST CHAR CONT */
         LR    LENGST,@15                                          0231
*            END;                           /* END OF TOO LONG WORD */
*                                                                  0232
*          ELSE;                                                   0233
@RF00228 DS    0H                                                  0234
*        END;                               /* END OF STRING SCAN   */
@DE00224 L     @09,STRINGS(,PARMPTR)                               0234
         CH    STRINGPT,PARMLENG(,@09)                             0234
         BH    @DC00224                                            0234
         LR    @01,@09                                             0234
         ALR   @01,STRINGPT                                        0234
         CLI   STRING-1(@01),C','                                  0234
         BE    @DC00224                                            0234
         LR    @01,@09                                             0234
         ALR   @01,STRINGPT                                        0234
         CLI   STRING-1(@01),C')'                                  0234
         BE    @DC00224                                            0234
         LR    @01,@09                                             0234
         ALR   @01,STRINGPT                                        0234
         CLI   STRING-1(@01),C'('                                  0234
         BE    @DC00224                                            0234
         ALR   @09,STRINGPT                                        0234
         CLI   STRING-1(@09),C'='                                  0234
         BNE   @DL00224                                            0234
@DC00224 DS    0H                                                  0235
*        IF STRINGPT ^> PARMLENG &          /* END OF PARMS @ZA11651*/
*           STRING(STRINGPT) = '=' THEN     /* STOP ON = FOR KEYWORD*/
         L     @09,STRINGS(,PARMPTR)                               0235
         CH    STRINGPT,PARMLENG(,@09)                             0235
         BH    @RF00235                                            0235
         ALR   @09,STRINGPT                                        0235
         CLI   STRING-1(@09),C'='                                  0235
         BNE   @RF00235                                            0235
*          DO;                              /* = IS PART OF THIS WRD*/
*            KEYBUF(LENGST) = '=';          /* PUT == IN BUFFER     */
         LR    @09,DATAPTR                                         0237
         ALR   @09,LENGST                                          0237
         MVI   KEYBUF-1(@09),C'='                                  0237
*            LENGST = LENGST + 1;           /* THIS IS PART OF LENG */
         AL    LENGST,@CF00045                                     0238
*          END;                             /* END KEYWORD= PROCESS */
*        ELSE;                                                     0240
@RF00235 DS    0H                                                  0241
*        DO WHILE STRINGPT ^> PARMLENG &    /* END OF STRING @ZA11651*/
*                 STRING(STRINGPT) = ')';   /* SCAN AND COUNT TRAILING
*                                              PARENTHESES.  @ZA11651*/
         B     @DE00241                                            0241
@DL00241 DS    0H                                                  0242
*          STRINGPT = STRINGPT + 1;         /* INCR STRING POINTER  */
         AL    STRINGPT,@CF00045                                   0242
*          PARENCNT = PARENCNT - 1;         /* DECREMENT ) COUNT    */
         L     @09,PARENCNT(,DATAPTR)                              0243
         BCTR  @09,0                                               0243
         ST    @09,PARENCNT(,DATAPTR)                              0243
*        END;                               /* END OF TRAILING )    */
*                                                                  0244
@DE00241 L     @09,STRINGS(,PARMPTR)                               0244
         CH    STRINGPT,PARMLENG(,@09)                             0244
         BH    @DC00241                                            0244
         ALR   @09,STRINGPT                                        0244
         CLI   STRING-1(@09),C')'                                  0244
         BE    @DL00241                                            0244
@DC00241 DS    0H                                                  0245
*        STRINGPT = STRINGPT + 1;       /* INCR PAST WORD IN STRING */
         LA    @09,1                                               0245
         ALR   STRINGPT,@09                                        0245
*        /* IF AN ERROR OCCURED, THE LENGTH IS SET TO ZERO, IF NOT  */
*        /* THEN THE LENGTH IS  SET TO THE KEYWORD LENGTH           */
*        IF MSGCODE = 1 THEN                /* CHECK IF ERROR OCCUR */
         C     @09,MSGCODE(,DATAPTR)                               0246
         BNE   @RF00246                                            0246
*          LENGST = 0;                      /* ZERO LENGTH IF ERROR */
         SLR   LENGST,LENGST                                       0247
*        ELSE LENGST = LENGST - 1;          /* INDEX = LENGTH + 1   */
*                                                                  0248
         B     @RC00246                                            0248
@RF00246 BCTR  LENGST,0                                            0248
*        REG14 = LINKSAV4;                  /* RESTORE RETURN REG   */
@RC00246 L     REG14,LINKSAV4(,DATAPTR)                            0249
*        END GETWORD;                       /* THE END OF THE       */
@EL00005 DS    0H                                                  0250
@EF00005 DS    0H                                                  0250
@ER00005 BR    @14                                                 0250
@PB00005 DS    0H                                                  0251
*                                           /* GETWORD INTERNAL     */
*                                           /* PROCEDURE            */
*        GEN(EJECT);                                               0251
         EJECT
*INITIALZ:       /* THE INITIALIZATION INTERNAL PROCEDURE           */
*PROC   OPTIONS(NOSAVEAREA,DONTSAVE,RETREG);                       0252
*                                                                  0252
         B     @PB00006                                            0252
INITIALZ DS    0H                                                  0253
*        /* THIS PROCEDURE DOES A GETMAIN FOR A DATA AREA AND       */
*        /* INITIALIZES THIS AREA AND ANY REGISTERS NEEDING INITIAL */
*                                                                  0253
*        PARMPTR = LISTPTR;                 /* GET PTR TO LIST      */
         L     PARMPTR,LISTPTR(,REG1)                              0253
*        TEMPLIST = GETMAIN2;               /* COND GETMAIN IN PARM */
         LA    @09,GETDATA                                         0254
         MVC   TEMPLIST(12,PARMPTR),GETMAIN2(@09)                  0254
*                                           /* LIST LAST 3 WORDS    */
*        LENGST = LENGTH(DATAREA);          /* GET LENGTH OF CORE   */
         LA    LENGST,83                                           0255
*        REG1 = ADDR(TEMPLIST);             /* POINT TO TEMP LIST   */
         LA    REG1,TEMPLIST(,PARMPTR)                             0256
*        WORKREG = SUBPONL;                 /* GET SUBPOOL NUMBER   */
         SLR   WORKREG,WORKREG                                     0257
         IC    WORKREG,SUBPONL(,PARMPTR)                           0257
*                     RESPECIFY (REG15,REG14) RESTRICTED ;         0258
*                                                                  0258
*        GEN(GETMAIN A=(13),MF=(E,(1)),LV=(LENGST),SP=(WORKREG));  0259
         GETMAIN A=(13),MF=(E,(1)),LV=(LENGST),SP=(WORKREG)
*        IF REG15 = 0 THEN                  /* CHECK IF GETCORE GOOD*/
         LTR   REG15,REG15                                         0260
         BNZ   @RF00260                                            0260
*          DO;                              /* INITIALIZE IF GOOD   */
*                                                                  0261
*        /* THE ADDRESS OF THE GOTTEN CORE IS RETURNED IN THE FIRST */
*        /* WORD OF THE SAVE AREA POINTED TO BY REG 13              */
*            DATAPTR = RETURNED;            /* GET THE GOTTEN CORE  */
         L     DATAPTR,RETURNED(,REG13)                            0262
*            DATAREA = DATAREA && DATAREA;  /* CLEAR GOTTEN CORE    */
         XC    DATAREA(83,DATAPTR),DATAREA(DATAPTR)                0263
*            GETLIST = TEMPLIST;            /* PUT GETMAIN LIST IN  */
         MVC   GETLIST(12,DATAPTR),TEMPLIST(PARMPTR)               0264
*                                           /* WORD AREA FOR MSG C  */
*            ZEROINIT = ZEROINIT && ZEROINIT; /* INIT ZERO AREAS    */
         XC    ZEROINIT(12,DATAPTR),ZEROINIT(DATAPTR)              0265
*            STRINGPT = 1;                  /* POINT TO START OF DAT*/
         LA    STRINGPT,1                                          0266
*          END;                             /* END SUCCESSFUL INIT  */
*        ELSE;                              /* NO INITIALIZATION ERR*/
@RF00260 DS    0H                                                  0269
*        TEMPLIST = TEMPLIST && TEMPLIST;   /* CLEAR TEMP LIST AREA */
         XC    TEMPLIST(12,PARMPTR),TEMPLIST(PARMPTR)              0269
*        COMPAT = 'FF'X;                    /* SETUP AS ALL COMPATBL*/
         MVI   COMPAT(DATAPTR),X'FF'                               0270
*        JFCORGAM = '1'B;                   /* INDICATE AMO ORGANIZ */
         L     @09,JFCBPTR(,PARMPTR)                               0271
         OI    JFCORGAM(@09),B'00001000'                           0271
*                     RESPECIFY (REG15,REG14) UNRESTRICTED;        0272
*        END INITIALZ;                      /* END OF THE IEFVAMP   */
@EL00006 DS    0H                                                  0273
@EF00006 DS    0H                                                  0273
@ER00006 BR    @14                                                 0273
@PB00006 DS    0H                                                  0274
*                                           /* INITIALIZATION PROC  */
*        GEN(EJECT);                                               0274
*                                                                  0274
         EJECT
*POSITINL:         /* THE POSITIONAL PARAMETER INTERNAL PROCEDURE   */
*PROC    OPTIONS(NOSAVEAREA,DONTSAVE,RETREG);                      0275
*                                                                  0275
         B     @PB00007                                            0275
POSITINL DS    0H                                                  0276
*        /* THE POSITINL PROCEDURE PROCESSES KEYWORDS THAT CONTAIN  */
*        /* POSITIONAL PARAMETERS. IT MAY CALL  GETWORD, FINDKEY   */
*        /* VALUE AND ERROR AS INTERNAL PROCEDURES. UPON EXIT FROM  */
*        /* THIS PROCEDURE, THE JFCB HAS BEEN UPDATED BY THE KEYWORD*/
*        /* INFORMATION                                             */
*                                                                  0276
*        LINKSAV2 = REG14;                  /* SAVE RETURN REG      */
         ST    REG14,LINKSAV2(,DATAPTR)                            0276
*        NUMBER = 1;                        /* INIT TO FIRST POSITN */
         LA    @09,1                                               0277
         ST    @09,NUMBER(,DATAPTR)                                0277
*        PARENCNT = 1;                      /* INIT TO 1 FOR THE DO */
         ST    @09,PARENCNT(,DATAPTR)                              0278
*                                           /* WHILE LOOP. REMOVE IF*/
*                                           /* DO UNTIL POSSIBLE    */
*        ENTRYPTR = ENTCHAIN;               /* GET TABLE OF PARMS   */
*                                                                  0279
         L     ENTRYPTR,ENTCHAIN(,ENTRYPTR)                        0279
*        DO WHILE NUMBER ^> MAXPOS &        /* DO NOT EXCEED NUMBER */
*                 PARENCNT ^= 0;            /* STOP IF LAST ) REACH */
         B     @DE00280                                            0280
@DL00280 DS    0H                                                  0281
*          CALL GETWORD;                    /* GET A PARAMETER      */
         BAL   @14,GETWORD                                         0281
*          IF NUMBER = 1 THEN               /* DECR PARENCNT IF FIRS*/
         CLC   NUMBER(4,DATAPTR),@CF00045                          0282
         BNE   @RF00282                                            0282
*            PARENCNT = PARENCNT - 1;       /* ONE TIME DECREMENT   */
         L     @09,PARENCNT(,DATAPTR)                              0283
         BCTR  @09,0                                               0283
         ST    @09,PARENCNT(,DATAPTR)                              0283
*          IF LENGST ^= 0 THEN              /* CHECK FOR NULL PARM  */
@RF00282 LTR   LENGST,LENGST                                       0284
         BZ    @RF00284                                            0284
*            DO;                            /* PROCESS IF NOT NULL  */
*              IF CONVERT = '1'B   THEN     /* CHECK IF NUMBER      */
         TM    CONVERT(ENTRYPTR),B'00010000'                       0286
         BNO   @RF00286                                            0286
*                CALL VALUE;                /* CVB AND PUT IN JFCB  */
*                                                                  0287
         BAL   @14,VALUE                                           0287
*              ELSE                         /* CHECK FOR KEYWORDS   */
*                IF SUBWORDS = '1'B   THEN  /* KEYWORD HAVE KEYWORDS*/
         B     @RC00286                                            0288
@RF00286 TM    SUBWORDS(ENTRYPTR),B'10000000'                      0288
         BNO   @RF00288                                            0288
*                  DO;                      /* GET SUB-KEYWORD PROC */
*                    ENTSAVE = ENTRYPTR;    /* SAVE THIS POSITIONAL */
         ST    ENTRYPTR,ENTSAVE(,DATAPTR)                          0290
*                                           /* ENTRY POINTER        */
*                    ENTRYPTR = ENTCHAIN;   /* GET SUBKEY TABLE     */
         L     ENTRYPTR,ENTCHAIN(,ENTRYPTR)                        0291
*                    CALL FINDKEY;          /* SCAN TABLE FOR KEY   */
         BAL   @14,FINDKEY                                         0292
*                    IF FINDERR = '1'B  THEN/* IF END THEN NOT FOUND*/
         TM    FINDERR(DATAPTR),B'10000000'                        0293
         BNO   @RF00293                                            0293
*                      DO;                  /* BUILD AN ERROR MSG   */
*                        CALL ERROR;        /* MSG BUILD RTN        */
         BAL   @14,ERROR                                           0295
*                      END;                 /* END NOT FOUND KEY    */
*                                                                  0296
*                    ELSE                   /* A KEY WAS FOUND      */
*                      DO;                  /* PREPARE TO PUT BIT   */
         B     @RC00293                                            0297
@RF00293 DS    0H                                                  0298
*                        IF OVERFLOW = '1'B   THEN/*               0298
*                                                   JFCB EXT        */
         TM    OVERFLOW(ENTRYPTR),B'00000010'                      0298
         BNO   @RF00298                                            0298
*                          CALL ADDJFCB;    /* GET EXT IF JFCB OFL  */
         BAL   @14,ADDJFCB                                         0299
*                        ELSE JFCBREG = JFCBPTR; /* USE JFCB IF OK  */
         B     @RC00298                                            0300
@RF00298 L     JFCBREG,JFCBPTR(,PARMPTR)                           0300
*                        WORKREG = JFCBREG + JFCBDISP -1; /* A OF OR*/
@RC00298 LR    WORKREG,JFCBREG                                     0301
         SLR   @09,@09                                             0301
         IC    @09,JFCBDISP(,ENTRYPTR)                             0301
         ALR   WORKREG,@09                                         0301
         BCTR  WORKREG,0                                           0301
*                        GEN(OC  0(1,WORKREG),BYTEMASK(ENTRYPTR)); 0302
         OC  0(1,WORKREG),BYTEMASK(ENTRYPTR)
*                      END;                 /* END OF OR REQUEST    */
*                                                                  0303
*                    ENTRYPTR = ENTSAVE;    /* RESTORE ENTRY PTR    */
@RC00293 L     ENTRYPTR,ENTSAVE(,DATAPTR)                          0304
*                  END;                     /* END SUB-KEYWORDS     */
*                                                                  0305
*              ELSE;                        /* ONLY TWO TYPES SUPPOR*/
@RF00288 DS    0H                                                  0307
*            END;                           /* END FOR NON NULL VAL */
*          ELSE;                            /* NOP IF LENGTH = 0    */
*                                                                  0308
@RF00284 DS    0H                                                  0309
*          NUMBER = NUMBER + 1;             /* INCR POSITION NUMBER */
@RC00284 LA    @09,1                                               0309
         AL    @09,NUMBER(,DATAPTR)                                0309
         ST    @09,NUMBER(,DATAPTR)                                0309
*          IF SAMENTRY = '0'B  THEN         /* CHECK IF INCR NECESRY*/
         TM    SAMENTRY(ENTRYPTR),B'00000100'                      0310
         BNZ   @RF00310                                            0310
*            ENTRYPTR = ENTRYPTR + LENGTH(TENTRY); /* GET NEXT ENTRY*/
         AL    ENTRYPTR,@CF00210                                   0311
*          ELSE;                            /* USE THE SAME TABLE   */
@RF00310 DS    0H                                                  0313
*                                           /* ENTRY. THIS IS USED  */
*                                           /* FOR MULTIPLE SUB KEY */
*                                           /* WORDS                */
*        END;                               /* END OF DO WHILE LOOP */
*                                                                  0313
@DE00280 L     @09,NUMBER(,DATAPTR)                                0313
         CH    @09,MAXPOS(,DATAPTR)                                0313
         BH    @DC00280                                            0313
         L     @09,PARENCNT(,DATAPTR)                              0313
         LTR   @09,@09                                             0313
         BNZ   @DL00280                                            0313
@DC00280 DS    0H                                                  0314
*        REG14 = LINKSAV2;                  /* RESTORE LINK REG     */
         L     REG14,LINKSAV2(,DATAPTR)                            0314
*        END POSITINL;                      /* END POSITION SUB RTN */
@EL00007 DS    0H                                                  0315
@EF00007 DS    0H                                                  0315
@ER00007 BR    @14                                                 0315
@PB00007 DS    0H                                                  0316
*        GEN(EJECT);                                               0316
         EJECT
*VALUE:            /* THE VALUE OF A NUMBER IN A KEYWORD PROCEDURE  */
*PROC    OPTIONS(NOSAVEAREA,DONTSAVE,RETREG);                      0317
*                                                                  0317
         B     @PB00008                                            0317
VALUE    DS    0H                                                  0318
*        /* THE VALUE PROCEDURE IS CALLED WHEN THE KEYWORD CONTAINS */
*        /* A VALUE THAT MUST BE CONVERTED TO BINARY AND PLACED INTO*/
*        /* THE JFCB. THE VALUE IS CHECKED FOR VALIDITY, AND IF OK, */
*        /* IT IS PLACED INTO THE JFCB. THIS ROUTINE MAY CALL       */
*        /* ERROR AS AN INTERNAL PROCEDURE.                         */
*                                                                  0318
*        LINKSAV1 = REG14;                  /* SAVE THE RETURN REG  */
         ST    REG14,LINKSAV1(,DATAPTR)                            0318
*        WORKREG = 1;                       /* POSITION TO FIRST CHR*/
         LA    WORKREG,1                                           0319
*        MSGCODE = 0;                       /* INIT FOR NO ERROR    */
         SLR   @09,@09                                             0320
         ST    @09,MSGCODE(,DATAPTR)                               0320
*        IF LENGST > 8 THEN                 /* CHECK IF NO. TOO LARG*/
         C     LENGST,@CF00162                                     0321
         BNH   @RF00321                                            0321
*          MSGCODE = 2;                     /* TOO LARGE MSG CODE   */
*                                                                  0322
         MVC   MSGCODE(4,DATAPTR),@CF00104                         0322
*        DO WHILE WORKREG ^> LENGST;        /* PROCESS ONE VALUE    */
@RF00321 B     @DE00323                                            0323
@DL00323 DS    0H                                                  0324
*          IF KEYBUF(WORKREG) > 'F9'X ×     /* CHECK GREATER 9      */
*             KEYBUF(WORKREG) < 'F0'X THEN  /* CHECK LESS THAN 0    */
         LR    @09,DATAPTR                                         0324
         ALR   @09,WORKREG                                         0324
         CLI   KEYBUF-1(@09),X'F9'                                 0324
         BH    @RT00324                                            0324
         LR    @09,DATAPTR                                         0324
         ALR   @09,WORKREG                                         0324
         CLI   KEYBUF-1(@09),X'F0'                                 0324
         BNL   @RF00324                                            0324
@RT00324 DS    0H                                                  0325
*              MSGCODE = 3;                 /* INDICATE CONVERT ERR */
         MVC   MSGCODE(4,DATAPTR),@CF00109                         0325
*          ELSE;                            /* NO ERROR IF VALID 0-9*/
*                                                                  0326
@RF00324 DS    0H                                                  0327
*          WORKREG = WORKREG + 1;           /* INCR INDEX TO NEXT C */
         AL    WORKREG,@CF00045                                    0327
*        END;                               /* END VALIDITY CHECK   */
*                                                                  0328
@DE00323 CR    WORKREG,LENGST                                      0328
         BNH   @DL00323                                            0328
*        IF MSGCODE = 0 THEN                /* IS THIS A VALID NO.  */
         L     @09,MSGCODE(,DATAPTR)                               0329
         LTR   @09,@09                                             0329
         BNZ   @RF00329                                            0329
*          DO;                              /* PACK AND CVB IF OK   */
*            WORKREG = LENGST - 1;          /* LENGTH-1 FOR PACK EX */
         LR    WORKREG,LENGST                                      0331
         BCTR  WORKREG,0                                           0331
*            GEN(EX  WORKREG,PACK);         /* PACK INTO DOUBLE AREA*/
         EX  WORKREG,PACK
*            GEN(CVB WORKREG,DOUBLE(DATAPTR)); /* GET BINARY VAL RG */
         CVB WORKREG,DOUBLE(DATAPTR)
*            DOUBLE4 = WORKREG;             /* USE CVB AREA AS WORK */
         ST    WORKREG,DOUBLE4(,DATAPTR)                           0334
*            IF SIZE = 3 THEN               /* CHECK 3 BYTE SIZE    */
         CLI   SIZE(ENTRYPTR),3                                    0335
         BNE   @RF00335                                            0335
*              DO;                          /* 3 BYTE SIZE CHECK    */
*                IF WORKREG > 8388607 THEN  /* MAX 3 BYTE VALUE     */
         C     WORKREG,@CF00166                                    0337
         BNH   @RF00337                                            0337
*                  MSGCODE = 2;             /* INDICATE TOO LARGE   */
         MVC   MSGCODE(4,DATAPTR),@CF00104                         0338
*              END;                         /* END 3 BYTE VALUE CHEK*/
*            ELSE                                                  0340
*              IF SIZE = 2 THEN             /* CHECK 2 BYTE SIZE    */
         B     @RC00335                                            0340
@RF00335 CLI   SIZE(ENTRYPTR),2                                    0340
         BNE   @RF00340                                            0340
*                DO;                        /* 2 BYTE SIZE CHECK    */
*                  IF WORKREG > 32767 THEN  /* MAX 2 BYTE VALUE     */
         C     WORKREG,@CF00167                                    0342
         BNH   @RF00342                                            0342
*                    MSGCODE = 2;           /* INDICATE TOO LARGE   */
         MVC   MSGCODE(4,DATAPTR),@CF00104                         0343
*                END;                       /* END 3 BYTE VALUE CHEK*/
*              ELSE;                                               0345
@RF00340 DS    0H                                                  0346
*            IF OVERFLOW = '1'B   THEN      /* JFCB EXTENSION CK    */
@RC00340 DS    0H                                                  0346
@RC00335 TM    OVERFLOW(ENTRYPTR),B'00000010'                      0346
         BNO   @RF00346                                            0346
*              CALL ADDJFCB;                /* GET EXTENSION IF YES */
         BAL   @14,ADDJFCB                                         0347
*            ELSE JFCBREG = JFCBPTR;        /* USE JFCB IF OK       */
         B     @RC00346                                            0348
@RF00346 L     JFCBREG,JFCBPTR(,PARMPTR)                           0348
*            JFCB(JFCBDISP:JFCBDISP+SIZE-1) = DOUBLE4(5-SIZE:SIZE);
@RC00346 SLR   @09,@09                                             0349
         IC    @09,JFCBDISP(,ENTRYPTR)                             0349
         ALR   @09,JFCBREG                                         0349
         BCTR  @09,0                                               0349
         SLR   @15,@15                                             0349
         IC    @15,SIZE(,ENTRYPTR)                                 0349
         LR    @14,@15                                             0349
         BCTR  @14,0                                               0349
         LCR   @15,@15                                             0349
         AL    @15,@CF00168                                        0349
         ALR   @15,DATAPTR                                         0349
         BCTR  @15,0                                               0349
         EX    @14,@SM00744                                        0349
*          END;                             /* END VALID DECIMAL #  */
*                                                                  0350
*        ELSE;                              /* PROC IF ERROR VALID  */
@RF00329 DS    0H                                                  0352
*          IF MSGCODE ^= 0 THEN             /* CHECK IF AN ERROR    */
         L     @09,MSGCODE(,DATAPTR)                               0352
         LTR   @09,@09                                             0352
         BZ    @RF00352                                            0352
*            CALL ERROR;                    /* INVALID NUMBER MSG   */
*                                                                  0353
         BAL   @14,ERROR                                           0353
*        REG14 = LINKSAV1;                  /* RESTORE LINK REG     */
@RF00352 L     REG14,LINKSAV1(,DATAPTR)                            0354
*        RETURN;                            /* RETURN TO CALLER     */
@EL00008 DS    0H                                                  0355
@EF00008 DS    0H                                                  0355
@ER00008 BR    @14                                                 0355
*PACK:   /* THIS INSTRUCTION IS USED BY AN ASSEMBLER EXECUTE INST   */
*        GEN(PACK  DOUBLE(8,DATAPTR),KEYBUFER(0,DATAPTR));  /* PACK */
PACK     PACK  DOUBLE(8,DATAPTR),KEYBUFER(0,DATAPTR)
*        END  VALUE;                        /* END OF VALUE INTERNAL*/
         B     @EL00008                                            0357
@PB00008 DS    0H                                                  0358
*        GEN(EJECT);                                               0358
*                                                                  0358
         EJECT
*        /* THE FOLLOWING REGISTERS ARE USED BY IEFVAMP             */
*        DCL                                /* DEFINE THE REGS      */
*         (REG1      REG(1)            ,    /* CONTAINS PARM LIST   */
*          REG13     REG(13)           ,    /* SAVE AREA REG        */
*          REG14     REG(14)           ,    /* SUBROUTINE LINK REG  */
*          REG15     REG(15)) PTR(31);      /* RETURN CODE REGISTER */
*                                                                  0359
*        DCL                                /* DEFINE RESTRICTED REG*/
*         (WORKREG   REG(2)  ,              /* GENERAL WORK REG     */
*          PARMPTR   REG(3)  ,              /* SAVES THE PARM LIST  */
*          LENGST    REG(4)  ,              /* LENGTH OF A WORD     */
*          DATAPTR   REG(5)  ,              /* PTR TO WORK AREA     */
*          STRINGPT  REG(6)  ,              /* INDEX FOR PARM STRING*/
*          ENTRYPTR  REG(7) ,               /* TABLE ENTRY POINTER  */
*          JFCBREG   REG(8) )               /* JFCB OR JFCB EXT PTR */
*                  RESTRICTED PTR(31);      /* RESTRICT POINTERS    */
*                                                                  0360
*        GEN(EJECT);                                               0361
*                                                                  0361
         EJECT
*        /* THE FOLLOWING PARAMETER LIST IS PASSED TO IEFVAMP BY    */
*        /* THE SCHEDULER IN REGISTER 1 UPON ENTRY                  */
*                                                                  0362
*        DCL   LISTPTR PTR(31) BASED(REG1); /* POINTER TO PARMLIST  */
*                                                                  0362
*        DCL 1 PARMLIST  BASED(PARMPTR),    /* PTR KEPT IN PARMPTR  */
*              2 STRINGS     PTR(31),       /* PTR TO AMP CHAR STRNG*/
*              2 JFCBPTR     PTR(31),       /* PTR TO THE JFCB      */
*              2 TEMPLIST    CHAR(12) BDY(WORD), /* COND GETMAIN LST*/
*                3 MSGPTR    PTR(31),       /* PTR TO ERROR MSGS    */
*                3 OVERPTR   PTR(31),       /* OVERFLOW JFCB PTR    */
*                3 JFCBOFST  PTR(15),       /* JFCB OVERFLOW TTR DSP*/
*                3 OVEROFST  PTR(15),       /* OVERFLOW TTR DISPLACE*/
*              2 *           PTR(15),       /* RESERVED             */
*              2 OVERID      PTR(8),        /* OVERFLOW REC ID      */
*              2 SUBPONL     PTR(8);        /* SUBPOOL NUMBER FOR GT*/
*                                                                  0363
*        GEN(EJECT);                                               0364
*                                                                  0364
         EJECT
*        /* THE FOLLOWING DCL DEFINES THE ERROR MESSAGE BUFFER      */
*                                                                  0365
*        DCL 1 MESSAGE BASED(WORKREG),      /* GOTTEN CORE PTR IN RG*/
*              2 MSGLEN      FIXED(15),     /* MESSAGE LENGTH       */
*              2 MSGZERO     PTR(15),       /* RESERVED             */
*              2 MSGCHAIN    PTR(31),       /* CHAIN TO NEXT MSG OR */
*              2 MSGBUF      CHAR(80),      /* TEXT OF ERROR MSG    */
*                3 MSGPREF   CHAR(21),      /* IEFXXXI KEYWORD PREFX*/
*                  4 MSGNBR  CHAR(7),       /* MSG NUMBER           */
*                3 MSGWORD   CHAR(9),       /* ERROR KEYWORD        */
*                3 MSGMDLE   CHAR(31),      /* UNIQUE PART OF MSG   */
*                  4 *       CHAR(7),       /* VALUE                */
*                  4 MSGVAL  CHAR(9),       /* VALUE IN ERROR       */
*                3 MSGNOTE   CHAR(19);      /* STEP NOT EXECUTED MSG*/
*                                                                  0365
*        /* THE FOLLOWING DCL DEFINES THE CHARACTER STRING          */
*        /* CONTAINING THE PARAMETERS SPECIFIED ON THE AMP KEYWORD  */
*                                                                  0366
*        DCL 1 DSTRING BASED(STRINGS),      /* BASED ON PARM LIST   */
*              2 PARMLENG    FIXED(15),     /* LENGTH OF STRING     */
*              2 STRING(*)   CHAR(1);       /* INDEXED STRING OF CHR*/
*                                                                  0366
*        /* THE FOLLOWING DCL DEFINES A 176 BYTE JFCB               */
*                                                                  0367
*        DCL   JFCB  CHAR(176) BASED(JFCBREG); /* BASED ON PARM LIST*/
*                                                                  0367
*        /* THE FOLLOWING DCL DEFINES THE 180 BYTE JFCB EXTENSION   */
*                                                                  0368
*        DCL 1 JFCBEXT BASED(JFCBREG),      /* ACCESSED BY JFCBREG  */
*              2 JFCBCHAN    PTR(31),       /* CHAIN TO NEXT OR 0   */
*              2 OVERFULL    BIT(1);        /* EXTENSION IS FULL    */
*                                                                  0368
*        DCL RETURNED PTR(31) BASED(REG13); /* RETURN GOT CORE PTR  */
*        GEN(EJECT);                                               0370
*                                                                  0370
         EJECT
*        /* THE FOLLOWING WORK AREA IS IN CORE OBTAINED BY A GETMAIN*/
*        /* DURING THE INITIALIZATION PROCEDURE. IT IS POINTED TO BY*/
*        /* DATAPTR.                                                */
*                                                                  0371
*        DCL 1 DATAREA BASED(DATAPTR) BDY(DWORD), /* GETMAINED CORE */
*              2 DOUBLE      CHAR(8) BDY(DWORD), /* CVB WORK AREA   */
*                3 DOUBLE4   CHAR(4),      /* WORD CVB WORK AREA   */
*              2 GETLIST     CHAR(12) BDY(DWORD), /* GETMAIN LIST   */
*                3 MAXPOS    FIXED(15) BDY(HWORD), /* # OF KEYS     */
*              2 TEMPSAVE    PTR(31),       /* TEMPORARY SAVE AREA  */
*              2 ZEROINIT    CHAR(12) BDY(WORD),   /* INIT TO 0     */
*                3 RETURNS   PTR(31),       /* RETURN PTR TO CORE   */
*                3 MSGCODE   FIXED(31),     /* ERROR MSG NUMBER     */
*                3 RETCODE   FIXED(31),     /* IEFVAMP RETURN CODE  */
*              2 PARENCNT    FIXED(31),     /* NO. OF PARENTHESES   */
*              2 ENTSAVE     PTR(31),       /* TABLE ENTRY SAVE AREA*/
*              2 LINKSAV1    PTR(31),       /* LINKREG SAVE AREA    */
*              2 LINKSAV2    PTR(31),       /* LINKREG SAVE AREA    */
*              2 LINKSAV3    PTR(31),       /* LINKREG SAVE AREA    */
*              2 LINKSAV4    PTR(31),       /* LINKREG SAVE AREA    */
*              2 NUMBER      FIXED(31),     /* POSITIONAL PARM NO.  */
*              2 KEYBUFER    CHAR(9),       /* KEYWORD BUFFER       */
*                3 KEYBUF8   CHAR(8),       /* 8 BYTE SUBSET OF KEY */
*                  4 KEYBUF(*) CHAR(1),     /* INDEXED KEYWORD BYTE */
*              2 ERRBITS    BIT(8),         /* ERROR COND BITS      */
*                3 FINDERR  BIT(1),         /* ERROR ON FINDKEY RTN */
*              2 TEMPFLD      BIT(32),      /* AND AREA FOR DUP BITS*/
*                3 TEMPFLD2    BIT(8),      /* AREA FOR COMPATIBLE  */
*              2 DUPBITS      BIT(32),      /* DUP OR CONFLICT BITS */
*              2 COMPAT       BIT(8);       /* COMPATBL DSORG BITS  */
*                                                                  0371
*        GEN(EJECT);                                               0372
*                                                                  0372
         EJECT
*        /* THE FOLLOWING DCL DEFINES AN ENTRY IN THE KEYWORD TABLE */
*                                                                  0373
*        DCL 1 TENTRY BASED(ENTRYPTR),      /* ENTRYPTR KEEP ADDR   */
*              2 FLAGS1      BIT(8),        /* TYPE OF KEY AND PROC */
*                3 SUBWORDS  BIT(1),        /* KEYWORD HAS SUB KEYS */
*                3 ORMASK    BIT(1),        /* OR BITS INTO JFCB    */
*                3 MOVECHAR  BIT(1),        /* MOVE WORD INTO JFCB  */
*                3 CONVERT   BIT(1),        /* CVB DECIMAL TO BINARY*/
*                3 POSITKEY  BIT(1),        /* POSITIONAL PARMS     */
*                3 SAMENTRY  BIT(1),        /* DO NOT INCR POS ENTRY*/
*                3 OVERFLOW  BIT(1),        /* JFCB EXT NEEDED      */
*                3 ANDIT     BIT(1),        /* AND BITS OFF  @Y30LSPS*/
*              2 KEYWORD     CHAR(9),       /* KEYWORD FOR THIS ENTY*/
*              2 BYTEMASK    BIT(8),        /* BITS TO OR INTO JFCB */
*                3 SIZE      PTR(8),        /* SIZE OF FIELD IF CVB */
*              2 JFCBDISP    PTR(8),        /* DISPLACEMENT IN JFCB */
*                3 MAXKEYS   PTR(8),        /* MAX NO. KEY IF SUBWDS*/
*              2 CONFLICT    BIT(32),       /* DUPLICATE OF CONFLICT*/
*                3 BUFSP     BIT(1),        /* BUFSP IS A DUPLICATE */
*                3 BUFND     BIT(1),        /* BUFND IS A DUPLICATE */
*                3 BUFNI     BIT(1),        /* BUFNI IS A DUPLICATE */
*                3 STRNO     BIT(1),        /* STRNO IS A DUPLICATE */
*                3 SYNAD     BIT(1),        /* SYNAD IS A DUPLICATE */
*                3 CROPS     BIT(1),        /* CROPS IS A DUPLICATE */
*                3 RECFM     BIT(1),        /* RECFM IS A DUPLICATE */
*                3 AMORG     BIT(1),        /* AMORG IS A DUPLICATE */
*                3 TRACE     BIT(1),        /* TRACE IS A DUPLICATE */
*                3 OPTCD     BIT(1),        /* OPTCD IS A DUPLICATE */
*                3 *         BIT(22),       /* RESERVED BITS @Y30LSPS*/
*              2 DSORGS      BIT(8),        /* REQ DSORGS BIT       */
*                3 VSAM      BIT(1),        /* COMPATIBLE WITH VSAM */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 ENTCHAIN    PTR(31) BDY(WORD); /* CHAIN PTR IF SUB */
*                                                                  0373
*        GEN(EJECT);                                               0374
*                                                                  0374
         EJECT
*        /* THE FOLLOWING DECLARES ARE LOCATED AT THE END OF THIS   */
*        /* MODULE. IF THEY BECOME TO LARGE THEY CAN BE PLACED INTO */
*        /* A SEPARATE CSECT.                                       */
*                                                                  0375
*        DCL MSGP1 CHAR(21) INIT            /* PREFIX FOR ERROR MSG */
*         ('IEFXXXI AMP KEYWORD ');                                0375
*                                                                  0375
*        DCL MSGP9 CHAR(19) INIT            /* END OF ERROR MSG     */
*         (' STEP NOT EXECUTED ');                                 0376
*                                                                  0376
*        DCL MSGMDL1 CHAR(31) INIT          /* INVALID KEYWORD MSG  */
*         (' IS INVALID ');                                        0377
*                                                                  0377
*        DCL MSGMDL2 CHAR(31) INIT          /* VALUE ERROR MSG      */
*         (' VALUE            IS TOO LARGE ');                     0378
*                                                                  0378
*        DCL MSGMDL3 CHAR(31) INIT          /* NON DECIMAL ERROR MSG*/
*         (' REQUIRES A DECIMAL VALUE ');                          0379
*                                                                  0379
*        DCL MSGMDL4 CHAR(31) INIT          /* DUPLICATE OR CONFLICT*/
*          ('DUPLICATE OR CONFLICTING PARM');              /*@Y30LSPS*/
*                                                                  0380
*        DCL MSGNBR1 CHAR(7) INIT           /* MESSAGE NUMBER       */
*         ('IEF447I');                                             0381
*                                                                  0381
*        DCL MSGNBR2 CHAR(7) INIT           /* MESSAGE NUMBER       */
*         ('IEF448I');                                             0382
*                                                                  0382
*        DCL MSGNBR3 CHAR(7) INIT           /* MESSAGE NUMBER       */
*         ('IEF449I');                                             0383
*                                                                  0383
*        DCL MSGNBR4 CHAR(7) INIT           /* DUPLICATE OR CONFLICT*/
*          ('IEF175I');                                    /*@Y30LSPS*/
*                                                                  0384
*        GEN(EJECT);                                               0385
*                                                                  0385
*                                                                  0385
         EJECT
*/* **************************************************************** */
*/*                                                                  */
*/*                    JOB FILE CONTROL BLOCK                        */
*/*                                                                  */
*/*  OS/VS2 RELEASE 4, 06/24/75, LEVEL=1                             */
*/*                                                                  */
*/*  METHOD OF ACCESS                                                */
*/*      BAL  - A DSECT CARD SHOULD PRECEDE MACRO CALL.  USING ON    */
*/*             INFMJFCB GIVES ADDRESSABILITY FOR ALL SYMBOLS.       */
*/*      PL/S - DCL JFCBPTR PTR                                      */
*/*                                                                  */
*/*  F.E.'S                                                          */
*/*      MICROFICHE LISTING - IEFJFCBN                               */
*/*                                                                  */
*/*  DEVELOPERS                                                      */
*/*      BAL LISTING  - SPECIFY LIST=YES ON MACRO CALL.              */
*/*      PL/S LISTING - SPECIFY %IHALIST='YES' BEFORE INCLUDE.       */
*/*                                                                  */
*/*      FOR INTEGRATION A LISTING SHOULD NOT BE REQUESTED.          */
*/* **************************************************************** */
*                                                                  0386
*DECLARE                                                           0386
*  1 INFMJFCB BASED(JFCBPTR) BDY(WORD),                            0386
*   2 JFCBDSNM CHAR(44) BDY(WORD), /* DATA SET NAME                  */
*    3 JFCBQNAM CHAR(8) BDY(WORD), /* PROCESS QUEUE NAME SPECIFIED BY
*                                     THE QNAME KEYWORD  (TCAM)      */
*   2 JFCBELNM CHAR(8) BDY(WORD),  /* ELEMENT NAME OR RELATIVE     0386
*                                     GENERATION NUMBER.  TYPE OF  0386
*                                     AREA (INDEX, PRIME OR OVERFLOW)
*                                     FOR AN INDEXED SEQUENTIAL DATA
*                                     SET ONLY.                      */
*    3 JFCIPLTX CHAR(7) BDY(WORD), /* MODULE NAME OF NETWORK CONTROL
*                                     PROGRAM  (TCAM)          ICB391*/
*   2 JFCBTSDM BIT(8),             /* JOB MANAGEMENT/DATA MANAGEMENT
*                                     INTERFACE                      */
*    3 JFCCAT   BIT(1),            /* DATA SET IS CATALOGED          */
*    3 JFCVSL   BIT(1),            /* VOLUME SERIAL LIST HAS BEEN  0386
*                                     CHANGED                        */
*    3 JFCSDS   BIT(1),            /* DATA SET IS A SYSIN OR SYSOUT
*                                     DATA SET                       */
*    3 JFCTTR   BIT(1),            /* A JOB STEP IS TO BE RESTARTED.
*                                     USE JFCBOTTR INSTEAD OF      0386
*                                     DS1LSTAR FIELD TO REPOSITION 0386
*                                     DATA SET IF AUTOMATIC STEP   0386
*                                     RESTART OCCURS.  (THIS JOB HAD
*                                     ABEND PROCESSING FOR A DATA SET
*                                     OPENED FOR MOD.)               */
*    3 JFCNWRIT BIT(1),            /* DO NOT WRITE BACK THE JFCB   0386
*                                     DURING OPEN PROCESSING         */
*    3 JFCNDSCB BIT(1),            /* DO NOT MERGE DSCB OR LABEL   0386
*                                     FIELDS INTO THIS JFCB          */
*    3 JFCNDCB  BIT(1),            /* DO NOT MERGE DCB FIELDS INTO 0386
*                                     THIS JFCB                      */
*    3 JFCPAT   BIT(1),            /* THE PATTERNING DSCB IS COMPLETE*/
*   2 JFCBDSCB CHAR(3) BDY(WORD,2),/* TTR ADDRESS OF THE FORMAT 1  0386
*                                     DSCB FOR DATA SET PART ON THE
*                                     FIRST VOLUME OF THE DATA SET 0386
*                                                              ICB398*/
*   2 JFCFCBID CHAR(4) BDY(WORD),  /* FORMS CONTROL BUFFER IMAGE   0386
*                                     IDENTIFICATION FOR THE 3211  0386
*                                     PRINTER OR DATA PROTECTION   0386
*                                     IMAGE IDENTIFICATION FOR THE 0386
*                                     3525 CARD PUNCH WITH THE READ
*                                     AND PRINT FEATURES OR FORMAT 0386
*                                     RECORD ID                MDC007*/
*    3 JFCBFRID CHAR(4) BDY(WORD), /* LAST 4 CHARACTERS OF A PDS   0386
*                                     MEMBER TO BE USED IN THE     0386
*                                     INTERPRETATION OF DOCUMENTS  0386
*                                     READ BY 3886 DEVICE FOR THIS 0386
*                                     STEP                     MDC024*/
*     4 JFCAMCRO CHAR(2) BDY(WORD), /* VSAM CHECKPOINT/RESTART OPTION
*                                     INDICATORS               ICB438*/
*     4 JFCAMSTR FIXED(15) BDY(WORD,3), /* NUMBER OF STRINGS   ICB438*/
*   2 JFCBADBF FIXED(15) BDY(WORD), /* NUMBER OF DATA BUFFERS  ICB438*/
*   2 JFCNLREC FIXED(15) BDY(WORD,3), /* LOGICAL RECORD LENGTH FOR 0386
*                                     VSAM                     ICB438*/
*   2 JFCVINDX FIXED(15) BDY(WORD), /* MASS STORAGE SYSTEM         0386
*                                     COMMUNICATOR (MSSC) VOLUME   0386
*                                     SELECTION INDEX              0386
*                                     (MDC308)               @Z30LP9A*/
*   2 JFCBLTYP BIT(8) BDY(WORD,3), /* LABEL TYPE                     */
*    3 JFCRSV38 BIT(1),            /* RESERVED                       */
*    3 JFCBAL   BIT(1),            /* AMERICAN NATIONAL STANDARD TAPE
*                                     LABELS (AL OR IF BIT 4 IS ALSO
*                                     ON, AUL)                       */
*    3 JFCBLTM  BIT(1),            /* UNLABELLED TAPE CREATED BY DOS
*                                     MAY HAVE LEADING TAPE MARK.  0386
*                                     OPEN/CLOSE/EOV AND RESTART MUST
*                                     SPACE OVER A TAPE MARK IF ONE
*                                     EXISTS.                  ICB398*/
*    3 JFCBLP   BIT(1),            /* BYPASS LABEL PROCESSING        */
*    3 JFCSUL   BIT(1),            /* USER LABEL                     */
*    3 JFCNSL   BIT(1),            /* NONSTANDARD LABEL              */
*    3 JFCSL    BIT(1),            /* STANDARD LABEL                 */
*    3 JFCNL    BIT(1),            /* NO LABEL                       */
*   2 JFCBOTTR CHAR(3) BDY(WORD,4),/* DASD MOD DATA SET - IF AUTOMATIC
*                                     STEP RESTART WAS REQUESTED, TTR
*                                     OF THE END-OF-DATA INDICATOR 0386
*                                     EXISTING WHEN THE DATA SET WAS
*                                     FIRST OPENED DURING THE      0386
*                                     ORIGINAL EXECUTION OF THE    0386
*                                     CURRENT STEP                   */
*    3 JFCBUFOF PTR(8),            /* TAPE DATA SET - THIS FIELD   0386
*                                     CONTAINS THE BUFFER OFFSET (DCB
*                                     SUBPARAMETER VALUE)            */
*     4 JFCBFOFL BIT(1),           /* IF 1, THE OFFSET EQUALS FOUR 0386
*                                     AND THE BUFFER OFFSET FIELD OF
*                                     EACH BLOCK (D-FORMAT RECORDS)
*                                     CONTAINS THE BLOCK LENGTH    0386
*                                     (SPECIFIED BY BUFOFF=L).     0386
*                                     IF 0, THE OFFSET IS AS       0386
*                                     SPECIFIED IN THE REMAINING   0386
*                                     SEVEN BITS AND THE BUFFER    0386
*                                     OFFSET FIELD OF EACH BLOCK DOES
*                                     NOT CONTAIN THE BLOCK LENGTH.  */
*    3 JFCBFLSQ FIXED(15),         /* FOR MAGNETIC TAPE DEVICES,   0386
*                                     FILE SEQUENCE NUMBER           */
*     4 JFCFUNC  BIT(8),           /* FUNCTION INDICATORS FOR THE  0386
*                                     3525 CARD PUNCH (SPECIFIED BY
*                                     THE FUNC PARAMETER)      ICB392*/
*      5 JFCFNCBI BIT(1),          /* I - INTERPRET (PUNCH AND PRINT
*                                     TWO LINES)               ICB392*/
*      5 JFCFNCBR BIT(1),          /* R - READ                 ICB392*/
*      5 JFCFNCBP BIT(1),          /* P - PUNCH                ICB392*/
*      5 JFCFNCBW BIT(1),          /* W - PRINT                ICB392*/
*      5 JFCFNCBD BIT(1),          /* D - DATA PROTECTION      ICB392*/
*      5 JFCFNCBX BIT(1),          /* X - THIS DATA SET IS TO BE   0386
*                                     PRINTED.  THIS MAY BE CODED  0386
*                                     WITH PW OR RPW TO DISTINGUISH
*                                     THE DATA SET TO BE PRINTED FROM
*                                     THE DATA SET TO BE PUNCHED.  0386
*                                                              ICB392*/
*      5 JFCFNCBT BIT(1),          /* T - TWO-LINE PRINT SUPPORT   0386
*                                     REQUEST.  THE SECOND PRINT LINE
*                                     IS LOCATED ON CARD LINE THREE.
*                                                              ICB392*/
*      5 JFCRSV31 BIT(1),          /* RESERVED                 ICB392*/
*   2 JFCBVLSQ FIXED(15),          /* VOLUME SEQUENCE NUMBER         */
*   2 JFCBMASK CHAR(8) BDY(WORD),  /* DATA MANAGEMENT TASK           */
*    3 JFCBOPS1 CHAR(5),           /* OPEN ROUTINE INTERNAL SWITCHES */
*    3 JFCBFLG1 BIT(8),            /* FLAG BYTE                      */
*     4 JFCSTAND BIT(1),           /* VOLUME LABEL PROCESSING      0386
*                                     STANDARD                       */
*     4 JFCSLCRE BIT(1),           /* CREATION OF A STANDARD LABEL 0386
*                                     IS NECESSARY                   */
*     4 JFCSLDES BIT(1),           /* DESTRUCTION OF A STANDARD LABEL
*                                     IS NECESSARY                   */
*     4 JFCDUAL  BIT(1),           /* DUAL-DENSITY CHECK DETECTED    */
*     4 JFCOPEN  BIT(4),           /* OPEN ROUTINE INTERNAL SWITCHES */
*      5 *        BIT(3),          /* OPEN ROUTINE INTERNAL SWITCHES */
*      5 JFCBPWBP BIT(1),          /* PASSWORD BYPASS INDICATOR    0386
*                                                              MDC010*/
*    3 JFCBFLG2 BIT(8),            /* FLAG BYTE OF OPEN SWITCHES     */
*     4 JFCINOP  BIT(1),           /* TREAT THE INOUT OPTION OF OPEN
*                                     AS INPUT                       */
*     4 JFCOUTOP BIT(1),           /* TREAT THE OUTIN OPTION OF OPEN
*                                     AS OUTPUT                      */
*     4 JFCDEFER BIT(1),           /* SET ONLY IN A JFCB RECORDED IN
*                                     A DATA SET DESCRIPTOR RECORD 0386
*                                     (DSDR) BY THE CHECKPOINT     0386
*                                     ROUTINE.  INDICATES THAT THE 0386
*                                     DATA SET RELATED TO THE JFCB IS
*                                     BEING PROCESSED SEQUENTIALLY,
*                                     AT THE CHECKPOINT, ON A VOLUME
*                                     OTHER THAN THE VOLUME ON WHICH
*                                     PROCESSING BEGAN IN THE CURRENT
*                                     STEP.  WHEN RESTART OCCURS,  0386
*                                     THIS BIT CAUSES DEFERRED VOLUME
*                                     MOUNTING.                      */
*      5 JFCNRPS  BIT(1),          /* USE BY OPEN ROUTINES - SET TO
*                                     INDICATE THAT THIS DATA SET  0386
*                                     RESIDES ON A NON-RPS DEVICE. 0386
*                                     RESET TO ZERO WHEN OPEN      0386
*                                     PROCESSING IS COMPLETED. ICB495*/
*     4 JFCMODNW BIT(1),           /* DISPOSITION OF THIS DATA SET 0386
*                                     HAS BEEN CHANGED FROM MOD TO 0386
*                                     NEW.  DISPOSITION (IN JFCBIND2)
*                                     WILL BE RESTORED TO MOD AFTER
*                                     OPEN.                          */
*     4 JFCSDRPS BIT(1),           /* USE SEARCH DIRECT FOR        0386
*                                     ROTATIONAL POSITION SENSING  0386
*                                     (RPS) DEVICES            ICB398*/
*     4 JFCTRACE BIT(1),           /* GTF TRACE IS TO OCCUR DURING 0386
*                                     OPEN/CLOSE/EOV AND DYNAMIC   0386
*                                     ALLOCATION PROCESSING OF DCB 0386
*                                                              ICB392*/
*     4 JFCBBUFF BIT(1),           /* INDICATOR TO OPEN THAT A     0386
*                                     NON-ZERO VALUE IN JFCBOTTR IS
*                                     NOT TO PREVENT THE NORMAL    0386
*                                     STORING BY OPEN OF A TTR IN  0386
*                                     JFCBOTTR.  BEFORE OPEN -     0386
*                                     JFCBUFOF (OFFSET 67) CONTAINS
*                                     A BUFFER OFFSET OR INVALID   0386
*                                     INFORMATION RESULTING FROM A 0386
*                                     JFCB-TO-JFCB MERGE.  AFTER   0386
*                                     OPEN - OPEN MAY HAVE STORED A
*                                     TTR IN JFCBOTTR (OFFSET 67), IN
*                                     WHICH CASE OPEN WILL HAVE SET
*                                     THIS BIT TO ZERO.              */
*     4 JFCRCTLG BIT(1),           /* OPEN HAS UPDATED THE TTR.    0386
*                                     SCHEDULER STEP TERMINATION   0386
*                                     ROUTINE IS TO RECATALOG THIS 0386
*                                     DATA SET AND PLACE IN THE    0386
*                                     CATALOG ENTRY THE DSCB TTR   0386
*                                     CONTAINED IN JFCBDSCB IF THIS
*                                     DATA SET IS CATALOGED.   ICB398*/
*    3 JFCBOPS2 BIT(8),            /* OPEN ROUTINE INTERNAL SWITCHES */
*   2 JFCBCRDT CHAR(3) BDY(WORD),  /* DATA SET CREATION DATE (YDD, 0386
*                                     Y=YEAR AND DD=DAY)             */
*   2 JFCBXPDT CHAR(3) BDY(WORD,4),/* DATA SET EXPIRATION DATE (YDD) */
*   2 JFCBIND1 BIT(8),             /* INDICATOR BYTE 1               */
*    3 JFCRLSE  BIT(2),            /* RELEASE EXTERNAL STORAGE       */
*    3 JFCLOC   BIT(2),            /* DATA SET HAS BEEN LOCATED      */
*    3 JFCADDED BIT(2),            /* NEW VOLUME HAS BEEN ADDED TO 0386
*                                     THE DATA SET                   */
*    3 JFCGDG   BIT(1),            /* DATA SET IS A MEMBER OF A    0386
*                                     GENERATION DATA GROUP          */
*    3 JFCPDS   BIT(1),            /* DATA SET IS A MEMBER OF A    0386
*                                     PARTITIONED DATA SET           */
*   2 JFCBIND2 BIT(8),             /* INDICATOR BYTE 2               */
*    3 JFCDISP  BIT(2),            /* BIT PATTERN FOR NEW, MOD, OLD  */
*    3 JFCSECUR BIT(2),            /* DATA SET SECURITY              */
*    3 JFCSHARE BIT(1),            /* SHARED DATA SET                */
*    3 JFCENT   BIT(1),            /* DELETE THIS JFCB BEFORE      0386
*                                     ALLOCATION FOR A RESTARTED   0386
*                                     GENERATION DATA GROUP          */
*    3 JFCREQ   BIT(1),            /* STORAGE VOLUME REQUESTED       */
*    3 JFCTEMP  BIT(1),            /* TEMPORARY DATA SET             */
*   2 JFCAMPTR PTR(31),            /* POINTER TO AMPBLK FOR        0386
*                                     ADDITIONAL VSAM PARAMETERS   0386
*                                                              ICB438*/
*    3 JFCBUFRQ CHAR(1),           /* NUMBER OF BUFFERS REQUIRED FOR
*                                     EACH LINE (QTAM)               */
*     4 JFCBUFNO CHAR(1),          /* NUMBER OF BUFFERS REQUIRED FOR
*                                     THIS DATA SET (ACCESS METHODS
*                                     OTHER THAN TCAM AND QTAM)      */
*      5 JFCBUFIN BIT(4),          /* THE NUMBER OF BUFFERS ASSIGNED
*                                     INITIALLY FOR RECEIVING      0386
*                                     OPERATIONS FOR EACH LINE IN A
*                                     LINE GROUP  (TCAM)       MDC021*/
*      5 JFCBFOUT BIT(4),          /* THE NUMBER OF BUFFERS ASSIGNED
*                                     INITIALLY FOR SENDING        0386
*                                     OPERATIONS FOR EACH LINE IN A
*                                     LINE GROUP  (TCAM)       MDC022*/
*    3 JFCBGNCP PTR(8),            /* FOR GAM, THIS FIELD IS USED FOR
*                                     THE NUMBER OF IOB'S CONSTRUCTED
*                                     BY THE OPEN ROUTINE.  MAXIMUM
*                                     NUMBER IS 99.            MDC025*/
*     4 JFCBHIAR CHAR(1),          /* BUFFER POOL LOCATION IN MAIN 0386
*                                     STORAGE (HIERARCHY)            */
*      5 JFCBFALN CHAR(1),         /* BUFFER ALIGNMENT               */
*       6 JFCBFTEK BIT(8),         /* BUFFERING TECHNIQUE            */
*        7 JFCHIER  BIT(1),        /* BITS 0 AND 5 DESCRIBE MAIN   0386
*                                     STORAGE HIERARCHY.  BOTH BITS
*                                     OFF, HIERARCHY 0.  BIT 0 OFF 0386
*                                     AND BIT 5 ON, HIERARCHY 1.     */
*        7 JFCBBFTA BIT(2),        /* A - FOR QSAM LOCATE MODE     0386
*                                     PROCESSING OF SPANNED RECORDS,
*                                     AUTOMATIC RECORD AREA        0386
*                                     CONSTRUCTION DURING LOGICAL  0386
*                                     RECORD INTERFACE PROCESSING. 0386
*                                     OPEN IS TO CONSTRUCT A RECORD
*                                     AREA IF IT AUTOMATICALLY     0386
*                                     CONSTRUCTS BUFFERS.            */
*         8 JFCSIM   BIT(1),       /* S - SIMPLE BUFFERING           */
*         8 JFCBBFTR BIT(1),       /* R - FOR BSAM CREATE BDAM     0386
*                                     PROCESSING OR BDAM PROCESSING
*                                     OF UNBLOCKED SPANNED RECORDS,
*                                     SOFTWARE TRACK OVERFLOW.  OPEN
*                                     FORMS A SEGMENT WORK AREA POOL
*                                     AND STORES THE ADDRESS OF THE
*                                     SEGMENT WORK AREA CONTROL BLOCK
*                                     IN THE DCBEOBW FIELD OF THE  0386
*                                     DATA CONTROL BLOCK.  WRITE USES
*                                     A SEGMENT WORK AREA TO WRITE A
*                                     RECORD AS ONE OR MORE SEGMENTS.
*                                     FOR BSAM INPUT PROCESSING OF 0386
*                                     UNBLOCKED SPANNED RECORDS WITH
*                                     KEYS, RECORD OFFSET PROCESSING.
*                                     READ READS ONE RECORD SEGMENT
*                                     INTO THE RECORD AREA.  THE   0386
*                                     FIRST SEGMENT OF A RECORD IS 0386
*                                     PRECEDED IN THE RECORD AREA BY
*                                     THE KEY.  SUBSEQUENT SEGMENTS
*                                     ARE AT AN OFFSET EQUAL TO THE
*                                     KEY LENGTH.                    */
*        7 JFCEXC   BIT(1),        /* E - EXCHANGE BUFFERING         */
*        7 JFCDYN   BIT(1),        /* DYNAMIC BUFFERING              */
*        7 JFCHIER1 BIT(1),        /* HIERARCHY 1 MAIN STORAGE       */
*        7 JFCDWORD BIT(1),        /* D - DOUBLE WORD BOUNDARY       */
*        7 JFCFWORD BIT(1),        /* F - FULL WORD NOT A DOUBLE   0386
*                                     WORD BOUNDARY                  */
*    3 JFCBUFL  FIXED(15) BDY(WORD,3), /* BUFFER LENGTH              */
*   2 JFCEROPT BIT(8),             /* ERROR OPTION.  DISPOSITION OF
*                                     PERMANENT ERRORS IF USER     0386
*                                     RETURNS FROM A SYNCHRONOUS   0386
*                                     ERROR EXIT  (QSAM)             */
*    3 JFCACC   BIT(1),            /* ACCEPT                         */
*    3 JFCSKP   BIT(1),            /* SKIP                           */
*    3 JFCABN   BIT(1),            /* ABNORMAL END OF TASK           */
*    3 JFCTOPT  BIT(1),            /* ON-LINE TERMINAL TEST        0386
*                                     (BTAM)                   ICB349*/
*    3 JFCRSV02 BIT(1),            /* RESERVED                       */
*    3 JFCRSV03 BIT(1),            /* RESERVED                       */
*    3 JFCRSV04 BIT(1),            /* RESERVED                       */
*    3 JFCRSV05 BIT(1),            /* RESERVED                       */
*   2 JFCTRTCH CHAR(1) BDY(WORD,2);/* TAPE RECORDING TECHNIQUE     0386
*                                     FOR 7-TRACK TAPE               */
*                                                                  0386
*DECLARE                                                           0387
*  1 JFCKEYLE CHAR(1) DEF(JFCTRTCH) BDY(WORD,2),                   0387
*                                  /* DIRECT ACCESS KEY LENGTH       */
*   2 JFCCODE  BIT(8) BDY(BYTE),   /* CONVERSION CODE (PAPER TAPE)   */
*    3 JFCNOCON BIT(1),            /* N - NO CONVERSION              */
*    3 JFCBCD   BIT(1),            /* I - IBM BCD                    */
*    3 JFCFRI   BIT(1),            /* F - FRIDEN                     */
*    3 JFCBUR   BIT(1),            /* B - BURROUGHS                  */
*    3 JFCNCR   BIT(1),            /* C - NATIONAL CASH REGISTER     */
*    3 JFCASCII BIT(1),            /* A - ASCII (8-TRACK)            */
*    3 JFCTTY   BIT(1),            /* T - TELETYPE                   */
*    3 JFCRSV32 BIT(1);            /* RESERVED                       */
*                                                                  0387
*DECLARE                                                           0388
*  1 JFCSTACK BIT(8) DEF(JFCTRTCH) BDY(WORD,2),                    0388
*                                  /* STACKER SELECTION (CARD READER,
*                                     (CARD PUNCH)                   */
*   2 JFCMODE  BIT(8) BDY(WORD,2), /* MODE OF OPERATION (CARD READER,
*                                     (CARD PUNCH)             ICB394*/
*    3 JFCBIN   BIT(1),            /* C - COLUMN BINARY MODE         */
*    3 JFCEBCD  BIT(1),            /* E - EBCDIC MODE                */
*    3 JFCMODEO BIT(1),            /* O - OPTICAL MARK READ MODE   0388
*                                     (3505 ONLY)              ICB394*/
*    3 JFCMODER BIT(1),            /* R - READ COLUMN ELIMINATE MODE
*                                     (3505 AND 3525 WITH READ     0388
*                                     FEATURE)                 ICB394*/
*    3 JFCRSV06 BIT(1),            /* RESERVED                       */
*    3 JFCRSV07 BIT(1),            /* RESERVED                       */
*    3 JFCTWO   BIT(1),            /* 2 - STACKER TWO                */
*    3 JFCONE   BIT(1);            /* 1 - STACKER ONE                */
*                                                                  0388
*DECLARE                                                           0389
*  1 JFCSPPRT DEF(JFCTRTCH) BDY(WORD,2),                           0389
*   2 JFCPRTSP BIT(8) BDY(WORD,2), /* NORMAL PRINTER SPACING         */
*   2 JFCDEN   BIT(8),             /* TAPE DENSITY - 2400/3400 SERIES
*                                     MAGNETIC TAPE UNITS            */
*   2 JFCBABFS PTR(24) BDY(WORD,4),/* TOTAL BUFFER SIZE FOR ALL VSAM
*                                     BUFFERS                  ICB438*/
*    3 JFCLIMCT CHAR(3) BDY(WORD,4),/* SEARCH LIMIT (BDAM)           */
*     4 *        CHAR(1),          /* RESERVED                       */
*     4 JFCTRKBL CHAR(2) BDY(WORD),/* DATA SET OPENED FOR MOD - IF 0389
*                                     AUTOMATIC STEP RESTART WAS   0389
*                                     REQUESTED, TRACK BALANCE     0389
*                                     EXISTING WHEN THE DATA SET WAS
*                                     FIRST OPENED DURING THE      0389
*                                     ORIGINAL EXECUTION OF THE    0389
*                                     CURRENT STEP                   */
*   2 JFCDSORG BIT(16) BDY(WORD,3),/* DATA SET ORGANIZATION BEING  0389
*                                     USED                           */
*    3 JFCDSRG1 BIT(8),            /* BYTE 1 OF JFCDSORG             */
*     4 JFCORGIS BIT(1),           /* INDEXED SEQUENTIAL             */
*     4 JFCORGPS BIT(1),           /* PHYSICAL SEQUENTIAL            */
*     4 JFCORGDA BIT(1),           /* DIRECT                         */
*     4 JFCORGCX BIT(1),           /* BTAM OR QTAM LINE GROUP  MDC011*/
*     4 JFCORGCQ BIT(1),           /* QTAM DIRECT ACCESS MESSAGE   0389
*                                     QUEUE                    MDC012*/
*     4 JFCORGMQ BIT(1),           /* QTAM PROBLEM PROGRAM MESSAGE 0389
*                                     QUEUE                    MDC013*/
*     4 JFCORGPO BIT(1),           /* PARTITIONED                    */
*     4 JFCORGU  BIT(1),           /* UNMOVABLE - THE DATA CONTAINS
*                                     LOCATION DEPENDENT INFORMATION */
*    3 JFCDSRG2 BIT(8),            /* BYTE 2 OF JFCDSORG             */
*     4 JFCORGGS BIT(1),           /* GRAPHICS                       */
*     4 JFCORGTX BIT(1),           /* TCAM LINE GROUP          MDC014*/
*     4 JFCORGTQ BIT(1),           /* TCAM MESSAGE QUEUE       MDC015*/
*     4 JFCRSV13 BIT(1),           /* RESERVED, BINARY ZERO          */
*     4 JFCORGAM BIT(1),           /* VSAM                     ICB438*/
*     4 JFCORGTR BIT(1),           /* TCAM 3705                MDC016*/
*     4 JFCRSV15 BIT(1),           /* RESERVED, BINARY ZERO          */
*     4 JFCRSV16 BIT(1),           /* RESERVED, BINARY ZERO          */
*   2 JFCRECFM BIT(8) BDY(WORD),   /* RECORD FORMAT                  */
*    3 JFCRCFM  BIT(3),            /* RECORD FORMAT (USASI/USASCII)
*                                                              MDC023*/
*     4 JFCFMREC BIT(2),           /* BITS INDICATING RECORD FORMAT  */
*     4 JFCRFO   BIT(1),           /* T - TRACK OVERFLOW             */
*    3 JFCRFB   BIT(1),            /* B - BLOCKED - MAY NOT OCCUR  0389
*                                     WITH UNDEFINED                 */
*    3 JFCRFS   BIT(1),            /* S - FOR FIXED LENGTH RECORD  0389
*                                     FORMAT, STANDARD BLOCKS.  NO 0389
*                                     TRUNCATED BLOCKS OR UNFILLED 0389
*                                     TRACKS ARE EMBEDDED IN THE DATA
*                                     SET.                         0389
*                                     FOR VARIABLE LENGTH RECORD   0389
*                                     FORMAT, SPANNED RECORDS.       */
*    3 JFCCHAR  BIT(2),            /* CONTROL CHARACTER              */
*    3 *        BIT(1),            /* RESERVED                       */
*   2 JFCOPTCD BIT(8) BDY(WORD,2), /* OPTION CODES                   */
*    3 JFCWVCSP BIT(1),            /* QSAM-BSAM-BPAM - W - WRITE   0389
*                                     VALIDITY CHECK                 */
*     4 JFCWVCIS BIT(1),           /* BISAM-QISAM - W - WRITE      0389
*                                     VALIDITY CHECK                 */
*      5 JFCWVCBD BIT(1),          /* BDAM - W - WRITE VALIDITY    0389
*                                     CHECK                          */
*       6 JFCSDNAM BIT(1),         /* TCAM - SOURCE OR DESTINATION 0389
*                                     NAME PRECEDES MESSAGE (AFTER 0389
*                                     CONTROL BYTE)                  */
*    3 JFCALLOW BIT(1),            /* QSAM-BSAM-BPAM - U - ALLOW A 0389
*                                     DATA CHECK CAUSED BY AN      0389
*                                     INVALID CHARACTER (1403      0389
*                                     PRINTER WITH UCS FEATURE)      */
*     4 JFCRSV17 BIT(1),           /* RESERVED                       */
*      5 JFCOVER  BIT(1),          /* BDAM - TRACK OVERFLOW          */
*       6 JFCWUMSG BIT(1),         /* TCAM - WORK UNIT IS A MESSAGE
*                                     (DEFAULT WORK UNIT IS A RECORD)*/
*    3 JFCPCIBT BIT(1),            /* QSAM-BSAM-BPAM - C - CHAINED 0389
*                                     SCHEDULING USING THE PROGRAM 0389
*                                     CONTROLLED INTERRUPTION        */
*     4 JFCMAST  BIT(1),           /* BISAM-QISAM - M - MASTER     0389
*                                     INDEXES                        */
*      5 JFCEXT   BIT(1),          /* BDAM - E - EXTENDED SEARCH     */
*       6 JFCCBWU  BIT(1),         /* TCAM - CONTROL BYTE PRECEDES 0389
*                                     WORK UNIT                      */
*    3 JFCBCKPT BIT(1),            /* QSAM-BSAM-BPAM - BYPASS      0389
*                                     EMBEDDED DOS CHECKPOINT      0389
*                                     RECORDS ON TAPE         ICB398*/
*     4 JFCIND   BIT(1),           /* BISAM-QISAM - I - INDEPENDENT
*                                     OVERFLOW AREA                  */
*      5 JFCFEED  BIT(1),          /* BDAM - F - FEEDBACK            */
*    3 JFCRSV18 BIT(1),            /* RESERVED                       */
*     4 JFCCYL   BIT(1),           /* BISAM-QISAM - Y - CYLINDER   0389
*                                     OVERFLOW AREA                  */
*      5 JFCACT   BIT(1),          /* BDAM - A - ACTUAL ADRESSING    */
*       6 JFCOPTQ  BIT(1),         /* USASI/USASCII - EBCDIC TO ASCII
*                                     OR ASCII TO EBCDIC TRANSLATION
*                                     REQUIRED                       */
*    3 JFCREDUC BIT(1),            /* QSAM-BSAM-BPAM-EXCP - Z -    0389
*                                     USE REDUCED ERROR RECOVERY   0389
*                                     PROCEDURE (MAGNETIC TAPE)      */
*     4 JFCRSV19 BIT(1),           /* RESERVED                       */
*      5 JFCRSV20 BIT(1),          /* RESERVED                       */
*       6 JFCSRCHD BIT(1),         /* QSAM-BSAM-BPAM - USE SEARCH  0389
*                                     DIRECT (SD) INSTEAD OF SEARCH
*                                     PREVIOUS ON ROTATIONAL POSITION
*                                     SENSING (RPS) DEVICE.  (DIRECT
*                                     ACCESS)                        */
*    3 JFCRSV21 BIT(1),            /* RESERVED                       */
*     4 JFCDEL   BIT(1),           /* BISAM-QISAM - L - DELETE     0389
*                                     OPTION                         */
*      5 JFCRSV22 BIT(1),          /* RESERVED                       */
*    3 JFCOPTJ  BIT(1),            /* QSAM-BSAM-BPAM - J - 3800    0389
*                                     CONTROL CHARACTER            0389
*                                     (MDC301)               @Z40MP9A*/
*     4 JFCREORG BIT(1),           /* BISAM-QISAM - R -            0389
*                                     REORGANIZATION CRITERIA        */
*      5 JFCREL   BIT(1),          /* BDAM - R - RELATIVE BLOCK    0389
*                                     ADDRESSING                     */
*   2 JFCBLKSI FIXED(15) BDY(WORD,3), /* MAXIMUM BLOCK SIZE          */
*    3 JFCBUFSI FIXED(15) BDY(WORD,3), /* MAXIMUM BUFFER SIZE        */
*     4 JFCBAXBF FIXED(15) BDY(WORD,3), /* NUMBER OF INDEX BUFFERS 0389
*                                     (VSAM)                   ICB438*/
*   2 JFCAMSYN CHAR(8) BDY(WORD),  /* MODULE NAME FOR SYNAD ROUTINE
*                                     FOR VSAM                 ICB438*/
*    3 JFCLRECL FIXED(15) BDY(WORD), /* LOGICAL RECORD LENGTH        */
*    3 JFCNCP   CHAR(1) BDY(WORD,3), /* NUMBER OF CHANNEL PROGRAMS.
*                                     NUMBER OF READ OR WRITE      0389
*                                     REQUESTS WHICH MAY BE ISSUED 0389
*                                     PRIOR TO A CHECK.  NUMBER OF 0389
*                                     IOB'S GENERATED.  (MAXIMUM   0389
*                                     NUMBER IS 99.)               0389
*                                     NOTE - GAM USES JFCBFTEK FOR 0389
*                                     THIS INFORMATION AND DOES    0389
*                                     NOT USE THIS FIELD AT ALL.     */
*     4 JFCBUFMX CHAR(1),          /* THE MAXIMUM NUMBER OF BUFFERS
*                                     TO BE USED FOR DATA TRANSFER 0389
*                                     FOR EACH LINE IN THIS LINE   0389
*                                     GROUP  (TCAM)                  */
*    3 JFCNTM   CHAR(1) BDY(WORD,4), /* THE NUMBER OF TRACKS THAT  0389
*                                     DETERMINE THE DEVELOPMENT OF A
*                                     MASTER INDEX.  MAXIMUM NUMBER
*                                     IS 99.  (ISAM)                 */
*     4 JFCBFSEQ PTR(8),           /* TAPE POSITIONING INFORMATION 0389
*                                     FOR CHECKPOINT RESTART.  THIS
*                                     FIELD IS USED TO PASS A      0389
*                                     PHYSICAL FILE SEQUENCE COUNT 0389
*                                     FROM CHECKPOINT TO RESTART.  0389
*                                     THE COUNT TELLS THE PHYSICAL 0389
*                                     POSITION OF THE TAPE VOLUME  0389
*                                     THAT WAS BEING PROCESSED WHEN
*                                     THE CHECKPOINT WAS TAKEN.    0389
*                                                             SA60703*/
*      5 JFCPCI   BIT(8),          /* PROGRAM-CONTROLLED INTERRUPTION
*                                     (PCI) FLAG BYTE (TCAM)         */
*       6 JFCPCIX1 BIT(1),         /* PCI=(X,) RECEIVE OPERATIONS  0389
*                                                              ICB473*/
*       6 JFCPCIX2 BIT(1),         /* PCI=(,X) SEND OPERATIONS     0389
*                                     X INDICATES THAT AFTER THE   0389
*                                     FIRST BUFFER IS FILLED (ON   0389
*                                     RECEIVE OPERATIONS) OR EMPTIED
*                                     (ON SEND OPERATIONS), A PCI  0389
*                                     OCCURS DURING THE FILLING OR 0389
*                                     EMPTYING OF THE NEXT BUFFER. 0389
*                                     THE FIRST BUFFER REMAINS     0389
*                                     ALLOCATED AND ANOTHER IS     0389
*                                     ALLOCATED.               ICB473*/
*       6 JFCPCIA1 BIT(1),         /* PCI=(A,) RECEIVE OPERATIONS    */
*       6 JFCPCIA2 BIT(1),         /* PCI=(,A) SEND OPERATIONS     0389
*                                     A INDICATES THAT AFTER THE   0389
*                                     FIRST BUFFER IS FILLED (ON   0389
*                                     RECEIVE OPERATIONS) OR EMPTIED
*                                     (ON SEND OPERATIONS), A PCI  0389
*                                     OCCURS DURING THE FILLING OR 0389
*                                     EMPTYING OF THE NEXT BUFFER. 0389
*                                     THE FIRST BUFFER IS DEALLOCATED.
*                                     A BUFFER IS ALLOCATED IN PLACE
*                                     OF THE DEALLOCATED BUFFER.     */
*       6 JFCPCIN1 BIT(1),         /* PCI=(N,) RECEIVE OPERATIONS    */
*       6 JFCPCIN2 BIT(1),         /* PCI=(,N) SEND OPERATIONS     0389
*                                     N INDICATES THAT NO PCI'S ARE
*                                     TAKEN DURING FILLING (ON     0389
*                                     RECEIVE OPERATIONS) OR EMPTYING
*                                     (ON SEND OPERATIONS) OF BUFFERS.
*                                     BUFFERS ARE DEALLOCATED AT THE
*                                     END OF TRANSMISSION.           */
*       6 JFCPCIR1 BIT(1),         /* PCI=(R,) RECEIVE OPERATIONS    */
*       6 JFCPCIR2 BIT(1),         /* PCI=(,R) SEND OPERATIONS     0389
*                                     R INDICATES THAT AFTER THE   0389
*                                     FIRST BUFFER IS FILLED (ON   0389
*                                     RECEIVE OPERATIONS) OR EMPTIED
*                                     (ON SEND OPERATIONS), A PCI  0389
*                                     OCCURS DURING THE FILLING OR 0389
*                                     EMPTYING OF EACH SUCCEEDING  0389
*                                     BUFFER.  THE COMPLETED BUFFER
*                                     IS DEALLOCATED, BUT NO NEW   0389
*                                     BUFFER IS ALLOCATED TO TAKE  0389
*                                     ITS PLACE.                     */
*                                                                  0389
* /*******************************************************************/
* /*                                                                 */
* /*                     NORMAL 108 SEGMENT                          */
* /*                                                                 */
* /*******************************************************************/
*                                                                  0389
*    3 JFCRESRV CHAR(4) BDY(WORD), /* FIRST BYTE CONTAINS NUMBER OF
*                                     BYTES FOR TIME OF DAY.  SECOND
*                                     BYTE CONTAINS NUMBER OF BYTES
*                                     FOR DATE.  THIRD BYTE CONTAINS
*                                     NUMBER OF BYTES FOR OUTSEQ.  0389
*                                     FOURTH BYTE CONTAINS NUMBER OF
*                                     BYTES IN.  (TCAM)              */
*     4 JFCRKP   FIXED(15) BDY(WORD), /* THE RELATIVE POSITION OF THE
*                                     FIRST BYTE OF THE KEY WITHIN 0389
*                                     EACH LOGICAL RECORD.  MAXIMUM
*                                     VALUE IS LOGICAL RECORD LENGTH
*                                     MINUS KEY LENGTH.              */
*     4 JFCCYLOF CHAR(1),          /* THE NUMBER OF TRACKS TO BE   0389
*                                     RESERVED ON EACH CYLINDER TO 0389
*                                     HOLD RECORDS THAT OVERFLOW   0389
*                                     FROM OTHER TRACKS ON THAT    0389
*                                     CYLINDER.  MAXIMUM VALUE IS  0389
*                                     99.                            */
*     4 JFCDBUFN CHAR(1),          /* RESERVED                       */
*   2 JFCINTVL CHAR(1) BDY(WORD);  /* INTENTIONAL DELAY, IN SECONDS,
*                                     BETWEEN PASSES THROUGH A     0389
*                                     POLLING LIST (QTAM)            */
*                                                                  0389
* /*******************************************************************/
* /*                                                                 */
* /*                     END OF NORMAL 108 SEGMENT                   */
* /*                                                                 */
* /*******************************************************************/
*                                                                  0390
* /*******************************************************************/
* /*                                                                 */
* /*                     108 PRINTER SEGMENT                         */
* /*                                                                 */
* /*     NOTE  THIS SEGMENT REPLACES THE NORMAL 108 SEGMENT IF       */
* /*           THE DD STATEMENT USES THE UCS PARAMETER.              */
* /*                                                                 */
* /*******************************************************************/
*                                                                  0390
*DECLARE                                                           0390
*  1 JFCUCSEG DEF(JFCRESRV) BDY(WORD),                             0390
*   2 JFCUCSID CHAR(4) BDY(WORD),  /* NAME OF THE UCS IMAGE TO BE  0390
*                                     LOADED                         */
*   2 JFCUCSOP BIT(8),             /* OPERATION OF THE UCS IMAGE TO
*                                     BE LOADED                      */
*    3 JFCBEXTP BIT(1),            /* JFCB EXTENSION PRESENT FOR 3800
*                                     DEVICE  (MDC302)       @Z40MP9A*/
*    3 JFCFOLD  BIT(1),            /* UCS IMAGE IS TO BE LOADED IN 0390
*                                     THE FOLD MODE                  */
*    3 JFCRSV25 BIT(1),            /* RESERVED                       */
*    3 JFCVER   BIT(1),            /* UCS IMAGE IS TO BE VERIFIED    */
*    3 JFCFCBAL BIT(1),            /* FORMS ARE TO BE ALIGNED        */
*    3 JFCFCBVR BIT(1),            /* FORMS CONTROL BUFFER (FCB)   0390
*                                     IMAGE IS TO BE VERIFIED        */
*    3 JFCRSV26 BIT(1),            /* RESERVED                       */
*    3 JFCRSV27 BIT(1),            /* RESERVED                       */
*                                                                  0390
* /*******************************************************************/
* /*                                                                 */
* /*                     END OF 108 PRINTER SEGMENT                  */
* /*                                                                 */
* /*******************************************************************/
*                                                                  0390
*   2 JFCOUTLI PTR(24) BDY(WORD,2),/* SMF - SYSOUT LIMIT.  BINARY  0390
*                                     REPRESENTATION OF THE OUTLIM=
*                                     PARAMETER ON THE SYSOUT DD   0390
*                                     STATEMENT.  THE MAXIMUM NUMBER
*                                     OF LOGICAL RECORDS SPECIFIED 0390
*                                     FOR THIS OUTPUT DATA SET.      */
*    3 JFCTHRSH CHAR(1),           /* RECORDS TO BE USED             */
*     4 JFCCPRI  BIT(8),           /* PRIORITY BETWEEN SEND AND    0390
*                                     RECEIVE OPERATIONS (TCAM)      */
*      5 JFCRSV53 BIT(1),          /* RESERVED                 MDC020*/
*      5 JFCRSV54 BIT(1),          /* RESERVED                 MDC019*/
*      5 JFCRSV55 BIT(1),          /* RESERVED                 MDC018*/
*      5 JFCRSV33 BIT(1),          /* RESERVED                       */
*      5 JFCRSV34 BIT(1),          /* RESERVED                       */
*      5 JFCRECV  BIT(1),          /* RECEIVE PRIORITY         MDC018*/
*      5 JFCEQUAL BIT(1),          /* EQUAL PRIORITY           MDC019*/
*      5 JFCSEND  BIT(1),          /* SEND PRIORITY            MDC020*/
*    3 JFCSOWA  FIXED(15),         /* LENGTH, IN BYTES, OF THE USER-
*                                     PROVIDED WORK AREA (QTAM)      */
*   2 JFCBNTCS CHAR(1),            /* NUMBER OF OVERFLOW TRACKS      */
*   2 JFCBNVOL CHAR(1),            /* NUMBER OF VOLUME SERIAL NUMBERS*/
*   2 JFCBVOLS CHAR(30) BDY(WORD,3),/* THE FIRST FIVE VOLUME SERIAL
*                                     NUMBERS                        */
*    3 JFCAVOLS (5) CHAR(6);       /* THE FIRST FIVE VOLUME SERIAL 0390
*                                     NUMBERS                @Z30LP9A*/
*                                                                  0390
*DECLARE                                                           0391
*  1 JFCBS001 DEF(JFCBVOLS) BDY(WORD,3), /*                  @Z30LP9A*/
*   2 *        CHAR(22),           /* FIRST 22 BYTES OF            0391
*                                     JFCBVOLS               @Z30LP9A*/
*   2 JFCMSVGP CHAR(8) BDY(WORD),  /* MASS STORAGE VOLUME GROUP FROM
*                                     WHICH TO SELECT A VOLUME     0391
*                                     (MDC306)               @Z30LP9A*/
*   2 JFCBEXTL CHAR(1),            /* LENGTH OF BLOCK OF EXTRA VOLUME
*                                     SERIAL NUMBERS (BEYOND FIVE)   */
*   2 JFCBEXAD CHAR(3),            /* RELATIVE TRACK ADDRESS (TTR) 0391
*                                     OF FIRST JFCB EXTENSION BLOCK
*                                     FOR VOLUME SERIAL NUMBERS OR 0391
*                                     TTR OF JFCB EXTENSION BLOCK  0391
*                                     FOR 3800  (MDC303)     @Z40MP9A*/
*   2 JFCBPQTY CHAR(3) BDY(WORD),  /* PRIMARY QUANTITY OF DIRECT   0391
*                                     ACCESS STORAGE REQUIRED        */
*    3 JFCRUNIT CHAR(3),           /* UNIT TYPE (EBCDIC) OF A DEVICE
*                                     AT A REMOTE TERMINAL.  THE   0391
*                                     FIRST TWO CHARACTERS ARE RD  0391
*                                     (READER), PR (PRINTER) OR PU 0391
*                                     (PUNCH).  THE THIRD CHARACTER
*                                     IS A NUMBER FROM 1 TO 9. ICB387*/
*   2 JFCBCTRI BIT(8),             /* SPACE PARAMETERS               */
*    3 JFCBSPAC BIT(2),            /* SPACE MASK BITS                */
*    3 JFCBMSGP BIT(1),            /* REQUEST IS FOR A MASS STORAGE
*                                     VOLUME GROUP (MSVGP) VOLUME  0391
*                                     (MDC307)               @Z30LP9A*/
*    3 JFCRSV29 BIT(1),            /* RESERVED                       */
*    3 JFCONTIG BIT(1),            /* CONTIG REQUEST                 */
*    3 JFCMIXG  BIT(1),            /* MXIG REQUEST                   */
*    3 JFCALX   BIT(1),            /* ALX REQUEST                    */
*    3 JFCROUND BIT(1),            /* ROUND REQUEST                  */
*   2 JFCBSQTY CHAR(3) BDY(WORD),  /* SECONDARY QUANTITY OF DIRECT 0391
*                                     ACCESS STORAGE REQUIRED        */
*    3 JFCRQID  FIXED(15),         /* QUEUE IDENTIFICATION (QID) USED
*                                     BY ACCESS METHOD TO DETERMINE
*                                     THE REMOTE TERMINAL LOCATION 0391
*                                     FOR THIS JOB.            ICB387*/
*   2 JFCFLGS1 BIT(8),             /* FLAG BYTE (ICB488)      SA53458*/
*    3 JFCBDLET BIT(1),            /* IF ONE, DELETE THE DATA SET  0391
*                                     USED WHEN EXTENDING THE JOB  0391
*                                     QUEUE OR SPOOL DATA SETS     0391
*                                     (OS/VS1)  (MDC305)     @XM05457*/
*    3 JFCTOPEN BIT(1),            /* TAPE DATA SET HAS BEEN OPENED
*                                                              MDC026*/
*    3 JFCBADSP BIT(1),            /* AUTOMATIC DATA SET PROTECTION
*                                     INDICATOR  (MDC310)    @Z40RP9A*/
*    3 JFCRSV42 BIT(1),            /* RESERVED  (MDC311)             */
*    3 JFCBCEOV BIT(1),            /* IF ONE, CHKPT=EOV SPECIFIED FOR
*                                     THIS DATA SET (MDC312) @Z30JP9A*/
*    3 JFCVRDS  BIT(1),            /* VIO DATA SET             MDC006*/
*    3 JFCRSV45 BIT(1),            /* RESERVED                       */
*    3 JFCBUAFF BIT(1),            /* UNIT AFFINITY SPECIFIED FOR  0391
*                                     THIS DATA SET (ICB488)  SA53458*/
*   2 JFCBDQTY CHAR(3) BDY(WORD),  /* QUANTITY OF DIRECT ACCESS    0391
*                                     STORAGE REQUIRED FOR A       0391
*                                     DIRECTORY OR AN EMBEDDED INDEX
*                                     AREA                           */
*   2 JFCBSPNM PTR(24) BDY(WORD,4),/* MAIN STORAGE ADDRESS OF THE  0391
*                                     JFCB WITH WHICH CYLINDERS ARE
*                                     SPLIT                          */
*   2 JFCBABST FIXED(15),          /* RELATIVE ADDRESS OF FIRST TRACK
*                                     TO BE ALLOCATED                */
*   2 JFCBSBNM PTR(24) BDY(WORD),  /* MAIN STORAGE ADDRESS OF THE  0391
*                                     JFCB FROM WHICH SPACE IS TO  0391
*                                     BE SUBALLOCATED                */
*   2 JFCBDRLH CHAR(3) BDY(WORD,4),/* AVERAGE DATA BLOCK LENGTH      */
*   2 JFCBVLCT CHAR(1),            /* VOLUME COUNT                   */
*   2 JFCBSPTN CHAR(1),            /* NUMBER OF TRACKS PER CYLINDER
*                                     TO BE USED BY THIS DATA SET  0391
*                                     WHEN SPLIT CYLINDER IS       0391
*                                     INDICATED                      */
*   2 JFCBEND  CHAR(0) BDY(WORD);                                  0391
*        GEN(EJECT);                                               0392
*                                                                  0392
         EJECT
*        DCL 1 TABLE1 LOCAL BDY(WORD),      /* HIGH ORDER KEY TABLE */
*              2 * BIT(8)    INIT ('10'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('BUFSP='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('03'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCBABFS) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT ('80000000'X), /*BUFSP IS DUP     */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE BUFSP ENTRY IN THE TABLE             */
*                                                                  0393
*              2 * BIT(8)    INIT ('10'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('BUFND='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('02'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8)    INIT (ADDR(JFCBADBF) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('40000000'X), /* BUFND IS DUP     */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE BUFND ENTRY IN THE TABLE             */
*                                                                  0393
*              2 * BIT(8)    INIT ('10'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('BUFNI='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('02'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCBAXBF) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('20000000'X), /* BUFNI IS DUP     */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE BUFNI ENTRY IN THE TABLE             */
*                                                                  0393
*              2 * BIT(8)    INIT ('10'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('STRNO='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('02'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8)    INIT (ADDR(JFCAMSTR) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('10000000'X), /* STRNO IS DUP     */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE STRNO ENTRY IN THE TABLE             */
*                                                                  0393
*              2 * BIT(8)    INIT ('20'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('SYNAD='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('08'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCAMSYN) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('08000000'X), /* SYNAD IS DUP     */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE SYNAD ENTRY IN THE TABLE      @Y30LSPS*/
*                                                                  0393
*              2 * BIT(8)    INIT ('80'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('CROPS='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('00'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8)    INIT (ADDR(JFCAMCRO) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('04000000'X), /* CROPS IS DUP     */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT(ADDR(TABLE2)),/*CHAIN IF SUB KEYS*/
*        /* THIS CONCLUDES THE CROPS ENTRY IN THE TABLE             */
*                                                                  0393
*              2 * BIT(8)    INIT ('80'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('RECFM='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('00'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCRECFM) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('02000000'X), /* RECFM IS DUP     */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT(ADDR(TABLE3)),/*CHAIN IF SUB KEYS*/
*        /* THIS CONCLUDES THE RECFM ENTRY IN THE TABLE              */
*                                                                  0393
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('AMORG'),/* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('00'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCDSRG2) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('01000000'X), /* AMORG IS DUP     */
*              2 * BIT(8)    INIT('80'X),   /* VSAM DSORG ONLY      */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* NO SUB KEYS          */
*        /* THIS CONCLUDES THE AMORG ENTRY IN THE TABLE             */
*                                                                  0393
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('TRACE'),/* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('04'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCBFLG2) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00800000'X), /* TRACE IS DUPLICAT*/
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* NO SUB KEYS          */
*        /* THIS CONCLUDES THE TRACE ENTRY IN THE TABLE             */
*                                                                  0393
*              2 * BIT(8)    INIT ('80'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('OPTCD='),/* THIS KEYWORD        */
*              2 * BIT(8)    INIT ('00'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCOPTCD) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00400000'X), /*OPTCD IS DUP      */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT(ADDR(TABLE4)),/*CHAIN IF SUB KEYS*/
*        /* THIS CONCLUDES THE OPTCD ENTRY IN THE TABLE              */
*                                                                  0393
*              2 * BIT(8)    INIT ('FF'X);  /* TABLE TERMINATOR     */
*                                                                  0393
*        DCL 1 TABLE2  LOCAL BDY(WORD),     /* CROPS KEY TABLE      */
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('RCK'),  /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('80'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8)    INIT (ADDR(JFCAMCRO) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE CROPS=RCK ENTRY IN THE TABLE         */
*                                                                  0394
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('NCK'),  /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('40'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8)    INIT (ADDR(JFCAMCRO) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE CROPS=NCK ENTRY IN THE TABLE         */
*                                                                  0394
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('NRE'),  /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('20'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8)    INIT (ADDR(JFCAMCRO) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE CROPS=NRE ENTRY IN THE TABLE         */
*                                                                  0394
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('NRC'),  /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('10'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8)    INIT (ADDR(JFCAMCRO) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE CROPS=NRC ENTRY IN THE TABLE         */
*                                                                  0394
*              2 * BIT(8)    INIT ('FF'X);  /* TABLE TERMINATOR     */
*                                                                  0394
*        DCL 1 TABLE3  LOCAL BDY(WORD),     /* CROPS KEY TABLE      */
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('V'),    /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('40'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCRECFM) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE RECFM=V ENTRY IN THE TABLE           */
*                                                                  0395
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('VB'),   /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('50'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCRECFM) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE RECFM=VB ENTRY IN THE TABLE          */
*                                                                  0395
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('F'),    /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('80'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCRECFM) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE RECFM=F ENTRY IN THE TABLE           */
*                                                                  0395
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('FB'),   /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('90'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCRECFM) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE RECFM=FB ENTRY IN THE TABLE          */
*                                                                  0395
*              2 * BIT(8)    INIT ('FF'X);  /* TABLE TERMINATOR     */
*                                                                  0395
*        DCL 1 TABLE4  LOCAL BDY(WORD),     /* OPTCD KEY TABLE      */
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('I'),    /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('10'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCOPTCD) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE OPTCD=I ENTRY IN THE TABLE           */
*                                                                  0396
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('L'),    /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('02'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCOPTCD) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE OPTCD=L ENTRY IN THE TABLE           */
*                                                                  0396
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('IL'),   /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('12'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCOPTCD) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE OPTCD=IL ENTRY IN THE TABLE          */
*                                                                  0396
*              2 * BIT(8)    INIT ('40'X),  /* KEY TYPE FLAGS       */
*              2 * CHAR(9)   INIT ('LI'),   /* THIS KEYWORD         */
*              2 * BIT(8)    INIT ('12'X),  /* OR MASK OR LENGTH    */
*              2 * PTR(8) INIT (ADDR(JFCOPTCD) - ADDR(INFMJFCB)+1),
*              2 * BIT(32)   INIT('00000000'X), /* NO DUPS OR BITS  */
*              2 * BIT(8)    INIT ('FF'X),  /* ALLOW ALL DSORGS     */
*              2 *           BIT(24),       /* RESERVED FOR EXPANS  */
*              2 * PTR(31)   INIT (0),      /* CHAIN IF SUB KEYS    */
*        /* THIS CONCLUDES THE OPTCD=LI ENTRY IN THE TABLE          */
*                                                                  0396
*              2 * BIT(8)    INIT ('FF'X);  /* TABLE TERMINATOR     */
*                                                                  0396
*        GEN;                               /* BUILD A GETMAIN LIST */
GETDATA  GETMAIN   EC,LV=88,MF=L
*        DCL GETDATA LABEL GENERATED;                              0398
*        DCL GETMAIN2 CHAR(12) BASED(ADDR(GETDATA)); /* CHARS OF LIST*/
*                                                                  0399
*    END IEFNB902                           /* THE FINAL END OF IT  */
*/* THE FOLLOWING INCLUDE STATEMENTS WERE FOUND IN THIS PROGRAM.      *
*/*%INCLUDE SYSLIB  (IEFJFCBN)                                        *
*;                                                                 0400
@EL00001 DS    0H                                                  0400
@EF00001 DS    0H                                                  0400
@ER00001 LM    @14,@12,12(@13)                                     0400
         BR    @14                                                 0400
@DATA    DS    0H
@CH00737 DC    H'88'
@SM00739 MVC   JFCB(0,@09),KEYBUF8(DATAPTR)
@SM00744 MVC   JFCB(0,@09),DOUBLE4(@15)
@DATD    DSECT
         DS    0F
IEFNB902 CSECT
         DS    0F
@CF00045 DC    F'1'
@CF00104 DC    F'2'
@CF00109 DC    F'3'
@CF00083 DC    F'4'
@CF00168 DC    F'5'
@CF00162 DC    F'8'
@CF00210 DC    F'24'
@CF00167 DC    F'32767'
@CF00166 DC    F'8388607'
@DATD    DSECT
         DS    0D
         ORG   *+1-(*-@DATD)/(*-@DATD) INSURE DSECT DATA
@ENDDATD EQU   *
IEFNB902 CSECT
         DS    0F
@SIZDATD DC    AL1(0)
         DC    AL3(@ENDDATD-@DATD)
         DS    0D
@CB00127 DC    X'00000000'
TABLE1   DS    CL241
         ORG   TABLE1
@NM00009 DC    X'10'
@NM00010 DC    CL9'BUFSP='
@NM00011 DC    X'03'
@NM00012 DC    AL1(JFCBABFS-INFMJFCB+1)
@NM00013 DC    X'80000000'
@NM00014 DC    X'FF'
@NM00015 DS    BL3
@NM00016 DC    A(0)
@NM00017 DC    X'10'
@NM00018 DC    CL9'BUFND='
@NM00019 DC    X'02'
@NM00020 DC    AL1(JFCBADBF-INFMJFCB+1)
@NM00021 DC    X'40000000'
@NM00022 DC    X'FF'
@NM00023 DS    BL3
@NM00024 DC    A(0)
@NM00025 DC    X'10'
@NM00026 DC    CL9'BUFNI='
@NM00027 DC    X'02'
@NM00028 DC    AL1(JFCBAXBF-INFMJFCB+1)
@NM00029 DC    X'20000000'
@NM00030 DC    X'FF'
@NM00031 DS    BL3
@NM00032 DC    A(0)
@NM00033 DC    X'10'
@NM00034 DC    CL9'STRNO='
@NM00035 DC    X'02'
@NM00036 DC    AL1(JFCAMSTR-INFMJFCB+1)
@NM00037 DC    X'10000000'
@NM00038 DC    X'FF'
@NM00039 DS    BL3
@NM00040 DC    A(0)
@NM00041 DC    X'20'
@NM00042 DC    CL9'SYNAD='
@NM00043 DC    X'08'
@NM00044 DC    AL1(JFCAMSYN-INFMJFCB+1)
@NM00045 DC    X'08000000'
@NM00046 DC    X'FF'
@NM00047 DS    BL3
@NM00048 DC    A(0)
@NM00049 DC    X'80'
@NM00050 DC    CL9'CROPS='
@NM00051 DC    X'00'
@NM00052 DC    AL1(JFCAMCRO-INFMJFCB+1)
@NM00053 DC    X'04000000'
@NM00054 DC    X'FF'
@NM00055 DS    BL3
@NM00056 DC    AL4(TABLE2)
@NM00057 DC    X'80'
@NM00058 DC    CL9'RECFM='
@NM00059 DC    X'00'
@NM00060 DC    AL1(JFCRECFM-INFMJFCB+1)
@NM00061 DC    X'02000000'
@NM00062 DC    X'FF'
@NM00063 DS    BL3
@NM00064 DC    AL4(TABLE3)
@NM00065 DC    X'40'
@NM00066 DC    CL9'AMORG'
@NM00067 DC    X'00'
@NM00068 DC    AL1(JFCDSRG2-INFMJFCB+1)
@NM00069 DC    X'01000000'
@NM00070 DC    X'80'
@NM00071 DS    BL3
@NM00072 DC    A(0)
@NM00073 DC    X'40'
@NM00074 DC    CL9'TRACE'
@NM00075 DC    X'04'
@NM00076 DC    AL1(JFCBFLG2-INFMJFCB+1)
@NM00077 DC    X'00800000'
@NM00078 DC    X'FF'
@NM00079 DS    BL3
@NM00080 DC    A(0)
@NM00081 DC    X'80'
@NM00082 DC    CL9'OPTCD='
@NM00083 DC    X'00'
@NM00084 DC    AL1(JFCOPTCD-INFMJFCB+1)
@NM00085 DC    X'00400000'
@NM00086 DC    X'FF'
@NM00087 DS    BL3
@NM00088 DC    AL4(TABLE4)
@NM00089 DC    X'FF'
         ORG   TABLE1+241
MSGP1    DC    CL21'IEFXXXI AMP KEYWORD '
MSGP9    DC    CL19' STEP NOT EXECUTED '
MSGNBR1  DC    CL7'IEF447I'
MSGMDL1  DC    CL31' IS INVALID '
MSGNBR2  DC    CL7'IEF448I'
MSGMDL2  DC    CL31' VALUE            IS TOO LARGE '
MSGNBR3  DC    CL7'IEF449I'
MSGMDL3  DC    CL31' REQUIRES A DECIMAL VALUE '
MSGNBR4  DC    CL7'IEF175I'
MSGMDL4  DC    CL31'DUPLICATE OR CONFLICTING PARM'
         DS    CL3
TABLE2   DS    CL97
         ORG   TABLE2
@NM00090 DC    X'40'
@NM00091 DC    CL9'RCK'
@NM00092 DC    X'80'
@NM00093 DC    AL1(JFCAMCRO-INFMJFCB+1)
@NM00094 DC    X'00000000'
@NM00095 DC    X'FF'
@NM00096 DS    BL3
@NM00097 DC    A(0)
@NM00098 DC    X'40'
@NM00099 DC    CL9'NCK'
@NM00100 DC    X'40'
@NM00101 DC    AL1(JFCAMCRO-INFMJFCB+1)
@NM00102 DC    X'00000000'
@NM00103 DC    X'FF'
@NM00104 DS    BL3
@NM00105 DC    A(0)
@NM00106 DC    X'40'
@NM00107 DC    CL9'NRE'
@NM00108 DC    X'20'
@NM00109 DC    AL1(JFCAMCRO-INFMJFCB+1)
@NM00110 DC    X'00000000'
@NM00111 DC    X'FF'
@NM00112 DS    BL3
@NM00113 DC    A(0)
@NM00114 DC    X'40'
@NM00115 DC    CL9'NRC'
@NM00116 DC    X'10'
@NM00117 DC    AL1(JFCAMCRO-INFMJFCB+1)
@NM00118 DC    X'00000000'
@NM00119 DC    X'FF'
@NM00120 DS    BL3
@NM00121 DC    A(0)
@NM00122 DC    X'FF'
         ORG   TABLE2+97
         DS    CL3
TABLE3   DS    CL97
         ORG   TABLE3
@NM00123 DC    X'40'
@NM00124 DC    CL9'V'
@NM00125 DC    X'40'
@NM00126 DC    AL1(JFCRECFM-INFMJFCB+1)
@NM00127 DC    X'00000000'
@NM00128 DC    X'FF'
@NM00129 DS    BL3
@NM00130 DC    A(0)
@NM00131 DC    X'40'
@NM00132 DC    CL9'VB'
@NM00133 DC    X'50'
@NM00134 DC    AL1(JFCRECFM-INFMJFCB+1)
@NM00135 DC    X'00000000'
@NM00136 DC    X'FF'
@NM00137 DS    BL3
@NM00138 DC    A(0)
@NM00139 DC    X'40'
@NM00140 DC    CL9'F'
@NM00141 DC    X'80'
@NM00142 DC    AL1(JFCRECFM-INFMJFCB+1)
@NM00143 DC    X'00000000'
@NM00144 DC    X'FF'
@NM00145 DS    BL3
@NM00146 DC    A(0)
@NM00147 DC    X'40'
@NM00148 DC    CL9'FB'
@NM00149 DC    X'90'
@NM00150 DC    AL1(JFCRECFM-INFMJFCB+1)
@NM00151 DC    X'00000000'
@NM00152 DC    X'FF'
@NM00153 DS    BL3
@NM00154 DC    A(0)
@NM00155 DC    X'FF'
         ORG   TABLE3+97
         DS    CL3
TABLE4   DS    CL97
         ORG   TABLE4
@NM00156 DC    X'40'
@NM00157 DC    CL9'I'
@NM00158 DC    X'10'
@NM00159 DC    AL1(JFCOPTCD-INFMJFCB+1)
@NM00160 DC    X'00000000'
@NM00161 DC    X'FF'
@NM00162 DS    BL3
@NM00163 DC    A(0)
@NM00164 DC    X'40'
@NM00165 DC    CL9'L'
@NM00166 DC    X'02'
@NM00167 DC    AL1(JFCOPTCD-INFMJFCB+1)
@NM00168 DC    X'00000000'
@NM00169 DC    X'FF'
@NM00170 DS    BL3
@NM00171 DC    A(0)
@NM00172 DC    X'40'
@NM00173 DC    CL9'IL'
@NM00174 DC    X'12'
@NM00175 DC    AL1(JFCOPTCD-INFMJFCB+1)
@NM00176 DC    X'00000000'
@NM00177 DC    X'FF'
@NM00178 DS    BL3
@NM00179 DC    A(0)
@NM00180 DC    X'40'
@NM00181 DC    CL9'LI'
@NM00182 DC    X'12'
@NM00183 DC    AL1(JFCOPTCD-INFMJFCB+1)
@NM00184 DC    X'00000000'
@NM00185 DC    X'FF'
@NM00186 DS    BL3
@NM00187 DC    A(0)
@NM00188 DC    X'FF'
         ORG   TABLE4+97
@00      EQU   00                      EQUATES FOR REGISTERS 0-15
@01      EQU   01
@02      EQU   02
@03      EQU   03
@04      EQU   04
@05      EQU   05
@06      EQU   06
@07      EQU   07
@08      EQU   08
@09      EQU   09
@10      EQU   10
@11      EQU   11
@12      EQU   12
@13      EQU   13
@14      EQU   14
@15      EQU   15
REG15    EQU   @15
STRINGPT EQU   @06
LENGST   EQU   @04
ENTRYPTR EQU   @07
JFCBREG  EQU   @08
WORKREG  EQU   @02
REG1     EQU   @01
PARMPTR  EQU   @03
REG14    EQU   @14
DATAPTR  EQU   @05
REG13    EQU   @13
JFCB     EQU   0
INFMJFCB EQU   0
JFCBDSNM EQU   INFMJFCB
JFCBELNM EQU   INFMJFCB+44
JFCBTSDM EQU   INFMJFCB+52
JFCFCBID EQU   INFMJFCB+56
JFCBFRID EQU   JFCFCBID
JFCAMCRO EQU   JFCBFRID
JFCAMSTR EQU   JFCBFRID+2
JFCBADBF EQU   INFMJFCB+60
JFCBLTYP EQU   INFMJFCB+66
JFCBOTTR EQU   INFMJFCB+67
JFCBUFOF EQU   JFCBOTTR
JFCBFLSQ EQU   JFCBOTTR+1
JFCFUNC  EQU   JFCBFLSQ
JFCBMASK EQU   INFMJFCB+72
JFCBFLG1 EQU   JFCBMASK+5
JFCOPEN  EQU   JFCBFLG1
JFCBFLG2 EQU   JFCBMASK+6
JFCDEFER EQU   JFCBFLG2
JFCBIND1 EQU   INFMJFCB+86
JFCBIND2 EQU   INFMJFCB+87
JFCAMPTR EQU   INFMJFCB+88
JFCBUFRQ EQU   JFCAMPTR
JFCBUFNO EQU   JFCBUFRQ
JFCBGNCP EQU   JFCAMPTR+1
JFCBHIAR EQU   JFCBGNCP
JFCBFALN EQU   JFCBHIAR
JFCBFTEK EQU   JFCBFALN
JFCBBFTA EQU   JFCBFTEK
JFCEROPT EQU   INFMJFCB+92
JFCTRTCH EQU   INFMJFCB+93
DATAREA  EQU   0
DOUBLE   EQU   DATAREA
DOUBLE4  EQU   DOUBLE
GETLIST  EQU   DATAREA+8
MAXPOS   EQU   GETLIST
TEMPSAVE EQU   DATAREA+20
ZEROINIT EQU   DATAREA+24
RETURNS  EQU   ZEROINIT
MSGCODE  EQU   ZEROINIT+4
RETCODE  EQU   ZEROINIT+8
PARENCNT EQU   DATAREA+36
ENTSAVE  EQU   DATAREA+40
LINKSAV1 EQU   DATAREA+44
LINKSAV2 EQU   DATAREA+48
LINKSAV3 EQU   DATAREA+52
LINKSAV4 EQU   DATAREA+56
NUMBER   EQU   DATAREA+60
KEYBUFER EQU   DATAREA+64
KEYBUF8  EQU   KEYBUFER
KEYBUF   EQU   KEYBUF8
ERRBITS  EQU   DATAREA+73
FINDERR  EQU   ERRBITS
TEMPFLD  EQU   DATAREA+74
TEMPFLD2 EQU   TEMPFLD
DUPBITS  EQU   DATAREA+78
COMPAT   EQU   DATAREA+82
MESSAGE  EQU   0
MSGLEN   EQU   MESSAGE
MSGZERO  EQU   MESSAGE+2
MSGCHAIN EQU   MESSAGE+4
MSGBUF   EQU   MESSAGE+8
MSGPREF  EQU   MSGBUF
MSGNBR   EQU   MSGPREF
MSGWORD  EQU   MSGBUF+21
MSGMDLE  EQU   MSGBUF+30
MSGVAL   EQU   MSGMDLE+7
MSGNOTE  EQU   MSGBUF+61
TENTRY   EQU   0
FLAGS1   EQU   TENTRY
SUBWORDS EQU   FLAGS1
ORMASK   EQU   FLAGS1
MOVECHAR EQU   FLAGS1
CONVERT  EQU   FLAGS1
POSITKEY EQU   FLAGS1
SAMENTRY EQU   FLAGS1
OVERFLOW EQU   FLAGS1
ANDIT    EQU   FLAGS1
KEYWORD  EQU   TENTRY+1
BYTEMASK EQU   TENTRY+10
SIZE     EQU   BYTEMASK
JFCBDISP EQU   TENTRY+11
CONFLICT EQU   TENTRY+12
DSORGS   EQU   TENTRY+16
ENTCHAIN EQU   TENTRY+20
LISTPTR  EQU   0
GETMAIN2 EQU   0
RETURNED EQU   0
PARMLIST EQU   0
STRINGS  EQU   PARMLIST
JFCBPTR  EQU   PARMLIST+4
TEMPLIST EQU   PARMLIST+8
OVERPTR  EQU   TEMPLIST+4
JFCBOFST EQU   TEMPLIST+8
SUBPONL  EQU   PARMLIST+23
DSTRING  EQU   0
PARMLENG EQU   DSTRING
STRING   EQU   DSTRING+2
JFCBEXT  EQU   0
JFCBCHAN EQU   JFCBEXT
OVERFULL EQU   JFCBEXT+4
JFCKEYLE EQU   JFCTRTCH
JFCCODE  EQU   JFCKEYLE
JFCSTACK EQU   JFCTRTCH
JFCMODE  EQU   JFCSTACK
JFCSPPRT EQU   JFCTRTCH
JFCBABFS EQU   JFCSPPRT+2
JFCLIMCT EQU   JFCBABFS
JFCDSORG EQU   JFCSPPRT+5
JFCDSRG1 EQU   JFCDSORG
JFCDSRG2 EQU   JFCDSORG+1
JFCORGAM EQU   JFCDSRG2
JFCRECFM EQU   JFCSPPRT+7
JFCRCFM  EQU   JFCRECFM
JFCOPTCD EQU   JFCSPPRT+8
JFCWVCSP EQU   JFCOPTCD
JFCWVCIS EQU   JFCWVCSP
JFCWVCBD EQU   JFCWVCIS
JFCALLOW EQU   JFCOPTCD
JFCRSV17 EQU   JFCALLOW
JFCOVER  EQU   JFCRSV17
JFCPCIBT EQU   JFCOPTCD
JFCMAST  EQU   JFCPCIBT
JFCEXT   EQU   JFCMAST
JFCBCKPT EQU   JFCOPTCD
JFCIND   EQU   JFCBCKPT
JFCRSV18 EQU   JFCOPTCD
JFCCYL   EQU   JFCRSV18
JFCACT   EQU   JFCCYL
JFCREDUC EQU   JFCOPTCD
JFCRSV19 EQU   JFCREDUC
JFCRSV20 EQU   JFCRSV19
JFCRSV21 EQU   JFCOPTCD
JFCDEL   EQU   JFCRSV21
JFCOPTJ  EQU   JFCOPTCD
JFCREORG EQU   JFCOPTJ
JFCBLKSI EQU   JFCSPPRT+9
JFCBUFSI EQU   JFCBLKSI
JFCBAXBF EQU   JFCBUFSI
JFCAMSYN EQU   JFCSPPRT+11
JFCNCP   EQU   JFCAMSYN+2
JFCNTM   EQU   JFCAMSYN+3
JFCBFSEQ EQU   JFCNTM
JFCPCI   EQU   JFCBFSEQ
JFCRESRV EQU   JFCAMSYN+4
JFCUCSEG EQU   JFCRESRV
JFCUCSOP EQU   JFCUCSEG+4
JFCOUTLI EQU   JFCUCSEG+5
JFCTHRSH EQU   JFCOUTLI
JFCCPRI  EQU   JFCTHRSH
JFCBVOLS EQU   JFCUCSEG+10
JFCBS001 EQU   JFCBVOLS
JFCBPQTY EQU   JFCBS001+34
JFCBCTRI EQU   JFCBS001+37
JFCBSQTY EQU   JFCBS001+38
JFCFLGS1 EQU   JFCBS001+41
         AGO   .@UNREFD                START UNREFERENCED COMPONENTS
JFCBEND  EQU   JFCBS001+58
JFCBSPTN EQU   JFCBS001+57
JFCBVLCT EQU   JFCBS001+56
JFCBDRLH EQU   JFCBS001+53
JFCBSBNM EQU   JFCBS001+50
JFCBABST EQU   JFCBS001+48
JFCBSPNM EQU   JFCBS001+45
JFCBDQTY EQU   JFCBS001+42
JFCBUAFF EQU   JFCFLGS1
JFCRSV45 EQU   JFCFLGS1
JFCVRDS  EQU   JFCFLGS1
JFCBCEOV EQU   JFCFLGS1
JFCRSV42 EQU   JFCFLGS1
JFCBADSP EQU   JFCFLGS1
JFCTOPEN EQU   JFCFLGS1
JFCBDLET EQU   JFCFLGS1
JFCRQID  EQU   JFCBSQTY
JFCROUND EQU   JFCBCTRI
JFCALX   EQU   JFCBCTRI
JFCMIXG  EQU   JFCBCTRI
JFCONTIG EQU   JFCBCTRI
JFCRSV29 EQU   JFCBCTRI
JFCBMSGP EQU   JFCBCTRI
JFCBSPAC EQU   JFCBCTRI
JFCRUNIT EQU   JFCBPQTY
JFCBEXAD EQU   JFCBS001+31
JFCBEXTL EQU   JFCBS001+30
JFCMSVGP EQU   JFCBS001+22
@NM00008 EQU   JFCBS001
JFCAVOLS EQU   JFCBVOLS
JFCBNVOL EQU   JFCUCSEG+9
JFCBNTCS EQU   JFCUCSEG+8
JFCSOWA  EQU   JFCOUTLI+1
JFCSEND  EQU   JFCCPRI
JFCEQUAL EQU   JFCCPRI
JFCRECV  EQU   JFCCPRI
JFCRSV34 EQU   JFCCPRI
JFCRSV33 EQU   JFCCPRI
JFCRSV55 EQU   JFCCPRI
JFCRSV54 EQU   JFCCPRI
JFCRSV53 EQU   JFCCPRI
JFCRSV27 EQU   JFCUCSOP
JFCRSV26 EQU   JFCUCSOP
JFCFCBVR EQU   JFCUCSOP
JFCFCBAL EQU   JFCUCSOP
JFCVER   EQU   JFCUCSOP
JFCRSV25 EQU   JFCUCSOP
JFCFOLD  EQU   JFCUCSOP
JFCBEXTP EQU   JFCUCSOP
JFCUCSID EQU   JFCUCSEG
JFCINTVL EQU   JFCSPPRT+19
JFCDBUFN EQU   JFCRESRV+3
JFCCYLOF EQU   JFCRESRV+2
JFCRKP   EQU   JFCRESRV
JFCPCIR2 EQU   JFCPCI
JFCPCIR1 EQU   JFCPCI
JFCPCIN2 EQU   JFCPCI
JFCPCIN1 EQU   JFCPCI
JFCPCIA2 EQU   JFCPCI
JFCPCIA1 EQU   JFCPCI
JFCPCIX2 EQU   JFCPCI
JFCPCIX1 EQU   JFCPCI
JFCBUFMX EQU   JFCNCP
JFCLRECL EQU   JFCAMSYN
JFCREL   EQU   JFCREORG
JFCRSV22 EQU   JFCDEL
JFCSRCHD EQU   JFCRSV20
JFCOPTQ  EQU   JFCACT
JFCFEED  EQU   JFCIND
JFCCBWU  EQU   JFCEXT
JFCWUMSG EQU   JFCOVER
JFCSDNAM EQU   JFCWVCBD
@NM00007 EQU   JFCRECFM
JFCCHAR  EQU   JFCRECFM
JFCRFS   EQU   JFCRECFM
JFCRFB   EQU   JFCRECFM
JFCRFO   EQU   JFCRCFM
JFCFMREC EQU   JFCRCFM
JFCRSV16 EQU   JFCDSRG2
JFCRSV15 EQU   JFCDSRG2
JFCORGTR EQU   JFCDSRG2
JFCRSV13 EQU   JFCDSRG2
JFCORGTQ EQU   JFCDSRG2
JFCORGTX EQU   JFCDSRG2
JFCORGGS EQU   JFCDSRG2
JFCORGU  EQU   JFCDSRG1
JFCORGPO EQU   JFCDSRG1
JFCORGMQ EQU   JFCDSRG1
JFCORGCQ EQU   JFCDSRG1
JFCORGCX EQU   JFCDSRG1
JFCORGDA EQU   JFCDSRG1
JFCORGPS EQU   JFCDSRG1
JFCORGIS EQU   JFCDSRG1
JFCTRKBL EQU   JFCLIMCT+1
@NM00006 EQU   JFCLIMCT
JFCDEN   EQU   JFCSPPRT+1
JFCPRTSP EQU   JFCSPPRT
JFCONE   EQU   JFCMODE
JFCTWO   EQU   JFCMODE
JFCRSV07 EQU   JFCMODE
JFCRSV06 EQU   JFCMODE
JFCMODER EQU   JFCMODE
JFCMODEO EQU   JFCMODE
JFCEBCD  EQU   JFCMODE
JFCBIN   EQU   JFCMODE
JFCRSV32 EQU   JFCCODE
JFCTTY   EQU   JFCCODE
JFCASCII EQU   JFCCODE
JFCNCR   EQU   JFCCODE
JFCBUR   EQU   JFCCODE
JFCFRI   EQU   JFCCODE
JFCBCD   EQU   JFCCODE
JFCNOCON EQU   JFCCODE
OVERID   EQU   PARMLIST+22
@NM00001 EQU   PARMLIST+20
OVEROFST EQU   TEMPLIST+10
MSGPTR   EQU   TEMPLIST
@NM00004 EQU   TENTRY+17
VSAM     EQU   DSORGS
@NM00003 EQU   CONFLICT+1
OPTCD    EQU   CONFLICT+1
TRACE    EQU   CONFLICT+1
AMORG    EQU   CONFLICT
RECFM    EQU   CONFLICT
CROPS    EQU   CONFLICT
SYNAD    EQU   CONFLICT
STRNO    EQU   CONFLICT
BUFNI    EQU   CONFLICT
BUFND    EQU   CONFLICT
BUFSP    EQU   CONFLICT
MAXKEYS  EQU   JFCBDISP
@NM00002 EQU   MSGMDLE
JFCRSV05 EQU   JFCEROPT
JFCRSV04 EQU   JFCEROPT
JFCRSV03 EQU   JFCEROPT
JFCRSV02 EQU   JFCEROPT
JFCTOPT  EQU   JFCEROPT
JFCABN   EQU   JFCEROPT
JFCSKP   EQU   JFCEROPT
JFCACC   EQU   JFCEROPT
JFCBUFL  EQU   JFCAMPTR+2
JFCFWORD EQU   JFCBFTEK
JFCDWORD EQU   JFCBFTEK
JFCHIER1 EQU   JFCBFTEK
JFCDYN   EQU   JFCBFTEK
JFCEXC   EQU   JFCBFTEK
JFCBBFTR EQU   JFCBBFTA
JFCSIM   EQU   JFCBBFTA
JFCHIER  EQU   JFCBFTEK
JFCBFOUT EQU   JFCBUFNO
JFCBUFIN EQU   JFCBUFNO
JFCTEMP  EQU   JFCBIND2
JFCREQ   EQU   JFCBIND2
JFCENT   EQU   JFCBIND2
JFCSHARE EQU   JFCBIND2
JFCSECUR EQU   JFCBIND2
JFCDISP  EQU   JFCBIND2
JFCPDS   EQU   JFCBIND1
JFCGDG   EQU   JFCBIND1
JFCADDED EQU   JFCBIND1
JFCLOC   EQU   JFCBIND1
JFCRLSE  EQU   JFCBIND1
JFCBXPDT EQU   INFMJFCB+83
JFCBCRDT EQU   INFMJFCB+80
JFCBOPS2 EQU   JFCBMASK+7
JFCRCTLG EQU   JFCBFLG2
JFCBBUFF EQU   JFCBFLG2
JFCTRACE EQU   JFCBFLG2
JFCSDRPS EQU   JFCBFLG2
JFCMODNW EQU   JFCBFLG2
JFCNRPS  EQU   JFCDEFER
JFCOUTOP EQU   JFCBFLG2
JFCINOP  EQU   JFCBFLG2
JFCBPWBP EQU   JFCOPEN
@NM00005 EQU   JFCOPEN
JFCDUAL  EQU   JFCBFLG1
JFCSLDES EQU   JFCBFLG1
JFCSLCRE EQU   JFCBFLG1
JFCSTAND EQU   JFCBFLG1
JFCBOPS1 EQU   JFCBMASK
JFCBVLSQ EQU   INFMJFCB+70
JFCRSV31 EQU   JFCFUNC
JFCFNCBT EQU   JFCFUNC
JFCFNCBX EQU   JFCFUNC
JFCFNCBD EQU   JFCFUNC
JFCFNCBW EQU   JFCFUNC
JFCFNCBP EQU   JFCFUNC
JFCFNCBR EQU   JFCFUNC
JFCFNCBI EQU   JFCFUNC
JFCBFOFL EQU   JFCBUFOF
JFCNL    EQU   JFCBLTYP
JFCSL    EQU   JFCBLTYP
JFCNSL   EQU   JFCBLTYP
JFCSUL   EQU   JFCBLTYP
JFCBLP   EQU   JFCBLTYP
JFCBLTM  EQU   JFCBLTYP
JFCBAL   EQU   JFCBLTYP
JFCRSV38 EQU   JFCBLTYP
JFCVINDX EQU   INFMJFCB+64
JFCNLREC EQU   INFMJFCB+62
JFCBDSCB EQU   INFMJFCB+53
JFCPAT   EQU   JFCBTSDM
JFCNDCB  EQU   JFCBTSDM
JFCNDSCB EQU   JFCBTSDM
JFCNWRIT EQU   JFCBTSDM
JFCTTR   EQU   JFCBTSDM
JFCSDS   EQU   JFCBTSDM
JFCVSL   EQU   JFCBTSDM
JFCCAT   EQU   JFCBTSDM
JFCIPLTX EQU   JFCBELNM
JFCBQNAM EQU   JFCBDSNM
.@UNREFD ANOP                          END UNREFERENCED COMPONENTS
@RC00036 EQU   @RC00031
@RC00059 EQU   @RC00056
@RC00074 EQU   @RC00071
@RC00109 EQU   @EL00002
@RC00157 EQU   @RC00131
@RC00150 EQU   @RC00131
@RC00144 EQU   @RC00131
@RC00188 EQU   @EL00004
@RC00195 EQU   @EL00004
@RC00286 EQU   @RC00284
@RF00337 EQU   @RC00335
@RF00342 EQU   @RC00340
@RC00114 EQU   @RC00109
@RC00198 EQU   @RC00195
@ENDDATA EQU   *
         END   IEFNB902,(C'PLS1830',0701,76254)
