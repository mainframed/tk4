        TITLE 'IGG019KJ - BDAM VRE FOUNDATION MODULE'
IGG019KJ CSECT
*MODULE NAME - IGG019KJ                                               *
*                                                                     *
*DESCRIPTIVE NAME - BDAM FOUNDATION MODULE, VARIABLE SPANNED RECORDS  *
*                                                                     *
*COPYRIGHT - NONE                                                     *
*                                                                     *
*CHANGE ACTIVITY                                                      *
*                                                                     *
*          OS REL 20 CHANGES/DELETIONS
*3572230600-230700                                               M5471
*3572                                                            A33688
*3572001100,002000-003400,172000,197000-197500,280000,371000,    20201
*3572516500,518100                                               20201
*          OS REL 21 CHANGES/DELETIONS
*1132                                                            A44088
*                                                               SA53267
*3572184530,196860-196940,272500,309500-310000,311000,325500-326000
*351000-353000,608000,667000-669000,708000,720500-721500,766700  21905
*3572269000,577000,577500,583500,584500,600000                   A35339
*3572588000-588500,609000-611500,613500                          A30797
*158500,162000-164500                                           SA54515
*          VS 1-1 CHANGES/DELETIONS
*          VS 2-1 CHANGES/DELETIONS
*                                                               XA00093
*          VS 1-3 CHANGES/DELETIONS
*                                                               XA02033
*                                                               XA03071
*          VS 2-2 CHANGES/DELETIONS
*                                                                Y02072
*                                                                YM1143
*                                                                YM1458
*                                                                YM5969
*461060-461080                                                   YM7542
*                                                                YM5853
*D147000                                                         YM7841
*A138100-138300,146600,147100-147300,147600-148100              ZA01524
*          VS 2-4 CHANGES/DELETIONS
*D314030-322124                                                @ZA08000
*
*STATUS CHANGE LEVEL 006
*
*FUNCTION/OPERATION - THIS IS THE BASIC MODULE OF BDAM FOR VRE.  THIS *
*   FOUNDATION MODULE CONSISTS OF THREE MAIN FUNCTIONAL ROUTINES -    *
*   ROUTINE 1. INITIAL ENTRY FOR ANY BDAM READ OR WRITE, CHECK THE    *
*    VALIDITY OF SPECIFIED TYPE AND OPTIONS, OBTAIN AN IOB, PROVIDE   *
*    LINKAGE FOR ADDRESS CONVERSION AND CHANNEL PROGRAM CONSTRUCTION, *
*    ISSUE THE 'EXCP' AND RETURN TO THE USER.                         *
*                                                                     *
*   ROUTINE 2. ASYNCHRONOUS INTERRUPT ROUTINE (ASI) WHICH IS ENTERED  *
*    FROM THE SUPERVISOR AT THE COMPLETION OF THE CHANNEL END MODULE. *
*    IT PERFORMS THE SEGMENTATION PROCESSING, CHANNEL PROGRAM         *
*    MODIFICATION AND CHANNEL PROGRAM RESTART, IT LINKS NEWLY GOTTEN  *
*    IOBS TO THE DCB, PROVIDES LINKAGE TO THE FEEDBACK, SELF-FORMAT   *
*    AND READ EXCLUSIVE MODULES, MAKES THE IOB AVAILABLE, ISSUES THE  *
*    'POST' AND RETURNS TO THE SUPERVISOR.                            *
*                                                                     *
*   ROUTINE 3. ERROR ROUTINES, RELEASE THE IOB, SET THE PROPER        *
*    EXCEPTION CODES, ISSUE THE 'POST'.                               *
*                                                                     *
*ENTRY POINTS- 'IGG019KJ' (ENTRYPT) IS THE ENTRY FOR A BDAM READ OR   *
*   WRITE MACRO INSTRUCTION. THE GENERATED CALLING SEQUENCE IS,       *
*            L    15,DCBREAD   (DCB+48)                               *
*            BALR 14,15                                               *
*                                                                     *
*   'IECDFDNA' IS THE ENTRY POINT TO THE ASI ROUTINE FROM SUPERVISOR  *
*   WHEN THE REQUEST HAS TERMINATED. THE CALLING SEQUENCE USED IS,    *
*            L    15,IRBRBEP   (IRB+12)                               *
*            BALR 14,15                                               *
*                                                                     *
*   'LATERR' IS AN ENTRY TO THE INVALID REQUEST ERROR ROUTINE FROM    *
*   THE ADDRESS CONVERSION OR PRE-FORMAT MODULES. CALLING SEQUENCE IS,*
*            L    REG,20(IGG019KA BASE)                               *
*            BR   REG                                                 *
*                                                                     *
*INPUT- ROUTINE 1.- DECB ADDRESS IN REGISTER 1, SAVE AREA ADDRESS IN  *
*   REGISTER 13, RETURN ADDRESS IN REGISTER 14, ENTRY POINT IN        *
*   REGISTER 15.                                                      *
*                                                                     *
*   ROUTINE 2.(ASI)- IOS QUEUEING ELEMENT ADDRESS IN REGISTER 1,      *
*   RETURN ADDRESS IN REGISTER 14, ENTRY POINT IN REGISTER 15.        *
*                                                                     *
*   ROUTINE 3.(INVALID REQUEST)- REGISTERS 5,7,11,13 WILL CONTAIN THE *
*   DECB ADDRESS, IOB ADDRESS, IGG019KJ ADDRESS, SAVE AREA ADDRESS,   *
*   RESPECTIVELY. REGISTER 12 WILL CONTAIN THE REASON CODE WHICH WILL *
*   APPEAR IN BYTE TWO OF THE DECB AFTER 'POST' IS EXECUTED.          *
*                                                                     *
*OUTPUT- ROUTINE 1.- AN IOB WILL BE OBTAINED, CHANNEL PROGRAM         *
*   CONSTRUCTED AND 'EXCP' EXCECUTED FOR A VALID READ OR WRITE.       *
*                                                                     *
*   ROUTINE 2.(ASI)- FEEDBACK WILL BE RETURNED IF REQUESTED, AND A    *
*   COMPLETION CODE PLACED IN THE DECB BY THE 'POST' ROUTINE.         *
*                                                                     *
*   ROUTINE 3.(INVALID REQUEST)- A COMPLETION CODE AND REASON CODE    *
*   ARE PLACED IN THE DECB BY THE 'POST' ROUTINE.                     *
*                                                                     *
*EXTERNAL ROUTINES- 'IGG019KC'-CONVERT RELATIVE TRACK ADDRESS (TT OR  *
*   TTR) TO AN ACTUAL ADDRESS OR CONVERT ACTUAL TO TTR FOR FEEDBACK.  *
*                                                                     *
*   'IGG019KR'-CONSTRUCT A CHANNEL PROGRAM TO SEARCH BY BLOCK ID OR   *
*             -CONSTRUCT A CHANNEL PROGRAM TO SEARCH BY BLOCK KEY.    *
*                                                                     *
*   'IGG019KN'-CONSTRUCT A CHANNEL PROGRAM TO ADD A NEW BLOCK TO A    *
*   DATA SET OF VARIABLE LENGTH SPANNED RECORDS, (SELF-FORMAT MODULE).*
*   ALSO ENTERED TO DETERMINE IF THE NEW BLOCK WILL FIT ON THE TRACK  *
*   AFTER THE CAPACITY RECORD IS READ INTO THE IOB.                   *
*   ALSO ENTERED AFTER THE WRITE-ADD REQUEST HAS COMPLETED, TO SCAN   *
*   THE UNSCHEDULED QUEUE FOR OTHER WRITE-ADD REQUESTS AND EXECUTE    *
*   THE FIRST REQUEST FOUND, IF ANY.                                  *
*                                                                     *
*   SVC 53 -   PLACE A RECORD ON THE READ EXCLUSIVE LIST FOR A READ   *
*   OR WRITE ADD REQUEST, OR REMOVE A RECORD FROM THE LIST FOR WRITE  *
*   WHEN EXCLUSIVE CONTROL IS SPECIFIED.                              *
*                                                                     *
*   'IGG019KG'-CONVERT AN ACTUAL ADDRESS TO A RELATIVE BLOCK NUMBER   *
*   IF FEEDBACK IS REQUESTED.                                         *
*                                                                     *
*EXITS-NORMAL- 'RSTOR' IS THE RETURN TO THE PROGRAM WHICH ISSUED THE  *
*   READ OR WRITE MACRO-INSTRUCTION. THE REQUEST HAS EITHER BEEN      *
*   EXECUTED VIA 'EXCP' OR HAS BEEN POSTED COMPLETE AS AN INVALID     *
*   REQUEST.                                                          *
*   'SUPEXIT' IS THE EXIT FROM THE ASI ROUTINE TO SUPERVISOR. THE DECB*
*   HAS BEEN POSTED AS COMPLETE WITH A CODE INDICATING SUCCESSFUL OR  *
*   ERROR COMPLETION.                                                 *
*   'EXCPEXIT' IS THE EXIT FROM THE ASI ROUTINE AFTER A CHANNEL       *
*   PROGRAM HAS BEEN RESTARTED.                                       *
*                                                                     *
*TABLES/WORK AREAS- N/A                                               *
*                                                                     *
*ATTRIBUTES- THE INITIAL ENTRY ROUTINE AND INVALID REQUEST ERROR      *
*   ROUTINE ARE REENTRANT AND EXECUTED ENABLED.                       *
*   THE ASI ROUTINE IS REUSEABLE AND EXECUTED ENABLED, PROBLEM PGM    *
*   STATE AND THE PROBLEM PROGRAM PROTECT KEY.                        *
*                                                                     *
*NOTE- THE BDAM MODUES BRANCH AND LINK TO EACH OTHER WITHOUT USE OF   *
*   A REGISTER SAVE AREA SO THE REGISTER USAGE MUST REMAIN CONSISTENT *
*   IN THE BDAM MODULES, IGG019KJ, IGG019KC, IGG019KQ, IGG019KR,      *
*   IGG019KG, IGG019KN.                                               *
*                                                                     *
*                                                                     *
*
*
         IEZBITS
*
*  REGISTER USAGE
*
PARAM2   EQU   0
PARAM    EQU   1         PARAMETERS
WKREG1   EQU   2         WORK REGISTER
DEBREG   EQU   3         DEB ADDRESS
DCBREG   EQU   4         DCB ADDRESS
DECBREG  EQU   5         DECB ADDRESS
WKREG2   EQU   6         WORK REGISTER
IOBREG   EQU   7         IOB ADDRESS
FDNBASE  EQU   11        BASE FOR THE FOUNDATION MODULE
INTRET   EQU   12        RETURN FOR INTERNAL LINKAGES
SAVE     EQU   13        POINTER TO USER SAVE AREA
RETREG   EQU   14        RETURN REGISTER
EPREG    EQU   15        ENTRY POINT
*
         EJECT
*
         USING IGG019KJ,EPREG
*
ENTRYPT  B     BEGIN                    BRANCH AROUND ADDRESS LOCATIONS
*
RRAD     DC    F'0'                     RELATIVE BLOCK MODULE ADDRESS
RTAD     DC    V(IGG019KC)              RELATIVE TRACK MOD ADDR  Y02072
VERAD    DC    V(IGG019KQ)              VERIFY MODULE ADDRESS    Y02072
ASIAD    DC    A(IECDFDNA)              ASYNCH INTERRUPT ROUTINE Y02072
ERRENTRY DC    A(LATERR)                INVALID REQUEST ERROR RT Y02072
KEYMODAD DC    V(IGG019KR)              ADDRESS OF THE KEY MOD   Y02072
IDMODAD  DC    V(IGG019KR)              ADDRESS OF THE ID MODULE Y02072
*
*
*
         DROP  EPREG
         USING IGG019KJ,FDNBASE
BEGIN    SAVE  (14,12)                  SAVE USER REGISTERS IN HIS AREA
         LR    FDNBASE,EPREG            ESTABLISH A BASE FOR MODULE
         LR    DECBREG,PARAM            SET BASE REGISTERS FOR DECB
         USING DECBDEF,DECBREG                                   Y02072
         L     DCBREG,DECDCBAD          SET BASE REGISTER FOR DCB
         USING IHADCB,DCBREG                                     Y02072
         L     DEBREG,DCBDEBAD          SET BASE REGISTER FOR DEB
         USING DEBDEF,DEBREG
*
         IC    INTRET,DECTYPE           SAVE REQUESTED OPTIONS IN A REG
         OI    DECTYPE,VERIFY+EXSCH+ACTAD+RELRD+OFLOW
         NC    DECTYPE(ONE),DCBOPTCD    COMBINE DCB OPTIONS WITH THE
         EX    INTRET,ORBACK            REQUEST OPTIONS.
         N     INTRET,OPSMSK            VALIDITY CHECK READX,DYN. BFR.
         BZ    OKOPTS                   OPTIONS (BR IF NONE PRESENT),BY
         EX    INTRET,VALCHK            EXECUTING A TM INSTRUCTION.
         BO    OKOPTS                   OK IF ALSO SPECIFIED IN DCB,
         IC    INTRET,INVOPT            ELSE FLAG THIS REQUEST AS
         B     ABORT                    INVALID AND GO POST COMPLETION.
*
ORBACK   OI    DECTYPE,NULL  EXECUTED-RETURN FEEDBACK OPTION BIT.
VALCHK   TM    DCBOPTCD,NULL EXECUTED-CHECK READX,DYN. BFR. REQUEST.
*
OKOPTS   TM    DECTYPE+ONE,READ         IS THIS A READ REQUEST
         BO    LGNCHK                   YES, GO TEST LENGTH OPTION
         TM    DEBOPATB,WRTMSK          DID OPEN SPECIFY OUTPUT/UPDATE
         BC    ONE+MIXED,FORMCHK        YES, WRITE REQUEST IS VALID
         IC    INTRET,INVWRT            FLAG THIS WRITE TO INPUT DATA
         B     ABORT                    SET, GO POST COMPLETION
*
*
FORMCHK  EQU   *
         L     WKREG2,DECAREA            USE FIRST TWO BYTES OF DATA AS
         MVC   DECLNGTH(TWO),NULL(WKREG2) BLOCK LENGTH FOR THE WRITE
         B     SZRTN                     GO DETERMINE IOB SIZE
*
LGNCHK   EQU   *
         TM    DECTYPE+ONE,LGNOP         DID USER CODE LENGTH AS 'S'
         BZ    SZRTN                     NO, USE DECB LENGTH
         MVC   DECLNGTH(TWO),DCBBLKSI    USE MAXIMUM BLOCK SIZE
*
SZRTN    EQU   *
***********************************************************************
*                                                                     *
*  THE FOLLOWING ROUTINE CALCULATES THE SIZE OF THE IOB WHICH IS      *
*  REQUIRED FOR THIS REQUEST.
*
*
         LA    WKREG1,BASESZ            IOB SIZE = BASE + OPTIONS
         TM    DECTYPE+ONE,KEY          IS TYPE = DK
         BZ    TSTRD                    BR IF NO
         TM    DECTYPE,EXSCH            TEST FOR EXTENDED SEARCH
         BZ    TSTRD                    BR IF NO
         CLC   ZEROS(THREE),DCBLIMCT    IS LENGTH OF SEARCH SPECIFIED
         BC    ONE+MIXED,ESOK           YES, REQUEST IS VALID
         IC    INTRET,INVLIMCT          FLAG INVALID REQUEST (LIMCT=0)
         B     ABORT                    GO POST COMPLETION
*
ESOK     EQU   *
         TM    DECTYPE+ONE,ADD          IS IT WRITE ADD
         BO    ITISADD                  BR IF YES
         LA    WKREG1,EXTNDSCH(WKREG1)  ADD EXTENDED SEARCH CHANNEL
*                                       PROGRAM SIZE
         TM    DECTYPE,VERIFY           IS WRITE VALIDITY CHECK REQ'D
         BZ    READXTST                 BR IF NO
         LA    WKREG1,WCUPDTES(WKREG1)  ELSE, ADD ON SIZE FOR WRITE
*                                       CHECK CCW'S.
         B     READXTST                 GO TEST FOR EXCLUSIVE CONTROL
*
TSTRD    EQU   *
         TM    DECTYPE+ONE,READ         IS THIS A READ REQUEST
         BZ    ADDTST                   BR IF NO
         LA    WKREG1,RDDIORDK(WKREG1)  ADD READ CHANNEL PROGRAM SIZE
         TM    DECTYPE+ONE,NEXTADR      IS NEXT ADDRESS REQ'D
         BZ    READXTST                 BR IF NO
         TM    DECTYPE+ONE,KEY          IS THIS A READ TYPE = DK
         BZ    RDTYPDI                  BR IF NO
         LA    WKREG1,RNDK(WKREG1)      ADD FOR NEXT ADDRESS CCW'S
         B     READXTST                 GO TEST FOR READ EXCLUSIVE
*
RDTYPDI  EQU   *
         LA    WKREG1,RNDI(WKREG1)      ADD FOR NEXT ADDRESS CCW'S
         B     READXTST                 GO TEST FOR READ EXCLUSIVE
*
ADDTST   EQU   *
         TM    DECTYPE+ONE,ADD          IS IT WRITE ADD
         BZ    NOTADD                   BR IF NO
ITISADD  EQU   *
         LA    WKREG1,WRTADD+EXCNTRL(WKREG1) ADD ON THE WRITE ADD
*                                       CHANNEL PROGRAM SIZE AND THE
*                                       EXCLUSIVE CONTROL LIST.
         TM    DECTYPE,VERIFY           IS WRITE VALIDITY CHECK REQ'D
         BZ    GOTIOBSZ                 BR IF NO
         LA    WKREG1,WCADD(WKREG1)     ADD ON SIZE OF WRITE CHECK CCWS
         B     GOTIOBSZ                 GO GET AN IOB
*
NOTADD   EQU   *
         LA    WKREG1,WRDIORDK(WKREG1)  ADD WRITE CHANNEL PROGRAM SIZE
         TM    DECTYPE,VERIFY           IS WRITE VALIDITY CHECK REQ'D
         BZ    READXTST                 BR IF NO
         TM    DECTYPE+ONE,KEY          IS THIS A WRITE TYPE = DK
         BZ    WRTDI                    BR IF NO
         LA    WKREG1,WCUPDTDK(WKREG1)  ADD SIZE OF WRITE CHECK CCW'S
         B     READXTST                 GO TEST FOR EXCLUSIVE CONTROL
*
WRTDI    EQU   *
         LA    WKREG1,WCUPDTDI(WKREG1)  ADD SIZE OF WRITE CHECK CCW'S
READXTST EQU   *
         TM    DECTYPE,READX            IS THIS A READ EXCLUSIVE OR A
*                                       WRITE TO RELEASE
         BZ    GOTIOBSZ                 BR IF NEITHER
         LA    WKREG1,EXCNTRL(WKREG1)   ADD FOR ENQ PARAMETER LIST
         SPACE 5
GOTIOBSZ EQU   *
         AH    WKREG1,H8                ADD A DOUBLE WORD FOR    20201
*                                       SECTOR VALUES JUST IN CASE
*                                       RPS IS USED
***********************************************************************
*    THE FOLLOWING ROUTINE OBTAINS AN IOB AREA FROM THE POOL OF AREAS
*     IF ONE OF ENOUGH SIZE IS AVAILABLE
***********************************************************************
*
         USING IOBSTDRD,IOBREG          EST BASE FOR IOB         Y02072
         L     IOBREG,DCBIOBAD          LOAD FIRST LINK ADDRESS
SHFT     LA    IOBREG,NULL(IOBREG)      BE SURE HI-ORDER BYTE IS ZERO
         LTR   IOBREG,IOBREG            TEST FOR ZERO LINK ADDRESS.
         BZ    GETCR                    IF ADDR=0, GO GET CORE FOR IOB
         CH    WKREG1,IOBDIOBS          IS THIS IOB AREA LARGE ENOUGH
         BH    TRYNEXT                  IF NOT GO SEE IF THERE ARE MORE
         TS    IOBDAYLI                 IS THIS IOB AVAILABLE    Y02072
         BZ    CLRIOB                   YES, GO INITIALIZE AREA
*
TRYNEXT  L     IOBREG,IOBDPLAD          LOAD NEXT POOL LINK
         B     SHFT                     GO TEST FOR END OF CHAIN
*
*
******************** EXECUTE INSTRUCTIONS**********************
CLRXC    XC    IOBDTYPE(ONE),IOBDTYPE   EXECUTED-- CLEAR LAST OF IOB
CLRXXC   XC    IOBDTYPE+Q255(1),IOBDTYPE+Q255 CLR IF IOB+CCWS   ZA01524
*                                       EXTENDS BEYOND IOBDTYPE ZA01524
*                                       +255 BYTES              ZA01524
*
*
*  GETMAIN ROUTINE
*
GETCR    LR    PARAM2,WKREG1            MOVE BYTE COUNT TO PARAM REG
         AH    PARAM2,PREFSZ            ADD FOR PREFIX
         GETMAIN R,LV=(0)
*
         LR    IOBREG,PARAM             LOAD CORE ADDRESS TO IOB BASE
         AH    IOBREG,PREFSZ            INCREMENT TO FORM IOB PREFIX
         STH   WKREG1,IOBDIOBS          STORE THE AREA SIZE IN IOB
         SR    WKREG2,WKREG2            CLEAR THE POOL
         ST    WKREG2,IOBDAYLI          ADDRESS AREA             Y02072
CLRIOB   XC    IOBFLAG1(FT),IOBFLAG1    CLEAR TO IOB SIZE FIELD
         LR    WKREG2,IOBREG
         SH    WKREG2,PREFSZ            POINT TO START OF IOB PREFIX
         XC    NULL(L'PREFSZ,WKREG2),NULL(WKREG2) CLEAR PREFIX   Y02072
         LH    WKREG1,IOBDIOBS          GET SIZE OF IOB         ZA01524
         SH    WKREG1,K49               REDUCE SIZE TO REMAINING SIZE
         CH    WKREG1,H255              IOB GREATER THAN 255+   ZA01524
*                                       49(ALREADY CLEARED)     ZA01524
         BH    CLROVFF                  YES, GO CLEAR BEYOND    ZA01524
         EX    WKREG1,CLRXC             CLEAR THE REST OF THE AREA
         B     CORCLRD                  BR AROUND NEXT INST     ZA01524
*
CLROVFF  EQU   *                        CLEAR IOB GREATER 255   ZA01524
         XC    IOBDTYPE(Q255),IOBDTYPE  CLEAR 1ST 255 BYTES     ZA01524
         SH    WKREG1,H255              SUBT AMOUNT CLEARED     ZA01524
         EX    WKREG1,CLRXXC            CLEAR OUT THE REMAINDER ZA01524
*
CORCLRD  EQU   *                        INITIALIZE IOB          ZA01524
         ST    DCBREG,IOBDCBPT          STORE DCB ADDRESS IN IOB
         ST    DECBREG,IOBECBPT         STORE ECB ADDRESS IN IOB
         ST    IOBREG,DECIOBPT          STORE IOB ADDR IN DECB
         LA    WKREG1,IOBCHNPR          DEVELOP CHANNEL PROGRAM START
         ST    WKREG1,IOBSTART          ADDRESS AND STORE IT IN IOB
         MVC   IOBDTYPE(L'DECTYPE),DECTYPE  MOVE OPT,TYPE CODES  YM1143
         MVI   IOBFLAG1,CPFLAG          MARK AS UNRELATED,COMMAND CHAIN
*
*    THE FOLLOWING ROUTINE DETERMINES THE ADDRESSING METHOD BEING
*     USED AND CHECKS THE VALIDITY OF THE ADDRESS.
*
         L     PARAM,DECRECPT           LOAD POINTER TO USER'S ADDRESS
         LA    RETREG,CLRCP             LOAD COMMON RETURN POINT ADDR
         TM    IOBDTYP2,IOBRQUST+IOBADDTY  BYPASS NEXT RTN IF READ/ADD
         BC    ONE+MIXED,D1NOFDBK       AND GO DETERMINE ADDRESS TYPE
         TM    IOBDTYP2,IOBTYPE         IF TYPE IS KEY, BYPASS CHECKING
         BO    TRYX                     FOR A WRITE TO R ZERO
         TM    IOBDTYPE,IOBACTAD        IS ADDRESS ACTUAL
         BZ    TRYRT                    NO, GO TEST FURTHER
TESTR0   EQU   *                        WRT R0 INVALID -TEST IT OX02033
         CLI   IDDISP(PARAM),IDOFZERO   IS THIS A WRITE TO R0
         BNE   ACTUAL                   NO, ACTUAL ADDRESS IS OK
SETIRBIT IC    INTRET,INVID             FLAG INVAL REQ. (WRITE TO R0)
         B     LATERR                   GO POST COMPLETION, FREE IOB
*
TRYRT    EQU   *
         TM    DCBOPTCD,DCBOPTF         FEEDBACK IN DCB OPTCD?  XA02033
         BO    TRYRT2                   YES, NOT ACTUAL ADDRESS XA02033
         TM    IOBDTYPE,IOBRDEXC+IOBFDBCK  WRT REL/FDBK IN DECB XA03071
         BO    TESTR0                   YES, ASSUME ACTUAL ADDR XA02033
*                                       BECAUSE FEEDBACK ALWAYS XA02033
*                                       PROVIDED FOR READX REQ  XA02033
*                                       AND WRT REL MUST ASSUME XA02033
*                                       PREVIOUS READX REQUEST  XA02033
TRYRT2   EQU   *                        NOT ACTUAL ADDRESSING   XA02033
         CLI   ROFTTR(PARAM),IDOFZERO   IS R OF TTR A 0
         BE    SETIRBIT                 YES,WRITE REQUEST IS INVALID
*
RELTRKX  L     EPREG,RTAD               EXIT TO CONVERT TTR TO AN
         B     CNVENTRY(EPREG)          ACTUAL ADDRESS
*
TRYX     TM    IOBDTYPE,IOBRDEXC        IS THIS A WRITE WITH FEEDBACK
         BZ    D1NOFDBK                 NO, GO TEST ADDRESS TYPE
         TM    DCBOPTCD,DCBOPTF         WAS FEEDBACK RELATIVE FOR READ
         BZ    ACTUAL                   NO, GO MOVE ACTUAL ADDR TO IOB
D1NOFDBK TM    IOBDTYPE,IOBACTAD        IF ADDRESS IS ALREADY ACTUAL,
         BO    ACTUAL                   GO MOVE IT TO THE IOB,
         B     RELTRKX                  GO TO RELATIVE TRACK EXIT
*
CLRCP    EQU   *                                                 20201
         XC    IOBDNCRF(FZ+CCWLN),IOBDNCRF  CLEAR AREA TO STORE  20201
*                                       REG'S PLUS REC REDY DW
         B     GETSWA                   OBTAIN SEGMENT WORK AREA
*
*  THE FOLLOWING ROUTINE DETERMINES THE TYPE OF READ OR WRITE
*    AND PROVIDES LINKAGE TO THE PROPER MODULE
*
ACTUAL   MVC   IOBSEEK,NULL(PARAM)      MOVE USER ADDRESS TO
         MVC   IOBUPLIM(SEVN),IOBSEEK   SEEK AND LIMIT FIELDS
*
*   THIS SECTION OF CODE WILL LOCATE A SEGMENT WORK AREA AND
*   ASSIGN IT TO THE IOB FOR THIS REQUEST IF DYNAMIC BUFFERING
*   IS NOT USED.  IF DYNAMIC BUFFERING IS USED, A BUFFER WILL BE
*   OBTAINED AT SIO TIME.
*
GETSWA   EQU   *
         LR    WKREG1,IOBREG
         SH    WKREG1,IOBASWA           POINT TO SWA ADDR FIELD
         TM    IOBDTYPE,IOBDYNBF        TEST FOR DYNAMIC BUFFERING
         BZ    PRELOOP                  GET A SWA IF NOT
         TM    DECTYPE+ONE,READ         IS THIS A READ REQUEST
         BO    TYPEDEC                  IF YES, NO SWA REQUIRED
         L     WKREG2,DECAREA           GET RECORD AREA ADDRESS
         SH    WKREG2,FOUR              GET SWA ADDRESS
         TM    IOBDTYP2,IOBSKEY         WAS KEY ADDR 'S'?       XA00093
         BZ    MOVESWAD                 BR IF NOT               XA00093
         SR    RETREG,RETREG            CLEAR REG               XA00093
         IC    RETREG,DCBKEYLE          BACK UP BY LENGTH OF    XA00093
         SR    WKREG2,RETREG            KEY WHICH PRECEDES      XA00093
MOVESWAD EQU   *                        RECORD                  XA00093
         MVC   NULL(EQU4,WKREG1),NULL(WKREG2)  MOVE SWA ADDR TO IOB
         B     TYPEDEC                  GO GENERATE THE CHANNEL PROGRAM
PRELOOP  EQU   *
         TM    DCBOPTCD,DCBOPTDB        SEE IF DYNAMIC BUFFERING IN DCB
         BZ    GETSWA2                  BRANCH IF NO
         L     PARAM,DEBUCBAD           LOAD UCB ADDRESS
         L     WKREG2,CVTPTR(NULL,NULL) LOAD CVT ADDRESS
         L     WKREG2,DTABOFF(NULL,WKREG2) LOAD DEVICE TABLE ADDRESS
         IC    PARAM,TYPCD(PARAM)       LOAD DEVICE CODE
         N     PARAM,LASTFOUR           CLEAR ALL BUT LOW ORDER 4 BITS
         IC    PARAM,NULL(PARAM,WKREG2) FIND ENTRY TRK LENGTH OFFSET
         LA    WKREG2,EQU4(PARAM,WKREG2) POINT TO ENTRY TRK LENGTH
         LH    WKREG2,NULL(WKREG2)      LOAD TRK LNGTH
         CH    WKREG2,DCBBLKSI          COMPARE MAX LOG REC LNGTH AND
*                                       TRK SIZE
         BL    ADDCNTL                  TRK SIZE LOW, BRANCH
         LH    WKREG2,DCBBLKSI          USE MAX LOGICAL REC LNGTH
ADDCNTL  EQU   *
         LA    PARAM2,CNTLBYTE(WKREG2)  ADD CNTL BYTES
         GETMAIN R,LV=(0)               GET CORE
         LA    WKREG2,TEN(WKREG2)       ADD CNTL FIELD TO SWA SIZE
         STH   WKREG2,SIX(PARAM)        PUT BUFFER SIZE IN BUFCB
         XC    RAINC(EQU4,PARAM),RAINC(PARAM)
*                                       PUT ZERO IN BUFFER POINTER
         LA    WKREG2,ONE
         STH   WKREG2,EQU4(PARAM)       PUT NO OF BUFFERS IN BUFCB
         LA    WKREG2,RAINC(PARAM)      GET ADDRESS OF SWA
         ST    WKREG2,NULL(PARAM)       PUT ADD IN BUFCB
         B     GOTSWA                   GO LINK SWA TO IOB
*
*   LOCATE A SEGMENT WORK AREA
*
GETSWA2  EQU   *
         L     WKREG2,DCBDYNB           GET ADDRESS OF BCB
SWALOOP  L     WKREG2,NULL(WKREG2)      GET A SWA ADDRESS
         LA    WKREG2,NULL(WKREG2)      CLEAR HI ORDER BYTE
         LTR   WKREG2,WKREG2            SEE IF NO MORE SWA'S
         BZ    NOSWA                    BRANCH IN NO SWA AVAIL.
         TS    NULL(WKREG2)             DETERMINE IF SWA IS AVAIL.
         BZ    GOTSWA                   BRANCH IF SWA CAN BE USED
         B     SWALOOP                  ELSE TRY FOR ANOTHER ONE
*
GOTSWA   EQU   *
         ST    WKREG2,NULL(WKREG1)      STORE SWA ADDRESS
         MVC   RADSP(RALEN,WKREG2),DECAREA  PUT RECORD AREA PTR IN SWA
         MVI   RADSP(WKREG2),NULL       SET TRACK COUNT TO ZERO
         XC    RAINC(RAINCLN,WKREG2),RAINC(WKREG2)  ZERO B.I. FIELD
         B     TYPEDEC                  GO CONSTRUCT CCW'S
*
NOSWA    IC    INTRET,NOSWACD           SET NO SWA ERROR CODE
         B     LATERR                   GO POST COMPLETION
*
*                                                                     *
TYPEDEC  LA    RETREG,EXPCTEND          LOAD COMMON RETURN ADDR  Y02072
*
* CHECK FOR RPS AND IF USED BUILD FIRST SECTOR ADDRESS AND
* PUT IN FIRST CCW ALSO SET SECTOR CMND WHICH WILL BE USED TO
*      INDICATE RPS CHANNEL PROGRAMS ARE TO BE BUILT
*
         SR    WKREG1,WKREG1            CLEAR REG FOR IT         20201
         IC    WKREG1,IOBM              GET EXTENT NO.           20201
         SLL   WKREG1,FOURB             MULTIPLY BY 16           20201
         L     WKREG2,DEBUCBAD(WKREG1)  GET UCB ADDRESS FOR      20201
*                                       PRESENT EXTENT           20201
         TM    OPTOFF(WKREG2),RCDRY     IS RCD READY TO BE USED  20201
         BNO   NOTRRA                   BRANCH IF NO             20201
         LH    WKREG2,IOBDIOBS          GET IOB SIZE             20201
         AR    WKREG2,IOBREG            ADD IOB ADDR             20201
         LH    WKREG1,H8                DOUBLE WORD OF RCD READY 20201
         TM    DECTYPE,READX            READ EXCLUSIVE USED      20201
         BO    ADDIT                    BRANCH IF YES            20201
         TM    DECTYPE+ONE,ADD          WRITE ADD                20201
         BZ    NOTREX                   BRANCH IF NO             20201
*
ADDIT    EQU   *                                                 20201
         LA    WKREG1,EXCNTRL(WKREG1)   ADD ENQ SIZE             20201
NOTREX   EQU   *                                                 20201
         SR    WKREG2,WKREG1            OBTAIN SECTOR ADDRESS    20201
*
         ST    WKREG2,IOBDCPND          PUT TEMPORARILY IN IOB   20201
         MVI   IOBDCPND,SETSC           PUT CMND IN FOR          20201
*                                       INDICATOR                20201
         SH    IOBREG,PREFSZ            GET IOB PREFIX           20201
         OI    NULL(IOBREG),RCDRYM      TURN ON RCD READY MASK   20201
         AH    IOBREG,PREFSZ            RESTORE IOB REG          20201
NOTRRA   EQU   *                                                 20201
         LA    WKREG2,IOBCHNPR          INIT CCW PTR.            20201
*
         TM    IOBDTYP2,IOBADDTY+IOBTYPE  IS TYPE KEY OR WRITE ADD
         BZ    IDEXIT                   NO, GO GENERATE ID CHAN PROGRAM
         MVI   IOBR,IDOFZERO            MAKE R BYTE ZERO TO SEARCH ON 0
*
         TM    IOBDTYP2,IOBADDTY        IS TYPE WRITE ADD
         BO    SOMEWA                   YES, GO TEST RECORD FORMAT
         CLI   DCBKEYLE,NULL            HAVE KEYS BEEN SPECIFIED
         BE    SETNOKEY                 NO, GO SET ERROR CODE
         L     WKREG1,DECKYADR          LOAD AND TEST FOR MISSING KEY
         LTR   WKREG1,WKREG1            ADDRESS FIELD IN DECB
         BC    NONZERO,PROCEED          IF NOT MISSING GO TEST EXIT
SETNOKEY IC    INTRET,INVKEY            SET INVALID REQUEST CODE
         B     LATERR                   GO POST COMPLETION, FREE IOB
*
PROCEED  EQU   *
         L     EPREG,KEYMODAD           EXIT TO GENERATE KEY CHANNEL
         BR    EPREG                    PROGRAM
IDEXIT   L     EPREG,IDMODAD            LOAD ID MODULE ADDRESS AND
         BR    EPREG                    GO TO GENERATE ID CHANNEL PROG.
*
SOMEWA   EQU   *
         L     EPREG,DCBDFOR            LOAD ENTRY POINT OF THE
         BR    EPREG                    WRITE ADD MODULE AND BR. TO IT
*
*
EXPCTEND EQU   *
         LA    WKREG2,CCWLN(WKREG2)      UPDATE POINTER TO PROGRAM END
         ST    WKREG2,IOBDCPND           EXPECTED ENDING ADDRESS
         MVC   IOBDNCRF+ONE(ONE),IOBBB2  MOVE B TO INLINE SEEK
*
         LR    PARAM,IOBREG              LOAD IOB ADDR AS THE PARAMETER
         EXCP  (1)
*
RSTOR    RETURN (14,12),T,RC=0
*
*
*    THE FOLLOWING ROUTINE COMPLETES THE PROCESSING OF AN INVALID
*     REQUEST AND RETURNS TO THE USER.
*
LATERR   EQU   *
         LR    WKREG1,IOBREG
         SH    WKREG1,IOBASWA           POINT TO SWA ADDR FIELD
         L     WKREG1,NULL(WKREG1)
         LTR   WKREG1,WKREG1
         BZ    NOSWATF                  BR IF NO SWA
         MVI   NULL(WKREG1),NULL        ZERO THE SWA IN USE BYTE
NOSWATF  EQU   *
         TM    IOBDAYLI,AVLMSK          IF THE AVAILABILITY BIT IS SET
         BO    FRMPOOL                  THIS IOB IS LINKED TO THE POOL
         LH    PARAM2,IOBDIOBS          SET SIZE PARAMETER FOR FREEMAIN
         AH    PARAM2,PREFSZ            ADD FOR PREFIX
         LR    PARAM,IOBREG             SET ADDRESS PARAMETER
         SH    PARAM,PREFSZ             POINT TO START OF PREFIX
         FREEMAIN R,LV=(0),A=(1)
         B     ABORT                    GO POST
*
FRMPOOL  EQU   *
         MVI   IOBDAYLI,AVLABLE         AVAILABLE
ABORT    AH    INTRET,INVREQ            SET INVALID REQ. EXCEPT. CODE
         SR    WKREG2,WKREG2            ZERO OUT THE IOB POINTER FIELD
         ST    WKREG2,DECIOBPT          OF THE DECB
         LR    PARAM2,INTRET            POSITION THE POST CODE
         SLL   PARAM2,EIGHT             (EXCEPTION CODES)
         LR    PARAM,DECBREG            LOAD ECB ADDRESS PARAMETER
         LA    PARAM,0(0,PARAM)         CLEAR TOP BYTE IN REG    A44088
         MVI   NULL(PARAM),NULL         AND CLEAR THE OLD POST CODE AND
         POST  (1),(0)                  POST.
         B     RSTOR                    GO RESTORE REGISTERS AND RETURN
*
OPSMSK   DC    F'6'                     OPTIONS-READX,DYNAMIC BFR.
INVREQ   DC    H'4096'                  INVALID REQUEST BIT
K49      DC    H'49'                    CONSTANT 49
PREFSZ   DC    H'8'                     SIZE OF IOB PREFIX
IOBASWA  DC    H'4'                     DISPLACEMENT TO SWA ADDRESS
*
*   THE FOLLOWING EQUATES SHOW THE INCREMENT WHICH MUST BE ADDED TO
*   THE BASE SIZE OF THE IOB FOR A PARTICULAR OPTION.
*
RNDI     EQU   32                       NEXT ADDRESS TYPE DI
RNDK     EQU   40                       NEXT ADDRESS TYPE DK
WCADD    EQU   48                       WRITE VERIFY WITH WRITE ADD
WCUPDTDI EQU   40                       WRITE VERIFY TYPE DI UPDATE
WCUPDTDK EQU   24                       WRITE VERIFY TYPE DK UPDATE
WCUPDTES EQU   32                       WRITE VERIFY WITH EXTENDED SRCH
EXTNDSCH EQU   128                      EXTENDED SEARCH
WRTADD   EQU   104                      WRITE ADD
EXCNTRL  EQU   28                       EXCLUSIVE CONTROL
RDDIORDK EQU   32                       READ (NO EXTENDED SEARCH)
WRDIORDK EQU   40                       WRITE (NO EXTENDED SEARCH)
         SPACE 3
INVID    DC    X'08'                   INVALID ZERO ID
INVOPT   DC    X'02'                   INVALID OPTIONS
INVWRT   DC    X'40'                   WRITE TO INPUT DATA SET
INVLIMCT DC    X'20'                   EXTENDED SEARCH, LIMIT IS ZERO
NOSWACD  DC    X'00'                    NO SWA INDICATION         21905
*
INVKEY   DC    X'04'                    KEYS ARE MISSING
AVLMSK   EQU   X'80'                    IOB AVAILABILITY FLAG
ZEROS    EQU   OPSMSK                   PLUS ZEROS FOR COMPARING.
MIXED    EQU   4
ONE      EQU   1
IDDISP   EQU   7                        DISPLACEMENT OF BLOCK ID
IDOFZERO EQU   0                        ZERO BLOCK ID
ROFTTR   EQU   2                        DISPLACEMENT OF R IN TTR
CNVENTRY EQU   4                        ENTRY IN ADDR CNVRT RTN  Y02072
NONZERO  EQU   7
TWO      EQU   2
AVLABLE  EQU   0                        IOB AVAILABLE SETTING
WRTMSK   EQU   15                       DCB WAS OPENED FOR
*                                        OUTPUT OF UPDATE
CCWLN    EQU   8                        LENGTH OF A CCW
RALEN    EQU   4                        LENGTH OF RECORD AREA POINTER
RADSP    EQU   4                        DISPLACEMENT OF R.A. PTR IN SWA
RAINC    EQU   8                        DISPLACEMENT OF B.I. IN SWA
RAINCLN  EQU   2                        LENGTH OF B.I. FIELD IN SWA
NULL     EQU   0                        ZERO CONST. FOR REGISTER INSTR.
RCDRYM   EQU   X'40'                    RCD READY MASK/BIT       20201
OPTOFF   EQU   17                       OFFSET IN UCB TO OPTION  20201
*                                       CDE                      20201
RCDRY    EQU   X'10'                    RCD READY BIT IN OPTION  20201
*                                       FLD                      20201
SETSC    EQU   X'23'                    SET SECTOR CCW COMMAND   20201
RDSC     EQU   X'22'                    READ SECTOR CCW COMMAND  20201
CPFLAG   EQU   X'42'                    SET UNRELATED, COMMAND CHAIN
NOPCODE  EQU   X'03'                    NO OP
FT       EQU   42
FZ       EQU   40
SEVN     EQU   7
         DROP DECBREG                                             21905
         DROP DEBREG                                              21905
         DROP IOBREG,FDNBASE,DCBREG                              Y02072
         TITLE 'IGG019KJ - BDAM VRE FOUNDATION MODULE  - ASI ROUTINE'
*
*
*  ASYNCHRONOUS INTERRUPT ROUTINE
*   THIS ROUTINE IS ENTERED BY THE SUPERVISOR SO THAT BDAM MAY
*   COMPLETE THE PROCESSING OF A REQUEST.
*   BDAM EXPECTS THE FOLLOWING REGISTER USAGE'
*            1 RQE ADDRESS
*           14 RETURN POINT
*           15 ENTRY POINT OF THIS ROUTINE
*
         USING IECDFDNA,EPREG
*
*
SWAPTR   EQU   2
RIOB     EQU   2                        IOB ADDRESS
DATALN   EQU   3                        DATA LENGTH REGISTER
MVCLNGTH EQU   3                        RECORD LENGTH
TOTLN    EQU   4                        TOTAL LENGTH REGISTER
RAPTR    EQU   5                        RECORD AREA POINTER
POSINRA  EQU   6                        POINTER TO NEXT DATA BYTE IN
*                                       THE RECORD AREA
FROMADR  EQU   6                        POINTER TO RECORD TO BE MOVED
RRQE     EQU   7                        RQE BASE REG             Y02072
CPSTART  EQU   8                        CHANNEL PROGRAM STARTING ADDR.
TOADR    EQU   9                        POINTER TO RECORD DESTINATION
DECBPTR  EQU   10                       DECB POINTER
READADD  EQU   10                       ENTRY POINT REG FOR READX & ADD
RETFMOVE EQU   14                       RETURN ADDRESS
WORKR2   EQU   14                       WORK REGISTER IN ASI ROUTINE
WORKR1   EQU   15                       WORK REGISTER IN ASI ROUTINE
*
IECDFDNA B     DASIA                    ENTRY FROM SUPERVISOR
         B     DASIB                    ENTRY FROM SELF-FORMAT
*                                       TO POST IOB
*                   NOTE:  THIS ENTRY ASSUMES THAT THERE MAY BE AN IOB
*                          ADDR SAVED IN REG 6 WHICH MUST BE MAIN-
*                          TAINED THROUGHOUT ASI PROCESSING ON THIS
*                          PATH. CONTROL IS THEN RETURNED TO 19KN VIA
*                          THE ADDR PUT IN IOBDQPTR BY 19KN.
         B     DASIC                    ENTRY TO CLEAN UP AND RETURN
*
DASIA    EQU   *
         LR    FDNBASE,EPREG            BASE TO TRANSPARENT REG  Y02072
         DROP  EPREG                    DROP ENTRY BASE REG      Y02072
         USING IECDFDNA,FDNBASE         ESTABLISH NEW BASE       Y02072
         LR    RRQE,PARAM               SAVE IOS RQE ADDRESS     Y02072
         USING RQE,RRQE                 ESTABLISH RQE BASE       Y02072
         L     PARAM,RQEIOB             GET IOB ADDRESS FROM RQE Y02072
         USING IOBSTDRD,PARAM           ESTABLISH IOB BASE       Y02072
         L     SAVE,IOBDCBPT            GET DCB ADDR FROM IOB    Y02072
         USING IHADCB,SAVE              ESTABLISH DCB BASE       Y02072
         LR    INTRET,RETREG            MOVE SUPERVISOR RETURN ADDRESS
         L     DECBPTR,IOBECBPT         GET DECB ADDRESS          21905
         USING DECBDEF,DECBPTR                                    21905
*
***********************************************************************
*  THE FOLLOWING ROUTINE LINKS IOBS TO THE DCB POOL IF THEY WERE      *
*  OBTAINED BY GETMAIN. THEY ARE ADDED IN ORDER OF INCREASING SIZE.   *
***********************************************************************
*                        POOL THE IOB                            Y02072
         L     WORKR1,IOBDPLAD          WAS IOB FROM POOL OR     Y02072
         LTR   WORKR1,WORKR1            OBTAINED BY GETMAIN      Y02072
         BNZ   INPOOL                   IF NOT 0,ALREADY IN POOL Y02072
*
*                        ADD NEW IOB TO IOB POOL                 Y02072
         MVI   IOBDAYLI,UNAVALSW        MARK CURRENT IOB UNAVAIL Y02072
*                                       ABLE BEFORE ADD TO POOL  Y02072
         LA    PARAM,0(0,PARAM)         INSURE 0 HI-ORDER BYTE   A30797
         L     WORKR1,DCBIOBAD          PUT DCB POOL ADDRESS IN
         LA    WORKR2,NULL(WORKR1)      BOTH WORK REGS.
LOOP     LA    WORKR1,NULL(WORKR1)      CLEAR HI BYTE.
         LTR   WORKR1,WORKR1            ANY IOB'S BEYOND THIS.
         BZ    TSTEQ                    NO, GO TEST FOR FIRST IOB
*
*   PUT IOB ON POOL IN ORDER OF INCREASING SIZE. PUT NEW IOB IN QUEUE
*   AS THE FIRST IOB IN THAT SIZE GROUP.
*
         CLC   IOBDIOBS,IOBDIOBS-IOBSTDRD(WORKR1)
         BH    SEENEXT1                 NEW IOB IS LARGER
         IC    PARAM2,IOBDAYLI          SAVE AVAILABILITY BYTE   Y02072
         SLL   PARAM2,SHFT3BYT          WHILE STORING INTO       Y02072
         OR    WORKR1,PARAM2            IOB CHAINING FIELD       Y02072
         ST    WORKR1,IOBDPLAD          STORE NXT IOB ADDR IN    A30797
         LA    WORKR1,0(WORKR1)         CLR TOP BYTE TO COMPARE  Y02072
TSTEQ    CR    WORKR1,WORKR2            IF EQUAL, THIS IOB IS THE
         BE    FIRSTIOB                 FIRST ONE TO BE POOLED
*
*   RELINK THE POOL CHAIN WITHOUT DESTROYING THE AVAILABILITY FLAG.
*
         IC    PARAM2,IOBDAYLI-IOBSTDRD(WORKR2)                   21905
         SLL   PARAM2,SHFT3BYT
         OR    PARAM,PARAM2                                       21905
         ST    PARAM,IOBDPLAD-IOBSTDRD(WORKR2)
         LA    PARAM,0(PARAM)           CLEAR TOP BYTE-NOT NEG   YM1458
         B     INPOOL                   CONTINUE IOB PROCESSING  Y02072
*
FIRSTIOB ST    PARAM,DCBIOBAD           INSERT THIS IOB AS TOP OF CHAIN
         B     INPOOL                   CONTINUE IOB PROCESSING  Y02072
SEENEXT1 LR    WORKR2,WORKR1            SAVE THE ADDRESS OF PRIOR LINK,
         L     WORKR1,IOBDPLAD-IOBSTDRD(WORKR1)  LOAD THE ADDRESS OF
*                                       THE NEXT IOB IN POOL
         B     LOOP                     GO TEST LINK ADDRESS = ZERO
*
*
*
INPOOL   EQU   *                        TEST FOR ERRORS          Y02072
         TM    IOBSTAT1,IOBNEWVL        DID END OF EXTENT CAUSE ASI
         BZ    TSTERR                   NO, CONTINUE LOOKING FOR CAUSE.
         XI    IOBSTAT1,IOBNEWVL+IOBABNRM YES,CLEAR EXCP AND ABN BITS
         L     DECBPTR,IOBECBPT         GET USER ECB ADDRESS     Y02072
         ST    DECBPTR,IOBDQPTR         SAVE IT IN IOB, TO BE    Y02072
*                                       RESTORED BY CEA OR EOE   Y02072
         LA    WKREG2,IOBCSW+3          GET CSW ADDRESS TO USE   Y02072
         ST    WKREG2,IOBECBPT          AS DUMMY ECB FOR IOS     Y02072
         EXCP  (1)                      RESTART THE CHANNEL PROGRAM
         BR    INTRET                   GO BACK TO SUPERVISOR.
*
TSTERR   EQU   *                        TEST FOR ERROR           Y02072
         DROP  RRQE                                              Y02072
         ST    INTRET,IOBDQPTR          SAVE SUPVERVISOR RETURN IN IOB.
         LR    INTRET,PARAM             PUT IOB ADDR INTO READX REG
         LR    SWAPTR,PARAM             *
         SH    SWAPTR,FOUR               * SET UP SWA POINTER
         L     SWAPTR,NULL(SWAPTR)       *
         USING SWA,SWAPTR               *
         L     CPSTART,IOBSTART         SET UP CHANNEL PROGRAM ADDRESS
         TM    IOBSTAT1,IOBABNRM        WAS THIS ABNORMAL COMPLETION
         BO    ASIERR                   BRANCH IF YES
*
GOODCMPL EQU   *
         L     RAPTR,SWARAPT            SET UP RECORD AREA POINTER
         LR    POSINRA,RAPTR
         TM    IOBDTYPE,IOBDYNBF        IS DYN BUF BEING USED   XA00093
         BNO   NOTDYNBF                 NO, BR AROUND           XA00093
         TM    IOBDTYP2,IOBTYPE         IS THIS READ BY BLK ID  XA00093
         BO    NOTDYNBF                 NO, BR AROUND           XA00093
         TM    IOBDTYP2,IOBSKEY         WAS KEY ADDR CODED 'S'  XA00093
         BZ    NOTDYNBF                 NO, BR AROUND           XA00093
         SR    POSINRA,POSINRA          CLEAR REG TO GET KEY    XA00093
         IC    POSINRA,DCBKEYLE         LENGTH IN DCB.KEY WAS   XA00093
         AR    POSINRA,RAPTR            READ INTO RECORD AREA   XA00093
         LR    RAPTR,POSINRA            SO NEED OFFSET TO       XA00093
*                                       MOVE DATA.              XA00093
NOTDYNBF EQU   *                                                XA00093
         AH    POSINRA,SWABFINC         POINT TO NEXT DATA BYTE
         SR    DATALN,DATALN
         SR    TOTLN,TOTLN
         L     WORKR1,IOBCSW-1          GET LAST CCW ADDRESS
         SH    WORKR1,H8                BACK UP ONE CCW
         TM    DECTYPE+ONE,READ         IS THIS A READ REQUEST
         BZ    WRITEREQ                 BR IF NO
         CLI   NULL(WORKR1),NOPCODE     IS IT A NOP CCW
         BE    NATST                    BR IF YES
         TM    IOBDTYPE,IOBRDEXC        IS THIS A READ EXCLUSIVE CNTRL.
         BZ    ASIREAD                  BR IF NO
         TM    IOBSTAT1,IOBENQUE        HAS RECORD BEEN ENQ'D YET
         BZ    ENQUEUE                  GO ENQ IF NOT
ASIREAD  EQU   *
         TM    DECTYPE+ONE,KEY          IF TYPE IS DK,
         BO    ASIREAD2                 BR AROUND READ R0 TEST
         CLI   IOBR,NULL                SEE IF THIS WAS A READ ON R0
         BNE   ASIREAD2                 BR IF NOT
         LH    DATALN,DECLNGTH
         EX    DATALN,MOVER0            MOVE R0 TO THE RECORD AREA
         B     ISITNA                   SEE IF NEXT ADDRESS IS REQ'D
*
MOVER0   MVC   NULL(NULL,RAPTR),SWABDW  * EXECUTED *   MOVE R0
*
ASIREAD2 EQU   *
         LH    DATALN,SWABDW            GET SEGMENT LENGTH
         SH    DATALN,H8                SUBTRACT 8 FROM DATA LENGTH
         LH    TOTLN,SWABFINC
         AR    TOTLN,DATALN             ADD LL-8 TO TOTAL
*
         TM    SEGFLGS,FIRSTSEG         IS THIS A FIRST SEGMENT
         BO    VERMID                   BR IF NO
         CR    RAPTR,POSINRA            IF ANOTHER SEG HAS BEEN READ
         BNE   BADFLGS                  GO SET ERROR FLAG BECAUSE THE
*                                       SEG CONTROL FLAGS ARE BAD.
         MVC   NULL(SEGDATA-SWABDW,RAPTR),SWABDW  MOVE DESCRIPTORS
         LA    POSINRA,SEGDATA-SWABDW(POSINRA)    UPDATE DATA POINTER
         LA    TOTLN,SEGDATA-SWABDW(TOTLN)        UPDATE DATA COUNT
NOTFIRST LR    TOADR,POSINRA            *  SET UP FOR
         LA    FROMADR,SEGDATA          *     DATA MOVE
         CH    TOTLN,DECLNGTH           WAS TOO MUCH DATA READ
         BNH   NOTTM                    BR IF NO
         LR    DATALN,TOTLN             TOTAL INDICATED IN BDW    21905
         SH    TOTLN,DECLNGTH           EXCESS OVER MAX REC LNGTH 21905
         SR    DATALN,TOTLN             ONLY MOVE TO MAX RECLNGTH 21905
         BAL   RETFMOVE,MOVE            MOVE THE SEGMENT DATA TO
*                                           THE RECORD AREA
         B     BADFLGS                  GO TO SET ERROR FLAG      21905
VERMID   EQU   *
         CR    RAPTR,POSINRA            SINCE THIS IS NOT A FIRST SEG,
         BNE   NOTFIRST                 MAKE SURE A SEG HAS ALREADY
*                                       BEEN READ.  IF NOT, SET ERROR.
BADFLGS  EQU   *
         OI    IOBSTAT1,IOBABNRM        SET ABNORMAL COMPLETION
         B     SETLGNCK                 GO SET WRONG LENGTH RECORD
NOTTM    BAL   RETFMOVE,MOVE            MOVE THE SEGMENT DATA TO
*                                        THE RECORD AREA
         STH   TOTLN,SWABFINC           STORE BUFFER INCREMENT
         MVC   NULL(TWO,RAPTR),SWABFINC UPDATE LL IN RECORD AREA
         CH    TOTLN,DECLNGTH           BR IF THE REQUIRED NUMBER OF
         BE    LASTRD                   BYTES HAVE BEEN READ
         TM    SEGFLGS,LASTSEG          WAS THIS THE LAST SEGMENT
         BZ    LASTRD                   BR IF LAST
         TM    SEGFLGS,FIRSTSEG         IS THIS A FIRST SEGMENT
         BO    MIDREAD                  BR IF NO
         TM    DECTYPE+ONE,KEY          IS TYPE = DK
         BO    FRSTDK                   BR IF YES
         CLI   DCBKEYLE,NULL            IS KEY LENGTH ZERO IN DCB
         BE    MIDREAD                  BR IF YES, CHNL PROG IS OK
         L     WORK3,DECKYADR
         LTR   WORK3,WORK3              IS KEY ADDRESS SPECIFIED
         BZ    MIDREAD                  BR IF NO, CHNL PROG IS OK
         L     WORKR1,IOBDCPND          GET CHNL PROG ENDING ADDR.
         SH    WORKR1,SIXTEEN           BACK UP TWO CCW'S
         MVC   NULL(CCWLN,WORKR1),CCWLN(WORKR1)  MOVE LAST CCW UP ONE
*                                       POSITION TO BYPASS KEY READ
         LA    WORKR1,CCWLN(WORKR1)     ESTABLISH NEW CHANNEL PROGRAM
         ST    WORKR1,IOBDCPND               ENDING ADDRESS
         B     MIDREAD                  SET UP FOR NEXT READ
FRSTDK   EQU   *
         TM    DECTYPE,EXSCH            TEST FOR EXTENDED SEARCH
         BO    FRSTES                   BR IF YES
         USING READDK1,CPSTART          SET UP CHANNEL PROGRAM DSECT
*
         LR    WORKR1,PARAM             GET IOB PTR              20201
         SH    WORKR1,H8                BACK UP TO PREFIX        20201
         TM    NULL(WORKR1),RCDRYM      RCD READY USED           20201
         BNO   NOTRRA1                  BRANCH IF NO             20201
         LA    WORKR1,RDK1NOP2          GET 2ND NOP ADDR         20201
         TM    DECTYPE+ONE,NEXTADR      NEXT ADDR REQUESTED      20201
         BZ    NOADDX                   BRANCH IF NO             20201
         LA    WORKR1,RDK1NOP3+BIT8     GET SECTOR ADDR          20201
NOADDX   EQU   *                                                 20201
         ST    WORKR1,RDK1NOP1          PUT IN SECTOR ADDR       20201
         MVI   RDK1NOP1,SETSC           SET SECTOR CMND          20201
         B     FEATA1                   GO AROUND NEXT           20201
NOTRRA1  EQU   *                                                 20201
         MVI   RDK1NOP1,NOPCODE         MAKE CCW1 A NOP          20201
FEATA1   EQU   *                                                 20201
         LA    WORKR1,IOBCC             *
         ST    WORKR1,RDK1SIE1           *   CONSTRUCT SEARCH-ID-EQUAL
         MVI   RDK1SIE1,SIEOP           *    CCW
         MVI   RDK1SIE1+BYTE7,FIVE      *    SET COUNT TO FIVE
*
         LA    WORKR1,RDK1SIE1          *
         ST    WORKR1,RDK1TIC1           *   CONSTRUCT A TIC CCW
         MVI   RDK1TIC1,TICOP           *
         B     MIDREAD                  SET UP FOR NEXT READ
FRSTES   EQU   *
         MVC   IOBDNCRF+SEVN(ONE),IOBSEEK   SAVE EXTENT NUMBER
         MVC   SAVEID+TWO(TWO),IOBDSTAT SAVE THE IOB STATUS
         USING READES1,CPSTART          SET UP CHANNEL PROGRAM DSECT
         MVC   RE1RD,RERD-RENOP1(CPSTART) MOVE READ DATA CCW TO CCW4
         LA    WORKR1,RE1NOP2           SET NEW EXPECTED CHANNEL END
         ST    WORKR1,IOBDCPND               IN IOB
         MVC   IOBCC(CCHHLN),DNRCFP2    MOVE NEW CCHH TO IOBSEEK+3
MIDREAD  EQU   *
         BAL   WORK3,ADD1RTN            INCREMENT TRACK NBR BY ONE
         MVI   IOBR,R1                  SET R OF MBBCCHHR TO 1
         TM    IOBDTYP2,IOBADDTY+IOBTYPE  IS THIS TYPE DI
         BC    ONE+MIXED,AFTDITST       BR IF NOT
         MVC   IOBUPLIM+THREE(EQU4),IOBCC
         B     EXCPAGN                  GO EXCP
AFTDITST EQU   *
         TM    IOBDTYP2,IOBADDTY        IS THIS A WRITE ADD
         BZ    EXCPAGN                  BR IF NO
         MVC   IOBDNCRF(FIVE),IOBCC     MOVE CCHHR TO COUNT FIELD
         MVC   IOBCHNPR+(WASIE1-WRITEADD)+THREE(EQU4),IOBCC
*                                       MOVE CCHH TO OLD CCW2
*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *
EXCPAGN  EQU   *                        READ OR WRT NEXT SEGMENT
         L     DECBPTR,IOBECBPT         GET USER ECB ADDRESS     Y02072
         ST    DECBPTR,IOBDQPTR         SAVE IT IN IOB, TO BE    Y02072
*                                       RESTORED BY CEA OR EOE   Y02072
         LA    WKREG2,IOBCSW+3          GET CSW ADDRESS TO USE   Y02072
         ST    WKREG2,IOBECBPT          AS DUMMY ECB FOR IOS     Y02072
         EXCP  (1)                      RESTART THE CHANNEL PROGRAM
         SVC   EXIT                     EXIT
*
*   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *   *
LASTRD   EQU   *
         SH    TOTLN,FOUR
         STH   TOTLN,SWABFINC           PUT DATA LENGTH IN SEGMENT
         MVC   SDW(TWO,RAPTR),SWABFINC  DESCRIPTOR WORD
ISITNA   TM    DECTYPE+ONE,NEXTADR      IS NEXT ADDRESS REQUESTED
         BZ    DASIB                    BR IF NO
         MVC   SAVEID+TWO(TWO),IOBDSTAT SAVE THE IOB STATUS
         NC    IOBDSTAT,CLRSTAT         CLEAR OUT CURRENT STATUS
         TM    DECTYPE+ONE,KEY          IS TYPE = DK
         BO    NADK                     BR IF YES
         MVC   SAVEID(ONE),IOBR         SAVE ID OF CURRENT RECORD
         MVC   SWABDW(FIVE),DNRCFP2     SAVE CCHHR FROM CAPACITY RCD.
         USING READDI0N,CPSTART
         MVC   RDINASI1,RDINASI2        MOVE CCW5 TO CCW2
         LA    WORKR1,SWABDW            *
         ST    WORKR1,RDINARD            * PUT SWA ADDR IN CCW4
         MVI   RDINARD,READCCW          *
         MVI   RDINASI2,NOPCODE         MAKE CCW5 A NOP
         MVI   RDINASI2+FLAGS,SWL       SET NOP FLAGS
         B     GETNA                    CALCULATE NEXT ADDRESS
NADK     EQU   *
         MVI   IOBR,NULL                SET R=0 IN IOBSEEK
         TM    SEGFLGS,FIRSTSEG         WAS THIS A ONE SEGMENT RECORD
         BO    MIDNADK                  BR IF NO
         MVC   IOBCC(EQU4),DNRCFP2      MOVE CCHH TO IOBSEEK+3
         MVC   SAVEID(ONE),IOBDNCRF+SIX SAVE ID OF CURRENT RECORD
         TM    DECTYPE,EXSCH            TEST FOR EXTENDED SEARCH
         BZ    NADKNES                  BR IF NOT
         USING READES1,CPSTART          SET UP CHANNEL PROGRAM DSECT
         MVC   RE1RD(CCPADR),RERD-RENOP1(CPSTART) MOVE READ DATA TO CCW
MIDNAES  EQU   *
         MVI   RE1RD+FLAGS,COMCHAN+SWL  SET FLAGS
         MVC   RE1NOP2,RENOP2-RENOP1(CPSTART) MAKE CCW5 A NOP
         B     EXCPAGN                  EXCP FOR NEXT ADDRESS
MIDNADK  EQU   *
         MVI   SAVEID,ONE               SAVE ID OF LAST SEGMENT
         TM    DECTYPE,EXSCH
         BZ    NADKNES                  BR IF NOT EXTENDED SEARCH
         MVC   RE1RD+SIX(TWO),RE1SIDE+SIX  SET READ LENGTH TO FIVE
         B     MIDNAES                  GO FINISH THE CCW'S
NADKNES  EQU   *
         USING READDK1,CPSTART          SET UP CHANNEL PROGRAM DSECT
         LA    WORKR1,RDK1NOP2
         ST    WORKR1,IOBSTART          SET NEW CHNL PROG START ADDR
         B     EXCPAGN                  EXCP FOR NEXT ADDRESS
NATST    EQU   *
         TM    DECTYPE+ONE,NEXTADR      IS NEXT ADDRESS REQUESTED
         BZ    ASIERR2                  BR IF NO
         SH    WORKR1,H8
         CLI   NULL(WORKR1),TICOP       WAS THE PRECEDING CCW A TIC
         BE    ASIERR2                  BR IF YES
GETNA    EQU   *
*
*  AT THI POINT, THE SWA CONTAINS THE CCHHR OF THE LAST BLOCK ON THE
*  TRACK IN THE FIRST 5 BYTES AND THE ID OF THE LAST BLOCK READ IN THE
*  6TH BYTE.
*
         MVC   IOBDSTAT,SAVEID+TWO      RESTORE IOB STATUS
         CLC   SAVEID(ONE),SWABDW+CCHHLN WAS THIS THE LAST BLOCK ON
*                                        THE TRACK
         BNE   NEXTTID                  BR IF NOT
         BAL   WORK3,ADD1RTN            INCREMENT TRACK NBR BY ONE
         L     DECBPTR,IOBECBPT         RESTORE DECB POINTER
         TM    DECTYPE+ONE,TYPERU       IS TYPE = RU
         BM    NOTRU                    BR IF NO
ACTTST   EQU   *
         TM    IOBDTYPE,IOBACTAD        IS ACTUAL ADDRESSING USED
         BO    ACTNA                    BR IF YES
*
*  THE FOLLOWING ROUTINE WILL CONVERT THE MBBCCHHR ADDRESS IN IOBSEEK
*  TO A RELATIVE TTR BY USING THE RESIDENT CONVERSION ROUTINE IECPRLTV.
*
         STM   WREG9,ACTADR,IOBCHNPR    SAVE REGISTERS USED
         LA    ACTADR,IOBSEEK           SET ACTUAL ADR. PARAMETER
         L     PARAM,DCBDEBAD           SET DEB ADDRESS
         L     IECPRLTV,CVTPTR          GET ADDR OF CONVERSION ROUTINE
         L     IECPRLTV,APRLTV(IECPRLTV)     FROM THE CVT.
         BALR  RETREG,IECPRLTV          GO TO CONVERSION ROUTINE
*
         ST    CONVID,IOBDCPND-IOBSEEK(ACTADR) SAVE THE RETURNED TTR0
         LM    WREG9,ACTADR,IOBCHNPR-IOBSEEK(ACTADR) RESTORE THE REGS
         L     WORKR1,DECNA
         MVC   NULL(TTRLN,WORKR1),IOBDCPND MOVE TTR TO USER AREA
         B     DASIB                    NEXT ADDRESS FEEDBACK COMPLETED
*
NEXTTID  EQU   *
         IC    WORKR1,SAVEID            *
         LA    WORKR1,ONE(WORKR1)        * ADD 1 TO R IN IOBSEEK
         STC   WORKR1,IOBR              *
         B     ACTTST                   GO SUPPLY NEXT ADDRESS
NOTRU    EQU   *
         MVI   SAVEID,NULL              SET CURRENT ID TO ZERO
         NC    IOBDSTAT,CLRSTAT         CLEAR IOB STATUS
         B     EXCPAGN                  GO READ NEXT CAPACITY RECORD
ACTNA    EQU   *
         L     WORKR1,DECNA
         MVC   NULL(ACTLN,WORKR1),IOBSEEK MOVE MBBCCHHR TO USER AREA
         B     DASIB                    NEXT ADDRESS FEEDBACK COMPLETED
*
*
WRTDONE  EQU   *
         TM    IOBDTYP2,ADD             WAS THIS A WRITE ADD     Y02072
         BZ    DASIB                    BR IF NO
         L     READADD,DCBDFOR          GET ADDRESS OF ADD MODULE AND
         B     ADDDONE(READADD)         BRANCH TO IT
*
USETRKCP EQU   *
         LH    DATALN,TRKLN(DTABREG)    SET SEGMENT LNGTH TO TRACK SIZE
RPSDEV1  EQU   *                                                 20201
         MVI   SEGFLGS,MIDSEG           SET FLAGS TO MIDDLE SEGMENT
         B     AFTRFLG                  GO FINISH WRITE SETUP
WRITEREQ EQU   *
         CLI   NULL(WORKR1),READCCW     WAS LAST CCW A READ DATA
         BNE   SUBSQWRT                 BR IF NO
         CLC   CNTOFF(CNTLN,WORKR1),H7  WAS DATA LENGTH = 7
         BNE   FRSTWRT                  BR IF NO
         TM    IOBSTAT1,IOBENQUE        IS RECORD ENQ'ED YET
         BZ    ENQUEUE                  GO ENQUEUE IF NO
KNP8EXIT L     READADD,DCBDFOR          GET BASE OF SELF-FORMAT MODULE
         B     ADDSRCH(READADD)         AND BRANCH TO IT
SUBSQWRT EQU   *
         SH    WORKR1,H8                BACK UP ONE CCW
         CLI   NULL(WORKR1),READCCW
         BE    FRSTWDK                  BR IF ENTRY FROM FIRST WRITE DK
         LH    DATALN,DECLNGTH          GET TOTAL DATA LENGTH FROM DECB
         SH    DATALN,SWABFINC          SUBTRACT LENGTH WRITTEN SO FAR
         BZ    WRTDONE                  BR IF ALL OF RECORD IS DONE
         AH    DATALN,H8
         BAL   RETREG,GETDVTB           GET A POINTER TO DEVICE TABLE
*                                       ENTRY
         LR    RETREG,PARAM             GET IOB ADDR             20201
         SH    RETREG,H8                POINT TO PREFIX          20201
         SR    TOADR,TOADR              ZERO OUT A COUPLE OF     20201
*                                       REGS                     20201
         SR    RETREG,RETREG                                     20201
         IC    RETREG,OVERI(DTABREG)    GET OVERHD               20201
         TM    BYTEDEV(DTABREG),TBOVHD  IS TWO BYTE OVHD USED    20201
         BNO   MZ0001                   IF NOT, OVHD IS O.K.     20201
         LH    RETREG,OVERI(DTABREG)    ELSE GET TWO BYTES       20201
MZ0001   EQU   *                                                 20201
         IC    TOADR,OVERK(DTABREG)     GET KEY OVERHEAD         20201
         SR    RETREG,TOADR             REC OVHD - KEY OVHD      20201
         LH    TOADR,TRKLN(DTABREG)     GET TRK CAPACITY         20201
         SR    TOADR,RETREG             TRK CAP - REC OVHD + KEY 20201
*                                       OVHD                     20201
         CR    DATALN,TOADR             WILL DATA FIT ON TRK     20201
         BNH   WALOON                   YES  THEN GO TO IT       20201
         LR    DATALN,TOADR             USE TRK LEN AS SEG LEN   20201
         B     RPSDEV1                  DO YOUR THING            20201
*
         CH    DATALN,TRKLN(DTABREG)    COMPARE DATA LENGTH WITH
*                                       TRACK CAPACITY
         BH    USETRKCP                 BR IF DATA LENGTH IS GREATER
*
*   THIS ROUTINE WILL CALCULATE THE REMAINING TRACK BALANCE AFTER
*   WRITING THE LAST SEGMENT.  THIS TRACK BALANCE WILL BE PLACED IN
*   THE UPDATED CAPACITY RECORD.
*
W2       EQU   9                        WORK REGISTER
W3       EQU   14                       WORK REGISTER
W4       EQU   15                       WORK REGISTER
*
*
WALOON   EQU   *                                                 20201
         SR    W3,W3                    *  ZERO WORK REGISTERS
         SR    W4,W4                    *
         LR    W2,DATALN                GET DATA LENGTH
         IC    W4,OVERK(DTABREG)        GET VALUE TO BE SUBTRACTED FROM
*                                       OVERHEAD FOR NON-KEYED RECORDS
         IC    W3,OVERI(DTABREG)        GET OVERHEAD FOR NOT LAST RCD.
         TM    BYTEDEV(DTABREG),TBOVHD  DEV WITH 2 BYTE OVHD     20201
         BNO   MZ0002                   NO, OVHD O.K.            20201
         LH    W3,OVERI(DTABREG)           GET 2 BYTES           20201
MZ0002   EQU   *                                                 20201
         MH    W2,TOLER(DTABREG)        MULTIPLY DATA LENGTH BY
         SRA   W2,NINE                  DIVIDE RESULT BY 512
         SR    W3,W4                    SUBTRACT NO-KEY OVERHEAD FROM
*                                       TOTAL OVERHEAD
         AR    W2,W3                    ADD OVERHEAD TO DATA LENGTH
         N     W2,ZEROH                 ZERO 2 HI ORDER BYTES
         LH    W3,TRKLN(DTABREG)        GET TRACK CAPACITY
         SR    W3,W2                    GET NEW TRACK BALANCE
         BM    ZEROTB                   SET TRK BAL TO 0 IF NEGATIVE
         STH   W3,IOBDBYTR              ELSE, STORE NEW TRK BALANCE
SETLAST  EQU   *
         MVI   SEGFLGS,LASTSEGF         SET FLAGS FOR LAST SEGMENT
AFTRFLG  EQU   *
         TM    DECTYPE+ONE,ADD+KEY      IS TYPE =DA OR DK
         BZ    DIWRT                    BR IF NEITHER (TYPE = DI)
         TM    DECTYPE+ONE,ADD
         BO    WRTADD2                  BR IF ADD
         TM    DECTYPE,EXSCH            TEST FOR EXTENDED SEARCH
         BO    ESWCHNG                  BR IF YES
         USING WRITEDK1,CPSTART
         CLI   WDK1NOP1,SETSC           RCD READY USED           20201
         BNE   NOTRRA9                  BRANCH IF NO             20201
         L     WORKR1,WDK1NOP1          GET SECTOR ADDR          20201
         MVI   NULL(WORKR1),NULL        SECTOR=0                 20201
NOTRRA9  EQU   *                                                 20201
*
         STH   DATALN,WDK1WD+CNTOFF     STORE DATA LENGTH IN WRITE CCW
FINWRT   EQU   *
         BAL   RETFMOVE,PREMOVE         MOVE DATA AND FILL IN BDW,SDW
         AH    TOTLN,SWABFINC           UPDATE THE BUFFER
         STH   TOTLN,SWABFINC            INCREMENT FIELD
         B     MIDREAD                  GO UP TRACK ADDRESS
ZEROTB   EQU   *
         XC    IOBDBYTR,IOBDBYTR        SET TRK BALANCE TO ZERO
         B     SETLAST                  GO SET SEGMENT FLAGS
ESWCHNG  EQU   *
         USING WRITEES1,CPSTART
         STH   DATALN,WEWD+CNTOFF       STORE DATA LENGTH IN WRITE CCW
         B     FINWRT                   GO MOVE DATA TO SWA
DIWRT    EQU   *
         USING WRITEDI1,CPSTART         SET UP CHANNEL PROGRAM DSECT
         SH    PARAM,H8                 IOB PREFIX               20201
         TM    NULL(PARAM),RCDRYM       RCD READY USED           20201
         BNO   NOTRRB1                  BRANCH IF NO             20201
         LA    WORKR1,WDI1NOP1+BYTE6    GET ZERO BYTE ADDR       20201
         ST    WORKR1,WDI1NOP1          PUT IN CCW               20201
         MVI   WDI1NOP1,SETSC           INSERT CMND              20201
NOTRRB1  EQU   *                                                 20201
         AH    PARAM,H8                 RESTORE IOB REG          20201
         CLI   WDI1WD,WDOP              IS CCW4 A WRITE DATA CCW
         BNE   WDIKEYS                  BR IF NO
         STH   DATALN,WDI1WD+CNTOFF     PUT SEG LNGTH IN CCW
         B     FINWRT                   CONTINUE WRITE PROCESSING
WDIKEYS  EQU   *
         LA    WORKR1,WDI1WDK           *
         ST    WORKR1,WDI1WKD            * MAKE CCW4 TIC TO CCW5
         MVI   WDI1WKD,TICOP            *
         STH   DATALN,WDI1WDK+CNTOFF    PUT SEG LNGTH IN CCW
         B     FINWRT                   CONTINUE WRITE PROCESSING
WRTADD2  EQU   *
         USING WRITADD1,CPSTART         SET UP ADD DSECT
         CLI   WA1SIE2,TICOP            IS CCW6 STILL A TIC
         BE    CHNGWA                   BR IF YES
FINWA    EQU   *
         STH   DATALN,WA1WD+CNTOFF      PUT SEG LNGTH IN CCW
         STH   DATALN,CNTDL             PUT SEG LNGTH IN COUNT FIELD
         B     FINWRT                   FINISH WRITE PROCESSING
CHNGWA   EQU   *
         MVC   WA1WC,WAWCKD1-WANOP2(CPSTART) MOVE WRITE COUNT CCW
         TM    WAKWK-WANOP2+FLAGS(CPSTART),DATACHAN  WERE KEYS WRITTEN
         BO    WAKEYS                   BR IF YES
         LA    WORKR1,WANKWD-WANOP2(CPSTART) POINT TO WRITE DATA CCW
MVCWD    EQU   *
         MVC   WA1WD,NULL(WORKR1)       MOVE IN WRITE DATA CCW
         MVI   WA1WD+FLAGS,COMCHAN      SET COMMAND CHAINING FLAG
         MVC   WA1SIE2(WA1WCR-WA1SIE2),WA1SIE  MOVE IN SEARCH ID EQUAL
*                                       AND TIC CCW'S
         LA    PARAM2,WA1SIE2           *
         ST    PARAM2,WA1TIC2            *  INSERT TIC ADDRESS
         MVI   WA1TIC2,TICOP            *
         LA    PARAM2,IOBCC
         ST    PARAM2,WA1WCR            PUT ADDR OF IOBSEEK+3 IN THE
*                                       CCW WHICH UPDATES R0
         MVI   WA1WCR,WDOP              INSERT WRITE DATA OP CODE
         MVC   WA1WCR+FLAGS(EQU4),WCRF  INSERT FLAGS AND DATA LENGTH
         TM    DECTYPE,VERIFY           WRITE CHECK REQUESTED
         BO    WAWC                     BR IF YES
ZEROKL   MVI   CNTKL,NULL               SET KEY LNGTH TO 0 IN COUNT FLD
         B     FINWA                    GO FINISH ADD PREPERATION
WAKEYS   EQU   *
         LA    WORKR1,WAKWD-WANOP2(CPSTART)  POINT TO WRITE DATA CCW
         B     MVCWD                    GO MOVE IN WRITE DATA CCW
WAWC     EQU   *
         MVC   WA1NOP2,WA1NOP1          MOVE IN NOP OR SET SECTOR=0
         MVC   WA1RR0,WANKRR0-WANKWD(WORKR1) MOVE IN READ R0 CCW
         OI    WA1RR0+FLAGS,COMCHAN     SET COMMAND CHAINING FLAG
         MVC   WA1RD,WANKRKD-WANKWD(WORKR1) MOVE IN READ-KEY-DATA CCW
         NI    WA1RD+FLAGS,COMCOFF      TURN OFF COMMAND CHAINING
         B     ZEROKL                   GO ZERO KEY LENGTH
FRSTWRT  EQU   *
         TM    DECTYPE+ONE,KEY          IS TYPE = DK
         BZ    FRSTWDI                  BR IF NO (TYPE = DI)
FRSTWDK  EQU   *
         MVC   IOBCC(FIVE),DNRCFP2      MOVE CCHHR TO IOBSEEK+3
         TM    DECTYPE,EXSCH            TEST FOR EXTENDED SEARCH
         BO    FRSTWES                  BR IF YES
         USING WRITEDK1,CPSTART         SET UP DSECT
         CLI   WDK1NOP2,RDSC            RCD READY IMPLEMENTED    20201
         BNE   NOTRRB9                  BRANCH NO                20201
         MVC   WDK1NOP1,WDK1NOP2        MOVE RD SECTOR TO CCW1   20201
         MVI   WDK1NOP1,SETSC           CHANGE CMND              20201
         MVI   WDK1NOP1+BYTE4,COMCHAN   CMND CHAIN CCW           20201
         MVI   WDK1NOP2,SETSC           CHANGE RD SECTOR TO SET  20201
         B     FEATB9                   SKIP NEXT INST           20201
NOTRRB9  EQU   *                                                 20201
         MVI   WDK1NOP1,NOPCODE         CCW1 A NOP               20201
FEATB9   EQU   *                                                 20201
         LA    WORKR1,IOBCC             *
         ST    WORKR1,WDK1SIE            * MAKE CCW2 A SEARCH-ID-EQUAL
         MVI   WDK1SIE,SIEOP            *
         MVI   WDK1SIE+BYTE7,FIVE       SET LENGTH TO 5          20201
         LA    WORKR1,WDK1SIE           *
         ST    WORKR1,WDK1TIC1           * MAKE CCW3 TIC TO CCW2
         MVI   WDK1TIC1,TICOP           *
         LA    WORKR1,WDK1WD            POINT TO WRITE DATA CCW
         MVI   WDK1WD+FLAGS,NULL        TURN OFF COMMAND CHAINING
         B     MAKEAWD                  GO CONSTRUCT WRITE DATA CCW
FRSTWDI  EQU   *
         USING WRITEDI1,CPSTART         SET UP DSECT
         LA    WORKR1,WDI1WD            POINT TO WRITE DATA CCW
         CLI   WDI1WDK,WDOP             ARE KEYS BEING WRITTEN
         BNE   MAKEAWD                  BR IF NO
         MVC   WDI1WKD(CCPADR),DECKYADR PUT KEY ADDR IN CCW
         MVI   WDI1WKD,WKDOP            MOVE IN WRITE-KEY-DATA OP CODE
         MVI   WDI1WKD+FLAGS,DATACHAN   SET DATA CHAINING FLAG
         MVC   WDI1WKD+CNTOFF+ONE(ONE),DCBKEYLE MOVE IN KEY LENGTH
         LA    WORKR1,WDI1WDK           POINT TO WRITE DATA CCW
         B     MAKEAWDL                 PUT LENGTH IN THE CCW
FRSTWES  EQU   *
         MVC   IOBDNCRF+SEVN(ONE),IOBSEEK  SAVE THE EXTENT NUMBER
         USING WRITEES1,CPSTART         SET UP DSECT
         OI    WE1NOP1+BYTE3,BYTE1      CHANGE ADDR IN CASE SET  20201
*                                       SECTOR
         LA    WORKR1,WEWD              *
         ST    WORKR1,WE1TIC2            * MAKE CCW4 A TIC TO CCW16
         MVI   WE1TIC2,TICOP            *
MAKEAWD  EQU   *
         LA    WREG9,SWABDW
         ST    WREG9,NULL(WORKR1)       PUT SWA ADDR IN WRITE CCW
         MVI   NULL(WORKR1),WDOP        PUT IN WRITE-DATA OP CODE
MAKEAWDL LH    DATALN,DECLNGTH          GET DATA LENGTH FROM USER
         CH    DATALN,SWABDW            IS THE LENGTH GREATER THAN THE
*                                       SIZE OF THE FIRST SEGMENT
         BH    USESEGLN                 BR IF YES
         MVI   SEGFLGS,NULL             SET FLAGS TO 00
ENDFW    EQU   *
         STH   DATALN,CNTOFF(WORKR1)    PUT DATA LENGTH IN THE CCW
         STH   DATALN,SWABFINC          PUT LENGTH IN BUF INCR FIELD
         LA    FROMADR,EIGHT(RAPTR)     POINT TO DATA TO BE MOVED
         BAL   RETFMOVE,PREMOVE         MOVE DATA AND FILL IN BDW,SDW
         TM    DECTYPE,VERIFY
         BZ    EXCPAGN                  BR IF NOT WRITE CHECK
         MVI   FLAGS(WORKR1),COMCHAN    SET COMMAND CHAINING FOR VERIFY
         TM    DECTYPE+ONE,KEY          IS TYPE =DK
         BZ    EXCPAGN                  BR IF NO
         OI    CCWLN+FLAGS(WORKR1),COMCHAN SET COMMAND CHAINING IN THE
*                                          NEXT CCW
         B     EXCPAGN                  WRITE THE SEGMENT
USESEGLN EQU   *
         LH    DATALN,SWABDW            USE SEG LENGTH AS DATA LENGTH
         MVI   SEGFLGS,ONE              INDICATE FIRST SEGMENT
         B     ENDFW                    INSERT DATA LENGTH IN CCW
*
*
*  THIS ROUTINE WILL MOVE A RECORD WHOSE LENGTH MAY EXCEED 256 BYTES
*
*
AMOVE    MVC   NULL(NULL,TOADR),NULL(FROMADR) MOVE LESS THAN 256 BYTES
*
MOVE256  MVC   NULL(FFF,TOADR),NULL(FROMADR)  MOVE 256 BYTES
         LA    TOADR,FFF(TOADR)
         LA    FROMADR,FFF(FROMADR)
*
MOVE     SH    MVCLNGTH,H256            IF SIZE IS GREATER OR EQUAL TO
         BH    MOVE256                   256, GO MOVE 256 BYTES
         AH    MVCLNGTH,H255            ELSE,
         EX    MVCLNGTH,AMOVE            MOVE REMAINING NBR OF BYTES
         BR    RETFMOVE                 RETURN TO CALLING SEQUENCE
*
*
PREMOVE  EQU   *
         STH   DATALN,SWABDW            PUT LENGTH IN BLK. DESCP. WORD
         SH    DATALN,FOUR
         STH   DATALN,SEGLL             PUT LENGTH IN SEG. DESCP. WORD
         SH    DATALN,FOUR
         LR    TOTLN,DATALN             SAVE ACTUAL DATA LENGTH
         LA    TOADR,SEGDATA
         B     MOVE                     MOVE THE DATA TO THE SWA
*
DASIB    TM    IOBDTYPE,IOBRDEXC+IOBFDBCK   IF NOT READ EXCLUSIVE OR
         BZ    DASIC                    FEEDBACK OPTION, SKIP NEXT RTN.
         TM    IOBDTYP2,IOBTYPE+IOBADDTY  IS TYPE = DI
         BC    ONE+MIXED,FDBKNDI        BRANCH IF NO
         TM    IOBDTYP2,IOBRQUST        IS THIS A READ
         BO    DASIC                    BRANCH IF YES
FDBKNDI  EQU   *
*
*  THE FOLLOWING ROUTINE LOCATES OR DEVELOPS ACTUAL ADDRESS FOR USE AS
*     FEEDBACK AND/OR READ EXCLUSIVE ARGUMENT
*
         TM    IOBSTAT1,IOBADDVU        IS THIS A SELF FORMAT ADD
         BO    TSTEXIT                  YES-SKIP MOVING FEEDBACK
         MVC   IOBBB2(SIX),IOBDNCRF+ONE  MOVE ACTUAL
         MVC   IOBM,IOBDNCRF+SEVN       RESTORE EXTENT NUMBER
*
*  IF THIS WAS A WRITE TO RELEASE AN EXCLUSIVE RECORD, GO TO THE READ
*   EXCLUSIVE MODULE WITHOUT TESTING FOR FEEDBACK TO BE RETURNED.
*
TSTEXIT  TM    IOBDTYP2,IOBRQUST        IS THIS A READ OR WRITE
         BO    TSTFDB                   READ, GO TEST FOR FEEDBACK
         TM    IOBDTYPE,IOBRDEXC        IF WRITE AND EXCLUSIVE BITS SET
         BO    RDXEXIT                  GO TO THE READX MODULE
TSTFDB   TM    DCBOPTCD,DCBOPTF         IF DCB DOES NOT SPECIFY
         BZ    ACTFDBK                  FEEDBACK
         TM    IOBDTYPE,IOBACTAD        OR ADDRESSING IS ACTUAL
         BZ    TSTRR                    RETURN
ACTFDBK  L     WORKR1,IOBECBPT          ACTUAL ADDRESS
         L     WORKR1,DECRECPT-DECBDEF(WORKR1)    AS
         MVC   NULL(EIGHT,WORKR1),IOBSEEK             FEEDBACK.
         B     DASIC                    GO TEST FOR DYNAMIC BUFFERING
         SPACE 2
***********************************************************************
*  THE FOLLOWING ROUTINE SETS UP FOR AND ISSUES SVC 53, THE EXCLUSIVE *
*  CONTROL MODULE.  THE FIRST EXIT IS TO GET EXCLUSIVE CONTROL OF     *
*  THE BLOCK JUST READ IN (FOR EITHER A READ EXCLUSIVE OR WRITE ADD   *
*  REQUEST.) THE SECOND EXIT IS TO RELEASE EXCLUSIVE CONTROL OF THE   *
*  BLOCK JUST WRITTEN OUT (WRITE RELEASE). IGC0005C EXPECTS THE IOB   *
*  TO BE IN REG 1 UPON ENTRY. THIS REGISTER WILL BE COMPLEMENTED.     *
***********************************************************************
ENQUEUE  EQU   *
         LCR   PARAM,PARAM               REG 1, IOB-COMPLEMENTED Y02072
*
         SVC   53                        GO ENQUEUE CURRENT REC  Y02072
*
         SVC   EXIT                      RETURN TO SUPERVISOR
RDXEXIT  EQU   *                         RELEASE CONTROL OF BLK  Y02072
         LR    IOBREG,PARAM              SAVE IOB REG ACROSS SVC Y02072
         LCR   PARAM,PARAM               REG 1, IOB-COMPLEMENTED Y02072
         DROP  PARAM                     DROP IOB BASE REG       Y02072
*
         SVC   53                        GO DEQUEUE CURRENT REC  Y02072
*
         LR    PARAM,IOBREG              RESTORE IOB REG         Y02072
         USING IOBSTDRD,PARAM            REESTABLISH ADDRESSING  Y02072
         B    DASIC                      NO, GO CHK DYN BUF      Y02072
***********************************************************************
*
TSTRR    LA    INTRET,DASIC             SET UP TO TEST FOR DYN. BUFF.
*                                       ON RETURN FROM ADDR CONVERSION
*
         L     EPREG,DCBREAD            LOCATE THE
         USING IGG019KJ,EPREG                                    A35339
         L     EPREG,RTAD               LOAD ADDR OF REL TRK MOD A35339
         DROP  EPREG                                             A35339
         BR    EPREG                    AND GO THERE (19KC+0)    Y02072
*
*
DASIC    EQU   *
         TM    IOBDTYPE,IOBDYNBF        TEST FOR DYNAMIC BUFFERING
         BO    ASIDB                    BR IF YES
         TM    DCBOPTCD,DCBOPTDB        SEE IF DYNAMIC BUFFERING IN DCB
         BZ    FREESWA                  BRANCH IF NO
*
*   THE SEGMENT WORK AREA WILL NOW BE RETURNED TO THE POOL
*
         LR    IOBREG,PARAM             SAVE IOB ADDRESS
         SH    PARAM,FOUR               GET ADDRESS OF IOB-4
         L     PARAM,NULL(PARAM)        GET SWA ADDRESS IN IOB
         SH    PARAM,H8                 GET BCB ADDRESS
         LH    PARAM2,SIX(PARAM)        GET BUFFER SIZE
         AH    PARAM2,H8                ADD BUFFER CONTROL BLOCK SIZE
         FREEMAIN R,LV=(0),A=(1)        FREE BUFFER
         LR    PARAM,IOBREG             RESTORE IOB REGISTER
         B     ASIDB                    CONTINUE
FREESWA  EQU   *
         LR    WORKR1,PARAM
         SH    WORKR1,FOUR              GET SWA ADDRESS
         L     WORKR1,NULL(WORKR1)
         MVI   NULL(WORKR1),NULL        MAKE SWA AVAILABLE
*
ASIDB    EQU   *
         TM    IOBDTYP2,IOBRQUST        IS THIS A READ REQUEST
         BO    MAKEAVL                  YES- MAKE IOB AVAILABLE  Y02072
         TM    IOBDTYPE,IOBDYNBF        NO-TEST FOR DYN. BUFFERING
         BZ    MAKEAVL                  NO- MAKE IOB AVAILABLE   Y02072
*
*                       FREE DYNAMIC BUFFER
*
         LR    SAVE,PARAM               SAVE IOB POINTER         A30797
         L     PARAM2,IOBECBPT          ADDR OF DECB             A30797
         L     PARAM,IOBDCBPT           ADDR OF DCB              A30797
         FREEDBUF (0),D,(1)             FREE THE BUFFER          A30797
         LR    PARAM,SAVE               RESTORE IOB POINTER      A30797
         L     SAVE,IOBDCBPT            RESTORE DCB POINTER      A30797
         USING IHADCB,SAVE                                       A30797
*
*   THE FOLLOWING ROUTINE ZEROES THE AVAILABILITY BYTE IN THE IOB
*   AND POSTS THE ECB COMPLETE.
*
MAKEAVL  SR    PARAM2,PARAM2            CLEAR FOR EXCEPTION CODES.
         IC    PARAM2,IOBSTAT2          INSERT EXCEP. CODES FROM IOB
         SLL   PARAM2,HIPOS             POSITION THEM FOR POST.
         LR    RIOB,PARAM               SAVE IOB REG IN POST     Y02072
         DROP  PARAM,SWAPTR             DROP PREVIOUS BASES      Y02072
         USING  IOBSTDRD,RIOB           NEW BASE FOR IOB         Y02072
         L     FDNBASE,IOBDQPTR         LOAD SAVED SUPER RETURN  YM5969
         L     PARAM,IOBECBPT           SET DECB PARAMETER
*
         POST  (1),(0)                  POST.
         TM    DCBMACRF,DCBMRCK         IS CHECK MACRO SPECIFIED Y02072
         BOR   FDNBASE                  YES, RETURN DIRECTLY     Y02072
         MVI   IOBDAYLI,NULL            ELSE, MAKE IOB AVAILABLE Y02072
         BR    FDNBASE                  RETURN TO SUPERVISOR     Y02072
         DROP  RIOB                     DROP TEMPORARY IOB BASE  Y02072
         USING IOBSTDRD,PARAM           REESTABLISH OLD IOB BASE Y02072
         USING SWA,SWAPTR               REESTABLISH SWA BASE     Y02072
*
*
*
*    THE FOLLOWING ROUTINE DETERMINES THE CAUSE OF ABNORMAL COMPLETION
*     BY ANALYZING THE SENSE BYTES AND CSW STORED IN THE IOB BY IOS.
*
*
ASIERR   TM    IOBSTAT2,ALLMSK          HAS ERROR ALREADY BEEN FLAGGED
         BM    ERREXIT                  IF YES , EXIT
         TM    IOBCSW+3,UCMSK           TEST FOR UNIT CHECK
         BZ    TSTEXC                   BR. IF NOT
         TM    IOBSENS0,DCMSK           TEST FOR DATA CHECK      YM5853
         BO    SETUDC                   BRANCH IF YES
         TM    IOBSENS1,NRMSK           TEST NO RECORD FOUND     YM5853
         BZ    SETUE                    IF NOT SET, MUST BE UNRELATED
ASIERR2  OI    IOBSTAT2,NOREC           SET NO RECORD FOUND EX. CODE
         TM    IOBDTYP2,IOBADDTY        IS TYPE WRITE ADD
         BZ    DASIC                    NO, RETURN TO POOLING ROUTINE
         XI    IOBSTAT2,FLIPMSK         CHG NO-RCD-FOUND TO NO-SPACE
         B     KNP8EXIT                 GO TO SELF FORMAT MODULE
*
SETUDC   OI    IOBSTAT2,UNCOR           SET UNCORRECTABLE DATA CHECK
         B     ERREXIT                  GO TEST FOR EXIT
*
TSTEXC   EQU   *
         TM    IOBCSW+4,INCLMSK         WAS THE RECORD WRONG LENGTH
         BO    SETINCL                  IF YES GO SET FLAG
SETUE    OI    IOBSTAT2,UNREL           SET UNRELATED ERROR FLAG
*
ERREXIT  TM    IOBDTYP2,IOBADDTY        IF THIS WAS A FORMAT WRITE,
         BO    KNP8EXIT                 GO SCAN UNSCHEDULED QUEUE
         TM    IOBSTAT2,INCLMSK+ENDOD   IF INCORRECT LENGTH OR EOD
         BZ    DASIC                    BYPASS FEEDBACK TEST
         B     ISITNA                   ELSE TEST FOR NEXT ADDRESS
*
SETINCL  EQU   *
         TM    IOBDTYP2,IOBRQUST        WAS THIS A READ REQUEST
         BZ    SETLGNCK                 BR IF NOT
         LH    WORKR1,DECLNGTH          GET SPECIFIED LENGTH
         SH    WORKR1,IOBCSW+5          SUBTRACT RESIDUAL COUNT
         CH    WORKR1,SWABDW            REMAINDER SHOULD EQUAL THE
*                                       LENGTH OF THE RECORD JUST READ
         BNE   SETLGNCK                 SET ERROR IF NOT
         NI    IOBFLAG1,CLRLNER1        CLEAR LENGTH ERROR
         NI    IOBCSW+4,CLRLNER2        CLEAR LENGTH ERROR
         NI    IOBDSTAT,CLRABN          TURN OFF ABNORMAL COMPLETION
         B     GOODCMPL                 CONTINUE PROCESSING
SETLGNCK EQU   *
         OI    IOBSTAT2,LGNCK           SET INCORRECT LENGTH EXCEPTION
         B     ERREXIT                  CODE, GO DETERMINE EXIT
*
*
ADD1RTN  EQU   *
*
***********************************************************************
*
*              ADD1RTN ROUTINE IN IGG019KJ
*
***********************************************************************
*
*
*        REGISTER USAGE
*
*
WORK3    EQU   3                        REG TO RETURN TO CALLING RTN
CVTREG   EQU   4                        CVT POINTER
DTABREG  EQU   CVTREG                   DEVICE TABLE POINTER
IOBADR   EQU   PARAM                    IOB POINTER
DEBREG2  EQU   7                        DEB POINTER
WKREGA   EQU   9                        GENERAL PURPOSE REGISTER
WKREGB   EQU   10                       GENERAL PURPOSE REGISTER
WKREG3   EQU   8                        GENERAL PURPOSE REGISTER
RQEREG   EQU   15                       POINTER OF 12*
UCBREG   EQU   RQEREG                   UCB POINTER
TWLVSTAR EQU   7
*
*
         USING DEBDEF,DEBREG2           DEB BASE REG
         LA    RETREG,GOTDVTB
*
*
*        CALCULATE THE DEVICE TYPE ENTRY IN THE DEVICE TABLE
*
*
GETDVTB  LR    RQEREG,TWLVSTAR          GET 12* POINTER
         USING RQE,RQEREG               ESTABLISH RQE BASE       Y02072
         L     UCBREG,RQEUCB            LOAD 3 BYTE UCB ADDR     Y02072
         DROP  RQEREG                                            Y02072
         L     CVTREG,CVTPTR(NULL,NULL)      LOAD CVT ADDRESS
         L     DTABREG,DTABOFF(NULL,CVTREG)  LOAD DEVICE TABLE ADDRESS
*                                            FROM CVT
         IC    WKREGA,TYPCD(UCBREG)     LOAD DEVICE CODE FROM UCB
         N     WKREGA,LASTFOUR          CLEAR ALL BUT LOW ORDER 4 BITS
         IC    WKREGA,NULL(WKREGA,DTABREG)   GET DEVICE ENTRY OFFSET
         LA    DTABREG,NULL(WKREGA,DTABREG)  POINTER TO DESIRED ENTRY
*                                            TO THE DEVICE TABLE
*
*
         BR    RETREG                   RETURN IF JUST DEV TAB WANTED
GOTDVTB  EQU   *
         MVC   IOBCSW-1(BYTE4),NULL(DTABREG)  MOVE TOTAL NO. OF CCHH TO
*                                            IOBCSW FIELD TEMPORARILY
         MVC   IOBCSW+3(BYTE4),IOBCC     NEXT MOVE IN THE CURRENT CCHH
         MVI   IOBR,NULL                 ZERO OUT R IN IOBSEEK FIELD
         L     DEBREG2,DCBDEBAD          GET DEB ADDRESS
         LA    IOBADR,NULL(NULL,IOBADR) CLEAR HI-ORDER BYTE TO ZERO
         LA    WKREGB,BYTE3(NULL,IOBADR)     POINT TO LAST H IN CCHH
         L     WKREG3,IOBCSW+3          LOAD CURRENT CCHH ADDRESS
         TM    BYTEDEV(DTABREG),CONTIG  ARE ADDRESS BYTES NON-CONTIG.
         BZ    DOWNONE                  BRANCH IF THEY ARE CONTIGUOUS
*
*
ADDONE   EQU   *
*
*
         AH    WKREG3,ONEH              INCREMENT CURRENT CCHH BY ONE
         TM    BYTEDEV(DTABREG),CONTIG  IF THIS DEVICE HAS NON-CONTIG-
*                                       UOUS BYTES
         BO    USEBYTE                  BRANCH IF IT HAS
         STH   WKREG3,IOBCSW-1-IOBSTDRD+BYTE4(NULL,WKREGB) ST NEW CC OR
*                                                      HH VALUE
         CLC   IOBCSW-1-IOBSTDRD+4(2,WKREGB),IOBCSW-1-IOBSTDRD(WKREGB)
*                                       IS VALUE OF NEW CC OR HH VALID
         BL    TESTEXT                  IF IT IS, GO TEST EXTENT LIMIT
         SRL   WKREG3,BIT16             SHIFT TO NEW CC VALUE
         MVC   IOBCSW-1-IOBSTDRD+BYTE4(BYTE2,WKREGB),ZERO  ZERO 2 BYTES
         BCTR  WKREGB,NULL              DECREMENT INDEX TO NEXT VALUE
*
*
DOWNONE  EQU   *
*
*
         BCTR  WKREGB,NULL              DECREMENT INDEX TO NEXT VALUE
         CR    WKREGB,IOBADR            IF ALL OF CCHH BEEN INCREMENTED
         BNL   ADDONE                   IF NO, REPEAT LOOP
*
*
CALEXT   EQU   *
*
*
*        CALCULATE THE NEXT EXTENT
*
*
         SR    WKREGA,WKREGA
         IC    WKREGA,IOBM              LOAD CURRENT EXTENT NUMBER
         LA    WKREGA,BYTE1(NULL,WKREGA)    ADJUST EXTENT NUMBER
         SR    WKREGB,WKREGB            CLEAR REGISTER
         IC    WKREGB,DEBNMEXT          FETCH NO. OF TOTAL EXTENTS
         CR    WKREGA,WKREGB            CHECK IF IT IS THE LAST EXTENT
         BNE   NEXTEXT                  BRANCH IF NOT
         SR    WKREGA,WKREGA            OTHERWISE, USE THE 1ST EXTENT
*
NEXTEXT  EQU   *
*
*
         STC   WKREGA,IOBM              STORE NEW EXTENT NO. IN IOBSEEK
         SLL   WKREGA,FOURB             MULT EXTENT NO. BY 16 FOR
*                                       INDEXING
         LA    WKREGB,DEBDVMOD(WKREGA)  FETCH ADDRESS OF EXTENT IN DEB
         MVC   IOBBB1(BYTE6),BYTE4(WKREGB) MOVE BBCCHH IN THE
*                                                 IOBSEEK FIELD
         BR    WORK3                    RETURN TO CALLING ROUTINE
*
*
USEBYTE  EQU   *
*
*
         STC   WKREG3,IOBCSW-1-IOBSTDRD+BYTE4(WKREGB) STORE NEW BYTE
         SRL   WKREG3,BIT8              SHIFT TO NEXT VALUE
         CLC   IOBCSW-1-IOBSTDRD+4(1,WKREGB),IOBCSW-1-IOBSTDRD(WKREGB)
*                                       CHECK VALIDITY OF NEW BYTE
         BL    TESTEXT                  BRANCH IF NEW BYTE IS VALID
         MVI   IOBCSW-1-IOBSTDRD+BYTE4(WKREGB),NULL  OTHERWISE ZERO OUT
*                                                 THIS NEW BYTE
         B     DOWNONE                  GO CHECK IF ALL BYTES PROCESSED
*
*
TESTEXT  EQU   *
*
         SR    WKREGA,WKREGA            CLEAR REG                 21905
         IC    WKREGA,IOBM              GET CURRENT EXTENT NO     21905
         SLL   WKREGA,FOURB             MULTIPLY BY 16 FOR INDEX  21905
         LA    WKREGA,DEBDVMOD(WKREGA)  LOAD ADDR OF CUR EXT      21905
*                                       IN DEB
         USING DEBDVMOD,WKREGA                                    21905
*
         MVC   IOBCC(BYTE4),IOBCSW+3    MOVE NEW CCHH BACK TO
*                                                 IOBSEEK FIELD
         CLC   IOBCC(BYTE4),DEBENDCC    CHECK IF THE NEW CCHH IS
*                                       THE NEW CCHH IS OUTSIDE OF THE
*                                       CURRENT EXTENT
         BH    CALEXT                   IF YES, GO TO CALCULATE THE
*                                       NEXT EXTENT
         BR    WORK3                    OTHERWISE, RETURN TO CALLING
*                                       ROUTINE
*
*
***********************************************************************
*                 CONSTANTS AND EQUATES
***********************************************************************
*
         DS    0F
LASTFOUR DC    X'0000000F'              USED TO CLEAR ALL BUT LAST 4
*                                       BITS
ZEROH    DS    0F                       * USED TO ZERO THE HI ORDER
         DC    X'0000FFFF'              * HALF WORD OF A REGISTER
ONEH     DC    H'1'                     GENERAL PURPOSE CONSTANT
H7       DC    H'7'                     GENERAL PURPOSE CONSTANT
H8       DC    H'8'                     CCW LENGTH
SIXTEEN  DC    H'16'                    GENERAL PURPOSE CONSTANT
FOUR     DC    H'4'                     GENERAL PURPOSE CONSTANT
H255     DC    H'255'                   *
H256     DC    H'256'                    * CONSTANTS USED BY MOVE RTN
FFF      EQU   256                      *
Q255     EQU   255                      MAX TO CLEAR IOB        ZA01524
ZERO     DC    H'0'                     GENERAL PURPOSE CONSTANT  21905
WCRF     DC    X'20000007'              FLAGS AND DATA LENGTH USED TO
*                                       UPDATE R0
UNAVALSW EQU   X'FF'              IOB UNAVAILABLE SWITCH
SHFT3BYT EQU   X'18'              USED FOR SLL 24 BITS(3 BYTES)
CLRSTAT  DC    X'0400'                  USED TO CLEAR IOBDSTAT EXCEPT
*                                       FOR DYNAMIC BUFFERING BIT
*
*   DEVICE TABLE OFFSETS
*
TRKLN    EQU   4                        TRACK LENGTH
OVERI    EQU   6                        OVERHEAD NOT LAST RECORD
OVERK    EQU   8                        OVERHEAD KEYED RECORD
TOLER    EQU   10                       TOLERANCE FACTOR
DTABOFF  EQU   64                       DEVICE TABLE OFFSET IN CVT
*
NINE     EQU   9                        USED TO DIVIDE BY 512 (SHIFT)
EQU4     EQU   4
SIX      EQU   6
HIPOS    EQU   16
TYPCD    EQU   19                       DEVICE TYPE OFFSET IN UCB
BYTE1    EQU   1                        ONE BYTE
BYTE2    EQU   2                        TWO BYTES
BYTE3    EQU   3                        THREE BYTES
BYTE4    EQU   4                        FOUR BYTES
FOURB    EQU   4                        USED AS MULTIPLIED BY 16
BYTEDEV  EQU   9                        FLAG BYTE OFFSET IN THE DEVICE
*                                       TABLE
BYTE6    EQU   6                        SIX BYTES
BYTE7    EQU   7                        SEVEN BYTES
BIT8     EQU   8                        EIGHT BITS
BIT16    EQU   16                       SIXTEEN BITS
CONTIG   EQU   2                        FLAGS INDICATING BYTES OF CCHH
*                                       ARE NON-CONTIGUOUS
FIRSTSEG EQU   2                        FIRST SEGMENT IF BIT IS ZERO
LASTSEG  EQU   1                        LAST SEGMENT IF BIT IS ZERO
SIEOP    EQU   X'31'                    SEARCH-ID-EQUAL COMM. CODE
TICOP    EQU   8                        TIC  COMMAND CODE
CCHHLN   EQU   4
R1       EQU   1                        BLOCK ID = 1
SDW      EQU   4                        OFFSET OF SEG DESCRIPTOR WORD
NEXTADR  EQU   X'10'                    NEXT ADDRESS MASK
TYPERU   EQU   X'30'                    MASK FOR TYPE = RU TEST
TBOVHD   EQU   X'08'                    MASK FOR 2 BYTE OVHD     20201
*                                       DEVS                     20201
FIVE     EQU   5                        LENGTH OF CCHHR
CCPADR   EQU   4                        LENGTH OF COMM. CODE AND ADDR.
WREG9    EQU   9
ACTADR   EQU   2
IECPRLTV EQU   15                       BALR REG TO GO TO IECPRLTV
CVTPTR   EQU   16                       CVT ADDRESS
APRLTV   EQU   32                       DISPLACEMENT OF IECPRLTV ADDR.
*                                       IN THE CVT
CONVID   EQU   0                        TTR0 AFTER CONVERSION
TTRLN    EQU   3
ACTLN    EQU   8                        LENGTH OF MBBCCHHR
CNTOFF   EQU   6                        OFFSET OF COUNT FIELD IN CCW
ADDSRCH  EQU   8                        OFFSET OF SEARCH RTN IN ADD MOD
LASTSEGF EQU   2                        LAST SEGMENT FLAG
ADDDONE  EQU   12
CNTLN    EQU   2
WDOP     EQU   5                        WRITE DATA CHANNEL COMMAND CODE
MIDSEG   EQU   3                        MIDDLE SEGMENT IF BITS ARE ONES
THREE    EQU   3
TEN      EQU   10                       CONTROL FIELD LENGTH IN SWA
CNTLBYTE EQU   18                       CONTROL FIELD AND BCB LNGTH
DATACHAN EQU   X'80'                    DATA CHAINING IF A ONE
FLAGS    EQU   4                        OFFSET OF FLAG FIELD IN CCW
COMCHAN  EQU   X'40'                    COMMAND CHAINING IF A ONE
COMCOFF  EQU   X'BF'                    MASK TO TURN OFF COMCHAN
SWL      EQU   X'20'                    SUPPRESS WRONG LENGTH IF A 1
WKDOP    EQU   X'0D'                    WRITE-KEY-DATA COMMAND CODE
EIGHT    EQU   8
READCCW  EQU   X'06'
EXIT     EQU   3                        SVC NUMBER TO RETURN TO SUPERV.
CLRLNER1 EQU   X'FB'                    CLEAR LENGTH ERROR IN IOBFLAG1
CLRLNER2 EQU   X'BF'                    CLEAR LENGTH ERROR IN IOBCSW
CLRABN   EQU   X'7F'                    TURN OFF ABNORMAL COMPLETION
FLIPMSK  EQU   X'A0'                    CHANGE NO RECORD FOUND TO
*                                             NO SPACE FOUND
ALLMSK   EQU   X'FF'                    TEST FOR EXCEPTION CODES
INCLMSK  EQU   X'40'                    INCORRECT LENGTH
NRMSK    EQU   X'08'                    NO RECORD FOUND
UCMSK    EQU   X'02'                    UNIT CHECK
DCMSK    EQU   X'08'                    DATA CHECK
*              EXCEPTION CODES
NOREC    EQU   X'80'
LGNCK    EQU   X'40'
UNCOR    EQU   X'08'
ENDOD    EQU   X'04'
UNREL    EQU   X'02'
*              OPTIONS AND TYPE
VERIFY   EQU   X'80'
OFLOW    EQU   X'40'
EXSCH    EQU   X'20'
ACTAD    EQU   X'08'
READX    EQU   X'02'
RELRD    EQU   X'01'
LGNOP    EQU   X'40'
READ     EQU   X'08'
KEY      EQU   X'04'
ADD      EQU   X'02'
MODID    DC    C'IGG019KJ'              MODULE ID                Y02072
FIX      DC    C'@ZA08000'              LATEST FIX IN MODULE   @ZA08000
DATE     DC    C'&SYSDATE'              DATE OF LATEST FIX     @ZA08000
PATCH    DC    XL((*-IGG019KJ)/20)'0'   5% PATCH AREA            Y02072
         EJECT
***********************************************************************
*                       DSECTS
***********************************************************************
         DCBD  DSORG=DA
         EJECT
         IEFUCBOB  LIST=YES
         EJECT
         IECDRQE                                                 Y02072
         EJECT
*      DATA EVENT CONTROL BLOCK (DECB) DEFINITION
         DS    0F
DECBDEF  DSECT
DECSDECB DS    CL4            STANDARD EVENT CONTROL BLOCK (ECB)
DECTYPE  DS    CL2            TYPE FIELD
DECLNGTH DS    CL2            DATA LENGTH
DECDCBAD DS    CL4            ADDRESS OF DCB
DECAREA  DS    CL4            ADDRESS OF DATA AREA
DECIOBPT DS    CL4            ADDRESS OF THE IOB
DECKYADR DS    CL4            ADDRESS OF KEY
DECRECPT DS    CL4            ADDRESS OF RECORD REFERENCE
DECNA    DS    CL4            ADDRESS OF NEXT ADDRESS FEEDBACK AREA
         EJECT
*
*      I/O BLOCK (IOB) DEFINITION
*
         IEZIOB                                                  Y02072
*
*        IOB EQUATES
*
IOBUPLIM EQU   IOBRSV35                 UPPER LIMIT COUNT        Y02072
DNRCFP2  EQU   IOBDNCRF+2
CNTKL    EQU   IOBDNCRF+5     OFFSET OF KEY LENGTH IN COUNT
CNTDL    EQU   IOBDNCRF+6     OFFSET OF DATA LENGTH IN COUNT
IOBDIOBX EQU   42             OFFSET FOR IOBDIOS
IOBDPLAX EQU   44             OFFSET FOR IOBDPLAD
BASESZ   EQU   IOBCHNPR-IOBSTDRD   IOB BASE SIZE WITHOUT PREFIX
         ORG   IOBSTAT2                                          Y02072
OTHERERR EQU   BIT6
         EJECT
         IKJTCB
         EJECT
*
*      DATA EXTENT BLOCK (DEB) DEFINITION
*
DEBDEF   DSECT
         DS    0F
DEBNMSUB DS    0CL1      NO. OF SUBR. LOADED BY OPEN
DEBTCBAD DS    CL4       ADDRESS OF THE TCB FOR THIS DEB
DEBAMLNG DS    0CL1      NO. OF BYTES IN THE ACCESS MTHD. DPDT. SECTION
DEBDEBAB DS    CL4       ADDRESS OF THE PREVIOUS DEB IN THE SAME TASK
DEBOFLGS DS    0CL1      DATA SET STATUS FLAGS
DEBIRBAD DS    CL4       IRB ADDRESS
DEBOPATB DS    0CL1      TYPE OF FILES
DEBSYSPG DS    CL4       ADDRESS OF FIRST IOB IN THE SYSTEM PURGE CHAIN
DEBNMEXT DS    0CL1      NUMBER OF EXTENTS SPECIFIED IN THE DSCB
DEBUSRPG DS    CL4       ADDRESS OF FIRST IOB IN THE USER PURGE CHAIN
DEBPRIOR DS    0CL1      ALWAYS ZERO
DEBECBAD DS    CL4       ECB ADDRESS FOR SVC PURGE REQUEST
DEBPROTG DS    0CL1      RESERVED FOR FUTURE USE (FIRST 4 BITS)
DEBDEBID DS    0CL1      HEX 'F' TO IDENTIFY THIS BLOCK AS A DEB
DEBDCBAD DS    CL4       ADDRESS OF THE DCB ASSOCIATED WITH THIS DEB
DEBEXSCL DS    0CL1      EXTENT SCALE
DEBAPPAD DS    CL4       ADDRESS OF I/O APPENDAGE VECTOR TABLE
DEBDVMOD DS    0CL1      DEVICE MODIFIER FILE MASK
DEBUCBAD DS    CL4       ADDR OF UCB ASSOCIATED WITH THIS DATA EXTENT
DEBBINUM DS    CL2       RESERVED FOR FUTURE USE-ALWAYS ZERO
DEBSTRCC DS    CL2       STARTING CYLINDER NUMBER FOR EXTENT
DEBSTRHH DS    CL2       STARTING HEAD NUMBER FOR EXTENT
DEBENDCC DS    CL2       ENDING CYLINDER NUMBER FOR EXTENT
DEBENDHH DS    CL2       ENDING HEAD NUMBER FOR EXTENT
DEBNMTRK DS    CL2       NUMBER OF TRACKS ALLOCATED TO A GIVEN EXTENT
DEBSUBID EQU   0         SUBROUTINE ID'S
         EJECT
*   THE FOLLOWING DSECT SHOWS THE FORMAT OF THE SEGMENT WORK AREA
*
SWA      DSECT                          SEGMENT WORK AREA DSECT
SWANXTPT DS    F                        POINTER TO NEXT SWA
SWARAPT  DS    F                        POINTER TO THE RECORD AREA
SWABFINC DS    CL2                      BUFFER INCREMENT FIELD
SWABDW   DS    CL4                      BLOCK DESCRIPTOR WORD
SAVEID   EQU   SWABDW+5                 SAVE AREA FOR ID OF LAST SEGMNT
SWASDW   DS    0CL4                     SEGMENT DESCRIPTOR WORD
SEGLL    DS    H                        SEGMENT LENGTH (LL)
SEGFLGS  DS    C                        SEGMENTATION FLAGS
SEGUNUSD DS    C                        CURRENTLY UNUSED
SEGDATA  DS    C                        DATA PORTION OF RECORD
         EJECT
***********************************************************************
*                                                                     *
*                                                                     *
*                       CHANNEL PROGRAM DSECTS                        *
*                                                                     *
*                                                                     *
***********************************************************************
         SPACE 10
*
*   ORIGINAL CHANNEL PROGRAM TO WRITE (ADD) A NEW VRE RECORD
*
WRITEADD DSECT
WANOP1   DS    D                  CCW1  NOP
WASIE1   DS    D                  CCW2  SEARCH ID EQUAL (R0)
WATIC1   DS    D                  CCW3  TIC TO CCW2
WARD     DS    D                  CCW4  READ DATA (R0)
WANOP2   DS    D                  CCW5  NOP
WASIE2   DS    D                  CCW6  SEARCH ID EQUAL (R0)
WATIC2   DS    D                  CCW7  TIC TO CCW6
WAWDR0   DS    D                  CCW8  UPDATE CAPACITY RECORD
WASIE3   DS    D                  CCW9  SEARCH ID EQUAL
WATIC3   DS    D                  CCW10 TIC TO CCW9
WAWCKD1  DS    D                  CCW11 WRITE COUNT
* THE NEXT CCW'S MAY BE PRESENT ONLY IF KEYS ARE TO BE WRITTEN.
WAKWK    DS    D                  CCW12 WRITE KEY
WAKWD    DS    D                  CCW13 WRITE DATA
WAKNOP1  DS    D               ** CCW14 NOP
WAKNOP2  DS    D               ** CCW15 NOP
WAKSIE   DS    D               ** CCW16 SEARCH ID EQUAL
WAKTIC   DS    D               ** CCW17 TIC TO CCW16
WAKRKD   DS    D               ** CCW18 READ-KEY-DATA TO DO WRITE CHECK
WAKRR0   DS    D               ** CCW19 WRITE CHECK R0
* IF KEYS ARE NOT TO BE WRITTEN, THE FOLLOWING CCW'S ARE USED
WANK     EQU   WAKWK-WRITEADD
         ORG   WRITEADD+WANK      ORG BACK TO CCW12
WANKWD   DS    D                  CCW12 WRITE DATA
WANKNOP1 DS    D               ** CCW13 NOP
WANKNOP2 DS    D               ** CCW14 NOP
WANKSIE  DS    D               ** CCW15 SEARCH ID EQUAL
WANKTIC  DS    D               ** CCW16 TIC TO CCW15
WANKRKD  DS    D               ** CCW17 READ-KEY-DATA TO DO WRITE CHECK
WANKRR0  DS    D               ** CCW18 WRITE CHECK R0
*
*                              ** THESE CCW'S ARE INCLUDED ONLY IF
*                                 WRITE CHECK IS REQUESTED.
         SPACE 3
*
*   CHANNEL PROGRAM FOR WRITE ADD AFTER WRITING THE FIRST SEGMENT
*
WRITADD1 DSECT
WA1NOP1  DS    D                  CCW1  NOP
WA1SIE   DS    D                  CCW2  SEARCH ID EQUAL (R0)
WA1TIC   DS    D                  CCW3  TIC TO CCW2
WA1WC    DS    D                  CCW4  WRITE COUNT
WA1WD    DS    D                  CCW5  WRITE DATA
WA1SIE2  DS    D                  CCW6  SEARCH ID EQUAL (R0)
WA1TIC2  DS    D                  CCW7  TIC TO CCW6
WA1WCR   DS    D                  CCW8  UPDATE CAPACITY RECORD
WA1NOP2  DS    D               ** CCW9  NOP
WA1RR0   DS    D               ** CCW10 READ R0 FOR WRITE CHECK
WA1RD    DS    D               ** CCW11 READ DATA FOR WRITE CHECK
*
*                              ** THESE CCW'S ARE INCLUDED WHEN WRITE
*                                 CHECK IS REQUESTED.
         SPACE 6
*
*   ORIGINAL CHANNEL PROGRAM TO READ BY BLOCK KEY USING EXTENDED SEARCH
*
READES0  DSECT
RENOP1   DS    D                  CCW1  NOP
RESIE    DS    D                  CCW2  SEARCH ID EQUAL (R0)
RETIC1   DS    D                  CCW3  TIC TO CCW2
REMTSIE  DS    D                  CCW4  MULTI-TRACK SEARCH ID EQUAL
RETIC2   DS    D                  CCW5  TIC TO CCW7
RENOP2   DS    D                  CCW6  NOP
RESKE1   DS    D                  CCW7  SEARCH KEY EQUAL
RETIC3   DS    D                  CCW8  TIC TO CCW4
RENOP3   DS    D                  CCW9  NOP
RENOP4   DS    D                  CCW10 NOP
RERHA    DS    D                  CCW11 READ HOME ADDRESS
RENOP5   DS    D                  CCW12 NOP
RERDCNT  DS    D                  CCW13 READ COUNT
RESKE2   DS    D                  CCW14 SEARCH KEY EQUAL
RETIC4   DS    D                  CCW15 TIC TO CCW13
RERD     DS    D                  CCW16 READ DATA
         SPACE 3
*
*  CHANNEL PROGRAM TO READ BY BLOCK KEY USING EXTENDED SEARCH AFTER
*  READING THE FIRST SEGMENT.
*
READES1  DSECT
RE1NOP1  DS    D                  CCW1  NOP
RE1SIDE  DS    D                  CCW2  SEARCH ID EQUAL
RE1TIC   DS    D                  CCW3  TIC TO CCW2
RE1RD    DS    D                  CCW4  READ DATA
RE1NOP2  DS    D                  CCW5  NOP. THIS CCW IS PRESENT ONLY
*                                       WHEN THE NEXT ADDRESS IS BEING
*                                       DETERMINED.
         SPACE 6
*
*   ORIGINAL CHANNEL PROGRAM TO WRITE BY BLOCK KEY USING EXTENDED
*   SEARCH.
*
WRITEES0 DSECT
WENOP1   DS    D                  CCW1  NOP
WESIE1   DS    D                  CCW2  SEARCH ID EQUAL (R0)
WETIC1   DS    D                  CCW3  TIC TO CCW2
WEMTSIE  DS    D                  CCW4  MULTI-TRACK SEARCH ID EQUAL
WETIC2   DS    D                  CCW5  TIC TO CCW7
WENOP2   DS    D                  CCW6  NOP
WESKE1   DS    D                  CCW7  SEARCH KEY EQUAL
WETIC3   DS    D                  CCW8  TIC TO CCW4
WENOP3   DS    D                  CCW9  NOP
WENOP3A  DS    D                  CCW10 NOP
WERHA    DS    D                  CCW11 READ HOME ADDRESS
WENOP3B  DS    D                  CCW12 NOP
WERC     DS    D                  CCW13 READ COUNT
WESKE2   DS    D                  CCW14 SEARCH KEY EQUAL
WETIC4   DS    D                  CCW15 TIC TO CCW13
WERD1    DS    D                  CCW16 READ DATA TO GET SEGMENT LENGTH
WENOP4   DS    D               ** CCW17 NOP
WESIE2   DS    D               ** CCW18 SEARCH ID EQUAL
WETIC5   DS    D               ** CCW19 TIC TO CCW18
WERD2    DS    D               ** CCW20 READ DATA TO DO WRITE CHECK
*
*                              ** INDICATES THAT THE CCW'S ARE PRESENT
*                                 ONLY IF WRITE CHECK IS REQUESTED.
*
         SPACE 3
*
*  CHANNEL PROGRAM AFTER DETERMINING THE LENGTH OF THE FIRST SEGMENT.
*
WRITEES1 DSECT
WE1NOP1  DS    D                  CCW1  NOP
WE1SIE1  DS    D                  CCW2  SEARCH ID EQUAL
WE1TIC1  DS    D                  CCW3  TIC TO CCW2
WE1TIC2  DS    D                  CCW4  TIC TO CCW16
WENTUSED DS    11D                CCW5-CCW15 ARE BYPASSED BY THE TIC IN
*                                       CCW4.
WEWD     DS    D                  CCW16 WRITE DATA
WE1WC    DS    D                  CCW17-CCW20 SAME AS BEFORE
         SPACE 6
*
*   ORIGINAL CHANNEL PROGRAM FOR READ TYPE = DI  WHEN THE NEXT ADDRESS
*   IS REQUESTED.
*
READDI0N DSECT
RDINANOP DS    D                  CCW1  NOP
RDINASI1 DS    D                  CCW2  SEARCH ID EQUAL (R0)
RDINAT1  DS    D                  CCW3  TIC TO CCW2
RDINARD  DS    D                  CCW4  READ DATA (R0)
RDINASI2 DS    D                  CCW5  SEARCH ID EQUAL
RDINAT2  DS    D                  CCW6  TIC TO CCW5
* THE NEXT CCW IS INCLUDED ONLY IF KEYS ARE TO BE READ
RDINARK  DS    D                  CCW7  READ KEY
RDINADK  DS    D                  CCW8  READ DATA
RDINANK  EQU   RDINARK-READDI0N
         ORG   READDI0N+RDINANK         POSITION FOR NO KEYS
* THE FOLLOWING CCW IS PRESENT IF KEYS ARE NOT TO BE READ
RDINAD   DS    D                  CCW7  READ DATA
         SPACE 3
*
*   CHANNEL PROGRAM FOR READ TYPE = DI  WHEN THE NEXT ADDRESS IS
*   REQUESTED AND AFTER READING THE FIRST SEGMENT.
*
READDI1N DSECT
RDINAN1  DS    D                  CCW1  NOP
RDINASI5 DS    5D                 CCW2-CCW6 ARE THE SAME AS BEFORE
RDINARD1 DS    D                  CCW7  READ DATA
         SPACE 6
*
*   ORIGINAL CHANNEL PROGRAM FOR READ TYPE = DI AND THE NEXT ADDRESS
*   IS NOT REQUESTED.
*
READDI0  DSECT
RDISIE   DS    D                  CCW1  SEARCH ID EQUAL
RDITIC   DS    D                  CCW2  TIC TO CCW1
* THE FOLLOWING CCW IS INCLUDED ONLY IF KEYS ARE TO BE READ
RDIRK    DS    D                  CCW3  READ KEY
RDIRD    DS    D                  CCW4  READ DATA
RDINK    EQU   RDIRK-READDI0
         ORG   READDI0+RDINK            POSITION FOR NO KEYS
RDIRDNK  DS    D                  CCW3  READ DATA
         SPACE 3
*
*  CHANNEL PROGRAM FOR READ TYPE = DI AFTER READING THE FIRST SEGMENT
*  (NEXT ADDRESS IS NOT REQUESTED).
*
READDI1  DSECT
RDISIE1  DS    D                  CCW1  SEARCH ID EQUAL
RDITIC1  DS    D                  CCW2  TIC TO CCW1
RDIRD1   DS    D                  CCW3  READ DATA
         SPACE 6
*
*   ORIGINAL CHANNEL PROGRAM FOR WRITE TYPE = DI
*
WRITEDI0 DSECT
WDINOP1  DS    D                  CCW1  NOP
WDISIE   DS    D                  CCW2  SEARCH ID EQUAL
WDITICL  DS    D                  CCW3  TIC TO CCW2
WDIRDD   DS    D                  CCW4  READ DATA TO GET SEG LENGTH
* THE FOLLOWING 6 CCW'S MAY BE PRESENT ONLY IF KEYS ARE TO BE WRITTEN
WDIWDK   DS    D                  CCW5  WRITE DATA
WDINOP2K DS    D               ** CCW6  NOP
WDINOP3K DS    D               ** CCW7  NOP
WDISIE2K DS    D               ** CCW8  SEARCH ID EQUAL
WDITIC2K DS    D               ** CCW9  TIC TO CCW8
WDIRKDK  DS    D               ** CCW10 READ KEY DATA TO DO WRITE CHECK
WDINK    EQU   WDIWDK-WRITEDI0
* THE FOLLOWING 5 CCW'S MAY BE PRESENT IF KEYS ARE NOT TO BE WRITTEN
         ORG   WRITEDI0+WDINK           ORG BACK TO WRITE DATA CCW
WDINOP2  DS    D               ** CCW5  NOP
WDINOP3  DS    D               ** CCW6  NOP
WDISIE2  DS    D               ** CCW7  SEARCH ID EQUAL
WDITIC2  DS    D               ** CCW8  TIC TO CCW7
WDIRKD   DS    D               ** CCW9  READ KEY DATA TO DO WRITE CHECK
*
*                              ** INDICATES THAT THESE CCW'S ARE
*                                 PRESENT ONLY FOR WRITE CHECK OPTION
*
         SPACE 3
*
*   CHANNEL PROGRAM FOR WRITE TYPE = DI AFTER DETERMINING THE
*   LENGTH OF THE FIRST SEGMENT
*
WRITEDI1 DSECT
WDI1NOP1 DS    D                  CCW1  NOP
WDI1SIE  DS    D                  CCW2  SEARCH ID EQUAL
WDI1TIC1 DS    D                  CCW3  TIC TO CCW2
* THE FOLLOWING 7 CCW'S MAY BE PRESENT IF KEYS ARE TO BE WRITTEN
WDI1WKD  DS    D                  CCW4  WRITE KEY
WDI1WDK  DS    D                  CCW5  WRITE DATA
WDI1WCK  DS    5D                 CCW6-CCW10 ARE THE SAME AS BEFORE FOR
*                                       WRITE CHECK.
WDINK1   EQU   WDI1WKD-WRITEDI1
* THE FOLLOWING 6 CCW'S MAY BE PRESENT IF KEYS ARE NOT TO BE WRITTEN
         ORG   WRITEDI1+WDINK1    ORG BACK TO CCW4
WDI1WD   DS    D                  CCW4  WRITE DATA
WDI1WC   DS    5D                 CCW5-CCW9 ARE THE SAME AS BEFORE FOR
*                                       WRITE CHECK
         SPACE 6
*
*   ORIGINAL CHANNEL PROGRAM FOR READ TYPE = DK
*
READDK0  DSECT
RDKRDCNT DS    D                  CCW1  READ COUNT INTO IOBDNRCF+2
RDKSKE   DS    D                  CCW2  SEARCH KEY EQUAL
RDKTIC1  DS    D                  CCW3  TIC TO CCW1
RDKRDD   DS    D                  CCW4  READ DATA
RDKNOP1  DS    D               ** CCW5  NOP
RDKSIE   DS    D               ** CCW6  SEARCH ID EQUAL (R0)
RDKTIC2  DS    D               ** CCW7  TIC TO CCW6
RDKRDD2  DS    D               ** CCW8  READ DATA (R0)
RDKNOP2  DS    D               ** CCW9  NOP
*
*                              ** THESE CCW'S ARE INCLUDED ONLY IF THE
*                                 NEXT ADDRESS IS REQUESTED.
         SPACE 3
*
*   CHANNEL PROGRAM FOR READ TYPE = DK AFTER BEING MODIFIED
*
READDK1  DSECT
RDK1NOP1 DS    D                  CCW1  NOP
RDK1SIE1 DS    D                  CCW2  SEARCH ID EQUAL (ID=1)
RDK1TIC1 DS    D                  CCW3  TIC TO CCW2
RDK1RDD1 DS    D                  CCW4  READ DATA
RDK1NOP2 DS    D               ** CCW5  NOP
RDK1SIE2 DS    D               ** CCW6  SEARCH ID EQUAL (R0)
RDK1TIC2 DS    D               ** CCW7  TIC TO CCW6
RDK1RDD2 DS    D               ** CCW8  READ DATA (R0)
RDK1NOP3 DS    D               ** CCW9  NOP
*
*                              ** THESE CCW'S ARE INCLUDED ONLY IF THE
*                                 NEXT ADDRESS IS REQUESTED.
*
         SPACE 6
*
*   ORIGINAL CHANNEL PROGRAM FOR WRITE TYPE = DK
*
WRITEDK0 DSECT
WDKRDCNT DS    D                  CCW1  READ COUNT INTO IOBDNRCF+2
WDKSKE   DS    D                  CCW2  SEARCH KEY EQUAL
WDKTIC1  DS    D                  CCW3  TIC TO CCW1
WDKRDD   DS    D                  CCW4  READ DATA TO GET SEG LENGTH
WDKNOP1  DS    D                  CCW5  NOP
WDKWCSIE DS    D               ** CCW6  SEARCH ID EQUAL (WRITE CHECK)
WDKWCTIC DS    D               ** CCW7  TIC TO CCW6     (WRITE CHECK)
WDKWCRDD DS    D               ** CCW8  READ DATA TO DO WRITE CHECK
*
*                              ** INDICATES THAT THESE CCW'S ARE
*                                 PRESENT ONLY FOR WRITE CHECK OPTION.
*
         SPACE 3
*
*   CHANNEL PROGRAM FOR  WRITE TYPE = DK  AFTER BEING MODIFIED
*
WRITEDK1 DSECT
WDK1NOP1 DS    D                  CCW1  NOP
WDK1SIE  DS    D                  CCW2  SEARCH ID EQUAL
WDK1TIC1 DS    D                  CCW3  TIC TO CCW2
WDK1WD   DS    D                  CCW4  WRITE DATA
WDK1NOP2 DS    D               ** CCW5  NOP
WDK1WCSI DS    D               ** CCW6  SEARCH ID EQUAL (WRITE CHECK)
WDK1WCT  DS    D               ** CCW7  TIC TO CCW6     (WRITE CHECK)
WDK1WCRD DS    D               ** CCW8  READ DATA TO DO WRITE CHECK
*
*                              ** INDICATES THAT THESE CCW'S ARE
*                                 PRESENT ONLY FOR WRITE CHECK OPTION.
*
         END
