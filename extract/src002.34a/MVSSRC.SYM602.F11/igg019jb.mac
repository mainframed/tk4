 TITLE 'IGG019JB -- DYNAMIC BUFFERING MODULE, SIO  APPENDAGE'
IGG019JB CSECT
*MODULE NAME = IGG019JB                                               *
*                                                                     *
*DESCRIPTIVE NAME = DYN BUF MODULE & SIO APPENDAGE FOR VS RECORD      *
*                   FORMAT AND VIRTUAL ADDRESS SPACE                  *
*                                                                     *
*COPYRIGHT = NONE                                                     *
*                                                                     *
*CHANGE ACTIVITY                                                      *
*                                                                     *
*        VS1-1 CHANGES/DELETIONS
*        VS2-1 CHANGES/DELETIONS
*        VS1-2 CHANGES/DELETIONS
*D094000                                                        XA00093
*        VS1-3 CHANGES/DELETIONS
*                                                                XM1559
*        VS2-2 CHANGES/DELETIONS
*001200,003000,005600,006200,006800,010400-011200,012600-032400,034200-
*042800,059600,064000,065800-066200,068800-070600,074200,081000,116800,
*122600-126600,130600-131200,131800,132600,133000,138800-139800,140400-
*154400,157200-157400,160800,161200-164200,165400,168800,180200-180600,
*183000-185200,187000-187400,191000-193600,195400-202600         Y02072
*                                                                     *
*STATUS CHANGE LEVEL 3                                                *
*                                                                     *
         IEZBITS
***********************************************************************
         USING *,RAPDBASE
SIOEP    B     SIORTNE            START I/O APPENDAGE E.P.
         ORG   IGG019JB+8
FRBUFEP  B     FBUFRTNE           FREE DYNAMIC BUFFER SVC E.P.
***********************************************************************
*
*
***********************************************************************
*  THE FOLLOWING TWO ENTRY POINTS ARE USED FOR PROCESSING OF THE      *
*  FREEDBUF ESTAE ROUTINE, IGCT005G.  THE FIRST ENTRY POINT (+12) IS  *
*  USED WHEN, IN THE ESTAE CLEANUP ROUTINE, IT IS DETERMINED THAT THE *
*  AUDIT TRAIL BIT INDICATING THAT THE NEXT IOB HAD BEEN TAKEN FROM   *
*  THE IOB QUEUE BUT THE CHANNEL PGM HAD NOT BEEN INITIALIZED YET     *
*  (WKAIOBQ BIT IS ON). IN THIS CASE ENTRY IS MADE TO INITIALIZE      *
*  THE CHANNEL PROGRAM AND ISSUE THE EXCP FOR THIS REQUEST.           *
*         THE SECOND ENTRY POINT (+16) IS USED WHEN THE NEXT IOB HAS  *
*  BEEN REMOVED FROM THE QUEUE, ITS CHANNEL PGM INITIALIZED, BUT THE  *
*  ABEND OCCURRED BEFORE THE EXCP WAS ISSUED (WKABUFAS BIT ON).IN THIS*
*  CASE ENTRY IS MADE TO ISSUE THE EXCP FOR THIS REQUEST.             *
*          INPUT FOR BOTH ENTRIES IS THE SAME:                        *
*                   REGISTER 2 = NEXT IOB ADDRESS                     *
*                   REGISTER 3 = BEGINNING ADDRESS OF THIS MODULE     *
*                   REGISTER 4 = DCB ADDRESS                          *
*                   REGISTER 5 = SVRB ADDRESS                         *
*                   REGISTER 6 = BUFFER ADDRESS                       *
*                   REGISTER 8 = TCB ADDRESS                          *
*                   REGISTER 15= BEGINNING ADDRESS OF THIS MODULE     *
*                   WKAREG14 IN SVRB WORKAREA IN INITIALIZED TO       *
*                                RETURN ADDRESS IN ESTAE              *
*  A THIRD ENTRY INTO THIS MODULE IS TAKEN BY ESTAE, IGCT005G, IF NO  *
*  AUDIT TRAIL BITS ARE SET AT ALL.  IN THIS CASE ENTRY IS THE SAME   *
*  AS FOR FREEDBUF (+8).  INPUT IS LIKEWISE THE SAME.                 *
***********************************************************************
ESTENT1  B     ESTENTA                  INIT CH PGM, ISSUE EXCP  Y02072
*
ESTENT2  B     ESTENTB                  ISSUE EXCP               Y02072
***********************************************************************
*                                                                     *
*                  REGISTER EQUATES
R0       EQU   0        INPUT REGISTER 0    SVC
RWORK0   EQU   0        WORK REGISTER
R1       EQU   1        INPUT REGISTER 1
RRQE     EQU   1        ADDRESS OF RQE                           Y02072
RLINK    EQU   1        INTERNAL LINKAGE REGISTER                Y02072
RWORK1   EQU   1        WORK REGISTER
RIOB     EQU   2        ADDRESS OF IOB
RBASE3   EQU   3        BASE REGISTER       SVC
RDCB     EQU   4        ADDRESS OF DCB
RWORK4   EQU   4        WORK REGISTER
RSVRB    EQU   5        ADDRESS OF SVRB ON ENTRY FROM FREEDBUF   Y02072
RBUFFR   EQU   6        BUFFER ADDRESS
RSWA     EQU   6        PTR TO SEGMENT WORK AREA (ASSGNBUF)
RWORK6   EQU   6        WORK REGISTER
RDECB    EQU   7        DECB ADDRESS
RCCW     EQU   7        PTR TO CCW TO MODIFY (ASSGNBUF)
RWORK7   EQU   7        WORK REGISTER
RTCB     EQU   8        TCB BASE REGISTER                        Y02072
RNEWLST  EQU   8        ADDR OF NEW UNSCHEDULED LIST
RWORK9   EQU   9        WORK REGISTER
RWORK10  EQU   10       WORK REGISTER
RWORK11  EQU   11       WORK REGISTER
RWORK12  EQU   12       WORK REGISTER
RSAVE    EQU   13       ADDRESS OF IOS SAVEAREA                  Y02072
RWORK13  EQU   13       WORK REGISTER (EXTEND RTN)               Y02072
RRETURN  EQU   14       RETURN ADDRESS
RRETCODE EQU   15       RETURN CODE REGISTER
RAPDBASE EQU   15       BASE REGISTER FOR APPENDAGE ROUTINES
RWORK15  EQU   15       WORK REGISTER
R15      EQU   15       SAVE/RESTORE REG                         Y02072
         SPACE 5
KEYDATOP EQU   X'0E'         CCW OP-CODE  READ KEY & DATE
RDDATAOP EQU   X'06'         CCW OP-CODE  READ DATA
NOP      EQU   X'03'         CCW OP-CODE
SILI     EQU   BIT2          CCW FLAGS    SUPPRESS INCORRECT
*                                         LENGTH INDICATION
*
IC       EQU   B'0001'       MASK FOR ICM, INSERTS 1 BYTE INTO
*                            LOW ORDER BYTE OF REGISTER
ADDR     EQU   B'0111'       MASK FOR ICM/STCM, INSERTS OR
*                            STORES A 24-BIT ADDRESS TO OR FROM
*                            THE LOW-ORDER 3 BYTES OF A REGISTER.
FIXERR   EQU   8             RETURN CODE IF GETMAIN FAILS FOR
*                            EXTEND FUNCTION
*
         EJECT
*
SIORTNE  EQU   *
*                                                                     *
* FUNCTION:                                                           *
*    THE START-I/O APPENDAGE ATTEMPTS TO ASSIGN A BUFFER TO A         *
*    READ REQUEST IF THE REQUEST SPECIFIES DYNAMIC BUFFERING AND      *
*    NO BUFFER WAS ASSIGNED BEFORE EXCP.  IF A BUFFER IS              *
*    AVAILABLE FOR ASSIGNMENT, IT IS REMOVED FROM THE BUFFER          *
*    POOL AND THE BUFFER CHAIN IS UPDATED.  THE BUFFER ADDRESS        *
*    IS PLACED IN THE REQUEST'S DECB AND IN THE READ CCWS OF THE      *
*    REQUEST'S CHANNEL PROGRAM.  THE ADDRESS OF THE SEGMENT WORK      *
*    AREA (PART OF THE BUFFER) IS PLACED IN THE IOB.  THE ROUTINE     *
*    THEN RETURNS TO IOS TO INITIATE THE I/O.                         *
*    IF NO BUFFER IS AVAILABLE THE REQUEST IS PLACED ON A QUEUE       *
*    OF REQUESTS WAITING FOR BUFFERS.  THE ROUTINE TAKES THE IOS      *
*    RETURN WHICH INDICATES THAT THE I/O REQUEST SHOULD NOT BE        *
*    INITIATED.                                                       *
*    IF NO BUFFER IS AVAILABLE AND THE ADDRESS OF THE IOB FOR         *
*    THIS REQUEST CANNOT BE PLACED ON THE CURRENT UNSCHEDULED         *
*    LIST, THE CHANNEL PROGRAM IS MODIFIED TO PREVENT DATA            *
*    TRANSFER AND THE NORMAL RETURN TO IOS IS TAKEN.  THE             *
*    CHANNEL END APPENDAGE WILL SCHEDULE THE ASYNCHRONOUS             *
*    ROUTINE, WHICH WILL EXTEND THE UNSCHEDULED LIST IF NECES-        *
*    SARY, AND WILL RE-ISSUE THE EXCP.                                *
*                                                                     *
* ENTRY POINT:                                                        *
*         SIOEP -- ENTERED ASYNCHRONOUSLY FROM IOS AT START-I/O       *
*         TIME.  THE ADDRESS OF IGG019JB IS PLACED IN THE             *
*         APPENDAGE VECTOR TABLE (AVT) DURING OPEN PROCESSING.        *
*         CALLING SEQUENCE -- L     15,4(AVTPTR)                      *
*                             BALR  14,15                             *
*                                                                     *
* INPUT                                                               *
*    **** REGISTER CONTENTS ****                                      *
*    REGISTER  1 -- REQUEST QUEUE ELEMENT (RQE) ADDRESS               *
*    REGISTER  2 -- INPUT/OUTPUT BLOCK (IOB) ADDRESS                  *
*    REGISTER  3 -- DATA EXTENT BLOCK (DEB) ADDRESS                   *
*    REGISTER  4 -- DATA CONTROL BLOCK (DCB) ADDRESS                  *
*    REGISTER  7 -- UNIT CONTROL BLOCK (UCB) ADDRESS                  *
*    REGISTER 13 -- IOS REGISTER SAVEAREA                       Y02072*
*    REGISTER 14 -- RETURN ADDRESS                                    *
*    REGISTER 15 -- ADDRESS OF IGG019JB                               *
*                                                                     *
* OUTPUT                                                              *
*    **** REGISTER CONTENTS ****                                      *
*    ALL REGISTER CONTENTS ARE UNCHANGED                              *
*                                                                     *
*    **** DATA AREAS SET BY THIS ROUTINE ****                         *
*    IOBSWAP            IF A BUFFER IS ASSIGNED, SEGMENT WORK         *
*                       AREA ADDRESS                                  *
*    IOBDSTAT BIT IOBBUFF    SET IF A BUFFER IS ASSIGNED              *
*    IOBDQSW,IOBDQCP    SET IF NO BUFFER IS AVAILABLE & THERE IS      *
*                       NO ROOM ON THE CURRENT UNSCHEDULED LIST       *
*                       FOR THE IOB ADDRESS. -- CHANNEL PGM MODIFIED  *
*    USLBFRQB           UPDATED IF REQUEST IS PLACED ON QUEUE         *
*                       TO WAIT FOR BUFFER                            *
*    USLBFRQT           UPDATED IF THIS REQUEST IS THE ONLY ONE ON    *
*                       THE QUEUE WAITING FOR A BUFFER.               *
*    BCBBFAVL           UPDATED IF A BUFFER IS ASSIGNED               *
*    DECAREA            DATA ADDR IN THE ASSIGNED BUFFER              *
*    DECKYADR           KEY ADDR IN THE ASSIGNED BUFFER FOR A READ    *
*                       BY BLOCK ID, & KEY ADDR SPECIFIED 'S'.        *
*    DECARB1            SAVEAREA FOR OP-CODE OF CCW1 IF CHANNEL       *
*                       PROGRAM IS MODIFIED.                          *
*    DECARB2            SAVEAREA FOR FLAGS OF CCW1 IF CHANNEL         *
*                       PROGRAM IS MODIFIED.                          *
*    NEXT-TO-LAST CCW ADDR   KEY ADDR WHEN KEY IS IN DYNAMIC BUFFER   *
*                            (SEE DECKYADR).                          *
*    LAST CCW ADDR      DATA ADDR                                     *
*                                                                     *
* EXITS                                                               *
*         0(R14)        RETURN TO IOS & START I/O                     *
*         4(R14)        RETURN TO IOS & DISREGARD I/O REQUEST         *
*                                                                     *
* ATTRIBUTES -- REENTRANT,PRIVILEGED,KEY=0,ENABLED, WITH THE LOCAL    *
*    LOCK HELD. MODESET IS ISSUED TO PROCESS IN USER KEY.             *
***********************************************************************
****                                                               ****
         USING IOBSTDRD,RIOB
         USING IHADCB,RDCB
         TM    IOBDTYP2,IOBRQUST  IS THIS A READ REQUEST?
         BCR   8,RRETURN          IF NOT, RETURN TO IOS
         TM    IOBDTYPE,IOBDYNBF  DOES REQUEST SPECIFY DYNAMIC
*                                 BUFFERING?
         BCR   8,RRETURN          IF NO, RETURN TO IOS
         TM    IOBSTAT1,IOBBUFF   HAS A BUFFER BEEN ASSIGNED TO
*                                 THIS REQUEST?
         BCR   1,RRETURN          IF SO, RETURN TO IOS
*
*                       IF A BUFFER IS AVAILABLE, ASSIGN IT TO
*                       THIS REQUEST AND UPDATE THE BUFFER POOL.
*
         STM   R0,R15,0(RSAVE)          SAVE IOS REGISTERS       Y02072
         USING RQE,RRQE                 ESTABLISH RQE BASE       Y02072
*
         MODESET  KEYADDR=RQEPRT,WORKREG=10  CHANGE TO USER KEY  Y02072
*
         L     RWORK10,DCBBUFCB         GET BUFFER CONTROL BLOCK ADDR
         USING BCBDEFV,RWORK10          ESTABLISH BASE FOR BCB   Y02072
         SR    RWORK11,RWORK11
         ICM   RWORK11,IC,BCBBFAVL      GET BUFFER NUMBER FOR NEXT
*                                       AVAILABLE BUFFER
         BZ    PTONBUFQ           IF NONE AVAILABLE, BRANCH TO
*                                 PUT REQUEST ON QUEUE
         IC    RWORK9,BCBSUFFX-1(RWORK11)   GET NUMBER OF 2ND
*                                 AVAILABLE BUFFER.
         STC   RWORK9,BCBBFAVL    MAKE IT THE NEXT AVAILABLE
*
*                                 COMPUTE ADDR OF THE BUFFER TO
*                                 BE ASSIGNED.
*
         BCTR  RWORK11,0          BUFFER NUMBER - 1.
         L     RWORK7,BCBBUFL     LENGTH OF EACH BUFFER
         MR    RWORK6,RWORK11     BUFFER # -1 * BUFFER LENGTH
*                                 = DISPLACEMENT INTO BUFFER POOL
         LR    RWORK11,RWORK7
         A     RWORK11,BCBBUF1    + ADDR OF BUFFER #1 = BUFFER
*                                 ADDR.
         DROP  RWORK10,RRQE                                      Y02072
         BAL   RLINK,ASSGNBUF     ASSIGN BUFFER TO REQUEST
*
SIORET   EQU   *                        RETURN TO IOS            Y02072
*
         MODESET  KEYADDR=IOSKEY,WORKREG=10  CHANGE TO IOS KEY   Y02072
*
         LM    R0,R15,0(RSAVE)          LOAD IOS REGISTERS       Y02072
         BR    RRETURN                  RETURN TO IOS TO INITIATE
*                                       I/O REQUEST
         SPACE 5
PTONBUFQ EQU   *
*
*                       NO BUFFER WAS AVAILABLE. PUT THIS IOB ON
*                       THE QUEUE WAITING FOR BUFFERS.
*
*
         L     RWORK11,DCBDYNB    ADDR OF CURRENT LIST
         USING USL,RWORK11
*
*                       PUT IOB ADDR ON THE UNSCHEDULED LIST
*
         L     RWORK10,USLBFRQB   ADDR OF LAST LIST SLOT USED
         LTR   RWORK10,RWORK10    ANY USED?
         BZ    EMPTYQ             BRANCH IF NONE
         USING USLSLOT,RWORK10
         TM    USLSLTFL,USLENDL   IS LAST ONE END OF LIST ?
         BZ    BUMP               BRANCH IF NOT
         LA    RWORK10,USLSLOT1-4 LOOP TO POINT TO 1ST SLOT
BUMP     LA    RWORK10,USLNXT     POINT TO NEXT SLOT
         TM    USLSLTFL,USLINUSE  IS THIS SLOT ALREADY IN USE?
         BO    RECOUP             BRANCH YES, LIST IS FULL
*
STIOBADR ST    RWORK10,USLBFRQB   THIS SLOT IS LAST USED
         STCM  RIOB,ADDR,USLIOBA+1     PLACE IOB ADDR IN SLOT
         OI    USLSLTFL,USLINUSE  MARK SLOT NOT AVAILABLE
         DROP  RWORK10
*
         MODESET  KEYADDR=IOSKEY,WORKREG=10  CHANGE TO IOS KEY   Y02072
*
         LM    R0,R15,0(RSAVE)          LOAD IOS REGISTERS       Y02072
         B     4(RRETURN)               IOS RETURN - DON'T DO I/O
*
EMPTYQ   LA    RWORK10,USLSLOT1   USE FIRST SLOT ON LIST
*                                 TOP SLOT IS FIRST ON QUEUE
         STCM  RWORK10,ADDR,USLBFRQT+1
         B     STIOBADR
         DROP  RWORK11
*
*                       THE IOB ADDRESS CANNOT BE PLACED ON THE
*                       CURRENT UNSCHEDULED LIST BECAUSE THE
*                       LIST IS FULL.
*                       MODIFY THE CHANNEL PROGRAM SO THAT NO
*                       DATA IS TRANSFERRED. THE CHANNEL
*                       PROGRAM WILL BE REPAIRED AND THE EXCP
*                       WILL BE REISSUED BY THE ASI ROUTINE.
*
RECOUP   L     RWORK10,IOBECBPT   GET DECB ADDRESS
         USING DECB,RWORK10
         IC    RWORK9,IOBCHNPR    SAVE OP-CODE OF CCW1
         STC   RWORK9,DECARB1
         MVI   IOBCHNPR,NOP       SET OP-CODE TO NOP
         IC    RWORK9,IOBCHNPR+4  SAVE FLAGS OF CCW1
         STC   RWORK9,DECARB2
         MVI   IOBCHNPR+4,SILI    SUPPRESS INCORRECT LENGTH FLAG
         OI    IOBDQSW,IOBDQCP    CHANNEL PGM HAS BEEN ALTERED
         B     SIORET             TAKE NORMAL IOS RETURN
*                       (MUST GET TO CEA TO SCHEDULE ASI)
         DROP  RWORK10
         DROP  RIOB
         DROP  RDCB
*
         EJECT
*
*                  THIS SUBROUTINE IS USED BY THE START-I/O
*                  APPENDAGE AND THE FREE DYNAMIC BUFFER SVC
*                  ROUTINE. IT IS ENTERED IN USER KEY.
*                  IT ASSIGNS A BUFFER TO AN I/O REQUEST BY
*                  PLACING THE BUFFER ADDRESS INTO THE DECB
*                  AND THE CHANNEL PROGRAM.  IT ALSO PLACES THE
*                  SEGMENT WORK AREA ADDRESS IN THE IOB.
*
*              REGISTER INPUT:  RIOB    - ADDR OF IOB TO WHICH
*                                         BUFFER WILL BE ASSIGNED
*                               RDCB    - DCB ADDRESS
*                               RWORK11 - BUFFER ADDRESS
*                               RLINK   - RETURN ADDRESS
*              REGISTER OUTPUT: RSWA    - WORK REGISTER
*                               RWORK9  - WORK REGISTER
*                               RCCW    - WORK REGISTER
*                               RWORK10 - WORK REGISTER
*                               RWORK11 - WORK REGISTER
         USING SWA,RWORK11        ESTABLISH BASE FOR SEG WRKAREA Y02072
         USING IHADCB,RDCB
         USING IOBSTDRD,RIOB
ASSGNBUF L     RWORK9,IOBECBPT    GET DECB ADDRESS
         USING DECB,RWORK9
*                                 PLACE SWA ADDR IN IOB
         LR    RWORK10,RIOB       PLACE IOB ADDRESS IN WORK REG
         LA    RSWA,IOBSTDRD-IOBSWAP   DISP TO IOBSWAP FIELD
         SR    RWORK10,RSWA       POINT TO IOB PREFIX
         USING IOBSWAP,RWORK10
         ST    RWORK11,IOBSWAP    PLACE SWA ADDR IN IOB
*                                 DATA & KEY (IF REQUESTED) WILL
*                                 BE READ INTO THE SEGMENT AREA
*                                 OF THE DYNAMIC BUFFER.  THE
*                                 USER WILL BE PASSED THE ADDRESS
*                                 OF LOCATIONS IN THE RECORD
*                                 AREA.
*
         LA    RSWA,SWASEGMT      GET ADDRESS OF SEGMENT AREA    Y02072
*
         L     RWORK10,DCBBUFCB   ADDRESS BUFFER CONTROL BLOCK
         USING BCBDEFV,RWORK10    ESTABLISH BASE FOR BCB         Y02072
         L     RWORK10,BCBRAOFS-1 GET DISPLACEMENT OF RECORD
         DROP  RWORK10            AREA FROM START OF BUFFER.
         LA    RWORK11,0(RWORK10,RWORK11)        ADDR OF RECORD AREA
*
         L     RCCW,IOBDCPND      POINT BEYOND LAST CCW
         SH    RCCW,H16           POINT TO NEXT-TO-LAST CCW
*                                 FOR A READ BY BLOCK ID, KEY
*                                 CODED 'S', THE KEY IS READ
*                                 INTO THE DYNAMIC BUFFER.
         TM    IOBDTYP2,IOBTYPE   IS THIS READ BY BLOCK ID?
         BO    FILLSCCW           BRANCH IF NO
         TM    IOBDTYP2,IOBSKEY   WAS KEY ADDRESS CODED 'S'?
         BZ    FILLSCCW           BRANCH IF NO
         ST    RWORK11,DECKYADR   PLACE KEY ADDRESS IN DECB
         CLI   DCBKEYLE,0         IS KEY LENGTH ZERO             XM1559
         BE    FILLSCCW           BR IF YES                      XM1559
         ST    RWORK11,0(RCCW)    PLACE ADDR OF KEY IN RECORD   XA00093
*                                 AREA INTO NEXT-TO-LAST CCW.
         MVI   0(RCCW),KEYDATOP   RESTORE OP-CODE
*                                 INCREMENT RECORD AREA & SEGMENT
*                                 AREA POINTERS BEYOND KEY.
         SR    RWORK10,RWORK10
         IC    RWORK10,DCBKEYLE   GET LENGTH OF KEY
         AR    RWORK11,RWORK10    BUMP RECORD AREA POINTER
*
FILLSCCW ST    RWORK11,DECAREA    PLACE DATA ADDRESS IN DECB
         ST    RSWA,8(RCCW)       PLACE DATA ADDRESS IN LAST CCW
         MVI   8(RCCW),RDDATAOP   RESTORE OP-CODE.
         OI    IOBDSTAT,IOBBUFF   SET BUFFER-ASSIGNED SWITCH
         BR    RLINK              RETURN TO CALLER
         DROP  RWORK11
         DROP  RWORK9
         DROP  RIOB
         DROP  RDCB
         EJECT
FBUFRTNE EQU   *
*                                                                     *
* FUNCTION:                                                           *
*    THE FREE DYNAMIC BUFFER ROUTINE RELEASES A DYNAMIC BUFFER.       *
*    IF ANY IOBS ARE ON THE UNSCHEDULED QUEUE (WAITING FOR A          *
*    BUFFER) THE ROUTINE ASSIGNS THE BUFFER TO THE FIRST IOB ON       *
*    THE QUEUE, AND ISSUES AN EXCP FOR THAT IOB.  IF NO IOBS ARE      *
*    ON THE UNSCHEDULED QUEUE THE ROUTINE PLACES THE BUFFER ON        *
*    THE CHAIN OF AVAILABLE BUFFERS.                                  *
*    THE EXTEND-LIST FUNCTION IS ALSO CALLED VIA THE FREE DYNAM-      *
*    IC BUFFER SVC.  IT GETS STORAGE FOR AN UNSCHEDULED LIST          *
*    WHICH IS TWICE AS LARGE AS THE PREVIOUS LIST.  IT INITIALIZES    *
*    THE NEW LIST (AND MOVES ALL ENTRIES FROM THE OLD LIST TO         *
*    THE NEW LIST) AND PLACES ITS ADDRESS IN DCBDYNB.                 *
*                                                                     *
* ENTRY POINT:                                                        *
*         FRBUFEP -- ENTERED FROM MODULE IGC0005G WHEN SVC 57 IS      *
*         ISSUED FOR A DCB WHICH SPECIFIED DIRECT ORGANIZATION.       *
*         CALLING SEQUENCE -- L    15,DCBDEBAD                        *
*                             L    15,DEBAPPAD                        *
*                             L    15,4(15)                           *
*                             BAL  14,8(15)                           *
*                                                                     *
* INPUT                                                               *
*    **** REGISTER CONTENTS ****                                      *
*    REGISTER  0 -- DECB ADDRESS                                      *
*                  R0 IS NEGATIVE FOR THE EXTEND-LIST FUNCTION.       *
*    REGISTER  1 -- DCB ADDRESS                                       *
*    REGISTER  5 -- ADDRESS OF SVRB                                   *
*    REGISTER  8 -- ADDRESS OF TCB PASSED BY FREEDBUF                 *
*    REGISTER 14 -- RETURN ADDRESS                                    *
*    REGISTER 15 -- ADDRESS OF IGG019JB                               *
*                                                                     *
* OUTPUT                                                              *
*    **** REGISTER CONTENTS ****                                      *
*    ALL REGISTERS EXCEPT REGISTER 14 CAN BE USED WITHOUT SAVING      *
*    OR RESTORING CONTENTS.                                           *
*    REGISTER 15 CONTAINS RETURN CODE.                                *
*                                                                     *
*    **** DATA FIELDS SET BY THIS ROUTINE ****                        *
*    USLBFRQT      IF AN IOB IS WAITING FOR A BUFFER, PTR TO 1ST      *
*                  IOB ON QUEUE IS UPDATED.                           *
*    USLBFRQB      IF, AFTER 1 IOB IS DEQUEUED, THE LIST IS EMPTY,    *
*                  USLBFRQB IS SET TO ZERO.                           *
*    IF THE FREED BUFFER IS ASSIGNED TO A WAITING REQUEST, THE        *
*    BUFFER ADDRESS IS PLACED IN THE CHANNEL PROGRAM AND DECB         *
*    FIELDS, AND IN THE IOB AS THE SEGMENT WORK AREA ADDRESS (SEE     *
*    SIORTNE DESCRIPTION FOR DETAILS).                                *
*    SWABFINC      SET TO ZERO                                        *
*    BCBBFAVL      IF THE BUFFER IS NOT ASSIGNED TO A REQUEST,        *
*                  ITS NUMBER IS PLACED IN BCBBFAVL.  THE             *
*                  CORRESPONDING BYTE OF THE BUFFER POOL SUFFIX       *
*                  WILL POINT TO THE SECOND AVAILABLE BUFFER.         *
*    DCBDYNB       FOR THE EXTEND FUNCTION, POINTS TO NEW LIST.       *
*            THE LIST IS INITIALIZED AS FOLLOWS:                      *
*    USLSIZE       LIST SIZE IN BYTES -- 2* OLD LIST SIZE             *
*    USLFLAGS      BIT USLCURNT SET IN NEW LIST, TURNED OFF IN        *
*                  OLD LIST.                                          *
*    USLBFRQT      THE IOB ADDRESSES ARE ARRANGED SUCH THAT THE       *
*                  ADDR OF THE 1ST IOB ON THE OLD LIST IS COPIED      *
*                  INTO THE TOP SLOT ON THE NEW LIST.  IF NO          *
*                  IOBS ARE ON THE LIST, SET TO ZERO.                 *
*    USLBFRQB      ADDR OF SLOT USED BY LAST IOB ON QUEUE (OR 0       *
*                  IF THERE ARE NONE.)                                *
*    USLCHAIN      ADDRESS OF PRIOR LIST COPY                         *
*    IOBDQSW, BIT IOBDQEXT   RESET ON COMPLETION OF EXTEND            *
*    SVRB          SEE BELOW
*                                                                     *
* EXTERNAL REFERENCES                                                 *
*        EXCP CALL TO IOS                                             *
*        GETMAIN FOR NEW UNSCHEDULED LIST (EXTEND FUNCTION)           *
*        MODESET   TO CHANGE BETWEEN SUPERVISOR AND USER KEYS         *
*        SETLOCK   TO RELEASE AND OBTAIN THE LOCAL LOCK               *
*                                                                     *
* EXITS, NORMAL                                                       *
*    BRANCH RETURN TO IGC0005G ON REGISTER 14.  RETURN CODE (R15)     *
*    = 0.                                                             *
*                                                                     *
* EXITS, ERROR                                                        *
*     BRANCH RETURN TO IGC0005G ON REGISTER 14.  RETURN CODE (R15)    *
*     = 8.  THE BUFFER HAS NOT BEEN FREED, OR THE UNSCHEDULED         *
*     LIST HAS NOT BEEN EXTENDED.  THIS CAN OCCUR AS A RESULT OF      *
*     GETMAIN FOR THE NEW UNSCHEDULED LIST CANNOT BE SATISFIED.       *
*                                                                     *
* TABLES / WORK AREAS                                                 *
*        IOB, DCB, DECB, BUFFER CONTROL BLOCK                         *
*        UNSCHEDULED LIST, & SVRB EXTENDED SAVEAREA                   *
*                                                                     *
* ATTRIBUTES -- REENTRANT, PRIVILEGED. ENTRY IS IN SUPERVISOR KEY     *
*        WITHOUT THE LOCAL LOCK HELD. RETURN TO IGC0005G IS IN        *
*        SUPERVISOR KEY. MOST PROCESSING IS IN USER KEY.              *
*                                                                     *
* NOTES -- THE ROUTINE MUST HAVE THE LOCAL LOCK TO UPDATE THE SERIALLY*
*        REUSABLE IOB AND BUFFER QUEUES. SETLOCK WILL BE ISSUED THEN. *
*                                                                     *
*****                                                             *****
         EJECT
         LR    RBASE3,RAPDBASE    ESTABLISH BASE REGISTER
         USING IGG019JB,RBASE3
         DROP  RAPDBASE
         LR    RDCB,R1            TRANSFER DCB ADDRESS
         USING IHADCB,RDCB
         USING RBSECT,RSVRB       ESTABLISH BASE FOR SVRB        Y02072
         ST    RRETURN,WKAREG14   SAVE RETURN REGISTER
         USING TCB,RTCB           ESTABLISH BASE FOR TCB         Y02072
*                                 PASSED BY FREEDBUF IN R8       Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=6  CHANGE TO USER KEY Y02072
*
         LTR   RDECB,R0           TEST FOR SPECIAL FUNCTION
         BNP   EXTEND             BRANCH YES
         USING DECB,RDECB
*
*                       LOCATE THE BEGINNING ADDRESS OF THE
*                       BUFFER BEING FREED.
*
         L     RBUFFR,DECAREA     ASSUME RECORD AREA ADDR = DATA
*                                 ADDR
         TM    DECTYPE2,DECKEYS   WAS KEY IN BUFFER (CODED 'S')?
         BZ    FBU0500            BRANCH NO
         L     RBUFFR,DECKYADR    RECORD AREA ADDR = KEY ADDR
FBU0500  EQU   *
         LA    RWORK12,BUFRECAR-BUFBFPTR
         SR    RBUFFR,RWORK12     POINT TO ADDR OF BEGINNING OF
*                                 BUFFER
         L     RBUFFR,0(RBUFFR)         GET BUFFER ADDRESS
         USING SWA,RBUFFR               ESTABLISH BASE FOR SWA   Y02072
         XC    SWABFINC,SWABFINC        RECORD AREA OFFSET PTR   Y02072
         L     RWORK10,DCBDYNB          ADDR OF UNSCHEDULED LIST Y02072
         USING USL,RWORK10              USL ADDRESSABILITY       Y02072
         L     RWORK12,DCBBUFCB         GET BCB ADDRESS          Y02072
         USING  BCBDEFV,RWORK12         BCB ADDRESSABILITY       Y02072
*
*   PREPARE FOR QUEUE UPDATES. THIS REQUIRES THAT THE LOCAL LOCK BE
*   OBTAINED WHILE MANIPULATING THE QUEUE. IT IS RELEASED WHEN THE
*   QUEUE HAS BEEN UPDATED AND THE NEXT WAITING IOB HAS BEEN REMOVED,
*   OR THE BUFFER HAS BEEN PUT BACK ON THE AVAILABLE BUFFER QUEUE.
*   MODESET IS ISSUED BECAUSE SETLOCK REQUIRES SUPERVISOR KEY.
*   SETLOCK USES REGISTERS 11-14 WITHOUT RESTORING THEM. CERTAIN
*   FIELDS WILL BE SAVED AT THIS POINT SHOULD THE ESTAE NEED THEM.
*
         IC    RWORK9,BCBBFAVL          GET NEXT AVAIL BUF NO    Y02072
*                                       FOR ESTAE- 1 BYTE        Y02072
         DROP  RWORK12                  DROP BCB BASE            Y02072
         L     RWORK0,USLBFRQT          GET USL CONTENTS FOR     Y02072
*                                       ESTAE - IN USER KEY      Y02072
*
         MODESET  EXTKEY=ZERO           CHANGE TO SUPER KEY      Y02072
*                                       TO GET THE LOCAL LOCK    Y02072
*
GETLOCK  SETLOCK  OBTAIN,TYPE=LOCAL,RELATED=('BUFFERQ,IGG019JB(FREELOCKX
               ,FREELCK1)'),MODE=UNCOND  GET THE LOCAL LOCK      Y02072
*
         ST    RBUFFR,WKABUFRG          SAVE BUF PTR FOR ESTAE   Y02072
         ST    RWORK0,WKASAVE           SAVE USL CONTENT IN SVRB Y02072
         STC   RWORK9,WKASAVE2          SAVE NEXT AVAIL BUF NO.  Y02072
*                                       FOR ESTAE IN CASE PATH   Y02072
*                                       TAKEN CHANGES THIS       Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=11 RET TO USER KEY    Y02072
*
         ICM   RWORK9,ADDR,USLBFRQT+1   PTR TO 1ST IOB ON QUEUE
         BZ    FBUNOREQ                 BRANCH IF NO IOBS TO MAKE
*                                       BUFFER AVAILABLE
         USING USLSLOT,RWORK9
         L     RIOB,USLSLOT             GET IOB ADDRESS
         USING IOBSTDRD,RIOB
*
         MODESET  EXTKEY=ZERO           CHANGE TO ZERO KEY       Y02072X
                                        TO SAVE IOB PTR          Y02072
         ST    RIOB,WKAIOBRG            SAVE IOB PTR FOR ESTAE   Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=11  RET TO USER KEY   Y02072
*
         NI    USLSLTFL,X'FF'-USLINUSE  MAKE SLOT AVAILABLE
         TM    USLSLTFL,USLENDL   IS THIS LAST SLOT IN LIST?
         BZ    NXTSLT             BRANCH IF NO
         LA    RWORK9,USLSLOT1-4 GET BACK TO TOP OF LIST
NXTSLT   LA    RWORK9,USLNXT      BUMP SLOT POINTER 1 ENTRY
         TM    USLSLTFL,USLINUSE  IS THERE ANOTHER IOB WAITING?
         BO    STOREPTR           BRANCH IF YES
         DROP  RWORK9
         SR    RWORK9,RWORK9
         ST    RWORK9,USLBFRQB          MARK QUEUE EMPTY BY SETTING
*                                       TOP & BOTTOM PTRS TO ZERO.
STOREPTR STCM  RWORK9,ADDR,USLBFRQT+1   SLOT OF FIRST IOB (OR 0)
         DROP  RWORK10                                           Y02072
*
         MODESET  EXTKEY=ZERO           CHANGE TO ZERO KEY       Y02072X
                                        TO SET BIT IN SVRB       Y02072X
                                        AND RELEASE LOCAL LOCK   Y02072
         MVI   WKATRAIL,WKAIOBQ         SET BIT IN SVRB EXT SAVE Y02072
*                                       AREA INDICATING IOB DEQ  Y02072
*
FREELOCK SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('BUFFERQ,IGG019JB(GETLOCKX
               )')                      FREE THE LOCAL LOCK      Y02072
*
ESTENTA  EQU   *                        ESTAE ENTRY IF WKAIOBQ=1 Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=11  RET TO USER KEY   Y02072
*
         LR    RAPDBASE,RBASE3          LOAD BASE FOR COMMON SUBRTNE
         LR    RWORK11,RBUFFR           PUT BUFFER ADDR IN R11
         BAL   RLINK,ASSGNBUF           ASSIGN THE BUFFER TO THE
*                                       DEQUEUED IOB.
*
         MODESET  EXTKEY=ZERO           CHANGE TO ZERO KEY       Y02072X
                                        TO SET BIT IN SVRB       Y02072
         MVI   WKATRAIL,WKABUFAS        SET BIT IN SVRB EXTENDED Y02072
*                                       SAVEAREA INDICATING BUF  Y02072
*                                       ASSIGNED TO NEXT IOB     Y02072
ESTENTB  EQU   *                        ESTAE ENTRY IF WKABUFAS  Y02072
*                                       BIT IS ON                Y02072
         MODESET  KEYADDR=WKASVKEY,WORKREG=11  RET TO USER KEY   Y02072
*
         L     RWORK11,IOBECBPT         LOAD ADDR TO USER'S DECB Y02072
         ST    RWORK11,IOBDQPTR         SAVE DECB ADDR IN IOB    Y02072
         LA    RWORK11,IOBCSW+3         SET UP CSW ADDRESS TO    Y02072
         ST    RWORK11,IOBECBPT         USE AS DUMMY ECB FOR IOS Y02072
*                                       CEA OR EOE WILL RESTORE  Y02072
*                                       USER'S DECB ADDR IN IOB  Y02072
*
         EXCP  (RIOB)                   SCHEDULE I/O FOR NEXT IOB ON Q
*
         MODESET  EXTKEY=ZERO           RETURN TO ZERO KEY       Y02072
*
         MVI   WKATRAIL,WKAEXCP         SET BIT INDICATING EXCP  Y02072
*
         B     NORMEXIT                 NORMAL RET TO IGC0005G   Y02072
         SPACE 5
*
*     NO IOBS ARE WAITING FOR BUFFERS. RETURN BUFFER TO AVAILABLE
*     BUFFER QUEUE.  THIS ROUTINE IS ENTERED IN USER KEY WITH THE
*     LOCAL LOCK HELD. RETURN TO FREEDBUF FROM THIS ROUTINE IS IN
*     SUPERVISOR KEY.
*
FBUNOREQ L     RWORK12,DCBBUFCB   ADDR OF BUFFER CONTROL BLOCK   Y02072
         USING BCBDEFV,RWORK12    ESTABLISH BASE FOR BCB         Y02072
*
*                 COMPUTE BUFFER NUMBER FROM BUFFER ADDRESS
*
         LR    RWORK1,RBUFFR      BUFFER ADDRESS
         S     RWORK1,BCBBUF1     MINUS ADDR OF 1ST BUFFER
*                                  = DISP INTO BUFFER POOL
         SR    RWORK0,RWORK0
         L     RWORK11,BCBBUFL
         DR    RWORK0,RWORK11     DIVIDED BY BUFFER LENGTH
*                                  = BUFFER NUMBER -1.
         LA    RWORK1,1(RWORK1)   PLUS 1 = BUFFER NUMBER
*
*                      PLACE BUFFER # ON AVAILABLE CHAIN
*
         IC    RWORK9,BCBBFAVL    NEXT AVAIL BUFFER #
         STC   RWORK9,BCBSUFFX-1(RWORK1)    POINT CHAIN ENTRY
*                                 FOR THIS BUFFER TO IT
         STC   RWORK1,BCBBFAVL    MAKE THIS BUFFER NEXT AVAIL
*
*             RELEASE LOCAL LOCK AND SET AUDIT TRAIL BIT
*
         MODESET  EXTKEY=ZERO           CHANGE TO ZERO KEY       Y02072X
                                        TO SET BIT IN SVRB       Y02072X
                                        AND RELEASE LOCK         Y02072
         MVI   WKATRAIL,WKABUFQ         SET BIT INDICATING BUF   Y02072
*                                       FREED AND PUT ON QUEUE   Y02072
*
FREELCK1 SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('BUFFERQ,IGG019JB(GETLOCKX
               )')                      FREE THE LOCAL LOCK      Y02072
*
         B     NORMEXIT                 NORMAL RETURN TO IGC0005G
*
         EJECT
EXTEND   EQU   *
*
*                  THIS FUNCTION IS ONLY CALLED FROM THE
*                  ASYNCHRONOUS ROUTINE AND THUS IT WOULD BE
*                  IMPOSSIBLE FOR A SECOND EXTEND REQUEST TO BE
*                  ISSUED ON A GIVEN DCB BEFORE THE FIRST
*                  REQUEST COMPLETED. IT IS ENTERED IN USER KEY
*                  AND EXITS IN SUPERVISOR KEY.
*
*                  GET STORAGE FOR AN UNSCHEDULED LIST TWICE AS
*                  LARGE AS THE CURRENT ONE.
*
         LPR   RDECB,RDECB        GET DECB ADDR (UNCOMPLEMENTED)
         L     RWORK10,DCBDYNB    GET ADDR OF CURRENT UNSCHED-   Y02072
         USING USL,RWORK10        ULED LIST.                     Y02072
         LH    RWORK11,USLSIZE    SIZE OF CURRENT LIST           Y02072
         SLL   RWORK11,1          *2 = SIZE OF NEW LIST          Y02072
*
         GETMAIN RC,SP=0,LV=(RWORK11)   GET CORE FOR NEW USL     Y02072
*
         LTR   RRETCODE,RRETCODE        DO I HAVE THE CORE?
         BNZ   ERREXIT5                 BRANCH IF NO.
         LR    RNEWLST,R1               GET ADDR OF NEW LIST     Y02072
*
         MODESET  EXTKEY=ZERO           CHANGE TO KEY ZERO TO    Y02072X
                                        GET LOCK AND ST IN SVRB  Y02072
*
*
*     IT IS NECESSARY TO GET THE LOCAL LOCK TO MOVE THE OLD
*     USL LIST CONTENTS INTO THE NEW GOTTEN AREA. SETLOCK
*     USES REGISTERS 11-14 WITHOUT RESTORING THEM.
*
         ST    RWORK11,WKAESTAE         SAVE R11 AROUND SETLOCK  Y02072
*
EXTLOCK  SETLOCK  OBTAIN,TYPE=LOCAL,MODE=UNCOND,RELATED=('BUFFERQ,IGG01X
               9JB(EXTFREE)')           GET THE LOCAL LOCK       Y02072
*
         L     RWORK11,WKAESTAE         RESTORE R11              Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=9   RET TO USER KEY   Y02072
*
*
         LA    RWORK1,0(RNEWLST,RWORK11)  END OF LIST            Y02072
*
*                  INITIALIZE NEW LIST
*
         XC    0(USLSLOT1-USL,RNEWLST),0(RNEWLST)     CLEAR TO 0
         STH   RWORK11,USLSIZE-USL(RNEWLST)  SIZE OF NEW LIST    Y02072
         LR    RWORK9,RWORK10           GET ADDR OF OLD USL LIST Y02072
         AH    RWORK9,USLSIZE           ADD LEN TO GET END ADDR  Y02072
         LA    RWORK6,USLSLOT1-USL(RNEWLST)
*                                 LESS FIRST SLOT ADDR, NEW LIST
         SR    RWORK1,RWORK6      = LENGTH OF ENTRIES, NEW LIST
*
*
*                  IF THE LIST HAS ENTRIES IN 2 NONCONTIGUOUS
*                  SEGMENTS, FIRST MOVE THE SEGMENT CORRESPONDING
*                  TO THE TOP OF THE QUEUE. THE SEGMENTS WILL BE
*                  MOVED WITH MVCL WHICH DEPENDS ON TWO REGISTER
*                  PAIRS:  R12-R13  AND  R6-R7
*
         ICM   RWORK12,ADDR,USLBFRQT+1  ADDR OF TOP QUEUE ENTRY  Y02072
         BZ    CLRLST
         LR    RWORK13,RWORK9           SAVE FOR LEN CALCULATION Y02072
*                                       ENDING ADDR OF OLD USL   Y02072
         SH    RWORK9,H4                POINT TO LAST ENTRY, OLD LIST
         USING USLSLOT,RWORK9
         NI    USLSLTFL,X'FF'-USLENDL   TURN OFF END OF LIST FLAG
*                                       BEFORE MOVE
         ST    RWORK6,USLBFRQT-USL(RNEWLST)
*                                       TOP OF QUEUE FOR NEW LIST IS
*                                       FIRST SLOT.
         LA    RWORK9,USLSLOT1    FIRST SLOT, OLD LIST.
         TM    USLSLTFL,USLINUSE  IS THIS SLOT BEING USED?
         BZ    SECSEG             BRANCH NO, 1 MOVE WILL SUFFICE
         DROP  RWORK9
         CR    RWORK12,RWORK9     IS TOP QUEUE ENTRY IN 1ST SLOT Y02072
         BE    SECSEG             BRANCH YES, AGAIN 1 MOVE OK
*
         SR    RWORK13,RWORK12    LENGTH OF 1ST SEGMENT          Y02072
         LR    RWORK7,RWORK13     RECEIVING FIELD IS SAME LGTH   Y02072
         SR    RWORK1,RWORK7      REDUCE LENGTH OF UNUSED SLOTS
         MVCL  RWORK6,RWORK12     MOVE 1ST SEGMENT TO NEW LIST   Y02072
         LA    RWORK12,USLSLOT1   2ND SEGMENT STARTS AT 1ST SLOT Y02072
*                                 OF OLD LIST.
*
*                  MOVE SECOND OR ONLY LIST SEGMENT.
*
SECSEG   L     RWORK13,USLBFRQB   LAST SLOT OF SEGMENT TO MOVE   Y02072
         USING USLSLOT,RWORK13                                   Y02072
         LA    RWORK13,USLNXT     POINT AT END ADDR + 1          Y02072
         DROP  RWORK13                                           Y02072
         SR    RWORK13,RWORK12    LENGTH OF SECOND SEGMENT       Y02072
         LR    RWORK7,RWORK13     RECEIVING FIELD IS SAME LGTH   Y02072
         SR    RWORK1,RWORK7      REDUCE AMOUNT OF UNUSED SLOTS
         MVCL  RWORK6,RWORK12     MOVE 2ND SEGMENT TO NEW LIST   Y02072
         LR    RWORK9,RWORK6      END OF LAST USED SLOT
         SH    RWORK9,H4          ADDR OF BOTTOM SLOT IN QUEUE
         ST    RWORK9,USLBFRQB-USL(RNEWLST)  INITIALIZE PTR TO
*                                 LAST SLOT OF QUEUE.
*
*                  CLEAR THE UNUSED SLOTS ON THE NEW LIST
*
CLRLST   LR    RWORK7,RWORK1      LENGTH REMAINING (TO FIELD)
         SR    RWORK13,RWORK13    SEND NO CHARACTERS, PAD X'00'  Y02072
         MVCL  RWORK6,RWORK12     CLEAR REST OF LIST             Y02072
*
         SH    RWORK6,H4          ADDR LAST SLOT
         USING USLSLOT,RWORK6
         OI    USLSLTFL,USLENDL   TURN ON END-OF-LIST FLAG
         DROP  RWORK6
*
         NI    USLFLAGS,X'FF'-USLCURNT  TURN OFF 'CURRENT' FLAG
*                                       IN OLD LIST
         OI    USLFLAGS-USL(RNEWLST),USLCURNT
*                                 TURN ON 'CURRENT' FLAG IN NEW
*                                 SET POINTER TO OLD LIST IN NEW
         ST    RWORK10,USLCHAIN-USL(RNEWLST)                     Y02072
         ST    RNEWLST,DCBDYNB    SET POINTER TO NEW LIST IN DCB
*
*     MODESET MUST BE ISSUED TO RETURN TO SUPERVISOR KEY BEFORE
*     RELEASING THE LOCAL LOCK. SETLOCK USES REGISTERS 11-14
*     WITHOUT RESTORING THEM.
*
         MODESET  EXTKEY=ZERO           RETURN TO ZERO KEY       Y02072
*
EXTFREE  SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('BUFFERQ,IGG019JB(EXTLOCKX
               )')                      FREE THE LOCAL LOCK      Y02072
*
*
*                       NORMAL EXIT
*
NORMEXIT L     RRETURN,WKAREG14   RESTORE RETURN REGISTER
         SR    RRETCODE,RRETCODE  RETURN CODE = 0.
         BR    RRETURN            RETURN TO IGC0005G
*
         SPACE 2
*
*                            ERROR EXITS.
*
ERREXIT5 LA    RRETCODE,FIXERR    LOAD ERROR CODE
         L     RRETURN,WKAREG14   RESTORE RETURN REGISTER
         BR    RRETURN            RETURN TO CALLER
*
***********************************************************************
*                           CONSTANTS                                 *
***********************************************************************
H16      DC    H'16'
H4       DC    H'4'
IOSKEY   DC    X'00'                    KEY OF IOS               Y02072
ZERO     DC    X'00'                    SVRB KEY                 Y02072
MODID    DC    C'IGG019JB'              MODULE ID                Y02072
FIX      DC    C' XM1559 '              LATEST FIX               YM5349
DATE     DC    C'11/13/73'              DATE OF LATEST FIX       YM5349
PATCH    DC    XL50'0'                  PATCH AREA               Y02072
         EJECT
***********************************************************************
*                             DSECTS                                  *
***********************************************************************
         IHAPSA                                                  Y02072
         EJECT
         IKJTCB                                                  Y02072
         EJECT
         IECDRQE                                                 Y02072
         IEZIOB
         ORG   IOBDQPTR
IOBDQSW  DS    B        FLAGS
IOBDQCP  EQU   BIT0          CHANNEL PROGRAM MODIFIED
*
         IHADCB DSORG=DA
*
         IHADECB
         ORG   DECAREA
DECARB1  DS    B                  SAVEAREA FOR CCW1 OP-CODE
DECARB2  DS    B                  SAVEAREA FOR CCW1 FLAGS
         EJECT
         IGGBCB  TYPE=DAM                                        Y02072
         SPACE 5
         IGGSWA                                                  Y02072
BUFFERB  DSECT          FORMAT OF BUFFER BEYOND SEGMENT AREA
BUFBFPTR DS    A        ADDRESS OF BEGINNING OF BUFFER
BUFRECAR EQU   *        RECORD AREA; BUFBFPTR IS ALIGNED SO THAT
*                       BUFRECAR FALLS AS SPECIFIED BY DCBBFALN.
         SPACE 5
         IGGUSL                                                  Y02072
         EJECT
         IKJRB                                                   Y02072
         IGGFRWKA                                                Y02072
         END
