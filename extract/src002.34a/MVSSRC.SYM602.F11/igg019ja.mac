 TITLE 'IGG019JA -- DYNAMIC BUFFERING MODULE, SIO APPENDAGE'
         IEZBITS
IGG019JA CSECT
*MODULE NAME = IGG019JA                                               *
*                                                                     *
*DESCRIPTIVE NAME = DYN BUF MODULE & SIO APPENDAGE,                   *
*                   VIRTUAL ADDRESS SPACE                             *
*                                                                     *
*COPYRIGHT = NONE                                                     *
*                                                                     *
*CHANGE ACTIVITY                                                      *
*              VS1-1 CHANGES/DELETIONS
*              VS2-1 CHANGES/DELETIONS
*              VS1-2 CHANGES/DELETIONS
*              VS2-2 CHANGES/DELETIONS
*006000,029000,032000,051000-055000,062000-159000,170000-213000,292000,
*321000,334000-343000,361000,557000,579000,582000-599000,619000,621000,
*625000,629000,631000,661000-663000,668000-738000,752000-753000,
*765000-768000,770000-787000,793000,810000,868000-870000,882000-892000,
*902000-904000,925000-932000,936000-969000                       Y02072
*              VS2-4 CHANGES/DELETIONS
*A2871000-288040,370020-377040,414020-415120,575040-575092,    @ZA08000
*A924020-924120,897740-898020                                  @ZA08000
*D2885000-298500,378000-394000,467000-537000,665000-897700     @ZA08000
*D377024,A024500,374152,C374228,374244                         @ZA24815
*
*STATUS CHANGE LEVEL - RELEASE VS2-2 LEVEL 0
*
***********************************************************************
         USING *,RAPDBASE
SIOEP    B     SIORTNE            START I/O APPENDAGE E.P.
         ORG   IGG019JA+8
FRBUFEP  B     FBUFRTNE           FREE DYNAMIC BUFFER SVC E.P.
*
*
***********************************************************************
*  THE FOLLOWING TWO ENTRY POINTS ARE USED FOR PROCESSING OF THE      *
*  FREEDBUF ESTAE ROUTINE, IGCT005G.  THE FIRST ENTRY POINT (+12) IS  *
*  USED WHEN, IN THE ESTAE CLEANUP ROUTINE, IT IS DETERMINED THAT THE *
*  AUDIT TRAIL BIT INDICATING THAT THE NEXT IOB HAD BEEN TAKEN FROM   *
*  THE IOB QUEUE BUT THE CHANNEL PGM HAD NOT BEEN INITIALIZED YET     *
*  (WKAIOBQ BIT IS ON). IN THIS CASE ENTRY IS MADE TO INITIALIZE      *
*  THE CHANNEL PROGRAM AND ISSUE THE EXCP FOR THIS REQUEST.           *
*         THE SECOND ENTRY POINT (+16) IS USED WHEN THE NEXT IOB HAS  *
*  BEEN REMOVED FROM THE QUEUE, ITS CHANNEL PGM INITIALIZED, BUT THE  *
*  ABEND OCCURRED BEFORE THE EXCP WAS ISSUED (WKABUFAS BIT ON).IN THIS*
*  CASE ENTRY IS MADE TO ISSUE THE EXCP FOR THIS REQUEST.             *
*          INPUT FOR BOTH ENTRIES IS THE SAME:                        *
*                   REGISTER 2 = NEXT IOB ADDRESS                     *
*                   REGISTER 3 = BEGINNING ADDRESS OF THIS MODULE     *
*                   REGISTER 4 = DCB ADDRESS                          *
*                   REGISTER 5 = SVRB ADDRESS                         *
*                   REGISTER 6 = BUFFER ADDRESS                       *
*                   REGISTER 8 = TCB ADDRESS                          *
*                   REGISTER 15= BEGINNING ADDRESS OF THIS MODULE     *
*                   WKAREG14 IN SVRB WORKAREA IN INITIALIZED TO       *
*                                RETURN ADDRESS IN ESTAE              *
*  A THIRD ENTRY INTO THIS MODULE IS TAKEN BY ESTAE, IGCT005G, IF NO  *
*  AUDIT TRAIL BITS ARE SET AT ALL.  IN THIS CASE ENTRY IS THE SAME   *
*  AS FOR FREEDBUF (+8).  INPUT IS LIKEWISE THE SAME.                 *
***********************************************************************
ESTENT1  B     ESTENTA                  INIT CH PGM, ISSUE EXCP  Y02072
*
ESTENT2  B     ESTENTB                  ISSUE EXCP               Y02072
***********************************************************************
*                                                                     *
***********************************************************************
*                  REGISTER EQUATES
***********************************************************************
R0       EQU   0        INPUT REGISTER 0    SVC
RWORK0   EQU   0        WORK REGISTER
R1       EQU   1        INPUT REGISTER 1
RWORK1   EQU   1        WORK REGISTER
RLINK    EQU   1        INTERNAL LINKAGE REGISTER                Y02072
RRQE     EQU   1        ADDR OF RQE PASSED BY IOS                Y02072
RIOB     EQU   2        ADDRESS OF IOB
RWORK2   EQU   2        WORK REGISTER                          @ZA08000
RBASE3   EQU   3        BASE REGISTER       SVC
RWORK3   EQU   3        WORK REG                               @ZA08000
RDCB     EQU   4        ADDRESS OF DCB
RWORK4   EQU   4        WORK REGISTER
RSVRB    EQU   5        ADDRESS OF SVRB ON ENTRY FROM FREEDBUF   Y02072
RBUFFR   EQU   6        BUFFER ADDRESS
RWORK6   EQU   6        WORK REGISTER
RSWA     EQU   6        PTR TO SEMENT WORK AREA (ASSGNBUF)     @ZA08000
RDECB    EQU   7        DECB ADDRESS
RWORK7   EQU   7        WORK REGISTER
RCCW     EQU   7        PTR TO CCW TO MODIFY (ASSGNBUF)        @ZA08000
RTCB     EQU   8        ADDRESS OF TCB IN FREE BUF RTN           Y02072
RNEWLST  EQU   8        ADDR OF NEW UNSCHEDULED LIST
RRQES    EQU   8        REGISTER TO SAVE RQE POINTER           @ZA24815
RWORK9   EQU   9        WORK REGISTER
RWORK10  EQU   10       WORK REGISTER
RWORK11  EQU   11       WORK REGISTER
RWORK12  EQU   12       WORK REGISTER
RSAVE    EQU   13       IOS REGISTER SAVEAREA ADDR               Y02072
RWORK13  EQU   13       WORK REGISTER (RECOUP RTN)               Y02072
RRETURN  EQU   14       RETURN ADDRESS
RRETCODE EQU   15       RETURN CODE REGISTER
RAPDBASE EQU   15       BASE REGISTER FOR APPENDAGE ROUTINES
RWORK15  EQU   15       WORK REGISTER
R15      EQU   15       SAVE/RESTORE REG                         Y02072
         SPACE 5
SETSECT  EQU   X'23'         CCW OP-CODE
KEYDATOP EQU   X'0E'         CCW OP-CODE  READ KEY & DATE
RDDATAOP EQU   X'06'         CCW OP-CODE  READ DATA
NOP      EQU   X'03'         CCW OP-CODE
SILI     EQU   BIT2          CCW FLAGS    SUPPRESS INCORRECT
*                                         LENGTH INDICATION
*
IC       EQU   B'0001'       MASK FOR ICM, INSERTS 1 BYTE INTO
*                            LOW ORDER BYTE OF REGISTER
ADDR     EQU   B'0111'       MASK FOR ICM/STCM, INSERTS OR
*                            STORES A 24-BIT ADDRESS TO OR FROM
*                            THE LOW-ORDER 3 BYTES OF A REGISTER.
         EJECT
SIORTNE  EQU   *
*                                                                     *
* FUNCTION:                                                           *
*    THE START-I/O APPENDAGE ATTEMPTS TO ASSIGN A BUFFER TO A         *
*    READ REQUEST IF THE REQUEST SPECIFIES DYNAMIC BUFFERING AND      *
*    NO BUFFER WAS ASSIGNED BEFORE EXCP.  IF A BUFFER IS              *
*    AVAILABLE FOR ASSIGNMENT, IT IS REMOVED FROM THE BUFFER          *
*    POOL AND THE BUFFER CHAIN IS UPDATED.  THE BUFFER ADDRESS        *
*    IS PLACED IN THE REQUEST'S DECB AND IN THE READ CCWS OF THE      *
*    REQUEST'S CHANNEL PROGRAM.  THE ROUTINE THEN RETURNS TO IOS      *
*    TO INITIATE THE I/O.                                             *
*    IF NO BUFFER IS AVAILABLE THE REQUEST IS PLACED ON A QUEUE       *
*    OF REQUESTS WAITING FOR BUFFERS.  THE ROUTINE TAKES THE IOS      *
*    RETURN WHICH INDICATES THAT THE I/O REQUEST SHOULD NOT BE        *
*    INITIATED.                                                       *
*    IF NO BUFFER IS AVAILABLE AND THE ADDRESS OF THE IOB FOR         *
*    THIS REQUEST CANNOT BE PLACED ON THE CURRENT UNSCHEDULED LIST,   *
*    THE EXTEND-LIST FUNCTION GETS STORAGE FOR AN UNSCHEDULED LIST
*    WHICH IS TWICE AS LARGE AS THE PREVIOUS LIST.  IT INITIALIZES    *
*    THE NEW LIST (AND MOVES ALL ENTRIES FROM THE OLD LIST TO         *
*    THE NEW LIST) AND PLACES ITS ADDRESS IN DCBDYNB.                 *
*                                                                     *
* ENTRY POINT:                                                        *
*         SIOEP -- ENTERED ASYNCHRONOUSLY FROM IOS AT START-I/O       *
*         TIME.  THE ADDRESS OF IGG019JA IS PLACED IN THE             *
*         APPENDAGE VECTOR TABLE (AVT) DURING OPEN PROCESSING.        *
*         CALLING SEQUENCE -- L     15,4(AVTPTR)                      *
*                             BALR  14,15                             *
*                                                                     *
* INPUT                                                               *
*    **** REGISTER CONTENTS ****                                      *
*    REGISTER  1 -- REQUEST QUEUE ELEMENT (RQE) ADDRESS               *
*    REGISTER  2 -- INPUT/OUTPUT BLOCK (IOB) ADDRESS                  *
*    REGISTER  3 -- DATA EXTENT BLOCK (DEB) ADDRESS                   *
*    REGISTER  4 -- DATA CONTROL BLOCK (DCB) ADDRESS                  *
*    REGISTER  7 -- UNIT CONTROL BLOCK (UCB) ADDRESS                  *
*    REGISTER 13 -- IOS SAVEAREA ADDRESS                        Y02072*
*    REGISTER 14 -- RETURN ADDRESS                                    *
*    REGISTER 15 -- ADDRESS OF IGG019JA                               *
*                                                                     *
* OUTPUT                                                              *
*    **** REGISTER CONTENTS ****                                      *
*    ALL REGISTER CONTENTS ARE RESTORED BEFORE RETURN TO IOS.         *
*                                                                     *
*    **** DATA AREAS SET BY THIS ROUTINE ****                         *
*    USLBFRQB           UPDATED IF REQUEST IS PLACED ON QUEUE         *
*                       TO WAIT FOR BUFFER                            *
*    USLBFRQT           UPDATED IF THIS REQUEST IS THE ONLY ONE ON    *
*                       THE QUEUE WAITING FOR A BUFFER                *
*    BCBBFAVL           UPDATED IF A BUFFER IS ASSIGNED               *
*    DECAREA            DATA ADDR IN THE ASSIGNED BUFFER              *
*    DECKYADR           KEY ADDR IN THE ASSIGNED BUFFER FOR A READ    *
*                       BY BLOCK ID, & KEY ADDR SPECIFIED 'S'.        *
*    CCW3 ADDR          KEY ADDR,FOR NON-RPS CHANNEL PROGRAMS WHEN    *
*                       KEY IS IN DYNAMIC BUFFER (SEE DECKYADR).      *
*    CCW4 ADDR          KEY ADDR FOR RPS CHANNEL PROGRAMS, AS ABOVE   *
*    NEXT-TO-LAST CCW ADDR -- DATA ADDR FOR TRACK-OVERFLOW PROGRAMS   *
*    LAST CCW ADDR      DATA ADDR FOR NON-TRACK-OVERFLOW PROGRAMS     *
*                                                                     *
* EXITS                                                               *
*         0(R14)        RETURN TO IOS & START I/O                     *
*         4(R14)        RETURN TO IOS & DISREGARD I/O REQUEST         *
*                                                                     *
* ATTRIBUTES -- REENTRANT,PRIVILEGED,KEY=0,ENABLED,WITH THE LOCAL     *
*    LOCK HELD. MODESET IS ISSUED TO DO ALL PROCESSING IN USER KEY.   *
*                                                                     *
         EJECT
**********************************************************************
*** DETERMINE IF A BRANCH ENTRY TO SMF IS REQUIRED BECAUSE EXCP HAS
*** BEEN ISSUED FROM THE ASI ROUTINE IN IGG019KA OR IGC0005C(RELEX)
*** OR THE ABNORMAL END APPENDAGE HAS RETURNED TO IOS TO RETRY
*** THE IO REQUEST
***   INPUT-  REGISTER ONE CONTAINS NUMBER OF EXCP COUNTS.
***   OUTPUT- SMF EXCP COUNT INCREMENTED BY VALUE IN REG ONE.
*** SMF BRANCH ENTRY INTERFACE
*** REGISTER  0 - TCB PTR
*** REGISTER  1 - SMF EXCP COUNT
*** REGISTER  3 - DEB PTR
*** REGISTER  7 - UCB PTR
*** REGISTER 10 - WORK REG
*** REGISTER 11 - WORK REG
*** REGISTER 12 - WORK REG
*** REGISTER 13 - WORK REG
*** REGISTER 14 - RETURN ADDR
*** REGISTER 15 - SMF BASE
**********************************************************************
         STM   R0,R15,0(RSAVE)          SV REGS IN IOS SV AREA @ZA08000
         LR    RWORK2,RSAVE             SAVE AREA PTR          @ZA08000
         USING PSA,0                    LOW CORE MAP           @ZA08000
         L     RWORK13,PSATOLD          PTR TO CURRENT TCB     @ZA08000
*
*** IF THE ABE APPENDAGE RETURNS TO IOS TO RESCHEDULE I/O
*** THERE WILL BE NO TCB POINTER. THE I/O SUPERVISOR USES THE
*** SRB TO DISPATCH THE I/O REQUEST.
*
         LTR   RWORK13,RWORK13          IS THERE A POINTER     @ZA08000
         BZ    SMFCALL                  SCHEDULED UNDER SRB    @ZA08000
         USING TCB,RWORK13              TCB ADDRESSABILITY     @ZA08000
         L     RWORK13,TCBRBP           PTR TO RB              @ZA08000
         DROP  RWORK13                                         @ZA08000
         USING RBBASIC,RWORK13          RB ADDRESSABILITY      @ZA08000
*
***IF EXCP IS ISSUED OUT OF RELEX THE RB WILL BE AN SVRB WITH
***THE PREVIOUS RB AN IRB.
*
         TM    RBSTAB1,RBFTSVRB         IS THIS AN IRB OR SVRB @ZA08000
         BZ    NOTIRB                   NO,BR AROUND SMF CALL  @ZA08000
         BNO   SMFCALL                  MAKE SMF CALL FOR IRB  @ZA08000
         L     RWORK13,RBLINK           PTR TO PREVIOUS RB     @ZA08000
         TM    RBSTAB1,RBFTIRB          IS PREVIOUS RB AN IRB  @ZA08000
         DROP  RWORK13                                         @ZA08000
         BZ    NOTIRB                   NO,DON'T CALL SMF      @ZA08000
SMFCALL  EQU   *                        CALL SMF               @ZA08000
         USING RQE,RRQE
         L     R0,RQETCB                PTR TO TCB             @ZA08000
         L     R1,MINUS1                NEGATIVE COUNT TO SMF  @ZA08000
         L     R15,CVTPTR               PTR TO CVT             @ZA08000
         L     R15,CVTSMFEX-CVTMAP(,R15)   PTR TO SMF RTN      @ZA08000
         BALR  RRETURN,R15              BR TO SMF              @ZA08000
         DROP  RRQE
         DROP  R0                                              @ZA08000
NOTIRB   EQU   *                        NOT AN IRB             @ZA08000
         LM    R0,R15,0(RWORK2)         RESTORE REGS           @ZA08000
         USING IOBSTDRD,RIOB
         USING IHADCB,RDCB
         TM    IOBDTYP2,IOBRQUST  IS THIS A READ REQUEST?
         BCR   8,RRETURN          IF NOT, RETURN TO IOS
         TM    IOBDTYPE,IOBDYNBF  DOES REQUEST SPECIFY DYNAMIC
*                                 BUFFERING?
         BCR   8,RRETURN          IF NO, RETURN TO IOS
         TM    IOBSTAT1,IOBBUFF   HAS A BUFFER BEEN ASSIGNED TO
*                                 THIS REQUEST?
         BCR   1,RRETURN          IF SO, RETURN TO IOS
*
*                       IF A BUFFER IS AVAILABLE, ASSIGN IT TO
*                       THIS REQUEST AND UPDATE THE BUFFER POOL.
*
         USING RQE,RRQE                 ESTABLISH RQE BASE       Y02072
*
         MODESET  KEYADDR=RQEPRT,WORKREG=10  CHANGE TO USER KEY  Y02072
*
         L     RWORK10,DCBBUFCB   GET BUFFER CONTROL BLOCK ADDR
         USING BCBDEFV,RWORK10          ESTABLISH BASE FOR BCB   Y02072
         SR    RWORK11,RWORK11
         ICM   RWORK11,IC,BCBBFAVL  GET BUFFER NUMBER FOR NEXT
*                                 AVAILABLE BUFFER
         BZ    PTONBUFQ           IF NONE AVAILABLE, BRANCH TO
*                                 PUT REQUEST ON QUEUE
         IC    RWORK9,BCBSUFFX-1(RWORK11)   GET NUMBER OF 2ND
*                                 AVAILABLE BUFFER.
         STC   RWORK9,BCBBFAVL    MAKE IT THE NEXT AVAILABLE
*
*                                 COMPUTE ADDR OF THE BUFFER TO
*                                 BE ASSIGNED.
*
         BCTR  RWORK11,0          BUFFER NUMBER - 1.
         L     RWORK7,BCBBUFL     LENGTH OF EACH BUFFER        @ZA08000
         MR    RWORK6,RWORK11     BUFFER #-1 * BUFFER LENGTH   @ZA08000
*                                 = DISPLACEMENT INTO BUFFER POOL
         LR    RWORK11,RWORK7                                  @ZA08000
         A     RWORK11,BCBBUF1    + ADDR OF BUFFER #1 = BUFFER
*                                 ADDR.
         DROP  RWORK10,RRQE                                      Y02072
         BAL   RLINK,ASSGNBUF     ASSIGN BUFFER TO REQUEST
*
SIORET   EQU   *                        RETURN TO IOS            Y02072
*
         MODESET  KEYADDR=IOSKEY,WORKREG=10  CHANGE TO IOS KEY   Y02072
*
         LM    R0,R15,0(RSAVE)          LOAD IOS REGISTERS       Y02072
         BR    RRETURN                  RETURN TO IOS TO INITIATE
*                                       I/O REQUEST
         SPACE 5
PTONBUFQ EQU   *
*
*                       NO BUFFER WAS AVAILABLE. PUT THIS IOB ON
*                       THE QUEUE WAITING FOR BUFFERS.
*
*
         L     RWORK11,DCBDYNB    ADDR OF CURRENT LIST
         USING USL,RWORK11
*
*                       PUT IOB ADDR ON THE UNSCHEDULED LIST
*
         L     RWORK10,USLBFRQB   ADDR OF LAST LIST SLOT USED
         LTR   RWORK10,RWORK10    ANY USED?
         BZ    EMPTYQ             BRANCH IF NONE
         USING USLSLOT,RWORK10
         TM    USLSLTFL,USLENDL   IS LAST ONE END OF LIST ?
         BZ    BUMP               BRANCH IF NOT
         LA    RWORK10,USLSLOT1-4 LOOP TO POINT TO 1ST SLOT
BUMP     LA    RWORK10,USLNXT     POINT TO NEXT SLOT
         TM    USLSLTFL,USLINUSE  IS THIS SLOT ALREADY IN USE?
         BO    EXTEND             BRANCH YES, LIST IS FULL
*
STIOBADR ST    RWORK10,USLBFRQB         THIS SLOT IS LAST USED
         STCM  RIOB,ADDR,USLIOBA+1      PLACE IOB ADDR IN SLOT
         OI    USLSLTFL,USLINUSE        MARK SLOT NOT AVAILABLE
         DROP  RWORK10                  DROP USL BASE            Y02072
*
         MODESET  KEYADDR=IOSKEY,WORKREG=10  CHANGE TO IOS KEY   Y02072
*
         LM    R0,R15,0(RSAVE)          LOAD IOS REGISTERS       Y02072
         B     4(RRETURN)               IOS RETURN - DON'T DO I/O
*
EMPTYQ   LA    RWORK10,USLSLOT1   USE FIRST SLOT ON LIST
*                                 TOP SLOT IS FIRST ON QUEUE
         STCM  RWORK10,ADDR,USLBFRQT+1
         B     STIOBADR
         DROP  RWORK11
*
         EJECT
EXTEND   EQU   *                                               @ZA08000
*                       THE IOB ADDRESS CANNOT BE PLACED ON THE
*                       CURRENT UNSCHEDULED LIST BECAUSE THE
*                       LIST IS FULL.
*                       GET STORAGE FOR AN UNSCHEDULED LIST TWICE AS
*                       LARGE AS THE CURRENT ONE.
*    DCBDYNB       FOR THE EXTEND FUNCTION, POINTS TO NEW LIST.       *
*              THE LIST IS INITIALIZED AS FOLLOWS:                    *
*    USLSIZE       LIST SIZE IN BYTES -- 2* OLD LIST SIZE             *
*    USLFLAGS      BIT USLCURNT SET IN NEW LIST, TURNED OFF IN        *
*                  OLD LIST.                                          *
*    USLBFRQT      THE IOB ADDRESSES ARE ARRANGED SUCH THAT THE       *
*                  ADDR OF THE 1ST IOB ON THE OLD LIST IS COPIED      *
*                  INTO THE TOP SLOT ON THE NEW LIST.  IF NO          *
*                  IOBS ARE ON THE LIST, SET TO ZERO.                 *
*    USLBFRQB      ADDR OF SLOT USED BY LAST IOB ON QUEUE (OR 0       *
*                  IF THERE ARE NONE.)                                *
*    USLCHAIN      ADDRESS OF PRIOR LIST COPY                         *
*
         L     RWORK10,DCBDYNB    GET ADDR OF CURRENT UNSCHED-   Y02072
         USING USL,RWORK10        ULED LIST.                     Y02072
         LH    RWORK11,USLSIZE    SIZE OF CURRENT LIST           Y02072
         SLL   RWORK11,1                *2= SIZE OF NEW LIST   @ZA08000
         LR    RRQES,RRQE         SAVE RQE POINTER             @ZA24815
*
         GETMAIN R,SP=250,LV=(RWORK11),BRANCH=YES   GET CORE   @ZA08000X
                                                    FOR NEW USL
         LR    RWORK2,RSAVE             SAVE AREA PTR          @ZA08000
         LM    RRETURN,R15,56(RSAVE)    RESTORE BASE REG       @ZA08000
         USING RQE,RRQES                                       @ZA24815
         MODESET KEYADDR=RQEPRT,WORKREG=9      USER KEY        @ZA08000
         DROP  RRQES                                           @ZA24815
         LR    RNEWLST,R1               GET ADDR OF NEW LIST     Y02072
*
         LA    RWORK1,0(RNEWLST,RWORK11)                         Y02072
*
*                  INITIALIZE NEW LIST
*
         XC    0(USLSLOT1-USL,RNEWLST),0(RNEWLST)     CLEAR TO 0
         STH   RWORK11,USLSIZE-USL(RNEWLST)  SIZE OF NEW LIST    Y02072
         LR    RWORK9,RWORK10           GET ADDRESS OF OLD USL   Y02072
         AH    RWORK9,USLSIZE           ENDING ADDR OF OLD USL   Y02072
         LA    RWORK6,USLSLOT1-USL(RNEWLST)
*                                 LESS FIRST SLOT ADDR, NEW LIST
         SR    RWORK1,RWORK6      = LENGTH OF ENTRIES, NEW LIST
*
*
*                  IF THE LIST HAS ENTRIES IN 2 NONCONTIGUOUS
*                  SEGMENTS, FIRST MOVE THE SEGMENT CORRESPONDING
*                  TO THE TOP OF THE QUEUE. THE SEGMENTS WILL BE
*                  MOVED WITH MVCL WHICH DEPENDS ON TWO REGISTER
*                  PAIRS:  R12-R13  AND  R6-R7
*
         ICM   RWORK12,ADDR,USLBFRQT+1                           Y02072
*                                 ADDR OF TOP QUEUE ENTRY
         BZ    CLRLST
         LR    RWORK13,RWORK9           SAVE FOR LEN CALCULATION Y02072
*                                       OLD USL ADDR ENDING      Y02072
         SH    RWORK9,H4                POINT TO LAST ENTRY, OLD LIST
         USING USLSLOT,RWORK9
         NI    USLSLTFL,X'FF'-USLENDL  TURN OFF END OF LIST FLAG
*                                      BEFORE MOVE
         ST    RWORK6,USLBFRQT-USL(RNEWLST)
*                                 TOP OF QUEUE FOR NEW LIST IS
*                                 FIRST SLOT.
         LA    RWORK9,USLSLOT1    FIRST SLOT, OLD LIST.
         TM    USLSLTFL,USLINUSE  IS THIS SLOT BEING USED?
         BZ    SECSEG             BRANCH NO, 1 MOVE WILL SUFFICE
         DROP  RWORK9
         CR    RWORK12,RWORK9     IS TOP QUEUE ENTRY IN 1ST SLOT Y02072
         BE    SECSEG             BRANCH YES, AGAIN 1 MOVE OK
*
         SR    RWORK13,RWORK12    LENGTH OF 1ST SEGMENT          Y02072
         LR    RWORK7,RWORK13     RECEIVING FIELD IS SAME LENGTH Y02072
         SR    RWORK1,RWORK7      REDUCE LENGTH OF UNUSED SLOTS
         MVCL  RWORK6,RWORK12     MOVE 1ST SEGMENT TO NEW LIST   Y02072
         LA    RWORK12,USLSLOT1   2ND SEGMENT STARTS AT 1ST SLOT Y02072
*                                 OF OLD LIST.
*
*                  MOVE SECOND OR ONLY LIST SEGMENT.
*
SECSEG   L     RWORK13,USLBFRQB   LAST SLOT OF SEGMENT TO MOVE   Y02072
         USING USLSLOT,RWORK13    ESTABLISH BASE FOR UNSCHED LST Y02072
         LA    RWORK13,USLNXT     POINT AT END ADDR + 1          Y02072
         DROP  RWORK13                                           Y02072
         SR    RWORK13,RWORK12    LENGTH OF SECOND SEGMENT       Y02072
         LR    RWORK7,RWORK13     RECEIVING FIELD IS SAME LENGTH Y02072
         SR    RWORK1,RWORK7      REDUCE AMOUNT OF UNUSED SLOTS
         MVCL  RWORK6,RWORK12     MOVE 2ND SEGMENT TO NEW LIST   Y02072
         LR    RWORK9,RWORK6      END OF LAST USED SLOT
         SH    RWORK9,H4          ADDR OF BOTTOM SLOT IN QUEUE
         ST    RWORK9,USLBFRQB-USL(RNEWLST)  INITIALIZE PTR TO
*                                 LAST SLOT OF QUEUE.
*
*                  CLEAR THE UNUSED SLOTS ON THE NEW LIST
*
CLRLST   LR    RWORK7,RWORK1      LENGTH REMAINING (TO FIELD)
         SR    RWORK13,RWORK13    SEND NO CHARACTERS, PAD X'00'  Y02072
         MVCL  RWORK6,RWORK12     CLEAR REST OF LIST             Y02072
*
         SH    RWORK6,H4          ADDR LAST SLOT
         USING USLSLOT,RWORK6
         OI    USLSLTFL,USLENDL   TURN ON END-OF-LIST FLAG
         DROP  RWORK6
*
         NI    USLFLAGS,X'FF'-USLCURNT  TURN OFF 'CURRENT' FLAG
*                                       IN OLD LIST
         OI    USLFLAGS-USL(RNEWLST),USLCURNT
*                                 TURN ON 'CURRENT' FLAG IN NEW
*                                 SET POINTER TO OLD LIST IN NEW
         ST    RWORK10,USLCHAIN-USL(RNEWLST)                     Y02072
         ST    RNEWLST,DCBDYNB    SET POINTER TO NEW LIST IN DCB
         LR    RSAVE,RWORK2             RESTORE SAVE REG       @ZA08000
         B     PTONBUFQ                 PUT IOB ON USL IST     @ZA08000
*
*
         EJECT
*
*                  THIS SUBROUTINE IS USED BY THE START-I/O
*                  APPENDAGE AND THE FREE DYNAMIC BUFFER SVC
*                  ROUTINE. IT IS ENTERED IN USER KEY.
*                  IT ASSIGNS A BUFFER TO AN I/O REQUEST BY
*                  PLACING THE BUFFER ADDRESS INTO THE DECB
*                  AND THE CHANNEL PROGRAM.
*
*              REGISTER INPUT:  RIOB    - ADDR OF IOB TO WHICH
*                                         BUFFER WILL BE ASSIGNED
*                               RDCB    - DCB ADDRESS
*                               RWORK11 - BUFFER ADDRESS
*                               RLINK   - RETURN ADDRESS
*              REGISTER OUTPUT: RWORK9  - WORK REGISTER
*                               RWORK10 - WORK REGISTER
*                               RWORK11 - WORK REGISTER
*                               RCCW    - WORK REGISTER
*                               RSWA    - WORK REGISTER
         USING IHADCB,RDCB
         USING IOBSTDRD,RIOB
ASSGNBUF L     RWORK9,IOBECBPT    GET DECB ADDRESS
         USING DECB,RWORK9
         USING SWA,RWORK11        ESTABLISH BASE FOR SEG WRKAREA Y02072
         TM    DCBRECFM,DCBRECV+DCBRECSB IS THIS VS FORMAT     @ZA08000
         BNO   NORECVS1           NO,BRANCH AROUND VS CODE     @ZA08000
*                                 PLACE SWA ADDR IN IOB
         LR    RWORK10,RIOB       PLACE IOB ADDRESS IN WORK REG
         LA    RSWA,IOBSTDRD-IOBSWAP   DISP TO IOBSWAP FIELD
         SR    RWORK10,RSWA       POINT TO IOB PREFIX
         USING IOBSWAP,RWORK10
         ST    RWORK11,IOBSWAP    PLACE SWA ADDR IN IOB
*                                 DATA & KEY (IF REQUESTED) WILL
*                                 BE READ INTO THE SEGMENT AREA
*                                 OF THE DYNAMIC BUFFER.  THE
*                                 USER WILL BE PASSED THE ADDRESS
*                                 OF LOCATIONS IN THE RECORD
*                                 AREA.
*
         LA    RSWA,SWASEGMT      GET ADDRESS OF SEGMENT AREA    Y02072
*
         L     RWORK10,DCBBUFCB   ADDRESS BUFFER CONTROL BLOCK
         USING BCBDEFV,RWORK10    ESTABLISH BASE FOR BCB         Y02072
         L     RWORK10,BCBRAOFS-1 GET DISPLACEMENT OF RECORD
         DROP  RWORK10            AREA FROM START OF BUFFER.
         LA    RWORK11,0(RWORK10,RWORK11)        ADDR OF RECORD AREA
*
         L     RCCW,IOBDCPND      POINT BEYOND LAST CCW
         SH    RCCW,H16           POINT TO NEXT-TO-LAST CCW
*                                 FOR A READ BY BLOCK ID, KEY
*                                 CODED 'S', THE KEY IS READ
*                                 INTO THE DYNAMIC BUFFER.
         TM    IOBDTYP2,IOBTYPE   IS THIS READ BY BLOCK ID?
         BO    FILLCCWV           BRANCH IF NO
         TM    IOBDTYP2,IOBSKEY   WAS KEY ADDRESS CODED 'S'?
         BZ    FILLCCWV           BRANCH IF NO
         ST    RWORK11,DECKYADR   PLACE KEY ADDRESS IN DECB
         CLI   DCBKEYLE,0         IS KEY LENGTH ZERO             XM1559
         BE    FILLCCWV           BR IF YES                      XM1559
         ST    RWORK11,0(RCCW)    PLACE ADDR OF KEY IN RECORD   XA00093
*                                 AREA INTO NEXT-TO-LAST CCW.
         MVI   0(RCCW),KEYDATOP   RESTORE OP-CODE
*                                 INCREMENT RECORD AREA & SEGMENT
*                                 AREA POINTERS BEYOND KEY.
         SR    RWORK10,RWORK10
         IC    RWORK10,DCBKEYLE   GET LENGTH OF KEY
         AR    RWORK11,RWORK10    BUMP RECORD AREA POINTER
*
FILLCCWV ST    RWORK11,DECAREA    PLACE DATA ADDRESS IN DECB
         ST    RSWA,8(RCCW)       PLACE DATA ADDRESS IN LAST CCW
         MVI   8(RCCW),RDDATAOP   RESTORE OP-CODE.
         OI    IOBDSTAT,IOBBUFF   SET BUFFER-ASSIGNED SWITCH
         BR    RLINK              RETURN TO CALLER
         DROP  RWORK11
         EJECT
NORECVS1 EQU   *                  NOT VS FORMAT                @ZA08000
*                                 FOR A READ BY BLOCK ID, KEY
*                                 CODED 'S', THE KEY IS READ
*                                 INTO THE DYNAMIC BUFFER.
         TM    IOBDTYP2,IOBTYPE   IS THIS READ BY BLOCK ID?
         BO    FILLSCCW           BRANCH IF NO
         TM    IOBDTYP2,IOBSKEY   WAS KEY ADDRESS CODED 'S'?
         BZ    FILLSCCW           BRANCH IF NO
*                                 IN AN RPS PROGRAM CCW 3 READS
*                                 THE KEY; IN A NON-RPS PROGRAM,
*                                 CCW 4.
         LA    RWORK10,IOBCHNPR+16     ADDR OF CCW 3
         CLI   IOBCHNPR,SETSECT   TEST FOR RPS PROGRAM
         BNE   NORPS              BRANCH IF NOT
         LA    RWORK10,8(RWORK10) FOR RPS -- CCW 4
*                                 PUT BUFFER ADDR OF KEY IN
*                                 CORRECT CCW & IN DECB
NORPS    ST    RWORK11,0(RWORK10) PLACE ADDRESS IN READ KEY CCW
         MVI   0(RWORK10),KEYDATOP   RESTORE OP-CODE
         ST    RWORK11,DECKYADR   PLACE KEY ADDRESS IN DECB
*                                 INCREMENT BUFFER POINTER
*                                 BEYOND KEY
         SR    RWORK10,RWORK10
         IC    RWORK10,DCBKEYLE   GET KEY LENGTH
         AR    RWORK11,RWORK10    BUMP BUFFER PTR BEYOND KEY
*                                 IN A NON-TRACK-OVERFLOW PGM
*                                 THE LAST CCW READS DATA; FOR
*                                 TRACK OVERFLOW, THE NEXT-TO-
*                                 LAST CCW
FILLSCCW L     RWORK10,IOBDCPND   POINTS BEYOND LAST CCW
         SH    RWORK10,H8         ADDR OF LAST CCW
         TM    DCBOPTCD,DCBOPTTO  TEST FOR TRACK OVERFLOW
         BZ    STADDR             BRANCH IF NO
         SH    RWORK10,H8         ADDR OF NEXT-TO-LAST CCW
*
STADDR   ST    RWORK11,0(RWORK10) PUT DATA ADDR IN CCW
         MVI   0(RWORK10),RDDATAOP     RESTORE READ DATA OP-CODE
         ST    RWORK11,DECAREA    PLACE DATA ADDRESS IN DECB
         OI    IOBDSTAT,IOBBUFF   SET BUFFER-ASSIGNED SWITCH
         BR    RLINK              RETURN TO CALLER
         DROP  RWORK9
         DROP  RIOB
         DROP  RDCB
         EJECT
FBUFRTNE EQU   *
*                                                                     *
* FUNCTION:                                                           *
*    THE FREE DYNAMIC BUFFER ROUTINE RELEASES A DYNAMIC BUFFER.       *
*    IF ANY IOBS ARE ON THE UNSCHEDULED QUEUE (WAITING FOR A          *
*    BUFFER) THE ROUTINE ASSIGNS THE BUFFER TO THE FIRST IOB ON       *
*    THE QUEUE, AND ISSUES AN EXCP FOR THAT IOB.  IF NO IOBS ARE      *
*    ON THE UNSCHEDULED QUEUE THE ROUTINE PLACES THE BUFFER ON        *
*    THE CHAIN OF AVAILABLE BUFFERS.                                  *
*                                                                     *
* ENTRY POINT:                                                        *
*         FRBUFEP -- ENTERED FROM MODULE IGC0005G WHEN SVC 57 IS      *
*         ISSUED FOR A DCB WHICH SPECIFIED DIRECT ORGANIZATION.       *
*         CALLING SEQUENCE -- L    15,DCBDEBAD                        *
*                             L    15,DEBAPPAD                        *
*                             L    15,4(15)                           *
*                             BAL  14,8(15)                           *
*                                                                     *
* INPUT                                                               *
*    **** REGISTER CONTENTS ****                                      *
*    REGISTER  0 -- DECB ADDRESS                                      *
*    REGISTER  1 -- DCB ADDRESS                                       *
*    REGISTER  5 -- SVRB ADDRESS                                      *
*    REGISTER  8 -- TCB ADDRESS PASSED BY FREEDBUF                    *
*    REGISTER 14 -- RETURN ADDRESS                                    *
*    REGISTER 15 -- ADDRESS OF IGG019JA                               *
*                                                                     *
* OUTPUT                                                              *
*    **** REGISTER CONTENTS ****                                      *
*    ALL REGISTERS EXCEPT REGISTER 14 CAN BE USED WITHOUT SAVING      *
*    OR RESTORING CONTENTS.                                           *
*    REGISTER 15 CONTAINS RETURN CODE.                                *
*                                                                     *
*    **** DATA FIELDS SET BY THIS ROUTINE ****                        *
*    USLBFRQT      IF AN IOB IS WAITING FOR A BUFFER, PTR TO 1ST      *
*                  IOB ON QUEUE IS UPDATED.                           *
*    USLBFRQB      IF, AFTER 1 IOB IS DEQUEUED, THE LIST IS EMPTY,    *
*                  USLBFRQB IS SET TO ZERO.                           *
*    THE BUFFER ADDRESS IS PLACED IN THE CHANNEL PROGRAM AND DECB     *
*    FIELDS (SEE SIORTNE DESCRIPTION FOR DETAILS).                    *
*    BCBBFAVL      IF THE BUFFER IS NOT ASSIGNED TO A REQUEST,        *
*                  ITS NUMBER IS PLACED IN BCBBFAVL.  THE             *
*                  CORRESPONDING BYTE OF THE BUFFER POOL SUFFIX       *
*                  WILL POINT TO THE SECOND AVAILABLE BUFFER.         *
*    SVRB          SEE BELOW
*                                                                     *
* EXTERNAL REFERENCES                                                 *
*        EXCP CALL TO IOS                                             *
*        MODESET   TO CHANGE BETWEEN SUPERVISOR AND USER KEYS         *
*        SETLOCK   TO RELEASE AND OBTAIN THE LOCAL LOCK
*                                                                     *
* EXITS, NORMAL                                                       *
*    BRANCH RETURN TO IGC0005G ON REGISTER 14.  RETURN CODE (R15)     *
*    = 0.                                                             *
*                                                                     *
*                                                                     *
* TABLES / WORK AREAS                                                 *
*        IOB, DCB, DECB, BUFFER CONTROL BLOCK,                        *
*         & SVRB EXTENDED SAVEAREA                                    *
*                                                                     *
* ATTRIBUTES -- REENTRANT, READONLY, PRIVILEGED. ENTRY IS IN SUPER-   *
*        VISOR KEY WITHOUT THE LOCAL LOCK HELD. RETURN TO IGC0005G IS *
*        IN SUPERVISOR KEY. MOST PROCESSING IS IN USER KEY.           *
*                                                                     *
* NOTES -- THE ROUTINE MUST HAVE THE LOCAL LOCK TO UPDATE THE SERIALLY*
*        REUSABLE IOB AND BUFFER QUEUES. SETLOCK WILL BE ISSUED THEN. *
*                                                                     *
*****                                                             *****
         EJECT
         LR    RBASE3,RAPDBASE    ESTABLISH BASE REGISTER
         USING IGG019JA,RBASE3
         DROP  RAPDBASE
         LR    RDCB,R1            TRANSFER DCB ADDRESS
         USING IHADCB,RDCB
         USING RBSECT,RSVRB       ESTABLISH BASE FOR SVRB        Y02072
         ST    RRETURN,WKAREG14   SAVE RETURN REGISTER
         USING TCB,RTCB           ESTABLISH BASE FOR TCB         Y02072
*                                 PASSED BY FREEDBUF IN R8       Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=6  CHANGE TO USER KEY Y02072
*
         USING DECB,RDECB
*
*                       LOCATE THE BEGINNING ADDRESS OF THE
*                       BUFFER BEING FREED.
*
         L     RBUFFR,DECAREA     ASSUME BUFFER ADDR = DATA ADDR
         TM    DECTYPE2,DECKEYS   WAS KEY IN BUFFER (CODED 'S')?
         BZ    FBU0500            BRANCH NO
         L     RBUFFR,DECKYADR    BUFFER ADDR = KEY ADDR
FBU0500  EQU   *
         TM    DCBRECFM,DCBRECV+DCBRECSB IS THIS VS FORMAT     @ZA08000
         BNO   NORECVS2                 NO,BR AROUND VS CODE   @ZA08000
         LA    RWORK12,BUFRECAR-BUFBFPTR
         SR    RBUFFR,RWORK12     POINT TO ADDR OF BEGINNING OF
*                                 BUFFER
         L     RBUFFR,0(RBUFFR)         GET BUFFER ADDRESS
         USING SWA,RBUFFR               ESTABLISH BASE FOR SWA   Y02072
         XC    SWABFINC,SWABFINC        RECORD AREA OFFSET PTR   Y02072
NORECVS2 EQU   *                        NOT VS RECORD FORMAT   @ZA08000
         L     RWORK10,DCBDYNB    ADDR OF UNSCHEDULED LIST       Y02072
         USING USL,RWORK10              USL ADDRESSABILITY       Y02072
         L     RWORK12,DCBBUFCB         GET BCB ADDRESS          Y02072
         USING  BCBDEFV,RWORK12         BCB ADDRESSABILITY       Y02072
*
*   PREPARE FOR QUEUE UPDATES. THIS REQUIRES THAT THE LOCAL LOCK BE
*   OBTAINED WHILE MANIPULATING THE QUEUE. IT IS RELEASED WHEN THE
*   QUEUE HAS BEEN UPDATED AND THE NEXT WAITING IOB HAS BEEN REMOVED,
*   OR THE BUFFER HAS BEEN PUT BACK ON THE AVAILABLE BUFFER QUEUE.
*   MODESET IS ISSUED BECAUSE SETLOCK REQUIRES SUPERVISOR KEY.
*   CERTAIN FIELDS WILL BE SAVED AT THIS POINT, SHOULD THE ESTAE
*   NEED THEM. SETLOCK USES REGISTERS 11-14 WITHOUT RESTORING THEM.
*
         IC    RWORK9,BCBBFAVL          GET NEXT AVAIL BUF NO    Y02072
*                                       FOR ESTAE- 1 BYTE        Y02072
         DROP  RWORK12                  DROP BCB BASE            Y02072
         L     RWORK0,USLBFRQT          GET USL CONTENTS FOR     Y02072
*                                       ESTAE - IN USER KEY      Y02072
*
         MODESET  EXTKEY=ZERO           CHANGE TO SUPER KEY      Y02072
*                                       TO GET THE LOCAL LOCK    Y02072
*
GETLOCK  SETLOCK  OBTAIN,TYPE=LOCAL,RELATED=('BUFFERQ,IGG019JA(FREELOCKX
               ,FREELCK1)'),MODE=UNCOND  GET THE LOCAL LOCK      Y02072
*
         ST    RBUFFR,WKABUFRG          SAVE BUF PTR FOR ESTAE   Y02072
         ST    RWORK0,WKASAVE           SAVE USL CONTENT IN SVRB Y02072
         STC   RWORK9,WKASAVE2          SAVE NEXT AVAIL BUF NO.  Y02072
*                                       FOR ESTAE IN CASE PATH   Y02072
*                                       TAKEN CHANGES THIS       Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=11 RET TO USER KEY    Y02072
*
         ICM   RWORK9,ADDR,USLBFRQT+1   PTR TO 1ST IOB ON QUEUE
         BZ    FBUNOREQ           BRANCH IF NO IOBS TO MAKE
*                                 BUFFER AVAILABLE
         USING USLSLOT,RWORK9
         L     RIOB,USLSLOT       GET IOB ADDRESS
         USING IOBSTDRD,RIOB
*
         MODESET  EXTKEY=ZERO           CHANGE TO SUPER KEY      Y02072
*                                       TO SAVE IOB ADDRESS      Y02072
         ST    RIOB,WKAIOBRG            SAVE IOB PTR FOR ESTAE   Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=11  RET TO USER KEY   Y02072
*
         NI    USLSLTFL,X'FF'-USLINUSE  MAKE SLOT AVAILABLE
         TM    USLSLTFL,USLENDL   IS THIS LAST SLOT IN LIST?
         BZ    NXTSLT             BRANCH IF NO
         LA    RWORK9,USLSLOT1-4 GET BACK TO TOP OF LIST
NXTSLT   LA    RWORK9,USLNXT      BUMP SLOT POINTER 1 ENTRY
         TM    USLSLTFL,USLINUSE  IS THERE ANOTHER IOB WAITING?
         BO    STOREPTR                 BRANCH IF YES
         SR    RWORK9,RWORK9
         DROP  RWORK9
         ST    RWORK9,USLBFRQB          MARK QUEUE EMPTY BY SETTING
*                                       TOP & BOTTOM PTRS TO ZERO.
STOREPTR STCM  RWORK9,ADDR,USLBFRQT+1   SLOT OF FIRST IOB (OR 0)
         DROP  RWORK10                                           Y02072
*
         MODESET  EXTKEY=ZERO           CHANGE TO ZERO KEY       Y02072X
                                        TO SET BIT IN SVRB       Y02072X
                                        AND RELEASE LOCAL LOCK   Y02072
         MVI   WKATRAIL,WKAIOBQ         SET BIT IN SVRB EXT SAVE Y02072
*                                       INDICATING IOB DEQUEUED  Y02072
*
FREELOCK SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('BUFFERQ,IGG019JA(GETLOCKX
               )')                      FREE THE LOCAL LOCK      Y02072
*
ESTENTA  EQU   *                        ESTAE ENTRY IF WKAIOBQ=1 Y02072
*
         MODESET  KEYADDR=WKASVKEY,WORKREG=11  RET TO USER KEY   Y02072
*
         LR    RAPDBASE,RBASE3    LOAD BASE FOR COMMON SUBRTNE
         LR    RWORK11,RBUFFR     PUT BUFFER ADDR IN R11
         BAL   RLINK,ASSGNBUF     ASSIGN THE BUFFER TO THE
*                                 DEQUEUED IOB.
*
         MODESET  EXTKEY=ZERO           CHANGE TO SUPER KEY      Y02072X
                                        TO SET BIT IN SVRB       Y02072
         MVI   WKATRAIL,WKABUFAS        SET BIT IN SVRB EXTENDED Y02072
*                                       SAVEAREA INDICATING BUF  Y02072
*                                       ASSIGNED TO NEXT IOB     Y02072
ESTENTB  EQU   *                        ESTAE ENTRY IF WKABUFAS  Y02072
*                                       BIT IS ON                Y02072
         MODESET  KEYADDR=WKASVKEY,WORKREG=11  RET TO USER KEY   Y02072
*
         L     RWORK11,IOBECBPT         LOAD ADDR TO USER'S DECB Y02072
         ST    RWORK11,IOBDQPTR         SAVE DECB ADDR IN IOB    Y02072
         LA    RWORK11,IOBCSW+3         SET UP CSW ADDRESS TO    Y02072
         ST    RWORK11,IOBECBPT         USE AS DUMMY ECB FOR IOS Y02072
*                                       CEA OR EOE WILL RESTORE  Y02072
*                                       USER'S DECB ADDR IN IOB  Y02072
*
         EXCP  (RIOB)                   SCHEDULE I/O FOR NEXT IOB ON Q
*
         MODESET  EXTKEY=ZERO           RETURN TO ZERO KEY       Y02072
*
         MVI   WKATRAIL,WKAEXCP         SET BIT INDICATING EXCP  Y02072
*
         B     NORMEXIT                 NORMAL RET TO IGC0005G   Y02072
         SPACE 5
*
*   NO IOBS ARE WAITING FOR BUFFERS.  RETURN BUFFER TO THE AVAILABLE
*   QUEUE.THIS ROUTINE IS ENTERED IN USER KEY WITH THE LOCAL LOCK HELD.
*   RETURN FROM THIS ROUTINE TO FREEDBUF IS IN SUPERVISOR KEY.
*
FBUNOREQ L     RWORK12,DCBBUFCB   ADDR OF BUFFER CONTROL BLOCK   Y02072
         USING BCBDEFV,RWORK12          ESTABLISH BCB BASE       Y02072
*
*                      COMPUTE BUFFER NUMBER FROM BUFFER ADDRESS
*
         LR    RWORK1,RBUFFR      BUFFER ADDRESS
         S     RWORK1,BCBBUF1     MINUS ADDR OF 1ST BUFFER
*                                  = DISP INTO BUFFER POOL
         SR    RWORK0,RWORK0
         D     RWORK0,BCBBUFL     DIVIDED BY BUFFER LENGTH
*                                  = BUFFER NUMBER -1.
         LA    RWORK1,1(RWORK1)   PLUS 1 = BUFFER NUMBER
*
*                      PLACE BUFFER # ON AVAILABLE CHAIN
*
         IC    RWORK9,BCBBFAVL    NEXT AVAIL BUFFER #
         STC   RWORK9,BCBSUFFX-1(RWORK1)    POINT CHAIN ENTRY
*                                 FOR THIS BUFFER TO IT
         STC   RWORK1,BCBBFAVL    MAKE THIS BUFFER NEXT AVAIL
*
*            RELEASE LOCAL LOCK AND SET AUDIT TRAIL BIT
*
*
         MODESET  EXTKEY=ZERO           CHANGE TO SUPER KEY      Y02072X
                                        TO SET BIT IN SVRB       Y02072X
                                        AND RELEASE LOCK         Y02072
         MVI   WKATRAIL,WKABUFQ         SET BIT INDICATING BUF   Y02072
*                                       FREED AND PUT ON QUEUE   Y02072
*
FREELCK1 SETLOCK  RELEASE,TYPE=LOCAL,RELATED=('BUFFERQ,IGG019JA(GETLOCKX
               )')                      FREE THE LOCAL LOCK      Y02072
*
*
         EJECT
*
*
*                       NORMAL EXIT
*
NORMEXIT L     RRETURN,WKAREG14   RESTORE RETURN REGISTER
         SR    RRETCODE,RRETCODE  RETURN CODE = 0.
         BR    RRETURN            RETURN TO IGC0005G
*
         SPACE 2
***********************************************************************
*                           CONSTANTS                                 *
***********************************************************************
MINUS1   DC    F'-1'                    NEGATIVE COUNT FOR SMF @ZA08000
H8       DC    H'8'
H16      DC    H'16'                                           @ZA08000
H4       DC    H'4'
IOSKEY   DC    X'00'                    KEY OF IOS               Y02072
ZERO     DC    X'00'                    SVRB KEY                 Y02072
NAME     DC    CL8'IGG019JA'            MODULE NAME            @ZA08000
FIX      DC    C'OZ24815 '              LATEST APAR            @ZA24815
DATE     DC    CL8'&SYSDATE'            LAST FIX DATE          @ZA08000
PATCH    DC    XL50'0'                  PATCH AREA               Y02072
         EJECT
***********************************************************************
*                         DSECTS                                      *
***********************************************************************
         IHAPSA                                                  Y02072
         EJECT
         IECDRQE                                                 Y02072
         EJECT
         IKJTCB
         EJECT
         IEZIOB
         ORG   IOBDQPTR
IOBDQSW  DS    B        FLAGS
IOBDQCP  EQU   BIT0          CHANNEL PROGRAM MODIFIED
*
         IHADCB DSORG=DA
*
         IHADECB
         SPACE
         IHAECB
*
         EJECT
         CVT   DSECT=YES                                       @ZA08000
         EJECT
         IGGSWA                                                @ZA08000
BUFFERB  DSECT          FORMAT OF BUFFER BEYOND SEGMENT AREA
BUFBFPTR DS    A        ADDRESS OF BEGINNING OF BUFFER
BUFRECAR EQU   *        RECORD AREA; BUFBFPTR IS ALIGNED SO THAT
*                       BUFRECAR FALLS AS SPECIFIED BY DCBBFALN.
         EJECT
         IGGBCB  TYPE=DAM                                        Y02072
         EJECT
         IKJRB                                                   Y02072
         IGGFRWKA                                                Y02072
         EJECT
         IGGUSL                                                  Y02072
         END
