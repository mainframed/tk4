 TITLE 'IGG0CLCB - SECOND CSECT OF INTERFACE MAPPER'
IGG0CLCB CSECT
*A193924-193944,297710,C297800,D193960                         @YM04820
*A029996,306380,C192181                                        @YM07060
*A029434,C194113                                               @YM05170
********THIS ENTIRE PROGRAM WRITTEN BY                         @YL026ZB
***********************************************************************
* STATUS -- CHANGE LEVEL                                              *
*    THIS MODULE IS A MODIFIED VERSION OF OS VS2-1 MODULE IKJEHCT1    *
*    WHICH WAS USED FOR TSO LISTCAT COMMAND.                          *
*                                                                     *
* FUNCTION --                                                         *
*    THIS IS THE MAIN PROCESSING MODULE FOR GENERIC LOCATE.           *
*    IT GETS CONTROL FROM IGG0CLCA VIA BALR 14,15                     *
*    AND WILL SEARCH THE SYSCTLG DATA SET USING THE CATALOG           *
*    MANAGEMENT ROUTINE LOCATE AND RETURN THE NAMES OF ALL DATA       *
*    SETS SETS THAT ARE FOUND TO HAVE THE REQUESTED HIGH LEVEL        *
*    QUALIFIERS AS THE FIRST PART OF THE DATASET NAME.                *
*    THE CIR SUBROUTINE IS USED TO DO THE ACTUAL LOCATES AND BUILD    *
*    LISTS OF QUALIFIERS TO BE PROCESSED.                             *
*                                                                     *
*                                                                     *
* ENTRY POINTS --                                                     *
*         IGG0CLCB                                                    *
*                                                                     *
* INPUT --                                                            *
*    INPUT CONSISTS OF FOUR REGISTERS CONTAINING THE FOLL0WING;       *
*                                                                     *
*          REG 0  - ADDRESS OF THE HIGH LEVEL QUALIFIERS OF THE       *
*                   DATASET NAMES TO BE LOCATED.                      *
*          REG 1  - ADDRESS OF THE USER'S WORK AREA WHERE THE LOCATED *
*                   DATASET NAMES ARE TO BE RETURNED.                 *
*          REG 2  - TCB ADDRESS.                                      *
*          REG 12 - ADDRESS OF SVC 26(CONTROLLER III) WORK AREA       *
*                                                                     *
* OUTPUT --                                                           *
*    A LIST OF DSNAMES FOUND CATALOGED UNDER THE REQUESTED HIGH       *
*    QUALIFIERS.                                                      *
*                                                                     *
* EXTERNAL REFERENCES --                                              *
*        IGG0CLCC - OS CATALOG MANAGEMENT                             *
*                                                                     *
* EXITS, NORMAL -- RETURN TO IGG0CLCA VIA BR 14 WITH RETURN CODE IN   *
*                  REGISTER 15 OF ZERO.                               *
*                                                                     *
* EXITS, ERROR -- RETURN TO IGG0CLCA VIA BR 14 WITH ONE OF THE        *
*                 FOLLOWING RETURN CODES IN REGISTER 15;              *
*                 4 - DATASET(S) NOT FOUND                            *
*                 8 - OUT OF CORE OR ESTAE MACRO FAILURE              *
*                12 - USER'S WORK AREA TOO SMALL                      *
*                                                                     *
* TABLES/WORK AREAS --                                                *
*    WORKCORE- MAIN WORK AREA CONTAINING SWITCHS, MACRO LIST FORMS,   *
*    POINTERS AND BLOCKS OF CORE USED IN NORMAL PROCESSING.           *
*                                                                     *
* ATTRIBUTES -- REENTRANT, READ-ONLY, REFRESHABLE                     *
*                                                                     *
* CHARACTER CODE DEPENDENCY -- CHARACTER CODE INDEPENDENT             *
*                                                                     *
* NOTES --                                                            *
*    REGISTER CONVENTIONS                                             *
*       R11 - BASE REGISTER                                           *
*       R12 - POINTER TO CONTROLLER III WORKAREA                      *
*       R13 - POINTER TO WORKCORE OF WHICH THE FIRST                  *
*             72 BYTES IS A SAVE AREA                                 *
***********************************************************************
         EJECT
R0       EQU   0                   REGISTER 0
R1       EQU   1                    POINTS TO CURRENT SLOT IN MAINLINE
R2       EQU   2                   REGISTER 2
R3       EQU   3                   REGISTER 3
R4       EQU   4                   REGISTER 4
R5       EQU   5                   REGISTER 5
R6       EQU   6                   REGISTER 6
R7       EQU   7                   REGISTER 7
R8       EQU   8                   REGISTER 8
R9       EQU   9                   REGISTER 9
R10      EQU   10                  REGISTER 10
R11      EQU   11                       MAIN BASE REG FOR THE PROGRAM
R12      EQU   12                  POINTS TO CNTRLR III WORKAREA
R13      EQU   13                           POINTS TO WORK AREA.
R14      EQU   14                  REGISTER 14
R15      EQU   15                  REGISTER 15
BLKSP    EQU   0                   SUBPOOL FOR LOCATE BLOCKS
WORKSP   EQU   0                   SUBPOOL FOR WORKAREA
TTROFF   EQU   9                   OFFSET TO TTR FIELD
CIRVOLS  EQU   X'04'               VOLUMES OPTION
CIRDSN   EQU   X'01'               DSNAME  OPTION
CIRIND   EQU   X'02'               INDEX   OPTION
CIROFF   EQU   8                   OFFSET TO CIR ENTRY
DSNENT   EQU   X'07'               CIR DSNAME CODE
DSNLEN   EQU   9                   LENGTH OF DSNAME ENTRY
GDGENT   EQU   X'02'               GDG ENTRY CODE
GDGLEN   EQU   16                  LENGTH OF GDG ENTRY
INDENT   EQU   X'00'               INDEX ENTRY
INDLEN   EQU   12                  LENGTH OF INDEX ENTRY
VOLENT   EQU   X'08'               VOLUMES WITH DSNAME ENTRY
VCBENT   EQU   X'01'               VOLUME CONTROL BLOCK ENTRY
VCBLEN   EQU   12                  LENGTH OF VCB ENTRY
ALIENT   EQU   X'04'               ALIAS ENTRY
ALILEN   EQU   20                  LENGTH OF ALIAS ENTRY
CVOLENT  EQU   X'05'               CVOL POINTER ENTRY
CVOLLEN  EQU   19                  LENGTH OF CVOL ENTRY
CIRVOLID EQU   259                 OFFSET TO VOLID IN CIR LIST (LOCATE)
ASTSW    EQU   X'80'               OPTMASK-ASTERISK IN INDEX STRUCTURE
GDGSW    EQU   X'20'               OPTMASK GDG SWITCH
ANYOPT   EQU   X'07'               HISTORY + DATA + MEMBERS
GDGSWOFF EQU   X'DF'               AND MASK FOR GDGSW
LOCSAVOF EQU   72                  OFFSET TO LOCAL SAVEAREA
HIGHBIT   EQU   X'80'              USED FOR TEST OF HIGH BIT
BLANK    EQU   C' '                BLANK
CHARG    EQU   C'G'                G
CHARV    EQU   C'V'                V
COMPZONE EQU   X'F0'               MASK TO TEST FOR COMPLEMENT
FOXES    EQU   X'FF'               VALUE OF HEX FF
ON       EQU   X'01'               SWITCH ON VALUE
OFF      EQU   X'00'               SWITCH OFF VALUE
EIGHT    EQU   X'08'               VALUE OF HEX 08
FORTY5   EQU   45                  VALUE OF 45
ENTPTR   EQU   4                   OFFSET OF 4 FOR CIR RTN
CHARA    EQU   C'A'                TYPE CODE FOR NON-VSAM DATASETS
HEX00    EQU   X'00'               BYTE COMPARE FIELD
FORWARD  EQU   8                   OFFSET TO FORWARD CHAIN SAVE
BACKWARD EQU   4                   OFFSET TO BACKWARD CHAIN SAVE
L0       EQU   0                   USED FOR LENGTH OFFSETS WHEN NECC
L1       EQU   1                   LENGTH OFFSET OF ONE
L3       EQU   3                   LENGTH OF 3
L4       EQU   4                   LENGTH OF 4
D0       EQU   0                   DISPLACEMENT OF 0
D1       EQU   1                   DISPLACEMENT OF 1
D2       EQU   2                   DISPLACEMENT OF 2
D3       EQU   3                   DISPLACEMENT OF 3
D4       EQU   4                   DISPLACEMENT OF 4
D6       EQU   6                   DISPLACEMENT OF 6
D8       EQU   8                   DISPLACEMENT OF 8
L8       EQU   8                   LENGTH OF EIGHT
PERIOD   EQU   C'.'                USED FOR PERIOD CONSTANT
D14      EQU   14                  OFFSET OF 14
D15      EQU   15                  OFFSET OF 15
L43      EQU   43                  LENGTH OF 43
TWELVE   EQU   12                  USED FOR OFFSET OF 12
CIROPT   EQU   0                   OFFSET TO OPTION BYTE IN PARM LIST
CIRSRCH  EQU   4                   OFFSET TO WORD PTR TO TTR OR NAME
CIRWA    EQU   12                  OFFSET TO WORK AREA FOR LIST
ACIRSAVE EQU   16                  OFFSET TO WORK SAVE AREA PASSED
HEXFF    EQU   X'FF'               MASK FOR ALL BITS ON
FRSTNTRY EQU   2                   OFFSET TO FIRST ENTRY IN A CTLG BLK
CODEOFF  EQU   0                   OFFSET TO CODE IN ENTRY FOR OUTPUT
NAMEOFF  EQU   1                   OFFSET TO NAME IN ENTRY FOR OUTPUT
ATTROFF  EQU   256                 OFFSET TO TTR OF NEXT CATALOG BLOCK
VOLOFF   EQU   259                 OFFSET TO VOLSER OF CATALOG CVOL
VOLSEROF EQU   4                   OFFSET TO VOLSER IN LINK ENTRY
GDGDATA  EQU   12                  OFFSET TO GDGDATA FIELD IN ENTRY
DEVCDEOF EQU   9                   OFFSET TO DEVICE CODE FIELD IN ENTRY
CVOLVOL  EQU   13                  OFFSET TO VOLSER OF CVOL IN ENTRY
NAMLEN   EQU   8                   LENGTH OF SIMPLE NAME
ONE      EQU   1                   ONE MEANS 1--USED MAINLY IN SHIFTING
CATENTLN EQU   12                  LENGTH OF BASIC CATALOG ENTRY
TTRLEN   EQU   3                   LENGTH OF TTR
VOLLEN   EQU   6                   LENGTH OF VOLSER
ALIASLEN EQU   12                  LENGTH OF ALIAS ENTRY IN LIST
DSLEN    EQU   9                   LENGTH OF BASIC PART OF LIST ENTRY
DATALEN  EQU   4                   LENGTH OF GDG DATA IN OUTPUT LIST
DEVCDELN EQU   4                   LENGTH OF DEVICE CODE IN CVOL ENTRY
INDXNTRY EQU   X'00'               INDEX ENTRY CODE
DSNMNTRY EQU   X'07'               DS NAME ENTRY CODE
MULTIVOL EQU   X'F8'               DS NAME ENTRY WITH MULTIVOLUMES
GDGENTRY EQU   X'02'               GDG ENTRY CODE
VCBENTRY EQU   X'01'               VOLUME CONTROL BLOCK ENTRY CODE
ALIAS    EQU   X'04'               ALIAS ENTRY CODE
OLDPTR   EQU   X'03'               OLD CVOL PTR CODE (BEFORE REL. 17)
NEWPTR   EQU   X'05'               NEW CVOL PTR CODE (AFTER RELEASE 17)
DSOPT    EQU   X'01'               OPT CODE FOR SIMPLE DSNAMES IN LIST
INDOPT   EQU   X'02'               OPT CODE FOR SIMPLE QUALS IN LIST
VOLOPT   EQU   X'04'               OPTION CODE FOR VOLS TO BE INCLUDED
OTHROPT  EQU   X'08'               OPTION CODE FOR ALL OTHER ENTRIES
ALLOPT   EQU   X'0F'               MASK FOR ALL OPTIONS
INDXCODE EQU   X'00'               LIST CODE FOR AN INDEX ENTRY
VCBCODE  EQU   X'01'               VOLUME CONTROL BLOCK ENTRY LIST CODE
GDGCODE  EQU   X'02'               GDG ENTRY LIST CODE
ALIASCDE EQU   X'04'               ALIAS ENTRY LIST CODE
CVOLCODE EQU   X'05'               CVOL ENTRY LIST CODE
DSNWOVOL EQU   X'07'               SIMPLE DSNAME ENTRY WITHOUT VOLUMES
DSNWVOLS EQU   X'08'               SIMPLE DSNAME ENTRY WITH VOLUMES
LINKCODE EQU   X'FF'               LINK ENTRY LIST CODE
INDXCBLK EQU   X'00'               FOR TESTING FOR INDEX CTL ENTRIES
TWENTY5  EQU   25                  MINIMUM COUNT FOR VALID INDEX BLOCK
VOLPLUS  EQU   X'0B'               ALL OPTIONS EXCEPT VOLOPT
CNT      EQU   11                  OFFSET TO CNT FIELD IN CTLG ENTRIES
ERR01    EQU   8                   VOLS ONLY REQUEST--INDEX BLOCK FOUND
ERR02    EQU   12                  VCB FOUND IN ERROR
ERR03    EQU   4                   LOCATE FAILED-- RC STORED INTO LIST
ABENDCD  EQU   X'11A'              ABEND CODE WHEN UNDER USERS KEY
         EJECT
         SAVE  (14,12),,*
         LR    R11,R15             SET UP ADDRESSABILITY
         USING IGG0CLCB,R11        USE R11 FOR MAIN BASE.
         LR    R4,R1               SAVE OUT AREA ADDRESS
         LR    R3,R0         SAVE DSNAME AREA ADDRESS
         GETMAIN  R,LV=WORKSIZE,SP=WORKSP    GET INITIAL CORE
         ST    R13,BACKWARD(R1)      SET UP BACKWARD CHAIN
         ST    R1,FORWARD(R13)       SET UP FORWARD CHAIN
         LR    R13,R1              SETUP ADDRESSABILITY FOR WORK SPACE.
         USING WORKCORE,R13          USE R13 FOR WORKCORE BASE
         ST    R4,OUTADDR      SAVE OUT AREA ADDRESS
         ST    R2,TCBADDR    SAVE ADDRESS OF TCB
         MVI   TOOSMALL,OFF  INIT SWITCH TO OFF
         MVI   KEYTYPE,OFF   INIT SWITCH TO SVC KEY
***********************************************************************
*
*        INITIALIZE CHAIN ADDRESSES OF CIR BLOCKS AND POINT TO START
*        OF CHAIN FROM FIRSTBLK LOCATION.
*
*      BLOCKS ARE OBTAINED DYNAMICALLY AS NEEDED AND ARE KEPT
*      IN THE TABLE UNTIL THE END OF THE PROGRAM WHEN THEY ARE FREED.
*
***********************************************************************
         LA    R1,CIRBLOCK         POINT AT FIRST BLOCK
         ST    R1,FRSTBLK          SAVE ADDR OF FIRST CIR BLOCK
         ST    R1,CURNTBLK         INITIALIZE CURRENT CIR BLOCK PTR
         XC    ENTPTR(L4,R1),ENTPTR(R1) CLEAR CURRNT ENTRY PT
         LA    R1,CIRBLOCK+CIRBLKLN LINK FOUR BLOCKS TOGETHER
         ST    R1,CIRBLOCK         LINK ONE TO TWO
         XC    ENTPTR(L4,R1),ENTPTR(R1) CLEAR CRRNT ENTRY PTR
         LA    R2,CIRBLKLN(R1)     LINK BLOCK TWO TO THREE
         ST    R2,D0(R1)           STORE PTR
         XC    ENTPTR(L4,R2),ENTPTR(R2)   CLEAR CURRENT ENTPTR
         LA    R1,CIRBLKLN(R2)     LINK THREE TO FOUR
         ST    R1,D0(R2)           STORE PTR
         XC    D0(L8,R1),D0(R1)    CLEAR CHAIN ADDR -CURRENT ENTRY PTR
         XC    ESTAELST(16),ESTAELST ZERO ESTAE MACRO LIST FORM
         STM   R11,R13,SAVER11 SAVE REGS FOR ESTAE             @YM05170
         ESTAE ESTAEXIT,CT,PARAM=SAVER11,XCTL=NO,RECORD=YES,           *
               MF=(E,ESTAELST) ISSUE ESTAE
         LTR   R15,R15       IS RETURN CODE ZERO
         BZ    ESTAEOK       YES,CONTINUE
         MVC   RETCD,RC8     SET RETURN CODE
         B     WRAPUP        EXIT
ESTAEOK  EQU   *
         NI    OPTMASK,HEX00       CLEAR OPTION BYTE
         MVI   FIRSTCIR,OFF        TURN OFF FIRST CIR SWITCH
         MVI   FIRSTIME,ON         TURN ON FIRST ALLOCATE SWITCH
         MVC   GETML(LILFS),GETMLMDL  MOVE LIST FORM OF MACROS TO WORK
         CLI   0(R3),L43     IS NODE TOO LARGE
         BH    NOENTRY       YES,EXIT WITH RETURN CODE 4
         CLI   0(R3),L1      IS NODE TOO SMALL
         BL    NOENTRY       YES,EXIT WITH RETURN CODE 4
         MVI   USERNODE,BLANK        PROPAGATE BLANKS FOR USERID
         MVC   USERNODE+D1(L'USERNODE-D1),USERNODE CLEAR USERND AREA
         SR    R1,R1         CLEAR REG 1
         IC    R1,D0(R3)     PUT DSNAME LENGTH IN R1
         LA    R7,D0(R3,R1)  POINT TO LAST BYTE OF NAME
         CLI   D0(R7),PERIOD IS THIS A PERIOD
         BNE   MOVENODE      NO,GO AHEAD WITH REQUEST
         BCTR  R1,R0         YES,DECREMENT LENGTH BY ONE
         LTR   R1,R1         IS LENGTH NOW ZERO
         BZ    NOENTRY       YES,CANNOT PROCESS SO EXIT WITH RC=4
MOVENODE EQU   *
         STH   R1,USRNODEL   SAVE LENGTH
         LA    R3,D1(R3)     POINT TO DSNAME
         BCTR  R1,R0         DECREMENT LENGTH FOR MOVE
         LA    R7,USERNODE   POINT TO HOLD AREA FOR NODE
         EX    R1,MOVE       MOVE NODE TO HOLD AREA
         MVC   SAVENODE,USERNODE      SAVE NODE FOR BUILD NAME @YM07060
         XC    RETCD,RETCD         SET RETURN CODE TO ZERO INITIALLY
         XC    GDGCNT,GDGCNT       CLEAR GDG COUNT AREA
         LA    R1,USERNODE         POINT AT NAME TO SEARCH ON
         ST    R1,CIRINDX          STORE IN PARM LIST
         LA    R1,CIRSAVE          CIR SAVE AREA
         ST    R1,CIRWK2           STORE IN LIST
         XC    CIRVOL,CIRVOL       CLEAR VOLUME PTR
MAIN00A  XC    CIRPARM,CIRPARM      CLEAR OPTIONS
         OI    CIRPARM,CIRDSN+CIRIND REQUEST DSNAMES AND INDEX NAMES
         BAL   R8,OBTBLK           GET FIRST FREE BLK
         MVI   FIRSTCIR,ON         TURN ON FIRST CIR SWITCH
         BAL   R8,CIRROUT          CALL CIR
         LTR   R15,R15             TEST R15 FOR 0
         BZ    MAIN00              YES, GO PROCESS
         MVC   RETCD,RC4     INDICATE DATASET NOT FOUND
         B     WRAPUP              GO TERMINATE
         EJECT
MAIN00   EQU   *
***********************************************************************
*
* CHECK FOR A NULL LIST AND RETURN TO CALLER WITH RC OF 4 IF THE INDEX
* STRUCTURE SPECIFIED, OR USERID, HAD NO DATA SETS CATALOGED
* UNDER IT.
*
***********************************************************************
         L     R1,CURNTBLK         GET CURRENT BLK POINTER
         LA    R6,D8(R1)           POINT AT LIST
         ST    R6,D4(R1)           MAKE FIRST ENTRY CURRENT
         CLI   D0(R6),FOXES        CHECK FOR LINK ENTRY
         BNE   MAIN01              NO, PROCESS LIST
         CLC   D1(L3,R6),ZERO      SEE IF TTR IS ZERO
         BE    NOENTRY             YES, TERMINATE
MORDATA  LA    R1,D4(R6)           PT AT VOLSER IN LINK ENTRY
         MVC   CIRCVOL(L'CIRCVOL),D0(R1) MOVE CVOL TO SAVE AREA
         LA    R1,CIRCVOL          POINT AT CVOL
         ST    R1,CIRVOL           STORE INTO LIST
         LA    R1,D1(R6)           POINT AT TTR
         MVC   CIRTTR(L'CIRTTR),D0(R1) MOVE TTR TO SAVE AREA
         LA    R1,CIRTTR           ADDRESS OF TTR FOR PARM LIST
         ST    R1,CIRINDX          STORE IN LIST
         OI    CIRINDX,ASTSW       TURN ON TTR INDICATOR BIT
         B     MAIN00A             TRY AGAIN
NOENTRY  EQU   *
         MVC   RETCD,RC4     INDICATE DATASET NOT FOUND
         B     WRAPUP              GO TERMINATE
*
MAIN01   EQU   *
***********************************************************************
*
*        ENTRY IS MADE TO THIS ROUTINE WITH REG 6 POINTING TO A NEW
*        LIST ELEMENT. THE LIST ENTRY IS ANALYZED AND THE APPROPRIATE
*        ROUTINE IS USED TO PROCESS IT. DSNAME ENTRIES ARE USED TO
*        COMPLETE FULLY QUALIFIED DATA SET NAMES, AND ARE RETURNED
*        TO THE CALLERS OUTPUT AREA
*
***********************************************************************
         CLI   D0(R6),DSNENT       DSNAME ENTRY
         BE    DSNAMRT             YES, GO BUILD FULL DSNAME
*
         CLI   D0(R6),VOLENT       DSNAME ENTRY WITH VOLUMES
         BE    DSNAMRT             YES, GO BUILD FULL DSNAME
*
         CLI   D0(R6),VCBENT       VOLUME CONTROL BLOCK ENTRY
         BE    VCBROUT             YES, GO PROCESS--BUILD FULL DSNAME
*
         CLI   D0(R6),INDENT       INDEX ENTRY
         BE    INDEXRT             YES, GO PROCESS-GET A NEW LIST
*
         CLI   D0(R6),GDGENT       GENERATION DATA GROUP ENTRY
         BE    GDGROUT             YES, GO PROCESS SIMPLE NAMES
         CLI   D0(R6),FOXES        CHECK FOR LINK ENTRY
         BE    MAIN01A             PROCESS NORMALLY
         CLC   D1(L3,R6),ZERO      SEE IF TTR IS ZERO
         BE    WRAPUP              GO TERMINATE
         B     MORDATA             MORE DATA TO BE PROCESSED
*
MAIN01A  EQU   *
         BAL   R8,POINTER          GO UPDATE CURRENT ENTRY PTR TO NEXT
         L     R6,CURNTBLK         GET CURRENT BLOCK POINTER
         L     R6,D4(R6)           GET CURRENT ENTRY POINTER
         B     MAIN01              GO ANALYZE ENTRY TYPE.
       EJECT
INDEXRT  DS    0H
***********************************************************************
*
*        THIS ROUTINE GETS CONTROL WHEN AN INDEX ENTRY IS DISCOVERED
*        IN THE LIST FROM CIR. IT SETS UP A PARAMETER LIST FOR CIR
*        AND USES OBTBLK TO ALLOCATE ANOTHER BLOCK FOR A NEW LIST
*        OF LOWER QUALIFIERS. IF THE NEW LIST IS FOUND TO BE EMPTY,
*        THE NEXT ENTRY IS PROCESSED.OTHERWISE THE NEW LIST
*        IS MADE CURRENT.
*              CURNTBLK POINTS TO CURRENT CIR LIST
*
***********************************************************************
         XC    CIRPARM,CIRPARM     CLEAR CIR OPTIONS
         LA    R1,TTROFF(R6)       POINT AT TTR FIELD IN INDEX ENTRY
         ST    R1,CIRINDX          STORE IN CIRPARM LIST
         OI    CIRINDX,HIGHBIT     TURN ON HIGH BIT EQUALTTR
         L     R1,CURNTBLK         GET CURNT BLOCK ADDRESS
         LA    R1,CIRVOLID+VOLENT(R1) POINT PAST CHAIN ADDRS TO VOLSER
*                                AT END OF CIR LIST.
         ST    R1,CIRVOL           PUT PTR IN PARM LIST
IND00    EQU   *
         OI    CIRPARM,CIRDSN+CIRIND REQUEST DSNAMES AND INDEXNAMES
         BAL   R8,OBTBLK           GET FIRST FREE BLOCK
         BAL   R8,CIRROUT          CALL CIR
         LTR   R15,R15             TEST RETURN CODE
         BNZ   CIR08               NONZERO, LET CIRROUT HANDLE ERROR
*
*        CHECK FOR EMPTY INDEX STRUCTURE
*
         L     R1,CURNTBLK         GET ADDR OF NEW BLOCK
         LA    R6,D8(R1)           POINT AT FIRST ENTRY
         ST    R6,D4(R1)           MAKE IT CURRENT ENTRY
         CLI   D0(R6),FOXES        CHECK FOR LINK ENTRY
         BNE   MAIN01              NO, GO PROCESS LIST
         CLC   D1(D3,R6),ZERO      SEE IF TTR IS ZERO
         BE    EMPTYIND            YES, IT IS AN EMPTY INDEX
         LA    R1,D4(R6)           POINT AT VOLSER IN LINK ENTRY
         ST    R1,CIRVOL           PUT INTO CIR PARM LIST
         LA    R1,D1(R6)           POINT AT TTR
         ST    R1,CIRINDX          STORE INTO LIST
         OI    CIRINDX,ASTSW       INDICATE TTR ENTRY
         XC    CIRPARM,CIRPARM     CLEAR OPTION BYTES
         B     IND00               TRY AGAIN
EMPTYIND EQU   *
         XC    D4(L4,R1),D4(R1)    FREE CURRENT BLK
         B     MAIN01A       GO PROCESS NEXT ENTRY
       EJECT
DSNAMRT  DS    0H
VCBROUT  DS    0H
***********************************************************************
*
*        THIS ROUTINE IS GIVEN CONTROL WHEN A DATA SET ENTRY OR
*        VOLUME CONTROL BLOCK ENTRY IS FOUND IN THE LIST FROM CIR.
*        A CHECK IS MADE TO DETERMINE IF A GENERATION DATA GROUP IS
*        BEING PROCESSED. IF SO, THE GENERATION PORTION OF THE SIMPLE
*        NAME MUST BE COMPLEMENTED. THEN THE FULLY QUALIFIED NAME,
*        WITH THE NODE, IS CONSTRUCTED AND RETURNED TO THE CALLERS
*        OUTPUT AREA.
*              REG 6 POINTS TO CURRENT ENTRY
*
***********************************************************************
*  CHECK FOR GENERATION DATA GROUP DATA SET NAME
         CLI   D1(R6),CHARG        TEST FOR A G
         BNE   GDGTEST             NO, CONTINUE
         CLI   D6(R6),CHARV        TEST FOR A V
         BNE   GDGTEST             NO, CONTINUE
         L     R1,FOUR             SET LOOP CONTROL
GDGLOOP  LA    R7,D0(R1,R6)        POINT TO CHARACTER TO BE TESTED
         TM    D1(R7),COMPZONE     TEST FOR COMPLEMENTED NUMBER
         BNZ   GDGTEST             NOT COMPLEMENT, CONTINUE
         BCT   R1,GDGLOOP          YES, CHECK NEXT CHARACTER
         XC    D2(L4,R6),FOXMASK   COMPLEMENT GENERATION NUMBER
GDGTEST  TM    OPTMASK,GDGSW       SEE IF GDG SWITCH IS ON
         BNO   DSN01               NO, SKIP COMPLEMENT
         L     R1,GDGCNT           GET NUMBER OF DATASETS REMAINING
         BCT   R1,DSN01A           DECREMENT COUNT
         NI    OPTMASK,GDGSWOFF    TURN OFF GDGSW
DSN01A   ST    R1,GDGCNT           SAVE UPDATED COUNT
DSN01    EQU   *
         BAL   R8,BUILDNAM         USE PORTION OF OBTBLK ROUT TO BUILD
*                                  DSNAME
         B     MAIN01A             PROCESS NORMALLY
         EJECT
GDGROUT  DS    0H
***********************************************************************
*
*        THIS ROUTINE IS ENTERED IF A GDG ENTRY IS FOUND IN THE CIR
*        LIST. IT TURNS ON THE GDGSW SWITCH SO THAT THE DSNAME ENTRY
*        ROUTINE WILL KNOW THAT THE GENERATION NUMBER IN THE SIMPLE
*        NAMES WILL REQUIRE COMPLEMENTING. A CHECK IS MADE TO SEE
*        IF ANY GENERATIONS EXIST. IF NOT, THE ENTRY IS SKIPPED.
*        IF IT IS NOT EMPTY THE COUNT IS KEPT AND DECREMENTED EACH
*        TIME A GENERATION NAME IS PROCESSED. CONTROL IS PASSED TO THE
*        INDEX ENTRY ROUTINE TO READ IN THE LIST OF NAMES THROUGH CIR.
*
*              REG 6 POINTS TO CURRENT ENTRY
*
***********************************************************************
         XR    R1,R1               CLEAR REG FOR IC
*  COUNT IS LAST 2 BYTES OF ENTRY
         IC    R1,D14(R6)          GET FIRST BYTE
         SLL   R1,L8               SHIFT FIRST BYTE OVER
         IC    R1,D15(R6)          GET SECOND CHARCTER
         LTR   R1,R1               IS COUNT ZERO
         BZ    MAIN01A             YES,GO PROCESS NEXT ENTRY
         ST    R1,GDGCNT           NO, SAVE COUNT
         OI    OPTMASK,GDGSW       TURN ON GDG SWITCH
         B     INDEXRT             GO GET LIST FROM CIR
         EJECT
WRAPUP   DS    0H
***********************************************************************
*
*        THIS ROUTINE GETS CONTROL WHEN COMPLETE OR
*        AN ERROR RESULTING IN TERMINATION OCCURS. IT FREES ALL
*        DYNAMIC CORE OBTAINED.
*
***********************************************************************
         ESTAE 0             REMOVE ESTAE
         L     R1,FRSTBLK        GET PTR TO FIRST CIR BLOCK
         L     R1,CIRBLKLN*3(R1) GET CHAIN PTR OUT OF LAST BLOCK
WRAPUP00 C     R1,ZERO             IS IT ZERO
         BE    WRAPUP01            YES, ALL EXTRA BLOCKS ARE FREED
         L     R2,D0(R1)           CHAIN PTR TO NEXT
         FREEMAIN R,LV=CIRBLKLN,A=(1),SP=BLKSP
         LR    R1,R2               COPY CHAIN PTR
         B     WRAPUP00            GO CHECK NEXT PTR
WRAPUP01 EQU   *
         L     R2,RETCD      SAVE RETURN CODE ACCROSS FREEMAIN
         CLI   TOOSMALL,ON   WAS USER AREA EXCEEDED?
         BNE   WRAPUP02      NO,LEAVE RETURN CODE AS IS
         L     R2,RC12       YES,INDICATE USER AREA EXCEEDED
WRAPUP02 EQU   *
         L     R3,D4(R13)    SAVE PREVIOUS SAVEAREA ADDRESS
         FREEMAIN R,LV=WORKSIZE,A=(13),SP=WORKSP
         LR    R15,R2        RESET RETURN CODE
         LR    R13,R3        RESET PREVIOUS SAVE AREA ADDRESS
         RETURN (14,12),RC=(15)
         EJECT
POINTER  DS    0H
***********************************************************************
*
*        THIS ROUTINE IS ENTERED TO UPDATE THE CURRENT ENTRY POINTER
*        IN THE CURRENT BLOCK. THE CURRENT BLOCK IS DETERMINED BY
*        SEARCHING THE CHAIN FOR THE FIRST ONE WITH A ZERO ENTRY
*        POINTER AND THEN BACKING UP ONE. THE CURRENT ENTRY TYPE IS
*        DETERMINED AND THE POINTER IS ADVANCED ACCORDINGLY. IF THE
*        NEXT ENTRY IS A LINK ENTRY WHICH CONTAINS A NONZERO TTR,
*        THE CIR IS CALLED TO PROVIDE THE NEXT BLOCK OF ENTRIES. IF
*        THE TTR IS ZERO, THE CURRENT BLOCK IS RELEASED AND THE
*        PRECEDING BLOCK IS CONSIDERED. WHEN ALL BLOCKS ARE PROCESSED,
*        IE, THE CURRENT BLOCK EQUALS THE FIRST BLOCK AND THE ENTRY
*        POINTER IS ZERO, THE WRAPUP ROUTINE IS ENTERED.
*
***********************************************************************
         STM   R0,R9,LOCSAVOF(R13)  SAVE REGISTERS LOCALLY
PTR00    L     R1,FRSTBLK          GET PTR TO FIRST BLOCK
         CLC   D4(L4,R1),ZERO      SEE IF PTR IS ZERO
         BE    WRAPUP              YES, WE ARE FINISHED
PTR01    ST    R1,PREVBLK          SAVE THIS BLOCK PTR
         L     R1,D0(R1)           GET PTR TO NEXT BLOCK
         CLC   D4(L4,R1),ZERO      SEE IF PTR IS ZERO
         BE    PTR02               YES,PROCESS LAST PTR
         CLC   D0(L4,R1),ZERO      NO, CHECK CHAIN ADDRESS
         BNE   PTR01               IF NOT ZERO, TRY NEXT BLOCK.
         B     PTR03               GO AROUND NEXT INSTRUCTION
PTR02    L     R1,PREVBLK          GET PREVIOUS BLOCK POINTER.
PTR03    L     R2,ENTPTR(R1)       PICK UP CURRENT ENTRY POINTER
         CLI   D0(R2),DSNENT       CHECK FOR DSNAME ENTRY
         BNE   PTR04               NO, CHECK NEXT CODE
         LA    R2,DSNLEN(R2)       UPDATE PTR
         B     PTRFFCHK            GO CHECK FOR LINK ENTRY
*
PTR04    CLI   D0(R2),GDGENT       GDG ENTRY
         BNE   PTR05               NO, CHECK NEXT
         LA    R2,GDGLEN(R2)       BUMP PTR
         B     PTRFFCHK            GO CHECK FOR LINK ENTRY
*
PTR05     CLI   D0(R2),INDENT      INDEX ENTRY
         BNE   PTR06               NO, CHECK NEXT
         LA    R2,INDLEN(R2)       BUMP PTR
         B     PTRFFCHK            GO CHECK FOR LINK ENTRY
*
PTR06    CLI  D0(R2),VOLENT        VOLUMES WITH DSNAME
         BNE   PTR07               NO, CHECK NEXT
         XR    R4,R4               CLEAR FOR INSERT CHARACTER
         IC    R4,DSNLEN+D1(R2)       GET VOLUME COUNT
         LA    R5,VCBLEN           LENGTH OF EACH ENTRY IN VOLUME LIST
         MR    R4,R4               TOTAL LENGTH OF LIST
         LA    R2,DSNLEN+D2(R2,R5)    BUMP PTR BEYOND ENTRY
         B     PTRFFCHK            GO CHECK FOR LINK ENTRY.
*
PTR07    CLI   D0(R2),VCBENT       VOLUME CONTROL BLOCK PTR ENTRY
         BNE   PTR08               NO, CHECK NEXT
         LA    R2,VCBLEN(R2)       BUMP POINTER
         B     PTRFFCHK            CHECK FOR LINK ENTRY
*
PTR08    CLI   D0(R2),ALIENT       ALIAS ENTRY
         BNE   PTR09               NO, CHECK NEXT
         LA    R2,ALILEN(R2)       BUMP POINTER
         B     PTRFFCHK            CHECK FOR LINK ENTRY
*
PTR09    CLI   0(R2),CVOLENT       CHECK FOR CVOL PTR ENTRY
         BNE   PTR10               NO, MUST BE LINK ENTRY
         LA    R2,CVOLLEN(R2)      BUMP POINTER
PTRFFCHK EQU   *
         ST    R2,ENTPTR(R1)       UPDATE ENTRY PTR IN BLOCK
         CLI   D0(R2),FOXES        CHECK FOR LINK ENTRY
         BNE   PTREXIT             GO TO EXIT IF NOT LINK ENTRY
PTR10    CLC   D1(L3,R2),ZERO      IS TTR ZERO
         BNE   PTR11               NO, GET ANOTHER BLOCK
         XC    D4(L4,R1),D4(R1)    CLEAR ENTRY POINTER
         B     PTR00               GO BACK TO START OF ROUTINE
PTR11    EQU   *
*
*        A LINK ENTRY WAS FOUND WITH A NONZERO TTR. UNCHAIN LAST
*        BLOCK AND PASS IT BACK TO CIR TO COMPLETE LIST.
*
         XC    D4(L4,R1),D4(R1)     UNCHAIN LAST BLOCK
         LA    R3,D8(R1)           POINT AT AREA FOR LIST FROM CIR
         ST    R3,CIRWK1           STORE IN PARM LIST
         LA    R3,D1(R2)           POINT AT TTR
         MVC   CIRTTR(L'CIRTTR),D0(R3)  MOVE TTR TO SAVE AREA
         LA    R1,CIRTTR           POINT AT TTR OF NEXT BLOCK
         ST    R1,CIRINDX          PUT IN LIST
         OI    CIRINDX,ASTSW       TURN ON BIT INDICATING TTR
         LA    R3,D3(R3)           POINT AT VOLID FOR CATALOG
         MVC   CIRCVOL(L'CIRCVOL),D0(R3)  MOVE CVOL TO SAVE AREA
         LA    R1,CIRCVOL          GET ADDRESS OF CVOL
         ST    R1,CIRVOL           PUT ADDRESS IN LIST
         XC    CIRPARM,CIRPARM     CLEAR OPTION BYTE
         TM    OPTMASK,ANYOPT      CHECK FOR HISTORY, VOLUMES, MEMBERS
         BZ    PTR12               NONE, SKIP VOLUME REQUEST OPT
         OI    CIRPARM,CIRVOLS     REQUEST VOLUMES
PTR12    OI    CIRPARM,CIRDSN+CIRIND REQUEST DSNAMES AND INDEX NAMES
*
         BAL   R8,CIRROUT          CALL CIR
         LTR   R15,R15             CHECK R15 FOR ZERO
         BNZ   CIR08               NO, PROCESS ERROR BACK IN CIRROUT
*
         L     R2,CIRWK1           GET AREA POINTER
         LR    R1,R2
         LA    R3,D8               GET DECREMENT FACTOR
         SR    R1,R3               POINT AT LINK FIELDS OF BLOCK
         ST    R2,D4(R1)           STORE IN BLOCK
PTREXIT  EQU   *
         ST    R1,CURNTBLK         POINT TO NEW BLOCK AS CURRENT
         LM    R0,R9,LOCSAVOF(R13)  REFRESH REGISTERS
         BR    R8                  RETURN TO CALLER
CIRROUT  EQU   *
         LA    R1,CIRPARM          PARM LIST FOR CALL MACRO
         LA    R15,CIR       GET CIR ADDRESS
         BALR  R14,R15       CALL CIR SUBROUTINE
         B     CIRRC(R15)          ANALYZE RETURN CODE
*
CIRRC    B     CIROK               RC=00 SUCCESSFUL OPERATION
         B     CIR04               RC=04 LOCATE FAILED
         B     CIR08               RC=08 VOL REQUEST-INCOMPATIBLE OPT
         B     CIR12               RC=12 VOLUMES FOUND-INCOMPATIBLE OPT
CIR04    EQU   *
CIR08    EQU   *
         MVC   RETCD,RC4     INDICATE DATASET NOT FOUND
         B     WRAPUP        TERMINATE
CIROK    EQU   *
CIR12    EQU   *
         BR    R8                  RETURN TO CALL.
         EJECT
OBTBLK   DS    0H
***********************************************************************
*
*        THIS ROUTINE IS ENTERED VIA 'BAL R8,OBTBLK' AND IS USED TO
*        OBTAIN A NEW BLOCK TO BE USED AS A WORK AREA FOR CIR AND
*        TO BECOME THE CURRENT BLOCK. IF NO FREE BLOCKS ARE AVAILABLE
*        THEN A CONDITIONAL GETMAIN IS ISSUED AND THE NEW BLOCK IS
*        ADDED ON THE CHAIN. IF THE GETMAIN FAILS, CONTROL IS
*        RETURNED TO THE CALLER WITH RETURN CODE OF 8.
*
***********************************************************************
         STM   R0,R9,LOCSAVOF(R13)  SAVE REGISTERS LOCALLY.
         L     R1,FRSTBLK          GET PTR TO FIRST BLOCK.
OBTBLK01 CLC   ENTPTR(D4,R1),ZERO     SEE IF THE ENTRY POINTER IS ZERO
         BE    OBTBLK03            YES, USE THIS BLOCK
         CLC   D0(L4,R1),ZERO      SEE IF CHAIN ADDRESS IS ZERO
         BE    OBTBLK02            YES, ISSUE GETMAIN FOR ANOTHER BLOCK
         L     R1,0(R1)            NO, PICK UP CHAIN ADDRESS
         B     OBTBLK01            GO CHECK NEXT BLOCK.
OBTBLK02 LR    R3,R1               SAVE PTR TO CURRENT LAST BLK
         LA    R1,GETML            POINT AT LIST FORM OF MACRO
         LA    R2,TEMPSAVE         ANSWER PLACE
         GETMAIN A=(R2),LV=CIRBLKLN,SP=BLKSP,MF=(E,(1))
         LTR   R15,R15             CHECK FOR RETURN CODE
         BNZ   OBTBLK04            YES, PROCESS ERROR
         L     R1,TEMPSAVE         GET NEW BLK ADDRESS
         ST    R1,D0(R3)           CHAIN IT ONTO LAST BLK
         XC    D0(L8,R1),D0(R1)     CLEAR ENTRY PTR AND CHAIN ADDR
OBTBLK03 EQU   *
         ST    R1,CURNTBLK         SAVE IT AS CURRENT BLOCK
         LA    R1,CIROFF(R1)       POINT AT CIR BLOCK
         ST    R1,CIRWK1           PUT IN LIST
         LM    R0,R9,LOCSAVOF(R13)  REFRESH REGISTERS
         BR    R8                  RETURN TO CALLER
OBTBLK04 EQU   *
         MVC   RETCD,RC8     INDICATE OUT OF CORE
         B     WRAPUP        TERMINATE
BUILDNAM EQU   *
         MVI   KEYTYPE,ON    INDICATE CHANGE TO USER KEY
         L     R10,TCBADDR   GET ADDRESS OF TCB
         USING TCB,R10       ESTABLISH ADDRESSABILITY TO TCB
* GET INTO USER'S KEY
         MODESET EXTKEY=RBT234,SAVEKEY=OLDKEY,WORKREG=3
         DROP  R10           DONE WITH TCB
         SR    R0,R0         CLEAR REG 0
         L     R7,OUTADDR    GET ADDRESS OF USER WORKAREA
         CH    R0,D2(R7)     IS CURRENT LENGTH ZERO?
         BNE   OBTBLKA       NO,GO CALCULATE NEXT ENTRY ADDR
         L     R0,FOUR       LOAD R0 WITH A FOUR
         STH   R0,D2(R7)     SET INITIAL LENGTH TO FOUR
OBTBLKA  EQU   *
         LH    R2,D2(R7)     GET CURRENT LENGTH IN R2
         LA    R3,FORTY5(R2) R3=CURRENT LENGTH + 45
         STH   R3,D2(R7)     SET CURRENT LENGTH
         CH    R3,D0(R7)     IS THERE ROOM FOR NEXT ENTRY?
         BH    OBTBLK08      NO,GO SET TOOSMALL INDICATOR
         AR    R7,R2         R7=ADDR OF NEXT ENTRY
         MVI   D0(R7),CHARA  SET TYPE FIELD TO NONVSAM -A-
         LA    R7,D1(R7)     BUMP PAST TYPE FIELD
         MVI   D0(R7),BLANK  CLEAR ENTRY AREA TO BLANKS
         MVC   D1(L43,R7),D0(R7)
         LH    R2,USRNODEL   GET LENGTH OF NODE
         LA    R3,SAVENODE   GET ADDRESS OF NODE               @YM07060
         BCTR  R2,R0         DECREMENT LENGTH FOR MOVE
         EX    R2,MOVE       MOVE NODE TO USER WORKAREA
         LA    R1,D1(R2,R7)  BUMP PAST NODE
         MVI   D0(R1),PERIOD PUT A PERIOD AFTER NODE
         LA    R1,D1(R1)     BUMP PAST PERIOD
         L     R2,FRSTBLK          GET FIRST BLK PTR
         L     R3,D4(R2)           GET CURRENT ENTRY POINTER
OBTBLK05 MVC   D0(L8,R1),D1(R3)    MOVE QUALIFIER TO USER AREA
         LA    R1,D8(R1)           POINT BEYOND NAME
OBTBLK06 BCTR  R1,R0               BACKUP POINTER BY ONE AND
         CLI   D0(R1),BLANK        TRUNCATE BLANKS.IS IT A BLANK
         BE    OBTBLK06            YES, TRY AGAIN
         LA    R1,D1(R1)           POINT JUST BEYOND NAME
         L     R2,D0(R2)           GET NEXT BLOCK
         LTR   R2,R2               SEE IF ADDRESS IS ZERO
         BZ    OBTBLK07            YES, WE ARE DONE
         CLC   D4(L4,R2),ZERO      IS ENTRY PTR ZERO
         BE    OBTBLK07            YES, WE ARE DONE
         L     R3,ENTPTR(R2)       NO, PICK UP PTR
         MVI   D0(R1),PERIOD       PLACE PERIOD AFTER LAST QUALIFIER
         LA    R1,D1(R1)           UPDATE POINTER
         B     OBTBLK05            PROCESS NEXT QUALIFIER
OBTBLK07 EQU   *
* GET BACK INTO SVC KEY
         MODESET KEYADDR=OLDKEY,WORKREG=3
         MVI   KEYTYPE,OFF   INDICATE CHANGE BACK TO SVC KEY
         BR    R8                  RETURN TO CALLER
OBTBLK08 EQU   *
* GET BACK INTO SVC KEY                                        @YM04820
         MODESET KEYADDR=OLDKEY,WORKREG=3                      @YM04820
         MVI   KEYTYPE,OFF   INDICATE CHANGE BACK TO SVC KEY   @YM04820
         MVI   TOOSMALL,ON   SET WORKAREA TOO SMALL INDICATOR  @YM04820
         BR    R8                  RETURN TO CALLER            @YM04820
         EJECT
ESTAEXIT EQU   *             ESTAE EXIT ROUTINE
         DROP  R11
         USING *,R15
         C     R0,RC12       IS RTCA AVAILABLE
         BE    NORTCA        NO,GO PROCESS WITHOUT IT
         DROP  R15
         USING IGG0CLCB,R11
         STM   R14,R12,TWELVE(R13) SAVE REGS
         LR    R4,R14        SAVE RETURN POINT
         L     R15,D0(R1)    GET PARM LIST ADDRESS
         LM    R11,R13,D0(R15) RESET NEEDED REGS
         LR    R3,R1         SAVE SDWA-RTCA ADDRESS
         USING SDWA,R3       SET ADDRESSABILITY TO SDWA
         TM    SDWAERRC,SDWAPERC WERE WE PERCOLLATED TO
         BO    ESTX0020      YES,BYPASS DUMPING
         CLI   KEYTYPE,ON    WERE WE UNDER USERS KEY
         BNE   ESTX0010      NO,BYPASS SETTING ABEND CODE
         SETRP DUMP=YES,COMPCOD=(ABENDCD,SYSTEM),RC=0,WKAREA=(3)
         B     ESTX0030      GO TO CLEAN UP
ESTX0010 EQU   *
         SETRP DUMP=NO,RECORD=YES,RC=0,RECPARM=RECORD,WKAREA=(3)
         SDUMP SDATA=LPA
         B     ESTX0030      GO TO CLEAN UP
ESTX0020 EQU   *
         SETRP DUMP=IGNORE,RECORD=YES,RC=0,WKAREA=(3),RECPARM=RECORD
ESTX0030 EQU   *
         L     R1,FRSTBLK    GET PTR TO FIRST CIR BLOCK
         L     R1,CIRBLKLN*3(R1) GET CHAIN PTR OUT OF LAST BLOCK
ESTX0040 EQU   *
         C     R1,ZERO       HAVE ALL BLOCKS BEEN FREED
         BE    ESTX0050      YES,BYPASS FREEMAIN
         L     R2,D0(R1)     CHAIN TO NEXT BLOCK
         FREEMAIN R,LV=CIRBLKLN,A=(1),SP=BLKSP
         LR    R1,R2         COPY CHAIN PTR
         B     ESTX0040      GO CHECK NEXT PTR
ESTX0050 EQU   *
         FREEMAIN R,LV=WORKSIZE,A=(13),SP=WORKSP FREEMAIN WORKAREA
         LR    R14,R4        RESET RETURN POINT
         SR    R15,R15       ZERO RETURN CODE
         BR    R14           RETURN TO RTM
NORTCA   EQU   *
         LR    R4,R14        SAVE RETURN POINT
         LM    R11,R13,D0(R2) RESET NEEDED REGISTERS           @YM05170
         B     ESTX0030      GO TO CLEAN UP
         DROP  R3
         EJECT
***********************************************************************
* THIS CODE IS A MODIFIED VERSION OF OS VS2-1 MODULE IKJEHCIR WHICH   *
* WAS USED FOR TSO LISTCAT COMMAND.                                   *
*                                                                     *
* FUNCTION --                                                         *
*                                                                     *
*    THIS SUBROUTINE IS DESIGNED TO PROVIDE AN INTERFACE BETWEEN      *
*    IGG0CLCB AND THE SYSTEM CATALOG.  IT ABBREVIATES                 *
*    INFORMATION FOUND IN THE CATALOG INDEX BLOCKS ACCORDING TO       *
*    OPTIONS SPECIFIED BY THE CALLER.  THE LIST OF INFORMATION        *
*    RETURNED TO THE CALLER AS A RESULT OF ONE CALL TO THIS           *
*    MODULE WILL INCLUDE ONLY WHAT IS FOUND IN ONE INDEX BLOCK.       *
*    MULTIPLE CALLS MAY THEREFORE BE REQUIRED IF ALL OF THE           *
*    INFORMATION AT A PARTICULAR LEVEL OF INDEX IS DESIRED.           *
*    THE INFORMATION OBTAINED BY THIS MOUDLE IS GOTTEN BY A CALL TO OS*
*    CATALOG MANAGEMENT WITH EITHER THE BLOCK OR NAME OPTION.         *
*    THE SECOND WORD OF THE PARAMETER LIST INPUT TO THIS MODULE       *
*    INDICATES WHICH OPTION IS TO BE SELECTED AS DESCRIBED LATER.     *
*    THE WORK AREA PROVIDED BY THE CALLER IS USED TO HOLD THE         *
*    INDEX BLOCK READ AND ULTIMATELY THE INFORMATION LIST. EACH       *
*    ENTRY IN THE INDEX BLOCK IS EXAMINED AND REQUESTED               *
*    INFORMATION IS RIPPLED DOWN TO THE FORWARD PORTION OF THE        *
*    BLOCK.                                                           *
*                                                                     *
* ENTRY POINTS --                                                     *
*                                                                     *
*         CIR                                                         *
*                                                                     *
* INPUT --                                                            *
*                                                                     *
*    THE FOLLOWING PARMETER LIST MUST BE SUPPLIED BY THE CALLING      *
*    PROGRAM FOR EACH ENTRY TO THIS MODULE.                           *
*                                                                     *
*                   *************************                         *
*               + 0 * OPTIONS*   UNUSED     *                         *
*                   *************************                         *
*               + 4 * A(INDEXNAME OR TTR)   *  IF TTR, HIGH ORDER BIT *
*                   *************************     SHOULD BE ON.       *
*               + 8 * A(VOLID OF CVOL)      *  DEFAULTS TO SYSRES IF  *
*                   *************************     NOT SPECIFIED.      *
*               + C * A(WORKAREA1)          *  265 BYTE AREA FOR      *
*                   *************************     LOCATE AND LIST     *
*               +10 * A(WORKAREA2)          *  72 BYTE AREA USED AS   *
*                   *************************     REG SAVEAREA        *
*                                                                     *
*    OPTIONS IS A 1 BYTE FIELD THAT COULD CONTAIN ANY COMBINATION     *
*    OF THE FOLLOWING BIT DEFINITIONS.                                *
*                                                                     *
*              X'01'-LOWEST LEVEL QUALIFIERS ARE REQUESTED            *
*              X'02'-INDEX NAMES ARE REQUESTED                        *
*              X'04'-VOLIDS ARE REQUESTED                             *
*              X'08'-ALL OTHER VALID ENTRIES ARE REQUESTED            *
*                                                                     *
* OUTPUT --                                                           *
*                                                                     *
*    LIST ENTRIES OF THE FORM SHOWN BELOW DEPENDING ON SELECTED       *
*    OPTION CODES.                                                    *
*                                                                     *
*           OPTION X'01' -   **************                           *
*                            *07* DSNAME  *                           *
*                            **************                           *
*                            / 2/   8     /                           *
*                                                                     *
*                            ************************                 *
*                            *02* GDGNAME *TTR* DATA*                 *
*                            ************************                 *
*                            / 2/   8     / 3 /  4  /                 *
*                                                                     *
*           OPTION X'02' -   *******************                      *
*                            *00* INDEXNAME*TTR*                      *
*                            *******************                      *
*                            / 2/    8     / 3 /                      *
*                                                                     *
*           OPTION X'04'     ***********************************      *
*                            *08* DSNAME *CT*CODE*VOLSER1*SEQ*        *
*                            ***********************************..... *
*                            / 2/    8   / 2/  4 /  6    / 2 /        *
*                                                                     *
*                             CT   -NUMBER OF VOLSERS DESCRIBED       *
*                             CODE -4 BYTE DEVICE CODE                *
*                             VOLSER- A VOLUME ID                     *
*                             SEQ  -SEQUENCE FIELD FOR TAPE DEVICE    *
*                                                                     *
*                            *****************                        *
*                            *01* DSNAME *TTR*                        *
*                            *****************                        *
*                            / 2/   8    / 3 /                        *
*                             TTR POINTS TO VOLUME CONTROL BLOCK      *
*                                                                     *
*           OPTION X'08'     *****************************            *
*                            *04* ALIASNAME*TTR* TRUENAME*            *
*                            *****************************            *
*                            / 2/   8      / 3 /    8    /            *
*                                                                     *
*                            **************************               *
*                            *05* DSNAME *CODE*CVOLSER*               *
*                            **************************               *
*                            / 2/   8    / 4  /   6   /               *
*                                                                     *
*    THE LAST ENTRY IN EVERY LIST WILL BE A LINK ENTRY AS SHOWN       *
*    BELOW. IT MARKS THE END OF THE LIST AND IF THE TTR IS NONZERO    *
*    IT POINTS TO THE NEXT INDEX BLOCK IN THE CURRENT STRUCTURE       *
*    AND THE VOLSER WILL INDICATE THE CVOL IT IS ON.                  *
*                                                                     *
*                            ***************                          *
*                            *FF*TTR*VOLSER*                          *
*                            ***************                          *
*                            / 2/ 3 /   6  /                          *
*                                                                     *
*                                                                     *
* EXTERNAL REFERENCES --                                              *
*                                                                     *
*    IGG0CLCC - OS CATALOG MANAGEMENT                                 *
*                                                                     *
* EXITS, NORMAL --                                                    *
*                                                                     *
*    BR 14 RETURN CODE IN REG 15 SET TO 00.                           *
*                                                                     *
* EXITS, ERROR                                                        *
*    BR 14 WITH A RETURN CODE IN REG 15 AS FOLLOWS                    *
*                                                                     *
*                        RC=04 LOCATE FAILED. THE LOCATE RETURN CODE  *
*                              IS STORED IN THE FIRST WORD OF THE     *
*                              USERS PARAMETER LIST                   *
*                                                                     *
*                        RC=08 ONLY VOLUMES WERE REQUESTED BUT THE    *
*                              DSNAME POINTED TO WAS NOT FULLY        *
*                              QUALIFIED OR IF A TTR WAS SPECIFIED,   *
*                              IT DID NOT POINT TO A VOLUME CONTROL   *
*                              BLOCK.                                 *
*                                                                     *
*                        RC=12 VOLUMES WERE RETURNED BY LOCATE BUT    *
*                              THIS WAS NOT COMPATIBLE WITH THE       *
*                              OPTIONS REQUESTED.                     *
*                                                                     *
* TABLES/WORK AREAS --                                                *
*                                                                     *
*    ONLY THOSE DESCRIBED IN THE INPUT PARM LIST                      *
*                                                                     *
* ATTRIBUTES --                                                       *
*    REENTRANT,READ ONLY,REFRESHABLE                                  *
*                                                                     *
* CHARACTER CODE DEPENDENCY -- NONE                                   *
*                                                                     *
* NOTES -- N/A                                                        *
*                                                                     *
* REGISTER USAGE                                                      *
*  R1  POINTS AT ENTRY IN WORK AREA.                                  *
*  R2  POINTS AT CURRENT ENTRY IN BLOCK                               *
*  R4  CONTAINS PARAMETER LIST ADDRESS                                *
*  R11 MAIN BASE REG                                                  *
*  R12 ADDRESS OF CONTROLLER III WORKAREA                             *
*  R15 WILL CONTAIN RETURN CODE                                       *
***********************************************************************
      EJECT
CIR      SAVE  (14,12),,*
         L     R2,ACIRSAVE(R1)     GET ADDR OF SAVEAREA FROM PARM LIST
         ST    R2,FORWARD(R13)     ESTABLISH FORWARD CHAIN
         ST    R13,BACKWARD(R2)    ESTABLISH BACKWARD CHAIN
         LR    R13,R2              NEW SAVEAREA
         LR    R4,R1               COPY PARAMETER LIST ADDRESS.
         L     R5,CIROPT(R4)       SAVE OPTION BITS
         TM    CIRSRCH(R4),HIGHBIT TEST FOR TTR ADDRESS OR NAME
         BO    TTRADD              TTR WAS SPECIFIED.
         MVC   CIROPT(L4,R4),CAM1  SET CAMLST OPTIONS TO NAME
         B     LOCATE        GO LOCATE
TTRADD   MVC   CIROPT(L4,R4),CAM2  SET CAMLST OPTION TO BLOCK
         NI    CIRSRCH(R4),HEXFF-HIGHBIT TURN OFF TTR ADDRESS INDICATOR
LOCATE   EQU   *
         L     R15,CLCCADDR  R15 = ENTRY POINT OF OS CAT.MGMT.
         BALR  R14,R15       GO DO LOCATE
         LTR   R15,R15             TEST LOCATE RETURN CODE
         BZ    CODE00              SUCCESS, CONTINUE
         C     R15,TWELVERC        TEST FOR RC = 12
         BE    CODE12              OK, INDEX BLOCK READ
ERRCODE  EQU   *
         ST    R15,CIROPT(R4)      SAVE LOCATE CODE IN 1ST WORD OF LIST
         LA    R15,ERR03           SET RC=4 FOR CALLER.
ERREXIT  EQU   *
         L     R13,BACKWARD(R13)   GET CALLERS SAVEAREA
         RETURN (14,12),RC=(15)    RETURN  TO CALLER
*
CODE12   ST    R5,CIROPT(R4)       REPLACE OPTION BITS IN LIST
         TM    CIROPT(R4),ALLOPT-VOLOPT WAS VOLUMES ONLY REQUESTED
         BNZ   CODE12A             NO, PROCESS BLOCK
         LA    R15,ERR01           SET ERROR CODE
         B     ERREXIT             GO EXIT WITH ERROR
CODE12A  L     R1,CIRWA(R4)        POINT TO LOCATE WORKAREA
         LR    R7,R1               SAVE BLOCK ADDRESS.
         LH    R6,D0(R1)           GET BYTE COUNT FOR BLOCK
         LA    R6,D0(R1,R6)        POINT AT END OF USED PART OF BLOCK
         LA    R2,FRSTNTRY(R1)     POINT AT FIRST ENTRY
CHKTYPE  EQU   *
         CLI   CNT(R2),INDXNTRY    CHECK FOR INDEX PTR ENTRY
         BE    INDEXPTR            YES, GO
         TM    CIROPT(R4),DSOPT    CHECK FOR DSNAME OPTION SPECIFIED
         BNO   ALLCHK              NO, GO CHECK
         TM    CNT(R2),DSNMNTRY    CHECK FOR DSNAME ENTRY.
         BO    DSENTRY             PROCESS AS A DS
         TM    CNT(R2),MULTIVOL    IS IT A DS PTR WITH SEVERAL VOLUMES
         BNZ   DSENTRY             YES, GO
         CLI   CNT(R2),GDGENTRY    IS IT A GDG PTR
         BE    GDGPTR              YES, GO
         CLI   CNT(R2),VCBENTRY    IS IT A VOL CONTROL BLOCK
         BE    VOLPTR              YES, GO
ALLCHK   EQU   *
         TM    CIROPT(R4),OTHROPT  CHECK FOR OTHER OPTION
         BNO   NEXENTRY            NO, SKIP THIS ENTRY.
         CLI   CNT(R2),ALIAS       IS IT AN ALIAS ENTRY
         BE    ALIASENT            YES, GO
         CLI   CNT(R2),OLDPTR      IS IT AN OLD CVOL PTR
         BE    OLDCVOL             YES, GO
         CLI   CNT(R2),NEWPTR      IS IT A NEW CVOL PTR
         BE    NEWCVOL             YES, GO
         B     NEXENTRY            SKIP TO NEXT ENTRY
*
DSENTRY  TM    CIROPT(R4),VOLOPT   CHECK FOR VOLUME OPTION
         BO    DSENTRY1            YES, GO BUILD ENTRIES WITH VOLUMES
         MVI   CODEOFF(R1),DSNWOVOL DSNAME WITH OUT VOLUMES CODE
         MVC   NAMEOFF(NAMLEN,R1),D0(R2) MOVE NAME TO LIST
         LA    R1,DSLEN(R1)        INCREMENT WORKAREA POINTER
NEXENTRY EQU *
         XR    R3,R3               CLEAR REG FOR INSERT INSTRUCTION
         IC    R3,CNT(R2)          PICK UP HW COUNT
         SLL   R3,ONE              MULTIPLY BY 2 TO MAKE IT BYTES
         LA    R2,CATENTLN(R3,R2)  ADJUST POINTER TO NEXT ENTRY
EOBCHK   EQU   *
         CR    R2,R6               SEE IF END OF BLOCK IS REACHED
         BL    CHKTYPE             IF NOT, PROCESS ANOTHER ENTRY
         MVI   CODEOFF(R1),LINKCODE INDICATE LINK ENTRY
         MVC   NAMEOFF(TTRLEN,R1),ATTROFF(R7) MOVE TTR TO ENTRY
         MVC   VOLSEROF(VOLLEN,R1),VOLOFF(R7) MOVE VOLSER TO ENTRY
         B     NORMEXIT            NORMAL EXIT FROM ROUTINE
DSENTRY1 MVI   CODEOFF(R1),DSNWVOLS INDICATE DSNAME WITH VOLUMES
         MVC   NAMEOFF(NAMLEN,R1),D0(R2) MOVE NAME TO LIST
         LA    R1,DSLEN(R1)        INCREMENT WORKAREA POINTER
         XR    R3,R3               CLEAR FOR INSERT INSTRUCTION
         IC    R3,CNT(R2)          GET HW COUNT
         SLL   R3,ONE              MULTIPLY BY 2 TO MAKE IT BYTES
         BCTR  R3,R0               DECREMENT CNT BY ONE FOR EX
         EX    R3,MOVEVOLS         MOVE VOLUME LIST
         LA    R3,L1(R3)           ADD BACK DECREMENT VALUE
         LA    R2,CATENTLN(R3,R2)  POINT TO NEXT ENTRY IN BLOCK
         LA    R1,L0(R3,R1)        POINT TO NEXT LIST ENTRY LOCATION.
         B     EOBCHK              CHK FOR END OF BLOCK
INDEXPTR CLI   D0(R2),LINKCODE     CHECK FOR LINK ENTRY
         BE    LINKPTR             YES, GO EXIT.
         TM    CIROPT(R4),INDOPT   WAS INDEX INFORMATION REQUESTED
         BO    INDEXGO             YES, GO
         B     NEXENTRY            GET NEXT ENTRY
INDEXGO  MVI   CODEOFF(R1),INDXCODE INDICATE INDEX NAME.
         MVC   NAMEOFF(CNT,R1),D0(R2) MOVE NAME AND TTR TO LIST ENTRY
         LA    R1,INDLEN(R1)       POINT TO NEXT LIST ENTRY
         B     NEXENTRY            GET NEXT ENTRY
NODATA   LR    R1,R2               POINT TO WORKAREA
         LR    R7,R1               SAVE BLK ADDRESS
         LA    R2,FRSTNTRY(R2)     ADJUST R2 POINTER
LINKPTR  MVI   CODEOFF(R1),LINKCODE INDICATE LINK ENTRY
         MVC   NAMEOFF(TTRLEN,R1),NAMLEN(R2) MOVE TTR TO LIST
         MVC   VOLSEROF(VOLLEN,R1),VOLOFF(R7) MOVE VOLSER TO ENTRY
NORMEXIT EQU   *
         L     R13,BACKWARD(R13)   GET CALLERS SAVE AREA ADDRESS
         XR    R15,R15             SET RC=0
         RETURN (14,12),RC=(15)    RETURN TO CALLER
*
VOLPTR   EQU   *
         TM    CIROPT(R4),VOLOPT   SEE IF VOLUMES WERE REQUESTED
         BO    VOLPTR1             YES, GO
         MVI   CODEOFF(R1),DSNWOVOL INDICATE DSNAME WITHOUT VOLUMES
         MVC   NAMEOFF(NAMLEN,R1),D0(R2) MOVE NAME TO LIST
         LA    R1,DSLEN(R1)        INCREMENT WORKAREA POINTER  @YM04820
         B     NEXENTRY            GET NEXT ENTRY              @YM04820
VOLPTR1  MVI   CODEOFF(R1),VCBCODE INDICATE DSNAME AND TTR OF VCB
         MVC   NAMEOFF(CNT,R1),D0(R2) MOVE NAME AND TTR TO LIST
VOLEXIT  LA    R1,VCBLEN(R1)       INCREMENT LIST PTR
         B     NEXENTRY            GET NEXT ENTRY
GDGPTR   MVI   CODEOFF(R1),GDGCODE INDICATE GDG ENTRY IN LIST
         MVC   NAMEOFF(CNT,R1),D0(R2) MOVE NAME AND TTR TO LIST ENTRY
         XR    R3,R3               CLEAR REGISTER FOR INSERT
         IC    R3,CNT(R2)
         MVC   GDGDATA(DATALEN,R1),CATENTLN(R2) PUT FLAGS IN LIST
         LA    R1,GDGLEN(R1)       ADJUST LIST PTR
         SLL   R3,ONE              MULT HW COUNT BY 2-- MAKE IT BYTES
         LA    R2,CATENTLN(R3,R2)  POINT TO NEXT ENTRY IN BLOCK
         B     EOBCHK              CHECK FOR END OF BLOCK
ALIASENT EQU   *
         MVI   CODEOFF(R1),ALIASCDE INDICATE ALIAS ENTRY
         MVC   NAMEOFF(CNT,R1),D0(R2) MOVE ALIAS AND TTR TO LIST.
         XR    R3,R3               CLEAR FOR INSERT CHARA
         IC    R3,CNT(R2)
         MVC   ALIASLEN(NAMLEN,R1),CATENTLN(R2) MOVE TRUE NAME TO LIST
         LA    R1,ALIASLEN+NAMLEN(R1) ADJUST LIST PTR
         SLL   R3,ONE              CONVERT HALFWORDS TO BYTES
         LA    R2,CATENTLN(R3,R2)  POINT TO NEXT ENTRY IN BLOCK
         B     EOBCHK              CHECK FOR END OF BLOCK
OLDCVOL  CLI   D0(R2),INDXCBLK     INDEX CONTROL ENTRY
         BE    NEXENTRY            YES, GO TRY NEXT
         MVI   CODEOFF(R1),CVOLCODE INDICATE CVOL PTR IN LIST ENTRY
         MVC   NAMEOFF(NAMLEN,R1),D0(R2) MOVE NAME TO LIST
         XC    DEVCDEOF(DEVCDELN,R1),DEVCDEOF(R1) ZERO DEVICE CODE
         MVC   CVOLVOL(VOLLEN,R1),CATENTLN(R2) MOVE VOLID TO LIST
         XR    R3,R3               CLEAR FOR INSERT CHARA
         IC    R3,CNT(R2)
CVOLEXIT SLL   R3,ONE              CONVERT HALFWORD COUNT TO BYTES
         LA    R2,CATENTLN(R3,R2)  POINT AT NEXT ENTRY IN BLOCK
         LA    R1,CVOLLEN(R1)      POINT AT NEXT LIST ENTRY
         B     EOBCHK              CHECK FOR END OF BLOCK
NEWCVOL  CLI   D0(R2),INDXCBLK     INDEX CONTROL ENTRY CHECK
         BE    NEXENTRY            GET NEXT ENTRY
         MVI   CODEOFF(R1),CVOLCODE  INDICATE CVOL
         MVC   NAMEOFF(NAMLEN,R1),D0(R2) PUT NAME INTO LIST ENTRY
         MVC   DEVCDEOF(DEVCDELN+VOLLEN,R1),CATENTLN(R2) MOVE DEVICE
*                             CODE AND VOLSER TO LIST ENTRY.
         XR    R3,R3               CLEAR FOR INSERT CHARACTER
         IC    R3,CNT(R2)
         B     CVOLEXIT            EXIT FROM ROUTINE
**********************************************************************
*
*   THIS ROUTINE GETS CONTROL IF A ROUTINE CODE OF ZERO IS PASSED BACK
*   FROM LOCATE.
*
**********************************************************************
CODE00   EQU   *
         L     R2,CIRWA(R4)        PICK UP BLOCK ADDRESS
         CLC   CIROPT(L4,R4),CAM1  WAS THIS A LOCATE BY NAME
         ST    R5,D0(R4)           RESTORE OPTION BYTES
         BE    TESTVCB             YES, BLOCK MUST BE A VCB
         CLI   FRSTNTRY(R2),LINKCODE TEST FOR NO ENTRY
         BE    NODATA              YES, GO TO NODATA RTN
         LA    R3,TWENTY5          GET MINIMUM POSSIBLE BYTE COUNT
         CH    R3,D0(R2)           CHECK AGAINST ACTUAL BYTE COUNT
         BH    TESTVCB             IF COUNT IS LESS THAN MINIMUM, VCB
         TM    CIROPT(R4),VOLPLUS  WAS OTHER THAN VOLUMES REQUESTED
         BNZ   CODE12A             YES, PROCESS AS INDEX BLOCK.
*
*   SINCE NO OTHER OPTIONS WERE REQUESTED, WE MUST ASSUME IT IS A
*   VOLUME CONTROL BLOCK.  THE FOLLOWING CHECKS ARE MADE BASED
*   ON THAT ASSUMPTION. IF NO OPTIONS WERE REQUESTED, IT IS STILL
*   AN ERROR AND IS CAUGHT HERE. EVEN IF IT IS NOT A VCB, SINCE
*   OPTIONS DID NOT INDICATE HE EXPECTED OTHER THAN A VCB AND WE
*   CAN NOT DETERMINE FOR SURE WHAT IT IS, HE WILL GET WHATEVER
*   HE POINTED AT WITH THE TTR HE FURNISHED.
*
TESTVCB  TM    CIROPT(R4),VOLOPT   WAS VOLUMES REQUESTED
         BZ    ERRVCB              NO, PROCESS ERROR
         TM    CIROPT(R4),VOLPLUS  WERE THERE OTHER REQUESTS
         BNZ   ERRVCB              YES, PROCESS AS ERROR.
         B     NORMEXIT            NO, EXIT NORMALLY
ERRVCB   EQU   *
         LA    R15,ERR02           SET RC=12, VOLUME BLK FOUND IN ERROR
         B     ERREXIT             EXIT IN ERROR
         EJECT
CAM1     CAMLST  NAME,1,,3         LOCATE CAMLST
CAM2     CAMLST                    BLOCK,1,2,3
GETMLMDL GETMAIN                   EC,MF=L
FREEMMDL FREEMAIN                  E,MF=L
EILFS    EQU   *                   END OF LIST FORMS FOR INITCORE
LILFS    EQU   EILFS-GETMLMDL      LENGTH OF LIST FORMS FOR INITCORE
MOVE     MVC   D0(L0,R7),D0(R3)    MVC INSTRUCTION FOR MOVES
MOVEVOLS MVC   D0(L0,R1),TWELVE(R2) USED FOR EXECUTE
RC0      EQU   *                   RETURN CODE 0
ZERO     DC    F'0'                VALUE OF 0
RC4      EQU   *                   RETURN CODE 4
FOUR     DC    F'4'                VALUE OF 4
RC8      DC    F'8'                RETURN CODE 8
RC12     EQU   *                   RETURN CODE 12
TWELVERC DC    F'12'               TWELVE FOR RC TEST
RECORD   DC    C'IGG0CLCA',C'IGG0CLCB',8X'00'  RECORD AREA FOR SETRP
FOXMASK  DC    X'FFFFFFFF'         MASK TO COMPLEMENT GENERATION NUMBER
CLCCADDR DC    V(IGG0CLCC)   ADDRESS OF OS CATLG.MGMT.
         EJECT
WORKCORE DSECT
STRTDSCT EQU   *                   START OF DSECT
SAVE     DS    28F                 SAVE AREA
GETML    GETMAIN EC,MF=L
FREEML   FREEMAIN E,MF=L
USRNODEL DS    H                   LENGTH OF USERID OR NODE
USERNODE DS    CL44                USERID OR NODE IS KEPT HERE
SAVENODE DS    CL44                USERID OR NODE IS SAVED HERE@YM07060
OPTMASK  DS    CL1                 MASK OF USER OPTS SPECIFIED IN CMD.
FIRSTIME DS    CL1                 ALLOCATE FIRST TIME  SWITCH
FIRSTCIR DS    CL1                 FIRST TIME SWITCH FOR CIRROUT
TOOSMALL DS    CL1           WORKAREA TOO SMALL SWITCH
OLDKEY   DS    CL1           KEY SAVE AREA FOR MODESET MACRO
KEYTYPE  DS    CL1           KEYTYPE SWITCH. 01=USER,00=SVC
SAVER11  DS    F             REGISTER 11 SAVE FOR ESTAE
SAVER12  DS    F             REGISTER 12 SAVE FOR ESTAE
SAVER13  DS    F             REGISTER 13 SAVE FOR ESTAE
ESTAELST DS    4F            ESTAE MACRO LIST FORM
TCBADDR  DS    F             SAVE AREA FOR TCB ADDRESS
OUTADDR  DS    F             ADDRESS OF USER WORKAREA
CURNTBLK DS    F                   PTR TO CURRENT BLOCK FROM CIR.
FRSTBLK  DS    F                   PTR TO FIRST BLOCK IN CHAIN.
         DS    0D
CIRBLOCK DS    4CL280              WORKAREAS FOR CIR--DBLWORD ALIGNED
CIRBLKLN EQU   L'CIRBLOCK          LENGTH OF ONE CIRBLOCK.
*
*
*     PARMLIST FOR CIR RTN    *********
CIRPARM  DS    0F                  BEGIN OF PARMLIST
CIROPTNS DS    1F                  OPTIONS USED
CIRINDX  DS    1F                  ADDR OF INDEXNAMES OR TTR
CIRVOL   DS    1F                  ADDR OF VOLID OF CVOL
CIRWK1   DS    1F                  ADDR OF WORKAREA1
CIRWK2   DS    1F                  ADDR OF WORKAREA2
*
*    END OF CIR PARMLIST
*
*
CIRSAVE  DS    28F                 SAVEAREA FOR CIR PLUS SUBROUTINES
CIRTTR   DS    CL3                 HOLDS TTR OF NEXT BLOCK FOR CIRROUT
CIRCVOL  DS    CL6                 HOLDS CVOL VOLID FOR NEXT BLOCK
PREVBLK  DS    F             USED BY POINTER ROUTINE
GDGCNT   DS    F             GDG COUNT OF GENERATIONS
RETCD    DS    F                   RETURN CODE FOR TMP
TEMPSAVE DS    F                   FOR GETMAIN ADDR, ALIGNING VOL COUNT
ENDDSCT  EQU   *                   END OF WORKCORE DSECT
WORKSIZE EQU   ENDDSCT-STRTDSCT    SIZE OF WORKAREA
         EJECT
         IKJTCB
         EJECT
         IHARB
         EJECT
         IHASDWA
         EJECT
IGG0CLCB CSECT
         DS    0F            FORCE ALIGNMENT FOR PATCH AREA
PATCH    DC    50C'Z'        PATCH AREA
         END
