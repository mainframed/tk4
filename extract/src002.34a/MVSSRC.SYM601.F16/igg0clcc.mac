     TITLE 'IGG0CLCC - INITIALIZATION, LOCATE, RELATIVE GDG, ALIAS'
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IGG0CLCC                                   @YL026UD
*01*  STATUS = 00
*01*  CHANGE-ACTIVITY = NEW FOR RELEASE 21,CHANGED FOR OSVS      Y01113
*                       (AS IGG0CLC0,IGG0CLC1,IGG0CLC2,IECPBLDL)
*                       RENAMED AND CHANGED FOR VS2 RELEASE 2  @YL026UD
* 16 BIT UCB ADDRESS SUPPORT FOR VS2-3                         @Z30AAEH
*A042920-042940                                                 YA00090
* A41320-41400                                                 @Z30AAEH
*          DELETIONS/CHANGES FOR VS2-3.0
*A041920-041940,042960-042980                                   ZA00015
*A199900-1999400,C201000,260800                                @ZA01897
*A197830-197832,198410-198420                                  @ZA02286
*       VS2 037 CHANGES
*A020042-020056,A020066-020179                                 @OZ03161
*A044600                                                       @OZ04613
*A136210-136280,A139810-139880                                 @OZ04937
*A201800                                                       @OZ05600
*A017100-017200,A017900                                        @OZ06685
*A139871-139877                                                @OZ14626
*A192701-192702                                                @OZ14790
*D135600-136200                                                @OZ14792
*A270802                                                       @OZ20755
*C017300,C018200,A017370-018420,A247800-248100                 @OZ30106
*D248840-248867,A248962,A250775-250776                         @OZ30106
*C199200,C199320                                               @OZ31408
*A144320-144380                                                @OZ32573
*A145750,A153220-153280                                        @OZ32593
*C136250,C139840,C195030                                       @OZ33388
*
***********************************************************************
***********************************************************************
*01*  DESCRIPTIVE-NAME = INITIALIZATION, LOCATE,               @YL026UD
* EXTENDED MVS CVOL SUPPORT                                    @Z40CSRC
* SU32  RACF VERSION 2                                         @G32DSFS
*
*
*01*  DESCRIPTIVE-NAME = INITIALIZATION, LOCATE,               @YL026UD
*                        RELATIVE GDG, AND ALIAS               @YL026UD
*01*  FUNCTION = INITIALIZATION                                @YL026UD
*                  1.  ESTABLISHES THE WORKAREA                @YL026UD
*                  2.  CONSTRUCTS THE NAME REFERENCING TABLE   @YL026UD
*                  3.  BRANCHES TO IGC0002H TO OPEN SYSCTLG    @YL026UD
*                  4.  ESTABLISHES RPS WORKAREA FOR NON-LOCATE @YL026UD
*                LOCATE                                        @YL026UD
*                  1.  LOCATES THE HIGH LEVEL NAME             @YL026UD
*                  2.  ENQUES AND DEQUES NECESSARY RESOURCES   @YL026UD
*                  3.  LOCATES BY BLOCK                        @YL026UD
*                  4.  LOCATES THE REMAINING NAME LEVELS       @YL026UD
*                  5.  SETS LOCATE RETURN CODE                 @YL026UD
*                  6.  DEQUES ALL RESOURCES FOR NORMAL LOCATE  @YL026UD
*                  7.  RETURNS VOLUME INFORMATION TO CALLER    @YL026UD
*                      FOR NORMAL LOCATE                       @YL026UD
*                  8.  MAINTAINS A TTR OF THE FIRST DELETABLE  @YL026UD
*                      BLOCK FOR UCATDX OPERATION              @YL026UD
*                RELATIVE GDG AND ALIAS                        @YL026UD
*                  1.  LOCATES RELATIVELY NAMED GENERATION     @YL026UD
*                      DATA SETS                               @YL026UD
*                  2.  BUILDS ALIAS ENTRIES                    @YL026UD
*                  3.  BUILDS CVOL POINTER ENTRIES             @YL026UD
*                  4.  RESOLVES ALIAS NAMES AND RE-ENQUES      @YL026UD
*     FOR AN OVERVIEW OF THIS MODULE AND ITS RELATIONSHIP WITH THE
*     OTHER CATALOG MANAGEMENT MODULES, REFER TO THE CVOL PROCESSOR
*     PLM, Y35-0011.
*01*  NOTES = LABELS REFERED TO IN COMMENTARY ARE ENCLOSED IN SINGLE
*     QUOTES. EQUATED CONSTANTS ARE PREFIXED WITH 'D' OR 'X' WHEN THEY
*     ARE DECIMAL OR HEXADECIMAL RESPECTIVELY; FOR EXAMPLE, D12 EQU 12,
*     AND X12 EQU X'12'. ERROR CODES ARE SET USING 'ERRORXX' AT
*     CORRESPONDING LABELS, 'ERRXX'. BRANCHES ORIGINATE FROM LABELS
*     'IGG0CLCX'. FLAGS ARE LABELED 'FLAGX'.  IO IS DONE FROM EITHER A
*     SUBROUTINE NAMED 'CALLBLDL' OR A SUBROUTINE NAMED 'IO'. ADDRESS
*     CONVERSION IS ACCOMPLISHED IN SUBROUTINES NAMED 'TOABSL' AND
*     'TORLTV'. THESE CONVENTIONS ARE FOLLOWED IN EVERY MODULE WHERE
*     THE EVENT EXISTS.
*02*    DEPENDENCIES = THE OPERATION OF THIS MODULE DEPENDS ON THE
*       COLLATING SEQUENCE OF THE EXTERNAL CHARACTER SET.  A TRANSLATE
*       AND TEST TABLE IS CONSTRUCTED FOR THE EBCDIC CHARACTER SET AND
*       IS ARRANGED SO THAT REDEFINITION OF THE CHARACTER CONSTANTS BY
*       REASSEMBLY WILL RESULT IN A CORRECT TABLE.  THE CONSTANTS IN
*       QUESTION ARE PREFIXED WITH 'CCD', FOR 'CHARACTER CODE
*       DEPENDENT'.
*02*    PERFORMANCE = 1.  AN ENQUEUE SCHEME COMPOSED OF THREE
*                         RESOURCES (HIGH LEVEL NAME, VOLUME INDEX,
*                         AND VICE), WHICH INCREASES THE AVAILABILITY
*                         OF SYSCTLG.
*                     2.  CATALOG MANAGEMENT OPERATES ENABLED.
*                     3.  A TABLE IS CONSTRUCTED FROM THE GIVEN NAME.
*                     4.  THE GIVEN NAME IS CHECKED FOR SYNTAX ERRORS
*                         IN THIS MODULE.
*02*    RESTRICTIONS = ALL DIRECT ACCESS STORAGE DEVICES EXCEPT 2321
*       DATA CELL ARE SUPPORTED BY CATALOG MANAGEMENT.
*02*    REGISTER-CONVENTIONS = REGISTERS ARE LABELED 'R0,R1,...,R15'.
*       REQUIRED ADDITIONAL LABELS ARE EQUATED TO THESE.  REGISTERS
*       COMMON TO ALL MODULES OF CATALOG MANAGEMENT ARE
*       R4  BASE REGISTER FOR THE MODULE.
*       R6  BASE REGISTER FOR THE WORKAREA DSECT.
*       R8  BASE REGISTER FOR THE CAMLSTD DSECT.
*02*    PATCH-LABEL = 'FIXAREA'                                @YL026UD
*01*  MODULE-TYPE = MODULE
*02*    PROCESSOR = ASSEMBLER
*02*    MODULE-SIZE = SEE EXTERNAL SYMBOL DICTIONARY ABOVE
*02*    ATTRIBUTES = REENTERABLE, READ ONLY, ENABLED, SUPERVISORY MODE
*01*  ENTRY = IGG0CLCC                                           Y01113
*02*    PURPOSE = (IGG0CLC0) THIS IS THE FIRST LOAD OF OS CATLG  Y01113
*       PROCESSING. ENTERED TO INITIALIZE THE WORKAREA,          Y01113
*       CERTAIN PARAMETERS, AND OPEN THE APPROPRIATE SYSCTLG.    Y01113
*       (IGG0CLC1) ENTERED FOR 'LNKX', 'BLDA', 'BLOCK', 'NAME' @YL026UD
*       FOR RELATIVELY NAMED GENERATION DATA SETS, AND ANY     @YL026UD
*       REQUEST REQUIRING A LOCATE BY ALIAS NAME.  FOR 'LNKX'  @YL026UD
*       AND 'BLDA', INSURES THAT REQUEST CAN BE PERFORMED ON   @YL026UD
*       STRUCTURE THAT EXISTS IN SYSCTLG.                      @YL026UD
*       (IGG0CLC2) ENTERED FOR EVERY REQUEST TO FINISH THE     @YL026UD
*       LOCATE FUNCTION AND EITHER RETURN TO IGG0CLCA OR       @YL026UD
*       IGG0CLCB OR SET UP FOR THE FOLLOWING LOADS OF CATALOG  @YL026UD
*       MANAGEMENT.                                            @YL026UD
*02*    LINKAGE = BALR 14,15
*02*    INPUT = 1.  R1 -- POINTER TO THE CAMLST (SEE CAMLSTD DSECT FOR
*                         A DESCRIPTION OF THE FIELDS)
*               2.  R12 - POINTER TO CONTROLLER III WORKAREA.  @YL026UD
*                         MUST BE RESTORED AT RETURN.            Y01113
*               3.  R13 - POINTER TO REGISTER SAVEAREA         @YL026UD
*                         (IN CONTROLLER III WORKAREA)         @YL026UD
*02*    OUTPUT = FOR A RETURN TO IGG0CLCA OR IGG0CLCB, THE     @YL026UD
*                OUTPUT CONSISTS OF, WHERE APPROPRIATE,        @YL026UD
*                .  LOCATE RETURN CODES                        @YL026UD
*                .  VOLUME LIST FOR DATA SET                   @YL026UD
*                .  TTR OF DSCB FOR DATA SET                   @YL026UD
*                .  VOLUME IDENTIFICATION OF THE CVOL          @YL026UD
*                   CONTAINING SYSCTLG                         @YL026UD
*                .  DEVICE TYPE OF THE CVOL CONTAINING SYSCTLG @YL026UD
*                .  TTR OF THE NEXT VCB                        @YL026UD
*                THE FORMAT OF THE RETURNED DATA IS DESCRIBED  @YL026UD
*                AT 'RETDATA' IN THE WORKAREA.                 @YL026UD
*02*    EXIT-NORMAL = IGG0CLCD OR IGG0CLCA OR IGG0CLCB         @YL026UD
*02*    EXIT-ERROR = IGG0CLC7                                  @YL026UD
*01*  EXTERNAL-REFERENCES = AS FOLLOWS:
*02*    ROUTINES = IECPBLDL, FREEMAIN, IGC0002H (OPEN/EXTEND),
*         IGG0CL1A (CVOL DYNAMIC ALLOCATION ROUTINE)           @Z40CSRC
*02*    DATA-SETS = SYSCTLG
*02*    DATA-AREA = ALL DATA AREAS ARE DESCRIBED BY DSECTS AT THE END
*       OF THE MODULE
*01*  TABLES = 'NAMTABLE'
*01*  MACROS = ENQ, DEQ, GETMAIN, ESTAE, EXCP, WAIT, RACHECK
*
**** END OF SPECIFICATIONS ***/
         EJECT                                                 @YL026UD
IGG0CLCC CSECT                                                 @YL026UD
*
*      SAVE REGISTERS IN CONTROLLER III WORKAREA               @YL026UD
*      (REGISTER 12 POINTS TO THE WORKAREA)                    @YL026UD
*                                                              @YL026UD
         STM   R14,R12,12(R13)         SAVE REGISTERS 14-12    @YL026UD
         ST    R13,612(R12)            SAVE REGISTER 13        @YL026UD
*                                                              @YL026UD
         BALR  BASE,0                  SET BASE REGISTER       @YL026UD
         USING *,BASE
         B     MODLABEL               BRANCH AROUND MOD LABEL  @YL026UD
         DC    C'IGG0CLCC  '           MODULE IDENTIFIER       @Z40CSRC
         DC    C'&SYSDATE'             COMPILATION DATE        @Z40CSRC
         DC    C'UZ19845'              PTF LEVEL               @OZ33388
MODLABEL DS    0H                      AROUND LABEL            @Z40CSRC
*                                                              #YL026UD
*      OBTAIN ADDRESSES OF THE CVT, CALLER'S TCB, AND          #YL026UD
*      THIS TASK'S SVRB FROM THE CONTROLLER III WORKAREA       #YL026UD
*                                                              #YL026UD
         L     R3,596(R12)             OBTAIN CVT ADDRESS      #YL026UD
         L     R9,600(R12)             OBTAIN CALLER'S TCB     #YL026UD
         L     R5,604(R12)             OBTAIN THIS TASK'S SVRB #YL026UD
*                                                              #YL026UD
         USING CAMLSTD,R1
         USING CVT,R3
         USING SVRBEXTD,R5
         USING UCB,R11
         USING WORKAREA,R6
         USING BLDLAREA,R13
*
         TITLE 'IGG0CLCC - (IGG0CLC0) INITIALIZATION AND LOCATE'
***********************************************************************
*                                                                     *
*     IGG0CLC0 - INITIALIZATION AND LOCATE                            *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLC0 EQU   *
*
*      NECESSARY TO CHECK CALLER'S WORKAREA POINTER?
*
         L     R0,CAMMASK1             GET MASK FOR CAMLST FLAGS
         N     R0,CAMLSTD              NON-LOCATE?
*      R0 IS NOW A TEMPORARY LOCATE SWITCH (IF 0, LOCATE FUNCTION)
         LR    R13,R0
         LR    R14,R1
         BNZ   GETWA                   BRANCH IF YES
         L     R6,CAMPTR3              GET WA PTR AND SET DSECT BASE
*
*      SINCE MODULE IGG0CLCA OR IGG0CLCB HAS BUILT THE         @YL026UD
*      PARAMETER LIST IN PROTECT KEY ZERO, VALIDITY            @YL026UD
*      CHECKING FORMERLY PERFORMED AT THIS POINT IS            @YL026UD
*      NO LONGER REQUIRED.                                     @YL026UD
*
*
GETWA    EQU   *
*
         LR    R8,R14                  ESTABLISH BASE FOR CAMLSTD DSECT
         USING CAMLSTD,R8
         DROP  R1
         LTR   TLOCSW,R13              TEST AND SAVE TEMPORARY LOC SW
         BNZ   CATMAIN                 BRANCH IF NOT LOCATE
*
***********************************************************************
*      FUNCTION LOCATE - GETMAIN FOR BLDLAREA                  @ZA06685
***********************************************************************
         LA    R0,BLDLEND-BLDLAREA     GET LENGTH AND SUBPOOL  @ZA06685
         GETMAIN RC,LV=(0)                                     @OZ30106
         LTR   R15,R15                 WAS GETMAIN SUCCESSFUL? @OZ30106
         BNZ   GETMNERR                BR IF NOT               @OZ30106
         LR    R13,R1                  ESTABLISH BLDLAREA BASE
         B     ZEROWA                  BRANCH TO ZERO WORKAREA @OZ30106
*
***********************************************************************
*      NON-LOCATE FUNCTION - GETMAIN FOR WORKAREA/BLDLAREA     @ZA06685
***********************************************************************
CATMAIN  EQU   *
         LA    R0,WORKEND-WORKAREA     LENGTH AND SUBPOOL NO.
         GETMAIN RC,LV=(0)                                     @OZ30106
         LTR   R15,R15                 WAS GETMAIN SUCCESSFUL? @OZ30106
         BNZ   GETMNERR                BR IF NOT               @OZ30106
         LR    R6,R1                   ESTABLISH WORKAREA BASE
         LA    R13,BLDLAREA-WORKAREA(R6)    ESTABLISH BLDLAREA BASE
         B     ZEROWA                  BR TO ZERO WORKAREA     @OZ30106
*
***********************************************************************
* SET RETURN CODE AND MESSAGE IEC340I - COND. GETMAIN FAILURE @OZ30106*
***********************************************************************
GETMNERR EQU   *
         LA    R1,MSG1                 POINT TO MESSAGE        @OZ30106
         WTO   MF=(E,(1))              WRITE MESSAGE IEF340I   @OZ30106
         SR    R0,R0                   CLEAR FOR RETURN        @OZ30106
         SR    R1,R1                   CLEAR FOR RETURN        @OZ30106
         LTR   TLOCSW,TLOCSW           LOCATE FUNCTION?        @OZ30106
         BNZ   NONLERR                 BR IF NOT               @OZ30106
         LA    R15,ERROR24             LOCATE ERROR 24         @OZ30106
         B     CLCAEXIT                EXIT TO CLCA/CLCB       @OZ30106
NONLERR  EQU   *
         LA    R15,ERROR28             NON-LOCATE ERROR 28     @OZ30106
         B     CLCAEXIT                EXIT TO CLCA/CLCB       @OZ30106
***********************************************************************
*
ZEROWA   EQU   *
*
*      CLEAR WORKAREA (SET ALL FLAGS TO ZERO) AND SAVE POINTER   Y01113
*      TO CATALOG CONTROLLER WORKAREA.                           Y01113
*
         XC    WORKAREA(D256),WORKAREA
         ST    R12,CWAP                SAVE CONTROLLER WA PTR    Y01113
         MVC   VOLSN,588(R12)          OBTAIN SYSCTLG VOLSER   @YL026UD
         LTR   TLOCSW,TLOCSW           TEST TEMPORARY LOCATE SWITCH
         BNZ   ESTAESET                BRANCH IF NOT LOCATE    @YL026UD
*
         OI    FLAG1,LOCATEF           * TURN ON PERMANENT LOCATE SW
*
*      TEMPORARY LOCATE SWITCH NO LONGER NEEDED
*                                                              @YL026UD
*                                                              @YL026UD
ESTAESET EQU   *                                               @YL026UD
*                                                              @YL026UD
*      BUILD ESTAE PARAMETER LIST, ISSUE ESTAE MACRO,          @YL026UD
*      AND SET ESTAE-RELATED FLAGS AND POINTERS TO ZERO        @YL026UD
*                                                              @YL026UD
         LA    R14,D96(R5)             SET SVRB SAVEAREA PTR   @YL026UD
         ST    R14,ESTAER5             SAVE SVRB SAVEAREA PTR  @YL026UD
         ST    R6,ESTAER6              SAVE CATALOG WKA PTR    @YL026UD
         ST    R13,ESTAER13            SAVE BLDL WKA PTR       @YL026UD
         XC    ESTAESVA(40),ESTAESVA  ZERO ESTAE INFO AREA     @ZA03161
         LA    R14,ESTAEPRM            GET ESTAE PARM LIST PTR @YL026UD
         L     R7,ESTAEXIT        LOAD EXIT ADDRESS            @ZA03161
*                                                              @YL026UD
         ESTAE (R7),CT,PARAM=(R14),XCTL=YES,                   @ZA03161*
               RECORD=YES,MF=(E,ESTAELST)                      @YL026UD
*                                                              @YL026UD
         ST    R15,ESTAEFLG            SAVE ESTAE RETURN CODE    YM4836
         LTR   R15,R15                 TEST ESTAE RETURN CODE  @YL026UD
         BZ    SAVESVRB                BRANCH IF OK            @ZA03161
         OI    FLAG2,ESTAEFL      SET ESTAE ERROR FLAG         @ZA03161
         B   ERR28                   SET PERM I/O ERROR        @ZA03161
*
*
SAVESVRB EQU   *                                               @YL026UD
*
         LA    R5,D96(R5)              SET DSECT BASE REG TO SAVE AREA
         ST    R5,SVRBEXTP             SAVE POINTER FOR LATER MODULES
         XC    SVRBEXT,SVRBEXT         ZERO EXTENDED SAVE AREA
*
*      FIND AND STORE IN THE WORKAREA THE ENTRY POINTS TO THE
*      FOLLOWING RESIDENT ROUTINES FOR LATER USE:
*      A)  IECPRLTV  (CONVERTS ABSOLUTE DASD ADDRESS TO RELATIVE)
*      B)  IECPCNVT  (CONVERTS RELATIVE DASD ADDRESS TO ABSOLUTE)
*      C)  IECPBLDL  (USED TO LOCATE LEVEL NAMES)
*
         L     R14,CVTPRLTV            GET ADDRESS
         L     R15,CVTPCNVT
         STM   R14,R15,CONVERTS        STORE IN WORKAREA
*
         LA    R14,IECPBLDL            GET BLDL ENTRY ADDRESS  @YL026UD
         ST    R14,EPBLDL              STORE BLDL ENTRY ADDR   @YL026UD
*
         ST    R6,BLDLISTP             SET LIST POINTER FOR BLDL
*
*      CONSTRUCT 8 BYTES OF FF FOR THIS AND LATER MODULES
*
         MVI   HIBIN,XFF
         MVC   HIBIN+1(L'HIBIN-1),HIBIN  8 BYTES OF FF
*
         TM    CAMOPTN1,CAMBLOCK       IS THIS A LOCATE BY TTR ?
         BO    UCBSRCH                 BRANCH IF YES
*
*      BUILD ENQ/DEQ PARAMETER LIST IN THE SVRB
*      EXTENDED SAVE AREA
*
         MVC   ENQNAME,QNAM            SET UP QNAME
         MVI   ENQPARM,ENDLIST         SET END OF LIST INDICATOR
         MVI   ENQRLEN,L'ENQRNAME      SET RNAME LENGTH
         LA    R14,ENQNAME             ADDRESS OF MAJOR NAME
         LA    R15,ENQRNAME            ADDRESS OF MINOR NAME
         LA    R0,UCBADDR              ADDRESS OF UCB ADDR
         STM   R14,R0,ENQPTRS          PUT INTO PARM LIST
*
*
*      SCAN THE GIVEN NAME AND CONSTRUCT THE NAME TABLE
*      (SEE NAMTABLE IN WORKAREA DSECT FOR NAMES AND DESCRIPTIONS OF
*      THE NAME TABLE CONTENTS)
*
*      NOTE: NAME TABLE WAS ZEROED AT ZEROWA
         XC    TRTABLE,TRTABLE         CLEAR TRT AREA
         MVI   TRTABLE+CCDPERD,CODPERD    PERIOD TRANSLATES TO 4
         MVI   TRTABLE+CCDBLANK,CODBLANK  BLANK TRANSLATES TO 8
         MVI   TRTABLE+CCDLPARN,CODPARN   LEFT PAREN TRANSLATES TO 12
         XR    R1,R1                   CLEAR FOR TRT
*
*
*      SET ONELVLSW AS A FLAG INDICATING A ONE LEVEL OPERATION
*      (BLDA,DLTA,LINKX OR DRPX)
*      IF ONELVLSW IS ZERO, THEN NOT ONE LEVEL OPERATION
*      IF ONELVLSW IS NON-ZERO, THEN ONE LEVEL OPERATION
*
         L     ONELVLSW,ONELVLMK       GET ONE LEVEL BIT MASK
         N     ONELVLSW,CAMLSTD        'AND' WITH CAM LIST OPTIONS
         XR    LEVELCTR,LEVELCTR       SET TO 0
         L     NAMPSAV,CAMPTR1         GET NAME POINTER
*      NOTE: SAVE NAMEPSAV FOR LATER USE AS HINAMP
         LR    LEVELPTR,NAMPSAV        INITIALIZE
         LA    NAMENDP,D44(NAMPSAV)
         LA    DLPTR,NAMLEN1           POINT TO FIRST LEVEL NAME LEN
*      NOTE: FIRST DISPLACEMENT HAS BEEN SET TO 0
*
*
NAMELOOP EQU   *
*
*      SCAN NAME FOR NEXT DELIMITER
*
*      FIRST: A LEVEL NAME MAY NOT BEGIN WITH A NUMBER OR X'FF'
*
         TM    0(LEVELPTR),XFF         IS FIRST BYTE BINARY 0 OR -1?
         BNM   ERR20                   BRANCH IF THE ABOVE
*
*
TRTLEVEL EQU   *
*
         TRT   0(D09,LEVELPTR),TRTABLE SCAN TO NEXT DELIMITER
*      UNDER 9 CHARACTERS IN LEVEL NAME?
         BNZ   LEVELOK                 BRANCH IF YES
*      SCANNED 9 AND NO DELIMITER
         LA    R1,D08(LEVELPTR)        FAKE A GOOD TRT RESULT
         LA    R2,CODBLANK             SET DELIM CODE TO A BLANK
*      9 OR MORE CHARACTERS - DOES THE NAME HAVE MORE THAN 44 CHARS
         CR    R1,NAMENDP              NAME EQUAL 44 BYTES?
         BL    ONELVLCK                BRANCH IF LESS THAN 44
         LR    R1,NAMENDP              SET DELIMITER TO MAX NAME
         B     LEVELOK                 PROCESS LEVEL
*
*
ONELVLCK EQU   *
*
*      IS IT A ONE LEVEL OPERATION?
         LTR   ONELVLSW,ONELVLSW       BLDA,DLTA,LINKX OR DRPX?
         BZ    ERR20                   BRANCH IF NO
*
*
*      IF THIS IS THE FIRST LEVEL, IT IS OK SINCE A DELIMITER IS NOT
*      REQUIRED FOR A ONE LEVEL NAME
*
*      IS THIS THE FIRST LEVEL?
*
*     LEVELCTR NOT UPDATED UNTIL LATER, SO IF FIRST, LEVELCTR IS 0
         LTR   LEVELCTR,LEVELCTR       ZERO?
         BNZ   ERR20                   BRANCH IF NO
*
*
LEVELOK  EQU   *
*
         LR    SAVDELP,R1              SAVE DELIMITER POINTER
         SR    R1,LEVELPTR             CALCULATE LEVEL LENGTH
         BNP   ERR20                   BRANCH IF 0 OR NEG LEN
*      DECREMENT LENGTH BY 1 FOR LATER EXECUTE INSTRUCTIONS
         BCTR  R1,0                    DECREMENT LENGTH BY 1
         STC   R1,0(DLPTR)             SAVE LENGTH IN NAMTABLE
*      INCREMENT NUMBER OF LEVELS GIVEN IN NAME
         LA    LEVELCTR,D01(LEVELCTR)  INCREMENT BY 1
*
*      END OF NAME?
*
         STC   R2,NAMDELIM             SAVE POSSIBLE NAME DELIMITER
         CLI   NAMDELIM,CODPERD        LAST DELIMITER NOT A PERIOD?
         BNE   NAMEND                  BRANCH IF YES
*
*      CALCULATE DISPLACEMENT FOR THE NEXT LEVEL
*
         LA    LEVELPTR,D01(SAVDELP)   POINT TO NEXT LEVEL NAME
         LR    NXTDISP,LEVELPTR
         SR    NXTDISP,NAMPSAV         NXTDISP HAS NEXT DISPLACEMENT
         LA    DLPTR,D01(DLPTR)        POINT TO NEXT LEVEL DISP FIELD
         STC   NXTDISP,0(DLPTR)        SAVE DISPLACEMENT
         STC   NXTDISP,INDEXLEN
         LA    DLPTR,D01(DLPTR)        POINT TO NEXT LEVEL LEN FIELD
         B     NAMELOOP                LOOP THROUGH AGAIN
*
*
NAMEND   EQU   *
*
*      THE SCAN OF THE NAME IS FINISHED
*
         ST    SAVDELP,NAMDELMP        SAVE POINTER TO ENDING DELIM
*      CALCULATE LENGTH OF NAME (MINUS 1 FOR EX INSTRUCTIONS)
         SR    SAVDELP,NAMPSAV         CALCULATE LENGTH
         BCTR  SAVDELP,0               DECREMENT BY 1
         STH   SAVDELP,NAMLEN          SAVE IN WORKAREA
         BCTR  DLPTR,0                 DECREMENT BY 1
         ST    DLPTR,NAMLSTP           SAVE LAST DISPL. POINTER
         STH   LEVELCTR,NAMLG          SAVE LEVEL COUNTER
*
*      IS THIS A ONE LEVEL OPERATION (I.E. BLDA,DLTA,LINK OR DRPX)?
*      IF SO, IS THE GIVEN NAME ONE LEVEL?
*
         LTR   ONELVLSW,ONELVLSW       TEST ONE LEVEL FLAG
         BZ    MOVEHIL                 BRANCH IF NOT ONE LEVEL
*
*      ONE LEVEL OPERATION REQUIRES AN UNQUALIFIED NAME
*
         BCT   LEVELCTR,ERR20          BRANCH IF NO
*
*
MOVEHIL  EQU   *
*
*
*      MOVE HIGH LEVEL NAME INTO HILVLNAM BY PREPARING AND USING
*      AN EXECUTE INSTRUCTION
         XR    HILVLEN,HILVLEN         CLEAR HILVLEN
         IC    HILVLEN,NAMLEN1         GET LENGTH OF HIGH LEVEL NAME
         MVI   HILVLNAM,CCDBLANK       BLANK HILVLNAM
         MVC   HILVLNAM+1(L'HILVLNAM-1),HILVLNAM
         EX    HILVLEN,MOVENAME        MVC   HILVLNAM(0),0(NAMPSAV)
*
*      PUT FIRST LEVEL NAME IN BLDL AND ENQ INPUT PARM LISTS
*
         MVC   NAME,HILVLNAM           FIRST LEVEL NAME
         MVC   ENQRNAM8,HILVLNAM       SET RNAME FOR ENQ
*
*
UCBSRCH  EQU   *
*
*      FIND THE UCB OF THE GIVEN VOLUME                        @YL026UD
*
*      ESTABLISH A BASE FOR THE UCB DSECT                      @YL026UD
*
         L     UCBPTR,CVTSYSAD
*
*
SRCHTAB  EQU   *
*
*      SEARCH THE UCB TABLE LOOKING FOR THE VOLUME SERIAL      @YL026UD
*      CONTAINED IN VOLSN                                      @YL026UD
*
         L     UCBTABP,CVTILK2         GET POINTER TO UCB TABLE
*
*      SET UP LOOP TO RETURN HERE EACH TIME FOR NEXT UCB ENTRY
*
         BALR  BALREG1,0               SET LOOP RETURN
         LH    UCBPTR,0(UCBTABP)       GET NEXT UCB ADDRESS    @Z30AAEH
         LA    UCBTABP,D02(UCBTABP)    POINT TO NEXT UCB ENTRY
         LTR   UCBPTR,UCBPTR           IF 0, NO UCB ENTRY
         BCR   8,BALREG1               REENTER LOOP IF NO
         BP    HAVEUCB                TEST VALID UCB           @Z30AAEH
         N     UCBPTR,FFFF            DROP HIGH ORDER BITS     @Z30AAEH
         C     UCBPTR,FFFF            TEST FOR END OF TABLE    @Z30AAEH
*      TAKE ERROR EXIT IF END OF UCB TABLE AND VOLUME NOT MOUNTED
         BE    ERR04                   TAKE ERROR EXIT         @Z30AAEH
HAVEUCB  TM    UCBSTAT,UCBONLI         TEST IF ONLINE           ZA00015
         BCR   8,BALREG1               OFFLINE, GET NEXT UCB    ZA00015
*
         TM    UCBTBYT3,UCB3DACC       TEST DEVICE CLASS
         BCR   8,BALREG1               REENTER LOOP IF NOT DASD
*
         CLC   SRTEVOLI,VOLSN          COMPARE VOL SER NUMBERS @YL026UD
         BCR   7,BALREG1               GET NEXT UCB
*
         CLC   ZEROVOLS,VOLSN          ALL ZEROES VOLID?        YA00090
         BE    ERR04A                  YES, ERROR 4             YA00090
         TM    UCBFL1,UCBNOTRD         TEST IF READY            ZA00015
         BO    ERR04                   NOTREADY-4,MOUNT         ZA00015
*
*
SAVEVOL  EQU   *
*
         ST    UCBPTR,UCBADDR          PUT UCB ADDRESS IN RNAME
*      NOTE: SAVE UCB ADDRESS IN UCBPTR FOR SVC OPENEXT INSTRUCTION
         TM    CAMOPTN1,CAMBLOCK       LOCATE BY BLOCK?
         BO    OPENGTMN                BRANCH IF YES
*
*      IF FUNCTION IS LOCATE, ENQUEUE SHARE ON THE HIGH LEVEL NAME,
*      OTHERWISE ENQUEUE EXCLUSIVE
*
*      NOTE: RNAME ALREADY SET TO HIGH LEVEL NAME.
*      INITIALIZE FLAGS TO HAVE, EXCLUSIVE, RESERVE            @ZA04613
*                                                                X01965
         MVI   ENQFLAGS,HAVE+RESERVE                           @ZA04613
         TM    FLAG1,LOCATEF           * LOCATE FUNCTION?
         BZ    ENQNAM                  BRANCH IF NOT LOCATE
*
         OI    ENQFLAGS,SHARE          SET ENQ TO SHARE
*
ENQNAM   EQU   *
*
         ENQ   ,MF=(E,(R5))
*
*      INITIALIZE FLAGS FOR VOLUME INDEX ENQUE
         MVI   ENQFLAGS,HAVE+SHARE+SYSTEM
         MVC   ENQRNAM8,QNAM           SET FIRST 8 BYTES OF RNAME
         TM    FLAG1,LOCATEF           * LOCATE?
*      BRANCH IF YES -- ENQFLAGS ARE PROPERLY SET
         BO    ENQVI                   ENQ ON VOLUME INDEX
*
*      TEST AND SET FLAG FOR CATBX
*
         TM    CAMOPTN1,CAMCAT         CATALOG OPERATION?
         BZ    TSTLEVEL                BRANCH IF NO
         TM    CAMOPTN2,CAMBLDX        BLDX OPERATION?
         BZ    TSTLEVEL                BRANCH IF NO
         OI    FLAG1,CATBXF            * TURN FLAG BIT ON
         B     ENQEXCL                 SINCE CATBX ENQ EXCLUSIVE
*
*
TSTLEVEL EQU   *
*
*      HOW MANY LEVELS IN THE NAME?
*
         CLI   NAMLG+1,X02             GREATER THAN 2?
         BH    ENQVI                   BRANCH IF YES & ENQ SHARE
*
*
ENQEXCL  EQU   *
*
*      ENQUE EXCLUSIVE SINCE IT IS UNKNOWN AT THIS POINT WHETHER OR
*      NOT THE VOLUME INDEX WILL BE MODIFIED.  AFTER THE FIRST LEVEL
*      IS LOCATED, ENOUGH INFORMATION IS AVAILABLE TO KNOW IF THE
*      VOLUME INDEX WILL BE MODIFIED.
*
         NI    ENQFLAGS,EXCL           SET FLAG TO EXCLUSIVE
*
*
ENQVI    EQU   *
*
         ENQ   ,MF=(E,(R5))
*
*
OPENGTMN EQU   *
*
*      GET MAIN STORAGE IN SUBPOOL 253 TO BE USED AS AN OPEN   @YL026UD
*      WORKAREA.  OPEN (IGC0002H) WILL BUILD THE DEB AND DCB   @YL026UD
*      IN THIS AREA.                                           @YL026UD
*
*
*      INPUT TO IGC0002H                                       @YL026UD
*        R0  -  SET TO ZERO INDICATES AN OPEN CATALOG REQUEST
*        R1  -  UCB ADDRESS
*        R15 -  ADDRESS OF OPEN WORKAREA
*
*
         L     R0,SPNBYTES             GET SP ID AND SIZE OF WA
         GETMAIN R,LV=(0)
         ST    R1,SVOPNWAP             SAVE WKA PTR (ESTAE)    @YL026UD
*
         USING DCBAREA,R1                                      @YL026UD
         ST    R6,CATWAP               SAVE WORKAREA PTR FOR 2H
         ST    R13,BLDLAP              SAVE BLDLAREA PTR       @YL026UD
         DROP  R1
*
         LR    R15,R1                  PUT OPEN WA PTR INTO R15
         XR    R0,R0                   ZERO R0 TO INDICATE OPEN REQUEST
         LR    R1,UCBPTR               GET UCB ADDRESS         @YL026UD
         L     R2,OPENMOD              GET IGC0002H MOD ADDR   @YL026UD
         BALR  R14,R2                  ISSUE OPEN              @YL026UD
*
*      UPON RETURN:
*        R1  -  CONTAINS DCB ADDRESS
*        R15 -  CONTAINS RETURN CODE
*      THE NUMBER OF BYTES FOR THE DCB/DEB IS IN THE FIRST WORD OF THE
*      DCB/DEB CALLED NMBYTES
*
         LR    R2,R1                   SAVE DCB ADDRESS
         LCR   R1,R15                  CHECK RETURN CODE AND SET SW
         BNZ   IGG0CLC7                BRANCH IF ERROR
         ST    R2,DCBADDR              SAVE DCB ADDRESS
         L     R2,D44(R2)              GET DEB ADDRESS
         ST    R2,DEBADDR              SAVE DEB ADDRESSS
*
*
*****  THE CATALOG IS NOW OPEN
*
*
*      IF LOCATE BY BLOCK, BRANCH TO IGG0CLC1                  @YL026UD
*
         TM    CAMOPTN1,CAMBLOCK       LOCATE BY TTR?
         BO    IGG0CLC1                BRANCH IF YES
*
         MVI   BLDLIST+3,BLDLCON       SET BLDL INPUT CONSTANT (76)
*      NOTE: FIRST LEVEL NAME HAS ALREADY BEEN PUT INTO THE NAME
*      FIELD FOR BLDL
         MVI   TTR+2,REC1              START BLDL SEARCH AT FIRST BLK
         ST    R6,BASESAVE             SAVE CATALOG WA BASE
         STM   R3,R8,SVAREA6           SAVE NECESSARY REGS OVER BLDL
         LM    R15,R1,BLDLPARM         LOAD INPUT PARAMETERS
         BALR  R14,R15                 GO TO BLDL
*
*      OUTPUT FROM BLDL:
*      R15                 CATALOG WA               R1
*      0-ENTRY FOUND       ENTRY STARTING AT NAME   POINT TO ENTRY
*                                                   IN BUFFER
*      4-ENTRY NOT FOUND   UNCHANGED                DESTROYED
*      8-I/O ERROR         UNCHANGED                DESTROYED
*
         L     R6,BASESAVE             RESTORE WA BASE
         LM    R3,R8,SVAREA6           RESTORE REGS
*
*      THE FOLLOWING SHIFT SETS THE CONDITION AS FOLLOWS:
*      IF R15=0,THEN CC=0              RESULT IS ZERO
*      IF R15=4,THEN CC=2              RESULT IS POSITIVE
*      IF R15=8,THEN CC=3              RESULT OVERFLOWS
*
         SLA   R15,D28                 SET CONDITION CODE
*
*      A ZERO 'FOUNDENT' INDICATES NO ENTRY WAS FOUND
*
         BP    ROUTE                   BRANCH IF NOT FOUND
*
         ST    R1,FOUNDENT             SAVE POSSIBLE POINTER TO GIPE
         BO    ERR28                   BRANCH IF ERROR (R15=8)
*
*      WHAT TYPE OF ENTRY FOUND?
*
         CLI   TYPEB,NCVOLTYP          NEW CVOL TYPE?
         BE    TSTDL                   BRANCH IF YES
*
         CLI   TYPEB,OCVOLTYP          OLD CVOL TYPE?
         BNE   SHARETST                BRANCH IF NO
*
*
TSTDL    EQU   *
*
*      TEST FOR DRPX OR LNKX
*
         OI    FLAG2,CVOLF             * INDICATE CVOL ENTRY FOUND
         TM    CAMOPTN2,CAMLNKX        LNKX?
         BO    IGG0CLC1                BRANCH IF YES
         TM    CAMOPTN3,CAMDRPX        DRPX?
         BNO   NEWCAT                  NO, GO GET NEW CATLG    @Z40CSRC
         EJECT
*                                                              @Z40CSRC
*      CHECK FOR A DRPX WITHIN A RACF-DEFINED CATALOG          @Z40CSRC
*                                                              @Z40CSRC
         TM    FLAG5,OCWRACAT          IN A RAC-DEFINED CATLG  @Z40CSRC
         BNO   IGG0CLC2                NO, CONTINUE            @Z40CSRC
         L     R15,RACFADDR            GET ADDR OF RACF RTN    @Z40CSRC
         BALR  R14,R15                 GO CHECK AUTHORIZATION  @Z40CSRC
         LTR   R15,R15                 IS USER UNAUTHORIZED    @Z40CSRC
         BNZ   ERRRACF                 YES, SET UP ERROR EXIT  @Z40CSRC
         B     IGG0CLC2                CONTINUE PROCESSING     @Z40CSRC
         EJECT                                                 @Z40CSRC
NEWCAT   EQU   *                       NOT LNKX OR DRPX        @Z40CSRC
*
**********************************************************************
*   THIS ROUTINE IS ENTERED WHEN A CVOL POINTER ENTRY IS FOUND       *
*   AND THE PRESENT CATALOG IS NOT THE DESIRED ONE.                  *
*      THE FOLLOWING MUST BE DONE:                                   *
*      1) DEQ THE VOLUME INDEX AND HIGH LEVEL NAME                   *
*      2) CLOSE THIS CATALOG                                         *
*      3) CALL IGG0CL1A TO DYNAMICALLY ALLOCATE THE NEW CVOL   @Z40CSRC
**********************************************************************
*      GET VOL SER AND DEVICE TYPE INFORMATION FROM CVOL ENTRY.
*
         XC    DEVTYPE,DEVTYPE         0 DEVICE TYPE AREA
         MVC   VOLSN,DATAB             SAVE VOL SER IF OLD TYPE CVOL
         CLI   TYPEB,OCVOLTYP           OLD TYPE ENTRY?
         BE    DEQVI                   BRANCH IF YES
         MVC   DEVTYPE,DATAB           MOVE DEVICE TYPE CODE FROM ENTRY
         MVC   VOLSN,DATAB+4           MOVE VOL SER
*
DEQVI    EQU   *
*      DEQUEUE THE VOLUME INDEX                                @Z40CSRC
*                                                              @Z40CSRC
         DEQ   ,MF=(E,(R5))            DEQ VOL INDEX           @Z40CSRC
*                                                              @Z40CSRC
*      DEQUEUE THE HIGH LEVEL NAME & 'UN-RESERVE' THE DEVICE   @Z40CSRC
*                                                              @Z40CSRC
         MVC   ENQRNAM8,HILVLNAM       RESTORE NAME            @Z40CSRC
         MVI   ENQFLAGS,HAVE+SYSTEMS   SET DEQ OPTIONS         @Z40CSRC
         DEQ   ,MF=(E,(R5))            DEQ HIGH LEVEL NAME     @Z40CSRC
*                                                              @Z40CSRC
*      FREE DCB/DEB AND CLOSE CATALOG DATA SET.                @Z40CSRC
*                                                              @Z40CSRC
         L     R1,DCBADDR              POINT TO DCB AREA       @Z40CSRC
         USING DCBAREA,R1              DCB AREA ADDRESSABLE    @Z40CSRC
         L     R0,NMBYTES              GET LENGTH TO FREE      @Z40CSRC
         LA    R1,DCBAREA              GET ADDR TO FREE        @Z40CSRC
         XC    SVOPNWAP,SVOPNWAP       CLEAR ESTAE'S PTR       @Z40CSRC
         FREEMAIN R,LV=(0),A=(1)       FREE DCB/DEB STORAGE    @Z40CSRC
         DROP  R1                      ADDRESSABILITY ENDS     @Z40CSRC
         NI    FLAG2,CVOLFC            RESET 'CVPE FOUND' SW   @Z40CSRC
         XC    PTRS,PTRS               CLEAR POINTERS SINCE THEY ARE
*                                      USED AS SWITCHES        @Z40CSRC
*                                                              @Z40CSRC
*     THE FOLLOWING COUNTER PREVENTS INFINITE LOOPING          @Z40CSRC
*     IN A CLOSED CHAIN OF CVOLS                               @Z40CSRC
*                                                              @Z40CSRC
         SR    R2,R2                   CLEAR REG               @Z40CSRC
         IC    R2,CVOLCTR              GET CVOL COUNTER (IS INITIALIZED*
                                       TO ZERO & DECREMENTED TO        *
                                       ZERO AGAIN              @Z40CSRC
         BCT   R2,NOLOOP               DECREMENT & BR IF NOT 0 @Z40CSRC
*
         B     ERR04A                  BEEN THRU 256 CVOL'S    @Z40CSRC
*                                                              @Z40CSRC
NOLOOP   EQU   *                       LESS THAN 256 CVOL'S    @Z40CSRC
*                                                              @Z40CSRC
*     NOT IN A CVOL LOOP                                       @Z40CSRC
*                                                              @Z40CSRC
         STC   R2,CVOLCTR              STORE UPDATE COUNT      @Z40CSRC
*                                                              @Z40CSRC
*     INVOKE IGG0CL1A TO DYNAMICALLY ALLOCATE THE NEW CVOL     @Z40CSRC
*                                                              @Z40CSRC
*        INTERFACE WITH IGG0CL1A --                            @Z40CSRC
*              R12 - ADDRESS OF CONTROLLER III WORK AREA       @Z40CSRC
*              R14 - RETURN ADDRESS                            @Z40CSRC
*              R15 - ENTRY POINT ADDRESS                       @Z40CSRC
*        ALL REGISTERS ARE SAVED AND RESTORED BY IGG0CL1A      @Z40CSRC
*        IN A SAVE AREA IN THE CONTROLLER WORK AREA.           @Z40CSRC
*              R15 - 0 IF SUCCESSFUL, NON-ZERO IF UNSUCCESSFUL @Z40CSRC
*                                                              @Z40CSRC
         L     R12,CWAP                GET WORK AREA ADDR      @Z40CSRC
         USING CC3WA,R12               WORK AREA ADDRESSABLE   @Z40CSRC
         MVC   CC3CVOLS,VOLSN          SET UP CVOL VOLSER      @Z40CSRC
         L     R15,ALLOCRTN            GET ADDR OF ROUTINE     @Z40CSRC
         BALR  R14,R15                 CALL IGG0CL1A           @Z40CSRC
         LTR   R15,R15                 WAS ALLOCATION OK       @Z40CSRC
         BZ    SRCHTAB                 YES, GO FIND UCB        @Z40CSRC
         STC   R15,ERRLOCSV            SAVE ERROR CODE         @Z40CSRC
         B     IGG0CLC7                EXIT TO ERROR ROUTINE   @Z40CSRC
         DROP  R12                     ADDRESSABILITY ENDS     @Z40CSRC
         EJECT
SHARETST EQU   *
*
         TM    ENQFLAGS,SHARE          ENQUED SHARED?
         BZ    DEQTST                  BRANCH IF NO
*
*      VOLUME INDEX NO LONGER NEEDED SINCE FIRST LEVEL FOUND
*
         B     DEQUE                   GO DEQUE & ROUTE          X01965
*
*
DEQTST   EQU   *
*
*      THE VOLUME INDEX WAS ENQUED EXCLUSIVE.  ENOUGH INFORMATION IS
*      NOW AVAILABLE TO CONCLUDE WHETHER THE VOLUME INDEX IS TO BE
*      MODIFIED.   IF THE NUMBER OF LEVELS GIVEN IS ONE OR THE
*      FIRST ENTRY IS A A GIPE, THEN THE VOLUME INDEX MAY NOT
*      BE DEQUEUED SINCE IT WILL BE MODIFIED.
*
         CLI   NAMLG+1,X01             NO. OF LEVELS 1?
         BE    ROUTE                   BRANCH IF YES
*
         CLI   TYPEB,GIPETYP           GIPE?
         BE    ROUTE                   BRANCH IF YES
*                                                                X01965
DEQUE    EQU   *                                                 X01965
*
*      THE VOLUME INDEX WILL NOT BE MODIFIED, SO DEQ
*
         DEQ   ,MF=(E,(R5))
*
*
ROUTE    EQU   *
*
*      ROUTE THE REQUEST TO CLC1 OR CLC2
*
         TM    CAMOPTN2,CAMBLDA+CAMLNKX    BLDA OR LNKX OPERATION?
         BM    IGG0CLC1                BRANCH IF YES
*
*      IF AN ALIAS ENTRY, XCTL TO IGG0CLC1 TO RESOLVE ALIAS NAME AND
*      ENQ ON THE TRUE NAME AND DEQ ON THE ALIAS NAME,
*      UNLESS A DLTA OPERATION, THEN XCTL TO CLC2 AND DO NOT ENQ ON
*      THE ALIAS NAME --- THIS AVOIDS A POTENTIAL ENQ INTERLOCK
*      BETWEEN THE VOLUME INDEX RESOURCE AND THE TRUE NAME RESOURCE
*
         TM    CAMOPTN2,CAMDLTA        DLTA?
         BO    IGG0CLC2                BRANCH IF YES
*
         CLI   TYPEB,ALIASTYP          ALIAS ENTRY?
         BE    IGG0CLC1                BRANCH IF YES
*                                                              @YL026UD
*       BRANCH TO IGG0CLC2 FOR ALL OTHER REQUESTS              @YL026UD
*
         B     IGG0CLC2                                        @YL026UD
         TITLE 'IGG0CLCC - (IGG0CLC1) RELATIVE GDG AND ALIAS'  @YL026UD
***********************************************************************
*                                                                     *
*     IGG0CLC1 - RELATIVE GDG AND ALIAS                               *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLC1 EQU   *
*
         DROP  R3                                              @YL026UD
         DROP  R11                                             @YL026UD
*
         USING WORKAREA,R6             ESTABL BASE FOR WORKAREA
         USING CAMLSTD,R8              ESTABL BASE FOR CAMLST
         USING BLDLAREA,R13            ESTABL BASE FOR BLDL'S WORKAREA
         OI    MODMAP1,MODCLC1         INDIC ENTRY TO IGG0CLC1
*
         TM    CAMOPTN1,CAMBLOCK       LOCATE BY TTR?
         BO    BYBLOCK                 BRANCH IF YES
*
*      IF CONTROL WAS RECEIVED FROM IGG0CLC2, THEN REQUEST IS FOR
*      LOCATING A RELATIVELY NAMED GENERATION DATA SET.
*
         TM    MODMAP1,MODCLC2         CONTROL FROM IGG0CLC2?
         BO    RELGDG                  YES, MUST BE RELATIVE GDS NAME
*
         TM    CAMOPTN2,CAMBLDA        FUNCTION BLDA?
         BO    BLDARTN                 YES, GO TO BUILD ALIAS ROUTINE
*
         TM    CAMOPTN2,CAMLNKX        FUNCTION LNKX?
         BO    LNKXRTN                 YES, GO TO 'LNKXRTN'
*
         CLI   TYPEB,ALIASTYP          ALIAS ENTRY FOUND?
         BE    ALIAS                   YES, GO RESOLVE ALIAS NAME
*
         B     ERR08                   DO NOTHING
*
LNKXRTN  EQU   *
*
*      LNKX FUNCTION (CONNECT CVOL'S)
*
         NC    FOUNDENT,FOUNDENT       WAS AN ENTRY FOUND?
         BNZ   ERR12                   YES, DON'T LNKX
*
*      BUILD THE ENTRY AND PASS CONTROL TO IGG0CLC2.
*
*      ESTABLISH AUXILIARY ADDRESSABILITY TO THE PORTION OF THE
*      WORKAREA IN WHICH THE NEW CVOL POINTER ENTRY WILL BE BUILT.
*
         LA    NEWENTRY,NAME           NEW ENTRY STARTS AT NAME
         USING ENTRY,NEWENTRY          ESTABL BASE FOR ENTRY
         L     POINT,CAMPTR3           DEVICE TYPE & CVOL VOLUME SERIAL
*
*      BUILD THE ENTRY.
*
         MVI   ETYPE,NCVOLTYP          MOVE IN COUNT OF HALF WORDS
         XC    ETTR,ETTR               ZERO THE TTR FIELD
*
*      MOVE IN 4-BYTE DEVICE TYPE AND 6-BYTE VOLUME SERIAL
*
         MVC   EDEVTYP(L'EDEVTYP+L'EVOLID),0(POINT)
         B     IGG0CLC2                BRANCH TO IGG0CLC2      @YL026UD
*
         DROP  NEWENTRY
*
         EJECT
*
BLDARTN  EQU   *
*
         NC    FOUNDENT,FOUNDENT       WAS AN ENTRY FOUND?
         BZ    ERR08                   NO, DON'T BLDA
*
*      BUILD THE ALIAS ENTRY
*
         CLI   TYPEB,IPETYP            IS ENTRY FOUND AN IPE?
         BNE   ERR08                   NOT AN IPE
*
         MVC   TRUE,NAME               MOVE TRUE NAME INTO AE
         L     R3,TTR0                 SAVE THE TTR0
         L     R1,CAMPTR3              POINT TO ALIAS
         TM    0(R1),XFF               IS FIRST BYTE BINARY 0 OR -1?
         BNM   ERR20                   YES, ERROR
*
         MVC   NAME,0(R1)              MOVE IN ALIAS NAME
         LA    R0,X0100                GET TTR TO FIRST BLK
         ST    R0,TTR                  START BLDL AT FIRST BLK
*
*      SEARCH FOR DUPLICATE ALIAS NAME OR GET BLOCK TO BE UPDATED
*
         BAL   BALREG3,CALLBLDL        SEARCH FOR ALIAS
         BZ    ERR12                   BRANCH IF NAME FOUND
*
*      CONSTRUCT ALIAS ENTRY
*
         ST    R3,TTR0                 RESTORE THE TTR0
         MVI   TYPE,ALIASTYP           SET TYPE CODE
         OI    FLAG2,ALIASBLT          * INDIC ALIAS ENTRY IS BUILT
         B     IGG0CLC2                BRANCH TO IGG0CLC2      @YL026UD
*
         EJECT
*
ALIAS    EQU   *
*
*      FIRST LOAD OF LOCATE FOUND AN ALIAS ENTRY.
*
*      1.  TRANSLATE THE ALIAS NAME INTO THE TRUENAME
*      2.  MOVE TRUE QUALIFIED NAME INTO DSNAME AREA PASSED BY USER
*      3.  UPDATE THE NAME TABLE.
*      4.  ENQUEUE THE TRUE HIGH-LEVEL NAME.
*      5.  DEQUEUE THE ALIAS NAME.
*
*
         OI    FLAG2,ALIASSW           FLAG ALIAS ENTRY FOUND  @YL026UD
*                                                              @YL026UD
*      INITIALIZE REGISTERS.
*
         L     R3,CAMPTR1              ALIAS NAME POINTER
         XR    R7,R7                   ZERO R7
         XR    R1,R1                   ZERO R1
*
*      SET UP TRANSLATE TABLE TO SCAN TRUE NAME IN ALIAS ENTRY FOR
*      FIRST BLANK (OR END).
*
         XC    TRTABLE,TRTABLE         CLEAR THE TRANSLATE TABLE
         MVI   TRTABLE+CCDBLANK,CODBLANK BLANK TRANSLATES TO 08
         TRT   TRUEB,TRTABLE           SCAN TRUE NAME
         BNZ   UNDER8                  FOUND A BLANK
*
*      ALL EIGHT CHARACTERS ARE SIGNIFICANT.
*
         LA    R1,D08                  PUT LENGTH IN R1
         B     STRULEN                 GO STORE TRUE NAME LENGTH
*
*
UNDER8   EQU   *
*
*      LESS THAN EIGHT CHARACTERS ARE SIGNIFICANT.
*
         LA    R0,TRUEB                TRUE NAME AS FOUND BY BLDL
         SR    R1,R0                   LENGTH OF TRUE NAME IN R1
*
STRULEN  EQU   *
*
*      SAVE THE LENGTH OF THE TRUE FIRST LEVEL NAME.
*      FIND THE TOTAL LENGTH OF THE GIVEN NAME, OUT TO A LEFT
*      PARENTHESIS IF PRESENT.
*
         LR    TRULEN,R1               SAVE TRUE LENGTH
         LH    R1,NAMLEN               (LENGTH-1) OF FULL NAME
         CLI   NAMDELIM,CODBLANK       LAST DELIMITER A BLANK?
         BE    CHEKLEN                 YES, CHECK LENGTH
*
*      R1 CONTAINS (LENGTH-1) OF GIVEN NAME OUT TO LAST LEVEL, WHICH
*      WHEN RESOLVED WILL REQUIRE 8 CHARACTERS PLUS A DELIMITER.
*
         LA    R1,D09(R1)              SET R1 TO FINAL NAME LENGTH
*
CHEKLEN  EQU   *
*
*      SAVE THE NAME AS GIVEN                                   SA48399
*      BLANK THE GIVEN NAME IN THE USER AREA                    SA48399
*                                                               SA48399
         MVC   RESALIAS,0(R3)          SAVE THE GIVEN NAME      SA48399
         MVI   0(R3),CCDBLANK          SET UP TO BLANK USER NAMESA48399
         LR    R11,R1                  (LENGTH-1) OF FINAL NAME SA48399
         EX    R11,MOVE2               BLANK THE AREA           SA48399
*                                                               SA48399
*      CALCULATE LENGTH OF 'TRUENAME.SECONDLEVEL...LASTLEVEL'
*      LAST LEVEL IS 8 BYTES LONG IF NAME WAS RELATIVE GDG.
*
         IC    R7,NAMLEN1              (LENGTH-1) OF ALIAS
         SR    R1,R7                   SUBTRACT (LENGTH-1) OF ALIAS
*
*      ADD (LENGTH-1) OF TRUE
*
         AR    R1,TRULEN               ADD LENGTH OF TRUE
*
         LA    R0,D44                  MAXIMUM LENGTH
         CR    R1,R0                   IS FINAL RESULT TOO LONG?
         BH    ERR20                   YES                      SA48399
*                                                               SA48399
*      IF NAME IS LESS THAN 44 BYTES THEN MOVE NAME PLUS        SA48399
*      TRAILING BLANK.                                          SA48399
*                                                               SA48399
*      IF NAME IS 44 BYTES LONG THEN MOVE 44 BYTES.             SA48399
*                                                               SA48399
         BL    RECONSTR                GO MOVE NAME +1 BYTE     SA48399
*                                                               SA48399
         BCTR  R1,0                    MINUS 1, NAME IS 44 BYTESSA48399
*                                                               SA48399
RECONSTR EQU   *                                                SA48399
*
*      FINAL RESULT IS AN ALLOWABLE LENGTH
*
*      1.  MOVE IN TRUE FIRST LEVEL NAME.                       SA48399
*      2.  MOVE BACK IN SECOND THRU LAST LEVELS.                SA48399
*
         MVC   0(L'TRUEB,R3),TRUEB     MOVE IN TRUE FIRST LEVEL
         CLC   NAMLG,H01               ONE LEVEL NAME?
         BE    NOLOW                   YES, NO LOW LEVELS TO MOVE
*
         AR    R3,TRULEN               POINT TO FIRST DELIMITER
*
*      OBTAIN (LENGTH-1) OF SECOND THRU LAST LEVELS,
*      INCLUDING FIRST DELIMITER, FOR AN EXECUTE INSTRUCTION
*
         SR    R1,TRULEN               ELIMINATE LENGTH OF FIRST LEVEL
         LA    R11,RESALIAS+1(R7)      POINT TO FRST DELIM IN SVD NAME
         EX    R1,MOVE1                MOVE IN REST OF NAME
*
*      FULLY QUALIFIED TRUE NAME IS SET UP IN USER'S AREA.
*
NOLOW    EQU   *
*
*      UPDATE NAME TABLE IF NECESSARY.
*
         BCTR  TRULEN,0                (LENGTH-1) OF TRUE
         STC   TRULEN,NAMLEN1          SAVE (LENGTH-1) OF FIRST LEVEL
         SR    TRULEN,R7               ARE ALIAS AND TRUE SAME LENGTH?
         BZ    RESOLVED                YES, NAME TABLE IS OK
*
*      ALIAS AND TRUE NAMES DIFFER IN LENGTH.  UPDATE NAME TABLE.
*      TRULEN CONTAINS (TRUE LENGTH) - (ALIAS LENGTH)
*
         XR    R7,R7                   ZERO R7
         LH    R9,NAMLG                SET LOOP COUNTER
         LA    R11,NAMDISP2            POINT TO SECOND DISPLACEMENT
         BCT   R9,NXTLVL               DECR LOOP COUNTER
*
         B     NOLOW2                  NO LOW LEVELS TO UPDATE
*
*
NXTLVL   EQU   *
*
*      CHANGE EACH DISPLACEMENT TO CORRESPOND WITH CHANGE IN LENGTH
*      OF FIRST LEVEL.
*
         IC    R7,0(R11)               GET DISPLACEMENT
         AR    R7,TRULEN               CHANGE IT
         STC   R7,0(R11)               STORE NEW DISPLACEMENT
         LA    R11,D02(R11)            BUMP TO NEXT 'NAMDISP'
         BCT   R9,NXTLVL               LOOP, TO END OF NAME TABLE
*
NOLOW2   EQU   *
*
         L     R11,NAMDELMP            GET 'NAMDELMP'
         AR    R11,TRULEN              CHANGE 'NAMDELMP'
         ST    R11,NAMDELMP            STORE UPDATED POINTERS
         AH    TRULEN,NAMLEN           CHANGE 'NAMLEN'
         STH   TRULEN,NAMLEN           STORE UPDATED LENGTH
*
RESOLVED EQU   *
*
*      NAME AND NAME TABLE ARE UPDATED.
*
*      RE-ENQUEUE
*
         USING SVRBEXTD,R5             ESTABL ADDRBLTY TO SVRB EXT SA
         L     R5,SVRBEXTP             SET BASE
         IC    R7,ENQFLAGS             SAVE FLAG BYTE
         MVI   ENQFLAGS,HAVE+SYSTEMS   INDIC TYPE OF REQUEST     X01965
         TM    FLAG1,LOCATEF           * LOCATE REQUEST?
         BZ    EXCLUSIV                NO
*
         OI    ENQFLAGS,SHARE          INDIC SHARED ENQ
*
EXCLUSIV EQU   *
*
*      ENQUEUE THE TRUE HIGH LEVEL NAME.
*
         MVC   HILVLNAM,TRUEB          SAVE TRUE NAME FOR IGG0CLC2
         MVC   ENQRNAM8,TRUEB          SET RNAME TO TRUE NAME
         ENQ   ,MF=(E,(R5))
         MVC   ENQRNAM8,ALIASNAM       SET RNAME TO ALIAS NAME
         DEQ   ,MF=(E,(R5))
         MVC   ENQRNAM8,ENQNAME        SET RNAME BACK TO SYSCTLG
         STC   R7,ENQFLAGS             RESTORE FLAG BYTE
*
*      ALIAS NAME IS COMPLETELY RESOLVED.
*
*      PASS CONTROL TO IGG0CLC2 FOR THE REMAINDER OF LOCATE.
*
*      IGG0CLC2 WILL RETURN HERE IF RELATIVE NAMING IS USED IN A
*      LATER LEVEL.
*
         B     IGG0CLC2                GO FINISH FUNCTION
         EJECT
*
RELGDG   EQU   *
*
         TM    FLAG1,LOCATEF           IS FUNCTION LOCATE?
         BZ    ERR20                   NO
*
*      THE FUNCTION IS LOCATE A GENERATION DATA SET AND THE
*      NAME GIVEN IS IN RELATIVE FORMAT.
*
*      1.  CONVERT RELATIVE MEMBER TO BINARY - RESULT IS 'QUALIFIER'.
*      2.  READ FIRST BLOCK OF GENERATION DATA SET NAMES.
*
*      IF QUALIFIER IS POSITIVE
*      .   TRANSLATE FIRST NAME TO BINARY.
*      .   ADD THE QUALIFIER.
*      .   BUILD A NEW NAME.
*      .   RETURN.
*
*      IF QUALIFIER IS NEGATIVE OR ZERO
*      .   USE QUALIFIER TO COUNT ENTRIES UNTIL QUALIFIER IS ZERO OR
*          NAMES ARE EXHAUSTED.
*      .   IF QUALIFIER IS ZERO, DESIRED ENTRY IS FOUND.
*          RETURN TO USER WITH ABSOLUTE NAME AND VOLUME LIST.
*      .   IF NAMES ARE EXHAUSTED RETURN TO USER WITH ERRLOC=8.
*
         L     R1,NAMDELMP             POINT TO LEFT PAREN '('
         MVC   RELNUMBR,L'CCDLPARN(R1) GET NEXT 8 CHARACTERS
         LA    R1,RELNUMBR             POINT TO RELATIVE NUMBER
*
AGAIN    EQU   *
*
*      SCAN DIGITS FOR RIGHT PARENTHESIS ')' TO GET LENGTH.
*
         LA    R1,D01(R1)              NEXT DIGIT
         TM    0(R1),XF0               NUMBER?
         BO    AGAIN                   YES
*
*      NOT A NUMBER, MUST BE RIGHT PARENTHESIS ')'
*
         CLI   0(R1),CCDRPARN          ')'?
         BNE   ERR20                   NO
*
         BCTR  R1,0                    LEAST SIGNIFICANT DIGIT
         CLI   RELNUMBR,CCDMINUS       IS FIRST CHARACTER '-'?
         BNE   POS                     NO
*
         MVI   RELNUMBR,CCD0           YES, CHANGE IT TO ZERO
         MVZ   0(L'MINUS,R1),MINUS     MOVE IN A MINUS ZONE
         B     NUMBER                  GO CONVERT IT TO BINARY
*
*
POS      EQU   *
*
         CLI   RELNUMBR,CCDPLUS        IS FIRST CHARACTER '+'?
         BNE   NUMBER                  NO, GO CONVERT IT TO BINARY
*
         MVI   RELNUMBR,CCD0           YES, CHANGE IT TO A ZERO
*
NUMBER   EQU   *
*
         TM    RELNUMBR,XF0            IS FIRST CHARACTER A NUMBER?
         BNO   ERR20                   NO
*
         LA    R2,RELNUMBR             YES, POINT TO IT
         SR    R1,R2                   SUBTRACT FOR LENGTH
         XC    PKDNUMBR,PKDNUMBR       ZERO AREA FOR PACKING
         EX    R1,PACK1                PACK THE RELATIVE NUMBER
         CVB   Q,PKDNUMBR              Q IS QUALIFIER REGISTER
*
*      THE GIPE WAS READ BY BLDL.  THE DATA PORTION IS TWO BYTES
*      DISPLACED FROM ITS NORMAL POSITION IN A CATALOG ENTRY.
*
*                                                              @ZA04937
*    TEST FOR SUPER LOCATE WITH BASE SUPPLIED AND IF SO        @ZA04937
*    SET UP THE SUPPLIED BASE                                  @ZA04937
*                                                              @ZA04937
        TM    CAMOPTN3,X'06'      TEST FOR SLOC WITH BASE      @OZ33388
        BNO   NEWBLOCK             NO SKIP BASE SETUP          @ZA04937
        L     R7,CAMDSCBP          LOAD POINTER TO BASE        @ZA04937
        XC    0(4,R7),MASKFF       MATCH PATTERN IN CATALOG    @ZA04937
*
*      QUALIFIER REGISTER IS THE BINARY EQUIVALENT OF THE GIVEN
*      RELATIVE NUMBER AND IS USED AS
*
*      1.  IF NEGATIVE, AN ENTRY COUNTER WHILE SCANNING THE
*          BLOCKS FOR THE DESIRED ENTRY.
*
*      2.  IF POSITIVE, AN INCREMENT TO ALTER THE FIRST
*          ENTRY IN THE GENERATION DATA GROUP TO PRODUCE A NEW
*          ABSOLUTE NUMBER.
*
*      3.  IF ZERO, AN INDICATOR TO LOCATE THE LATEST DATA SET.
*
*
NEWBLOCK EQU   *
*
*      CALL BLDL TO READ IN THE BLOCK AT TTR
*
         XC    NAME,NAME               ZERO THE NAME
         BAL   BALREG3,CALLBLDL        READ THE BLOCK
*
*      SET UP POINTERS TO INDICATE START OF FIRST ENTRY (POINT)
*      AND END OF LAST ENTRY (LAST).
*
         USING ENTRY,POINT             ESTABL ADDRBLTY TO ENTRY
         LA    POINT,BLDLBUFF+L'INBYTSU   SKIP HALFWORD OF BYTE CNT
         CLI   ETYPE,ICETYP            ICE?
         BNE   NXTENTRY                NO, 'POINT' IS GOOD
         LA    POINT,L'ICE(POINT)      YES, BUMP 'POINT' TO NEXT ENTRY
*
*      DETERMINE WHETHER OR NOT THIS IS THE DESIRED ENTRY.
*
NXTENTRY EQU   *
*
         CLC   ENAME,HIBIN             IS NAME ALL FF'S?
         BE    FFF                     YES
*                                                              @ZA04937
*    TEST FOR SUPERLOCATE WITH BASE                            @ZA04937
*                                                              @ZA04937
         TM    CAMOPTN3,X'06'      TEST FOR SLOC WITH BASE     @OZ33388
         BNO   NSLOC               BR IF NOT                   @ZA04937
         CLC   EGENNO,0(R7)        COMP CATLG GENERATION & BASE
         BL    INCRNXT             BR IF BASE NOT REACHED YET  @ZA04937
         BE    NSLOC               BASE FOUND - BR             @ZA14626
*   THIS CODE ADJUSTS Q WHEN BASE HAS BEEN DELETED
         CVB   R0,PKDNUMBR         BASE DELETED, GET GIVEN Q   @OZ14626
         CR    R0,Q                HAS Q BEEN INCREMENTED?     @OZ14626
         BNE   NSLOC               YES-BR, Q ALREADY ADJUSTED  @OZ14626
         AH    Q,H01               REL GEN 0 DELETED, ADJUST SO WE CAN
*                                  FIND CORRECT (-X) GENERATION@OZ14626
NSLOC    EQU   *                                               @OZ04937
*
         LTR   Q,Q                     IS QUALIFIER NEGATIVE?
         BNM   COMPL                   NO, THIS IS THE DESIRED ENTRY
*
         AH    Q,H01                   YES, INCREMENT QUALIFIER
*
*      INCREMENT POINT TO NEXT ENTRY.
*
INCRNXT  EQU   *                                               @ZA04937
         XR    R2,R2                   ZERO R2
         IC    R2,ETYPE                GET COUNT OF HALFWORDS
         LA    R2,D12(R2,R2)           CALCULATE ENTRY LENGTH
         AR    POINT,R2                INCREMENT POINT
         B     NXTENTRY                GO CHECK
*
*
FFF      EQU   *
*
*      END OF BLOCK, CHECK FOR ANOTHER.
*
         NC    ETTR,ETTR               ANOTHER BLOCK IN CHAIN?
         BZ    NEWGEN                  NO
*
         MVC   TTR,ETTR                YES, GET ITS TTR
         B     NEWBLOCK                GO READ THE BLOCK
*
*
NEWGEN   EQU   *
*
*      NAME WAS NOT FOUND, BUILD ABSOLUTE NAME.
*
         LTR   Q,Q                     IS QUALIFIER POSITIVE?
         BNP   ERR08                   NO
*
         XC    ENAME,ENAME             SET UP FOR BUILD
         MVI   ENAME,CCDG              FIRST CHARACTER IS G
         MVI   ENAME+5,CCDV            SIXTH CHARACTER IS V
         XR    R2,R2                   ZERO R2
         B     ADDQUAL                 GO ADD QUALIFIER REG
*
*
COMPL    EQU   *
*
*      ENTRY AT POINT IS THE DESIRED ENTRY.  TRANSLATE ITS
*      GENERATION NUMBER INTO BINARY FOR ENSUING CALCULATION.
*
         CLI   ENAME,CCDG              FIRST CHAR A 'G'?       @OZ32573
         BNE   ERR12                   BR IF NOT               @OZ32573
         CLI   ENAME+5,CCDV            SIXTH CHAR A 'V'?       @OZ32573
         BNE   ERR12                   BR IF NOT               @OZ32573
         XC    EGENNO,MASKFF           COMPLEMENT GENERATION NUMBER
         LTR   Q,Q                     GENERATING A NEW NAME?
         BZ    MOVE                    NO
*
         PACK  PKDNUMBR,EGENNO         YES, PACK THE NUMBER FOUND
         CVB   R2,PKDNUMBR             CONVERT IT TO BINARY
*
ADDQUAL  EQU   *
*
         AR    R2,Q                    ADD QUALIFIER TO GENERATN NO.
         CVD   R2,PKDNUMBR             CONVERT GENERATN NO. TO DECIMAL
         UNPK  EGENNO,PKDNUMBR         UNPACK GENERATN NO.
         OI    L'EGENNO(POINT),CCD0    ENSURE LO-ORDER DIGIT UNSIGNED
         MVC   L'EGENNO+2(L'ZEROS,POINT),ZEROS SET VERSION NO. TO ZERO
         OI    FLAG4,GDGPLUS           GDG REL. NO. IS PLUS    @OZ32593
*
MOVE     EQU   *
*
         L     R2,NAMDELMP             POINT TO DELIMITER
         MVI   0(R2),CCDPERD           CHANGE '(' TO '.'
         MVC   L'CCDPERD(L'ENAME,R2),ENAME    MOVE NAME TO USER AREA
         MVC   NAME,ENAME              IMITATE BLDL
         LTR   Q,Q                     GENERATING A NEW NAME?
         BP    ERR00                   YES, DONE
*
         CLI   ETYPE,VCBPETYP          VCBPE?
         BNE   ERR00                   NO, GO RETURN
*
         MVC   TTR,ETTR                SET UP TTR FOR BLDL
         XC    NAME,NAME               CLEAR NAME TO READ BLOCK
         BAL   BALREG3,CALLBLDL        READ VCB
         B     ERR00                   GO RETURN
*
         DROP  POINT
*
         EJECT
*
BYBLOCK  EQU   *
*
*      READ THE SPECIFIED BLOCK
*      BLDL PARM AREA WAS PREVIOUSLY SET TO 0 IN IGG0CLC0
*
         L     R2,CAMPTR1              GET POINTER TO TTR
         MVC   TTR,0(R2)               MOVE IN TTR FOR BLDL
         CLI   TTR+2,X00               IS R OF USER TTR 0?
         BE    ERR28                   BRANCH IF YES
*
         BAL   BALREG3,CALLBLDL        READ SPECIFIED BLK
         NC    BLDLECB,BLDLECB         WAS A BLOCK READ?
         BZ    ERR28                   NO, TTR TOO BIG
*
         B     RETURN                  YES, TAKE LOCATE EXIT
*
         EJECT
*
ERR00    EQU   *
*
         MVI   ERRLOCSV,ERROR00        RETURN CODE IS ZERO
*
*      DEQUEUE ALL RESOURCES, RETURN VOLUME LIST, FREEMAIN AND EXIT.
*
         USING SVRBEXTD,R5             ESTABL ADDRBLTY TO SVRB EXT SA
         L     R5,SVRBEXTP             SET BASE
         OI    ENQFLAGS,RESERVE        TURN ON RESERVE           YM5073
         MVC   ENQRNAM8,HILVLNAM       RESTORE HIGH LEVEL NAME
         DEQ   ,MF=(E,(R5))            DEQ NAME & RELEASE DEVICE
*
RETURN   EQU   *
*
         L     R5,SVRBEXTP             SET SVRB EXT POINTER      Y01113
         L     R1,DCBADDR              SET BASE TO DCB/DEB
         USING DCBAREA,R1              ESTABL BASE TO DCB/DEB
         L     R0,NMBYTES              GET SUBPOOL AND NUMBER OF BYTES
         LA    R1,DCBAREA              AREA TO FREE            @YL026UD
         XC    SVOPNWAP(4),SVOPNWAP    RESET WKA PTR (ESTAE)   @YL026UD
         SVC   FREEMAIN                FREE DCB/DEB & CLOSE CATALOG
         L     R12,CWAP                RESTORE CONTROLLER WA PTR Y01113
*
*      MOVE THE APPROPRIATE DATA TO THE CALLER'S AREA.
*
*      IF THE FUNCTION IS LOCATE A GENERATION DATA SET IN ORDER
*      TO ESTABLISH A NEW NAME, ZERO THE CALLER'S AREA.
*
*      IF THE FUNCTION IS LOCATE A BLOCK OR IF A VCBPE WAS FOUND,
*      THEN MOVE THE BLOCK INTO THE CALLER'S AREA.
*
*      IF A DSPE WAS FOUND, THEN MOVE THE VOLUME LIST AND THE DSCBTTR
*      INTO THE CALLER'S AREA.
*
*      THE VOLUME SERIAL AND DEVICE TYPE ARE IN PLACE AT THIS POINT.
*
         TM    FLAG4,GDGPLUS           RELATIVE GDG PLUS?      @OZ32593
         BNO   MOVEDATA                YES, DONT BRANCH        @OZ32593
         XC    WORKAREA(D256),WORKAREA ZERO CALLER'S WORKAREA  @OZ32593
         B     FREE                    GO FREE BLDL WORKAREA   @OZ32593
MOVEDATA EQU   *                                               @OZ32593
         USING ENTRY,POINT             ESTABL ADDRBLTY TO ENTRY
         NC    NAME,NAME               WAS  A BLOCK READ?
         BZ    MOVEBLOK                YES
*
         MVC   RETDSCBT(L'EDSCBTTR),EDSCBTTR  DSCB TTR TO RETURN AREA
         MVI   RETDSCBT+3,X00          ZERO LO-ORDER BYTE
         MVC   RETDATA(L'EVOLIST),EVOLIST   VOLUME LIST TO RETURN AREA
         B     FREE                    GO FREE BLDLS WORKAREA
*
         DROP  POINT
*
*
MOVEBLOK EQU   *
*
         MVC   RETDATA,BLDLBUFF        MOVE BLOCK INTO CALLER'S AREA
*
FREE     EQU   *
*
         LA    R1,0(R13)               POINT TO AREA TO FREE
         LA    R0,BLDLEND-BLDLAREA     GET LENGTH TO FREEMAIN  @YL026UD
*                                      AND 0 HIGH ORDER BYTE
         SVC   FREEMAIN                FREE THE WORKAREA
*
         XR    R15,R15                 SET RETURN CODE         @YL026UD
         B     IGG0CLCA                RETURN TO IGG0CLCA/CLCB @YL026UD
         EJECT
*
****************
*              *
CALLBLDL EQU   *
*              *
****************
*
* FUNCTION:
*    CALLS BLDL TO READ THE BLOCK AT TTR.
*
* INPUT:
*    TTR,BALREG3 IS RETURN REGISTER,BLDLPARM
*
* OUTPUT:
*    BLDLBUFF CONTAINS BLOCK,R15=0
*
* DESTROYED:
*    R0,R1,R2,R10,R11,R12,BALREG1,BASESAVE,SAVEAREA
*
* EXITS:
*         RETURN IF PERMANENT I/O ERROR.
***
         ST    R6,BASESAVE             SAVE THE WORKAREA BASE
         STM   R3,R9,SVAREA7           SAVE REGISTERS
         LM    R15,R1,BLDLPARM         GET PARAMETERS FOR BLDL
         BALR  BALREG1,R15             CALL BLDL
         L     R6,BASESAVE             RESTORE WORKAREA BASE
         LM    R3,R9,SVAREA7           RESTORE REGISTERS
         SLA   R15,D28                 SET CC FROM RETURN CODE
         BCR   14,BALREG3              BR IF NO I/O ERROR
*
*      ELSE FALL THRU TO ERR28
*
         B     ERR28
         TITLE 'IGG0CLCC - (IGG0CLC2) SECOND LOAD OF LOCATE'   @YL026UD
***********************************************************************
*                                                                     *
*     IGG0CLC2 - SECOND LOAD OF LOCATE                                *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLC2 EQU   *
*
         DROP  R1                                              @YL026UD
*
         USING WORKAREA,R6
         USING BLDLAREA,R13
         USING SVRBEXTD,R5
         USING CAMLSTD,R8
         USING UCB,R2
         OI    MODMAP1,MODCLC2         INDIC ENTRY TO IGG0CLC2
*
         TM    CAMOPTN1,CAMUNCAT       UNCATALOG OPERATION?
         BZ    SKIP1                   BRANCH IF NO
         TM    CAMOPTN2,CAMDLTX        DLTX OPERATION?
         BZ    SKIP1                   BRANCH IF NO
         OI    FLAG1,UCATDXF           * TURN FLAG BIT ON
*
*
SKIP1    EQU   *
*
         XR    LEVELCNT,LEVELCNT       INITIALIZE LEVEL COUNT TO ZERO
*      DID 2F FIND AN ENTRY?   YES IF FOUNDENT IS NON-ZERO
         L     R1,FOUNDENT             RESTORE R1 IN CASE OF GIPE
         LTR   R1,R1                   R1 0?
         BZ    EXIT08                  BRANCH IF NO ENTRY FOUND
         LA    TABLEPTR,NAMDISP2       POINT TO 2ND LEVEL NAME DATA
*
*
UCATCHK  EQU   *
*
*    TEST FOR UCATDX FUNCTION
*
         LA    LEVELCNT,D01(LEVELCNT)   INCREMENT LEVELS
*
         TM    FLAG1,UCATDXF           UCATDX OPERATION?
         BZ    ANALTYPE                BRANCH IF NO--ANALYZE TYPE
*
         LR    R10,R1                  SAVE R1 -- MAY POINT TO GIPE
         BAL   BALREG3,UCATDX          BRANCH TO UCATDX UPDATE
         LR    R1,R10                  RESTORE R1
*
*
ANALTYPE EQU   *
*
*      ANALYZE TYPE OF ENTRY FOUND
*
*      LAST ENTRY FOUND CVOL ENTRY OR WAS AN ALIAS ENTRY BUILT IN C1?
         TM    FLAG2,CVOLF+ALIASBLT
         BM    EXIT12                  BRANCH IF YES AND SET CODE
*
         CLI   TYPEB,ALIASTYP          ALIAS ENTRY?
         BE    IPE                     BRANCH IF YES AN TREAT AS IPE
*
         CLI   TYPEB,IPETYP            IPE?
         BE    IPE                     BRANCH IF YES
*
         CLI   TYPEB,GIPETYP           GIPE?
         BE    GIPE                    BRANCH IF YES
*
*      ASSUME ENTRY IS DSPE OR VCBPE
*
         CH    LEVELCNT,NAMLG          ANY MORE LEVELS?
         BL    ERR16                   BRANCH IF YES
*
         TM    FLAG1,LOCATEF           * LOCATE?
         BO    LOCDLOC                 YES, PREPARE TO RETURN  @Z40CSRC
*                                                              @Z40CSRC
*     TEST FOR UNCATLG OR RECATLG IN A RACF-DEFINED CATALOG    @Z40CSRC
*                                                              @Z40CSRC
         TM    FLAG5,OCWRACAT          IS CATLG RACF DEFINED   @Z40CSRC
         BNO   CLC3PREP                NO, GO SET UP FOR CLC3  @Z40CSRC
         TM    CAMOPTN1,CAMUNCAT+CAMRECAT UNCAT OR RECAT       @Z40CSRC
         BZ    CLC3PREP                NO, GO SET UP FOR CLC3  @Z40CSRC
         L     R15,RACFADDR            GET ADDR OF RACF RTN    @Z40CSRC
         BALR  R14,R15                 GO CHECK AUTHORIZATION  @Z40CSRC
         LTR   R15,R15                 IS USER UNAUTHORIZED    @Z40CSRC
         BNZ   ERRRACF                 YES, SET UP ERROR EXIT  @Z40CSRC
         B     CLC3PREP                CONTINUE PROCESSING     @Z40CSRC
*                                                              @Z40CSRC
LOCDLOC  EQU   *                       LOCATE LOCATED          @Z40CSRC
*
         CLI   NAMDELIM,CODPARN        INVALID NAME?
         BE    ERR16                   BRANCH IF YES
*
         CLI   TYPEB,VCBPETYP          VCBPE?
         BNE   FREERES                 BRANCH IF NO
*
*      READ VCB
*
         BAL   BALREG3,READBLK         READ VCB
         B     FREERES                 FREE RESOURES
*
*
IPE      EQU   *
         TM    FLAG2,GDGSW             GDG SWITCH ON?          @OZ14790
         BO    EXIT12                  YES, BR-THIS ENTRY INVAL@OZ14790
*
         CH    LEVELCNT,NAMLG          ANY MORE LEVELS?
         BNL   EXIT12                  BRANCH IF NO
*
*      SAVE ICE TTR OF LEVEL TO BE UPDATED
         MVC   ICETTR,TTR0
*
*
MORELVLS EQU   *
*
         BAL   BALREG1,NEXTLVL         GET NEXT LEVEL FOR BLDL
*
*
FINDNAME EQU   *
*
         BAL   BALREG3,BLDLCALL        FIND THE LEVEL NAME
*
         BC    2,EXIT08                BRANCH IF NAME NOT FOUND
*
         B     UCATCHK                 CHECK IF UCATDX
*
*
GIPE     EQU   *
*                                                              @ZA04937
*    TEST FOR SUPERLOCATE AND SET INFORMATION                  @ZA04937
         TM    CAMOPTN3,X'02'      TEST FOR SUPERLOCATE        @OZ33388
         BZ    NSLOC3              NO BR                       @ZA04937
         L     R1,CAMDSCBP         LOAD POINTER TO WORKAREA    @ZA04937
         LA    R15,NAME+2                                      @ZA04937
         USING ENTRY,R15                                       @ZA04937
         LH    R0,EGCURSIZ         LOAD CURRENT GEN COUNT      @ZA04937
         STH   R0,4(,R1)           STORE IN SLOC WKAREA        @ZA04937
         MVI   6(R1),X'80'         SET GDG FLAG FOR CLCA       @ZA04937
         LTR   R0,R0               TEST FOR EMPTY GDG          @ZA04937
         BNZ   NSLOC3              BR NOT EMPTY                @ZA04937
         OI    6(R1),X'40'         SET EMPTY FLAG              @ZA04937
NSLOC3   EQU   *                                               @ZA04937
*
         OI    FLAG2,GDGSW             TURN ON GDG FLAG
         TM    FLAG1,LOCATEF           * LOCATE FUNCTION?
         BO    CHECKLVL                BRANCH IF YES
*
         TM    FLAG2,ALIASSW           GIPE ALIAS?             @YL026UD
         BO    ERR16                   BRANCH TO ERROR IF YES  @YL026UD
*                                                              @YL026UD
         MVC   OUTDATA,INDATA          SAVE GIPE BLK FOR UPDATE
*      CALCULATE DISPLACEMENT BETWEEN BUFFERS SO GIPE PTR MAY BE
*      ADJUSTED
         LA    R1,OUTDATA-INDATA(R1)   ADJUST POINTER
         ST    R1,FOUNDENT             SAVE POINTER
         BAL   BALREG2,TORLTV          CONVERT GIPE DASD ADDRESS
         ST    R0,WRITETTR             SAVE TTR
*
*      IN CASE OPERATION IS UCATDX, CHANGE TO UNCAT SINCE A GIPE HAS
*      BEEN FOUND
*
         NI    FLAG1,UCATDXFC          TURN OFF IN CASE ON
         XC    DELTTR1,DELTTR1         0, SINCE IT A SWITCH IN C3
*
*
CHECKLVL EQU   *
*
         TM    FLAG2,ALIASSW           GIPE ALIAS?             @YL026UD
         BO    ERR08                   BRANCH TO ERROR IF YES  @YL026UD
*                                                              @YL026UD
         CH    LEVELCNT,NAMLG          ANY MORE LEVELS?         YA00091
         BL    ABSLEVEL                BRANCH IF YES            YA00091
         CLI   NAMDELIM,CODPARN        LAST DELIMITER A LEFT PAREN ?
         BNE   EXIT12                  SET EXIT CODE TO 12     @YL026UD
*      SAVE ICE TTR OF LEVEL TO BE UPDATED                     @ZA02286
         MVC   ICETTR,TTR0                                     @ZA02286
*      SAVE NO. OF LEVELS FOUND IN CASE OF LATER ERROR EXIT OR CATBX
         STH   LEVELCNT,NAMLF                                  @YL026UD
         B     IGG0CLC1                RESOLVE RELATIVE GDG    @YL026UD
*
*
*
ABSLEVEL EQU   *
*      SAVE ICE TTR OF LEVEL TO BE UPDATED                     @ZA02286
         MVC   ICETTR,TTR0                                     @ZA02286
*
*      GET NEXT LEVEL NAME WHICH IS AN ABSOLUTE GDG NAME
*
         BAL   BALREG1,NEXTLVL         GET NEXT LEVEL
*
*      CHECK IF GIVEN ABSOLUTE GENERATION NAME IS IN PROPER FORMAT
         CLI   NAME,CCDG               FIRST CHAR. A 'G' ?
         BNE   ERR08                   BRANCH IF NO            @OZ31408
         CLI   NAME+5,CCDV             SIXTH CHAR. A 'V' ?
         BNE   ERR08                   BRANCH IF NO            @OZ31408
*
*      NAME IS OK - COMPLEMENT THE NUMBER IN THE GENERATION NAME -
*      (I.E. THE X'S OF GXXXXV00)
*
         CLC   GENNO,CCDZERO           IS IT G0000VXX?         @ZA01897
         BE    ERR08B                  YES, BR-INVALID         @ZA01897
         XC    GENNO,MASKFF            NO, COMPLEMENT GEN. NO.
*
*      INDICATE TO CLC6 AN ABSOLUTE GDG NAME
         OI    FLAG3,GDS               SET FLAG
*
         TM    CAMOPTN1,CAMCAT         IS THIS A CAT FUNCTION?
         BZ    FINDNAME                BRANCH IF NO AND SEARCH FOR NAME
*                                                              @Z40CSRC
*      CATALOGING A NEW GDG GENERATION.                        @Z40CSRC
*      THIS REQUIRES AN AUTHORIZATION CHECK IF PERFORMED       @Z40CSRC
*      IN A RACF-DEFINED CATALOG.                              @Z40CSRC
*                                                              @Z40CSRC
         TM    FLAG5,OCWRACAT          IN RACF-DEFINED CATALOG @Z40CSRC
         BNO   NORAC                   NO, SKIP RAC CHECK      @Z40CSRC
         L     R15,RACFADDR            GET ADDR OF RACF RTN    @Z40CSRC
         BALR  R14,R15                 GO CHK AUTHORIZATION    @Z40CSRC
         LTR   R15,R15                 IS USER UNAUTHORIZED    @Z40CSRC
         BNZ   ERRRACF                 YES, SET UP ERROR EXIT  @Z40CSRC
*                                                              @Z40CSRC
NORAC    EQU   *                       NO RACF AUTH FAILURE    @Z40CSRC
*
*      IF THE VERSION NUMBER IS NON-ZERO, THEN THE BLOCK RETURNED
*      BY BLDL MAY NOT BE THE BLOCK TO BE UPDATED (SEE APAR 43345)
*
         CLC   NAME+6(2),CCDZERO       ZERO?                   @ZA01897
         BE    FINDNAME                BRANCH IF YES
*
*      CHANGE THE VERSION NUMBER SO BLDL WILL ALWAYS RETURN THE BLOCK
*      TO BE UPDATED
*
         LH    R9,NAME+6               SAVE VERSION NUMBER
*      NOTE: R9 IS TABLEPTR, SO TABLEPTR IS NOW INVALID
         MVC   NAME+6(2),CCDZERO       SET VERSION NO. TO 0    @ZA05600
         BAL   BALREG3,BLDLCALL        FIND BLK TO BE UPDATED
         STH   R9,NAME+6               RESTORE VERSION NO.
         B     EXIT08                  SET LOCATE CODE TO NOT FOUND
*
*
FREERES  EQU   *
*
         L     R12,CWAP                RESTORE CONTROLLER WA PTR Y01113
         L     R5,SVRBEXTP
         MVC   ENQRNAM8,HILVLNAM       RESTORE HIGH LEVEL NAME
*      DEQUE NAME AND RELEASE ('UN-RESERVE') THE DEVICE
         MVI   ENQFLAGS,HAVE+SYSTEMS   SET FLAGS
*
DEQNAME  EQU   *
*
         DEQ   ,MF=(E,(R5))            DEQ NAME
*
*      FREE DCB/DEB AND CLOSE THE CATALOG
*
         L     R1,DCBADDR              GET POINTER TO DCB/DEB
         USING DCBAREA,R1
         L     R0,NMBYTES              GET NO. OF BYTES TO FREE
*
*      GET THE ADDRESS OF THE AREA TO FREE AND 0 THE HIGH ORDER BYTE
*      TO INDICATE FREEMAIN
         LA    R1,DCBAREA                                      @YL026UD
         XC    SVOPNWAP(4),SVOPNWAP    RESET WKA PTR (ESTAE)   @YL026UD
         SVC   FREEMAIN                FREEMAIN  R,LV=(0),A=(1)
         DROP  R1
*
         CLI   TYPEB,VCBPETYP          VCBPE?
         BNE   DSPE                    BRANCH IF NO
*
         MVC   RETDATA,BLDLBUFF        MOVE BLK INTO USER'S WA
         B     RETURN2                 FREEMAIN AND RETURN TO CALLER
*
*
DSPE     EQU   *
*
*      RETURN DATA TO USER
*
         MVC   RETDSCBT(L'TTR),TTR     RETURN DSCB TTR
         MVI   RETDSCBT+3,X00          0 FOURTH BYTE
         MVC   RETDATA(D62),DATAB      RETURN DATA
*
*
RETURN2  EQU   *
*
*      FREE WORKAREA
*
         LR    R1,R13                  GET POINTER TO AREA TO FREE
         LA    R0,BLDLEND-BLDLAREA     GET LENGTH TO FREEMAIN  @YL026UD
         SVC FREEMAIN                  FREEMAIN R,LV=(0),A=(R13)
*
         XR    R15,R15                 SET RETURN CODE         @YL026UD
         B     IGG0CLCA                RETURN TO IGG0CLCA/CLCB @YL026UD
*
*
EXIT08   EQU   *
*
         MVI   ERRLOCSV,ERROR08        SET ERROR CODE
         B     LOCTEST2                TEST IF LOCATE FUNCTION
*
*
EXIT12   EQU   *
*
         MVI   ERRLOCSV,ERROR12        SET ERROR CODE
*
LOCTEST2 EQU   *
*
         TM    FLAG1,LOCATEF           LOCATE?
         BZ    CLC3PREP                BRANCH IF NO AND PREPARE FOR C3
*
*      NO DSPE OR VCBPE FOUND, LOCATE ERROR -- PREPARE AND BRANCH TO C7
*
         OI    FLAG1,RTNBLK            INDIC TO C7 TO RETURN BLK
*
         CLI   ERRLOCSV,ERROR08        ERROR 8?
         BE    BRANCHC7                BRANCH IF YES TO C7     @YL026UD
*
         BAL   BALREG3,READBLK         READ NEXT BLK FOR ERROR 16
*                                                              @YL026UD
BRANCHC7 EQU   *                                               @YL026UD
*                                                              @YL026UD
         STH   LEVELCNT,NAMLF          SAVE NO. LEVELS FOUND   @YL026UD
         B     IGG0CLC7                BRANCH TO CLC7          @YL026UD
*
*
CLC3PREP EQU   *
*
*      PREPARE FOR IGG0CLC3 AND LATER MODULES
*
*      SAVE THE CCHHR OF THE BLOCK JUST READ. SAVE IT AS A TTR.
*
         BAL   BALREG2,TORLTV          SAVE DASD ADDRESS
         ST    R0,READTTR              SAVE TTR
*
*      CHECK FIRST NAME IN LAST BLOCK READ FOR AN ICE ENTRY
*
         CLI   INENTRY,X00             DOES NAME START WITH 00?
         MVC   ICEPERT,INENTRY+L'INAME   ASSUME YES
         BE    SKIP3                   BRANCH IF YES AND CONTINUE
         OI    FLAG1,READICEF          SET FLAG TO READ ICE IN CLC3
*
SKIP3    EQU   *
*
*      DO INITIAL PREPARATIONS FOR SEVERAL FUNCTIONS
*
*
         TM    FLAG1,CATBXF            * CATBX?
         BZ    UCATDXCK                BRANCH IF NO
*
         CLI   ERRLOCSV,ERROR00        DSPE OR VCBPE FOUND?
         BE    ERR08B                  BRANCH IF YES           @YL026UD
*
         TM    FLAG2,GDGSW             HAS A GIPE BEEN FOUND?
         BO    RELOC                   BRANCH IF YES--'NAME' UPDATED
*
*      PUT LAST LEVEL NAME INTO 'NAME' FOR CATALOG OPERATION
*
*      POINT TO LAST LEVEL DATA IN 'NAMTABLE' FOR SUBROUTINE NEXTLVL
         L     TABLEPTR,NAMLSTP        SET POINTER
         BAL   BALREG1,NEXTLVL         PUT LAST LEVEL NAME INTO 'NAME'
*
*
UCATDXCK EQU   *
*
         TM    FLAG1,UCATDXF           * UCATDX OPERATION?
         BZ    RELOC                   BRANCH IF NO
*
         CLI   ERRLOCSV,ERROR00        LOCATE FIND DSPE OR VCBPE?
         BNE   ERR08B                  BRANCH IF NO            @YL026UD
         MVC   NAME,UCATNAM            INDIC NAME FOR CLC6 TO DELETE
         CLC   UCATICE,ICETTR          TTR'S EQUAL?
         BE    RELOC                   BRANCH IF YES
         OI    FLAG1,READICEF          MUST READ ICE
         MVC   ICETTR,UCATICE          SET TTR TO READ
*
*
RELOC    EQU   *
*
*      RELOCATE THE CCWS TO BE USED BY LATER MODULES.
*
         DROP  R13                     NO LONGER NEEDED--NONLOCATE FUN
         LM    R9,R2,FIRST5            GET 5 CCWS
         AR    R9,R6                   RELOCATE
         AR    R11,R6
         AR    R13,R6
         AR    R15,R6
         AR    R1,R6
         STM   R9,R2,CCWFRST5          STORE INTO WA
         LM    R9,R2,SECOND5           GET NEXT 5 CCWS
         AR    R9,R6                   RELOCATE
         AR    R11,R6
         AR    R13,R6
         AR    R15,R6
         AR    R1,R6
*     RELOCATE 2 CONTIGUOUS TO PREVIOUS 5
         STM   R9,R12,CCWSEC2
         STM   R13,R2,CCWLST3          RELOCATE LAST 3 ELSEWHERE
         LA    R1,SIDE1                GET NEW CHANNEL ADDRESS
         ST    R1,IOBCHPR              UPDATE IOB
*
*      RPS DEVICE?
*
         L     R5,SVRBEXTP             RESTORE FOR CLC2 AND CLC3
         L     R2,UCBADDR              GET UCB ADDRESS
         TM    UCBTBYT2,RPSBIT         RPS BIT ON?
         BZ    IGG0CLC3                BRANCH IF NO
*
*      RPS DEVICE
*
         OI    FLAG2,RPSDEV            TURN ON RPS FLAG
*      GETMAIN FOR RPS SUPPORT.
         LA    R0,RPSEND-RPSD          GET LENGTH AND SP NUMBER
         GETMAIN R,LV=(0)
         ST    R1,SVRPSWAP             SAVE WKA PTR (ESTAE)    @YL026UD
         USING RPSD,R1
         ST    R1,RPSAVEP              SAVE IN WORKAREA
         ST    R1,RPSR1                SAVE IN RPS AREA
         ST    R1,IOBCHPR              UPDATE IOB CHAN PROG POINTER
         LA    R15,THETA               POINT TO THETA IN WA
         ST    R15,RPSPTR              PUT POINTER IN RPS AREA
         MVC   RPSPTR(D01),UCBTBYT4    PUT IN UCB TYPE CODE
         LM    R9,R12,RPSCCWS          GET RPS CCWS
         AR    R9,R6                   RELOCATE
         AR    R11,R6
         STM   R9,R12,RPSCCW           PUT INTO RPS AREA
*      SET UP DD=BLOCKSIZE=256, K=KEYLEN=8, R=RECORD NO. IN RPS AREA
         MVC   RPSDDKR,RPSDDK
         L     R9,CVTPTR               GET POINTER TO CVT
         USING CVT,R9
*      GET POINTER TO SECTOR CONVERT ROUTINE
         MVC   RPSCNVT,CVT0SCR1
         DROP  R9
         DROP  R1
*
         B     IGG0CLC3
         EJECT
*
****************
*              *
UCATDX   EQU   *
*              *
****************
* FUNCTION:
*    TO MAINTAIN A TTR TRAIL OF DELETABLE BLOCKS -- THIS IS DONE BY
*    KEEPING A TTR TO THE FIRST BLOCK TO BE DELETED
*
* INPUT:
*    A DATA BLOCK IN BLDLBUFF
*    RETURN ADDRESS IN BALREG3
*
* OUTPUT:
*    UPDATED TTR FIELD OF DELTTR1
*
*
* DESTROYED:
*    R0,R1,R2,BALREG2,BALREG3,R14,AND R15
*
*
* SUBROUTINES USED:
*         TORLTV
*
****************
****************
*
         USING BLDLAREA,R13
         BAL   BALREG2,TORLTV          CONVERT CCHHR OF BLK TO TTR
*      R0 HAS TTR0 OF BLK AND MUST BE PRESERVED IN SUBROUTINE
*
*      1) THE FIRST LEVEL NAME MAY NOT BE REMOVED OR THE BLK DELETED
*      2) THE SECOND MAY BE REMOVED BUT THE BLK NOT DELETED
*
         CH    LEVELCNT,THREE          FIRST OR SECOND LEVEL?
         BL    NOTDEL                  BRANCH IF YES
*
*      IS THE ONLY ENTRY (BESIDES THE ICE AND ILE) THE FOUND ENTRY?
*      IF SO THE BLOCK IS DELETABLE
*
         XR    R1,R1                   CLEAR
         IC    R1,TYPEB                GET NO. OF HALF WORDS
*
*      2 BYTE LENGTH + ICE(18) + ILE(12)
*      + ENTRY LENGTH BEFORE DATA(12) = 44 BYTES
*
         LA    R1,D44(R1,R1)
*      R1 NOW CONTAINS NO. OF BYTES IN BLK IF FOUND ENTRY THE ONLY ONE
*
         CH    R1,INBYTSU              ONE ENTRY?
         BNE   NOTDEL                  BRANCH IF NO
*
         C     R0,ICETTR               FIRST BLOCK IN CHAIN?
         BE    UPDTTR                  BRANCH IF YES
*
*
NOTDEL   EQU   *
*
*
*      THIS BLOCK IS NOT DELETABLE (MORE THAN ONE ENTRY OR FIRST OR
*      SECOND LEVEL)
*
         ST    R0,WRITETTR             SAVE TTR OF BLK TO BE UPDATED
*      0 DELTTR1 SINCE NO BLKS ARE DELETABLE
         XC    DELTTR1,DELTTR1
         MVC   OUTDATA,INDATA          SAVE BLK TO UPDATED
         MVC   UCATICE,ICETTR          SAVE ICE TTR FOR THIS LEVEL
         MVC   UCATNAM,NAME            SAVE NAME TO BE DELETED
         BR    BALREG3                 RETURN TO CALLER
*
*
UPDTTR   EQU   *
*
*      IF DELTTR1=0, THEN FIRST DELETEABLE BLK, SO UPDATE DELTTR1
*      IF DELTTR1 NOT 0, THEN NOT FIRST DELETEABLE BLK, SO RETURN
*
         NC    DELTTR1,DELTTR1         DELTTR1=0 ?
         BCR   7,BALREG3               RETURN IF NO
         ST    R0,DELTTR1              UPDATE FIRST DELETABLE BLK
         BR    BALREG3                 RETURN
         DROP  R13
         EJECT
*
****************
*              *
READBLK  EQU   *
*              *
****************
*
***FUNCTION:
*    THIS SUBROUTINE READS A BLOCK BY TTR USING BLDL.
*
* INPUT:
*    RETURN ADDRES IN BALREG3
*    TTR AT 'TTR0'
*
* OUTPUT:
*    IF FOUND, THE BLOCK IS AT BLDLBUFF
*
* DESTROYED:
*    REGISTERS R0,R1,R2,R3,R10,R11,R12,R14, AND R15
*    'NAME'
*    'BLDLBUFF'
*
* EXITS:
*
*    EXITS TO CALLBLDL
*
***************
***************
*
         XC    NAME,NAME               0 NAME FOR BLDL
*
*      FALL THROUGH TO 'CALLBLDL'
*
         EJECT
*
****************
*              *
BLDLCALL EQU   *
*              *
****************
* FUNCTION:
*    THIS SUBROUTINE INTERFACES TO BLDL TO SEARCH FOR THE NAME IN
*    'NAME' OR READ A BLOCK SPECIFIED BY A TTR IN 'TTR' WHEN 'NAME'
*    IS 0
*
* INPUT:
*    RETURN ADDRESS IN BALREG3
*    NAME AND TTR SET
*
* OUTPUT:
*    1) CONDITION CODE=0 IF ENTRY IS FOUND
*    2) CONDITION CODE=2 IF ENTRY IS NOT FOUND
*    3) IF THE ENTRY IS FOUND, IT IS PLACED AT NAME AND THE DATA
*      IS IN BLDLBUFF WITH R1 POINTING TO THE ENTRY IN THE BLOCK
*    4) IF THE ENTRY IS NOT FOUND, THE BLOCK IT WOULD GO INTO
*      IS IN BLDLBUFF
* DESTROYED:
*    REGISTERS R0,R1,R2,R3,R10,R11,R12,R14, AND R15 -- BLDLBUFF
*
* EXITS:
*         PERMANENT I/O ERROR, IT WILL BRANCH TO IGG0CLC7      @YL026UD
***************
***************
*
         USING BLDLAREA,R13
         ST    R6,BASESAVE             SAVE THE WA BASE
         STM   R4,R9,SVAREA6           SAVE REGS OVER BLDL
         LM    R15,R1,BLDLPARM         GET BLDL INPUT PARMS
         BALR  R14,R15                 BRANCH TO BLDL
         L     R6,BASESAVE             RESTORE WA BASE
         LM    R4,R9,SVAREA6           RESTORE REGS
*      THE FOLLOWING SHIFT SETS THE CONDITION CODE AS FOLLOWS:
*      IF R15=0, THEN CC=0
*      IF R15=4, THEN CC=2
*      IF R15=8, THEN CC=3             (OVERFLOW)
         SLA   R15,28                  SET CC
         BCR   10,BALREG3              RETURN IF R15=0 OR 4
*
         B     ERR28B                  ERROR EXIT              @YL026UD
         DROP  R13
         EJECT
*
****************
*              *
TORLTV   EQU   *
*              *
****************
*
***FUNCTION:
*    THIS SUBROUTINE CONVERTS THE DATA COUNT, READ BY BLDL, FOR THE
*    CURRENT IN CORE DATA BLOCK AND CONVERTS IT TO A TTR
*
* INPUT:
*    RETURN ADDRESS IN BALREG2
*
* OUTPUT:
*    TTR0 IN REGISTER 0
* DESTROYED:
*    REGISTERS R0,R1,R2,R14 AND R15 -- SAVEAREA,BLDLCHR
*
* SUBROUTINES USED:
*    THE RESIDENT CONVERT ROUTINE -- IECPRLTV
*
***************
***************
*
         USING BLDLAREA,R13
*
*      FIRST MOVE THE DATA COUNT FIELD INTO THE IOB MBBCCHHR
         MVC   BLDLCHR(L'BLDLCHR),BLDLCNT
*      SAVE THE REGS DESTROYED BY CONVERT
         STM   R9,R13,SVAREA5
         L     R1,DEBADDR              GET DEB ADDR
         LA    R2,BLDLMBB              POINT TO MBBCCHHR IN IOB
         L     R15,EPTORLTV            GET ENTRY POINT
         BALR  BALREG1,R15             CONVERT
         LM    R9,R13,SVAREA5          RESTORE MODIFIED REGISTERS
*      THIS ROUTINE ALWAYS GIVES A RETURN CODE OF 0, SO IT IS NOT
*      CHECKED
         BR    BALREG2                 RETURN TO CALLER
         DROP  R13
         EJECT
*
****************
*              *
NEXTLVL  EQU   *
*              *
****************
*
***FUNCTION:
*    THIS SUBROUTINE GETS THE NEXT LEVEL NAME AND PUTS IT INTO
*    THE 'NAME' WORKAREA LOCATION
*
* INPUT:
*    RETURN ADDRESS IN BALREG1
*    REGISTER TABLEPTR (MAINTAINED IN THIS SUBROUTINE) POINTING TO
*    NEXT DISPLACEMENT IN THE NAME TABLE
*
* OUTPUT:
*    NEXT LEVEL IN 'NAME'
*    TABLEPTR INCREMENTED TO NEXT ENTRY
* DESTROYED:
*    REGISTERS R1,R2, AND TABLEPTR
***************
***************
*
         MVI   NAME,CCDBLANK           BLANK NAME
         MVC   NAME+1(L'NAME-1),NAME
         XR    R1,R1                   0 R1
         IC    R1,0(TABLEPTR)          GET LEVEL DISPLACEMENT
         L     R2,CAMPTR1              LOAD POINTER TO NAME
         AR    R2,R1                   R2 NOW POINTS TO PROPER LEVEL
         IC    R1,D01(TABLEPTR)        GET LEVEL LENGTH MINUS ONE
*      MOVE LEVEL NAME INTO 'NAME'
         EX    R1,MOVELVL              MVC   NAME(0),0(R2)
*      INCREMENT TO NEXT LEVEL NAME INFORMATION
         LA    TABLEPTR,D02(TABLEPTR)
         BR    BALREG1                 RETURN
         EJECT
*
ERR04A   EQU   *
*
*      SET SCHEDULER SWITCH SO MOUNT MESSAGE IS NOT ISSUED
         XC    DEVTYPE,DEVTYPE         0 SWITCH
*
*
ERR04    EQU   *
*
         MVI   ERRLOCSV,ERROR04        SET ERROR CODE
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR08    EQU   *
*
         MVI   ERRLOCSV,ERROR08        SET EXIT CODE TO 8      @YL026UD
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR08B   EQU   *                                               @YL026UD
*
*      SAVE NO. OF LEVELS FOUND IN CASE OF LATER ERROR EXIT OR CATBX
         STH   LEVELCNT,NAMLF                                  @YL026UD
         MVI   ERRCATSV,ERROR08        RETURN CODE IS 08       @YL026UD
         B     IGG0CLC7                GO TO XCTL
*
*
ERR12    EQU   *
*
         MVI   ERRLOCSV,ERROR12        RETURN CODE IS 12
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR16    EQU   *
*
*      SAVE NO. OF LEVELS FOUND IN CASE OF LATER ERROR EXIT OR CATBX
         STH   LEVELCNT,NAMLF                                  @YL026UD
         MVI   ERRLOCSV,ERROR16        SET ERROR CODE TO 16
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR20B   EQU   *                                               @YL026UD
*                                                              @YL026UD
*      SAVE NO. OF LEVELS FOUND IN CASE OF LATER ERROR EXIT OR CATBX
         STH   LEVELCNT,NAMLF                                  @YL026UD
*                                                              @YL026UD
ERR20    EQU   *
*
         MVI   ERRLOCSV,ERROR20        SET ERROR CODE TO 20
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
ERR28B   EQU   *                                               @YL026UD
*                                                              @YL026UD
*      SAVE NO. OF LEVELS FOUND IN CASE OF LATER ERROR EXIT OR CATBX
         STH   LEVELCNT,NAMLF                                  @YL026UD
*                                                              @YL026UD
ERR28    EQU   *
*
         MVI   ERRLOCSV,ERROR28        SET ERROR TO 28
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*                                                              @YL026UD
*                                                              @YL026UD
IGG0CLCA EQU   *                                               @YL026UD
*                                                              @YL026UD
*      RETURN TO INTERFACE MAPPER (IGG0CLCA OR IGG0CLCB)       @YL026UD
*                                                              @YL026UD
         LR    R2,R15                  SAVE RETURN CODE        @YL026UD
         LR    R3,R0                   SAVE RETURN CODE        @YL026UD
         LR    R4,R1                   SAVE RETURN CODE        @YL026UD
*                                                              @YL026UD
         ESTAE 0                       RESET ESTAE EXIT        @YL026UD
*                                                              @YL026UD
         LR    R15,R2                  RESTORE RETURN CODE     @YL026UD
         LR    R0,R3                   RESTORE RETURN CODE     @YL026UD
         LR    R1,R4                   RESTORE RETURN CODE     @YL026UD
CLCAEXIT EQU   *                                               @OZ30106
         L     R13,612(R12)            GET CIII SAVEAREA PTR   #YL026UD
         LM    R2,R12,28(R13)          RESTORE REGISTERS 2-12  #YL026UD
         L     R14,12(R13)             RESTORE RETURN REGISTER #YL026UD
         BR    R14                     RETURN TO IGG0CLCA/CLCB #YL026UD
*
*
IGG0CLC3 EQU   *
*
*      SAVE NO. OF LEVELS FOUND IN CASE OF LATER ERROR EXIT OR CATBX
         STH   LEVELCNT,NAMLF                                  @YL026UD
         L     R15,IGG0CLCD            OBTAIN MODULE NAME      @YL026UD
         BALR  R14,R15                 BRANCH TO IGG0CLCD MOD  @YL026UD
*
ERRRACF  EQU   *                       RACF ERROR EXIT         @Z40CSRC
*
IGG0CLC7 EQU   *
*
         L     R15,ERRORMOD            OBTAIN MODULE NAME      @YL026UD
         BALR  R14,R15                 BRANCH TO ERROR MODULE  @YL026UD
*
         TITLE 'IGG0CLCC - (IECPBLDL) FIND/BLDL ROUTINE'       @YL026UD
***********************************************************************
*                                                                     *
*     IECPBLDL - FIND/BLDL ROUTINE                                    *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLCC CSECT
*
IECPBLDL BALR  RGBASE,0                SET BASE REGISTER FOR MODULE
         USING BASE1,RGBASE            ESTABL BASE FOR MODULE
         USING BLDLWKA,RGAREA          ESTABL BASE FOR BLDL WORKAREA
BASE1    L     RGA,EPTOABSL            GET CONVERT ENTRY PT    @YL026UD
         ST    RGA,IECPCNVT            SAVE ADDR IN BLDL WKA   @YL026UD
         SR    RGA,RGA                 ZERO REGISTER
         LA    RGAREA,0(RGAREA)        CLEAR HI-ORDER BYTE
         ST    RGA,ERCODE              ERCODE, C.N., Z TO ZERO
         LR    RGJ,RGDCB               RGJ HAS DCB ADDRESS
BBBB1    LR    RGK,RGADDR              RGK POINTS TO FFLL
         STM   R6,R11,RDAREA           TEMPORARY SAVE
*
***      CONSTRUCT CHANNEL PROGRAM, ECB, AND IOB FOR READING
***      DIRECTORY BLOCKS
*
         LM    R0,R11,CHANPROG         GET AND RELOCATE CHAN PROG
         ALR   R0,RGAREA               CCW1 - SID CCHHR
         ALR   R2,RGAREA               CCW2 - TIC TO CCW1
         AR    R4,RGAREA               CCW3 - RDCNT INTO NEWCNT
         AR    R8,RGAREA               CCW5 - TIC TO CCW3
         AR    R10,RGAREA              CCW6 - RD DATA INTO RDAREA
         STM   R0,R11,CCW              STORE IN BLDAREA WA
         SR    R0,R0                   ZERO ECB
         LA    R2,ECBBLDL              MOVE AND RELOCATE IOB
         LA    R5,CCW
         SR    R8,R8                   ZERO BLK INCR FIELD
         STM   R0,R8,ECBBLDL           ECB AND IOB TO WORKAREA
         MVI   IOBBLDL,X'02'           SET NON-RELATED FLAG
         LM    R6,R11,RDAREA           RESTORE REGISTERS
         LA    RGF,4(RGK)              PT TO NAME ARGUMENT
         AH    R0,0(RGK)               PICK UP NO. OF FIELDS
         BZ    H                       Q. TTR START SUPPLIED
         LR    RGA,RGK                 INIT USERS LIST
BBB1     MVI   14(RGA),0               ZERO R FIELD
         AH    RGA,2(RGK)              GO TO NEXT FIELD IN LIST
         BCT   0,BBB1                  Q. ANOTHER FIELD
         LH    RGG,0(RGK)              GET NO. OF ENTRIES
BB1      SR    R0,R0                   SET TTR START TO ZERO
BB1A     IC    R0,ERCODE+2             INSERT C.N.
         USING IHADCB,RGJ              GET ADDRESSIBILITY FOR DCB
BB2      L     R1,DCBDEBAD             GET DEB ADDRESS
         LA    R2,MBB                  FOR RESULT MBBCCHHR
         LR    R3,RGAREA
         STM   R11,R15,RDAREA          SAVE VOLATILE REGISTERS
         L     R15,IECPCNVT            USE TTR CONVERT ROUTINE @YL026UD
         BALR  R14,R15
         LTR   R15,R15                 WAS USER TTR VALID
         LM    R11,R15,RDAREA-FIRST(R3) RESTORE VOLATILE REGISTERS
         BNZ   BADIO                   BRANCH IF INVALID TTR
         LR    RGH,RGF                 POINT TO FIRST EMPTY ENTRY
         LR    RGI,RGG                 NO. OF ENTRIES REMAINING
         ST    RGJ,IOBBLDL+20          DCB ADDRESS INTO IOB
         A     RGH,SKEH                SEARCH CCW OP
B1       ST    RGH,CCW4                INIT SEARCH
         LR    R2,R15                  SAVE BASE
         EXCP  IOBBLDL
         DROP  RGBASE
         USING BASE1,R2
         WAIT  1,ECB=ECBBLDL
WAITLOOP TM    ECBBLDL,X'60'           CHECK COMPLETE AND ERROR BITS
         BZ    WAITLOOP                Q. NOT YET COMPLETE
         BO    GOODIO                  CONTINUE IF NO ERRORS
BADIO    LA    R15,8                   GET I/O ERROR CODE
         BR    RGRET                   RETURN
GOODIO   EQU   *
         LR    R15,R2                  RESTORE BASE
         DROP  R2
         USING BASE1,RGBASE
* SCAN DIRECTORY BLOCK
         LA    R3,RDAREA               GET INPUT BLOCK ADDR    @YL026UD
         BCTR  R3,0
         AH    R3,RDAREA               SET END ADDR-1
         LA    R1,RDAREA+2             SET START ADDRESS
         LA    R0,31                   SET MASK FOR C BYTE
C        CLC   0(8,R1),0(RGH)          COMPARE NAMES
         BE    D                       Q. FOUND
         BH    G                       Q. NOT IN THIS SECTION
         IC    R2,11(R1)               GET USERS FIELD LENGTH
         NR    R2,R0                   MASK 3 H.O. BITS
         LA    R2,12(R2,R2)            ENTIRE ENTRY LENGTH IN R2
         BXLE  R1,R2,C                 Q. MORE ENTRIES IN BLOCK
         MVC   CCHHR,NEWCNT            SET NEW START
         B     B1
*
D        MVC   8(3,RGH),8(R1)          MOVE TTR
         IC    R4,11(R1)               GET C FROM DIRECTORY
         NR    R4,R0                   MASK 3 H.O. BITS
         LH    R5,2(RGK)               GET USERS LL
         SH    R5,C14
         BM    E1                      Q. LL LESS THAN 14
         BXLE  R4,R4,E
         LR    R4,R5                   USE REG 4
E        EX    R4,BLDLMOVE             MOVE INTO USERS LIST
         MVC   12(1,RGH),ERCODE+3      GET Z
E1       IC    R4,ERCODE+2             GET C.N.
         STC   R4,11(RGH)              C.N. INTO USERS LIST
F        BCT   RGI,F2                  Q. ANOTHER LIST ENTRY
F1       LR    RGI,R15                 SAVE BASE
         DROP  RGBASE
         USING BASE1,RGI
         LH    R15,ERCODE
         BR    RGRET                   BRANCH TO RETURN        @YL026UD
*
         DROP  RGI
         USING BASE1,RGBASE
F2       AH    RGH,2(RGK)              GO TO NEXT ENTRY
         CLI   10(RGH),0               FIND NEXT ZERO R
         BE    C                       Q. EMPTY ENTRY
         B     F                       SEE IF ANOTHER EMPTY ENTRY
*
G        CLI   0(R1),X'FF'             CHECK FOR CONTINUATION POINTER
         BL    G1                      Q. NOT HIGH NAME
         CLC   1(7,R1),0(R1)           MAKE SURE
         BL    G1                      Q. REALLY NOT HIGH NAME
GG1      MVC   FNDLST3,8(R1)           GET TTR0 ON WORD BOUNDARY
         L     R0,FNDLST3
         SH    R0,H256                 DECREMENT R BY 1
         BNM   BB1A                    Q. CONTINUATION POINTER
G1       CLI   ERCODE+1,4
         BE    E1                      Q. PREVIOUS ERROR
         LA    RGF,0(RGH)              POINT TO FIRST EMPTY ENTRY
*                                      ZERO H.O. BYTE
         LR    RGG,RGI                 NO. OF ENTRIES REMAINING
         MVI   ERCODE+1,4              SET ERROR CODE 4
         B     E1
*
H        LA    RGG,R1                  SET FOR ONE ENTRY
         LR    R1,RGF                  MAKE MOVE AT GG1 WORK
         LR    RGH,RGF                 POINT TO ENTRY
         LR    RGI,RGG
         B     GG1
*
         TITLE 'IGG0CLCC - CONSTANT DEFINITIONS'               @YL026UD
*
***********************************************************************
*
* CONSTANTS FOR ALL EXCEPT RACHECK ROUTINE
*
***********************************************************************
         DS    0F
CAMMASK1 DC    X'387F8000'             CHECK ALL BITS USED BY CATALOG
ONELVLMK DC    X'00198000'             CHECK FOR ONE LEVEL OPERATION
FFFF     DC    X'0000FFFF'                                     @Z30AAEH
QNAM     DC    CL8'SYSCTLG '           ENQ NAME
SPNBYTES DS    0F                      PUT ON FULL WORD BOUNDARY
         DC    AL1(253)                SUBPOOL ID
         DC    AL3(AREAEND-DCBAREA)    GET SIZE OF AREA        #YL026UD
ENABLE   DC    X'FF'                   SSM MASK
ZEROVOLS DC    6X'00'                  VOLUME ID                YA00090
MSG1     WTO   'IEC340I - IGG0CLCC, INSUFFICIENT STORAGE FOR THE CATALOX
               G WORKAREA',ROUTCDE=(11),MF=L                   @OZ30106
MOVENAME MVC   HILVLNAM(0),0(NAMPSAV)
MOVELVL  MVC   NAME(0),0(R2)           MOVE LEVEL NAME
H01      DC    H'01'
ZEROS    DC    X'F0F0'
MINUS    DC    X'D0'
MOVE1    MVC   0(0,R3),0(R11)          MOVE SECOND THRU LAST LEVELS
MOVE2    MVC   1(0,R3),0(R3)           BLANK USER NAME AREA
PACK1    PACK  PKDNUMBR,0(0,R2)        PACK THE RELATIVE NUMBER
RPSDDK   DC    X'01000800'             RPS THETA CONVERT CONSTANT
*
BLDLMOVE MVC   13(1,RGH),11(R1)        BLDL MOVE
C14      DC    H'14'
*
RACFADDR DC    A(RACHK)                RACHECK ROUTINE         @Z40CSRC
IGG0CLCD DC    V(IGG0CLCD)                                     @YL026UD
ERRORMOD DC    V(IGG0CLC7)                                     @YL026UD
OPENMOD  DC    V(IGC0002H)                                     @YL026UD
ESTAEXIT DC    V(ESTAEXIT)                                     @YL026UD
ALLOCRTN DC    V(IGG0CL1A)             ALLOCATION ROUTINE      @Z40CSRC
*
         TITLE 'IGG0CLCC - CHANNEL COMMAND WORD DEFINITIONS'   @YL026UD
*
*       CHANNEL COMMAND WORDS
*
*      THE FIRST TWO CCW'S POSITION TO A RECORD
         DS    0F                      ALIGN ON WORD BOUNDARY
FIRST5   EQU   *
CCWSIDE1 EQU   *
         DC    X'31'                  SEARCH ID EQUAL
         DC    AL3(IOBSKADD+3-WORKAREA)    POINT TO IOB CCHHR
         DC    X'4000'                 COMMAND CHAIN ON
         DC    H'5'                    COMPARE 5 BYTES
*
CCWTIC1  EQU   *
         DC    X'08'                   TIC TO SIDE1
         DC    AL3(SIDE1-WORKAREA)     POINT TO CCWSIDE1
*      MUST KEEP THE FOLLOWING 0 SINCE IT IS USED BY CCWSKE AND CCWNOP
         DC    F'0'                    USUALLY ZERO FOR TIC
*
READATA  EQU   *
*
*      USED TO READ VICE, ICE AND FIRST PART OF AN EMPTY BLOCK
*
         DC    X'06'                   READ DATA
*      READS 24 BYTES INTO THE TEMPORARY BUFFER IN THE SAVEAREA
         DC    AL3(TEMPBUFF-WORKAREA)
         DC    X'2000'                 SUPPRESS INCORRECT LENGTH
         DC    H'24'                   READ 24 BYTES
*
CCWRC    EQU   *                       READ COUNT
         DC    X'92'                   MULTI-TRACK OPERATION
         DC    AL3(NEXTCNT-WORKAREA)   POINT TO INPUT BUFFER
         DC    X'4000'                 COMMAND CHAIN ON
         DC    H'8'                    READ 8 BYTES
*
*      THE NEXT FOUR CCW'S ARE USED TO FIND THE NEXT AVAILABLE BLK
*      (HAS 0 KEY) IN THE CATALOG BY DOING A SEQUENTIAL SEARCH FROM
*      THE OLD FIRST AVAILABLE BLOCK.
CCWSKE   EQU   *
         DC    X'29'                  SEARCH KEY EQUAL (TO 0)
         DC    AL3(TIC1+4-WORKAREA)    POINT TO 4 BYTES OF 0
*      COMMAND CHAINING AND SUPPRESS INCORRECT LENGTH
         DC    X'6000'
         DC    H'4'                    COMPARE ONLY FOUR BYTES
*
SECOND5  EQU   *
CCWTIC2  EQU   *
         DC    X'08'                   TIC TO READ COUNT
         DC    AL3(RC-WORKAREA)        POINT TO READ COUNT CCW
         DC    F'0'                    USUALLY ZERO FOR TIC
*
CCWNOP   EQU   *
*
*      AFTER A KEY MATCH AT CCWSKE, THIS CCW IS EXECUTED
*
         DC    X'03'                   CCW NOP
         DC    AL3(TIC1+4-WORKAREA)    SEE REMARK BELOW
         DC    X'2000'                 SUPPRESS INCORRECT LENGTH
         DC    H'4'                    SEE REMARK BELOW
*      THE ABOVE CCW OPCODE IS MODIFIED AND ALSO USED AS A WKD.
*
*      THE NEXT CCW WRITE VERIFIES (I.E. READS WHAT WAS JUST
*      WRITTEN TO CHECK CYCLIC BITS ON THE DEVICE).
*
CCWRKD   EQU   *
         DC    X'0E'                   READ KEY AND DATA
         DC    AL3(OUTPUT-WORKAREA)    POINT TO 'OUTPUT' BUFFER
*      SUPPRESS TRANSFER TO MAIN-STORAGE AND SUPPRESS INCORRECT LENGTH
         DC    X'3000'
         DC    H'264'                  KEY LEN PLUS DATA LEN
*
CCWRD    EQU   *
         DC    X'06'                   READ A DATA BLOCK
         DC    AL3(INPUT-WORKAREA)     READ INTO INPUT BUFFER
         DC    F'256'                  ALL FLAGS OFF AND READ 1 BLOCK
*
CCWWKD   EQU   *
         DC    X'0D'                   WRITE KEY AND DATA
         DC    AL3(OUTPUT-WORKAREA)    WRITE FROM OUTPUT BUFFER
         DC    F'264'                  ALL FLAGS OFF-- WRITE KEY DATA
*
         DS    0F
RPSCCWS  EQU   *
*
CCWSS    EQU   *
         DC    X'23'                   SET SECTOR
         DC    AL3(THETA-WORKAREA)     POINT TO RPS THETA
         DC    X'4000'                 COMMAND CHAINING
         DC    H'1'                    BYTE COUNT 1 FOR THETA
*
CCWTIC3  EQU   *
*
*      TIC TO NORMAL CHANNEL PROGRAM (CCWSIDE1)
*
         DC    X'08'                   TIC CCW
         DC    AL3(CHPROG-WORKAREA)    POINT TO USUAL CCW LIST
         DC    F'0'                    USUALLY ZERO FOR TIC
*
THREE    DC    H'3'                    COMPARE TO LEVELCNT FOR UCATDX
CCDZERO  DC    CL4'0000'                 CHARACTER ZERO        @ZA01897
         EJECT
CHANPROG DS    0F
*CCW1
         DC    X'31'                   SEARCH ID EQUAL
         DC    AL3(0+CCHHR-FIRST)
         DC    X'4000'                 COMMAND CHAIN
         DC    H'5'                    COUNT
*CCW2
         DC    X'08'                   TIC
         DC    AL3(0+CCW1-FIRST)
         DC    F'0'
*CCW3
         DC    X'92'                   RD COUNT, M/T
         DC    AL3(NEWCNT-FIRST)
         DC    X'4000'
         DC    H'8'
*CCW4
SKEH     DC    X'69'                   SEARCH EQUAL HI KEY
         DC    AL3(0)
         DC    X'4000'                 COMMAND CHAIN
         DC    H'8'                    COUNT
*CCW5
         DC    X'08'                   TIC
         DC    AL3(0+CCW3-FIRST)
         DC    F'0'
*CCW6
         DC    X'06'                   READ DATA
         DC    AL3(0+RDAREA-FIRST)
         DC    H'0'
H256     DC    H'256'
*                                                              @YL026UD
*                                                              @YL026UD
*      MODULE PATCH AREA (MAINTENANCE AREA)                    @YL026UD
*                                                              @YL026UD
         DS    0H
FIXAREA  DC    100C'Z'                                         @YL026UD
*
         TITLE 'IGG0CLCC - CONSTANT EQUATE DEFINITIONS'        @YL026UD
*
*
*      CONSTANT EQUATES
*
VICETYP  EQU   5                       VICE TYPE CODE
ICETYP   EQU   3                       ICE TYPE CODE
ILETYP   EQU   0                       ILE TYPE CODE
IPETYP   EQU   0                       IPE TYPE CODE
DSPETYP  EQU   7                       OR MORE, FOR DSPE TYPE CODE
VCBPETYP EQU   1                       VCBPE TYPE CODE
OCVOLTYP EQU   3                       OLD CVOL TYPE CODE
NCVOLTYP EQU   5                       NEW CVOL TYPE CODE
ALIASTYP EQU   4                       ALIAS TYPE CODE
GIPETYP  EQU   2                       GIPE TYPE CODE
ERROR00  EQU   0
ERROR04  EQU   4
ERROR08  EQU   8
ERROR12  EQU   12
ERROR16  EQU   16
ERROR20  EQU   20
ERROR24  EQU   24
ERROR28  EQU   28
ERROR72  EQU   72
***********************************************************************
*      CHARACTER CODE DEPENDENT CONSTANTS
***********************************************************************
CCDBLANK EQU   C' '
CCDRPARN EQU   C')'
CCDMINUS EQU   C'-'
CCDPLUS  EQU   C'+'
CCD0     EQU   C'0'
CCDG     EQU   C'G'
CCDV     EQU   C'V'
CCDPERD  EQU   C'.'
CCDLPARN EQU   C'('
***********************************************************************
CODPERD  EQU   4
CODBLANK EQU   8
CODPARN  EQU   12
CLC1     EQU   C'1'
CLC2     EQU   C'2'
CLC3     EQU   C'3'
CLC4     EQU   C'4'
CLC5     EQU   C'5'
CLC6     EQU   C'6'
CLC7     EQU   C'7'
EXIT     EQU   3
FREEMAIN EQU   10
GETMAIN  EQU   10
FIRSTBLK EQU   256
RPSBIT   EQU   X'10'
BLDLCON  EQU   76
CELLTYPE EQU   5
DBLWD    EQU   X'07'
ENDLIST  EQU   X'FF'
REC1     EQU   1
*
X00      EQU   X'00'
X01      EQU   X'01'
X02      EQU   X'02'
X48      EQU   X'48'
XF0      EQU   X'F0'
XFF      EQU   X'FF'
X0100    EQU   X'0100'
D01      EQU   1
D02      EQU   2
D08      EQU   8
D09      EQU   9
D12      EQU   12
D17      EQU   17
D28      EQU   28
D44      EQU   44
D62      EQU   62
D96      EQU   96
D256     EQU   256
D264     EQU   264
*
POMASK   EQU   X'02'    MASK INDICATING PARTITIONED ORGANIZATION
OUTMASK  EQU   X'0F'    MASK INDICATING NOT INPUT PROCESSING
         TITLE 'IGG0CLCC - REGISTER EQUATE DEFINITIONS'        @YL026UD
*
*      REGISTER EQUATES
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4                       BASE REGISTER FOR ALL MODULES
R5       EQU   5
R6       EQU   6                       WORKAREA BASE REGISTER
R7       EQU   7
R8       EQU   8                       CAMLST POINTER
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12                      SECONDARY LINKAGE REGISTER
R13      EQU   13                      BLDL WORKAREA BASE REGISTER
R14      EQU   14                      PRIMARY LINKAGE REGISTER
R15      EQU   15
*
BALREG1  EQU   R14
BALREG2  EQU   R12
BALREG3  EQU   R5
BASE     EQU   R4
*
UCBTABP  EQU   R12                     POINTS TO UCB LOOK UP TABLE
UCBPTR   EQU   R11                     POINTS TO UCB
HILVLEN  EQU   R9                      HIGH LEVEL NAME LENGTH
NXTDISP  EQU   R9                      NEXT DISPLACEMENT
SAVDELP  EQU   R9
DLPTR    EQU   R10                     PTR TO DISP & LEN FIELDS
NAMENDP  EQU   R14                     END OF LARGEST ALLOWABLE NAME
LEVELPTR EQU   R12                     POINTS TO THE LEVEL NAME
NAMPSAV  EQU   R7                      SAVES THE POINTER TO THE
LEVELCTR EQU   R15                     LEVEL COUNTER
ONELVLSW EQU   R0                      ONE LEVEL SWITCH
TLOCSW   EQU   R7                      TEMPORARY LOCATE SWITCH
LEVELCNT EQU   R7
ERRLOC   EQU   R3
TABLEPTR EQU   R9
Q        EQU   R9
TRULEN   EQU   R10
POINT    EQU   R10
NEWENTRY EQU   R7
*
RGADDR   EQU   0
RGDCB    EQU   1
RGA      EQU   2
RGB      EQU   3
RGC      EQU   4
RGD      EQU   5
RGE      EQU   6
RGF      EQU   7
RGG      EQU   8
RGH      EQU   9
RGI      EQU   10
RGJ      EQU   11
RGK      EQU   12
RGAREA   EQU   13
RGRET    EQU   14
RGBASE   EQU   15
*
DISABLE  EQU   ONELVLMK
*
***********************************************************************
*                                                                     *
         TITLE 'IGG0CLCC - RACF AUTHORIZATION CHECKING ROUTINE'
***********************************************************************
*                                                              @Z40CSRC
RACHK    EQU   *                       RACHECK ROUTINE         @Z40CSRC
*                                                              @Z40CSRC
***********************************************************************
*                                                              @Z40CSRC
*  FUNCTION:                                                   @Z40CSRC
*        CHECK AUTHORIZATION VIA RACF                          @Z40CSRC
*                                                              @Z40CSRC
*  INPUT:                                                      @Z40CSRC
*        R4 - MODULE BASE ADDRESS                              @Z40CSRC
*        R6 - OS CATALOG WORK AREA ADDR                        @Z40CSRC
*        R8 - CAMLST ADDR                                      @Z40CSRC
*        R13 - BLDL AREA ADDR                                  @Z40CSRC
*        R14 - RETURN ADDR                                     @Z40CSRC
*                                                              @Z40CSRC
*  OUTPUT:                                                     @Z40CSRC
*        R15 - RETURN CODE -- 0=OK, 4=NOT AUTHORIZED.          @Z40CSRC
*        ERRLOCSV=8 AND NAMLF=56 IF NOT AUTHORIZED             @Z40CSRC
*                                                              @Z40CSRC
*  DESTROYED:                                                  @Z40CSRC
*        REGISTER R15 (OTHER REGISTERS ARE PRESERVED)          @Z40CSRC
*        CC3SAV1A, CC3RACHK,                                   @Z40CSRC
*                                                              @Z40CSRC
****************                                               @Z40CSRC
*                                                              @Z40CSRC
         USING WORKAREA,R6             WORK AREA ADDRESSABLE   @Z40CSRC
         USING CAMLSTD,R8              CAMLST ADDRESSABLE      @Z40CSRC
         USING BLDLAREA,R13            BLDL AREA ADDRESSABLE   @Z40CSRC
*                                                              @Z40CSRC
         L     R15,CWAP                GET ADDR OF CC3 WK AREA @Z40CSRC
         USING CC3WA,R15               CC3 WK AREA ADDRESSABLE @Z40CSRC
         STM   R0,R14,CC3SAV1A         SAVE REGISTERS          @Z40CSRC
         LR    R12,R15                 COPY ADDR OF CC3WA      @Z40CSRC
         DROP  R15                     CEASE USING CC3WA,R15   @Z40CSRC
         USING CC3WA,R12               ADDRESS CC3WA VIA R12   @Z40CSRC
         BALR  R9,R0                   SET BASE REG.           @Z40CSRC
         USING *,R9                    CODE ADDRESSABLE        @Z40CSRC
         MVI   CC3NAMSV,X00            SHOW NO NAME SAVED YET  @Z40CSRC
*                                                              @Z40CSRC
*   INITIALIZE RACHECK PARAMETER LIST                          @Z40CSRC
*                                                              @Z40CSRC
         MVC   CC3RACHK(ACHKLEN),RACHKMDL MOVE IN DEFAULTS     @Z40CSRC
         LA    R7,CC3RACHK             ADDR OF PARM AREA       @Z40CSRC
         USING ACHKLIST,R7             PARM AREA ADDRESSABLE   @Z40CSRC
         L     R14,CAMPTR1             GET ADDR OF DSNAME      @Z40CSRC
         ST    R14,ACHKENTW            ENTITY NAME ADDR        @Z40CSRC
*                                                              @Z40CSRC
*   CHECK FOR CATALOGING A GDG GENERATION                      @Z40CSRC
*                                                              @Z40CSRC
         TM    CAMOPTN1,CAMCAT         CATALOG REQUEST         @Z40CSRC
         BNO   NOTCATG                 NO, SKIP CAT CODE       @Z40CSRC
         MVI   ACHKFLG2,ACHKTUPD       SET UPDATE LEVEL        @Z40CSRC
*                                                              @Z40CSRC
*   TEMPORARILY BLANK OUT '.G----V--' IN GENERATION NAME       @Z40CSRC
*                                                              @Z40CSRC
         L     R14,NAMLSTP             GET ADDR OF LAST        @Z40CSRC
*                                      ENTRY IN NAME TABLE     @Z40CSRC
         SR    R15,R15                 CLEAR REG.              @Z40CSRC
         IC    R15,X00(,R14)           GET OFFSET TO LAST      @Z40CSRC
*                                      QUALIFIER OF NAME       @Z40CSRC
         BCTR  R15,R0                  GET OFFSET TO LAST '.'  @Z40CSRC
         A     R15,CAMPTR1             ADDR OF LAST '.'        @Z40CSRC
         MVC   X00(GVLEN,R15),CCDBLKS  BLANK .G----V--         @Z40CSRC
         LA    R14,VOLSN               ADDR OF VOLSER          @Z40CSRC
         B     RACSETUP                GO SET UP FOR RACHECK   @Z40CSRC
*                                                              @Z40CSRC
NOTCATG  EQU   *                       NOT CATLG GDG           @Z40CSRC
*                                                              @Z40CSRC
*   CHECK FOR DRPX                                             @Z40CSRC
*                                                              @Z40CSRC
         TM    CAMOPTN3,CAMDRPX        IS IT DRPX              @Z40CSRC
         BNO   NOTDRPX                 NO, SKIP DRPX CODE      @Z40CSRC
         LA    R14,CCDCNAME            ADDR OF 'SYSCTLG'       @Z40CSRC
         ST    R14,ACHKENTW            STORE ENTITY NAME       @Z40CSRC
         MVI   ACHKFLG2,ACHKTALT       MUST BE ALTER OWNER     @Z40CSRC
         LA    R14,CVPEVOLS            GET ADDR OF VOLSER      @Z40CSRC
         CLI   TYPEB,OCVOLTYP          WAS THIS CVOL POINTER   @Z40CSRC
*                                      CREATED BEFORE OS       @Z40CSRC
*                                      RELEASE 17              @Z40CSRC
         BNE   RACSETUP                NO, GO SET UP FOR RACF  @Z40CSRC
         LA    R14,DATAB               ADDR OF VOLSER--OLD TYP @Z40CSRC
         B     RACSETUP                GO SET UP FOR RACHECK   @Z40CSRC
*                                                              @Z40CSRC
NOTDRPX  EQU   *                       NOT DRPX REQUEST        @Z40CSRC
*                                                              @Z40CSRC
*   SET AUTHORIZATION LEVEL FOR UNCATALOG & RECATALOG          @Z40CSRC
*                                                              @Z40CSRC
         TM    CAMOPTN1,CAMRECAT       IS IT RECAT             @Z40CSRC
         BNO   NOTRECAT                NO, SKIP RECAT CODE     @Z40CSRC
         MVI   ACHKFLG2,ACHKTUPD       SET UPDATE AUTH LEVEL   @Z40CSRC
         B     GETVOLS                 GO GET VOL SER          @Z40CSRC
*                                                              @Z40CSRC
NOTRECAT EQU   *                       NOT RECAT REQUEST       @Z40CSRC
         TM    CAMOPTN1,CAMUNCAT       IS IT UNCAT             @Z40CSRC
         BNO   RACSETUP                NO, GO SET UP RACHECK   @Z40CSRC
         MVI   ACHKFLG2,ACHKTALT       SET ALTER OWNER LEVEL   @Z40CSRC
*                                                              @Z40CSRC
*   GET 1ST VOLSER OF DATA SET                                 @Z40CSRC
*                                                              @Z40CSRC
GETVOLS  EQU   *                       GET VOLSER CODE         @Z40CSRC
         LA    R14,DSPEVOL1            ASSUME ENTRY IS DSPE    @Z40CSRC
         CLI   TYPEB,VCBPETYP          IS IT REALLY A VCBPE    @Z40CSRC
         BNE   RACFSTUP                NO ,DO RACHECK          @G32DSFS
*                                                              @Z40CSRC
*   READ IN VCB TO GET VOLSER                                  @Z40CSRC
*                                                              @Z40CSRC
         MVC   CC3NAMSV,NAME           SAVE NAME               @Z40CSRC
         MVC   CC3TTRSV,ICETTR         SAVE TTR OF CURRENT REC @Z40CSRC
*                                      (IS ZERO IF IN VICE)    @Z40CSRC
         L     R15,AREADBLK            GET ADDR OF BLK RD RTN  @Z40CSRC
         BALR  BALREG3,R15             GO READ BLOCK           @Z40CSRC
         L     R12,CWAP                RESTORE CC3WA ADDR      @Z40CSRC
         LA    R14,VCBVOL1             POINT TO 1ST VOLSER     @Z40CSRC
*                                                              @Z40CSRC
*   INVOKE RACF TO CHECK AUTHORIZATION                         @Z40CSRC
*                                                              @Z40CSRC
RACFSTUP EQU   *                       TEST FOR TAPE           @G32DSFS
*                                                              @G32DSFS
         LR    R15,R14                 TYPE FIELD +2           @G32DSFS
         SH    R15,TYPEOFF             TYPE FIELD PTR          @G32DSFS
         TM    0(R15),UCB3TAPE         IS DEV TYPE EQU TAPE    @G32DSFS
         BZ    RACSETUP                NOT TAPE DEVICE         @G32DSFS
*                                                              @G32DSFS
         L     R15,CVTPTR              LOAD CVT ADDRESS        @G32DSFS
         USING CVT,R15                 CVT ADDRESSABILITY      @G32DSFS
         L     R15,CVTRAC              LOAD RACF CVT ADDRESS   @G32DSFS
         LTR   R15,R15                 RACF ACTIVE             @G32DSFS
         BZ    PASTRERR                RACF NOT ACTIVE         @G32DSFS
         USING RCVT,R15                RCVT ADDRESSABILITY     @G32DSFS
         TM    RCVTSTA1,RCVTTAPE       TEST FOR TAPE VOLUME    @G32DSFS
         BZ    PASTRERR                NOT TAPE VOLUME         @G32DSFS
*                                                              @G32DSFS
         STCM  R14,B'0111',ACHKENT     VOLSER INTO ENTITY      @G32DSFS
         LA    R14,TAPEVOL             TAPE VOL CLASS NAME     @G32DSFS
         STCM  R14,B'0111',ACHKCLN     CLASS NAME INTO LIST    @G32DSFS
         SR    R14,R14                 VOLSER @ ZERO FOR TAPE  @G32DSFS
*                                                              @G32DSFS
RACSETUP EQU   *                       RACHECK SET UP          @Z40CSRC
         RACHECK VOLSER=(R14),MF=(E,(R7))                      @G32DSFS
         LA    R14,ERROR08             LOAD COMPARISON VALUE   @Z40CSRC
         CR    R15,R14                 TEST IF UNAUTHORIZED    @Z40CSRC
         BNE   PASTRERR                BR IF NOT UNAUTHORIZED  @Z40CSRC
         MVI   ERRCATSV,ERROR08        SET ERROR RETURN CODE   @Z40CSRC
         MVI   ERRLOCSV,X00            CLEAR LOCATE RET CODE   @Z40CSRC
         MVI   NAMLF+D01,RACREASN      SET REASON CODE TO BE   @Z40CSRC
*                                      RETURNED TO USER IN R0  @Z40CSRC
*                                                              @Z40CSRC
PASTRERR EQU   *                       BEYOND RACF ERROR CODE  @Z40CSRC
*                                                              @Z40CSRC
*   REFRESH IN-CORE CATALOG RECORD                             @Z40CSRC
*                                                              @Z40CSRC
         CLI   CC3NAMSV,X00            IS REFRESHING NEEDED    @Z40CSRC
         BE    PASTREFR                NO, SKIP REFR CODE      @Z40CSRC
         MVC   NAME,CC3NAMSV           RESTORE NAME FOR BLDL   @Z40CSRC
         L     R15,CC3TTRSV            GET ORIGINAL TTR        @Z40CSRC
         ST    R15,TTR0                SET TTR FOR BLDL        @Z40CSRC
         LTR   R15,R15                 IS TTR ZERO             @Z40CSRC
         BNZ   BLCALL                  BRANCH IF TTR NON-ZERO  @Z40CSRC
         MVI   TTR0+D02,REC1           SET TO START AT 1ST REC @Z40CSRC
*                                                              @Z40CSRC
BLCALL   EQU   *                       SET UP TO CALL BLDL     @Z40CSRC
         L     R15,ABLDLCAL            GET ADDR OF BLDL RTN    @Z40CSRC
         BALR  BALREG3,R15             GO READ ORIG ENTRY      @Z40CSRC
         L     R12,CWAP                RESTORE CC3WA ADDRESS   @Z40CSRC
*                                                              @Z40CSRC
PASTREFR EQU   *                       PAST REFRESH CODE       @Z40CSRC
*                                                              @Z40CSRC
*   RESTORE LAST QUALIFIER OF GDG GENERATION                   @Z40CSRC
*                                                              @Z40CSRC
         TM    CAMOPTN1,CAMCAT         IS IT CATLG GDG         @Z40CSRC
         BNO   RACLNUP                 NO, GO CLEAN UP         @Z40CSRC
         L     R14,NAMLSTP             PT TO LAST IN NAME TBL  @Z40CSRC
         SR    R15,R15                 CLEAR REG.              @Z40CSRC
         IC    R15,X00(,R14)           OFFSET TO LAST QUAL.    @Z40CSRC
         A     R15,CAMPTR1             ADDR OF LAST QUALIFIER  @Z40CSRC
         MVC   X00(L'NAME,R15),NAME    MOVE IN NAME            @Z40CSRC
         XC    D01(4,R15),MASKFF       RESTORE TO TRUE NAME    @OZ20755
         BCTR  R15,R0                  POINT TO PERIOD SPOT    @Z40CSRC
         MVI   X00(R15),CCDPERD        MOVE IN '.'             @Z40CSRC
*                                                              @Z40CSRC
*   CLEANUP FOR RACF ROUTINE                                   @Z40CSRC
*                                                              @Z40CSRC
RACLNUP  EQU   *                       CLEANUP                 @Z40CSRC
         LM    R0,R14,CC3SAV1A         RESTORE REGISTERS       @Z40CSRC
         DROP  R7,R9,R12               ADDRESSABILITY ENDS     @Z40CSRC
         SR    R15,R15                 ASSUME SUCCESS          @Z40CSRC
         CLI   NAMLF+D01,RACREASN      IS USER UNAUTHORIZED    @Z40CSRC
         BNER  R14                     NO, RETURN              @Z40CSRC
         LA    R15,ERROR04             SET RETURN CODE         @Z40CSRC
         BR    R14                     RETURN                  @Z40CSRC
*                                                              @Z40CSRC
*   EQUATES FOR RACF ROUTINE                                   @Z40CSRC
*                                                              @Z40CSRC
RACSHFT  EQU   28                      RACF REG CD SHIFT VALUE @Z40CSRC
RACREASN EQU   56                      RACF REASON CODE        @Z40CSRC
GVLEN    EQU   9                       LENGTH OF .G----V--     @Z40CSRC
*                                                              @Z40CSRC
***********************************************************************
*   CONSTANTS FOR RACF ROUTINE                                 @Z40CSRC
***********************************************************************
*                                                              @Z40CSRC
CCDBLKS  DC    CL9' '                  BLANKS                  @Z40CSRC
CCDCNAME DC    CL44'SYSCTLG'           CVOL NAME               @Z40CSRC
CLASNAME DC    AL1(L'CCDCLASS)         LENGTH OF CLASS NAME    @Z40CSRC
CCDCLASS DC    C'DATASET'              CLASS NAME--MUST FOLLOW @Z40CSRC
*                                      LENGTH                  @G32DSFS
TAPEVOL  DC    AL1(L'TAPE)             LENGTH OF CLASS NAME    @G32DSFS
TAPE     DC    C'TAPEVOL'              CLASS NAME--MUST FOLLOW @G32DSFS
*                                      LENGTH                  @Z40CSRC
TYPEOFF  DC    H'2'                    DISP TO GET TO TYPE FLD @G32DSFS
AREADBLK DC    A(READBLK)              READ BLOCK RTN          @Z40CSRC
ABLDLCAL DC    A(BLDLCALL)             BLDL CALLING RTN        @Z40CSRC
***********************************************************************
RACHKMDL RACHECK CLASS=CLASNAME,DSTYPE=N,MF=L                  @Z40CSRC
*
* END OF IGG0CLCC CSECT                                               *
CLCCSIZE EQU   *                                                      *
         TITLE 'IGG0CLCC - RACHECK PARAMETER LIST'             @Z40CSRC
         ICHACHKL                                              @Z40CSRC
***********************************************************************
         TITLE 'IGG0CLCC - RACF CVT DSECT DEFINITIONS'         @Z40CSRC
         ICHPRCVT                                              @Z40CSRC
         TITLE 'IGG0CLCC - CATALOG CONTROLLER III WORK AREA'   @Z40CSRC
*                                                              @Z40CSRC
*  CATALOG CONTROLLER III WORK AREA                            @Z40CSRC
*                                                              @Z40CSRC
*        THIS AREA IS OBTAINED BY IGC0002F                     @Z40CSRC
*        AND FREED BY IGC0002F AND IGG0CLCA.                   @Z40CSRC
*        FOR A DESCRIPTION OF THE RESERVED FIELDS              @Z40CSRC
*        SEE THE ABOVE MODULES.                                @Z40CSRC
*                                                              @Z40CSRC
CC3WA    DSECT                                                 @Z40CSRC
         DS    CL588                   RESERVED                @Z40CSRC
CC3CVOLS DS    CL6                     CVOL VOLUME SERIAL      @Z40CSRC
*                                      (SAME AS WKCVOLVS IN CLCA)
         DS    CL2886                  RESERVED                @Z40CSRC
CC3SAV1A DS    18F                     SAVE AREA (FOR CL1A)    @Z40CSRC
*                                      (SAME AS WKCL1ASV IN CLCA)
CC3RACHK DS    12F                     RACF PARAMETER AREA     @Z40CSRC
*                                      (SAVE AS WKSHRPRM IN CLCA)
         ORG   CC3RACHK+ACHKLEN        BEYOND ACTUAL LIST      @Z40CSRC
CC3NAMSV DS    CL8                     SAVE INDEX NAME         @Z40CSRC
CC3TTRSV DS    F                       SAVE TTR OF ORIG BLK    @Z40CSRC
         TITLE 'IGG0CLCC - CATALOG WORKAREA DSECT DEFINITION'  @YL026UD
         WORKAREA LIST=YES                                       Y01113
CVPEVOLS EQU   DATAB+4                 VOLSER IN CVPE          @Z40CSRC
DSPEVOL1 EQU   VOLCNTB+6               1ST VOLSER IN DSPE      @Z40CSRC
VCBVOL1  EQU   INENTRY+4               1ST VOLSER IN VCB       @Z40CSRC
         TITLE 'IGG0CLCC - COMMUNICATIONS VECTOR TABLE DSECT'  @YL026UD
CVT      DSECT
         CVT
         TITLE 'IGG0CLCC - UNIT CONTROL BLOCK DSECT'           @YL026UD
UCB      DSECT
         IEFUCBOB
         TITLE 'IGG0CLCC - BLDL WORKAREA DSECT DEFINITION'     @YL026UD
*
***      BLDL WORKAREA DEFINITION
*
BLDLWKA  DSECT
FIRST    DS    0D
SAVE2H   DS    12F                     SAVEAREA FOR IGC0002H   @YL026UD
ESTAREA  DS    14F                     ESTAE INFORMATION AREA  @YL026UD
RDAREA   DS    64F                     256 BYTE READIN AREA
NEWCNT   DS    2F
CCW      DS    0D
CCW1     DS    D
CCW2     DS    D
CCW3     DS    D
CCW4     DS    D
CCW5     DS    D
CCW6     DS    D
ECBBLDL  DS    F
IOBBLDL  DS    8F
MBB      DS    C'mbb'
CCHHR    DS    C'cchhr'
ERCODE   DS    F
FNDLST1  DS    F
IECPCNVT EQU   FNDLST1                                         @YL026UD
FNDLST2  DS    CL8
FNDLST3  DS    F
REPSW    DS    X                       'AVT REPLACED' INDICATOR
SAVEAVT  DS    3X                      SAVE AREA FOR USER'S AVT PT
LAST     DS    0D
*
         TITLE 'IGG0CLCC - DCB DEFINITION DSECT (IHADCB)'      @YL026UD
*
***      DCB DEFINITION
*
         DCBD  DSORG=PS,DEVD=DA
*
         TITLE 'IGG0CLCC - DEB DEFINITION DSECT (IHADEB)'      @YL026UD
*
***      DEB DEFINITION
*
IHADEB   DSECT
         DS    F
DEBAMLNG DS    X                       LENGTH OF DEB A/M SECTION
         DS    3X
DEBOFLGS DS    X                       OPEN FLAGS
         DS    3X
DEBOPATB DS    X                       METHOD OF I/O PROCESSING
         DS    3X
DEBNMEXT DS    X
         DS    12X
DEBAPPAD DS    3X                      APPENDAGE VECTOR TABLE ADDRESS
DEBDVMOD DS    F
DEBBINUM DS    H
DEBSTRCC DS    H
DEBSTRHH DS    H
DEBENDCC DS    H
DEBENDHH DS    H
DEBNMTRK DS    H
*
         END   IGG0CLCC
