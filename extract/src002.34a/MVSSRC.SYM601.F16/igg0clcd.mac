         TITLE 'IGG0CLCD - UPDATE AND ENTRY BUILDING'          @YL026UD
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IGG0CLCD                                   @YL026UD
*01*  STATUS = 00
*01*  CHANGE-ACTIVITY = NEW FOR RELEASE 21
*                       (AS IGG0CLC3,IGG0CLC4,IGG0CLC5)        @YL026UD
*                       RENAMED AND CHANGED FOR VS2 RELEASE 2  @YL026UD
*01*  DESCRIPTIVE-NAME = UPDATE AND ENTRY BUILDING             @YL026UD
*01*  FUNCTION = (IN IGG0CLC3)                                 @YL026UD
*                1.  ENQUES ON THE VICE
*                2.  READS THE CONTROL ENTRIES (ICE AND VICE).
*                3.  INSURES THAT SOME SPACE IS AVAILABLE TO PROCESS
*                    REQUEST.
*                4.  BUILDS INDEX ENTRIES
*                5.  BUILDS INDEX CHAINS
*                6.  BUILDS GENERATION INDEX ENTRIES
*                7.  ROUTES CONTROL TO THE NEXT LOAD ACCORDING TO THE
*                    REQUEST TYPE.
*                8.  MAINTAINS ALIAS COUNTS
*                (IN IGG0CLC4)                                 @YL026UD
*                1.  UPDATES A GENERATION INDEX POINTER ENTRY. @YL026UD
*                2.  REMOVES LAST ENTRY FROM A FULL            @YL026UD
*                    GENERATION DATA GROUP.                    @YL026UD
*                3.  SCRATCHES ALL DATA SETS REMOVED FROM      @YL026UD
*                    A GENERATION DATA GROUP.                  @YL026UD
*                4.  BUILDS A DATA SET POINTER ENTRY.          @YL026UD
*                5.  BUILDS VOLUME CONTROL BLOCK POINTER ENTRY.@YL026UD
*                (IN IGG0CLC5)                                 @YL026UD
*                1.  FREES A CHAIN OF INDEX LEVELS.            @YL026UD
*                2.  FREES A CHAIN OF VCBS.                    @YL026UD
*                3.  FREES A BLOCK.                            @YL026UD
*                4.  WRITES A BLOCK CONTAINING A NEW GIPE.     @YL026UD
*                5.  WRITES A NEW LAST BLOCK OF A GDG.         @YL026UD
*                6.  EMPTYS A GDG.                             @YL026UD
*                7.  BUILDS A CHAIN OF VCBS.                   @YL026UD
*                8.  CLEANS UP PARTIALLY CREATED INDEX         @YL026UD
*                    STRUCTURES AND VCB CHAINS ON CATALOG      @YL026UD
*                    FULL ERROR CONDITIONS.                    @YL026UD
*     FOR AN OVERVIEW OF THIS MODULE AND ITS RELATIONSHIP WITH THE
*     OTHER CATALOG MANAGEMENT MODULES, REFER TO THE CATALOG MANAGEMENT
*     PLM, Y28-6606.
*01*  NOTES = LABELS REFERED TO IN COMMENTARY ARE ENCLOSED IN SINGLE
*     QUOTES. EQUATED CONSTANTS ARE PREFIXED WITH 'D' OR 'X' WHEN THEY
*     ARE DECIMAL OR HEXADECIMAL RESPECTIVELY; FOR EXAMPLE, D12 EQU 12,
*     AND X12 EQU X'12'. ERROR CODES ARE SET USING 'ERRORXX' AT
*     CORRESPONDING LABELS, 'ERRXX'. BRANCHES ORIGINATE FROM LABELS
*     'IGG0CLCX'. FLAGS ARE LABELED 'FLAGX'.  IO IS DONE FROM EITHER A
*     SUBROUTINE NAMED 'CALLBLDL' OR A SUBROUTINE NAMED 'IO'. ADDRESS
*     CONVERSION IS ACCOMPLISHED IN SUBROUTINES NAMED 'TOABSL' AND
*     'TORLTV'. THESE CONVENTIONS ARE FOLLOWED IN EVERY MODULE WHERE
*     THE EVENT EXISTS.
*02*    DEPENDENCIES = THE OPERATION OF THIS MODULE DEPENDS ON THE
*       COLLATING SEQUENCE OF THE EXTERNAL CHARACTER SET.  A TRANSLATE
*       AND TEST TABLE IS CONSTRUCTED FOR THE EBCDIC CHARACTER SET AND
*       IS ARRANGED SO THAT REDEFINITION OF THE CHARACTER CONSTANTS BY
*       REASSEMBLY WILL RESULT IN A CORRECT TABLE.  THE CONSTANTS IN
*       QUESTION ARE PREFIXED WITH 'CCD', FOR 'CHARACTER CODE
*       DEPENDENT'.
*02*    PERFORMANCE = 1.  THE ICE IS NOT REREAD.
*                     2.  THE VOLUME INDEX IS ENQUED SHARED WHEN AN
*                         ENTRY IS NOT BEING INSERTED INTO IT.
*                     3.  THE BLOCK TO BE UPDATED IS NOT
*                         OVERLAID IN MOST CASES.
*                     4.  BEFORE THE SYSCTLG DATA SET IS MODIFIED, THE
*                         'STEP MUST COMPLETE' (SMC) ENQ IS ISSUED
*                     5.  UPON AN ERROR CONDITION, ALL USED DATA BLOCKS
*                         ARE FREED
*                     6.  CHECKS ARE MADE FOR CONSISTENCY BETWEEN
*                         THE REQUEST AND THE STATE OF SYSCTLG IN
*                         ORDER TO MAINTAIN THE INTEGRITY OF SYSCTLG
*02*  RESTRICTIONS = ALL DIRECT ACCESS STORAGE DEVICES EXCEPT 2321
*       DATA CELL ARE SUPPORTED BY CATALOG MANAGEMENT.
*02*    REGISTER-CONVENTIONS = REGISTERS ARE LABELED 'R0,R1,...,R15'.
*       REQUIRED ADDITIONAL LABELS ARE EQUATED TO THESE.  REGISTERS
*       COMMON TO ALL MODULES OF CATALOG MANAGEMENT ARE
*       R4  BASE REGISTER FOR THE MODULE.
*       R6  BASE REGISTER FOR THE WORKAREA DSECT.
*       R8  BASE REGISTER FOR THE CAMLSTD DSECT.
*02*    PATCH-LABEL = 'FIXAREA'                                @YL026UD
*01*  MODULE-TYPE = MODULE
*02*    PROCESSOR = ASSEMBLER
*02*    MODULE-SIZE = 4000 BYTES                               @YL026UD
*02*    ATTRIBUTES = REENTERABLE READ ONLY, ENABLED, SUPERVISORY MODE
*01*  ENTRY = IGG0CLCD                                         @YL026UD
*02*    PURPOSE = (IGG0CLC3) ENTERED FOR EVERY NON-LOCATE      @YL026UD
*       REQUEST. BUILDS ALL MISSING INDEX LEVELS. FOR BLDA,    @YL026UD
*       DLTA, BLDX, DLTX, DRPX, BLDG, IT INSURES THE REQUEST   @YL026UD
*       CAN BE PERFORMED ON THE EXISTING SYSCTLG STRUCTURE.    @YL026UD
*       (IGG0CLC4) ENTERED FOR 'CAT', 'UNCAT', 'RECAT',        @YL026UD
*       'CATBX', FOR EITHER GDG OR NON-GDG.                    @YL026UD
*       (IGG0CLC5) ENTERED FOR A VARIETY OF REQUESTS FOR THE   @YL026UD
*       PERFORMANCE OF NECESSARY IO OTHER THAN THE NORMAL      @YL026UD
*       UPDATING OF AN INDEX LEVEL.                            @YL026UD
*02*    LINKAGE = LINK                                         @YL026UD
*02*    INPUT = FOR ALL MODULES, EXCEPT IGC0002F, CONSISTS OF
*       .  WORKAREA (BLDLAREA)
*       .  SVRB EXTENSION
*       .  DCB
*       .  DEB
*       .  CAMLST AND PARAMETERS
*       .  SYSCTLG
*       IN ADDITION, IGG0CLC3 REQUIRES                         @YL026UD
*       .  'READICEF'--INDICATES IF ICE MUST BE READ
*       .  'ICETTR'--TTR OF ICE FOR THIS REQUEST
*       .  'NAMETTR0'--USED TO CONSTRUCT AN INDEX
*       IN ADDITION, IGG0CLC4 REQUIRES                         @YL026UD
*       .  'FOUNDENT'--POINTER TO THE GIPE (CAT,UNCAT)         @YL026UD
*       .  'NAMLG'--NUMBER OF LEVELS GIVEN (CAT,CATBX)         @YL026UD
*       .  'NAMLF'--NUMBER OF LEVELS FOUND (CAT,CATBX)         @YL026UD
*       IN ADDITION, IGG0CLC5 REQUIRES                         @YL026UD
*       .  'DELTTR1'--POINTER TO INDEX LEVEL CHAIN TO FREE     @YL026UD
*       .  'DELTTR3'--POINTER TO VCB CHAIN TO FREE             @YL026UD
*       .  'TTR0'--POINTER TO BLOCK TO FREE                    @YL026UD
*       .  'WRITETTR'--POINTER TO NEW BLOCK TO WRITE           @YL026UD
*       .  'READTTR'--POINTER TO NEW LAST GDG BLOCK TO WRITE   @YL026UD
*       .  'ICE'--FOR EMPTYING A GENERATION DATA GROUP         @YL026UD
*02*    OUTPUT = SEE INPUT FOR NEXT LOAD
*02*    EXIT-NORMAL = IGG0CLCE                                 @YL026UD
*02*    EXIT-ERROR = IGG0CLC7 (IN IGG0CLCE)                    @YL026UD
*01*  EXTERNAL-REFERENCES = AS FOLLOWS:
*02*    ROUTINES = IECPRLTV, IECPCNVT, ENQ, OPENEXT(IGC0002H)  @YL026UD
*02*    DATA-SETS = SYSCTLG
*02*    DATA-AREA = ALL DATA AREAS ARE DESCRIBED BY DSECTS AT THE END
*       OF THE MODULE LISTING.
*01*  TABLES = NAME TABLE (SEE LABELS PREFIXED WITH 'NAM' IN WORKAREA
*     DSECT)
*01*  MACROS = EXCP, GETMAIN, ENQ, DEQ, FREEMAIN, SCRATCH,     @YL026UD
*              SETRP, SDUMP, TESTAUTH, WAIT
*
*              VS2 RELEASE 037 CHANGES
*A286018-286028                                                @OZ03161
*C115700                                                       @OZ14792
*C285940                                                       @OZ17516
*A173810-173880,A286551                                        @OZ19636
*A173916,A173924                                               @OZ27009
*A285940-285943,A286689-286701,A297708-297716                  @OZ29464
*
**** END OF SPECIFICATIONS ***/
         EJECT                                                 @YL026UD
IGG0CLCD CSECT
*
         BALR  BASE,0                  SET BASE REGISTER
         USING *,BASE
         USING WORKAREA,R6
         USING SVRBEXTD,R5
         USING CAMLSTD,R8
         USING CVT,R3
         B     MODLABEL                BRANCH AROUND MOD LABEL @YL026UD
         DC    C'IGG0CLCD        '     MODULE IDENTIFIER       @YL026UD
         DC    C'&SYSDATE'             DATE OF ASSEMBLY
MODLABEL EQU   *
*
         TITLE 'IGG0CLCD - (IGG0CLC3) UPDATE INITIALIZATION'   @YL026UD
***********************************************************************
*                                                                     *
*     IGG0CLC3 - UPDATE INITIALIZATION                                *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLC3 EQU   *                                               @YL026UD
*
         OI    MODMAP1,MODCLC3         INDIC ENTRY TO IGG0CLC3
         XC    DELTTR3,DELTTR3         RESET TO ZERO             Y01113
*
         TM    MODMAP1,MODCLC4         BEEN TO CLC4?
         BO    CATBX                   BRANCH IF YES AND BUILD INDEXES
*
         TM    FLAG1,READICEF          MUST READ ICE?
         BZ    ENQVI                   BRANCH IF NO
*
*      READ ICE ENTRY
*
         L     R0,ICETTR               GET ICE TTR
*
*      IF ICETTR=0, THEN ICE=VICE FOR THIS REQUEST
*
         LTR   R0,R0                   ICETTR 0?
         MVI   ITYPE,VICETYP           ASSUME YES
         BZ    ENQVI                   BRANCH IF YES
*
         BAL   BALREG2,TOABSL          CONVERT TTR
*
*      CHANNEL PROGRAM SET DURING RELOCATE.
*
         BAL   BALREG1,IO1             ***READ ICE***
         MVC   ICEPERT,TEMPBUFF+L'INBYTSU+L'INAME  SAVE ICE
*
ENQVI    EQU   *
*
*      ENQUEUE ON VOLUME INDEX (IF NECESSARY), AND VICE AND READ VICE.
*
         MVI   ENQFLAGS,SHARE+HAVE+SYSTEM  INDIC TYPE OF REQUEST X01965
         ENQ   ,MF=(E,(R5))
*
*      ENQUE ON VICE
*
         XC    ENQRNAM8,ENQRNAM8       RNAME OF ZERO
         MVI   ENQFLAGS,HAVE+SYSTEM    INDIC TYPE OF REQUEST     X01965
         ENQ   ,MF=(E,(R5))
*
*      READ VICE ENTRY
*
         LA    R0,VICETTR              SET VICE TTR OF 001
         BAL   BALREG2,TOABSL          CONVERT
*
*      CHANNEL PROGRAM WAS SET DURING RELOCATE IN CLC2
*
         BAL   BALREG1,IO1             READ THE BLOCK
*      GET THE NEEDED PART OF THE VICE
         MVC   VICEPERT,TEMPBUFF+L'INBYTSU+L'VNAME
*
*      SAVE ORIGINAL 'VFHOLE' --- IF 'VFHOLE' IS NOT CHANGED THEN THE
*      VICE DOES NOT HAVE TO BE UPDATED, HENCE NOT REREAD AND WRITTEN
*      IN IGG0CLC7
*
         MVC   VICESAVE,VSAVE          SAVE ORIGINAL VFHOLE
*
*      IF THE VOLUME INDEX WAS PREVIOUSLY DEQUEUED AND ENQUEUED AGAIN,
*      THEN A CHECK MUST BE MADE TO BE SURE THE CATALOG WAS NOT
*      EXTENDED DURING THE INTERVENING TIME.  IF SO, CLOSE AND REOPEN
*      THE CATALOG SO THE DEB REFLECTS THE NEW EXTENT.
*
         L     R0,VCLSTBLK             TTR TO LST BLK IN CURRENT CTLG
         BAL   BALREG2,TOABSL          TTR WITHIN DEB EXTENTS?
         LTR   R15,R15                 RETURN CODE 0? (I.E. WITHIN DEB)
         BZ    SPACECHK                BRANCH IF YES
*
*      CLOSE CATALOG BY FREEING THE DCB/DEB
*
         L     R1,IOBDCB               GET DCB POINTER
         USING DCBAREA,R1              ESTABL ADDRBLTY TO DCBAREA
         L     R0,NMBYTES              GET NUMBER OF BYTES TO FREE
         LA    R1,DCBAREA              POINTER TO AREA         @YL026UD
         XC    SVOPNWAP(4),SVOPNWAP    RESET WKA PTR (ESTAE)   @YL026UD
         SVC   FREEMAIN                FREEMAIN R,LV=(0),A=(1)
*
         L     R0,SPNBYTES             GET SP ID AND SIZE OF WA
         GETMAIN R,LV=(0)              GET NEW DCB/DEB AREA FOR 2H
         ST    R1,SVOPNWAP             SAVE WKA PTR (ESTAE)    @YL026UD
*
*      PREPARE FOR OPEN
*
         USING DCBAREA,R1              ESTABL DCBAREA ADDRBLTY @YL026UD
         ST    R6,CATWAP               SAVE WORKAREA PTR FOR 2H
         LA    R0,BLDLAREA             OBTAIN 'BLDLAREA' ADDRESS
         ST    R0,BLDLAP               SAVE BLDLAREA PTR (2H)  @YL026UD
         DROP  R1
         LR    R15,R1                  OPEN WA POINTER
         XR    R0,R0                   INDICATE OPEN REQUEST
         L     R1,UCBADDR              GET UCB ADDRESS
         L     R2,OPENMOD              GET IGC0002H MODULE ADDRESS
         BALR  R14,R2                  RE-OPEN CATALOG
*
         LR    R2,R1                   SAVE DCB ADDRESS
         LCR   R1,R15                  CHECK RETURN CODE
         BNZ   IGG0CLC7                TAKE ERROR EXIT
*
         ST    R2,IOBDCB               UPDATE IOB DCB
         L     R2,D44(R2)              GET DEB ADDRESS
         ST    R2,DEBADDR              SAVE DEB ADDRESS
*
*
SPACECHK EQU   *
*
*      IS THERE SUFFICIENT SPACE AVAILABLE IN THE CATALOG TO PROCEED
*      BEYOND THIS POINT?
*
*      WILL DATA BE ADDED TO THE CATALOG?
*
         TM    CAMOPTN1,CAMCAT+CAMRECAT     CATALOG OR RECAT?   SA52093
*      BRANCH IF YES AND CHECK SPACE                            SA52093
         BM    FULLCHK                      BRANCH IF YES       SA52093
*      BLDX OR BLDG OR BLDA OR LNKX?
         TM    CAMOPTN2,CAMBLDX+CAMBLDG+CAMBLDA+CAMLNKX
         BZ    ROUTE                   BRANCH IF NO - CHECK UNNECESSARY
*
*
FULLCHK  EQU   *
*
         CLI   VFHOLE,XFF              CATALOG FULL?
         BE    ERR20                   BRANCH IF YES
*
*
ROUTE    EQU   *
*
*      ROUTE THE REQUEST TO THE PROPER MODULE OR ROUTINE
*
*      IF UCATDX AND BLOCKS HAVE TO BE FREED -- GO TO CLC5
*
         NC    DELTTR1,DELTTR1         ANY BLKS TO FREE?
         BNZ   IGG0CLC5                BRANCH IF YES
*
*     CAT, RECAT, UNCAT, CATBX OR UCATDX ----   GO TO IGG0CLC4
*
         TM    CAMOPTN1,CAMCAT+CAMRECAT+CAMUNCAT
         BM    IGG0CLC4                BRANCH IF YES
*
*      TEST FOR LNKX
*
         TM    CAMOPTN2,CAMLNKX        LNKX?
         BO    IGG0CLC6                BRANCH IF YES AND GO TO CLC6
*
*      TEST FOR BLDX OR BLDG
*
         TM    CAMOPTN2,CAMBLDX+CAMBLDG
         BM    BLDX                    BRANCH IF BLDX OR BLDG
*
*      IS LAST ENTRY FOUND AN IPE, ALIAS OR CVOL?
*
         CLI   ERRLOCSV,ERROR12        IS LOCATE ERROR CODE 12?
         BNE   ERR08                   BRANCH IF NO
*
*      TEST FOR DRPX
*
         TM    CAMOPTN3,CAMDRPX        DRPX?
         BO    DRPX                    BRANCH IF YES
*
*      CHECK FOR DLTX FUNCTION
*
         TM    CAMOPTN2,CAMDLTX        IS DLTX BIT ON?
         BO    DLTXRTN                 BRANCH IF YES
*
*      CHECK FOR BLDA OR DLTA
*
         TM    CAMOPTN2,CAMBLDA+CAMDLTA     IS BLDA OR DLTA BIT ON?
         BM    BDLTARTN                BRANCH IF YES
*
*      ALL POSSIBLITIES ARE EXHAUSED --- NO FUNCTION MATCH
*
         B     ERR08                   ERROR EXIT
*
*
DRPX     EQU   *
*
         TM    FLAG2,CVOLF             * CVOL LAST ENTRY FOUND?
         BO    IGG0CLC6                YES, CONTINUE PROCESSING
         B     ERR08                   ERROR--INCORRECT ENTRY
*
*
BLDX     EQU   *
*
*      ALL PREVIOUS LEVELS TO THE LAST MUST EXIST BEFORE BUILDING AN
*      INDEX
         LH    R15,NAMLG               NAME LEVELS GIVEN
         BCTR  R15,0                   DECREMENT BY 1
         CH    R15,NAMLF
         BL    ERR08                   BRANCH IF EQUAL (DUPLICATE)
         BH    ERR16                   BRANCH IF LEVELS MISSING
*
*      BUILD AN INDEX.
*
*      CONSTRUCT FIRST 28 BYTES OF THE KEY AND DATA FIELDS
         BAL   BALREG1,KEYICE          CONSTRUCT FIRST PART OF BLK
*
*      PUT IN LINK ENTRY
         MVC   OUTDATA+L'OUTBYTSU+L'ICE(L'LNKENTRY),LNKENTRY
*
*      SINCE THE CATALOG DATA SET IS TO BE MODIFIED, ISSUE THE STEP
*      MUST COMPLETE ENQ
*
         OI    ENQFLAGS,SMCSTEP        SET FLAGS FOR SMC
         ENQ   ,MF=(E,(R5))            ISSUE REQUEST
*      WRITE BLOCK, FIND NEXT FREE BLOCK AND PUT INTO VICE
         BAL   BALREG5,WRTSRCH         ***WRITE BLOCK***
*
*
BLDXCHK  EQU   *
*
         TM    CAMOPTN2,CAMBLDX        BLDX?
         BO    IGG0CLC6                BRANCH IF YES
*
*      BUILD A GIPE.
*
         LA    R2,NAME                 POINT TO ENTRY
         USING EINDEX,R2               USE ENTRY DSECT
         XC    EGIPEF,EGIPEF           ZERO GIPE DATA FIELD
         MVI   ETYPE,GIPETYP           SET TYPE TO GIPE
         MVC   EGMAXSIZ,CAMGEN         GET MAXIMUM GENERATION COUNT
         TM    CAMOPTN3,CAMEMPTY       'EMPTY' OPTION SPECIFIED?
         BZ    TSTDELET                BRANCH IF NO
         OI    EGFLAGS,EGEMPTY         TURN ON EMPTY FLAG
*
TSTDELET EQU   *
*
         TM    CAMOPTN3,CAMDELET       'DELETE' OPTION SPECIFIED?
         BZ    IGG0CLC6                BRANCH IF NO
         OI    EGFLAGS,EGDELETE        TURN ON DELETE FLAGS
         B     IGG0CLC6                GO TO CLC6 AND INSERT NAME
*
         DROP  R2
*
CATBX    EQU   *
*
*      BUILD ALL INDEXES FOR CATBX.
*
*      FIRST BUILD THE BLOCK TO CONTAIN THE DSPE OR VCBPE ENTRY
*
*      SINCE THE CATALOG DATA SET WILL BE MODIFIED, WILL ISSUE
*      'STEP MUST COMPLETE'
*
         TM    ENQFLAGS,SMCSTEP        SMC ALREADY ISSUED?       Y01965
         BO    SKIPSMC                 BRANCH IF YES             Y01965
*
         OI    ENQFLAGS,SMCSTEP        SET FLAGS FOR SMC
         ENQ   ,MF=(E,(R5))            ISSUE REQUEST
*                                                                Y01965
SKIPSMC  EQU   *                                                 Y01965
*                                                                Y01965
*
*      CONSTRUCT KEY AND ICE IN 'OUTPUT' AND 0 REMAINING BLOCK
         BAL   BALREG1,KEYICE          CONSTRUCT FIRST PART OF BLK
         LH    LEVEL,NAMLG             GET NUMBER OF LEVELS GIVEN
*      DECREMENT BY ONE SO PROPER EXIT IS TAKEN ON CORRECT LEVEL
         BCTR  LEVEL,0                 DECREMENT BY 1
         LA    R1,D02                  INITIALIZE FOR VCBPE
         CLI   TYPE,VCBPETYP           VCBPE?
         BE    MOVENTRY                BRANCH IF YES
*      ASSUME ENTRY IS DSPE.
         IC    R1,TYPE                 GET NUMBER OF HALFWORDS
         LA    R1,0(R1,R1)             DOUBLE
         BCTR  R1,0                    DECREMENT FOR EX INSTRUCTION
         L     R2,CAMPTR3              GET POINTER TO VOLUME LIST
         EX    R1,MOVEVOLS             MVC    OUTDATA+32(0),0(R2)
         LA    R1,D01(R1)              RESET DATA LENGTH
*
*
MOVENTRY EQU   *
*
*      PUT NEW ENTRY INTO BUFFER.
*
         MVC   OUTENTRY+L'ICE(L'NAMTTR0),NAMTTR0
*
*      IF THE ENTRY IS A VCBPE, ONLY 12 BYTES OF THE ENTRY ARE MOVED
*      BY THE ABOVE INSTRUCTION, BUT THE LAST TWO BYTES OF A VCBPE
*      ARE 0 AND THE BLOCK WAS ZEROED IN THE 'KEYICE' ROUTINE.  THE
*      EXTRA TWO BYTES ARE ALLOWED FOR IN THE FOLLOWING BY THE ABOVE
*      LA R1,2 INSTRUCTION.
*
         LA    R1,D12(R1)              CALCULATE LENGTH OF ENTRY
*      ADD 32 FOR HALFWORD COUNT, ICE AND ILE
         AH    R1,OUTBYTSU
*      UPDATE BYTES USED FIELD IN BLOCK
         STH   R1,OUTBYTSU
*      POINT R2 TO WHERE ILE GOES
         LA    R2,OUTDATA-L'LNKENTRY(R1)
         MVC   0(L'LNKENTRY,R2),LNKENTRY    PUT IN ILE
*      SAVE TTR OF BLOCK, WRITE IT AND FIND NEXT FREE BLOCK
         BAL   BALREG5,WRTSRCH         ***WRITE BLOCK***
*
*      NOW BUILD REMAINING INDEXES
*
         BCTR  LEVEL,0                 DECREMENT TO NEXT LEVEL
         BAL   BALREG1,MOVELVL         MOVE NEXT LEVEL NAME INTO 'NAME'
         MVI   TYPE,IPETYP             SET AS IPE
         CH    LEVEL,NAMLF             LESS THAN NO. OF LEVELS FOUND?
         BE    BLDXCHK                 BRANCH IF YES
         BL    ERR08                   ERROR CONDITION
*
*      ANOTHER INDEX LEVEL TO BUILD.
*
         BAL   BALREG1,KEYICE          BUILD KEY AND ICE AND 0 BLOCK
         XR    R1,R1                   SET R1 TO CORRECT LENGTH
         B     MOVENTRY                BRANCH AND PUT ENTRY INTO BUFFER
*
*
DLTXRTN  EQU   *
*
*      DELETE INDEX ROUTINE
*
*      THE ONLY POSSIBLE ENTRY TYPES AT THIS POINT ARE IPE AND ALIAS
*
         L     R0,TTR
         BAL   BALREG2,TOABSL          CONVERT TTR
         BAL   BALREG1,IO1             READ 20 BYTES INTO TEMPBUFF
         CLI   TEMPBUFF+1,X20          IS THERE AN ENTRY IN THE BLOCK?
         BNE   ERR12                   BRANCH IF YES--CAN'T DELETE
         CLI   TEMPBUFF+ALIASDSP,X00   CHECK ALIAS COUNT
         BNZ   ERR12                   CAN'T DELETE--HAS ALIASES
*      OK TO DELETE INDEX -- INDICATE TO CLC5 TO FREE BLK AT 'TTR'
         OI    FLAG3,FRBLK
         B     IGG0CLC5                GO TO CLC5 AND FREE BLK
*
*
BDLTARTN EQU   *
*
*      BUILD AND DELETE ALIAS ROUTINE
*
*      UPDATE THE ALIAS COUNT IN THE ICE AT 'TTR', AND PASS CONTROL
*      TO IGG0CLC5
*
         L     R0,TTR0                 GET TTR OF ICE
         IC    R0,ZERO                 ZERO THE COUNT FIELD
         BAL   BALREG2,TOABSL          CONVERT THE TTR
         MVC   OPTNCCW,RD              MOVE IN CCW TO READ DATA
         BAL   BALREG1,IO1             READ DATA INTO INPUT
*
*      UPDATE ALIAS COUNT OF ICE IN BLOCK JUST READ.
*
         XR    ALIASCNT,ALIASCNT       CLEAR
         IC    ALIASCNT,INDATA+ALIASDSP    GET ALIAS CNT
         LA    INTEGER,D01              PUT 1 IN ANOTHER REGISTER
*
*      IF FUNCTION IS BLDA, INCREMENT THE ALIAS COUNT
*      IF FUNCTION IS DLTA, DECREMENT THE ALIAS COUNT
*
         TM    CAMOPTN2,CAMBLDA        BLDA?
         BO    ADDREG                  BRANCH IF YES
*
*      DLTA FUNCTION.
*
         CLI TYPEB,ALIASTYP            ALIAS ENTRY?
         BNE ERR08                     BRANCH IF NO -- INCORRECT ENTRY
         LCR   INTEGER,INTEGER         COMPLEMENT INTEGER TO DECREMENT
*
ADDREG   EQU   *
*
         AR    ALIASCNT,INTEGER        MODIFY ALIAS COUNT
         STC   ALIASCNT,INDATA+ALIASDSP   UPDATE ALIAS CNT
*
*      ALIAS COUNT IN ICE UPDATED.  READY FOR WRITE.
*      INDICATE TO CLC5 TO WRITE UPDATED BLOCK
*
         OI    FLAG3,WRBLK+NEEDBLK
*      PREPARE FOR IGG0CLC5
         MVC   OUTDATA,INDATA          MOVE BLK TO OUTPUT BUFFER
         MVC   WRITETTR(L'TTR),TTR     INDICATE WHERE TO WRITE BLK
         B     IGG0CLC5                GO TO CLC5 TO WRITE BLK
         EJECT
*
****************
*              *
WRTSRCH  EQU   *
*              *
****************
*
* FUNCTION:
*    WRITE THE KEY AND DATA BLOCK AT 'OUTPUT' INTO THE FREE BLOCK
*    POINTED TO BY 'VFHOLE' - WRITE VERIFY WHAT WAS JUST WRITTEN AND
*    THEN SEARCH FOR A NEW FREE BLOCK.
*
* INPUT:
*    1)  RETURN ADDRESS IN BALREG3
*    2)  UPDATE OUTPUT BLOCK
*
* OUTPUT:
*    1)  PUT TTR0 OF BLOCK WRITTEN INTO 'TTR'
*    2)  BLOCK WRITTEN FROM BUFFER 'OUTPUT'
*    3)  NEW HOLE INTO VFHOLE
*
* DESTROYED:
*    NEXTCNT UPON FIRST HOLE SEARCH
*    VFHOLE IN VICE
*
* EXITS:
*         1)  TOABSL - TO CONVERT THE TTR
*         2)  IO - TO WRITE, WRITE VERIFY AND SEARCH FOR NEXT FREE
*             BLOCK.
*
***************
***************
*
         L     R0,VFHOLE               GET FREE BLOCK TTR
         ST    R0,TTR0                 SAVE TTR TO CONSTRUCT IPE
         BAL   BALREG2,TOABSL          CONVERT
         MVC   OPTNCCW,WKD             MOVE IN WRITE KEY AND DATA CCW
         BAL   BALREG1,IO1             WRITE BLOCK
         MVC   OPTNCCW,RKD             MOVE IN WRITE VERIFY CCW
         OI    OPTNCCW+4,CC            COMMAND CHAIN TO SEARCH NXT HOLE
         BAL   BALREG1,IO1             WRITE VERIFY
         LTR   R15,R15                 ANOTHER FREE BLK FOUND?
         BZ    CONTINUE                BRANCH IF YES
*
         OI    FLAG1,ERRFULL           SET ERROR FLAG FOR CLC5
         B     IGG0CLC5                GO TO CLC5 AND FREE BLKS
*
CONTINUE EQU   *
*
         BAL   BALREG2,TORLTV          CONVERT NEW FREE BLK ADDR TO TTR
         ST    R0,VFHOLE               PUT INTO VICE
         BR    BALREG5                 RETURN TO CALLER
         EJECT
****************
*              *
KEYICE   EQU   *
*              *
****************
*
* FUNCTION:
*    CONSTRUCT AN ICE ENTRY IN OUTPUT.  ALSO PUT IN AN FF KEY AND 32
*    IN THE BYTES USED FIELD OF THE DATA BLOCK.
*
* INPUT:
*    RETURN ADDRESS IN BALREG1
*
* OUTPUT:
*    KEY, BYTES USED FIELD, AND ICE IN OUTPUT
*    REMAINING BLOCK ZEROED
*    32 IN BYTES USED FIELD OF DATA BLOCK
*
* DESTROYED:
*    OUTPUT
*    OUTKEY
*    SAVETTR
*
***************
***************
*
         MVC   OUTKEY,HIBIN            PUT IN FF KEY
         XC    OUTDATA,OUTDATA         0 BLOCK
*      SET UP HALFWORD BYTE COUNT AND ICE
         MVI   OUTBYTSU+1,X20          HLFWD BYTE COUNT
         MVI   OUTICE+7,X01            SET ICE NAME
         MVI   OUTICECD,X03            SET ICE CODE
         MVC   OUTILBLK,VFHOLE         UPDATE THE LAST BLOCK ADDRESS
         MVC   OUTILL,VFHOLE           UPDATE THE INDEX LOWER LIMIT
         BR    BALREG1                 RETURN TO CALLER
         EJECT
*
****************
*              *
IO1      EQU   *
*              *
****************
*
* FUNCTION:
*    1.  IF THE DEVICE HAS THE RPS FEATURE, THE SET SECTOR CCW IS
*        UPDATED.
*    2.  ISSUE EXCP FOR THE CHANNEL PROGRAM POINTED TO BY THE IOB.
*    3.  WAIT FOR THE OPERATION TO COMPLETE AND CHECK THE ECB.
*    4.  IF AN END OF EXTENT CONDITION, BRANCH TO IGC0002H     @YL026UD
*        AND EXTEND THE CATALOG.                               @YL026UD
*    5.  IF A PERMANENT I/O ERROR, SET AN ERROR CODE AND BRANCH TO
*        IGG0CLC7.
*
* INPUT:
*    UPDATED CHANNEL PROGRAM
*    RETURN ADDRESS IN BALREG 1
*
* OUTPUT:
*    1.  FILLED BUFFER OR
*    2.  EMPTIED BUFFER OR
*    3.  ANOTHER FREE BLOCK ADDRESS
*
* DESTROYED:
*    REGISTERS R0,R1,R15 (IF EXTENDS)
*
* EXTERNAL ROUTINES USED:
*    EXCP, WAIT, IGC0002H TO EXTEND CATALOG                    @YL026UD
*
* EXITS:
*         IGC0002H TO EXTEND THE CATALOG                       @YL026UD
*         IGG0CLC7 FOR PERMANENT I/O ERROR
***************
***************
*
         TM    FLAG2,RPSDEV            RPS FEATURE?
         BZ    EXCP1                   BRANCH IF NO
         L     R1,RPSAVEP              GET RPS SAVE AREA PTR
         USING RPSD,R1
         STM   R9,R2,RPSAVE            SAVE REGISTERS TO BE DESTROYED
         LM    R15,R2,RPSINPUT         GET THETA CONVERT INPUT PARMS
         IC    R0,IOBSKADD+7           GET R OF CCHHR
         BALR  R14,R15                 CONVERT R TO THETA
*      NOTE: R1 AND R3 THROUGH R8 ARE NOT DESTROYED BY THE CONVERT
         LM    R9,R2,RPSAVE            RESTORE REGISTERS
*
*
EXCP1    EQU   *
*
         EXCP  IOB                     ISSUE EXCP
         WAIT  ECB=ECB                 WAIT FOR REQUEST
         XR    R15,R15                 SET RETURN CODE TO 0
         CLI   ECB,X7F                 NORMAL COMPLETION?
         BCR   8,BALREG1               BRANCH IF YES
         CLI   ECB,X42                 OUT OF EXTENT?
         BNE   ERR28                   NO, PERMANENT I/O ERROR
*
*      FALL THROUGH AND EXTEND CATALOG
*
         ST    BALREG1,SVBALREG        SAVE CURRENT BALREG1    @YL026UD
         L     R0,IOBDCB               GET DCB ADDRESS
         L     R2,OPENMOD              GET IGC0002H ADDRESS    @YL026UD
         BALR  BALREG1,R2              EXTEND                  @YL026UD
*
         L     BALREG1,SVBALREG        RESTORE SAVED BALREG1   @YL026UD
         CH    R15,H08                 NO MORE EXTENDS?
         BCR   8,BALREG1               RETURN IF YES
*
         LCR   R1,R15                  CHECK RETURN CODE
*
         BNZ   IGG0CLC7                BRANCH IF DID NOT EXTEND
         B     EXCP1                   RE-ISSUE REQUEST
         DROP  R1
         EJECT
*
****************
*              *
MOVELVL EQU    *
*              *
****************
*
* FUNCTION:
*    TO PUT THE CURRENT LEVEL NAME INTO THE 'NAME' WORKAREA LOCATION
*
* INPUT:
*    1)  RETURN ADDRESS IN BALREG1
*    2)  CURRENT LEVEL NUMBER IN REGISTER 'LEVEL'
*
* OUTPUT:
*    1)  CURRENT LEVEL IN 'NAME'
*    2)  REGISTER 'LEVEL' DECREMENTED BY 1
*
* DESTROYED:
*    1)  REGISTERS - R1,R2, AND R15
*
***************
***************
*
         MVI   NAME,CCDBLANK           INSERT BLANK
         MVC   NAME+1(L'NAME-1),NAME   BLANK NAME
         LA    R15,0(LEVEL,LEVEL)      DOUBLE LEVEL
*      SET R15 POINT TO THE DATA FOR THE LEVEL INDICATED BY 'LEVEL'
         LA    R15,NAMTABLE(R15)
         XR    R1,R1                   CLEAR R1
         IC    R1,0(R15)               GET DISPLACEMENT
         L     R2,CAMPTR1              GET POINTER NAME
         AR    R2,R1                   POINT TO LEVEL NAME
         IC    R1,D01(R15)             GET LENGTH
         EX    R1,MOVELVLN             MVC    NAME(0),0(R2)
         BR    BALREG1                 RETURN TO CALLER
         TITLE 'IGG0CLCD - (IGG0CLC4) ENTRY BUILDING'          @YL026UD
***********************************************************************
*                                                                     *
*     IGG0CLC4 - ENTRY BUILDING                                       *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLC4 EQU   *                                               @YL026UD
*
         DROP  R3
         DROP  R5
*
         USING WORKAREA,R6
         USING CAMLSTD,R8
*
         OI    MODMAP1,MODCLC4         INDIC ENTRY TO IGG0CLC4
*
*      INITIALIZE
*
         L     GIPE,FOUNDENT           SET BASE TO GIPE IF PRESENT
*
*      SAVE LENGTH OF ALL LEVELS OUT TO THE LAST LEVEL OF THE DATA
*      SET NAME IN CASE OF AN EVENTUAL SCRATCH.
*
*      TEST THE FUNCTION REQUESTED FOR CONSISTENCY WITH WHETHER OR NOT
*      THIS ENTRY WAS FOUND IN PHASE I.
*
         CLI   ERRLOCSV,ERROR00        WAS THE ENTRY FOUND?
         BE    FOUND                   YES
*
*      ENTRY NOT FOUND, CHECK FOR ALLOWABLE FUNCTIONS, CAT & CATBX.
*
         TM    CAMOPTN1,CAMCAT         IS FUNCTION CAT?
         BO    CATRTN                  YES
*
*      FUNCTION IS NOT COMPATIBLE WITH LOCATE RETURN CODE.
*
         B     ERR08                   NO
*
*
FOUND    EQU   *
*
*      ENTRY FOUND, CHECK FOR ALLOWABLE FUNCTIONS, RECAT & UNCAT
*
         TM    CAMOPTN1,CAMUNCAT       IS FUNCTION UNCAT?
         BO    ALTERTN                 YES
*
         OI    FLAG1,RECATF            SET RECAT SWITCH IN CASE
         TM    CAMOPTN1,CAMRECAT       IS FUNCTION RECAT?
         BO    ALTERTN                 YES
*
*      FUNCTION REQUESTED IS NOT COMPATIBLE WITH LOCATE RETURN CODE.
*
         B     ERR08                   ERROR EXIT
*
         EJECT
*
CATRTN   EQU   *
*
*      FUNCTION IS CAT OR CATBX
*
*      1.  COMPARE LEVELS GIVEN AND LEVELS FOUND.
*
*          .  (GIVEN)-(FOUND)=0, CATALOG ERROR CODE=8.
*
*          .  (GIVEN)-(FOUND)=1, FUNCTION IS CAT.
*
*          .  (GIVEN)-(FOUND)=2 OR MORE, DO 2.
*
*      2.  CHECK FUNCTION.
*
*          .  IF FUNCTION IS NOT CATBX, CATALOG ERROR CODE = 8.
*
*          .  IF FUNCTION IS CATBX, DO 3A OR 3B.
*
*      3A. IF A DSPE IS REQUIRED (FOR 5 OR FEWER VOLUMES), THE ENTRY
*          IS BUILT AND CONTROL IS PASSED TO IGG0CLC3 FOR THE BUILDING
*          OF MISSING INDEX LEVELS.
*
*      3B. IF A VCBPE IS REQUIRED (FOR 6 OR MORE VOLUMES), THE ENTRY
*          IS BUILT WITHOUT THE TTR FIELD AND CONTROL IS PASSED TO
*          IGG0CLC5 FOR THE BUILDING OF REQUIRED VCB'S.
*
*      COMPARE LEVELS GIVEN WITH LEVELS FOUND.
*
         LH    LEVEL2,NAMLG            GET NUMBER OF LEVELS GIVEN
         SH    LEVEL2,NAMLF            SUBTRACT NUMBER FOUND
         BNP   ERR08                   DIFFERENCE=0
*
         BCTR  LEVEL2,0                MINUS ONE
         LTR   LEVEL2,LEVEL2           RESULT ZERO?
         BZ    CATNOBLD                YES, DIFFERENCE=1
*
*      DIFFERENCE IS 2 OR MORE, CHECK FUNCTION
*
         TM    FLAG1,CATBXF            * IS FUNCTION CATBX?
         BZ    ERR16                   NO
*
*      FUNCTION IS CATBX.
*
         BAL   BALREG1,BLDENTRY        BUILD ENTRY
         TM    FLAG3,BLVCB             * MORE THAN 5 VOLUMES?
         BO    IGG0CLC5                YES, GO BUILD VCBS
*
         L     R5,SVRBEXTP             RESTORE BASE FOR CLC3
         B     IGG0CLC3                NO, GO BUILD INDEX LEVELS
*
         EJECT
*
CATNOBLD EQU   *
*
*
*      CHANGE CATBX FUNCTION TO CAT FUNCTION.
*
         NI    FLAG1,CATBXFC           * TURN OFF CATBXF
*
CATONLY  EQU   *
*
*      FUNCTION IS CAT
*
*      THE LAST BLOCK BLDL SEARCHED IS AT INPUT
*
         TM    FLAG2,GDGSW             GENERATION DATA SET?
         BZ    CULMINAT                NO
*
*      DATA SET NAME IS IN COMPLIMENT FORM (FROM IGG0CLC2) AT NAME
*
         BAL   BALREG1,SETUP           SET POINT AND LAST
*
CATCMPR  EQU   *
*
         USING ENTRY,POINT             ESTABL ADDRBLTY TO ENTRY
         CLC   EGENNO,GENNO            DO THE ABSOL NUMBERS MATCH?
         BNE   CATRTN1                 NO, GO LOOK AT NEXT ENTRY
*
         CLC   ENAME,NAME              ARE THE NAMES IDENTICAL?
         BNE   ALTER                   NO, SET RECAT            YA00092
         MVI   ERRLOCSV,ERROR00        YES,ZERO LOCATE CODE     YA00092
*                                      IN CASE NON-ZERO VERSION YA00092
         BE    ERR08                   DUPLICATE NAME
*
ALTER    OI    FLAG1,RECATF            * SET RECAT FLAG         YA00092
         B     ALTERTN                 GO TO ALTER ROUTINE
*
*
CATRTN1  EQU   *
*
         LR    R1,POINT                SAVE POINT TEMPORARILY
         BAL   BALREG1,INCR            INCREMENT 'POINT'
         CR    POINT,LAST              ANY MORE ENTRIES?
         BL    CATCMPR                 YES
*
         DROP  POINT
         USING ENTRY,GIPE              ESTABL ADDRBLTY TO GIPE
         CLC   EGMAXSIZ,EGCURSIZ+1     IS GROUP FULL?
         BNH   OPTION                  YES, GO PROCESS OPTIONS @OZ14792
*
*      ADD 1 TO GENERATION COUNT AND INDICATE A WRITE FOR IGG0CLC5
*
         LH    R1,EGCURSIZ             GET CURRENT SIZE OF GROUP
         LA    R1,D01(R1)              ADD ONE
         STH   R1,EGCURSIZ             UPDATE IN-CORE GIPE
         OI    FLAG3,WRBLK             * TURN ON WRITE BLOCK FLAG
         BAL   BALREG1,BLDENTRY        BUILD ENTRY
         B     IGG0CLC5                GO WRITE BLOCK WITH UPDATED GIPE
*
         EJECT
*
OPTION   EQU   *
*
*      GROUP IS FULL.  IF NEW ENTRY HAS GENERATION NUMBER GREATER
*      THAN THE GREATEST IN THE GROUP, THE NEW ENTRY WILL NOT BE ADDED.
*
         DROP  GIPE
         USING ENTRY,R1                POINT WAS SAVED IN R1
         CLC   EGENNO,GENNO            IS NEW ENTRY OLDER THAN LAST?
         BL    ERR24                   YES, RETURN TO ISSUER OF SVC 26
*
         DROP  R1
         USING ENTRY,GIPE              ESTABL ADDRBLTY TO GIPE
*
*      NAMED ENTRY WILL BE ADDED TO GENERATION DATA GROUP.
*      GROUP IS FULL AND OPTIONS MUST BE PROCESSED.
*
         TM    EGFLAGS,EGEMPTY         EMPTY SPECIFIED?
         BNO   REMOVLST                NO, REMOVE ONLY LAST ENTRY
*
*      EMPTY OPTION WAS SPECIFIED.
*
         MVI   EGCURSIZ+1,X01          UPDATE GIPE
         OI    FLAG3,EMPTY+WRBLK       * SET EMPTY & WRITE BLOCK FLAG
         TM    EGFLAGS,EGDELETE        DELETE SPECIFIED?
         BZ    CULMINAT                NO
*
*      START AT THE BEGINNING OF THE GENERATION DATA GROUP AND
*      SCRATCH ALL DATA SETS, READING NEW BLOCKS AS NECESSARY.
*
         CLC   ETTR,READTTR            TTR IN GIPE = TTR OF 'INPUT'?
         BE    NOREAD                  YES
*
         MVC   READTTR(L'ETTR),ETTR    GET TTR FROM GIPE
*
READ     EQU   *
*
         BAL   BALREG4,GET             ***READ BLOCK INTO INPUT***
*
NOREAD   EQU   *
*
         BAL   BALREG1,SETUP           SETUP 'POINT' AND 'LAST'
*
RECUR    EQU   *
*
         BAL   BALREG1,SCRATCH         SCRTCH ALL VOLS OF DS AT 'POINT'
         BAL   BALREG1,INCR            BUMP 'POINT' TO NEXT ENTRY
         CR    POINT,LAST              POINTING TO THE ILE?
         BL    RECUR                   NOT YET
*
         DROP  GIPE
         USING ENTRY,POINT             ESTABL ADDRBLTY TO ENTRY
         NC    ETTR,ETTR               ANOTHER BLOCK IN CHAIN?
         BZ    CULMINAT                NO
*
         MVC   READTTR(L'ETTR),ETTR    GET TTR FROM ILE
         B     READ                    GO READ THE NEXT BLOCK
*
         EJECT
*
REMOVLST EQU   *
*
*      STORE READTTR FOR POSSIBLE USE BY WRLSTRTN IN C5         YA00091
*      IF WE NOW HAVE THE LAST BLOCK                            YA00091
*                                                               YA00091
         MVC   SAVETTR3,READTTR        SAVE TTR OF BLK TO BE UPDATED
*                                                               YA00091
         CLC   ILSTBLK,READTTR         ALREADY HAVE THE LAST BLOCK?
         BE    FINDLAST                YES, GO SCAN IT FOR LAST ENTRY
*
         MVC   READTTR(L'ILSTBLK),ILSTBLK NO, GET TTR OF LAST BLOCK
         BAL   BALREG4,GET             ***READ BLOCK INTO INPUT***
*
FINDLAST EQU   *
*
*      ADJUST 'POINT' TO POINT TO ENTRY JUST PRECEDING THE INDEX LINK
*      ENTRY IN 'INPUT'.
*
         BAL   BALREG1,SETUP           SET UP 'POINT' AND 'LAST'
*                                                               SA52084
*      IF 'POINT' AND 'LAST' ARE EQUAL THEN THE BLK IS EMPTY,   SA52084
*      SO DO NOT SCAN THE BLK NOR DELETE THE LAST ENTRY.        SA52084
*                                                               SA52084
         CR    POINT,LAST              EQUAL?                   SA52084
         BE    SETFLG3                 BRANCH IF YES            SA52084
*
FINDSCAN EQU   *
*
*      SCAN BLOCK FOR THE LAST ENTRY.  LENGTH WILL CONTAIN LENGTH OF
*      ENTRY JUST PRECEDING INDEX LINK ENTRY.
*
         CR    POINT,LAST              THERE YET?
         BNL   FINDED                  YES
*
         BAL   BALREG1,INCR            BUMP POINT TO NEXT ENTRY
         B     FINDSCAN                CHECK AGAIN
*
*
FINDED   EQU   *
*
*      POINT POINTS TO LAST ENTRY (ILE) AND LENGTH CONTAINS THE LENGTH
*      OF THE PRECEDING ENTRY.
*      SUBTRACT LENGTH FROM POINT TO FIND THE LAST NON-'FF' ENTRY IN
*      THE BLOCK.
*
         SR    POINT,LENGTH            BACKUP ONE ENTRY
         USING ENTRY,POINT             EST. ADDRBLTY TO ENTRY   SA55225
*                                                               SA55225
*     CHECK FOR ANY DELETABLE VCBS                              SA55225
*                                                               SA55225
         CLI   ETYPE,VCBPETYP          VCBPE?                   SA55225
         BNE   TESTDLT                 BRANCH IF NO             SA55225
*                                                               SA55225
*     SET FLAG AND TTR FOR MODULE                               SA55225
*     IGG0CLC5 TO DELETE THE VCBS                               SA55225
*                                                               SA55225
         OI    FLAG3,FRVCB             * SET FREE VCB FLAG      SA55225
         MVC   DELTTR3(L'ETTR),ETTR    SAVE VCB CHAIN PTR       SA55225
*                                                               SA55225
*                                                               SA55225
TESTDLT  EQU  *                                                 SA55225
*                                                               SA55225
         DROP  POINT
         USING ENTRY,GIPE              EST ADDRBLTY TO GIPE
         TM    EGFLAGS,EGDELETE        DELETE SPECIFIED?
         BZ    DONTSCR                 NO
*
         BAL   BALREG1,SCRATCH         SCRATCH ALL VOLS OF LAST ENTRY
*
DONTSCR  EQU   *
*
         DROP  GIPE
         USING ENTRY,POINT             REESTABL PRIOR ADDRBLTY
         MVC   EINDEX,0(LAST)          MOVE ILE OVER LAST ENTRY
         LCR   LENGTH,LENGTH           PREPARE TO SUBTRACT
         AH    LENGTH,INBYTSU          DECREMENT BYTES USED BY LENGTH
         STH   LENGTH,INBYTSU          UPDATE IN-CORE BYTES USED FIELD
*                                                               SA52084
*                                                               SA52084
SETFLG3  EQU   *                                                SA52084
*                                                               SA52084
         OI    FLAG3,WRLST             * SET WRITE LAST FLAG
         B     CULMINAT                GO BUILD ENTRY          @YL026UD
*
         EJECT
*
ALTERTN  EQU   *
*
*      ALTER ROUTINE PROCESSES RECAT & UNCAT REQUESTS
*
*      CHECK FOR ANY DELETABLE VCBS
*
         CLI   TYPEB,VCBPETYP          VCBPE FOUND?
         BNE   VCBSNONE                NO
*
         MVC   DELTTR3(L'TTR),TTR      GET VCB CHAIN POINTER
         OI    FLAG3,FRVCB             * SET FREE VCB FLAG
*
*      STARTING TTR OF VCB CHAIN IS IN DELTTR3 AND FRVCB FLAG IS ON
*      FOR IGG0CLC5, AS AN INDICATION TO DELETE THOSE VCBS.
*
VCBSNONE EQU   *
*
*      CHECK FUNCTION
*
         TM    CAMOPTN1,CAMUNCAT       REQUESTED FUNCTION UNCAT?
         BO    CHEKGDG                 YES
*
         TM    FLAG1,RECATF            * REQUESTED FUNCTION RECAT?
         BNO   ERR08                   NO
*
*      FUNCTION IS RECAT, BUILD A NEW ENTRY.
*
         B     CULMINAT                GO BUILD ENTRY          @YL026UD
*
*
CHEKGDG  EQU   *
*
*      FUNCTION IS UNCAT
*      CHECK FOR GDG OR NON-GDG, FOR GIPE PROCESSING
*
         TM    FLAG2,GDGSW             * GDG PROCESSING?
         BNO   NEXTLOAD                NO
*
*      ESTABLISH ADDRESSABILITY TO THE GIPE
*
         DROP  POINT
         USING ENTRY,GIPE              ESTABL ADDRBLTY TO GIPE
*
*      UPATE GIPE & INDICATE NEED TO WRITE IT
*
         LH    R1,EGCURSIZ             GET CURRENT SIZE OF GROUP
         BCTR  R1,0                    MINUS ONE
         STH   R1,EGCURSIZ             UPDATE IN-CORE CURRENT SIZE
         OI    FLAG3,WRBLK             * SET WRITE BLOCK FLAG
*
*      BLOCK IS IN 'OUTPUT' & ITS TTR IS IN 'WRITETTR'
*      'WRBLK' SWITCH IS SET FOR IGG0CLC5
*
         DROP  GIPE
         B     IGG0CLC5                BRANCH TO IGG0CLC5      @YL026UD
*
         EJECT
*
CULMINAT EQU   *
*
*      BUILD THE REQUIRED ENTRY AND BRANCH TO THE APPROPRIATE MODULE.
*
         BAL   BALREG1,BLDENTRY        GO BUILD ENTRY
*
NEXTLOAD EQU   *
*
*      THE NEXT MODULE IS DETERMINED BY WHETHER OR NOT SPECIAL
*      PROCESSING IS REQUIRED. IF IT IS, IGG0CLC5 IS  BRANCHED TO
*      TO FREE AND WRITE ANY VCB'S, WRITE ANY NEW INDEX        @YL026UD
*      BLOCKS, AND PROCESS EMPTY REQUESTS.
*
*      IF NO SPECIAL PROCESSING IS REQUIRED, IGG0CLC5 IS
*      BYPASSED AND IGG0CLC6 IS THE NEXT MODULE TO RECEIVE CONTROL.
*
         TM    FLAG3,WRBLK+FRVCB+BLVCB+WRLST+EMPTY * NEED IGG0CLC5?
         BZ    IGG0CLC6                NO
*
         B     IGG0CLC5                YES
*
         EJECT
*
****************
*              *
TOABSL2  EQU   *
*              *
****************
*
* FUNCTION:
*    CONVERT THE TTR0 IN R0 TO AN ABSOLUTE DASD ADDRESS AND
*    PUT IT INTO THE IOB MBBCCHHR
*
* INPUT:
*    R0 IS THE TTR0 TO BE CONVERTED
*    RETURN ADDRESS IN BALREG2
*
* OUTPUT:
*    ABSOLUTE DASD ADDRESS IN IOB
*    ERROR CODE IN R15
*
* DESTROYED:
*    REGISTERS - R0,R1,R2,R14, AND R15=0
*    WA - SAVEAREA AND MBBCCHHR OF THE IOB
*
* SUBROUTINES USED:
*         THE RESIDENT CONVERT ROUTINE - IECPCNVT
*
*
***
*
         L     R15,EPTOABSL            GET EP TO 'IECPCNVT'
         STM   R9,R13,SAVEAREA         SAVE REGS DESTROYED BY CONVERT
         L     R1,DEBADDR              GET DEB ADDRESS
         LA    R2,IOBSKADD             POINT TO MBBCCHHR
         BALR  BALREG1,R15             GO TO CONVERT
         LM    R9,R13,SAVEAREA         RESTORE REGISTERS
         BR    BALREG2                 RETURN
*
         EJECT
*
****************
*              *
IO2      EQU   *
*              *
****************
*
* FUNCTION:
*    1.  IF THE DEVICE HAS THE RPS FEATURE, THE SET SECOTR CCW IS
*        UPDATED.
*    2.  ISSUE EXCP FOR THE CHANNEL PROGRAM POINTED TO BY THE JOB.
*    3.  WAIT FOR THE OPERATION TO COMPLETE AND CHECK THE ECB.
*    4.  IF AN END OF EXTENT CONDITION, BRANCH TO IGC0002H     @YL026UD
*        AND EXTEND THE CATALOG.                               @YL026UD
*    5.  IF A PERMANENT I/O ERROR, SET AN ERROR CODE AND BRANCH TO
*        IGG0CLC7.
*
* INPUT:
*    UPDATED CHANNEL PROGRAM
*    RETURN ADDRESS IN BALREG 1
*
* OUTPUT:
*    1.  FILLED BUFFER
*    2.  EMPTIED BUFFER
*    3.  ANOTHER FREE BLOCK ADDRESS
*
* DESTROYED:
*    REGISTERS R0,R1,R15 (IF EXTENDS), AND ERRCAT
*
* EXTERNAL ROUTINES USED:
*    EXCP, WAIT, IGC0002H TO EXTEND CATALOG                    @YL026UD
*
* EXITS:
*         IGG0CLC7 FOR PERMANENT I/O ERROR
***
*
         USING RPSD,R1                 ESTABL BASE TO RPS WORKAREA
         TM    FLAG2,RPSDEV            RPS FEATURE?
         BZ    EXCP2                   BRANCH IF NO
*
         L     R1,RPSAVEP              GET RPS SAVE AREA PTR
         STM   R9,R2,RPSAVE            SAVE REGS DESTROYED BY CONVERT
         LM    R15,R2,RPSINPUT         GET THETA CONVERT INPUT PARMS
         IC    R0,IOBSKADD+7           GET R OF CCHHR
         BALR  BALREG1,R15             GO TO CONVERT R TO THETA
         LM    R9,R2,RPSAVE            RESTORE REGISTERS
*
EXCP2    EQU   *
*
         EXCP  IOB                     ISSUE EXCP
         WAIT  ECB=ECB                 WAIT FOR REQUEST
         CLI   ECB,X7F                 I/O ERROR?
         BCR   8,BALREG1               BRANCH IF NO
*
         B     ERR28                   ERROR EXIT
*
         DROP  R1
*
         EJECT
*
****************
*              *
GET      EQU   *
*              *
****************
*
* FUNCTION:
*    CONVERTS READTTR INTO AN ABSOLUTE ADDRESS AND READS THE BLOCK
*    AT THAT ADDRESS INTO INPUT.
* INPUT:
*    READTTR,BALREG3 IS RETURN REGISTER
* OUTPUT:
*    INDEX BLOCK AT INPUT,MBBCCHHR OF BLOCK AT MBBCCHHR
* DESTROYED:
*    BALREG2,R0,OPTNCCW
* SUBROUTINES USED:
*    TOABSL,IO
***
*
         L     R0,READTTR              GET TTR FOR CONVERSION
         BAL   BALREG2,TOABSL2         CONVERT FOR IO
         MVC   OPTNCCW,RD              MOVE READ DATA CCW
         BAL   BALREG1,IO2             READ 256 BYTE BLOCK INTO 'INPUT'
         BR    BALREG4                 RETURN
*
         EJECT
*
****************
*              *
SETUP    EQU   *
*              *
****************
*
* FUNCTION:
*    SETS TWO REGISTERS, POINT AND LAST, TO POINT TO THE FIRST ENTRY
*    IN INPUT AND THE LAST ENTRY IN INPUT, RESPECTIVELY.
* INPUT:
*    INBLKSZ,H12,BALREG1 IS RETURN REGISTER
* OUTPUT:
*    POINT,LAST
* DESTROYED:
*    NOTHING
* SUBROUTINES USED:
*    NONE
***
*
         LA    POINT,INENTRY           ADDRESS OF FIRST ENTRY
         LA    LAST,INBYTSU            ADDR OF HALFWORD BLOCK SIZE
         AH    LAST,INBYTSU            POINT TO END OF ILE
         SH    LAST,H12                SUBTRACT LENGTH OF ILE
         BR    BALREG1                 RETURN
*
         EJECT
*
****************
*              *
INCR     EQU   *
*              *
****************
*
* FUNCTION:
*    ADJUSTS POINT TO POINT TO THE NEXT ENTRY IN INPUT
* INPUT:
*    ETYPE,POINT,BALREG1 IS RETURN REGISTER
* OUTPUT:
*    POINT,LENGTH
* DESTROYED:
*    NOTHING
*
***
*
         USING ENTRY,POINT             ESTABL BASE FOR ENTRY
         SR    LENGTH,LENGTH           ZERO LENGTH
         IC    LENGTH,ETYPE            PICK UP ENTRY TYPE
*
*      TOTAL LENGTH OF THE ENTRY IS 12 + 2*(ETYPE)
*
         LA    LENGTH,D12(LENGTH,LENGTH)    CALCULATE LENGTH
         AR    POINT,LENGTH            ADJUST POINT
         BR    BALREG1                 POINT IS AT NEXT ENTRY
*
         DROP  POINT
*
         EJECT
*
****************
*              *
BLDENTRY EQU   *
*              *
****************
*
* FUNCTION:
*    BUILDS AN ENTRY TO REPRESENT THE DATA SET LEVEL OF A QUALIFIED
*    NAME.
*    1.  IF A VCB IS REQUIRED, A VCBPE IS BUILT.  SINCE THIS MODULE
*        DOES NOT WRITE IN THE SYSCTLG DATA SET, A SWITCH (BLVCB)
*        IS TURNED ON TO INDICATE TO PHASE III THAT A CHAIN OF VCB'S
*        REQUIRE BUILDING.
*    2.  IF A VCB IS NOT REQUIRED, A DSPE IS BUILT.  IF THE NUMBER
*        OF VOLUMES IS ONE, THE DSCBTTR OPTION IS PROCESSED.
*        N.B.  IF THE FUNCTION IS CATBX AND CONTROL IS RETURNING TO
*        CLC3, THE VOLUME LIST IS NOT APPENDED TO THE ENTRY AT THIS
*        POINT, BECAUSE NAMTABLE MUST BE PRESERVED.
*    THE ENTRY IS BUILT STARTING AT NAME IN THE WORKAREA AND CONTINUING
*    THRU AS MANY BYTES AS ARE NECESSARY, NOT OVER 74.
* INPUT:
*    BITS USED AS SWITCHES ARE DESIGNATED "BYTE(BIT,BIT,...)"
*    CAMPTR3,H06,CAMDSCBP,VOLUME LIST,CAMOPTN2(CAMDSCBT),MOVE1,
*    FLAG1(CATBXF),CAMOPTN1(CAMRECAT),BALREG1 IS RETURN REGISTER
* OUTPUT:
*    BITS SET AS SWITCHES ARE DESIGNATED "BYTE(BIT,BIT,...)"
*    TTR,TYPE,     VOLCNT,DATA,FLAG3(BLVCB)
*
* DESTROYED:
*    R1,R2
*
* SUBROUTINES USED:
*    NONE
***
*
*      DECIDE WHAT TYPE OF ENTRY TO BUILD, VCBPE OR DSPE.
*
         L     R1,CAMPTR3              POINT TO VOLUME LIST
         LH    TALLY,0(R1)             GET THE COUNT
*                                                               SA53641
         LTR   TALLY,TALLY                                      SA53641
         BNP   ERR08                                            SA53641
*                                                               SA53641
         CH    TALLY,H06               VCB REQUIRED?
         BL    BLDDSPE                 GO BUILD DSPE
*
*      VCB'S ARE REQUIRED.  INDICATE SO FOR PHASE III.
*
         MVI   TYPE,VCBPETYP           MOVE IN ENTRY TYPE
         XC    VOLCNT,VOLCNT           CLEAR LAST HFWD OF ENTRY
         OI    FLAG3,BLVCB             INDIC NEED TO BUILD VCBS
         BR    BALREG1                 RETURN
*
*
BLDDSPE  EQU   *
*
*      DSPE IS REQUIRED.
*
*      CALCULATE NUMBER OF HALFWORDS REQUIRED TO CONTAIN VOLUME LIST;
*      (NO. OF HALFWORDS) = 6*(NO. OF VOLUMES) + 1
*
*      RESULT GOES IN THE TYPE FIELD OF THE ENTRY.
*
         MH    TALLY,H06               MULTIPLY BY 6
         LA    TALLY,D01(TALLY)        ADD ONE
         STC   TALLY,TYPE              MOVE IN THE ENTRY TYPE
*
*      DECIDE WHETHER OR NOT TO APPEND VOLUME LIST TO ENTRY.
*
         TM    FLAG1,CATBXF            * IS FUNCTION CATBX?
         BO    BLDLATER                YES, DON'T APPEND
*
*      FUNCTION IS NOT CATBX.  COMPLETE THE ENTRY.
*
         SLL   TALLY,1                 DOUBLE NUMBER OF HALFWORDS
         BCTR  TALLY,0                 MINUS ONE FOR EXECUTE
         EX    TALLY,MOVE1             MVC   VOLCNT(0),0(R1)
*
BLDLATER EQU   *
*
*      CHECK FOR DSCBTTR PROCESSING
*
         CLI   TYPE,DSPETYP            ONLY ONE VOLUME?
         BNE   BLDCLEAR                NO, DON'T PROCESS DSCBTTR OPTION
*
         TM    CAMOPTN2,CAMDSCBT       DSCBTTR SPECIFIED?
         BO    BLDDSCBT                YES
*
*      DSCBTTR IS NOT SPECIFIED, SET TO ZERO                    SA52095
*
*
BLDCLEAR EQU   *
*
*      ZERO TTR FIELD AND RETURN
*
         XC    TTR,TTR                 3 BYTES OF ZEROS IN TTR
         BR    BALREG1                 ENTRY IS BUILT
*
*
BLDDSCBT EQU   *
*
*      TTR OF DSCB OF NAMED DATA SET IS SPECIFIED.
*
         L     R1,CAMDSCBP             POINT TO 3 BYTE DSCBTTR
         MVC   TTR,0(R1)               MOVE IN DSCBTTR
         BR    BALREG1                 ENTRY IS BUILT
*
         EJECT
*
****************
*              *
SCRATCH  EQU   *
*              *
****************
*
* FUNCTION:
*    RELEASES SPACE ALLOCATED TO DATA SET NAMED AT POINT.  MAY RESIDE
*    ON MORE THAN ONE VOLUME.  ROUTINE SCRATCHES UP TO 20 VOLUMES
*    AT A TIME UNTIL ALL SPACE HAS BEEN RELEASED.
* INPUT:
*    CAMPTR1, USER-PASSED DATA SET INDEX LEVELS, LASTLEV,MOVE2,
*    POINT, ENTRY AT POINT, MASKFF, SCROPTN, VCB'S IF PRESENT.
*    BALREG1 IS RETURN REGISTER
* OUTPUT:
*    NOTHING
* DESTROYED:
*    DSNAME,LEN,DSN,SCRPARM,R0,R1,R3,VCBMAIN,BALREGS,BALREG2
* SUBROUTINES USED:
*    GETMAIN SERVICE ROUTINE, FREEMAIN SERVICE ROUTINE, TOABSL,
*    IO, SCRATCH SERVICE ROUTINE.
***
*
         USING ENTRY,POINT             ESTABL ADDRBLTY TO ENTRY
*
*      SETUP PARAMETERS FOR SCRATCH
*
*      BUILD THE NAME
*
         MVI   DSNAME,CCDBLANK         MOVE IN A BLANK
         MVC   DSNAME+1(L'DSNAME-1),DSNAME CLEAR THE DSNAME AREA
         L     DSN,CAMPTR1             POINT TO NAME
         XR    LEN,LEN                 ZERO 'LEN'
         IC    LEN,INDEXLEN            GET LNGTH OF ALL BUT LAST LVL
*
*      MOVE ALL BUT LAST LEVEL INTO 'DSNAME', INCLUDING LAST DELIMITER
*
         BCTR  LEN,0                   MINUS ONE FOR EXECUTE
         EX    LEN,MOVE2               MVC DSNAME(0),0(DSN)
*
*      POINT TO WHERE LAST LEVEL WILL GO.  '+1' IS TO CORRECT FOR
*      BCTR ON LEN.
*
         LA    LEN,DSNAME+1(LEN)
         TM    ENAME,XFF               ICE OR ILE?
         BCR   11,BALREG1              YES, DON'T SCRATCH IT
*
         MVC   0(L'ENAME,LEN),ENAME    APPEND LAST LEVEL
         DROP  POINT
         USING ENTRY,LEN               ESTABL ADDRBLTY TO GEN DSPE
         XC    EGENNO,MASKFF           COMPLIMENT GENERATION NUMBER
         DROP  LEN
         USING ENTRY,POINT             REESTABL ADDRBLTY
*
*      BUILD THE SCRATCH CAMLST
*
         TM    CAMOPTN3,CAMTIOT        IS TIOT ENQUED?         @OZ19636
         BZ    SCROPTNA                NO, BR TO CONTINUE      @OZ19636
*
*    TEST CALLER AUTHORIZATION                                 @OZ19636
*
         LR    R9,R14                  SAVE R14                @OZ19636
         STM   R0,R3,SVAREA4           SAVE REGS               @OZ27009
         TESTAUTH FCTN=1,STATE=YES,KEY=YES,BRANCH=YES,RBLEVEL=2
         LR    R14,R9                  RESTORE R14             @OZ19636
         LM    R0,R3,SVAREA4           RESTORE REGS            @OZ27009
         LTR   R15,R15                 CALLER AUTHORIZED?      @OZ19636
         BNZ   SCROPTNA                NO, BR AROUND           @OZ19636
         L     R0,SCROPTN2             SET TIOT ENQUED OPTION  @OZ19636
*                                    AND ALL OTHER SCRATCH OPTIONS
         B     SCROPTNB                                        @OZ19636
SCROPTNA EQU   *
         L     R0,SCROPTN              GET OPTION BYTES
SCROPTNB EQU   *
         LA    R1,DSNAME               GET ADDR OF FULLY QUALIFIED NAME
         STM   R0,R1,SCRPARM           FRST TWO WRDS OF SCRATCH CAMLST
*
*      THIRD WORD OF SCRATCH CAMLST IS NOT USED.
*      FOURTH WORD CONTAINS ADDRESS OF THE VOLUME LIST.
*      1.  IF THE DATA SET RESIDES ON FROM 1 THRU 5 VOLUMES, THE
*          ADDRESS OF THE VOLUME LIST IS EVOLCNT IN INPUT.
*      2.  IF THE DATA SET RESIDES ON 6 OR MORE VOLUMES, THE ADDRESS
*          OF THE VOLUME LIST IS THE ADDRESS OF A 256 BYTE GETMAIN
*          AREA OBTAINED FOR THE PURPOSE OF READING VCB'S.
*
         CLI   ETYPE,VCBPETYP          IS ENTRY A VCBPE?
         BNE   SCR1TO5                 NO
*
*      GETMAIN TO SERVE AS AN INPUT BUFFER
*
         USING VCBD,VCBMAIN2           VCBMAIN2 EQU R11
         LA    R0,BLOCK                GET SIZE OF AREA         SA53664
         GETMAIN R,LV=(0)
         ST    R1,SVVCBLK4             SAVE BLOCK PTR (ESTAE)  @YL026UD
         LR    VCBMAIN2,R1             SET BASE FOR AREA
         ST    VCBMAIN2,SCRVOLS        FOURTH WORD OF SCRATCH CAMLST
*
*      SAVE RETURN SO THAT SCRATCHY CAN BE LINKED TO REPETITIVELY
*      FROM THIS VCB PROCESSING PORTION.
*
         ST    BALREG1,BALREGS         SAVE RETURN REG
*
*      GET TTR OF FIRST VCB OF CHAIN FROM THE VCBPE
*
         MVC   SAVEAREA(L'ETTR),ETTR   MOVE IT INTO A WORD
         L     R0,SAVEAREA             PREPARE FOR CONVERT
         IC    R0,ZERO                 ZERO TYPE, ETTR IS 3-BYTE FIELD
*
*      SETUP TO READ DATA INTO GETMAIN AREA
*
         MVC   OPTNCCW,RD              MOVE IN CCW TO READ DATA
         ST    VCBMAIN2,OPTNCCW        MOVE IN ADDRESS
         MVI   OPTNCCW,RDOP            MOVE IN READ DATA OP-CODE
*
SCREAD   EQU   *
*
         BAL   BALREG2,TOABSL2         CONVERT TTR
         BAL   BALREG1,IO2             READ DATA INTO VCBMAIN
*
*      SET VOLUME COUNT FOR SCRATCH
*
         LA    R0,D20                  GET 20 FOR COMPARAND
         CH    R0,VCBVOLCT             MORE VOLUMES THAN IN THIS LIST?
         BNL   SCRLAST                 NO, VOLUME COUNT IS GOOD
*
         STH   R0,VCBVOLCT             YES, CORRECT SIZE OF LIST = 20
*
SCRLAST  EQU   *
*
*      CALL 'SCRATCHY' FOR THIS LIST
*
         BAL   BALREG1,SCRATCHY        SCRATCH A SET OF VOLUMES
*
*      PREPARE FOR NEXT READ
*
         L     R0,VCBLNK               GET TTR OF NEXT VCB
         LTR   R0,R0                   IS THERE A NEXT BLOCK
         BNZ   SCREAD                  YES, GO READ IT
*
*      END OF VCB CHAIN, FREEMAIN AND RETURN
*
         LA    R0,BLOCK                GET THE SIZE OF THE AREA
         LR    R1,VCBMAIN2             GET THE ADDRESS OF THE AREA
         XC    SVVCBLK4(4),SVVCBLK4    RESET BLOCK PTR (ESTAE) @YL026UD
         FREEMAIN R,LV=(0),A=(1)
         L     BALREG1,BALREGS         RESTORE RETURN REG
         BR    BALREG1                 RETURN
*
*
SCR1TO5  EQU   *
*
*      ENTIRE VOLUME LIST IS CONTAINED IN DSPE
*
         LA    R0,EVOLCNT              POINT TO VOLUME LIST
         ST    R0,SCRVOLS              FOURTH WORD OF SCRATCH CAMLST
*
SCRATCHY EQU   *
*
*      ISSUE SCRATCH MACRO & RETURN VIA BALREG1
*
         SR    R0,R0                   ZERO 'R0'
         SCRATCH SCRPARM
         BR    BALREG1                 RETURN
*
         DROP  VCBMAIN2
         DROP  POINT
*
         TITLE 'IGG0CLCD - (IGG0CLC5) FIRST LOAD OF UPDATE'    @YL026UD
***********************************************************************
*                                                                     *
*     IGG0CLC5 - FIRST LOAD OF UPDATE                                 *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLC5 EQU   *                                               @YL026UD
*
         USING CAMLSTD,R8
         USING WORKAREA,R6
         OI    MODMAP1,MODCLC5         INDIC ENTRY TO IGG0CLC5
         TM    FLAG1,ERRFULL           * BEING ENTERED TO CLEAN UP?
         BO    ERRTN                   YES, GO DELETE INDEX STRUCTURE
*
*      START THE UPDATE PROCESS.  SINCE SYSCTLG IS GOING TO BE WRITTEN
*      IN, OTHER TASKS IN THE REGION MUST BE NON-DISPATCHABLE.
*
         USING SVRBEXTD,R1             ESTABL ADRBLTY TO SVRBEXT Y01965
         L     R1,SVRBEXTP             POINT TO PARAMETER LIST
         TM    ENQFLAGS,SMCSTEP        SMC ALREADY ISSUED?       Y01965
         BO    SMCSKIP                 BRANCH IF YES             Y01965
*                                                                Y01965
         OI    ENQFLAGS,SMCSTEP        SET ENQ TO SMC            Y01965
         ENQ   ,MF=(E,(1))             DISABLE STEP TASKS        Y01965
         DROP  R1                                                Y01965
*                                                                Y01965
SMCSKIP  EQU   *                                                 Y01965
*                                                                Y01965
*
*      CHECK0
*
*      CHECK FOR REQUEST TO FREE INDEX LEVELS FOR UCATDX FUNCTION.
*
         NC    DELTTR1,DELTTR1         NEED TO FREE INDEX BLOCKS?
         BZ    CHECK1                  NO
*
         BAL   BALREG3,FRNDXRTN        YES, CALL FREE INDEX ROUTINE
         B     RESTORE                 GO MOVE BLK TO BE UPDTD TO INPUT
*
*
CHECK1   EQU   *
*
*      CHECK FOR REQUEST TO FREE A CHAIN OF VCB'S.
*
         TM    FLAG3,FRVCB             * NEED TO FREE VCB'S?
         BNO   CHECK2                  NO
*
         BAL   BALREG3,FRVCBRTN        YES, CALL FREE VCB ROUTINE
*
CHECK2   EQU   *
*
*      CHECK FOR REQUEST TO FREE A BLOCK FOR DLTX FUNCTION.
*
         TM    FLAG3,FRBLK             * NEED TO FREE BLOCK?
         BNO   CHECK3                  NO
*
         L     R0,TTR0                 GET ADDR OF BLOCK
         BAL   BALREG3,FRBLKRTN        YES, CALL FREE BLOCK ROUTINE
*
CHECK3   EQU   *
*
*      CHECK FOR REQUEST TO WRITE THE BLOCK CONTAINING AN UPDATED GIPE.
*
         TM    FLAG3,WRBLK             * NEED TO WRITE A BLOCK?
         BNO   CHECK4                  NO
*
         BAL   BALREG3,WRBLKRTN        YES, CALL WRITE BLOCK ROUTINE
*
CHECK4   EQU   *
*
*      CHECK FOR A REQUEST TO REWRITE THE NEW LAST BLOCK OF A CHAIN
*      OF GENERATION DATA SET POINTERS
*
         TM    FLAG3,WRLST             * NEED TO WRITE LAST?
         BNO   SAVE                    NO
*
         BAL   BALREG3,WRLSTRTN        YES, CALL WRITE LAST ROUTINE
*
*
SAVE     EQU   *
*
*      SAVE THE BLOCK IN INPUT BY MOVING IT TO OUTPUT AND ITS TTR
*      FROM READTTR TO WRITETTR.
*
*      IT MAY BE:
*
*      1.  THE BLOCK TO BE UPDATED, IF WRLST IS NOT ON.  THIS WILL
*          BE PASSED TO THE NEXT LOAD OF UPDATE.
*
*      2.  THE BLOCK WHICH WRLSTRTN WAS REQUESTED TO WRITE.
*
*      IF WRLST IS ON AND THE BLOCK DOES NOT CONTAIN AN ICE, THE
*      BLOCK WAS ACTUALLY WRITTEN AND THIS IS A MEANINGLESS MOVE.
*
*      IF WRLST IS ON AND THE BLOCK DOES CONTAIN AN ICE, THE BLOCK
*      WAS NOT WRITTEN AND THIS MOVE SAVES IT FOR THE NEXT LOAD OF
*      UPDATE.
*
         MVC   OUTDATA,INDATA          SAVE THE BLOCK
         MVC   WRITETTR,READTTR        SAVE ITS TTR
         XC    READTTR,READTTR         CLEAR READTTR
*
*      CHECK5
*
*      CHECK FOR REQUEST TO PROCESS EMPTY OPTION FOR A FULL GENERATION
*      DATA GROUP.
*
         TM    FLAG3,EMPTY             * NEED TO EMPTY GDG?
         BNO   RESTORE                 NO
*
         BAL   BALREG3,EMPTYRTN        YES, CALL EMPTY ROUTINE
*
*
RESTORE  EQU   *
*
*      MOVE BLOCK AND TTR BACK INTO INDATA
*
         MVC   INDATA,OUTDATA          MOVE BLOCK BACK TO 'INDATA'
         MVC   READTTR,WRITETTR        MOVE TTR BACK TO 'READTTR'
         XC    WRITETTR,WRITETTR       CLEAR 'WRITETTR'
*
*
*      CHECK6
*
*      CHECK FOR REQUEST TO BUILD A CHAIN OF VCB'S.
*
         TM    FLAG3,BLVCB             * NEED TO BUILD VCB'S?
         BNO   NXTLOAD                 NO
*
         BAL   BALREG3,BLVCBRTN        YES, CALL BUILD VCB ROUTINE
*
NXTLOAD  EQU   *
*
         TM    FLAG1,CATBXF            * REQUESTED FUNCTION CATBX?
         BNO   IGG0CLC6                NO, GO UPDATE
*
         L     R5,SVRBEXTP             RESTORE BASE FOR CLC3
         B     IGG0CLC3                YES, GO BUILD NEEDED INDICES
*
         EJECT
*
****************
*              *
WRBLKRTN EQU   *
*              *
****************
*
* FUNCTION:
*    WRITES THE BLOCK FROM OUTPUT AT THE ADDRESS IN WRITETTR.
*
* INPUT:
*    OUTPUT,WRITETTR,BALREG3 IS RETURN REGISTER
*
* OUTPUT:
*    NONE
*
* DESTROYED:
*    R0,BALREG2,BALREG1,OPTNCCW
*
* SUBROUTINES USED:
*    TOABSL,IO
***
*
*
*      WRITE THE BLOCK.
*
*      IT IS IN 'OUTDATA' AND ITS TTR IS IN 'WRITETTR'.
*
         L     R0,WRITETTR             GET WRITE ADDRESS
         BAL   BALREG2,TOABSL          CONVERT IT
         LA    R0,OUTDATA              GET ADDRESS OF BUFFER
         MVC   OPTNCCW,RD              GET SKELETON CCW
         ST    R0,OPTNCCW              MOVE IN ADDRESS
         BAL   BALREG2,WRITE           ***WRITE DATA FROM OUTPUT***
         BR    BALREG3                 RETURN
*
         EJECT
*
****************
*              *
WRLSTRTN EQU   *
*              *
****************
*
* FUNCTION:
*    WRITES THE LAST BLOCK OF A CHAIN OF DATA SET LEVEL POINTERS IN
*    GENERATION DATA GROUP.  IGG0CLC4 HAS PREVIOUSLY REMOVED THE
*    LAST ENTRY TO MAKE ROOM IN THE GROUP FOR THE NEW ENTRY.
*    IF THE LAST BLOCK IS ALSO THE FIRST BLOCK, IT IS SAVED FOR
*    FURTHER UPDATING (IN THE ICE), TO BE DONE BY IGG0CLC7.
*
* INPUT:
*    INPUT,READTTR,BALREG3 IS RETURN REGISTER.
*
* OUTPUT:
*    NONE
*
* DESTROYED:
*    POINT,R0,BALREG2,OPTNCCW
*
* SUBROUTINES USED
*    TOABSL,IO
***
*
*
*      ESTABLISH ADDRESSABILITY FOR THE FIRST ENTRY IN THE BLOCK TO
*      BE WRITTEN.  IF THE FIRST ENTRY IS AN ICE, THE BLOCK WILL
*      NOT BE WRITTEN; THE BLOCK IS SAVED SO THAT WHEN THE ICE
*      IS UPDATED, A READ IS NOT REQUIRED.
*
         LA    POINT2,INENTRY          GET ADDRESS OF FIRST ENTRY
         USING ENTRY,POINT2            ESTABL ADDRBLTY TO ENTRY
         CLI   ETYPE,ICETYP            IS ENTRY AN ICE?
         BCR   8,BALREG3               YES, DO NOT WRITE THE BLOCK
*
*      WRITE THE BLOCK.  IT IS IN INPUT AND ITS TTR IS IN READTTR.
*
         L     R0,READTTR              GET WRITE ADDRESS
         BAL   BALREG2,TOABSL          CONVERT IT
         MVC   OPTNCCW,RD              MOVE IN READ DATA CCW
         BAL   BALREG2,WRITE           ***WRITE DATA FROM INPUT***
         MVC   READTTR,SAVETTR3        SET TTR TO BLK TO BE UPDATED
         OI    FLAG3,NEEDBLK           * SET FLAG SO C6 WILL READ BLK
         BR    BALREG3                 RETURN
*
         DROP  POINT2
*
         EJECT
*
****************
*              *
EMPTYRTN EQU   *
*              *
****************
*
* FUNCTION:
*    PROCESSES A REQUEST TO EMPTY A GENERATION DATA GROUP.
*    1.  READS BLOCK.
*    2.  REMOVES ALL VCB'S POINTED TO FROM BLOCK.
*    3.  MOVES NEW ENTRY INTO FIRST BLOCK AND SAVES IT.
*    4.  FREES BLOCK, IF NOT THE FIRST.
*    5.  REPEATS 1 THRU 4 UNTIL END OF CHAIN AND GROUP IS EMPTIED.
*
*    FIRST BLOCK IS SAVED FOR IGG0CLC7, WHICH UPDATES THE ICE
*    AND WRITES THE BLOCK.
*
* INPUT:
*    ICE,LNKENTRY,FLAG4(COMPLETE=0), NEW ENTRY AT NAME, BALREG3
*    IS RETURN REGISTER.
*
* OUTPUT:
*    OUTPUT,WRITETTR
*
* DESTROYED:
*    BALREGS,DELTTR3=0,OPTNCCW,R0,BALREG2,BALREG1,LEN,LINKTTR=0,
*    POINT,TARGET,SIZE,INPUT
*
* SUBROUTINES USED:
*    TOABSL,IO,SETUP,FRVCBRTN,INCR,FRBLOK
***
*
*
*        ESTABLISH POINT AS A BASE REGISTER FOR INSPECTING ENTRIES.
*
         USING ENTRY,POINT2            ESTABL ADDRBLTY TO ENTRY
         ST    BALREG3,BALREGS         SAVE THE RETURN REGISTER
*
*      TTR OF FIRST BLOCK OF CHAIN TO BE EMPTIED IS IN THE ICE OF
*      THAT BLOCK.
*
         MVC   READTTR(L'IFSTBLK),IFSTBLK   GET TTR
*
EMPREAD  EQU   *
*
*      READ THE BLOCK AND SETUP THE ENTRY POINTERS.
*
         MVC   OPTNCCW,RD              GET CCW
         L     R0,READTTR              GET READ ADDRESS
         BAL   BALREG2,TOABSL          CONVERT IT
         BAL   BALREG1,IO3             ***READ DATA INTO INPUT***
         LA    POINT2,INENTRY          ADDRESS OF FIRST ENTRY
*
EMPCHEK  EQU   *
*
*      INSPECT THE INDICATED ENTRY
*
         CLC   ENAME,HIBIN             IS THE NAME ALL 'FF'S?
         BE    EMPRENEW                YES, END OF BLOCK
*
         CLI   ETYPE,VCBPETYP          IS THE ENTRY A VCBPE?
         BNE   EMPNEXT                 NO, DONE WITH THIS ENTRY
*
         MVC   DELTTR3(L'ETTR),ETTR    GET VCB CHAIN PTR
         BAL   BALREG3,FRVCBRTN        GO FREE THEM
*
EMPNEXT  EQU   *
*
         BAL   BALREG1,INCR2           INCREMENT ENTRY POINTER
         B     EMPCHEK                 LOOP BACK
*
*
EMPRENEW EQU   *
*
*      IF THE BLOCK JUST SCANNED WAS THE FIRST BLOCK, THEN
*      BUILD THE NEW FIRST BLOCK IN OUTPUT, COMPLETE.  PUT ITS TTR
*      IN WRITETTR. THE BLOCK IS THEN PASSED TO IGG0CLC7 FOR
*      THE UPDATE OF ITS ICE.
*
*      IF THE BLOCK JUST SCANNED WAS NOT THE FIRST BLOCK THEN GO TO
*      EMPFR TO FREE IT.
*
         TM    FLAG4,COMPLETE          * IS THE FIRST BLOCK COMPLETE?
         BO    EMPFR                   YES
*
*      SET UP AN EMPTY BLOCK SO THE NEXT LOAD OF UPDATE CAN INSERT
*      THE NEW ENTRY.
*
         MVC   OUTDATA,INDATA          PUT 1ST BLK INTO OUTPUT  SA55202
         XC    LINKTTR,LINKTTR         ENSURE LINK ENTRY HAS ZERO TTR
         MVC   OUTENTRY+L'ICE(L'LNKENTRY),LNKENTRY       SET ILE
         MVI   OUTBYTSU+1,X20          SET BYTES USED FOR UPDATE
*
*      INDICATE BLOCK IS COMPLETE AND SAVE ITS TTR.
*
         OI    FLAG4,COMPLETE          * SET COMPLETE
         MVC   WRITETTR(L'IFSTBLK),IFSTBLK     NEW BLOCK'S WRITE ADDR
*
         B     EMPRESET                GO CHECK FOR ANOTHER BLOCK
*
*
EMPFR    EQU   *
*
*      FREE THE BLOCK JUST SCANNED.
*
         L     R0,READTTR              GET WRITE ADDRESS
         BAL   BALREG3,FRBLKRTN        GO TO FREE BLOCK ROUTINE
*
*
EMPRESET EQU   *
*
*      IF THERE IS ANOTHER BLOCK, GET ITS READ ADDRESS AND GO TO
*      'EMPREAD' TO READ IT.
*
*      IF THERE IS NOT ANOTHER BLOCK, RETURN.
*
         MVC   READTTR(L'ETTR),ETTR    GET LINK TTR
         NC    READTTR,READTTR         IS IT ZERO?
         BNZ   EMPREAD                 NO
*
*      END OF CHAIN.
*
         MVI   FLAG4,X00               * RESET FLAG4
         L     BALREG3,BALREGS         RESTORE RETURN REGISTER
         BR    BALREG3                 RETURN
*
         DROP  POINT2
*
         EJECT
*
****************
*              *
FRNDXRTN EQU   *
*              *
****************
*
         ST    BALREG3,BALREGS         SAVE THE RETURN REG
         USING ENTRY,POINT2            ESTABL ADDRBLTY TO ENTRY
         LA    POINT2,INENTRY+L'ICE    POINT TO FIRST ENTRY IN BLOCK
*
FRNDXRD  EQU   *
*
         L     R0,DELTTR1              ADDR OF FREEABLE BLOCK
         LTR   R0,R0                   ABOUT TO READ RECORD ZERO?
         BZ    FRNDXEND                YES, END OF CHAIN
*
         BAL   BALREG2,TOABSL          GO TO CONVERT
         MVC   OPTNCCW,RD              MOVE IN READ DATA CCW
         BAL   BALREG1,IO3             ***READ DATA INTO INPUT***
         L     R0,DELTTR1              ADDR OF FREEABLE BLOCK
         BAL   BALREG3,FRBLKRTN        ***FREE BLOCK***
         MVC   DELTTR1(L'ETTR),ETTR    ADDR OF NEXT FREEABLE BLOCK
         CLI   ETYPE,VCBPETYP          ENTRY FOUND A VCBPE?
         BE    FRNDXVCB                GO FREE THEM
*
         CLI   ETYPE,DSPETYP           ENTRY FOUND A DSPE?
         BNL   FRNDXEND                YES, DONE
*
         B     FRNDXRD                 READ NEXT BLOCK IF THERE IS ONE
*
*
FRNDXVCB EQU   *
*
         MVC   DELTTR3,DELTTR1         GET VCB CHAIN PTR
         BAL   BALREG3,FRVCBRTN        ***FREE VCBS***
*
FRNDXEND EQU   *
*
         L     BALREG3,BALREGS         RESTORE RETURN REG
         BR    BALREG3                 RETURN
*
         EJECT
*
****************
*              *
FRVCBRTN EQU   *
*              *
****************
*
         USING VCBD,VCBMAIN            ESTABL ADDRBLTY TO VCB
         LA    R0,BLOCK+L'VCBBAL       LENGTH OF REQUIRED AREA
         GETMAIN R,LV=(0)
         ST    R1,SVVCBLK5             SAVE BLOCK PTR (ESTAE)  @YL026UD
         LR    VCBMAIN,R1              SET BASE TO AREA
         ST    BALREG3,VCBBAL          SAVE RETURN REG
*
FRVCBRD  EQU   *
*
*      SET UP CHANNEL PROGRAM TO READ DATA INTO VCBMAIN AREA.
*
         MVC   OPTNCCW,RD              MOVE IN READ DATA CCW
         ST    VCBMAIN,OPTNCCW         MOVE IN ADDRESS
         MVI   OPTNCCW,RDOP            RESTORE READ DATA OP-CODE
         L     R0,DELTTR3
         LTR   R0,R0                   ZERO?
         BZ    FRVCBEND                YES, DONE
         BAL   BALREG2,TOABSL          GO TO CONVERT
         BAL   BALREG1,IO3             ***READ DATA INTO VCBMAIN***
         L     R0,DELTTR3              ADDR OF VCB
         BAL   BALREG3,FRBLKRTN        ***FREE BLOCK***
         MVC   DELTTR3,VCBLNK          ADDR OF NEXT VCB
         B     FRVCBRD                 GO READ IT
*
*
FRVCBEND EQU   *
*
         L     BALREG3,VCBBAL          RESTORE RETURN REG
         LA    R0,BLOCK+L'VCBBAL       LENGTH OF AREA TO FREE
         LR    R1,VCBMAIN              ADDR OF AREA TO FREE
         XC    SVVCBLK5(4),SVVCBLK5    RESET BLOCK PTR (ESTAE) @YL026UD
         FREEMAIN R,LV=(0),A=(1)
         BR    BALREG3                 RETURN
*
         DROP  VCBMAIN
*
         EJECT
*
****************
*              *
FRBLKRTN EQU   *
*              *
****************
*
*      FREE ONE BLOCK
*
*      PRIOR TO FIRST HOLE IN SYSCTLG?                          SA52119
         CL    R0,VFHOLE                                        SA52119
         BNL   FROK                    NO, OK TO JUST FREE IT
         ST    R0,VFHOLE               YES, RESET 'VFHOLE'
*
FROK     EQU   *
*
         BAL   BALREG2,TOABSL          GO TO CONVERT
         MVC   OPTNCCW,NOP             MOVE IN SKELETON CCW
         MVI   OPTNCCW,WKDOP           MOVE IN WRITE KEY & DATA OP-CODE
         BAL   BALREG1,IO3             ***WRITE ZERO KEY & DATA***
         BR    BALREG3                 RETURN
*
         EJECT
*
****************
*              *
BLVCBRTN EQU   *
*              *
****************
*
         LA    VCBMAIN,OUTDATA         SET BASE FOR VCB
         USING VCBD,VCBMAIN            ESTABL BASE FOR VCB
         MVC   OUTKEY,HIBIN            SET KEY TO X'FF'
         XC    VCBTTR,VCBTTR           ZERO 'VCBTTR'
         LA    MODULUS,D20             NUMBER OF VOLUMES PER VCB
         XR    WORK2,WORK2             ZERO 'WORK2'
         L     WORK1,CAMPTR3           POINT TO VOLUME LIST
         LH    WORK3,0(WORK1)          GET NUMBER OF VOLUMES
         BCTR  WORK3,0                 MINUS 1
         DR    WORK2,MODULUS           NUMBER OF VCB'S - 1 IN WORK3
         LA    WORK2,D01(WORK2)        NUMBER OF VOLUMES IN LAST VCB
         LA    COUNT,D01(WORK3)        VCB COUNTER
         MH    WORK3,H240              TIMES NUMBER OF BYTES/VCB
         LA    POINT2,D02(WORK1,WORK3) 1ST VOLUME ENTRY FOR LAST VCB
         LR    WORK1,WORK2             NUMBER OF VOLUMES IN LAST VCB
         MH    WORK1,H12               NUMBER OF BYTES TO BE MOVED
*
BLVCB1   EQU   *
*
         XC    OUTDATA,OUTDATA         CLEAR BLOCK
         BCTR  WORK1,0                 MINUS 1 FOR EXECUTE
         EX    WORK1,MOVE3             MOVE USERS VOLUME LIST
         STH   WORK2,VCBVOLCT          VOLUME COUNT TO VCB
         MVC   VCBLNK,VCBTTR           WRITE LINK TTR
         L     R0,VFHOLE               GET NEXT BLOCK ADDR
         ST    R0,VCBTTR               SAVE AS NEXT LINK TTR
         BAL   BALREG2,TOABSL          GO TO CONVERT
         MVC   OPTNCCW,WKD             MOVE IN WRITE KEY & DATA OP-CODE
         BAL   BALREG1,IO3             ***WRITE KEY & DATA***
         MVC   OPTNCCW,RKD             READ KEY & DATA -- NO TRANSFER
         OI    OPTNCCW+4,CC            COMMAND CHAIN
         BAL   BALREG1,IO3             ***VERIFY WRITE & SEARCH KEY=0**
*
*      CHECK FOR CATALOG FULL CONDITION.
*
         LTR   R15,R15                 CATALOG FULL?
         BZ    BLVCB2                  NO
*
         MVC   DELTTR3,VCBTTR          GET VCB CHAIN PTR
         BAL   BALREG3,FRVCBRTN        GO FREE THEM
         B     ERR20                   AND EXIT
*
*
BLVCB2   EQU   *
*
         BAL   BALREG2,TORLTV          GET THE NEW TTR
         ST    R0,VFHOLE               PUT NEW TTR IN VICE
         LA    WORK2,D20(WORK2)        BUMP VOL COUNT BY 20
         SH    POINT2,H240             BACKUP IN VOLUME LIST
         LA    WORK1,L'VCBVOLS         NUMBER OF BYTES TO BE MOVED
         BCT   COUNT,BLVCB1            BRANCH IF ANY MORE VCB'S
         MVC   TTR,VCBTTR              HEAD OF CHAIN TTR INTO VCBPE
         XC    VCBTTR,VCBTTR           ZERO 'VCBTTR'
         BR    BALREG3                 RETURN
*
         DROP  POINT2
*
         EJECT
*
****************
*              *
INCR2    EQU   *
*              *
****************
*
* FUNCTION:
*    ADJUSTS POINT TO POINT TO THE NEXT ENTRY IN INPUT
* INPUT:
*    ETYPE,POINT,BALREG1 IS RETURN REGISTER
* OUTPUT:
*    POINT,LENGTH
* DESTROYED:
*    NOTHING
*
***
*
         USING ENTRY,POINT2            ESTABL ADDRBLTY TO ENTRY
*
         XR    LENGTH2,LENGTH2         ZERO 'LENGTH2'
         IC    LENGTH2,ETYPE           PICK UP ENTRY TYPE
*
*      TOTAL LENGTH OF THE ENTRY IS 12 + 2*(ETYPE)
*
         LA    LENGTH2,D12(LENGTH2,LENGTH2)    CALCULATE LENGTH
         AR    POINT2,LENGTH2          ADJUST POINT
         BR    BALREG1                 POINT IS AT NEXT ENTRY
*
         DROP  POINT2
*
         EJECT
*
****************
*              *
WRITE    EQU   *
*              *
****************
*
         MVI   OPTNCCW,WDOP            MOVE IN WRITE DATA OP CODE
         BAL   BALREG1,IO3             WRITE DATA
*
*      VERIFY THE WRITE OPERATION
*
         MVC   OPTNCCW,RKD             MOVE IN CCW - NO TRANSFER
         BAL   BALREG1,IO3             ***READ KEY & DATA***
         BR    BALREG2                 RETURN
*
         EJECT
*
****************
*              *
TOABSL   EQU   *
*              *
****************
*
* FUNCTION:
*    CONVERT THE TTR0 IN R0 TO AN ABSOLUTE DASD ADDRESS AND
*    PUT IT INTO THE IOB MBBCCHHR
*
* INPUT:
*    R0 IS THE TTR0 TO BE CONVERTED
*    RETURN ADDRESS IN BALREG2
*
* OUTPUT:
*    ABSOLUTE DASD ADDRESS IN IOB
*    ERROR CODE IN R15
*
* DESTROYED:
*    REGISTERS - R0,R1,R2,R14, AND R15=0
*    WA - SAVEAREA AND MBBCCHHR OF THE IOB
*
* SUBROUTINES USED:
*         THE RESIDENT CONVERT ROUTINE - IECPCNVT
*
*
***
*
         L     R15,EPTOABSL            GET EP TO 'IECPCNVT'
         B     CONVERT                 GO SET UP FOR CONVERT
*
         EJECT
*
****************
*              *
TORLTV   EQU   *
*              *
****************
*
* FUNCTION:
*    MOVE THE DASD ADDRESS OF CCHHR FROM NXTCNT INTO THE CCHHR OF THE
*    IOB.  THIS GIVES THE TTR OF THE NEXT FREE BLOCK.
*
* INPUT:
*    RETURN IN BALREG2
*    UPDATED NXTCNT
*
* OUTPUT:
*    TTR0 IN R0
*
* DESTROYED:
*    REGISTERS -- R0,R1,R2,R14, AND R15=0
*    WA -- SAVEAREA AND CCHHR OF IOB
*
* SUBROUTINES USED:
*         THE RESIDENT CONVERT ROUTINE -- IECPRLTV
*
*
***
*
*      MOVE DATA COUNT FIELD INTO IOB
*
         MVC   IOBSKADD+3(L'NXTCCHHR),NXTCCHHR MOVE DATA COUNT FIELD
         L     R15,EPTORLTV            GET EP TO 'IECPRLTV'
*
CONVERT  EQU   *
*
         STM   R9,R13,SVAREA5          SAVE REGS DESTROYED BY CONVERT
         L     R1,DEBADDR              GET DEB ADDRESS
         LA    R2,IOBSKADD             POINT TO MBBCCHHR
         BALR  BALREG1,R15             GO TO CONVERT
         LM    R9,R13,SVAREA5          RESTORE REGISTERS
         BR    BALREG2                 RETURN
*
         EJECT
*
****************
*              *
IO3      EQU   *
*              *
****************
*
* FUNCTION:
*    1.  IF THE DEVICE HAS THE RPS FEATURE, THE SET SECOTR CCW IS
*        UPDATED.
*    2.  ISSUE EXCP FOR THE CHANNEL PROGRAM POINTED TO BY THE JOB.
*    3.  WAIT FOR THE OPERATION TO COMPLETE AND CHECK THE ECB.
*    4.  IF AN END OF EXTENT CONDITION, BRANCH TO IGC0002H     @YL026UD
*        AND EXTEND THE CATALOG.                               @YL026UD
*    5.  IF A PERMANENT I/O ERROR, SET AN ERROR CODE AND BRANCH TO
*        IGG0CLC7.
*
* INPUT:
*    UPDATED CHANNEL PROGRAM
*    RETURN ADDRESS IN BALREG 1
*
* OUTPUT:
*    1.  FILLED BUFFER
*    2.  EMPTIED BUFFER
*    3.  ANOTHER FREE BLOCK ADDRESS
*
* DESTROYED:
*    REGISTERS R0,R1,R15 (IF EXTENDS), AND ERRCAT
*
* EXTERNAL ROUTINES USED:
*    EXCP, WAIT, SVC 28 TO EXTEND CATALOG
*
* EXITS:
*         IGC0002H TO EXTEND THE CATALOG                       @YL026UD
*         IGG0CLC7 FOR PERMANENT I/O ERROR
***
*
         USING RPSD,R1                 ESTABL ADDRBLTY TO RPS AREA
         TM    FLAG2,RPSDEV            * RPS FEATURE?
         BZ    EXCP3                   BRANCH IF NO
*
         L     R1,RPSAVEP              GET RPS SAVE AREA PTR
         STM   R9,R2,RPSAVE            SAVE REGS DESTROYED BY CONVERT
         LM    R15,R2,RPSINPUT         GET CONVERT INPUT PARAMETERS
         IC    R0,IOBSKADD+7           GET R OF CCHHR
         BALR  R14,R15                 CONVERT R TO THETA
         LM    R9,R2,RPSAVE            RESTORE REGISTERS
*
EXCP3    EQU   *
*
         EXCP  IOB                     ISSUE EXCP
         WAIT  ECB=ECB                 WAIT FOR REQUEST
         XR    R15,R15                 ZERO RETURN CODE
         CLI   ECB,X7F                 I/O ERROR?
         BCR   8,BALREG1               BRANCH IF NO
*
         CLI   ECB,X42                 END OF EXTENT?
         BNE   ERR28                   BRANCH IF NO AND EXIT
*
*      EXTEND CATALOG
*
         ST    BALREG1,SVBALREG        SAVE CURRENT BALREG1    @YL026UD
         L     R0,IOBDCB               GET DCB ADDRESS
         L     R2,OPENMOD              GET IGC0002H ADDRESS    @YL026UD
         BALR  BALREG1,R2              EXTEND                  @YL026UD
*
         L     BALREG1,SVBALREG        RESTORE SAVED BALREG1   @YL026UD
         CH    R15,H08                 ANY MORE EXTENTS?
         BCR   8,BALREG1               BRANCH IF NO
*
         LCR   R1,R15                  RETURN CODE 0?
         BNZ   IGG0CLC7                BRANCH IF NO
*
         B     EXCP3                   RE-ISSUE REQUEST
*
         DROP  R1
*
         EJECT
*
ERRTN    EQU   *
*
         MVC   DELTTR1,TTR0            PREPARE FOR FRNDXRTN
         BAL   BALREG3,FRNDXRTN        GO FREE INDEX CHAIN
         B     ERR20                   SET RETURN CODE OF 20   @YL026UD
*
*
ERR08    EQU   *
*
         MVI   ERRCATSV,ERROR08        RETURN CODE IS 08
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR12    EQU   *
*
         MVI   ERRCATSV,ERROR12        RETURN CODE IS 12
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR16    EQU   *
*
         MVI   ERRCATSV,ERROR16        RETURN CODE IS 16
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR20    EQU   *
*
         MVI   ERRCATSV,ERROR20        RETURN CODE IS 20
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR24    EQU   *
*
         MVI   ERRCATSV,ERROR24        RETURN CODE IS 24
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
ERR28    EQU   *
*
         MVI   ERRCATSV,ERROR28        RETURN CODE IS 28
         B     IGG0CLC7                BRANCH TO IGG0CLC7      @YL026UD
*
*
IGG0CLC6 EQU   *
*
         L     R15,IGG0CLCE            OBTAIN MODULE NAME      @YL026UD
         BALR  R14,R15                 BRANCH TO IGG0CLCE      @YL026UD
*
*
IGG0CLC7 EQU   *
*
         L     R15,ERRORMOD            OBTAIN MODULE NAME      @YL026UD
         BALR  R14,15                  BRANCH TO ERROR MODULE  @YL026UD
*
         TITLE 'IGG0CLCD - (ESTAEXIT) ESTAE EXIT ROUTINE'      @YL026UD
***********************************************************************
*                                                                     *
*     ESTAEXIT - ESTAE EXIT ROUTINE                                   *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
         ENTRY ESTAEXIT                                        @YL026UD
*                                                              @YL026UD
*      ESTAEXIT IS GIVEN CONTROL ON PERCOLATION FROM ANOTHER   @YL026UD
*      ESTAE EXIT ROUTINE, OR RECEIVES CONTROL BECAUSE OF AN   @YL026UD
*      INTERRUPT IN MODULES IGG0CLCC, IGG0CLCD, IGG0CLCE.      @YL026UD
*      REGISTER 14 MUST BE SAVED FOR RETURN TO THE TRM.        @YL026UD
*      AN RTCA MAY OR MAY NOT BE AVAILABLE.  ESTAEXIT ALWAYS   @YL026UD
*      PERCOLATES TO THE NEXT ESTAE ON THE CHAIN.              @YL026UD
*                                                              @YL026UD
*                                                              @YL026UD
ESTAEXIT EQU   *                                               @YL026UD
*                                                              @YL026UD
         BALR  BASE,0                  SET BASE REG FOR MODULE @YL026UD
         USING *,BASE                  ESTABLISH BASE REGISTER @YL026UD
*                                                              @YL026UD
         CH    R0,H12                  IS RTCA AVAILABLE       @YL026UD
         BE    NORTCA                  NO, PROCESS WITHOUT IT  @YL026UD
         STM   R14,R12,12(R13)         SAVE REGISTERS          @YL026UD
         LR    R2,R14                  SAVE RETURN REGISTER    @YL026UD
         L     R15,0(R1)               GET ESTAE INFO LIST PTR @YL026UD
         L     R5,0(R15)               RESTORE SVRB BASE REG   @YL026UD
         L     R6,4(R15)               RESTORE CATLG WKA REG   @YL026UD
         L     R13,8(R15)              RESTORE BLDL  WKA REG   @YL026UD
         LR    R3,R1                   SAVE SDWA-RTCA ADDRESS  @YL026UD
         USING SDWA,R3                 SET SDWA ADDRESSIBILITY @YL026UD
         TM    SDWAERRC,SDWAPERC       WERE WE PERCOLATED TO?  @YL026UD
         BO    PERC                    YES, BYPASS DUMPING     @YL026UD
*                                                              @YL026UD
*      NOT PERCOLATED TO                                       @YL026UD
*                                                              @YL026UD
         SETRP RECORD=YES,DUMP=NO,RECPARM=RECORD,RC=0,         @YL026UD*
               WKAREA=(R3)                                     @YL026UD
*                                                              @YL026UD
         MVC   DUMPHDR(L'SKELHDR),SKELHDR STORE SDUMP HEADER   @OZ29464
         MVC   DUMPLIST(SDUMPSIZ),DUMPL STORE PARM LIST        @OZ29464
         LA    R2,DUMPHDR              POINT TO HEADER         @OZ29464
         SDUMP HDRAD=(R2),MF=(E,DUMPLIST) ISSUE SDUMP MACRO    @OZ29464
         B     DEQALL                  BRANCH TO DEQUES        @YL026UD
*                                                              @YL026UD
PERC     EQU   *                                               @YL026UD
*                                                              @YL026UD
*      PERCOLATED TO                                           @YL026UD
*                                                              @YL026UD
         SETRP RECORD=YES,DUMP=IGNORE,RECPARM=RECORD,RC=0,     @YL026UD*
               WKAREA(R3)                                      @YL026UD
         B     DEQALL                  BRANCH TO DEQUES        @YL026UD
         DROP  R3                                              @YL026UD
*                                                              @YL026UD
NORTCA   EQU   *                                               @YL026UD
*                                                              @YL026UD
         L     R5,0(R2)                RESTORE SVRB BASE REG   @YL026UD
         L     R6,4(R2)                RESTORE CATLG WKA REG   @YL026UD
         L     R13,8(R2)               RESTORE BLDL  WKA REG   @YL026UD
         LR    R2,R14                  SAVE RETURN REGISTER    @YL026UD
*                                                              @YL026UD
         TM   FLAG2,ESTAEFL      TEST ESTAE FLAG               @ZA03161
         BO   FREEALL            BRANCH IF ESTAE FAILURE       @ZA03161
*
*                                                              @YL026UD
DEQALL   EQU   *                                               @YL026UD
*                                                              @YL026UD
*      DEQUE ALL ENQUED RESOURCES                              @YL026UD
*                                                              @YL026UD
         USING SVRBEXTD,R5             ENQ INFO ADDRESSIBILITY @YL026UD
         XC    ENQRNAM8,ENQRNAM8       RESET RNAME FOR VICE    @YL026UD
         OI    ENQFLAGS,HAVE           SET FLAG IN CASE NO     @YL026UD
*                                      PREVIOUS ENQ            @YL026UD
         DEQ   ,MF=(E,(R5))            DEQUE VICE              @YL026UD
*                                                              @YL026UD
         NI    ENQFLAGS,SMCSTEPC       RESET 'STEP MUST CMPLT' @YL026UD
         MVC   ENQRNAM8,ENQNAME        SET RNAME FOR VOL INDEX @YL026UD
         DEQ   ,MF=(E,(R5))            DEQUE VOLUME INDEX      @YL026UD
*                                                              @YL026UD
         OI    ENQFLAGS,RESERVE        TURN ON RESERVE FLAG    @YL026UD
         MVC   ENQRNAM8,HILVLNAM       SET RNAME FOR HIGH LEVEL@YL026UD
         DEQ   ,MF=(E,(R5))            DEQUE HIGH LEVEL NAME   @YL026UD
*                                      AND RELEASE THE DEVICE  @YL026UD
*                                                              @YL026UD
*                                                              @YL026UD
FREEALL  EQU   *                                               @YL026UD
*                                                              @YL026UD
*      FREE ALL ACQUIRED STORAGE AREAS                         @YL026UD
*                                                              @YL026UD
         L     R1,SVEXTWAP             GET EXTEND WKA PTR      @YL026UD
         LTR   R1,R1                   DOES WKA EXIST?         @YL026UD
         BZ    FREEFMT                 BRANCH IF NOT           @YL026UD
*                                                              @YL026UD
FREEEXT  EQU   *                                               @YL026UD
*                                                              @YL026UD
         LA    R0,EXTWALEN             GET EXTEND WKA LENGTH   @YL026UD
         SVC   FREEMAIN                FREE EXTEND WORKAREA    @YL026UD
*                                                              @YL026UD
FREEFMT  EQU   *                                               @YL026UD
*                                                              @YL026UD
         L     R1,SVFMTWAP             GET FORMAT WKA PTR      @YL026UD
         LTR   R1,R1                   DOES WKA EXIST?         @YL026UD
         BZ    FREEVCB5                BRANCH IF NOT           @YL026UD
         LA    R0,FMTWALEN             GET FORMAT WKA LENGTH   @YL026UD
         SVC   FREEMAIN                FREE FORMAT WORKAREA    @YL026UD
*                                                              @YL026UD
FREEVCB5 EQU   *                                               @YL026UD
*                                                              @YL026UD
         L     R1,SVVCBLK5             GET VCB WKA PTR (CLC5)  @YL026UD
         LTR   R1,R1                   DOES WKA EXIST?         @YL026UD
         BZ    FREEVCB4                BRANCH IF NOT           @YL026UD
         LA    R0,VCB5LEN              GET VCB WKA LENGTH      @YL026UD
         SVC   FREEMAIN                FREE VCB WORKAREA (CLC5)@YL026UD
*                                                              @YL026UD
FREEVCB4 EQU   *                                               @YL026UD
*                                                              @YL026UD
         L     R1,SVVCBLK4             GET VCB WKA PTR (CLC4)  @YL026UD
         LTR   R1,R1                   DOES WKA EXIST?         @YL026UD
         BZ    FREEOPN                 BRANCH IF NOT           @YL026UD
         LA    R0,VCB4LEN              GET VCB WKA LENGTH      @YL026UD
         SVC   FREEMAIN                FREE VCB WORKAREA (CLC4)@YL026UD
*                                                              @YL026UD
FREEOPN  EQU   *                                               @YL026UD
*                                                              @YL026UD
         L     R1,SVOPNWAP             GET OPEN WKA PTR        @YL026UD
         LTR   R1,R1                   DOES WKA EXIST?         @YL026UD
         BZ    FREERPS                 BRANCH IF NOT           @YL026UD
         USING DCBAREA,R1                                      @YL026UD
         L     R0,NMBYTES              GET OPEN WKA LENGTH     @YL026UD
         DROP  R1                                              @YL026UD
         SVC   FREEMAIN                FREE OPEN WORKAREA      @YL026UD
*                                                              @YL026UD
FREERPS  EQU   *                                               @YL026UD
*                                                              @YL026UD
         L     R1,SVRPSWAP             GET RPS WKA PTR         @YL026UD
         LTR   R1,R1                   DOES WKA EXIST?         @YL026UD
         BZ    FREECAT                 BRANCH IF NOT           @YL026UD
         LA    R0,RPSEND-RPSD          GET RPS WKA LENGTH      @YL026UD
         SVC   FREEMAIN                FREE RPS WORKAREA       @YL026UD
*                                                              @YL026UD
FREECAT  EQU   *                                               @YL026UD
*                                                              @YL026UD
         TM    FLAG1,LOCATEF           LOCATE REQUEST?         @YL026UD
         BZ    NOLOCATE                BRANCH IF NOT           @YL026UD
         LR    R1,R13                  GET BLDL WKA PTR        @YL026UD
         LA    R0,BLDLEND-BLDLAREA     GET BLDL WKA LENGTH     @YL026UD
         B     FREECAT1                BRANCH TO FREEMAIN      @YL026UD
*                                                              @YL026UD
NOLOCATE EQU   *                                               @YL026UD
*                                                              @YL026UD
         LR    R1,R6                   GET CATALOG WKA PTR     @YL026UD
         LA    R0,WORKEND-WORKAREA     GET CATALOG WKA LENGTH  @YL026UD
*                                                              @YL026UD
FREECAT1 EQU   *                                               @YL026UD
*                                                              @YL026UD
         SVC   FREEMAIN                FREE WORKAREA           @YL026UD
*                                                              @YL026UD
         SR    R15,R15                 ZERO REGISTER 15        @YL026UD
         LR    R14,R2                  RESTORE RETURN REGISTER @YL026UD
         BR    R14                     RETURN TO RTM           @YL026UD
*                                                              @YL026UD
         TITLE 'IGG0CLCD - CONSTANT DEFINITIONS'               @YL026UD
*
*      CONSTANTS
*
         DS    0F
SCROPTN  DC    XL4'41004000'           NO PURGE SCRATCH OPTIONS
SCROPTN2 DC    XL4'4100C000'           OPTNS WITH TIOT ENQUED  @OZ19636
H06      DC    H'06'
H08      DC    H'08'
H12      DC    H'12'
H240     DC    H'240'
*
MOVEVOLS MVC   OUTDATA+32(0),0(R2)
MOVELVLN MVC   NAME(0),0(R2)
MOVE1    MVC   VOLCNT(0),0(R1)         APPEND VOLUME LIST
MOVE2    MVC   DSNAME(0),0(DSN)        MOVE IN ALL BUT LAST LEVEL
MOVE3    MVC   OUTENTRY(0),0(POINT2)
*
EXTWALEN DC    AL1(253)                EXTEND WORKAREA SUBPOOL @YL026UD
         DC    AL3(250)                EXTEND WORKAREA LENGTH  @YL026UD
FMTWALEN DC    F'512'                  FORMAT WORKAREA LENGTH  @YL026UD
VCB5LEN  DC    F'260'                  VCB BLOCK (CLC5) LENGTH @YL026UD
VCB4LEN  DC    F'256'                  VCB BLOCK (CLC4) LENGTH @YL026UD
RECORD   DC    C'IGG0CLCa'             ESTAE RECORD MODULE     @YL026UD
         DC    C'IGG0CLCD'             ESTAE RECORD CSECT      @YL026UD
         DC    8X'00'                  ESTAE RECORD FRR ID     @YL026UD
*
SPNBYTES DS    0F                      PUT ON WORD BOUNDARY
         DC    AL1(253)                SET SUBPOOL ID
         DC    AL3(AREAEND-DCBAREA)    SIZE                    @YL026UD
*
IGG0CLCE DC    V(IGG0CLCE)
ERRORMOD DC    V(IGG0CLC7)
OPENMOD  DC    V(IGC0002H)
DUMPL    SDUMP SDATA=(PSA,LSQA,RGN,LPA),MF=L SDUMP LIST FORM   @OZ29464
SDUMPSIZ EQU *-DUMPL
SKELHDR  DS    0XL43                 SDUMP HEADER              @OZ29464
         DC    AL1(42+1)             SDUMP HEADER SIZE FIELD   @OZ29464
SKELMSG  DC    CL42'SDUMP - IGG0CLCD - CVOL CATALOG MANAGEMENT' OZ29464
*                                                              @YL026UD
*                                                              @YL026UD
*      PATCH AREA (MAINTENANCE AREA)                           @YL026UD
*                                                              @YL026UD
FIXAREA  DC    100X'00'                                        @YL026UD
*                                                              @YL026UD
         TITLE 'IGG0CLCD - CONSTANT EQUATE DEFINITIONS'        @YL026UD
*
*      CONSTANT EQUATES
*
VICETYP  EQU   5                       VICE TYPE CODE
ICETYP   EQU   3                       ICE TYPE CODE
ILETYP   EQU   0                       ILE TYPE CODE
IPETYP   EQU   0                       IPE TYPE CODE
DSPETYP  EQU   7                       OR MORE, FOR DSPE TYPE CODE
VCBPETYP EQU   1                       VCBPE TYPE CODE
OCVOLTYP EQU   3                       OLD CVOL TYPE CODE
NCVOLTYP EQU   5                       NEW CVOL TYPE CODE
ALIASTYP EQU   4                       ALIAS TYPE CODE
GIPETYP  EQU   2                       GIPE TYPE CODE
ERROR00  EQU   0
ERROR04  EQU   4
ERROR08  EQU   8
ERROR12  EQU   12
ERROR16  EQU   16
ERROR20  EQU   20
ERROR24  EQU   24
ERROR28  EQU   28
ERROR32  EQU   32
ERROR72  EQU   72
***********************************************************************
*      CHARACTER CODE DEPENDENT CONSTANTS
***********************************************************************
CCDBLANK EQU   C' '
CCDRPARN EQU   C')'
CCDMINUS EQU   C'-'
CCDPLUS  EQU   C'+'
CCD0     EQU   C'0'
CCDG     EQU   C'G'
CCDV     EQU   C'V'
CCDPERD  EQU   C'.'
CCDLPARN EQU   C'('
***********************************************************************
CODPERD  EQU   4
CODBLANK EQU   8
CODPARN  EQU   12
CLC1     EQU   C'1'
CLC2     EQU   C'2'
CLC3     EQU   C'3'
CLC4     EQU   C'4'
CLC5     EQU   C'5'
CLC6     EQU   C'6'
CLC7     EQU   C'7'
EXIT     EQU   3
FREEMAIN EQU   10
*
CC       EQU   X'40'                   COMMAND CHAIN
BLOCK    EQU   256
VICETTR  EQU   256
ALIASDSP EQU   17
*
X00      EQU   X'00'
X01      EQU   X'01'
X03      EQU   X'03'
X20      EQU   X'20'
X42      EQU   X'42'
X7F      EQU   X'7F'
XFF      EQU   X'FF'
D01      EQU   1
D02      EQU   2
D12      EQU   12
D20      EQU   20
D44      EQU   44
         TITLE 'IGG0CLCD - REGISTER EQUATE DEFINITIONS'        @YL026UD
*
*      REGISTER EQUATES
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4                       BASE REGISTER FOR ALL MODULES
R5       EQU   5
R6       EQU   6                       WORKAREA BASE REGISTER
R7       EQU   7
R8       EQU   8                       CAMLST POINTER
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12                      SECONDARY LINKAGE REGISTER
R13      EQU   13                      BLDL WORKAREA BASE REGISTER
R14      EQU   14                      PRIMARY LINKAGE REGISTER
R15      EQU   15
*
BALREG1  EQU   R14
BALREG2  EQU   R12
BASE     EQU   R4
*
BALREG3  EQU   R7
BALREG4  EQU   R3
BALREG5  EQU   R9
*
COUNT    EQU   R13
MODULUS  EQU   R0
POINT    EQU   R10
POINT2   EQU   R5                                              @YL026UD
SIZE     EQU   R0
TARGET   EQU   BALREG2
LENGTH   EQU   R9                                              @YL026UD
LENGTH2  EQU   R7                                              @YL026UD
LEVEL    EQU   R7
LEVEL2   EQU   R1                                              @YL026UD
VCBMAIN  EQU   R9
VCBMAIN2 EQU   R11                                             @YL026UD
*
INTEGER  EQU   R15
ALIASCNT EQU   R11
DSN      EQU   R1
GIPE     EQU   R5
LAST     EQU   R7
LEN      EQU   R2
TALLY    EQU   R2
*
WORK1    EQU   R3
WORK2    EQU   R10
WORK3    EQU   R11                     WORK2 + 1
*
***********************************************************************
*                                                                     *
* END OF IGG0CLCD CSECT                                               *
*                                                                     *
CLCDSIZE EQU   *                                                      *
MAXISIZE EQU   IGG0CLCD+X'1000'                                       *
AVAILABL EQU   MAXISIZE-CLCDSIZE                                      *
*                                                                     *
***********************************************************************
*
         TITLE 'IGG0CLCD - CATALOG WORKAREA DSECT'             @YL026UD
*
*      DSECTS
*
         WORKAREA LIST=YES                                       Y01113
DUMPLIST EQU   SAVEAREA           SDUMP PARM LIST IN WORKAREA  @OZ29464
DUMPHDR  EQU   INPUT              SDUMP HEADER                 @OZ29464
         TITLE 'IGG0CLCD - COMMUNICATION VECTOR TABLE DSECT'   @YL026UD
CVT      DSECT
         CVT
         TITLE 'IGG0CLCD - UNIT CONTROL BLOCK DSECT'           @YL026UD
UCB      DSECT
         IEFUCBOB
         TITLE 'IGG0CLCD - STAE DIAGNOSTIC WORK AREA DSECT'    @YL026UD
         IHASDWA DSECT=YES                                     @YL026UD
         END   IGG0CLCD                                        @YL026UD
