         TITLE 'IGG0CLCE - UPDATE, CLEANUP, ERROR PROCESSING'  @YL026UD
* /* START OF SPECIFICATIONS ****
*
*01*  MODULE-NAME = IGG0CLCE                                   @YL026UD
*01*  STATUS = 00
*
*01*  DESCRIPTIVE-NAME = UPDATE, CLEANUP, OPEN, AND FORMAT     @YL026UD
*01*  FUNCTION = IGG0CLC6 -                                    @YL026UD
*                1.  CREATES A NEW UPDATED BLOCK.              @YL026UD
*                2.  RIPPLES THE UPDATE DOWN THE INDEX CHAIN.  @YL026UD
*                IGG0CLC7 -                                    @YL026UD
*                1.  WRITES THE LAST BLOCK OF AN UPDATE.       @YL026UD
*                2.  UPDATES THE ICE AND REWRITES IT.          @YL026UD
*                3.  UPDATES THE VICE AND REWRITES IT.         @YL026UD
*                4.  DEQUEUES ALL RESOURCES.                   @YL026UD
*                5.  FREES ALL MAIN STORAGE.                   @YL026UD
*                6.  SETS RETURN CODES.                        @YL026UD
*                7.  CREATES AN ENVIRONMENT RECORD FOR         @YL026UD
*                    NON-LOCATE ERROR CODES OF 8 AND 28.       @YL026UD
*     FOR AN OVERVIEW OF THIS MODULE AND ITS RELATIONSHIP WITH THE
*     OTHER CATALOG MANAGEMENT MODULES, REFER TO THE CATALOG MANAGEMENT
*     PLM, Y28-6606.
*01*  NOTES = LABELS REFERED TO IN COMMENTARY ARE ENCLOSED IN SINGLE
*     QUOTES. EQUATED CONSTANTS ARE PREFIXED WITH 'D' OR 'X' WHEN THEY
*     ARE DECIMAL OR HEXADECIMAL RESPECTIVELY; FOR EXAMPLE, D12 EQU 12,
*     AND X12 EQU X'12'. ERROR CODES ARE SET USING 'ERRORXX' AT
*     CORRESPONDING LABELS, 'ERRXX'. BRANCHES ORIGINATE FROM LABELS
*     'IGG0CLCX'. FLAGS ARE LABELED 'FLAGX'.  IO IS DONE FROM EITHER A
*     SUBROUTINE NAMED 'CALLBLDL' OR A SUBROUTINE NAMED 'IO'. ADDRESS
*     CONVERSION IS ACCOMPLISHED IN SUBROUTINES NAMED 'TOABSL' AND
*     'TORLTV'. THESE CONVENTIONS ARE FOLLOWED IN EVERY MODULE WHERE
*     THE EVENT EXISTS.
*02*    DEPENDENCIES = OPERATION OF THIS MODULE DEPENDS ON THE
*       COLLATING SEQUENCE OF THE EXTERNAL CHARACTER SET. REDEFINITION
*       OF THE CHARACTER CONSTANTS BY REASSEMBLY WILL RESULT IN A
*       CORRECT MODULE. THE CONSTANTS IN QUESTION ARE PREFIXED WITH
*       'CCD', FOR 'CHARACTER CODE DEPENDENT'.
*02*    PERFORMANCE = (IGG0CLC6) INHIBITS RIPPLING WHERE POSSIBLE
*       AND ATTEMPTS MOVEMENT OF INDEX BLOCKS TO ATTAIN CONTIGUITY.
*       (IGG0CLC7) REWRITES THE VICE OR ICE ONLY WHEN IT HAS
*       BEEN MODIFIED.                                         @YL026UD
*02*    RESTRICTIONS = ALL DIRECT ACCESS STORAGE DEVICES EXCEPT 2321
*       DATA CELL ARE SUPPORTED BY CATALOG MANAGEMENT.
*02*    REGISTER-CONVENTIONS = REGISTERS ARE LABELED 'R0,R1,...,R15'.
*       REQUIRED ADDITIONAL LABELS ARE EQUATED TO THESE. REGISTERS
*       COMMON TO ALL MODULES OF CATALOG MANAGEMENT ARE
*       R4  BASE REGISTER FOR THE MODULE.
*       R6  BASE REGISTER FOR THE WORKAREA DSECT.
*       R8  BASE REGISTER FOR THE CAMLSTD DSECT.
*02*    PATCH-LABEL = 'FIXAREA'                                @YL026UD
*01*  MODULE-TYPE = MODULE
*02*    PROCESSOR = ASSEMBLER
*02*    MODULE-SIZE = 4000 BYTES                               @YL026UD
*02*    ATTRIBUTES = REENTERABLE, READ ONLY, ENABLED, SUPERVISORY MODE
*01*  ENTRY = IGG0CLCE                                         @YL026UD
*02*    PURPOSE = (IGG0CLC6) ENTERED FOR ALL NON-LOCATE        @YL026UD
*       REQUESTS FOR THE UPDATING OF AN INDEX LEVEL.           @YL026UD
*       (IGG0CLC7) ENTERED FOR ALL NON-LOCATE REQUESTS TO      @YL026UD
*       FINISH THE UPDATING OF AN INDEX LEVEL AND TO INDICATE  @YL026UD
*       THE NEW STATUS OF THE SYSCTLG IN THE CONTROL ENTRIES.  @YL026UD
*       ALSO ENTERED TO PROCESS ERROR CONDITIONS AND RETURN    @YL026UD
*       CONTROL TO THE ISSUER OF SVC 26.                       @YL026UD
*02*    LINKAGE = LINK                                         @YL026UD
*02*    INPUT = FOR IGG0CLC6 AND IGG0CLC7 CONSISTS OF
*       .  WORKAREA (BLDLAREA)
*       .  SVRB EXTENSION
*       .  DCB
*       .  DEB
*       .  CAMLST AND PARAMETERS
*       .  SYSCTLG
*       IN ADDITION, IGG0CLC6 REQUIRES
*       .  'READTTR'
*       .  'NAME'
*       .  'TTR0'
*       .  'DATA'
*       .  OPTIONALLY THE BLOCK TO BE UPDATED
*       IN ADDITION, IGG0CLC7 REQUIRES                         @YL026UD
*       (NORMAL)                                               @YL026UD
*       .  'LINKTTR'--INDICATES BLOCK MAY BE FREED             @YL026UD
*       .  'WRITETTR'--WHERE TO WRITE LAST BLOCK               @YL026UD
*       .  'ICEPERT'--USED PART OF ICE                         @YL026UD
*       .  'VICEPERT'--USED PART OF VICE                       @YL026UD
*       .  'OUTPUT'--CONTAINS BLOCK TO BE WRITTEN              @YL026UD
*       .  'ERRCODE'--ZERO                                     @YL026UD
*       .  R1--ZERO OR POSITIVE                                @YL026UD
*       .  R7--POINTER TO THE LINK ENTRY                       @YL026UD
*       (ERROR)                                                @YL026UD
*       .  'ERRCODE'--CONTAINS CATALOG AND LOCATE ERROR CODES  @YL026UD
*       .  R1 NEGATIVE--INDICATES IGC0002H RETURNED ERROR CODE @YL026UD
*02*    OUTPUT = (IGG0CLC6) SEE INPUT FOR IGG0CLC7             @YL026UD
*       (IGG0CLC7) NORMAL                                      @YL026UD
*       .  R15 = 0                                             @YL026UD
*       .  UPDATED SYSCTLG                                     @YL026UD
*       (IGG0CLC7) ERROR                                       @YL026UD
*       .  R15 = RETURN CODE                                   @YL026UD
*       .  R0 = NUMBER OF LEVELS FOUND                         @YL026UD
*       .  R1 = LOCATE ERROR CODE                              @YL026UD
*02*    EXIT-NORMAL = IGG0CLCA OR IGG0CLCB                     @YL026UD
*02*    EXIT-ERROR = IGG0CLCA OR IGG0CLCB                      @YL026UD
*01*  EXTERNAL-REFERENCES = AS FOLLOWS.
*02*    ROUTINES = IECPRLTV, IECPCNVT
*02*    DATA-SETS = SYSCTLG
*02*    DATA-AREA = ALL DATA AREAS ARE DESCRIBED BY DSECTS AT THE END
*       OF THE MODULE LISTING.
*01*  TABLES = NONE
*01*  MACROS = EXCP, WAIT, ESTAE, FREEMAIN, ENQ, DEQ, TIME, WTO
*
*01*  CHANGE-ACTIVITY = NEW FOR RELEASE 21
*                       (AS IGG0CLC6,IGG0CLC7)
*                       RENAMED AND CHANGED FOR VS2 RELEASE 2  @YL026UD
* IGC0002H,IGG0CLF2 SPLIT OFF TO IGG0CLCF                      @OZ00006
* A127959                                                      @OZ02274
*A10510-10520                                                  @ZA02665
*A18770-18796                                                  @ZA02665
*A127812-127829                                                @ZA02665
*A291390-291395                                                @ZA02665
*        VS2 RELEASE 030 CHANGES
* A132620                                                      @OZ03161
* A134100                                                      @OZ04613
*A127810                                                       @OZ05575
*A011910-012009,127830-127929,127957-127980,291395-291407      @OZ05908
*A127505                                                       @OZ07534
* D128200,A128200,128620                                       @OZ07699
*        VS2 RELEASE 037 CHANGES
* A018792,A046620-046680,A127890-127898,C127900,C291392        @OZ12193
* A098301-098305                                               @OZ12193
* D127505,A127852-127858                                       @OZ12244
*D011910-012009,A015101,A017401,A028400-028418                 @OZ11109
*A127896,A127926,A127959,C291368,C291390,C291395               @OZ14802
*C128200,D128620                                               @OZ15062
*A142458,A292252                                               @OZ32432
*
**** END OF SPECIFICATIONS *******************************************/
         EJECT                                                 @YL026UD
IGG0CLCE CSECT                                                 @YL026UD
*
         BALR  BASE,0                  SET BASE FOR MODULE
         USING *,BASE                  ESTABL BASE FOR MODULE
         USING CAMLSTD,R8              ESTABL BASE FOR CAMLST
         USING ENTRY,R9                ESTABL BASE FOR ENTRY
         USING WORKAREA,R6             ESTABL BASE FOR WORKAREA
*
         B     MODLABEL                BRANCH AROUND MOD LABEL @YL026UD
         DC    C'IGG0CLCE        '     MODULE IDENTIFIER       @YL026UD
         DC    C'&SYSDATE'             DATE OF ASSEMBLY
         DC    C'UZ20205'              PTF LEVEL
         DS    0H
MODLABEL EQU   *
         TITLE 'IGG0CLCE - (IGG0CLC6) SECOND LOAD OF UPDATE'   @YL026UD
***********************************************************************
*                                                                     *
*     IGG0CLC6 - SECOND LOAD OF UPDATE                                *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
IGG0CLC6 EQU   *                                               #YL026UD
*
         OI    MODMAP1,MODCLC6         INDIC ENTRY TO IGG0CLC6
*
*      SET ALL OTHER TASKS IN REGION NON-DISPATCHABLE
*
         USING SVRBEXTD,R1             ESTABL ADDRBLTY TO SVRB EXT
         L     R1,SVRBEXTP             SET BASE TO PARAMETER LIST
         TM    ENQFLAGS,SMCSTEP        SMC ALREADY ISSUED?       Y01965
         BO    SKIPSMC                 BRANCH IF YES             Y01965
*
         OI    ENQFLAGS,SMCSTEP        SET ENQ FLAGS             Y01965
         ENQ   ,MF=(E,(1))             DISABLE STEP TASKS
         DROP  R1
*                                                                Y01965
SKIPSMC  EQU   *                                                 Y01965
*                                                                Y01965
*
*      INITITALIZE
*
         SR    LENGTH,LENGTH           ZERO 'LENGTH'             Y01113
         XC    TTRS,TTRS               ZERO 'WRITETTR, LINKTTR'  Y01113
         ST    LENGTH,EXCLUDE          ZERO 'EXCLUDE'            Y01113
         XC    SAVEKEY,SAVEKEY          SIMULATE PREVIOUS       ZA02665
*                                       ENTRY KEY = 0           ZA02665
         XC    OUTDATA,OUTDATA         CLEAR THE OUTPUT BLOCK
         LA    OUT,OUTENTRY            FIRST HOLE IN NEW BLOCK
         TM    FLAG3,NEEDBLK           BLOCK FOR UPDATE IN?
         BZ    SETUP                   YES
*
         BAL   R10,GET                 NO, READ BLOCK FOR UPDATE
         B     COMPARE                 START THE UPDATE PROCESS
*
*
SETUP    EQU   *
*
         BAL   R10,GETSET              SET UP TTRS
*
COMPARE  EQU   *
*
*      COMPARE 4 BYTES OF GDG NAME OR 8 BYTES OF NON-GDG NAME
*      AT 'IN' WITH UPDATE NAME.
*
*      GO TO 'ADD' IF UPDATE NAME IS SMALLER,
*      GO TO 'CHEKROOM' IF UPDATE NAME IS GREATER,
*      GO TO NEXT INSTRUCTION ('DELETE') IF NAMES MATCH.
*
         TM    FLAG3,GDS               * PROCESSING GDG?
         BZ    NONGDG                  NO
*
         CLC   GENNO,EGENNO            YES, COMPARE GENERATION NUMBERS
         B     CRIT                    GO MAKE THE CC DECISION
*
*
NONGDG   EQU   *
*
         CLC   NAME,ENAME              COMPARE ENTIRE NAMES
*
CRIT     EQU   *
*
         BL    ADD                     NEW IS LESS THAN EXISTING
*
         BH    CHEKROOM                NEW IS GREATER THAN EXISTING
*
*      DELETE                          NEW IS EQUAL TO EXISTING
*
*      CALCULATE THE LENGTH OF THE ENTRY TO BE DELETED AND
*      INCREMENT THE 'IN' POINTER SO THAT ENTRY WILL BE IGNORED.
*      TURN THE COMPLETION SWITCH ON.  GO TO NEXT INSTRUCTION
*      ('ADD') IF REQUEST IS RECATALOG, OTHERWISE GO TO 'CHEKLINK'.
*
         BAL   BALREG3,EDITYPE         GO EDIT ENTRY TYPE      @OZ11109
         IC    LENGTH,ETYPE            COUNT FIELD OF INPUT ENTRY
         LA    LENGTH,D12(LENGTH,LENGTH)    LENGTH OF INPUT
         AR    IN,LENGTH               STEP OVER ENTRY
         OI    FLAG4,UPDATED           * SET UPDATE COMPLETE
         TM    FLAG1,RECATF            RECAT?
         BZ    CHEKLINK                NO
*
         NI    FLAG4,X'FF'-UPDATED     * UPDATE NOT COMPLETE   @OZ11109
*
ADD      EQU   *
*
*      SAVE 'IN' AND SET UPDATE IN PROGRESS SWITCH TO INDICATE 'IN'
*      IS IRREGULAR.  LOAD 'IN' WITH ADDRESS OF UPDATE ENTRY.  GO
*
         ST    IN,ADDING               SAVE POINTER TO ENTRY
         OI    FLAG4,UPDATING          * SET UPDATE IN PROGRESS
         LA    IN,NAME                 POINT TO NEW ENTRY
*
CHEKROOM EQU   *
*
*      COMPUTE LENGTH OF ENTRY TO BE MOVED (TO 'OUT').
*      CALL 'PUT' IF THERE IS NOT ENOUGH ROOM TO MOVE THE ENTRY.
*
         BAL   BALREG3,EDITYPE         GO EDIT ENTRY TYPE      @OZ11109
         IC    LENGTH,ETYPE            COUNT FIELD OF INPUT ENTRY
         LA    LENGTH,D12(LENGTH,LENGTH)    LENGTH OF INPUT ENTRY
*
*      POINT TO FIRST CHARACTER OF LAST POSSIBLE LINK ENTRY
*
         LA    R1,OUTLKLMT
         SR    R1,OUT                  GET BYTES AVAILABLE
         CR    R1,LENGTH               ROOM AVAILABLE?
         BNL   TRANS                   YES, GO MOVE THE ENTRY
*
         BAL   BALREG3,PUT             ***GO WRITE THE BLOCK***
*
TRANS    EQU   *
*                                                               ZA02665
*     MAKE SURE THE NEXT ENTRY TO BE MOVED TO OUTPUT IS         ZA02665
*     OF A HIGHER KEY THAN THE PREVIOUS ONE.  IF NOT, SET       ZA02665
*     A FLAG TO HAVE IGG0CLC7 WRITE A WARNING MESSAGE TO        ZA02665
*     THE OPERATOR THAT THE CATALOG NEEDS REPAIR.               ZA02665
*                                                               ZA02665
         CLC   SAVEKEY,0(IN)            TEST PREVIOUS KEY LESS  ZA02665
*                                       THAN NEXT KEY           ZA02665
         BL    TRANS2                   YES, OK                 ZA02665
         OI    FLAG2,SEQERR             ENTRY OUT OF SEQUENCE  @OZ02665
         OI    FLAG4,ERRORTTR           SET ERROR HOLD FLAG    @OZ12193
TRANS2   EQU   *                                                ZA02665
         MVC   SAVEKEY,0(IN)         SAVE FOR NEXT TIME THRU    ZA02665
*
*      MOVE ENTRY AT 'IN' TO 'OUT' AND BUMP 'IN' TO POINT TO
*      NEXT ENTRY TO BE MOVED.  SAVE NAME MOVED IN CASE
*      IT BECOMES A KEY.  GO TO 'COMPARE' IF UPDATE IS NOT COMPLETE.
*
         LR    R1,LENGTH               GET LENGTH OF ENTRY
         BCTR  R1,0                    MINUS ONE FOR EXECUTE
         EX    R1,MOVE1                MVC 0(0,OUT),0(IN)
         MVC   OUTKEY,0(IN)            SAVE AS A POSSIBLE KEY
         TM    FLAG4,UPDATING          ADDING OR JUST MOVING?
         BZ    INCRIN                  JUST MOVING
*
         L     IN,ADDING               RESTORE POINTER TO ENTRY
*
*      TURN OFF 'UPDATING' SWITCH AND ON 'UPDATED' SWITCH
*
         XI    FLAG4,COMPLETE          * SET UPDATE COMPLETE
         B     STABLIN                 DON'T INCR 'IN'
*
*
INCRIN   EQU   *
*
         AR    IN,LENGTH               INCR 'IN'
*
STABLIN  EQU   *
*
         AR    OUT,LENGTH              INCR 'OUT'
         TM    FLAG4,UPDATED           * UPDATE COMPLETE?
         BZ    COMPARE                 NO
*
CHEKLINK EQU   *
*
*      CHECK NEXT ENTRY TO BE MOVED.  GO TO 'CHEKROOM' IF IT IS NOT A
*      LINK ENTRY.  IF IT IS, GO TO 'NEXTLOAD' IF THE LINK IS ZERO
*      AND GO TO NEXT INSTRUCTION 'READ' IF LINK IS NON-ZERO.
*
         CLC   ENAME,HIBIN             IS NEXT ENTRY A LINK ENTRY?
         BNE   CHEKROOM                NO
*
         NC    ETTR,ETTR               IS LINK TTR ZERO?
         BZ    LAST                    YES, END OF INPUT
*
*      UPDATE IS COMPLETE. THE NEXT ENTRY IN 'INPUT' IS A LINK ENTRY
*      WITH A NON-ZERO TTR.
*
         TM    FLAG4,STOP              * IS THIS THE FIRST BLOCK?
         BC    11,CONTUPDT             NO, CONTINUE UPDATE
*                                                               SA52084
*      'SLACK' IS NOT PERMITTED IN GDG PROCESSING               SA52084
*                                                               SA52084
         TM    FLAG3,GDS               GDG PROCESSING?          SA52084
         BO    CONTUPDT                YES, CONTINUE UPDATE     SA52084
*
*      CHECK UNUSED BYTES IN BLOCK.
*
*      IF NUMBER OF UNUSED BYTES IS LESS THAN 'SLACK', THEN STOP
*      THE UPDATE PROCESS, CONTINUE IF NOT.
*
         LA    R0,SLACK(OUT)           ADD SLACK TO PTR
         LA    R1,OUTLKLMT             GET LAST AVAIL BYTE ADDR
         CR    R0,R1                   NO. OF UNUSED BYTES PERMSBLE?
         BNL   LAST                    YES
*
*      READ A NEW INPUT BLOCK IF NECESSARY.
*
CONTUPDT EQU   *
*
         MVC   READTTR,ETTR            GET TTR OF NEXT BLOCK FOR UPDATE
         BAL   R10,GET                 ***READ IT IN***
         B     CHEKLINK                CHECK FIRST ENTRY
*
*
LAST     EQU   *
*
*      PREPARE TO GO TO IGG0CLC7 FOR THE WRITING OF THE
*      LAST BLOCK.
*
         MVC   0(L'LNKENTRY,OUT),0(IN) MOVE IN THE ILE
         BAL   BALREG3,SETKEYCT        SET KEY AND 'OUTBYTSU'
*
*      FREE THE BLOCK AT 'LINKTTR' UNLESS IT IS BEING USED
*
         DROP  IN
         USING ENTRY,OUT               ESTABL ADDRBLTY TO LINK ENTRY
         CLC   ETTR,LINKTTR            BLOCK AT 'LINKTTR' BEING USED?
         BE    DONTFREE                YES, DON'T FREE THE BLOCK
*
         MVC   EXCLUDE,LINKTTR         SET UP FOR 'KEY0WRIT'
         BAL   BALREG3,KEY0WRIT        GO FREE THE BLOCK
         BAL   BALREG3,HOLE            REPLACE 'VFHOLE' IF NECESSARY
         DROP  OUT
         USING ENTRY,IN                RE-ESTABL ADDRBLTY TO IN ENTRY
*
DONTFREE EQU   *
*
         B     ERR00                   GO TO IGG0CLC7
*
         EJECT
*******************************                                @OZ11109
*                             *
EDITYPE  EQU   *              *                                @OZ11109
*                             *
* TEST FOR VALID RECORD TYPE  *                                @OZ11109
*******************************
         CLI   ETYPE,NCVOL                                     @OZ11109
         BNH   ETYPEOK                                         @OZ11109
         CLI   ETYPE,DSPE7                                     @OZ11109
         BE    ETYPEOK                                         @OZ11109
         CLI   ETYPE,DSPED                                     @OZ11109
         BE    ETYPEOK                                         @OZ11109
         CLI   ETYPE,DSPE13                                    @OZ11109
         BE    ETYPEOK                                         @OZ11109
         CLI   ETYPE,DSPE19                                    @OZ11109
         BE    ETYPEOK                                         @OZ11109
         CLI   ETYPE,DSPE1F                                    @OZ11109
         BE    ETYPEOK                                         @OZ11109
         MVI   ERRCATSV,ERROR08        NOT A VALID ENTRY       @OZ11109
         OI    FLAG2,ETYPERR                                   @OZ11109
         B     IGG0CLC7                                        @OZ11109
ETYPEOK  EQU   *                                               @OZ11109
         BR    BALREG3                                         @OZ11109
         EJECT
*
****************
*              *
GET      EQU   *
*              *
****************
*
*       IF 'LINKTTR' IS EMPTY OR EQUAL TO 'READTTR', CONTINUE.
*       ELSE, EMPTY 'LINKTTR' BY CALLING 'PUT'.
*
         NC    LINKTTR,LINKTTR         EMPTY?
         BZ    GETCHP                  YES
*
         CLC   LINKTTR,READTTR         EQUAL TO 'READTTR'?
         BE    GETCHP                  YES
*
         BAL   BALREG3,PUT             ***GO WRITE THE BLOCK***
*
GETCHP   EQU   *
*
         MVC   NEXTKEY,HIBIN           SET IN CASE NEXT KEY NOT READ
         MVC   OPTNCCW,RD              MOVE IN READ DATA CCW
         MVI   RC,RKDOP                MOVE IN READ KEY & DATA OP-CODE
         MVI   RC+4,SILI               SUPPRESS INCORRECT LENGTH INDIC
         CLC   VHIREC,READTTR+2        LAST RECORD ON TRK?
         BE    GETREAD                 YES, DON'T READ NEXT KEY
*
         OI    OPTNCCW+4,CC            COMMAND CHAIN
*
GETREAD  EQU   *
*
         L     R0,READTTR              GET READ ADDRESS
         BAL   BALREG2,TOABSL          CONVERT THE READ ADDRESS
*
*      READ DATA INTO INPUT AND NEXT KEY IF ON SAME TRACK
*
         BAL   BALREG1,IO1             ***READ DATA & KEY***
         MVI   RC,RCOP                 RESTORE RC CCW
         MVI   RC+4,CC
         NI    FLAG4,CONTIGLC          * TURN OFF 'CONTIGL' BIT
         BAL   BALREG3,KEY0WRIT        FREE THE BLOCK AT 'EXCLUDE'
*
*      UPDATE 'WRITETTR' AND 'LINKTTR' AS APPROPRIATE TO THE PATTERN
*      OF GETS AND PUTS FOR THIS REQUEST.
*
*      IF 'WRITETTR' IS ZERO OR EQUAL TO 'READTTR'
*      THEN SET
*      'WRITETTR' EQUAL TO 'READTTR', AND
*      'LINKTTR' FROM THE INDEX LINK ENTRY IN THE BLOCK JUST READ.
*
*      IF 'WRITETTR' DOES NOT MEET THE ABOVE CONDITION,
*      THEN SET
*      'LINKTTR' EQUAL TO 'READTTR'.
*
         NC    WRITETTR,WRITETTR       OK TO PUT 'READTTR' HERE
         BZ    GETWRITE                YES
*
         CLC   WRITETTR,READTTR        IS 'READTTR' ALREADY HERE?
         BE    GETWRITE                YES
*
*      MUST SET 'LINKTTR' EQUAL TO 'READTTR'
*
         NC    NEXTKEY,NEXTKEY         IS NEXT BLOCK AVAIL
         BNZ   GETLINK                 NO
*
*      INDIC THAT BLOCK FOLLOWING 'LINKTTR' IS A FREE BLOCK
*
         OI    FLAG4,CONTIGL           * TURN ON 'CONTIGL' BIT
*
GETLINK  EQU   *
*
         MVC   LINKTTR,READTTR         SET 'LINKTTR'
         B     GETDONE                 PREPARE TO RETURN
*
*
GETWRITE EQU   *
*
*      SET 'WRITETTR' EQUAL TO 'READTTR'
*
         NI    FLAG4,CONTIGWC          * 'WRITETTR' EQUALS ZERO
         NC    NEXTKEY,NEXTKEY         IS THE NEXT BLOCK AVAILABLE?
         BNZ   GETSET                  NO
*
*      INDIC THAT BLOCK FOLLOWING WRITETTR IS A FREE BLOCK
*
         OI    FLAG4,CONTIGW           * TURN ON 'CONTIGW' BIT
*
GETSET   EQU   *
*
         DROP  IN
         USING ENTRY,R1                EST ADDRBLTY TO LINK ENTRY
         MVC   WRITETTR,READTTR        SET 'WRITETTR'
         LH    R1,INBYTSU              NUMBER OF BYTES USED
         LA    R1,INPUT-L'LNKENTRY(R1) POINT TO LINK ENTRY
*
*      SET 'LINKTTR'
*
         MVC   LINKTTR,ETTRTYPE        MOVE IN LINK TTR & ZERO COUNT
*
GETDONE  EQU   *
*
*
*      SAVE THE READ ADDRESS.  LATER, IF A TTR BECOMES UNNEEDED
*      BECAUSE OF REARRANGING FOR CONTIGUITY (IN 'PUT'),
*      THE BLOCK AT THAT TTR MAY BE FREED IF IT HAS BEEN READ.
*
         MVC   SAVETTR,READTTR         INDIC BLOCK IS IN 'INPUT'
         XC    READTTR,READTTR         ZERO 'READTTR'
         LA    IN,INENTRY              POINT TO FIRST ENTRY
         BR    R10                     RETURN
*
         DROP  R1
*
         EJECT
*
****************
*              *
PUT      EQU   *
*              *
****************
*
         STM   R10,R11,SVAREA2X        BALREG3 EQU R11
         BAL   BALREG2,PUTINCR         GET TTR FOLLOWING WRITETTR
*
*      LOOK FOR CONTIGUITY
*
         C     R1,LINKTTR              ALREADY CONTIGUOUS?
         BE    PUTWRITE                YES
*
         LR    NEXTTTR,R1              SAVE 'NEXTTTR'
*      IS NEXT BLOCK THE FIRST AVAIL?                           SA52119
         CL    NEXTTTR,VFHOLE                                   SA52119
         BE    PUTFHOLE                YES, USE IT
*
         TM    FLAG4,CONTIGW           IS NEXT BLOCK FREE?
         BO    PUTNEXT                 YES, USE IT
*
         B     PUTHOLE                 CONTIGUITY IMPOSSIBLE
*
*
PUTFHOLE EQU   *
*
         BAL   BALREG3,KEY0PREP        PREPARE TO FREE A BLOCK
         BAL   BALREG3,HOLE            MAINTAIN VFHOLE
         B     PUTHOLE                 GO SET 'LINKTTR'
*
*
PUTNEXT  EQU   *
*
         BAL   BALREG3,KEY0PREP        PREPARE TO FREE A BLOCK
         ST    NEXTTTR,LINKTTR         USE 'NEXTTTR'
         B     PUTWRITE                TTRS ARE SET
*
*
PUTHOLE  EQU   *
*
         NC    LINKTTR,LINKTTR         LINKTTR = 0?
         BNZ   PUTWRITE                NO, 'LINKTTR' SET OK
*
         L     R0,VFHOLE               GET TTR OF FIRST HOLE
         BAL   BALREG3,SWAP            SET 'LINKTTR' = 'VFHOLE'
         BAL   BALREG2,TOABSL          GO TO CONVERT
         MVC   OPTNCCW,TIC2            MOVE IN SEARCH CCW
         BAL   BALREG1,IO1             ***SEARCH FOR KEY=0***
         BAL   BALREG2,TORLTV          GET ITS TTR
         ST    R0,VFHOLE               MAINTAIN 'VFHOLE'
*
PUTWRITE EQU   *
*
         USING ENTRY,OUT               ESTABL ADDRBLTY TO ENTRY
         MVC   EINDEX,LNKENTRY         MOVE IN ILE
         BAL   BALREG3,SETKEYCT        GO SET KEY & 'OUTBYTSU'
         MVC   OPTNCCW,WKD             MOVE IN WRITE KEY & DATA CCW
         BAL   BALREG1,IO1             ***WRITE KEY AND DATA***
*
*      VERIFY THE WRITE OPERATION
*
         MVC   OPTNCCW,RKD             MOVE IN CCW--NO TRANSFER
         BAL   BALREG1,IO1             ***READ KEY AND DATA***
         XC    OUTDATA,OUTDATA         CLEAR THE OUTPUT BLOCK
         TM    FLAG4,ERRORTTR          ERROR HOLD ON?          @OZ12193
         BNO   STORTTR                 YES - FALL THROUGH      @OZ12193
         MVC   CONWORK(4),WRITETTR     SAVE FOR MSG IEC304I    @OZ12193
         NI    FLAG4,X'FF'-ERRORTTR    TURN ERROR HOLD OFF     @OZ12193
STORTTR  EQU   *
         MVC   WRITETTR,LINKTTR        SET NEW 'WRITETTR'
         XC    LINKTTR,LINKTTR         ZERO 'LINKTTR'
         OI    FLAG4,WROTE             * INDIC FIRST BLOCK WRITTEN
         NI    FLAG4,CONTIGC           * TURN OFF ALL CONTIG SW
         LM    R10,R11,SVAREA2X        BALREG3 EQU R11
         LA    OUT,OUTENTRY            POINT TO FIRST ENTRY SLOT
         BR    BALREG3                 RETURN
*
         EJECT
*
****************
*              *
PUTINCR  EQU   *
*              *
****************
*
         L     R1,WRITETTR             GET TTR TO INCREMENT
         CLC   VHIREC,WRITETTR+2       END OF TRACK?
         BE    PUTINCRT                YES, INCREMENT TRACK
*
         A     R1,ONEREC               INCREMENT RECORD         SA53646
         BR    BALREG2                 RETURN
*
*
PUTINCRT EQU   *
*
         SRL   R1,D16                  SHIFT OUT THE R
         LA    R1,X01(R1)              INCREMENT TT
         SLL   R1,D16                  REPOSITION TTR IN REG
         A     R1,ONEREC               SET R TO 1               SA53646
         BR    BALREG2                 RETURN
*
         EJECT
*
****************
*              *
KEY0PREP EQU   *
*              *
****************
*
         MVC   EXCLUDE,LINKTTR         SAVE TTR OF BLOCK TO BE FREED
         CLC   EXCLUDE,SAVETTR         BLOCK BEEN READ?
         BE    KEY0WRIT                YES, GO FREE IT
*
         MVC   LINKTTR,HIBIN           SET LINKTTR TO FF
         BR    BALREG3                 RETURN
*
*
KEY0WRIT EQU   *
*
         NC    EXCLUDE,EXCLUDE         IS TTR ZERO?
         BCR   8,BALREG3               YES, NOTHING TO FREE, RETURN
*
         L     R0,EXCLUDE              TTR OF BLOCK TO FREE
         BAL   BALREG2,TOABSL          GO CONVERT IT
         MVC   OPTNCCW,NOP             MOVE IN SKELETON CCW
         MVI   OPTNCCW,WKDOP           MOVE IN WRITE KEY & DATA CCW
         BAL   BALREG1,IO1             WRITE ZERO KEY AND BLOCK
         XC    EXCLUDE,EXCLUDE         BLOCK IS FREED
         BR    BALREG3                 RETURN
*
         EJECT
*
****************
*              *
SETKEYCT EQU   *
*              *
****************
*
         LR    R10,BASE                MAKE R10 BIG
         BAL   BALREG2,PUTINCR         GO INCREMENT 'WRITETTR'
         ST    R1,SAVETTR3             SAVE TTR OF NEXT BLOCK
         CLC   ETTR,SAVETTR3           SHOULD KEY INDIC CONTIGUITY?
         BNE   SETKEY                  NO, GO RESET KEY
*
         XR    R10,R10                 YES, CHECK FOR EXTENT BOUNDARY
         L     R0,SAVETTR3             GET LINK TTR
         BAL   BALREG2,TOABSL          GO TO CONVERT
         IC    R10,IOBSKADD            SAVE THE 'M'
*
SETKEY   EQU   *
*
         L     R0,WRITETTR             GET WRITE TTR
         BAL   BALREG2,TOABSL          GO TO CONVERT
         IC    R15,IOBSKADD            PICK UP 'M'
         CR    R10,R15                 ARE 'M'S EQUAL?
         BE    SETCOUNT                YES
*
         MVC   OUTKEY,HIBIN            SET KEY TO ALL X'FF'
*
SETCOUNT EQU   *
*
         LA    R10,L'EINDEX(OUT)       BUMP 'OUT' AROUND ILE
         LA    R0,OUTDATA              POINT TO START OF BLOCK
         SR    R10,R0                  GET BYTES USED
         STH   R10,OUTBYTSU            SET BYTES USED
         BR    BALREG3                 RETURN
*
         DROP  OUT
*
         EJECT
*
****************
*              *
HOLE     EQU   *
*              *
****************
*
         CLC   VFHOLE,LINKTTR          NEED TO UPDATE VFHOLE?
         BH    SWAP                    YES
*
         XC    LINKTTR,LINKTTR         NO, DISPOSE LINKTTR
         BR    BALREG3                 RETURN
*
*
SWAP     EQU   *
*
         XC    VFHOLE,LINKTTR          START THE SWAP
         XC    LINKTTR(L'VFHOLE),VFHOLE
         XC    VFHOLE,LINKTTR          SWAP COMPLETE
         BR    BALREG3                 RETURN
*
         EJECT
*
****************
*              *
TOABSL   EQU   *
*              *
****************
*
* FUNCTION:
*    CONVERT THE TTR0 IN R0 TO AN ABSOLUTE DASD ADDRESS AND
*    PUT IT INTO THE IOB MBBCCHHR
*
* INPUT:
*    R0 IS THE TTR0 TO BE CONVERTED
*    RETURN ADDRESS IN BALREG2
*
* OUTPUT:
*    ABSOLUTE DASD ADDRESS IN IOB
*    ERROR CODE IN R15
*
* DESTROYED:
*    REGISTERS - R0,R1,R2,R14, AND R15=0
*    WA - SAVEAREA AND MBBCCHHR OF THE IOB
*
* SUBROUTINES USED:
*         THE RESIDENT CONVERT ROUTINE - IECPCNVT
*
*
****************
****************
*
         L     R15,EPTOABSL            GET CONVERT ADDRESS FROM WA
         B     CONVERT                 USE COMMON CODE
         EJECT
*
****************
*              *
TORLTV   EQU   *
*              *
****************
*
* FUNCTION:
*    MOVE THE DASD ADDRESS OF CCHHR FROM NXTCNT INTO THE CCHHR OF THE
*    IOB.  THIS GIVES THE TTR OF THE NEXT FREE BLOCK.
*
* INPUT:
*    RETURN IN BALREG2
*    UPDATED NXTCNT
*
* OUTPUT:
*    TTR0 IN R0
*
* DESTROYED:
*    REGISTERS -- R0,R1,R2,R14, AND R15=0
*    WA -- SAVEAREA AND CCHHR OF IOB
*
* SUBROUTINES USED:
*         THE RESIDENT CONVERT ROUTINE -- IECPRLTV
*
*
****************
****************
*
         MVC   IOBSKADD+3(L'NXTCCHHR),NXTCCHHR    MOVE COUNT FIELD
*
         L     R15,EPTORLTV            GET ADDRESS OF ROUTINE FROM WA
*
*
CONVERT  EQU   *
*
*      THE FOLLOWING SECTION IS COMMON TO BOTH ROUTINES
*
         STM   R9,R13,SAVEAREA         SAVE REGS DESTROYED BY CONVERT
         L     R1,DEBADDR              GET DEB ADDRESS
         LA    R2,IOBSKADD             POINT TO MBBCCHHR
         BALR  BALREG1,R15             GO TO CONVERT ROUTINE
         LM    R9,R13,SAVEAREA         RESTORE REGISTERS
         BR    BALREG2                 RETURN TO CALLER
         EJECT
*
****************
*              *
IO1      EQU   *
*              *
****************
*
* FUNCTION:
*    1.  IF THE DEVICE HAS THE RPS FEATURE, THE SET SECTOR CCW IS
*        UPDATED.
*    2.  ISSUE EXCP FOR THE CHANNEL PROGRAM POINTED TO BY THE IOB.
*    3.  WAIT FOR THE OPERATION TO COMPLETE AND CHECK THE ECB.
*    4.  IF AN END OF EXTENT CONDITION, BRANCH TO IGC0002H     @YL026UD
*        AND EXTEND THE CATALOG.                               @YL026UD
*    5.  IF A PERMANENT I/O ERROR, SET AN ERROR CODE AND XCTL TO
*        IGG0CLC7.
*
* INPUT:
*    UPDATED CHANNEL PROGRAM
*    RETURN ADDRESS IN BALREG 1
*
* OUTPUT:
*    1.  FILLED BUFFER
*    2.  EMPTIED BUFFER
*    3.  ANOTHER FREE BLOCK ADDRESS
*
* DESTROYED:
*    REGISTERS R0,R1,R15 (IF EXTENDS), AND ERRCAT
*
* EXTERNAL ROUTINES USED:
*    EXCP, WAIT, IGC0002H TO EXTEND CATALOG                    @YL026UD
*
* EXITS:
*         IGC0002H TO EXTEND THE CATALOG                       @YL026UD
*         IGG0CLC7 FOR PERMANENT I/O ERROR
***
*
         USING RPSD,R1                 ESTABL ADDRBLTY TO RPS WORKAREA
         TM    FLAG2,RPSDEV            * RPS FEATURE?
         BZ    EXCP1                   BRANCH IF NO
*
         L     R1,RPSAVEP              GET RPS SAVE AREA PTR
         STM   R9,R2,RPSAVE            SAVE REGS DESTROYED BY CONVERT
         LM    R15,R2,RPSINPUT         GET CONVERT INPUT PARAMETERS
         IC    R0,IOBSKADD+7           GET R OF CCHHR
         BALR  R14,R15                 CONVERT R TO THETA
         LM    R9,R2,RPSAVE            RESTORE REGISTERS
*
EXCP1    EQU   *
*
         EXCP  IOB                     ISSUE EXCP
         WAIT  ECB=ECB                 WAIT FOR REQUEST
         CLI   ECB,X7F                 I/O ERROR?
         BCR   8,BALREG1               RETURN IF NO
*
         CLC   OPTNCCW,TIC2            SEARCHING FOR NEXT HOLE?
         BNE   ERR28                   NO
*
         CLI   ECB,X42               END OF EXTENT?            @OZ00006
         BNE   ERR28                 NO,  SET I/O ERROR        @OZ00006
         MVI   VFHOLE,XFF              INDIC CATALOG FULL
         B     PUTWRITE                RETURN
*
         DROP  R1
*
         EJECT
*
ERR28    EQU   *
*
         MVI   ERRCATSV,ERROR28        RETURN CODE IS 28       @YL026UD
         B     IGG0CLC7                GO TO ERROR MODULE      @YL026UD
*
*
ERR00    EQU   *
*
         XR    R1,R1                   SET FOR NORMAL EXIT
         XC    ERRCODE,ERRCODE         RETURN CODE IS 00
         B     IGG0CLC7
*
         TITLE 'IGG0CLCE - (IGG0CLC7) THIRD LOAD OF UPDATE AND CLEANUP'
***********************************************************************
*                                                                     *
*     IGG0CLC7 - THIRD LOAD OF UPDATE AND CLEANUP                     *
*                                                                     *
***********************************************************************
*                                                              @YL026UD
         ENTRY IGG0CLC7                                        @YL026UD
*
IGG0CLC7 EQU   *                                               @YL026UD
*
         BALR  BASE,0                  SET BASE FOR MODULE
         USING *,BASE                  ESTABL BASE FOR MODULE
*
         USING ENTRY,R7                ESTABL BASE FOR ENTRY DSECT
         USING WORKAREA,R6             ESTABL BASE FOR WORKAREA
         USING CAMLSTD,R8              ESTABL BASE FOR CAMLST
         USING SVRBEXT,R5              ESTABL BASE FOR SVRB EXTN
*
         OI    MODMAP1,MODCLC7         INDIC ENTRY TO IGG0CLC7
         L     R5,SVRBEXTP             SET BASE FOR SVRB EXTN
*
*      IF R1 IS NEGATIVE, THEN AN ERROR OCCURRED IN 'OPENEXT', AS
*      CALLED FROM A PREVIOUS MODULE
*
         LCR   R1,R1                   NEGATIVE?
         BP    ERR2H                   BRANCH IF YES
*
         NC    ERRCODE,ERRCODE         ERROR TO PROCESS?        SA52062
         BNZ   ERREXIT                 BRANCH AND PROCESS ERROR SA52062
*                                                               SA52062
         EJECT
*
*      COMPLETE THE UPDATE
*      .  WRITE THE LAST BLOCK OF THE UPDATE
*      .  UPDATE THE ICE IF NECESSARY
*      .  UPDATE THE VICE IF NECESSARY
*      .  CHECK FOR THE NEED TO EXTEND THE SYSCTLG DATA SET
*
*      THE BLOCK IN 'OUTPUT' IS THE LAST BLOCK OF THE UPDATE.
*      SET UP TO WRITE KEY & DATA FROM 'OUTPUT'.
*
         L     R0,WRITETTR             GET THE WRITE ADDR
         BAL   BALREG2,TOABSL1         GO TO CONVERT
         TM    FLAG4,ERRORTTR          ERROR HOLD ON?          @OZ12193
         BNO   DONTSAVE                YES - FALL THROUGH      @OZ12193
         MVC   CONWORK(4),WRITETTR     SAVE FOR MSG IEC304I    @OZ12193
         NI    FLAG4,X'FF'-ERRORTTR    TURN ERROR HOLD OFF     @OZ12193
DONTSAVE EQU   *
         MVC   OPTNCCW,WKD             MOVE IN WRITE KEY & DATA OP-CODE
*
*      THE BLOCK MAY CONTAIN THE ICE FOR THE LEVEL OR IT MAY CONTAIN
*      THE VICE.  IT IS CHECKED FOR THESE TWO POSSIBILITIES
*      AND HANDLED ACCORDING TO THE FOLLOWING DECISION TABLE.
*
*      'Y' INDICATES THE REFERENCED BIT IN 'FLAG5' IS '1'B.
*      'N' INDICATES THE REFERENCED BIT IN 'FLAG5' IS '0'B.
*
*      ---------------------------------------------------------------
*      ×                             ×'FLAG5'× 1 2 3 4 5 6 7 8 9 A B ×
*      ---------------------------------------------------------------
*      × BLOCK CONTAIN ICE OR VICE?  × 'FST' ×   Y Y N N N N N Y Y Y ×
*      × 'XLSTBLK' FIELD REQ UPDATE? × 'LST' × N Y Y Y Y Y Y N N Y N ×
*      × NEW 'VFHOLE'?               × 'VFH' × N N Y N Y Y N Y Y   Y ×
*      × UPDATE IN LOW LEVEL INDEX?  × 'LIN' ×   Y Y Y Y N N   Y N N ×
*      ---------------------------------------------------------------
*      × UPDATE 'VLSTBLK'                    ×           X X     X   ×
*      ---------------------------------------------------------------
*      × 'VICE' TO 'OUTPUT'     × 'MOVEVICE' ×                   X X ×
*      × WRITE 'OUTPUT'         × 'WRITVICE' × X                 X X ×
*      × CHECK FOR CATALOG FULL ×            × X                 X X ×
*      × WRITE 'OUTPUT'         × 'READICE'  ×       X X             ×
*      × READ IN ICE BLOCK      ×            ×       X X             ×
*      × 'ILSTBLK' TO 'INPUT'   ×            ×       X X             ×
*      × WRITE 'INPUT'          ×            ×       X X             ×
*      × 'ILSTBLK' TO 'OUTPUT'  × 'MOVEICE'  ×   X X                 ×
*      × WRITE 'OUTPUT'         × 'WRITICE'  ×   X X     X X X X     ×
*      × READ IN VICE BLOCK     × 'READVICE' ×     X   X X X X X     ×
*      × 'VICE' TO 'INPUT'      ×            ×     X   X X X X X     ×
*      × WRITE 'INPUT'          ×            ×     X   X X X X X     ×
*      × CHECK FOR CATALOG FULL × 'CHEKSPAC' ×     X   X X X X X     ×
*      ---------------------------------------------------------------
*
         EJECT
*
*      SET SWITCHES IN 'FLAG5', 'VFHOLE' AND 'VLSTBLK'
*
         CLI   ITYPE,ICETYP            UPDATING LOW LEVEL?
         BNE   VIUPDATE                NO, UPDATING THE VOL INDEX
*
         OI    FLAG5,LIN               * SET LOW LEVEL INDEX SWITCH
         MVC   TEMPBUFF(L'ICEPERT),ICEPERT GET PERT PORTION OF ICE
         B     FSTCHEK                 GO CHECK FOR 'FST'
*
*
VIUPDATE EQU   *
*
         MVC   TEMPBUFF(L'VICEPERT),VICEPERT GET PERT PORTION OF VICE
         MVC   FSTBLK,TTRVFST          FIRST BLOCK OF VOLUME INDEX
*
FSTCHEK  EQU   *
*
         CLC   FSTBLK,WRITETTR         WRITING THE FIRST BLOCK?
         BNE   LSTCHEK                 NO, GO CHECK FOR 'LST'
*
         OI    FLAG5,FST               * SET FIRST BLOCK SWITCH
*
LSTCHEK  EQU   *
*
         NC    ETTR,ETTR               WRITING THE LAST BLOCK?
         BNZ   VFHCHEK                 NO, GO CHECK 'VFH'
*
         CLC   LSTBLK,WRITETTR         LAST BLOCK PROPERLY INDIC?
         BE    VFHCHEK                 YES, GO CHECK FOR 'VFH'
*
         OI    FLAG5,LST               * SET 'LST' SWITCH
         TM    FLAG5,LIN               * LOW LEVEL UPDATE?
         BO    VFHCHEK                 YES, DON'T RESET 'VLSTBLK'
*
         MVC   VLSTBLK,WRITETTR        RESET 'VLSTBLK'
*
VFHCHEK  EQU   *
*
         CLC   VSAVE,VICESAVE          NEED TO UPDATE VICE?
         BE    ROUTE                   NO
*
         OI    FLAG5,VFH               * YES, SET 'VFH' SWITCH
*
         EJECT
*
ROUTE    EQU   *
*
         TM    FLAG5,LST+VFH           * TAKE THE 'WRITVICE' ENTRY?
         BZ    WRITVICE                YES
*
         TM    FLAG5,FST+LST+LIN       * TAKE THE 'MOVEICE' ENTRY?
         BO    MOVEICE                 YES
*
         TM    FLAG5,LST+LIN           * TAKE THE 'READICE' ENTRY?
         BO    READICE                 YES
*
         TM    FLAG5,FST               * TAKE THE 'WRITICE' ENTRY?
         BZ    WRITICE                 YES
*
         TM    FLAG5,LIN               * TAKE THE 'MOVEVICE' ENTRY?
         BO    WRITICE                 NO
*
*      FALL THRU TO 'MOVEVICE'
*
         EJECT
*
MOVEVICE EQU   *
*
         MVC   OUTENTRY+L'VNAME(L'VICEPERT),VICEPERT VICE TO 'OUTPUT'
*
WRITVICE EQU   *
*
         BAL   BALREG4,WRITE           ***WRITE KEY & DATA***
         B     CHEKSPAC                CHECK FOR CATALOG FULL
*
*
READICE  EQU   *
*
         BAL   BALREG4,WRITE           ***WRITE KEY & DATA***
         L     R0,IFSTBLK              TTR OF ICE
         IC    R0,ZERO                 ZERO ALIAS COUNT
         BAL   BALREG4,READ            ***READ ICE DATA***
         MVC   INENTRY+L'INAME(L'ILSTBLK),WRITETTR    MOVE IN NEW ICE
         BAL   BALREG4,WRITE           ***WRITE ICE DATA***
         TM    FLAG5,VFH               * OK TO QUIT UPDATE?
         BZ    EXITCODE                YES
*
         B     READVICE                NO, VICE NEEDS UPDATING
*
*
MOVEICE  EQU   *
*
         MVC   OUTENTRY+L'INAME(L'ILSTBLK),WRITETTR UPDATE ICE
*
WRITICE  EQU   *
*
         BAL   BALREG4,WRITE           ***WRITE KEY & DATA***
         CLI   FLAG5,FST+LST+LIN       * OK TO QUIT UPDATE?
         BE    EXITCODE                YES
*
READVICE EQU   *
*
         LA    R0,X0100                GET TTR OF VICE
         BAL   BALREG4,READ            ***READ VICE DATA***
         MVC   INENTRY+L'VNAME(L'VICEPERT),VICEPERT  VICE TO 'INPUT'
         BAL   BALREG4,WRITE           ***WRITE VICE DATA***
         EJECT
*
CHEKSPAC EQU   *
*
         CLI   VFHOLE,XFF              IS CATALOG FULL?
         BNE   EXITCODE                NO, FUNCTION IS COMPLETE
*
*      CATALOG IS FULL.  ATTEMPT TO EXTEND BY STARTING AT THE LAST
*      BLOCK IN THE CATALOG AND SEARCHING FOR KEY=0.
*      'IO' WILL BRANCH TO IGC0002H TO EXTEND.                 @YL026UD
*
*      IF A NEW EXTENT IS AVAILABLE, CONTROL WILL RETURN AND 'VFHOLE'
*      WILL BE UPDATED IN THE ALREADY WRITTEN VICE.
*
*      IF NO NEW EXTENT IS AVAILABLE, CONTROL WILL GO TO THE
*      EXITING CODE AND THE VICE WILL REMAIN INDICATING CATALOG
*      FULL.
*
         MVC   OPTNCCW,TIC2            TO SEARCH KEY=0
         MVC   VFHOLE,VICESAVE         PUT ON WORD BDY           YM5075
         L     R0,VFHOLE               TTR OF ORIGINAL 'VFHOLE'  YM5075
         BAL   BALREG2,TOABSL1         GO TO CONVERT
         BAL   BALREG1,IO2             ***SEARCH KEY=0***
         BAL   BALREG2,TORLTV1         GO TO CONVERT
         ST    R0,VFHOLE               UPDATE 'VFHOLE'
*
*      'VCLSTBLK' IS UPDATED BY IGC0002H                       @YL026UD
*
         B     READVICE                UPDATE VICE
*
         EJECT
*
ERREXIT  EQU   *
*
         TM    FLAG1,LOCATEF           LOCATE?
         BO    EXITCODE                BRANCH IF YES
*
         CLI   VTYPE,VICETYP           IS VICE IN CORE?
         BNE   EXITCODE                BRANCH IF NO AND DON'T CREATE ER
*
*      SAVE REGISTERS IN CASE AN ENVIRONMENT RECORD IS CREATED.
*
         LA    R15,OUTPUT              SET TEMPORARY BASE FOR ER
         USING EREC,R15
         STM   R0,R14,EREGSAV          SAVE REGS EXCEPT R15
         LR    R9,R15                  SET PERMANENT BASE FOR ER
         DROP  15
         USING EREC,R9
         CLI   ERRCATSV,ERROR08        CATALOG ERROR=8?
         BE    ER                      BRANCH IF YES AND CREATE ER
*
*      CREATE AN ENVIRONMENT RECORD FOR ALL ERROR CODES 28 OR GREATER
*
         CLI   ERRCATSV,ERROR28        I/O ERROR?
         BL    EXITCODE                BRANCH IF NO
*
*
ER       EQU   *
*
*      SAVE THE IOB AND OPTION CCW ('OPTNCCW') SO MORE I/O MAY BE
*      DONE AND NOT INVALID THE ENVIRONMENT RECORD
*
         MVC   ERIOB,IOB               SAVE OLD IOB
         MVC   EROPTNCC,OPTNCCW        SAVE OPTION CCW
*
*      IF THE LAST BLOCK OF THE DATA SET ('VCLSTBLK') IS AVAILABLE
*      (KEY FIELD ZERO), THEN THE ENVIRONMENT RECORD (SEE EREC DSECT
*      FOR A DESCRIPTION) MAY BE WRITTEN.
*
         L     R0,VCLSTBLK             GET TTR TO CATALOG LAST BLOCK
         BAL   BALREG2,TOABSL1         CONVERT
*
*      SET UP CCW TO READ LAST KEY FIELD
*
         LM    R14,R15,ERCCWR          GET RKD CCW
         AR    R14,R9                  RELOCATE
         STM   R14,R15,OPTNCCW         BUILD THE CHANNEL PROGRAM
*
*      READ KEY FIELD AND 4 BYTES OF DATA OF THE LAST BLOCK OF CATALOG
*      DATA SET.
*
         BAL   BALREG1,IO2             ***READ KEY FIELD***
         NC    ERKEY,ERKEY             KEY 0?
         BNZ   EXITCODE                DO NOT CREATE ER
*
*      CREATE THE ENVIRONMENT RECORD (SEE EREC FOR A DESCRIPTION)
*
*      RELOCATE WRITE CCW
*
         LM    R14,R15,ERCCWW          GET WRITE DATA CCW
         AR    R14,R9                  RELOCATE FOR EREC1
         STM   R14,R15,OPTNCCW         BUILD THE CHANNEL PROGRAM
*
*      FIRST SAVE THE FIRST 20 BYTES OF EACH BUFFER
*
         MVC   ERINPUT,INENTRY         SAVE 18 BYTES OF INPUT
         MVC   EROUTPUT,OUTENTRY       SAVE 18 BYTES OF OUTPUT
         LA    R1,D01
         A     R1,EROCTR               INCREMENT BY 1
         ST    R1,ERCTR                SAVE IN NEW OUTPUT AREA
         MVC   ERMODMAP,MODMAP1        RELOCATE MOD MAP
         MVC   ERERRCOD,ERRCODE        RELOCATE ERROR CODES
         MVI   ERNAME,CCDBLANK
         MVC   ERNAME+1(L'ERNAME-1),ERNAME     BLANK NAME
         LH    R15,NAMLEN              GET LENGTH OF NAME-1
         L     R14,CAMPTR1             GET PTR TO NAME
         EX    R15,MOVENAME            MVC ERNAME(0),0(R14)
         TIME  DEC                     GET TIME AND DATE
         STM   R0,R1,ERTIME            SAVE TIME AND DATE IN ER
*
*      MOVE FLAGS INTO THE RECORD
*
         MVC   ERFLG12,ERFLAG12        FLAG1 AND FLAG2
         MVC   ERFLAG3,FLAG3           FLAG3
         MVC   ERNAMTTR,NAMTTR0        SAVE LEVEL NAME
         MVC   ERCAMLST,CAMLSTD        SAVE OPTION BYTES
         MVC   ERWA1,ERTTRS            SAVE TTRS
         BAL   BALREG1,IO2             WRITE ENVIRONMENT RECORD
         B     EXITCODE                PREPARE AND RETURN TO CALLER
*
*
ERR2H    EQU   *
*
*      AN ERROR FROM IGC0002H, TRANSLATE THE ERROR CODE TO     @YL026UD
*      THE PROPER CATALOG ERROR CODE
*
         STC   R1,ERRSV2H              SAVE ERROR CODE
         LA    R7,ERROR28              INITIALLY ASSUME I/O ERROR
         CLI   ERRSV2H,ERROR12         12?
         BE    SETCODE                 BRANCH IF YES
*
         LA    R7,ERROR20              ASSUME NO SPACE ERROR
         CLI   ERRSV2H,ERROR08         8?
         BE    SETCODE                 BRANCH IF YES
*
         LR    R7,R1                   MUST BE 4 OR 72
*
*      SET SO SCHEDULER MOUNT MESSAGE IS NOT ISSUED
         XC    DEVTYPE,DEVTYPE         0 SWITCH
*
SETCODE  EQU   *
*
         TM    FLAG1,LOCATEF           * LOCATE?
         BZ    SKIP1                   BRANCH IF NO
         STC   R7,ERRLOCSV             LOCATE ERROR
         B     EXITCODE                SET PROPER CODE AND EXIT
*
SKIP1    EQU   *
*
         STC   R7,ERRCATSV             NON-LOCATE ERROR
*                                                              @OZ07699
EXITCODE EQU   *                                               @OZ07699
         USING BLDLAREA,R13            BASE FOR MSGAREA        @ZA05575
*                                                               ZA02665
*  WRITE A MESSAGE TO THE OPERATOR IF THE ERROR CONDITION      @ZA05908
* CALLS FOR IT                                                 @ZA05908
*                                                               ZA02665
         TM    FLAG1,LOCATEF           LOCATE?                 @OZ12244
         BO    TSTSQERR                YES, GOTO TSTSQERR      @OZ12244
         LA    R13,BLDLAREA-WORKAREA(R6) ADDRESSABILITY        @OZ12244
TSTSQERR EQU   *
         TM    FLAG2,SEQERR             DID CLC6 FIND SEQUENCE  ZA02665
*                                       ERROR                   ZA02665
         BZ    TSTENTRY                 NO,SKIP                @ZA05908
         MVC   INPUT(MSG2LEN),MSG2     BUILD ERROR MESSAGE     @ZA05908
*  ROUTINE TO CONVERT TTR FROM HEX TO EBCDC FOR IEC304I MSG
         UNPK  CONWORK(7),CONWORK(4)   TTR                     @OZ12193
         NC    CONWORK(7),MASK         DROP ZONES              @OZ12193
         TR    CONWORK(6),CONTABL      SET TO EBCDIC           @OZ12193
         LA    R1,INPUT+MSG2LEN-15     PT TO TTR OF MSG        @OZ12193
         MVC   0(6,R1),CONWORK         MOVE TTR TO MSG         @OZ12193
         MVC   INPUT+MSG2LEN+44(L'DESCRTE),DESCRTE    MOVE IN  @OZ14802
*                                      ROUTE & DESCR CODES     @OZ14802
         LA    1,INPUT+MSG2LEN-7       SET BASE TO COMPLETE MSG
         B     BUILDMSG                                        @ZA05908
TSTENTRY EQU   *                                               @ZA05908
         TM    FLAG2,ETYPERR           CHK FOR ETYPE ERR       @ZA05908
         BZ    TESTIO                  NO BR                   @ZA05908
         MVC   INPUT(MSG3LEN),MSG3     MOVE MSG TO WORKAREA    @ZA05908
         MVC   INPUT+MSG3LEN+44(L'DESCRTE),DESCRTE    MOVE IN  @OZ14802
*                                      ROUTE & DESCR CODES     @OZ14802
         LA    1,INPUT+MSG3LEN-7       SET TO COMPLETE MSG     @ZA05908
         B     BUILDMSG                                        @ZA05908
TESTIO   EQU   *                                                ZA02665
*                                                              @OZ00006
* WRITE I/O ERROR MESSAGE TO OPERATOR IF THERE WAS AN I/O      @OZ00006
* ERROR, SO HE CAN NOTIFY THE SYSTEMS PROGRAMMER               @OZ00006
*                                                              @OZ00006
         CLI   ERRLOCSV,ERROR28        I/O ERROR ON LOCATE     @OZ00006
         BE    WRITMSG                 YES, WRITE MSG          @OZ00006
         CLI   ERRCATSV,ERROR28        I/O ERROR ON NON-LOCATE @OZ00006
         BNE   SETLEVLS                NOT I/O ERROR, GO EXIT  @OZ00006
WRITMSG  EQU   *                                               @ZA05908
         MVC   INPUT(MSGLEN),MSG      MESSAGE SKELETON         @ZA02274
         MVC   INPUT+MSGLEN+44(L'DESCRTE),DESCRTE     MOVE IN  @OZ14802
*                                      ROUTE & DESCR CODES     @OZ14802
         LA    1,INPUT+MSGLEN-7                                @ZA05908
BUILDMSG EQU   *                                               @ZA05908
         MVC   0(6,1),VOLSN    VOL SER TO MSG                  @ZA05908
         MVI   7(1),CCDBLANK  BLANK NAME                       @ZA05908
         MVC   8(L'ERNAME-1,1),7(1)                            @ZA05908
         LH    R15,NAMLEN              NAME LENGTH             @ZA05908
         L     R14,CAMPTR1             POINT TO NAME           @ZA05908
         EX    R15,MOVENAM2            MOVE NAME TO MSG        @ZA05908
         LA    R1,INPUT                                        @ZA05908
         WTO   MF=(E,(1))                                      @ZA05908
         DROP  R13                                             @ZA05908
*                                                              @OZ00006
SETLEVLS EQU   *                                               @OZ00006
*
*      SET PROPER ANALYSIS RETURN CODES                        @OZ07699
*
         LH    R10,NAMLF               GET # OF LEVELS         @OZ15062
         XR    R11,R11                 CLEAR
         IC    R11,ERRLOCSV            GET LOCATE ERROR CODE
         XR    R7,R7                   CLEAR
         IC    R7,ERRCATSV             INITIALLY ASSUME CATALOG ERROR
*
         LTR   R7,R7                   CATALOG ERROR ?
         BNZ   FREERES                 BRANCH IF YES; RETURN THIS CODE
*
         LTR   R11,R11                 LOCATE ERROR ?
         BZ    FREERES                 BRANCH IF NO; NO ERROR
*
         LR    R7,R11                  SET LOCATE ERROR CODE
         TM    FLAG1,LOCATEF           * LOCATE?
         BO    LOCODE                  BRANCH IF YES
*
         CLI   ERRLOCSV,ERROR04        LOCATE ERROR OF 4?
         BE    FREERES                 BRANCH IF YES
*
         CLI   ERRLOCSV,ERROR72        ERROR 72?
         BE    FREERES                 BRANCH IF YES; RETURN A 72
*
         LA    R7,ERROR08
         CLI   ERRLOCSV,ERROR28        LOCATE I/O ERROR?
         BNE   FREERES                 BRANCH IF NO; RETURN AN 8
*
         LA    R7,ERROR28              SET TO CATALOG I/O ERROR
         B     FREERES                 FREE RESOURCES
*
*
LOCODE   EQU   *
*
         CLI   ERRLOCSV,ERROR28        LOCATE I/O ERROR?
         BNE   FREERES                 BRANCH IF NO; RETURN THIS CODE
*
         TM    CAMOPTN1,CAMBLOCK       LOCATE BY BLOCK?
         BO    DCBDEB                  BRANCH IF YES; RETURN A 28
*
         LA    R7,ERROR24              LOCATE I/O ERROR CODE IS 24
*
FREERES  EQU   *
*
         TM    CAMOPTN1,CAMBLOCK       LOCATE BY BLOCK?
         BO    DCBDEB                  BRANCH IF YES--DO NOT ISSUE DEQ
*
         TM    FLAG2,ESTAEFL      TESTFOR ESTAE FAILURE        @ZA03161
         BNZ   DCBDEB                  BRANCH IF ESTAE FAILURE @YL026UD
*
*      DEQUEUE VICE, VOLUME INDEX AND HIGH LEVEL NAME(RELEASE DEVICE),
*      IF ENQUEUED UPON
*
         XC    ENQRNAM8,ENQRNAM8       SET RNAME FOR VICE
*
*      SET FLAG TO HAVE IN CASE NO PREVIOUS ENQ
*
         OI    ENQFLAGS,HAVE
         DEQ   ,MF=(E,(R5))            DEQ VICE
*
         NI    ENQFLAGS,SMCSTEPC       NO 'RESET MUST CMPLT'     Y01965
         MVC   ENQRNAM8,ENQNAME        SET RNAME FOR VOLUME INDEX
         DEQ   ,MF=(E,(R5))            DEQ VOLUME INDEX
*
         MVI   ENQFLAGS,RESERVE+HAVE   TURN ON RESERVE         @ZA04613
         MVC   ENQRNAM8,HILVLNAM       SET RNAME FOR HIGH LEVEL
*
*      DEQUE NAME AND RELEASE ('UN-RESERVE') THE DEVICE
*
         DEQ   ,MF=(E,(R5))            DEQ NAME
*
*
DCBDEB   EQU   *
*
*     FREE THE MAIN STORAGE FOR THE DCB/DEB AREA
*
         TM    FLAG1,FREEDCB           DCB/DEB ALREADY FREED?
         BO    RPSTST                  BRANCH IF YES; CHECK FOR RPS WA
*
*      GET DCB/DEB ADDRESS FREE
         L     R1,DCBADDR
*      IF CLC3 HAS GOTTEN CONTROL DCBADDR IS NO LONGER VALID
         TM    MODMAP1,MODCLC3         HAS CLC3 GOTTEN CONTROL?
         BZ    SKIP5                   BRANCH IF NO
         L     R1,IOBDCB               GET DCB ADDRESS FROM IOB
*
SKIP5    EQU   *
*
*      IF R1=0 THEN THE DCB/DEB GETMAIN HAS NOT BEEN ISSUED YET
*
         LTR   R1,R1                   0?
         BZ    FREEWA                  BRANCH IF YES
*      FREE THE DCB/DEB AND CLOSE THE CATALOG
         USING DCBAREA,R1
         L     R0,NMBYTES              GET LENGTH
         LA    R1,DCBAREA              GET ADDRESS             @YL026UD
         XC    SVOPNWAP(4),SVOPNWAP    RESET WKA PTR (ESTAE)   @YL026UD
         SVC   FREEMAIN                FREEMAIN   R,LV=(0),A=(1)
         DROP  R1
*
*
RPSTST   EQU   *
*
         TM    FLAG2,RPSDEV            RPS WA?
         BZ    FREEWA                  BRANCH IF NO
*
*      FREE RPS WORKAREA
*
         LA    R0,RPSEND-RPSD          GET LENGTH
         L     R1,RPSAVEP              GET ADDRESS OF THE AREA
         XC    SVRPSWAP(4),SVRPSWAP    RESET WKA PTR (ESTAE)   @YL026UD
         SVC   FREEMAIN                FREEMAIN   R,LV=(0),A=(1)
*
*
FREEWA   EQU   *
*
*      FREE WORKAREA
*
*      INITIALLY ASSUME NON-LOCATE FUNCTION
*
         L     R12,CWAP                RESTORE CONTROLLER WA PTR Y01113
         LA    R0,WORKEND-WORKAREA     GET LENGTH OF AREA TO FREE
         LR    R1,R6                   GET POINTER TO AREA TO FREE
*
         TM    FLAG1,LOCATEF           * LOCATE?
         BZ    FREEWA2                 BRANCH IF NO
*
         TM    FLAG1,RTNBLK            RETURN BLK TO USER?
         BZ    SKIP6                   BRANCH IF NO
*
         USING BLDLAREA,R13            ESTABL ADDRBLTY TO 'BLDLAREA'
         MVC   RETDATA,BLDLBUFF        RETURN BLK
         DROP  R13
*
*
SKIP6    EQU   *
*
         LR    R1,R13                  GET POINTER TO AREA TO FREE
         LA    R0,BLDLEND-BLDLAREA     GET LENGTH TO FREEMAIN  @YL026UD
*
FREEWA2  EQU   *
*
         SVC   FREEMAIN                FREEMAIN R,LV=(0),A=(1)
*
*      RETURN TO INTERFACE MAPPER (IGG0CLCA OR IGG0CLCB)       @YL026UD
*                                                              @YL026UD
         ESTAE 0                       RESET ESTAE EXIT        @YL026UD
*                                                              @YL026UD
*      PUT RETURN CODES INTO PROPER REGISTERS AND EXIT         @YL026UD
*                                                              @YL026UD
         LR    R0,R10                  NUMBER OF LEVELS FOUND  @YL026UD
         LR    R1,R11                  INDIC RETURN & CODE     @YL026UD
         ICM   R1,8,HEX8               INDCATE CVOL VS VSAMCAT @OZ32432
         LR    R15,R7                  SET RETURN CODE         @YL026UD
*                                                              @YL026UD
         L     R13,612(R12)            GET CIII SAVEAREA PTR   @YL026UD
         LM    R2,R12,28(R13)          RESTORE REGISTERS 2-12  @YL026UD
         L     R14,12(R13)             RESTORE RETURN REGISTER @YL026UD
         BR    R14                     RETURN TO IGG0CLCA/CLCB @YL026UD
         EJECT
*
****************
*              *
READ     EQU   *
*              *
****************
*
         BAL   BALREG2,TOABSL1         GO TO CONVERT
         MVC   OPTNCCW,RD              MOVE IN READ DATA CCW
         BAL   BALREG1,IO2             ***READ DATA***
         MVI   OPTNCCW,WDOP            MOVE IN WRITE DATA OP-CODE
         BR    BALREG4                 RETURN
*
         EJECT
*
****************
*              *
WRITE    EQU   *
*              *
****************
*
         BAL   BALREG1,IO2             ***WRITE DATA***
*
*      VERIFY THE WRITE OPERATION
*
         MVC   OPTNCCW,RKD             MOVE IN CCW--NO TRANSFER
         BAL   BALREG1,IO2             ***READ KEY & DATA***
         BR    BALREG4                 RETURN
*
         EJECT
*
****************
*              *
TOABSL1  EQU   *
*              *
****************
*
* FUNCTION:
*    CONVERT THE TTR0 IN R0 TO AN ABSOLUTE DASD ADDRESS AND
*    PUT IT INTO THE IOB MBBCCHHR
*
* INPUT:
*    R0 IS THE TTR0 TO BE CONVERTED
*    RETURN ADDRESS IN BALREG2
*
* OUTPUT:
*    ABSOLUTE DASD ADDRESS IN IOB
*    ERROR CODE IN R15
*
* DESTROYED:
*    REGISTERS - R0,R1,R2,R14, AND R15=0
*    WA - SAVEAREA AND MBBCCHHR OF THE IOB
*
* SUBROUTINES USED:
*         THE RESIDENT CONVERT ROUTINE - IECPCNVT
*
*
****************
****************
*
         L     R15,EPTOABSL            GET CONVERT ADDRESS FROM WA
         B     CONVERT1                USE COMMON CODE
         EJECT
*
****************
*              *
TORLTV1  EQU   *
*              *
****************
*
* FUNCTION:
*    MOVE THE DASD ADDRESS OF CCHHR FROM NXTCNT INTO THE CCHHR OF THE
*    IOB.  THIS GIVES THE TTR OF THE NEXT FREE BLOCK.
*
* INPUT:
*    RETURN IN BALREG2
*    UPDATED NXTCNT
*
* OUTPUT:
*    TTR0 IN R0
*
* DESTROYED:
*    REGISTERS -- R0,R1,R2,R14, AND R15=0
*    WA -- SAVEAREA AND CCHHR OF IOB
*
* SUBROUTINES USED:
*         THE RESIDENT CONVERT ROUTINE -- IECPRLTV
*
*
****************
****************
*
         MVC   IOBSKADD+3(L'NXTCCHHR),NXTCCHHR    MOVE COUNT FIELD
*
         L     R15,EPTORLTV            GET ADDRESS OF ROUTINE FROM WA
*
*
CONVERT1 EQU   *
*
*      THE FOLLOWING SECTION IS COMMON TO BOTH ROUTINES
*
         STM   R9,R13,SAVEAREA         SAVE REGS DESTROYED BY CONVERT
         L     R1,DEBADDR              GET DEB ADDRESS
         LA    R2,IOBSKADD             POINT TO MBBCCHHR
         BALR  BALREG1,R15             GO TO CONVERT ROUTINE
         LM    R9,R13,SAVEAREA         RESTORE REGISTERS
         BR    BALREG2                 RETURN TO CALLER
         EJECT
*
***
****************
*              *
IO2      EQU   *
*              *
****************
*
* FUNCTION:
*    1.  IF THE DEVICE HAS THE RPS FEATURE, THE SET SECTOR CCW IS
*        UPDATED.
*    2.  ISSUE EXCP FOR THE CHANNEL PROGRAM POINTED TO BY THE IOB.
*    3.  WAIT FOR THE OPERATION TO COMPLETE AND CHECK THE ECB.
*    4.  IF AN END OF EXTENT CONDITION, BRANCH TO IGC0002H     @YL026UD
*        AND EXTEND THE CATALOG.                               @YL026UD
*    5.  IF A PERMANENT I/O ERROR, SET AN ERROR CODE AND BRANCH TO
*        ERREXIT.
*
* INPUT:
*    UPDATED CHANNEL PROGRAM
*    RETURN ADDRESS IN BALREG 1
*
* OUTPUT:
*    1.  FILLED BUFFER OR
*    2.  EMPTIED BUFFER OR
*    3.  ANOTHER FREE BLOCK ADDRESS
*
* DESTROYED:
*    REGISTERS R0,R1,R15 (IF EXTENDS)
*
* EXTERNAL ROUTINES USED:
*    EXCP, WAIT, IGC0002H TO EXTEND CATALOG                    @YL026UD
*
* EXITS:
*         IGC0002H TO EXTEND THE CATALOG                       @YL026UD
*         IGG0CLC7 FOR PERMANENT I/O ERROR
****************
****************
*
         USING RPSD,R1
*
         TM    FLAG2,RPSDEV            RPS FEATURE?
         BZ    EXCP2                   BRANCH IF NO
         L     R1,RPSAVEP              GET RPS SAVE AREA PTR
         STM   R9,R2,RPSAVE            SAVE REGS DESTROYED BY CONVERT
         LM    R15,R2,RPSINPUT         GET SECTOR CONVERT INPUT PARAMS
         IC    R0,IOBSKADD+7           GET R OF CCHHR
         BALR  R14,R15                 CONVERT R TO SECTOR
         LM    R9,R2,RPSAVE            RESTORE REGISTERS
*
*
EXCP2    EQU   *
*
         EXCP  IOB                     ISSUE EXCP
         WAIT  ECB=ECB                 WAIT FOR REQUEST
         CLI   ECB,X7F                 I/O ERROR?
         BCR   8,BALREG1               BRANCH IF NO
         NC    ERRCODE,ERRCODE         PROCESSING ER?
         BNZ   EXITCODE                BRANCH IF YES--IGNORE ERROR
         CLI   ECB,X'42'               OUT OF EXTENT?
         BE    EXTEND2                 BRANCH IF YES AND EXTEND
         MVI   ERRCATSV,ERROR28        SET ERROR CODE TO I/O ERROR
         B     ERREXIT                 EXIT
*
EXTEND2  EQU   *
*
*      EXTEND CATALOG
*
         ST    BALREG1,SVBALREG        SAVE CURRENT BALREG1    @YL026UD
         L     R0,IOBDCB               GET DCB PTR
         L     R15,IGC0002H                                    @OZ00006
         BALR  BALREG1,R15             GO TO NEXT EXTENT       @OZ00006
*
         L     BALREG1,SVBALREG        RESTORE SAVED BALREG1   @YL026UD
         LTR   R1,R15                  CHECK RETURN CODE
         BZ    EXCP2                   RE-ISSUE REQUEST IF OK
*                                                               SA52094
*      UNABLE TO EXTEND CATALOG, BUT THIS REQUEST HAS           SA52094
*      COMPLETED NORMALLY SO EXIT                               SA52094
*                                                               SA52094
         B     EXITCODE                EXIT                     SA52094
*
         DROP  R1
         TITLE 'IGG0CLCE - CONSTANT DEFINITIONS'               @YL026UD
*
* CONSTANTS                                                    @YL026UD
*
         USING EREC,R9                                         @YL026UD
         DS    0F
ERCCWR   EQU   *
         DC    X'0E'                   READ KEY AND DATA
         DC    AL3(ERKEY-EREC)         POINT TO BUFFER
         DC    X'2000'                 SLI
         DC    H'12'                   READ 12 BYTES
         DS    0F
ERCCWW   EQU   *
         DC    X'05'                   WRITE DATA
         DC    AL3(0)                  BUFFER PTR SET DURING EXECUTION
TTRVFST  DS    0XL3                    TTR OF THE FIRST BLOCK OF VI
         DC    X'0000'                 ALL FLAGS OFF
         DC    H'256'                  BYTES WRITTEN
*
ONEREC   DC    F'256'                  UP TTR0 BY ONE
MOVE1    MVC   0(0,OUT),0(IN)
MSG      DC    AL2(MSGLEN+44),X'8000'                          @OZ14802
         DC    C'IEC302I SYSCTLG I/O ERROR,VVVVVV,'            @OZ00006
MSGLEN   EQU   *-MSG                   LENGTH OF MSG SKELETON  @OZ00006
DESCRTE  DC    X'10004040'             SYSTEM STATUS,SYSTEM    @OZ00006
*                                      ERROR/MAINTENANCE,      @OZ00006
*                                      MASTER CONSOLE INFOR-   @OZ00006
*                                      MATIONAL                @OZ00006
         DS    0H                                              @OZ00006
MOVENAM2 MVC   7(0,1),0(R14)   OBJECT OF EXECUTE      @ZA02274 @ZA05908
MOVENAME MVC   ERNAME(0),0(R14)
MSG2     DC    AL2(MSG2LEN+44),X'8000'                         @OZ14802
         DC    C'IEC304I SYSCTLG ENTRY SEQUENCE ERROR,X''TTTTRR'',VVVVV*
               V,'                      SEQUENCE ERROR MESSAGE @OZ12193
MSG2LEN  EQU   *-MSG2                                           ZA02665
MSG3     DC    AL2(MSG3LEN+44),X'8000'                         @OZ14802
         DC    C'IEC305I INVALID ENTRY IN SYSCTLG,VVVVVV,'     @ZA05908
MSG3LEN  EQU   *-MSG3                                          @ZA05908
         DROP  R9                                               YL026UD
*
HICCHHNT DC    X'7FFF7FFF7FFF'    HIGH CCHH COUNT.
IGC0002H  DC    V(IGC0002H)                                    @OZ00006
EXTMAXCC DC    F'2'               MAXIMUM EXTEND RETURN CODE   @YL026UD
CONTABL  DC    CL16'0123456789ABCDEF'     TRANSLATE TABLE      @OZ12193
MASK     DC    X'0F0F0F0F0F0F00'          HEX TO EBCDC MASK    @OZ12193
HEX8     DC    X'08'                      ONE BYTE CONSTANT 08 @OZ32432
         TITLE 'IGG0CLCE - CHANNEL COMMAND WORD DEFINITIONS'
*
* PATTERN CHANNEL COMMAND WORDS.
*
CCW1     CCW   X'31',M2B2C2HR+3-AREADCB,X'40',5 SEARCH EQUAL ID@YL026UD
CCW2     CCW   X'08',CHPG-AREADCB,0,1          TIC TO CCW1     @YL026UD
CCW3     CCW   X'06',IECSDSF4-AREADCB,X'60',48 READ VTOC DSCB. @YL026UD
CCW4     CCW   X'D1',DS4HPCHR-AREADCB,X'40',5  SEARCH HI ID.   @YL026UD
CCW5     CCW   X'08',CHPG+48-AREADCB,0,1       TIC TO CCW7.    @YL026UD
CCW6     CCW   X'03',0,0,1                   CONTROL NOP.
CCW7     CCW   X'29',DS1DSNAM-AREADCB,X'60',44 SEARCH KEY EQUAL@YL026UD
CCW8     CCW   X'08',CHPG+24-AREADCB,0,1       TIC TO CCW4.    @YL026UD
CCW9     CCW   X'06',DS1FMTID-AREADCB,X'40',96 RD SYSCTLG DSCB @YL026UD
CCW10    CCW   X'12',COUNT-AREADCB,0,8         READ COUNT.     @YL026UD
CCWRDKD  CCW   X'0E',DSCBK-AREADCB,0,140       READ KEY & DATA @YL026UD
*
CCWSID   CCW   X'31',MBBCCHHR+3-WKAREA,X'40',5 SEARCH ID
         DC    X'0800000000000000'     TIC
CCWWR    CCW   X'1D',COUNT2-CHPGA2,X'60',8 WRITE CKD, SLI
CCWRCH   CCW   X'1E',0,X'50',272       READ CKD, SKIP
READVTOC CCW   X'29',D1SDSNAM-WKAREA,X'60',44 SEARCH KEY EQUAL
         CCW   X'08',CHPGA-WKAREA,0,1    TIC
         CCW   X'06',D1SFMTID-WKAREA,0,96 READ DATA
WRVTOC   CCW   X'05',D1SFMTID-WKAREA,X'40',96 WRITE DATA
         CCW   X'29',D1SDSNAM-WKAREA,X'60',44 SEARCH KEY EQUAL
         CCW   X'08',CHPGA4-WKAREA,0,1 TIC
         CCW   X'06',0,X'10',96        CHECK DATA
CCWRD    CCW   X'06',BLOCK-WKAREA,X'00',256 READ DATA           SA50973
CCWWDOP  EQU   X'05'                   WRITE DATA OP CODE       SA50973
CCWOPTN1 EQU   X'30'                   NO TRANSFER, SILI        SA50973
CCWOPTN2 EQU   X'40'                   COMMAND CHAIN            SA50973
*                                                              @YL026UD
*                                                              @YL026UD
*      MODULE PATCH AREA (MAINTENANCE AREA)                    @YL026UD
*                                                              @YL026UD
         DS    0H
FIXAREA  DC    100C'Z'                                         @YL026UD
*                                                              @YL026UD
         TITLE 'IGG0CLCE - CONSTANT EQUATE DEFINITIONS'
*
*      CONSTANT EQUATES
*
VICETYP  EQU   5                       VICE TYPE CODE
ICETYP   EQU   3                       ICE TYPE CODE
ILETYP   EQU   0                       ILE TYPE CODE
IPETYP   EQU   0                       IPE TYPE CODE
DSPETYP  EQU   7                       OR MORE, FOR DSPE TYPE CODE
VCBPETYP EQU   1                       VCBPE TYPE CODE
OCVOLTYP EQU   3                       OLD CVOL TYPE CODE
NCVOLTYP EQU   5                       NEW CVOL TYPE CODE
ALIASTYP EQU   4                       ALIAS TYPE CODE
GIPETYP  EQU   2                       GIPE TYPE CODE
ERROR00  EQU   0
ERROR04  EQU   4
ERROR08  EQU   8
ERROR12  EQU   12
ERROR16  EQU   16
ERROR20  EQU   20
ERROR24  EQU   24
ERROR28  EQU   28
ERROR32  EQU   32
ERROR72  EQU   72
***********************************************************************
*      CHARACTER CODE DEPENDENT CONSTANTS
***********************************************************************
CCDBLANK EQU   C' '
CCDRPARN EQU   C')'
CCDMINUS EQU   C'-'
CCDPLUS  EQU   C'+'
CCD0     EQU   C'0'
CCDG     EQU   C'G'
CCDV     EQU   C'V'
CCDPERD  EQU   C'.'
CCDLPARN EQU   C'('
***********************************************************************
*
* MISCELLANEOUS EQUATES USED .
*
ONE      EQU   1                       A ONE CONSTANT.
TWO      EQU   2                       A TWO CONSTANT.
THREE    EQU   3                       A THREE CONSTANT.
FOUR     EQU   4                       A FOUR CONSTANT.
EIGHT    EQU   8                       AN EIGHT CONSTANT.
TEN      EQU   10                      A TEN CONSTANT.
TWELVE   EQU   12                      A TWELVE CONSTANT.
NINTY    EQU   90                      DSCB MOVE LENGTH.
B12      EQU   12                      BINARY 12
B14      EQU   14                      BINARY 14
B15      EQU   15                      BINARY 15.
B22      EQU   22                      BINARY 22
B24      EQU   24                      BINARY 24
B26      EQU   26                      BINARY 26
B36      EQU   36                      BINARY 36
B40      EQU   40                      BINARY 40 EQUATE.
B100     EQU   100                     BINARY 100
B105     EQU   105                     BINARY 105
B184     EQU   184                     BINARY 184
B253     EQU   253                     SUBPOOL 253 CONSTANT.
RPSIDLOC EQU   62                      OFFSET TO RPS ID          XM2100
X00      EQU   X'00'                   HEX 00
X01      EQU   X'01'                   HEX 01
X0D      EQU   X'0D'                   HEX 0D
X0E      EQU   X'0E'                   HEX 0E
X10      EQU   X'10'                   HEX 10
X12      EQU   X'12'                   HEX 12
X14      EQU   X'14'                   HEX 14
X18      EQU   X'18'                   HEX 18
X20      EQU   X'20'                   HEX 20
X42      EQU   X'42'                   HEX 42
X7F      EQU   X'7F'                   HEX 7F
X81      EQU   X'81'                   HEX 81
XBF      EQU   X'BF'                   HEX BF
XFF      EQU   X'FF'                   HEX FF
X100     EQU   X'100'                  HEX 100
X105     EQU   X'105'                  HEX 105
X0100    EQU   X'0100'                 HEX 0100
DEBAD    EQU   44                      DEB POINTER IN DCB
WASZ     EQU   128                     SIZE OF RPS WORK AREA.
AVTSV    EQU   120                     DISP TO AVT PTR IN RPSWA.
DEBAPDS  EQU   28                      APPNDG. PTR DISP. IN DEB.
FMWAL    EQU   512                     FORMAT WORKAREA LENGTH.
*
CODPERD  EQU   4
CODBLANK EQU   8
CODPARN  EQU   12
CLC1     EQU   C'1'
CLC2     EQU   C'2'
CLC3     EQU   C'3'
CLC4     EQU   C'4'
CLC5     EQU   C'5'
CLC6     EQU   C'6'
CLC7     EQU   C'7'
FREEMAIN EQU   10
*
CC       EQU   X'40'                   COMMAND CHAIN
SLACK    EQU   32                      MAXIMUM NUMBER OF UNUSED BYTES
*                                      ALLOWED IN A CATALOG INDEX BLOCK
SILI     EQU   X'20'                   SUPPRESS INCORRECT LENGTH
*
D01      EQU   1
D12      EQU   12
D16      EQU   16
         TITLE 'IGG0CLCE - REGISTER EQUATE DEFINITIONS'
*
* THE FOLLOWING ARE REGISTER EQUATES USED IN THIS PROGRAM.
*
R0       EQU   0                       REGISTER 0
R1       EQU   1                       REGISTER 1
R2       EQU   2                       REGISTER 2
R3       EQU   3                       REGISTER 3
R4       EQU   4                       REGISTER 4
R5       EQU   5                       REGISTER 5
R6       EQU   6                       REGISTER 6
R7       EQU   7                       REGISTER 7
R8       EQU   8                       REGISTER 8
R9       EQU   9                       REGISTER 9
R10      EQU   10                      REGISTER 10
R11      EQU   11                      REGISTER 11
R12      EQU   12                      REGISTER 12
R13      EQU   13                      REGISTER 13
R14      EQU   14                      REGISTER 14
R15      EQU   15                      REGISTER 15
RGA      EQU   2                       REGISTER 2
RGB      EQU   3                       REGISTER 3
RGC      EQU   4                       REGISTER 4
RGD      EQU   5                       REGISTER 5
RGE      EQU   6                       REGISTER 6
RGF      EQU   7                       REGISTER 7
RGG      EQU   8                       REGISTER 8
RGH      EQU   9                       REGISTER 9
RGBASE   EQU   4                       BASE REGISTER           @YL026UD
RGDQTY   EQU   10                      DIRECTORY QUANTITY
RGTTR    EQU   11                      RELATIVE TRACK COUNTER
RGAREA   EQU   13                      WORK AREA ADDRESS
RGRET    EQU   14                      RETURN REGISTER
*
BALREG1  EQU   R14
BALREG2  EQU   R12
BASE     EQU   R4
*
BALREG3  EQU   R11
BALREG4  EQU   R3
*
IN       EQU   R9
OUT      EQU   R7
LENGTH   EQU   R5
NEXTTTR  EQU   R10
*
RFKEY    EQU   0                  INPUT FUNCTION REQUEST KEY.
RPARM    EQU   1                  INPUT PARAMETER REGISTER.
RBASE    EQU   4                  BASE REGISTER.               @YL026UD
RCWA     EQU   6                  CATALOG WORK AREA BASE.
RGAREA2  EQU   8                  SECONDARY DCB BASE REGISTER.
RGAREA3  EQU   9                  TERTIARY DCB BASE REGISTER.
RFKEYA   EQU   10                 POSSIBLE TTR KEY FROM EXTEND.
RUCB     EQU   11                 UCB BASE REGISTER.
RBR      EQU   15                 RETURN CODE REGISTER.
*
         SPACE
*
**********************************************************************
*
* END OF THE IGG0CLCE CSECT.
*
FMTSIZE  EQU   *                       EQUATE TO LAST BYTE OF CSECT.
MAXSIZE  EQU   IGG0CLCE+X'1000'        MAXIMUM ALLOWABLE LENGTH.
AVAILABL EQU   MAXSIZE-FMTSIZE         FREE SPACE REMAINING.
*
**********************************************************************
*
         TITLE 'IGG0CLCE - CATALOG WORKAREA DSECT'
*
*      DSECTS
*
         WORKAREA LIST=YES
         TITLE 'IGG0CLCE - ENVIRONMENT RECORD DSECT'
EREC     DSECT                         ENVIRONMENT RECORD
ERCTR    DS    F                       RESERVED
ERES1    DS    1F                      RESERVED
ERTIME   DS    2F                      TIME AND DATE
ERCAMLST DS    1F                      CAMLST OPTION BYTES
ERMODMAP DS    XL1                     MODULE MAP
ERFLG12  DS    XL2                     FLAG1 AND FLAG2
ERFLAG3  DS    XL1                     FLAG3
ERERRCOD DS    XL2                     CATALOG AND LOCATE ERROR CODES
ERNAMTTR DS    XL14                    CURRENT LEVEL NAME
EREGSAV  DS    15F                     REGS 1 THROUGH 14
ERWA1    DS    XL28                    TTRS IN WORKAREA
         ORG   ERWA1                   OVERLAY 12 BYTES 'ERWA1' SA52063
ERKEY    DS    CL8                     KEY FIELD                SA52063
EROCTR   DS    CL4                     OLD COUNT                SA52063
         ORG
ERINPUT  DS    XL18                    FIRST 18 BYTES OF 'INPUT'
EROUTPUT DS    XL18                    FIRST 18 BYTES OF 'OUTPUT'
EROPTNCC DS    XL8                     'OPTNCCW'--INDICATES LAST I/O
ERIOB    DS    XL40                    IOB
ERNAME   DS    CL44                    FULL GIVEN NAME
ERBUFF   EQU   ERWA1                   READ BUFFER
         TITLE 'IGG0CLCE - FORMAT WORKAREA DSECT'
*
* THIS DSECT DEFINES THE WORK AREA PASSED TO THE FORMAT ROUTINE.
*
         SPACE
WKAREA   DSECT
FSVAREA  DS    0F                      REG SAVE AREA.
SVBLKS   DS    F                       NUMBER OF BLOCKS FOR DIRECTORY
SVDCB    DS    F                       DCB ADDRESS
SVBLPTK  DS    F                       NUMBER OF BLOCKS PER TRACK
SVBYTES  DS    F                       NUMBER OF BYTES IN WORK AREA
SVADDR   DS    F                       ADDRESS OF WORK AREA
SVCNT    DS    F                       DATA MANAGEMENT COUNT
SVTT     DS    F                       STARTING RELATIVE TRACK ADDRESS
CHPGA    DS    0D                      WRITE CHANNEL PROGRAM
CHPGA1   DS    D                       CCW 1.
CHPGA2   DS    D                       CCW 2.
CHPGA3   DS    D                       CCW 3.
CHPGA4   DS    D                       CCW 4.
CHPGA5   DS    D                       CCW 5.
CHPGA6   DS    D                       CCW 6.
CHPGA7   DS    D                       CCW 7.
CHPGA8   DS    D                       CCW 8.
CHPGA9   DS    D                       CCW 9.
CHPGA10  DS    D                       CCW 10.
CHPGA11  DS    D                       CCW 11.
CHPGA12  DS    D                       CCW 12.
CHPGA13  DS    D                       CCW 13.
CHPGA14  DS    D                       CCW 14.
CHPGA15  DS    D                       CCW 15.
CHPGA16  DS    D                       CCW 16.
CHPGA17  DS    D                       CCW 17.
CHPGB    DS    0D                      READ CHANNEL PROGRAM
CHPGB1   DS    D                       CCW 1.
CHPGB2   DS    D                       CCW 2.
CHPGB3   DS    D                       CCW 3.
CHPGB4   DS    D                       CCW 4.
CHPGB5   DS    D                       CCW 5.
CHPGB6   DS    D                       CCW 6.
CHPGB7   DS    D                       CCW 7.
CHPGB8   DS    D                       CCW 8.
CHPGB9   DS    D                       CCW 9.
CHPGB10  DS    D                       CCW 10.
CHPGB11  DS    D                       CCW 11.
CHPGB12  DS    D                       CCW 12.
CHPGB13  DS    D                       CCW 13.
CHPGB14  DS    D                       CCW 14.
CHPGB15  DS    D                       CCW 15.
CHPGB16  DS    D                       CCW 16.
CHPGB17  DS    D                       CCW 17.
         EJECT
         ORG   CHPGA6                  OVERLAY CHPGA AND B      SA50973
BLOCK    DS    0CL256                  BUFFER                   SA50973
         DS    XL2                     FILLER, 'BYTES USED'     SA50973
         DS    XL12                    FILLER, FRST PART 'VICE' SA50973
UPLSTBLK DS    XL2                     FRST 2 BYTES 'VCLSTBLK'  SA50973
         ORG
COUNT2   DS    0D                      DIRECTORY CONTROL BLOCK
CTKEY    DS    CL8                     KEY OF DIR BLOCK.
CTCOUNT  DS    CL2                     COUNT OF DIRECTORY BLOCK.
CTDIR    DS    CL7                     FILLER.
CTLBK    DS    CL1                     LOW ORDER OF NAME.
         DS    CL2                     FILLER.
CTTTRC   DS    CL2                     TTRC
CTHITT   DS    CL2                     HI TT.
CTHIR    DS    CL1                     HI R.
         DS    CL3                     FILLER.
CTNABTR  DS    CL1                     NEXT AVAILABLE BLOCK TTR.
         DS    CL2                     FILLER.
CTNBLB   DS    CL1                     BYTES IN LAST BLOCK.
CTHIENT  DS    CL8                     HI ENTRY.
         DS    CL72                    FILLER.
HICOUNT  DS    D                       LAST RELATIVE TRACK
FECB     DS    F                       EVENT CONTROL BLOCK
FIOB     DS    8F                      INPUT OUTPUT BLOCK
MBBCCHHR DS    CL8                     SEEK ADDRESS
BPAMDIR  DS    0X                      BDAM DIRECTORY
BPDCNT   DS    CL8                     BPAM DIR COUNT.
BPDHIK   DS    CL9                     BPAM DIR HI KEY.
BPDBPB   DS    CL1                     BPAM DIR BYTES PER BLOCK.
BPDHIE   DS    CL8                     BPAM DIR HI ENTRY.
         ORG   COUNT2-148              ORG EXTEND SAVE AREA.
EXTSAVE  DS    CL8                     FIRST EXTENT OF DEB
*
*      FORMAT 1 DSCB
*
D1SDSNAM DS    CL44                    DATA SET NAME
D1SFMTID DS    CL1                     FORMAT IDENTIFIER
D1SDSSN  DS    CL6                     DATA SET SERIAL NUMBER
D1SVOLSQ DS    XL2                     VOLUME SEQUENCE NUMBER
D1SCREDT DS    XL3                     CREATION DATE
D1SEXPDT DS    XL3                     EXPIRATION DATE
D1SNOEPV DS    XL1                     NUMBER OF EXTENTS ON VOLUME
D1SNOBDB DS    XL1                     NUMBER OF BYTES USED IN LAST
*                                         DIRECTORY BLOCK
         DS    XL1                     RESERVED
D1SSYSCD DS    CL13                    SYSTEM CODE
         DS    XL7                     RESERVED
D1SDSORG DS    XL2                     DATA SET ORGANIZATION
D1SRECFM DS    XL1                     RECORD FORMAT
D1SOPTCD DS    XL1                     OPTION CODE
D1SBLKL  DS    XL2                     BLOCK LENGTH
D1SLRECL DS    XL2                     RECORD LENGTH
D1SKEYL  DS    XL1                     KEY LENGTH
D1SRKP   DS    XL2                     RELATIVE KEY POSITION
D1SDSIND DS    XL1                     DATA SET INDICATORS
D1SSCALO DS    XL4                     SECONDARY ALLOCATION
D1SLSTAR DS    XL3                     LAST USED TRACK AND BLOCK
D1STRBAL DS    XL2                     BYTES REMAINING ON LAST TRACK
         DS    XL2                     RESERVED
D1SEXT1  DS    XL10                    FIRST EXTENT DESCRIPTION
*        FIRST BYTE                    EXTENT TYPE INDICATOR
*        SECOND BYTE                   EXTENT SEQUENCE NUMBER
*        THIRD - SIXTH BYTES           LOWER LIMIT
*        SEVENTH - TENTH BYTES         UPPER LIMIT
D1SEXT2  DS    XL10                    SECOND EXTENT DESCRIPTION
D1SEXT3  DS    XL10                    THIRD EXTENT DESCRIPTION
D1SPTRDS DS    XL5                     POSSIBLE POINTER TO A FORMAT
*                                         2 OR 3 DSCB
D1SEND   EQU   *
         TITLE 'IGG0CLCE - COMMUNICATION VECTOR TABLE DSECT'
*
*COMMUNICATION VECTOR TABLE DEFINITION
*
         TITLE 'IGG0CLCE - DCB/DEB AREA DSECT'
*
* THIS DSECT DESCRIBES THE DCB/DEB AREA.
*
AREADCB  DSECT
         DS    6F                 DCB AREA FILLER.
DAREA    DS    0F                 WORK AREA REFERENCE.
NUMBYTES DS    F                  NUMBER OF BYTES.
DSCBTRK  DS    F                  CC HH OF SYSCTLG DSCB.
CATWKAP  DS    1F                 CATALOG WORKAREA ADDRESS     @YL026UD
BLDLP    DS    1F                 BLDL    WORKAREA ADDRESS     @YL026UD
DEB      DS    0F                 START OF THE DEB.
DEBTCBAD DS    F                  TCB ADDRESS.
DEBAMIND DS    0X                 AM INDICATOR.
DEBDEBAD DS    F                  NEXT DEB ADDRESS.
         DS    2F                 IRB AND SYS PURGE CHAIN.
DEBNMEXT DS    0X                 NO OF EXTENTS.
         DS    2F                 USER PURGE AND PURGE ECB ADDR.
DEBDCBAD DS    F                  DCB ADDRESS.
DEBAPPAD DS    F                  APPENDAGE VECTOR TABLE ADDRESS.
DEBDVMOD DS    0X                 DEBICE MODIFIER MASK.
DEBUCBAD DS    F                  UCB ADDRESS.
DEBBINUM DS    H                  BIN NUMBER.
DEBSTRCH DS    0CL8               START/END CCHH.
DEBSTRCC DS    H                  START CYLINDER.
DEBSTRHH DS    H                  START HEAD.
DEBENDCC DS    H                  END CYLINDER.
DEBENDHH DS    H                  END HEAD.
DEBNMTRK DS    H                  NUMBER OF TRACKS.
EXTL     EQU   16                 LENGTH OF AN EXTENT ENTRY.
MAXEL    EQU   256                MAXIMUM EXTENT AREA LENGTH.
DEBEND   EQU   *
DEBL     EQU   DEBEND-DEB         DEB LENGTH.
         EJECT
*
* FORMAT 4 DSCB DEFINITION.
*
         SPACE
         IECSDSL1 (4)
         ORG   IECSDSF4+48        ORG TO CCW AREA.
CHPG     DS    2D                 CHANNEL PROGRAM RELOCATE AREA.
CHPGAA   DS    2D                 CHANNEL PROGRAM RELOCATE AREA.
CHPGBB   DS    2D                 CHANNEL PROGRAM RELOCATE AREA
CHPGCC   DS    2D                 CHANNEL PROGRAM RELOCATE AREA
CHPGDD   DS    2D                 CHANNEL PROGRAM RELOCATE AREA
AECB     DS    F                  EVENT CONTROL BLOCK.
AIOB     DS    8F                 I/O CONTROL BLOCK.
M2B2C2HR DS    CL8                SEEK ADDRESS IN THE IOB.
CCHHR    EQU   M2B2C2HR+3         CHANNEL-HEAD ADDRESS.
CCHHRL   EQU   5                  LENGTH OF CCHHR.
DSCBK    DS    CL44               DATA SET NAME AREA.
DSCBK4   EQU   DSCBK+4            FOUR BYTES OFF DSCBK
DSCBD    EQU   DSCBK+44           FOURTY FOUR BYTES OFF DSCBK
*
* FORMAT 1 DSCB DEFINITION.
*
         SPACE
         ORG   DSCBK              ORG COUNT AREA.
         IECSDSL1 (1)
COUNT    DS    CL8                SYSCTLG DSCB DISK ADDR/
COUNTA   EQU   COUNT+4
*                                 WORKAREA FOR CONVERT ROUTINE.
REGSAVE  DS    1F                 REGISTER SAVE AREA
REGS2    DS    1F                 REGISTER SAVE AREA.
REGS3    DS    1F                 REGISTER SAVE AREA
REGS4    DS    1F                 REGISTER SAVE AREA.
REGS5    DS    1F                 REGISTER SAVE AREA.
REGS6    DS    1F                 REGISTER SAVE AREA.
NUMUCB   DS    H                  NUMBER OF UCB'S.
SWL      EQU   6                  LENGTH OF SWITCH AREA.
FMTSW    DS    X                  COUNT OF BLOCK TRACK.
EXTDSW   DS    X                  EXTEND COUNTER.
EXTDTT   DS    F                  RELATIVE TRACK ADDRESS.
AREAEND2 DS    0D                 USED TO DETERMINE NUMBER BYTES.
EXTDRGSV DS    2F                 REGISTER SAVE AREA.
*
* EXTEND WORK AREA DEFINITION.
*
         ORG   DAREA              ORG TO EXTEND AREA.
EXTDAREA DS    0F
         IECDSECT
         TITLE 'IGG0CLCE - UNIT CONTROL BLOCK DSECT'
*
* THIS IS THE UCB DEFINITION DSECT.
*
         SPACE
UCB      DSECT
         IEFUCBOB
         END   IGG0CLCE
