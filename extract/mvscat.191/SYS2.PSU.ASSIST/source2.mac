         TITLE '*** ASSIST - MAIN CONTROL - OVERALL ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: ASSIST     MONITOR CONTROL PROGRAM FOR THE ASSIST SYSTEM  *
*        ENTRY CONDITIONS                                             *
*   R1= @ POINTER TO OS LENGTH/PARM FIELD AREA.                       *
*        CALLS AOBJIN,AODECK,APARMS,EXECUT,MPCON0,REENDA,REINTA       *
*        CALLS XXXXFINI,XXXXINIT                                      *
*        USES DSECTS: AJOBCON,AVWXTABL,ECONTROL                       *
*        USES MACROS: $DBG,$PRNT,$RETURN,$SAVE,$SORC,$TIRC            *
*        USES MACROS: ASPAGE,ASPRNT,ASRECL,ASTIME,ASTIMR              *
*        USES MACROS: FREEMAIN,GETMAIN,STIMER,TTIMER,XCALL,XSNAP,WTL  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASSIST   CSECT
* * * * * * * * REGISTER USAGE IN ASSIST MAIN PROGRAM * * * * * * * * *
*   R0,R1,R15  USUALLY LOCAL WORK REGISTERS. PARAMETER REGS FOR SOME. *
*   R9 = INTERNAL LINK REGISTER FOR TIME/RECORDS/PAGES CONTROL .      *
*   R10= ADDRESS OF EXECUTION CONTROL BLOCK ECONTROL (PART OF TIME).  *
*   R11= ADDRESS OF JOB CONTROL TABLE AJOBCON(ALWAYS).                *
*   R12= ADDRESS OF ASSEMBLER CONTROL TABLE AVWXTABL(PART OF TIME).   *
*   R13= SAVE AREA PTR AND BASE REGISTER ALSO.                        *
*   R14= EXTERNAL LINK REGISTER.  INTERNAL LINK REGISTER FOR LOWEST   *
*              LEVEL INTERNAL SUBROUTINES.                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         $DBG  ,NO                 NO DEBUG,SINCE NO AVWXTABL
         AIF   (&$ASMLVL).ASXSAVE  SKIP FOR OS $SAVE
         BALR  R15,0               SET UP TEMPORARY ADDRESSABILITY(DOS)
         USING *,R15               INFORM ASSEMBLER OF R15 USING
         CNOP  0,4                 FULLWORD ALIGNMENT FOR FUTURE SAVE
         BAL   R13,ASSAVE+72       BR AROUND SAVE,SET R13 = @ SAVEAREA
         USING *,R13               SHOW R13 AS ASSIST BASE REGISTER
         DROP  R15                 KILL USING
ASSAVE   DC    18F'0'              SAVEAREA FOR CSECT ASSIST
.ASXSAVE AIF   (NOT &$ASMLVL).ASNXSAV  SKIP IF UNDER DOS GENERATION
         $SAVE RGS=(R14-R12),BR=R13,SA=ASSAVE
.ASNXSAV ANOP
         MVC   ASPARMSV,0(R1)      MOVE @ LENGTH/PARM FIELD OVER
         ASTIMR 00,2               INITIALIZE TIMER IF &$TIMER=2
         XCALL XXXXSPIN            INITIALIZE PROGRAM INTERRUPT CODE
         LA    R11,ASJOBCON        GET @ FOR AJOBCON
         USING AJOBCON,R11         NOTE MAIN TABLE USING
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INITIALIZE AJOBCON.  CALL XXXXINIT TO INITIALIZE       *
*        INPUT/OUTPUT PROCESSORS.  (I.E. DO OPENS, SET FLAGS.  )      *
*        MAKE SURE BOTH LINE PRINTER (PR) AND SOURCE CARD READER (SO) *
*        OPENED SUCCESSFULLY.  QUIT IMMEDIATELY IF THEY DIDN'T.       *
*        CALL APARMS TO ANALYZE PARM FIELD IF ANY,SET FLAGS IN AJOBCON*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASJINIT  EQU   *                   SECTION TO INIT AJOBCON
         XC    AJOZER1(AJOZER$L),AJOZER1    ZERO OUT WHOLE SECTION
         SPACE 1
ASJOBINT EQU   *                    ENTRY FOR BEGINNING OF NEW $JOB
*              CALL PARM FIELD ANALYSIS ROUTINE TO SET FLAGS.         *
ASJPARMS EQU   *
*              ***** LIMIT PARMS & RESETABLE DEFAULTS *****
         LA    R9,ASPARLIM         SHOW @ PARM FIELD
         LA    R10,ASPARL$L        SHOW LENGTH OF PARM FIELD
         MVI   AJOAPMOD,AJOAPRSE   SHOW THIS IS RESET CALL
         MVI   AJOAPSET,APCSETLD   SHOW LIMIT/DEFAULT CALL TYPE
         XCALL APARMS              CALL PARM FIELD SCANNER
         AIF   (NOT &$ASMLVL).ASPARMC  NO // EXEC PARM FIELD
         SPACE 1
*              ***** REAL PARM FIELD ANALYSIS *****
         L     R9,ASPARMSV         GET PTR TO LENGTH-PARM FOR APARMS
         LH    R10,0(R9)           GET LENGTH OF THE REAL PARM
         LA    R9,2(R9)            GET @ ACTUAL PARM FIELD
         MVI   AJOAPMOD,AJOAPMOV   SHOW PARM SHOULD BE MOVED OVER
         MVI   AJOAPSET,APCSETP    SHOW THIS IS THE REAL PARM FIELD NOW
         XCALL APARMS              CALL SCANNER PROGRAM
.ASPARMC ANOP
         SPACE 1
         TM    AJOSTEP,AJOMSINT    HAVE GONE THRU 1-TIME INIT ALREADY
         BO    ASNOT1T             YES, SO DON'T DO IT AGAIN.
         SPACE 1
*              ***** ONE-TIME-PER-BATCH INITIALIZATION *****
         BAL   R14,ASMSINIT        MAIN STORAGE INITIALIZATION
         TM    AJOMODE,AJNSYSIN    WAS NOSYSIN SPECIFIED
         BO    ASZERR2             NOSYSIN, SO QUIT NOW. NO SOURCE CRDS
         SPACE 1
*              HAVE DCB'S OPEND FOR PRINTER, SOURCE RDR. CHECK FOR OK.
         XCALL XXXXINIT            CALL I/O INITIALIZER
         TM    AJIOPR,AJIOPEN      DID PRINTER OPEN RIGHT
         BZ    ASZERR1             NO,GO DO MESSAGE AND QUIT
         TM    AJIOSO,AJIOPEN      DID SOURCE CARD RDR OPEN RIGHT
         BZ    ASZERR2             NO, BRANCH AND QUIT IMMEDIATELY
ASNOT1T  EQU   *                   ENTER FOR EVERY-TIME PROCESSING
         TM    AJOMODE,AJOBATCH    WAS THIS BATCH RUN
         BZ    ASPARFIN            NO, SKIP TO PUT IN FINAL DEFAULTS
         AIF   (NOT &$DATARD).ASNRDX   SKIP IF NO DATA RDR EXISTS
         OI    AJIORE,AJIODFLT     SINCE BATCH, MAKE SURE  NO DATA RDR
.ASNRDX  ANOP
         SPACE 1
*              ***** BATCH MODE - GET $JOB CARD AND ITS PARMS *****
         AIF   (NOT &$MACSLB).ASSNOMC
         XCALL XXXXLBED         MAKE SURE THAT XXXXSORC GETS CARD RIGHT
.ASSNOMC ANOP
         MVI   AJOBTRQ,AJO$J       SHOW THAT $JOB CARD IS DESIRED     J
         BAL   R14,ASFLUSH         GO GET IT; RETURN ONLY IF FOUND    J
*              ***** $JOB CARD OR EQUIV FOUND. PROCESS PARM.
         MVI   AJOAPMOD,AJOAPMOV   SHOW PARM SHOULD BE MOVED OVER
         MVI   AJOAPSET,APCSETU    SHOW USER SETTING THIS TIME
         LA    R9,AJOJCLPM         SHOW @ PARM FIELD ON $JOB CARD
         LA    R10,80-(AJOJCLPM-AJOJCLCD)   LENGTH OF PARM FIELD(MAX)
         XCALL APARMS              CALL PARM ANALYSIS ROUTINE
         MVC   AJOPARM(80),AJOJCLCD         MOVE WHOLE JCL CARD IN INST
         SPACE 1
*              ***** DEFAULT PARM FIELDS - DON'T OVERRRIDE SET *****
ASPARFIN EQU   *                   SKIP HERE IF NOBATCH
         MVI   AJOAPMOD,AJOAPDEF+AJOAPFIN   DEFAULT CALL, ALSO LAST 1
         MVI   AJOAPSET,APCSETLD   SHOW LIMIT/DEFAULT TYPE SETTING
         LA    R9,ASPARDF          SHOW DEFAULT PARMS
         LA    R10,ASPARD$L        SHOW LENGTH OF DEFAULT PARM LIST
         XCALL APARMS              MAKE FINAL CALL TO PARM ROUTINE
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              TIME,RECORDS,PAGES INITIALIZATION FOR ASSEMBLY.        *
*              PRINT ASSIST HEADER + 1 PARM FIELD.                    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         ASRECL 04                 CALL RECORD INIT CODE
         ASPAGE 04                 CALL PAGE HANDLING, IF EXISTS
         ASTIMR  04,1              SET UP TIME/INST COUNT LIMITS
         SPACE 1
*              PRINT HEADER.  PRINT REAL PARM OR $JOB PARM AREA
ASPRHEAD EQU   *                   ENTRY FOR MULTIPLE ASSEMBLYS/EXEC
         ASPRNT ASH1HD,ASH1H$L     PRINT BEGINNING HEADER
         ASPRNT AJOPARMA,AJOP$L+1  PRINT THE PARM FIELD
         AIF   (&$DEBUG).ASDA      SKIP IF PRODUCTION
         XSNAP LABEL='AFTER TIME/RECORDS SET',IF=(AJODEBUG,O,8,TM),    X
               STORAGE=(*AJOPARMA,*AJOBCON+AJOB$L)
.ASDA    ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SET UP ADDRESSES FOR CALL TO THE ASSIST ASSEMBLER.     *
*        ALSO SET UP TIME,SO CAN DO TIMING FOR THE ASSEMBLER          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASASMCL  EQU   *                   SECTION TO CALL ASSEMBLER
         MVC   AJOTADL(8),AJOPADL  REINITIALIZE TEMP TO PERMANENTS
         SPACE 1
ASASMCLR EQU   *                   ENTRY LABEL FOR REPLACE PHAS B
         L     RAT,AJOVWXPT        INIT ADCON FOR ASSEMBLER TABLE
         USING AVWXTABL,RAT        NOTR POINTER IN R12
         ST    R11,AVAJOBPT        INIT POINTER TO AJOBCON.
         MVC   AVADDLOW(8),AJOTADL MOVE CURRENT CORE LIMITS OVER
         MVC   AVNERR(AJOAVL),AJONERR       GIVE FLAGS TO ASSEMBLER
         AIF   (NOT &$OBJIN).ASNOBJ1        SKIP IF NO OBJECT DECK IN
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              OBJECT DECK INPUT CODE                                 *
*        IF PARM=OBJIN, CALL AOBJIN TO LOAD DECK, SKIPPING EXECUTION  *
*        IF THERE IS NOT ENOUGH ROOM FOR IT.  AOBJIN SETS UP VALUES   *
*        IN AVWXTABL JUST AS THOUGH THERE HAD BEEN AN ASSEMBLY.       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TM    AJODECKF,AJOOBJIN   WAS THERE OBJECT DECK,INSTD OF SOURC
         BZ    ASOBJINN            NO, NO OBJECT DECK-SKIP TO ASSEMBLE
         AIF   (&$REPL EQ 0).ASNRPX    SKIP IF NO REPLACEMENT
         TM    AJOMODE,AJOREPLF    REPLACE RUN
         BO    ASOBJINN            YES, SO DON'T LET HIM READ DECK IN
.ASNRPX  ANOP
         XCALL AOBJIN              CALL OBJECT INPUT ROUTINE
         TM    AVTAGS1,AJNLOAD     NOLOAD SET IF SOMETHING WRONG
         BO    ASNOEXEC            BAD DECK - SKIP EXECUTION
         B     ASOBJINX            OK, SKIP OVER ASSEMBLY AND CONTINUE
ASOBJINN EQU   *                   SKIP HERE IF NO OBJECT INPUT
.ASNOBJ1 ANOP
         AIF   (&$REPL EQ 0).ASNREP1        SKIP IF NO REPLACEMENT
*              IF REPLACEMENT POSSIBLE, CALL REINTA TO SET FLAGS,ADCONS
         XCALL REINTA              CALL REPLACE PRE-ASSEMBLY INIT
.ASNREP1 SPACE 1
         SPACE 1
*              FLAG ASSEMBLY, CALL ASSEMBLER, UNFLAG ASSEMBLY.
         OI    AJOSTEP,AJOSASM     SHOW WE'RE IN ASSEMBLER NOW
         XCALL MPCON0              CALL THE ASSEMBLER
         NI    AJOSTEP,255-AJOSASM SHOW WE FINISHED ASSEMBLER
         SPACE 1
         ASTIMR 12,1               CALL FOR ASSEMBLY TIME,RATE PRINTING
         SPACE 1
         AIF   (&$REPL EQ 0).ASNREP2        SKIP IF NO REPLACEMENT
*              IF REPLACEMENT POSSIBLE, CALL REENDA TO CHANGE ADCONS
         XCALL REENDA              POST-ASSEMBLY PROCESSOR
.ASNREP2 SPACE 1
         TM    AVTAGS1,AJNLOAD     WAS NO LOAD FLAG SET
         BO    ASNOEXEC            EITHER USER DIDN'T WANT, OR ERRS
ASOBJINX EQU   *                   EXIT HERE IF OBJECT INPUT
         AIF   (NOT &$DECK).ASNDECK         SKIP IF NO DECKS PUNCHED
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              OBJECT DECK PUNCH CODE                                 *
*        IF PARM=DECK, PUNCH THE CURRENT USER PROGRAM OUT, AS LONG    *
*        AS IT WASN'T ONE JUST READ IN FOR PARM=OBJIN.                *
*        ALSO, DON'T PUNCH IF IN REPLACE RUN.                         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TM    AJOASMF2,AJODECK    DID USER WANT AN OBJECT DECK
         BZ    ASDECKN             NO, SKIP
         TM    AJODECKF,AJOOBJIN   DID HE JUST READ IT IN
         BO    ASDECKN             YES, IDIOT USER-DON'T PUNCH IT
         AIF   (&$REPL EQ 0).ASNREDK        SKIP IF NO REPLACEMENT
         TM    AJOMODE,AJOREPLF    ARE WE IN REPLACE RUN
         BO    ASDECKN             YES, DON'T ALLOW DECK PUNCHED
.ASNREDK ANOP
         XCALL AODECK              CALL TO PUNCH OBJECT DECK
ASDECKN  EQU   *                   SKIP LABEL OVER OBJECT DECK PUNCH
.ASNDECK ANOP
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PRE-EXECUTION CONTROL CARD CHECKING                    *
*        IF IN BATCH MODE, FLUSH CARDS UNTIL A $ENTRY CARD FOUND,     *
*        AND POSSIBLY ALLOW EXECUTION, OR A $JOB CARD FOUND, IN       *
*        WHICH CASE GO BACK FOR NEXT JOB.  $STOP CARD FOUND WILL NOT  *
*        RETURN HERE ANYWAY.    NOTE THAT EXECUTION IN BATCH MODE     *
*        CURRENTLY REQUIRES A $ENTRY CARD.                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AJOMODE,AJOBATCH    ARE WE IN MIDDLE OF BATCH RUN
         BZ    ASEXNBAT            NO, NO BATCH, DON'T READ ANY CARDS
         SPACE 1
         AIF   ('&$BTCC(3)' EQ '').ASBTCC1  SKIP IF NO $ENTRY NEEDED  J
         MVI   AJOBTRQ,AJO$E       SHOW THAT $ENTRY IS WHAT WE WANT   J
         BAL   R14,ASFLUSH         GO GET; IF RETURN, IT EXISTS       J
         CLI   AJOBTYP,AJO$E       WAS IT ACTUALLY $ENTRY             J
         BE    ASEXNBAT            YES, CONTINUE                      J
         OI    AJIOSO,AJIOSORR     $JOB- SET FOR REREAD, FINISH JOB   J
         B     ASNOEXEC            GO TO END THIS JOB, PICK UP $JOB   J
.ASBTCC1 ANOP
ASEXNBAT EQU   *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PREPARE ADDRESSES AND ECONTROL BLOCK FOR EXECUTION     *
*        OF USER PROGRAM BY EXECUT.  SET UP ECONTROL APPROPRIATELY.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASEXECAL EQU   *
         LM    R0,R5,AVRADL        GET THE 6 @ WORDS FROM AVWXTABL
         LA    R10,AVECONTR        OVERLAP ECONTROL&UNNEEDED AV SECT
         DROP  RAT                 REMOVE USING FOR TIME BEING
         AIF   (&$REPL EQ 0).ASNRP1E        SKIP IF NO REPLACE
         SPACE 1
*              IF IN REPLACE MODE A, THE ECONTROL BLOCK CANNOT BE
*              LOCATED IN MIDDLE OF AVWXTABL, SO ALLOCATE SPACE FOR
*              IT AT HIGH END OF DYNAMIC AREA INSTEAD.
         TM    AJOMODE,AJOREPLF+AJOREPHB    ARE WE IN REPL, OR PHASE B
         BNM   ASREPLBM            BRANCH-NOT PHASE A IN ANY CASE
         SPACE 1
         L     R10,AJOTADH         GET CURRENT HIGH POINTER
         SH    R10,=AL2(EC$LEN)    SPACE FOR ECONTROL
         ST    R10,AJOTADH         SAVE BACK, ALSO LEAVE IN R10
ASREPLBM EQU   *                   BRANCH HERE IF NOT REPL PHASE A
.ASNRP1E SPACE 1
         USING ECONTROL,R10        NOTE EXECUTION TIME USING
         XC    ECZER1(ECZER$L),ECZER1       ZERO OUT AREA IN ECONTROL
         LR    R1,R5               MOVE HIGHEST FAKE @ OVER
         SR    R1,R4               GET LENGTH OF PROGRAM
         AR    R1,R0               GET UPPER @ LIMIT FOR PROGRAM
         LR    R6,R1               SAVE ENDING @ OF PROGRAM
         LA    R1,72+256(R1)       INCREMENT ENDING @,SAVAR+BUFFER
         C     R1,AJOTADH          IS THERE ENOUGH ROOM FOR SAVA,BUFFR
         BH    ASEXOVSP            NO,BRANCH OUT, ABORT EXECUTION
         SPACE 1
         MVI   0(R6),$PRGFILC      PUT IN FILL CORE CHARACTER
         MVC   1(71,R6),0(R6)      PROPAGATE FILL THRU 1ST SAVE AREA
         MVC   72(256,R6),64(R6)   FILL DUMMY 256 BYTES ALSO
         XC    4(4,R6),4(R6)       ZERO INITIAL BACKWARDS SA PTR (HSA)
         STM   R0,R5,ECRADL        SAVE ALL THE @ POINTERS IN ECONTROL
         STM   R0,R1,ECRDLIML      STORE ECRADL-ECRADH==> ECRDLIML-H
         SPACE 1
         ST    R1,AJOTADL          STORE BACK UPDATED LOWER LIMIT
         ST    R6,ECSAVE1          SAVE @ DUMMY SAVE AREA,FOR DUMPS
         SPACE 1
         S     R6,ECRELOC          SUBTRACT THE RELOCATION FACTOR
         L     R7,=F'-100000'      SET UP FOR WEIRD RETURN @
         LR    R8,R3               MOVE TO STORE IN FAKE R15- EPA
         STM   R6,R8,ECREG13       STORE FAKE R13-R14-R15 INTO FAKE RGS
         MVI   ECREGS,$PRGFILR     PUT FILL REGISTER CHAR INTO 1ST BYTE
         MVC   ECREGS+1(51),ECREGS PROPAGATE 4'S THROUGH REGS 0-12
         MVC   ECFPREGS(32),ECREGS PUT 4'S IN FP REGS ALSO
         MVC   ECILIMP,AJOINSL     MOVE INSTRUCTION LIMIT OVER
         MVC   ECAJ(ECAJL),AJOEC   MOVE EXECUTION FLAGS OVER
         MVI   ECSYSMSK,X'FF'      SET CHANNEL MASKS TO INTERRUPT CEH
         MVI   ECKYAMWP,X'C5'      SET KEY-C, AMWP=0101           CEH
         SPACE 1
         OI    ECFLAG0,$ECSPIEB    NOTE WE WANT SPIE REMOVED AT END
*              IF 'RELOC' OPTION USED, ALLOW STORE-ONLY PROTECT
         AIF   (NOT &$RELOC).ASNRELC        SKIP IF NO RELOC MODE AVAIL
         TM    AJOASMF,AJORELOC    DID USER ASK FOR RELOC MODE
         BO    *+8                 YES, SKIP, DON'T SET FETCH PROTECT
.ASNRELC ANOP
         OI    ECFLAG0,$ECPROT     SHOW BOTH FETCH/STORE PROTECT
         SPACE 1
         XCALL XXXXSNIN            HAVE XXXXSNAP INIT CALL #
         ST    R10,AJOECOPT        SAVE @ ECONTROL, IN CASE TIMER
         AIF   (&$DEBUG).ASXS1     SKIP XSNAP IF NOT DEBUG MODE
         XSNAP LABEL='ECONTROL BEFORE EXECUT',IF=(AJODEBUG,O,2,TM),    #
               STORAGE=(*ECONTROL,*ECONTROL+EC$LEN)
         LM    R14,R15,ECRADL      GET STORAGE LIMITS
         XSNAP T=(NO,,1),LABEL='USER STORAGE BEFORE EXEC(FAKE ADDR)',  #
               STORAGE=(*0(R14),*0(R15)),IF=(AJODEBUG,O,4,TM)
.ASXS1   ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        EXECUTION CONTROL BLOCK PREPARATION COMPLETED.  MAKE SURE    *
*        THAT TIME OR RECORDS LIMITS HAVE NOT BEEN OVERRUN ALREADY.   *
*        IF NOT, THEN PRINT HEADER, SET TIMER, AND EXECUTE PROGRAM.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AJOMODE,AJOSOVRT+AJOSRECX    HAS ANY OVERRUN OCCURRED
         BNZ   ASNOEXEC            SKIP IF OVERRUN ALREADY. DON'T EXEC
         AIF   (&$REPL EQ 0).ASNREP3        SKIP IF NO REPLACEMENT
         TM    AJOMODE,AJOREPLF+AJOREPHB     TEST REPLACE STATUS
         BNM   ASREPLBZ            BR-EITHER NO REPLACE(Z) OR PHS B(O)
         OI    AJOMODE,AJOREPHB    WAS IN PHASE A, SET NOW TO B
         MVC   ECRFLAG,AJORFLAG    INITIALIZE THE FLAG VALUE
         ASPAGE 14                 GET PAGE CONTROL SET
         ASRECL 14                 GET RECORDS SET (LIKE EXEC)
         ASTIMR 14,1               SET TIMER, AS FOR NORMAL EXEC.
         B     ASASMCLR            RETURN TO RUN A REPLACED CSECT
ASREPLBZ EQU   *                   EXIT LABEL- NO REPLACE, PHASE B
.ASNREP3 SPACE 2
         ASPRNT ASHEXGO,L'ASHEXGO  PRINT PRE-EXECUTION HEADING
         SPACE 1
         ASPAGE 16                 SET PAGE LIMITS FOR EXECUTION
         ASRECL 16                 SET UP RECORD LIMITS FOR EXECUTION
         SPACE 1
*              FLAG EXECUTION, CALL EXECUT, UNFLAG EXECUTION.
         OI    AJOSTEP,AJOSEXEC    FLAG TO SHOW WE'RE IN INTERPRETER
         ASTIMR 16,1               SET TIMER, AFTER SHOWN IN EXEC PHASE
         XCALL EXECUT              CALL THE INTERPRETER
         NI    AJOSTEP,255-AJOSEXEC         SHOW FINISHED EXECUTION
         SPACE 1                                                      J
*              POST-EXECUTION PHASE - USE ALL DUMP LIMITS IN ORDER TO J
*              PREVENT UNNECESSARY LOSS OF MESSAGES.                  J
         OI    AJOSTEP,AJOSDUMP    SHOW NOW IN DUMP STEP              J
         ASRECL 20                 RECORD LIMIT; CLEAR AJOSRECX FLAG  J
         ASPAGE 20                 PAGE LIMIT, IF USED                J
         ASTIMR 18,0               PRINT INSTRUCTION COUNT/RATE
         ASTIMR 20,1               RESET TIMER FOR DUMP PROCESSING    J
*              IF 1 OR MORE DATA CARDS WAS NOT READ DURING EXECUTION, J
*              READ IT AND PRINT WITH MESSAGE TO THAT EFFECT.         J
         AIF   (NOT &$DATARD).ASNDRZZ  SKIP IF NO DATA RDR            J
         TM    AJIORE,AJIOPEN+AJIODFLT  WAS RDR OPEN, OR DEFAULT USED J
         BNZ   ASCARDRR            YES, SAFE TO DO $READ NOW          J
         MVC   AJOPARM(80+L'ASCARDMS),AJOBLANK   BLANK OUT WHOLE AREA J
         MVC   AJOPARM+L'ASCARDMS(27),=C'NO CARDS READ:FILE UNOPENED' J
         B     ASCARDMM
.ASNDRZZ ANOP
ASCARDRR $READ AJOPARM+L'ASCARDMS,80,ASNOMORC    READ, SKIP IF EOF    J
ASCARDMM MVC   AJOPARM(L'ASCARDMS),ASCARDMS  COPY MESSAGE OVER        J
         ASPRNT AJOPARMA,81+L'ASCARDMS  PRINT THE ASSEMBLED LINE      J
*              NOTE: ABOVE MESSAGE MAY OVERLAP INTO AJODWORK.  BUT OK.J
ASNOMORC EQU   *                   COME HERE IF NO CARDS UNREAD       J
         SPACE 2
*              DETERMINE WHETHER PROGRAM ENDED WITH A NORMAL RETURN OR*
*        AN ERROR. PRINT NORMAL MESSAGE IF IT WAS FLAGGED AS NORMAL.  *
         CLI   ECFLAG1,$ECBRN14    WAS RETURN NORMAL
         BNE   ASDUMPCL            NO, SO CALL DUMP ROUTINE
         ASPRNT ASNORMAL,L'ASNORMAL    PRINT NORMAL COMPLETION BY RET
         B     ASNOEXEC
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              USER PROGRAM DUMP PHASE                                *
*        SET UP CORRECT LIMITS FOR DUMP, THEN MAKE SPECIAL XSNAP      *
*        CALL WHICH PRODUCES THE FINAL DUMP, USING APPROPRIATE LIMITS.*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASDUMPCL EQU   *
         LM    R14,R15,ECRDLIML    ECRDLIML-ECRDLIMH - DUMP LIMITS
         XSNAP T=(PR,FL,10),STORAGE=(*0(R14),*0(R15))      FINAL DUMP
         B     ASNOEXEC            GO TO MAKE BATCH CHECK
         EJECT
*              ASEXOVSP - ENTERED IF STORAGE OVERFLOW.                *
ASEXOVSP ASPRNT ASEMSG,L'ASEMSG    PRINT STORAGE OVERFLOW MESSAGE
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MAIN END-OF-$JOB EXIT - ASNOEXEC                       *
*        IF TIME AND RECORDS OVERRUN OCCURRED, PRINT MESSAGE.         *
*        THEN TEST FOR BATCH RUN, IF SO REUTURN FOR NEXT $JOB CARD.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              ASNOEXEC - PRINT OVERRUN MESSAGE IF ONE HAS OCCURRED.  *
ASNOEXEC EQU   *
         TM    AJOMODE,AJOSRECX+AJOSOVRT    TEST FOR OVERRUN
         BZ    ASTSTBAT            NO OVERRUN, TEST FOR BATCH
         NI    AJOMODE,255-AJOSRECX    IF SPURIOUS ON, REMOVE SO FLAG
         MVI   AJORECNT+3,1        ALLOW ONE PRINT LINE FOR AM005 CEH
         ASPRNT ASRTOVR,L'ASRTOVR  OVERFLOW- NOTE OCCURRENCE
         SPACE 1
*              ASTSTBAT - TEST FOR BATCH RUN, CONTINUE IF SO.         *
ASTSTBAT EQU   *
         AIF   (&$XXIOS).ASFIN     SKIP IF NO EXTENDED I/O            J
         XCALL XXDDFINI            CALL TO CLOSE EVERYTHING UP        J
.ASFIN   ANOP
         TM    AJOMODE,AJOBATCH    WAS RUN A BATCH ONE
         BZ    ASFINIS             NO, SO WE'RE DONE. QUIT NOW
         SPACE 1
*              FOR BATCH RUN, MAKE SURE MODE/STEP BITS RESET RIGHT.
         NI    AJOMODE,255-(AJOREPLF+AJOSRECX+AJOSOVRT+AJOREPHB)
         NI    AJOSTEP,255-(AJOSASM+AJOSEXEC+AJOSDUMP)     RESET PHASE
         B     ASJPARMS            GO BACK, SEARCH FOR NEXT $JOB
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASFLUSH    FLUSH CARD RDR UNTIL NEXT COMMAND CARD         *
*        FLUSH UNTIL ASSIST JCL CARD FOUND, PLACING SUCH CARD INTO    *
*        AJOJCLCD (XXXXSORC DOES IT AUTOMATICALLY WHEN FOUND).        *
*        IF END-FILE FOUND, TERMINATE RUN.  NOTE $STOP == EOF.        *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS TO CALLING CODE.                              *
*        EXIT CONDITIONS                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASFLUSH  $SORC AJOJCLCD,80,ASFINIS IF END-FILE, ALL DONE-QUIT         J
         MVI   AJOBTRQ,AJO$D       SET TO BE DATA AGAIN               J
         BR    R14                 RETURN TO CALLER                   J
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTIMR##   TIMING SERVICES IN ASSIST MAIN PROGRAM.        *
*        THIS SECTION CONSISTS OF A NUMBER OF ENTRIES CALLED FROM     *
*        POINTS IN THE ASSIST MAIN PROGRAM, USING THE MACRO ASTIMR    *
*        AND A TWO-DIGIT CODE AS ONE OPERAND.  EACH ENTRY PERFORMS A  *
*        SPECIFIC TIMING FUNCTION. AS OF 10/20/70, NO ENTRY IS CALLED *
*        FROM MORE THAN ONE POINT IN ASSIST, SO ACTUALLY, THE CODE FOR*
*        EACH ONE COULD BE INSERTED INLINE, SAVING SOME SPACE.  THE   *
*        SECTIONS ARE GROUPED THIS WAY FOR EASE OF MODIFICATION, AND  *
*        EASE OF GENERATION, SINCE NOT ALL ENTRIES EXIST FOR ALL      *
*        GENERATION OPTIONS (CONTROLLED BY &$TIMER).  THE ASTIMR MACRO*
*        GENERATES CALLS ONLY TO THE EXISTING SECTIONS.               *
*        ENTRY CONDITIONS (FOR ALL ASTIMR## ENTRIES)                  *
*   R9 = RETURN @ TO CALLING SECTION IN ASSIST.                       *
*        EXIT CONDITIONS                                              *
*   R0,R1,R14,R15  MAY BE DESTROYED.                                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$TIMER LT 2).AST00A        SKIP IF NO $TIRC USABLE
*              ASTIMR00 - &$TIMER=2 - INITIALIZE OVERALL TIMER        *
ASTIMR00 EQU   *
         $TIRC TIMREM              GET REMAINING TIME, TIMER UNITS
         ST    R0,ASTBEGIN         SAVE THIS INITIAL TIME
         BR    R9                  RETURN TO CALLER
         SPACE 1
.AST00A  AIF   (&$TIMER GT 0).AST04A        SKIP IF ANY TIMER AT ALL
         SPACE 1
*              ASTIMR18 - &$TIMER=0 - PRINT INSTRUCTION COUNT.        *
ASTIMR18 EQU   *
         LM    R0,R1,ECILIMT       GET ECILIMT-ECILIMP FOR COMPUTE
         SR    R1,R0               GET DIFFERENCE = # EXECUTED
         CVD   R1,AJODWORK         CONVERT # EXECUTED
         MVC   ASHEXP2,ASPATB      MOVE EDIT PATTERN OVER
         ED    ASHEXP2,AJODWORK+8-ASPBL/2   EDIT # INSTRS DONE
         SPACE 1
         ASPRNT ASHEX,ASHEXL       PRINT EXECUTION MESSAGE
         BR    R9                  RETURN TO CALLER
         SPACE 1
         AGO   .AST24A             SKIP OVER REST OF CODE
.AST04A  AIF   (&$TIMER GT 1).AST04B        SKIP IF NOT =1
*              ASTIMR04 - &$TIMER=1 - FIND TIME FOR STIMER SETTING.   *
ASTIMR04 EQU   *
         L     R0,AJOTIML          LOAD TOTAL TIME LIMIT INTO PARM REG
         BAL   R14,ASTIMSET        GO SET TIMER TO VALUE IN R0(TU)
         BR    R9                  RETURN TO CALLER
         SPACE 1
         AGO   .AST08A             SKIP OVER CODE
.AST04B  ANOP
*              ASTIMR04 - &$TIMER=2 - GET TIME LEFT FOR STIMER        *
ASTIMR04 EQU   *
         L     R0,AJOTIML          TOTAL TIME LIMIT (TIMER UNITS)
         TM    AJOAPMOD,AJOAPUST   DID USER ACTUALLY SUPPLY T= VALUE
         BO    AST04A              YES, SO LEAVE IT ALONE-OK
*              USER DID NO SUPPLY T=, USE TIMREM TO GET ACTUAL LEFT.
         $TIRC TIMREM              GET ACTUAL TIME REMAINING
         SH    R0,=AL2(5000/26)    5 MILLISEC FUDGE FACTOR FOR SAFETY
AST04A   BAL   R14,ASTIMSET        GO SET TIMER TO DESIRED VALUE
         BR    R9                  RETURN TO CALLER
.AST08A  SPACE 2
         SPACE 1
*              ASTIMR12 - &$TIMER=1,2 - PRINT ASSEMBLY STATISTICS.    *
*        ENTRY CONDITIONS                                             *
*   R12(RAT) = @ AVWXTABL DUMMY SECTION                               *
ASTIMR12 EQU   *
         USING AVWXTABL,RAT        NOTE THE POINTER
         LH    R7,AVSTMTNO         GET # STATEMENTS FOR ASTIMER
         DROP  RAT                 ERASE THE USING
         ASTIME ASHASM,*           CALL TIMER TO PRINT MSG
         BR    R9                  RETURN TO CALLER
         SPACE 1
*              ASTIMR14 - SET UP FOR REPLACEMENT PHASE B EXEC.        *
ASTIMR14 EQU   *                   (SAME AS -16, I.E., EXECUTION)
*              ASTIMR16 - &$TIMER=1,2 - SET TIMER FOR EXECUTION TIMING*
ASTIMR16 EQU   *
         L     R0,AJOTIMR          GET CURRETN TIME REMAINING FOR T=
         L     R1,AJOTX            GET DESIRED TX= LIMIT
         LA    R15,AJOTD           ADDRESS OF TIME TO BE SAVED FOR DUMP
         BAL   R14,ASTRP16         CALL ROUTINE TO CALCULATE TIME
         BAL   R14,ASTIMSET        CALL STIMER CODE
         BR    R9                  RETURN TO CALLING SECTION OF CODE
         SPACE 1
*              ASTIMR18 - &$TIMER=1,2  CALC,PRINT EXEC TIME,RATE      *
ASTIMR18 EQU   *
         LM    R6,R7,ECILIMT       GET ECILIMT/ECLIMP FROM ECONTROL
         SR    R7,R6               GET # INSTRUCTIONS ACTUALLY DONE
         CVD   R7,AJODWORK         CONVERT # INSTRS DONE
         MVC   ASHEXP2,ASPATB      MOVE EDIT PATTERN OVER
         ED    ASHEXP2,AJODWORK+8-ASPBL/2   EDIT # INSTRUCTIONS DONE
         ASTIME ASHEX,*            GO TO DO TIMING
         BR    R9                  RETURN TO CALLING SECTION
         SPACE 1
*              ASTIMR20 - &$TIMER=1,2. SET UP FOR DUMP
ASTIMR20 EQU   *
         L     R0,AJOTIMR          GET CURRENT TIMER SETTING
         A     R0,AJOTD            ADD IN TIME FOR DUMP
         BAL   R14,ASTIMSET        CALL STIMER ROUTINE
         BR    R9                  RETURN TO CALLER
         SPACE 1
         AIF   (&$TIMER LT 2).AST24A        SKIP IF NO ENDING TIME
*              ASTIMR24 - &$TIMER=2 - COMPUTE,PRINT TOTAL ASSIST TIME *
ASTIMR24 EQU   *
         $TIRC TIMREM              GET TIME REMAINING INTO R0
         L     R1,ASTBEGIN         PLACE BEGINNING TIME FOR ASTIMER
         LA    R2,ASHEND           SHOW @ OF MESSAGE
         LA    R3,ASHENDP          SHOW @ NUMBER AREA
         LA    R4,ASHENDL          SHOW LENGTH OF MESSAGE
         SR    R6,R6               SHOW NO RATE (2ND PART OF MESSAGE)
         BAL   R14,ASTIMERE        ENTER MIDDLE SECTION OF TIME PRINTER
         BR    R9                  RETURN TO CALLER
.AST24A  ANOP
         EJECT
         AIF   (&$TIMER LT 1).AST60A        SKIP CODE IF UNNEEDED
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTIMSET   SET INTERVAL TIMER ROUTINE                     *
*        CALLED BY ASTIMR## SECTIONS TO SET TIMER FOR GIVEN INTERVAL. *
*        **NOTE** THIS IS ONLY USE OF IBM STIMER MACRO IN ASSIST.     *
*        ALSO, UNDER DOS, ONLY USE OF STXIT MACRO.                    *
*        ENTRY CONDITIONS                                             *
*   R0 = VALUE OF TIMER INTERVAL TO BE SET (TIMER UNITS = 26.04 MICS) *
*   R14= RETURN ADDRESS TO CALLING SECTION IN ASTIMR##                *
*        EXIT CONDITIONS                                              *
*   R0,R1,R15  MAY BE MODIFIED.                                       *
*   AJOMODE IS SET TO SHOW NO TIME OVERRRUNS EXIST AT MOMENT.         *
*        USES MACROS:  STIMER(OS) ; STXIT,SETIME, GETIME(DOS)         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASTIMSET EQU   *
         ST    R0,AJOTIMR          STORE VALUE AS CURRENT LAST TIMER
         NI    AJOMODE,255-AJOSOVRT         MAKE SURE FLAG SET OFF
         AIF   (&$ASMLVL).ASTDOST  SKIP OVER DOS TIMING OPTIONS
         LR    R1,R0               GET VALUE OF TIMER INTERVAL IN R1
         M     R0,AJ2604           MULT BY MICROSEC/TU
         D     R0,AJ100M           CONVERT TO SEC IN R1
         SETIME  (R1)              SET INTERVAL TIMER
         GETIME  TU                R1 <= TIME OF DAY IN TIMER UNITS
         A     R1,AJOTIML          R1 <= TIME OF DAY FOR TIMER INTERRPT
         ST    R1,ASTMRMDS         SAVE TIME FOR TIMREM OPTION
         STXIT IT,ASTEXIT,ASTSAVAD ALLOW TIMER INTERRUPTION
.ASTDOST AIF   (NOT &$ASMLVL).ASTOSTM  SKIP OS STIMER
         STIMER TASK,ASTEXIT,TUINTVL=AJOTIMR
.ASTOSTM ANOP
         BR    R14                 RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTIMER    UPDATE TIMER,PRINT ELAPSED TIME,MESSAGE        *
*        **NOTE** THIS IS ONLY USE OF IBM TTIMER MACRO IN ASSIST.     *
*        ENTRY CONDITIONS                                             *
*   R2 = @ MESSAGE TO BE PRINTED OUT                                  *
*      = 0 ==> UPDATE TIMER ONLY, DO NOT PRINT MESSAGE OUT            *
*   R3 = @ AREA WHERE TIME INCREMENT SHOULD BE PLACED                 *
*   R4 = LENGTH OF MESSAGE TO BE PRINTED                              *
*   R6 = @ WHERE SECOND PART OF MESSAGE TO GO (INSTS/SEC, ETC)        *
*      = 0 ==> THERE IS NO 2ND PART OF MESSAGE                        *
*   R7 = VALUE TO BE USED IN 2ND PART OF MESSAGE, IF ANY              *
*   R14= RETURN @ TO CALLING SECTION OF PROGRAM.                      *
*        USES MACROS:  TTIMER(OS) ; GETIME(DOS)                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASTIMER  EQU   *                   ENTRY FOR TIMING PRINTING MODULE
         AIF   (&$ASMLVL).ASTOSGT  SKIP IF OS TTIMER DESIRED
         GETIME  TU                R1 <= TIME OF DAY IN TIMER UNITS
         L     R0,ASTMRMDS         GET TIME OF DAY FOR INTERRUPT(TIME)
         SR    R0,R1               YIELDS TIME (TU) LEFT IN INTERVAL
.ASTOSGT AIF   (NOT &$ASMLVL).ASTDSGT  SKIP IF DOS GETIME IN EFFECT
         TTIMER ,                  GET TIME LEFT IN INTERVAL
.ASTDSGT ANOP
         L     R1,AJOTIMR          GET CURRENT TIME REMAINING
         ST    R0,AJOTIMR          STORE NEW TIME REMINAING
         LTR   R2,R2               IS THERE A MESSAGE TO BE PRINTED
         BCR   Z,R14               RETURN TO CALLER, JUST RESET TIMER
         SPACE 1
*              ASTIMERE ENTRY ONLY ENTERED FROM SECTION ASTIMR24,IF GEN
ASTIMERE EQU   *                   ENTRY WITH NO TIMER UPDATE.
         SR    R1,R0               GET TIME DIFFERENCE
         M     R0,AJ2604           MULT BY 26.04 MICROSEC/TU
         D     R0,AJ100000         CONVERT TO MILLISEC IN R1
         CVD   R1,AJODWORK         CONVERT ELAPSED TIME
         MVC   0(ASPAL,R3),ASPATA  MOVE THE EDIT PATTERN IN
         ED    0(ASPAL,R3),AJODWORK+8-ASPAL/2         EDIT VALUE OVER
         LTR   R3,R6               TEST CODE AND MOVE OVER
         BZ    ASTPRINT            SKIP REST IF ZERO,GO PRINT
         SPACE 1
         M     R6,AJ1000           MULT # STMTS, GET STMTS/SEC
         LTR   R1,R1               MAKE SURE TIME >= 1MILLISEC
         BZ    *+6                 SKIP DIVIDE IF 0
         DR    R6,R1               DIVIDE TO GET STMTS OR INSTS/SEC
         CVD   R7,AJODWORK         CONVERT RESULT TO DECIMAL
         MVC   0(ASPBL,R3),ASPATB  MOVE EDIT PATTERN OVER
         ED    0(ASPBL,R3),AJODWORK+8-ASPBL/2         EDIT VALUE ACCROS
ASTPRINT LR    R0,R2               MOVE @ MESSAGE OVER FOR ASASPRINT
         LR    R1,R4               MOVE LENGTH OVER FOR ASASPRNT
*              FALL THRU INTO ASASPRNT
.AST60A  ANOP
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASASPRNT   CALLED BY ASPRNT MACRO TO PRINT A LINE.        *
*        THIS INSUB IS USED INSTEAD OF MANY $PRNTS TO SAVE SPACE.     *
*        *** MUST IMMEDIATELY FOLLOW ASTIMER SECT., IF IT EXISTS.     *
*        ENTRY CONDITIONS                                             *
*   R0 = @ LINE TO BE PRINTED                                         *
*   R1 = LENGTH OF LINE TO BE PRINTED.                                *
*   R14= RETURN @ TO CALLING CODE INSIDE MAIN PROG ASSIST.            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASASPRNT $PRNT (R0),(R1)           PRINT THE LINE DESIRED
         BR    R14                 RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MAIN STORAGE MANAGEMENT CODE SECTIONS.                 *
*        THE FOLLOWING SECTIONS OF CODE CONTAIN THE INTERFACE         *
*        BETWEEN ASSIST AND THE OPERATING SYSTEM WITH RESPECT TO      *
*        DYNAMIC MEMORY MANAGEMENT.  IF ASSIST MUST BE RUN UNDER      *
*        A SYSTEM WITHOUT SUCH FACILITIES, THIS CODE CAN BE MODIFIED  *
*        TO JUST SUPPLY ADDRESSES OF A FIXED STORAGE AREA.            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASMSINIT   MAIN STORAGE INITIALIZATION                    *
*              ASMSINIT IS CALLED TO OBTAIN THE LARGEST POSSIBLE      *
*        BLOCK OF MAIN STORAGE >= 8K BYTES, FREE BACK THE AMOUNT      *
*        GIVEN BY ASLENOS (OR FREE= PARM, IF USED), AND SET VALUES    *
*        DESCRIBING THE STORAGE AREA LEFT, WHICH IS USED AS THE       *
*        SINGLE DYNAMIC STORAGE AREA FOR THE ENTIRE RUN.              *
*        STORAGE ALLOCATION IS DONE 1 TIME ONLY FOR WHOLE BATCH.      *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN @ TO CALLING SECTION OF CODE.                         *
*        EXIT CONDITIONS                                              *
*   R0,R1,R2,R15   ARE MODIFIED BY THIS SECTION.                      *
*   AJOPADL,AJOPADH HAVE BEEN SET(LOWER, UPPER LIMITS OF CORE AREA).  *
*        AJOSTEP SET WITH FLAG AJOMSINT TO SHOW DONE.                 *
*        USES MACROS: GETMAIN (ONLY USE OF GETMAIN IN ASSIST).        *
*                     COMRG-(DOS)                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASMSINIT EQU   *
         OI    AJOSTEP,AJOMSINT    SHOW MAIN CORE OBTAINED. HALT FREE=
         LA    R2,AJOPADL          GET @ WHERE @'S TO BE PUT
         AIF   (&$ASMLVL).ASGETMN  FOR THE OS GETMAIN
         SPACE
         COMRG                     GET @ OF OUR COMMUNICATIONS REGION
         LM    R0,R1,32(R1)        R0 <- HIGHEST PARTITION ADDRESS
*                                  R1 <- END @ OF LAST PHASE LOADED
         LA    R1,3(R1)            GET @ OF AT LEAST NEXT FULLWORD
         N     R1,=X'FFFFFFFC'     INSURE FULLWORD BOUNDARY
         N     R0,=X'FFFFFFFC'     MAKE SURE ON FULLWORD BOUNDARY
         SR    R0,R1               GET LENGTH OF FREE STORAGE LEFT
         ST    R1,0(R2)            SAVE @ OF FREE BLOCK
         ST    R0,4(R2)            SAVE LENGTH OF FREE BLOCK
.ASGETMN AIF   (NOT &$ASMLVL).ASNGTMN  IN CASE OF STATIC ALLOCATION
         GETMAIN VU,LA=ASSPACE,A=(2),SP=1    GET AT LEAST 8K
.ASNGTMN ANOP
*              AT THIS PT AJOPADL=@ AREA, AJOPADH=LENGTH OF IT
         SPACE 1
         AIF   (&$DEBUG).ASZX1     SKIP IF NOT DEBUG MODE
*              ZERO ENTIRE DYNAMIC MEMORY AREA FOR DEBUGGING.
         LH    R0,=H'-256'         FOR BXH DECREMENT
         L     R15,AJOPADH         GET LENGTH OF AREA
         L     R1,AJOPADL          GET @ AREA
         AR    R15,R1              ADD BEGIN TO LENGTH TO GET END@
         AR    R15,R0              ADD -256 TO ENDING @
         SPACE 1
         XC    0(256,R15),0(R15)   ZERO A BLOCK OF MEMORY
         BXH   R15,R0,*-6          LOOP BACKWARDS, ZEROING
         XC    0(256,R1),0(R1)     ZERO 1ST 256 TO MAKE SURE
.ASZX1   ANOP
         SPACE 1
         LM    R0,R1,AJOPADL       AJOPADL,H= AREA @, LENGTH
         LR    R15,R1              SAVE THE LENGTH OF THE AREA
         AR    R1,R0               GET UPPER @ LIMIT
         ST    R1,AJOPADH          SAVE AS PERMANENT UPPER LIMIT
         SPACE 1
*              CHECK FREE VALUE, FREE SPACE AS REQUESTED.
         L     R0,AJOFREE          GET FREE VALUE (INIT TO ASLENOS)
         CR    R0,R15              COMPARE FREE LENGTH TO OBTAINED ONE
         BNH   *+6                 SKIP IF OK, FREE <= GOTTEN         J
         LR    R0,R15              FREE WHOLE THING (LOOK FOR AS999)  J
         AIF   (&$FREEMN EQ 0).ASZQQQ  SKIP IF NO LOWER LIMIT ON FREE J
         CH    R0,=H'&$FREEMN'     COMPARE AGAINST MINIMUM ALLOWED    J
         BNL   *+8                 SKIP IF >= MINIMUM ALLOWED         J
         LH    R0,=H'&$FREEMN'     PROBABLY ERROR, USE MINIMUM ALLOWED
.ASZQQQ  ANOP                                                         J
         SRL   R0,3                SHIFT, REMOVE 3 BITS
         SLA   R0,3                SHIFT, ALIGNED ON DOUBLEWORD
         BCR   Z,R14               RETURN, FREE=0, SO FREE NONE
         SR    R1,R0               SUBTRACT FROM UPPER LIMIT
         ST    R1,AJOPADH          NEW UPPER LIMIT
         B     ASMSFREE            GO FREE THE SPACE REQUESTED
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASMSFINI FREE CURRENT DYNAMIC STORAGE AREA                *
*        CALLED TO FREE SPACE DESCRIBED BY AJOPADL-AJOPADH PTRS.      *
*        SINCE DOS USER MUST ALLOCATE OWN DYNAMIC AREA FOR THE USERS  *
*        PROGRAMS, THERE IS NO NEED TO FREE THIS BLOCK.               *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN @ TO CALLING SECTION OF CODE.                         *
*        EXIT CONDITIONS                                              *
*   R0,R1,R15  ARE MODIFIED.                                          *
*   STORAGE FROM (AJOPADL) TO (AJOPADH) HAS BEEN FREEMAIN'ED.         *
*        USES MACROS: FREEMAIN   (ONLY USE OF FREEMAIN IN ASSIST).    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASMSFINI EQU   *
         LM    R15,R0,AJOPADL      GET AJOPADL-AJOPADH
         LR    R1,R15              MOVE LOWER @ OVER
         SR    R0,R15              LENGTH = (AJOPADH) - (AJOPADL).
         SPACE 1
ASMSFREE EQU   *                   ENTRY POINT FROM ASMSINIT TO FREE
         AIF   (NOT &$ASMLVL).ASNFRMN   SKIP IF DOS DYNAMIC STORAGE USE
         AL    R0,=XL4'01000000'   SHOW SP=1
         FREEMAIN R,LV=(0),A=(1)   FREE THE SPACE TO OS
.ASNFRMN ANOP
         BR    R14                 RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASRECL##   RECORD LIMIT CONTROL                           *
*        VARIOUS ENTRIES IN THIS SECTION ARE CALLED TO MANIPULATE     *
*        RECORD CONTROL VARIABLES.  EACH SECTION IS NORMALLY CALLED   *
*        ONLY ONE PLACE, BUT ARE GROUPED HERE FOR EASE OF CHANGE, AND *
*        SETUP FOR DIFFERING OPTIONS.                                 *
*        ENTRY CONDTIONS                                              *
*   R9 = RETURN ADDRESSS OF CALLING CODE                              *
*        EXIT CONDITIONS                                              *
*   R0,R1,R14,R15  MAY BE DESTROYED.                                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              ASRECL04 - INITIALIZE TOTAL RECORD COUNT               *
ASRECL04 EQU   *
         AIF   (&$RECORD EQ 2).ASR04A       SKIP IF  $TIRC EXISTS
         MVC   AJORECNT,AJORECL    MOVE USER VALUE OVER
         BR    R9                  RETURN TO CALLER
.ASR04A  AIF   (&$RECORD LT 2).ASR04B       SKIP IF NO $TIRC
*              CALCULATED RECORD LIMIT: =RECREM (IF USER SUPPLIED NO
*              R= PARM.   OR  MIN(RECREM, USER R= PARM)).
         $TIRC RECREM              GET # LEFT SAID BY SYSTEM
         TM    AJOAPMOD,AJOAPUSR   DID USER ACTUALLY SPECIFY
         BZ    ASR04A              NO, SO JUST USE RECREM
         AIF   (&$RECOVR).ASRPSU1  SKIP IF R= SHOULD BE USED-PSU BATS
         C     R0,AJORECL          CHECK AGIANST USER R=
         BNH   *+8                 SKIP IF MINIMUM THERE ALREADY
.ASRPSU1 L     R0,AJORECL          GET USER SPECIFIED R= RECORD LIMIT
ASR04A   ST    R0,AJORECNT         STORE THE COUNT THERE
         BR    R9                  RETURN TO CALLER
.ASR04B  ANOP
         SPACE 1
*              ASRECL14 - SET RECORD COUNT BEFORE REPL PHASE B.
ASRECL14 EQU   *                   JUST SAME AS FOR EXECUTE TIME
         SPACE 1
*              ASRECL16 - RECORD CONTROL JUST BEFORE USER EXECUTION.
*              AJORECNT = MIN(AJORECNT, RX=) - RD=  .
*              THIS METHOD ALLOWS FOR DUMP IF DESIRED.
ASRECL16 EQU   *
         L     R0,AJORECNT         GET CURRENT LINES LEFT-TOTAL
         L     R1,AJORX            GET DESIRED TOTAL FOR EXEC+DUMP
         LA    R15,AJORD           @ RECORDS SAVED FOR DUMP
         BAL   R14,ASTRP16         CALL COMPUTING ROUTINE
         ST    R0,AJORECNT         STORE THE VALUE COMPUTED
         NI    AJOMODE,255-AJOSRECX    REMOVE POSSIBLE OVERRUN FLAG
         BR    R9                  RETURN TO CALLER
         SPACE 1
*        ASRECL20 - RESET RECORD CONTROL JUST BEFORE USER DUMP DONE.
ASRECL20 EQU   *
         L     R0,AJORECNT         GET # LEFT FROM EXECUTION
         A     R0,AJORD            ADD THOSE SAVED FOR DUMP
         ST    R0,AJORECNT         STORE CORRECT NEW VALUE
         NI    AJOMODE,255-AJOSRECX         REMOV OVERRRUN FLAG IF ON
         BR    R9                  RETURN TO CALLER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: ASTRP16    COMPUTE VALUES FOR BEFORE EXECUTION            *
*        USED BY (ASTIMR,ASRECL,ASPAGE)16 TO COMPUTE THE VALUE FOR    *
*        CONTROL FOR USER EXECUTION.  THE VALUE IS THE MINIMUM OF     *
*        REMAINING VALUE AND THE USER EXECUTION VALUE.  THEN SUBTRACT *
*        AMOUNT TO BE SAVED FOR A DUMP.                               *
*        ENTRY CONDITIONS                                             *
*   R0 = CURRENT VALUE OF COUNTER  (AJOTIMR,AJORECNT,AJOPREM)         *
*   R1 = EXECUTION VALUE           (AJOTX,  AJORX,  AJOPX)            *
*   R15= @ DUMP VALUE              (AJOTD,  AJORD,  AJOPD)            *
*        EXIT CONDITIONS                                              *
*   R0 = MIN ((R0), (R1)) - 0(R15).  IF <0, = 0(R15) & 0(R15) = 0.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ASTRP16  EQU   *
         CR    R0,R1               WAS REMAINING LESS THAN EXEC SPECFD
         BL    *+6                 YES, USE IT SINCE MIN
         LR    R0,R1               NO, USE EXECUTION TIME SPECIFIED VAL
         S     R0,0(,R15)          SUBTRACT VALUE SAVED FOR DUMP
         BCR   P,R14               RETURN IF OK
         A     R0,0(,R15)          ADD THE VALUE BACK TO 0 OR ABOVE
         SR    R1,R1               GET A 0
         ST    R1,0(,R15)          ZERO OUT-SO WE DON'T GIVE HIM MORE
         BR    R14                 RETURN TO CALLING SECTION
         EJECT
         AIF   (NOT &$PAGE).ASPG100         SKIP IF NO PAGE CONTROL
**--> INSUB: ASPAGE##   PAGE CONTROL CODE FOR PAGE MODE LIMITS  + + + +
*+       THESE SECTIONS CALLED TO SET LINE AND PAGE LIMITS.  NOTE THAT+
*+       THEY DO NOT BOTHER TO CHECK WHETHER PAGE CONTROL MODE IS     +
*+       ON OR NOT.  THIS IS SAFE BECAUSE THESE ACTIONS HAVE NO       +
*+       EFFECT WHATSOEVER IF PAGE CONTROL NOT ON, SINCE XXXXIOCO     +
*+       SECTIONS DO NO CHECKING UNLESS IT IS.                        +
*+       NOTE THAT SECTIONS OF ASTIMR##, ASRECL##, AND ASPAGE## HAVING+
*+       SAME TWO-DIGIT CODE FOR END GENERALLY ARE CALLED TOGETHER.   +
*+       ENTRY CONDITIONS                                             +
*+  R9 = RETURN ADDRESS TO CALLING SECTION OF CODE.                   +
*+       EXIT CONDITIONS                                              +
*+  R0,R1,R14,R15  MAY BE DESTROYED.                                  +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
*+             ASPAGE04 - INITIALIZE FOR WHOLE RUN.  SET UP FOR       +
*+             DEFINITE NEW PAGE SKIP, SINGLE SPACE IF REQUESTED.     +
ASPAGE04 EQU   *
         MVC   AJOPREM,AJOP        SET FROM WHATEVER VALUE OF P=
         SR    R0,R0               ZERO REGISTER
         ST    R0,AJOLREM          LINES LEFT = 0, CREATE NEW PAGE
         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLE SPACE FLAG
         OC    AJIOPR,AJIOSS       ENTER SINGLE SPACE FLAG IF REQUIRED.
         BR    R9                  RETURN
         SPACE 1
         AIF   (&$REPL EQ 0).ASPNR SKIP IF NO REPL
*+             ASPAGE14 - PAGE CONTROL BEFORE REPLACE PHASE B.
ASPAGE14 EQU   *
         SR    R0,R0               ZERO REGISTER
         ST    R0,AJOLREM          SAME AS ASPAGE16, BUT ****NEW PAGE**
*              FALL THRU INTO ASPAGE16.
.ASPNR   ANOP
         SPACE 1
*              ASPAGE16 - PAGE LIMIT SET BEFORE USER PROGRAM EXECUTE.
ASPAGE16 EQU   *
         L     R0,AJOPREM          GET CURRENT # PAGES LEFT
         L     R1,AJOPX            GET NUMBER FOR EXEC+DUMP
         LA    R15,AJOPD           GET VALUE FOR DUMP
         BAL   R14,ASTRP16         CALL GENERAL COMPUTE FOR EXEC
         ST    R0,AJOPREM          STORE COMPUTED VALUE BACK
         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLESPACE FLAG
         OC    AJIOPR,AJIOSSX      FLAG SINGLE SPACE IF DESIRED
         BR    R9                  RETURN TO CALLER
         SPACE 1
*+             ASPAGE20 - SET UP PAGE LIMIT FOR DUMP.                 +
ASPAGE20 EQU   *
         L     R0,AJOPREM          GET CURRENT PAGES LEFT
         A     R0,AJOPD            ADD IN DUMP PAGES
         ST    R0,AJOPREM          STORE BACK
         NI    AJIOPR,255-AJIOSING REMOVE POSSIBLE SINGLE SPACE FLAG
         OC    AJIOPR,AJIOSSD      PUT IN SSD FLAG IF EXISTS
         BR    R9                  RETURN
.ASPG100 ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              DISASTROUS TERMINATIONS.                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              ASZERR1 - COULD NOT OPEN PRINTER - ABORT               *
         AIF   (&$ASMLVL).ASOSWTL      SKIP $PRNT IF UNDER OS GENERATN
ASZERR1  $PRNT =CL50' AM001 - ASSIST COULD NOT OPEN PRINTER - ABORT',50
.ASOSWTL AIF   (NOT &$ASMLVL).ASDSPNT  SKIP IF DOS GENERATED $PRNT
ASZERR1  WTO   'AM001 ASSIST COULD NOT OPEN PRINTER FT06F001:ABORT',   #
               ROUTCDE=11          WRITE-TO-PROGRAMMER NOW
.ASDSPNT ANOP
         TM    AJIOSO,AJIOPEN      COULD READER BE OPENED FOR SOURCE
         BO    ASZERRXI            SKIP IF RDR DID OPEN OK
         SPACE 1
*              ASZERR2 - COULDN'T OPEN SOURC RDR - ABORT              *
         AIF   (&$ASMLVL).ASRDRNO      SKIP FOR OS WTL & ABORT
ASZERR2  $PRNT =CL50' AM002 - ASSIST COULD NOT OPEN READER - ABORT',50
.ASRDRNO AIF   (NOT &$ASMLVL).ASNOWTL  SKIP IF NO OS WTL ALLOWED
ASZERR2  WTO   'AM002 ASSIST COULD NOT OPEN READER SYSIN:ABORT',       #
               ROUTCDE=11          WRITE-TO-PROGRAMMER RATHER THAN WTL
.ASNOWTL ANOP
         SPACE 1
ASZERRXI LA    R2,16               SET RETURN CODE TO DISASTER
         B     ASFINISZ            TAKE ERROR EXIT
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       FINISH AND EXIT SECTION                       *
*        HAVE TOTAL RUN TIME COMPUTED AND PRINTED.                    *
*        CLOSE ALL DCB'S WHICH ARE CURRENTLY OPEN (XXXXFINI).         *
*        FREE ALL THE STORAGE OBTAINED BY GETMAIN AT BEGINNING.       *
*        STORE VALUE IN R2 AS RETURN CODE.                            *
*        RETURN TO CALLING PROGRAM.                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ASFINIS  EQU   *                   NORMAL TERMINATION LABEL
         ASTIMR 24,2               PRINT END MESSAGE IF REQUIRED
         SPACE 1
         XCALL XXXXFINI            HAVE ALL DCB'S CLOSED
         SR    R2,R2               SET RETURN CODE TO 0
         SPACE 1
*              ASFINISZ ENTERED IF COULDN'T OPEN RDR OR PRINTER       *
*              RETURN ALL GETMAIN'ED STORAGE TO THE SYSTEM.           *
ASFINISZ EQU   *
         BAL   R14,ASMSFINI        GO RETURN ALL SPACE USED TO OS
         SPACE 1
         AIF   (&$ASMLVL).ASNOEOJ      SKIP FOR OS RETURN
         EOJ                       SVC RETURN TO SUPERVISOR IF DOS
.ASNOEOJ AIF   (NOT &$ASMLVL).ASDSEOJ  SKIP IF DOS EOJ IN EFFECT
         L     R1,4(R13)           GET PREVIOUS SAVE AREA PTR
         ST    R2,16(R1)           STORE VALUE IN R2 AS RETURN CODE
         $RETURN RGS=(R14-R12)     RETURN TO CALLER
.ASDSEOJ ANOP
         SPACE 1
         AIF   (&$TIMER LT 1).AST65A       SKIP STIMER EXIT IF NON REQR
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       TIMER EXIT ROUTINE                            *
*        THIS SECTION IS CALLED IF A TIMER INTERRUPT OCCURS DURING    *
*        AN ASSIST RUN.  IT FLAGS AJOSOVRT BIT IN AJOMODE TO NOTE THE *
*        OVERRUN, THEN EXAMINES AJOSTEP TO DETERMINE WHAT STEP ASSIST *
*        IS IN.  DEPENDING ON THE STEP, IT TAKES ACTION TO ENSURE     *
*        THAT THE PARTICULAR PHASE WILL BE TERMINATED FAIRLY QUICKLY. *
*        PHASES CAN BE ASSEMBLY, EXECUTION, DUMP, OR ASSEMBLY+EXEC    *
*        (THE LAST CASE BEING DURING A REPLACE PHASE B, IF ANY).      *
*        **NOTE** UNDER DOS USE, ANY MODIFIED REGS MUST BE PLACED IN  *
*        THE INTERRUPT SAVE AREA BEFORE EXITING                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).ASTEXIN  SKIP IF UNDER OS GENERATION
ASTEXIT  BALR  R15,0               ESTABLISH ADDRESSABILITY
         USING *,R15               INFORM OF BASE REG R15 USING
.ASTEXIN AIF   (NOT &$ASMLVL).ASTEXDS  SKIP IF UNDER DOS GENERATION
         USING ASTEXIT,R15         NOTE TEMPORARY USING
ASTEXIT  STM   R14,R12,12(R13)     SAVE ALL , FOR SAFETY
.ASTEXDS ANOP
         LA    R11,ASJOBCON        GET @ MAIN TABLE BACK
         OI    AJOMODE,AJOSOVRT    SHOW REAL TIME OVERRUN
         TM    AJOSTEP,AJOSEXEC    WAS INTERPRETER BEING USED
         BZ    ASTEXASM            NO, GO TO CHECK ASM FLAG
         L     R10,AJOECOPT        GET @ ECONTROL BLOCK
         MVI   ECFLAG1,$ECTIMEX    TELL EXECUT TO QUIT NEXT BRANCH
         SPACE 1
ASTEXASM EQU   *
*              **NOTE** THE MAIN PROGRAMS FOR BOTH PASSES OF THE
*              ASSEMBLER TEST AVTAGS2 1 TIME FOR EACH STATEMENT.
*              **NOTE** IT IS ALWAYS SAFE TO SET THE BIT THIS WAY.
         L     RAT,AJOVWXPT        GET @ VWXTABL
         USING AVWXTABL,RAT        NOTE PTR THERE
         OI    AVTAGS2,AJOASTOP    SET BIT-ASSEMBLER WILL STOP
         DROP  RAT                 ZAP USING
*              WE MAY BE IN DUMP STEP (AJOSDUMP IN AJOSTEP).  IN
*              IN ANY CASE, SET AJOSRECX , WHICH WILL STOP ANY
*              ASSIST MODULE, THE NEXT TIME ANY OUTPUT IS DONE.
         TM    AJOSTEP,AJOSDUMP    ARE WE IN DUMP STEP                J
         BZ    *+8                 NO, SKIP OVER OVERRUN SET
         OI    AJOMODE,AJOSRECX    SHOW RECORDS EXCEEDED(PSEUDO)
ASTEXIZ  EQU   *
         AIF   (&$ASMLVL).ASTEXEX  SKIP IF UNDER OS GENERATION
         EXIT  IT                  RETURN TO DOS SUPERVISOR
ASTSAVAD DC    18F'-1'             DOS -IT- INTERRUPT SAVE AREA
ASTMRMDS DS    F                   TIME OF DAY FOR TIMER INTERRUPT
.ASTEXEX AIF   (NOT &$ASMLVL).ASTEX2   SKIP IF UNDER DOS GENERATION
         LM    R14,R12,12(R13)     RELOAD REGS
         BR    R14                 RETURN TO OS/360
.ASTEX2  ANOP
         DROP  R15                 KILL THE USING
.AST65A  ANOP
         EJECT
*              PRIMARY SPACE ALLOCATION CONTROL WORDS                 *
ASSPACE  DC    A(8192,524288)      GET ALL WE CAN, UP TO 512 K
ASTBEGIN DS    F                   FOR TIME LEFT AT BEGINNING
ASFWORK  DS    F                   TEMPORARY WORKAREA
ASPARMSV DS    A                   SAVE WORD FOR @ PARM FILED,ETC
         SPACE 1
*                  *** HEADER FOR BEGINNING OF EACH JOB ***
ASH1HD   DC    C'1*** ASSIST &$VERSLV-&$GENDAT'                 CPP
         DC    C'  &$MCHNE/&$MODEL:&$SYSTEM'                    CPP
*                                  INSTRUCTION SET-DECIMAL,FLOAT,PRIVIL
         DC    C'  INS=S',(&$DECSA)C'D',(&$FLOTA)C'F',(&$PRIVOP)C'P'
         DC    (&$S370A)C'7'       SUPPORT DEC. FLOAT, PRIV, 370 CPP
         DC    C'/X=',(&$XIOS)C'B',(1-&$XXIOS)C'G',(&$HEXI*&$HEXO)C'H'
         DC    (&$EXINT)C'O'       SUPPORT BASIC,XGET,HEXS,XOPC CPP
         DC    ((1-(&$HEXI+&$HEXO+&$XIOS+&$EXINT+3)/4)*&$XXIOS)C'NONE'
*                                  TIME,RECORDS,PAGE CHECKING/CONTROL
         DC    C', CHECK/TRC/=&$TIMER&$RECORD&$COMNT'           CPP
*                                  MAJOR OPTIONALS-CMPRS,COMNT,
*                                  026 KEYPUNCH, MACRO, REPLACE MONITOR
         DC    C', OPTS=',(&$CMPRS)C'C',((&$DISKU+1)/2)C'D'     CPP
         DC    (&$KP26)C'K',(&$MACROS)C'M',(&$PAGE)C'P'         CPP
         DC    ((&$REPL+1)/2)C'R',(&$XREF)C'X'                  CPP
         DC    C'  PENN STATE UNIV ***'                         CPP
ASH1H$L  EQU   *-ASH1HD            LENGTH OF THIS HEADER
         SPACE 1
*              EDIT PATTERN, OUTPUT HEADINGS                          *
         AIF   (&$TIMER LT 1).AST70A        SKIP EDIT PATTERN
ASPATA   DC    X'40202021204B202020'         EDIT PATTERN FOR TIMING
ASPAL    EQU   L'ASPATA            LENGTH ATTRIB OF EDIT TIME PATTERN
.AST70A  ANOP
ASPATB   DC    X'4020202020202120' EDIT PATTERN FOR # INSTRUCTIONS DONE
ASPBL    EQU   L'ASPATB            LENGTH ATTRIB OF STMT EDIT PATTERN
         SPACE 1
         AIF   (&$TIMER GT 0).AST75A        SKIP IF NOT =0
*              EXECUTION STATISTICS MESSAGE FOR &$TIMER=0 ONLY.
ASHEX    DC    C'0*** EXECUTION:'
ASHEXP2  DC    ZL(ASPBL)'0',C' INSTRUCTIONS EXECUTED ***'
ASHEXL   EQU   *-ASHEX             LENGTH OF MESSAGE
.AST75A  AIF   (&$TIMER EQ 0).AST80A        SKIP MESSAGES IF UNNEEDED
ASHASM   DC    C'0*** ASSEMBLY TIME ='
ASHASMP  DS    CL(ASPAL)
         DC    C' SECS, '
ASHASMN  DC    ZL(ASPBL)'0',C' STATEMENTS/SEC ***'
ASHASML  EQU   *-ASHASM            DEFINE LENGTH OF MESSAGE
         SPACE 1
ASHEX    DC    C'0*** EXECUTION TIME ='
ASHEXP   DS    CL(ASPAL)
         DC    C' SECS.  '
ASHEXP2  DC    ZL(ASPBL)'0',C' INSTRUCTIONS EXECUTED - '
ASHEXN   DC    ZL(ASPBL)'0',C' INSTRUCTIONS/SEC ***'
ASHEXL   EQU   *-ASHEX             DEFINE TOTAL LENGTH OF MESSAGE
.AST80A  ANOP
ASCARDMS DC     C'*** FIRST CARD NOT READ: '   CARD MESSAGE           J
         SPACE 1
ASEMSG   DC    C'0*** AM003 - STORAGE OVERFLOW BEFORE EXECUTION, EXECUTX
               TION DELETED ***'
         SPACE 1
ASNORMAL DC    C'0*** AM004 - NORMAL USER TERMINATION BY RETURN ***'
         SPACE 1
ASRTOVR  DC    C'0*** AM005 - TIME OR RECORDS HAVE BEEN EXCEEDED'
         SPACE 1
         AIF   (&$TIMER LT 2).AST90A        SKIP END MESSAGE IF NEED
ASHEND   DC    C'0*** TOTAL RUN TIME UNDER ASSIST = '
ASHENDP  DC    ZL(ASPAL)'0',C' SECS ***'
ASHENDL  EQU   *-ASHEND            LENGTH OF MESSAGE
         SPACE 1
.AST90A  ANOP
ASHEXGO  DC    C'0*** PROGRAM EXECUTION BEGINNING - ANY OUTPUT BEFORE EX
               XECUTION TIME MESSAGE IS PRODUCED BY USER PROGRAM ***'
         SPACE 2
*              ***** PARM FIELD OPTION LISTS *****
         SPACE 1
*              ASPARLIM - SUPPLIES LIMIT VALUES FOR NUMERICAL PARMS,
*              PLUS DEFAULT VALUES FOR ANY OVERRIDABLE VALUES.
*              **NOTE** MOST OF OVERRIDABLE ONES COULD BE SUPPLIED
*              IN DEFAULT PARM FIELD BELOW ALSO.
ASPARLIM DS    0D                  ALIGN
*              UPPER LIMIT VALUES-CANNOT BE INCREASED BEYOND THESE.
         DC    C'I=&$IMX'          MAXIMUM INSTRUCTION COUNT
         AIF   (NOT &$PAGE).ASPL10 SKIP IF NO PAGE CONTROL
         DC    C',L=&$LMX,P=&$PMX,PD=&$PDMX,PX=&$PXMX'  PAGE LIMITS
.ASPL10  ANOP
         DC    C',R=&$RMX,RD=&$RDMX,RX=&$RXMX'        RECORD LIMITS
         AIF   (&$TIMER EQ 0).ASPL20        SKIP IF NO TIMING
         DC    C',T=&$TMX,TD=&$TDMX,TX=&$TXMX'        TIME LIMITS
.ASPL20  ANOP
         SPACE 1
*              OVERRIDABLE DEFAULT VALUES FOR RESETTABLE PARM OPTIONS.
         DC    C',&$BATCH,NOCMPRS,NOCOMNT,DUMP=0,FREE=&$FREE'
         DC    C',LIST,LOAD,NOMONIT,NERR=0'  (LARGE NO LONGER EXISTS) J
         AIF   (NOT &$DATARD).ASPL25        SKIP IF NO DATA RDR
         DC    C',DATA,SYSIN'      DEFAULT - THEY BOTH EXIST
.ASPL25  ANOP
         AIF   (&$DEBUG).ASPL30    SKIP IF NO DEBUG
         DC    C',DEBUG=0'         NO VALUE FOR DEBUG
.ASPL30  ANOP
*********AIF   (NOT &$EXINT).ASPL35    **********NEW INTERPRETER******
         DC    C',IECF=0'          DEFAULT: NO STATISTICS
.ASPL35  ANOP
         AIF   (NOT &$KP26).ASPL40 SKIP IF NO ALTERNATE KEYPINCH
         DC    C',KP=29'           DEFAULT IS 029
.ASPL40  ANOP
         AIF   (NOT &$PAGE).ASPL50 SKIP IF NO PAGE CONTROL
*              CHANGE BELOW TO ---CPAGE TO PAGE CONTROL DEFAULT.
         DC    C',NOSS,NOSSX,NOSSD,CPAGE'   MAKE CPAGE DEFAULT IF GEN J
.ASPL50  ANOP
         AIF   (&$DISKU NE 1).ASPL60                   SKIP
         DC    C',NODISKU'         NORMAL - DO INCORE
.ASPL60  ANOP
         AIF   (NOT &$PUNCH).ASPL70         SKIP IF NOPUNCH
         DC    C',PUNCH'           REAL PUNCH EXISTS
.ASPL70  ANOP
         AIF   (&$REPL EQ 0).ASPL90         SKIP IF NO REPLACE
         DC    C',NOREPL,RFLAG=0'
.ASPL90  ANOP
         AIF   (NOT &$PRIVOP).ASPL100       SKIP IF NO PRIVILEGED OPS
         DC    C',NOSUPER'
.ASPL100 ANOP
         AIF   (NOT (&$DECK OR &$OBJIN)).ASPL110      SKIP IF NO DECKS
         DC    C',NODECK,NOOBJIN'
.ASPL110 ANOP
         AIF   (NOT &$RELOC).ASPL120   SKIP IF NO RELOC MODE
         DC    C',NORELOC'         MAKE NON RELOCATED NORMAL MODE
.ASPL120 ANOP
         AIF   (&$S370 NE 2).ASPL130 SKIP IF NOT SIMULATING S/370
         DC    C',ALGN'            MAKE DEFAULT ALGN (ALIGNMENT NEEDED)
.ASPL130 ANOP
         AIF   (NOT &$MACROS).ASPL140       SKIP IF NO MACROS
         DC    C',MACRO=N,MACTR=&$MMACTR,MNEST=&$MMNEST,MSTMG=&$MMSTMG'
         AIF   (NOT &$MACSLB).ASPL135        SKIP IF NO LIBRARY MACS
         DC    C',NOLIBMC'                   DEFAULT = NO CALL LIBR MCS
.ASPL135 ANOP
.ASPL140 ANOP
         AIF   (NOT &$XREF).NOXREF6  SKIP IF NO XREF                  A
         DC    C',XREF=(&$XREFDF(1),&$XREFDF(2),&$XREFDF(3))'  DEFAULTA
.NOXREF6 ANOP                                                         A
         DC    C' '                PUT IN BLANK AT END*****MUST HAVE***
ASPARL$L EQU   *-ASPARLIM          LENGTH OF ENTIRE FIELD
         SPACE 2
*              DEFAULT VALUES FOR LIMIT VALUES AND NONRESETTABLE PARMS.
ASPARDF  DS    0D                  ALIGN
         AIF   (NOT &$PAGE).ASPD10 SKIP IF NO PAGE CONTROL
         DC    C'L=&$LDF,P=&$PDF,PD=&$PDDF,PX=&$PXDF,'
.ASPD10  ANOP
         DC    C'R=&$RDF,RD=&$RDDF,RX=&$RXDF'         RECORD DEFAULTS
         AIF   (&$TIMER EQ 0).ASPD20        SKIP IF NO TIMER
         DC    C',T=&$TDF,TD=&$TDDF,TX=&$TXDF'
.ASPD20  ANOP
         DC    C' '                PUT IN BLANK AT END*****MUST HAVE***
ASPARD$L EQU   *-ASPARDF           LENGTH OF THIS PARM FIELD
         SPACE 1
         LTORG
         SPACE 1
*              FOLLOWING SECTION CORRESPONDS TO AJOBCON DSECT.        *
ASJOBCON DS 0D
         DC    16F'0'              FOR ZEROING
         DC    F'1000'             FOR CONVERSION, AJ1000
         AIF   (&$ASMLVL).ASJOSTU      SKIP TO SET OS TIMER UNIT=26.04
         DC    F'333334'           DOS TIMER UNITS(USEC) * 100
.ASJOSTU AIF   (NOT &$ASMLVL).ASJDSTU  SKIP IF DOS TU OF 1/300 SEC
         DC    F'2604'             FOR TIME CONVERSIONS
.ASJDSTU ANOP
         DC    F'100000'           FOR TIME CONVERSIONS
         DC    F'100000000'        100 MILLION, TIME CONVERSIONS
         DC    V(VWXTABL)          @ MAIN ASSEMBLER TABLE
         DC    V(EXECUT)           ADCON FOR INTERPRETER CODE
         DS    0D
         AIF   (NOT &$KP26).ASNKP26         SKIP IF NO 026 KEYPUNCH ALL
         SPACE 1
*              TRANSLATE TABLE - 026-->029 KEYPUNCH.  ALLOWS KP=26.
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F   SAME EXCEPT )+(='
         DC    X'000102030405060708090A0B0C0D0E0F'    0X
         DC    X'101112131415161718191A1B1C1D1E1F'    1X
         DC    X'202122232425262728292A2B2C2D2E2F'    2X
         DC    X'303132333435363738393A3B3C3D3E3F'    3?
         DC    X'404142434445464748494A4B5D4D4E4F'    4X   ) 4C
         DC    X'4E5152535455565758595A5B5C5D5E5F'    5X  + 50
         DC    X'606162636465666768696A6B4D6D6E6F'    6X  ( 6C
         DC    X'707172737475767778797A7E7D7D7E7F'    7X  = 7B  ' 7C
         DC    X'808182838485868788898A8B8C8D8E8F'    8X
         DC    X'909192939495969798999A9B9C9D9E9F'    9X
         DC    X'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'    AX
         DC    X'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'    BX
         DC    X'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'    CX
         DC    X'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'    DX
         DC    X'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'    EX
         DC    X'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'    FX
         SPACE 1
.ASNKP26 ANOP
         DC    CL136' '            FOR BLANKING
         DC    C'0'                FOR CARRIAGE ONTROL
         ORG   ASJOBCON+AJOB$L     GET REMAINING LENGTH FOR SECTION
         DS    0D                  SEE WHAT LENGTH IS
         DROP  R10,R11,R13         KILL LEFTOVER USINGS
         TITLE '*** APCBLK DSECT - APARMS PARM CODE BLOCK ***'
**--> DSECT: APCBLK     APARMS PARM CODE BLOCK. . . . . . . . . . . . .
*.       THIS BLOCK DESCRIBES A PARM OPTION TABLE, GIVING THE NAME OF .
*.       THE PARM, A FLAG BYTE, AND AN OFFSET ADDRESS TO A PROCESSING .
*.       SECTION OF CODE IN CSECT APARMS.  IT IS USED ONLY IN APARMS. .
*.       LOCATION:  INSIDE TABLE APBPARMA IN CSECT APARMS.            .
*.       GENERATION: EACH APCBLK IS CREATED BY 1 CALL TO APCGN MACRO. .
*.       NAMES: APC-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
APCBLK   DSECT
*              EQU FLAG LIST FOR APCFLAG) - GIVE HANDLING TYPES.
APCYESNO EQU   B'00000001'         (APCFLAG)- YES/NO PARM;ELSE =PARM
APCYES1B EQU   B'00000010'         (APCFLAG)- FOR YES/NO TYPE PARMS
*                                  ON=> 1BIT=>YES;OFF=> 1BIT=> NO
APCNINCR EQU   B'00000010'         (APCFLAG)- IF =PARM DECIMAL VALUE
*                                  IF VALUE SET, DO NOT INCREMENT
APCD     EQU   B'00000100'         (APCFLAG)- PARM=DECIMAL # VALUE
APCNRSET EQU   B'00001000'         (APCFLAG)- ONCE SET, DO NOT RESET
APCCALL  EQU   B'00010000'         (APCFLAG)- CALL ROUTINE -APCADDR @
APCSETU  EQU   B'00100000'         (APCFLAG)-VALUE SET BY USER-$JOB CRD
APCSETP  EQU   B'01000000'         (APCFLAG)-VALUE SET FROM REAL PARM
APCSETLD EQU   B'10000000'         (APCFLAG)- VALUE WAS SET BY LIMIT
*                                  OR DEFAULT VALUE.
APCSET   EQU   APCSETLD+APCSETU+APCSETP     VALUE SET BY ANYBODY
APCP$L   EQU   AJOCP$L             LENGTH OF MAXIMUM # CHARS IN PARM
         SPACE 1
*              VARIABLES IN APCBLK - GIVE PARM NAME AND FLAGS
APCPARM  DS    CL(APCP$L)          EBCDIC FORM OF PARM, R-PADDED BLANKS
APCFLAG  DS    B                   FLAGS- DESCRIBE TYPE OF HANDLING
APCAJOFS DS    AL1                 OFFSET OF VARIABLE FROM AJO$PARM
APCLKSET DS    B                   FLAG SHOWING WHICH CALL SET/IF SET
APCBITS  DS    B                   FLAG USED TO SET FOR YES OPT OF Y/N
         ORG   APCBITS             BACK UP TO OVERLAY FOR =PARM
APCADDR  DS    AL1                 OFFSET FROM APAJUMP TO ROUTINE
APC$L    EQU   *-APCBLK            LENGTH OF 1 APCBLK
         TITLE '*** APARMS - USER PARM FIELD PROCESSING CSECT ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: APARMS     USER PARM FIELD PROCESSING CSECT               *
*        SCANS USER PARM FIELD, SETS VALUES IN AJOBCON DSECT.         *
*        ENTRY CONDITIONS                                             *
*   R9 = @ OF ACTUAL PARM FIELD CHARACTER STRING.                     *
*   R10= LENGTH OF PARM FIELD AT 0(R9).                               *
*   R11= ADDRESS OF AJOBCON DUMMY SECTION AREA.                       *
*        EXIT CONDITIONS                                              *
*   AJOPARM IN AJOBCON NOW HAS USER PARM FIELD, RIGHT-PADDED WITH ' '.*
*   VARIOUS FLAGS IN AJOBCON ARE NOW SET(SEE CODE STARTING AT APAJUMP)*
*        USES DSECTS: AJOBCON,APCBLK                                  *
*        USES MACROS: $DBG,$RETURN,$SAVE,$TIRC,APCGN,XDECI            *
*        *NOTE* AS OF 8/12/70, THIS PROGRAM IS MORE GENERAL THAN      *
*        CURRENTLY NEEDED, TO ALLOW FOR FUTURE NEW PARM OPTIONS.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APARMS   CSECT
         $DBG  ,NO                 SHOW NO DEBUG CODE FROM $SAVE/RETURN
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*         REGISTER USAGE AND CONVENTIONS IN APARMS CSECT              *
*   R0,R1,R2 = TEMPORARY WORK REGISTERS                               *
*   R3   ADDRESS OF CURRENT APCBLK WHEN LOOKING DOWN PARM LIST        *
*   R4 = APCP$L = LENGTH OF 1 APCBLK.  USED AS INCREMENT IN BXLE'S.   *
*   R5 = @ LAST APCBLK IN TABLE OR PART OF TABLE SEARCHED, BXLE LIMIT.*
*   R6 = SCAN POINTER TO NEXT CHARACTER TO BE PROCESSED IN PARM FIELD *
*   R7 = 1    CONSTANT FOR USE IN BXH'S AND  INCREMENTING,DECREMENTING*
*   R8 = BASE REGISTER                                                *
*   R9 = @ PARM FIELD ON INPUT.  USED AS BYTE REGISTER THEREAFTER.    *
*   R10= LENGTH OF PARM FIELD ON INPUT. @ LAST BYTE OF PARM AS LIMIT @*
*   R11= @ AJOBCON BLOCK, ON INPUT AND UNCHANGED                      *
*   R12  (UNUSED)                                                     *
*   R13= @ CALLING PROGRAM'S SAVE AREA, UNCHANGED                     *
*   R14= INTERNAL LINK REGISTER, WORK REGISTER                        *
*   R15= TEMPORARY WORK REGISTER                                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AJOBCON,R11         NOTE POINTER TO JOB TABLE
         $SAVE RGS=(R14-R12),SA=NO,BR=R8
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       INITIALIZATION SECTION                        *
*              INITIALIZE FLAGS IN LEADING NIBBLES OF APCFLAG BYTES.  *
*        CHECK TO SEE IF A PARM FIELD WAS USED. IF SO, MOVE IT OVER   *
*        TO INTERNAL AREA, WITH BLANKS FOLLOWING, TO MAKE SCANNING    *
*        EASIER AND USE LESS REGISTERS. SET UP FOR DOING ANALYSIS.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         LA    R4,APC$L            FOR INCREMENT ON MANY BXLE'S
         USING APCBLK,R3           NOTE USING, WILL USE R3 ALWAYS
         SPACE 1
*              ***** TEST FOR FLAG RESET REQUIRED. DO SO IF NEEDED ****
         TM    AJOAPMOD,AJOAPRSE   WAS THIS CALL A RESET CALL
         BZ    APNOTRSE            NO, SO SKIP RESET THIS TIME
         LA    R3,APBPARMA         @ BEGINNING OF TABLE
         LA    R5,APBPARMB-APC$L   @ LAST ELEMENT IN TABLE
         SPACE 1
         NI    APCLKSET,255-APCSET REMOVE ALL SET FLAGS
         BXLE  R3,R4,*-4           LOOP THRU TABLE
         SPACE 1
APNOTRSE EQU   *                   EXIT HERE IF NOT A RESET CALL
         LA    R7,1                USEFUL CONSTANT
         LR    R6,R10              MOVE LENGTH OF PARM OVER
*              IF AJOAPMOV SET, LEAVE PARM WHERE IT IS (MUST BE LIMIT
*              OR DEFAULT, WHICH HAVE BLANK AFTER PARM.)
         TM    AJOAPMOD,AJOAPMOV   SHOULD IT BE MOVED
         BO    *+12                YES, GO TO MOVE AND PAD CODE
         LR    R6,R9               MOVE BEGINNING ADDRESS OVER TO INIT
         AR    R10,R9              ADD BEGIN TO LENGTH GIVING END IN 10
         B     APMINIT             SKIP OVER TO INIT CODE
         MVC   AJOPARM,AJOBLANK+1  BLANK OUT ENTIRE PARM AREA
         SR    R6,R7               DECREMENT FOR MVC,CHECK FOR SIGN
         BM    APFINE              THERE WAS NO PARM FIELD,BRANCH
         LA    R0,AJOP$L-1         LENGTH-1 OF MAXIMUM PARM FIELD
         CR    R6,R0               IS LENGTH SMALL ENOUGH
         BNH   *+6                 SKIP IF LEGAL
         LR    R6,R0               TOO BIG,USE MAXIMUM
         STC   R6,*+5              STORE THIS LENGTH INTO MVC
         MVC   AJOPARM($),0(R9)    MOVE PARM FIELD OVER, R-PAD WITH BL
         AIF   (NOT &$KP26).APNKP2T         SKIP IF NO 026 KEYPUNCH
         STC   R6,*+5              PUT LENGTH INTO TR
         TR    AJOPARM($),AJTRTB26 TRANSLATE SO WILL PRINT RIGHT
.APNKP2T ANOP
         LA    R10,AJOPARM(R6)     SET LIMIT @ FOR SCANNING
         LA    R6,AJOPARM          INIT SCAN POINTER TO BEGINNING
APMINIT  EQU   *                   ENTRY TO BEGIN INIT FOR SCANNING
         SR    R9,R9               CLEAR FOR USE AS BYTE REG AFTER NOW
         MVC   APFLOCKT+1(1),AJOAPSET  MOVE INTO TM INSTR TO TEST LOCK
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       PARAMETER FIELD SCAN SECTION                  *
*              CHECK FOR PARM BEGINNING WITH 'NO', AND SET FLAGS IF   *
*        FOUND.  SCAN FOR , = OR BLANK TERMINATING PARM, SAVING UP TO *
*        FIVE CHARS OF PARM, RIGHT-PADDED WITH BLANKS, FOR LOOKUP.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APMSCAN  EQU   *                   BEGINNING OF SCAN FOR 1 PARM OPTION
         CLI   0(R6),C' '          SEARCH FOR NONBLANK
         BNE   *+8                 FOUND NONBLANK, EXIT LOOP
APMSCANX BXH   R6,R7,APFINC        BUMP SCAN PTR, GO TO CHECK FOR END
         SPACE 1
         SR    R2,R2               SHOW EXPECTED POSTIVE PARM
         AIF   (&$DEBUG).APND1     SKIP IF PRODUCTION
         XSNAP STORAGE=(*AJOPARMA,*AJIOFLAG),LABEL='APMSCAN',          X
               IF=(AJODEBUG,O,1,TM)         SNAP IF DEBUG ON
.APND1   ANOP
         CLC   0(2,R6),=C'NO'      IS PARM PRECEDED BY NO
         BNE   APMSCA              NO,SO SKIP,LEAVING R2 SET
         LA    R2,2                SET TO SHOW NO VALUE
         AR    R6,R2               ADD 2 TO SCAN PTR, BEYOND 'NO'
         SPACE 1
*              SEARCH FOR A POSSIBLE DELIMITER CHARACTRER (ALPHABETIC)
APMSCA   EQU   *
         LR    R15,R6              SAVE @ OF BEGINNING OF PARM
         CLI   0(R6),C'A'          IS IT A DELIMITER
         BL    *+8                 PROBABLY-BRANCH OUT
         BXH   R6,R7,*-8           LOOP UNTIL FIND (NOT BLANKS END PRM)
         SPACE 1
         LR    R1,R6               @ DELIMITER
         SR    R1,R15              R1 = LENGTH OF PARM
         BNP   APMSCANX            EXTRA DELIMITER-GO TO IGNORE IT
         SR    R1,R7               R1= LENGTH(PARM OPTION) - 1
         LA    R0,APCP$L-1         MAXIMUM POSSIBLE LENGTH-1 OF PARM
         CR    R1,R0               WAS PARM TOO LONG TO BE LEGAL ONE
         BH    APMSCANX            YES, SO IGNORE IT
*              **NOTE** COULD CHANGE ABOVE TO ALLOW TRUNC OF LONG PARMS
         STC   R1,APMSCMVC+1       STORE LENGTH-1 INTO MVC
         MVC   AJOCOMP,AJOBLANK    FILL PARM WITH BLANKS
APMSCMVC MVC   AJOCOMP($),0(R15)   MOVE OPTION IN, PAD WITH BLANKS
         AR    R6,R7               POSITION SCAN PTR BEYOND DELIMITER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       PARAMETER LOOKUP AND FLAGGING                 *
*        USING 1ST LETTER OF OPTION AS TABLE INDEX, SEARCH SECTION    *
*        OF LOOKUP TABLE FOR IT. IF NOT FOUND, IGNORE IT. IF FOUND,   *
*        USE BITS OF ITS APCFLAG TO DETERMINE HANDLING. IF THIS CALL  *
*        ACTUALLY SETS A VARIABLE, OR INTO ITS APCFLAG BIT(S) SHOWING *
*        WHAT TYPE CALL PRODUCED THIS VALUE, FOR LATER CHECKING.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         CLI   AJOCOMP,C'Z'        MAKE SURE CHARACTER OK (NOT DIGIT)
         BH    APFINC              BAD OPTION NAME-IGNORE IT
         IC    R9,AJOCOMP          GET FIRST LETTER OF OPTION
         LA    R5,B'00111100'      MASK FOR MIDDLE 4 BITS OF OPTION
         NR    R9,R5               MASK OUT ALL BUT MIDDLE BITS
         SRL   R9,1                SHIFT FOR HALFWORD INDEX VALUES
         LA    R3,APBPARMA         BEGINNING OF TABLE @
         AH    R3,APLNDX(R9)       = @ BEGINNING OF TABLE SECTION
         LA    R5,APBPARMA-APC$L   @ BEGINNING - 1 ELEMENT LENGTH
         AH    R5,APLNDX+2(R9)     = @ LAST POSSIBLE ELEMENT IN SECTION
*              AT THIS PT, R3 IS INDEX, AND R5 LIMIT FOR ENSUING BXLE
         SPACE 2
APLOOK   CLC   AJOCOMP,APCPARM     COMPARE NEW PARM WITH TABLE ENTRY
         BE    APFOUND             SKIP OUT IF FOUND
         BXLE  R3,R4,APLOOK        LOOP THRU TABLE
         B     APFINC              FELL THRU, NOT IN TABLE, IGNORE IT
         SPACE 1
APFOUND  EQU   *                   EXIT HERE WHEN PARM IDENTIFIED
         AIF   (&$DEBUG).APND2     SKIP IF PRODUCTION
         XSNAP LABEL='APFOUND',STORAGE=(*APCBLK,*APCBLK+8),            #
               IF=(AJODEBUG,O,1,TM)         SNAP FOUND BLOCK,IF DEBUG
.APND2   ANOP
APFLOCKT TM    APCFLAG,$           CAN THIS PARM BE SET BY CURRENT CALL
         BNO   APFNOSET            NO,SO IGNORE HIM
         IC    R9,APCAJOFS         GET OFFSET IN AJOBCON TO VARIABLE
*              IF PARM=DECIMAL #, CONVERT THE VALUE INTO R0.
         TM    APCFLAG,APCD        WAS THIS DECIMAL CONVERT
         BZ    *+8                 NO, SKIP CONVERT
         BAL   R14,APDECON         CALL ROUTINE TO SCAN, PUT VALU IN R0
*              IF VALUE NOT SET PREVIOUSLY, SKIP TO TEST FOR TYPE
         TM    APCLKSET,APCSET     HAS IT BEEN SET ALREADY BY ANYBODY
         BZ    APFTYPE             NO, SO SAFE TO DO IT THIS TIME
*              HAS ALREADY BEEN SET-CHECK IF CAN DO IT AGAIN.
         TM    APCFLAG,APCNRSET    IS IT ALLOWED TO BE RESET
         BO    APFNOSET            NOT ALLOWED TO RESET-SKIP OUT
         TM    APCLKSET,APCSETU+APCSETP     WAS IT SET BY $JOB
         BZ    APFDFSK             NO, SKIP CHECK FOR DEFAULT-OK TO SET
         TM    AJOAPMOD,AJOAPDEF   IS THIS DEFAULT TYPE CALL
         BO    APFNOSET            YES, JUMP OUT-DON'T OVERRIDE VALUE
APFDFSK  EQU   *
*              IF PARM IS YES/NO TYPE, GO TO RESET ITS VALUE
         TM    APCFLAG,APCYESNO    WAS IT YES/NO TYPE
         BO    APFYESNO            YES, SO GO PROCESS IT
         SPACE 1
*              ***** PARM=VALUE PROCESSING *****
         TM    APCFLAG,APCNINCR    SEE IF DECIMAL# AND CAN'T INCR
         BZ    APFCALL             ALLOWABLE TO CHANGE-GO SEE IF CALL
*              VARIABLE ALREADY SET AND NEW VALUE SUPPLIED.  VALUE
*              CAN BE RESET IF IT IS LESS THAN OR EQUAL OLD ONE.
         C     R0,AJO$APC(R9)      COMPARE (ASSUMES FULLWORD VALUE)
         BH    APFNOSET            TOO HIGH-IGNORE HIM
*              IF FLAGGED, CALL INDIVIDUAL PROCESSING ROUTINE.
*              THIS TAKES CARE OF SPECIAL CASES.
APFCALL  TM    APCFLAG,APCCALL     DOES PARM REQUIRE CALL
         BZ    APFSTORE            NO, SO JUST STORE VALUE(ASSUMED F)
         IC    R2,APCADDR          GET OFFSET @ OF ROUTINE
         LA    R14,APFSET          RETURN @ TO SHOW VALUE SET
         B     APAJUMP(R2)         GO TO THE ROUTINE INDICATED
*              **NOTE- ROUTINE WILL EXIT TO R14(SET) OR APFNOSET.
APFSTORE ST    R0,AJO$APC(R9)      STORE THE COMPUTED VALUE
         B     APFSET              GO TO FLAG THAT VALUE HAS BEEN SET
*              TYPE TEST - DEFINITELY LEGAL TO SET NEW VALUE.
APFTYPE  TM    APCFLAG,APCYESNO    WAS IT YES/NO TYPE PARM
         BZ    APFCALL             NO WAS = PARM OR SPECIAL-GO DO IT
*              ***** YES/NO PARM PROCESSING *****
*              AT THIS POINT R2=0 => YES VALUE, R2=2 => NO VALUE.
*              R9 = OFFSET FROM AJO$APC TO BYTE TO BE FLAGGED.
*              DETERMINE POLARITY OF FLAG BYTE AND SET ACCORDINGLY.
APFYESNO TM    APCFLAG,APCYES1B    DOES A YES VALUE => A BIT ON
         BO    *+6                 YES, SO LEAVE R2 AS IS/SKIP
         AR    R2,R7               NO. YES VALUE=> BIT OFF-INCREM R2
         LA    R14,AJO$APC(R9)     GET ACTUAL @ BYTE TO BE SET
         OC    0(1,R14),APCBITS    SET BIT(S) DEFINITELY ON
         IC    R2,APFYNTAB(R2)     GET THE BYTE FROM CONTROL TABLE
         LTR   R2,R2               MUST WE NOW RESET GIVEN BIT TO 0
         BNZ   *+10                NO, SKIP SINCE BIT SET TO 1 OK
         XC    0(1,R14),APCBITS    YES, MUST TURN BIT OFF TO BE RIGHT
         SPACE 1
*              ***** COMMON PARM VALUE SETTING EXITS *****
APFSET   EQU   *                   VALUE WAS ACTUALLY SET THIS TIME
         OC    APCLKSET,AJOAPSET   OR IN TO SHOW WHO ACTUALLY SET VALUE
APFNOSET EQU   *                   EXIT HERE IF NOT SET THIS TIME
APFINC   CR    R6,R10              HAVE WE REACHED END YET(R10=LIMIT @)
         BL    APMSCAN             NO,RETURN FOR NEXT PARM
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                       COMPLETION SECTION                            *
*        IF AJOAPMOD WAS FLAGGED WITH AJOAPFIN, THE CURRENT CALL TO   *
*        APARMS IS THE LAST BEFORE ASSEMBLY BEGINS. ANY OPTION NEEDING*
*        IT MAY THEN TEST THE SET BITS IN ITS APCFLAG TO DETERMINE    *
*        WHERE THE PARM CAME FROM WHICH ACTUALLY SET ITS VALUE.       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APFINE   EQU   *                   EXIT HERE AT END OF 1 COMPLETE SCAN
         TM    AJOAPMOD,AJOAPFIN   WAS THIS LAST CALL
         BZ    APNOTLST            NO, SO DON'T MAKE CHECKS
         AIF   (&$TIMER LT 2).APFNNT        SKIP IF NOT SPECIAL TIMER
         SPACE 1
*              FLAG AJOAPMOD IF USER ACTUALLY SUPPLIED T=.  IF HE DID
*              NOT, ASSIST WE USE TIMREM VALUE INSTEAD OF DEFAULT,
*              THUS ALLOWING MORE PRECISE CONTROL OVER TIME.
         TM    APBT+(APCLKSET-APCBLK),APCSETU+APCSETP VALUE FROM $J,PAR
         BZ    *+8                 NO,DON'T SET THE FLAG
         OI    AJOAPMOD,AJOAPUST   YES, USER ACTUALLY GAVE VALUE-NOTE
         SPACE 1
.APFNNT  AIF   (&$RECORD LT 2).APFNNR       SKIP IF NO SPECIAL RECORDS
         SPACE 1
*              FLAG AJOAPMOD IF USER ACTUALLY SUPPLIED R=. IF HE DID
*              NOT, WILL USE $TIRC RECREM FOR PRECISE RECORD COUNT.
         TM    APBR+(APCLKSET-APCBLK),APCSETU+APCSETP DID HE SET VALUE
         BZ    *+8                 NO, SKIP OVER
         OI    AJOAPMOD,AJOAPUSR   SHOW USER SET R= HIMSELF
.APFNNR  ANOP
         SPACE 2
         AIF   (NOT &$ACCT).APNCOM1         SKIP IF NO ACCOUNT DISCRIM
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              ACCOUNT NUMBER CHECKING                                *
*        THE FOLLOWING CODE CAN BE USED TO SET DIFFERENT OPTIONS      *
*   DEPENDING ON THE ACCOUNT NUMBER OF THE JOB.  AS OF 03/01/71,      *
*   THE ONLY DISCRIMINATION PRESENT IS TO REQUIRE COMMENT CHECKING    *
*   CERTAIN ACCOUNTS, I.E., INTRODUCTORY COURSES.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $TIRC (NAME,AJOACCT)      GET ACCOUNTING INFO
         LA    R0,L'AJOACCT        INCREMENT FOR BXLE
         LA    R1,APXCOMLB         @ LAST ENTRY IN TABLE FOR LIMIT BXLE
         LA    R2,APXCOMLA         START OF ACCT# TABLE FOR INDEX BXLE
         SPACE 1
*              SEARCH TABLE FOR ACCOUNT NUMBER.
         CLC   AJOACCT,0(R2)       IS THIS THE ONE
         BE    APXCOMFN            YES, JUMP OUT OF LOOP
         BXLE  R2,R0,*-10          LOOP UNTIL END OF TABLE
         B     APXCOMXT            NOT FOUND - IGNORE IT
APXCOMFN OI    AJOASMF2,AJOCOMNT   COMMENT CHECKING NOW IN EFFECT
         SPACE 1
APXCOMXT EQU   *                   EXIT POINT FROM ACCT# CHECKING
*              CHECK FOR CERTAIN NAME TO ALLOW SPECIAL DEBUGGING.
         AIF   (NOT &$JRM).APNCOM1 SKIP IF NOT ANY SPECIAL JRM CODE
         CLC   =C'MASHEY J ',AJOPRGNM       CHECK FOR NAME, SPECIAL OPT
         BNE   APNOTJRM            NO, NOT NAME, SO SKIP
         CLC   AJOACCT,APACCJRM    IS ACCOUNT CURRENT ONE
         BNE   APNOTJRM            NO, IT ISN'T, SKIP
         OI    AJODMPF,$EC$JRM     SET FLAG TO MAKE EXECUT DO EXTRA
APNOTJRM EQU   *                   SKIP HERE IF NOT SPECIAL DEBUG
.APNCOM1 ANOP
APNOTLST EQU   *                   EXIT HERE UNLESS LAST CALL TO AP
APRET    $RETURN RGS=(R14-R12),SA=NO
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: APDECON    CONVERT DECIMAL PARM VALUE                     *
*        ENTRY CONDITIONS                                             *
*   R6 = SCAN PTR TO 1ST CHARACTER OF DECIMAL #                       *
*   R14= RETURN @ TO CALLING SECTION OF APARMS                        *
*        EXIT CONDITIONS                                              *
*   R0 = CONVERTED RESULT OF DECIMAL #, =0 IF THERE WERE NO NUMBERS   *
*   R6 = SCAN POINTER TO 1ST NON-DECIMAL DIGIT FOUND                  *
*        THIS ROUTINE MODIFIES REGS R0,R1,R6                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
APDECON  LR    R1,R6               SAVE INIT SCAN POINTER
         SR    R0,R0               SET DEFAULT AMOUNT
         XDECI R0,0(R6)            SCAN AND CONVERT VALUE
         LR    R6,R1               MOVE SCAN PTR @ OVER INTO PTR REG
         BR    R14                 RETURN TO CALLING SECTION OF CODE
         EJECT
* * * * * INDIVIDUAL PARAMETER FIELD ANALYSIS SECTIONS.               *
*        ALL LABELS ARE OF FORM APA$$$$$ WHERE $$$$$ IS PARAMETER NAME*
APAJUMP  EQU   *                   BASE @ FOR PARM ROUTINES
         SPACE 3
*              PARM=VALUE TYPE PARAMETERS                             *
         SPACE 1
         AIF   (NOT &$ACCT).APNACCT         SKIP IF NO ACCT DISCRIMINAT
APAACCT  BR    R14                 ACCT NUMBER OPTION *****FUTURE USE**
.APNACCT ANOP
         SPACE 1
APADUMP  MVI   AJODMPF,$ECREGS+$ECDINST+$ECSTORG DEFAULT DUMP FLAGS
         LTR   R0,R0               WAS VALUE 0 (LEAVE DEFAULT OK)
         BCR   Z,R14               YES, SO LEAVE FLAG THERE
         NI    AJODMPF,255-$ECSTORG         JUST SMALL DUMP,REMV FLAG
         BR    R14                 RETURN
         SPACE 1
         AIF   (&$DEBUG).APNDEBG   SKIP IF DEBUG NOT MODE
APADEBUG STC   R0,AJODEBUG         STORE VALUE IN DEBUG FLAG
         BR    R14                 RETURN
         SPACE 1
.APNDEBG ANOP
         SPACE 2
         AIF   (NOT &$MACROS).APNMAC        SKIP IF NO MACRO STUFF
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              *** SCANNING CODE FOR MACRO=  PARM.                    *
*        POSSIBLE OPTIONS ARE AS FOLLOWS:                             *
*        MACRO=N                   NO MACROS (ASSUMED IF IN ERROR)    *
*        MACRO=F                   F-LEVEL MACRO (BASIC REQUEST)      *
*        MACRO=G                   ADD G-LEVEL FEATURES               *
*        MACRO=H                   ADD H-LEVEL FEATURES               *
*        **NOTE** THE BASIC FACILITY IS THE F-LEVEL COMPATIBLE ONE.   *
*        SOME OF THESE OPTIONS MAY NOT BE SUPPORTED, AND IN ANY CASE, *
*        CODE FOR THEM IS ALL CONDITIONAL.                            *
*        SEE SET VARIABLES BEGINNING &$MACRO- .                       *
*        ** SETS BITS IN AJOASMFM, SEE FLAGS AT BEGINNING OF AJOBCON. *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APAMACRO EQU   *                   CODE FOR MACRO=
*              FOLLOWING STMT MAKES ASSUMPTION OF  MACRO=N.
         NI    AJOASMFM,(255-AJOMACRO-AJOMACRG-AJOMACRH) SET MACRO=N
         SR    R2,R2               CLEAR, WILL BE INDEX TO TABLE
         CLI   0(R6),C'F'          WAS IT MACRO=F
         BE    APAMACR1            YES, SKIP, LEAVE R2=0
         AR    R2,R7               SET R2=1
         CLI   0(R6),C'G'          WAS IT G
         BE    APAMACR1            YES, BRANCH, LEAVE R2=1
         AR    R2,R7               SET R2=2
         CLI   0(R6),C'H'          WAS IT MACRO = H
         BNE   APAMACRZ            NO, MUST BE MACRO=N, OR ERROR-SKIP
APAMACR1 LA    R2,APAMACRT(R2)     GET @ FLAG BYTE FOR ACTUAL LEVEL
         OC    AJOASMFM(1),0(R2)   OR APPRORPIATE BITS INTO FLAG
APAMACRZ BXH   R6,R7,APFSET        BUMPSCAN PTR, GO TO SHOW SET
*              AJOASMFM FLAG BYTES FOR MACRO= F, G, H .
APAMACRT DC    AL1(AJOMACRO,AJOMACRO+AJOMACRG,AJOMACRO+AJOMACRH,0)
         DS    0H                  MUST BE HALF ALIGNED (NOTE 0 ABOVE)
.APNMAC  ANOP
         SPACE 1
         AIF   (NOT &$KP26).APKP29X         SKIP IF NO 026 KEYPUNCH
APAKP    EQU   *                   KP=26 OR KP=29.  29 DEFAULT
*              ANYTHING BUT KP=26 TREATED AS KP=29.
         NI    AJIOSO,255-AJIOKP26 RESET TO DEFAULT KP=029
         LA    R1,26               VALUE FOR COMPARE
         CR    R0,R1               WAS KP=26 SPECIFIED
         BCR   NE,R14              NO, VALUE SET RIGHT, RETURN
         OI    AJIOSO,AJIOKP26     SHOW 026 KEYPUNCH
         BR    R14                 RETURN, GO TO APFSET
.APKP29X ANOP
         SPACE 1
         AIF   (&$TIMER EQ 0).APNOT         SKIP IF NO TIMING
*              ***** SCANNING/CONVERSION FOR T=, TD=, TX= *****       *
*              THE FOLLOWING CODE ALLOWS THESE PARMS TO SPECIFY       *
*        FRACTIONAL PARTS OF A SECOND.  IT SCANS THE FRACTIONAL PART  *
*        IF ANY AND CONVERTS THE VALUE INTO TIMER UNITS (26.04 MICSEC *
*        AND STORES IT IN APPROPRIATE LOCATION.  IT ACCEPTS UP TO 3   *
*        FRACTIONAL DIGITS (I.E., MILLISECONDS).                      *
         SPACE 1
APAT     EQU   *
APATD    EQU   *
APATX    EQU   *
         LR    R1,R0               MOVE # SECONDS ON PARM OVER
         M     R0,AJ1000           *1000 = # MILLISECONDS
         CLI   0(R6),C'.'          DID HE SPECIFY FRACTION
         BNE   APTINT              NO,JUST INTERGER-SKIP
         LR    R2,R1               MOVE MILLISEC # OVER FOR SAFETY
         AR    R6,R7               BUMP SCAN PTR BEYOND .
         LR    R5,R6               SAVE @ 1ST FRAFTION DIGIT
         BAL   R14,APDECON         CALL CONVERTER FOR SCANNING
         SR    R5,R6               GET # DIGITS
         AH    R5,=H'4'            ADD LIMIT+1 TO GET 3-1 OF MULTS
         BNP   APTIGNOR            IF MORE THAN 3 DIGITS-IGNORE IT
         SPACE 1
         LR    R1,R0               MOVE VALUE OF FRACTION
         LA    R15,10              VALUE FOR MULTIPLY
         BAL   R14,*+6             SET REG,SKIP OVER MULT & INTO LOOP
         MR    R0,R15              CONVERT*10
         BCTR  R5,R14              LOOP.    END WITH # MILLISEC IN R1
         AR    R2,R1               ADD TO PREVIOUSLY SAVED # MILLISEC
APTIGNOR LR    R1,R2               MOVE VALUE BACK TO R1
         SPACE 1
*              AT THIS PT, R1=# MILLISECONDS SPECIFIED
APTINT   EQU   *
         M     R0,AJ100000         GET 100*# MICROSECONDS
         D     R0,AJ2604           / BY 100# MICRO SEC IN A TIMER UNIT
*              AT THIS PT R1 = # TIMER UNITS IN INTERVAL
         LR    R0,R1               MOVE OVER FOR LATER STORE
         TM    APCLKSET,APCSET     HAS IT BEEN SET BY ANYONE
         BZ    APFSTORE            NO, DEFINITELY SAFE TO STORE-GO
         TM    APCLKSET,APCSETU+APCSETP     SET BY USER
         BZ    *+12                NO, SKIP DEFAUL TEST
         TM    AJOAPMOD,AJOAPDEF   IS IT DEFAUL T CALL
         BO    APFNOSET            YES, ALREADY SET-DON'T OVERRRIDE
         SPACE 1
         C     R0,AJO$APC(R9)      COMPARE TO PREVIOUS VALUE
         BH    APFNOSET            TOO-HIGH-IGNORE HIM
         B     APFSTORE            OK-GOTO STORE VALUE
.APNOT   ANOP
           AIF   (NOT &$XREF).NOXREF5                                 A
        SPACE 3
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* THIS ROUTINE IS THE CROSS REFERENCE OPTION SCANNING ROUTINE         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APAXREF  EQU   *
         IC    R0,AJOXREF         GET FLAG IN                         A
         LR    R2,R0              MOVE FLAG TO R0,R1,R2               A
         LR    R1,R2
         N     R0,APXRB3          GET RIGHT BITS SET                  A
         N     R1,APXRB2
         N     R2,APXRB1                                              A
         LR    R12,R6             GET POINTER TO PARM FIELD           A
         CLI   0(R12),C'('        SEE IF LIST OF VALUES               A
         BNE   APXRXRO            PROCESS FIRST ONLY                  A
         AR    R12,R7             BUMP PAST "("                       A
         CNOP  0,4                MAKE SURE OF PROPER ALIGNMENT       A
         BAL   R14,APXRCHK        CHECK FOR PROPER DELIMETER          A
         DC    A(APXRSD)          WHERE TO GO IF OMITTED              A
         BAL   R14,APXRSET        SET  VALUE INTO PROPER REGISTER     A
         SLL   R15,4              MOVE TO RIGHT POSITION              A
         LR    R0,R15             MOVE TO CORRECT REGISTER
         AR    R12,R7             BUMP TO NEXT CHARACTER              A
APXRSD   EQU   *                  CHECK FOR VALUES IN SD=
         AR    R12,R7             BUMP PAST VALUE                     A
         CNOP  0,4                MAKE SURE OF ALIGNMENT              A
         BAL   R14,APXRCHK        CHECK PROPER DELIMITER              A
         DC    A(APXRSR)          ADDRESS TO GO TO IF USING DEFAULTS
         BAL   R14,APXRSET        SET CORRECT VALUE                   A
         SLL   R15,2              MOVE TO CORRECT POSITION            A
         LR    R1,R15             MOVE TO RIGHT REG                   A
         AR    R12,R7             BUMP TO NEXT CHARACTER              A
APXRSR   EQU   *                  DO SR= DEFAULT                      A
         AR    R12,R7             BUMP POINTER                        A
         CLI   0(R12),C')'        WAS IT OMITTED                      A
         BE    APXRADD            YES, DO ADD                         A
         CLI   1(R12),C')'        PROPER DELIMITER                    A
         BNE   APXRFIN            NO, BAG IT                          A
         BAL   R14,APXRSET        GET NUMBER IN REG                   A
         LR    R2,R15             MOVE TO RIGHT REG                   A
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
* THIS SECTION ADDS THE REGISTERS R0,R1,R2.  THESE REGISTERS HAVE THE *
* CORRECT VALUES IN THEM EITHER BY THE DEFAULT VALUES OR BY SETTING   *
* A FLAG WITH THE XREF= OPTION.                                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APXRADD  EQU   *                                                      A
         AR    R1,R0              COLLECT XREF AND SD VALUES          A
         AR    R2,R1              COLLECT ALL                         A
         STC   R2,AJOXREF         SET ACTUAL FLAG                     A
APXRRET  EQU   *                                                      A
         LA    R6,1(R12)          SET PROPER DELIMITER                A
         B     APFSET             SHOW VALUE SET                      A
APXRXRO  BAL   R14,APXRSET        GET NUMBER                          A
         SLL   R15,4              MOVE TO RIGHT POSITION              A
         LR    R0,R15             MOVE TO RIGHT REGS                  A
         B     APXRADD            SET ACTUAL XREF FLAG                A
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->INSUB: APXRSET   CONVERT NUMBER TO INTERNAL FORM                  *
*     CONVERTS XREF PARM NUMBERS AND CHECKS TO SEE IF THEY'RE IN THE  *
*     RANGE 0-3.                                                      *
*     ENTRY CONDITIONS                                                *
*   R12= POINTER TO NUMBER TO BE CONVERTED                            *
*     EXIT CONDITIONS                                                 *
*   R15= CONVERTED NUMBER                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APXRSET  EQU   *                  INSUB TO SET VALUE IN REGISTER 15   A
         MVC   APXRWORK+7(1),0(R12)    MOVE NUMBER TO WORK AREA       A
         PACK  APXRWORK(8),APXRWORK                                   A
         CVB   R15,APXRWORK       CONVERT NUMBER TO INTERNAL FORM     A
         C     R15,=X'00000003'   SEE IF TOO BIG                      A
         BH    APXRFIN            DENOTE ERROR                        A
         BR    R14                RETURN                              A
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->INSUB: APXRCHK   CKECK FOR VALID DELIMITER                        *
*     CHECKS FOR ',' IN XREF=(A,B,C) PARM FIELD.  SPECIAL RETURN      *
*     FOR XREF=(A).                                                   *
*     ENTRY CONDITIONS                                                *
*   R12= POINTER OF NEXT CHARACTER                                    *
*     EXIT CONDITIONS                                                 *
*   R14= @ OF ROUTINE TO BRANCH TO                                    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
APXRCHK  EQU   *                                                      A
         CLI   0(R12),C','        WAS NEXT OPERAND OMITTED?           A
         BE    APXRNXT            YES: DO NEXT SECTION
         CLI   1(R12),C','        PROPER DELIMITER?                   A
         BNE   APXRFIN            NO: GO TO ERROR                     A
         B     4(R14) GO BAVK                                         A
APXRNXT  L     R14,0(R14)         GET ADDRESS
         BR    R14                GO TO ROUTINE
APXRFIN  EQU   *
         LR    R6,R12             GET @ BACK IN R6
         B     APFNOSET           ERROR FOUND: SHOW NOT SET           A
APXRB1   DC    A(3)               MASK OUT ALL BUT LOWER BITS         A
APXRB2   DC    A(12)              MIDDLE BITS                         A
APXRB3   DC    A(48)              TOP BITS                            A
APXRWORK DC    D'0'               WORK AREA                           A
.NOXREF5 ANOP
*              TABLE OF APCBLKS FOR PARM FIELD ANALYSIS               *
APBPARMA DS    0D                  DEFINE BEGINNING SYMBOL, ALIGN
APLAC    EQU   *                   PARMS A-C
         APCGN ACCT,AJOACCT,0,C=1,G=&$ACCT
         AIF   (&$S370 NE 2).APNALGN    SKIP IF NO S/370 SIMULATION
         APCGN ALGN,AJOEXEF,AJONALGN,Y=1
.APNALGN ANOP
         APCGN BATCH,AJOMODE,AJOBATCH,I1=1,Y=1,LK=110
         APCGN CMPRS,AJOASMF2,AJOCMPRS,I1=1,Y=1,G=&$CMPRS
         APCGN COMNT,AJOASMF2,AJOCOMNT,I1=1,Y=1,G=&$COMNT,LK=110
         APCGN CPAGE,AJIOPR,AJIOPAGE,I1=1,Y=1,G=&$PAGE,LK=110
APLDG    EQU   *                   PARMS D-G
         APCGN DATA,AJIORE,AJIODFLT,Y=1,G=&$DATARD,LK=110
         APCGN DEBUG,AJODEBUG,C=1,D=1,G=&$DEBUG,GC=1
         APCGN DECK,AJOASMF2,AJODECK,Y=1,I1=1,G=&$DECK
         APCGN DISKU,AJOASMF,AJODISKU,G=&$DISKU,Y=1,I1=1
         APCGN DUMP,AJODMPF,C=1,D=1
         APCGN FREE,AJOFREE,0,D=1,LK=110
APLHI    EQU   *                   PARMS H-I
         APCGN I,AJOINSL,0,D=1,I1=1
         APCGN IECF,AJOIECF,0,D=1,G=&$EXINT   IECF OF EXT'D INTPRTR
APLJL    EQU   *                   PARMS J-L, GAP
         APCGN KP,AJIOSO,C=1,D=1,G=&$KP26
         APCGN L,AJOL,0,D=1,I1=1,G=&$PAGE
         APCGN LIBMC,AJOASMFM,AJOLIBMC,I1=1,Y=1,G=&$MACROS  PRT LIB MCS
         APCGN LIST,AJOASMF,AJNLIST,Y=1
         APCGN LOAD,AJOASMF,AJNLOAD,Y=1
APLMP    EQU   *                   PARMS M-P
         APCGN MACRO,AJOASMFM,C=1,G=&$MACROS          MACRO LEVEL
         APCGN MACTR,AJOMACTR,0,D=1,G=&$MACROS        MACRO ACTR
         APCGN MNEST,AJOMNEST,0,D=1,G=&$MACROS        MACRO NEST LIMIT
         APCGN MSTMG,AJOMSTMG,0,D=1,G=&$MACROS        MACRO STMT LIMIT
         APCGN MONIT,AJOMODE,AJOMONIT,I1=1,Y=1,LK=110
         APCGN NERR,AJONERRF,0,D=1
         APCGN OBJIN,AJODECKF,AJOOBJIN,Y=1,I1=1,G=&$OBJIN
         APCGN P,AJOP,0,D=1,I1=1,G=&$PAGE
APBPD    APCGN PD,AJOPD,0,D=1,I1=1,G=&$PAGE
         APCGN PUNCH,AJIOPN,AJIODFLT,Y=1,G=&$PUNCH,LK=110
APBPX    APCGN PX,AJOPX,0,D=1,I1=1,G=&$PAGE
APLQR    EQU   *                   PARMS Q-R, GAP
APBR     APCGN R,AJORECL,0,D=1,I1=1
APBRD    APCGN RD,AJORD,0,D=1,I1=1
         APCGN RELOC,AJOASMF,AJORELOC,I1=1,Y=1,G=&$RELOC
         APCGN REPL,AJOMODE,AJOREPLF,I1=1,Y=1,G=&$REPL
         APCGN RFLAG,AJORFLAF,0,D=1,G=&$REPL
APBRX    APCGN RX,AJORX,0,D=1,I1=1
APLST    EQU   *                   PARMS S-T
         APCGN SS,AJIOSS,AJIOSING,I1=1,Y=1,G=&$PAGE
         APCGN SSD,AJIOSSD,AJIOSING,I1=1,Y=1,G=&$PAGE
         APCGN SSX,AJIOSSX,AJIOSING,I1=1,Y=1,G=&$PAGE
         APCGN SUPER,AJOEXEF,AJOSUPER,I1=1,Y=1,G=&$PRIVOP
         APCGN SYSIN,AJOMODE,AJNSYSIN,Y=1,G=&$DATARD,LK=110
APBT     APCGN T,AJOTIML,D=1,I1=1,G=&$TIMER,C=1
         APCGN TD,AJOTD,D=1,I1=1,G=&$TIMER,C=1
APBTX    APCGN TX,AJOTX,D=1,I1=1,G=&$TIMER,C=1
APLUX    EQU   *                   PARMS U-X
         APCGN XREF,AJOXREF,C=1,G=&$XREF                              A
APLYZ    EQU   *                   PARMS Y-Z
APBPARMB EQU   *                   LIMIT OF APCGN'D TABLE
         SPACE 2
*              PARM TABLE LOOKUP INDEX - APLNDX
*              GIVES OFFSETS TO BEGINNING OF EACH SECTION OF TABLE,
*              DETERMINED BY INITIAL LETTER
*              DETERMINED BY MIDDLE 4 BITS OF 1ST BYTE OF OPTION NAME.
APLNDX   $AL2  APBPARMA,(APLAC,APLDG,APLHI,APLJL,APLJL,APLMP,APLQR,    #
               APLST,APLST,APLUX,APLYZ,APBPARMB)
         AIF   (NOT &$ACCT).APNCOM2         SKIP IF NO ACCT# CHECKING
         SPACE 1
*              TABLE OF ACCOUNT NUMBERS RECEIVING SPECIAL TREATMENT.
APXCOMLA EQU   *                   BEGINNING OF TABLE
         DC    5CL5'ACCT#'         DUMMIES, TO BE FIXED IN OBJ DECK
APACCJRM DC    C'C3338'            CURRENT ACCT# FOR TESTING PURPOSES
APXCOMLB EQU   *-L'AJOACCT         @ LAST 1 IN TABLE
         SPACE 1
.APNCOM2 ANOP
         SPACE 1
*              TABLE TO DETERMINE WHETHER YES/NO PARM SHOULD HAVE ITS
*              VARIABLE BYTE BITS SET TO 1'S OR 0'S.
APFYNTAB DS    0BL4                YES/NO BIT SETTING CONTROL TABLE
         DC    B'1'                YES PARM,YES1B ==> BIT = 1
         DC    B'0'                YES PARM, YES1B ==> BIT  = 0
         DC    B'0'                NO PARM, YES1B ==> BIT = 0
         DC    B'1'                NO PARM, YES1B ==> BIT = 1
         LTORG
         DROP  R3,R8,R11           KILL ALL USINGS
         AIF   (NOT (&$DECK OR &$OBJIN)).AOBNONE      SKIP IF NO DECKS
         TITLE 'AOBJCARD DSECT : OBJECT DECK CARDIMAGE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AOBJCARD   IMAGE OF OBJECT DECK CARD                      *
*        THIS DSECT DESCRIBES 1 CARD OF AN ASSIST OBJECT DECK.  THE   *
*   DECK FORMAT IS COMPATIBLE WITH NORMAL S/360 OBJECT DECKS, SO THAT *
*   THEY CAN BE USED UNDER SOME CIRCUMSTANCES.    THEY ARE HOWEVER    *
*   SIMPLER, IN ORDER TO ALLOW FOR PRODUCTION OF THEM FROM STUDENT-   *
*   COMPILERS, I.E. XPL.  LATER VERSIONS OF THE LOADER MAY PERMIT     *
*   MORE COMPLEX OBJECT DECKS, BUT AS OF 9/01/71, THE ONLY TYPES OF   *
*   OBJECT DECK CARDS RECOGNIZED ARE TXT AND END CARDS.               *
*        NAMES: AO------                                              *
*        REFERENCE: ASSEMBLER(F) PROGRAMMER'S GUIDE - GC26-3756-4     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
AOBJCARD DSECT
         SPACE 1
*              ***** COMMON BASE BEGINNING *****
         DS    X'02'               1     (S/360) - ASSIST IGNORES
AOBJTYPE DS    CL3                 2-4   TYPE OF CARD
         SPACE 1
*              ***** ESD CARD LAYOUT *****
********************    NOT CURRENTLY IMPLEMENTED   *******************
         SPACE 1
*              ***** TXT CARD LAYOUT *****
         ORG   AOBJTYPE            BACK UP TO SHOW LAYOUT
         DS    CL3'TXT'            2-4   TEXT CARD IDENTIFIACTION
AOTADDR  DS    0A,C' '             5     ASSIST IGNORES 1ST BYTE
AOTADDRT DS    AL3                 6-8   @ WHERE OBJECT CODE GOES
         DS    CL2' '              9-10  ASSIST IGNORES THESE COLS
AOTLENG  DS    0H,C                11-12 LENGTH OF CODE ON CARD
AOTLENG2 DS    AL1                 12    LENGTH USED BY ASSIST 0-56
         DS    CL4' '              13-16 IGNORED *****FUTURE USE ******
AOTCODE  DS    CL56                17-72 OBJECT CODE 0-56 BYTES OF IT
AOTSEQN  DS    CL8                 73-78 SEQUENCE NUMBER, IGNORED
         SPACE 1
*              ***** RLD CARD LAYOUT *****
********************    NOT CURRENTLY IMPLEMENTED   *******************
         SPACE 1
*              ***** END CARD LAYOUT *****
         ORG   AOBJTYPE            BACK TO SHOW TYPE
         DS    CL3'END'            2-4   END CARD FLAG
AOEBLNK  EQU   *                   BEGINNING OF BLANK AREA
AOENTRY  DS    0A,C' '             5     ASSIST IGNORES LEADING BLANK
AOENTRY2 DS    AL3                 6-8   GIVES ENTRY @, UNLESS BLANK
AOEBLNKL EQU   72-(*-AOBJCARD)     LENGTH TO BE BLANKED
         TITLE 'AOBJDK CSECT - OBJECT DECK PUNCH/LOAD'
AOBJDK   CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: AOBJDK     OBJECT DECK HANDLING MODULE                    *
*                                  JOHN R. MASHEY - 09/01/71          *
*        THE TWO ENTRIES OF AOBJDK ARE USED TO LOAD OR PUNCH OBJECT   *
*   DECKS WHICH ARE SUBSETS OF NORMAL S/360 DECKS.   THE TWO ENTRIES  *
*   MAY OR MAY NOT EXIST, DEPENDING ON FLAGS &$DECK AND &$OBJIN.      *
*        USES DSECTS: AOBJCARD,AVWXTABL                               *
*        USES MACROS: $RETURN,$SAVE                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         $DBG  ,NO                 NO DEBUG IN $SAVE,$RETURN
         EJECT
         AIF   (NOT &$OBJIN).AOBJN1         SKIP IF NO OBJECT INPUT
         ENTRY AOBJIN
AOBJIN   $SAVE RGS=(R14-R12),SA=NO,BR=R6
         USING AVWXTABL,RAT        NOTE ASSEMBLER CONTROL TABLE
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: AOBJIN     LOAD OBJECT DECK                               *
*        ENTRY CONDITIONS                                             *
*   R12(RAT) = @ ASSEMBLER CONTROL TABLE (AVWXTABL).                  *
*        EXIT CONDITIONS                                              *
*   AVRADL,AVRADH,AVRELOC,AVFENTER,AVLOCLOW,AVLOCHIH  ARE SET UP      *
*   AS THEY WOULD HAVE BEEN HAD THE PROGRAM BEEN ASSEMBLED.           *
*   AVTAGS1    IS FLAGGED WITH AJNLOAD IF SOME ERROR OCCURRED.        *
*        NAMES: AOB-----                                              *
*        USES MACROS: $PRNT,$RETURN,$SAVE,$SORC,XSNAP                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * REGISTER USAGE FOR AOBJIN * * * * * * * * * * * * * * *
*   R0,R1      WORK REGISTERS.  R1 USED FOR ADDRESS CALCULATIONS.     *
*   R2 = LOWEST REAL @ LOADED CODE. INIT=AVADDLOW. INTO AVRADL.       *
*   R3 = @+1 OF HIGHEST LOADED CODE. INIT=AVADDLOW.  INTO AVRADH.     *
*   R4 = LOAD RELOCATION FACTOR. = AVADDLOW - (1ST TXT @ FOUND).      *
*   R5 = USER ENTRYPOINT @ (FAKE).  TO BE STORED INTO AVFENTER.       *
*   R6 = BASE REGISTER                                                *
*   R7 = ADDRESS OF OBJECT CARD IMAGE (AOBJCARD DSECT).               *
*   R8 = BYTE REGISTER (USED FOR INSERT OF LENGTH FROM AOTLENG2)      *
*   R9 = @+1 OF HIGHEST USABLE BYTE FOR PROGRAM.  = AVADDHIH.         *
*   R10,R11    UNUSED                                                 *
*   R12(RAT)= @ AVWXTABL CONTROL BLOCK                                *
*   R13= @ CALLING PROGRAM'S SAVE AREA.                               *
*   R14= INTERNAL LINK REGISTER, WORK REGISTER.                       *
*   R15= WORK REGISTER                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              OBJECT LOAD INITIALIZATION.                            *
*        1. FILL OBJECT AREA (AVADDLOW-AVADDHIH) WITH FILL CHARS.     *
*        2. SET UP INITIAL VALUES FOR @'S IN REGISTERS.               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LM    R8,R9,AVADDLOW      AVADDLOW-AVADDHIH - CORE LIMITS
         LA    R7,31(,R8)          * ALIGN ACTUAL BEGINNING @
         SRL   R7,5                * TO MULTIPLE OF 32.
         SLL   R7,5                * THIS IS REQUIRED BY XXXXSNAP
         ST    R7,AVADDLOW         * STORE ALIGNED VALUE BACK
         LA    R8,32               # BYTES TO BE FILLED WITH 1 STM
         SR    R9,R8               SUBTRACT 32 FOR BXLE USE
         SR    R9,R8               -32 MORE FOR COMPLETE SAFETY
         BXH   R7,R8,AOBINTA       MAKE SURE AT LEAST 32 BYTES
         SPACE 1
         SR    R7,R8               BACK UP TO  BEGINNING FOR SAFETY
         MVI   0(R7),$PRGFILC      PUT IN FILL CHARACTER
         MVC   1(31,R7),0(R7)      PROPAGATE FILL CHARACTER
         LM    R14,R5,0(R7)        GET 8 REGS WORTH OF FILL CHARACTER
         SPACE 1
         STM   R14,R5,0(R7)        STORE 32 BYTES OF FILL CHARACTER
         BXLE  R7,R8,*-4           LOOP TO FILL WHOLE AREA
         SPACE 1
AOBINTA  LM    R8,R9,AVADDLOW      AVADDLOW-AVADDHIH - LIMIT @'S
         LR    R2,R8               R2= INIT VALUE LOWEST REAL(AVRADL)
         LR    R3,R2               R3= INIT VALUE HIGHEST LIMIT(RADH)
         SR    R5,R5               INIT ENTRY @ TO 0 (BEGINNING OF CD)
         NI    AVTAGS1,255-AVOENTR-AVO1TXT  SHOW NO TXT, ENTRY @ FOUND
         LA    R7,AVCONCAT         USE THIS AS WORKAREA FOR AOBJCARD
         USING AOBJCARD,R7         NOTE DSECT
         SR    R8,R8               CLEAR R8 AS BYTE REGISTER FOR INSERT
         SPACE 1
*              PRINT HEADER MESSAGE AL000.
         BAL   R14,AOBHEXCO        CONVERT VALUES TO HEX FOR PRINT
         DC    H'2'                # ITEMS IN FOLLOWING LIST
         DC    AL2(AVADDLOW-AVWXTABL,AOB000A-AOB)     REAL @ START
         DC    AL2(AVADDHIH-AVWXTABL,AOB000B-AOB)     REAL LIMIT
         BAL   R14,AOBPRINT        GO PRINT COMPLETED MESSAGE
         DC    AL2(AOB000-AOB,AOB000L)      @ OFFSET, LENGTH
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              READ OBJECT DECK AND LOAD LOOP HEAD                    *
*        READ 1 CARD OF OBJECT DECK, UNTIL EOF FOUND. DETERMINE TYPE  *
*   OF CARD, BRANCH TO PROCESSING SECTION, RETURN FOR NEXT CARD.      *
*   **NOTE** AS OF 9/01/71, WILL PROCESS ONLY TXT AND END CARDS, THUS *
*   SECTIONS OF CODE COMMENTED OUT ARE TO INDICATE POSSIBLE EXTENSIONS*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBREAD  EQU   *                   ENTRY LABEL FOR 1 CARD PROCESS
         $SORC AOBJCARD,80,AOBJEOF READ UNTIL END-FILE
         CLC   AOBJTYPE,=C'TXT'    WAS IT TEXT CARD (MOST LIKELY)
         BE    AOBTXT              YES (NOTE WE IGNORE COL 1 OF CARD)
         CLC   AOBJTYPE,=C'END'    WAS IT END CARD
         BE    AOBEND              YES, GO THERE TO PROCESS IT
*****    CLC   AOBJTYPE,=C'RLD'    WAS IT RLD
*****    BE    AOBRLD              YES, GO THERE
*****    CLC   AOBJTYPE,=C'ESD'    WAS IT ESD CARD
*****    BE    AOBESD              YES, GO THERE
*****    IF DESIRED, INSERT COUNTER HERE FOR UNKNOWN TYPES OF CARDS.
         B     AOBREAD             UNKNOWN TYPE OF CARD-IGNORE IT
         SPACE 1
*        ***** PROCESSING CODE FOR INDIVIDUAL TYPES OF CARDS *****
         SPACE 2
*              ***** END CARD(S) *****
*              SETS R5 = ENTRY @, IF:  1) A PREVIOUS END CARD HAS     *
*              NOT ALREADY SPECIFIED ONE, AND 2) ONE IS GIVEN ON THIS *
*              END CARD.                                              *
AOBEND   EQU   *
         TM    AVTAGS1,AVOENTR     HAS ONE BEEN SPECIFIED ALREADY
         BO    AOBREAD             YES, SO DON'T DO IT AGAIN
         CLC   AOENTRY2,AWBLANK+1  WAS ENTRY POINT BLANK
         BE    AOBREAD             YES, SO IGNORE IT
         L     R5,AOENTRY          GET FULLWORD CONTAINING ENTRY @
         LA    R5,0(,R5)           REMOVE LEADING BYTE
         OI    AVTAGS1,AVOENTR     SHOW ENTRY @  FOUND, SO WONT DO AGAN
         B     AOBREAD             GO BACK FOR MORE (IF ANY)
         SPACE 2
*              ***** ESD CARD(S) *****                                *
*AOBESD  EQU   *                   EXTERNAL SYMBOL DICTIONARY
         SPACE 2
*              ***** RLD CARD(S) *****                                *
*AOBRLD  EQU   *                   RELOCATION DICTIONARY
         EJECT
*              ***** TXT CARD(S) *****                                *
*              MOVE TEXT CODE FROM CARDIMAGE INTO MEMORY.             *
*              COMPUTE RELOCATION FACTOR FROM FIRST TEXT CARD FOUND.  *
*              MAINTAIN HIGH LIMIT FOR ACTUAL OBJECT CODE, AND MAKE   *
*              SURE CODE DOES NOT EXCEED HIGH LIMIT, OR GO BELOW      *
*              THE LOW LIMIT (AFTER FIRST TEXT CARD).                 *
AOBTXT   EQU   *                   ENTRY LABEL FOR TEXT CARD
         L     R1,AOTADDR          GET @ CODE (USER PROG RELATIVE)
         LA    R1,0(,R1)           REMOVE HI-ORDER BYTE
         TM    AVTAGS1,AVO1TXT     HAVE WE GOTTEN AT LEAST 1 TXT CARD
         BO    AOBTXT1             YES, SO SKIP
*              FIRST TEXT CARD - COMPUTE RELOCATION FACTOR
         LR    R4,R2               MOVE REAL BEGINNING @ OVER
         SR    R4,R1               SUBTRACT USER LOW @ FROM REAL= RELOC
         OI    AVTAGS1,AVO1TXT     FLAG SO WE DON'T COMPUTE IT AGAIN
         BZ    AOBTXT1             NO, LEAVE ENTRY PT REG AS IS
         TM    AVTAGS1,AVOENTR     HAS ENTRY PT BEEN RECEIVED ALREADY
         BO    AOBTXT1             YES, SO DON'T CHANGE R5
         LR    R5,R1               MAKE DEFAULT ENTRY PT THE FIRST BYTE
AOBTXT1  AR    R1,R4               RELOC USER @ TO REAL ONE
         CR    R1,R2               WAS IT LOWER THAN REAL LIMIT
         BL    AOBTXTIL            YES, GO TO FLAG OR PRINT MESSAGE
         IC    R8,AOTLENG2         GET LENGTH FROM CARD OF CODE
         LA    R0,0(R8,R1)         GET REAL @+1 OF LAST BYTE OF CODE
         CR    R0,R9               WAS IT HIGHER THAN ACTUAL SPACE
         BH    AOBTXTIH            YES, TOO MUCH CODE-EXIT
         CR    R0,R3               WAS IT HIGHER THAN PREVIOUS HIGH
         BNH   *+6                 NO, SKIP
         LR    R3,R0               YES, SET NEW HIGH LIMIT
         SPACE 1
         LTR   R8,R8               WAS LENGTH=0 (POSSIBLE FOR DS'S)
         BZ    AOBREAD             YES, SO DON'T DO ANYTHING
         BCTR  R8,0                DECREMENT LENGTH TO LENGTH-1 FOR MVC
         EX    R8,AOBTXTMV         MOVE TEXT CODE OVER
         B     AOBREAD             RETURN FOR NEXT CARD
AOBTXTMV MVC   0($,R1),AOTCODE     MOVE CODE TO MEMORY **MODIFIED**
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              EXIT CODE - CHECK AND STORE FINAL ADDRESSES            *
*        MAKE SURE WE RECIEVED AT LEAST 1 TEXT CARD, ASSURE *8        *
*   LENGTH MULTIPLE, AND STORE BLOCK OF 6 ADDRESSES APPROPRIATELY.    *
*   NOTE THAT ALTERATIONS MUST BE MADE IF THE USER CODED RELOC, IN    *
*   WHICH CASE HIS PROGRAM MUST EITHER BE LOADED FROM WHERE IT WAS    *
*   ASSEMBLED ORIGINALLY, OR MUST CONTAIN NO ADDRESS CONSTANTS AT ALL.*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBJEOF  EQU   *
         TM    AVTAGS1,AVO1TXT     DID WE GET AT LEAST 1 TXT CARD
         BZ    AOBNOTXT            NO, QUIT NOW WITH ERROR
         LA    R3,7(,R3)           ROUND UPPER REAL @ UP
         SRL   R3,3                SHIFT TO REMOVE 3 BITS
         SLL   R3,3                SHIFT BACK, NOW ALIGNED
         TM    AVTAGS1,AJORELOC    WAS THIS TO BE RELOACTED MODE
         BZ    AOBJNORM            NO, NORMAL-SKIP
         AR    R5,R4               RELOCATE USER LOCATION TO REAL
         SR    R4,R4               MAKE EXECUTION RELOC FACTOR = 0
AOBJNORM EQU   *                   FINAL STORE OF @'S
         STM   R2,R5,AVRADL        AV(RADL-RADH-RELOC-FENTER)
         SR    R2,R4               RADL-RELOC = FAKE LOW @ FOR USER
         SR    R3,R4               RADH-RELOC = FAKE HIGH LIMIT @
         STM   R2,R3,AVLOCLOW      AV(LOCLOW-LOCHIH) -USER RELATIVE LIM
         SPACE 1
*              SUCCESFFUL COMPLETION MESSAGE AL100.
         BAL   R14,AOBHEXCO        GO CONVERT VALUES TO HEX
         DC    H'4'                # ITEMS IN LIST
         DC    AL2(AVLOCLOW-AVWXTABL,AOB100A-AOB)     LOWEST USER @
         DC    AL2(AVLOCHIH-AVWXTABL,AOB100B-AOB)     HIGH USER @
         DC    AL2(AVFENTER-AVWXTABL,AOB100C-AOB)     FAKE ENTRY @
         DC    AL2(AVRELOC-AVWXTABL,AOB100D-AOB)      RUN TIME RELOC
         BAL   R14,AOBPRINT        PRINT COMPLETED MESSAGE
         DC    AL2(AOB100-AOB,AOB100L)      MESSG OFFSET, LENGTH
         SPACE 1
AOBJEXIT $RETURN RGS=(R14-R12),SA=NO        RETURN TO CALLER
         SPACE 1
*              ***** ERROR EXITS *****
AOBNOTXT BAL   R14,AOBPRINT        PRINT AL996 - NO TEXT CARDS FOUND
         DC    AL2(AOB996-AOB,AOB996L)      OFFSET, LENGTH
         B     AOBJBAD             GO TO SHOW ABORT
AOBTXTIL BAL   R14,AOBPRINT        AL997 - TXT @ TOO LOW
         DC    AL2(AOB997-AOB,AOB997L)      OFFSET,LENGTH
         B     AOBTXTID            GO TO DUMP STMT FOR USER
AOBTXTIH BAL   R14,AOBPRINT        AOB998 - OVERFLOW OF AREA
         DC    AL2(AOB998-AOB,AOB998L)      OFFSET, LENGTH
AOBTXTID BAL   R14,AOBDUMP         DUMP USER CARDIMAGE, FALL TO AOBJBAD
AOBJBAD  BAL   R14,AOBPRINT        GO PRINT AL999 - LOAD ABORT
         DC    AL2(AOB999-AOB,AOB999L)      OFFSET, LENGTH
         OI    AVTAGS1,AJNLOAD     FLAG NOLOAD
         B     AOBJEXIT            RETURN SHOWING ERROR
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AOBDUMP    DUMP CURRENT USER CARDIMAGE                    *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS TO CALLING CODE                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBDUMP  EQU   *
         XSNAP T=(NO,,0),LABEL='IMAGE OF INCORRECT OBJECT CARD',       X
               STORAGE=(*AOBJCARD,*AOBJCARD+80)
         BR    R14
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AOBHEXCO   CONVERT VALUES TO EDITED HEXADECIMAL           *
*        ENTRY CONDITIONS                                             *
*   R14= @ PARAMETER LIST.  LIST CONSISTS OF THE FOLLOWING:           *
*        1) HALFWORD GIVING # ITEMS IN LIST TO BE CONVERTED.          *
*        2) 1 OR MORE PAIRS OF OFFSET VALUES GIVING DISPLACEMENT      *
*        FROM AVWXTABL TO FULLWORD VARIABLE TO BE CONVERTED, AND      *
*        OFFSET FROM LABEL AOB TO 6-BYTE FIELD WHERE EDITED HEX       *
*        SHOULD BE PLACED. REQUIRES FREE BYTE AFTER THIS FIELD.       *
*        EXIT CONDITIONS                                              *
*   R0,R1,R14,R15  ARE ALL MODIFIED.                                  *
*   CONTROL RETURNED TO LOCATION AFTER PARAMETER LIST.                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBHEXCO LH    R0,0(,R14)          GET # ENTRIES IN FOLLOWING LIST
AOBHEX2  LH    R1,2(,R14)          GET OFFSET OF FULLWORD TO CONVERT
         LA    R1,AVWXTABL(R1)     GET ACTUAL @ OF VARIABLE
         LH    R15,4(,R14)         GET OFFSET TO OUTPUT FIELD
         LA    R15,AOB(R15)        GET ACTUAL @ OUTPUT FIELD
         UNPK  0(7,R15),1(4,R1)    UNPACK 3 BYTES, WITH EXTRA FOR EASE
         TR    0(6,R15),AWTHEX3    TRANSLATE TO PRINTABLE
         MVI   6(R15),C' '         PUT IN BLANK AFTER TO WIPE EXTRA OUT
         LA    R14,4(,R14)         BUMP PTR TO NEXT PAIR
         BCT   R0,AOBHEX2          LOOP THORUGH LIST
         B     2(,R14)             RETURN TO CALLER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AOBPRINT   PRINT 1 LINE OF OUTPUT MESSAGE                 *
*        ENTRY CONDITIONS                                             *
*   R14= @ PARAMETER LIST, WHICH HAS OFFSET @ OF MESSAGE FROM AOB,    *
*        FOLLOWED BY LENGTH OF MESSAGE, BOTH IN HALFWORDS.            *
*        EXIT CONDITIONS                                              *
*   R0,R1      ARE MODIFIED.                                          *
*   CONTROL RETURNED TO LOCATION AFTER PARAMETER LIST.                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AOBPRINT LA    R0,AOB              BASE @ FOR MESSAGE
         AH    R0,0(,R14)          ADD IN OFFSET @
         LH    R15,2(,R14)         LENGTH OF MESSAGE
         $PRNT (R0),(R15)          PRINT THE MESSAGE
         B     4(,R14)             RETURN TO CALLER
         EJECT
*              AOBJIN LOADER MESSAGES - AL###                         *
*              AL000 - BEGINNIG HEADER LABEL.                         *
*              AL100 - SUCCESSFUL COMPLETION.                         *
*              AL996 - NO TEXT CARDS RECEIVED.                        *
*              AL997 - TXT CARD @ TOO LOW                             *
*              AL998 - TXT CARD @ TOO HIGH - OVERFLOW OF AREA         *
*              AL999 - LOAD ABORTED MESSAGE                           *
AOB      EQU   *                   BASE FOR OFFSET @'S IN PARM LISTS
         SPACE 1
AOB000   DC    C'0*** AL000 - ASSIST LOADER BEGINS LOAD AT '
AOB000A  DC    XL6'0'              LOWEST @ = AVADDLOW
         DC    C' ,USABLE CORE ENDS AT '
AOB000B  DC    XL6'0',C' ***'      HIGH LIMIT = AVADDHIH
AOB000L  EQU   *-AOB000            LENGTH OF THIS MESSAGE
         SPACE 1
AOB100   DC    C'0*** AL100 - LOAD COMPLETED, USER ADDRESSES: LOW '
AOB100A  DC    XL6'0',C' ,HIGH '   AVLOCLOW - LOW USER LIMT
AOB100B  DC    XL6'0',C' ,ENTRY '  HIGH LIMIT  AVLOCHIH
AOB100C  DC    XL6'0',C' . RUN-TIME RELOCATION '      USER ENTRY @
AOB100D  DC    XL6'0',C' ***'      AVRELOC - RUN-TIME RELOCATION
AOB100L  EQU   *-AOB100            LENGTH OF THIS MESSAGE
         SPACE 1
AOB996   DC    C'0*** AL996 - NO TXT CARD RECEIVED ***'
AOB996L  EQU   *-AOB996            LENGTH OF MESSAGE
         SPACE 1
AOB997   DC    C'0*** AL997 - TXT CARD ADDRESS BELOW 1ST TXT CARD ***'
AOB997L  EQU   *-AOB997            LENGTH OF MESSAGE
         SPACE 1
AOB998   DC    C'0*** AL998 - TXT CARD ADDRESS EXCEEDED STORAGE ***'
AOB998L  EQU   *-AOB998            LENGTH OF MESSAGE
         SPACE 1
AOB999   DC    C' *** AL999 - LOAD ABORTED ***'
AOB999L  EQU   *-AOB999            LENGTH OF MESSAGE
         DROP  R6,R7,RAT           REMV USINGS: BASE,AOBJCARD,AVWXTABL
.AOBJN1  AIF   (NOT &$DECK).AOBNONE    SKIP IF NO DECK
         EJECT
         ENTRY AODECK
AODECK   $SAVE RGS=(R14-R12),SA=NO,BR=R6
         USING AVWXTABL,RAT        NOTE ASSEMBLER CONTROL TABLE
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: AODECK     PUNCH OBJECT DECK FOLLOWING ASSEMBLY           *
*        IF THE DECK OPTION IS SPECIFIED, AODECK IS CALLED FOLLOWING  *
*   A SUCCESSFULL ASSEMBLY TO PUNCH THE USER PROGRAM OUT IN OBJECT    *
*   DECK FORM.  THE DECK PUNCHED CONTAINS 1 OR MORE TXT CARDS AND     *
*   1 END CARD, AND FOLLOWS S/360 DECK FORMAT FAIRLY CLOSELY.         *
*        **NOTE** THIS FACILITY IS VERY PRIMITIVE, AND THE DECKS      *
*   PRODUCED CANNOT REALLY BE USED FOR ANYTHING BUT INPUT TO ASSIST,  *
*   SINCE THERE IS NEITHER EXTERNAL SYMBOL DICTIONARY NOR RELOCATION  *
*   DICTIONARY PRODUCED.  ALSO, SINCE THE ENTIRE USER PROGRAM IS      *
*   PUNCHED, OBJECT CARDS ARE PRODUCED FOR SPACE CONTAINING ONLY DS   *
*   LOCATIONS.  IN SOME CASES, THIS COULD CAUSE HUGE DECKS TO BE      *
*   PUNCHED.   IF A BETTER SETUP IS DESIRED, ASSEMBLER MODULE UTOPRS  *
*   COULD BE CHANGED TO PRODUCE SMALLER DECKS, ALTHOUGH RLD ENTRIES   *
*   WOULD STILL BE DIFFICULT TO PRODUCE.                              *
*        **NOTE** THE MOST LIKELY USE FOR THIS OPTION IS TO PRODUCE   *
*   OBJECT DECKS TO BE USED AS UTILITY PROGRAMS FROM RJE TERMINALS.   *
*        ENTRY CONDITIONS                                             *
*   R12(RAT) = @ ASSEMBLER CONTROL TABLE (AVWXTABL).                  *
*        USES MACROS: $PNCH,$RETURN,$SAVE                             *
*        NAMES: AOD-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * REGISTER USAGE FOR AODECK * * * * * * * * * * * * * * *
*   R4 = @ CURRENT BLOCK OF CODE TO BE PUNCHED (INIT = AVRADL).       *
*   R5 = CURRENT LENGTH OF CODE REMAINING (INIT =AVRADH-AVRADL)       *
*   R6 = BASE REGISTER                                                *
*   R7 = @ AOBJCARD : OBJECT CARD OUTPUT IMAGE                        *
*   R8 = CURRENT @ OF CODE TO PUNCHED (USER PROGRAM RELATIVE).        *
*   R9 = L'AOTCODE = LENGTH OF NORMAL(ALL BUT LAST) CODE ON CARD      *
*   R12(RAT)= @ ASSEMBLER CONTROL TABLE (AVWXTABL).                   *
*   R13= @ CALLING PROGRAM'S SAVE AREA, UNCHANGED                     *
*   R14= INTERNAL LINK REGISTER                                       *
*   ALL OTHERS ARE UNUSED                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INITIALIZATION FOR OBJECT PUNCH                        *
*        INITIALIZE REGISTERS, SEQUENCE #, AND TXT CARDIMAGE.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LM    R4,R5,AVRADL        AV(RADL-RADH) LOWER/UPPER REAL @'S
         SR    R5,R4               SIZE OF CODE = UPPER-LOWER LIMIT
         BNP   AODEXIT             NO MORE, QUIT
         LA    R7,AVCONCAT         WE WILL USE THIS AS WORKAREA
         USING AOBJCARD,R7         NOTE PTR THERE
         L     R8,AVLOCLOW         GET LOWEST USER PROGRAM @
         MVC   AOBJCARD(72),AWBLANK    BLANK OUT CARD, EXCEPT SEQUENCE
         MVC   AOBJTYPE,=C'TXT'    FLAG AS TXT CARD
*****    MVI   AOBJCARD,X'02'      NORMAL S/360 FLAG
         LA    R9,L'AOTCODE        LENGTH OF NORMAL OBJECT CODE
         STH   R9,AOTLENG          STORE FOR NORMAL LENGTH
         ZAP   AVDWORK1(5),AWP0    ZERO WORKAREA FOR SEQUENCE#
         UNPK  AOTSEQN(8),AVDWORK1(5)       MOVE SEQUENCE # OVER
         OI    AOTSEQN+7,X'F0'     MAKE PRINTABLE
         MVI   AODTXTMV+1,L'AOTCODE-1       NORMAL LENGTH-1 OF OBJCODE
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              LOOP FOR PUNCHING OBJECT DECK                          *
*        PUNCH FULL OBJECT CARD FOR (ALL BUT POSSIBLY LAST BLOCK)     *
*   OF CODE IN USER PROGRAM.                                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AODTXT   EQU   *
         ST    R8,AOTADDR          STORE USER CODE FAKE @ INTO CARD
*****    MVI   AOTADDR,C' '        BLANK OUT FOR S/360 NORMAL
         CR    R5,R9               HOW MUCH IS LEFT TO BE PUNCHED
         BNL   AODTNORM            STILL ENOUGH FOR FULL CARD-BRANCH
         SPACE 1
         BCTR  R5,0                LENGTH-1 FOR MVC
         STC   R5,AODTXTMV+1       STORE INTO MVC FOR LAST PUNCH
         MVC   AOTCODE,AWBLANK     BLANK OUT WHOLE CARD, SINCE PART NOT
AODTNORM EQU   *
AODTXTMV MVC   AOTCODE($),0(R4)    MOVE CODE FROM MEMORY
         BAL   R14,AODPUNCH        GO PUNCH THE CARD
         AP    AVDWORK1(5),AWP1    INCREMENT THE CARD COUNTER
         UNPK  AOTSEQN(8),AVDWORK1(5)       UNPACK FOR NEXT CARD
         OI    AOTSEQN+7,X'F0'     MAKE SURE PRINTABLE
         AR    R8,R9               INCREMENT USER CODE @
         AR    R4,R9               INCREMENT REAL @ IN MEMORY PTR
         SR    R5,R9               DECREMENT LENGTH PUNCHED LAST TIME
         BP    AODTXT              IF MORE TO DO, RETURN FOR NEXT CARD
         SPACE 1
*              ***** COMPLETION - PUNCH END CARD
         MVC   AOBJTYPE,=C'END'    MAKE CARD AN END CARD
         MVC   AOEBLNK(AOEBLNKL),AWBLANK    BLANK OUT CARD(CEPT SEQN#)
         MVC   AOENTRY2,AVFENTER+1 MOVE ENTRY @ IN
         BAL   R14,AODPUNCH        PUNCH THE ASSEMBLED END CARD
AODEXIT  $RETURN RGS=(R14-R12),SA=NO
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: AODPUNCH   PUNCH 1 OBJECT CARD FOR AODECK                 *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN @ TO CALLING SECTION OF CODE                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
AODPUNCH EQU   *
         $PNCH AOBJCARD,80,AODEXIT PUNCH, QUIT IF OVERRUN
         BR    R14                 RETURN TO CALLING SECTION
         LTORG
         DROP  R6,R7,RAT           REMV USINGS: BASE,AOBJCARD,AVWXTABL
.AOBNONE ANOP
         AIF   (&$EXINT).EXYZ      SKIP IF USING EXTENDED INTERPRETER
         TITLE '*** EXECUT - ASSIST INTERPRETER SECTION ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: EXECUT       INTERPRETER SECTION                          *
*              EXECUT PERFORMS ALL 360 INSTRUCTION SIMULATION DURING  *
*        INTERPRETIVE EXECUTION OF THE USER PROGRAM.  ALL CONTROL     *
*        VALUES FOR THIS MODULE ARE CONTAINED IN DSECT ECONTROL, WHICH*
*        IS PASSED TO EXECUT BY THE CALLING PROGRAM.  THE INSTRUCTION.*
*        SET SIMULATED INCLUDES THE FOLLOWING:                        *
*              1. STANDARD INSTRUCTION SET (INCL. 370'S IF ALLOWED)   *
*              2. DECIMAL INSTRUCTION SET (IF PRESENT ON MACHINE).    *
*              3. FLOATING POINT INSTRUCTIONS (OPTIONAL).             *
*              4. X-MACRO PSEUDO INSTRUCTIONS - XDUMP, XLIMD,         *
*                XPNCH, XPRNT, XREAD.                                 *
*        THE PRIVILEGED OPERATIONS MAY BE DECODED TO THE POINT OF     *
*        BRANCHING TO INDIVIDUAL INSTRUCTION HANDLERS, BUT THEY ARE   *
*        ARE FLAGGED WITH AN 0C2 INTERRUPT AT PRESENT, AND ARE NOT    *
*        INTERPRETED FURTHER.  THE CODE PRESENT IS FOR FUTURE USE.    *
*              THE SVC INSTRUCTION IS CURRENTLY FLAGGED WITH AN 0C2 IF*
*        USED, BUT CODE EXISTS TO HANDLE ALL SVC CALLS IN A TABLE-    *
*        DRIVEN WAY, USING THE @ OF AN SVC CONTROL TABLE PASSED IN THE*
*        WORD ECSVCADS IN ECONTROL.  AS OF 8/2/70, THERE ARE NOT SVC  *
*        ROUTINES, BUT THE CODE EXISTS FOR FUTURE USE.                *
*              GENERAL CODE IS ALSO PROVIDED FOR ANY ADDITIONAL NEW   *
*        INSTRUCTIONS OR I/O SIMULATORS BY THE SECTION EXCALL, WHICH  *
*        ALLOWS CALLS TO EXTERNAL ROUTINES (WHICH WOULD BE USED BY    *
*        ANY SVC CALLS, IF THERE ARE ANY).                            *
*        ENTRY CONDITIONS                                             *
*   R10= @ ECONTROL - EXECUTION CONTROL BLOCK.                        *
*   ECONTROL CONTAINS ALL INITIAL VALUES FOR REGS,LIMITS,ETC.         *
*        EXIT CONDITIONS                                              *
*   ECINTCOD   CONTAINS INTERRRUPT CODE, IF PROGRAM INTERRUPT.        *
*   ECFLAG1    CONTAINS SPECIAL COMPLETION CODE, IF ANY.              *
*   ECERRAD  = ADDRESS OF AN ERCOMPCD ERROR COMPLETION CODE BLOCK     *
*   ECONTROL   CONTAINS ALL OTHER VALUES NEEDED FOR A COMPLETION DUMP.*
*        USES DSECTS: ECONTROL,ECSTACKD                               *
*        USES MACROS: $AL2,$ERCGN,$PNCH,$PRNT,$READ,$RETURN,$SAVE     *
*        USES MACROS: $SPIE, XDECI, XDECO, XSNAP                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
EXECUT   CSECT
         $DBG  ,NO                 KILL TRACE CODE HERE
         SPACE 1
EXPRFETC EQU   B'10000000'         (EXIPROT) - INST ACCESSES STORAGE
EXPRSTOR EQU   B'01000000'         (EXIPROT) - INST MODIFIES STORAGE
EXPRFET2 EQU   B'00100000'         (EXIPROT) - SS INST ACCESSES CORE
EXPRSTO2 EQU   B'00010000'         (EXIPROT) - SS INST MODS CORE(2ND @)
         SPACE 1
*        *** SYMBOLIC REGISTER EQUATES ***                            *
RSTK     EQU   R3                  ADDR OF CURRENT INST. STACK ENTRY
RIA      EQU   R4                  INSTRUCTION ADDRESS REGISTER
RCC      EQU   R5                  CONDITION CODE REGISTER
REC      EQU   R6                  POINTER TO ECONTROL BLOCK
RWK      EQU   R7                  WORK REGISTER
RR1      EQU   R8                  DECODING REGISTER FOR R1 FIELD
RR2      EQU   R9                  REGISTER 2 (WHEN USED IN RR'S)
RX2      EQU   RR2                 INDEX REGISTER(FOR RX'S)
RR3      EQU   RR2                 RO OPERAND(FOR RS INST)
RB1      EQU   R10                 1ST BASE-DISPLACEMENT-(B1-D1)
RB2      EQU   R11                 2ND BASE-DISPLACEMENT-(B2-D2)
RMEM     EQU   R12                 CONTAINS RELOCATION VALUE
RLINK    EQU   R14                 INTERNAL LINAKGE REGISTER-RETURN ADD
ROP      EQU   R15                 USED TO HOLD OPCODE BYTE
*        **NOTE** DURING MAIN EXECUTION REGS R2,ROP ARE BYTE REGS.    *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*              ORGANIZATION OF THE ASSIST INTERPRETER                 *
*                                                                     *
*        1.    INITIALIZATION CODE                                    *
*        2.    INTERRUPT-HANDLING AND EXIT CODE                       *
*        3.    OCCASIONAL INTERNAL SUBROUTINE CODE                    *
*        4.    PRIMARY INSTRUCTION FETCH AND COMMON DECODING          *
*        5.    1ST-LEVEL DECODING, IN GROUPS :  RR, RX, SI-RS, AND SS *
*        6.    2ND-LEVEL SECTIONS-PERFORM INDIVIDUAL INSTRUCTIONS,    *
*              IN GROUPS:  RR, RR-RX OVERLAP, RX, SI, RS, SS,SPECIAL  *
*        7.    3RD-LEVEL INTERNAL SUBROUTINES (DECODERS,RANGE CHECK)  *
*        8.    DATA AREAS, OPCODE BRANCH AND PROTECTION TABLES        *
*                                                                     *
*        **WARNING** ADDRESSIBILITY IS NOW TIGHT IN EXECUT.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        INITIALIZATION PHASE - OBTAIN PARAMATER ADDRESSES FROM CALLER*
*   PERFORM CALCULATIONS TO GET THEM INTO NEEDED FORM. ZERO OUT THE   *
*   INSTRUCTION STACK FINSTACK,AND INITIALIZE ANY REQUIRED REGISTER   *
*   VALUES FOR THE EXECUTION. ALSO SAVE INSTRUCTION LIMIT VALUE.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $SAVE RGS=(R14-R12),BR=R8,SA=EXECSAVE
         LR    REC,R10             MOVE ECONTROL BLOCK POINTER OVER
         USING ECONTROL,REC        NOTE USAGE
         TM    ECFLAG0,$ECCONT     IS THIS A CONTINUE OR A NEW
         BO    EXCONTIN            INIT ALREADY DONE-KEEP GOING
         OI    ECFLAG0,$ECCONT     NOTE THAT ANY OTHERS WILL BE CONTINU
         SPACE 1
*              INSTRUCTION STACK ZEROING AND CHAINING.                *
         SR    R1,R1               CLEAR FOR ZEROING USE
         SR    R2,R2               CLEAR FOR ZEROING
         SR    R3,R3               CLEAR FOR ZEROING
         LA    R4,L'ECSTENT        VALUE OF SINGLE ENTRY
         LA    R5,ECINSTAC+L'ECINSTAC*(EC$STACK-1)     GET ENDING LIMIT
         LA    R7,ECINSTAC         GET BEGINNING ADDRESS OF STACK AREA
         USING ECSTACKD,R7         SET UP TEMPORARY USING
         LA    R0,ECINSTAC+L'ECINSTAC        GET @ 2ND ELEMENT
         SPACE 1
EXINITST STM   R0,R3,ECSTENT       ZERO 1 TABLE ENTRY
         LR    R7,R0               UPDATE POINTER TO STACK ENTRY
         BXLE  R0,R4,EXINITST      CONTINUE LOOPING
         SPACE 1
         LA    R0,ECINSTAC         ADDRESS FOR WRAPAROUND
         STM   R0,R3,ECSTENT       STORE IN LAST ENTRY
         ST    R7,ECRSTK           SAVE WHERE CAN BE PICKED UP
         DROP  R7        DROP TEMPORARY REG TO KEEP USING STRAIGHT
         MVC   ECILIMT,ECILIMP     MOVE PERMANENT TO TEMPORARY
         MVC   ECILCMSK(4),ECFENTER          MAKE ENTRY POINT THE PSW
         MVC   ECR14SAV,ECREG14    SAVE FOR ORIGINAL RETURN @
         SPACE 1
EXCONTIN BAL   RLINK,EXADCALC      GO TO RECALCULATE ADDRESSES IF NEED
         SPACE 1
EXSPIEGO EQU   *
         TM    ECFLAG0,$ECSPIEA    IS OUR SPIE ALREADY IN EFFECT
         BO    EXSPIEA             YES,WE DON'T HAVE TO RE-SPIE
         $SPIE EXSPIERT,((1,15)),CE=EXSPIEXT,ACTION=CR  CATCH ALL INTRP
         ST    R1,ECPICA           SAVE PREVIOUS PICA, IF ANY
         OI    ECFLAG0,$ECSPIEA    SHOW OUR SPIE IS IN CONTROL
EXSPIEA  L     RSTK,ECRSTK         GET POINTER TO NEXT SLOT FOR STACK
         USING ECSTACKD,RSTK       SET UP STACK USING FROM NOW ON
         L     RMEM,ECRELOC        GET RELOCATION VALUE IN REGISTER
         SR    R2,R2               CLEAR REG FOR CONSTANT INSERTS
         STH   R2,ECINTCOD         SET THE INTERRUPT CODE TO 0
         SR    ROP,ROP             CLEAR OPCODE REG FOR CONSTANT IC'S
         L     RB2,ECILCMSK        LOAD INST ADDR WHERE EXFINB EXPECTS
         LR    RCC,RB2             PLACE CC AND MASK OVER
         SPM   RCC                 INITIALIZE REAL CC TO FAKE ONE
         AIF   (NOT &$FLOTE).EXNOFL1         SKIP IF NOT GOING TO DO FP
         LD    F0,ECFPREGS         GET FP REG
         LD    F2,ECFPREGS+8       GET 2ND FP REG
         LD    F4,ECFPREGS+16      LOAD 3RD FP REG
         LD    F6,ECFPREGS+24      GET 4TH FP REG
.EXNOFL1 ANOP
         B     EXFINB              SKIP TO START RUN
EXECSAVE DC    18F'0'              SAVE AREA, ALSO BASE REGISTER HERE
         DROP  R8                  KILL TEMPORARY USING
         USING EXECSAVE,R13        USE R13 AS BASE/SAVEAREA POINTER
EXJUMP   DS    0H                  BASE FOR 2ND LEVEL INDEX JUMPS
         SPACE 1
* * * * * 0CX INTERRUPT EXITS   * * * * * * * * * * * * * * * * * * * *
*              THE LABELS ARE HERE SO THAT OTHERS MAY BE EQU'D TO THEM*
EX0C1    LA    R0,1                SHOW OPERATION INTERRUPT
         AIF   (&$DEBUG).EX0C1A    SKIP DEBUG CODE IF PRODUCTION
         CLI   ECOP,X'83'          IS CODE THE PSEUDO DIAGNOSE
         BE    EXDIAG              YES,GO THERE FOR OUR PSEUDO DIAGNOSE
.EX0C1A  ANOP
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
EX0C2C   EQU   *                   CHECK FOR PRIVILEGED OPERATION
         TM    ECKYAMWP,$ECPRBST   ARE WE IN PROBLEM STATE
         BCR   Z,RLINK             NO,SUPERVISOR STATE,SO OK-RETURN
EX0C2    LA    R0,2                PRIVILEGED OPERATION
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
EX0C3    LA    R0,3                EXECUTE INTERRUPT
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
EX0C4    LA    R0,4                PROTECTION INTERRUPT
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
*EX0C5   LA    R0,5                ADDRESSING INTERRUPT
*        B     EXEXITI             QUIT
EX0C6    LA    R0,6                SPECIFICATION INTERRUPT
         B     EXEXITI             EXIT POINT FOR INTERRUPTS
*EX0C7   LA    R0,7                DATA EXCEPTION
*        B     EXITI               QUIT
EX0CA    LA    R0,10               DECIMAL OVERFLOW
         B     EXEXITI             QUIT
         SPACE 2
*              ENTERED WHEN PROGRAM BRANCHES OUT OF RANGE             *
EXIAOUT  MVI   ECFLAG1,$ECBRN14    HOPE FOR NORMAL RETURN
         L     R14,ECR14SAV        GET RETURN @, ORIGINAL
         LA    R14,0(R14)          REMOVE LEADING BYTE
         CR    RIA,R14             WAS BRANCH TO THIS @
         BE    EXITA               RETURN
         MVI   ECFLAG1,$ECBROUT    WAS ACTUAL BRANCH OUT OF PROG,RET
         LA    R1,EXCCBROU         SHOW @ BRANCH OUT
         B     EXITIA              GO HAVE @ STORED, QUIT
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INTERRUPT HANDLER - THIS SECTION IS ENTERED FOR ANY    *
*        REAL INTERRUPT, SUCH AS 0C7,0C6,ETC.  THE REAL INTERRUPT     *
*        IS SAVED AS THE PSEUDO INTERRUPT, SINCE THEY MUST BE THE     *
*        SAME. THE ADDRESS IN THE PSW PART OF THE PIE IS MODIFIED SO  *
*        THAT OS WILL RETURN CONTROL TO EXSPIERT INSTEAD OF TO THE    *
*        INTERRUPTED CODE, AND THEN CONTROL IS GIVEN TO OS. WHEN THE  *
*        INTERPRETER REGAINS CONTROL, IT EXITS, SHOWING AN INTERRUPT. *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING *,R15
EXSPIEXT LH    RB1,2(R1)           GET INTERRUPT CODE FROM PIE
         AIF   (&$DEBUG).EXXNSP    SKIP IF PRODUCTION
         XSNAP LABEL='SPIE',STORAGE=(*0(R1),*32(R1)),                  X
               IF=(ECFLAG2,O,X'20',TM)      XSNAP PIE
.EXXNSP  ANOP
         BR    R14                 RETURN TO OS CONTROL
         DROP  R15                 DROP USING TO KEEP STRAIGHT
         SPACE 1
EXSPIERT LR    R0,RB1              MOVE INTERRUPT CODE OVER WHERE NEED
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              EXIT AND RETURN CODE - SAVE EVERYTHING REQUIRED,       *
*        REMOVE $SPIE IF NECESSARY, AND RETURN TO CALLER.             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXEXITI  STH   R0,ECINTCOD         SAVE INTO INTERRUPT CODE
         MVI   ECFLAG1,0           RESET, NEEDED BY REPLACE MONITOR
*              FOLLOWING FINDS MESSAGE FOR 0CX COMPLETION CODES.      *
         ALR   R0,R0               SLL R0,1,DOUBLE CODE FOR INDEX
         LR    R1,R0               MOVE WHERE WE CAN USE FOR INDEX
         LH    R1,EXCOFFS(R1)      GET OFFSET TO MESSAGE BLOCK
         LA    R1,EXCC0(R1)        GET @ MESSAGE BLOCK
EXITIA   ST    R1,ECERRAD          STORE THIS @ IN ECONTROL
         SPACE 1
EXITA    ST    RSTK,ECRSTK         SAVE THE STACK POINTER
         N     RCC,=XL4'3F000000'  REMOVE @, ILC(WHICH IS WRONG)
         ALR   RCC,RIA             PUT THE ADDRESS AND CONCODE TOGETHER
         ST    RCC,ECILCMSK        SAVE INTO THE PSW
         OI    ECILCMSK,X'40'      SET ILC TO =1
         CLI   ECOP,X'40'          WAS LAST INSTRUCTION RR
         BL    EXITAILC            YES, SO ILC IS SET RIGHT,BRANCH
         XI    ECILCMSK,X'C0'      SET ILC TO 2 FOR RX-SI-RS
         CLI   ECOP,X'C0'          WAS INST AN SS
         BL    EXITAILC            NO, IT WAS SI-RX-RS, BRANCH, ILC=2
         OI    ECILCMSK,X'40'      SET ILC=3 FOR SS INSTS
EXITAILC EQU   *
         AIF   (NOT &$FLOTE).EXNOFL3         SKIP IF NOT FLOATINGS
         STD   F0,ECFPREGS         STORE FIRST FP REG
         STD   F2,ECFPREGS+8       STORE 2ND FP REG
         STD   F4,ECFPREGS+16      SAVE THE THIRD FP REG
         STD   F6,ECFPREGS+24      SAVE 4TH FP REG
.EXNOFL3 ANOP
         TM    ECFLAG0,$ECSPIEB    DO WE NEED TO UNDO SPIE
         BZ    EXECRET             NO WE DON'T,SO DON'T SPIE
         L     R1,ECPICA           GET PICA ADDRESS BACK
         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS XSPIEBLK
         NI    ECFLAG0,255-$ECSPIEA          WE WILL HAVE TO RESPIES
EXECRET  $RETURN RGS=(R14-R12)
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SPECIAL ROUTINES - THE FOLLOWING ROUTINES ARE USED AT MOST   *
*        OCCASIONALLY, AND ARE NOT DIRECTLY PARTS OF THE INTERPRETER. *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              EXTERNAL CALL ROUTINE - THIS SECTION PREPARES ALL OF   *
*        THE DUMMY MACHINE AREAS, AND CALLS THE ROUTINE WHOSE ADDRESS *
*        IS IN RWK.  IT CHECKS FOR AN INTERRUPT CONDITION,RESTORES    *
*        ALL THE REGISTERS, AND RETURNS CONTROL TO NORMAL EXECUTION.  *
*        ***NOTE*** THIS ROUTINE IS MAINLY FOR FUTURE USE, I.E. FOR   *
*        IMPLEMENTATION OF CERTAIN SVC'S, MACHINE LEVEL I/O, OR       *
*        ANY ADDITIONAL PSEUDO MACHINE OPCODES WHICH ARE REQUIRED.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXCALL   STM   R0,R15,ECTSAVE      SAVE THE REGS TO BE SAFE
         ST    RSTK,ECRSTK         SAVE POINTER IN CONTROL BLOCK
         N     RCC,=XL4'3F000000'  REMOVE EXTRA BITS IN CC REG
         ALR   RCC,RIA             PUT THE ADDRESS AND CONCODE TOGETHER
         ST    RCC,ECILCMSK        SAVE INTO THE PSW
         LR    R15,RWK             PLACE ADDRESS IN R15 FOR CALL
         BALR  RLINK,R15           CALL THE ROUTINE
         LM    R0,R15,ECTSAVE      RESTORE THE REGS
         SR    R0,R0     CLEAR THIS OUT
         CH    R0,ECINTCOD         SEE IF INTERRUPT CODE
         BNE   EXITA               IF THERE WAS CODE-RETURN
         CLI   ECFLAG1,0           WAS SPECIAL CODE STILL 0
         BNE   EXITA               NO,SO EXIT WITH ERROR FLAG
         BAL   RLINK,EXADCALC      HAVE ADDRESS RECALCULATED IF NEEDED
         L     RB2,ECILCMSK        GET PSW BACK
         LR    RCC,RB2             GET CC AND MASK BACK
         B     EXFINB              BRANCH THERE, IN CASE PSW CHANGED
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              ADDRESS CALCULATION SECTION - IF THE ADDRESS VALUES    *
*        MAY HAVE BEEN CHANGED, OR ARE NOT ALREADY COMPUTED,THIS      *
*        SECTION FINDS THE USER HIGH ADDRESS AND RELOCATION FACTOR    *
*        GIVEN REAL LOW AND HIGH ADDRESSES, AND USER LOW ADDRESS.     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXADCALC TM    ECFLAG0,$ECADSOK    SEE IF THE ADDR'S NEED FIXING
         BCR   O,RLINK             RETURN IF CALCULATIONS UNNEEDED
         OI    ECFLAG0,$ECADSOK    FLAG ADDRS OK, WHICH THEY WILL BE
         L     R0,ECRADH           GET REAL HIGH ADDRESS LIMIT
         S     R0,ECRADL           GET LENGTH OF PROGRAM
         A     R0,ECFADL           ADD TO FAKE LOW ADDRESS
         ST    R0,ECFADH           STORE THIS IN FAKE HIGHEST
         SH    R0,=H'256'          FOR @ CHECKING DIFFERENCE
         ST    R0,ECFADHC          SAVE FOR @ CHECKING EXRANGE
         L     R0,ECRADL           GET REAL LOWEST ADDRESS
         S     R0,ECFADL           SUBTRACT TO GET RELOCATION EXEC
         ST    R0,ECRELOC          SAVE THIS FOR EXECUTION TIME RELOCAT
         BR    RLINK               RETURN TO CALLING SECTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        MAIN INTERPRETER LOOP HEAD. ALL SUCCESSFUL BRANCHES PASS     *
*   THROUGH EFINB, WHICH CHECKS FOR ILLEGAL BRANCHES. CONTROL THEN    *
*   PASSES THROUGH EFIN,WHICH CHECKS FOR LOOPING BEYOND INSTRUCTION   *
*   COUNT LIMIT.  ALL OTHER INSTRUCTIONS SKIP EFINB AND RETURN        *
*   DIRECTLY TO EFIN.   THE NEXT INSTRUCTION IS THEN ACCESSED,DECODED *
*   PARTIALLY FOR 4-WAY BRANCH (RR,RX,SI&RS,SS),AND VARIOUS           *
*   BOOKKEEPING DETAILS DONE (UPDATING INSTRUCTION ADDRESS,MOVING     *
*   INSTRUCTION INTO NEXT STACK LOCATION,ETC. )                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXFINB   LA    RIA,0(RB2)          MOVE BRANCH ADDRESS OVER,REM 1ST BYT
         C     RIA,ECFADL          COMPARE FOR BELOW LOWEST FAKE
         BL    EXIAOUT             BRANCHED OUT OF RANGE
         C     RIA,ECFADH          COMPARE TO NEXT ADDRESS BEYOND AREA
         BNL   EXIAOUT             ADDRESS OUT OF RANGE-ERROR
         AIF   (NOT &$ALIGN).EXFT1 SKIP IF MACHINE REQUIRES ALIGN
         ST    RB2,ECTSAVE         SAVE ADDR: MUST DO CHECK SLOW WAY
         TM    ECTSAVE+3,X'01'     WAS ADDR ODD
         BO    EX0C6               YES-BAD PROGRAMMER-JUMP
.EXFT1   AIF   (&$ALIGN).EXFT2     SKIP IF ALIGN NOT NEEDED
         LH    R0,0(RB2,RMEM)      QUICK ALIGNEMNT CHECK
.EXFT2   ANOP
*              IF TIMER RUNOUT OCCURS, ASSIST SETS ECFLAG1=$ECTIMEX.
*              EXECUT DISCOVERS THIS NEXT TIME BRANCH IS SUCCESSFUL.
         AIF   (&$TIMER EQ 0).EXNOTOA       SKIP IF NO TIMER AT ALL
         CLI   ECFLAG1,$ECTIMEX    HAS FLAG BEEN SET BY TIMER EXIT
         BE    EXOVRTIM            YES, SO GO THERE, TIME RAN OUT
.EXNOTOA ANOP
         SPACE 2
*              CHECK FOR EXCEEDING TOTAL INSTRUCTION COUNT            *
*              ALL INSTRUCTIONS BUT SUCCESSFUL BRANCHES ENTER HERE    *
EXFIN    L     R0,ECILIMT          GET THE COUNTER
EXTIMDEC BCT   R0,EXGO             DECREMENT COUNTER, BRANCH IF OK
         ST    R0,ECILIMT          RESTORE INST COUNT FOR STATS(0)
         MVI   ECFLAG1,$ECTIMEX    SHOW TIME EXCEEDED(INSTR LIMIT)
         LA    R1,EXCCTIME         SHOW @ TIME MESSAGE
         B     EXITIA              GO TO FINISH AND EXIT
         AIF   (&$TIMER EQ 0).EXNOTOB       SKIP IF NO TIMER AT ALL
EXOVRTIM LA    R1,EXCCTIMB         SHOW TIMER OVER. ECFLAG1 ALREADY SET
         B     EXITIA              SKIP TO EXIT SECTION
.EXNOTOB ANOP
EXGO     ST    R0,ECILIMT          STORE THIS BACK IN LIMIT
         SPACE 1
*              INSTRUCTION FETCH AND PRIMARY DECODING SECTION.        *
         SPACE 1
         LA    RWK,0(RIA,RMEM)     OBTAIN PHYSICAL REAL ADDRESS
EXFEXENT L     RSTK,ECSTLINK       OBTAIN ADDRESS OF NEXT STACK SLOT
         STM   RIA,RCC,ECSTIADD    SAVE INSTRUCTION ADDRESS,CC,MASK
         MVC   ECSTINST,0(RWK)     MOVE 6 BYTES INTO NEXT SLOT
         IC    ROP,ECOP            GET OPCODE INTO REGISTER
         IC    R2,EXOPTAB1(ROP)    GET SECONDARY CODE FOR OPCODES
         LR    R1,ROP              GET OPCODE WHERE CAN BE CHANGED
         SRL   R1,6                REMOVE ALL BUT 1ST 2 BITS
         SLL   R1,2                SHIFT BACK = MULT*4 FOR INDEX
         AIF   (&$DEBUG).EXSNAP1   SKIP XSNAPS GENERATION IF NOT DEBUG
         XSNAP LABEL='PRIMARY FETCH',IF=(ECFLAG2,O,X'80',TM),          #
               STORAGE=(*ECSTENT,*ECB2D2+2,*ECFPREGS,*ECILIMP)
         LM    RB1,RB2,ECRADL      GET LOW AND HIGH @ POINTERS
         XSNAP T=NO,LABEL='USER AREA',STORAGE=(*0(RB1),*0(RB2)),IF=(ECF#
               LAG2,O,X'40',TM)
.EXSNAP1 ANOP
         SPACE 1
*              UPDATE INSTRUCTION COUNTER RIA TO NEXT INSTRUCTION,    *
*        TAKE 4-WAY BRANCH TO PRIMARY TYPE DECODING SECTIONS.         *
EXEXLEN  A     $CHN+RIA,EXILENG(R1)    UPDATE RIA**CHANGED BY EXEX*****
EXPRIME  B     *+4(R1)             TAKE BRANCH FOR PRIMARY PROCESSING
         B     EXTRR               R1=0 ==> RR INSTRUCTION
         B     EXTRX               R1=4 ==> RX INSTRUCTION
         B     EXTSIRS             R1=8 ==> SI OR RS INSTRUCTION
         B     EXTSS               R1=12 ==> SS INSTRUCTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        RR PRIMARY DECODING - DECODE R1-R2 FIELDS,THEN MAKE          *
*   SECOND LEVEL BRANCH TO INDIVIDUAL INSTRUCTION PROCESSORS.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTRR    BAL   RLINK,EXR1R2        GET R1,R2 FIELDS SEPARATED
         LH    R1,EXSECRR(R2)      GET SECOND LEVEL BRANCH INDEX VALUE
         B     EXJUMP(R1)          TAKE BRANCH TO INDIVIUDAL ROUTINES
         SPACE 4
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        RX PRIMARY DECODING - DECODE B2-D2 FIELDS,R1-X2 FIELDS,      *
*   YIELDING 2ND OPERAND ADDRESS IN REGISTER RB2. IF INSTRUCTION IS   *
*   ONE OF THOSE NOT REQUIRING ADDRESS RELOCATION(I.E. BRANCHES OF    *
*   SOME TYPE,LOAD ADDRESS) TAKE SECOND LEVEL BRANCH IMMEDIATELY.     *
*   FOR OTHER INSTRUCTIONS,THE 2ND OPERAND ADDRESS IS CHECKED FOR     *
*   WITHIN THE PERMITTED RANGE BY EXRANGE, AND THEN THE ADDRESS IS    *
*   RELOCATED TO THE ACTUAL CORE ADDRESS.  THEN THE SECOND-LEVEL      *
*   CHOICE IS MADE FOR THE INDIVIDUAL PROCESSORS.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTRX    BAL   RLINK,EXABD         PERFORM B2-D2 ADDRESS CALCULATION
         BAL   RLINK,EXR1R2        OBTAIN R1,X2 FIELDS
         BZ    EXRXNOX             IF X2=0,NO INDEXING NEED BE DONE
         AL    RB2,ECREGS(RX2)     PERFORM INDEXING OPERATION
         LA    RB2,0(RB2)          ZAP POSSIBLE 1ST BYTE FROM X2 FIELD
EXRXNOX  LH    R1,EXSECRX(R2)      GET BRANCH INDEX ADDRESS
         CH    R2,EXNORNG          COMPARE WITH HIGHEST FOR NO RANGECK
         BNH   EXJUMP(R1)          TAKE BRANCH TO ROUTINES
         BAL   RLINK,EXRANGE       HAVE THE RANGE CHECKED FOR THE INST
         AR    RB2,RMEM            RELOCATE FAKE @ TO REAL @
         AIF   (&$S370 NE 2).EXTRX SKIP IF NOT SIMULATING S/370'S
         TM    ECFLAG4,AJONALGN    MUST WE FAKE ALIGNMENT
         BZ    EXJUMP(R1)          NO--> BRANCH
         CH    R2,EXALIGN          DOES INSTRUCTION REQUIRE ALIGNMENT
         BH    EXJUMP(R1)          NO--> BRANCH
         LTR   RB1,RB2             SAVE FOR LATER, SET CC TO =
         MVC   EXDUBLWD(8),0(RB2)  MOVE MAXIMUM OF 8 BYTES OVER
         LA    RB2,EXDUBLWD        LOAD ADDRESS OF ALIGNED FIELD
.EXTRX   ANOP
         B     EXJUMP(R1)          TAKE BRANCH TO APPROPRIATE ROUTINE
         SPACE 4
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SI-RS PRIMARY DECODING - DECODE B1-D1 FIELD,WITH RESULTING   *
*   ADDRESS APPEARING IN REGISTER RB2. THEN MAKE SECOND-LEVEL CHOICE  *
*   TO THE VARIOUS INDIVIDUAL PROCESSORS.                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTSIRS  BAL   RLINK,EXABD         ADDRESSING FOR B1-D1 FIELD
         LH    R1,EXSECSI(R2)      GET SECOND LEVEL JUMP INDEX
         B     EXJUMP(R1)          TAKE BRANCH TO INDIVIUAL ROUTINE
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SS PRIMARY DECODING - DECODE AND CHECK 1ST AND 2ND OPERAND   *
*   ADDRESSES FOR WITHIN RANGE,USING DECODED VALUES OF L OR L1 AND L2 *
*   FIELDS AS REQUIRED. AFTER RELOCATING TO ACTUAL MACHINE ADDRESSES, *
*   MAKE SECOND-LEVEL BRANCH TO INDIVIDUAL PROCESSOR SEGMENTS.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXTSS    BAL   RLINK,EXABD         HAVE 1ST @ DECODED
         BAL   RLINK,EXRANGE       CHECK 1ST @ FOR WITHIN RANGE
         LA    RB1,0(RB2,RMEM)     RELOCATE THE 1ST @ TO REAL @
         LH    RB2,ECB2D2          GET THE BASE-DISP FOR 2ND @
         BAL   RLINK,EXABD1        HAVE 2ND @ DECODED
         SPACE 1
*              NOTE THAT THE FOLLOWING SEQUENCE IS ESSENTIALLY LIKE   *
*        THE SECTION EXRANGE.  THIS IS REQUIRED BECAUSE THE 1ST AND   *
*        2ND OPERANDS OF SS INSTRUCTIONS DO NOT NECESSARILY HAVE THE  *
*        SAME PROTECTION ATTRIBUTES, I.E. 1ST OPERANDS ARE SOMETIMES  *
*        STORE PROTECTION VIOLATION CAUSES, WHILE 2ND OPERANDS USUALLY*
*        CAUSE ONLY FETCH PROTECTION VIOLATIONS, IF ANY.              *
         C     RB2,ECFADL          IS @ LOWER THAN LOWEST ALLOWED
         BL    EXSSL               TOO LOW,GO SEE IF REALLY ILLEGAL
         C     RB2,ECFADHC         COMP WITH ACTUAL HI LIM(ECFADH-256)
         BL    EXSSL2              @ ACCEPTABLE,GO RELOCATE AND EXECUTE
         SPACE 1
*              ADDRESS OUT OF RANGE-CHECK INST TYPE/PROTECTION MODE.  *
EXSSL    LA    RWK,EXIPROT-64(ROP) GET @ PROTECTION CONTROL BYTE
         TM    0(RWK),EXPRSTO2+EXPRFET2     ANY CORE ACCESS AT ALL?
         BO    EXRANOUT            YES,AND @ OUT OF RANGE-GO TO FLAG
         SPACE 1
         BZ    EXSSL2              NO IT ISN'T,SO ITS OK ANYWAY
         TM    ECFLAG0,$ECPROT     OUT OF RANGE,FETCH PROT,IF MODE ON
         BNZ   EXRANOUT            ABSOLUTE PROTECT MODE-SO PROTECT ERR
         SPACE 1
EXSSL2   AR    RB2,RMEM            RELOCATE THE 2ND OP ADDRESS
         MVC   EXQSS(2),ECOP       MOVE THE OPCODE AND LENGTH(S) OVER
         LH    R1,EXSECSS(R2)      GET SECOND LEVEL BRANCH INDEX
         B     EXJUMP(R1)          TAKE BRANCH
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SECOND-LEVEL PROCESSOR SECTIONS - THESE SECTIONS PERFORM     *
*   ALL REQUIRED COMPUTING AFTER INITIAL DECODING HAS BEEN DONE IN    *
*   RESPECTIVE PRIMARY SECTIONS.                                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 4
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              RR SECOND-LEVEL PROCESSOR SECTION.                     *
*              TO CONDENSE CODE IN  RR SECTION, REMOVE THE CODE       *
*        SECTIONS BELONGING TO EXLR AND EXFPRR AND EQU THOSE SYMBOLS  *
*        TO EXNORMRR INSTEAD                                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              SET PROGRAM MASK                                       *
EXSPM    L     RCC,ECREGS(RR1)     PLACE SPECIFIED REG INTO CC REGISTER
         SPM   RCC                 SET REAL CC-PM TO FAKE CC-PM
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
         AIF   (&$PRIVOP).EXSSK    SKIP AND GENERATE RITH CODE-PRIVS OK
EXSSK    EQU   EX0C2               PRIVILEGEDS NOT ALLOWED-FLAG
EXISK    EQU   EX0C2               PRIVILEGEDS NOT ALLOWED-FLAG
         AGO   .EXSVC              SKIP OVER GENERATION OF CODE
.EXSSK   ANOP
EXSSK    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXISK    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
.EXSVC   ANOP
         SPACE 1
EXSVC    L     RWK,ECSVCADS        GET @ SVC CONTROL TABLE,IF EXISTS
         LTR   RWK,RWK             ARE SVC'S ALLOWED
         BZ    EX0C2               NO SVC'S AT ALL,SO ERROR
         IC    RR1,ECI2            GET IMMEDIATE FIELD
         IC    RR1,0(RR1,RWK)      GET SVC OFFSET BYTE TO @ ROUTINE
         SLA   RR1,2               MULT*4 FOR INDEX TO FULLWORDS
         BZ    EX0C2               IF =0,MAKE IT PRIVILEGED OPERATION
         L     RWK,256(RWK)        GET @ SVC ROUTINE @ TABLE
         L     RWK,0(RR1,RWK)      PICK UP ACTUAL @ SVC ROUTINE
         B     EXCALL              GO TO CALL ROUTINE
*        **NOTE** AN SVC CONTROL TABLE IS 260 BYTES LONG, CONTAINING  *
*        256 BYTES OF INDIVIUDAL SVC INDICATORS, AND 1 FULLWORD PTR.  *
         EJECT
*              REGULAR RR INSTRUCTIONS - 3 ENTRIES TO SEQUENCE -      *
*              LR        (SEPARATE SINCE CURRENT CC IS NOT CHANGED)   *
*              NR,CLR,OR,XR,CR,AR,SR,ALR,SLR -   NORMALS              *
*              LPR,LNR,LTR,LCR     (DO NOT NEED R1 LOADED)            *
EXLR     L     RWK,ECREGS(RR2)     GET SECOND OPERAND
         ST    RWK,ECREGS(RR1)     PLACE INTO FIRST OPERAND
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
EXNORMRR L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND
EXLPNTR  L     RR2,ECREGS(RR2)     OBTAIN 2ND OPERAND
         STC   ROP,EXQRR           PLACE ACTUAL OPCODE INTO INST
EXQRR    LR    $CHN+RWK,RR2        **RIGHT OPCODE IS ENTERED IN *******
         ST    RWK,ECREGS(RR1)     SAVE IN FAKE 1ST OPERAND LOCATION
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
         AIF   (&$FLOTEX).EXXFPRR  GO GENERATE CODE IF XFP OK
EXXFPRR  EQU   EX0C1               NOTE XFP NOT ALLOWED
         AIF   (&$FLOTE).EXFPRR    GO GENERATE IF FLOATINGS OK
EXFPRR   EQU   EX0C1               NOTE WE DO NOT ALLOW FLOATINGS
         AGO   .EXFPRR2
.EXXFPRR ANOP
EXXFPRR  EQU   *                   CODE FOR XFP SAME AS REGULAR FP
.EXFPRR  ANOP
         SPACE 2
*              RR FLOATING POINT INSTRUCTIONS.                        *
EXFPRR   SPM   RCC                 SET THE CONDITION CODE
         EX    0,ECOP              EXECUTE THE ACTUAL INSTRUCTION
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
.EXFPRR2 ANOP
         SPACE 2
         AIF   (&$S370 NE 0).EXLONG1 SKIP IF GENERATING S/370'S
EXLONG   EQU   EX0C1               NOTE S/370 RR'S NOT ALLOWED
         AGO   .EXLONG3            SKIP OVER CODE GENERATION
.EXLONG1 ANOP
*        ADDRESS CHECKING CODE FOR CLCL, AND MVCL
EXLONG   EQU   *                   COMMON CODE FOR MVCL, CLCL CHECKING
         TM    ECR1R2,X'11'        DID HE SPECIFY EVEN REGS?
         BNZ   EX0C6               NO--> SPECIFICATION ERROR
         L     R0,EXLONGMK         LOAD MASK TO ZAP TOP OF REGS
         LA    R1,ECREGS(RR1)      GET ADDRESS OF FIRST REGISTER PAIR
         LM    RB1,RB2,0(R1)       LOAD FIRST SET OF REGISTERS
         NR    RB1,R0              GET RID OF UPPER BYTE OF ADDRESS
         NR    RB2,R0              GET RID OF UPPER BYTE OF LENGTH
         BZ    EXLONG2             IF LENGTH = 0, DON'T CHECK ADDRESS
         C     RB1,ECFADL          IS ADDRESS TOO LOW?
         BL    EXLONG1             YES - BRANCH TO CHECK PROTECTION
         LR    RWK,RB1             COPY ADDRESS TO WORK REGISTER
         AR    RWK,RB2             COMPUTE HIGHEST ADDRESS
         C     RWK,ECFADH          IS IT ABOVE MAXIMUM FOR USER?
         BL    EXLONG2             NO - BRANCH AROUND PROTECTION CHECK
EXLONG1  CLI   ECOP,14             IS THIS A MVCL INSTRUCTION
         BE    EX0C4               YES - PROTECTION ERROR
         TM    ECFLAG0,$ECPROT     IS FETCH PROTECT ON?
         BNZ   EX0C4               YES - PROTECTION ERROR
         SPACE 2
*        FIRST ADDRESS OK - CHECK SECOND
EXLONG2  LA    R2,ECREGS(RR2)      GET ADDRESS OF SECOND REG. PAIR
         LM    RR1,RR2,0(R2)       LOAD SECOND SET OF REGISTERS
         NR    RR1,R0              GET RID OF UPPER BYTE AF ADDRESS
         NR    RR2,R0              GET RID OF UPPER BYTE OF LENGTH
         BZ    EXLONG4             IF LENGTH = 0, DON'T CHECK ADDRESS
         C     RR1,ECFADL          IS ADDRESS TOO LOW?
         BL    EXLONG3             YES - BRANCH TO CHECK FOR PROTECTION
         LR    RWK,RR1             COPY ADDRESS INTO WORK REGISTER
         AR    RWK,RR2             COMPUTE HIGHEST ADDRESS
         C     RWK,ECFADH          IS IT ABOVE USER MAXIMUM
         BL    EXLONG4             NO - BRANCH AROUND ERROR CHECK
EXLONG3  TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT ON
         BNZ   EX0C4               YES - PROTECTION ERROR
         SPACE 2
*        BOTH ADDRESSES ARE OK - RELOCATE THEM AND PERFORM COMMAND
EXLONG4  ALR   RB1,RMEM            RE-LOCATE ADDRESS TO ACTUAL
         ALR   RR1,RMEM            RE-LOCATE ADDRESS TO ACTUAL
         SPACE 2
         AIF   (&$S370 NE 1).EXLONG2 SKIP IF NOT ON REAL 370
         L     RB2,4(,R1)          RESTORE UPPER BYTES IN LENGTH REGS
         L     RR2,4(,R2)          RESTORE UPPER BYTES IN LENGTH REGS
         STC   ROP,EXQLONG         STORE IN OPCODE
EXQLONG  CLCL  RB1,RR1             *** OPCODE STORED IN ***
         BALR  RCC,0               CAPTURE COND CODE
         AGO   .EXLONG4
.EXLONG2 ANOP
         CLI   ECOP,14             IS THIS A MVCL COMMAND?
         BE    EXMVCL              YES - BRANCH
         SPACE 2
*        CODE FOR CLCL COMMAND
         LTR   RR2,RR2             SECOND LENGTH = 0?
         BZ    EXCLCL6             YES - BRANCH TO CHECK FIRST LENGTH
         LTR   RB2,RB2             FIRST LENGTH = 0?
         BZ    EXCLCL2             YES - BRANCH TO USE PAD & OPND 2
EXCLCL1  CLC   0(1,RB1),0(RR1)     COMPARE A CHARACTER FROM EACH FIELD
         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH
         LA    RB1,1(,RB1)         INCREMENT POINTERS
         LA    RR1,1(,RR1)         INCREMENT POINTERS
         BCT   RB2,EXCLCL3         DECREMENT FIRST LENGTH, BRANCH = 0
         B     EXCLCL7             LENGTH = 0 - BRANCH INTO PAD LOOP
EXCLCL2  CLC   4(1,R2),0(RR1)      COMPARE PAD TO OPND 2
         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH
         LA    RR1,1(,RR1)         INCREMENT POINTER
EXCLCL7  BCT   RR2,EXCLCL2         DECREMENT SECOND COUNT - BRANCH = 0
         B     EXCLCL5             IF LENGTH = 0, OPNDS = - WE'RE DONE
EXCLCL3  BCT   RR2,EXCLCL1         DECREMENT SECOND LENGTH, BRANCH = 0
EXCLCL4  CLC   0(1,RB1),4(R2)      COMPARE FIRST OPND & PAD
         BNE   EXCLCL5             IF NOT EQUAL, WE ARE DONE - BRANCH
         LA    RB1,1(,RB1)         INCREMENT POINTER
         BCT   RB2,EXCLCL4         DECREMENT LENGTH, BRANCH = 0
EXCLCL5  BAL   RCC,EXLONG5         CAPTURE CON CODE AND RETURN
EXCLCL6  LTR   RB2,RB2             FIRST LENGTH = 0?
         BNZ   EXCLCL4             NO, USE 1ST OPND AND PAD
         BAL   RCC,EXLONG5         GET COND CODE (=0) AND RETURN
         SPACE 2
*        CODE FOR MVCL COMMAND
EXMVCL   EQU   *                   CODE FOR MVCL COMMAND
         LR    R0,RB2              ASSUME FIRST LENGTH SMALLEST
         CR    RB2,RR2             COMPARE THE LENGTHS
         BALR  RCC,0               CAPTURE CON CODE
         BL    *+6                 IF FIRST LOWER, BRANCH
         LR    R0,RR2              SECOND LENGTH MUST BE THE SMALLER
         LTR   R0,R0               IS SMALLEST LENGTH = 0?
         BZ    EXMVCL3             IF SMALLER = 0, BRANCH
         SPACE 2
*        FOLLOWING CODE CHECKS FOR DESTRUCTIVE OVERLAP
         CR    RB1,RR1             IS 1ST FIELD AFTER SECOND?
         BNH   EXMVCL1             NO - NO OVERLAP - BRANCH
         AR    RWK,RMEM            RE-LOCATE HIGH OPND 2 ADDRESS
         CR    RB1,RWK             IS 1ST FIELD AFTER END OF 2ND
         BNL   EXMVCL1             YES - NO OVERLAP - BRANCH
         TM    *+1,1               SET CON CODE TO OVERFLOW (3)
         BAL   RCC,EXLONG5         CAPTURE CON CODE AND RETURN
         SPACE 2
EXMVCL1  SR    RB2,R0              DECREMENT LENGTHS BY THE SMALLER
         SR    RR2,R0              DECREMENT LENGTHS BY THE SMALLER
EXMVCL2  MVC   0(1,RB1),0(RR1)     MOVE A BYTE
         LA    RB1,1(,RB1)         INCREMENT POINTERS
         LA    RR1,1(,RR1)         INCREMENT POINTERS
         BCT   R0,EXMVCL2          DECREMENT LENGTH, IF = 0, BRANCH
EXMVCL3  LTR   RB2,RB2             DO WE NEED PADDING?
         BZ    EXLONG5             NO - WE ARE DONE - BRANCH
         MVC   *+7(1),4(R2)        MOVE PAD CHAR INTO MVI INSTRUCTION
EXMVCL4  MVI   0(RB1),$CHN         MOVE PAD TO FIRST OPRND
         LA    RB1,1(,RB1)         INCREMENT POINTER
         BCT   RB2,EXMVCL4         DECREMENT LENGTH - IF = 0, BRANCH
         SPACE 2
*        COMMON CLCL, MVCL EXIT CODE
EXLONG5  XC    5(3,R1),5(R1)       ZAP LOWER PART OF LENGTH IN CORE
         XC    5(3,R2),5(R2)       ZAP LOWER PART OF LENGTH IN CORE
         O     RB2,4(,R1)          PUT UPPER BYTE BACK INTO REG
         O     RR2,4(,R2)          PUT UPPER BYTE BACK INTO REG
         L     R0,EXLONGMK         GET MASK TO ZAP UPPER BYTE OF REGS
.EXLONG4 ANOP
         SPACE 2
*        OPERATION COMPLETE - RESTORE REGISTERS AND RETURN
         SLR   RB1,RMEM            DE-RELOCATE FINAL ADDRESSES
         SLR   RR1,RMEM            DE-RELOCATE FINAL ADDRESSES
         NR    RB1,R0              ZAP UPPER BYTES OF ADDRESS REGS
         NR    RR1,R0              ZAP UPPER BYTES OF ADDRESS REGS
         STM   RB1,RB2,0(R1)       PUT REGISTERS BACK INTO CORE
         STM   RR1,RR2,0(R2)       PUT REGISTERS BACK INTO CORE
         SR    R2,R2               RESTORE R2 AS BYTE REGISTER
         B     EXFIN               RETURN
.EXLONG3 ANOP
         EJECT
*              RR-RX OVERLAP SECOND-LEVEL PROCESSOR SECTION.          *
         SPACE 1
*              BRANCH AND LINK  (BALR,BAL)                            *
EXBALR   MVI   EXILC,X'40'         SET ILC RIGHT
         LR    RB2,RIA             NO BRANCH WILL OCCUR-SET UP FOR REST
         BZ    EXBAL1              IF R2=0, NO BRANCH WILL OCCUR
         L     RB2,ECREGS(RR2)     BRANCH DOES OCCUR-LOAD ADDR IN
         B     EXBAL1              SKIP CODE TO SET FILC
EXBAL    MVI   EXILC,X'80'         SET ILC UP RIGHT
EXBAL1   N     RCC,=XL4'3F000000'  LEAVE ONLY CC-PM IN REGISTER RCC
         AL    RCC,EXILC           ADD ILC INTO PSW BEING BUILT
         ALR   RIA,RCC             NOW HAVE ILC-CC-PM-IA FILEDS
         ST    RIA,ECREGS(RR1)     PLACE BUILT PSW INTO FAKE REG
         B     EXFINB              BRANCH TAKEN-RETURN
         SPACE 1
*              BRANCH ON COUNT  (BCTR,BCT)                            *
EXBCTR   BNZ   EXBCTR1             IF R2=0,NO BRANCH WILL OCCUR
         L     RWK,ECREGS(RR1)     OBTAIN VALUE OF REGISTER
         BCTR  RWK,0               DECREMENT THE VALUE
         ST    RWK,ECREGS(RR1)     RESTORE IT TO FAKE REGISTER
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
EXBCTR1  L     RB2,ECREGS(RR2)     GET BRANCH ADDRESS IN SAME AS BCT
EXBCT    L     RWK,=F'-1'          PUT -1 IN
         A     RWK,ECREGS(RR1)               ADD VALUE IN (DOING BCT)
         ST    RWK,ECREGS(RR1)     RESTORE DECREMENTED VALUE TO FAKE RG
         BNZ   EXFINB              IF NOT=0, BRANCH IS TAKEN
         B     EXFIN               BRANCH FAILED
         SPACE 1
*              BRANCH ON CONDITION  (BCR,BC)                          *
EXBCR    BZ    EXFIN               IF R2 IS 0, NO BRANCH OCCURS
         L     RB2,ECREGS(RR2)     BRANCH ADDRESS TO FIT WITH BC
EXBC     SLL   RR1,2               GET MASK BACK IN RIGHT SPOT
         SPM   RCC                 SET REAL CC = FAKE CC
         STC   RR1,EXQBC+1         STORE INTO MASK FIELD
EXQBC    BC    $CHN,EXFINB         **MASK STORED IN**
         B     EXFIN               BRANCH FIALED
         SPACE 1
*              MULTIPLY AND DIVIDE  (MR,DR,M,D)                       *
EXMRDR   LA    RB2,ECREGS(RR2)     MAKE ADDRESS COMPATIBLE WITH M-D
EXMD     TM    ECR1R2,X'10'        MAKE SURE R1 IS EVEN SPECIFICATION
         BO    EX0C6               SPECIFICATION ERROR-ODD REGISTER
         LA    RR1,ECREGS(RR1)     OBTAIN ACTUAL ADDRESS OF FAKE R1
         LM    R0,R1,0(RR1)        OBTAIN 2 FAKE REGISTER VALUES
         MVN   EXQMD(1),ECOP       MOVE CODE - SAYS M OR D
EXQMD    M     $CHN+R0,0(RB2)      **CHANGED TO M OR D DURING EXEC*****
         STM   R0,R1,0(RR1)        RESTORE THE REGISTERS TO THE FAKES
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              RX SECOND-LEVEL PROCESSOR SECTION.                     *
*              TO CONDENSE CODE IN RX SECTION, THE CODE BELONGING     *
*        TO THE SECTIONS BEGINNING EXLOADS,EXSTORS,EXLA, AND EXFPRX   *
*        SHOULD BE EQU'D TO EXNORMRX, AND THE ACTUAL CODE OF THOSE    *
*        SECTIONS REMOVED.                                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              RX NORMAL (IC,CH,AH,SH,MH,N,CL,O,X,C,A,S,AL,SL)        *
EXNORMRX L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND
         STC   ROP,EXQNORMR        STORE OPCODE IN
         SPM   RCC                 SET REAL CC = FAKE CC
EXQNORMR IC    $CHN+RWK,0(RB2)     **WILL BE CHANGED TO RIGHT OPCODE***
         ST    RWK,ECREGS(RR1)     PLACE RESULT INTO FAKE REGISTER
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
*              EXECUTE -USES SECTION OF PRIMARY DECODING SECTION      *
EXEX     LH    RWK,0(RB2)          QUICK CHECK FOR ALIGNMENT ERROR
         CLI   0(RB2),X'44'        MAKE SURE NOT AN EXECUTE
         BE    EX0C3               EXECUTE INTERRUPT
         LR    RWK,RB2             PUT ADDRESS WHERE EXPECTED
         MVC   EXEXLEN(2),EXEXBRNC REPLACE ADD BY BR RLINK
         BAL   RLINK,EXFEXENT      GO BACK AND DO COMMON SECTION
         SPACE 1
*              THE FOLLOWING EXECUTED AFTER PRIMARY DECODING DONE     *
         SR    RB2,RMEM            DE-RELOCATE INSTR @
         ST    RB2,ECSTIADD        STORE INTO INSTR STACK FOR DUMP
EXEXOR   MVC   EXEXLEN(2),EXEXLEN2 FIX UP A TO BE ONE AGAIN
         LTR   RR1,RR1             CHECK FOR R1 OPERAND BEING USED
         BZ    EXPRIME+4(R1)       NOTHING TO OR IN-BRANCH
         LA    RB2,ECREGS+3(RR1)   ADDRESS OF LAST BYTE OF GIVEN REG
         OC    ECR1R2,0(RB2)       OR BYTE INTO INSTRUCTION
         B     EXPRIME+4(R1)       TAKE PRIMARY BRANCH
EXEXLEN2 A     RIA,EXILENG(R1)     INST TO REPLACE MODIFIED ONE
         ORG   *-2                 WE ONLY NEED 1ST 2 BYTES OF LAST INS
EXEXBRNC BR    RLINK               WILL BE MOVED IN FOR EXECUTE
         SPACE 1
*              RX LOAD OPERATIONS(NO CC SETTING)  (LH,CVB,L)          *
EXLOADS  STC   ROP,EXQLOAD         STORE OPCODE IN
EXQLOAD  L     $CHN+RWK,0(RB2)     ** OPCODE WILL BE MOVED IN *********
         ST    RWK,ECREGS(RR1)     PLACE RESULT INTO FAKE REG
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
*              RX STORE OPERATIONS  (NO CC SETTING)  (STH,CVD,STC,ST) *
EXSTORS  L     RWK,ECREGS(RR1)     OBTAIN 1ST OPERAND
         STC   ROP,EXQSTORS        STORE OPCODE INTO INST
EXQSTORS ST    RWK,0(RB2)          ** OPCODE WILL BE CHANGED***********
         AIF   (&$S370 NE 2).EXSTORS SKIP IF NOT SIMULATING S/370
         BZ    EXFIN               IF CHECKING ALIGNMENT, RETURN
         MVC   0(8,RB1),EXDUBLWD   PUT ALTERED CORE BACK IN RIGHT PLACE
.EXSTORS ANOP
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
*        LOAD ADDRESS  LA                                             *
EXLA     ST    RB2,ECREGS(RR1)     PUT RESULT IN DESIRED FAKE REGISTER
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         AIF   (&$FLOTEX).EXXFPRX  SKIP IF WE HAVE EXTENDED FP
EXXFPRX  EQU   EX0C1               NOTE INSTRUCTIONS NOT ALLOWED
         AIF   (&$FLOTE).EXFPRX    GO GEN IF FLOATINGS ALLOWED
EXFPRX   EQU   EX0C1               NOTE FLOATINGS NOT ALLOWED
EXFPRXST EQU   EX0C1               NOTE FLOATINGS NOT ALLOWED
         AGO   .EXFPRX2            SKIP OVER GENERATION
.EXXFPRX ANOP
EXXFPRX  EQU   *                   CODE FOR EXTENDED FLOATINGS
.EXFPRX  ANOP
         SPACE 1
*        FLOATING POINT RX INSTRUCTIONS.                              *
EXFPRX   EQU   *                   ODD REG CHECK DONE WITH SPIE
         STC   ROP,EXQFPRX         STORE OPCODE IN
         SLL   RR1,2               GET R1 FIELD BACK INTO PLACE
         STC   RR1,EXQFPRX+1       STORE R1 FIELD INTO INST ALSO
         SPM   RCC                 SET THE CONDITION CODE
EXQFPRX  STD   $,0(,RB2)           **OPCODE AND R1 FIELDS STORED IN****
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         AIF   (&$S370 EQ 2).EXFPRX1 SKIP IF SIMULATING S/370
EXFPRXST EQU   EXFPRX              CODE FOR STORES SAME AS OTHERS
         AGO   .EXFPRX2            SKIP AROUND CODE GENERATION
.EXFPRX1 ANOP
         SPACE 2
*        CODE FOR FLOATING POINT STORES WHEN FAKING ALIGNMENT
EXFPRXST EQU   *                   CODE FOR FLOATING POINT STORES
         STC   ROP,EXQFPRXS        STORE OPCODE IN
         SLL   RR1,2               GET R1 FIELD BACK INTO PLACE
         STC   RR1,EXQFPRXS+1      STORE R1 FIELD INTO INST ALSO
EXQFPRXS STD   $,0(,RB2)           **OPCODE AND R1 FIELDS STORED IN****
         BZ    EXFIN               IF ALIGNMENT CHECKING, RETURN
         MVC   0(8,RB1),EXDUBLWD   PUT ALTERED CORE BACK IN RIGHT PLACE
         B     EXFIN               RETURN
.EXFPRX2 ANOP
         SPACE 2
         AIF   (NOT &$XIOS).EXCONT SKIP IF NO XMACROS
*              XDECO - EXTENDED DECIMAL OUTPUT INSTRUCTION.           *
*        SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO EDITED     *
*        12-BYTE DECIMAL FIELD.  (X'52' OPCODE).                      *
EXXDECO  L     R0,ECREGS(RR1)      GET VALUE OF THE REGISTER
         XDECO R0,0(RB2)           CONVERT THE VALUE
         B     EXFIN               GO FOR NEXT INSTRUCTION
         SPACE 1
*              XDECI - EXTENDED DECIMAL INPUT INSTRUCTION.            *
*        SPECIAL INPUT CONVERTER, SCANS 1-9 DIGIT, SIGNED/UNSIGNED    *
*        DECIMAL NUMBERS WITH ANY # PRECEDING BLANKS. SETS CC TO 0,1,2*
*        ACCORDING TO VALUE OF RESULT.  CC=3 IF >9 DIGITS, OR 1ST     *
*        CHARACTER NOT +, -, DIGIT, OR + OR - WITHOUT DIGIT FOLLOWING.*
*        OPCODE IS HEX '53'  (RX FORMAT).                             *
EXXDECI  XDECI R0,0(RB2)           CONVERT AND SCAN VALUE
         BALR  RCC,0               SAVE THE CC
         BO    *+8                 SKIP STORE IF VALUE WAS BAD
         ST    R0,ECREGS(RR1)      SAVE THE CONVERTED VALUE IF OK
         SR    R1,RMEM             DE-RELOCATE THE SCAN PTR VALUE
         ST    R1,ECREG1           SAVE SCAN PTR IN USER REG 1
         B     EXFIN               GO BACK FOR NEXT INSTR
         SPACE 1
         AIF   (NOT &$HEXI).EXNOHXI    SKIP OF NO XHEXI
*              XHEXI-EXTENDED HEXADECIMAL INPUT INSTRUCTION           *
*        SPECIAL INPUT MACRO, SCANS 1-8 DIGITS.     SKIPS LEADING     *
*        BLANKS. SETS CONDITION CODE TO 3 IF ILLEGAL HEX CHARACTER    *
*        FOUND.  IF GREATER THAN 8 DIGITS FOUND R1 POINTS TO 9TH ELSE *
*        R1 POINTS TO FIRST NON-HEX CHARACTER IN STRING               *
*        (X'61' OPCODE)                                               *
EXXHEXI  XHEXI R0,0(RB2)               CONVERT AND SCAN VALUE
         BALR  RCC,0                   SAVE THE CC
         BO    *+8                     SKIP STORE IF VALUE WAS BAD
         ST    R0,ECREGS(RR1)          STORE CONVERTED VALUE IF OK
         SR    R1,RMEM                 DE-RELOCATE SCAN POINTER VALUE
         ST    R1,ECREG1               SAVE SCAN POINTER IN USER R1
         B     EXFIN                   GO FOR NEXT INSTRUCTION
         AGO   .EXCKHXO                CHECK IF XHEXO ALLOWED
.EXNOHXI ANOP
EXXHEXI  EQU   EX0C1                   INVALID OP-CODE
.EXCKHXO AIF   (NOT &$HEXO).EXNOHXO    SKIP IF NOT XHEXO ALLOWED
*              XHEXO-EXTENDED HEXADECIMAL OUTPUT MACRO                *
*        SPECIAL RX INSTRUCTION CONVERTS REGISTER VALUE TO OUTPUT     *
*        8 BYTE FORM.  (X'62' OPCODE).                                *
EXXHEXO  L     R0,ECREGS(RR1)          GET VALUE OF THE REGISYER
         XHEXO R0,0(RB2)               CONVERT VALUE
         B     EXFIN                   GET NEXT INSTRUCTION
         AGO   .EXCONT
.EXNOHXO ANOP
EXXHEXO  EQU   EX0C1                   INVALID OP CODE
.EXCONT  ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SI SECOND-LEVEL PROCESSOR SECTION                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              ALL NORMAL SI'S - OP  D(B),I2                          *
EXSI     BAL   RLINK,EXRANGE       CHECK ADDRESS FOR IN RANGE
         AR    RB2,RMEM            RELOCATE TO REAL @
         MVC   EXQSI(2),ECOP       MOVE OPCODE AND I2 FIELD IN
         SPM   RCC                 SET REAL CON-CODE= FAKE ONE
EXQSI    TM    0(RB2),$CHN         ** OP AND I2 WILL BE MOVED IN*******
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
         AIF   (&$DEBUG).EXDIAG1   SKIP IF NOT  DEBUG MODE
*              DIAG-PSEUDO SI INSTRUCTION USED FOR DEBUGGING PURPOSES *
EXDIAG   MVC   ECFLAG2,ECI2        SUPPLY CONTROL FLAG TO BYTE
         B     EXFIN               GO BACK FOR NEXT INSTRUCTION
.EXDIAG1 ANOP
         SPACE 1
         AIF   (&$P370).EXLCTL     SKIP IF PRIVILEGED 370'S ALLOWED
EXLCTL   EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED
EXSTCTL  EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED
EXP370   EQU   EX0C2               NO PRIVILEGED 370 OPS ALLOWED
         AGO   .EXNP370            SKIP OVER CODE GENERATION
.EXLCTL  ANOP
EXLCTL   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXSTCTL  BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXP370   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
.EXNP370 ANOP
         AIF   (&$PRIVOP).EXSIO    GENERATE CODE,IF PRIVILEGEDS EXIST
EXSIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXTIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXHIO    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXSSM    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXTCH    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXLPSW   EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXWRD    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
EXRDD    EQU   EX0C2               NO PRIVILEGED OPS ALLOWED
         AGO   .EXNOPRV            SKIP OVER CODE GENERATION
.EXSIO   ANOP
EXSIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXTIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXHIO    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXTCH    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXSSM    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXLPSW   BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXWRD    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
EXRDD    BAL   RLINK,EX0C2C        GO CHECK FOR SUPERVISOR STATE
.EXNOPRV ANOP
         AIF   (&$REPL GT 0).EXNREP0    SKIP IF REPL OPTION ALLOWED
EXXREPL  EQU   EX0C1               NO REPLACEMENT: MAKE ILLEGAL OP
.EXNREP0 AIF   (&$REPL EQ 0).EXNREPL    SKIP IF NO REPLACEMENT
         SPACE 2
EXXREPL  EQU   *                   CODE FOR XREPL COMMAND -REPLACE
         BAL   RLINK,EXRANGE       HAVE @ CHECKED FOR RANGE
         AR    RB2,RMEM            RELOCATE TO REAL @
         SPACE 1
         CLI   ECI2,0              WAS IT SET RFLAG TYPE XREPL
         BH    EXXREPL1            NO, SKIP TO NEXT TYPE
         MVC   ECRFLAG,0(RB2)      SET RFLAG FROM USER LOCATION
         B     EXFIN               GO FOR NEXT INSTR
         SPACE 1
EXXREPL1 CLI   ECI2,1              WAS IT FETCH RFLAG TYPE
         BH    EXXREPL2            NO, SKIP TO NEXT TYPE
         MVC   0(L'ECRFLAG,RB2),ECRFLAG     FETCH THE FLAG TO USER AREA
         B     EXFIN               GO FOR NEXT INSTR
         SPACE 1
EXXREPL2 CLI   ECI2,2              WAS IT INSTRUCTION COUNT
         BH    EXXREPL3            NO, GO ON TO NEXT
         MVC   0(4,RB2),ECILIMT    MOVE TEMPORARY INSTRUCTION COUNT OVE
         B     EXFIN               GO FOR NEXT INSR
EXXREPL3 EQU   EXFIN               ILLEGAL I2 FIELD, IGNORE.
.EXNREPL ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              RS SECOND-LEVEL PROCESSOR SECTION.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              BRANCH ON INDEX  (BXH,BXLE)                            *
EXRSBX   BAL   RLINK,EXR1R2        GO DECODE R1-R3 FIELDS
         L     R0,ECREGS(RR3)      OBTAIN REGISTER SPECIFIED BY R3 FLD
         L     R1,ECREGS+4(RR3)    GET NEXT REGISTER BEYOND
         TM    ECR1R3,X'1'         WAS REGISTER ODD
         BZ    *+6                 IF EVEN REG,SET UP OK,SKIP NEXT INST
         LR    R1,R0               R3 WAS ODD-SO USE SAME VALUE
         STC   ROP,EXQRSBX         STORE OPCODE INTO INSTRUCTION
         L     RWK,ECREGS(RR1)     OBTAIN R1 FIELD VALUE
EXQRSBX  BXH   $CHN+RWK,R0,EXRSBX1 ** CHANGED TO EITHER BXH-BXLE*******
         ST    RWK,ECREGS(RR1)     BRANCH FAILED-BUT STORE REG BACK
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
EXRSBX1  ST    RWK,ECREGS(RR1)     RESTORE UPDATED REGISTER
         B     EXFINB              GO TO FINISH-SUCC BRANCH
         SPACE 1
*              LOAD/STORE MULTIPLE (LM,STM) *CODE MAY NOT BE OBVIOUS* *
EXLMSTM  BAL   RLINK,EXR1R2        GET R1 AND R3 FIELDS
         AIF   (&$S370 NE 2).EXLMSTM SKIP IF NOT SIMULATING S/370
         TM    ECFLAG4,AJONALGN    SHOULD ALIGNMENT BE CHECKED
         BO    *+8                 NO - BRANCH AROUND CHECK
.EXLMSTM ANOP
         L     R0,0(RB2,RMEM)      QUICK CHECK FOR FULLWORD ALIGNMENT
         LA    R1,4(RR3)           OBTAIN  1 PART OF LENGTH VALUE
         CR    RR1,RR3             IS R1 FIELD <= R3 FIELD
         BNH   EXLMSTM1            SKIP OVER IF EASY CASE(R1<R3)
         SPACE 1
         LR    R2,R1               R2 NOW = (RR3)+4
         LA    R1,64               OBTAIN VALUE
         SR    R1,RR1              R1 = 64-(RR1)
         B     EXLMSTM2            PROPER LENGTHS SET UP IN R1,R2
         SPACE 1
EXLMSTM1 SR    R1,RR1              R1 = (RR3)-(RR1)+4 - 1ST,ONLY LENGTH
         SR    R2,R2               CLEAR 2ND LENGTH,SINCE ONLY 1 USED
EXLMSTM2 BAL   RLINK,EXRANGE       CHECK FOR PROTECTION VIOLATION
         AR    RB2,RMEM            RELOCATE @ TO REAL CORE @
         LA    RWK,ECREGS(RR1)     ADDR OF 1ST (OR ONLY) REG SEGMENT
         SPACE 1
         SR    RB1,RB1             CLEAR FOR USE AS INDEX
         CLI   ECOP,X'90'          WAS INST STM
         BE    *+8                 YES,WAS STM,SO RB1 SET RIGHT
         LA    RB1,6               LM - SET FOR EXECUTE INDEX
         SPACE 1
         BCTR  R1,0                DECREMENT SINCE SS INST NEEDEDS IT
         EX    R1,EXQLMSTM(RB1)    EXECUTE MVC IN CORRECT DIRECTION
         CR    RR1,RR3             WAS R1 <= R3 FIELD
         BNH   EXFIN               RETURN IF NO MORE TO DO
         SPACE 1
         LA    RB2,1(R1,RB2)       2ND CORE SEGMENT ADDRESS
         LA    RWK,ECREGS          ADDR OF 2ND REG SECTION(FAKE R0)
         BCTR  R2,0                DECRMENT TO PLEASE MVC
         EX    R2,EXQLMSTM(RB1)    EXECUTE RIGHT MVC
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
EXQLMSTM MVC   0($CHN,RB2),0(RWK)  MVC FOR STM - MEMORY <---- REGISTERS
         MVC   0($CHN,RWK),0(RB2)  USED FOR LM - REGISTERS <---- MEMORY
         SPACE 1
*              ALL SHIFT INSTRUCTIONS-SEPARATE ENTRIES SINGLE OR DOUBL*
*              DOUBLE SHIFTS ENTER AT EXSHIFD,SINGLES AT EXSHIFS      *
EXSHIFD  TM    ECR1R3,X'10'        IS 1ST REGISTER SPECIFIED EVEN
         BO    EX0C6               ODD REGISTER SPEC-SPECIFICATION ERRO
EXSHIFS  IC    R2,ECR1R3           OBTAIN REGISTER BYTE
         SRL   R2,4                SHIFT TO LEAVE ONLY R1 FIELD
         SLL   R2,2                MULT*4 FOR FULLWORD INDEX TO REG
         LA    RR1,ECREGS(R2)      GET @ FAKE REGISTER DESIRED
         LM    R0,R1,0(RR1)        GET REG PAIR(NOT REALLY FOR S SHIFT)
         STC   ROP,EXQSHIF         PLACE SHIFT OPCODE INTO INST
         SPM   RCC                 SET THE REAL CON-CODE= FAKE ONE
EXQSHIF  SRL   $CHN+R0,0(RB2)      SHIFT ***CHANGED DURING EXEC********
         STM   R0,R1,0(RR1)        REPLACE REGISTER PAIR
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 2
         AIF   (&$S370 NE 0).EXMASK1 SKIP IF WE WANT S/370 INSTRUCTIONS
EXSTCM   EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED
EXICM    EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED
EXCLM    EQU   EX0C1               NOTE INSTRUCTION NOT ALLOWED
.EXMASK1 AIF   (&$S370 NE 1).EXMASK2 SKIP IF WE DON'T HAVE 370 HARDWARE
*        CODE FOR ICM, STCM, AND CLM INSTRUCTIONS ON S/370
EXSTCM   EQU   *                   CODE FOR STCM COMMAND
EXICM    EQU   *                   CODE FOR ICM  COMMAND
EXCLM    EQU   *                   CODE FOR CLM  COMMAND
         BAL   RLINK,EXRANGE       GO CHECK FOR PROTECTION ERROR
         AR    RB2,RMEM            RELOCATE TO REAL ADDRESS
         BAL   RLINK,EXR1R2        GO GET R1-M3 FIELDS
         L     R0,ECREGS(RR1)      GET REGISTER
         SRL   RR2,2               MOVE MASK BACK TO PROPER LOCATION
         STC   ROP,EXQRS370        STORE OPCODE IN INSTRUCTION
         SPM   RCC                 SET REAL CON CODE TO FAKE ONE
         EX    RR2,EXQRS370        EXECUTE INSTRUCTION, GIVING MASK
         ST    R0,ECREGS(RR1)      PUT REGISTER BACK INTO CORE
         BAL   RCC,EXFIN           GET CON CODE AND RETURN
EXQRS370 ICM   R0,0,0(RB2)         ***OPCODE CHANGED DURING EXECUTION**
.EXMASK2 AIF   (&$S370 NE 2).EXMASK3 SKIP IF NOT SIMULATING S/370
*        CODE FOR STCM UNDER S/360 SIMULATION
EXSTCM   EQU   *                   CODE FOR STCM COMMAND
         BAL   RLINK,EXRANGE       GO CHECK RANGE OF ACCESS
         BAL   RWK,EXMASK          GO TO COMMON MASK CODE
         MVC   0(1,RB2),0(RB1)     INSTRUCTION EXECUTED BY EXMASK
         B     EXFIN               WHEN EXMASK RETURNS, WE ARE DONE
         SPACE 2
*        CODE FOR ICM UNDER S/360 SIMULATION
EXICM    EQU   *                   CODE FOR ICM COMMAND
         BAL   RLINK,EXRANGE       GO CHECK RANGE OF ACCESS
         BAL   RWK,EXMASK          GO TO COMMON MASK CODE
         MVC   0(1,RB1),0(RB2)     INSTRUCTION EXECUTED BY EXMASK
         SR    RB2,R1              RB2 = # OF BYTES MOVED INTO REGISTER
         BZ    EXICM1              IF ZERO, CON CODE IS 0. QUIT.
         TM    0(R1),X'80'         CHECK FOR 'SIGN BIT' ON
         BO    EXICM2              IF ON, BRANCH TO SET CON CODE TO -
         BCTR  RB2,0               GET LENGTH-1
         EX    RB2,EXICM3          ITS + OR 0, SO COMPARE TO ZERO
EXICM1   BAL   RCC,EXFIN           GET CON CODE AND RETURN
EXICM2   OI    *+1,1               SET CON CODE TO -
         BAL   RCC,EXFIN           GET CON CODE AND RETURN
EXICM3   CLC   0(0,R1),=F'0'       INSTRUCTION TO COMPARE BYTES TO 0
         SPACE 2
*        CODE FOR CLM UNDER S/360 SIMULATION
EXCLM    EQU   *                   CODE FOR CLM COMMAND
         BAL   RLINK,EXRANGE       CHECK ADDRESS BEFORE CHANGING BRANCH
         MVI   EXMSKC,E*16         MAKE BRANCH INTO BNE FOR CLM ONLY
         BAL   RWK,EXMASK+4        GO TO MASK CODE, SKIPPING @ CHECKING
         CLC   0(1,RB1),0(RB2)     INSTRUCTION EXECUTED BY EXMASK
         BAL   RCC,EXFIN           CAPTURE CON-CODE AND RETURN
         SPACE 2
*        COMMON CODE FOR ICM, STCM, AND CLM WITH S/360 SIMULATION
EXMASK   EQU   *                   COMMON CODE FOR S/370 RS INSTRUCTION
         MVI   EXMSKC,X'F0'        MAKE SURE BRANCH IS B NOT BNE
         AR    RB2,RMEM            RELOCATE ADDRESS TO REAL @
         LR    R1,RB2              COPY FOR POSSIBLE LATER USE
         BAL   RLINK,EXR1R2        GET R1-M3 FIELDS
         SLL   RR2,26              MOVE LEFTMOST MASK BIT TO SIGN POS
         LA    RB1,ECREGS-1(RR1)   GET @-1 OF IN CORE REGISTER
         SPACE 2
EXMSK1   LA    RB1,1(,RB1)         INCREMENT REGISTER POINTER
         ALR   RR2,RR2             SHIFT MASK LEFT 1 BIT
         BM    EXMSK1              NO CARRY, NZ=>MOVE TO DO NR
         BZ    6(,RWK)             IF 0, WE ARE ALL DONE, RETURN
         EX    0,0(,RWK)           PERFORM SUPPLIED OPERATION
         LA    RB2,1(,RB2)         INCREMENT CORE AREA POINTER
EXMSKC   EQU   *+1                 POSITION OF MASK CHANGED BY CLM
         BC    $+15,EXMSK1         USUALLY BRANCH TO LOOP (BE FOR CLM)
         B     6(,RWK)             IF UNEQUAL COMPARE FOR CLM, RETURN
.EXMASK3 ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              SS SECOND-LEVEL PROCESSOR SECTION.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              MOVES,TR,PACK - CHANGE NEITHER CC NOR REGISTERS.       *
EXMOVS   DS    0H                  LOCATION FOR MOVES,ETC
EXQSS    MVN   0($CHN,RB1),0(RB2)  **OPCODE AND LENGTH MOVED IN **
         B     EXFIN               RETURN FOR NEXT INSTRUCTION
         SPACE 1
*              LOGICALS AND DECIMALS - MAY CHANGE CC,BUT NOT REGS     *
EXLOGS   SPM   RCC                 SET REAL CC = FAKE ONE
EXDECS   EQU   EXLOGS              SAME AS LOGS IF DECIMAL FEATURE IN
         EX    0,EXQSS             EXECUTE PREPARED INST
         BAL   RCC,EXFIN           GET CC, RETURN FOR NEXT INST
         SPACE 1
*              TRT AND EDMK -CHANGE CC,POSSIBLY REGISTERS 1&2         *
EXTRT    LM    R1,R2,ECREG1        GET FAKE R1,R2
EXEDMK   EQU   EXTRT               SAME AS TRT,IF DECIMAL FEATURE USED
         LA    R1,0(R1)            CLEAR UPPER BYTE FOR SAFETY
         ALR   R1,RMEM             RELOCATE TO REAL @, IN CASE CHANGED
         EX    0,EXQSS             EXECUTE PREPARED INSTRUCTION
         BALR  RCC,0               PICK UP CHANGED CONDITION CODE
         SLR   R1,RMEM             CONVERT BACK TO FAKE @
         XC    ECREG1+1(3),ECREG1+1         CLEAR 3 BYTES OF FAKE R1
         O     R1,ECREG1           GET FAKE R1 BACK TOGETHER
         STM   R1,R2,ECREG1        REPLACE FAKE REGS R1 AND R2
         SR    R2,R2               CLEAR FOR BYTE REGISTER AGAIN
         B     EXFIN               GO FOR NEXT INSTRUCTION
         AIF   (&$S370 NE 0).EXSRP1 SKIP IF WE HAVE S/370'S
         SPACE 2
EXSRP    EQU   EX0C1               NOTE SRP NOT ALLOWED
         AGO   .EXSRP3             SKIP OVER CODE GENERATION
.EXSRP1  SPACE 2
*        CODE FOR SRP (SHIFT AND ROUND PACKED) S/370 COMMAND
EXSRP    EQU   *                   CODE FOR SRP
         SR    RB2,RMEM            REMOVE RE-LOCATION DONE EARLIER
         AIF   (&$S370 NE 1).EXSRP2 SKIP IF WE DO NOT HAVE 370 HARDWARE
         B     EXDECS              REST OF CODE SAME AS ALL DECIMALS
.EXSRP2  AIF   (&$S370 NE 2).EXSRP3 SKIP IF NOT SIMULATING S/370'S
         IC    RR1,ECL1I3          GET LENGTH AND IMMEDIATE
         N     RR1,EXSRPMK         REMOVE IMMEDIATE FIELD
         LR    RR2,RR1             COPY (LENGTH OF FIELD) * 4
         SRL   RR1,4               GET LENGTH
         OR    RR2,RR1             SET UP REG WITH 2 LENGTHS
         SPACE
         MVO   EXSRPDA1(1),ECL1I3(1) MOVE IMMEDIATE OVER
         ZAP   EXSRPDA1(1),EXSRPDA1(1) CHECK IMMEDIATE
         EX    RR1,EXSRPZP1        CHECK USERS NUMBER
         BZ    EXSRPLF5            IF NUMBER = 0, WERE DONE
         SPACE
         SLL   RB2,26              EXTEND BIT 26 AS IF
         SRA   RB2,26                   IT IS A SIGN BIT
         BZ    EXSRPLF3            IF SHIFT IS ZERO, WERE DONE
         BP    EXSRPLF             IF SHIFT IS POSITIVE,IT'S LEFT SHIFT
         SPACE 2
EXSRPRT  LPR   RB2,RB2             MUST BE RIGHT SHIFT, GET + SHIFT
         B     EXSRPRT2            BRANCH INTO LOOP
EXSRPRT1 MVO   EXSRPDA2(16),EXSRPDA2(15) SHIFT ALL BUT LAST NIBBLE
EXSRPRT2 BCT   RB2,EXSRPRT1        DECREMENT COUNT AND BRANCH
         SLL   RR1,4               SHIFT LENGTH TO L1 FIELD
         MVN   EXSRPDA2+15(1),EXSRPDA1 MAKE SIGN POSITIVE
         AP    EXSRPDA2(16),EXSRPDA1(1) ADD IN ROUNDING FACTOR
         EX    RR1,EXSRPMV1        MOVE TO USER, DOING LAST SHIFT
         B     EXSRPLF3            GO TO SET COND CODE AND RETURN
         SPACE 2
EXSRPLF  LA    RWK,0(RR1,RB1)      GET @ LAST BYTE OF USER NUMBER
         STC   RR2,EXSRPLF2+1      PUT LENGTH INTO MVO INSTR
         OI    *+1,0               SET COND CODE TO ZERO
EXSRPLF1 BNZ   EXSRPLF2            HAS OVRFLOW OCCURRED? BRANCH IF SO
         TM    0(RB1),X'F0'        CHECK FIRST NIBBLE FOR NON-ZERO
EXSRPLF2 MVO   0($CHN,RB1),0($CHN,RB1) SHIFT LEFT (LENGTHS STORED IN)
         MVZ   0(1,RWK),=PL1'0'    MOVE ZERO TO PROPAGATED SIGN
         BCT   RB2,EXSRPLF1        DECREMENT COUNT AND BRANCH
         BNZ   EXSRPLF4            OVERFLOW SO BRANCH TO CHECK FOR 0CA
EXSRPLF3 EX    RR2,EXSRPZP2        SET COND CODE FOR +, -, OR 0
         BAL   RCC,EXFIN           CAPTURE COND CODE AND RETURN
EXSRPLF4 TM    ECSTCCPM,X'04'      CHECK MASK BIT
         BO    EX0CA               OVERFLOW HAS OCCURED--> ERROR
         TM    *+1,1               SET COND CODE TO OVRFLOW
EXSRPLF5 BAL   RCC,EXFIN           CAPTURE COND CODE AND RETURN
         SPACE
EXSRPZP1 ZAP   EXSRPDA2(16),0($CHN,RB1) CHECK AND MOVE USER NUMBER
EXSRPZP2 ZAP   0($CHN,RB1),0($CHN,RB1) SET COND CODE TO +, -, OR 0
EXSRPMV1 MVO   0($CHN,RB1),EXSRPDA2(15) MOVE BACK TO USERS AREA
.EXSRP3  ANOP
         EJECT
         AIF   (&$XIOS).EXXIOS     SKIP TO GENERATE CODE IF EXISTS
EXXIOS   EQU   EX0C1               THESE INSTRUCTIONS DO NOT EXIST
         AGO   .EXNOXIO
.EXXIOS  ANOP
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        PSEUDO RX-SS EXTENDED MNEMONICS-XREAD,XPRNT,XPNCH I/O'S      *
*              PSEUDO DUMP ROUTINE - XDUMP                            *
*        **NOTE** BECAUSE OF NO-STANDARD ADDRESSING DONE BY THESE     *
*        INSTRUCTIONS, THEY DO THEIR OWN ADDRESS CHECKING, AND THUS   *
*        HAVE A PROTECTION BYTE OF X'00' SO THE INITIAL SS SECTION    *
*        DOESN'T STOP THEM.  THEY THEN FAKE THE PROTECTION BYTES OF   *
*        EITHER STM(X'C0' -XREAD), OR TM(X'80' - XPRNT,XDUMP,XPNCH).  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
EXXIOS   EQU   *                   SECTION FOR X-MACRO I/O INSTRUCTIONS
         N     RCC,=XL4'3F000000'  REMOVE ALL BUT CC-PM BITS
         ALR   RCC,RIA             PUT CC-PM-PROG ADDRESS TOGETHER
         ST    RCC,ECILCMSK        STORE RESULTING PSW
         OI    ECILCMSK,X'C0'      SET ILC=3, FOR LENGTH OF X-INST
         CLI   ECOP,X'E1'          SEE IF IT WAS REGS TYPE XDUMP
         BE    EXXDUMPR            YES,SO GO DUMP REGS ONLY
         SR    RB2,RMEM            REMOVE SPURIOUS RELOCATION
         BNZ   EXXLOK              LENGTH OK IF NOT ZERO
         L     RB2,ECREGS          GET VALUE OF FAKE 0
EXXLOK   BAL   RLINK,EXR1R2        GET MASK AND INDEX VALUE
         BZ    EXXNOX2             SKIP IF NO INDEX REG USED
         AL    RB1,ECREGS(RX2)     ADD INDEX VALUE TO ADDRESS
         LA    RB1,0(RB1)          CHOP OFF 1ST BYTE
EXXNOX2  EQU   *
         LR    RR2,RB2             SAVE THE LENGTH TO BE DONE
         LR    RB2,RB1             LOAD ADDRESS OVER FOR RANGECHK
         SR    RB2,RMEM            GET CHECKABLE RANGE
         LA    ROP,X'98'           FAKE PROTECT LIKE LM INSTRC        A
         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED
         SRL   RR1,3               GET MASK VALUE IN PLACE FOR INDEX
         ALR   RR1,RR1             SHIFT LEFT FOR MULT OF TWO
         LH    R1,EXXIOJ(RR1)      GET ADDRESS VALUE
         B     EXJUMP(R1)          GO TO RIGHT SECTION OF CODE
         AIF   (NOT &$JRM).EXNOJRM SKIP IF NO JRM SPECIAL CODE
         ORG   *-4                 ORG BACK OVER B EX0C1 INSTR
         TM    ECFLAG3,$EC$JRM     WAS SPECIAL JRM DEBUG FLAG SET
         BZ    EX0C1               NO, MUST HAVE BEEN REAL ERROR
         SPACE 1
*              SPECIAL DEBUG CODE ENTERED ONLY WHEN JRM SUBMITS JOB
*              WITH CORRECT NAME/ACCT NUMBER, MODIFIES XREAD TO HAVE
*              MASK FIELD TOO LARGE FOR NORMAL CORRECTNESS.
*              IT CAUSES THE USER PROGRAM TO BE CALLED DIRECTLY:
*   R1 = ADDRESS OF SPECIAL ADDRESS LIST:  A(ASSIST,ASJOBCON,VWXTABL)
*   R6(REC) = @ ECONTROL BLOCK, MAY NOT BE CHANGED BY USER PROGRAM.
*   R14,R15  NORMAL OS/360 CONVENTIONS
         LR    RWK,RB1             MOVE ADDR OVER WHERE HE EXPECTS
         LA    R1,=A(ASSIST,ASJOBCON,VWXTABL)    USEFUL @'S
         B     EXCALL              GO TO GENERAL CALL ROUTINE
.EXNOJRM ANOP
         SPACE 1
*              XREAD PSEUDO-INSTRUCTION - READ A CARD.                *
EXXREAD  TM    ECFLAG0,$ECEOF      HAS THERE BEEN EOF ALREADY
         BO    EXXREOF             YES, USER TRYING TO GO PAST
         LA    ROP,X'90'           FOR PROTECT CHECK
         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED
         $READ 0(RB1),(RR2),EXXREOFA
         BAL   RCC,EXXIEND         GO TO FINISH UP
EXXREOFA OI    ECFLAG0,$ECEOF      FLAG END OF FILE
         BAL   RCC,EXXIEND         GO TO END UP
         SPACE 1
EXXREOF  MVI   ECFLAG1,$ECREADR    SHOW READ BEYOND END-OF-FILE ERROR
         LA    R1,EXCCREAD         SHOW END-FILE
         B     EXITIA              GO TO EXIT ROUTINE
         SPACE 1
*              XPRNT PSEUDO-INSTRUCTION- PRINT A LINE.                *
EXXPRNT  $PRNT 0(RB1),(RR2),EXXRECEX
         B     EXXIEND
         SPACE 1
*              XPNCH PSEUDO-INSTRUCTION - PUNCH A CARD.               *
EXXPNCH  $PNCH 0(RB1),(RR2),EXXRECEX
         B     EXXIEND             DO COMMON EXIT
         AIF   (&$XXIOS).EXXIOS1   SKIP IF NOT ALLOWED XGET-XPUT
EXXGET   EQU   *                   XGET PSEUDO INSTRUCTION - DO INPUT
         LA    ROP,X'90'           FOR PROTECT CHECK
         BAL   RLINK,EXRANGE       HAVE ADDRESS-LENGTH CHECKED
         $GET  0(RB1),(RR2)
         BAL   RCC,EXXIEND         GO TO FINISH UP
EXXPUT   EQU   *                   XPUT PSEUDO INSTRUCTION - DO OUTPUT
         $PUT  0(RB1),(RR2)
         BAL   RCC,EXXIEND         GO TO FINISH UP
         AGO   .EXXIOS2            SKIP LABEL SAVING
.EXXIOS1 ANOP                      SAVE LABELS
EXXGET   EQU   *
EXXPUT   EQU   *
.EXXIOS2 ANOP
EXXIEND  EQU   EXFIN               COMMON EXIT-SAME AS EXFIN
         SPACE 1
EXXRECHK CLI   ECFLAG1,$ECRECEX    DID XXXXSNAP SET FLAG
         BNE   EXFIN               NO, SO DON'T BOMB USER OUT
EXXRECEX MVI   ECFLAG1,$ECRECEX    RECORDS EXCEEDED
         LA    R1,EXCCRECE         SHOW RECORDS EXCEEDED MESSAGE
         B     EXITIA              GO FINISH UP AND RETURN
         SPACE 1
*              XDUMP PSEUDO-INSTRUCTION - DUMP STORAGE OR REGISTERS.  *
EXXDUMP  EQU   *                   ENTRY LABEL FOR STORAGE XDUMP
         LR    RB2,RB1             MOVE BEGINNING @, SINCE RB1=R10
         LR    R10,REC             MOVE ECONTROL PTR OVER FOR XXXXSNAP
         XSNAP T=(NO,,1),LABEL='USER STORAGE',                         X
               STORAGE=(*0(RB2),*0(RR2,RB2))
         B     EXXRECHK            GO CHECK FOR RECORD OVERFLOW
         SPACE 1
EXXDUMPR LR    R10,REC             MOVE ECONTROL PTR OVER FOR XXXXSNAP
         XSNAP T=(PR,,1),LABEL='USER REGISTERS'
         B     EXXRECHK            GO CHECK FOR RECORD OVERFLOW
         SPACE 1
*              XLIMD PSUEDO INSTRUCTION - LIMIT DUMP AREA.            *
EXXLIMD  LA    RB2,0(RR2,RB1)      GET 2ND LIMIT, REAL @ OF IT
         BCT   RR2,*+8             IF RR2=1(OMITTED) USE END OF PROG
         L     RB2,ECRADH          LENGTH=1, USE HIGHEST @ INSTEAD
         STM   RB1,RB2,ECRDLIML    ECRDLIML-ECRDLIMH - NEW LIMTS
         B     EXFIN               GO FOR NEXT INSTRUCTION
         SPACE 1
EXXIOJ   $AL2  EXJUMP,(EXXREAD,EXXPRNT,EXXPNCH,EXXDUMP,EXXLIMD,EXXGET,EX
               XXPUT,EX0C1)
.EXNOXIO ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        UTILITY (3RD LEVEL) DECODING,ADDRESS ADDING,AND CHECKING     *
*   ROUTINES. THESE ARE CALLED BY THE 1ST AND 2ND LEVEL PROCESSORS    *
*        THESE ROUTINE ARE ONLY USED DURING ACTUAL INTERPRETATION.    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        *** ADDRESS ADDER *** OBTAINS BASE-DISPLACEMENT,DECODES,AND  *
*        RETURNS PROGRAM RELATIVE ADDRESS IN RB2.  USES RW.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
EXABD    LH    RB2,ECBD            OBTAIN 1ST BASE-DISPLACEMENT
EXABD1   LR    RWK,RB2             DUPLICATE B-D OVER
         N     RB2,=XL4'FFF'       REMOVE BASE,LEAVING DISPLACEMENT
         N     RWK,=XL4'F000'      REMOVE DISPLACEMENT,LEAVE BASE
         BCR   Z,RLINK             IF NO BASE-DONE,RETURN TO CALLER
         SRL   RWK,10              SHIFT TO GET BASE*4 FOR INDEX
         AL    RB2,ECREGS(RWK)     ADD VALUE FROM RIGHT FAKE REGISTER
         LA    RB2,0(RB2)          CHOP OFF FRONT BYTE
         BR    RLINK               RETURN TO CALLER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        ***  DOUBLE REGISTER DECODER - PLACES R1 AND (R2-X2-R3)      *
*        FIELDS MULTIPLIED BY 4 INTO REGS RR1 AND RR2 RESPECTIVELY.   *
*        THE CONDITON CODE IS SET ACCORDING TO PRESENCE OF NON-ZERO   *
*        SECOND REGISTER FIELD                                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXR1R2   IC    RR1,ECR1R2          OBTAIN 2ND BYTE OF INST
         LR    RR2,RR1             DUPLICATE VALUE TO OTHER REG
         N     RR1,=XL4'F0'        REMOVE 2ND REG,LEAVING 1ST ONLY
         SRL   RR1,2               GET R1 FIELD*4,FOR INDEXING USE
         SLL   RR2,2               PREPARE R2-X2-R3 FIELD FOR INDEX
         N     RR2,=XL4'3C'        REMOVE EXTRA BITS,SET CCODE
         BR    RLINK               RETURN TO CALLER
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        *** RANGE CHECKING ROUTINE - CHECKS THE ADDRESS PROVIDED IN  *
*        RB2 FOR BEING WITHIN THE ALLOWABLE RANGE.  THE METHOD USED   *
*        DEPENDS ON THE FACT THAT AN EXTRA 256 BYTES OF CORE WAS      *
*        ALLOCATED AT THE END OF THE USER PROGRAM,SO THAT THERE IS    *
*        NO NEED TO CHECK USING THE LENGTH OF CODE AFFECTED BY THE    *
*        INSTRUCTION.   THIS ROUTINE USES REGISTER RWK.               *
*        ENTRY CONDITIONS                                             *
*   RB2= PROGRAM ADDRESS TO BE CHECKED FOR RANGE (ECFADL<=@<ECFADH)   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EXRANGE  C     RB2,ECFADL          IS ADDRESS TOO LOW
         BL    EXRADDL             YES-ERROR
         C     RB2,ECFADHC         COMP WITH ACTUAL HI LIM(ECFADH-256)
         BCR   L,RLINK             RETURN IF LEGAL
         SPACE 1
*              ADDRESS OUT OF RANGE.  IF INSTRUCTION MODIFES STORAGE, *
*        IT IS DEFINITE ERROR.  IF IT FETCHES, AND THE ABSOLUTE       *
*        PROTECT FLAG IS ON, IT IS AN ERROR, OTHERWISE IT IS OK.      *
EXRADDL  LA    RWK,EXIPROT-64(ROP) GET THE @ PROTECTION CONTROL BYTE
         TM    0(RWK),EXPRSTOR+EXPRFETC     ANY CORE ACCESS AT ALL
         BO    EXRANOUT            YES,WOULD CHANGE,SO DEFNITE ERROR
         SPACE 1
         BCR   Z,RLINK             NO STORAGE ACCESS, SO @ IS OK
         TM    ECFLAG0,$ECPROT     IS ABSOLUTE PROTECT MODE ON
         BCR   Z,RLINK             NO,SO RETURN,LET USER TRY TO ACCESS
         SPACE 1
*              ADDRESS DEFINITELY ILLEGAL.  MAKE SURE THAT THE OPCODE *
*        ITSELF WAS LEGAL, GIVING AN 0C4 COMPLETION IF SO, AND AN 0C1 *
*        IF THE OPCODE WAS NOT LEGAL ANYWAY (THIS MAY OCCUR SINCE THE *
*        CHECK FOR LEGAL OPCODE IS NOT MADE UNTIL THE 2ND LEVEL       *
*        BRANCH TO INDIVIDUAL PROCESSING SECTIONS.)                   *
EXRANOUT LA    RWK,EXOPTAB1(ROP)   GET @ OPCODE INDEX BYTE
         CLI   0(RWK),0            MAKE SURE THE OPCODE IS LEGAL
         BNZ   EX0C4               IT WAS LEGAL,THEREFORE PROTECTION
         B     EX0C1               NOT LEGAL, ==> OPERATION
         EJECT
         SPACE 4
* * * * * SECONDARY TYPE INDEX BRANCH ADDRESS TABLES  * * * * * * * * *
         SPACE 1
EXSECRR  $AL2  EXJUMP,(EX0C1,EXSPM,EXBALR,EXBCTR,EXBCR,EXSSK,EXISK,EXSV#
               C,EXLPNTR,EXNORMRR,EXLR,EXMRDR,EXFPRR,EXXFPRR,EXLONG)
EXSECRX  $AL2  EXJUMP,(EX0C1,EXLA,EXBAL,EXBCT,EXBC,EXNORMRX,EXMD,EXLOAD#
               S,EXSTORS,EXFPRX,EXFPRXST,EXXFPRX,EXEX,EXXDECI,EXXDECO,E#
               XXHEXI,EXXHEXO)
EXSECSI  $AL2  EXJUMP,(EX0C1,EXSSM,EXLPSW,EXWRD,EXRDD,EXRSBX,EXLMSTM,EX#
               SHIFS,EXSHIFD,EXSI,EXSIO,EXTIO,EXHIO,EXTCH,EXCLM,EXSTCM,#
               EXICM,EXLCTL,EXSTCTL,EXP370,EXXREPL)
EXSECSS  $AL2  EXJUMP,(EX0C1,EXMOVS,EXLOGS,EXTRT,EXEDMK,EXDECS,EXXIOS,E#
               XSRP)
         SPACE 1
*              OFFSETS TO COMPLETION CODE MESSAGES                    *
EXCOFFS  $AL2  EXCC0,(EXCC1,EXCC2,EXCC3,EXCC4,EXCC5,EXCC6,EXCC7,EXCC8,E#
               XCC9,EXCCA,EXCCB),-2    STANDARD INTERRRUPT PTRS
         AIF   (NOT &$FLOTE).EXFL6 SKIP IF NO FLOATING INERRUPTS
         $AL2  EXCC0,(EXCCC,EXCCD,EXCCE,EXCCF)   FLOATING INTERRUPTS
.EXFL6   ANOP
EXCC0    EQU   *                   BASE @ FOR COMPLETION MESSAGES
EXCC1    $ERCGN 0C1,'OPERATION'
EXCC2    $ERCGN 0C2,'PRIVILEGED OPERATION'
EXCC3    $ERCGN 0C3,'EXECUTE'
EXCC4    $ERCGN 0C4,'PROTECTION'
EXCC5    $ERCGN 0C5,'ADDRESSING'
EXCC6    $ERCGN 0C6,'SPECIFICATION'
EXCC7    $ERCGN 0C7,'DATA'
EXCC8    $ERCGN 0C8,'FIXED-POINT OVERFLOW'
EXCC9    $ERCGN 0C9,'FIXED-POINT DIVIDE'
EXCCA    $ERCGN 0CA,'DECIMAL OVERFLOW'
EXCCB    $ERCGN 0CB,'DECIMAL DIVIDE'
         AIF   (NOT &$FLOTE).EXFL8 SKIP MESSAGES FOR FLOATING POINT
EXCCC    $ERCGN 0CC,'EXPONENT OVERFLOW'
EXCCD    $ERCGN 0CD,'EXPONENT UNDERFLOW'
EXCCE    $ERCGN 0CE,'SIGNIFICANCE'
EXCCF    $ERCGN 0CF,'FLOATING-POINT DIVIDE'
.EXFL8   ANOP
         SPACE 1
EXCCREAD $ERCGN 220,'ATTEMPTED READ PAST END-FILE',TYPE=ASSIST
EXCCTIME $ERCGN 221,'INSTRUCTION LIMIT EXCEEDED',TYPE=ASSIST
EXCCRECE $ERCGN 222,'RECORD LIMIT EXCEEDED',TYPE=ASSIST
         AIF   (&$TIMER EQ 0).EXNOTOC       SKIP IF NO TIMER AT ALL
EXCCTIMB $ERCGN 223,'TIME LIMIT EXCEEDED',TYPE=ASSIST
.EXNOTOC ANOP
EXCCBROU $ERCGN 224,'BRANCH OUT OF PROGRAM AREA',TYPE=ASSIST
         SPACE 1
         AIF   (&$S370 NE 2).EXDUBLW SKIP IF NOT SIMULATING S/370
EXDUBLWD DC    D'0'                DOUBLE-WORD FOR ALIGNING OPERANDS
EXSRPMK  DC    XL4'F0'             MASK TO REMOVE IMMEDIATE FIELD
EXALIGN  DC    H'22'               # OF HIGH RX INST NEEDING ALIGNMENT
EXSRPDA1 DC    PL1'0'              AREA FOR ROUNDING FACTOR
EXSRPDA2 DS    PL16'0'             AREA FOR SHIFTING USER NUMBER
.EXDUBLW AIF   (&$S370 EQ 0).EXLONGK SKIP IF WE DON'T HAVE S/370'S
EXLONGMK DC    0F'0',XL4'FFFFFF'   MASK FOR ZAPPING UPPER BYTES OF REGS
.EXLONGK ANOP
EXILENG  DC    F'2,4,4,6'          INSTRUCTION LENGTHS
EXILC    DC    F'0'                USED BY BAL AND BALR TO HOLD ILC
EXNORNG  DC    H'8'                # OF HIGH RX INST WITH NO RANGECK
         LTORG
         EJECT
         DS    0D                  ALIGN FOR DUMP READING EASE
* * * * * TABLE OF SECONDARY BRANCH INDEX VALUES                      *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
EXOPTAB1 DC    X'00000000020406080A0C0E0000001C1C'     0
         DC    X'10101010121212121412121216161212'     1
         DC    X'18181818181A1A1A1818181818181818'     2
         DC    X'18181818181A1A1A1818181818181818'     3
         DC    X'1002100A180406080E0A0A0A0A00100E'     4
         DC    X'10001C1A0A0A0A0A0E0A0A0A0C0C0A0A'     5
         DC    X'141E2000000000161212121212121212'     6
         DC    X'14000000000000001212121212121212'     7
         DC    X'0200040006080A0A0E0E0E0E10101010'     8
         DC    X'0C121212121212120C0000001416181A'     9
         DC    X'28000000000000000000000000000000'     A 28-XREPL
         DC    X'002600000000242200000000001C1E20'     B
         DC    X'00000000000000000000000000000000'     C
         DC    X'00020202040404040000000002060A08'     D
         DC    X'0C0C0000000000000000000000000000'     E
         DC    X'0E0A0202000000000A0A0A0A0A0A0000'     F
         SPACE 1
* * * * * TABLE USED BY RANGE CHECKING ROUTINE FOR RX,SI,RS, AND SS   *
*        BITS OF EACH BYTE HAVE FOLLOWING MEANING                     *
*   BIT 0 = 1 ==> 1ST ADDRESS IS PROTECTED IF NOT RUNNING REPLACE MODE*
*   BIT 1 = 1 ==> 1ST ADDRESS IS PROTECTED REGARDLESS OF RUNNING MODE *
*   BIT 2 = 1 ==> 2ND ADDRESS IS PROTECTED IF NOT RUNNING REPLACE MODE*
*   BIT 3 = 1 ==> 2ND ADDRESS IS PROTECTED REGARDLESS OF RUNNING MODE *
*        BITS 2-3 ARE ONLY FLAGGED FOR SS AND POSSIBLY SPECIAL INSTS  *
*        **NOTE** BIT 1 = 1 ==> BIT 0 = 1,  BIT 3 = 1 ==> BIT 2 = 1.  *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
EXIPROT  DC    X'C000C080C0000000808080808000C080'     4
         DC    X'C000C080808080808080808080808080'     5
         DC    X'C080C000000000808080808080808080'     6
         DC    X'C0000000000000008080808080808080'     7
         DC    X'00000000000000000000000000000000'     8
         DC    X'C080C0C0C080C0C08000000000000000'     9
         DC    X'C0000000000000000000000000000000'     A 28-XREPL
         DC    X'0000C0000000C080000000000080C080'     B
         DC    X'00000000000000000000000000000000'     C
         DC    X'00E0E0E0E0A0E0E000000000E0A0E0E0'     D
         DC    X'00000000000000000000000000000000'     E              A
         DC    X'C0E0E0E000000000E0A0E0E0E0E00000'     F
         SPACE 4
         DROP  R13,REC,RSTK        KILL LEFTOVER USINGS
.EXYZ    ANOP
         TITLE 'XXXXDECI - EXTENDED DECIMAL INPUT CONVERSION MODULE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXDECI   EXTENDED DECIMAL INPUT CONVERSION MODULE       *
*        XXXXDECI IS CALLED BY MACRO XDECI TO PERFORM SCANNING AND    *
*        CONVERSION OF DECIMAL STRINGS.                               *
*        ENTRY CONDITIONS                                             *
*   R14= ADDRESS OF XDECIB DSECT CREATED BY CALLING XDECI.            *
*   R15= ENTRY POINT ADDRESS (=V(XXXXDECI))                           *
*        EXIT CONDITIONS                                              *
*   XDECIR1,XDECIRV VALUES ARE FILLED IN FOR REGS.                    *
*   CC   IS SET ACCORDING TO SIGN OF RESULT, OR = 3 IF ERROR.         *
*        USES DSECTS: XDECIB                                          *
*        NAMES: XXDI----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDECI CSECT
         USING *,R15               NOTE ENTRY PT USING FOR BASE REG
         USING XDECIB,R14          NOTE @ CONTROL BLOCK FROM XDECI
         STM   R2,R3,XXDISAVE      SAVE WORK REGISTERS
         LA    R1,1                USEFUL CONSTANT, IN ODD REGISTER
         LR    R2,R0               MOVE BEGINNING @ OVER WHERE USABLE
*              SCAN LOOP TO SKIP OVER LEADING BLANKS.
         CLI   0(R2),C' '          IS NEXT CHARACTER A BLANK
         BNE   *+8                 SKIP OUT OF LOOP IF NOT
         BXH   R2,R1,*-8           LOOP, INCREMENTING SCAN POINTER
         SPACE 1
         MVI   XXDIS,X'10'         MAKE INST AN LPR FOR NOW
         CLI   0(R2),C'+'          IS THERE A LEADING +
         BE    XXDII               YES, BRANCH TO BUMP POINTER
         CLI   0(R2),C'-'          IS THERE A LEADING -
         BNE   XXDII2              NO,DON'T BUMP SCAN POINTER
         MVI   XXDIS,X'11'         - SIGN,SO MAKE INST AN LNR
XXDII    AR    R2,R1               BUMP SCAN PTR BY 1, LEADING SIGN
XXDII2   LR    R3,R2               MOVE INIT SCAN PTR AND SAVE IT
         SPACE 1
*              SCAN TO END OF DECIMAL DIGITS.
         CLI   0(R2),C'0'          IS NEXT CHARACTER A DIGIT
         BL    *+16                BRANCH OUT OF LOOP IF NOT DIGIT
         CLI   0(R2),C'9'          WAS IT TOO HIGH (MULTIPUNCH)
         BH    *+8                 YES, BRANCH OUT.  IDIOT OVERPUNCHERS
         BXH   R2,R1,*-16          LOOP BACK, BUMPING SCAN POINTER
         SPACE 1
         ST    R2,XDECIR1          STORE VALUE FOR RETURN AS SCAN PTR
         SR    R2,R3               OBTAIN LENGTH OF STRING
         BZ    XXDION              IF ZERO LENGTH, ERROR, BRANCH
         LA    R0,9                LIMIT FOR COMPARISON
         CR    R2,R0               COMPARE WITH LIMIT VALUE
         BNH   *+12                SKIP IF SMALL ENOUGH TO BE OK
XXDION   TM    *+1,1               SET COND CODE = 3,BAD VALUE
         B     XXDIST              GO TO RETURN TO CALLER
         SR    R2,R1               NORMAL CODE, DECREMENT LENGTH
         EX    R2,XXDIPK           PACK THE VALUE
         CVB   R0,XXDIDWOR         CONVERT VALUE
XXDIS    LPR   $+R0,R0             MAKE SIGN, SET CC RIGHT**MODIFIED***
         ST    R0,XDECIRV          SAVE AS VALUE FOR REG
XXDIST   LM    R2,R3,XXDISAVE      RESTORE EXTRA WORK REGS
         B     XDECIRET            RETURN TO CALLING XDECI MACRO
         SPACE 1
XXDIPK   PACK  XXDIDWOR,0($,R3)    PACK TO BE EXECUTED
XXDIDWOR DS    D                   DOUBLEWORD WORKAREA
XXDISAVE DS    2F                  WORK REGS SAVE AREA
         DROP  R14,R15             KILL USINGS
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XDECIB     CONTROL BLOCK CREATED BY XDECI MACRO           *
*        AN XDECIB IS CREATED BY EACH CALL TO THE XDECI MACRO, AND    *
*        CONTAINS THE @ XXXXDECI, SAVEWORDS FOR REGS R14,R15,R0, AND  *
*        WORDS FOR RETURN VALUES FOR REGISTER R1, AND THE ARGUMENT REG*
*        THIS DSECT IS USED ONLY IN MODULE XXXXDECI.                  *
*        GENERATION: XDECI                                            *
*        NAMES: XDECI---                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XDECIB   DSECT
         DS    V(XXXXDECI)         ADCON TO GET HERE
         DS    3F                  REGS 14,15,0 SAVED HERE
XDECIR1  DS    A                   RETURN VALUE FOR REG 1 SCAN POINTER
XDECIRV  DS    F                   VALUE CONVERTED AND RETURNED HERE
XDECIRET LM    14,1,4(14)          RETURN POINT @
         TITLE 'XXXXDECO - EXTENDED DECIMAL OUTPUT CONVERSION PROGRAM'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXDECO   EXTENDED DECIMAL OUTPUT CONVERSION MODULE      *
*        XXXXDECO IS CALLED BY MACRO XDECO TO CONVERT A REGISTER      *
*        VALUE TO EDITED DECIMAL, IN A 12-BYTE AREA, WITH SIGN.       *
*        ENTRY CONDITIONS                                             *
*   R14= ADDRESS OF XDECOB DSECT CREATED BY XDECO                     *
*   R15= ENTRY POINT ADDRESS (=V(XXXDECO))                            *
*        EXIT CONDITIONS                                              *
*   EDITED 12-BYTE RESULT OF REGISTER ARGUMENT STORED AT ADDRESS ARG. *
*        USES DSECTS: XDECOB                                          *
*        NAMES: XXDO----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDECO CSECT
         USING *,R15               NOTE ENTRY PT USING FOR BASE
         USING XDECOB,R14          NOTE XDECO CONTROL BLOCK
         STM   R1,R2,XXDOSAVE      SAVE WORK REGISTERS
         LR    R2,R0               MOVE @ AREA WHERE CAN BE USED
         L     R0,XDECOV           GET VALUE TO BE CONVERTED
         CVD   R0,XXDODWOR         CONVERT THE VALUE
         MVC   0(12,R2),XXDODECP   MOVE EDIT PATTERN IN
         LA    R1,11(R2)           SET UP FOR NEG NUMBER FOR EDMK
         EDMK  0(12,R2),XXDODWOR+2 EDIT THE VALUE OVER
         BNM   XXDORETN            SKIP INSERTION OF - IF >=0
         BCTR  R1,0                MOVE @ POINTER BACK 1
         MVI   0(R1),C'-'          INSERT - IN FRONT OF 1ST DIGIT
XXDORETN LM    R1,R2,XXDOSAVE      RESTORE WORKING REGS
         SPM   R14                 RESTORE ORIGINAL COND CODE
         B     XDECORET            RETURN TO CALLING XDECO
         SPACE 1
XXDODECP DC    X'402020202020202020202120'  EDIT PATTERN
XXDODWOR DS    D                   WORKAREA
XXDOSAVE DS    2F                  SAVE AREA FOR REGS 1-2
         DROP  R14,R15             KILL USINGS
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XDECOB     CONTROL BLOCK CREATED BY XDECO                 *
*        AN XDECOB  IS CREATED FOR EACH XDECO CALL, AND CONTAINS THE  *
*        @ XXXXDECO MODULE, SAVE WORDS FOR REGS R14,R15,R0, AND A     *
*        WORD FOR THE VALUE TO BE CONVERTED TO DECIMAL.               *
*        XDECOB IS USED ONLY IN CSECT XXXXDECO.                       *
*        GENERATION: XDECO                                            *
*        NAMES: XDECO---                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XDECOB   DSECT
         DS    V(XXXXDECO)         ADCON TO GET HERE
         DS    3F                  SAVE AREA FOR REGS 14,15,0
XDECOV   DS    F                   VALUE FOR CONVERSION
XDECORET LM    14,0,4(14)          RETURN POINT @
         AIF   (NOT &$HEXI).XXHEXI
         TITLE 'XXXXHEXI-MODULE CALLED BY XHEXI'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XXXXHEXI EXTENDED HEXADECIMAL INPUT CONVERSION MODULE      *
*        XXXXHEXI IS CALLED BY MACRO XHEXI TO SCAN THE INPUT STRING   *
*        AND CONVERT IT TO HEXADECIMAL INPUT.                         *
*        ENTRY CONDITIONS                                             *
*  R14= ADDRESS OF A STORAGE AREA WITH R14-R1 STORED                  *
*  R15= ENTRY POINT ADDRESS (V(XXXXHEXI))                             *
*  R0 = ADDRESS OF STRING TO BE SCANNED.                              *
*        EXIT CONDITIONS                                              *
*  VALUE OF CONVERTED STRING IN STORAGE AREA POINTED TO BY R14,       *
*  STORED IN 16 PASSED R14 OR IN XHEXINUM.                            *
*  R1= ENDING ADDRESS OF STRING, I.E. FIRST NON-HEXADECIMAL DIGIT.    *
*   CC SET=3 IF ERROR                                                 *
*        USES DSECT XHEXIB.                                           *
*        NAMES: XXHI----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXHEXI CSECT
         USING *,15               SET UP BASE REGISTER
         USING XHEXIB,R14         DSECT OVERLAP
         STM   R14,R6,XXHEXISA    STORE APPROPRIATE REGISTERS
         LR    R1,R0              START SCAN OF STRING
         LA    R3,1               ODD VALUE USED IN BXH INSTR
XXHILP   CLI   0(R1),C' '         SEARCH FOR FIRST NON-BLANK
         BNE   XXHIBGN            BRANCH WHEN FOUND TO START TRT
         BXH   R1,R3,XXHILP       KEEP GOING UNTIL FIND NON-BLANK
XXHIBGN  LR    R3,R1              FIRST BYTE OF STRING IN R3 AND R4
         LR    R4,R3
         LR    R6,R1              BEGINNING OF STRING
         LA    R1,8(R1)           R1 NOW HAS MAXIMUM ADDRESS IN IT
*  IF TRT DOESN'T STOP BEFORE 8TH TIME, R1 WON'T CHANGE=> NEED END
         TRT   0(8,R6),XXHITAB2   FIND LAST BYTE-8 MAXIMUM
         LR    R6,R1              SAVE ENDING ADDRESS
         SR    R1,R3              FIND  NO OF CHARACTERS
         BZ    XXHIERR            IF LENGTH ZERO SET CC TO 3
         LR    R3,R1
         MVC   XXHIDOUB(8),=12C'0'  MOVE ZEROS IN AREA TO BE CONVERTED
         LA    R5,8
         SR    R5,R3              # OF PADDED BLANKS
         LA    R5,XXHIDOUB(R5)    R5 NOW ADDRESS OF CONVERTED STRING
         BCTR  R3,0
         EX    R3,XXHIMOVE        EX USED TO MOVE CONVERTED STRING IN
         TR    XXHIDOUB(8),XXHITAB3 CONVERT C1-C6 TO FA-FF
         PACK  XXHIOUT(5),XXHIDOUB(9)  DO FUNNY PACK TO MAKE RIGHT LETS
         L     R0,XXHIOUT         CONVERTED NUMBER IN R0
         ST    R0,XHEXINUM        STORE CONVERTED NUMBER
         B     XXHIARND           BRANCH AROUND CONSTANTS
         LTORG
XXHIMOVE MVC   0(0,R5),0(R4)      MOVE FOR STRING TO BE CONVRTED
XXHIDOUB DS    D,C                STORAGE AREA
XXHIOUT  DS    F,C                STORAGE AREA
         SPACE 1
** TAB2 STOPS ON ANYTHING BUT VALID HEX DIGITS
XXHITAB2 DC    256X'01'
         ORG   XXHITAB2+C'A'      STOPS ON ANYTHING BUT A-F
         DC    6X'00'
         ORG   XXHITAB2+C'0'      STOP ONLY ON 0-9
         DC    10X'00'
         ORG
         SPACE 1
*  TAB3 USED IN TR CONVERTS TO FA-FF FROM C1-C6
XXHITAB3 EQU   *-C'A'             CONVERT FA-FF FROM C1-C6
         DC     X'FAFBFCFDFEFF'
         ORG   XXHITAB3+C'0'
         DC    X'F0F1F2F3F4F5F6F7F8F9'
         ORG
XXHIERR  TM    *+1,1              SET CONDITION CODE
XXHIARND LM    14,15,XXHEXISA     RESTORE REGISTERS
         LR    R1,R6              ENDING ADRESS IN SRTING
         LM    R2,R6,XXHEXISA+16
         B     XHEXIRET           RETURN TO CALLING PROG
XXHEXISA DS    9F                 SAVE AREA FOR REGISTERS
         DROP  R14,R15            CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XHEXIB   CONTROL BLOCK CREATED BY XHEXI                   *
*        AN XHEXIB IS CREATED FOR EACH XHEXI CALL, AND CONTAINS THE   *
*  @ XXXXHEXI MODULE, SAVE WORDS R14,R15,R0, AND A WORD VALUE THAT HAS*
*  BEEN CONVERTED                                                     *
*        XHEXI IS USED ONLY IN CSECT XXXXHEXI                         *
*        GENERATION XHEXI                                             *
*        NAMES XHEXI---                                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XHEXIB   DSECT
         DS    V(XXXXHEXI)        ADCON TO GET HERE
         DS    3F                 STORAGE FOR REGISTERS
XHEXINUM DS    F                  STORAGE FOR CONVERTED NUMBER
XHEXIRET LM    R14,0,4(R14)       RESTORE REGISTERS
.XXHEXI  AIF   (NOT &$HEXO).XXHEXO
         TITLE 'XXXXHEXO - MODULE TO SUPPORT XHEXO PSEUDO-OP'   CPP
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XXXXHEXO EXTENDED HEXADECIMAL OUTPUT CONVERSION MODULE     *
*        XXXXHEXO IS CALLED BY MACRO XHEXO TO CONVERT A REGISTER VALUE*
*        TO EDITED HEXADECIMAL IN AN 8-BYTE AREA.                     *
*        ENTRY CONDITIONS:                                            *
*   R14= ADDRESS OF SAVEAREA FOR CALLING MACRO                        *
*   R15= ENTRY POINT ADDRESS                                          *
*   R0 = ADDRESS OF AREA WHERE CONVERTED STRING GOES                  *
*   # OF REGISTER CONTAINING VALUE TO BE CONVERTED IN XHEXOREG        *
*        EXIT CONDITIONS:                                             *
*   8-BYTE CONVERTED VALUE FROM REGISTER ARGUMENT STORED AT ADDRESS   *
*   POINTED TO BY LOCATION ARGUMENT                                   *
*        USES DSECT XHEXOB.                                           *
*        NAMES:XXHO----                                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXHEXO CSECT
         USING *,15               BASE REGISTER
         USING XHEXOB,R14         DSECT OVERLAP
         STM   R14,R1,XXHEXOSA    STORE REGISTERS
         L     R1,XHEXOREG        REGISTER TO BE CONVERTED
         ST    R1,XXHOAREA        STORE NUMBER TO BE CONVERTED
         LR    R1,R0             VALUE OF ADDRESS TO BE MOVED TO IN R1
         L     R14,=A(XXHOTAB3-C'0')   FOR CONVERSION
         UNPK  XXHODOUB(9),XXHOAREA(5)  CONVERT NUMBER
         TR    XXHODOUB,0(R14)    MAKE PRINTABLE
         MVC   0(8,R1),XXHODOUB   MOVE NUMBER INTO RIGHT AREA
XXHOBACK LM    R14,R1,XXHEXOSA    RESTORE REGISTERS
         B     XHEXORET           RETURN TO CALLING PROG
XXHOTAB3 DC    C'0123456789ABCDEF'
XXHOAREA DS    F,C                STORAGE AREA
XXHODOUB DS    D,C                STORAGE
XXHEXOSA DS    4F
         LTORG
         DROP  R14,R15            CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XHEXOB   CONTROL BLOCK CREATED BY XHEXO                   *
*        AN XHEXOB IS CREATED FOR XHEXO CALL, AND CONTAINS THE @      *
*   XXXXHEXO MODULE, SAVE WORDS FOR R14-R2 AND THE PLACE TO RETURN    *
*        XHEXOB IS USED ONLY IN CSECT XXXXHEXO.                       *
*        GENERATION: XXXXHEXO                                         *
*        NAMES: XHEXO----                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XHEXOB   DSECT
         DS    V(XXXXHEXO)        STORAGE OF VCON
         DS    3F
XHEXOREG DS    F                  REGISTER STORAGE
XHEXORET LM    R14,R2,4(R14)      RESTORE REGISTERS
.XXHEXO  ANOP
         AIF   (&$XXIOS).XGPSKIP   SKIP IF XGET/XPUT NOT ALLOWED
         TITLE 'CSECT***XDDTABLE*** CONTROL TABLE FOR XGET-XPUT MONIT'
XDDTABLE CSECT
**-->CSECT: XDDTABLE* * * * * * * * * * * * * * * * * * * * * * * * * *
*       CONTAINS INFORMATION ON EACH FILE FOR THE MONITOR             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
        XDDSLOT SYSIN,XREAD,POSIN=1       XREAD ONLY
        XDDSLOT FT05F001,XREAD,POSIN=1    XREAD ONLY
        XDDSLOT XREAD,XREAD,POSIN=1       XREAD ONLY
        XDDSLOT INPUT,XREAD,POSIN=1       XREAD ONLY
        XDDSLOT XPRNT,XPRNT,POSOUT=1      XPRNT ONLY
        XDDSLOT FT06F001,XPRNT,POSOUT=1   XPRNT ONLY
        XDDSLOT XPNCH,XPNCH,POSOUT=1      XPNCH ONLY
        XDDSLOT FT07F001,XPNCH,POSOUT=1   XPNCH ONLY
        XDDSLOT XSNAPOUT                  USER CAN'T TOUCH XSNAPOUT
        XDDSLOT SYSPRINT                  USER CAN'T TOUCH SYSPRINT
        XDDSLOT SYSLIB                    USER CAN'T TOUCH SYSLIB
        XDDSLOT FT08F001                  USER CAN'T TOUCH FT08F001
        XDDSLOT FT16F001,POSOUT=1    USER CAN OUTPUT
        XDDSLOT FT17F001,POSOUT=1    USER CAN OUTPUT
        XDDSLOT
        XDDSLOT
        XDDSLOT
        XDDSLOT
        XDDSLOT
        XDDSLOT
X$DDLONG EQU   *-XDDTABLE          BYTE LENGTH OF TABLE
X$DDNUM  EQU   X$DDLONG/X$SLLONG   WILL BE SET TO # OF SLOTS
         TITLE 'CSECT***XDDGET*** XGET-XPUT MONITOR'
XDDGET   CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XDDGET (ENTRY XDDPUT)                                      *
*        XGET - XPUT MONITOR.  USES TABLE XDDTABDE TO CONTROL         *
*        I/O THROUGH USER CALLS TO XGET & XPUT.                       *
*        CALLS $READ,$PRNT,$PNCH,XGET,XPUT MACROS.                    *
*    E.X.                                                             *
*        THE MONITOR WILL NOT PERMIT A USER TO XGET A $READ FILE,     *
*        INSTEAD, THE MONITOR WILL CALL $READ AND THE USER WILL       *
*        NOT KNOW ABOUT IT.                                           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XIOBLOCK,R14
         USING *,R15
         MVI   XDDIOBIT,X$SLXGET   SET FOR INPUT
         LA    R15,XDDPUT          RESET ADDRESSING
         USING XDDPUT,R15
         B     XDDPUT+4            CONTINUE PROCESSING, KEEP INPUT FLAG
         ENTRY XDDPUT
XDDPUT   MVI   XDDIOBIT,X$SLXPUT   SET FOR OUTPUT
*              COMMON FROM NOW ON
         STM   R14,R12,XDDSAVE     SAVE REGS
         USING XDDPUT,12           SET NORMAL ADDRESSING
         LR    R12,R15
         DROP  R15                 KILL R15
         L     R3,=V(XDDTABLE)     GET THE @ OF THE TABLE
         USING X$SLOT,R3
         LA    R4,X$SLLONG         GET LENGTH/INCR OF ENTRY
         LA    R5,X$SLOT+X$DDLONG-1
XDDLOOP1 CLC   X$SLNAME(8),0(R1)   ARE NAMES SAME?
         BE    XDDFOUND            YES, CHECK OUT REST OF ENTRY
         BXLE  R3,R4,XDDLOOP1
*              NOT FOUND
         AIF   (&X$DDMOR).XDDSK1   ALLOWED OWN DDNAMES?
*              YES                 TRY TO FIND SPACE
         L     R3,=A(XDDTABLE)     RESET BEGINNING ADDRESS
XDDLOOP  TM    X$SLFLAG,X$SLPERM   ENTRY TEMPORARY?
         BZ    XDDMAKE             YES
XDDLPBOT BXLE  R3,R4,XDDLOOP
.XDDSK1  ANOP
*                                  SIGNAL ERROR
XDDFBAD  EQU   *
         TM    *+1,X'FF'           SET COND CODE
XDDFGOOD EQU   *
         LM    R14,R12,XDDSAVE     RESTORE REQS
         B     XIORETRN            RETURN
         AIF   (&X$DDMOR).XDDSK2
*                                  PUT DDNAME IN
XDDMAKE  TM    X$SLFLAG,X$SLOPEN   FILE OPEN?
         BM    XDDLPBOT            YES, TRY AGAIN
         MVC   X$SLNAME(8),0(R1)
         MVI   X$SLFLAG,X$SLPOIN   SET FOR POSSIBLE IN OR OUT
         B     XDDAAAA
.XDDSK2  ANOP
XDDFOUND TM    X$SLFLAG,X$SLOPEN   IS IT OPEN?
         BZ    XDDNOPEN            NO,  GO FIX UP
         TM    X$SLFLAG,$          *****CHANGES-  GOING THE RIGHT WAY?
XDDIOBIT EQU   *-3                 LABEL FOR IMMEDIATE BYTE
         BO    XDDECIDE            GOING RIGHT WAY --- BRANCH
         B     XDDFBAD             TAKE BAD BRANCH
XDDNOPEN SR    R2,R2               EMPTY R2
         IC    R2,XDDIOBIT
         SRL   R2,4                MOVE BITS OVER
         STC   R2,*+5              PUT IN TM INST BELOW
         TM    X$SLFLAG,$ ****CHANGES*****  USER ALLOWED TO GO THIS WAY
         BZ    XDDFBAD             NO, GO RETURN
XDDAAAA  OC    X$SLFLAG,XDDIOBIT   SET TEMP DIRECTION BIT
XDDECIDE SR    R2,R2               CLEAR R2
         IC    R2,X$SLWAY
         LH    R8,XIOLENG          SET UP LENGTH
         B     *+4(R2)             BRANCH INTO BRANCH TABLE
         B     XDD$GPIO            DO XGET-XPUT
         B     XDD$READ            DO NORMAL READ
         B     XDD$PRNT            DO NORMAL PRINT
         B     XDD$PNCH            DO NORMAL PUNCH
XDD$READ EQU   *
         $READ  (R0),(R8)
         B     XDDFGOOD            GO RETURN
XDD$PRNT EQU   *
         $PRNT  (R0),(R8)
         B     XDDFGOOD            GO RETURN
XDD$PNCH EQU   *
         $PNCH (R0),(R8)
         B     XDDFGOOD            GO RETURN
XDD$GPIO EQU   *
         LTR    R8,R8              IS LENGTH ZERO?
         BNE   *+8                 NO, DON'T FORGET ELEMENT
         NI     X$SLFLAG,X$SLCLOS  EMPTY ELEMENT
         CLI   XDDIOBIT,X$SLXPUT   WAS IT OUTPUT?
         BE    XDD$PUT             YES, DO OUTPUT
*                                  NO,  DO INPUT
         XGET  (R0),(R8)
         B     XDDCLEAN
XDD$PUT  EQU   *
         XPUT  (R0),(R8)
XDDCLEAN EQU   *
*        IF COND CODE IS BAD, WIPE OUT FLAG
         BE    XDDFGOOD            GO RETURN
         BALR  R2,0                SAVE COND CODE FOR AFTER NI
         NI    X$SLFLAG,X$SLCLOS   WIPE OUT FLAG
         SPM   R2                  RESTORE COND CODE TO BEFORE NI
         B     XDDFGOOD            GO RETURN
XDDSAVE  DS    15F                 SAVE AREA FOR REGISTERS
         LTORG
         DROP  R14,R3,R12          CLEAN UP USINGS
         TITLE 'CSECT***XXDDFINI*** CLOSE XGET-XPUT HANDLED FILES'
XXDDFINI CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->CSECT: XXDDFINI  CLOSES XGET-XPUT FILES                           *
*    LIKE XXXXFINI, CALLED AT SAME TIME.                              *
*    BUT CLOSES ONLY THE FILES HANDLED BY XGET-XPUT                   *
*                                                                     *
*    SEARCHS TABLE XDDTABLE FOR FILES THAT ARE OPEN AND ARE HANDLED   *
*              BY XGET-XPUT.                                          *
*    WHEN FOUND, CLOSES THEM THROUGH XGET-XPUT. BLANKS OUT FIRST BYTE *
*              OF NAME IN TABLE.  IF NOT PERMANENT, AND NOT OPEN,     *
*              JUST WIPES OUT FIRST BYTE.                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XIOBLOCK,R14        ADDRESSABILITY INTO XIOBLOCK
         USING *,R15               TEMPORARY ADDRESSABILITY
         STM   R14,R12,XDDFSAVE    SAVE REGISTERS
         BALR  R12,0               SET R12
         USING *,R12               PERMANENT ADDRESSABILITY
         DROP  R15                 KILL R15
         L     R3,=V(XDDTABLE)     GET THE @ OF THE TABLE
         USING X$SLOT,R3 .         SET UP FOR TABLE
         LA    R4,X$SLLONG         GET INCREMENT SIZE
         LA    R5,X$SLOT+X$DDLONG-1     GET UPPER BOUNDARY
XXDDFLOP TM    X$SLFLAG,X$SLOPEN   IS FILE OPEN
         BZ    XXDDFCHK            NO, GO SEE IF IT IS PERMANENT
         CLI   X$SLWAY,X$SLXGPT    IS FILE HANDLED BY XGET-XPUT?
         BNE   XXDDFBOT            NO, CLOSED BY XXXXFINI
         LR    R1,R3               POINT TO DD NAME
         TM    X$SLFLAG,X$SLXGET   HANDLED BY XGET?
         BO    XXDDFGET            YES CLOSE BY XGET
*                                  NO, CLOSE BY XPUT
         XPUT  XDDFSAVE,0          CLOSE, USE DUMMY OUTPUT AREA
         B     XXDDFCHK
XXDDFGET EQU   *
         XGET  XDDFSAVE,0          CLOSE, USE DUMMY INPUT AREA
XXDDFCHK NI    X$SLFLAG,X$SLCLOS   REMOVE OPEN BITS
         TM    X$SLFLAG,X$SLPERM   IS FILE PERMANENT
         BO    XXDDFBOT            YES, LEAVE ALONE
         MVI   X$SLNAME,C' '       NO, BLANK OUT
XXDDFBOT BXLE  R3,R4,XXDDFLOP      TRY NEXT ENTRY
*                                  RAN OUT OF ENTRIES, DONE
         LM    R14,R12,XDDFSAVE    RESTORE REGISTERS
         BR    R14                 RETURN
XDDFSAVE DS    15F                 SAVE AREA FOR REGISTERS
         LTORG
         DROP  R14,R3,R12          KILL USINGS
         PRINT GEN
XXXXGET  XGPGEN
XXXXPUT  XGPGEN DIREC=P
         PRINT NOGEN               TURN OFF AFTER
.XGPSKIP ANOP
         TITLE 'CSECT XXXXXIOCO  ASSIST I/O PROCESSOR'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXIOCO   ASSIST INPUT/OUTPUT CONTROL PROCESSING         *
*              XXXXIOCO CONTAINS ALL ACTUAL INPUT/OUTPUT OPERATIONS.  *
*        XXXXINIT AND XXXXFINI ARE USUALLY CALLED ONCE EACH, TO       *
*        PERFORM INITIALIZATION AND TERMINATION RESPECTIVELY.         *
*        THE ENTRIES XXXXSORC,XXXXREAD,XXXXPNCH,XXXXPRNT ARE CALLED   *
*        TO READ SOURCE CARDS,READ DATA CARDS, PUNCH CARDS, OR PRINT  *
*        LINES DURING EXECUTION.  THE DCB'S FOR READ AND PNCH ARE NOT *
*        OPENED UNLESS THEY ARE USED, AND IF USED WITHOUT WORKABLE    *
*        OPEN'S, THEY DEFAULT BACK TO SORC AND PRNT, RESPECTIVELY.    *
*        THESE 4 ENTIRES SHARE A COMMON BASE REGISTER (R13,ALSO @ SAVE*
*        AREA), COMMON VALUES OF R11 (@ AJOBCON) AND R12 ( CONSTANT 1)*
*        COMMON EXIT CODE.  SORC AND READ SHARE SOME COMMON CODE (GET)*
*        AND PNCH AND PRNT SHARE SOME COMMON CODE (PUT).              *
*        THESE ROUTINES ARE DESIGNED TO ACCEPT THE XIOBLOCK SET UP BY *
*        THE XIONR MACRO($READ,$PRNT,$PNCH,$SORC). LOCATE MODE IS     *
*        USED TO MINIMIZE MOVEMENT OF CARD AND LINE IMAGES.           *
*        *NOTE* REMOTE OPEN/CLOSE PARM LISTS ARE USED TO SAVE SPACE.  *
*        UNDER A DOS SYSTEM, NO SUCH LIST EXISTS DUE TO THE NON-      *
*        EXISTENCE OF MACRO EXECUTE FORMS FOR THE CLOSING OF DTF'S    *
*        USES MACROS:  DCB,DCBD(OS) OR DTF(DOS)   (OVERALL USE)       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXIOCO CSECT
         $DBG  ,NO                 SHOW NO DEBUG CODE-$SAVE/$RETURN
         ENTRY XXXXINIT,XXXXFINI,XXXXREAD,XXXXSORC,XXXXPNCH,XXXXPRNT
         AIF   (&$DISKU EQ 0).XXNOENT  SKIP ENTRY DEFINITION IF NODSK
         AIF   (&$ASMLVL).XXBOS1   GEN. CORRECT DISK I/O EQUATES
XXDECBE  EQU   4 .                 DOS 'DECB' OFFSET
XXDECBIN EQU   0 .                 OFFSET INTO FAKE DECB - XXFIXUP
XXDKOFFL EQU   8 .                 DOS BUFFER OFFSET, NEEDS 8 BYTES
XXDKOPEN EQU   X'15'               DTF OFFSET FOR OPEN TEST
XXMASK   EQU   X'04'               DOS OPEN TEST MASK
         AGO   .XXBOS2
.XXBOS1  ANOP
XXDECBE  EQU   16 .                OS DECB OFFSET
XXDECBIN EQU   12 .                OFFSET INTO OS DECB - XXFIXUP
XXDKOFFL EQU   0 .                 OS BUFFER OFFSET, NONE NEEDED
XXDKOPEN EQU   48 .                OS DCB DISP. FOR OPEN TEST
XXMASK   EQU   X'10' .             OS OPEN TEST MASK.
.XXBOS2  ANOP
         ENTRY XXXXDKOP,XXXXDKRD,XXXXDKE1,XXXXDKWT
.XXNOENT ANOP
         AIF   (NOT &$MACSLB).XXNOMET    SKIP ENTRIES IF NO MACSLB
         ENTRY XXXXLBOP,XXXXLBRD,XXXXFIND,XXXXLBED
.XXNOMET ANOP
         USING AJOBCON,R11         NOTE GLOBAL USING FOR WHOLE CSECT
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXINIT   INITIAL OPEN FOR READER/PRINTER                *
*        OPENS PRINTER,SOURCE CARD RDR.  INITIALIZES XXIOCPTR, WHICH  *
*        ALWAYS HAS BEGINNING @ OF OPEN/CLOSE PARM LIST (OS GEN. ONLY)*
*        ENTRY CONDITIONS                                             *
*   R11= @ AJOBCON DUMMY SECTION                                      *
*   AJIO-- FLAGS IN AJOBCON ARE ALL ZEROS.                            *
*        EXIT CONDITIONS                                              *
*   AJIOSO,AJIOPR FLAGGED WITH AJIOPEN IF DCB'S OPENED PROPERLY.      *
*        USES MACROS: $RETURN,$SAVE,OPEN                              *
*        USES DSECT: AJOBCON                                          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXINIT $SAVE RGS=(R14-R12),SA=XXIOSAVE,BR=R6
         ST    R11,XXIOAJOB        SAVE @ OF MAIN TABLE
         AIF   (NOT &$MACSLB).XXINNOM  SKIP WHEN NO MACSLB ABILITY
         MVI   XXLBFLG,X'00'       SHOW NO BUFFER(MACSLB) AT THIS POINT
.XXINNOM ANOP
         AIF   (&$ASMLVL).XXOSOPN  SKIP FOR OS GENERATION OPEN
         OPEN  XXSODCB,XXPRDCB     OPEN XXSODCB, XXPRDCB RIGHT NOW
         TM    XXSODCB+15,X'20'    DID SOURCE READER OPEN?
         BO    *+8                 SKIP FLAGGING IF IT DIDN'T OPEN
         OI    AJIOSO,AJIOPEN      SHOW SOURCE READER OPEN
         TM    XXPRDCB+15,X'20'    DID LINE PRINTER OPEN?
         BO    *+8                 SKIP FLAGGING IF IT DIDN'T OPEN
.XXOSOPN AIF   (NOT &$ASMLVL).XXDOSOP        SKIP IF A DOS OPEN
         LA    R1,XXIOCSP          INIT VALUE OF OPEN/CLOSE PTR
         ST    R1,XXIOCPTR         STORE INIT VALUE OF PTR
         OPEN  MF=(E,(1))          OPEN XXSODCB,XXPRDCB RIGHT NOW
         TM    XXSODCB+48,X'10'    DID SOURCE READER OPEN?
         BZ    *+8                 SKIP FLAGGING IT OPEN IF DIDN'T
         OI    AJIOSO,AJIOPEN      SHOW SOURCE READER OPEN
         TM    XXPRDCB+48,X'10'    DID PRINTER OPEN?
         BZ    *+8                 SKIP FLAGGING IT OPEN IF DIDN'T
.XXDOSOP ANOP
         OI    AJIOPR,AJIOPEN      SHOW PRINTER OPEN
XXIOOPRT $RETURN RGS=(R14-R12)
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXFINI   CLOSE ALL DCB'S WHICH ARE OPEN                 *
*        XXXXFINI USES THE OPEN/CLOSE PARM LIST BUILT DURING EXECUTION*
*        TO CLOSE ALL DCB'S CURRENTLY OPEN.  USES 1 EXECUTE TYPE OPEN.*
*        DOS GENERATIONS HAVE NO OPEN/CLOSE LIST, SO A CHECK MUST BE  *
*        MADE TO SEE WHICH DCB'S MUST BE CLOSED.                      *
*        ENTRY CONDITIONS                                             *
*   R11= @ AJOBCON DUMMY SECTION                                      *
*        EXIT CONDITIONS                                              *
*   AJIO-- FLAGS ARE ALL ZEROED OUT.                                  *
*        USES DSECTS: AJOBCON                                         *
*        USES MACROS: $RETURN,$SAVE,CLOSE                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXFINI $SAVE RGS=(R14-R12),BR=R6,SA=XXIOSAVE
         AIF   (&$ASMLVL).XXOSCLS  SKIP FOR OS GENERATION CLOSE
         PUT   XXPRDCB             OUTPUT LAST DOS RECORD
         CLOSE XXSODCB,XXPRDCB     CLOSE SOURCE READER AND PRINTER
         AIF   (NOT &$DATARD).XXNORDR     SKIP IF NO //DATA.INPUT RDR
         TM    AJIORE,AJIOPEN      WAS OTHER READER OPENED
         BNO   XXFIPNCH            IF NOT, THEN DON'T CLOSE IT
         CLOSE XXREDCB             CLOSE DATA CARD READER
.XXNORDR AIF   (NOT &$PUNCH).XXNOPNC         SKIP IF NO REAL CARD PUNCH
XXFIPNCH TM    AJIOPN,AJIOPEN      WAS THE PUNCH OPENED
         BNO   XXFIEXIT            IF NOT, THEN DON'T CLOSE IT
         PUT   XXPNDCB             OUTPUT LAST PUNCHED DOS CARD
         CLOSE XXPNDCB             CLOSE CARD PUNCH FILE
.XXNOPNC AIF   (&$PUNCH).XXOSCLS   SKIP IF CARD PUNCH EXISTS
XXFIPNCH EQU   *                   EQU TO EXIT, SINCE NO REAL PUNCH
         TM    AJIODSK,AJIOPEN     IS DISK DTF OPEN
         BO    XXFIOUT             NO - SO GO RETURN
         CLOSE XXDKUDCB            YES - SO CLOSE DTF
XXFIOUT  EQU   *
.XXOSCLS AIF   (NOT &$ASMLVL).XXDOSCL     SKIP IF DOS CLOSE IN EFFECT
         L     R1,XXIOCPTR         GET PTR TO BUILT UP OPEN/CLOSE LIST
         CLOSE MF=(E,(1))          REMOTE CLOSE ON ALL OPEN DCB'S
.XXDOSCL ANOP
XXFIEXIT XC    AJIOFLAG,AJIOFLAG   CLEAR ALL FLAGS OUT
         AIF   (NOT &$ASMLVL).XXFIF1   SKIP IF NOT OS/360
*              FOLLOWING CODE REQUIRED FOR PROPER REUSABILITY.
         L     R2,XXIOCPTR         GET @ BEGINNING OF DCB @ LIST
         SPACE 1
XXFIFREE L     R1,0(,R2)           GET @ NEXT DCB
         AIF   ((&$DISKU EQ 0) AND (NOT &$MACSLB)).XXFINA
         USING IHADCB,R1           NOTE USING ON R1
         TM    DCBBUFCB+3,1        DOES DCB OWN A BUFFER POOL OR NOT
         BO    XXDCBLST            SINCE ODD @, NO BUFFER POOL - BRANCH
XXFRPOOL FREEPOOL (1)              DO THE FREEPOOL TO GET RID OF BUFS
XXDCBLST TM    0(R2),X'80'         WAS THAT THE LAST?
         AGO   .XXFINB
.XXFINA  ANOP
         FREEPOOL (1)              DO THE FREEPOOL TO GET RID OF BUFS
         TM    0(R2),X'80'         WAS THAT ONE THE LAST ONE?
.XXFINB  ANOP
         LA    R2,4(R2)            INCREMENT TO NEXT DCB @
         BNO   XXFIFREE            NOT LAST, GO BACK FOR NEXT ONE
         SPACE 1
.XXFIF1  ANOP
         $RETURN RGS=(R14-R12),SA=XXIOSAVE
         DROP  R6                  KILL USING
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*         REGISTER USAGE FOR SECTIONS SORC,READ,PNCH,PRNT             *
*   R0 = @ I/O AREA WHERE USER DESIRES DATA MOVED TO/FROM             *
*   R1 = @ DCB FOR OPERATION (SET BEFORE ENTRY TO SECTIONS GET, PUT   *
*   R2 = @ CONTROL BYTE FOR READER SECTIONS, SET BEFORE ENTRY TO GET  *
*   R3,R4 WORK REGISTERS                                              *
*   R5 = DOS IOREG FOR BOTH GET & PUT OPERATIONS                      *
*   R6,R7,R8,R9,R10  ARE NOT MODIFIED OR USED                         *
*   R11= @ AJOBCON, MAIN CONTROL DUMMY SECTION                        *
*   R12= 1, USEFUL CONSTANT                                           *
*   R13= @ SAVE AREA XXIOSAVE, ALSO COMMON BASE REGISTER              *
*   R14= @ XIOBLOCK, CONTAINING LENGTH OF I/O REQUEST                 *
*   R15= LOCAL WORK REGISTER, TEMPORARY SINCE I/O OPRS MODIFY.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXIOSAVE,R13        NOTE GLOBAL USING
         USING XIOBLOCK,R14        NOTE PTR TO XIOBLOCK, GLOBAL
         AIF   (NOT &$DATARD).XXNDAT0       SKIP IF NO //DATA.INPUT RDR
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXREAD   READ 1 CARD AT USER EXECUTION TIME             *
*        OPENS CARD READER(DDNAME FT05F001) IF NOT ALREADY OPEN, OR   *
*        USES OPEN READER (DDNAME FT00F001) TO GET 1 CARD, USING THE  *
*        COMMON CODE SECTION XXIOGET.  IF NODATA WAS SPECIFIED IN THE *
*        USER PARM FIELD, NO OPEN WILL BE DONE FOR  FT05F001, BUT     *
*        SYSIN WILL BE USED INSTEAD.  CALLED BY $READ MACRO.          *
*        ENTRY CONDITIONS                                             *
*   R0 = @ I/O AREA WHERE DATA TO BE READ/WRITTEN                     *
*   R14= @ XIOBLOCK CREATED BY THE CALLING XIONR MACRO.               *
*   R15= ENTRY POINT ADDRESS                                          *
*        EXIT CONDITIONS                                              *
*   CC=  0     NORMAL RETURN, CARD WAS READ AND TRANSFERRED TO USER   *
*   CC=  1     ENDFILE ON READER.  IF ASSIST JCL, SAVED IN AJOBCON.   *
*        USES MACROS:   GET,OPEN                                      *
*        USES DSECTS: AJOBCON,XIOBLOCK                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXREAD,REP        NOTE TEMPORARY USING
XXXXREAD STM   R11,R5,XXIOSAVT     STORE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         TM    AJIORE,AJIOPEN      WAS IT ALREADY OPEN?
         BO    XXREC               YES,GO DO GET
         TM    AJIORE,AJIODFLT     ARE WE USING SOURCE RDR INSTEAD?
         BO    XXSORE              YES, SO USE SORC READER INSTEAD
*              CALL OPTIONAL USING OPEN ROUTINE TO OPEN RDR IF IT CAN.
         LA    R2,AJIORE           SHOW @ RDR CONTROL BYTE
         AIF   (&$ASMLVL).XXNDTF   SKIP IF UNDER OS GENERATION
         LA    R1,XXREDCB          SHOW @ OF DOS DCB
.XXNDTF  AIF   (NOT &$ASMLVL).XXNIOCR  SKIP IF UNDER DOS GENERATION
         LA    R3,XXIOCRE          SHOW @ OF OPEN/CLOSE PARM VALUE
.XXNIOCR ANOP
         BAL   R4,XXIOPENO         CALL OPEN/FLAGGING SECTION
         BZ    XXIOGET             IF OK, ALL SET UP-GO READ
         B     XXSORE              OPEN DIDN'T GO, USE SOURCE RDR
         SPACE 1
XXREC    LA    R1,XXREDCB          SHOW @ DCB
         LA    R2,AJIORE           SHOW @ CONTROL BYTE
         B     XXIOGET             GO TO COMMON GET ROUTINE
.XXNDAT0 AIF   (&$DATARD).XXNDAT2  SKIP IF DATA RDR EXISTS
XXXXREAD EQU   *                   EQU TO XXXXSORC-DATA RDR EXIST
.XXNDAT2 ANOP
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXSORC   READ A CARD DURING ASSEMBLY TIME               *
*        CALLED BY MACRO $SORC TO READ CARD FOR ASSEMBLER, USING      *
*        ALREADY OPEN DCB (DDNAME SYSIN).                             *
*        ENTRY CONDITIONS - SAME AS THOSE FOR ENTRY XXXXREAD.         *
*        EXIT CONDITIONS  - SAME AS THOSE FOR ENTRY XXXXREAD.         *
*        USES DSECTS: AJOBCON,XIOBLOCK                                *
*        USES MACROS: GET                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXSORC,REP        NOTE TEMPORARY USING
XXXXSORC STM   R11,R5,XXIOSAVT     STORE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         AIF   (NOT &$MACSLB).XXNOSOC  SKIP IF NO MACRO LIBRARY
XXSWTCH  BC    $,XXXXLBRD          GET A CARD FROM LIBRARY-MAYBE
.XXNOSOC  ANOP
         CLI   AJOBTRQ,AJO$D       REQUEST FOR DATA?                  J
         BE    XXIOBTAA            YES, NO NEED FRO SPECIAL CHECKS    J
*              AT THIS POINT, ASSIST IS ASKING FOR A $JOB/$ENTRY CARD J
         NI    AJIOSO,255-AJIOPSEO MAKE SURE NO PSEUD-END-FILE ON     J
         AIF   (NOT &$HASPBT).XXIOBTA   SKIP IF NO HASP AUTOBATCH     J
         TM    AJIOSO,AJIOSOHS     DO WE NEED BUFFER FLUSH?           J
         BZ    XXIOBTAA            NO,SKIP OVER IT                    J
         NI    AJIOSO,255-AJIOSOHS REMOVE FLAG SO WON'T DO AGAIN      J
*              JUST PREVIOUSLY, TWO OS NULL CARDS HAD BEEN FOUND, AND J
*              ASSIST WANTS TO READ FOR THE NEXT $JOB CARD, IN WHICH  J
*              CASE HASP MAY WANT TO PERFORM TERMINATION.  IT IS USED J
*              THUSLY.   IF USING MULTIPLE BUFFERS, CONSIDER CHANGING J
*              THIS TO CLOSE/OPEN ON XXPRDCB.                         J
*              IT IS NECESSARY TO PUT A BLANK LINE (SINCE LOCATE MODE)J
XXSORD   PUT   XXPRDCB             DO PUT LOCATE
         LH    R2,XXPRDCB+DCBLRECL-IHADCB   GET ACTUAL RECORD LENGTH  J
         BCTR  R2,0                GET LENGTH-1 FOR MVC               J
         STC   R2,*+5              PUT LENGTH-1 INTO MVC              J
         MVC   0($,R1),AJOBLANK    PUT OUT A BLANK LINE TO FLUSH      J
.XXIOBTA ANOP                                                         J
XXIOBTAA EQU   *                   BRANCH IF DATA OR NO BUFFER FLUSH  J
XXSORE   LA    R1,XXSODCB          SHOW @ DCB
         LA    R2,AJIOSO           SHOW @ CONTROL BYTE
         SPACE 2
* * * * * XXIOGET - COMMON GET CODE FOR XXXXSORC AND XXXXREAD         *
XXIOGET  TM    0(R2),AJIOEOF+AJIOPSEO    WAS EITHER EOF FLAG ALREADY ON
         BNZ   XXIORETA            YES, REFUSE TO READ A CARD NOW
         LM    R14,R0,XXIOSAVT+12  RELOAD ORIG VALUES, IN CASE CHANGED
         LH    R3,XIOLENG          GET THE LENGTH OF OPERATION FROM XIO
         LR    R4,R0               MOVE @ AREA OVER FOR SAFEKEEPING
         TM    AJIOSO,AJIOSORR     WAS REREAD REQUIRED?               J
         BZ    *+16                NO, BRANCH AND READ NEXT CARD      J
         L     R1,XXIOLSTC         REREAD- GET @ OF LAST BUFFER       J
         NI    AJIOSO,255-AJIOSORR CLEAR FLAG SO DON'T REREAD AGAIN   J
         B     XXIOBTBB            BRANCH AROUND READ                 J
         GET   (1)                 DO GET LOCATE ON DCB @
         AIF   (&$ASMLVL).XXNIORG      SKIP IF OS & HAVE NO IOREG (PUT)
*        WHEN DOS ISSUES A GET, R5 IS USED AS ITS IOREG (SINCE R1     *
*        IS ILLEGAL) TO POINT TO INPUT BUFFER. MUST LOAD R1 NOW.      *
         LR    R1,R5               GET @ OF INPUT RECORD
.XXNIORG ANOP
         ST    R1,XXIOLSTC         SAVE ADDRESS OF THIS BUFFER        J
XXIOBTBB EQU   *                   BRANCH HERE IF DOING REREAD        J
         SPACE 1
*              ***** BATCH CONTROL CARD PROCESSING *****
*              IF NOT RUNNING BATCH MODE, ANYTHING GOES; ELSE $JOB &
*              $ENTRY CARDS CREATE PSEUDO EOF AND ARE SAVED. $STOP
*              SETS REAL EOF FLAG TO TERMINATE PROCESSING
         TM    AJOMODE,AJOBATCH    ARE WE IN BATCH MODE
         BNZ   XXIOBTCC            YES, GO LOOK FOR CONTROL CARDS     J
         SPACE 1
*              THRU HERE ==> NORMAL CARD-SIMULATE READ
XXIONORM EQU   *                   ENTER HERE FOR NORMAL CARD
         SR    R3,R12              SUBTRACT 1 FROM LENGTH
         BM    XXIORETB            0 LENGTH READ(MUST BE FLUSHING)
         STC   R3,*+5              STORE LENGTH - 1 INTO MOVE
         MVC   0($CHN,R4),0(R1)    MOVE DESIRED PART OF CARD OVER
         AIF   (NOT &$KP26).XXNKP26         SKIP IF NO 026 KEYPUNCH
         SPACE 1
*              IF KP=26 OPTION USED, TRSANSLATE CARD TO EBCDIC.
         TM    AJIOSO,AJIOKP26     WAS KP=26 OPTION SPECIFIED
         BZ    XXIOKP29            NO, DON'T TRANSLATE, ALREADY -29
         STC   R3,*+5              STORE LENGTH-1 INTO TR
         TR    0($,R4),AJTRTB26    TRANSLATE AMOUNT READ BY RDR TO 029
XXIOKP29 EQU   *                   SKIP HERE IF NO TRANSLATE NEEDED
.XXNKP26 ANOP
         B     XXIORETB            RETURN, SHOWING NORMAL RETURN      P
         SPACE 1                                                      J
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *J*
*         BATCH CONTROL CARD SCANNING PROCESS -  NEW FOR VERSION 3.0 J*
*         THIS VERSION INCORPORATES MORE FLEXIBILITY, AND ALSO       J*
*         SUPPORTS HASP AUTOBATCH CODE AS AN OPTION.  MODULE ASSIST  J*
*         SETS FLAG AJOBTRQ TO SHOW THE TYPE OF CONTROL CARD THAT IT J*
*         IS REQUESTING (AJOBTRQ=0 OTHERWISE).  ACTIONS THEN DEPEND  J*
*         ON THE TYPE REQUESTED AND THE INPUT FOUND.  NOTE THAT THIS J*
*         CODE NOW PERFORMS THE FLUSH TO CONTROL CARD, RATHER THAN   J*
*         HAVING ASSIST LOOP LOOKING FOR ONE.                        J*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *J*
XXIOBTCC CLI   0(R1),C'&$BTCC(1)'  DOES CARD HAVE CONTROL CHARACTER?  J
         BNE   XXIOBTEE            NO, CAN'T BE CONTROL CARD, BRANCH  J
         CLC   =C'&$BTCC(2)',1(R1) IS IT JOB BEGINNER?                J
         LA    R15,AJO$J           SHOW CODE FOR JOB BEGINNER         J
         BE    XXIOBTFF            YES, GO HANDLE IT                  J
         AIF   ('&$BTCC(3)' EQ '').XXIOBT3   SKIP IF NO $ENTRY WANTED J
         CLC   =C'&$BTCC(3)',1(R1) WAS IT $ENTRY OR EQUIVALENT?       J
         LA    R15,AJO$E           SHOW CODE FOR $ENTRY               J
         BE    XXIOBTFF            YES, GO TO PROCESS IT              J
.XXIOBT3 AIF   ('&$BTCC(4)' EQ '').XXIOBT4  SKIP IF $STOP NOT ALLOWED J
         CLC   =C'&$BTCC(4)',1(R1) IS THIS A $STOP CARD OR EQUIV?     J
         BE    XXIOEOF             YES, TREAT AS REAL EOF             J
.XXIOBT4 ANOP                                                         J
XXIOBTEE SR    R15,R15             SET = AJOB$D, NOT A CONTROL CARD   J
XXIOBTFF EQU   *                   COME HERE TO MAKE PROCESS DECISION J
         SPACE 1                                                      J
         AIF   (NOT &$HASPBT).XXIOBT6  SKIP IF NOT HASP AUTOBATCH     J
*              HASP AUTOBATCH CODE FOLLOWS: SET UP TO READ OVER OS    J
*              JOB CARDS, HANDLE TWO NULLS AS REQUIRED, ALLOW READING J
*              OF SINGLE NULL, AND MAKE UP DUMMY $JOB CARD IF OMITTED J
*              FOLLOWING OS JOB CARD.                                 J
         CLC   0(2,R1),=C'//'      WAS THIS CARD // CARD?             J
         BNE   XXIOBTSS            NO, GO TO DETERMINE ACTION         J
         CLC   2(70,R1),AJOBLANK+2       WAS IT NULL CARD (COLS 3-72)?
         BNE   XXIOBTNN            NO, NOT A NULL CARD AT ALL-BRANCH  J
*              AT THIS POINT, WE HAVE 1 NULL.  NOW CHECK FOR 2ND.     J
         GET   XXSODCB             READ CARD, SET R1 => CARD          J
         ST    R1,XXIOLSTC         MAKE SURE @ CARD SAVED FOR LATER   J
         CLC   0(2,R1),=C'//'      COULD IT BE NULL?                  J
         BNE   XXIOBTHH            NO, GO TO HANDLE SINGLE NULL(GAH)  J
         CLC   2(70,R1),AJOBLANK+2       WAS IT NULL CARD (COLS 3-72)?
         BNE   XXIOBTHH            NOT NULL- BRANCH                   J
*              TWO NULL CARDS FOUND - ACTION DEPENDS ON REQUEST TYPE. J
         CLI   AJOBTRQ,AJO$J       WAS $JOB CARD ASKED FOR?           J
         BE    XXSORD              YES, GO BUFFER FLUSH AND DO GET    J
         OI    AJIOSO,AJIOSOHS     NEXT TIME-SHOW WILL NEED BUFFER FLSH
         AIF   ('&$BTCC(3)' EQ '').XXIOBT5 SKIP IF NO $ENTRY          J
         MVI   AJOBTYP,AJO$J       FAKE TO MAKE $ENTRY REQ QUIT       J
         CLI   AJOBTRQ,AJO$E       WAS IT ACTUALLY $ENTRY?            J
         BE    XXIORETB            RETURN NORMAL, WILL CALL FOR $JOB  J
.XXIOBT5 B     XXIOASJC            GO SHOW PSEUDO-END-FILE            J
*              FOLLOWING CODE FOR SINGLE NULL BY ITSELF IN JOB(?)     J
XXIOBTHH MVC   AJOJCLCD,AJOBLANK   BLANK OUT WORK AREA                J
         MVC   AJOJCLCD(2),=C'//'  CREATE DUMMY NULL CARD             J
         LA    R1,AJOJCLCD         SHOW @ NULL CARD                   J
XXIOBTJJ OI    AJIOSO,AJIOSORR     REREAD,DON'T LOSE LAST CARD        J
         SR    R15,R15             SHOW AJO$D => NON-CONTROL CARD     J
         B     XXIOBTSS            GO TO DETERMINE ACTION NEEDED      4
*              FOLLOWING CODE IF // CARD, BUT NOT NULL CARD           J
XXIOBTNN CLI   AJOBTRQ,AJO$J      SHOULD WE BE SCANNING FOR $JOB      J
         BNE   XXIOBTSS            NO, SO TREAT AS NORMAL DATA CARD   J
*              WE ASSUME THAT WE'RE ACTUALLY LOOKING AT OS JOB CARD   J
*              NOW: HERE IS PLACE FOR ACCOUNTING IF YOU WANT IT.      J
         GET   XXSODCB             SKIP OVER THE CARD                 J
         ST    R1,XXIOLSTC         SAVE @, IN CASE NEEDED LATER       J
         CLC   =C'&$BTCC(1)&$BTCC(2)',0(R1)  WAS IT A $JOB NEXT       J
         BE    XXIOBTOO            YES, THIS IS WHAT WE WANTED        J
*              NO $JOB CARD AFTER OS JOB: BE NICE AND FAKE ONE.       J
*              FOLLOWING STATEMENT CAN BE USED TO SUPPLY PARMS, SINCE J
*              ASSIST THINKS IT'S A $JOB CARD.  CHANGE AS DESIRED.    J
         MVC   AJOJCLCD,AJOBLANK   BLANK OUT CARD WORKAREA            J
         MVC   AJOJCLCD(15),=CL15'&$BTCC(1)&$BTCC(2) ASSUMED'         J
         LA    R1,AJOJCLCD         SHOW ADDRESS OF ASSEMBLED FAKE CARDJ
         OI    AJIOSO,AJIOSORR     MARK, SO DON'T LOSE LOOKAHEAD      J
XXIOBTOO LA    R15,AJO$J           FAKE CODE OF $JOB CARD             J
.XXIOBT6 ANOP
*              FOLLOWING CODE EXPECTS R15=0,1,2 TO INDICATE TYPE OF   J
*              CARD FOUND (DATA, $JOB, $ENTRY(MAYBE)).  USE TABLE TO  J
*              DETERMINE ACTION: FUNCTION OF TYPE REQESTED&THAT FOUND.J
XXIOBTSS STC   R15,AJOBTYP         SHOW THE TYPE ACTUALLY FOUND       J
         MH    R15,=H'3'           MULTIPLY TO GET OFFSET OF TABLE ROW
         SR    R14,R14             CLEAR FOR INSERT                   J
         IC    R14,AJOBTRQ         GET COLUMN SELECTOR: TYPE REQUEST  J
         AR    R15,R14             GET OFFSET OF CODE BYTE IN TABLE   J
         IC    R15,XXIOBTAB(R15)   GET CODE BYTE TO DETERMINE ACTION  J
*              ACTIONS:  0: LOOP (SEARCHING FOR $JOB/$ENTRY CARD);    J
*              4: RETURN NORMAL, COPYING CARD TO REQUESTED AREA;      J
*              8:  EXIT WITH END-FILE (CONTROL CARD FOUND IN DATA)    J
         B     *+4(R15)            TAKE INDEXED BRANCH                J
         B     XXSORE              0: LOOP, HUNTING CONTROL CARD      J
         B     XXIONORM            4: NORMAL RETURN, COPY CARD        J
*                                  8: FALL THRU INTO XXIOASJC         J
XXIOASJC OI    AJIOSO,AJIOPSEO+AJIOSORR PSEUDO-EOF, REREAD TO SAVE CARD
         B     XXIORETA            SHOW A PSEUDO END-FILE
XXIOEOF  OI    0(R2),AJIOEOF       SHOW END-FILE HAS OCCURRED
         B     XXIORETA            RETURN SHOWING END-FILE
*              ACTION CONTROL TABLE: USED IN XXIOBTSS CODE.  CHANGE   J
*              AS NEEDED IF DIFFERENT ACTIONS DESIRED.                J
*  AJOBTRQ=        DATA,$JOB,$ENTRY   (REQUEST).  ACTUAL FOUND BELOW  J
XXIOBTAB DC    AL1(0004,0000,0000)    DATA FOUND- NORMAL, LOOP, LOOP  J
         DC    AL1(0008,0004,0004)    $JOB FOUND- EOF, NORMAL, NORMAL J
         DC    AL1(0008,0000,0004) $ENTRY FOUND- EOF,LOOP,NORMAL      J
XXIOLSTC DS    A                   @ LAST CARD READ, FOR REREAD USE   J
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXPNCH   PUNCH A CARD, OPENING IF REQUIRED              *
*        CALLED BY $PNCH MACRO TO PUNCH A CARD (DDNAME FT07F001).  IF *
*        THE DCB XXPNDCB CANNOT BE OPENED, OR IF NOPUNCH WAS USED IN  *
*        THE USER PARM FIELD, THE CARD IS PRINTED (DDNAME FT06F001)   *
*        WITH ' CARD-->' PRECEDING IT TO NOTE USAGE.                  *
*        ENTRY CONDITIONS - SAME AS ENTRY XXXXREAD                    *
*        EXIT CONDITIONS                                              *
*   CC=  0     NORMAL RETURN, CARD WAS PUNCHED OR PRINTED             *
*   CC=  1     RECORD LIMIT HAS BEEN EXCEEDED, CARD PUNCHED ANYWAY    *
*        USES DSECTS: AJOBCON,IHADCB,XIOBLOCK                         *
*        USES MACROS: OPEN,PUT                                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXPNCH,REP        NOTE TEMPORARY USING
XXXXPNCH STM   R11,R5,XXIOSAVT     SAVE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         AIF   (NOT &$PUNCH).XXNPN0    SKIP IF NO REAL PUNCH
         LA    R2,AJIOPN           SHOW @ CONTROL BYTE
         TM    AJIOPN,AJIOPEN      HAS PUNCH BEEN OPENED?
         BO    XXPNC               YES, SO GO DO IT
         TM    AJIOPN,AJIODFLT     ARE WE ALREADY USING PRINTER?
         BO    XXPNNOPN            YES, SO GO FIX UP
         SPACE 1
*              CALL OPTIONAL UNIT OPEN ROUTINE TO OPEN PUNCH IF IT CAN.
         AIF   (&$ASMLVL).XXYIOCR  SKIP IF UNDER OS GENERATION
         LA    R1,XXPNDCB          SHOW @ OF DOS PUNCH DCB
.XXYIOCR AIF   (NOT &$ASMLVL).XXYSDTF  SKIP IF UNDER DOS GENERATION
         LA    R3,XXIOCPN          SHOW @ OPEN/CLOSE PARM VALUE
.XXYSDTF ANOP
         BAL   R4,XXIOPENO         CALL OPEN/FLAGGING ROUTINE, SETS CC
         BZ    XXIOPUT             IF OK, ALL SET UP, SO GO PUNCH
XXPNNOPN EQU   *                   SECTION TO USE PRINTER FOR PUNCH
.XXNPN0  ANOP
         LR    R2,R0               SAVE @ I/O AREA
         MVC   AJOPNDFT(8),=C' CARD-->'     ENTER CARD FLAG
         MVC   AJOPNDFT+8(80),0(R2)         MOVE POSSIBLE CARD OVER
         LA    R0,AJOPNDFT         FAKE I/O @ TO BE THIS AREA
         LH    R3,XIOLENG          GET LENGTH DESIRED TO PUNCH
         LA    R3,8(R3)            ADD EXTRA LENGTH OF ' CARD-->'
         LA    R1,XXPRDCB          SHOW @ OF PRINTER INSTEAD
         LA    R2,AJIOPR           SHOW @ CONTROL BYTE(IN CASE PAGE)
         B     XXPRPN              PRINT CARD INSTEAD OF PUNCHING
         AIF   (NOT &$PUNCH).XXNPN1         SKIP IF NOPUNCH
         SPACE 1
XXPNC    LA    R1,XXPNDCB          SHOW @ DCB
         B     XXIOPUT             GO TO COMMON PUT SECTION
.XXNPN1  ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXPRNT   PRINT ONE LINE OF OUTPUT                       *
*        CALLED BY $PRNT MACRO TO PRINT 1 LINE, USING DDNAME FT06F001.*
*        ENTRY CONDITIONS - SAME AS ENTRY XXXXREAD                    *
*        EXIT CONDITIONS - SAME AS XXXXPNCH                           *
*        USES DSECTS: AJOBCON,IHADCB,XIOBLOCK                         *
*        USES MACROS: PUT                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING XXXXPRNT,REP        NOTE TEMPORARY BASE
XXXXPRNT STM   R11,R5,XXIOSAVT     SAVE REGS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         DROP  REP                 KILL TEMPORARY USING
         LA    R1,XXPRDCB          SHOW @ PRINTER DCB
         LA    R2,AJIOPR           SHOW @ PRINTER CONTROL BYTE
         SPACE 1
* * * * * XXIOPUT - COMMON PUT ROUTINE FOR PNCH, PRNT                 *
XXIOPUT  TM    AJOMODE,AJOSRECX    ARE RECORDS ALREADY EXCEEDED
         BO    XXIORETA            YES, IGNORE THIS GUY
         SPACE 1
         LH    R3,XIOLENG          GET LENGTH OF REQUEST
*              ***** OUTPUT RECORD COUNT AND TESTING *****
XXPRPN   EQU   *                   ENTRY POINT IF FAKING PUNCH ON PRNTR
         L     R15,AJORECNT        GET CURRENT RECORDS REMAINING
         SR    R15,R12             DECREMENT
         BM    XXIOVERP            SKIP OUT, NO MORE-DON'T WRITE
         ST    R15,AJORECNT        STORE UPDATED COUNTER BACK
         SPACE 1
         AIF   (NOT &$PAGE).XXNPAG2         SKIP WHOLE SECT IF NO PAGE
         LR    R15,R0              MOVE @ USER AREA WHERE CAN USE IT
         MVC   AJIOWRKB,0(R15)     SAVE 1ST BYTE WHERE WE CAN GET IT
         TM    0(R2),AJIOPAGE      ARE WE 1)PRINTING AND 2)IN PAGE CONT
         BZ    XXNPAGEC            NO, WE AREN'T IN PAGE CONTROL MODE-B
         SPACE 1
*              ***** PAGE CONTROL MODE - PERFORM COINT,CHECK *****
         MVC   XXIOPCLI+1(1),0(R15)    MOVE CARRIAGE CONTROL IN FOR CLI
         LA    R2,XXIOPGTA         BEGINNING @ LEGAL CAR CON BYTE TABLE
         LA    R14,4               INCREMENT FOR BXLE SEARCH
         LA    R15,XXIOPGTZ        @ LAST ELEMNT IN TABLE,BXLE LIMIT
         SPACE 1
XXIOPCLI CLI   0(R2),$             COMPARE TABLE ELEMENT TO USER CARCON
         BE    XXIOPFND            FOUND WHAT HE USED-BRANCH
         BXLE  R2,R14,XXIOPCLI     LOOP UNTIL FIND IT OR RUN OUT
         SPACE 1
         LA    R2,XXIOPGTB         @ BLANK CARRAGE CONTROL TABLE ELEM.
XXIOPFND EQU   *                   CHARACTER FOUND
         TM    AJIOPR,AJIOSING     ARE WE IN CRUNCHED SINGLESPACE MODE?
         BZ    XXIONSIN            NO, NOT SINGLE SPACE MODE
*              FOLLOWING IMPLEMENTS SINGLE SPACE MODE, WHICH SINGLE
*              SPACES ANY CARRIAGE CONTROL EXCEPT '1', WHICH IS JUST
*              DOUBLE SPACED INSTEAD OF NEW PAGED.  THIS MAY BE USEFUL
*              FOR CRAMMING AS MUCH OUTPUT AS POSSIBLE IN GIVEN #
*              OF PAGES, OR OBTAINING AS MUCH OF A DUMP AS POSSIBLE.
         IC    R14,1(,R2)          GET OFFSET TO WORD FOR REPLACEMENT
         LA    R2,XXIOPGTA(R14)    GET @ REPLACEMENT CARRIAGE CONTROL
XXIONSIN EQU   *                   SKIP HERE IF NO SINGLE SPACE
         MVC   AJIOWRKB,0(R2)      PICK UP CORRECT BYTE FOR CC
         SPACE 1
         LM    R14,R15,AJOLREM     GET AJOLREM-AJOPREM FOR TESTING
         SH    R14,2(R2)           LINES REMAINING-LINES FOR GIVEN CCON
         BP    XXIOPSTL            STILL MORE-JUMP-NO OVERFLOW
         SPACE 1
*              OVERFLOW TO NEXT PAGE- COUNT <= 0
         MVI   AJIOWRKB,C'1'       SHOW NEW PAGE CARRAGE CONTROL
         L     R14,AJOL            RESET # LEFT ON PAGE TO LIMIT
         SR    R15,R12             # PAGES LEFT = # PAGES LEFT -1
         ST    R15,AJOPREM         STORE UPDATED PAGES REMAINING
         BM    XXIOVERP            PAGE COUNT EXCEEDED-SHOW OVERFLOW
XXIOPSTL ST    R14,AJOLREM         STORE BACK COMPLETED LINES LEFT
XXNPAGEC EQU   *                   BRANCH HERE IF NO PAGE CONTROL ON
.XXNPAG2 ANOP
         SPACE 1
         LR    R2,R0               MOVE @ DATA AREA OVER WHERE SAFE
         AIF   (&$ASMLVL).XXOSREC  SKIP IF UNDER OS GENERATION
         L     R4,8(R1)            @ OF DTF CCW (CONTAINS LRECL-1)
         LH    R4,6(R4)            ORIGINAL DTF LRECL FIELD - 1
         LA    R4,1(R4)            +1 => ORIGINAL DTF LRECL
         PUT   (1)                 DO DOS PUT, WITH IOREG AS SPECIFIED
*        WHEN DOS ISSUES A PUT, R5 IS USED AS THE IOREG (SINCE R1 IS  *
*        ILLEGAL) TO POINT TO NEXT OUTPUT BUFFER.  GET @ INTO R1.     *
         LR    R1,R5               @ OF DOS DTF OUTPUT BUFFER
.XXOSREC AIF   (NOT &$ASMLVL).XXDSREC  SKIP IF UNDER DOS GENERATION
         USING IHADCB,R1           USING FOR DCB DUMMY SECTION
         LH    R4,DCBLRECL         GET LRECL FIELD FROM DCB
         DROP  R1                  KILL USING
         PUT   (1)                 DO PUT LOCATE
.XXDSREC ANOP
*              NEXT 3 STMTS GUARD AGAINST I/O OF LENGTH > REAL LENGTH.
         CLR   R3,R4               IS I/O <= LRECL (CLR RATHER THAN CR)
         BNH   *+6                 YES, GOOD PERSON, SKIP OVER
         LR    R3,R4               NO, BAD PERSON, USE LRECL
         SR    R3,R12              DECREMENT LENGTH TO L-1
         BM    XXIOPUTA            SKIP IF 0 LENGTH
         STC   R3,*+5              STORE LENGTH-1 FOR MOVE
         MVC   0($CHN,R1),0(R2)    MOVE DATA OVER
XXIOPUTA SR    R4,R12              DECREMENT REG -LRECL FIELD
         AIF   (NOT &$PAGE).XXNPAG4         SKIP IF NO PAGE CONTROL
         MVC   0(1,R1),AJIOWRKB    PUT IN POSSIBLY-CHANGED CAR CON BYTE
.XXNPAG4 ANOP
         AR    R1,R3               GET @-1 OF 1ST BYTE FOR BLANK PAD
         SR    R4,R3               GET # BLANKS REQUIRED FOR PAD
         BZ    XXIOPUTC            SKIP IF NO BLANK PAD
         SR    R4,R12              DECREMENT TO L-1 FOR PAD
         STC   R4,*+5              STORE L-1 INTO MOVE
         MVC   1($CHN,R1),AJOBLANK BLANK PAD AT END OF RECORD
XXIOPUTC EQU   *                   EXIT HERE FOR NORMAL RETURN
         SPACE 1
* * * * * COMMON EXIT CODE FOR SORC,READ,PNCH,PRNT                    *
*        THIS SECTION MUST IMMEDIATELY FOLLOW XXIOPUT SECTION.        *
*        XXIORETA SETS CONDITION CODE TO 1, SHOWING EITHER END-FILE   *
*        ON INPUT DEVICE, OR RECORD OVERFLOW ON OUTPUT DEVICE.        *
*        XXIORETB SETS CC = 0 TO SHOW NO SPECIAL CONDITION.           *
XXIORETB SR    R0,R0               SET CC TO 0
XXIORETC LM    R11,R5,XXIOSAVT     RELOAD CHANGED REGS
         B     XIORETRN            RETURN APPROPRIATELY
XXIOVERP OI    AJOMODE,AJOSRECX    SHOW PAGES/RECORDS EXCEEDED
XXIORETA OI    *+1,1               SET CC TO 1
         B     XXIORETC            GO TO RELOAD AND RETURN
         AIF   (&$DISKU EQ 0).XNODISK  SKIP DISK UTILITY WHEN NODISK
         USING AVWXTABL,R7         NOTE MAIN TABLE USING
         USING XIOBLOCK,R14
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY:  XXXXDKOP    INITIALIZES FOR DISK UTILITY RUN             *
*              ALL XXXXDK ENTRIES BY RICHARD FORD, PAUL WEISSER.      *
*        XXXXDKOP IS CALLED FROM UTINT1 IF THE DISK UTILITY OPTION    *
*        IS ENABLED.  IT PERFORMS A STANDARD FORM OPEN ON THE DISK    *
*        UTILITY DCB,  INITIALIZES ANY VARIABLES USED BY THE DISK     *
*        UTILITY ROUTINES. XXXXDKOP ALSO COMPLETES THE DECB'S CREATED *
*        FOR BUFFER POOL MANAGEMENT BY FILLING IN THE RESPECTIVE      *
*        BUFFER ADDRESS. IN BATCH MODE XXXXDKOP RESETS THE DISK DATA  *
*        SET WITH A POINT MACRO INSTRUCTION.                          *
*                                                                     *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R13-> SAVE AREA POINTER                                *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R0 -> HOLDS LOW END ROINTER TO BUFFER AREA             *
*              R1 -> WORK REGISTER                                    *
*              R3 -> HOLDS NUMBER OF BUFFERS FOR LOOP CONTROL         *
*              R7 -> BASE REGISTER FOR AVWXTABL                       *
*                                                                     *
*        USES MACROS: POINT (OS), POINTS (DOS)                        *
*        USES DSECTS: AVWXTABL, XXIOBLOCK                             *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XXXXDKOP,R15        NOTE TEMPORARY USING
XXXXDKOP STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 KILL R15
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         NI    AJIODSK,255-AJIOEOF CLEAR EOF FLAG FOR BATCH RUN
         LA    R8,4+XXDKOFFL       GET OFFSET INTO BUFFER IN R8
         TM    XXDKUDCB+XXDKOPEN,XXMASK     IS DISK DCB/DTF OPEN
         BO    XXOPNPT             IF SO, GO ISSUE POINT MACRO
         AIF   (NOT &$ASMLVL).XXDR01  SKIP IF DOS GENERATION
         XC    XXDKBLKS(2),XXDKBLKS    CLEAR BLKSIZE FOR JCL
.XXDR01  LA    R2,AJIODSK          GET ADDRESS OF CONTROL BYTE
         AIF   (&$ASMLVL).XXDR1    SKIP IF OS GENERATION
         LA    R1,XXDKUDCB         GET ADDR OF DTF FOR OPEN
         AGO   .XXDR2
.XXDR1   LA    R3,XXIODSKU         R3 <-- ADDR OF REMOTE CLOSE WORD
.XXDR2   BAL   R4,XXIOPENO         OPEN DCB/DTF
         BM    XXEXIT              DID NOT OPEN---DISASTER
         OI    AJIODSK,AJIOPEN     SHOW DCB OPEN
XXOPNPT  L     R0,AVADDHIH         GET CURRENT HIGH CORE POINTER
         S     R0,XXDKLN           GET SPACE FOR FIRST BUFFER
         SR    R0,R8               BUMP PAST LENGTH USED WORD
         AIF   (&$BUFNO EQ 1).XXDKOPC  SKIP IF ONLY ONE BUFFER
         LA    R3,&$BUFNO-1        GET # OF BUFFERS - 1 FOR LOOP
.XXDKOPC ANOP
         LA    R1,XXDECB+4         GET ADDR OF 1ST DECB
         ST    R1,AVDECB           PUT ADDR OF DECB IN BCB
         LR    R1,R0               DUPLICATE BUFFER ADDR
         AR    R1,R8               BUMP PAST LENGTH USED WORD
         STM   R0,R1,AVBUFF@       INITIALIZE AVBCB
         A     R1,XXDKLN           COMPUTE ENDING BUFFER @
         ST    R1,AVBUFEND         PUT VALUE IN BCB
         AIF   (&$BUFNO EQ 1).XXDKOPA  SKIP IF ONLY ONE BUFFER
         L     R1,XXDECB           GET LINK IN R1
         ST    R1,AVDECBNX         PUT THIS IN BCB
.XXDKOPA ANOP
         LA    R1,XXDECB           GET DECB BLOCK ADDRESS
         ST    R0,XXDECBE(R1)      STORE 1ST BUFF @ IN DECB 1
         AIF   (&$BUFNO EQ 1 ).XXDKOPB  SKIP IF ONLY 1 BUFFER
         A     R8,XXDKLN           GET FULL BUFF LENGTH IN R8
         SR    R0,R8               GET NEXT BUFF @
         L     R1,0(R1)            GET LINK TO NEXT DECB
         ST    R0,XXDECBE(R1)      STORE NEW BUFF @ AT NEW DECB
         BCT   R3,*-10             LOOP FOR ALL DECBS
.XXDKOPB ANOP
         ST    R0,AVADDHIH         STORE UPDATED LOW END POINTER
         XDKPT XXDKUDCB,XXXPOINT   REPOSITION THE DISK
         SR    R2,R2               CLEAR R2 TO INITIALIZE COUNT
         B     XXXXDKRT            RETURN TO CALLER
XXEXIT   XI    AVTAGS1,AJODISKU    CANCEL DISK OPTION
         OI    *+1,1               SET CC TO MINUS TO FLAG UTINIT1
         B     XXXDKRTB            RETURN
         SPACE 2
XXDKEOF  EQU   *                   EOF EXIT ( FUTURE USE )
XXDKSYND OI    AJIODSK,AJIOEOF+AJIOSYND MARK END-FILE, ALSO SYNAD
         B     XXXDKRTB            RETURN
         SPACE 2
         AIF   (NOT &$ASMLVL).XXEX1    SKIP IF OS GENERATION
*              XXDKUDCB DCB EXIT - USE BLKSIZE FROM JCL IF GIVEN, ELSE
*              USE DEFAULT &$BLEN.
*              THIS CODE ONLY USEFUL IN OS/360 SYSTEM.
         USING XXDKEXCD,R15        LOCAL USING
         USING IHADCB,R1           @ DCB, SUPPLIED BY OPEN
XXDKEXCD LH    R0,DCBBLKSI         GET BLKSIZE FROM THE DCB
         SRA   R0,2                DIVIDE BY 4, TEST FOR ZERO
         SLL   R0,2                ALIGN TO FULLWORD MULTIPLE
         BNZ   *+8                 SKIP IF BLKSIZE FROM JCL
         LH    R0,=AL2(&$BLEN)     USE DEFAULT BUFFER LENGTH INSTEAD
         STH   R0,DCBBLKSI         STORE ACTUAL BLKSIZE TO BE USED
         SH    R0,=H'4'            WANT BLKSIZE-4 FOR LATER USE
         ST    R0,XXDKLN           SAVE IT WHERE EXPECTED
         BR    R14                 RETURN TO OPEN EXECUTOR
         DROP  R1,R15              REMOVE DCB, LOCAL USINGS
.XXEX1   ANOP
         TITLE 'DISK UTILITY READ'
         USING XXXXDKRD,REP        NOTE TEMPORARY USING
         USING XIOBLOCK,R14        FORMAT FOR CONTROL BLOCK
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->ENTRY XXXXDKRD   RETURN A SET OF RECORD BLOCKS TO UTGET2          *
*        XXXXDKRD IS CALLED BY UTGET2 WHEN IT HAS COMPLETED           *
*        PROCESSING A SET OF RECORD BLOCKS. XXXXDKRD RETURNS THE      *
*        ADDRESS OF THE NEXT BUFFER TO BE PROCESSD VIA THE BUFFER     *
*        CONTROL BLOCK AND RE-FILLS THE BUFFER WHICH WAS JUST         *
*        PROCESSED. WHEN ALL BLOCKS HAVE BEEN READ, XXXXDKRD CON-     *
*        TINUES TO ACCEPT CALLS UNTIL ALL BUFFERS HAVE BEEN           *
*        PROCESSED, AT WHICH TIME AN END-OF-FILE INDICATION           *
*        (CC=1) IS RETURNED.                                          *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R13-> BASE REGISTER AND SAVE AREA POINTER              *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R2 -> WORK REGISTER FOR COUNTER                        *
*              R3 -> DECB POINTER                                     *
*              R4 -> BUFFER POINTER                                   *
*                                                                     *
*        USES MACROS: READ, CHECK                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDKRD STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        GLOBAL USING
         DROP  REP                 DROP R15
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         LM    R3,R4,AVBCB         GET BCB INFO
         TM    AJIODSK,AJIOEOF     TEST IF LAST BLOCK READ
         AIF   (&$BUFNO NE 1).XXDKRDA   SKIP IF MORE THAN 1 BUFFER
         BO    XXCCSET             BRANCH TO SET CONDITION CODE
.XXDKRDA ANOP
         LH    R2,XXBLKCNT         SET R2 TO COUNTER VALUE
         BCT   R2,XXDKNZ           IF COUNT =0 TAKE BRANCH
         AIF   (&$BUFNO EQ 1).XXDKRDB   SKIP IF ONLY ONE BUFFER
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        LAST REAL READ HAS BEEN PERFORMED---RESET COUNTER TO         *
*        EMPTY ALL BUFFERS; SET FLAG TO SHOW END-OF-FILE              *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BO    XXCCSET             IF LAST BLK PASSED, SET CC
.XXDKRDB ANOP
         OI    AJIODSK,AJIOEOF     SET END-OF-FILE FLAG
         AIF   (&$BUFNO EQ 1).XXDKRDC   SKIP IF ONLY ONE BUFFER
         LA    R2,&$BUFNO          GET COUNT OF BUFFERS
         B     XXDKREAD            GO AND READ LAST BLOCK
         SPACE 2
.XXDKRDC ANOP
XXDKNZ   EQU   *
         AIF   (&$BUFNO EQ 1).XXDKRDE   SKIP IF ONLY ONE BUFFER
         BO    XXDKNM               IF END FLAG SET, SKIP READ
.XXDKRDE ANOP
XXDKREAD XDKCHK    (R3),XXDKUDCB,DOS   CHECK BEFORE GIVING OUT BLOCK
         XDKRD (R3),XXDKUDCB,(R4)  READ A BLOCK
         AIF   (&$BUFNO EQ 1).XXRDD    SKIP IF ONLY 1 BUFFER
XXDKNM   BAL   R14,XXFIXUP         GO UPDATE POINTERS
.XXRDD   AIF   (&$ASMLVL).XXRDD1       SKIP IF OS GEN
         TM    AJIODSK,AJIOEOF     IF EOF IS SET,
         BZ    XXXXDKRT            DO NOT CHECK LAST BLOCK
.XXRDD1  XDKCHK    (R3),XXDKUDCB   CHECK BEFORE GIVING OUT BLOCK
         SR    R0,R0               SET CC TO NOT NEGATIVE
         B     XXXXDKRT            RETURN TO CALLER
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        LAST BLOCK HAS ALREADY BEEN PASSED--- SET CC & RETURN        *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXCCSET  OI    *+1,1               SET CC TO MINUS
         B     XXXDKRTB            RETURN TO CALLER
         TITLE 'END PASS1 INITIALIZE FOR PASS2'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXDKE1    COMPLETE PASS1 PROCESSING, SET UP FOR PASS 2  *
*        XXXXDKE1 IS CALLED FROM UTEND1.  XXXXDKE1 WRITES LAST BUFFER *
*        OR IF NO PREVIOUS WRITES WERE PERFORMED,  PASSES UTGET2 THE  *
*        INITIAL ADDRESS OF THE ONLY BUFFER USED.  IF AT LEAST 1      *
*        WRITE TO DISK WAS DONE,  XXXXDKE1 POINTS THE DISK TO START   *
*        AND READS N-1 BUFFERS FROM THE DISK AND SETS UP FOR          *
*        PASS 2 OF THE ASSIST ASSEMBLER.                              *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R2 -> COUNTER WORK REGISTER                            *
*              R3 -> DECB POINTER                                     *
*              R4 -> BUFFER POINTER                                   *
*              R8 -> WORK REGISTER                                    *
*                                                                     *
*        USES DSECTS: XXIOBLOCK, AVWXTABL                             *
*        USES MACROS: READ, WRITE, POINT, CHECK                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XXXXDKE1,REP        TEMPORARY USING
XXXXDKE1 STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        NOTE GLOBAL USING
         DROP  REP                 DROP TEMPORARY USING
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         LH    R2,XXBLKCNT         GET # OF BLOCKS TO BE READ
         AIF   (&$BUFNO EQ 1).XXDKEA   SKIP IF JUST 1 BUFFER
         LTR   R2,R2               IS IT 0?
         BNP   XXONEBLK            TAKE BRANCH TO ONE BLK WRITTEN
         L     R6,AVDECBLT         GET POINTER TO LAST DECB
         XDKCHK  (R6),XXDKUDCB     ISSUE CHECK
.XXDKEA  ANOP
XXONEBLK LM    R3,R5,AVBCB         OBTAIN NEEDED VALUES
         SR    R5,R4               GET BUFFER USED LENGTH
         ST    R5,XXDKOFFL(,R4)    STORE LENGTH IN BUFFER
         XDKWT (R3),XXDKUDCB,(R4)  WRITE THE BLOCK
         XDKCHK  (R3),XXDKUDCB     CHECK COMPLETION OF LAST WRITE
         XDKPT XXDKUDCB,XXXPOINT   POINT TO THE FIRST RECORD
         AIF   (&$BUFNO NE 1).XXDK1    SKIP IF MORE THAN 1 BUFFER
         ST    R4,AVBUFINC         RESET LENGTH WORD
         AR    R2,R12              INCREMENT COUNTER
         B     XXXXDKRT            GO RETURN
.XXDK1   AIF   (&$BUFNO EQ 1).XXDEC    SKIP IF 1 BUFFER
         AR    R2,R12              INCREMENT THE COUNTER
         LA    R8,&$BUFNO-1        GET # OF BUFFERS LESS 1
         LR    R6,R12              INITIALIZE TO GET ALL INFO
XXEPRD1  XDKRD (R3),XXDKUDCB,(R4)  READ FIRST BLOCK
         AR    R6,R12              INCREMENT READ COUNTER
         SR    R2,R12              DECREMENT BLOCK COUNTER
         BZ    XXFEWER             IF ZERO GO TO XXFEWER
         BAL   R14,XXFIXUP         ELSE MOVE POINTERS TO NEXT BLOCK
         BCT   R8,XXEPRD1          LOOP TO CONTINUE READING
         B     XXXXDKRT            RETURN TO CALLER
XXFEWER  OI    AJIODSK,AJIOEOF     SET LAST-BLOCK-READ FLAG
         STH    R6,XXBLKCNT        STORE # OF FULL BUFFERS
         BAL   R14,XXFIXUP         BRANCH TO UPDATE POINTERS
         BCT   R8,XXFIXUP          LOOP TO POSITION DECB POINTERS
         B     XXXDKRTB            RETURN TO CALLER
.XXDEC   ANOP
         TITLE 'DISK UTILITY WRITE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXDKWT     WRITE A FULL BUFFER TO DISK                  *
*        XXXXDKWT IS CALLED FROM UTPUT1 WHEN PASS1 HAS FILLED A       *
*        BUFFER.  XXXXDKWT WRITES THE BUFFER TO DISK AND UPDATES      *
*        THE BUFFER MANAGEMENT TABLE WHICH RETURNS THE ADDRESS OF     *
*        THE NEXT AVAILABLE BUFFER TO UTPUT1.                         *
*                                                                     *
*        REGISTER ASSIGNMENTS                                         *
*              R13-> BASE REGISTER AND SAVE AREA POINTER              *
*              R14-> XIOBLOCK POINTER REGISTER                        *
*              R15-> TEMP. BASE REGISTER                              *
*              R3 -> POINTER TO CURRENT DECB                          *
*              R4 -> BUFFER POINTER                                   *
*              R5 -> BUFFER LENGTH USED ACCUMULATOR                   *
*              R6 -> POINTER TO OLD DECB                              *
*                                                                     *
*        USES DSECTS: AVWXTABL, XXIOBLOCK                             *
*        USES MACROS: WRITE, CHECK                                    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING XXXXDKWT,REP        NOTE TEMP USING
XXXXDKWT STM   R11,R8,XXIOSAVT     SAVE REGISTERS IN LOCAL AREA
         LM    R11,R13,XXIOAJOB    LOAD BASE REGISTERS AND CONSTANT 1
         USING XXIOSAVE,R13        NOTE GLOBAL USING
         DROP  REP                 KILL TEMP USING
         L     R7,AJOVWXPT         GET ADDRESS OF MAIN TABLE
         LH     R2,XXBLKCNT        GET CURRENT COUNTER VALUE
         AIF   (&$BUFNO EQ 1).XXWTA    SKIP IF ONLY 1 BUFFER
         LTR   R2,R2               IS THIS FIRST CALL TO THIS ENTRY
         BZ    XXXX1ST             IF IT IS, SKIP CHECK
         L     R6,AVDECBLT         GET POINTER TO LAST DECB
         XDKCHK  (R6),XXDKUDCB     ISSUE CHECK
.XXWTA   ANOP
XXXX1ST  LM    R3,R5,AVBCB         OBTAIN NEEDED VALUES
         SR    R5,R4               SUBTRACT TO GET LENGTH OF INFO
         ST    R5,XXDKOFFL(,R4)    STORE LENGTH IN BUFFER
         XDKWT (R3),XXDKUDCB,(R4)  WRITE THE RECORD(BLOCK)
         AIF   (&$BUFNO NE 1).XXWTB   SKIP IF > 1 BUFFER
         XDKCHK  (R3),XXDKUDCB     CHECK LAST WRITE
.XXWTB   ANOP
         AR    R2,R12              INCREMENT COUNTER
         AIF   (&$BUFNO EQ 1).XXWTC    SKIP IF ONLY 1 BUFFER
         BAL   R14,XXFIXUP         GO TO FIXUP ROUTINE
.XXWTC   AIF   (&$BUFNO NE 1).XXWTD    SKIP IF BUFNO > 1
         LA    R4,4(R4)            INCREMENT POINTER PAST LENGTH WORD
         ST    R4,AVBUFINC         STORE AVBUFINC BACK INTO BCB
.XXWTD   ANOP
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                                                     *
*        COMMON RETURN CODE FOR DISK ROUTINES                         *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXXXDKRT STH   R2,XXBLKCNT         STORE UPDATED COUNTER
XXXDKRTB LM    R11,R8,XXIOSAVT     RESTORE REGISTERS
         B     XIORETRN            RETURN TO CALLER
         AIF   (&$BUFNO EQ 1).XXFXA    SKIP WHOLE SECTION IF 1 BUFFER
         TITLE 'DISK UTILITY BCB UPDATE ROUTINE'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: XXFIXUP     UPDATE BCB POINTERS TO NEXT BUFFER            *
*                                                                     *
*        XXFIXUP UPDATES THE POINTERS IN THE BCB, MOVING THE NEXT     *
*        I/O OPERATION TO THE NEXT BUFFER.                            *
*                                                                     *
*        ENTRY CONDITIONS:   R3-> ADDRESS OF CURRENT DECB.            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XXFIXUP  ST    R3,AVDECBLT         STORE ADDR FOR BACKWARD REFERENC
         L     R3,AVDECBNX         LINK TO NEXT DECB BLOCK
         MVC   AVDECBNX(4),0(R3)   MOVE LINK TO AVBCB
         LA    R3,4(R3)            GET DECB @ FOR NEXT BUFFER
         L     R4,XXDECBIN(R3)     GET BUFFER ADDRESS
         LA    R5,4+XXDKOFFL(R4)   BUMP PAST LENGTH USED WORD
         STM   R3,R5,AVDECB        FILL PART OF THE BCB
         A     R5,XXDKLN           GET BUFFER ENDING ADDRESS
         ST    R5,AVBUFEND         COMPLETE BCB BLOCK
         BR    R14                 RETURN TO CALLER
.XXFXA   ANOP
XXDKLN   DC    A(&$BLEN-4)         BUFFER LENGTH FOR HIGH END POINT
XXXPOINT DC    X'00000100'         POINT CONTROL WORD
XXBLKCNT DS    H                   COUNTER HALF-WORD
XXDECB   XXDKDECB  &$BUFNO         DEFINE DECB TABLE
         DROP  R7                  DELETE AVWXTABL USING
.XNODISK ANOP
         EJECT
         AIF   (NOT (&$PUNCH OR &$DATARD OR (&$DISKU NE 0) OR &$MACSLB)#
               ).XXNRP4            SKIP IF NO SPECIAL OPEN NEEDED
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: XXIOPENO   OPEN OPTIONAL DATA SET, FIX FLAGS              *
*        XXIOPENO IS CALLED FROM ENTRIES XXXXREAD OR XXXXPNCH TO      *
*        OPEN A DCB, FLAG ITS AJIO-- BYTE AJIODFLT IF OPEN FAILS,     *
*        OR AJIOPEN IF IT GOES.  IF OPEN OK, THE OPEN/CLOSE PARM WORD *
*        ADDED TO THE FRONT OF CURRENT LIST BEING BUILT FOR CLOSING.  *
*        UNDER DOS GENERATIONS, NO OPEN/CLOSE PARM WORD IS PRESENT,   *
*        SO JUST OPEN AND SET RETURN CODE.                            *
*        ENTRY CONDITIONS                                             *
*   R1 = @ OF DCB (XXREDCB, XXPNDCB) UNDER DOS GENERATIONS ONLY       *
*   R2 = @ AJIO-- CONTROL BYTE (AJIORE, AJIOPN)                       *
*   R3 = @ OPEN/CLOSE PARM WORD (XXIOCRE, XXIOCPN)                    *
*   R4 = RETURN @ TO CALLING SECTION OF CODE                          *
*        EXIT CONDITIONS                                              *
*   R1 = @ OF DCB (XXREDCB, XXPNDCB)                                  *
*   R2 = @ AJIO-- FLAG BYTE (SAME AS ON ENTRY)                        *
*   R0,R14 ARE PRESERVED FROM EFFECTS OF OPEN                         *
*   CC = 0 ==> OPEN WENT.  AJIO-- FLAG FLAGGED WITH AJIOPEN.          *
*   CC = 1 ==> OPEN FAILED.  AJIO-- BYTE FLAGGED WITH AJIODFLT.       *
*   XXIOCPTR=XXIOCPTR-4 IF OPEN OK, OPEN/CLOSE WORD MOVE ALSO.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).XXNIHA   SKIP IF UNDER OS GENERATION
XXIOPENO OPEN  (1)                 OPEN OPTIONAL DATA SET
         LM    R14,R0,XXIOSAVT+12  RELOAD MESSED UP REGISTERS
         TM    15(R1),X'20'        DID THE OPEN GO
         BZ    XXIOPENQ            YES, OPEN WENT
.XXNIHA  AIF   (NOT &$ASMLVL).XXYIHA   SKIP IF UNDER DOS GENERATION
XXIOPENO LR    R1,R3               MOVE PTR TO OPEN/CLOSE WORD OVER
         OPEN  MF=(E,(1))          DO REMOTE OPEN
         LM    R14,R0,XXIOSAVT+12  RELOAD MESSED-UP REGISTERS
         L     R1,0(R3)            GET @ DCB FROM OPEN/CLOSE PARM
         USING IHADCB,R1           NOTE DCB DSECT USING
         TM    DCBOFLGS,X'10'      DID THE OPEN GO?
         BO    XXIOPENQ            YES, OPEN WENT
         DROP  R1                  KILL USING
.XXYIHA  ANOP
         SPACE 1
         OI    0(R2),AJIODFLT      OPEN FAILED, USE DEFAULT DATA SET
         BR    R4                  RETURN TO CALLER, CC=1 AT MOMENT
         SPACE 1
*        OPEN SUCCEEDED. MARK DATA SET OPEN. ADD ITS OPEN/CLOSE PARM  *
*        WORD TO FRONT OF LIST SO IT WILL BE CLOSED LATER (OS ONLY).  *
XXIOPENQ OI    0(R2),AJIOPEN       SHOW OPEN OK
         AIF   (NOT &$ASMLVL).XXNPRMW  NO DOS PARM WORD LIST
         L     R15,XXIOCPTR        GET CURRENT PTR TO OPEN/CLOSE LIST
         SH    R15,=H'4'           SUBTRACT TO GET NEXT POSITION
         ST    R15,XXIOCPTR        STORE UPDATED VALUE
         MVC   0(4,R15),0(R3)      MOVE NEW OPEN/CLOSE PARM IN
         NI    0(R15),X'7F'        REMOVE LEADING BIT, SINCE NOT LAST
.XXNPRMW ANOP
         SR    R15,R15             SET CC=0 TO SHOW SUCCESSFUL
         BR    R4                  RETURN TO CALLING CODE
         SPACE 1
.XXNRP4  AIF   (NOT &$ASMLVL).XXNPN2   NO LIST FORMS UNDER DOS
XXIOCPTR DS    A                   @ 1ST VALID OPEN/CLOSE PARM IN LIST
*              OPEN/CLOSE PARM VALUES.  ORDER REQUIRED NEXT 2 CARDS.
         DS    2F                  FOR RE, PN OPEN/CLOSE PARMS
         AIF   (&$DISKU LT 1).XXNDKOP
         DS    F                   ROOM FOR DISK UTILITY PARM WORD
.XXNDKOP AIF   (NOT &$MACSLB).XXNMCLB  SKIP WORD IF NOT NEEDED
         DS    A                   SPACE FOR ANOTHER PTR WORD
.XXNMCLB ANOP
XXIOCSP  OPEN  (XXSODCB,INPUT,XXPRDCB,OUTPUT),MF=L    SET UP VALUES
         SPACE 1
         AIF   (NOT &$DATARD).XXNRE2        SKIP IF NO DATA RDR
XXIOCRE  OPEN  (XXREDCB,INPUT),MF=L         SET UP VALUE HERE
.XXNRE2  AIF   (NOT &$PUNCH).XXNPN2         SKIP IF NO REAL PUNCH
XXIOCPN  OPEN  (XXPNDCB,OUTPUT),MF=L        SET UP VALUE HERE
.XXNPN2  ANOP
         AIF   (&$DISKU EQ 0).XXNDOPN  SKIP IF NO DISK OPTION
         AIF   (NOT &$ASMLVL).XXNDOPN  SKIP IF OS GENERATION
XXIODSKU OPEN  (XXDKUDCB,(OUTIN)),MF=L
.XXNDOPN ANOP
         EJECT
         AIF   (NOT &$MACSLB).XXNMCOP
XXLIBCLS OPEN  (XXLIBDCB,INPUT),MF=L   LIST FORM FOR MACRO LIBRARY OPEN
         EJECT
         SPACE 10
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> ENTRY: XXXXLBOP                                                   *
*              XXXXLBOP INITIALIZES FOR A MACRO LIBRARY RUN.  XXXXLBOP*
*        IS CALLED BY MOCOMSYS IN MCON1.  IT OPENS THE SYSTEM LIBRARY *
*        DCB IF NECESSARY, ALLOCATES BUFFER SPACE IN HIGH CORE, AND   *
*        SETS SWITCH IN XXXXSORC SUCH THAT XXXXSORC PROVIDES INCARD   *
*        THE ADDRESS OF A CARD IMAGE FROM THE SYSTEM LIBRARY BUFFER   *
*        INSTEAD OF FROM THE NORMAL SYSIN DATA SET.  ALSO SETS THE    *
*        ADDRESS INTO THE GLOBAL TABLE NEEDED BY THE SUPPORTING       *
*        ROUTINES.                                                    *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              PSEUDO-STANDARD OS LINKAGE (SAVING ONLY NEEDED REG)    *
*              R1=> BASE FOR IHADCB DSECT                             *
*              R4=> BASE FOR XLBDSECT DSECT                           *
*              R7=> AVWXTABL BASE REGISTER                            *
*              R13=> SAVE AREA POINTER AND MAIN BASE REGISTER         *
*              R15=> TEMP BASE REGISTER                               *
*                                                                     *
*        USES MACROS:                                                 *
*              $ALLOCH                                                *
*                                                                     *
*        USES DSECTS:                                                 *
*              AVWXTABL, XLBDSECT, IHADCB                             *
*                                                                     *
*        EXIT CONDITIONS:                                             *
*              CC = 1 (MINUS) IF OPEN DID NOT GO                      *
*              AND ZERO (0) IF OPEN WENT                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING AVWXTABL,R7         NOTE MAIN TABLE USING
         USING XXXXLBOP,R15        TEMP BASE REGISTER
XXXXLBOP STM   R11,R8,XXLBSAVT     SAVE REGISTERS TO BE CHANGED
         LM    R11,R13,XXIOAJOB    LOAD NEEDED VALUES
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 CLEAN UP USINGS
         L     R7,AJOVWXPT         GET MAIN TABLE ADDRESS
         MVC   AVLIBBUF,AWZEROS    ZERO THE GLOBAL WORD
         TM    XXLIBDCB+48,X'10'   IS THE LIBRARY DCB ALREADY OPEN
         BO    XXLBALOP            YES-- GO TO ALREADY OPEN
         LA    R2,XXLBFLG          R2 <-- ADDRESS OF CONTROL BYTE
         LA    R3,XXLIBCLS         R3 <-- DDDRESS OF REMOTE CLOSE WORD
         BAL   R4,XXIOPENO         GO DO OPEN
         BM    XXLBOVR             OPEN DID NOT GO -- HURT
         SPACE 2
*        OPEN WENT SO COMPLETE LIBRARY RUN SET UP
         SPACE 2
XXLBALOP LA    R1,XXLIBDCB         GET ADDRESS OF LIBRARY DCB
         USING IHADCB,R1           SET USING FOR DCB DSECT
         LH    R2,DCBBLKSI         GET BLOCK SIZE FROM THE DCB
         SPACE 2
*        ROUND UP TO A D-WORD MULTIPLE TO BE SURE
         SPACE 2
         LA    R2,7+XLBUFCNT(R2)   ADD 7 PLUS LENGTH OF CONTROL AREA
         SRL   R2,3                DIVIDE BY 8
         SLL   R2,3                MULTIPLY BY 8
         SPACE 2
*        GET THE SPACE FOR THE BUFFER AND CONTROL WORDS IN HIGH CORE
         SPACE 2
         USING XLBDSECT,R4         NOTE LIBRARY DSECT
         $ALLOCH R4,R2,XXLBOVR     GET THE SPACE IN HIGH CORE
         MVI   XXLBFLG,X'FF'       SET FLAG TO SHOW BUFFER ALLOCATED
         SPACE 2
*        INITIALIZE GLOBAL CONTROL WORD
         ST    R4,AVLIBBUF         STORE BUFFER AND CONTROL BLOCK
*                                  ADDRESS IN THE GLOBAL TABLE
         SPACE 2
*        INITIALIZE THE BUFFER CONTROL WORDS
         SPACE 2
         ST    R2,XLBUFLNG         STORE TOTAL LENGTH IN CONTROL WORD 1
         AR    R2,R4               GET START PLUS LENGTH IN R2
         ST    R2,XLBUFEND         STORE IN CONTROL WORD 2
         SR    R2,R4               REMOVE STARTING ADDRESS
         LA    R2,XLBUFCNT(R4)     GET REAL BUFFER START ADDRESS
         LR    R3,R2               DUPLICATE FOR MUTIPLE STORE
         STM   R2,R3,XLBUFSTR      STORE IN CONTROL WORDS 2 & 3
         DROP  R4,R1               CLEAN UP USINGS
         SPACE 2
*        SET XXXXSORC SWITCH TO ALWAYS BRANCH
         SPACE 2
         MVI   XXSWTCH+1,X'F0'     SET SWITCH TO BRANCH
         SPACE 2
         SR    R0,R0               MAKE CC NOT MINUS
XXLBOUTA LM    R11,R8,XXLBSAVT     RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         SPACE 2
*        STORAGE OVERFLOW EXIT
         SPACE 2
XXLBOVR  OI    *+1,1               SET CC TO MINUS
         B     XXLBOUTA            RETURN
         DROP  R7,R13              CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> ENTRY: XXXXFIND                                                   *
*              XXXXFIND DOES A D-TYPE FIND ON EACH MACRO THAT IS      *
*        REQUIRED BY THE USER PROGRAM AS DEFINED ON THE SYSLIB CARD.  *
*        CALLED FROM MOCOMSYS IN THE MCON1 CSECT.                     *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              R12 => AVWXTABL BASE REGISTER                          *
*              R13 => SAVE AREA  POINTER AND MAIN BASE REGISTER       *
*              R14 => DCB ADDRESS                                     *
*                                                                     *
*        ENTRY CONDITIONS:                                            *
*              MEMBER NAME IS IN AVMSYMBL                             *
*                                                                     *
*        EXIT CONDITIONS:                                             *
*              CC SET TO ZERO IF ALL WENT WELL                        *
*              CC SET TO MINUS IF NAME COULD NOT BE FOUND             *
*                                                                     *
*        USES MACROS:                                                 *
*              FIND                                                   *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING AVWXTABL,R12        NOTE MAIN TABLE USING
         USING XXXXFIND,R15
XXXXFIND STM   R11,R1,XXLBSAVT     SAVE REGISTERS THAT MIGHT CHANGE
         L     R13,XXIOAJOB+8      GET BASE REGISTER SET UP
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 CLEAN UP USING SITUATION
         SPACE 2
         MVC   XXFNDDW,AVMSYMBL    PUT NAME ON A D-WORD BOUNDRY
         SPACE 2
         FIND  XXLIBDCB,XXFNDDW,D  DO THE FIND
         LTR   R15,R15             TEST RETURN CODE FROM FIND ROUTINE
         BNZ   XXFNDERR            COULDNOT FIND NAME--SET UP BAD RTN
         SPACE 2
         SR    R0,R0               MAKE CC NOT MINUS
XXXXFDOT LM    R11,R1,XXLBSAVT     RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         SPACE 2
XXFNDDW  DS    D                   D-WORD ALIGNED PLACE FOR MEMBER NAME
XXFNDERR OI    *+1,1               SET CC TO MINUS FOR RETURN
         B     XXXXFDOT            RETURN
         DROP  R12,R13             CLEAN UP USINGS
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> ENTRY: XXXXLBRD                                                   *
*                                                                     *
*              CALLED BY INCARD VIA XXXXSORC TO PROVIDE THE MACRO     *
*        PROCESSOR WITH DEBLOCKED RECORDS FROM THE SYSTEM MACRO       *
*        LIBRARIES.  FUNCTIONS AS AN INSUB TO ENTRY XXXXSORC.         *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              SAME AS XXXXSORC: EXCEPT R12 IS BASE FOR AVWXTABL      *
*                                                                     *
*        ENTRY CONDITIONS:                                            *
*              SAME AS XXXXSORC                                       *
*              ADDITIONALLY -- INCARDS DATA AREA COMES OVER IN        *
*              REGISTER R0 AND MUST BE PROTECTED FROM SYSTEM ACTIONS  *
*                                                                     *
*        USES DSECTS:                                                 *
*              XLBDSECT, IHADCB                                       *
*                                                                     *
*        USES MACROS:                                                 *
*              READ, CHECK                                            *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING XXIOSAVE,R13        NOTE MAIN USING
         USING IHADCB,XXXLBDCB
XXXXLBRD STM   R6,R7,XXLBSAVT      SAVE SOME WORK REGISTERS
         L     R12,AJOVWXPT        GET AVWXTABL BASE ADDRESS
         USING AVWXTABL,R12        NOTE MAIN TABLE USING
         L     R3,AVLIBBUF         GET ADDRESS OF BUFFER SPACE
         USING XLBDSECT,R3         NOTE LIBRARY DSECT USING
         LR    R4,R0               MOVE DATA AREA ADDRESS OVER
         SPACE 2
XXXLBDCB EQU   R5                  HOLDS THE LIBRARY DCB ADDRESS
XXRECPT  EQU   R6                  HOLDS ADDRESS OF CARD IMAGE
XXBUFEND EQU   R7                  POINTER TO THE END OF THE BUFFER
         SPACE 2
         LM    XXRECPT,XXBUFEND,XLBUFSTR   GET CONTROL INFORMATION
         CR    XXRECPT,XXBUFEND    IS BUFFER EMPTY
         BNL   XXXLIBRD            YES--GO READ A NEW BUFFER FULL
         SPACE 2
XXLBRCPT MVC   0(80,R4),0(XXRECPT) MOVE CARD WHERE INCARD EXPECTS
         LA    XXRECPT,80(XXRECPT) INCREMENT TO NEW RECORD
         SPACE 2
*        SET UP FOR RETURN
         SPACE 2
         ST    XXRECPT,XLBUFSTR    SAVE UPDATED RECORD POINTER
XXLBRDRT LM    R6,R7,XXLBSAVT      RESTORE REGISTERS
         B     XXIORETB            RETURN TO CALLER (INCARD)
XXXLIBRD LA    XXXLBDCB,XXLIBDCB   GET DCB ADDRESS IN A REG
         LA    XXRECPT,XLIBBUF     GET AREA ADDRESS INTO XXRECPT REG
         READ  XXLBDECB,SF,(XXXLBDCB),(XXRECPT),'S'   READ A BLOCK
         CHECK XXLBDECB            CHECK FOR I/O COMPLETION
         SPACE 2
         LH    XXBUFEND,DCBBLKSI   GET BLOCKSIZE FROM DCB
         L     R2,XXLBDECB+16      GET IOB ADDRESS
         SH    XXBUFEND,14(R2)     GET RELATIVE END OF NEW BLOCK
         LA    XXBUFEND,XLBUFCNT(R3,XXBUFEND)  GET ABSOULUTE END OF NEW
*                                  BLOCK
         ST    XXBUFEND,XLBUFCED   SET CONTROL WORD 4, CURRENT END
         B     XXLBRCPT            GO TO DEBLOCK
XXMCEODD MVC   0(80,R4),AWBLANK    BLANK OUT AREA FOR CARD
         MVC   10(4,R4),=C'MEND'   PUT MEND CARD IMAGE THERE
         B     XXLBRDRT            RETURN VIA XXXXSORC, INCARD
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         DROP  R3,R5,R12,R13       CLEAN UP USINGS
*-> ENTRY: XXXXLBED                                                   *
*                                                                     *
*              CALLED 1 TIME BY THE MAIN PROGRAM MCON1 TO INSURE      *
*        THAT THE XXXXSORC SWITCH BRANCH IS SET FOR NORMAL PROCESSING.*
*        ALSO CALLED BY MOCOMSYS IN MCON1 TO DEALLOCATE THE BUFFER    *
*        AND CONTROL WORD SPACE AND TO RESET THE XXXXSORC SWITCH      *
*        BRANCH TO THE NORMAL CONDITION.                              *
*                                                                     *
*        REGISTER ASSIGNMENTS:                                        *
*              R2=> AVWXTABL BASE REGISTER                            *
*              R13 => SAVE AREA POINTER AND MAIN BASE REGISTER        *
*              R15 => TEMP BASE REGISTER                              *
*                                                                     *
*        USES DSECTS:                                                 *
*              XLBDSECT                                               *
*                                                                     *
*        USES MACROS:                                                 *
*              $DALLOCH                                               *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 5
         USING AVWXTABL,R2         NOTE TABLE USING
         USING XXXXLBED,R15        TEMP USING
XXXXLBED STM   R11,R2,XXLBSAVT     SAVE SOME WORK REGISTERS
         LM    R11,R13,XXIOAJOB    GET NEEDED VALUES
         L     R2,AJOVWXPT         GET BASE VALUE FOR MAIN TABLE
         USING XXIOSAVE,R13        NOTE MAIN USING
         DROP  R15                 CLEAN UP USING SITUATION
         TM    XXLBFLG,X'FF'       IS THERE A BUFFER AROUND?
         BZ    XXEDSET             NO -- DO NOT DE-ALLOCATE THE BUFFER
         SPACE 2
*        DEALLOCATE BUFFER SPACE IN HIGH FREEAREA
         SPACE 2
         L     R15,AVLIBBUF        GET ADDRESS OF BUFFER AREA
         USING XLBDSECT,R15        NOTE LIBRARY DSECT USING
         L     R15,XLBUFLNG        GET TOTAL LENGTH OF SPACE TO BE
*                                  FREED
         $DALLOCH R1,(R15)         DEALLOCATE THE AREA
         DROP  R15                 CLEAN UP USING SITUATION
         SPACE 2
*        SET XXXXSORC SWITCH BRANCH TO NORMAL NON-BRANCH
         SPACE 2
XXEDSET  MVI   XXLBFLG,X'00'       MARK BUFFER AS GONE
         MVI   XXSWTCH+1,X'00'     SET TO NEVER BRANCH IN XXXXSORC
         LM    R11,R2,XXLBSAVT     RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         DROP  R2                  CLEAN UP USING SITUATION
         SPACE 2
XXLBSAVT DS    14F                 SPACE FOR TEMP STORAGE OF REGISTERS
XXLBFLG  DS    B                   DUMMY FLAG BYTE FOR REMOTE OPEN
         SPACE 5
.XXNMCOP ANOP
XXIOAJOB DS    A                   SPACE FOR @ AJOBCON BLOCK
         DC    A(1,XXIOSAVE)       FOR REGS R12-R13-FOLLOW XXIOAJOB
XXIOSAVT DS    14F                 SAVE AREA FOR I/O ROUTINES
         AIF   (NOT &$PAGE).XXNPAG8         SKIP IF NO PAGE CONTROL
*              LEGAL CARRIAGE CONTROL CHARACTERS.  ITEMS ARE THE
*              CHARACTER, AN OFFSET TO ITS REPLACEMENT CHARCATER
*              WORD IF IN MODE SINGL, AND DECREMENT FOR LINE COUNTER.
XXIOPGTA DS    0H                  ORIGIN OF TABLE, ALIGN
XXIOPB   EQU   *-XXIOPGTA          OFFSET FROM TABLE TO BLANK'S BLOCK
XXIOPGTB DC    C' ',AL1(XXIOPB),H'1'        SINGLE SPACE, SINGLE SPACE
XXIOPD   EQU   *-XXIOPGTA          OFFSET TO DOUBLE SPACE
         DC    C'0',AL1(XXIOPB),H'2'        DOUBLE SPACE,SINGLE SPACE
         DC    C'1',AL1(XXIOPD),H'32000'    NEW PAGE, DOUBLESPACE
         DC    C'-',AL1(XXIOPB),H'3'        TRIPLE SPACE,SINGLE SPACE
         DC    C'+',AL1(*-1-XXIOPGTA),H'0'  NO SPACE, NOSPACE
XXIOPGTZ EQU   *-4                 @ LAST ELEMENT IN TABLE
.XXNPAG8 ANOP
         LTORG
         SPACE 1
*              DCB'S FOR THE SOURCE AND DATA CARD READERS.
         AIF   (NOT &$ASMLVL).XXNPN4   SKIP IF UNDER DOS GENERATION
XXSODCB  DCB   DDNAME=&$IOUNIT(1),DSORG=PS,MACRF=GL,EODAD=XXIOEOF
         AIF   (NOT &$DATARD).XXNRE4        SKIP IF NO DATA RDR
XXREDCB  DCB   DDNAME=&$IOUNIT(2),DSORG=PS,MACRF=GL,EODAD=XXIOEOF
.XXNRE4  ANOP
         SPACE 1
*              DCB'S FOR THE LINE PRINTER AND CARD PUNCH.
XXPRDCB  DCB   DDNAME=&$IOUNIT(3),DSORG=PS,MACRF=PL,                   #
               RECFM=FA,LRECL=133,BLKSIZE=133,BUFNO=1
         AIF   (NOT &$PUNCH).XXNPN4        SKIP IF NO REAL PUNCH EXISTS
XXPNDCB  DCB   DDNAME=&$IOUNIT(4),DSORG=PS,MACRF=PL,                   #
               RECFM=F,LRECL=80,BLKSIZE=80,BUFNO=1
.XXNPN4  ANOP
         AIF   (&$ASMLVL).XXNPN8   SKIP IF UNDER OS GENERATION
XXSODCB  DTFCD DEVADDR=&$IOUNIT(1),EOFADDR=XXIOEOF,IOREG=(5),          X
               IOAREA1=XXIOLOCP,IOAREA2=XXIOLOCS,TYPEFLE=INPUT
XXIOLOCP DC    80C' '              DOS IOAREA1
XXIOLOCS DC    80C' '              DOS IOAREA2
         AIF   (NOT &$DATARD).XXNRE8   SKIP IF NO DATA CARD READER
XXREDCB  DTFCD DEVADDR=&$IOUNIT(2),EOFADDR=XXIOEOF,IOREG=(5),          X
               IOAREA1=XXIOLOCP,IOAREA2=XXIOLOCS,TYPEFLE=INPUT
.XXNRE8  ANOP
         SPACE 1
*        DCB'S FOR THE LINE PRINTER AND CARD PUNCH                    *
XXPRDCB  DTFPR DEVADDR=&$IOUNIT(3),BLKSIZE=133,IOREG=(5),CTLCHR=ASA,   X
               IOAREA1=XXIOFILP,IOAREA2=XXIOFILS
XXIOFILP DC    133C' '             PRINTER IOAREA1
XXIOFILS DC    133C' '             PRINTER IOAREA2
         AIF   (NOT &$PUNCH).XXNPN8    SKIP IF NO REAL CARD PUNCH
XXPNDCB  DTFCD DEVADDR=&$IOUNIT(4),CRDERR=RETRY,IOREG=(5),CTLCHR=ASA,  X
               IOAREA1=XXIOPNCP,IOAREA2=XXIOPNCS,TYPEFLE=OUTPUT
XXIOPNCP DC    80C' '              PUNCH IOAREA1
XXIOPNCS DC    80C' '              PUNCH IOAREA2
.XXNPN8  ANOP
         AIF   (&$DISKU EQ 0).XXNDDCB  SKIP IF NO DISK OPTION
         AIF   (&$ASMLVL).XXDDCB1  SKIP IF OS GENERATION
XXDKUDC  DTFSD DEVADDR=&$IOUNIT(5),EOFADDR=XXDKEOF,TYPEFLE=WORK,       X
               BLKSIZE=3520,NOTEPNT=YES,DEVICE=&$DSKUDV
XXDKUDCB EQU   XXDKUDC             ATTACH 7-CHAR DTFSD LABEL TO EXPECTD
         AGO   .XXNDDCB
.XXDDCB1 ANOP
XXDKUDCB DCB  DDNAME=&$IOUNIT(5),EODAD=XXDKEOF,RECFM=FB,EXLST=XXDKEXLS,#
               SYNAD=XXDKSYND,DSORG=PS,NCP=&$BUFNO,MACRF=(RP,W)
XXDKBLKS EQU   XXDKUDCB+X'3E'      BLKSIZE FIELD (DCBBLKSI) ADDRESS
XXDKEXLS DC    0F'0',X'85',AL3(XXDKEXCD)  DCB EXIT, FILL IN BLKSIZE
.XXNDDCB ANOP
         EJECT
         AIF   (NOT &$MACSLB).XXNMDCB
*        DCB FOR THE MACRO LIBRARY FETCH OPTION
XXLIBDCB DCB   DSORG=PO,DDNAME=&$IOUNIT(6),MACRF=R,EODAD=XXMCEODD
.XXNMDCB ANOP
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XIOBLOCK   CONTROL BLOCK FOR INPUT/OUTPUT MACROS          *
*        THIS BLOCK IS CREATED FOR ANY I/O MACRO BY THE INNER MACRO   *
*        XIONR, AND CONTAINS THE ADCON FOR THE DESIRED I/O ENTRYPOINT,*
*        SAVE WORDS FOR MODFIED REGS R14,R15,R0, AND THE LENGTH FOR   *
*        THE I/O AREA TO BE READ OR WRITTEN.                          *
*        THIS DSECT IS ONLY USED IN CSECT XXXXIOCO.                   *
*        GENERATION: BY MACRO XIONR (FOR $READ,$SORC,$PRNT,$PNCH).    *
*        NAMES: XIO-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XIOBLOCK DSECT
         DS    V .                 @ I/O ROUTINE
         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED
XIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USE)
XIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS
         AIF   (NOT &$ASMLVL).XXNDCBD  NO IHADCB UNDER DOS
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: IHADCB     DATA CONTROL BLOCK DSECT                       *
*        DCB DSECT USED BY PARTS OF XXXXIOCO.                         *
*        GENERATION: DCBD MACRO                                       *
*        LOCATION: XXSODCB,XXREDCB,XXPNDCB,XXPRDCB                    *
*        NAMES: DCB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         DCBD  DSORG=QS
.XXNDCBD ANOP
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-> LIBRARY DSECT -- XLBDSECT                                         *
*                                                                     *
*              DESCRIBES LIBRARY BUFFER SPACE AND CONTROL WORDS       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XLBDSECT DSECT
XLBUFLNG DS    F                   CONTROL WORD 1 => TOTAL LENGTH
XLBUFEND DS    F                   CONTROL WORD 2 => PERMENENT BUFFER
*                                     END
XLBUFSTR DS    F                   CONTROL WORD 3 => START OF BUFFER
XLBUFCED DS    F                   CONTROL WORD 4 => END OF BLOCK
XLBUFCNT EQU   *-XLBUFLNG          LENGTH OF CONTROL SECTION OF BUFFER
XLIBBUF  DS    F                   ACTUAL BUFFER STARTS HERE
         SPACE 5
         DROP  R11,R13,R14         AJOBCON,BASE REG, XIOBLOCK
         TITLE '*** XXSNAPC DSECT - XSNAP CONTROL BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XXSNAPC    CONTROL BLOCK USED BY THE XSNAP MACRO          *
*        THIS BLOCK IS CREATED BY EVERY PRINTING XSNAP MACRO.  IT     *
*        CONTAINS THE  EXACT CONTENTS OF THE GP REGISTERS BEFORE THE  *
*        XSNAP WAS CALLED, A FLAG BYTE INDICATING DESIRED OUTPUT AND  *
*        SPECIAL OPTIONS, THE NUMBER OF ADDRESS PAIRS USED IN THE     *
*        XSNAP STORAGE= OPERAND, THE ADDRESS PAIRS THEMSELVES, AND    *
*        THE ADDRESS CONSTANT FOR XXXXSNAP.  THE BYTE XXSFLAGS MAY    *
*        HAVE SEVERAL BITS TURNED ON REQUESTING SPECIAL ASSIST        *
*        SERVICES, SUCH AS USER DEBUGGING OUTPUT AND USER DUMP.  THE  *
*        BITS ARE SUPPLIED BY XSNAP OPERAND T(3), AND HAVE            *
*        MEANING ONLY WHEN USED INSIDE ASSIST WITH THE SPECIAL ASSIST *
*        VERSION OF THE CSECT XXXXSNAP.                               *
*        GENERATION: XSNAP MACRO, WITH T= ANY TYPE BUT ST OR STORE.   *
*        NAMES: XXS-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXSNAPC  DSECT
XXSGPRG  EQU   B'00000001'         (XXSFLAGS)=> PRINT GP REGS
XXSFLRG  EQU   B'00000010'         (XXSFLAGS)=> PRINT FL REGS
XXSAVTR  EQU   B'00000100'         (XXSFLAGS)=> SAVE AREA TRACE(FUTURE)
XXSASNAP EQU   B'00010000'         (XXSFLAGS)=> ASSIST EXECUTE SNAP
XXSASDMP EQU   B'00100000'         (XXSFLAGS)=> ASSIST FINAL DUMP
         SPACE 1
XXSRGSAV DS    16F                 REGISTER AREA, REGS SAVED BY XSNAP
XXSFLAGS DS    B                   OPTION BYTE FLAG
         DS    AL1                 **** UNUSED AS OF VERSION 4.0***
XXSLABLN DS    AL1                 LENGTH OF THE LABEL FIELD
XXSNMSTR DS    AL1                 NUMBER OF @ PAIRS IN STORAGE= LIST
         DS    V(XXXXSNAP)         ADCON FOR CALL TO XXXXSNAP ROUTINE
XXSADSTR DS    0A                  STORAGE = ADDRESS LIST(OPTIONAL)
         TITLE '*** XXXXSNAP-DEBUGGIN,DUMPING MODULE- V.4.0.AS ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*                                       JOHN R. MASHEY - MAY 1969     *
*                                       VERSION 4.0 - FEBRUARY 1970   *
*                                       VERSION 4.0.AS(SIST) FEB 1970 *
*                                       IBM 360/67 ASSEMBLER 'G'      *
*                                       PENNSYLVANIA STATE UNIVERSITY *
*        ABSOLUTE REGISTER EQUATES AND USAGE                          *
*              EQU'S HAVE BEEN CHANGED TO COMMENTS TO PREVENT MULTIPLE*
*        DEFINITION WHEN ASSEMBLING AS PART OF ASSIST.                *
*R0      EQU   0                   WORK REGISTER                      *
*R1      EQU   1                   USED AS WORK REGISTER              *
*R2      EQU   2                   USED TO HOLD 1ST ADDRESS OF PAIR   *
*R3      EQU   3                   USED TO HOLD SECOND ADDRESS OF PAIR*
*R4      EQU   4                   USED AS INCREMENT FOR BXLE'S       *
*R5      EQU   5                   LIMIT ADDRESS IN VARIOUS BXLE'S    *
*R6      EQU   6                   WILL CONTAIN CVTMZ00(HIGHEST ADDR) *
*R7      EQU   7                   OLD ADDRESS IN SAME LINE CHECK     *
*R8      EQU   8                   INTERNAL LINKAGE REGISTER          *
*R9      EQU   9                   ADDRESS OF CURRENT ADDRESS PAIR    *
*R10     EQU   10                  POINTS TO XSNAP LABEL,REGISTER AREA*
*R11     EQU   11                  @ ECONTROL BLOCK, RELOCATION VALUE *
*        THIS VALUE IN R11 ONLY IF XXSFLAGS HAS XXASNAP OR XXASDMP ON.*
*R12     EQU   12                  # STORAGE= ADDRESS PAIRS TO DO     *
*R13     EQU   13                  BASE REGISTER/@ DUMMY SAVE AREA    *
*R14     EQU   14                  RETURN ADDR,POINTER TO LABEL LENGTH*
*R15     EQU   15                  ENTRY POINT REGISTER               *
*        EQUREGS L=F,DO=(0,6,2)    SET UP FLOATING EQU'S              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        XSNAP CONTROL BLOCK AND POINTERS ON ENTRY TO XXXXSNAP.       *
*        FIELD     LENGTH(BYTES)   DESCRIPTION/PURPOSE                *
*        LABEL      LABLN          LABEL=, PADDED TO FULLWORD WITH ' '*
* R10===>RGSAV      64             16 FULLWORDS, WHERE REGS WERE SAVED*
*        FLAGS      1              BYTE FOR OPTION BITS               *
*              BIT 2 = 1 ==>       ASSIST COMPLETION FINAL DUMP       *
*              BIT 3 = 1 ==>       XSNAP USER DEBUGGING DUMP(XDUMP)   *
*              BIT 6 = 1 ==>       PRINT FP REGISTERS. IF =0, DO NOT  *
*              BIT 7 = 1 ==>       PRINT GP REGISTERS. IF =0, DO NOT  *
*        UNUSED     1              FOR FUTURE USE, NOT USED IN V.4.0  *
*        LABLN      1              LENGTH OF THE LABEL FIELD          *
*        NMSTR      1              # 8-BYTE @ PAIRS IN STORAGE= LIST  *
*        ADCON      4              V(XXXXSNAP) FOR CALL               *
*        ADSTR      NMSTR*8        STORAGE= @ LIST, IF PRESENT        *
*        INSTRUCTS  10       3 INSTRUCTIONS - LA, L, BALR             *
* R14===>LM    0,15,0(10)          RETURN POINT, RELOADS REGISTERS    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXSNAP   DEBUGGING OUTPUT, COMPLETION DUMP              *
*        THIS MODULE PROVIDES ALL REGISTER AND STORAGE DUMPING FOR    *
*        DEBUGGING PURPOSES, BOTH FOR INTERNAL ASSIST DEBUGGING, AND  *
*        FOR USER PROGRAMS DURING EXECUTION.  IT IS CALLED BY THE     *
*        MACRO XSNAP (XDUMP PSEUDO-INSTRUCTION FOR USER PROGRAMS),    *
*        AND PRODUCES A USER DUMP OR DEBUGGING OUPUT IF THE CALLING   *
*        XSNAP SPECIFIED A BINARY VALUE FOR OPERAND T(3).             *
*        ENTRY CONDITIONS                                             *
*   SEE XSNAP CONTROL BLOCK AND POINTERS ON ENTRY TO XSNAP COMMENTS.  *
*   ALSO, IF SPECIAL ASSIST OUTPUT IS DESIRED I.E. T(3) IS USED, THE  *
*   WORD IN XXSRGSAV WHERE REGISTER R10 WAS SAVED MUST CONTAIN THE    *
*   ADDRESS OF THE ECONTROL DUMMY SECTION, WHICH SUPPLIES VALUES      *
*        EXIT CONDITIONS                                              *
*   ALL REGISTERS AND CONDITION CODE ARE RESTORED TO ORIGINAL VALUES  *
*   AFTER EXECUTION OF THE INSTRUCTION AT THE RETURN POINT.           *
*        USES DSECTS: ECONTROL,XXSNAPC                                *
*        USES MACROS: $PRNT(IF &$DEBUG=1), OPEN,PUT(IF&$DEBUG=0)      *
*        NAMES: XX------ , ALL NAMES ADDED FOR ASSIST: XXAS----       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXSNAP CSECT
         USING XXXXSNAP,R15        NOTE TEMPORARY ENTRY USING
         USING XXSNAPC,R10         NOTE POINTER TO BLOCK
         CNOP  0,4                 MAKE SURE ALIGNED ON FULLWORD
         BAL   R13,*+76            SET UP BASE AND SAVE AREA @
         USING *,R13               NOTE USING FOR BASE/SAVE AREA
XXSSAVE  DS    18F                 FAKE SAVE AREA FOR OS TO SAVE INTO
         ORG   XXSSAVE             ORG BACK
XXDWORK  DS    4D                  OVERLAP FLT WORK AREAS INTO FAKE SAV
         ORG
         DROP  R15                 CLEAR TEMPORARY USING
         ST    R14,XXSAVE14        SAVE RETURN ADDRESS,CC PROG MAKS
         L     R11,XXSRGSAV+4*R10  GET PTR (WAS IN R10)
         USING ECONTROL,R11        NOTE POINTER TO ECONTROL BLOCK
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        GET ADDRESS OF LABEL FROM FIRST POSITION IN ADDRESS LIST,    *
*   AND USING REGISTER 10(THE ADDRESS OF THE REGISTER SAVE AREA)      *
*   FIND THE LENGTH OF THE LABEL AND PRINT THE LABEL & HEADER LINE.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XXOPENOK SR    R2,R2               CLEAR FOR INSERTION
         BAL   R8,XXSNBLNC         MAKE SURE XXLABEL BLANK, CC = 0
         TM    XXSFLAGS,XXSASDMP   ARE WE IN ASSIST FINAL DUMP
         BZ    XXASNDMP            NO, SO SKIP NEXT SECTION OF CODE ***
         EJECT
*              FOLLOWING SECTION PRINTS HEADER,COMPLETION CODE,PSW,   *
*        AND INSTRUCTION TRACE(OPTIONAL) FOR AN ASSIST FINAL DUMP     *
         SPACE 1
         MVC   XXLABEL(L'XXAS1HD),XXAS1HD   MOVE FIRST HDR, 1 CC IN
         BAL   R8,XXPRINTP         GO TO PRINT AS DESIRED             J
         BAL   R8,XXSNBLNC         REBLANK XXLABEL, MAKE CC = 0 AGAIN
         SPACE 1
         MVC   XXAS2HD,=C'PSW AT ABEND'     MOVE HDR IN
         MVC   XXAS2CC,=C'COMPLETION CODE'  MOVE HDR IN
         UNPK  XXAS2P1,ECPSW(5)    FIRST HALF OF PSW
         UNPK  XXAS2P2,ECILCMSK(5) 2ND HALF OF PSW
         TR    XXAS2P1(2*L'XXAS2P1-1),XXTAB1         FIND CONVERSION
         MVI   XXAS2P1+8,C' '      BLANK BETWEEN PARTS OF PSW
         MVI   XXAS2P2+8,C' '      BLANK AFTER 2ND PART OF PSW
         SPACE 1
         L     R1,ECERRAD          GET @ ERROR BLOCK
         USING ERCOMPCD,R1         NOTE THE POINTER
         MVC   *+7(1),ERCLENG      MOVE LENGTH-1 OVER
         MVC   XXAS2MS($CHN),ERCMSSG        MOVE MESSAGE OVER
         SPACE 1
         IC    R2,ERCTYPE          GET TYPE OF COMPLETION
         SLL   R2,3                MULT * 8 FOR INDEX TO TABLE
         DROP  R1                  NOTE NO LONGER USING BLOCK PTR
         LA    R1,XXAS2TPM(R2)     GET @ COMPLETION TYPE
         MVC   XXAS2TP,0(R1)       MOVE THE TYPE INTO MESSAGE
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         BAL   R8,XXSNBLNK         REBLANK XXLABEL
         SPACE 1
         TM    ECFLAG3,$ECDINST    SHOULD THERE BE INSTRUCTION TRACE
         BZ    XXASREGS            NO,SO DON'T PRINT INSTRUCTIONS
         LA    R0,XXAS3HD          SHOW @ THIS HEADER
         BAL   R8,XXPRINT          PRINT MESSAGE
         SPACE 1
         LA    R0,XXAS4HD          SHOW @ OF THIS LABEL
         BAL   R8,XXPRINT          PRINT (R0=@ XXLABEL STILL)
         SPACE 1
         L     R9,ECRSTK           GET @ CURRENT INSTRUCTION STACK
         LR    R12,R9              SAVE @ FOR COMPARISON IN LOOP
         USING ECSTACKD,R9         NOTE DSECT FOR EACH STACK ENTRY
         SPACE 1
*              FIRST LOOP SEARCHES FOR 1ST ACTUAL INSTRUCTION IN THE  *
*        INSTRUCTION STACK.  CHECK REQUIRED IN CASE OF PROGRAM WHICH  *
*        BOMBS ON 1ST INSTRUCTION, SUCH AS BEGINNING WITH DC H'0'.    *
XXASINA  L     R9,ECSTLINK         GET @ NEXT INSTRUCTION ENTRY
         CLI   ECOP,0              WAS THIS AN INSTRUCTION
         BNE   XXASINB             YES,SKIP TO BEGIN PRINTING
         CR    R9,R12              CHECK FOR COMPLETE CYCLE
         BNE   XXASINA             NOT CYCLE,LOOP UNTIL 1ST INST
         SPACE 1
*              HAVING FOUND 1ST ACTUAL INSTRUCTION, OR SINGLE OPCODE  *
*        OF 0 IN INSTRUCTION CYCLE, PRINT 1 OR MORE INSTRUCTIONS.     *
XXASINB  NI    ECSTCCPM,X'3F'      ZERO OUT ILC(NOT ALREADY SAVED)
XXASINB1 OI    ECSTCCPM,$CHN       OR BUILT-UP ILC FROM LAST INST
         MVI   *-3,0               ZERO OUT BYTE FOR ILC
         MVC   XXAS5I2(10),XXBLANKS         BLANK HALFWORDS 2-3
         SPACE 1
         UNPK  XXAS5I1(5),ECOP(3)  CONVERT OPCODE REGS/LENGTH (ALWAYS)
         MVI   XXAS5I1+4,C' '      BLANK TRAILING BYTE
         CLI   ECOP,X'40'          WAS INSTRUCTION RR
         BL    XXASINC             YES,SO DO NO MORE ON INST
         SPACE 1
         UNPK  XXAS5I2(5),ECBD(3)  UNPACK FIRST BASE-DISPLACEMENT
         OI    XXASINB1+1,X'80'    SET ILC FOR NEXT INST TO 2
         MVI   XXAS5I2+4,C' '      BLANK TRAILING BYTE
         CLI   ECOP,X'C0'          WAS INST RX,RS,SI
         BL    XXASIND             YES,SO NO MORE CONVERT NEEDED
         SPACE 1
         UNPK  XXAS5I3(5),ECB2D2(3) UNPACK 3RD HALFWORD- 2ND BASE-DISP
         MVI   XXAS5I3+4,C' '      BLANK TRAILING BYTE
XXASINC  OI    XXASINB1+1,X'40'    SET NEXT ILC TO 1(RR), OR 3(SS)
XXASIND  UNPK  XXAS5CC(3),ECSTCCPM CONVERT ILC(NOW RIGHT) CC PM OF PSW
         MVI   XXAS5CC+2,C' '      BLANK TRAILING BYTE
         SPACE 1
         UNPK  XXAS5AD(7),ECSTIADD+1(4)     CONVERT INST ADDRESS
         MVI   XXAS5AD+6,C' '      BLANK TRAILING BYTE
         TR    XXAS5CC(XXAS5$L-2),XXTAB1    FINISH HEX CONVERT
         SPACE 1
         CR    R9,R12              WAS THIS LAST ONE
         BNE   *+10                BRANCH OVER MVC IF NOT LAST ONE
         MVC   XXLABEL+2+XXAS5$L(L'XXAS5P),XXAS5P     MOVE ERR PTR
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         CR    R9,R12              WAS THIS THE LAST 1(ABENDING INSTR)
         L     R9,ECSTLINK         GET @ NEXT ENTRY IN TABLE
         BNE   XXASINB             GOBACK FOR NEXT ENTRY IN TABLE
         SPACE 1
XXASINE  MVC   XXLABEL+1(XXAS5$L+2+L'XXAS5P),XXBLANKS REBLANK
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         DROP  R9                  DROP LEFTOVER USING          CPP
         AIF   (NOT &$EXINT).NOXXINT
         SPACE 3
         SPACE 2
         LA    R0,XXAS7HD          GET ADDR 1ST BRANCH TRACE HEADER
         BAL   R8,XXPRINT          BRANCH, AND PRINT THES HEADER
         SPACE 2
         LA    R0,XXAS4HD          GET ADDR 2ND BRANCH TREE HEADER
         BAL   R8,XXPRINT          PRINT THIS HEADER
         SPACE 2
*              GET BRANCH STACK ADDRESSIBILITY
         L     R1,ECBSTK           GET @ CURRENT BRANCH INSTR STACK
         LR    R12,R1              SAVE ADDRESS FOR COMPARISON IN LOOP
         USING ECSTACKD,R1         NOTE DSECT FOR EACH BSTACK ENTRY CEH
         SPACE 2
*              FIRST LOOP SEARCHES FOR 1ST ACTUAL BRANCH INSTRUCTION IN
*              THE BRANCH INSTRUCTION STACK.  CHECK REQUIRED IN CASE OF
*              PROGRAM BOMB HAVING EXECUTED NO BRANCHES.
XXASBINA EQU   *
         L     R1,ECSTLINK         GET @ NEXT BRANCH ENTRY      CEH
         CLI   ECOP,0              WAS THIS ENTRY AN INSTR.     CEH
         BNE   XXASBINB            YES, SKIP TO BEGIN PRINTING
         CR    R1,R12              CHECK FOR A COMPLETE CYCLE
         BNE   XXASBINA            NOT CYCLE, LOOP UNTIL 1ST BRANCH
         SPACE 2
*              HAVE FOUND 1ST ACTUAL !RANCH INSTRUCTION, OR A SINGLE  *
*              OPCODE IN BRANCH INSTRUCTION CYCLE. PRINT 1 OR MORE    *
*              INSTRUCTIONS                                           *
XXASBINB EQU   *
         NI    ECSTCCPM,X'3F'      ZERO OUT ILC(NOT ALREADY SAVED) CEH
XXASBIN1 OI    ECSTCCPM,$CHN       OR BUILT-UP ILC FROM LAST INSTR CEH
         MVI   *-3,0               ZERO OUT BYTE FOR ILC
         MVC   XXAS5I2(10),XXBLANKS     BLANK OUT HALFWORDS 2 AND 3
         SPACE 2
         UNPK  XXAS5I1(5),ECOP(3)  CONVERT OPCODE, REGS. & LEN  CEH
         MVI   XXAS5I1+4,C' '      BLANK OUT TRAILING BYTE
         CLI   ECOP,X'40'          WAS THIS AN RR INSTR.       CEH
         BL    XXASBINC            YES WE ARE FINISHED WITH THIS INSTR
         SPACE 2
         UNPK  XXAS5I2(5),ECBD(3)   UNPACK ONLY BASE-DISPL.      CEH
         OI    XXASBIN1+1,X'80'    SET ILC NEXT INSTR TO 2
         MVI   XXAS5I2+4,C' '      BLANK OUT TRAILING BYTE
         B     XXASBIND            NO MORE CONVERSION NEEDED
         SPACE 2
XXASBINC EQU   *
         OI    XXASBIN1+1,X'40'    SET NEXT ILC TO 1 FOR RR INSTR
XXASBIND EQU   *
         UNPK  XXAS5CC(3),ECSTCCPM CONVERT GOOD ILC-CC PM OF PSW CEH
         MVI   XXAS5CC+2,C' '      BLANK OUT TRAILING BYTE
         SPACE 2
         UNPK  XXAS5AD(7),ECSTIADD+1(4)    CONVERT BR INST. ADDR. CEH
         MVI   XXAS5AD+6,C' '      BLANK OUT TRAILING BYTE
         TR    XXAS5CC(XXAS5$L-2),XXTAB1   FINISH HEX CONVERT
         SPACE 2
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         CR    R1,R12              WAS THIS THE FINAL BRANCH INSTR
         L     R1,ECSTLINK         GET NEXT ENTRY IN TABLE      CEH
         BNE   XXASBINB            GO BACK FOR NEXT ENTRY IN TABLE
         BAL   R8,XXSNBLNC         CLEAR XXLABEL OF GARBAGE
         DROP  R1                  CLEAR AWAY BASE REGISTER
.NOXXINT ANOP
         SPACE 1
*              FINAL DUMP==> EITHER PRINT ALL REGS OR NONE            *
XXASREGS TM    ECFLAG3,$ECREGS     SHOULD WE GIVE REGS
         BO    XXASREG1            YES,SO GO DO IT
         B     XXCHKST             NO REGS AT ALL
         EJECT
XXASNDMP EQU   *                   ENTRY LABEL FOR NORMAL XSNAP
         IC    R2,XXSLABLN         GET LENGTH OF LABEL FIELD
         LR    R1,R10              GET DUPLICATE OF XXSNAPC PTR
         SR    R1,R2               SUBTRACT TO GET START @ FOR LABEL
         BCTR  R2,0                DECREMENT TO LENGTH-1 FOR MVC
         STC   R2,*+5              STORE INTO MVC
         MVC   XXLABEL+38($CHN),0(R1)       MOVE LABEL TO PRINT AREA
         ST    R1,XXWORK1          SAVE THIS @ FOR CONVERSION
         MVC   XXWORK1(1),XXSAVE14 MOVE CCMASK OVER FOR CONVERSION
         SPACE 1
         TM    XXSFLAGS,XXSASNAP   IS THIS A USER SNAP
         BZ    *+10                NO,SO DON'T CHANGE PSW
         MVC   XXWORK1(4),ECILCMSK MOVE USER PSW OVER
         MVC   XXLABEL+1(XXSN1B),XXSNP1ST    MOVE HEADER,PATTERN,MSG
         ED    XXLABEL+L'XXSNP1ST+1(6),XXCOUNT         EDIT CALL NUMBER
         UNPK  XXLABEL+1+XXSN1B(9),XXWORK1(5)       CONVERT CCPM,LOCN
         TR    XXLABEL+1+XXSN1B(8),XXTAB1  FINISH HEX CONVERSION
         AP    XXCOUNT,=P'1'       INCREMENT # CALLS
         BAL   R8,XXPRINTL         PRINT ASSEMBLED XXLABEL
         BAL   R8,XXSNBLNK         REBLANK XXLABEL
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        CHECK TO SEE IF THE REGISTERS SHOULD BE PRINTED.             *
*        PRINT THE HEADING FOR THE REGISTER DUMP.  CONVERT AND PRINT  *
*   THE REGISTERS IN 2 LINES. CHECK TO SEE IF ONLY THE REGISTERS      *
*   WERE DESIRED. FINISH UP AND RETURN TO CALLING XSNAP IF SO.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
         TM    XXSFLAGS,XXSGPRG    DOES HE WANT GP REGS PRINTED
         BZ    XXCHKFP             NO, SO DONT PRINT THEM
         LR    R2,R10              DUPLICATE @ RGSAV OVER
         TM    XXSFLAGS,XXSASNAP   WAS THIS USER XSNAP
         BZ    XXGOREG             NO,NORMAL XSNAP,SKIP
XXASREG1 LA    R2,ECREGS           SHOW @ FAKE REGS INSTEAD
XXGOREG  EQU   *                   ***WE HAVE DELETED REG HEADER**    J
         SPACE 1
         MVC   XXREGOUT(12),=CL12'0 REGS 0-7'          LABEL-1ST REGS
         BAL   R8,XXREGS1          CONVERT 1>T REGS BLOCK,PRINT LINE
         BAL   R8,XXPRINT          HAVE LINE PRINTED
         SPACE 1
         MVC   XXREGOUT(12),=CL12'  REGS 8-15'   2ND LINE LABEL
         BAL   R8,XXREGS2          GET 2ND GROUP CONVERTED,PRINTED
         BAL   R8,XXPRINT          HAVE LINE PRINTED
         SPACE 1
XXCHKFP  EQU   *
         AIF   (NOT &$FLOTM).XXS2  SKIP IF MACHINE DOEN'T HAVE FLOT
         TM    XXSFLAGS,XXSFLRG    DOES HE WANT FLOATING PT REGS PRINT
         BZ    XXCHKST             NO,SO GO CHECK FOR STORAGE=
         SPACE 1
*              FOLLOWING SECTION PRINTS FLOATING POINT REGISTERS      *
         MVC   XXREGOUT(12),=CL12'0 FLTR 0-6'         MOVE LABEL IN
         LA    R2,ECFPREGS         SHOW @ FAKE REGS
         TM    XXSFLAGS,XXSASDMP+XXSASNAP   WAS THIS ASSIST SNAP/DUMP
         BNZ   XXFPCONV            GO CONVERT THEM
         STD   F0,XXDWORK          SAVE REG F0
         STD   F2,XXDWORK+8        SAVE F2
         STD   F4,XXDWORK+16       SAVE F4
         STD   F6,XXDWORK+24       SAVE F6
         LA    R2,XXDWORK          SET UP @ WORKAREA FOR XXREGS1
XXFPCONV EQU   *
         BAL   R8,XXREGS1          CALL GP REG CONVERTER
         MVC   XXREGOUT+24(12),XXREGOUT+28           PUT F0 TOGETHER
         MVC   XXREGOUT+48(12),XXREGOUT+52           PUT F2 TOGETHER
         MVC   XXREGOUT+72(12),XXREGOUT+76           PUT F4 TOGETHER
         MVC   XXREGOUT+96(12),XXREGOUT+100          PUT F6 TOGETHER
         BAL   R8,XXPRINT          PRINT THE ASSEMBLED LINE
         MVC   XXREGOUT,XXBLANKS   REBLANK LINE LIKE ITS SUPPOSED TO BE
.XXS2    ANOP
         SPACE 1
XXCHKST  EQU   *
         SR    R12,R12             CLEAR FOR INSERTION
         IC    R12,XXSNMSTR        GET # OF ADDRESS PAIRS
         LTR   R12,R12             ARE THERE ANY @ PAIRS
         BZ    XXEXIT1             NO STORAGE=, SO QUIT
         LA    R9,XXSADSTR         INIT R9 TO @ FIRST ADDRESS PAIR
         LA    R4,4                SET UP BXLE INDEX FOR REST OF PROG
         SPACE 1
         TM    XXSFLAGS,XXSASNAP+XXSASDMP   ARE SPECIAL @ GAMES NEEDED
         BZ    XXASTA              SKIP IF NOT (I.E. NORMAL XSNAP)
         TM    XXSFLAGS,XXSASDMP   WAS THIS A DUMP?
         BZ    XXAST               SKIP IF JUST SNAP
         TM    ECFLAG3,$ECSTORG    SHOULD STORAGE BE DUMPED
         BZ    XXEXIT3             NO STORAGE,SO QUIT
         MVC   XXLABEL(L'XXAS6HD),XXAS6HD   MOVE IN STORAGE DUMP HEADER
         BAL   R8,XXPRINTP         GO PRINT AS DESIRED                J
         BAL   R8,XXSNBLNC         REBLANK XXLABEL, MAKE SURE CC = 0
         SPACE 1
XXAST    L     R6,ECRADH           GET REAL HIGH LIMIT @
         TM    ECFLAG0,$ECPROT     WAS ABSOLUTE PROTECT MODE ON
         L     R11,ECRELOC         GET EXECUTION TIME RELOCATION FACTOR
         BZ    XXASTB              NO, SKIP, RESET TO NORMAL LIMIT
         DROP  R11                 NOTE NO LONGER USING WITH ECONTROL
         LCR   R11,R11             MAKE NEGATIVE,SO CAN USE IN LA'S
         B     XXASTC              SKIP TO BEGIN PROCESSING
*              NOTE ASSIST DUMP REQUIRES USER CORE TO BEGIN ON REAL   *
*        ADDRESS DIVISIBLE BY 32,TO GET REASONABLE OUTPUT.            *
         SPACE 1
*              THE FOLLOWING 2 LINES HELP US PREVENT 0C5'S            *
XXASTA   SR    R11,R11             SET RELOCATION TO 0 (NORMAL XSNAP)
         AIF   (NOT &$ASMLVL).XXASDOS   SKIP IF OTHER THAN OS/360
XXASTB   L     R6,16               CVT PTR **********OS/360 ONLY ******
         L     R6,164(R6)          GET CVTMZ000 - HIGHEST CORE @
.XXASDOS AIF   (&$ASMLVL).XXASNOS  SKIP IF OS/360, CAN GET SIZ FROM CVT
XXASTB   COMRG                     R1 <- @ OF COMMUNICATIONS REGION
         L     R6,48(R1)           GET @ OF END OF MACHINE (DOS)
         LA    R6,1(R6)            GET @ ON NEXT NON-AVAIL BYTE
.XXASNOS ANOP
XXASTC   SH    R6,=H'32'           REDUCE SO WILL NOT 0C5
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SECTIONS XXMEMA - XXMEME SERVE TO PROCESS 1 ADDRESS PAIR     *
*   FROM THE LIST OF ADDRESS PAIRS SPECIFYING STORAGE TO BE DUMPED.   *
*   AT XXMEMF,THE 2ND ADDRESS IS TESTED TO SEE IF IT IS THE LAST ONE  *
*   AND  THE DUMP COMPLETED IF SO. OTHERWISE,A BRANCH IS TAKEN BACK   *
*   TO XXMEMA TO PROCESS THE NEXT ADDRESS PAIR.                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XXMEMA   LM    R2,R3,0(R9)         OBTAIN NEXT ADDRESS PAIR
         LA    R0,0(R11,R2)        RELOCATE ADDRESS IF NEEDED
         ST    R0,XXWORK1          SAVE FOR CONVERSION
         UNPK  XXCOREL,XXWORK1+1(4)         CONVERT WITH TRAILING BLANK
         LA    R0,0(R11,R3)        GET HIGH ADDRESS,RELOCATE
         ST    R0,XXWORK1          SAVE FOR CONVERT
         UNPK  XXCOREH,XXWORK1+1(4)         CONVERT WITH TRAILING BLANK
         TR    XXCOREL(17),XXTAB1  TRANSLATE TO COMPLETE HEX CONVERT
         MVC   XXCOREL+7(2),=C'TO' PUT REST OF MSG IN
         MVC   XXCORETL,=C'CORE ADDRESSES SPECIFIED-' PUT IN MSG
         BAL   R8,XXPRINTL         PRINT XXLABEL
         MVC   XXCORETL(XXCORE$L),XXBLANKS+30         REBLANK THE AREA
         SPACE 1
         CR    R3,R6               MAKE SURE HIGH ADDR ISN'T TOO HIGH
         BNH   *+6                 SKIP OVER IF NOT TOO HIGH
         LR    R3,R6               @ WOULD 0C5-USE HIGHEST INSTEAD
         LA    R3,31(R3)           PREPARE TO ROUND 2ND ADDR UPWARD
         SRDL  R2,5                ROUND BOTH ADDRESSES
         SLL   R2,5                NOW HAVE 1ST ADDR IN R2,ROUNDED DOWN
         SLL   R3,5                NOW HAVE HIGH ADDR IN R3,ROUNDED UP
         CR    R2,R3               WAS USER IN ERROR: LOW ADDR>HIGH ADD
         BH    XXMEMF              ADDR ERROR-PRINT NOTHING,GO TO NEXT
         CR    R2,R6               MAKE SURE IF 1ST=2ND>MEMORY SIZE
         BH    XXMEMF              PRINT NOTHING IF SO
         SPACE 2
XXMEMB   EQU   *
         AR    R2,R11              RELOCATE IF NEEDED
         ST    R2,XXWORK1          STORE BEGINNING ADDR FOR CONVERT
         SR    R2,R11              CONVERT BACK TO REAL @
         LR    R7,R2               SAVE BEGINNING ADDRESS FOR SAME CHK
         UNPK  XXCORADD+1(7),XXWORK1+1(4)    GET BEGINNING ADDRESS
         MVC   XXCORE3,0(R2)       MOVE 32 BYTES OVER FOR ALPHMERIC TR
         TR    XXCORE3,XXTAB2      PERFORM ALPHAMERIC CONVERSION
         SPACE 1
         LA    R1,XXCORE1          ADDRESS FOR 1ST BLOCK CONVERSION
         BAL   R8,XXMEMP1          GET 1ST BLOCK OF 4 WORDS CONVERTED
         LA    R1,XXCORE2          ADDRESS FOR 2ND BLOCK CONVERSION
         BAL   R8,XXMEMP1          GET 2ND BLOCK CONVERTED
         SPACE 1
         TR    XXCORADD+1(84),XXTAB1         FINISH HEX CONVERSION
         LA    R0,XXCORADD         ADDRESS OF CORE OUTPUT LINE
         BAL   R8,XXPRINT          GET 1 CORE LINE PRINTED
         EJECT
*        XXMEMC-XXMEME CHECK FOR DUPLICATE LINES. HAVING FOUND 1 OR   *
*   MORE DUPLICATE LINES,CORE IS SCANNED UNTIL A DIFFERENT LINE IS    *
*   FOUND,OR THE BLOCK FINISHED,AND THEN PRINTS SAME LINES MESSAGE.   *
         SPACE 2
XXMEMC   CR    R2,R3               R2 HAS BEEN INCREMENTED-ARE WE DONE
         BNL   XXMEMF              YES WE'RE DONE WITH THIS SECTION
         CLC   0(32,R7),0(R2)      COMPARE PREVIOUS SECTION WITH NEXT
         BNE   XXMEMB              NOT THE SAME-WILL HAVE TO PRINT LINE
         LA    R7,32(R11,R7)       INCREMENT TO MAKE RIGHT @,RELOCATE
         ST    R7,XXWORK1          SAVE 1ST LINE ADDRESS OF SAME AREAS
         SR    R7,R11              CONVERT BACK TO REAL @
         UNPK  XXSAML,XXWORK1+1    1ST STEP TO CONVERT
         SPACE 1
XXMEMD   LA    R2,32(R2)           INCREMENT TO LOOK AT NEXT SECTION
         CR    R2,R3               ARE WE DONE
         BNL   XXMEME              YES,WE'RE DONE-SAME LINES MESSAGE
         CLC   0(32,R7),0(R2)      CHECK NEXT SECTION WITH 1ST OF SAMES
         BE    XXMEMD              SAME-KEEP LOOPING UNTIL DIFFERENT
         SPACE 1
XXMEME   LA    R1,0(R11,R2)        GET END @,RELOCATE,WHERE CAN DESTROY
         SH    R1,=H'32'           DECRMENT SO LINE ADDR RIGHT
         ST    R1,XXWORK1          SAVE FOR HEX CONVERSION
         UNPK  XXSAMH,XXWORK1+1    CONVERT-FIRST STEP
         TR    XXSAML(13),XXTAB1   FINISH HEX CONVERSION OF SAME LINES
         MVI   XXSAML+6,C'-'       PLACE DASH BETWEEN ADDRESSES
         MVC   XXLABEL+1+3(XXSAM$L),XXSAME  MOVE SAME LINES MSG OVER
         LA    R0,XXLABEL+1        SHOW @ 1 BEYOND CARRIAGE CONTROL
         BAL   R8,XXPRINT          PRINT THE SAME LINE MESSAGE
         CR    R2,R3               HAVE WE MEANWHILE FINISHED BLOCK
         BL    XXMEMB              NO-KEEP GOING UNTIL BLOCK DONE
         SPACE 1
XXMEMF   LA    R9,8(R9)            INCREM R9 TO @ NEXT @ PAIR
         MVC   XXLABEL+1+3(XXSAM$L),XXBLANKS+1+3      REBLANK AREA
         BCT   R12,XXMEMA          GO BACK FOR NEXT BLOCK
         B     XXEXIT2             ALL STORAGE= DONE, GO RETURN
         EJECT
*        XXEXIT - PRINT ENDING LINE,THEN RETURN TO CALLING XSNAP.     *
         SPACE 2
XXEXIT1  TM    XXSFLAGS,XXSGPRG+XXSFLRG     WERE EITHER REGS PRINTED
         BZ    XXEXIT3             NO OPTIONS, JUST LEAVE SINGLE LINE
XXEXIT2  EQU   *                   DON'T HAVE TO SET R0, USE XXPRINTL
         BAL   R8,XXPRINTL         PRINT XXLABEL FOR A BLNKA LINE
XXEXIT3  L     R14,XXSAVE14        RELOAD RETURN @, CC
         SPM   R14                 RESTORE CONDITION CODE
         BR    R14                 RETURN TO CALLING XSNAP
         EJECT
*        ***  INTERNAL SUBROUTINE AREA ***                            *
         SPACE 1
*              XXSNBLNC BLANKS XXLABEL, SETS CARRIAGE CONTROL = 0.
*              XXSNBLNK JUST BLANKS XXLABEL, NOT CHANGING CC.
XXSNBLNC MVI   XXLABEL,C'0'        MAKE NORMAL DOUBLE SPACE CC
XXSNBLNK MVC   XXLABEL+1(L'XXLABEL-1),XXBLANKS+1 REBLANK ENTIRE AREA
         BR    R8                  RETURN TO CALLER
         SPACE 2
*              XXREGS1 CONVERTS AND PRINTS 1 LINE OF 8 REGISTERS      *
         SPACE 1
XXREGS1  LA    R4,12               INCREMENT FOR BXLE
         LA    R5,XXREGOUT+16+7*12 LIMIT ADDRESS FOR BXLE
XXREGS2  LA    R3,XXREGOUT+16      START POINT,INDEX FOR COMING BXLE
XXREGS3  UNPK  0(9,R3),0(5,R2)     CONVERT 1 REGISTER VALUE
         MVI   8(R3),C' '          BLANK OUT EXTRA BYTE USED IN CONVERT
         LA    R2,4(R2)            INCREMENT POINTER TO REGISTER
         BXLE  R3,R4,XXREGS3       LOOP-DO 1 LINE OF 8 REGISTER VALUES
         TR    XXREGOUT+16(92),XXTAB1        FOR REST OF HEX CONVERT
         LA    R0,XXREGOUT         ADDRESS OF OUTPUT LINE
         BR    R8                  RETURN TO CALLER
         SPACE 2
*              XXMEMP1 CONVERTS 1 BLOCK OF 16 BYTES TO HEX.           *
         SPACE 1
XXMEMP1  LA    R5,12(R2)           SET UP LIMIT FOR BXLE
XXMEMP2  UNPK  0(9,R1),0(5,R2)     UNPACK 1 WORD OF MEMORY
         MVI   8(R1),C' '          BLANK OUT EXTRA BYTE UNPACKED
         LA    R1,9(R1)            INCREMENT POINTER TO OUTPUT AREA
         BXLE  R2,R4,XXMEMP2       CONTINUE,CONVERTING 16 BYTES
         BR    R8                  RETURN TO CALLER
         SPACE 2
*              XXPRINTL PRINTS 121 CHARACTERS STARTING AT XXLABEL.    *
*              XXPRINT  PRINTS 121 CHARACTERS STARTING AT @ IN R0.    *
         SPACE 1
XXPRINTP EQU   *    ***COME HERE IF MIGHT BE PAGE SKIP POSSIBLE***    J
         AIF   (&$DMPAG).XXNPQQQ   SKIP IF PAGE EJECTS ALLOWED AT ALL J
         MVI   XXLABEL,C'0'        USE DOUBLE SPACE RATHER THAN EJECT J
.XXNPQQQ ANOP                                                         J
XXPRINTL LA    R0,XXLABEL          SHOW @ XXLABEL
XXPRINT  EQU   *
         AIF   (&$DEBUG).XXS50     SKIP IF PRODUCTION
         PUT   XXSNDCB,(0)
         AGO   .XXS60              SKIP
.XXS50   $PRNT (0),121,XXSNPROV    PRINT OUTPUT,GO TO LABEL IF OVERFLOW
.XXS60   ANOP
         BR    R8                  RETURN TO CALLER
         EJECT
*              EXIT TAKEN IF RECORD LIMIT OVERRUN.  THIS CHECKS TO    *
*        SEE IF OUTPUT IS FOR AN EXECUTION-TIME XDUMP, IN WHICH CASE  *
*        EXECUTION IS STOPPED, SINCE USER IS OVERRUNNING HIS LIMIT.   *
XXSNPROV EQU   *
         TM    XXSFLAGS,XXSASNAP   WAS THIS A USER SNAP (XDUMP)
         BZ    XXEXIT3             NO, FINAL DUMP-WE'RE DONE
         SPACE 1
*              OVERFLOW OCCURED.  QUIT, FLAGGING ECONTROL.
         L     R11,XXSRGSAV+4*R10  GET PTR TO ECONTROL, WAS IN R10
         USING ECONTROL,R11        NOTE POINTER
         MVI   ECFLAG1,$ECRECEX    SHOW EXECUT THAT RECORD OVERFLOWED
         B     XXEXIT3             GO RETURN CONTROL
         DROP  R11                 NOT NEEDED ANYMORE
         SPACE 5
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXSNIN   XXXXSNAP INITIALIZATION ENTRY                  *
*        CALLED TO INITIALIZE 'XSNAP - CALL' NUMBER TO 1 (IN CASE     *
*        BATCHED RUNS ARE USED).                                      *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS                                               *
*   R15= @ XXXXSNIN                                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ENTRY XXXXSNIN            INITIALIZATION ENTRY FOR ASSIST
         USING XXXXSNIN,R15        NOTE USING
XXXXSNIN ZAP   XXCOUNT,=P'1'       INITILZE COUNTER TO 1
         BR    R14                 RETURN TO CALLER
         SPACE
         EJECT
*        *** OUTPUT LINE,CONSTANT, AND TRANSLATE TABLE AREA ***       *
         SPACE 2
XXSAVE14 DS    A                   SAVE WORD FOR RETURN @, CC,MASK
XXWORK1  DC    F'0',X'04'          FIELD + REVERSED BLANK FOR HEX CONVT
XXCOUNT  DC    PL3'1'              COUNTER FOR NUMBER OF CALLS
         AIF   (&$DEBUG).XXS70     SKIP IF PRODUCTION VERSION
         PRINT NOGEN
         ENTRY XXSNDCB             SO PEOPLE CAN CHANGE,IF THEY WISH
         AIF   (&$ASMLVL).XXSNDTF  SKIP IF UNDER OS GENERATION
XXSNDCB  DTFPR DEVADDR=SYSLST,BLKSIZE=121,CTLCHR=YES,IOAREA1=XXSNIOAR, X
               WORKA=YES
XXSNIOAR DC    121C' '             DOS XSNAP IOAREA
.XXSNDTF AIF   (NOT &$ASMLVL).XXS70    SKIP IF UNDER DOS GENERATION
XXSNDCB  DCB   DSORG=PS,MACRF=PM,RECFM=FA,LRECL=121,BLKSIZE=121,       #
               DDNAME=XSNAPOUT,BUFNO=1
.XXS70   ANOP
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXSNP1ST DC    C'BEGIN XSNAP - CALL'         HEADER TITLE
         DC    X'402020202021'     EDIT PATTERN FOR CALL NUMBER
         DC    C' AT '             FOR XSNAP LOCATION MESSAGE
XXSN1B   EQU   *-XXSNP1ST          LENGTH OF HEADER,NUMBER,LOCATION
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXSAME   DC    CL9'LINES'          BEGINNING OF SAME LINE MSG
XXSAML   DC    CL7' '              LOWEST ADDRESS AREA
XXSAMH   DC    CL7' ',C'   SAME AS ABOVE'   END OF SAME LINES MSG
XXSAM$L  EQU   *-XXSAME            LENGTH OF MESSAGE
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXLABEL  DC    CL121'0'            MAIN PRINTING AREA, WITH SKIP CARCON
         DC    CL7' '              PAD TO DOUBLEWORD BOUNDARY
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXBLANKS DC    CL121' ',CL7' '     BLANKS, ALSO FOR XXREGLAB PRINTING
         DS    0D                  ALIGN FOR SPEED
XXREGOUT DC    CL121' '            REGISTER PRINTING AREA
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXTAB    DC    C'0123456789ABCDEF' TR TABLE FOR HEX CONVERT
XXTAB1   EQU   XXTAB-240           TO MAKE CONSTANT TR'S EASIER FOR HEX
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXTAB2   DC    64C'.',C' ',128C'.',C'ABCDEFGHI',7C'.',C'JKLMNOPQR'
         DC    8C'.',C'STUVWXYZ',6C'.',C'0123456789',6C'.'  ALPH TR TAB
         SPACE 1
         DS    0D                  ALIGN FOR SPEED
XXCORADD DC    CL7' ',CL3' '       10 BYTES - LINE ADDRESS
XXCORE1  DC    4CL9' ',CL3' '      39 BYTES - SPACE FOR 4 WORDS
XXCORE2  DC    4CL9' ',CL3'  *'    39 BYTES - SPACE FOR 2ND BLOCK
XXCORE3  DC    CL32' ',C'*'        33 BYTES - ALPHAMERICS +   *
         SPACE 1
         ORG   XXLABEL+30          ORG BACK TO MAIN LABEL AREA
XXCORETL DS    C'CORE ADDRESSES SPECIFIED-'   SPACE FPR HDR
         ORG   XXCORETL+30         SPACE UPWARD
XXCOREL  DS    CL7,CL3             SPACE FOR LOW ADDR, 'TO '
XXCOREH  DS    CL7' '              SPACE FOR 2ND @
XXCORE$L EQU   *-XXCORETL          GET LENGTH OF HDR
         ORG   ,                   RESTORE NORMAL LOCATION CTR
         EJECT
         DS    0D                  ALIGN FOR SPEED
XXAS1HD  DC    C'1 ASSIST COMPLETION DUMP'  HEADER 1ST PAGE OF DUMP
         SPACE 1
         ORG    XXLABEL+1          ORG BACK TO LABEL PRINTING AREA+1
XXAS2HD  DS    C'PSW AT ABEND'     SPACE FOR HDR, L' ATTRIBUTE SET
         DS    C                   SPACING BYTE
XXAS2P1  DS    CL9                 1ST HALF OF PSW
XXAS2P2  DS    CL9                 2ND HALF OF PSW
         DS    CL6' '
XXAS2CC  DS    C'COMPLETION CODE',CL3' '    SPACE, L'
XXAS2TP  DS    CL8                 SPACE FOR TYPE-SYTEM,ASSIST,USER =
         DS    C' '
XXAS2MS  EQU   *                   FOR MESSAGE
         ORG   ,                   ORG BACK TO NORMAL LOCATION CTR
         SPACE 1
XXAS2TPM DC    CL8'SYSTEM =',CL8'ASSIST =',CL8' USER  ='
         SPACE 1
XXAS3HD  DC    CL121'0** TRACE OF INSTRUCTIONS JUST BEFORE TERMINATION:#
                PSW BITS SHOWN ARE THOSE BEFORE CORRESPONDING INSTRUCTI#
               ON DECODED ***'
         SPACE 1
XXAS4HD  DC    CL121'0  IM LOCATION    INSTRUCTION :  IM = PSW BITS 32-#
               39(ILC,CC,MASK) BEFORE INSTRUCTION EXECUTED AT PROGRAM L#
               OCATION SHOWN'
         SPACE 1
         ORG   XXLABEL+1           ORG BACK INTO MAIN LABEL
XXAS5HD  DS    C'  '               SPACING
XXAS5CC  DS    XL2                 ILC-CC-PM
         DS    C'  '               SPACING
XXAS5AD  DS    XL6                 PSW ADDRESS
         DS    CL5' '
XXAS5I1  DS    XL5                 1ST HALFWORD OF INSTRUCTION
XXAS5I2  DS    XL5                 2ND HALFWORD OF INSTRUCTION
XXAS5I3  DS    XL5                 3RD HALFWORD OF INSTRUCTION
XXAS5$L  EQU   *-XXAS5HD           DEFINE LENGTH OF THIS MESSAGE
         ORG   ,                   RESTORE NORMAL LOCATION CTR
XXAS5P   DC    C'<-- LAST INSTRUCTION DONE - PROBABLE CAUSE OF TERMINAT#
               ION'                BOMB POINTER MSG
         SPACE 1
XXAS6HD  DC    C'1 USER STORAGE'   HEADER 2ND PAGE OF DUMP
         LTORG
         AIF   (NOT &$EXINT).XXASNXT
         SPACE 3
*              THESE LABELS ARE ONLY USED IN THE LAST 10 BRANCH       *
*              INSTRUCTION COMPLETION MESSAGE                         *
         SPACE 2
XXAS7HD  DC    CL121'-** TRACE OF LAST 10 BRANCH INSTRUCTIONS EXECUTED:X
                PSW BITS SHOWN ARE THOSE BEFORE CORRESPONDING INSTRUCTIX
               ON DECODED ***'
.XXASNXT ANOP
         DROP  R10,R13             DROP REGISTERS NO LONGER USED CPP
         TITLE '*** XXXXSPIE  ASSIST INTERRUPTS COMMUNICATIONS ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: XXXXSPIE       INTERRUPT CONTROL & COMMUNICATIONS         *
*                                  SCOTT A SMITH - FALL 1971.         *
*        THIS IS CALLED ONLY FROM THE MACRO EXPANSION OF $SPIE.  IT   *
*        CONTAINS THE ONLY MACROS THAT CAUSE LINKAGE TO BE SET UP     *
*        BETWEEN THE SUPERVISOR AND THE EXIT ROUTINE FOR INTERRUPT    *
*        HANDLING.  THE INITIAL COMMUNICATIONS ARE NEVER MADE UNLESS  *
*        AT LEAST ONE $SPIE IS EXPANDED.  ONLY ONE ACTUAL SUPERVISOR  *
*        CALL IS NECESSARY.  ALL OTHER $SPIE EXPANSIONS JUST MANI-    *
*        PULATE THE CONTROL BLOCKS GENERATED BY THAT EXPANSION.       *
*        **NOTE**  XXXXSPIE CONTAINS THE ONLY OCCURENCES OF THE       *
*        MACROS  SPIE (OS) OR STXIT (DOS)                             *
*        NAMES:  XSP-----                                             *
*                                                                     *
*        THIS ENTRY HANDLES THE UPDATING OF THE POINTER TO THE        *
*        ACTIVE XSPIEBLK .                                            *
*        ENTRY CONDITIONS                                             *
*   R1 = @ NEWLY CREATED ACTIVE XSPIEBLK (OR RESTORED XSPIEBLK)       *
*   R14= RETURN ADDRESS                                               *
*   R15= @ ENTRY POINT                                                *
*        EXIT CONDITIONS                                              *
*   R1 = @ LAST PREVIOUS ACTIVE XSPIEBLK                              *
*      = 0 , IF NO PREVIOUS XSPIEBLK'S EXISTED                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XXXXSPIE CSECT
         $DBG  ,NO                 SHOW NO DEBUG CODE - $SAVE/$RETURN
         USING XXXXSPIE,REP        SHOW OF ENTRY POINT REGISTER USING
         L     R0,XSPACBLK         GET CURRENT XSPIEBLK @
         ST    R1,XSPACBLK         SAVE THE NEW ACTIVE XSPIEBLK @
         LR    R1,R0               RETURN PREVIOUS XSPIEBLK @
         BR    RET                 ACTIVE XSPIEBLK PTRS CHANGED, RETURN
         DROP  REP                 INFORM ASSEMBLER NO LONGER USING R15
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> ENTRY: XXXXSPIN     INITIALIZATION OF INTERRUPT COMMUNICATIONS   *
*        THE ONLY NECESSARY SPIE(OS) OR STXIT(DOS) IS EXECUTED HERE   *
*        TO CATCH ALL INTERRUPTS AND TO REQUEST THE RETURN OF CONTROL *
*        TO THE SAME EXIT ROUTINE HANDLER.  AS SUBSEQUENT $SPIE'S     *
*        ARE ISSUED, NO SVC IS NEEDED; JUST AN ANALYSIS OF THE        *
*        STATUS OF THE ACTIVE CONTROL BLOCK(XSPIEBLK) BY THE COMMON   *
*        INTERRUPT EXIT ROUTINE.                                      *
*        USES MACROS: SPIE(OS) OR STXIT(DOS),$SAVE,$RETURN            *
*        ENTRY CONDITIONS                                             *
*   R14= RETURN ADDRESS                                               *
*   R15= @ ENTRY POINT                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         ENTRY XXXXSPIN
XXXXSPIN $SAVE RGS=(R14-R12),SA=XSPYSAVE
         XC    XSPACBLK,XSPACBLK   SET PREVIOUS XSPIEBLK PTR TO ZERO
         AIF   (&$ASMLVL).XSPOS    SKIP IF WE ARE IN OS GENERATION
         STXIT PC,XXXXSPEX,XSPYSAVE    CATCH ALL PROGRAM CHECKS
.XSPOS   AIF   (NOT &$ASMLVL).XSPDOS   SKIP IF SET BY DOS GENERATION
         SPIE  XXXXSPEX,((1,15))   CATCH ALL PROGRAM EXCEPTIONS
.XSPDOS  ANOP
         $RETURN RGS=(R14-R12)     RETURN AFTER ESTABLISHING COMMUNCTS
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> INSUB: XXXXSPEX              INTERRUPT EXIT ROUTINE              *
*        RECEIVES CONTROL FOR ALL INTERRUPTS, REGARDLESS OF @ ON      *
*        MOST PREVIOUS $SPIE CALL.  XXXXSPEX MONITORS THE INTERRUPT   *
*        HANDLING.  IT FIRST DETERMINES IF THIS PARTICULAR INTERRUPT  *
*        WAS TO BE CAUGHT, SINCE ALL REAL INTERRUPTS WILL EFFEC-      *
*        TIVELY BE NAILED.  IF IT WAS NOT TO BE CAUGHT, THEN CONTROL  *
*        IS RETURNED TO THE SUPERVISOR TO REINITIALIZE EXECUTION      *
*        WHERE IT WAS LEFT OFF.   ***NOTE***   IT MIGHT BE DESIRABLE  *
*        TO INSERT CODE IN THIS CASE TO EITHER PRINT OUT A MESSAGE    *
*        OR TO TAKE SOME OTHER ACTION.  THE CALLABLE EXIT(IF ANY) IS  *
*        GIVEN CONTROL , BUT IT MUST RETURN CONTROL.  UPON RETURN     *
*        THE PSW IS CHANGED (IF EXIT @ GIVEN) AND SUPERVISOR GETS CNTL*
*        USES DSECTS: XSPIEBLK                                        *
*        THIS ROUTINE PRESERVES THE CONTENTS OF R2-R12 FOR THE        *
*        INSPECTION BY THE CALLABLE EXIT ROUTINE.                     *
*        ENTRY CONDITIONS                                             *
*   R1 = @ OF OS PIE BLOCK (*DOS*MOST LOAD @ INTRPT SAVEAREA(PSW)     *
*   R14= RETURN ADDRESS                                               *
*   R15= @ ENTRY POINT                                                *
*        EXIT CONDITIONS                                              *
*   R1 = @ OF OS PIE BLOCK OR @ OF DOS PSW & SAVE.  **NOTE** CALLABLE *
*        EXIT ROUTINE MUST NOT CHANGE THE CONTENTS OF REGISTER #1     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).XSPNBAL  SKIP IF UNDER OS GENERATION
XXXXSPEX BALR  R15,0               ESTABLISH TEMP DOS ADDRESSABILITY
         USING *,R15               INFORM OF USING
         LA    R1,XSPYSAVE         GET DOS @ OF PSW & SAVE AREA
.XSPNBAL AIF   (NOT &$ASMLVL).XSPADDR  SKIP IF UNDER DOS GENERATION
         USING *,R15               SHOW OF ENTRY POINT REG USING
XXXXSPEX LA    R1,4(R1)            GET R1 <- OS PSW IN PIEBLOCK
.XSPADDR ANOP
         STM   R13,R15,XSPSVRES    STORE THE REGISTERS
         LA    R13,XSPYSAVE        @ OUR SAVE AREA, FOR SAFETY
         L     R14,XSPACBLK        LOADS @ OF ACTIVE XSPIEBLK
         USING XSPIEBLK,R14        DSECT USING FOR CONTROL BLOCK
         LTR   R14,R14             SEE IF A $SPIE IS IN EFFECT
         BZ    XSPNOSPY            NO SPIE WAS IN EFFECT AT PRESENT
         L     R0,=X'80000000'     LOAD 1 BIT IN HIGH ORDER END
         MVC   *+8(2),2(R1)        PLACE INT. # INTO L' NEXT INSTRUCTN
         SRL   R0,$                GET BIT TO MASKABLE POSITION
         N     R0,XSPINTRP         AND WITH INTERRUPT TYPES TO BE CAUGT
         BZ    XSPNTCTH            THIS INTERRUPT WAS NOT TO BE CAUGHT
         L     R0,XSPEXRTN         GET CALLABLE EXIT @
         LTR   R0,R0               WAS ONE ACTUALLY SUPPLIED?
         BZ    XSPNOCLX            IF NONE, THEN DON'T TRY TO CALL
         LR    R15,R0              MOVE @ TO R15 FOR BALR, WATCH ADDRES
         BALR  R14,R15             GO TO CALLABLE EXIT: MUST RETURN
         USING *,R14               NOTE TEMP USING FOR REGAIN OF R15
         L     R15,XSPSVRET+4      GET ORIGINAL ENTRY POINT ADDRESS
         USING XSPIEBLK,R14        INFORM OF DSECT USING AGAIN
         AIF   (&$ASMLVL).XSPNRES  SKIP REGISTER SAVE IF UNDER OS
         SPACE
*        UNDER DOS, REGS THAT WERE CHANGED BY CALLABLE EXIT MUST BE   *
*        UPDATED IN SAVE AREA TO SHOW NEW VALUES OVER IN EXIT ROUTINE *
         STM   R2,R12,XSPYSAVE+16  SAVE NEW VALUES FROM CALLABLE EXIT
.XSPNRES ANOP
         L     R14,XSPACBLK        REGAIN POINTER TO XSPIEBLK
XSPNOCLX L     R0,XSPCLBEX         GET @ OF EXIT ROUTINE
         LTR   R0,R0               WAS IT EVER SUPPLIED?
         BZ    XSPIERTN            DON'T CALL, JUST RETURN
         MVC   5(3,R1),XSPCLBAD    CHANGE THE PSW ADDRESS FIELD
         B     XSPIERTN            GO TO RETURN TO SUPERVISOR
XSPNTCTH EQU   *                   COME HERE IF NO SPIE SET
******** AIF   (&$DEBUG).XXSPNBG   SKIP IF NOT DEBUG MODE
         L     R14,=V(VWXTABL)     GET @ ASSEMBLER TABLE
         USING AVWXTABL,R14        NOTE PTR THERE
         XSNAP LABEL='ASSIST ABEND-SEND DECK TO SYSTEMS: 3-12; PSW,14-2#
               ; AVTAB',STORAGE=(*0(R1),*28(R1),*AVADDLOW,*AVWXEND) CPP
         DROP  R14                 ZAP TEMPORARY USING
.XXSPNBG DC    H'0'                BOMB HERE WITH S0C1
XSPNOSPY EQU   *                   MAY WISH TO PRINT A MSG.
XSPIERTN DS    0H
         L     R13,XSPSVRES        RELOAD CORRECT R13
         AIF   (NOT &$ASMLVL).XSPRST        DON'T RESTORE R1 IF NOT OS
         S     R1,=F'4'            RESTORE OS R1 TO POINT TO PIE BLOCK
         L     R14,XSPSVRET        GET RETURN ADDRESS
         BR    R14                 RETURN CONTROL TO SUPERVISOR
.XSPRST  AIF   (&$ASMLVL).XSPNEXT  SKIP IF OS, SINCE NO EXIT PC
         EXIT  PC                  RETURN CONTROL TO SUPERVISOR
.XSPNEXT ANOP
XSPACBLK DC    F'-1'               ACTIVE XSPIEBLK POINTER
XSPYSAVE DC    18F'-1'             SAVEAREA FOR REGS & DOS INTERRUPTS
XSPSVRES DC    F'-1'               FOR REG 13
XSPSVRET DC    2F'-1'              FOR TEMP LOC. OF RET & REP REGS
         LTORG
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: XSPIEBLK    INTERRUPT COMMUNICATIONS CONTROL BLOCK        *
*        THIS BLOCK CONTAINS EXIT ADDRESSES AND INTERRUPT MASKS FOR   *
*        USE IN HANDLING THE 15 PROGRAM EXCEPTIONS.  THE INTERRUPT    *
*        MASK IS EXTENDED TO A FULLWORD FOR EASE OF TESTING AGAINST   *
*        THE INTERRUPTS THAT WERE DESIRED TO BE TRAPPED.  THE EXIT    *
*        ADDRESS IS OF LENGTH 3 FOR CHANGING THE PSW(ONLY 3 BYTE @    *
*        LOCATION:  INSIDE $SPIE MACRO EXPANSION                      *
*        GENERATION:  ONE XSPIEBLK IS GENERATED FOR EVERY $SPIE       *
*            EXPANSION EXCEPT LINKAGE TERMINATION & RESTORATION       *
*        NAMES:  XSP-----                                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
XSPIEBLK DSECT
XSPCLBEX DS    C                   ALIGNMENT FOR VL3 PSW (@ PORTION)
XSPCLBAD DS    VL3                 @ OF INTERRUPT EXIT ROUTINE
XSPEXRTN DS    VL4                 @ OF CALLABLE EXIT ROUTINE
XSPINTRP DS    BL2                 POSSIBLE INTERRUPT MASK BITS
         DS    BL2'0'              TRAILING ZEROES FOR EASY TESTING
