         PRINT ON,NOGEN
         TITLE 'ASSIST VERSION 4.0/A - MARCH 1975'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        PENNSYLVANIA STATE UNIVERSITY COMPUTER SCIENCE DEPARTMENT    *
*        PROJECT SUPERVISION: GRAHAM CAMPBELL                         *
*        PROGRAM DESIGN, CODING, DOCUMENTATION: JOHN R. MASHEY.       *
*        DOS/360 CONVERSION, $SPIE, XXXXSPIE: SCOTT A. SMITH.         *
*                                                                     *
*        PROGRAM WRITTEN BEGINNING SUMMER 1969.                       *
*        FIRST BATCH USAGE:  SPRING TERM, 1970.                       *
*        FIRST USAGE ON STUDENT REMOTE TERMINALS: FALL TERM, 1970.    *
*        FIRST DISTRIBUTION TO OTHER INSTALLATIONS: SUMMER 1971.      *
*        FIRST DISTRIBUTION (DOS/360 VERSION) : FALL 1971.            *
*                                                                     *
*        DISK UTILITY (DISKU) FACILITY (XXXXDK##, UTOPRS CHANGES):    *
*              RICHARD FORD, PAUL WEISSER - SPRING 1972.              *
*        XHEXI, XHEXO ADDITIONS: ALAN ARTZ - SPRING 1972.             *
*        S/370 INSTRUCTIONS: CHARLES JOHNSON - SPRING 1972.           *
*        MACRO PROCESSOR - GRAHAM CAMPBELL - SPRING, SUMMER 1972.     *
*        LIBRARY MACRO FETCH AND PROCESSING: RICHARD FORD, SUMMER 1972*
*        IMPROVED MACRO PROCESSOR, OPEN CODE ALAN ARTZ,               *
*              JOHN STERNBERGH - FALL,WINTER 1972 - 73                *
*        DOS DISK UTILITY - RICHARD FORD - WINTER 1973                *
*        EXTENDED I/O PACKAGE, XGET - XPUT - RICHARD FOWLER -         *
*              FALL 1972                                              *
*        CROSS-REFERENCE- ALAN ARTZ, ALICE FELTE, RICH LONG -         *
*              SPRING, SUMMER 1973.                                   *
*        EXTENDED INTERPRETER- MARK DALTON, JOHN STERNBERGH, RICH     *
*              LONG - SPRING, SUMMER, FALL 1973.                      *
*        DOCUMENTATION UPDATE- GLENN FADNER - FALL 1973, WINTER 1974. *
*                                                                     *
*         MANY THANKS TO SHELLY GEARHART FOR HELP WITH DISTRIBUTION   *
*         MATERIALS.  SPECIAL THANKS TO KAREN HOERTER (PSU CC PROGRAM *
*         LIBRARIAN)FOR HANDLING OF ASSIST TAPE DISTRIBUTION, AND FOR *
*         FACING MASSIVE PILE OF TAPES WITHOUT MOANING (TOO MUCH).    *
* * * * * NOTES ON DISTRIBUTION VERSIONS OF ASSIST  * * * * * * * * * *
*                                                                     *
*        VERSION   DATE AVAIL.     COMMENTS                           *
*                                                                     *
*        1.2/A1    09/01/71        ORIGINAL DISTRIBUTION VERSION      *
*                                                                     *
*        1.3/A     04/01/72        CONTAINS DOS/360 CODE, FIXES BUGS  *
*                                                                     *
*        2.0/A     08/72(APPROX)   MACRO PROCESSOR, S/370, DISK OPTION*
*                                  FOR INTERMEDIATE STORAGE IF NEEDED.*
*              PREPARED BY: RICHARD FORD + JRM                        *
*                                                                     *
*        2.1/A     02/01/73        OPEN CODE, DOS DISKU, XGET - XPUT  *
*              PREPARED BY: ALAN ARTZ, ALICE FELTE + JRM              *
*                                                                     *
*        3.0/A     08/01/73        XREF, HASP AUTOBATCH, OVERLAYS     *
*              PREPARED BY: RICH LONG + JRM                           *
*                                                                     *
*        3.0/B     03/01/74        EXTENDED INTERPRETER,DOCUMENTATION *
*                                    UPDATES.                         *
*              PREPARED BY: MARK DALTON, GLENN FADNER, RICH LONG      *
*                                                                     *
*        4.0/A     3/01/75         CLEANS UP 3.0/B                    *
*                                  EXTENDED INTERP., ETC              *
*           PREPARED BY THOMAS MINSKER                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE '*** XCHAR MACRO - SAFE RIGHT-END SUBSTRING MACRO ***'
         MACRO
         XCHAR &STRING,&NUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCHAR      RETURN SAFE RIGHT-END SUBSTRING OF A STRING.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO RETURNS IN &XXCHAR THE &NUM CHARACTERS TAKEN FROM *
.*       THE RIGHT END OF THE CHARACTER STRING &STRING, WITHOUT       *
.*       BLOWING UP IF THERE ARE LESS THAN &NUM CHARS IN &STRING.     *
.*       THIS MACRO IS USED BY XSAVE,XRETURN, AND XSRNR               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             RETURN RESULT IN THIS
         AIF   (&NUM GT K'&STRING).XGA       SKIP IF HE WANTS MORE
&XXCHAR  SETC  '&STRING'(K'&STRING+1-&NUM,&NUM)        SCOOP RIGHT AMT
         MEXIT
.XGA     ANOP
&XXCHAR  SETC  '&STRING'           STRING SMALLER-USE WHOLE THING
         MEND
         TITLE 'XDECI MACRO - EXTENDED DECIMAL INPUT CONVERSION'
         MACRO
&LABEL   XDECI &REG,&ADDRESS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION              *
.*--> MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION * * * * * * *
.*             EXTENDED DECIMAL INPUT MACRO - ENABLES PROGRAMS        *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       USES MODULE XXXXDECI TO SCAN DECIMAL STRING BEGINNING AT     *
.*       &ADDRESS, CONVERT ITS VALUE INTO REGISTER &REG, AND SET      *
.*       REGISTER R1 AS A SCAN POINTER TO THE DELIMITER FOLLOWING THE *
.*       STRING OF DECIMAL DIGITS.  THE CONDITION CODE IS SET BY THE  *
.*       VALUE IN &REG, UNLESS AN ERROR OCCURRS, IN WHICH CASE CC=3.  *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF LABEL
&XLABL   SETC  'XX&SYSNDX.E'       CREATE UNIQUE LABEL
         CNOP  2,4  .              LINE UP ON BOUNDARY
&LABEL   STM   14,1,&XLABL  .      SAVE LINKAGE REGS
         LA    0,&ADDRESS .        BEGINNING @ FOR SCANNING
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION
         BALR  14,15 .             CALL ROUTINE, PT WITH R14
         DC    V(XXXXDECI) .       ADCON FOR CONVERSION ROUTINE
&XLABL   DS    5F .                REGS 14,15,0,1, VALUE FOR &REG
         LM    14,1,4(14) .        RELOAD REGS
         BO    *+8 .               BRANCH IF &REG SHOULDN'T CHANGE
         L     &REG,&XLABL+16  .   GET VALUE FOR &REG
         AIF   (T'&REG EQ 'N' AND '&REG' NE '1').XXEXIT SKIP IF SAFE
         L     1,&XLABL+12  .      USER MAY HAVE REG=1, LOAD FOR SAFE
.XXEXIT  MEND
         TITLE 'XDECO MACRO - EXTENDED DECIMAL OUTPUT CONVERSION'
         MACRO
&LABEL   XDECO &REG,&ADDRESS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XDECO      EXTENDED DECIMAL OUTPUT CONVERSION            *
.*       USES MODULE XXXXDECO TO CONVERT VALUE IN REGISTER &REG TO    *
.*       AN EDITED 12-BYTE FIELD, WITH SIGN, AT LOCATION &ADDRESS.    *
.*             EXTENDED DECIMAL OUTPUT MACRO - ENABLES PROGRAMS       *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF UNIQUE LABEL
&XLABL   SETC  'XX&SYSNDX.D'       CREATE UNIQUE LABEL
         CNOP  2,4 .               LINE UP ON RIGHT BOUNDARY
&LABEL   STM   14,0,&XLABL  .      STORE LINKAGE REGS
         ST    &REG,&XLABL+12  .   SAVE VALUE TO BE CONVERTED
         LA    0,&ADDRESS .        OBTAIN @ OPERAND FILED
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION PROG
         BALR  14,15 .             CALL XXXXDECO, PT R14
         DC    V(XXXXDECO) .       ADCON FOR CONVERSION PROG
&XLABL   DS    4F .                REGS 14,15,0, REG TO BE CONVERTED
         LM    14,0,4(14) .        RELOAD LINKAGE REGISTERS
         MEND
         TITLE 'MACRO-->XHEXI EXTENDED HEXADECIMAL CONVERSION'
         MACRO
&NAME    XHEXI &REG,&ADDR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XHEXI  HEXADECIMAL INPUT CONVERSION MACRO.                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE STARTING AT THE ADDRESS GIVEN BY  *
.*  &ADDR AND CONVERTS IT AND PUTS THE HEXADECIMAL VALUE IN &REG.     *
.*  IF THERE ARE MORE THAN 8 DIGITS, R1 POINTS TO THE 9TH AND THE     *
.*  FIRST 8 ARE CONVERTED.  IF THERE IS A NON-BLANK, NON-HEX DIGIT    *
.*  FOUND, R1 POINTS TO THAT CHARACTER AND THE CC=3, OTHERWISE CC SET *
.*  BY VALUE IN REG.                                                  *
.*                                                                    *
.*       CALLS MODULE XXXXHEXI TO DO THE ACTUAL CONVERSIONS           *
.*                                                                    *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &LABEL
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    STM   14,0,&LABEL  .     SAVE REGISTERS
         ST    &REG,&LABEL+12  .  REGISTER STORE INCASE OF OVERFLOW CND
         LA    0,&ADDR  .         GET STRING TO BE CONVERTED
         CNOP  2,4  .             GET PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXI
         BALR  14,15  .           GO TO APPROPRIATE PLACE
         DC    V(XXXXHEXI)  .     VCON OF ROUTINE
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,4(14)  .      RESTORE REGISTERS
         L     &REG,&LABEL+12  .  GET CONVERTED NUMBER
         MEND
         TITLE 'MACRO-->XHEXO EXTENDED HEXADECIMAL CONVERSION'
         MACRO
&NAME    XHEXO &REG,&ADDR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XHEXO  HEXADECIMAL OUTPUT CONVERSION MACRO                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE IN &REG AND CONVERTS IT TO        *
.*  PRINTABLE FORM.                                                   *
.*       IT PUTS THE CONVERTED VALUE IN AN EIGHT BYTE AREA STARTING AT*
.* THE ADDRESS GIVEN IN &ADDR.                                        *
.*       THE CC AND REGISTERS ARE LEFT UNCHANGED.                     *
.*                                                                    *
.*       CALLS MODULE XXXXHEXO TO DO THE ACTUAL CONVERSIONS.          *
.*                                                                    *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &LABEL
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    DS    0H
         STM   14,0,&LABEL  .     SAVE REGISTERS
         ST    &REG,&LABEL+12  .  SAVE &REG
         LA    0,&ADDR   .        PASS REGISTER TO XXXXHEXO
         CNOP  2,4  .             GET PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXO
         BALR  14,15  .           CALL XXXXHEXO
         DC    V(XXXXHEXO)
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,&LABEL  .     RESTORE REGISTERS
         MEND
         TITLE '*** XIDENT MACRO - CREATE ID FOR XSAVE MACRO ***'
         MACRO
         XIDENT &ID,&LABEL,&XCSECT,&PRIVATE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIDENT     IDENTIFY ENTRY POINT FOR XSAVE,$SAVE.         *
.*       MACRO USED BY XSAVE TO PRODUCE ID AT AN ENTRY POINT.  WILL   *
.*       USE THE FIRST NON-NULL OPERAND PASSED TO IT AS THE ID.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&J                LOCAL COUNTERS
&I       SETA  1                    INITIALIZE
         AIF   ('&ID' NE '*').XIDINC         SKIP IF EXPLICIT ID FIELD
.XILOOP  ANOP
&I       SETA  &I+1                 INCREMENT TO NEXT ONE
         AIF   ('&SYSLIST(&I)' EQ '').XILOOP SKIP BACK IF THIS IS NULL
.XIDINC  ANOP
&J       SETA  6+((K'&SYSLIST(&I)+1)/2)*2   GET BRANCH LENGTH
         B     &J.(,15) .           BRANCH AROUND ID
&J       SETA  &J-5                 GET ACTUAL LENGTH OF ID
         DC    AL1(&J),CL&J'&SYSLIST(&I)'
         MEND
         TITLE ' *** XIONR-INNER MACRO FOR XREAD,XPRNT,XPNCH ***'
         MACRO
&XLABEL  XIONR &XNAME,&XNUM,&XAREA,&XDEFT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIONR      INNER MACRO-$READ,$PNCH,$PRNT,$SORC           *
.*                                 ALSO XGET,XPUT,$GET,AND$PUT        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XIONR IS USED BY XIOPAK MACROS XREAD,XPRNT,XPNCH TO SET UP   *
.*       THE REQUIRED CODE FOR CALLING THEIR RESPECTIVE SUBROUTINES.  *
.*       *** ARGUMENTS ***                                            *
.*       XNAME     THE NAME OF THE I/O ROUTINE TO BE CALLED.          *
.*       XNUM      THE LENGTH OF XAREA TO BE PRINTED,PUNCHED,ETC.     *
.*       XAREA     THE AREA ON WHICH I/O OPERATION TO BE PERFORMED.   *
.*             MAY BE SPECIFIED BY (0) OR (R0).                       *
.*       XDEFT     DEFAULT VALUE OF XNUM TO BE USED, IF IT IS OMITTED *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&XAREA EQ 'O').XERR1       PRODUCE MNOTE
&XLABEL  STM   14,0,XX&SYSNDX.R+4 .    SAVE REGS WHICH WILL BE CHANGED
         AIF   (T'&XNUM EQ 'O').XN1    SKIP NEXT CHECK IF OMITTED
         AIF   ('&XNUM'(1,1) NE '(' OR '&XNUM'(K'&XNUM,1) NE ')').XN1
         STH   &XNUM,XX&SYSNDX.R+16 .       STORE LENGTH
.XN1     AIF   ('&XAREA' EQ '(0)' OR '&XAREA' EQ '(R0)').XNOLA
.XN2     LA    0,&XAREA
.XNOLA   L     15,XX&SYSNDX.R  .   GET BRANCH ADDRESS
         CNOP  2,4  .              ADJUST FOR RIGHT ALIGNEMNT
         BALR  14,15 .             CALL ROUTINE, R14==> CONTROL BLOCK
XX&SYSNDX.R DC V(&XNAME)  .        ROUTINE ADDRESS
         DS    3F .                SAVE SPACE FOR REGS 14-0
         AIF   ('&XNUM' EQ '').XDFT         SKIP IF DEFAULT SHOULD BE
         DC    AL2(&XNUM) .        LENGTH OF AREA
         AGO   .XDS                SKIP
.XDFT    DC    AL2(&XDEFT) .       DEFAULT LENGTH USED
.XDS     LM    14,0,4(14) .        RESTORE REGS. CON CODE ALREADY DONE
         MEXIT
.XERR1   MNOTE 0,'**XIONR- AREA ADDRESS OMITTED-GENERATION CANCELLED'
         MEND
         TITLE '*** XLOOK MACRO - LOOK UP ELEMENT IN LIST ***'
         MACRO
         XLOOK &ARG1,&ARGL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XLOOK      FIND POSITION OF ELEMENT IN LIST.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO TO FIND AND RETURN POSTION OF ARGUMENT IN A SUBLIST.   *
.*       &ARG1 ARGUMENT TO BE SEARCHED FOR                            *
.*       &ARGL LIST OF ARGUMENTS FOR &ARG1 TO BE CHECKED FOR IN       *
.*       &XXLOOK   THE FIRST POSITION IN &ARGL IN WHICH &ARG1 IS      *
.*       FOUND, IF ANY.  IF &ARG1 IS NOT IN &ARGL, &XXLOOK = 0.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             FOR RETURN OF INDEX VALUE
&XXLOOK  SETA  1                   INITIALIZE THE COUNTER
.XLA     AIF   (&XXLOOK GT N'&ARGL).XLB     IF GT,QUIT,NOT FOUND
         AIF   ('&ARG1' EQ '&ARGL(&XXLOOK)').XXEXIT   IF FOUND,RETURN
&XXLOOK  SETA  &XXLOOK+1           INCREMENT COUNTER
         AGO   .XLA                GO BACK FOR NEXT CHECK
.XLB     ANOP
&XXLOOK  SETA  0                   NOT FOUND, SET TO 0 TO SHOW THIS
.XXEXIT  MEND
         TITLE ' *** XMUSE - INNER MACRO FOR XSAVE-MULTIPLE USING ***'
         MACRO
         XMUSE &BR,&AD
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XMUSE      BASE REGISTER SETUP MACRO FOR XSAVE           *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       THIS MACRO IS CALLED BY XSAVE TO HANDLE BR AND AD OPERANDS,  *
.*       AND PRODUCE APPROPRIATE USINGS.  &BR AND &AD ARE FROM XSAVE. *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&N               LOCAL COUNTERS
         LCLC  &B(4),&V            BASE REGS, USING NAME
&N       SETA  N'&BR               GET NUMBER WHERE HANDY
&V       SETC  '*'                 NORMAL USE
         AIF   (&N LE 4).XNOKA     MAKE SURE NOT TOO MANY BASES
&N       SETA  4                   IDIOT USER HAD >4 BASES, IGNORE EXTR
         MNOTE 4,'**XMUSE- MORE THAN 4 BASE REGS-EXTRAS IGNORED'
.XNOKA   AIF   ('&AD' EQ '').X1LOOP         SKIP IF NORMAL SITUATION
.*             USED IF AD PARAMATER WAS SPECIFIED IN XSAVE MACRO.     *
         CNOP 0,4
         B     *+8 .               SKIP AROUND ADDRESS CONSTANT
         DC    A(&AD)       .      ADDRESS CONSTANT FOR AD=PARAMETER
         L     &BR(1),*-4 .        LOAD ADCON INTO RIGHT REGISTER
&V       SETC  '&AD'               CHANGE NAME FOR USING 1ST OPERND
.*             NORMAL SECTION OF CODE FOR GENERATING USING.           *
.X1LOOP  ANOP
&I       SETA  &I+1      INCREMENT COUNTER TO BASE REG
&B(&I)   SETC  ',&BR(&I)'          GET I'TH BASE REGISTER
         AIF   (&I LT &N).X1LOOP   CONTINUE UNTIL ALL BASE REGS DONE
         DROP  15 .                CLEAN UP USING SITUATION
         USING &V&B(1)&B(2)&B(3)&B(4)
         MEND
         TITLE '*** XRETURN MACRO - EXTENDED RETURN MACRO ***'
         MACRO
&LABEL   XRETURN &RGS=(14-12),&SA=,&RC=,&RP=,&T=,&TR=*,&REEN=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XRETURN    GENERAL RETURN MACRO, OS LINKAGE              *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED RETURN MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN   *
.*       FOR EXPLANATION AND USE OF OPERANDS.                         *
.*       USES MACROS: FREEMAIN,XCHAR,XSRNR                            *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XRETUST            =0 TRACE GENERATION OK, =1 NO TRACE
         GBLC  &XSAVE,&XXCHAR      STD SAVE AREA NAME, XCHAR VARIABLE
         LCLA  &I                  LOCAL COUNTER
         LCLB  &RCA,&RCB           FOR CONTROL OF RETURN CODE GENER
.*                                                                    *
.*       GENERATE LABEL IF THERE IS ONE, GENERATE TRACE CODE IF IT    *
.*       IF DESIRED, AND SET UP LCLB VARIABLES TO DESCRIBE RETURN     *
.*       CODE CONDITIONS. GENERATE LR IF NEEDED FOR RC OPTION.        *
.*                                                                    *
         SPACE 1
         AIF   (T'&LABEL EQ 'O').XNOLB       SKIP IF NO LABEL USED
&LABEL   DS    0H .                DEFINE LABEL
.XNOLB   AIF   ('&TR' EQ 'NO' OR &XRETUST).XNORT       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,EXITED   GET TRACE GENERATED
.XNORT   ANOP
&RCA     SETB  (T'&RC EQ 'O')      TRUE IF WHOLE THING OMITTED
&RCB     SETB  (1)                 SET THIS WAY FOR NEXT TEST
         AIF   (&RCA).XNRCB        SKIP IMMEDIATELY IF OMITTED
&RCB     SETB  ('&RC'(1,1) NE '(' OR '&RC'(K'&RC,1) NE ')')  NOT RG TYP
         AIF   (&RCB).XNRCB       SKIP IF NOT REGISTER TYPE
         XCHAR &RC,3               GET LAST 3 CHARS
         AIF   ('&XXCHAR' EQ '15)').XNRCB    SKIP IF ALREADY IN 15
         LR    15,&RC .            LOAD RETURN CODE FROM DESIRED REG
.XNRCB   AIF   (T'&REEN EQ 'O').XNORM        SKIP IF NOT REENTRANT
.*                                                                    *
.*       REENTRANT RETURN CODE GENERATION - OBTAIN ADDRESS AND LENGTH *
.*       OF AREA FROM WHERE XSAVE PUT THEM,DO FREEMAIN,FIXUP REGS.    *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XRETUST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XRETURN- TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    L     13,4(13) .          GET OLD SA POINTER BACK
         STM   15,1,16(13) .       SAVE REGS FROM FREEMAIN CRUNCHING
         L     1,8(13) .           GET ADDRESS OF AREA BACK
*        FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         LM    15,1,16(13) .       RESTORE THE REGS
         AGO   .XNORM1             GO TO PROCESS REGISTER RESTORATION
.XNORM   AIF   ('&SA' EQ 'NO').XNORM1        SKIP RESTORATION IF UNUSED
.*                                                                    *
.*       REGISTER RESTORATION CODE - RESTORE REGS FROM CALLER'S       *
.*       SAVE AREA,DEPENDING ON RETURN CODE AND FUNCTION OPTIONS.     *
.*                                                                    *
         L     13,4(13) .          RESTORE PREVIOUS SAVE AREA POINT
.XNORM1  AIF   ('&RGS' EQ 'NO').XNORM2A     SKIP IF NO REGS NEEDED
         AIF   ('&RGS' NE '(14-12)' OR NOT &RCB).XNORM2
         LM    14,12,12(13) .      STANDARD REGISTER RESTORATION
         AGO   .XNORM2A            CONTINUE
.XNORM2  ANOP
&I       SETA  &I+1                INCREMENT COUNTER
         XSRNR L,&RGS(&I),&RCB     HAVE RESTORE CODE GENRATED
         AIF   (&I LT N'&RGS).XNORM2        LOOP UNTIL DONE
.*                                                                    *
.*       RETURN CODE(15) AND RETURN PAST(14) CODE GENERATION.         *
.*                                                                    *
.XNORM2A AIF   (&RCA OR NOT &RCB).XNORM3    SKIP IF NOT LA TYPE RC=
         LA    15,&RC .            PUT RETURN CODE IN 15
.XNORM3  AIF   ('&T' NE '*').XNORM4          SEE IF MVI WANTED
         MVI   12(13),X'FF' .      SHOW WE HAVE RETURNED
.XNORM4  AIF   (T'&RP EQ 'O').XNORP          SKIP IF RP NOT USED
         B     &RP.(14) .          RETURN GIVEN NUMBER PAST 14
         AGO   .XNORM5
.XNORP   BR    14 .                RETURN NORMALLY TO CALLER
.*                                                                    *
.*       SAVE AREA GENERATION - IF A SAVE AREA SHOULD BE CREATED,     *
.*       USE EITHER ONE SPECIFIED BY MACRO,OR ELSE STANDARD ONE.      *
.*                                                                    *
.XNORM5  AIF   (T'&SA EQ 'O' OR '&SA' EQ 'NO').XEXIT   SKIP IF NO SAV5
         AIF   ('&SA' EQ '*').XSASTD         IF *,USE STANDARD SAVE
&SA      DC    18F'0' .            SAVE AREA,NAMED BY MACRO
         AGO   .XEXIT
.XSASTD  ANOP
&XSAVE   DC    18F'0' .            SAVE AREA,USING GENERATED NAME
.XEXIT   SPACE 1
         MEND
         TITLE '*** XSAVE - EXTENDED SAVE MACRO ***'
         MACRO
&LABEL   XSAVE &RGS=(14-12),&BR=12,&SA=*,&ID=*,&TR=*,&REEN=,&OPT=,&AD=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSAVE      EXTENDED SAVE MACRO - OS LINKAGE.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED SAVE MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN     *
.*       FOR DESCRIPTION OF ARGUMENTS FOR THIS MACRO                  *
.*       USES MACROS: GETMAIN,XCHAR,XIDENT,XLOOK,XMUSE,XSRNT,XSRTR    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             RETURN VARIABLE FROM XLOOK MACRO
         GBLB  &XSAVEST            =0 TRACE GEN OK, =1 NO TRACE DONE
         GBLC  &XSAVE,&XCSECT,&XXCHAR  STD NAME,CSECT NAME,XCHAR VAR
         LCLA  &I                  LOCAL COUNTER
         LCLB  &XNSECT             FLAG FOR NEW CSECT
         LCLC  &B1,&BT             1ST BASE,LAST 2 CHARS OF 1ST BASE
&B1      SETC  '&BR(1)'            GET FIRST OR ONLY BASE IN EASIER NAM
         XCHAR &B1,2               GET LAST 2 CHARS OF BASE REG
&BT      SETC  '&XXCHAR'           GET LAST 2 CHARACTERS
&XNSECT  SETB  ('&SYSECT' NE '&XCSECT')      NOTE IF NEW CSECT NEEDED
&XCSECT  SETC  '&SYSECT'           SET TO SYSECT, FOR NORMAL USE
.*                                                                    *
.*       CHECK OPT FIELD - GENERATE TITLE AND/OR ENTRY OR CSECT       *
.*       STATEMENTS, DEPENDING ON CONTENTS OF OPT FIELD, IF USED.     *
.*                                                                    *
         AIF   (T'&OPT EQ 'O').XNOPS         SKIP IF OPT UNUSED
         XLOOK TITLE,&OPT           WAS TITLE OPTION USED
         AIF   (&XXLOOK EQ 0).XNTITL         SKIP IF TITLE NOT USED
         AIF   (N'&OPT EQ 1).XNOPS SKIP IF TITLE ONLY
         TITLE '*** &LABEL ***'
.XNTITL  XLOOK ENTRY,&OPT           WAS ENTRY USED
         AIF   (&XXLOOK EQ 0).XTRCS         SKIP IF NOT USED
         AIF   ('&LABEL' EQ '').XENTE        SKIP TO ERR IF NO LABEL
         ENTRY &LABEL  .            NOTE XSAVE ENTRY OPTION
         AGO   .XNOPS
.XENTE   MNOTE 4,'**XSAVE- OPT=ENTRY USED WITHOUT LABEL-OPTION IGNORED'
         AGO   .XNOPS
.XTRCS   XLOOK CSECT,&OPT           CHECK FOR CSECT OPTION
         AIF   (&XXLOOK EQ 0).XTRCS1        SKIP IF OPTION NOT THERE
&LABEL   CSECT
&XCSECT  SETC  '&LABEL'            SET THIS TO SHOW NEW CSECT
&XNSECT  SETB  (1)                  NOTE THAT NEW CSECT IS NEEDED
         AGO   .XENT1               SKIP OVER &LABEL DEFN
.XTRCS1  MNOTE 0,'**XSAVE- UNKNOWN OPT=&OPT- IGNORED'
.*                                                                    *
.*       CREATE STATMENT LABEL IF ANY. IF IDENTIFIER REQUESTED,USE    *
.*       SPECIFIED IDENTIFIER,STATEMENT LABEL,OR CSECT NAME IN XIDENT *
.*       TO GENERATE CORRECT IDENTIFIER WITH BRANCH AROUND IT.        *
.*                                                                    *
.XNOPS   SPACE 2
&LABEL   DS    0H .                DEFINE LABEL,MAKE SURE ALIGNED
.XENT1   USING *,15 .              FOR TEMPORARY ADDRESSIBILITY
         AIF   ('&SA' EQ '*' OR '&SA' EQ 'NO').XCHKS1 SKIP IF NO CHANGE
&XSAVE   SETC  '&SA'                EXPLICIT NEW SAVE AREA NAME
         AGO   .XSAOK
.XCHKS1  AIF   ('&XSAVE' NE '').XCHKS2       SKIP IF NOT NULL
&XSAVE   SETC  '$PR#&SYSNDX'        SET UP DEFAULT SAVE AREA NAME
         AGO   .XSAOK
.XCHKS2  AIF   (NOT &XNSECT).XSAOK SKIP IF NEW SAVE NOT NEEDED
&XSAVE   SETC  '&XCSECT'(1,3).'#&SYSNDX'     DEFAULT SAVE AREA NAME
.*                                                                    *
.XSAOK   AIF   ('&ID' EQ 'NO').XID3 SKIP IF NO ID WANTED
         XIDENT &ID,&LABEL,&XCSECT,$PRIVATE CALL TO SET UP IDENT
.*                                                                    *
.*       IF TR OPTION IN EFFECT, CALL XSRTR TO GENERATE RIGHT CODE,   *
.*       THEN HAVE XSRNR GENERATE CODE TO SAVE RANGES OF REGISTERS    *
.*                                                                    *
.XID3    AIF   (&XSAVEST OR '&TR' EQ 'NO').XNOTR       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,ENTERED  GET TRACE GENERATED
.XNOTR   AIF   ('&RGS' NE '(14-12)').XSRCAL SKIP IF NOT STANDARD
         STM   14,12,12(13) .      SAVE STANDARD REGISTER SET
         AGO   .XCHK13
.XSRCAL  AIF   ('&RGS' EQ 'NO').XCHK13       SKIP IF NO REGS SAVED
&I       SETA  1                   INITIALIZE COUNTER
.XSETUP  XSRNR ST,&RGS(&I)         CALL XSRNR WITH EACH REG SET
&I       SETA  &I+1                INCREMENT TO NEXT REGS SET
         AIF   (&I LE N'&RGS).XSETUP         CONTINUE PROCESSING RGS
.XCHK13  AIF   ('&BT' NE '13').XNORM1       NOT REG 13,DO NORMALLY
.*                                                                    *
.*       REGISTER 13 DOUBLE USAGE - THIS SECTION GENERATES CODE TO    *
.*       USE REGISTER 13 BOTH AS A BASE AND AS THE SAVE AREA POINTER. *
.*                                                                    *
         AIF   (T'&AD EQ 'O').XU2  SKIP TO NORMAL IF &AD OMITTED
         LR    14,13 .             SAVE @ OLD SAVE AREA BEFORE SETTING
         XMUSE &BR,&AD             HAVE ADCON SET UP
         ST    13,8(14) .          SAVE NEW POINTER INTO OLD SAVEAREA
         ST    14,4(13) .          SAVE OLD POINTER INTO NEW AREA
         AGO   .XEND1              GO FINISH UP
.XU2     CNOP  0,4
         ST    13,&XSAVE+4 .       SAVE OLD SA POINTER INTO NEW AREA
         BAL   13,&XSAVE+72 .      SET UP 13, BRANCH AROUND SA
         XMUSE &BR                 SET UP WHATEVER USING REQUIRED
&XSAVE   DC    18F'0'  .           SAVE AÞEA
.XU3     L     15,&XSAVE+4 .       GET OLD SA POINTER BACK TO SET LINKS
         ST    13,8(15) .          STORE NEW POINTER IN OLD AREA
         AGO   .XEND1              CHECK NUMBER OF BR'S,GET LA'S SET UP
.*                                                                    *
.XNORM1  AIF   (T'&REEN EQ 'O').XNORM2       SKIP OVER REENTRANT
.*                                                                    *
.*       REENTRANT ENTRY CODE GENERATION - THIS GENERATES CODE TO     *
.*       ACQUIRE SPACE FOR SAVEAREA(72 BYTES) + AS MUCH MORE SPACE    *
.*       AS IS SPECIFIED IN REEN PARAMATER, IF USED.                  *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XSAVEST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XSAVE- USE OF TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    ANOP
         GETMAIN R,LV=8*((&REEN+79)/8) .GET CORE ROUNDED TO DBLWRD
         ST    13,4(1) .           STORE OLD POINTER IN NEW AREA
         ST    1,8(13) .           STORE (EW POINTER IN OLD AREA
         LR    &B1,1 .             SAVE VALUE OF NEW SAVE POINTER
         LM    0,1,20(13) .        RESTORE PREVIOUS VALUES OF REGS
         LR    13,&B1 .            POINT 13 TO NEW SAVE AREA
         AGO   .XNEWBS             GO GENERATE NEW BALR,USING
.*                                                                    *
.*       NORMAL,NON-REENTRANT ENTRY CODE SECTION.                     *
.*                                                                    *
.XNORM2  AIF   ('&SA' EQ 'NO').XNEWBS        SKIP IF NO SAVE AREA
         ST    13,&XSAVE+4 .       SAVE OLD POINTER IN NEW AREA
         AIF   ('&BT' NE '15').XSN15         SKIP IF NOT 15
         LA    13,&XSAVE .         GET ADDRESS OF NEW SAVE AREA
         L     &B1,&XSAVE+4 .      GET OLD SAVE POINTER BACK
         AGO   .XSOLD              GO SAVE NEW POINTER
.XSN15   LR    &B1,13 .            MOVE OLD POINTER OVER
         LA    13,&XSAVE    .      ADDRESS OF NEW SAVE AREA
.XSOLD   ST    13,8(&B1) .         SAVE NEW POINTER IN OLD AREA
.*             SET UP BALR, LA'S IF REQUIRED, AND USING STATEMENT.    *
.XNEWBS  AIF   ('&BT' NE '15' OR N'&BR GT 1).XSET2  SKIP IF 15
         AIF   ('&REEN' EQ '' AND '&SA' EQ 'NO' AND '&AD' EQ '').XEND2
.XSET2   AIF   (T'&AD NE 'O').XSET3          SKIP BALR IF ADCON USED
         BALR  &B1,0 .             SET UP NEW BASE REGISTER
.XSET3   XMUSE &BR,&AD             SET UP USINGS, ADCON IF NEEDED
.XEND1   AIF   (N'&BR EQ 1).XEND2  IF ONLY 1 BASE,DON'T CALL XMUSE
&I       SETA  2                    INITIALIZE
.XA2A    LA    &BR(&I),4095 .       LOAD IN ADDRESS
         LA    &BR(&I),1(&BR(&I),&BR(&I-1))  .   SET USING VALUES
&I       SETA  &I+1                 INCREMENT TO NEXT BASE
         AIF   (&I LE N'&BR AND &I LE 4).XA2A         LOOP FOR # BASES
.XEND2   SPACE 1
         MEND
         TITLE '*** XSNAP MACRO DEFINITION ***'
         MACRO
&XLABEL  XSNAP &T=PR,&LABEL=,&STORAGE=,&IF=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSNAP      EXTENDED SNAP MACRO-DEBUGGING-DUMPING.        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSNAP     IS USED FOR STORING,PRINTING OF REGISTERS AND ANY  *
.*       OTHER ADDRESSABLE AREAS. XSNAP HARMS NO REGISTERS,CAN BE USED*
.*       IN ANY NUMBER OF CSECTS IN 1 ASSEMBLY,AND PRINTS REGISTERS   *
.*       EXACTLY AS THEY ARE WHEN THE XSNAP IS CALLED.  XSNAP         *
.*       ACTION MAY BE MADE CONDITIONAL EITHER AT ASSEMBLY TIME OR    *
.*       DURING EXECUTE TIME.  SEE WRITEUP FOR OPERAND DESCRIPTION.   *
.*       USES MACROS: XLOOK                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             XLOOK RETURN VALUE
         GBLB  &XSNAPST            GENERATION STATUS,ON=0,OFF=1
         LCLA  &I,&K,&L,&N         LOCAL COUNTERS
         LCLB  &XP,&XF             PRINT REGS AND PRINT FLOATING REGS
         LCLC  &NAM,&INST,&A(5)
.*                                                                    *
.*       CHECK FOR XSNAPS BEING CANCELLED. CREATE LABEL IF NEEDED.    *
.*                                                                    *
         AIF   ('&T(3)' NE '').XGOGEN  SKIP  SKIP IF NONCANCELLABLE
         AIF   (NOT &XSNAPST).XGOGEN   GENERATE IF STATUS=ON
         AIF   (T'&XLABEL EQ 'O').XXEXIT    SKIP IF NOTHING TO GEN
&XLABEL  DS    0H  .               LABEL USED ON NULLIFIED XSNAP
         MEXIT
.XGOGEN  SPACE 1
&NAM     SETC  'XX&SYSNDX'         SET UP MOST OF NAME FOR LABELS
&N       SETA  (N'&STORAGE/2)*2    GET ROUNDED NUMBER OF OPERANDS
&XLABEL  STM   0,15,&NAM.B  .      SAVE ALL REGISTERS
.*                                                                    *
.*       IF OPTION - IF IF OPTION IS USED AND HAS CORRECT ARGUMENTS,  *
.*       GENERATE A CLI, C, OR CR INSTRUCTION TO PERFORM APPROPRIATE  *
.*       TEST,DEPENDING ON THE KIND OF IF ARGUMENTS . NEGATE THE      *
.*       CONDITION AND CREATE THE RIGHT EXTENDED MNEMONIC BRANCH      *
.*       SO THAT THE XSNAP WILL BE SKIPPED IF THE STATED CONDTION IS  *
.*       NOT MET.  GENERATE USER'S OWN OPCODE IF HE SUPPLIED ONE.     *
.*                                                                    *
         AIF   (T'&IF EQ 'O').XNOIF          SKIP IF IF NOT REQUESTED
         AIF   (N'&IF GE 3).XOKIF  SKIP IF ENOUGH ARGUMENTS
         MNOTE 0,'**XSNAP- IF=&IF:IGNORED, LACKS REQUIRED 3-4 OPERANDS'
         AGO   .XNOIF              CANCEL IF OPTION
.XOKIF   XLOOK &IF(2),(H,L,E,O,P,M,Z,NH,NL,NE,NO,NP,NM,NZ)
         AIF   (&XXLOOK GT 0).XOKIF1        SKIP IF OK RELATION
         MNOTE 0,'**XSNAP- IF=&IF(2) UNKNOWN-CANCELLED'
         AGO   .XNOIF              SKIP GENERATION OF THIS OPTION
.XOKIF1  ANOP
&INST    SETC  '&IF(4)'            GET INSTRUCTION
         AIF   (N'&IF EQ 4).X      IF OPCODE SUPPLIED,SKIP CHECKING
&INST    SETC  'CLI'               MAKE TENTATIVE INSTRUCTION SETUP
         AIF   ('&IF(1)'(1,1) NE '(' OR '&IF(1)'(K'&IF(1),1) NE ')').X
&INST    SETC  'C'                 PROBABLY WANTS RX TYPE
         AIF   ('&IF(3)'(1,1) NE '(' OR '&IF(3)'(K'&IF(3),1) NE ')').X
&INST    SETC  'CR'                2 REGS-USER WANTS RR TYPE
.X       ANOP
         &INST &IF(1),&IF(3) .     TEST
&INST    SETC  'BN&IF(2)'          NEGATE COND, HOPE FOR 1 OF 1ST SET
         AIF   (&XXLOOK LE 7).XOKIF2        SKIP IF NOW SET UP RIGHT
&INST    SETC  'B'.'&IF(2)'(2,2)   REMOVE N FROM COND
.XOKIF2  &INST &NAM.C
.*                                                                    *
.*             CREATE BRANCH AROUND THE SAVE AREA, FLAGS, ETC.        *
.*                                                                    *
.XNOIF   XLOOK &T(1),(PR,PRINT,FL,FLOAT,NO,NOREGS,ST,STORE)
&I       SETA  72+4*&N             LENGTH FOR T=PRINT,NOREGS
         AIF   (&XXLOOK LE 6).XBRNCH        SKIP IF ILLEGAL, OR PR,NO
&I       SETA  68                  LENGTH FOR T=STORE
.XBRNCH  B     &NAM.B+&I  .        BRANCH AROUND CONSTANTS
.*                                                                    *
.*       CREATE FRONT BRACKET CHARACTER STRING FOR REGISTER AREA      *
.*                                                                    *
         DS    0F  .               ALIGN LABEL ON FULLWORD
&L       SETA  8                   SET &L FOR NO LABEL= LENGTH
         AIF   (T'&LABEL EQ 'O').XNOLAB    IF NO LABEL,SKIP GENERATION
&L       SETA  ((K'&LABEL+1)/4)*4  ROUND LENGTH UP TO FULLWORD
         AIF   (&L LE 92).XLAB1    SKIP IF LABEL SMALL ENOUGH
         MNOTE 0,'**XSNAP- LABEL= OPERAND TRUNCATED TO 92 CHARACTERS'
&L       SETA  92                  TRUNCATE
.XLAB1   DC    CL&L&LABEL
         AGO   .XCHK1              SKIP GENRATION OF 1ST DELIMETER
.XNOLAB  DC    CL8'&NAM.B'   .     FRONT BRACKET FOR REGISTER AREA
.*                                                                    *
.*             CREATE REGISTER AREA, BRACKETS, FLAG VALUES, AS NEEDED *
.XCHK1   AIF   (&XXLOOK LT 7).XPRINT        SKIP IF PRINTED OUTPUT
&NAM.B   DC    16F'-1',4C'X' .     REGISTER SAVE AREA, BRACKET X'S
         AGO   .XIFLB              SKIP TO CHECK FOR IF LABEL
.XPRINT  AIF   (&XXLOOK GT 0).XPRINT1       SKIP IF LEGAL T=
         MNOTE 0,'**XSNAP- UNKNOWN T=&T: T=PR ASSUMED'
.XPRINT1 ANOP
&XP      SETB  (&XXLOOK LT 5)      SET TO 1 IF GP REGS NEEDED
&XF      SETB  (&XXLOOK GT 2 AND &XP)       SET TO 1 IF T=FL OR T=FLOAT
&XF      SETB  (&XF OR '&T(2)' EQ 'FL' OR '&T(2)' EQ 'FLOAT')
&NAM.B   DC    16F'-1',B'&T(3)00&XF&XP',AL1(0,&L,&N/2),V(XXXXSNAP)
.*                                                                    *
.*       GENERATE ADDRESS LIST FOR STORAGE=, WITH EITHER WORDS FOR    *
.*       STORING ADDRESSES OR A-TYPE ADDRESS CONSTANTS.               *
.*                                                                    *
         AIF   (T'&STORAGE EQ 'O').OKN      SKIP IF STORAGE= NOT USED
&I       SETA  1                   INITIALIZE AS COUNTER
         AIF   (&N EQ N'&STORAGE).LOOP1               SKIP IF LEGAL
         MNOTE 0,'**XSNAP- ODD OPERAND IGNORED: STORAGE=&STORAGE(&N)'
         AIF   (&N EQ 0).OKN
.LOOP1   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP1E
&K       SETA  1                   INITIALIZE COUNTER
.*             PROCESS ADDRESS REQUIRING LA - ST COMBINATION          *
.LOOP1A  AIF   (&I+&K GT &N).LOOP1C         SKIP IF WE'RE AT END
         AIF   ('&STORAGE(&I+&K)'(1,1) NE '*').LOOP1C SKIP IF NOT *
&K       SETA  &K+1                INCREM # CONSECUTIVE * FORMS
         AGO   .LOOP1A             GO CHECK NEXT
.LOOP1C  DS    &K.A .              WORDS WHERE ADDRESSES WILL BE STORED
&I       SETA  &I+&K               INCREMENT
         AGO   .LOOP1G             GO FOR NEXT CHECK
.*             PROCESS ADDRESS CONSTANT TYPE OF OPERAND               *
.LOOP1E  DC    A(&STORAGE(&I))
&I       SETA  &I+1                INCREMENT # OPERANDS DONE
.LOOP1G  AIF   (&I LE &N).LOOP1    CONTINUE IF ANY MORE
.*                                                                    *
.*       CREATE LOAD ADDRESS - STORE PAIRS FOR EXPRESSION ADDRESSES   *
.*                                                                    *
&I       SETA  1
.LOOP2   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP2E    SKIP IF NOT *
&L       SETA  K'&STORAGE(&I)-1    GET # CHARS IN EXPRESSION
&K       SETA  1                   INIT COUNTER
         AIF   (&L LE 40).LOOP2A   SKIP IF SMALL ENOUGH
         MNOTE 8,'**XSNAP- STORAGE(&I) LONGER THAN 40 CHARACTERS'
&L       SETA  40                  TRUNCATE AND HOPE IT GOES
.*       BREAK EXPRESSION INTO 8 CHARACTER SECTIONS.                  *
.LOOP2A  ANOP
&A(&K)   SETC  '&STORAGE(&I)'(8*&K-6,8)      GET UP TO 8 NEXT CHARS
&K       SETA  &K+1                INCRMENT COUNTER
         AIF   (8*&K-8 LT &L).LOOP2A        LOOP UNTIL HAVE WHOLE OPR
         LA    0,&A(1)&A(2)&A(3)&A(4)&A(5)
         ST    0,&NAM.B+4*&I+68    STORE ADDRESS IN LIST
.LOOP2C  ANOP
&K       SETA  &K-1                DECRMENT SECTION TO NULL
&A(&K)   SETC  ''                  NULL FOR NEXT USE
         AIF   (&K GT 2).LOOP2C    CONTINUE UNTIL ALL BUT &A(1) NULL
.LOOP2E  ANOP
&I       SETA  &I+1                INCREMENT POSITION IN LIST
         AIF   (&I LE &N).LOOP2    CONTINUE WITH LIST
.*                                                                    *
.*       CREATE CODE TO SET UP REGISTERS FOR XXXXSNAP,CALL IT,AND     *
.*       RESTORE REGS ON RETURN.  XXXXSNAP RESTORES THE CONDTION CODE.*
.*                                                                    *
.OKN     LA    10,&NAM.B  .        GET ADDRESS OF REGISTER BLOCK
         L     15,68(10) .         GET V(XXXXSNAP) FOR BRANCH
         BALR  14,15 .             CALL XXXXSNAP,POINT 14 AT NEXT INST
         LM    0,15,0(10) .        RELOAD THE REGISTERS
.*             CREATE LABEL FOR IF OPTION, IF IT WAS USED.            *
.XIFLB   AIF   ('&INST' EQ '').XEXIT         SKIP GEN OF IF LABEL
&NAM.C   EQU   * .                 DEFINE LABEL FOR IF= BRANCH
.XEXIT   SPACE 2
.XXEXIT  MEND
         SPACE 2
         MACRO
         XSET &XSNAP=
         GBLB  &XSNAPST            =0 ==> XSNAPS, =1 ==> NONE
.*             SIMPLE XSET, JUST FOR XSNAPS.
&XSNAPST SETB  ('&XSNAP' EQ 'OFF')           1==> NO XSNAPS
         MEND
         TITLE '*** XSRNR - REGISTER LOAD-STORE FOR XRETURN-XSAVE ***'
         MACRO
         XSRNR &OP,&RG,&NO15
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRNR      SAVE/RESTORE REGISTERS FOR XSAVE/XRETURN      *
.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *
.*             THIS MACRO IS USED BY XSAVE AND XRETURN TO SET UP      *
.*       REGISTER SAVING AND RESTORATION.                             *
.*       &OP IS THE OPCODE TO BE USED.  I.E.  EITHER L  OR ST.        *
.*       &RG  IS 1 OPERAND FROM THE &RGS OPERAND USED BY XSAVE AND    *
.*             XRETURN.  IT IS EITHER 1 REGISTER, OR A PAIR OF REGS   *
.*             SEPARATED BY A DASH.                                   *
.*       &NO15   =0  STATES THAT A RETURN CODE IS CURRENTLY IN REG 15 *
.*             AND SHOULD NOT BE DISTURBED, REGARDLESS OF HOW THE REGS*
.*             ARE SPECIFIED.                                         *
.*       USES MACROS: XCHAR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             FOR COMMUNICATION WITH XCHAR
         LCLA  &I
         LCLC  &R1,&R2             1ST REG, 2ND REG, TEMPORARY
         AIF   ('&RG' EQ 'NO').XXEXIT        DON'T GEN ANYTHING
.*             SCAN FOR DASH-MEANING 2 REGISTERS.                     *
.XSL1    ANOP
&I       SETA  &I+1                INCREMENT FOR NEXT CHARACTER
         AIF   ('&RG'(&I,1) EQ '-').XDASH    JUMP IF DASH FOUND
         AIF   (&I LT K'&RG).XSL1  CONTINUE TO END OF OPERAND
&R1      SETC  '&RG'               &RG IS 1 REGISTER BY ITSELF
         AGO   .XSAA               GO TO NEXT DECISION POINT
.*             FOUND DASH-NOW SEPARATE THE REGISTERS.                 *
.XDASH   ANOP
&R1      SETC  '&RG'(1,&I-1)       GET FIRST REGISTER
         AIF   (&I EQ K'&RG).XSAA  DUMB USER - 1 REG FOLLOWED BY -
&R2      SETC  '&RG'(&I+1,K'&RG-&I)         GET 2ND REGISTER
.XSAA    XCHAR &R1,2               GET UP TO LAST 2 CHARS OF 1ST REG
         AIF   ('&XXCHAR' NE '14' AND '&XXCHAR' NE '15').XNO1415
&I       SETA  4*&XXCHAR-44         OFFSET FOR 14 OR 15
         AIF   ('&R2' NE '').XS2RG SKIP IF 2 REGISTERS SPECIFIED
         AIF   ('&XXCHAR' EQ '15' AND '&NO15' EQ '0').XXEXIT
         &OP   &R1,&I.(13)  .       SAVE/RESTORE 1 REG
         MEXIT
.XS2RG   AIF   ('&NO15' EQ '0').XSN15        SKIP IF 15 SHOULDN'T BE
         &OP.M &R1,&R2,&I.(13)  .  SAVE/RESTORE RANGE OF REGS
         MEXIT
.XSN15   AIF   ('&XXCHAR' EQ '15').XSN15A    SKIP IF 15 SPECIFIED
         L     &R1,12(13)  .        RELOAD REG 14
         XCHAR &R2,2                GET 2ND REG
         AIF   ('&XXCHAR' EQ '15').XXEXIT    SKIP IF 15 SPECIFIED
.XSN15A  LM    0,&R2,20(13)  .     RELOAD REST OF REGS
         MEXIT
.*             RESTORE 1 REG OR RANGE (NOT STARTING WITH 14 OR 15).   *
.XNO1415 AIF   ('&R2' NE '').XLMSTM          JUMP IF MULTIPLE REGS
         &OP   &R1,&R1*4+20(13)
         MEXIT
.XLMSTM  &OP.M &R1,&R2,&R1*4+20(13)
.XXEXIT  MEND
         TITLE 'DISK UTILITY I/O DOS/OS MACROS'
         MACRO
&LA      XDKCHK    &P1,&P2,&P3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKCHK                                                    *
.*       THIS MACRO WILL PRODUCE EITHER A DOS CHECK MACRO OR A        *
.*       OS VERSION OF THE CHECK MACRO                                *
.*                                                                    *
.*       &P1 IS THE OS CHECK MACRO PARAMETER                          *
.*       &P2 IS THE DOS CHECK MACRO PARAMETER                         *
.*       &P3   IF 'DOS' AND &$ASMLVL IS DOS GEN DOS CHECK             *
.*             OTHERWISE GEN &$ASMLVL TYPE CHECK                      *
.*       USES INNER MACROS: CHECK (OS OR DOS VERSION)                 *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            OS/DOS LEVEL SWITCH
&LA      DS    0H .                GEN LABEL AND BOUNDRY
         AIF   (&$ASMLVL).XOSGEN   DETERMINE LEVEL
         CHECK &P2 .               GEN DOS CHECK
.XEND    MEXIT                     ALL DONE
.XOSGEN  AIF   ('&P3' EQ 'DOS').XEND   IF NOT DEFAULT QUIT
         CHECK &P1 .               GEN OS TYPE CHECK
         MEND
         SPACE 10
         MACRO
&LA      XDKPT &P1,&P2
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKPT                                                     *
.*       THIS MACRO GENERATES EITHER A DOS POINTS MACRO CALL OR AN    *
.*       OS POINT MACRO CALL                                          *
.*                                                                    *
.*       &P1 IS THE DCB OR DTF NAME                                   *
.*       &P2 IS THE POINT WORD ADDRESS (OS ONLY)                      *
.*                                                                    *
.*       USES INNER MACROS: POINT (OS), POINTS (DOS)                  *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            GLOBAL ASMBLY LEVEL SWITCH
         AIF   (&$ASMLVL).XDKP1    GENERATE CORRECT MACRO VERSION
&LA      POINTS  &P1 .             DOS POINTS MACRO
         MEXIT
.XDKP1   ANOP
&LA      POINT &P1,&P2 .           OS POINT MACRO
         MEND
         SPACE 10
         MACRO
&LA      XDKWT &P1,&P2,&P3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO:XDKWT                                                      *
.*       THIS MACRO WILL GENERATE A CORRECT WRITE MACRO CALL FOR      *
.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *
.*                                                                    *
.*       &P1 IS THE DECB NAME                                         *
.*       &P2 IS THE FILE NAME UNDER DOS GEN AND THE DCB NAME FOR OS   *
.*       &P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF GENERATION        *
.*                                                                    *
.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *
.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *
.*       IS PERFORMED                                                 *
.*                                                                    *
.*       USES INNER MACROS: WRITE (OS FORM OR DOS FORM)               *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL
         AIF (NOT &$ASMLVL).XWT1   GEN CORRECT CALL BY LEVEL SWTCH
&LA      WRITE &P1,SF,&P2,&P3,MF=E .        GENERATE AN OS MACRO CALL
         MEXIT
.XWT1    ANOP
&LA      WRITE &P2,SQ,&P3 .        GENERATE A DOS MACRO CALL
         MEND
         SPACE 10
         MACRO
&LA      XDKRD &P1,&P2,&P3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKRD                                                     *
.*       THIS MACRO WILL GENERATE A CORRECT READ MACRO CALL FOR       *
.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *
.*                                                                    *
.*       &P1 IS THE DECB NAME                                         *
.*       &P2 IS THE DCB ADDRESS FOR OS AND THE FILENAME UNDER DOS     *
.*       &P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF ASSEMBLY          *
.*                                                                    *
.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *
.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *
.*       IS PERFORMED                                                 *
.*                                                                    *
.*       USES INNER MACROS: READ (OS FORM OR DOS FORM)                *
.*                                                                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL
         AIF   (NOT &$ASMLVL).XRE1  GEN CORRECT CALL BY LEVEL SWTCH
&LA      READ &P1,SF,&P2,&P3,MF=E .         GENERATE AN OS MACRO CALL
         MEXIT
.XRE1    ANOP
&LA      READ  &P2,SQ,&P3 .                 GENERATE A DOS MACRO CALL
         MEND
         SPACE 10
         TITLE 'XXDKDECB MACRO DEFINE CONTROL BLOCKS FOR DISK UTILITY'
         MACRO
&LABEL   XXDKDECB   &II
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XXDKEDCB GENERATE TABLE OF DECBS FOR DISK UTILITY        *
.*       THIS MACRO GENERATES A LINKED TABLE OF DECBS.                *
.*       THE BUFFER ADDRESSES ARE PLACED IN THE DECB BY XXXXDKOP      *
.*       USES MACRO: WRITE                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$ASMLVL            LEVEL OF ASSEMBLY SWITCH
         LCLA  &I,&XXLNK           LCL COUNTER AND LINK FACTOR(OS/DOS)
&I       SETA  &II                 INITIALIZE FOR UNIQUE NAMES
         AIF   (&$ASMLVL).OS1      GENERATE CORRECT LINK FACTOR(OS/DOS)
&XXLNK   SETA  8                   DOS LEVEL LINK FACTOR
         AGO   .OS2
.OS1     ANOP
&XXLNK   SETA  24                  OS LEVEL LINK FACTOR
.OS2     ANOP
         SPACE 2
&LABEL   DS    0F .                DEFINE LABEL, ALIGN TO FULLWORD
         AIF   (&I EQ 1).DESTOP    BRANCH IF LAST ENTRY
.DENEXT  DC    A(*+&XXLNK) .       LINK TO NEXT ENTRY
         AIF   (&$ASMLVL).XXDK1    LEVEL DEPENDENT CODE GENERATION
         DC    F'0'                FULLWORD FOR FAKE DECB
         AGO   .XXDK2
.XXDK1   WRITE XXDECB&I,SF,XXDKUDCB,0,MF=L    GENERATE A DECB
.XXDK2   SPACE 2
&I       SETA  &I-1                DECREMENT COUNTER
         AIF   (&I GT 1).DENEXT    LOOP IF NOT LAST ENTRY
.DESTOP  DC    A(&LABEL) .         LAST ENTRY, LINK TO TOP OF TABLE
         AIF   (&$ASMLVL).XXDK3    LEVEL OF ASSEMBLY
         DC    F'0'                FULLWORD FOR FAKE DECB
         AGO   .XXDK4
.XXDK3   WRITE XXDECB&I,SF,XXDKUDCB,0,MF=L    GENERATE A DECB
.XXDK4   SPACE 5
         MEND
         SPACE 3
         MACRO
&L       $DISK &TYPE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DISK     CALL DISK UTILITY                              *
.*       $DISK CALLS MACRO XIONR TO SET UP A BRANCH TO A DISK         *
.*       UTILITY ROUTINE.                                             *
.*       USES MACRO: XIONR                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&L       XIONR XXXXDK&TYPE,0,(0)   CALL DISK UTILITY
         MEND
         TITLE '$ERCGN MACRO - GENERATE COMPLETION CODE BLOCK '
         MACRO
&LABEL   $ERCGN &CODE,&MSSG,&TYPE=SYSTEM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ERCGN     GENERATE COMPLETION CODE BLOCK FOR XXXXSNAP   *
.*       EACH CALL CREATES 1 ENTRY DESCRIBED BY DSECT ERCOMPCD.       *
.*                                                                    *
.*       &CODE     CHARACTER VALUE OF ERROR CODE NUMBER.              *
.*       &MSSG     ERROR MESSAGE TO BE PRINTED                        *
.*       &TYPE     TYPE OF COMPLETION CODE - SYSTEM, ASSIST, OR USER. *
.*                                                                    *
.*       *NOTE* IF &$OPTMS = 0, NO MESSAGE WILL BE GENED, ONLY CODE.  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$OPTMS             MEMORY OPTIMIZATION(0=SMALL)
         LCLA  &I                  FOR LENGTH
         LCLC  &T                  FOR TYPE
&T       SETC  'ERC&TYPE'(1,7)     GET EQU FOR TYPE
&I       SETA  K'&CODE+K'&MSSG-2   GET LENGTH OF TOTAL MESSAGE
         AIF   (&$OPTMS GT 0).ERCA     SKIP IF NOT MINIMAL MEMORY
&I       SETA  K'&CODE-1           GET LENGTH - 1 OF ERROR CODE
&LABEL   DC    AL2(256*&I+&T),C'&CODE'
         AGO   .XXEXIT             QUIT
.ERCA    ANOP
&LABEL   DC    AL2(256*&I+&T),C'&CODE ',C&MSSG
.XXEXIT  MEND
         SPACE 2                                                      S
         MACRO                                                        A
&LABEL   $MSG  &NMBR,&MSG,&FLAG=0                                     A
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $MSG                  USED TO GENERATE LINE IN MSG TABLE *
.*       &NMBR IS MESSAGE #   (3 DIGITS)                              *
.*       &MSG IS QUOTED STRING OF MESSAGE                             *
.*       &FLAG IS FLAG BYTE                                           *
.* GENERATES:(LENGTH-1 OF MSG): #BYTES +3 FOR LENGTH OF MSG           *
.*       (FLAG BYTE): 1 BYTE                                          *
.*       (CHAR FORM OF NMBR): 3 BYTES                                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$OPTMS             MEMORY OPTIMIZATION(0=SMALL)       S
         LCLA  &K                  FOR K'&MSG                         S
         AIF   (&$OPTMS EQ 0).SMALL   SKIP FOR MIMIMAL MEMORY         S
&K       SETA  K'&MSG-2-1+3   MSG-QUOTES-1+LENGTH OF NMBR             S
&LABEL   DC    AL1(&K,&FLAG),CL3'&NMBR',C&MSG                         S
         MEXIT                                                        S
.SMALL   ANOP                                                         S
&LABEL   DC    AL1(2,&FLAG),CL3'&NMBR'                                S
         MEND                                                         S
         TITLE '*** CARD-PUNCH, LINE-PRINT MACROS - $PNCH,$PRNT ***'
         MACRO
&LABEL   $PNCH &XAREA,&XNUM,&OVER
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PNCH      PUNCH A CARD, BRANCH IF RECORD OVERFLOW       *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPNCH WRTUP *
.*       &OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXPNCH,&XNUM,&XAREA,80     HAVE CONTROL BLOCK SET
         AIF   ('&OVER' EQ '').XXEXIT       SKIP IF OVER NOT SPEC
         BL    &OVER   .           BRANCH IF EXCEEEDED RECORD COUNT
.XXEXIT  MEND
         SPACE 4
         MACRO
&LABEL   $PRNT &XAREA,&XNUM,&OVER
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PRNT      PRINT A LINE, BRANCH IF RECORD OVERFLOW.      *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPRNT WRITUP*
.*       &OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXPRNT,&XNUM,&XAREA,133    HAVE BLOCK SETUP
         AIF   ('&OVER' EQ '').XXEXIT       SKIP IF NO LABEL
         BL    &OVER    .          BRANCH IF EXCEEDED RECORDS
.XXEXIT  MEND
         TITLE '*** CARD-READ MACROS - $READ,$SORC ***'
         MACRO
&LABEL   $READ &XAREA,&XNUM,&EOF
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $READ      READ CARD DURING EXECUTION, BRANCH IF EOF.    *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP*
.*       &EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXREAD,&XNUM,&XAREA,80   SET UP CONTROL BLOCK
         AIF   (T'&EOF EQ 'O').XXEXIT       SKIP IF NO LABEL
         BL    &EOF   .            TAKE BRANCH IF END OF FILE
.XXEXIT  MEND
         SPACE 4
         MACRO
&LABEL   $SORC &XAREA,&XNUM,&EOF
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SORC      READ ASSEMBLER SOURCE CARD, BRANCH IF EOF.    *
.*       &XAREA,&XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP*
.*       &EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        *
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   XIONR XXXXSORC,&XNUM,&XAREA,80  SET UP CONTROL BLOCK         *
         AIF   (T'&EOF EQ 'O').XXEXIT       SKIP IF NO LABEL
         BL    &EOF   .            BRANCH IF END-FILE
.XXEXIT  MEND
         TITLE 'SPECIAL XGET AND XPUT MACROES FOR ASSIST'
         MACRO
&XLABEL  $GET  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GET  INTERNAL XGET MACRO FOR ASSIST.                    *
.*                                      RICHARD FOWLER NOV, 1972 V.5.0*
.*       LIKE XGET BUT CONVERTS USER REG1 AND SETS ACTUAL R1 TO       *
.*       ACTUAL ADDRESS.  ALSO CALLS XDDGET.                          *
.*                                                                    *
.*       EXECUTION ASSUMES USER REGISTER POINTS TO DDNAME.            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&XLABEL  L     R1,ECREG1           GET USER @ DDNAME
         AR    R1,RMEM             GET REAL ADDRESS
         XIONR XDDGET,&XNUM,&XAREA,80
.XMEND   MEND
         SPACE 5
         MACRO
&XLEBEL  $PUT  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PUT                                                     *
.*       LIKE $GET, BUT CALLS XDDPUT.                                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&XLEBEL  L     R1,ECREG1           GET USER @ DDNAME
         AR    R1,RMEM             GET REAL ADDRESS
         XIONR XDDPUT,&XNUM,&XAREA,133
.XMEND   MEND
         TITLE 'EXTENDED I/O MACROES XGET AND XPUT'
         MACRO
&XLABEL  XGET  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XGET    GET RECORD OFF OF &DDNAME FILE                   *
.*                                 RICHARD FOWLER AUG, 1972 V.5.0     *
.*       MACRO FOR EASY READING OFF OF ANY DD FILE, READS &XNUM       *
.*       CHARACTERS. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON     *
.*       END OF FILE. GENERATION CONTROLLED BY &XGETST.               *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
         GBLB  &XGETST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XGETST).XNOGEN    IF SHOULDN'T GENERATE-SKIP CALL
&XLABEL  XIONR XXXXGET,&XNUM,&XAREA,80   SET UP CONTROL BLOCK
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XGET
.XXEXIT  MEND
         SPACE 5
         MACRO
&XLABEL  XPUT  &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XPUT           PUT A RECORD ONTO FILE &DDNAME            *
.*                                 RICHARD FOWLER AUG 1972 V.5.0      *
.*       MACRO FOR EASY PRINTING ONTO ANY DD FILE. RECORD LENGTH=&XNUM*
.*       IF PRINT FILE, FIRST CHARACTER IS USED AS CARRIAGE CONTROL   *
.*       GENERATION CONTROLLED BY &XPUST                              *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XPUTST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XPUTST).XNOGEN    IF SHOULDN'T GENERATE, SKIP CALL
&XLABEL  XIONR XXXXPUT,&XNUM,&XAREA,133   SET UP CONTROL BLOCK
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XPUT
.XXEXIT  MEND
         TITLE 'MACRO---XGPSRCH--- INNER MACRO FOR XGPGN MACRO'
         MACRO
        XXGPSRCH &DIREC,&TIME
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XXGPSRCH  INNER MACRO FOR XGPGEN                          *
.*     ARGUMENTS:                                                     *
.*       &DIREC= G--> INPUT                                           *
.*               P--> OUTPUT                                          *
.*       &TIME=1 --> FIRST CALL, SETS UP EXTRA CODE AND ACTS AS &SYSND*
.*             2--> SECOND CALL                                       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         L     R3,X&DIREC.ELEM .   GET # LAST POINTER TO OPEN FILES
         LA    R1,X&DIREC.PNTSRT . GET @ OF FIRST POINTER
         LTR   R3,R3 .             ARE THERE ANY ELEMENTS?
         BE    X&DIREC.MAKE&TIME   NO - GO CREATE ONE
         LA    R2,12 .             SET UP INCREMENT SIZE
X&DIREC.LOOP&TIME CLC 0(8,R1),X&DIREC.CURENT COMPARE DD NAMES
         BE    X&DIREC.CONT&TIME   IF EQUAL, GO TO I/O
         BXLE  R1,R2,X&DIREC.LOOP&TIME EQUAL, SEARCH TILL END OF TABLE
         SPACE 2
         MEND
         TITLE 'MACRO---XGPGEN--- GENERATE GENERAL I/O MODULES'
         MACRO
&LABEL   XGPGEN &DIREC=G,&FETCH=NOT,&DDNUM=20
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XGPGEN  GENERATE GENERAL I/O MODULES                     *
.*                                    RICHARD FOWLER NOV, 1972 V.5.0  *
.*                                                                    *
.*       ARGUMENTS:                                                   *
.*             &DIREC = P --> OUTPUT                                  *
.*                   = P --> INPUT                                   *
.*             &FETCH  =NOT --> NO FETCH PROTECTION                   *
.*                    =PROTECT -->    FETCH PROTECTION                *
.*             &DDNUM = MAXIMUM NUMBER OF DD NAMES ALLOWED AT ONCE    *
.*     (**EACH DD FILE REQUIRES 3F TABLE ENTRY PLUS DCB AND BUFFER**) *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE ' &LABEL - MODULE CREATED BY XGPGEN'
&LABEL   CSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: EXTENDED I/O MODULE FOR GENERAL I/O                       *
*        THIS MODULE IS CALLED TO DO GENERAL I/O WORK ON A FILE       *
*              SIMILAR IN OPERATION TO XIO ROUTINES, BUT CAN HANDLE   *
*              MANY FILES AT ONCE.                                    *
*        ENTRY CONDITIONS:                                            *
*          R14 = @ OF CONTROL BLOCK                                   *
*          R15  = ENTRY POINT ADDRESS                                 *
*          R0  = ADDRESS OF AREA TO MOVE DATA INTO                    *
*          R1  = ADDRESS OF DD NAME TO BE USED                        *
*        CONTROL BLOCK:                                               *
*      OFFSET  LENGTH        WHAT                                     *
*        0       1F        ENTRY POINT ADDRESS                        *
*        4       3F          SAVE AREA                                *
*        16      2           LENGTH OF AREA                           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING *,15 .              NOTE TEMPORARY ADDRESSABILITY
         USING XIOBLOCK,R14
         STM   R13,R7,X&DIREC.SAV1 SAVE REGISTERS TO BE USED          A
         CNOP  0,4 .               GET ON FULLWORD
         BAL   R13,*+76            SET UP FAKE AREA PNTR - BASE
         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER
         DS    18F .               FAKE SAVE AREA
         DROP  R15 .               KILL OLD ADDRESSING
         SPACE 2
         USING IHADCB,R1 .         SET UP ADDRESSIBILITY TO DCB S
         MVC   X&DIREC.CURENT(8),0(R1) . GET CURRENT DD NAME
*   CHECK FOR CLOSE
         SR    R1,R1               GET ZERO LENGTH INDICATOR
         CH    R1,XIOLENG          ARE THEY EQUAL?
         BE    X&DIREC.EOF .       YES-GO CLOSE AND FORGET FILE
         XXGPSRCH &DIREC
*  THE FOLLOWING CODE, IF EXECUTED, GENERATES A DCB AND TRIES AN OPEN
*
X&DIREC.MAKE C R1,=A(X&DIREC.FULL) CHECK FOR TABLE OVERFLOW
         BNL   X&DIREC.CC3         NO SPACE, DON'T TRY OPEN-RETURN    J
         ST    R1,X&DIREC.ELEM .   SAVE NEW ADDRESS, R1 ALREADY POINTIN
         MVC   0(8,R1),X&DIREC.CURENT  SAVE DD NAME FOR FUTURE CALLS
         L     0,X&DIREC.LONG      LOAD R2 WITH LENGTH OF DCB
         GETMAIN R,LV=(0) .        GET SPACE FROM OS
         L     R2,X&DIREC.ELEM .   GET ADDRESS OF POINTER
         ST    R1,8(R2) .          SAVE @ OF DCB
*
         ST    R1,X&DIREC.FULL     KLUDGE TO GET AROUND ADDRESSIBILITY
         MVC   X&DIREC.OPEN+1(3),X&DIREC.FULL+1  COPY OVER DCB @ INTO J
*
         MVC   0(X&DIREC.ELEM-X&DIREC.DCB,R1),X&DIREC.DCB BUILD DCB
         MVC   DCBDDNAM,X&DIREC.CURENT MOVE DD NAME INTO DCB
         OPEN  MF=(E,X&DIREC.DCBPTR)  DO REMOTE OPEN
         L     R1,X&DIREC.FULL .   FIX R1, DESTROYED IN OPEN
         TM    DCBOFLGS,X'10' .    DID OPEN GO?
         BO    X&DIREC.CONT4       YES, DO I/O
*              OPEN DIDN'T GO - CLEAN UP SO DOESN'T BOMB LATER        J
         L     R0,X&DIREC.LONG     GET LENGTH OF DCB FOR FREEMAIN     J
         FREEMAIN R,LV=(0),A=(1)   GIVE THE SPACE BACK TO OS          J
         XC    0(12,R2),0(R2)      CLEAR OUT SO WON'T THINK IT'S OPEN J
X&DIREC.CC3 TM *+1,X'FF'           SET CC=3  ==> OPEN IMPOSSIBLE      J
         B     X&DIREC.RET         RETURN TO USER
         SPACE 2
X&DIREC.CONT L R1,8(R1) .          GET DCB ADDRESS
X&DIREC.CONT4 LH R5,XIOLENG        GET LENGTH OF AREA
         AIF   ('&FETCH' EQ 'PROTECT').SKPFTCH
         L     R2,X&DIREC.SAV1+12  GET @ I/O AREA
* THE FOLLOWING CODE IS USED FOR ADDRESS ILLEGAL     ******************
*****  THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT ***********
         SPACE 2
         L     R4,16 .             GET CVT PNTR FROM LOC 16
         LA    R0,0(R2,R5) .       GET ENDING ADDRESS OF I/O AREA
         C     R0,164(R4) .        COMPARE TO CVTMZ00 - HIGHEST ADDRESS
         BNL   X&DIREC.ABD3 .      GO ABEND IF HIGHER
.SKPFTCH ANOP
         AIF   ('&DIREC' EQ 'P').XOUT  SKIP IF OUTPUT
         LH    R7,DCBLRECL         GET LRECL FROM DCB                 J
         GET   IHADCB .            GET # BUFFER
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK                  J
         LR    R5,R7               TOO BIG, USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGHT JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R2),0(R1) .   GIVE USER 256 BYTES OF DATA
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+10 .              NO - DONT MOVE LEFTOVER BYTES
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
.XCLOSE  ANOP
         SR    R0,R0 .             SET COND CODE TO 0, USER OK
         B     X&DIREC.RET .       GO TO RETURN                       B
X&DIREC.EOF EQU *                  CLOSE IHADCB
         XXGPSRCH &DIREC,2
X&DIREC.MAKE2 B X&DIREC.RET .      GO RETURN
X&DIREC.CONT2 LR R4,R1 .           SAVE THE ADDRESS
         MVC   X&DIREC.PTR+1(3),9(R1)
         LA    R1,X&DIREC.PTR
         CLOSE MF=(E,(1))          DO REMOTE CLOSE
         L     R1,8(R4) .          POINT TO DCB TO FREE
         FREEPOOL (1)              FREE THE BUFFERS
         L     R1,8(R4)            RESET R1 IN CASE DESTROYED
         L     R0,X&DIREC.LONG     GET AMOUNT TO FREE
         FREEMAIN R,LV=(0),A=(1)
*
*   DCB NO LONGER EXISTS,  REMOVE CORRESPONDING ELEMENT FROM LIST
*
         LA    R3,X&DIREC.FULL .    GET UPPER ADDRESS OF TABLE
         SR    R3,R4   .           FIND LENGTH OF REST OF TABLE
         EX    R3,X&DIREC.WIPOUT   WIPE OUT 12 BYTES OF MEMORY
*
*      IF NO POINTERS REMAIN, SET POINTER TO LAST = ZERO
*
         LA    R3,12
         L     R2,X&DIREC.ELEM
         SR    R2,R3
         LA    R1,X&DIREC.PNTSRT
         CR    R1,R2
         BNH   *+8
         LA    R2,0 .              SET POINTER TO ZERO
         ST    R2,X&DIREC.ELEM     SAVE POINTER
         AIF   ('&DIREC' EQ 'P').XRET
         OI    *+1,1 .             SET COND CODE FOR END OF FILE
.*       SHOULD REMOVE DCB FROM LIST NOW
         AGO   .XRET .             HAVE RETURN CODE GENERATED
.*
.XOUT    ANOP
         LH    R7,82(R1) .         GET LRECL
         PUT   IHADCB .            PRINT THE STUFF
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK LENGTH           J
         LR    R5,R7               TOO BIG- USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         LR    R6,R5               SAVE FOR LATER
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R1),0(R2) .   PUT STUFF INTO BUFFER
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+12
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
         AR    R1,R5               GET BEGINNING @ TO BLANK
         SR    R7,R6               GET DIFFERENCE BETWEEN USER AND DCB
         BZ    *+12                NO DIFFERENCE, DO NOTHING          A
         MVI   1(R1),C' '
         EX    R7,X&DIREC.MOV2     CLEAR REST
*  ****NOTE THAT THIS ONLY WORKS FOR DIFFERENCES < 256
         AGO   .XCLOSE
.*
.XRET    ANOP
         SPACE 2
X&DIREC.RET LM R13,R7,X&DIREC.SAV1 RESTORE REGS                       A
         B     XIORETRN            RETURN
         DROP  R14
X&DIREC.ABD3 CLI  *,0              SET CC=2, SHOW EXECUTE ERROR       J
         B     X&DIREC.RET         GO RETURN, SHOWING ERROR           J
.*
         SPACE 2
X&DIREC.PTR CLOSE (X&DIREC.CONT),MF=L    GENERAL PURPOSE CLOSE
X&DIREC.WIPOUT MVC 0(1,R4),12(R4)
X&DIREC.CURENT DS  CL8  .          AREA TO HOLD CURRENT DD NAME
X&DIREC.SAV1 DS 11F                SAVE AREA FOR REGS USED            A
X&DIREC.PNTSRT DS (&DDNUM*3)F .    AREA FOR DDNUM DD NAMES & POINTERS
X&DIREC.FULL DS F
X&DIREC.OPEN DS 0F                 EXTRA LABEL
         AIF   ('&DIREC' EQ 'P').XDEFSR  SKIP IF OUTPUT
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(INPUT)),MF=L  OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=GL,EODAD=X&DIREC.EOF
X&DIREC.ELEM DC  F'0' .            INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R2),0(R1) .    GIVES USER THE DATA
         LTORG
         DROP  R13
         MEXIT                     DONE
.XDEFSR  ANOP
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(OUTPUT)),MF=L OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=PL
X&DIREC.ELEM DC F'0' .             INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R1),0(R2) .    MOVE INTO LINE
X&DIREC.MOV2 MVC 2(1,R1),1(R1)     CLEAR OUT REST OF BUFFER
         LTORG
         DROP  R13
         MEND
         TITLE '***MACRO*** XDDSLOT  GENERATES XGET-XPUT CONTROL TABLE'
         MACRO
&LABEL   XDDSLOT &NAME,&WHICH,&POSIN=0,&POSOUT=0,&PERM=1,&REST1=00,    X
               &REST2=0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XDDSLOT CREATE TABLE ENTRY FOR XGET-XPUT                 *
.*                                    RICHARD FOWLER OCT. 1972. V.5.0 *
.*                                                                    *
.*       THIS MACRO GENERATES AN ELEMENT TO HELP ASSIST KEEP          *
.*             CONTROL OF THINGS WHILE EXECUTING XGET-XPUT.           *
.*             &NAME CHAR STRING OF RESERVED DD NAME                  *
.*             &WHICH  MISSING OR IN ERROR, USER MAY XGET-XPUT IT     *
.*                 =XREAD   USER CAN XREAD ONLY                       *
.*                 =XPRNT   USER CAN XPRNT ONLY                       *
.*                 =XPNCH   USER CAN XPNCH ONLY                       *
.*                                                                    *
.*             &POSIN = 1 CAN INPUT                                   *
.*                    = 0 CANNOT INPUT                                *
.*                                                                    *
.*             &POSOUT = 1 CAN OUTPUT                                 *
.*                     = 0 CANNOT OUTPUT                              *
.*             &PERM = 1 ON REENTERING, &NAME WILL STILL EXIST        *
.*                   =0  &NAME WILL NOT EXIST ON REENTERING           *
.*                                                                    *
.*             &REST 1,2  NOT USED                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&NAME EQ 'O').DDEMPTY   CREATE AN EMPTY SLOT
&LABEL   DC    CL8'&NAME' .        NO, SHOVE IN DDNAME
.*             SET BITS, NOTE NOT CURRENTLY OPEN
         DC    B'00&REST1&POSOUT&POSIN&REST2&PERM'
         AIF   (T'&WHICH NE 'O').DDSK1      WAS &WHICH OMITTED
.DDSK4   DC    XL1'00' .           YES ASSUME XGET-XPUT
         MEXIT
.DDSK1   AIF   ('&WHICH' NE 'XREAD').DDSK2   READ ONLY?
         DC    XL1'04' .           YES,  FIX INDEX
         MEXIT
.DDSK2   AIF   ('&WHICH' NE 'XPRNT').DDSK3  DO WRITES ONLY?
         DC    XL1'08' .           YES,   FIX INDEX
         MEXIT
.DDSK3   AIF   ('&WHICH' NE 'XPNCH').DDSK4 IF INVALID, ASSUM XGET-XPUT
         DC    XL1'0C' .           VALID,  SET INDEX
         MEXIT
.DDEMPTY ANOP
&LABEL   DC    CL8' ' .            BLANK DDNAME
         DC    XL2'0C00' .         BLANK EVERYTHING, XGET-XPUT ALLOWED
         MEND
         TITLE '*** LINKAGE MACROS - $CALL,$RETURN,$SAVE ***'
         MACRO
&LABEL   $CALL &ENTRY
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $CALL      SUBROUTINE CALL INSIDE ASSIST ASSEMBLER.      *
.*       &ENTRY    ENTRY POINT NAME TO BE CALLED, OS LINKAGE.         *
.*       **NOTE** GENERATES NAME WITH AX PREFIX, SO CAN ONLY BE USED  *
.*       INSIDE ASSEMBLER WHERE AVWXTABL USING HOLDS.                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     REP,AX&ENTRY .      GET ADCON FROM THE TABLE
         BALR  RET,REP .           CALL THE DESIRED ROUTINE
         MEND
         SPACE 2
         MACRO
&LABEL   $RETURN &RGS=NO,&SA=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $RETURN    RETURN FROM SUBROUTINE, OS LINKAGE.           *
.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XRETURN.    *
.*       USES MACROS: XRETURN                                         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO
&LABEL   XRETURN RGS=&RGS,SA=&SA,TR=&TRACE
         MEND
         SPACE 2
         MACRO
&LABEL   $SAVE &RGS=NO,&BR=15,&SA=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SAVE      SUBROUTINE ENTRY SETUP, OS LINKAGE.           *
.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XSAVE MACRO.*
.*       USES MACROS: XSAVE                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &TRACE,&ID          TRACE FORM, IDENT
&LABEL   XSAVE RGS=&RGS,BR=&BR,SA=&SA,TR=&TRACE,ID=&ID
         MEND
         SPACE 2
         MACRO
         $DBG  &D,&T
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DBG       SET TRACE, DEBUGGING SET VARIABLES FOR ASM.   *
.*       &D        HEX FLAG BYTE FOR USE IN TM INSTRUCTION.           *
.*       &T        IS TRACE MODE FOR AN XSNAP = NO,*,SNAP.            *
.*       SEE MACROS $RETURN,$SAVE,XSRTR FOR GENERATION OF TRACE CODE  *
.*       ON ROUTINE ENTRY/EXIT. SEE ALSO ASSIST PROGRAM LOGIC MANUAL. *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &DEBUG,&TRACE       DEBUG FLAG BYTE,TRACE MODE
         AIF   ('&D' EQ '').D1     SKIP IF OMITTED,DON'T CHANGE
&DEBUG   SETC  'X''&D'''           SET FLAG BYTE FOR MASK
.D1      AIF   ('&T' EQ '').D2     SKIP IF NOTRACE,DON'T CHANGE
&TRACE   SETC  '&T'                SET UP TRACE MODE,IF ANY
.D2      MEND
         TITLE '*** $AL2 MACRO - CREATE AL2 JUMP INDEX CONSTANTS ***'
         MACRO
&LABEL   $AL2  &BASE,&LIST,&OFSET,&L
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $AL2       CREATE HALFWORD ADDRESS OFFSET TABLE.         *
.*       USED TO GENERATE LIST OF AL2 ADDRESS CONSTANTS WHICH         *
.*       CONTAIN THE RELATIVE ADDRESS OF EACH ITEM IN &LIST FROM &BASE*
.*       &OFSET GIVES A NUMBER TO BE ADDED OR SUBTRACTED WHEN SETTING *
.*       UP THE EQU FOR THE LABEL,SO THAT INDEXING MAY START ANYWHERE *
.*       &L IS CODED IF THE OFFSET LIST SHOULD BE PRECEDED BY LENGTH  *
.*       SET UP FOR BXLE .                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I                  LOCAL COUNTER
         DS    0H                  ALIGN
         AIF   (T'&LABEL EQ 'O').XCHKL       SKIP IF NO LABEL
&LABEL   EQU   *&OFSET
.XCHKL   AIF   (T'&L EQ 'O').XNOFS1          SKIP IF LENGTH OMITTED
&I       SETA  N'&LIST*2-2         SET UP FOR BXLE-# OF OPS
         DC    H'&I'
&I       SETA  0                   RESET COUNTER
.XNOFS1  ANOP
&I       SETA  &I+1
         DC    AL2(&LIST(&I)-&BASE)
         AIF   (&I LT N'&LIST).XNOFS1        KEEP LOOPING UNTIL DONE
         MEND
         TITLE '*** $SPIE - EXTENDED INTERRUPT COMMUNICATIONS ***'
         MACRO
&LABEL   $SPIE &EXIT,&TYPES,&CE=0,&ACTION=INIT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SPIE        INTERRUPT COMMUNICATIONS                    *
.*                                 SCOTT A. SMITH - FALL 1971.        *
.*       MAY BE USED BY OS OR DOS SYSTEMS TO SPECIFY THE ADDRESS      *
.*       OF AN INTERRUPTION EXIT ROUTINE AND TO SPECIFY THE PROGRAM   *
.*       INTERRUPT TYPES THAT ARE TO CAUSE THE EXIT ROUTINE TO BE     *
.*       GIVEN CONTROL.                                               *
.*       &EXIT     LABEL TO BE BRANCHED TO FOR THE INTERRUPTION       *
.*                 EXIT.  ADDRESS MAY BE IN A REGISTER.               *
.*       &TYPES    A LIST OF INTERRUPTION TYPES TO CATCH.  IF THIS    *
.*                 IS NOT SPECIFIED, A DEFAULT VALUE OF  ((1,15))     *
.*                 IS ASSUMED.  THE FORM OF THIS OPERAND IS A LIST    *
.*                 OF OPERANDS SEPARATED BY COMMAS.  THE LIST ITSELF  *
.*                 IS ENCLOSED IN PARENTHESES WITH EACH OPERAND       *
.*                 SPECIFYING A GROUP OF INTERRUPT TYPES TO CATCH.    *
.*                 EACH OF THESE IS EITHER A SINGLE INTEGER BETWEEN   *
.*                 1 AND 15, OR A PAIR OF INTEGERS BETWEEN 1 & 15     *
.*                 REPRESENTING AN INCLUSIVE RANGE OF INTERRUPTS.     *
.*                 EACH PAIR IS ENCLOSED IN PARENTHESES.              *
.*       &ACTION=  SPECIFIES THE ACTION THIS MACRO IS TO TAKE.        *
.*             -->INIT: IDENTIFIES THIS AS AN INITIAL $SPIE CALL      *
.*                 AND INITIALIZATION IS TO BE PERFORMED.             *
.*             -->CR: CREATE A NEW $SPIE COMMUNICATION, BUT DO        *
.*                 NOT REINITIALIZE.                                  *
.*             -->(RS,(REG)) RESTORE A PREVIOUS $SPIE COMMUNICATION   *
.*                 LINK USING THE XSPIEBLK AT THE ADDRESS IN THE      *
.*                 REGISTER.  ALL OTHER PARAMETERS ARE IGNORED        *
.*            ***DEFAULT***INIT                                       *
.*       &CE=      THIS SPECIFIES AN OPTIONAL CALLABLE EXIT WHICH     *
.*                 MAY RECEIVE TEMPORARY CONTROL IMMEDIATELY FOLLOW-  *
.*                 ING AN INTERRUPT.  THIS EXIT MUST RETURN.          *
.*       *REGISTERS 14,15,0,1 ARE DESTROYED BY THIS MACRO*            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&PTRVAL,&ENDVAL
         LCLB  &BIT(15),&J,&K
         LCLC  &STR,&PTR,&END,&NAME
         SPACE 1 .                 SEPARATE FROM MAIN LINE CODE
         AIF   ('&LABEL' EQ '').NOLAB  DO NOT GENERATE A LABEL IF NONE
&LABEL   DS    0H .                GENERATE USER LABEL
.NOLAB   AIF   ('&ACTION(1)' NE 'INIT').NOINT   NO INITIALIZATION
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       PERFORM CALL TO XXXXSPIN FOR INITIALIZATION                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.INITIAL CNOP  0,4 .               ALIGNMENT FOR ADCON
         BAL   R14,*+8 .           SKIP AROUND ADCON FOR XXXXSPIN
         DC    V(XXXXSPIN) .       INITIALIZATION ADCON
         L     R15,0(R14) .        LOAD INITIALIZATION ROUTINE ADDRESS
         BALR  R14,R15 .           GO INITIALIZE, RETURN FOR XXXXSPIE
         AGO   .CREATE             SKIP ACTION CHECK, ALREADY KNOW
.NOINT   AIF   ('&ACTION(1)' EQ 'RS').RSTR    RESTORE OLD XSPIEBLK
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       INITIALIZE A BIT STRING TO REPRESENT THE INTERRUPT TYPES     *
.*       TO CATCH FOR THIS PARTICULAR $SPIE                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.CREATE  AIF   ('&TYPES' NE '').LIST   IF OMMITED, GET ALL INTERRUPTS
&PTRVAL  SETA  1                   SET POINTER TO START AT SOC #1
&ENDVAL  SETA  15                  FLAG ALL INTERRUPTS UP TO SOC #15
         AGO   .NEXT               MAKE APPROPRIATE BIT MARKS
.LIST    ANOP
&I       SETA  1                   START SCAN OF TYPES FIELD AT LOC9 1
.TOP     AIF   ('&TYPES(&I)' EQ ' ').SKIP   TO SKIP EMBEDDED BLANKS
&STR     SETC  '&TYPES(&I)'        SAVE NEXT CHAR IN TYPES STRING
         AIF   ('&STR'(1,1) NE '(').SINGLE   FOR NON-PAIRS OF TYPES
&PTR     SETC  '&STR'(2,1)         ASSUME ONE DIGIT LONG
         AIF   ('&STR'(3,1) EQ ',').OKLOOK   IT WAS ONE DIGIT, GET #2OP
&PTR     SETC  '&STR'(2,2)         FIRST TYPE: 2 DIGITS LONG
&END     SETC  '&STR'(5,2)         SHOULD BE LEN=2; IF NOT, CAUGHT LATR
         AGO   .SETOK              HAVE CHAR STRINGS OF TWO TYPE LIMITS
.OKLOOK  ANOP                      FIND TYPE LIM #2 DIGIT LENGTH
&END     SETC  '&STR'(4,1)         ASSUME OF LENGTH 1, SINCE FIRST WAS
         AIF   ('&STR'(5,1) EQ ')').SETOK   IT IS OF LENGTH 1, SO IS OK
&END     SETC  '&STR'(4,2)         SECOND LIMIT IS A 2 DIGIT #
.SETOK   ANOP
&PTRVAL  SETA  &PTR                GET INTEGER VALUE FOR BIT MARKING
&ENDVAL  SETA  &END                INTEGER ENDING VALUE
         AIF   (&PTRVAL GT &ENDVAL OR &PTRVAL LT 1 OR &ENDVAL GT 15).ER
.NEXT    ANOP                      LOOP TO SET UP BIT MARKERS FOR TYPES
&BIT(&PTRVAL)  SETB  1             MARK THIS INTERRUPT TO BE CAUGHT
         AIF   (&PTRVAL EQ &ENDVAL).SKIP   ALL DONE, SEE IF MORE INTRPS
&PTRVAL  SETA  &PTRVAL+1           FLAG NEXT INTERRUPT TYPE TO CATCH
         AGO   .NEXT               MARK IT IN BIT FLAG FIELD
.SINGLE  AIF   (&TYPES(&I) LT 1 OR &TYPES(&I) GT 15).ER  OUT OF RANGE
&BIT(&STR)     SETB  1             CATCH THIS INTERRUPT TYPE (BIT MARK)
.SKIP    ANOP                      GET NEXT OPERAND FROM &CATCH
&I       SETA  &I+1                UP SCAN POINTER TO NEXT LOC.
         AIF   (&I LE N'&TYPES).TOP    GET NEXT MASK SPEC., IF IT EXIST
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       WE HAVE THE BIT STRING INITIALIZED, NOW WE MUST BUILD UP     *
.*       THE NEW XSPIEBLK FOR NEW INTERRUPTS AND EXIT ADDRESSES.      *
.*       DETERMINE THE PRESENCE & NATURE OF INTERRUPT EXIT ROUTINE    *
.*       ADDRESS AND THE CALLABLE EXIT ADDRESS, AND PUT IN XSPIEBLK   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         CNOP  2,4 .               ALIGNMENT FOR ADCONS
         LA    R1,*+18 .           ADDRESS FOR BRANCH AROUND XSPIEBLK
         BALR  R1,R1 .             BR AROUND BLK; R1 <= @ XSPIEBLK
         AIF   ('&EXIT' EQ '').NOEXIT  NO EXIT RTN @ SUPPLIED
         AIF   ('&EXIT'(1,1) EQ '(').INREG  EXIT RTN @ IS IN A REGISTER
         DC    AL4(&EXIT) .        # OF EXIT RTN
.CONT    AIF   ('&CE'(1,1) EQ '(').CEREG    @ IS IN A REGISTER
         DC    AL4(&CE) .          CALLABLE EXIT ROUTINE ADDRESS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       EXPAND BIT PATTERN FOR INTERRUPT TYPES TO CATCH.  EXPANDED   *
.*       TO A FULLWORD FOR EASIER MANIPULATION                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.INT     DC    B'0&BIT(1)&BIT(2)&BIT(3)&BIT(4)&BIT(5)&BIT(6)&BIT(7)&BITX
               (8)&BIT(9)&BIT(10)&BIT(11)&BIT(12)&BIT(13)&BIT(14)&BIT(1X
               5)',BL2'0' .    BIT PATTERN WITH PADDED ZEROS
         AIF   (NOT &J).KEF        SKIP IF &EXIT NOT IN REGISTER
         ST    &EXIT(1),0(0,R1) .  STORE REG VALUE FOR &EXIT @
.KEF     AIF   ('&CE'(1,1) NE '(').XSPYCAL .    SKIP IF &CE NOT IN REG.
         ST    &CE(1),4(0,R1) .    STORE CALLABLE EXIT @ IN XSPIEBLK
         AGO   .XSPYCAL            GO FOR A CALL TO XXXXSPIE TO CHNG PT
.INREG   ANOP                      &EXIT IS IN A REGISTER
&J       SETB  1                   FLAG THIS CONDITION SO WE STORE @
.NOEXIT  DC    AL4(0) .            SET ASIDE LOCATION FOR EXIT @
         AGO   .CONT               SEE ABOUT SECOND ADDRESS
.CEREG   DC    AL4(0) .            @ FOR RESERVING LOC. FOR CALLABLE EX
         AGO   .INT                GENERATE BIT PATTERN FOR INTERRUPTS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       HERE WE ARE INTERESTED IN RESTORING AN OLD XSPIEBLK.  GET    *
.*       XSPIEBLK ADDRESS IN R1.                                      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.RSTR    ANOP
&PTR     SETC  '&ACTION(2)'        GET SECOND ARGUMENT: REG. IN PARENS
&END     SETC  '&PTR'(2,1)         ASSUME ONLY A ONE DIGIT NUMBER
&I       SETA  &END                CONVERT CHARACTER # TO ACTUAL #
         AIF   ('&PTR'(3,1) EQ ')').CHKR1  ASSUMPTION WAS RIGHT
&END     SETC  '&PTR'(2,2)         GET THE TWO DIGIT NUMBER
&I       SETA  &END                CONVERT CHARACTER # TO ACTUAL #
.CHKR1   AIF   (&I EQ 1).XSPYCAL   DON'T DO A :  LR 1,1
         LR    R1,&I .             GET @ OF OLD XSPIEBLK IN REG #1
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       PREPARE CALL TO XXXXSPIE AND THEN CALL IT.  R1 SHOULD BE     *
.*       POINTING TO THE NEW (OR OLD, IN CASE OF ACTION=(RS)) SPYBLK  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.XSPYCAL CNOP  0,4 .               ALIGNMENT FOR UPCOMING ADCON
         B     *+8 .               SKIP AROUND XXXXSPIE ADCON
         DC    V(XXXXSPIE) .       ENTRY POINT @ FOR ACTION EXECUTION
         L     R15,*-4 .           R15 <- @ OF XXXXSPIE FOR CALL
         BALR  R14,R15 .           CHANGE XSPIEBLK POINTERS--RETURN OL@
         AGO   .XXIT               RETURN
.ER      MNOTE 4,'**ERROR--INVALID SEQUENCE OF INTERRUPT TYPES--$SPIE CX
               ANCELLED'
.XXIT    SPACE 1
         MEND
         TITLE '*** XSRTR-XSAVE/XRETURN TRACE-ASSIST VERSION ***'
         MACRO
         XSRTR &TR,&LABEL,&MSG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRTR      CREATE SPECIAL ASSIST ENTRY/EXIT TRACE CODE.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO IS USED BY XSAVE AND XRETURN TO GENERATE THE      *
.*       TRACE CODE CALLS TO XPRNT OR XSNAP, IF THE TR OPERAND IS USED*
.*       *NOTE* THIS IS MODIFIED VERSION FOR USE IN ASSIST ONLY.      *
.*       USES MACROS: XSNAP                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XSNAPST            XSNAP STATUS;0==>ON,1==>OFF
         GBLB  &$DEBUG             DEBUG MODE FLAG,0==>YES,1==>NO
         GBLC  &DEBUG              DEBUG FLAG BITS FOR TESTING
         LCLB  &XSTSAV             FOR SAVING STATUS VARIABLES
         LCLC  &NAME               FOR EITHER LABEL OR CSECT
         LCLC  &T                  FOR TYPE
         AIF   (&$DEBUG).XXEXIT    SKIP WHOLE THING IF NO DEBUG
&NAME    SETC  '&LABEL'            ASSUME NAME IS LABEL
         AIF   (T'&LABEL NE 'O').XNOK1       SKIP IF LABEL EXISTS
&NAME    SETC  '&SYSECT'           USE CSECT NAME INSTEAD
         AIF   ('&SYSECT' NE '').XNOK1       SKIP IF CSECT NOT PC
&NAME    SETC  '$PRIVATE'          USE NAME FOR PRIVATE CODE (PC)
.XNOK1   ANOP
&XSTSAV  SETB  (&XSNAPST)          SAVE XSNAP STATUS, IN CASE OFF
&XSNAPST SETB  (0)                 MAKE SURE XSNAP WILL GENERATE
*        XSNAP LABEL='  MESSAGE '
&T       SETC  'PR'                FOR NORMAL PRINTING OF REGS
         AIF   ('&TR(1)' NE '*').XDFTB       SKIP AND PRINT REGS
&T       SETC  'NO'                DO NOT PRINT REGISTERS
.XDFTB   XSNAP LABEL='*** &NAME &MSG ***',T=&T,IF=(AVDEBUG,O,&DEBUG,TM)
&XSNAPST SETB  (&XSTSAV)           RESTORE STATUS,IN CASE IT WAS OFF
.XXEXIT  MEND
         TITLE '*** ALIGN LOCATION COUNTER MACROS - $ALIGN,$ALIGR ***'
         MACRO
&LABEL   $ALIGN &R,&A,&TAG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALIGN     GET,ALIGN, RESTORE UPDATED LOCATION COUNTER.  *
.*       USED TO ALIGN LOCATION COUNTER TO H, F, OR D BOUNDARIES.     *
.*       &R WILL CONTAIN ALIGNED VALUE OF LOCATION COUNTER            *
.*       &A GIVES ALIGNMENT REQUIRED , IF IN PARENTHESES, GIVES REG,  *
.*       IF NOT, GIVES DECIMAL NUMBER 1-3-7 FOR H,F,D ALIGN           *
.*       &TAG  IF CODED-MEANS THAT LOCATION COUNTER IS ALREADY IN &R. *
.*       USES MACROS: $ALIGR,$GLOC,$SLOC                              *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&TAG EQ 'O').XNORM         NORMAL USE
         AIF   (T'&LABEL EQ 'O').XC          SKIP IF NOT NEEDED
&LABEL   DS    0H
         AGO   .XC                 SKIP TO DECIDE
.XNORM   ANOP
&LABEL   $GLOC &R .                GET THE LOCATION COUNTER
.XC      AIF   ('&A'(1,1) EQ '(').XREG       SKIP IF REGISTER FORM
         LA    &R,&A.(&R) .        INCREMENT THE LOCATION COUNTER
         O     &R,AWF&A .          MAKE LAST BITS ALL 1'S
         S     &R,AWF&A .          SUBTRACT,GETTING RIGHT ALIGNMENT
         AGO   .XST                GO STORE IT BACK
.XREG    $ALIGR &R,&A
.XST     $SLOC &R .                STORE LOCATION COUNTER BACK
         MEND
         SPACE 2
         MACRO
&LABEL   $ALIGR &R,&A
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALIGR     ALIGN VALUE IN REGISTER (USUALLY LOCCNTR).    *
.*        ALIGN REGISTER MACRO-ALIGN REGISTER &R TO BOUNDARY GIVEN    *
.*       BY VALUE IN REG &A, WHICH HAS 1,3,7 ETC IN IT.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   AR    &R,&A .             ADD LENGTH-1 TO LOCATION COUNTER
         OR    &R,&A .             MAKE LAST 1-3 BITS ALL 1'S
         SR    &R,&A .             ALIGN VALUE APPROPRIATELY
         MEND
         TITLE '*** MISC LOC-COUNTER MACROS-$CKALN,$GLOC,$SLOC ***'
         MACRO
&LABEL   $CKALN &MASK,&B
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $CKALN     CHECK LOC-COUNTER ALIGNMENT, BRANCH IF OK.    *
.*       USED TO CHECK ALIGNMENT - &MASK IS 1-3-7, &B IS BRANCH LOC   *
.*       IF LOCATION COUNTER IS PROPERLY ALIGNED.                     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   TM    AVLOCNTR+3,&MASK .  CHECK FOR RIGHT ALIGNMENT
         BZ    &B .                TAKE BRANCH IF WAS ALIGNED
         MEND
         SPACE 2
         MACRO
&LABEL   $GLOC &RG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GLOC      GET LOCATION COUNTER INTO REGISTER.           *
.*       GET LOCATION COUNTER MACRO-PUTS LOCCNTR VALUE IN &RG         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &RG,AVLOCNTR        GET LOCATION COUNTER
         MEND
         SPACE 2
         MACRO
&LABEL   $SLOC &RG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SLOC      SET LOCATION COUNTER TO REGISTER VALUE.       *
.*       SET LOCATION COUNTER MACRO - SETS &RG AS LOCCNTR VALUE       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   ST    &RG,AVLOCNTR        SET LOCATION COUNTER
         MEND
         TITLE '*** SCAN POINTER MACROS - $SCOF, $SCPT ***'
         MACRO
&LABEL   $SCOF &RG,&SCP,&BYTE,&AD=AVRSBPT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SCOF      CONVERT REGISTER SCAN POINTER TO OFFSET VALUE.*
.*       SCAN POINTER OFFSET MACRO - PLACE SCAN POINTER REGISTER &SCP *
.*       INTO WORK REGISTER &RG. FIND OFFSET, AND STORE IT INTO &BYTE *
.*       IF &BYTE SPECIFIED.  &AD= WORD GIVING BEGINNING @ FOR OFFSET.*
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   LR    &RG,&SCP .          MOVE SCAN POINTER ADDRESS OVER
         S     &RG,&AD .           SUBTRACT STARTING ADDR
         AIF   (T'&BYTE EQ 'O').XEXIT        SKIP IF NO STORE WANTED
         STC   &RG,&BYTE .         SAVE OFFSET INTO BYTE
.XEXIT   MEND
         SPACE 2
         MACRO
&LABEL   $SCPT &RG,&BYTE,&AD=AVRSBPT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SCPT      CONVERT OFFSET TO A SCAN POINTER @ INTO REG.  *
.*       GET SCAN POINTER ADDRESS FROM OFFSET-OFFSET IS IN &BYTE,ADDR *
.*       IS CREATED IN &RG.  &AD GIVES BEGINNING @ OF FIELD.          *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   SR    &RG,&RG .           CLEAR FOR INSERTION
         IC    &RG,&BYTE .         GET THE OFFSET VALUE
         A     &RG,&AD .           ADD START ADDR TO GET REAL ADDR
         MEND
         TITLE '*** STORAGE ALLOCATION MACROS - $ALLOCH,$ALLOCL ***'
         MACRO
&LABEL   $ALLOCH &R,&L,&OVRFL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALLOCH    GET CORE IN FREEAREA HIGH END (ASSEMLBER).    *
.*       &R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  *
.*       &L  GIVES REGISTER CONTAINING THE LENGTH DESIRED             *
.*       &OVRFL IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVADDHIH .       GET CURRENT HIGH END POINTER
         SR    &R,&L .             GET NEW HIGH END POINTER
         C     &R,AVADDLOW .       MAKE SURE NO OVERFLOW
         BL    &OVRFL .            TAKE BRANCH IF OVERFLOW
         ST    &R,AVADDHIH .       RESTORE UPDATED POINTER
         MEND
         SPACE 2
         MACRO
&LABEL   $ALLOCL &R,&L,&OVRFL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALLOCL    GET CORE IN LOW FREEAREA (IN ASSEMBLER).      *
.*       &R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  *
.*       &L  GIVES REGISTER CONTAINING THE LENGTH DESIRED.            *
.*       &OVRFL  IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVADDLOW .       LOAD CURRENT LOW END POINTER
         AR    &R,&L .             ADD REQUESTED LENGTH TO POINTER
         C     &R,AVADDHIH .       MAKE SURE NO OVERFLOW
         BH    &OVRFL .            TAKE BRANCH IF OVERFLOW
         ST    &R,AVADDLOW .       REPLACE UPDATED POINTER
         SR    &R,&L .             RESTORE POINTER
         MEND
         TITLE '*** STORAGE ALLOCATION MACROS - $MALLOCL,$MALLOCH ***'
         MACRO
&LABEL   $MALLOCL  &R,&L,&OVRFL=MXPNDOVR,&LENG=                       S
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->  MACRO:  &MALLOCL    GET CORE IN LOW FREEAREA.  SAME AS &ALLOCL *
.*        EXCEPT USES AVGEN2CD AS POINTER TO FREE HIGH AREA.  USED IN *
.*        MEXPND                                                      *
.*                                                                    *
.*     &R  GIVES REGISTER WHERE ADDRESS OF NEW USEABLE AREA APPEARS   *
.*     &L  GIVES REGISTER CONTAINING LENGTH DESIRED                   *
.*     &OVRFL IS @ TO BE BRANCHED TO IF OVERFLOW                      *
.*     &LENG IS THE LENGTH TO BE ALLOCATED                            *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   DS    0H                  DEFINE LABEL                       S
         AIF   ('&LENG' EQ '').X                                      S
         LA    &L,&LENG            LOAD LENGTH TO ALLOCATE            S
.X       L     &R,AVADDLOW         LOAD CURRENT LOW END PTR           S
         AR    &R,&L               ADD REQUESTED LENGTH
         C     &R,AVGEN2CD         MAKE SURE NO OVERFLOW
         BH    &OVRFL              BRANCH IF OVERFLOW
         ST    &R,AVADDLOW         REPLACE UPDATED POINTER
         SR    &R,&L               RESTORE POINTER
         MEND
         SPACE 2
         MACRO
&LABEL   $MALLOCH  &R,&L,&OVRFL=MXPNDOVR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->  MACRO:  &MALLOCH   GET CORE IN HIGH FREEAREA.  SAME AS &ALLOCH *
.*        EXCEPT USES AVGEN2CD AS HIGH END POINTER.  USED IN MEXPND   *
.*     &R  IS REG NEW USEABLE @ APPEARS IN                            *
.*     &L  GIVES REGISTER DESIRED LENGTH IS IN                        *
.*     &OVRFL  IS BRANCH @ IF OVERFLOW OCCURS                         *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVGEN2CD         LOAD CURRENT HIGH END POINTER
         SR    &R,&L               GET NEW HIGH END POINTER
         C     &R,AVADDLOW         MAKE SURE NO OVERFLOW
         BL    &OVRFL              BRANCH IF OVERFLOW
         ST    &R,AVGEN2CD         RESTORE UPDATED POINTER
         MEND
         TITLE '*** STORAGE DEALLOCATION MACRO - $DALLOCH ***'
         MACRO
&LABEL   $DALLOCH &R,&L
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DALLOCH   RETURN CORE-HIGH FREEAREA (IN ASSEMBLER)      *
.*       &R IS A WORK REGISTER, WHICH WILL BE DESTROYED               *
.*       &L REPRESENTS THE LENGTH. IF 1ST CHAR IS '(', WILL BE        *
.*       TAKEN AS REGISTER CONTAINING THE LENGTH, OTHER WISE TO       *
.*       BE AN ACTUAL LENGTH TO BE ADDED.                             *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &R,AVADDHIH .       GET CURRENT HIGH END POINTER
         AIF   ('&L'(1,1) NE '(').XLENG      IF NOT REG FORM,SKIP
         AR    &R,&L .             ADD THE LENGTH BACK
         AGO   .XST                GO RESTORE
.XLENG   LA    &R,&L.(&R) .        INCREMENT REGISTER
.XST     ST    &R,AVADDHIH .       RESTORE UPDATED POINTER
         MEND
         TITLE '*** ASSEMBLER SYMBOL DEFINIITON MACRO - $SDEF ***'
         MACRO
&LABEL   $SDEF &RVAL,&RESD,&RLENG
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SDEF      STORE VALUES IN SYMBOL TABLE ENTRY, FLAG DEFN.*
.*       &RVAL     REGISTER CONTAINING SYMBOL VALUE.                  *
.*       &RESD     REGISTER CONTAINING SECTION ID OF SYMBOL.          *
.*       &RLENG    REGISTER CONTAINING LENGTH ATTRIBUTE-1 FOR SYMBOL. *
.*       *NOTE* SYMSECT DSECT MUST HAVE VALID USING AT TIME OF CALL.  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   ST    &RVAL,SYVALUE .     DEFINE VALUE
         STC   &RESD,SYESDID .     NOTE ESDID OF SYMBOL
         STC   &RLENG,SYLENG .     NOTE LENGTH ATTRIBUTE
         OI    SYFLAGS,$SYDEF .    NOTE SYMBOL NOW DEFINED
         MEND
         TITLE '*** $SERR - SET ERROR CODE EQUS AND MESSAGES'
         MACRO
&ERR     $SERR &MSG,&NM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SERR      SET ERROR CODE MESSAGES AND EQU SYMBOLS.      *
.*       CALLED 2 TIMES FOR EACH ERROR EQU, 1 TIME TO SET UP EQU, 1   *
.*       TIME TO CREATE ERROR MESSAGE DC'S IN CSECT OUTPUT OF ASMBLER.*
.*       &ERR      IS LAST 5 CHARACTERS OF ERROR MESSAGE EQU SYMBOL.  *
.*       &MSG      IS THE ERROR MESSAGE ASSOCIATED WITH THE EQU.      *
.*       &NM       IS THE ERROR CODE FOR EXTERNAL USE - AS###.        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$ERNUM,&$ERFA      # ERRORS, ADDRESS OFFSET VALUE
         GBLA  &$OPTMS             MEMORY OPTIMIZATION
         LCLA  &I                  LOCAL COUNTER
         AIF   ('&SYSECT' EQ 'OUTPUT').SGEN GO TO GEN IF IN OUTPUT
.*             GENERATE THE EQU                                       *
&$ERNUM  SETA  &$ERNUM+2           INCREMENT # ERRORS, EQU VALUE
$ER&ERR  EQU   &$ERNUM
         MEXIT
.SGEN    AIF   (&$OPTMS GT 2).SGEN1    SKIP UNLESS VERY SMALL SYSTEM
.*             SMALL MEMORY - GEN JUST ERROR #, DON'T USE POINTERS
.*             OR LENGTHS, SINCE LENGTHS WILL BE CONSTANT = 3.
         DC    C'&NM'
         AGO   .XXEXIT
.*             GENERATE POINTER TO LENGTH-1 AND ERROR MESSAGE         *
.SGEN1   ORG   OUERRPT+$ER&ERR
         DC    H'&$ERFA'
         ORG
&I       SETA  K'&MSG+K'&NM-2      LENGTH-1 OF ERROR MESSAGE
.SENORM  DC    AL1(&I),C'&NM ',C&MSG
&$ERFA   SETA  &$ERFA+&I+2         INCREMENT THE OFFSET POINTER
.XXEXIT  MEND
         TITLE '*** $SETRT MACRO - BUILD TRT TABLE FOR SCANNING ***'
         MACRO
&LABEL   $SETRT &LIST
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SETRT     SET UP TRT TABLE FOR SCANNING IN ASSEMBLER.   *
.*       USED INSIDE ASSIST ASSEMBLER TO CREATE TEMPORARY TRT TABLE IN*
.*       COMMON AREA AWTZTAB (WHICH CONTAINS 256 HEX 0'S).            *
.*       &LIST IS LIST OF CHARACTER/VALUE PAIRS, WITH CHARACTERS      *
.*       ENCLOSED IN QUOTES.  CORRESPONDONG VALUES ARE MOVED INTO     *
.*       CORRESPONDING LOCATIONS IN 256-BYTE TABLE OF ZEROS.          *
.*       IF VALUE IS OMITTED, ZERO IS ASSUMED.                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I
         LCLC  &CH1,&CH2
&I       SETA  1
         AIF   (T'&LABEL EQ 'O').XNOLB
&LABEL   DS    0H
.XNOLB   ANOP
&CH1     SETC  '&LIST(&I)'         GET NEXT LIST VALUE
&CH2     SETC  '&CH1'(1,2)         GET UP TO 2 CHARS
         AIF   ('&CH2' EQ 'X''' OR '&CH2' EQ 'C''').XGEN
         AIF   ('&CH2'(1,1) EQ '''').XC
&CH1     SETC  'C''&CH1'''         ADD C' ' TO ELEMENT
         AGO   .XGEN
.XC      ANOP
&CH1     SETC  'C&CH1'             ADD C TO ELEMENT
.XGEN    ANOP
&CH2     SETC  '&LIST(&I+1)'       GET VALUE OP
         AIF   ('&CH2' NE '').XGEN1
&CH2     SETC  '0'                 SET TO ZERO
.XGEN1   MVI   AWTZTAB+&CH1,&CH2
&I       SETA  &I+2                INCREMENT
         AIF   (&I LT N'&LIST).XNOLB         CONTINUE LOOPING
         MEND
         TITLE '*** MISC. UTILITY MACROS - $GTAD,$LV,$STV ***'
         MACRO
&LABEL   $GTAD &RG,&ENTRY
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GTAD      LOAD ADCON INTO REGISTER FORM AVWXTABL.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     &RG,AX&ENTRY
         MEND
         SPACE 2
         MACRO
&LABEL   $LV   &RG,&AD,&L=3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $LV        LOAD VARIABLE LENGTH VALUE INTO REGISTER(ASMB)*
.*       LOAD VARIABLE - PLACES &L BYTES IN &RG FROM &AD              *
.*       HIGH ORDER BYTES ARE ZEROED, USES AVFWORK1                   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (&L NE 3).XNO3      SKIP IF NOT 3
&LABEL   MVI   AVFWORK1,0
         AGO   .XMVC2              SKIP TO MOVE OVER
.XNO3    ANOP
&LABEL   SR    &RG,&RG .           CLEAR REG FOR ZEROS
         ST    &RG,AVFWORK1 .      ZERO WORK WORD OUT
.XMVC2   MVC   AVFWORK1-&L+4(&L),&AD .       MOVE BYTES OVER
         L     &RG,AVFWORK1 .      LOAD THE REGISTER
         MEND
         SPACE 2
         MACRO
&LABEL   $STV  &RG,&AD,&L=3
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $STV       STORE VARIABLE LENGTH VALUE FROM REGISTER (AS)*
.*       STORE VARIABLE MACRO-STORES &L BYTES FROM LOW ORDER END OF   *
.*       REGISTER &RG INTO ADDRESS &AD.                               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   ST    &RG,AVFWORK1 .      STORE REG INTO WORK WORD
         MVC   &AD.(&L),AVFWORK1+4-&L
         MEND
         TITLE '*** CONG MACRO - GEN CONSTATNT CODE TABLES(CODTL1)***'
         MACRO
         CONG  &C,&TYP,&LEN,&LD='''',&RD='''',&LW=1,&HI=8,&E=$CNERR
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: CONG       GENERATE CONSTANT CODE TABLE (CSECT CODTL1).  *
.*       USED IN CODTL1 OF ASSEMBLER TO PRODUCE 1 ENTRY IN            *
.*       CONSTANT DESCRIPTION BLOCK.  SEE CONBLK DSECT IN CODTL1.     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ORG   CODINXO+C'&C'       ORG INTO RIGHT SPOT IN TABLE
         DC    AL1(CODT&C-CONTAB1) DEFINE OFFSET VALUE
         ORG
CODT&C   DC    AL1(&TYP+$CN&C+&E,&LEN-1,C&LD,C&RD,&LW-1,&HI-1)
         MEND
         TITLE '*** MACROS USED BY THE EXTENDED INTERPRETER ONLY'
         MACRO
&LABEL   EITAB &INS,&SYS,&IL,&CL,&TYPE,&OPC,&MODCHK,&OP1,&OP2,&D2B,    X
               &D2H,&ALN,&R1,&R2,&ROUTINE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: EITAB       INTERPRETER CONTROL TABLE MACRO              *
.*                                                                    *
.*       THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO CONSTRUCT  *
.*       A SINGLE CONTROL TABLE ENTRY.  EACH TABLE ENTRY DEFINES THE  *
.*       DECODING NECESSARY FOR ITS CORRESPONDING INSTRUCTION(S).     *
.*                                                                    *
.*       IT SHOULD BE NOTED THAT:                                     *
.*         (1)     IT IS SUGGESTED THAT ASTERISKS BE PLACED IN        *
.*                 ARGUMENT FIELDS NOT APPLICABLE TO A PARTICULAR     *
.*                 INSTRUCTION DECODING FORMAT.  IF THIS IS DONE,     *
.*                 THE ARGUMENT FIELDS WILL FORM ALIGNED COLUMNS      *
.*                 IN THE SOURCE LISTING, MAKING READING AND DE-      *
.*                 BUGGING EASIER.                                    *
.*         (2)     ONLY TWO ARGUMENTS ARE REQUIRED FOR EXTENDED       *
.*                 OPCODE INSTRUCTIONS IN THE MAIN TABLE.  THESE      *
.*                 ARE &OPC AND &ROUTINE.  THE LATTER SHOULD BE       *
.*                 THE LABEL OF THE APPROPRIATE EXTENDED OPCODE       *
.*                 SECONDARY TABLE (NOT THE USUAL ROUTINE LABEL).     *
.*                 IT IS SUGGESTED THAT ALL OTHER FIELDS CONTAIN      *
.*                 ASTERISKS.                                         *
.*                                                                    *
.*       ***** ARGUMENTS *****                                        *
.*                                                                    *
.*       &INS      = THE MNEMONIC INSTRUCTION CODE (LA,BCT,SR,ETC.)   *
.*       &SYS      = 360 IF THE INSTR IS GOOD ON 360'S & 370'S        *
.*                 = 370 IF THE INSTR IS GOOD ONLY ON 370'S           *
.*       &IL       = INSTRUCTION LENGTH IN BYTES (2, 4 OR 6)          *
.*       &CL       = AN INTEGER (1 <= &CL <= 8) SPECIFYING THE LENGTH *
.*                   OF STORAGE MODIFIED OR FETCHED BY THIS INSTR     *
.*                 = 0   IF THE LENGTH IS CONTAINED IN THE INST ITSELF*
.*                   (SS INSTRUCTIONS)                                *
.*                 = *   IF NOT APPLICABLE                            *
.*       &TYPE     = NO  IF THIS IS NOT A PRIVILEGED INSTR            *
.*                 = PR  IF THIS IS A PRIVILEGED INSTRUCTION          *
.*       &OPC      = NM  IF THIS INSTR'S OPCODE IS NORMAL (8 BITS)    *
.*                 = EX  IF THIS INSTR'S OPCODE IS EXTENDED (> 8 BITS)*
.*       &MODCHK   = CK  IF THE STORAGE ACCESS @ AND LENGTH ARE TO BE *
.*                   RANGE CHECKED IN THE MAIN DECODING LOOP (NEAR    *
.*                   STMT LABEL -> EINOCHK)                           *
.*                 = NO  IF CHECKING SHOULD NOT BE DONE IN THE MAIN   *
.*                   DECODING LOOP                                    *
.*                 = **  IF NOT APPLICABLE                            *
.*       &OP1      = F   IF OPRND #1 SHOULD BE FETCH CHECKED          *
.*                 = S   IF OPRND #1 SHOULD BE STORE CHECKED          *
.*                 = N   IF NO CHECKING IS REQUIRED FOR OPRND #1      *
.*                 = *   IF NOT APPLICABLE                            *
.*       &OP2      = SAME AS &OP1, BUT FOR OPRND #2                   *
.*       &D2B      = RR4 IF 2ND BYTE TO BE DECODED AS 2 REGS (X 4)    *
.*                 = LL1 IF 2ND BYTE TO BE DECODED AS 2 FIELDS (X 1)  *
.*                 = IOL IF 2ND BYTE TO BE DECODED AS 1 FIELD (X 1)   *
.*       &D2H      = BD  IF 2ND HALFWORD @ IS ONLY BASE+DISPL         *
.*                 = IX  IF 2ND HALFWORD @ IS BASE+DISPL+INDEX        *
.*                 = **  IF NOT APPLICABLE                            *
.*       &ALN      = DBL IF OPRND ALIGNMENT MUST BE DOUBLEWORD        *
.*                 = FUL IF OPRND ALIGNMENT MUST BE AT LEAST FULLWORD *
.*                 = HAF IF OPRND ALIGNMENT MUST BE AT LEAST HALFWORD *
.*                 = NON IF NO ALIGNMENT NEEDED                       *
.*                 = *** IF NOT APPLICABLE                            *
.*       &R1       = E   IF THE R1 FIELD MUST SPECIFY AN EVEN REG     *
.*                 = O   IF THE R1 FIELD CAN SPECIFY AN ODD REG       *
.*                 = *   IF NOT APPLICABLE  (IF &D2B = RR4)          *
.*       &R2       = SAME AS &R1, BUT FOR R2 FIELD                    *
.*       &ROUTINE  = A STMT LABEL SPECIFYING A ROUTINE TO WHICH       *
.*                   CONTROL IS PASSED FOLLOWING PRIMARY DECODING     *
.*                   (E.G. - EIBAL, EILA, EINORMRR, ETC.)             *
.*                 = A STMT LABEL OF THE SECONDARY CONTROL TABLE      *
.*                   APPROPRIATE FOR AN EXTENDED OPCODE INSTRUCTION   *
.*                   (SEE NOTES ABOVE ARGUMENT LISTING)               *
.*                                                                    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &BYTE               BYTES ARE BUILT WITH THIS VAR
         SPACE 1
EIT&INS  EQU   *                   LABEL FOR EIXTAB MACRO
.*
.*             CHECK IF THIS ENTRY IS FOR AN EXTENDED OPCODE INSTR --
.*             BRANCH IF IT IS
.*
         AIF   ('&OPC' EQ 'EX').OPEXTD
.*
.*             ASSEMBLE AND GENERATE THE 1ST AND 2ND BYTES OF THIS
.*             TABLE ENTRY  --  INCLUDING LABEL IF ANY
.*
&BYTE    SETC  '00001000'          INITIAL BYTE SET-UP
         AIF   (&SYS EQ 370).OPB1A SKIP IF 370-ONLY INSTR
&BYTE    SETC  '00001100'          ADD BIT IF 360/370 INSTR
.OPB1A   AIF   ('&TYPE' NE 'PR').OPB1B  SKIP IF NOT A PRIV INSTR
&BYTE    SETC  '01'.'&BYTE'(3,6)   ADD BIT IF PRIV INSTR
.OPB1B   AIF   (&IL NE 2).OPB1C    SKIP IF NOT AN RR INSTR
&BYTE    SETC  '&BYTE'(1,2).'1'.'&BYTE'(4,5)  ADD BIT IF RR INSTR
         AGO   .OPB1D              NO CHECKING IF RR INSTR
.OPB1C   AIF   (('&MODCHK' EQ '') OR ('&MODCHK' EQ '**') OR ('&MODCHK' X
               EQ 'NO')).OPB1D     SKIP IF NO CHECKING TO BE DONE
&BYTE    SETC  '&BYTE'(1,3).'1'.'&BYTE'(5,4)  ADD BIT IF CHECKING
.OPB1D   ANOP
&LABEL   DC    B'&BYTE',HL1'&IL'                                      L
.*
.*             1ST & 2ND BYTES GENERATED  --  NOW ASSEMBLE AND
.*             GENERATE BYTE # 3
.*
&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP
.*             SET OPERAND #1 CHECKING BITS
         AIF   (('&OP1' EQ 'N') OR ('&OP1' EQ '*')).OPB3A  SKIP IF NOCK
&BYTE    SETC  '01000000'          AT LEAST THIS BIT IS ON
         AIF   ('&OP1' EQ 'F').OPB3A  SKIP IF FETCH CHECKING
&BYTE    SETC  '11000000'          SET STORE CHECK BITS ON
.*             SET OPERAND #2 CHECKING BITS
.OPB3A   AIF   (('&OP2' EQ 'N') OR ('&OP2' EQ '*')).OPB3B
&BYTE    SETC  '&BYTE'(1,2).'010000'  AT LEAST FETCH BIT IS ON
         AIF   ('&OP2' EQ 'F').OPB3B  SKIP IF FETCH CHECKING
&BYTE    SETC  '&BYTE'(1,2).'110000'  SET STORE CHECK BITS ON
.*             SET BIT IF THIS IS A NON-RR BRANCH INSTR
.OPB3B   AIF   ((&IL EQ 2) AND ('&INS' NE 'XOPC')).OPB3E  SKIP IF RR
         AIF   (('&INS' NE 'BAL') AND ('&INS' NE 'BC') AND ('&INS' NE 'X
               BCT') AND ('&INS' NE 'BXH') AND ('&INS' NE 'BXLE')).OPB3X
               C                   SKIP IF NOT A NON-RR BRANCH
&BYTE    SETC  '&BYTE'(1,4).'1000' SET NON-RR BRANCH INSTR BIT ON
.*             SET BIT FOR 2ND HALFWORD DECODING
.OPB3C   AIF   (('&D2H' EQ '**') OR ('&D2H' EQ 'IX')).OPB3D  NOT = B+D
&BYTE    SETC  '&BYTE'(1,5).'100'  SET BASE+DISP BIT ON
.OPB3D   ANOP
.*             SET BITS FOR 2ND BYTE DECODING (NOT HERE IF AN RR INSTR)
         AIF   ('&D2B' EQ 'RR4').OPB3E     SKIP IF RR4                L
&BYTE    SETC  '&BYTE'(1,6).'01'   ASSUME LLX1
         AIF   ('&D2B' EQ 'LL1').OPB3E  SKIP IF LLX1
&BYTE    SETC  '&BYTE'(1,6).'11'   SET BITS FOR IOL
.OPB3E   ANOP
         DC    B'&BYTE.'
.*
.*             1ST 3 BYTES GENERATED  --  NOW DO BYTE 4
.*
&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP
         AIF   (('&ALN' EQ '') OR ('&ALN' EQ 'NON') OR ('&ALN' EQ '***'X
               )).OPB4A
&BYTE    SETC  '00000001'          SET HALFWORD ALIGN
         AIF   ('&ALN' EQ 'HAF').OPB4A JUMP IF NOW OK
&BYTE    SETC  '00000011'          SET FULL WORD ALIGN
         AIF   ('&ALN' EQ 'FUL').OPB4A JUMP IF NOW OK
&BYTE    SETC  '00000111'          SET DOUBLEWORD ALIGN
.OPB4A   ANOP
         DC    B'&BYTE.'
.*
.*             1ST 4 BYTES GENERATED  --  NOW DO BYTE 5
.*
&BYTE    SETC  '00000000'          INITIAL BYTE SET-UP
         AIF   ('&D2B' NE 'RR4').OPB5B  SKIP IF NO REGS TO CHK
         AIF   ('&R1' NE 'E').OPB5A  SKIP IF R1 CAN BE ODD
&BYTE    SETC  '00010000'          SET BIT FOR R1 EVEN
.OPB5A   AIF   ('&R2' NE 'E').OPB5B  SKIP IF R2 CAN BE ODD
&BYTE    SETC  '&BYTE'(1,4).'0001' SET BIT FOR R2 EVEN
.OPB5B   ANOP
         DC    B'&BYTE.'
.*
.*             1ST 5 BYTES GENERATED  --  NOW DO BYTE 6
.*             AND THE HALFWORD DISPL TO THE ROUTINE
.*
&BYTE    SETC  '0'                 INITIAL BYTE SET-UP
         AIF   (('&CL' EQ '*') OR ('&CL' EQ '') OR ('&CL' EQ '0')).OPB6X
               A
&BYTE    SETC  '&CL'
.OPB6A   ANOP
         DC    HL1'&BYTE.',AL2(&ROUTINE.-EISPEJMP)
         SPACE 1
         MEXIT
.*
.*             EXTENDED OPCODE IF HERE -- GENERATE TABLE ENTRY
.*
.OPEXTD  ANOP
&LABEL   DC    B'10000000',XL3'0',A(&ROUTINE)                         L
         SPACE 1
         MEND
         EJECT
         MACRO
&LABEL   EIXTAB  &L1,&L2,&L3,&L4,&L5,&L6,&L7,&L8
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO:  EIXTAB       INTERPRETER SECONDARY CONTROL TABLE MACRO  *
.*                                                                    *
.*             THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO      *
.*             GENERATE THE 256 BYTE SECONDARY TABLE.  THIS TABLE IS  *
.*             INDEXED INTO BY THE OPCODE OF THE INSTRUCTION BEING    *
.*             EXECUTED.  EACH TABLE ENTRY CONTAINS A DISPLACEMENT    *
.*             INTO THE MAIN DECODING TABLE.  INVALID OPCODES ALSO    *
.*             ARE GIVEN DISPLACEMENTS INTO THE TABLE.  THESE         *
.*             POINT TO ZERO ENTRIES IN THE MAIN TABLE NOTING THE     *
.*             THE OPCODES AS BEING INVALID.  THE NUMBER OF           *
.*             PARAMETERS USED FOR A CALL TO THIS MACRO IS 8.  IF     *
.*             8 ARE NOT USED AN MNOTE IS GIVEN AND THE GENERATION    *
.*             FOR THAT MACRO CALL IS TERMINATED.  THE PARAMETERS     *
.*             SHOULD EACH BE THE MNEMONIC OF THE INSTRUCTION OR      *
.*             THE NAME OF THE GROUP OF INSTRUCTIONS REPRESENTED.     *
.*             THESE NAMES MUST CORRESPOND TO NAMES IN THE MAIN       *
.*             TABLE.  NUMERIC PARAMETERS SHOULD BE USED FOR ALL      *
.*             ILLEGAL OPCODES.  THESE SHOULD BE A 2, 4 OR 6          *
.*             DEPENDING ON THE LENGTH OF THE ZERO MAIN TABLE ENTRY   *
.*             BEING INDEXED.                                         *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &L
&LABEL   DC    0C' '
         AIF   (N'&SYSLIST EQ 8).EILOOP
         MNOTE 30,'***** EIGHT INSTRUCTIONS NOT SPECIFIED - ERROR ****'
         MEXIT
.EILOOP  ANOP
&L       SETA  &L+1
         AIF   (T'&SYSLIST(&L) NE 'N').EINONUM
         AIF   ((&SYSLIST(&L) EQ 2) OR (&SYSLIST(&L) EQ 4) OR (&SYSLISTX
               (&L) EQ 6)).EINONUM
         MNOTE 30,'*** NUMERIC VALUE SPECIFIED NOT EQUAL 2, 4, 6 ***'
         MEXIT
.EINONUM ANOP
         DC    AL1((EIT&SYSLIST(&L).-EICONTAB)/8)
         AIF   (&L LT 8).EILOOP
         MEND
         TITLE '*** EVCG TABLE - GENERATE ROW OF EVALUT TRANSITION TAB'
         MACRO
         CROSSET  &NUM
         GBLB  &$XREF              CONTROLS GENERATION OF MACRO
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: CROSSET               MACRO TO SET FLAGS FOR XREF        *
.*  THIS MACRO IS USED IN THE ICMOP2 CSECT AND IS CALLED EVERY TIME   *
.*  A NEW OPERAND IS SCANNED.  IT SETS THE INSTRUCTION TYPE           *
.*  AND THE FLAG AVXRTYPE.                                            *
.*    &NUM ==>  # OF OPERAND BEING SCANNED.  CONTROLS TESTING         *
.*              OF CORRECT FLAG.                                      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (NOT &$XREF).NOXREF SKIP IF NOT CROSS REFERENCE
         OI    AVXRTYPE,AVXRFTCH .  SET BIT ON
         TM    AVXRMDFT,AVXRMOD&NUM  .  SEE IF MODIFY REFERENCE
         BZ    *+8                 NO SKIP RESETING
         NI    AVXRTYPE,X'FF'-AVXRFTCH  .  TURN OFF FLAG
.NOXREF  MEND
         SPACE 5
         MACRO
&LABEL   EVCG  &L
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: EVCG       CREATE ROW OF TRANSITION TABLE (CSECT EVALUT) *
.*       &L        LIST OF PAIRS- JUMP LABEL,(ERROR CODE OR STATE #). *
.*       CREATES 1 ROW OF TABLE EVCTAB IN GENERAL EXPRESSION EVALUATOR*
.*       CSECT EVALUT.  SEE EVCTDSCT DSECT FOR ENTRIES IN EACH ROW.   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I                  LOCAL COUNTER
&I       SETA  1                   INIT
&LABEL   DS    0H
.EVCA    AIF   (T'&L(&I+1) EQ 'N').EVCC     JUMP IF IT IS STATE #
         DC    AL1(EV&L(&I)-EVDJUMP,$ERV&L(&I+1)) .   OFFSET,ERROR
         AGO   .EVCE
.EVCC    DC    AL1(EV&L(&I)-EVDJUMP,EVCT&L(&I+1)-EVCTAB)
.EVCE    ANOP
&I       SETA  &I+2                INCREMENT BY 2 FOR NEXT PAIR
         AIF   (&I LT N'&L).EVCA   GO BACK IF THERE'S MORE
         MEND
         TITLE '*** TABLE GENERATION MACROS -IBPRTAB, ICT ***'
         MACRO
&LABEL   IBPRTAB &OP,&VO,&VX
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: IBPRTAB    GENERATE 1 BLOCK FOR PRINT SCAN LIST          *
.*.      USED ONLY IN IBASM1. CREATES 1 BLOCK: DSECT IBPSCECT         *
.*.      &OP       OPERAND NAME (ON, OFF, ETC).                       *
.*.      &VO       VALUE TO BE OR'D INTO PRINT BYTE: BIT TO SET ON/OFF*
.*.      &VX       VALUE TO BE XOR'D INTO PRINT CONTROL: EITHER 0     *
.*.                IF BIT ON (&VX OMITTED), OR SAME AS &VO IF * CODED.*
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &K                  FOR COUNT
         LCLC  &C                  FOR &VX VALUE
&K       SETA  K'&OP-1             GET #-1 OF CHARS IN OPERAND
&C       SETC  '0'                 ASSUME &VX OMITTED
         AIF   ('&VX' EQ '').IB1   SKIP IF WAS OMITTED
&C       SETC  '&VO'               DUPLICATE VALUE OF EQUATE
.IB1     ANOP
&LABEL   DC    AL1(&K,&VO,&C),C'&OP'
         MEND
         SPACE 4
         MACRO
&LABEL   ICT   &TYPE,&VALUE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ICT        CREATE CONTROL CODES(ICYFLAG) VALUES(ICMOP2). *
.*       &TYPE     TYPE OF INSTRUCTION FORMAT ($RR,$RX,ETC).          *
.*       &VALUE    VALUE OF CODE REQUIRED FOR TABLE.                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ORG   ICTTAB+&TYPE/2
&LABEL   DC    AL1(&VALUE)
         MEND
         TITLE '*** OPG MACRO - GENERATE OPCODTB ENTRY FOR OPCOD1 ***'
         MACRO
         OPG   &MNEM,&TYPE,&HEX,&MASK,&CODE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: OPG        CREATE 1 ENTRY IN ASM OPCODE TABLE (OPCOD1).  *
.*       THE GENERATED ENTRY IS DESCRIBED BY DSECT OPCODTB.           *
.*       GENERATES THE 4 FIELDS OF AN OPCODTB ENTRY - OPCTYPE,OPCHEX, *
.*       OPCMASK, AND OPCMNEM.  IF &HEX OR &MASK ARE OMITTED,THEY     *
.*       ARE ASSUMED TO BE 0.   &CODE IS USED FOR INSTRUCTIONS WHICH  *
.*       MAY NOT BE GENERATED. IF USED , IT IS 'D' FOR DECIMAL INSTS, *
.*       'F' FOR FLOATING POINT INSTRUCTIONS, AND 'P' FOR PRIVILEGED  *
.*       OPERATIONS.  IF THE SPECIFIED TYPE IS NOT TO BE GENERATED,   *
.*       THE APPROPRIATE GLOBAL VARIABLE WILL HAVE BEEN SET, AND THE  *
.*       OPCODTB ENTRY WILL NOT BE CREATED.                           *
.*       &CODE = 'M' FOR MACRO OPCODES.                               *
.*       &CODE = 'FX' FOR EXTENDED FLOATING POINT OPCODES.            *
.*       &CODE = 'S370' FOR NON-PRIVILEGED S/370 OPCODES.             *
.*       &CODE = 'P370' FOR PRIVILEGED S/370 OPCODES.                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &OPNGN(8)           USED TO KNOW IF LENGTH HAS BEEN USED
         GBLB  &$DECSA,&$FLOTA,&$PRIVOP      GENERATION STATUS VARS
         GBLB  &$MACROS            =1 GEN MACRO OPCODES
         GBLB  &$FLOTAX            =1 GEN EXTENDED FP OPCODES
         GBLB  &$S370A             =1 GEN NON-PRIVILEGED S/370 OPCODES
         GBLB  &$P370A             =1 GEN PRIVILEGED S/370 OPCODES
         AIF   (T'&CODE EQ 'O').XNOC         SKIP IF NO CODE USED
         AIF   ('&CODE' EQ 'F' AND NOT &$FLOTA).XEXIT  SKIP IF NOTFLOAT
         AIF   ('&CODE' EQ 'FX' AND NOT &$FLOTAX).XEXIT SKIP IF NO EXFP
         AIF   ('&CODE' EQ 'D' AND NOT &$DECSA).XEXIT  SKIP IF NO DECS
         AIF   ('&CODE' EQ 'P' AND NOT &$PRIVOP).XEXIT SKIP IF NO PRIVS
         AIF   ('&CODE' EQ 'M' AND NOT &$MACROS).XEXIT SKIP IF NO MACRS
         AIF   ('&CODE' EQ 'S370' AND NOT &$S370A).XEXIT SKIP IF NO 370
         AIF   ('&CODE' EQ 'P370' AND NOT &$P370A).XEXIT SKIP IF NO PRV
.XNOC    ANOP
&OPNGN(K'&MNEM) SETB 1       NOTE THAT ONE OF THIS LENGTH HAS BEEN USED
         AIF   ('&HEX' EQ '' OR '&MASK' EQ '').XNOQ    SKIP IF OMITTED
         DC    AL1(&TYPE,&HEX,&MASK),C'&MNEM'
         MEXIT
.XNOQ    AIF   (T'&HEX EQ 'O').XNOX    SKIP IF HEX OMITTED.
         DC    AL1(&TYPE,&HEX,0),C'&MNEM'
         MEXIT
.XNOX    AIF   (T'&MASK EQ 'O').XNOMSK SKIP IF MASK FIELD OMITTED
         DC    AL1(&TYPE,0,&MASK),C'&MNEM'
         MEXIT
.XNOMSK  DC    AL1(&TYPE,0,0),C'&MNEM'
.XEXIT   MEND
         TITLE '*** OPGT MACRO - GENERATE OPCOD1 POINTER TABLES ***'
         MACRO
         OPGT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: OPGT       CREATE 2ND LEVEL OPCODE PTR TABLES (OPCOD1).  *
.*       USES MACROS: $AL2                                            *
.*       NOTE &OPNGN VALUES WERE SET BY OPG MACRO. CALLED 1 TIME ONLY.*
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &OPNGN(8)           LENGTH TAGS
         LCLC  &O                  PREFIX CHARACTERS
         LCLA  &I                  LOOP COUNTER
.OPLOOP  ANOP
&I       SETA  &I+1                INCREMENT TO NEXT LENGTH
         AIF   (&OPNGN(&I)).OPGEN1 GENERATE, IF ANY WERE USED
OPF&I    EQU   OPADS .             NAME FOR UNUSED # OF LETTERS
         AGO   .OPBOT              GO TO BOTTOM OF LOOP
.OPGEN1  ANOP
&O       SETC  'OP&I'              GET PREFIX CHRACTERS
OPF&I    $AL2  OPFIND,                                                 X
               (&O.A,&O.B,&O.C,&O.D,&O.L,&O.M,&O.N,&O.S,&O.T,&O.END)
.OPBOT   AIF   (&I LT 8).OPLOOP    CONTINUE LOOPING
         MEND
         TITLE 'REPRNT MACRO - PRINT MACRO FOR REMONI INTERNAL USE'
         MACRO
&LABEL   REPRNT &MSG,&MSGL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: REPRNT     PRINT MESSAGE MACRO FOR REMONI USE            *
.*       &MSG  GIVES RX-TYPE ADDRESS OF MESSAGE TO BE PRINTED.        *
.*       &MSGL GIVES LENGTH OF THE MESSAGE TO BE PRINTED.             *
.*       MODIFIES REGISTERS  R7, R8, R14.                             *
.*       CALLS INSUB, REXPRINT.                                       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   LA    R7,&MSG   .         SHOW @ MESSAGE
         LA    R8,&MSGL   .        SHOW LENGTH OF MESSAGE
         BAL   R14,REXPRINT .      CALL THE INSUB
         MEND
         TITLE 'RFSGN MACRO - GENERATES 1 ENTRY IN TABLE CSECT RFSYMS'
         MACRO
&LABEL   RFSGN &CSECT,&ENTRY,&TYPE=0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: RFSGN      GENERATE 1 ENTRY OF REPLACE NAME TABLE(RFSYMS)*
.*             RFSGN MACRO IS USED TO GENERATE THE PRIMARY TABLE      *
.*       OF CSECT NAMES AND THEIR ENTRY POINT NAMES, WHICH IS USED TO *
.*       DO REPLACEMENT AND CHECKING OF STUDENT-WRITTEN CSECTS.       *
.*             IF &$REPL=2 AND TYPE=2, RFSGN CREATES AN ELEMENT IN    *
.*       THE SECOND SECTION OF RFSYMS, WHICH DESCRIBES A CALLABLE     *
.*       ENTRYPOINT IN REAL ASSIST ROUTINES.                          *
.*       &CSECT    NAMES A CSECT WHICH CAN BE REPLACED.               *
.*             IF TYPE=2, NAMES A CALLABLE ENTRY FOR 2ND SECTION.     *
.*       &ENTRY    IS A LIST OF 1 OR MORE ENTRY POINT NAMES IN &CSECT.*
.*             IF TYPE=2, THIS ONE IS OMITTED.                        *
.*       &TYPE     = 1 IF &CSECT MAY CALL OTHER CSECTS, OMITTED IF NOT*
.*             =2 IF CALL IS TO CREATE CALLABLE ENTRY ELEMENT.        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$REPL              REPLACE VAR. 0=NONE, 1=LIMITED
         LCLA  &I,&N               INDEX, L'&ENTRY
         LCLC  &EN                 TEMPORARY ENTRY NAME FOR CONVENINCE
         AIF   ('&TYPE' NE '0' AND &$REPL NE 2).RFSB  SKIP IF NOT LIM R
         AIF   ('&TYPE' EQ '2').RFSA2       SKIP IF TYPE 2 ELEMENT
&N       SETA  N'&ENTRY            GET # ENTRIES, >= 1
.*             RFSYMB,RFSENTN,RFSENTL,RFSTYPE.
&LABEL   DC    CL6'&CSECT',AL1(&N,RFS$LEN*(&N+1))
         AIF   ('&TYPE' EQ '0').RFSA1       SKIP IF CAN'T CALL OTHER
         DC    AL2(RI&CSECT-RFSYMS)    REPLACE CSECT WHICH CAN CALL
         AGO   .RFSA               GO BACK FOR NEXT
.RFSA1   DC    AL2(0)
.RFSA    AIF   (&I GE &N).RFSB     JUMP OUT IF NO MORE ENTRIES
&I       SETA  &I+1                INCREMENT INDEX TO ENTRIES
.*             RFSYMB,RFSAXPT,RFSRGPT,RFSRHPT.
&EN      SETC  '&ENTRY(&I)'        GET ENTRY, FOR CONVENIENCE
         DC    CL6'&EN',AL2(AX&EN-AX$BASE,RG&EN-RG$BASE)
         AGO   .RFSA
.RFSA2   ANOP
RF&CSECT DC    CL6'&CSECT',AL2(AX&CSECT-AX$BASE,RH&CSECT-RH$BASE)
.RFSB    SPACE 1
         MEND
         TITLE '*** WCONG MACRO - GENERATE CONST.ADDR OFFSET TABLE ***'
         MACRO
         WCONG &C
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: WCONG      CREATE OFFSETS TO CONSTANT SUBR ADCONS-VWXTABL*
.*       CREATE WCONADS TABLE IN VWXTABL FOR USE OF CODTL1 AND CNDTL2 *
.*       IN DOING TABLE-DRIVEN CONSTANT PROCESSING. CALLED 1 TIME ONLY*
.*       &C        LIST OF CONSTANT TYPES ALLOWED.    (A,B,C, ETC).   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I                  COUNTER
         AIF   ('&SYSECT' NE 'VWXTABL').XXEXIT         SKIP IF NOT VWXT
.LOOP    ANOP
&I       SETA  &I+1                INCREMENT TO NEXT 1
         ORG   WCONADS+$CN&C(&I)   ORG TO ADCON SPOT
         DC    AL1(AXC&C(&I).CON1-AXC$BASE)
         AIF   (&I LT N'&C).LOOP   LOOP UNTIL DONE
         ORG
.XXEXIT  MEND
         TITLE '$TIRC MACRO - TIME OR RECORS -USED OR REMAINING(PSU)'
         MACRO
&LABEL   $TIRC &TYPE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $TIRC      GET TIME/RECORDS DATA FROM OPERATING SYSTEM.  *
.*             THIS MACRO USES PSU SVC CALL 250 TO OBTAIN TIME OR     *
.*       RECORDS INFORMATION.  &TYPE IS TIMREM,TIMUSE,RECREM,RECUSE.  *
.*       RESULT IS RETURNED IN R0, IN EITHER RECORDS, OR IN TIMER     *
.*       UNITS OF 26.04 MICROSECOND.  DESTROYS R0,R1,R15.             *
.*       *NOTE* MAY HAVE TO BE REWRITTEN FOR LOCAL CONDITONS.         *
.*       &TYPE CAN ALSO BE OF FORM  (NAME,ADDR)  WHERE ADDR IS AN     *
.*       RX-TYPE ADDRESS, AT WHICH THE MACRO PLACES THE FOLLOWING:    *
.*       BYTES  0-4  : ACCOUNT NUMBER       .... INFORMATION FROM     *
.*       BYTES  5-12 : JOB NAME             .... FROM                 *
.*       BYTES 13-32 : PROGRAMMER NAME      .... JOB CARD             *
.*       THIS FORM NEEDED ONLY IF &$ACCT=1,  AND IS COMPLETELY LOCAL  *
.*       TO PSU CC, THUS MUST BE REWRITTEN IF USED ELSEWHERE.         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   ('&TYPE(1)' NE 'NAME').TIMREC          SKIP IF NOT NAME
         CNOP  0,4                 ALIGN FOR LATER ADCON
&LABEL   LA    R1,&TYPE(2)  .      GET @ WHERE INFO TO BE PUT
         ST    R1,*+8 .            STORE INTO PARAMATER LIST
         BAL   R1,*+8 .            SET R1==> ADCON, SKIP AROUND
         DS    A .                 FOR @ AREA FOR INFORMATION
         SR    R15,R15             R15 = 0 PART OF CONVENTION
         SR    R0,R0 .             SET R0 TO 0 FOR NAME CALL
         BCTR  R0,0 .              SET R0 TO -1==> WANT NAME
         SVC   250 .               GET ACCOUNTING INFO****PSU CC*******
         AGO   .XXEXIT             QUIT GENERATING
.TIMREC  ANOP
         AIF   ('&TYPE'(1,3) EQ 'TIM').TIM  SKIP IF TIME DESITRED
&LABEL   SR    R0,R0
         SR    R15,R15
         SVC   250 .               MAKE RECORD CALL
         AIF   ('&TYPE'(4,3) EQ 'USE').XXEXIT         SKIP IF DONE
         LR    R0,R1 .             MOVE RECORDS REMAINING OVER
         MEXIT
.TIM     ANOP
&LABEL   LA    R0,1
         SR    R15,R15
         SVC   250 .               MAKE CALL FOR TIME INFO
         AIF   ('&TYPE'(4,3) EQ 'USE').TIM2 SKIP IF IN RIGHT REG
         LR    R0,R1 .             MOVE TIME REMAINING OVER
.TIM2    SLL   R0,2 .              *4 FOR # 26.04 MIC TIMER UNITS
.XXEXIT  MEND
         TITLE 'APCGN MACRO - GENERATE APCBLK IN CSECT APARMS'
         MACRO
&LABEL   APCGN &PARM,&AJOFS,&BITS,&C=0,&N=0,&D=0,&I1=0,&Y=0,&G=1,&GC=0,#
               &LK=111
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: APCGN      GENERATE 1 APCBLK ELEMENT IN APARMS           *
.*       GENERATES BLOCK FOR PARM OPTION SCANNING CONTROL, DEPENDING  *
.*       ON DESIRED CHARACTERISTICS OF THE PARM. MAY SKIP GENERATION  *
.*       IF THE REQUIRED OPTION DOES NOT EXIST IN PARTICULAR SYSTEM.  *
.*       ***SEE DSECT APCBLK AND CSECT APARMS (FROM LABEL APFOUND)    *
.*       FOR FURTHER INFORMATION ON HANDLING OF BLOCK CREATED BY THIS.*
.*  &PARM      NAME OF THE PARM OPTION.                               *
.*  &AJOFS     NAME OF VARIABLE IN AJOBCON TO BE SET BY THIS PARM     *
.*  &BITS      VALUE USED TO SET FLAG FOR YES/NO TYPE PARMS.          *
.*       IF =PARM AND NOT CALL TYPE, SHOULD BE GIVEN VALUE 0.         *
.*  &G,&GC     USED TO CONTROL GENERATION.  GENERATION IS SKIPPED     *
.*       IF &G EQ &GC, THUS ALLOWING CONDITIONAL ASSEMBLY OF PARMS.   *
.*       &C THRU &Y GIVE TYPE BITS TO BE PLACED INTO APCFLAG.  EACH   *
.*       CORRESPONDS TO 1 OR MORE EQU SYMBOLS, AS LISTED.             *
.*  &C         =1 IF PARM IS NONSTANDARD AND A ROUTINE MUST BE CALLED.*
.*       APPLIES ONLY TO =VALUE TYPE PARMS.  THE ROUTINE CALLED MUST  *
.*       BE NAMED APA&PARM.                           (APCCALL)       *
.*  &N         =1 IF VALUE CANNOT BE GIVEN ANOTHER VALUE ONCE IT HAS  *
.*       BEEN SET ONCE.  MAY BE USED BY ANY PARM TYPE.(APCNRSET)      *
.*  &D         =1 IF PARM IS PARM=DECIMAL VALUE.  IF THIS IS CODED    *
.*       AND PARM IS NOT A SPECIAL CALL TYPE, THEN IT IS ASSUMED THAT *
.*       THE VALUE CONVERTED IS TO BE STORED AS A FULLWORD AT THE     *
.*       GIVEN VARIABLE LOCATION IN AJOBCON.          (APCD)          *
.*  &I1        =1 IF PARM IS A YES/NO TYPE AND  1BIT ON CORRESPONDS   *
.*       TO A YES VALUE (1BIT MEANS NO OTHERWISE).    (APCYES1B)      *
.*             =1 IF PARM IS =DECIMAL # PARM, AND MAY NEVER BE        *
.*       INCREMENTED AFTER IT HAS BEEN SET (BUT MAY BE DECREASED).    *
.*       USED PARTICULARLY FOR TIME/RECORDS LIMITS.   (APCNINCR)      *
.*  &Y         =1 IF THE PARM IS A YES/NO TYPE.  OTHERWISE, IT IS     *
.*       AN =PARM OF SOME SORT.                       (APCYESNO)      *
.*  &LK        DENOTES WHICH OF THE POSSIBLE CALLS IS ALLOWED TO SET  *
.*       A VALUE FOR THE GIVEN PARM.  CONSISTS OF 3 BITS: ###, WITH   *
.*       MEANINGS AS FOLLOW:                                          *
.*       100   CAN BE SET BY LIMIT OR DEFAULT VALUE  (APCSETLD)       *
.*       010   CAN BE SET FROM THE PARM FIELD         (APCSETP)       *
.*       001   CAN BE SET BY USER FROM $JOB CARD      (APCSETU)       *
.*             THIS MACRO USED ONLY IN APARMS CSECT.                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   ('&G' EQ '&GC').XXEXIT       SKIP IF FLAGGED THAT WAY
&LABEL   DC    CL(APCP$L)'&PARM',B'&LK&C&N&D&I1&Y',AL1(&AJOFS-AJO$APC)
         DC    B'0'
         AIF   (&C EQ 1).APCC      SKIP IF CALL TYPE
         DC    AL1(&BITS)
         MEXIT
.APCC    DC    AL1(APA&PARM-APAJUMP)
.XXEXIT  MEND
         TITLE '*** ASSIST CSECT MACROS: ASPRNT,ASTIME ***'
         MACRO
&LABEL   ASPRNT &XAREA,&XNUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASPRNT     PRINT LINE INSIDE MAIN PROG ASSIST.           *
.*       ASPRNT SETS UP R0=@ LINE, R1=LENG, CALLS INSUB ASASPRNT OF   *
.*       ASSIST.  MODIFIES REGS R0,R1,R14.                            *
.*       &XAREA,&XNUM SAME AS THOSE FOR $PRNT = @, LENGTH TO PRINT.   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   LA    R0,&XAREA  .        SHOW @ PRINT AREA
         AIF   ('&XNUM'(1,1) EQ '(').ASREG  SKIP IF REGISTER FORM
         LA    R1,&XNUM  .         SHOW LENGTH
         AGO   .ASBAL
.ASREG   LR    R1,&XNUM  .         MOVE LENGTH REGISTER VALUE OVER
.ASBAL   BAL   R14,ASASPRNT .      CALL INSUB ASPRNT
         MEND
         SPACE 2
         MACRO
&LABEL   ASTIME &ASH,&VALUE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASTIME     UPDATE TIMER,PRINT TIMING MESSAGES(ASSIST).   *
.*       &ASH      NAME OF MESSAGE, IF OMITTED UPDATE TIMER ONLY.     *
.*       &VALUE    NAME OF VALUE TO BE CONVERTED, OMITTED-NO 2ND PART *
.*       *NOTE* ONLY USABLE INSIDE MAIN PROGRAM ASSIST.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&ASH NE 'O').ASCALL1       SKIP IF OPERAND USED
&LABEL   SR    R2,R2 .             SHOW ASTIMER JUST UPDATE TIMER
         AGO   .ASCALL2            GO HAVE BAL GENREATED
.ASCALL1 ANOP
&LABEL   LA    R2,&ASH .           ENTER @ AREA TO BE PRINTED
         LA    R3,&ASH.P
         LA    R4,&ASH.L  .        LENGTH OF MESSAGE TO BE PRINTED
         AIF   ('&VALUE' EQ '').ASCNV       SKIP IF NO VALUE
         LA    R6,&ASH.N .         SHOW @ WHERE STMT/SEC GOES
         AIF   ('&VALUE' EQ '*').ASCALL2    SKIP IF VALUE ALREADY IN
         L     R7,&VALUE .         GET VALUE TO BE CONVERTED
         AGO   .ASCALL2
.ASCNV   SR    R6,R6 .             SHOW THERE IS NO 2ND PART MESSAGE
.ASCALL2 BAL   R14,ASTIMER .       CALL TEST TIMER ROUTINE
         MEND
         TITLE '*** ASSIST MACROS: ASPAGE,ASRECL,ASTIMR ***'
         MACRO
         ASPAGE &CODE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASPAGE     LINK TO SECTION OF PAGE CONTROL CODE          *
.*       &CODE IS TWO-DIGIT # GIVING DESIRED SECTION OF PAGE CONTROL  *
.*       CALL IS GENERATED ONLY IF &$PAGE = 1.                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &$PAGE              =1 PAGE CONTROL CODE EXISTS
         AIF   (NOT &$PAGE).XXEXIT SKIP IF NO PAGE CODE EXISTS
         BAL   R9,ASPAGE&CODE .    CALL SECTION OF ASPAGE##
.XXEXIT  MEND
         SPACE 2
         MACRO
         ASRECL &CODE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASRECL     LINK TO RECORD LIMIT CONTROL CODE             *
.*       &CODE IS TWO DIGIT NUMBER GIVING SECTION OF ASRECL## CALLED  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BAL   R9,ASRECL&CODE .    CALL SECTION OF ASRECL##
         MEND
         SPACE 2
         MACRO
&LABEL   ASTIMR &CODE,&TLEVEL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASTIMR     LINK TO TIMER ROUTINES IN MAIN PROGRAM ASSIST *
.*       ASTIMR ALLOWS FOR CONDITIONAL GENERATION OF CALLS TO         *
.*       VARIOUS TIMING MODULES INSIDE ASSIST MAIN PROGRAM, DEPENDING *
.*       ON THE DESIRED TIMING METHOD BEING USED.                     *
.*       &CODE  IS 2-DIGIT CODE, GIVING SECTION OF ASTIMR TO BE CALLED*
.*       &TLEVEL IS 0,1,2.  NO CODE IS CREATED IF &$TIMER<&TLEVEL.    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &$TIMER             TIMER LEVEL BEING USED
&LABEL   DS    0H
         AIF   (&$TIMER LT &TLEVEL).XXEXIT  SKIP IF NOT IN USE
         BAL   R9,ASTIMR&CODE .    CALL ENTRY OF ASTIMR## CODE
.XXEXIT  MEND
         TITLE '*** XCALL - OS LINKAGE, LITERAL VCON ***'
         MACRO
&LABEL   XCALL &ENTRY
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCALL      SUBROUTINE CALL, OS LINKAGE, LITERAL FORM.    *
.*       &ENTRY    NAME OF ENTRYPOINT TO BE CALLED.                   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
&LABEL   L     REP,=V(&ENTRY) .    GET @ ENTRY POINT
         BALR  RET,REP .           CALL THE ROUTINE
         MEND
         TITLE '*** GLOBAL SET SYMBOLS AND EQUATES ***'
**       GLOBAL SET VARIABLES - SYSGEN TYPE - &$------                *
         GBLB  &$ACCT              =1 => ACCOUNT DISCRIMINATION POSSIBL
         GBLB  &$ALIGN             =0 ==> MODEL REQUIRES DATA ALIGNED
*                                  =1 ==> MODEL DOES NOT REQUIRE ALIGN
         GBLB  &$ASMLVL            =0==>DOS,=1==>OS
         GBLC  &$BATCH             LIMIT/DFLT: BATCH(DOS) - NOBATCH(OS)
         GBLC  &$BTCC(4)           BATCH CONTROL CARD ITEMS: SEE SETC'S
         GBLA  &$BLEN              SET TO BUFFER LENGTH IN BYTES
         GBLA  &$BUFNO             THE NUMBER OF BUFFERS
         GBLB  &$CMPRS             =0 NO CMPRS CODE, =1 CMPRS OPTION
         GBLA  &$COMNT             >0 COMMENT CHECK (&$COMNT % REQ)
         GBLB  &$DATARD            =0 SOURCE,DATA THRU SYSIN ONLY(WATFV
*                                  =1 DATA MAY BE READ FROM FT05F001
*                                  (I.E.- SINGLE JOB PROCESSING-PSU)
         GBLB  &$DECSA             SHOULD ASSEMBLER PERMIT DECIMALS
         GBLB  &$DECSM             DOES MACHINE HAVE DECIMALS
         GBLB  &$DECK              =0 NO OBJ DECKS PUNCHED. =1 CAN DO
         GBLB  &$DMPAG             =1 BEGIN DUMP ON NEW PAGE, 0=> NO  J
         GBLC  &$DSKUDV            DEVICE TYPE FOR DISK DEFAULT TO
*                                  2314 DISK DRIVE
         GBLA  &$DISKU             0 FOR NO DISK UTILITY
*                                      1 FOR USER OPTION
*                                      2 FOR ALWAYS DISK
         GBLB  &$FLOTA             SHOULD ASSEMBLER ALLOW FLOATING PT
         GBLB  &$FLOTAX            SHOULD ASSEMBLER ALLOW EXTENDED FP'S
         GBLB  &$DEBUG             0==>DEBUG MODE, 1==> PRODUCTION MODE
         GBLA  &$ERNUM             # DIFFERENT ERROR MESSAGES
         GBLB  &$EXINT             = 0 REGULAR INTERPRETER
*                                  = 1 EXTENDED INTERPRETER
         GBLB  &$FLOTE             =1==> WILL INTERPRET FLT,0==> NO
         GBLB  &$FLOTEX            =1==> WILL INTERPRET EX FP'S,0==> NO
         GBLB  &$FLOTM             =1==> MACHINE HAS FLTING PT,0==> NO
         GBLB  &$FLOTMX            =1==> MACHINE HAS EX FP'S,0==> NO
         GBLA  &$FREE,&$FREEMN     DEFAULT FREE=, MINIMUM FREE= (80A) J
         GBLC  &$GENDAT            GENERATATION DATE FOR THIS ASSIST
         GBLB  &$HASPBT            =1 HASP AUTOBATCH CODE SUPPORTED   J
         GBLB  &$HEXO              =1==> HEXO ALLOWED,=0==> NOT ALLOWED
         GBLB  &$HEXI              =1==> HEXI ALLOWED,=0==> NOT ALLOWED
         GBLA  &$IDF,&$IMX         DEFAULT,MAXIMUM I= # INSTRUCTIONS
         GBLC  &$IOUNIT(8)         GLOBAL SUBLISTED VARIABLE FOR
*                                  DDNAMES IN DCB'S AND DTF'S
*
*        &$IOUNIT(1)= PRIMARY INPUT, OS=> SYSIN, DOS=> SYSIPT
*        &$IOUNIT(2)= SECONDARY INPUT, OS=> FT05F001, DOS=> SYSRDR
*        &$IOUNIT(3)= PRINTER, OS=>FT06F001, DOS=> SYSLST
*        &$IOUNIT(4)= PUNCH, OS=> FT07F001, DOS=> SYSPCH
*        &$IOUNIT(5)= DISK INTERMEDIATE, OS=>FT08F001, DOS=> IJSYS01
*        &$IOUNIT(6)= MACRO LIBRARY, OS=> SYSLIB, DOS=> N/A
*        &$IOUNIT(7)= FUTURE USE
*        &$IOUNIT(8)= FUTURE USE
*
         GBLB  &$JRM               =1 FOR PSU LOCAL SPECIAL CODE: JRM
         GBLB  &$KP26              =1 ALLOW KP=26 OR KP=29 OPTION
*                                  =0 ALLOW ONLY 029 KEYPUNCH CARDS
         GBLA  &$LDF,&$LMX         DEFAULT,MAX L= # LINES/PAGE
         GBLB  &$MACOPC            =1 ==> ALLOW OPEN CODE COND ASMBL
         GBLB  &$MACROG            =1 ==> ADD ASM G FEATURES TO ASM F
         GBLB  &$MACROH            =1 ==> ADD SOME ASM H FEATURES TO F
         GBLB  &$MACROV            OS/VS SUPPORT
         GBLB  &$MACROS            MACRO/CONDITIONAL ASSEMBLY ALLOWED
*              **NOTE** BASIC MACRO FACILITY IS ASSEMBLER F COMPATIBLE.
         GBLB  &$MACSLB            =1 ==> MACRO LIBRARY ALLOWED
         GBLC  &$MCHNE             MACHINE GENERATION OF EQUIPMENT
         GBLA  &$MMACTR            LOCAL ACTR INITIAL VALUE DEFAULT
         GBLA  &$MMNEST            MACRO NEST LIMIT DEFAULT
         GBLA  &$MMSTMG            GLOBAL MACRO STMT LIMIT DEFAULT
         GBLA  &$MODEL             MODEL NUMBER OF 360/370 BEING RUN ON
         GBLB  &$OBJIN             =0 CANNOT READ OBJECT DECK. =1 CAN
         GBLA  &$OPTMS             OPTIMIZE - 0==> MEMORY, 9==> SPEED
         GBLB  &$PAGE              =0 NO PAGE COUNT/CONTROL CODE EXISTS
*                                  =1 PAGE CONTROL &OPTIONS ALLOWED
         GBLA  &$PDF,&$PMX         DEFAULT,MAX P= # PAGES LIMIT
         GBLA  &$PDDF,&$PDMX       DEFAULT,MAX PD= # PAGES FOR DUMP
         GBLB  &$PRIVOP            =0==>NO PRIV OPS, =1==> PRIV OPS OK
         GBLA  &$PRTSIZ            MAX # CHARS IN PRINT LINE FOR ASM
         GBLB  &$PUNCH             =0 WE DON'T ACTUALLY HAVE CARD PUNCH
*                                  =1 REAL PUNCH EXISTS, POSSIBLE USE
         GBLA  &$PXDF,&$PXMX       DEFAULT,MAX PX= PAGES FOR EXECUTION
         GBLB  &$P370              =1 WILL INTERPRET PRIVELEGED S/370
         GBLB  &$P370A             SHOULD ASSEMBLER PERMIT PRIV S/370'S
         GBLA  &$RDF,&$RMX         DEFAULT,MAX R= TOTAL # RECORDS
         GBLA  &$RDDF,&$RDMX       DEFAULT,MAX RD= RECORDS FOR DUMP
         GBLA  &$RECORD            =0,1=> NO $TIRC RECREM, =2=> $TIRC
         GBLB  &$RECOVR            (ONLY USED FOR &$RECORD=2).
*              =0 => R= DOES NOT OVERRIDE $TIRC VALUE, =1 => IT DOES.
*              (AT PSU, OUTPUT CAN GO TO BAT FILES - DOESN'T COUNT).
         GBLB  &$RELOC             =0==> NO RELOCATION CODE GENERATED
         GBLA  &$REPL              0=> NO REPL,1=> LIMITED,2=> FULL
         GBLA  &$RXDF,&$RXMX       DEFAULT,MAX RD= RECORDS FOR EXECUTE
         GBLB  &$SPECIO            SPECIAL ROUTINES EXIST(TYPE=$IS+)
         GBLA  &$SYHASH            SIZE OF INITIAL PTR TABLE FOR SYMOPS
         GBLC  &$SYSTEM            SYSTEM BEGIN RUN - DOS,PCP,MFT,MVT
         GBLA  &$S370              =0==> NO S/370 INSTR INTERPRETED
*                                  =1==> S/370 INSTR INTERPRETED ON 370
*                                  =2==> S/370 INSTR INTERPRETED ON 360
         GBLB  &$S370A             SHOULD ASSEMBLER PERMIT SYSTEM 370'S
         GBLC  &$TDF,&$TMX         DEFAULT,MAX T= TOTAL TIME FOR RUN
         GBLC  &$TDDF,&$TDMX       DEFAULT,MAX TD= TIME FOR DUMP
         GBLA  &$TIMER             0==> NO TIMING AT ALL
*              1==> STIMER/TTIMER ONLY. =2==> LOCAL TIMER FOR TIMREM
         GBLC  &$TXDF,&$TXMX       DEFAULT,MAX TX= TIME FOR EXECUTION
         GBLC  &$VERSLV            VERSION #.LEVEL #
         GBLB  &$XIOS              =0==>NO XIO MACROS,=1==>XIO MACROS
         GBLB  &$XREF              CONTROL GENERATION OF XREF FACILITY
*        =1 FULL XREF, =0 NO XREF AT ALL                              A
         GBLA  &$XREFDF(3)         DEFAULT VALUES FOR FLAGS           A
*        &$XREFDF(1)=0       NO XREF(OTHERS =3MEANS COMPRESSED LISTING
*        &$XREFDF(2)=3       COLLECT MODIFY AND FETCH DEFN            A
*        &$XREFDF(3)=3       COLLECT REFERENCES MODIFY/FETCH          A
         GBLA  &$XREF#B            NUMBER OF SLOTS FOR XREF BLKS      A
         GBLB  &$XXIOS             =0==>XGET-XPUT MACROS,=1==> NO
         GBLB  &X$DDMOR          ALLOW USER OWN DDNAMES:=1==>YES,0==>NO
**       GLOBAL SET VARIABLES - INTERNAL TYPE -                       *
         GBLC  &DEBUG              DEBUG NUMBER FOR TESTING AVDEBUG
         GBLC  &ID                 IDENT GENERATION CONTROL
         GBLC  &TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO
&$BTCC(1) SETC '$'            CONTROL CHARACTER FOR BATCH CARDS       J
&$BTCC(2)  SETC  'JOB'            JOB BEGINNING INDICATOR       CPP
&$BTCC(3) SETC 'ENTRY'        BEGIN DATA CARD: SET = '' IF NONE NEEDED
&$BTCC(4)  SETC  'STOP'           TERMINATOR INDICATOR          CPP
         SPACE 1
*********  NOTE  ********  SHOULD THE VALUE OF &$BLEN BE CHANGED
*        AND THE VERSION OF ASSIST TO BE GENERATED IS A DOS SYSTEM
*        THEN BE SURE TO CHANGE THE VALUE OF THE BLKSIZE PARAMETER
*        ON THE DTFSD DEFINITION IN CSECT XXXIOCO
&$BLEN   SETA  3520                HALF-TRACK SIZE FOR IBM 2316 PACK
&$BLEN   SETA  4*(&$BLEN/4)        ROUND BLEN DOWN TO FULLWORD MULTIPLE
&$BUFNO  SETA  2                   SET FOR 4 BUFFERS
&$CMPRS  SETB  (1)                ALLOW 'CMPRS' OPTION          CPP
&$COMNT  SETA  80                  REQUIRE 80% COMMENTS, IF COMNT OPT
&$DATARD SETB  (1)                 ALLOW SINGLE JOB/TWO RDRS
&$DEBUG  SETB  (1)                 FOR QUICK RUN, KILL GENERATION
&$DECK   SETB  (1)                 ALLOW OBJECT DECKS TO BE PUNCHED
&$DECSA  SETB  (1)                 ASSEMBLER WILL ACCEPT DECIMAL INSTS
&$DECSM  SETB  (1)                 PSU 360/67 HAS DECIMAL INSTRUCTIONS
&$DISKU  SETA  1                   SET FOR USER OPTION ON DISK UTILITY
&$DMPAG  SETB  1                   ASSUME COMPLETION DUMP ON NEW PAGE J
&$EXINT  SETB  1                   USE EXTENDED INTERPRETER           L
&$FLOTA  SETB  (1)                 ASSEMBLER ALLOWS FLOATING POINT
&$FLOTAX SETB  (1)                 ASSEMBLER ALLOWS EXTENDED F. P.
&$FLOTE  SETB  (1)                 WE WILL EXECUTE FLTINGS,IF POSSIBLE
&$FLOTEX SETB  (1)                 WILL EXECUTE EXTENDED F. P., IF POSS
&$FLOTM  SETB  (1)                 PSU 360/67 HAS FLOATING POINT
&$FLOTMX SETB  (0)                 PSU 360/67 HASN'T GOT EXTENDED F. P.
&$FREE   SETA  30720               RETURN 30K TO OS/360               L
&$FREEMN SETA  2048                MINIMUM ALLOWED FREE=;  *****NOTE  J
*              IF YOU HAVE 80A ABEND'S OFTEN, RAISE THIS AS NEEDED*** J
&$GENDAT SETC  '12/02/75'          CURRENT GENERATION DATE
&$IDF    SETA  150000              100 SECS ON /67
&$IMX    SETA  150000              100 SECS ON /67
&$KP26   SETB  (1)                 ALLOW 026 KEYPUNCH
&$LDF    SETA  63                  DEFAULT 63 LINES/PAGE
&$LMX    SETA  63                  MAXIMUM OF 63 LINES/PAGE
*              MACRO SETS: ONLY SIGNIFICANT IF &$MACROS=1.
&$MACOPC SETB  1                   ALLOW OPEN CODE, AT LEAST FOR TEST
&$MACROS SETB  1                   ALLOW MACROS TO BE PROC ESSED
&$MACROG SETB  0                   NO ASM G CODE ***NOT SUPPORTED YET**
&$MACROH SETB  0                   NO ASM H CODE ***NOT SUPPORTED YET**
&$MACROV SETB  0                   NO OS/VS ASSEMBLER SUPPORT YET
&$MACSLB SETB  1                   ALLOW MACRO LIBRARY FETCH
&$MCHNE  SETC  '370'               PSU RUNS SYSTEM 370
&$MMACTR SETA  200                 DEFAULT ACTR VALUE = 200
&$MMNEST SETA  15                  DEFAULT LIMIT OF 15 DEEP IN MACS
&$MMSTMG SETA  4000                DEFAULT MAXIMUM TOTAL 4000 MAC STMTS
         SPACE 1
&$MODEL  SETA  65                  DEFAULT MODEL NUMBER
&$OBJIN  SETB  (1)                 ALLOW OBJECT DECKS TO BE READ
&$OPTMS  SETA  4                   MEDIUM OPTIMIZATION
&$PAGE   SETB  (1)                 ALLOW ALL PAGE CONTROL OPTIONS
&$PDF    SETA  10                  TEN TOTAL PAGES
&$PMX    SETA  25                  MAXIMUM POSSIBLE OF 25 TOTAL
&$PDDF   SETA  1                   NORMAL DUMP-JUST FIRST PAGE
&$PDMX   SETA  5                   MAXIMUM OF 5 PAGES FOR THE DUMP
&$PRIVOP SETB  1                   ALLOW ALL PRIVILEGED OPERATIONS
&$PRTSIZ SETA  121                 LIMIT TO 121 CHARS AS DEFAULT LIM  J
&$PUNCH  SETB  (1)                 A REAL PUNCH EXISTS
&$PXDF   SETA  5                   DEFAULT PAGES FOR EXECUTION
&$PXMX   SETA  5                   MAXIMUM PAGES FOR EXECUTION
&$RDF    SETA  100000              DEFAULT RECORDS FOR EXEC
&$RMX    SETA  100000              MAX EXECUTION RECORDS
&$RDDF   SETA  25                  DEFAULT RECORDS FOR A DUMP
&$RDMX   SETA  5000                MAXIMUM RECORDS FOR DUMP
&$RECORD SETA  1                   SHOW $TIRC RECREM CAN'T BE USED
&$RELOC  SETB  (1)                 NEED RELOC SINCE WE HAVE REPL
&$REPL   SETA  2                  ALLOW FULL REPL. OPTIONS      CEH
&$RXDF   SETA  10000               DEFAULT EXECUTION RECORDS
&$RXMX   SETA  10000               MAXIMUM EXECUTION RECORDS
&$SYSTEM SETC  'OS-MVT'            SYSTEM IS OS OPTION MVT
&$S370   SETA  2                   PSU WANTS S/370'S ON 360/67
&$S370A  SETB  (1)                 ASSEMBLER ALLOWS S/370'S
&$XIOS   SETB  (1)                 WE'RE ALLOWING XIO MACROS
&$XXIOS  SETB  0                   ALLOW XGET - XPUT
&X$DDMOR SETB  0                   ALLOW USER OWN DD NAMES
&$HEXI   SETB  (1)                 XHEXI ALLOWED THIS ASSEMBLY
&$HEXO   SETB  (1)                 XHEXO ALLOWED
&$TDF    SETC  '100'               DEFAULT SECONDS FOR RUN
&$TMX    SETC  '200'               MAX POSSIBLE SECONDS FOR RUN
&$TDDF   SETC  '.1'                DEFAULT TIME FOR DUMP
&$TDMX   SETC  '10'                MAXIMUM TIME FOR A DUMP
&$TIMER  SETA  1                   SHOW WE WANT OVERALL TIMING DONE
&$TXDF   SETC  '100'               DEFAULT TIME FOR EXECUTION
&$TXMX   SETC  '200'               MAXIMUM TIME FOR EXECUTION
&$VERSLV SETC  '4.0/A2'            VERSION LEVEL (CEH,CPP,TXM 12/02/75)
&$XREF   SETB  1                   ALLOW CROSS REFERENCE
&$XREFDF(1) SETA  3                PSU TESTING                        L
&$XREFDF(2) SETA  3                COLLECT ALL MOD/FETCH DEFN         A
&$XREFDF(3) SETA  3                COLLECT ALL MOD/FETCH REFERENCES   A
&$XREF#B SETA  10                  ALLOCATE 10 SLOTS/BLOCK            A
&$ASMLVL SETB  ('&$SYSTEM'(1,2) EQ 'OS')     SET LEVEL OF ASSEMBLER
&$FLOTE  SETB  (&$FLOTE AND &$FLOTM)         KILL GEN IF NO FLOATS
&$FLOTEX SETB  (&$FLOTEX AND &$FLOTMX) KILL GEN IF NO EXTENDED FLOATS
         AIF   (&$ASMLVL).OSGEN    SKIP IF OS GENERATION
&$BATCH  SETC  'BATCH'            DEFAULT OF DOS IS BATCH       CEH
&$IOUNIT(1) SETC  'SYSIPT'         SET DOS MAIN INPUT
&$IOUNIT(2)  SETC  'SYSRDR'        SET DOS SECONDARY INPUT
&$IOUNIT(3)  SETC  'SYSLST'        SET DOS PRINTER
&$IOUNIT(4) SETC 'SYSPCH'          SET DOS PUNCH
&$IOUNIT(5)    SETC 'SYS001'       SET DOS DISK INTERMEDIATE
&$BUFNO  SETA  2                   FOR DOS GEN INSURE ONLY 2 BUFFERS
&$DSKUDV SETC  '2314'              SET DOS DISK DRIVE TYPE
         AGO   .OSGEN1
.OSGEN   ANOP
&$BATCH  SETC  'NOBATCH'          DEFAULT FOR OS IS NOBATCH     CEH
&$IOUNIT(1)  SETC  'SYSIN'         SET OS PRIMARY INPUT
&$IOUNIT(2)  SETC  'FT05F001'      SET OS SECONDARY INPUT
&$IOUNIT(3)  SETC  'FT06F001'      SET OS PRINTER
&$IOUNIT(4)  SETC  'FT07F001'      SET OS PUNCH
&$IOUNIT(5)  SETC  'FT08F001'      SET OS DISK INTERMEDIATE
&$IOUNIT(6)  SETC  'SYSLIB'        SET OS MACRO LIBRARY
.OSGEN1  ANOP
&ID      SETC  'NO'                SET NO ID FOR TIME BEING
         AIF   (&$DEBUG).EQU1      LEAVE NO ID IF PRODUCTION PROG
&ID      SETC  '*'                 DEBUG==> GENERATE ID'S AT ENTRIES
.EQU1    ANOP
         ASSYSGEN ,                CALL TO POSSIBLY RESET SET VARIABLES
&$P370   SETB  (&$PRIVOP AND (&$S370 NE 2)) KILL GEN IF NO PRIV OR S370
&$P370A  SETB  (&$PRIVOP AND &$S370A) NO PRIV 370'S IF NO PRIV OR S370
&$ALIGN  SETB  (&$ALIGN OR (&$S370 EQ 1 OR &$MODEL EQ 85)) FORCE VALUE
&$MACSLB SETB  (&$MACSLB AND &$MACROS)  REMOVE LIBRARY IF NO MACROS   J
&$RELOC  SETB  (&$RELOC OR (&$REPL NE 0))  IF REPL, MAKE SURE RELOC   J
&$HASPBT SETB  (&$HASPBT AND &$ASMLVL)  ELIM HASP IF NOT OS SYSTEM    J
         SPACE 2
         TITLE '*** OPCODTB DSECT - OPCODE CONTROL TABLE ENTRY ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: OPCODTB    DESCRIBES 1 ENTRY IN OPOCDE TABLE              *
*        LOCATION: ELEMENTS OF TABLE IN CSECT OPCOD1 OF ASSEMLBER.    *
*        GENERATION: 1 CALL TO MACRO OPG CREATES AN ELEMENT.          *
*        SECTIONS OPCTYPE,OPCHEX,OPCMASK CORRESPOND TO SIMILARLY-NAMED*
*        SECTIONS OF DUMMY SECTION RCODBLK. SEE CSECT OPCOD1.         *
*        NAMES: OPC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
OPCODTB  DSECT
OPCTYPE  DS    C                   TYPE BYTE FOR MNEMONIC
OPCHEX   DS    C                   HEX CODE FOR MACHINE OPS/SUBCODE
OPCMASK  DS    C                   MASK/ALIGNMENT(MACHINE) / SUBCODE
OPCMNEM  DS    CL8                 MNEMONIC- FROM 1 TO 8 CHARACTERS
         SPACE 4
* * * * * EQUATES USED FOR BCR INSTRUCTIONS * * * * * * * * * * * * * *
H        EQU   2                   HIGH
L        EQU   4                   LOW
E        EQU   8                   EQUAL
NH       EQU   13                  NOT HIGH
NL       EQU   11                  NOT LOW
NE       EQU   7                   NOT EQUAL
O        EQU   1                   ONES OR OVERFLOW
P        EQU   2                   POSITIVE
M        EQU   4                   MINUS
Z        EQU   8                   ZERO
NP       EQU   13                  NOT POSITIVE
NM       EQU   11                  NOT MINUS
NZ       EQU   7                   NOT ZERO
NO       EQU   14                  NOT ONES OR NOT OVERFLOW
         SPACE 1
$CHN     EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT
$        EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT
         SPACE 1
$PRGFILC EQU   C'5'                CHAR USED TO FILL UNUSED PROG CORE
$PRGFILR EQU   C'4'                CHAR USED TO FILL USER REGS AT FIRST
         TITLE 'DSECT***X$SLOT*** FORMAT OF AN ENTRY FOR XGET-XPUT MON'
X$SLOT   DSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->DSECT: X$SLOT FORMAT FOR XGET-XPUT MONITOR TABLE                  *
*        USED IN XDDGET AND XDDPUT TO CONTROL USE OF CERTAIN          *
*           DD NAMES BY USER WITH XGET-XPUT PERMITTED.                *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
X$SLNAME DS    CL8                 DDNAME
X$SLFLAG DS    CL1                 FLAG BITS
X$SLWAY  DS    CL1
X$SLLONG EQU   *-X$SLNAME          GET LENGTH OF ENTRY
X$SLOPEN EQU   X'C0'               THESE BITS OFF IF FILE NOT OPEN
X$SLXGET EQU   X'40'               INPUT FILE
X$SLXPUT EQU   X'80'               OUTPUT FILE
X$SLPERM EQU   X'01'               PERMANENT FILE NAME
X$SLCLOS EQU   X'3F'               OPPOSITE OF X$SLOPEN
X$SLPOIN EQU   X'0C'               ON FOR POSSIBLE INPUT OR OUTPUT
X$SLXGPT EQU   X'00'               BITS OFF MEAN USE XGET-XPUT
         TITLE '*** REGISTER EQUATES AND CONVENTIONS ***'
*        *** ABSOLUTE REGISTER EQUATES ***                            *
F0       EQU   0                   FLOATING POINT REGISTER 0          *
F2       EQU   2                   FLOATING POINT REGISTER 2          *
F4       EQU   4                   FLOATING POINT REGISTER 4          *
F6       EQU   6                   FLOATING POINT REGISTER 6          *
         SPACE 1
R0       EQU   0                   SPECIAL WORK REGISTER 0            *
R1       EQU   1                   SPECIAL WORK REGISTER 1            *
R2       EQU   2                   SPECIAL WORK REGISTER 2            *
R3       EQU   3                   GENERAL WORK REGISTER 1            *
R4       EQU   4                   GENERAL WORK REGISTER 2            *
R5       EQU   5                   GENERAL WORK REGISTER 3            *
R6       EQU   6                   GENERAL WORK REGISTER 4            *
R7       EQU   7                   PARAMETER REGISTER 1               *
R8       EQU   8                   PARAMETER REGISTER 2               *
R9       EQU   9                   PARAMETER REGISTER 3               *
R10      EQU   10                  PARAMETER REGISTER 4               *
R11      EQU   11                  PARAMETER REGISTER 5               *
R12      EQU   12                  ASSEMBLER TABLE POINTER-READ ONLY  *
R13      EQU   13                  SAVE AREA POINTER/BASE REG FOR SOME*
R14      EQU   14                  RETURN ADDRESS USED IN CALLS       *
R15      EQU   15                  ENTRY POINT ADDRESS/OFTEN USED BASE*
         SPACE 1
*        *** SYMBOLIC REGISTER EQUATES ***                            *
RW       EQU   R3                  GENERAL WORK REGISTER 1            *
RX       EQU   R4                  GENERAL WORK REGISTER 2            *
RY       EQU   R5                  GENERAL WORK REGISTER 3            *
RZ       EQU   R6                  GENERAL WORK REGISTER 4            *
RA       EQU   R7                  PARAMETER REGISTER 1               *
RB       EQU   R8                  PARAMETER REGISTER 2               *
RC       EQU   R9                  PARAMETER REGISTER 3               *
RD       EQU   R10                 PARAMETER REGISTER 4               *
RE       EQU   R11                 PARAMETER REGISTER 5               *
RAT      EQU   R12                 ASSEMBLER TABLE POINTER-READ ONLY  *
RSA      EQU   R13                 SAVE AREA POINTER/BASE REG FOR SOME*
RET      EQU   R14                 RETURN ADDRESS USED IN CALLS       *
REP      EQU   R15                 ENTRY POINT ADDRESS/OFTEN USED BASE*
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        *** REGISTER CONVENTIONS ***                                 *
*        A. REGISTERS R0-R6 ARE PROTECTED ACROSS CALLS.               *
*        B. REGISTER RAT(R12) MAY NOT BE CHANGED BY ANY ROUTINE.      *
*        C.REGISTERS R7-R11 (RA-RE) ARE COMPLETELY UNPROTECTED ACROSS *
*         CALLS, AND MAY BE USED BY ANY ROUTINE .  PARAMATERS WILL    *
*         NORMALLY BE PLACED TO USE FIRST RA, THEN RB, ETC.  IF MORE  *
*         THAN 5 PARAMATERS ARE REQUIRED, REGISTER RE WILL POINT TO   *
*         AN OS TYPE PARAMATER LIST.                                  *
*        D. EXCEPT FOR THE ABOVE, THE CONVENTIONS ARE EXACTLY THE     *
*         SAME AS STANDARD IBM CONVENTIONS WITH REGARD TO LINKAGE,    *
*         SAVE AREA STRUCTURE, REQUIREMENTS, ETC.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE '*** ERROR CODE EQUATE SYMBOLS - $ER----- ***'
ALIGN    $SERR 'W-ALIGNMENT ERROR-IMPROPER BOUNDARY',000
ENTRY    $SERR 'W-ENTRY ERROR-CONFLICT OR UNDEFINED',001
EXTRN    $SERR 'W-EXTERNAL NAME ERROR OR CONFLICT',002
RGNUS    $SERR 'W-REGISTER NOT USED',003
ODDRG    $SERR 'W-ODD REGISTER USED-EVEN REQUIRED',004
NOEND    $SERR 'W-END CARD MISSING-SUPPLIED',005
ADDR     $SERR 'ADDRESSIBILITY ERROR',100
CNLNG    $SERR 'CONSTANT TOO LONG',101
CNTYP    $SERR 'ILLEGAL CONSTANT TYPE',102
CONT     $SERR 'CONTINUATION CARD COLS. 1-15 NONBLANK',103
CONTX    $SERR 'MORE THAN 2 CONTINUATION CARDS',104
CXREL    $SERR 'COMPLEX RELOCATABILITY ILLEGAL',105
DCEXT    $SERR 'TOO MANY OPERANDS IN DC',106
DPCSE    $SERR 'MAY NOT RESUME SECTION CODING',107
DUPLF    $SERR 'ILLEGAL DUPLICATION FACTOR',108
EXGTA    $SERR 'EXPRESSION TOO LARGE',109
EXLTA    $SERR 'EXPRESSION TOO SMALL',110
ICNOP    $SERR 'INVALID CNOP OPERAND(S)',111
ILLAB    $SERR 'LABEL NOT ALLOWED',112
ILORG    $SERR 'ORG VALUE IN WRONG SECTION OR TOO LOW',113
INVCN    $SERR 'INVALID CONSTANT',114
INVDM    $SERR 'INVALID DELIMITER',115
INVF     $SERR 'INVALID FIELD',116
INVSY    $SERR 'INVALID SYMBOL',117
IVOPC    $SERR 'INVALID OP-CODE',118
MULDF    $SERR 'PREVIOUSLY DEFINED SYMBOL',119
NEABS    $SERR 'ABSOLUTE EXPRESSION REQUIRED',120
NODLM    $SERR 'MISSING DELIMITER',121
NOIMP    $SERR 'FEATURE NOT CURRENTLY IMPLEMENTED',122
NOOPR    $SERR 'MISSING OPERAND',123
NONAM    $SERR 'LABEL REQUIRED',124
RELOC    $SERR 'RELOCATABLE EXPRESSION REQUIRED',126
SDINV    $SERR 'INVALID SELF-DEFINING TERM',127
START    $SERR 'ILLEGAL START CARD',128
TLIT     $SERR 'ILLEGAL USE OF LITERAL',129
UNDEF    $SERR 'UNDEFINED SYMBOL',130
UNRV     $SERR 'UNRESOLVED EXTERNAL REFERENCE',131
VILCH    $SERR 'ILLEGAL CHARACTER',132
VPARN    $SERR 'TOO MANY PARENTHESIS LEVELS',133
VRELO    $SERR 'RELOCATABLE VALUE USED WITH * OR /',134
VSYNT    $SERR 'SYNTAX',135
VTMTR    $SERR 'TOO MANY TERMS IN EXPRESSION',136
VUNEX    $SERR 'UNEXPECTED END OF EXPRESSION',137
INTPT    $SERR 'STATEMENT CAUSED INTERRUPT',138
         SPACE 1
         AIF   (NOT &$MACROS).SERR1         SKIP IF NO MACROS
ILOPR    $SERR 'OPERAND NOT ALLOWED',201
STMNA    $SERR 'STATEMENT OUT OF ORDER',202
SSDIM    $SERR 'SET SYMBOL DIMENSION ERROR',203
INSBV    $SERR 'INVALID NBR OF SUBSCRIPTS',204
ILCNV    $SERR 'ILLEGAL CONVERSION',205
MISQU    $SERR 'MISSING QUOTES IN CHAR EXPR',206
ILMNM    $SERR 'ILLEGAL OR DUP MACRO NAME',207
MXDMD    $SERR 'OPRND NOT COMPATIBLE WITH OPRTR',208
UNDKW    $SERR 'UNDFND OR DUP KEYWORD',209
EXMAC    $SERR 'MNEST LIMIT EXCEEDED',210
ILAT     $SERR 'ILLEGAL ATTRIBUTE USE',211
MEXST    $SERR 'GENERATED STMT TOO LONG',212
OVRGN    $SERR 'GENERATED STMTS OVERWRITTEN',298
.SERR1   ANOP
         TITLE '*** INSTRUCTION TYPES AND CODES ***'
* * * * * INSTRUCTION TYPES FOR MACHINE INSTRUCTIONS(OPCTYPE FIELD)   *
$IA      EQU   X'00'               (OPCHEX)==> PREFIX FOR MACHINE OPS
$RRM     EQU   2                   RR EXTENDED MNEMONICS -R2
$RXM     EQU   4                   RX EXTENDED MNEMONICS - D2(X2,B2)
$RR      EQU   6                   NORMAL RR - R1,R2
$RX      EQU   8                   NORMAL RX - R1,D2(X2,B2)
$RS      EQU   10                  RS(LM,STM,BXH,BXLE)-R1,R3,D2(B2)
$RSH     EQU   12                  RS(SHIFTS) - R1,D2(B2)
$SI      EQU   14                  SI NORMAL - D1(B1),I2
$SS      EQU   16                  SS-1 LENGTH- D1(L,B1),D2(B2)
$SS2     EQU   18                  SS-2 LENGTHS - D1(L1,B1),D2(L2,B2)
$RSO     EQU   20                  ODD RR-SI'S (SPM,SVC,LPSW,SSM,TS,IO)
$SPC     EQU   22                  SPECIAL(FAKE) INSTRUCTIONS-XREAD,ETC
$ICTMX   EQU   11                  MAXIMUM IC TYPE / 2
         SPACE 1
IAA      EQU   X'10'               (RCMASK) - R1 REQUIRED TO BE EVEN
IAL1     EQU   X'00'               (RCMASK) - LITERAL OK-OP1==>NEVER!
IAL2     EQU   X'08'               (RCMASK) - LITERAL PERMITTED-OP2
IAB      EQU   X'20'               (RCMASK) - R2 REQUIRED TO BE EVEN
         SPACE 1
* * * * * ASSEMBLER INSTRUCTION TYPES - $I------ (OPCTYPE FIELD)  * * *
$IB      EQU   X'C0'               OPCODTB ENTRY TAG BITS FOR AM INST
*              *NOTE* SECTIONS MO, MT DEPEND ON $IB HAVING THIS VALUE *
$IUSING  EQU   2                   USING INSTRUCTION
$IDROP   EQU   4                   DROP INSTRUCTION
$ISTART  EQU   6                   START INSTRUCTION
$ICSECT  EQU   8                   CSECT INSTRUCTION
$IDSECT  EQU   10                  DSECT INSTRUCTION
$IENTRY  EQU   12                  ENTRY INSTRUCTION
$IEXTRN  EQU   14                  EXTRN INSTRUCTION
$IEQU    EQU   16                  EQU INSTRUCTION
$IDC     EQU   18                  DC INSTRUCTION
$IDS     EQU   20                  DS INSTRUCTION
$ICCW    EQU   22                  CCW INSTRUCTION
$ITITLE  EQU   24                  TITLE INSTRUCTION
$IEJECT  EQU   26                  EJECT INSTRUCTION
$ISPACE  EQU   28                  SPACE INSTRUCTION
$IPRINT  EQU   30                  PRINT INSTRUCTION
$IORG    EQU   32                  ORG INSTRUCTION
$ILTORG  EQU   34                  LTORG INSTRUCTION
$ICNOP   EQU   36                  CNOP INSTRUCTION
$IEND    EQU   38                  END INSTRUCTION
$IDEBUG  EQU   40                  DEBUG FLAG SETTING ROUTINE
         SPACE 1
IBNONAM  EQU   X'40'               (OPCHEX)==> LABEL NOT PERMITTED
IBNENAM  EQU   X'20'               (OPCHEX)==> LABEL IS REQUIRED
IBOMOP   EQU   X'10'               (OPCHEX)==> OPERAND MAY BE OMITTED
IBMOSPEC EQU   X'08'               (OPCHEX,RCHEX)==> REQUIRES SPECIAL
*              HANDLING OF SOME KIND IN MOCON1 (END, ALL PRINT CTRL).
IBMOPRCT EQU   X'04'               (OPCHEX,RCHEX)==> IS SOME KIND OF
*              PRINT CNTRL, SO REQUIRES SPEC HANDLING BY MOCON1.
IBMOPRCX EQU   IBMOSPEC+IBMOPRCT   (OPCHEX,RCHEX)==> PRT CNTRL
         TITLE '*** MISCELLANEOUS EQUATE SYMBOLS ***'
$ESDSECT EQU   1                   (AVCESDID)-IN DSECT, EVEN=>CSECT
$IS      EQU   X'40'               OPCTYPE CODE FOR SPECIALS
$IM      EQU   X'80'               OPCTYPE CODE FOR MACROS
         SPACE 1
$IBPON   EQU   X'80'               (AVPRINT,AVPRINT1)-PRINT ON
$IBPGEN  EQU   X'40'               (AVPRINT,AVPRINT1)- PRINT GEN
$IBPDAT  EQU   X'20'               (AVPRINT,AVPRINT1)- PRINT DATA
*                                  PRINT DATA, NODATA ONLY FOR COMPATIB
$IBPLIST EQU   X'02'               (AVPRINT)==> LIST IS ON
         SPACE 1
$IBSTAR1 EQU   X'80'               (AVTAGS1)==> START NO LONGER ALLOWED
$IBDSEC1 EQU   X'40'               (AVTAGS1)==> PROCESSING DSECT NOW
*              IF THIS FLAG IS NOT SET, CURRENT SECTION IS A CSECT.   *
$IBPRCD1 EQU   X'20'               (AVTAGS1) - PRIVATE CODE HAS OCCURRD
         SPACE 1
$INEND2  EQU   B'10000000'         (AVTAGS2)==> ENDFILE ON SYSIN-INCARD
         SPACE 1
$OUMACH  EQU   0                   CODE FOR MACHINE INSTRUCTIONS
$OUCONS  EQU   2                   CODE FOR CONSTANTS
$OULIST  EQU   4                   LISTING CONTROL INSTRUCTONS
$OUCOMM  EQU   6                   COMMENTS,ETC WITHOUT LOCATION COUNTE
         AIF   (NOT &$MACROS).NOMMMMM  SKIP IF NO MACROS
* * * * * * * * EQUATES FOR MACRO-TYPE OPCODES* * * * * * * * * * * * *
         SPACE 2
$MACRO   EQU   2                   MACRO DECLARATION
$GBLA    EQU   4                   GLOBAL ARITHMETIC DECLARATION
$GBLB    EQU   6                   GLOBAL BINARY DECLARATION
$GBLC    EQU   8                   GLOBAL CHARACTER DECLARATION
$LCLA    EQU   10                  LOCAL ARITHMETIC DECLARATION
$LCLB    EQU   12                  LOCAL BINARY DECLARATION
$LCLC    EQU   14                  LOCAL CHARACTER DECLARATION
$ACTR    EQU   16                  ACTR INSTRUCTION
$SETA    EQU   18                  SET ARITHMETIC INSTRUCTION
$SETB    EQU   20                  SET BINARY INSTRUCTION
$SETC    EQU   22                  SET CHARACTER INSTRUCTION
$AIF     EQU   24                  AIF INSTRUCTION
$AGO     EQU   26                  AGO INSTRUCTION
$ANOP    EQU   28                  ANOP INSTRUCTION
$MNOTE   EQU   30                  MNOTE INSTRUCTION
$MEXIT   EQU   32                  MEXIT INSTRUCTION
$MEND    EQU   34                  MEND INST
         SPACE 1
$ARITH   EQU   4                   ARITHMETIC VLAUE
$BOOL    EQU   8                   LOGICAL VALUE
$CHAR    EQU   12                  CHARACTER VALUE
.NOMMMMM ANOP
         SPACE 1
         TITLE '*** ICBLOCK - MACHINE INSTRUCTION CODE BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ICBLOCK    MACHINE INSTRUCTION OBJECT CODE BLOCK.         *
*        THIS DSECT IS USED TO TRANSMIT DATA FROM ICMOP2 CSECT TO     *
*        OUTPT2 FOR PRINTING MACHINE INSTRUCTIONS.                    *
*        LOCATION: TABLE ICYBLOCK IN CSECT ICMOP2 OF ASSEMBLER.       *
*        NAMES: ICB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ICBLOCK  DSECT
$ICBEA1  EQU   X'40'               (ICBFLAG) ==> EA1 EXISTS
$ICBEA2  EQU   X'20'               (ICBFLAG) ==> EA2 EXISTS
         SPACE 1
ICBEA1   DS    F                   1ST ADDRESS
ICBEA2   DS    F                   2ND ADDRESS
ICBOPR1R DS    0H                  OPCODE - R1 - R2
ICBOP    DS    C                   HEX OPCODE
ICBR1R2  DS    C                   REGISTERS OR LENGTHS OR IMMED.FIELD
ICBOPN1  DS    H                   1ST BASE DISPLACEMENT IN INSTRUCTION
ICBOPN2  DS    H                   2ND BASE DISPLACEMENT IN INSTRUCTION
ICBFLAG  DS    C                   FLAG BYTE FOR EXISTENCE OF EAU,EA2
         TITLE '*** SYMSECT DSECT - SYMBOL TABLE ENTRIES ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: SYMSECT    ASSEMBLER SYMBOL TABLE ENTRY.                  *
*        CREATED BY ENTRY SYENT1 OF CSECT SYMOPS, AND HAS VALUES ADDED*
*        BY MOCON1,IBASM1, FOR VALUE, SECTION ID, LENGTH ATTRIBUTE,   *
*        AND BY ESDOPRS FOR SPECIAL ATTRIBUTES(CSECT,ETC).            *
*        LOCATION:  FREEAREA HIGH END ($ALLOCH'D).                    *
*        NAMES: SY------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
SYMSECT  DSECT
$SYDEF   EQU   X'80'               (SYFLAGS) - SYMBOL HAS BEEN DEFINED
$SYENT   EQU   X'40'               (SYFLAGS) - DECLARED AN ENTRY
$SYCSE   EQU   X'20'               (SYFLAGS) - DECLARED A CSECT
$SYDSE   EQU   X'10'               (SYFLAGS) - DECLARED A DSECT
$SYEXT   EQU   X'08'               (SYFLAGS) - DECLARED EXTRN
$SYXRMD  EQU   X'02'               (SYFLAGS) - XREF HAS MODIFY REFERS A
$SYXRFT  EQU   X'01'               (SYFLAGS) - XREF HAS FETCH REF     A
         SPACE 1
SYLINK   DS    0F                  ADDRESS OF NEXT SYMBOL IN CHAIN
SYHASH2  DS    C                   SECONDARY HASH CODE OF NEXT SYMBOL
SYLINKA  DS    CL3                 ADDRESS REFERRED TO BY SYLINK
SYVALUE  DS    F                   VALUE OF THE SYMBOL
SYESDID  DS    C                   ESDID OF THE SYMBOL
SYLENG   DS    C                   LENGTH ATTRIBUTE OF THE SYMBOL
SYFLAGS  DS    C                   FLAG BYTE
SYCHARS  DS    C                   #-1 OF BYTES IN SYMBOL (RANGE:0-7)
SYMBOL   DS    CL8                4-8 CHARS OF SYMBOL,R-PADDED WITH BLK
         TITLE '*** CNCBLOCK DSECT - CONSTANT CODE BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: CNCBLOCK   CONSTANT CODE BLOCK-DC'S, LITERALS.            *
*        LOCATION: EACH CNCBLOCK IS CREATED IN AREA COBLK OF CODTL1.  *
*        1 OR MORE CNCBLOCKS MAY BECOME PART OF THE RCODBLK CREATED   *
*        IN AREA IBRCB BY IBASM1, AND 1 CNCBLOCK BECOMES PART OF THE  *
*        ENTRY FOR EACH DISTINCT LITERAL(SEE LTLENTRY DSECT, LTOPRS   *
*        CSECT.)                                                      *
*        NAMES: CNC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
CNCBLOCK DSECT
* * * * * CONSTANT TYPE,DESCRIPTOR CODES-USED IN CNCBLOCK AREAS * * * *
$CNA     EQU   0                   A-TYPE CONSTANT TYPE CODE
$CNB     EQU   1                   B-TYPE CONSTANT TYPE CODE
$CNC     EQU   2                   C-TYPE CONSTANT TYPE CODE
$CND     EQU   3                   D-TYPE CONSTANT TYPE CODE
$CNE     EQU   4                   E-TYPE CONSTANT TYPE CODE
$CNF     EQU   5                   F-TYPE CONSTANT TYPE CODE
$CNH     EQU   6                   H-TYPE CONSTANT TYPE CODE
$CNP     EQU   7                   P-TYPE CONSTANT TYPE CODE
$CNV     EQU   8                   V-TYPE CONSTANT TYPE CODE
$CNX     EQU   9                   X-TYPE CONSTANT TYPE CODE
$CNZ     EQU   10                  Z-TYPE CONSTANT TYPE CODE
$CNT$N   EQU   11                  1 MORE THAN MAX $CN# CODE=# TYPES
$CNALN   EQU   X'80'               (CNCTYP)==> ALIGNMENT REQUIRED
$CNVLN   EQU   X'40'               (CNCTYP)==> VARIABLE LENGTH (LIKE C)
$CNMUL   EQU   X'20'               (CNCTYP)==> MULTIPLE CONSTANTS OK
$CNERR   EQU   X'10'               (CNCTYP)==> RB HAS ERR CODE-PASS 2
         SPACE 1
CNCTYP   DS    C                   FLAGS AND TYPE CODE
CNCLEN   DS    C                   LENGTH-1 OF CONSTANT
CNCSCAN  DS    C                   SCAN POINTER TO 1ST CHAR OF 1ST CONS
CNCNUM   DS    C                   NUMBER OF CONSTANTS IN OPERAND
CNCDUP   DS    H                   DUPLICATION FACTOR
CNCTOT   DS    H                   TOTAL LENGTH OF OPERAND(<=65K)
CNC$LEN  EQU   *-CNCBLOCK          LENGTH OF CONSTANT CODE BLOCK
         TITLE '*** RECORD BLOCKS - RCODBLK, REBLK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RCODBLK    RECORD CODE BLOCK - VARIABLE DATA FOR STMT.    *
*        AN RCODBLK IS CREATED BY EITHER IAMOP1 OR IBASM1 DURING      *
*        ASSEMBLER PASS 1 FOR EVERY STATEMENT WITH AN ACCEPTABLE      *
*        OPERATION CODE.  IT CONTAINS VARIABLE INFORMATION WHICH      *
*        DEPENDS ON THE TYPE OF INSTRUCTION, AND MAY INCLUDE HEX      *
*        MACHINE CODES AND MASKS, ALIGNMENT INFORMATION, LITERAL      *
*        ADDRESSES, EQU SYMBOL ADDRESSES, AND 1 -10 CNCBLOCKS FOR DC  *
*        COMMANDS.  THE MOST COMMON LENGTHS ARE 8 AND 12.             *
*        LOCATION: CREATED IN AREA IARCB(IN IAMOP1) OR IBRCB(IN       *
*        IBASM1). STORED IN LOW AREA AFTER ITS RSBLOCK BY UTPUT1.     *
*        FOR MACHINE INSTRUCTIONS, MOVED TO ICRCB(IN ICMOP2) IN PASS 2*
*        NAMES: RC------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RCODBLK  DSECT
RCLENG   DS    C                   LENGTH OF RCB
RCLOC    DS    AL3                 LOCATION COUNTER VALUE
RCTYPE   DS    C                   PRIMARY INSTRUCTION TYPE
RCHEX    DS    C                   HEX CODE FOR MACH OPS, 2ND CODE OTHR
RCMASK   DS    C                   MASK-ALIGNMENT FOR MACH OPS
RCLQ     DS    C                   SLOT FOR LENGTH ATTRIBUTE L'*
RC$LEN   EQU   *-RCODBLK-1         NORMAL LENGTH,WITHOUT LITERAL/EQU
RCLITEQ  DS    A                   LITERAL/EQU ADDRESS
RC$LEN2  EQU   *-RCODBLK-1         LENGTH-1 INCLUDING EQU OR LITERAL
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: REBLK      SCAN POINTER/ERROR CODE PAIR BLOCK.            *
*        LOCATION: AVREBLK(AVWXTABL DSECT), CREATED BY ERRTAG SUBR.   *
*        MOVED INTO LOW AREA FOLLOWING CORRESPONDING RCODBLK. MOVED   *
*        BY UTGET2 BACK INTO AVREBLK AREA IN AVWXTABL DURING PASS 2.  *
*        *NOTE* ONLY EXISTS FOR STATEMENTS HAVING 1 OR MORE ERROR OR  *
*        WARNING MESSAGES ATTACHED TO IT.                             *
*        NAMES: REB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
REBLK    DSECT
REBLN    DS    C                   LENGTH-1 OF ERROR BLOCK
$ERREBMX EQU   4                   MAX # ERROR MESSAGES KEPT PER STMT
*              THERE IS 1 REBLN, UP TO $ERREBMX REBSCN-REBERR PAIRS.
REBSCN   DS    C                   SCAN OFFSET POINTER TO ERROR
REBERR   DS    C                   ERROR CODE
         TITLE '*** RECORD BLOCKS - RSBLOCK,RSCBLK,RSOURCE ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSBLOCK    RECORD SOURCE BLOCK-SOURCE CODE, FLAGS.        *
*        AN RSBLOCK IS CREATED FOR EVERY SOURCE STATEMENT BY INCARD   *
*        AND CONTAINS DATA COMMON TO EVERY STATEMENT, SUCH AS 1-3     *
*        SOURCE CARD IMAGES, FLAGS FOR EXISTENCE OF OTHER RECORD      *
*        BLOCKS.  ONLY RECORD BLOCK NECESSARY FOR A SOURCE STATEMENT. *
*        LOCATION: CREATED IN AVRSBLOC (AVWXTABL DSECT) BY INCARD,    *
*        WITH MODIFICATION BY ERRTAG AND MOCON1. MOVED TO LOW  END    *
*        OF FREEAREA BY UTPUT1, AND REMAINS THERE.                    *
*        NAMES: RSB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSBLOCK  DSECT
$RSMXCRD EQU   3                   MAXIMUM # OF CARDS IN 1 STATEMENT
$RCBX    EQU   X'80'               (RSBFLAG)==>RECORD CODE BLOCK EXISTS
$REBX    EQU   X'40'               (RSBFLAG)==>RECORD ERROR BLOCK EXIST
$RSCX    EQU   X'20'               (RSBFLAG)==>RECORD SOURCE CODE BLOCK
*              FOLLOWING MAINLY INVOLVED WITH MACRO PROC.
$RSBGENR EQU   X'08'               (RSBFLAG)==> GENERATED STMT
*              I.E., SHOULD BE PRINTED WITH + BEFORE STMT.
$RSBNP## EQU   X'04'               (RSBFLAG)==> DO NOT PROCESS FURTHER,
*              EXCEPT TO PRINT.  HAS STMT #. (COMMENTS, OUTER MACROS).
$RSBNPNN EQU   X'02'               (RSBFLAG)==> DO NOT PROCESS FURTHER,
*              EXCEPT PRINT.  NO STMT #.  (INNER MACROS, SPEC ERRORS).
$RSBMERR EQU   X'01'               (RSBFLAG)==> ERROR RECORD, GIVEN
*              SPECIAL TREATMENT IN OUTPT2, COUNTS AS ERROR.  NOTE:
*              IF THIS FLAG ON, $RSBNPNN SHOULD BE ALSO.
         SPACE 1
RSBLENG  DS    C                   LENGTH-1 OF THIS RSB(0-216)
RSBFLAG  DS    C                   FLAG BITS FOR THIS RSB
RSBNUM   DS    C                   NUMBER OF CARDS USED IN RSB
RSBSCAN  DS    C                   SCAN POINTER OFFSET TO OPERAND FLD
RSB$L    EQU   *-RSBLOCK           LENGTH OF STANDARD PART OF RSBLOCK
RSBSOURC DS    0CL71               SPACE FOR 3 CARD IMAGES
RSBLOPC  DS    CL71                1ST CARD IMAGE
RSB$LN1  EQU   *-RSBLOCK-1         LENGTH-1 DEFAULT VALUE
         DS    2CL71               0-2 MORE CARD IMAGES
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSCBLK     RECORD SOURCE-CONTINUATIONS, SEQUENCE #'S      *
*        CREATED BY INCARD FOR ANY STATEMENT HAVING EITHER SEQUENCE   *
*        NUMBERS OR CONTINUATION PUNCHES.                             *
*        LOCATION: CREATED BY INCARD IN AVRSCBLK(AVWXTABL) DURING     *
*        ASSEMBLY PASS 1. MOVED TO LOW END OF DYNAMIC AREA BY UTPUT1, *
*        FOLLOWING CORRESPONDING REBLK(IF ONE EXISTS).  REMAINS IN    *
*        THAT AREA FOR REST OF PROCESSING.                            *
*        NAMES: RSC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSCBLK   DSECT
RSCLENG  DS    C                   LENGTH-1 OF THIS RSCBLK
* * * * * THE PREVIOUS ENTRIES ARE FIXED,THERE MAY BE UP TO 3 OF REST *
RSCILEN  DS    C                   LENGTH OF INDIVIDUAL CARD IMAGE
RSCONSQ  DS    CL9                 CONTINUATION-SEQUENCE NUMBER COLUMNS
RSC$LEN  EQU   *-RSCILEN           LENGTH OF 1 ENTRY OF VARIABLE PART
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSOURCE    DESCRIPTION OF A SINGLE SOURCE CARD            *
*        USED FOR INPUT PROCESSING BY SUBROUTINE INCARD.              *
*        LOCATION: AVRSBLOC(AVWXTABL) DURING CREATION OF RSBLOCK.     *
*        NAMES: RSO-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSOURCE  DSECT
RSOLOPC  DS    CL15                LABEL+OPCODE,NORMAL
RSOOPRCM DS    CL56                OPERAND+COMMENTS FIELD
RSOL1    EQU   *-RSOLOPC           LENGTH OF 1ST OR ONLY SOURCE CARD
RSOLC    EQU   *-RSOOPRCM          LENGTH OF SOURCE CONTINUATION CARD
RSOCONT  DS    C                   CONTINUATION COLUMN
RSOSEQN  DS    CL8                 SEQUENCE NUMBERS,IF ANY
         AIF   (NOT &$MACROS).AVNMCCC           SKIP IF NO MACROS
         TITLE 'MACLIB DSECT AND EQUS'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT:  MACLIB   THIS DSECT GIVES THE FORMAT OF A MACRO          *
*         LIBRARY ENTRY.                                              *
*        NOTE: THIS IS ONLY MACRO DSECT NEEDED OUTSIDE MACRO PROCESSOR*
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MACLIB   DSECT
MCLIBNXT DS    F                   POINTER TO NEXT ENTRY
MCLBNMLN DS    C                   LENGTH OF MACRO LIB ENTRY NAME
MCLBNAM  DS    CL8                 MACRO LIBRARY ENTRY NAME
MCLBFLGS DS    0C                  MACRO LIBRARY ENTRY FLAGS
MCLBTAGS DS    C                   MACLIB ENTRY FLAG BYTE
MCLBFLG2 DS    C                   MACRO LIBRARY ENTRY FLAGS
MCLBFLG3 DS    C                   MACRO LIBRARY ENTRY FLAGS
MCPOPRNB DS    H                   NUMBER OF OPERANDS (NOT LABEL FLD)
MCKOPRNB DS    H                   NUMBER OF KEYWORD OPERANDS
MCDDVPNT DS    F                   LINK TO LOCAL DICT DOPE VECTORS
MCLOCDLN DS    F                   LENGTH OF LOCAL DICTIONARY
MCLDNBRE DS    F                   # OF LOCAL DICT. ENTRIES
MCPARPNT DS    F                   POINTER TO PARAMETER DOPE VECTORS
MCCODLNK DS    F                   POINTER TO DEFINITION CODE
$LMACLIB EQU   *-MACLIB            LENGTH OF MACLIB ENTRY
         SPACE 5                                                      S
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: MSGBLOCK        ERROR MESSAGE BLOCK                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MSGBLOCK DSECT                                                        S
MSGLENM1 DS    AL1                 L-1 OF NUMBR+MSG                   S
MSGFLAG  DS    AL1                 MISC FLAG BYTE                     S
MSGNMBR  DS    CL3                 ERROR #                            S
MSGMSG   DS    0C                  VARYING LEN MSG                    S
         SPACE 5                                                      S
AVMCLBDF EQU   X'80'               MCLBTAGS - MACRO DEFINED FLAG
AVMCLBNF EQU   X'40'               MCLBTAGS - MACRO SEARCHED FOR/LIBRY
.AVNMCCC ANOP
         TITLE '*** AVWXTABL DSECT - MAIN ASSEMBLER TABLE ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AVWXTABL   MAIN CONTROL TABLE FOR THE ASSEMBLER.          *
*        THIS DSECT IS USED BY ALMOST ALL SUBROUTINES OF THE ASSEMBLER*
*        FOR COMMUNICATION, COMMON CONSTANTS, AND WORKAREAS, AND IS   *
*        ALSO USED SOMEWHAT BY THE MAIN PROGRAM ASSIST AND THE        *
*        REPLACE MONITOR REMONI.                                      *
*        LOCATION: CSECT VWXTABL, WITH SAME NAMES PREFIXED WITH 'A'.  *
*        NAMES: AX------,AW------,AV------  (DEPENDS ON SECTION)      *
*        THIS DSECT CONTAINS THE FOLLOWING SECTIONS:                  *
*                                                                     *
*              1. ADDRESS CONSTANTS(NAMES: AX, FOLLOWED BY ENTRY NAME)*
*        THIS SECTION CONTAINS 1 ADDRESS CONSTANT FOR EVERY CALLABLE  *
*        ENTRY POINT IN THE ASSIST ASSEMBLER.  THESE ARE READ-ONLY,   *
*        EXCEPT DURING A REPLACE RUN, IN WHICH THE ADCONS FOR A       *
*        SINGLE CSECT ARE TEMPORARILY MODIFIED.  THE LABEL AX$BASE IS *
*        USED AS A BASE ADDRESS FOR THE CALCULATION OF OFFSETS TO     *
*        INDIVIDUAL ADCONS, FOR THOSE ROUTINES REQUIRING TABLE-DRIVEN *
*        CALLING SEQUENCES (CNDTL2,CODTL1,MPCON0,REMONI).  NOTE THAT  *
*        ALL ENTRY POINTS HAVE 6-CHARACTER NAMES.  THE MACRO $CALL    *
*        IS USED IN CONJUNCTION WITH THIS PART OF AVWXTABL.           *
*                                                                     *
*              2. CONSTANT VALUES (NAMES: AW------)                   *
*        THIS SECTION CONTAINS USEFUL CONSTANT VALUES, SUCH AS        *
*        ZEROES, BLANKS, MASK VALUES, TRANSLATE TABLES, EDIT PATTERNS.*
*        ALL VALUES ARE READ-ONLY, EXCEPT THAT ANY ROUTINE MAY        *
*        MODIFY PART OF THIS SECTION IF IT RESTORES IT BEFORE         *
*        ALLOWING ANOTHER SUBROUTINE TO GAIN CONTROL.  TRANSLATE      *
*        TABLES INCLUDE ONES FOR SCANNING DECIMAL NUMBERS AND MACHINE *
*        INPUT CONVERSION - HEX TO BINARY, SCANNING SYMBOLS AND       *
*        INSTRUCTION OPERANDS, SCANNING HEXADECIMAL CONSTANTS, DOING  *
*        GENERAL EXPRESSIONS, CONVERTING BINARY TO OUPUT HEXADECIMAL. *
*        GENERATION: SECTION AWCONADS IS CREATED BY MACRO WCONG.      *
*                                                                     *
*              3. VARIABLES (NAMES: AV------)                         *
*        THIS SECTION CONTAINS ALL VARIABLE AREAS USED FOR            *
*        COMMUNICATION INSIDE THE ASSIST ASSEMBLER, IN ADDITION TO    *
*        VARIOUS WORKAREAS, WHICH MAY BE OVERLAPPED TO SAVE SPACE.    *
*        THE AREAS PROVIDED INCLUDE THE RECORD BLOCKS, LOCATION       *
*        COUNTER VALUES, CURRENT SECTION ID, CURRENT DYNAMIC STORAGE  *
*        AREA LIMITS, AND VARIOUS FLAGS.  TEMPORARY WORKAREAS ARE     *
*        SUPPLIED, ALL WITH 'WORK' INCLUDED IN THEIR NAMES, WHICH     *
*        CAN BE USED BY ANY ROUTINE , BUT ARE NOT SAFE ACROSS A       *
*        SUBROUTINE CALL.  NOTE THAT THIS SECTION REQUIRES EQU SYMBOLS*
*        FROM CNCBLOCK AND THE RECORD BLOCKS TO ASSEMBLE CORRECTLY.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
AVWXTABL DSECT
         SPACE 1
* * * * * NAMES IN AVWXTABL DSECT ARE SAME, EXCEPT WITH A'S PREFIXED  *
* * * * * AVWXTABL SECTION X - ADDRESS CONSTANTS  * * * * * * * * * * *
AX$BASE  DS    0A                  BASE ADDRESS FOR OFFSETS TO ROUTINES
*              *** BROPS2 ENTRY POINTS ***                            *
AXBRINIT DS    V(BRINIT)           BASE-REG INITIALIZATION
AXBRUSIN DS    V(BRUSIN)           BASE-REG SET UP USING VALUE
AXBRDROP DS    V(BRDROP)           BASE REG DROP A REGISTER
AXBRDISP DS    V(BRDISP)           BASE REG GET BASE-DISPLACEMENT
AXC$BASE DS    0F                  BASE ADDRESS FOR CONSTANT ADDR OFFSE
*              *** CACONS ENTRY POINTS ***                            *
AXCACON1 DS    V(CACON1)           SCAN A-TYPE CONST
AXCACON2 DS    V(CACON2)           ASSEMBLE A-TYPE CONSTANT
*              *** CBCONS ENTRY POINTS ***                            *
AXCBCON1 DS    V(CBCON1)           SCAN BINARY CONSTANT
AXCBCON2 DS    V(CBCON2)           ASSEMBLE BINARY CONSTANT
*              *** CCCONS ENTRY POINTS ***                            *
AXCCCON1 DS    V(CCCON1)           SCAN CHARACTER CONSTANT
AXCCCON2 DS    V(CCCON2)           ASSEMBLE CHARACTER CONSTANT
*              *** CDECNS ENTRY POINTS ***                            *
AXCDECN1 DS    V(CDECN1)           SCAN FLOATING PT CONST
AXCDECN2 DS    V(CDECN2)           ASSEMBLE FLOATING PT CONSTANT
AXCDCON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES
AXCECON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES
*              *** CFHCNS ENTRY POINTS ***                            *
AXCFHCN1 DS    V(CFHCN1)           SCAN FIXED POINT CONSTANT
AXCFHCN2 DS    V(CFHCN2)           ASSEMBLE FIXED POINT CONSTANT
AXCFCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES
AXCHCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES
*              *** CONSTANT PROCESSOR CONTROL ROUTINES ***            *
AXCNDTL2 DS    V(CNDTL2)           PASS 2 CONSTANT PROCESSING
AXCODTL1 DS    V(CODTL1)           DUPLICATION FACTOR-TYPE-LENGTH PROC
*              *** CPCONS ENTRY POINTS ***                            *
AXCPCON1 DS    V(CPCON1)           SCAN PACKED CONSTANT
AXCPCON2 DS    V(CPCON2)           ASSEMBLE PACKED CONSTANT
*              *** CVCONS ENTRY POINTS ***                            *
AXCVCON1 DS    V(CVCON1)           SCAN V-TYPE CONSTANTS
AXCVCON2 DS    V(CVCON2)           ASSEMBLE V-TYPE ADDRESS CONSTANTS
*              *** CXCONS ENTRY POINTS ***                            *
AXCXCON1 DS    V(CXCON1)           SCAN HEXADECIMAL CONSTANTS
AXCXCON2 DS    V(CXCON2)           ASSEMBLE HEXADECIMAL CONSTANTS
*              *** CZCONS ENTRY POINTS ***                            *
AXCZCON1 DS    V(CZCON1)           SCAN ZONED CONSTANTS
AXCZCON2 DS    V(CZCON2)           ASSEMBLE ZONED CONSTANTS
*              *** ERRORS ENTRY POINTS ***                            *
AXERRTAG DS    V(ERRTAG)           FLAG ERROR
AXERRLAB DS    V(ERRLAB)           ERROR FLAG FOR A LABEL
*              *** ESDOPRS ENTRY POINTS ***                           *
AXESINT1 DS    V(ESINT1)           ESD ROUTINE INITIALIZATION
AXESCSEC DS    V(ESCSEC)           CSECT,START, OR DSECT
AXESENX1 DS    V(ESENX1)           ENTRY OR EXTRN - PASS 1
AXESENX2 DS    V(ESENX2)           PASS 2 ENTRY AND EXTRN
*              *** EVALUT - EXPRESSION EVALUATOR ***                  *
AXEVALUT DS    V(EVALUT)           GENERAL EXPRESSION EVALUATION ROUT
*              *** 2ND LEVEL PROCESSOR CSECTS ***                     *
AXIAMOP1 DS    V(IAMOP1)           MACHINE OPCODES-PASS 1
AXIBASM1 DS    V(IBASM1)           ASSEMBLER OPCODES - PASS 1
AXICMOP2 DS    V(ICMOP2)           MACHINE OPCODES - PASS 2
AXIDASM2 DS    V(IDASM2)           ASSEMBLER OPCODES - PASS 2
*              *** INPUT1 ENTRY POINTS ***                            *
AXINCARD DS    V(INCARD)           INPUT CARD PROCESSOR
*              *** LTOPRS ENTRY POINTS ***                            *
AXLTINT1 DS    V(LTINT1)           LITERAL TABLE INITIALIZATION
AXLTENT1 DS    V(LTENT1)           ENTER A LITERAL INTO POOL
AXLTDMP1 DS    V(LTDMP1)           RETURN LITERAL LENGTH-PASS 1
AXLTEND1 DS    V(LTEND1)           END PASS 1 FOR LITERAL TABLE
AXLTGET2 DS    V(LTGET2)           GET ADDRESS OF LITERAL
AXLTDMP2 DS    V(LTDMP2)           PRODUCE LITERAL RECORDS-PASS 2
         AIF   (NOT &$MACROS).AXNOMAC       SKIP IF NO MACROS
*              ** MACROS ENTRY POINTS **                              *
AXMACINT DS    V(MACINT)           MACRO INITIALIZATION ENTRY
AXMACRO1 DS    V(MACRO1)           BUILD MACRO DEFINITION TABLES
AXMEXPND DS    V(MEXPND)           MACRO EXPANSION ENTRY
AXMCBODY DS    V(MCBODY)           PROCESS MACRO DEFINITION BODY
AXMACSCN DS    V(MACSCN)           SCAN MACRO STATEMENT
AXMACFND DS    V(MACFND)           SEARCH MACRO LIBRARY
AXMCVSCN DS    V(MCVSCN)           SCAN VARIABLE SYMBOL
AXMCSCOP DS    V(MCSCOP)           SCAN STANDARD OPERAND
AXMCGTST DS    V(MCGTST)           MOVE STRING TO LOW CORE
AXMCSYSR DS    V(MCSYSR)           SEARCH MACRO LIBRARIES FOR VAR SYMBL
AXMACLEX DS    V(MACLEX)           MACRO STMT LEX ANALYSIS
AXMCGNCD DS    V(MCGNCD)           MACRO DEFINITION CODE GENERATION
AXMXMVSR DS    V(MXMVSR)           MOVE GENERATED STMT TO HIGH CORE
AXMXERRM DS    V(MXERRM)           GENERATE ERROR MESSAGE
AXMCDTRM DS    V(MCDTRM)           CHAR TO BINARY CONVERSION
AXMCATRM DS    V(MCATRM)           TEST FOR ATTRIBUTE
         DS    2V                  SPACE FOR MACRO ENTRY POINTS
.AXNOMAC ANOP
*              ***  MAIN PROGRAMS - PASS 1&2 ***                      *
AXMOCON1 DS    V(MOCON1)           MAIN CONTROL - PASS 1
AXMOSTOP DS    V(MOSTOP)           DISASTER EXIT-PASS 1
AXMTCON2 DS    V(MTCON2)           MAIN CONTROL - PASS 2
*              *** OPCOD1 ENTRY POINTS ***                            *
AXOPINIT DS    V(OPINIT)           INITIALIZATION,IF ANY
AXOPFIND DS    V(OPFIND)           LOOKUP OPCODE
*              *** OUTPUT ENTRY POINTS ***                            *
AXOUINT1 DS    V(OUINT1)           INITIALIZATION ENTRY FOR OUTPUT
AXOUTPT2 DS    V(OUTPT2)           OUTPUT LINE PRINTER
AXOUEND2 DS    V(OUEND2)           FINISH UP LAST PRINTING
*              *** SCANRS ENTRY POINTS ***                            *
AXSCANBL DS    V(SCANBL)           SCAN TO FIRST BLANK OUTSIDE OF C'
AXSCANCO DS    V(SCANCO)           SCAN TO COMMA OR BLANK
AXSCANEQ DS    V(SCANEQ)           SCAN TO = OR BLANK
*              *** SDTERM ENTRY POINTS ***                            *
AXSDBCDX DS    V(SDBCDX)           SELF DEFINING TERM-ALL 4 KINDS     *
AXSDBTRM DS    V(SDBTRM)           BINARY SELF-DEFINING TERM
AXSDCTRM DS    V(SDCTRM)           CHARACTER SELF-DEFINING TERM
AXSDDTRM DS    V(SDDTRM)           DECIMAL SELF-DEFINING TERM
AXSDXTRM DS    V(SDXTRM)           HEXADECIMAL SLEF-DEFINING TERM
*              *** SYMOPS ENTRY POINTS ***                            *
AXSYINT1 DS    V(SYINT1)           SYMBOL TABLE INITIALIZATION
AXSYENT1 DS    V(SYENT1)           ENTER A SYMBOL INTO SYMBOL TABLE
AXSYFIND DS    V(SYFIND)           LOOK UP A SYMBOL IN SYMBOL TABLE
AXSYEND2 DS    V(SYEND2)           CLEANUP/STATISTICS AT END OF SYM TAB
*              *** UTOPRS ENTRY POINTS ***                            *
AXUTINT1 DS    V(UTINT1)           UTILITIES INITIALIZATION
AXUTPUT1 DS    V(UTPUT1)           PASS 1 OUTPUT OF EXPANDED RECORDS
AXUTEND1 DS    V(UTEND1)           END PASS 1-INIT FOR PASS 2
AXUTGET2 DS    V(UTGET2)           GET ADDR'S OF EXPANDED RECRDS-PASS 2
AXUTPUT2 DS    V(UTPUT2)           OBJECT CODE CREATION-PASS 2
AXUTEND2 DS    V(UTEND2)           FINISH UP PASS 2
         AIF   (NOT &$XREF).NOXREF2  SKIP IF NO CROSS REFERENCE       A
*    CROSS REFERENCE ENTRY POINTS                                     A
AXXRINT1 DS    V(XRINT1)           1ST PASS INIT ROUTINE              A
AXXRINT2 DS    V(XRINT2)           2ND PASS INIT ROUTINE              A
AXXRCOLL DS    V(XRCOLL)           COLLECTION ROUTINE                 A
AXXRPRNT DS    V(XRPRNT)           PRINT ROUTINE                      A
AXXRSCAN DS    V(XRSCAN)           CONTROL CARD SCANNING ROUTINE      A
.NOXREF2 ANOP
AXSPECAD DS    A                   BASE ADDRESS FOR SPECIAL ROUTINES
AXSPECA2 DS    A                   BASE @ LEV2-PASS 2 - 'SPECIALS'
         EJECT
* * * * * AVWXTABL SECTION W - CONSTANTS  * * * * * * * * * * * * * * *
AWD0     DS    0D                  FLOATING POINT 0 FOR CDE
AWZEROS  DS    32D'0'              256 BYTES OF BINARY ZEROS
AWD10    DS    D'10'               DOUBLEWORD CONSTANT 10
AWF1     DS    F'1'                FULLWORD 1 CONSTANT
AWH1     EQU   AWF1+2              HALFWORD 1 CONSTANT
AWB1     EQU   AWF1+3              BYTE 1 CONSTANT
AWF3     DS    F'3'                FULLWORD 3 CONSTANT
AWH3     EQU   AWF3+2              HALFWORD 3 CONSTANT
AWB3     EQU   AWF3+3              BYTE 3 CONSTANT
AWF4     DS    F'4'                FULLWORD CONSTANT 4
AWF7     DS    F'7'                FULLWORD 7 CONSTANT
AWH7     EQU   AWF7+2              HALFWORD 7 CONSTANT
AWB7     EQU   AWF7+3              BYTE 7 CONSTANT
AWF10    DS    F'10'               FULLWORD CONSTANT 10
AWH10    EQU   AWF10+2             HALFWORD CONSTANT 10
AWF12    DS    F'12'               FULLWORD CONSTANT 12
AWF15    DS    F'15'               FULLWORD CONSTANT 15 (4 1 BITS)
AWFXF    EQU   AWF15               FULLWORD CONSTANT,4 1-BITS
AWFXFF   DS    F'255'              FULLWORD CONSTANT 255
AWF4095  DS    F'4095'             FULLWORD 4095 CONSTANT
AWFXFFF  EQU   AWF4095             XL4'FFF'      ON F BOUNDARY
AWHXFFF  EQU   AWFXFFF+2           XL2'0FFF'  ON H BOUNDARY
AWFX7FFF DS    X'00007FFF'         MAXIMUM SIZE, MASK VALUE
AWFXFFFF DS    X'0000FFFF'         65K DECIMAL NUMBER
AWFX6F   DS    XL4'FFFFFF'         FULLWORD 24-BIT MASK
AWFM4    DS    F'-4'               FULLWORD -4 CONSTANT
AWFM1    DS    F'-1'               FULLWORD -1 CONSTANT
AWHM1    EQU   AWFM1+2             HALFWORD -1 CONSTANT
         EJECT
*        TABLE USED TO SCAN DECIMAL NUMBERS                           *
*        CHARACTERS 0-9 HAVE ZERO VALUES,ALL OTHERS NONZERO           *
*        ALSO USED IN ICMOP2 FOR GENERAL SCANNING.                    *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
AWTDECT  DS    X'02020202020202020202020202020202'    0
         DS    X'02020202020202020202020202020202'    1
         DS    X'02020202020202020202020202020202'    2
         DS    X'02020202020202020202020202020202'    3
         DS    X'100202020202020202020202020C0202'    4 BLANK (
         DS    X'02020202020202020202020608020202'    5  $ *
         DS    X'02020202020202020202020E02020202'    6  ,
         DS    X'02020202020202020202020606020A02'    7 # @ =
         DS    X'02020202020202020202020202020202'    8
         DS    X'02020202020202020202020202020202'    9
         DS    X'02020202020202020202020202020202'    A
         DS    X'02020202020202020202020202020202'    B
         DS    X'02060404060606060606020202020202'    C B-C(4) ALPHS-6
         DS    X'02060604060606060606020202020202'    D L-(4) ALPHS-6
         DS    X'02020606060606040606020202020202'    E X-(4) ALPHS - 6
         DS    X'00000000000000000000020202020202'    F
         SPACE 1
*        TABLE USED TO SCAN HEXADECIMAL CONSTANTS FOR CORRECTNESS     *
*        CHARACTERS A-F,0-9 ARE ZERO,ALL OTHERS ARE NON-ZERO          *
AWTHEXT  DS    X'02020202020202020202020202020202'    0
         DS    X'02020202020202020202020202020202'    1
         DS    X'02020202020202020202020202020202'    2
         DS    X'02020202020202020202020202020202'    3
         DS    X'02020202020202020202020202020202'    4
         DS    X'02020202020202020202020202020202'    5
         DS    X'02020202020202020202020202020202'    6
         DS    X'02020202020202020202020202020202'    7
         DS    X'02020202020202020202020202020202'    8
         DS    X'02020202020202020202020202020202'    9
         DS    X'02020202020202020202020202020202'    A
         DS    X'02020202020202020202020202020202'    B
         DS    X'02000000000000020202020202020202'    C
         DS    X'02020202020202020202020202020202'    D
         DS    X'02020202020202020202020202020202'    E
         DS    X'00000000000000000000020202020202'    F
         SPACE 1
*        TABLE USED TO CONVERT HEXADECIMAL CONSTANTS                  *
AWTHEX2  EQU   *-C'A'              OFFSET SYMBOL FROM TABLE CORRECTLY
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
         DS      X'0A0B0C0D0E0F000000000000000000'    C
         DS    X'00000000000000000000000000000000'    D
         DS    X'00000000000000000000000000000000'    E
         DS    X'00010203040506070809'                F
         EJECT
*        USED TO SCAN ACROSS SYMBOLS,STOP ON DELIMITERS               *
*        CHARACTERS $,#,@,A-Z,0-9 ARE ZERO. ALL OTHERS ARE NONZERO    *
*        ALSO USED IN EVALUT FOR OPERATOR CODES- (+*)-/,              *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
AWTSYMT  DS    X'01010101010101010101010101010101'     0
         DS    X'01010101010101010101010101010101'     1
         DS    X'01010101010101010101010101010101'     2
         DS    X'01010101010101010101010101010101'     3
         DS    X'04010101010101010101010101020501'     4 BLANK (+
         DS    X'01010101010101010101010007030101'     5 $*)
         DS    X'06080101010101010101010401010101'     6 -/,
         DS    X'01010101010101010101010000010101'     7  #@
         DS    X'01010101010101010101010101010101'     8
         DS    X'01010101010101010101010101010101'     9
         DS    X'01010101010101010101010101010101'     A
         DS    X'01010101010101010101010101010101'     B
         DS    X'01000000000000000000010101010101'     C  A-I
         DS    X'01000000000000000000010101010101'     D  J-S
         DS    X'01010000000000000000010101010101'     E  S-Z
         DS    X'00000000000000000000010101010101'     F  0-9
         SPACE 1
AWTZTAB  EQU   AWZEROS             SPACE FOR 256-BYTE ZEROED TRT TABLE
         DS    0D                  LINE UP BLANKS ON D BOUNDARY
AWBLANK  DS    CL132' '            BLANKS
         ORG   AWBLANK+16          MAXIMUM OVERLAP OF AWBLANK&AWTHEX3
*        TABLE USED TO CONVERT INTERNAL BINARY TO EXTERNAL HEX.       *
*   TR TABLE     0123456789ABCDEF0123456789ABCDEF                     *
AWTHEX3  DS    C'                                '    0-1
         DS    C'                                '    2-3
         DS    C'                                '    4-5
         DS    C'                                '    6-7
         DS    C'                                '    8-9
         DS    C'                                '    A-B
         DS    C'                                '    C-D
         DS    C'                0123456789ABCDEF'    E-F
AWEP4    DS    X'40202120'         4-BYTE DECIMAL EDIT PATTERN
AWEP6    DS    X'402020202120'     6-BYTE EDIT PATTERN FOR DEC #
AWP0     DS    PL1'0'              FOR ZEROING DECIMAL COUNTERS
AWP1     DS    P'1'                DECIMAL CONSTANT 1
AWCONADS DS    ($CNT$N)AL1         OFFSETS TO CONSTANT PROG ADCONS
         EJECT
AVOENTR  EQU   B'00000010'         (AVTAGS1)<AOBJIN> ENTRY @ FROM END
AVO1TXT  EQU   B'00000100'         (AVTAGS1)<AOBJIN> >=1 TXT CARDS FND
         SPACE 1
* * * * * AVWXTABL SECTION V - VARIABLES  * * * * * * * * * * * * * * *
         DS    0D                  GET ALIGNMENT
*        **NOTE  VARIABLES FROM HERE THRU AVAJL ARE GIVEN INITIAL     *
*        VALUES BY CALLING PROGRAM BEFORE CALLING MPCON0.             *
AVADDLOW DS    F                   POINTER TO HIGH END OF LOW AREA
*                        GIVES FIRST FREE LOCATION AT LOW END.        *
AVADDHIH DS    F                   POINTER TO LOW ADDR OF HIGH END
*                        GIVES LOWEST ADDR OF ALREADY USED SPACE      *
AVECONPT DS    A                   @ ECONTROL, IF NEEDED (REPLMON)
AVAJOBPT DS    A                   @ AJOBCON TABLE, IN CASE EVER NEEDED
         SPACE 1
*              VARIABLES FROM HERE TO AVAJL CORRESPOND TO AJOBOCN
*              SECTION AJONERR - AJOAVL, AND CANNOT BE CHANGED WITHOUT
*              EXTREME CARE.  AJOAVL MUST = AVAJL.
         CNOP  2,4                 ALIGN AVNERR LIKE AJONERR
AVNERR   DS    H                   MAX # ACTUAL ERRORS ALLOWED
         SPACE 1
         AIF   (NOT &$MACROS).AVMXX1        SKIP IF NO MACROS AT ALL
         SPACE 1
*        AVMMACTR-AVMMSTMG MUST BE IN SAME ORDER AS AJOMACTR-AJOMSTMG.
AVMMACTR DS    F                   DEFAULT INITIAL VALUE OF MACRO ACTR
AVMMNEST DS    F                   ABSOLUTE LIMIT ON MACRO NEST LEVEL
AVMMSTMG DS    F                   GLOBAL LIMIT ON MACRO STMTS PROCESSD
AVTAGSM  DS    B                   MACRO OPTIONS BITS (FROM AJOASMFM)
*   BIT7=0 => NO MACROS ALLOWED.   =1(AJOMACRO) => MACROS ALLOWED
*   BIT6=0 => NO ASM G FEATURES.   =1(AJOMACRG) => ADD MACRO G TO ABOVE
*   BIT5=0 => NO ASM H FEATURES    =1(AJOMACRH) => ADD MACRO H TO F
*   REMAINING BITS RESERVED FOR FUTURE USE WITH MACRO PROCESSING.     *
.AVMXX1  ANOP
AVTAGS0  DS    B                   FLAG- FUTURE USE FROM AJOBCON
         SPACE 1
AVTAGS1  DS    B                   1ST BYTE OF FLAG BITS
*   BIT0=0 => START ALLOWED, =1($IBSTAR1)=> START NO LONGER ALLOWED.  *
*   BIT1=0 => CURRENT SECTION IS CSECT, =1($IBDSEC1)=> IN DSECT NOW   *
*   BIT2=0 => NO PRIVATE CODE, =1($IBPRCD1)=> PRIV CODE HAS OCCURREC  *
*   BIT3=0 => NORMAL LOAD, =1(AJORELOC)=> LOAD RELOCATED TO REAL @'S  *
*   BIT4=0 => ALL IN CORE, =1(AJODISKU) => USE DISK INTERMEDIATE.     *
*   BIT5=0 => NORMAL PROGRAM, =1(AJOLARGE)=> PROG LARGE, CRUNCH MUCH  *
*   BIT6=0 => LIST SOURCE, =1(AJNLIST)=> NOLIST (EXCEPT ERRORS)       *
*   BIT7=0 => LOAD OBJECT CODE, =1(AJNLOAD)=> CREATE NO OBJECT CODE   *
*        *NOTE* BITS 3-7 ARE SET FROM AJOASMF, BITS 0-2 INIT  = 0.    *
*              AVTAGS1 BITS ALSO USED BY OBJECT CODE LOADER AOBJIN.
*   BIT0=0 => NO TXT CARDS FOUND YET. =1(AVO1TXT) => >= 1 CARD FOUND. *
*   BIT1=0 => NO ENTRY @ FND ON END CARD YET. =1(AVOENTR) => FOUND.   *
         SPACE 1
AVTAGS2  DS    B                   2ND BYTE OF FLAG BITS
*   BIT0=0 => NO EOF FOUND, =1($INEND2)=> EOF, CREATE END CARD
*   BIT1=0 => CONTINUE ASSEMBLY. =1(AJOASTOP) ==> STOP ASSEMBLY.
*   BIT0=0 => NODECK. =1(AJODECK) => OBJECT DECK(USES <AODECK>).      *
*   BIT6=0 => NO COMMENT CHECK. =1 REQUIRES &$COMNT % OF MACH INSTS
*   BIT7=0=> NORMAL LISTING. =1 => CMPRS LISTING (2 STMTS/LINE)
*   OTHER BITS FOR FUTURE USE, SET FROM AJOASMF2 IN AJOBCON.          *
         AIF   (NOT &$XREF).NOXREF1 SKIP IF NO XREF                   A
AVXRFLAG DS    C                   FLAG BYTE FOR CROSS REFERENCE      A
          SPACE 2
* THE FOLLOWING FLAGS USED IN TESTING THE ABOVE FLAG                  A
         SPACE
AVXRON   EQU   B'00100000'         XREF FACILITY ON                   A
AVXRCOMP EQU   B'00110000'         COMPRESSED LISTING                 A
AVXRSDMD EQU   B'00001000'         SD OPERAND MOD REFERENCE           A
AVXRSDFT EQU   B'00000100'         SD OPERAND FETCH REFERENCE         A
AVXRSRMD EQU   B'00000010'         SR OPERAND MOD                     A
AVXRSRFT EQU   B'00000001'         SR OPERAND FETCH                   A
.NOXREF1 ANOP
AVAJL    EQU   *-AVNERR            LENGTH OF BLOCK FROM AJOBCON
*              VRADL,VRADH,VRELOC,VFENTER,VLOCLOW,VLOCHIH MUST BE IN  *
*        THE ORDER WHICH IS GIVEN.  THEY ARE USED IN LM-STM GROUPS    *
AVRADL   DS    A                   LOWEST REAL ADDRESS OF USER PROGRAM
AVRADH   DS    A                   HIGHEST REAL ADDRESS OF USER PROGRAM
AVRELOC  DS    F                   RELOCATION FACTOR FOR OBJECT CODE
AVZAREA1 DS    0F                  VARIABLE AREA TO BE ZEROED-BEGINNING
AVFENTER DS    A                   PROGRAM ENTRY POINT ADDRESS
*              AVLOCLOW,AVLOCHIH,AVLOCNTR,AVCSLOW,AVCSHIH-REQUIRED ORDR
AVLOCLOW DS    F                   LOWEST LOCATION COUNTER(START OR 0)
AVLOCHIH DS    F                   HIGHEST VALUE OF AVLOCCNTR
AVLOCNTR DS    F                   LOCATION COUNTER
AVCSLOW  DS    F                   CURRENT CSECT LOW LOCCNTR VALUE
AVCSHIH  DS    F                   CURRENT CSECT HIGH VALUE
         SPACE 1
AVSTMTNO DS    H                   TOTAL # OF STATEMENTS
AVSTMTER DS    H                   TOTAL # STMTS FLAGGED
AVNERRA  DS    H                   # FATAL ERROR MESSAGES
AVNWARN  DS    H                   # WARNING MESSAGES
AVOUCOUN DS    H                   WITHIN PAGE LINE COUNT (OUTPUT)
AVOULNCN DS    PL3                 STATEMENT NUMBER CURRENT
AVOUPGCN DS    PL2                 NUMBER OF PAGES (OUTPUT)
         AIF   (NOT &$XREF).NOXREF4  SKIP IF NO XREF
AVXRLAVS DS    F                   LIST OF AVAIL SPACE FOR XREF       A
AVXRHEAD DS    F                   HEADER POINTER FOR XREF TREE       A
AVXRCNT  DS    H                   COUNTER FOR NUMBER OF REFERENCES   A
AVXRLNCN DS    PL3                 ADDITIONAL LINE COUNTER FOR XREF   A
AVXRMDFT DS    C                   ADDITIONAL FLAG FOR XREF           A
* FLAG TO BE TESTED WITH THE FOLLOWING                                A
AVXRMOD1 EQU   B'10000000'         MODIFY FIRST OPERAND               A
AVXRMOD2 EQU   B'01000000'         MODIFY SECOND OPERAND              A
AVXRMOD3 EQU   B'00100000'         MODIFY THIRD OPERAND               A
AVXRMOD4 EQU   B'00010000'         MODIFY FIRST THRU SECOND OPERAND   A
AVXRFET1 EQU   B'00001000'         FETCH FIEST OPERAND                A
AVXRFET2 EQU   B'00000100'         FETCH SECOND OPERAND               A
AVXRFET3 EQU   B'00000010'         FETCH THIRD OPERAND                A
AVXRFET4 EQU   B'00000001'         FETCH FIRST THRU SECOND OPERAND    A
AVXRTYPE DS    C                   USED TO TEST M/F REFERENCE         A
AVXRFTCH EQU   X'08'               USED TO TEST ABOVE FLAG            A
* IF NOT TYPE , MUST BE MODIFY REFERNCE                               A
.NOXREF4 ANOP
         SPACE
AVCESDID DS    C                   CURRENT CSECT ESDID
*              EVEN VALUE=> CSECT, ODD VALUE=> DSECT ($ESDSECT FLAG).
AVPRINT  DS    C                   LISTING CONTROL FLAG BYTE
AVPRINT1 DS    C                   LISTING CONTROL: 1ST PASS ONLY
AVPRSAVE EQU   B'00000001'         (AVPRINT1,AVPRINT)==> SAVE IN 1ST PS
AVDEBUG  DS    C                   DEBUGGING FLAG TESTED BY XSNAPS
AVTAGS3  DS    B                   VARIOUS FLAGS
*  BIT0=0 => NO STORAGE OVERFLOW. =1(AVOVERFL) => STORAGE EXCEEDED.
AVOVERFL EQU   B'10000000'         (AVTAGS3) => STORAGE OVERFLW OCCRD
AVMTAG00 DS    B                   MISC FLAG BYTE, MACRO COMMUNICATION
AVMOPENC EQU   B'00000001'         (AVMTAG00)==> GBLX,LCLX IN OPEN COD
AVMNOMAC EQU   B'00000010'         (AVMTAG00) => NO MORE MACROS       S
*                                  BECAUSE GBLX, LCLX, ETC. FOUND     S
AVMOPDIC EQU   B'00000100'         (AVMTAG00) => OPEN CODE LOCAL      S
*                                  DICTIONARY HAS BEEN ALLOCATED      S
AVMOPGO  EQU   B'00001000'         (AVMTAG00) => SUCCESSFUL AIF/AGO   S
AVMOPMIN EQU   B'00010000'         (AVMTAG00) - OPEN CODE MACLIB ENTRY X
                                   IS PROPERLY ZEROED & @ OF LOCAL    SX
                                   DUMMY HAS BEEN ENTERED             S
AVMISC00 DS    B                   MISC FLAG BYTE, FUTURE USE
AVMISC01 DS    B                   MISC FLAG BYTE, FUTURE USE
AVMISC02 DS    B                   MISC FLAG BYTE, FUTURE USE
AVZAREA2 DS    0D                  VARIABLE AREA TO BE ZEROED - END
         EJECT
AVECONTR DS    0D                  ECONTROL DSECT WILL BE LOCATED HERE
AVCONCAT DS    CL256               SPACE FOR CONSTANT BUILDING(CNDTL2)
AVCONBLD DS    CL256               CONSTANT/CODE BUILDING AREA
AVRSBLOC DS    CL(RSB$L+RSOL1+80+RSOLC*($RSMXCRD-2)) RSBLOCK AREA
AVRSCBLK DS    (RSCONSQ-RSCBLK+$RSMXCRD*RSC$LEN)C AREA FOR RSCBLK
AVREBLK  DS    0C                  BEGINNING OF RECORD ERROR BLOCK
AVREBLN  DS    C                   RECORD ERROR BLOCK LENGTH-1
AVREBES  DS    ($ERREBMX)CL2       ERROR CODE AREAS
AVREBSCN EQU   AVREBES             BYTE FOR SCAN OFFSET
AVREBERR EQU   AVREBES+1           BYTE FOR ERROR CODE
         ORG   ,                   MAKE SURE BACK FAR ENOUGH
         SPACE 1
AVDWORK1 DS    D                   1ST DOUBLE WORD WORK AREA
AVDWORK2 DS    D                   2ND DOUBLE WORD WORK AREA
AVRCBPT  DS    A                   ADDRESS OF RECORD CODE BLOCK
AVREBPT  DS    A                   ADDRESS OF RECORD ERROR BLOCK
AVRSBPT  DS    A                   ADDRESS OF RECORD SOURCE BLOCK
AVRSCPT  DS    A                   RECORD SOURCE CODE BLOCK POINTER
AVLABPT  DS    F                   ADDRESS OF LABEL ENTRY,=0 IF NO LAB
AVFWORK1 DS    F                   1ST FULLWORD WORKAREA
AVMPSPIE DS    A                   @ SPIE BLOCK WHEN ENTERED ASSEMBLER
AVSOLAST DS    A                   @ BLANK BEFORE ' AFTER SOURCE STMT
         AIF   (&$COMNT EQ 0).AVNOCOM       SKIP IF NO COMMENT CHECKING
*              FOLLOWING 2 VARIABLES MUST BE IN GIVEN ORDER.
AVMACHIN DS    H                   # MACHINE INSTS, SET BY IAMOP1
AVCOMNTN DS    H                   # MACHINE INSTS WITH COMMENTS
.AVNOCOM ANOP
         AIF   (&$DISKU EQ 0).AVDKTA        SKIP IF NO DISK AT ALL
*
*        BUFFER CONTROL BLOCK FOR DISK UTILITY I/O SYNCHRONIZATION
*
AVBCB    DS    0F                  BUFFER CONTROL BLOCK
AVDECB   DS    A(0)                ADDRESS OF CURRENT DECB
AVBUFF@  DS    A(0)                ADDRESS OF CURRENT BUFFER
AVBUFINC DS    A(0)                POINTER TO 1ST UNUSED BYTE IN BUFFER
AVBUFEND DS    A(0)                POINTER TO END OF BUFFER
         AIF   (&$BUFNO EQ 1).AVDKTA        SKIP IF ONLY 1 BUFFER
AVDECBNX DS    A(0)                ADDRESS OF NEXT DECB
AVDECBLT DS    A(0)                POINTER TO LAST DECB
.AVDKTA  ANOP
         AIF   (NOT &$MACROS).AVNOMAC       SKIP IF NO MACROS
         SPACE 2
*              VARIABLES USED IN MACRO PROCESSING.                    *
AVSYSECT DS    D                   CURRENT CSECT/DSECT NAME
AVGEN1CD DS    A                   @ 1ST BYTE BEYOND 1ST GEN'D CARD-
*              SET BY MEXPND.  THEN USED AS PTR BY INCARD.
AVGEN2CD DS    A                   USED AS PTR BY INCARD. HAS @ LAST
*              CARD GENERATED BY MEXPND (ORIG SETTING OF AVADDHIH).
AVMACSPC EQU   *                   LABEL FOR SPACE FOR MACRO AVM'S
*
.AVNOMAC ANOP
         AIF   (NOT &$MACROS).AVNLIB         SKIP IF NO MACROS
AVMFLD1  DS    F                   POINTER TO CURRENT LABEL FIELD
AVMFLDL1 DS    C                   LENGTH OF LABEL
AVMFLDT1 DS    C                   TYPE OF LABEL - SEQ, VAR OR OTHER
AVMFLD1H DS    H                   NOT CURRENTLY USED
AVMFLD2  DS    F                   POINTER TO OPCODE FIELD
AVMFLDL2 DS    C                   LENGTH OF OPCODE FIELD
AVMFLDT2 DS    C                   TYPE OF OPCODE - ASM, MACR OR MAC IN
AVMFLD2H DS    H                   NOT CURRENTLY USED
AVMFLD3  DS    F                   POINTER TO OPERAND FIELD
AVMFLDL3 DS    C                   LENGTH OF OPERAND FIELD
AVMFLDT3 DS    C                   TYPE OF OPERAND FIELD
AVMFLD3H DS    H                   NOT CURRENTLY USED
AVMFLD4  DS    F                   POINTER TO COMMENT FIELD
AVMFLDL4 DS    C                   LENGTH OF COMMENT FIELD
AVMFLDT4 DS    C                   TYPE OF COMMENT FIELD - NOT USED
AVMFLD4H DS    H                   NOT CURRENTLY USED
AVMFLD5  DS    F                   2ND CARD NON STND OPRND
AVMFLDL5 DS    C                   2ND CARD NON STND OPRND LENGTH
AVMFLDT5 DS    C                   2ND CARD NON STND OPRND TYPE
AVMFLD5H DS    H                   NOT CURRENTLY USED
AVMFLD6  DS    F                   2ND NON STND CARD COMMENT
AVMFLDL6 DS    C                   2ND NON STND CARD COMMENT LENGTH
AVMFLDT6 DS    C                   2ND NON STND CARD COMMENT TYPE
AVMFLD6H DS    H                   NOT CURRENTLY USED
AVMFLD7  DS    F                   3RD NON STND CARD OPRND
AVMFLDL7 DS    C                   3RD NON STND CARD OPRND LENGTH
AVMFLDT7 DS    C                   3RD NON STND CARD OPRND TYPE
AVMFLD7H DS    H                   NOT CURRENTLY USED
AVMFLD8  DS    F                   3RD NON STND CARD COMMENT
AVMFLDL8 DS    C                   3RD NON STND CARD COMMENT 6ENGTH
AVMFLDT8 DS    C                   3RD NON STND CARD COMMENT TYPE
AVMFLD8H DS    H                   NOT CURRENTLY USED
$LAVMFLD EQU   *-AVMFLD1           LENGTH OF FIELD INFO POINTERS
         SPACE 1
AVMBYTE1 DS    C                   1ST MACRO FLAG BYTE
AVMBYTE2 DS    C                   2ND MACRO FLAG BYTE
AVMBYTE3 DS    C                   3RD MACRO FLAG BYTE
AVMBYTE4 DS    C                   FLAG BYTE
AVMBYTE5 DS    C                   FLAG BYTE
         SPACE 1
AVMSYMLN DS    C                   LENGTH OF CURRENT SYMBOL
AVMSYMBL DS    CL8                 GLOBAL AREA FOR CURRENT SYMBOL
AVMSYSDX DS    PL2                 CURRENT &SYSNDX COUNT
         SPACE 1
AVMSEQPT DS    F                   POINTER TO SEQ SYMBOL TABLE
AVMCRINS DS    F                   CURRENT GENERATED INSTRUCTION @
AVMMACID DS    F                   CONTAINS ID NUMBER OF CURRENT MACRO
AVMACNST DS    F                   CURRENT MACRO NESTING COUNT
AVMLDICT DS    F                   POINTER TO OPEN LOCAL DICTIONARY
AVMGDICT DS    F                   POINTER TO GLOBAL DICTIONARY
AVMACLIB DS    F                   POINTER TO MACRO LIBRARY
AVMOVRFL DS    A                   @ OVERFLOW EXIT ROUTINE
AVMTSCNP DS    F                   TEMP STORAGE FOR SCAN POINTER
         SPACE 1
AVMBSPIE DS    F                   TEMP STORAGE FOR MCBODY $SPIE INT @
         ORG   AVMBSPIE            PUT AVMXSPIE IN SAME PLACE**********
AVMXSPIE DS    F                   TEMP STORAGE FOR MXPEND SPIE INT @
         SPACE 1
AVMCHSTR DS    F                   @ OF CHARACTER WORK AREA
AVMCHLIM DS    F                   LAST AVAILABLE BYTE OF CHAR WORK
AVMWRKL1 DS    F                   @ OF LAST BYTE OF AVMWRK1
AVMWRKL2 DS    F                   @ OF LAST BYTE OF AVMWRK2
         SPACE 1
AVMWRK1  DS    CL256               MACRO WORK AREA 1
AVMWRK2  EQU   AVCONCAT            USE CONCAT FOR WORK AREA 2
         SPACE 1
AVMDWRK1 DS    D                   1ST DOUBLE WORD WORK AREA
AVMDWRK2 DS    D                   2ND DOUBLE WORD WORK AREA
AVMDWRK3 DS    D                   3RD DOUBLE WORD WORK AREA
AVMDWRK4 DS    D                   4TH DOUBLE WORD WORK AREA
         SPACE 1
AVMFWRK1 DS    F                   1ST FULL WORD WORK AREA
AVMFWRK2 DS    F                   2ND FULL WORD WORK AREA
AVMFWRK3 DS    F                   3RD FULL WORD WORK AREA
AVMFWRK4 DS    F                   4TH FULL WORD WORK AREA
         SPACE 1
AVMHWRK1 DS    H                   1ST HALFWORD WORK AREA
AVMHWRK2 DS    H                   2ND HALFWORD WORK AREA
AVMHWRK3 DS    H                   3RD HALFWORD WORK AREA
AVMHWRK4 DS    H                   4TH HALFWORD WORK AREA
         SPACE 1
AVMSNBY1 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS
AVMSNBY2 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS
         AIF   (NOT &$MACSLB).AVNLIB         SKIP IF NO LIBRARY FETCH
AVLIBBUF DS    F                   POINTER TO LIBRARY BUFFER SPACE
.AVNLIB  ANOP
AVWXEND  DS    0D                  ENDING @ AVWXTABL
         TITLE 'ERCOMPCD DSECT - COMPLETION CODE MESSAGE BLOCK'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ERCOMPCD   COMPLETION CODE/ERROR MESSAGE BLOCK            *
*        THIS GIVES FORMAT OF 1 COMPLETION CODE/MESSAGE BLOCK FOR     *
*        USE IN A USER COMPLETION DUMP BY SUBROUTINE XXXXSNAP.  THE   *
*        ADDRESS OF THE APPROPRIATE BLOCK IS PLACED INTO WORD ECERRAD *
*        IN DSECT ECONTROL, AND IS USED THEN BY XXXXSNAP TO PRINT THE *
*        INFORMATION IN THE ERCOMPCD BLOCK.                           *
*        LOCATION: INSIDE EXECUT, WILL BE ELSEWHERE(FUTURE).          *
*        GENERATION: 1 BLOCK CREATED BY 1 CALL TO $ERCGN MACRO.       *
*        NAMES: ERC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ERCOMPCD DSECT
ERCSYST  EQU   0                   (ERCTYPE)==> SYSTEM COMPLETION CODE
ERCASSI  EQU   1                   (ERCTYPE)==> ASSIST SPECIAL MESSAGE
ERCUSER  EQU   2                   (ERCTYPE)==> USER ABEND COMPLETION
ERCLENG  DS    C                   LENGTH-1 OF ERCMSSG
ERCTYPE  DS    C                   CODE OF COMPLETION TYPE
ERCMSSG  DS    0C                  COMPLETION MESSAGE(VARIABLE LENGTH)
         TITLE 'AJOBCON - MAIN JOB CONTROL TABLE DSECT'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AJOBCON    MAIN JOB CONTROL TABLE                         *
*        THIS DSECT PROVIDES THE PRIMARY COMMUNICATION TABLE USED     *
*        BY THE MAIN PROGRAM ASSIST, THE I/O ROUTINES(XXXXIOCO), THE  *
*        PARM FIELD ANALYZER (APARMS), THE MAIN PROGRAM OF THE        *
*        ASSEMBLER (MPCON0), AND THE REPLACE MONITOR (REMONI).  IT    *
*        PROVIDES FOR GLOBAL FLAG VALUES DEALING WITH THE OVERALL     *
*        JOB IN PROGRESS, PARM FIELD VALUES, USEFUL CONSTANTS, BLANKS,*
*        ZEROES, WORKAREAS, AND DYNAMIC STORAGE AREA LIMITS.          *
*        LOCATION: IN TABLE ASJOBCON OF CSECT ASSIST.                 *
*        NAMES: AJ------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
AJOBCON  DSECT
*              FOLLOWING EQU'S USED FOR COMMUNICATION BETWEEN ASSIST  J
*              AND XXXXSORC DURING CONTROL CARD CHECKING. VALUES ARE  J
*              PLACED INTO AJOBTRQ AND ATOBTYP.                       J
AJO$D    EQU   0                   (AJOBTRQ)- DATA READ (NORMAL CASE) J
AJO$J    EQU   1                   (AJOBTRQ)- LOOKING FOR $JOB CARD   J
AJO$E    EQU   2                   (AJOBTRQ)- LOOKING FOR $ENTRY      J
AJOAPRSE EQU   B'00000001'         (AJOAPMOD)- ZERO ALL APCFLAG SET
*                                  BITS BEFORE SCANNING PARM OPTIONS
AJOAPDEF EQU   B'00000010'         (AJOAPMOD)- DEFAULT CALL TO APARMS-
*                                  OVERRIDE NO VALUE ALREADY SET ANY WY
AJOAPFIN EQU   B'00000100'         (AJOAPMOD)- FINAL CALL TO APARMS-
*                                  SET ANY FINAL FLAGS NEEDED.
AJOAPMOV EQU   B'00001000'         (AJOAPMOD)- MOVE PARM FIELD INTO
*              AJOPARM, WITH BLANK PADDING.  IF NOT SET, APARMS WILL
*              LEAVE PARM WHERE IT IS, AND ASSUME THAT ITS LENGTH
*              INCLUDES AT LEAST ONE BLANK FOLLOWING ACTUAL PARM.
         SPACE 1
*        ----- NEXT 2 BITS POSSIBLY SET ONLY WHEN &$TIMER=2,&$RECORD=2
AJOAPUSR EQU   B'01000000'         (AJOAPMOD)- SET IF USER SUPPLIED R=
AJOAPUST EQU   B'10000000'         (AJOAPMOD)- SET IF USER SUPPLIED T=
AJOBATCH EQU   B'00000001'         (AJOMODE)==> BATCH MODE,DON'T CLOSE
         SPACE 1
AJOREPLF EQU   B'00000010'         (AJOMODE)==> REPLACE MODE RUN
AJOMONIT EQU   B'00000100'         (AJOMODE)==> RUNNING UNDER WATFR MON
AJNSYSIN EQU   B'00001000'         (AJOMODE)==> NO SYSIN, ABORT RUN
AJOSRECX EQU   B'00100000'         (AJOMODE)==> RECORD OVERRUN OCCURRED
AJOSOVRT EQU   B'00010000'         (AJOMODE)==> TIME OVERRUN OCCURRED
AJOREPHB EQU   B'01000000'         (AJOMODE)==>REPLACEMENT PHASE B
         SPACE 1
AJOMSINT EQU   B'00000001'         (AJOSTEP)- MAIN STORAGE INIT DONE
AJOSDUMP EQU   B'00100000'         (AJOSTEP)- PROGRAM IN DUMPING PHS
AJOSEXEC EQU   B'01000000'         (AJOSTEP)==> PROGR IN EXECUTION
AJOSASM  EQU   B'10000000'         (AJOSTEP)==> PROG IN ASSEMBLY PHASE
         SPACE 1
AJNLOAD  EQU   B'00000001'         (AJOASMF)==> CHECK ONLY, NO OBJCT CD
AJNLIST  EQU   B'00000010'         (AJOASMF)==> NO LISTING DESIRED
AJOLARGE EQU   B'00000100'         (AJOASMF)==> PROGRAM IS LARGE,OPTIM
AJODISKU EQU   B'00001000'         (AJOASMF,AVTAGS1) => DISK OPTION
AJORELOC EQU   B'00010000'         (AJOASMF)==> RELOC CODE TO REAL @'S
         SPACE 1
AJOCMPRS EQU   B'00000001'         (AJOASMF2,AVTAGS2)-COMPRESSD LISTING
AJOCOMNT EQU   B'00000010'         (AJOASMF2-AVTAGS2)- COMMENT CHECK
AJODECK  EQU   B'00000100'         (AJOASMF2-AVTAGS2)- PUNCH OBJ DECK
AJOASTOP EQU   B'01000000'         (AJOASMF2-AVATGS2)- STOP ASSEMBLY
         SPACE 1
AJOMACRO EQU   B'00000001'         (AJOASMFM,AVMTAGSM)=> MACROS(F) OK
AJOMACRG EQU   B'00000010'         (AJOASMFM,AVMTAGSM)=> ASM G MACROS
AJOMACRH EQU   B'00000100'         (AJOASMFM,AVMTAGSM)=> ASM H MACROS
AJOMACRV EQU   B'00001000'         (AJOASMFM,AVTAGSM)=> OS/VS ASM
         SPACE 1
AJOLIBMC EQU   B'10000000'         (AJOASMFM,AVMTAGSM)=>PRT LIB MACROS
AJOSUPER EQU   B'00000010'         (AJOEXEF)==> INIT USER IN SUPERVISOR
AJONALGN EQU   B'00000100'         (AJOEXEF-ECFLAG4)==>NO ALIGNMENT 0C6
         SPACE 1
AJIOPEN  EQU   B'00000001'         (AJIO-SO-RE-PR-PN)==> DCB OPEN
AJIOEOF  EQU   B'00000010'         (AJIO-SO-RE)==> END-FILE ENCOUNTERED
AJIODEOF EQU   B'00000100'         DISK END-OF-FILE FLAG
AJIOSYND EQU   B'00010000'         DISK SYNAD ERROR FLAG
AJIOSOHS EQU   B'00010000'         (AJIOSO)- OUTPUT BUFFER FLUSH      J
AJIOPSEO EQU   B'00000100'         (AJIO-SO-RE)=> PSEUDO ENDFILE(JCL)
AJIOPAGE EQU   B'01000000'         (AJIOPR)- PAGE CONTROL MODE ON
AJIOSORR EQU   B'01000000'         (AJIOSO)- REREAD LAST CARD READ    J
AJIODKNO EQU   B'10000000'         DISK DCB COULD NOT BE OPENED
AJIOKP26 EQU   B'10000000'         (AJIOSO) - KP=26 -TRANSLATE TO 029
AJIOSING EQU   B'10000000'         (AJIOPR)-SINGLE SPACE CARRIAGE CONT
*                                  EXCEPT  NEW PAGE==> DOUBLESPACE
AJIODFLT EQU   B'10000000'         (AJIO-RE,PN)==> USING SO OR PR DEFLT
         SPACE 1
AJOOBJIN EQU   B'00000001'         (AJODECKF) - OBJECT INPUT DECK
         SPACE 1
AJOZEROS DC    16F'0'              FOR USE IN ZEROING THINGS
AJ1000   DS    F'1000'             FOR CONVERSIONS
AJ2604   DC    F'2604'             FOR USE IN TIME CONVERSIONS
AJ100000 DC    F'100000'           FOR USE IN TIME CONVERSIONS
AJ100M   DC    F'100000000'        FOR USE IN SECS==>TIMER UNITS
AJOVWXPT DS    V(VWXTABL)          @ MAIN ASSEMBLER TABLE
AJOEXECU DS    V(EXECUT)           ADCON FOR INTERPRETER CODE
         DS    0D
         AIF   (NOT &$KP26).AJNKP26         SKIP IF NO KP=26 OPT ALLWS
AJTRTB26 DS    XL256               026-->029 KEYPUNCH TRANSLATE TABLE
.AJNKP26 ANOP
AJOBLANK DC    CL136' '            FOR GENERAL SUPERVISOR BLANKING
AJOPARMA DS    C                   FOR CARRIAGE CONTROL
AJOP$L   EQU   100                 MAXIMUM LENGTH OF PARM FIELD
AJOPNDFT DS    0CL88               CARD IMAGE HERE IF NOPUNCH USED.
AJOPARM  DS    CL(AJOP$L+2)        SPACE FOR PARM,2 TRAILING BLANKS
AJOCP$L  EQU   5                   MAX # CHARACTERS IN EACH PARM
         DS    0D                  MAKE AJOCOMP PART OF AJODWORK
AJOCOMP  DS    0CL(AJOCP$L)        SPACE FOR COMPARE DURING PARM SCAN
         SPACE 1
AJODWORK DS    D                   GENERAL DOUBLEWORD WORKAREA
AJOPADL  DS    A                   PERMANENT LOW @ WORKAREA
AJOPADH  DS    A                   PERMANENT HIGH @ WORKAREA
AJOTADL  DS    A                   TEMPORARY LOW @ WORKAREA
AJOTADH  DS    A                   TEMPORARY HIGH @ WORKAREA
AJOECOPT DS    A                   @ ECONTROL, EXECUTION CONTROL BLK
         SPACE 1
AJO$APC  EQU   *                   BASE @ FOR OFFSETS TO PARM VARIABLES
AJOZER1  EQU   *                   PLACE TO BEGIN ZEROING ON INIT
         AIF   (&$REPL EQ 0).AJNREPL        SKIP GEN IF NO REPL
AJORFLAF DS    0F,H                DUMMY RFLAG INTO FULLWORD-MAKES
*                                  CODE IN APARMS CSECT EASIER
AJORFLAG DS    H                   REPLACE FLAG FROM RFLAG=
.AJNREPL ANOP
         AIF   (NOT &$PAGE).AJNPAGE         SKIP IF NO PAGE CONTROL
AJOL     DS    F                   LINES/PAGE FROM PARM FIELDS
AJOP     DS    F                   TOTAL PAGES FROM PARM FIELDS
AJOPX    DS    F                   PAGES FOR EXECUTION TIME,PARM FIELD
AJOPD    DS    F                   PAGES FOR DUMP IF RECORDS EXCEEDED
*              AJOLREM-AJOPREM MUST BE IN ORDER GIVEN TOGETHER
AJOLREM  DS    F                   LINES REMAINING IN PAGE AT ANY TIME
AJOPREM  DS    F                   PAGES REMAINING AT ANY TIME
*              FOLLOWING VARIABLES MAY BE SET WITH AJIOSING FLAG TO
*              SHOW SINGLE SPACE CRUNCHING DURING NOTED PROG PHASE.
*              SINGLE SPACE ACTION TAKEN ONLY IF PAGE CONTROL OPT USED
AJIOSS   DS    B                   SET==> SINGLE SPACE DURING ASSEMBLY
AJIOSSD  DS    B                   SET==> SINGLE SPACE DURING DUMP
AJIOSSX  DS    B                   SET==> SINGLE SPACE DURING EXECUT
.AJNPAGE ANOP
AJORD    DS    F                   # RECORDS MINIMUM ALLLOWED FOR DUMP
AJORX    DS    F                   RECORDS FOR EXECUTION TIME
AJOTD    DS    F                   MINIMUM TIME SAVED FOR DUMP
AJOTX    DS    F                   TIME(SECS) FOR EECUTION TIME
AJOTIML  DS    F                   TIME LIMIT FOR JOB, FROM T=
AJORECNT DS    F                   # RECORDS REMAINING(DECREMENTED)
AJORECL  DS    F                   RECORD LIMIT, FROM R=
AJOINSL  DS    F                   # EXECUTED INST LJMIT, FROM I=
AJONERRF DS    0F,H                DUMMY AJONERR INTO FULLWORD.
*                                  SIMPLIFIES CODE IN APARMS
*        **NOTE** SECTION FROM AJONERR - AJOAVL MUST CORRESPOND       *
*        EXACTLY TO SECTION AVNERR - AVAJL, INC ALIGNMENT.            *
*        THIS SECTION MOVED TO CORRESPONDING SECTION IN AVWXTABL.     *
AJONERR  DS    H                   MAXIMUM # ERRORS TO STILL OK EXECUT
         SPACE 1
         AIF   (NOT &$MACROS).AJNMACX       SKIP IF NO MACROS
*              MACRO  OPTIONS AND FLAG BYTES.
AJOMAC01 DS    0F                  START OF MACRO PARAMETER OPTIONS
AJOMACTR DS    F                   INITIAL ACTR VALUE FOR MACROS/MAIN
AJOMNEST DS    F                   MAXIMUM NEST LEVEL FOR MACROS
AJOMSTMG DS    F                   GLOBAL LIMIT: MACRO STMTS PROCESSED
AJOASMFM DS    B                   MACRO FLAGS (SETS AVTAGSM)
.AJNMACX ANOP
AJOASMF0 DS    B                   ASSEMBLER FLAG **FUTURE USE*********
AJOASMF  DS    C                   FLAG BYTE FOR ASSEMBLER SECTION
AJOASMF2 DS    B                   2ND BYTE OF FLAG BITS(FUTR USE)
         AIF   (NOT &$XREF).NOXREF3                                   A
*  CROSS REFERENCE FLAG BYTE                                          A
AJOXREF  DS    C                   FLAG FOR XREF FACILITY             A
.NOXREF3 ANOP                                                         A
AJOAVL   EQU   *-AJONERR           LENGTH OF SECTION MOVED TO AVWXTABL
         SPACE 2
AJOMODE  DS    B                   MODE FLAG, MISC FLAGS.
AJOSTEP  DS    B                   FLAG SHOWING CURRENT STEP
*              EXECUTION CONTROL FLAGS, MUST BE IN GIVEN ORDER. SECTION
*        AJOEC - AJOECL MUST CORRESPOND WITH ECAJ - ECAJL.            *
AJOEC    DS    0F                  BEGIN AREA  --  ALIGNMENT
AJOIECF  DS    F                   IECF=  (ONLY NEEDED FOR &$EXINT=1)
AJODMPF  DS    B                   DUMP FLAGS (SETS ECFLAG3)
AJOEXEF  DS    B                   GENRAL EXECUTION MODE FLAGS(ECFLAG4)
AJOEXEFA DS    B                   EXECUTION FLAGS (ECFLAG5) **FUTURE**
AJOECL   EQU   *-AJOEC             LENGTH OF FLAG BYTES
         SPACE 1
AJOAPMOD DS    B                   FLAG BYTE FOR RUNNING MODE OF APARMS
AJOAPSET DS    B                   SET BYTE - OR'D BY APARMS WHEN IT
*              SETS APCFLAG TO SHOW VALUE SET. SEE APCSET,SETLD,SETU
         SPACE 1
AJIOFLAG DS    0BL4                AREA OF FLAGS FOR DCB'S
AJIORE   DS    B                   FLAG BYTE FOR DATA READER(XXXXREAD)
AJIOSO   DS    B                   FLAG BYTE FOR SOURCE RDR (XXXXSORC)
AJIOPR   DS    B                   FLAG BYTE FOR PRINTER(XXXXPRNT)
AJIOPN   DS    B                   FLAG BYTE FOR PUNCH (XXXXPNCH)
AJIODSK  DS    B                   FLAG BYTE FOR RUNNING MODE DISKU
AJIOWRKB DS    B                   WORK BYTE FOR USE OF XXXXIOCO
         SPACE 1
AJODEBUG DS    B                   DEBUG FLAG BYTE
AJODECKF DS    B                   OBJECT DECK CONTROL FLAG
AJOBTRQ  DS    C                   ASSIST SETS FOR XXXXSORC USE       J
AJOBTYP  DS    C                   XXXXSORC SETS FOR ASSIST           J
AJOTIMR  DS    F                   TEMPORARY TIME WORK AREA
AJOFREE  DS    F                   MEMORY TO BE FREED TO OPERATING SYST
AJOZER$L EQU   *-AJOZER1           LENGTH OF AREA TO BE ZEROED
         DS    0D
AJOJCLCD DS    CL80                ASSIST JCL STORED HERE BY READ ROUTN
AJOJCLPM EQU   AJOJCLCD+15         LOCATION OF $JOB PARM FIELD
         AIF   (NOT &$ACCT).AJONACC         SKIP IF NO ACCT INFO
         SPACE 1
*              ACCOUNT # CHECKING DATA - FROM $TIRC (NAME,AJOACCT)
AJOACCT  DS    CL5                 ACCOUNT #
AJOJOBNM DS    CL8                 JOB NAME
AJOPRGNM DS    CL20                PROGRAMMER'S NAME
.AJONACC ANOP
AJOB$L   EQU   *-AJOBCON           GET LENGTH OF AJOBCON
         TITLE '*** ECONTROL DSECT - EXECUTION CONTROL BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ECONTROL   EXECUTION CONTROL BLOCK                        *
*        THIS BLOCK CONTAINS ALL DATA REQUIRED TO DESCRIBE A USER     *
*        PROGRAM TO BE EXECUTED BY THE ASSIST INTERPRETER (EXECUT).   *
*        IT CONTAINS SIMULATED USER REGISTERS AND PROGRAM STATUS WORD,*
*        AN INSTRUCTION STACK, POINTERS TO THE USER PROGRAM CODE,     *
*        AND VARIOUS FLAGS DESCRIBING THE RUNNING MODE AND OPTIONS    *
*        ALLOWED TO THE USER PROGRAM.  IT IS CREATED FROM INFORMATION *
*        FROM THE ASSEMBLER, THE USER PARM FIELD, AND FROM THE        *
*        OPTIONS IN ASSIST, AND IS MODIFIED BY EXECUT.  IT ALSO       *
*        PROVIDES ALL DATA NEEDED BY XXXXSNAP TO DO A USER DUMP.      *
*        LOCATION: IN HIGH END OF DYNAMIC CORE AREA.                  *
*        NAMES: EC------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ECONTROL DSECT
EC$STACK EQU   10                  MAX # OF INSTS KEPT IN STACK
         SPACE 1
$ECCONT  EQU   X'80'               (ECFLAG0)==>CONTINUE,DO NOT INIT
$ECADSOK EQU   X'40'               (ECFLAG0)==>RELOCATION&LIMIT @'S OK
$ECEOF   EQU   X'20'               (ECFLAG0)==>EOF ON CARD READER
$ECPROT  EQU   X'10'               (ECFLAG0)==> ABSOLUTE PROTECT MODE
*              I.E. THIS FLAG MEANS FETCH PROTECT IN ADDITION TO STORE*
$ECSPIEA EQU   X'08'               (ECFLAG0)==> EXECUT SPIE IN EFFECT
$ECSPIEB EQU   X'04'               (ECFLAG0)==> REMOVE SPIE BEFORE EXIT
         SPACE 1
$ECBROUT EQU   2                   (ECFLAG1)==> BRANCH OUT OF RANGE
$ECTIMEX EQU   4                   (ECFLAG1)==> TIME COUNT EXCEEDED
$ECREADR EQU   6                   (ECFLAG1)==> ATTEMPT READ PAST EOF
$ECRECEX EQU   8                   (ECFLAG1)==> RECORDS EXCEEDED
$ECABEND EQU   10                  (ECFLAG1)==> USER REQUESTED ABEND
$ECBRN14 EQU   12                  (ECFLAG1)==> NORMAL RETURN (R14)
         SPACE 1
$ECREGS  EQU   B'00000001'         (ECFLAG3)==>PRINT REGS IN DUMP
$ECDINST EQU   B'00000010'         (ECFLAG3)==>PRINT INST TRACE IN DUMP
$ECSTORG EQU   B'00000100'         (ECFLAG3)==> PRINT USER STORAGE
$EC$JRM  EQU   B'10000000'         (ECFLAG3)==> SPECIAL JRM DEBUG
         SPACE 1
$ECPRBST EQU   X'01'               (ECKYAMWP) ==> PROBLEM STATE PROG
         SPACE 1
*              REPLACE MONITOR FLAGS, SET BY RFLAG= AND XREPL INSTR.
ECR$CARD EQU   B'00000001'         (ECRFLAG+1)PRINT CARDIMAGE
ECR$REGA EQU   B'00000010'         (ECRFLAG+1)PRINT REGS BEFORE ENTRY
ECR$REGB EQU   B'00000100'         (ECRFLAG+1)PRINT RESULTS FROM REAL P
ECR$REGC EQU   B'00001000'         (ECRFLAG+1)PRINT RESULTS OF USER PRG
ECR$REGD EQU   B'00010000'         (ECRFLAG+1) PRT IF USER CALLS
ECR$ERRC EQU   B'10000000'         (ECRFLAG+1)=> ERROR FOUND IN REGS
         SPACE 1
*              FLOATING POINT REGISTER SAVE AREA                      *
ECFPREGS DS    4D                  DUMMY FLOATING POINT REGS
ECDWORK  EQU   ECFPREGS            WE CAN USE FP REGS AS WORK AREA
         SPACE 1
*              SIMULATED GENERAL PURPOSE REGISTERS                    *
ECREGS   DS    16F                 FAKE REGISTERS FOR INTERPRETER
ECREG1   EQU   ECREGS+4            FAKE R1
ECREGRA  EQU   ECREGS+4*RA         FAKE RA
ECREG12  EQU   ECREGS+48           FAKE R12(RAT)
ECREG13  EQU   ECREGS+52           FAKE R13
ECREG14  EQU   ECREGS+56           FAKE R14, RETURN @ REG
ECREG15  EQU   ECREGS+60           FAKE R15, ENTRY PT REG
         DS    F                   DUMMY REG, SIMPLIFIES SINGLE SHIFTS
*              NECESSARY TO USE CURRENT CODE FOR SLL 15,1, FOR EXAMPLE
ECR14SAV DS    A                   ORIGINAL RETURN @ FOR COMPARISON
ECZER1   EQU   *                   BEGINNING FOR BLOCK ZEROING
         SPACE 1
*              SIMULATED PROGRAM STATUS WORD                          *
ECPSW    DS    0D                  PSW FOR PROG
ECSYSMSK DS    C                   SYSTEM MASK
ECKYAMWP DS    C                   PROT KEY, AMWP FIELD
ECINTCOD DS    H                   INTERRRUPT CODE
ECILCMSK DS    C                   ILC-CC-PROGRAM MASK
ECPSWIAD DS    CL3                 INSTRUCTION ADDRESS
         SPACE 1
*              CONTROL FLAGS                                          *
ECFLAGS  DS    0F                  A FULLWORD FOR FLAGS
ECFLAG0  DS    C                   MAJOR CONTROL BITS
ECFLAG1  DS    C                   USED TO RETURN SPECIAL ERROR CODES
ECFLAG2  DS    C                   CONTROLS DEBUG MODE SNAPS
ECAJ     DS    0F                  BEGIN AJOBCON FLAGS, ALIGN
ECOIECF  DS    F                   ORIGINAL IECF (&$EXINT ONLY)
ECFLAG3  DS    B                   DUMP CONTROL FLAG (AJODMPF)
ECFLAG4  DS    B                   MISC. EXEC FLAGS (AJOEXEC)
ECFLAG5  DS    B                   MISC EXEC FLAGS (AJOEXEFA)*FUTURE***
ECAJL    EQU   *-ECAJ              LENGTH OF FLAGS GROUP MUST = AJECL
ECRFLAG  DS    H                   REPLACE MONITOR FLAG
         SPACE 1
ECERRAD  DS    A                   @ SPECIAL ASSIST COMPLETION MESSAGE
ECSVCADS DS    A                   @ ADDRESS LIST OF SVC'S,=0 IF NONE
ECZER$L  EQU   *-ECZER1            LENGTH OF AREA FOR BLOCK ZEROING
ECFADHC  DS    A                   HIGH @ PROG + SAVE = ECFADH-256
*              ECILIMT-ECILIMP MUST BE IN ORDER GIVEN, USED IN LM     *
ECILIMT  DS    F                   INST COUNT LIMIT (DECREMENTED)
ECILIMP  DS    F                   PERMANENT INSTRUCTION COUNT LIMIT
         SPACE 1
*              ECRDLIML-ECRDLIMH GIVE DUMP LIMTS. MUST BE IN GIVEN ORDR
ECRDLIML DS    A                   REAL DUMP LIMIT LOW(INIT=ECRADL)
ECRDLIMH DS    A                   REAL DUMP LIMIT HIH(INIT=ECRADH)
         SPACE 1
*              ADDRESS VALUES DESCRIBING LIMITS OF USER PROGRAM.      *
*              **NOTE** THEY MUST BE IN THE ORDER GIVEN BELOW.        *
ECRADL   DS    F                   REAL LOWEST ADDRESS OF PROGRAM
ECRADH   DS    F                   REAL HIGHEST ADDRESS
ECRELOC  DS    F                   RELOCATION CONTINUALLY APPLIED
ECFENTER DS    A                   USER PROGRAM FAKE ENTRY POINT @
ECFADL   DS    F                   FAKE LOWEST ADDRESS OF PROGRAM
ECFADH   DS    F                   FAKE HIGHEST ADDRESS OF PROGRAM
         SPACE 1
ECINSTAC DS    (EC$STACK)CL16      INSTRUCTION STACK
ECRSTK   DS    F                   SAVE WORD FOR RSTK POINTER
ECSAVE1  DS    A                   @ FAKE SAVE AREA FOR USER PROG
ECPICA   DS    F                   SAVE WORD FOR PREVIOUS PICA
ECTSAVE  DS    16F                 FOR SAVING REGS WHEN DOING CALLS
         AIF   (NOT &$EXINT).ECOVER
         SPACE 2
EC$BRSTC EQU   10                  SIZE OF BRANCH STACK (# OF SLOTS)
ECBRSTAC DS    (EC$BRSTC)CL16      BRANCH STACK
ECBSTK   DS    F                   SAVE WORD FOR BSTK POINTER
ECBCUR   DS    F                   CURRENT STACK PTR SAVED HERE
         AIF   (&$EXINT EQ 0).ECNOEXT   SKIP IF NO EXTENDED INTERPRETER
         SPACE 5
* * * * * * * * * * * * * * ##### EXTENSION ##### * * * * * * * * * * *
*                                                                     *
*        IMPORTANT-->  THIS SECTION IS AN EXTENSION TO THE            *
*        ECONTROL DSECT AND IS USED BY THE OPTIONAL ASSIST            *
*        INTERPRETER.  IT CONTAINS FLAGS, EQUATES, AND                *
*        ADDRESSES FOR USER INTERRUPT HANDLING AND OTHER              *
*        USER OPTIONS.  SEE PSEUDO-INSTRUCTION XOPC.                  *
*                                                                     *
*        NOTE:  DATA IN THIS AREA IS ACCESSABLE TO THE USER           *
*        PROGRAMMER BY MEANS OF VARIOUS XOPC INSTRUCTION              *
*        CODES, AND IN GENERAL BY XOPC 12 & 13.                       *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
ECPRCB   EQU   *
*              FLAGS USED BY THE OPTIONAL INTERPRETER
*
*              FLAGS FOR OPTIONS-IN-EFFECT CHECKING
*              NOTE: ECPRCBF1 WILL NOT BE USED FOR ANY OTHER
*                    FLAG TYPES.
ECPRTRCE EQU   B'00000001'         (ECPRFLG1)==> TRACE = ON
ECPRMODC EQU   B'00001000'         (ECPRFLG1)==> MODIFICATION CHECKING X
                                                 = ON
ECPRIECF EQU   B'00000010'         (ECPRFLG1)==> COUNT FACILITY ON
ECPRCTON EQU   B'00000100'         (ECPRFLG1)==> HAS COUNT ON BEFORE?
ECPRCTOF EQU   B'00000000'         (ECPRFLG1)==> COUNT FACILITY OFF
ECPRNOSP EQU   B'00001000'         (ECPRFLG1)==> NO SPACE FOR COUNT FAC
*
*              FLAGS FOR MACHINE EMULATION (ECPRCBF2 LOW ORDER NIBBLE)
*              AND OTHER DATA.
*
*              NOTE: THE FLAGS FOR MACHINE EMULATION CAN BE CHANGED
*              DYNAMICALLY BY THE USER PROGRAMMER BY WAY OF THE XOPC
*              INSTRUCTION.  THIS ALLOWS RUN-TIME CONTROL OF EMULATION
*              OPTIONS, SINCE THESE FLAGS ARE CHECKED BEFORE THE
*              INTERPRETATION OF EACH USER INSTRUCTION.  IF THE USER
*              PROGRAM SCREWS UP THESE FLAGS, IT MAY BE
*              TERMINATED 'CONFUSINGLY' WITH AN OC-1 ON A VALID
*              INSTRUCTION.
ECEM360  EQU   B'00000100'         (ECPRFLG2)==>  MACHINE = 360
ECEM370  EQU   B'00001000'         (ECPRFLG2)==>  MACHINE = 370
ECSUPRST EQU   B'01000000'         (ECPRFLG2)==> IN SUPERVISOR STATE
ECALNCHK EQU   B'10000000'         (ECPRFLG2)==> ALIGNMENT CHECKING=ON
ECSPISET EQU   B'10000000'         (ECPRFLG3)==> A PSEUDO SPIE IS SET
ECINHDST EQU   B'01000000'         (ECPRFLG3)==> INTERRUPT HANDLING ST
ECNOSPI  EQU   B'00000000'         (ECPRFLG3)==> NO SPIE INTERRUPT SET
ECLKADR  EQU   B'00000001'         (ECPRFLG4)==> CLOCK EXIT ADDR SET
*              PRCB STORAGE BEGINS HERE
ECPRFLG1 DS    B
ECPRFLG2 DS    B
ECPRFLG3 DS    B
ECPRFLG4 DS    B
ECPRFLG5 DS    B
ECPRFLG6 DS    B
ECPRFLG7 DS    B
ECPRFLG8 DS    B
*              INSTRUCTION TRACE AND MONITOR ADDRESSES
*              ***** NOTE: DO NOT CHANGE THE ORDER OF THESE SOURCE
*                          RECORDS
ECPRTRAL DS    A                   BEGINNING (LOW) @ OF TRACE         M
ECPRTRAH DS    A                   ENDING (HIGH) @ OF TRACE           M
ECPRMODL DS    A                   BEGINNING (LOW) @ OF CHECK FACILITY
ECPRMODH DS    A                   ENDING (HIGH) @ OF CHECK FACILITY
*              INSTRUCTION COUNTER (PSEUDO-CLOCK) INFORMATION
ECPRCLOK DS    F                   CLOCK (DECMTD BY 1 FOR EACH INSTR)
ECPRCMPR DS    F                   COMPARATOR (CHECKED AGAINST CLOCK   X
                                   FOR INTERRUPT TEST)
ECPRCLEA DS    A                   USER SPECIFIED CLOCK EXIT ADDRESS
*              EXIT ADDRESS FOR USER SPECIFIED PSUEDO-SPIE HANDLING
*              (IF NOT SPECIFIED, THIS ADDRESS WILL BE ZERO.)
ECPRSCDE DS    F                   USER SPECIFIED SPIE CODE MASK
ECPRSPIE DS    A                   EXIT ADDRESS FOR PSUEDO-SPIE XOPC 0
*              2 WORD SAVE AREA FOR INTERRUPT (REGS 0 - 1)
ECPRIRGS DS    2F                  DEFINE 2 WORD SAVE AREA
*              STORAGE FOR IECF (BY ADDRESS) INFORMATION
ECPRICA  DS    A                   BEGIN @ OF IECF (BY ADDR) COUNTERS
ECPRICAL DS    F                   LENGTH OF COUNTING AREA
ECPRICL  DS    A                   IECF LOW @ COMPARATOR (BEGINNING)  M
ECPRICH  DS    A                   IECF HIGH @ COMPARATOR (ENDING)    M
*              MISCELLANEOUS EQUATES FOR THE OPTIONAL INTERPRETER
EISSINST EQU   B'11000000'         IDENTIFIES SS INSTRUCTIONS
ECPROPON EQU   ECPRTRCE+ECPRIECF
EC#XOPC  EQU   22                  # OF THE MAX LEGAL XOPC CODE
ECREG0   EQU   ECREGS              FAKE REG 0
ECREG2   EQU   ECREGS+8            FAKE REG 2
         SPACE 1
ECPRWORK DS    8F                  WORK AREA FOR FUTURE GENERAL USE
         SPACE 1
ECPRCB$L EQU   *-ECPRCB            LENGTH OF PRCB
.ECNOEXT  ANOP
.ECOVER  ANOP
         DS    0D
EC$LEN   EQU   *-ECONTROL          LENGTH OF ECONTROL DSECT
         TITLE '*** ECSTACKD DSECT - ECONTROL INSTRUCTION STACK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ECSTACKD   SINGLE ENTRY IN ECONTROL INSTRUCTION STACK     *
*        THE ECONTROL INSTRUCTION STACK IS A CIRCULAR LINKED LIST     *
*        WHICH ALWAYS CONTAINS DATA ON UP TO THE LAST 10 INSTRUCTIONS *
*        INTERPRETED DURING EXECUTION.  IT IS FILLED IN BY EXECUT, AND*
*        IS USED BY XXXXSNAP TO PROVIDE THE INSTRUCTION TRACE PART    *
*        OF A USER COMPLETION DUMP.                                   *
*        LOCATION: INSIDE AREA ECINSTAC IN DSECT ECONTROL.            *
*        NAMES: EC------     (SAME AS ECONTROL NAME CHARACTERS)       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ECSTACKD DSECT
ECSTENT  DS    0CL16               INST STACK ENTRY
ECSTLINK DS    F                   ADDRESS OF NEXT STACK ENTRY
ECSTIADD DS    F                   INSTRUCTION ADDRESS
ECSTCCPM DS    H                   CON-CODE & PROGRAM MASK
         SPACE 1
ECSTINST DS    0CL6                UP TO 6 BYTES OF INSTRUCTION
ECOP     DS    C                   OPCODE
ECM1R2   DS    0C                  M1,R2 FIELD FOR BC'S
ECR1R2   DS    0C                  R1,R2 FIELD FOR RR INSTRUCTIONS
ECR1X2   DS    0C                  FIELD FOR RX INSTRUCTIONS
ECR1R3   DS    0C                  FIELD FOR RS INSTRUCTIONS
ECR1M3   DS    0C                  FIELD FOR RS INSTRUCTIONS
ECI2     DS    0C                  FIELD FOR SI INSTRUCTIONS
ECL1I3   DS    0C                  FIELD FOR SRP INSTRUCTION
ECOPEX   DS    0C                  2ND BYTE OF EXTENDED OP CODE
ECL1L2   DS    C                   FIELD FOR ALL SS INSTRUCTIONS
ECBD     DS    H                   1ST OR ONLY BASE-DISPLACEMENT FIELD
ECB2D2   DS    H                   2ND BASE-DISP(SS & SPECIALS ONLY)
