         TITLE '*** BROPS2 - BASE REGISTER OPERATIONS - PASS 2 ***'
**--> CSECT: BROPS2   2   ALL BASE REGISTER OPERATIONS - ALL PASS 2 . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BROPS2   CSECT
         $DBG  A0,SNAP
         ENTRY BRINIT,BRUSIN,BRDROP,BRDISP
         USING AVWXTABL,RAT        NOTE MAIN USING
         SPACE 2
**--> ENTRY: BRINIT   2   INITIALIZE BASE REGISTER TABLES . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRINIT   $SAVE SA=NO
         MVC   BRVALS(4*16),AWZEROS         ZERO OUT VALUE /ID TABLE
         $RETURN SA=NO
         SPACE 2
**--> ENTRY: BRUSIN   2   ENTER A REGISTER-VALUE PAIR . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = NUMBER OF REGISTER FOR WHICH USING TO BE SET UP = 0-15       .
*.  RB = ADDRESS DECLARED IN USING FOR GIVEN REGISTER = 0-2**24-1     .
*.  RC = ESDID OF THE USING VALUE, IN LOW ORDER BYTE = 1-255          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRUSIN   $SAVE SA=NO
         SLL   RA,2                REG #*4 FOR FULLWORD INDEXING
         ST    RB,BRVALS(RA)       STORE VALUE OF REG IN RIGHT SLOT
         STC   RC,BRVALS(RA)       STORE ID IN HI-ORDER BYTE
         $RETURN SA=NO
         SPACE 2
**--> ENTRY: BRDROP   2   DROP A REGISTER FROM USING. . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = NUMBER OF REGISTER TO BE DROPPED FROM USING - = 0-15         .
*.       EXIT CONDITIONS                                              .
*.  RB = 0    THE REGISTER WAS CURRENTLY USABLE                       .
*.  RB = ›0   THE REGISTER WAS NOT CURRENTLY IN USE                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRDROP   $SAVE SA=NO
         SLL   RA,2                REG# * 4 FOR INDEX TO TABLE
         LA    RB,BRVALS(RA)       SET RB›=0, @ WORD FOR DESIRED REG
         CLI   0(RB),0             WAS THE REG IN USE
         BE    BRDRRET             NO,BRANCH,LEAVING RB›=0-ERROR
         MVI   0(RB),0             SET ID = 0, DEFINITELY DROPPING REG
         SR    RB,RB               SET RB=0 TO SHOW OK
BRDRRET  $RETURN SA=NO
         EJECT
**--> ENTRY: BRDISP   2   GIVEN VALUE&ESDID, RETURN BASE-DISPLACEMENT .
*.       ENTRY CONDITIONS                                             .
*.  RA = ADDRESS VALUE TO BE DECOMPOSED TO BASE-DISPLACEMENT (24 BITS).
*.  RB = ESDID OF ADDRESS TO BE DECOMPOSED - LOW ORDER BYTE           .
*.       VALUE IS FROM 1-255. 0 CAN BE USED TO MARK NONUSABLE.        .
*.       EXIT CONDITIONS                                              .
*.  RA = BASE-DISPLACEMENT FORM OF ADDRESS, IF ADDRESSABLE            .
*.  RB = 0    NORMAL RETURN - ADDRESS WAS DECOMPOSABLE                .
*.     = ›0   ADDRESSIBILITY ERROR(NO REG,OR DISP TOO LARGE)          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
BRDISP   $SAVE RGS=R14,SA=NO
         STC   RB,BRCESD+1         PLACE ESDID INTO CLI INSTRUCTION
         SLL   RB,24               SHIFT ID TO HI-ORDER BYTE OF RB
         ALR   RA,RB               PUT SECITON ID IN WITH VALUE
         LM    RC,RE,BRRGSCDE      GET INITIAL VALUES FOR RC,RD,RE
         SR    R14,R14             R14 = 0 ==> NO REGISTER FOUND YET
         SPACE 1
*              THE FOLLOWING LOOP EXECUTED 16 TIMES, CHECK EACH REG   *
BRCESD   CLI   0(RC),$CHN          COMPARE INCOMING ESDID WITH 1 OLD
         BNE   BRLOOP              IF NOT EQUAL,GO TO NEXT
         CL    RA,0(,RC)           COMP INCOMING VALUE TO ONE IN USE RG
         BL    BRLOOP              REGISTER HIGHER THAN ADDRESS-NO USE
         CL    RB,0(,RC)           COMP PREVIOUS BEST REG TO NEXT ONE
         BH    BRLOOP              IF PREVIOUS BEST > NEW, SKIP
         L     RB,0(,RC)           GET NEW BEST ID/VALUE
         LR    R14,RC              SAVE FOR INDEX TO BEST REG
BRLOOP   BXLE  RC,RD,BRCESD        BUMP TO NEXT REG, GO BACK TO CHK
         SPACE 1
         S     R14,BRRGSCDE        S R14,=A(BRVALS) = 4* REG #, IF OK
         BM    BRNOGOOD            IF R14 WAS =0, NO USABLE REG, BRANCH
         SLR   RA,RB               COMPUTE DISPLACEMENT FOUND
         C     RA,AWF4095          C RA,=F'4095' -MAKE SURE NOT BOG
         BH    BRNOGOOD            JUMP IF ILLEGALLY BIG
         SLL   R14,10              SHIFT REG NUMBER TO RIGHT SPOT
         AR    RA,R14              PUT BASE AND SIP TOGETHER
         SR    RB,RB               ZERO TO SHOW SUCCESSFUL COMPLETE
BRRET    $RETURN RGS=R14,SA=NO
BRNOGOOD LR    RB,RD               RB = 4 ==> ADDRESSIBLITY ERROR
         B     BRRET               GO RETURN TO CALLER
         SPACE 1
BRRGSCDE DC    A(BRVALS,4,BRVALS+60)   2NDEX,INCREM,LIMIT-REGS RC,RD,RE
* * * * * INTERNAL VARIABLES                                          *
         DS    0D                  FOR ALIGNEMENT
BRVALS   DS    16F                 TABLE OF USABLE VALUES IN REGS
*              1ST BYTE OF EACH HAS ID, RESTS HAVE ADDRESS.
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** CACONS - A-TYPE CONSTANT PROCESSING ***'
**--> CSECT: CACONS   1-2 PROCESS A-TYPE ADDRESS CONSTANTS. . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CACONS   CSECT
         $DBG  A0,SNAP
         ENTRY CACON1,CACON2
         USING AVWXTABL,RAT        NOTE MAIN USING
         SPACE 2
**--> ENTRY: CACON1     SCAN ACON, BUT DO NOT ASSEMBLE VALUE. . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO  ==> ILLEGAL CONSTANT ($ERINVCN)                     .
*.       CALLS SCANCO                                                 .
*.       **NOTE** EXPRESSION ENDING IN  )  INSIDE MULTIPLE CONSTANT   .
*.       WILL BE PROCESSED IMPROPERLY, SUCH AS  DC  A(B+(C),D)  .     .
*.       THE CHARACTERS  C)  ARE TREATED AS END OF THE ACON.          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CACON1   $SAVE RGS=(R14-R1),BR=R1,SA=CACOSAVE
         LR    R0,RA               SAVE ORIG SCAN POINTER
         $CALL SCANCO              SCAN TO COMMA OR BLANK
         LTR   RB,RB               WAS THERE ERROR
         BNZ   CAC1RET             YES-ERROR-RETURN WITH IT
         CR    R0,RA               WAS THERE A NULL CONSTANT
         BE    CAC1ERR             YES-ERROR-BRANCH
         SPACE 1
         BCTR  RA,0                BACK UP SCAN PTR 1 BYTE
         CLI   1(RA),C','          WAS SCAN STOPPER A COMMA
         BNE   CAC1RET             NO, MUST BE END OF CONST: EXPR)
         SPACE 1
         CLI   0(RA),C')'          MAKE SURE THS IS RIGHT PAREN
         BE    CAC1RET             SKIP IF SO
         LA    RA,1(RA)            CONST ENDED WITH EXPR, RESET PTR=>,
         B     CAC1RET             GO EXIT
CAC1ERR LA     RB,$ERINVCN         NULL CONSTANT
CAC1RET  $RETURN RGS=(R14-R1)
         EJECT
**--> ENTRY: CACON2   1-2 SCAN ACON, ASSEMBLE VALUE . . . . . . . . . .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE - ERROR CODE (FROM EVALUT)                     .
*.     = $ERRELOC  IF SECTION ID IS A DSECT, WHICH IS NOT ALLOWED.    .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.  RD = ESDID OF CONSTANT, IF =0 ==> ABSOLUTE EXPRESSION             .
*.       CALLS EVALUT                                                 .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CACON2   $SAVE RGS=(R14-R0),BR=R13,SA=CACOSAVE
         LR    R0,RB               SAVE THE LENGTH-1 FOR ASSEMBLY
         $CALL EVALUT              CALL EXPRESSION EVALUATOR
         LTR   RB,RB               WAS THERE ERROR
         BNZ   CAC2RET             ERROR-RETURN
*              CHECK TO MAKE SURE DON'T DC  A(DSECT SYMBOL)
         STC   RD,AVFWORK1         STORE FOR TEST OF EVEN/ODD
         TM    AVFWORK1,$ESDSECT   TEST FOR ODD
         BZ    *+8                 NO, EVEN=> CSECT TYPE OR ABS TERM-OK
         LA    RB,$ERRELOC         NO GOOD- FLAG ERROR-DSECT RELOC
         ST    RC,AVCONBLD         STORE THE VALUE
         LCR   RE,R0               GET NEGATIVE OF LENGTH-1 FOR ASSMBLY
         LA    RC,AVCONBLD+3(RE)   GET REAL STARTING ADDRESS
CAC2RET  $RETURN RGS=(R14-R0)
         DROP  RAT,R1,R13
         TITLE '*** CBCONS - SCAN AND/OR ASSEMBLE BINARY CONSTANTS ***'
**--> CSECT: CBCONS   1-2 PROCESS BINARY CONSTANTS. . . . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CBCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CBCON1,CBCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CBCON1   1   SCAN B CONSTANT, DO NOT ASSEMBLE. . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CBCON1   $SAVE RGS=(R1-R2),SA=NO
         MVC   AWTDECT+C'2'(8),AWBLANK      CAUSE 2-9 TO BE ›=0
         SR    R1,R1               CLEAR SO TRT WORKSA RIGHT
         TRT   0(256,RA),AWTDECT   MUST ENCOUNTER DELIMITER (3CRD LIM)
         MVC   AWTDECT+C'2'(8),AWZEROS+C'2' REZERO TRT TABLE
         LA    RC,7(R1)            MOVE ENDING PTR,ROUND UP
         SR    RC,RA               GET # 0'S & 1'S,ROUNDED UP TO 8
         LR    RA,R1               MOVE ENDING POINTER FOR RETURN
         CLI   0(RA),C''''         WAS DELIMIER ' LIKE SUPPOSED TO
         BNE   CB1ERR              NO, ERROR, INVALID DELIMITER
         SRA   RC,3                DIVIDE BY 8, GET # BUTES REQUIRED
         BZ    CB1ERR              IF 0, CONST WAS B'', ERROR,BRANCH
         SR    RB,RB               SHOW NO ERROR
CB1RET   $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
CB1ERR   LA    RB,$ERINVCN         INVALID CONSTANT -SET FLAG FOR RETUR
         B     CB1RET              GO RETURN, SHOWING ERROR
         EJECT
**--> ENTRY: CBCON2   1-2 ASSEMBLE BINARY CONSTANT. . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CBCON2   $SAVE RGS=(R0-R2),SA=NO
         STC   RB,*+5              STORE LENGTH-1 INTO NEXT MVC
         MVC   AVCONBLD($CHN),AWZEROS       ZERO OUT WHOLE AREA
         SR    R1,R1               CLEAR FOR COMING TRT
         L     RD,AWFM1            =F'-1' FOR DECREMENTING LATER
         TRT   0(256,RA),AWTDECT   WE CHECKED IN PASS 1, LOOK FOR DLM
         LA    RE,0(RD,RA)         GET LIMIT FOR BXH, @ 1ST ' OF CONST
         LR    RA,R1               GET @  OF ENDING '
         BXH   R1,RD,CB2L2         DECREM LAST PTR, ENTER LOOP RIGHT
         SPACE 1
CB2L1    BCT   R2,CB2L3            DECREMENT BIT POSITION POINTER,BRNCH
         STC   R0,AVCONBLD(RB)     STORE ASSEMBLED BYTE INTO POSITION
         AR    RB,RD               SUBTRACT 1 FROM BYTE COUNT
         BM    CB2RETA             IF <0, WE ARE DONE, QUIT
         SPACE 1
*              INITIALIZATION - 1 TIME FOR EACH BYTE REQUIRED         *
CB2L2    SR    R0,R0               CLEAR FOR BUILDING UP BYTE
         LA    R2,8                # BITS IN 1 BYTE
         LCR   RC,RD               RC = 1, FOR SHIFTING BIT TO ADD
         SPACE 1
CB2L3    CLI   0(R1),C'0'          IS NEXT CHAR A 0
         BE    *+6                 SKIP ADDING BIT IN, IF SO
         ALR   R0,RC               ADD 1 BIT IN IN RIGHT BIT POSITION
         ALR   RC,RC               == SLL RC,1 - SHIFT 1 BIT OVER FOR N
         BXH   R1,RD,CB2L1         DECREMENT POINTER, JUMP TO CHECK
         SPACE 1
         STC   R0,AVCONBLD(RB)     RAN OUT OF DIGITS, STORE THE BYTE
CB2RETA  LA    RC,AVCONBLD         GET @ BEGINNING OF ASSEMBLED CONST
CB2RET   $RETURN RGS=(R0-R2),SA=NO
         DROP  RAT,REP             KILL USINGS
         TITLE '*** CCCONS - SCAN AND/OR ASSEMBLE C-TYPE CONSTANTS ***'
**--> CSECT: CCCONS   1-2 PROCESS CHARACTER TYPE CONSTANTS. . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CCCON1,CCCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CCCON1   1   SCAN,RETURN LENGTH,DO NOT ASSEMBLE. . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCCON1   $SAVE SA=NO
         SR    RC,RC               INDEX FOR BXLE, WILL GO FROM 0==>255
         LA    RD,1                INCREMENT FOR BXLE FOR LOOP
         LA    RE,255              LIMIT=LENGTH OF MAXIMUM CONSTANT
         SPACE 1
*              INITIALIZATION DONE, NOW DO CHECKING LOOP              *
CC1LOOP  CLI   0(RA),C''''         IS THE NEXT CHAR A '
         BNE   CC1CHK2             NO, GO CHECK FOR & OR OTHER
         CLI   1(RA),C''''         IS NEXT CHARACTER & '
         BNE   CC1OUT              NO IT ISNT, MUST BE END OF CONSTANT
         BXH   RA,RD,CC1LOOPA      BUMP SCAN POINTER 1 AND BRANCH
         SPACE 1
CC1CHK2  CLI   0(RA),C'&&'         IS CHAR AN &
         BNE   CC1LOOPA            BRANCH IF NOT==> NORMAL CHARACTER
         AR    RA,RD               INCREMENT TO 2ND &,HOPEFULLY
         CLI   0(RA),C'&&'         MAKE SURE 2ND & IS THERE TOO
         BNE   CC1ERR              ERROR IF IT ISNT-BRANCH
         SPACE 1
CC1LOOPA AR    RA,RD               INCREMENT POINTER TO NEXT CHAR
         BXLE  RC,RD,CC1LOOP       CONTINUE LOOPING
         SPACE 1
CC1ERR   LA    RB,$ERINVCN         NOTE THIS IS AN INVALID CONSTANT
         B     CC1RET              RETURN, WITH ERROR
         SPACE 1
CC1OUT   LTR   RC,RC               MAKE SURE LENGTH OF CONST>0
         BZ    CC1ERR              NULL CONSTANT==>ERROR
         SR    RB,RB               CLEAR TO SHOW LEGAL CONSTANT
CC1RET   $RETURN SA=NO
         EJECT
**--> ENTRY: CCCON2   2   SCAN, ASSEMBLE. . . . . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.  RD = LENGTH-1 OF CONSTANT (WAS IN RB ON ENTRY)              CPP
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CCCON2   $SAVE SA=NO
         LA    RD,1                FOR INCREMENT AND USEFUL CONST
         SR    RE,RE               CLEAR FOR COUNTER
*              **NOTE** BXH'S WORK OK SINCE RA>256 ALWAYS.
         SPACE 1
CC2LOOP  CLI   0(RA),C''''         IS CHAR A '
         BNE   CC2CHK2             BRANCH IF IT ISN'T
         CLI   1(RA),C''''         SEE IF NEXT 1 IS '
         BNE   CC2PAD              BRANCH==>HIT END OF CONST,PAD NEEDED
         BXH   RA,RD,CC2MOV        INCREMENT POINT TO 2ND '&JUMP
         SPACE 1
CC2CHK2  CLI   0(RA),C'&&'         IS CHAR AN &
         BNE   CC2MOV              JUMP IF IT IS NORMAL CHARACTER
         AR    RA,RD               INCREMENT TO POINT AT 2ND &
CC2MOV   IC    RC,0(RA)            GET THE CHARACTER
         STC   RC,AVCONBLD(RE)     SAVE THIS IN THE RIGHT PLACE IN CONS
         AR    RE,RD               INCREMENT NUMBER OF BYTES DONE
         BXH   RA,RD,CC2LOOP       INCREMENT AND JUMP BACK FOR NEXT
         SPACE 1
CC2PAD   LR    RD,RB               SAVE LENGTH-1 OF CONSTANT    CPP
         SR    RB,RE               RE=LENGTH-1 OF PAD, IF ANY   CPP
         BM    CC2RETA             IF <0, NO PAD REQUIRED, QUIT
         LA    RE,AVCONBLD(RE)     RE=@ OF FIRST BYTE TO BLANK  CPP
         STC   RB,*+5              STORE LENGTH INTO MVC
         MVC   0($CHN,RE),AWBLANK  PAD--BLANK OUT ENOUGH        CPP
         SPACE 1
CC2RETA  LA    RC,AVCONBLD         POINT TO BEGINNING OF ASSEMBLED CONS
CC2RET   $RETURN SA=NO
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** CDECNS - D AND E TYPE CONSTANT PROCESSING ***'
**--> CSECT: CDECNS   1-2 PROCESS D&E TYPE CONSTS . . . . . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CDECNS   CSECT
         $DBG  A0,SNAP
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         ENTRY CDECN1,CDECN2
         SPACE 2
**--> ENTRY: CDECN1   1   SCAN, BUT DO NOT ASSEMBLE D OR E TYPE CONSTS.
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.       CALLS CDECN2                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CDECN1   EQU   *                   USE SAMEENTRY AS CDECN2 FOR THIS
         EJECT
**--> ENTRY: CDECN2   1-2 SCAN,ASSEMBLE D&E TYPE CONSTANTS. . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       CALLS SDDTRM                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION - CDECN2  * * * * * * * * * * * * * * * *
*   F0 = ACCUMULATOR FOR VALUE BUILT UP FOR CONSTANT                  *
*   F2 = FLOATING POINT 10.0                                          *
*   F4 = INITIALLY FLOATING POINT 10.0. MULTIPLIED BY 10 FOR FRACTION *
*   F6 = FLOATING POINT WORK REGISTER                                 *
*   RA = SCAN POINTER ADDRESS REGISTER, ADVANCED DURING SCAN          *
*   RC = UNUSED CURRENTLY                                             *
*   RD = UNUSED CURRENTLY                                             *
*   RE = 1  USEFUL CONSTANT IN ODD REGISTER, USED FOR BXH'ING.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (&$FLOTA AND &$FLOTM).CD2FULL  SKIP IF OK TO HAVE D&E
*              RESTRICTED VERSION - IF NOT ACCEPTING FLOATING PT, OR
*              NOT ON MACHINE, ASSEMBLE ONLY D'0'  OR E'0'.
CDECN2   $SAVE SA=NO
         CLI   0(RA),C'0'          WAS IT LEGAL ZERO
         BNE   CD2INVCN            NO, BAD, WE ONLY ACCEPT 0
         LA    RA,1(RA)            BUMP SCAN PTR 1
         LA    RC,AWZEROS          SHOW @ 8 BYTES OF ZERO
         SR    RB,RB               SHOW ACCEPTABLE
CD2RET   $RETURN SA=NO             RETURN FROM SMALL MODULE
CD2INVCN LA    RB,$ERINVCN         SHOW INVALID, WASN'T 0
         B     CD2RET              RETURN WITH RROR
         DROP  RAT,REP             AVWXTABL,ENTRY BASE
         AGO   .CD2MINI            SKIP OVER REGULAR CODE
.CD2FULL ANOP
         SPACE 1
CDECN2   $SAVE SA=CDE2SAVE,RGS=(R14-R15),BR=R13
         MVI   CD2CON+1,X'F0'      MAKE NOOP TO BRANCH,INIT
         MVI   CD2FTEST+1,0        INIT THIS TEST TO NOOP
         LD    F0,AWD0             GET CONSTANT 0
         LD    F2,AWD10            GET USEFUL CONSTANT 10
         STD   F2,AVDWORK1         STORE VALUE WITH X'41' EXPONENT
         MVI   CD2PERI+1,0         INIT . BRANCH TO NOOP
         LDR   F4,F2               INIT F4 TO FLOATING PT 10 FOR DIVIDE
         LA    RE,1                FOR BXHING AND OTHER INCREMNTING
         MVI   CD2SIGN,X'20'       MAKE INST A LPDR-ASSUME + #
         CLI   0(RA),C'0'          DO WE START WITH DIGIT
         BNL   CD2DIG              YES,GO PROCESSES
         CLI   0(RA),C'.'          DO WE HAVE . AT BEGINNING
         BE    CD2PERI             GO THERE IF SO
         CLI   0(RA),C'+'          DO WE HAVE +
         BE    CD2INCA             YES,BUMP SCAN PTR,LEAVE SIGN OK
         CLI   0(RA),C'-'          DO WE HAVE -
         BNE   CD2INVCN            NO,MUST BE ERROR
         MVI   CD2SIGN,X'21'       MAKE INST LNDR SINCE NEGATIVE SIGN
CD2INCA  AR    RA,RE               BUMP SCAN PTR BEYOND SIGN
         EJECT
*              LOOP HEAD FOR SCANNING FOLLOWS.                        *
CD2LOOP  CLI   0(RA),C'0'          DO WE HAVE DIGIT
         BL    CD2NDIG             NO,BRANCH OUT
CD2DIG   MVI   CD2CON+1,0          MAKE BRANCH NOOP,SHOW 1 DIGIT,AT LEA
         UNPK  AVDWORK1+1(1),0(1,RA)   MOVE SWITCHED NIBBLES TO WORK
         NI    AVDWORK1+1,X'F0'    REMOVE EXTRA NIBBLE AT END, LEAVE #
CD2FTEST BC    $CHN,CD2LDIV        BRANCH OUT IF IN FRACTIONAL PART
         MDR   F0,F2               MULT ACCUMULATED VALUE BY 10
         AD    F0,AVDWORK1         ADD NEW VALUE INTO ACCUMUALTOR
         BXH   RA,RE,CD2LOOP       BUMP SCAN POINTER, GO FOR NEXT
         SPACE 1
CD2LDIV  LD    F6,AVDWORK1         GET VALUE OF NEXT DIGIT
         DDR   F6,F4               DIVIDE BY CURRENT POWER OF 10
         MDR   F4,F2               RAISE POWER OF 10 IN F4 BY ANOTHER
         ADR   F0,F6               ADD NEW VALUE IN
         BXH   RA,RE,CD2LOOP       BUMP SCAN PTR, GET NEXT
         SPACE 1
CD2NDIG  CLI   0(RA),C'.'          IS IT PERIOD
         BNE   CD2NOPR             NEITHER DIG NOR PERIOD
CD2PERI  BC    $CHN,CD2INVCN       IF WE COME HERE 2 TIMES-GO TO ERROR
         MVI   CD2PERI+1,X'F0'     MAKE NOOP A BRANCH TO ERROR
         MVI   CD2FTEST+1,X'F0'    MAKE BRANCH-SHOW FRACTION NOW
         BXH   RA,RE,CD2LOOP       BUMP SCAN PTR,GET NEXT
         EJECT
*              FOLLOWING SECTION SCANS FOR AN EXPONENT E AND SIGN
CD2NOPR  CLI   0(RA),C'E'          WAS THIS EXPONENT INDICATOR
         BNE   CD2DLM              NO,MUST BE DELIMITER
         AR    RA,RE               BUMP SCAN PTR BEYOND E
         MVI   CD2SIGNE,X'2C'      MAKE EXPONENT SIGN + (MDR INST)
         CLI   0(RA),C'0'          IS NUMBER THERE
         BNL   CD2EVAL             IF DECIMAL,GO EVALUATE
         CLI   0(RA),C'+'          WAS THERE A + SIGN
         BE    CD2INCB             YES,JUST BUMP SCAN PTR
         CLI   0(RA),C'-'          WAS THERE - SIGN
         BNE   CD2INVCN            NO,ERROR
         MVI   CD2SIGNE,X'2D'      -EXPONENT, MAKE INST A DDR
CD2INCB  AR    RA,RE               BUMP SCAN PTR BY 1
         SPACE 1
*              HAVE EXPONENT VALUE CONVERTED. ADJUST FRACTION BY IT.
CD2EVAL  $CALL SDDTRM
         LTR   RB,RB               WAS IT OK
         BNZ   CD2INVCN            NO,ERROR
         LTR   RC,RC               WAS EXPONENT 0
         BZ    CD2CON              YES,DON'T DO ANYTHING
*              THERE SHOULD BE SOME MAGNITUDE CHECKING HERE
CD2SIGNE MDR   $CHN+F0,F2          **MODIFIED** MUL OR DIV,DEP ON SIGN
         BCT   RC,CD2SIGNE         LOOP FOR REQUIRED AMOUNT
         SPACE 1
*              MAKE ENDING CHECKS, THEN RETURN TO CALLER.
CD2DLM   CLI   0(RA),C''''         WAS THIS ' DELIMITER
         BE    CD2CON              YES,OK
         CLI   0(RA),C','          WAS IT , DELIM
         BNE   CD2INVCN            INVALID DELIMITER
CD2CON   BC    $CHN,CD2INVCN       BRANCH OUT IF NO FRACTIO ANYWHERE
CD2SIGN  LPDR  $CHN+F0,F0          **MODIFIED** GET RIGHT SIGN
         STD   F0,CD2CONB          SAVE THIS VALUE
         LA    RC,CD2CONB          POINT TO THIS @
         SR    RB,RB               SHOW OK
CD2RET   $RETURN RGS=(R14-R15)
CD2INVCN LA    RB,$ERINVCN         SHOW ERROR
         B     CD2RET              RETURN
CD2CONB  DS    D                   SPACE FOR SAVING CONSTANT
         DROP  RAT,R13             KILL USINGS
.CD2MINI ANOP
         TITLE '*** CFHCNS - FULLWORD-HALFWORD FIXED CONSTANTS ***'
**--> CSECT: CFHCNS   1-2 PROCESS FULLWORD-HALFWORD CONSTANTS . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFHCNS   CSECT
         $DBG  A0,SNAP
         USING AVWXTABL,RAT        NOTE MAIN USING
         ENTRY CFHCN1,CFHCN2
         SPACE 2
**--> ENTRY: CFHCN1   1   SCAN CONST, DO NOT ASSEMBLE . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFHCN1   $SAVE RGS=(R1-R2),SA=NO
         SPACE 1
*              INITIALIZE, CHECK FOR LEADING SIGN.  **NOTE** THIS     *
*        ROUTINE DOES NOT PERMIT DECIMAL POINTS INSIDE CONSTANTS.     *
         SR    R1,R1               CLEAR FOR ADDRESS INSERT
         CLI   0(RA),C'+'          PLUS SIGN CHECK
         BE    CFH1INC             GO BUMP SCAN POINTER IF SO
         CLI   0(RA),C'-'          MUST BE MINUS SIGN
         BNE   CF1TRT              SKIP IF NOT ASIGN
CFH1INC  LA    RA,1(RA)            INCR SCAN POINTER PAST + OR -
         SPACE 1
*              SCAN DECIMAL DIGITS, MAKE SURE THERE'S AT LEAST 1.
CF1TRT   TRT   0(11,RA),AWTDECT    SCAN FOR DELIMITER
         BZ    CFH1BIG             BRANCH IF TOO BIG
         SR    R1,RA               GET NUMBER OF CHARS
         BZ    CFH1INVC            NO DIGITS, SO INVLAID, LIKE F''
         SPACE 1
         AR    RA,R1               GET POINTER BACK
         SR    RB,RB               CLEAR TO SHOW OK
CFH1RET  $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
CFH1INVC LA    RB,$ERINVCN         INVALID CONSTANT ERROR
         B     CFH1RET             GO RETUN
CFH1BIG  EQU   CFH1INVC            TOO BIG, USE JUST INVALID MESSAGE
         EJECT
**--> ENTRY: CFHCN2   2   ASSEMBLE F OR H CONST . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       **NOTE** - THIS ROUTINE WILL ASSEMBLE VALUES INTO F OR H     *
*.       CONSTANTS OF LENGTH 1-8, BUT THE VALUE OF ANY CONSTANT MUST  *
*.       BE OF SIZE TO FIT INTO 1 FULLWORD, I.E. THE OTHER FULLWORD   *
*.       MUST EITHER BE ALL 0'S OR ALL 1'S (BINARY).  .               *
*.       **NOTE** IT IS POSSIBLE FOR THIS ROUTINE TO CAUSE A FIXED PT *
*.       OVERFLOW, WHICH WILL CAUGHT AND LAGGED BY SPIE MONITOR IN    *
*.       MAIN PROGRAM MPCON0.                                         *
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CFHCN2   $SAVE RGS=(R1-R2),SA=NO
         SPACE 1
*              INITIALIZE.  CHECK SIGN, KAE CFH2SIG EITHR LR OR LCR.
         SR    R1,R1               CLEAR FOR ADDRESS INSERTION
         MVI   CFH2SIG+1,X'FF'     ASSUME + SIGN WILL OCCUR
         CLI   0(RA),C'0'          IS THERE NO SIGN
         BNL   CFH2TRT             NO SIGN-BRANCH
         CLI   0(RA),C'+'          PLUS SIGN CHECK
         BE    CFH2INC             BRANCH IF SO
         MVI   CFH2SIG+1,X'FD'     SET TO SHOW MINUS
CFH2INC  LA    RA,1(RA)            BUMP PAST SIGN
         SPACE 1
*              SCAN CONSTANT, CONVERT TO BIANRY FORM.
CFH2TRT  TRT   0(11,RA),AWTDECT    GO FOR DELIMITER
         SR    R1,RA               GET DIFFERENCE=#OF DIGITS
         BCTR  R1,0                DECREMENT FOR LENGTH-1
         EX    R1,CFH2PACK         PACK THE NUMBER
CFH2SIG  NI    AVDWORK1+7,$        CHANGE SIGN TO SHOW + (F) OR - (D)
         CVB   RD,AVDWORK1         CONVERT THE VALUE
         SPACE 1
*              GIVE CONSTANT RIGHT SIGN, STORE IT, POINT TO IT.
         SRDA  RD,32               MAKE CONSTANT A DOUBLE WORD-
         STM   RD,RE,AVCONBLD      STORE IN BUILDING AREA
         LCR   RB,RB               MAKE LENGTH-1 NEGATIVE-GET OFFSET
         LA    RC,AVCONBLD+7(RB)   GET START ADDR OF DESIRED CONST
         SR    RB,RB               SHOW THE CONSTANT IS OK
         LA    RA,1(R1,RA)         GET SCAN POINTER TO ENDING ' ,
CFH2RET  $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
CFH2PACK PACK  AVDWORK1,0(0,RA)    PACK DECIMAL STRING
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** CNDTL2 - CONSTANT PROCESSOR CONTROL - PASS 2 ***'
**--> CSECT: CNDTL2   2   CONSTANT PROCESSOR CONTROL - PASS 2 . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RB = NUMBER OF CONSTANT CONTROL BLOCKS TO BE PROCESSED            .
*.  RC = ADDRESS OF FIRST OR ONLY CNCBLOCK TO BE DONE                 .
*.       CALLS CACON2,CBCON2,CCCON2,CDECN2,CFHCN2,CPCON2,CVCON2,CXCON2.
*.       CALLS CZCON2,ERRTAG,OUTPT2,UTPUT2                            .
*.       USES DSECTS: AVWXTABL,CNCBLOCK                               .
*.       USES MACROS: $ALIGR,$CALL,$GLOC,$GTAD,$RETURN,$SAVE          .
*.       USES MACROS: $SCPT,$SLOC                                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CNDTL2   CSECT
         $DBG  A0,SNAP
* * * * * REGISTER ALLOCATION AND USAGE FOR CNDTL2  * * * * * * * * * *
*   R0 = # CONSTANTS REMAINING TO BE DONE IN CURRENT CNCBLOCK(CNCNUM) *
*   R1 = LENGTH-1 OF CONSTANT(S) IN INDIVIDUAL OPERAND, (FROM CNCLEN) *
*              ALSO USED AS BYTE REGISTER, 3 HI-ORD* BYTES=0          *
*   R2 = DUPLICATION FACTOR FOR CONSTANT OPERAND ( FROM CNCDUP)       *
*   RW = @ CURRENT CNCBLOCK BEING PROCESSED.                          *
*   RX = @ AREA FOR BUILDING UP MULTIPLE CONSTANTS (AVCONBL2)         *
*   RY = @ SPECIFIC CONSTANT PASS 2 ROUTINE                           *
*   RZ = CURRENT TOTAL LENGTH OF ASSEMBLED CONSTANTS (MULTIPLE OPRNDS)*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AVWXTABL,RAT
         $SAVE RGS=(R14-R6),BR=R13,SA=CNDTSAVE
         SPACE 1
*              INITIALIZEREGISTERS, COUNTERS.  ENTER CODE LOOP.
         SR    R0,R0               CLEAR FOR INSERIONS
         SR    R1,R1               CLEAR FOR INSERTIONS
         LR    RW,RC               MOVE @ 1ST OR ONLY CNCBLOCK OVER
         USING CNCBLOCK,RW         NOTE POINTER
         MVC   CNDOCNT,AWHM1       =H'-1' = 6-1 OF BYTES FOR PRINTING
         B     CNDAA1              ENTR RIGHT SPOT TO BEGIN
         SPACE 1
*              CNDA IS ENTERED 1 TIME FOR EACH OPERAND AFTER FIRST    *
CNDA     LH    R15,CNCTOT          GET TOTAL LENGTH OF LAST CONSTANT
         A     R15,AVLOCNTR        ADD LOCATION COUNTER
         LA    RW,CNC$LEN(RW)      INCREMENT CNCBLOCK POINTER TO NEXT
         TM    CNCTYP,$CNALN       DOES NEW OPERAND REQUIRE ALIGNMENT
         BZ    CNDNOLN             NO,SKIP ALIGNING THE LOCCNTR
         IC    R1,CNCLEN           GET L-1 OF CONST(NOTE R1 BYTE REG)
         $ALIGR R15,(R1)           ALIGN LOCATION COUNTER
CNDNOLN  $SLOC R15                 RESET LOCATION COUNTER
         SPACE 1
*              CNDAA1 IS ENTERED 1 TIME FOR EACH CNCBLOCK PROCESSED.  *
CNDAA1   STH   RB,CND#CNCS         SAVE CURRENT # CNCBLOCKS TO BE DONE
CNDAA    $SCPT RA,CNCSCAN          CONVERT OFFSET TO ACTUAL @ PTR
         IC    R1,CNCTYP           GET TYPE BYTE
         N     R1,AWF15            REMOVE LEADING BITS
         IC    R1,AWCONADS(R1)     GET OFFSET TO PASS 1 CONSTANT SUBR
         $GTAD RY,C$BASE+4(R1)     GET @ PASS 2 CONSTANT ROUTINE
         IC    R0,CNCNUM           GET # OF CONSTANTS IN THIS OPERAND
         IC    R1,CNCLEN           GET THE LENGTH-1 OF EACH CONSTANT
         LA    RX,AVCONCAT         SET UP @ OF BUILDING AREA
         SR    RZ,RZ               CLEAR THE TOTAL LENGTH BUILT UP
         EJECT
*              CNDBB ENTERED ONCE FOR EACH CONSTANT IN EACH OPERAND   *
CNDBB    LR    RB,R1               MOVE LENGTH-1 OVER FOR CALL TO ROUTI
         LR    REP,RY              MOVE @ ROUTINE OVER
         BALR  RET,REP             CALL THE ROUTINE
         TM    CNCTYP,$CNERR       SHOULD WE TEST RB FOR ERRORS
         BZ    CNDNERR             SKIP IF NO TEST NEEDED
         LTR   RB,RB               WAS THERE AN ERROR
         BZ    CNDNERR             SKIP IF NO ERROR
         SPACE 1
*              ERROR FOUND IN PASS 2. FLAG IT,PRINT STMT, AND QUIT.   *
         $CALL ERRTAG              HAVE ERROR FLAGGED
         B     CNDRETA             RETURN TO CALLER
         SPACE 1
CNDNERR  EQU   *
         LA    RE,0(RX,RZ)         GET @ WHERE NEXT CODE TO GO
         LA    RZ,1(R1,RZ)         INCREM TOTAL LENGTH BY NEW AMOUNT
         CLI   CNCNUM,1            WAS THERE ONLY 1 CONSTANT(LIKELY)
         BE    CNDPRNT1            SKIP TO SIMPLE CASE IF SO
         STC   R1,*+5              STORE L-1 INTO NEXT INST
         MVC   0($CHN,RE),0(RC)    MOVE CODE OVER
         LA    RA,1(RA)            BUMP THE SCAN POINTER TO NEXT OPERAN
         BCT   R0,CNDBB            GO BACK FOR NEXT CONSTANT IN OPERAND
         SPACE 1
*              FALL THRU AFTER ASSEMBLING 2 OR MORE CONSTS IN 1 OPRND.*
         LR    RC,RX               MOVE @ ASSEMBLED CONSTANT OVER
CNDPRNT1 BCTR  RZ,0                DECREMENT TOTAL LENGTH TO L-1
         LH    R2,CNCDUP           GET DUPLICATION FACTOR
         LTR   R2,R2               TEST (MAX VAL FOR DUPL=X'7FFF')
         BZ    CNDLOOP2            SKIP REST IF ZERO DUPLICATION FACTOR
         SPACE 1
*              ACCUMULATE ENOUGH BYTES FOR PRINTING, IF NOT ALREADY.  *
         LH    RA,CNDOCNT          GET LENGTH-1 CURÞENTLY READY
         LA    R15,6               FOR COMPARISON A(D LIMIT VALUE
         CR    RA,R15              IS THERE ENOUGH  ALREADY
         BH    CNDUTPUT            BRANCH OUT IF ALREADY ENOUGH
         SPACE 1
         LA    R14,1               FOR BXLE INCREME(T
         SR    RD,RD               INIT FOR INDEX I(TO ASSEMBLED CONT
         LR    RE,R2               DUPLICATE DUPLIC"ATION FACTOR,>0
         B     CNDLC               ENTER LOOP APPRO&RIATELY
         SPACE 1
*              LOOP TO ACCUMULATE PRINTING CODE, 1 BYTE AT TIME.
CNDLA    AR    RD,R14              INCREMENT WITHIN CONSTANT PTR TO NXT
         CR    RD,RZ               HAVE WE REACHED END OF CONST
         BNH   CNDLC               NO,KEEP GOING
         SR    RD,RD               END OF CONST,CLEAR TO BEGIN AGAIN
         SR    RE,R14              DECREMENT TEMPORARY DUPLICATION FAC
         BNP   CNDLE               QUIT IF RUN OUT OF DUPLFAC
         SPACE 1
CNDLC    IC    RB,0(RD,RC)         GET 1 BYTE OF CONSTANT OPERAND
         STC   RB,CNDOCOD+1(RA)    STORE FOR PRINTING
         BXLE  RA,R14,CNDLA        LOOP UNTIL HAVE 8 BYTES OR RUN OUT
         SPACE 1
CNDLE    STH   RA,CNDOCNT          STORE BACK THE UPDATED PR COUNT
         EJECT
*              CALL UTPUT2 TO DUPLICATE AND LOAD OBJECT CODE          *
CNDUTPUT EQU   *
         LR    RE,R2               MOVE DUPLICATION FACTOR OVER
         $GLOC RA                  GET LOCATION COUNTER FOR CODE
         LR    RD,RZ               TOTAL L-1 OF CODE(NOT CNTING DUPL)
         $CALL UTPUT2              HAVE OBJECT CODE LOADED,DUPLICATED
         SPACE 1
*              LOOP BACK FOR NEXT OPERAND, IF >1 WAS USED.
CNDLOOP2 LH    RB,CND#CNCS         GET # CNCBLOCKS LEFT TO DO
         BCT   RB,CNDA             GET NEXT OPERAND (UNLIKELY)
         SPACE 1
CNDRETA  EQU   *                   INSERT $DALLOCH CODE LATER
         LA    RB,$OUCONS          SHOW WE WANT LOCATION COUNTER
         LA    RC,CNDOCOD          GET @ OF CODE TO BE PRINTED
         LH    RD,CNDOCNT          GET LENGTH-1 OF CONST TO PRINT
         $CALL OUTPT2              HAVE STMT PRINTED
CNDRET   $RETURN RGS=(R14-R6)
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
CND#CNCS DS    H                   # CNCBLOCKS TO BE PROCESSED (U=1)
CNDOCNT  DS    H                   FOR LENGTH-1 OF CODE TO PRINT
CNDOCOD  DS    D                   AREA TO BUILD UP PRINTED CODE
         DROP  RAT,R13,RW          KILL USINGS
         TITLE '*** CODTL1 - SCAN DUPL FAC,TYPE,LENGTH,CONST-PASS1 ***'
**--> CSECT: CODTL1   1   SCAN DUPFAC,TYPE,LENGTH-CALL C ROUTINES . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO DUPLICATION FACTOR OR CONSTANT TYPE          .
*.  RB = 0    CONSTANT IS IN A DEFINE STORAGE STMT                    .
*.  RB = 4     CONSTANT IS IN A DC STATEMENT                          .
*.  RB = 8     CONSTANT IS A LITERAL - (I.E. DUPLFAC ›= 0, DECIMALS)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER FOLLOWING CONSTANT                 .
*.  RB = 0    LEGAL SPECIFICATION OF CONSTANT                         .
*.  RB = NONZERO VALUE - ERROR CODE - ILLEGAL                         .
*.  RC = ADDRESS OF A CONSTANT CONTROL BLOCK                          .
*.  RE = TOTAL LENGTH OF OPERAND,INCLUDING MULTIPLE OPERANDS,IF ANY   .
*.       CALLS CACON1,CBCON1,CCCON1,CDECN1,CFHCN1,CPCON1,CVCON1,CXCON1.
*.       CALLS CZCON1,EVALUT,SDDTRM                                   .
*.       USES DSECTS: AVWXTABL,CONBLK                                 .
*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE,$SCOF,CONG
*        NOTE RESTRICTIONS - DUPLICATION FACTOR AND TOTAL LENGTH MUST *
*        BOTH BE ABLE TO FIT IN HALFWORD EACH. LENGTH MAY BE GREATER  *
*        THAN 256 FOR A DS,BUT LENGTH ATTRIBUTE WILL NOT BE CORRECT   *
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
CODTL1   CSECT
         $DBG  A0,SNAP
* * * * * REGISTER ALLOCATION FOR CODTL1  * * * * * * * * * * * * * * *
*   R0 = 0 ==> PROCESSING DS,  = 4 ==> PROCESSING DC STATEMENT.       *
*      = 8 ==> LITERAL CONSTANT, I.E. REQUIRE DECIMAL MODIFIERS.      *
*   R1 = 1         USED TO BUMP SCAN POINTER IN BXH'S,ETC.            *
*   R2 = ADDRESS OF CONSTANT BLOCK ENTRY (CONBLK),AFTER TYPE FOUND    *
*   RW = LENGTH-1 OF OPERAND BEING PROCESSED.IMPLIED OR SPECIFIED.    *
*   RX = NUMBER OF CONSTANTS IN THE OPERAND                           *
*   RY = DUPLICATION FACTOR OF THE OPERAND                            *
*   RZ   USED AS LINK OR WORK REGISTER                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN USING
         $SAVE RGS=(R14-R6),BR=R13,SA=COSAVE
         SPACE 1
*              INITIALIZATION OF REGISTERS, CONSTANT BLOCK, FLAGS.
         LR    R0,RB               SAVE R0=0==>DS,R0=4==>DC
         SR    RB,RB               SHOW NO ERRORS AT BEGINNING
         LA    R1,1                HANDY CONSTANT
         LR    RY,R1               SET DEFAULT DUPLICATION FACTOR=1
         LM    R2,R4,AWZEROS       ZERO POINTER REG,LENGTH,#OF CONSTS
         STM   R2,R3,COBLK         ZERO OUT BLOCK
         MVI   CODXLEN+1,0         INITIALIZE TO NO EXPLICIT LENGTH
         SPACE 1
*              BEGIN PROCESSING OF DUPLICATION FACTOR, IF PRESENT.
         BAL   R14,CODNUM          GO GET DUPLICATION FACTOR
         B     CODLOOK             NO DUPLICATION FACTOR,SKIP
         SPACE 1
*              DUPLICATION FACTOR EXPLICIT-CHECK IT,MOVE TO RY.       *
         C     RC,AWFX7FFF         =XL4'7FFF' COMPARE TO MAX SIZE LEGAL
         BH    CODEDUPL            BRANCH IF TOO BIG
         LTR   RY,RC               MOVE FACTOR OVER AND TEST
         BNZ   CODLOOK             BRANCH IF DEFINITELY LEGAL
         C     R0,AWF7             0 DUPLICATION FACTOR, IS IT LITERL
         BNL   CODEDUPL            BRANCH - 0 DUPLFAC IN LITERAL -ERROR
         SPACE 1
*              CHECK TYPE FOR LEGALITY. GET ADDR OF CONBLK ENTRY.     *
CODLOOK  CLI   0(RA),C'A'          MAKE SURE LEGITAMATE
         BL    CODERTYP            NO,IT IS AN ERROR
         IC    R2,0(RA)            GET THE TYPE CODE
         IC    R2,CODINXO(R2)      GET OFFSET INTO CONTABL ENTRIES
         LTR   R2,R2               IS THE TYPE LEGAL
         BZ    CODERTYP            NO,ERROR
         SPACE 1
         LA    R2,CONTAB1(R2)      GET ACTUAL ADDRESS OF RIGHT ENTRY
         USING CONBLK,R2           NOTE DUMMY SECT FOR CONTABL ENTRY
         MVC   COTYP,CONTYP        MOVE TYPE+FLAGS OVER
         AR    RA,R1               INCREMENT SCAN POINT BEYOND TYPE
         SPACE 1
*              CHECK FOR EXPLICIT LENGTH SPECIFICATION,EVAL IT IF SO. *
         CLI   0(RA),C'L'          IS THERE A LENGTH SPECIFICATION
         BNE   CODEFAL             NO,USE DEFAULT LENGTH
         EJECT
*              LENGTH EXPLICITLY SUPPLIED - PROCESS IT,NOTE NO ALIGN. *
         AR    RA,R1               INCREMENT SCAN POINTER TO BEYOND L
         BAL   R14,CODNUM          GO GET LENGTH
         B     CODINVD             INVALID DELIMITER OR SOMETHING
CODEDL   LR    RW,RC               MOVE LENGTH OVER
         SR    RW,R1               DECREMENT TO LENGTH-1
         NI    COTYP,255-$CNALN    WIPE OUT ALIGNMENT FLAG,IF ANY
         MVI   CODXLEN+1,X'F0'     MAKE NOP A BRANCH-EXPLICIT LENGTH
         SPACE 1
*              CHECK EXPLICIT LENGTH FOR BEEING IN RIGHT RANGE.
         SR    RD,RD               CLEAR REG FOR INSERT
         IC    RD,CONLLW           GET LOWEST LIMIT VALUE
         CR    RW,RD               IS LENGTH TOO LOW
         BL    CODLBAD             ILLEGAL LENGTH
         IC    RD,CONLHI           GET HIGH LIMIT ON LENGTH-1
         CR    RW,RD               COMPARE TO SEE IF HIGH
         BNH   CODCONGO            THE LENGTH IS IN RANGE
         LTR   R0,R0               IS THIS IN A DS
         BNZ   CODEBIG             NO,IT IS DC, THEREFORE ILLEGAL
         SPACE 1
*              NOTE C & X DC'S MAY EXCEED NORMAL 256 LENGTH LIMIT.
         CLI   CONTYP,$CNVLN+$CNC  IS IT C TYPE
         BE    CODCONGO            YES,SO IT IS OK
         CLI   CONTYP,$CNVLN+$CNX  IS IT HEX CONST
         BE    CODCONGO            YES,SO ITS OK
         B     CODEBIG             NO,IT IS TOO LARGE,SINCE NOT X OR C
         SPACE 1
CODEFAL  IC    RW,CONLEN           GET DEFALUT LENGTH-1
*              HAVE GOTTEN DUPFAC-TYPE-LENGTH,NOW SCAN FOR CONSTANT.  *
CODCONGO CLI   0(RA),C' '          CHECK,IS THIS THE END
         BE    *+12                SKIP NEXT 2 INSTS==> NO OPERAND
         CLI   0(RA),C','          CHECK FOR , AFTER LENGTH
         BNE   CODOPR              NO,THERE'S STILL MORE
         LTR   R0,R0               IF FIELD OMITTED,MUST BE DS
         BNZ   CODEOMOP            OMITTED OPERAND IN DC==>ERROR
         BXLE  RX,R1,CODFIN        SET # OEPRANDS = 1 AND BRANCH
         SPACE 1
*              GET ADDRESS OF APPROPRIATE PASS 1 CONSTANT SUB&CALL IT *
CODOPR   CLC   0(1,RA),CONLD       IS THE LEFT DELIMITER OK
         BNE   CODINVD             NO IT ISNT-BRANCH TO ERROR
         AR    RA,R1               BUMP SCAN POINTER TO 1ST CHAR OF CON
         IC    RD,CONTYP           GET TYPE VALUE
         N     RD,AWFXF            =XL4'F' WIPE OUT FLAG BITS FROM NIBL
         IC    RD,AWCONADS(RD)     GET OFFSET TO ADDR OF TYPE
         $GTAD R0,C$BASE(RD)       GET @ PASS 1 ROUTINE - C#CON1
         $SCOF R15,RA,COSCAN       GET THE OFFSET AND SAVE IT
         EJECT
*              CONSTANT TYPE KNOWN. CALL ROUTINE TO PROCESS IT.       *
CODCALL  LR    REP,R0              MOVE ADDRESS OV ROUTIN OVER
         BALR  RET,REP             CALL THE ROUTINE
         LTR   RB,RB               WAS THERE AN ERROR
         BNZ   CODRETA             YES,RETURN WITH THE RROR
         AR    RX,R1               INCREMENT THE # OF OPERANDS
         CLC   0(1,RA),CONRD       IS DELIM THE RIGHT DELIM
         BE    CODCONA             YES,THIS IS END OF OPERAND
*              THE FOLLOWING TAKES CARE OF MULTIPLE OPERANDS WHERE OK *
         CLI   0(RA),C','          IS DELIMITER RIGHT
         BNE   CODINVD             NO,IT IS BAD DELIMITER
         TM    COTYP,$CNMUL        ARE MULTIPLE DELIMS ALLOWED
         BZ    CODINVD             SKIP IF THEY AREN'T ERROR
         BXH   RA,R1,CODCALL       BUMP SCAN POINTER AND CALL ROUTINE
         SPACE 1
*              HAVE PROCESSED WHOLE OPERAND. CHECK FOR OVERRIDE LENGTH*
CODCONA  AR    RA,R1               INCREMENT SCAN POINTER
CODXLEN  BC    $CHN,CODFIN         BRANCH IF LENGTH EXPLICIT,NOP IFNOT
         TM    COTYP,$CNVLN        WAS LENGTH VARIABLE,ALLOWING OVERD
         BZ    CODFIN              NO,LEAVE THE LENGTH ALONE
         LR    RW,RC               MOVE THE RETURNED LENGTH OVER
         SR    RW,R1               DECREMENT BY 1 TO GET CONSISTENT
         SPACE 1
*              STORE FLAGS INTO COBLK. COMPUTE TOTAL LENGTH INTO RE   *
CODFIN   STC   RX,CONUM            STORE NUMBER OF OPERANDS
         STC   RW,COLEN            SAVE THE LENGTH-1 OF OPERAND
         LTR   RE,RY               MOVE OVER AND TEST DUPL FACTOR
         BZ    CODRETA             YES,0 DUP FACTOR-0 EVERYTHING
         STH   RY,CODUP            STORE A NONZERO DUPLICATION FACTOR
         BAL   R14,*+6             SKIP 1ST AR AND GO TO BCTR
         AR    RE,RY               ADD DUPLFAC TO SLEF
         BCTR  RX,R14              LOOP ON NUMBER OF CONSTANTS IN OPRND
*              DUPLICATION FACTOR * NUMBER OF OPERANDS IS IN RE       *
         CR    RE,R1               IS DUP FAC*#OPERANDS =1
         BNE   CODMULT             IF NOT,GIVE UP AND MULTIPLY
         LA    RE,1(RW)            MOVE THE LENGTH OVER&ADD 1
         B     CODSTOR             HAVE LENGTH SAVED AND QUIT
CODMULT  AR    RW,R1               INCREMENT LENGTH-1 TO LENGTH
         MR    RD,RW               MULTIPLY TO GET TOTL LENGTH
CODSTOR  STH   RE,COTOT            SAVE THE TOTAL LENGTH
         CL    RE,AWFX7FFF         MAKE SURE WHOLE LENGTH NOT TOO BIG
         BH    CODEBIG             TOTAL LENGTH IS TOO BIG
*              POINT AT THE COBLK AND RETURN                          *
CODRETA  LA    RC,COBLK            SHOW ADDRESS OF OUR CODE BLOCK
CODRET   $RETURN RGS=(R14-R6)
         EJECT
* * * * * CODNUM - CALLED TO EVALUATE DUPLICATION FACTOR OR LENGTH -  *
*        RETURNS 0(R14) IF EXPRESSION OMITTED. RETURNS TO 4(R14) IF OK*
*        RC HAS VALUE OF EXPRESSION                                   *
CODNUM   LA    RZ,4(R14)           SET UP GOOD RETURN FOR SECTIONS
         CLI   0(RA),C'0'          DO WE HAVE DECIMAL NUMBER
         BNL   CODECAL             YES,DECIMAL NUMBER,GO CONVERT
         CLI   0(RA),C'('          EITHER EXPRESSION,OR OMITTED
         BCR   NE,R14              RETURN IF IT WAS OMITTED
         SPACE 1
*              IF FALLS THRU==>EXPRESSION,ENCLOSED IN PARENS. EVALUATE*
         C     R0,AWF7             ARE WE IN LITERAL
         BH    CODESYNT            YES, ILLEGAL DUPLFAC OR LENGTH
         AR    RA,R1               BUMP SCAN POINTER PAST 1ST (
         $CALL EVALUT
         LTR   RB,RB               CHECK FOR ERROR
         BNZ   CODRET              RETURN WITH ERROR CODE IF SO
         LTR   RD,RD               WAS IT RELOCATABLE
         BNZ   CODNEABS            RELOCATABLE RELOCATION FACTOR,ERROR
         CLI   0(RA),C')'          SEE IF THIS WAS END
         BNE   CODINVD             INVALID DELIMITER IF NOT
         BXH   RA,R1,0(RZ)         INCREMENT SCAN POINTER PAST ) AND BR
         SPACE 1
*              DUPLFAC OR LENGTH WAS DECIMAL NUMBER. GET ITS VALUE    *
CODECAL  $CALL SDDTRM              GET DECIMAL SELF-DEFINING TERM
         LTR   RB,RB               WAS THERE AN ERROR
         BCR   Z,RZ                RETURN IF THE NUM WAS OK
         B     CODRET              RETURN WITH ERROR CODE IN RB
         SPACE 1
* * * * * INDIVIDUAL ERROR CODE SECTIONS                              *
CODERTYP LA    RB,$ERCNTYP         UNKNOWN TYPE OF CONSTANT
         B     CODRET              RETURN SHOWING ERROR
CODEOMOP LA    RB,$ERNOOPR         MISSING OPERAND(CONSTANT)
         B     CODRET              RETURN SHOWING ERROR
CODEBIG  LA    RB,$EREXGTA         NUMBER OR EXPRESSION TOO LARGE
         B     CODRET              RETURN SHOWING ERROR
CODLBAD  LA    RB,$EREXLTA         NUMBER OR EXPRESSION TOO SMALL     P
         B     CODRET              RETURN SHOWING ERROR
CODINVD  LA    RB,$ERINVDM         INVALID DELIMITER
         B     CODRET              RETURN,SHOWING ERROR CODE
CODNEABS LA    RB,$ERNEABS         ABSOLUTE EXPRESSION REQUIRED
         B     CODRET              RETURN
CODESYNT LA    RB,$ERVSYNT         SYNTAX - ILLEGAL () IN LITERAL
         B     CODRET              RETURN
CODEDUPL LA    RB,$ERDUPLF         ILLEGAL DUPLICATION FACTOROR
         B     CODRET              RETURN
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
CODINX   DC    XL(256-C'A')'0'     CONSTANT INDEX TABLE
CODINXO  EQU   CODINX-C'A'            GET SYMBOL WITH OFFSET
CONTABL  EQU   *                   BEGINNING OF CONSTANT DESCRIPTOR TAB
CONTAB1  EQU   CONTABL-1           GET OFFSET SYMBOL SO OFFSETS NOT ZER
         CONG  A,$CNALN+$CNMUL,4,LD='(',RD=')',HI=4
         CONG  B,$CNVLN,1,HI=256,E=0
         CONG  C,$CNVLN,1,HI=256,E=0
         CONG  D,$CNALN+$CNMUL,8
         CONG  E,$CNALN+$CNMUL,4
         CONG  F,$CNALN+$CNMUL,4
         CONG  H,$CNALN+$CNMUL,2
         CONG  P,$CNVLN+$CNMUL,1,HI=16,E=0
         CONG  V,$CNALN+$CNMUL,4,LD='(',RD=')',LW=3,HI=4
         CONG  X,$CNVLN,1,HI=256,E=0
         CONG  Z,$CNVLN+$CNMUL,1,HI=16,E=0
         LTORG
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
* * * * * COBLK AREA - SET UP LIKE CNCBLOCK FOR CONSTANT CODES        *
COBLK    DS    0D                  INTERNAL CONSTANT BLOCK LIKE CNCBLK
COTYP    DS    C                   TYPE + FLAGS
COLEN    DS    C                   LENGTH-1 OF CONSTANT OPERAND
COSCAN   DS    C                   SCAN POINTER OFFSET TO START OF CONS
CONUM    DS    C                   NUMBER OF OPERANDS IN CONSTANT
CODUP    DS    H                   DUPLICATION FACTOR
COTOT    DS    H                   TOTAL LENGTH OF CONSTANT
         SPACE 1
**--> DSECT: CONBLK     CONSTANT DESCRIPTOR CODES BLOCK(CODTL1) . . . .
*.       THIS BLOCK CONTAINS DATA FOR A GIVEN CONSTANT TYPE, AND IS   .
*.       USED BY ASSEMBLER SUBR. CODTL1 IN SCANNING CONSTANTS AND     .
*.       BUILDING CNCBLOCKS DURING ASSEMBLY PASS 1.  THE DATA         .
*.       GIVEN INCLUDES A FLAG BYTE, DEFAULT LENGTH-1, LEFT AND       .
*.       RIGHT DELIMITER CHARACTERS REQUIRED FOR THE CONSTANT, AND    .
*.       MINIMUM AND MAXIMUM VALUES FOR THE LENGTH-1 OF THE CONSTANT. .
*.       THE FLAG BYTE, WITH MODIFICATIONS, BECOMES THE CNCTYPE BYTE  .
*.       OF THE CNCBLOCK CREATED FOR EACH CONSTANT OPERAND.           .
*.       LOCATION: TABLE CONTABL OF CSECT CODTL1                      .
*.       GENERATION: 1 CALL TO MACRO CONG CREATES A CONBLK ENTRY.     .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
CONBLK   DSECT
CONTYP   DS    C                   CONSTANT TYPE+ FLAGS
CONLEN   DS    C                   DEFAULT LENGTH
CONLD    DS    C                   LEFT DELIMITER
CONRD    DS    C                   RIGHT DELIMITER
CONLLW   DS    C                   LOWEST VALUE OF LENGTH-1
CONLHI   DS    C                   HIGHEST VALUE OF LENGTH-1
         DROP  RAT,R13,R2          CLEAN UP USING
         TITLE '*** CPCONS - PACKED DECIMAL CONSTANTS ***'
**--> CSECT: CPCONS   1-2 PROCESS PACKED CONSTANTS. . . . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CPCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CPCON1,CPCON2       PASS 1 AND 2 ENTRIES
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CPCON1   1   SCAN,DO NOT ASSEMBLE PACKED CONSTATNT . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CPCON1   $SAVE SA=NO
         SR    RC,RC               CLEAR FOR USE AS FLAG
         LA    RD,32               (MAX # DIGITS IN CONST) + 1 AS LIMIT
         LA    RE,1                FOR INCREMENTING AND DECREMENTING
         CLI   0(RA),C'+'          IS THERE A + SIGN NEXT
         BE    CP1LOOP             YES,BRANCH TO INCREMENT SCAN PTR
         CLI   0(RA),C'-'          IS IT - SIGN
         BNE   *+6                 SKIP BUMPING SCAN PTR IF SO
         SPACE 1
CP1LOOP  AR    RA,RE               BUMP SCAN POINTER BY 1
         CLI   0(RA),C'0'          IS NEXT CHAR A DIGIT
         BL    CP1NODIG            BRANCH IF NOT - SOME PUNCTUATION
         BCT   RD,CP1LOOP          DIGIT-DECREMENT LIMIT COUNTER,BRANCH
         B     CP1INVCN            INVALID (TOO LONG)
         SPACE 1
CP1NODIG CLI   0(RA),C'.'          WAS NON-DIGIT A PERIOD
         BNE   CP1QUOT             NO,MUST BE ENDING ' OR ,
         BXLE  RC,RE,CP1LOOP       SET RC=1, BRANCH BACK IF 1ST TIME
CP1INVCN LA    RB,$ERINVCN         2 PERIODS, OR OTHER ERROR
         B     CP1RET              GO RETURN WITH ERROR MESSAGE
         SPACE 1
CP1QUOT  CLI   0(RA),C''''         WAS ENDING MARK A QUOT
         BE    CP1DONE             YES,OK,BRANCH
         CLI   0(RA),C','          WERE MULTIPLE OPS USED
         BNE   CP1INVCN            INVALID (PROBABLY DELIMITER)
         SPACE 1
CP1DONE  SR    RB,RB               SHOW NO ERRRORS
         LA    RC,32               (MAX # DIGITS + 1) FOR SUBTRCT
         SR    RC,RD               SUBTRACT COUNTER = ACTUAL # DIGITS
         BZ    CP1INVCN            IF 0 DIGITS, QUIT - NULL CONTSNAT
         SRA   RC,1                SHIFT TO GET # OF BYTES REQUIRED
         AR    RC,RE               HAD # BYTES - 1, NOW GET # BYTES
CP1RET   $RETURN SA=NO
         EJECT
**--> ENTRY: CPCON2   1-2 SCAN AND ASSEMBLE P TYPE CONSTANT . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER ENDING SCAN                        .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       USES MACROS: $RETURN,$SAVE,$SETRT                            .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CPCON2   $SAVE RGS=(R1-R2),SA=NO
         MVC   AVCONBLD(16),AWZEROS         ZERO OUT WORK AREA
         LA    RC,AVCONBLD(RB)     @ LAST BYTE OF ASSEMBLED CONSTANT
         LA    RE,1                FOR INCREMENTING,DECREMENTING
         AR    RB,RE               RB = ACTUAL # OF BYTES DESIRED
         SR    R1,R1               CLEAR FOR INSERTION OF ADDRESS
         $SETRT ('''',1,',',1)     SET UP TABLE FOR SCANNING
         TRT   1(32,RA),AWTZTAB    SIGN+PERIOD+31 DIGS-1 = 32 MAX LEN
         $SETRT ('''',0,',',0)     RESET TABLE TO ZEROS
         MVI   CP2BRNCH+1,0        MAKE BRANCH A NOOP INITIALLY
         LA    RD,X'F0'            MASK FOR REMOVING ZONE NIBBLES
         MVI   0(RC),X'C'          INIT SIGN TO A PLUS SIGN
         CLI   0(RA),C'+'          WAS PLUS THERE
         BE    CP2LOAD             YES,SKIP
         CLI   0(RA),C'-'          WAS MINUS THERE
         BNE   CP2LOAD             NO,MUST BE DIGIT OR PERIOD
         MVI   0(RC),X'D'          PLACE DECIMAL MINUS SIGN IN CONST
CP2LOAD  LR    RA,R1               DUPLICATE @ ENDING PUNCTUATION
         SR    R1,RE               BACK POINTER UP TO LAST DIG IN CONST
         SPACE 1
CP2NUMBR CLI   0(R1),C'0'          ARE WE LOOKING AT DIGIT
         BL    CP2NODIG            NOT DIGIT-BRANCH
         IC    R2,0(R1)            GET THE DIGIT
CP2BRNCH BC    $CHN,CP2EVEN        COMMUTATOR - B(EVEN) NOOP(ODD)
         SLL   R2,4                ODD DIGIT - GET INTO LEFT NIBBLE
         STC   R2,*+5              PLACE INTO OI INSTRUCTION FOLLOWING
         OI    0(RC),$CHN          WILL OR IN 1 NIBBLE TO CONSTANT
         SR    RC,RE               BACK POINTER UP,HAVE FINISHED THIS 1
         BCT   RB,CP2FLIP          DECREMENT COUNTER,BRANCH IF MORE
         B     CP2RETA             HAVE DONE REQUIRED # - NOW RETURN
         SPACE 1
CP2EVEN  SLR   R2,RD               REMOVE THE ZONE NIBBLE FROM DIGIT
         STC   R2,0(RC)            STORE THE NUMERIC INTO CONSTNT
CP2FLIP  XI    CP2BRNCH+1,X'F0'    FLIP COMMUTATOR SWITCH/EVEN/ODD
CP2DECR  BCT   R1,CP2NUMBR         DECREM SCN PTR, BRANCH ALWAYS
         SPACE 1
CP2NODIG CLI   0(R1),C'.'          WAS NON-DGIT THE PERIOD
         BE    CP2DECR             YES,DECREM SCAN PTR AND GET NEXT
         SPACE 1
CP2RETA  LA    RC,AVCONBLD         SHOW @ OF CONSTT,WITH L-PAD ZEROS
CP2RET   $RETURN SA=NO,RGS=(R1-R2)
         DROP  RAT,REP             KILL USINGS
         TITLE '*** CVCONS - V-TYPE ADDRESS CONSTANT PROCESSING ***'
**--> CSECT: CVCONS   1-2 PROCESS V-TYPE ADCONS . . . . . . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCONS   CSECT
         $DBG  A0,SNAP
         USING AVWXTABL,RAT        NOTE MAIN USING
         ENTRY CVCON1,CVCON2
         SPACE 2
**--> ENTRY: CVCON1   1   SCAN V-TYPE CONST, NO ASSEMBLE. . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE - ILLEGAL SYMBOL ($ERINVSY)                    .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCON1   $SAVE RGS=(R1-R2),SA=NO
         SR    R1,R1               CLEAR FOR ADDRESS INSERT
         TRT   0(9,RA),AWTSYMT     SCAN FOR SYMBOL DELIMITER
         BZ    CVC1ERR             ERROR IF NOT FOUND
         CLI   0(RA),C'0'          IS 1ST CHAR LETTER
         BNL   CVC1ERR             NO-ERROR BRANCH
         CR    R1,RA               MAKE SURE NOT NULL
         BE    CVC1ERR             NULL ERROR-BRANCH
         SR    RB,RB               SHOW OK
         LR    RA,R1               MOVE SCAN POINTER OVER
CVC1RET  $RETURN RGS=(R1-R2),SA=NO
CVC1ERR LA     RB,$ERINVSY         INVALID SYMBOL
         B     CVC1RET             RETURN
         EJECT
**--> ENTRY: CVCON2   2   SCAN&ASSEMBLE VCON. . . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO FIRST CHARACTER OF VCON.                     .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0 ==> NO ERRORS, NONZERO ==> ERROR CODE                      .
*.     = NONZERO ERROR CODE ($ERUNRV  OR  $ERRELOC).                  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       CALLS SYFIND                                                 .
*.       CALLS RESYMB (ONLY IF &$REPL=2 AND EXTRN SYMBOL USED).       .
*.       USES DSECTS: AVWXTABL,SYMSECT                                .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CVCON2   $SAVE RGS=(R14-R2),BR=R13,SA=CVCOSAVE
         LR    R0,RB               SAVE LENGTH-1 OF SSEMBLY
         SR    R1,R1               CLEAR FOR ADDRESS INSERT
         TRT   0(9,RA),AWTSYMT     SCAN SYMBOL
         LR    RB,R1               MOVE SCAN POINTER TO END BACK
         SR    RB,RA               GET LENGTH OF SYMBOL
         $CALL SYFIND              LOOK UP SYMBOL
         LTR   RB,RB               WAS IT FOUND
         BNZ   CVCONUNR            UNRESOLVED REFERENCE
         SPACE 1
         USING SYMSECT,RA          NOTE USING
         AIF   (&$REPL LT 2).CVNREPL        SKIP IF NO REPL CALLS
         TM    SYFLAGS,$SYEXT      WAS IT FLAGGED EXTRN
         BZ    CVC2NOEX            NO, SO SKIP CALLING CODE
         L     R15,CVRESYMB        GET  =V(RESYMB)
         BALR  R14,R15             CALL HIM
         LTR   RB,RB               WAS NAME LEGITAMATE
         BZ    CVC2VAL             YES, RESYMB PUT VALUE INTO TABLE
         B     CVCONUNR            NO, SO EXTRN, THUS UNRESOLVED
CVRESYMB DC    V(RESYMB)           SYMBOL CHECKING MODULE
CVC2NOEX EQU   *                   BRANCH HERE IF NOT EXTRN SYMBOL
.CVNREPL ANOP
         SPACE 1
         TM    SYFLAGS,$SYDEF      IS IT DEFINED
         BZ    CVCONUNR            NO, UNDEFINED, UNRESOLVED
         TM    SYFLAGS,$SYENT+$SYCSE         IS IT EITHER CSECT OR ENTR
         BZ    CVCONUNR            NO-ERROR
*              CHECK TO SEE IF SYMBOL WAS A DSECT SYMBOL.
         TM    SYESDID,$ESDSECT    WAS IT A DSECT
         BZ    CVC2VAL             NO, OK, BRANCH
         LA    RB,$ERRELOC         SHOW ERROR NOT ALLOWED
         B     CVC2RETA            EXIT WITH ERROR
CVC2VAL  LCR   RE,R0               NEGATIVE OF LENGTH-1 FOR OFFSET
         LA    RC,SYVALUE+3(RE)    GET ACTUAL STARTIN @ OF CONSTANT
         SPACE 1
CVC2RETA LR    RA,R1               MOVE SCAN POINTER BACK
CVC2RET  $RETURN RGS=(R14-R2)
CVCONUNR LA    RB,$ERUNRV          UNRESOLVED EXTERNAL REFERENCE
         B     CVC2RETA            RETURN
         DROP  RAT,RA,R13                   REMOVE USINGS
         TITLE '*** CXCONS - SCAN AND/OR ASSEMBLE HEX CONSTANTS ***'
**--> CSECT: CXCONS   1-2 PROCESS HEXADECIMAL CONSTANTS . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CXCONS   CSECT
         $DBG  A0,SNAP
         ENTRY CXCON1,CXCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CXCON1   1   SCAN HEX CONST, DO NOT ASSEMBLE . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CXCON1   $SAVE RGS=(R1-R2),SA=NO
         SR    R1,R1               CLEAR FOR INSERTION OF ADDRESS HERE
         TRT   0(256,RA),AWTHEXT   SCAN AND CHECL CHARACTERS
         CLI   0(R1),C''''         DELIMITER MUST BE A '
         BNE   CX1ERR              IF NOT,IT IS ERROR
         LA    RC,1(R1)            GET END POINTER +1
         SR    RC,RA               GET # OF HEX DIGITS+1
         SRA   RC,1                DIVIDE BY 2 FOR NUMBER OF BYTES
         BZ    CX1ERR              NULL CONST==> ERROR BRANCH
         SR    RB,RB               CLEAR REG TO SHOW A LEGAL CONST
CX1RETA  LR    RA,R1               GET SCAN POINTER OVER
CX1RET   $RETURN RGS=(R1-R2),SA=NO
CX1ERR   LA    RB,$ERINVCN         INVALID CONST (OR ILLEGAL DELIM)
         B     CX1RETA             GO RETURN
         EJECT
**--> ENTRY: CXCON2   1-2 ASSEMBLE HEX CONSTANT . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CXCON2   $SAVE RGS=(R0-R2),SA=NO
         SR    R1,R1               CLEAR FOR TRT
         SR    R2,R2               CLEAR FOR LATER INSERTS
         STC   RB,*+5              STORE LENGTH-1 INTO MVC
         MVC   AVCONBLD($CHN),AWZEROS       ZERO, IN CASE PADDING
         L     RC,AWFM1            GET =F'-1' FOR DECREMENT
         TRT   0(256,RA),AWTHEXT   SCAN FOR ENDING '
         MVI   CX2EVOD+1,X'F0'     SET UP BRANCH FOR ODD 1ST TIME
         LA    RD,0(RC,R1)         GET @ LAST DIGIT OF CONST
         SR    RD,RA               GET NUMBER OF HEX DIGITS IN CONST
         SPACE 1
CX2HGET  IC    R2,0(RD,RA)         GET THE NEXT HEX DIGIT
CX2EVOD  BC    $CHN,CX2ODD         BRANCH IF ODD (FROM RIGHT END)
         IC    RE,AWTHEX2(R2)      GET VALUE OF THE BYTE
         SLL   RE,4                SHIFT IT OVER
         ALR   RE,R0               ADD ODD BYTE TO THE EVEN ONE
         STC   RE,AVCONBLD(RB)     STORE COMPLETED BYTE IN PLACE
         BXH   RB,RC,CX2FLIP       DECREMENT REMAIN COUNT
         B     CX2RETA             BRANCH IF EXACT OR TRUNCATION      P
         SPACE
CX2ODD   IC    R0,AWTHEX2(R2)      GET THE VALUE OF THE DIGIT
CX2FLIP  XI    CX2EVOD+1,X'F0'     SWITH B ODD, NOOP EVEN & VICE VRSA
         BXH   RD,RC,CX2HGET       DECREMENT DIGITS REAMINING,LOOP
         SPACE 1
*              FALLS THRU ==> MAY BE ODD # DIGITS,STORE LAST IF SO    *
         CLI   CX2EVOD+1,X'F0'     WAS LAST DIGIT DONE AN EVEN ONE
         BE    *+8                 YES,SO DON'T STORE ODD ONE
         STC   R0,AVCONBLD(RB)     STORE INTO POSITION
CX2RETA  LA    RC,AVCONBLD         SHOW @ CONSTANT
         LR    RA,R1               SHOW SCAN PTR TO DELIMITING '
CX2RET   $RETURN RGS=(R0-R2),SA=NO
         DROP  RAT,REP             CLEAN UP USING
         LTORG
         TITLE '*** CZCONS - ZONED DECIMAL CONSTANTS ***'
**--> CSECT: CZCONS   1-2 PROCESS ZONED CONSTS. . . . . . . . . . . . .
*.       USES DSECTS: AVWXTABL                                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CZCONS   CSECT
         $DBG A0,SNAP
         ENTRY CZCON1,CZCON2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: CZCON1   1   SCAN, BUT DO NOT ASSEMBLE . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RB = 0    CONSTANT WAS LEGAL, NO ERRORS                           .
*.  RB = NONZERO VALUE FOR ERROR CODE - INVALID CONSTANT - ($ERINVCN) .
*.  RC = NUMBER OF BYTES REQUIRED FOR CONSTANT                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CZCON1   $SAVE SA=NO
         SR    RC,RC               CLEAR FLAG FOR # OF PERIODS
         LA    RD,17               (MAX @ DIGITS) +1
         LA    RE,1                FOR INCREMENTING AND DECREMENTING
         CLI   0(RA),C'+'          IS THERE PLUS SIGN
         BE    CZ1LOOP             YES,GO BUMP SCAN PTR
         CLI   0(RA),C'-'          IS THERE MINUS
         BNE   *+6                 SKIP IF NOT
         SPACE 1
CZ1LOOP  AR    RA,RE               BUMP SCAN PTR BY 1
         CLI   0(RA),C'0'          IS NEXT CHAR A DIGIT
         BL    CZ1NODIG            BRANCH IF NO DIGIT
         BCT   RD,CZ1LOOP          DECREMENT LIMIT,BRANCH IF OK
         B     CZ1INVCN            GO FLAG (TOO MANY DIGITS)
         SPACE 1
CZ1NODIG CLI   0(RA),C'.'          WAS NONDIGIT A PERIOD
         BNE   CZ1QUOT             NO,MUST BE ' OR ,
         BXLE  RC,RE,CZ1LOOP       SET RC=1,BRANCH IF FIRST TIME
         B     CZ1INVCN            2 PERIODS - ERROR - BRANCH
         SPACE 1
CZ1QUOT  CLI   0(RA),C''''         WAS DELIMITER '
         BE    CZ1DONE             YES,QUIT
         CLI   0(RA),C','          WAS DELIMITER ,
         BNE   CZ1INVCN            INVALID CONSTANT
         SPACE 1
CZ1DONE  SR    RB,RB               SHOW NO ERROR
         LA    RC,17               (MAX @ DIGITS+1)
         SR    RC,RD               GET ACTUAL # BYTES REQUIRED
         BNZ   CZ1RET              BRANCH IF LEGAL (NONZERO) LENGTH
CZ1INVCN LA    RB,$ERINVCN         SHOW INVALID CONSTANT
CZ1RET   $RETURN SA=NO
         EJECT
**--> ENTRY: CZCON2   1-2 SCAN AND ASSEMBLE Z-TYPE CONSTANT . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHAR AFTER PREVIOUS DELIMETER)  .
*.  RB = LENGTH-1 OF 1 CONSTANT OF 1 OPERAND TO BE ASSEMBLED          .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF DELIMITER STOPPING SCAN, OR ERROR)  .
*.  RC = ADDRESS OF PROPERLY ASSEMBLED CONSTANT                       .
*.       USES MACROS: $RETURN,$SAVE,$SETRT                            .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
CZCON2   $SAVE SA=NO,RGS=(R1-R2)
         MVI   AVCONBLD,C'0'       SET UP FOR PUTTING ZEROES
         MVC   AVCONBLD+1(14),AVCONBLD      PROPAGATE DECIMAL 0'S
         LA    RC,AVCONBLD(RB)     @ LAST BYTE OF CONSTANT
         LA    RE,1                HANDY CONST FOR INCREM-DECREM
         AR    RB,RE               RB = # OF BYTES REQUIRED
         LR    RD,RC               SAVE @ LAST BYTE FOR SIGN LATER
         SR    R1,R1               CLEAR FOR @ INSERTION
         $SETRT ('''',1,',',1)     SET UP TABLE FOR SCAN
         TRT   1(17,RA),AWTZTAB    SCAN TO ENDING DELIMITER
         $SETRT ('''',0,',',0)     ZERO TABLE OUT AGAIN
         MVI   CZ2SIGN+1,255-X'CF' SET UP FOR + SIGN
         CLI   0(RA),C'+'          IS THERRE A PLUS SIGN
         BE    CZ2LOAD             YES,BRANCH
         CLI   0(RA),C'-'          IS THERE MINUS
         BNE   CZ2LOAD             NO,BRANCH
         MVI   CZ2SIGN+1,255-X'DF' SET UP FOR MINUS SIGN
CZ2LOAD  LR    RA,R1               DUPLICATE PTR TO ENDING PUNCTUATION
         SR    R1,RE               BACK UP PTR TO LAST DIGIT
         SPACE 1
CZ2NUMBR CLI   0(R1),C'0'          ARE WE LOOKING  AT DIGIT
         BL    CZ2NODIG            BRANCH IF NOT DIGIT
         MVC   0(1,RC),0(R1)       MOVE DIGIT TO CONSTANT
         SR    RC,RE               DECREMENT CONSTANT POINTER
         SR    R1,RE               DECREMENT SCAN POINTER
         BCT   RB,CZ2NUMBR         DECREMENT,BRANCH IF MORE NEEDED
         B     CZ2RETA             BRANCH TO RETURN
         SPACE 1
CZ2NODIG CLI   0(R1),C'.'          WAS THIS PERIOD
         BNE   CZ2RETA             NO,SO MUST BE ENDING ' OR , - BRANCH
         BCT   R1,CZ2NUMBR         DECREM SCAN PTR,BACK FOR NEXT DIGIT
         SPACE 1
CZ2RETA  LA    RC,AVCONBLD         SHOW @ OF ASSEMBLEE CONSTANT
CZ2SIGN  XI    0(RD),$CHN          CREAT RIGHT SIGN IN ZONE OF LAST BYT
CZ2RET   $RETURN SA=NO,RGS=(R1-R2)
         DROP  RAT,REP             KILL USINGS
         TITLE '*** ERRORS - ERROR FLAGGING AND POINTER SETUP ***'
**--> CSECT: ERRORS   1-2 ERROR FLAGGING ROUTINES . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO CAUSE OF ERROR                               .
*.  RB = ERROR CODE                                                   .
*.       EXIT CONDITIONS                                              .
*.  RA,RB ARE UNCHANGED BY ERRTAG OR ERRLAB                           .
*.       USES DSECTS: AVWXTABL,RSBLOCK                                .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ERRORS   CSECT
         $DBG  80,SNAP             NOTE WE WANT TO SEE ALL ERRS
         ENTRY ERRTAG,ERRLAB
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: ERRTAG       FLAG ERROR AT SCAN POINTER POSITION . . . . .
*.       ENTRY CONDITIONS-EXIT CONDITIONS - SEE CSECT ERRORS          .
*.       USES MACROS: $RETURN,$SAVE,$SCOF                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ERRTAG   $SAVE SA=NO
         L     RE,AVRSBPT          GET ADDR OV RECORD SOURCE BLOCK
         USING RSBLOCK,RE          NOTE USING
         TM    RSBFLAG,$REBX       DOES A RECORD ERROR BLOCK EXIST
         BO    ERREBEX             REB ALREADY EXISTS
         OI    RSBFLAG,$REBX       FLAG==>REB EXISTS,THERE ARE ERROR(S)
         DROP  RE                  NO LONGET USING
         MVI   AVREBLN,0           INITIALIZE TO LENGTH-1 OF 0
ERREBEX  CLI   AVREBLN,$ERREBMX*L'AVREBES    CHECK IF MORE ROOM
         BNL   ERRTRET             NO MORE ROOM-RETURN
         SR    RD,RD               CLEAR FOR INSERT TO FOLLOW
         IC    RD,AVREBLN          GET THE CURRENT LENGTH-1 OF REB
         $SCOF RE,RA,AVREBSCN(RD)
         STC   RB,AVREBERR(RD)     PLACE ERROR CODE IN ALSO
         LA    RD,L'AVREBES(RD)    INCREMENT COUNTER
         STC   RD,AVREBLN          PLACE NEW VALUE INTO COUNTER AREA
         $DBG  ,NO                 DON'T NEED TO SEE GOING OUT
ERRTRET  $RETURN SA=NO
         SPACE 2
**--> ENTRY: ERRLAB       FLAG ERROR FOR A LABEL. . . . . . . . . . . .
*.       ENTRY CONDITIONS-EXIT CONDITIONS - SEE CSECT ERRORS          .
*.       CALLS ERRTAG                                                 .
*.       USES MACROS: $CALL,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ERRLAB   $SAVE RGS=(R14-R0),SA=NO
         LR    R0,RA               SAVE THE REAL SCAN POINTER
         L     RE,AVRSBPT          GET POINTER TO RECORD SOURCE BLOCK
         USING RSBLOCK,RE          NOTE THE USING
         LA    RA,RSBSOURC         MAKE A FAKE POINTER TO LABEL
         DROP  RE                  NOTE NO LONGER USING
         $CALL ERRTAG              CALL FLAGGING SECTION
         USING ERRTAG,REP          NOTE CHANGED USING
         LR    RA,R0               RETURN REAL SCAN POINTER
ERRLRET  $RETURN RGS=(R14-R0),SA=NO
         DROP  RAT,REP             CLEAN UP USING
         TITLE  '*** ESDOPR - EXTERNAL SYMBOL DICTIONARY ***'
**--> CSECT: ESDOPRS  1-2 EXTERNAL SYMBOL DICTIONARY&ESDID OPERATIONS .
*.       THIS MODULE HANDLES ALL FLAGGING AND CHECKING OF SECTION     .
*.       AND EXTERNAL ATTRIBUTES, INCLUDING FLAGGING SYMBOL TABLE     .
*.       ENTRIES AND MANIPULATING LOCATION COUNTERS AND SECTION IDS.  .
*.       USES DSECTS: AVWXTABL,SYSMSECT                               .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESDOPR   CSECT
         $DBG  90,*
         ENTRY ESINT1,ESCSEC,ESENX1,ESENX2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 1
**--> ENTRY: ESINT1       INITIALIZATION . PASS 1 . . . . . . . . . . .
*.       THIS SECTION FOR COMPLETENESS, FUTURE USE. DOES NOTHING 8/70..
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESINT1   $SAVE SA=NO
*        ***** FUTURE USE - DOES NOTHING AT PRESENT TIME.**************
ESINRET  $RETURN SA=NO
         SPACE 1
**--> ENTRY: ESCSEC       DECLARE A CONTROL SECTION OR DUMMY SECTION. .
*.       ENTRY CONDITIONS                                             .
*.  RB = 0 ==> CSECT                                                  .
*.     = 2 ==> DSECT                                                  .
*.     = 4 ==> START                                                  .
*.  RC = VALUE TO BE USED TO SET LOCATION COUNTER(START ONLY,RB=4)    .
*.       EXIT CONDITIONS                                              .
*.  RB = 0 ==> NO ERRORS.  ›=0 ==> AN ERROR CODE TO BE SET            .
*.  RB = NONZERO VALUE - ERROR CODE - ($ERDPCSE)                      .
*.  AVCESDID  IS INCREMENTED BY 1 OR 2 FOR NEXT VALUE OF REQUIRED TYPE.
*.       I.E. CSECTS HAVE EVEN VALUES, DSECTS ODD ONES.               .
*.  LOCATION COUNTERS ARE MODIFIED (AVLOCHIH,AVLOCNTR).               .
*.       USES MACROS: $ALIGR,$AL2,$GLOC,$RETURN,$SAVE,$SLOC           .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESCSEC   $SAVE SA=NO
         L     RE,AVLABPT          GET POINTER TO LABEL ENTRY
         LTR   RE,RE               WAS THER A STMT LABEL
         BNZ   ESCSLAB             RE = @ SYMBOL TABLE ENTRY,BRANCH
         TM    AVTAGS1,$IBPRCD1    HAS PRIVATE CODE OCCURRED
         BO    ESCSERPC            ERROR-RESUMPTION OF PRIVATE CODE
         OI    AVTAGS1,$IBPRCD1    FLAG THAT PRIVATE CODE HAS NOW OCCUR
         AIF   (NOT &$MACROS).ESNOMA1       SKIP IF NO MACROS
         MVC   AVSYSECT,AWBLANK    SET &SYSECT FOR USE OF MEXPND
.ESNOMA1 ANOP
         B     ESCSINCR            GO BUMP ESDID
         SPACE 1
         USING SYMSECT,RE          NOTE SYMBOL TABLE USING
ESCSLAB  TM    SYFLAGS,$SYDEF      HAS SYMBOL BEEN DEFINED ALREADU
         BO    ESCSERPC            ERROR-RESUMPTION OF CONTROL SECT
         AIF   (NOT &$MACROS).ESNOMA2       SKIP IF NO MACRO EXPANDSER
*              SET UP &SYSECT FOR MACRO EXAPNDER MEXPND.
         MVC   AVSYSECT,AWBLANK    BLANK OUT SECTION NAME
         MVC   *+7(1),SYCHARS      MOVE LEN-1 INTO NEXT INSTR
         MVC   AVSYSECT($),SYMBOL  MOVE SYMBOL OVER, NOW RIGHT-PADDED
.ESNOMA2 ANOP
ESCSINCR SR    RD,RD               CLEAR FOR INSERTION
         IC    RD,AVCESDID         GET CURRENT ESDID
         LA    RD,2(RD)            INITIALLY INCREMENT BY 2 FOR NEXT
         STC   RD,AVCESDID         REPLACE UPDATED SECTION ID
         LH    RB,ESCSJUMP(RB)     GET OFFSET TO ROUTINE
ESCSJ    B     ESCSJ(RB)           TAKE BRANCH TO RIGHT SECTION
         SPACE 1
* * * * * PROCESS CSECT STATEMENT                                     *
ESCSECT  TM    AVTAGS1,$IBDSEC1    ARE WE IN DSECT CURRENTLY
         BZ    ESCSCS              NO WE AREN'T,SKIP
         NI    AVTAGS1,255-$IBDSEC1          REMOVE DSECT FLAG
         L     RC,AVLOCHIH         GET HIGHEST LOCATION COUNTER VALUE
         B     ESCSTAG             GO TO FLAG SYMBOL TABLE ENTRY
         SPACE 1
ESCSCS   $GLOC RC                  GET CURRENT LOCATION COUNTER
         C     RC,AVCSHIH          COMPARE TO HIGHEST IN CSECT
         BNL   ESCSTAG             GO TO TAG IF HIGHEST VALUE IN RC
         L     RC,AVCSHIH          ORG *-X MUST HAVE OCCURED-GET HIGHES
         EJECT
* * * * * COMMON CODE FOR START AND CSECT                             *
ESCSTART EQU   *
ESCSTAG  LTR   RE,RE               WAS THERE A SYMBOL
         BZ    ESCSDBL             SKIP TO ALIGN IF NO SYMBOL
         OI    SYFLAGS,$SYCSE      NOTE SYMBOL IS A CSECT
ESCSDBL  LA    RD,7                SET UP FOR D ALIGNING
         $ALIGR RC,RD              ALIGN VALUE TO DOUBLEWORD
         NI    AVCESDID,255-$ESDSECT        FLAG AS A CSECT, EVEN VALUE
         B     ESCSETL             GO SET LOCATION COUNTER,ETC.
         SPACE 1
* * * * * ESCSDSEC - PROCESS DSECT                                    *
ESCSDSEC SR    RC,RC               CLEAR FOR VALUE TO SET LOCATION COUN
         OI    SYFLAGS,$SYDSE      FLAG SYMBOL WITH DSECT
         OI    AVCESDID,$ESDSECT   MAKE SURE ODD, I.E. DSECT
         TM    AVTAGS1,$IBDSEC1    ARE WE ALREADY IN DSECT
         BO    ESCSETL             GO SET LOCCNTR IF ALREADY IN DSECT
         L     RD,AVCSHIH          GET HIGH IN CURRENT CSECT
         C     RD,AVLOCNTR         IS IT HIGHER THAN LOCATION COUNTER
         BNL   *+8                 SKIP IF VALUE IN RD IS HIGH
         L     RD,AVLOCNTR         GET LOCATION COUNTER-IT IS HIGH
         ST    RD,AVLOCHIH         SAVE THIS AS HIGHEST VALUE YET ENCOU
         OI    AVTAGS1,$IBDSEC1    NOTE THAT WE ARE NO WIN DSECT
         SPACE 1
ESCSETL  $SLOC RC                  SET NEW LOCATON COUNTER VALUE
         LR    RD,RC               DUPLICATE VALUE OVER FOR SETTING UP
         STM   RC,RD,AVCSLOW       STORE VALUE INTO AVCSLOW-AVCSHIH
         SR    RB,RB               SHOW NO ERRORS
ESCSRET  $RETURN SA=NO
ESCSERPC LA    RB,$ERDPCSE         ILLEGAL CSECT RESUMPTION
         B     ESCSRET             RETURN
         SPACE 1
*              JUMP OFFSET TABLE FOR 3 TYPES OF CALLS TO ESCSEC       *
ESCSJUMP $AL2  ESCSJ,(ESCSECT,ESCSTART,ESCSDSEC)
         DROP  RE                  CLEAR USING
         EJECT
**--> ENTRY: ESENX1       ENTRY AND EXTRN STATEMENTS- PASS 1. . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER                                                 .
*.  RB = 0 ==> ENTRY                                                  .
*.     = 2 ==> EXTRN                                                  .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO BLANK FOLLOWING OPERAND FIELD, OR ERROR      .
*.  RB = 0 ==> NO ERRORS.  ›= 0 ==> ERROR CODE TO BE SET              .
*.  RB = NONZERO VALUE - ERROR CODE - ($ERINVDM,$ERINVSY)             .
*.  ALL LABEL'S IN STMT HAVE SYMSECTS FLAGGED APPROPRIATELY.          .
*.       CALLS SYENT1                                                 .
*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESENX1   $SAVE SA=ESDOSAVE,RGS=(R14-R6),BR=RW
         LA    RZ,ESNX1RET         SHOW @ FOR RETURN FROM ERROR
         MVI   ESENXF+1,$SYENT     PLACE THIS INTO FLAGGING INST
         LTR   RB,RB               WAS THIS CALL FOR ENTRY
         BZ    *+8                 SKIP IF SO
         MVI   ESENXF+1,$SYEXT     WAS EXTRN-PUT FLAG BYTE IN
         LA    RY,1                ST UP USEFUL 1 IN ODDREG
         SPACE 1
ESENX1A  BAL   RX,ESSYMBOL         GO HAVE SYMBOL SCANNED AND ENTERED
         USING SYMSECT,RC          NOTE USING(SET UP BY ESSYMBOL)
ESENXF   OI    SYFLAGS,$CHN        WILL HAVE FLAG BYTE PLACED IN
         CLI   0(RA),C' '          WAS THIS LAST ONE
         BE    ESN1RETA            GO RETURN WITH NO ERRORS
         CLI   0(RA),C','          IS DELIMITER RIGHT ONE
         BNE   ESERIND             NO,ERROR
         BXH   RA,RY,ESENX1A       BUMP SCAN PTR, GO FOR NEXT NAME
         SPACE 1
ESN1RETA SR    RB,RB               SHOW NO ERRORS
ESNX1RET $RETURN RGS=(R14-R6)
         EJECT
**--> ENTRY: ESENX2       ENTRY AND EXTRN STATEMENTS - PASS 2 . . . . .
*.       CHECKS ENTRY/EXTRN STATEMENTS FOR CONFLICTS, ERRORS.         .
*.       ENTRY AND EXIT CONDITIONS EXACTLY SAME AS ESENX1             .
*.             EXCEPT EXIT VALUE OF RB MEANS NOTHING.                 .
*.       CALLS ERRTAG,SYENT1                                          .
*.       USES MACROS: $CALL,$GTAD,$RETURN,$SAVE                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
ESENX2   $SAVE SA=ESDOSAVE,RGS=(R14-R6),BR=RW
         LA    RZ,ESNX2RET         SHOW @ FOR ERROR RETURN, IF ANY
         LR    R0,RB               SAVE CODE, =0 ==> ENTRY, =2==>EXTRN
         LA    RY,1                FOR BXH'ING CONSTANT IN ODD REG
         SPACE 1
ESNX2L   BAL   RX,ESSYMBOL         CALL SYMBOL LOOKUP ROUTINE
         LTR   R0,R0               ENTRY OR EXTRN
         BNZ   ESNX2EXT            EXTRN-BRANCH
         SPACE 1
         TM    SYFLAGS,$SYDEF      WAS ENTRY DEFINED
         BZ    ESNX2ERA            NO IT WASNT, ERROR BRANCH
         TM    SYFLAGS,$SYDSE+$SYEXT        WAS IT ALSO MARKED DSECT/EX
         BZ    ESNX2M              NO, IT WAS LEGAL, BRANCH
ESNX2ERA LA    RB,$ERENTRY         ENTRY ERROR
         B     ESNX2ERR            GO HAVE IT FLAGGED
         SPACE 1
ESNX2EXT TM    SYFLAGS,$SYDEF+$SYENT+$SYCSE+$SYDSE    IS EXTRN OK
         BZ    ESNX2M              YES, BRANCH, LEGAL
         LA    RB,$EREXTRN         EXTERNAL NAME ERROR
ESNX2ERR SR    RA,RY               BACK SCAN PTR UP 1
         $CALL ERRTAG              HAVE THERROR FLAGGED
         AR    RA,RY               INCREMENT BACK TO DELIMITER
         SPACE 1
ESNX2M   CLI   0(RA),C' '          WAS ENDING DELIMITER BLANK
         BCR   E,RZ                B ESNX2RET - QUIT
         BXH   RA,RY,ESNX2L        BUMP SCAN PTR AND CONTINUE
         SPACE 1
ESNX2RET $RETURN RGS=(R14-R6),SA=ESDOSAVE
         EJECT
         USING ESDOSAVE,R13        GIVE SUBR COMMON BASE FROM 1-2
*              INDIVIUDAL ERROR EXITS AND FLAGGING                    *
ESERIND  LA    RB,$ERINVDM         INVALID DELIMITER
         BR    RZ                  RETURN TO REQUIRED LOCATION
ESERSYM  LA    RB,$ERINVSY         INVALID SYMBOL
         BR    RZ                  RETURN TO REQUIRED LOCATION
         SPACE 1
* * * * * ESSYMBOL - SCAN SYMBOL,HAVE IT ENTERED IN TABLE,RETURN @    *
ESSYMBOL SR    R1,R1               CLEAR SO TRT'S WORK
         TRT   0(9,RA),AWTSYMT     SCAN FOR DELIMITER
         BZ    ESERIND             FLAG ERROR, IF SYMBOL TOO LONG
         CLI   0(RA),C'0'          MAKE SURE NOT LEADING DIGTI
         BNL   ESERSYM             LEADING DIGIT-ILLEGAL
         LR    RB,R1               MOVE END SCAN POINTER OVER
         SR    RB,RA               GET LENGTH OF SYMBOL
         BZ    ESERIND             ZWRO LENGTH SYMBOL -DELIMITER
         $CALL SYENT1              HAVE SYMBOL ENTRED IN TABLE
         LR    RC,RA               MOVE POINTER TO SYMBOL ENTRY OVER
         LR    RA,R1               UPDATE  SCAN POINTER
         BR    RX                  RETURN TO CALLER
         DROP  RC,RW,R13           SYMSECT, REGUALR BASE, 2ND BASE
         TITLE '*** EVALUT - EXPRESSION EVALUATOR ***'
**--> DSECT: EVCTDSCT   EVALUT TRANSITION TABLE ENTRY . . . . . . . . .
*.       THIS DESCRIBES 1 ENTRY IN 1 ROW OF THE GENERAL EXPRESSION    .
*.       EVALUATOR EVALUT, AND GIVES A SECTION OFFSET @ TO USE, AND   .
*.       EITHER A NEXT STATE(ROW) IN TABLE OR AN ERROR CODE FOR AN    .
*.       ILLEGAL CURRENT STATE/CURRENT VALUE COMBINATION.             .
*.       LOCATION: TABLE EVCTAB IN CSECT EVALUT.                      .
*.       GENERATION: 1 ROW OF EVCTDSCTS IS GENERATED BY 1 EVCG MACRO. .
*.       NAMES: EVCT----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
EVCTDSCT DSECT
EVCTADR  DS    AL1                 JUMP OFFSET INDEX FOR ROUTINES
EVCTCOD  DS    AL1                 NEXT ROW OFFSET OR ERROR CODE
EVCTL    EQU   *-EVCTDSCT          LENGTH OF SINGLE TABLE ENTRY
*              EQU'S DEFINING OFFSETS ALONG ROWS IN EVCTAB            *
EVCLP    EQU   0                   (
EVCRP    EQU   EVCTL               )
EVCPL    EQU   2*EVCTL             + -
EVCMU    EQU   3*EVCTL             *
EVCDI    EQU   4*EVCTL             /
EVCAB    EQU   5*EVCTL             ABSOLUTE TERM
EVCRE    EQU   6*EVCTL             RELOCATABLE TERM
EVCBL    EQU   7*EVCTL             BLANK OR ,
         SPACE 2
**--> CSECT: EVALUT   1-2 GENERAL EXPRESSION EVALUATION ROUTINE . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF EXPRESSION)        .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER STOPPING SCAN, OR ERROR            .
*.  RB = 0 ==> EXPRESSION GOOD, = NONZERO VALUE==>ERROR CODE          .
*.  RC = VALUE OF EXPRESSION, IF IT WAS GOOD                          .
*.  RD = 0 ==> EXPRESSION WAS AN ABSOLUTE EXPRESSION                  .
*.     = ESDID FOR A RELOCATABLE EXPRESSION (1-255)                   .
*.  RE = LENGTH ATTRIBUTE - 1 OF EXPRESSION.                          .
*.       CALLS SDBCDX,SYFIND                                          .
*.       USES DSECTS: AVWXTABL,EVCTDSCT,RCODBLK,RSBLOCK,SYMSECT       .
*.       USES MACROS: $CALL,$GLOC,$RETURN,$SAVE,EVCG                  .
*.                                                                    .
*.       **NOTE** SEE IBM PLM Y26-3700-0, PP. 45-47. EVALUT SOMEWHAT  .
*.       RESEMBLES IEUF7V-EXPRESSION EVALUATION ROUTINE.  NOTE EVALUT .
*.       HAS 1 LESS STATE SETTING, SINCE IEUF7V COND=0 IS UNNEEDED.   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         EJECT
EVALUT   CSECT
         $DBG  B0,SNAP
* * * * * REGISTER ALLOCATION AND USAGE FOR EVALUT* * * * * * * * * * *
*   R0   UNRESTRICTED WORK REGISTER                                   *
*   R1   ADDRESS WORK REGISTER - HIGH-ORDER BYTE =0 ALWAYS            *
*   R2   BYTE WORK REGISTER - HIGH-ORDER 3 BYTES = 0 ALWAYS           *
*   RW   TERM /SIGN/ID STACK INDEX = INDEX OF NEXT EMPTY H IN EVTRID  *
*   RX   OPERATOR STACK POINTER = @ LAST OPERATOR CODE IN EVOPRS      *
*   RY = 1     USEFUL CONSTANT IN ODD REGISTER, CAN BE USED FOR BSH'S *
*   RZ   STATE REGISTER = @ ROW IN EVCTAB OR @ ENTRY IN EVCTAB        *
*   RA   SCAN POINTER TO NEXT CHARACTER TO BE EXAMINED                *
*   RB-RE      GENERAL WORK REGISTERS AND PARAMETER REGISTERS         *
*   R13  BASE REGISTER AND SAVE AREA POINTER                          *
*   R14  INTERNAL AND EXTERNAL LINK REGISTER                          *
*   R15  UNRESTRICTED WORK REGISTER                                   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R6),BR=R13,SA=EVALSAVE
EVLPC    EQU   2                   AWTSYMT CODE FOR LEFT PAREN
         SPACE 1
*              INITIALIZATION SECTION                                 *
         NI    EVFLENG+1,X'0F'     MAKE SURE BRANCH IS A NOPR
         LA    R0,16               FOR INIT OF EVPCNT-EVTRNM
         STH   R0,EVPCNT           STORE EVPCNT=0, EVTRNM=16
         LM    R1,RW,AWZEROS       ZERO OUT
         LA    RX,EVOPRS           INIT TO BEFINNING OF STACK
         LA    RY,1                HANDY CONSTANT IN ODD REGISTER
         USING EVCTDSCT,RZ         NOTE TRANSITION TABLE ENTRY USING
         B     EVCNEXTA            ENTER AT RIGHT PLACE TO START
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MAIN CONTROL POINT - PICK UP CODE FROM PREVIOUS ENTRY  *
*        IN TRANSITION TABLE, TO MAKE IT THE CURRENT STATE. FIND FROM *
*        THIS THE @ NEW ROW INT ABLE (NEW STATE).  GET THE NEXT CHAR  *
*        TO BE SCANNED, GET CODE FORM AWTSYMT WHICH DESCRIBES IT. IF  *
*        THE CHAR IS A DELIMITER, SKIP TO EVCOPRT.  FOR A CHARACTER   *
*        WHICH MIGHT BEGIN A TERM (ALPHANUMERIC), SCAN AND EVALUATE   *
*        THE TERM, DETERMINING ITS RELOCATIBILITY ATTRIBUTE FOR LATER *
*        IN REGS RC & RD FOR USE BY EVTERM, IF LEGAL.                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EVCNEXT  IC    R2,EVCTCOD          GET CODE FROM PREVIOUS ENTRY
EVCNEXTA LA    RZ,EVCTAB(R2)       GET @ REQUIRED ROW IN EVCTAB
         AIF   (&$DEBUG).EVCX0     SKIP IF PRODUCTION MODE
         XSNAP IF=(AVDEBUG,O,X'B0',TM),STORAGE=(EVOPRS,EVALQ),         #
               LABEL='EVCNEXTA'
.EVCX0   ANOP
         IC    R2,0(RA)             GET THE NEXT SOURCE BYTE
         IC    R2,AWTSYMT(R2)       GET THE CODE FROM THE TABLE
         CR    R2,RY                COMPARE TO 1 FOR TYPE
         BH    EVCOPRT              IF >1, CHARACTER WAS OPERATOR
         BE    EVZILCH              ILLEGAL CHARACTER, IF =1
         SPACE 1
*              TERM-PROCESSING SECTION - CODE IN R2 = 0               *
         CLI   0(RA),C'0'           WAS IT A DIGIT
         BNL   EVCSDT2             SKIP TO SELF-DEFINING TERM SECTION
         CLI   1(RA),C''''          IS NEXT CHAR A '
         BE    EVCSDT1              SKIP IF SO, I.E. L' B' C' OR X'
         SPACE 1
*              SYMBOL FOUND - HAVE IT SCANNED. GET VALUE,SECTION ID.
         BAL   R14,EVSYMB           CALL SYMBOL ROUTINE
         USING SYMSECT,RB           NOTE POINTER
         L     RC,SYVALUE           GET VALUE OF SYMBOL INTO RC
         IC    R2,SYLENG            GET LENGTH-1
         BAL   R14,EVFLENG          CALL LENGTH ATTRIB SAVER
         IC    R2,SYESDID           GET SECTION ID
         LTR   RD,R2                MOVE SECTION ID AND TEST IT
         BZ    EVCABSA              SKIP IF0, I.E. ABSOLUTE SYMBOL
         LA    R2,EVCRE            SHOW OFFSET FOR RELOCATABLE TERM
         B     EVCJUMPA             GO TO MAKE CHOICE
         EJECT
*              ABSOLUTE TERM - SELF-DEFINING OR LENGTH ATTRIBUTE      *
EVCSDT1  CLI   0(RA),C'L'           WAS IT L'
         BNE   EVCSDT2              NO, MUST BE X' B' OR C'
*              TERM IS A LENGTH ATTRIBUTE - L'SYMBOL OR L'*.
         LA    RA,2(RA)             BUMP SCAN PTR PAST L'
         CLI   0(RA),C'*'          IS IT L'*
         BNE   EVCSDT2A            SKIP IF NOT (BRANCH PROBABLE)
         BAL   R14,EVFLQAS         CALL L'* ROUTINE
         BXH   RA,RY,EVCSDT2B      BRANCH, INCREM SCAN PTR BEYOND *
         SPACE 1
*              PROCESS SELF-DEFINING TERM                             *
EVCSDT2  $CALL SDBCDX              CALL SELF-DEF TERM PROCESSOR
         LTR   RB,RB                WAS RESULT OK
         BZ    EVCSDT3              YES,OK,RESULT IN RC
         BP    EVZERROR             ERROR,BRANCH
         BXH   RA,RY,EVZSYNT       ' BAD, LETTER NOT B,C,X-ERROR
         SPACE 1
EVCSDT2A BAL   R14,EVSYMB          CALL SYMBOL LOOKUP
         IC    R2,SYLENG           GET LENGTH-1
         DROP  RB                  REMOVE SYMSECT USING
EVCSDT2B LA    RC,1(R2)            MOVE, CONVERT LENGTH-1 TO LENGTH
         BAL   R14,EVFLENG         HAVE LENGTH ATTRIB SAVED,IF NEEDED
*              IF EVCSDT3 ENTERED THRU EVCSDT1, R2 STILL =0 (L' =1)
EVCSDT3  BAL   R14,EVFLENG         HAVE LENGTH-1 SAVED, IF NOT ALREADY
         SR    RD,RD                SHOW ABSOLUTE TERM
EVCABSA  LA    R2,EVCAB            SHOW OFFSET FOR ABSOLUTE TERM
         B     EVCJUMPA             GO TO MAKE BRANCH
         EJECT
* * * * * EVFLQAS - OBTAIN L'*-1, RETURN IT IN R2, IF IT EXISTS       *
*        THIS ROUTINE CALLED ONLY BY TERM PROCESSING SECTION          *
*        EXIT CONDITIONS                                              *
*   R2 = L'* - 1, FOR USE AS EXPLICIT LENGTH ATTRIBUTE, OR IMPLIED L  *
         SPACE 1
EVFLQAS  L     R15,AVRSBPT         GET RSB POINTER
         USING RSBLOCK,R15         NOTE USING FOR RSBLOCK
         SR    R2,R2               SET R2=0, I.E. L'* = 1
         TM    RSBFLAG,$RCBX       IS THERE AN RCB
         BCR   Z,R14               RETURN IF THERE ISN'T ANY,USE 1
         L     R15,AVRCBPT         RCB EXISTS, GET THE @ OF IT
         USING RCODBLK,R15         NOTE NEW USING
         IC    R2,RCLQ             GET THE L'* VALUE
*        BR R14 FALL THRU INTO EVFLENG, SET LENGTH-1 OR JUST RETURN.
         DROP  R15                 KILL RCODBLK USING
         SPACE 1
* * * * * EVFLENG - STORE LENGTH ATTRIBUTE-1, IF 1ST TIME             *
*        THIS ROUTINE CALLED ONLY FROM TERM PROCESSING SECTION.       *
*        MUST IMMEDIATELY FOLLOW SECTION EVFLQAS.                     *
*        ENTRY CONDITIONS                                             *
*   R2 = LENGTH ATTRIVUTE-1                                           *
         SPACE 1
EVFLENG  BCR   $CHN,R14             RETURN TO CALLER IF NOT 1ST TIME
         OI    EVFLENG+1,X'F0'      CHANGE NOPR TO BR
         STC   R2,EVALQ             SAVE LENGTH ATTRIBUTE - 1
         BR    R14                  RETURN TO CALLER
         SPACE 1
* * * * * EVSYMB - SCAN SYMBOL AND HAVE IT LOOKED UP BY SYFIND        *
*        THIS SECTION CALLED ONLY FROM TERM PROCESSING SECTION.       *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF SYMBOL                      *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO DELIMITER FOLLOWING SYMBOL                   *
*   RB = @ SYMSECT ENTRY IN SYMBOL TABLE OF THE SYMBOL                *
         SPACE 1
EVSYMB   TRT   0(9,RA),AWTSYMT      SCAN FOR DELIMITER
         BZ    EVZINVSY             IF NOT FOUND,SYMBOL TOO LONG-ERROR
         LR    RB,R1               GET PTR TO DELIMITER INTO RB
         SR    RB,RA                GET LENGTH OF SYMBOL
         BZ    EVZILCH              ILLEGAL CHARACTER
         LR    R0,R14               SAVE RETURN @
         SPACE 1
         $CALL SYFIND              CALL LOOKUP ROUTINE
         LTR   RB,RB                WAS THE SYMBOL UNDEFINED
         BNZ   EVZUNDEF             UNDEFINED SYMBOL,ERROR
         LR    RB,RA                MOVE POINTER TO SYMBOL OVER
         USING SYMSECT,RB           NOTE SYMBOL POINTE
         TM    SYFLAGS,$SYDEF       WAS SYMBOL DEFINED
         BZ    EVZUNDEF             NO,UNDEFINED-BRANCH
         LR    RA,R1                GET SCAN PTR TO DELIMITER
         LR    R14,R0               RESTORE RETURN @
         BR    R14                  RETURN TO CALLING SECTION
         DROP  RB                   KILL USING
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              BRANCH ACCORDING TO CURRENT STATE (GIVEN BY RZ) AND    *
*        TYPE OF TERM OR DELIMITER.  USE VALUES IN EVCTAB, WHICH      *
*        CONTAIN OFFSET JUMP VALUES, AND EITHER A NEXT STATE VALUE,   *
*        OR AN ERROR CODE IF A BRANCH TAKEN DIRECTLY TO EVCERR.       *
*        THE LABELS EVERR, EVLOCNT, EVTERM, EVPCHIH, EVPCTES, EVPCZER,*
*        AND EVOPCHK MUST ALL BE WITHIN 256 BYTES OF EVDJUMP.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
EVCOPRT  LR    R1,R2               SAVE OPERATOR CODE FROM AWTSYMT
         IC    R2,EVCOFFS(R2)      GET OFFSET FOR TRANSITION TABLE
EVCJUMPA LA    RZ,EVCTDSCT(R2)     GET @ INDIVIDUAL ENTRY INTABLE
         IC    R2,EVCTADR          GET JUMP INDEX VALUE FROM TABLE
         AIF   (&$DEBUG).EVCX1     SKIP IF PRODUCTION MODE
         XSNAP IF=(AVDEBUG,O,X'B0',TM),                                #
               STORAGE=(*EVDJUMP(R2),*EVDJUMP+4(R2)),LABEL='EVDJUMP'
.EVCX1   ANOP
         B     EVDJUMP(R2)         TAKE BRANCH TO PARTICULAR ROUTINE
EVDJUMP  EQU   *                   BASE FOR RPUTINE JUMPS
         SPACE 1
* * * * * EVERR - OBTAIN ERROR CODE FROM TRANSITION TABLE, EXIT.      *
EVERR    IC    R2,EVCTCOD          GET ERROR CODE
         LR    RB,R2                MOVE TO EXPECTED LOCATION
         B     EVZERROR             GO TO FINISH
         SPACE 1
* * * * * EVLOCNT - PROCESS LOCATION COUNTER REFERENCE                *
EVLOCNT  $GLOC RC                   GET LOCATION COUNTER
         IC    R2,AVCESDID          GET SECTION ID CURRENT
         LR    RD,R2               MOVE OVER WHERE EXPECTED
         BAL   R14,EVFLQAS         CALL L'* ROUTINE, SAVE LENGTH-1 ATT
         AR    RA,RY               BUMP SCAN PTR 1, FALL THRU TO EVTERM
         SPACE 1
* * * * * EVTERM - ENTER TERM VALUE AND ID INTO EVTRMS/EVTRID         *
*        THIS SECTION MUST IMMEDIATELY FOLLOW EVLOCNT.                *
*        ENTRY CONDITIONS                                             *
*   RC = VALUE OF TERM TO BE ENTERED                                  *
*   RD = SECTION ID (1-255) FOR RELOCATABLE, 0 FOR ABSOLUTE TERM      *
*   RW = INDEX OF NEXT EMPTY SLOT IN EVTRID                           *
*        EXIT CONDITIONS                                              *
*   RW = RW+2  (I.E. ONE ENTRY HAS BEEN PUSHED INTO STACK)            *
         SPACE 1
EVTERM   IC    R2,EVTRNM           GET # TERMS LEFT TO GO
         SR    R2,RY               DECREMENT
         BM    EVZTMTR             TOO MANY TERMS IN EXPRESSION
         STC   R2,EVTRNM           STORE BACK UPDATED VALUE
         STH   RD,EVTRID(RW)       STORE SECTION ID
         LA    R15,0(RW,RW)        GET INDEX FOR EVTRMS ENTRY
         ST    RC,EVTRMS(R15)      STORE  THE VALUE OF TERM
         LA    RW,2(RW)            INCREMENT THE OFFSET INDEX
         B     EVCNEXT             GO BACK FOR NEXT ONE
         EJECT
* * * * * EVPCHIH - ( FOUND, INCREMENT AND TEST PAREN COUNT           *
EVPCHIH  CLI   EVPCNT,4             CHECK PAREN COUNT
         BH    EVZPARN              TOO MANY PARENS-BRANCH
         IC    R2,EVPCNT            GET PAREN COUNT
         AR    R2,RY               INCREMENT BY 1
         STC   R2,EVPCNT            STORE BACK
         B     EVOPENT             GO ENTER OPERATOR
         SPACE 1
* * * * * EVPCTES - , OR BLANK FOUND, MAKE SURE PAREN COUNT = 0       *
EVPCTES  CLI   EVPCNT,0             IS PAREN COUNT 0 LIKE IT SHOULD BE
         BE    EVFRCA              YES, GO FORCEBACK ALL OPERATORS
         B     EVERR               ERR-UNEXPECTED END OF EXPRESSION
         SPACE 1
* * * * * EVPCZER - ) FOUND, TEST AND DECREMENT PAREN COUNT, FORCEBACK*
EVPCZER  IC    R2,EVPCNT            GET PAREN COUNT
         SR    R2,RY                DECREMENT PAREN COUNT
         BNM   *+8                 IF WAS NOT PREVIOUSLY ZERO, JUMP
         BXLE  R2,RY,EVFRCA        SET R2=0, BRANCH TO FINISH UP
         STC   R2,EVPCNT            STORE BACK
         SPACE 1
* * * * * EVFRCP - FORCE EVALUATION BACK TO LAST LEFT PAREN           *
*              LOOP UNTIL LEFT PAREN CODE FOUND IN OPERATOR STACK     *
EVFRCP   BALR  R14,0               SET R14 = @ NEXT INSTRUCTION, LOOP
         CLI   0(RX),EVLPC         IS CURRENT CODE THAT OF LEFT PAREN
         BNE   EVFRCO              NO, SO EVALUATE UNTIL WE FIND (
         SPACE 1
         SR    RX,RY               DECREMENT OPERATOR STACK POINTER
         AR    RA,RY               BUMP SCAN POINTER PAST )
         LH    R15,EVTRID-2(RW)    GET CURRENT SIGN/ID
         LTR   R15,R15             IS IT ABSOLUTE
         BZ    EVCNEXT             ABSOLUTE, SO USE NEXT STATE FROM TAB
         LA    R2,EVCT4-EVCTAB     OFFSET FOR RELOCATABLE
         B     EVCNEXTA            GO FOR NEXT
         SPACE 1
* * * * * EVOPCHK - CHECK OPERATOR PRECEDENCE, EVALUATE IF NEEDED     *
*        ENTRY CONDITIONS                                             *
*   R1 = OPERATOR CODE OF CURRENT OPERATOR, FROM AWTSYMT              *
EVOPCHK  IC    R2,0(RX)            GET CODE OF PREVIOUS OPERATOR
         IC    R2,EVOPREC(R2)      PRECEDENCE OF PREV OP +- = 0
         SR    R15,R15             CLEAR FOR INSERT
         IC    R15,EVOPREC(R1)     GET PRECEDENCE OF NEW OPERATOR
         CR    R15,R2              IF NEW PREC > OLD, SKIP EVALUATRE
         BH    *+8                 IF NEW CODE> OLD CODE, SKIP EVAL
         BAL   R14,EVFRCO          FORCE 1 OPERATOR EVALUATION
         SPACE 1
EVOPENT  AR    RX,RY               INCREMENT POINTER TO EMPTY SLOT
         STC   R1,0(RX)            STORE CODE OF NEW OPERATOR
         BXH   RA,RY,EVCNEXT       BUMP SCAN POINTER, GET NEXT CODE
         SPACE 1
         EJECT
* * * * * EVFRCO - EVALUATE 1 OPERATOR AND 2 TERMS IN STACKS          *
*        ENTRY CONDITIONS                                             *
*   RW = INDEX OF NEXT EMPTY HALFWORD IN EVTRID STACK                 *
*   RX = @ LAST OPERATOR CODE ENTERED IN OPERATOR STACK EVOPRS        *
*   R14= RETURN ADDRESS TO CALLING SECTION OF CODE.                   *
*        EXIT CONDITONS                                               *
*   RC = COMPUTED RESULT OF OPERATION                                 *
*   RW = RW-2  (I.E. 1 ENTRY OF EVTRID&EVTRMS WAS POPPED)             *
*   RX = RX-1  (I.E. ONE ENTRY FROM OPERATOR STACK WAS POPPED)        *
EVFRCO   SR    RW,RY               SUBTRACT 1 FROM INDEX
         SR    RW,RY               SUBTRACT ANOTHER 1, MAKING -2
         LH    RE,EVTRID(RW)       GET PREVIOUS SIGN CODE/SECTION ID
         LA    R15,0(RW,RW)        GET 2* RW FOR INDEX INTO EVTRMS
         LA    R15,EVTRMS-4(R15)   GET @ 2ND PREVIOUS ENTRY
         LM    RC,RD,0(R15)        GET 2ND PREVIOUS,PREVIOUS EVTRMS
         IC    R2,0(RX)            GET CURRENT OPERAOTR CODE
         IC    R2,EVFRCT-5(R2)     GET OFFSET VALUE FOR TYPE JUMP
         B     EVFRJ(R2)           TAKE BRANCH TO SECTION
EVFRJ    EQU   *                   BASE FOR OPERATOR JUMPS
         SPACE 1
*        - OPERATOR                                                   *
EVFRMI   SR    RC,RD               PERFORM OPERATION
         LCR   RE,RE               COMPLEMENT SIGN CODE/SECTION ID
         B     EVFRPLA             CONTINUE WITH COMMON +- CODE
         SPACE 1
*        + OPERATOR                                                   *
EVFRPL   AR    RC,RD               PERFORM OPERATION
         LTR   RE,RE               WAS PREVIOUS AN ABS TERM(RE=0 IF SO)
EVFRPLA  BZ    EVFRCOEX            YES, SO LEAVE 2ND PREV CODE AS IS
         LH    RB,EVTRID-2(RW)     GET 2ND PREVIOUS SIGN CODE/ID
         LTR   RB,RB               WAS 2ND PREV TETRM ABSOLUTE
         BZ    EVFRPLB             YES, SO USE PREV CODE UNCHANGED-BRAN
         AR    RE,RB               2 RELOCATABLE TERMS, ADD SIGN/ID
         BNZ   EVZCXREL            IF NO 0, COMPLEX RELOCATIBILITY
EVFRPLB  STH   RE,EVTRID-2(RW)     SAVE COMPUTED SIGN/ID INTO RESULT
         B     EVFRCOEX            HAVE RESULT SAVED AND EXIT
         SPACE 1
*        * OPERATOR                                                   *
EVFRMU   MR    RB,RD               1ST OP IN RC, RESULT VALUE ALSO
         B     EVFRCOEX            GO HAVE RESULT STORED
         SPACE 1
*        / OPERATOR                                                   *
EVFRDI   LR    RB,RC               MOVE 2ND PREVIOUS VALUE OVER
         LTR   RC,RD               MOVE AND TEST DIVISOR OVER
         BZ    EVFRCOEX            IF DIVISOR =0, LEAVE RC=0,BRANCH
         SRDA  RB,32               PROPAGATE SIGN,MOVE DIVIDEND BACK
         DR    RB,RD               PERFORM OPEATION ,HAVING CHECKED 0
         SPACE 1
EVFRCOEX ST    RC,0(R15)           STORE RESULT INTO EVTRMS STACK
         AIF   (&$DEBUG).EVCX2     SKIP IF PRODUCTION MODE
         XSNAP IF=(AVDEBUG,O,X'B0',TM),LABEL='EVFRCOEX'
.EVCX2   ANOP
         BCTR  RX,R14              BACK UP OPERATOR POINTER 1, RETURN
         EJECT
* * * * * EVFRCA - FORCE EVALUATION OF ALL VALUES, RETURN TO CALLER   *
*        LOOP CALLING EVFRCO UNTIL LEFT PAREN CODE FOUND              *
*        NOTE THAT EVFRCO LEAVE RESULT IN RC, SO NEED NOT BE FETCHED. *
EVFRCA   BALR  R14,0               SET R14 = @ NEXT INSTRUCTION
         CLI   0(RX),EVLPC         IS CURRENT OP CODE LEFT PAREN
         BNE   EVFRCO              IF NOT, CALL FORCE 1 OPERATOR SECTIO
         SPACE 1
         LH    RD,EVTRID           GET 1ST RELOCATE ID HALFWORD
         LTR   RD,RD               IS IT ACCEPTABLE (0 OR +)
         BM    EVZCXREL            IF <0, NEGATIVE RELOCATABLE TERM
         CL    RC,AWFX6F           IS VALUE WITHIN 24 BITS
         BH    EVZEXGTA            NO,ERROR BRANCH
         IC    R2,EVALQ            GET LENGTH ATTRIBUTE - 1
         LR    RE,R2               MOVE LENGTH ATTRIBUTE - 1 OVER
         SR    RB,RB               SHOW THE EXPRESSION WAS OK
EVZERROR EQU   *                   DEFINE LABEL FOR ERROR EXIT
EVRET    $RETURN RGS=(R14-R6)
         SPACE 1
* * * * * ERROR EXIT SECTION                                          *
EVZCXREL LA    RB,$ERCXREL         COMPLEX RELOCATIBILITY ILLEGAL
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZEXGTA LA    RB,$EREXGTA         SHOW LARGER THAN 24 BITS
         LTR   RC,RC               WAS VALUE POSITIVE
         BP    EVZERROR            BRANCH IF SO, FALL THRU IS NOT
EVZEXLTA LA    RB,$EREXLTA         SHOW EXPRESSION NEGATIVE
         B     EVZERROR            GO RETURN WITH ERROR
EVZILCH  LA    RB,$ERVILCH         ILLEGAL CHARACTER
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZINVSY LA    RB,$ERINVSY          SHOW INVALID SYMBOL
         B     EVZERROR             GO TO SHOW ERROR
EVZPARN  LA    RB,$ERVPARN         TOO MANY PARENS
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZSYNT  LA    RB,$ERVSYNT         SYNTAX
         B     EVZERROR            EXIT, WITH ERROR CODE
EVZTMTR  LA    RB,$ERVTMTR         TOO MANY TERMS IN EXPRESSION
         B     EVZERROR            GO RETURN WITH ERROR
EVZUNDEF LR    RA,R1                MOVE SCAN POINTER BACK
         SR    RA,RY               DECREMNT BY 1 FOR BETTER POINTER
         LA    RB,$ERUNDEF          SHOW UNDEFINED
         B     EVZERROR             GO TO ERROR SECTION
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
EVCOFFS  EQU   *-2                 OFFSET BACKWARDS SMALLEST INDEX
*              OFFSETS OBTAINED USING INDEX VALUE FROM AWTSYMT        *
         DC    AL1(EVCLP,EVCRP,EVCBL,EVCPL,EVCPL,EVCMU,EVCDI)
*        JUMP OFFSET TABLE FOR EVFRCO - FOR + - * / OPERATORS         *
EVFRCT   DC    AL1(EVFRPL-EVFRJ,EVFRMI-EVFRJ,EVFRMU-EVFRJ,EVFRDI-EVFRJ)
EVOPREC  EQU   *-2                 ORIGIN RIGHT FOR INDICES 2 UP
         DC    AL1(0,0,0,1,1,2,2)  PRECEDENCES: ( X X + - * / (2-8)
         SPACE 1
EVCTAB   DS    0H                  TRANSITION TABLE
EVCT1    EVCG  (PCHIH,1,ERR,SYNT,ERR,SYNT,LOCNT,4,ERR,SYNT,TERM,3,TERM,#
               4,ERR,UNEX)         BEGINNING ( + - LAST FOUND
EVCT2    EVCG  (PCHIH,1,ERR,SYNT,ERR,SYNT,ERR,SYNT,ERR,SYNT,TERM,3,ERR,#
               RELO,ERR,UNEX)      * / OPERATORS LAST ENCOUNTERD
EVCT3    EVCG  (PCTES,SYNT,PCZER,3,OPCHK,1,OPCHK,2,OPCHK,2,ERR,SYNT,ERR#
               ,SYNT,PCTES,UNEX)   ABSOLUTE TERM WAS LAST
EVCT4    EVCG  (PCTES,SYNT,PCZER,3,OPCHK,1,ERR,RELO,ERR,RELO,ERR,SYNT,E#
               RR,SYNT,PCTES,UNEX) RELOCATABLE TERM LAST PREVIOUS
         SPACE 1
*              OPERATOR STACK - 1ST ENTRY IS CODE FOR (               *
EVOPRS   DC    AL1(EVLPC)          BEGINNING OF OPERATOR STACK,LEFT PRN
         DS    21C                 REMAINING SECTION OF EVOPRS
         SPACE 1
*              TERM STACK - COMPUTED VALUES KEPT TO 32 BITS.          *
EVTRMS   DS    16F                 TERM STACK
         SPACE 1
*              SIGN CODE/ID STACK. EACH HALFWORD IS ASSOCIATED WITH   *
*        CORRESPONDING FULLWORD IN EVTRMS.   FOR ABSOLUTE VALUES, THE *
*        EVTRID ENTRY = 0, FOR RELOCATABLE VALUES, THE SECTION ID IS  *
*        ENTERED IN THE 2ND BYTE OF A HALFWORD, WITH ZEROS IN THE 1ST *
*        BYTE.  IF THE VALUE IS NEGATIVE, THE HALFWORD IS COMPLEMENTED*
EVTRID   DS    16H                 SIGN CODE/ID STACK
*              EVPCNT AND EVTRNM MUST BE IN ORDER, ON H BOUNDARY      *
EVPCNT   DS    C                   PAREN COUNT - 0<=EVPCNT<=5
EVTRNM   DS    C                   # TERMS LEFT (INIT TO 16
EVALQ    DS    C                   LENGTH ATTRIVUTE - 1 OF EXPRESSION
         DROP  RAT,R13,RZ          KILL USINGS
         TITLE '*** IAMOP1 - MACHINE OPCODES - PASS 1 ***'
**--> CSECT: IAMOP1   1   MACHINE OPERATIONS - PASS 1 . . . . . . . . .
*.       THIS IS 1 OF 2 PASS 1,LEVEL 2 PROGRAMS.  IT PERFORMS ALL     .
*.       PASS 1 MACHINE INSTRUCTION PROCESSING, INCLUDING ALIGNMENT   .
*.       OF THE LOCATION COUNTER, SCANNING FOR LITERAL CONSTANTS,     .
*.       AND BUILDING AN RCODBLK FOR THE STATEMENT.  THE RCODBLK      .
*.       INCLUDES THE INSTRUCTION FORMAT TYPE, THE MACHINE CODE FOR   .
*.       THE GIVEN INSTRUCTION, MASK (EXTENDED MNEMONICS), FLAGS      .
*.       AND ALIGNMENT VALUES NEEDED, THE LENGTH ATTRIBUTE-1 FOR THE  .
*.       INSTRUCTION, AND THE ADDRESS OF A LITERAL CONSTANT IN THE    .
*.       LITERAL TABLE, IF THERE IS ONE USED.                         .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF OPCODE CONTROL TABLE ENTRY FOR OPCODE USED        .
*.       EXIT CONDITIONS                                              .
*.  RB = 0    NO ERRORS WERE ENCOUNTERED                              .
*.     = >0   ERRORS WERE FOUND IN STATEMENT                          .
*.  RC = @ RECORD CODE BLOCK(RCODBLK) FOR THE STATEMENT.              .
*.       THE RCODBLK HAS ALL VALUES FILLED IN EXCEPT RCLOC(IARCLOC).  .
*.  RD = LENGTH OF CODE - TO BE ADDED AFTER ALIGNMENT DONE            .
*.       CALLS ERRTAG,LTENT1,SCANEQ                                   .
*.       USES DSECTS: AVWXTABL,OPCODTB                                .
*.       USES MACROS: $CALL,$CKALN,$GLOC,$LTENT1,$RETURN,$SAVE,$SLOC  .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
IAMOP1   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R3),BR=R13,SA=IAMOSAVE
         USING OPCODTB,RC          NOTE TABLE POINTER
         MVC   IARCTYPE(3),OPCTYPE MOVE CODE BYTES OVER
         DROP  RC                  NO LONGER NEED POINTER HERE
         MVI   IARCLENG,RC$LEN     PUT IN NORMAL LENGTH-1
         LM    R1,R3,AWZEROS       GET HANDY ZEROS
         IC    R1,IARCHEX          GET HEX OPCODE
         SRL   R1,6                SHIFT TO GET INDEX
         IC    R3,IALENGS(R1)      GET LENGTH-1 FOR LENGTH ATTRIBUTE
         STC   R3,IARCLQ           SAVE FOR L' ATTRIBUTE
         SPACE 1
         CLI   AVCESDID,0          WAS CODE PRECEDED BY A CSECT
         BNE   IALICHK             CSECT OR DSECT BEFORE-BRANCH
         SPACE 1
         MVI   AVCESDID,2          NO, UNITIATED PRIVAT  CODE
         OI    AVTAGS1,$IBSTAR1+$IBPRCD1    SHOW NO START, PRIV CODE IN
         SPACE 1
IALICHK  $CKALN 1,IALNOK           CHECK ALIGNMENT AND BRANCH OK
         $GLOC R1                  GET LOCATION COUNTER VALUE
         LA    R1,1(R1)            INCREMENT TO HALFWORD BOUNDARY
         $SLOC R1                  SET NEW LOCATION COUNTE VALUE
         EJECT
*              SCAN FOR LITERAL OR END OF OPERAND FIELD               *
IALNOK   EQU   *
         $CALL SCANEQ              SCAN TO = OR LBANK
         CLI   0(RA),C' '          ARE WE TO END OF STATEMENT
         BE    IARETA              YES,WE'RE DONE
         CLI   0(RA),C'='          MAKE SURE IT IS =
         BNE   IARETA              IF NOT, ERROR, BUT DON'T FLAG NOW
         SPACE 1
*              LITERAL FOUND- HAVE IT SAVED, WITH POINTER VALUES.
         $CALL LTENT1              CALL TO ENTER LITERAL
         LTR   RB,RB               WAS LITERAL OK
         BNZ   IAERROR             NO IT WASN'T,BRANCH
         MVI   IARCLENG,RC$LEN2    SET LENGTH TO LENGTH WITH LITERAL
         ST    RC,IARCLITA         SAVE ADDRESS OF LITERAL
         SPACE 1
IARETA   EQU   *                   EXIT LABEL
         AIF   (&$COMNT EQ 0).IANOCOM       SKIP IF NO COMMENT CHEK
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MACHINE INSTRUCTION COMMENT COUNTING ROUTINE.          *
*        IF THE COMMENT CHECK OPTION IS SPECIFIED, EITHER BY THE      *
*   COMNT PARM OPTION, OR BY ACCOUNT NUMBER SETTING,  THIS CODE       *
*   COUNTS THE NUMBER OF MACHINE INSTRUCTIONS, AND ALSO COUNTS THE    *
*   APPROXIMATE NUMBER OF THEM WHICH HAVE A COMMENT OF 4 OR MORE      *
*   NONBLANK CHARACTERS.  (SEE VARIABLES AVMACHIN  AND  AVCOMNTN).    *
*   THESE VALUES ARE INITIALIZED TO ZERO IN OUINT1, AND ARE USED IN   *
*   OUEND2 TO MAKE SURE THAT STUDENT PROGRAMMERS PUT A GIVEN AMOUNT   *
*   OF COMMENTS ON THEIR INSTRUCTIONS (I.E. &$COMNT PER CENT OF THE   *
*   MACHINE INSTRUCTIONS MUST HAVE COMMENTS ARE ELSE THE PROGRAM WILL *
*   NOT BE EXECUTED.).                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AVTAGS2,AJOCOMNT    IS COMMENT CHK IN EFFECT
         BZ    IARETA2             NO, SO DON'T CHECK THEM
         SPACE 1
         LA    R1,1                SET R1 FOR USEFUL VALUE, BXHING
         AR    RA,R1               BUMP SCAN PTR BEYOND POSSIBLE '(LIT)
         LH    RE,AVMACHIN         GET CURRENT # MACHINE INSTS
         AR    RE,R1               INCREMENT FOR THIS INSTRUCTION
         STH   RE,AVMACHIN         STORE UPDATED COUNTER BACK
         SPACE 1
*              SCAN TO FIND THE COMMENT FIELD, IF ANY.
         CLI   0(RA),C' '          IS NEXT CHAR BLANK
         BNE   *+8                 NO-JUMP OUT, COMMENT BEGUN
         BXH   RA,R1,*-8           BUMP SCAN PTR BY 1, LOOP
         SPACE 1
         L     RE,AVSOLAST         GET @ BLANK BEFORE AFTER QUOTE
         LR    RD,R1               MOVE A 1 TO REG RD FOR BXLE INCREM
         LA    R1,4                ***** # NONBLANKS REQUIRED *********
         SPACE 1
*              LOOP UNTIL EITHER AFTERQUOTE FOUND OR 4 NONBLANKS.
         CLI   0(RA),C' '          IS THIS A BLANK
         BNE   *+12                NO, SKIP TO BCT TO COUNT IT
         BXLE  RA,RD,*-8           INCREMENT SCN PTR, LOOP BACK
         B     IARETA2             FELL THRU - SHORT COMMENT-DON'T COUN
         BCT   R1,*-8              COUNT # CHARS, LOOP TO BXLE
         SPACE 1
*              LEGITAMATE COMMENT FILED-GIVE PROGRAMMER CREDIT FOR IT.
         LH    RE,AVCOMNTN         GET ACCUMULATD # COMMENTS
         AR    RE,RD               INCREMENT BY 1 FROM RD
         STH   RE,AVCOMNTN         RESTORE UPDATED # COMMENTS
         SPACE 1
.IANOCOM ANOP
*              POINT TO OUR RCB AND RETURN TO MAIN CONTROL.
IARETA2  LA    RC,IARCB            SHOW @ OF OUR RCB FOR MAINPROG
         LA    RD,1(R3)            GET TOTAL LENGTH IN RD FOR RETURN
IARET    $RETURN RGS=(R14-R3)      RETURN TO CALLER
         SPACE 1
* * * * * INDIVIDUAL ERROR SECTIONS
IAERROR  $CALL ERRTAG              CALL ERROR FLAGGING ROUTINE
         B     IARETA              GO RETURN
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
IALENGS  DC    HL1'1,3,3,5'        LENGTH-1 BYTES FOR EACH INST TYPE
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
*        RCB ENTRIES FOR IAMOP1                                       *
IARCB    DS    0D                  RECORD CODE BLOCK
IARCLENG DS    C                   LENGTH OF RCB
IARCLOC  DS    AL3                 LOCATION COUNTER VALUE (BY MOCON1)
IARCTYPE DS    C                   PRIMARY TYPE BYTE
IARCHEX  DS    C                   HEX OPCODE FOR MACH INSTS
IARCMASK DS    C                   MASK/LITERAL TAGS/ALIGNMENT
IARCLQ   DS    C                   FOR L'*
IARCLITA DS    A                   ADDRESS OF A LITERAL,IF EXISTS
IARCEND  DS    0C                  END OF RCB ENTRY
         DROP  RAT,R13             CLEAR USING
         TITLE '*** IBASM1 - ASSEMBLER OPCODES - PASS 1 ***'
**--> CSECT: IBASM1   1   ASSEMBLER INSTRUCTIONS - PASS 1 . . . . . . .
*.       THIS MODULE IS 1 OF THE 2 PASS 1,LEVEL 2 ROUTINES OF THE     .
*.       ASSIST ASSEMBLER.  IT PERFORMS ALL PROCESSING FOR ASSEMBLER  .
*.       INSTRUCTIONS DURING PASS 1, INCLUDING SCANNING, MODIFYING    .
*        LOCATION COUNTERS, AND BUILDING AN RCODBLK FOR THE STMT.     .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF OPCODE CONTROL TABLE ENTRY FOR OPCODE USED        .
*.       EXIT CONDITIONS                                              .
*.  RB = 0    NO ERRORS WERE ENCOUNTERED                              .
*.     = >0   ERRORS WERE FOUND IN STATEMENT                          .
*.  RC = ADDRESS OF RECORD CODE BLOCK (RCB)                           .
*.  RD = LENGTH OF CODE - TO BE ADDED AFTER ALIGNMENT DONE            .
*.       CALLS CCCON1,CODTL1,ERRLAB,ERRTAG,ESCSEC,ESENX1              .
*.       CALLS EVALUT,LTDMP1,SDBCDX,SDDTRM                            .
*.       USES DSECTS: AVWXTABL,CNCBLOCK,IBPSECT,OPCODTB,SYMSECT       .
*.       USES MACROS: $AL2,$ALIGR,$CALL,$CKALN,$GLOC,$RETURN,$SAVE    .
*.       USES MACROS: $SDEF,$SLOC,IBPRTAB                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
IBASM1   CSECT
         $DBG  90,*
         SPACE 1
* * * * * REGISTER ALLOCATION AND USAGE IN IBASM1 * * * * * * * * * * *
*   R0 = WORK REGISTER. SCAN POINTER SAVED HERE BY SOME INTERNAL SUBRS*
*   R1 = 1     USEFUL VALUE, IN ODD REG FOR BXH'ING SCAN POINTER.     *
*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0).                        *
*   R3(IBLN)   LENGTH TO BE ADDED TO LOCATION COUNTER (INIT = 0).     *
*   R4(IBLB)   @ IN SYMBOL TABLE OF LABEL.  IF NO LABEL, = 0.         *
*   R5(IBLR)   INTERNAL LINKAGE REGISTER.                             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
IBLN     EQU   R3                  LENGTH REGISTER
IBLB     EQU   R4                  LABEL POINTER,IF EXISTS
IBLR     EQU   R5                  LINKAGE REGISTER
IBMAXCON EQU   10                  MAXIMUM NUMBER OF CONSTANTS
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R6),BR=R13,SA=IBSAVE
         SPACE 1
*              INITIALIZATION - SET UP REGISTERS,GET OPCODTB CODES    *
         LA    R1,1                SET UP USEFUL VALUE IN R1
         SR    R2,R2               CLEAR REGISTER
         SR    IBLN,IBLN           SET LENGTH TO 0
         STM   R2,IBLN,IBRCB       ZERO OUT RCB
         USING OPCODTB,RC          NOTE OPCODE TABLE
         MVC   IBRCTYPE(3),OPCTYPE MOVE CODE BYRS OVER
         MVC   IBRCLQ,OPCMASK      PLACE DEFAULT LENGTH ATTRIBUTE IN
         DROP  RC                  NO LONGER NEEDED
         MVI   IBRCLENG,RC$LEN     MOVE IN NORMAL LENGTH-1 OF RCB
         SR    RB,RB               CLEAR, TYPICAL NO ERROR SETTING
         SPACE 1
*              TEST FOR LEGALITY/FLAG START INSTRUCTION               *
         TM    AVTAGS1,$IBSTAR1+$IBDSEC1     CHECK TAGS1 SETTING
         BNZ   IBALAB              ALREADY SET OR SHOUDLN'T-SKIP
         TM    IBRCHEX,$IBSTAR1    IS THIS A START PREVENTER
         BZ    IBALAB              NO IT ISN'T,DON'T FLAG
         OI    AVTAGS1,$IBSTAR1    FLAG THE START NO LONGER GOOD
         CLI   AVCESDID,0          DOES A CSECT EXIST
         BNE   IBALAB              SOMETHING EXIST-BRANCH
         MVI   AVCESDID,2          UNITIATED PRIV CODE STARTS NOW
         OI    AVTAGS1,$IBPRCD1    SHOW PRIV CODE EXISTS NOW
         SPACE 1
*              CHECK FOR LABEL WHERE NONE ALLOWED,OR MISSING WHERE REQ*
IBALAB   L     IBLB,AVLABPT        GET ADDRESS OF LABEL,IF EXISTS
         LTR   IBLB,IBLB           SEE IF A LABEL EXISTS
         BNZ   IBANOLB             SKIP IF LABEL EXISTS
         TM    IBRCHEX,IBNENAM     NO NAME EXISTS,SEE IF IT IS REQUIRED
         BZ    IBAOPTST            NO NAME NEEDED,SKIP TO CHEK OPERAND
         LA    RB,$ERNONAM         NAME IS NEEDED,DOESN'T EXIST-ERR
         B     IBERLAB             GO FLAG ERROR-NO LABEL
         SPACE 1
IBANOLB  TM    IBRCHEX,IBNONAM     IT HAS A LABEL,SEE IF IT IS ALLOWED
         BZ    IBAOPTST            NAME IS ALLOWED,GO CHK OPERAND
         LA    RB,$ERILLAB         LABEL NOT PERMITTED
         $CALL ERRLAB              FLAG ERROR AT LABEL FIELD
         SPACE 1
*              IF OPERAND IS OMITTED, CHECK THAT ITS NOT ILLEGALLY SO *
IBAOPTST CLI   0(RA),C' '          SEE IF OPERAND EXISTS
         BNE   IBALEV2             OPERAND EXISTS-JUMP
         TM    IBRCHEX,IBOMOP      MAKE SURE OPERAND MAY BE OMITTED
         BZ    IBERNOPR            MISSING OPERAND-ILLEGAL
         SPACE 1
IBALEV2  IC    R2,IBRCTYPE         GET TYPE BYTE FOR TABLE
         LH    R14,IBAJUMP-$IB(R2) GET OFFSET TO INDIVIDUAL SECTION
IBASMJ   B     IBASMJ(R14)         BRANCH TO INDIVIDUAL SECTION
         SPACE 1
IBARBZER SR    RB,RB               CLEAR RB TO SHOW NO ERRORS
IBASCAN  EQU   *                   NO LONGER NEED SCAN TO END OF FIELDS
* * * * * EXIT CODE                                                   *
IBRETA   LR    RD,IBLN             PLACE LENGTH TO BE ADDED TO LOCCNTR
         LA    RC,IBRCB            PLACE ADDRESS FOR MAIN PROG
IBRET    $RETURN RGS=(R14-R6)
         SPACE 2
* * * * * CCW * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBCCW    EQU   *
         LA    RB,$ERNOIMP         NOT CURRENTLY IMPLEMENTED
         B     IBERRORA            HAVE THIS FLAGGED FOR NOW
         EJECT
* * * * * CNOP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = # BYTES TO BE GENERATED (=0,2,4,6).            *
IBCNOP   $GLOC IBLB                GET VALUE OF LOCATION COUNTER
         $CKALN 1,IBCNOL           CHECK HALFWORD ALIGNMENT
         AR    IBLB,R1             INCREMENT LOCCNTR BY 1 TO ALIGN
         $SLOC IBLB                SET LOCCNTR VALUE
         SPACE 1
IBCNOL   BAL   IBLR,IBCNEV         CALL EXPRESSION EVAL, CHECK ROUTINE
         STC   RC,AVFWORK1         STORE VALUE,SO CAN TEST FOR ODD
         TM    AVFWORK1,1          WAS THE VALUE ODD
         BZ    *+8                 SKIP AND CONTINUE IF EVEN-OK
         BCT   RA,IBERICNO         MOVE SCAN PTR BACK, GO FLAG ERROR
         CLI   0(RA),C','          IS DELIM COMMA
         BNE   IBERIND             NO,ERROR
         AR    RA,R1               ADD 1 TO SCAN POINTER
         LR    IBLN,RC             SAVE 1ST OPERAND HERE
         SPACE 1
         BAL   IBLR,IBCNEV         CALL EXPRESSION EVAL, CHECK
         SR    RC,R1               GET 2ND OPERAND - 1
         C     RC,AWF3             WAS 2ND OPERAND ORIGINALLY 4
         BE    *+12                YES, SKIPP IF OK
         C     RC,AWF7             WAS 2ND OPERAND ORIGINALLY 8
         BNE   IBERICNO            NO, SO ERROR
         NR    IBLB,RC             GET LAST 2-3 BITS OF LOCCNTR
         LA    IBLN,1(IBLN,RC)     GET 1ST OPERAND + 4 OR 8
         SR    IBLN,IBLB           GET (1ST OPRND + 4 OR 8) - LOCNTR
         NR    IBLN,RC             GET LAST 2-3 BITS OF RESULT = LENGTH
         STC   IBLN,IBRCMASK       STORE RESULTING LENGTH FOR PASS 2
         CLI   0(RA),C' '          WAS THIS ALL
         BE    IBRETA              YES, SO DONE
         B     IBERIND             NO, INVALID DELIMIETER
         SPACE 1
IBCNEV   $CALL EVALUT              CALL EXPRESSION EVALUATOR
         LTR   RB,RB               WAS EXPRESSION OK
         BNZ   IBERRORA            NO ,ERROR, FLAG IT
         LTR   RD,RD               WAS EXPRESSION ABSOLUTE
         BCR   Z,IBLR              YES, RETURN TO CALLING SECTION
         B     IBERICNO            NO, CNOP ERROR
         SPACE 2
* * * * * CSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBCSECT  SR    RB,RB               SHOW THIS IS A CSECT CALL
         B     IBESCALL            GO TO COMMON CODE SECTION
         SPACE 2
* * * * * DROP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBDROP   EQU   IBASCAN             NOTHING TO DO THIS PASS
         AIF   (&$DEBUG).IBNOD1    SKIP IF NOT DEBUG MODE
         SPACE 1
* * * * * DEBUG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBDEBUG  MVC   IBRCHEX,0(RA)       GET 1ST CHAR,EITHER 1 OR 2
         LA    RA,2(RA)            BUMP SCAN POINTER PAST 1, OR 2,
         BAL   IBLR,IBEVCALL       CALL EXPRESSION EVALUATOR FOR VALUE
         STC   RC,IBRCMASK         SAVE THE BYTE CODE
         CLI   IBRCHEX,C'2'        WAS THIS PASS 2 ONLY
         BE    IBRETA              YES,DON'T CHANGE AVDEBUG
         STC   RC,AVDEBUG          SAVE THE NEW FLAG INTO DEBUG
         B     IBRETA              GO RETURN
.IBNOD1  ANOP
         EJECT
* * * * * DC - DS * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = # OPERANDS IN DC STMT (= 1 TO IBMAXCON).       *
*        ADDS TO RCODBLK 1 CNCBLOCK FOR EACH OPERAND.                 *
*        SETS RCLQ = LENGTH ATTRIBUTE - 1 OF 1ST OPERAND.             *
*        **NOTE** MUST CHECK FOR MISSING QUOTE, ELSE ABEND MAY OCCUR. *
         SPACE 1
* * * * * REGISTER ALLOCATION FOR DC-DS PROCESSING  * * * * * * * * * *
*   R0 = CURRENT NUMBER OF OPERANDS PROCESSED                         *
*   R1 = 1                         CONSTANT FOR BXHING                *
*   R2 = CURRENT LENGTH-1 OF IBRCB,WILL BE INCREMENTED BY DC'S        *
*   RW(IBLN) = LOCATION COUNTER FOR BEGINNING OF STATEMENT            *
*   RX = 0 ==> DS, 4 ==> DC STATEMENT.                                *
*   RY = MAXIMUM # OPERANDS ALLOWED(= IBMAXCON IF DC, = 4095 IF DS).  *
*   RZ = ADDRESS OF CURRENT CNCBLOCK PART OF IBRCB BEING FILLED(DC'S) *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
IBDC     LA    RX,4                SHOW THIS IS A DC
         LA    RZ,IBRCONS          ADDRESS OF 1ST CONST BLOCK
         LA    RY,IBMAXCON         MAXIMUM NUMBER OF CONSTANTS ALOOWED
         B     IBDCDS              BRANCH TO COMMON CODE
         SPACE 1
IBDS     SR    RX,RX               CLEAR TO SHOW CODTL1 THIS IS DS
         LA    RY,4095             PUT HUGE NUMBER SO WON'T FLAG EXCED
IBDCDS   SR    R0,R0               CLEAR TO SHOW NO OPERANDS RIGHT NOW
         IC    R2,IBRCLENG         GET CURRENT LENGTH OF IBRCB
         $GLOC IBLN                GET THE LOCATION COUNTER
         SPACE 1
*              LOOP FOR 1 OR MORE OPERANDS.                           *
IBDSCAL  LR    RB,RX               SHOW CODTL1 WHETHER DC OR DS
         $CALL CODTL1              CALL THE OPERAND PROCESSOR
         LTR   RB,RB               WAS THERE AND ERROR
         BNZ   IBDCENDA            IF RB›=0, ==> ERROR
         SPACE 1
         USING CNCBLOCK,RC         RC POINTS AT CODTL1'S CNCBLOCK
         IC    RB,CNCLEN           GET LENGTH-1 OF CONSTANT
         TM    CNCTYP,$CNALN       IS ALIGNMENT REQUIRED
         BZ    IBDSLQ              DO NOT ALIGN UNLESS NEEDED
         $ALIGR IBLN,RB
IBDSLQ   BXH   R0,R1,IBDSADD       SKIP FOLLOWING 2 STMTS IF NOT 1ST
         $SLOC IBLN                SET LOCATION COUNTER FOR STMT START
         STC   RB,IBRCLQ           SAVE THE LENGTH ATTRIBUTE
IBDSADD  AR    IBLN,RE             ADD THE TOTAL LENGTH OVER
         LTR   RX,RX               IS THIS A DS OR A DC
         BZ    IBDSOPA             IT IS A DS, BRANCH
         CR    R0,RY               COMPARE # OF OPS TO MAXIMUM ALLOWED
         BH    IBDCEXT             IF EXCEEDS, FLAG ERROR
         SPACE 1
IBDCMOV  MVC   0(CNC$LEN,RZ),CNCBLOCK        MOVE BLOCK OVER(DC ONLY)
         LA    R2,CNC$LEN(R2)      INCREMENT THE LENGTH
         LA    RZ,CNC$LEN(RZ)      BUMP POINTER OF NEXT EMPTY SPACE
IBDSOPA  CLI   0(RA),C' '          IS THIS THE END
         BE    IBDCHEKA            GO TO CHECK FOR MISSING DELIMT
         CLI   0(RA),C','          IS DELIM ACTUALLY A COMMA
         BNE   IBDCINDL            NO, BAD USER, GET HIM
         BXH   RA,R1,IBDSCAL       BUMP SCAN POINT AND GET NEXT OPERAND
         SPACE 1
IBDCHEKA C     RA,AVSOLAST         COMPARE TO @ BLANK BEFORE AFTER '
         BL    IBDCEND             LOW, THEREFOR NO MISSING '
         LA    RB,$ERNODLM         MISSING ', ERROR-SHOW IT
         B     IBDCENDA            HAVE IT FLAGGED, , NO ASMBLY
         SPACE 1
IBDCINDL LA    RB,$ERINVDM         INVALID DELIMITER-SHOW IT
         B     IBDCENDA            GO FLAG ERROR
IBDCEXT  LA    RB,$ERDCEXT         TOO MANY CONSTANT OPERANDS IN DC
IBDCENDA $CALL ERRTAG              HAVE THE ERROR FLAGGED
         LA    R2,RC$LEN           GET REGULAR LENGTH-1 BACK
IBDCEND  S     IBLN,AVLOCNTR       GET DIFFERENCE, TO BE ADDED TO LOCCN
         STC   R0,IBRCMASK         SAVE NUMBER OF OPERANDS
         STC   R2,IBRCLENG         PLACE THE LENGTH-1 BACK INTO RCB
         B     IBRETA              RETURN
         DROP  RC
         SPACE 2
* * * * * DSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBDSECT  LA    RB,4                SHOW ESD ROUTINE THIS IS DSECT
         B     IBESCALL            GO CALL ROUTINE
         SPACE 2
* * * * * EJECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBEJECT  EQU   IBRETA              NOTHING TO DO
         SPACE 2
* * * * * END PLUS COMMON END-LTORG CODE* * * * * * * * * * * * * * * *
IBEND    LR    R0,RA               SAVE SCAN POINTER
         $CALL LTDMP1              CALL LITERAL DUMP
         LR    IBLN,RA             MOVE LENGTH REQUIRED OVER
         TM    AVTAGS1,$IBDSEC1    ARE WE IN A DSECT RIGHT NOW
         BO    IBEND1              SKIP OVER IF SO,AVLOCHIH IS OK
         SPACE 1
         A     RA,AVLOCNTR         ADD LOCATION COUNTER TO INCREMENT
         C     RA,AVCSHIH          IS THIS LARGE THAN PREVIOUS LARGEST
         BNL   *+8                 YES,SO USE JUST COMPUTED VALUE
         L     RA,AVCSHIH          BACKWARDS ORG,USE PREVIOUS HIGHEST
         ST    RA,AVLOCHIH         SAVE HIGHEST VALUE OF CODE,USE IT
IBEND1   LR    RA,R0               RESTORE THE SCAN POINTER
         B     IBARBZER            GO ZERO RB TO SHOW OK
         SPACE 2
* * * * * ENTRY * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBENTRY  SR    RB,RB               SHOW ESENX1 THIS IS ENTRY
         B     IBENEXCL            GO CALL ROUTINE
         SPACE 2
* * * * * EQU * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCEQU = VALUE OF SYMBOL (IF EVALUATION COMPLETE).       *
*        ALSO ZEROS AVLABPT SO THAT MPCON0 DOESNT REDEFINE SYMBOL.    *
IBEQU    EQU   *                   SHOW LENGTH 4> THAN USUAL
         MVC   AVLABPT,AWZEROS     ZERO IT, MOCON1 WILL THINK NO LABEL
         BAL   IBLR,IBEVCALL       CALL GEN EXPRESSION EVALUTAR
         BNZ   IBERRORA            NOGOOD, QUIT,FLAG ERROR.
         SPACE 1
         USING SYMSECT,IBLB        NOT SYMBOL TABLE USING
         CLI   0(RA),C' '          RIGHT DELIMITER
         BNE   IBERIND             NO,ERROR
         $SDEF RC,RD,RE            DEFINE THE SYMBOL
         DROP  IBLB                ERASE USING
         ST    RC,IBRCEQU          PLACE VALUE FOR LATER USE
         MVI   IBRCLENG,RC$LEN2    SHOW LENGTH 4> THAN USUAL
         B     IBRETA              GO RETURN
         SPACE 2
* * * * * EXTRN * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBEXTRN  LA    RB,2                SHOW ESENX1 THIS IS EXTRN CALL
IBENEXCL $CALL ESENX1              CALL EXTRN-ENTRY ROUTINE
         LTR   RB,RB               WERE THERE ERRORS
         BZ    IBRETA              NO ERRORS-QUIT
         B     IBERRORA            GO HAVE ERROR FLAGGED AND QUIT
         SPACE 2
* * * * * LTORG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBLTORG  EQU   IBEND               USE SAME CODE. LTDMP1 ALIGNS LOCNTR.
         SPACE 2
* * * * * ORG * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBORG    CLI   0(RA),C' '          WAS OPERAND OMITTED
         BE    IBORGOM             YES,OMITTED
         BAL   IBLR,IBEVCALL       GET EXPRESSION EVALUATED
         BNZ   IBERRORA            IF ERROR,RETURN
         CLI   0(RA),C' '          MAKE SURE ENDS WITH ' '
         BNE   IBERIND             INVALID DELIM
         IC    R2,AVCESDID         GET ESDID
         CR    R2,RD               MAKE SURE THEY ARE SAME            7
         BNE   IBERORG             WRONG SECTION - BAD ORG
         C     RC,AVCSLOW          IS IT LOWER THAN LOWEST LEGAL VALUE
         BL    IBERORG             LOWERR THAN LOWEST LEGAL, ERROR
         SPACE 1
         L     R0,AVCSHIH          GET HIGHEST VALUE
         C     R0,AVLOCNTR         IS HIGHEST NOT HIGHER THAN LOCCNTR
         BNL   IBORGH1             SKIP IF HIGH VALUE>=LOCCNTR
         $GLOC R0                  GET CURRENT LOCCNTR
IBORGH1  CR    R0,RC               IS HIGHEST VALUE LESS THAN NEW
         BNL   IBORGH2             NO IT ISNT,BRANCH
         LR    R0,RC               NEW HIGHEST VALUE
IBORGH2  ST    R0,AVCSHIH          STORE NEW HIGH VALUE
         $SLOC RC                  SET LOCATION COUNTER
         B     IBRETA              GO RETURN
         SPACE 1
*              OMITTED OPERAND IN ORG==>SET TO HIGHEST UNUSED VALUE   *
IBORGOM  $GLOC R0                  GET LOCCNTR
         C     R0,AVCSHIH          COMPARE TO HIGHEST VALUE
         BNL   IBORGO1             SKIP IF LOCCNTR HIGH
         L     R0,AVCSHIH          USE HIGHEST VALUE
IBORGO1  ST    R0,AVCSHIH          SET POSSIBLY NEW HIGHEST LOCCNTR VAL
         $SLOC R0                  SET NEW LOCCNTR VALUE
         B     IBRETA              GO RETURN
         EJECT
* * * * * PRINT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = VALUE OF PRINT CODE TO BE SET BY PRINT.        *
*        ALSO IMMEDIATELY SETS AVPRINT1 TO CORECT PRINT CONTROL.      *
IBPRINT  LA    RE,IBPLAST          ADDRSS OF LAST IN TABLE
         SR    RD,RD               CLEAR FOR INSERTIONS
         MVI   AVFWORK1,0          INIT=0 FOR CORRECTNESS TESTS
         MVC   IBRCMASK,AVPRINT1   COPY CURRENT PRINT STATUS
         SPACE 1
*              LOOP TO LOOK UP NEXT OPERAND IN LEGAL PRINT LIST       *
IBPLOOP  LA    R14,IBPTAB          @ BEGINNING OF TABLE
         USING IBPSECT,R14         NOTE THE TABLE
         SPACE 1
IBPLOOPA IC    RD,IBPLENG          GET LENGTH-1 OF ENTRY
         STC   RD,*+5              STORE L-1 INTO CLC INST
         CLC   0($CHN,RA),IBPOPR   COMPARE INCOMING OPERAND
         BNE   IBPLOOPB            GO TO BOTTOM IF NOT
         SPACE 1
         MVC   *+7(1),IBPVO        COPY BIT TO CHECK INTO TM NEXT
         TM    AVFWORK1,$          TEST: SEE IF 2 OF SAME OR CONTRADCT
         BNZ   IBERINVF            INVALID
         OC    AVFWORK1(1),IBPVO   OR IN: RECORD FOR COMPATIBLITY TST
         OC    IBRCMASK,IBPVO      SET DESIRED BIT DEFINITELY = 1
         XC    IBRCMASK,IBPVX      XOR: SET BIT OFF IF REQUIRED OFF
         MVC   AVPRINT1,IBRCMASK   KEEP AVPRINT1 SAME VALUE AS RCMASK
         LA    RA,1(RD,RA)         BUMP SCP TO DELIMITER
         CLI   0(RA),C' '          IS THIS THE END
         BE    IBRETA              YES,RETURN
         CLI   0(RA),C','          CHECK DELIMITER
         BNE   IBERIND             ERROR IF NOT
         BXH   RA,R1,IBPLOOP       GO BACK FOR NEXT OP,BUMP SCPTR
         SPACE 1
IBPLOOPB LA    R14,IBPOPR-IBPSECT+1(R14)     INCREMENT BY RITHT OFFSET
         BXLE  R14,RD,IBPLOOPA     INCREMENT WITH VARIABLE LENGTH
         B     IBERINVF            IF FALSS THRU==>UNRECOGNIZABLE
         DROP  R14                 CLEAR USING
         SPACE 2
* * * * * SPACE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = # LINES TO BE SPACED. OMITTED OPERAND ==> 1.   *
IBSPACE  CLI   0(RA),C' '          IS OPERAND OMITTED
         BE    IBRETA              SKIP CALL,LEAVE IBRCMASK=1
         $CALL SDDTRM              GET VALUE FOR SPACING
         LTR   RB,RB               WAS VALUE OK
         BNZ   IBERRORA            BRANCH IF ERROR
         LTR   RC,RC               WAS VALUE ›=0
         BZ    IBRETA              RETURN IF =0,LEAVE 1 AS SPACE VALUE
         STC   RC,IBRCMASK         STORE VALUE FOR PASS 2.
         B     IBRETA              RETURN
         EJECT
* * * * * START PLUS COMMON START,DSECT,CSECT CODE  * * * * * * * * * *
*        SETS RCMASK = NEW CURRENT ESDID NUMBER.                      *
*        START SETS ITS VALUE INTO AVLOCLOW&AVFENTER FOR INIT.        *
IBSTART  TM    AVTAGS1,$IBSTAR1    IS START NO LONGER ALLOWED
         BO    IBSTERR             BRANCH-ERROR
         SR    RC,RC               CLEAR FOR VALUE IF OMITTED
         CLI   0(RA),C' '          WAS OPERAND OMITTED.
         BE    IBESCALA            YES,GO CALL SED ROUTINE
         $CALL SDBCDX              GET SELF-DEFINING TERM
         LTR   RB,RB               WAS VALUE OK
         BP    IBERRORA            BRANCH, ERROR CODE IN RB
         BM    IBERINVF            RB=-4, NOT SELF-DEFTERM, ERROR
         CLI   0(RA),C' '          MAKE SURE DELIMITER OK
         BNE   IBERIND             INVALID DELIMITER
         LA    RB,7                FOR DBLWD ALIGNMENT
         $ALIGR RC,RB              ALIGN STARTING VALUE TO *8
         ST    RC,AVLOCLOW         THIS IS NOW LOWEST LOC(UT WANTS IT)
         ST    RC,AVFENTER         STORE FOR BEGINNING @
IBESCALA LA    RB,2                SHOW ESD ROUTINE THIS IS A START
         SPACE 1
*              COMMON CODE - START, DSECT, CSECT.
IBESCALL LR    R0,RA               SAVE SCAN POINTER
         $CALL ESCSEC              CALL FOR CSECT,DSECT,OR START
         OI    AVTAGS1,$IBSTAR1    FLAG NO MORE STARTS
         LR    RA,R0               RESTORE SCAN POINTER
         LTR   RB,RB               CHECK FOR ERRPRS
         BNZ   IBERLAB             GO HAVE ERRORS FLAGGED IF NEEDED
         MVC   IBRCMASK,AVCESDID   KEEP NEW ESDID VALUE
         B     IBRETA              RETURN
         SPACE 2
* * * * * TITLE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCMASK = LENGTH OF TITLE OPERAND FIELD.                 *
IBTITLE  CLI   0(RA),C''''         MAKE SURE DELIM OK
         BNE   IBERIND             ERROR IF NOT
         AR    RA,R1               BUMP SCAN POINTER BY 1
         $CALL CCCON1              HAVE THE TITLE CHECKED
         LTR   RB,RB               WAS THERE ERROR
         BNZ   IBERRORA            YES,GO FLAG IT
         CLI   1(RA),C' '          MAKE SURE ENDS WITH QUOTE BLANK
         BNE   IBERIND             BRANCH IF ERROR
         C     RA,AVSOLAST         WAS IT >= @ BLANK BEFORE AFERQUOTE
         BNL   IBERNODL            TOO LONG, MISSING DELIMITER
         SR    RC,R1               S RC,=F'1' GET LENGTH-1 AS NEEDED
         STC   RC,IBRCMASK         SAVE THE LEGNTH REQUIRED
         BXH   RA,R1,IBRETA        BUMP SCAN POINTER AND RETURN
         SPACE 2
* * * * * USING * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IBUSING  EQU   IBASCAN             NOTHING TO DO THIS PASS
         EJECT
* * * * * INDIVIDUAL ERROR EXITS                                      *
IBERNODL LA    RB,$ERNODLM         MISSING DELIMITER ERROR
         B     IBERRORA            GO FLAG AND EXIT
IBERICNO LA    RB,$ERICNOP         ILLEGAL CNOP OPERAND COMBINATION
         B     IBERRORA            GO TO FLAG
IBERIND  LA    RB,$ERINVDM         INVALID DELIMITER
         B     IBERRORA            SET ERROR CODE AND RETUN
IBERINVF LA    RB,$ERINVF          ILLEGAL FIELD OF SOME SORT
         B     IBERRORA            GO FLAG IT
IBERNOPR LA    RB,$ERNOOPR         MISSING OPERAND
         B     IBERRORA            GO PUT OUT ERROR CODE
IBERORG  LA    RB,$ERILORG         ILLEGAL ORG
         B     IBERRORA            GO FLAG IT
IBSTERR  LA    RB,$ERSTART         SHOW BAD START, FALL THRU-IBERRORA
         SPACE 2
* * * * * ALL ERRORS EXCEPT LABEL ERRORS                              *
IBERRORA $CALL ERRTAG              HAVE LABEL FLAGGED
         B     IBRETA              RETURN TO CALLER
         SPACE 2
* * * * * LABEL ERRORS                                                *
IBERLAB  $CALL ERRLAB              CALL LABEL ERROR
         B     IBRETA              RETURN TO CALLER
         SPACE 2
*              INTERNAL SUBROUTINES.
         SPACE 2
* * * * * EXPRESSION EVALUATION - CALL TO EVALUT                      *
IBEVCALL $CALL EVALUT              CALL EXPRESSION EVALUATOR
         LTR   RB,RB               SET THE CONDTION CODE
         BR    IBLR                RETURN TO CALLER
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
* * * * * 2ND LEVEL JUMP TABLE FOR IBASM1                             *
IBAJUMP  $AL2  IBASMJ,(IBUSING,IBDROP,IBSTART,IBCSECT,IBDSECT,IBENTRY,I#
               BEXTRN,IBEQU,IBDC,IBDS,IBCCW,IBTITLE,IBEJECT,IBSPACE,IBP#
               RINT,IBORG,IBLTORG,IBCNOP,IBEND),-2
         AIF   (&$DEBUG).IBNOD2    SKIP IF NOT DEBUG MODE
         DC    AL2(IBDEBUG-IBASMJ)           OFFSET TO DEBUG ROUTINE
.IBNOD2  ANOP
         SPACE 1
* * * * * PRINT OPERAND TABLE                                         *
IBPTAB   IBPRTAB ON,$IBPON         SET BIT ON
         IBPRTAB OFF,$IBPON,*      SET 'ON' BIT OFF
         IBPRTAB GEN,$IBPGEN       SERT GEN BIT ON
         IBPRTAB NOGEN,$IBPGEN,*   SET 'GEN' BIT OFF
         IBPRTAB DATA,$IBPDAT      SET DATA BIT ON (ONLY COMPATIBLITY)
         IBPRTAB NODATA,$IBPDAT,*  SET 'DATA' BIT OFF
IBPLAST  EQU   *-1                 @ LAST BYTE FOR LIMIT
         SPACE 1
         LTORG
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
* * * * * RCB AREA FOR IBASM1                                         *
IBRCB    DS    0D                  RECORD CODE BLOCK
IBRCLENG DS    C                   LENGTH OF RCB
IBRCLOC  DS    AL3                 LOCATION COUNTER VALUE
IBRCTYPE DS    C                   OPCODE TYPE
IBRCHEX  DS    C                   2ND LEVEL TAGS-LABLE&OPERAND
IBRCMASK DS    C                   FROM OPCTYPE=LENGTH ATTRIBUTE
IBRCLQ   DS    C                   BYTE FOR LENGTH ATTRIBUTE L'*
IBRCEQU  DS    0F                  VALUE OF AN EQUATE SYMBOL
IBRCONS  DS    (IBMAXCON)CL(CNC$LEN)         CONSTANT CODE BLOCKS
         SPACE 1
* * * * * DSECT USED BY PRINT ROUTINE FOR TABLE LOOKUP  * * * * * * * *
IBPSECT  DSECT
IBPLENG  DS    C                   NUMBER OF CHARACTERS IN CODE
IBPVO    DS    B                   BIT TO BE OR'D IN: BIT TO TEST
IBPVX    DS    B                   BIT TO BE XOR'D IN, RESET =0 IF NEED
IBPOPR   DS    C                   OPERAND CHARACTERS(ON,OFF,ETC)
         DROP  RAT,R13             CLEAN UP USING SIUTATION
         TITLE '*** ICMOP2 - MACHINE INSTRUCTIONS - PASS 2 ***'
**--> CSECT: ICMOP2   2   MACHINE OPERATIONS - PASS 2 . . . . . . . . .
*.       THIS MODULE IS 1 OF THE 2 PASS 2,LEVEL 2 ROUTINES IN THE     .
*.       ASSIST ASSEMBLER.  IT PROCESSES ALL MACHINE INSTRUCTIONS IN  .
*.       THE SECOND PASS, SCANNING ALL THE OPERAND FIELDS AND CREATING.
*.       THE OBJECT CODE FOR THEM.  IT ALSO DOES THE SETUP REQUIREED  .
*.       FOR OUTPT2 TO PRODUCE THE PRINTED LISTING. THIS ROUTINE HAS  .
*.       MANY SPECIAL-CASE SECTIONS WHICH ARE USED FOR SPEED, AND     .
*.       WHICH COULD USE LESS SPACE IF CALLS TO THE GENERAL EXPRESSION.
*.       EVALUATOR EVALUT WERE USED INSTEAD.                          .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF RECORD CODE BLOCK(RCODBLK) FOR STATEMENT          .
*.  RE = ADDRESS OF RECORD SOURCE BLOCK(RSBLOCK) FOR STATEMENT        .
*.       CALLS BRDISP,ERRTAG,EVALUT,LTGET2,SDBCDX,SDDTRM              .
*.       CALLS SDBCDX,SYFIND,OUTPT2,UTPT2                             .
*.       USES MACROS: $AL2,$CALL,$GLOC,$RETURN,$SAVE,ICT              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
ICMOP2   CSECT
         $DBG  90,*
ICB1D1   EQU   X'10'               (ICYFLAG) - ==> B(D) OPERAND FORMAT
ICBX2    EQU   X'08'               (ICYFLAG) ==> D(X,B) FORMAT,NOT L
ICBSOPN2 EQU   X'04'               (ICYFLAG) ==> B(D) STORED INTO OPN2
ICBSEA2  EQU   X'02'               (ICYFLAG) ==> @ GOES TO ICYEA2
ICYXLFN  EQU   X'80'               (ICYF2) ==> X OR L FIELD PRESENT
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         USING RCODBLK,RC          NOTE POINTER TO CODE BLOCK
         EJECT
* * * * * OVERALL REGISTER USAGE FOR ICMOP2 * * * * * * * * * * * * * *
*   R1 = @ REGISTER-HI-ORDER BYTE =0. OFTEN USED TO SAVE SCAN PTR RA  *
*   R2 = BYTE REGISTER - HI-ORDER 3 BYTES = 0. USED FOR INSERTIONS,ETC*
*   RW = LEVEL 1 LINK REGISTER                                        *
*   RX = LEVEL 3 LINK REGISTER                                        *
*   RY = 1    USED FOR INCREMENTING,DECREMENTING REGS,BXH'ING SCAN PTR*
*   RZ = LEVEL 2 LINK REGISTER                                        *
*   RA = SCAN POINTER REGISTER - @ NEXT CHARACTER TO BE EXAMINED      *
*   RB = USUAL PLACE FOR AN ESDID TO BE KEPT,IF THERE IS ONE          *
*   RC = NORMAL PARAMATER REGISTER FOR RETURN OF A CONVERTED VALUE    *
*   R13= @ SAVEAREA AND BASE REGISTER                                 *
*   R14-R15   LOCAL WORK REGISTERS, EXTERNAL LINK REGISTERS           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $SAVE RGS=(R14-R6),BR=R13,SA=ICMOSAVE
         MVC   ICRCB(RCLITEQ-RCODBLK+4),RCODBLK        MOVE TO FREE RC
         DROP  RC                  NO LONGER USING,WILL NEED EVERY REG
         LM    R0,R3,AWZEROS       ZERO OUT THESE REGS
         STM   R0,R3,ICYBLOCK      ZERO OUT BLOCK FOR OBJ CODE
         LA    RY,1                INITIALIZE REGISTER
         MVC   ICYOP(2),ICRCHEX    MOVE OPCODE-MASK OVER
         AIF   (NOT &$XREF).NOXRF15                                   A
         IC    R2,ICYOP            GET OPCODE                         A
         IC    R2,ICXRTAB(R2)      GET FLAG BYTE FROM TABLE           A
         STC   R2,AVXRMDFT         STORE FLAG BYTE IN FLAG            A
.NOXRF15 ANOP
         NI    ICYR1R2,X'F0'       REMOVE 2ND NIBBLE,LEAVING MASK ONLY
         SPACE 1
*              OBTAIN TYPE INFORMATION,INSTRUCTION SECTION @. TAKE
*              BRANCH TO ONE OF LEVEL 0 INSTRUCTION PROCESSORS.
         IC    R2,ICRCTYPE         GET TYPE BYTE
         LH    R14,ICOJUMP(R2)     GET OFFSET @ FOR LEVEL 0 ROUTINE
         SRL   R2,1                DIVIDE BY 2 FOR BYTE INDEX
         IC    R2,ICTTAB(R2)       GET FLAG BYTE BELONGING TO TYPE
         STC   R2,ICYFLAG          STORE FLAG BYTE FOR LATER USE
ICMOJ    B     ICMOJ(R14)          TAKE BRANCH TO INSTRUCTION TYPE SUBR
* * * * * JUMP OFFSET TABLE FOR INSTRUCTION TYPE PROCESSORS (LEVEL 0) *
ICOJUMP  $AL2  ICMOJ,(ICRRM,ICRXM,ICRR,ICRX,ICRS,ICRSH,ICSI,ICSS,ICSS2,#
               ICRSO,ICSPC),-2
         EJECT
* * * * * INDIVIDUAL ERROR EXITS                                      *
ICNUNDEF LA    RB,$ERUNDEF         UNDEFINED SYMBOL
         LR    RA,R1               GET A SCAN POINTER BACK
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNEABS  LA    RB,$ERNEABS         AN ABSOLUTE TERM OR EXPRESSION NEEDD
         B     ICNERROR            GO FLAG ERROR
ICNBADSY LA    RB,$ERINVSY         INVALID SYMBOL
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNLITER LA    RB,$ERTLIT          ILLEGAL USE OF LITERAL
         B     ICNERROR            GO FLAG ERROR
ICNRELC  LA    RB,$ERRELOC         RELOCATABILITY ERROR
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNEXGTB AR    RA,RY               BUMP SCAN PTR TO ALLOW FOR BCT
ICNEXGTA LA    RB,$EREXGTA         EXPRESSION TOO LARGE
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNADDR  LA    RB,$ERADDR          ADDRESSIBILITY ERROR
         BCT   RA,ICNERROR         MOVE SCAN PTR BACK,GO FLAG ERR
ICNILLEG CLI   0(RA),C' '          WAS ILLEGAL A BLANK (MISSING)
         BNE   ICNINVDM            NO,SOMETHING ELSE ILLEFAL
ICNNOOPR LA    RB,$ERNOOPR         MISSING OPERAND
         B     ICNERROR            GO HAVE IT FLAGGED
ICBLANK  CLI   0(RA),C' '          FINAL CHECK FOR BLANK
         BE    ICOUTPT             BRANCH OUT IF OK
ICNINVDM LA    RB,$ERINVDM         INVALID DELIMITER (MOST COMMON)
ICNERROR $CALL ERRTAG              HAVE ERROR FLAGGED
ICNERRF  MVC   ICYEA1(14),AWZEROS  ZERO THE INSTRUCTION OUT
         SPACE 1
* * * * * ICOUTPT - COMMON EXIT - PRODUCE OBJECT CODE,PRINT STMT      *
ICOUTPT  $GLOC RA                  GET LOCATION COUNTER FOR UTPUT2
         LA    RC,ICYOP            @ OBJECT CODE FOR UTPUT2
         IC    R2,ICRCLQ           GET LENGTH-1 OF STATEMENT CODE
         LR    RD,R2               MOVE OVER FOR LENGTH-1 FOR UTPUT2
         LR    RE,RY               SET RE = 1 ==> PRODUCE 1 OF OBJECT
         $CALL UTPUT2              HAVE OBJECT CODE LOADED
         SPACE 1
*              SET UP AND CALL PRINTER ROUTINE                        *
         LA    RB,$OUMACH          SHOW THIS IS A MACHINE INSTRUCTION
         LA    RC,ICYBLOCK         GET @ BLOCK
         LR    RD,R2               MOVE LENGTH-1 WHERE OUTPT2 WANTS IT
         $CALL OUTPT2              CALL OUTPUT ROUTINE
         AIF   (NOT &$XREF).ICNXRF1  SKIP IF NO CROSS-REF OPTION      J
         MVI   AVXRTYPE,AVXRFTCH   MAKE FETCH TYPE NORMAL FOR REST    J
.ICNXRF1 ANOP
ICRET    $RETURN RGS=(R14-R6)
         EJECT
* * * * * ICRR - NORMAL RR INSTRUCTIONS,EXTENDED MNEM RR'S - LEVEL - 0*
ICRRM    BAL   RZ,ICREG            GO GET REG 2 FIELD
         EX    RC,ICOIR            HAVE IT ORED IN
         B     ICBLANK             GO CHECK FOR BLANK
ICRR     EQU   *                                                      A
         CROSSET   1               SET FLAG M/F FIRST OPRND           A
         BAL   RW,ICWREG1          GO GET FIRST REGISTER              A
         CROSSET   2               SET FLAG M/F 2ND OPERAND           A
         BAL   RZ,ICREG            GO GET 2ND REGISTER
         EX    RC,ICOIR            HAVE IT OR'D INTO R2 FIELD
         AIF   (NOT(&$FLOTA OR &$FLOTAX OR &$S370A)).ICRRNF
         TM    ICRCMASK,IAB        SHOULD R2 BE EVEN?
         BNO   ICBLANK             NO, SO BRANCH TO CHECK FOR BLANK
         TM    ICYR1R2,X'01'       WAS THRE AN ODD REG IN 2ND POSITION
         BZ    ICBLANK             NO, SO OK -BRANCH
         BAL   RZ,ICWODDR          HAVE ODD REG FLAGGED
.ICRRNF  B     ICBLANK             GO TO CHECK FOR BLANK AND QUIT
         SPACE 2
* * * * * ICRX - NORMAL RX AND RX EXTENDED MNEMONICS - LEVEL - 0      *
ICRX     EQU   *                                                      A
         CROSSET  1                SET FLAG FOR 1ST OPERAND           A
         BAL   RW,ICWREG1          CALL FOR 1ST REG                   A
ICRXM    EQU   *                   ENTRY FOR RX EXTENDED MNEMONICS
         CROSSET  2                SET FLAG 2ND OPERAND               A
         BAL   RW,ICXBD            GO GET THE OPERAND
         TM    ICYF2,ICYXLFN       WAS INDEX SPECIFIED
         BZ    *+10                SKIP OVER IF SO
         OC    ICYR1R2,ICYXL       PLACE X2 FIELD IN,IF IT WAS SPECIFIE
         B     ICBLANK             GO CHECK FOR BLANK
         SPACE 2
* * * * * ICRS - REGULAR NON-SHIFT RS INSTRUCTIONS - LEVEL - 0        *
ICRS     EQU   *                                                      A
         CROSSET  1                SET 1ST OPERAND FLAG               A
         BAL   RW,ICWREG1          GET 1ST REGISTER                   A
         CROSSET 2 SET SECOND OPERAND                                 A
         BAL   RZ,ICREG            GET 2ND REG
         EX    RC,ICOIR            HAVE 2ND REG PLACED ALSO
         CLI   0(RA),C','          IS DELIM WHAT IT SHOULD BE
         BNE   ICNINVDM            NO-ERROR
         CROSSET 3                 SET 3RD OPERAND                    A
         BXH   RA,RY,ICRSH1        BUMP PAST , AND GO GET D2-B2
         SPACE 2
* * * * * ICRSH - RS SHIFT INSTRUCTIONS - LEVEL - 0                   *
ICRSH    EQU   *                                                      A
         CROSSET  1                SET FLAG                           A
         BAL   RW,ICWREG1          GET 1ST REGISTER                   A
         CROSSET  2                SET SECOND OPERAND                 A
ICRSH1   BAL   RW,ICXBD            GET BASE-DISP (COMMON RS CODE)
         B     ICBLANK             GO TEST FR BLANK AND QUIT
         EJECT
* * * * * ICSI - NORMAL SI INSTRUCTIONS - OP D1(B1),I2 - LEVEL - 0    *
ICSI     EQU   *                                                      A
         CROSSET  1                1ST OPERAND                        A
         BAL   RW,ICXBD            GET B(D) FIELD                     A
         CLI   0(RA),C','          CHECK FOR COMMA
         BNE   ICNINVDM            BRANCH IF NOT-ILLEGAL
         AR    RA,RY               BUMP SCAN POINTER PAST ,
         SPACE 1
ICSI1    LR    R1,RA               SAVE SCAN PTR, IN CASE NOT JUST SDT
         BAL   RX,ICSDTRM          GO GET SDT IF IT IS ONE
         BM    ICSI2               NO IT WAN'T-GIVE UP AND USE EXPRESSI
         CLI   0(RA),C' '          WAS THIS ALL (WE HOPE SO)
         BE    ICSI3               YES,WE GOT BY WITH SIMPLE CASE
         LR    RA,R1               NOT SD TERM BY SELF-RESTORE SCP
         SPACE 1
ICSI2    BAL   RX,ICEXP            GO GET EXPRESSION
         BP    ICNEABS             EXPRESSION HAD TO BE ABSOLUTE-ERROR
ICSI3    CL    RC,AWFXFF           WAS EXPRESSION SMALL ENOUGH
         BH    ICNEXGTA            NO-TOO BIG
         STC   RC,ICYR1R2          SAVE I2 FIELD
         B     ICBLANK             GO CHECK FOR BLANK AND FINISH UP
         SPACE 1
ICSS     EQU   *                                                      A
* * * * * ICSS - SS INSTRUCTIONS WITH 1 LENGTH - LEVEL - 0            *
         CROSSET  1                1ST OPERAND FLAG SET               A
         BAL   RW,ICXBD            GET 1ST BASE DISPLACEMENT          A
         BAL   RX,ICULEN           PICK UP LENGTH IN R2
         STC   R2,ICYR1R2          SAVE INTO INSTRUCTION
         CLI   0(RA),C','          IS DELIMITER OK
         BNE   ICNINVDM            NO,ERROR
         AR    RA,RY               BUMP SCAN POINTER PAST ,
         SPACE 1
         OI    ICYFLAG,ICB1D1+ICBSOPN2+ICBSEA2         SET FOR 2ND OP
         CROSSET 2                 2ND OPERAND                        A
         BAL   RW,ICXBD            GO PROCESS 2ND OPERAND
         B     ICBLANK             GO CHECK FOR BLANK AND QUIT
         SPACE 1
* * * * * ICSS2 - SS INSTRUCTIONS WITH 2 LENGTHS - LEVEL - 0          *
ICSS2    EQU   *                                                      A
         CROSSET 1                 SET 1ST OPERAND FLAG               A
         BAL   RW,ICXBD            GET 1ST BASE DISPLACEMNT           J
         BAL   RX,ICULEN           GO GET LENGTH
         C     R2,AWF15            MAKE SURE LEGAL SIZE
         BH    ICNEXGTA            TOO BIG-BRANCH
         SLL   R2,4                SHIFT OVER FOR L1 POSITION
         STC   R2,ICYR1R2          SAVE THE LENGTH
         CLI   0(RA),C','          CHECK DELIMITER
         BNE   ICNINVDM            ERROR IF NOT
         AR    RA,RY               BUMP SCAN POINTER
         SPACE 1
         AIF   (NOT &$S370A).ICSS2 SKIP IF NOT ASSEMBLING S/370'S
         CLI   ICYOP,240           IS THIS A SRP INSTRUCTION?
         BE    ICSS2A              YES - BRANCH
         SPACE 2
.ICSS2   ANOP
         OI    ICYFLAG,ICBSOPN2+ICBSEA2      RESET FLAGS FOR 2ND OPRND
         MVI   ICYF2,0             REZERO RETURN CODES FLAG
         CROSSET 2                 SET FLAGS                          A
         BAL   RW,ICXBD            GET 2ND LENGTH-BASE-DISP
         BAL   RX,ICULEN           GO PICK UP LENGTH IN R2
         C     R2,AWF15            MAKE SURE LEGAL SIZE
         BH    ICNEXGTA            NO-TOO BIG-ERROR
         EX    R2,ICOIR            HAVE THE LENGTH OR'D IN
         B     ICBLANK             GO CHECK FOR BLANK AND QUIT
         AIF   (NOT &$S370A).ICSS2A SKIP IF NOT ASSEMBLIN& S/3 0'S
         SPACE 2
* * * * * ICSS2A - SPECIAL CODE FOR SRP (S/370) INSTRUCTION
ICSS2A   OI    ICYFLAG,ICB1D1+ICBSOPN2+ICBSEA2       SET FOR 2ND OPND
         CROSSET 2                 SET 2ND OPERAND FLAG               A
         BAL   RW,ICXBD            GO PROCESS 2ND OPERAND
         CLI   0(RA),C','          CHECK DELIMITER
         BNE   ICNINVDM            ERROR IF NOT
         AR    RA,RY               BUMP SCAN POINTER
         BAL   RZ,ICREG            GO GET IMMEDIATE FIELD
         CH    RC,AWH10            IS IMMEDIATE TO LARGE?
         BNL   ICNEXGTA            YES - ERROR
         EX    RC,ICOIR            HAVE IMMEDIATE OR'ED IN
         B     ICBLANK             GO CHECK FOR BLANK AND QUIT
.ICSS2A  ANOP
         EJECT
* * * * * ICRSO - SPM,SVC, AND IO-TYPE SI'S - LEVEL - 0               *
ICRSO    EQU   *
         CLI   ICYOP,X'0A'         IS IT SVC
         BE    ICSI1               YES, USE IMMEDIATE FIELD PART OF SI
         CLI   ICYOP,X'01'         IS THIS AN XOPC INSTRUCTION        M
         BE    ICSI1               YES, USE IMMEDIATE FIELD PART OF SIM
         CLI   ICYOP,X'04'         IS IT  SPM
         BE    ICRSO1              YES,GO PROCESS
*              FALL THRU ==> ODD SI INSTRS (TS, SIO, TCH, ETC)
         MVI   ICYFLAG,$ICBEA1+ICB1D1        CHANGE FLAG FOR SEMI-SI
         AIF   (NOT &$P370A).ICRSO IF NO PRIVELEGED S/370'S, BRANCH
         MVO   ICYR1R2(2),ICRCMASK MOVE IN MASK DIGIT FOR S/370
.ICRSO   ANOP
         BAL   RW,ICXBD            GET BASE-DISPLACEMENT
         B     ICBLANK             GO FOR BLANK AND QUIT
         SPACE 1
ICRSO1   BAL   RZ,ICREG            SPM HAS 1 REG,GO GET IT
         SLL   RC,4                SHIFT OVER FOR RIGHT POSITION
         STC   RC,ICYR1R2          STORE R1 FIELD
         B     ICBLANK             LOOK FOR BLANK AND QUIT
         SPACE 1
* * * * * ICSPC - SPECIAL INSTRUCTIONS - XREAD,XPRNT,XPNCH - LEVEL - 0*
ICSPC    EQU   *                   FOR SPECIAL IO INSTRUCTIONS
         AIF   (NOT &$XIOS).ICXIO  SKIP IF THESE SPECIALS NOT ALLOWED
         MVI   ICSPCDUM+1,0        MAKE A NOOP
         CLI   ICYR1R2,X'60'       WAS IT XDUMP
         BNE   ICSPCO              SKIP IF NOT XDUMP IN 1ST PLACE
         MVI   ICSPCDUM+1,X'F0'    SHOW XDUMP WITH ARGUMENTS
         CLI   0(RA),C' '          ARE THERE ANY OPERANDS
         BNE   ICSPCO              YES, ALREADY SET RIGHT, CONTINUE
         MVI   ICYOP,X'E1'         CHANGE OPCODE E0 TO E1-REGS XDUMP
         B     ICOUTPT             GO OUTPUT CODE
         SPACE 1
ICSPCO   BAL   RW,ICXBD            GET ADDRESS OPERAND
         TM    ICYF2,ICYXLFN       WAS INDEX REG USED
         BZ    *+10                NO,SKIP IT
         OC    ICYR1R2,ICYXL       PUT LENGTH IN
         CLI   0(RA),C' '          WAS THIS ALL
         BNE   ICSPC1              SKIP IF LENGTH FOLLOWS
         IC    R2,ICYR1R2          GET MASK VALUE
         SRL   R2,5                SHIFT OVER FOR BYTE INDEXING
         IC    R2,ICSPCDLT(R2)     GET DEFAULT LENGTH VALUE
         STH   R2,ICYOPN2          SAVE THE VALUE IN D(B) FIELD
         B     ICOUTPT             GO HAVE PRINTED AND RETURN
         SPACE 1
ICSPC1   CLI   0(RA),C','          MAKE SURE DELIM WHAT IT'S SUPPOSED T
         BNE   ICNINVDM            ERROR - BRANCH
         AR    RA,RY               BUMP SCAN POINTER
         CLI   0(RA),C'('          IS THIS REGISTER FORM
         BNE   ICSPC2              NO,MUST BE SPECIFIED LENGTH
ICSPCDUM BC    $CHN,ICNINVDM       XDUMP WITH ARGS DOESN'T ALLOW (R) FM
         AR    RA,RY               BUMP SCAN POINTER PAST (
         BAL   RZ,ICREG            GET REGISTER VALUE
         SLL   RC,4                SHIFT FOR POSITION
         STC   RC,ICYOPN2          SAVE INTO B POSTION
         CLI   0(RA),C')'          IS DELIMITER RIGHT
         BNE   ICNINVDM            NO-ERROR-BRANCH
         BXH   RA,RY,ICBLANK       BUMP SCP AND GO CHK BLANK          P
         SPACE 1
ICSPC2   BAL   RX,ICEXP            GO GET EXPRESSION
         BNZ   ICNEABS             SHOULD BE ABSOLUTE-ERR IF NOT
         STH   RC,ICYOPN2          SAVE THE VALUE
         B     ICBLANK             GO CHK BLANK AND FINISH UP
ICSPCDLT DC    AL1(80,133,80,4,1)  DFLT L'S-READ,PRNT,PUNCH,DUMP,LIMD
.ICXIO   ANOP
         EJECT
* * * * * ICWREG1 - PROCESS 1ST REGISTER OR MASK - LEVEL - 1          *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHAR OF 1ST REGISTER                     *
*   RW = RETURN ADDRESS OF CALLING SECTION                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICWREG1  BAL   RZ,ICREG            GET 1ST REG CONVERTED
         SLL   RC,4                SHIFT OVER
         STC   RC,ICYR1R2          STORE INTO AREA
         TM    ICRCMASK,IAA        MUST THE REGISTER BE EVEN
         BZ    ICWR1               NO,GO FINISH UP
         TM    ICYR1R2,X'10'       MAKE SURE REG IS EVEN
         BZ    ICWR1               REG IS OK,SKIP
         LA    RZ,ICWR1            SET UP RETURN @ TO CONTINUE
         SPACE 1
*              ICWODDR MAY BE CALLED TO FLAG ODD FLT-PT REG - LEVEL-2 *
ICWODDR  SR    RA,RY               DECREMENT SCAN PTR BY 1 TO REG
         LA    RB,$ERODDRG         REGISTER IS ODD-FLAG IT
         $CALL ERRTAG              FLAG ERROR
         BXH   RA,RY,0(RZ)         PUT SCAN PTR FORWARD 1, RETURN TO CL
         SPACE 1
ICWR1    CLI   0(RA),C','          IS REG FOLLOWED BY ,
         BNE   ICNINVDM            NO-ERROR
         BXH   RA,RY,0(RW)         BUMP PAST , AND RETURN
         EJECT
* * * * * ICXBD - PROCESS 1 OPERAND - D(B) OR D(X-L,B) - LEVEL - 1    *
*        ENTRY CONDITIONS                                             *
*   RW = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*        ICYEA1 OR ICYEA2 WILL BE FILLED IN. ICYOPN1 OR ICYOPN2 WIIL  *
*        BE FILLED IN AND A LENGTH OR INDEX REGISTER WILL BE STORED   *
*        INTO ICYFL, IF PRESENT.                                      *
*        **NOTE** MOST OF THE CODE IN THIS SECTION IS DESIGNED TO     *
*   MAKE NORMAL CASE PROCESSING AS FAST AS POSSIBLE. THE PROGRAM      *
*   ATTEMPTS TO FIND ONE OF SEVERAL TYPICAL OPERAND FORMATS, AND IF   *
*   SUCCESSFULL, PROCESSES THEM QUICKLY. IF NOT, IT GIVES UP AND      *
*   USES THE EXPRESSION EVALUATOR EVALUT INSTEAD. THE ROUTINE WILL    *
*   CONVERT ANY OF THE FOLLOWING SORTS OF OPERANDS WITHOUT CALLING    *
*   THE EVALUT ROUTINE :                                              *
*   1. FOR OPERANDS OF FORM S OR D(B) - IF D IS A DECIMAL # OR        *
*        SELF-DEFINING TERM BY ITSELF, AND (B) IS PRESENT OR NOT, OR  *
*   IF S IS EITHER A SYMBOL BY ITSELF, OR SYMBOL+# OR SYMBOL-#, WHERE *
*        SYMBOL IS EITHER AN ORDINARY SYMBOL OR LOCATION COUNTER REF  *
*   2. FOR OPERANDS OF FORM S(XL) OR D(XL,B) OR D(XL) OR D(,B)        *
*        SYMBOL IS EITHER AN ORDNIARY SYMBOL OR LOCATION COUNTER REFE *
*        IF S OR D ARE AS DESCRIBED BY 1., AND IF XL DESIGNATES A     *
*   LENGTH, IT IS GIVEN BY A DECIMAL #.                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (&$OPTMS LT 2).ICX2 SKIP IF MEMORY TIGHT
ICXBD    ST    RA,ICZ1RA           SAVE THE SCAN POINTER IF BACK-UP NEE
         IC    R2,0(RA)            GET THE FIRST CHARACTER OF OPERAND
         IC    R2,AWTDECT(R2)      GET INDEX VALUE FROM TABLE
         C     R2,AWF12            MAKE SURE NOT ILLEGAL
         BH    ICNILLEG            ILLEGAL CHAR-BRANCH
         LH    R14,ICXJUMP(R2)     GET THE OFFSET @
ICXBDJ   B     ICXBDJ(R14)         JUMP TO RIGHT BEGINNING SECTION
* * * * * JUMP OFFSET TABLE FOR 1ST CHARACTER FOR ICXBD ROUTINE       *
ICXJUMP  $AL2  ICXBDJ,(ICXDEC,ICNINVDM,ICXSDT,ICXSYM,ICXLOC,ICXLIT,ICXL#
               PARN)
.ICX2    AIF   (&$OPTMS GE 2).ICX3 SKIP IF NOT GREAT MEMORY OPT
ICXBD    CLI   0(RA),C'='          CHECK FOR LITERAL (MEMORY OPT CODE)
         BNE   ICXDEXP2            NOT LITERAL, GO CALL EXPRESSION EVAL
.ICX3    ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        THE FOLLOWING CODE SECTIONS PROCESS AN OPERAND SPECIFIED AS  *
*   A LITERAL, A RELOCATABLE SYMBOL OR EXPRESSION, OR AN EXPLICIT     *
*   DISPLACEMENT.  EXPLICIT BASES,LENGTHS, OR INDEX REGISTERS ARE     *
*   PROCESSED BY ICXABS-ICXRELOC                                      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
* * * * * ICXLIT - PROCESS A LITERAL OPERAND - 1ST CHAR WAS =         *
ICXLIT   TM    ICRCMASK,IAL2       IS LITERAL ALLOWED
         BZ    ICNLITER            NO,GO FLAG IT
         CLI   ICRCLENG,RC$LEN2    DOES A LITERAL @ EXIST
         BNE   ICNERRF             NO,BUT IT WAS ALREADY FLAGGED-QUIT
         L     RC,ICRCLITA         GET @ LITERAL IN LITERAL TABLE
         $CALL LTGET2              GET THE PROGRAM @ LITERAL(IN RC)
         STC   RD,ICYLQT           STORE LENGTH-1 ATTRIBUTE
         NI    ICYF2,255-ICYXLFN   ZERO TO SHOW NO EXPLICIT LENGTH
         BAL   RZ,ICGBD            HAVE IT CONVERTED TO B-D FORM
         BR    RW                  RETURN TO CALLER OF ICXBD
         AIF   (&$OPTMS LT 2).ICX4 SKIP IF MEMORY OPTMIZED
         SPACE 1
* * * * * ICXSDT - CHECK SELF-DEFING TERM OR L' - 1ST CHAR WAS BCLX   *
ICXSDT   CLI   1(RA),C''''         IS ' 2ND CHAR OF OPERAND
         BNE   ICXSYM              NO,SO GO PROCESS SYMBOL
         BAL   RX,ICSDTRM          GO GET SELF-DEFINING TERM
         BZ    ICXDEC1             IF WAS SDTERM-ENTER DEC ROUTINE
         B     ICXDEXP2            IF NOT,MUST HAVE BEEN L'-GO EVAL EXP
         SPACE 1
* * * * * ICXLOC - PROCESS LOCATION COUNTER REFERENCE - 1ST CHAR WAS **
ICXLOC   $GLOC RC                  GET CURRENT LOCATION COUNTER VALUE
         SR    RB,RB               CLEAR FOR INSERTION
         IC    RB,AVCESDID         GET CURRENT ESDID
         IC    RE,ICRCLQ           GET LENGTH ATTRIBUTE,IF NEEDED
         BXH   RA,RY,ICXSYM1       BUMP SCAN POINTER AND CONTINUE
         EJECT
* * * * * ICXSYM - PROCESS SYMBOL REFERENCE - 1ST CHARACTER WAS ALPH  *
ICXSYM   BAL   RX,ICSYM            GO GET SYMBOL VALUE,ETNRY
         USING SYMSECT,RA          NOTE USING, RC=VALUE,RB=ESDID
         IC    RE,SYLENG           GET LENGTH ATTRIBUTE
         DROP  RA                  NO LONGER USING
         LR    RA,R1               RESTORE SCAN POINTER
         SPACE 1
*              COMMON CODE - SYMBOL AND LOCATION COUNTER REFERENCE.
ICXSYM1  STC   RE,ICYLQT           SAVE LENGTH ATTRIBUTE IN CASE NEEDED
         IC    R2,0(RA)            GET NEXT CHARACTER
         IC    R2,AWTDECT(R2)      GET INDEX VALUE OF CHARACTER
         C     R2,AWF12            COMPARE TO VALUE FOR (
         BNL   ICXSTEST            SKIP IF ( COMMA OR BLANK-DONE
         SPACE 1
         MVI   ICXSUBAD,X'1A'      MAKE INSTRUCTION AN AR
         CLI   0(RA),C'+'          IS IT PLUS LIKE WE HOPE
         BE    ICXSINC             YES,GO HAVE# CONVERTED
         CLI   0(RA),C'-'          IS IT -
         BE    ICXSUB              YES,GO SET INSTRUCTION
         LTR   RB,RB               WAS THE SYMBOL ABSOLUTE
         BZ    ICXDEXP1            YES,SO GO EVALUATE WHOLE EXPRESSION
         B     ICNRELC             NO,RELOCATABLE TERM IN * OR /
         SPACE 1
ICXSUB   MVI   ICXSUBAD,X'1B'      MAKE INSTRUCTION SUBTRACT TEMPORARIL
ICXSINC  AR    RA,RY               BUMP THE SCAN POINTER
         CLI   0(RA),C'0'          ARE WE LOOKING AT DECIMAL #
         BL    ICXDEXP1            IF NOT,GIVE UP AND USE EXPRESION EVA
         STM   RB,RC,ICZ1A         SAVE THES REGS
         BAL   RX,ICDNUM           GET # CONVERTED
         IC    R2,0(RA)            GET NEXT CHAR
         IC    R2,AWTDECT(R2)      GET INDEX VALUE
         C     R2,AWF12            IS IT ( COMMA OR BLANK
         BL    ICXDEXP1            NO,SO MUST BE MORE COMPLEX EXPR-JUMP
         SPACE 1
         LR    RD,RC               SAVE VALUE OF DECIMAL #
         LM    RB,RC,ICZ1A         GET SYMBOL VALUE-ESDID BACK
ICXSUBAD AR    $CHN+RC,RD          ADD OR SUBTRACT VALUE(OPCODE CHNG)
ICXSTEST LTR   RB,RB               WAS SYMBOL ABSOLUTE OR RELOCATABLE
         BZ    ICXABS              SKIP IF ABSOLUTE(UNLIKELY)
.ICX4    ANOP
         SPACE 2
* * * * * ICXRELOC - RELOCATABLE OPERAND- CONVERT TO D(B) FORM        *
*        ON ENTRY TO ICXRELOC, RC = ADDRESS, RB = ESDID OF ADDRESS    *
ICXRELOC BAL   RZ,ICGBD            GET BASE-DISPLACEMENT FORM
         TM    ICYFLAG,ICB1D1      WAS THERE ONLY BASE-DISPLACEMENT
         BCR   O,RW                YES RETURN TO CALLER
         CLI   0(RA),C'('          WAS INDEX OR LENGTH SPECIFIED
         BCR   NE,RW               NO,SO JUST RETURN TO CALLER
         AR    RA,RY               BUMP SCAN POINTER PAST (
         BAL   RZ,ICX2L12          GO GET INDEX OR LENGTH AS NEEDED
         STC   RC,ICYXL            SAVE THIS VALUE FOR LATER
         CLI   0(RA),C')'          IS ) THERE LIKE IT SHOULD BE
         BNE   ICNINVDM            NO-ERROR
         BXH   RA,RY,0(RW)         BUMP SCAN POINTER AND RETURN
         EJECT
         AIF   (&$OPTMS LT 2).ICX6 SKIP IF MEMORY OPT
* * * * * ICXDEC - PROCESS DECIMAL DISPLACEMENT - 1ST CHAR WAS DEC #  *
ICXDEC   BAL   RX,ICDNUM           GO GET DECIMAL #
ICXDEC1  CLI   0(RA),C'('          IS NEXT (
         BE    ICXABSA             YES,BASE-X-L FOLLOW
         CLI   0(RA),C' '          IS BLANK NEXT
         BE    ICXABSB             YES,GO INTO ABS SECTION
         CLI   0(RA),C','          IS THIS FIRST OPERAND OF SEVERAL
         BE    ICXABSB             YES,GO FINISH OFF
         SPACE 1
*        FALLS THRU==> NOT SIMPL,HOPED-FOR DECIMAL #-USE EXPRESSION EV*
ICXDEXP1 L     RA,ICZ1RA           GET THE ORIGINAL SCAN POINTER BACK
ICXLPARN EQU   *                   1ST CHAR WAS ( ==> PROCESS EXPRESSN
.ICX6    ANOP
ICXDEXP2 BAL   RX,ICEXP            GO GET EXPRESSION EVALUATED
         STC   RE,ICYLQT           SAVE THIS AS LENGTH ATTRIBUTE
         BNZ   ICXRELOC            CC SET BY ESDID TEST-GO TO RELOC IF
         SPACE 2
* * * * * ICXABS - OPERAND DISPLACEMENT EXPLICIT - GET X,L,B,ETC      *
*        ON ENTRY TO ICXABS,ICXABSA,ICXABSB, RC = DISPLACEMENT VALUE  *
ICXABS   CLI   0(RA),C'('          WAS DISPLACEMENT ALONE(PROB SHIFT)
         BNE   ICXABSB             YES,GO FINISH UP
ICXABSA  CL    RC,AWFXFFF          IS DISPLACEMENT > 4095
         BH    ICNEXGTA            DISPLACEMENT TOO LARGE
         ST    RC,ICZ1A            SAVE THE DISPLACEMENT VALUE
         AR    RA,RY               BUMP SCAN POINTER PAST (
         TM    ICYFLAG,ICB1D1      IS THER LENGTH OR INDEX
         BO    ICXABSN             NO-BASE-DISPLACEMENT ONLY
         SPACE 1
         CLI   0(RA),C','          IS L OR X FIELD OMITTED
         BNE   *+8                 SKIP IF NOT OMITTED
         BXH   RA,RY,ICXABSN       BUMP PAST , AND JUMP-OMITTED X OR L
         BAL   RZ,ICX2L12          GET LENGTH OR INDEX
         STC   RC,ICYXL            SAVE LENGTH OR INDEX
         SPACE 1
         SR    RC,RC               CLEAR FOR OMITTED BASE,INCASE IT IS
         CLI   0(RA),C','          IS BASE SPECIFIED
         BNE   ICXABSP             NO,MUST BE OMITTED
         AR    RA,RY               BUMP SCAN POINTER BY 1
ICXABSN  BAL   RZ,ICREG            GET BASE REGISTER
ICXABSP  CLI   0(RA),C')'          IS THE DELIMITER AN ENDING )
         BNE   ICNINVDM            NO-EEROR
         LR    RD,RC               MOVE VALUE OF REGISTER OVER
         SLL   RD,12               SHIFT INTO RIGHT POSITOON
         L     RC,ICZ1A            GET DISPLACEMENT BACK
         AR    RD,RC               PUT BAS AND DISPLACEMENT TOGETHER
         BXH   RA,RY,ICXABSB2      BUMP SCAN PTR PAST ) AND BRANCH
         EJECT
*              ICXABSB ENTERED IF DISPLACEMENT ALONE,NO X,L,B         *
ICXABSB  CL    RC,AWFXFFF          IS DISPLACEMENT > 4095
         BH    ICNEXGTA            NO-ERROR -DISPLACEMNT >4095
         LR    RD,RC               DUPLICATE VALUE OF ADDRESS AS B-D
         SPACE 1
*              ICXABSB2 ENTERED AS COMMON EXIT FROM ICXABS.           *
ICXABSB2 BAL   RX,ICPEA            HAVE ADDRESS CHECKED AND STORED
         BAL   RZ,ICQOPN           HAVE BASE-DISPLACEMENT STORED
         BR    RW                  RETURN TO CALLER
         EJECT
* * * * * ICGBD - GET AND STORE BASE-DISP OF @ - LEVEL - 2  * * * * * *
*   RB = ESDID OF THE @                                               *
*   RC = @ FOR WHICH BASE-DISPLACEMENT IS TO BE FOUND                 *
*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICGBD    BAL   RX,ICPEA            HAVE ACTUAL ADDRESS CHECKED AND SAVE
         LR    R1,RA               SAVE THE SCAN POINTER
         LR    RA,RC               MOVE @ OVER FOR BRDISP CALL
         $CALL BRDISP              GO HAVE BASE-DISPLACEMENT FOUND
         LR    RD,RA               MOVE VALUE OVER TO FALL INTO ICQOPN
         LR    RA,R1               RESTORE THE SCAN POINTER
         LTR   RB,RB               WAS BASE-DISP OK
         BNZ   ICNADDR             NO,ADDRESSIBILITY ERROR
         SPACE 2
* * * * * ICQOPN - STORE BASE-DISPLACEMENT INTO OPN1-OPN2 - LEVEL - 2 *
*        ENTRY CONDITIONS                                             *
*   RD = VALUE TO BE STORED INTO ICYOPN1-OPN2 FIELD
*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICQOPN   TM    ICYFLAG,ICBSOPN2    SHOULD IT GO INTO OPN2
         BO    *+10                YES,SKIP OVER IF OPN2
         STH   RD,ICYOPN1          STORE INTO 1ST OPERAND D(B) FIELD
         BR    RZ                  RETURN TO CALLER
         STH   RD,ICYOPN2          STORE INTO 2ND FIELD (SS INSTS ONLY)
         BR    RZ                  RETURN TO CALLER
         EJECT
* * * * * ICREG - SCAN AND CONVERT A REGISTER VALUE. - LEVEL - 2.     *
*        AS OF VERSION 3.0/A, ANY ABSOLUTE EXPRESSION <= 15 IS       J*
*        ALLOWED FOR REGISTER.  CODE IS ORIENTED TOWARDS NORMAL CASE.J*
*        ENTRY CONDTIONS                                              *
*   RA = @ FIRST CHARACTER OF REGISTER.                               *
*   RZ = RETURN ADDRESS.                                              *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO CHARACTER FOLLOWING REGISTER                 *
*   RC = VALUE OF REGISTER,RIGHT JUSTIFIED.  0 <= RC <= 15            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICREG    LR    R0,RA               SAVE @ OF 1ST CHAR OF EXPRESSION   J
         BAL   RX,ICSDTRM          NOW GO TRY FOR SELF-DEFINING TERM  J
         BZ    ICREGSYC            IF OK, BRANCH TO CHECK DELIM AFTER J
*              NOT SELF-DEF TERM, TRY EXPRESSION OR SYMBOL.           J
         CLI   0(RA),C'('          MAKE SURE NOT EXPRESSION IN PARENS J
         BE    ICREGSYE            WAS EXPRESS IN PARENS-BRANCH OUT   J
         BAL   RX,ICSYM            SYMBOL, GO TO EVALUATE IT          J
         LR    RA,R1               MOVE SCAN POINTER BACK RIGHT
         BNZ   ICNEABS             BRANCH ==> RELOCATABLE REGISTER-ERR
*              MAKE SURE ACTUALLY IS END OF REGISTER FIELD            J
ICREGSYC CLI   0(RA),C','          MOST COMMON ENDING DELIMITER       J
         BE    ICREGSYO            YES, WAS COMMA, DONE, BRANCH OUT   J
         CLI   0(RA),C' '          NEXT COMMON DELIMITER              J
         BE    ICREGSYO            YES, IT WAS BLANK, BRANCH OUT      J
         CLI   0(RA),C')'          LAST CAHNCE, RIGHT PAREN           J
         BE    ICREGSYO            BRANCH OUT, WAS END OF EXPRESSION  J
*              WAS MORE COMPLEX EXPRESSSION, PROCESS IT (R), R+1, ETC.J
ICREGSYE LR    RA,R0               RESTORE ORIGINAL PTR, FROM ICREG.  J
         BAL   RX,ICEXP            CALL GENERAL EXPRESSION EVAL (SLOW)J
         BNZ   ICNEABS             MUST BE ABSOLUTE EXPRESS-BR IF NOT J
ICREGSYO C     RC,AWF15            WAS IT LEGAL SIZE
         BCR   NH,RZ               RETURN TO CALLER IF SMALL ENOUGH
         B     ICNEXGTA            TOO BIG-ERROR-FLAG IT
         EJECT
* * * * * ICX2L12 - FLAG X-L FOUND, MAKE CHOICE OF ROUTINE - LEVEL - 2*
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHAR OF LENGTH OR INDEX                  *
*   RZ = RETURN ADDRESS OF CALLING ROUTINE                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICX2L12  OI    ICYF2,ICYXLFN       NOTE THAT LENGTH OR INDEX FOUND
         TM    ICYFLAG,ICBX2       ARE WE LOOKING FOR AN INDEX REG
         BO    ICREG               SKIP IF REG,FLL THRU TO LENGTH IF NT
         SPACE 2
* * * * * ICLENG - SCAN AND CONVERT A LENGTH.   LEVEL - 2             *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF LENGTH.                     *
*   RZ = RETURN ADDRESS TO CALLING ROUTINE                            *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO DELIMITER FOLLOWING LENGTH, EITHER , OR )    *
*   RC = LENGTH FOR ASSEMBLY(I.E. L-1,EXCEPT L=0).  0 <= RC <= 255    *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$OPTMS LT 2).ICX10         SKIP IF MEMORY OPT
ICLENG   CLI   0(RA),C'0'          DO WE HAVE DECIMAL # (WE HOPE SO!)
         BL    ICLEXP              NO WE DON'T - USE EXPRESSION EVAL
         ST    RA,ICZ2A            SAVE THE SCAN POINTER
         BAL   RX,ICDNUM           GO GET DECIMAL #
         CLI   0(RA),C','          IS IT FOLLOWED BY COMMA
         BE    ICLSIZE             YES- LENGTH WAS JUST DECIMAL #
         CLI   0(RA),C')'          IS DELIM  )
         BE    ICLSIZE             YES,GO CHECK FOR SIZE
         SPACE 1
         L     RA,ICZ2A            GET SCAN POINTER BACK-MORE THAN #
.ICX10   AIF   (&$OPTMS GE 2).ICX11         SKIP IF NOT EMMORY OPT
ICLENG   EQU   *
.ICX11   ANOP
ICLEXP   BAL   RX,ICEXP            GO GET EXPRESSION EVALUATED
         BNZ   ICNEABS             BRANCH==> RELOCATABLE EXP-ERR
ICLSIZE  SR    RC,RY               DECREMENT LENGTH TO LENGTH-1
         BNM   *+6                 SKIP IF ORIG LENGTH ›= 0
         SR    RC,RC               MAKE LENGTH ZERO
         C     RC,AWFXFF           IS THE VALUE <= 255
         BCR   NH,RZ               RETURN IF VALUE OK
         B     ICNEXGTA            LENGTH > 255-DEFINITELY BAD
         EJECT
* * * * * ICPEA - CHECK @ ALIGNMENT, SET UP EA1 OR EA2 - LEVEL - 3    *
*        **NOTE** REGS RA-RD ARE SAFE ACROSS CALL TO ICPEA            *
*        ENTRY CONDITIONS                                             *
*   RC = ADDRESS VALUE TO BE STORED INTO ICYEA1 OR ICYEA2             *
*   RX = RETURN ADDRESS TO CALLING SECTION                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICPEA    ST    RC,ICYEA2           STORE VALUE IN 2ND SLOT ALWAYS
         TM    ICYFLAG,ICBSEA2     DID VALUE ACTUALLY BELONG IN 2ND POS
         BO    *+8                 BRANCH IF WAS 2ND OPERAND
         ST    RC,ICYEA1           STORE VALUE IN FIRST SLOT
         IC    R14,ICRCMASK        GET MAK FOR ALIGNMENT
         N     R14,AWF7            REMOVE ALL BUT LAST 3 BITS
         NR    R14,RC              TEST FOR RIGHT ALIGNMENT
         BCR   Z,RX                IF ZERO==> ALIGNMENT OK
         SPACE 1
*              FALLS THRU ==> ALIGNMENT ERROR MESSAGE                 *
         STM   RB,RD,ICZ3A         SAVE THE VALUES OF REGS
         LA    RB,$ERALIGN         NOTE ALIGNMENT ERROR
         SR    RA,RY               MOVE SCAN PTR BACK 1
         $CALL ERRTAG              HAVE IT FLAGGED
         AR    RA,RY               PUT SCAN PTR BACK WHERE BELONGS
         LM    RB,RD,ICZ3A         RESTORE REGS
         BR    RX                  RETURN TO CALLER
         SPACE 2
* * * * * ICDNUM - SCAN AND CONVERT DECIMAL #.   LEVEL - 3            *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST DIGIT OF DECIMAL #                       *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   RA = @ DELIMITER BEYOND #                                         *
*   RC = VALUE OF #, RIGHT JUSTIFIED.                                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICDNUM   EQU   *
         $CALL SDDTRM              CALL DECIMAL CONVERTER
         LTR   RB,RB               WAS THERE ERROR
         BCR   Z,RX                NO ERRORS,RETURN
         B     ICNERROR            ERROR-GO HAVE IT FLAGGED
         EJECT
* * * * * ICEXP - SCAN AND EVALUATE EXPRESSION - LEVEL - 3            *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF EXPRESSION                  *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   RA = SCAN POINTER TO DELIMITER FOLLOWING EXPRESSION               *
*   RB = ESDID OF EXPRESSION, =0 FOR ABSOLUTE EXPRESSION              *
*   RC = VALUE OF EXPRESSION                                          *
*   RE = LENGTH ATTRIBUTE - 1 OF EXPRESSION                           *
*   CC = SET BY TESTING ESDID                                         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICEXP    $CALL EVALUT              EVALUATE EXPRESSION
         LTR   RB,RB               WAS IT LEGAL
         BNZ   ICNERROR            NO-GO FLAG AND QUIT
         LTR   RB,RD               MOVE ESDID OVER AND SET CC
         BR    RX                  RETURN TO CALLER
         SPACE 2
* * * * * ICSDTRM - GET SELF-DEFINING TERM VALUE - LEVEL - 3          *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER                                *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   RA = UNCHANGED IF NOT SD TERM, SCAN PTR TO DELIMITER IF WAS SDTERM*
*   RC = VALUE OF SELF-DEFING TERM, IF IT WAS ONE                     *
*   CC   SET BY TESTING RB ON RETURN (<0 ==> NOT SD TERM)             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICSDTRM  EQU   *                   DON'T NEED TO SET RB ANYMORE
         $CALL SDBCDX              CALL GENERAL SD TERM PROCESSOR
         LTR   RB,RB               TEST CONDITON
         BCR   NP,RX               RETURN IF EITHER GOOD, OR NOT SD TER
         B     ICNERROR            IT WAS SD TERM, BUT ILLEGAL ONE
         EJECT
* * * * * ICSYM - SCAN AND LOOK UP SYMBOL,RETURN VALUES. LEVEL - 3    *
*        ENTRY CONDITIONS                                             *
*   RA = SCAN POINTER TO 1ST CHARACTER OF SYMBOL                      *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDTIONS                                               *
*   R1 = SCAN POINTER TO DELIMITER FOLLOWING SYMBOL                   *
*   RA = @ SYMSECT ENTRY FOR THE SYMBOL                               *
*   RB = ESDID OF THE SYMBOL                                          *
*   RC = VALUE OF THE SYMBOL                                          *
*   CC = SET BY TESTING THE ESDID OF THE SYMBOL                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICSYM    TRT   0(9,RA),AWTSYMT     SCAN FOR END OF SYMBOL
         BZ    ICNBADSY            BAS SYMBOL - TOO LONG
         LR    RB,R1               MOVE ENDING POINTER OVER
         SR    RB,RA               GET LENGTH OF SYMBOL
         BZ    ICNBADSY            SYMBOL OF 0 LENGTH -ERROR
         $CALL SYFIND              HAVE IT LOOKED UP IN TABLE
         LTR   RB,RB               WAS IT ALREADY THERE
         BNZ   ICNUNDEF            UNDEFINED-NOT IN TABLE
         SPACE 1
         USING SYMSECT,RA          NOTE SYMBOL TABLE USING
         TM    SYFLAGS,$SYDEF      IS SYMBOL DEFINED
         BZ    ICNUNDEF            NOT FLAGGED DEFINED - ERROR
         IC    RB,SYESDID          GET ESDID OF THE SYMBOL
         L     RC,SYVALUE          GET VALUE OF THE SYMBOL
         LTR   RB,RB               SRT CC HERE
         BR    RX                  RETURN TO CALLER
         DROP  RA                  KILL USING FOR SYMSECT
         SPACE 2
* * * * * ICULEN - GET SPECIFIED LENGTH, OR IMPLIED LENGTH - LEVEL - 3*
*        ENTRY CONDITIONS                                             *
*   RX = RETURN ADDRESS OF CALLING SECTION                            *
*        EXIT CONDITIONS                                              *
*   R2 = LENGTH-1,SUITABLE FOR USE IN SS INSTRUCTION                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ICULEN   IC    R2,ICYXL             GET LENGTH (IF SPECIFIED)
         TM    ICYF2,ICYXLFN       WAS A LENGTH EXPLICITYLY SPECIFIED
         BCR   O,RX                YES,RETUNR NOW
         IC    R2,ICYLQT           NO, IMPLIED LENGTH, GET THE LENGTH-1
         BR    RX                  RETUNR TO CALLER
         SPACE 1
ICOIR    OI    ICYR1R2,$CHN        REG OR LENGTH SUPPLIED BY EXECUTE
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
* * * * * TABLE OF ICYFLAG VALUES FOR VARIOUS INSTRUCTION TYPES.      *
*        A MACRO IS USED TO KEEP INDEPENDENCE ON ACTUAL EQUATE VALUES *
ICTTAB   EQU   *-1                 OFFSET SYMBOL
         DS    ($ICTMX)C           DEFINE ENOUGH STORAGE FOR MAX TYPES
         ICT   $RRM,0
         ICT   $RXM,$ICBEA2+ICBX2+ICBSEA2
         ICT   $RR,0
         ICT   $RX,$ICBEA2+ICBX2+ICBSEA2
         ICT   $RS,$ICBEA2+ICB1D1+ICBSEA2
         ICT   $RSH,$ICBEA2+ICB1D1+ICBSEA2
         ICT   $SI,$ICBEA1+ICB1D1
         ICT   $SS,$ICBEA1+$ICBEA2 WILL BE CHANGED AFTER 1ST OP DONE
         ICT   $SS2,$ICBEA1+$ICBEA2 ILL BE CHANGED AFTER 1ST OP DONE
         ICT   $RSO,0              FOR SPM,SVC. OTHERS WILL CHANGE
         ICT   $SPC,$ICBEA1+ICBX2
         ORG
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
         AIF   (&$OPTMS LT 2).ICX12         SKIP IF MEMORY OPT
ICZ1A    DS    2F                  USED BY LEVEL 1 ROUTINES AS SAVE
ICZ1RA   DS    F                   FOR SAVING SCAN POINTER IN ICXBD
ICZ2A    DS    F                   SAVE WORD FOR LEVEL 2 ROUTINES
.ICX12   AIF   (&$OPTMS GE 2).ICX13         SKIP IF MEMORY NO OPT
ICZ1A    DS    F                   LEVEL 1 SAVE WORD (MEMORY OPTMZ)
.ICX13   ANOP
ICZ3A    DS    3F                  USED BY LEVEL 3 ROUTINES AS SAVE
         SPACE 1
*              INTERNAL LOCATION FOR RCODBLK VARIABLES                *
ICRCB    DS    0F                  ALIGN ON FULLWORD
ICRCLENG DS    C                   LENGTH - 1 OF ICRCB
         DS    AL3                 ICRCLOC
ICRCTYPE DS    C                   INSTRUCTION TYPE
ICRCHEX  DS    C                   HEX OPCODE
ICRCMASK DS    C                   MASK AND FLAG BITS
ICRCLQ   DS    C                   LENGTH-1 ATTRIBUTE OF INSTRUCTION
ICRCLITA DS    A                   @ LITERAL IN LITERAL TABLE,IF EXISTS
         SPACE 1
*              INTERNAL LOCATION FOR OBJECT CODE BLOCK-ICBLOCK        *
ICYBLOCK DS    0F                  ALIGN ON F
ICYEA1   DS    F                   INSTRUCTION @ 1 FOR OUTPT2
ICYEA2   DS    F                   INSTRUCTION @ 2 FOR OUTPT2
ICYOP    DS    C                   OPCODE
ICYR1R2  DS    C                   REGISTERS,MASK,LENGTHS
ICYOPN1  DS    H                   1ST BASE DISPLACEMENT
ICYOPN2  DS    H                   2ND BASE-DISPLACEMENT
ICYFLAG  DS    C                   CONTROLS PROCESSING&PRINTING OF OPRD
*              THE ABOVE VARS ARE USED BY OUTPT2                      *
ICYF2    DS    C                   BYTE FOR ICXBD TO RETURN STATUS
ICYXL    DS    C                   INDEX OR LENGTH STORED HERE -ICXBD
ICYLQT   DS    C                   FOR IMPLIED LENGTH - LENGTH-1 HERE
         AIF   (NOT &$XREF).NOXRF16
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F                     A
ICXRTAB  DC    X'000000000884840C0C0C080000000C0C'         0          A
         DC    X'84848484840C8484840C848484848484'         1          A
         DC    X'84848484848484840C84848484848484'         2          A
         DC    X'8484848484848484840C848484848484'         3          A
         DC    X'488448840C84840C840C848484004884'         4          A
         DC    X'48004884840C8484840C848484848484'         5          A
         DC    X'4884480000000084840C848484848484'         6          A
         DC    X'4800000000000000840C848484848484'         7          A
         DC    X'08000800000086868484848484848484'         8          A
         DC    X'2C00840C840C8484C200000000000000'         9          A
         DC    X'00000000000000000000000000000000'         A          A
         DC    X'00000000000000000000000000882C86'         B          A
         DC    X'06000000000000000000000000000000'         C          A
         DC    X'00848484840C84840000000084848484'         D          A
         DC    X'00000000000000000000000000000000'         E          A
         DC    X'84848484000000008484848484840000'         F          A
.NOXRF16 ANOP                                                         A
         DROP  RAT,R13             KILL USINGS
         TITLE '*** IDASM2 - ASSEMBLER INSTRUCTIONS - PASS 2 ***'
**--> CSECT: IDASM2   2   ASSEMBLER INSTRUCTIONS - PASS 2 . . . . . . .
*.       THIS MODULE IS 1 OF THE 2 PASS 2,LEVEL 2 ROUTINES IN THE     .
*.       ASSIST ASSEMBLER.  IT PERFORMS ALL PROCESSING OF ASSEMBLER   .
*.       INSTRUCTIONS IN THE SECOND PASS.  IT PRODUCES SOME OBJECT    .
*.       CODE, AND DOES SETUP FOR PRINTING.  MOST OF THE WORK HAS     .
*.       ALREADY BEEN DONE IN THE CORREPONDING PASS 1 MODULE, IBASM1. .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF 1ST CHARACTER OF OPERAND FIELD)     .
*.  RC = ADDRESS OF RECORD CODE BLOCK(RCODBLK) FOR STATEMENT          .
*.  RE = ADDRESS OF RECORD SOURCE BLOCK(RSBLOCK) FOR STATEMENT        .
*.       CALLS BRDROP,BRUSIN,CCCON2,CNDTL2,ERRTAG,ESENX2,EVALUT,LTDMP2.
*.       CALLS OUTPT2,UTPUT2                                          .
*.       USES DSECTS: AVWXTABL,RCODBLK,RSBLOCK,SYMSECT                .
*.       USES MACROS: $AL2,$CALL,$GLOC,$RETURN,$SAVE,$SDEF,$STV       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
IDASM2   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         USING RCODBLK,RC          RC HAS POINTER ON ENTRY
         USING RSBLOCK,RE          NOTE ADDRESSIBILITY
         SPACE 1
* * * * * REGISTER USAGE FOR IDASM2 * * * * * * * * * * * * * * * * * *
*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0).                        *
*   RW = INTERNAL LINK REGISTER - LEVEL - 1 (IDREGET,IDEVAL)          *
*   RY = 1     USEFUL CONSTANT IN ODD REGISTER.                       *
*   RC = @ RCODBLK FOR STMT (= AVRCBPT).                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         $SAVE RGS=(R14-R6),SA=IDSAVE,BR=R13
         LA    RY,1                SET UP HANDY CONSTANT FOR MANY SECTS
         SR    R2,R2               CLEAR FOR INSERTIONS
         IC    R2,RCTYPE           GET TYPE BYTE
         LH    R14,IDAJUMP-$IB(R2) GET OFFSET @ TO RIGHT SECTION
         TM    RSBFLAG,$REBX       DO ERRORS EXIST ALREADY
         DROP  RE                  REMOVE RSBLOCK USING NOW
IDASMJ   BZ    IDASMJ(R14)         GO IF NO ERRORS
*              ERRORS EXIST - CURRENTLY, PROCESS END CARDS ONLY
         CLI   RCTYPE,$IB+$IEND    WAS IT AN END CARD
         BNE   IDOUT2              ANYTHING ELSE - FORGET IT
         B     IDEND               PROCESS END WHETHER ERRS OR NOT
         EJECT
* * * * * INDIVIDUAL ERROR EXITS                                      *
IDERELOC LA    RB,$ERRELOC         NEED RELOCATABLE VALUE
         B     IDERROR             GO HAVE ERROR FLAGGED
IDERELC  LA    RB,$ERNEABS         ABSOLUTE VALUE REQUIRED
         B     IDERROR             GO HAVE ERROR FLAGGED
IDREGBIG LA    RB,$EREXGTA         REGISTER OR OTHER VALUE TOO LARGE
         B     IDERROR             GO HAVE ERROR FLAGGED
IDERIND  LA    RB,$ERINVDM         INVALID DELIMITER
IDERROR  $CALL ERRTAG              FLAG IT
         SPACE 1
* * * * * PRINT STATEMENT AND RETURN TO CALLER.                       *
IDOUT2   L     RD,AWFM4            PUT NEG # TO SHOW NO CODE PRINTED
IDOUT2A  LA    RB,$OUCONS          SHOW TYPE OF CALL TO OUTPT2
IDOUT    $CALL OUTPT2              HAVE LINE PRINTED
IDRET    $RETURN RGS=(R14-R6)
         EJECT
* * * * * CCW * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDCCW    EQU   IDOUT2              **UNTIL CCW CODE WRITTEN           *
         SPACE 1
* * * * * CNOP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDCNOP   IC    R2,RCMASK           GET LENGTH 0-2-4-6
         SR    R2,RY               DECREMENT LENGTH TO LENGTH - 1
         BM    IDOUT2              IF L<0,NO OBJECT CODE NEEDED-SKIP
         LR    RD,R2               MOVE LEN-1 OVER FOR UTPUT2
         LR    RE,RY               PLACE A 1 IN REG RE-DUPFAC OF 1
         LA    RC,=3X'0700'        GET @ 3 NOPRS
         $GLOC RA                  GET LOCATION COUNTER FOR UTPUT2
         $CALL UTPUT2              CALL OBJECT CODE ROUTINE
         LA    RC,=3X'0700'        GET @ 3 NOPRS
         LR    RD,R2               MOVE LENGTH-1 OVER FOR OUTPT2
         B     IDOUT2A             GO HAVE CODE PRINTED
         SPACE 1
* * * * * CSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDCSECT  NI    AVTAGS1,255-$IBDSEC1          MAKE SURE FLAGGED CSECT
         B     IDESCH              GO CHANGE ESDID
         SPACE 1
* * * * * DC  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDC     SR    RB,RB               CLEAR FOR INSERT
         IC    RB,RCMASK           GET THE NUMBER OF OPERANDS IN DC
         LA    RC,RCLITEQ          GET @ FIRST OR ONLY CNCBLOCK
         $CALL CNDTL2              CALL 2ND PASS CONSTANT PROCESSOR
         B     IDRET               RETURN(CNDTL2 PRINTED LINE)
         SPACE 1
         AIF   (&$DEBUG).IDNOD1    SKIP OVER IF NOT DEBUG MODE
         SPACE 1
* * * * * DEBUG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDEBUG  CLI   RCHEX,C'2'          WAS THIS FOR PASS 2
         BNE   IDOUT2              QUIT IF WASN'T FOR 2
         MVC   AVDEBUG,RCMASK      MOVE BYTE INTO DEBUG FIELD
         B     IDOUT2              GO HAVE PRINTED OUT
.IDNOD1  ANOP
         SPACE 1
* * * * * DS  * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDS     EQU   IDOUT2              EVERYTHING DONE IN PASS 1
         SPACE 1
* * * * * DROP  * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDROP   BAL   RW,IDREGET          GET THE REGISTER VALUE
         $CALL BRDROP              HAVE REG DROPPED
         LR    RA,R1               RESTORE SCAN POINTER
         LTR   RB,RB               WAS THERE AN ERROR
         BZ    IDDROK              NO ERROR CONTINUE
         SR    RA,RY               BACK UP SCAN POINTER BY 1
         LA    RB,$ERRGNUS         REGISTER NOT USED-ONLY ERROR POSSIBL
         $CALL ERRTAG              HAVE THE ERROR TAGGED
         AR    RA,RY               BUMP SCAN POINTER TO NEXT CHAR
         SPACE 1
IDDROK   CLI   0(RA),C' '          WAS THIS LAST REGISTER
         BE    IDOUT2              YES-QUIT
         CLI   0(RA),C','          IS DELIMITER OK
         BNE   IDERIND             INVALID DELIMITER-NO COMMA
         BXH   RA,RY,IDDROP        BUMP SCAN POINTER AND GO BACK
         EJECT
* * * * * DSECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDDSECT  OI    AVTAGS1,$IBDSEC1    FLAG DSECT NOW
IDESCH   MVC   AVCESDID,RCMASK     MOVE NEW ESDID OVER
         B     IDOUT2              GO HAVE STATEMENT PRINTED
         SPACE 1
* * * * * ENTRY * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDENTRY  SR    RB,RB               SHOW THIS IS ENTRY CALL
         B     IDENEXCL            GO CALL ESENX2 ROUTINE
         SPACE 1
* * * * * EJECT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDEJECT  SR    RE,RE               SHOW THIS IS SPACE OR EJECT
         B     IDPRIN2             GO TO CALL PRINTOUT ROUTINE
         SPACE 1
* * * * * END * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS AVFENTER=ENTRY @, LEAVES = START VALUE OR 0 IF NO END SY*
IDEND    CLI   0(RA),C' '          WAS THERE A SYMBOL ON THE END CARD
         BE    IDLTORG             GO HANDLE AS LTORG
         BAL   RW,IDEVAL           HAVE EXPRESSION EVALUATED
         ST    RC,AVFENTER         SAVE THIS ENTRY POINT VALUE
         B     IDLTORG             GO HANDLE AS LTORG NOW
         SPACE 1
* * * * * EQU * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        SETS RCLOC = VALUE OF EQU SYMBOL FOR LISTING.                *
IDEQU    MVC   RCLOC,RCLITEQ+1     MOVE VALUE OF SYMBOL OVER FOR PRINT
         B     IDOUT2              GO PRINT STMT
         SPACE 1
* * * * * EXTRN * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDEXTRN  LA    RB,2                SHOW ESENX2 THIS IS EXTRN
IDENEXCL $CALL ESENX2              CALL ROUTINE
         B     IDOUT2              PRINT STATEMENT AND RETURN
         SPACE 1
* * * * * LTORG * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              END CARD PROCESSING ALSO USES THIS CODE                *
IDLTORG  LA    RB,$OUCOMM          SHOW NO LOCATION COUNTER-END-LTORG
         L     RD,AWFM4            SHOW THERE IS NO CODE TO BE PRINTED
         $CALL OUTPT2
         $CALL LTDMP2              HAVE LITERALS DUMPED AND PRINTED
         B     IDRET               RETURN
         SPACE 1
* * * * * ORG * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDORG    EQU   IDOUT2              EVERYTHING ALREADY DONE IN PASS 1
         EJECT
* * * * * PRINT * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDPRINT  LA    RE,2                SHOW THIS IS A PRINT COMMAND
IDPRIN2  LA    RC,RCMASK           @ TAG BITS(PRINT) OR # (SPACE,EJECT)
         B     IDLIST              GO TO CALL ROUTINE
         SPACE 1
* * * * * SPACE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDSPACE  EQU   IDEJECT             HANDLED SAME AS EJECT
         SPACE 1
* * * * * START * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDSTART  EQU   IDCSECT             HANDLE SAME AS CSECT
         SPACE 1
* * * * * TITLE * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDTITLE  EQU   *                   PROCESS TITLE STATEMENT       CPP
         LA    RA,1(RA)            RA=>1ST BYTE OF TITLE (AFTER ') CPP
         SR    RB,RB               CLEAR FOR INSERT            CPP
         IC    RB,RCMASK           GET LENGTH-1 OF TITLE       CPP
         $CALL CCCON2              EVALUATE OPD. (SAME AS C-TYPE DC) CP
         LA    RE,4                SHOW THIS IS A TITLE
*              COMMON CODE - EJECT,PRINT,SPACE,TITLE.
IDLIST   LA    RB,$OULIST          SHOW LISTING CONTROL
         B     IDOUT               GO FINALLY TO CALL OUTPT2
         SPACE 1
* * * * * USING * * * * * * * * * * * * * * * * * * * * * * * * * * * *
IDUSING  BAL   RW,IDEVAL           CALL EXPRESSION EVALUATORE
         SPACE 1
*              INITIALIZES FOR POSSIBLE MULTIPLE USING, LOOP IF SO.
IDUSB    LR    RX,RC               MOVE LOCATION COUNTER VALUE OVER
         L     RC,AVRCBPT          GET RCODBLK POINTER BACK,USING THER
         $STV  RX,RCLOC            SAVE LOCATION FOR PRINTING
         SPACE 1
IDUSC    CLI   0(RA),C','          MAKE SURE COMMA IS THERE
         BNE   IDERIND             BRANCH IF NOT-INVALIDDELIM
         AR    RA,RY               BUMP SCAN POINTER BEYOND ,
         BAL   RW,IDREGET          GO GET 1ST OR AFTER REGISTER VALUE
         LR    RB,RX               PUT CURRENT USING VALUE IN REG
         LR    RC,RZ               MOVE THE ESDID OVER FOR THE CALL
         $CALL BRUSIN              HAVE USING ENTERED
         SPACE 1
         CLI   0(R1),C' '          SCAN PT IN R1,CHECK FOR LAST
         BE    IDOUT2              QUIT IF DONE
         LA    RX,4095(RY,RX)      BUMP CURRENT USING 4096
         LR    RA,R1               MOVE SCAN POINTER BACK OVER
         B     IDUSC               BUMP SCAN POINTER AND CONTINUE
         EJECT
**--> INSUB: IDREGET    CONVERT REGISTER, CHECK VALIDITY  + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RA = SCAN POINTER TO 1ST CHARACTER OF REGISTER                    +
*+  RW = RETURN @ TO CALLING SECTION OF CODE                          +
*+       EXIT CONDITIONS                                              +
*+  R1 = SCAN PTR TO @ DELIMITER FOLLOWING SCAN (IF REGISTER GOOD).   +
*+  RA = VALUE OF REGISTER IF GOOD, = SCAN PTR TO ERROR IF BAD.       +
*+  RC = VALUE OF REGISTER IF GOOD.                                   +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
IDREGET  $CALL EVALUT              USE EXP EVAL (LOW PROB USAGE)
         LR    R1,RA               SAVE SCAN PTR
         LTR   RB,RB               WAS REGISTER OK
         BNZ   IDERROR             NO, BRANCH AND FLAG IT
         LTR   RD,RD               CHECK FOR ABSOLUTE VALUE, NOT RELOC
         BNZ   IDERELC             ›=0 ==> RELOCATABLE==> ERROR
         SPACE 1
IDREGCHK C     RC,AWF15            MAKE SURE REG NOT TOOT LARGE
         BH    IDREGBIG            NO,REGISTER TOO LARGE
         LR    RA,RC               PUT REGISTER WHERE DESIRED
         BR    RW                  RETURN TO CALLER,READY FOR DROP,USIN
         SPACE 1
**--> INSUB: IDEVAL     EVALUATE RELOCATABLE EXPRESSION + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RA = SCAN PTR TO 1ST CHARACTER OF EXPRESSION                      +
*+  RW = RETURN @ TO CALLING SECTION IN IDASM2                        +
*+       EXIT CONDITIONS                                              +
*+  RZ = SECTION ID OFTHE EXPRESSION  (SAME AS VALUE IN RD)           +
*+  RA = SCAN PTR @ TO DELIMITER IF GOOD, TO ERROR IF NOT.            +
*+  RC = VALUE OF THE EXPRESSION                                      +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
IDEVAL   $CALL EVALUT
         LTR   RB,RB               WAS EXPRESSION OK
         BNZ   IDERROR             NO, ERROR
         LTR   RZ,RD               DUPLICATE ESDID, TEST FOR RELOCATBL
         BCR   NZ,RW               RETURN IF RELOCATABLE (RD ›= 0)
         B     IDERELOC            ERROR, NEED RELOCATABLE EXPRESSION
         SPACE 1
* * * * * INTERNAL CONSTANTS                                          *
* * * * * BRANCH OFFSET TABLE FOR INDIVIDUAL INSTRUCTIONS             *
IDAJUMP $AL2   IDASMJ,(IDUSING,IDDROP,IDSTART,IDCSECT,IDDSECT,IDENTRY,I#
               DEXTRN,IDEQU,IDDC,IDDS,IDCCW,IDTITLE,IDEJECT,IDSPACE,IDP#
               RINT,IDORG,IDLTORG,IDCNOP,IDEND),-2
         AIF   (&$DEBUG).IDNOD2    SKIP IF NOT DEBUG MODE
         DC    AL2(IDDEBUG-IDASMJ)           OFFSET TO DEBUG ROUTINE
.IDNOD2  ANOP
         LTORG
         DROP  RAT,R13,RC          KILL USINGS
         TITLE '*** INPUT1 - INPUT CARDIMAGE READER/PROCESSORS ***'
**--> CSECT: INPUT1   1   INPUT AND MANIPULATION OF SOURCE CARDS. . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
INPUT1   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        MAIN TABLE USING
         ENTRY INCARD
         SPACE 2
**--> ENTRY: INCARD       CALLED TO GET CARD AND CREATE RSBLOCK . . . .
*.       THIS ENTRY READS 1 STATEMENT (1-3 CARDS), AND SETS UP THE    .
*.       RECORD BLOCKS RSBLOCK, AND RSCBLK (IF CONTINUATIONS OR       .
*.       SEQUENCE NUMBERS ARE USED).  IT IS CALLED DURING PASS 1 OF   .
*.       THE ASSEMBLY.  IF AN ENDFILE INDICATION IS ENCOUNTERED, IT   .
*.       CREATES A PSEUDO ENDCARD, SINCE THE MAIN PROGRAM OF PASS 1   .
*.       MOCON1 ONLY STOPS AFTER AN END CARD IS FOUND.  AS OF 8/17/70,.
*.       INCARD IS THE ONLY ASSEMBLER ENTRY DOING CARD READING.       .
*.       IN SETTING UP THE RSBLOCK, INCARD CONCATENATES THE SECTIONS  .
*.       OF A CONTINUED STATEMENT, AND REMOVES BLANKS TO SOME DEGREE  .
*.       FROM THE TRAILING EDGE OF THE STATEMENT.  IT ALSO INSERTS    .
*.       THE 3 CHARACTERS BLANK,APOSTROPHE,BLANK AFTER THE LAST       .
*.       NONBLANK CHARACTER IN THE SOURCE STATEMENT.  THIS IS CRUCIAL .
*.       TO THE PROPER SCANNING OF THE SOURCE STATEMENT WITHOUT       .
*.       REQUIRING LENGTHS TO BE CARRIED FROM ROUTINE TO ROUTINE.     .
*.                                                                    .
*.             IF THE MACRO PROCESSOR EXISTS (&$MACROS=1), INCARD     .
*.       ALSO HANDLES RECOVERY OF GENERATED STMTS (CREATED BY MEXPND ..
*.       IN THE DYNAMIC-HIGH AREA).                                   .
*.             IF A MACRO LIBRARY FACILITY EXISTS (&$MACSLB=1),       .
*.       INCARD CAN BE SWITCHED TO READ FROM IT, INSTEAD OF $SORC.    .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN PTR TO ERROR, ONLY IF RB ›= 0.  NO MEANING IF RB = 0.   .
*.  RB = 0     NO ERRORS FOUND IN STATEMENT BY INCARD                 .
*.  RB = ERROR CODE (NONZERO) OF ERROR.  RA HAS SCAN PTR OF IT.       .
*.  AVSOLAST = @ BLANK IMMEDIATELY BEFORE ' IN THE 4-BYTE FIELDWHICH  .
*.       INCARD PLACES AFTER THE SOURCE STMT TO STOP SCANNING OVERRUN..
*.       USES DSECTS: AVWXTABL,RSBLOCK,RSCBLK,RSOURCE                 .
*.       USES MACROS: $RETURN,$SAVE,$SORC                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR INCARD  * * * * * * * * * * * * * * *
*   R1 = NUMBER OF CARDS INCLUDED IN CURRENT RSBLOCK (FROM 1-3)       *
*   R2 = 0 (INITIALLY) - BYTE REGISTER FOR INSERTION                  *
*   RW = ADDRESS OF RSBLOCK BEING BUILT                               *
*   RX = ADDRESS OF RSCBLK BEING BUILT(IF ANY)                        *
*   RY = ADDRESS WHERE NEXT SOURCE SHOULD BE READ(RSOURCE)            *
*   RZ = CURRENT LENGTH-1 OF RSBLOCK BEING BUILT                      *
*   R14= INTERNAL LINK REGISTER (FOR INCRSMV).                        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
INCARD   $SAVE RGS=(R14-R6),SA=NO
         AIF   (&$DEBUG).INNZ      SKIP IF NOT DEBUGGIN MODE
         MVC   AVRSBLOC(256),AWTZTAB         ZERO OUT ***DEBUGGING ***
.INNZ    LA    R1,1                INIT # CARDS TO 1
         LM    RW,RX,AVRSBPT       VRSBPT,VRSCPT POINTERS
         USING RSBLOCK,RW          NOTE RSBLOCK USING SETUP
         USING RSCBLK,RX           NOTE RSCBLK USING SETUP
         LA    RY,RSBSOURC         INIT POINTER TO NEXT INPUT AREA
         USING RSOURCE,RY          NOTE CARDIMAGE USING
         LA    RZ,RSB$LN1          INIT LENGTH-1 OF RSBLOCK
         SR    R2,R2               CLEAR FOR ZERO VALUE
         ST    R2,RSBLENG          ZERO OUT WHOLE CODES SECTION
         SR    RB,RB               CLEAR INITIALLLY==> NO ERRORS
         TM    AVTAGS2,$INEND2     HAS THERE BEEN EOF, END CARD NEEDED
         BO    INCREOF             END CARD NEEDED-GO CREATE IT
         SPACE 1
         AIF   (NOT &$MACROS).INNOMA        SKIP IF NO MACROS
*              SEE IF EXPANDED STMTS EXIST. IF SO, PROCESS NEXT ONE.
         L     RC,AVGEN1CD         @ 1ST BYTE BEYOND NEXT GEN'D STMT
         C     RC,AVGEN2CD         CHECK AGAINST LOWER LIMIT
         BNH   INNOTGEN            SKIP IF THERE ARE NO MORE CARDS
         SPACE 1
         C     RC,AVADDHIH         MAKE SURE AVGEN1CD <= AVADDHIH
         BH    INMOVRGN            RAN OVER GENERATED CODE FROM TOP
         CLC   AVGEN2CD,AVADDLOW   CHECK FOR OVERRUN FROM BOTTO4
         BNH   INMOVRGN            YES IT DID (MORE LIKELY) - GO
         SPACE 1
*              MOVE NEXT EXPANDED STMT OVER TO RSBLOCK AREA.
         LA    RD,RSB$L            = LENGTH OF CONSTANT PART OF RSBLOCK
         SR    RC,RD               DECREMENT GEN PTR
         MVC   RSBLOCK(RSB$L),0(RC)         COPY CONSTANT PART
         IC    RZ,RSBLENG          GET L-1 OF GEN'D STMT
         STC   RZ,INMMOVE+1        PUT L-1 INTO MVC INSTR
         SR    RC,RZ               GET @ 2ND BYTE OF GEN'D STMT (L-1)
         SR    RC,R1               GET @ 1ST BYTE OF GEN'D STMT
INMMOVE  MVC   RSBSOURC($),0(RC)   MOVE WHOLE STMT OVER
         SPACE 1
*              IF THERE ARE ALREADY ERRORS IN THE STMT, MOVE THE
*              RESULTING REBLK OVER TO NORMAL LOCATION.
         TM    RSBFLAG,$REBX       DOES THE STMT HAVE ERRORS
         BZ    INMNOREB            NO, JUMP (NORMAL CASE)
         IC    R2,RSBNUM           GET REBLN FROM TEMPORARY LOCATION
         STC   R2,AVREBLN          STORE THE LENGTH-1 OF ERROR BLOCK
         SR    RC,R2               RC = @ OF REST OF REBLK (NOT REBLN)
         SR    R2,R1               GET L-1 OF PART OF REBLK LEFT
         STC   R2,*+5              PLACE L-1 INTO MVC INSTR
         MVC   AVREBES($),0(RC)    MOVE REST OF ERROR BLOCK OVER
         SPACE 1
INMNOREB ST    RC,AVGEN1CD         UPDATE PTR TO NEXT GEN'D STMT
         SPACE 1
*              STMT FROM MACRO PROCESSOR MAY HAVE 1-2 EXTRA BLANKS AT
*              END: REMOVE THEM SO DON'T CAUSE UNNECESSARY CONT CARDS.
         LA    RC,RSBSOURC-1(RZ)   @ NEXT TO LAST CHAR OF STMT
         CLI   1(RC),C' '          WAS LAST BYTE A BLANK
         BNE   INMOBLN             NO, SKIP, DON'T REMOVE
         CLI   0(RC),C' '          WAS NEXT TO LAST A BLANK
         BNE   *+6                 NO, REMOVE ONLY 1 - BRANCH
         SR    RZ,R1               YES, REMOVE 2 BLANKS FROM COUNT
         SR    RZ,R1               REMOVE OTHER BLANK
*              NOW CONSTRUCT RSCBLK, IF STMT REQUIRES IT BY BEING TOO *
*        LARGE TO FIT ON 1 CARD.  AT THIS PT, RZ = LENGTH-1 OF STMT.  *
*        (RZ) <=  70 ==> 1 CARD,  NO RSCBLK.                          *
*        (RZ) <= 126 ==> 2 CARDS, RSCBLK, 21 BYTES LONG               *
*              RSCLENG = 2*RSC$LEN; RSCILEN(1) = RSOL1;               *
*              RSCILEN(2) = (RC) - (RSOL1-1) .
*        (RZ) <= 182 ==> 3 CARDS, RSCBLK, 31 BYTES LONG.              *
*              RSCLEN = 3*RSC$LEN; RSCILEN(1) = RSOL1;
*              RSCILEN(2) = RSOLC; RSCILEN(3) = (RC) -(RSOL1-1)-RSOLC.
         SPACE 1
INMOBLN  LR    RC,RZ               GET L-1 TO BE DESTROYED
         AR    RZ,RD               GET L-1 OF ENTIRE RSBLOCK, AS NEEDED
         SPACE 1
         SH    RC,=AL2(RSOL1-1)    GET # BYTES IN GEN'D CARDS 2,3
         BNP   INCNORM             <=0, SO ONLY 1 CARD- BRANCH(NORMAL)
         TM    RSBFLAG,$RSBMERR    MACRO ERROR?                       J
         BO    INCNORM             YES, CAN'T BE CONTINUED ANYWAY     J
         SPACE 1
*              CONTINUATION CARDS NEEDED, LIKEWISE RSCBLK (MOAN).
         LA    RY,AWBLANK          FAKE BLANK CARDIMAGE FOR INCRSMV
         LA    RE,RSOLC            GET LENGTH OF CONTINUED CARDIMAGE
         AR    R1,R1               SET # CARDS SO FAR = 2 (AT LEAST)
         BAL   R14,INCRSMV1        HAVE 1ST SECTION OF RSCBLK SET UP
         MVI   RSCONSQ-RSCILEN(RD),C'X'      INDICATE CONTINUED CARD
         BAL   R14,INCMOV          MOVE SECOND CARD SEQNO/SET CODES
         SPACE 1
         CR    RC,RE               ARE THERE 2 CARDS OR 3
         BNH   INMCONT2            <= RSOLC ==> ONLY 2 CARDS TOTAL - GO
         SPACE 1
         SR    RC,RE               GET LENGTH OF 3RD CARD IMAGE
         MVI   RSCONSQ-RSCILEN(RD),C'X'   SHOW 2ND CARD CONINUED
         BAL   R14,INCMOV          SAVE 3RD AND LAST SECTION OF RSCBLK
         LA    R1,1(,R1)           SET  TOTAL # CARDS = 3.
*              IT IS ASSUMED THAT MEXPND NEVER CREATES STMTS HAVING   *
*              MORE THAN 193 (RSOL1+2*RSOLC) BYTES OF SOURCE DATA.    *
*              OTHERWISE, IT WOULD BE NECESSARY TO CHECK (RC) <= RSOLC*
INMCONT2 STC   RC,RSCILEN-RSCILEN(,RD)  SAVE LENGTH OF LAST PART <=56.
         B     INCNORM             ALL SET, NO GO PROCESS NORMALLY
         SPACE 1
INMOVRGN EQU   *                   COME HERE IF OVERRUN OCCURS
         MVC   AVGEN1CD,AVGEN2CD   COPY, SO THINKS NO MORE GEN'D STMTS
         MVC   0(80,RY),AWBLANK    FAKE A BLANK CARD
         OI    RSBFLAG,$RSBNPNN    DON'T PROCESS FURHTER
         LA    RB,$EROVRGN         FLAG ERROR: GEN'D STMTS OVERRUN
         B     INCHECK             SKIP OVER CARD READ AND GO ON
         EJECT
         SPACE 1
INNOTGEN EQU   *                   ENTERED IF NOT GENRTED STMT
.INNOMA  ANOP
         $SORC 0(RY),80,INCREOF    READ FIRST,HOPEFULLY ONLY,CARD
INCHECK  CLI   RSOCONT,C' '        CHECK FOR CONTINUATION CAHR
         BNE   INCCONT             CARD MUST BE CONTINUED-BRANCH
         CLC   RSOSEQN,AWBLANK     IS THERE SEQUENCE INFO
         BE    INCNORM             NO SEQNO-BRANCH NORMAL
INCHC    BAL   R14,INCRSMV         CALL CONTINUATION/SENO SAVER
         EJECT
*              ENTIRE STATEMENT READ-FINISH UP AND RETURN             *
INCNORM  STC   R1,RSBNUM           SAVE # CARDS(HOPEFULLY 1)
         LA    RE,RSBLOCK(RZ)      GET @ LAST ACTUAL SOURCE BYTE
*              FOLLOWING SECTION REMOVES BLANKS FROM END OF CARD.     *
         BCT   R1,INCBLC           SKIP BLANK-CRUNCH IF >1 CARD
*              REMOVE 36 BLANKS QUICKLY, IF POSSIBLE
         LH    R2,=H'-36'          GET VALUE TO BACK UP @ PTR
         AR    R2,RE               GET @ BEGINNING OF COMMENTS FIELD
         CLC   1(36,R2),AWBLANK    IS HALF OF CARD ALL BLANK
         BE    INCBL               YES,SO LEAVE R2 WHERE IT IS, BLANKS
         LR    R2,RE               WASN'T BLANK, DO WHOLE THING
INCBL    LA    R1,RSBSOURC+9       LIMIT @, INCLUDING POSSIBLE LABEL
         LH    R0,=H'-8'           DECREMENT: 8 BLANKS PER CHUNK
         BXLE  R2,R0,INCBLN        DECREMENT/TEST, SKIP IF TERHE ALREAD
         SPACE 1
         CLC   1(8,R2),AWBLANK     CHOP OFF 8 BLANKS IF POSSIBLE
         BNE   INCBLN              NOT BLANKS, TOO BAD, SKIP OUT
         BXH   R2,R0,*-10          LOOP UNTIL LIMIT REACHED
INCBLN   SR    R2,R0               SUBTRCT DECREMNT, PUT PTR BACK OK
         SPACE 1
         L     R0,AWFM1            GET NEW DECREMENT FOR 1 AT A TIME
         SPACE 1
*              LOOP TO REMOVE BLANKS FROM END OF STMT, 1 AT A TIME.   *
INCBLA   CLI   0(R2),C' '          IS THIS A BLANK
         BNE   INCBLB              NO IT ISNT, SO QUIT REMOVING-BRANCH
         BXH   R2,R0,INCBLA        LOOP UNTIL LIMIT @ REACHED
         SPACE 1
         SR    R2,R0               SUBTRCT -1,PUT POINTER BACK RIGHT
INCBLB   SR    R2,RE               GET # BLANKS REMOVED
         AR    RZ,R2               ADD DECREMENT TO LENGTH VALUE IN RZ
         AR    RE,R2               OBTAIN @ LAST BYTE(NEW)
         SPACE 1
*              CONCATENATE ENDING FIELD "  ' " TO SOURCE STMT TO      *
*              PREVENT SCANNING BEYOND END OF STMT. SAVE LIMIT @ IN   *
*              AVSOLAST, SAVE FINAL LENGTH-1 OF RSBLOCK. RETURN.      *
INCBLC   EQU   *                   FOR SKIP IF >1 CARD, NO CRUNCH
         MVC   1(4,RE),INCBQB      MOVE IN DELIMITER  VALUE
         LA    RC,2(RE)            GET @ OF BLANK BEFORE ENDING '
         ST    RC,AVSOLAST         STORE THIS FOR OTHER'S USE
         LA    RZ,2(RZ)            INCREMENT RZ BY 1 TO GET >=2BLANKS
         STC   RZ,RSBLENG          SAVE L-1 OF RSBLOCK
INCRET   $RETURN RGS=(R14-R6),SA=NO
         EJECT
*              FOLLOWING SECTION ENTERED FOR CONTINUATION CARD        *
INCCONT  BAL   R14,INCRSMV         HAVE CONTINUATION FIELD-SEQNO SAVED
         C     R1,AWF3             IS # OF CARDS<3(MAXIMUM)
         BNL   INCERR1             NO,WE HAVE TOO MANY CONTS(3 OR MORE)
         LA    RY,RSBLOCK+1(RZ)    GET NEXT ADDRESS TO BE INPUT
         $SORC 0(RY),80,INCREOFA   GET NEXT CARD
         CLC   RSOLOPC,AWBLANK     ARE 1ST 15 COLUMNS BLANK
         BE    INCCOK              BRANCH IF IT IS BLANK(OK)
         LR    RA,RY               ERROR-MOVE  ADDRESS OVER
         LA    RB,$ERCONT          ILLEGAL CONTINUATION-ERROR
         SPACE 1
INCCOK   MVC   RSOURCE(L'RSOOPRCM),RSOOPRCM  MOVE CARD IMAGE OVER
         LA    RZ,L'RSOOPRCM(RZ)   INCREMENT LENGTH-1 OD RSBLOCK
         LA    R1,1(R1)            INCRMENT NUMBER OF CARDS
         CLI   RSOCONT,C' '        IS CONTINUATION CARD CONINUED ALSO
         BE    INCHC               NO IT ISNT,HAVE LAST CONT/SEN SAVED
         B     INCCONT             CONINUED AGAIN-KEEP GOING
INCREOF  MVC   RSBSOURC(71),AWBLANK         BLANK OUT SOURCE AREA
         SPACE 1
         MVC   RSBSOURC+9(3),=C'END'        MAKE UP END CARD
         LA    RA,RSBSOURC+10      SET PTR TO END FOR WARNING
         LA    RB,$ERNOEND         WARNING-MESSAGE CODE-NO END CARD
INCREOFA OI    AVTAGS2,$INEND2     EOF==> CREATE END CARD NEXT TIME
         B     INCNORM             GO SET FLAGS AND RETURN
INCERR1  LA    RB,$ERCONTX         TOO MANY CONTINUATIONS(>2)
         LA    RA,RSOCONT-1        GET THE POINTER
         LA    R14,INCNORM         SET RETURN ADDR OF INCRSMV
*              FALL THRU INTO INCRSMV (WHICH MUST FOLLOW).
         SPACE 1
**--> INSUB: INCRSMV    SAVE CON/SEQNO INTO RSCBLK  + + + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RY = @ CARDIMAGE FROM WHICH CON/SEQNO TAKEN (RSOURCE DSECT)       +
*+       EXIT CONDITIONS                                              +
*+  RD = @ VARIABLE PART OF RSCBLK JUST CREATED (I.E. NEWEST RSCILEN) +
*+  R14= RETURN @ TO CALLING SECTION OF CODE IN INCARD.               +
*+  R2   IS DESTROYED.                                                +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
INCRSMV  TM    RSBFLAG,$RSCX       HAVE THERE BEEN PREVIOUS CONT/SEQS
         BO    INCMOV              YES THERE HAVE,BRANCH
INCRSMV1 OI    RSBFLAG,$RSCX       SHOW 1ST ONE - RSC EXISTS
         MVI   RSCLENG,0           ZERO OUT LENGTH AT FIRST
         MVI   RSCILEN,RSOCONT-RSOURCE      LENGTH FOR 1ST CRD(71)
INCMOV   IC    R2,RSCLENG          GET CURRENT L-1 OF BYTES
         LA    RD,RSCILEN(R2)      GET ADDR OF NEXT SLOT
         LTR   R2,R2               WAS THIS 1ST CARD
         BZ    *+8                 SKIP MVI IF IT WAS 1ST
         MVI   0(RD),L'RSOOPRCM    MOVE IN LENGTH FOR CONT CARD (56,
         MVC   RSCONSQ-RSCILEN(9,RD),RSOCONT MOVE CONT/SEQ OVER
         LA    R2,RSC$LEN(R2)      INCREMENT LENGTH-1
         STC   R2,RSCLENG          UPDATE LENGTH-1
         BR    R14                 RETURN TO CALLING SECTION
         SPACE 1
* * * * * INTERNAL CONSTANTS                                          *
INCBQB   DC    C'  '' '            DELIMITER FIELD FOR END OF SOURCE
         LTORG
         DROP  RAT,REP,RW,RX,RY    REMOVE ALL USINGS
         TITLE '*** LTOPRS - LITERAL OPERATIONS ***'
**--> CSECT: LTOPRS   1-2 ALL LITERAL TABLE OPERATIONS. . . . . . . . .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTOPRS   CSECT
         $DBG  A0,*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              NOTE RESTRICTION - A-TYPE ADCONS IN LITERALS MAY NOT   *
*              MAKE REFERENCES TO THE LOCATION COUNTER.   A WARNING   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         ENTRY LTINT1,LTENT1,LTDMP1,LTEND1,LTGET2,LTDMP2
         SPACE 2
**--> ENTRY: LTINT1   1   INITIALIZE LITERAL TABLE IF NEEDED. . . . . .
*.  ALLOCATES AND ZEROS 1ST LITERAL POOL BASE TABLE. INITS 1ST AND    *
*.  CURRENT BLOCK POINTERS TO 1ST LTBASETB.                           *
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,LTBASETB                               .
*.       USES MACROS: $ALLOCH,$RETURN,$SAVE                           .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTINT1   $SAVE SA=NO
         LA    RB,LTB$LEN          GET LENGTH OF 1 LTBASETB ENTRY
         $ALLOCH RA,RB,LTZOVER     GET NEEDED SPACE
         LR    RB,RA               DUPLICATE THIS VALUE
         STM   RA,RB,LTBFIRST      LTBFIRST-LTBNOW - SET POINTERS
         USING LTBASETB,RA         NOTE USING
         MVC   LTBASETB(LTB$LEN),AWZEROS     ZERO OUT THE TABLE
         DROP  RA                  CLEAN UP USING
         $RETURN SA=NO
         EJECT
**--> ENTRY: LTENT1   1   ENTER A LITERAL INTO THE TABLE. . . . . . . .
*.       THIS ENTRY IS CALLED DURING PASS 1 TO SCAN A LITERAL BY      .
*.       IAMOP1.  THE LITERAL IS SCANNED BY CODTL1, AND IT IS ENTERED .
*.       IF IT IS NOT ALREADY PRESENT.  NOTE THAT NO DUPLICATES       .
*.       ARE EVER KEPT IN THE SAME POOL, EVEN FOR A-TYPE CONSTANTS    .
*.       WITH LOCATION COUNTER REFERENCES.                            .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER (ADDRESS OF = IN LITERAL)                       .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER (ADDRESS OF ERROR OR DELIMETER)                 .
*.  RB = 0 IF LITERAL LEGAL, ERROR CODE OTHER WISE                    .
*.  RC = ADDRESS OF LITERAL TABLE ENTRY                               .
*.       CALLS CODTL1,MOSTOP                                          .
*.       USES DSECTS: AVWXTABL,CNCBLOCK,LTBASETB,LTLENTRY,RSBLOCK     .
*.       USES MACROS: $ALLOCH,$CALL,$RETURN,$SAVE,$SCPT               .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR LTENT1  * * * * * * * * * * * * * * *
*   R1 = #-1 OF CHARACTERS IN THE LITERAL BEING PROCESSED             *
*   R2 = # OF CHARACTERS IN LITERAL,ROUNDED TO FULLWORD, THEN -1      *
*   RW = BASE REGISTER                                                *
*   RX = INITIAL SCAN POINTER TO = OF LITERAL                         *
*   RC = @ CNCBLOCK PROVIDED BY CODTL1                                *
*   RD = TOTAL LENGTH OF NEW LTENTRY BLOCK                            *
*   RE = @ LTENTRY BLOCK FOR A NEW LITERAL                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
LTENT1   $SAVE RGS=(R14-R6),SA=LTOPSAVE,BR=R3
         SPACE 1
*              INITIALIZES, CALL 1ST-PASS CONSTANT PROCESSOR.
         LR    RX,RA               SAVE SCAN POINTER
         LA    RA,1(RA)            INCREMENT POINTER PAST =
         LA    RB,8                SHOW CODTL1 WE ARE IN LITERAL
         $CALL CODTL1              CALL DUPLFAC-TYPE-LENGTH PROCESSOR
         LTR   RB,RB               WAS THERE AN ERROR
         BNZ   LTE1RET             IF SO,RETURN SHOWING ERROR
         SPACE 1
*              CHECK TO MAKE SURE NO MISSING DELIMITER.
         C     RA,AVSOLAST         COMPARE TO @ BLANK BEFORE '
         BNL   LTE1ERR3            MISSING QUOTE ON C-CON-ERROR
         USING CNCBLOCK,RC         CODTL1 HAS SET UP A CNCBLOCK
         SPACE 1
*              SET UP FOR LOOKING FOR A DUPLICATE LITERAL             *
         LR    R1,RA               MOVE NEW SCAN POINTER OVER
         SR    R1,RX               GET LENGTH OF LITERAL-# OF CHARS
         LA    R15,112             GET LENGTH FOR COMPARISON
         CR    R1,R15              MAKE SURE NO MORE THAN 2 CARDS
         BH    LTE1ERR4            BRANCH IF TOO LONG
         BCTR  R1,0                GET # CHARS - 1 IN LITERAL
         BCTR  RE,0                GET TOTAL LENGTH-1 OF LITERAL DC
         N     RE,AWF7             REMOVE ALL BUT LAST 3 BITS OF LENGTH
         IC    R15,LTEB1248(RE)    GET THE OFFSET TO POINTER -LTBASETB
         L     R14,LTBNOW          GET @ CURRENT LTBASETB
         USING LTBASETB,R14        NOTE TABLE USING
         LA    RE,LTBCH1(R15)      GET @ ACTUAL POINTER -LTBCH1-2-4-8
         DROP  R14                 NO LONGER NEEDED
         USING LTLENTRY,RE         WILL POINT AT 1ST ENTRY,IF ›=0
         STC   R1,LTE1CLI+1        SAVE #-1 OF CHARS INTO CLI
         STC   R1,LTE1CLC+1        SAVE #-1 OF CHARS INTO CLC ALSO
         BAL   R15,LTE1L           BEGIN SEARCH,SETTING REG FOR BCR TOO
         SPACE 1
*              SEARCH FOR LITERAL IN CHAIN OF RIGHT LENGTH.           *
LTE1CLI  CLI   LTLCHARS,$CHN       CHECK 1ST FOR SAME # OF CHARS
         BNE   LTE1L               IF NOT,LOOP TO NEXT ON CHAIN
LTE1CLC  CLC   LTLITRAL($CHN),0(RX)          IS LITERAL THE SAME
         BE    LTE1OLD             BRANCH OUT IF SAME LITERAL
         SPACE 1
LTE1L    LR    RD,RE               SAVE @ OLD LTLENTRY
         L     RE,LTLINK           GET @ NEXT LTLENTRY FROM OLD ONE
         LA    RE,0(RE)            REMOVE 1ST BYTE
         LTR   RE,RE               IS THE LINK = 0
         BCR   NZ,R15              BNZ LTE1CLI - GO BACK FOR NEXT TEST
         SPACE 1
*              FALL THRU==> THIS IS A NEW LITERAL-GET SPACE&ENTER IT  *
         LA    R14,LTL$LEN+4(R1)   GET TOTAL LENGTH,ROUNDED OVER FULL
         O     R14,AWF3            MAKE LAST 2 BITS 1'S
         S     R14,AWF3            ALIGN TO FULLWORD AMOINT
         $ALLOCH RE,R14,LTZOVER    GET SPACE FOR NEW ENTRY
         STC   R1,*+5              PUT LENGTH-1 INTO MVC
         MVC   LTLITRAL($CHN),0(RX)          MOVE LITERAL OVER
         LR    R15,RE              MOVE POINTER OVER
         AL    R15,0(RD)           ADD LTLCHARS OF PREVIOUS ENTRY
         ST    R15,0(RD)           STORE LTLCHARS-LTLINKA BACK
         MVC   LTLTYP(CNC$LEN),CNCBLOCK      MOVE ALL THE CODES OVER
         DROP  RC                  HAVE GOTTEN CODES,NO MORE USING
         SLL   R1,24               SHIFT LENGTH-1 FOR POSITION TO STORE
         ST    R1,LTLINK           STORE LTLCHARS FIELD, WITH 0 LTLINKA
         $SCPT R15,LTLSCAN         GET SCAN POINTER ADDRESS
         SR    R15,RX              GET OFFSET FROM = SIGN
         STC   R15,LTLSCAN         SAVE THIS SCAN POINTER INSTEAD
LTE1OLD  LR    RC,RE               MOVE @ LITERAL ENTRY FOR RETURN
LTE1RET  $RETURN RGS=(R14-R6)
         SPACE 1
*              INDIVIDUAL ERROR EXITS.                                *
LTE1ERR3 LA    RB,$ERNODLM         MISSING DELIMITER
         B     LTE1RET             RETURN
LTE1ERR4 LA    RB,$ERCNLNG         CONSTANT TOO LONG FOR LITERAL
         B     LTE1RET             GO RETURN
         EJECT
**--> ENTRY: LTDMP1   1   DUMP LITERALS ON FINDING LTORG AND END. . . .
*.       LTDMP1 IS CALLED BY IBASM1 TO FIND LENGTH OF THE CURRENT     .
*.       LITERRAL POOL, AND AVANCE THE CURRENT POOL PTR TO THE NEXT 1..
*.       EXIT CONDITIONS                                              .
*.  RA = TOTAL LENGTH REQUIRED FOR THE LITERAL BLOCK                  .
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .
*.       USES MACROS: $ALIGN,$ALLOCH,$CALL,$GLOC,$RETURN,$SAVE        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTDMP1   $SAVE RGS=(R14-R0),SA=NO
         SPACE 1
*              INITIALIZE PROCESSING FOR 1 LITERAL POOL.
         SR    RA,RA               CLEAR TOTAL LENGTH
         L     RB,LTBNOW           GET POINTER TO CURRENT LTBASETB
         USING LTBASETB,RB         TELL ASSEMBLER
         $GLOC RE                  GET LOCATION COUNTER
         $ALIGN RE,7,*             ALIGN TO DOUBLEWORD
         ST    RE,LTBVALUE         SAVE THIS VALUE IN LTBLOCK
         LA    RC,4                # OF LITERAL CHAINS - LTBCH1-2-4-8
         LA    RD,LTBCH8           @ FIRST CHAING POINTER TO BE DONE
         SPACE 1
*              OUTSIDE LOOP - GET NEXT CHAIN OF LITERALS - 8-4-2-1.
LTD1L    L     RE,0(RD)            GET NEXT POINTER FORM LTBCH1-2-4-8
         USING LTLENTRY,RE         NOTE ENTRY POINTER(@ SET LOWER DOWN)
         A     RD,AWFM4            SUBTRACT 4 TO GET NEXT ONE NEXT TIME
         BAL   R14,LTD1LTR         GO TEST LINK PTR,ALSO SETING R14
         SPACE 1
*              LOOP ALONG LITERAL CHAINS,ADDING LENGTHS,GETTING OFSETS*
LTD1E    STH   RA,LTLOFSET         SAVE OFFSET OF LITERAL
         AH    RA,LTLTOT           ADD THE TOTAL LENGTH OF LITERAL IN
         AIF   (&$DEBUG).LTXS1     SKIP IF PRODUCTION
         XSNAP STORAGE=(*LTLENTRY,*LTLITRAL),IF=(AVDEBUG,O,X'84',TM)
.LTXS1   ANOP
         L     RE,LTLINK           GET @ NEXT LITERAL ON CHAIN
         LA    RE,0(RE)            REMOVE FIRST BYTE(LTLCHARS)
LTD1LTR  LTR   RE,RE               IS POINTER 0. IF SO==> LAST ON CHAIN
         BCR   NZ,R14              BNZ LTD1E - KEEP GOING IF MORE
         SPACE 1
         BCT   RC,LTD1L            LOOP TO GET ALL LITERALS - 8-4-2-1
         DROP  RE                  NO LONGER NEEDED
         SPACE 1
         LA    RD,LTB$LEN          GET LENGTH FOR NEXT LTBASETB
         $ALLOCH RE,RD,LTZOVER     GET THE SPACE
         ST    RE,LTBLINK          SAVE POINTER TO NEW LTBASETB IN OLD
         MVC   LTBESDID,AVCESDID   MOVE CURRENT ESDID OVER
         DROP  RB                  NO MORE REFS TO OLD LTBASETB
         USING LTBASETB,RE         USING FOR JUST CREATED LTBASETB
         MVC   LTBASETB(LTB$LEN),AWZEROS     ZERO IT OUT
         ST    RE,LTBNOW           SAVE NEW POINTER
LTD1RET  $RETURN RGS=(R14-R0),SA=NO
         DROP  RE                  NO LONGER USING
         EJECT
* * * * * LTZOVER IS ENTERED IF STORAGE OVERFLOW OCCURS, PASS 1       *
LTZOVER  $GTAD REP,MOSTOP          GET ADDR OF OVERFLOW ERROR EXIT
         BR    REP                 GO THERE, WILL EVENTAULLY PRINT 999
         SPACE 1
**--> ENTRY: LTEND1   1   CLEANUP AFTER PHASE 1 PREPARE FOR PHASE 2 . .
*.       THIS ENTRY SETS UP FOR ASSEMBLER PASS 2 LITERAL PROCESSING.  .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTEND1   $SAVE SA=NO
         MVC   LTBNOW,LTBFIRST     RESET ORIG POINTER TO CURRENT ONE
         $RETURN SA=NO
         SPACE 2
**--> ENTRY: LTGET2   2   GET ADDRESS OF LITERAL IN ASSEMBLY. . . . . .
*.       LTGET2 IS CALLED BY ICMOP2 EACH TIME A LITERAL IS FOUND IN   .
*.       SCANNING MACHINE INST OPERANDS DURING PASS 2. IT RETURNS THE .
*.       ATTRIBUTES OF THE LITERAL, INCLUDING THE USER PROGRAM @ FOR  .
*.       THE LITERAL, THE SECTION ID OF THE LITERAL, AND THE LENGTH   .
*.       ATTRIBUTE OF THE LITERAL. ICMOP2 SUPPLIES A POINTER TO THE   .
*.       LTLENTRY OF THE LITERAL, WHICH HAD BEEN SAVED IN THE         .
*.       STATEMENT'S RCODBLK .                                        .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO 1ST CHAR OF LITERAL =                        .
*.  RC = @ LITERAL TABLE ENTRY IN LITERAL TABLE(WAS SAVED IN RCB)     .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO CHARACTER AFTER LITERAL                      .
*.  RB = ESDID OF CSECT IN WHICH LITERAL EXISTS                       .
*.  RC = ADDRESS OF LITERAL (PROGRAM ADDRESS-FOR LISTING,ETC)         .
*.  RD = IMPLIED LENGTH-1 OF THE LITERAL(LOW ORDER BYTE, OTHERS INDTR).
*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         USING LTLENTRY,RC         NOTE USING,ON ENTRANCE
LTGET2   $SAVE SA=NO
         L     RE,LTBNOW           GET POINTER TO CURRENT LTBASETB
         USING LTBASETB,RE         NOTE THE USING HERE
         SR    RB,RB               CLEAR FOR INSERT OF ESDID
         IC    RB,LTLCHARS         GET LENGTH-1 OF LITERAL STRING
         LA    RA,1(RA,RB)         BUMP SCAN POINTER PAST LITERAL
         IC    RB,LTBESDID         GET THE ESDID OF LITERAL POOL
         AIF   (&$DEBUG).LTXS2     SKIP IF PRODUCTION
         XSNAP STORAGE=(*LTLENTRY,*LTLITRAL),IF=(AVDEBUG,O,X'84',TM)
.LTXS2   ANOP
         IC    RD,LTLLEN           GET LENGTH-1 BEFORE RC ERASED
         LH    RC,LTLOFSET         GET OFFSET FROM LITERAL POOL BASE
         A     RC,LTBVALUE         GET ACTUAL ADDRESS
LTG2RET $RETURN SA=NO
         DROP  RC,RE               REMOVE THE USINGS
         EJECT
**--> ENTRY: LTDMP2   2   DUMP LITERALS IN PASS 2 . . . . . . . . . . .
*.       LTDMP2 IS CALLED BY IDASM2 DURING PASS 2, WHENEVER A LTORG   .
*.       OR END STMT IS FOUND, TO PRODUCE THE OBJECT CODE AND LISTING .
*.       OF ANY LITERALS IN THE CURRENT LITERAL POOL.  THE CURRENT    .
*.       POOL BASE POINTER IS ADVANCED TO THE NEXT LTBASETB.          .
*.       CALLS CNDTL2                                                 .
*.       USES DSECTS: AVWXTABL,LTBASETB,LTLENTRY                      .
*.       USES MACROS: $CALL,$GLOC,$RETURN,$SAVE,$SLOC                 .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
LTDMP2   $SAVE RGS=(R14-R6),SA=LTOPSAVE,BR=R13
         SPACE 1
* * * * * REGISTER ALLOCATION AND USAGE FOR LTDMP2  * * * * * * * * * *
*   R1 = @ CURRENT LTBASETB BEING PROCESSED. 1 IS DONE FOR EACH CALL. *
*   R2 = BYTE REGISTER FOR INSERTIONS.                                *
*   RW = @ LOOP HEAD FOR 1 LINK OF 1 LITERAL CHAIN.                   *
*   RX = @ CURRENT LTLENTRY BLOCK BEING PROCESSED.                    *
*   RY = -4   FOR BXH INDEX AND LIMIT VALUE.                          *
*   RZ = OFFSET(0-4-8-12) TO LTBCH# POINTER OF LENGTH BEGIN DONE      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              INITIALIZATION - SET UP FAKE RECORD PTRS,ETC.          *
         LA    RA,LTRCODBL         GET @ FAKE RCODBLK SET UP
         ST    RA,AVRCBPT          SAVE THIS ADDRESS
         LA    RA,LTRSBLOC         GET @ FAKE RSBLOCK
         LA    RB,LTRSCBLK         GET @ FAKE RSCBLOCK
         STM   RA,RB,AVRSBPT       STORE PTRS IN AVRSBPT-AVRSCPT
         $GLOC R0                  GET LOCATION COUNTER
         L     R1,LTBNOW           GET @ NEXT LTBASETB
         USING LTBASETB,R1         NOTE THE POINTER
         SR    R2,R2               BYTE REGISTER-CLEAR FOR INSERTS
         L     RY,AWFM4            GET -4 FOR BXH'ING
         LA    RZ,LTBCH8-LTBCH1    GET OFFSET FROM LTBCH1-DO LENGTH 8
         EJECT
*              PROCESS CHAINS OF LITERALS, IN ORDER OF LENGTH 8-4-2-1.*
*              LTD2LRX ENTERD 4 TIMES,1 FOR EACH CHAIN OF LITERALS.   *
LTD2LRX  L     RX,LTBCH1(RZ)       GET NEXT POINTER FROM LTBASETB
         USING LTLENTRY,RX         NOTE POINTER
         BAL   RW,LTD2LTR          GO CHECK FOR LITERALS OF THIS LENGTH
         SPACE 1
*              FOLLOWING CODE EXECUTED 1 TIME FOR EACH LITERAL IN POOL*
*              PLACE LITERAL FOR PASS 2 SCAN AND PRINTING.            *
LTD2LTL  IC    R2,LTLSCAN          GET SCAN POINTER OFFSET FROM = TO CN
         LA    R2,LTRSBOPR-LTRSBLOC(R2)      GET CORRECT OFFSET
         STC   R2,LTLSCAN          SAVE WHERE CNDTL2 WILL EXPECT IT
         IC    R2,LTLCHARS         GET #-1 OF CHARS IN LITERAL
         MVC   LTRSBLOC(3),LTRSBCO1          GET CODES FOR 1 CARD LITER
         CLI   LTLCHARS,55         ARE THERETOO MANY CHARS FOR 1 CARD
         BNH   *+10                SKIP IF ONLY 1 CARD NEEDED
         MVC   LTRSBLOC(3),LTRSBCO2          GET CODES FOR 2 CARDS
         SPACE 1
         STC   R2,*+5              STORE LENGTH-1 INTO MVC
         MVC   LTRSBOPR($CHN),LTLITRAL       MOVE LITERAL FROM TABLE
         $SLOC R0                  SET LOCATION COUNTER
         MVC   LTRCLOC,AVLOCNTR+1  MOVE LOCATION COUNTER INTO FK RCB
         AH    R0,LTLTOT           ADD TOTAL LENGTH OF LITERAL TO LOC
         SPACE 1
         LA    RB,1                SHOW CNDTL2 WE HAVE 1 OPERAND
         LA    RC,LTLTYP           GET @ CNCBLOCK PART OF LTLENTRY
         $CALL CNDTL2              HAVE CONSTANT PROCESSED,PRINTED
         STC   R2,*+5              SAVE LENGTH-1 INTP BLANKING MVC
         MVC   LTRSBOPR($CHN),AWBLANK+15+RSB$L         BLANK,KEEPING BD
         L     RX,LTLINK           GET @ NEXT LTLENTRY ON CHAIN
         LA    RX,0(RX)            REMOVE 1ST BYTE IF ANY
         SPACE 1
*              CONTINUE LOOPING UNTIL LAST LITERAL FOUND ON CHAIN.    *
*              THEN DECREMENT TO NEXT CHAIN BEGINNING AND PROCESS IT. *
LTD2LTR  LTR   RX,RX               WAS THIS LAST ONE ON CHAIN
         BCR   NZ,RW               BNZ LTD2LTL - GO BACK FOR NEXT
         BXH   RZ,RY,LTD2LRX       DONE WITH 1 CHAIN,GO ON TO NEXT
         SPACE 1
         MVC   LTBNOW,LTBLINK      MOVE POINTER TO NEXT LTBASETB OVER
LTD2RET  $RETURN RGS=(R14-R6)      RETURN TO CALLER
         DROP  R1,RX               KILL USINGS
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
LTEB1248 DC    X'000400080004000C' OFFSETS TO LTBCH1-2-4-8 FOR LENGTHS
LTRSBCO1 DC    AL1(RSB$LN1,$RCBX,1)          CODES FOR FAKE RSBLOCK-1CD
LTRSBCO2 DC    AL1(RSB$LN1+56,$RCBX+$RSCX,2) CODES FOR RSBLOCK-2 CARDS
         SPACE 1
*              FAKE RSCBLK, USED IF MORE THAN 1 CARD REQUIRED FOR LIT.*
LTRSCBLK DC    AL1(1+2*RSC$LEN,71) RSCLEN,1ST RSCILEN FOR CONT/SEQ
         DC    CL9'X'              CONTINUATION FLAG,SEQNO
         DC    AL1(56)             LENGTH OF 2ND CARD IMAGE
         DC    CL9' '              SEQNO OF 2ND CARD IMAGE
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
LTBFIRST DS    A                   @ FIRST LTBASETB IN EXISTENCE
LTBNOW   DS    A                   @ CURRENT LTBASETB BEING PROCESSED
         SPACE 1
*              FAKE RCODBLK-RCLOC WILL BE USED AS LOCATION COUNTER.   *
LTRCODBL DS    0F                  LINE UP ON RIGHT BOUNDARY
         DC    X'7'                RCLENG - LENGTH-1 OF BLOCK
LTRCLOC  DS    AL3                 LOCATION COUNTER WILL BE PLACE HERE
         DC    F'0'                FILL OUT BLOCK
         SPACE 1
*              FAKE RSBLOCK - WILL BE USED TO ASSEMBLE AND PRINT.     *
LTRSBLOC DS    0D                  LINE UP
         DS    CL4                 RSBLEN-RSBFLAG,RSBNUM,RSBSCAN BYTES
LTRSBSOU DC    CL15' '             15 BLANKS IN FRONT OF =
LTRSBOPR DC    CL56' '             OPERAND FIELD, IF ONLY 1 CARD USED
         DC    CL56' '             CONTINUATION OF OPERAND FIELD
         EJECT
**--> DSECT: LTBASETB   LITERAL POOL BASE TABLE - 1 FOR EACH POOL . . .
*.       ONE LTBASETB IS CREATED FOR EACH LITERAL POOL, BY LTINT1 OR  .
*.       LTDMP1.  THE TOTAL # CREATED = # LTORGS + 2, WHICH INCLUDES  .
*.       1 FOR THE END STMT, AND 1 EXTRA 1 FOR CODE SIMPLIFICATION.   .
*.       WHEN LTDMP1 IS CALLED, IT FILLS IN THE SECTION ID OF THE     .
*.       SECTION WHERE THE POOL WILL BE ASSEMBLED, THE BEGINNING @ OF .
*.       THE POOL, AND THE OFFSET @ VALUES FROM THE BEGINNING @ TO    .
*.       EACH LITERAL IN THE POOL.  IN ADDITION TO ADDRESS AND SECTION.
*.       ID, THE LTBASETB ALSO CONTAINS THE LIST HEADS FOR 4 LISTS    .
*.       OF LITERAL ENTRIES (LTLENTRY BLOCKS). USED ONLY IN LTOPRS.   .
*.       LOCATION: HIGH END OF DYNAMIC AREA ($ALLOCH MACRO).          .
*.       NAMES: LTB-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
LTBASETB DSECT
LTBLINK  DS    0F                  ADDRESS OF NEXT LTB, =0 IF LAS
LTBESDID DS    C                   ESDID OF CSECT IN WHICH OCCURS
LTBLINKA DS    AL3                 ACTUAL LINKA ADDRESS
LTBVALUE DS    F                   ADDRESS OF LTORG OR END,D BOUNDARY
LTBCH1   DS    A                   ADDRESS OF 1ST LTENRY FOR LENGTH 1
LTBCH2   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 2
LTBCH4   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 4
LTBCH8   DS    A                   ADDRESS OF 1ST ENTRY FOR LENGTH 8
LTB$LEN  EQU   *-LTBASETB          LENGTH OF 1 LITERAL BASE TABLE
         EJECT
**--> DSECT: LTLENTRY   LITERAL TABLE ENTRY FOR EACH LITERAL. . . . . .
*.       1 LTLENTRY BLOCK IS CREATED BY LTENT1 FOR EACH UNIQUE        .
*.       LITERAL IN A GIVEN LITERAL POOL.  THE LTLENTRY BLOCKS ARE    .
*.       ORGANIZED IN 4 LINKED LISTS, WITH LIST HEADS IN THE CURRENT  .
*.       LTBASETB BLOCK.  EACH LTLENTRY INCLUDES THE OFFSET FROM THE  .
*.       BEGINNING OF THE CURRENT LITERAL POOL @ (ENTERED BY LTDMP1), .
*.       A COMPLETE CNCBLOCK DESCRIBING THE LITERAL CONSTANT, AND THE .
*.       CONSTANT IN CHARACTER FORM.  LTGET2 USES THESE BLOCKS TO     .
*.       DETERMINE THE USER PROGRAM ADDRESS FOR ANY DESIRED LITERAL,  .
*.       AND LTDMP2 USES THEM TO PRINT LITERAL POOL LISTING AND       .
*.       HAVE THE CODE ASSEMBLED FOR THE POOL.   USED ONLY IN LTOPRS. .
*.       LOCATION: HIGH END OF DYNAMIC AREA ($ALLOCH MACRO).          .
*.       NAMES: LTL-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
LTLENTRY DSECT
LTLINK   DS    0F                  ADDRESS OF NEXT ENTRY ON CHAIN
LTLCHARS DS    C                   #-1 OF CHARACTERS IN LITERAL
LTLINKA  DS    AL3                 ACTUAL POINTER TO NEXT LTLENTRY
LTLOFSET DS    H                   OFFSET OF THIS LITERAL FROM BASE
         SPACE 1
*              FOLLOWING SECTION (INCLD LTLTOT) = 1 CNCBLOCK DSECT.
LTLTYP   DS    C                   CONSTANT TYPE+ FLAGS
LTLLEN   DS    C                   LENGTH-1 OF OPERAND
LTLSCAN  DS    C                   SCAN POINTER TO 1ST CONSTANT
LTLNUM   DS    C                   NUMBER OF CONSTANTS IN OPERAND
LTLDUP   DS    H                   DUPLICATION FACTOR
LTLTOT   DS    H                   TOTAL LENGTH OF OPERAND
LTL$LEN  EQU   *-LTLENTRY          LENGTH OF CONSTANT SECTION
LTLITRAL DS    C                   LITERAL, LENGTH ROUNDED UP TO F
         DROP  RAT,R13             KILL USINGS
         TITLE '*** MOCON1 - MAIN CONTROL - ASSEMBLER PASS ONE ***'
**--> CSECT: MOCON1   1   MAIN CONTROL - ASSEMBLER PASS 1 . . . . . . .
*.       MOCON1 PROVIDES OVERALL CONTROL FOR PASS 1 OF THE ASSIST     .
*.       ASSEMBLER, AND SUPERVISES OR PERFORMS THE FOLLOWING:         .
*.        1. READING INPUT CARDS, CREATING RECORD BLOCKS (INCARD).    .
*.        2. SCANNING LABELS, ENTERING THEM IN SYMBOL TABLE(SYENT1).  .
*.        3. SCANNING CARD FOR THE OPCODE, IF ANY.                    .
*.        4. FINDING OPCODE IN OPCODE TABLE (OPFIND).                 .
*.        5. SCANNING FOR OPERAND FIELD, SAVING SCAN POINTER.         .
*.        6. 2ND LEVEL INSTRUCTION PROCESSING (IAMOP1,IBASM1).        .
*.        7. DEFINING ATTRIBUTES, VALUE OF LABEL, IF REQUIRED.        .
*.        8. UPDATING LOCATION COUNTER TO NEXT LOCATION.              .
*.        9. STORING RECORD BLOCKS FOR STMT (UTPUT1).                 .
*.                                                                    .
*.       NOTE: PRINT CONTROL/COMMENTS STMTS ARE PROCESSED COMPLETELY  .
*.       DURING PASS 1 AND NOT SAVED, IF POSSIBLE.                    .
*.                                                                    .
*.       CALLS ERRLAB,ERRTAG,IAMOP1,IBASM1,INCARD,OPFIND,SYENT1,UTPUT1.
*.       CALLS OUTPT2                                                 .
*.       USES DSECTS: AVWXTABL,OPCODTB,RCODBLK,RSBLOCK                .
*.       USES MACROS: $CALL,$GLOC,$GTAD,$PRNT,$RETURN,$SAVE           .
*.       USES MACROS: $SCOF,$SDEF,$SLOC                               .
*.       CALLS ERRLAB,ERRTAG,IAMOP1,IBASM1,INCARD,OPFIND,SYENT1       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
MOCON1   CSECT
         $DBG  90,*
         ENTRY MOSTOP              NOTE DISASTER ENTRY POINT
* * * * * REGISTER USAGE IN MOCON1  * * * * * * * * * * * * * * * * * *
*   R0   CURRENTLY UNUSED.                                            *
*   R2 = BYTE REGISTER, USED FOR INSERTIONS                           *
*   RW = ADDRESS OF RSBLOCK(NORMALLY IN AVWXTABL)                     *
*   RX = ADDRESS OF SYMBOL TABLE ENTRY,IF ANY,SAME AS AVLABPT.        *
*   R5 = 1, USED FOR BXH'S,ETC.                                       *
*   RA = SCAN POINTER ADDRESS REGISTER                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         $SAVE RGS=(R14-R6),BR=R13,SA=MOCOSAVE
         LA    R2,AVREBLK          RECORD ERROR BLOCK
         LA    RW,AVRSBLOC         RECORD SOURCE BLOCK
         USING RSBLOCK,RW          RECORD SOURCE BLOCK
         LA    RX,AVRSCBLK         RECORD SOURCE CODE BLOCK
         STM   R2,RX,AVREBPT       SORE THE ADDRESSES IN TABLE
         SR    R1,R1               CLEAR,SO TRT'S WILL WORK
         LR    R2,R1               CLEAR THIS FOR INSERTS
         LA    R5,1                INIT FOR BXH'S,ETC
         MVI   MOBACK+1,X'F0'      MAKE THE BC A BRANCH,UNTIL END FOUND
         AIF   (NOT &$MACSLB).MONOMC1
         XCALL XXXXLBED         MAKE SURE XXXXSORC SWITCH SET NORMALLY
.MONOMC1 ANOP
         EJECT
*              MAIN LOOP - PASS 1. THRU MOSTINIT 1 TIME FOR EACH STMT.*
MOSTINIT EQU   *                   LOOP HEAD FOR ALL STATEMENTS
         SPACE 1
*              IF TIME/RECORDS EXCEEDED, HALT PROCESSING NOW.
         TM    AVTAGS2,AJOASTOP    WAS STOP BIT SET BY TIMER EXIT
         BO    MORET               YES, QUIT
         SPACE 1
         $CALL INCARD              GET NEXT SOURCE CARD
         LTR   RB,RB               DID INCARD FIND AN ERROR
         BZ    MOSTINIV            NO, SO DON'T FLAG IT
         $CALL ERRTAG              FLAG ERROR FOUND BY INCARD
         SPACE 1
MOSTINIV EQU   *
         AIF   (NOT &$MACROS).MONMC1   SKIP IF NO MACROS
         TM    RSBFLAG,$RSBNPNN+$RSBNP##    DOES STMT NEED NO PROCESS
         BNZ   MOUTOUCK            NO PROC - SKIP TO SAVE OR PRINT NOW
.MONMC1  ANOP
         SR    RX,RX               CLEAR TO SHOW NO LABEL YET ENCOUNTER
         LA    RA,RSBSOURC         SET UP ADDRESS FOR START SCAN
         SPACE 1
*              CHECK FOR COMMENT OR LACK OF LABEL ON STMT.
         CLI   RSBSOURC,C' '       IS THIS NORMAL SOURCE,NO LABEL
         BE    MONOLB              YES,BRANCH TO HANDLE IT
         CLI   RSBSOURC,C'*'       IS IT  A COMMENT
         BE    MOCMSYSC            SKIP TO CHK *SYSLIB POSSIBILITY
         SPACE 1
*              STATEMENT HAS A LABEL IF FALLS THRU HERE.              *
         CLI   RSBSOURC,C'0'       MAKE SURE BEGINNING OF SYMBOL<C'0'
         BNL   MOLABR1             NO IT ISN'T,STARTS WITH #==>ILLEGAL
         TRT   RSBSOURC(9),AWTSYMT           SCAN A SYMBOL
         BZ    MOLABR1             SYMBOL 9+ CHARACTERS LONG-ERROR
         CLI   0(R1),C' '          IS DELIMITER BLANK LIKE SUPPOSED TO
         BNE   MOLABR2             NO IT ISNT==> ERROR-BRANCH
         SPACE 1
*              LEGAL LABEL FOUND. ENTER IN SYMBOL TABLE. CHECK FOR
*              MULTIPLE DEFINITION, FLAG STMT IF SO.
         LR    RB,R1               MOVE POINTER TO BLANK OVER
         SR    RB,RA               GET LENGTH OF SYMBOL
         $CALL SYENT1              HAVE SYMBOL ENTERED OR LOOKED UP
         LR    RX,RA               MOVE POINTER TO SYMBOL BACK OVER
         USING SYMSECT,RX          NOTE SYMBOL TABLE USING
         TM    SYFLAGS,$SYDEF      WAS SYMBOL ALREADY DEFINED
         BZ    MOLABGO             NO IT WASNHT-OK
MOLABMUL EQU   *                   ENTER HERE IF MULTIPLE DEFINED LABEL
         LA    RB,$ERMULDF         MULTUPLY-DEFINED SYMBOL
         $CALL ERRLAB              LABEL ERROR
MOLABGO  LR    RA,R1               MOVE POINTER TO BLANK AFTER LABEL
         BXH   RA,R5,MOOPC         BUMP SCAN POINTER 1 AND BRANCH
         SPACE 1
*              THE FOLLOWING IS ENTERED IF THERE WAS NO LABEL         *
MONOLB   CLC   RSBSOURC+1(8),AWBLANK         HOPE THAT THESE COLS BLANK
         BNE   MOOPC               NO THEY WERE'T,SKIP AND DO GENERALLY
         LA    RA,RSBSOURC+9       HAPPINESS-1ST 9 COLS BLANK
MOOPC    ST    RX,AVLABPT          SAVE POINTER(IF LABEL) OR 0(IF NOT)
         EJECT
*              SCAN LOOP TO FIND OPCODE                               *
MOOPCA   CLI   0(RA),C' '          IS THIS ANOTHER BLANK
         BNE   MOOPCB              NO IT ISNT BLANK-BRANCH OUT
         BXH   RA,R5,MOOPCA        BUMP SCAN POINTER AND CONTINUE
         SPACE 1
*              OPCODE IS FOUND-RA POINTS THERE. IF OMITTED,RA==> '    *
MOOPCB   C     RA,AVSOLAST         COMPAE TO @ BLANK BEFORE ' AFTER
         BNL   MOOPNONE            BRANCH OUT - - MISSING OPCODE
         $CALL OPFIND              LOOK UP TYPE OF OPCODE
         LTR   RB,RB               WAS IT LEGAL
         BNZ   MOMACHK             GO TO ERROR OR MACRO CHECK
         USING OPCODTB,RC          NOTE OPCODE TABLE POINTER
         AR    RA,R5               INCREMENT SCAN POINTER BY 1
         LR    RE,RA               SAVE SCAN POINTER FOR LATER
         SPACE 1
*              SEARCH FOR OPERAND FIELD.                              *
MOOPRA   CLI   0(RA),C' '          IS THIS STILL BLANK FIELD
         BNE   MOOPRB              NO-BRANCH OUT-WE HAVE OPERAND FIELD
         BXH   RA,R5,MOOPRA        BUMP SCAN POINT AND CONTINUE
         SPACE 1
*              FOUND FIRST NONBLANK CHAR IN OPERAND FIELD. TEST FOR
*              OMITTED OPERAND, EITHER COMPLETELY OR SHOWN BY ,.
MOOPRB   CLC   0(2,RA),=C', '      DOES HE SHOW OMITTED OPERAND
         BNE   MOOPRB2             NO,SO SKIP TO CHK FOR TOTAL OMIT
         BXH   RA,R5,MOOPRC        BUMP SCAN PTR TO SHOW BLANK,FAKE OMI
         SPACE 1
MOOPRB2  C     RA,AVSOLAST         CHK WITH @ BLANK BEFORE AFTERQUOTE
         BL    MOOPRC              OPERAND EXISTS, BRANCH
         LR    RA,RE               OMITTED,SO REPLACE ADDR OF 1ST BLNK
MOOPRC   $SCOF RE,RA,RSBSCAN       PLACE SCAN POINTER
         SPACE 1
*              MAKE TYPE TEST TO DETERMINE WHICH 2ND LEVEL PROCESSOR.
         TM    OPCTYPE,$IB         MAKE TEST FOR TUPE OF OPCODE
         BZ    MOCALLIA            BRANCH TO CALL MACHINE INSTRUCTIONS
         BO    MOCALLIB            CALL ASSEMBLER INSTS
         AIF   (NOT &$SPECIO).MONS SKIP IF NO SPECIALS
         AIF   (NOT &$MACROS).MOSPNM        SKIP IF SPECIALS,NO MACROS
         TM    OPCTYPE,$IS         WAS INSTRUCTION A SPECIAL
         BZ    MOCALLMA            BRANCH TO CALL MACRO1
.MOSPNM  IC    R2,OPCTYPE          GET TYPE OF OPCODE
         SLL   R2,2                MULT BY 4 FOR ADDRESS
         $GTAD REP,SPECAD-4*$IS(R2)         GET RIGHT ADDRESS
         B     MOCALLXX            GO TO CALL SECTION
.MONS    AIF   (NOT &$MACROS).MONSM         SKIP IF NO MACROS
MOCALLMA TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO MODE
         BZ    MOOPNONE            NO, FALG AS UNDERINFED OPCODE
MOCALLMC EQU   *                   ENTRY FROM OPEN CODE CHECK         J
         $CALL MACRO1              CALL THE MACRO DEFINITOON PROCESSOR
         B     *+4(RB)             TAKE INDEXED BRANCH ACCORDINGLY
         B     MOSTINIT            NORMAL RETURN - GO BACK FOR NEXT CRD
         B     MOSTINIV            NO, PROB AIF-AGO - CARD ALREADY EXIS
         B     MOPUT               ERROR ALREADY FLAGGED, GO TO SAVE
.MONSM   ANOP
         SPACE 1
MOCMSYSC EQU   *                   COME HWERE FOR ALL COMMENT CARDS
         AIF   (NOT &$MACSLB).MONSYS1       SKIP IF NO MACRO LIBRARY
         CLC   RSBSOURC+1(6),=C'SYSLIB'     WAS THIS *SYSLIB CARD
         BE    MOCOMSYS            GO TO CHECK AND PROCESS IT
.MONSYS1 ANOP
         AIF   (NOT &$XREF).NOXRF12                                   A
*  CHECK FOR *XREF CARD                                               A
         CLC   RSBSOURC+1(4),=C'XREF'  IS IT XERF                     A
         BNE   MOUTOUCK            NO GO ON                           A
         LA    RA,RSBSOURC+5       FOR ENTRY TO XRSCAN (@ TO BEGIN)   L
         SR    RD,RD               CLEAR FOR PROPER ENTRY CONT        L
         $CALL XRSCAN              CALL SCANNING ROUTINE              A
.NOXRF12 ANOP                                                         A
         SPACE 1
*              BRANCH HERE TO DETERMINE WTHER STMT SHOULD BE SAVED VIA
*              UTPUT1, OR PRINTED IMMEDIATELY AS A COMMENT TYPE.
MOUTOUCK TM    AVPRINT1,AVPRSAVE   MUST WE SAVE THE CARD
         BO    MOPUT               YES, SO GO DO IT
MOOUCOMM LA    RB,$OUCOMM          SHOW COMMENT TYPE ( NO LC CTR)
         B     MOIBOUTA            GO TO PUT IT OUT TO LISTING
*              ASSEMBLER INSTRUCTIONS                                 *
MOCALLIB EQU   *                   PROCESSING FOR ASSEMBLER OPS FOLLOWS
         AIF   (NOT &$MACOPC).MOIBA      SKIP ID NO OPEN CODE         J
         BAL   R14,MOOPAMPC        GO CHECK FOR SUBSTITUTE OF EVAR    J
.MOIBA   ANOP                                                         J
         $CALL IBASM1              CALL ASSEMBLER OPS PROCESSOR
         USING RCODBLK,RC          IBASM1 RETURNED PTR TO BLK IN RC
         L     RX,AVLABPT          RELOAD PTR: IF EQU, MAY NOW BE = 0
         TM    RCHEX,IBMOSPEC+IBMOPRCT WAS SPECIAL OF ANY KIND
         BZ    MOCALLXX            NO, SO SKIP TO COMPLETE PROCESSING
*              FALL THRU ==> SOME SPECIAL KIND OF HANDLING NEEDED.
         BM    MOCASEND            AT PRSENT, THIS COND ==> END CARD-B
         SPACE 2
*              SPECIAL HANDLING: BYPASS PASS 2 PROCESSING.            *
*        DURING PASS 1, IT IS POSSIBLE TO PROCESS A STMT COMPLETELY,  *
*   INCLUDING PRINTING IT, UNTIL ANY STMT EXCEPT ONE OF THE FOLLOWING *
*   IS FOUND IN THE INPUT STREAM:                                     *
*   COMMENT CARD, PRINT, SPACE, EJECT, TITLE.                         *
*   MACRO DEFINITIONS, GBL OR LCL IN OPEN CODE.                       *
*        THESE STMTS CAN BE COMPLETELY PROCESSED, THUS SAVING SPACE   *
*   AND TIME.   THE SECTIONS OF CODE BELOW HANDLE THIS.               *
         SPACE 1
         TM    AVPRINT1,AVPRSAVE   MUST WE SAVE RATHER THAN FINISH
         BO    MOCALLXY            YES, BRANCH, MUST SAVE IT
         SPACE 1
*              PROCESS PRINT CONTROL STMTS: SEE CORRESPOND IDASM2 CODE.
*              NOTE: SOME ERROS IN PRINT WILL CAUSE PRINT ON,NOGEN.
         CLI   RCTYPE,$IB+$ITITLE  IS THIS ACTUALLY TITLE STMT
         BNE   MOIBPR1             NO, BRANCH FOR NEXT CHECK
         SR    RB,RB               YES, WAS TITLE; CLEAR FOR INSERT CP
         IC    RB,RCMASK           GET LENGTH-1 OF TITLE        CPP
         $SCPT RA,RSBSCAN          GET SCAN POINTER BACK       CPP
         AR    RA,R5               (R5=1) RA=>1ST BYTE TITLE   CPP
         $CALL CCCON2              ASSEMBLE AS IF C-TYPE CONST. CPP
*              RETURNS: RC=> ASSEMBLED TITLE, RD=LEN-1 OF TITLE CPP
         LA    RE,4                SHOW THIS WAS A TITLE        CPP
         B     MOIBOUTL            BRANCH TO PRINT OR STORE TITLE CPP
         SPACE 1
MOIBPR1  CLI   RCTYPE,$IB+$IPRINT  WAS IT ACTUALLY PRINT STMT
         LA    RC,RCMASK           @ CONTROL BYTE(PRINT,SPACE,EJECT)
         LA    RE,2                SHOW THIS WAS A PRINT STMT.  CPP
         BE    MOIBOUTL            WAS PRINT; ALL REGS SET, PRINT CPP
         SR    RE,RE               FALL THRU==> SPACE OR EJCT, RESET =0
MOIBOUTL LA    RB,$OULIST          SHOW THIS WAS A LISTING CTRL CPP
         SPACE 1
*              IMMEDIATE PRINT CONTROL: CALL PRINT ROUTINE.
MOIBOUTA $CALL OUTPT2              REGS RB,RC,RD,RE ALREADY SET UP
         B     MOSTINIT            GO BACK, PICK UP NEXT STMT
         SPACE 1
MOCASEND EQU   *                   COME HERE FOR END CARD
         MVI   MOBACK+1,0          MAKE BRANCH A NOOP SO WE FALL THROUG
         B     MOCALLXX            GO CALL ROUTINE
         DROP  RC                  NOTE NO LONGER USING RC BLOCK
         SPACE 1
*              MACHINE OPCODES                                        *
MOCALLIA EQU   *                   COME HERE FOR MACHINE OPS          J
         AIF   (NOT &$MACOPC).MOIAA                                   J
         BAL   R14,MOOPAMPC        GO CHECK FOR SUBSTITUTEION OF &VAR J
.MOIAA   ANOP                                                         J
         $CALL IAMOP1              CALL MACHINE OP PROCESSOR          J
         EJECT
*              CALL THE 2ND LEVEL PROCESSOR ROUTINE REQUIRED.         *
MOCALLXX EQU   *
MOCALLXY EQU   *                   SKIP HERE IF AVPRINT1 SET ALREADY
         USING RCODBLK,RC          RC--> RCB OF 2ND LEVEL ROUTINE
         SPACE 1
*              FINISH CREATION OF RCODBLK,ADDING LOC.COUNTER VALUE.
         OI    RSBFLAG,$RCBX       NOTE THAT AN RCB EXISTS NOW
         $GLOC RE                  GET LOCATION COUNTER
         MVC   RCLOC,AVLOCNTR+1    MOVE THE LOCATION COUNTER IN
         SPACE 1
*              DEFINE STMT LABEL, IF ANY, IF NOT ALREADY DEFINED.
         LTR   RX,RX               IS THERE A LABEL ON STATMENT
         BZ    MONOLB2             NO,SKIP DEFINING IT
         TM    SYFLAGS,$SYDEF      HAS THIS BEEN DEFINED YET
         BO    MONOLB2             YES,DON'T REDEFINE IF ALREADY
         IC    R14,AVCESDID        GET ESDID
         IC    RB,RCLQ             GET LENGTH ATTRIBUTE
         $SDEF RE,R14,RB           DEFINE THE SYMBOL
         SPACE 1
*              INCREMENT LOCATION COUNTER BY LENGTH OF THIS STMT.
MONOLB2  AR    RE,RD               ADD INCREMENT TO LOCATION COUNTER
         $SLOC RE
         ST    RC,AVRCBPT          SAVE ADDR OF RCB
         AIF   (&$DEBUG).MONOXS    SKIP IF PRODUCION
         XSNAP STORAGE=(*0(RC),*12(RC),*AVLOCNTR,*AVDWORK1-1),T=NO,    #
               IF=(AVDEBUG,O,X'88',TM)
.MONOXS  ANOP
         SPACE 1
MOPUT    $CALL UTPUT1              OUTPUT THE EXPANDED RECORDS
MOBACK   BC    $CHN,MOSTINIT       B MOSTINIT UNTIL END-BECOMES NOOP
         SPACE 1
MORET    $RETURN RGS=(R14-R6)
         EJECT
**--> ENTRY: MOSTOP     CALLED IF DISASTROUS ERROR OCCURS IN PASS 1 . .
*.       RESTORES CONDITIONS FOR MOCON1, NOTE OVERFLOW OCCURRENCE.    .
*.  ENDS EXECUTION FOR PASS 1, FLAGGING PROGRAM NONEXECUTABLE.        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         USING MOSTOP,REP          NOTE TEMPORARY USING
MOSTOP   L     R13,=A(MOCOSAVE)    GET @ SAVE AREA,BAS REG
         DROP  REP                 KILL TEMPORARY USING,BACK TO NORMAL
         OI    AVTAGS3,AVOVERFL    SHOW OVERFLOW OCCURRED.
         B     MORET               RETURN TO MAIN CONTROL
         AIF   (NOT &$MACOPC).MOAMP1                                  J
         SPACE 1                                                      J
**--> INSUB: MOOPAMPC CHECK STATEMENT FOR SET VARIABLE SUBSTITUTION  *J
*+       ENTRY CONDITIONS:                                           +J
*+  RA= @ OPERAND FIELD / UNCHENGED ON EXP                           +J
*+  R14 = RETURN ADDRESS                                             +J
*+       EXIT CONDITIONS                                             +J
*+  RETURN IF NO POSSIBLE SUBSTITUTION                               +J
*+  -->MOCALLMC IF SUBSTITUTION POSSIBLE                             +J
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +J
MOOPAMPC TM    AVMTAG00,AVMOPENC   HAVE SET VARS FOUND ALRESDY        J
         BCR   Z,RET               NO, NO SUBSTITUTION POSSIBLE       J
         TM    RSBFLAG,$RSBGENR    GENERATE STATMENT                  J
         BCR   O,RET               YES, CAN'T SUBSTITUTE AGAIN        J
         IC    R2,RSBLENG          GET LENGTH-1 OF WHOLE STMT         J
         SH    R2,=AL2(RSB$L)      GET LENGTH-1 OF STMT               J
         STC   R2,MOOPAMPT+1       PUT L-1 INTO TRT                   J
         $SETRT ('&&',4)           FLAG TO STOP ONE                   J
MOOPAMPT TRT   RSBSOURC($),AWTZTAB SCAN FOR &                         J
         $SETRT ('&&',0)           REZERO                             J
         BCR   Z,RET               NO SUBSTITUTION-RET                J
         LA    RC,AWZEROS          SHOW @ ZEROS: MACRO WANTS THIS     J
         B     MOCALLMC            GO TO CALL MACRO1 TO SCAN          J
.MOAMP1  ANOP                                                         J
         SPACE 1
* * * * * OUT-OF-LINE ERROR PROCESSING SECTIONS * * * * * * * * * * * *
         SPACE 2
*              ERROR IN LABEL - FLAG, MOVE SCAN PTR TO 1ST BLANK.
         SPACE 1
MOLABR2  EQU   *
         AIF   (NOT &$MACOPC).MOLABR                                  J
*              IF MACROS MAY BE PRESENT, CHECK FOR SEQUENCE SYMBOL.
         TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO RUN                A
         BZ    MOLABR2B            NO, SO ERROR FOR SURE
         TRT   RSBSOURC+1(8),AWTSYMT        SCAN SYMBOL
         BZ    MOLABR1             TOO LONG, ERROR
         CLI   0(R1),C' '          TERMINATE PROPERLY
         BNE   MOLABR2B            NO ERROR FLAG IT                   J
         TM    RSBFLAG,$RSBGENR    WAS IT GENERATED                   J
         BO    MOLABGO             YES,SO IGNOR LABEL                 J
         CLI   0(RA),C'&&'         SET VARIABLE                       J
         BE    MOLABGO             YES,CONTINUE                       J
         CLI   0(RA),C'.'          SEQUENCE SYMBOL?                   A
         BNE   MOLABR2B            NO ERROR                           J
         CLI   1(RA),C'0'          CHECK FOR LEGALITY                 J
         BNL   MOLABR2B            BAD-1ST CHAR IS DIGIT              J
* LEGAL SET SYMBOL-PLACE IT IN SYMBOL TABLE                           J
         LR    RB,R1               @ TERMINATOR BLANK                 J
         SR    RB,RA               GET LENGTH                         J
         $CALL SYENT1              HAVE SYMBOL LOOKED UP              J
         USING SYMSECT,RA          NOT PTR                            J
         TM    SYFLAGS,$SYDEF      YES ERROR                          J
         BO    MOLABMUL            YES ERROR                          J
         OI    SYFLAGS,$SYDEF      SHOW DEFINED NOW                   J
         B     MOLABGO             CONTINUE AS USUAL                  J
         DROP  RA                  ZAP USING                          J
         SPACE 1
*              DEFINITE ILLEGAL LABEL FIELD.
.MOLABR  ANOP
MOLABR2B LR    RA,R1               INVALID CHARACTER, SHOW SCAN PTR
MOLABR1  LA    RB,$ERINVSY         INVALID SYMBOL
         $CALL ERRTAG              FALG IT
MOLABLP  CLI   0(RA),C' '          SEARCH FOR BLANK
         BE    MOOPC               FOUND BLANK AFTER SYMBOL-BRANCH
         BXH   RA,R5,MOLABLP       BUMP SCAN POINTER AND CONTINUE
         SPACE 1
*              MISSING OPERATION CODE ERROR.
MOOPNONE LA    RA,RSBSOURC+9       POINT WHERE OPCODE SHOULD BE
         LA    RB,$ERIVOPC         OMITTED OPCODE
         B     MOERRORA            GO HAVE IT FLAGGED
         SPACE 1
MOMACHK  EQU   *                   DEFINE LABEL, EITHER MACRO CHECK, ER
         AIF   (NOT &$MACROS).MONMAC        SKIP IF NO MACROS
*              THIS CODE ENTERED IF UNRECOGNIZED OPCODE.  AT THIS PT,
*              RB = $ERIVOPC, SET BY OPFIND.  MAKE SURE STMT WAS NOT
*              ALREADY A GENERATED ONE.  CALL MEXPND TO SEE IF MACRO.
         TM    AVTAGSM,AJOMACRO    ARE WE IN MACRO MODE
         BZ    MOERRORA            NO, FLAG AS UNDEFINED OPCODE
         BAL   R14,MOOPAMPC        CHECK FOR SUBSTITUTION OF &VAR     S
         $CALL MEXPND              CALL TO EXPAND MACROS
*********CODE MAY BE REQUIRED TO SHOW WE ARE IN EXPANSION MODE        *
         LTR   RB,RB               WAS THE MACRO KNOWN
         BZ    MOSTINIT            OK,BRANCH IF OS
.MONMAC  ANOP
         SPACE 1
*              GENERAL 1-STMT UNRECOVERABLE ERROR SECTION.
MOERRORA $CALL ERRTAG              HAVE ERROR FLAGGED
         B     MOUTOUCK            GO TO CHK PRINT/SAVE OPTION
         SPACE 1
         EJECT
         AIF   (NOT &$MACSLB).MONOMC2
* . . . .   MOCOMSYS  SECTION . . . . . . . . . . . . . . . . . . . . .
*                                                                     .
*        THIS SECTION OF MOCON1 IS CALLED WHENEVER A '*SYSLIB CARD    .
*        HAS BEEN FOUND.  IT COORDINATES THE ACTIVITIES OF MACRO      .
*        LIBRARY PROCESSING AND THE MACRO PROCESSOR                   .
*                                                                     .
*        ENTRY CONDITIONS:                                            .
*              REGISTER RA --> SCAN POINTER TO SYSLIB CARD            .
*                                                                     .
*        EXIT CONDITIONS:                                             .
*              REGISTERS UNCHANGED                                    .
*                                                                     .
*        USES MACROS:                                                 .
*              $CALL, $ALLOCL                                         .
* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 2
MOCOMSYS STM   RA,RE,MOCOMSVE      SAVE CONDITION OF WORK REGISTERS
         MVC   MOCPRTSV,AVPRINT    SAVE CURRENT PRINT STATUS
         TM    AVTAGSM,AJOMACRO    RETURN IF MACRO DISENABLED
         BZ    MOUTOUCK            NOT MACRO MODE GO TO PRINT CARD
         TM    AVPRINT1,AVPRSAVE   IS SYSLIB CARD IN LEGAL POSITION
         BO    MOCLBER1            IN ERROR--GO THERE TO FINISH
         AIF   (NOT &$MACOPC).MOMXX1         SKIP IF NO OPEN CODE
         TM    AVMTAG00,AVMOPENC   HAVE GBLX, LCLX BEEN FOUND
         BO    MOCLBER1            YES, ERROR - FLAG IT
.MOMXX1  ANOP
         LA    RA,7(RA)            SYSLIB LEGAL-INCREMENT POINTER PAST
*                                  SYSLIB TO THE FOLLOWING BLANK
         SPACE 1
*        SCAN AND SKIP BLANKS TILL FIRXT SYMBOL OF NAME FOUND
MOCBLNK  CLI   0(RA),C' '          IS THIS A BLANK
         BNE   MOCLBSC             NO BRANCH OUT TO CONTINUE
         BXH   RA,R5,MOCBLNK       BUMP SCAN POINTER AND CONTINUE
         SPACE 1
MOCBUMP  LA    RA,1(R1)            KICK PAST A LEGAL DELIMITER
MOCLBSC  LR    R1,RA               MOVE POINTER OVER FOR ERROR FLUSH
         C     RA,AVSOLAST         IS SYSLIB CARD BLANK
         BNL   MOCNLSYS            YES--> SO SKIP NAME SCAN CODE
         CLI   0(RA),C'0'          DOES NAME START WITH LEGAL CHARACTE
         BNL   MOCLBER2            NOT LEGAL STARTING CHARACTER
         TRT   0(9,RA),AWTSYMT     SCAN THE NAME
         BZ    MOCLBER2            NAME TOO LONG--ERROR
         LR    RB,R1               MOVE BLANK POINTER OVER
         SR    RB,RA               GET LENGTH OF NAME
         SR    RB,R5               DECREMENT FOR LENGTH-1 OF NAME
         MVC   AVMSYMBL,AWBLANK    BLANK OUT SEARCH AREA
         EX    RB,MOCMVEL          MOVE NAME INTO SEARCH AREA
         L     RC,AVMACLIB         SET UP TO SEARCH LIST WITH MACFND
         BAL   RD,MOCLOOK          SEARCH LIST FOR NEW NAME
         LTR   RB,RB               SET CC ON RETURNED MAGNITUDE OF RB
         BNZ   MOCNMADD            NOT FOUND- PUT NAME IN THE LIST
MOCNAMNT CLI   0(R1),C','          IF LEGAL NAME DELIMITER LOOP FOR ALL
*                                  NAMES
         BE    MOCBUMP             LOOP FOR ALL NAMES
         CLI   0(R1),C' '          IS SCAN CHARACTER A BLANK
         BNE   MOCLBER3            NOT BLANK OR COMMA--ERROR INVALID
*                                  DELIMITER
MOCNLSYS LA    RB,$OUCOMM          SET TO PRINT A COMMNNT
         $CALL OUTPT2              PRINT STATEMENT AND ANY ERRORS
         L     RC,AVMACLIB         GET BEGIN ADDRESS OF MACRO LIST    M
         USING MACLIB,RC           NOTE USING ON MACRO LIST DSECT     M
         SR    RB,RB               ZERO FOR SEARCH END LIST           M
         CL    RB,MCLIBNXT         IF LIST HEADER IS NULL             M
         BE    MOCLBOUT            THEN NO OPEN - JUST QUIT           M
         DROP  RC                  CLEAR USING                        M
         XCALL XXXXLBOP            CALL TO OPEN LIBRARY DCB           M
         BM    MOCLBER4            NO--SET UP ERROR
         SPACE 2
         TM    AVTAGSM,AJOLIBMC    SHOULD WE PRINT MACRO DEFINITIONS
         BO    *+8                 NO -- PROCESS NORMALLY
         NI    AVPRINT,255-$IBPON  TURN PRINT STATUS OFF
         SPACE 1
MOCLBMOR L     RC,AVMACLIB         GET BEGIN ADDRESS OF MACRO LIST
         USING MACLIB,RC           NOTE USING ON MACRO LIST DSECT
         SR    RB,RB               ZERO FOR SEARCH END TEST
         CL    RB,MCLIBNXT         IF LIST HEADER IS NULL
         BE    MOCLBOUT            THEN NOTHING TO DO -- GO HOME
         L     RC,MCLIBNXT         ELSE START LIST SCAN
         B     MOCLBFD2            SKIP TO LOOK AT FIRST ENTRY
MOCLBFD1 L     RC,MCLIBNXT         GET @ OF NEXT ENTRY
MOCLBFD2 TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED?
         BO    MOCLBFD5            DEFINED -- GO LOOK AT NEXT ENTRY
         TM    MCLBTAGS,AVMCLBNF   PREVIOUSLY SEARCHED FOR
         BNO   MOCLBFND            N/- GO DO FIND AND MACRO DEFINITION
MOCLBFD5 CL    RB,MCLIBNXT         IS THIS FINAL ENTRY
         BNE   MOCLBFD1            NO--LOOK AT NEXT
         SPACE 5
MOCLBSP  XCALL XXXXLBED            CALL LIBRARY ENDUP ROUTINE
         L     RC,AVMACLIB         GET BEGIN @ OF MACRO LIST
         SR    RB,RB               ZERO FOR SEARCH EBD TEST
         B     MOCLBFD4            SKIP TO LOOK AT FIRST ENTRY
MOCLBFD3 L     RC,MCLIBNXT         GET @ OF NECT ENTRY
MOCLBFD4 TM    MCLBTAGS,AVMCLBDF   HAS THIS MACRO BEEN DEFINED
         BO    MOCLBMR1            DEFINED -- SKIP ERROR SET
         MVC   MOCER7MS+10(8),MCLBNAM       MOVE BAD NAME INTO MESS
         BAL   RE,MOCLBER7         GO TO MARK NAME AS ERROR
MOCLBMR1 CL    RB,MCLIBNXT         IS THIS FINAL ENTRY
         BNE   MOCLBFD3            NO--CONTINUE SEARCH
         SPACE 2
MOCLBOUT MVC   AVPRINT,MOCPRTSV    RESTORE THE PRINT STATUS
         LM    RA,RE,MOCOMSVE      RESTORE REGISTER TO PREVIOUS CONDIT
         SPACE 2
         B     MOSTINIT            RETURN FOR NEXT SOURCE CARD
         SPACE 2
MOCLBFND MVC   AVMSYMBL,MCLBNAM    MOVE NAME INTO WORK AREA FOR FIND
         OI    MCLBTAGS,AVMCLBNF   MARK NAME AS SEARCHED FOR
         XCALL XXXXFIND            CALL FIND ROUTINE
         BM    MOCLBMOR            ERROR NOT FOUND -- MESSAGE WILL
*                                  COME OUT LATER
         DROP  RC                  KILL USING
MOCLIBNI $CALL INCARD              CALL INCARD TO READ FROM MACRO
*                                  LIBRARY
         LTR   RB,RB               TEST MAGNITUDE OF RETURN REGISTER
         BNZ   MOCLBER5            ERROR ON NON-ZERO VALUE
         LA    RC,MOCMAC           GET OPCODTB ENTRY FOR MACRO
         $CALL MACRO1              START MACRO DEFINITION PHASE
         B     MOCLBMOR            GO BACK TO PICK UP REST OF NAMES
         SPACE 2
*        ERROR ROUTINES FOLLOW
         SPACE 2
MOCLBER1 LA    RB,$ERSTMNA         SET ERROR-SYSLIB OUT OF ORDER
         $CALL ERRTAG              CALL TO SET ERROR FLAG BIT
         $CALL UTPUT1              SEND ILLEGAL CARD OUT
         B     MOCLBOUT            RETURN
         SPACE 2
MOCLBER2 BAL   RB,MOCERALL         GO FOR COMMON ERROR CODE
         DC    AL2($ERINVSY)       DEFINE ERROR--INVALID SYMBOL
         SPACE 2
MOCLBER3 BAL   RB,MOCERALL         GO FOR COMMON ERROR CODE
         DC    AL2($ERINVDM)       DEFINE ERROR--INVALID DELIMITER
         SPACE 2
MOCLBER4 MVC   RSBLENG(RSB$L+MOCER4LN+1),MOCER4ST  MOVE ERROR IN
         LA    RB,$OUCOMM          SET COMMENT FLAG                   A
         $CALL OUTPT2              PRINT ALLREADY DEFINED ERROR
         B     MOCLBOUT            RETURN
         SPACE 2
MOCLBER5 $CALL ERRTAG              SET ERROR BIT-DEFINED BY INCARD
         B     MOCCOM              GO FOR COMMON RETURN CODE
         SPACE 2
MOCLBER7 MVC   RSBLENG(RSB$L+MOCER7LN+1),MOCER7ST  MOVE THE ERROR IN
MOCCOM   LA    RB,$OUCOMM          SET TO PRINT A COMMENT
         $CALL OUTPT2              PRINT THE MESSAGE
         SR    RB,RB               ER-ZERO RG TO CONTINUE
         BR    RE                  RETURN TO CALLER
MOCERALL LH    RB,0(,RB)           GET THE ERROR FLAG FOR ERRTAG
         LR    RA,R1               MOVE BAD CHAR POINTER OVER
         $CALL ERRTAG              CALL TO SET ERROR BIT
         B     MOCNLSYS            ON BAD CHAR -- PROCESS  WHAT THERE
*                                  IS UP TO THIS POINT
         SPACE 5
         USING MACLIB,RC           NOTE USING ON MACRO LIST
MOCLOOK  SR    RB,RB               ZERO WORK REG FOR END TEST
         B     MOCLOOK2            SKIP FIRST LINK JUMP
MOCLOOK1 L     RC,MCLIBNXT         LINK TO NEXT ENTRY
MOCLOOK2 CLC   AVMSYMBL,MCLBNAM    IS THIS THE ONE WE ARE LOOKING FOR
         BE    MOCLKRT             YESYES -- GO BACK TO PRCESS
         CL    RB,MCLIBNXT         IS THIS THE LAST ENTRY
         BNE   MOCLOOK1            NO -- LINK TO THE NEXT ENTRY
         LA    RB,$ERUNDEF         NAME NOT IN LIST INDICATE THIS
MOCLKRT  BR    RD                  RETURN TO CONTINUE
         SPACE 2
MOCNMADD LA    RE,$LMACLIB         GET LIST ENTRY LENGTH
         $ALLOCL RB,RE,MOCLBOUT    GET LIST SPACE
         ST    RB,MCLIBNXT         LINK LIST TO NEW ENTRY
         DROP  RC                  CLEAR USING
         USING MACLIB,RB           NOTE USING ON MACLIB DSECT
         MVC   MACLIB($LMACLIB),AWZEROS     ZERO NEW ENTRY
         MVC   MCLBNAM,AVMSYMBL    MOVE NAME INTO LIST
         DROP  RB                  KILL USING
         SR    RB,RB               REZERO REGISTER TO CONTINUE
         B     MOCNAMNT            CONTINUE SCAN FOR NEW NAMES
         SPACE 2
MOCOMSVE DS    5F                  TEMP REGISTER SAVE AREA
MOCPRTSV DS    C                   SAVE BYTE FOR PRINT STATUS
MOCMVEL  MVC   AVMSYMBL($),0(RA)   VARIABLE LENGTH NAME MOVE
MOCMAC   DC    AL1($IM,$MACRO,0)   SEE OPG CALL TO MACRO
MOCER4ST DC    AL1(RSB$L+MOCER4LN,$RSBMERR,1,0)  DEFINE THIS ERROR
MOCER4MS DC    C'289 UNABLE TO OPEN MACRO LIBRARY: OPTION CANCELED'
MOCER4LN EQU   *-MOCER4MS          LENGTH OF THE MESSAGE
MOCER7ST DC    AL1(RSB$L+MOCER7LN,$RSBMERR,1,0)  DEFINE THIS ERROR
MOCER7MS DC    C'288 MACRO          COULD NOT BE FOUND'
MOCER7LN EQU   *-MOCER7MS          GET LENGTH OF THE MESSAGE
.MONOMC2 ANOP
         LTORG
         DROP  RAT,R13,RW,RX       CLEAN UP USINGS
         TITLE '*** MPCON0 - ASSIST ASSEMBLER MAIN CONTROL PROGRAM ***'
**--> CSECT: MPCON0   0   MAIN PROGRAM CONTROL-INIT,SET UP TABLES,ETC..
*.       MPCON0 INITIALIZES AVWXTABL DSECT VALUES FOR WHOLE ASSEMBLY, .
*.       SETS A $SPIE TO INTERCEPT SOME TYPES OF INTERRUPTS, SETS THE .
*.       PROGRAM AMSK TO ONLY HAVE FIXED-OVERFLOW INTRPTS, AND CALLS  .
*.       ALL THE SUBROUTINES REQUIRED FOR AN ASSEMBLY IN A TABLE-     .
*.       DRIVEN MANNER, USING A LIST OF POINTERS TO ADDRESS CONSTNATS..
*.       AFTER THE ASSEMBLY IS COMPLETED, IT PRINTS VARIOUS STATISTICS.
*.       AND THEN RETURNS CONTROL TO THE ASSIST MONITOR.  NOTE THAT   .
*.       MPCON0 IS THE ONLY CSECT IN THE ASSEMBLER WHICH ACTUALLY     .
*.       REFERS TO AJOBCON, ALTHOUGH OTHERS USE EQU FLAGS FROM IT.    .
*.       ENTRY CONDITIONS                                             .
*   R12(RAT)= @ VWXTABL CSECT, INITIALIZED BY ASSIST CONTROL PROG.    .
*   AVAJOBPT,AVECONPT HAVE BEEN INITIALIZED IF NEEDED BY ASSIST.      .
*.       CALLS ESINT1,LTINT1,OPINIT,SYINT1,UTINT1,OUINT1,MOCON1       .
*.       CALLS LTEND1,UTEND1,BRINIT,MTCON2                            .
*.       CALLS OUEND2,SYEND2,UTEND2                                   .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $AL2, $CALL, $PRNT, $RETURN, $SAVE, $SPIE       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MPCON0   CSECT
         $DBG  ,NO
         $SAVE RGS=(R14-R12),BR=R13,SA=MPSAVE
         SPACE 1
*              INITIALIZATION FOR ASSEMBLY - OBTAIN VARIOUS VALUES    *
*              FROM AJOBCON. ZERO FLAGS. SET SPIE,PROGRAM MASK.       *
         SPACE 1
         USING AVWXTABL,RAT        NOTE MAIN USING FROM NOW ON
         LM    R2,R3,AVADDLOW      GET ORIG CORE LIMITS FOR STATS LATER
         MVC   AWZEROS+C' '(64),AWZEROS     MAKE SURE ZERO(SEE SCANRS)
         MVC   AVZAREA1(AVZAREA2-AVZAREA1),AWZEROS     ZERO OUT AREA
         MVC   AVRCBPT(7*4),AWZEROS         ZERO AVRCBPT---AVSOLAST
*                                  REQUIRED FOR REPLACE, GOOD DEBUG
         NI    AVTAGS1,255-$IBSTAR1-$IBDSEC1-$IBPRCD1  INIT VALUES
         NI    AVTAGS2,255-$INEND2     CLEAR EOF FLAG
         SPACE 1
         $SPIE ,((7,15)),ACTION=CR,CE=MPSPIEXT   GET CONTROL FOR ERRS
         ST    R1,AVMPSPIE         SAVE @ PREVIOUS SPIE CONTROL BLOCK
         L     R0,=XL4'08000000'   GET MASK FOR SPM (FIXED OVER ONLY)
         SPM   R0                  SET TO STOP ANY FP INTERRUPTS
         SPACE 1
*              SET UP VALUES FOR CALLS TO ALL SUBROUTINES             *
         LA    RZ,MPCALL1          INIT INDEX FOR BXLE CALL LOOP
         LA    RX,2                INCREMENT FOR BXLE
         LA    RY,MPCALL2-2        LIMIT ADDRESS FOR BXLE
         SPACE 1
*              FOLLOWING LOOP PERFORMS ENTIRE ASSEMBLY PROCESS.
MPCALLR  LH    REP,0(,RZ)          GET OFFSET @ FROM OFFSET LIST
         $CALL $BASE(REP)          CALL THE RIGHT ROUTINE
         BXLE  RZ,RX,MPCALLR       LOOP THRU CALL LIST
         EJECT
*              IF 'STOP' BIT SET, FLAG NOLOAD ALSO
         TM    AVTAGS2,AJOASTOP    HAS STOP BIT BEEN SET FOR ANY REASON
         BZ    *+8                 NO, CONTINUE
         OI    AVTAGS1,AJNLOAD     SHOW NO LOAD CAN BE DONE
         SPACE 1
*              CONVERT AND PRINT STORAGE USAGE. NOTE THAT THIS CODE,  *
*              MPCONV, AND DATA MPAT-MPHLEN ARE NOT REQUIRED FOR      *
*              ACTUAL WORKING OF THE PROGRAM, AND COULD BE REMOVED.   *
         LM    R0,R1,AVADDLOW      GET CURRENT FREE AREA POINTERS
         SPACE 1
         SR    R3,R1               AJOTADH -AVADDHIH = HIGH CORE USED
         SR    R0,R2               AVADDLOW-AJOTADL = LOW CORE USED
         LR    R5,R0               SAVE TO CALCULATE TOTAL SPACE.
         S     R1,AVADDLOW         AVADDHIH-AVADDLOW = REMAINING AREA
         LA    R2,MPARL            @ FIRST AREA FOR LOW STORAGE
         BAL   RZ,MPCONV           HAVE LOW VALUE(R0) CONVERTED
         LA    R2,MPARH            ADDRESS OF HIGH AREA USED
         LR    R0,R3               MOVE DIFFERENCE OVER WHERE EXPECTED
         SPACE 1
         BAL   RZ,MPCONV           CALL CONVERTER ROUTINE
         LA    R2,MPREM            @ REMAINING AREA TO BE PRINTED
         LR    R0,R1               MOVE VALUE OVER FOR CONVERTER
         BAL   RZ,MPCONV           CALL CONVERTER
         SPACE 1
*              COMPUTE AVERGAE # BYTES PER STATEMENT USED.
         AR    R5,R3               ADD HIGH USED (R5) TO LOW USED(R3)
         SR    R4,R4               CLEAR SO DIVIDE WORKS OK
         LH    R0,AVSTMTNO         GET # STATEMENTS
         DR    R4,R0               DIVIDE TO GET BYTES/STATEMENT
         LR    R0,R5               MOVE QUOTIENT OVER
         LA    R2,MPBYSTMT         FOR # BYTES/STMT
         BAL   RZ,MPCONV           CALL CONVERTER
         SPACE 1
         $PRNT MPHEAD,MPHLEN       PRINT THE ASSEMBLED LINE
         AIF   (NOT &$XREF).NOXREF9  SKIP IF NO XREF                  A
         TM    AVXRFLAG,AVXRON     DO WE WANT A CROSS REFERENCE       A
         BZ    MPRETA              NO SKIP CALL                       A
         $CALL XRPRNT              CALL CROSS REF PRINT ROUTINE       A
.NOXREF9 ANOP                                                         A
MPRETA   EQU   *
         L     R1,AVMPSPIE         GET @ PREVIOUS SPIE BLOCK BACK
         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS SPIE BLOCK
MPRET    $RETURN RGS=(R14-R12)
         EJECT
*              SPIE EXIT ROUTINE - FLAGS INTERRUPTS 0C7-0CF.          *
         USING MPSPIEXT,R15        NOTE ENTRY PT AT SPIE
MPSPIEXT STM   R14,R12,12(R13)     SAVE ALL THE REGS
         LA    RB,$ERINTPT         SHOW INTERRUPT MESSAGE
         $CALL ERRTAG              CALL ERROR FLAGGING
         LM    R14,R12,12(R13)     RELOAD REGS
         BR    R14                 RETURN TO SUPERVISOR
         DROP  R15                 KILL TEMPORARY USING
         SPACE 1
         SPACE 2
* * * * * MPCONV - CONVERT 1 ADDRESS DIFERENCE  AND EDIT IT           *
*        ENTRY CONDITIONS                                             *
*   R0 = ADDRESS DIFFERENCE TO BE CONVERTED                           *
*   R2 = ADDRESS OF AREA WHERE EDITED VALUE TO BE PUT                 *
*   RZ = RETURN ADDRESS TO CALLING CODE                               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
MPCONV   CVD   R0,AVDWORK1         CONVERT DIFFERENCE TO DECIMAL
         MVC   0(L'MPAT,R2),MPAT   MOVE THE PATTERN IN
         ED    0(L'MPAT,R2),AVDWORK1+8-L'MPAT/2       EDIT VALUE OVER
         BR    RZ                  RETURN TO CALLER
         SPACE 1
* * * * * INTERNAL CONSTANTS                                          *
*              OFFSETS TO ADCONS FOR ROUTINES TO BE CALLED            *
MPCALL1  DS    0H
         $AL2  AX$BASE,(AXESINT1,AXLTINT1,AXOPINIT,AXSYINT1,AXUTINT1)
         AIF   (NOT &$MACROS).MPNOMA1       SKIP IF NO MACRO MODS
         $AL2  AX$BASE,(AXMACINT)      OPCODE INITIALIZATION
.MPNOMA1 ANOP
         AIF   (NOT &$XREF).NOXREF8                                   A
         $AL2  AX$BASE,(AXXRINT1)  XREF INTIALIZATION PASS 1          A
.NOXREF8 ANOP                                                         A
         $AL2  AX$BASE,(AXOUINT1,AXMOCON1)
MPCALL1A $AL2  AX$BASE,(AXLTEND1,AXUTEND1,AXBRINIT)                   A
         AIF   (NOT &$XREF).NOXRF70   SKIP IF NO XREF
         $AL2  AX$BASE,(AXXRINT2)   XREF INITIALIZATION 2ND PASS      1
.NOXRF70 ANOP
         $AL2  AX$BASE,(AXMTCON2)
         $AL2  AX$BASE,(AXOUEND2,AXSYEND2,AXUTEND2)
MPCALL2  EQU   *
         SPACE 1
*              STORAGE USAGE OUTPUT HEADING,EDIT PATTERN              *
MPAT     DC    X'4020202020202120' EDIT PATTERN FOR ADDRESSES
MPHEAD   DC    C'0*** DYNAMIC CORE AREA USED:  LOW:'
MPARL    DS    CL(L'MPAT)          FOR LOW AREA USAGE
         DC    C' HIGH:'
MPARH    DS    CL(L'MPAT)          FOR HIGH AREA USAGE(SYMBOL TABLE)
         DC    C' LEAVING:'
MPREM    DS    CL(L'MPAT)          FOR REMAINING STORAGE
         DC    C' FREE BYTES. AVERAGE: '
MPBYSTMT DS    CL(L'MPAT)          FOR AVERAGE BYTES/STMT
         DC    C' BYTES/STMT ***'
MPHLEN   EQU   *-MPHEAD            DEFINE LENGTH OF AREA
         LTORG
         DROP  RAT,R13             CLEAR UP USING
         TITLE '*** MTCON2 - MAIN CONTROL - PASS 2 ***'
**--> CSECT: MTCON2   2   MAIN CONTROL - ASSEMBLER PASS 2 . . . . . . .
*.       MTCON2 IS THE CONTROL PROGRAM FOR THE 2ND PASS OF THE ASSIST .
*.       OF THE ASSIST ASSEMBLER.  IT IS RELATIVELY SMALL, SINCE      .
*.       MOST OF THE WORK HAS BEEN DONE IN PASS 1.   IT PERFORMS OR   .
*.       SUPERVISES THE FOLLOWING ACTIONS, FOR EACH SOURCE STMT:      .
*.        1. RETRIEVES POINTERS TO THE RECORD BLOCKS (UTGET2).        .
*.        2. SETS UP THE LOCATION COUNTER AND OPERAND SCAN POINTER.   .
*.        3. CALLS 2ND LEVEL INSTRUCTION PROCESSORS(ICMOP2,IDASM2).   .
*.        4. PRINTS ANY STATEMENT WITH NO RCODBLK (OUTPT2).           .
*.       FINISH BY ROUNDING UP LENGTH OF PROG TO DOUBLEWORD BOUNDARY. .
*.       CALLS ICMOP2,IDASM2,OUTPT2,UTGET2                            .
*.       USES DSECTS: AVWXTABL,RCODBLK,RSBLOCK                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE,$SLOC                       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
MTCON2   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN USING
         $SAVE RGS=(R14-R6),SA=MTCOSAVE,BR=R13
         SR    R2,R2               CLEAR FOR INSERTIONS
         MVI   AVCESDID,2          INIT TO VALUE IN CASEE UNIT PRIV CD
         SPACE 1
*              MTGET2 ENTERED 1 TIME FOR EACH STATEMENT. CALLS UTGET2 *
*        TO GET @'S OF RECORD BLOCKS.  @ RSBLOCK IS RETURNED IN RC,   *
*        AND ALL EXISTING VALUES HAVE BEEN FILLED IN FOR RECORD PTRS. *
         SPACE 1
MTGET2   EQU   *                   ENTRY FOR LOOP HEAD FOR 1 STMT
*              IF 'STOP' BIT SET BY ANYONE, QUIT NOW.
         TM    AVTAGS2,AJOASTOP    HAS IT BEEN SET
         BO    MTRET               YES, QUIT
         SPACE 1
         $CALL UTGET2              CALL TO OBTAIN NEXT BLOCKS
         LTR   RE,RE               WAS THIS THE END
         BNZ   MTENDOF             YES,NO MORE TO DO-QUIT
         LR    RE,RC               MOVE @ RSBLOCK OVER
         USING RSBLOCK,RE          NOTE POINTER
         TM    RSBFLAG,$RCBX       DOES A RCB EXIST
         BZ    MTPRINT             NO IT DOESN'T,EITHER ERROR OR COMM
         SPACE 1
*              GET INFORMATION FROM RCODBLK. SRT UP FOR LEVEL 2 SUBRS.
         L     RC,AVRCBPT          GET @ RCODBLK BACK INTO REG
         USING RCODBLK,RC          NOTE THIS USING
         IC    R2,RSBSCAN          GET SCAN POINTER TO BEGINNING OF OPE
         LA    RA,RSBLOCK(R2)      GET @ OPERAND FIELD
         L     RD,RCLOC-1          GET THE LOCATION COUNTER FOR STMT
         LA    RD,0(RD)            REMOVE 1ST BYTE
         $SLOC RD                  SET THE LOCATION COUNTER
         SPACE 1
*              CHOOSE CORRECT 2ND-LEVEL PROCESSOR.
         TM    RCTYPE,$IB          MAKE TYPE TEST
         BO    MTCID               BRANCH TO CALL ASSEMBLER ROUTINE
         AIF   (NOT &$SPECIO).MTNOSPC       SKIP IF NO SPECIALS
         BZ    MTCID               BRANCH IF ASSEMBLER INSTRUCTIONS
*              FALLS THRU ==> SPECIAL INST                            *
         IC    R2,RCTYPE           GET TYPE BYTE
         SLL   R2,2                *4 FOR FULLWORD @ INDEXING
         $CALL SPECA2-4*$IS(R2)    GET 2ND PASS SPECIAL ROUTINES
         B     MTGET2              GO GET NEXT RECORD
.MTNOSPC ANOP
MTCIC    $CALL ICMOP2              PASS 2 MACHINE INSTRUCTIONS
         B     MTGET2              GO GET NEXT ONE
         SPACE 1
MTCID    $CALL IDASM2              ASSEMBLER INSTRUCTIONS
         B     MTGET2              GO GET NEXT ONE
         SPACE 1
MTPRINT  LA    RB,$OUCOMM          SHOW OUTPT2 NO LOCCNTR OR CODE
         $CALL OUTPT2              CALL PRINTER ROUTINE
         AIF   (NOT &$XREF).NOXRF13                                   A
*   CHECK FOR THE * XREF CARD                                         A
         CLI   RSBSOURC,C'*'       IS IT A COMMENT CARD               A
         BNE   MTNXREFF            NO, CAN'T BE * XREF CARD           A
         CLC   RSBSOURC+1(4),=C'XREF'  IS IT XREF                     A
         BNE   MTNXREFF            NO, GO ON                          A
         LA    RA,RSBSOURC+5       FOR ENTRY TO XRSCAN (@ TO BEGIN)   L
         LA    RD,8                SET ENTRY CONDITIONS TO XRSCAN     L
         $CALL XRSCAN              CALL SCANNING ROUTINE              A
MTNXREFF EQU   *                                                      A
.NOXRF13 ANOP                                                         A
         B     MTGET2              GO GET NEXT ONE
MTENDOF  EQU   *
*              ALIGN LENGTH OF PROG TO MULTIPLE OF 8.
         L     R0,AVLOCHIH         GET HIGHEST LOCATION COUNTER  VALUE
         LA    R1,7                GET VALUE FOR DOUBLEWORD ALIGN
         $ALIGR R0,R1              ALIGN UP TO DOUBLEWORD BOUNDARY
         ST    R0,AVLOCHIH         RESTORE UPDATED,ALIGNED VALUE
         S     R0,AVLOCLOW         LENGTH= HIGH LOCATION-LOW LOCATION
         A     R0,AVRADL           + LOWEST REAL LOCATION
         ST    R0,AVRADH           = HIGH LIMIT FOR REAL @'S
MTRET    $RETURN RGS=(R14-R6)
         DROP  RAT,RC,RE,R13       CLEAR USINGS
         LTORG                                                        A
         TITLE '*** OPCOD1 - IDENTIFY MNEMONIC OPERATION CODES ***'
**--> CSECT: OPCOD1   1   OPCODE TABLES AND LOOKUP CODE . . . . . . . .
*.       THIS MODULE CONTAINS THE CODE,TABLES TO IDENTIFY OPCODES.    .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OPCOD1   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
OP1      EQU   IAL2+1              COMMON MASK FIELD==>LIT ALLOWED,H AL
OP3      EQU   IAL2+3              MASK FIELD==>LIT ALLOWED, FULL ALIG
OP7      EQU   IAL2+7              MASK FIELD==>LIT ALLOWED,D ALIGN
IAR      EQU   IAA+IAB             MASK FIELD==>R1 AND R2 MUST BE EVEN
         ENTRY OPINIT,OPFIND
         SPACE 2
**--> ENTRY: OPINIT   1   INITILIAZE OPCODE ROUTINE IF NEEDED . . . . .
*.       AS OF 8/17/70, THIS ENTRY DOES NOTHING. IT IS INCLUDED FOR   .
*.       COMPLETENESS, POSSIBLE MODIFICATION REQUIRING INITIALIZATION..
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OPINIT   BR    R14                 RETURN-NOTHING TO DO NOW
         SPACE 2
**--> ENTRY: OPFIND   1   LOOK UP AN OPCODE . . . . . . . . . . . . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO 1ST CHARACTER OF OPCODE                      .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO 1ST BLANK FOLLOWING LEGAL OPCODE,OR SAME AS O.
*.       ENTRY IF OPCODE WAS NOT RECOGNIZED.                          .
*.  RB = 0 IF THE OPCODE WAS FOUND IN OPCODE TABLE                    .
*.  RB = NONZERO VALUE - ERROR CODE FOR ILLEGAL OPCODE ($ERIVOPC)     .
*.  RC = ADDRESS OF OPCODTB ENTRY FOR THE OPCODE, IF IT WAS FOUND     .
*.       USES DSECTS: AVWXTABL,OPCODTB                                .
*.       USES MACROS: $RETURN,$SAVE,OPG,OPGT                          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OPFIND   $SAVE RGS=(R1-R2),SA=NO
         CLI   0(RA),C'A'          MAKE SURE NO ILLEGAL
         BL    OPFERR              ILLEGAL,NOTE ERROR
         LR    R1,RA               DUPLICATE THE SCAN POINTER
         LA    RE,6(R1)            GET THE LIMIT FOR THE BXLE
         LA    RD,1                GET INCREMENT FOR BXLE
         SPACE 1
*              SCAN LOOP TO FIND END OF MNEMONIC                      *
OPFLOOP  CLI   1(R1),C' '          LOOK FOR BLANK
         BE    OPFLNG              BLANK FOUND-END OF OPCODE
         BXLE  R1,RD,OPFLOOP       CONTINUE SEARCHING
         B     OPFERR              ERROR- NOT RIGHT SIZE
         SPACE 1
*              END OF MNEMONIC FOUND, GET POINTERS ET UP FOR LOOKUP   *
OPFLNG   LR    R2,R1               DUPLICATE PT TO LAST CHAR OF OPCODE
         SR    R2,RA               GET LENGTH-1 OF OPCODE = 0-7
         STC   R2,OPFCOMP+1        PLACE INTO CLC INSTRUCTION
         LA    RD,OPCMNEM-OPCODTB+1(R2)      GET TOTAL LENGTH OF ENTRY
         IC    R2,OPFL1(R2)        GET 1ST OFFSET VALUE,DEPNDING ON LEN
         LTR   R2,R2               MAKE SURE THERE ARE SOME OF THIS LEN
         BZ    OPFERR              NO THERE AREN'T-ERROR
         SPACE 1
         LA    RE,OPADS(R2)        ADDR OF RIGHT TABLE SET
         IC    R2,0(RA)            GET THE 1ST CHAR OF OPCODE
         IC    R2,OPFCH1-C'A'(R2)  GET 2ND OFFSET VALUE FOR LETTERS
         LH    RC,0(R2,RE)         GET THE CORRECT POINTER
         AR    RC,R15              ADD ADDRESS OF OPFIND TO GET REAL AD
         USING OPCODTB,RC          NOTE DSECT FOR TABLE ENTRY
         LH    RE,2(R2,RE)         GET THE LIMIT ADDRESS IN TABLE
         AR    RE,R15              ADD TO GET REAL ADDRESS
         SPACE 1
*              SEARCH LOOP TO LOOK UP MNEMONIC                        *
OPFCOMP  CLC   0($CHN,RA),OPCMNEM  COMPARE MNEMONIC WITH TABLE ENTRY
         BNH   OPFCHK              IF NOT HIGH, EITHER SAME, OR NO GOOD
         BXLE  RC,RD,OPFCOMP       CONTINUE LOOPING
OPFCHK   BNE   OPFERR              NE==>ERROR(GET LOOP FALL THRU TOO)
         SPACE 1
         SR    RB,RB               CLEAR RB TO SHOW OK.
         LA    RA,1(R1)            UPDATE SCAN POINTER TO BLANK
OPFRET   $RETURN RGS=(R1-R2),SA=NO
OPFERR   LA    RB,$ERIVOPC         INVALID OPCODE
         B     OPFRET              RETURN
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
*        1ST LEVEL POINTER TABLE-HAS OFFSET ADDRESSES OF POINTER SETS *
*        BELONGING TO EACH USABLE OPCODE LENGTH FROM 1 TO 8.          *
OPFL1    DC    AL1(OPF1-OPADS,OPF2-OPADS,OPF3-OPADS,OPF4-OPADS,OPF5-OPA#
               DS,OPF6-OPADS,OPF7-OPADS,OPF8-OPADS)
         SPACE 2
*        INDIVIDUAL OPCODTB ENTRY TABLES, IN ORDER BY LENGTH, THEN    *
*        ALPHABETICALLY WITHIN LENGTH                                 *
         SPACE 1
*              1-CHARACTER INSTRUCTIONS                               *
OP1A     EQU   *
         OPG   A,$RX,90,OP3        ADD
OP1B     EQU   *
         OPG   B,$RXM,71,X'F0'+1   BRANCH
OP1C     EQU   *
         OPG   C,$RX,89,OP3        COMPARE
OP1D     EQU   *
         OPG   D,$RX,93,OP3+IAA    DIVIDE
OP1L     EQU   *
         OPG   L,$RX,88,OP3        LOAD
OP1M     EQU   *
         OPG   M,$RX,92,OP3+IAA    MULTIPLY
OP1N     EQU   *
         OPG   N,$RX,84,OP3        AND
         OPG   O,$RX,86,OP3        OR
OP1S     EQU   *
         OPG   S,$RX,91,OP3        SUBTRACT
OP1T     EQU   *
         OPG   X,$RX,87,OP3        EXCLUSIVE OR
OP1END   EQU   *
         EJECT
*              2-CHARACTER INSTRUCTIONS                               *
OP2A     EQU   *
         OPG   AD,$RX,106,OP7+IAA,F    ADD NORM LONG
         OPG   AE,$RX,122,OP3+IAA,F    ADD NORM SHORT
         OPG   AH,$RX,74,OP1       ADD HALFWORD
         OPG   AL,$RX,94,OP3       ADD LOGICAL
         OPG   AP,$SS2,250,IAL2,D  ADD DECIMAL
         OPG   AR,$RR,26           ADD REGISTER
         OPG   AU,$RX,126,OP3+IAA,F    ADD UNNORM SHORT
         OPG   AW,$RX,110,OP7+IAA,F    ADD UNNORM LONG
OP2B     EQU   *
         OPG   BC,$RX,71,1         BRANCH ON CONDITION
         OPG   BE,$RXM,71,X'80'+1  BRANCH ON EQUAL
         OPG   BH,$RXM,71,X'20'+1  BRANCH ON HIGH
         OPG   BL,$RXM,71,X'40'+1  BRANCH ON LOW
         OPG   BM,$RXM,71,X'40'+1  BRANHC ON MINUS
         OPG   BO,$RXM,71,X'10'+1  BRANCH ON ONES
         OPG   BP,$RXM,71,X'20'+1  BRANCH ON PLUS
         OPG   BR,$RRM,7,X'F0'     BRANCH REGISTER
         OPG   BZ,$RXM,71,X'80'+1  BRANCH ON ZERO
OP2C     EQU   *
         OPG   CD,$RX,105,OP7+IAA,F    COMPARE LONG
         OPG   CE,$RX,121,OP3+IAA,F    COMPARE SHORT
         OPG   CH,$RX,73,OP1       COMPARE HALFWORD
         OPG   CL,$RX,85,OP3       COMPARE LOGICAL
         OPG   CP,$SS2,249,IAL1+IAL2,D       COMPARE DECIMAL
         OPG   CR,$RR,25           COMPARE REGISTER
OP2D     EQU   *
         OPG   DC,$IDC+$IB,$IBSTAR1          DEFINE CONSTANT
         OPG   DD,$RX,109,OP7+IAA,F    DIVIDE LONG
         OPG   DE,$RX,125,OP3+IAA,F    DIVIDE SHORT
         OPG   DP,$SS2,253,IAL2,D  DIVIDE DECIMAL
         OPG   DR,$RR,29,IAA       DIVIDE REGISTER
         OPG   DS,$IDS+$IB,$IBSTAR1          DEFINE STORAGE
         OPG   ED,$SS,222,IAL2,D   EDIT
         OPG   EX,$RX,68,OP1       EXECUTE
         OPG   IC,$RX,67,IAL2      INSERT CHARACTER
OP2L     EQU   *
         OPG   LA,$RX,65,IAL2      LOAD ADDRESS
         OPG   LD,$RX,104,OP7+IAA,F    LOAD LONG
         OPG   LE,$RX,120,OP3+IAA,F    LOAD SHORT
         OPG   LH,$RX,72,OP1       LOAD HALFWORD
         OPG   LM,$RS,152,OP3      LOAD MULTIPLE
         OPG   LR,$RR,24           LOAD REGISTER
         EJECT
OP2M     EQU   *
         OPG   MD,$RX,108,OP7+IAA,F    MULTIPLY LONG
         OPG   ME,$RX,124,OP3+IAA,F    MULTIPLY SHORT
         OPG   MH,$RX,76,OP1       MULTIPLY HALFWORD
         OPG   MP,$SS2,252,IAL2,D  MULTIPLY DECIMAL
         OPG   MR,$RR,28,IAA       MULTIPLY REGISTER
OP2N     EQU   *
         OPG   NC,$SS,212,IAL2     AND CHARACTER
         OPG   NI,$SI,148          AND IMMEDIATE
         OPG   NR,$RR,20           AND REGISTER
         OPG   OC,$SS,214,IAL2     OR CHARACTER
         OPG   OI,$SI,150          OR IMMEDIATE
         OPG   OR,$RR,22           OR REGISTER
OP2S     EQU   *
         OPG   SD,$RX,107,OP7+IAA,F    SUBTRACT NORM LONG
         OPG   SE,$RX,123,OP3+IAA,F    SUBTRACT NORM SHORT
         OPG   SH,$RX,75,OP1       SUBTRACT HALFWORD
         OPG   SL,$RX,95,OP3       SUBTRACT LOGICAL
         OPG   SP,$SS2,251,IAL2,D  SUBTRACT DECIMAL
         OPG   SR,$RR,27           SUBTRACT REGISTER
         OPG   ST,$RX,80,3         STORE
         OPG   SU,$RX,127,OP3+IAA,F    SUBTRACT UNNORM SHORT
         OPG   SW,$RX,111,OP7+IAA,F    SUBTRACT UNNORM LONG
OP2T     EQU   *
         OPG   TM,$SI,145,IAL1     TEST UNDER MASK
         OPG   TR,$SS,220,IAL2     TRANSLATE
         OPG   TS,$RSO,147         TEST AND SET (ONLY NON-PRIV TYPE)
         OPG   XC,$SS,215,IAL2     EXCLUSIVE OR CHARACTER
         OPG   XI,$SI,151          EXCLUSIVE OR IMMEDIATE
         OPG   XR,$RR,23           EXCLUSIVE OR REGISTER
OP2END   EQU   *
         EJECT
*              3-CHARACTER INSTRUCTIONS                               *
OP3A     EQU   *
         OPG   ADR,$RR,42,IAR,F       ADD NORM LONG REGISTER
         OPG   AER,$RR,58,IAR,F       ADD NORM SHORT REGISTER
         OPG   AGO,$IM,$AGO,,M
         OPG   AIF,$IM,$AIF,,M
         OPG   ALR,$RR,30          ADD LOGICAL REGISTER
         OPG   AUR,$RR,62,IAR,F       ADD UNNORM SHORT REGISTER
         OPG   AWR,$RR,46,IAR,F       ADD UNNORM LONG REGISTER
         OPG   AXR,$RR,54,IAR,FX        ADD EXTENDED REGISTER
OP3B     EQU   *
         OPG   BAL,$RX,69,1        BRANCH AND LINK
         OPG   BCR,$RR,7           BRANCH ON CONDITION REGISTER
         OPG   BCT,$RX,70,1        BRANCH ON COUNT
         OPG   BER,$RRM,7,X'80'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BHR,$RRM,7,X'20'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BLR,$RRM,7,X'40'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BMR,$RRM,7,X'40'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNE,$RXM,71,X'70'+1 BRANCH ON NOT EQUAL
         OPG   BNH,$RXM,71,X'D0'+1 BRANCH ON NOT HIGH
         OPG   BNL,$RXM,71,X'B0'+1 BRANCH ON NOT LOW
         OPG   BNM,$RXM,71,X'B0'+1 BRANCH ON NOT MINUS
         OPG   BNO,$RXM,71,X'E0'+1 BRANCH ON NOT ONES
         OPG   BNP,$RXM,71,X'D0'+1 BRANCH ON NOT PLUS
         OPG   BNZ,$RXM,71,X'70'+1 BRANCH ON NOT ZERO
         OPG   BOR,$RRM,7,X'10'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BPR,$RRM,7,X'20'    **EXTENDED BRANCH MNEMONIC**       J
         OPG   BXH,$RS,134,1       BRANCH ON INDEX HIGH
         OPG   BZR,$RRM,7,X'80'    **EXTENDED BRANCH MNEMONIC**       J
OP3C     EQU   *
         OPG   CCW,$ICCW+$IB,$IBSTAR1,7,P    CHANNEL COMMAND WORD
         OPG   CDR,$RR,41,IAR,F       COMPARE LONG REGISTER
         OPG   CER,$RR,57,IAR,F       COMAPRE SHORT REGISTER
         OPG   CLC,$SS,213,IAL1+IAL2         COMPARE LOGICAL CHARACTER
         OPG   CLI,$SI,149,IAL1    COMPARE LOGICAL IMMEDIATE
         OPG   CLM,$RS,189,IAL2,S370    COMPARE LOGICAL UNDER MASK
         OPG   CLR,$RR,21          COMPARE LOGICAL REGISTER
         OPG   CVB,$RX,79,OP7      CONVERT TO BINARY
         OPG   CVD,$RX,78,7        CONVERT TO DECIMAL
OP3D     EQU   *
         OPG   DDR,$RR,45,IAR,F       DIVIDE LONG REGISTER
         OPG   DER,$RR,61,IAR,F       DIVIDE SHORT REGISTER
         OPG   END,$IEND+$IB,IBOMOP+IBNONAM+IBMOSPEC  END
         OPG   EQU,$IEQU+$IB,IBNENAM+$IBSTAR1,1        EQUATE
         OPG   HDR,$RR,36,IAR,F       HALVE LONG
         OPG   HER,$RR,52,IAR,F       HALVE SHORT
         OPG   HIO,$RSO,158,,P     HALT I/O
         OPG   ICM,$RS,191,IAL2,S370    INSERT CHARACTERS UNDER MASK
         OPG   ISK,$RR,9,,P        INSERT STORAGE KEY
OP3L     EQU   *
         OPG   LCR,$RR,19          LOAD COMPLEMENT REGISTER
         OPG   LDR,$RR,40,IAR,F       LOAD LONG REGISTER
         OPG   LER,$RR,56,IAR,F       LOAD SHORT REGISTER
         OPG   LNR,$RR,17          LOAD NEGATIVE REGISTER
         OPG   LPR,$RR,16          LOAD POSITIVE REGISTER
         OPG   LTR,$RR,18          LOAD AND TEST REGISTER
         EJECT
OP3M     EQU   *
         OPG   MDR,$RR,44,IAR,F       MULTIPLY LONG REGISTR
         OPG   MER,$RR,60,IAR,F       MULTIPLY SHORT REGISTER
         OPG   MVC,$SS,210,IAL2    MOVE CHARACTER
         OPG   MVI,$SI,146         MOVE IMMEDIATE
         OPG   MVN,$SS,209,IAL2    MOVE NUMERICS
         OPG   MVO,$SS2,241,IAL2   MOVE WITH OFFSET (2 LENGTHS)
         OPG   MVZ,$SS,211,IAL2    MOVE ZONES
         OPG   MXD,$RX,103,IAA+OP7,FX   MULTIPLY EXTENDED/LONG
         OPG   MXR,$RR,38,IAR,FX        MULTIPLY EXTENDED REGISTER
OP3N     EQU   *
         OPG   NOP,$RXM,71,X'00'+1 NO OPERATION
         OPG   ORG,$IORG+$IB,IBNONAM+IBOMOP+$IBSTAR1   ORIGIN
         OPG   RDD,$SI,133,,P      READ DIRECT
OP3S     EQU   *
         OPG   SCK,$RSO,178,X'40'+OP7,P370   SET CLOCK
         OPG   SDR,$RR,43,IAR,F       SUBTRACT NORM LONG REGISTER
         OPG   SER,$RR,59,IAR,F       SUBTRACT NORM SHORT REGISTER
         OPG   SIO,$RSO,156,,P     START I/O
         OPG   SLA,$RSH,139,IAL2   SHIFT LEFT ALGEBRAIC
         OPG   SLL,$RSH,137,IAL2   SHIFT LEFT LOGICAL
         OPG   SLR,$RR,31          SUBTRACT LOGICAL REGISTER
         OPG   SPM,$RSO,4
         OPG   SRA,$RSH,138,IAL2   SHIFT RIGHT ALGEBRAIC
         OPG   SRL,$RSH,136,IAL2   SHIFT RIGHT LOGICAL
         OPG   SRP,$SS2,240,,S370   SHIFT AND ROUND PACKED
         OPG   SSK,$RR,8,,P        SET STORAGE KEY
         OPG   SSM,$RSO,128,,P     SET SYSTEM MASK
         OPG   STC,$RX,66          STORE CHARACTER
         OPG   STD,$RX,96,7+IAA,F      STORE LONG
         OPG   STE,$RX,112,3+IAA,F     STORE SHORT
         OPG   STH,$RX,64,1        STORE HALFWORD
         OPG   STM,$RS,144,3       STORE MULTIPLE
         OPG   SUR,$RR,63,IAR,F       SUBTRACT UNNORM SHORT REGISTER
         OPG   SVC,$RSO,10         SUPERVISOR CALL
         OPG   SWR,$RR,47,IAR,F       SUBTRACT UNNORM LONG REGISTER
         OPG   SXR,$RR,55,IAR,FX        SUBTRACT EXTENDED REGISTER
OP3T     EQU   *
         OPG   TCH,$RSO,159,,P     TEST CHANNEL
         OPG   TIO,$RSO,157,,P     TEST I/O
         OPG   TRT,$SS,221,IAL1+IAL2         TRANSLATE AND TEST
         OPG   WRD,$SI,132,,P      WRITE DIRECT
         OPG   ZAP,$SS2,248,IAL2,D ZERO AND ADD DECIMAL
OP3END   EQU   *
         EJECT
*              4-CHARACTER INSTRUCTIONS                               *
OP4A     EQU   *
         OPG   ACTR,$IM,$ACTR,,M
         OPG   ANOP,$IM,$ANOP,,M
OP4B     EQU   *
         OPG   BALR,$RR,5          BRANCH AND LINK REGISTER
         OPG   BCTR,$RR,6          BRANCH ON COUNT REGISTER
         OPG   BNER,$RRM,7,X'70'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNHR,$RRM,7,X'D0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNLR,$RRM,7,X'B0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNMR,$RRM,7,X'B0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNOR,$RRM,7,X'E0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNPR,$RRM,7,X'D0'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BNZR,$RRM,7,X'70'   **EXTENDED BRANCH MNEMONIC**       J
         OPG   BXLE,$RS,135,1      BRANCH INDEX LOW OR EQUAL          J
OP4C     EQU   *
         OPG   CLCL,$RR,15,IAR,S370     COMPARE LOGICAL CHARACTERS LONG
         OPG   CNOP,$ICNOP+$IB,IBNONAM+$IBSTAR1        CONDITIONAL NOP
OP4D     EQU   *
         AIF   (&$DEBUG).OPDIAG    SKIP DIAGNOSE IF NOT DEBUG MODE
         OPG   DIAG,$SI,131        DIAGNOSE(EXECUT EQUIV OF DEBUG)
.OPDIAG  ANOP
         OPG   DROP,$IDROP+$IB,IBNONAM       DROP REGISTER
         OPG   EDMK,$SS,223,IAL2,D EDIT AND MARK
         OPG   GBLA,$IM,$GBLA,$ARITH,M
         OPG   GBLB,$IM,$GBLB,$BOOL,M
         OPG   GBLC,$IM,$GBLC,$CHAR,M
OP4L     EQU   *
         OPG   LCDR,$RR,35,IAR,F      LOAD COMPLEMENT LONG REGISTER
         OPG   LCER,$RR,51,IAR,F      LOAD COMPLEMENT SHORT REGISTER
         OPG   LCLA,$IM,$LCLA,$ARITH,M
         OPG   LCLB,$IM,$LCLB,$BOOL,M
         OPG   LCLC,$IM,$LCLC,$CHAR,M
         OPG   LCTL,$RS,183,OP3,P370    LOAD CONTROL
         OPG   LNDR,$RR,33,IAR,F      LOAD NEGATIVE LONG REGISTER
         OPG   LNER,$RR,49,IAR,F      LOAD NEGATIVE SHORT REGISTER
         OPG   LPDR,$RR,32,IAR,F      LOAD POSITIVE LONG REGISTER
         OPG   LPER,$RR,48,IAR,F      LOAD POSITIVE SHORT REGISTER
         OPG   LPSW,$RSO,130,7,P   LOAD PROGRAM STATUS WORD
         OPG   LRDR,$RR,37,IAR,FX       LOAD ROUNDED EXTENDED ==> LONG
         OPG   LRER,$RR,53,IAR,FX     LOAD ROUNDED LONG ==> SHORT
         OPG   LTDR,$RR,34,IAR,F      LOAD AND TEST LONG REGISTER
         OPG   LTER,$RR,50,IAR,F      LOAD AND TEST SHORT REGISTER
OP4M     EQU   *
         OPG   MEND,$IM,$MEND,,M
         OPG   MVCL,$RR,14,IAR,S370     MOVE CHARACTERS LONG
         OPG   MXDR,$RR,39,IAR,FX       MULTIPLY EXTENDED / LONG REG
OP4N     EQU   *
         OPG   NOPR,$RRM,7,X'00'   NO OPERATION
         OPG   PACK,$SS2,242,IAL2  PACK
OP4S     EQU   *
         OPG   SETA,$IM,$SETA,$ARITH,M
         OPG   SETB,$IM,$SETB,$BOOL,M
         OPG   SETC,$IM,$SETC,$CHAR,M
         OPG   SIOF,$RSO,156,X'10',P370      START I/O FAST
         OPG   SLDA,$RSH,143,IAL2+IAA        SHIFT LEFT DOUBLE ALGEBRAI
         OPG   SLDL,$RSH,141,IAL2+IAA        SHIFT LEFT DOUBLE LOGICAL
         OPG   SRDA,$RSH,142,IAL2+IAA        SHIFT RIGHT DOUBLE ALGEBRA
         OPG   SRDL,$RSH,140,IAL2+IAA        SHIFT RIGHT DOUBLE LOGICAL
         OPG   STCK,$RSO,178,X'50',P370      STORE CLOCK
         OPG   STCM,$RS,190,,S370       STORE CHARACTERS UNDER MASK
OP4T     EQU   *
         OPG   UNPK,$SS2,243,IAL2  UNPACK
         AIF   (&$XXIOS).OP4TSK1   SKIP IF NO XGETS ALLOWED     CPP
         OPG   XGET,$SPC,224,X'A0'  GENERAL INPUT              D
.OP4TSK1 AIF   (NOT &$EXINT).OP4TSK2  SKIP IF NO XOPC'S         CPP
         OPG   XOPC,$RSO,1         EXTENDED USER DEBUG CONTROL INSTR
.OP4TSK2 AIF   (&$XXIOS).OP4TSK    SKIP IF NO XPUTS ALLOWED     CPP
         OPG    XPUT,$SPC,224,X'C0'+IAL2  GENERAL OUTPUT OP           J
.OP4TSK  ANOP
OP4END   EQU   *
         EJECT
*              5-CHARACTER INSTRUCTIONS                               *
OP5A     EQU   *
OP5B     EQU   *
OP5C     EQU   *
         OPG   CSECT,$ICSECT+$IB,IBOMOP      CSECT
OP5D     EQU   *
         AIF   (&$DEBUG).OPNOD1    SKIP IF NOT DEBUG MODE
         OPG   DEBUG,$IDEBUG+$IB   DEBUG FLAG SETTING OPCODE
.OPNOD1  ANOP
         OPG   DSECT,$IDSECT+$IB,IBOMOP+IBNENAM        DUMMY SECTION
         OPG   EJECT,$IEJECT+$IB,IBNONAM+IBOMOP+IBMOPRCX,255 EJECT
         OPG   ENTRY,$IENTRY+$IB,IBNONAM     ENTRY DECLARATION
         OPG   EXTRN,$IEXTRN+$IB,IBNONAM     EXTERNAL DECLARATION
OP5L     EQU   *
         OPG   LTORG,$ILTORG+$IB,IBOMOP+$IBSTAR1       LTORG
OP5M     EQU   *
         OPG   MACRO,$IM,$MACRO,,M
         OPG   MEXIT,$IM,$MEXIT,,M
         OPG   MNOTE,$IM,$MNOTE,,M
OP5N     EQU   *
         OPG   PRINT,$IPRINT+$IB,IBNONAM+IBMOPRCX,$IBPON+$IBPGEN
OP5S     EQU   *
         OPG   SPACE,$ISPACE+$IB,IBNONAM+IBOMOP+IBMOPRCX,1 SPACE
         OPG   START,$ISTART+$IB,IBOMOP      START
         OPG   STCTL,$RS,182,3,P370    STORE CONTROL
         OPG   STIDC,$RSO,178,X'30',P370     STORE CHANNEL ID
         OPG   STIDP,$RSO,178,X'20',P370     STORE CPU ID
OP5T     EQU   *
         OPG   TITLE,$ITITLE+$IB,IBNONAM+IBMOPRCX,0   TITLE
         OPG   USING,$IUSING+$IB,IBNONAM+$IBSTAR1      USING
         AIF   (NOT &$XIOS).OPNOXIO          SKIP IF NO XIOS WANTED
         OPG   XDECI,$RX,83        DECIMAL INPUT
         OPG   XDECO,$RX,82        DECIMAL OUTPUT
         OPG   XDUMP,$SPC,224,X'60'+IAL2     DUMP
         AIF   (NOT &$HEXI).OPNOHXI    SKIP IF NO XHEXI
         OPG   XHEXI,$RX,97            OP CODE FOR XHEXI
.OPNOHXI ANOP
         AIF   (NOT &$HEXO).OPNOHXO    SKIP IF NO XHEXO
         OPG   XHEXO,$RX,98            OP CODE FOR XHEXO
.OPNOHXO ANOP
         AIF   (NOT &$XIOS).OPNOXIO  SKIP IF NO X-I/O PSEUDOS   CPP
         OPG   XLIMD,$SPC,224,X'80'    LIMIT AREA (COMPLETION DUMP)
         OPG   XPNCH,$SPC,224,X'40'+IAL2     PUNCH
         OPG   XPRNT,$SPC,224,X'20'+IAL2     PRINT
         OPG   XREAD,$SPC,224,X'00'          READ
.OPNOXIO ANOP
         AIF   (&$REPL EQ 0).OPNREPL        SKIP IF NOT REPLACE
         OPG   XREPL,$SI,160       XREPL SPECIAL COMMAND
.OPNREPL ANOP
OP5END   EQU   *
         SPACE 2
*        SECOND LEVEL OFFSET TABLE - HAS POINTERS FOR EACH BEGINNING  *
*        CHARACTER, IN TABLE DETERMINED BY LENGTH.                    *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
OPFCH1   DC      X'000204060606060606060606060606'     C
         DC    X'060606080A0C0C0C0C0C0C0C0C0C0C0C'     D
         DC    X'0C0C0E10101010101010101010101010'     E
         DC    X'10101010101010101010101010101010'     F
         SPACE 2
*        OFFSET VALUES INTO OPCODTB ENTRY AREA                        *
OPADS    DS    H                   BASE ADDRESS OF 2ND LEVEL OFFSET TAB
         OPGT
         DROP  REP,RC              CLEAN UP USINGS
         TITLE '*** OUTPUT - SOURCE AND OBJECT LISTING ***'
**--> CSECT: OUTPUT       PRINTED LISTING ROUTINE . . . . . . . . . . .
*.       OUTPUT HANDLES THE FORMATTING AND PRINTING OF THE ASSEMBLY   .
*.       LISTING FOR THE ASSIST ASSEMBLER.                            .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OUTPUT   CSECT
         $DBG  C0,SNAP
         ENTRY OUINT1,OUTPT2,OUEND2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 1
*              LIST OF LINE/PAGE CONTROL EQUATE VALUES FOLLOWS.
$OU#LNS  EQU   60                  MAXIMUM PRINTED LINES/PAGE
OUH#     EQU   3                   # LINES USED BY STANDARD HEADING
$OU#NORM EQU   $OU#LNS-OUH#        NORMAL LINES/PAGE FOR ACTIAL STMTS
$OU#PAG1 EQU   $OU#NORM-5          # LINES FOR STMTS ON 1ST PAGE ONLY
         SPACE 1
**--> ENTRY: OUINT1   1   INITIALIZATION ENTRY - CALLED BEFORE PASS 1 .
*.       OUINT1 IS CALLED TO INITIALIZE FLAG VALUES AND COUNTERS      .
*.       USED IN OUTPUT, INCLUDING LISTING CONTROL, STATEMENT #,      .
*.       PAGE COUNT, WITHIN-PAGE LINE COUNT, AND TITLE AREA.          .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
OUINT1   $SAVE SA=NO
         AIF   (&$COMNT EQ 0).OUNCOM1       SKIP IF NO COMMENT CHK
         MVC   AVMACHIN(4),AWZEROS ZERO VARIABLES(SEE IAMOP1 CSECT)
.OUNCOM1 ANOP
         MVI   AVPRINT,$IBPON+$IBPGEN       PRINT ON,GEN,NODATA
         TM    AVTAGS1,AJNLIST     IS LIST ON         OR OFF
         BO    *+8                 SKIP IF LIST IS OFF
         OI    AVPRINT,$IBPLIST    SHOW LIST IS ON FOR LATER TEST
         MVC   AVPRINT1,AVPRINT    COPY VALUE FOR USE DURING PASS 1
         ZAP   OULNCNT,AWP1        SET CURRENT STMT # = 1
         ZAP   OUPGCNT,AWP0        SET PAGE COUNT TO ZERO LASO
         MVC   OUCOUNT,AWH1        INIT WITHIN PAGE COUNT TO 1
         MVC   OUHEADNG,AWBLANK    BLANK OUT SPOT FOR HEADING
*              FOLLOWING STMTS HELP AVOID WASTED 1ST PAGE LISTING.
         LA    RE,$OU#PAG1         # LINES FOR STMTS ON 1ST PAGE ONLY
         STH   RE,OUH#LINE         SET COUNTERSETTER TO INITIAL VALUE
         MVI   OUHEAD1,C'0'        JUST DO DOUBLESPACE 1ST TIME
         AIF   (NOT &$CMPRS).OUINCM         SKIP IF NO COMPRESS CODE
         SPACE 2
*              CMPRS OPTION INITIALIZATION&TESTING - IF ON, GET
*              SPACE FOR OUCMPRSD BLOCK, INIT VARIABLES.
         SPACE 1
         TM    AVTAGS2,AJOCMPRS    IS CMPRS OPTION USED
         BZ    OUINOCMP            NO, SO DON'T GET SPACE
         SPACE 1
         LA    RA,OUCMPR$L         TOTAL LENGTH OF OUCMPRSD BLOCK
         $ALLOCH RB,RA,OUINCMOV    ACQUIRE AREA
         USING OUCMPRSD,RB         NOTE PTR THERE
         ST    RB,OUCMPRAD         STORE @ BLOCK FOR OUTPT2 USE
         LA    RE,$OU#PAG1+OUH#    TOTAL # LINES FOR PAGE 1
         STH   RE,OUCMOPAG         SET # LINES ON FIRST PAGE ONLY
         STH   RE,OUCMLEFT         SET # LINES LEFT IN OUCMSAVE,PAGE1
         SPACE 1
         LA    RC,OUCMSAVE         @ 1ST BYTE OF STORAGE AREA
         ST    RC,OUCMSTMT         SET @ SO 1ST STMT WILL BE THERE
         NI    OUCMPHAS,255-OUCMPHSB        SHOW OUTPT2 IN PHASE 'A'
         MVI   OUCMCCIN,C'0'       MAKE INITIAL CARRIAGE CONT D SPACE
         MVC   OUCMBREK,=C'. '     INITIALZE SEPARATER FIELD
         B     OUINOCMP            SKIP OVER RESET CODE
         DROP  RB                  KILL USING
         SPACE 1
*              INSUFFICIENT SPACE - CANCEL CMPRS OPTION NOW.
OUINCMOV NI    AVTAGS2,255-AJOCMPRS         REMOVE CMPRS FLAG
OUINOCMP EQU   *
         SPACE 1
.OUINCM  ANOP
OUINRET  $RETURN SA=NO
         EJECT
**--> ENTRY: OUTPUT2      PRINT 1 STATEMENT,WITH CODE AS NEEDED,ERROR .
*.       OUTPT2 PRINTS 1 STATEMENT, WITH ANY ERROR MESSAGES NEEDED,   .
*.       PRINTS TITLES AND HEADINGS WHEN REQUIRED, PERFORMS PAGE AND  .
*.       LINE COUNTING, MAINTAINS LISTING CONTROL STATUS, AND KEEPS   .
*.       COUNTS OF NUMBER OF STATEMENTS FLAGGED, TOTAL # ERRORS,      .
*.       TOTAL # WARNING MESSAGES.                                    .
*.       ENTRY CONDITIONS                                             .
*.  RB = PRIMARY CALL TYPE CODE                                       .
*.     = 0    ($OUMACH) MACHINE INSTRUCTIONS                          .
*.     = 2    ($OUCONS) CONSTANTS,CNOPS,ETC. PRINT LOCATION COUNTER,CO.
*.     = 4    ($OULIST) - LISTING CONTROL - EJECT,SPACE,PRINT,TITLE   .
*.     = 6    ($OUCOMM) - COMMENTS,ETC.-DO NOT HAVE LOCATION COUNTER  .
*.  RC = AN INFORMATION ADDRESS OF SOME TYPE                          .
*.     = @ OBJECT CODE (RB=0,2)                                       .
*.     = @ # LINES TO SPACE (RB=4,RE=0)                               .
*.     = @ PRINT CONTROL CODE BYTE (RB=4,RE=2) I.E. PRINT             .
*.     = @ TITLE CODE (RB=4,RE=4)                                     .
*.  RD = #-1 OF BYTES OF OBJECT CODE OR TITLE                         .
*.  RE = SECONDARY CODE OR ADDRESS                                    .
*.     = SECONDARY CODE FOR LISTING CONTROL OPERATIONS                .
*.     = 0    SPACE OR EJECT                                          .
*.     = 2    PRINT                                                   .
*.     = 4    TITLE                                                   .
*.       USES DSECTS: AVWXTABL,ICBLOCK,RCODBLK,RSBLOCK,RSCBLK,REBLK   .
*.       USES MACROS: $AL2,$PRNT,$RETURN,$SAVE,$SERR                  .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         EJECT
* * * * * REGISTER USAGE FOR OUTPT2 * * * * * * * * * * * * * * * * * *
*   RW = CURRENT VALUE OF OUCOUNT. IF =1,NEW HEADING NEEDED           *
*   RX = BASE REGISTER                                                *
*   RY = UNUSED AT PRESENT                                            *
*   RZ = @ RSBLOCK BELONGING TO STATEMENT BEING PROCESSED.            *
*   R14= INTERNAL LINK REGISTER.  LOCAL WORK REGISTRE.                *
*   R15= LOCAL WORK REGISTER.                                         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
OUTPT2   $SAVE RGS=(R14-R6),SA=NO           LEAVE R15 AS IS
         LR    RX,R15              MOVE @ OUTPT2 OVER FOR NEW BASE
         DROP  R15                 REMOVE OLD USING
         USING OUTPT2,RX           NOTE NEW USING
         SPACE 1
*              COMMON INITIALIZATION. MAKE PROCESSOR CHOICE, BASED    *
*        ON CONTENTS OF REG RB. PRINT IF PRINT ON, OR INSTRUCTION IS  *
*        A LISTING CONTROL, OR ANY STMT WITH AN ERROR IN IT.          *
         SPACE 1
         L     RZ,AVRSBPT          GET POINTER TO RSBLOCK
         USING RSBLOCK,RZ          NOTE POINTER
         LH    RW,OUCOUNT          GET WITHIN PAGE COUNT
         MVC   OUTLINE(OUTLEN),AWBLANK       BLANK OUT LEFT HAND SIDE
         AIF   (NOT &$MACROS).OUNGEN        SKIP IF NO MACRO CODE
         SPACE 1
         TM    RSBFLAG,$RSBGENR    WAS THIS GENERATED STMT
         BZ    OUNGEN              NO, NORMAL, SKIP
         MVI   OUSOURC-1,C'+'      MARK OUTPUT AS GENERATED
         TM    AVPRINT,$IBPGEN     IS PRINT GEN: SHOULD WE PRINT
         BO    OUNGEN              PRINT GEN-DEFINITELY PRINT
*              FOLLOWING STMTS ALLOW GENERATED PRINT STMTS TO BE USED.
*        WARNING: EXTENSION FROM ASMBLER F.
         CH    RB,=AL2($OULIST)    IS IT LISTING CONTROL STMT
         BNE   OUTRETE             NO, NOT LISTING CONTROL - GO CHK
         CH    RE,=H'2'            WS IT ACTUALLY  PRINT
         BNE   OUTRETE             NO, SO IGNORE IT
*              YES, FALL THRU AND DO IT
OUNGEN   EQU   *                   SKIP HERE IF NOT GEN'D STMT
         SPACE 1
.OUNGEN  ANOP
         LH    R14,OUJUMP1(RB)     GET PRIMARY TUPE OF STATEMENT
         TM    AVPRINT,$IBPON+$IBPLIST SET CC=3 IF PRINT ON AND LIST
OUTJ1    BAL   R14,OUTJ1(R14)      GO TO RIGHT CODE, WITH CC SET
*              IF SPECIFIC STMT TYPE CODE DOESN'T WANT TO PROCESS IT,
*              IT CAN RETURN HERE VIA A BCR NO,R14, AND STMT WON'T BE
*              PRINTED UNLESS IT HAS ERRORS IN IT.
         SPACE 1
OUTRETE  TM    RSBFLAG,$REBX+$RSBMERR  ARE THERE ANY ERRORS/ERR RECRD
         BZ    OUTRETA             XKIP IF NONE,PRINT STMT IF SO
         EJECT
*              OUTSTMT - FORMAT AND PRINT STATEMENT,WITH ERRORS       *
*              NORMALLY ENTERED AFTER INDIVIUDAL TYPE PROCESSING.
OUTSTMT  EQU   *                   COME HERE IF STMT SHOULD BE PRINTED
         AIF   (NOT &$MACROS).OUNMAC1       SKIP IF NO MACROS ALLOWED
         TM    RSBFLAG,$RSBNPNN    WAS THIS NOT TO BE NUMBERED
         BO    OUTSTMTN            NO NUMBER - SKIP EDITING
.OUNMAC1 ANOP
         SPACE 2
         MVC   OUDSTMNT-1(6),AWEP6     COPY THE EDIT PATTERN
         ED    OUDSTMNT-1(6),OULNCNT         FORMAT STATEMENT #
*              GET 1ST(OR ONLY) CARD-IMAGE IN PLACE FOR PRINTING      *
*              NEXT STMT ASSUMES 1ST CARD OF SEVERAL IS 71 BYTES LONG.
OUTSTMTN LA    R1,RSOL1-1          NORMAL LENGTH-1, CLEAR FOR INSERT
         L     R2,AVRSCPT          GET @ RSCBLK,IF IT EXISTS
         USING RSCBLK,R2           NOTE USING,FOR ANY SECTION REQUIRING
         CLI   RSBNUM,1            WAS THERE ONLY 1 CARD
         BNE   OUTC1B              NO, SKIP, R1 ALREADY SET OK
OUTC1A   IC    R1,RSBLENG          GET THE LENGTH OF RSBLOCK, 1 SOURCE
         LA    R1,(255-RSB$L)(R1)  SUBTRACT LENGTH, LOW-ORDER BYTE-WISE
         MVC   OUSOURCE,AWBLANK+9           BLANK STMT, CONT/SEQNO
         SPACE 1
         AIF   (NOT &$MACROS).OUNMAC2  SKIP IF NO MACRO
         TM    RSBFLAG,$RSBMERR    SPECIAL ERROR FORMT STMT
         BZ    OUTC1B              NO, SO SKIP SPECIAL FORMATTING
         SPACE 1
*              SPECIAL ERROR MESSAGE - ISSUED BY MACRO PROCESSOR -
*              STMT IMAGE IS CONSTRUCTED TEXT OF ERROR MESSAGE.
*              **NOTE** THESE ARE NOT CURRENTLY COUNTED AS ERRORS
         STC   R1,OURSBMOV+1       PUT L-1 INTO MOVE FOR MESSAGE
         MVC   OUTLINE+1(L'OUTERRAS-1),OUTERRAS+1  ERROR PTR ON LEFT
         MVC   OUCONSQ+1(8),OUTEREND+1 ERROR PTE ON RIGHT
OURSBMOV MVC   OUTLINE+L'OUTERRAS($),RSBSOURC   MOVE MESSAGE IN
         B     OUTSPRNT            GO PRINT WITHOUT FURHTER ADO
.OUNMAC2 ANOP
         SPACE 1
OUTC1B   STC   R1,*+5              STORE LENGTH-1 INTO NEXT INSTR
         MVC   OUSOURC($CHN),RSBSOURC        MOVE VARIABLE LENGTH OVER
         SPACE 1
*              PLACE CONTINUATION SEQNO IN IF NEEDED                  *
         TM    RSBFLAG,$RSCX       DO WE HAVE CONT/SEQN
         BZ    OUTSPRNT            NO,DON'T NEED CONT/SEQN
         MVC   OUCONSQ,RSCONSQ     MOVE FIELD IN
         SPACE 1
OUTSPRNT EQU   *                   POINT FOR PRINTING 1ST /ONLY CARD
OUTSPRNU BAL   R14,OUTLNSA         HAVE THE STMT PRINTED
         CLI   RSBNUM,1            WAS THERE ONLY 1 CARD(HOPE)
         BNE   OUTSCON             NO(GROAN)-MULTIPLE CARDS IN STMT
         TM    RSBFLAG,$REBX       WERE THERE ERRORS
         BNZ   OUTERR              BRANCH IF ERRORS(UNFORTUNATE)
         SPACE 1
OUTRETA  STH   RW,OUCOUNT          SAVE WITHIN PAGE COUNT
         AIF   (NOT &$MACROS).OUNMAC3       SKIP IF NO MACROS
         TM    RSBFLAG,$RSBNPNN    SEE IF SHOULDN'T INCRE STMT #
         BO    OUTRETAA            SKIP OVER STMT# ADD INSTR(S)       J
.OUNMAC3 AP    OULNCNT,AWP1        BUMP STMT # TO # OF NEXT ONE
         AIF   (NOT &$XREF).NOXRF10                                   A
         AP    AVXRLNCN,AWP1       INCREMENT ADDITIONAL LINE COUNTER  A
.NOXRF10 ANOP                                                         A
OUTRETAA EQU   *                   BRANCH HERE BEFORE EXIT            J
         $DBG  C0,*                JUST TRACE ON EXIT
OUTRET   $RETURN RGS=(R14-R6),SA=NO
         EJECT
* * * * * OUTSCON - HANDLE PRINTING OF CONTINUATION CARDS.SET UP OFFSE*
* * * * * REGISTER USAGE                                              *
*   R1 = CURRENT COUNT OF # CARDS REMAINING TO BE PRINTED(INIT-RSBNUM)*
*   R2 = @ CURRENT RSCBLK SECTION BEING PROCESSED                     *
*   RD = CURRENT TOTAL OFFSET. USED TO EXTRACT CARDS,SET ERROR MESSGS *
*              INIT.  LOOP THOURHG OUTSCON2 FOR EACH CONT/CARD. SET   *
*              UP OFFSETS IN OUTOFFS FOR USE IN ERROR POINTERS.       *
         SPACE 1
OUTSCON  SR    R1,R1               CLEAR FOR INSERTION
         IC    R1,RSBNUM           GET TOTAL # OF CARDS
         LA    RC,OUTOFFS(R1)      GET @ LAST BYTE FOR OFFSETS
         MVI   0(RC),RSB$L         MOVE BEGINNING OFFSET IN
         SR    RD,RD               CLEAR FOR INSERT
         IC    RD,RSCILEN          GET LENGTH OF 1ST CARDIMAGE
         LA    RD,RSB$L(RD)        INCREMENT LENGTH BY 1ST OFFSET
         STC   RD,OUTOFFS-1(R1)    STORE IN APPROPRAITE PART OF OUTOFFS
         BCTR  R1,0                DECREMENT # CARDS LEFT TO DO
         MVC   OUTLINE,AWBLANK     BLANK WHOLE LINE
         SPACE 1
OUTSCON2 LA    R2,RSC$LEN(R2)      BUMP RSCB POINTER TO NEXT FIELD
         LA    RC,RSBLOCK(RD)      GET @ NEXT SOURCE CARD ELEMENT
         SR    RB,RB               CLEAR FOR INSERT
         IC    RB,RSCILEN          GET LENGTH OF NEXT CARD
         AR    RD,RB               ADD TO TOAL OFFSET LENGTH
         STC   RD,OUTOFFS-1(R1)    STORE NEXT OFFSET INTO LIST
         BCTR  RB,0                DECREMENT FOR LENGTH-1
         STC   RB,*+5              SAVE INTO MVC
         MVC   OUSOURC+15($CHN),0(RC)        MOVE CARD IMAGE OVER
         MVC   OUCONSQ,RSCONSQ     MOVE CONT/SEQNO OVER
         BAL   R14,OUTLNSA         HAVE STMT PRINTED
         STC   RB,*+5              PUT LENGTH-1 INTO NEXT MVC
         MVC   OUSOURC+15($CHN),AWBLANK      BLANK OUT PART OF LINE USE
         BCT   R1,OUTSCON2         LOOP UNTIL WHOLE STATEMENT FINISHED
         SPACE 1
         TM    RSBFLAG,$REBX       DO ERRORS EXIST
         BZ    OUTRETA             NO ERRORS - QUIT
         EJECT
* * * * * OUTERR - PRINT ERROR MESSAGES AND SCAN POINTERS             *
*   R2 = # ERROR CODE/SCAN POINTER PAIRS (= 1 TO $ERREBMX).           *
*   RE = CUMULATIVE COUNT OF ERRORS(NOT WARNINGS) THOURGHOUT SECTION. *
OUTERR   L     RD,AVREBPT          GET POINTER TO ERRORS
         USING REBLK,RD            NOTE USING
         LH    RE,AVNERRA          GET ACTUAL # ERRORS
         LH    R14,AVSTMTER        GET TOTAL # STMT ERRORS
         LA    R14,1(R14)          INCREMENT TO SHOW 1 MORE STMT FLAGD
         STH   R14,AVSTMTER        STORE BACK UPDATED POINTER
         SR    R2,R2               CLEAR FOR INSERTION
         IC    R2,REBLN            GET TOTAL ELNGTH OF ERROR BLOCK
         SRL   R2,1                DIVIDE BY TO=#ERRORS
         SR    R1,R1               CLEAR FOR CONSTANT INSERTS
         SPACE 1
OUTERR1  IC    R1,REBSCN           GET SCAN POINTER
         CLI   RSBNUM,1            WAS THERE ONLY 1 STATEMENT
         BE    OUTERR5             SKIP OVER MULTIPLE SECTION IF SO
         SPACE 1
*              SECTION FROM HERE TO OUTERR5 REQUIRED FOR MULT CARDS.  *
         SR    RC,RC               CLEAR FOR INSERT
         IC    RC,RSBNUM           GET NUMBER OF CARDS
         SR    R0,R0               CLEAR FOR INSERTS
OUTERR3  IC    R0,OUTOFFS-1(RC)    GET LIMIT SCAN POINTER FOR CARD
         CR    R0,R1               COMPARE WITH ERROR POINTER
         BH    OUTERR4             BRANCH OUT IF CORRECT SPOT FOUND
         BCT   RC,OUTERR3          LOOP FOR # OF CARDS
         B     OUTERR5             NOT FOUND-WILL BE TOO HIGH
OUTERR4  IC    R0,OUTOFFS(RC)      GET BEGINNING SCAN POINTER
         SR    R1,R0               GET OFFSET FROM CARD BEGINNING
         LA    R1,RSB$L(R1)        ADD SCAN OFFSET FROM RSBLOCK
         IC    R0,RSBNUM           GET # OF CARDS
         CR    R0,RC               SEE IF SAME,I.E. IN 1ST CARDIMAGE
         BE    OUTERR5             SKIP OVER-ITS IN 1ST CARD,SO OK
         LA    R1,15(R1)           CONTINUATION CARD-BUMP POINTER
         SPACE 1
*              FOLLOWING CONCLUDES PROCESSING FOR SINGLE CARD STMTS   *
OUTERR5  LA    RC,OUTEOFF(R1)      GET @ WHERE $ SHOULD GO
         LA    R0,OUTEREND         GERT LAST POSSIBLE SCAN POINTER
         CR    R0,RC               MAKE SURE POINTER NOT BEYOND END
         BNL   *+6                 SKIP IF OK
         LR    RC,R0               USE LAST POSSIBLE OFFSET @
*              RC = @ FOR $ SCAN POINTER AT THIS POINT.               *
         IC    R1,REBERR           GET THE ERROR CODE
         AIF   (&$OPTMS GT 2).OUOP1         SKIP IF BIG MEMORY
*              SMALL SPACE==> NO PTRS, JUST MULT CODE BY 3/2.
         LR    RB,R1               MOVE ERROR CODE OVER
         SRL   RB,1                ITS EVEN NUMBER, SO DIVIDE BY 2
         AR    R1,RB               = 3/2 CODE, DESIRED NUMBER
         LA    RB,OUERRMS-3-1(R1)  @-1 OF 3BYTE ERROR NUMBER
         AGO   .OUOP2
.OUOP1   ANOP
         LH    RB,OUERRPT(R1)      GET OFFSET TO ERROR MESSAGE
         LA    RB,OUERRMS(RB)      GET ACTUAL @ ERROR MESSAGE
.OUOP2   ANOP
*              INCREMENT ERROR OR WARNING MESSAGE TOTAL COUNT.
         LA    R15,1               SET UP FOR ERROR-WARNING INC
         CLI   1(RB),C'0'          WAS ERR # FROM 000-099 (WARNING)
         BE    *+10                YES, BRANCH IF IT IS A WARNING
         AR    RE,R15              INCREMENT # ERRORS (AVNERRA)
         B     *+12                BRANCH OVER WARNING CODE
         AH    R15,AVNWARN         INCREMENT # WARNING MESSAGES
         STH   R15,AVNWARN         PUT # WARNINGS BACK
         SPACE 1
*              SET UP MESSAGE, SCAN POINTER. PRINT MESSAGE.
         AIF   (&$OPTMS GT 2).OUOP3         SKIP IF LARGE MEMORY
         MVC   OUTERMS(3),1(RB)    MOVE ERROR # INTO MSG
         AGO   .OUOP4              SKIP REGUALR CODE
.OUOP3   ANOP
         IC    R1,0(RB)            GET LENGTH-1 OF ERROR MESSAGE
         STC   R1,OUTERR6+1        SAVE INTO BLANKING MVC
         STC   R1,*+5              STORE TO MOVE MESSAGE INTO BUFFER
         MVC   OUTERMS($CHN),1(RB) MOVE ERROR MESSAGE INTO BUFFER
.OUOP4   ANOP
         MVI   0(RC),C'$'          PLACE SCAN POINTER IN
         LA    RA,OUTERROR         SET UP @ ERROR LINE
         BAL   R14,OUTLNS          HAVE ERROR MESSAGE PRINTED
         SPACE 1
         AIF   (&$OPTMS LE 2).OUOP5         SKIP IF SMALL MEMORY
OUTERR6  MVC   OUTERMS($CHN),OUBLDASH       RESTORE BLANKS-DASHES
.OUOP5   ANOP
         MVI   0(RC),C'-'          FILL IN DASH WIPED BY $
         LA    RD,2(RD)            INCREMENT ERROR BLOCK PTR
         BCT   R2,OUTERR1          LOOP FOR NUMBER OF ERRORS
         SPACE 1
*              UPDATE ERROR COUNT & CHECK FOR EXCEEDING LIMIT.
         STH   RE,AVNERRA          STORE UPDATED ERROR COUNT
         CH    RE,AVNERR           COMPARE TO ERROR LIMIT
         BNH   OUTRETA             IF STILL OK,BRANCH
         OI    AVTAGS1,AJNLOAD     FLAG NOLOAD,NO MORE OBJECT CODE
         B     OUTRETA             GO RETURN
         EJECT
* * * * * RB=$OUMACH - FORMAT LEFT-SIDE FOR MACHINE INSTRUCTIONS  * * *
OUMACH   EQU   *
         BCR   NO,R14              RETURN UNLESS PRINT ON AND LIST
         L     R14,AVRCBPT         GET # RCB TO PICK UP INFO
         USING RCODBLK,R14         NOTE USING
         UNPK  OULOC(7),RCLOC(4)   UNPACK LOCATION COUNTER
         MVI   OULOC+6,C' '        BLANK OT EXTRA BYE
         DROP  R14                 LOCATION COUNTER ALL THAT WAS NEEDED
         USING ICBLOCK,RC          NOTE INSTRUCTION CODE BLOCK
*              RD = LENGTH-1 OF INSTRUCTION = 1,3,5.                  *
         UNPK  OUOPR1R2(5),ICBOPR1R(3)       GET OPCODE-R1-R2 FIELD
         MVI   OUOPR1R2+4,C' '     BLANK OUT EXTRA BYTE
         C     RD,AWF3             CHECK LENGTH-1 AND SET CC
         BL    OUMACH1             ONLY 2 BYTE INSTRUCTION-QUIT
         UNPK  OUOPN1(5),ICBOPN1(3)          UNPACK 1ST BASE-DISP
         MVI   OUOPN1+4,C' '       BLANK OUT END BYTE
         BE    OUMACH1             IF RD=3,==> 4 BYTE INST-QUIT
         UNPK  OUOPN2(5),ICBOPN2(3)          6-BYTE INST.UNPK 2ND B-D
         MVI   OUOPN2+4,C' '       BLANK OUT END BYTE
         SPACE 1
*              OBJECT CODE ALL UNPACKED - NOW CHECK FOR INSTRUCT ADDRS*
OUMACH1  TM    ICBFLAG,$ICBEA1     WAS THERE A 1ST INST ADDR
         BZ    OUMACH2             NO,DON'T LOOK FOR ONE
         UNPK  OUEA1+1(6),ICBEA1+1(4)        GET 5 BYTES OF ADDRESS OVE
OUMACH2  TM    ICBFLAG,$ICBEA2     WAS THERE A 2ND ADDRESS TO BE PRINTE
         BZ    OUMACH3             NO THERE WASN'T,BRANCH
         UNPK  OUEA2+1(6),ICBEA2+1(4)        GET 5 BYTES OF ADDR
OUMACH3  TR    OUTLINE+1(OUTLENM),AWTHEX3    TRANSLATE TO FINISH
         B     OUTSTMT             GO HAVE STATEMENT PRINTED OUT
         SPACE 1
* * * * * RB=$OUCONS - FORMAT LEFT-SIDE WITH LOC,CONSTANT IF NEEDED * *
OUCONS   EQU   *
         BCR   NO,R14              RETURN IF NOT PRINT ON, LIST
         L     R14,AVRCBPT         GET @ RCB FOR INFO THERE
         USING RCODBLK,R14         NOTE POINTER
         UNPK  OULOC(7),RCLOC(4)   CONVERT THE LOCATION COUNTER
         MVI   OULOC+6,C' '        BLANK OT EXTRA BYE
         DROP  R14
         LTR   RD,RD               IS LENGTH-1 <0,WHICH ==> NO CONSTANT
         BM    OUCONS2             NO CONSTANT - TRANSLATE LOCCNTR&QUIT
         C     RD,AWF7             IS LENGTH-1 > 7
         BNH   *+8                 SKIP NEXT IF WITHIN RANGE
         LA    RD,7                USE ONLY 1ST 8 BYTES OF CONSTANT
         SPACE 1
         LA    R14,0(RD,RD)        GET 2*(L-1 OF CODE) FOR UNPACK LENGT
         LA    R15,OUCONST(R14)    SAVE @ LAST UNPACKED BYTE
         SLL   R14,4               SHIFT OVER INTO 1ST NIBBLE OF LOW BT
         AR    RD,R14              PUT LENGTHS INTO LOW-ORDER BYTE
         STC   RD,*+5              STORE INTO UNPK INSTRUCTION
         UNPK  OUCONST($CHN),0($CHN,RC)      CONVERT CONST CODE
         UNPK  1(1,R15),0(1,R15)   DUPLICATE AND REVERSE NIBBLES
         OI    0(R15),X'F0'        MAKE DIGIT PRINTABLE
         OI    1(R15),X'F0'        FIX UP LAST BYTE
OUCONS2  TR    OUTLINE+1(24),AWTHEX3         CONVERT OT HEX OUTPUT
         B     OUTSTMT             GO PRINT PUT STATEMENT
         EJECT
* * * * * RB=$OULIST - LISTING CONTROL - SPACE,EJECT,PRINT,TITLE  * * *
OULIST   EQU   *                   ""=3 IF PRINT ON, LIST OPTION
         LH    R15,OUJUMP2(RE)     GET SECONDARY BRANCH CODE
OUTJ2    B     OUTJ2(R15)          BRANCH TO STMT TYPE, DON'T CHANGE CC
         SPACE 1
* * * * * OUSPEJ - PROCESS SPACE OR EJECT,USING # OF LINES TO BE SPACD*
*              AT THIS PT, CC MUST =3, ELSE NO SPACING DONE.
OUSPEJ   BCR   NO,R14              QUIT, (RETURN TO OUTRETE
         LA    RD,1                SET COUNTER CLEAR
         LA    RA,AWBLANK          @ BLANK LINE
         CLI   0(RC),255           REAL EJECT ?
         BE    OUSPEJ1A            YES, GO DO THE EJECT
         IC    RD,0(RC)            GET # OF LINES TO BE PSACED
OUSPEJ1  SR    RW,RD               GET # LINES LEFT ON THIS PAGE
         BP    OUSPEJ2             SKIP SOME LEFT - PRINT BLANK LINES
         LCR   RD,RW               # BLANKS TO BE PRINTED AFTER TITIL
         BZ    OUTITL2             IF NO BLANK LINES, JUST RESET TITLE
OUSPEJ1A BAL   R14,OUTLNSTI        HAVE TITLE LINES PRINTED
         B     OUSPEJ1             LOOP-BE SAFE FOR PRINT 200 ETC
OUSPEJ2  BAL   R14,OUXPRNT         PRINT 1 BLANK LINE
         BCT   RD,OUXPRNT          GO PRINT BLANK LINES
         B     OUTRETA             GO RETURN
         SPACE 1
* * * * * OUPRINT - PROCESS PRINT INSTRUCTION. RC = @ CONTROL BYTE    *
OUPRINT  MVC   AVPRINT,0(RC)       MOVE PRINT CONTROL BYTE OVER
         B     OUTRETE             NOT ON,GO CHECK FOR ERRORS
         SPACE 1
* * * * * OUTITLE - BRING IN NEW TITLE,FLAG TITLE EXISTS,PRINT IF ON. *
OUTITLE  MVC   OUHEADNG,AWBLANK    BLANK THE HEADING OUT
         STC   RD,*+5              STORE LENGTH-1 OF NEW TITLE INTO MVC
         MVC   OUHEADNG($CHN),0(RC)          MOVE NEW HEADING INTO FIEL
OUTITL2  LA    RW,1                SET COUNT SO WILL CREATER HEADER NXT
         B     OUTRETE             GO MAKE SURE THERE WAS NO ERROR
         SPACE 2
OUCOMM   EQU   *                   COME HERE FOR COMMENTS, SPEC ERRS
         BCR   NO,R14              PRINT OFF/NOLIST - RETURN
         B     OUTSTMT             PRINT LIST AND ON - GO PRINT STMT
         EJECT
**--> INSUB: OUTLNSA/OUTLNS  PRINT 1 LINE (WITH HEADING IF NEEDED)+ + +
*+       PRINTS A 121 BYTE LINE, DECREMENTS REMAINING LINE COUNT.     +
*+       ENTRY CONDITIONS                                             +
*+  RA = @ 121-BYTE LINE TO BE PRINTED (OUTLNS ONLY).                 +
*+  RW = LINE COUNT REMAINING.  IF = 1, WILL PRODUCE HEADING.         +
*+  R14= RETURN @ TO CALLING SECTION OF CODE.                         +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
OUTLNSA  LA    RA,OUTLINE          ENTRY FOR MOST COMMON @
OUTLNS   BCT   RW,OUXPRNT          DECREMENT REMAINING, BRANCH IF OK
         SPACE 1
*              A HEADING AND PAGE SKIP ARE REQUIRED IF FALLS THRU HERE.
OUTLNSTI LR    RW,RA               SAVE ORIG LINE @ PTR INTO RW
         LR    R15,R14             SAVE THE ORIGIANL RETURN @ IN R15
         SPACE 1
         AP    OUPGCNT,AWP1        INCREMENT PAGE COUNT
         MVC   OUPCNT,AWEP4        MOVE EDIT PATTERN OVER
         ED    OUPCNT,OUPGCNT      EDIT PAGE COUNT OVER
         LA    RA,OUHEAD1          SHOW @ 1ST HEADING (TITLE)
         BAL   R14,OUXPRNT         PRINT IT
         LA    RA,OUHEAD2          SHOW @ 2ND HEADNING
         BAL   R14,OUXPRNT         HAVE IT PRINTED
         SPACE 1
         LR    RA,RW               RESTORE OLD LINE @
         LR    R14,R15             RESTORE OLD RETURN @
         SPACE 1
         LH    RW,OUH#LINE         GET # LINES LEFT TO DO
         MVI   OUHEAD1,C'1'        MAKE SURE SET FOR PAGE SKIP
         MVC   OUH#LINE,=AL2($OU#NORM)      SET COUNTERSETTER NORMAL
*              FALL THRU INTO OUXPRNT TP PRINT STMT ITSELF.
         SPACE 1
**--> INSUB: OUXPRNT    LOW-LEVEL PRINT ROUTINE- 121-BYTE LINE  + + + +
*+       ROUTINE PRINTS 1 LINE (NORMAL), OR ELSE BRANCHS TO CMPRS     +
*+       OPTION CODE TO SAVE/PRINT 2 STMTS PER LINE, IF CMPRS CODE    +
*+       EXISTS AND USER SPECIFIES THE OPTION.                        +
*+       ENTRY CONDITIONS                                             +
*+  RA = @ 121-CHARACTER LINE TO BE PRINTED                           +
*+  R14= RETURN @ TO CALLING SECTION OF CODE.                         +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
OUXPRNT  EQU   *                   ENTRY FOR PRINTING OR SAVING
         AIF   (NOT &$CMPRS).OUXCM1         SKIP IF NO CMPRS CODE
         TM    AVTAGS2,AJOCMPRS    IS CMPRS OPTION IN EFFECT
         BO    OUXCMINT            YES, GO TO PROCESS NEW STMT
         SPACE 1
.OUXCM1  ANOP
         $PRNT 0(RA),121           PRINT 1 NORMAL LINE
         BCR   Z,R14               RETURN IF NO OVERFLOW
         OI    AVTAGS2,AJOASTOP    RECORDS OVER-SHOW FLAG FOR STOPPING
         BR    R14                 RETURN TO CALLING SECTION.
         AIF   (NOT &$CMPRS).OUXCM2         SKIP IF NO CMPRS OPTION
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CMPRS OPTION PROCESSING - 2 STMTS/LINE                 *
*   THIS SECTION PERFORMS ALL MANIPULATION AND PRINTING REQUIRED TO   *
*   PRODUCE A LISTING IN WHICH THE FIRST HALF OF APPROX. 120 STMTS    *
*   IS PRINTED ON THE LEFT SIDE OF A PAGE, AND THE OTHER HALF ON THE  *
*   OTHER SIDE, THUS REDUCING THE LINES PRINTED BY THE ASSEMBLER BY   *
*   APPROXIMATELY 1/2.  IT CONSISTS OF THE FOLLOWING STEPS:           *
*   INITIALIZATION CODE: OUXCMINT : CONVERTS NONBLANK CARRIAGE        *
*        CONTROL LINES TO BLANK LINES FOLLOWED BY ACTUAL LINES.       *
*        ALSO SAVES REGISTERS WHICH WILL BE MODIFIED BY THIS SECTION. *
*   PHASE 'A' CODE :  ENTERED FOR EACH LINE UNTIL ENTIRE LHS OF PAGE  *
*        IS STORED, THEN SETS FLAGS FOR PHASE 'B'.                    *
*   PHASE 'B' CODE : OUXCMB : BUILD AND PRINT LINE CONSISTING OF      *
*        ONE STMT SAVED DURING PHASE 'A' AND THE LINE JUST GIVEN.     *
*        WHEN ALL SAVED STMTS HAVE BEEN PRINTED, RESET TO PHASE 'A'.  *
*        **NOTE** THIS SECTION IS ALSO USED FROM OUEND2 ENTRY.        *
*              REGISTER USAGE IN THIS SECTION                         *
*   RA = @ INCOMING LINE TO BE PRINTED.                               *
*   RB = @ CMPRS WORKAREA (OUCMPRSD DSECT)                            *
*   RC = @ NEXT EMPTY STMT SLOT, NEXT TO BE PRINTED / WORK REG.       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
**--> INSUB: OUXCMINT   ENTRY POINT FOR CMPRS HANDLING  + + + + + + + +
*        INITIAL SECTION - CHECK FOR NONBLANK CARRIAGE CONTROL.       +
*        ENTRY CONDTIONS           (ENTIRE SECTION)                   +
*   RA = @ 121-BYTE LINE IMAGE FOR OUTPUT  (OUSTMTIM DSECT)           +
*   R14= RETURN @ TO CALLING SECTION OF CODE                          +
*        *NOTE* MODIFIES NO REGISTERS, DOES USE AVDWORK1&AVDWORK2.    +
*        NAMES: OUXCM---                                              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
         USING OUSTMTIM,RA         NOTE DSECT FOR CONVENIENCE
OUXCMINT STM   RA,RC,AVDWORK1      INTO AVDWORK1,AVDWORK2 D'S
         CLI   OUSTCC,C' '         WAS CARRIAGE CONTROL NORMAL ' '
         BE    OUXCMPRT            YES, DON'T NEED DO FIXUP-BRANHC
         SPACE 1
*              NONBLANK CC - INSERT BLANK LINE, SAVING/RESTORING REGS.
         ST    R14,AVDWORK2+4      SAVE INTO TEMPORARY AREA
         LA    RA,AWBLANK          SHOW @ BLANK LINE
         BAL   R14,OUXCMPRT        CALL INTERIOR SECTION
         L     RA,AVDWORK1         RESTORE ORIG LINE @
         L     R14,AVDWORK2+4      RESTORE REAL RETURN @
         SPACE 1
*              OUXCMPRT - GET WORKAREA @, CHOOSE CURRENT PHASE A,B
OUXCMPRT L     RB,OUCMPRAD         GET @ CMPRS CONTROL BLOCK
         USING OUCMPRSD,RB         NOTE THE POINTER
         TM    OUCMPHAS,OUCMPHSB   IS IT PHASE B (PRINTOUT)
         BO    OUXCMB              YES, SO GO TO PRINT OUT 2 STMTS
         EJECT
*              PHASE 'A' - SAVE STMT IMAGES UNTIL AREA FULL.
         L     RC,OUCMSTMT         GET @ NEXT SLOT FOR STMT SEGMENT
         MVC   0(OUCM$L1,RC),OUSTP1         GET 1ST SECTION OF STMT
         MVC   OUCM$L1(OUCM$L2,RC),OUSTP2   2ND STMT SECTION (SOURCE)
         LA    RC,OUCM$LT(RC)      INCREMENT SLOT PTR TO NEXT ONE
         ST    RC,OUCMSTMT         STORE UPDATED SLOT PROINTER BACK
         SPACE 1
         LH    RC,OUCMLEFT         GET # EMPTRY SLOTS LEFT THIS TIME
         S     RC,AWF1             DECREMENT # EMPTRY SLOTX
         STH   RC,OUCMLEFT         RESTORE UPDATED # SLOTS
         BP    OUXCMRET            IF SLOTS LEFT, GO TO EXIT CODE
         SPACE 1
*              NO EMPTY SLOTS LEFT FOR STMTS.  RESET VARIABLES AND
*              FLAG SO ENTERS PHASE 'B' OF CMPRS PROCESSING NEXT TIME.
OUXCMA1  LA    RC,OUCMSAVE         INIT @ TO 1ST SAVED STMT
         ST    RC,OUCMSTMT         INIT PTR TO 1ST SAVED STMT
         MVC   OUCMLICC,OUCMCCIN   INIT CARRIAGE CONTROL 1ST STMT
         MVI   OUCMCCIN,C'1'       MAKE SURE NEW PAGE FOR PAGES 2-
         OI    OUCMPHAS,OUCMPHSB   SHOW NOW PHASE 'B'
         B     OUXCMRET            GO TO RETURN CODE
         SPACE 2
*              PHASE 'B' - RETIRIEVE AND PRINT SAVED STMT WITH NEW 1.
OUXCMB   L     RC,OUCMSTMT         GET @ NEXT STMT TO PRINT
         MVC   OUCMSTMA,0(RC)      MOVE THE STMTS TO PRINT AREA
         MVC   OUCMSTMB(OUCM$L1),OUSTP1     GET 1ST SECTION OF NEW 1
         MVC   OUCMSTMB+OUCM$L1(OUCM$L2),OUSTP2       2ND SECT OF NEW
         $PRNT OUCMLINE,133        PRINT THE ENTIRE LINE, 2 STMTS
         BM    OUXCMOVR            OVER NOW ON PRINTER-STOP
         SPACE 1
         MVI   OUCMLICC,C' '       MAKE SURE CC IS ' ' FOR REST OF PAGE
         LA    RC,OUCM$LT(RC)      INCREMENT PTR TO NEXT SAVED STMT
         ST    RC,OUCMSTMT         STORE BACK UPDATE PTR @
         SPACE 1
         LH    RC,OUCMLEFT         GET # EMPTY SLOTS LEFT
         LA    RC,1(RC)            INCREMNT # EMPTY (JUST PRINTED 1)
         STH   RC,OUCMLEFT         RESTORE UPDATED # EMPTRY SLOTS
         CH    RC,OUCMOPAG         IS EMPTY # = # ON PAGE
         BL    OUXCMRET            NO, STILL MORE TO DO, RETURN
         SPACE 1
*              HAVE PRINTED ALL SAVED STMTS, RETURN TO PHASE 'A'
         LA    RC,OUCMSAVE         GET @ FIRST SLOT
         ST    RC,OUCMSTMT         RE-INIT TO @ FIRST SLOT
         LA    RC,$OU#LNS          NORMAL # LINES PER PAGE
         STH   RC,OUCMOPAG         SET # ON PAGE TO NORMAL # FOR SURE
         STH   RC,OUCMLEFT         SET COUNTER VALUE NORMAL TOO
         NI    OUCMPHAS,255-OUCMPHSB        REST TO PHASE 'A'
         SPACE 1
*              OUXCMRET - EXIT CODE - RESTORE REGS,RETURN
OUXCMRET LM    RA,RC,AVDWORK1      RESTORE REGS FROM SAVED WORDS
         BR    R14                 RETURN TO CALLING SECTION OF CODE
OUXCMOVR OI    AVTAGS2,AJOASTOP    FLAG OVERRRUN
         B     OUXCMRET            GO TO EXIT FROM CMPRS SECTION
         DROP  RA,RB               REMOVE USINGS
.OUXCM2  ANOP
         EJECT
**--> ENTRY: OUEND2   2   PRINT ENDING STATISTICS FOR ASSMBLY . . . . .
*.       OUEND2 IS CALLED AT THE END OF THE ASSEMBLY TO PRINT SUMMARY .
*.       OF ERRORS AND WARNINGS ISSUED.  FIRST LINE PRINTED GIVES     .
*.       TOTAL # OF STMTS FLAGGED, TOTAL # ERRORS, TOTAL # WARNINGS.  .
*.       IF MAXIMUM # ERRORS IS EXCEEDED, ANOTHER LINE IS PRINTED.    .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $PRNT,$RETURN,$SAVE                             .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
OUEND2   $SAVE SA=NO
         AIF   (NOT &$CMPRS).OUENC1         SKIP IF NO COMPRS CODE
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CMPRS OPTION COMPLETION CODE                           *
*              SET UP COMMON USING CONDITIONS WITH OUTPT2, AND TEST   *
*        FOR CMPRS OPTION IN EFFECT.  IF IT IS, THEN HAVE ANY         *
*        STATEMENTS PRINTED WHICH HAD BEEN SAVED, BUT NOT YET         *
*        PRINTED.                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         TM    AVTAGS2,AJOCMPRS    DID USER SPECIFY CMPRS OPTION
         BZ    OUENCMNO            NO HE DIDNT, SKIP
         SPACE 1
         STM   R14,RX,12(R13)      STORE REGS, ESPEC RX,R14
         L     RX,=A(OUTPT2)       GET ADDR (SAFE IN OVERLAY)         J
         DROP  R15                 REMOVE OLD USING
         USING OUTPT2,RX           NOTE COMMON USING WITH OUTPT2
         SPACE 1
*              TEST PHASE OF CMPRS HANDLING.  IF STMTS LEFT, SET TO
*              PHASE B TO DUMP THOSE LEFT, IF NOT ALREADY PHASE B.
         L     RB,OUCMPRAD         GET @ CONTROL BLOCK FOR CMPRS
         USING OUCMPRSD,RB         NOTE CONTROL BLOCK USING
         TM    OUCMPHAS,OUCMPHSB   ARE WE IN PHASE B ALREADY
         BO    OUENPHSB            YES, JUMP TO FINISH
         BAL   R14,OUXCMA1         IN PHASE A, CALL THIS TO SET TO B
         L     RB,OUCMPRAD         RELOAD RB, WHICH WAS ERASED
         SPACE 1
*              CMPRS HANDLER IN PHASE 'B' - PRINT ANY REMAINING STMTS
OUENPHSB LH    RD,OUCMOPAG         GET # ON PAGE
         SH    RD,OUCMLEFT         DIFFERENCE = # LEFT TO DO
         BNP   OUENCMDN            NO STMTS LEFT, NO PRINTING NEEDED
         LA    RA,AWBLANK          SHOW @ FAKE BLANK LINE
         SPACE 1
         BAL   R14,OUXCMINT        GO TO PRINT 1 MORE STMT/BLANK LINE
         BCT   RD,*-4              LOOP UNTIL ALL LINES LEFT PRINTED
         SPACE 1
OUENCMDN LM    R14,RX,12(R13)      RESTORE REGS, ESP RX,R14
         DROP  RB                  REMOVE USING
         USING OUEND2,R15          RESTORE REGULAR USING
         EJECT
OUENCMNO EQU   *                   NORMAL OUEND2 PROCESSING
.OUENC1  ANOP
         SPACE 1
         TM    AVTAGS3,AVOVERFL    DID OVERFLOW OF STORAGE OCCUR
         BZ    OUNOVRFL            NO, DON'T PRINT MSG
         $PRNT OUAS999,OUAS999L    PRINT THE MESSAGE
OUNOVRFL EQU   *                   BRANCH HERE IF STORAGE OK
         SPACE 1
         ZAP   AVDWORK1,OULNCNT    MOVE LINE COUNT OVER FOR CONVERT
         CVB   RE,AVDWORK1         CONVERT THE LINE COUNT TO BINARY
         STH   RE,AVSTMTNO         SAVE AS NUMBER OF STATEMENTS
         SPACE 1
         LH    RE,AVSTMTER         GET # STATEMENTS FLAGGED
         LA    RD,OUSTMTER         GET @ TO PUT RESULT
         BAL   RC,OUENCONV         GO CONVERT VALUE
         SPACE 1
         LH    RE,AVNWARN          # WARNINGS ISSUED
         LA    RD,OUNWARN          @ FOR RESULT
         BAL   RC,OUENCONV         GO CONVERT VALUE
         SPACE 1
         LH    RE,AVNERRA          ACTUAL # ERRORS
         LA    RD,OUNERRA          @ FOR RESULT
         BAL   RC,OUENCONV         CONVERT VALUE
         $PRNT OUEND2M,OUEND2ML    PRINT 1ST MESSAGE
         SPACE 1
         LH    RE,AVNERR           GET LIMIT # ERRORS
         CH    RE,AVNERRA          COMPARE TO ACTUAL
         BNL   OUENDREA            SKIP TO EXIT CODE IF OK
         SPACE 1
         LA    RD,OUNERR           GET @ FOR CONVERTED RESULT
         BAL   RC,OUENCONV         GO CONVERT ACTUAL #
         $PRNT OUEND2N,OUEND2NL    PRINT 2ND MESSAGE
         SPACE 1
OUENDREA EQU   *                   EXIT CODE LABEL
         AIF   (&$COMNT EQ 0).OUNCOM2       SKIP IF NO COMMENT CHEKCING
         EJECT
*              FINAL CHECK - IF COMMENT CHECK OPTION IN EFFECT,
*              MAKE SURE PROGRAMMER HAS SUPPLIED COMMENTS ON AT LEAST
*              &$COMNT PER CENT OF MACHINE INSTRUCTIONS. IF NOT,
*              DELETE HIS EXECUTION.  SEE OUINT1 AND IAMOP1 FOR CODE.
         SPACE 1
         TM    AVTAGS2,AJOCOMNT    IS COMMENT OPTION IN EFFECT
         BZ    OUENDRET            NO, SO SKIP
         SPACE 1
         LH    RE,AVMACHIN         # MACHINE INSTRUCTIONS
         MH    RE,=H'&$COMNT'      * PERCENT REQUIRED TO HAVE COMMENTS
         LH    RD,AVCOMNTN         # COMMENTS ON THE MACH INSTRS
         MH    RD,=H'100'          BY 100 FOR COMPARISON
         CR    RD,RE               IS COMNTN>= MACHIN*&$COMNT/100
         BNL   OUENDRET            YES, SO HE HAD ENOUGH COMMENTS-OK
         SPACE 1
*              INSUFFICIENT COMMENTS - ZAP USER WITH MESSAGE.
         OI    AVTAGS1,AJNLOAD     NO EXECUTION
         $PRNT OUEND2P,OUEND2PL    PRINT THE MESSAGE
         SPACE 1
.OUNCOM2 ANOP
OUENDRET $RETURN SA=NO             RETURN TO CALLER
         SPACE 1
* * * * * OUENCONV - CONVERT AND EDIT INTEGER TO 6 BYTE FIELD         *
*        ENTRY CONDTIONS                                              *
*   RC = RETURN @ TO CALLING SECTION                                  *
*   RD = @ 6-BYTE FIELD WHERE CONVERTED AND EDITED RESULT TO BE PLACED*
*   RE = VALUE TO BE CONVERTED TO DECIMAL                             *
*        EXIT CONDTIONS                                               *
*        6-BYTE FIELD AT 0(RD) HAS EDITED RESULT, WITH 'NO' IF RE=0.  *
OUENCONV LTR   RE,RE               IS RESULT 0
         BZ    OUENCONO            YES, SO PU 'NO' IN
         CVD   RE,AVDWORK1         CONVERT VALUE TO DECIMAL
         MVC   0(6,RD),AWEP6       MOVE 6-BYTE EDIT PATTERN IN
         ED    0(6,RD),AVDWORK1+5  EDIT THE FIELD
         BR    RC                  RETURN TO CALLER
OUENCONO MVC   0(6,RD),=CL6'  NO  '         VALUE = 0, USE 'NO' INSTEAD
         BR    RC                  RETURN TO CALLER
         EJECT
* * * * * INTERNAL CONSTANTS                                          *
*              PRIMARY TYPE BRANCH OFFSETS                            *
OUJUMP1  $AL2  OUTJ1,(OUMACH,OUCONS,OULIST,OUCOMM)
*              SECONDARY BRANCH OFFSETS FOR LISTING CONTROL.          *
OUJUMP2  $AL2  OUTJ2,(OUSPEJ,OUPRINT,OUTITLE)
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
OUCOUNT  EQU   AVOUCOUN            H, WITHIN-PAGE LINES REMAINING
OULNCNT  EQU   AVOULNCN            PL3 - STATEMENT #
OUPGCNT  EQU   AVOUPGCN            PL2 - # PAGES
OUTOFFS  DS    ($RSMXCRD+1)C       SPACE FOR SAVING OFFSETS FOR CARDS
OUH#LINE DS    H                   # LINES PER PAGE, EXCEPT HEADING
         AIF   (NOT &$CMPRS).OUECMPA        SKIP IF NO CMPRS MODE
OUCMPRAD DS    A                   @ OUCMPRSD AREA, IF CMPRS OPT USED
.OUECMPA ANOP
         SPACE 1
*              PAGE HEADING 1 - TITLE FIELD,IF ANY, PAGE NUMBER       *
         DS    0D                  ALIGNMENT FOR MODEL 65+
OUHEAD1  DS    0CL121
         DC    CL8'1'              CARRIAGE CONTROL
OUHEADNG DS    CL100               SPACE FOR TITLE FIELD
         DC    CL9'    PAGE '
OUPCNT   DS    ZL4                 PAGE NUMBER
         SPACE 1
*              PAGE HEADING 2 - COLUMN HEADINGS AND DATE              *
         DS    0D                  ALIGNMENT FOR MODEL 65+
OUHEAD2  DS    0CL121
         DC    C'0  LOC  '         CARRIAGE CONTROL, LOCATION COUNTER
         DC    C'OBJECT CODE    ADDR1 ADDR2  STMT   SOURCE STATEMENT'
         DC    CL54' '
OUDATE   DC    CL8' '              DATE (IF AVAILABLE)
         EJECT
*              OUTPUT BUFFER SETUP FOR ALL STATEMENTS                 *
         DS    0D                  ALIGNMENT FOR SPEED IN MODELS 65+
OUTLINE  DS    0CL121
         DS    C                   CARRIAGE CONTROL
OULOC    DS    XL6                 SPACE FORLOCATION COUNTER
         DS    C
OUCONST  DS    0XL16               SPACE FOR UP TO 8 BYTES CONVERTED
OUOPR1R2 DS    XL4                 SPACE FOR CONVERTED OPCODE-R1-R2
         DS    C
OUOPN1   DS    XL4                 CONVERTED 1ST BASE-DISPLACEMENT
         DS    C
OUOPN2   DS    XL4                 CONVERTED 2ND BASE DISPLACEMENT
OUEA1    DS    XL6                 CONVERTED 1ST INSTRUCTION ADDRESS
OUEA2    DS    XL6                 CONVERTED 2ND INSTRUCTION ADDRESS
         DS    C
OUTLENM  EQU   *-OULOC             LENGTH FOR TRANSLATE: MACHINE OPS
         SPACE 1
OUDSTMNT DS    ZL5                 STATEMENT NUMBER
         DS    C                   BLANK OR PLUS
OUTLEN   EQU   *-OUTLINE           LENGTH FOR BLANKING ORIGINAL
OUSOURCE DS    0CL80               SOURCE STATEMENT
OUSOURC  DS    CL71                SOURCE CARD,WITHOUT CONT/SEQNO
OUCONSQ  DS    CL9                 CONTINUATION/SEQUENCE # FIELD
         SPACE 1
*              OUTPUT BUFFER SETUP FOR ERROR MESSAGES                 *
         DS    0D
OUTERROR DS    0CL121              ERROR LINE
OUTERRAS DC    CL9' ----->AS'      ERROR FLAG - LEFT
OUTERMS  DC    CL32' '             SPACE FOR ERROR MESSAGE
OUTEOFF  EQU   *-RSB$L             OFFSET FROM SOURCE IMAGE
         DC    72C'-',CL8' <-ERROR'         SPACE FOR $, END FLAG
OUTEREND EQU   *-9                 @ LAST POSSIBLE SCAN POINTER
         AIF   (&$OPTMS LE 2).OUOP5A   SKIP IF SMALL MEMORY
OUBLDASH DC    CL(L'OUTERMS)' ',18C'-'      FOR REBLANKING ERROR FIELD
.OUOP5A  ANOP
         SPACE 1
*              FINAL MESSAGE(S) ON STATEMENTS FLAGGED,WARNINGS,ETC.   *
*              THIS SECTION USED BY ENTRYPT OUEND2.
OUEND2M  DC    C'0***'
OUSTMTER DC    ZL6'0',C' STATEMENTS FLAGGED -'
OUNWARN  DC    ZL6'0',C' WARNINGS,'         # WARNINGS ISSUED
OUNERRA  DC    ZL6'0',C' ERRORS'   # ERRORS
OUEND2ML EQU   *-OUEND2M           LENGTH OF THIS MESSAGE
         SPACE 1
OUEND2N  DC    C'0***** NUMBER OF ERRORS EXCEEDS LIMIT OF'
OUNERR   DC    ZL6'0',C' ERRORS - PROGRAM EXECUTION DELETED *****'
OUEND2NL EQU   *-OUEND2N           LENGTH OF THIS ERROR MESSAGE
         AIF   (&$COMNT EQ 0).OUNCOM3       SKIP IF NO COMMENT CHEK
OUEND2P  DC    C'0***** EXECUTION DELETED - LESS THAN &$COMNT '
         DC    C'PER CENT OF MACHINE INSTRUCTIONS HAVE COMMENTS *****'
OUEND2PL EQU   *-OUEND2P           GET LENGTH OF WHOLE MESSAGE
         SPACE 1
.OUNCOM3 ANOP
         SPACE 1
OUAS999  DC    C'0AS999'           MESSAGE NUMBER
         AIF   (&$OPTMS LE 2).OUAS999  SKIP IF LOW CORE USAGE
         DC    C' DYNAMIC STORAGE EXCEEDED'
.OUAS999 ANOP
OUAS999L EQU   *-OUAS999           LENGTH OF MESSAGE
         LTORG
         EJECT
*              ERROR POINTERS AND ERROR MESSAGES                      *
*              FOR ADDRESSIBILITY, THIS SECTION SHOULD BE LAST.       *
*        **NOTE** FOR SMALL COMPUTERS, THIS CODE CAN BE GREATLY       *
*        BY MODIFYING MACRO $SERR TO GENERATE ONLY THE ERROR NUMBERS. *
         AIF   (&$OPTMS LE 2).OUOP6         SKIP IF SMALL MEMORY
*        THE PROGRAM LOGIC REMIANS UNCHNAGED, BUT 1100 BYTES CAN BE   *
*        SAVED WHICH ARE CURRENTLY TAKEN BY THE ERROR MESSAGES.       *
*              THE TABLE CONSISTS OF 2 SECTIONS: A HALFWORD OFFSET    *
*              @ LIST, AND A LIST OF MESSAGES CREATED BY $SERR'S,     *
*              WHICH ARE POINTED TO BY THE OFFSET @'S.                *
         SPACE 1
         DS    0H                  ALIGN ON HALF WORD BPUNDARY
OUERRPT   EQU  *-2 .               OFFSET TO 1 ' BACKWARDS
         DS    (&$ERNUM/2)H .      SPACE FOR HALFWORD ERROR POINTERS
.OUOP6   ANOP
         EJECT
OUERRMS  EQU   *                   BASE ADDRESS FOR ERROR MESSAGES
ALIGN    $SERR 'W-ALIGNMENT ERROR-IMPROPER BOUNDARY',000
ENTRY    $SERR 'W-ENTRY ERROR-CONFLICT OR UNDEFINED',001
EXTRN    $SERR 'W-EXTERNAL NAME ERROR OR CONFLICT',002
RGNUS    $SERR 'W-REGISTER NOT USED',003
ODDRG    $SERR 'W-ODD REGISTER USED-EVEN REQUIRED',004
NOEND    $SERR 'W-END CARD MISSING-SUPPLIED',005
ADDR     $SERR 'ADDRESSIBILITY ERROR',100
CNLNG    $SERR 'CONSTANT TOO LONG',101
CNTYP    $SERR 'ILLEGAL CONSTANT TYPE',102
CONT     $SERR 'CONTINUATION CARD COLS. 1-15 NONBLANK',103
CONTX    $SERR 'MORE THAN 2 CONTINUATION CARDS',104
CXREL    $SERR 'COMPLEX RELOCATABILITY ILLEGAL',105
DCEXT    $SERR 'TOO MANY OPERANDS IN DC',106
DPCSE    $SERR 'MAY NOT RESUME SECTION CODING',107
DUPLF    $SERR 'ILLEGAL DUPLICATION FACTOR',108
EXGTA    $SERR 'EXPRESSION TOO LARGE',109
EXLTA    $SERR 'EXPRESSION TOO SMALL',110
ICNOP    $SERR 'INVALID CNOP OPERAND(S)',111
ILLAB    $SERR 'LABEL NOT ALLOWED',112
ILORG    $SERR 'ORG VALUE IN WRONG SECTION OR TOO LOW',113
INVCN    $SERR 'INVALID CONSTANT',114
INVDM    $SERR 'INVALID DELIMITER',115
INVF     $SERR 'INVALID FIELD',116
INVSY    $SERR 'INVALID SYMBOL',117
IVOPC    $SERR 'INVALID OP-CODE',118
MULDF    $SERR 'PREVIOUSLY DEFINED SYMBOL',119
NEABS    $SERR 'ABSOLUTE EXPRESSION REQUIRED',120
NODLM    $SERR 'MISSING DELIMITER',121
NOIMP    $SERR 'FEATURE NOT CURRENTLY IMPLEMENTED',122
NOOPR    $SERR 'MISSING OPERAND',123
NONAM    $SERR 'LABEL REQUIRED',124
RELOC    $SERR 'RELOCATABLE EXPRESSION REQUIRED',126
SDINV    $SERR 'INVALID SELF-DEFINING TERM',127
START    $SERR 'ILLEGAL START CARD',128
TLIT     $SERR 'ILLEGAL USE OF LITERAL',129
UNDEF    $SERR 'UNDEFINED SYMBOL',130
UNRV     $SERR 'UNRESOLVED EXTERNAL REFERENCE',131
VILCH    $SERR 'ILLEGAL CHARACTER',132
VPARN    $SERR 'TOO MANY PARENTHESIS LEVELS',133
VRELO    $SERR 'RELOCATABLE VALUE USED WITH * OR /',134
VSYNT    $SERR 'SYNTAX',135
VTMTR    $SERR 'TOO MANY TERMS IN EXPRESSION',136
VUNEX    $SERR 'UNEXPECTED END OF EXPRESSION',137
INTPT    $SERR 'STATEMENT CAUSED INTERRUPT',138
         AIF   (NOT &$MACROS).OUSERR1       SKIP IF NO MACROS
ILOPR    $SERR 'OPERAND NOT ALLOWED',201
STMNA    $SERR 'STATEMENT OUT OF ORDER',202
SSDIM    $SERR 'SET SYMBOL DIMENSION ERROR',203
INSBV    $SERR 'INVALID NBR OF SUBSCRIPTS',204
ILCNV    $SERR 'ILLEGAL CONVERSION',205
MISQU    $SERR 'MISSING QUOTES IN CHAR EXPR',206
ILMNM    $SERR 'ILLEGAL OR DUP MACRO NAME',207
MXDMD    $SERR 'OPRND NOT COMPATIBLE WITH OPRTR',208
UNDKW    $SERR 'UNDFND OR DUP KEYWORD',209
EXMAC    $SERR 'MNEST LIMIT EXCEEDED',210
ILAT     $SERR 'ILLEGAL ATTRIBUTE USE',211
MEXST    $SERR 'GENERATED STMT TOO LONG',212
OVRGN    $SERR 'GENERATED STMTS OVERWRITTEN',298
.OUSERR1 SPACE 1
         DROP  RAT,R2,RC,RD,RX,RZ  REMV USINGS
         AIF   (NOT &$CMPRS).OUCMDSE        SKIP IF NO CMPRS CODE
         EJECT
**--> DSECT: OUCMPRSD   CONTROL BLOCK FOR OUTPUT CMPRS OPTION . . . . .
*.       THIS BLOCK DESCRIBES AREA USED BY OUTPT2 WHEN DOING THE      .
*.       CMPRS LISTING OPTION (2 STMTS/LINE).  IT CONTAINS VARIABLES, .
*.       FLAGS, AND SPACE FOR $OU#NORM PARTIAL CARD IMAGES, WHICH     .
*.       ARE SAVED AND USED FOR THE LEFT-HAND-SIDE OF THE PAGE.       .
*.       THIS BLOCK IS ALLOCATED SPACE ONLY IF THE CMPRS PARM IS      .
*.       USED.  THE @ OUCMPRSD IS STORED IN OUCMPRAD VARIABLE.        .
*.       LOCATION: IN DYNAMIC AREA, ACQUIRED BY $ALLOCH IN OUINT1.    .
*.       NAMES: OUCM----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
OUCMPRSD DSECT
*              LENGTH EQUS FOR PARTS OF STMT ACTUALLY PRINTED/SAVED.
OUCM$LT  EQU   (&$PRTSIZ-3)/2      TOTAL # BYTES SAVED PER CMPRS STMT
OUCM$L1  EQU   OUEA1-OULOC         # BYTES IN FIRST PART OF STMT
OUCM$L2  EQU   OUCM$LT-OUCM$L1     # BYTES SAVED, FROM OUDSTMT-1
         SPACE 1
*              CMPRS OPTION PHASE EQUATE FLAGS.
OUCMPHSB EQU   B'00000001'         (OUCMPHAS)- PHASE B - PRINTING CARDS
         SPACE 1
*              CMPRS PROCESSING VARIABLES.
OUCMSTMT DS    A                   @ SLOT FOR NEXT CARD SAVED/PRINTED
OUCMOPAG DS    H                   # STMTS TOTAL ON CURRENT PAGE
OUCMLEFT DS    H                   # SLOTS LEFT/ # ALREADY PRINTED
OUCMPHAS DS    B                   PHASE FLAG - A OR B.
OUCMCCIN DS    C                   CARRIAGE CONTROL INIT - '0' OR '1'
         SPACE 1
*              STATEMENT ASSEMBLY AREA - HOLDS BOTH HALVES OF A
*              LINE FOR PRINTING, DURING PHASE B OF PROCESSING.
         DS    0F                  ALIGN FOR POSSIBLE SPEED
OUCMLINE DS    0CL133
OUCMLICC DS    C                   CARRIAGE CONTROL BYTE
OUCMSTMA DS    CL(OUCM$LT)         SPACE FOR CARD SAVED IN PHASE A
OUCMBREK DS    CL2' '              BREAK - MUST INIT TO C'  '
OUCMSTMB DS    CL(OUCM$LT)         SPACE FOR CARD FROM PHASE B
         SPACE 1
*              CARD SEGMENT SAVE AREA - DURING PHASE A, ENOUGH CARDS
*              ARE SAVED HERE FOR LEFT-HAND-SIDE OF PAGE.
OUCMSAVE DS    ($OU#LNS)CL(OUCM$LT)         1 PAGE OF STMT SEGMENTS
         SPACE 1
OUCMPR$L EQU   ((*-OUCMPRSD+3)/4)*4         DSECT TOTAL LENGTH, ROUNDED
         SPACE 2
**--> DSECT: OUSTMTIM   STATEMENT IMAGE USED IN OUTPUT  . . . . . . . .
*.       USED IN CMPRS OPTION HANDLER OF OUTPT2 TO ACCESS PORTIONS    .
*.       OF INCOMING STATEMENTS TO BE SAVED.                          .
*.       NAMES: OUST----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
OUSTMTIM DSECT
OUSTCC   DS    C                   CARRIAGE CONTROL
OUSTP1   DS    CL(OUCM$L1)         FIRST PART - LOC, OBJ CODE
         DS    2XL6                SKIP ADDR1-ADDR2, DON'T SAVE
OUSTP2   DS    CL(OUCM$L2)         2ND PART - STMT #, PART OF CARD
.OUCMDSE ANOP
         TITLE '*** SCANRS - SCANNING ROUTINES -SCAN-BL,CO,EQ ***'
**--> CSECT: SCANRS   1-2 SCANNING ROUTINES . . . . . . . . . . . . . .
*.       SCANRS CONTAINS VARIOUS UTILITY SCANNING ROUTINES. ALL 3     .
*.       ENTRIES TERMINATE SCANNING ON FINDING A BLANK. 1 ENTRY ALSO  .
*.       STOPS FOR A COMMA, AND THE OTHER STOPS FOR AN EQUALS SIGN.   .
*.       ****NOTE**** THIS ROUTINE MODIFIES TABLE AWTZTAB IN AVWXTABL..
*.       IT MAY THEN CALL SDBCDX WITHOUT RESETTING THE TABLE. THIS    .
*.       IS AN EXCEPTION TO THE RULE OF NOT PERMITTING MODIFICATION   .
*.       TO AV------ SECTIONS WHEN CALLING ANOTHER MODULE.            .
*.       CALLS SDBCDX                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $CALL,$RETURN,$SAVE,$SETRT                      .
*.       NAMES: SCAN----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANRS   CSECT
         $DBG  90,*
         USING AVWXTABL,RAT        NOTE MAIN USING
         ENTRY SCANBL,SCANCO,SCANEQ
         SPACE 2
**--> ENTRY: SCANEQ       SCAN TO = OR BLANK(USED BY IAMOP1 FOR LITERA.
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER                                                 .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO = OR BLANK, OR ERROR IF ANY                  .
*.  RB = 0    IF SCAN OK, = ERROR CODE IF ERROR FOUND(IN SELF-DEF TRM).
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANEQ   $SAVE RGS=(R14-R2),SA=SCANSAVE     SAVE REGS,SET UP SA @
         $SETRT ('=',4)            SET UP CODE FOR =
         B     SCANGO              GO TO COMMON SECTION OF CODE
         SPACE 2
**--> ENTRY: SCANCO       SCAN TO COMMA OR BLANK (USED BY A-TYPE ADCON.
*.       ENTRY AND EXIT CONDITIONS SAME AS SCANEQ                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANCO   $SAVE RGS=(R14-R2),SA=SCANSAVE     SAVE REGS,SET UP SA @
         $SETRT (',',4)            SET THE SCAN CODE FOR ,
         B     SCANGO              GO TO COMMON SECTION OF CODE
         SPACE 2
**--> ENTRY: SCANBL       SCAN TO BLANK ONLY. . . . . . . . . . . . . .
*.       ENTRY AND EXIT CONDITIONS SAME AS SCANEQ                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SCANBL   $SAVE RGS=(R14-R2),SA=SCANSAVE,BR=R13   SAVE REGS, SET UP SA @
*              FALL THRU INTO COMMON SECTION OF CODE, SCANGO.
         EJECT
* * * * * COMMON CODE SECTION FOR SCANNING AND RESETTING TRT TABLE    *
SCANGO   $SETRT (' ',4,'''',8)     SET FOR QUOTE AND BLANK
         SR    R1,R1               CLEAR FOR INSERTING ADDRESS
         SR    R2,R2               CLEAR CODE INSERTION
         SR    RB,RB               CLEAR TO SHOW OK
*              INITIALIZATION DONE. REMAINDER IS SCAN LOOP            *
SCANTRT  TRT   0(256,RA),AWTZTAB   SCAN FOR ',BLANK OR EITHER = OR ,
         LR    RA,R1               MOVE THE SCAN POINTER OVER
         B     *(R2)               BRANCH APPROPRAITELY(CC=0 IMPOSSIB)
         B     SCANRETA            CHAR WAS =, OR BLANK-RETURN
         BCTR  R1,0                CHAR WAS QUOTE-BACK UP TO SEE BEFORE
         CLI   0(R1),C'L'          WAS THIS LENGTH ATTRIBUTE
         BNE   SCANSDT             NO-MUST BE SELF-DEFINING TERM-BRANCH
         LA    RA,2(R1)            INCREMENT SCAN POINTER PAST L'
         B     SCANTRT             GO BACK FOR NEXT SCAN
*              SELF-DEFINING TERM TENTATIVELY FOUND-CHECK             *
SCANSDT  LR    RA,R1               MOVE THE SCAN POINTER OVER
         $CALL SDBCDX              CALL ROUTINE(RB=0==>SCAN ONLY)
         LTR   RB,RB               DETERMINE RESULT
         BP    SCANRETA            ERROR FOUND,RETURN WITH IT
         BM    *+12                INVALID, ' BUT NOT X' B' C' L'
         CLI   0(RA),C''''         CHECK FOR CL21' ' TYPE ERROR IN OPRN
         BNE   SCANTRT             IF NOT,OK, CONTINUE, ELSE ERROR
         LA    RB,$ERINVDM         WE HAVE ',BUT NOTSDTRM-ERROR
SCANRETA $SETRT (' ',0,'''',0,'=',0,',',0)  REZERO ALL BYTES USED
         SPACE 1
SCANRET  $RETURN RGS=(R14-R2)      RETURN   TO CALLER
         DROP  RAT,R13             CLEAN UP USING SITUATION
         TITLE '*** SDTERM - SELF-DEFINING TERM PROCESSORS ***'
**--> CSECT: SDTERM     SELF-DEFINING TERM CONVERSIONS. . . . . . . . .
*.       SDTERM INCLUDES AN ENTRY POINT FOR CONVERTING EACH TYPE OF   .
*.       SELF-DEFINING TERM, AND AN ENTRY POINT WHICH FIRST DECIDES   .
*.       WHICH TYPE(IF ANY) THE SCAN POINTER IS POINTING AT, THEN     .
*.       BRANCHES TO THE CORRECT SECTION TO CONVERT THE TERM.         .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDTERM   CSECT
         $DBG  90,SNAP
         ENTRY SDBCDX,SDBTRM,SDCTRM,SDDTRM,SDXTRM
         USING AVWXTABL,RAT        NOTE MAIN USING
         SPACE 2
**--> ENTRY: SDBCDX   1-2 DETERMINE TYPE OF SELF-DEFINING TERM-CHECK. .
*.       DECIDE TYPE OF SELF-DEFINING TERM, BRANCH TO RIGHT SECTION.  .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO BEGINNING OF TERM- TO C,B,X, OR 1ST DIGIT    .
*.       EXIT CONDITIONS                                              .
*.  RA = SCAN POINTER TO DELIMITER BEYOND TERM,(NOT ' ENDING B,C,X)   .
*.  RB = 0    SELF DEFINING TERM WAS LEGAL                            .
*.  EB = >0 - ERROR CODE - ILLEGAL TERM ($ERSDINV)                    .
*.  RB = -4 ==> SCAN POINTER DID NOT POINT AT SELF-DEFINING TERM      .
*.  RC = VALUE OF SELF-DEFINING TERM, FROM 0 TO 2**24-1               .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDBCDX   $SAVE SA=NO
         CLI   0(RA),C'0'          CHECK FOR DIGITS
         BNL   SDDTRM1             GO PROCESS DECIMAL FIELD
         CLI   1(RA),C''''         IS 2ND CAHR A '
         BNE   SDBCDX1             NO, SO RETURN SHOWING NO SELF-DEF TR
         CLI   0(RA),C'C'          CHARACTER TYPE
         BH    SDTX                HIGHER THAN C,TRY X
         BE    SDCTRM1             PROCESS C'----
         CLI   0(RA),C'B'          BINARY TYPE
         BE    SDBTRM1             PROCESS BINARY TERM
         B     SDBCDX1             EROR, NOT ONE OF THESE
SDTX     CLI   0(RA),C'X'          HEXADECIMAL TYPE
         BE    SDXTRM1             PROCESS HEX TERM
SDBCDX1  L     RB,AWFM4            PUT NEGATIVE 4 IN FOR RETURN CODE
         $RETURN SA=NO
         EJECT
**--> ENTRY: SDBTRM   1-2 SCAN, COMPUTE BINARY SELF-DEFINING TERM . . .
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDB-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDBTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDBTRM   $SAVE RGS=NO,SA=NO
         LA    RA,2(RA)            INCREMENT BEYOND B'
         CLI   0(RA),C''''         MAKE SURE NOT NULL CONST
         BE    SDBINVCN            NULL CONSTANT-ILLEGAL
         SR    RC,RC               CLEAR REGISTER RESULT APPEARS IN
         LA    RD,1                FOR LOOP INCREMENT
         LA    RE,24(RA)           FOR LIMIT ADDRESS
         SPACE 1
SDBLOOP  CLI   0(RA),C'0'          CHECK FOR 0
         BE    SDBLOOPB            IF SO, JUST SHIFT RESULT
         CLI   0(RA),C'1'          CHECK FOR  A 1
         BNE   SDBOUT              BRANCH IF NOT, SHOULD BE '
         AR    RC,RD               ADD A 1 INTO REGISTER
SDBLOOPB AR    RC,RC               = SLL RC,1 - SHIFT TO NEXT
         BXLE  RA,RD,SDBLOOP       CONTINUE LOOPING
         BCT   RA,SDBINVCN         TOO LARGE, BACK UP AND FLAG
         SPACE 1
SDBOUT   CLI   0(RA),C''''         MAKE SURE DELIMETER IS '
         BNE   SDBINVCN            IF NOT , ILLEGAL
         AR    RA,RD               POINT TO NEXT BEYOND
         SRL   RC,1                SHIFT BACK FOR CORRECT RESULT
         SR    RB,RB               SHOW NO ERRORS
SDBRET   $RETURN SA=NO,RGS=NO
SDBINVCN LA    RB,$ERSDINV         SHOW ILLEGAL
         B     SDBRET              RETURN
         EJECT
**--> ENTRY: SDCTRM   1-2 SCAN, COMPUTE CHARACTER SELF-DEFINING TERM. .
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDC-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDCTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDCTRM   $SAVE RGS=NO,SA=NO
         SR    RC,RC               CLEAR REGISTER FOR RESULT
         LA    RD,1                FOR USEFUL CONTANT
         AR    RA,RD               INCREMENT FOR  C TO '
         LA    RE,4                LIMIT = MAX CHARS(3)+1
         SPACE 1
*              SCAN LOOP - CHECK FOR 'S AND &S AND LENGTH <4 BYTES.
SDCLOOP  AR    RA,RD               INCREMENT TO LOOK AT NEXT SLOT
         CLI   0(RA),C''''         IS IT A QUOTE
         BE    SDCQUOT             YES-BRANCH
         CLI   0(RA),C'&&'         IS IT AN &
         BNE   SDCNORM             NO, GO DO NORMAL CASE
         AR    RA,RD               INCREMENT TO NEXT SLOT
         CLI   0(RA),C'&&'         IS THIS ONE & ALSO
         BE    SDCNORM             2 &&'S TOGETHER-OK
         B     SDCINVCN            INVALID - SINGLE & BY ITSELF
         SPACE 1
SDCQUOT  AR    RA,RD               LOOK AT NEXT CHAR
         CLI   0(RA),C''''         IS IS FOLLOWED BY '
         BNE   SDCOUT              NO, IT IS END OF CONST
SDCNORM  SLL   RC,8                SHIFT 1 CHRACTER WORTH
         IC    RC,0(RA)            GET THE CHARACTER
         BCT   RE,SDCLOOP          KEEP GOING-UP TO 24 BITS WORTH
         SPACE 1
         B     SDCINVCN            FELL THRU-MORE THAN 3 CHARS-ILLEGAL
SDCOUT   C     RE,AWF3             WAS THERE A NULL CONSTANT
         BH    SDCINVCA            RE = 4 ==> NULL CONST,ILLEGAL
         SR    RB,RB               SHOW NO ERRORS
SDCRET   $RETURN RGS=NO,SA=NO
SDCINVCA SR    RA,RD               NULL CONST-BACK UP SCAN PTR 1
SDCINVCN LA    RB,$ERSDINV         SHOW INVALID
         B     SDCRET              GO RETURN
         EJECT
**--> ENTRY: SDDTRM   1-2 CHECK OR CONVERT DECIMAL SELF-DEFINING TERM .
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDD-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDDTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDDTRM   $SAVE RGS=(R1-R2),SA=NO
         LR    RD,RA               DUPLICATE SCAN POINTER
         SR    R1,R1               CLEAR FOR USE WITH TRT
         TRT   0(9,RD),AWTDECT     TRANSLATE WITH DECIMAL TABLE
         BZ    SDDINVCN            MORE THAN 9 DIGITS, ERROR
         LR    RA,R1               MAKE R1 NEW SCAN POINTER
         SR    R1,RD               SUBTRACT TO GET LENGTH
         BZ    SDDINVCN            IF ZERO LENGTH,ILLEGAL
         SPACE 1
         BCTR  R1,0                GET LENGTH-1 FOR EXECUTE
         EX    R1,SDDPACK          PACK THE CHARS IN
         CVB   RC,AVDWORK1         CONVERT THE NUMBER
         C     RC,AWFX6F           COMPARE TO HIGHEST VALUE
         BH    SDDINVCM            IF TOO BIG, BACK UP SCAN PTR,RETURN
         SPACE 1
         SR    RB,RB               SHOW NO ERRORS EXIST
SDDRET   $RETURN RGS=(R1-R2),SA=NO
SDDINVCM BCTR  RA,0                DECREMENT SCAN POINTER BY 1
SDDINVCN LA    RB,$ERSDINV         SHOW INVALID SD TERM
         B     SDDRET              GO RETURN WITH ERROR
         SPACE 1
SDDPACK  PACK  AVDWORK1(8),0($CHN,RD)        PACK A DECIMAL FIELD
         EJECT
**--> ENTRY: SDXTRM   1-2 SCAN, COMPUTE HEXADECIMAL SELF-DEFINING TERM.
*.       ENTRY,EXIT CONDITONS SAME AS SDBCDX, EXCEPT RB >= 0 ON EXIT. .
*.       NAMES: SDX-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SDXTRM1  BALR  R15,0               SET UP ADDRESS AS EXPECTED ON ENTRY
SDXTRM   $SAVE RGS=(R1-R2),SA=NO
         LA    RA,2(RA)            INCREMENT PAST X'
         SR    R1,R1               CLEAR FOR TRT
         TRT   0(7,RA),AWTHEXT               CHECK FOR LEGALITY
         BZ    SDXINVCX            TOO LARGE, GO FLAG IT
         CLI   0(R1),C''''         CHECK FOR PROPER DELIMIETER
         BNE   SDXINVCY            INVALID CHARACTER,ERROR
         SPACE 1
         LR    RD,RA               SAVE THE SCAN POINTER
         LA    RA,1(R1)            INCREMENT THE SCAN POINTER
         SR    R1,RD               GET THE LENGTH
         BZ    SDXINVCW            NULL CONSTANT-BRANCH ERROR
         SPACE 1
         EX    R1,SDXMOVE          MOVE THE CONST+1 EXTRA BYTE OVER
         EX    R1,SDXTRAN          TRANSLATE THE BYTES APPROPRIATELY
         EX    R1,SDXPACK          PACK THEM TOGETHER
         L     RC,AVDWORK1         LOAD FULLWORD VALUE INTO REG
         SR    RB,RB               SHOW LEGAL VALUE
SDXRET   $RETURN RGS=(R1-R2),SA=NO
         SPACE 1
SDXINVCW BCT   RA,SDXINVCN         BACK UP SCAN PTR,GO RETURN ERR
SDXINVCX LA    R1,6(RA)            TOO LONG-PLACE SCAN PTR RIGHT
SDXINVCY LR    RA,R1               MOVE SCAN POINTER OVER
SDXINVCN LA    RB,$ERSDINV         INVALID SELF-DEFINING TERM
         B     SDXRET              GO RETURN
         SPACE 1
SDXMOVE  MVC   AVDWORK2($CHN),0(RD)          MOVE HEX TERM TO WORKAREA
SDXTRAN  TR    AVDWORK2($CHN),AWTHEX2        CONVERT HEX TO BINARY
SDXPACK  PACK  AVDWORK1(5),AVDWORK2($CHN)    DO CORRECT PACK-INTERNAL
         DROP  RAT,REP             CLEAN UP USING
         TITLE '*** SYMOPS - ASSIST SYMBOL TABLE OPERATIONS ***'
**--> CSECT: SYMOPS   1-2 ALL NORMAL SYMBOL TABLE OPERATIONS. . . . . .
*.       SYMOPS BUILDS, MAINTAINS, AND RETRIEVES FROM THE SYMBOL      .
*.       TABLE OF THE ASSIST ASSEMBLER.  THE SYMBOL TABLE IS A VIRUTAL.
*.       SCATTER TABLE, WITH CHAIN ORDERING BY A SECONDARY HASH CODE. .
*.       ALL SYMBOLS ARE HASHED INTO A SMALL PRIMARY POINTER TABLE.   .
*.       EACH WORD IN THE PRIMARY TABLE POINTS TO A LINKED LIST OF    .
*.       SYMBOLS HASHING TO THAT LOCATION IN THE PRIMARY TABLE. THE   .
*.       SYMBOLS ARE ORDERED ON THE LIST IN DESCENDING ORDER BY THE   .
*.       VALUE OF A SECOND HASH CODE, WHICH IS KEPT IN THE LINK       .
*.       POINTER POINTING TO THE SYMBOL TO WHICH IT BELONGS.  THIS    .
*.       METHOD IS USED BECAUSE MAKES NO ASSUMPTIONS ABOUT THE FINAL  .
*.       SIZE OF THE FINAL SYMBOL TABLE, PERMITTING ALLOCATION OF     .
*.       ENTRIES FROM THE DYNAMIC AREA.  IT ALSO PERMITS A VERY FAST  .
*.       (3 FAST INSTRUCTIONS) MAJOR SEARCH LOOP, WHICH STILL GIVES   .
*.       GOOD PERFORMACNE EVEN WITH A SMALL INITIAL POINTER TABLE     .
*.       AND LONG LISTS OF SYMBOLS.                                   .
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,SYMSECT                                .
*.       USES MACROS: $ALLOCH,$CALL,$RETURN,$SAVE                     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
SYMOPS   CSECT
         $DBG  90,*
&$SYHASH SETA  8                   SET UP 1ST VALUE
         AIF   (&$OPTMS EQ 0).SYHA
&$SYHASH SETA  16                  TRY ALRGER VALUE
         AIF   (&$OPTMS LE 3).SYHA SKIP IF NOW HAVE RIGHT VALUE
&$SYHASH SETA  32                  LARGER VALUE
         AIF   (&$OPTMS LE 6).SYHA          SKIP IF NOW HAVE VALUE
&$SYHASH SETA  64                  LARGEST VALUE CURRENTLY
.SYHA    ANOP
*              USING VALUE OF &$OPTMS, DETERMINE SIZE OF INITIAL POINT*
*        HASH TABLE.  VALUES ARE (&$OPTMS)-&$SYHASH -                 *
*        (0)-8, (1-3)-16, (4-6)-32, (7-9)-64.   THE RELATIVELY SMALL  *
*        SIZES CAN BE TOLERATED BECAUSE OF THE SECONDARY KEY ORDERING.*
         SPACE 1
         ENTRY SYINT1,SYENT1,SYFIND,SYEND2
         USING AVWXTABL,RAT        NOTE MAIN USING
         EJECT
**--> ENTRY: SYINT1   1   INITIALIZE SYMBOL TABLE . . . . . . . . . . .
*.       OBTAINS SPACE FOR INITIAL POINTER TABLE, ZEROES IT.          .
*.       ALSO SAVES THE ADDRESS OF THE INITIAL POINTER TABLE.         .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SYINT1   $SAVE RGS=(R14-R6),SA=NO
         LM    R0,R7,AWZEROS       GET ZEROS FOR ZEROING HASH TABLE
         LA    R10,32              # BYTES ZEROED BY EACH STM
         LA    R11,4*&$SYHASH      GET LENGTH OF INITIAL PTR TABLE
         $ALLOCH R9,R11,SYOVER     ALLOCATE THE REQUIRED SPACE
         AR    R11,R9              END TABLE @ = BEGIN TABLE @ + LENGTH
         SPACE 1
         SR    R11,R10             BXLE LIMIT = END @ - LOOP INCREMENT
         ST    R9,SYRA             SAVE THE BEGIN TABLE @ FOR LATER
SYIZERO  STM   R0,R7,0(R9)         ZERO 32 BYTES OF INDEX TABLE
         BXLE R9,R10,SYIZERO       CONTINUE ZEROING
         $RETURN RGS=(R14-R6),SA=NO
         EJECT
**--> ENTRY: SYENT1   1   ENTER A SYMBOL INTO TABLE,RETURN ADDRESS. . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO FIRST CHARACTER OF THE SYMBOL                .
*.  RB = NUMBER OF CHARACTERS IN THE SYMBOL  =  1 - 8                 .
*.       EXIT CONDITIONS                                              .
*.  RA = ADDRESS IN THE SYMBOL TABLE WHERE SYMBOL IS                  .
*.  RB = 0    THE SYMBOL WAS ALREADY PRESENT IN THE TABLE             .
*.     = 4    THE SYMBOL WAS NOT ALREADY PRESENT IN THE TABLE         .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         AIF   (NOT &$XREF).NOXRF19
SYENT1   $SAVE RGS=(R14-R6),SA=SYXRSA,BR=R2  **NOTE ODD BASE REG***
         AGO   .NOXRF20            SKIP OLD SAVE MACRO
.NOXRF19 ANOP
SYENT1   $SAVE RGS=(R3-R6),SA=NO
.NOXRF20 ANOP                                                         A
         LA    RC,SYENTER          SET UP FOR BRANCH LATER ON
         LA    RW,SYRETB           SET UP FOR BRANCH LATER            L
         AIF   (NOT &$XREF).NOXRF22  SKIP IF NO XREF                  A
         B     SYXFINDX            GO TO ROUTINE                      A
         AGO   .NOXRF23            SKIP OLD CODE IF XREF              A
.NOXRF22 ANOP                                                         A
         LA    REP,SYFIND          SET UP FOR NEW USING
         USING SYFIND,REP          SET SO BRANCH WILL WORK
         B     SYFINDA             GO TO COMMON CODE SECTION
.NOXRF23 ANOP                                                         A
         SPACE 2
**--> ENTRY: SYFIND   1-2 LOOK UP SYMBOL,REPORT PRESENCE/ADDRESS. . . .
*.       ENTRY CONDITIONS                                             .
*.  RA = SCAN POINTER TO FIRST CHARACTER OF THE SYMBOL                .
*.  RB = NUMBER OF CHARACTERS IN THE SYMBOL  =  1 - 8                 .
*.       EXIT CONDITIONS                                              .
*.  RA = ADDRESS OF THE SYMBOL IN THE SYMBOL TABLE, IF IT IS THERE    .
*.  RB = 0    THE SYMBOL IS IN THE TABLE                              .
*.     = 4    THE SYMBOL IS NOT IN THE TABLE                          .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         AIF   (NOT &$XREF).NOXRF24                                   A
SYFIND   $SAVE RGS=(R14-R6),SA=SYXRSA,BR=R2     ***NOTE ODD BASE REG  A
         AGO   .NOXRF25                                               A
.NOXRF24 ANOP                                                         A
SYFIND   $SAVE RGS=(R3-R6),SA=NO
.NOXRF25 ANOP                                                         A
         LA    RC,SYRETA           SET ADDRESS FOR LATER
         LA    RW,SYRET            SET UP FOR BRANCH LATER            L
         AIF   (NOT &$XREF).NOXRF88    SKIP IF NO XREF                A
SYXFINDX BALR  R2,0                SET UP BASE REG                    A
         USING *,R2                                                   A
.NOXRF88 ANOP                                                         A
         SPACE 1
*              GET SYMBOL, PAD WITH BLANKS, GET LENGTH OF SYMBOL      *
*              THE FOLLOWING CODE IS COMMON TO BOTH SYFIND AND SYENT1 *
SYFINDA  STC   RB,SYCOMP2+1        SAVE THE LENGTH INTO CLC
         BCTR  RB,0                DECRMENT LENGTH FOR MOVE
         MVC   SYMTEMP,AWBLANK     FILL WITH BLANKS FOR PADDING
         STC   RB,SYMTEMPC         SAVE VALUE IN FRONT OF SYMBOL
         STC   RB,*+5              PUT LENGTH INTO MVC INSTRUCTION
         MVC   SYMTEMP($CHN),0(RA)           MOVE AND PAD SYMBOL
         EJECT
*              HASH SYMBOL, GET ADDRESS OF 1ST POINTER, GET 2ND HASH  *
         LM    RD,RE,SYMTEMP       GET HALVES OF SYMBOL FOR HASHING
         MR    RD,RD               MULT 1ST HALF * 2ND HALF OF SYMBOL
         LM    RX,RB,SYREGS        GET WHOLE BLOCK OF REGS            L
         NR    RD,RZ               COMPUTE PRIMARY HASH CODE
         AR    RA,RD               GET ADDRESS OF  1ST HASHTAB ENTRY
         USING SYMSECT,RA          NOTE USAGE OF DSECT FROM NOW ON
*              FIRST HASH CODE COMPLETE. NOW GET SECONDARY HASH CODE. *
         SR    RD,RD               CLEAR REG OUT BEFORE SHIFTING CODE
         SLDL  RD,8                MOVE  8 BITS FOR SECONDARY CODE
         LTR   RD,RD               IS SECONDARY CODE ZERO
         BNZ   SYKEY2A             IF NOT ZERO,OK
         LA    RD,255              PUT THIS VALUE FOR SECONDARY KEY
SYKEY2A  STC   RD,SYCOMP1+1        PLACE SECONDARY KEY INTO CLI INST
         BAL   RE,SYCOMP1          SKIP L 1ST TIME,SET UP ADDR IN REG
         SPACE 1
*              FOLLOWING THREE INSTRUCTIONS - MAIN SEARCH LOOP        *
*              EACH LOOP CHECKS SECONDARY CODE OF NEXT SYMBOL IN LIST.*
SYLOOP1  L     RA,SYLINK           GET NEXT POINTER
SYCOMP1  CLI   SYHASH2,$CHN        COMPARE SECONDARY CODES
         BCR   H,RE                BH SYLOOP1 - CONTINUE IF HIGH
         BCR   L,RC                BL SYENTER OR SYRETA IF NOT PRESENT
         SPACE 1
*              SEARCH LOOP FOR ACTUAL SYMBOL COMPARISON               *
*              THIS IS ONLY ENTERED FOR SYMBOLS WITH IDENTICAL CODES  *
SYLOOP2  LR    RE,RA               DUPLICATE OLD POINTER VALUE
         L     RA,SYLINK           GET @ NEXT POINTER ON CHAIN
SYCOMP2  CLC   SYMTEMPC($CHN),SYCHARS        COMPARE # OF CHARS,SYMBOLS
         BCR   E,RW                BE->SYRETB(PASS1),SYRET(PASS2)     L
         EX    0,SYCOMP1          MAKE SURE SECONDARY IS SAME
         BCR   E,RX                BE SYLOOP2 - KEEP CHECKING
         LR    RA,RE               RESTORE REG POINTER FOR ENTRY
         BR    RC                  B SYENTER OR SYRETA,DEPENDING
         SPACE 1
         SPACE 1                                                      L
*        ENTERS PASS 2 WHEN SYMBOL IS IN SMBL TABLE (RB=0)            L
SYRET    EQU   *                   ENTER WHEN SYMBOL PRESENT          L
         AIF   (NOT &$XREF).NOXRF17                                   L
         TM    AVXRFLAG,AVXRON     FLAG MAY HAVE BEEN DISARMED(XRCOLL)L
         BZ    SYRETB              RETURN IF NOT ON (=0)              L
         MVC   AVFWORK1(1),AVXRFLAG SET UP FOR REF COLLECT TESTING    L
         NC    AVFWORK1(1),SYFLAGS  AND WITH SD= BITS                 L
*  SEE IF MODIFY OR FETCH                                             L
         TM    AVXRTYPE,AVXRFTCH   FETCH REFERENCE                    L
         BZ    SYCKMOD             NO,MODIFY REF                      L
         TM    AVFWORK1,AVXRSRFT   FETCH REFS?                        L
         BZ    SYRETB              NO, RETURN                         L
         B     SYXRCALL            GO COLLECTBREFS                    L
SYCKMOD  TM    AVFWORK1,AVXRSRMD   COLLECT MOD REFS?                  L
         BZ    SYRETB              NO,RETURN                          L
SYXRCALL EQU   *                   CALLING XRCOLL TO COLLECT REFERENCEL
         $CALL XRCOLL              CALL COLLECTIMG ROUTINE            L
         SR    RB,RB               SET RETURN CODE                    L
.NOXRF17 ANOP                                                         F
         B     SYRETB              GO RETURN                          L
*              ENTER NEW SYMBOL-MUST HAVE BEEN CALLED AT SYENT1       *
SYENTER  CLI   SYMTEMPC,4          CHECK FOR LENGTH
         BL    *+8                 L<=4==> LEAVE 4 IN RW-PREV LOADED
         LA    RY,8                WILL NEED 8 BYTES                  L
         LA    RC,SYMBOL-SYMSECT(RY)  GET LENGTH OF ENTRY             L
         $ALLOCH RE,RC,SYOVER      GET NEEDED SPACE
         L     RC,SYLINK           GET THE OLD SYLINK-SYHASH2 FIELD
         ST    RE,SYLINK           SAVE THE POINTER INTO OLD POINTER
         STC   RD,SYHASH2          SAVE 2ND HASH CODE IN THERE TOO
         LR    RA,RE               MAKE DSECT LOCATED AT NEW AREA
         ST    RC,SYLINK           STORE OLD SYLINK-SYHASH2 INTO NEW
         MVC   SYVALUE(SYCHARS-SYVALUE),AWZEROS        ZERO FLAGS,ETC
         STC   RY,*+5              MOVE LENGTH INTO MVC               L
         MVC   SYCHARS($CHN),SYMTEMPC        MOVE LENGTH&SYMBOL OVER
         SPACE  5                                                     A
         AIF   (NOT &$XREF).NOXRF55  SKIP ID NO CROSS REF             A
*  THE FOLLWING SECTION OF CODE IS USED FOR THE CROSS REFERENCE       A
*   FACILITY.  THE BYTE SYFLAGS IS SET BY THE BITS IN AVXRFLAG, THIS  A
*   ARE LATER TESTED TO SEE WHICH REFERENCES WE ARE COLLOECTING       A
*                                                                     A
         TM    AVXRFLAG,AVXRSDFT+AVXRSDMD   ARE WE COLLECTIOG DEFS    A
         BZ    SYRETA              NO, RETURN                         A
         LH    RB,AVXRCNT          GET # OF REFS COLLECTED            A
         LA    RB,1(RB)            INCREASE BY ONE                    A
         STH   RB,AVXRCNT          RESTORE IT                         A
         IC    RB,AVXRFLAG         GET FLAG IN REG TO SET BITS        A
         N     RB,=A(AVXRSDFT+AVXRSDMD)     FOR SETTING SYFLAGS       L
         SRL   RB,2                MOVE TO RIGHT POSITION             A
         IC    RY,SYFLAGS          PREPARE TO OR FLAGS                L
         OR    RB,RY               SET PROPER BITS IN SYFLAGS         L
         STC   RB,SYFLAGS          STORE IT IN FLAG                   A
.NOXRF55 ANOP                                                         A
         SPACE 1
*              RETURN,SHOWING SYMBOL PRESENT/NOT PRESENT/OVERFLOW     *
SYRETA   LA    RB,4                SHPW THE SYMBOL WAS NEW
SYRETB   EQU   *                                                      A
         AIF (NOT &$XREF).NOXRF18                                     F
         $RETURN RGS=(R14-R6),SA=*     RETURN IF XREF IS ON           F
         AGO   .NOXRF99                                               F
.NOXRF18 ANOP                                                         F
         $RETURN RGS=(R3-R6),SA=NO     RETURN IF XREF IS OFF          F
.NOXRF99 ANOP                                                         F
         EJECT
*              EXIT FOR STORAGE EXCEEDED.  AS 999 MESSAGE.
SYOVER   $GTAD REP,MOSTOP          GET ADDR OF EXIT
         BR    REP                 GO THERE, NVER TO RETURN
         SPACE 2
**--> ENTRY: SYEND2   2   CLEANUP AT END OF PASS 2. . . . . . . . . . .
*.       *** FUTURE USE - WILL COMPUTE SYMBOL TABLE STATISTICS.       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
SYEND2   BR    RET                 RETURN,NOTHING EXISTS RIGHT NOW
         SPACE 2
* * * * * INTERNAL CONSTANTS                                          *
SYREGS   DS    0F                  FOLLOWING IS REGISTER BLOCK FOR LM
SYRX     DC    A(SYLOOP2)          ADCON FOR BRANCHES
SYRY     DC    F'4'                FIRST GUESS FOR ROUNDED SYMBL LEN  L
SYRZ     DC    A(4*(&$SYHASH-1))   SHIFTED MASK FOR 1ST HASH CODE
SYRA     DS    A                   BEGINNING @ HASH INDEX TABLE
SYRB     DC    F'0'               RETURN CODE= SYMBOL ALREADY PRESENT
         SPACE 1
* * * * * INTERNAL VARIABLES                                          *
SYMTEMP  EQU   AVDWORK2            DS D, SPACE FOR SYMBOL
SYMTEMPC EQU   SYMTEMP-1           FOR # CHARACTERS IN SYMBOL
         AIF   (NOT &$XREF).NOXRF50                                   A
         DROP  RAT,R2,RA           CLEAN UP USINGS                    A
         LTORG                                                        A
         AGO   .NOXRF51                                               A
.NOXRF50 ANOP                                                         A
         DROP  RAT,REP,RA          CLEAN UP USING SITUATION
.NOXRF51 ANOP                                                         A
         TITLE '*** UTOPRS - INCORE DISK UTILITY OPERATIONS ***'
**--> CSECT: UTOPRS   1-2 UTILITY DATA SET ROUTINES . . . . . . . . . .
*.             THIS MODULE PERFORMS ALL THE HANDLING WHICH WOULD      .
*.       NORMALLY BE DONE USING SECONDARY STORAGE FOR INTERMEDIATE    .
*.       SOURCE RECORDS AND FOR OBJECT CODE.  IT USES THE LOWER END   .
*.       OF THE DYNAMIC CORE AREA TO STORE THE RECORD BLOCKS (RSBLOCK,.
*.       RSCBLK,REBLK) RESULTING FROM THE SOURCE PROGRAM, AND PLACING .
*.       THEM DURING PASS 1 SO THAT THE OBJECT CODE CAN BE OVERLAID   .
*.       INTO THE SAME AREA.  I.E. IN NO CASE WILL THE RECORDS BLOCKS .
*.       FOR A SOURCE STATEMENT BE PLACED NEARER THE BEGINNING OF THE .
*.       AREA THAN THE OBJECT CODE RESULTING FROM THE STATEMENT.      .
*.                                                                    .
*.       CODE FOR THIS MODULE DEPENDS HEAVILY ON &$DISKU, WHICH       .
*.       CAN ALLOW UTOPRS TO USE DISK FOR INTERMEDIATE STORAGE.       .
*.       &$DISKU = 0 ==> EVERYTHING IN CORE (NORMAL ASSIST).          .
*.       &$DISKU = 1 ==> USER HAS INCROEE/DISK OPTION (DISKU,NODISKU) .
*.       &$DISKU = 2 ==> ALWAYS GO TO DISK, NO INCORE CODE EXISTS.    .
*.                                                                    .
*.       USES MACROS: $DISK,$RETURN,$SAVE                             .
*.       CALLS XXXXDKOP,XXXXDKRD,XXXXDKE1,XXXXDKWT                    .
*.       USES DSECTS: AVWXTABL                                        .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTOPRS   CSECT
         $DBG  C0,*
         ENTRY UTINT1,UTPUT1,UTEND1,UTGET2,UTPUT2,UTEND2
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         SPACE 2
**--> ENTRY: UTINT1   1   INITIALIZE UTILITY ROUTINES . . . . . . . . .
*.       INITIALIZES UT POINTER TO BEGINNING OF RECORD BLOCK AREA.    .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTINT1   $SAVE SA=NO
         AIF   (&$DISKU NE 1).UTINADK  SKIP UNLESS DISKU OPTIONAL
         TM    AVTAGS1,AJODISKU    IS DISK UTILITY ON?
         BNO   UTINODSK            N/--NODISK--CONTINUE NORMALLY
.UTINADK AIF   (&$DISKU LT 1).UTINODK        SKIP IF NO DISK
         $DISK OP                  INITIALIZE DISK UTILITY
         BM    UTINODSK            DISK DCB NOT OPEN-CANCEL DISK OPTION
         LA    RE,AVBUFINC         GET @ OF BUFFE @
         ST    RE,UTCONTRL         SAVE IN UTOPS CONTROL WORD
         AIF   (&$DISKU EQ 2).UTINODK        SKIP UNNEC CODE FOR 2
         MVI   UTBRCHNG+1,X'F0'    SET UTPUT1 TO ALWAYS BRANCH
         B     UTDISKON            DISK IS ON--SKIP NEXT CODE
UTINODSK EQU   *                   ESTABLISH DESTINATION LABEL
         LA    RE,AVADDLOW         INITIALIZE UTCONTROL WORD
         ST    RE,UTCONTRL         WITH @ OF AVADDLOW
         MVI   UTBRCHNG+1,X'00'    SET BRANCH MASK TO 0
.UTINODK AIF   (&$DISKU EQ 2).UTINODL        SKIP UNNNEC CODE FOR 2
         MVI   UTP1RSB1+1,X'00'    MAKE INCORE CODE NOP FIRST TIME
.UTINODL ANOP
*              FOLLOWING CODE MAKES SURE REAL LOWEST @ OF USER PROGRAM
*              IS MULTIPLE OF 32.  XXXXSNAP REQUIRES THIS TO GET
*              REASONABLE COMPLETION DUMPS AND XDUMPS.
*              OTHERWISE, CODE  MVC UTSTART,AVADDLOW WOULD SUFFICE.
UTDISKON L     RE,AVADDLOW         GET LOWEST LIMIT VALUE
         LA    RD,31               SET UPF ALIGNMENT VALUE
         $ALIGR RE,RD              ALIGN TO 32-MULTIPLE
         ST    RE,AVADDLOW         STORE BACK, NOW ALIGNED
         ST    RE,AVRADL           STORE BACK, ALIGNED OK
         AIF   (NOT &$RELOC).UTINREL        SKIP IF NO RELOCATION
         TM    AVTAGS1,AJORELOC    SHOULD CODE BE RELOCATED
         BZ    UTINTRET            NO,DON'T FIXUP ADDRESSES
*              FOLLOWING CODE SIMULATES A USER START CARD WITH VALUE
*        OF ACTUAL LOAD POINT IN MEMORY. RELOCATION IS THUS AUTOMATIC.
         MVC   AVFENTER,AVADDLOW   MOVE IN LOWEST ADDR AS DEFAULT ENTRY
         MVC   AVLOCLOW(20),AVFENTER   FILL IN @'S INSTEAD OF ZEROES
         OI    AVTAGS1,$IBSTAR1    FLAG A START, FINISH FAKERY
.UTINREL ANOP
UTINTRET $RETURN SA=NO
         AIF   (&$DISKU NE 2).UTINODM        SKIP IF NOT DISK ONLY
UTINODSK $GTAD REP,MOSTOP          GET ADDR OF EXIT/OVERFL
         BR    REP                 GO TO FLAG, END PASS 1
.UTINODM ANOP
         EJECT
**--> ENTRY: UTPUT1   1   WRITE TO UTILITY DURING PASS 1. . . . . . . .
*.       UTPUT1 MOVES ALL EXISISTING RECORD BLOCKS FOR A STATEMENT    .
*.       INTO THE LOW END OF THE DYNAMIC CORE AREA, AT THE END OF     .
*.       PROCESSING EACH STATEMENT DURING PASS 1.  THE BLOCKS ARE     .
*.       NEVER PLACED CLOSER TO THE BEGINNING OF THE RECORD BLOCK     .
*.       AREA THAN ANY OBJECT CODE WHICH COULD BE PRODUCED BY THE     .
*.       STATEMENT.  THIS MAKES IT SAFE IN PASS 2 TO JUST MOVE        .
*.       OBJECT CODE INTO THE SAME OVERALL AREA, WITH NO FEAR OF      .
*.       OVERWRITING RECORD BLOCKS STILL NEEDED FOR THE SAME OR       .
*.       LATER STATEMENTS.  THE BLOCKS ARE PLACED IN THIS ORDER:      .
*.       RSBLOCK, (RCODBLK), (REBLK), (RSCBLK)   WITH THE BLOCKS      .
*.       IN ( ) PLACED IF THEY EXIST.  **NOTE** BLOCKS RSBLOCK AND    .
*.       RCODBLK ARE ALWAYS ALIGNED TO FULLWORD BOUNDARY.             .
*.       CALLS MOSTOP                                                 .
*.       USES DSECTS: AVWXTABL,RSBLOCK                                .
*.       USES MACROS: $ALIGR,$CALL,$GLOC,$RETURN,$SAVE                .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR UTPUT1  * * * * * * * * * * * * * * *
*   RX = INTERNAL LINK REGISTER (FOR CALLING UTPMOVE).                *
*   RY = CURRENT FREEAEA POINTER (AVADDLOW)                           *
*   RZ = CURRENT HIGH END POINTER (AVADDHIH)                          *
*   RA = 3     USED TO ALIGN LOCATIONS TO FULLWORD BOUNDARY($ALIGR)   *
*   RB = BYTE REGISTER FOR INSERTS(HI-ORDRR 3 BYTES = 0).             *
*   RC = VRSBPT    (FROM AVWXTABL)                                    *
*   RD = PARAMATER REGISTER FOR UTPMOVE INTERNAL SUBR (@ BLOCK).      *
*   RE = WORK REGISTER                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
UTPUT1   $SAVE RGS=(R3-R6),SA=NO   RW-RZ, USE AS FEW REGS AS CAN
         OI    AVPRINT1,AVPRSAVE   MAKE SURE SAVED FROM NOW ON
         LA    RA,3                SET UP ALIGNMENT VALUE
         SR    RB,RB               CLEAR FOR INSERTIONS
         AIF   (&$DISKU NE 1).UTPT1A   NO USER OPTION ON DISK UTILITY
         L     RW,UTCONTRL         SET UP CONTROL WITH USER OPTION
         LM    RY,RZ,0(RW)         LOAD FROM EITHER AVADDLOW OR
*                                      AVBUFINC
UTBRCHNG BC     $,UTPNOFF           ALWAYS/NEVER BRANCH-DISK/NODISK
*                                      AROUND NORMALL PROCESSING IF DKU
*                                      NO BRANCH IF NOT DISK
.UTPT1A  AIF   (&$DISKU NE 2).UTPT1B   NO DISK AT ALL
         LM    RY,RZ,AVBUFINC      ALWAYS DISK, GET BUFFER PARMS
         AGO   .UTPT1DK            SKIP ALL INCORE ONLY CODE
.UTPT1B  AIF   (&$DISKU NE 0).UTPT1X   SKIP WHEN DISK UTILITY ON
         LM    RY,RZ,AVADDLOW      GET LOW-HIGH CORE POINTERS
.UTPT1X  ANOP
         $GLOC RE                  GET LOCATION COUNTER VALUE
         S     RE,AVLOCLOW         GET OFFSET
UTP1RSB1 BC    $,UTP1RSBX          SKIP IF NOT 1ST INCORE RSBLOCK SAVED
         MVI   UTP1RSB1+1,X'F0'    MAKE NOP A BRANCH AFTER 1ST TIME
         MVC   UTG2PT,AVADDLOW     INIT @ 1ST RSBLOCK, IF  ANY INCORE
UTP1RSBX EQU   *                   BRANCH HERE AFTER 1ST TIME THRU
         A     RE,AVRADL           ADD BASE @ OF UT CORE AREA
         SR    RE,RY               GET OFFSET REQUIRED,IF ANY
         BNP   UTPNOFF             BRANCH IF NO FURTHER OFFSET NEEDED
         TM    AVTAGS1,$IBDSEC1+AJNLOAD     IS EITHER DSECT OR NOLOAD
         BNZ   UTPNOFF             DSECT OR NOLAD, SO NO OFFSET REQUIRD
         SPACE 1
*              IF FALLS THRU-MUST OFFSET NEXT ENTRY BEYOND LOCCNTR    *
         $ALIGR RE,RA              ROUND OFFSET TO FULLWORD MULTIPLE
         AR    RE,RY               GET BACK ACTUAL @ FOR NEXT RSB TO GO
         CR    RE,RZ               MAKE SURE WE HAVE ROOM
         BNL   UTPOVER             DISASTER EXIT-OVERFLOW
         ST    RE,0(RY)            SAVE ADDRESS OF NEXT BLOCK
         LR    RY,RE               MOVE NEW POINTER OVER
.UTPT1DK ANOP
         SPACE 1
*              GET ALL THE RECORD POINTERS AND MOVE EXISTING ONES.    *
UTPNOFF  L     RC,AVRSBPT          GET ONLY DEFINITE EXISTING BLOCK
         USING RSBLOCK,RC          NOTE RECORD SOURCE BLOCK USING
         AIF   (NOT &$XREF).NOXRF11  SKII IF NO XREF                  A
         TM    RSBFLAG,$RSBNPNN    IS STMT TO BE NUMBERED             A
         BZ    UTPTNPRC            NO, DON'T INCREMENT                A
         AP    AVXRLNCN,AWP1       APP 1 TO LINE COUNTER(CROSS REF)   A
UTPTNPRC EQU   *                                                      A
.NOXRF11 ANOP                                                         A
         LR    RD,RC               MOVE PTR OVER FOR UTPMOVE
         BAL   RX,UTPMOVE          CALL MOVER SUBROUTINE
         SPACE 1
         $ALIGR RY,RA              GET FULLWORD ALIGNMENT
         TM    RSBFLAG,$RCBX       DO WE HAVE A RCB WITH THIS
         BZ    UTPREB              NO RCB-TRY FOR REB
         L     RD,AVRCBPT          GET @ RCODBLK
         BAL   RX,UTPMOVE          CALL MOVER ROUTINE
         SPACE 1
UTPREB   TM    RSBFLAG,$REBX       DO WE HAVE A REB
         BZ    UTPRSC              NO REB,LOOK FOR  RSCB
         L     RD,AVREBPT          GET @ REBLK (AVREBLK)
         BAL   RX,UTPMOVE          CALL MOVER ROUTINE
         SPACE 1
UTPRSC   TM    RSBFLAG,$RSCX       TEST FOR RSC
         BZ    UTPEND1             NO RSC-SKIP TO END
         L     RD,AVRSCPT          GET @ RSCBLK
         BAL   RX,UTPMOVE          CALL MOVER ROUTINE
         DROP  RC                  NO LONGER NEEDED FOR RSB
         SPACE 1
UTPEND1  $ALIGR RY,RA              ALIGN POINTER TO FULLWORD
         AIF   (&$DISKU NE 0).UTPT1D
         ST    RY,AVADDLOW         STORE POINTER BACK
         AGO   .UTPT1F
.UTPT1D  AIF   (&$DISKU NE 1).UTPT1E   GO TO ALWAYS DISK CODE
         ST    RY,0(RW)            STORE POINTER BACK
         AGO   .UTPT1F
.UTPT1E  ST    RY,AVBUFINC         STORE POINTER BACK
.UTPT1F  ANOP
UTPRET   $RETURN RGS=(R3-R6),SA=NO       RETURN
         SPACE 2
**--> INSUB: UTPMOVE    MOVE 1 RECORD BLOCK INTO DYNAMIC AREA + + + + +
*+       ENTRY CONDITIONS                                             +
*+  RD = ADDRESS OF THE BLOCK TO BE MOVED. ITS FIRST BYTE GIVES LEN-1 +
*+  RY = ADDRESS WHERE BLOCK SHOULD BE PLACED                         +
*+       EXIT CONDITIONS                                              +
*+  RY = ADDRESS OF NEXT FREE SPACE FOR BLOCKS.                       +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
UTPMOVE  IC    RB,0(,RD)           GET LENGTH-1 OF BLOCK
         LA    RE,1(RB,RY)         INCREMENT @ PTR BY WHOLE LENGTH
         CR    RE,RZ               MAKE SURE WE HAVE ROOM
         BNL   UTPOVER             NO MORE ROOM-DISASTER
         STC   RB,*+5              STORE LENGTH-1 INTO MVC INSTUCTION
         MVC   0($,RY),0(RD)       MOVE BLOCK INTO DYNAMIC AREA
         LR    RY,RE               MOVE UPDATED LOW END POINTER BACK
         BR    RX                  RETURN TO CALLING SECTION OF UTPUT1
         SPACE 1
         AIF   (&$DISKU NE 0).UTPOVRA
UTPOVER  $GTAD REP,MOSTOP          GET ADDR OF EXIT - AS999 MESSAGE
         BR    REP                 GO THERE, ENDING PASS 1
         AGO   .UTPOVRB
.UTPOVRA AIF   (&$DISKU EQ 1).UTPOVRC  SKIP IF DISK UTILITY OPTIONAL
UTPOVER  $DISK WT                  CALL DISK UTILITY TO WRITE A BLOCK
         LM    RY,RZ,AVBUFINC      GET PARMS FROM CONTROL BLOCK
         B     UTPNOFF             PROCESS AT UTPNOFF
         AGO   .UTPOVRB
.UTPOVRC ANOP
UTPOVER  TM    AVTAGS1,AJODISKU    IS DISK ENABLED?
         BNO   UTPEXIT             NOT ENABLED  TAKE EXIT
         $DISK WT                  DISK ENABLED  WRITE A BLOCK TO DISK
         LM    RY,RZ,AVBUFINC      GRAB SOME CONTROL INFORMATION
*                                  ADDRESS OF NEXT BUFFER TO BE FILLED
         B     UTPNOFF             PROCEES AT UTPNOFF
UTPEXIT  $GTAD REP,MOSTOP          GET ADDRESS OF EXIT--AS999 MESSAGE
         BR    REP                 TAKE EXIT NOW
.UTPOVRB ANOP
         EJECT
**--> ENTRY: UTEND1   1   END PASS 1, PREPARE FOR PASS 2 OF ASSEMBLER .
*.       UTEND1 RESETS CORE POINTERS AND CALCULATES RELOCATION FACTOR..
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTEND1   $SAVE SA=NO
         L     RD,AVRADL           GET @ 1ST BYTE WHERE OBJ CODE GOES
         AIF   (&$DISKU EQ 2).UTE1A1  SKIP IF NO INCORE CODE AT ALL
         L     RE,AVADDLOW         CURRENT ENDING POINTER
         ST    RE,UTG2END          PTR TO END OF CORE USED (IF INCORE)
*              FOLLOWING STMT ONLY NEEDED IF UNUSED CORE FILL DONE.
         ST    RD,UTP2LAST         SAVE AVRADL AS INIT @ LAST CODE LOAD
         S     RD,AVLOCLOW         GET RELOCATION FACTOR
         ST    RD,AVRELOC          SAVE THE RELOCATION FACTOR
         AIF   (&$DISKU EQ 0).UTRET    SKIP WHEN NO DISK AT ALL
         AIF   (&$DISKU EQ 2).UTALW    SKIP WHEN ALWAYS DISK
         TM    AVTAGS1,AJODISKU    IS DISK UTILITY ON?
         BNO   UTRETE1             NO  RETURN AFTER THIS CODE
         SPACE 1
*        IF DISKU OPTION ON, MAKE SURE OBJECT CODE FITS INTO THE      *
*        ALLOWED AREA.  (THIS CHECK IS MADE CONSTANTLY DURING UTPUT1  *
*        FOR THE INCORE VERSION).  THIS ASSUMES AVADDHIH WILL REMAIN  *
*        CONSTANT FROM THIS POINT ON.  IF AVADDHIH MAY BE CHANGED,    *
*        IT WILL BE NECESSARY TO CHECK DURING UTPUT2 .                *
         SPACE 1
         A     RD,AVLOCHIH         RD = REAL @ OF END OF OBJ CODE
         C     RD,AVADDHIH         CHECK AGAINST LOWER LIMIT OF UPPER
         BNH   *+12                IF NEEDED <= AVAIL, SKIP, OK
         OI    AVTAGS3,AVOVERFL    SHOW STORAGE EXCEEDED
         OI    AVTAGS1,AJNLOAD     KILL OBJECT CODE GENERATION
         SPACE 1
.UTALW   $DISK E1                  CALL END-PASS-1 FIX ROUTINE
         LR    RD,RE               DUPLICATE RE
         STM   RD,RE,UTG2PT        SET POINTERS TO FORCE CALL TO DISKU
.UTRET   ANOP
UTRETE1  $RETURN SA=NO             RETURN TO MASTER CONTROL
         EJECT
**--> ENTRY: UTGET2   2   GET FROM UTILITY DUIRNG PASS 2. . . . . . . .
*.       UTGET2 IS CALLED DURING PASS 2 TO RETRIEVE THE ADDRESSES OF  .
*.       THE SET OF RECORD BLOCKS BELONGING TO THE NEXT STATEMENT. A  .
*.       CHECK IS REQUIRED FOR ANY OFFSET ADJUSTMENT MADE BY UTPUT1,  .
*.       WHICH MADE SURE THAT NO RECORD BLOCK COULD BE OVERLAID BY    .
*.       ITS OWN CODE.
*.       EXIT CONDITIONS                                              .
*.  RC = @ RSBLOCK (THE ONLY BLOCK DEFINITELY PRESENT).               .
*.  RE = 0    NORMAL RETURN.      RE = 4 ==> END-FO-FILE-QUIT         .
*.  AVRSBPT,AVRCBPT,AVRSCPT NOW POINT TO THEIR BLOCKS, IF THEY EXIST. .
*.  AVREBLK HAS HAD THE REBLK MOVED INTO IT, IF THERE WAS ONE.        .
*.  AVREBPT IS NOT CHANGED, STILL POINTS AT AVREBLK, AS ALWAYS.       .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REGISTER ALLOCATION FOR UTGET2  * * * * * * * * * * * * * * *
*   RA = 3     MASK FOR DOING FULLWORD ALIGNMENT.                     *
*   RB = BYTE REGISTER FOR INSERTIONS (HI-ORDER 3 BYTES = 0).         *
*   RC = @ RSBLOCK, USED TO TEST FOR EXISTENCE OF OTHERS.             *
*   RD = CURRENT @ NEXT BLOCK, INITIALIZED = UTG2PT                   *
*   RE = UTG2END-LIMIT @, USED TO DETERMINE END OF RECORDS.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         AIF   (&$ASMLVL).UTOS     SKIP FOR OS GENERATION
UTDKDISP EQU   8                   GEN DOS BUFFER DISP
         AGO   .UTGLVL
.UTOS    ANOP
UTDKDISP EQU   0                   GEN OS BUFFER DISP
.UTGLVL  SPACE 1
UTGET2   $SAVE RGS=NO,SA=NO        USE ONLY TEMP REGS
         LA    RA,3                SET UP FOR FULLWORD ALIGNMENT
         SR    RB,RB               CLEAR FOR INSERTIONS
         LM    RC,RD,UTG2PT        UTG2PT-UTG2END VALUES FOR COMPARE
         CR    RC,RD               COMPARE CURRENT POINTER TO END @
         BNL   UTG2DONE            NO MORE RECORDS-BRANCH-DONE
         SPACE 1
*        THE FOLLOWING CHECKS FOR AN OFFSET ADJUSTMENT @ FOLLWING THE *
*        LAST RSB, INSTEAD OF ANOTHER RSB.  THE 1ST BYTE FOR AN OFFSET*
*        WILL =0, BUT AN RSBLENG NEVER = 0.
         CLI   0(RC),0             IS NEXT BYTE 0, IF SO RC==> OFFSET@
         BNE   *+8                 BRANCH IF NORMAL RSB FOLLOWS
         L     RC,0(RC)            OFFSET @ ==> NEXT RSBLOCK, LOAD IT
UTG2DKCT ST    RC,AVRSBPT          STORE THE @ OF THE RSBLOCK
         USING RSBLOCK,RC          NOTE ADDRESS
         SPACE 1
         IC    RB,RSBLENG          GET THELENGTH-1 OF BLOCK
         LA    RD,4(RB,RC)         MOVE @ OVER, ADD LENGTH+ALIGN
         OR    RD,RA               MAKE LAST 2 BITS 1'S
         SR    RD,RA               HAVE ROUNDED UP TO NEXT FULLWORD B
         SPACE 1
         TM    RSBFLAG,$RCBX       DO WE HAVE RCB
         BZ    UTG2REB             NO RCB-SKIP
         ST    RD,AVRCBPT          STORE @ RCODBLK
         USING RCODBLK,RD          NOTE POINTER
         IC    RB,RCLENG           GET LENGTH-1 OF RCODBLK
         LA    RD,1(RB,RD)         INCREMENT POINTER BY FULL LENGTH
         SPACE 1
UTG2REB  TM    RSBFLAG,$REBX       DOES REB EXIST
         BZ    UTG2RSC             NO IT DOESN'T - SKIP
         USING REBLK,RD            NOTE PTR TO ERROR BLOCK
         IC    RB,REBLN            GET LENGTH-1 OF THE BLOCK
         STC   RB,*+5              STORE LENGTH-1 INTO NEXT INSTR
         MVC   AVREBLK($),REBLK    MOVE THE ERROR BLOCK OVER
         LA    RD,1(RB,RD)         INCREMENT POINTER TO NEXT POSITION
         SPACE 1
UTG2RSC  TM    RSBFLAG,$RSCX       DOES RECORD SOURCE CODE BLOCK EXIST
         BZ    UTG2EXIT            NO,SKIP OVER
         ST    RD,AVRSCPT          STORE @ RSCBLK WHERE NEEDED
         USING RSCBLK,RD           NOTE POINTER
         IC    RB,RSCLENG          GET LENGTH-1 OF RSCBLK
         LA    RD,1(RB,RD)         INCREMENT BY LENGTH TO NEXT POSITION
         SPACE 1
UTG2EXIT $ALIGR RD,RA              ALIGN TO FULLWORD FOR NEXT RSBLOCK
         ST    RD,UTG2PT           STORE THE POINTER BACK, NEXT RSBLOCK
         SR    RE,RE               CLEAR TO SHOW NORMAL
         $DBG  C0,SNAP
UTG2RET  $RETURN RGS=NO,SA=NO      RETURN
UTG2DONE EQU   *                   ESTABLISH LABEL
         AIF   (&$DISKU GT 1).UTG2DA   DISK ONLY
         AIF   (&$DISKU LT 1).UTG2DB   USER OPTION--DISK OR NO DISK
         TM    AVTAGS1,AJODISKU    IS DISK ON?
         BNO   UTG2EOF             NO--SET E-O-F FLAG
.UTG2DA  ANOP
         $DISK RD                  GET NEXT BUFFER OF INFO
         BM    UTG2EOF             ON REAL EOF--SET FLAG AND RTURN
         L     RC,AVBUFF@          GET BUFFER ADDRESS
         LR    RD,RC               DUPLICATE FOR BUFFER LENGTH
         A     RD,0+UTDKDISP(RC)   ADD IN BUFFER USED LENGTH
         LA    RC,4+UTDKDISP(RC)   BUMP PAST LENGTH USED WORD
         ST    RD,UTG2END          STORE ENDING ADDRESS
         B     UTG2DKCT            GO BACK AND PROCESS
.UTG2DB  ANOP
UTG2EOF  LA    RE,4                SHOW E-O-F  NO MORE SOURCE
         B     UTG2RET
         DROP  RC,RD               KILL THESE USINGS
         EJECT
**--> ENTRY: UTPUT2       PRODUCES AND RELOCATES OBJECT CODE. . . . . .
*.       UTPUT2 MOVES OBJECT CODE PRODUCED BY THE ASSEMBLER INTO IT   .
*.       PROPER LOCATION IN THE OBJECT PROGRAM, APPLYING DUPLICATION  .
*.       FACTOR AT THIS TIME, IF NECESSARY.  BECAUSE OF THE WAY THE   .
*.       ASSIST INTERPRETER EXECUT WORKS, AND BECAUSE OF THE PSEUDO   .
*.       START CARD USED BY THE REPLACE MONITOR, NO RELOCATION NEED   .
*.       EVER BE DONE BY THIS PROGRAM, MAKING IT FAST AND SMALL.  THE .
*.       MODULE ALSO FILLS IN  AREAS OF THE OBJECT PROGRAM HAVING NO  .
*.       CODE WITH CHARACTER 5'S, WHICH HELP REDUCE THE SIZE OF ANY   .
*.       COMPLETION DUMPS, AND AID DEBUGGING  (X'F5F5F5' SHOWS UP     .
*        DISTINCTIVELY IN A DUMP, AND IS NOT A LEGAL INSTRUCTION).    .
*.       ENTRY CONDITIONS                                             .
*.  RA = PROGRAM LOCATION COUNTER OF THE OBJECT CODE                  .
*.  RC = @ ASSEMBLED CODE IN MEMORY                                   .
*.  RD = LENGTH-1 OF OBJECT CODE                                      .
*.  RE = DUPLICATION FACTOR FOR THE CODE - 1 OR GREATER               .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $RETURN,$SAVE                                   .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
UTPUT2   $SAVE RGS=NO,SA=NO        NO REGS NEEDED
         SPACE 1
         TM    AVTAGS1,$IBDSEC1+AJNLOAD     DSECT OR NOLOAD
         BNZ   UTP2RET             RETURN IF SO, DON'T LOAD ANY CODE
         A     RA,AVRELOC          ADD RELOCATION FACTOR TO ADDRESS
         STC   RD,UTP2MOVE+1       STORE LENGTH-1 INTO MVC IMMEDIATLY
         SPACE 1
*              FOLLOWING SECTION PLACES CHARACTER 5'S IN ANY UNUSED   *
*        LOCATIONS OF MEMORY, EXCEPT POSSIBLY A BLOCK OF DS AREAS     *
*        ENDING PROGRAM, WITH NO FOLLOWING LITERALS, DC'S.            *
*        SECTION NOT REALLY NECESSARY, COULD BE REMOVED WITH NO HARM. *
         LR    RB,RA               DUPLICATE VALUE OF CODE @
         S     RB,UTP2LAST         SUB @ LAST CODE, GET # FILLED
         BNP   UTP2MOVE            SKIP, NO PADDING NEED BE DONE
         SPACE 1
         STM   R1,R2,24(R13)       SAVE WORK REGISTERS
         L     R2,UTP2LAST         GET STARTING @ AREA TO BE TWOED
         MVI   0(R2),$PRGFILC      PUT IN CORE FILL CHARACTER
         LA    R1,256              SET UP FOR LENG FILL IF NEEDED
         BCT   RB,UTP2ZB           DECREMENT COUNT 1, BRANCH >1 ORIG
         B     UTP2NT              1 BYTE ONLY, ALREADY DONE,QUIT
         SPACE 1
UTP2ZA   MVC   1(256,R2),0(R2)     PROPAGATE 5'S FOR 256 BYTES
         AR    R2,R1               ADD 256 TO BEGINNING @ OF CODE
         SR    RB,R1               DECREMENT COUNT REMAINING BY 256
         BZ    UTP2NT              BRANCH IF NOTHING LEFT TO DO
         SPACE 1
UTP2ZB   CR    RB,R1               COMPARE COUNT REMAINING TO 256
         BH    UTP2ZA              IF STILL HIGH, FILL ANOTHER 256
         BCTR  RB,0                DECREMENT COUNT TO LENGTH-1 FOR MVC
         STC   RB,*+5              STORE LENGTH-1 INTO MVC
         MVC   1($,R2),0(R2)       PROPAGATE 5'S FOR LAST TIME
UTP2NT   LM    R1,R2,24(R13)       RELOAD DESTOYED WORK REGS
*              END OF CORE-FILLING SEGMENT.                           *
         EJECT
*              FOLLOWING 3 STMTS DO ACTUAL CODE LOAD/DUPLICATION.
UTP2MOVE MVC   0($CHN,RA),0(RC)    MOVE OBJECT CODE OVER
         LA    RA,1(RD,RA)         BUMP ADDRESS TO NEXT LOCATION
         BCT   RE,UTP2MOVE         DUPLICATE AS MANY TIMES AS NEEDED
         SPACE 1
*              FOLLOWING 3 STMTS USED ONLY FOR CORE-FILL ACTIONS.     *
         C     RA,UTP2LAST         WAS END @ OF CODE HIGHEST SO FAR
         BNH   *+8                 SKIP  IF NOT SO
         ST    RA,UTP2LAST         STORE NEW HIGHEST CODE @
         SPACE 1
         $DBG  C0,*
UTP2RET  $RETURN SA=NO
         SPACE 2
**--> ENTRY: UTEND2   2   CLEANUP AFTER PHASE 2 DONE. . . . . . . . . .
*.       UTEND2 IS CALLED AT THE END OF ASSEMBLY PASS 2.  IT ASSURES  .
*.       THAT ANY DS STATEMENTS ENDING THE PROGRAM WILL BE FILLED IN  .
*.       WITH 5'S, LIKE ANY OTHER DS'S FOLLOWED BY CODE (THE VERY LAST.
*.       STRING OF DS'S MAY NOT BE CAUGHT BY UTPUT2).  IT DOES THIS BY.
*.       CALLING UTPUT2 WITH SOME NONEXISTENT OBJECT CODE.            .
*.       CALLS UTPUT2                                                 .
*.       USES DSECTS: AVWXTABL                                        .
*.       USES MACROS: $SAVE                                           .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
UTEND2   $SAVE RGS=NO,SA=NO        NO REGS NEED BE SAVED
         NI    AVTAGS1,255-$IBDSEC1         MAKE SURE DSECT FLAG OFF
         L     RA,AVLOCHIH         GET @ 1 BYTE BEYOND HIGHEST LOCNTR
         LA    RC,=AL1($PRGFILC)   SET @ 1 BYTE CORE FILL CHARACTER
         SR    RD,RD               SHOW LENGTH-1 OF 0 FOR FAKE CODE
         LA    RE,1                SHOW DUPLICATION FACTOR OF 1
         $GTAD REP,UTPUT2          GET ADCON FOR OTHER SECTION
         BR    REP                 GO TO UTPUT2, IT WILL FILL IF NEEDED
         LTORG
         SPACE 2
* * * * * INTERNAL VARIABLES                                          *
*              USED BY PASS 1                                         *
         AIF   (&$DISKU NE 1).UTCNTRL  SKIP UNLESS DISK IS OPTION
UTCONTRL DS    F                   @ AVBUFINC/AVADDLOW-DEPENDS ON DISKU
.UTCNTRL ANOP
*              USED BY PASS 2                                         *
UTG2PT   DS    A                   POINTER TO NEXT RSBLOCK TO BE GOTTEN
UTG2END  DS    A                   POINTER TO END OF CORE AREA USED
UTP2LAST DS    A                   @ HIGHEST CODE LOADED,**FILL USE****
         DROP  RAT,REP
         TITLE '*** VWXTABL - MAIN ASSEMBLER CONTROL TABLE ***'
**--> CSECT: VWXTABL    MAIN ASSEMBLER COMMUNICATION TABLE. . . . . . .
*.       THIS IS ACTUAL TABLE THAT AVWXTABL DSECT CORREPSONDS TO.     .
*.       SEE AVWXTABL COMMENTS FOR DESCRIPTION.                       .
*.       USES MACROS: WCONG                                           .
*.       NAMES: X------, W------, V------                             .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
VWXTABL  CSECT
         SPACE 1
* * * * * NAMES IN AVWXTABL DSECT ARE SAME, EXCEPT WITH A'S PREFIXED  *
* * * * * AVWXTABL SECTION X - ADDRESS CONSTANTS  * * * * * * * * * * *
X$BASE   DS    0A                  BASE ADDRESS FOR OFFSETS TO ROUTINES
*              *** BROPS2 ENTRY POINTS ***                            *
XBRINIT  DC    V(BRINIT)           BASE-REG INITIALIZATION
XBRUSIN  DC    V(BRUSIN)           BASE-REG SET UP USING VALUE
XBRDROP  DC    V(BRDROP)           BASE REG DROP A REGISTER
XBRDISP  DC    V(BRDISP)           BASE REG GET BASE-DISPLACEMENT
XC$BASE  DS    0F                  BASE ADDRESS FOR CONSTANT ADDR OFFSE
*              *** CACONS ENTRY POINTS ***                            *
XCACON1  DC    V(CACON1)           SCAN A-TYPE CONST
XCACON2  DC    V(CACON2)           ASSEMBLE A-TYPE CONSTANT
*              *** CBCONS ENTRY POINTS ***                            *
XCBCON1  DC    V(CBCON1)           SCAN BINARY CONSTANT
XCBCON2  DC    V(CBCON2)           ASSEMBLE BINARY CONSTANT
*              *** CCCONS ENTRY POINTS ***                            *
XCCCON1  DC    V(CCCON1)           SCAN CHARACTER CONSTANT
XCCCON2  DC    V(CCCON2)           ASSEMBLE CHARACTER CONSTANT
*              *** CDECNS ENTRY POINTS ***                            *
XCDECN1  DC    V(CDECN1)           SCAN FLOATING PT CONST
XCDECN2  DC    V(CDECN2)           ASSEMBLE FLOATING PT CONSTANT
XCDCON1  EQU   XCDECN1             MAKE EQUATE FOR STANDARD NAMES
XCECON1  EQU   XCDECN1             MAKE EQUATE FOR STANDARD NAMES
*              *** CFHCNS ENTRY POINTS ***                            *
XCFHCN1  DC    V(CFHCN1)           SCAN FIXED POINT CONSTANT
XCFHCN2  DC    V(CFHCN2)           ASSEMBLE FIXED POINT CONSTANT
XCFCON1  EQU   XCFHCN1             MAKE EQUATE FOR STANDARD NAMES
XCHCON1  EQU   XCFHCN1             MAKE EQUATE FOR STANDARD NAMES
*              *** CONSTANT PROCESSOR CONTROL ROUTINES ***            *
XCNDTL2  DC    V(CNDTL2)           PASS 2 CONSTANT PROCESSING
XCODTL1  DC    V(CODTL1)           DUPLICATION FACTOR-TYPE-LENGTH PROC
*              *** CPCONS ENTRY POINTS ***                            *
XCPCON1  DC    V(CPCON1)           SCAN PACKED CONSTANT
XCPCON2  DC    V(CPCON2)           ASSEMBLE PACKED CONSTANT
*              *** CVCONS ENTRY POINTS ***                            *
XCVCON1  DC    V(CVCON1)           SCAN V-TYPE CONSTANTS
XCVCON2  DC    V(CVCON2)           ASSEMBLE V-TYPE ADDRESS CONSTANTS
*              *** CXCONS ENTRY POINTS ***                            *
XCXCON1  DC    V(CXCON1)           SCAN HEXADECIMAL CONSTANTS
XCXCON2  DC    V(CXCON2)           ASSEMBLE HEXADECIMAL CONSTANTS
*              *** CZCONS ENTRY POINTS ***                            *
XCZCON1  DC    V(CZCON1)           SCAN ZONED CONSTANTS
XCZCON2  DC    V(CZCON2)           ASSEMBLE ZONED CONSTANTS
*              *** ERRORS ENTRY POINTS ***                            *
XERRTAG  DC    V(ERRTAG)           FLAG ERROR
XERRLAB  DC    V(ERRLAB)           ERROR FLAG FOR A LABEL
*              *** ESDOPRS ENTRY POINTS ***                           *
XESINT1  DC    V(ESINT1)           ESD ROUTINE INITIALIZATION
XESCSEC  DC    V(ESCSEC)           CSECT,START, OR DSECT
XESENX1  DC    V(ESENX1)           ENTRY OR EXTRN - PASS 1
XESENX2  DC    V(ESENX2)           PASS 2 ENTRY AND EXTRN
*              *** EVALUT - EXPRESSION EVALUATOR ***                  *
XEVALUT  DC    V(EVALUT)           GENERAL EXPRESSION EVALUATION ROUT
*              *** 2ND LEVEL PROCESSOR CSECTS ***                     *
XIAMOP1  DC    V(IAMOP1)           MACHINE OPCODES-PASS 1
XIBASM1  DC    V(IBASM1)           ASSEMBLER OPCODES - PASS 1
XICMOP2  DC    V(ICMOP2)           MACHINE OPCODES - PASS 2
XIDASM2  DC    V(IDASM2)           ASSEMBLER OPCODES - PASS 2
*              *** INPUT1 ENTRY POINTS ***                            *
XINCARD  DC    V(INCARD)           INPUT CARD PROCESSOR
*              *** LTOPRS ENTRY POINTS ***                            *
XLTINT1  DC    V(LTINT1)           LITERAL TABLE INITIALIZATION
XLTENT1  DC    V(LTENT1)           ENTER A LITERAL INTO POOL
XLTDMP1  DC    V(LTDMP1)           RETURN LITERAL LENGTH-PASS 1
XLTEND1  DC    V(LTEND1)           END PASS 1 FOR LITERAL TABLE
XLTGET2  DC    V(LTGET2)           GET ADDRESS OF LITERAL
XLTDMP2  DC    V(LTDMP2)           PRODUCE LITERAL RECORDS-PASS 2
         AIF   (NOT &$MACROS).XNOMAC        SKIP IF NO MACROS
*              ** MACROS ENTRY POINTS **                              *
XMACINT  DC    V(MACINT)           MACRO INITIALIZATION ENTRY
XMACRO1  DC    V(MACRO1)           BUILD MACRO DEFINITION TABLES
XMEXPND  DC    V(MEXPND)           MACRO EXPANSION ENTRY
XMCBODY  DC    V(MCBODY)           PROCESS MACRO DEFINITION BODY
XMACSCN  DC    V(MACSCN)           SCAN MACRO STATEMENT
XMACFND  DC    V(MACFND)           SEARCH MACRO LIBRARY
XMCVSCN  DC    V(MCVSCN)           SCAN VARIABLE SYMBOL
XMCSCOP  DC    V(MCSCOP)           SCAN STANDARD OPERAND
XMCGTST  DC    V(MCGTST)           MOVE STRING TO LOW CORE
XMCSYSR  DC    V(MCSYSR)           SEARCH MACRO LIBRARIES FOR VAR SYMB
XMACLEX  DC    V(MACLEX)           MACRO STMT LEX ANALYSIS
XMCGNCD  DC    V(MCGNCD)           MACRO DEFINITION CODE GENERATION
XMXMVSR  DC    V(MXMVSR)           MOVE GENERATED STMT TO HIGH CORE
XMXERRM  DC    V(MXERRM)           GENERATE ERROR MESSAGE
XMCDTRM  DC    V(MCDTRM)           CHAR TO BINARY CONVERSION
XMCATRM  DC    V(MCATRM)           TEST FOR ATTRIBUTE
         DS    2V                  SPACE FOR MACRO ENTRY POINTS
.XNOMAC  ANOP
*              ***  MAIN PROGRAMS - PASS 1&2 ***                      *
XMOCON1  DC    V(MOCON1)           MAIN CONTROL - PASS 1
XMOSTOP  DC    V(MOSTOP)           DISASTER EXIT-PASS 1
XMTCON2  DC    V(MTCON2)           MAIN CONTROL - PASS 2
*              *** OPCOD1 ENTRY POINTS ***                            *
XOPINIT  DC    V(OPINIT)           INITIALIZATION,IF ANY
XOPFIND  DC    V(OPFIND)           LOOKUP OPCODE
*              *** OUTPUT ENTRY POINTS ***                            *
XOUINT1  DC    V(OUINT1)           INITIALIZATION ENTRY FOR OUTPUT
XOUTPT2  DC    V(OUTPT2)           OUTPUT LINE PRINTER
XOUEND2  DC    V(OUEND2)           FINISH UP LAST PRINTING
*              *** SCANRS ENTRY POINTS ***                            *
XSCANBL  DC    V(SCANBL)           SCAN TO FIRST BLANK OUTSIDE OF C'
XSCANCO  DC    V(SCANCO)           SCAN TO COMMA OR BLANK
XSCANEQ  DC    V(SCANEQ)           SCAN TO = OR BLANK
*              *** SDTERM ENTRY POINTS ***                            *
XSDBCDX  DC    V(SDBCDX)           SLEF DEFINING TERM-ALL 4 KINDS     *
XSDBTRM  DC    V(SDBTRM)           BINARY SELF-DEFINING TERM
XSDCTRM  DC    V(SDCTRM)           CHARACTER SELF-DEFINING TERM
XSDDTRM  DC    V(SDDTRM)           DECIMAL SELF-DEFINING TERM
XSDXTRM  DC    V(SDXTRM)           HEXADECIMAL SLEF-DEFINING TERM
*              *** SYMOPS ENTRY POINTS ***                            *
XSYINT1  DC    V(SYINT1)           SYMBOL TABLE INITIALIZATION
XSYENT1  DC    V(SYENT1)           ENTER A SYMBOL INTO SYMBOL TABLE
XSYFIND  DC    V(SYFIND)           LOOK UP A SYMBOL IN SYMBOL TABLE
XSYEND2  DC    V(SYEND2)           CLEANUP/STATISTICS AT END OF SYM TAB
*              *** UTOPRS ENTRY POINTS ***                            *
XUTINT1  DC    V(UTINT1)           UTILITIES INITIALIZATION
XUTPUT1  DC    V(UTPUT1)           PASS 1 OUTPUT OF EXPANDED RECORDS
XUTEND1  DC    V(UTEND1)           END PASS 1-INIT FOR PASS 2
XUTGET2  DC    V(UTGET2)           GET ADDR'S OF EXPANDED RECRDS-PASS 2
XUTPUT2  DC    V(UTPUT2)           OBJECT CODE CREATION-PASS 2
XUTEND2  DC    V(UTEND2)           FINISH UP PASS 2
         AIF   (NOT &$XREF).NOXREF7  SKIP ID NO XREF                  A
*              ***  CROSS REFERENCE ENTRY POINTES ***                 A
XXRINT1  DC    V(XRINT1)           1ST PASS INIT ROUTINE              A
XXRINT2  DC    V(XRINT2)           2ND PASS INIT ROUTINE              A
XXRCOLL  DC    V(XRCOLL)           COLLECTION ROUTINE                 A
XXRPRNT  DC    V(XRPRNT)           PRINT ROUTINE                      A
XXRSCAN  DC    V(XRSCAN)           SCANNING ROUTINE                   A
.NOXREF7 ANOP                                                         A
XSPECAD  DS    A                   BASE ADDRESS FOR SPECIAL ROUTINES
XSPECA2  DS    A                   BASE @ LEV2-PASS 2 - 'SPECIALS'
         EJECT
* * * * * AVWXTABL SECTION W - CONSTANTS  * * * * * * * * * * * * * * *
WD0      DS    0D                  FLOATING POINT 0 FOR CDE
WZEROS   DC    32D'0'              256 BYTES OF BINARY ZEROS
WD10     DC    D'10'               DOUBLEWORD FLOATING CONSTANT 10
WF1      DC    F'1'                FULLWORD 1 CONSTANT
WH1      EQU   WF1+2               HALFWORD 1 CONSTANT
WB1      EQU   WF1+3               BYTE 1 CONSTANT
WF3      DC    F'3'                FULLWORD 3 CONSTANT
WH3      EQU   WF3+2               HALFWORD 3 CONSTANT
WB3      EQU   WF3+3               BYTE 3 CONSTANT
WF4      DC    F'4'                FULLWORD CONSTANT 4
WF7      DC    F'7'                FULLWORD 1
WH7      EQU   WF7+2               HALFWORD 7 CONSTANT
WB7      EQU   WF7+3               BYTE 7 CONSTANT
WF10     DC    F'10'               FULLWORD CONSTANT 10
WH10     EQU   WF10+2              HALFWORD CONSTANT 10
WF12     DC    F'12'               FULLWORD CONSTANT 12
WF15     DC    F'15'               FULLWORD CONSTANT 15 (4 1 BITS)
WFXF     EQU   WF15                FULLWORD CONSTANT,4 1-BITS
WFXFF    DC    F'255'              FULLWORD CONSATNT 255
WF4095   DC    F'4095'             FULLWORD 4095 CONSTANT
WFXFFF   EQU   WF4095              XL4'FFF'      ON F BOUNDARY
WHXFFF   EQU   WFXFFF+2            XL2'0FFF'  ON H BOUNDARY
WFX7FFFF DC    X'00007FFF'         MAXIMUM SIZE, MASK VALUE
WFXFFFF  DC    X'0000FFFF'         65K DECIMAL NUMBER
WFX6F    DC    XL4'FFFFFF'         FULLWORD 24-BIT MASK
WFM4     DC    F'-4'               FULLWORD -4 CONSTANT
WFM1     DC    F'-1'               FULLWORD -1 CONSTANT
WHM1     EQU   WFM1+2              HALWORD -1 CONSTANT
         EJECT
*        TABLE USED TO SCAN DECIMAL NUMBERS                           *
*        CHARACTERS 0-9 HAVE ZERO VALUES,ALL OTHERS NONZERO           *
*        ALSO USED IN ICMOP2 FOR GENERAL SCANNING.                    *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
WTDECT   DC    X'02020202020202020202020202020202'    0
         DC    X'02020202020202020202020202020202'    1
         DC    X'02020202020202020202020202020202'    2
         DC    X'02020202020202020202020202020202'    3
         DC    X'100202020202020202020202020C0202'    4 BLANK (
         DC    X'02020202020202020202020608020202'    5  $ *
         DC    X'02020202020202020202020E02020202'    6  ,
         DC    X'02020202020202020202020606020A02'    7 # @ =
         DC    X'02020202020202020202020202020202'    8
         DC    X'02020202020202020202020202020202'    9
         DC    X'02020202020202020202020202020202'    A
         DC    X'02020202020202020202020202020202'    B
         DC    X'02060404060606060606020202020202'    C B-C(4) ALPHS-6
         DC    X'02060604060606060606020202020202'    D L-(4) ALPHS-6
         DC    X'02020606060606040606020202020202'    E X-(4) ALPHS - 6
         DC    X'00000000000000000000020202020202'    F
*        TABLE USED TO SCAN HEXADECIMAL CONSTANTS FOR CORRECTNESS     *
*        CHARACTERS A-F,0-9 ARE ZERO,ALL OTHERS ARE NON-ZERO          *
WTHEXT   DC    X'02020202020202020202020202020202'    0
         DC    X'02020202020202020202020202020202'    1
         DC    X'02020202020202020202020202020202'    2
         DC    X'02020202020202020202020202020202'    3
         DC    X'02020202020202020202020202020202'    4
         DC    X'02020202020202020202020202020202'    5
         DC    X'02020202020202020202020202020202'    6
         DC    X'02020202020202020202020202020202'    7
         DC    X'02020202020202020202020202020202'    8
         DC    X'02020202020202020202020202020202'    9
         DC    X'02020202020202020202020202020202'    A
         DC    X'02020202020202020202020202020202'    B
         DC    X'02000000000000020202020202020202'    C
         DC    X'02020202020202020202020202020202'    D
         DC    X'02020202020202020202020202020202'    E
         DC    X'00000000000000000000020202020202'    F
*              TABLE FOR HEXADECIMAL INPUT CONVERSIONS.               *
WTHEX2   EQU   *-C'A'              OFFSET SYMBOL FROM TABLE CORRECTLY
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
         DC      X'0A0B0C0D0E0F000000000000000000'    C
         DC    X'00000000000000000000000000000000'    D
         DC    X'00000000000000000000000000000000'    E
         DC    X'00010203040506070809'                F
         EJECT
*        USED TO SCAN ACROSS SYMBOLS,STOP ON DELIMITERS               *
*        CHARACTERS $,#,@,A-Z,0-9 ARE ZERO. ALL OTHERS ARE NONZERO    *
*        ALSO USED IN EVALUT FOR OPERATOR CODES- (+*)-/,              *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
WTSYMT   DC    X'01010101010101010101010101010101'     0
         DC    X'01010101010101010101010101010101'     1
         DC    X'01010101010101010101010101010101'     2
         DC    X'01010101010101010101010101010101'     3
         DC    X'04010101010101010101010101020501'     4 BLANK (+
         DC    X'01010101010101010101010007030101'     5 $*)
         DC    X'06080101010101010101010401010101'     6 -/,
         DC    X'01010101010101010101010000010101'     7  #@
         DC    X'01010101010101010101010101010101'     8
         DC    X'01010101010101010101010101010101'     9
         DC    X'01010101010101010101010101010101'     A
         DC    X'01010101010101010101010101010101'     B
         DC    X'01000000000000000000010101010101'     C  A-I
         DC    X'01000000000000000000010101010101'     D  J-S
         DC    X'01010000000000000000010101010101'     E  S-Z
         DC    X'00000000000000000000010101010101'     F  0-9
WTZTAB   EQU   WZEROS              SPACE FOR 256-BYTE ZEROED TRT TABLE
         DS    0D                  LINE UP BLANKS ON D BOUNDARY
WBLANK   DC    CL132' '            BLANKS
         ORG   WBLANK+16           OVERLAP WBLANK&WTHEX3
         SPACE 1
*        TABLE USED TO CONVERT INTERNAL BINARY TO EXTERNAL HEX.       *
*   TR TABLE     0123456789ABCDEF0123456789ABCDEF                     *
WTHEX3   DC    C'                                '    0-1
         DC    C'                                '    2-3
         DC    C'                                '    4-5
         DC    C'                                '    6-7
         DC    C'                                '    8-9
         DC    C'                                '    A-B
         DC    C'                                '    C-D
         DC    C'                0123456789ABCDEF'    E-F
         SPACE 1
WEP4     DC    X'40202120'         4-BYTE DECIMAL EDIT PATTERN
WEP6     DC    X'402020202120'     6-BYTE EDIT PATTERN FOR DEC #
WP0      DC    PL1'0'              FOR ZEROING DECIMAL COUNTERS
WP1      DC    P'1'                DECIMAL CONSTANT 1
WCONADS  DS    ($CNT$N)AL1         SPACE FOR CONSTANT OFFSET TABLE
         WCONG (A,B,C,D,E,F,H,P,V,X,Z)       GENERATE OFFSETS IN WCONAD
         EJECT
* * * * * AVWXTABL SECTION V - VARIABLES  * * * * * * * * * * * * * * *
         DS    0D                  GET ALIGNEMENT
*        **NOTE** FOLLOWING SECTION SHOULD MIRROR AV- SECTION OF      *
*        AVWXTABL DSECT, BUT HAS BEEN REMOVED, BECAUSE NO CODE IS     *
*        ACTUALLY GENERATED, AND FINAL ORG TAKES CARE OF LENGTH.      *
         ORG   VWXTABL+AVWXEND-AVWXTABL     MAKE SURE AS BIG AS AVWXTB
         AIF   (NOT &$XREF).XXNOXRF                                   J
XREFTAB  DSECT
XREFSYM  DS    F                   @ OF SYMBOL'S SYMSECT ENTRY
XREFLLNK DS    H                   LEFT LINK TO NEXT SYMBOL IN TREE
XREFRLNK DS    H                   RIGHT LINK TO NEXT SYMBOL IN TREE
XREFBLCK DS    F                   @ OF BLOCK WITH STATEMENT NUMBERS
XREFTLGN EQU   *-XREFTAB           LENGTH OF XREF TABLE ENTRY
XREFBLK  DSECT
XRBLKNUM DS    F                   NEG # OF SLOTS LEFT IN BLOCK OR
*                                  POINTER TO NEXT BLOCK OF REFERENCES
         DS    &$XREF#B.H          SLOTS FOR STMT NUMBERS
XREFBLGN EQU   *-XREFBLK           LENGTH OF BLOCK OF STMT #
XRPL     EQU   &$PRTSIZ            SET UP XREF LINE LENGTH = MAX LENG J
XRPLAST  EQU   XRPL-18             OFFSET: LAST PLACE TO START        L
         TITLE 'XREFA - CROSS REFERENCE FACILITY'
**--> CSECT: XREFA   CROSS REFERENCE CONTROL SECTION...................
*.         WRITTEN BY ALICE FELTE,ALAN ARTZ, AND RICH LONG            .
*.                                           ---SPRING/SUMMER 1973    .
*.                                                                    .
*.  THIS CSECT IS THE MAIN CONTROL SECTION FOR THE CROSS REFERENCE    .
*. FOR ASSIST. IT HAS THREE ENTRY POINTS WHICH WILL BE DESCRIBED LATER.
*. THIS ROUTINE CONTROLS ALL THE CROSS-REFERENCE FACILITY IF IT IS TO .
*. BE GENERATED.  THE FIRST PASS THE FLAGS AND LOCATION COUNTER ARE   .
*. INITIALIZED--XRINT1.  SPACE IS ALLOCATED FOR THE CROSS-REFERENCE   .
*. ENTRIES AND NECESSARY FLAGS ARE SET FOR THE SECOND PASS--XRINT2.   .
*. THE *XREF CARD WILL BE SCANNED BY XRSCAN.                          .
*.                                                                    .
*.  XRINT1: PASS ONE INITIALIZATION                                   .
*.         CALLED FROM MPCON0.                                        .
*.         1)  INITIALIZE THE ADDITIONAL LOCATION COUNTER,            .
*.             AVXRLNCN, TO 1.                                        .
*.         2)  INITIALIZE THE COUNTER, AVXRCNT, FOR THE NUMBER OF     .
*.             REFERENCES TO 0.                                       .
*.                                                                    .
*.  XRINT2: PASS TWO INITIALIZATION                                   .
*.         CALLED FROM MTCON2.                                        .
*.         1)  ALLOCATE SPACE USING THE MACRO $ALLOCH TO THE          .
*.             DSECT, XREFTAB, SIZE * THE NUMBER OF REFERENCES        .
*.             TO BE COLLECTED AND INITIALIZE ALL SPACE TO 0.         .
*.         2)  SET AVXRLAVS TO FIRST FREE NODE.                       .
*.         3)  SET HEADER NODE FOR THE TREE STRUCTRUE EQUAL TO 0.     .
*.                                                                    .
*.  XRSCAN:  CARD SCANNING ROUTINE.                                   .
*.             A FLAG IS PASSED IN A REGISTER TO DETERMINE WHICH      .
*.         PASS IS BEING PROCESSED.  FOR THE FIRST PASS, SCAN THE     .
*.         CARD AND SET THE SD FLAG ACCORDINGLY.  FOR THE SECOND      .
*.         PASS, SCAN THE CARD AND SET THE SR FLAG ACCORDINGLY.       .
*.                                                                    .
*......................................................................
XREFA    CSECT
         ENTRY XRINT1,XRINT2,XRSCAN
         EJECT
**--> ENTRY: XRINT1     PASS ONE INITIALIZATION........................
*.       THIS IS CALLED FROM MPCON0 ONLY ONCE                         .
*.       MODULE DESCRIPTION--                                         .
*.            INITIALIZES AVXRLNCT, THE ADDITIONAL LINE COUNTER, TO 1 .
*.       AND AVXRCNT, COUNTER FOR THE NUMBER OF REFERENCES FOUND, TO 0.
*.                                                                    .
*......................................................................
         SPACE 2
XRINT1   EQU   *                   ENTRY INITIALIZATION FIRST PASS
         USING *,R15
         USING AVWXTABL,RAT        MAIN TABLE USING
         ZAP   AVXRLNCN(3),AWP1    INITIALIZE ADDITIONAL LINE COUNTER
         MVC   AVXRCNT(2),AWZEROS  INITIALIZE # OF REFERENCES TO 0
         MVI   XRSDORSR,C'D'       FOR SD= SCAN ON *XREF CARDS        L
         MVC   XRFLAGSV,AVXRFLAG   SAVE FLAG
         NI    AVXRFLAG,X'FF'-AVXRSRFT-AVXRSRMD  ZAP, NO PASS 1 REFS
XRI1RET  BR    R14                 RETURN
         DROP  R15,RAT
         SPACE 3
**--> ENTRY: XRINT2     PASS TWO INITIALIZATION........................
*.       THIS IS CALLED FROM MPCON0 ONLY ONCE.                        .
*.       MODULE DESCRIPTION--                                         .
*.            ALLOCATES A BLOCK OF SPACE USING $ALLOCH WHERE THE SIZE .
*.       IS AVXRCNT * XRSIZE.  IT SET AVXRLAVS TO THE ADDRESS OF THE  .
*.       BEGINNING OF THE BLOCK OR FIRST FREE NODE AS RETURNED BY     .
*.       $ALLOCH.  IT ALSO SETS AVXRHEAD, THE HEADER POINTING TO THE  .
*.       FIRST ENTRY IN THE TREE, EQUAL TO 0.                         .
*.                                                                    .
*......................................................................
         SPACE 2
XRINT2   EQU   *                   ENTRY INITIALIZATION SECOND PASS
         USING *,R15
         USING AVWXTABL,RAT        MAIN TABLE USING
         USING XREFTAB,RB          CROSS REFERENCE TABLE
         TM    AVXRFLAG,AVXRON     IS XREF WANTED
         BZ    XRI2RET             NO, RETURN
         MVI   XRSDORSR,C'R'       FOR SR= SCAN ON *XREF CARDS        L
         MVC   AVXRFLAG,XRFLAGSV   RESTORE FOR REF COLL BITS
         LA    RC,XREFTLGN         GET LENGTH OF XREF TABLE ENTRY
         MH    RC,AVXRCNT          GET AMOUNT OF SPACE TO BE ALLOCATED
XRI2ALLO $ALLOCH RB,RC,XRI2OVFL    ALLOCATE SPACE FOR TABLE
         MVC   AVXRHEAD(4),AWZEROS HEADER WILL BE NULL
         ST    RB,AVXRLAVS         PUT @ OF SPACE IN FREE SPACE LIST
         MVI   AVXRTYPE,AVXRFTCH   MAKE SURE FETCH TYPE REF NORMAL    J
         MVC   AVXRLNCN(3),AVOULNCN  INITIALIZE LINE COUNTER
         BR    R14                 RETURN
*     CANCEL XREF OPTION AND SET OVERFLOW FLAG
XRI2OVFL NI    AVXRFLAG,X'FF'-AVXRON  TURN XREF OFF
         OI    AVTAGS3,AVOVERFL    SHOW OVERFLOW OCCURRED
XRI2RET  BR    R14                 RETURN
XRFLAGSV DC    AL1($),X'0'         SAVE WORD,  PAD
         DROP  RAT,RB
         EJECT
**--> ENTRY: XRSCAN     CARD SCANNING ROUTINE..........................
*.       THIS IS CALLED FROM MOCON1 AND MTCON2 TO SCANN THE *XREF CARD.
*.                                                                    .
*.       ENTRY CONDITIONS--  RA  @ TO BEGIN *XREF PARM SCAN           .
*.                           RD  IDX TO SET FLAGS(0=PASS 1,8=PASS 2)  .
*.                                                                    .
*.       MODULE DESCRIPTION--                                         .
*.            CHECK TO SEE WHICH PASS IT IS IN.  DEPENDING ON WHICH   .
*.       PASS IT IS, THE *XREF CARD IS SCANNED AND THE FLAGS SET.     .
*.            IF IT IS PASS ONE, THE CARD IS SCANNED FOR SD=.  IF IT  .
*.       NOT THERE, AVXRFLAG IS NOT CHANGED.  IF IT IS, CHECK FOR     .
*.       LEGAL VALUES OF *, 0, OR 1.  IF IT IS NONE OF THESE THREE,   .
*.       THE STATEMENT IS FLAGGED WITH A SYNTAX ERROR.  IF IT IS A    .
*.       LEGAL VALUE, THE AVXRFLAG IS SET ACCORDINGLY.                .
*.            IF IT IS PASS TWO, THE CARD IS SCANNED SR= AND IS       .
*.       PROCESSED SIMILARLY TO SD= ABOVE.                            .
*.                                                                    .
*......................................................................
         SPACE 2
XRSCAN   $SAVE RGS=(R14-R6),SA=NO   SAVE REGISTERS TO BE USED
         USING AVWXTABL,RAT        MAIN TABLE USING
         TM    AVXRFLAG,AVXRON     IS XREF ON?
         BZ    XRRETURN            NO, RETURN
         LA    RC,1                USEFUL CONSTANT
         $SETRT ('S',1)            SET UP AWTZTAB TO STOP ON S        L
         LA    RE,65(RA)           LAST @ TO CHECK FOR 'S'            L
*
*  PASS 1 -- SCAN FOR SD= AND SET AVWXFLAG ACCORDINGLY                F
* PASS 2 -- SCAN FOR SR= AND SET AVWXFLAG ACCORDINGLY                 L
*
XRSTRT   LR    RB,RE               RB=END OF SCAN                     L
         SR    RB,RA               DETERMINE MACHINE LENGTH FOR EX INST
         EX    RB,XRSEXTRT         SCAN FOR 'S'                       L
         BZ    XRRETURN            IF NOT FOUND,RETURN                F
         CLC   1(2,R1),XRSDORSR    CHK FOR D= (PASS1),R= (PASS2)      L
         BE    *+8                 YES, CHECK FOR LEGAL NUMBER        L
         BXH   RA,RC,XRSTRT        INCR & CHECK FOR ANOTHER S         L
*
*  CHECK MODIFY CHAR FOR '*', '0', OR '1'. ANYTHING ELSE IS ILLEGAL   F
*
         LA    RA,3(R1)            GET @ OF MODIFY CHAR               L
         CLI 0(RA),C'0'            IS IT 0                            F
         BE    XRM0(RD)            YES, SET FLAG                      L
         CLI 0(RA),C'1'            IS IT 1                            F
         BE    XRM1(RD)            YES SET FLAG                       L
         CLI   0(RA),C'*'          IS IT *                            L
         BNE   XRSDSRER            ERROR IF NOT                       L
*                                                                     F
*     CHECK FETCH CHAR FOR '*', '0', '1', ',', OR ' '.  ANYTHING ELSE F
*     IS AN ERROR.  MARK IT SYNTAX ERROR                              F
*                                                                     F
XRNUM2   AR    RA,RC               GET @ OF FETCH CHAR                L
         CLI   0(RA),C'0'          IS IT 0                            F
         BE    XRF0(RD)            YES, SET AVXRFLAG                  L
         CLI   0(RA),C'1'          IS IT 1                            F
         BE    XRF1(RD)            YES, SET AVXRFLAG                  L
         CLI   0(RA),C'*'           IS IT *
         BNE   *+6                 NO, CHECK FOR ',' OR ' '           L
*                                                                     F
*     CHECK FOR A BLANK OR COMMA.    IF IT IS BLANK, RETURN           F
*                                  IF IT IS COMMA, SCAN REST OF CARD  F
*                                                                     F
XRBLNK   AR    RA,RC               NO CHANGE NECESSARY  CHECK FOR ',' L
         CLI   0(RA),C' '          IS IT BLANK                        L
         BE    XRRETURN            YES, RETURN                        F
         CLI   0(RA),C','          IS IT A COMMA                      F
         BE    XRSTRT              GO TO SCAN REST OF THE CARD        L
XRSDSRER LA    RB,$ERVSYNT         SET ERROR CODE
         $CALL ERRTAG              CALL ERROR ROUTINE
*
*     RETURN TO CALLING ROUTINE
XRRETURN $SETRT ('S',0)            RESET AWTZTAB TO ZERO
         $RETURN RGS=(R14-R6),SA=NO
*        SET AVXRFLAG APPROPRIATELY                                   L
XRM0     NI    AVXRFLAG,X'FF'-AVXRSDMD SET SD MODIFY OFF              L
         B     XRNUM2              GET 2ND #                          L
         NI    AVXRFLAG,X'FF'-AVXRSRMD  SET SR MODIFY OFF             L
         B     XRNUM2              GET 2ND #                          L
XRM1     OI    AVXRFLAG,AVXRSDMD   SET SD MODIFY ON                   L
         B     XRNUM2              GET 2ND #                          L
         OI    AVXRFLAG,AVXRSRMD   SET SR MODIFY                      L
         B     XRNUM2              GET 2ND #                          L
XRF0     NI    AVXRFLAG,X'FF'-AVXRSDFT  SET SD FETCH OFF              L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
         NI    AVXRFLAG,X'FF'-AVXRSRFT  SET SR FETCH FLAG OFF         L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
XRF1     OI    AVXRFLAG,AVXRSDFT   SET SD FETCH ON                    L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
         OI    AVXRFLAG,AVXRSRFT   SET SR FETCH FLAG ON               L
         B     XRBLNK              GO CHECK FOR ',' OR ' '            L
XRSEXTRT TRT   0($,RA),AWTZTAB     SEARCH FOR AN S                    L
         DROP  RAT                                                    L
XRSDORSR DC    C'$='               $ REPLACED BY D(PASS 1) OR R(PASS2)
         LTORG
         TITLE 'XRCOLL - CROSS REFERENCE COLLECTION ROUTINE'
**--> CSECT: XRCOLL     COLLECTION ROUTINE.............................
*.       THIS IS CALLED BY SYFIND AFTER IT IS FOUND THAT THE SYMBOL   .
*.       IS DEFINED AND THE REFERENCE IS TO BE COLLECTED.             .
*.                                                                    .
*.       ENTRY CONDITIONS--  RA  HAS THE ADDRESS OF THE SYMBOL IN THE .
*.                                SYMBOL TABLE.                       .
*.                                                                    .
*.       MODULE DESCRIPTION--                                         .
*.          AVXRHEAD HAS THE ADDRESS OF THE FIRST NODE IN THE TREE.   .
*.          AVXRLAVS HAS THE ADDRESS OF THE FIRST AVAILABEL FREE NODE .
*.                                                                    .
*.            THE FOLLOWING ALGORITHM IS FROM "THE ART OF COMPUTER    .
*.       PROGRAMMING" VOL. 1  'FUNDAMENTAL ALGORITHMS' BY DONALD KNUTH.
*.            CHECK HEADER 'AVXRHEAD' FOR EMPTY TREE(= 0).  IF EMPTY, .
*.       EXECUTE INSUB 'XRCLAVS' TO GET FREE NODE FOR PROCESSING.     .
*.       'XRCLAVS' INSERTS SYMBOL AND INITIALIZES LINKS IN NODES---   .
*.       LEFT LINK=0,RIGHT KINK=-1 (ODD DISPLACEMENT IMPOSSIBLE, NEGA-.
*.       TIVE TO SIMPLIFY CHECKS IN XRPRNT ROUTINE).  IF NOT EMPTY,   .
*.       DETERMINE WHETHER OR NOT A NODE HAS ALREADY BEEN CREATED FOR .
*.       THE PRESENT SYMBOL BY COMPARING THE ADDRESS OF THE SYMBOL    .
*.       IN REG RA TO THE ADDRESSES OF SYMBOLS ALREADY IN THE TREE    .
*.       NODES.  IF EQUAL, PROCESS THE REFERENCE (DESCRIBED LATER).   .
*.       OTHERWISE, COMPARE ACTUAL SYMBOLS TO DETERMINE WHERE IN THE  .
*.       TREE THE NEWLY CREATED NODE SHOULD BE INSERTED.  IF THE NEW  .
*.       SYMBOL IS SMALLER IN VALUE THAN THAT OF A NODE IN TREE, THE  .
*.       COMPARISON CONTINUES WITH IT'S LEFT SUBTREE.  IF LARGER, COM-.
*.       PARISON CONTINUES WITH RIGHT SUBTREE.  WHEN A ZERO LEFT LINK .
*.       IS FOUND, OR NEGATIVE RIGHT LINK, THE LINK IS CHANGED TO     .
*.       POINT TO THE NODE WHICH WILL CONTAIN THE INFO FOR THE NEW    .
*.       SYMBOL(NODE FETCHED AND INITIALIZED BY 'XRCLAVS'.            .
*.                                                                    .
*.       PROCESSING THE REFERENCES:                                   .
*.            ONCE THE SYMBOL IS PLACED IN THE TREE, THE REFERENCE    .
*.       MUST BE ENTERED IN A BLOCK OF REFERENCES.  THIS IS DONE IN   .
*.       THE FOLLOWING MANNER:                                        .
*.            1)  IF THE PTR TO THE BLOCK OF REFERENCES IS NULL       .
*.                (I.E. FIRST REFERENCE), A BLOCK MUST BE             .
*.                ALLOCATED AND THE ADDRESS PLACED IN THE POINTER     .
*.                OF THE XREFTAB.                                     .
*.            2)  IF IT IS NOT NULL, THE POINTER IS AN ADDRESS AND    .
*.                THE BLOCK CAN BE LOCATED.                           .
*.                                                                    .
*.            3)  THE FIRST FULLWORD OF THE REFERENCE-BLOCK           .
*.                CONTAINS EITHER:                                    .
*.                A)  THE NUMBER OF SLOTS LEFT IN THE BLOCK.          .
*.                    THE REFERENCE MAY BE ENTERED IN THE BLOCK, THE  .
*.                    NUMBER OF SLOTS IS DECREMENTED BY 1.            .
*.                B)  NEGATIVE ADDRESS OF AN ADDITIONAL BLOCK         .
*.                C)  ZERO, MEANING A NEW BLOCK MUST BE ALLOCATED.    .
*.                    ALLOCATE A NEW BLOCK AND SET THE POINTER IN     .
*.                    PRECEDING BLOCK TO IT (NEGATIVE ADDRESS). THEN  .
*.                    A) MAY BE FOLLOWED.                             .
*......................................................................
         SPACE 2
* * * *  REGISTER USAGE: XRCOLL * * * * * * * * * * * * * * * * * * * *
*   R0=  X'0000FFFF'               USED TO INITIALIZE NODE LINKS      *
*   RW=  @ NODE IN XREF LIST BEING CHECKED  (@ XREFTAB)               *
*   RX=  @ SYMSECT OF SYMBOL ALREADY IN XREF TABLE                    *
*   RA=  @ SYMSECT OF SYMBOL TO BE CHECKED IN XREFTAB                 *
*   RB=  @  BEGIN OF XREF TABLE (FROM WHICH OFFSETS COMPUTED)         *
*   RC,RD,RE,RY,RZ   WORK REGISTERS                                   *
*   R14= INTERNAL LINKAGE                                             *
*   R15= BASE REGISTER                                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XRCOLL   CSECT
         $SAVE RGS=(R14-R6),SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         USING XREFTAB,RW          CROSS TABLE (POINTERS)
         L     R0,AWFXFFFF         =X'0000FFFF'  USED TO INIT PTRS    J
         MVC   AVDWORK2,AWBLANK    PREPARE FOR SYMBOL TO BE CHECKED
         USING SYMSECT,RA
         IC    RD,SYCHARS          GET LENGTH OF LABEL
         EX    RD,XRCSYMO          MOVE SYMBOL TO PADDED AREA FOR COMP
         DROP  RA                  DROP SO USING ON RX OK
         L     RW,AVXRHEAD         GET HEADER POINTER TO FIRST NODE
         LTR   RB,RW               IS IT ZERO, NO NODES ALLOCATED
         BNZ   XRCSYMCK            SYMBOLS IN TABLE - BRANCH
         SPACE 1
*              FIRST SYMBOL - ALLOC SPACE,SET AVXRHEAD
         BAL   R14,XRCLAVS         CALL ALLOCATE ROURINE
         ST    RW,AVXRHEAD         POINTER TO 1ST ENTRY
         LR    RB,RW               RB--> TOP OF TREE
         B     XRCNUENT            GO TO FILL IN
         SPACE 1
XRCSYMCL LA    RW,0(RY,RB)         GET @ NEXT NODE
         USING SYMSECT,RX          SYMBOL TABLE USING
XRCSYMCK L     RX,XREFSYM          GET @ OF SYMSECT ENTRY FOR SYMBOL
         MVC   AVDWORK1(8),AWBLANK INITIALIZE WORK AREA TO BLANKS
         IC    RD,SYCHARS          GET LENGTH OF LABEL
         EX    RD,XRCSYMN          MOVE SYMBOL TO PADDED FIELD
         DROP  RX
         CLC   AVDWORK2(8),AVDWORK1  COMPARE SYMBOLS TO SEE IF WANTED
         BE    XRCENTER            IF EQUAL, HAVE TO ENTER STMT # INTO
         BH    XRCRIGHT            IF> GO TO RIGHT LINK AND CHECK AGAIN
*   IF < GO TO LEFT LINK AND CHECK AGAIN
         LH    RY,XREFLLNK         GET DISP OF LINK IN TABLE
         LTR   RY,RY               IS IT THE END OF TREE
         BNZ   XRCSYMCL            NO, LOOP
*
*           ENTER NEW NODE INTO TREE - LEFT LINKED
*
XRCNULEF BAL   R14,XRCLAVS         GET A NEW NODE
         LR    RZ,RB               TO SAVE @ OF OLD NODE
         SR    RZ,RX               COMPUTE DISPLACEMENT OF OLD NODE
         STH   RZ,XREFRLNK         STORE THREAD TO PREVIOUS NODE
         USING XREFTAB,RX
         LR    RZ,RW               TO SAVE @ OF NEW NODE
         SR    RZ,RB               COMPUTE DISP OF NEW NODE
         STH   RZ,XREFLLNK         STORE INTO LEFT LINK OF PREV NODE
         DROP  RX
         B     XRCNUENT            NOW READY TO ENTER STMT NUMBER
         SPACE 1
XRCRIGHT LH    RY,XREFRLNK         DET DISP OF LINK IN TABLE
         LTR   RY,RY               IS IT THE END OF THE LIST
         BP    XRCSYMCL            NO,LOOP
*
*           ENTER NEW NODE INTO TREE - RIGHT LINKED
*
XRCNURIT BAL   R14,XRCLAVS         GET A NEW NODE
         LR    RZ,RW               TO SAVE @ OF NEW NODE
         SR    RZ,RB               GET DISP OF NEW NODE
         USING XREFTAB,RX
         LH    RY,XREFRLNK         GET RIGHT LINK OF OLD NODE
         STH   RZ,XREFRLNK         STORE DISP OF NEW NODE IN RLINK OF L
         DROP  RX
         STH   RY,XREFRLNK         STORE RLINK OF OLD NODE IN NEW
*
*  ALLOCATE NEW BLOCK FOR REFERENCES
*
XRCNUENT LA    RY,XREFBLGN         GET LENGTH OF BLOCK TO BE ALLOCATED
         $ALLOCH RX,RY,XRCOVFLW    ALLOCATE A BLOCK FOR REFERENCE
         USING XREFBLK,RX          XREF BLOCK OF STMT NUMBERS
         ST    RX,XREFBLCK         STORE POINTER TO BLK OF REFERENCES
         USING SYMSECT,RA
         B     XRCLBLK             GO INSERT STATEMENT NUMBER
*        ENTER HERE IF OLD SYMBOL
XRCENTER L     RX,XREFBLCK         GET ADDRESS OF REFERENCE BLOCK
XRCNXBLK L     RY,XRBLKNUM         GET NUB OF SPACES LEFT OR @ NEXT BLK
         LTR   RY,RY               IS IT ZERO
         BP    XRCSTMT#            POSITIVE, PUT STMT # INTO BLOCK
         BZ    XRCALLOC            ALLOCATE NEW BLOCK IF 0
         LPR   RX,RY               RX--> NEXT REFERENCE BLOCK
         B     XRCNXBLK            GO SEE IF THIS BLOCK HAS ROOM
*              ALLOCATE ADDITIONAL REFERENCE BLOCK
XRCALLOC LA    RY,XREFBLGN         GET LENGTH TO BE ALLOCATED
         LR    RZ,RX               SAVE @ OF FILLER REFERENCE BLOCK
         $ALLOCH RX,RY,XRCOVFLW    ALLOCATE NEW BLOCK OF REFERENCES
         LNR   RY,RX               ADDITIONAL BLK @ IS NEGATIVE
         ST    RY,0(RZ)            STORE @ OF NEW BLOCK INTO FILLED BLK
XRCLBLK  LA    RY,&$XREF#B         GET MAX AVAIL STMT SLOTS,IDX TO 1ST
*
*  INSERT STATEMENT NUMBER INTO REFERENCE BLOCK (- IF MODIFY)
*
XRCSTMT# LA    RC,2(RY,RY)         GET DISPLACEMENT OF OPEN SLOT
         ZAP   AVDWORK1(8),AVXRLNCN GET STMT # OF REFERENCE
         CVB   RZ,AVDWORK1          GET STMT # OF REFERENCE
         TM    AVXRTYPE,AVXRFTCH   IS IT A FETCH REF
         BNZ   *+6                 NO, MUST BE A MODIFY REFERENCE
         LNR   RZ,RZ               GET NEGATIVE STMT # INTO REF BLOCK
         STH   RZ,0(RC,RX)         STORE STMT # OF REFERENCE
         BCTR  RY,0                DECREMENT # OF SLOTS
         ST    RY,XRBLKNUM         STORE REMAINING # OF SLOTS
XRCRET   $RETURN RGS=(R14-R6),SA=NO
         DROP  RX
         SPACE 3
*.-->  INSUB: XRCLAVS . . . . . . . . . . . . . . . . . . . . . . . . .
*.            GET THE FIRST FREE NODE FROM THE LIST OF AVAILABLE      .
*.       SPACE, AVXRLAVS.  SETS AVXRLAVS TO POINT TO THE NEW FIRST    .
*.       FREE NODE.  STORES THE ADDRESS OF THE SUMBOL'S SYMSECT ENTRY .
*.       IN THE NEW NODE.                                             .
*.       RW  HAS THE ADDRESS OF THE NEW NODE                          .
*.       RX  HAS ADDRESS OF OLD NODE                                  .
*.       LEFT LINK INITIALIZED TO ZERO; RIGHT LINK TO -1              .
*.       NOTE: IT IS POSSIBLE TO HAVE THREAD OF A NODE POINT BACK TO  .
*.       ROOT NODE WHICH HAS INDEX DISPLACEMENT OF ZERO.  SINCE -0 IS .
*.       NOT DISTINGUISHABLE FROM +0, THE END OF THE TREE IS DENOTED  .
*.       BY -1 VICE 0                                                 .
*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  .
         SPACE 2
XRCLAVS  LR    RX,RW               SAVE ADDRESS OF OLD NODE
         L     RW,AVXRLAVS         ADDRESS OF FIRST FREE NODE
         LA    RZ,XREFTLGN(RW)     GET @ OF NEXT FREE NODE
         ST    RZ,AVXRLAVS         SAVE @ OF NEW FIRST FREE NODE
         ST    RA,XREFSYM          STORE @ OF SYMBOLS' SYMSECT ENTRY IN
         ST    R0,XREFLLNK         ZERO BOTH LINKS
         BR    R14                 RETURN
         SPACE 3
*
*     COMES HERE WHEN IT DOES NOT HAVE ENOUGH SPACE TO ALLOCATE A NEW
*      REFERENCE BLOCK
*
XRCOVFLW OI    AVTAGS3,AVOVERFL    SET OVERFLOW FLAG ON
         MVI   AVXRFLAG,X'00'      DISARM FLAG NEVER TO RETURN        L
         B     XRCRET              RETURN
XRCSYMN  MVC   AVDWORK1($),SYMBOL-SYMSECT(RX)  MOVE SYMBOL ALREADY IN
*                                              TREE TO WORK AREA
XRCSYMO  MVC   AVDWORK2($),SYMBOL  MOVE NEW SYMBOL TO WORK AREA
         DROP  RW,RA,RAT
         LTORG
         TITLE 'XRPRNT - CROSS REFERENCE PRINT ROUTINE'
**--> CSECT: XRPRNT     PRINT ROUTINE..................................
*.       CALLED FROM MPCON0 TO PRINT OUT THE CROSS REFERENCE.         .
*.            THE COMPRESS BIT OF AVXRFLAG IS TESTED BY AVXRCOMP TO   .
*.       DETERMINE WHICH FORMAT TO USE FOR PRINTING.  IF IT IS OFF,   .
*.       EACH REFERENCE SYMBOL IS PRINTED ON A NEW LINE.  IF IT IS ON,.
*.       THE REFERENCED LABELS ARE PRINTED MORE THAN ONE PER LINE IF  .
*.       THERE IS ROOM.                                               .
*.            THE FOLLOWING ALGORITHM IS FROM "THE ART OF COMPUTER    .
*.       PROGRAMMING" VOL. 1  'FUNDAMENTAL ALGORITHMS' BY DONALD KNUTH.
*.            THE TREE IS THEN TRAVERSED IN POSTORDER.                .
*.                GET THE ADDRESS OF THE FIRST NODE IN THE TREE FROM  .
*.            AVXRHEAD.  IF IT IS 0, PRINT A MESSAGE THAT NO SYMBOLS  .
*.            HAVE BEEN REFERENCED.  IF IT IS NOT 0, FOLLOW THE LEFT  .
*.            LINKS UNTIL IT IS 0.  THEN PRINT THE SYMBOL FROM THE    .
*.            NODE AND ALL ITS REFERENCES.  NOTE: A NEGATIVE          .
*.            REFERENCE IS A MODIFY AND A POSITIVE REFERENCE IS A     .
*.            FETCH.  IT IS PRINTED ACCORDING TO THE FORMAT DESCRIBED .
*.            ABOVE.                                                  .
*.                THEN THE RIGHT LINK IS CHECKED.  IF IT IS -1,WE ARE .
*.            AT THE END OF THE TREE AND RETURN TO ASSIST.            .
*.            IF IT IS LESS THAN -1,IT IS A THREAD BACK TO A NODE.    .
*.            GET THE POSITIVE ADDRESS OF THE NODE, PRINT THE SYMBOL  .
*.            AND ITS REFERENCES.  CHECK THE RIGHT LINK AGAIN.        .
*.            IF IT IS POSITIVE, IT IS THE ADDRESS OF THE NEXT NODE.  .
*.            GO TO THAT NODE AND CHECK ITS LEFT LINK AS ABOVE.       .
*.                                                                    .
*......................................................................
         SPACE 2
* * * *  REGISTER USAGE: XRPRNT * * * * * * * * * * * * * * * * * * * *
*   RW=  @ CURRENT XREFTAB ENTRY PROCESSED                            *
*   R0=  LAST @ TO START STMT # (COMPRESSED OUTPUT)                   *
*   R2=  -1  DENOTES END OF TREE                                      *
*   RA=  LAST @ TO START A SYMBOL (COMPRESSED OUTPUT)                 *
*   RB= @ XREFBLK BEING PROCESSED                                     *
*   RC,RD,RZ   WORK REGISTERS                                         *
*   RE=  @ OF 1ST ELEMENT (BASE FROM WHICH OFFSETS GIVEN)             *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
XRPRNT   CSECT
         $SAVE RGS=(R14-R6),SA=NO
         USING AVWXTABL,RAT        MAIN TABLE USING
         USING XREFTAB,RW          SET UP USINGS ON POINTER TABLE
*
*     PRINT CROSS REFERENCE HEADERS
*
         L     RW,AVXRHEAD         GET @ OF FIRST NODE IN TREE
         LTR   RE,RW               IS THERE AN @ THERE?
         BZ    XRPRRET             NO,RETURN
         $PRNT XREFTTL1,L'XREFTTL1 FIRST LINE OF HEADER
         LA    RZ,XRPOUTPT+1       GET ADDRESS OF OUTPUT LINE
         LA    RA,XRPOUTPT+XRPLAST LAST @ TO START SYMBOL
         LA    R0,11(RA)           LAST @ TO START STMT #
         SR    R2,R2               SET UP REG TO FIND END OF TREE
         BCTR  R2,0                -1 DENOTES END OF TREE
         MVC   XRPOUTPT(XRPL),AWBLANK  BLANK OUT OUTPUT LINE
         MVI   XRPOUTPT,C'0'       CC FOR 1ST LINE
XRPLLNK  LH    RX,XREFLLNK         GET LEFT LINK
         LTR   RX,RX               IS IT THE NODE TO BE PRINTED
         BZ    XRPRNODE            YES,PRINT NODE
         LA    RW,0(RX,RE)         @ OF NODE IN RW
         B     XRPLLNK             IS IT THE LAST NODE
XRPRLNK  LH    RX,XREFRLNK         GET RIGHT LINK
         CR    RX,R2               END OF TREE?
         BE    XRPRRETP            -1, END OF TREE
         TM    AVXRFLAG,AVXRCOMP   IS IT TO BE COMPRESSED OUTPUT
         BNO   XRPSYMBL            NO,GO PRINT LINE
*        OUTPUT IS TO BE COMPRESSED
         LA    RZ,3(RZ)            SKIP 3 SPACES BEFORE NEXT SYMBOL
         CR    RZ,RA               IS PTR TO OR PAST THAT POINT?
         BL    *+8                 NO,MOVE CHARACTERS INTO LINE
XRPSYMBL BAL   R14,XRPRLINE        PRINT OUTPUT LINE
         LTR   RX,RX               THREAD OR NODE?
         BNP   *+12                A THREAD, PRINT NODE
         LA    RW,0(RX,RE)         @ OF NODE IN RW
         B     XRPLLNK             CHECK FOR LEFT
         LPR   RW,RX               @ OF NODE TO PRINTED
         LA    RW,0(RW,RE)         @ OF NODE TO BE PRINTED
         SPACE 1
*        OBTAIN AND PRINT SYMBOL
XRPRNODE L     RY,XREFSYM          GET @ OF SYMBOL'S SYMSECT ENTRY
         USING SYMSECT,RY          DO USING
         IC    RD,SYCHARS          GET LENGTH OF SYMBOL
         EX    RD,XRPMOVE          MOVE SYMBOL TO OUTPUT LINE
         LA    RZ,9(RZ)            INVREMENT PTR TO POSITION IN OUTPUT
         L     RB,XREFBLCK         GET @ OF REFERENCE BLOCK
         USING XREFBLK,RB          SET UP REFERENCE BLOCK DSECT
         UNPK  0(7,RZ),SYVALUE+1(4) UNPACK
         MVI   6(RZ),C' '          MAKE BLANK
         TR    0(6,RZ),AWTHEX3     FINISH HEX CONVERT
         LA    RZ,6(RZ)            INCR PTR TO POSITION IN OUTPUT LINE
         BAL   R14,XRPNUMSL        GET NUM OF SLOTS USED AND TIMES LOOP
XRPNEXT# CR    RZ,R0               IS IT THE END OF THE LINE?
         BL    *+8                 NO GET STMT NO.
         BAL   R14,XRPRLINE        YES PRINT LINE
         LA    RC,2(RX,RX)         SAVE NUMBER TO BE PRINTED
         LH    RC,0(RC,RB)         PUT STM # IN REG
         CVD   RC,AVDWORK2         PACKED DECIMAL VALUE OF STMT #
         MVC   0(6,RZ),AWEP6       MOVE EDIT PATTERN IN
         LA    R1,5(RZ) DO NOT REMOVE..A MUST FOR 1 DIGIT,NEGATIVE    L
*                       STATEMENT NUMBERS..EDMK NEEDS THIS @          L
         EDMK  0(6,RZ),AVDWORK2+5  EDIT STMT # TO PRINTABLE FORM
         BNM   *+10                POSITIVE STMT # (MOD REF)
         BCTR  R1,0                GET @ TO INSERT -
         MVI   0(R1),C'-'          INSERT MINUS SIGN TO SHOW MODIFY
         LA    RZ,6(RZ)            INREMENT PTR TO  POS IN OUTPUT LINE
         BCTR  RX,0                DECREMENT TIMES THRU LOOP
         CR    RD,RX               HAVE ALL REFS IN BLK BEEN COLLECTED?
         BL    XRPNEXT#            NO,IF LOW
         SPACE 1
         LTR   RY,RY               IS THERE ANOTHER BLOCK OF REFERENCES
         BNM   XRPRLNK             NO GET NEXT SYMBOL IN TREE
         LPR   RB,RY               PUT @ OF NEXT BLOCK IN RB
         BAL   R14,XRPNUMSL        GET NUMBER OF SLOTS USED; TIMES THRU
         B     XRPNEXT#            PRINT NEXT REFERENCE
XRPMOVE  MVC   0($,RZ),SYMBOL      MOVE SYMBOL TO OUTPUT LINE  EXECUTED
         SPACE 3
*.--> INSUB: XRPRLINE       PRINTS A LINE OF REFERENCES . . . . . . . .
*.       SETS RZ TO POINT TO THE BEGINNING OF THE LINE. CLEAR         .
*.       OUTPUT LINE TO ALL BLANKS.                                   .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ..
         SPACE 2
XRPRLINE $PRNT XRPOUTPT,XRPL,XRPMSG PRINT OUT THE LINE OF REFERENCES
         LA    RZ,XRPOUTPT+1       GET ADDRESS OF OUTPUT LINE
         MVC   XRPOUTPT(XRPL),AWBLANK   CLEARS OUTPUT LINE
         BR    R14                 RETURN
         SPACE 3
*.--> INSUB: XRPNUMSL . . . . . . . . . . . . . . . . . . . . . . . . .
*.       GETS INDEX TO 1ST REFERENCE OF BLOCK, INDEX TO LAST REFERENCE.
*.       TO PRINT, AND VALUE FROM XRBLKNUM TO USE AS FLAG FOR TEST FOR.
*.       ADDITIONAL BLOCKS LATER IN MAIN SECTION OF CODE.             .
*.         RX=  INDEX TO 1ST REFERENCE TO BE PRINTED                  .
*.         RD=  INDEX TO LAST REFERENCE TO BE PRINTED                 .
*.         RY=  FLAG USED LATER(IF - THERE IS AN ADDITIONAL BLOCK)    .
*......................................................................
         SPACE 2
XRPNUMSL LA    RX,&$XREF#B         RX=POSS # REFS(ASSUME 1ST BLOCK
         L     RY,XRBLKNUM         GET # OF UNUSED SLOTS
         LTR   RD,RY               IS IT AN @ OR # OF SLOTS
         BCR   NM,R14              RD=LAST REFERENCE
         SR    RD,RD               RD=LAST REFERENCE
         BR    R14                 RETURN
         SPACE 3
* XRPMSG EQU   XRPRRET  *****      RETURN ON RECORDS EXCEEDED  CEH
XRPRRETP $PRNT XRPOUTPT,XRPL,XRPMSG        PRINT LAST LINE
XRPRRET  $RETURN RGS=(R14-R6),SA=NO
XRPMSG   EQU   XRPRRET             RETURN ON RECORDS EXCEEDED  CEH
XRPOUTPT EQU   AVCONCAT            WORK AREA
XREFTTL1 DC    C'0*** CROSS-REFERENCE:  VALUE(HEX) LOCATION REF REF ...X
                (- SHOWS MODIFY) ***'
         DROP  RW,RY,RB,RAT
.XXNOXRF ANOP
