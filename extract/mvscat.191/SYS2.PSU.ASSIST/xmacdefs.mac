./ ADD LEVEL=40,SOURCE=0,NAME=EQUREGS
         MACRO
&LABEL   EQUREGS &L=R,&DO=(0,15,1),&SYM=
.*--> MACRO: EQUREGS    GENERATE SYMBOLIC REGISTER EQUATES  . . . . . .
.*                                 JOHN R. MASHEY/JULY'69/PSU 360/67  *
.*       MACRO FOR SETTING UP SETS OF REGISTER EQUATES.               *
.*       *** ARGUMENTS ***                                            *
.*       L=        SYMBOL USED TO BEGIN EQUATES, SUCH AS R, REG,ETC.  *
.*       DO=       (INITIAL,LIMIT,INCREMENT) WILL SET UP REGISTERS    *
.*             EQUATED TO THE VALUE AS CONTROLLED BY THE DO PARAMATER.*
.*             BEHAVES LIKE FORTRAN DO, INCLUDING ABILITY TO LEAVE OUT*
.*             INCREMENT.                                             *
.*       SYM=      LIST OF SYMBOLS TO BE CONCATENATED TO L PARM.      *
.*             LIST WILL SET UP EQUATES INCLUDING SYM VALUES, FOR     *
.*             FIRST SET OF EQUATES IN LIST, AND WILL THEN SET UP     *
.*             NUMERIC EQUATES IF DO VALUES EXCEED NUMBER OF ELEMENTS *
.*             IN SYM OPERAND.  MAY BE OMITTED ENTIRELY.              *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&J,&K            COUNTER,INCREMENT,SYM COUNTER
         AIF   (N'&DO LT 2).XERROR           NOT ENOUGH ARGUMENTS-ERR
&K       SETA  1                   INIT
&I       SETA  &DO(1)              SET TO INITIAL VALUE
&J       SETA  1                   SET TO DEFAULT VALUE
         AIF   (N'&DO LT 3).XLOOP            DEFAULT VALUE IS OK
&J       SETA  &DO(3)              USE VALUE PROVIDED
.XLOOP   AIF   ('&SYM(&K)' EQ '').XLOOP1     USE NUMBER IF NO SYM VAL
&L&SYM(&K) EQU &I
&K       SETA  &K+1      INCREMENT TO GET NEXT SYM OPERAND
         AGO   .XLOOP2             SKIP OVER NORMAL GENRATION
.XLOOP1  ANOP
&L&I     EQU   &I
.XLOOP2  ANOP
&I       SETA  &I+&J               ADD INCREMENT TO COUNTER
         AIF   (&I LE &DO(2)).XLOOP          CONTINUE UNTIL DONE
         MEXIT
.XERROR  MNOTE 0,'** ERROR - EQUREGS REQUIRES AT LEAST 2 VALUES IN DO'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XCHAR
         MACRO
         XCHAR &STRING,&NUM
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCHAR      RETURN SAFE RIGHT-END SUBSTRING OF A STRING.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO RETURNS IN &XXCHAR THE &NUM CHARACTERS TAKEN FROM *
.*       THE RIGHT END OF THE CHARACTER STRING &STRING, WITHOUT       *
.*       BLOWING UP IF THERE ARE LESS THAN &NUM CHARS IN &STRING.     *
.*       THIS MACRO IS USED BY XSAVE,XRETURN, AND XSRNR               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             RETURN RESULT IN THIS
         AIF   (&NUM GT K'&STRING).XGA       SKIP IF HE WANTS MORE
&XXCHAR  SETC  '&STRING'(K'&STRING+1-&NUM,&NUM)        SCOOP RIGHT AMT
         MEXIT
.XGA     ANOP
&XXCHAR  SETC  '&STRING'           STRING SMALLER-USE WHOLE THING
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XDECI
         MACRO
&LABEL   XDECI &REG,&ADDRESS
.*--> MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION * * * * * * *
.*             EXTENDED DECIMAL INPUT MACRO - ENABLES PROGRAMS        *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       USES MODULE XXXXDECI TO SCAN DECIMAL STRING BEGINNING AT     *
.*       &ADDRESS, CONVERT ITS VALUE INTO REGISTER &REG, AND SET      *
.*       REGISTER R1 AS A SCAN POINTER TO THE DELIMITER FOLLOWING THE *
.*       STRING OF DECIMAL DIGITS.  THE CONDITION CODE IS SET BY THE  *
.*       VALUE IN &REG, UNLESS AN ERROR OCCURRS, IN WHICH CASE CC=3.  *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF LABEL
&XLABL   SETC  'XX&SYSNDX.E'       CREATE UNIQUE LABEL
         CNOP  2,4  .              LINE UP ON BOUNDARY
&LABEL   STM   14,1,&XLABL  .      SAVE LINKAGE REGS
         LA    0,&ADDRESS .        BEGINNING @ FOR SCANNING
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION
         BALR  14,15 .             CALL ROUTINE, PT WITH R14
         DC    V(XXXXDECI) .       ADCON FOR CONVERSION ROUTINE
&XLABL   DS    5F .                REGS 14,15,0,1, VALUE FOR &REG
         LM    14,1,4(14) .        RELOAD REGS
         BO    *+8 .               BRANCH IF &REG SHOULDN'T CHANGE
         L     &REG,&XLABL+16  .   GET VALUE FOR &REG
         AIF   (T'&REG EQ 'N' AND '&REG' NE '1').XXEXIT SKIP IF SAFE
         L     1,&XLABL+12  .      USER MAY HAVE REG=1, LOAD FOR SAFE
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XDECO
         MACRO
&LABEL   XDECO &REG,&ADDRESS
.*--> MACRO: XDECO      EXTENDED DECIMAL OUTPUT CONVERSION* * * * * * *
.*       USES MODULE XXXXDECO TO CONVERT VALUE IN REGISTER &REG TO    *
.*       AN EDITED 12-BYTE FIELD, WITH SIGN, AT LOCATION &ADDRESS.    *
.*             EXTENDED DECIMAL OUTPUT MACRO - ENABLES PROGRAMS       *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  &XLABL              FOR CREATION OF UNIQUE LABEL
&XLABL   SETC  'XX&SYSNDX.D'       CREATE UNIQUE LABEL
         CNOP  2,4 .               LINE UP ON RIGHT BOUNDARY
&LABEL   STM   14,0,&XLABL  .      STORE LINKAGE REGS
         ST    &REG,&XLABL+12  .   SAVE VALUE TO BE CONVERTED
         LA    0,&ADDRESS .        OBTAIN @ OPERAND FILED
         L     15,&XLABL-4  .      GET ADCON FOR CONVERSION PROG
         BALR  14,15 .             CALL XXXXDECO, PT R14
         DC    V(XXXXDECO) .       ADCON FOR CONVERSION PROG
&XLABL   DS    4F .                REGS 14,15,0, REG TO BE CONVERTED
         LM    14,0,4(14) .        RELOAD LINKAGE REGISTERS
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XDUMP
         MACRO
&LABEL   XDUMP &AREA,&LENGTH
.*--> MACRO: XDUMP      ASSIST COMPATIBILITY DUMP MACRO . . . . . . . .
.*             MACRO FOR STORAGE AND REGISTER DUMPING. ENABLES        *
.*       PROGRAMS WRITTEN FOR ASSIST TO BE RUN DIRECTLY UNDER OS/360. *
.*       SEE ASSIST USER MANUAL FOR USAGE *
.*       *NOTE* USES XSNAP, SO REQUIRES XSNAPOUT DD SYOUT=A CARD.     *
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         AIF   (T'&AREA EQ 'O').XREGS   SKIP TO REGS IF NO OPS
         AIF   (T'&LENGTH EQ 'O').XSTDF DEFAULT LENGTH IF NONE
.*             DUMP STORAGE, USING SUPPLIED LENGTH &LENGTH.
&LABEL   XSNAP T=NO,LABEL='USER STORAGE',                              #
               STORAGE=(*&AREA,*&LENGTH+&AREA)
         MEXIT
.*             DUMP STORAGE, USING DEFAULT LENGTH OF 4.
.XSTDF   ANOP
&LABEL   XSNAP T=NO,LABEL='USER STORAGE',                              #
               STORAGE=(*&AREA,*4+&AREA)
         MEXIT
.*             &AREA,&LENGTH OMITTED --> DUMP REGISTERS.
.XREGS   ANOP
&LABEL   XSNAP LABEL='USER REGISTERS'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XGET
         MACRO
&XLABEL  XGET  &XAREA,&XNUM
.*--> MACRO: XGET    GET RECORD OFF OF &DDNAME FILE . . . . . . . . . *
.*                                 RICHARD FOWLER AUG, 1972 V.5.0     *
.*       MACRO FOR EASY READING OFF OF ANY DD FILE, READS &XNUM       *
.*       CHARACTERS. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON     *
.*       END OF FILE. GENERATION CONTROLLED BY &XGETST.               *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
         GBLB  &XGETST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XGETST).XNOGEN    IF SHOULDN'T GENERATE-SKIP CALL
&XLABEL  XIONR XXXXGET,&XNUM,&XAREA,80
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XGET
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XGPGEN
         MACRO
&LABEL   XGPGEN &DIREC=G,&FETCH=NOT,&DDNUM=20
.** --> MACRO: XGPGEN  GENERATE GENERAL I/O MODULES . . . . . . . . . .
.*                                    RICHARD FOWLER NOV, 1972 V.5.0  .
.*                                                                    .
.*       ARGUMENTS:                                                   .
.*             &DIREC = P --> OUTPUT                                  .
.*                   ›= P --> INPUT                                   .
.*             &FETCH  =NOT --> NO FETCH PROTECTION                   .
.*                    ›=NOT -->    FETCH PROTECTION                   .
.*             &DDNUM = MAXIMUM NUMBER OF DD NAMES ALLOWED AT ONCE    .
.*     (**EACH DD FILE REQUIRES 3F TABLE ENTRY PLUS DCB AND BUFFER**) .
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         TITLE ' &LABEL - MODULE CREATED BY XGPGEN'
         DCBD DSORG=QS
* * * * * XIOBLOCK - CONTROL BLOCK SET UP BY XREAD/XPRNT/XPNCH  * * * *
XIOBLOCK DSECT
         DS    V .                 @ I/O ROUTINE
         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED
XIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USEQ
XIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS
&LABEL   CSECT
*--> CSECT: EXTENDED I/O MODULE FOR GENERAL I/O . . . . . . . . . . . .
*        THIS MODULE IS CALLED TO DO GENERAL I/O WORK ON A FILE       .
*              SIMILAR IN OPERATION TO THE XIO ROUTINES, BUT CAN HANDLE
*              MANY FILES AT ONCE.                                    .
*        ENTRY CONDITIONS:                                            .
*          R14 = @ OF CONTROL BLOCK                                   .
*          R15  = ENTRY POINT ADDRESS                                 .
*          R0  = ADDRESS OF AREA TO MOVE DATA INTO                    .
*          R1  = ADDRESS OF DD NAME TO BE USED                        .
*        CONTROL BLOCK:                                               .
*      OFFSET  LENGTH        WHAT                                     .
*        0       1F        ENTRY POINT ADDRESS                        .
*        4       3F          SAVE AREA                                .
*        16      2           LENGTH OF AREA                           .
* . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         USING *,15 .              NOTE TEMPORARY ADDRESSABILITY
         USING XIOBLOCK,R14
         STM   R13,R7,X&DIREC.SAV1 SAVE REGISTERS TO BE USED          A
         CNOP  0,4 .               GET ON FULLWORD
         BAL   R13,*+76            SET UP FAKE AREA PNTR - BASE
         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER
         DS    18F .               FAKE SAVE AREA
         DROP  R15 .               KILL OLD ADDRESSING
         SPACE 2
         USING IHADCB,R1 .         SET UP ADDRESSIBILITY TO DCB S
         MVC   X&DIREC.CURENT(8),0(R1) . GET CURRENT DD NAME
*   CHECK FOR CLOSE
         SR    R1,R1               GET ZERO LENGTH INDICATOR
         CH    R1,XIOLENG          ARE THEY EQUAL?
         BE    X&DIREC.EOF .       YES-GO CLOSE AND FORGET FILE
         XXGPSRCH &DIREC
*  THE FOLLOWING CODE, IF EXECUTED, GENERATES A DCB AND TRIES AN OPEN
*
X&DIREC.MAKE C R1,=A(X&DIREC.FULL) CHECK FOR TABLE OVERFLOW
         BNL   X&DIREC.CC3         NO SPACE, DON'T TRY OPEN-RETURN    J
         ST    R1,X&DIREC.ELEM .   SAVE NEW ADDRESS, R1 ALREADY POINTIN
         MVC   0(8,R1),X&DIREC.CURENT  SAVE DD NAME FOR FUTURE CALLS
         L     0,X&DIREC.LONG
         GETMAIN R,LV=(0) .        LOAD R1 WITH ADDR OF NEW DCB
         L     R2,X&DIREC.ELEM .   GET ADDRESS OF POINTER
         ST    R1,8(R2) .          SAVE @ OF DCB
*
         ST    R1,X&DIREC.FULL     KLUDGE TO GET AROUND ADDRESSIBILITY
         MVC   X&DIREC.OPEN+1(3),X&DIREC.FULL+1  COPY OVER DCB @ INTO J
*
         MVC   0(X&DIREC.ELEM-X&DIREC.DCB,R1),X&DIREC.DCB BUILD DCB
         MVC   DCBDDNAM,X&DIREC.CURENT MOVE DD NAME INTO DCB
         OPEN  MF=(E,X&DIREC.DCBPTR)  DO REMOTE OPEN
         L     R1,X&DIREC.FULL .   FIX R1, DESTROYED IN OPEN
         TM    DCBOFLGS,X'10' .    DID OPEN GO?
         BO    X&DIREC.CONT4       YES, DO I/O
*              OPEN DIDN'T GO - CLEAN UP SO DOESN'T BOMB LATER        J
         L     R0,X&DIREC.LONG     GET LENGTH OF DCB FOR FREEMAIN     J
         FREEMAIN R,LV=(0),A=(1)   GIVE THE SPACE BACK TO OS          J
         XC    0(12,R2),0(R2)      CLEAR OUT SO WON'T THINK IT'S OPEN J
X&DIREC.CC3 TM *+1,X'FF'       SET CC=3  ==> OPEN IMPOSSIBLE          J
         B     X&DIREC.RET         RETURN TO USER
         SPACE 2
X&DIREC.CONT L R1,8(R1) .          GET DCB ADDRESS
X&DIREC.CONT4 LH R5,XIOLENG        GET LENGTH OF AREA
         AIF   ('&FETCH' EQ 'PROTECT').SKPFTCH
         L     R2,X&DIREC.SAV1+12  GET @ I/O AREA
* THE FOLLOWING CODE IS USED FOR ADDRESS ILLEGAL     ******************
*****  THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT ***********
         SPACE 2
         L     R4,16 .             GET CVT PNTR FROM LOC 16
         LA    R0,0(R2,R5) .       GET ENDING ADDRESS OF I/O AREA
         C     R0,164(R4) .        COMPARE TO CVTMZ00 - HIGHEST ADDRESS
         BNL   X&DIREC.ABD3 .      GO ABEND IF HIGHER
.SKPFTCH ANOP
         AIF   ('&DIREC' EQ 'P').XOUT  SKIP IF OUTPUT
         LH    R7,DCBLRECL         GET LRECL FROM DCB                 J
         GET   IHADCB .            GET # BUFFER
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK                  J
         LR    R5,R7               TOO BIG, USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R2),0(R1) .   GIVE USER 256 BYTES OF DATA
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+10 .              NO - DONT MOVE LEFTOVER BYTES
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
.XCLOSE  ANOP
         SR    R0,R0 .             SET COND CODE TO 0, USER OK
         B     X&DIREC.RET .       GO TO RETURNX&DIREC.EOF CLOSE IHADCB
X&DIREC.EOF EQU *
         XXGPSRCH &DIREC,2
X&DIREC.MAKE2 B X&DIREC.RET .      GO RETURN
X&DIREC.CONT2 LR R4,R1 .           SAVE THE ADDRESS
         MVC   X&DIREC.PTR+1(3),9(R1)
         LA    R1,X&DIREC.PTR
         CLOSE MF=(E,(1))          DO REMOTE CLOSE
         L     R1,8(R4) .          POINT TO DCB TO FREE
         FREEPOOL (1)              FREE THE BUFFERS
         L     R1,8(R4)            RESET R1 IN CASE DESTROYED
         L     R0,X&DIREC.LONG     GET AMOUNT TO FREE
         FREEMAIN R,LV=(0),A=(1)
*
*   DCB NO LONGER EXISTS,  REMOVE CORRESPONDING ELEMENT FROM LIST
*
         LA    R3,X&DIREC.FULL .    GET UPPER ADDRESS OF TABLE
         SR    R3,R4   .           FIND LENGTH OF REST OF TABLE
         EX    R3,X&DIREC.WIPOUT   WIPEOUT 12 BYTES OF MEMORY
*
*      IF NO POINTERS REMAIN, SET POINTER TO LAST TO ZERO
*
         LA    R3,12
       L       R2,X&DIREC.ELEM
         SR    R2,R3
         LA    R1,X&DIREC.PNTSRT
         CR    R1,R2
         BNH   *+8
         LA    R2,0 .              SET POINTER TO ZERO
         ST    R2,X&DIREC.ELEM     SAVE POINTER
         AIF   ('&DIREC' EQ 'P').XRET
         OI    *+1,1 .             SET COND CODE FOR END OF FILE
.*       SHOULD REMOVE DCB FROM LIST NOW
         AGO   .XRET .             HAVE RETURN CODE GENERATED
.*
.XOUT    ANOP
         LH    R7,82(R1) .         GET LRECL
         PUT   IHADCB .            PRINT THE STUFF
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK LENGTH           J
         LR    R5,R7               TOO BIG- USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         LR    R6,R5               SAVE FOR LATER
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R1),0(R2) .   PUT STUFF INTO BUFFER
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+12
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,X&DIREC.MOV .    MOVE INTO RIGHT PLACE
         AR    R1,R5               GET BEGINNING @ TO BLANK
         SR    R7,R6               GET DIFFERENCE BETWEEN USER AND DCB
         BZ    *+12                NO DIFFERENCE, DO NOTHING          A
         MVI   1(R1),C' '
         EX    R7,X&DIREC.MOV2     CLEAR REST
*  ****NOTE THAT THIS ONLY WORKS FOR DIFFERENCES < 256
         AGO   .XCLOSE
.*
.XRET    ANOP
         SPACE 2
X&DIREC.RET LM R13,R7,X&DIREC.SAV1 RESTORE REGS                       A
         B     XIORETRN            RETURN
         DROP  R14
X&DIREC.ABD3 CLI  *,0              SET CC=2, SHOW EXECUTE ERROR       J
         B     X&DIREC.RET         GO RETURN, SHOWING ERROR           J
.*
         SPACE 2
X&DIREC.PTR CLOSE (X&DIREC.CONT),MF=L    GENERAL PURPOSE CLOSE
X&DIREC.WIPOUT MVC 0(1,R4),12(R4)
X&DIREC.CURENT DS  CL8  .          AREA TO HOLD CURRENT DD NAME
X&DIREC.SAV1 DS 11F                SAVE AREA FOR REGS USED            A
X&DIREC.PNTSRT DS (&DDNUM*3)F .    AREA FOR DDNUM DD NAMES & POINTERS
X&DIREC.FULL DS F
X&DIREC.OPEN DS 0F                 EXTRA LABEL
         AIF   ('&DIREC' EQ 'P').XDEFSR  SKIP IF OUTPUT
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(INPUT)),MF=L  OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=GL,EODAD=X&DIREC.EOF
X&DIREC.ELEM DC  F'0' .            INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R2),0(R1) .    GIVES USER THE DATA
         LTORG
         DROP  R13
         MEXIT                     DONE
.XDEFSR  ANOP
X&DIREC.DCBPTR OPEN (X&DIREC.CONT,(OUTPUT)),MF=L OPEN CONTROL WORD    J
X&DIREC.DCB DCB DSORG=PS,MACRF=PL
X&DIREC.ELEM DC F'0' .             INITIAL # OF ELEMENTS
XX&DIREC.LONG EQU X&DIREC.ELEM-X&DIREC.DCB   GET DCB LENGTH
X&DIREC.LONG DC A(XX&DIREC.LONG)   SAVE LENGTH OF DCB
X&DIREC.MOV MVC 0(1,R1),0(R2) .    MOVE INTO LINE
X&DIREC.MOV2 MVC 2(1,R1),1(R1)     CLEAR OUT REST OF BUFFER
         LTORG
         DROP  R13
         MEND
./ ADD LEVEL=41,SOURCE=0,NAME=XHEXI
         MACRO
&NAME    XHEXI &REG,&ADDR
.*                                                                    *
.*-->MACRO: XHEXI  HEXADECIMAL INPUT CONVERSION MACRO.                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE STARTING AT THE ADDRESS GIVEN BY  *
.*  &ADDR AND CONVERTS IT AND PUTS THE HEXADECIMAL VALUE IN &REG.     *
.*  IF THERE ARE MORE THAN 8 DIGITS, R1 POINTS TO THE 9TH AND THE     *
.*  FIRST 8 ARE CONVERTED.  IF THERE IS A NON-BLANK, NON-HEX DIGIT    *
.*  FOUND, R1 POINTS TO THAT CHARACTER AND THE CC=3, OTHERWISE CC SET *
.*  BY VALUE IN REG.                                                  *
.*                                                                    *
.*       CALLS MODULE XXXXHEXI TO DO THE ACTUAL CONVERSIONS           *
.*                                                                    *
.**********************************************************************
         LCLC  &LABEL
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    STM   14,0,&LABEL  .      SAVE REGISTERS
         ST    &REG,&LABEL+12  .  REGISTER STORE INCASE OF OVERFLOW CND
         LA    0,&ADDR  .         GET STRING TO BE CONVERTED
         CNOP  2,4  .              GET PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXI
         BALR  14,15  .            GO TO APPROPRIATE PLACE
         DC    V(XXXXHEXI)  .      VCON OF ROUTINE
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,4(14)  .       RESTORE REGISTERS
         L     &REG,&LABEL+12  .  GET CONVERTED NUMBER
         MEND
./ ADD LEVEL=41,SOURCE=0,NAME=XHEXO
         MACRO
&NAME    XHEXO &REG,&ADDR
         LCLC  &LABEL
.*                                                                    *
.*-->MARCO: XHEXO  HEXADECIMAL OUTPUT CONVERSION MACRO                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE IN & REG AND CONVERTS IT TO       *
.*  PRINTABLE FORM.                                                   *
.*       IT PUTS THE CONVERTED VALUE IN AN EIGHT BYTE AREA STARTING AT*
.* THE ADDRESS GIVEN IN &ADDR.                                        *
.*      THE CONDITION CODE IS NOT CHANGED AND NETHER ARE THE REGISTERS*
.*                                                                    *
.*       CALLS MODULE XXXXHEXO TO DO THE ACTUAL CONVERSIONS.          *
.*                                                                    *
.**********************************************************************
&LABEL   SETC  'XX&SYSNDX.H'      UNIQUE LABEL
&NAME    DS    0H
         STM   14,0,&LABEL  .      SAVE REGIST5RS
         ST    &REG,&LABEL+12  .    SAVE REGISTER
         LA    0,&ADDR   .        PASS REGISTER TO XXXXHEXO
         CNOP  2,4  .              GDT PROPER ALIGNMENT
         L     15,&LABEL-4  .     ADDRESS OF XXXXHEXO
         BALR  14,15  .            CALL HEXO
         DC    V(XXXXHEXO)
&LABEL   DS    4F  .              STORAGE FOR REGISTERS
         LM    14,0,&LABEL  .     RESTORE REGISTERS
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XIDENT
         MACRO
         XIDENT &ID,&LABEL,&XCSECT,&PRIVATE
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIDENT     IDENTIFY ENTRY POINT FOR XSAVE,$SAVE.         *
.*       MACRO USED BY XSAVE TO PRODUCE ID AT AN ENTRY POINT.  WILL   *
.*       USE THE FIRST NON-NULL OPERAND PASSED TO IT AS THE ID.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&J                LOCAL COUNTERS
&I       SETA  1                    INITIALIZE
         AIF   ('&ID' NE '*').XIDINC         SKIP IF EXPLICIT ID FIELD
.XILOOP  ANOP
&I       SETA  &I+1                 INCREMENT TO NEXT ONE
         AIF   ('&SYSLIST(&I)' EQ '').XILOOP SKIP BACK IF THIS IS NULL
.XIDINC  ANOP
&J       SETA  6+((K'&SYSLIST(&I)+1)/2)*2   GET BRANCH LENGTH
         B     &J.(,15) .           BRANCH AROUND ID
&J       SETA  &J-5                 GET ACTUAL LENGTH OF ID
         DC    AL1(&J),CL&J'&SYSLIST(&I)'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XIOGN
         MACRO
&XLABEL  XIOGN  &LRECL=80,&BLKSIZE=80,&XOP=OUTPUT,&RECFM=,&DDNAME=,    #
               &BUFNO=1
.*--> MACRO: XIOGN      I/O SUPPORT MODULE GENERATION . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.5.0  *
.*       MACRO USED TO GENERATE THE I/O CSECTS USED BY THE XIOPAK     *
.*       MACROS XREAD,XPRNT,XPNCH.  THE CSECTS ARE CALLED EACH TIME   *
.*       ONE OF THE MACROS IS CALLED, AND DOES REQUIRED OPN'S, GET'S, *
.*       PUT'S, ETC .                                                 *
.*       **ARGUMENTS**                                                *
.*       BLKSIZE,BUFNO,LRECL,RECFM=    ARGUMENTS FOR CREATED DCB.     *
.*             DEFAULTS: BLKSIZE=80,BUFNO=1,LRECL=80.                 *
.*             IF MODULE DESIRED FOR USE WITH VARIABLE JCL VALUES,    *
.*             CODE BLKSIZE=0,BUFNO=0,LRECL=0.                        *
.*       XOP= EITHER INPUT OR OUTPUT, DENOTING DIRECTION OF I/O.      *
.*             DEFAULT: OUTPUT.                                       *
.*       DDNAME=   LIST OF DDNAMES WHICH MODULE CAN USE FOR I/O.      *
.*             WILL ATTEMPT OPEN OF EACH ONE, IN ORDER GIVEN, UNTIL   *
.*             ONE SUCCEEDS OR LIST IS EXHAUSTED.                     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XIOGNST            =0 ==> HAVEN'T GEND XIOBLOCK
         LCLA  &XDD                COUNTER FOR # DDNAMES
         LCLB  &XIO                OUTPUT=1,INPUT=0
         LCLC  &X                  PREFIX OF ALL LABELS
&XDD     SETA  N'&DDNAME           GET # OF DDNAMES TO BE TRIED
&XIO     SETB  ('&XOP' EQ 'OUTPUT')          SET FOR INPUT OR OUTPUT
&X       SETC  '&XLABEL'(3,4)      GET LABEL START
        TITLE  ' *** &XLABEL *** I/O ROUTINE'
&XLABEL  CSECT
         ENTRY &X.DCB
         USING XIOBLOCK,R14 .      NOTE POINTER TO CONTROL BLOCK
         USING *,R15 .             NOTE TEMPORARY ADDRESSIBILITY
         STM   R13,R5,&X.SAV1   .  SAVE REGS WHICH WILL BE USED
         CNOP  0,4 .               MAKE SURE ALIGNED ON FULLWORD
         BAL   R13,*+76 .          SET UP FAKE SAVE AREA PTR,BASE
         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER
         DS    18F .               FAKE SAVE AREA,FOR GET/PUT ETC
         DROP  R15 .               KILL OLD ADDRESSING
         SPACE 2
.XASA1   AIF   (&XIO).XOUT         SKIP IF OUTPUT
&X.EOFT  NOP   &X.ABD2  .          *** WILL BECOME A B AFTER EOF EXIT
.XOUT    ANOP
&X.TES1  NOP   &X.GO   .           *** WILL BE A BRANCH AFTER OPEN GOES
         LR    R5,R14              SAVE R14 AROUND CALL TO XXXXOPEN
         LA    1,&X.OPBK .         GET ADDRESS OF CONTROL TABLE
         L     15,&X.OPAD .        GET BRANCH ADDRESS
         BALR  14,15 .             CALL XXXXOPEN ROUTINE
         LR    R14,R5              RESTORE R14
&X.OPOK  MVI   &X.TES1+1,X'F0'  .  CHANGE NOP TO B-DONT OPEN AGAIN
&X.GO    LH    R4,&X.DCB+82 .      GET DCB LRECL FOR COMPARISON
         LH    R5,XIOLENG .        GET LENGTH FROM CONTROL BLOCK
         BCTR  R5,0 .              DECREMENT TO LENGTH-1
         CLR   R4,R5 .             COMPARE WITH LIMIT
         BH    *+8 .               SKIP IF WITHIN RANGE
         LR    R5,R4 .             MOVE DEFAULT VALUE OVER
         BCTR  R5,0 .              DECREMENT DEFAULT TO LENGTH-1
.XASB    SPACE 2
         L     R2,&X.SAV1+12 .     GET ADDRESS OF I/O AREA (FROM R0)
.*
*        THE FOLLOWING CODE IS USED TO CHECK FOR ADDRESS ILLEGAL      *
*        THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT**********
         L     R1,16 .             GET CVT POINTER FROM LOC 16
         LA    R0,1(R2,R5) .       GET ENDING ADDRESS OF I/O AREA
         C     R0,164(R1) .        COMPARE TO CVTMZ00-HGIHEST ADDRESS
         BNL   &X.ABD3   .         GO ABEND IF HIGHER
.*
         AIF   (&XIO).XOUT1        SKIP IF OUTPUT MODE
         GET   &X.DCB              OBTAIN @ BUFFER
         EX    R5,&X.MOV  .        MOVE REQUESTED NUMBER OF BYTES
         SR    R0,R0 .             SET CONDITION CODE=0, SHOW USER OK
         B     &X.RET  .           GO TO RETURN TO CALLER
&X.ABD2  WTO   ' &XLABEL ABEND 300 - ATTEMPT TO READ PAST END-OF-FILE',X
               ROUTCDE=11
         B     &X.ABD1  .          GO ABEND
&X.EOF   CLOSE &X.DCB
         LA    1,&X.DCB            POINT 1 TO DCB TO FREE BUFFER
         FREEPOOL (1)              FREE THE BUFFERS
         OI    *+1,1  .            SET CONDITON CODE TO 1
         MVI   &X.EOFT+1,X'F0'  .  CHANGE NOP TO B-NO MORE READS
         AGO   .XRET               HAVE RETURN CODE GENRATED
.*
.XOUT1   EX    R5,&X.MOV  .        MOVE NUMBER OF BYTES TO OUTPUT LINE
         PUT   &X.DCB,&X.BUF
         EX    R5,&X.MOV1  .       REBLANK OUTPUT LINE
.*
.XRET    ANOP
         SPACE 2
&X.RET   LM    R13,R5,&X.SAV1  .   RESTORE THE REGS WE CHANGED
         AIF   (NOT &XIO).XOUT2    SKIP SPM IF THIS WAS AN INPUT
         SPM   R14 .               RESTORE THE CONDITION CODE
.XOUT2   B     XIORETRN .          RETURN TO CALLING XIOBLOCK
&X.ABD3  WTO   ' &XLABEL ABEND 300-ILLEGAL ADDRESS-SEE REG 2',         X
               ROUTCDE=11
&X.ABD1  ABEND 300,DUMP
.*
         SPACE 2
&X.SAV1  DS    9F .                AREA TO PRESERVE REGS IN
&X.OPAD  DC    V(XXXXOPEN) .       ADDRESS OF SUPEROPEN ROUTINE
&X.OPBK  XOPENBLK &X.DCB,&XLABEL,&DDNAME,RECFM=&RECFM,LRECL=&LRECL,    #
               BLKSIZE=&BLKSIZE,BUFNO=&BUFNO,XOP=&XOP
.XNODD   AIF   (&XIO).XOUT3        SKIP IF OUTPUT
.*
&X.MOV   MVC   0(0,R2),0(R1) .     R1==> BUFFER, EXECUTE SUPPLIES LENGT
&X.DCB   DCB   DSORG=PS,MACRF=GL,EODAD=&X.EOF
         AGO   .XEXIT
.*
.XOUT3   ANOP
&X.BUF   DC    CL(&LRECL)' ' .     OUTPUT I/O BUFFER AREA
&X.BLNK  DC    CL(&LRECL)' ' .     FOR REBLANKING OUTPUT BUFFER
&X.MOV   MVC   &X.BUF(0),0(R2)  .  MOVE RIGHT NUMBER OF CHARS TO BUFFER
&X.MOV1  MVC   &X.BUF(0),&X.BLNK   EXECUTED MOVE TO REBLANK BUFFER
&X.DCB   DCB   DSORG=PS,MACRF=PM
.XEXIT   DROP  R13,R14 .           KILL LEFTOVER ADDRESSING
.*
         AIF   (&XIOGNST).XXEXIT   SKIP IF ALREADY GEND XIOBLOCK
&XIOGNST SETB  (1)                 SHOW WE'VE GENERATE XIOBLOCK
         EJECT
* * * * * XIOBLOCK - CONTROL BLOCK SET UP BY XREAD/XPRNT/XPNCH  * * * *
XIOBLOCK DSECT
         DS    V .                 @ I/O ROUTINE
         DS    3F                  AREA FOR REGS 15-0 TO BE SAVED
XIOLENG  DS    AL2 .               LENGTH OF RECORD, (CODES-FUTURE USEQ
XIORETRN LM    14,0,4(14)          RETURN CODE FOR RESTORING REGISTERS
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XIONR
         MACRO
&XLABEL  XIONR &XNAME,&XNUM,&XAREA,&XDEFT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIONR      INNER MACRO-$READ,$PNCH,$PRNT,$SORC           *
.*                                 JOHN R. MASHEY - FEB 1970 - V.5.0  *
.*       XIONR IS USED BY XIOPAK MACROS XREAD,XPRNT,XPNCH TO SET UP   *
.*       THE REQUIRED CODE FOR CALLING THEIR RESPECTIVE SUBROUTINES.  *
.*       *** ARGUMENTS ***                                            *
.*       XNAME     THE NAME OF THE I/O ROUTINE TO BE CALLED.          *
.*       XNUM      THE LENGTH OF XAREA TO BE PRINTED,PUNCHED,ETC.     *
.*       XAREA     THE AREA ON WHICH I/O OPERATION TO BE PERFORMED.   *
.*             MAY BE SPECIFIED BY (0) OR (R0).                       *
.*       XDEFT     DEFAULT VALUE OF XNUM TO BE USED, IF IT IS OMITTED *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
.*                                                                    *
.*       AS OF AUG 1972, XGET AND XPUT ALSO USE THIS MACRO.           *
.*                                     RICHARD FOWLER                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'&XAREA EQ 'O').XERR1       PRODUCE MNOTE
&XLABEL  STM   14,0,XX&SYSNDX.R+4 .    SAVE REGS WHICH WILL BE CHANGED
         AIF   (T'&XNUM EQ 'O').XN1    SKIP NEXT CHECK IF OMITTED
         AIF   ('&XNUM'(1,1) NE '(' OR '&XNUM'(K'&XNUM,1) NE ')').XN1
         STH   &XNUM,XX&SYSNDX.R+16 .       STORE LENGTH
.XN1     AIF   ('&XAREA' EQ '(0)' OR '&XAREA' EQ '(R0)').XNOLA
.XN2     LA    0,&XAREA
.XNOLA   L     15,XX&SYSNDX.R  .   GET BRANCH ADDRESS
         CNOP  2,4  .              ADJUST FOR RIGHT ALIGNEMNT
         BALR  14,15 .             CALL ROUTINE, R14==> CONTROL BLOCK
XX&SYSNDX.R DC V(&XNAME)  .        ROUTINE ADDRESS
         DS    3F .                SAVE SPACE FOR REGS 14-0
         AIF   ('&XNUM' EQ '').XDFT         SKIP IF DEFAULT SHOULD BE
         DC    AL2(&XNUM) .        LENGTH OF AREA
         AGO   .XDS                SKIP
.XDFT    DC    AL2(&XDEFT) .       DEFAULT LENGTH USED
.XDS     LM    14,0,4(14) .        RESTORE REGS. CON CODE ALREADY DONE
         MEXIT
.XERR1   MNOTE 0,'**XIONR- AREA ADDRESS OMITTED-GENERATION CANCELLED'
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XLIMD
         MACRO
&XLABEL  XLIMD &ADDR,&LENGTH
.*--> MACRO: XLIMD      LIMIT DUMP-ASSIST COMPATIBILITY MACRO . . . . .
.*.      MACRO PROVIDED ONLY FOR RUNNING ASSIST DECKS UNDER OS/360.   .
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
&XLABEL  DS    0H .                XLIMD EXPANSION- NOTHING
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XLOOK
         MACRO
         XLOOK &ARG1,&ARGL
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XLOOK      FIND POSITION OF ELEMENT IN LIST.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO TO FIND AND RETURN POSTION OF ARGUMENT IN A SUBLIST.   *
.*       &ARG1 ARGUMENT TO BE SEARCHED FOR                            *
.*       &ARGL LIST OF ARGUMENTS FOR &ARG1 TO BE CHECKED FOR IN       *
.*       &XXLOOK   THE FIRST POSITION IN &ARGL IN WHICH &ARG1 IS      *
.*       FOUND, IF ANY.  IF &ARG1 IS NOT IN &ARGL, &XXLOOK = 0.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             FOR RETURN OF INDEX VALUE
&XXLOOK  SETA  1                   INITIALIZE THE COUNTER
.XLA     AIF   (&XXLOOK GT N'&ARGL).XLB     IF GT,QUIT,NOT FOUND
         AIF   ('&ARG1' EQ '&ARGL(&XXLOOK)').XXEXIT   IF FOUND,RETURN
&XXLOOK  SETA  &XXLOOK+1           INCREMENT COUNTER
         AGO   .XLA                GO BACK FOR NEXT CHECK
.XLB     ANOP
&XXLOOK  SETA  0                   NOT FOUND, SET TO 0 TO SHOW THIS
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XMUSE
         MACRO
         XMUSE &BR,&AD
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XMUSE      BASE REGISTER SETUP MACRO FOR XSAVE           *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       THIS MACRO IS CALLED BY XSAVE TO HANDLE BR AND AD OPERANDS,  *
.*       AND PRODUCE APPROPRIATE USINGS.  &BR AND &AD ARE FROM XSAVE. *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  &I,&N               LOCAL COUNTERS
         LCLC  &B(4),&V            BASE REGS, USING NAME
&N       SETA  N'&BR               GET NUMBER WHERE HANDY
&V       SETC  '*'                 NORMAL USE
         AIF   (&N LE 4).XNOKA     MAKE SURE NOT TOO MANY BASES
&N       SETA  4                   IDIOT USER HAD >4 BASES, IGNORE EXTR
         MNOTE 4,'**XMUSE- MORE THAN 4 BASE REGS-EXTRAS IGNORED'
.XNOKA   AIF   ('&AD' EQ '').X1LOOP         SKIP IF NORMAL SITUATION
.*             USED IF AD PARAMATER WAS SPECIFIED IN XSAVE MACRO.     *
         CNOP 0,4
         B     *+8 .               SKIP AROUND ADDRESS CONSTANT
         DC    A(&AD)       .      ADDRESS CONSTANT FOR AD=PARAMETER
         L     &BR(1),*-4 .        LOAD ADCON INTO RIGHT REGISTER
&V       SETC  '&AD'               CHANGE NAME FOR USING 1ST OPERND
.*             NORMAL SECTION OF CODE FOR GENERATING USING.           *
.X1LOOP  ANOP
&I       SETA  &I+1      INCREMENT COUNTER TO BASE REG
&B(&I)   SETC  ',&BR(&I)'          GET I'TH BASE REGISTER
         AIF   (&I LT &N).X1LOOP   CONTINUE UNTIL ALL BASWE REGS DONE
         DROP  15 .                CLEAN UP USING SITUATION
         USING &V&B(1)&B(2)&B(3)&B(4)
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XOPENBLK
         MACRO
&LABEL   XOPENBLK &DCB,&XNAME,&DDNAME,&RECFM=F,&LRECL=,&BLKSIZE=,      #
               &BUFNO=1,&XOP=OUTPUT,&ABEND=YES,&WARN=NO
.*--> MACRO: XOPENBLK   GENERATES 1 CONTROL BLOCK FOR XXXXOPEN  . . . .
.*             SEE THE XOPENBLK DSECT.                                .
.*       *** ARGUMENTS ***                                            .
.*       &DCB                      NAME OF DCB TO BE OPENED           .
.*       &XNAME                    NAME OF CALLING ROUTINE            .
.*       &DDNAME                   LIST OF 1 OR MORE DDNAMES, IN ORDER.
.*                                 DESIRED TO BE TRIED.               .
.*             NEXT 4 ARGS GIVE DEFAULT VALUES USED TO FILL DCB       .
.*             IF NEEDED DURING DCB EXIT PROCESSING.                  .
.*       &RECFM=, &LRECL=, &BLKSIZE=, &BUFNO=     SAME NAMES AS DCB   .
.*       &XOP=                     DIRECTION TO OPEN:  OUTPUT OR INPUT.
.*       &ABEND=                   ABEND IF CAN'T OPEN: YES OR NO     .
.*       &WARN=                    WARNING IF CAN'T OPEN FIRST CHOICE .
.*                                 YES  OR  NO                        .
.*. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         LCLA  &I                  COUNTER VARIABEL
         LCLB  &B0,&B3,&B5         FOR RECFM BITS, XOPFLAG1 BITS
&LABEL   OPEN  (&DCB,&XOP),MF=L .  LIST TO GEN CONTROL ELEMENT
         DC    AL2(&LRECL,&BLKSIZE,&BUFNO)   LRECL,BLKSIZE,BUFNO
.*
&B0      SETB  ('&RECFM'(1,1) EQ 'F')  SHOULD BE SET
&B3      SETB  ('&RECFM.X'(2,1) EQ 'B')          BLOCKED OR NOT
&B5      SETB  ('&RECFM'(K'&RECFM,1) EQ 'A')     ASA CARRIAGE CONTROLS
         DC    B'&B0.00&B3.0&B5.00' .       RECFM BYTE
.*
&B0      SETB  ('&ABEND' EQ 'YES') DOES HE WANT TO ABEND IF NO OPEN
&B3      SETB  ('&WARN' EQ 'YES')  DOES HE WANT WARN IF NOT FIRST DDNA
         DC    B'&B3&B0',CL8'&XNAME ' .  XOP-FLAG1,XNAME
.*
&I       SETA  8*(N'&DDNAME-1)     3 DDNAMES, CONVERT TO BXLE LMT
         DC    H'&I' .             BXLE OFFSET FOR DD SEARCH
&I       SETA  1                   RE INIT FOR LOOP TO GEN
.XOPA    DC    CL8'&DDNAME(&I)'
&I       SETA  &I+1                INCREMENT TO NEXT ONE
         AIF   (&I LE N'&DDNAME).XOPA       LOOP UNTIL ALL DDNAMES GEND
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XPNCH
         MACRO
&XLABEL  XPNCH &XAREA,&XNUM
.*--> MACRO: XPNCH      PUNCH CARD MACRO  . . . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO FOR EASY PUNCHING OF UP TO 80 BYTES OF XAREA. MACRO    *
.*       GENERATION IS CONTROLLED BY &XPNCHST.                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XPNCHST            STATUS VARIABLE- 0=ON, 1=OFF
         AIF   (&XPNCHST).XNOGEN   SKIP GENRATION IF NOT WANTED
&XLABEL  XIONR XXXXPNCH,&XNUM,&XAREA,80
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR A CANCELLED  XPNCH
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XPRNT
         MACRO
&XLABEL  XPRNT &XAREA,&XNUM
.*--> MACRO: XPRNT      PRINT LINE MACRO  . . . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO FOR EASY PRINTING OF UP TO 133 CHARACTERS OF XAREA,    *
.*       AS SPECIFIED BY XNUM.  FIRST CHARACTER IS USED AS CARRIAGE   *
.*       CONTROL CHARACTER.  GENERATION IS CONTROLLED BY &XPRNTST.    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XPRNTST            GENERATION STATUS 0=YES, 1=NO
         AIF   (&XPRNTST).XNOGEN   SKIP GENERATION IF STATUS=OFF
&XLABEL  XIONR XXXXPRNT,&XNUM,&XAREA,133
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XPRNT
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XPUT
         MACRO
&XLABEL  XPUT  &XAREA,&XNUM
.*--> MACRO: XPUT           PUT A RECORD ONTO FILE &DDNAME . . . . .  *
.*                                 RICHARD FOWLER AUG 1972 V.5.0      *
.*       MACRO FOR EASY PRINTING ONTO ANY DD FILE RECORD LENGTH=&XNUM *
.*       IF PRINT FILE, THE FIRST CHARACTER IS USED AS CARRIAGE CONTROL
.*       GENERATION CONTROLLED BY &XPUST                              *
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
         GBLB  &XPUTST             GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XPUTST).XNOGEN    IF SHOULDN'T GENERATE, SKIP CALL
&XLABEL  XIONR XXXXPUT,&XNUM,&XAREA,133
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H .                LABEL FOR CANCELLED XPUT
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XREAD
         MACRO
&XLABEL  XREAD &XAREA,&XNUM
.*--> MACRO: XREAD      READ CARD MACRO . . . . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO FOR EASY CARD READING-READS UP TO 80 CHARACTERS INTO   *
.*       XAREA OPERAND. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON  *
.*       END OF FILE.  GENERATION CONTROLLED BY &XREADST.             *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XREADST            GENERATION STATUS- 0=YES, 1=NO
         AIF   (&XREADST).XNOGEN   IF SHOULDN'T GENRATE-SKIP CALL
&XLABEL  XIONR XXXXREAD,&XNUM,&XAREA,80
         MEXIT
.XNOGEN  AIF   (T'&XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED
&XLABEL DS     0H .                LABEL FOR CANCELLED XREAD
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XRETURN
         MACRO
&LABEL   XRETURN &RGS=(14-12),&SA=,&RC=,&RP=,&T=,&TR=*,&REEN=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XRETURN    GENERAL RETURN MACRO, OS LINKAGE              *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED RETURN MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN   *
.*       FOR EXPLANATION AND USE OF OPERANDS.                         *
.*       USES MACROS: FREEMAIN,XCHAR,XSRNR                            *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XRETUST            =0 TRACE GENERATION OK, =1 NO TRACE
         GBLC  &XSAVE,&XXCHAR      STD SAVE AREA NAME, XCHAR VARIABLE
         LCLA  &I                  LOCAL COUNTER
         LCLB  &RCA,&RCB           FOR CONTROL OF RETURN CODE GENER
.*                                                                    *
.*       GENERATE LABEL IF THERE IS ONE, GENERATE TRACE CODE IF IT    *
.*       IF DESIRED, AND SET UP LCLB VARIABLES TO DESCRIBE RETURN     *
.*       CODE CONDITIONS. GENERATE LR IF NEEDED FOR RC OPTION.        *
.*                                                                    *
         SPACE 1
         AIF   (T'&LABEL EQ 'O').XNOLB       SKIP IF NO LABEL USED
&LABEL   DS    0H .                DEFINE LABEL
.XNOLB   AIF   ('&TR' EQ 'NO' OR &XRETUST).XNORT       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,EXITED   GET TRACE GENERATED
.XNORT   ANOP
&RCA     SETB  (T'&RC EQ 'O')      TRUE IF WHOLE THING OMITTED
&RCB     SETB  (1)                 SET THIS WAY FOR NEXT TEST
         AIF   (&RCA).XNRCB        SKIP IMMEDIATELY IF OMITTED
&RCB     SETB  ('&RC'(1,1) NE '(' OR '&RC'(K'&RC,1) NE ')')  NOT RG TYP
         AIF   (&RCB).XNRCB       SKIP IF NOT REGISTER TYPE
         XCHAR &RC,3               GET LAST 3 CHARS
         AIF   ('&XXCHAR' EQ '15)').XNRCB    SKIP IF ALREADY IN 15
         LR    15,&RC .            LOAD RETURN CODE FROM DESIRED REG
.XNRCB   AIF   (T'&REEN EQ 'O').XNORM        SKIP IF NOT REENTRANT
.*                                                                    *
.*       REENTRANT RETURN CODE GENERATION - OBTAIN ADDRESS AND LENGTH *
.*       OF AREA FROM WHERE XSAVE PUT THEM,DO FREEMAIN,FIXUP REGS.    *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XRETUST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XRETURN- TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    L     13,4(13) .          GET OLD SA POINTER BACK
         STM   15,1,16(13) .       SAVE REGS FROM FREEMAIN CRUNCHING
         L     1,8(13) .           GET ADDRESS OF AREA BACK
*        FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         FREEMAIN R,LV=8*((&REEN+79)/8),A=(1)          FREE STORAGE
         LM    15,1,16(13) .       RESTORE THE REGS
         AGO   .XNORM1             GO TO PROCESS REGISTER RESTORATION
.XNORM   AIF   ('&SA' EQ 'NO').XNORM1        SKIP RESTORATION IF UNUSED
.*                                                                    *
.*       REGISTER RESTORATION CODE - RESTORE REGS FROM CALLER'S       *
.*       SAVE AREA,DEPENDING ON RETURN CODE AND FUNCTION OPTIONS.     *
.*                                                                    *
         L     13,4(13) .          RESTORE PREVIOUS SAVE AREA POINT
.XNORM1  AIF   ('&RGS' EQ 'NO').XNORM2A     SKIP IF NO REGS NEEDED
         AIF   ('&RGS' NE '(14-12)' OR NOT &RCB).XNORM2
         LM    14,12,12(13) .      STANDARD REGISTER RESTORATION
         AGO   .XNORM2A            CONTINUE
.XNORM2  ANOP
&I       SETA  &I+1                INCREMENT COUNTER
         XSRNR L,&RGS(&I),&RCB     HAVE RESTORE CODE GENRATED
         AIF   (&I LT N'&RGS).XNORM2        LOOP UNTIL DONE
.*                                                                    *
.*       RETURN CODE(15) AND RETURN PAST(14) CODE GENERATION.         *
.*                                                                    *
.XNORM2A AIF   (&RCA OR NOT &RCB).XNORM3    SKIP IF NOT LA TYPE RC=
         LA    15,&RC .            PUT RETURN CODE IN 15
.XNORM3  AIF   ('&T' NE '*').XNORM4          SEE IF MVI WANTED
         MVI   12(13),X'FF' .      SHOW WE HAVE RETURNED
.XNORM4  AIF   (T'&RP EQ 'O').XNORP          SKIP IF RP NOT USED
         B     &RP.(14) .          RETURN GIVEN NUMBER PAST 14
         AGO   .XNORM5
.XNORP   BR    14 .                RETURN NORMALLY TO CALLER
.*                                                                    *
.*       SAVE AREA GENERATION - IF A SAVE AREA SHOULD BE CREATED,     *
.*       USE EITHER ONE SPECIFIED BY MACRO,OR ELSE STANDARD ONE.      *
.*                                                                    *
.XNORM5  AIF   (T'&SA EQ 'O' OR '&SA' EQ 'NO').XEXIT   SKIP IF NO SAV5
         AIF   ('&SA' EQ '*').XSASTD         IF *,USE STANDARD SAVE
&SA      DC    18F'0' .            SAVE AREA,NAMED BY MACRO
         AGO   .XEXIT
.XSASTD  ANOP
&XSAVE   DC    18F'0' .            SAVE AREA,USING GENERATED NAME
.XEXIT   SPACE 1
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSAVE
         MACRO
&LABEL   XSAVE &RGS=(14-12),&BR=12,&SA=*,&ID=*,&TR=*,&REEN=,&OPT=,&AD=
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSAVE      EXTENDED SAVE MACRO - OS LINKAGE.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED SAVE MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN     *
.*       FOR DESCRIPTION OF ARGUMENTS FOR THIS MACRO                  *
.*       USES MACROS: GETMAIN,XCHAR,XIDENT,XLOOK,XMUSE,XSRNT,XSRTR    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             RETURN VARIABLE FROM XLOOK MACRO
         GBLB  &XSAVEST            =0 TRACE GEN OK, =1 NO TRACE DONE
         GBLC  &XSAVE,&XCSECT,&XXCHAR  STD NAME,CSECT NAME,XCHAR VAR
         LCLA  &I                  LOCAL COUNTER
         LCLB &XNSECT              FLAG FOR NEW CSECT
         LCLC  &B1,&BT             1ST BASE,LAST 2 CHARS OF 1ST BASE
&B1      SETC  '&BR(1)'            GET FIRST OR ONLY BASE IN EASIER NAM
         XCHAR &B1,2               GET LAST 2 CHARS OF BASE REG
&BT      SETC  '&XXCHAR'           GET LAST 2 CHARACTERS
&XNSECT  SETB  ('&SYSECT' NE '&XCSECT')      NOTE IF NEW CSECT NEEDED
&XCSECT  SETC  '&SYSECT'           SET TO SYSECT, FOR NORMAL USE
.*                                                                    *
.*       CHECK OPT FIELD - GENERATE TITLE AND/OR ENTRY OR CSECT       *
.*       STATEMENTS, DEPENDING ON CONTENTS OF OPT FIELD, IF USED.     *
.*                                                                    *
         AIF   (T'&OPT EQ 'O').XNOPS         SKIP IF OPT UNUSED
         XLOOK TITLE,&OPT           WAS TITLE OPTION USED
         AIF   (&XXLOOK EQ 0).XNTITL         SKIP IF TITLE NOT USED
         AIF   (N'&OPT EQ 1).XNOPS SKIP IF TITLE ONLY
        TITLE  '*** &LABEL ***'
.XNTITL  XLOOK ENTRY,&OPT           WAS ENTRY USED
         AIF   (&XXLOOK EQ 0).XTRCS         SKIP IF NOT USED
         AIF   ('&LABEL' EQ '').XENTE        SKIP TO ERR IF NO LABEL
         ENTRY &LABEL  .            NOTE XSAVE ENTRY OPTION
         AGO   .XNOPS
.XENTE   MNOTE 4,'**XSAVE- OPT=ENTRY USED WITHOUT LABEL-OPTION IGNORED'
         AGO   .XNOPS
.XTRCS   XLOOK CSECT,&OPT           CHECK FOR CSECT OPTION
         AIF   (&XXLOOK EQ 0).XTRCS1        SKIP IF OPTION NOT THERE
&LABEL   CSECT
&XCSECT  SETC  '&LABEL'            SET THIS TO SHOW NEW CSECT
&XNSECT  SETB  (1)                  NOTE THAT NEW CSECT IS NEEDED
         AGO   .XENT1               SKIP OVER &LABEL DEFN
.XTRCS1  MNOTE 0,'**XSAVE- UNKNOWN OPT=&OPT- IGNORED'
.*                                                                    *
.*       CREATE STATMENT LABEL IF ANY. IF IDENTIFIER REQUESTED,USE    *
.*       SPECIFIED IDENTIFIER,STATEMENT LABEL,OR CSECT NAME IN XIDENT *
.*       TO GENERATE CORRECT IDENTIFIER WITH BRANCH AROUND IT.        *
.*                                                                    *
.XNOPS   SPACE 2
&LABEL   DS    0H .                DEFINE LABEL,MAKE SUREE ALIGNED
.XENT1   USING *,15 .              FOR TEMPORARY ADDRESSIBILITY
         AIF   ('&SA' EQ '*' OR '&SA' EQ 'NO').XCHKS1 SKIP IF NO CHANGE
&XSAVE   SETC  '&SA'                EXPLICIT NEW SAVE AREA NAME
         AGO   .XSAOK
.XCHKS1  AIF   ('&XSAVE' NE '').XCHKS2       SKIP IF NOT NULL
&XSAVE   SETC  '$PR#&SYSNDX'        SET UP DEFAULT SAVE AREA NAME
         AGO   .XSAOK
.XCHKS2  AIF   (NOT &XNSECT).XSAOK SKIP IF NEW SAVE NOT NEEDED
&XSAVE   SETC  '&XCSECT'(1,3).'#&SYSNDX'     DEFAULT SAVE AREA NAME
.*                                                                    *
.XSAOK   AIF   ('&ID' EQ 'NO').XID3 SKIP IF NO ID WANTED
         XIDENT &ID,&LABEL,&XCSECT,$PRIVATE CALL TO SET UP IDENT
.*                                                                    *
.*       IF TR OPTION IN EFFECT, CALL XSRTR TO GENERATE RIGHT CODE,   *
.*       THEN HAVE XSRNR GENERATE CODE TO SAVE RANGES OF REGISTERS    *
.*                                                                    *
.XID3    AIF   (&XSAVEST OR '&TR' EQ 'NO').XNOTR       SKIP IF NO TRACE
         XSRTR &TR,&LABEL,ENTERED  GET TRACE GENERATED
.XNOTR   AIF   ('&RGS' NE '(14-12)').XSRCAL SKIP IF NOT STANDARD
         STM   14,12,12(13) .      SAVE STANDARD REGISTER SET
         AGO   .XCHK13
.XSRCAL  AIF   ('&RGS' EQ 'NO').XCHK13       SKIP IF NO REGS SAVED
&I       SETA  1                   INITIALIZE COUNTER
.XSETUP  XSRNR ST,&RGS(&I)         CALL XSRNR WITH EACH REG SET
&I       SETA  &I+1                INCREMENT TO NEXT REGS SET
         AIF   (&I LE N'&RGS).XSETUP         CONTINUE PROCESSING RGS
.XCHK13  AIF   ('&BT' NE '13').XNORM1       NOT REG 13,DO NORMALLY
.*                                                                    *
.*       REGISTER 13 DOUBLE USAGE - THIS SECTION GENERATES CODE TO    *
.*       USE REGISTER 13 BOTH AS A BASE AND AS THE SAVE AREA POINTER. *
.*                                                                    *
         AIF   (T'&AD EQ 'O').XU2  SKIP TO NORMAL IF &AD OMITTED
         LR    14,13 .             SAVE @ OLD SAVE AREA BEFORE SETTING
         XMUSE &BR,&AD             HAVE ADCON SET UP
         ST    13,8(14) .          SAVE NEW POINTER INTO OLD SAVEAREA
         ST    14,4(13) .          SAVE OLD POINTER INTO NEW AREA
         AGO   .XEND1              GO FINISH UP
.XU2     CNOP  0,4
         ST    13,&XSAVE+4 .       SAVE OLD SA POINTER INTO NEW AREA
         BAL   13,&XSAVE+72 .      SET UP 13, BRANCH AROUND SA
         XMUSE &BR                 SET UP WHATEVER USING REQUIRED
&XSAVE   DC    18F'0'  .           SAVE AÞEA
.XU3     L     15,&XSAVE+4 .       GET OLD SA POINTER BACK TO SET LINKS
         ST    13,8(15) .          STORE NEW POINTER IN OLD AREA
         AGO   .XEND1              CHECK NUMBER OF BR'S,GET LA'S SET UP
.*                                                                    *
.XNORM1  AIF   (T'&REEN EQ 'O').XNORM2       SKIP OVER REENTRANT
.*                                                                    *
.*       REENTRANT ENTRY CODE GENERATION - THIS GENERATES CODE TO     *
.*       ACQUIRE SPACE FOR SAVEAREA(72 BYTES) + AS MUCH MORE SPACE    *
.*       AS IS SPECIFIED IN REEN PARAMATER, IF USED.                  *
.*                                                                    *
         AIF   ('&TR' EQ 'NO' OR &XSAVEST).XGOK        MAKE SURE REENT
         MNOTE 0,'**XSAVE- USE OF TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    ANOP
*        GETMAIN R,LV=8*((&REEN+79)/8)       GET SPACE ROUNDED TO D
         GETMAIN R,LV=8*((&REEN+79)/8) .GET CORE ROUNDED TO DBLWRD
         ST    13,4(1) .           STORE OLD POINTER IN NEW AREA
         ST    1,8(13) .           STORE (EW POINTER IN OLD AREA
         LR    &B1,1 .             SAVE VALUE OF NEW SAVE POINTER
         LM    0,1,20(13) .        RESTORE PREVIOUS VALUES OF REGS
         LR    13,&B1 .            POINT 13 TO NEW SAVE AREA
         AGO   .XNEWBS             GO GENERATE NEW BALR,USING
.*                                                                    *
.*       NORMAL,NON-REENTRANT ENTRY CODE SECTION.                     *
.*                                                                    *
.XNORM2  AIF   ('&SA' EQ 'NO').XNEWBS        SKIP IF NO SAVE AREA
         ST    13,&XSAVE+4 .       SAVE OLD POINTER IN NEW AREA
         AIF   ('&BT' NE '15').XSN15         SKIP IF NOT 15
         LA    13,&XSAVE .         GET ADDRESS OF NEW SAVE AREA
         L     &B1,&XSAVE+4 .      GET OLD SAVE POINTER BACK
         AGO   .XSOLD              GO SAVE NEW POINTER
.XSN15   LR    &B1,13 .            MOVE OLD POINTER OVER
         LA    13,&XSAVE    .      ADDRES> OF NEW SAVE AREA
.XSOLD   ST    13,8(&B1) .         SAVE NEW POINTER IN OLD AREA
.*             SET UP BALR, LA'S IF REQUIRED, AND USING STATEMENT.    *
.XNEWBS  AIF   ('&BT' NE '15' OR N'&BR GT 1).XSET2  SKIP IF 15
         AIF   ('&REEN' EQ '' AND '&SA' EQ 'NO' AND '&AD' EQ '').XEND2
.XSET2   AIF   (T'&AD NE 'O').XSET3          SKIP BALR IF ADCON USED
         BALR  &B1,0 .             SET UP NEW BASE REGISTER
.XSET3   XMUSE &BR,&AD             SET UP USINGS, ADCON IF NEEDED
.XEND1   AIF   (N'&BR EQ 1).XEND2  IF ONLY 1 BASE,DON'T CALL XMUSE
&I       SETA  2                    INITIALIZE
.XA2A    LA    &BR(&I),4095 .       LOAD IN ADDRESS
         LA    &BR(&I),1(&BR(&I),&BR(&I-1))  .   SET USING VALUES
&I       SETA  &I+1                 INCREMENT TO NEXT BASE
         AIF   (&I LE N'&BR AND &I LE 4).XA2A         LOOP FOR # BASES
.XEND2   SPACE 1
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSET
         MACRO
&XLABEL  XSET  &XSNAP=,&XSTOP=,&XREAD=,&XPRNT=,&XPNCH=,&XTIME=,        X
               &XSAVE=,&XRETURN=
.*--> MACRO: XSET       CONTROL XMACRO GENERATION . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSET IS USED TO CONTROL GENERATION OF X-MACROS OF THE NAMES  *
.*       USED AS OPERANDS. NAME=OFF CANCELLS THE GIVEN MACRO UNTIL    *
.*       NAME=ON IS CODED.  ALL NAMES ARE ON UNLESS CANCELLED. ALL    *
.*       CODE MAY BE ELIMINATED FOR ANY MACROS EXCEPT XSAVE/XRETURN,  *
.*       WHOSE TRACE CODE ONLY IS ELIMINATED.                         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XSNAPST,&XSTOPST,&XSAVEST,&XRETUST     STATUS VARS
         GBLB  &XREADST,&XPRNTST,&XPNCHST,&XTIMEST
         AIF   (T'&XLABEL EQ 'O').XNOLB  GEN LABEL ONLY IF NEEDED
&XLABEL  DS    0H  .               LABEL APPEARED ON AN XSET
.XNOLB   ANOP
&XSNAPST SETB (('&XSNAP' EQ 'OFF') OR ((T'&XSNAP EQ 'O') AND &XSNAPST))
&XSTOPST SETB (('&XSTOP' EQ 'OFF') OR ((T'&XSTOP EQ 'O') AND &XSTOPST))
&XREADST SETB (('&XREAD' EQ 'OFF') OR ((T'&XREAD EQ 'O') AND &XREADST))
&XPRNTST SETB (('&XPRNT' EQ 'OFF') OR ((T'&XPRNT EQ 'O') AND &XPRNTST))
&XPNCHST SETB (('&XPNCH' EQ 'OFF') OR ((T'&XPNCH EQ 'O') AND &XPNCHST))
&XTIMEST SETB (('&XTIME' EQ 'OFF') OR ((T'&XTIME EQ 'O') AND &XTIMEST))
&XSAVEST SETB (('&XSAVE' EQ 'OFF') OR ((T'&XSAVE EQ 'O') AND &XSAVEST))
&XRETUST SETB  (('&XRETURN' EQ 'OFF') OR ((T'&XRETURN EQ 'O') AND      X
               &XRETUST))
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSNAP
         MACRO
&XLABEL  XSNAP &T=PR,&LABEL=,&STORAGE=,&IF=
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSNAP      EXTENDED SNAP MACRO-DEBUGGING-DUMPING.        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSNAP     IS USED FOR STORING,PRINTING OF REGISTERS AND ANY  *
.*       OTHER ADDRESSIBLE AREAS. XSNAP HARMS NO REGISTERS,CAN BE USED*
.*       IN ANY NUMBER OF CSECTS IN 1 ASSEMBLY,AND PRINTS REGISTERS   *
.*       EXACTLY AS THEY ARE WHEN THE XSNAP IS CALLED.  XSNAP         *
.*       ACTION MAY BE MADE CONDITIONAL EITHER AT ASSEMBLY TIME OR    *
.*       DURING EXECUTE TIME.  SEE WRITEUP FOR OPERAND DESCRIPTION.   *
.*       USES MACROS: XLOOK                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             XLOOK RETURN VALUE
         GBLB  &XSNAPST            GENERATION STATUS,ON=0,OFF=1
         LCLA  &I,&K,&L,&N         LOCAL COUNTERS
         LCLB  &XP,&XF             PRINT REGS AND PRINT FLOATING REGS
         LCLC  &NAM,&INST,&A(5)
.*                                                                    *
.*       CHECK FOR XSNAPS BEING CANCELLED. CREATE LABEL IF NEEDED.    *
.*                                                                    *
         AIF   (NOT &XSNAPST).XGOGEN   GENERATE IF STATUS=ON
         AIF   (T'&XLABEL EQ 'O').XXEXIT    SKIP IF NOTHING TO GEN
&XLABEL  DS    0H  .               LABEL USED ON NULLIFIED XSNAP
         MEXIT
.XGOGEN  SPACE 1
&NAM     SETC  'XX&SYSNDX'         SET UP MOST OF NAME FOR LABELS
&N       SETA  (N'&STORAGE/2)*2    GET ROUNDED NUMBER OF OPERANDS
&XLABEL  STM   0,15,&NAM.B  .      SAVE ALL REGISTERS
.*                                                                    *
.*       IF OPTION - IF IF OPTION IS USED AND HAS CORRECT ARGUMENTS,  *
.*       GENERATE A CLI, C, OR CR INSTRUCTION TO PERFORM APPROPRIATE  *
.*       TEST,DEPENDING ON THE KIND OF IF ARGUMENTS . NEGATE THE      *
.*       CONDITION AND CREATE THE RIGHT EXTENDED MNEMONIC BRANCH      *
.*       SO THAT THE XSNAP WILL BE SKIPPED IF THE STATED CONDTION IS  *
.*       NOT MET.  GENERATE USER'S OWN OPCODE IF HE SUPPLIED ONE.     *
.*                                                                    *
         AIF   (T'&IF EQ 'O').XNOIF          SKIP IF IF NOT REQUESTED
         AIF   (N'&IF GE 3).XOKIF  SKIP IF ENOUGH ARGUMENTS
         MNOTE 0,'**XSNAP- IF=&IF:IGNORED, LACKS REQUIRED 3-4 OPERANDS'
         AGO   .XNOIF              CANCEL IF OPTION
.XOKIF   XLOOK &IF(2),(H,L,E,O,P,M,Z,NH,NL,NE,NO,NP,NM,NZ)
         AIF   (&XXLOOK GT 0).XOKIF1        SKIP IF OK RELATION
         MNOTE 0,'**XSNAP- IF=&IF(2) UNKNOWN-CANCELLED'
         AGO   .XNOIF              SKIP GENERATION OF THIS OPTION
.XOKIF1  ANOP
&INST    SETC  '&IF(4)'            GET INSTRUCTION
         AIF   (N'&IF EQ 4).X      IF OPCODE SUPPLIED,SKIP CHECKING
&INST    SETC  'CLI'               MAKE TENTATIVE INSTRUCTION SETUP
         AIF   ('&IF(1)'(1,1) NE '(' OR '&IF(1)'(K'&IF(1),1) NE ')').X
&INST    SETC  'C'                 PROBABLY WANTS RX TYPE
         AIF   ('&IF(3)'(1,1) NE '(' OR '&IF(3)'(K'&IF(3),1) NE ')').X
&INST    SETC  'CR'                2 REGS-USER WANTS RR TYPE
.X       ANOP
         &INST &IF(1),&IF(3) .     TEST
&INST    SETC  'BN&IF(2)'          NEGATE COND, HOPE FOR 1 OF 1ST SET
         AIF   (&XXLOOK LE 7).XOKIF2        SKIP IF NOW SET UP RIGHT
&INST    SETC  'B'.'&IF(2)'(2,2)   REMOVE N FROM COND
.XOKIF2  &INST &NAM.C
.*                                                                    *
.*             CREATE BRANCH AROUND THE SAVE AREA, FLAGS, ETC.        *
.*                                                                    *
.XNOIF   XLOOK &T(1),(PR,PRINT,FL,FLOAT,NO,NOREGS,ST,STORE)
&I       SETA  72+4*&N             LENGTH FOR T=PRINT,NOREGS
         AIF   (&XXLOOK LE 6).XBRNCH        SKIP IF ILLEGAL, OR PR,NO
&I       SETA  68                  LENGTH FOR T=STORE
.XBRNCH  B     &NAM.B+&I  .        BRANCH AROUND CONSTANTS
.*                                                                    *
.*       CREATE FRONT BRACKET CHARACTER STRING FOR REGISTER AREA      *
.*                                                                    *
         DS    0F  .               ALIGN LABEL ON FULLWORD
&L       SETA  8                   SET &L FOR NO LABEL= LENGTH
         AIF   (T'&LABEL EQ 'O').XNOLAB      IF NO LABEL,SKIP GENERATIO
&L       SETA  ((K'&LABEL+1)/4)*4  ROUND LENGTH UP TO FULLWORD
         AIF   (&L LE 92).XLAB1    SKIP IF LABEL SMALL ENOUGH
         MNOTE 0,'**XSNAP- LABEL= OPERAND TRUNCATED TO 92 CHARACTERS'
&L       SETA  92                  TRUNCATE
.XLAB1   DC    CL&L&LABEL
         AGO   .XCHK1              SKIP GENRATION OF 1ST DELIMETER
.XNOLAB  DC    CL8'&NAM.B'   .     FRONT BRACKET FOR REGISTER AREA
.*                                                                    *
.*             CREATE REGISTER AREA, BRACKETS, FLAG VALUES, AS NEEDED *
.XCHK1   AIF   (&XXLOOK LT 7).XPRINT        SKIP IF PRINTED OUTPUT
&NAM.B   DC    16F'-1',4C'X' .     REGISTER SAVE AREA, BRACKET X'S
         AGO   .XIFLB              SKIP TO CHECK FOR IF LABEL
.XPRINT  AIF   (&XXLOOK GT 0).XPRINT1       SKIP IF LEGAL T=
         MNOTE 0,'**XSNAP- UNKNOWN T=&T: T=PR ASSUMED'
.XPRINT1 ANOP
&XP      SETB  (&XXLOOK LT 5)      SET TO 1 IF GP REGS NEEDED
&XF      SETB  (&XXLOOK GT 2 AND &XP)       SET TO 1 IF T=FL OR T=FLOAT
&XF      SETB  (&XF OR '&T(2)' EQ 'FL' OR '&T(2)' EQ 'FLOAT')
&NAM.B   DC    16F'-1',B'&T(3)00&XF&XP',AL1(0,&L,&N/2),V(XXXXSNAP)
.*                                                                    *
.*       GENERATE ADDRESS LIST FOR STORAGE=, WITH EITHER WORDS FOR    *
.*       STORING ADDRESSES OR A-TYPE ADDRESS CONSTANTS.               *
.*                                                                    *
         AIF   (T'&STORAGE EQ 'O').OKN      SKIP IF STORAGE= NOT USED
&I       SETA  1                   INITIALIZE AS COUNTER
         AIF   (&N EQ N'&STORAGE).LOOP1               SKIP IF LEGAL
         MNOTE 0,'**XSNAP- ODD OPERAND IGNORED: STORAGE=&STORAGE(&N)'
         AIF   (&N EQ 0).OKN
.LOOP1   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP1E
&K       SETA  1                   INITIALIZE COUNTER
.*             PROCESS ADDRESS REQUIRING LA - ST COMBINATION          *
.LOOP1A  AIF   (&I+&K GT &N).LOOP1C         SKIP IF WE'RE AT END
         AIF   ('&STORAGE(&I+&K)'(1,1) NE '*').LOOP1C SKIP IF NOT *
&K       SETA  &K+1                INCREM # CONSECUTIVE *FORMS
         AGO   .LOOP1A             GO CHECK NEXT
.LOOP1C  DS    &K.A .              WORDS WHERE ADDRESSES WILL BE STORED
&I       SETA  &I+&K               INCREMENT
         AGO   .LOOP1G             GO FOR NEXT CHECK
.*             PROCESS ADDRESS CONSTANT TYPE OF OPERAND               *
.LOOP1E  DC    A(&STORAGE(&I))
&I       SETA  &I+1                INCREMENT # OPERANDS DONE
.LOOP1G  AIF   (&I LE &N).LOOP1    CONTINUE IF ANY MORE
.*                                                                    *
.*       CREATE LOAD ADDRESS - STORE PAIRS FOR EXPRESSION ADDRESSES   *
.*                                                                    *
&I       SETA  1
.LOOP2   AIF   ('&STORAGE(&I)'(1,1) NE '*').LOOP2E    SKIP IF NOT *
&L       SETA  K'&STORAGE(&I)-1    GET # CHARAS IN EXPRESSION
&K       SETA  1                   INIT COUNTER
         AIF    (&L LE 40).LOOP2A  SKIP IF SMALL ENOUGH
         MNOTE 8,'**XSNAP- STORAGE(&I) LONGER THAN 40 CHARACTERS'
&L       SETA  40                  TRUNCATE AND HOPE IT GOES
.*       BREAK EXPRESSION INTO 8 CHARACTER SECTIONS.                  *
.LOOP2A  ANOP
&A(&K)   SETC  '&STORAGE(&I)'(8*&K-6,8)      GET UP TO 8 NEXT CHARS
&K       SETA  &K+1                INCRMENT COUNTER
         AIF   (8*&K-8 LT &L).LOOP2A        LOOP UNTIL HAVE WHOLE OPR
         LA    0,&A(1)&A(2)&A(3)&A(4)&A(5)
         ST    0,&NAM.B+4*&I+68    STORE ADDRESS IN LIST
.LOOP2C  ANOP
&K       SETA  &K-1                DECRMENT SECTION TO NULL
&A(&K)   SETC  ''                  NULL FOR NEXT USE
         AIF   (&K GT 2).LOOP2C    CONTINUE UNTIL ALL BUT &A(1) NULL
.LOOP2E  ANOP
&I       SETA  &I+1                INCREMENT POSITION IN LIST
         AIF   (&I LE &N).LOOP2    CONTINUE WITH LIST
.*                                                                    *
.*       CREATE CODE TO SET UP REGISTERS FOR XXXXSNAP,CALL IT,AND     *
.*       RESTORE REGS ON RETURN.  XXXXSNAP RESTORES THE CONDTION CODE.*
.*                                                                    *
.OKN     LA    10,&NAM.B  .        GET ADDRESS OF REGISTER BLOCK
         L     15,68(10) .         GET V(XXXXSNAP) FOR BRANCH
         BALR  14,15 .             CALL XXXXSNAP,POINT 14 AT NEXT INST
         LM    0,15,0(10) .        RELOAD THE REGISTERS
.*             CREATE LABEL FOR IF OPTION, IF IT WAS USED.            *
.XIFLB   AIF   ('&INST' EQ '').XEXIT         SKIP GEN OF IF LABEL
&NAM.C   EQU   * .                 DEFINE LABEL FOR IF= BRANCH
.XEXIT   SPACE 2
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSRNR
         MACRO
         XSRNR &OP,&RG,&NO15
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRNR      SAVE/RESTORE REGISTERS FOR XSAVE/XRETURN      *
.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *
.*             THIS MACRO IS USED BY XSAVE AND XRETURN TO SET UP      *
.*       REGISTER SAVING AND RESTORATION.                             *
.*       &OP IS THE OPCODE TO BE USED.  I.E.  EITHER L  OR ST.        *
.*       &RG  IS 1 OPERAND FROM THE &RGS OPERAND USED BY XSAVE AND    *
.*             XRETURN.  IT IS EITHER 1 REGISTER, OR A PAIR OF REGS   *
.*             SEPARATED BY A DASH.                                   *
.*       &NO15   =0  STATES THAT A RETURN CODE IS CURRENTLY IN REG 15 *
.*             AND SHOULD NOT BE DISTURBED, REGARDLESS OF HOW THE REGS*
.*             ARE SPECIFIED.                                         *
.*       USES MACROS: XCHAR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  &XXCHAR             FOR COMMUNICATION WITH XCHAR
         LCLA  &I
         LCLC  &R1,&R2             1ST REG, 2ND REG, TEMPORARY
         AIF   ('&RG' EQ 'NO').XXEXIT        DON'T GEN ANYTHING
.*             SCAN FOR DASH-MEANING 2 REGISTERS.                     *
.XSL1    ANOP
&I       SETA  &I+1                INCREMENT FOR NEXT CHARACTER
         AIF   ('&RG'(&I,1) EQ '-').XDASH    JUMP IF DASH FOUND
         AIF   (&I LT K'&RG).XSL1  CONTINUE TO END OF OPERAND
&R1      SETC  '&RG'               &RG IS 1 REGISTER BY ITSELF
         AGO   .XSAA               GO TO NEXT DECISION POINT
.*             FOUND DASH-NOW SEPARATE THE REGISTERS.                 *
.XDASH   ANOP
&R1      SETC  '&RG'(1,&I-1)       GET FIRST REGISTER
         AIF   (&I EQ K'&RG).XSAA  DUMB USER - 1 REG FOLLOWED BY -
&R2      SETC  '&RG'(&I+1,K'&RG-&I)         GET 2ND REGISTER
.XSAA    XCHAR &R1,2               GET UP TO LAST 2 CHARS OF 1ST REG
         AIF   ('&XXCHAR' NE '14' AND '&XXCHAR' NE '15').XNO1415
&I       SETA  4*&XXCHAR-44         OFFSET FOR 14 OR 15
         AIF   ('&R2' NE '').XS2RG SKIP IF 2 REGISTERS SPECIFIED
         AIF   ('&XXCHAR' EQ '15' AND '&NO15' EQ '0').XXEXIT
         &OP   &R1,&I.(13)  .       SAVE/RESTORE 1 REG
         MEXIT
.XS2RG   AIF   ('&NO15' EQ '0').XSN15        SKIP IF 15 SHOULDN'T BE
         &OP.M &R1,&R2,&I.(13)  .  SAVE/RESTORE RANGE OF REGS
         MEXIT
.XSN15   AIF   ('&XXCHAR' EQ '15').XSN15A    SKIP IF 15 SPECIFIED
         L     &R1,12(13)  .        RELOAD REG 14
         XCHAR &R2,2                GET 2ND REG
         AIF   ('&XXCHAR' EQ '15').XXEXIT    SKIP IF 15 SPECIFIED
.XSN15A  LM    0,&R2,20(13)  .     RELOAD REST OF REGS
         MEXIT
.*             RESTORE 1 REG OR RANGE (NOT STARTING WITH 14 OR 15).   *
.XNO1415 AIF   ('&R2' NE '').XLMSTM          JUMP IF MULTIPLE REGS
         &OP   &R1,&R1*4+20(13)
         MEXIT
.XLMSTM  &OP.M &R1,&R2,&R1*4+20(13)
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSRTR
         MACRO
         XSRTR &TR,&LABEL,&MSG
.*--> MACRO: XSRTR      GENERATE TRACE CODE FOR XSAVE/XRETURN . . . . .
.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *
.*       THIS MACRO IS USED BY XSAVE AND XRETURN TO GENERATE THE      *
.*       TRACE CODE CALLS TO XSNAP OR XPRNT, OR TIMING CALLS TO XTIME.*
.*       MACROS CALLED BY THIS MACRO - XLLOK, XPRNT,XSNAP,XTIME       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  &XXLOOK             FOR COMMUNICATION 0WITH XLOOK
         GBLB &XSNAPST,&XPRNTST    GLOBALS FOR OUTPUT MACROS
         LCLA  &I                  FOR USE AS LENGTH SPECIIFICATION
         LCLB  &XSTSAV             FOR SAVING STAUS VARIABLES
         LCLC  &NAME               FOR EITHER LABEL OR CSECT
         XLOOK &TR(1),(*,SNAP,TIME)         CHECK TYPE
         AIF   (&XXLOOK LT 3).XPS  SKIP IF NOT TIME
*        XTIME ,&TR(2)
         XTIME ,&TR(2)
         MEXIT
.XPS     AIF   (&XXLOOK EQ 0 AND N'&TR GT 1 AND '&TR(2)' NE 'SNAP').XE
&NAME    SETC  '&LABEL'            ASSUME NAME IS LABEL
         AIF   (T'&LABEL NE 'O').XNOK1       SKIP IF LABEL EXISTS
&NAME    SETC  '&SYSECT'           USE CSECT NAME INSTEAD
         AIF   ('&SYSECT' NE '').XNOK1       SKIP IF CSECT NOT PC
&NAME    SETC  '$PRIVATE'          USE NAME FOR PRIVATE CODE (PC)
.XNOK1   AIF   (&XXLOOK EQ 2 OR '&TR(2)' EQ 'SNAP').XNSNAP
&XSTSAV  SETB  (&XPRNTST)          SAVE STATUS VARIABLE
&XPRNTST SETB  (0)                 MAKE SURE XPRNT WILL GENERATE
         AIF   (&XXLOOK EQ 1).XDFTA         SKIP- TR=* - DEFAULT
&I       SETA 2*((K'&TR)/2)        GET RIGHT TOTAL LENGTH FOR DC
         B     *+4+&I .            BRANCH AROUND MESSAGE
XX&SYSNDX.T DC C'0',CL(&I-1)&TR
         AGO   .XPRB               SKIP OVER ALTERNATE
.XDFTA   B     *+28 .              BRANCH AROUND MESSAGE
XX&SYSNDX.T DC CL24'0*** &NAME &MSG ***'
&I       SETA  24                  SET UP FOR XPRNT
.XPRB    ANOP
*        XPRNT XX&SYSNDX.T,&I      PRINT MESSAGE WITH GIVEN LENGTH
         XPRNT XX&SYSNDX.T,&I
&XPRNTST SETB  (&XSTSAV)           RESTORE PREVIOUS VALUE
         MEXIT
.XE      MNOTE 0,'**XSRTR- TR=&TR: UNKNOWN, IGNORED'
         MEXIT
.XNSNAP  ANOP
&XSTSAV  SETB  (&XSNAPST)          SAVE XSNAP STATUS, IN CASE OFF
&XSNAPST SETB  (0)                 MAKE SURE XSNAP WILL GENERATE
*        XSNAP LABEL='  MESSAGE '
         AIF   (&XXLOOK EQ 2).XDFTB         SKIP IF TR=SNAP
         XSNAP LABEL=&TR(1)
         AGO   .XSNB               SKIP OVER ALTERNATE
.XDFTB   XSNAP LABEL='*** &NAME &MSG ***'
.XSNB    ANOP
&XSNAPST SETB  (&XSTSAV)           RESTORE STATUS,IN CASE IT WAS OFF
         MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XSTOP
         MACRO
&LABEL   XSTOP &N=2,&ABEND=200,&GOTO=
.*--> MACRO: XSTOP      CONTROL PROGRAM LOOPS . . . . . . . . . . . . .
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSTOP     IS USED TO STOP INFINITE LOOPS IN ASSEMBLER        *
.*         N=NUMBER   WILL CAUSE THE PROGRAM TO ABEND THE NUMBER'TH   *
.*             TIME THROUGH THE XSTOP.  DEFAULT IS N=2,               *
.*             WHICH MEANS THE XSTOP CAN ONLY BE ENCOUNTERED ONCE     *
.*             BEFORE IT ABENDS.                                      *
.*         ABEND=K      K WILL BE THE COMPLETION CODE ISSUED BY THE   *
.*             EMBEDDED ABEND MACRO.  DEFAULT IS 200.                 *
.*         GOTO=LABEL   BRANCH TO LABEL INSTEAD OF ABENDING           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  &XSTOPST            XSTOP GENERATION STATUS,ON=0,OFF=1
         LCLC  &XNAM               NAME FOR CONSTANTS
         AIF   (&XSTOPST).XXNOG    SKIP IF NOGEN
&XNAM    SETC  'XX&SYSNDX.V'       GET UNIQUE LABEL
&LABEL   ST    0,&XNAM   .         SAVE WORK REGISTER
         L     0,&XNAM+4   .       LOAD CURRENT COUNTER VALUE
         BCT   0,&XNAM+8   .       BRANCH IF STILL OK,DECREMENT REG
         L     0,&XNAM .           RESTORE WORK REGISTER
         AIF   ('&GOTO' EQ '').XXAB         SKIP IF NO GOTO USED
         B     &GOTO  .            TAKE DESIRED BRANCH
         AGO   .XXDC               SKIP TO GENERATE DC'S
.XXAB    ABEND &ABEND,DUMP
.XXDC    ANOP
&XNAM    DC    A(0,&N)    .        REGISTER SAVE AREA, COUNTER
         ST    0,&XNAM+4   .       SAVE DECREMENTED COUNTER VALUE
         L     0,&XNAM   .         RESTORE WORK REGISTER
         SPACE 2
         MEXIT
.XXNOG   AIF   (T'&LABEL EQ 'O').XXEXIT     SKIP IF NO LABEL
&LABEL   DS    0H
.XXEXIT  MEND
./ ADD LEVEL=40,SOURCE=0,NAME=XXGPSRCH
         MACRO
        XXGPSRCH &DIREC,&TIME
.**-->MACRO: XXGPSRCH  INNER MACRO FOR XGPGEN . . . . . . . . . . . . .
.*     ARGUMENTS:
.*       &DIREC= G--> INPUT
.*               P--> OUTPUT
.*       &TIME=1 --> FIRST CALL, SETS UP EXTRA CODE AND ACTS AS &SYSNDX
.*             2--> SECOND CALL
.*. . . . . . . . . . . . .. .  . . . . . . . . . . . . . . . . . . . .
         L     R3,X&DIREC.ELEM .   GET # LAST POINTER TO OPEN FILES
         LA    R1,X&DIREC.PNTSRT . GET @ OF FIRST POINTER
         LTR   R3,R3 .             ARE THERE ANY ELEMENTS?
         BE    X&DIREC.MAKE&TIME   NO - GO CREATE ONE
         LA    R2,12 .             SET UP INCREMENT SIZE
X&DIREC.LOOP&TIME CLC 0(8,R1),X&DIREC.CURENT COMPARE DD NAMES
         BE    X&DIREC.CONT&TIME   IF EQUAL, GO TO I/O
         BXLE  R1,R2,X&DIREC.LOOP&TIME ›EQUAL, SEARCH TILL END OF TABLE
         SPACE 2
         MEND
