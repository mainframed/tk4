,
// EXEC ASGCG,PARM.DATA='MAP'
//SOURCE.INPUT DD *
         TITLE 'TEST PROGRAM-XDECI,XDECO,XDUMP COMPATIBILITY MACROS'
*        THIS PROGRAM TESTS THE MACROS XDUMP,XDECI,XDECO, WHICH       *
*   ARE HANDLED IN THE ASSIST SYSTEM AS SPECIAL MACHINE INSTRUCTIONS. *
*   THE FUNCTIONS AND USAGE OF THESE COMMANDS ARE DESCRIBED IN THE    *
*   ASSIST USER MANUAL.                                               *
         SPACE 1
XDECTEST CSECT
         USING XDECTEST,15         NOTE ENTRY POINT USING
         STM   14,12,12(13)        STORE REGS
         LR    12,13               MOVE OLD SA PTR OVER
         LA    13,XDECSAVE         PTR TO NEW SAVE AREA
         ST    12,4(13)            PTR TO OLD SA
         ST    13,8(12)            PTR TO NEW SAVE AREA
         BALR  12,0                NEW BASE
         USING *,12                NOTE NEW BASE
         SPACE 1
*              TESTS FOR XDUMP. REGISTERS, THEN STORAGE AREAS.
         XDUMP
         XDUMP AREA,64             AREA WITH EXPLICIT LENGTH
         XDUMP AREA                DUMP, IMPLIED LENGTH = 4
         SPACE 4
*              TESTS FOR XDECI. CONVERT CHARACTER STRINGS, WHICH WOULD*
*        NORMALLY BE READ IN FROM CARDS.                              *
         SR    2,2                 CLEAR FOR INDEX TO NUMBERS
         LA    1,CARD              INIT FOR SCANNING ACROSS
LOOP     XDECI 0,0(1)              SCAN AND CONVERT NEXT NUMBER
         BO    OVER                BRANCH IF NOGOOD
         ST    0,NUMBERS(2)        STORE THE VALUE
         LA    2,4(2)              INCREMENT INDEX VALUE
         B     LOOP                GO BACK FOR NEXT NUMBER
OVER     CLI   0(1),C'$'           WAS IT $ DELIMITER
         BE    DONE                YES, QUIT
         XPRNT =CL30'0*** BAD NUMBER ***',30
DONE     XDUMP
         XDUMP NUMBERS,60          DUMP ARRAY OUT
         SRL   2,2                 DIVIDE BY 4 FOR # NUMBERS
         SPACE 2
*              TEST XDECO - PRINT NUMBERS OUT.
         SR    3,3                 CLEAR FOR INDEX TO ARRAY
LOOP2    L     0,NUMBERS(3)        GET NEXT VALUE
         XDECO 0,OUTPUT            CONVERT
         XPRNT OUTPUT,12           PRINT NUMBER
         LA    3,4(3)              INCREMENT INDEX
         BCT   2,LOOP2             CONTINUE FOR NEXT
         SPACE 1
         L     13,4(13)            RESTORE PTR
         LM    14,12,12(13)        RESTORE REGS
         BR    14                  RETURN
         SPACE 1
XDECSAVE DS    18F                 SAVE AREA
NUMBERS  DC    16F'4095'           FOR CONVERSIONS
CARD     DC    C'0 +1  -1 -000 +64 64 -64   123456789  '
         DC    C' 1234567890  $'   SHOULD STOP ON BIG #
AREA     DC    CL64'1234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ,./$#@'
OUTPUT   DC    CL12' '             OUTPUT CONVERSION AREA
         LTORG
         END
/*
//DATA.XSNAPOUT DD SYSOUT=A
,
// EXEC ASGCG,PARM.DATA='MAP,EP=TEST'
//SOURCE.INPUT DD *
         TITLE 'TEST PROGRAM XSNAP,XSTOP,XSET - VERSION 4.0'
         PRINT GEN
TEST     CSECT
         XSAVE
         L     1,=XL4'00FF0000'    GET HUGE ADDRESS
         XSNAP STORAGE=(*0(1),*20(1))
         L     2,=XL4'2FFF00'      @ NEAR END OF MACHINE
         XSNAP STORAGE=(*0(2),*400(2))
         XSNAP T=FLOAT
         XSNAP T=(NO,FL)
         XSNAP T=ST
         XSNAP T=NO
         XSNAP T=NOREGS
         XSNAP T=NR
         XSNAP T=FL
         XSNAP T=(NO,FLOAT)
         XSNAP T=(PR,FL,0101)
         XSNAP T=ST,IF=(L1)
         XSNAP IF=(L1,N,0)
         XSNAP IF=(L1,L,1)
         XSNAP IF=((0),NH,(1))
         XSNAP IF=(L1,E,L2,CLC)
         XSNAP IF=((0),NE,=F'1')
         XSNAP STORAGE=(L1,L2,L3,L4,L5,L6)
         XSNAP STORAGE=(*L1+10,*L1+20,*L1+20,*L1+10,L2)
         LA    1,10                SET LOOP LIMIT
LOOPA    XSNAP LABEL='AT LOOPA',IF=((1),H,=H'5',CH)
         XSNAP T=NOREGS,LABEL=' XSNAP WITH TRACE ONLY'
         XSTOP N=7,ABEND=350
         BCT   1,LOOPA             LOOP THROUGH
         XSNAP STORAGE=(*L1+L'L2+1000-L'L1-L'L2-1200+L2-L1,*L2)
         XSET  XSNAP=OFF,XSTOP=OFF
         XSNAP T=STORE,LABEL='XXEXIT'
         XSTOP N=1
         XRETURN SA=*
L1       DC    CL130'ABCDEFGHI'
L2       DC    30X'0'
L3       DC    50XL4'0'
L4       DC    X'1'
L5       DC    64C'A'
         DC    64C'B'
         DC    64C'C'
         DC    256C'E'
         DC    X'1'
L6       DS    F
         LTORG
         END
/*
//DATA.SYSUDUMP DD SYSOUT=A
//DATA.XSNAPOUT DD UNIT=AFF=FT06F001
,
//*
//*            TEST PROGRAM TO DEMONSTRATE THE FOLLOWING MACROS:
//*       1. EQUREGS
//*       2. XSAVE
//*       3. XRETURN
//*       4. XPRNT AND XSNAP (INDIRECTLY)
//*
//*       THIS IS PART OF XMACRO PACKAGE VERSION 4.0 (APRIL 1972)
//*
//*       THE CATALOGUED PROCEDURES ARE LOCAL TO PENN STATE UNIVERSITY
//*       COMPUTATION CENTER, ARE FOR USE WITH ASSEMBLER G AND THE
//*       LOADER, CORRESPONDING TO ASMFCG.
//*
// EXEC ASGCG,PARM.DATA='MAP'
//SOURCE.INPUT DD *
         EQUREGS
*         TYPICAL USAGE FOLLOWS.
         XSAVE
         CALL PROG2
         XRETURN SA=*,RC=4    RETURN TO OS WITH RETURN CODE OF 4
*        FOLLOWING CALLS EXTREME AND UNTYPICAL.
PROG2    XSAVE RGS=(R14,R0-R1,5-12),BR=(11,10),OPT=(TITLE,CSECT)
         CALL  LOWEST         CALL LOWEST LEVEL ROUTINE
         LA    R3,5           SET UP LIMIT ON RECURSION DEPTH
         CALL  RECURSE        CALL RECURSIVE ROUTINE
         CALL  PROG3
         CALL  PROG4
         B     BAD            RETURN HERE× OR SKIP BRANCH VIA RP=
         SR    15,15          CLEAR FOR RETURN CODE = 0
BAD      XRETURN  RGS=(14,0-1,5-12),SA=*,T=*,RC=(R15)
*         LOWEST LEVEL ROUTINE FOLLOWS: NOTE CODE GENERATED.
LOWEST   CSECT
         XSAVE SA=NO,BR=15,TR=NO,ID=NO  ZAP OPTIONS
         XRETURN SA=NO,TR=NO
*         FOLLOWING CSECT USES REEN FOR RECURSIVE CALLS.
PROGRAM  CSECT
RECURSE  XSAVE TR=('RECURSION',SNAP),REEN=0,OPT=ENTRY
         BCT   R3,CONTINU          LOOP, RECURSING
         B     RETB                GIVE UP NOW
CONTINU  CALL  RECURSE             CALL MYSELF AGAIN
RETB     XRETURN REEN=0            RETURN, FREE STORAGE
*         ENTIRES PROG3 AND PROG4 HAVE SAME ADDRESSIBILITY, WITH AD.
PROG3    XSAVE OPT=ENTRY,SA=P3SAVE,BR=(12,11,10),AD=PROG3
PROG3A   XRETURN RC=(R3),T=*
PROG4    XSAVE OPT=ENTRY,AD=PROG3,BR=(12,11,10),ID=PROG3ENTRYOFPROGRAM
         LTR   R0,R0               TEST TO DECIDE
         BZ    ZERO                SKIP TO RP=0
         XRETURN RP=4              BRANCH OVER BAD ABOVE
ZERO     XRETURN RP=0,T=*,SA=*     SAVE AREA, RP
         END
//DATA.XPRNT DD SYSOUT=A
//DATA.XSNAPOUT DD SYSOUT=A
$JOB   ASSIST
*        FOLLOWING IS A REASONABLE TEST OF ASSIST'S XIO FACILITY
*
*        READS CARDS FROM TWO FILES, WRITES THEM TO DISK, RECOVERS THEM
*        AND PRINTS THEM ON A PRINTER
*
         USING *,15                ADDRESSABILITY
INC      EQU   3                   RECORD COUNT INCREMENT REGISTER
IOREG    EQU   1                   XIO POINTER REGISTER
COUNT    EQU   2                   RECORD COUNTER REGISTER
         LA    INC,1               GET INCREMENT FOR RECORD COUNT
         SR    COUNT,COUNT         INITIALIZE THE COUNTER
INLOOP   LA    IOREG,=CL8'XIN1'    ADDRESS INPUT FILE
         XREAD INAREA1,80          READ ACARD FROM NORMAL INPUT FILE
         BM    OUT                 ON E-O-F TERMINATE INPUT
         AR    COUNT,INC           COUNT CARD JUST READ
         XGET  INAREA2,80          READ A CARD FROM THE SECOND
*                                  INPUT FILE
         BNE   OUT                 ON E-O-F TERMINATE INPUT
         AR    COUNT,INC           COUNT THE CARD JUST READ
         LA    IOREG,=CL8'DISK'
         XPUT  INAREA1,160         WRITE OUT A BLOCK
         BNZ   ERROR               ON I/O ERROR TERMINATE
         MVC   INAREA1(160),BLANKS BLANK OUT INPUT AREA
         B     INLOOP              LOOP FOR ALL CARDS
OUT      XDECO COUNT,VAL           CONVERT NUMBER OF CARDS READ
*                                  TO PRINTABLE FORM
         XPRNT HEAD,HLNG           PRINT RUN HEADING
         LA    IOREG,=CL8'PRINT'   POINT AT PRINT FILE
         XPUT  MESS,MLNG           PRINT RECORD HEADER
      SR   0,0   CLEAR FOR CLOSE
      LA   IOREG,=CL8'DISK'    FILE
      XPUT INAREA1,(0)      CLOSE THE FILE
OUTLOOP  LA    IOREG,=CL8'DISK'    POINT TO DISK FILE FOR INPUT
         XGET  INAREA1,160         READ DATA BACK IN
         BNE   DONE                ON E-O-F TERMINATE RUN
         XPRNT INAREA1-1,81        PRINT A CARD IMAGE
         MVC   INAREA1(80),INAREA2   MOVE NEXT CARD OVER
         LA    IOREG,=CL8'PRINT'   POINT AT PRINTER FILE
         XPUT  INAREA1-1,81        PRINT A CARD IMAGE
         B     OUTLOOP             LOOP FOR ALL CARDS
ERROR    XPRNT =CL15'0I/O ERROR QUIT',15
RET      BR    14                  RETURN TO THE SYSTEM
DONE     LA    IOREG,=CL8'PRINT'   POINT AT PRINT FILE
         XPUT  NORMTM,27
         B     RET                 TERMINATE NORMALLY
NORMTM   DC    C'***NORMAL TERMINATION***'
HEAD     DC    C'1BEGIN PRINT OF CARDS READ'
HLNG     EQU   *-HEAD              HEADING LENGTH
MESS     DC    C' NUMBER OF CARDS READ = '
VAL      DS    CL12' ',C'/'
MLNG     EQU   *-MESS              VAL PRINT MESSAGE LENGTH
BLANKS   DC    CL160' '            INPUT BLANKS
         DC    C'0'
INAREA1  DC    CL80' '             INPUT/OUTPUT AREA 1
INAREA2  DC    CL80' '             INPUT/OUTPUT AREA2
         END
$ENTRY
THE CARDS IN THIS FILE ARE READ WITH THE NORMAL DATA READER
*********      NORMAL # 2          *************
*********      NORMAL 3            *************
*********      NORMAL 4            *************
*********      NORMAL 6            *************
*********      NORMAL 7            *************
*********      NORMAL 8            *************
*********      NORMAL 9            *************
*********      NORMAL 10           *************
//DATA.PRINT DD SYSOUT=A,DCB=(RECFM=FA,LRECL=133,BLKSIZE=133)
//DATA.DISK DD UNIT=SYSDA,DISP=(NEW,DELETE),DSN=&&TEMP,                *
//             DCB=(RECFM=FB,LRECL=160,BLKSIZE=160),SPACE=(CYL,(1,1))
//DATA.XIN1 DD *
THESE CARDS ARE READ FROM THE SECOND CARD INPUT FILE ( XIO -> XGET )
XXXXXXXXX      SECOND READ FILE CARD 2
XXXXXXXXX      SECOND READ FILE CARD 3
XXXXXXXXX      SECOND READ FILE CARD 4
XXXXXXXXX      SECOND READ FILE CARD 5
XXXXXXXXX      SECOND READ FILE CARD 6
XXXXXXXXX      SECOND READ FILE CARD 7
XXXXXXXXX      SECOND READ FILE CARD 8
XXXXXXXXX      SECOND READ FILE CARD 9
XXXXXXXXX      SECOND READ FILE CARD 10
/*
