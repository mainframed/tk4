         TITLE  '***  EQU''S FOR MACRO ROUTINES '
         AIF   (NOT &$MACROS).MAXXXX   SKIP MACROS                    J
*   FOLLOWING EQU'S HANDLE ERROR MESSAGES IN MEXPND NOT TAKEN CAREOF
*     BY ERRTAG
$ER#ACTR EQU   2                   ACTR EXCEEDED                      S
$ER#DMER EQU   4                   SET SYMBOL SUBSCRIPT               S
$ER#SBST EQU   6                   SUBSTRING EXPRESSION               S
$ER#CVCA EQU   8                   CHAR TO ARITH CONV ERR             S
$ER#CVAB EQU   10                  ARITH TO BOOL CONV ERR             S
$ER#CVCB EQU   12                  CHAR TO BOOL CONV ERR              S
$ER#ATER EQU   14                  ATTRIBUTE USE ERR                  S
$ER#SYSL EQU   16                  &SYSLIST ERR                       S
$ER#SYER EQU   18                  SYSTEM ERR                         S
$ER#EXBF EQU   20                  CHAR BUFFER EXCEEDED               S
$ER#MXST EQU   22                  MAX # OF STMTS EXCEEDED            S
$ER#ZDIV EQU   24                  FIXED PT OVERFLOW OR ZERO DIVIDE   S
$ER#PRVR EQU   26                                                     A
         SPACE 2
*   FOLLOWING FLAGS SET IN AVMSNBY1 WILL TURN ON RESPECTIVE SNAPS
$MSNP01  EQU   X'80'               MACINT SNAP FLAG
$MSNP02  EQU   X'40'               MACRO1 SNAP FLAG
$MSNP03  EQU   X'20'               MACSCN SNAP FLAG
$MSNP04  EQU   X'10'               MCSCOP SNAP FLAG
$MSNP05  EQU   X'08'               MACFND,MCVSCN SNAP FLAG
$MSNP06  EQU   X'04'          MCSYSR, DECTRM, MCGTST, ATTERM SNAP FLAG
$MSNP07  EQU   X'02'               MCBODY SNAP FLAG
$MSNP08  EQU   X'01'               BSU'S SNAP FLAG
         SPACE
*   FOLLOWING FLAGS SET IN AVMSNBY2 WILL TURN ON RESPECTIVE SNAPS
$MSNP09  EQU   X'80'               MACLEX SNAP FLAG
$MSNP10  EQU   X'40'               MCGNCD SNAP FLAG - ONE OPS
$MSNP11  EQU   X'20'               MEXPND SNAP - INIT AND INTERPRET
$MSNP12  EQU   X'10'               MEXPND SNAP - INTERNAL ROUTINES
$MSNP13  EQU   X'08'               MXERRM, MXMVSR SNAP CONTROL
$MSNP14  EQU   X'04'               SET MEXPND ENTER EXIT SNAPS
         SPACE
$MINDEF  EQU   X'80'               AVMBYTE1 - IN MACRO DEFINITION
$MINEXP  EQU   X'40'               AVMBYTE1 - IN MACRO EXPANSION
$MGBLFLG EQU   X'80'               MCLBFLG2 - GLOBALS NO LONGER OK    S
$MLCLFLG EQU   X'40'+$MGBLFLG      MCLBFLG2 - LOCALS NO LONGER OK     S
$MACTFLG EQU   X'20'+$MLCLFLG      MCLBFLG2 - ACTR NO LONGER OK       S
$MCOCFL1 EQU   B'00000001'         (MCLBFLG2) - OPEN CODE - DECLARE   S#
                                   TYPES ALLOWED                      S
$MCOCFL2 EQU   B'00000011'         (MCLBFLG2) - OPEN CODE - DECLARE   S#
                                   TYPES NOT ALLOWED                  S
$MC1DCL  EQU   B'10000000'         DECLARE TYPE                       S
$MC1ERR  EQU   B'01000000'         ORDER ERROR                        S
$MC1SKIP EQU   B'00100000'         DON'T CALL MXINST                  S
$MC1RET  EQU   B'00010000'         RETURN AFTER MXINST                S
$MSBLIST EQU   X'04'               AVMBYTE1 - PROCESSING OPERAND SUBLST
$MINQUOT EQU   X'02'               AVMBYTE1 - INSIDE QUOTED STRING
$MKEYOPR EQU   X'01'               KEYWORD OPRND PROCESSSED, POSIT NOGO
         SPACE 1
$MOPRTR  EQU   X'80'               AVMBYTE2 - PREV SYMBOL = OPRTR
$MTERM   EQU   X'40'               AVMBYTE2 - PREV SYMBOL = TERM
$MINARIT EQU   X'20'               AVMBYTE2 - IN ARITHMETIC EXPRESSION
$MINBOOL EQU   X'10'               AVMBYTE2 - IN BOOLEAN EXPRESSION
$MINCHAR EQU   X'08'               AVMBYTE2 - IN CHARACTER EXPRESSION
$MDIMVAR EQU   X'04'               AVMBYTE2 - PREV SYMBOL = DIMEN SYMB
$MINAPAR EQU   X'02'               AVMBYTE2 - IN ARITH SUBSCR EXPRESS
$MINPEXP EQU   X'01'               AVMBYTE2 - DO EXPRES IN PARENS ONLY
         SPACE 1
$MRPARST EQU   X'80'               AVMBYTE4 - RIGHT PAREN IN INPUT
$MINSTRN EQU   X'40'               AVMBYTE4 - PROC VAR SYMB IN STRING
$MCOMST  EQU   X'20'               AVMBYTE4 - COMMA IN BSU INPUT STRM
$MGENSTP EQU   X'10'               AVMBYTE4 - STOP MACRO GENERATION
$MXJMPFL EQU   X'08'               AVMBYTE4 - AGO OR SUCCESSFUL AIF SWT
$MSTOPEX EQU   X'04'               AVMBYTE4 - DON'T EXPAND CRRNT MACRO
         SPACE 2
$GLOBAL  EQU   4
$LOCAL   EQU   8
$SYMPAR  EQU   12
$SYSVAR  EQU   16                  SYSTEM VARIABLE INDEX
         SPACE 2
$LCHWRK  EQU   1024
$LSUBENT EQU   12                  LENGTH OF SUB-OPERAND ENTRY
$LMSRCMX EQU   (RSOL1+2*RSOLC)-1   MAXIMUM LENGTH-1 OF GEN'D STMT
         SPACE 2
$BSAR    EQU   X'20'               MCBSFLGS, ARITHMETIC TYPE
$BSBOOL  EQU   X'10'               MCBSFLGS, BOOLEAN TYPE
$BSCHAR  EQU   X'08'               MCBSFLGS, CHARACTER TYPE
         SPACE 2
*  EQUATES FOR INDEX VALUES FOR OPERATOR BSU'S
$BSPLUS  EQU   2
$BSMIN   EQU   4
$BSMULT  EQU   6
$BSDIV   EQU   8
$BSOR    EQU   10
$BSAND   EQU   12
$BSNOT   EQU   14
$BSNE    EQU   16
$BSGE    EQU   18
$BSLE    EQU   20
$BSLT    EQU   22
$BSEQ    EQU   24
$BSGT    EQU   26
$BSCAT   EQU   28
$BSAGO   EQU   30
$BSAIF   EQU   32
$BSETA   EQU   34
$BSETB   EQU   36
$BSETC   EQU   38
$BSRPAR  EQU   40
$BSLPAR  EQU   42
$BSBSCRP EQU   44
$BSBSTR  EQU   46
$BSBSYL  EQU   48
$BSCOMMA EQU   50                  HIERARCHY = ZERO
$BSPRINT EQU   52                  HIERARCHY = 2
$BSMEXIT EQU   54                  HIERARCHY = 2
$BSMEND  EQU   56                  HIERARCHY = 2
$BSANOP  EQU   58                  HIERARCHY = 2
$BSERR01 EQU   60                  HIERARCHY = 2
$BSINMAC EQU   62                  SET INNER MACRO CALL CODE HIER = 2
$BSMVSTM EQU   64                  BSU INDEX FOR MOVE STMT
$BSMNTER EQU   X'80'               FLAG TO FORCE ERR MSSGE ON MNOTE
$BSRLCHR EQU   X'80'               FLAG FOR CHAR TYPE RELATIONAL OPRTR
$MPRCOM  EQU   1                   (MCBSFLGS)=> SPECIAL PRINT         A
         SPACE 2
*   EQUATES FOR OPERATOR HIERARCHIES
$MCOMMHR EQU   0
$MPARHR  EQU   0
$MPRNTHR EQU   2
$MSETHR  EQU   2
$MORHR   EQU   4
$MANDHR  EQU   6
$MRELHR  EQU   8
$MCATHR  EQU   10
$MPLUSHR EQU   12
$MMULTHR EQU   14
$MNOTHR  EQU   16
$MAGOHR  EQU   16
$MAIFHR  EQU   16
         SPACE 2
*  EQUATES FOR TERM BSU INDEXES
$BSTSYAG EQU   2                   GLOBAL ARITH SET SYMBOL
$BSTSYBG EQU   4                   GLOBAL BOOLEAN SET SYMBOL
$BSTSYCG EQU   6                   GLOBAL CHAR SET SYMBOL
$BSTSYAL EQU   8                   LOCAL ARITH SET SYMBOL
$BSTSYBL EQU   10                  LOCAL BOOL SET SYMBOL
$BSTSYCL EQU   12                  LOCAL CHAR SET SYMBOL
$BSYMPAR EQU   14                  SYMBOLIC PARAMETER
$BSIMMA  EQU   16                  ARITH IMMEDIATE BALUE
$BSIMMB  EQU   18                  BOOLEAN IMMEDIATE VALUE
$BSTRING EQU   20                  STRING VALUE
$BSYSNDX EQU   22                  &SYSNDX SYSTEM VARIABLE
$BSYSLST EQU   24                  &SYSLIST SYSTEM VARIABLE
$BSYSECT EQU   26                  &SYSECT SYSTEM VARIABLE
$BSLABEL EQU   28
$BSTEMP  EQU   30
$BSATI   EQU   34                  BSU NBR FOR I' ATTRIBUTE
$BSATK   EQU   36                  BSU NBR FOR K' ATTRIBUTE
$BSATL   EQU   38                  BSU NBR FRR L' ATTRIBUTE
$BSATN   EQU   40                  BSU NBR FOR N' ATTRIBUTE
$BSATS   EQU   42                  BSU NBR FOR S' ATTRIBUTE
$BSATT   EQU   44                  BSU NBR FOR T' ATTRIBUTE
$BSADDRA EQU   46                  BSU NBR FOR ARITH TYPE @
$BSADDRB EQU   48                  BSU NBR FOR BOOL @
$BSADDRC EQU   50                  BSU NBR FOR CHAR TYPE @
         SPACE 2
*  EQUATES FOR VARIOUS LEFT PAREN TYPES
$MINLPAR EQU   X'80'               ARITH LEFT PAREN
$MINSBST EQU   X'40'               SUBSTRING LEFT PAREN
$MINSBSC EQU   X'20'               SUBSCRIPT LEFT PAREN
$MINSYSL EQU   X'10'               &SYSLIST LEFT PAREN
         TITLE '*** DSECTS FOR MACRO CAPABILITY IN ASSIST***'
**-->  DSECT: MCGLBDCT    FORMAT FOR GLOBAL DICTIONARY ENTRY          *
*.                                                                    *
*.*********************************************************************
         SPACE
MCGLBDCT DSECT
MCGLBNXT DS    F                   LINK TO NEXT GLOBAL ENTRY
MCGLBLEN DS    C                   LENGTH OF GLOBAL NAME
MCGLBNAM DS    CL8                 GLOBAL DICT ENTRY NAME
MCGLBTYP DS    C                   ENTRY TYPE, ARITH, BOOL OR CHAR
MCGLBDIM DS    H                   DIMENSION OF SET VARIABLE
MGLCLPNT DS    0F                  POINTER OFFSET FOR LOCAL VALUE
MCGLBDEF DS    F                   COUNT # OF MACRO DEFINITION
$LGLBENT EQU   *-MCGLBDCT          LEN OF GLOBAL DICT ENTRY STND PART
MCGBAVAL DS    0F                  GLOBAL ARITH VALUE
MCGBBVAL DS    0F                  GLOBAL BOOL VALUE
MCGBCLEN DS    F                   GOBAL CHAR VALUE LENGTH
MCGBCVAL DS    CL8                 GLOBAL CHAR VALUE
         EJECT
**--> DSECT:  MCLCLDPV   FORMAT FOR LOCAL DICTIONARY DOPE VECTOR      *
*.                                                                    *
*.*********************************************************************
         SPACE
MCLCLDPV DSECT
MCLOCNXT DS    F                   POINTER TO NEXT ENTRY
MCLCLLEN DS    C                   LOCAL ENTRY NAME LENGTH
MCLCLNAM DS    CL8                 LOCAL ENTRY NAME
MCLCLTYP DS    C                   TYPE, IE ARITH, BOOL OR CHAR
MCLCLDIM DS    H                   DIMENSION OF LOCAL ENTRY
MCLCLPNT DS    F                   OFFSET POINTER FOR VALUE
$LLCLDV  EQU   *-MCLCLDPV          LEN OF LOCAL DICT D.V.
         SPACE 2
**--> DSECT: MCPARENT   FORMAT FOR SYMBOLIC PARAMETER ENTRY           *
*.                                                                    *
*.*********************************************************************
         SPACE
MCPARENT DSECT
MCPARNXT DS    F                   POINTER TO NEXT ENTRY
*              NOTE: NEXT 3 ENTRIES MUST BE IN ORDER GIVEN.  JRM.     J
MCPARNLN DS    C                   PARAM ENTRY NAME LENGTH
MCPARNAM DS    CL8                 SYMBOLIC PARAM NAME
MCPARTYP DS    C                   PARAMETER TYPE, POSIT OR KEYWORD
MCPARNTL EQU   *-MCPARNLN          LENGTH MOVED TOGETHER              J
MCPARNDX DS    H                   PARAMETER POSITION IN LIST
MCPROPLN DS    C                   LENGTH OF OPERAND
MCPRATYP DS    C                   ATTRIBUTE TYPE, IE 'N', 'O'
MCPARNB  DS    C                   UNUSED AT PRESENT                  J
MCPARFIL DS    C                   UNUSED AT MOMENT                 JRM
MCPROPRN DS    F                   OPERAND STANDARD VALUE POINTER
$LPARENT EQU   *-MCPARENT          LEN OF SYM PARAM ENTRY
         SPACE 2
**-->  DSECT:  MCBSU   FORMAT OF BASIC SYNTACTIC UNIT                 *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCBSU    DSECT
MCBSFLGS DS    C                   INDICATES OPRTR, TERM ETC
MCBSINDX DS    C                   BSU INDEX OF SYMBOL
MCBSOFST DS    C                   SYMBOL OFFSET RELATIVE TO SOURCE
MCBSTRLN DS    0C                  STRING LENGTH
MCBSHIER DS    C                   HIERARCHY OF OPERATOR, IF OPRTR
MCBSVALU DS    0F                  ARITH OR BOOL IMMEDIATE VALUE
MCBSLOC  DS    F                   LOCATION OF TERM VALUE
$LMCBSU  EQU   *-MCBSU            LENGTH OF BSU ENTRY
         SPACE 2
**-->  DSECT:  MCSEQ   FORMAT OF SEQUENCE SYMBOL ENTRY                *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCSEQ    DSECT
MCSEQNXT DS    F                   POINTER TO NEXT ENTRY
MCSEQNLN DS    C                   LENGTH OF NAME
MCSEQNAM DS    CL8                 NAME OF SEQ SYMBOL
MCSEQFLG DS    C                   ENTRY FLAG BYTE
MCSEQDUM DS    H                   UNUSED
MCSEQVAL DS    F                   POINTER TO SEQ SYMBOL LOCATION     *
$LMCSEQ  EQU   *-MCSEQ             LENGTH OF SEQ SYMBOL ENTRY
         SPACE 2
**-->  DSECT:  MCOPQUAD  FORMAT OF ONE OP ENTRY.  MACRO DEFINITIONS   *
*.        ARE TRANSLATED INTO ONE OPS FOR SUBSEQUENT INTERPRETATION   *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCOPQUAD DSECT
*        EACH STATEMENT BEGINS WITH A PARTIAL ONE OP GIVEN FIRST,     A
*        FOLLOWED BY 0 OR MORE NORMAL-SIZE ONE-OPS                    A
MCQUDNXT DS    A                   ADDRESS OF NEXT STMT'S CODE        A
MCQSTMNO DS    PL3                 STATEMENT NUMBER                   A
MCQS1FLG DS    C                   FLAGE BYTE OR UNUSED               A
$LMCOPL1 EQU   *-MCOPQUAD          LENGTH OF 1ST ONE-OP IN STMY       A
         SPACE 1                                                      A
*        FORMAT OF NORMAL ONE-OPS IN STATEMENT FOLLOWS                A
         ORG   MCOPQUAD            BACK TO BEGINNING                  A
MCBOPRTR DS    C                   OP CODE
MCARG1DX DS    C                   ARG #1 BSU INDEX
MCARG2DX DS    C                   ARG #2 BSU INDEX
MCRSLTYP DS    C                   RESULT TYPE
MCARG1LC DS    F                   ARG #1 LOCATION
MCARG2LC DS    A                   ADDRESS OF ARGUMENT #1             A
MCRESULT DS    F                   RESULT
$LMCQUAD EQU   *-MCOPQUAD          LENGHT OF ONE-OP
         SPACE 2
**-->  DSECT:  MCBSTRMS   FORMAT OF TWO BSU'S FOR EASE                *
*.        OF MANIPULATION IN TERM STACK                               *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCBSTRMS DSECT
MCBSFLG1 DS    C                   TERM #1 FLAG BYTE
MCBSNDX1 DS    C                   TERM #1 BSU INDEX
MCBOFST1 DS    C                   TERM #1 OFFSET
MCBLN1   DS    C                   TERM #1 LENGTH
MCBSLOC1 DS    F                   TERM #1 LOCATION OR VALUE
MCBSFLG2 DS    C                   TERM#2 FLAG BYTE
MCBSNDX2 DS    C                   TERM #2 BSU INDEX
MCBOFST2 DS    C                   TERM #2 OFFSET
MCBLN2   DS    C                   TERM #2 LENGTH
MCBSLOC2 DS    F                   TERM #2 LOCATION OR VALUE
         SPACE 2
*.-->  DSECT:  MCBOPRST    FORMAT OF OPERATOR STACK ENTRY             *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MCBOPRST DSECT
MCBOPFL  DS    C                   OPERATOR FLAGS
MCBSOPST DS    C                   OPERATOR BSU INDEX
MCBOPOF  DS    C                   OFFSET
MCBOPHR  DS    C                   OPRTR HIERARCHY
MCBOPVAL DS    F                   NOT USED
         SPACE 2
**--> DSECT: MXPNTSAV       CONTROL FOR LEVEL OF MACRO EXPANSION * *  S
*.       ONE IS ALLOCATED FOR EACH LEVEL OF MACRO CALL                A
*.       NAMES:MXP_____                                               A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXPNTSAV DSECT
MXPNLINK DS    A                   @ LAST PREVIOUS MXPNTSAV           A
MXPLSYPT DS    F                   PNTR TO SYM PARAM D.V.'S
MXPSYSDX DS    PL3                 CURRENT SYSNDX VALUE
MXPNFLG1 DS    C                   FLAG BYTE
MXPCHRBF DS    F                   PNTR TO CHAR BUFFER FOR CATEN OPRTNS
MXPNMCLB DS    F                   PNTR TO MAC LIB ENTRY
MXPNKYPT DS    F                   PNTR TO 1ST KEYWORD SYM PAR DV
MXPNKLPT DS    F                   PNTR TO 1ST KEYWORD DICT ENTRY
MXPNLDBS DS    F                   PNTR TO SET SYMB LOCAL DICT
MXPNCDPT DS    F                   PNTR TO 1ST INSTRUCTION
MXPNCRCD DS    F                   PNTR TO CURRENT INST
MXPNBOPS DS    F                   NBR OF POSITIONAL OPRNDS
MXPNLSPT DS    F                   PNTR TO SYM PAR DICT ENTRIES
$LMXPTSV EQU *-MXPNTSAV            LEN OF DYNAMIC WORK AREA IN MEXPND
         SPACE 2
**-->  DSECT:  MCPAROPR  FORMAT FOR SYMBOLIC PARAMETER DICTIONARY     *
*.        ENTRY.  ONE ENTRY FOR EACH SYM PARAM ON ENTRY TO MEXPND     *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCPAROPR DSECT
MCPAROFL DS    C                   OPRNDS FLAGS
MCPAROLN DS    C                   OPRND LENGTH, IE K'
MCPARONB DS    C                   # OF SUBOPRNDS IE N'
MCPAROTP DS    C                   OPRND TYPE, IE N, O OR U
MCPAROPT DS    F                   POINTER TO OPRND
MCPRSBPT DS    F                   POINTER TO LSUB OPRND LIST
$LMPAROP EQU   *-MCPAROPR          LEN OF SYM PAR DICT ENTRY
         SPACE 2
**-->  DSECT:  MCPARSUB   FORMAT FOR DICT ENTRY FOR SUBLIST OPRNDS    *
*.        ONE ENTRY FOR EACH ELEMENT OF SUBLIST OF SYM PARAM ENTRY    *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MCPARSUB DSECT
MCPARSFL DS    C                   SUBOPRND FLAGS
MCPARSNU DS    C                   NOT USED
MCPARSTP DS    C                   SUB OPRND TYPE
MCPARSLN DS    C                   SUB OPRND LENGTH
MCPARSPT DS    F                   PNTR TO SUB OPRND
$LMPARSB EQU   *-MCPARSUB          LEN OF SUBLIST OPRND ENTRY
         AIF   (NOT &$DEBUG).MACDBG          SKIP IF DEBUG
         XSET  XSNAP=OFF           KILL REMAINING XSANPS
.MACDBG  ANOP
         PRINT ON,NOGEN
         TITLE '*** MACINT - MACRO INITIALIZATION ROUTINE'            S
**--> CSECT:  MACINT    THIS ROUTINE IS CALLED IN INITIALIZATION      *
*.       PHASE OF ASSIST.  IT PERFORMS CERTAIN REQUIRED STORAGE       *
*.       ALLOCATION AND SETS POINTERS AVGEN1CD AND AVGEN2CD.          *
*.       OVERFLOW MESSAGE FOR GENERAL USE IS ALSO CREATED.            *
*.                                 G.M.CAMPBELL - SUMMER - 1972       *
*.                                                                    *
*.       USES MACROS:  $ALLOCL, $SAVE, $RETURN, $CALL                 *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.       REGISTER USAGE:                                              S
*.             WORK REGS:  RA,RB                                      S
*.                                                                    *
*.*********************************************************************
         SPACE
MACINT   CSECT
         $DBG  ,NO
          $SAVE                    SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         MVI   AVMSNBY1,X'FF'      TURN OFF SNAPS                     S
         MVI   AVMSNBY2,X'FF'      TURN OFF SNAPS                     S
         AIF   (&$DEBUG).MACINT1   SKIP IF  IF NOT DEBUG
         MVI   AVMSNBY1,X'00'      CLEAR SNAP BYTE 1
         MVI   AVMSNBY2,X'00'      CLEAR SNAP BYTE 2
         XSNAP LABEL='***MACINT ENTERED***',IF=(AVMSNBY1,O,$MSNP01,TM)
.MACINT1 ANOP
         MVC   AVMBYTE1(4),AWZEROS   CLEAR FLAGS
         LA    RA,AVMWRK1+255      GET UPPER LIMIT OF WORK AREA1
         ST    RA,AVMWRKL1         SAVE IN MAIN CONTROL AREA
         LA    RA,AVMWRK2+255      GET WORK AREA2 LIMIT
         ST    RA,AVMWRKL2         SAVE IN MAIN CONTROL AREA
         SPACE 2
         XC    AWZEROS(256),AWZEROS    ZERO TABLE                     S
         TM    AVTAGSM,AJOMACRO    MACRO OPTION USED?
         BZ    MACINTRT            RETURN IF NOT
         SPACE 1
*        CONSIDER MODIFYING CODE FOR LIST HANDLING ********************
         LA    RB,$LMACLIB+$LGLBENT+$LCHWRK   TOTAL WORKAREA LENGTH   J
         $ALLOCL  RA,RB,MCINITOV   GET DUMMY AREA FOR MACLIB
         ST    RA,AVMACLIB         STORE @ IN MAIN TABLE
         MVC   0($LMACLIB+$LGLBENT,RA),AWZEROS  ZERO MAC,GBLX TABLES  A
         USING MACLIB,RA           NOTE USING ON MACLIB ENTRY
         OI    MCLBTAGS,AVMCLBDF   SET DEFINED FLAG ON DUMMY
         DROP  RA
*              SPACE FOR 1 DUMMY MCGLBDCT.                            J
         LA    RA,$LMACLIB(,RA)    BUMP PTR BEYOND MACRO ENTRY        J
         ST    RA,AVMGDICT         STORE @ IN MAIN TABLE
         SPACE 1                   REMV OLD MVC                       J
*              BUMP, POINT AT $LCHWORK BYTES FOR CHARACTER WORKAREA.  J
         LA    RA,$LGLBENT(,RA)    BUMP PTR BEYOND GBLX ENTRY         J
         ST    RA,AVMCHSTR         SAVE @ IN AVWXTABL
         LA    RA,$LCHWRK-1(RA)    GET @ OF LAST BYTE
         ST    RA,AVMCHLIM         SAVE @ IN AVWXTABL
         LA    RA,MCINITOV         GET @ OF OVRFLW ROUTINE
         ST    RA,AVMOVRFL         SAVE IN AVWXTABL
         MVC   AVMACNST,AWZEROS    INIT NEXTING COUNT TO ZERO
         MVC   AVMMACID,AWZEROS    INITIALIZE MACRO ID TO ZERO
         ZAP   AVMSYSDX,AWP0       INIT SYSNDX TO ZERO
MACINTRT EQU   *
         MVC   AVGEN1CD,AVADDHIH   INIT EXPANSION POINTER 1
         MVC   AVGEN2CD,AVADDHIH   INIT EXPANSION POINTER 2
         XSNAP LABEL='***MACINT EXITED*** ',IF=(AVMSNBY1,O,$MSNP01,TM)
         $RETURN  SA=NO
         SPACE 2                                                      S
**--> INSUB: MCINITOV       OVERFLOW ROUTINE + + + + + + + + + + + + +S
*+       CALLED BY ANY ROUTINE WHEN STORAGE OVERFLOW OCCURS.         +S
*+       -- TERMINATES SECOND PASS                                   +S
*+                                                                   +S
*+       USES MACROS:  $SPIE,$CALL                                   +S
*+       EXIT CONDITIONS:  PROGRAM MARKED NON-EXECUTABLE             +S
*+       CALLED BY:  MACRO1,MCGTEST,MCBODY, AND MCGNCD               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCINITOV EQU   *                   PROGRAM EXITS TO HERE IF OVERFLOW
         BALR  R15,0               **KLUDGE** NONSTANDRD BR'S *********
         USING *,R15               SHOULD HAVE THIS USING
*        **WARNING** MACRO1 & MEXPND CANNOT BOTHE BE ACTIVE FOR THIS.
         L     R1,AVMBSPIE         GET @ LAST PREVIOUS SPIE BLK
         OI    AVTAGS2,AJOASTOP    STOP 2ND PASS PROCESSING
         $SPIE ACTION=(RS,(1))     RESTORE PREVIOUS PTR
         $CALL MOSTOP              GO TO MOSTOP TO QUIT
         LTORG
         DROP  RAT,R15
         TITLE '***  MACRO1 - MAIN ROUTINE FOR MACRO DEFINITION'
**-->  CSECT:  MACRO1   CALLED BY MAIN CONTROL WHEN MACRO OPCODE      *
*.        ENCOUNTERED.  AT PRESENT (DEC 31, 1971) ONLY MACRO          *
*.        DEFINITIONS ARE ALLOWED, NO CONDITIONAL ASSEMBLY.  MACRO1   *
*.        CREATES ENTRY IN MACLIB FOR FUTURE EXPANSION BY MEXPND      *
*.        ENTRY CONDITIONS                                            *
*.     RA = SCAN POINTER @ OF OPERAND                                 *
*.     RC = @ OPCODTB ENTRY FOR OPERATION                             *
*.                                                                    *
*.        CALLS MACSCN,OUTPT2,MACFND,ERRTAG,ERRLAB,MCVSCN,MCSCOP,     *
*.              MCBODY                                                *
*.        USES MACROS: $SAVE,$RETURN,$CALL,$ALLOCL                    *
*.        USES DSECTS: RSBLOCK,OPCODTB,AVWXTABL,MACLIB,MCPARENT       *
*.                                                                    *
*.       REGISTER USAGE:                                              S
*.             WORK REGS: R0,R1,R2,RA,RB,RD,RE                        S
*.             BASE REGS: RAT,RW,RX,RY,R13,RC                         S
*.             UNUSED: RZ                                             S
*.                                                                    S
*.*********************************************************************
         XSET  XSNAP=OFF                                              A
         SPACE
MACRO1   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT        NOT MAIN TABLE USING
         XSNAP LABEL='***MACRO1 ENTERED***',IF=(AVMSNBY1,O,$MSNP02,TM)
         L     RW,AVRSBPT          GET @ OF SOURCE STATEMENT
         USING RSBLOCK,RW          ESTAB BASE FOR SOURCE
         USING OPCODTB,RC          ESTAB BASE FOR OPCODE ENTRY
         AIF   (&$DEBUG).MACQQ00   SKIP IF NO DEBUF
         $SPIE ,,ACTION=CR,CE=MCBSPIEP
         ST    R1,AVMBSPIE         SAVE PREV INT @
.MACQQ00 ANOP
         LA    RA,RSBSOURC         SET SCAN POINTER
         LR    R0,RC               SAVE RC ACROSS MACSCN CALL         A
         $CALL MACSCN              SCAN SOURCE STATEMENT FOR FIELDS
         LR    RC,R0               RESTORE RC                         A
         L     RA,AVMFLD2          GET OPCODE ADDRESS
         CLI   OPCHEX,$MACRO       OPCODE=MACRO?
         BNE   MACR1R01            ERROR IF NOT
         TM    AVPRINT1,AVPRSAVE   AFTER START STMNT OR EQUIV?
         BO    MACR1R01            ERROR IF YES
         AIF   (NOT &$MACOPC).MAC1A  BRANCH IF NO OPEN CODE           S
         TM    AVMTAG00,AVMNOMAC   MACROS ALLOWED?                    S
         BO    MACR1R01            MACROS NOT ALLOWED                 S
.MAC1A   ANOP                                                         S
         CLI   AVMFLDT1,X'00'      LABEL PRESENT?
         BE    MACRO101            OK IF NOT
         LA    RB,$ERILLAB         SET ERROR FLAG IF YES
         $CALL ERRLAB              MARK STATEMENT
MACRO101 EQU   *
MCR1PRNT EQU   *
         LA    RB,$OUCOMM          SET PRINT FLAG
         $CALL OUTPT2              PRINT STATEMENT
         MVC   AVMBYTE1(3),AWZEROS CLEAR ALL FLAGS
         L     RA,AVMMACID         GET PREV MACRO ID
         LA    RA,1(RA)            INCREMENT BY ONE
         ST    RA,AVMMACID         RESTORE CURRENT ID
*
*  NEXT SECTION READS AND PROCESSES THE PROTOTYPE STATEMENT
*
         BAL   RET,MACRORD         READ PROTOTYPE STMT
         LA    RA,RSBSOURC         SET SCAN POINTER TO ASTART
MACPROT1 EQU   *
         $CALL  MACSCN              SCAN SOURCE FOR FIELDS
         CLI   AVMFLDT2,C'I'       OPCODE = MACRO INSTRUCTION?
         BNE   MACR1DUM            IF ERR-BRANCH-BAD PROTOTYPE        S
*                                                                     S
*        IMPROPER PROTOTYPE STMT FOUND OR PREVIOUSLY DEFINED MACRO-   S
*        ERROR FLAGS SET AND UNIQUE NAME INSERTED.                    S
*                                                                     S
*                                                                     S
*        SCAN MACRO LIBRARY FOR MACRO NAME --                         S
*              PREVIOUSLY DEFINED FLAGGED AS ERROR                    S
*              NOT PREVIOUSLY DEFINED ==> OK                          S
*                                                                     S
MACPROT2    EQU   *
         SR    RE,RE               ZERO RE FOR EX USE
         IC    RE,AVMFLDL2         GET LENGTH OF SYMBOL
         BCTR  RE,0                DECR LENGTH FOR EX INST
         MVC   AVMSYMBL,AWBLANK    BLANK OUT COMMON SYMBOL FIELD
         L     RA,AVMFLD2          MOVE @ OPCODE TO SCAN PNTR
         EX    RE,MCMVSYM          MOVE SYMBOL INTO AVMSYMBL FOR SEARCH
         MVC   AVMSYMLN(1),AVMFLDL2 MOVE SYMBOL LENGTH INTO COMMON AREA
         L     RC,AVMACLIB         GET @ OF MACRO LIBRARY
         USING MACLIB,RX           SET USING FOR MACLIB ENTRY
         $CALL MACFND              SEARCH MACRO LIBRARY FOR SYMBOL
         LTR   RB,RB               ALREADY THERE?
         BNZ   MACPROT3            IF NOT, ENTER
         LR    RX,RC               MOVE BASE TO RX
         TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED?
         BNO   MACPROT4            NO, JUST MARK DEFINED NOW          S
         SPACE 1                                                      S
*              EITHER INCORRECT OR DUPLICATE MACRO NAME - GET @       S
*              OF DUMMY MACLIB HAVING X'00' AS MACRO NAME (ALWAYS     S
*              POINTED TO BY AVMACLIB - THIS DUMMY IS REUSED FOR ALL  S
*              SUCH ERRONEOUS MACROS.  ALSO FLAG ERROR.               S
MACR1DUM LA    RB,$ERILMNM         DUPLICATE/BAD MACRO NAME           S
         L     RA,AVMFLD2          GET @ OF OPCODE                    S
         $CALL ERRTAG              CALL ERROR FLAGGING                S
         L     RX,AVMACLIB         GET @ OF DUMMY ELEMENT             S
         MVC   MCLBFLG2($LMACLIB-(MCLBFLG2-MACLIB)),AWZEROS   RECLEAR S
         B     MACPROT4            AND PROCEED
*                                                                     S
*        MACRO NAME DEFINED AND ENTERED IN LIBRARY, SPACE ALLOCATED   S
*                                                                     S
MACPROT3 EQU   *
         LR    RX,RC               MOVE LIB ENTRY PNTR TO RX
         LA    RE,$LMACLIB         GET LENGTH OF MACRO LIN ENTRY
         $ALLOCL RD,RE,MCOVRPR     GET AREA FOR NEW ENTRY
         ST    RD,MCLIBNXT         SAVE @ OF NEW ENTRY IN PREV ENTRY
         LR    RX,RD               MOVE BASE TO RD
         MVC   MACLIB($LMACLIB),AWZEROS   ZERO NEW ENTRY
         MVC   MCLBNMLN(9),AVMSYMLN  MOVE NAME INTO LIBRARY
         SPACE
*   MACLIB ENTRY ESTABLISHED.  &SYSECT, &SYSNDX AND &SYSLIST ARE NEXT
*   ENTERED IN PARAMETER LIST
         SPACE
MACPROT4 EQU   *
         OI    MCLBTAGS,AVMCLBDF   SET DEFINED FLAG
         USING MCPARENT,RY         SET USING FOR PARAM ENTRY
         LA    RE,(MACSVAR#+1)*$LPARENT   GET SLOTS FOR SYSTEM        A
         $ALLOCL  RY,RE,MCOVRPR     GET SPACE FOR ENTRY
         MVC   MCPARNLN(MCPARNTL),MACSVAR1   MOVE &SYSECT ENTRIES     J
         LA    R1,AVSYSECT         GET @ OF CURRENT CSECT NAME
         ST    R1,MCPROPRN         SAVE IN ENTRY
         ST    RY,MCPARPNT         SAVE POINTER IN MACLIB ENTRY
         LA    RC,$LPARENT(,RY)    @ OF NEXT ENTRY                    A
         ST    RC,MCPARNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RC               MOVE BASE TO NEW ENTRY
         MVC   MCPARNLN(MCPARNTL),MACSVAR2   MOVE &SYSNDX ENTY        J
         MVC   MCPROPRN,AWZEROS    SET POINTER TO ZERO
         LA    RC,$LPARENT(,RC)    @ OF NEXT ENTRY                    A
         ST    RC,MCPARNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RC               MOVE AASE TO NEW ENTRY
         MVC   MCPARNLN(MCPARNTL),MACSVAR3   MOVE &SYSLIST ENTRY      J
         SPACE
*    SYSTEM VARIABLES ENTERED IN PARAM LEST.  NEXT GET LABEL IF ANY
         SPACE
         LA    RC,$LPARENT(,RC)    @ OF NEXT ENTRY
         ST    RC,MCPARNXT         SAVE LINK IN PREV ENTRY
         LR    RY,RC               MOVE BASE TO NEW ENTRY
         MVC   MCPARENT($LPARENT),AWZEROS ZERO OUT ENTRY
         L     RA,AVMFLD1          GET @ OF LABEL, IF ANY
         LTR   RA,RA               IS THERE A LABEL
         BZ    MCPARSCN            IF NOT, PROCEED WITH OPERAND SCAN
         $CALL MCVSCN              ELSE SCAN LABEL FIELD
         LTR   RB,RB               VARIABLE SYMBOL?
         BZ    MCLAB01             OKAY IF RB = 0
         LA    RB,$ERINVSY         ELSE FLAG INVALID SYMBOL
MACLABER EQU   *
         $CALL ERRLAB              FLAG ERROR
         B     MCPARSCN            RESUME SCAN AFTER FLAGGING ERROR
         SPACE
MCMVSYM  MVC   AVMSYMBL($),0(RA)   DUMMY FOR EX INST TO MOVE SYMBOL
         SPACE
*                                                                     S
*        SCAN FOR &LABEL -- IF NOT MULTIPLY DEFINED ENTER IN          S
*        PARAMETER LIST                                               S
*                                                                     S
MCLAB01  EQU   *
         L     RC,MCPARPNT         GET @ OF PARAM LIST
         $CALL MACFND              SCAN LIST
         LTR   RB,RB               NAME ALREADY PRESENT
         BNZ   MCLAB02             OKAY IF NONZERO
         LA    RB,$ERMULDF         ELSE SET MULTIPLE DEF FLAG
         B     MACLABER            BRANCH AND FLAG ERROR
MCLAB02   EQU  *
         MVC   MCPARNLN(9),AVMSYMLN       MOVE LABEL NAME INTO ENTRY
         MVI   MCPARTYP,C'P'       SET ENTRY TYPE TO POSITIONAL
         SPACE
*  START SCAN OF PARAMETER OPERAND FIELD
         SPACE
MCPARSCN CLI   AVMFLDL3,X'00'      OPERAND PRESENT?
         BE    MACRO1RT            IF NOT, FINI
         L     RA,AVMFLD3          ELSE GET @ OF OPERAND IN SCAN PNTR
         SPACE 2                                                      S
*        BEGIN LOOP TO SCAN MACRO PARAMETER LIST                      S
         SPACE 1                                                      S
MCPARST  EQU   *
         LR    R0,RA               COPY SCAN POINTER TEMPORRARILY
         $CALL MCVSCN              SCAN NEXT SYMBOL
         LTR   RB,RB               VAR SYMBOL OK?
         BZ    MCPRSC01            IF YES, PROCEED
         LA    RB,$ERINVSY         IF RB ›= 0, ILLEGAL                S
         B     MACR1TG1            FLAG STNT
         SPACE
*        HAVE LEGAL PARAMETER -- SCAN, DETERMINE TYP) AND INSERT      S
*                                                                     S
MCPRSC01 EQU   *
         CLI   0(RA),C'='          KEYWORD PARAMETER?
         BE    MCPRSC11            IF YES, OKAY
         TM    AVMBYTE1,$MKEYOPR   KEYWORD ALREADY PROCESSED?
         BO    MACR1R03            ERROR IF YES
***************  POSSIBLE CHANGE FOR ASM H OR VS  ***************     S
*                                                                     S
*        LEGAL PARM FOUND -- INSERT IF NOT DUPLICATE                  S
*                                                                     S
MCPRSC11 EQU   *
         ST    RA,AVMTSCNP         SAVE SCAN POINTER TEMPORARILY
         L     RC,MCPARPNT         GET @ OF PAR LIST
         $CALL MACFND              SEARCH PARAMETER LIST
         LTR   RB,RB               SYMBOL ALREADY PRESENT?
         BNZ   MCPRSC02            IF NOT, OKAY
         LR    RA,R0               RESTORE SCAN POINTER FOR ERROR MSG
MCPRSCMD LA    RB,$ERMULDF         SET MULT DEF FLAG
         B     MACR1TG1            BRANCH AND FLAG STMT
*
*        ALLOCATE SPACE FOR PARM ENTRY, CHACK TYPE AND BUMP COUNTERS  S
*                                                                     S
MCPRSC02 LA    RE,$LPARENT         GET LENGTH OF PAR ENTRY
         $ALLOCL R1,RE,MCOVRPR     GET AREA FOR NEW ENTRY
         ST    R1,MCPARNXT         PUT POINTER IN PREV ENTRY
         LH    R2,MCPARNDX         GET CURRENT OPERAND COUNT
         LR    RY,R1               MOVE BASE TO NEW ENTRY
         MVC   MCPARENT($LPARENT),AWZEROS   CLEAR ENTRY
         MVC   MCPARNLN(9),AVMSYMLN     MOVE SYMBOL INTO NIE ENTRY
         LA    R1,1(R2)            BUMP OPERAND COUNT BY ONE
         STH   R1,MCPARNDX         RESTORE NEW COUNT
         STH   R1,MCPOPRNB         UPDATE TOTAL NBR OF OPRNDS
         L     RA,AVMTSCNP         RESTORE SCAN POINTER
         CLI   0(RA),C'='          KEYWORD PARAMETER?
         MVI   MCPARTYP,C'P'       ELSE SET TYPE = POSITIONAL
         BNE   MCPRSC06            JUMP OUT IF POSITIONAL             A
         SPACE
*        KEYWORD PARM FOUND -- PROCESS ACCORDINGLY                    S
*                                                                     S
MCPRSCK  LA    RA,1(RA)            BUMP SCAN PNTR PAST '='
         MVI   MCPARTYP,C'K'       IDENTIFY AS KEYWORD OPERAND
         ST    RA,AVMTSCNP         SAVE SCAN PNTR TEMPORARILY
         NI    AVMBYTE1,X'FF'-$MSBLIST  TURN OFF SUBLIST FLAG
         OI    AVMBYTE1,$MKEYOPR   SET KEYWORD OPRND FLAG
         $CALL MCSCOP              SCAN OPERAND
         LTR   RB,RB               OPERAND OK?
         BNZ   MACR1TG1            IF NOT, BRANCH AND FLAG
         STC   RD,MCPRATYP         SAVE ATTRIBUTE TYPE
         STC   RC,MCPROPLN         STORE LENGTH
         LH    RE,MCKOPRNB         GET KEYWORD COUNT
         LA    RE,1(RE)            BUMP KEYWORD COUNT
         STH   RE,MCKOPRNB         RESTORE NEW COUNT
         LTR   RC,RC               CHECK FOR NULL STRING
         BZ    MCPRSC03            IF YES, GO TO NEXT OPERAND
         LA    RE,3+1(,RC)         ROUND TO FULLWORD+1 FOR DELIM AFTERJ
         SRL   RE,2                SHIFT RIGHT TO TRUNCATE 2 BITS
         SLL   RE,2                SHIFT LEFT TO RESTORE
         $ALLOCL RB,RE,MCOVRPR     GET AREA FOR KEYWORD VALUE
         ST    RB,MCPROPRN         SAVE STND VALUE @ IN ENTRY
*              OMIT  BCTR RC,0 : USE LENG RATHER THAN LENG-1, SO WILL J
*              PICK UP DELIMITER AFTER VALUE.  HELPS MEXPND SCAN OK   J
         L     RE,AVMTSCNP         RESTORE SCAN POINTER FOR OPRND MOVE
         EX    RC,MCMVOPRN         MOVE KEYWORD VALUE INTO ENTRY
*                                                                     S
*        PROCESS SUBLISTED PARAMETERS                                 S
*                                                                     S
MCPRSC03 EQU   *
         CLI   MCPRATYP,C'S'       SUBLIST?
         BNE   MCPRSC06            PROCEED IF NOT
         LR    R0,RA               COPY SCAN PNTR
         L     RA,AVMTSCNP         GET ORIGINAL SCAN PNTR
         LA    RA,1(RA)            BUMP PAST '('
         OI    AVMBYTE1,$MSBLIST   SET SUBLIST FLAG
*                                                                     S
*        BEGIN LOOP TO PROCESS SUBOPERANDS                            S
*                                                                     S
MCPRSC05 EQU   *
         $CALL MCSCOP              SCAN SUBOPRND
         LTR   RB,RB               OKAY?
         BNZ   MACR1TG1            IF NOT, BRANCH AND FLAG
         CLI   0(RA),C')'          END OF SUBLIST?
         LA    RA,1(RA)            BUMP PAST DELIM
         BNE   MCPRSC05            RESUME SCAN IF NOT END
         LR    RA,R0               ELSE RESTORE SCAN PNTR
*                                                                     S
*        DELIMETER CHECK                                              S
*                                                                     S
MCPRSC06 EQU   *
         CLI   0(RA),C' '          END OF OPERAND?
         BE    MACRO1RT            BRANCH AND PRINT IF YES
         CLI   0(RA),C','          DELIM = ','?
         BE    MCPRBMP             OK IF YES
         LA    RB,$ERINVDM         ELSE SET BAD DELIM FLAG
         B     MACR1TG1            BRANCH AND FLAG
MCPRBMP  EQU   *
         LA    RA,1(RA)            BUMP SCAN POINTER
         CLI   0(RA),C' '          BLANK AFTER ','?
         BNE   MCPARST             RESUME SCAN IF NOT
         SPACE 1
*        POSSIBLE NON-STD CONT CARDS -- MACROS ONLY                   S
         CLI   RSBNUM,1            ONLY 1 CARD?
         BE    MCPARST             RESUME SCAN IF YES
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    RA,RB               POINTING AT WHICH CARD?
         BNH   MCPRCO#2            PROCESS 2ND CARD IF LOW
         CLI   RSBNUM,3            TWO CONT CARDS?
         BNE   MCPARST             RESUME SCAN IF NOT
         LA    RB,RSOLC(RB)        POINT TO 1ST BYTE, 3RD CARD
         CR    RA,RB               WHERE IS SCAN POINTER?
         BH    MCPRCO#3            CHECK FOR 4TH CARD
MCPRCO#2 EQU   *
         LR    RA,RB               MOVE SCAN POINTER TO CONT CARD
         B     MCPARST             GO BACK FOR NEXT OPRND
         SPACE 2
MCPRCO#3 EQU   *
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BNE   MCPARST             RESUME SCAN IF NOT
         LA    RB,$OUCOMM          SET PRINT FLAG
         $CALL OUTPT2              PRINT STMT
         BAL   RET,MACRORD         GET NEXT STMT
         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG
         LA    RA,RSBSOURC         POINT TO START OF STMT
         CLC   0(15,RA),AWBLANK    ALL BLANKS IN COL 1-15?
         BE    MCPRCO#4            OKAY IF YES
         LA    RB,$ERCONT          ELSE SET ERROR FLAG
         $CALL ERRTAG              FLAG STMT
MCPRCO#4 EQU   *
         LA    RA,15(RA)           BUMP SCN PNTR TO COL 16
         B     MCPARST             AND RESUME SCAN
MCMVOPRN MVC   0($,RB),0(RE)       DUMMY FOR EX INSTR TO MOVE OPRND   S
         SPACE 2
**--> INSUB: MACRORD       MACRO READER  + + + + + + + + + + + + + + +S
*+       CALLED BY MACRO1 THREE PLACES:                              +S
*+             1ST TO READ PROTOTYPE STMT                            +S
*+             2ND TO CHECK FOR CONT CARDS (MACRO)                   +S
*+             3RD TO GET NEXT CONT CARD (NON-MACRO)                 +S
*+       ENTRY CONDS:                                                +S
*+             RETURN POINT = RET                                    +S
*+       EXIT CONDS:                                                 +S
*+             AVMBYTE5 (ERROR FLAG) SET IF MORE THAN ALLOWED        +S
*+             CONTINUATION CARDS  (LIMIT = 3)                       +S
*+       CALLS:  INCARD TO ACTUALLY READ CARDS                       +S
*+               ERRTAG FOR ERROR PROCESSING                         +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACRORD  EQU   *
         ST    RET,MACRDSAV        SAVE RETURN @
         $CALL INCARD              READ NEXT STMT
         STC   RB,AVMBYTE5         SAVE ERROR FLAG
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BE    MACRDRTN            PROCEED IF YES
         LTR   RB,RB               ELSE TEST FOR OTHER ERROR
         BZ    MACRDRTN            RETURN IF NONE
         $CALL ERRTAG              ELSE FLAG STMT
         TM    AVTAGS2,$INEND2     END OF FILE ERROR?
         BO    MACRO1RT            RETURN IF YES
MACRDRTN EQU   *
         L     RET,MACRDSAV        RESTORE RETURN @
         BR    RET                 AND RETURN
MACRDSAV DS    F                   SPACE FOR RETURN @
         SPACE 4
*        ERROR ROUTINE CALLED WHEN ERROR FOUND IN MAC DEF             S
*                                                                     S
MACR1R01 EQU   *
         AIF   (NOT &$MACOPC).MAC1B  BRANCH IF NO OPEN CODE           S
         EJECT                                                        S
*        MAIN CONTROL BLOCK FOR OPEN CODE CONDITIONAL ASSEMBLY        S
*                                                                     S
*              REGISTER USAGE FOR THIS SECTION:                       S
*                                                                     S
*              R0  - WORK REG                                         S
*              R1  - PTR TO CONTROL TABLE AND TRT REG                 S
*              R2  - PTR TO CONTROL TABLE                             S
*              RW  - BASE FOR RSBLOCK                                 S
*              RX  - BASE FOR MACLIB                                  S
*              RY  - UNUSED (BUT --> BASE FOR MCPARENT IN MACRO1)     S
*              RZ  - BASE FOR MXPNTSAV AND WORK REG                   S
*              RA  - WORK REG                                         S
*              RB  - BASE FOR MCLCLDPV AND WORK REG                   S
*              RC  - BASE FOR OPCODTB AND WORK REG                    S
*              RD  - UNUSED                                           S
*              RE  - UNUSED                                           S
*              RAT - BASE FOR AVWXTABL                                S
*              R13 - BASE FOR THIS CSECT --> MACRO1                   S
*                                                                     S
         OI    AVMTAG00,AVMNOMAC   FLAG => NO MORE MACROS             S
         SR    R1,R1               CLEAR FOR TABLE INDEX              S
         IC    R1,OPCHEX           GET OPCODE INDEX                   S
         LA    R1,MC1CONTB(R1)     LOAD @ OF TABLE ENTRY              S
         L     RX,AVMACLIB         GET @ OF OPEN CODE MACLIB          S
*        SET UP MACLIB ENTRY AND LOCAL DICTIONARY DUMMY ENTRY,        S
*        IF NOT ALREADY DONE                                          S
         TM    AVMTAG00,AVMOPMIN   IS LOCAL DUMMY BUILT ?             S
         BO    MC1CLMCB            BRANCH IF YES                      S
         L     RD,AVMMACID         INCRESE MACID                      A
         LA    RD,1(RD)            INCREASE BY ONE                    A
         ST    RD,AVMMACID         STORE IT BACK                      A
         MVC   MACLIB+4($LMACLIB-4),AWZEROS  ZERO OUT MACLIB ENTRY    S
         MVC   MCLBNMLN(9),MC1OPNCD  ENTER NAME AND LENGTH INTO MACLIBS
*        ALLOCATE CORE FOR LOCAL DUMMY ENTRY (SEE MCBODY START)       S
         LA    RA,$LLCLDV+$LGLBENT GET LENGTH OF DICTS                A
         USING MCLCLDPV,RB         NOTE USING ON LOCAL DICT DOPE VECT S
         $ALLOCH  RB,RA,MC1OVRFL   GET AREA FOR ENTRY                 S
         ST    RB,MCDDVPNT         SAVE @ IN MACLIB                   S
         MVC   0($LLCLDV+$LGLBENT,RB),AWZEROS   CLEAR ENTRY           A
         MVI   MCLCLTYP,$ARITH     SET TYPE = ARITH FOR LENGTH        S
         MVI   MCLCLDIM+1,1        SET DIMENSION TO 1                 S
         DROP  RB                                                     S
         MVI   MCLOCDLN+3,4        INIT LENGTH OF DICT TO 4           S
         OI    AVMTAG00,AVMOPMIN+AVMNOMAC   SET FLAGS                 A
         OI    MCLBFLG2,$MCOCFL1   SHOW OPEN CODE                     A
         XSNAP LABEL='AFTER OPEN MACLIB',STORAGE=(*MACLIB,*MACLIB+100),X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
MC1CLMCB EQU   *                                                      S
         XSNAP LABEL='MCICLMB,R1 TABLE ENTRY'                         A
         TM    0(R1),$MC1DCL       DECLARE TYPE OPCODE ?              S
         BNO   MC1ACTON            NO, ACTION TYPE                    S
         TM    AVPRINT1,AVPRSAVE   LISTING CONTROL = SAVE ?           S
         BO    MC1NORM             BRANCH IF YES                      S
         TM    MCLBFLG2,$MCOCFL2   DECLARE TYPE ALLOWED ?             S
         BO    MC1NORM             NO, OUT OF ORDER                   S
         OI    AVMTAG00,AVMOPENC   SET FLAG TO SHOW IN OPEN           A
         LR    RC,RX               COPY @ MACLIB WHERE EXPECTED       J
         $CALL MCBODY              PROCESS STATEMENT                  S
         B     MC1RTN0             RETURN, RB=0                       S
*        ACTION TYPE MACRO OPCODE PROCESSED BELOW                     S
MC1ACTON EQU   *                                                      S
         XSNAP LABEL='ACTION TYPE FOUND'                              A
         TM    0(R1),$MC1ERR       ERROR FLAG ON ?                    S
         BO    MC1NORM             BRANCH IF YES                      S
         OI    MCLBFLG2,$MCOCFL2   DECLARE TYPES NO LONGER ALLOWED    S
         TM    AVMTAG00,AVMOPDIC   HAS OPEN CODE LOCAL DICT BEEN      S#
                                   ALLOCATED ?                        S
         BO    MC1SAVLO            BRANCH IF YES                      S
*        ALLOCATE SPACE FOR OPEN CODE LOCAL DICTIONARY AND MXPNTSAV   S
         L     RA,MCLOCDLN         GET LENGTH OF LOCAL DICT           S
         LA    RA,$LMXPTSV(RA)     ADD LENGTH OF MXPNTSAV             S
         $ALLOCH RB,RA,MC1OVRFL    GET CORE FOR LOCAL DICT            S
*        INITIALIZE LOCAL DICTIONARY AND MXPNTSAV TO ZEROS            S
         ST    RB,MC1PTSAV         SAVE POINTER TO ALLOCATED CORE     S
         LR    R0,RA               COPY OVER LENGTH FOR LATER USE     J
         BCTR  RA,0                DECR COUNT                         S
         EX    RA,MC1MOVZR         CLEAR LENGTH MOD 256               S
         SRA   RA,8                SHIFT TO GET # 256 BYTE BLOCKS LEFTS
         BNP   MC1DNZER            SKIP IF NO MORE TO DO              S
         N     R0,AWFXFF      REMOVE ALL BUT LAST BYTE OF LENGTH      J
         AR    RB,R0               ADD LENGTH, GET @ FIRST BYTE TO 0  J
         MVC   0(256,RB),AWZEROS   CLEAR 256 BYTES AT A TIME          S
         LA    RB,256(,RB)         INCMT TO NEXT BLOCK                S
         BCT   RA,*-10             LOOP, CLEAR TILL DONE              S
*        SET UP MXPNTSAV AND SET ACTR LIMIT                           S
MC1DNZER EQU   *                                                      S
         USING MXPNTSAV,RZ         BASE REG FOR MXPNTSAV              S
         L     RZ,MC1PTSAV         BASE REG FOR MXPNTSAV              S
         ST    RX,MXPNMCLB         STORE @ OF MACLIB ENTRY            A
         LA    RB,$LMXPTSV(RZ)     GET ADDR OF LOCAL DICTIONARY       S
         ST    RB,MXPNLDBS         SAVE @ IN MXPNTSAV                 S
         MVC   0(4,RB),AVMMACTR    SET ACTR LIMIT                     S
         OI    AVMTAG00,AVMOPDIC   FLAG => DICT ALLOCATED             S
*        CALL MCBODY TO CREATE ONE-OPS.  IF NO ERROR ON RETURN,       S
*        CALL MXINST TO INTERPRET THE ONE-OPS.  OTHERWISE RETURN.     S
MC1SAVLO EQU   *                                                      S
         MVC   MC1LOPTR(4),AVADDLOW  SAVE CURRENT LO PTR              S
         LR    RC,RX               COPY @ MACLIB WHERE EXPECTED       J
         XSNAP LABEL='BEFORE CALL MCBODY OC',                          X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         L     RD,AVADDHIH         GET HIGH PTR                       A
         LR    RE,RD               COPY INTO RE                       A
         STM   RD,RE,AVGEN1CD      STORE INTO AVGEN1DC,AVGEN2DC       A
         $CALL MCBODY              PROCESS STATEMENT                  S
         L     RA,MCCODLNK         GET # FIRST INSTRUCTION            A
         USING MCOPQUAD,RA         NOTE ONE/OP PTR                    A
         CLI   MCQS1FLG,$BSERR01   WAS IT IN ERROR                    A
         BNE   *+8                 SKIP AROUND RESET IF O.K.          A
         LA    R1,=AL1($MC1SKIP,$MC1RET)  FAKE NO MORE ACTION         A
         NI    AVMTAG00,255-AVMOPGO  TURN OFF AIF/AGO FLAG (AVMOPGO)  S
         TM    0(R1),$MC1SKIP      IS SKIP BIT ON ? (SKIP MXINST)     S
         BO    MC1RSTLO            IF YES, SKIP CALL TO MXINST        S
         L     RC,MC1PTSAV         LOAD @ OF MXPNTSAV                 S
         USING MXPNTSAV,RC          SET UP ANOTHER USING              Z
         MVC   MXPNCRCD(4),MCCODLNK  LOAD @ OF UST INSTR              A
         DROP  RZ,RC,RA                                               A
         XSNAP LABEL='BEFORE CALL TO MXINST'                          A
         XCALL MXINST              CALL TO INTERPRET ONE-OPS          S
         L     RD,AVGEN1CD                                            A
         L     RE,AVADDHIH                                            A
         XSNAP LABEL='AFTER MXINST',STORAGE=(*0(RD),*4(RD),*0(RE),*4(REX
               ))                                                     A
*        WIPE OUT ONE-OPS AND RETURN IF DONE                          S
MC1RSTLO EQU   *                                                      S
         MVC   AVADDLOW(4),MC1LOPTR  RESTORE AVADDLOW                 S
*              IF ORIGINAL STATEMENT NOT ALREADY PRINTED, GET IT      A
*              BACK FROM HIGH AREA AND SAVE IT VIA UTPUT1             A
         TM    AVPRINT1,AVPRSAVE   ALREADY IN SAVE MODE               A
         BZ    MC1ALPRT            NO, SO PRINTED STMT ALREADY        A
         $CALL INCARD              GET STMT BACK                      A
         OI    RSBFLAG,$RSBNP##    SHOW NO MORE PROCESSING            A
         $CALL UTPUT1              HAVE IT SAVED                      A
MC1ALPRT TM    0(R1),$MC1RET       IS RETURN BIT ON ?                 S
         BO    MC1RTN0             BRANCH IF YES                      S
*        PROCESS AIF, AGO AND ANYTHING ELSE NEEDING ACTION            S
         SR    R2,R2               CLEAR R2 FOR INDEX                 S
         IC    R2,1(R1)            LOAD JUMP CODE FROM CONTROL TABLE  S
         B     *+4(R2)             BRANCH ON INDEX                    S
         B     MC1AGO              BRANCH TO PROCESS AGO              S
         TM    AVMTAG00,AVMOPGO    WAS AIF SUCCESSFUL ?               S
         BNO   MC1RTN0             NOT SUCCESSFUL SO RETURN           S
*        AGO OR SUCCESSFUL AIF -- CHECK FOR ILLEGAL BACKWARD REFERENCES
MC1AGO   EQU   *                                                      S
         LA    RA,AVMSYMBL         LOAD @ OF SEQ SYMBOL               S
         SR    RB,RB               CLEAR RB FOR LENGTH-1 IF SYMBOL    S
         IC    RB,AVMSYMLN         LOAD LENGTH-1                      S
         STC   RB,MC1CLC1+1        STORE LENGTH IN CLC INSTR          S
         LA    RB,1(RB)            ADD 1 TO GET LENGTH                S
         LR    RZ,RB               COPY LENGTH FOR LATER              S
         $CALL SYFIND              LOOK UP SEQ SYMBOL                 S
         B     *+4(RB)             BRANCH ON RETURNED INDEX           S
         B     MC1SEQDF            BRANCH IF PREVIOUSLY DEFINED       S
*        SEQ SYMBOL NOT PREVIOUSLY DEFINED -->                        S
*        READ CARDS UNTIL SEQ SYMBOL OR END-OF-FILE FOUND             S
MC1READ  EQU   *                                                      S
         $CALL INCARD              READ NEXT SOURCE CARD              S
         TM    AVTAGS2,$INEND2     END-OF-FILE ?                      S
         BO    MC1EOF              BRANCH IF YES                      S
         CLI   RSBLOPC,C'.'        IS THIS A SEQ SYMBOL?              S
         BNE   MC1READ             IF NOT, READ NEXT CARD             S
         LA    RA,RSBSOURC         @ 1ST BYTE OF CARD                 S
         $SETRT  (' ',4)           STOP TRT ON BLANK                  S
         TRT   1(8,RA),AWTZTAB     SCAN FOR BLANK                     S
         $SETRT  (' ',0)           REZERO TABLE                       S
         BZ    MC1READ             INVALID SEQ SYM -- IGNORE          S
         LR    RB,R1               @ OF BLANK                         S
         SR    RB,RA               GET LENGTH                         S
         CR    RB,RZ               IS IT = ONE WE WANT ?              S
         BNE   MC1AGOSY            NO, BUT SHOW DEFINED               S
MC1CLC1  CLC   AVMSYMBL($),0(RA)   COMPARE SYMBOLS                    S
         BE    MC1RTN4             SEQ SYM FOUND -- RETURN            S
MC1AGOSY $CALL SYENT1              ENTER SEQ SYM IN TABLE             S
*        IF WANTED, COULD SEE IF PREVIOUSLY DEFINED - WE IGNORE IT    S
         B     MC1READ             GO FOR NEXT CARD                   S
*        SEQUENCE SYMBOL PREVIOUSLY DEFINED -->                       S
*        (AS242 -- BACKWARDS AIF/AGO IN OPEN CODE)                    S
MC1SEQDF EQU   *                                                      S
         MVC   AVRSBLOC(MC1MSEQU),MC1MSSG   MOVE ERROR MSG INTO       S#
                                   RSBLOCK  (AS242)                   S
         B     MC1RTN4             RETURN                             A
*        END-OF-FILE ENCOUNTERED BEFORE SEQ SYMBOL FOUND -->          S
*        (AS241 - SEQUENCE SYMBOL NOT FOUND)                          S
MC1EOF   EQU   *                                                      S
         MVC   AVRSBLOC(MC1MSEQ2),MC1MSSG2  MOVE ERROR MSG INTO RSB   S
*        RETURN SHOWING NEXT SOURCE ALREADY IN RSBLOCK                S
MC1RTN4  EQU   *                                                      S
         LA    RB,4                SET RETURN CODE                    S
         B     MACRO1FN            RETURN                             S
*        RETURN SHOWING NEXT SOURCE NOT IN RSBLOCK                    S
MC1RTN0  EQU   *                                                      S
         SR    RB,RB               CLEAR FLAG REGISTER                S
         B     MACRO1FN            BRANCH TO RETURN                   S
*                                                                     S
*        OVERFLOW EXIT  --  HALT ASSEMBLY                             S
*                                                                     S
MC1OVRFL EQU   *                                                      S
         OI    AVTAGS2,AJOASTOP    STOP 2ND PASS PROCESSING           S
         $CALL MOSTOP              GO TO MOSTOP TO QUIT               S
*                                                                     S
*        MACRO1 DC/DS/DUMMYS FOR OPEN CODE                            S
MC1MOVZR MVC   0($,RB),AWZEROS     DUMMY INSTR                        S
MC1LOPTR DC    F'0'                WORD TO SAVE CURRENT AVADDLOW      S
MC1PTSAV DC    F'0'                WORD TO SAVE PTR TO MXPNTSAV       S
MC1MSSG  DC    AL1(MC1MSEQU,$RSBNPNN+$RSBMERR,1,0)                    A
         DC    C'242 BACKWARDS AIF/AGO ILLEGAL'                       S
MC1MSEQU EQU   *-MC1MSSG                                              S
MC1MSSG2 DC    AL1(MC1MSEQ2,$RSBNPNN+$RSBMERR,1,0)                    A
         DC    C'241 SEQUENCE SYMBOL NOT FOUND'                       S
MC1MSEQ2 EQU   *-MC1MSSG2                                             S
MC1OPNCD DC    X'08',CL8'OPEN-CDE'                                    S
         EJECT                                                        S
*        MACRO1 CONTROL TABLE FOR OPEN CODE CONDITIONAL ASSEMBLY      S
*                                                                     S
*              THE FIRST BYTE CONTAINS FLAG BITS;                     S
*              BYTE 2 CONTAINS JUMP CODES                             S
         SPACE 2                                                      S
MC1CONTB EQU   *                                                      S
         DC    AL1($MC1RET,0)          NON-MACRO STMT                 S
         DC    AL1($MC1ERR,0)          MACRO                          S
         DC    AL1($MC1DCL,0)          GBLA                           S
         DC    AL1($MC1DCL,0)          GBLB                           S
         DC    AL1($MC1DCL,0)          GBLC                           S
         DC    AL1($MC1DCL,0)          LCLA                           S
         DC    AL1($MC1DCL,0)          LCLB                           S
         DC    AL1($MC1DCL,0)          LCLC                           S
         DC    AL1($MC1RET,0)          ACTR                           S
         DC    AL1($MC1RET,0)          SETA                           S
         DC    AL1($MC1RET,0)          SETB                           S
         DC    AL1($MC1RET,0)          SETC                           S
         DC    AL1(0,4)                AIF                            S
         DC    AL1($MC1SKIP,0)         AGO                            S
         DC    AL1($MC1SKIP+$MC1RET,0) ANOP                           S
         DC    AL1($MC1RET,0)          MNOTE                          S
         DC    AL1($MC1ERR,0)          MEXIT                          S
         DC    AL1($MC1ERR,0)          MEND                           S
         DS    0H                  ALIGN IF NECESSARY                 S
         EJECT                                                        S
MC1NORM  EQU   *                                                      S
.MAC1B   ANOP                                                         S
         L     RA,AVMFLD2          GET @ OF OPCODE                    S
MACR1LAB LA    RB,$ERSTMNA         SET CODE / USE WHATEVER @ IN RA    S
MACR1TAG $CALL ERRTAG              SET FLAG
         LA    RB,8                SET PROPER RETURN CODE
         B     MACRO1FN
*        ERROR ROUTINE CALLED WHEN POSITIONAL PARAM FOUND AFTER       S
*        KEYWORD PARAM                                                S
***************  POSSIBLE CHANGES WITH ASM H OR VS  ***************   S
*                                                                     S
MACR1R03 EQU   *
         LA    RB,$ERVSYNT         SE T SYNTAX ERROR FLAG
         B     MACR1TG1            FLAG STMT
MCOVRPR  L     RE,AVMOVRFL         GET @ OF OVERFLOW ROUTINE
         BR    RE                  BRANCH THERE
         SPACE 4
*        GENERAL ROUTINE TO FLAG INCORRECT PARAM FIELDS               S
*                                                                     S
MACR1TG1 EQU   *
         $CALL ERRTAG              FLAG STMT
         SPACE 2
*        CHECK FOR END OF PROTOTYPE AND CALL ROUTINE TO PROCESS       S
*        BODY OF MACRO  (MCBODY)                                      S
*                                                                     S
MACRO1RT EQU   *
         LA    RB,$OUCOMM
         $CALL OUTPT2
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BNE   MACRO1RU            PROCEED IF NOT
         BAL   RET,MACRORD         ELSE GET NEXT STMT
         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG
         B     MACRO1RT            AND PRINT LINES
MACRO1RU EQU   *
         LR    RC,RX
         SR    RB,RB
         TM    AVTAGS2,$INEND2     END OF FILE?
         BO    MACRO1FN            RETURN IF YES
         $CALL MCBODY              PROCESS BODY OF DEFINIETION
MACRO1FN EQU   *
         AIF   (&$DEBUG).MACROFN   SKIP OVER DEBUG CODE IF NOT NEEDED J
         L     R1,AVMBSPIE
         $SPIE ,,ACTION=(RS,(1))   TURN OFF SPIE
         L     R1,AVADDLOW         GET @ OF START OF DYNAMIC AREA
         XSNAP LABEL='DYNAMIC AREA',STORAGE=(*0(RX),*0(R1),*AVADDLOW,*AX
               VWXEND),IF=(AVMSNBY1,O,$MSNP02,TM)
.MACROFN ANOP
         $RETURN  RGS=(R14-R6)
         AIF   (&$DEBUG).MACQQ01   SKIP IF NO DEBUG
         USING MCBSPIEP,R15
MCBSPIEP EQU   *
         L     RC,AVMACLIB         GET PONTR TO LOW ENDOF LOW CORE
         L     RD,AVADDLOW        GET HIGH END OFLOW CORE
         XSNAP LABEL='*** INTERRUPT IN MACRO DEFINITION PHASE ***',    #
               STORAGE=(*0(R1),*16(R1),*0(RC),*0(RD),*AVADDLOW,*AVWXEND#
               )
         DC    H'1'                FORCE INTERRUPT
         DROP  R15
.MACQQ01 ANOP
         DROP  RAT,RW,RX,RY,R13                                       A
         LTORG
MACSVAR# EQU   3                   ACTUAL # SYSTEM VARIABLES          J
*              SYSTEM VARIABLES - VALUES FOR MCPAR- NLN,NAM,TYP.      J
MACSVAR1 DC    AL1(7),CL8'&&SYSECT ',C'S'                             J
MACSVAR2 DC    AL1(7),CL8'&&SYSNDX ',C'S'                             J
MACSVAR3 DC    AL1(8),CL8'&&SYSLIST',C'S'                             J
         TITLE '*** MACSCN - MACRO STATEMENT SCAN ***'
**-->  CSECT: MACSCN   SCANS MACRO INSTRUCTION STATEMENT. IDENTIFIES  *
*.        LABEL, OPCODE, OPERAND AND COMMENT (IF ANY) FIELDS.         *
*.        LOCATION OF EACH FIELD STORED IN AVMFLD_.  LENGTH OF EACH   *
*.        FIELD STORED IN AVMFLDL_.  TYPE OF EACH FIELD PLACED IN     *
*.        AVMFLDT_.  FIELDS ARE SET TO ZERO IF NOT PRESENT.           *
*.        AVMFLDT1 CONTAINS '&' IF VARIABLE SYMBOL AND '.' IF SEQUENCE*
*.        SYMBOL ELSE ZERO.  AVMFLDT2 CONTAINS 'I' IF OPCODE IS       *
*.        SUSPECTED MACRO INSTRUCTION, 'M' IF MACRO OPCODE (AIF,      *
*.        AGO, SETA, ETC), 'O' IF OPCODE IS REGULAR ASSEMBLER OR      *
*.        MACHINE INSTRUCION AND X'00' IF ANYTHING ELSE.              *
*.        SCANS NON STND CONTINUATION FILDS AND PLACES VALUES IN      *
*.        AVMFLD5 THRU AVMFLD8                                        *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CAHARACTER OF STATEMENT                        *
*.        EXIT CONDITIONS                                             *
*.     RA = SAME AS ENTRY CONDITIONS                                  *
*.     RB = 4 IF COMMENT STATEMENT, 8 IF MACRO COMMENT, ELSE ZERO     *
*.     RC = @ OF OPCODTB ENTRY IF OPCODE = M OR O                     *
*.                                                                    *
*.        USES MACROS: $CALL, $SAVE, $RETURN, $SETRT                  *
*.        USES DSECTS: AVWXTABL, OPCODTB                              *
*.       CALLS ERRTAG,MCATRM,OPFIND                                   S
*.   NAMES: MAC----- OR MC------                                      S
*.             BASE REGS:  R13,RAT,RX,RC                             S*
*.             WORK REGS:  R1,R2,RA,RB,RW,RZ                         S*
*.*********************************************************************
         SPACE 2
* * * * * REGISTER USAGE IN MACSCN  * * * * * * * * * * * * * * * * * S
*   R0 = SAVE REGISTER FOR RETURN @ IN MACSCSTR  *2ND MINIMAL USED*  J*
*   R1 = TRT USAGE; ADDRESS REGISTER (HI-ORDER BYTE = 0).            J*
*   R2 = BYTE REGISTER (HI-ORDER 3 BYTES = 0); TRT USAGE.            J*
*   RW = PARENTHESES LEVEL COUNT IN SECTION MACSCSTR                 J*
*   RX = @ RSBLOCK BEGIN SCANNED                                     J*
*   RY = 1 FOR SCANNING USAGE (BXH, ETC)                             J*
*   RZ = SAVE REG FOR OPCODTB PTR  * MINIMAL-USED REGISTER           J*
*   RA = SCAN POINTER                                                J*
*   RB = RETURN CODE USAGE                                           J*
*   RC,RD,RE  = PARAMETER REGISTERS FOR EXTERNAL ROUTINES.           J*
*   R13 = SAVE AREA PTR; BASE REGISTER                               J*
*   R13= BASE REGISTER, SAVE AREA PTR.                               J*
*   RET,REP=  USUAL LINKAGE, INCLUDING INTERNAL LINKAGE              J*
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * S
         EJECT                                                        S
MACSCN   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT        SET MAIN CONTROL TABLE USING
         XSNAP LABEL='***MACSCN ENTERED***',IF=(AVMSNBY1,O,$MSNP03,TM)
         MVC   AVMFLD1($LAVMFLD),AWZEROS  CLEAR FIELD POINTERS
         SR    RB,RB
         LM    R1,R2,AWZEROS       CLEAR R1 AND R2 FOR TRT INST
         ST    RA,AVMTSCNP         SAVE SCAN POINTER TEMPORARILY
*
         LA    RY,1                SET UP USEFUL VALUE FOR SCANNING   J
*   CHECK FOR PRESENCE OF COMMENT STATEMENT
*
         CLI   0(RA),C'*'          REGULAR COMMENT?
         BNE   MCMNT01             IF NOT, JUMP
         LA    RB,4                ELSE SET COMMENT STMNT FLAG
         B     MCSCNRT             AND RETURN
MCMNT01  CLC   0(2,RA),=C'.*'      MACRO COMMENT?
         BNE   MACLABSC            IF NOT, JUMP AND START SCAN
         LA    RB,8                ELSE SET MACRO COMMENT FLAG
         B     MCSCNRT             AND RETURN
*
*   SET UP TRT TABLE TO SCAN FOR DELIMITERS
*
MACLABSC $SETRT  (' ',4,'(',8,')',12,'''',16)
         SPACE 2
*        START SCAN FOR LABEL -- DETERMINE TYPE (VAR,SEQ OR NORMAL)   S
*        AND PROCESS ACCORDINGLY                                      S
*                                                                     S
         CLI   0(RA),C' '          LABEL PRESENT?
         BE    MACOPCSC            IF BLANK, JUMP AND SCAN OPCODE
         ST    RA,AVMFLD1          ELSE SAVE LABEL @
         CLI   0(RA),C'&&'         VAR SYMBOL?
         BE    MACSCN02            IF YES, SCAN REST OF SYMBOL
         CLI   0(RA),C'.'          SEQ SYMBOL?
         BE    MACSCN02            IF YES, JUMP AND SCAN REST OF SYMBOL
         SPACE 2
MACSCN01 BAL   RET,MACSCSTR        BRANCH AND SCAN STRING
         B     MACSCN03
         SPACE 2
*        SCAN VAR OR SEQ SYMBOL -- SETS AVMFLDT1 TO PROPER TYPE       S
*                                                                     S
MACSCN02 CLI   1(RA),C'0'          FIRST CHAR IS A LETTER?
         BNL   MACSCN01            NOT ORD. SYMBOL IF NOT
         TRT   1(8,RA),AWTSYMT     SCAN SYMBOL
         BZ    MACSCN01            NOT SYMBOL, 9+ CHARS, RESUME SCAN
         CLI   0(R1),C' '          DELIM = BLANK?
         BNE   MACSCN01            NO SYMBOL IF NOT
         MVC   AVMFLDT1(1),0(RA)   SAVE TYPE
         LR    RA,R1               UPDATE SCAN POINTER
         SPACE 2
*        COMPUTE AND STORE CHARACTER LENGTH                           S
*                                                                     S
MACSCN03 S     RA,AVMFLD1          GET LENGTH OF FIELD
         STC   RA,AVMFLDL1         SAVE LENGTH
         A     RA,AVMFLD1          RESTORE SCAN POINTER
*
*    SCAN FOR START OF OPCODE
*
MACOPCSC BAL   RET,MACSCBLN        SCAN FOR NON BLANK
         ST    RA,AVMFLD2          SAVE @ OF OPCODE
         USING OPCODTB,RC          ESTAB BASE FOR OPCODE ENTRY
         $CALL OPFIND              LEGAL OPCODE?
         LTR   RB,RB               YES IF RB = 0
         BNZ   MACSCN04            IF NOT TREAT AS STRING
         LR    RZ,RC               COPY OPCODTB @ TEMPORARILY
         IC    R2,OPCTYPE          GET TYPE                           J
         SRL   R2,6                REMOVE ALL BUT 1ST 2 BITS          J
         IC    R2,MACSTAB1(R2)     GET TYPE: 'O' OR 'M' OF OPCODE     J
         STC   R2,AVMFLDT2         SAVE THE TYPE VALUE FOR LATER USE  J
         B     MACSCN06
MACSTAB1 DC    AL1(C'O',C'O',C'M',C'O')  OPCODE TYPE TABLES           J
         ORG   *+0*($IA+$IS+$IM+$IB)  REFER TO TYPES FOR XREF         J
         SPACE 2
MACSCN04 CLI   0(RA),C'0'          FIRST CHAR < 0?
         BNL   MACSCN07            NO SYMBOL IF NOT
         TRT   0(9,RA),AWTSYMT     SCAN SYMBOL
         BZ    MACSCN07            9+ CHARS IF ZERO
         CLI   0(R1),C' '          DELIM = BLANK?
         BNE   MACSCN07            NO SYMBOL IF NOT
         MVI   AVMFLDT2,C'I'       SET MACRO INSTRUCTION FLAG
         LR    RA,R1               MOVE SCAN POINTER
         B     MACSCN06            BRANCH TO GET LENGTH
         SPACE 2
MACSCN07 BAL   RET,MACSCSTR        SCAN OPCODE STRING
MACSCN06 S     RA,AVMFLD2          GET LENGTH OF OPCODE
         STC   RA,AVMFLDL2         SAVE LENGTH
         A     RA,AVMFLD2          RESTORE SCAN POINTER
*
*   NEXT SECTION FINDS AND SCANS OPERAND FIELD
*
         L     RX,AVRSBPT          POINT TO RSBLOCK
         USING RSBLOCK,RX          SET USING ON RSBLOCK
         BAL   RET,MACSCOPR        SCAN OPRND FIELD
         MVC   AVMFLD3(5),MACSCNFD MOVE DATA TO FIELD PNTRS
         BAL   RET,MACSCHEK        CHECK FOR NON STND CONT CARD
         BAL   RET,MACSCMMT        SCAN COMMENT FIELD
         MVC   AVMFLD4(5),MACSCNFD MOVE DATE TO FIELD PNTRS
         BAL   RET,MACSCOPR        SCAN NEXT OPRND(IF PRESENT)
         MVC   AVMFLD5(5),MACSCNFD MOVE DATA TO FIELD PNTRS
         BAL   RET,MACSCHEK        CHECK FOR 1 MORE NON STND CARD
         BAL   RET,MACSCMMT        SCAN COMMENT
         MVC   AVMFLD6(5),MACSCNFD   MOVE DATA TO FIELD PNTRS
         BAL   RET,MACSCOPR        SCAN 3RD OPRND(IF ANY)
         MVC   AVMFLD7(5),MACSCNFD   MOVE DATA TO FIELD PNTRS
         L     RB,AVSOLAST         SET EOR @ FOR LAST COMMENT
         BCTR  RB,0                DECR FOR TRUE LENGTH
         BAL   RET,MACSCMMT        SCAN COMMENT
         MVC   AVMFLD8(5),MACSCNFD  MOVE DATA TO FIELD PNTRS
         B     MCSCNFT             AND FINI
         SPACE 2
**--> INSUB: MACSCOPR       FIND AND SCAN OPERAND + + + + + + + + + ++S
*+       THIS ROUTINE FINDS, SCANS, GETS ADDR AND LENGTH OF THE      +S
*+       OPERAND FIELD                                               +S
*+                                                                   +S
*+       EXIT CONDS:  ADDR & LENGTH ARE PLACED IN APPROPRIATE        +S
*+                    PLACES IN TABLE.                               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCOPR EQU   *
         ST    RET,MACSCSAV        SAVE RETURN @
         BAL   RET,MACSCBLN        SCAN FOR NONBLANK
         ST    RA,MACSCNFD         SAVE @ OF OPRND
         BAL   RET,MACSCSTR        SCAN OPRND
         S     RA,MACSCNFD         SUBTRACT START @
         STC   RA,MACSCNFL         SAVE LENGTH
         A     RA,MACSCNFD         RESTORE POINTER
         L     RET,MACSCSAV        RESTORE RETURN @
         BR    RET                 AND RETURN
         SPACE 2
**--> INSUB: MACSCMMT       SCAN COMMENT FIELD + + + + + + + + + + + +S
*+       THIS ROUTINE SCANS FOR NON-BLANK, CHECKS FOR CARD           +S
*+       OVERRUN.  IF OK, SAVES @ AND LENGTH OF FIELD.               +S
*+                                                                   +S
*+       EXIT CONDS:  ADDR & LENGTH ARE PLACED IN APPROPRIATE        +S
*+                    PLACES IN TABLE.                               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCMMT EQU   *
         ST    RET,MACSCSAV        SAVE RETURN @
         MVC   MACSCNFD(6),AWZEROS   ZERO POINTER STORAGE
         BAL   RET,MACSCBLN        SCAN FOR NON BLANK
         CR    RA,RB               COMPARE WITH END OF RECORD
         BNL   MACSCMRT            RETURN IF IN NEXT CARD IMAGE
         ST    RA,MACSCNFD         ELSE SAVE @
         SR    RB,RA               GET LENGTH
         STC   RB,MACSCNFL         SAVE LENGTH
         AR    RA,RB               BUMP SCN PNTR TO BLNK BEYOND CMMT
MACSCMRT EQU   *
         L     RET,MACSCSAV        GERT RETRUN @
         BR    RET                 AND RETURN
MACSCSAV DS    F                   STORAGE FOR RETURN @
MACSCNFD DS    F                   TEMP STRORAE FOR LOCATION PNTR
MACSCNFL DS    C                   TEMP STROAGE FOR FIELD LENGTH
MACSCNTY DS    C                   TEMP STRGE FOR FIELD TYPE
         SPACE 2
**--> INSUB: MACSCHEK       CHECK FOR NON-STD COND CARD  + + + + + + +S
*+       CHECKS FOR MACRO PROTOTYPE CONTINUATION CARDS (UP TO 3)     +S
*+                                                                   +S
*+       EXIT CONDS:  RB = PTR SET TO:                               +S
*+             1.  LAST CHAR ON ORIGINAL CARD (NOT CONTINUATION)     +S
*+             2.  1ST BYTE ON 2ND OR 3RD CARD (NON-STD CONT)        +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCHEK EQU   *
         L     RB,AVSOLAST         GET EOR @
         BCTR  RB,0                DECR TO BLANK PAST LAST CHAR
         BCTR  RA,0                DECR SCAN POINTER
         CLI   0(RA),C','          STOP ON ','?
         LA    RA,1(RA)            RESTORE SCAN POINTER
         BCR   NE,RET              NOT NON-STND IF NO COMMA
         CLI   AVMFLDT2,C'I'       POSSIBLE MACRO CALL?
         BCR   NE,RET              ALSO RETURN IF NOT
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    RA,RB               COMPARE WITH SCAN POINTER
         BCR   NH,RET              RETURN IF NOT HIGH
         LA    RB,RSOLC(RB)        ELSE BYMP RB TO 3RD CARD
         CR    RA,RB               COMPARE SCAN PONTR AGAIN
         BCR   NH,RET              RETURN IF NOT HIGH
         L     RB,AVSOLAST         ELSE LOAD EOR @
         BCTR  RB,RET              DECREM TO 1ST BLANK, BRANCH ALWAYS J
         DROP  RX
         SPACE 2
**--> INSUB: MACSCBLN       SCAN FOR NON-BLANK CHAR  + + + + + + + + +S
*+       SCANS FOR NON-BLANK CHAR WITHOUT CARD OVERRUN               +S
*+                                                                   +S
*+       ENTRY COND:  RA = @ WHERE SCAN TO BEGIN                     +S
*+       EXIT COND:  RA = @ OF 1ST NON-BLANK OR                      +S
*+                        @ OF END OF RECORD                         +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCBLN EQU   *                   SCAN FOR NON-BLANK                 S
MACBLN01 CLI   0(RA),C' '          BLANK?
         BNE   MACBLN02            IF NOT, NON BLANK FOUND
         BXH   RA,RY,MACBLN01      ELSE TRY AGAIN                     J
MACBLN02 C     RA,AVSOLAST         END OF RECORD?
         BNL   MCSCNFT             IF YES, SCAN FINI, RETURN
         BR    RET                 ELSE RESUME STMNT SCAN
         EJECT                                                        S
**--> INSUB: MACSCSTR       SCAN ARBITRARY STRING  + + + + + + + + + +S
*+       THIS SECTION IS A ROUTINE TO SCAN AN ARBITRARY              +S
*+       STRING AND RETURN THE LENGTH.  SCAN PTR IS LEFT             +S
*+       AT BLANK FOLLOWING STRING.                                  +S
*+                                                                   +S
*+       ENTRY COND:  RA = @ OF BEGINNING OF STRING                  +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MACSCSTR EQU   *
         LR    R0,RET              COPYRETURN @
         SR    RW,RW               CLEAR RW FOR PAREN COUNT
         NI    AVMBYTE1,X'FF'-$MINQUOT   CLEAR QUOTE FLAG
         SPACE 2
MACSTRT  EQU   *
         TRT   0(200,RA),AWTZTAB   SCAN STRING
         B     *(R2)               BRANCH INTO TABLE FOR ROUTINE
         B     MCSCBLNK
         B     MCSCLPAR
         B     MCSCRPAR
         B     MCSCQUOT
         SPACE 2
MCSCBLNK TM    AVMBYTE1,$MINQUOT   INSIDE QUOTE?
         BO    MCSCBLOK            IF YES, PROCEED
         LTR   RW,RW               INSIDE PARENS?
         BP    MCSCBLOK            IF YES, PROCEED
         LR    RA,R1               ELSE UPDATE SCAN POINTER
         LR    RET,R0              RESTORE RETURN @
         BR    RET                 AND RETURN TO STMNT SCAN
         SPACE 2
MCSCLPAR AR    RW,RY               = LA RW,1(RW) BUMP PAREN COUNTER   J
         B     MCSCBLOK            GO TO BUMP SCAN PTR & CONTINUE     S
         SPACE 2
MCSCRPAR EQU   *
         BCTR  RW,0
MCSCBLOK LA    RA,1(,R1)           BUMP SCAN PTR TO NEXT CHAR         S
         B     MACSTRT             RESUME SCAN
         SPACE 2
MCSCQUOT C     R1,AVSOLAST         END OF RECORD?
         BNL   MCSCQU01            BRANCH AND PROCESS ERROR IF YES
         CLI   1(R1),C''''         TWO QUOTES?
         BE    MCSCQTWO            IF YES, JUMP AND PROCEED
         LR    RA,R1               MOVE SCAN POINTER
         TM    AVMBYTE1,$MINQUOT    ARE WE IN SIDE QUOTED STRING?
         BO    MCSCQTRT            IF YES, DON'T LOOK FOR ATTRIBUTE
         BCTR  RA,0                DEC POINTER FOR ATTERM
         TRT   0(1,RA),AWTSYMT     IS PREV CHAR ALPHA?
         BNZ   MCSCNOAT            IF NOT CAN'T BE ATTRIBUTE
         $CALL MCATRM              IS IT AN ATTRIBUTE?
         LTR   RB,RB               ATTRIBUTE IF RB=0
         BZ    MACSTRT             IF YES THEN RESUME SCAN
         BP    MCSCQTWO            IF ATTRIB NOT IMPLEMENTED RESUME SCA
MCSCNOAT AR    RA,RY               = LA RA,1(RA) RESTORE POINTER      J
         TM    AVMBYTE1,$MINQUOT   ARE WE INSIDE QUOTES?
         BO    MCSCQTRT            IF YES RESET TRT TABLE
         $SETRT ('(',0,')',0,' ',0)  ELSE TURN OFF TRT FOR QUOTE STRNG
         B     MCSCQUFT
MCSCQTRT $SETRT (' ',4,'(',8,')',12)  RESET TRT FOR END OF QUOTE STRNG
MCSCQUFT XI    AVMBYTE1,$MINQUOT   FLIP QUOTE FLAG
         BXH   RA,RY,MACSTRT       BUMP SCAN PTR, BRANCH ALWAYS       J
MCSCQTWO LA    RA,2(R1)            BUMP SCAN POINTER PAST DOUBLE '
         B     MACSTRT             RESUME SCAN
         SPACE 2
MCSCQU01 EQU   *
         NI    AVMBYTE1,X'FF'-$MINQUOT   TURN OFF QUOTE FLAG
         BCTR  R1,0                DEC R1
         LR    RA,R1               COPY R1 INTO SCAN POINTER
         LA    RB,$ERNODLM         SET NO DELIM FLAG
         $CALL ERRTAG              FLAG STATEMENT
         LA    RB,8                INDICATE MACRO COMMENT
         B     MCSCNERR            AND RETURN
         SPACE 4
*        RETURN SEQUENCE FOR MACSCN -- SETS RETURN CODES              S
*        AND RESETS TABLES, ETC.                                      S
*                                                                     S
MCSCNFT  EQU   *
         SR    RB,RB               CLEAR RB FOR NORMAL RETURN
MCSCNERR EQU   *
         $SETRT  (' ',0,'(',0,')',0,'''',0)    CLEAR TRT TABLE
MCSCNRT  EQU   *
         LR    RC,RZ               RESTORE OPCODTB @ TO RC FOR RETURN
         L     RA,AVMTSCNP         RESTORE SCAN POINTER
         XSNAP LABEL='***MACSCN EXITED***',IF=(AVMSNBY1,O,$MSNP03,TM), #
               STORAGE=(*AVMFLD1,*AVMBYTE5)
         $RETURN  RGS=(R14-R6)
         DROP  RAT,RC,R13
         LTORG
         TITLE '*** MCSCOP - STANDARD VALUE SCANNER ***'
**-->  CSECT:  MCSCOP   THIS ROUTINE SCANS A MACRO INSTRUCTION        *
*.        OPERAND.  THE OPERAND MUST CONFORM TO A STANDARD VALUE AS   *
*.        LAID DOWN IN SECTION 8 OF IBM GC28-2514                     *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.       AVMBYTE1: FLAG $MSBLIST EXPECTED SET IF ALREADY INSIDE SUBLISS
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = DELIM PAST OPRND IF STND VALUE ELSE POINTS AT ERROR       *
*.     RB = 0 IF STANDARD VALUE ELSE $ER MESSAGE                      *
*.     RC = LENGTH OF OPERAND IF OKAY                                 *
*.     RD = TYPE OF OPERAND.  IN THIS CASE TYPE WILL BE ONE OF        *
*.          'O' (NULL), 'N' (SELF-DEFINING TERM) OR 'U' (ALL OTHERS)  *
*.             CAN BE 'S' AFTER SCANNING   (1ST SUBPOPERAND           S
*.     RE = VALUE OF SELF DEFINING TERM                               *
*.       AVMBYTE1: FLAG $MINQUOT HAS INDETERMINATE VALUE.             S
*.        USES MACROS: $SAVE, $RETURN, $SETRT, $CALL                  *
*.        USES DSECTS: AVWXTABL                                       *
*.        CALLS SDBCDX                                                *
*.                                                                    *
*.*********************************************************************
         SPACE 4
* * * * * * * * * * REGISTER USAGE IN MCSCOP  * * * * * * * * * * * * S
*   R0 = TEMPORARY SAVE REGISTER FOR SCAN POINTER.                    S
*   R1 = SCAN POINTER FROM TRT INSTRUCTIONS.                          S
*   R2 = BYTE REGISTER, TRT USAGE.                                    S
*   RA = NORMAL SCAN POINTER.                                         S
*   RB = RETURN CODE REGISTER.                                        S
*   RC = RETURN LENGTH REGISTER.                                      S
*   RD = FLAG REGISTER FOR TYPE:  'U', 'N', 'O', OR 'S' .             S
*   RE = PARENTHESES NEST LEVEL COUNTER;  SELF-DEF TERM VALUE RETURN. S
*   R13= BASE REGISTER.                                               S
*   R14= INTERNAL LINK REGISTER.                                      S
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * S
         SPACE 2                                                      S
MCSCOP   CSECT
         $SAVE RGS=(R14-R2),SA=*,BR=13
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCSCOP ENTERED***',IF=(AVMSNBY1,O,$MSNP04,TM)
         NI    AVMBYTE1,X'FF'-$MINQUOT  TURN OFF QUOTE FLAG
         LA    RD,C'U'             SET UNDEFINED FLAG FOR STARTS
         BAL   R14,MCSET1          SET TRT TABLE FOR CORRECT SCANNING J
         SR    RE,RE               USE RE AS PAREN COUNTER
         SR    R1,R1                                                  A
         SR    R2,R2               CLEAR R2 FOR TRT USE
         LR    R0,RA               COPY SCAN POINTER
         TRT   0(1,RA),AWTDECT     POSSIBLE SDTERM?
         BZ    MCOPSDTM            DECIMAL TERM IF CC = 0
         C     R2,AWF4             IS IT B, C OR X?
         BE    MCOPSDTM            POSSIBLE IF EQUAL TO 4
         B     MCOPSTRT            SKIP AROUND SCAN POINTER BUMP FIRSTJ
MCOPSTRS LA    RA,1(,R1)           SET SCAN PTR 1 BEYOND LAST TRT END J
MCOPSTRT EQU   *
         TRT   0(200,RA),AWTZTAB   START SCAN
         B     *(R2)               JUMP TO TABLE OF BRANCHES
         B     MCOPQUOT
         B     MCOPLPAR
         B     MCOPRPAR
         B     MCOPEQUL
         B     MCOPAMPR
         B     MCOPSCFT
         B     MCOPBLNK
         SPACE 2
MCOPQUOT EQU   *                   COME HERE FOR '                    A
         CLI   1(R1),C''''         TWO QUOTES IN ROW?
         BE    MCOPQTWO            IF YES, JUMP AN  PROCESS
         TM    AVMBYTE1,$MINQUOT
         BO    MCOPINQU
         LA    R2,2                                                   A
         SR    R1,R2                                                  A
         CLI   1(R1),C'L'                                             A
         BNE   MCOPQU11                                               A
         TRT   0(1,R1),AWTSYMT     CHACK CHARACTER
         BZ    MCOPQU11            IF LETTER THEN IS NOT L'
         TRT   3(1,R1),AWTSYMT     CHAR AFTER L' = ALPHA?
         BNZ   MCOPQU11            IF NOT, JUMP OUT
         CLI   3(R1),C'Z'          CHAR GREATER THAN Z?
         BH    MCOPQU11            IF YES, CANT BE ALPAH
         CLI   0(R1),C'&&'         IS IT AN AMPERSAND?
         BE    MCOPQU11            IF YES, NOT L'
         LA    RA,3(R1)            BUMP SCAN POINTER
         B     MCOPSTRT            RESUME SCAN
         SPACE 2
MCOPQTWO LA    RA,2(R1)            BUMP SCAN POINTER PAST ''
         B     MCOPSTRT
         SPACE 2
MCOPQU11 AR    R1,R2               RESTORE SCAN PTR TO ' FOUND        A
*   THE $SETRT MACRO IS USED TO CLEAR THE AWTZTAB TABLE FOR SCAN OF
*   A QUOTED STRING
         IC    RB,AWTZTAB+C','     SAVE CURRENT COMMA STATUS ACRS '   J
         BAL   R14,MCSET2A         SET FOR INSIDE QUOTED STRING -ZERO J
         B     MCOPQU02
*     WHEN END OF QUOTED STRING HAS BEEN REACHED, AWTZTAB IS RESTORED
*    SO THAT NORMAL SCAN CAN CONTINUE
MCOPINQU BAL   R14,MCSET1A         RESET, NO LONGER INSIDE QUOTED STRNJ
         STC   RB,AWTZTAB+C','     RESTORE ORIGINAL COMMA STATUS      J
MCOPQU02 XI    AVMBYTE1,$MINQUOT   FLIP QUOTE FLAG
         B     MCOPSTRS            GO BACK TO INCREMENT PTR AND SCAN  J
         SPACE 2
MCOPLPAR CR    R1,R0               BEGINNING OF OPERAND?
         BNE   MCOPLP01            IF NOT, PROCEED
         L     RD,=C'   S'         ELSE SET SUBLIST FLAG
MCOPLP01 LA    RE,1(RE)            BUMP PAREN COUNTER
         $SETRT (',',0)            COMMAS OK INSIDE PARENS
         B     MCOPSTRS            GO AND BUMP SCAN PTR BY 1          A
         SPACE 2
MCOPRPAR BCT   RE,MCOPRP01         DECR PAREN COUNTER
         $SETRT (',',24)           RESET TRT TABLE IF ZERO
         B     MCOPRP02
MCOPRP01 LTR   RE,RE               TEST PAREN COUNT
         BNM   MCOPRPFT            IF NOT MINUS, OKAY
         TM    AVMBYTE1,$MSBLIST   ARE WE IN SUBLIST
         BO    MCOPSCFT            IF YES, OKAY. END OF SUBLIST
MCOPRER1 LA    RB,$ERVSYNT        SET SYNTAX ERROR
         LR    RA,R1               SET SCAN POINTER
         B     MCOPSCRT
MCOPRPFT EQU   MCOPSTRS            SAME AS PREVIOUS LABEL: BUMP PTR   J
         SPACE 2
MCOPRP02 C     RD,=C'   S'         ARE WE IN SUBLIST?
         BNE   MCOPRPFT            IF NOT, PROCEED
         CLI   1(R1),C','          END OF OPERAND?
         BE    MCOPRPFT            IF YES, PROCEED
         CLI   1(R1),C' '          END OF OPERAND?
         BE    MCOPRPFT
         LA    RD,C'U'             INSERT UNDEFINED FLAG
         B     MCOPRPFT            CONTINUE SCAN
         SPACE 4
MCOPEQUL CR    R1,R0               AT START OF OPERAND?
         BE    MCOPEQ01            IF YES, OKAY
         LTR   RE,RE               ELSE ARE WEIN PARENS?
         BZ    MCOPRER1            ERROR IF NOT
MCOPEQ01 EQU   MCOPSTRS            SAME AS PREVIOUS LABEL, SKIP THERE J
         B     MCOPSTRS            BRANCH THERE, IF FLLA THRU HERE    J
         SPACE 4
MCOPAMPR CLI   1(R1),C'&&'         TWO AMPERSANDS?
         BE    MCOPQTWO            IF YES USE DOUBLE QUOTE CODE
         CR    R0,R1               BEGINNING OF OPERAND?
         BE    MCOPEQ01            IF YES USE = CODE
         B     MCOPRER1            ELSE ERROR, USE RPAR CODE
         SPACE 2
MCOPSDTM EQU   *
         $CALL SDBCDX              CALL SELF-DEFINING TERM ROUTINE
         LTR   RB,RB               WAS IT SD TERM
         BNZ   MCOPSTRT            JUMP IF NOT REALY SELF-DEF TERM  JRM
         CLI   0(RA),C','          NORMAL DELIM AFTER SDTERM?
         BE    MCOPSDT1            PROCEED IF YES
         CLI   0(RA),C' '          DELIM = ' '?
         BE    MCOPSDT1            PROCEED IF YES
         CLI   0(RA),C')'          DELIM IS A ')'?
         BNE   MCOPSDT2            IF NOT, START SCAN OVER
         TM    AVMBYTE1,$MSBLIST   SCANNING SUBLIST?
         BO    MCOPSDT1            RIGHT PAREN OKAY  IF SO
MCOPSDT2 EQU   *
         LM    RC,RD,AWZEROS       CLEAR RC, RD AFTER SDDTERM
         LR    RA,R0               RESTORE SCAN POINTER TO RESUME SCAN
         B     MCOPSTRT
MCOPSDT1 EQU   *
         LR    R1,RA               MOVE SCAN POINTER INTO R1
         LA    RD,C'N'             SET SELF DEF TERM FLG
         LR    RE,RC               MOVE VALUE OF SDTERM INTO RE
         B     MCOPSCFT
         SPACE 2
MCOPBLNK EQU   *
         LTR   RE,RE               ARE WE IN PARENS
         BZ    MCOPSCFT            IF NOT, FINI
         LA    RB,$ERNODLM         ELSE SET WRONG DELIM FLAG
         B     MCOPSCRT            AND RETURN
         SPACE 4
MCOPSCFT LR    RA,R1               MOVE SCAN POINTER
         LR    RC,R1               COPPY POINTER
         SR    RB,RB               CLEAR RB FOR FLAG USE
         C     RD,=C'   S'         SUBLIST?
         BNE   MCOPSCF1            SKIP IF NOT
         TM    AVMBYTE1,$MSBLIST   IN SUBLIST FLAG ON?
         BNO   MCOPSCF1            SKIP IF NOT
         LA    RD,C'U'             ELSE SET UNEFINED FLAG
MCOPSCF1 EQU   *
         SR    RC,R0               GET LENGTH OF OPERAND
         BNZ   MCOPSCRT            JUMP AROUND IN NOT ZERO
         LA    RD,C'O'             ELSE SET NULL FLAG
MCOPSCRT BAL   R14,MCSET2          RESET ALL VALUES CHANGED IN TRT TB J
         XSNAP LABEL='***MCSCOP EXITED*** ',IF=(AVMSNBY1,O,$MSNP04,TM)
         $RETURN  RGS=(R14-R2)
         SPACE 2                                                      J
**--> INSUB: MCSET#     MODIFY TRT TABLE AWTZTAB  + + + + + + + + + + S
MCSET1   $SETRT ('''',4)       SET TO CATCH ' ,  AND THEN OTHER CHARS J
MCSET1A  $SETRT ('(',8,')',12,'=',16,'&&',20,',',24,' ',28) OTHER CHRSJ
         BR    R14                 RETURN TO CALLER                   J
         SPACE 1                                                      J
MCSET2   $SETRT ('''',0)           RESET ' TO 0, THEN OTHERS          J
MCSET2A  $SETRT ('(',0,')',0,'=',0,'&&',0,',',0,' ',0) RESET OTHERS   J
         BR    R14                 RETURN TO CALLER                   J
         DROP  RAT,R13
         LTORG
         TITLE '*** MACFND - SEARCHES DICTIONARIES FOR VARIABLE ***'
**-->  CSECT:  MACFND    THIS ROUTINE IS GENERAL SEARCH PROCEDURE     *
*.        WHICH CAN SCAN THE MACRO LIBRARY, GLOBAL AND LOCAL          *
*.        DICTIONARIES AND THE SYMBOLIC PARAMETER LIST.  THE CALLING  *
*.        ROUTINE DETERMINES WHICH LIBRARY BY PLACING THE APPROPRIATE *
*.        POINTER IN RC.                                              *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RC = @ OF FIRST ENTRY OF LIST TO BE SEARCHED                   *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RB = 0 IF ENTRY IS FOUND                                       *
*.        = $ERUNDEF IF ENTRY IS NOT FOUND                            *
*.     RC = @ OF ENTRY IF FOUND ELSE @ OF FINAL ENTRY IF NOT FOUND    *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.        USES DSECTS: MACLIB, AVWXTABL                               *
*.                                                                    *
*.REGISTER USAGE                                                      A
*.RC-MACLIB BASE REGISTER, LIST TO BE SEARCHED                        A
*.RAT- MAIN TABLE DSECT USING                                         A
*.RB-RETURN REGISTER                                                  A
*.                                                                    A
*. NAMES=MACFN___                                                     A
*.                                                                    A
*.                                                                    *
*.*********************************************************************
         SPACE 2
MACFND   CSECT
         $SAVE SA=NO
         USING AVWXTABL,RAT
         XSNAP LABEL='***MACFND ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP05X
               ,TM)
         USING MACLIB,RC           USE MACLIB AS REPRESENTATIVE DSECT
         LTR   RC,RC               CHECK FOR NULL (MAYBE OPEN CDE)    J
         BZ    MACFNDRU            SKIP IF NULL LIST                  J
         SR    RB,RB
         B     MACFND02            JUMP TO COMPARE FIRST ENTRY
MACFND01 L     RC,MCLIBNXT         GET @ OF NEST ENTRY
MACFND02 CLC   AVMSYMBL,MCLBNAM   COMPARE NAME WITH GLOBAL SYMBOL
         XSNAP LABEL='IN MACFND LOOP RC # LIB',STORAGE=(*0(RC),*30(RC))
         BE    MACFNDRT            IF EQUAL RETURN
         CL    RB,MCLIBNXT         FINAL ENTRY?
         BNE   MACFND01            IF NOT, TRY AGAIN
MACFNDRU LA    RB,$ERUNDEF         SHOW UNDEFINED SYMBOL              J
MACFNDRT EQU   *
         XSNAP LABEL='***MACFND EXITED***',IF=(AVMSNBY1,O,$MSNP05,TM)
         $RETURN   SA=NO
         DROP  RAT,RC,REP
         LTORG
         TITLE '***MCVSCN - VARIABLE SYMBOL SCANNER ***'
**-->  CSECT:  MCVSCN   THIS ROUTINE SCANS A STRING AND CHECKS        *
*.        FOR A LEGAL VARIABLE SYMBOL.  IF OKAY, SYMBOL IS MOVED INTO *
*.        AVMSYMBL IN AVWXTABL WHERE IT WILL BE UTILIZED IN SEARCHES. *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHARACTER OF STRING                            *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER PAST SYMBOL IF LEGAL                       *
*.        = SAME AS ENTRY IF NOT VARIABLE SYMBOL                      *
*.     RB = 0 IF OKAY, <0 IF NOT VARIABLE SYMBOL,                     *
*.        = $ER MESSAGE IF ILLEGAL SYMBOL                             *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.REGISTER USAGE                                                      A
*.RAT- MAIN TABLE DSECT USING                                         A
*.R1,R2 USED IN TRT'S                                                 A
*.RB- SET AS IN EXIT CONDITIONS ABOVE                                 A
*.                                                                    A
*.NAMES=MCVS____                                                      A
*.                                                                    A
*.*********************************************************************
         SPACE 2
MCVSCN   CSECT
         $SAVE RGS=(R0-R2),SA=NO
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCVSCN ENTERED***',T=NO,STORAGE=(*AVMSYMBL,*AVX
               MSYMBL+10),IF=(AVMSNBY1,O,$MSNP05,TM)
         LM    R1,R2,AWZEROS       ZERO R1, R2, FOR TRT USE
         LR    R0,RA               COPY SCAN POINTER
         CLI   0(RA),C'&&'         STARTS WITH '&'?
         BNE   MCVSCNOT             IF NOT, NO VAR SYMBOL
         CLI   1(RA),C'0'          2ND CHAR = ALAPHA?
         BNL   MCVSCNER             IF NOT, ERROR
         TRT   1(8,RA),AWTSYMT     SCAN RMNDER OF SYMBOL
         BZ    MCVSCNER             IF ZERO, 9+ CHARS LONG, ERROR
         SR    R1,R0               GET LENGTH OF SYMBOL
         AR    R0,R1               BUMP SCAN &
         STC   R1,AVMSYMLN         SAVE LENGTH IN GLOBAL AREA
         BCT   R1,MCVSCN01          DECR FOR EX BUT FALL THROUGH IF ZER
         B     MCVSCNER             ERROR IF LENGTH = 1
MCVSCN01 MVC   AVMSYMBL,AWBLANK    BLANK GLOBAL AREA
         EX    R1,MCVSMOVE         MOVE SYMBOL INTO GLOBAL AREA
         LR    RA,R0               BUMP SCAN POINTER
         SR    RB,RB
         B     MCVSCNRT
MCVSCNOT L     RB,AWFM4            SET NO SYMBOL FLAG
         B     MCVSCNRT
MCVSCNER LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG
MCVSCNRT EQU   *
         XSNAP LABEL='***MCVSCN EXITED***',IF=(AVMSNBY1,O,$MSNP05,TM)
         $RETURN  RGS=(R0-R2),SA=NO
MCVSMOVE MVC   AVMSYMBL(0),0(RA)   DUMMY TO MOVE SYMBOL IN EX INST
         DROP  RAT,REP
         LTORG
         TITLE '***MCSYSR - DICTIONARY SEARCH ROUTINE***'
**-->  CSECT:  MCSYSR  SCANS SUSPECTED VARIABLE SYMBOL FOR LEGALITY.  *
*.        IF VARIABLE SYMBOL THEN PLACES IN AVMSYMBL.  THEN SEARCHES  *
*.        GLOBAL, LOCAL AND SYMBOLIC PARAMETER DICTIONARIES FOR SYMBOL*
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHARACTER OF SYMBOL                            *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER PAST VARIABLE SYMBOL IF OKAY               *
*.        = SAME AS ENTRY IF NOT VARIABLE SYMBOL OR IF NOT FOUND      *
*.     RB = $ERUNDEF  IF SYMBOL IS NOT FOUND                          *
*.     RB = 0 IF SYMBOL IS FOUND IN ONE OF THE DICTIONARIES           *
*.        = SET TO -4 IF RA DOES NOT POINT AT VARIABLE SYMBOL         *
*.     RC = POINTER TO SYMBOL ENTRY IF FOUND                          *
*.     RD = $GLOBAL IF SYMBOL PRESENT IN GLOBAL DICTIONARY            *
*.        = $LOCAL IF SYMBOL FOUND IN LOCAL DICTIONARY                *
*.        = $SYMPAR IF SYMBOL IS SYMBOLIC PARAMETER                   *
*.        = $SYSTEM IF SYMBOL IS SYTEM VARIABLE                       *
*.                                                                    *
*.        USES MACROS: $CALL, $SAVE, $RETURN                          *
*.        USES DSECTS: MCGLBDCT, MACLIB,AVWXTABL                      *
*.        CALLS MCVSCN, MACFND                                        *
*.                                                                    A
*.REGISTER USAGE ***************                                      A
*.R13 -BASE REGISTER AND SAVEAREA POINTER                             A
*.RC- BASE REGISTER FOR GLOBAL DSECT                                  A
*.RX- BASE REGISER FOR MACRO DICTIONARY                               A
*.                                                                    A
*.NAMES=MCSY____                                                      A
*.                                                                    A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCSYSR   CSECT
         $SAVE RGS=(R14-R0),SA=*,BR=13
         USING AVWXTABL,RAT        SET MAIN TABLE USING
         XSNAP LABEL='***MCSYSR ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X
               ,TM)
         USING MCGLBDCT,RC         USE GLOBAL DSCT AS DUMMY FOR SEARCH
         USING MACLIB,RX           RX POINTS TO CURRENT MACLIB ENTRY
         LR    R0,RA               COPY SCAN POINTER
         SR    RD,RD               CLEAR RD FOR RETURN CODE
         $CALL MCVSCN              SCAN SYMBOL
         LTR   RB,RB               VAR SYMBOL?
         BZ    MCSY01              PROCEED IF YES
         L     RB,AWFM4            ELSE SET NO SYMBOL FLAG
         B     MCSYFT              AND RETURN
         SPACE
*.VARIABLE SYMBOL FOUND SEARCH PARAM DICTIONAY                        A
*.                                                                    A
MCSY01   EQU   *
         L     RC,MCPARPNT         GET PNTR TO PARAM LIST
         $CALL MACFND              SCAN PARAM DICT.
         LTR   RB,RB               SYMBOL F6UND?
         BNZ   MCSY02              IF NOT PROCEED WITH  GLOBAL SEARCH
         LA    RD,$SYMPAR          ELSE SET PARAMETER FLAG
         CLI   MCGLBTYP,C'S'       CHECK IF SYSTEM VARIABLE
         BNE   MCSYFT              RETURN IF NOT
         LA    RD,$SYSVAR          ELSE SET SYSTEM FLAG
         B     MCSYFT              AND RETURN
         SPACE
*.NOT IN PARM DICTIONARY, SEARCH GLOBAL DICTIONARY                    A
*.                                                                    A
MCSY02   EQU   *
         L     RC,AVMGDICT         GET PNTR TO GLOBAL DICTIONARY
         $CALL MACFND              SEARCH DICTIONARY
         LTR   RB,RB               SYMBOL FOUND?
         BNZ   MCSY03              PROCEED WITH PARAM SEARCH IF NOT
         CLC   MCGLBDEF,AVMMACID   GLOBAL DECLARED THIS DEFINITION?
         BNE   MCSY03              IF NOT, PROCEED AND SEARCH LOCAL DIC
         LA    RD,$GLOBAL          SET GLOBAL TYPE FLAG
         B     MCSYFT              AND RETURN
         SPACE
*.NOW CHECK LOCAL DICTIONARY                                          A
*.                                                                    A
MCSY03   EQU   *
         LA    RD,$LOCAL           SET LOCAL FLAG
         L     RC,MCDDVPNT         GET LOCAL DICT @
         $CALL MACFND              SEARCH LOCAL DICTIONARY
         LTR   RB,RB               SYMBOL FOUND?
         BZ    MCSYFT              IF YES, RETURN
         LR    RA,R0               ELSE RESTORE SCAN POINTER FIRST
MCSYFT   EQU   *
         XSNAP LABEL='***MCSYSR EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN  RGS=(R14-R0)
         DROP  RAT,RC,RX,R13
         LTORG
         TITLE '***MCDTRM - CONVERTS DECIMAL TO BINARY***'
**-->  CSECT:  MCDTRM   DECIMAL CONSTANT CONVERSION.  MCDTRM DECIDES  *
*.        SCAN POINTER IS POINTING AT LEGAL DECIAMAL TERM AND IF SO,  *
*.        CONVERTS TO BINARY FORM. HANDLES VALUES UP TO 2**31-1       *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHAR OF TERM                                   *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER BEYOND CONSTANT                            *
*.        = SAME AS ENTRY IF ERROR                                    *
*.     RB = 0 IF CONSTANT WAS LEGAL                                   *
*.        = $ER MSSGE IF ILLEGAL TERM                                 *
*.     RC = VALUE OF CONSTANT, 0 TO 2**31-1                           *
*.                                                                    *
*.        USES DSECTS: AVWXTABL                                       *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.REGISTER USAGE                                                      A
*.R12 -BASE REG                                                       A
*.RAT-MAIN TABLE DSECT USING                                          A
*.RD- SCAN POINTER                                                    A
*.                                                                    A
*.NAMES=MCD_____                                                      A
*.                                                                    A
*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 4
MCDTRM   CSECT
         $SAVE RGS=(R0-R2),SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MCDTRM ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X
               ,TM)
         LR    RD,RA               COPY SCAN POINTER
         SR    R1,R1               USE IN TRT INST
         TRT   0(11,RD),AWTDECT    TRANSLATE WITH DEC TABLE
         BZ    MCDTRMR1            ERROR IF MORE THAN 10 DIGITS
         BM    MCDTRM01            < 10 DIGITS, PROCEED
         CLC   0(10,RA),=C'2147483647'  10 DIGIT NUMBER WITHIN RANGE?
         BH    MCDTRMR1            ERROR IF GREATER
MCDTRM01 EQU   *
         LR    RA,R1               UPDATE SCAN POINTER
         SR    R1,RD               GET LENGTH
         BZ    MCDTRMR1            ILLEGAL IF ZERO LENGTH
         BCTR  R1,0                GET LENGTH-1 FOR EX INST
         EX    R1,MCDECPAK         PACK CHARS
         CVB   RC,AVDWORK1         CONVERT THE NIMBER
         SR    RB,RB               SHOW NO ERRORS
MCDTRMRT EQU   *
         XSNAP LABEL='***MCDTRM EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN  RGS=(R0-R2),SA=NO
MCDTRMR1 LA    RB,$ERSDINV         SET ILLEGAL NUMBER FLAG
         B     MCDTRMRT            AND RETURN
MCDECPAK PACK  AVDWORK1(8),0(0,RD)  PACK DEC CHARS
         LTORG
         DROP  RAT
         TITLE '***MCGTST - CHARSTRING STORE ROUTINE***'
**-->  CSECT:  MCGTST  THIS ROUTINE TAKES A STRING AS DELINEATED BY   *
*.        BEGINNING AND END POINTERS, OBTAINS STORAGE DYNAMICALLY AND *
*.        MOVES THE STING.  IF INSIDE QUOTES DOUBLE QUOTES WILL BE    *
*.        CRUNCHED TO ONE QUOTE                                       *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CAHRACTER OF STRING                            *
*.     RB = @ OF DELIMITER PAST STRING                                *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIMITER PAST STRING                                *
*.     RC = @ OF STRING IN NEW STORAGE                                *
*.     RD = LENGTH OF STRING                                          *
*.                                                                    *
*.        USES MACROS: $SAVE, $RETURN, $ALLOCL                        *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.   REGISTER USAGE                                                   A
*.       RAT-MAIN TABLE USING                                         A
*.       RA,RB,RC,RD-AS IN ENTR/EXIT CONDITIONS                       A
*.       RE,R1,R3-WORK REGISTERS                                      A
*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCGTST   CSECT
         $SAVE RGS=(R0-R3),SA=NO
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCGTST ENTERED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         CR    RA,RB               NULL STRING?
         BE    MCGTSTF             SKIP OUT IF NULL STRING            S
         LR    RE,RB               COPY END DELIM
         SR    RE,RA               GET LENGTH
         LR    RD,RE               COPY LENGTH
         LA    RE,3(RE)            GET NEXT FULL WORD PLUS            A
         SRL   RE,2
         SLL   RE,2                TRUNCATE TO FULL WORD
         $ALLOCL  RC,RE,MCGTOVR    OBTAIN STORAGE FOR STRING
         LR    RE,RD               COPY ORIGINAL LENGTH
         BCTR  RE,0                DECR FOR EX INST
         EX    RE,MCGTMV           MOVE STRING INTO STORAGE
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCGTSTFT            IF NOT, RETURN
         LR    R1,RC               GET @ OF STIRNG START
         LR    R3,R1
         AR    R3,RE               GET @ OF END OF STRING
         BCTR  R3,0                DECR TO SECOND LAST CHAR
         LA    R2,1                USE R2 AS INDEX
MCGTST02 EQU   *
         CLI   0(R1),C''''         QUOTE?
         BCTR  RE,0                REDUCE RMNDR COUNT
         BE    MCGTST03            SQUEEZE QUOTE IF YES
         BXLE  R1,R2,MCGTST02      ELSE BUMP INDEX AND RESUME SCAN
          B    MCGTSTFT            ELSE RETURN IF SCAN FINISHED
MCGTST03 EQU   *
         EX    RE,MCGTMVC                                             A
         MVI   1(R3),C' '          INSERT BLANK AT END OF SQUZD STRNG
         BCTR  R3,0                DECR END OF STRING POINTER
         BCTR  RE,0                DECR REMAINING LENGTH
         BCTR  RD,0                REDUCE OVERALL LENGTH
         AR    R1,R2               BUMP SCAN POINTER                  A
         B     MCGTST02            RESUME SCAN
MCGTMVC  MVC   0($,R1),1(R1)       SQUEEZE OUT QUOTE                  A
         SPACE 2
MCGTSTF  LM    RC,RD,AWZEROS       ZERO OUT- NULL STRING              S
MCGTSTFT EQU   *
         LR    RA,RB               MOVE SCAN POINTER
         XSNAP LABEL='***MCGTST EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN RGS=(R0-R3),SA=NO
         SPACE
MCGTOVR  L     R15,AVMOVRFL        GET @ OF OVERFLOW ROUTINE
         BR    REP                 BRANCH THERE
MCGTMV   MVC   0($,RC),0(RA)       MOVE STRING INTO STORAGE           A
         DROP  RAT
         LTORG
         TITLE '*** MCATRM - ATTRIBUTE PROCESSOR ***'
**-->  CSECT: MCATRM       THIS ROUTINE SCANS A TERM AND DETERMINES   *
*.        WHETHER IT IS A VALID ATTRIBUTE, IE I', K', L', N', S' OR T'*
*.        THE LENGTH (L'), SCALE (S') AND INTEGER (I') ATTRIBUTES ARE *
*.        NOT IMPLEMENTED AND ARE SO FLAGGED.                         *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHAR OF TERM                                   *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIM PAST QUOTE IF VALID ATTRIBUTE ELSE SAME AS     *
*.          ENTRY.                                                    *
*.     RB = 0 IF ATTRIBUTE                                            *
*.        = -4 IF NOT ATTRIBUTE                                       *
*.        = $ERMESSAGE IF NOT IMPLEMENTED                             *
*.     RC = TYPE OF ATTRIBUTE                                         *
*.                                                                    *
*.        USES MACROS: $SAVE, $RETURN                                 *
*.        USES DSECTS: AVWXTABL                                       *
*.                                                                    *
*.*********************************************************************
         SPACE 2
MCATRM   CSECT
         $SAVE RGS=(R14-R2),SA=NO
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MCATRM ENTERED***',T=NO,IF=(AVMSNBY1,O,$MSNP06X
               ,TM)
         LM    RB,RC,AWZEROS       ZERO RB AND RC
*                                                                     A
         BCTR  RA,0                DECR POINTER
         TRT   0(1,RA),AWTSYMT     TEST PREV CHAR
         LA    RA,1(RA)            RESTORE POINTER
         BZ    MCATRMR1            NOT ATTRIBUTE IF PREV CHAR = ALPHA
         LA    RD,MCATTABL         GET @ OF ATTRIBUTE TABLE
MCATRMSC CLC   0(2,RA),0(RD)       COMPARE NEXT ENTRY
         BL    MCATRMR1            IF LOW, NOT FOUND, RETURN
         BE    MCATRMYS            IF EQUAL, FOUND
         LA    RD,4(RD)            ELSE BUMP TABLE POINTER
         B     MCATRMSC            TRY AGAIN
         SPACE
MCATRMYS IC    RB,3(RD)            SET PRESENCE FLAG
         IC    RC,2(RD)            SET TYPE
         CLI   3(RD),$ERNOIMP      IMPLEMENTED?
         BE    MCATRMRT            IF NOT, DON'T MOVE POINTER
         LA    RA,2(RA)            BUMP POINTER
         B     MCATRMRT
MCATRMR1 EQU   *
         L     RB,AWFM4            SET -4 FOR NO ATTIB
MCATRMRT EQU   *
         XSNAP LABEL='***MCATRM EXITED***',IF=(AVMSNBY1,O,$MSNP06,TM)
         $RETURN  RGS=(R14-R2),SA=NO
         SPACE 2
MCATTABL DC    C'I''',AL1($BSATI,$ERNOIMP),C'K''',AL1($BSATK,X'00')
         DC    C'L''',AL1($BSATL,$ERNOIMP),C'N''',AL1($BSATN,X'00')
         DC    C'S''',AL1($BSATS,$ERNOIMP),C'T''',AL1($BSATT,X'00')
         DC    X'FFFF'                                                A
         LTORG
         DROP  RAT,REP
         TITLE '***MCBODY - PROCESSES BODY OF MACRO DEFINITION***'
**-->  CSECT:  MCBODY   PROCESSES THE BODY OF MACRO DEFINITION.       *
*.        CALLED FORM MACRO1 AFTRR PROTOTYPE STATEMENT PROCESSED.     *
*.        INITIALIZES LOCAL DICTIONARY FOR CURRENT DEFINITION.        *
*.        PROCESSES EACH STATEMENT TILL MEND STATEMENT ENCOUNTERED.   *
*.        TERMINATES AND RETURNS AT THAT POINT                        *
*.                                                                    *
*.       IN OPEN-CODE MODE, ($MCOCFL1 ON IN MCLBFLG2),                *
*.       MCBODY ONLY PROCESSES STMT IN RSBLOCK                        *
*.       IF AVPRSAVE IS SET IN AVPRINT1, IT CALL MXMVSR               *
*.       TO SAVE STMT IN HIGH AREA, ELSE IT PRINTS IT IMMEDIATELY     *
*.        ENTRY CONDITIONS                                            *
*.     RC = @ OF MACLIB ENTRY OF CURRENT MACRO DEFINITION             *
*.                                                                    *
*.        USES MACROS: $SAVE,$RETURN,$CALL,$ALLOCL,$ALLOCH,$SCOF,     *
*.                     $SETRT                                         *
*.        USES DSECTS: AVWXTABL,MACLIB,MCLCLDPV,OPCODTB,RSBLOCK,MCBSU,*
*.                     MCSEQ,MCGLBDCT,MCOPQUAD                        *
*.        CALLS INCARD,ERRTAG,MACSCN,ERRLAB,MCVSCN,MACFND,SDDTRM,     *
*.              MCSYSR,MACLEX,MCGTST,OUTPT2,MCGNCD                    *
*.                                                                    *
*.  REGISTER USAGE *************************                          A
*.R13- BASE REGISTER AND SAVEAREA POINTER                             A
*.RAT-MAIN TABLE DSECT USING                                          A
*.RX- MACLIB DSECT USING                                              A
*.RY- LOCAL DICTIONARY DSECT UING                                     A
*.RZ-OPCODE TABLE DSECT USING                                         A
*.RB,RE,RA- WORK REGISTERS                                            A
*.R1,R2 USED IN TRT'S                                                 A
*.RET- RETURN REGISTER USED FOR INSUBS                                A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCBODY   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT
         XSNAP LABEL='***MCBODY ENTERED***',IF=(AVMSNBY1,O,$MSNP07,TM)
         USING MACLIB,RX           SET USING FOR MACRO LIBRARY ENTRY
         LR    RX,RC               COPY @ OF MACLIB ENTRY
         USING MCLCLDPV,RY         SET USING FOR LOCAL DV ENTRY
         USING OPCODTB,RZ          SET USING FOR OPCODE TABLE ENTRY
         NI    AVMBYTE1,$MINDEF    CLEAR AVMBYTE1
         LM    R1,R2,AWZEROS       CLEAR R1 AND R2
         MVC   AVMCRINS,AWZEROS    ZERO PTR TO 1ST ONE-OP             J
         AIF   (NOT &$MACOPC).MCBODYA   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MCBOD02             IF YES, SKIP DUMMY ENTRIES         S
.MCBODYA ANOP                                                         S
         LA    RB,$LLCLDV          GET LENGTH OF LOCAL DOPE VECTOR
         SPACE
*    THIS DUMMY ENTRY IN LOCAL DICT WILL BE USED FOR ACTR AND &SYSNDX
         $ALLOCL  RY,RB,MCBODOVR   GET AREA FOR ENTRY
         ST    RY,MCDDVPNT         SAVE @ IN MACLIB
         MVC   0($LLCLDV,RY),AWZEROS   CLEAR ENTRY
         MVI   MCLCLTYP,$ARITH     SET TYPE EQUAL TO ARITH FOR LENGTH
         MVI   MCLCLDIM+1,1        SET DIMENSION TO 1
         MVI   MCLOCDLN+3,4        INIT LENGTH OF DICT TO 4
         SPACE
*    DUMMY ENTRY FOR SEQUENCE SYMBOL TABLE
         USING MCSEQ,RE            SET USING FOR SEQ SYMBOL ENTRY
         LA    RB,$LMCSEQ          GET LENGTH OF ENTRY
         $ALLOCH RE,RB,MCBODOVR    OBTAIN AREA FOR ENTRY
         ST    RE,AVMSEQPT         SAVE @ IN MAIN TABLE
         MVC   0($LMCSEQ,RE),AWZEROS   ZERO ENTRY
         MVI   MCSEQFLG,X'FF'      SET DEFINED FLAG
         DROP  RE        CLEAR USING
         EJECT                                                        A
         USING RSBLOCK,RW          SET USING FOR SOURCE STMNT
MCBOD01  EQU   *
         AIF   (NOT &$MACOPC).MCBODYB   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MACBODRT            RETURN IF YES                      S
.MCBODYB ANOP                                                         S
         L     RW,AVRSBPT          GET @ OF SOURCE STMNT
         $CALL INCARD              READ NEXT STATEMNT
         LTR   RB,RB               ERROR ON INPUT
         BZ    MCBOD02             JUMP ND PROCESS IF NOT
         $CALL ERRTAG              ELSE FLAG STMNT
         TM    AVTAGS2,$INEND2     END OF FILE?
         BO    MACBODRT            RETURN IF YES
MCBOD02  EQU   *
         LA    RA,RSBSOURC         SET SCAN POINTER
         ST    RA,MCBDSRPT         SAVE RSBSOURC @ FOR $SCOF USE
         MVI  AVMBYTE2,X'00'       ZERO FLAG BYTE 2
         MVI   AVMBYTE4,X'00'      CLEAR AVMBYTE4
         $CALL MACSCN              SCAN STMT
         C     RB,=F'8'            MACRO COMMENT?
         BE    MCBODPR1            JUMP AND PRINT IF YES
         LR    RZ,RC               COPY OPCODTB ENTRY @ INTO RZ
         DROP  RW                  DROP USING ON SOURCE IMAGE
         USING MCBSU,RW            SET UP USING ON BSU
         L     RW,AVMCHSTR         SET BASE FOR BSU WORKAREA
         MVC   MCBSU(8),AWZEROS    CLEAR FIRST BSU
         CLI   AVMFLDT2,C'M'       MACRO OPCODE?
         BE    MCBODJMP            IF YES, JUMP AND FIND WHICH OPCODE
         CLI   AVMFLDT2,C'I'       INNER MACRO INSTRUCTION?
         BNE   MCBODSTR            PROCESS MODEL STMT IF NOT          S
         AIF   (NOT &$MACOPC).MCBODYE   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MCBODSTQ            PROCESS MODEL STMT (NO INNER MACS) A
.MCBODYE ANOP                                                         S
         B     MCBDINMC            PROCESS INNER MACRO                S
*  THIS SECTION GETS THE TYPE OF OPERATION AND BRANCHES TO THE        A
*  CODE TO PROCESS IT                                                 A
MCBODBAS DS    0H
MCBODJMP EQU   *
         SR    R2,R2               C3EAR R2 FOR INDEX ACTION
         IC    R2,OPCHEX           GET OPCODE INDEX
         LA    R1,MCFLGTAB(R2)     LOAD @ OF TABLE ENTRY              S
         MVC   *+7(1),1(R1)        MOVE MASK INTO NEXT TM INSTR       S
*              NOTE:  THE NEXT INST IS MODIFIED BY THE PREVIOUS INST  S
         TM    MCLBFLG2,$          TEST IF CARD OUT OF ORDER          S
         BO    MACMACRO            BRANCH IF CARD OUT OF ORDER        S
         OC    MCLBFLG2(1),0(R1)   SET CURRENT OPCODE FLAG            S
         LH    R1,MACBINDX(R2)     GET REL @ FROM TABLE
         B     MCBODBAS(R1)        JUMP TO ROUTINE
         SPACE 2
MACBINDX $AL2  MCBODBAS,(MACMACRO,MACGBLA,MACGBLB,MACGBLC,MACLCLA,MACLCX
               LB,MACLCLC,MACACTR,MACSETA,MACSETB,MACSETC,MACAIF,MACAGOX
               ,MACANOP,MACMNOTE,MACMEXIT,MACMEND),-2
         EJECT                                                        S
*        THIS MACRO FLAG TABLE IS USED TO EITHER SET OR TEST A FLAG   S
*        TO CHECK IF A MACRO OPCODE IS OUT OF ORDER.                  S
*        ......THE FIRST BYTE OF EACH TWO BYTE ENTRY CONTAINS THE     S
*              FLAG TO BE SET INTO MCLBFLG2 WHEN THE OPCODE IS        S
*              ENCOUNTERED.  THE SECOND BYTE IS USED TO TEST AGAINST  S
*              MCLBFLG2 TO SEE IF THE CURRENT OPCODE IS OUT OF ORDER. S
*                                                                     S
*                  SET , TEST          OPCODE                         S
*                  ---   ----          ------                         S
*                                                                     S
MCFLGTAB EQU   *-2                 ORIGIN OF HALF-WORD TABLE          A
         DC    AL1(0,$MGBLFLG)     MACRO                              A
         DC    AL1(0,$MGBLFLG)         GBLA                           S
         DC    AL1(0,$MGBLFLG)         GBLB                           S
         DC    AL1(0,$MGBLFLG)         GBLC                           S
         DC    AL1($MGBLFLG,$MLCLFLG)  LCLA                           S
         DC    AL1($MGBLFLG,$MLCLFLG)  LCLB                           S
         DC    AL1($MGBLFLG,$MLCLFLG)  LCLC                           S
         DC    AL1($MACTFLG,$MACTFLG)  ACTR                           S
         DC    AL1($MACTFLG,0)         SETA                           S
         DC    AL1($MACTFLG,0)         SETB                           S
         DC    AL1($MACTFLG,0)         SETC                           S
         DC    AL1($MACTFLG,0)         AIF                            S
         DC    AL1($MACTFLG,0)         AGO                            S
         DC    AL1($MACTFLG,0)         ANOP                           S
         DC    AL1($MACTFLG,0)         MNOTE                          S
         DC    AL1($MACTFLG,0)         MEXIT                          S
         DC    AL1($MACTFLG,0)         MEND                           S
         DROP  RY                  CLEAR TEMP USING OF RY
         SPACE 2
         TITLE '***MCBODY - GBLX ROUTINES***'
         USING MCGLBDCT,RY         ESTAB USING FOR GLOBAL ENTRY
MACGBLA  EQU   *
MACGBLB  EQU   *
MACGBLC  EQU   *
         BAL   RET,MCB01           CHECK FOR LABEL & OPERAND          J
MCGB04   EQU   *
         ST    RA,AVMTSCNP         COPY SCAN POINTER TEMPRORARILY
         $CALL MCVSCN              SCAN SYMBOL
         LTR   RB,RB               VARIABLE SYMBOL?
         BZ    MCGB05              PROCESS IF OKAY
*                                                                    AS
         LA    RB,$ERINVSY         SET ERROR FLAG IF RB›=0            A
         B     MCBDPRER            AND JUMP AN4 FLAG
*   AT THIS POINT LEGAL SET SYMBOL                                    A
MCGB05   EQU   *
         L     RC,MCPARPNT         GET PARAM LIST START @
         $CALL MACFND              SCAN PARAM LIST
         LTR   RB,RB               SYMBOL PRESENT
         BZ    MCGBMD              ERROR IF YES-QUIT                  A
*  LEGAL GLOBAL DECLARATION                                           A
         L     RC,AVMGDICT         GET GLOBAL DICT POINTER
         $CALL MACFND              SCAN GLOBAL DICT
         LR    RY,RC               MOVE DICT ENTRY TO REGULAR BASE
         LTR   RB,RB               SYMBOL PRESENT?
         BNZ   MCGB07              JUMP AND PROCESS IF NOT PRESENT
         CLC   MCGLBDEF,AVMMACID   ELSE IS IT PREV DEFINED THIS DEF?
         BE    MCGBMD              MULT DEF IF YES
         CLC   MCGLBTYP,AVMBYTE3   DO TYPES MATCH?
         BNE   MCGBMD              IF NOT, THEN ERROR
         LA    RC,1                SET DIMENSION=1 FOR NO DIMEN       A
         CLI   0(RA),C'('          SYMBOL DIMENSIONED?
         BNE   MCGB08              IF NOT, PROCEED
         BAL   RET,MCB02           GET DIMENSION                      J
MCGB08   EQU   *                   COME HERE TO CHECK SIZES=          A
         CH    RC,MCGLBDIM         DIMENSIONS M1TCH?
         BE    MCGB10              PROCEED IF YES
         B     MCGBMD              AND JUMP AND FLAG MULT DEF ERROR
         SPACE
MCGB07   EQU   *
         LA    RC,1                SET DIMENSION TO 1
         CLI   0(RA),C'('          DIMENSIONED?
         BNE   MCGB11              PROCEED WITH SINGLE DIM IF NOT
         BAL   RET,MCB02           GET DIMENSION                      J
         BAL   RET,MCB03           CHECK SIZE                         J
MCGB11   EQU   *
         LA    RB,$LGLBENT         GET LENGTH OF GLOBAL ENTRY
         $ALLOCL  RE,RB,MCBODOVR   GET AREA FOR ENTRY
         ST    RE,MCGLBNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RE               MOVE BASE TO NEW ENTRY
         MVC   MCGLBNXT($LGLBENT),AWZEROS   CLEAR NEW ENTRY
         MVC   MCGLBLEN(9),AVMSYMLN  MOVE SYMABOL INTO ENTRY
         MVC   MCGLBTYP,AVMBYTE3   SAVE TYPE IN ENTRY
         STH   RC,MCGLBDIM         SAVE DIMENSI6N IN ENTRY
         SR    RE,RE               CLEAR RE
         IC    RE,AVMBYTE3         PLACE TYPE LENGTH IN RE
         CLI   AVMBYTE3,$CHAR      WAS IT CHARACTER?
         BE    MCGB12              IF YES , PROCEED WITH LENGTH OF 12
         LA    RE,4                ELSE USE LNG OF 4 FOR BOOL & ARITH A
MCGB12   LH    RD,MCGLBDIM         GET DIMENSION OF ARRAY
         SR    R0,R0               CL1R R0 FOR USE IN LOOP
MCGB13   EQU   *
         $ALLOCL  RB,RE,MCBODOVR   GET AREA FOR ELEMENT
         ST    R0,0(RB)            INITIALIZE TO ZERO
         BCT   RD,MCGB13           LOOP BACK IF NOT FINISHED
         SPACE 2
MCGB10   EQU   *
         MVC   MCGLBDEF,AVMMACID   SAVE CURRENT DEF ID
         CLI   0(RA),C' '          END OF OPRND LIST?
         BE    MCBODPR             JUMP AND PRINT IF YES
         CLI   0(RA),C','          PROPER DELIMITER?
         BNE   MCGBINVD            INVALID DELIM-GO FLAG              A
         LA    RA,1(RA)            BUMP SCAN POINTER PAST ','
         B     MCGB04              AND RESUME SCAN
         DROP  RY                  CLEAR RY USING AFTER GLOBAL USE
         TITLE '***MCBODY - LCLX ROUTINES***'
         USING MCLCLDPV,RY         USE RY AS BASE FOR LOCAL ENTRIES
MACLCLA  EQU   *
MACLCLB  EQU   *
MACLCLC  EQU   *
         BAL   RET,MCB01           CHECK FOR LABEL & OPERAND          J
MCLC04   EQU   *
         ST    RA,AVMTSCNP         COPY SCAN POINTER
         $CALL MCVSCN              SCAN FOR LEGAL VAR SYMBOL
         LTR   RB,RB               OKAY?
         BNZ   MCBDPRER            IF NOT, JUMP AND FLAG
         LR    R0,RA               COPY NEW SCAN POINTER VALUE TEMP
         L     RA,AVMTSCNP         GET ORIGINAL SCAN POINTER
         $CALL MCSYSR              SEARCH ALL DICTS FOR SYMBOL
         LTR   RB,RB               PRESENT ALREADY?
         BZ    MCGBMD              GO FLAG MULTIPLE DEFINITION        A
         LR    RA,R0               RESTORE SCAN POINTER
         LR    RY,RC               MOVE BASE TO USING REG RY
         LA    RB,$LLCLDV          GET LENGTH OF LCAL DV
         $ALLOCL  RE,RB,MCBODOVR   GET AREA FOR ENTRY
         MVC   0($LLCLDV,RE),AWZEROS   ZERO OUT ENTRY
         ST    RE,MCLOCNXT         SAVE POINTER IN PREV ENTRY
         LR    RY,RE               MOVE BASE TO NEW ENTRY
         MVC   MCLCLLEN(9),AVMSYMLN  MOVE NAME INTO NEW ENTRY
         MVC   MCLCLTYP,AVMBYTE3   ESTABLISH TYPE OF SET SYMBOL ENTRY
         MVC   MCLCLDIM,AWH1       SET DIM = 1 FOR PRESENT
         CLI   0(RA),C'('          DIMENSIONED?
         BNE   MCLCFT              IF NOT, PROCEED
         BAL   RET,MCB02           GET DIMENSION                      J
         SPACE
MCLC07   EQU   *
         BAL   RET,MCB03           CHECK DIMENSION SIZE               J
MCLC08   EQU   *
         STH   RC,MCLCLDIM         SET DIMENSION IN ENTRY
MCLCFT   EQU   *
         LA    R1,4                ASSUME LENGTH = 4
         TM    MCLCLTYP,$CHAR      TEST FOR TYPE
         BNO   MCLC11              SKIP IF NOT CHAR
*        ASSEMBLER G CAHRACTER DECL WILL CHANGE FOLLOWING.
         LA    R1,12               ELSE USE CHAR LENGTH OF ENTRY
MCLC11   EQU   *
         MH    R1,MCLCLDIM         GET TOTAL SIZE OF ARRAY
         L     RE,MCLOCDLN         GET CURRENT OFFSET/LENGTH          A
         ST    RE,MCLCLPNT         STORE AS OFFSET TO THIS VAR        A
         AR    R1,RE               UPDATE TOTAL DICT LENGTH           A
         ST    R1,MCLOCDLN         SAVE LENGTH OF LOCAL DICT IN MACLIB
         SPACE 1                                                      A
         CLI   0(RA),C' '          WAS THIS LAST ONE?                 A
         BE    MCBODPR             YES QUIT AND PRINT                 A
         CLI   0(RA),C','          OK DLM                             A
         BNE   MCGBINVD            NO, ERROR KILL IT                  A
         LA    RA,1(,RA)           BUMP SCAN PTR TO NEXT OPRND        A
         B     MCLC04              RETURN FOR NEXT OPRND              A
         DROP  RY                  DROP TEMP USING OF RY FOR LOCALS
         EJECT                                                        A
**--> INSUB: MCB01      CHECK LCLX,BLX FOR LABEL, OPCODE  + + + + + + J
*+                                                                   +A
*+    THIS IS CALLED TO CHECK FOR AN ERROR IN THE GBLX OR             A
*+       GBLX INSTRUCTION. IF AN ERROR OCCURES WHEN A LABEL IS PRESENTA
*+       AND/OR THERE IS NO OPERANDS.                                 A
*+                                                                    A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCB01    EQU   *                                                      J
         MVC   AVMBYTE3,OPCMASK    GET TYPE OF SET SYMBOL             A
         CLI   AVMFLDL1,0          CHECK IF LABEL PRESENT(L›=0)       A
         BE    MCB001              IF NOT PROCEED                     J
         ST    RET,MCB##SAV        SAVE THE RETURN @                  J
         LA    RB,$ERILLAB         ELSE SET ERROR FLAG                A
         $CALL ERRLAB              AND FLAG STMT                      A
         L     RET,MCB##SAV        RESTORE RETURN @                   J
MCB001   EQU   *                                                      J
         L     RA,AVMFLD3          GET @ OPERAND; =0 IF NONE          A
         LTR   RA,RA               DID ONE EXISTS                     A
         BCR   NZ,RET              YES-RET, NORMAL CASE               A
         B     MCBDOPER            NO-ERROR-MISSING OPERAND           A
         SPACE 5                                                      A
**--> INSUB: MCB02      OBTAIN DIMENSION OF GBLX OR LCLX STMT + + + + J
*+       BUNPS POINTER GETS DIMENSION AND FLAGS ERROR IF NOT CONST   QA
*+ RA= @ '(' ON ENTRY; @ BEYOND '(' ON EXIT IF GOOD                   A
*+  RC=VALUE OF SUBSCRIPT IF GOOD                                     A
*+ + + + + + + + + + ++  + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 5                                                      A
MCB02    ST    RET,MCB##SAV        SAVE RETURN @                      J
         LA    RA,1(RA)            BUMP PTR PAST )                    J
         $CALL SDDTRM              AND GET DIMENSION                  A
         LTR   RB,RB               DIMENSION=CONSTANT?                A
         BNZ   MCBDPRER            FLAG ERROR IF NOT                  A
         CLI   0(RA),C')'          CURRENT ENDING DLM                 A
         BNE   MCGBINVD            NO ERROR                           A
         LA    RA,1(,RA)           YES BUMP BEYOND )                  A
         L     RET,MCB##SAV        RESTORE RETURN @                   J
         BR    RET                 RETURN                             A
         SPACE 5                                                      A
**--> INSUB: MCB03: CHECK DIMENSION SIZE FOR GBLX,LCLX+ + + + + + + + J
*+       CHECKS TO MAKE SURE DIMENSION OF                           + A
*+       GBLX AND/OR LCLX IS WITHIN RANGE                           + A
*+       FLAGS ERROR IF NOTS WITHIN RANGE                           + A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +  A
         SPACE 2                                                      A
MCB03    C     RC,=F'2500'         DIMENSION WITHIN RANGE?            J
         BCR   NH,RET              RETURN IF NOT                      J
         LA    RB,$EREXGTA         ELSE SET ERROR FLAG                A
         B     MCBDPRER            AND FLAG STMT                      A
         TITLE '***MCBODY - SET INSTRUCTION ROUTINES***'
*                                                                     A
* SETX SYMBOLS FOUND, SET FLAG FOR TYPE & CONTINUE SCAN OF EXPRESSION A
*                                                                     A
MACSETA  EQU   *
         MVI   AVMBYTE3,$ARITH      SET ARITH TYPE FLAG
         B     MACSET
MACSETB  EQU   *
         MVI   AVMBYTE3,$BOOL       SET BOOLEAN FLAG
         B     MACSET
MACSETC  EQU   *
         MVI   AVMBYTE3,$CHAR       SET CHARACTER TYPE FLAG
*                                                                     A
*  CKECK FOR LEGAL SETUP IE, NO OPERAND ERRORS, NO LABEL              A
* ON STATEMENT, ERROR IF LOOKS LEGAL, GO ON ELSE FLAG ERROR           A
*                                                                     A
MACSET   EQU   *
         BAL   RET,MCB001          CHECK FOR OPERND,GET@              A
         L     RA,AVRSBPT          GET SOURCE BLOCK ADDRESS
         LA    RA,4(RA)            BUMP TO SOURCE STMNT
         CLI   AVMFLDL1,X'00'      LABEL PRESENT?
         BNE   MCBDST03            PROCEED IF YES
         LA    RB,$ERNONAM         SET MISSING LA&EL FLAG
         B     MCBDPRER            JUMP AND FLAG ERROR
* GET THE BSU ADDRESS SET TYPE & IF NEITHER OF THE SET TYPES-ERROR    A
*                                                                     A
MCBDST03 EQU   *
         LR    RC,RW               SET POINTER TO BSU
         $CALL MACLEX              SCAN LABEL FIELD
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            JUMP OUT IF YES
         LR    RW,RC               RESTORE BSU POINTER
         L     RE,AVMCHSTR         GET @ OF BSU WORKAREA
         CLI   AVMBYTE3,$BOOL      IS SET A, B, OR C
         BH    MCSETCHR            CHR IF HIGHER
         BE    MCSETBOL            BOOLEAN IF EQUAL
         OI    AVMBYTE2,$MINARIT   ELSE IS ARITHMETIC
         MVI   MCBSINDX,$BSETA     SET BSU INDEX FOR SETA
         CLI   1(RE),$BSTSYAG      IS IT GLOBAL ARITH SET SYSMB?
         BE    MCBDST01            IF YES, OKAY
         CLI   1(RE),$BSTSYAL      ELSE IS IT LOACAL ARITH SET SYMBOL?
         BE    MCBDST01            IF YES, OKAY
         B     MCLMXDER            ELSE FLAG ERROR
*                                                                     A
*  CHECKS THE FORMAT OF SETB-MAKE SURE ITS 0 OR 1, PARENS LEGAL       A
*   THEN CHECKS FOR GLOBAL OR LOCALS                                  A
*                                                                     A
MCSETBOL EQU   *
         L     RA,AVMFLD3          GET OPERAND @
         CLI   0(RA),C'('          STARTS WITH LEFT PAREN?
         BE    MCSETB01            OKAY IF YES
         CLI   0(RA),C'1'          OPERAND = 1?
         BE    MCSETB01            OKAY IF YES
         CLI   0(RA),C'0'          OPERAND = 0?
         BE    MCSETB01            OKAY IF YES
         LA    RB,$ERINVF          ELSE SET INVALID FIELD FLAG
         B     MCBDPRER            JUMP AND FLAG STMTN
MCSETB01 EQU   *
         OI    AVMBYTE2,$MINBOOL   SET BOOLEAN FLAG
         MVI   MCBSINDX,$BSETB     SET BSU INDEX
         CLI   1(RE),$BSTSYBG      IS IT BOOLEAN GLOBAL SET?
         BE    MCBDST01            OKAY IF YES
         CLI   1(RE),$BSTSYBL      ELSE IS IT BOOLEAN LOCAL SET?
         BE    MCBDST01            OKAY IF YEW
         B     MCLMXDER            ELSE FLAG EROR
*                                                                     A
* CHECK FOR LEGAL SETC SYMBOL                                         A
*                                                                     A
MCSETCHR EQU  *
         MVI   MCBSINDX,$BSETC     SET BSU INDEX
         OI    AVMBYTE2,$MINCHAR   SET CHAR FLAG
         CLI   1(RE),$BSTSYCG      IS IT CHAR GLOBAL SET SYMBOL?
         BE    MCBDST01            OKAY IF YES
         CLI   1(RE),$BSTSYCL      ELSE IS IT CHAR LOCAL SET?
         BNE   MCLMXDER            ERROR IF NOT
MCBDST01 EQU  *
*                                                                     A
* SETS HIERARCHY OF BSU, SETS FLAGA & MOVES ADRESS THEN SCANS         A
*  THE OPERAND, IF IN ERROR, FLAGS IT                                 A
*                                                                     A
         MVI   MCBSHIER,$MSETHR    SET HEERARCHY
         OI    MCBSFLGS,$MOPRTR    SET OPERATOR FLAG IN BSU
         L     RA,AVMFLD2          GET @ OF OPCODE
         $SCOF  RB,RA,MCBSOFST     GET OPCODE @ INTO BSU
         BAL   RE,MCBDBMP          BUMP BSU POINTER
         LR    RC,RW               MOVE BSU POINTER TO RC
         L     RA,AVMFLD3          GET ADDRESS OF OPERAND
         $CALL MACLEX      SCAN OPERAND
         LTR  RB,RB                ERROR
         BNZ  MCBDPRER             FLAG STMNT IF YES
         B     MCBODPR             JUMP TO FOOT
         TITLE '***MCBODY - AGO,AIF, MNOTE ETC ROUTINES***'
*  WHEN AN ACTR STATEMENT FOUND, SETS FLAG FOR NO MORE GLOBALS OR     A
*  LOCALS. SEES IF ACTR STMT OK, THEN CHECKS IF LABEL PRESENT(ERROR)  A
* CHECKS FOR OPERANDS(ERROR IF NOT THERE) SETS INDEX(COUNTER) & SETS  A
* UP THE BSU.                                                         A
*                                                                     A
MACACTR  EQU   *
         BAL   RET,MCB01           CHECK OPRND @ EXISTENCE            A
         MVI   MCBSFLGS,$MTERM+$BSAR    SET BSU FLAGS
         MVI   MCBSINDX,$BSTSYAL   SET LOCAL ARITH SET INDEX
         MVC   MCBSLOC,MCDDVPNT    MOVE @ OF ACTR TO BSU
         BAL   RE,MCBDBMP          BUMP BSU
         L     RD,MCBDSET          CREATE BSU                         S
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   S
         OI    AVMBYTE2,$MINARIT   SET ARITH EXPRESSION FLAG
         LR    RC,RW               GET BSU POINTER
         $CALL MACLEX              SCAN EXPRESSION
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            FLAG IF YES
         LR    RW,RC               RESTORE BSU POINTER
         B     MCBODPR             JUMP AND PRINT STMNT
         SPACE 2
* AIF FOUND, CHECK FOR LEGAL SEQUENCE, NO LCLX OR GBLX, AND SYNTAX    A
*  MUST START WITH ( AND HAVE SEQ SYMB FOLLOWING, THEN SETS UP THE    A
*  BSU WITH THE ADDRESSES.                                            A
*                                                                     A
MACAIF   EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LEGAL LABEL
         BAL   RET,MCB001          CHECK OPRND @ EXISTENCE            A
         CLI   0(RA),C'('          FIRST CHAR = '('?
         BE    MACAIF01            PROCEED IF YES
         LA    RB,$ERVSYNT         SET SYNTAX FLAG
         B     MCBDPRER            AND FLAG ERROR
MACAIF01 EQU   *
         OI    AVMBYTE2,$MINPEXP+$MINBOOL  SET FLGS FOR PAREN SCAN
         LR    RC,RW               GET BSU POINTER
         $CALL MACLEX              SCAN OPERAND
         LR    RW,RC               RESTORE BSU POINTER
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            FLAG IF YES
         CLI   0(RA),C'.'          SEQ SYMBOL AFTER EXPRESSION?
         BNE   MCBDISER            ERROR IF NOT
         MVC   MCBSFLGS(4),MCBDAIF                                    A
         L     R2,AVMFLD2          GET OFFSET OF OPCODE
         $SCOF R1,R2,MCBSOFST      INSERT OFFSET IN BSU
         BAL   RE,MCBDBMP          BUMP BSU
         L     RD,MCBDLABL         GET FIRST HALF OF BSU              A
*                                                                     A
         B     MACAGO03                                               S
         SPACE 2
* SAME THING WITH AGO, CKS SYNTAX, LEGAL SEQ, ETC AND SETS UP         A
* THE BSU                                                             A
*                                                                     A
MACAGO   EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LEGAL CLABEL
         BAL   RET,MCB001          CHECK OPRND GET @                  A
         CLI   0(RA),C'.'          POSSIBLE SEQ SYMBOL?
         BE    MACAGO02            PROCEED IF YES
         LA    RB,$ERINVSY         ELSE SET BAD SYMBOL FLAG
         B     MCBDPRER            AND FLAG STATEMNT
MACAGO02 EQU   *
         L     RD,MCBDAGO          CREATE BSU                         S
MACAGO03 ST    RA,MCBSLOC          SAVE @ OF LABEL                    S
         B     MCBODPR0            PRINT STATEMENT                    S
         SPACE 2
MACANOP  EQU   *
         MVI   MCBSINDX,$BSANOP    INSERT BSU ANOP INDEX
         B     MACAMM
MACMEXIT EQU   *
         MVI   MCBSINDX,$BSMEXIT   SET MEXIT BSU
         B     MACAMM
MACMEND  EQU   *
         MVI   MCBSINDX,$BSMEND    SET MEND BSU INDEX
MACAMM   EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LEGAL LABEL
         MVI   MCBSFLGS,$MOPRTR    SET OPRTR FLAG
         MVI   MCBSHIER,$MPRNTHR   SET PRINT HIERARCHY
         L     RA,AVMFLD2          GET OPCODE @
         $SCOF RB,RA,MCBSOFST      PUT OFFSET IN BSU
         BAL   RE,MCBDBMP          BUMP BSU POINTER                   A
         B     MCBODPR                                                A
         SPACE 2
* MNOTE STMT FOUND, CKS FOR VALID SYNTAX, CREATES BSU. SCANS STRING   A
*  FOR MESSAGE, ALSO CHECKING SYNTAX(INVALID DELIM ETC) CONCATS IFL   A
* NECESSARY                                                           A
*                                                                     A
MACMNOTE EQU   *
         BAL   RET,MCBDCHLB        CHECK FOR LABEL
         CLI   AVMFLDL3,X'00'      OPRND PRESENT?
         BE    MCBDOPER            ERROR IF NOT
         BAL   RET,MCBDPFLC        CREATE PRINT BSU AND BUMP PTR      F
         MVC   MCBSU(8),MCBDSTG1   COPY WHOLE BSU FROM TABLE          J
         BAL   RE,MCBDBMP          BUMP BSU POINTER
         L     RA,AVMFLD3          GET OPRND @
         BAL   RET,MCBDPFLC        CREATE PRINT BSU AND BUMP PTR      F
         CLI   0(RA),C''''         QUOTED STRING?
         BNE   MCMNOT01
         MVC   MCBSU(8),MCBDSTG2   COPY WHOLE BSU= '1,' BSU           J
         BAL   RE,MCBDBMP
         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG
         OI    AVMBYTE2,$MTERM     SET TERM PREV FLAG
         B     MCMNOT04
MCMNOT01 EQU   *
         $SETRT  (',',4,'''',8)    SET TABLE FOR SCAN
         SR    RE,RE
         IC    RE,AVRSBLOC         GET LENGTH-1
         S     RA,AVRSBPT           GET OFFSET OF RA
         SR    RE,RA               SUBTRACT OVERALL LENGTH
         A     RA,AVRSBPT          RESTORE RA
         EX    RE,MCMNOTSC
         $SETRT  (',',0,'''',0)    RESTORE TABLE
         BNZ   MCMNOT02            PROCEED IF SCAN STOPPED ON CHAR
MCMNOTER EQU   *
         LA    RB,$ERNODLM         ELSE SET BAD DELIM FLAG
         B     MCBDPRER            AND FLAG STMT
MCMNOT02 EQU   *
         CLI   0(R1),C','          STOP ON COMMA?
         BNE   MCMNOTER            ERROR IF NO
         LA    RB,1(R1)            GET DELIM @
         SR    RB,RA               GET LENGTH IN RB
         BAL   RET,MCBDSCAN        SCAN SEVERITY EXPRESSION
MCMNOT04 EQU   *
         CLI   0(RA),C''''         QUOTE?
         BNE   MCMNOTER            ERROR IF NOT
         BAL   RET,MCBDCATI        INSERT CAT OPRTR
         OI    AVMBYTE2,$MINCHAR   SET CHAR STRING FALG
         LR    RC,RW               GET BSU PNTR
         $CALL MACLEX              SCAN STRING
         LR    RW,RC               BUMP BSU PNTR
         LTR   RB,RB               ERROR
         BNZ   MCBDPRER            FLAG IF YES
         MVI   AVMFLDT2,X'00'      ZERO TYPE BYTE
         L     RD,MCBDPR2          CREATE BSU                         S
         L     RA,AVMFLD3          GET OPRND @
         CLI   0(RA),C'*'          COMMNET?
         BE    MCBODPR0            SKIP IF YES                        S
         L     RD,MCBDPR3          MNOTE BSU                          A
         B     MCBODPR0            PRINT STATEMENT                    S
MCMNOTMS DC    CL12'***MNOTE***'
MCMNOT1C DC    C'1,'               DEFAULT MNOTE SEVERITY             J
MCMNOTSC TRT   0($,RA),AWTZTAB     DUMMY FOR COMMA QUOTE SCAN
         SPACE 2
MACMACRO EQU   *
         L     RA,AVMFLD2          GET OPCODE @ IN RA
         LA    RB,$ERSTMNA         SET STMNT NO GOOD FLAG
         B     MCBDPRER            JUMP AND FLAG ERROR
         TITLE '***MCBODY - STRING, INNER MACRO AND OPCODE ROUTINES***'
* CHECKS COMMENT, SETS PRINT BSU IF STMT SHOULD BE PRINTED AND/OR     A
*        DOESN'T PRINT SEQ SYMBOLS IN MACRO, OR MACRO COMMENTS. ALSO  A
* MOVES OPCODE DATA IN IF PRESENT                                     A
*                                                                     A
MCBODSTQ EQU   *                                                      A
         MVI   AVMFLDT2,0          OPEN CODE FAKE FOR MODEL STMT      A
MCBODSTR EQU   *
         C     RB,AWF4             COMMENT?
         BE    MCBODCOM            ORDINARY COMMENT IF EQUAL
         OI    MCLBFLG2,$MACTFLG   GLBL'S, ETC. NO LONGER OK          S
MCBDSTIN EQU   *
         CLI   AVMFLDT1,C'.'       SEQ SYMBOL?
         BE    MCBDOPCD            PROCESS OPCODE IF YES
         L     RA,AVMFLD1          ELSE GET PNTR TO LABEL FIELD
         LTR   RA,RA               LABEL PRESENT
         BZ    MCBDOPCD            PROCESS OPCODE IF NOT
         BAL   RET,MCBDPFLC        CREATE PRINT BSU, NON COMMENT TYPE A
         IC    RB,AVMFLDL1         GET LENGTH OFLABEL FIELD
         SR    RC,RC               SET TERMINAL CHAR INDICATOR        S
         BAL   RET,MCBDSCAN        SCAN LABEL FIELD
MCBDOPCD EQU   *
         CLI   AVMFLDL2,X'00'      OPCODE EXISTS?
         BE    MCBDSFIN            FINI IF NOT
         MVC   MCBDFLDS(5),AVMFLD2 ELSE MOVE OPCODE FIELD DATA
         SR    RC,RC               INDICATE VAR SYMBOLS PRESENT
         BAL RET,MCBDSCFD          SCAN OPCODE FIELD
*                                                                     A
* SCANS OPERAND FIELD ALLOWING FOR NON-STANDARD CONTINUATIONS         A
* THAT IS RUNNINF ACROSS UP TO 3 CARDS, BALS TO MCBDSCFD TO TEST FOR  A
*THE DIFFERENT FIELDS.                                                A
*                                                                     A
MCBDOPRN EQU   *
         MVC   MCBDFLDS(5),AVMFLD3   GET DATA FOR OPRND FILED
         SR    RC,RC               CLEAR RC FOR VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN OPRND FILED
         MVC   MCBDFLDS(5),AVMFLD4  GET DATA FOR COMMENT FIELD
         LA    RC,4                INDICATE NO VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN COMMNET FIELD
         CLI   AVMFLDL5,0          2ND NON STND CARD?
         BE    MCBDSFIN            FINI IF NOT
         MVC   MCBDFLDS(5),AVMFLD5   GET DATA ON 2ND CARD OPRND
         SR    RC,RC               INCICATE VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN OPNRD ON 2ND CARD
         MVC   MCBDFLDS(5),AVMFLD6   GET DATA ON COMMNET FIELD( IF ANY)
         LA    RC,4                INDICATE NO VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN COMMNET FIELD
         CLI   AVMFLDL7,0          3RD NON STND CARD?
         BE    MCBDSFIN            FINI IF NOT
         MVC   MCBDFLDS(5),AVMFLD7   GET DATA ON OPRND
         SR    RC,RC               INDICATE VAR SYMBOLS
         BAL   RET,MCBDSCFD        SCAN OPRND
         LA    RC,4                INDICATE NO VAR CYMBOLS
         BAL   RET,MCBDSCFD        SCAN 3RD CARD COMMENT(IF ANY)
*                                                                     A
*  END OF STATEMENT  TEST FOR POSSIBLE INNER MACRO CALL, PROCESS      A
*   ELSE, BUMP BSU POINTER, PRINT LINE, AND CONTINUE                  A
*                                                                     A
MCBDSFIN EQU   *
         L     RD,MCBDPR2          CREATE BSU                         A
         CLI   AVMFLDT2,C'I'       INNER MACRO CALL
         BNE   MCBODPR0            SKIP OUT IF NOT INNER MACRO CALL   A
         L     RD,MCBDINMA         GET INNER MACRO BSU                A
         B     MCBODPR0            PRINT STATEMENT                    S
         SPACE 2
**--> INSUB:MCBDFLD   CREATES A PRINT BSU+ + + + + + + + + + + + + + +A
*+                                                                   +A
*+  CALLED TO CREATE A BSU SO STMT WILL BE PRINTED. IT ALSO          +A
*+  BUMPS THE BSU POINTER                                            +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDPFLC SR    RC,RC               ENTRY NON COMMENT TYPE PRINT BSU   A
MCBDPFLD EQU   *
         LR    RD,RA               COMPUT OFFSET                      A
         S     RD,MCBDSRPT                                            A
         SLL   RD,8                MOVE TO RIGHT BYTE                 A
         AL    RD,MCBPRBSU(RC)     GET PRINT BSU OR PRINT/COMMENT BSU A
         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG
         OI    AVMBYTE2,$MOPRTR    SET PREV INDICATOR TO OPRTR
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         BR    RET
         SPACE 2
**--> INSUB:MCBDSCFN     LOOKS FOR FIELDS  + + + + + + + + + + + + + +A
*+                                                                   +A
*+  SCAN FIELDS IN STMT, CREATES BSU'S, IF ONE EXISTS.  RETURNS       S
*+  THE LENGTH AND ENDING ADDRESS.                                   +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDSCFD EQU   *
         ST    RET,MCBDSAVE        SAVE RETURN @
         L     RA,MCBDFLD          GET POINTER TO FIELD
         LTR   RA,RA               FIELD EXISTS?
         BZ    MCBDSCFN            FINI IF NOT
         SR    RB,RB               CLEAR RB TO CARRY LENGTH
         IC    RB,MCBDFLDL         GET LENGTH OF FIELD
         BAL   RET,MCBDPFLD        CREATE BSU
         BAL   RET,MCBDSCAN        SCAN FIELD
MCBDSCFN EQU   *
         L     RET,MCBDSAVE        RESTORE RETURN @
         BR    RET                AND RETURN
MCBDSAVE DS    F                   CORE FOR RETURN @
MCBDFLDS DS    0F                  TEMP STORAGE FOR FIELD INFO
MCBDFLD  DS    F                   POINTER TO FILED
MCBDFLDL DS    C                   LENGTH OF FIELD
MCBDFLDT DS    C                   TYPE OF FIELD
         SPACE 2
*                                                                     A
* PROCESSES INNER MACRO CALLS  MOVES OPCODE IN FIELD, SEARCHES        A
*  FOR NAME IF LIBRARY, IF NOT THERE, MAKES NOTE OF REFERENCE FOR LATEA
*  SEARCH OR POSSIBLE ERROR                                           A
MCBDINMC EQU   *
         OI    MCLBFLG2,$MACTFLG   GLBL'S, ETC. NO LONGER OK          S
         SR    R2,R2               CLEAR R2 FOR EX INST
         L     R1,AVMFLD2          GET OPCODE @
         IC    R2,AVMFLDL2         GET LENGTH OF OPCODE
         BCTR  R2,0                DECR BY ONE FOR EX INST
         MVC   AVMSYMBL,AWBLANK    CLEAR PREVIOUS NAME
         EX    R2,MCBDINM1         MOVE OPCODE TO AVMBL               A
         MVC   AVMSYMLN,AVMFLDL2   MOEE LENGTH
         USING MACLIB,RC
         L     RC,AVMACLIB         GET @ OF MACLIB
         $CALL MACFND              SEARCH MACRO LIBRARY
         LTR   RB,RB               SYMBOL FOUND?
         BZ    MCBDSTIN            PROCESS IF YES IN STRING CODE
         LA    RE,$LMACLIB         GET LENGTH OF MACLIB ENTRY
         $ALLOCL RD,RE,MCBODOVR    GET SPACE FOR ENTRY
         ST    RD,MCLIBNXT         SAVE LINK IN PREV ENTRY
         LR    RC,RD               MOVE BASE TO RC
         MVC   MACLIB($LMACLIB),AWZEROS ZERO NEW ENTRY
         MVC   MCLBNMLN(9),AVMSYMLN     MOVE NAME INTO LIB ENTRY
         B     MCBDSTIN
MCBDINM1 MVC   AVMSYMBL($),0(R1)   DUMMY FOR EXECUTE INSTRUCTION      A
         DROP  RC                  CLEAR USING
         SPACE 2
MCBDSCAN EQU   *
**--> INSUB:MCBDSCAN  SCANS STATEMENTS IN A MOCOR DEFINITION + + + + +A
*+                                                                   +A
*+  SETS DIFFERENT TRT TABLES UP DEPENDING ON WHERE CALLED FORM      +A
*+   IN ROUTINE                                                      +A
*+  CHECKS BSU LIST AS TO WHICH VARIABLES NEED CONCATINATION         +A
*+  CREATES BSU & SETS FLAGS AS THE CONDITIONS WARRENT               +A
*+  SCANS STRINGS AND PROCESSES EXPRESSIONS WITH & VARIABLES         +A
*+                                                                   +A
*+       NOTE: WE ASSUME THAT A PERIOD SHOWS CONCATENATION ONLY IF   +J
*&       USED IMMEDIATELY AFTER A SET VAR/PARAMETER.                 +J
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
         ST    RET,MCBDSAV         SAVE RETURN @
         LA    RY,0(RB,RA)         GET DELIM @
         LTR   RC,RC               LOOK FOR &'S?
         BNZ   MCBDSC01            SKIP IF NO
MCBDSC00 $SETRT ('&&',4)           SET TO STOP ONLY ON &              J
MCBDSC01 EQU   *
         LR    R0,RA               COPY SCAN POINTER
MCBDSC0A EQU   *
         XSNAP T=NO,STORAGE=(*AVRSBLOC,*AVRSBLOC+80,*0(RW),*8(RW)),   S#
               LABEL=' MCBDSC0A ',IF=(AVTAGSM,O,AJOMACRH,TM)          S
         LR    RB,RY               GET FINAL @ IN RB
         SR    RB,RA               GET LENGTH IN RB
         LR    R1,RY               COPY DELIM @ IN R1 FOR TRT
         SR    R2,R2               CLEAR R2
         IC    R2,0(RA)            GET 1ST CHAR
         LA    RE,AWTZTAB(R2)      USE AS PNTR TO TRT TABLE
         CLI   0(RE),X'04'         '&', '.' OR BLANK?
         BE    MCBDSCMP            '&&' IF EQUAL
MCBDSC02 EQU   *                   FALL THRU MEANS NONTERMIANL
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCBDSC03            PROCEED IF YES
         BAL   RET,MCBDCATI        ELSE INSERT CAT OPRTR
MCBDSC03 EQU   *
         EX    RB,MCBDTRSC         SCAN STRING
         CLC   0(2,R1),=C'&&&&'    STOP ON DOUBLE &?
         BNE   MCBDSC04
         LA    RA,2(R1)            BUMP PAST &'S
         B     MCBDSC0A            AND RESUME SCAN
MCBDSC04 EQU   *
         LR    RA,R0               ELSE GET START @
         LR    RB,R1               MOVE DELIM@ TO RB
         $CALL MCGTST              MOVE STRING TO LOW CORE
         OI    MCBSFLGS,$MTERM+$BSCHAR  SET BSU FLAGS
         MVI   MCBSINDX,$BSTRING   SET BSU INDEX
         STC   RD,MCBSTRLN         STORE LEN IN BSU
         ST    RC,MCBSLOC          SAVE @ OF STING IN BSU
         NI    AVMBYTE2,255-($MTERM+$MOPRTR)  TURN OFF PREV IND FLAG
         OI    AVMBYTE2,$MTERM     SET PREV FLAG TO TERM
         BAL   RE,MCBDBMP          BUMP BSU OINTER
         CR    RA,RY               END OF STRING?
         BNL   MCBDSCFT            JUMP TO FOOT IF YES
         B     MCBDSC01            ELSE RESUME SCAN
MCBDSCMP EQU   *
         CLI   1(RA),C'&&'         TWO '&&'S?
         BNE   MCBDSCM1            CONTINUE IF NOT
         LA    RA,2(RA)            BUMP SCN PNTR PAST &&'S
         B     MCBDSC0A            AND RESUME SCAN
MCBDSCM1 EQU   *
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCBDSCM2            PROCEED IF YES
         BAL   RET,MCBDCATI        ELSE INSERT CATEN OPRTR
MCBDSCM2 EQU   *
         OI    AVMBYTE4,$MINSTRN   SET IN STRING FLAG
         LR    RC,RW               MOVE BSU PNTR TO RC
          $SETRT ('&&',0)          CLEAR TRT TABLE FOR MACLEX         J
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='MCBDSCAN -- BSU     #
               BEFORE CALL TO MACLEX',IF=(AVTAGSM,O,AJOMACRH,TM)
         $CALL MACLEX
         LR    RW,RC               RESTORE BSU POINTER
         LTR   RB,RB               ERROR?
         BNZ   MCBDPRER            JUMP OUT IF YES
         CR    RA,RY               SCAN FINI?
         BNL   MCBDSCFT            JUMP OUT IF YES
*              CHECK FOR . AFTER &VARIABLE - ONLY CASE IN WHICH .     J
*              IS NOT AN ORDINARY CHARACTER.                          J
         CLI   0(RA),C'.'          . AFTER &VARIABLE ?                J
         BNE   MCBDSC00            NO, GO BACK FOR NEXT SCAN          J
         LA    RA,1(,RA)      YES, BUMP OVER = CONCATENATION          J
         B     MCBDSC00            GO BACK FOR NEXT CHARACTER         J
MCBDSCFT EQU   *
         $SETRT ('&&',0)      MAKE SURE TRT TABLE CLEARED             J
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='MCBDSCAN -- BSU     #
               BEFORE RETURN        ',IF=(AVTAGSM,O,AJOMACRH,TM)
         L     RET,MCBDSAV         RESTORE RETURN @
         BR    RET                 AND RETURN
MCBDSAV  DS    F                   CORE FOR RETURN @
MCBDTRSC TRT   0(0,RA),AWTZTAB     DUMMY TO SCAN STRING
         SPACE 2
*  ORDINARY COMMENT, SET UP BSU AND CRETE CODE                        A
*                                                                     A
MCBODCOM EQU   *
         L     RD,MCBPRBSU         CREATE BSU                         A
         OI    AVMBYTE2,$MOPRTR    SET PREV FLAG TO OPERTR
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         SR    RB,RB
         IC    RB,AVRSBLOC         GET LENGTH-1 OF STMT
         S     RB,AWF3             DECR FOR STND PART
         L     RA,MCBDSRPT         GET PNTR TO SOURCE
         LA    RC,4                INDICATE NO TERMINAL CHARS
         BAL   RET,MCBDSCAN        SCAN COMMENT STMT
         L     RD,MCBDPR2          CREATE BSU                         A
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         B     MCBODPRC            JUMP AND GENRATE CODE
         TITLE '***MCBODY - MEND, PRINT, ERROR ETC. ROUTINES***'
**--> INSUB:MCBDCATI    CREATE CONCOT BSU+ + + + + + + + + + + + + + +A
*+                                                                   +A
*+   CONCATENATION OPERATION NEEDED. IN CASE OF VARIABLES THAT       +A
*+  HAVE TO BE COMBINED (IE IN SETC STMT)                            +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDCATI EQU   *                   ROUTINE TO INSERT CATEN OPRTR
         L     RD,MCBDCAT          CREATE BSU                         A
         NI    AVMBYTE2,X'FF'-($MTERM+$MOPRTR)  TURN OFF PREV BSU FLAG
         OI    AVMBYTE2,$MOPRTR    SET PREV BSU FLAG
         LR    RE,R14              COPY RETURN @ TO MCBDBMP0 REG      S
*        *** FALL THRU INTO MCBDBMP0  --  MUST IMMEDIATELY FOLLOW *** S
         SPACE 2
**--> INSUB: MCBDBMP       BUMPS BSU POINTER + + + + + + + + + + + + +A
*+                                                                   +A
*+   CALLED WHENEVER BSU ADDED & NEED POINTER MOVED                  +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBDBMP0 ST    RD,MCBSU            FILL IN BSU                        A
MCBDBMP  EQU  *
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='BSU - MCBDBMP',     #
               IF=(AVTAGSM,O,AJOMACRH,TM)
         LA    RW,8(RW)            BUMP BSU POINTER
         C     RW,AVMCHLIM         WORK AREA EXCEEDED?
         BL    MCBDBMP1            OK IF NOT
         LA    RB,$ERVTMTR         ELSE SET TOO MANY TERMS FLAG
         B     MCBDPRER            AND FLAG STATEMNT
MCBDBMP1 EQU   *
         MVC   MCBSU(8),AWZEROS    ZERO NEW BSU
         BR    RE                  AND RETURN
         SPACE  2
*  OVERFLOW CALL EXIR ROUTINE                                         A
MCBODOVR EQU   *
         L     REP,AVMOVRFL        GET @ OF OVERFLOW ROUTINE
         BR    REP                 BRANCH THERE
         SPACE 2
MCLMXDER EQU   *
         L     RA,AVRSBPT          GET SOURCE BLOCK @
         LA    RA,RSB$L(RA)        BUMP TO GET SOURCE STMT
         LA    RB,$ERILCNV         SET ILLEGAL CONVERSION ERROR FLAG
         B     MCBDPRER
         EJECT                                                        S
**--> INSUB:MCBDPR      PRINT STATEMENTS + + + + + + + + + + + + + + +A
*+                                                                   +A
*+  CALLED EACH TIME STATEMENTS NEEDS TO BE PRINTED. TEST FOR SEQ    +A
*+  SYMBOL, IF PRESENT TEST FOR ALREADY DEFINED, IF NOT ENTER INTO   +A
*+   LIST OF SYMBOLS & THEN PRINT, CONTINUES ' READING' STMTS        +A
*+  AND STOPS WHEN MEND FLAG SET.                                    +A
*+                                                                   +A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCBODPR0 BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
MCBODPR  EQU   *
         AIF   (&$DEBUG).MCBODPR
         L     R1,AVMCHSTR         GET @ OF BSU WORKAREA
         XSNAP LABEL='***BSU''S***',STORAGE=(*0(R1),*170(R1)),IF=(AVMSNX
               BY1,O,$MSNP08,TM)
.MCBODPR ANOP
         USING MCSEQ,RC            SET USING FOR SEQ SYMBOL ENTRY
         TM    MCLBFLG2,$MLCLFLG   DEFINITION TYPE STMT?              S
         BC    12,MCBODPR1         IF YES, JUMP AND PRINT
MCBODPRC EQU   *
         LR    RC,RX               COPY MACLIB POINTER
         $CALL MCGNCD              ELSE GENERATE CODE
         AIF   (NOT &$MACOPC).MCBODYC   SKIP IF NOT OPEN CODE         S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MCBODPR1            IF YES, SKIP PROCESSING            S
.MCBODYC ANOP                                                         S
         CLI   AVMFLDT1,C'.'       SEQ SYMBOL PRESENT?
         BNE   MCBODPR1            JUMP AND PRINT IF NOT
         SR    RE,RE
         IC    RE,AVMFLDL1         GET LENGTH OF SYMBOL
         BCTR  RE,0                REDUCE FOR EX INSTRUCTION
         L     RA,AVMFLD1          GET @ OF SEQ LABEL
         MVC   AVMSYMBL,AWBLANK    BLANK OUT COMMON AREA
         EX    RE,MCBDPR1          EX MOVE INSTRUCTION                A
         L     RC,AVMSEQPT         GET POINTER TO SEQ SYM ENTRIES
         $CALL MACFND              SEARCH SYMBOL DICT
         LTR   RB,RB               PRESENT?
         BZ    MCBODPR2            JUMP IF YES
         LA    RB,$LMCSEQ          ELSE GET LENGTH OF ENTRY
         $ALLOCH R1,RB,MCBODOVR    GET SPACE FOR ENTRY
         ST    R1,MCSEQNXT         STORE POINTER IN PREV ENTRY
         LR    RC,R1               MOVE BASE TO NEW ENTRY
         MVC   MCSEQNAM,AVMSYMBL   MOVE NAME INTO ENTRY
         OI    MCSEQFLG,X'FF'      SET DEFINED FLAG
         MVC   MCSEQNXT,AWZEROS    ZERO LINK POINTER
         MVC   MCSEQVAL,AVMCRINS   MOVE INST @ INTO ENTRY
         B     MCBODPR1            JUMP AND PRINT
MCBODPR2 EQU   *
         CLI   MCSEQFLG,X'FF'      ALREADY DEFINED?
         BNE   MCBODPR3            JUMP AND PROCESS IF NOT
         LA    RB,$ERMULDF         ELSE SET MULT DEF FLAG
         $CALL ERRLAB              AND FLAG STATEMENT
         B     MCBODPR1            PRINT STMNT
MCBODPR3 EQU   *
         L     RE,MCSEQVAL         GET @ OF INST
         USING MCOPQUAD,RE         SET USING FOR ONE OP ENTRY
MCBODPR4 EQU   *
         MVC   MCARG2LC,AVMCRINS   MOVE INST @ INTO ONE OP ENTRY
         L     RE,MCRESULT         GET NEXT POINTER
         LTR   RE,RE               POINTER PRESENT?
         BNZ   MCBODPR4            IF YES, UPDATE NEXT ENTRY IN LIST
         MVI   MCSEQFLG,X'FF'      ELSE SET DEFINED FLAG IN ENTRY
         MVC   MCSEQVAL,AVMCRINS   SET VALUE IN ENTRY
         DROP  RE
         SPACE
MCBODPR1 EQU   *
         AIF   (NOT &$MACOPC).MCBODYD   SKIP IF NOT OPEN CODE         S
         TM    AVPRINT1,AVPRSAVE   LISTING CONTROL = SAVE ?           S
         BNO   MCBODP1A            BRANCH IF NOT                      S
         SR    RE,RE               ZERO  FOR BYTE REGS USE            A
         IC    RE,AVRSBLOC         GET LENGTH-1                       A
         SH    RE,=AL2(RSB$L)      DECREMENT LENGTH FOR MXMVSR        A
         STC   RE,AVRSBLOC         RESTORE IT                         A
         $CALL MXMVSR              SAVE STATEMENT                     A
         B     MACBODRT            RETURN                             S
MCBODP1A EQU   *                                                      S
.MCBODYD ANOP                                                         S
         LA    RB,$OUCOMM
         $CALL OUTPT2              PRINT STATEEMNT
         CLI   OPCHEX,$MEND        MEND STATEMENT?
         BE    MACMEND1            CLEAN UP IF YES
         B     MCBOD01             ELSE READ NEXT STMNT
         DROP  RC
         SPACE 2
MCBDCHLB EQU   *
         ST    RET,MCBDCHSV        SAVE RETURN ADDRESS
         CLI   AVMFLDT1,C'.'       SEQ SYMBOL?
         BE    MCBDCHFT            OKAY IF YES
         CLI   AVMFLDL1,X'00'      NO LABEL?
         BE    MCBDCHFT            OKAY ALSO
         LA    RB,$ERILLAB         ELSE SET BAD LABEL FLAG
         $CALL ERRLAB              AND FLAG STMT
MCBDCHFT EQU   *
         L     RET,MCBDCHSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MCBDCHSV DS    F                   CORE FOR RETURN @
MCBDPR1  MVC   AVMSYMBL($),0(RA)   DUMMY MOVE FOR LABEL               A
         SPACE 2
MCGBINVD LA    RB,$ERINVDM         INVALID DLM                        A
         B     MCBDPRER            GO FLAG ERROR                      A
         SPACE 1                                                      A
MCGBMD   L     RA,AVMTSCNP         GET @ OF 1ST CHAR OF VAR NAME      A
         LA    RB,$ERMULDF         SHOW MULTIPLR DEFN                 A
         B     MCBDPRER            GO FLAG                            A
         SPACE 1                                                      A
MCBDOPER EQU   *
         LA    RA,AVRSBLOC+RSB$L+20 GUESS AT OPRND ADDRESS            A
         LA    RB,$ERNOOPR         SET NO OPRND FLAG
         SPACE 2
*                                                                     S
*  PRINTS AN APPROPRIATE MESSAGE & SETS ERR INDX IN BSU               A
*                                                                     A
MCBDPRER EQU   *
         L     RW,AVMCHSTR         SET BSU PNTR TO START OF WORK AREA
         LR    RD,RA               COMPUT OFFSET                      A
         S     RD,AVRSBPT                                             A
         SLL   RD,8                MOVE TO RIGHT BYTE                 A
         AL    RD,MCBDERR                                             A
         BAL   RE,MCBDBMP0         BUMP BSU POINTER                   A
         $CALL ERRTAG              FLAG STMNT
         B     MCBODPR             JUMP AND PRINT STATEMENT
         SPACE 2
MCBDISER EQU   *
         LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG
         B     MCBDPRER            AND FLAG STATEMENT
         SPACE 2
*                                                                     A
*        END OF ROUTINE, SET OP POINTERS TO ONE-OP ENTRIES PRINTS     A
*    OUT ERROR MESSAGES & DEBUG ADDRESS FOUND & STORED                A
*                                                                     A
MACMEND1 EQU   *
         USING MCOPQUAD,RE
         USING MCSEQ,RC
         L     RC,AVMSEQPT         GET @ OF SEQ SYM LIST
         USING RSBLOCK,RZ          NOTE USING FOR OUTPPUT RECORD
         L     RZ,AVRSBPT          SET BASE FOR OUTPUT RECORD
         MVC   RSBLOCK(RSB$L+L'MCMNERMS),MCMNERMF   SET FLAGS         S
MACMEND2 EQU   *
         CLI   MCSEQFLG,X'FF'      SYMBOL DEFINED?
         BNE   MACMEND3            PROCESS IF NOT
MACMENDN EQU   *
         L     RC,MCSEQNXT         SET BASE TO NEXT ENTRY
         LTR   RC,RC               LAST ENTRY?
         BNZ   MACMEND2            IF NOT, RESUME SEARCH
         B     MACMEND5            ELSE JUMP TO FOOT
MACMEND3 EQU   *
         L     RE,MCSEQVAL         GET @ OF ONE OP ENTRY
MACMEND4 EQU   *
         MVC   RSBSOURC+L'MCMNERMS(6),AWEP6   PUT EDIT MASK IN OUTPUT
         L     R1,MCRESULT         COPY LINK TO NXT SEQ ERROR TEMP
         L     RE,MCARG2LC         MOVE BASE TO 1ST ONE-OP
         ED    RSBSOURC+L'MCMNERMS(6),MCQSTMNO    EDIT STMT NBR TO FLD
         MVI   MCQS1FLG,$BSERR01   SET ERROR MSG OPCODE               A
         LA    RB,$OUCOMM          SET PRINT FLAG
         LR    R0,RC               COPY RC TEMPORARILY
         $CALL OUTPT2              PRINT ERROR MESSAGE
         LR    RC,R0               RESTORE RC
         LTR   RE,R1               SET BASE TO NEXT SEQ ERR ENTRY     S
         BNZ   MACMEND4            PRINT NEXT MESSAGE IF NOYT
         B     MACMENDN            RESUME SCAN OF SEQ SYMBOL DICT
MACMEND5 EQU   *
         LA    RC,$LMCSEQ           GET LENGTH OF SEQ ENTRY
         L     R1,AVADDHIH         GET PNTR FOR DEBUG STMNT
         A     RC,AVMSEQPT         ADD ORIGINAL POINTER
         ST    RC,AVADDHIH         RELEASE STORAGE IN HIGH END
         SPACE 2
MACBODRT EQU   *
         AIF   (&$DEBUG).MACBODR
         L     R2,AVMSEQPT         GET @ OF SEQ SYM TABLE FOR DEBUG
         XSNAP LABEL='***MCBODY EXITED***',STORAGE=(*0(R1),*0(R2)),IF=(X
               AVMSNBY1,O,$MSNP07,TM)
.MACBODR ANOP
         SR   RB,RB                CLEAR RB FOR RETURN
         $RETURN  RGS=(R14-R6)
MCBDSRPT DS    F                   WORD FOR RSBSOURC @
MCB##SAV DS    F                   RETURN @ FROM MCB## ROUTINES       J
MCBPRBSU DC    AL1($MOPRTR,$BSPRINT,0,$MPRNTHR)    PRINT BSU
MCBPRBSV DC    AL1($MOPRTR+$MPRCOM,$BSPRINT,0,$MPRNTHR) COMMENT PRM   A
*        ***** BSU TABLE - FIRST FULLWORDS OF MANY BSU'S. *****       J
MCBDERR  DC    AL1($MOPRTR,$BSERR01,0,$MPRNTHR)                       A
MCBDSET  DC    AL1($MOPRTR,$BSETA,0,$MSETHR)                          A
MCBDAGO  DC    AL1($MOPRTR,$BSAGO,0,$MAGOHR)                          A
MCBDSTG1 DC    AL1($MTERM+$BSCHAR,$BSTRING,0,11),A(MCMNOTMS) WHOLE BS J
MCBDSTG2 DC    AL1($MTERM+$BSCHAR,$BSTRING,0,2),A(MCMNOT1C) WHOLE BSU J
MCBDPR2  DC    AL1($MOPRTR,$BSMVSTM,0,$MPRNTHR)                       A
MCBDPR3  DC    AL1($MOPRTR,$BSMVSTM+$BSMNTER,0,$MPRNTHR)              A
MCBDAIF  DC    AL1($MOPRTR,$BSAIF,0,$MAIFHR)                          A
MCBDCAT  DC    AL1($MOPRTR,$BSCAT,0,$MCATHR)                          A
MCBDINMA DC    AL1($MOPRTR,$BSINMAC,0,$MPRNTHR)  INNER MACRO BSU      A
MCBDLABL DC    AL1($MTERM,$BSLABEL,0,0)                               A
MCMNERMF DC    AL1(L'MCMNERMS+RSB$L+6,$RSBNPNN+$RSBMERR,1,0)          A
MCMNERMS DC    C'220  UNDEFINED SEQUENCE SYMBOL IN STATEMENT'
         LTORG
         DROP  RAT,RW,RX,R13,RC,RZ,RE
         TITLE '***MACLEX - LEXICAL SCAN OF EXPRESSIONS***'
**-->  CSECT:  MACLEX   THIS PROCEDURE SCANS A MCRO STATEMENT AND     *
*.        CONVERTS IT INTO BSU'S.  ALSO CHECKS FOR SUCH ERRORS AS TWO *
*.        TERMS OR TWO OPERATORS IN A ROW.  WHERE NECESSARY IT INSERTS*
*.        CATENATION OPERATORS WHERE CATENATION IS IMPLICIT           *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RA = @ OF FIRST CHARACTER OF EXPRESSION                        *
*.     RC = @ ON NEXT AVAILABLE BSU IN WORKSPACE                      *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RA = @ OF DELIM PAST EXPRESSION IF NO ERROR                    *
*.        = @ OF ERROR IF ERROR PRESENT                               *
*.     RB = 0 IF OKAY                                                 *
*.        = $ERMSSGE IF ERROR                                         *
*.     RC = @ OF NEXT AVAILABLE SPACE FOR BSU                         *
*.                                                                    *
*.        CALLS MCGTST,MCDTRM,SDBCDX,MCSYSR,MCATRM,MCGTST             *
*.        USES DSECTS: AVWXTABL,MCBSU,MCPARENT,MCGLBDCT,MCLCLDPV      *
*.        USES MACROS: $SAVE,$RETURN,$ALLOCL,$SCOF,$SCPT,$CALL,$SETRT *
*.                                                                    *
*.       REGISTER USAGE                                               A
*.        WORK REGS: R0,R1,R2,RY,RZ,RB,RC,RE                          A
*.        USED FOR TRT: R1,R2                                         A
*.        RW-BASE REG FOR BSU                                         A
*.        R13 BASE REG FOR THIS CSECT                                 A
*.        RAT- BASE REGISTER FOR MAIN TABLE                           A
*.       RX-UNUSED                                                    A
*.       RD-?                                                         A
*.                                                                    A
*** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MACLEX   CSECT
         $SAVE RGS=(R14-R6),SA=*,BR=13
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MACLEX ENTERED***',T=NO,IF=(AVMSNBY2,O,$MSNP09X
               ,TM)
         USING MCBSU,RW            SET USING FOR BSU ENTRY
         LR    RY,RC               COPY ADDR OF NEXT BSU              A
         S     RY,=F'8'            GET ADDR OF PRECIOUS POINTER       A
         MVC   MCBSFLGP(4),0(RY)   MOVE PREV BSU INTO WORK AREA       A
         SR    RY,RY               USE RY FOR PAREN COUNT
         LR    RW,RC               GET @ OF SPACE FOR BSU
         MVI   AVMDWRK4,X'00'      CLEAR PAREN INFO BYTE
         MVC   MCBSU(8),AWZEROS    BLANK OUT ENTRY
         NI    AVMBYTE1,X'FF'-$MINQUOT   CLEAR QUOTE FLAG
         NI    AVMBYTE2,X'FF'-$MTERM    MAKE SURE TERM FLG IS OFF
         OI    AVMBYTE2,$MOPRTR    SET OPERATOR FLAG FOR START
         $SETRT ('''',26,'&&',28,'.',30)  SET TRT TABLE FOR QUOTE SCAN
         MVI   AWTDECT+C'+',18
         MVI   AWTDECT+C'-',20
         MVI   AWTDECT+C'/',22     MODIFY AWTDECT TABLE FOR TEMPORARY
         MVI   AWTDECT+C')',24     USE IN LEXICAL SCAN.  THIS SAVES
         MVI   AWTDECT+C'''',26    CREATING A NEW TABLE.
         MVI   AWTDECT+C'&&',28
         MVI   AWTDECT+C'.',30
         B     MCLXSTR0            JUMP TO LOOKUP CHAR ROUTINE        A
MCLEXBAS DS    0H
         SPACE 2
MACLINDX $AL2  MCLEXBAS,(MCLDIGIT,MCLEXERR,MCLSDTRM,MCLALPHA,MCLMULT,MCX
               LEQUAL,MCLXLPAR,MCLCOMMA,MCLBLANK,MCLPLUS,MCLMINUS,MCLDIX
               VID,MCLXRPAR,MCLQUOTE,MCLAMPRS,MCLPEROD)
         SPACE 2
*  TRT  TABLE SET-UP, LOOK UP CHARACTER OF EXPRESSIO AND GO TO THE    A
* ROUTINE TO PROCESS THE EXPRESSION.                                  A
MCLXSTRS EQU   *                                                      S
         LA    RA,1(R1)            BUMP SCAN POINTER                  S
MCLXSTRT EQU   *
MCLXSTR0 EQU   *                                                      A
         LR    R0,RA               COPY SCAN POINTER
MCLXSCAN EQU   *
         SR    R1,R1               ZERO R1 FOR TRT USE
         SR    R2,R2               USE R2 IN TRT INST
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BO    MCLX01              USE LIMITEE TRT IF YES
MCLX03   EQU   *
         TRT   0(1,RA),AWTDECT     LOOKUP NEXT CHAR
         B     MCLX02              AND JUMP TO GET ROUTINE
MCLX01   EQU   *
         TM    AVMBYTE2,$MINAPAR+$MDIMVAR  PAREN EXPRESSSION EXPECTED?
         BC    5,MCLX03            IF YES, USE REGULAR TRT
         TRT   0(200,RA),AWTZTAB
MCLX02   EQU   *
         LH    RE,MACLINDX(R2)     GET HALFWORD OFFSET FROM TABLE
         B     MCLEXBAS(RE)        ADD TO BASE AND JUMP TO ROUTINE
         SPACE 2
* DIGIT FOUND, CHECK TO SEE IF PROPER CONST, CONVERT IT, SET UP       A
*  BSU WITH CONSTANT VALUE, DECREMENT # BSU COUNTER & PROCESS         A
MCLDIGIT EQU   *
         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL CONSTANT OKAY?
         BZ    MCLXSYER            IF NOT, JUMP AND FLAG
         $CALL MCDTRM              CONVERT CONSTANT
         LTR   RB,RB               OK?
         BNZ   MCLXERTN             RETURN IF NOT
         MVI   MCBSINDX,$BSIMMA    SET IMMED ARITH INDEX
         OI    MCBSFLGS,$BSAR      INDICATE ARITH IN BSU
         ST    RC,MCBSVALU         STORE VALUE IN BSU
         S     RC,AWF1             DECR BY 1
         BH    MCLXTRMF            IF > 1 THEN FINI
         OI    MCBSFLGS,$BSBOOL    ELSE FLAG AS BOOLEAN CONSTANT ALSO
         B     MCLXTRMF            JUMP TO TERM FOOT
         SPACE 2
*  POSSIBLE SELF DEFINING TERM, CHECK NEXT CHAR, IF QUOTE, ALPHA,     A
*  ELSE CHECK FOR OK SDT.-SETS FLAGS ETC.                             A
MCLSDTRM EQU   *
         CLI   1(R1),C''''         NEXT CHAR = '?
         BNE   MCLALPHA            PROCESS ALPHA IF NOT
         $CALL SDBCDX              CHECK FOR SELF DEFINING TERM
         LTR   RB,RB               OKAY?
         BM    MCLALPHA            MAY BE L', BRANCH                  A
         BP    MCLXERTN            BAD SDTERM IF RB > 0               A
         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL  IN OKAY EXPRESSION?
         BZ    MCLXSYER            ERROR IF NOT
         OI    MCBSFLGS,$BSAR+$MTERM  SET TYPE TO ARITH TERM
         MVI   MCBSINDX,$BSIMMA    SET TO ARITH IMMED TYPE INDEX
         ST    RC,MCBSVALU         STORE VALUE IN BSU
         B     MCLXTRMF            JUMP TO TERM FOOT
         SPACE 2
*  ALPHA CHAR FOUND, CK ARITH EXPRESSION, PROCESS  IF IS, NEXT        A
*  CK  TYPE ATTR, ERROR  IF NOT FIRST CHAR OF OPRND  ALSO IF  (       A
*  SETS SYSLIST FLAG  SEARCHES ATTRIBUTES IN DICTIONARY               A
MCLALPHA EQU   *
         TM    AVMBYTE2,$MINARIT+$MINBOOL+$MINAPAR   IN ARITH EXPRES?
         BM    MCLALPH0            PROCEED IF YES
         C     R1,AVMFLD3          BEGINNING OF OPRND?
         BNE   MCLXSYER            ERROR IF NOT
         CLC   0(2,R1),=C'T'''     T' ATTIBUTE?
         BNE   MCLXSYER            ERROR IF NOT
MCLALPH0 EQU   *
         CLI   1(R1),C''''         NEXT CHAR = QUOTE?
         BNE   MCLRELOP            IF NOT TEST FOR RELOP
         $CALL MCATRM              IS IT AN ATTRIBUTE?
         LTR   RB,RB
         BM    MCLXSYER            IF NOT, SET SYNTAX EROR FLAG
         BP    MCLXERTN           NOT IMPLEMENTED
         STC   RC,MCBSINDX         STORE TYPE OF ATTRIB IN BSU
         $CALL MCSYSR              SEARCH DICTIONARIES
         LTR   RB,RB
         BM    MCLXISER            INVALID SYMBOL IF MINAS
         BP    MCLXERTN            NOT DEFINED IF RB > 0
         LA    RB,$SYMPAR          LOAD SYMBOLIC PARAM FLAG
         CR    RD,RB               IS IT SYM PAR?
         BE    MCLA01              IF YES PROCEED
         USING MCPARENT,RC         NOTE USING FOR ENTRY
         LA    RB,$SYSVAR          NEXT CHECK FOR SYSTEM VARIABLE
         CR    RB,RD
         BNE   MCLXISER            IF NOT, FLAG ERROR
         CLI   MCPARNLN,8          MUST BE &SYSLIST WITH LENGTH 8
         BNE   MCLXISER            ERROR IF NOT
         MVC   MCBSVALU,AWFM1      INDICATE &SYSLIST WITH -1
*   N'&SYSLIST CAN STAND ALONE SO CHECK FOR LEFT PAREN
         CLI   MCBSINDX,$BSATN     ATTRIB = N'?
         BNE   MCLALPH2            PROCEED IF NOT
         CLI   0(RA),C'('          NEXT CHAR = '('?
         BNE   MCLXTRMF            PROCESS IF NOT
MCLALPH1 EQU   *
         MVI   AVMDWRK4,$MINSYSL   SET &SYSLIST FLAG IF PAREN
         B     MCLXTRMF
MCLALPH2 EQU   *
         CLI   0(RA),C'('          NEXT CHAR = LEFT PAREN?
         BE    MCLALPH1            T' OR K' REQUIRE PAREN
         B     MCL$ERI                                                S
         SPACE
*  SYMBOLIC PARAMETER FOUND  SET UP BSU, AND CHK LEGALITY             A
MCLA01   EQU   *
         LH    R2,MCPARNDX         GET SYMBOLIC PARAM ID
         ST    R2,MCBSVALU         STORE IN BSU
         CLI   0(RA),C'('          NEXT CHAR  IS '('?
         BNE   MCLXTRMF            JUMP TO FOOT IF NOT
         OI    AVMBYTE2,$MDIMVAR   ELSE SET DIM VAR FLAG
         CLI   MCBSINDX,$BSATN     N' ATTRIB?
         BNE   MCLXTRMF            OKAY IF NOT
MCL$ERI  LA    RB,$ERILAT          SET BAD ATTRIB FLAG                S
         B     MCLXERTN            AND RETURN
      SPACE 2                                                         A
*   RELATIONAL OPERATOR FOUND, IF ›BOOL ERROR, ELSE GET OPERAND LENGTHA
*   AND LOOK UP IN TABLE FOR OPERATION WHEN LEGAL OPERATOR  FOUND,    A
*   SET UP BSU                                                        A
MCLRELOP EQU   *
         TM    AVMBYTE2,$MINBOOL   IN BOOLEAN EXPRESSION?
         BNO   MCLXSYER            IF NOT, REL OPCODE NOT ALLOWED
         TRT   0(4,RA),AWTSYMT     SCAN STRING FOR DELIM
         BZ    MCLXSYER            ERROR IF > 3 CHARS
         LR    R2,R1               COPY DEIIM @
         SR    R2,RA               GET LENGTH OF STRING
         BCT   R2,MCLARL01         DECR FOR EX INST
         B     MCLXSYER            ERROR IF ONE CHAR
MCLARL01 EQU   *
         LA    RE,MCRLOPTB         GET @ OF CONSTANT TABEL
MCLARL02 EQU   *
         EX    R2,MCLACMPR         COMPARE WITH NEXT ENTRY
         BE    MCLARL03            FOUND IF EQUAL
         BL    MCLXSYER            NOT PRESENT IF <
         LA    RE,5(RE)            BUMP TABLE POINTER
         B     MCLARL02            RESUME SEARCH OF TABEL
         SPACE
MCLARL03 EQU   *
         MVC   MCBSINDX,3(RE)      SET INDEX
         MVC   MCBSHIER,4(RE)      SET HIERARCHY IN BSU
         LR    RA,R1               BUMP SCAN POINTER
         B     MCLXOPRF            JUMP TO OPRTR FOOT
         SPACE 2
MCLACMPR CLC   0(0,RA),0(RE)       COMPARE STRING WITH TABLE ENTRY
MCRLOPTB DC    C'AND',AL1($BSAND,$MANDHR),C'EQ ',AL1($BSEQ,$MRELHR)
         DC    C'GE ',AL1($BSGE,$MRELHR),C'GT ',AL1($BSGT,$MRELHR)
         DC    C'LE ',AL1($BSLE,$MRELHR),C'LT ',AL1($BSLT,$MRELHR)
         DC    C'NE ',AL1($BSNE,$MRELHR),C'NOT',AL1($BSNOT,$MNOTHR)
         DC    C'OR ',AL1($BSOR,$MORHR),C'999'
         DROP RC
         SPACE 2
*   NEXT BLOCKS WHEN  +,-,/,OR * FOUND, SETS HIERARCHY AND SETS UP    A
*   THE BSU'S                                                         A
MCLMULT  EQU   *
         MVI   MCBSINDX,$BSMULT    SET INDEX TYPE IN BSU
MCLMHIER EQU   *
         MVI   MCBSHIER,$MMULTHR   SET MULT/DIVID HIERARCHY
         B     MCLXARFT            JUMP TO ARITH OPRTR FOOT
         SPACE 2
MCLDIVID EQU   *
         MVI   MCBSINDX,$BSDIV     SET BSU INDEX FOR DIVIDE
         B     MCLMHIER            JUMP AND SET HIERARCHY
         SPACE 2
MCLPLUS  EQU   *
         MVI   MCBSINDX,$BSPLUS    SET ADDITION INDIX IN BSU
MCLPHIER EQU   *
         MVI   MCBSHIER,$MPLUSHR    SET HIERARCHY OF OPRTR
         B     MCLXARFT            JUMP TO ARITH FOOT
         SPACE 2
MCLMINUS EQU   *
         MVI   MCBSINDX,$BSMIN     SET MINUS INDEX IN BSU
         B     MCLPHIER            JUMP AND SET SAME HIERARCHY AS PLUS
         SPACE 2
*   CK  IF ARITH EXPRESSION, ERROR IF NOT                             A
MCLXARFT EQU   *
         TM    AVMBYTE2,$MINARIT+$MINAPAR+$MINBOOL  IN ARITH EXPRESSION
         BZ    MCLXSYER            ERROR IF NOT
         LA    RA,1(R1)            BUMP SCAN POINTER
         B     MCLXOPRF            JUMP TO OPERATOR FOOT
         SPACE 2
         SPACE 2
*   LEFT  PAREN FOUND CHECK IF NESTING LEVEL OK, , CHKS & BRANCHES TO A
*   SEE IF 1)SUBSCRIPTED VAR,2)IN SUBSTRING,3)OR SYSLIST              A
MCLXLPAR EQU   *
         LA    RY,1(RY)            BUMP PAREN COUNT
         C     RY,=F'6'            CHECK NEXTING LEVEL
         BL    MCLXLP01            OKAY IF < 6
         LA    RB,$ERVPARN         ELSE SET TOO MANY PAREN FLAG
         B     MCLXERTN            AND RETURN
MCLXLP01 EQU   *
         LA    RZ,AVMDWRK4(RY)     USE RZ AS PNTR TO CURRENT PAREN
         TM    AVMDWRK4,$MINSYSL   IS &SYSLIST FLAG ON?
         BO    MCLXSBSL            IF YES MUST BE &SYSLIST PAREN
         TM    AVMBYTE2,$MDIMVAR   PREV BSU = DIMEN VARIABLE?
         BO    MCLXSBSC            IF YES, MUST BE SUBSCRIPT LP
         BCTR  R1,0                DECR POINTER
         CLI   0(R1),C''''         PREV CHAR = QUOTE?
         LA    R1,1(R1)            RESTORE POINTER BEFORE TEST
         BE    MCLXSBST            IF YES MUST BE SUBSTRING LP
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BNO   MCLXSYER            ERROR IF NOT
         MVI   0(RZ),X'00'         CLEAR FIRST BYTE OF PAREN INFO
         MVI   MCBSINDX,$BSLPAR    ELSE MUST BE LEFT PAREN
         B     MCLXPARF            JUMP TO L PAREN FOOT
         SPACE
*   SUBSCRIPT  CHECK                                                  A
MCLXSBSC EQU   *
         MVI   0(RZ),$MINSBSC      IDENTIFY PAREN LEVEL
         MVI   MCBSINDX,$BSBSCRP   SET BSU INDEX
         OI    AVMBYTE2,$MINAPAR   INDICATE INSIDE ARITH PARENS
         B     MCLXPARF            JUMP TO PAREN FOOT
         SPACE
*   SYSLIST CHECK                                                     A
MCLXSBSL EQU   *
         MVI   0(RZ),$MINSYSL      SET PAREN ID TO SYSLIST
         MVI   MCBSINDX,$BSBSYL    SET BSU INDEX ALSO
         OI    AVMBYTE2,$MINAPAR   INDICATE INSIDE ARITH PARENS
         CLI   MCBSINDP,$BSATN     IS IT THE N'                       A
         BNE   MCLXPARF            PROCEED IF NOT
         MVI   0(RZ),$MINSBSC      ELSE SET FLAG TO STOP 2 SUBSCRIPTS
         B     MCLXPARF            JUMP TO L PAREN FOOT
         SPACE
*   SUBSTRING CHECK                                                   A
MCLXSBST EQU   *
         MVI   0(RZ),$MINSBST      INDICATE PAREN IS SUBSTRING START
         MVI   MCBSINDX,$BSBSTR    SET BSU INDEX ALSO
         OI    AVMBYTE2,$MINAPAR   ALSO INDICATE INSIDE ARITH PARENS
         B     MCLXPARF            JUMP TO L PAREN FOOT
         SPACE
*   FOOT FOR LEFT PAREN                                               A
MCLXPARF EQU   *
         LA    RA,1(R1)            BUMP SCAN POINTER PAST (
         MVI   MCBSHIER,$MPARHR    SET PAREN HIERARCHY
         NI    AVMBYTE2,X'FF'-$MDIMVAR   TURN OFF DIMVAR FLAG
         MVI   AVMDWRK4,X'00'      TURN OFF SYSLIST FLAG
         B     MCLXDLMF            JUMP TO DELIM/OPRTR FOOT
         SPACE 4
* RIGHT PAREN FOUND CHECKS FOR RIGHT NUMBER AF ARGUMENTS, SEES IF     A
* CORRECT NESTING MOVES SUBSCIPTS INTO BSU, ALWAYS PROCESSED INFO     A
* AND CHECKS FOR MATCHED PARENS(N'LPREN=N'RPAREN)                     A
*                                                                     A
MCLXRPAR EQU   *
         LA    RZ,AVMDWRK4(RY)     GET @ CURRENT PAREN INFORMATION    J
         TM    0(RZ),$MINSBST      IN SUBSTRING?
         BNO   MCLXRP01            PROCEED IF NOT
         TM    0(RZ),$MINSBST+X'01'     TWO ARGUMENTS?
         BNO   MCLCOMR1                                               S
MCLXRP01 EQU   *
         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?
         BO    MCLXRP02            OKAY IF YES
         CLI   MCBSINDP,$BSRPAR    MUST BE RIGHT RAREN                A
         BNE   MCLXSYER            ERROR IF NOT )
MCLXRP02 EQU   *
         MVC   MCBSLOC+3(1),0(RZ)  MOVE NBR OF SUBSCRIPTS INTO BSU
         S     RY,AWF1             DECR PAREN COUNT
         BP    MCLXRP03            OKAY IF STILL POSITIVE
         BM    MCLXSYER            ERROR IF NEGATIVE
         NI    AVMBYTE2,X'FF'-$MINAPAR  TURN OFF ARITH EXPRESSION FLAG
         TM    AVMBYTE2,$MINPEXP   END OF EXPRESSI6N?
         BO    MCLXRP04            IF YES RETURN
         B     MCLXRP06            RETURN IF PAREN COUNT IS ZERO
MCLXRP03 EQU   *
         BCTR  RZ,0                DECR POINTER TO PAREN INFO
         LR    RE,RY               COPY PAREN COUNT INTO RE
MCLXRP05 EQU   *
         TM    0(RZ),$MINSBST+$MINSBSC+$MINSYSL  IN ARITH EXPRESSION?
         BM    MCLXRP06            IF YES RETURN
         BCTR  RZ,0                ELLE DECR POINTER AGAIN
         BCT   RE,MCLXRP05         DECR PAREN COUNT
         NI    AVMBYTE2,X'FF'-$MINAPAR  TURN OFF ARITH FLAG IF ZERO
MCLXRP06 EQU   *
         MVI   MCBSINDX,$BSRPAR    SET RIGHT PAREN INDEX IN BSU
         LA    RA,1(RA)            BUMP POINTER PAST PAREN
         B     MCLXDLMF
         SPACE
MCLXRP04 EQU   *
         MVI   MCBSINDX,$BSRPAR    SET INDEX IN BSU
         MVI   MCBSHIER,$MPARHR    SET HIERARCHY
         OI    MCBSFLGS,$MOPRTR    SET OPRTR FLAG IN BSU
         $SCOF RB,RA,MCBSOFST      GET OFFSET IN BSU
         LA    RA,1(R1)            BUMP SCAN POINTER
         BAL   RE,MCLXBMP          BUMP BSU
         NI    AVMBYTE2,X'FF'-$MINPEXP  TURN OFF PAREN EXPR FLAG
         B     MCLXFOOT            RETURN
         SPACE 2
* COMMA FOUND, CHECKS VALIDITY AND FLAGS ERRORS                       A
*                                                                     A
MCLCOMMA EQU   *
         LTR   RY,RY               ARE WE IN PARENS?
         BZ    MCLXSYER            ERROR IF NOT
         LA    RZ,AVMDWRK4(RY)     GET PTR TO PAREN INFO              A
         TM    0(RZ),$MINSBST+$MINSYSL  IN SUBSTR OR SYSLIST?
         BM    MCLCOM01            OKAY IF YES
MCLCOMR1 EQU   *
         LA    RB,$ERINSBV        ELSE SET WRONG NBR ARGS FLAG
         B     MCLXERTN            AND RETURN
MCLCOM01 EQU   *
         TM    0(RZ),X'01'         ONE ARG ALREADY PROCESSED?
         BO    MCLCOMR1            ERROR IF YES
         OI    0(RZ),X'01'         INDICATE ONE ARG PROCESSED
         MVI   MCBSINDX,$BSCOMMA   SET BSU INDEX
         MVI   MCBSHIER,$MCOMMHR   SET HIERARCHY
         LA    RA,1(R1)            BUMP SCAN POINTER
         B     MCLXDLMF            JUMP TO DILIM/OPRTR FOOT
         SPACE 4
* AMPERSANDS FOUND, PROCESS IT. C HECKS FOR VARIABLES, FOR INSIDE     A
* QUOTES, ADDS CONCATINATION OPERATOR WHEN NEEDED, SYBOL PARMS, ETC   A
* ALSO SEARCHES DICTIONARIES AND PROCESS GLOBAL, LOCAL & SYMBOLIC     A
* VARIABLES                                                           A
*                                                                     A
MCLAMPRS EQU   *
         TM    AVMBYTE2,$MINCHAR   IN CHAR EXPRESSION?
         BNO   MCLAMP00            PROCEED IF NOT
         TM    AVMBYTE1,$MINQUOT   SHOULD BE IN QUOTES
         BO    MCLAMP00            OKAY IF YES
         TM    AVMBYTE2,$MINAPAR   IN SUBSCRIPT?
         BO    MCLAMP00            THIS EXCUSSES ALL
         LA    RB,$ERMISQU         ELSE SETT MISSING QUOTES FLAG
         B     MCLXERTN            AND RETURN
MCLAMP00 EQU   *
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCLAMPR1            IF NOT, PROCEED
         CLI   1(R1),C'&&'         NEXT CAR = &?
         BNE   MCLAMP01            PROCEED IF NOT
         LA    RA,2(R1)            ELSE BUMP SCAN POINTER PAST &&
         B     MCLXSCAN            AND RESUME SCAN
MCLAMP01 EQU   *
         CR    R0,R1               STRING PRECEEDING &?
         BE    MCLAMPRT            PROCESS VAR SYMB IF NOT
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCLAMP02            PROCEED IF YES
         BAL   RET,MCLXCATI        ELSE INSERT CAT OPRTR
MCLAMP02 EQU   *
         LR    RB,R1               ELSSE COPY END OF STRING+1
         LR    RA,R0               GET START OF STRING
         $CALL MCGTST              GET STRING
         STC   RD,MCBSTRLN         SAVE STRING LENGTH IN BSU
         ST    RC,MCBSLOC          SAVE LOCATION IN BSU
         MVI   MCBSINDX,$BSTRING   IDENTIFY BSU
         OI    MCBSFLGS,$MINQUOT+$MTERM+$MINCHAR  SET FLAGS IN BSU
         $SCOF RB,R0,MCBSOFST      PUT OFFSET IN BSU
         LR    R0,RA               BUMP START POINTER
         BAL   RE,MCLXBMP          BUMP BSU
         B     MCLAMPR0            PROCEED                            A
MCLAMPRT EQU   *
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BO    MCLAMPR1            PROCEED IF YES
         SPACE 2
MCLAMPR0 BAL   RET,MCLXCATI        INSERT CONCAT OPR                  A
MCLAMPR1 EQU   *
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCLAMPR2            PROCEED IF NOT
         OI    MCBSFLGS,$MINQUOT   ELSE SET QUOTR FLAG IN BSU
MCLAMPR2 EQU   *
         $CALL MCSYSR              FIND SYMBOL IN DICTIONARIES
         LTR   RB,RB               OKAY?
         BP    MCLXERTN            UNDEFINED IF RB > 0
         BM    MCLXISER            INVALID SYMBOL IF RB < 0
         B     *(RD)               JUMP TO ROUTINE
         B     MCLAGLOB            GLOBAL SYMBOL?
         B     MCLALOCL            LOCAL SYMBOL?
         B     MCLASYPR            SYMBOLIC PARAMETER?
         USING MCPARENT,RC         SET USING FOR PARAMETER
MCLASYSV EQU   *                   SYTEM VARIABLE IF BRANCH HERE
         CLI   MCPARNLN,X'08'      COMPARE LENGTH
         BE    MCLASYLS            IF 8, MUST BE SYSLIST
         CLI   MCPARNAM+6,C'X'     IS IT &SYSNDX
         BE    MCLASYDX            PROCESS IF YES
         MVI   MCBSINDX,$BSYSECT   MUST BE &SYSSECT
         B     MCLXTRMF
MCLASYLS EQU   *
         MVI   MCBSINDX,$BSYSLST   SET &SYSLST INDEX IN BSU
         OI    AVMDWRK4,$MINSYSL   SET SYSLIST FLAG IN PAREN BYTE
         B     MCLAGSYL            GO TO MAKE SURE ( THERE AND FLAG   J
MCLASYDX EQU   *
         MVI   MCBSINDX,$BSYSNDX   SET &SYSNDX FLAG IN BSU
         B     MCLXTRMF
* SYMBOLIC PARAMETER FOUND                                            A
MCLASYPR EQU   *
         MVI   MCBSINDX,$BSYMPAR   SET SYMBOLIC PARAM BSU INDEX
         LH    R2,MCPARNDX         GET SYM PAR POSITION
         ST    R2,MCBSLOC          STORE IN BSU
         CLI   0(RA),C'('          NEXT CHAR = '('?
         BNE   MCLXTRMF            PROCEED TO FOOT IF NOT
         OI    AVMBYTE2,$MDIMVAR    ELSE SET DIM VARIABLE FLAG
         B     MCLXTRMF
         DROP  RC
         SPACE 2
* GLOBAL SYMBOL FOUND                                                 A
         USING MCGLBDCT,RC
MCLAGLOB EQU   *
         ST    RC,MCBSLOC          STORE ENTRY @ IN BSU
         CLI   MCGLBTYP,X'08'      WHAT TYPE OF GLOBAL SYMBOL?
         BH    MCLASY01
         BL    MCLASY02            ARITH IF LOW
         MVI   MCBSINDX,$BSTSYBG   MUST BE BOOL IF FALLS THROUGH
         OI    MCBSFLGS,$BSBOOL    SET BOOLEAN FLAG
         B     MCLAGLFT
MCLASY01 EQU   *
         MVI   MCBSINDX,$BSTSYCG   SET CHAR BSU INDEX
         OI    MCBSFLGS,$BSCHAR    SET CHAR FLAG
         B     MCLAGLFT
MCLASY02 EQU   *
         MVI   MCBSINDX,$BSTSYAG   SET ARITH BSU INDEX
         OI    MCBSFLGS,$BSAR      SET ARITH FLAG
         B     MCLAGLFT
         DROP  RC
         SPACE 2
* LOCAL SYMBOL FOUND                                                  A
         USING MCLCLDPV,RC
MCLALOCL EQU   *                   ROUTINE FOR LOCAL SYMBOLS
         ST    RC,MCBSLOC          SAVE ENTRY @ IN BSU
         CLI   MCLCLTYP,X'08'      WHAT TYPE LOCAL SYMBOL?
         BH    MCLASY03            CHAR IF HIGH
         BL    MCLASY04            ARITH IF LOW
         MVI   MCBSINDX,$BSTSYBL   SET LOCAL INDEX IF FALLS THROUGH
         OI    MCBSFLGS,$BSBOOL    SET BOOLEAN TYPE FLAG
         B     MCLAGLFT
MCLASY03 EQU   *
         MVI   MCBSINDX,$BSTSYCL   SET LOCAL CHAR SYMBOL INDEX
         OI    MCBSFLGS,$BSCHAR    SET CHAT TYPE FLAG
         B     MCLAGLFT
MCLASY04 EQU   *
         MVI   MCBSINDX,$BSTSYAL   SET LOCAL ARTITH INDEX
         OI    MCBSFLGS,$BSAR      SET ARITH TYPE FLAG
MCLAGLFT EQU   *
         CLC   MCLCLDIM,AWH1       SET SYMBOL DIMENSIONED?
         BE    MCLASY06            IF NOT, JUMP
MCLAGSYL OI    AVMBYTE2,$MDIMVAR   SHOW DIMENSIONED                   J
         CLI   0(RA),C'('          MUST BE LEFT PAREN
         BE    MCLXTRMF            OK IF YES
MCLASY05 EQU   *
         LA    RB,$ERSSDIM         ELSE SET SUBSCRIPT ERROR FLAG
         B     MCLXERTN            AND RETURN
MCLASY06 EQU   *
         CLI   0(RA),C'('          NEXT CHAR = (?
         BNE   MCLXTRMF            OKAY IF NOT
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BO    MCLXTRMF            PAREN OKAY IF YES
         B     MCLASY05            ELSE FLAG BAD PAREN
         DROP  RC
         SPACE 2
* PERIOD FOUND, LEGAL IF IN CHAR EXP & IF NOT, CONCATINATION OPERATOR A
* NEEDED AND BSU INSERTED                                             A
MCLPEROD EQU   *
         TM    AVMBYTE2,$MINCHAR   IN CHAR EXPRESSION?
         BNO   MCLXSYER            ERROR IF NOT
         TM    AVMBYTE1,$MINQUOT   ARE WE IN QUOTES?
         BNO   MCLPER01            PROCEED IF NO
         CR    R0,R1               POINTER MOVED?
         BE    MCLPER02            PROCEED IF NOT
MCLPER00 EQU   *
         LA    RA,1(R1)            ELSE BUMP PNTR PAST '.' AND RESUME
         B     MCLXSCAN            SCAN
MCLPER02 EQU   *
         CLI   1(R1),C'&&'         POSSIBLE VAR SYMBOL?
         BNE   MCLPER0A            PROCEED IF NOT
         CLI   2(R1),C'&&'         DOUBLE '&&'?
         BNE   MCLPER0B            CAT OPRTR IF NOT
MCLPER0A EQU   *
         IC    R2,1(R1)            GET NEXT CHARACTER
         LA    R2,AWTSYMT(R2)      USE AS POINTER INTO TABLE
         CLI   0(R2),X'00'         NEXT CHAR IS ALPHANUM?
         BNE   MCLPER00            TREAT PERIOD AS CHAR IF NOT
MCLPER0B EQU   *
         CLI   MCBSINDP,$BSCAT     PREV SYM= COCAT?                   A
         BE    MCLPER00            TREAT AS CHAR IF YES
MCLPER01 EQU   *
         $SCOF RB,R1,MCBSOFST      GET OFFSET OF CAT OPRTR
         BAL   RET,MCLXCATI        ELSE INSERT CAT OPRTR
         B     MCLXSTRS            RESUME SCAN                        S
         SPACE 4
* QUOTE FOUND, PROCESS FOR CHAR END, NULL STRING SYMBOL(DOUBLE QUOTES)A
* ALSO ERROR CHECKING DONE                                            A
MCLQUOTE EQU   *
         C     R1,AVSOLAST         END OF RECORD?
         BNL   MCLQUER1            ERROR IF YES
         TM    AVMBYTE1,$MINQUOT   ARE WE IN QUOTES?
         BNO   MCLQ02              IF NOT, SET FLAGS AND PROCEED
         CLI   1(R1),C''''         DOUBLE QUOTE?
         BNE   MCLQTF              IF NOT, GET STRING
         LA    RA,2(R1)            ELSE BUMP POINTER AND RESUME SCAN
         B     MCLXSCAN
MCLQ01   EQU   *
         LR    RB,R1               COPY END OF STRING + 1
         LR    RA,R0               COPY START OF STING
         $CALL MCGTST              GET STRING
         ST    RC,MCBSLOC          SAVE LOCATION IN BSU
         STC   RD,MCBSTRLN         SAVE STRING LENGTH IN BSU
         MVI   MCBSINDX,$BSTRING   IDENT BSU
         OI    MCBSFLGS,$MINQUOT   FLAG BSU AS IN QUOTE
         LA    RA,1(R1)            BUMP SCAN POINTER PAST QUOTE
         XI    AVMBYTE1,$MINQUOT   TURN QUOTE FLAG ON/OFF
         B     MCLXTRMF
MCLQ02   EQU   *
         TM    AVMBYTE2,$MINARIT   IN ARITH EXPRESSION?
         BO    MCLXISER            ERROR IF YES
         XI    AVMBYTE1,$MINQUOT   TURN ON QUOTE FLAG
         B     MCLXSTRS            RESUME SCAN                        S
MCLQTF EQU *
         CR    R0,R1               STRING PRESENT?
         BNE   MCLQTF01            IF YES, PROCEED
         BCTR  R1,0                ELSE DECR POINTER
         CLI   0(R1),C''''         PREV CHAR = QUOTE?
         LA    R1,1(R1)            RESTORE POINTER BEFORE TEST
         BE    MCLQ01              IF YES, PROCESS NULL STRING
         B     MCLQ02              ELSE TURN OFF FLAG AND RESUME SCAN
MCLQTF01 EQU   *
         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?
         BNO   MCLQ01              PROCEED IF NOT
         BAL   R14,MCLXCATI        ELSE INSERT CATEN OPRTR
         B     MCLQ01              AND THEN PROCEED
         SPACE 2
         SPACE
MCLQUER1 EQU   *
         LR    RA,R1               GET @ OF RECORD ENDING QUOTE
         S     RA,=F'2'            DECR TO END OF OPERAND
         B     MCL$ERV                                                S
         SPACE 2
MCLBLANK EQU   *
         LTR   RY,RY               STILL IN PARENS?
         BZ    MCLXFOOT            RETURN IF NOT
         TM    AVMBYTE2,$MINBOOL   IN BOOLEAN EXPRESSION
         BO    MCLXSTRS            OK IF YES, RESUME SCAN             S
MCL$ERV  LA    RB,$ERVUNEX         ELSE SET ERROR FLAG                S
         B     MCLXERTN            AND RETURN
         SPACE 4
MCLXOPRF EQU   *
         TM    AVMBYTE2,$MOPRTR    PREV BSU = OPRTR?
         BNO   MCLXDLMF            OKAY IF NOT
         CLI   MCBSINDX,$BSNOT     IS CURRENT SYMBOL = NOT ?          S
         BNE   MCLXOPER            ERROR IF NOT
         CLI   MCBSINDP,$BSLPAR    IS IT LEFT PAREN                   A
         BE    MCLXOP01            OKAY IF YES
         CLI   MCBSINDP,$BSAND     IS IT AN AND?                      A
         BE    MCLXOP01            OKAY IF YES
         CLI   MCBSINDP,$BSOR      IT IS OR?                          A
MCLXOP01 EQU   *
         BE    MCLXDLMF            RESUME SCAN IF ONE OF (, AND OR
         B     MCLXSYER            ELSE FLAG ERROR
MCLXOPER EQU   *
         CLI   MCBSINDP,$BSRPAR    PREV SYMBOL = RIGHT PAREN ?        S
         BE    MCLXOP01            OKAY IF YES
         B     MCLXSYER            ELSE FLAG ERROR
         SPACE 4
MCLXTRMF EQU   *
         TM    AVMBYTE2,$MTERM     PREV BSU = TERM?
         BO    MCLXSYER            ERROR IF YES
         OI    MCBSFLGS,$MTERM     SET FLAG IN BSU
         XI    AVMBYTE2,$MOPRTR+$MTERM  TURN ON TERM FLAG
         B     MCLXF09             JUMP TO FOOT
         SPACE 4
MCLXDLMF EQU   *
         OI    MCBSFLGS,$MOPRTR    TURN ON OPRTR FLG IN BSU
         NI    AVMBYTE2,X'FF'-$MDIMVAR-$MTERM  TERM,DIMVAR FLAGS      A
         OI    AVMBYTE2,$MOPRTR    TURN ON OPRTR FLAG
         B     MCLXF09
         SPACE 4
**--> INSUB: MCLXCATI    ROUTINE TO INSERT CONCATINATION + + + + + + +A
*+                                                                    A
*+ CALLED WHEN CONCATINATION OPERATION NEEDED, INSERTR BSU            A
*+                                                                    A
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +A
         SPACE 2                                                      A
MCLXCATI EQU   *
         MVI   MCBSINDX,$BSCAT     SET CATEN INDEX
         MVI   MCBSHIER,$MCATHR    SET HEERARCHY
         TM    AVMBYTE1,$MINQUOT   INSIDE QUOTES?
         BNO   MCLXCAT1            SKIP IF NOT
         OI    MCBSFLGS,$MINQUOT   SET IN QUOTE FLAG IN BSU
MCLXCAT1 EQU   *
         OI    MCBSFLGS,$MOPRTR    SET OPRTR FLAG IN BSU
         BAL   RE,MCLXBMP          BUMP BSU
         NI    AVMBYTE2,X'FF'-($MOPRTR+$MTERM)  TURN OFF FLAGS
         OI    AVMBYTE2,$MOPRTR    SET PREV SYMBOL = OPRTR FLAG
         BR    R14                 RETURN
         SPACE 4
**--> INSUB: MCLXBMP       BUMP POINTER  + + + + + + + + + + + + + + +S
*+       SAVE PREVIOUS BSU AND BUMP POINTER                          +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCLXBMP  EQU   *
         MVC   MCBSFLGP(4),0(RW)   MOVE PREV BSU INTO WRK AREA        A
         XSNAP T=NO,STORAGE=(*0(RW),*8(RW)),LABEL='BSU - MACLEXP',     #
               IF=(AVTAGSM,O,AJOMACRH,TM)
         LA    RW,$LMCBSU(RW)      BUMP BSI POINTER                   A
         C     RW,AVMCHLIM         WORK AREA EXCEEDED?
         BL    MCLXBMP1            OK IF NOT
         LA    RB,$ERVTMTR         ELSE FLAG TOO MANY TERMS
         B     MCLXERTN            AND RETURN
MCLXBMP1 EQU   *
         MVC   MCBSU(8),AWZEROS    ZERO NEW BSU
         BR    RE                  AND RETURN
MCBSFLGP DS    C                   PREVIOS                            A
MCBSINDP DS    C                   BSU                                A
MCBSOFSP DS    C                   WORK                               A
MCBSHIEP DS    C                   AREA                               A
         SPACE 2
MCLXF09  EQU   *
         $SCOF RB,R0,MCBSOFST      GET OFFSET INTO BSU
         BAL   RE,MCLXBMP          BUMP BSU
         TM    AVMBYTE4,$MINSTRN   PROCESSING OUTSIDE VAR SYMBOL?
         BNO   MCLXSTRT            IF NOT, RESUME SCAN
         NI    AVMBYTE4,X'FF'-$MINSTRN  ELSE TURN OFF FLAG
         CLI   0(RA),C'('          PAREN FOLLOWING?
         BNE   MCLXFOOT            RETURN IF NOT
         OI    AVMBYTE2,$MINPEXP   ELSE SET PARENS ONLY FLAG
         B     MCLXSTRT            AND RESUME SCAN
         SPACE 2
MCLXISER EQU   *
         LR    RA,R0               RESTORE SCAN POINTER
         LA    RB,$ERINVSY         SET INVALID SYMBOL FLAG
         B     MCLXERTN            AND RETURN
         SPACE 2
MCLEXERR EQU   *
MCLXSYER EQU   *
         LR    RA,R0               RESTORE SCAN POINTER
         LA    RB,$ERVSYNT         SET SYNTAX ERROR FLAG
         B     MCLXERTN            AND RETURN
         SPACE 2
MCLXFOOT EQU   *
         SR    RB,RB
         TM    AVMBYTE2,$MOPRTR    LAST BSU = OPRTR?
         BNO   MCLXERTN            RETURN NORMALLY IF NOT
         CLI   MCBSINDP,$BSRPAR    IT IS RIGHT PAREN?                 A
         BE    MCLXERTN            RETURN                             S
MCLXFTER EQU   *
         $SCPT RA,MCBSOFST         GET POINTER TO ERROR
         LA    RB,$ERVSYNT         SET ERROR FLAG
MCLXERTN EQU   *
MCLEQUAL EQU   MCLXERTN            ERROR IF '==' TURNS UP             S
         $SETRT ('''',0,'&&',0,'.',0)   RESTORE TRT TABLE
         MVI   AWTDECT+C'+',2
         MVI   AWTDECT+C'-',2
         MVI   AWTDECT+C'/',2      RESTORE AWTDEDT TABLE TO ORIGINAL
         MVI   AWTDECT+C')',2      CONDITIONS BEFORE RETURNING
         MVI   AWTDECT+C'''',2
         MVI   AWTDECT+C'&&',2
         MVI   AWTDECT+C'.',2
         XSNAP LABEL='***MACLEX EXITED***',IF=(AVMSNBY2,O,$MSNP09,TM)
         LR    RC,RW               SET BSU POINTER
         $RETURN  RGS=(R14-R6)
         LTORG
         DROP  RAT,RW
         TITLE '***  MCGNCD - GENERATE INTERNAL CODE FOR MACRO S'
**-->  CSECT:  MCGNCD  CONVERTS STRING OF BSU'S TO INTERNAL CODE      *
*.        IN ONE-OP FORM.  ONE-OPS ARE QUADRUPLES WITH OPRTR, TWO     *
*.        OPRNDS AND RESULT FIELD.   ADDRESS OF CURRENT GENERATED INST*
*.        IS IN AVMCRINS.  GEERATED CODE IS POINTED TO BY MCCODLNK    *
*.        FIELD IN MACLIB.  BSU STRING LOCATED IN AVMWRK1             *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.     RC = @ OF CURRENT MACLIB ENTRY                                 *
*.                                                                    *
*.        USES MACROS: $CALL,$SAVE,$RETURN,$SCOF,$SCPT,$ALLOCL,$ALLOCH*
*.        USES DSECTS: AVWXTABL,MCBSU,MCBSTRMS,MCBOPRST,MCOPQUAD,     *
*.                     MACLIB,MCSEQ                                   *
*.        CALLS MACFND, ERRTAG,                                       *
*.                                                                    *
*.        REGISTER USAGE:                                             S
*.             WORK REGS:  R0,R1,RA,RB,RC,RE                          S
*.             TRT BYTE REG:  R2                                      S
*.             RW  - BASE REG FOR BSU                                 S
*.             RX  - BASE REG FOR OPRND STACK                         S
*.             RY  - BASE REG FOR OPRTR STACK                         S
*.             RZ  - BASE REG FOR ONE-OP ENTRY                        S
*.             RAT - BASE REG FOR MAIN TABLE                          S
*.             R1  - BASE REG FOR MACLIB                              S
*.             RD  - UNUSED                                           S
*.                                                                    S
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
MCGNCD   CSECT
         $SAVE RGS=(R14-R6),BR=13,SA=*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MCGNCD ENTERED***',IF=(AVMSNBY2,O,$MSNP10,TM)
         USING MCBSU,RW            NOTE USING FOR BSU INPUT STRING
         USING MCBSTRMS,RX         USING FOR OPRND STACK
         USING MCBOPRST,RY         USING FOR OPRTR STACK
         USING MCOPQUAD,RZ         USING FOR ONE-OP ENTRY
         USING MACLIB,RC           USING FOR MACLIB ENTRY
         NI    AVMBYTE4,X'FF'-($MCOMST+$MRPARST)   CLEAR COMMA, RP FLAG
         LA    R0,$LMCBSU          LENGTH OF BSU FOR BUMPING          A
         SR    R2,R2               CLEAR BYTE REGISTER                A
         LA    RB,$LMCOPL1         GET LENGTH OF PREFIX SECTION       A
         $ALLOCL RE,RB,MCGNCDOV    GET SPACE FOR IT                   A
         MVC   0($LMCOPL1,RE),AWZEROS CLEAR OUT ONE-OP PREFIX         A
         L     RZ,AVMCRINS         GET PREV INST @
         LTR   RZ,RZ               1ST INSTRUCTION?
         BNZ   MCGNCD00            IF NOT, PROCEED
         LA    RZ,MCCODLNK         FAKE POINTER AS 1ST ONE            A
MCGNCD00 EQU   *
         ST    RE,MCQUDNXT         SAVE LINK IN PREV INSTRUCTION
* CREATE STACK OF ONE OPS                                             A
MCGNCD01 EQU   *
         LR    RZ,RE               SET BASE TO NEW ENTRY
         ST    RZ,AVMCRINS         SAVE CURRENT INST @
         ZAP   MCQSTMNO,AVOULNCN   STORE CURRENT PACKED DEC STMT NBR
         L     RW,AVMCHSTR         GET @ OF BSU INPUT STRING
         XSNAP LABEL='BEGIN MCGENCD',STORAGE=(*0(RW),*100(RW)),        X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         LA    RX,AVMWRK2          USE AVMWRK2 FOR OPRND STACK
         LA    RY,AVMWRK1          USE QVMWRK1 FOR OPRTR STACK
         MVC   MCBSTRMS($LMCBSU),AWZEROS  CLEAR OPRND STACK
         MVC   MCBOPRST($LMCBSU),AWZEROS   CLEAR OPRTR STACK
         SR    RX,R0               DECR APRND PTR FOR STMT            A
*  POP BSU, SET PRIORITIES AND PUSH ON APPROPRIATE STACK              A
MCGNCDSC EQU   *
         CLI   MCBSINDX,X'00'      END OF BSU'S?
         BE    MCGENCD             IF YES , POP INSTRUCTIONS
         TM    AVMBYTE4,$MRPARST+$MCOMST  PAREN OR COMMA FLAG ON?
         BM    MCGENCD             IF YES, POP INSTRUCTION
         TM    MCBSFLGS,$MTERM     TERM?
         BNO   MCGNCD02            IF NOT, PROCESS OPRTR
         AR    RX,R0               ELSE BUMP OPRND STACK PTR          A
         MVC   MCBSFLG2($LMCBSU),MCBSU  ELSE PUSH TERM ON OPRND STACK
         B     MCGNCD06
MCGNCD02 EQU   *
         CLI   MCBSINDX,$BSCOMMA   COMMA?
         BNE   MCGNCD03            TEST FOR PAREN IF NOT
         OI    AVMBYTE4,$MCOMST    ELSE SET FLAG
         B     MCGNCD06            AND JUMP TO FOOT
MCGNCD03 EQU   *
         CLI   MCBSINDX,$BSRPAR    REGHT PAREN?
         BNE   MCGNCD04            PROCEED IF NOT
         OI    AVMBYTE4,$MRPARST   ELSE SET FLAG
         B     MCGNCD06            AND JUMP TO FOOT
MCGNCD04 EQU   *
         CLI   MCBSHIER,$MPARHR    PAREN?
         BNE   MCGNCD05            PROCEED IF NOT
         CLI   MCBSINDX,$BSBSTR    SUBSTRING?
         BNE   MCGNPUSH            IF NOT, PUSH ONTO OPRTR STACK
         CLI   MCBSOPST,$BSCAT     CAT OPRTR IN STACK?
         BNE   MCGNPUSH            PUSH OPRTR IF NOT
         TM    MCBOPFL,$MINQUOT    CAT OPRTR IN QUOTES?
         BO    MCGENCD             POP OPRTR IF YES
MCGNPUSH EQU   *
         AR    RY,R0               BUMP STACK POINTER                 A
         MVC   MCBOPRST($LMCBSU),MCBSU  PUSH OPRTR ONTO STACK
         B     MCGNCD06            JUMP TO FOOT
MCGNCD05 EQU   *
         CLI   MCBSINDX,$BSCAT     CAT OPRTR?
         BNE   MCGNCD07            PROCESS NORMALLY IF NOT
         TM    MCBSFLGS,$MINQUOT   CAT OPRTR IN QOTES?
         BNO   MCGNCD07            PROCESS NORMAL IF NOT
         CLC   MCBSHIER,MCBOPHR    COMPARE HIERARCHIES
         BNL   MCGNPUSH            H(OPRRTR) >=H(STACK) THEN PUSH
         B     MCGENCD             ELSE POP OPRTR
MCGNCD07 EQU   *
         CLC   MCBSHIER,MCBOPHR    COMPARE HIERARCHIES
         BH    MCGNPUSH            PUSH OPRTR ONLY IF HIGH
         B     MCGENCD             ELSE POP OPRTR
MCGNCD06 EQU   *
         AR    RW,R0               POP INPUT BSU STACK                A
         B     MCGNCDSC            AND RESUME SCAN OF INPUT
MCOPRBAS DS    0H
         EJECT                                                        A
MCGENCD  EQU   *
         NI    AVMBYTE1,X'FF'-$MINQUOT   TURN OFF QUOTE FLAG
         TM    MCBSFLG1,$MINQUOT     FIRST TERM IN QUOTES?
         BZ    MCGENCD0            PROCEED IF NOT
         OI    AVMBYTE1,$MINQUOT   ELSE SET QUOTE FLAG
MCGENCD0 EQU   *
         CLI   MCBOPHR,$MPARHR     LEFT PAREN?
         BNE   MCGENCD2            PROCEED IF NOT
         TM    AVMBYTE4,$MCOMST    WORKING ON COMMA?
         BNO   MCGENCD1            PROCEED IF NOT
         XI    AVMBYTE4,$MCOMST    ELLE TURN OFF COMMA FLAG
         B     MCGNCDSC            AND RESUME SCAN
MCGENCD1 EQU   *
         NI    AVMBYTE4,X'FF'-$MRPARST   ELSE TURN OFF PAREN FLAG
         CLI   MCBSOPST,$BSLPAR     ORDINARY LEFT PAREN?
         BE    MCGENRT             IF YES POP OPRTR AND RESUME SCAN
*                                                                     A
*  ALLOCATE SPACE FOR ONE OP ENTRIES                                  A
*  HI	RARCHY AND JUMP ON INDEX TO PROCESS                             A
*                                                                     A
MCGENCD2 EQU   *
         CLI   MCBSOPST,X'00'      OPRTR STACK EMPTY?
         BE    MCGNCDRT            RETURN IF YES
         BAL   RET,MCGNALLO        ALLOCATE SP FOR 1 OP ENTRY         S
         IC    R2,MCBOPHR          GET HIERARCHY
         LH    R1,MCOPRNDX(R2)     GET OFFSET
         B     MCOPRBAS(R1)        JUMP TO ROUTINE
         SPACE
MCOPRNDX $AL2  MCOPRBAS,(MCPARGEN,MCHRTW,MCORGEN,MCANDGEN,MCRELGEN,MCCAX
               TGEN,MCPLSGEN,MCMULGEN,MCNOTGEN)
         SPACE
*  PAREN BSU FOUND PUT ONE-OP ON STACK                                A
*                                                                     A
MCPARGEN EQU   *                   HIER = 0 ROUTINES
         BAL   RE,MCMVTRMS         MOVE ARGS TO ONE-OP
         CLI   MCBOPRTR,$BSBSTR    SUBSTRING PAFEN?
         BE    MCPARG0Q            PROCEED IF NOT                     S
MCPARG02 EQU   *
         CLI   MCARG1DX,$BSATT     1ST ARG IS T'?
         BE    MCPARG0Q            TREAT AS QUOTED STRING IF YES
         TM    AVMBYTE1,$MINQUOT   FIRST TERM INSIDE QUOTES?
         BZ    MCPARG03            PROCEED IF NOT
MCPARG0Q EQU   *
         OI    MCBSFLG2,$MINQUOT   SET QUOTE FLAG IN OPRND STACK
MCPARG03 EQU   *
         SR    RW,R0               DECR PTR TO CHECK PREV ENTRY       S
         TM    MCBSLOC+3,X'01'     TWO ARG'S IN PARENS?
         LA    RW,$LMCBSU(RW)      RESTORE POINTER
         BNO   MCGENRT             PROCEED IF NOT
         BAL   RET,MCGNALLO        ALLOCATE SP FOR 1 OP ENTRY         S
         MVC   MCARG1DX,MCBSNDX1   MOVE IDENT OF ARG INTO ONE-OP
         MVC   MCARG1LC,MCBSLOC1   MOVE LOCATION OF OPRND INTO ONE-OP
         CLI   MCARG1DX,$BSTRING   STRING TERM?
         BNE   MCPARG04            PROCEED IF NOT
         MVC   MCARG1LC(1),MCBLN1   MOVE LENGTH OF STRING INTO ONE-OP
MCPARG04 EQU   *
         MVC   MCBSFLG1($LMCBSU),MCBSFLG2 PUSH DOWN OPRND STACK
         B     MCTWODEC            DECR OPRND STACK
         SPACE
*  HEIR=2, PUT ONE-OP ON STACK                                        A
*                                                                     A
MCHRTW   EQU   *
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR FROM STACK TO ONE-OP
         CLI   MCBSOPST,$BSPRINT   WHICH BSU OF HIER = 2?
         BL    MCTWOSET            IF LOW, MUST BE SETX
         BE    MCTWOPRA            IF EQUAL MUST BE PRINT             A
         CLI   MCBSOPST,$BSINMAC   ELSE IS IT INNER MACRO CALL?
         BNL   MCTWOPR             INNER IF EQUAL, MVSTR IF HIGH
*        NOTE: THESE JUST USE ONE-OP PREFIX BY THEMSELVES             A
         L     RZ,AVMCRINS         GET # PREFIX ONE-OP                A
         MVC   MCQS1FLG,MCBSOPST   COPY OPERATOR OVER                 A
         B     MCPREFIX            GO TO PREFIX-ONLY EXIT             A
MCTWOSET EQU   *
         BAL   RE,MCMVTRMS         MOVE OPRNDS INTO ONE-OP
         B     MCTWODEC
MCTWOPRA TM    MCBOPFL,$MPRCOM     WAS THIS SPECIAL PRINT COMMENT UP  A
         BZ    *+8                 NO, SKIP                           A
         OI    MCBOPRTR,$MPRCOM    YES, MAKE PRINT OPRTR ODD, SO KNOW A
MCTWOPR  EQU   *
         MVC   MCARG2LC+3(1),MCBOPOF   MOVE OFFSET INTO INTO ARG2LC
         MVC   MCARG1DX,MCBSNDX2   MOVE TYPE INTO ARG1DX
         MVC   MCARG1LC,MCBSLOC2   MOVE LOCATION OF STRING INTO ONE-OP
         CLI   MCBSNDX2,$BSTRING   INDEX BSU IS CHAR STRING?
         BNE   MCTWODEC            SKIP MOVE LEN IF NOT
         MVC   MCARG1LC(1),MCBLN2  MOVE LENGTH INTO LOC FIELD
         B     MCTWODEC            DECR OPRND STACK
*                                                                     A
* PLUS OR MULTIPLY BSU FOUND PUT ONE-OP ON STACK                      A
*                                                                     A
MCPLSGEN EQU   *
MCMULGEN EQU   *
         BAL   RE,MCMVTRMS         MOV& OPRNDS INTO ONE-OP
         MVI   MCBSFLG2,$MTERM+$BSAR  IDENT OPRND STACK TOP AS ARITH TR
         B     MCGENRT             JUMP TO FOOT
         SPACE
*                                                                     A
* AND × OR BSU FOUND, PUT ONE OP ONTO STACK                           A
*                                                                     A
MCORGEN  EQU   *
MCANDGEN EQU   *
         TM    MCBSFLG1,$BSBOOL    1ST OPRND = BOOL?
         BNO   MCMXDR1             ERROR IF NOT
         TM    MCBSFLG2,$BSBOOL    2ND OPRND = BOOL?
         BNO   MCMXDR1             ERROR IF NOT
         BAL   RE,MCMVTRMS         MOVE OPRNSD INTO ONE-OP
         MVI   MCBSFLG2,$MTERM+$BSBOOL  IDENTIFY AS BOOLEAN TERM
         B     MCGENRT             JUMP TO FOOT
         SPACE
* RELATIONAL OPERATOR FOUND PUT ONE-OP ONTO STACK                     A
*                                                                     A
MCRELGEN EQU   *
         MVI   AVMBYTE3,X'00'      CLEAR AVMBYTE3 FOR FLAG USE
         TM    MCBSFLG1,$MINQUOT   1ST TERM IN QUOTES?
         BO    MCRELG02
         TM    MCBSFLG2,$MINQUOT   2ND TERM IN QUOTES?
         BO    MCRELG03
         B     MCRELG01            ELSE PROCEED
MCRELG02 EQU   *
         OI    AVMBYTE3,$BSRLCHR   SET CHAR RELTN FLAG
         TM    MCBSFLG2,$MINQUOT   2ND TERM IN QUOTES?
         BO    MCRELG01            OKAY IF YES
         CLI   MCBSNDX2,$BSATT    ELSE IS IT T'?
         BE    MCRELG01            OKAY IF YES
         B     MCMXDR2             ELSE ERROR
MCRELG03 EQU   *
         OI    AVMBYTE3,$BSRLCHR   SET CHAR RELTN FLAG
         CLI   MCBSNDX1,$BSATT     1ST TERM = T'?
         BNE   MCMXDR2             ELSE ERROR                         S
MCRELG01 EQU   *
         BAL   RE,MCMVTRMS         MOVE TERMS INTO ONE-OP
         OC    MCBOPRTR,AVMBYTE3   SET CHR OR ARIT FLAG IN OPRTR
         MVI   MCBSFLG2,$MTERM+$BSBOOL   IDENTIFY AS BOOLEAN TERM
         B     MCGENRT             JUMP TO FOOT
         SPACE
*  CATENATION BSU FOUND PUT ONE-OP ON STACK                           A
*                                                                     A
MCCATGEN EQU   *
         CLI   AVMFLDT2,C'M'       MACRO OPCODE?
         BNE   MCCATG01            JUMP PAST QUOTE TEST IF NOT
         TM    MCBSFLG1,$MTERM+$MINQUOT  1ST TERM IN QUOTES?
         BNO   MCMXDR1             ERROR IF NOT
         TM    MCBSFLG2,$MTERM+$MINQUOT     2ND TERM IN QUOTES?
         BNO   MCMXDR1             ERROR IF NOT
MCCATG01 EQU   *
         BAL   RE,MCMVTRMS         MOVE OPRNDS INTO ONE-OP
         MVI   MCBSFLG2,$MTERM+$BSCHAR+$MINQUOT   IDENTIFY TEMP OPRND
         B     MCGENRT             JUMP TO FOOT
         SPACE
* 'NOT' BSU FOUND PUT IN OP-OP STACK                                  A
* ALSO CHECK FOR AGO AND AIF, AND PROCESS IF FOUND                    A
*                                                                     A
MCNOTGEN EQU   *
         CLI   MCBSOPST,$BSAGO     AGO OPRTR?
         BH    MCAIFGEN            IF HIGH MUST BE AIF
         BE    MCAGOGEN            IF EQUAL MUST BE AGO
         TM    MCBSFLG2,$MTERM+$BSBOOL  BOOLEAN TERM?
         BNO   MCMXDR2             ERROR IF NOT
         MVC   MCARG1DX,MCBSNDX2   MOVE INDEX INTO ONE-OP
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP
         MVC   MCARG1LC,MCBSLOC2   MOVE OPRND LOC INTO ONE-OP
         ST    RZ,MCBSLOC2         PUT @ OF ONE-OP IN OPRND STACK
         MVI   MCBSNDX2,$BSTEMP    IDENTIFY STACK AS TEMP
         B     MCGENRT             JUMP TO FOOT
         SPACE
* AGO OR AIF FOUND, PUT ON OP ON STACK                                A
*                                                                     A
MCAGOGEN EQU   *
         L     RA,MCBOPVAL         GET @ OF SEQ SYMBOL
         BAL   RE,MCSEQSCN         JUMP  TO SCAN SEQ SYM DICT
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP
         B     MCGENRT             JUMP TO FOOT
         SPACE
MCAIFGEN EQU   *
         L     RA,MCBSLOC2         GET ADDRESS OF SEQ SYMBOL
         TM    MCBSFLG1,$BSBOOL    BOOLEAN TERM?
         BNO   MCMXDR1             ERROR IF NOT
         BAL   RE,MCSEQSCN         SEQRCH SEQ SYMBOL DICT             A
         MVC   MCARG1DX,MCBSNDX1   MOVE TERM ID TO ONE-OP
         MVC   MCARG1LC,MCBSLOC1   MOVE LOCATION OF TERM TO ONE-OP
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR INTO ONE-OP
         MVC   MCARG2DX,MCBSNDX2   MOVE BSU TERM OF ARG INTO ONE-OP
         B     MCTWODEC            DECR OPRND STACK
         EJECT                                                        S
**--> INSUB: MCSEQSCN       ENTER SEQ SYMBOL IN DICT + + + + + + + + +S
*+       SCAN FOR ERRORS & PUT SEQ SYMBOL IN DICT                    +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCSEQSCN EQU   *                   ROUTINE TO ENTER SEQ SYMBOL IN DICT
         DROP  RC
         USING MCSEQ,RC            SET USING FOR SEQ SYM ENTRY
         CLI   1(RA),C'0'          FIRST CHAR  IS LETTER?
         BNL   MCSEQR1             ERROR IF DIGIT
         TRT   1(8,RA),AWTSYMT     SCAN SYMBOL
         BZ    MCSEQR1             SYMBOL 8+ CHARS, TOO LONG
         CLI   0(R1),C' '          DELIM = BLANK?
         BNE   MCSEQR1             ERROR IF NOT
         SR    R1,RA               GET LENGTH
         BCT   R1,MCSEQS01         DECR LENGTH FOR EX INST
         B     MCSEQR1             BUT FALL THRU IF LENGHT = 1
MCSEQS01 EQU   *
         MVC   AVMSYMBL,AWBLANK    BLANK GLOBAL NAME AREA
         STC   R1,AVMSYMLN         STORE LENGTH
         EX    R1,MCGMVC           MOVE SYMBOL                        S
         AIF   (NOT &$MACOPC).MCGNCDA  SKIP IF NOT OPEN CODE          S
         L     R1,AVMACLIB         LOAD @ OF MACLIB ENTRY             S
         USING MACLIB,R1           NOTE USING ON MACLIB               S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BCR   O,RE                IF YES, SKIP SEQ SYM MANAGEMENT    S
         DROP  R1                                                     S
.MCGNCDA ANOP                                                         S
         L     RC,AVMSEQPT         GET SEQ SYM POINTER
         LA    R1,0(RE)            SAVE RETURN @ TEMP                 S
         $CALL MACFND              SEARCH SEQ SYMBOL DICT
         LR    RE,R1               RESTORE RETURN @                   S
         LTR   RB,RB               SYMBOL PRESENT IN DECT?
         BZ    MCSEQS02            PROCEED IF YES
         LA    RB,$LMCSEQ          ELSE GET LENGTH OF ENTRY
         $ALLOCH  R1,RB,MCGNCDOV   GET SPACE FOR NEW ENTRY
         ST    R1,MCSEQNXT         SAVE LINK IN PREV ENTRY
         LR    RC,R1               MOVE BASE TO NEW ENTRY
         MVC   MCSEQ($LMCSEQ),AWZEROS  CLEAR NEW ENTRY
         MVC   MCSEQNAM,AVMSYMBL   MOVE NEW NAME INTO ENTRY
         MVC   MCARG2LC,AVMCRINS   STORE STMT @ IN ARG2
         ST    RZ,MCSEQVAL         SAVE LINK TO INST
         BR    RE                  RETURN
MCGMVC   MVC   AVMSYMBL($),0(RA)   DUMMY INSTR                        S
MCSEQS02 EQU   *
         CLI   MCSEQFLG,X'FF'      SYMBOL DEFINED?
         BNE   MCSEQS03            IF NOT, JUMP AND PROCESS
         MVC   MCARG2LC,MCSEQVAL   ELSE PUT VALUE IN ONE-OP
         BR    RE                  AND RETURN
MCSEQS03 EQU   *
         LR    R1,RZ               COPY INST @ TEMPORARILY
         L     RZ,MCSEQVAL         GET POINTER FROM ENTRY
MCSEQS04 EQU   *
         CLC   MCRESULT,AWZEROS    END OF CHAIN?
         BE    MCSEQS05            IF YES, ENTERLINK IN LAST ENTRY
         L     RZ,MCRESULT         ELSE GET POINTER TO NEXT LINK
         B     MCSEQS04            AND TRY AGAIN
MCSEQS05 EQU   *
         ST    R1,MCRESULT         PUT CURRENT @ IN LAST LINK
         LR    RZ,R1               RESTORE BSE OF ONE-OP
         MVC   MCARG2LC,AVMCRINS   STORE STMT @ IN ARG2
         BR    RE                  AND RETURN
         DROP  RC
         SPACE
MCTWODEC EQU   *
         SR    RX,R0               POP OPRND STACK                    S
MCGENRT  EQU   *
         SR    RY,R0               POP OPERATOR STACK                 S
         B     MCGNCDSC            RESUME SCAN
         SPACE 5                                                      S
**--> INSUB: MCMVTRMS       CREATE ONE BINARY ONE-OP + + + + + + + + +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCMVTRMS EQU   *                   ROUTINE TO CREATE ONE BINARY ONE OP
         MVC   MCARG1DX,MCBSNDX1   MOVE 1ST TERM ID INTO ONE OP
         MVC   MCARG2DX,MCBSNDX2   MOVE 2ND TERM ID INTO ONE OP
         MVC   MCARG1LC,MCBSLOC1   MOVE 1ST TERM LOCATION INTO ONE-OP
         MVC   MCARG2LC,MCBSLOC2   MOVE 2ND TERM LOCATION INTO ONE-OP
         CLI   MCBSNDX1,$BSTRING   BSU IS A STRING?
         BNE   MCMVTRM1            JUMP IF NOT
         MVC   MCARG1LC(1),MCBLN1    MOVE STRING LENGTH INTO ONE OP
MCMVTRM1 EQU   *
         CLI   MCBSNDX2,$BSTRING   2ND TERM IS STRING?
         BNE   MCMVTRM2            JUMP AROUND IF NOT
         MVC   MCARG2LC(1),MCBLN2  ELSE MOVE STRING LENGTH INTO ONE-OP
MCMVTRM2 EQU   *
         SR    RX,R0               POP OPRND STACK                    S
         MVI   MCBSNDX2,$BSTEMP    IDENTIFY OPRND STACK TOP AS TEMP
         MVC   MCBOPRTR,MCBSOPST   MOVE OPRTR FROM STACK TO ONE-OP
         ST    RZ,MCBSLOC2         PUT TESULST LOCATION IN OPRND STACK
         BR    RE                  RETURN
         SPACE
*        THE FOLLOWING SECTIONS ARE EXIT ROUTINES                     S
*                                                                     S
MCMXDR1  EQU   *
         LA    RB,$ERVSYNT         SETT ERROR TYPE
MCMXDFLG EQU   *
         $CALL ERRTAG              FLAG STMNT
         L     RZ,AVMCRINS         MOVE BASE TO 1ST ONE-OP
         MVI   MCQS1FLG,$BSERR01   SHOW ERRIR BSU                     A
MCPREFIX EQU   *                   ENTER FOR PREFIX/ONLY(NEND,MEXIT,ETA
         LA    RZ,$LMCOPL1(,RZ)    SHOW @ END OF PREFIX               A
         ST    RZ,AVADDLOW         RESTORE  LOW STORAGE
         B     MCGNCDRT            AND RETURN
         SPACE
MCMXDR2  EQU   *
         LA    RB,$ERMXDMD         SET MIXED MODE ERROR
         B     MCMXDFLG            JUMP AND FLAG STMNT
         SPACE
MCSEQR1  EQU   *
         LA    RB,$ERINVSY         SET BAD SYMBOL FLAG
         XSNAP LABEL='BAD SYBOL FLAGGED',                              X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         B     MCMXDFLG            JUMP AND FLAG STMNT
         SPACE
MCGNCDOV EQU   *
         L     REP,AVMOVRFL
         BR    REP
         SPACE
**--> INSUB: MCGNALLO       ALLOCATE LOW CORE  + + + + + + + + + + + +S
*+                                                                   +S
*+       ALLOCATES SPACE FOR OPERAND ENTRIES                         +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MCGNALLO EQU   *                                                      S
         LA    RB,$LMCQUAD         LOAD LENGTH OF AREA NEEDED         S
         $ALLOCL RZ,RB,MCGNCDOV    GET AREA FOR ONE OP                S
         MVC   0($LMCQUAD,RZ),AWZEROS  ZERO ENTRY                     S
         BR    RET                 RETURN                             S
         SPACE 2                                                      S
MCGNCDRT EQU   *
         XSNAP LABEL='MCGENCD EXITED',                                 X
               IF=(AVTAGSM,O,AJOMACRH,TM)                             A
         AIF   (&$DEBUG).MCGNCDR
         L     R1,AVMCRINS         GET @ OF ONE-OPS
         XSNAP LABEL='***ONE-OP''S***',STORAGE=(*0(R1),*200(R1),*AVMWRK1
               1,*AVMWRK1+64,*AVMWRK2,*AVMWRK2+64),IF=(AVMSNBY2,O,$MSNPX
               10,TM)
         XSNAP LABEL='***MCGNCD EXITED ***',IF=(AVMSNBY2,O,$MSNP10,TM)
.MCGNCDR ANOP
         $RETURN  RGS=(R14-R6)
         LTORG
         DROP  RAT,RW,RX,RY,RZ
         TITLE 'MEXPND - MACRO EXPANSION'
**-->  CSECT: MEXPND  EXPANDS MACRO DEFINITION. RECURSIVE. ACQUIRES   *
*.        STORAGE FROM LOW DYNAMIC AREA FOR STANDARD SAVE AREA AND    *
*.        LOCAL VARIABLES.  RELEASES STORAGE ON EXIT.  PUTS GENERATED *
*.        STATEMENTS IN HIGH STORAGE.  AVGEN1CD POINTS TO FIRST BYTE  *
*.        AFTER FIRST STATEMENT.  AVGEN1CD POINTS TO 1ST BYTE OF LAST *
*.        STATEMENT GENERATED                                         *
*.                                                                    *
*.        USES MACROS:  $MALLOCL, $MALLOCH, $CALL, $SAVE, $RETURN,    *
*.                      $AL2                                          *
*.        USES DSECTS: MACLIB, MCGLBDCT, MCOPQUAD, MCPAROPR, MCPARSUB *
*.                     AVWXTABL, MXPNTSAV, MCPARENT, RSBLOCK          *
*.        CALLS ERRTAG, MCSCOP,MXMVSR,MACSCN,MACFND,MXMVSR,MXERRM,    *
*.              ERRTAG,MEXPND,DECTRM                                  *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MEXPND   CSECT
         $SAVE RGS=(R14-R6),BR=13,SA=*                                A
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         MVC   MXADDLOW(4),AVADDLOW SAVE ADDR OF LOW STORAGE          A
         MVC   AVMACNST,AWZEROS    NEST LEVEL = 0                     A
         MVI   AVMBYTE5,0          CLEAR CONT CARD INDICATOR
         L     RC,AVRSBPT          SET BASE FOR SOURCE BLOCK
         USING RSBLOCK,RC          SET USING FOR SOURCE
         CLI   RSBNUM,3            WERE THERE ACTUALLY 3 CARDS IN STMTJ
         BL    MEXPND0A            NO, SKIP CONTINUED-FURTHER TEST    J
         L     RB,AVRSCPT          POINT TO CONT BLOCK
         USING RSCBLK,RB           ESTAB USING ON CONT BLOCK
         CLI   RSCONSQ+2*RSC$LEN,C' '   MORE THAN TWO CARDS?
         BE    MEXPND0A            PROCEED IF NOT
         NI    RSBFLAG,255-$REBX   TURN OFF ERROR FLAG
         MVI   AVMBYTE5,$ERCONTX   ELSE SET CONT CARD INDICATR
         DROP  RB,RC
MEXPND0A EQU   *
         OI    AVRSBLOC+1,$RSBNP##  TURN ON OUTER FLAG
         L     RB,AVADDHIH         GET HIGH PNTR
         LR    RC,RB               COPY INTO RC
         STM   RB,RC,AVGEN1CD      MOVE INTO AVGEN1CD,AVGEN2CD
         ST    RB,MEXGN2OV         SAVE ORIG VALUE, IN CASE OVERFLW JRM
         LA    RB,L'MXPOVRMS+RSB$L   GET LENGTH OF MSSGE
         $MALLOCH  R1,RB           GET STORAGE FOR ERROR MSSGE
         ST    R1,MEXGN2OV         SAVE @, IN CASE OVERFLOW NPW     JRM
         MVC   0(L'MXPOVRMS+RSB$L,R1),MXPOVRMS   MOVE ERROR MSSGE
         LA    RE,RSB$L            GET LENGTH OF SNDRD PART OF RSBLOCK
         IC    RB,AVRSBLOC         GET LENGTH-1 OF RSBLOCK
         SR    RB,RE               DECR BY RSB$L
         STC   RB,AVRSBLOC         RESTORE
         MVC   AVGEN1CD,AVGEN2CD   DECR HIGH PNTR AWAY FROM MSSGE
         EJECT                                                        S
MEXPND01 EQU   *
* EVERY NEST LEVEL                                                    A
         L     RC,AVMACNST                                            A
         LA    RC,1(,RC)           INCREASE BY ONE                    A
         C     RC,AVMMNEST         TEST FOR OVER                      A
         BH    MEXPMNES            OVER THE LIMIT                     A
* FALLS THROUGH IF OK                                                 A
         ST    RC,AVMACNST         STORE NEW LEVEL                    S
         LR    R1,RZ               SAVE PREVIOUS @ MXPNTSAV           S
         $MALLOCL RZ,RB,LENG=$LMXPTSV  GET SPACE FOR NEXT ONE         S
         USING MXPNTSAV,RZ                                            A
         ST    R1,MXPNLINK         STORE PREVIOUS RZ                  S
         L     RA,AVRSBPT          LOAD SCAN POINTER                  S
         LA    RA,RSB$L(RA)        GET @ OF SOURCE IMAGE              S
         SPACE
*  NEXT SECTION CHECKS NAME FOR VALIDITY
         SPACE
         $CALL MACSCN              SCAN SOURCE FOR FIELDS
         L     RA,AVMFLD2          GET OPCODE @
         CLI   AVMFLDT2,X'00'      UNIDENTIFIED OPCODE?
         BE    MEXPND03            ERROR IF YES
         MVC   AVMSYMBL,AWBLANK    ELSE CLEAR GLOBAL NAME AREA
         MVC   AVMSYMLN,AVMFLDL2   MOVE LENGTH OF OPCODE
         SR    R1,R1               CLEAR R1 FOR EX
         IC    R1,AVMFLDL2         GET OPCODE LEN
         BCTR  R1,0                DECR FOR EX INST
         EX    R1,MXPNMVC          MOVE OPCODE NAME TO GLOBAL DICT    S
         L     RC,AVMACLIB         GET MACLIB @
         $CALL MACFND              SEARCH MACLIB
         LTR   RB,RB               FOUND?
         BZ    MEXPND04            IF YES, PROCEED
MEXPND03 EQU   *
         LA    RB,$ERIVOPC         ELSE SET BAD OPCODE FLAG
         B     MXPNDERT            AND RETURN
MEXPND04 EQU   *
         USING MACLIB,RW           NOTE USING ON MACLIB
         LR    RW,RC               SET MACLIB BASE
         TM    MCLBTAGS,AVMCLBDF   PREVIOUSLY DEFINED MACRO?
         BNO   MEXPND03            ERROR IF NOT
         ST    RW,MXPNMCLB         SAVE MACLIB PNTR IN LOCAL AREA
         LH    RA,MCPOPRNB          GET NBR OF OPRNDS
         LA    RA,1(RA)            BUMP FOR LABEL FIELD
         LA    RC,$LMPAROP         GET LEN OF SYM PAR DICT ENTRY
         MR    RB,RA               GET LEN REQ'D
         $MALLOCL  RY,RC           GET CORE FOR SYM PAR DICTIONARY
         ST    RY,MXPNLSPT         COPPY PNTR TO SYM PAR DICT
         SPACE
*  NEXT SECTION ZEROS SYM PAR DICTIONARY AND INITIALIZES ENTRIESTO TYPE
*  'O'.  ALSO FINDS FIRST KEYWORD D.V. IF ANY.
         SPACE
         USING MCPARENT,RX         SET USING FOR SYM PAR D.V.
         USING MCPAROPR,RY         SET USING FOR SYM PAR DICT ENTRIES
         L     RX,MCPARPNT         SET BASE FOR D.V.'S
         MVC   MXPNKYPT(8),AWZEROS  CLEAR KEYWORD PNTRS
         NI    AVMBYTE1,255-$MKEYOPR SHOW NO KEYWORDS YET             S
MEXPND05 EQU   *
         CLI   MCPARTYP,C'S'       SYSTEM VAR?
         BNE   MEXPND06            IF NOT, PROCEED
         L     RX,MCPARNXT         ELSE POINT TO NEXT ENTRY
         B     MEXPND05            AND TRY AGIAN
MEXPND06 EQU   *
         ST    RX,MXPLSYPT         SET PNTR TO SYM PAR D.V.'S
MEXPND07 EQU   *
         MVC   MCPAROPR($LMPAROP),AWZEROS  CLEAR NEXT ENTRY
         MVI   MCPAROTP,C'O'       SET TYPE TO NULL
         CLI   MCPARTYP,C'K'       KEYWORD?
         BNE   MEXPND08            JUMP TO FOOT IF NOT
         TM    AVMBYTE1,$MKEYOPR   1ST KEYWRD DV FOUND?
         BO    MEXPND08            JUMP TO FOOT IF YES
         ST    RY,MXPNKLPT         SAVE @ OF 1ST KEYWRD DICT ENTRY
         ST    RX,MXPNKYPT         SAVE @ OF 1ST KEYWRD D.V.
         OI    AVMBYTE1,$MKEYOPR   TURN ON KEYWRD FOUND FLAG
MEXPND08 EQU   *
         L     RX,MCPARNXT         GET NEXT ENTRY PNTR
         LTR   RX,RX               LAST ENTRY IN D.V.'S
         BZ    MXPLAB01            PROCESS LABEL IF YES
         LA    RY,$LMPAROP(RY)     ELSE BUMP DICT POINTER
         B     MEXPND07            AND INITIALIZE NEXT ENTRY
         SPACE 2
*   NEXT SECTION PROCESS LABEL FIELD OF MACRO CALL
MXPLAB01 EQU   *
         NI    AVMBYTE1,X'FF'-$MKEYOPR  TURN OFF KEYWORD FLAG
         L     RX,MXPLSYPT         SET BASE TO 1ST SYM PAR DV
         L     RY,MXPNLSPT         POINT TO SYM PAR DICTIONARY
         L     RA,AVMFLD1          GET @ OF LABEL
         CLI   AVMFLDL1,X'00'      LABEL PRESENT?
         BE    MXPOPR01            IF NOT, PROCESS OPRND FIELD
         CLI   MCPARNLN,X'00'      LABEL OPRND DEFINED?
         BNE   MXPLAB03            PROCESS IF YES
         LA    RB,$ERILLAB         ELSE SET ILLEGAL LABEL FLAG
         $CALL ERRTAG              FLAG STMNT
         B     MXPOPR01            PROCESS OPRND
MXPLAB03 EQU   *
         SR    R2,R2               CLEAR R2
         IC    R2,AVMFLDL1         GET LABEL LENGTH
         LA    R2,3(,R2)           BUMP FOR ROUND/4                 JRM
         SRL   R2,2                DIVIDE BY 4                      JRM
         SLL   R2,2                MULT BY 4, ROUNDED UP            JRM
         $MALLOCL   RB,R2          GET STORAGE
         IC    R2,AVMFLDL1         GET LENGTH
         STC   R2,MCPAROLN         SAVE LEN IN DICT ENTRY
         BCTR  R2,0                DECR FOR EX INST
         EX    R2,MXPNMVOP         MOVE LABEL TO STORAGE
         MVI   MCPAROFL,X'FF'      SET DEFINED FLAG
         MVI   MCPAROTP,C'U'       SET TYPR TO UNDEFINED
         ST    RB,MCPAROPT         STORE OPRND LOC IN DICTIONARY
         SPACE 2
*   START PROCESSING OPRND FIELD.  IS THERE AN OPRND?
MXPOPR01 EQU   *
         MVC   MXPNBOPS,AWZEROS    INIT OPRND COUNT TO ZERO
         CLC   MCPARNXT,AWZEROS    SYM PAR DV'S?
         BE    MXPNOPFN            IF NOT, MOVE STMT TOHIG CORE
         L     RA,AVMFLD3          GET OPRND @
         LTR   RA,RA               OPRND PRESENT?
         BNZ   MXPOPR03            PROCESS IF YES
         IC    RA,AVMFLDL2         ELSE GET LEN OF OPCODE
         A     RA,AVMFLD2          ADD OPCODE @ TO SCAN POINTER
         DROP  RW                  DROP MACLIB USING
MXPOPR03 EQU   *
         ST    RA,AVMTSCNP         SAVE PNTR TEMP
         TM    AVMBYTE1,$MKEYOPR   KEYWORD PROCESSED?
         BO    MXPOPK01            JUMP IF YES
         LA    RY,$LMPAROP(RY)     ELSE BYMP DICT PNTR
         L     RX,MCPARNXT         AND GET NEXT DV ENTRY
         LTR   RX,RX               FINAL ENTRY?
         BNZ   MXPOPR04            PROCESS IF NOT
         CLI   0(RA),C' '          OPRND PRESENT?
         BE    MXPNOPFN            FINISHED IF NOT
         LA    RB,$ERILOPR         ELSE SET NO OPRND ALLWD FLAG
         $CALL ERRTAG              FLAG STMT
         B     MXPNOPFN            AND JUMP TO FOOT
MXPNMVOP MVC   0($,RB),0(RA)       DUMMY TO MOVE OPRND TO STORAGE
MXPOPR04 EQU   *
         CLI   MCPARTYP,C'K'       SYM PAR DV = KEYWORD?
         BE    MXPOPK00            PROCESS KEYWORD                    S
MXPOPR05 EQU   *
         CLI   0(RA),C' '          OPRND PRESENT?
         BE    MXPOPR07            CLEAN UP KEY WORDS IF NOT
         CLI   0(RA),C','          COMMA INIDICATES NULL
         BE    MXPOPR0C            BUMP OPRND COUNT IF YES
         BAL   RET,MXPNOSY7        ORDINARY SYMBOL ?                  S
         LTR   RB,RB               RB TELLS ALL
         BNZ   MXPOPR06            JUMP AND SCAN OPRND IF NOT
         CLI   0(RC),C'='          KEYWORD ?
         BNE   MXPOPR06            PROCESS IF NOT
         OI    AVMBYTE1,$MKEYOPR   SET KEYWORD FLAG
         B     MXPOPK02            PROCESS KEYWRD OPRND
MXPOPR06 EQU   *
         BAL   RET,MXPOPSCN        SCAN OPRND, SAVE IN DICT
MXPOPR0C EQU   *
         L     R1,MXPNBOPS         GET OPRND COUNT
         LA    R1,1(R1)            BUMP BY 1
         ST    R1,MXPNBOPS         RESTORE
         B     MXPOPRFT            JUMP TO FOOT
MXPOPR07 EQU   *
         BCTR  RA,0                DECR SCN PNTR TO CHECK FOR ','
         CLI   0(RA),C','          COMMA PRESENT
         LA    RA,1(RA)            RESTORE SCAN POINTER
         BNE   MXPOPKFN            IF NOT, JUMP AND CLEAN UP
         L     R1,MXPNBOPS         ELSE GET N' COUNT
         LA    R1,1(R1)            BUMP
         ST    R1,MXPNBOPS         RESTORE
         B     MXPOPKFN            AND JUMP TO CLEAN UP
         SPACE 2
MXPOPK00 OI    AVMBYTE1,$MKEYOPR   SET KEYWORD FLAG                   S
MXPOPK01 EQU   *                   PROCESS KEYWORD OPRNDS
         CLI   0(RA),C' '          BLANK?
         BE    MXPOPKFN            IF YES, FINISH KEYWORD PROTOTYEP
         BAL   RET,MXPNOSY7        ORDINARY SYMBOL ?                  S
         LTR   RB,RB               RB TELLS ALL
         BNZ   MXPOPKFR            ERROR IF NONZERO, JUMP OUT
         CLI   0(RC),C'='          KEYWORD ID?
         BNE   MXPOPKFQ            FLAG ERROR IF NOT '='
MXPOPK02 EQU   *
         LA    RC,1(RC)            BUMP PAST '='
         ST    RC,AVMTSCNP         SAVE ADDRESS OF DELIM
         MVC   AVMSYMBL,AWBLANK    CLEAR GLOBAL AREA
         STC   R1,AVMSYMLN         SAVE LENGHT
         BCTR  R1,0                DECR FOR EX INST
         MVI   AVMSYMBL,C'&&'      SET AMPERSAND IN GLOBAL FILED
         EX    R1,MXPNMVC2                                            A
         L     RC,MXPNKYPT         GET @ OF FIRST KEYWORD DV
         $CALL MACFND              SEARCH SYM PAR LIST
         LTR   RB,RB               SYMBOL FOUND?
         BNZ   MXPOPKFQ            FLAG ERROR IF NOT FOUND
         LR    RX,RC               MOVE BASE TO NEW ENTRY
MXPOPK03 EQU   *
         LA    RY,$LMPAROP         GET LENGTH OF ENTRY
         MH    RY,MCPARNDX         MULT BY POSIT OF OPRND IN LIST
         A     RY,MXPNLSPT         ADD BASE @ OF SYM PAR DICT
         L     RA,AVMTSCNP         GET @ OF KEYWORD VALUE
         CLI   MCPAROFL,X'FF'      PREVIOUSLY DEFINED?
         BE    MXPOPK06            SET ERROR FLAG IF SO
         CLI   0(RA),C' '          OPRND PRESENT?
         BE    MXPOPK05            IF NOT, NULL OPRND
         CLI   0(RA),C','          COMMA?
         BE    MXPOPK05            ALSO NULL IF YES
         B     MXPOPK04            ELSE PROCEED
MXPOPK06 EQU   *
         IC    R1,AVMSYMLN         GET LEN OF KEYWORD NAME
         LA    R1,1(R1)            BUMP FOR '='
         SR    RA,R1               RESTORE SCAN POINTER
         B     MXPOPKFQ            JUMP AND FLAG ERROR
MXPOPK04 EQU   *
         BAL   RET,MXPOPSCN        SCAN OPRND AND SAVE IN TEMP STORGE
         B     MXPOPRFT            JUMP TO FOOT
MXPOPK05 EQU   *
         MVI   MCPAROFL,X'FF'      NULL OPRND, SET DEFINED FLAG
         B     MXPOPRFT            JUMP TO FOOT
         SPACE
*   NEXT ROUTINE CLEANS UP DEFAULTS FOR KEYWORD OPRNDS
MXPOPKFQ EQU   *
         LA    RB,$ERUNDKW         SET BAD KEYWORD FLAG
MXPOPKFR EQU   *
         $CALL ERRTAG              FLAG STMT
MXPOPKFN EQU   *
         L     RX,MXPNKYPT         POINT AT 1ST SYM PARDV KEYWORD
         LTR   RX,RX               PRESENT?
         BZ    MXPNOPFN            FINISHED IF ZERO
         L     RY,MXPNKLPT         POINT TO 1ST KEYWORD DICT ENTRY
MXPOPKF1 EQU   *
         CLI   MCPAROFL,X'FF'      DEFINED?
         BE    MXPOPKFB            JUMP TO FOOT IF YES
         BAL   RET,MXPOPKPR        ELSE LOOK AT PROTOTYPE
MXPOPKFB EQU   *
         L     RX,MCPARNXT         GET NEXT KEYWORD OPRND
         LTR   RX,RX               FINAL OPRND?
         BZ    MXPNOPFN            FINI IF YES
         LA    RY,$LMPAROP(RY)     BUMP DICTIONARY POINTER
         B     MXPOPKF1            AND RESUME SCAN
         EJECT                                                        S
**--> INSUB: MXPOPKPR  + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+       SCAN PROTOTYPE OPRND AND SAVE IN LOCAL DICTIONARY           +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPOPKPR EQU   *
         ST    RET,MXPKPRSV        SAVE RETURN @
         MVC   MCPAROTP,MCPRATYP   COPY TYPE ATTRIB INTO DICTIONARY   J
         CLI   MCPRATYP,C'O'       NULL OPRND?
         BE    MXPPRKFT            FINI IF YES
         L     RA,MCPROPRN         GET POINTER TO PROTOTYP OPRND
         MVI   MCPARONB,1          ASSUME N' = 1 TEMPORARILY          J
         MVC   MCPAROLN,MCPROPLN   COPY LENGTH
         MVC   MCPAROPT,MCPROPRN   COPY POINTER
         MVI   MCPAROFL,X'FF'      SET DEFINED FLAG
         CLI   MCPAROTP,C'S'       SUB LIST?
         BNE   MXPPRKFT            FIISHED IF NOT
         MVI   MCPARONB,0          ZERO, SO WILL ACCUMULATE N' OK     J
         BAL   RET,MXPNSBSC        SCAN OPRND SUB LIST
MXPPRKFT EQU   *
         L     RET,MXPKPRSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXPKPRSV DS    F                   STORAGE FOR RETURN @
         EJECT                                                        S
**--> INSUB: MXPOPSCN  + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+       SCAN STD OPRND AND STORE IN LOW STORAGE                     +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPOPSCN EQU   *
         ST    RET,MXPPSCSV        SAVE RETURN @
         ST    RA,AVMTSCNP         SAVE SCAN POINTER
         NI    AVMBYTE1,X'FF'-$MSBLIST  TURN OFF SUBLIST FLAG
         $CALL MCSCOP              SCAN OPRND
         LTR   RB,RB               OKAY?
         BNZ   MXPOPKFR            AND LEAVE OPRNDS
         STC   RC,MCPAROLN         PUT OPRND LEN IN DICT
         STC   RD,MCPAROTP         STORE TYPE
         MVI   MCPAROFL,X'FF'      SET OPRND FLAG
         LA    RC,3+1(,RC)         ROUND + 1 BYTE FOR DELIMITER AFTER J
         SRL   RC,2                TRUNCATE
         SLL   RC,2                BY SHIFITING
         $MALLOCL  RB,RC           GET STORAGE
         IC    RC,MCPAROLN         GET ORIGINAL LENGTH
*              USE LENGTH RATHER THAN L-1: COPY DELIMITER AFTER ARG,  J
*              HELPS MEXPND SCAN RIGHT FOR &I SETA &ARG OPERATION.    J
         LR    R0,RA               COPY SCAN POINTER
         L     RA,AVMTSCNP         GET ORIGINAL POINTER
         ST    R0,AVMTSCNP         SAVE SCAN POINTER
         EX    RC,MXPNMVOP         MOVE OPRND TO LOW STORAGE
         ST    RB,MCPAROPT         SAVE OPRND @ IN DICTIONARY
         CLI   MCPAROTP,C'S'       SUB LIST?
         BE    MXPOPSBS            PROCESS SUBLIST IF YES
         MVI   MCPARONB,1          ELSE SET OPRND COUNT TO 1
         B     MXPOPSCF
MXPOPSBS EQU   *
         LR    RA,RB               SCAN PNTR TO OPRND
         BAL   RET,MXPNSBSC        SCAN SUB OPRNDS
MXPOPSCF EQU   *
         L     RA,AVMTSCNP         RESTORE SCAN POINTER
         L     RET,MXPPSCSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXPPSCSV DS    F                   STORAGE FOR RETURN @
         EJECT                                                        S
**--> INSUB: MXPNSBSC  + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+     SCAN OPRND SUBLIST, CREATE ENTRY IN DICTIONARY                +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPNSBSC EQU   *
         ST    RET,MXPNSBSV        SAVE RETURN @
         USING MCPARSUB,RW         NOTE USING ON SUBOPRND ENTRY
         LA    RA,1(RA)            BUMP PAAST '('
         OI    AVMBYTE1,$MSBLIST   SET SUBLIST FLAG
MXPNSB01 EQU   *
         LA    RB,$LMPARSB         GET LENGTH OF SUB ENTRY
         $MALLOCL  RW,RB           GET STORAGE
         MVC   0($LMPARSB,RW),AWZEROS  CLEAR ENTRY
         ST    RA,MCPARSPT         SAVE POINTER TO SUB ENTRY STRNG
         $CALL MCSCOP              SCAN SUB OPRND
         LTR   RB,RB               ERROR?
         BZ    MXPNSB02            PROCEED IF NOT
         S     RA,MCPAROPT         GET OFFSET OF POINTER
         LR    RE,RA               COPY TEMPORARILY
         IC    RA,MCPAROLN         GET LENGTHOF OPRND
         S     RA,AVMTSCNP         SUBTRACT CURRENT PNTR
         LPR   RA,RA               GET POS VALUE
         AR    RA,RE               ADD OFFSET OF ERROR
         B     MXPOPKFR            FORGET ABOUT REST OF OPRNDS
MXPNSB02 EQU   *
         CLI   MCPARONB,X'00'      1ST SUB OPRND?
         BNE   MXPNSB03
         STC   RD,MCPAROTP         MAIN OP TYPE = 1ST SUB TYPE
         ST    RW,MCPRSBPT         SAVE PNTR TO SUB ENTRIES
MXPNSB03 EQU   *
         STC   RC,MCPARSLN         SAVE LEN IN DV
         STC   RD,MCPARSTP         SAVE TYPE
         IC    RD,MCPARONB         GET SUB OPRND COUNT
         LA    RD,1(RD)            BUMP BY ONE
         STC   RD,MCPARONB         RESOTRE
         CLI   0(RA),C')'          END OF LIST?
         LA    RA,1(RA)            BUMP PAST DELIM
         BNE   MXPNSB01            RESUME SCAN IF NO ')'
         L     RET,MXPNSBSV        GET RETURN @
         BR    RET                 AND RETURN
MXPNSBSV DS    F                   SPACE FOR RETURN @
         DROP  RW
         EJECT                                                        S
**--> INSUB: MXPNOSYM       DETERMINS IF STRING IS ORDINARY  + + + + +S
*+           SYMBOL OF EITHER LENGTH 7 OR 8 (MAX)                    +S
*+           MXPNOSY7:  SETS RB = 7                                  +S
*+                                                                   +S
*+             ENTRY CONDITIONS:                                     +S
*+       RA = 1ST CHAR OF SYMBOL                                     +S
*+       RB = ALLOWABLE LENGTH (7 OR 8)                              +S
*+                                                                   +S
*+             EXIT CONDITIONS:                                      +S
*+       RA = SAME AS ENTRY                                          +S
*+       RB = ERROR INDICATION  (0 --> OK)                           +S
*+       RC = @ OF DELIM PAST SYMBOL                                 +S
*+       R1 = LENGTH OF SYMBOL                                       +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPNOSY7 LA    RB,7                SET MAX LENGTH OF KEYWORD          S
MXPNOSYM EQU   *
         CLI   0(RA),C'0'          FIRST CHAR = DIGIT?
         BNL   MXPSYMR1            ERROR IF YES
         EX    RB,MXPNOSSC         SCAN SYMBOL
         BZ    MXPSYMR2            ZERO MEANS TOO LONG
         LR    RC,R1               ELSE MOVE DELIM TO RC
         SR    R1,RA               GET LENGTH IN R1
         BZ    MXPSYMR2            NO SYMBOL IF ZERO LENGTH
         SR    RB,RB               CLAR RB FOR RETURN
         BR    RET
MXPSYMR1 EQU   *
MXPSYMR2 EQU   *
         LA    RB,$ERINVSY         SET BAD SYMBOL FALG
         BR    RET                 AND RETURN
MXPNOSSC TRT   0($,RA),AWTSYMT     DUMMY FOR SCAN
         EJECT                                                        S
MXPOPRFT EQU   *
         CLI   0(RA),C' '          BLANK?
         BE    MXPOPR03            RESUME SCAN IF YES
         LA    RA,1(RA)            ELSE BUMP PAST DELIM
         CLI   0(RA),C' '          BLANK AFTER ','?
         BNE   MXPOPR03            RESUME SCAN IF NOT
         SPACE 1
         L     RC,AVRSBPT          SET BASE OF RSBLOCK
         USING RSBLOCK,RC          NOTE USING ON RSBLOCK
*              POSSIBLE NON-STND CONT CARD
         CLI   RSBNUM,1            ONLY 1 CARD?
         BE    MXPOPR03            RESUME SCAN IF YES
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    RA,RB               POINTING AT WHICH CARD?
         BNH   MXPOPC#2            PROCESS 2ND CARD IF LOW
         CLI   RSBNUM,3            TWO CONT CARDS?
         BNE   MXPOPR03            RESUME SCAN IF NOT
         LA    RB,RSOLC(RB)        POINT TO 1ST BYTE, 3RD CARD
         CR    RA,RB               WHERE IS SCAN POINTER?
         BH    MXPOPC#3            CHECK FOR 4TH CARD
MXPOPC#2 EQU   *
         LR    RA,RB               MOVE SCAN POINTER TO CONT CARD
         CLI   0(RA),C' '          CONT CARD IS NON BLANK?
         BNE   MXPOPR03            PROCEED IF YES
         LA    RB,$ERVILCH         SET BAD CONT CARD ERROR FLAG
         B     MXPOPKFR            AND JUMP TO FOOT
         SPACE 2
MXPOPC#3 EQU   *
         CLI   AVMBYTE5,$ERCONTX  MORE THAN TREE CARDS?
         BNE   MXPOPR03            PROCEED WITH SCAN IF NOT
         $CALL MXMVSR              ELSE MOVE CARDS TO HIGH CORE
         LTR   RB,RB               CORE EXCEEDED?
         BNZ   MXPNDOVR            JUMP OUT IF YES
         BAL   RET,MXPNRDR         ELSE READ CONT CARDS
         L     RC,AVRSBPT          ESTAB BASE ON RSBLOCK
         LA    RA,RSBSOURC         POINT TO STMT START
         CLC   0(15,RA),AWBLANK    COLS 1-15 BLANK?
         BE    MXPOPC#4            OKAY IF YES
         LA    RB,$ERCONT          ELSE SET ERROR FLAG
         $CALL ERRTAG              AND FLAG STMT
MXPOPC#4 EQU   *
         LA    RA,15(RA)           POINT TO COL 16
         B     MXPOPR03            AND RESUME SCAN
         EJECT                                                        S
**--> INSUB: MXPNRDR   + + + + + + + + + + + + + + + + + + + + + + + +S
*+                                                                   +S
*+             CARD READER FOR ROUTINE MEXPND                        +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXPNRDR  EQU   *                                                      S
         ST    RET,MXPNRDSV        SAVE RETURN @
         MVC   MXPGENCD,AVGEN1CD   COPY AVGEN1CD
         MVC   AVGEN1CD,AVGEN2CD   MAKE PNTRS EQUAL FOR INCARD
         $CALL INCARD              READ NEXT STMT
         OI    AVRSBLOC+1,$RSBNPNN SET NO PROCESS FLAG                S
         SR    RE,RE              CLEAR RE
         IC    RE,AVRSBLOC        GET LENG-1 OF STMT
         LA    RD,RSB$L           GET LENGTH OF STND PART
         SR    RE,RD              SUBTRACT FROM OVERALL LENGTH
         STC   RE,AVRSBLOC        RESTORE REDUCED LENGTH
         MVC   AVGEN1CD,MXPGENCD   RESTORE AVGEN1CD POINTER
         STC   RB,AVMBYTE5         SAVE ERROR FLAG
         CLI   AVMBYTE5,$ERCONTX   MORE THAN THREE CARDS?
         BE    MXPNRDRT            PROCEED IF YES
         LTR   RB,RB               ELSE TEST FOR ERROR
         BZ    MXPNRDRT            PROCEED IF NONE
         $CALL ERRTAG              ELSE FLAG STMT
         TM    AVTAGS2,$INEND2     END OF FILE ERROR?
         BO    MXPNDERT            JUMP OUT IF YES
MXPNRDRT EQU   *
         L     RET,MXPNRDSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXPNRDSV DS    F                   SPACE FOR RETURN @
MXPGENCD DS    F                   TEMP STORAGE FOR AVGEN1CD
         EJECT                                                        S
*        NORMAL EXIT CODE                                             S
         SPACE 1                                                      S
MXPNOPFN EQU   *
         $CALL MXMVSR              MOVE SOURCE TO HIGH AREA
         CLI   AVMBYTE5,$ERCONTX   4 CARDS?
         BNE   MXPNOPFP            PROCEED IF NOT
         BAL   RET,MXPNRDR         ELSE READ NEXT CARD
         L     RC,AVRSBPT          SET BASE FOR RSBSOURC
         OI    RSBFLAG,$RSBNPNN    SET NO ACTION FLAG
         B     MXPNOPFN            AND PTINT CARDS
         DROP  RC
MXPNOPFP EQU   *
         CLC   AVMACNST,AWF1       WAS THIS ACTUALLY OUTER MACRO CL JRM
         BNE   *+10                NO, SO SKIP RESET OF PTR         JRM
         MVC   MEXGN2OV,AVGEN2CD   THUS SAVE CURRENT PTR FOR OVRFL  JRM
         LTR   RB,RB               OVERFLOW?
         BZ    MXPNLOCD            PROCEED IF NOT
         SPACE 3                                                      S
*        OVERFLOW EXIT                                                S
         SPACE 1                                                      S
MXPNDOVR EQU   *
         MVC   AVGEN1CD,AVADDHIH   SET PNTR TO OVRFLW MESSAGE
         MVC   AVGEN2CD,MEXGN2OV   RESET OVERFLO PTR, SHOW @ EITHER OF #
               AS218 MESSAGE OR OF OUTER MACRO CALL.                JRM
         B     MXNORML                                                A
         SPACE 1                                                      A
         SPACE
MEXGN2OV DC    F'0'                @ LAST STMT, IF OVERFL**MOVE***  JRM
MXPOVRMS DC    C'218 STORAGE EXCEEDED BY FOLLOWING MACRO EXPANSION'
         DC    AL1(L'MXPOVRMS-1,$RSBNPNN+$RSBMERR,$,$)
         SPACE
         DS    0H                                                     A
MEXPMNES EQU   *                   ERROR EXIT MNEST LIMIT             A
         LA    RB,$EREXMAC                                            A
         L     RA,AVRSBPT                                             A
         LA    RA,RSB$L+10(RA)     POINT TO OPCODE                    A
MXPNDERT DS    0H
         $CALL ERRTAG
         $CALL MXMVSR              MOVE SOURCE TO HIGH AREA IF INNER
         LTR   RB,RB               OVERFLOW?
         BNZ   MXPNDOVR            JUMPP AND FLAG IF YES
*                                                                     S
*        NORMAL RETURN SEQUENCE FOR MEXPND                            S
*         -- ALSO SET PTR TO RELEASE LOW STORAGE AREA                 S
*                                                                     S
MXNORML  EQU   *                   NORMAL RETURN                      A
         MVC   AVADDLOW,MXADDLOW   RESTOR PTR                         A
         SR    RB,RB               SHOW NORMAL RETURN ALWAYS          J
         $RETURN RGS=(R14-R6)                                         A
         SPACE 4
*   NEXT SECTION ALLOCATES AND INITIALIZES STORAGE FORLOCAL SET SYMBOL*
*    DICTIONARY
MXPNLOCD EQU   *
         SPACE
         AIF   (&$DEBUG).MXPNLDB
         L     RA,MXPNLSPT         GET PNTR TO SYM PAR DICT
         L     R1,AVGEN2CD         GET PNTR TO HIGH AREA
         L     R2,AVADDHIH         GET PNTR TO BEGINNING OF HIGH AREA
         XSNAP LABEL='***SYM PAR DICT INITIALIZED***',                 X
               IF=(AVMSNBY2,O,$MSNP11,TM),                             X
               STORAGE=(*0(R1),*0(R2),*0(R13),*124(R13),*0(RA),*128(RA)X
               )
.MXPNLDB ANOP
         SPACE
         AP    AVMSYSDX,AWP1       BUMP SYSNDX COUNTER
         ZAP   MXPSYSDX,AVMSYSDX   COPY INTO LOCAL AREA
         L     RW,MXPNMCLB         GET POINTER TO MACLIB
         USING MACLIB,RW           SET USING
         MVC   MXPNCDPT,MCCODLNK  SAVE PNTR TO CODE
         L     R1,MCLOCDLN         GET LEN OF LOCAL DICTIONARY
         $MALLOCL  R2,R1           GET CORE FOR SET SYMBOL DICT
         ST    R2,MXPNLDBS         SAVE BASE IN LOCAL AREA
*  INITIALIZE DICTIONARY TO ZEROS
         LR    R0,R1               SAVE COMPLETE LENGTH FOR LATER     J
         BCTR  R1,0                DECR COUNT
         EX    R1,MXPNMVZR         CLEAR LENGTH MOD 256
         SRA   R1,8                SHIFT TO GET # 256 BYTE BLOCKS LEFT
         BNP   MXPNLOC2            SKIP IF NO MORE TO DO
         N     R0,AWFXFF      GET LAST BYTE OF LENGTH                 J
         AR    R2,R0               GET @ FIRST BYTE TO ZERO           J
         SPACE 1
         MVC   0(256,R2),AWZEROS   CLEAR 256 BYTES AT A TIME
         LA    R2,256(,R2)         INCREMENT TO NEXT
         BCT   R1,*-10             LOOP, CLEARING UNTIL DONE
         SPACE
MXPNLOC2 EQU   *
         L     R2,MXPNLDBS         GET BASE OF SET SYMB LOCAL DICT
         MVC   0(4,R2),AVMMACTR    SET ACTR LIMIT
         TM    AVMBYTE4,$MGENSTP   ARE MACROS KILLED ?                S
         BO    MXNORML             IF YES, RETURN                     S
         MVC   MXPNCRCD,MXPNCDPT   SET PTR TO 1ST INSTR               S
         SPACE 2                                                      S
*        THIS NEXT SECTION OF CODE SETS CALLING                       S
*        ARGUMENTS AND CALLS MXINST TO                                S
*        INTERPRET DICTIONARY ONE-OPS AND                             S
*        CREATE GENERATED CODE -----                                  S
*        THEN USE RETURNED CODE TO BRANCH ON INDEX                    S
*        FOR FURTHER PROCESSING                                       S
         SPACE 2                                                      S
MXPNCALL EQU   *                                                      S
         LR    RC,RZ               SET CALLING CONVENTION             S
         XCALL MXINST              CALL ROUTINE                       A
         B     *+4(RB)             BRANCH ON RETURNED INDEX           S
         B     MXPNDX0             RB=0 MEND,MEXIT                    A
         B     MEXPND01            RB=4 INNER MACRO CALL              A
         B     MXNORML             RB=8   KILL THIS NEST              S
         B     MXKILMAC            RB=12  KILL ALL MACROS             S
         B     MXPNDOVR            RB=16  STORAGE OVERFLOW            S
         SPACE 2                                                      S
*        SET FLAG TO KILL ALL MACROS                                  S
*                                                                     S
MXKILMAC EQU   *                   KILL ALL MACROS                    A
         OI    AVMBYTE4,$MGENSTP   LILL                               A
         B     MXNORML                                                A
*                                                                     S
*        BACK UP NEST DEPTH COUNTER AND CALL MXINST                   S
*        AGAIN IF NOT DONE WITH NEST                                  S
*                                                                     S
MXPNDX0  EQU   *                                                      S
         ST    RZ,AVADDLOW         STORE CURRENT RZ                   S
         L     R0,AVMACNST         GET NEST LEVEL                     S
         BCTR  R0,0                DECR BY 1                          S
         ST    R0,AVMACNST         STORE NEW DEPTH LEVEL              S
         LTR   R0,R0               LEVEL = 0 ?                        S
         L     RZ,MXPNLINK         GET NEXT LINK                      S
         BZ    MXNORML             NO MORE, RETURN                    S
         L     RE,MXPNCRCD         GET @ OF LAST INSTR PROC (CALL)    S
         USING MCOPQUAD,RE         NOTE ONE-OP PTR                    S
         MVC   MXPNCRCD,MCQUDNXT   GET @ OF NEXT INSTR (AFTER CALL)   S
         DROP  RE                  REMOVE USING                       S
         B     MXPNCALL            CALL MXINST TO GENERATE CODE       S
         SPACE 2                                                      S
*        DEFINED CONSTANTS/STORAGE & DUMMY INSTRS                     S
MXADDLOW DS    F                   FULL WORD TO SAVE AVADDLOW         S
MXPNMVZR MVC   0($,R2),AWZEROS     DUMMY INSTR                        S
MXPNMVC2 MVC   AVMSYMBL+1($),0(RA) DUMMY INSTR                        S
MXPNMVC  MVC   AVMSYMBL($),0(RA)   DUMMY INSTR                        S
         LTORG                                                        S
         DROP  RW,RX,RY,RZ                                            S
         TITLE 'MXINST -- INTERPRETATION PHASE'                       S
**--> CSECT: MXINST       EXECUTE INSTRUCTIONS IN MACRO DEF          *S
*.             ENTRY CONDITIONS:                                     *S
*.       RC = @ MXPNTSAV                                             *S
*.             EXIT CONDITIONS:                                      *S
*.       RB = 0                    MEND OR MEXIT FOUND               *S
*.            4                    INNER MACRO CALL                  *S
*.            8                    KILL THIS MACRO NEST              *S
*.           12                    KILL ALL MACROS                   *S
*.           16                    STORAGE OVERFLOW                  *S
*.                                                                   *S
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **S
         SPACE 2                                                      S
MXINST   CSECT                                                        A
         $SAVE RGS=(R14-R6),BR=13,SA=*                                A
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING              S
         USING MCOPQUAD,RW         NOTE USING ON ONE-OP
         MVC   AVRSBLOC(RSB$L),AWZEROS   ZERO STND PART OF RSBLOC
         MVC   AVRSBLOC+4($LMSRCMX),AWBLANK   BLANK REMAINDER
         LR    RZ,RC                                                  A
         USING MXPNTSAV,RZ                                            A
         L     RW,MXPNCRCD                                            A
         XSNAP LABEL='MXINST INIT',STORAGE=(*MXPNTSAV,*MXPNLSPT+4,*AVADX
               DLOW,*AVWXEND),IF=(AVTAGSM,O,AJOMACRG,TM)              S
         $SPIE MXPNINJE,((8,9)),ACTION=CR,CE=MXPNZDIV  PRODUCTION TYPE
         ST    R1,AVMXSPIE         SAVE PREV INT BLOCK @
         B     MXPNIN01            SKIP, BEGIN AT 1ST ONE-OP
         SPACE
MXPNEXBS DS    0H                  ESTAB BASE FOR INDEX TABLE
MXPNINJE EQU   *                   ENTER HERE TO FLAG ERROR AND GO ON
*              TO NEXT ONE OP.  EXPECTS RB = ERROR CODE.
         BAL   R1,MXINERRM         GENERATE ERROR MESG                A
         SPACE 1
MXPNINJP EQU   *                   COME HERE FOR EACH NON-BRANCH STMT
*                                  AFTER VERY FIRST ONE.
         L     RW,MXPNCRCD         RESTORE BASE TO 1ST ONE-OP
         L     RW,MCQUDNXT         GET @ NEXT SEQUENTIAL INSTRUCTION
         SPACE 1
MXPNINJQ EQU   *                   COME HERE FOR AGO/GOOD AIF. RW= @
         AIF   (NOT &$MACOPC).MXINSTA  SKIP IF NOT OPEN CODE          S
*        ALLOW ONLY ONE STATEMENT DONE IF IN OPEN CODE                S
         L     RX,MXPNMCLB         LOAD @ OF MACLIB ENRTY             A
         USING MACLIB,RX           NOTE USING ON MACLIB               S
         TM    MCLBFLG2,$MCOCFL1   IN OPEN CODE ?                     S
         BO    MXMEND              RETURN IF YES                      S
         DROP  RX                                                     S
.MXINSTA ANOP                                                         S
         SPACE
         AIF   (&$DEBUG).MXPNNDB
         L     R1,MXPNCRCD         GET @ OF CURRENT INST
         L     R2,AVMCHSTR         GET POINTER TO CHAR WORK AREA
         XSNAP LABEL='***INSTRUCTION EXECUTED***',                     X
               IF=(AVMSNBY2,O,$MSNP11,TM),                             X
               STORAGE=(*0(R1),*128(R1),*0(R2),*128(R2))
.MXPNNDB ANOP
         SPACE
         L     R1,AVMMSTMG         GET GLOBAL LIMIT ON ISNTRUCTIONS
         S     R1,AWF1             DECR COUNT
         ST    R1,AVMMSTMG         RESTORE
         BNP   MXMENDER            GO TO FLAG ERROR AND STOP
         SPACE
MXPNIN01 EQU   *
         MVC   MXPCHRBF,AVMCHSTR   INIT BUFFER POINTER
         ST    RW,MXPNCRCD         UPDATE CURRENT INST POINTER
*        EACH STMT CONSISTS OF ONE-OP PREFIX(PTR,STMT#,STC),          A
*        FOLLOWED BY 0-MORE REGULAR ONE-OPS(MXOPQUAD DSECT)L          A
*        FOR ANOP,MEND,MEXIT,$BSERR01(ERROR), THE OPERATOR            A
*        CODE IS IN PREFIX (MCQS1FLG). FOR OTHERS, IT =0              A
         CLI   MCQS1FLG,0          WAS IT NORMAL PREFIX WITH ONE-OPS  A
         BE    MXPNIN03            YES SKIP SPECIAL CODE              A
         IC    R2,MCQS1FLG         GET OPERATOR TYPE                  A
         B     MXPNPREF            GO TO PREFIX ONLY CODE             A
MXPNIN03 SH    RW,=AL2($LMCQUAD-$LMCOPL1) BACK UP,SO WILL BUMP RIGHT  A
*        FALL THRU, START DOING ONE-OPS                               A
         EJECT
*   NEXT SECTION PROCESSES A SINGLE ONE-OP
MXPNONJP EQU   *
         LA    RW,$LMCQUAD(RW)     BUMP PAST CURRENT ONE-OP
         SR    RA,RA               CLEAR FOR INSERTS****************JRM
         MVI   AVMBYTE2,X'00'      CLEAR FLAG BYTE FOR TYPE USE       A
         IC    RA,MCARG1DX         GET INDEX OF 1ST ARG
         L     RB,MCARG1LC         GET LOC OF 1ST ARG
         IC    R2,MCBOPRTR         GET OPCODE
MXPNPREF EQU   *                   ENTER HERE FOR PREFIX ONLY ONES    A
         N     R2,=X'0000007E'     MASK OUT CHAR REL BIT, SPECIAL PRINA
         LH    R1,MXPNINDX(R2)     GET OFFSET
         XSNAP LABEL='MXPNONJP',STORAGE=(*0(RW),*16(RW)),              X
               IF=(AVTAGSM,O,AJOMACRH,TM)
         B     MXPNEXBS(R1)        JUMP TO ROUTINE
               SPACE
MXPNINDX $AL2  MXPNEXBS,(MXFIN,MXPLUS,MXMIN,MXMULT,MXDIV,MXOR,MXAND,MXN#
               OT,MXNE,MXGE,MXLE,MXLT,MXEQ,MXGT,MXCAT,MXAGO,MXAIF,MXSET#
               A,MXSETB,MXSETC,MXINV,MXINV,MXSBSCRP,MXSBST,MXSYSL,MXINV#
               ,MXPRNT,MXMEXIT,MXMEND,MXANOP,MXERRMS,MXINMAC,MXMVSTMT)
         SPACE
*   ENTRY POINT FOR SPIE ACTION
MXPNZDIV EQU   *
         USING MXPNZDIV,REP
         LA    RB,$ER#ZDIV         SET ERROR FLAG
         BR    RET                 RETURN NOW, RB SET
         AIF   (&$DEBUG).MACQQ04   SKIP IF NO DEBUG
         ORG   *-2                 GET BACK OVER NON-DEBUG CODE
         CLI   3(R1),8             FIXED POINT OVERFLOW?
         BCR   E,RET               RETURN IF YES FOR MORE SPIE ACTION
         CLI   3(R1),9             ZERO DIVIDE?
         BCR   E,RET               RETURN IF YES FOR MORE SPIE ACTION
         L     RA,AVGEN2CD         ELSE POINT TO LOW END OF HIGH CORE
         L     RB,AVADDHIH         POINT TO HIGH END OF HIGH CORE
         L     RC,AVMACLIB         POINT TO START OF LOW CORE
         L     RD,AVADDLOW         POINT TO HIGH END OF LOW CORE
         XSNAP LABEL='*** INTERRUPT IN MACRO EXPANSION ***',           X
               STORAGE=(*0(R1),*20(R1),*0(RA),*0(RB),*0(RC),*0(RD),*AVA#
               DDLOW,*AVWXEND,*0(R13),*130(R13))
         DC    X'00FF'             FORCE INTERRUPT
.MACQQ04 ANOP
         DROP  REP
         SPACE
*                                                                     A
MXPLUS   EQU   *
MXMIN    EQU   *
*        ARITHMETIC OPERATIONS HERE                                   A
MXMULT   EQU   *
MXDIV    EQU   *
         BAL   RET,MXARITH         CVRT 1ST ARG TO ARITH VLUE
         ST    RC,MXARG1           SAVE TEMPORRAILY
         IC    RA,MCARG2DX         GET 2ND ARG TYPE
         L     RB,MCARG2LC         GET LOCATION OF 2ND ARG
         BAL   RET,MXARITH         GET ARITH VALUE
         LR    RD,RC               COPY INTO RD
         L     RB,MXARG1           RELOAD 1ST ARGUMENT**************JRM
         SRDA  RB,32               MOVE OVER TO RC, WITH SIGN RIGHT
         IC    RA,MCBOPRTR         GET OPCODE
         EX    0,MXARITOP-2(RA)    EXECUTE CORRECT OPERATION
         ST    RC,MCRESULT         PUT RESULT IN ONE-OP
         MVI   MCRSLTYP,$BSIMMA    SET TYPE
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE 1
MXARITOP DS    0H                  TABLE OF INSTRS TO BE EXECUTED
         AR    RC,RD               ADD
         SR    RC,RD               SUBTRACT
         MR    RB,RD               MULTIPLY
         DR    RB,RD               DIVIDE
         EJECT                                                        A
* LOGICAL OPERATORS                                                   A
*                                                                     A
MXOR     EQU   *
MXAND    EQU   *
         BAL   RET,MXBOOL          GET 1ST ARG VALUE
         ST    RC,MXARG1           SAVE TEMPORARILY
         IC    RA,MCARG2DX         GET 2ND ARG TYPE
         L     RB,MCARG2LC         GET 2ND ARG LOC'N
         BAL   RET,MXBOOL          GET 2ND ARG VALUE
         L     RD,MXARG1           RESTORE 1ST ARG VALUE
         CLI   MCBOPRTR,$BSOR      OR OPRND?
         BE    MXOR01              JUMP TO OR IF YES
         NR    RC,RD               ELSE CARRY OUT AND OPERATION
         B     MXOR02              JUMP TO FOOT
MXOR01   EQU   *
         OR    RC,RD               CARRY OUT OR OPERATION
MXOR02   EQU   *
         ST    RC,MCRESULT         STORE RESULT IN ONE-OP
         MVI   MCRSLTYP,$BSIMMB    SET TYPE
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE
MXNOT    EQU   *
         BAL   RET,MXBOOL          CONVERT TO BOOL VALUE
         X     RC,AWF1             DO EXCLUSINVE OPERATION
         B     MXOR02              SAVE RESULT IN ONE-OP
         EJECT
MXNE     EQU   *
MXGE     EQU   *
MXLE     EQU   *
MXLT     EQU   *
MXEQ     EQU   *
MXGT     EQU   *
         LA    R1,$BSNE            GET $BSNE VALUE IN R1
         SRL   R2,1                DIVIDE OPCADE BU 2                 A
         IC    R2,MXRELOPS-($BSNE/2)(R2)                              A
         STC   R2,MXRELCH2+1       SAVE IT                            A
         MVI   MCRSLTYP,$BSIMMB    SET RESULT TYPE
         MVC   MCRESULT,AWZEROS    ASSUME FALSE FOR START
         TM    MCBOPRTR,$BSRLCHR   CHAR RELATION?
         BO    MXRELCHR            PROCESS CHAR REL IF YES
MXRELAR  EQU   *                   ELSE PROCESS ARITH RELATION
         BAL   RET,MXARITH         GET 1ST VALUE
         ST    RC,MXARG1           STORE TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET ARG2 LOCATION
         BAL   RET,MXARITH         GET ARITH VALUE
         L     RB,MXARG1           GET 1ST ARG
         CR    RB,RC               COMPARE OPRNDS
         B     MXRELCH2            FALL THROUGH MEANS FALSE           A
MXRLATRU EQU   *                   TARGET FOR TRUE CONDITION
         MVI   MCRESULT+3,X'01'    SET RESULT TO TRUE
         B     MXPNONJP            GET NEXT ONE-OP
MXRELCHR EQU   *
         BAL   RET,MXCHAR          GET ARG1 CHAR VLAUE
         STM   RB,RC,MXARG1LN      SAVE LEN AND TYPE TEMP
         IC    RA,MCARG2DX         GET ARG2 TYPE
*                                                                     A
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXCHAR          GET CHAR VALUE
         LR    RD,RB               MOVE 2ND ARG LEN TO RD
         LR    RE,RC               MOVE 2ND ARG LOC TO RE
         LM    RB,RC,MXARG1LN      RESTORE LEN AND TYPE
         CR    RB,RD               COMPARE LENGTHS
         BNE   MXRELCH2            UNEQUAL ==> COMPARE LENGHTS INSTD
         LTR   RB,RB               ZERO LENGTH?
         BZ    MXRELCH2            IF YES USE LEN COMPARE
MXRELCH1 EQU   *
         BCTR  RB,0                DECR LEN FOR EX INST
         EX    RB,MXCHCOMP         COMPARE STRINGS
MXRELCH2 BC    $,MXRLATRU                                             A
         B     MXPNONJP            FALL THRU MEANS FALSE
MXCHCOMP CLC   0($,RC),0(RE)       DUMMY FOR CHAR COMPARE
MXRELOPS DC    XL6'70B0D0408020'   MASKS FOR DIFFERENT RELATIONS
         EJECT
*                                                                     A
*        CONCATENATION PROCESSED                                      A
MXCAT    EQU   *
         MVI   MCRSLTYP,$BSTRING   SET TYPE TO CHAR
         BAL   RET,MXCHAR          GET CHAR VALUE OF ARG1
         STM   RB,RC,MXARG1LN      SAVE LEN & LOC TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         SPACE 1                                                      A
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXCHAR          GET CHAR VALUE OF ARG2
         LM    RD,RE,MXARG1LN      GET ARGU VALUE
         LR    RA,RB               GET LEN OF ARG2
         AR    RA,RD               GET TOTAL LEN OF ARGS
         LA    R1,AVMWRK1          GET @ OF WORK AREA
         S     RD,AWF1             DECR LEN OF ARG1 FOR EX INST
         BM    MXCAT02             IF ZERO LEN, JUMP
         EX    RD,MXMVWRK1         MOVE ARGU TO WORKAREA
         LA    RD,1(RD)            RESTORE ARG1 LEN
         AR    R1,RD               BUMP WORKAREA POINTER
         C     RA,AWFXFF           COMPARE TO MAX LENGTH
         BNH   MXCAT02             IF NOT HIGH, OKAY
         LR    RB,RA               ELSE MOVE TOTAL TO RB
         LA    RA,255              GET MAXIMUM ALLOWED LENGTH
         SR    RB,RA               GET ALLOWABLE REMADR IN RB
MXCAT02  EQU   *
         S     RB,AWF1             DECR BY 1 FOR EX INST
         BM    MXCAT03             IF ZERO LEN ON ARG2, JUMP
         LR    RE,RC               MOE PNTR TO FOR EX
         EX    RB,MXMVWRK1         ADD ARG2 TO STRING
MXCAT03  EQU   *
         LA    RE,AVMWRK1          GET STRING @ IN RE
         S     RA,AWF1             DECR FOR EX INST
         BM    MXCAT04             IF ZERO JUMP
         L     R1,MXPCHRBF         GET CURRENT @ OF STRING BUFFER
         AR    R1,RA               GET FINAL @
         C     R1,AVMCHLIM         EXCEED BUFFER?
         BH    MXCAT05             IF HIGH, JUMP FOR ERROR
         SR    R1,RA              RESTORE POINTER
         EX    RA,MXMVWRK1         MOVE TO BUFFER
         ST    R1,MCRESULT         SAVE @ IN ONE-OP
MXCAT04  EQU   *
         LA    RA,1(,RA)           BUMP TO RESTORE CAT STRING LEN
         STC   RA,MCRESULT         SAVE LEN IN ONE-OP
         AR    R1,RA               GET FINAL DELIM @
         ST R1,MXPCHRBF            STORE @ IN TABLE
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE
MXMVWRK1 MVC   0($,R1),0(RE)       MOVE ARG TO WORK AREA BUFFERER
         SPACE
MXCAT05  EQU   *
         LA    RB,$ER#EXBF         SET EXCEEDED BUFFER FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
         EJECT
*                                                                     A
*        AGO AMD AIF CODE PROCESSED                                   A
*                                                                     A
MXAIF    EQU   *
         BAL   RET,MXBOOL          GET BOOL VALUE
         LTR   RC,RC               TRUE OR FLSE?
         BZ    MXPNINJP            NO JUMP, CONTINUE SEQUENTAILLY
         AIF   (NOT &$MACOPC).MXINSTB  SKIP IF NOT OPEN CODE          S
         OI    AVMTAG00,AVMOPGO    SHOW AIF WAS SUCCESSFUL            S
.MXINSTB ANOP                                                         S
*              FALL THRU, PROCESS LIKE AGO.
         SPACE
MXAGO    EQU   *
         L     R1,MXPNLDBS         GET SET SYMB DICT BASE(LOCAL)
         L     R0,0(R1)            GET ACTR ALUE
         BCT   R0,MXAGO01          DECR COUNT
         LA    RB,$ER#ACTR         SET ACTR ERROR FLAG IF FALL THRU
         B     MXINKIL1            GENERAL ERROR MSG & SET FLAG       A
MXAGO01  EQU   *
         ST    R0,0(R1)            RESTORE DECREMENTED ACTR
         L     RW,MCARG2LC         GET @ OF BRANCH INTO RW, WHERE EXPCT
         B     MXPNINJQ            GO TO HAVE BRANCH DONE
         SPACE
MXSETA   EQU   *
MXSETB   EQU   *
MXSETC   EQU   *
         BAL   RET,MXADDR          GET @ OF TARGET
         ST    RC,MXARG1           SAVE TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET 2ND RG LOC
         CLI   MCBOPRTR,$BSETB     ARITH, BOOL OR CHAR?
         BH    MXSETC01            CHAR IF HIGH
         BE    MXSETB01            BOOL IF EQUAL
         BAL   RET,MXARITH         ARITH IF FALL THRU
         B     MXSETB02            USE BOOL CODE TO STORE
         SPACE 1
MXSETB01 EQU   *
         BAL   RET,MXBOOL          GET BOOL VALUE
MXSETB02 EQU   *
         L     R1,MXARG1           GET TARGET @
         ST    RC,0(R1)            STORE RESULT
         B     MXPNINJP            GET NEXT INST
         SPACE 1
MXSETC01 EQU   *
         BAL   RET,MXCHAR          GET CHAR VALUE
         L     R1,MXARG1           GET TARGET @
*************** POSSIBLE CHANGE WITH ASM H OR VS *********************S
         C     RB,=F'8'            LEN > 8
         BNH   MXSETC02            PROCEED IF NOT
         LA    RB,8                ELSE SET LEN TO MAX
MXSETC02 EQU   *
         ST    RB,0(R1)            SAVE LENGTH
         S     RB,AWF1             DECR FOR EX
         BM    MXPNINJP            IF ZERO, GET NEXT INST
         EX    RB,MXPMVSET         MOVE STRING TO SET SYMBOL
         B     MXPNINJP            GET NEXT INST
         SPACE
MXPMVSET MVC   4($,R1),0(RC)       DUMMY TO MOVE STRING
         EJECT
*   NEXT SECTION HANDLES SUBSCRIPTED SET SYMBOLS AND SYMBOLIC PRAMS
         SPACE
MXSBSCRP EQU   *
         CLI   MCARG1DX,$BSYMPAR   SYMPAR, K' OR T'?
         BNL   MXSCRP01            JUMP AND PROCESS IF YES
         BAL   RET,MXADDR          ELSE GET @ OF SET SYMBOL
         LA    R1,$BSATT          GET $BSADDRA-2
         SRL   RE,1                DIVIDE $ARITH, ETC TO GET 2, 4 OR 6
         AR    R1,RE               GET $BSADDRA, B ORC
         STC   R1,MCRSLTYP         SAVE TYPE  IN ONE-OP
         ALR   RE,RE               RESTORE TYPE(4,8,12)
         STM   RC,RE,MXARG1LN      SAVE @, LEN AND TYPE TEMP
MXSCRP01 EQU   *
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXARITH         GET ARITH VALUE
         LTR   RC,RC               TEST VALUE OF INDEX
         BP    MXSCRP02            PROCEED IF > 0
MXSCRPDR EQU   *
         LA    RB,$ER#DMER         ELSE SET DIMENON ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXSCRP02 EQU   *
         CLI   MCARG1DX,$BSYMPAR   SYM PAR, K' OR T'?
         BNL   MXSBSCSP            JUMP IF YES
         C     RC,MXARG1           COMPARE WITH SET SYMB DIM
         BH    MXSCRPDR            ERROR IF HIGH
         BCTR  RC,0                DECR TO GET OFFSET
         CLI   MCRSLTYP,$BSADDRB   BOOL TYPE?
         BNE   MXSCRP03            SKIP IF NOT
         MVI   MXARG2+3,4          ELSE SET LEN TO 4
MXSCRP03 EQU   *
         MH    RC,MXARG2+2         MULT TO GET OFFSET
         A     RC,MXARG1LN         ADD BASE @
         ST    RC,MCRESULT         PUT RESULT IN ONE-OP
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE
MXSBSCSP EQU   *                   PROCESS SYMBOLIC PARAMETER SUBSCRIPT
         MVI   MCRSLTYP,$BSTRING   SET TO CHAR FOR OPERNERS
         MVC   MCRESULT,AWZEROS    INIT REULST TO ZERO
         LA    R1,$LMPAROP         GET LEN OF SYM PAR DICT ENTRY
         MH    R1,MCARG1LC+2       MULST BY SYM PAR SUBSCRIPT
         A     R1,MXPNLSPT         ADD SYM PAR BASE @ OF DICT
         USING MCPAROPR,R1         SET USING FOR DICT ENTRY
         SR    RB,RB               CLEAR RB FOROPRND COUNT
         IC    RB,MCPARONB         GET NBR OF SUBOPRNDS
         CR    RB,RC               COMPARE WITH SUBSCRIPT
         BNL   MXSCSP03            PROCEED IF WITHIN RANGE
MXSCSP00 EQU   *
         CLI   MCARG1DX,$BSATK     K' ATRIB?
         BE    MXSCSP01            K' IF EQUAL
         BH    MXSCSP02            T' IF HIGH
         C     RC,AWF1             1ST SUBSCRIPT WANTED?
         BNE   MXPNONJP            FINI IF NOT
         MVC   MCRESULT+1(3),MCPAROPT+1      ELSE IS SYMPAR, COPY RESUL
         MVC   MCRESULT(1),MCPAROLN
         B     MXPNONJP            SYM PAR IF FALL THRU, DEFAULT VALUE
MXSCSP01 EQU   *                   PROCESS K' OUT OF RANGE
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         C     RC,AWF1             1ST SUBSCRIPT WANTED?
         BNE   MXPNONJP            FINI IF NOT
         MVC   MCRESULT+3(1),MCPAROLN  MOVE K' OF MAIN OPRND TO RESULT
         B     MXPNONJP            AND GET NEXT ONE-OP
MXSCSP02 EQU   *                   PROCESS  T' OUT OF RANGE
         C     RC,AWF1             1ST SUBSCRIPT WANTED?
         BNE   MXSCSP21            USE NULL TYPE IF NOT
         LA    RA,MCPAROTP         ELSE POINT AT OPRND TYPE
         B     MXSCSP22
MXSCSP21 EQU   *
         LA    RA,=C'O'            POINT AT NULL TYPE
MXSCSP22 EQU   *
         ST    RA,MCRESULT         STORE IN ONE-OP
         MVI   MCRESULT,1          ST LENGTH TO 1
         B     MXPNONJP            GET NEXT ONE-OP
MXSCSP03 EQU   *                   PRROCESS SUBSCRIPTS IN RANG
         L     R2,MCPRSBPT         GET POINTER TO SUBLIST ENTRIES
         LTR   R2,R2               SUBLIST EXISTS?
         BZ    MXSCSP00            PROCESS AS OUT OF RANGE IF NOT
         BCTR  RC,0                DECR INDEX
         SLL   RC,3                MULT BY 8 TO GET OFFSET
         AR    R2,RC               POINT TO SUBENTRY
         USING MCPARSUB,R2         SET USING ON SUB ENTRY
         CLI   MCARG1DX,$BSATK     K' ATTRIB?
         BE    MXSCSP04            YES IF EQUAL
         BH    MXSCSP05            T' IF HIGH
         MVC   MCRESULT+1(3),MCPARSPT+1      ELSE IS SYMPAR, COPY POINT
         MVC   MCRESULT(1),MCPARSLN   GET LEN OF STRING
         B     MXPNONJP            AND GET NEXT ONE-OP
MXSCSP04 EQU   *                   PROCESS K' IN RANGE
         MVC   MCRESULT+3(1),MCPARSLN   MOVE K' TO RESULT
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         B     MXPNONJP            GET NEXT ONE-OP
MXSCSP05 EQU   *                   PROCESS T' IN RANGE
         LA    RB,MCPARSTP         GET @ OF TYPE
         ST    RB,MCRESULT         PLACE IN RESULT
         MVI   MCRESULT,1          SET LEN TO 1
         B     MXPNONJP            GET NEXT ONE-OP
         DROP  R1,R2               DROP USING ON MCPAROPR,MCPARSUB
         SPACE
         EJECT
*   NEXT SECTION PROCESSES SUBSTRING ACTION
         SPACE
MXSBST   EQU   *
         MVI   MCRSLTYP,$BSTRING   INIT TYPE TO STRING
         MVC   MCRESULT,AWZEROS    INIT LEN TO ZERO
         BAL   RET,MXARITH         GET 1ST ARG VALUE
         LTR   RC,RC               WAS 1ST EXP <= 0
         BNP   MXSBSTER            ERROR IF INDEX <=0
         ST    RC,MXARG1           SAVE VALUE TEMP
         IC    RA,MCARG2DX         GET ARG2 INDEX
         L     RB,MCARG2LC         GET ARG2 LOC
         BAL   RET,MXARITH         GET ARITH VALUE
         LTR   RC,RC               WAS VALUE <= 0
         BNP   MXSBSTER            ERROR IF SO
*        **NOTE** MAY CHANGE THIS FOR G-LEVEL COMPATIBLE CODE
         C     RC,=F'8'            LEN > 8?
         BH    MXSBSTER            ERROR IF YES
         ST    RC,MXARG2           SAVE ARG2 TEMP
         IC    RA,MCARG1DX+$LMCQUAD  GET TYPE OF OPRND
         L     RB,MCARG1LC+$LMCQUAD  GET LOC OF OPERAND
         BAL   RET,MXCHAR          CONVERT TO CHAR
         C     RB,MXARG1           LEN < STARTING CHAR?
         BNL   MXSBST01            OKAY IF NO LOW
         L     RC,MXARG1           ELSE PUT BAD VALUE IN RC
         B     MXSBSTER            AND JUMP TO FLAG ERROR
MXSBST01 EQU   *
         LM    RD,RE,MXARG1        GET START NBR AND LEN
         AR    RD,RC               GET NEW START @ + 1
         BCTR  RD,0                DECR @
         ST    RD,MCRESULT         SAVE START @ OF SUBSTING
         AR    RC,RB               GET PNTR TO END OF STRING + 1
         AR    RD,RE               GET PNTR TO SUBSTR END PLUS 1
         CR    RC,RD               SUBSTRING OKAY?
         BNL   MXSBST03            JUMP IF OKAY
         S     RC,MCRESULT         ELSE GET LEN OF RMNDR OF STRING
         STC   RC,MCRESULT         SAVE LEN OF SUBST
         B     MXSBSTFT            JUMP TO FOOT
MXSBST03 EQU   *
         S     RD,MCRESULT         GET LENGTH OF SUBSTR
         STC   RD,MCRESULT         SVE LEN OF SUBSTR IN ONE-OP
MXSBSTFT EQU   *
         LA    RW,$LMCQUAD(RW)     BUMP PNTR PAST DUMMY ONE-OP
         B     MXPNONJP            GET NEXT ONE-OP
         SPACE 1
MXSBSTER EQU   *
         LA    RB,$ER#SBST         SET SUBSTR ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
         EJECT
*    NEXT SECTION PROCESSES SYSLIST SUBSCRIPTED VARIABLE
         SPACE
MXSYSL   EQU   *
         MVI   MCRSLTYP,$BSTRING   INIT TO CHAR TYPE
         MVC   MCRESULT,AWZEROS    INIST RESULT TO ZERO
         CLI   MCBOPRTR+$LMCQUAD,X'00'    DOUBLE SUBSCRIPT?
         BNE   MXSYSL01            SINGLE ONE-OP IF NOT
         BAL   RET,MXARITH         ELSE GET VALUE OF 1ST SUBSCRIPT
         ST    RC,MXARG1           STORE TEMP
MXSYSL01 EQU   *
         IC    RA,MCARG2DX         GET 2ND ARG
         L     RB,MCARG2LC         GET LOC
         BAL   RET,MXARITH         CONVERT TO ARITH
         ST    RC,MXARG2           SAVE TEMP(1ST SUB OF SINGLE)
         CLI   MCBOPRTR+$LMCQUAD,X'00'   2 OPRNDS
         BNE   MXSYSL02            JUMP IF NOT
         L     RC,MXARG1           ELSE RESTORE 1ST ARG VALUE         A
MXSYSL02 EQU   *
         LTR   RC,RC               VALUE > 0
         BNL   MXSYSL03            IF >= 0, OKAY
MXSYSLR1 EQU   *
         LA    RB,$ER#SYSL         SET SYSLIST DIM ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXSYSL03 EQU   *
         C     RC,MXPNBOPS         COMPARE WITH NBR OF POSIT OPRNDS
         BH    MXSYSLHI            JUMP IF HIGH
*   PROCESS &SYSLIST(A), N', K', T' WITHIN RANGE
         LA    RB,$LMPAROP         GET LEN OF SY PAR DICT ENTRY
         MR    RB,RB               MULT BY SUBSCRIPT TO GET OFFSET
         A     RC,MXPNLSPT         ADD BASE @ OF SYM PAR DICT
         USING MCPAROPR,RC         SET USING FOR DICT ENTRY
         CLI   MCBOPRTR+$LMCQUAD,X'00'   DOUBLE SUBSCRIPT?
         BE    MXSYLDBL            PROCESS IF YES
         CLI   MCARG1DX,$BSYSLST   &SYSLIST?
         BNE   MXSYSL04            IF NOT MUST BE ATTRIB
         MVC   MCRESULT+1(3),MCPAROPT+1  MOVE OPRND PNTR TO ONE-OP
         MVC   MCRESULT(1),MCPAROLN   MOVE LENGTH OF OPNRD TO ONE-OP
         B     MXPNONJP            GET NEXT OPCODE
MXSYSL04 EQU   *
         SR    R1,R1
         CLI   MCARG1DX,$BSATN     WHICH ATTRIB?
         BH    MXSYSLTP            T' IF HIGH
         BE    MXSYSLNP            N' IF EQUAL
         MVC   MCRESULT+3(1),MCPAROLN   K' IF FALL THRU
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         B     MXPNONJP            GET NEXT ONE-OP
MXSYSLNP EQU   *
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         MVC   MCRESULT+3(1),MCPARONB   GET NBR OF SUB OPRNDS
         CLI   MCPARONB,X'00'      ZERO SUBOPRNDS?
         BNE   MXPNONJP            IF > 0, GET NEXT ONE-OP
         CLI   MCPAROTP,C'O'       NULL OPRND?
         BE    MXPNONJP            IF YES, GET NEXT ONE-OP
         MVI   MCRESULT+3,1        ELSE SET NBR TO 1
         B     MXPNONJP            AND GET NEXT ONE-OP
MXSYSLTP EQU   *                   PROCESS T' IN RANGE
         LA    R1,MCPAROTP         GET @ OF TYPE
         ST    R1,MCRESULT         STORE RESULT IN ONE-OP
         MVI   MCRESULT,1          SET LEN=1
         B     MXPNONJP            GET NEXT ONE-OP
MXSYLDBL EQU   *                   PROCESS DOUBLE SUBSCRIPTE
         L     R1,MXARG2           GET 2ND VALUE
         LTR   R1,R1               POSITIVE?
         BH    MXSYLDB1            OKAY IF YES
         LR    RC,R1               ELSE MOVE BAD VALUE TO RC
         LA    RW,$LMCQUAD(RW)     BUMP ONE-OP PNTR PAST DUMMY
         B     MXSYSLR1            JUMP TO FLAG ERROR
MXSYLDB1 EQU   *
         SR    RE,RE
         IC    RE,MCPARONB         GET SUBOPRND COUNT
         CR    R1,RE               SUBS > NBR SUBOPRNDS?
         BNH   MXSYLDB2            PROCEED IFLOW
         CLI   MCARG1DX+$LMCQUAD,$BSYSLST  $BSYSLIST?
         BE    MXSYSDFT            JUMP TO FOOT IF YES
         MVI   MCRSLTYP,$BSIMMA    SET TYPE = ARITH
         CLI   MCARG1DX+$LMCQUAD,$BSATK   K'&SYSLIST?
         BE    MXSYSDFT            FINI IF YES
         MVI   MCRSLTYP,$BSTRING   ELSE SET TYPE TO CHAR
         LA    R1,=C'O'            ELSE GET @ OF NULL TYPE
         B     MXSYLDB5            SKIP TO SAVE @, SET LEN=1
MXSYLDB2 EQU   *                   PROCESS &SYSLIST(A,B) IN RANGE
         L     RC,MCPRSBPT         GET @ OF SUBOPRNDS
         USING MCPARSUB,RC         SET USING FOR SUB E TRY
         BCTR  R1,0                DECR INDEX FOR MULT
         SLL   R1,3                MULT BY 8 FOR OFFSET
         AR    RC,R1               MOVE BASE TO RIGHT ENTRY
         CLI   MCARG1DX+$LMCQUAD,$BSYSLST   &SYSLIST?
         BNE   MXSYSDB3            IF NOT, PROCESS T' OR K'
         MVC   MCRESULT,MCPARSPT   ELSE MOVE @ OF SUBOPRND TO ONE-OP
         MVC   MCRESULT(1),MCPARSLN    MOVE LEN TO ONE-OP
         B     MXSYSDFT            JUMP TO FOOT
MXSYSDB3 EQU   *                   PROCESS K'&SYSLIST OR T'&SYSLIST
         CLI   MCARG1DX+$LMCQUAD,$BSATT     T'&SYSLIST?
         BE    MXSYLDB4            JUMP IF YES
         MVC   MCRESULT+3(1),MCPARSLN    ELSE MUST BE K'&SYSLIST
         MVI   MCRSLTYP,$BSIMMA    SET TYPE TO ARITH
         B     MXSYSDFT            JUMP TO FOOT
MXSYLDB4 EQU   *
         LA    R1,MCPARSTP         GET @ OF TYPE
MXSYLDB5 ST    R1,MCRESULT         STORE IN ONE-OP
         MVI   MCRESULT,1          SET LEN TO 1
*              FALL THRU INTO MXSYSDFT
MXSYSDFT EQU   *
         LA    RW,$LMCQUAD(RW)     BUMP PNTR PAST DUMMT ONE-OP
         B     MXPNONJP            GET NEXT ONE-OP
         DROP  RC
         SPACE
*  PROCESS &SYSLIST(A), T' OR K' WHERE A > NBR OPRNDS
         SPACE
MXSYSLHI EQU   *
         CLI   MCBOPRTR+$LMCQUAD,X'00'     DOUBLE SUBS?
         BE    MXSYSLHD            PROCESS IF YES
         CLI   MCARG1DX,$BSYSLST   $&SYSLIST?
         BE    MXPNONJP            GET NEXT ONE OP IF YES
         CLI   MCARG1DX,$BSATN      N'?
         BNH   MXSYSLHK            K' OR N' IF LOW OR EQUAL
         B     MXSYSLHT            T' IF HIGH
MXSYSLHD EQU   *                   PROCESS DUBLE SUBSCRIPT
         CLI   MCARG1DX+$LMCQUAD,$BSYSLST     &SYSLIST?
         BE    MXSYSDFT            FINI IF YES
         CLI   MCARG1DX+$LMCQUAD,$BSATN     N'?
         BH    MXSYSLHT            ELSE IS T'&SYSLIST
*              FALL THRU ==> K', IF LOW
MXSYSLHK EQU   *
         MVI   MCRSLTYP,$BSIMMA     SET TYPE TO ARITH
MXSYSTSD EQU   *
         CLI   MCBOPRTR+$LMCQUAD,X'00'    DOUBLE SUBS?
         BE    MXSYSDFT            FINI IF YES, JUMP TO DOUBLE FOOT
         B     MXPNONJP            ELSE GET NEXT ONE-OP
MXSYSLHT EQU   *
         LA    R1,=C'O'            GET @ OF NULL TYPE
         ST    R1,MCRESULT         STORE @ IN ONE-OP
         MVI   MCRESULT,1          SET LEN TO 1
         B     MXSYSTSD            TEST FOR DOUBLE SUBS
         EJECT
* SECTION TO ADD CHARS TO OUTPUT                                      A
*                                                                     A
MXPRNT   EQU   *
         USING RSBLOCK,RY          NOTE USING ON SOURCE
         L     RY,AVRSBPT          SET BASE ON SOURCE
         BAL   RET,MXCHAR          CONVERT ARG TO STRING
         LA    RA,RSBSOURC         SET SCAN POINTER
         LA    RE,$LMSRCMX(RA)     SET UPPER LIMIT POINTER
         A     RA,MCARG2LC         ADD OFFSET
         CLI   RSBLENG,X'00'       1ST MOVE?
         BE    MXPRNT01
         SR    R1,R1
         IC    R1,RSBLENG          GET PREV LEN-1
         LA    R1,RSB$L+1(R1,RY)   POINT TO AVAILABLE BYTE
         CR    RA,R1               COMPARE WITH TARGET
*          FOLLOWING CHECKS SPECIAL CASE OF OPRND MEETING COMMENT     A
         BH    MXPRNT01            OKAY IF NEXT PTR > OLD END         A
         BL    MXPRNT00            IF LOW, MUST INCREM BEYOND ANYWAY  A
         TM    MCBOPRTR,$MPRCOM    IF EQUAL, CHECK FOR SPECIAL COMPR  A
         BZ    MXPRNT01            NOT COMMENT,CONCAT IF COM,MOVE OVERA
MXPRNT00 LA    RA,1(,R1)           SKIP BLANK B                       A
MXPRNT01 EQU   *
         S     RB,AWF1             DECR RB
         BM    MXPNONJP            IF NULL, GET NEXT ONE-OP
         LA    R2,0(RA,RB)         POINT TO FINAL BYTE
         CR    R2,RE               EXCEED LIMIT?
         BNH   MXPRNT02            PROCEED IF OKAY
         LA    RB,$ERMEXST         ELSE SET ERROR FLAG
         $CALL ERRTAG              FLAG STMT
         B     MXPNONJP            GET NEXT ONE-OP
MXPRNT02 EQU   *
         EX    RB,MXPMVSRC         MOVE STRING TO SOURCE BLOCK
         LA    RA,RSBSOURC         GET START @
         SR    R2,RA               GET LEN-1 IN R2
         STC   R2,RSBLENG          STORE LEN-1
         B     MXPNONJP            GET NEXT ONE-OP
MXPMVSRC MVC   0($,RA),0(RC)       DUMMY TO MOVE STRING
         DROP  RY
         EJECT
         SPACE 2
*        INNER MACRO CALL                                             A
*                                                                     A
MXINMAC  EQU   *
         USING RSBLOCK,RY          NOTE USING
         L     RY,AVRSBPT          SET BASE
         SR    R1,R1               USE R1 FOR LENGTH
         IC    R1,RSBLENG          GET LENGTH IN R1
         LA    R1,RSB$L+1(RY,R1)   POINT TO NEXT AVAILABLE BYTE
         MVC   0(4,R1),=C'  '' '   MOVE END OF RECORD INDICATROR
         LA    R1,1(R1)            BUMP R1
         ST    R1,AVSOLAST         SAVE END OF RECORD @
         MVI   RSBNUM,1            SET NBR CARDS TO 1
         LA    RB,RSBLOCK+RSB$L+RSOL1  POINT TO 1ST BYTE, 2ND CARD
         CR    R1,RB               COMPARE WITH AVSOLAST
         BL    MXINMAC1            AVSOLAST LOW, ONE CARD
         MVI   RSBNUM,2            SET COUNT TO 2 CARDS
         LA    RB,RSOLC(RB)        BUMP RB TO 1ST BYTE, 3RD CARD
         CR    R1,RB               COMPARE WITH AVSOLAST
         BL    MXINMAC1            IF LOW, 2 CARDS
         MVI   RSBNUM,3            ELSE IS 3 CARDS
MXINMAC1 EQU   *
         OI    RSBFLAG,$RSBGENR+$RSBNPNN  SET GEN & NO ACTION FLAGS
         TM    RSBFLAG,$REBX       ERROR BLOCK EXISTS?
         BNO   MXINCALL                                               A
         SPACE 4
MXMVSTMT EQU   *
         USING RSBLOCK,RY
         L     RY,AVRSBPT          SET BASE
         OI    RSBFLAG,$RSBGENR    SET GEN FLAG
         TM    MCBOPRTR,$BSMNTER   MNOTE ERROR?
         BNO   MXMVSTMU            SKIP IF NOT
         OI    RSBFLAG,$RSBMERR    SET ERROR FLAG
MXMVSTMU EQU   *
         $CALL MXMVSR              MOVE SOURCE TO HIGH
         LTR   RB,RB               OVERFLOW?
         BNZ   MXEXECOV            FLAG IF YES
         B     MXPNINJP            GET NEXT INST
MXERRMS  EQU   *
         LA    RB,$ER#PRVR         SHOW PREVIOUS ERROR                S
         DROP  RY                                                     S
         BAL   R1,MXINERRM         CALL ERROR FLAG ROUTINE            S
         B     MXPNINJP            ELSE GET NEXT INST
         SPACE
MXANOP   EQU   MXPNINJP            NO CODE NEEDED, GO FOR NEXT
MXFIN    EQU   MXPNINJP            NO CODE NEEDED, GO FOR NEXT
         EJECT                                                        S
*              *** ERROR EXITS: TERMINATE PROCESSING *****
MXINV    EQU   *
         LA    RB,$ER#SYER         SET SYSTEM ERR FLAG
         B     MXMENDEC            STOP PROCESSING AND RETURN
MXMENDER LA    RB,$ER#MXST         SET EXCEED STMTS FLAG
MXMENDEC EQU   *                   CALL MXERRM AND QUIT-TYPE EXIT LABEL
         BAL   R1,MXINERRM         GENERATE ERROR MESSAGE             A
MXENDEF  LA    RB,12               RB SET TO KILL MACROS              A
         B     MXINRTN             RETURN                             A
*              FALL THRU, HANDLE AS MEND OR MEXIT.
         SPACE
MXMEND   EQU   *
MXMEXIT  EQU   *
         SR    RB,RB               RB SET FOR MEND OR MEXIT           S
MXINRTN  EQU   *                                                      A
         L     R1,AVMXSPIE         RELOAD R1 FROM SPIE PTR            A
         LM    RC,RD,AVGEN1CD                                         A
         XSNAP LABEL='AT MXINST RET',STORAGE=(*0(RD),*0(RC),*AVADDLOW,*X
               AVWXEND),IF=(AVTAGSM,O,AJOMACRH,TM)
         $SPIE ,,,ACTION=(RS,(1))                                     A
         $RETURN RGS=(R14-R6)                                         A
         SPACE
MXARG1LN DS    F                   TEMP STORAGE FOR ARG1 LENGTH
MXARG1   DS    F                   TEMP STORAGE FOR ARG1
MXARG2   DS    F                   TEMP STORAGE FOR ARG2
*                                                                     S
*        SET RB TO RETURN CONDITION                                   S
*                                                                     S
MXINKIL1 EQU   *                                                      S
         BAL   R1,MXINERRM         CALL ERR MSG ROUTINE               S
         LA    RB,8                SET KILL MACRO NEST FLAG           S
         B     MXINRTN             NORMAL RETURN                      S
MXINCALL EQU   *                                                      A
         LA    RB,4                SET RETURN CODE                    A
         B     MXINRTN             RETURN                             A
         LTORG                                                        S
         DS    0H                  FORCE ALIGNMENT                    S
         EJECT                                                        A
**--> INSUB: MXINERRM       CALLS MXERRM TO HANDLE ERROR MESSAGES  + +S
*+                                                                   +S
*+             ENTRY CONDITIONS:                                     +S
*+       RB = ERROR CODE                                             +S
*+       RC = VALUE IF ANY                                           +S
*+       RD = LENGTH                                                 +S
*+       R1 = LINK REG                                               +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE 2                                                      S
MXINERRM EQU   *                                                      S
         LR    RE,RZ               COPY @ OF MXPNTSAV                 A
         $CALL MXERRM              CALL ERROR ROUTINE                 S
         LTR   RB,RB               TEST RB FOR OVERFLOW               S
         BCR   Z,R1                RETURN ON NOT OVERFLOW             S
*        SET RB TO OVERFLOW VALUE AND RETURN                          S
MXEXECOV EQU   *                                                      S
         LA    RB,16               SET OVERFLOW FLAG                  S
         B     MXINRTN             NORMAL RETURN                      S
         SPACE 5                                                      S
**--> INSUB: MXARITH MXARITH PRODUCES ARITH ONE-OP                    A
*+                                 MXBOOL PRODUCES BOOLEAN ONE-OP     A
*+                                 MXCHAR PRODUCES CHAR ONE-OP        A
*         TYPE.                                                       *
*                                                                     *
*         ENTRY CONDITIONS                                            *
*      RA = TYPE OF OPRND                                             *
*      RB = @ OF OPRND (OR VALUE IF IMMEDIATE TYPE)                   *
*                                                                     *
*         EXIT CONDITIONS                                             *
*+       RA=BYTE REG                                                  A
*+       R1=WIPED OUT                                                 A
*+       RE=WIPED OUT                                                 A
*      RB = LENGTH OF CHAR STRING IF CHAR VALUE                       *
*      RC = VALUE IF ARITH OR BOOL, @ OF STRING IF CHAR               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXARITH  DS    0F
         OI    AVMBYTE2,$MINARIT   SET ARITH FLAG
         B     MXSCCV
MXBOOL   EQU   *
         OI    AVMBYTE2,$MINBOOL   SET BOOL REQ'D FLAG
         B     MXSCCV
MXCHAR   EQU   *
         OI    AVMBYTE2,$MINCHAR   SET CHAR REQ'D FLAG
MXCONVBS DS    0H                  BASE FOR JUMP TABLE
MXSCCV   EQU   *
         ST    RET,MXSCCVSV        SAVE RETURN @
         SPACE
MXCONJMP EQU   *
         N     RA,AWFXFF           MASK OUT ALL EXCEPT INDEX
         LH    R1,MXCONNDX(RA)     GET OFFSET OF ROUTINE
         XSNAP LABEL='***MXARITH ENTERED***',                          X
               IF=(AVMSNBY2,O,$MSNP12,TM)
         B     MXCONVBS(R1)        JUMP TO ROUTINE
         SPACE
MXCONNDX $AL2  MXCONVBS,(MXCNGLA,MXCNGLB,MXCNGLC,MXCNLCA,MXCNLCB,MXCNLC#
               C,MXCNSYPR,MXCNIMMA,MXCNIMMB,MXCNIMMC,MXCNSYSX,MXCNUND,M#
               XCNCSCT,MXCNUND,MXCNTEMP,MXCNUND,MXCNUND,MXCNATTK,      #
               MXCNUND,MXCNATTN,MXCNUND,MXCNATTT,MXCNADDA,MXCNADDB,    #
               MXCNADDC),-2
         SPACE
*        PROCESS GLOBALS                                              A
*                                                                     A
         USING MCGLBDCT,RB         NOTE USING FOR GLOBAL SET SYMB DV
MXCNGLA  EQU   *
         L     RC,MCGBAVAL         GET ARITH VALUE
         B     MXCONV0A
         SPACE
MXCNGLB  EQU   *
         L     RC,MCGBAVAL         GET BOOL VALUE
         B     MXCONV0B
MXCNGLC  EQU   *
         LA    RC,MCGBCVAL         GET @ OF CHAR VALUE
         L     RB,MCGBCLEN         GET LENGTH OFSTRING
         B     MXCONV0C
         EJECT
MXCNLCA  EQU   *
MXCNLCB  EQU   *
MXCNLCC  EQU   *
         L     RC,MGLCLPNT         GET OFFSET
         A     RC,MXPNLDBS         ADD BASE @ OF LOCAL SET SYM DICT
         CLI   MCGLBTYP,$BOOL      WHAT TYPE                          A
         BH    MXCNLCA1            CHAR IF HIGH
         L     RC,0(RC)            ELSE GET ARITH OR BOOL VALUE
         BL    MXCONV0A            ARITH IF LOW
         B     MXCONV0B            ELSE IS BOOL
MXCNLCA1 EQU   *
         L     RB,0(RC)            GET LEN OF CHAR
         LA    RC,4(RC)            BUMP POINTER TO STRING
         B     MXCONV0C
         DROP  RB                  DROP USING ON SET SYMB DV
         SPACE
MXCNSYPR EQU   *
         USING MCPAROPR,RE         NOTE USING ON SYM PAR DICT ENTRY
         LA    RE,$LMPAROP         GET LEN OF ENTRY
         MR    RD,RB               CALCULATE OFFSET
         A     RE,MXPNLSPT         ADD SYM PAR DICT BASE
         L     RC,MCPAROPT         GET POINTER TO STRING
         IC    RB,MCPAROLN         GET LEN OF STRING
         TM    AVMBYTE2,$MINCHAR+$MINBOOL                             A
         BNZ   MXCONV0C                                               S
         CLI   MCPAROTP,C'N'       FALL THRU MEANS ARITH REQ'D
         BE    MXCNSYP1            IF SELF DEF TERM, OK
MXCNSYER EQU   *
         LR    RD,RB               ELSE MOVE LEN TO RD
         LA    RB,$ER#CVCA         SET CONVERSION ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCNSYP1 EQU   *
         LR    RA,RC               MOVE POINTER TO RA
         $CALL SDBCDX              CHECK FOR SELF DEF TERM
         LTR   RB,RB               OKAY?
         BZ    MXCONRTN            RETURN IF YES
         SR    RB,RB               ELSE CLEAR RB
         IC    RB,MCPAROLN         INSERT STRING LENGTH
         L     RC,MCPAROPT         POINT TO STRING
         B     MXCNSYER            AND FLAG ERROR
         SPACE
MXCNIMMA EQU   *
         LR    RC,RB               MOVE VALUE TO RC
         B     MXCONV0A            CONVERT IF NECESSARY
MXCNIMMB EQU   *
         LR    RC,RB               MOVE IMM VALUE TO RC
         B     MXCONV0B            CONVERT IF NECESSARY
MXCNIMMC EQU   *
         SRDL  RB,24               MOVE @ TO RC, LEAVE LEN IN RB
         SRL   RC,8                FINISH SHIFT IN RC
         B     MXCONV0C            CONVERT IF NECESSARY
*                                                                     A
*  PROCESS SYSNDX                                                     A
MXCNSYSX EQU   *                   GET SYSYNX VALUE
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCNSX01            PROCESS CHAR IF YES
         ZAP   AVDWORK1,MXPSYSDX   MOVE SYSNDX TO DOUBLE WORD
         CVB   RC,AVDWORK1         CONVERT TO BINARY
         TM    AVMBYTE2,$MINBOOL   BOOL REQ'D?
         BNO   MXCONRTN            RETURN IF NOT
MXCNSX03 EQU   *
         LA    RB,$ER#CVAB         SET ARITH - BOOL ERROR
         B     MXCONVAR                                               A
         EJECT
*                                                                     A
*  CONVERT SYSNDX TO CHAR                                             A
*                                                                     A
MXCNSX01 EQU   *
         L     RE,MXPCHRBF         GET POINTER TO WORK AREA
         LA    RE,4(RE)            BUMP TO TEST END
         C     RE,AVMCHLIM         TEST AGAINST LIMIT
         BNH   MXCNSX02            PROCEED IF OKAY
         LA    RB,$ER#EXBF         SET ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCNSX02 EQU   *
         LA    RB,4                PUT USEFUL VALUE IN RB
         SR    RE,RB               RESTORE THE POINTER
         UNPK  0(4,RE),MXPSYSDX    UNPACK &SYSNDX
         OI    3(RE),X'F0'         CHANGE LAST ZONE TO F
         LR    RC,RE               POINT RC AT STRING
         AR    RE,RB               BUMP RE TO END OF BUFFER
         ST    RE,MXPCHRBF         RESOTRE BUFFER POINTER
         B     MXCONRTN            AND RETURN
         SPACE
MXCNCSCT EQU   *
         LA    RC,AVSYSECT         GET @ OF CSECT NAME
         TRT   0(9,RC),AWTSYMT     SCAN NAME FOR LENGTH
         SR    R1,RC               GET LENGTH
         LR    RB,R1               MOVE LENGTH TO RB
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCONRTN            RETURN IF YES
         B     MXCONCAR                                               A
         SPACE
MXCNTEMP EQU   *
         USING MCOPQUAD,RB         SET USING ON ONE-OP
         IC    RA,MCRSLTYP         GET INDEX
         L     RB,MCRESULT         GET LOCATION
         B     MXCONJMP            EVALUATE
         DROP  RB
         EJECT
MXCNATTK EQU   *
MXCNATTN EQU   *
         LTR   RB,RB               &SYSLIST?
         BNL   MXCNAT01            NO IF NOT LOW
         L     RC,MXPNBOPS         ELSE GET NBR OF OPRNDS
         B     MXCONV0A            AND CONVERT IF NECESSARY
MXCNATTT EQU   *
MXCNAT01 EQU   *
         TM    AVMBYTE2,$MINBOOL   BOOLEAN VALUE REQUIRED             J
         BZ    MXCNAT02            IF NOT OKAY
         LA    RB,$ER#ATER         ELSE SET ATTRIB USE ERR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCNAT02 EQU   *
         USING MCPAROPR,RE         SET USING ON SYM PAR DICT ENTRY
         SR    RC,RC
         LA    RE,$LMPAROP         GET LENGTH OF ENTRY
         MR    RD,RB               GET OFFSET
         A     RE,MXPNLSPT         ADD SYM PAR DICT BASE
         LA    R1,$BSATN           GET N' INDEX
         CR    RA,R1               COMPARE WITH OPRND INDEX
         BH    MXCNATTP            T' IF HIGH
         BE    MXCNATNP            N' IF EQUAL
         IC    RC,MCPAROLN         K' IF FALL THRU
         B     MXCONV0A            RETRN
MXCNATNP EQU   *
         IC    RC,MCPARONB         GET N'
         B     MXCONV0A            JUMP TO CONVERT
MXCNATTP EQU   *
         LA    RB,1                GET LENGTH OF TYPE
         LA    RC,MCPAROTP         GET POINTER TO TYPE
         B     MXCONV0C            CONVERT IF NECESSARY
         DROP  RE
         SPACE
MXCNADDA EQU   *
         L     RC,0(RB)            GET ARITH VALUE
         B     MXCONV0A            CONVERT IF NECESSARY
MXCNADDB EQU   *
         L     RC,0(RB)            GET VALUE
         B     MXCONV0B            CONVERT IF NECESSARY
MXCNADDC EQU   *
         LA    RC,4(RB)            GET @ OF STRING
         L      RB,0(RB)           GET LENGTH OF STRING
         B     MXCONV0C            CONVERT IF NECESSARY
         SPACE
MXCNUND  EQU   *
         LA    RB,$ER#SYER         SET SYSTEM ERROR FALG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
         EJECT
*                                                                     A
*        CONVERT TO ARITH                                             A
*                                                                     A
MXCONV0A EQU   *
         TM    AVMBYTE2,$MINARIT   ARITH REQ'D?
         BO    MXCONRTN            RETURN IF YES
         B     MXCONVAR            ELSE CONVERT
*                                                                     A
*        CONVERT TO BOOLEAN                                           A
*                                                                     A
MXCONV0B EQU   *
         TM    AVMBYTE2,$MINBOOL+$MINARIT   ARITH OR BOOL REQ'D?
         BM    MXCONRTN            RETURN IF YES
         B     MXCONVBL            ELSE CONVERT
*                                                                     A
*        CONVERT TO CHAR                                              A
*                                                                     A
MXCONV0C EQU   *
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCONRTN            RETURN IF YES
         B     MXCONVCH            ELSE CONVERT
MXCONVAR EQU   *
         TM    AVMBYTE2,$MINCHAR   CHAR REQ'D?
         BO    MXCONVAC            CONVERT IF YES
         C     RC,AWF1             BOOL VALUE?
         BE    MXCONRTN            RETURN IF YES
         LTR   RC,RC               ZERO VALUE?
         BE    MXCONRTN            OKAY IF YES
MXCONVAB LA RB,$ER#CVAB            ELSE SET ERROR FLAG                A
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCONVAC EQU   *
         LPR   RC,RC               GET POS VALUE
         CVD   RC,AVDWORK1         CONVERT TO PACKED DEC
         LA    RB,12               GET MAX LENGTH OF DEC NUMBER+1
         $MALLOCL  RE,RB,OVRFL=MXEXECOV   GET STORAGE FOR NBR
         MVC   0(12,RE),MXCEP12    MOVE EDIT MASK FOR MAX NBR
         LA    R1,11(RE)           POINT TO LAST CHAR
         LA    RB,1(R1)            GET @ OF DELIM IN RB
         EDMK  0(12,RE),AVDWORK1+2 EDIT DEC FIELD
         LR    RC,R1               MOVE POINTER TO RC
         SR    RB,R1               PUT LENGTHIN RB
         B     MXCONRTN            AND RETURN
         EJECT
MXCONVBL EQU   *
*                                                                     A
* CONVERT BOOLEAN --> CHAR                                            A
*                                                                     A
         LA    RB,1                SET LEN TO 1
         LA    RC,MXCONBLT(RC)     GET @ OF '0' OR '1' AS APPROPRIATE
         B     MXCONRTN            AND RETURN
MXCONBLT DC    C'01'               CONVERT BOOLEAN TO CHARACTER
         SPACE
MXCONVCH EQU   *
         TM    AVMBYTE2,$MINBOOL   BOOL REQ'D?
         BO    MXCONVCB            CONVERT IF YES
*                                                                     A
* CONVERT CHAR --> ARITH                                              A
*                                                                     A
MXCONVCA EQU   *                   CONVERT TO ARITH
         SR    R2,R2
         SR    R1,R1
         LTR   RB,RB               TEST LENGTH OF CHAR
         BNZ   MXCONCA1            PROCEED IF NONZERO
MXCONCAR EQU   *                   PROCESS ZERO STRING
         LR    RD,RB               MOVE LENGTH TO RD
         LA    RB,$ER#CVCA         SET CONVERSION ERROR FLAG
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCONCA1 EQU   *                   CONVERT TO ARITH
         TRT   0(1,RC),AWTDECT     POSSIBLE SELF DEF TERM?
         BNZ   MXCONCA4            CKECK FOR C,B OR X IF NOT
         C     RB,AWF10            TEST LENGTH
         BH    MXCONCAR            ERROR IF > 10
         BL    MXCONCA2            IF < 10, OKAY
         CLC   0(10,RC),=C'2147483647'  ELSE COMPARE AGAINST LIMIT
         BH    MXCONCAR            ERROR IF HIGH
MXCONCA2 EQU   *
         BCTR  RB,0                DECR LEN FOR TRT
         EX    RB,MXPSCDEC         SCAN FOR DEC NBRS
         BZ    MXCONCA3            OKAY IF ALL DEC
         LA    RB,1(RB)            ELSE RESTORE RB
         B     MXCONCAR            AND FLAG ERROR
MXCONCA3 EQU   *
         EX    RB,MXPMVDEC         MOVE DEC STRING TO WORK AREA PACKED
         CVB   RC,AVDWORK1         CONVERT TO BIN
         B     MXCONRTN            AND RETURN
MXCONCA4 EQU   *
         C     R2,AWF4             B, C OR X?
         BNE   MXCONCAR            ERROR IF NOT
         LR    R1,RB               SAVE LENGTH
         LR    RA,RC               MOVE POINTER TO RA
         $CALL SDBCDX              CHECK FOR SELF DEF AND CONVERT
         LTR   RB,RB               OKAY?
         BZ    MXCONRTN            RETURN IF OKAY
         LR    RB,R1               RESTORE LENGTH TO RB
         LR    RC,RA               PUT POINTER IN RC
         B     MXCONCAR            AND FLAG ERROR
         SPACE
MXPMVDEC PACK  AVDWORK1,0($,RC)    DUMMY TO PACK STRING
MXPSCDEC TRT   0($,RC),AWTDECT     DUMMY TO SCAN FOR DEC CHARS
         SPACE 10                                                     S
MXCONVCB EQU   *                   CONVERT CHAR TO BOOL
         C     RB,AWF1             LEN = 1?
         BE    MXCONCB1            OKAY IF 1
MXCONCBR EQU   *                   ELSE IS ERROR
         LR    RD,RB               MOVE LEN TO RD
         LA    RB,$ER#CVCB         SET CHAR->BOOL ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXCONCB1 EQU   *
         CLI   0(RC),C'1'          CHAR = 1?
         BNE   MXCONCB2            PROCEED IF NOT 1
         LA    RC,1                SET BOOL VALUE
         B     MXCONRTN            AND RETURN
MXCONCB2 EQU   *
         CLI   0(RC),C'0'          DID CHAR = '0' (ZERO)              J
         BNE   MXCONCBR            ERROR IF NOT
         SR    RC,RC               SET FALSE BOOL FALUE
*                                                                     A
MXCONRTN EQU   *
         XSNAP LABEL='***MXARITH EXITED***',                           X
               IF=(AVMSNBY2,O,$MSNP12,TM)
         SR    RA,RA               ZERO RA FOR BYTE USE               A
         L     RET,MXSCCVSV        RESTORE RETURN @
         BR    RET                 AND RETURN
MXSCCVSV DS    F                   SPACE FOR RETURN ADDRESS
MXCEP12  DC    X'402020202020202020202120'    12 BYTE DEC MASK
         LTORG
         TITLE ' MXINST-INTERNAL ROUTINES'                            A
**--> INSUB: MXADDR       THIS ROUTINE ACCEPTS A ONE-OP  + + + + + + +S
*+       OPRND AND RETURNS THE @ OF THE SYMBOL.  OPRND MUST BE       +S
*+       A SET SYMBOL OR TEMP VALUE POINTING TO AN ADDRESS.          +S
*+                                                                   +S
*+             ENTRY CONDITIONS:                                      S
*+       RA = INDEX OF OPRND                                         +S
*+       RB = @ OF OPRND                                             +S
*+                                                                   +S
*+             EXIT CONDITIONS:                                      +S
*+       RC = @ OF VALUE                                             +S
*+       RD = DIMENSION OF SET SYMBOL                                +S
*+       RE = TYPE OF SYMBOL (IE -  $ARIT, $BOOL OR $CHAR)           +S
*+                                                                   +S
*+ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +S
         SPACE
MXADDR   DS    0F                  ENTRY PT FOR INTERNAL SUB
         XSNAP LABEL='***MXADDR ENTERED***',                           X
               IF=(AVMSNBY2,O,$MSNP12,TM)
         USING MCGLBDCT,RB         NOT USING ON SET SYMB DV
         SR    RE,RE
         SR    RD,RD
         LA    R1,$BSYMPAR         GET SYM PAR BSU VALUE
         CR    RA,R1               COMPRE WITH OPNRD
         BNL   MXADDR01            NOT SET SYM IF NOT LOW
         SRL   R1,1                DIVIDE SYM PAR BSU BY 2
         CR    RA,R1               COMPARE WITH OPRND
         BNL   MXADDRLC            SET SYM LOCAL IF NOT LOW
         LA    RC,MCGBAVAL         GET @ OF VALUE
         LH    RD,MCGLBDIM         GET DIMENSION
         IC    RE,MCGLBTYP         GET TYPE IN RE
         B     MXADDRET            JUMP TO FOOT
MXADDRLC EQU   *                   TREAT LOCAL SET SYMBOLS
         LH    RD,MCGLBDIM         GET DIMENSION
         IC    RE,MCGLBTYP         GET TYPE
         L     RC,MGLCLPNT         GET OFFSET
         A     RC,MXPNLDBS         ADD BASE @ OF SET SYM DICT
         B     MXADDRET            JUMP TO FOOT
MXADDR01 EQU   *
         USING MCOPQUAD,RB         NOTE USING ON ONE-OP
         LA    R1,$BSTEMP          GET TEMP BSU
         CR    R1,RA               MUST BE $BSTEMP
         BNE   MXADDRR1            ERROR IF NOT
         L     RC,MCRESULT         GET @ OF DESIRED VALUE
         CLI   MCRSLTYP,$BSADDRA   COMPARE WITH ARITH @
         BL    MXADDRR1            ERROR IF LOW
         BE    MXADDR02
         CLI   MCRSLTYP,$BSADDRC   CHECKFOR CHAR @
         BH    MXADDRR1            ERROR IF HIGH
         BE    MXADDR03            ARITH IF EQUAL
         LA    RE,$BOOL            FALL THRU MEANS BOOLEAN
         B     MXADDRET            JUMP TO FOOT
MXADDR02 EQU   *
         LA    RE,$ARITH           SET ARITH TYPE
         B     MXADDRET            JUMP TO FOOT
MXADDR03 EQU   *
         LA    RE,$CHAR            SET CHAR TYPE
         B     MXADDRET            JUMP TO FOOT
MXADDRR1 EQU   *
         LA    RB,$ER#SYER         SET SYSTEM ERROR
         B     MXPNINJE            GO FLAG ERROR AND CONTINUE
MXADDRET EQU   *
         XSNAP LABEL='*** MXADDR EXITED ***',                          #
               IF=(AVMSNBY2,O,$MSNP12,TM)
         BR    RET                 AND RETURN
         LTORG
         DROP  RB,RZ,RAT                                              S
         TITLE '***MXERRM  GENERATES ERROR MSSGS IN MEXPND***'
**-->  CSECT:  MXERRM  CALLED DURING MACRO GENERATION TO GENERATE     *
*.        ERROR MESSAGES NOT HANDLED BY ERRTAG                        *
*.                                                                    *
*.        ENTRY CONDITIONS                                            *
*.       RA-SCAN PTR                                                  A
*.     RB = ERROR TYPE                                                *
*.     RC = OPERAND VALUE OR LOCATION                                 *
*.     RD = LENGTH OF STRING IF CHAR VALUE                            *
*.       RE-@ MXPNTSACV                                               A
*.                                                                    *
*.       EXIT CONDITIONS                                              A
*.       RB=0 ==> OK                                                  A
*.       RB=4 ==> STORAGE OVERFLOW CAUSED MESSAGE SELECTED IS PLACED  A
*.       IN RSBLOCK, THEN MOVED OUT TO HIGH AREA BY MXMVSR            A
*.                                                                    A
*.        USES MACROS: $CALL, $AL2, $SAVE, $RETURN                    *
*.        CALLS MXMVSR                                                *
*.        USES DSECTS: RSBLOCK, MXPNTSAV, MCOPQUAD, AVWXTABL          *
*.                                                                    *
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXERRM   CSECT
         $SAVE RGS=(R14-R6),BR=R13,SA=*
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MXERRM ENTERED***',T=NO,                      X
               IF=(AVMSNBY2,O,$MSNP13,TM)
         USING RSBLOCK,RW          NOTE USING FOR SOURCE BLOCK
         L     RW,AVRSBPT          SET BASE FOR SOURCE
         USING MXPNTSAV,RE         MACRO BLOCK                        A
         L     RY,MXPNCRCD         CURRENT INSTRUCTION                A
         USING MCOPQUAD,RY         NOTE USING                         S
         MVC   RSBLOCK(RSB$L),=AL1(0,$RSBNPNN+$RSBMERR,1,0)           S
         LA    R1,MXMSSGS          ADDRESS OF MESSAGES                A
         AH    R1,MXERRPTR(RB)     @ SPECIFIC MSG                     A
         USING MSGBLOCK,R1                                            A
         SR    R2,R2               CLEAR R2                           A
         IC    R2,MSGLENM1         GET LENGTH-1 OF MSG & NUMBER       A
         EX    R2,MXERRMVC         MOVE IT IN                         A
*  1ST PART (MSG) NOW DONE                                            A
*  NOW FILL IN STM NUMBER, OTHER DATA                                 A
*  R2 WILL BE ACCUMUALTION OF L-1                                     A
         LA    RA,RSBSOURC+1(R2)   @ NEXT BYTE                        A
         MVC   0(MXERRS$L,RA),MXERRSTN  STMT NUMBER EDIT PATTERN      A
         ED    L'MXERRSTN(6,RA),MCQSTMNO                              A
         L     RY,MXPNMCLB         GET MACRO PTR                      A
         USING MACLIB,RY                                              A
         MVC   MXERRS$L(L'MCLBNAM,RA),MCLBNAM                         A
         LA    RB,MXMSSGS(RB)      ADD @ BEGINNING OF TABLE
         LA    R2,MXERRS$L+L'MCLBNAM(R2)  BUMP L-1                    A
         DROP  RE,RY                                                  A
         LA    RA,RSBSOURC+1(R2)   BUMP PTR FOR MSG OUTPUT            A
*        MSGFLAG = 0               MSG #                              S
*                  4               NUMERICAL                          S
*                  8               CHAR VALUE                         S
*                                                                     S
         CLI   MSGFLAG,X'04'       COMPARE VALUE                      S
         BL    MXERFOOT            IF LOW, DONE.
         MVC   0(3,RA),=C'-->'     MOVE POINTER TO RSBSOURC
         LA    RA,3(RA)            BUMP SCAN POINTER
         LA    R2,3(R2)            BUMP LEN-1
         BH    MXERRM0C            CHAR STRING IF HIGH
         SPACE
MXERRM0A EQU   *                   FALL THRU FOR ARITH TYPR
         LA    R1,AVMWRK1+11       POINT TO END OF EDIT MASK
         LA    RE,1(R1)            POINT RE TO DELIMMPAST MASK
         CVD   RC,AVDWORK1         CONVERT VALUE TO PACKED DEC
         MVC   AVMWRK1(12),MXEEP12  MOVE EDIT MASK TO WORK AREA
         EDMK  AVMWRK1(12),AVDWORK1+2  EDIT AND MARK VALUE
         SR    RE,R1               GET LENGTH OF STRING
         BCTR  R1,0                DECR POINTER TO SIGN POSIT
         EX    RE,MXMVSTRN         MOVE CHAR VALUE TO OUTPUT
         LTR   RC,RC               NEG VALUE?
         BNL   MXERRMA1            SKIP IF NOT
         MVI   1(RA),C'-'          ELSE INSERT MINUS SIGN
MXERRMA1 EQU   *
         LA    R2,2(RE,R2)        BUMP LENGTH
         B     MXERFOOT            JUMP TO FOOT
MXERRM0C EQU   *
         LR    R1,RC               MOVE @ OF STRING TO R1
         LA    RE,RSOL1-2                                             A
         SR    RE,R2               SUBTRACT CURRENT L-1               A
         CR    RD,RE               VALUE LEN OK?
         BNH   MXERRMC1            PROCEED IF OKAY
         LR    RD,RE               ELSE SUB OKAY LENGTH
MXERRMC1 EQU   *
         LA    R2,1(RD,R2)         GET TOTAL L-1                      A
         LTR   RD,RD               NULL STRING?
         BZ    MXERFOOT            FINI IF YES
         EX    RD,MXMVSTRN         MOVE STRING TO OUTPUP
*              FALL THRU INTO MXERFOOT.
MXERFOOT EQU   *
         STC   R2,RSBLENG          PUT LEN-1 IN OUTPUT
         $CALL MXMVSR              MOVE STMT TO HIGH AREA
         SPACE
         XSNAP LABEL='***MXERRM EXITED***',T=NO,                       X
               IF=(AVMSNBY2,O,$MSNP13,TM)
         SPACE
         $RETURN  RGS=(R14-R6)
         SPACE
MXERRMVC MVC   RSBSOURC($),MSGNMBR                                    A
MXMVSTRN MVC   1($,RA),0(R1)       DUMMY TO MOVE STRING
MXEEP12  DC    X'402020202020202020202120'    12 BYTE DEC MASK
MXMSSGS  EQU   *
MXACTRMS $MSG  221,' ACTR COUNTER EXCEEDED'                           A
MXDMSNMS $MSG  222,' INVALID SYM PAR OR SET SYMBL SUBSCRIPT',FLAG=4   A
MXSBSTMS $MSG  223,' SUBSTRING EXPRESSION OUT OF RANGE',FLAG=4        A
MXCVCAMS $MSG  224,' INVALID CONVERSION, CHAR TO ARITH',FLAG=8        A
MXCVABMS $MSG  225,' INVALID CONVERSION, ARITH TO BOOLEAN',FLAG=4     A
MXCVCBMS $MSG  226,' INVALID CONVERSION, CHAR TO BOOLEAN',FLAG=8      A
MXATTRMS $MSG  227,' ILLEGAL ATTRIBUTE LIST'                          A
MXSYSLMS $MSG  228,' &&SYSLIST SUBSCRIPT OUT OF RANGE',FLAG=4         A
MXSYERMS $MSG  229,' ASSIST CANNOT EXPAND--SIMPLIFY STMT OR USE .' CPP
MXERBFM  $MSG  230,' INTERNAL CHAR BUFFER EXCEEDED'                   A
MXEXSTMS $MSG  231,' MSTMG LIMIT EXCEEDED'                            A
MXZDIVMS $MSG  232,' ZERO DIVIDE OR FIXED POINT OVERFLOW'             A
MXPRVR   $MSG  217,' STMT NOT PROCESSED: PREVIOUS ERROR'              A
MXERRSTN DC    C': STMT/MACRO',X'402020202120',C'/'                   S
MXERRS$L EQU   *-MXERRSTN                                             A
MXERRPTR $AL2  MXMSSGS,(MXACTRMS,MXDMSNMS,MXSBSTMS,MXCVCAMS,MXCVABMS,MXX
               CVCBMS,MXATTRMS,MXSYSLMS,MXSYERMS,MXERBFM,MXEXSTMS,MXZDIX
               VMS,MXPRVR),-2                                         A
         LTORG
         DROP  RAT,RW                                                 A
         TITLE '***MXMVSR - MOVES GENERATED STMT TO HIGH CORE***'
**-->  CSECT:  MXMVSR  MOVES GENERATED STMT FROM RSBLOCK TO HIGH FREE *
*.        AREA. AVGEN2CD POINTS TO BEGINNING OF STMT                  *
*.                                                                    *
*.        EXIT CONDITIONS                                             *
*.     RB = ZERO IF OKAY ELSE 4 IF OVERFLOW                           *
*.                                                                    *
*.        USES MACROS: $SAVE, $RETURN, $MALLOCH                       *
*.       USES DSECTS RSBLOCK,REBLK,AVGEN1CD,AVGEN2CD                  A
*.                                                                    *
*.       REGISTER USAGES                                              A
*.       RAT-MAIN TABLE USING                                         A
*.       RW-SOURCE BLK USING                                          A
*.       RX-ERROR BLK USING                                           A
*.       R1,RB-BYTE REGISTERS                                         A
*.       RA-WORK REGISTER                                             A
*.                                                                    A
*.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MXMVSR   CSECT
         $SAVE RGS=(R14-R4),SA=NO                                     A
         USING AVWXTABL,RAT        NOTE MAIN TABLE USING
         XSNAP LABEL='***MXMVSR ENTERED***',T=NO,                      X
               IF=(AVMSNBY2,O,$MSNP13,TM)
         USING RSBLOCK,RW          NOTE SOURCE USING
         L     RW,AVRSBPT          SET BASE FOR RSBLOCK
         USING REBLK,RX            SET USING FOR ERROR BLOCK
         LA    RX,AVREBLK          SET BASE FOR ERROR BLOCK
         SR    R1,R1
         SR    RB,RB
         TM    RSBFLAG,$REBX       EROOR BLOCK EXISTS?
         BZ    MXMVSR01            JUMP AROUND IF NO
         IC    RB,REBLN            GET LEN-1 OF ERR BLOCK
         STC   RB,RSBNUM           PUT ERR BLOCK LEN IN RSB
*              REBLN IS ACTUAL LENGTH OF PART OF REBLK TO BE MOVED,
*              SINCE IT IS L-1 OF WHOLE THING (COUNTING REBLN)
MXMVSR01 EQU   *
         IC    R1,RSBLENG          GET LEN-1 OF STMT
         LA    RB,RSB$L+1(RB,R1)   GET TOTAL LENGTH FOR ENTIRE SECT
         $MALLOCH RA,RB,OVRFL=MXMVOVR    GET STORAGE FOR STMT
         TM    RSBFLAG,$REBX       ERROR BLOCK?
         BZ    MXMVSR02            SKIP IF NO
         IC    RB,REBLN            GET LEN-1 OF ERR BLOCK
         BCTR  RB,0                GET LENGTH-1 OF PART TO BE MOVED
         LA    RX,1(RX)            BUMP REBLK PTR TO PART BEING MOVED
         EX    RB,MXMVSRCE         MOVE ERRBLOCK TO HIGH STORAGE
         LA    RA,1(RA,RB)         GET ACTUAL LENGTH MOVED
MXMVSR02 EQU   *
         LA    RX,RSBSOURC         PUT @ OF SOURCE IN RX FOR EX INST
         EX    R1,MXMVSRCE         MOVE STMT TO HIGH CORE
         AR    RA,R1               BUMP PTR TO LAST CHAR              A
         MVC   1(RSB$L,RA),RSBLOCK MOVE FLAG BYTE ETC                 A
         SR    RB,RB               CLEAR RB FOR RETURN
MXMVRTN  EQU   *
         MVC   RSBLOCK(RSB$L),AWZEROS   ZERO STANDARD PART OF RSBLOCK
         MVC   RSBSOURC($LMSRCMX),AWBLANK   BLANK REMAINDER OF RECORD
         SPACE
         AIF   (&$DEBUG).MACQQ09   SKIP IF NO DEBUG
         L     R1,AVGEN2CD         GET POINTER TO NEW STMT
         XSNAP LABEL='***MXMVSR EXITED***',STORAGE=(*0(R1),*128(R1)),  X
               IF=(AVMSNBY2,O,$MSNP13,TM)
.MACQQ09 ANOP
         SPACE
         $RETURN RGS=(R14-R4),SA=NO                                   A
         SPACE
MXMVOVR  EQU   *
         LA    RB,4                SET OVERFLOW FLAG
         B     MXMVRTN             RETURN
MXMVSRCE MVC   0($,RA),0(RX)       DUMMY TO MOVE STIRNG TO HIGH
         LTORG
         DROP  RAT,RW,RX,REP
.MAXXXX  ANOP
