         PRINT ON,NOGEN
         TITLE 'ASSIST VERSION 4.0/A - MARCH 1975'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        PENNSYLVANIA STATE UNIVERSITY COMPUTER SCIENCE DEPARTMENT    *
*        PROJECT SUPERVISION: GRAHAM CAMPBELL                         *
*        PROGRAM DESIGN, CODING, DOCUMENTATION: JOHN R. MASHEY.       *
*        DOS/360 CONVERSION, $SPIE, XXXXSPIE: SCOTT A. SMITH.         *
*                                                                     *
*        PROGRAM WRITTEN BEGINNING SUMMER 1969.                       *
*        FIRST BATCH USAGE:  SPRING TERM, 1970.                       *
*        FIRST USAGE ON STUDENT REMOTE TERMINALS: FALL TERM, 1970.    *
*        FIRST DISTRIBUTION TO OTHER INSTALLATIONS: SUMMER 1971.      *
*        FIRST DISTRIBUTION (DOS/360 VERSION) : FALL 1971.            *
*                                                                     *
*        DISK UTILITY (DISKU) FACILITY (XXXXDK##, UTOPRS CHANGES):    *
*              RICHARD FORD, PAUL WEISSER - SPRING 1972.              *
*        XHEXI, XHEXO ADDITIONS: ALAN ARTZ - SPRING 1972.             *
*        S/370 INSTRUCTIONS: CHARLES JOHNSON - SPRING 1972.           *
*        MACRO PROCESSOR - GRAHAM CAMPBELL - SPRING, SUMMER 1972.     *
*        LIBRARY MACRO FETCH AND PROCESSING: RICHARD FORD, SUMMER 1972*
*        IMPROVED MACRO PROCESSOR, OPEN CODE ALAN ARTZ,               *
*              JOHN STERNBERGH - FALL,WINTER 1972 - 73                *
*        DOS DISK UTILITY - RICHARD FORD - WINTER 1973                *
*        EXTENDED I/O PACKAGE, XGET - XPUT - RICHARD FOWLER -         *
*              FALL 1972                                              *
*        CROSS-REFERENCE- ALAN ARTZ, ALICE FELTE, RICH LONG -         *
*              SPRING, SUMMER 1973.                                   *
*        EXTENDED INTERPRETER- MARK DALTON, JOHN STERNBERGH, RICH     *
*              LONG - SPRING, SUMMER, FALL 1973.                      *
*        DOCUMENTATION UPDATE- GLENN FADNER - FALL 1973, WINTER 1974. *
*                                                                     *
*         MANY THANKS TO SHELLY GEARHART FOR HELP WITH DISTRIBUTION   *
*         MATERIALS.  SPECIAL THANKS TO KAREN HOERTER (PSU CC PROGRAM *
*         LIBRARIAN)FOR HANDLING OF ASSIST TAPE DISTRIBUTION, AND FOR *
*         FACING MASSIVE PILE OF TAPES WITHOUT MOANING (TOO MUCH).    *
* * * * * NOTES ON DISTRIBUTION VERSIONS OF ASSIST  * * * * * * * * * *
*                                                                     *
*        VERSION   DATE AVAIL.     COMMENTS                           *
*                                                                     *
*        1.2/A1    09/01/71        ORIGINAL DISTRIBUTION VERSION      *
*                                                                     *
*        1.3/A     04/01/72        CONTAINS DOS/360 CODE, FIXES BUGS  *
*                                                                     *
*        2.0/A     08/72(APPROX)   MACRO PROCESSOR, S/370, DISK OPTION*
*                                  FOR INTERMEDIATE STORAGE IF NEEDED.*
*              PREPARED BY: RICHARD FORD + JRM                        *
*                                                                     *
*        2.1/A     02/01/73        OPEN CODE, DOS DISKU, XGET - XPUT  *
*              PREPARED BY: ALAN ARTZ, ALICE FELTE + JRM              *
*                                                                     *
*        3.0/A     08/01/73        XREF, HASP AUTOBATCH, OVERLAYS     *
*              PREPARED BY: RICH LONG + JRM                           *
*                                                                     *
*        3.0/B     03/01/74        EXTENDED INTERPRETER,DOCUMENTATION *
*                                    UPDATES.                         *
*              PREPARED BY: MARK DALTON, GLENN FADNER, RICH LONG      *
*                                                                     *
*        4.0/A     3/01/75         CLEANS UP 3.0/B                    *
*                                  EXTENDED INTERP., ETC              *
*           PREPARED BY THOMAS MINSKER                                *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE '*** XCHAR MACRO - SAFE RIGHT-END SUBSTRING MACRO ***'
         MACRO
         XCHAR STRING,NUM                                             00
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCHAR      RETURN SAFE RIGHT-END SUBSTRING OF A STRING.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO RETURNS IN XXCHAR THE NUM CHARACTERS TAKEN FROM * 00
.*       THE RIGHT END OF THE CHARACTER STRING STRING, WITHOUT       * 0
.*       BLOWING UP IF THERE ARE LESS THAN NUM CHARS IN STRING.     * 00
.*       THIS MACRO IS USED BY XSAVE,XRETURN, AND XSRNR               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  XXCHAR             RETURN RESULT IN THIS                0
         AIF   (NUM GT K'STRING).XGA       SKIP IF HE WANTS MORE      00
XXCHAR  SETC  'STRING'(K'STRING+1-NUM,NUM)        SCOOP RIGHT AMT  00026
         MEXIT
.XGA     ANOP
XXCHAR  SETC  'STRING'           STRING SMALLER-USE WHOLE THING       00
         MEND
         TITLE 'XDECI MACRO - EXTENDED DECIMAL INPUT CONVERSION'
         MACRO
LABEL   XDECI REG,ADDRESS                                            000
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION              *
.*--> MACRO: XDECI      EXTENDED DECIMAL INPUT CONVERSION * * * * * * *
.*             EXTENDED DECIMAL INPUT MACRO - ENABLES PROGRAMS        *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       USES MODULE XXXXDECI TO SCAN DECIMAL STRING BEGINNING AT     *
.*       ADDRESS, CONVERT ITS VALUE INTO REGISTER REG, AND SET      * 00
.*       REGISTER R1 AS A SCAN POINTER TO THE DELIMITER FOLLOWING THE *
.*       STRING OF DECIMAL DIGITS.  THE CONDITION CODE IS SET BY THE  *
.*       VALUE IN REG, UNLESS AN ERROR OCCURRS, IN WHICH CASE CC=3.  * 0
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  XLABL              FOR CREATION OF LABEL                0
XLABL   SETC  'XXSYSNDX.E'       CREATE UNIQUE LABEL                  00
         CNOP  2,4  .              LINE UP ON BOUNDARY
LABEL   STM   14,1,XLABL  .      SAVE LINKAGE REGS                    00
         LA    0,ADDRESS .        BEGINNING @ FOR SCANNING             0
         L     15,XLABL-4  .      GET ADCON FOR CONVERSION             0
         BALR  14,15 .             CALL ROUTINE, PT WITH R14
         DC    V(XXXXDECI) .       ADCON FOR CONVERSION ROUTINE
XLABL   DS    5F .                REGS 14,15,0,1, VALUE FOR REG       00
         LM    14,1,4(14) .        RELOAD REGS
         BO    *+8 .               BRANCH IF REG SHOULDN'T CHANGE      0
         L     REG,XLABL+16  .   GET VALUE FOR REG                   000
         AIF   (T'REG EQ 'N' AND 'REG' NE '1').XXEXIT SKIP IF SAFE    00
         L     1,XLABL+12  .      USER MAY HAVE REG=1, LOAD FOR SAFE   0
.XXEXIT  MEND
         TITLE 'XDECO MACRO - EXTENDED DECIMAL OUTPUT CONVERSION'
         MACRO
LABEL   XDECO REG,ADDRESS                                            000
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XDECO      EXTENDED DECIMAL OUTPUT CONVERSION            *
.*       USES MODULE XXXXDECO TO CONVERT VALUE IN REGISTER REG TO    * 0
.*       AN EDITED 12-BYTE FIELD, WITH SIGN, AT LOCATION ADDRESS.    * 0
.*             EXTENDED DECIMAL OUTPUT MACRO - ENABLES PROGRAMS       *
.*       WRITTEN FOR ASSIST TO BE RUN UNDER OS/360 DIRECTLY.          *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  XLABL              FOR CREATION OF UNIQUE LABEL         0
XLABL   SETC  'XXSYSNDX.D'       CREATE UNIQUE LABEL                  00
         CNOP  2,4 .               LINE UP ON RIGHT BOUNDARY
LABEL   STM   14,0,XLABL  .      STORE LINKAGE REGS                   00
         ST    REG,XLABL+12  .   SAVE VALUE TO BE CONVERTED           00
         LA    0,ADDRESS .        OBTAIN @ OPERAND FILED               0
         L     15,XLABL-4  .      GET ADCON FOR CONVERSION PROG        0
         BALR  14,15 .             CALL XXXXDECO, PT R14
         DC    V(XXXXDECO) .       ADCON FOR CONVERSION PROG
XLABL   DS    4F .                REGS 14,15,0, REG TO BE CONVERTED    0
         LM    14,0,4(14) .        RELOAD LINKAGE REGISTERS
         MEND
         TITLE 'MACRO-->XHEXI EXTENDED HEXADECIMAL CONVERSION'
         MACRO
NAME    XHEXI REG,ADDR                                               000
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XHEXI  HEXADECIMAL INPUT CONVERSION MACRO.                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE STARTING AT THE ADDRESS GIVEN BY  *
.*  ADDR AND CONVERTS IT AND PUTS THE HEXADECIMAL VALUE IN REG.     * 00
.*  IF THERE ARE MORE THAN 8 DIGITS, R1 POINTS TO THE 9TH AND THE     *
.*  FIRST 8 ARE CONVERTED.  IF THERE IS A NON-BLANK, NON-HEX DIGIT    *
.*  FOUND, R1 POINTS TO THAT CHARACTER AND THE CC=3, OTHERWISE CC SET *
.*  BY VALUE IN REG.                                                  *
.*                                                                    *
.*       CALLS MODULE XXXXHEXI TO DO THE ACTUAL CONVERSIONS           *
.*                                                                    *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  LABEL                                                   0
LABEL   SETC  'XXSYSNDX.H'      UNIQUE LABEL                          00
NAME    STM   14,0,LABEL  .     SAVE REGISTERS                        00
         ST    REG,LABEL+12  .  REGISTER STORE INCASE OF OVERFLOW CND 00
         LA    0,ADDR  .         GET STRING TO BE CONVERTED            0
         CNOP  2,4  .             GET PROPER ALIGNMENT
         L     15,LABEL-4  .     ADDRESS OF XXXXHEXI                   0
         BALR  14,15  .           GO TO APPROPRIATE PLACE
         DC    V(XXXXHEXI)  .     VCON OF ROUTINE
LABEL   DS    4F  .              STORAGE FOR REGISTERS                 0
         LM    14,0,4(14)  .      RESTORE REGISTERS
         L     REG,LABEL+12  .  GET CONVERTED NUMBER                  00
         MEND
         TITLE 'MACRO-->XHEXO EXTENDED HEXADECIMAL CONVERSION'
         MACRO
NAME    XHEXO REG,ADDR                                               000
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XHEXO  HEXADECIMAL OUTPUT CONVERSION MACRO                *
.*                                WRITTEN BY ALAN ARTZ 4/17/72        *
.*       THIS MACRO TAKES THE VALUE IN REG AND CONVERTS IT TO        * 0
.*  PRINTABLE FORM.                                                   *
.*       IT PUTS THE CONVERTED VALUE IN AN EIGHT BYTE AREA STARTING AT*
.* THE ADDRESS GIVEN IN ADDR.                                        * 0
.*       THE CC AND REGISTERS ARE LEFT UNCHANGED.                     *
.*                                                                    *
.*       CALLS MODULE XXXXHEXO TO DO THE ACTUAL CONVERSIONS.          *
.*                                                                    *
.*       SEE ASSIST USER MANUAL FOR USAGE INSTRUCTIONS.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  LABEL                                                   0
LABEL   SETC  'XXSYSNDX.H'      UNIQUE LABEL                          00
NAME    DS    0H                                                       0
         STM   14,0,LABEL  .     SAVE REGISTERS                        0
         ST    REG,LABEL+12  .  SAVE REG                             000
         LA    0,ADDR   .        PASS REGISTER TO XXXXHEXO             0
         CNOP  2,4  .             GET PROPER ALIGNMENT
         L     15,LABEL-4  .     ADDRESS OF XXXXHEXO                   0
         BALR  14,15  .           CALL XXXXHEXO
         DC    V(XXXXHEXO)
LABEL   DS    4F  .              STORAGE FOR REGISTERS                 0
         LM    14,0,LABEL  .     RESTORE REGISTERS                     0
         MEND
         TITLE '*** XIDENT MACRO - CREATE ID FOR XSAVE MACRO ***'
         MACRO
         XIDENT ID,LABEL,XCSECT,PRIVATE                             0004
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIDENT     IDENTIFY ENTRY POINT FOR XSAVE,$SAVE.         *
.*       MACRO USED BY XSAVE TO PRODUCE ID AT AN ENTRY POINT.  WILL   *
.*       USE THE FIRST NON-NULL OPERAND PASSED TO IT AS THE ID.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  I,J                LOCAL COUNTERS                      00
I       SETA  1                    INITIALIZE                          0
         AIF   ('ID' NE '*').XIDINC         SKIP IF EXPLICIT ID FIELD  0
.XILOOP  ANOP
I       SETA  I+1                 INCREMENT TO NEXT ONE               00
         AIF   ('SYSLIST(I)' EQ '').XILOOP SKIP BACK IF THIS IS NULL  00
.XIDINC  ANOP
J       SETA  6+((K'SYSLIST(I)+1)/2)*2   GET BRANCH LENGTH           000
         B     J.(,15) .           BRANCH AROUND ID                    0
J       SETA  J-5                 GET ACTUAL LENGTH OF ID             00
         DC    AL1(J),CLJ'SYSLIST(I)'                               0006
         MEND
         TITLE ' *** XIONR-INNER MACRO FOR XREAD,XPRNT,XPNCH ***'
         MACRO
XLABEL  XIONR XNAME,XNUM,XAREA,XDEFT                               00074
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XIONR      INNER MACRO-$READ,$PNCH,$PRNT,$SORC           *
.*                                 ALSO XGET,XPUT,$GET,AND$PUT        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XIONR IS USED BY XIOPAK MACROS XREAD,XPRNT,XPNCH TO SET UP   *
.*       THE REQUIRED CODE FOR CALLING THEIR RESPECTIVE SUBROUTINES.  *
.*       *** ARGUMENTS ***                                            *
.*       XNAME     THE NAME OF THE I/O ROUTINE TO BE CALLED.          *
.*       XNUM      THE LENGTH OF XAREA TO BE PRINTED,PUNCHED,ETC.     *
.*       XAREA     THE AREA ON WHICH I/O OPERATION TO BE PERFORMED.   *
.*             MAY BE SPECIFIED BY (0) OR (R0).                       *
.*       XDEFT     DEFAULT VALUE OF XNUM TO BE USED, IF IT IS OMITTED *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'XAREA EQ 'O').XERR1       PRODUCE MNOTE              0
XLABEL  STM   14,0,XXSYSNDX.R+4 .    SAVE REGS WHICH WILL BE CHANGED  00
         AIF   (T'XNUM EQ 'O').XN1    SKIP NEXT CHECK IF OMITTED       0
         AIF   ('XNUM'(1,1) NE '(' OR 'XNUM'(K'XNUM,1) NE ')').XN1   001
         STH   XNUM,XXSYSNDX.R+16 .       STORE LENGTH                00
.XN1     AIF   ('XAREA' EQ '(0)' OR 'XAREA' EQ '(R0)').XNOLA          00
.XN2     LA    0,XAREA                                                 0
.XNOLA   L     15,XXSYSNDX.R  .   GET BRANCH ADDRESS                   0
         CNOP  2,4  .              ADJUST FOR RIGHT ALIGNEMNT
         BALR  14,15 .             CALL ROUTINE, R14==> CONTROL BLOCK
XXSYSNDX.R DC V(XNAME)  .        ROUTINE ADDRESS                      00
         DS    3F .                SAVE SPACE FOR REGS 14-0
         AIF   ('XNUM' EQ '').XDFT         SKIP IF DEFAULT SHOULD BE   0
         DC    AL2(XNUM) .        LENGTH OF AREA                       0
         AGO   .XDS                SKIP
.XDFT    DC    AL2(XDEFT) .       DEFAULT LENGTH USED                  0
.XDS     LM    14,0,4(14) .        RESTORE REGS. CON CODE ALREADY DONE
         MEXIT
.XERR1   MNOTE 0,'**XIONR- AREA ADDRESS OMITTED-GENERATION CANCELLED'
         MEND
         TITLE '*** XLOOK MACRO - LOOK UP ELEMENT IN LIST ***'
         MACRO
         XLOOK ARG1,ARGL                                              00
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XLOOK      FIND POSITION OF ELEMENT IN LIST.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       MACRO TO FIND AND RETURN POSTION OF ARGUMENT IN A SUBLIST.   *
.*       ARG1 ARGUMENT TO BE SEARCHED FOR                            * 0
.*       ARGL LIST OF ARGUMENTS FOR ARG1 TO BE CHECKED FOR IN       * 00
.*       XXLOOK   THE FIRST POSITION IN ARGL IN WHICH ARG1 IS      * 001
.*       FOUND, IF ANY.  IF ARG1 IS NOT IN ARGL, XXLOOK = 0.       * 001
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  XXLOOK             FOR RETURN OF INDEX VALUE            0
XXLOOK  SETA  1                   INITIALIZE THE COUNTER               0
.XLA     AIF   (XXLOOK GT N'ARGL).XLB     IF GT,QUIT,NOT FOUND        00
         AIF   ('ARG1' EQ 'ARGL(XXLOOK)').XXEXIT   IF FOUND,RETURN   001
XXLOOK  SETA  XXLOOK+1           INCREMENT COUNTER                    00
         AGO   .XLA                GO BACK FOR NEXT CHECK
.XLB     ANOP
XXLOOK  SETA  0                   NOT FOUND, SET TO 0 TO SHOW THIS     0
.XXEXIT  MEND
         TITLE ' *** XMUSE - INNER MACRO FOR XSAVE-MULTIPLE USING ***'
         MACRO
         XMUSE BR,AD                                                  00
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XMUSE      BASE REGISTER SETUP MACRO FOR XSAVE           *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       THIS MACRO IS CALLED BY XSAVE TO HANDLE BR AND AD OPERANDS,  *
.*       AND PRODUCE APPROPRIATE USINGS.  BR AND AD ARE FROM XSAVE. * 00
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  I,N               LOCAL COUNTERS                       00
         LCLC  B(4),V            BASE REGS, USING NAME                00
N       SETA  N'BR               GET NUMBER WHERE HANDY               00
V       SETC  '*'                 NORMAL USE                           0
         AIF   (N LE 4).XNOKA     MAKE SURE NOT TOO MANY BASES         0
N       SETA  4                   IDIOT USER HAD >4 BASES, IGNORE EXTR 0
         MNOTE 4,'**XMUSE- MORE THAN 4 BASE REGS-EXTRAS IGNORED'
.XNOKA   AIF   ('AD' EQ '').X1LOOP         SKIP IF NORMAL SITUATION    0
.*             USED IF AD PARAMATER WAS SPECIFIED IN XSAVE MACRO.     *
         CNOP 0,4
         B     *+8 .               SKIP AROUND ADDRESS CONSTANT
         DC    A(AD)       .      ADDRESS CONSTANT FOR AD=PARAMETER    0
         L     BR(1),*-4 .        LOAD ADCON INTO RIGHT REGISTER       0
V       SETC  'AD'               CHANGE NAME FOR USING 1ST OPERND     00
.*             NORMAL SECTION OF CODE FOR GENERATING USING.           *
.X1LOOP  ANOP
I       SETA  I+1      INCREMENT COUNTER TO BASE REG                  00
B(I)   SETC  ',BR(I)'          GET I'TH BASE REGISTER               0022
         AIF   (I LT N).X1LOOP   CONTINUE UNTIL ALL BASE REGS DONE    00
         DROP  15 .                CLEAN UP USING SITUATION
         USING VB(1)B(2)B(3)B(4)                                   00234
         MEND
         TITLE '*** XRETURN MACRO - EXTENDED RETURN MACRO ***'
         MACRO
LABEL   XRETURN RGS=(14-12),SA=,RC=,RP=,T=,TR=*,REEN=           00336000
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XRETURN    GENERAL RETURN MACRO, OS LINKAGE              *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED RETURN MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN   *
.*       FOR EXPLANATION AND USE OF OPERANDS.                         *
.*       USES MACROS: FREEMAIN,XCHAR,XSRNR                            *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  XRETUST            =0 TRACE GENERATION OK, =1 NO TRACE  0
         GBLC  XSAVE,XXCHAR      STD SAVE AREA NAME, XCHAR VARIABLE   00
         LCLA  I                  LOCAL COUNTER                        0
         LCLB  RCA,RCB           FOR CONTROL OF RETURN CODE GENER     00
.*                                                                    *
.*       GENERATE LABEL IF THERE IS ONE, GENERATE TRACE CODE IF IT    *
.*       IF DESIRED, AND SET UP LCLB VARIABLES TO DESCRIBE RETURN     *
.*       CODE CONDITIONS. GENERATE LR IF NEEDED FOR RC OPTION.        *
.*                                                                    *
         SPACE 1
         AIF   (T'LABEL EQ 'O').XNOLB       SKIP IF NO LABEL USED      0
LABEL   DS    0H .                DEFINE LABEL                         0
.XNOLB   AIF   ('TR' EQ 'NO' OR XRETUST).XNORT       SKIP IF NO TRACE 00
         XSRTR TR,LABEL,EXITED   GET TRACE GENERATED                  00
.XNORT   ANOP
RCA     SETB  (T'RC EQ 'O')      TRUE IF WHOLE THING OMITTED          00
RCB     SETB  (1)                 SET THIS WAY FOR NEXT TEST           0
         AIF   (RCA).XNRCB        SKIP IMMEDIATELY IF OMITTED          0
RCB     SETB  ('RC'(1,1) NE '(' OR 'RC'(K'RC,1) NE ')')  NOT RG TYP 0038
         AIF   (RCB).XNRCB       SKIP IF NOT REGISTER TYPE             0
         XCHAR RC,3               GET LAST 3 CHARS                     0
         AIF   ('XXCHAR' EQ '15)').XNRCB    SKIP IF ALREADY IN 15      0
         LR    15,RC .            LOAD RETURN CODE FROM DESIRED REG    0
.XNRCB   AIF   (T'REEN EQ 'O').XNORM        SKIP IF NOT REENTRANT      0
.*                                                                    *
.*       REENTRANT RETURN CODE GENERATION - OBTAIN ADDRESS AND LENGTH *
.*       OF AREA FROM WHERE XSAVE PUT THEM,DO FREEMAIN,FIXUP REGS.    *
.*                                                                    *
         AIF   ('TR' EQ 'NO' OR XRETUST).XGOK        MAKE SURE REENT  00
         MNOTE 0,'**XRETURN- TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    L     13,4(13) .          GET OLD SA POINTER BACK
         STM   15,1,16(13) .       SAVE REGS FROM FREEMAIN CRUNCHING
         L     1,8(13) .           GET ADDRESS OF AREA BACK
*        FREEMAIN R,LV=8*((REEN+79)/8),A=(1)          FREE STORAGE     0
         FREEMAIN R,LV=8*((REEN+79)/8),A=(1)          FREE STORAGE     0
         LM    15,1,16(13) .       RESTORE THE REGS
         AGO   .XNORM1             GO TO PROCESS REGISTER RESTORATION
.XNORM   AIF   ('CSA' EQ 'NO').XNORM1        SKIP RESTORATION IF UNUSED
.*                                                                    *
.*       REGISTER RESTORATION CODE - RESTORE REGS FROM CALLER'S       *
.*       SAVE AREA,DEPENDING ON RETURN CODE AND FUNCTION OPTIONS.     *
.*                                                                    *
         L     13,4(13) .          RESTORE PREVIOUS SAVE AREA POINT
.XNORM1  AIF   ('RGS' EQ 'NO').XNORM2A     SKIP IF NO REGS NEEDED      0
         AIF   ('RGS' NE '(14-12)' OR NOT RCB).XNORM2                 00
         LM    14,12,12(13) .      STANDARD REGISTER RESTORATION
         AGO   .XNORM2A            CONTINUE
.XNORM2  ANOP
I       SETA  I+1                INCREMENT COUNTER                    00
         XSRNR L,RGS(I),RCB     HAVE RESTORE CODE GENRATED           004
         AIF   (I LT N'RGS).XNORM2        LOOP UNTIL DONE             00
.*                                                                    *
.*       RETURN CODE(15) AND RETURN PAST(14) CODE GENERATION.         *
.*                                                                    *
.XNORM2A AIF   (RCA OR NOT RCB).XNORM3    SKIP IF NOT LA TYPE RC=     00
         LA    15,RC .            PUT RETURN CODE IN 15                0
.XNORM3  AIF   ('T' NE '*').XNORM4          SEE IF MVI WANTED          0
         MVI   12(13),X'FF' .      SHOW WE HAVE RETURNED
.XNORM4  AIF   (T'RP EQ 'O').XNORP          SKIP IF RP NOT USED        0
         B     RP.(14) .          RETURN GIVEN NUMBER PAST 14          0
         AGO   .XNORM5
.XNORP   BR    14 .                RETURN NORMALLY TO CALLER
.*                                                                    *
.*       SAVE AREA GENERATION - IF A SAVE AREA SHOULD BE CREATED,     *
.*       USE EITHER ONE SPECIFIED BY MACRO,OR ELSE STANDARD ONE.      *
.*                                                                    *
.XNORM5  AIF   (T'SA EQ 'O' OR 'SA' EQ 'NO').XEXIT   SKIP IF NO SAV5  00
         AIF   ('SA' EQ '*').XSASTD         IF *,USE STANDARD SAVE     0
SA      DC    18F'0' .            SAVE AREA,NAMED BY MACRO             0
         AGO   .XEXIT
.XSASTD  ANOP
XSAVE   DC    18F'0' .            SAVE AREA,USING GENERATED NAME       0
.XEXIT   SPACE 1
         MEND
         TITLE '*** XSAVE - EXTENDED SAVE MACRO ***'
         MACRO
LABEL   XSAVE RGS=(14-12),BR=12,SA=*,ID=*,TR=*,REEN=,OPT=,AD=  00504000
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSAVE      EXTENDED SAVE MACRO - OS LINKAGE.             *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       EXTENDED SAVE MACRO - SEE PSU CC WRITEUP - XSAVE/XRETURN     *
.*       FOR DESCRIPTION OF ARGUMENTS FOR THIS MACRO                  *
.*       USES MACROS: GETMAIN,XCHAR,XIDENT,XLOOK,XMUSE,XSRNT,XSRTR    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  XXLOOK             RETURN VARIABLE FROM XLOOK MACRO     0
         GBLB  XSAVEST            =0 TRACE GEN OK, =1 NO TRACE DONE    0
         GBLC  XSAVE,XCSECT,XXCHAR  STD NAME,CSECT NAME,XCHAR VAR    005
         LCLA  I                  LOCAL COUNTER                        0
         LCLB  XNSECT             FLAG FOR NEW CSECT                   0
         LCLC  B1,BT             1ST BASE,LAST 2 CHARS OF 1ST BASE    00
B1      SETC  'BR(1)'            GET FIRST OR ONLY BASE IN EASIER NAM 00
         XCHAR B1,2               GET LAST 2 CHARS OF BASE REG         0
BT      SETC  'XXCHAR'           GET LAST 2 CHARACTERS                00
XNSECT  SETB  ('SYSECT' NE 'XCSECT')      NOTE IF NEW CSECT NEEDED   005
XCSECT  SETC  'SYSECT'           SET TO SYSECT, FOR NORMAL USE        00
.*                                                                    *
.*       CHECK OPT FIELD - GENERATE TITLE AND/OR ENTRY OR CSECT       *
.*       STATEMENTS, DEPENDING ON CONTENTS OF OPT FIELD, IF USED.     *
.*                                                                    *
         AIF   (T'OPT EQ 'O').XNOPS         SKIP IF OPT UNUSED         0
         XLOOK TITLE,OPT           WAS TITLE OPTION USED               0
         AIF   (XXLOOK EQ 0).XNTITL         SKIP IF TITLE NOT USED     0
         AIF   (N'OPT EQ 1).XNOPS SKIP IF TITLE ONLY                   0
         TITLE '*** LABEL ***'                                         0
.XNTITL  XLOOK ENTRY,OPT           WAS ENTRY USED                      0
         AIF   (XXLOOK EQ 0).XTRCS         SKIP IF NOT USED            0
         AIF   ('LABEL' EQ '').XENTE        SKIP TO ERR IF NO LABEL    0
         ENTRY LABEL  .            NOTE XSAVE ENTRY OPTION             0
         AGO   .XNOPS
.XENTE   MNOTE 4,'**XSAVE- OPT=ENTRY USED WITHOUT LABEL-OPTION IGNORED'
         AGO   .XNOPS
.XTRCS   XLOOK CSECT,OPT           CHECK FOR CSECT OPTION              0
         AIF   (XXLOOK EQ 0).XTRCS1        SKIP IF OPTION NOT THERE    0
LABEL   CSECT                                                          0
XCSECT  SETC  'LABEL'            SET THIS TO SHOW NEW CSECT           00
XNSECT  SETB  (1)                  NOTE THAT NEW CSECT IS NEEDED       0
         AGO   .XENT1               SKIP OVER LABEL DEFN               0
.XTRCS1  MNOTE 0,'**XSAVE- UNKNOWN OPT=OPT- IGNORED'                   0
.*                                                                    *
.*       CREATE STATMENT LABEL IF ANY. IF IDENTIFIER REQUESTED,USE    *
.*       SPECIFIED IDENTIFIER,STATEMENT LABEL,OR CSECT NAME IN XIDENT *
.*       TO GENERATE CORRECT IDENTIFIER WITH BRANCH AROUND IT.        *
.*                                                                    *
.XNOPS   SPACE 2
LABEL   DS    0H .                DEFINE LABEL,MAKE SURE ALIGNED       0
.XENT1   USING *,15 .              FOR TEMPORARY ADDRESSIBILITY
         AIF   ('SA' EQ '*' OR 'SA' EQ 'NO').XCHKS1 SKIP IF NO CHANGE 00
XSAVE   SETC  'SA'                EXPLICIT NEW SAVE AREA NAME         00
         AGO   .XSAOK
.XCHKS1  AIF   ('XSAVE' NE '').XCHKS2       SKIP IF NOT NULL           0
XSAVE   SETC  '$PR#SYSNDX'        SET UP DEFAULT SAVE AREA NAME       00
         AGO   .XSAOK
.XCHKS2  AIF   (NOT XNSECT).XSAOK SKIP IF NEW SAVE NOT NEEDED          0
XSAVE   SETC  'XCSECT'(1,3).'#SYSNDX'     DEFAULT SAVE AREA NAME     006
.*                                                                    *
.XSAOK   AIF   ('ID' EQ 'NO').XID3 SKIP IF NO ID WANTED                0
         XIDENT ID,LABEL,XCSECT,$PRIVATE CALL TO SET UP IDENT        006
.*                                                                    *
.*       IF TR OPTION IN EFFECT, CALL XSRTR TO GENERATE RIGHT CODE,   *
.*       THEN HAVE XSRNR GENERATE CODE TO SAVE RANGES OF REGISTERS    *
.*                                                                    *
.XID3    AIF   (XSAVEST OR 'TR' EQ 'NO').XNOTR       SKIP IF NO TRACE 00
         XSRTR TR,LABEL,ENTERED  GET TRACE GENERATED                  00
.XNOTR   AIF   ('RGS' NE '(14-12)').XSRCAL SKIP IF NOT STANDARD        0
         STM   14,12,12(13) .      SAVE STANDARD REGISTER SET
         AGO   .XCHK13
.XSRCAL  AIF   ('RGS' EQ 'NO').XCHK13       SKIP IF NO REGS SAVED      0
I       SETA  1                   INITIALIZE COUNTER                   0
.XSETUP  XSRNR ST,RGS(I)         CALL XSRNR WITH EACH REG SET         00
I       SETA  I+1                INCREMENT TO NEXT REGS SET           00
         AIF   (I LE N'RGS).XSETUP         CONTINUE PROCESSING RGS    00
.XCHK13  AIF   ('BT' NE '13').XNORM1       NOT REG 13,DO NORMALLY      0
.*                                                                    *
.*       REGISTER 13 DOUBLE USAGE - THIS SECTION GENERATES CODE TO    *
.*       USE REGISTER 13 BOTH AS A BASE AND AS THE SAVE AREA POINTER. *
.*                                                                    *
         AIF   (T'AD EQ 'O').XU2  SKIP TO NORMAL IF AD OMITTED        00
         LR    14,13 .             SAVE @ OLD SAVE AREA BEFORE SETTING
         XMUSE BR,AD             HAVE ADCON SET UP                    00
         ST    13,8(14) .          SAVE NEW POINTER INTO OLD SAVEAREA
         ST    14,4(13) .          SAVE OLD POINTER INTO NEW AREA
         AGO   .XEND1              GO FINISH UP
.XU2     CNOP  0,4
         ST    13,XSAVE+4 .       SAVE OLD SA POINTER INTO NEW AREA    0
         BAL   13,XSAVE+72 .      SET UP 13, BRANCH AROUND SA          0
         XMUSE BR                 SET UP WHATEVER USING REQUIRED       0
XSAVE   DC    18F'0'  .           SAVE A EA                            0
.XU3     L     15,XSAVE+4 .       GET OLD SA POINTER BACK TO SET LINKS 0
         ST    13,8(15) .          STORE NEW POINTER IN OLD AREA
         AGO   .XEND1              CHECK NUMBER OF BR'S,GET LA'S SET UP
.*                                                                    *
.XNORM1  AIF   (T'REEN EQ 'O').XNORM2       SKIP OVER REENTRANT        0
.*                                                                    *
.*       REENTRANT ENTRY CODE GENERATION - THIS GENERATES CODE TO     *
.*       ACQUIRE SPACE FOR SAVEAREA(72 BYTES) + AS MUCH MORE SPACE    *
.*       AS IS SPECIFIED IN REEN PARAMATER, IF USED.                  *
.*                                                                    *
         AIF   ('TR' EQ 'NO' OR XSAVEST).XGOK        MAKE SURE REENT  00
         MNOTE 0,'**XSAVE- USE OF TR OPTION IMPLIES NON-REENTRANT CODE'
.XGOK    ANOP
         GETMAIN R,LV=8*((REEN+79)/8) .GET CORE ROUNDED TO DBLWRD      0
         ST    13,4(1) .           STORE OLD POINTER IN NEW AREA
         ST    1,8(13) .           STORE (EW POINTER IN OLD AREA
         LR    B1,1 .             SAVE VALUE OF NEW SAVE POINTER       0
         LM    0,1,20(13) .        RESTORE PREVIOUS VALUES OF REGS
         LR    13,B1 .            POINT 13 TO NEW SAVE AREA            0
         AGO   .XNEWBS             GO GENERATE NEW BALR,USING
.*                                                                    *
.*       NORMAL,NON-REENTRANT ENTRY CODE SECTION.                     *
.*                                                                    *
.XNORM2  AIF   ('SA' EQ 'NO').XNEWBS        SKIP IF NO SAVE AREA       0
         ST    13,XSAVE+4 .       SAVE OLD POINTER IN NEW AREA         0
         AIF   ('BT' NE '15').XSN15         SKIP IF NOT 15             0
         LA    13,XSAVE .         GET ADDRESS OF NEW SAVE AREA         0
         L     B1,XSAVE+4 .      GET OLD SAVE POINTER BACK            00
         AGO   .XSOLD              GO SAVE NEW POINTER
.XSN15   LR    B1,13 .            MOVE OLD POINTER OVER                0
         LA    13,XSAVE    .      ADDRESS OF NEW SAVE AREA             0
.XSOLD   ST    13,8(B1) .         SAVE NEW POINTER IN OLD AREA         0
.*             SET UP BALR, LA'S IF REQUIRED, AND USING STATEMENT.    *
.XNEWBS  AIF   ('BT' NE '15' OR N'BR GT 1).XSET2  SKIP IF 15          00
         AIF   ('REEN' EQ '' AND 'SA' EQ 'NO' AND 'AD' EQ '').XEND2  007
.XSET2   AIF   (T'AD NE 'O').XSET3          SKIP BALR IF ADCON USED    0
         BALR  B1,0 .             SET UP NEW BASE REGISTER             0
.XSET3   XMUSE BR,AD             SET UP USINGS, ADCON IF NEEDED       00
.XEND1   AIF   (N'BR EQ 1).XEND2  IF ONLY 1 BASE,DON'T CALL XMUSE      0
I       SETA  2                    INITIALIZE                          0
.XA2A    LA    BR(I),4095 .       LOAD IN ADDRESS                     00
         LA    BR(I),1(BR(I),BR(I-1))  .   SET USING VALUES       007700
I       SETA  I+1                 INCREMENT TO NEXT BASE              00
         AIF   (I LE N'BR AND I LE 4).XA2A         LOOP FOR # BASES  007
.XEND2   SPACE 1
         MEND
         TITLE '*** XSNAP MACRO DEFINITION ***'
         MACRO
XLABEL  XSNAP T=PR,LABEL=,STORAGE=,IF=                             00784
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSNAP      EXTENDED SNAP MACRO-DEBUGGING-DUMPING.        *
.*                                 JOHN R. MASHEY - FEB 1970 - V.4.0  *
.*       XSNAP     IS USED FOR STORING,PRINTING OF REGISTERS AND ANY  *
.*       OTHER ADDRESSABLE AREAS. XSNAP HARMS NO REGISTERS,CAN BE USED*
.*       IN ANY NUMBER OF CSECTS IN 1 ASSEMBLY,AND PRINTS REGISTERS   *
.*       EXACTLY AS THEY ARE WHEN THE XSNAP IS CALLED.  XSNAP         *
.*       ACTION MAY BE MADE CONDITIONAL EITHER AT ASSEMBLY TIME OR    *
.*       DURING EXECUTE TIME.  SEE WRITEUP FOR OPERAND DESCRIPTION.   *
.*       USES MACROS: XLOOK                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  XXLOOK             XLOOK RETURN VALUE                   0
         GBLB  XSNAPST            GENERATION STATUS,ON=0,OFF=1         0
         LCLA  I,K,L,N         LOCAL COUNTERS                       0080
         LCLB  XP,XF             PRINT REGS AND PRINT FLOATING REGS   00
         LCLC  NAM,INST,A(5)                                         008
.*                                                                    *
.*       CHECK FOR XSNAPS BEING CANCELLED. CREATE LABEL IF NEEDED.    *
.*                                                                    *
         AIF   ('T(3)' NE '').XGOGEN  SKIP  SKIP IF NONCANCELLABLE     0
         AIF   (NOT ?XSNAPST).XGOGEN   GENERATE IF STATUS=ON
         AIF   (T'XLABEL EQ 'O').XXEXIT    SKIP IF NOTHING TO GEN      0
XLABEL  DS    0H  .               LABEL USED ON NULLIFIED XSNAP        0
         MEXIT
.XGOGEN  SPACE 1
NAM     SETC  'XXSYSNDX'         SET UP MOST OF NAME FOR LABELS       00
N       SETA  (N'STORAGE/2)*2    GET ROUNDED NUMBER OF OPERANDS       00
XLABEL  STM   0,15,NAM.B  .      SAVE ALL REGISTERS                   00
.*                                                                    *
.*       IF OPTION - IF IF OPTION IS USED AND HAS CORRECT ARGUMENTS,  *
.*       GENERATE A CLI, C, OR CR INSTRUCTION TO PERFORM APPROPRIATE  *
.*       TEST,DEPENDING ON THE KIND OF IF ARGUMENTS . NEGATE THE      *
.*       CONDITION AND CREATE THE RIGHT EXTENDED MNEMONIC BRANCH      *
.*       SO THAT THE XSNAP WILL BE SKIPPED IF THE STATED CONDTION IS  *
.*       NOT MET.  GENERATE USER'S OWN OPCODE IF HE SUPPLIED ONE.     *
.*                                                                    *
         AIF   (T'IF EQ 'O').XNOIF          SKIP IF IF NOT REQUESTED   0
         AIF   (N'IF GE 3).XOKIF  SKIP IF ENOUGH ARGUMENTS             0
         MNOTE 0,'**XSNAP- IF=IF:IGNORED, LACKS REQUIRED 3-4 OPERANDS' 0
         AGO   .XNOIF              CANCEL IF OPTION
.XOKIF   XLOOK IF(2),(H,L,E,O,P,M,Z,NH,NL,NE,NO,NP,NM,NZ)              0
         AIF   (XXLOOK GT 0).XOKIF1        SKIP IF OK RELATION         0
         MNOTE 0,'**XSNAP- IF=IF(2) UNKNOWN-CANCELLED'                 0
         AGO   .XNOIF              SKIP GENERATION OF THIS OPTION
.XOKIF1  ANOP
INST    SETC  'IF(4)'            GET INSTRUCTION                      00
         AIF   (N'IF EQ 4).X      IF OPCODE SUPPLIED,SKIP CHECKING     0
INST    SETC  'CLI'               MAKE TENTATIVE INSTRUCTION SETUP     0
         AIF   ('IF(1)'(1,1) NE '(' OR 'IF(1)'(K'IF(1),1) NE ')').X  008
INST    SETC  'C'                 PROBABLY WANTS RX TYPE               0
         AIF   ('IF(3)'(1,1) NE '(' OR 'IF(3)'(K'IF(3),1) NE ')').X  008
INST    SETC  'CR'                2 REGS-USER WANTS RR TYPE            0
.X       ANOP
         INST IF(1),IF(3) .     TEST                                 008
INST    SETC  'BNIF(2)'          NEGATE COND, HOPE FOR 1 OF 1ST SET   00
         AIF   (XXLOOK LE 7).XOKIF2        SKIP IF NOW SET UP RIGHT    0
INST    SETC  'B'.';IF(2)'(2,2)   REMOVE N FROM COND                   0
.XOKIF2  INST NAM.C                                                   00
.*                                                                    *
.*             CREATE BRANCH AROUND THE SAVE AREA, FLAGS, ETC.        *
.*                                                                    *
.XNOIF   XLOOK T(1),(PR,PRINT,FL,FLOAT,NO,NOREGS,ST,STORE)             0
I       SETA  72+4*N             LENGTH FOR T=PRINT,NOREGS            00
         AIF   (XXLOOK LE 6).XBRNCH        SKIP IF ILLEGAL, OR PR,NO   0
I       SETA  68                  LENGTH FOR T=STORE                   0
.XBRNCH  B     NAM.B+I  .        BRANCH AROUND CONSTANTS              00
.*                                                                    *
.*       CREATE FRONT BRACKET CHARACTER STRING FOR REGISTER AREA      *
.*                                                                    *
         DS    0F  .               ALIGN LABEL ON FULLWORD
XL       SETA  8                   SET L FOR NO LABEL= LENGTH          0
         AIF   (T'LABEL EQ 'O').XNOLAB    IF NO LABEL,SKIP GENERATION  0
L       SETA  ((K'LABEL+1)/4)*4  ROUND LENGTH UP TO FULLWORD          00
         AIF   (L LE 92).XLAB1    SKIP IF LABEL SMALL ENOUGH           0
         MNOTE 0,'**XSNAP- LABEL= OPERAND TRUNCATED TO 92 CHARACTERS'
L       SETA  92                  TRUNCATE                             0
.XLAB1   DC    CLLLABEL                                               00
         AGO   .XCHK1              SKIP GENRATION OF 1ST DELIMETER
.XNOLAB  DC    CL8'NAM.B'   .     FRONT BRACKET FOR REGISTER AREA      0
.*                                                                    *
.*             CREATE REGISTER AREA, BRACKETS, FLAG VALUES, AS NEEDED *
.XCHK1   AIF   (XXLOOK LT 7).XPRINT        SKIP IF PRINTED OUTPUT      0
NAM.B   DC    16F'-1',4C'X' .     REGISTER SAVE AREA, BRACKET X'S      0
         AGO   .XIFLB              SKIP TO CHECK FOR IF LABEL
.XPRINT  AIF   (XXLOOK GT 0).XPRINT1       SKIP IF LEGAL T=            0
         MNOTE 0,'**XSNAP- UNKNOWN T=T: T=PR ASSUMED'                  0
.XPRINT1 ANOP
XP      SETB  (XXLOOK LT 5)      SET TO 1 IF GP REGS NEEDED           00
@XF      SETB  (XXLOOK GT 2 AND XP)       SET TO 1 IF T=FL OR T=FLOAT 00
XF      SETB  (XF OR 'T(2)' EQ 'FL' OR 'T(2)' EQ 'FLOAT')           0095
NAM.B   DC    16F'-1',B'T(3)00XFXP',AL1(0,L,N/2),V(XXXXSNAP)      009600
.*                                                                    *
.*       GENERATE ADDRESS LIST FOR STORAGE=, WITH EITHER WORDS FOR    *
.*       STORING ADDRESSES OR A-TYPE ADDRESS CONSTANTS.               *
.*                                                                    *
         AIF   (T'STORAGE EQ 'O').OKN      SKIP IF STORAGE= NOT USED   0
I       SETA  1                   INITIALIZE AS COUNTER                0
         AIF   (N EQ N'STORAGE).LOOP1               SKIP IF LEGAL     00
         MNOTE 0,'**XSNAP- ODD OPERAND IGNORED: STORAGE=STORAGE(N)'   00
         AIF   (N EQ 0).OKN                                            0
.LOOP1   AIF   ('STORAGE(I)'(1,1) NE '*').LOOP1E                      00
K       SETA  1                   INITIALIZE COUNTER                   0
.*             PROCESS ADDRESS REQUIRING LA - ST COMBINATION          *
.LOOP1A  AIF   (I+K GT N).LOOP1C         SKIP IF WE'RE AT END        009
         AIF   ('STORAGE(I+K)'(1,1) NE '*').LOOP1C SKIP IF NOT *     009
K       SETA  K+1                INCREM # CONSECUTIVE * FORMS         00
         AGO   .LOOP1A             GO CHECK NEXT
.LOOP1C  DS    K.A .              WORDS WHERE ADDRESSES WILL BE STORED 0
I       SETA  I+K               INCREMENT                            009
         AGO   .LOOP1G             GO FOR NEXT CHECK
.*             PROCESS ADDRESS CONSTANT TYPE OF OPERAND               *
.LOOP1E  DC    A(STORAGE(I))                                          01
I       SETA  I+1                INCREMENT # OPERANDS DONE            01
.LOOP1G  AIF   (I LE N).LOOP1    CONTINUE IF ANY MORE                 01
.*                                                                    *
.*       CREATE LOAD ADDRESS - STORE PAIRS FOR EXPRESSION ADDRESSES   *
.*                                                                    *
I       SETA  1                                                        0
.LOOP2   AIF   ('STORAGE(I)'(1,1) NE '*').LOOP2E    SKIP IF NOT *     01
L       SETA  K'STORAGE(I)-1    GET # CHARS IN EXPRESSION            010
K       SETA  1                   INIT COUNTER                         0
         AIF   (L LE 40).LOOP2A   SKIP IF SMALL ENOUGH                 0
         MNOTE 8,'**XSNAP- STORAGE(I) LONGER THAN 40 CHARACTERS'       0
L       SETA  40                  TRUNCATE AND HOPE IT GOES            0
.*       BREAK EXPRESSION INTO 8 CHARACTER SECTIONS.                  *
.LOOP2A  ANOP
A(K)   SETC  'STORAGE(I)'(8*K-6,8)      GET UP TO 8 NEXT CHARS     01032
K       SETA  K+1                INCRMENT COUNTER                     01
         AIF   (8*K-8 LT L).LOOP2A        LOOP UNTIL HAVE WHOLE OPR   01
         LA    0,A(1)QA(2)A(3)A(4)A(5)                              0103
         ST    0,NAM.B+4*I+68    STORE ADDRESS IN LIST                01
.LOOP2C  ANOP
K       SETA  K-1                DECRMENT SECTION TO NULL             01
A(K)   SETC  ''                  NULL FOR NEXT USE                    01
         AIF   (K GT 2).LOOP2C    CONTINUE UNTIL ALL BUT A(1) NULL    01
.LOOP2E  ANOP
I       SETA  I+1                INCREMENT POSITION IN LIST           01
         AIF   (I LE N).LOOP2    CONTINUE WITH LIST                   01
.*                                                                    *
.*       CREATE CODE TO SET UP REGISTERS FOR XXXXSNAP,CALL IT,AND     *
.*       RESTORE REGS ON RETURN.  XXXXSNAP RESTORES THE CONDTION CODE.*
.*                                                                    *
.OKN     LA    10,NAM.B  .        GET ADDRESS OF REGISTER BLOCK        0
         L     15,68(10) .         GET V(XXXXSNAP) FOR BRANCH
         BALR  14,15 .             CALL XXXXSNAP,POINT 14 AT NEXT INST
         LM    0,15,0(10) .        RELOAD THE REGISTERS
.*             CREATE LABEL FOR IF OPTION, IF IT WAS USED.            *
.XIFLB   AIF   ('INST' EQ '').XEXIT         SKIP GEN OF IF LABEL       0
NAM.C   EQU   * .                 DEFINE LABEL FOR IF= BRANCH          0
.XEXIT   SPACE 2
.XXEXIT  MEND
         SPACE 2
         MACRO
         XSET XSNAP=                                                   0
         GBLB  XSNAPST            =0 ==> XSNAPS, =1 ==> NONE           0
.*             SIMPLE XSET, JUST FOR XSNAPS.
XSNAPST SETB  ('XSNAP' EQ 'OFF')           1==> NO XSNAPS             01
         MEND
         TITLE '*** XSRNR - REGISTER LOAD-STORE FOR XRETURN-XSAVE ***'
         MACRO
         XSRNR OP,RG,NO15                                            010
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRNR      SAVE/RESTORE REGISTERS FOR XSAVE/XRETURN      *
.*                                 JOHN R. MASHEY- FEB 1970 - V.4.0   *
.*             THIS MACRO IS USED BY XSAVE AND XRETURN TO SET UP      *
.*       REGISTER SAVING AND RESTORATION.                             *
.*       OP IS THE OPCODE TO BE USED.  I.E.  EITHER L  OR ST.        * 0
.*       RG  IS 1 OPERAND FROM THE RGS OPERAND USED BY XSAVE AND    * 01
.*             XRETURN.  IT IS EITHER 1 REGISTER, OR A PAIR OF REGS   *
.*             SEPARATED BY A DASH.                                   *
.*       NO15   =0  STATES THAT A RETURN CODE IS CURRENTLY IN REG 15 * 0
.*             AND SHOULD NOT BE DISTURBED, REGARDLESS OF HOW THE REGS*
.*             ARE SPECIFIED.                                         *
.*       USES MACROS: XCHAR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  XXCHAR             FOR COMMUNICATION WITH XCHAR         0
         LCLA  I                                                       0
         LCLC  R1,R2             1ST REG, 2ND REG, TEMPORARY          01
         AIF   ('RG' EQ 'NO').XXEXIT        DON'T GEN ANYTHING         0
.*             SCAN FOR DASH-MEANING 2 REGISTERS.                     *
.XSL1    ANOP
I       SETA  I+1                INCREMENT FOR NEXT CHARACTER         01
         AIF   (',RG'(I,1) EQ '-').XDASH    JUMP IF DASH FOUND         0
         AIF   (I LT K'RG).XSL1  CONTINUE TO END OF OPERAND           01
R1      SETC  'RG'               RG IS 1 REGISTER BY ITSELF          011
         AGO   .XSAA               GO TO NEXT DECISION POINT
.*             FOUND DASH-NOW SEPARATE THE REGISTERS.                 *
.XDASH   ANOP
R1      SETC  'RG'(1,I-1)       GET FIRST REGISTER                   011
         AIF   (I EQ K'RG).XSAA  DUMB USER - 1 REG FOLLOWED BY -      01
R2      SETC  'RG'(I+1,K'RG-I)         GET 2ND REGISTER            01144
.XSAA    XCHAR R1,2               GET UP TO LAST 2 CHARS OF 1ST REG    0
         AIF   ('XXCHAR' NE '14' AND 'XXCHAR' NE '15').XNO1415        01
I       SETA  4*XXCHAR-44         OFFSET FOR 14 OR 15                 01
         AIF   ('R2' NE '').XS2RG SKIP IF 2 REGISTERS SPECIFIED        0
         AIF   ('XXCHAR' EQ '15' AND 'NO15' EQ '0').XXEXIT            01
         OP   R1,I.(13)  .       SAVE/RESTORE 1 REG                  011
         MEXIT
.XS2RG   AIF   ('NO15' EQ '0').XSN15        SKIP IF 15 SHOULDN'T BE    0
         OP.M R1,R2,I.(13)  .  SAVE/RESTORE RANGE OF REGS           0116
         MEXIT
.XSN15   AIF   ('XXCHAR' EQ '15').XSN15A    SKIP IF 15 SPECIFIED       0
         L     R1,12(13)  .        RELOAD REG 14                       0
         XCHAR R2,2                GET 2ND REG                         0
         AIF   ('XXCHAR' EQ '15').XXEXIT    SKIP IF 15 SPECIFIED       0
.XSN15A  LM    0,R2,20(13)  .     RELOAD REST OF REGS                  0
         MEXIT
.*             RESTORE 1 REG OR RANGE (NOT STARTING WITH 14 OR 15).   *
.XNO1415 AIF   ('R2' NE '').XLMSTM          JUMP IF MULTIPLE REGS      0
         OP   R1,R1*4+20(13)                                         011
         MEXIT
.XLMSTM  OP.M R1,R2,R1*4+20(13)                                     0118
.XXEXIT  MEND
         TITLE 'DISK UTILITY I/O DOS/OS MACROS'
         MACRO
LA      XDKCHK    P1,P2,P3                                          0118
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKCHK                                                    *
.*       THIS MACRO WILL PRODUCE EITHER A DOS CHECK MACRO OR A        *
.*       OS VERSION OF THE CHECK MACRO                                *
.*                                                                    *
.*       P1 IS THE OS CHECK MACRO PARAMETER                          * 0
.*       P2 IS THE DOS CHECK MACRO PARAMETER                         * 0
.*       P3   IF 'DOS' AND $ASMLVL IS DOS GEN DOS CHECK             * 01
.*             OTHERWISE GEN $ASMLVL TYPE CHECK                      * 0
.*       USES INNER MACROS: CHECK (OS OR DOS VERSION)                 *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  $ASMLVL            OS/DOS LEVEL SWITCH                  0
LA      DS    0H .                GEN LABEL AND BOUNDRY                0
         AIF   ($ASMLVL).XOSGEN   DETERMINE LEVEL                      0
         CHECK P2 .               GEN DOS CHECK                        0
.XEND    MEXIT                     ALL DONE
.XOSGEN  AIF   ('P3' EQ 'DOS').XEND   IF NOT DEFAULT QUIT              0
         CHECK P1 .               GEN OS TYPE CHECK                    0
         MEND
         SPACE 10
         MACRO
LA      XDKPT P1,P2                                                  011
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKPT                                                     *
.*       THIS MACRO GENERATES EITHER A DOS POINTS MACRO CALL OR AN    *
.*       OS POINT MACRO CALL                                          *
.*                                                                    *
.*       P1 IS THE DCB OR DTF NAME                                   * 0
.*       P2 IS THE POINT WORD ADDRESS (OS ONLY)                      * 0
.*                                                                    *
.*       USES INNER MACROS: POINT (OS), POINTS (DOS)                  *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  $ASMLVL            GLOBAL ASMBLY LEVEL SWITCH           0
         AIF   ($ASMLVL).XDKP1    GENERATE CORRECT MACRO VERSION       0
LA      POINTS  P1 .             DOS POINTS MACRO                     01
         MEXIT
.XDKP1   ANOP
LA      POINT P1,P2 .           OS POINT MACRO                       011
         MEND
         SPACE 10
         MACRO
LA      XDKWT P1,P2,P3                                              0118
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO:XDKWT                                                      *
.*       THIS MACRO WILL GENERATE A CORRECT WRITE MACRO CALL FOR      *
.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *
.*                                                                    *
.*       P1 IS THE DECB NAME                                         * 0
.*       P2 IS THE FILE NAME UNDER DOS GEN AND THE DCB NAME FOR OS   * 0
.*       P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF GENERATION        * 0
.*                                                                    *
.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *
.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *
.*       IS PERFORMED                                                 *
.*                                                                    *
.*       USES INNER MACROS: WRITE (OS FORM OR DOS FORM)               *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  $ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL     0
         AIF (NOT $ASMLVL).XWT1   GEN CORRECT CALL BY LEVEL SWTCH      0
LA      WRITE P1,SF,P2,P3,MF=E .        GENERATE AN OS MACRO CALL   0118
         MEXIT
.XWT1    ANOP
LA      WRITE P2,SQ,P3 .        GENERATE A DOS MACRO CALL            011
         MEND
         SPACE 10
         MACRO
LA      XDKRD P1,P2,P3                                              0118
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XDKRD                                                     *
.*       THIS MACRO WILL GENERATE A CORRECT READ MACRO CALL FOR       *
.*       EITHER ASSEMBLY UNDER OS OR DOS.                             *
.*                                                                    *
.*       P1 IS THE DECB NAME                                         * 0
.*       P2 IS THE DCB ADDRESS FOR OS AND THE FILENAME UNDER DOS     * 0
.*       P3 IS THE AREA ADDRESS FOR BOTH LEVELS OF ASSEMBLY          * 0
.*                                                                    *
.*       THIS MACRO GENERATES AN EXECUTE FORM MACRO FOR OS            *
.*       ALL OPERANDS ARE ASSUMED CORRECT AS NO ERROR CHECKING        *
.*       IS PERFORMED                                                 *
.*                                                                    *
.*       USES INNER MACROS: READ (OS FORM OR DOS FORM)                *
.*                                                                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  $ASMLVL            GLOBAL SWITCH FOR ASSEMBLY LEVEL     0
         AIF   (NOT $ASMLVL).XRE1  GEN CORRECT CALL BY LEVEL SWTCH     0
LA      READ P1,SF,P2,P3,MF=E .         GENERATE AN OS MACRO CALL   0118
         MEXIT
.XRE1    ANOP
LA      READ  P2,SQ,P3 .                 GENERATE A DOS MACRO CALL   011
         MEND
         SPACE 10
         TITLE 'XXDKDECB MACRO DEFINE CONTROL BLOCKS FOR DISK UTILITY'
         MACRO
LABEL   XXDKDECB   II                                                 01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XXDKEDCB GENERATE TABLE OF DECBS FOR DISK UTILITY        *
.*       THIS MACRO GENERATES A LINKED TABLE OF DECBS.                *
.*       THE BUFFER ADDRESSES ARE PLACED IN THE DECB BY XXXXDKOP      *
.*       USES MACRO: WRITE                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  $ASMLVL            LEVEL OF ASSEMBLY SWITCH             0
         LCLA  I,XXLNK           LCL COUNTER AND LINK FACTOR(OS/DOS)  01
I       SETA  II                 INITIALIZE FOR UNIQUE NAMES          01
         AIF   ($ASMLVL).OS1      GENERATE CORRECT LINK FACTOR(OS/DOS) 0
XXLNK   SETA  8                   DOS LEVEL LINK FACTOR                0
         AGO   .OS2
.OS1     ANOP
XXLNK   SETA  24                  OS LEVEL LINK FACTOR                 0
.OS2     ANOP
         SPACE 2
LABEL   DS    0F .                DEFINE LABEL, ALIGN TO FULLWORD      0
         AIF   (I EQ 1).DESTOP    BRANCH IF LAST ENTRY                 0
.DENEXT  DC    A(*+XXLNK) .       LINK TO NEXT ENTRY                   0
         AIF   ($ASMLVL).XXDK1    LEVEL DEPENDENT CODE GENERATION      0
         DC    F'0'                FULLWORD FOR FAKE DECB
         AGO   .XXDK2
.XXDK1   WRITE XXDECBI,SF,XXDKUDCB,0,MF=L    GENERATE A DECB           0
.XXDK2   SPACE 2
I       SETA  I-1                DECREMENT COUNTER                    01
         AIF   (I GT 1).DENEXT    LOOP IF NOT LAST ENTRY               0
.DESTOP  DC    A(LABEL) .         LAST ENTRY, LINK TO TOP OF TABLE     0
         AIF   ($ASMLVL).XXDK3    LEVEL OF ASSEMBLY                    0
         DC    F'0'                FULLWORD FOR FAKE DECB
         AGO   .XXDK4
.XXDK3   WRITE XXDECBI,SF,XXDKUDCB,0,MF=L    GENERATE A DECB           0
.XXDK4   SPACE 5
         MEND
         SPACE 3
         MACRO
L       $DISK TYPE                                                    01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DISK     CALL DISK UTILITY                              *
.*       $DISK CALLS MACRO XIONR TO SET UP A BRANCH TO A DISK         *
.*       UTILITY ROUTINE.                                             *
.*       USES MACRO: XIONR                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
L       XIONR XXXXDKTYPE,0,(0)   CALL DISK UTILITY                    01
         MEND
         TITLE '$ERCGN MACRO - GENERATE COMPLETION CODE BLOCK '
         MACRO
LABEL   $ERCGN CODE,MSSG,TYPE=SYSTEM                                0119
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ERCGN     GENERATE COMPLETION CODE BLOCK FOR XXXXSNAP   *
.*       EACH CALL CREATES 1 ENTRY DESCRIBED BY DSECT ERCOMPCD.       *
.*                                                                    *
.*       CODE     CHARACTER VALUE OF ERROR CODE NUMBER.              * 0
.*       MSSG     ERROR MESSAGE TO BE PRINTED                        * 0
.*       TYPE     TYPE OF COMPLETION CODE - SYSTEM, ASSIST, OR USER. * 0
.*                                                                    *
.*       *NOTE* IF $OPTMS = 0, NO MESSAGE WILL BE GENED, ONLY CODE.  * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  $OPTMS             MEMORY OPTIMIZATION(0=SMALL)         0
         LCLA  I                  FOR LENGTH                           0
         LCLC  T                  FOR TYPE                             0
T       SETC  'ERCTYPE'(1,7)     GET EQU FOR TYPE                     01
I       SETA  K'CODE+K'MSSG-2   GET LENGTH OF TOTAL MESSAGE          012
         AIF   ($OPTMS GT 0).ERCA     SKIP IF NOT MINIMAL MEMORY       0
I       SETA  K'CODE-1           GET LENGTH - 1 OF ERROR CODE         01
LABEL   DC    AL2(256*I+T),C'CODE'                                  0120
         AGO   .XXEXIT             QUIT
.ERCA    ANOP
LABEL   DC    AL2(256*I+T),C'CODE ',CMSSG                          01208
.XXEXIT  MEND
         SPACE 2                                                      S
         MACRO                                                        A
LABEL   $MSG  NMBR,MSG,FLAG=0                                     A 0121
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $MSG                  USED TO GENERATE LINE IN MSG TABLE *
.*       NMBR IS MESSAGE #   (3 DIGITS)                              * 0
.*       MSG IS QUOTED STRING OF MESSAGE                             * 0
.*       FLAG IS FLAG BYTE                                           * 0
.* GENERATES:(LENGTH-1 OF MSG): #BYTES +3 FOR LENGTH OF MSG           *
.*       (FLAG BYTE): 1 BYTE                                          *
.*       (CHAR FORM OF NMBR): 3 BYTES                                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  $OPTMS             MEMORY OPTIMIZATION(0=SMALL)       S 0
         LCLA  K                  FOR K'MSG                         S 01
         AIF   ($OPTMS EQ 0).SMALL   SKIP FOR MIMIMAL MEMORY         S 0
K       SETA  K'MSG-2-1+3   MSG-QUOTES-1+LENGTH OF NMBR             S 01
LABEL   DC    AL1(K,FLAG),CL3'NMBR',CMSG                         S 01210
         MEXIT                                                        S
.SMALL   ANOP                                                         S
LABEL   DC    AL1(2,FLAG),CL3'NMBR'                                S 012
         MEND                                                         S
         TITLE '*** CARD-PUNCH, LINE-PRINT MACROS - $PNCH,$PRNT ***'
         MACRO
LABEL   $PNCH XAREA,XNUM,OVER                                       0121
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PNCH      PUNCH A CARD, BRANCH IF RECORD OVERFLOW       *
.*       XAREA,XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPNCH WRTUP * 01
.*       OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    * 0
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   XIONR XXXXPNCH,XNUM,XAREA,80     HAVE CONTROL BLOCK SET      012
         AIF   ('OVER' EQ '').XXEXIT       SKIP IF OVER NOT SPEC       0
         BL    OVER   .           BRANCH IF EXCEEEDED RECORD COUNT     0
.XXEXIT  MEND
         SPACE 4
         MACRO
LABEL   $PRNT XAREA,XNUM,OVER                                       0123
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PRNT      PRINT A LINE, BRANCH IF RECORD OVERFLOW.      *
.*       XAREA,XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XPRNT WRITUP* 01
.*       OVER IS LABEL TO BE BRANCHED TO IF RECORDS EXCEED LIMIT.    * 0
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   XIONR XXXXPRNT,XNUM,XAREA,133    HAVE BLOCK SETUP            012
         AIF   ('OVER' EQ '').XXEXIT       SKIP IF NO LABEL            0
         BL    OVER    .          BRANCH IF EXCEEDED RECORDS           0
.XXEXIT  MEND
         TITLE '*** CARD-READ MACROS - $READ,$SORC ***'
         MACRO
CLABEL   $READ XAREA,XNUM,EOF                                        012
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $READ      READ CARD DURING EXECUTION, BRANCH IF EOF.    *
.*       XAREA,XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP* 01
.*       EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        * 0
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   XIONR XXXXREAD,XNUM,XAREA,80   SET UP CONTROL BLOCK          012
         AIF   (T'EOF EQ 'O').XXEXIT       SKIP IF NO LABEL            0
         BL    EOF   .            TAKE BRANCH IF END OF FILE           0
.XXEXIT  MEND
         SPACE 4
         MACRO
LABEL   $SORC XAREA,XNUM,EOF                                        0125
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SORC      READ ASSEMBLER SOURCE CARD, BRANCH IF EOF.    *
.*       XAREA,XNUM-SEE XIONR MACRO FOR EXPLANATION, OR XREAD WRITUP* 01
.*       EOF      LABEL TO BE BRANCHED TO IF END-FILE OCCURS.        * 0
.*       USES MACROS: XIONR                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   XIONR XXXXSORC,XNUM,XAREA,80  SET UP CONTROL BLOCK         * 012
         AIF   (T'EOF EQ 'O').XXEXIT       SKIP IF NO LABEL            0
         BL    EOF   .            BRANCH IF END-FILE                   0
.XXEXIT  MEND
         TITLE 'SPECIAL XGET AND XPUT MACROES FOR ASSIST'
         MACRO
XLABEL  $GET  XAREA,XNUM                                             012
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GET  INTERNAL XGET MACRO FOR ASSIST.                    *
.*                                      RICHARD FOWLER NOV, 1972 V.5.0*
.*       LIKE XGET BUT CONVERTS USER REG1 AND SETS ACTUAL R1 TO       *
.*       ACTUAL ADDRESS.  ALSO CALLS XDDGET.                          *
.*                                                                    *
.*       EXECUTION ASSUMES USER REGISTER POINTS TO DDNAME.            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XLABEL  L     R1,ECREG1           GET USER @ DDNAME                    0
         AR    R1,RMEM             GET REAL ADDRESS
         XIONR XDDGET,XNUM,XAREA,80                                   01
.XMEND   MEND
         SPACE 5
         MACRO
XLEBEL  $PUT  XAREA,XNUM                                             012
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $PUT                                                     *
.*       LIKE $GET, BUT CALLS XDDPUT.                                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
XLEBEL  L     R1,ECREG1           GET USER @ DDNAME                    0
         AR    R1,RMEM             GET REAL ADDRESS
         XIONR XDDPUT,XNUM,XAREA,133                                  01
.XMEND   MEND
         TITLE 'EXTENDED I/O MACROES XGET AND XPUT'
         MACRO
XLABEL  XGET  XAREA,XNUM                                             012
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XGET    GET RECORD OFF OF DDNAME FILE                   * 0
.*                                 RICHARD FOWLER AUG, 1972 V.5.0     *
.*       MACRO FOR EASY READING OFF OF ANY DD FILE, READS XNUM       * 0
.*       CHARACTERS. CONDITION CODE SET TO 0 NORMALLY, OR TO 1 ON     *
.*       END OF FILE. GENERATION CONTROLLED BY XGETST.               * 0
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * **
         GBLB  XGETST             GENERATION STATUS- 0=YES, 1=NO       0
         AIF   (XGETST).XNOGEN    IF SHOULDN'T GENERATE-SKIP CALL      0
XLABEL  XIONR XXXXGET,XNUM,XAREA,80   SET UP CONTROL BLOCK           012
         MEXIT
.XNOGEN  AIF   (T'XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED   0
XLABEL  DS    0H .                LABEL FOR CANCELLED XGET             0
.XXEXIT  MEND
         SPACE 5
         MACRO
XLABEL  XPUT  XAREA,XNUM                                             012
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XPUT           PUT A RECORD ONTO FILE DDNAME            * 0
.*                                 RICHARD FOWLER AUG 1972 V.5.0      *
.*       MACRO FOR EASY PRINTING ONTO ANY DD FILE. RECORD LENGTH=XNUM* 0
.*       IF PRINT FILE, FIRST CHARACTER IS USED AS CARRIAGE CONTROL   *
.*       GENERATION CONTROLLED BY XPUST                              * 0
.*       EXECUTION ASSUMES REG 1 POINTS TO DD NAME                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  XPUTST             GENERATION STATUS- 0=YES, 1=NO       0
         AIF   (XPUTST).XNOGEN    IF SHOULDN'T GENERATE, SKIP CALL     0
XLABEL  XIONR XXXXPUT,XNUM,XAREA,133   SET UP CONTROL BLOCK          012
         MEXIT
.XNOGEN  AIF   (T'XLABEL EQ 'O').XXEXIT     GEN LABEL ONLY IF NEEDED   0
XLABEL  DS    0H .                LABEL FOR CANCELLED XPUT             0
.XXEXIT  MEND
         TITLE 'MACRO---XGPSRCH--- INNER MACRO FOR XGPGN MACRO'
         MACRO
        XXGPSRCH DIREC,TIME                                           01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->MACRO: XXGPSRCH  INNER MACRO FOR XGPGEN                          *
.*     ARGUMENTS:                                                     *
.*       DIREC= G--> INPUT                                           * 0
.*               P--> OUTPUT                                          *
.*       TIME=1 --> FIRST CALL, SETS UP EXTRA CODE AND ACTS AS SYSND* 01
.*             2--> SECOND CALL                                       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         L     R3,XDIREC.ELEM .   GET # LAST POINTER TO OPEN FILES     0
         LA    R1,XDIREC.PNTSRT . GET @ OF FIRST POINTER               0
         LTR   R3,R3 .             ARE THERE ANY ELEMENTS?
         BE    XDIREC.MAKETIME   NO - GO CREATE ONE                   01
         LA    R2,12 .             SET UP INCREMENT SIZE
XDIREC.LOOPTIME CLC 0(8,R1),XDIREC.CURENT COMPARE DD NAMES           012
         BE    XDIREC.CONTTIME   IF EQUAL, GO TO I/O                  01
         BXLE  R1,R2,XDIREC.LOOPTIME EQUAL, SEARCH TILL END OF TABLE 01
         SPACE 2
         MEND
         TITLE 'MACRO---XGPGEN--- GENERATE GENERAL I/O MODULES'
         MACRO
LABEL   XGPGEN DIREC=G,FETCH=NOT,DDNUM=20                           0126
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XGPGEN  GENERATE GENERAL I/O MODULES                     *
.*                                    RICHARD FOWLER NOV, 1972 V.5.0  *
.*                                                                    *
.*       ARGUMENTS:                                                   *
.*             DIREC = P --> OUTPUT                                  * 0
.*                   = P --> INPUT                                   *
.*             FETCH  =NOT --> NO FETCH PROTECTION                   * 0
.*                    =PROTECT -->    FETCH PROTECTION                *
.*             DDNUM = MAXIMUM NUMBER OF DD NAMES ALLOWED AT ONCE    * 0
.*     (**EACH DD FILE REQUIRES 3F TABLE ENTRY PLUS DCB AND BUFFER**) *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE ' LABEL - MODULE CREATED BY XGPGEN'                     0
LABEL   CSECT                                                          0
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> CSECT: EXTENDED I/O MODULE FOR GENERAL I/O                       *
*        THIS MODULE IS CALLED TO DO GENERAL I/O WORK ON A FILE       *
*              SIMILAR IN OPERATION TO XIO ROUTINES, BUT CAN HANDLE   *
*              MANY FILES AT ONCE.                                    *
*        ENTRY CONDITIONS:                                            *
*          R14 = @ OF CONTROL BLOCK                                   *
*          R15  = ENTRY POINT ADDRESS                                 *
*          R0  = ADDRESS OF AREA TO MOVE DATA INTO                    *
*          R1  = ADDRESS OF DD NAME TO BE USED                        *
*        CONTROL BLOCK:                                               *
*      OFFSET  LENGTH        WHAT                                     *
*        0       1F        ENTRY POINT ADDRESS                        *
*        4       3F          SAVE AREA                                *
*        16      2           LENGTH OF AREA                           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         USING *,15 .              NOTE TEMPORARY ADDRESSABILITY
         USING XIOBLOCK,R14
         STM   R13,R7,XDIREC.SAV1 SAVE REGISTERS TO BE USED          A 0
         CNOP  0,4 .               GET ON FULLWORD
         BAL   R13,*+76            SET UP FAKE AREA PNTR - BASE
         USING *,R13 .             NOTE NEW USING/SAVE AREA POINTER
         DS    18F .               FAKE SAVE AREA
         DROP  R15 .               KILL OLD ADDRESSING
         SPACE 2
         USING IHADCB,R1 .         SET UP ADDRESSIBILITY TO DCB S
         MVC   XDIREC.CURENT(8),0(R1) . GET CURRENT DD NAME            0
*   CHECK FOR CLOSE
         SR    R1,R1               GET ZERO LENGTH INDICATOR
         CH    R1,XIOLENG          ARE THEY EQUAL?
         BE    XDIREC.EOF .       YES-GO CLOSE AND FORGET FILE         0
         XXGPSRCH DIREC                                                0
*  THE FOLLOWING CODE, IF EXECUTED, GENERATES A DCB AND TRIES AN OPEN
*
XDIREC.MAKE C R1,=A(XDIREC.FULL) CHECK FOR TABLE OVERFLOW             01
         BNL   XDIREC.CC3         NO SPACE, DON'T TRY OPEN-RETURN    J 0
         ST    R1,XDIREC.ELEM .   SAVE NEW ADDRESS, R1 ALREADY POINTIN 0
         MVC   0(8,R1),XDIREC.CURENT  SAVE DD NAME FOR FUTURE CALLS    0
         L     0,XDIREC.LONG      LOAD R2 WITH LENGTH OF DCB           0
         GETMAIN R,LV=(0) .        GET SPACE FROM OS
         L     R2,XDIREC.ELEM .   GET ADDRESS OF POINTER               0
         ST    R1,8(R2) .          SAVE @ OF DCB
*
         ST    R1,XDIREC.FULL     KLUDGE TO GET AROUND ADDRESSIBILITY  0
         MVC   XDIREC.OPEN+1(3),XDIREC.FULL+1  COPY OVER DCB @ INTO J 01
*
         MVC   0(XDIREC.ELEM-XDIREC.DCB,R1),XDIREC.DCB BUILD DCB     012
         MVC   DCBDDNAM,XDIREC.CURENT MOVE DD NAME INTO DCB            0
         OPEN  MF=(E,XDIREC.DCBPTR)  DO REMOTE OPEN                    0
         L     R1,XDIREC.FULL .   FIX R1, DESTROYED IN OPEN            0
         TM    DCBOFLGS,X'10' .    DID OPEN GO?
         BO    XDIREC.CONT4       YES, DO I/O                          0
*              OPEN DIDN'T GO - CLEAN UP SO DOESN'T BOMB LATER        J
         L     R0,XDIREC.LONG     GET LENGTH OF DCB FOR FREEMAIN     J 0
         FREEMAIN R,LV=(0),A=(1)   GIVE THE SPACE BACK TO OS          J
         XC    0(12,R2),0(R2)      CLEAR OUT SO WON'T THINK IT'S OPEN J
XDIREC.CC3 TM *+1,X'FF'           SET CC=3  ==> OPEN IMPOSSIBLE      J 0
         B     XDIREC.RET         RETURN TO USER                       0
         SPACE 2
XDIREC.CONT L R1,8(R1) .          GET DCB ADDRESS                      0
XDIREC.CONT4 LH R5,XIOLENG        GET LENGTH OF AREA                   0
         AIF   ('FETCH' EQ 'PROTECT').SKPFTCH                          0
         L     R2,XDIREC.SAV1+12  GET @ I/O AREA                       0
* THE FOLLOWING CODE IS USED FOR ADDRESS ILLEGAL     ******************
*****  THIS CODE WILL NOT WORK IF MACHINE HAS FETCH PROTECT ***********
         SPACE 2
         L     R4,16 .             GET CVT PNTR FROM LOC 16
         LA    R0,0(R2,R5) .       GET ENDING ADDRESS OF I/O AREA
         C     R0,164(R4) .        COMPARE TO CVTMZ00 - HIGHEST ADDRESS
         BNL   XDIREC.ABD3 .      GO ABEND IF HIGHER                   0
.SKPFTCH ANOP
         AIF   ('DIREC' EQ 'P').XOUT  SKIP IF OUTPUT                   0
         LH    R7,DCBLRECL         GET LRECL FROM DCB                 J
         GET   IHADCB .            GET # BUFFER
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK                  J
         LR    R5,R7               TOO BIG, USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGHT JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R2),0(R1) .   GIVE USER 256 BYTES OF DATA
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+10 .              NO - DONT MOVE LEFTOVER BYTES
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,XDIREC.MOV .    MOVE INTO RIGHT PLACE                0
.XCLOSE  ANOP
         SR    R0,R0 .             SET COND CODE TO 0, USER OK
         B     XDIREC.RET .       GO TO RETURN                       B 0
XDIREC.EOF EQU *                  CLOSE IHADCB                         0
         XXGPSRCH DIREC,2                                              0
XDIREC.MAKE2 B XDIREC.RET .      GO RETURN                            01
XDIREC.CONT2 LR R4,R1 .           SAVE THE ADDRESS                     0
         MVC   XDIREC.PTR+1(3),9(R1)                                   0
         LA    R1,XDIREC.PTR                                           0
         CLOSE MF=(E,(1))          DO REMOTE CLOSE
         L     R1,8(R4) .          POINT TO DCB TO FREE
         FREEPOOL (1)              FREE THE BUFFERS
         L     R1,8(R4)            RESET R1 IN CASE DESTROYED
         L     R0,XDIREC.LONG     GET AMOUNT TO FREE                   0
         FREEMAIN R,LV=(0),A=(1)
*
*   DCB NO LONGER EXISTS,  REMOVE CORRESPONDING ELEMENT FROM LIST
*
         LA    R3,XDIREC.FULL .    GET UPPER ADDRESS OF TABLE          0
         SR    R3,R4   .           FIND LENGTH OF REST OF TABLE
         EX    R3,XDIREC.WIPOUT   WIPE OUT 12 BYTES OF MEMORY          0
*
*      IF NO POINTERS REMAIN, SET POINTER TO LAST = ZERO
*
         LA    R3,12
         L     R2,XDIREC.ELEM                                          0
         SR    R2,R3
         LA    R1,XDIREC.PNTSRT                                        0
         CR    R1,R2
         BNH   *+8
         LA    R2,0 .              SET POINTER TO ZERO
         ST    R2,XDIREC.ELEM     SAVE POINTER                         0
         AIF   ('DIREC' EQ 'P').XRET                                   0
         OI    *+1,1 .             SET COND CODE FOR END OF FILE
.*       SHOULD REMOVE DCB FROM LIST NOW
         AGO   .XRET .             HAVE RETURN CODE GENERATED
.*
.XOUT    ANOP
         LH    R7,82(R1) .         GET LRECL
         PUT   IHADCB .            PRINT THE STUFF
         CLR   R5,R7               COMPARE REQUEST LENGTH TO LRECL    J
         BNH   *+6                 SKIP AROUND IF OK LENGTH           J
         LR    R5,R7               TOO BIG- USE LRECL INSTEAD         J
         LR    R4,R5 .             SET UP FOR SHIFT
         LR    R6,R5               SAVE FOR LATER
         SRDL  R4,8 .              PUT RIGHTMOST BYTE IN R5
         SRL   R5,24 .             RIGTH JUSTIFY FOR MOVE
         LTR   R4,R4 .             ANYTHING LEFT IN R4?
         BE    *+22 .              NO - DO NORMAL MOVE
         MVC   0(256,R1),0(R2) .   PUT STUFF INTO BUFFER
         LA    R2,256(R2) .        GO TO NEXT BLOCK
         LA    R1,256(R1) .        GO TO NEXT BLOCK
         BCT   R4,*-14 .           IF ANYTHING LEFT IN R4, DO ANOTHER
*              NORMAL MOVE FOLLOWS
         LTR   R5,R5 .             IS ANYTHING IN R5?
         BE    *+12
         BCTR  R5,0 .              DECREMENT LENGTH BY 1
         EX    R5,XDIREC.MOV .    MOVE INTO RIGHT PLACE                0
         AR    R1,R5               GET BEGINNING @ TO BLANK
         SR    R7,R6               GET DIFFERENCE BETWEEN USER AND DCB
         BZ    *+12                NO DIFFERENCE, DO NOTHING          A
         MVI   1(R1),C' '
         EX    R7,XDIREC.MOV2     CLEAR REST                           0
*  ****NOTE THAT THIS ONLY WORKS FOR DIFFERENCES < 256
         AGO   .XCLOSE
.*
.XRET    ANOP
         SPACE 2
XDIREC.RET LM R13,R7,XDIREC.SAV1 RESTORE REGS                       A 01
         B     XIORETRN            RETURN
         DROP  R14
XDIREC.ABD3 CLI  *,0              SET CC=2, SHOW EXECUTE ERROR       J 0
         B     XDIREC.RET         GO RETURN, SHOWING ERROR           J 0
.*
         SPACE 2
XDIREC.PTR CLOSE (XDIREC.CONT),MF=L    GENERAL PURPOSE CLOSE          01
XDIREC.WIPOUT MVC 0(1,R4),12(R4)                                       0
XDIREC.CURENT DS  CL8  .          AREA TO HOLD CURRENT DD NAME         0
XDIREC.SAV1 DS 11F                SAVE AREA FOR REGS USED            A 0
XDIREC.PNTSRT DS (DDNUM*3)F .    AREA FOR DDNUM DD NAMES  POINTERS   012
XDIREC.FULL DS F                                                       0
XDIREC.OPEN DS 0F                 EXTRA LABEL                          0
         AIF   ('DIREC' EQ 'P').XDEFSR  SKIP IF OUTPUT                 0
XDIREC.DCBPTR OPEN (XDIREC.CONT,(INPUT)),MF=L  OPEN CONTROL WORD    J 01
XDIREC.DCB DCB DSORG=PS,MACRF=GL,EODAD=XDIREC.EOF                     01
XDIREC.ELEM DC  F'0' .            INITIAL # OF ELEMENTS                0
XXDIREC.LONG EQU XDIREC.ELEM-XDIREC.DCB   GET DCB LENGTH             012
XDIREC.LONG DC A(XXDIREC.LONG)   SAVE LENGTH OF DCB                   01
XDIREC.MOV MVC 0(1,R2),0(R1) .    GIVES USER THE DATA                  0
         LTORG
         DROP  R13
         MEXIT                     DONE
.XDEFSR  ANOP
XDIREC.DCBPTR OPEN (XDIREC.CONT,(OUTPUT)),MF=L OPEN CONTROL WORD    J 01
XDIREC.DCB DCB DSORG=PS,MACRF=PL                                       0
XDIREC.ELEM DC F'0' .             INITIAL # OF ELEMENTS                0
XXDIREC.LONG EQU XDIREC.ELEM-XDIREC.DCB   GET DCB LENGTH             012
XDIREC.LONG DC A(XXDIREC.LONG)   SAVE LENGTH OF DCB                   01
XDIREC.MOV MVC 0(1,R1),0(R2) .    MOVE INTO LINE                       0
XDIREC.MOV2 MVC 2(1,R1),1(R1)     CLEAR OUT REST OF BUFFER             0
         LTORG
         DROP  R13
         MEND
         TITLE '***MACRO*** XDDSLOT  GENERATES XGET-XPUT CONTROL TABLE'
         MACRO
LABEL   XDDSLOT NAME,WHICH,POSIN=0,POSOUT=0,PERM=1,REST1=00,    X0126258
               REST2=0                                                 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XDDSLOT CREATE TABLE ENTRY FOR XGET-XPUT                 *
.*                                    RICHARD FOWLER OCT. 1972. V.5.0 *
.*                                                                    *
.*       THIS MACRO GENERATES AN ELEMENT TO HELP ASSIST KEEP          *
.*             CONTROL OF THINGS WHILE EXECUTING XGET-XPUT.           *
.*             NAME CHAR STRING OF RESERVED DD NAME                  * 0
.*             WHICH  MISSING OR IN ERROR, USER MAY XGET-XPUT IT     * 0
.*                 =XREAD   USER CAN XREAD ONLY                       *
.*                 =XPRNT   USER CAN XPRNT ONLY                       *
.*                 =XPNCH   USER CAN XPNCH ONLY                       *
.*                                                                    *
.*             POSIN = 1 CAN INPUT                                   * 0
.*                    = 0 CANNOT INPUT                                *
.*                                                                    *
.*             POSOUT = 1 CAN OUTPUT                                 * 0
.*                     = 0 CANNOT OUTPUT                              *
.*             PERM = 1 ON REENTERING, NAME WILL STILL EXIST        * 01
.*                   =0  NAME WILL NOT EXIST ON REENTERING           * 0
.*                                                                    *
.*             REST 1,2  NOT USED                                    * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'NAME EQ 'O').DDEMPTY   CREATE AN EMPTY SLOT          0
LABEL   DC    CL8'NAME' .        NO, SHOVE IN DDNAME                  01
.*             SET BITS, NOTE NOT CURRENTLY OPEN
         DC    B'00REST1"POSOUTPOSINREST2PERM'                      0126
         AIF   (T'WHICH NE 'O').DDSK1      WAS WHICH OMITTED          01
.DDSK4   DC    XL1'00' .           YES ASSUME XGET-XPUT
         MEXIT
.DDSK1   AIF   ('WHICH' NE 'XREAD').DDSK2   READ ONLY?                 0
         DC    XL1'04' .           YES,  FIX INDEX
         MEXIT
.DDSK2   AIF   ('WHICH' NE 'XPRNT').DDSK3  DO WRITES ONLY?             0
         DC    XL1'08' .           YES,   FIX INDEX
         MEXIT
.DDSK3   AIF   ('WHICH' NE 'XPNCH').DDSK4 IF INVALID, ASSUM XGET-XPUT  0
         DC    XL1'0C' .           VALID,  SET INDEX
         MEXIT
.DDEMPTY ANOP
LABEL   DC    CL8' ' .            BLANK DDNAME                         0
         DC    XL2'0C00' .         BLANK EVERYTHING, XGET-XPUT ALLOWED
         MEND
         TITLE '*** LINKAGE MACROS - $CALL,$RETURN,$SAVE ***'
         MACRO
LABEL   $CALL ENTRY                                                   01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $CALL      SUBROUTINE CALL INSIDE ASSIST ASSEMBLER.      *
.*       ENTRY    ENTRY POINT NAME TO BE CALLED, OS LINKAGE.         * 0
.*       **NOTE** GENERATES NAME WITH AX PREFIX, SO CAN ONLY BE USED  *
.*       INSIDE ASSEMBLER WHERE AVWXTABL USING HOLDS.                 *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     REP,AXENTRY .      GET ADCON FROM THE TABLE             01
         BALR  RET,REP .           CALL THE DESIRED ROUTINE
         MEND
         SPACE 2
         MACRO
2LABEL   $RETURN RGS=NO,SA=                                           01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $RETURN    RETURN FROM SUBROUTINE, OS LINKAGE.           *
.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XRETURN.    *
.*       USES MACROS: XRETURN                                         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO    0
LABEL   XRETURN RGS=RGS,SA=SA,TR=TRACE                              0128
         MEND
         SPACE 2
         MACRO
LABEL   $SAVE RGS=NO,BR=15,SA=                                      0129
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SAVE      SUBROUTINE ENTRY SETUP, OS LINKAGE.           *
.*       SUPPLIES EXTRA DEBUGGING CONTROL AND DEFAULTS TO XSAVE MACRO.*
.*       USES MACROS: XSAVE                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  TRACE,ID          TRACE FORM, IDENT                    01
_LABEL   XSAVE RGS=RGS,BR=BR,SA=SA,TR=TRACE,ID=ID                  01296
         MEND
         SPACE 2
         MACRO
         $DBG  D,T                                                    01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DBG       SET TRACE, DEBUGGING SET VARIABLES FOR ASM.   *
.*       D        HEX FLAG BYTE FOR USE IN TM INSTRUCTION.           * 0
.*       T        IS TRACE MODE FOR AN XSNAP = NO,*,SNAP.            * 0
.*       SEE MACROS $RETURN,$SAVE,XSRTR FOR GENERATION OF TRACE CODE  *
.*       ON ROUTINE ENTRY/EXIT. SEE ALSO ASSIST PROGRAM LOGIC MANUAL. *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLC  DEBUG,TRACE       DEBUG FLAG BYTE,TRACE MODE           01
         AIF   ('D' EQ '').D1     SKIP IF OMITTED,DON'T CHANGE         0
DEBUG   SETC  'X''D'''           SET FLAG BYTE FOR MASK               01
.D1      AIF   ('T' EQ '').D2     SKIP IF NOTRACE,DON'T CHANGE         0
TRACE   SETC  'T'                SET UP TRACE MODE,IF ANY             01
.D2      MEND
         TITLE '*** $AL2 MACRO - CREATE AL2 JUMP INDEX CONSTANTS ***'
         MACRO
LABEL   $AL2  BASE,LIST,OFSET,L                                    01324
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $AL2       CREATE HALFWORD ADDRESS OFFSET TABLE.         *
.*       USED TO GENERATE LIST OF AL2 ADDRESS CONSTANTS WHICH         *
.*       CONTAIN THE RELATIVE ADDRESS OF EACH ITEM IN LIST FROM BASE* 01
.*       OFSET GIVES A NUMBER TO BE ADDED OR SUBTRACTED WHEN SETTING * 0
.*       UP THE EQU FOR THE LABEL,SO THAT INDEXING MAY START ANYWHERE *
.*       L IS CODED IF THE OFFSET LIST SHOULD BE PRECEDED BY LENGTH  * 0
.*       SET UP FOR BXLE .                                            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  I                  LOCAL COUNTER                        0
         DS    0H                  ALIGN
         AIF   (T'LABEL EQ 'O').XCHKL       SKIP IF NO LABEL           0
LABEL   EQU   *OFSET                                                  01
.XCHKL   AIF   (T'L EQ 'O').XNOFS1          SKIP IF LENGTH OMITTED     0
I       SETA  N'LIST*2-2         SET UP FOR BXLE-# OF OPS             01
         DC    H'I'                                                    0
I       SETA  0                   RESET COUNTER                        0
.XNOFS1  ANOP
I       SETA  I+1                                                     01
         DC    AL2(/LIST(I)-BASE)                                     01
         AIF   (I LT N'(LIST).XNOFS1        KEEP LOOPING UNTIL DONE    0
         MEND
         TITLE '*** $SPIE - EXTENDED INTERRUPT COMMUNICATIONS ***'
         MACRO
LABEL   $SPIE EXIT,TYPES,CE=0,ACTION=INIT                          01362
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SPIE        INTERRUPT COMMUNICATIONS                    *
.*                                 SCOTT A. SMITH - FALL 1971.        *
.*       MAY BE USED BY OS OR DOS SYSTEMS TO SPECIFY THE ADDRESS      *
.*       OF AN INTERRUPTION EXIT ROUTINE AND TO SPECIFY THE PROGRAM   *
.*       INTERRUPT TYPES THAT ARE TO CAUSE THE EXIT ROUTINE TO BE     *
.*       GIVEN CONTROL.                                               *
.*       EXIT     LABEL TO BE BRANCHED TO FOR THE INTERRUPTION       * 0
.*                 EXIT.  ADDRESS MAY BE IN A REGISTER.               *
.*       TYPES    A LIST OF INTERRUPTION TYPES TO CATCH.  IF THIS    * 0
.*                 IS NOT SPECIFIED, A DEFAULT VALUE OF  ((1,15))     *
.*                 IS ASSUMED.  THE FORM OF THIS OPERAND IS A LIST    *
.*                 OF OPERANDS SEPARATED BY COMMAS.  THE LIST ITSELF  *
.*                 IS ENCLOSED IN PARENTHESES WITH EACH OPERAND       *
.*                 SPECIFYING A GROUP OF INTERRUPT TYPES TO CATCH.    *
.*                 EACH OF THESE IS EITHER A SINGLE INTEGER BETWEEN   *
.*                 1 AND 15, OR A PAIR OF INTEGERS BETWEEN 1  15     * 0
.*                 REPRESENTING AN INCLUSIVE RANGE OF INTERRUPTS.     *
.*                 EACH PAIR IS ENCLOSED IN PARENTHESES.              *
.*       ACTION=  SPECIFIES THE ACTION THIS MACRO IS TO TAKE.        * 0
.*             -->INIT: IDENTIFIES THIS AS AN INITIAL $SPIE CALL      *
.*                 AND INITIALIZATION IS TO BE PERFORMED.             *
.*             -->CR: CREATE A NEW $SPIE COMMUNICATION, BUT DO        *
.*                 NOT REINITIALIZE.                                  *
.*             -->(RS,(REG)) RESTORE A PREVIOUS $SPIE COMMUNICATION   *
.*                 LINK USING THE XSPIEBLK AT THE ADDRESS IN THE      *
.*                 REGISTER.  ALL OTHER PARAMETERS ARE IGNORED        *
.*            ***DEFAULT***INIT                                       *
.*       CE=      THIS SPECIFIES AN OPTIONAL CALLABLE EXIT WHICH     * 0
.*                 MAY RECEIVE TEMPORARY CONTROL IMMEDIATELY FOLLOW-  *
.*                 ING AN INTERRUPT.  THIS EXIT MUST RETURN.          *
.*       *REGISTERS 14,15,0,1 ARE DESTROYED BY THIS MACRO*            *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  I,PTRVAL,ENDVAL                                       013
         LCLB  BIT(15),J,K                                           013
         LCLC  STR,PTR,END,NAME                                     0136
         SPACE 1 .                 SEPARATE FROM MAIN LINE CODE
         AIF   ('LABEL' EQ '').NOLAB  DO NOT GENERATE A LABEL IF NONE  0
LABEL   DS    0H .                GENERATE USER LABEL                  0
.NOLAB   AIF   ('ACTION(1)' NE 'INIT').NOINT   NO INITIALIZATION       0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       PERFORM CALL TO XXXXSPIN FOR INITIALIZATION                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.INITIAL CNOP  0,4 .               ALIGNMENT FOR ADCON
         BAL   R14,*+8 .           SKIP AROUND ADCON FOR XXXXSPIN
         DC    V(XXXXSPIN) .       INITIALIZATION ADCON
         L     R15,0(R14) .        LOAD INITIALIZATION ROUTINE ADDRESS
         BALR  R14,R15 .           GO INITIALIZE, RETURN FOR XXXXSPIE
         AGO   .CREATE             SKIP ACTION CHECK, ALREADY KNOW
.NOINT   AIF   ('ACTION(1)' EQ 'RS').RSTR    RESTORE OLD XSPIEBLK      0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       INITIALIZE A BIT STRING TO REPRESENT THE INTERRUPT TYPES     *
.*       TO CATCH FOR THIS PARTICULAR $SPIE                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.CREATE  AIF   ('TYPES' NE '').LIST   IF OMMITED, GET ALL INTERRUPTS   0
PTRVAL  SETA  1                   SET POINTER TO START AT SOC #1       0
ENDVAL  SETA  15                  FLAG ALL INTERRUPTS UP TO SOC #15    0
         AGO   .NEXT               MAKE APPROPRIATE BIT MARKS
.LIST    ANOP
I       SETA  1                   START SCAN OF TYPES FIELD AT LOC9 1  0
.TOP     AIF   ('TYPES(I)' EQ ' ').SKIP   TO SKIP EMBEDDED BLANKS     01
STR     SETC  'TYPES(I)'        SAVE NEXT CHAR IN TYPES STRING       013
         AIF   ('STR'(1,1) NE '(').SINGLE   FOR NON-PAIRS OF TYPES     0
PTR     SETC  'STR'(2,1)         ASSUME ONE DIGIT LONG                01
         AIF   ('STR'(3,1) EQ ',').OKLOOK   IT WAS ONE DIGIT, GET #2OP 0
PTR     SETC  'STR'(2,2)         FIRST TYPE: 2 DIGITS LONG            01
END     SETC  'STR'(5,2)         SHOULD BE LEN=2; IF NOT, CAUGHT LATR 01
         AGO   .SETOK              HAVE CHAR STRINGS OF TWO TYPE LIMITS
.OKLOOK  ANOP                      FIND TYPE LIM #2 DIGIT LENGTH
END     SETC  'STR'(4,1)         ASSUME OF LENGTH 1, SINCE FIRST WAS  01
         AIF   ('STR'(5,1) EQ ')').SETOK   IT IS OF LENGTH 1, SO IS OK 0
END     SETC  'STR'(4,2)         SECOND LIMIT IS A 2 DIGIT #          01
.SETOK   ANOP
PTRVAL  SETA  PTR                GET INTEGER VALUE FOR BIT MARKING    01
ENDVAL  SETA  END                INTEGER ENDING VALUE                 01
         AIF   (PTRVAL GT ENDVAL OR PTRVAL LT 1 OR ENDVAL GT 15).ER 0136
.NEXT    ANOP                      LOOP TO SET UP BIT MARKERS FOR TYPES
BIT(PTRVAL)  SETB  1             MARK THIS INTERRUPT TO BE CAUGHT     01
         AIF   (PTRVAL EQ ENDVAL).SKIP   ALL DONE, SEE IF MORE INTRPS 01
PTRVAL  SETA  PTRVAL+1           FLAG NEXT INTERRUPT TYPE TO CATCH    01
         AGO   .NEXT               MARK IT IN BIT FLAG FIELD
.SINGLE  AIF   (TYPES(I) LT 1 OR TYPES(I) GT 15).ER  OUT OF RANGE   0136
BIT(STR)     SETB  1             CATCH THIS INTERRUPT TYPE (BIT MARK) 01
.SKIP    ANOP                      GET NEXT OPERAND FROM CATCH         0
I       SETA  I+1                UP SCAN POINTER TO NEXT LOC.         01
         AIF   (I LE N'TYPES).TOP    GET NEXT MASK SPEC., IF IT EXIST 01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       WE HAVE THE BIT STRING INITIALIZED, NOW WE MUST BUILD UP     *
.*       THE NEW XSPIEBLK FOR NEW INTERRUPTS AND EXIT ADDRESSES.      *
.*       DETERMINE THE PRESENCE  NATURE OF INTERRUPT EXIT ROUTINE    * 0
.*       ADDRESS AND THE CALLABLE EXIT ADDRESS, AND PUT IN XSPIEBLK   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         CNOP  2,4 .               ALIGNMENT FOR ADCONS
         LA    R1,*+18 .           ADDRESS FOR BRANCH AROUND XSPIEBLK
         BALR  R1,R1 .             BR AROUND BLK; R1 <= @ XSPIEBLK
         AIF   ('EXIT' EQ '').NOEXIT  NO EXIT RTN @ SUPPLIED           0
         AIF   ('EXIT'(1,1) EQ '(').INREG  EXIT RTN @ IS IN A REGISTER 0
         DC    AL4(EXIT) .        # OF EXIT RTN                        0
.CONT    AIF   ('CE'(1,1) EQ '(').CEREG    @ IS IN A REGISTER          0
         DC    AL4(CE) .          CALLABLE EXIT ROUTINE ADDRESS        0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       EXPAND BIT PATTERN FOR INTERRUPT TYPES TO CATCH.  EXPANDED   *
.*       TO A FULLWORD FOR EASIER MANIPULATION                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.INT     DC    B'0BIT(1)BIT(2)BIT(3)BIT(4)BIT(5)BIT(6)BIT(7)BITX01363260
               (8)BIT(9)BIT(10)BIT(11)BIT(12)BIT(13)BIT(14)BIT(1X0136327
               5)',BL2'0' .    BIT PATTERN WITH PADDED ZEROS
         AIF   (NOT J).KEF        SKIP IF EXIT NOT IN REGISTER        01
         ST    EXIT(1),0(0,R1) .  STORE REG VALUE FOR EXIT @          01
.KEF     AIF   ('CE'(1,1) NE '(').XSPYCAL .    SKIP IF CE NOT IN REG. 01
         ST    CE(1),4(0,R1) .    STORE CALLABLE EXIT @ IN XSPIEBLK    0
         AGO   .XSPYCAL            GO FOR A CALL TO XXXXSPIE TO CHNG PT
.INREG   ANOP                      EXIT IS IN A REGISTER               0
J       SETB  1                   FLAG THIS CONDITION SO WE STORE @    0
.NOEXIT  DC    AL4(0) .            SET ASIDE LOCATION FOR EXIT @
         AGO   .CONT               SEE ABOUT SECOND ADDRESS
.CEREG   DC    AL4(0) .            @ FOR RESERVING LOC. FOR CALLABLE EX
         AGO   .INT                GENERATE BIT PATTERN FOR INTERRUPTS
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       HERE WE ARE INTERESTED IN RESTORING AN OLD XSPIEBLK.  GET    *
.*       XSPIEBLK ADDRESS IN R1.                                      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.RSTR    ANOP
PTR     SETC  'ACTION(2)'        GET SECOND ARGUMENT: REG. IN PARENS  01
END     SETC  'PTR'(2,1)         ASSUME ONLY A ONE DIGIT NUMBER       01
I       SETA  END                CONVERT CHARACTER # TO ACTUAL #      01
         AIF   ('PTR'(3,1) EQ ')').CHKR1  ASSUMPTION WAS RIGHT         0
END     SETC  'PTR'(2,2)         GET THE TWO DIGIT NUMBER             01
I       SETA  END                CONVERT CHARACTER # TO ACTUAL #      01
.CHKR1   AIF   (I EQ 1).XSPYCAL   DON'T DO A :  LR 1,1                 0
         LR    R1,I .             GET @ OF OLD XSPIEBLK IN REG #1      0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*       PREPARE CALL TO XXXXSPIE AND THEN CALL IT.  R1 SHOULD BE     *
.*       POINTING TO THE NEW (OR OLD, IN CASE OF ACTION=(RS)) SPYBLK  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.XSPYCAL CNOP  0,4 .               ALIGNMENT FOR UPCOMING ADCON
         B     *+8 .               SKIP AROUND XXXXSPIE ADCON
         DC    V(XXXXSPIE) .       ENTRY POINT @ FOR ACTION EXECUTION
         L     R15,*-4 .           R15 <- @ OF XXXXSPIE FOR CALL
         BALR  R14,R15 .           CHANGE XSPIEBLK POINTERS--RETURN OL@
         AGO   .XXIT               RETURN
.ER      MNOTE 4,'**ERROR--INVALID SEQUENCE OF INTERRUPT TYPES--$SPIE CX
               ANCELLED'
.XXIT    SPACE 1
         MEND
         TITLE '*** XSRTR-XSAVE/XRETURN TRACE-ASSIST VERSION ***'
         MACRO
         XSRTR TR,LABEL,MSG                                          013
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XSRTR      CREATE SPECIAL ASSIST ENTRY/EXIT TRACE CODE.  *
.*                                     JOHN R. MASHEY-JULY 1969-360/67*
.*       THIS MACRO IS USED BY XSAVE AND XRETURN TO GENERATE THE      *
.*       TRACE CODE CALLS TO XPRNT OR XSNAP, IF THE TR OPERAND IS USED*
.*       *NOTE* THIS IS MODIFIED VERSION FOR USE IN ASSIST ONLY.      *
.*       USES MACROS: XSNAP                                           *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  XSNAPST            XSNAP STATUS;0==>ON,1==>OFF          0
         GBLB  $DEBUG             DEBUG MODE FLAG,0==>YES,1==>NO       0
         GBLC  DEBUG              DEBUG FLAG BITS FOR TESTING          0
         LCLB  XSTSAV             FOR SAVING STATUS VARIABLES          0
         LCLC  NAME               FOR EITHER LABEL OR CSECT            0
         LCLC  T                  FOR TYPE                             0
         AIF   ($DEBUG).XXEXIT    SKIP WHOLE THING IF NO DEBUG         0
NAME    SETC  'LABEL'            ASSUME NAME IS LABEL                 01
         AIF   (T'LABEL NE 'O').XNOK1       SKIP IF LABEL EXISTS       0
NAME    SETC  'SYSECT'           USE CSECT NAME INSTEAD               01
         AIF   ('SYSECT' NE '').XNOK1       SKIP IF CSECT NOT PC       0
NAME    SETC  '$PRIVATE'          USE NAME FOR PRIVATE CODE (PC)       0
.XNOK1   ANOP
XSTSAV  SETB  (XSNAPST)          SAVE XSNAP STATUS, IN CASE OFF       01
XSNAPST SETB  (0)                 MAKE SURE XSNAP WILL GENERATE        0
*        XSNAP LABEL='  MESSAGE '
T       SETC  'PR'                FOR NORMAL PRINTING OF REGS          0
         AIF   ('TR(1)' NE '*').XDFTB       SKIP AND PRINT REGS        0
T       SETC  'NO'                DO NOT PRINT REGISTERS               0
.XDFTB   XSNAP LABEL='*** NAME MSG ***',T=T,IF=(AVDEBUG,O,DEBUG,TM) 0142
XSNAPST SETB  (XSTSAV)           RESTORE STATUS,IN CASE IT WAS OFF    01
.XXEXIT  MEND
         TITLE '*** ALIGN LOCATION COUNTER MACROS - $ALIGN,$ALIGR ***'
         MACRO
LABEL   $ALIGN R,A,TAG                                              0143
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALIGN     GET,ALIGN, RESTORE UPDATED LOCATION COUNTER.  *
.*       USED TO ALIGN LOCATION COUNTER TO H, F, OR D BOUNDARIES.     *
.*       R WILL CONTAIN ALIGNED VALUE OF LOCATION COUNTER            * 0
.*       A GIVES ALIGNMENT REQUIRED , IF IN PARENTHESES, GIVES REG,  * 0
.*       IF NOT, GIVES DECIMAL NUMBER 1-3-7 FOR H,F,D ALIGN           *
.*       TAG  IF CODED-MEANS THAT LOCATION COUNTER IS ALREADY IN R. * 01
.*       USES MACROS: $ALIGR,$GLOC,$SLOC                              *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'TAG EQ 'O').XNORM         NORMAL USE                 0
         AIF   (T'LABEL EQ 'O').XC          SKIP IF NOT NEEDED         0
LABEL   DS    0H                                                       0
         AGO   .XC                 SKIP TO DECIDE
.XNORM   ANOP
LABEL   $GLOC R .                GET THE LOCATION COUNTER             01
.XC      AIF   ('A'(1,1) EQ '(').XREG       SKIP IF REGISTER FORM      0
         LA    R,A.(R) .        INCREMENT THE LOCATION COUNTER       014
         O     R,AWFA .          MAKE LAST BITS ALL 1'S               01
         S     R,AWFA .          SUBTRACT,GETTING RIGHT ALIGNMENT     01
         AGO   .XST                GO STORE IT BACK
.XREG    $ALIGR R,A                                                   01
.XST     $SLOC R .                STORE LOCATION COUNTER BACK          0
         MEND
         SPACE 2
         MACRO
LABEL   $ALIGR R,A                                                   014
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALIGR     ALIGN VALUE IN REGISTER (USUALLY LOCCNTR).    *
.*        ALIGN REGISTER MACRO-ALIGN REGISTER R TO BOUNDARY GIVEN    * 0
.*       BY VALUE IN REG A, WHICH HAS 1,3,7 ETC IN IT.               * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   AR    R,A .             ADD LENGTH-1 TO LOCATION COUNTER     014
         OR    R,A .             MAKE LAST 1-3 BITS ALL 1'S           01
         SR    R,A .             ALIGN VALUE APPROPRIATELY            01
         MEND
         TITLE '*** MISC LOC-COUNTER MACROS-$CKALN,$GLOC,$SLOC ***'
         MACRO
LABEL   $CKALN MASK,B                                                014
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $CKALN     CHECK LOC-COUNTER ALIGNMENT, BRANCH IF OK.    *
.*       USED TO CHECK ALIGNMENT - MASK IS 1-3-7, B IS BRANCH LOC   * 01
.*       IF LOCATION COUNTER IS PROPERLY ALIGNED.                     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   TM    AVLOCNTR+3,MASK .  CHECK FOR RIGHT ALIGNMENT            01
         BZ    B .                TAKE BRANCH IF WAS ALIGNED           0
         MEND
         SPACE 2
         MACRO
LABEL   $GLOC RG                                                      01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GLOC      GET LOCATION COUNTER INTO REGISTER.           *
.*       GET LOCATION COUNTER MACRO-PUTS LOCCNTR VALUE IN RG         * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     RG,AVLOCNTR        GET LOCATION COUNTER                 01
         MEND
         SPACE 2
         MACRO
LABEL   $SLOC RG                                                      01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SLOC      SET LOCATION COUNTER TO REGISTER VALUE.       *
.*       SET LOCATION COUNTER MACRO - SETS RG AS LOCCNTR VALUE       * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   ST    RG,AVLOCNTR        SET LOCATION COUNTER                 01
         MEND
         TITLE '*** SCAN POINTER MACROS - $SCOF, $SCPT ***'
         MACRO
LABEL   $SCOF RG,SCP,BYTE,AD=AVRSBPT                               01534
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SCOF      CONVERT REGISTER SCAN POINTER TO OFFSET VALUE.*
.*       SCAN POINTER OFFSET MACRO - PLACE SCAN POINTER REGISTER SCP * 0
.*       INTO WORK REGISTER RG. FIND OFFSET, AND STORE IT INTO BYTE * 01
.*       IF BYTE SPECIFIED.  AD= WORD GIVING BEGINNING @ FOR OFFSET.* 01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   LR    RG,SCP .          MOVE SCAN POINTER ADDRESS OVER       015
         S     RG,AD .           SUBTRACT STARTING ADDR               01
         AIF   (T'BYTE EQ 'O').XEXIT        SKIP IF NO STORE WANTED    0
         STC   RG,BYTE .         SAVE OFFSET INTO BYTE                01
.XEXIT   MEND
         SPACE 2
         MACRO
LABEL   $SCPT RG,BYTE,AD=AVRSBPT                                    0155
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SCPT      CONVERT OFFSET TO A SCAN POINTER @ INTO REG.  *
.*       GET SCAN POINTER ADDRESS FROM OFFSET-OFFSET IS IN BYTE,ADDR * 0
.*       IS CREATED IN RG.  AD GIVES BEGINNING @ OF FIELD.          * 01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   SR    RG,RG .           CLEAR FOR INSERTION                  015
         IC    RG,BYTE .         GET THE OFFSET VALUE                 01
         A     RG,AD .           ADD START ADDR TO GET REAL ADDR      01
         MEND
         TITLE '*** STORAGE ALLOCATION MACROS - $ALLOCH,$ALLOCL ***'
         MACRO
LABEL   $ALLOCH R,L,OVRFL                                           0157
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALLOCH    GET CORE IN FREEAREA HIGH END (ASSEMLBER).    *
.*       R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  * 0
.*       L  GIVES REGISTER CONTAINING THE LENGTH DESIRED             * 0
.*       OVRFL IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.      * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     R,AVADDHIH .       GET CURRENT HIGH END POINTER         01
         SR    R,L .             GET NEW HIGH END POINTER             01
         C     R,AVADDLOW .       MAKE SURE NO OVERFLOW                0
         BL    OVRFL .            TAKE BRANCH IF OVERFLOW              0
         ST    R,AVADDHIH .       RESTORE UPDATED POINTER              0
         MEND
         SPACE 2
         MACRO
LABEL   $ALLOCL R,L,OVRFL                                           0160
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $ALLOCL    GET CORE IN LOW FREEAREA (IN ASSEMBLER).      *
.*       R  GIVES REGISTER WHERE ADDRESS OF NEW USABLE AREA APPEARS  * 0
.*       L  GIVES REGISTER CONTAINING THE LENGTH DESIRED.            * 0
.*       OVRFL  IS ADDRESS TO BE BRANCHED TO IF OVERFLOW OCCURS.     * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     R,AVADDLOW .       LOAD CURRENT LOW END POINTER         01
         AR    R,L .             ADD REQUESTED LENGTH TO POINTER      01
         C     R,AVADDHIH .       MAKE SURE NO OVERFLOW                0
         BH    OVRFL .            TAKE BRANCH IF OVERFLOW              0
         ST    R,AVADDLOW .       REPLACE UPDATED POINTER              0
         SR    R,L .             RESTORE POINTER                      01
         MEND
         TITLE '*** STORAGE ALLOCATION MACROS - $MALLOCL,$MALLOCH ***'
         MACRO
LABEL   $MALLOCL  R,L,OVRFL=MXPNDOVR,LENG=                       S 01628
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->  MACRO:  MALLOCL    GET CORE IN LOW FREEAREA.  SAME AS ALLOCL * 01
.*        EXCEPT USES AVGEN2CD AS POINTER TO FREE HIGH AREA.  USED IN *
.*        MEXPND                                                      *
.*                                                                    *
.*     R  GIVES REGISTER WHERE ADDRESS OF NEW USEABLE AREA APPEARS   * 0
.*     L  GIVES REGISTER CONTAINING LENGTH DESIRED                   * 0
.*     OVRFL IS @ TO BE BRANCHED TO IF OVERFLOW                      * 0
.*     LENG IS THE LENGTH TO BE ALLOCATED                            * 0
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   DS    0H                  DEFINE LABEL                       S 0
         AIF   ('LENG' EQ '').X                                      S 0
         LA    L,LENG            LOAD LENGTH TO ALLOCATE            S 01
.X       L     R,AVADDLOW         LOAD CURRENT LOW END PTR           S 0
         AR    R,L               ADD REQUESTED LENGTH                 01
         C     R,AVGEN2CD         MAKE SURE NO OVERFLOW                0
         BH    OVRFL              BRANCH IF OVERFLOW                   0
         ST    R,AVADDLOW         REPLACE UPDATED POINTER              0
         SR    R,L               RESTORE POINTER                      01
         MEND
         SPACE 2
         MACRO
LABEL   $MALLOCH  R,L,OVRFL=MXPNDOVR                                0162
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*-->  MACRO:  MALLOCH   GET CORE IN HIGH FREEAREA.  SAME AS ALLOCH * 01
.*        EXCEPT USES AVGEN2CD AS HIGH END POINTER.  USED IN MEXPND   *
.*     R  IS REG NEW USEABLE @ APPEARS IN                            * 0
.*     L  GIVES REGISTER DESIRED LENGTH IS IN                        * 0
.*     OVRFL  IS BRANCH @ IF OVERFLOW OCCURS                         * 0
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     R,AVGEN2CD         LOAD CURRENT HIGH END POINTER        01
         SR    R,L               GET NEW HIGH END POINTER             01
         C     R,AVADDLOW         MAKE SURE NO OVERFLOW                0
         BL    OVRFL              BRANCH IF OVERFLOW                   0
         ST    R,AVGEN2CD         RESTORE UPDATED POINTER              0
         MEND
         TITLE '*** STORAGE DEALLOCATION MACRO - $DALLOCH ***'
         MACRO
LABEL   $DALLOCH R,L                                                 016
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $DALLOCH   RETURN CORE-HIGH FREEAREA (IN ASSEMBLER)      *
.*       R IS A WORK REGISTER, WHICH WILL BE DESTROYED               * 0
.*       L REPRESENTS THE LENGTH. IF 1ST CHAR IS '(', WILL BE        * 0
.*       TAKEN AS REGISTER CONTAINING THE LENGTH, OTHER WISE TO       *
.*       BE AN ACTUAL LENGTH TO BE ADDED.                             *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     R,AVADDHIH .       GET CURRENT HIGH END POINTER         01
         AIF   ('L'(1,1) NE '(').XLENG      IF NOT REG FORM,SKIP       0
         AR    R,L .             ADD THE LENGTH BACK                  01
         AGO   .XST                GO RESTORE
.XLENG   LA    R,L.(R) .        INCREMENT REGISTER                   016
.XST     ST    R,AVADDHIH .       RESTORE UPDATED POINTER              0
         MEND
         TITLE '*** ASSEMBLER SYMBOL DEFINIITON MACRO - $SDEF ***'
         MACRO
LABEL   $SDEF RVAL,RESD,RLENG                                       0166
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SDEF      STORE VALUES IN SYMBOL TABLE ENTRY, FLAG DEFN.*
.*       RVAL     REGISTER CONTAINING SYMBOL VALUE.                  * 0
.*       RESD     REGISTER CONTAINING SECTION ID OF SYMBOL.          * 0
.*       RLENG    REGISTER CONTAINING LENGTH ATTRIBUTE-1 FOR SYMBOL. * 0
.*       *NOTE* SYMSECT DSECT MUST HAVE VALID USING AT TIME OF CALL.  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   ST    RVAL,SYVALUE .     DEFINE VALUE                         01
         STC   RESD,SYESDID .     NOTE ESDID OF SYMBOL                 0
         STC   RLENG,SYLENG .     NOTE LENGTH ATTRIBUTE                0
         OI    SYFLAGS,$SYDEF .    NOTE SYMBOL NOW DEFINED
         MEND
         TITLE '*** $SERR - SET ERROR CODE EQUS AND MESSAGES'
         MACRO
ERR     $SERR MSG,NM                                                 016
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SERR      SET ERROR CODE MESSAGES AND EQU SYMBOLS.      *
.*       CALLED 2 TIMES FOR EACH ERROR EQU, 1 TIME TO SET UP EQU, 1   *
.*       TIME TO CREATE ERROR MESSAGE DC'S IN CSECT OUTPUT OF ASMBLER.*
.*       ERR      IS LAST 5 CHARACTERS OF ERROR MESSAGE EQU SYMBOL.  * 0
.*       MSG      IS THE ERROR MESSAGE ASSOCIATED WITH THE EQU.      * 0
.*       NM       IS THE ERROR CODE FOR EXTERNAL USE - AS###.        * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  $ERNUM,$ERFA      # ERRORS, ADDRESS OFFSET VALUE       01
         GBLA  $OPTMS             MEMORY OPTIMIZATION                  0
         LCLA  I                  LOCAL COUNTER                        0
         AIF   ('SYSECT' EQ 'OUTPUT').SGEN GO TO GEN IF IN OUTPUT      0
.*             GENERATE THE EQU                                       *
$ERNUM  SETA  $ERNUM+2           INCREMENT # ERRORS, EQU VALUE        01
$ERERR  EQU   $ERNUM                                                  01
         MEXIT
.SGEN    AIF   ($OPTMS GT 2).SGEN1    SKIP UNLESS VERY SMALL SYSTEM    0
.*             SMALL MEMORY - GEN JUST ERROR #, DON'T USE POINTERS
.*             OR LENGTHS, SINCE LENGTHS WILL BE CONSTANT = 3.
         DC    C'NM'                                                   0
         AGO   .XXEXIT
.*             GENERATE POINTER TO LENGTH-1 AND ERROR MESSAGE         *
.SGEN1   ORG   OUERRPT+$ERERR                                          0
         DC    H'$ERFA'                                                0
         ORG
I       SETA  K'MSG+K'NM-2      LENGTH-1 OF ERROR MESSAGE            017
.SENORM  DC    AL1(I),C'NM ',CMSG                                    017
$ERFA   SETA  $ERFA+I+2         INCREMENT THE OFFSET POINTER         017
.XXEXIT  MEND
         TITLE '*** $SETRT MACRO - BUILD TRT TABLE FOR SCANNING ***'
         MACRO
LABEL   $SETRT LIST                                                   01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $SETRT     SET UP TRT TABLE FOR SCANNING IN ASSEMBLER.   *
.*       USED INSIDE ASSIST ASSEMBLER TO CREATE TEMPORARY TRT TABLE IN*
.*       COMMON AREA AWTZTAB (WHICH CONTAINS 256 HEX 0'S).            *
.*       LIST IS LIST OF CHARACTER/VALUE PAIRS, WITH CHARACTERS      * 0
.*       ENCLOSED IN QUOTES.  CORRESPONDONG VALUES ARE MOVED INTO     *
.*       CORRESPONDING LOCATIONS IN 256-BYTE TABLE OF ZEROS.          *
.*       IF VALUE IS OMITTED, ZERO IS ASSUMED.                        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  I                                                       0
         LCLC  CH1,CH2                                                01
I       SETA  1                                                        0
         AIF   (T'LABEL EQ 'O').XNOLB                                  0
LABEL   DS    0H                                                       0
.XNOLB   ANOP
CH1     SETC  'LIST(I)'         GET NEXT LIST VALUE                  017
CH2     SETC  'CH1'(1,2)         GET UP TO 2 CHARS                    01
         AIF   ('CH2' EQ 'X''' OR 'CH2' EQ 'C''').XGEN                01
         AIF   ('
CH2'(1,1) EQ '''').XC                                 01746000
CH1     SETC  'C''CH1'''         ADD C' ' TO ELEMENT                  01
         AGO   .XGEN
.XC      ANOP
CH1     SETC  'CCH1'             ADD C TO ELEMENT                     01
.XGEN    ANOP
CH2     SETC  'LIST(I+1)'       GET VALUE OP                         017
         AIF   ('CH2' NE '').XGEN1                                     0
CH2     SETC  '0'                 SET TO ZERO                          0
.XGEN1   MVI   AWTZTAB+CH1,CH2                                        01
I       SETA  I+2                INCREMENT                            01
         AIF   (I LT N'LIST).XNOLB         CONTINUE LOOPING           01
         MEND
         TITLE '*** MISC. UTILITY MACROS - $GTAD,$LV,$STV ***'
         MACRO
LABEL   $GTAD RG,ENTRY                                               017
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $GTAD      LOAD ADCON INTO REGISTER FORM AVWXTABL.       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     RG,AXENTRY                                             017
         MEND
         SPACE 2
         MACRO
LABEL   $LV   RG,AD,L=3                                             0178
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $LV        LOAD VARIABLE LENGTH VALUE INTO REGISTER(ASMB)*
.*       LOAD VARIABLE - PLACES L BYTES IN RG FROM AD              * 017
.*       HIGH ORDER BYTES ARE ZEROED, USES AVFWORK1                   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (L NE 3).XNO3      SKIP IF NOT 3                        0
LABEL   MVI   AVFWORK1,0                                               0
         AGO   .XMVC2              SKIP TO MOVE OVER
.XNO3    ANOP
LABEL   SR    RG,RG .           CLEAR REG FOR ZEROS                  018
         ST    RG,AVFWORK1 .      ZERO WORK WORD OUT                   0
.XMVC2   MVC   AVFWORK1-L+4(L),AD .       MOVE BYTES OVER            018
         L     RG,AVFWORK1 .      LOAD THE REGISTER                    0
         MEND
         SPACE 2
         MACRO
LABEL   $STV  RG,AD,L=3                                             0181
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $STV       STORE VARIABLE LENGTH VALUE FROM REGISTER (AS)*
.*       STORE VARIABLE MACRO-STORES L BYTES FROM LOW ORDER END OF   * 0
.*       REGISTER RG INTO ADDRESS AD.                               * 01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   ST    RG,AVFWORK1 .      STORE REG INTO WORK WORD             01
         MVC   AD.(L),AVFWORK1+4-L                                   018
         MEND
         TITLE '*** CONG MACRO - GEN CONSTATNT CODE TABLES(CODTL1)***'
         MACRO
         CONG  C,TYP,LEN,LD='''',RD='''',LW=1,HI=8,E=$CNERR     01832000
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: CONG       GENERATE CONSTANT CODE TABLE (CSECT CODTL1).  *
.*       USED IN CODTL1 OF ASSEMBLER TO PRODUCE 1 ENTRY IN            *
.*       CONSTANT DESCRIPTION BLOCK.  SEE CONBLK DSECT IN CODTL1.     *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ORG   CODINXO+C'C'       ORG INTO RIGHT SPOT IN TABLE         0
         DC    AL1(CODTC-CONTAB1) DEFINE OFFSET VALUE                  0
         ORG
CODTC   DC    AL1(TYP+$CNC+E,LEN-1,CLD,CRD,LW-1,HI-1)          01844000
         MEND
         TITLE '*** MACROS USED BY THE EXTENDED INTERPRETER ONLY'
         MACRO
LABEL   EITAB INS,SYS,IL,CL,TYPE,OPC,MODCHK,OP1,OP2,D2B,    X01846110
               D2H,ALN,R1,R2,ROUTINE                               01846
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: EITAB       INTERPRETER CONTROL TABLE MACRO              *
.*                                                                    *
.*       THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO CONSTRUCT  *
.*       A SINGLE CONTROL TABLE ENTRY.  EACH TABLE ENTRY DEFINES THE  *
.*       DECODING NECESSARY FOR ITS CORRESPONDING INSTRUCTION(S).     *
.*                                                                    *
.*       IT SHOULD BE NOTED THAT:                                     *
.*         (1)     IT IS SUGGESTED THAT ASTERISKS BE PLACED IN        *
.*                 ARGUMENT FIELDS NOT APPLICABLE TO A PARTICULAR     *
.*                 INSTRUCTION DECODING FORMAT.  IF THIS IS DONE,     *
.*                 THE ARGUMENT FIELDS WILL FORM ALIGNED COLUMNS      *
.*                 IN THE SOURCE LISTING, MAKING READING AND DE-      *
.*                 BUGGING EASIER.                                    *
.*         (2)     ONLY TWO ARGUMENTS ARE REQUIRED FOR EXTENDED       *
.*                 OPCODE INSTRUCTIONS IN THE MAIN TABLE.  THESE      *
.*                 ARE OPC AND ROUTINE.  THE LATTER SHOULD BE       * 01
.*                 THE LABEL OF THE APPROPRIATE EXTENDED OPCODE       *
.*                 SECONDARY TABLE (NOT THE USUAL ROUTINE LABEL).     *
.*                 IT IS SUGGESTED THAT ALL OTHER FIELDS CONTAIN      *
.*                 ASTERISKS.                                         *
.*                                                                    *
.*       ***** ARGUMENTS *****                                        *
.*                                                                    *
.*       INS      = THE MNEMONIC INSTRUCTION CODE (LA,BCT,SR,ETC.)   * 0
.*       SYS      = 360 IF THE INSTR IS GOOD ON 360'S  370'S        * 01
.*                 = 370 IF THE INSTR IS GOOD ONLY ON 370'S           *
.*       IL       = INSTRUCTION LENGTH IN BYTES (2, 4 OR 6)          * 0
.*       CL       = AN INTEGER (1 <= CL <= 8) SPECIFYING THE LENGTH * 01
.*                   OF STORAGE MODIFIED OR FETCHED BY THIS INSTR     *
.*                 = 0   IF THE LENGTH IS CONTAINED IN THE INST ITSELF*
.*                   (SS INSTRUCTIONS)                                *
.*                 = *   IF NOT APPLICABLE                            *
.*       TYPE     = NO  IF THIS IS NOT A PRIVILEGED INSTR            * 0
.*                 = PR  IF THIS IS A PRIVILEGED INSTRUCTION          *
.*       OPC      = NM  IF THIS INSTR'S OPCODE IS NORMAL (8 BITS)    * 0
.*                 = EX  IF THIS INSTR'S OPCODE IS EXTENDED (> 8 BITS)*
.*       MODCHK   = CK  IF THE STORAGE ACCESS @ AND LENGTH ARE TO BE * 0
.*                   RANGE CHECKED IN THE MAIN DECODING LOOP (NEAR    *
.*                   STMT LABEL -> EINOCHK)                           *
.*                 = NO  IF CHECKING SHOULD NOT BE DONE IN THE MAIN   *
.*                   DECODING LOOP                                    *
.*                 = **  IF NOT APPLICABLE                            *
.*       OP1      = F   IF OPRND #1 SHOULD BE FETCH CHECKED          * 0
.*                 = S   IF OPRND #1 SHOULD BE STORE CHECKED          *
.*                 = N   IF NO CHECKING IS REQUIRED FOR OPRND #1      *
.*                 = *   IF NOT APPLICABLE                            *
.*       OP2      = SAME AS OP1, BUT FOR OPRND #2                   * 01
.*       D2B      = RR4 IF 2ND BYTE TO BE DECODED AS 2 REGS (X 4)    * 0
.*                 = LL1 IF 2ND BYTE TO BE DECODED AS 2 FIELDS (X 1)  *
.*                 = IOL IF 2ND BYTE TO BE DECODED AS 1 FIELD (X 1)   *
.*       D2H      = BD  IF 2ND HALFWORD @ IS ONLY BASE+DISPL         * 0
.*                 = IX  IF 2ND HALFWORD @ IS BASE+DISPL+INDEX        *
.*                 = **  IF NOT APPLICABLE                            *
.*       ALN      = DBL IF OPRND ALIGNMENT MUST BE DOUBLEWORD        * 0
.*                 = FUL IF OPRND ALIGNMENT MUST BE AT LEAST FULLWORD *
.*                 = HAF IF OPRND ALIGNMENT MUST BE AT LEAST HALFWORD *
.*                 = NON IF NO ALIGNMENT NEEDED                       *
.*                 = *** IF NOT APPLICABLE                            *
.*        R1       = E   IF THE R1 FIELD MUST SPECIFY AN EVEN REG     *
.*                 = O   IF THE R1 FIELD CAN SPECIFY AN ODD REG       *
.*                 = *   IF NOT APPLICABLE  (IF D2B = RR4)          * 0
.*       R2       = SAME AS R1, BUT FOR R2 FIELD                    * 01
.*       ROUTINE  = A STMT LABEL SPECIFYING A ROUTINE TO WHICH       * 0
.*                   CONTROL IS PASSED FOLLOWING PRIMARY DECODING     *
.*                   (E.G. - EIBAL, EILA, EINORMRR, ETC.)             *
.*                 = A STMT LABEL OF THE SECONDARY CONTROL TABLE      *
.*                   APPROPRIATE FOR AN EXTENDED OPCODE INSTRUCTION   *
.*                   (SEE NOTES ABOVE ARGUMENT LISTING)               *
.*                                                                    *
.** * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLC  BYTE               BYTES ARE BUILT WITH THIS VAR        0
         SPACE 1
EITINS  EQU   *                   LABEL FOR EIXTAB MACRO               0
.*
.*             CHECK IF THIS ENTRY IS FOR AN EXTENDED OPCODE INSTR --
.*             BRANCH IF IT IS
.*
         AIF   ('OPC' EQ 'EX').OPEXTD                                  0
.*
.*             ASSEMBLE AND GENERATE THE 1ST AND 2ND BYTES OF THIS
.*             TABLE ENTRY  --  INCLUDING LABEL IF ANY
.*
BYTE    SETC  '00001000'          INITIAL BYTE SET-UP                  0
         AIF   (SYS EQ 370).OPB1A SKIP IF 370-ONLY INSTR               0
BYTE    SETC  '00001100'          ADD BIT IF 360/370 INSTR             0
.OPB1A   AIF   ('TYPE' NE 'PR').OPB1B  SKIP IF NOT A PRIV INSTR        0
BYTE    SETC  '01'.'BYTE'(3,6)   ADD BIT IF PRIV INSTR                01
.OPB1B   AIF   (IL NE 2).OPB1C    SKIP IF NOT AN RR INSTR              0
BYTE    SETC  'BYTE'(1,2).'1'.'BYTE'(4,5)  ADD BIT IF RR INSTR       018
         AGO   .OPB1D              NO CHECKING IF RR INSTR
.OPB1C   AIF   (('MODCHK' EQ '') OR ('MODCHK' EQ '**') OR ('MODCHK' X018
               EQ 'NO')).OPB1D     SKIP IF NO CHECKING TO BE DONE
!BYTE    SETC  'BYTE'(1,3).'1'.'BYTE'(5,4)  ADD BIT IF CHECKING       01
.OPB1D   ANOP
LABEL   DC    B'BYTE',HL1'IL'                                      L 018
.*
.*             1ST  2ND BYTES GENERATED  --  NOW ASSEMBLE AND          0
.*             GENERATE BYTE # 3
.*
BYTE    SETC  '00000000'          INITIAL BYTE SET-UP                  0
.*             SET OPERAND #1 CHECKING BITS
         AIF   (('OP1' EQ 'N') OR ('OP1' EQ '*')).OPB3A  SKIP IF NOCK 01
BYTE    SETC  '01000000'          AT LEAST THIS BIT IS ON              0
         AIF   ('OP1' EQ 'F').OPB3A  SKIP IF FETCH CHECKING            0
BYTE    SETC  '11000000'          SET STORE CHECK BITS ON              0
.*             SET OPERAND #2 CHECKING BITS
.OPB3A   AIF   (('OP2' EQ 'N') OR ('OP2' EQ '*')).OPB3B               01
BYTE    SETC  'BYTE'(1,2).'010000'  AT LEAST FETCH BIT IS ON          01
         AIF   ('OP2' EQ 'F').OPB3B  SKIP IF FETCH CHECKING            0
BYTE    SETC  'BYTE'(1,2).'110000'  SET STORE CHECK BITS ON           01
.*             SET BIT IF THIS IS A NON-RR BRANCH INSTR
.OPB3B   AIF   ((IL EQ 2) AND ('INS' NE 'XOPC')).OPB3E  SKIP IF RR    01
         AIF   (('INS' NE 'BAL') AND ('INS' NE 'BC') AND ('INS' NE 'X018
               BCT') AND ('INS' NE 'BXH') AND ('INS' NE 'BXLE')).OPB3X01
               C                   SKIP IF NOT A NON-RR BRANCH
BYTE    SETC  'BYTE'(1,4).'1000' SET NON-RR BRANCH INSTR BIT ON       01
.*             SET BIT FOR 2ND HALFWORD DECODING
.OPB3C   AIF   (('D2H' EQ '**') OR ('D2H' EQ 'IX')).OPB3D  NOT = B+D  01
BYTE    SETC  'BYTE'(1,5).'100'  SET BASE+DISP BIT ON                 01
.OPB3D   ANOP
.*             SET BITS FOR 2ND BYTE DECODING (NOT HERE IF AN RR INSTR)
         AIF   ('D2B' EQ 'RR4').OPB3E     SKIP IF RR4                L 0
BYTE    SETC  'BYTE'(1,6).'01'   ASSUME LLX1                          01
         AIF   ('D2B' EQ 'LL1').OPB3E  SKIP IF LLX1                    0
BYTE    SETC  'BYTE'(1,6).'11'   SET BITS FOR IOL                     01
.OPB3E   ANOP
         DC    B'BYTE.'                                                0
.*
.*             1ST 3 BYTES GENERATED  --  NOW DO BYTE 4
.*
BYTE    SETC  '00000000'          INITIAL BYTE SET-UP                  0
         AIF   (('ALN' EQ '') OR ('ALN' EQ 'NON') OR ('ALN' EQ '***'X018
               )).OPB4A
BYTE    SETC  '00000001'          SET HALFWORD ALIGN                   0
         AIF   ('ALN' EQ 'HAF').OPB4A JUMP IF NOW OK                   0
BYTE    SETC  '00000011'          SET FULL WORD ALIGN                  0
         AIF   ('ALN' EQ 'FUL').OPB4A JUMP IF NOW OK                   0
BYTE    SETC  '00000111'          SET DOUBLEWORD ALIGN                 0
.OPB4A   ANOP
         DC    B'BYTE.'                                                0
.*
.*             1ST 4 BYTES GENERATED  --  NOW DO BYTE 5
.*
BYTE    SETC  '00000000'          INITIAL BYTE SET-UP                  0
         AIF   ('D2B' NE 'RR4').OPB5B  SKIP IF NO REGS TO CHK          0
         AIF   ('R1' NE 'E').OPB5A  SKIP IF R1 CAN BE ODD              0
BYTE    SETC  '00010000'          SET BIT FOR R1 EVEN                  0
.OPB5A   AIF   ('R2' NE 'E').OPB5B  SKIP IF R2 CAN BE ODD              0
BYTE    SETC  'BYTE'(1,4).'0001' SET BIT FOR R2 EVEN                  01
.OPB5B   ANOP
         DC    B' BYTE.'
.*
.*             1ST 5 BYTES GENERATED  --  NOW DO BYTE 6
.*             AND THE HALFWORD DISPL TO THE ROUTINE
.*
BYTE    SETC  '0'                 INITIAL BYTE SET-UP                  0
         AIF   (('CL' EQ '*') OR ('CL' EQ '') OR ('CL' EQ '0')).OPB6X018
               A
BYTE    SETC  'CL'                                                    01
.OPB6A   ANOP
         DC    HL1'BYTE.',AL2(ROUTINE.-EISPEJMP)                      01
         SPACE 1
         MEXIT
.*
.*             EXTENDED OPCODE IF HERE -- GENERATE TABLE ENTRY
.*
.OPEXTD  ANOP
LABEL   DC    B'10000000',XL3'0',A(ROUTINE)                         L 01
         SPACE 1
         MEND
         EJECT
         MACRO
LABEL   EIXTAB  L1,L2,L3,L4,L5,_L6,L7,L8                        01846975
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO:  EIXTAB       INTERPRETER SECONDARY CONTROL TABLE MACRO  *
.*                                                                    *
.*             THIS MACRO IS USED BY THE EXTENDED INTERPRETER TO      *
.*             GENERATE THE 256 BYTE SECONDARY TABLE.  THIS TABLE IS  *
.*             INDEXED INTO BY THE OPCODE OF THE INSTRUCTION BEING    *
.*             EXECUTED.  EACH TABLE ENTRY CONTAINS A DISPLACEMENT    *
.*             INTO THE MAIN DECODING TABLE.  INVALID OPCODES ALSO    *
.*             ARE GIVEN DISPLACEMENTS INTO THE TABLE.  THESE         *
.*             POINT TO ZERO ENTRIES IN THE MAIN TABLE NOTING THE     *
.*             THE OPCODES AS BEING INVALID.  THE NUMBER OF           *
.*             PARAMETERS USED FOR A CALL TO THIS MACRO IS 8.  IF     *
.*             8 ARE NOT USED AN MNOTE IS GIVEN AND THE GENERATION    *
.*             FOR THAT MACRO CALL IS TERMINATED.  THE PARAMETERS     *
.*             SHOULD EACH BE THE MNEMONIC OF THE INSTRUCTION OR      *
.*             THE NAME OF THE GROUP OF INSTRUCTIONS REPRESENTED.     *
.*             THESE NAMES MUST CORRESPOND TO NAMES IN THE MAIN       *
.*             TABLE.  NUMERIC PARAMETERS SHOULD BE USED FOR ALL      *
.*             ILLEGAL OPCODES.  THESE SHOULD BE A 2, 4 OR 6          *
.*             DEPENDING ON THE LENGTH OF THE ZERO MAIN TABLE ENTRY   *
.*             BEING INDEXED.                                         *
.*                                                                    *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  L                                                       0
LABEL   DC    0C' '                                                    0
         AIF   (N'SYSLIST EQ 8).EILOOP                                 0
         MNOTE 30,'***** EIGHT INSTRUCTIONS NOT SPECIFIED - ERROR ****'
         MEXIT
.EILOOP  ANOP
L       SETA  L+1                                                     01
         AIF   (T'SYSLIST(L) NE 'N').EINONUM                          01
         AIF   ((
SYSLIST(L) EQ 2) OR (SYSLIST(L) EQ 4) OR (SYSLISTX01847135
               (L) EQ 6)).EINONUM                                      0
         MNOTE 30,'*** NUMERIC VALUE SPECIFIED NOT EQUAL 2, 4, 6 ***'
         MEXIT
.EINONUM ANOP
         DC    AL1((EITSYSLIST(L).-EICONTAB)/8)                       01
         AIF   (L LT 8).EILOOP                                         0
         MEND
         TITLE '*** EVCG TABLE - GENERATE ROW OF EVALUT TRANSITION TAB'
         MACRO
         CROSSET  NUM                                                  0
         GBLB  $XREF              CONTROLS GENERATION OF MACRO         0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: CROSSET               MACRO TO SET FLAGS FOR XREF        *
.*  THIS MACRO IS USED IN THE ICMOP2 CSECT AND IS CALLED EVERY TIME   *
.*  A NEW OPERAND IS SCANNED.  IT SETS THE INSTRUCTION TYPE           *
.*  AND THE FLAG AVXRTYPE.                                            *
.*    NUM ==>  # OF OPERAND BEING SCANNED.  CONTROLS TESTING         * 0
.*              OF CORRECT FLAG.                                      *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (NOT $XREF).NOXREF SKIP IF NOT CROSS REFERENCE          0
         OI    AVXRTYPE,AVXRFTCH .  SET BIT ON
         TM    AVXRMDFT,AVXRMODNUM  .  SEE IF MODIFY REFERENCE         0
         BZ    *+8                 NO SKIP RESETING
         NI    AVXRTYPE,X'FF'-AVXRFTCH  .  TURN OFF FLAG
.NOXREF  MEND
         SPACE 5
         MACRO
LABEL   EVCG  L                                                       01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: EVCG       CREATE ROW OF TRANSITION TABLE (CSECT EVALUT) *
.*       L        LIST OF PAIRS- JUMP LABEL,(ERROR CODE OR STATE #). * 0
.*       CREATES 1 ROW OF TABLE EVCTAB IN GENERAL EXPRESSION EVALUATOR*
.*       CSECT EVALUT.  SEE EVCTDSCT DSECT FOR ENTRIES IN EACH ROW.   *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  I                  LOCAL COUNTER                        0
I       SETA  1                   INIT                                 0
LABEL   DS    0H                                                       0
.EVCA    AIF   (T'L(I+1) EQ 'N').EVCC     JUMP IF IT IS STATE #       01
         DC    AL1(EVL(I)-EVDJUMP,$ERVL(I+1)) .   OFFSET,ERROR      0186
         AGO   .EVCE
.EVCC    DC    AL1(EVL(I)-EVDJUMP,EVCTL(I+1)-EVCTAB)                0186
.EVCE    ANOP
I       SETA  I+2                INCREMENT BY 2 FOR NEXT PAIR         01
         AIF   (I LT N'L).EVCA   GO BACK IF THERE'S MORE              01
         MEND
         TITLE '*** TABLE GENERATION MACROS -IBPRTAB, ICT ***'
         MACRO
LABEL   IBPRTAB OP,VO,VX                                            0188
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: IBPRTAB    GENERATE 1 BLOCK FOR PRINT SCAN LIST          *
.*.      USED ONLY IN IBASM1. CREATES 1 BLOCK: DSECT IBPSCECT         *
.*.      OP       OPERAND NAME (ON, OFF, ETC).                       * 0
.*.      VO       VALUE TO BE OR'D INTO PRINT BYTE: BIT TO SET ON/OFF* 0
.*.      VX       VALUE TO BE XOR'D INTO PRINT CONTROL: EITHER 0     * 0
.*.                IF BIT ON (VX OMITTED), OR SAME AS VO IF * CODED.* 01
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  K                  FOR COUNT                            0
         LCLC  C                  FOR VX VALUE                        01
K       SETA  K'OP-1             GET #-1 OF CHARS IN OPERAND          01
C       SETC  '0'                 ASSUME VX OMITTED                   01
         AIF   ('VX' EQ '').IB1   SKIP IF WAS OMITTED                  0
C       SETC  'VO'               DUPLICATE VALUE OF EQUATE            01
.IB1     ANOP
LABEL   DC    AL1(K,VO,C),C'OP'                                    01881
         MEND
         SPACE 4
         MACRO
LABEL   ICT   TYPE,VALUE                                             019
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ICT        CREATE CONTROL CODES(ICYFLAG) VALUES(ICMOP2). *
.*       TYPE     TYPE OF INSTRUCTION FORMAT ($RR,$RX,ETC).          * 0
.*       VALUE    VALUE OF CODE REQUIRED FOR TABLE.                  * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         ORG   ICTTAB+TYPE/2                                           0
LABEL   DC    AL1(VALUE)                                              01
         MEND
         TITLE '*** OPG MACRO - GENERATE OPCODTB ENTRY FOR OPCOD1 ***'
         MACRO
         OPG   MNEM,TYPE,HEX,MASK,CODE                             01928
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: OPG        CREATE 1 ENTRY IN ASM OPCODE TABLE (OPCOD1).  *
.*       THE GENERATED ENTRY IS DESCRIBED BY DSECT OPCODTB.           *
.*       GENERATES THE 4 FIELDS OF AN OPCODTB ENTRY - OPCTYPE,OPCHEX, *
.*       OPCMASK, AND OPCMNEM.  IF HEX OR MASK ARE OMITTED,THEY     * 01
.*       ARE ASSUMED TO BE 0.   CODE IS USED FOR INSTRUCTIONS WHICH  * 0
.*       MAY NOT BE GENERATED. IF USED , IT IS 'D' FOR DECIMAL INSTS, *
.*       'F' FOR FLOATING POINT INSTRUCTIONS, AND 'P' FOR PRIVILEGED  *
.*       OPERATIONS.  IF THE SPECIFIED TYPE IS NOT TO BE GENERATED,   *
.*       THE APPROPRIATE GLOBAL VARIABLE WILL HAVE BEEN SET, AND THE  *
.*       OPCODTB ENTRY WILL NOT BE CREATED.                           *
.*       CODE = 'M' FOR MACRO OPCODES.                               * 0
.*       CODE = 'FX' FOR EXTENDED FLOATING POINT OPCODES.            * 0
.*       CODE = 'S370' FOR NON-PRIVILEGED S/370 OPCODES.             * 0
.*       CODE = 'P370' FOR PRIVILEGED S/370 OPCODES.                 * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  OPNGN(8)           USED TO KNOW IF LENGTH HAS BEEN USED 0
         GBLB  $DECSA,$FLOTA,$PRIVOP      GENERATION STATUS VARS     019
         GBLB  $MACROS            =1 GEN MACRO OPCODES                 0
         GBLB  $FLOTAX            =1 GEN EXTENDED FP OPCODES           0
         GBLB  $S370A             =1 GEN NON-PRIVILEGED S/370 OPCODES  0
         GBLB  $P370A             =1 GEN PRIVILEGED S/370 OPCODES      0
         AIF   (T'CODE EQ 'O').XNOC         SKIP IF NO CODE USED       0
         AIF   ('CODE' EQ 'F' AND NOT $FLOTA).XEXIT  SKIP IF NOTFLOAT 01
         AIF   ('CODE' EQ 'FX' AND NOT $FLOTAX).XEXIT SKIP IF NO EXFP 01
         AIF   ('CODE' EQ 'D' AND NOT $DECSA).XEXIT  SKIP IF NO DECS  01
         AIF   ('CODE' EQ 'P' AND NOT $PRIVOP).XEXIT SKIP IF NO PRIVS 01
         AIF   ('CODE' EQ 'M' AND NOT $MACROS).XEXIT SKIP IF NO MACRS 01
         AIF   ('CODE' EQ 'S370' AND NOT $S370A).XEXIT SKIP IF NO 370 01
         AIF   ('CODE' EQ 'P370' AND NOT $P370A).XEXIT SKIP IF NO PRV 01
.XNOC    ANOP
OPNGN(K'MNEM) SETB 1       NOTE THAT ONE OF THIS LENGTH HAS BEEN USED 01
         AIF   ('HEX' EQ '' OR 'MASK' EQ '').XNOQ    SKIP IF OMITTED  01
         DC    AL1(TYPE,HEX,MASK),C'MNEM'                           0196
         MEXIT
.XNOQ    AIF   (T'HEX EQ 'O').XNOX    SKIP IF HEX OMITTED.             0
         DC    AL1(TYPE,HEX,0),C'MNEM'                               019
         MEXIT
.XNOX    AIF   (T'MASK EQ 'O').XNOMSK SKIP IF MASK FIELD OMITTED       0
         DC    AL1(TYPE,0,MASK),C'MNEM'                              019
         MEXIT
.XNOMSK  DC    AL1(TYPE,0,0),C'MNEM'                                  01
.XEXIT   MEND
         TITLE '*** OPGT MACRO - GENERATE OPCOD1 POINTER TABLES ***'
         MACRO
         OPGT
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: OPGT       CREATE 2ND LEVEL OPCODE PTR TABLES (OPCOD1).  *
.*       USES MACROS: $AL2                                            *
.*       NOTE OPNGN VALUES WERE SET BY OPG MACRO. CALLED 1 TIME ONLY.* 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  OPNGN(8)           LENGTH TAGS                          0
         LCLC  O                  PREFIX CHARACTERS                    0
         LCLA  I                  LOOP COUNTER                         0
.OPLOOP  ANOP
I       SETA  I+1                INCREMENT TO NEXT LENGTH             02
         AIF   (OPNGN(I)).OPGEN1 GENERATE, IF ANY WERE USED           02
OPFI    EQU   OPADS .             NAME FOR UNUSED # OF LETTERS         0
         AGO   .OPBOT              GO TO BOTTOM OF LOOP
.OPGEN1  ANOP
O       SETC  'OPI'              GET PREFIX CHRACTERS                 02
OPFI    $AL2  OPFIND,                                                 X0
               (O.A,O.B,O.C,O.D,O.L,O.M,O.N,O.S,O.T,O.END)    02024000
.OPBOT   AIF   (I LT 8).OPLOOP    CONTINUE LOOPING                     0
         MEND
         TITLE 'REPRNT MACRO - PRINT MACRO FOR REMONI INTERNAL USE'
         MACRO
LABEL   REPRNT MSG,MSGL                                              020
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: REPRNT     PRINT MESSAGE MACRO FOR REMONI USE            *
.*       MSG  GIVES RX-TYPE ADDRESS OF MESSAGE TO BE PRINTED.        * 0
.*       MSGL GIVES LENGTH OF THE MESSAGE TO BE PRINTED.             * 0
.*       MODIFIES REGISTERS  R7, R8, R14.                             *
.*       CALLS INSUB, REXPRINT.                                       *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   LA    R7,MSG   .         SHOW @ MESSAGE                       02
         LA    R8,MSGL   .        SHOW LENGTH OF MESSAGE               0
         BAL   R14,REXPRINT .      CALL THE INSUB
         MEND
         TITLE 'RFSGN MACRO - GENERATES 1 ENTRY IN TABLE CSECT RFSYMS'
         MACRO
LABEL   RFSGN CSECT,ENTRY,TYPE=0                                    0202
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: RFSGN      GENERATE 1 ENTRY OF REPLACE NAME TABLE(RFSYMS)*
.*             RFSGN MACRO IS USED TO GENERATE THE PRIMARY TABLE      *
.*       OF CSECT NAMES AND THEIR ENTRY POINT NAMES, WHICH IS USED TO *
.*       DO REPLACEMENT AND CHECKING OF STUDENT-WRITTEN CSECTS.       *
.*             IF $REPL=2 AND TYPE=2, RFSGN CREATES AN ELEMENT IN    * 0
.*       THE SECOND SECTION OF RFSYMS, WHICH DESCRIBES A CALLABLE     *
.*       ENTRYPOINT IN REAL ASSIST ROUTINES.                          *
.*       CSECT    NAMES A CSECT WHICH CAN BE REPLACED.               * 0
.*             IF TYPE=2, NAMES A CALLABLE ENTRY FOR 2ND SECTION.     *
.*       ENTRY    IS A LIST OF 1 OR MORE ENTRY POINT NAMES IN CSECT.* 02
.*             IF TYPE=2, THIS ONE IS OMITTED.                        *
.*       TYPE     = 1 IF CSECT MAY CALL OTHER CSECTS, OMITTED IF NOT* 02
.*             =2 IF CALL IS TO CREATE CALLABLE ENTRY ELEMENT.        *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  $REPL              REPLACE VAR. 0=NONE, 1=LIMITED       0
         LCLA  I,N               INDEX, L'ENTRY                      020
         LCLC  EN                 TEMPORARY ENTRY NAME FOR CONVENINCE  0
         AIF   ('TYPE' NE '0' AND $REPL NE 2).RFSB  SKIP IF NOT LIM R 02
         AIF   ('TYPE' EQ '2').RFSA2       SKIP IF TYPE 2 ELEMENT      0
N       SETA  N'ENTRY            GET # ENTRIES, >= 1                  02
.*             RFSYMB,RFSENTN,RFSENTL,RFSTYPE.
LABEL   DC    CL6'CSECT',AL1(N,RFS$LEN*(N+1))                       0202
         AIF   ('TYPE' EQ '0').RFSA1       SKIP IF CAN'T CALL OTHER    0
         DC    AL2(RICSECT-RFSYMS)    REPLACE CSECT WHICH CAN CALL     0
         AGO   .RFSA               GO BACK FOR NEXT
.RFSA1   DC    AL2(0)
.RFSA    AIF   (I GE N).RFSB     JUMP OUT IF NO MORE ENTRIES          02
I       SETA  I+1                INCREMENT INDEX TO ENTRIES           02
.*             RFSYMB,RFSAXPT,RFSRGPT,RFSRHPT.
EN      SETC  'ENTRY(I)'        GET ENTRY, FOR CONVENIENCE           020
         DC    CL6'EN',AL2(AXEN-AX$BASE,RGEN-RG$BASE)                020
         AGO   .RFSA
.RFSA2   ANOP
RFCSECT DC    CL6'CSECT',AL2(AXCSECT-AX$BASE,RHCSECT-RH$BASE)       0202
.RFSB    SPACE 1
         MEND
         TITLE '*** WCONG MACRO - GENERATE CONST.ADDR OFFSET TABLE ***'
         MACRO
         WCONG C                                                       0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: WCONG      CREATE OFFSETS TO CONSTANT SUBR ADCONS-VWXTABL*
.*       CREATE WCONADS TABLE IN VWXTABL FOR USE OF CODTL1 AND CNDTL2 *
.*       IN DOING TABLE-DRIVEN CONSTANT PROCESSING. CALLED 1 TIME ONLY*
.*       C        LIST OF CONSTANT TYPES ALLOWED.    (A,B,C, ETC).   * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LCLA  I                  COUNTER                              0
         AIF   ('SYSECT' NE 'VWXTABL').XXEXIT         SKIP IF NOT VWXT 0
.LOOP    ANOP
I       SETA  I+1                INCREMENT TO NEXT 1                  02
         ORG   WCONADS+$CNC(I)   ORG TO ADCON SPOT                    02
         DC    AL1(AXCC(I).CON1-AXC$BASE)                             02
         AIF   (I LT N'C).LOOP   LOOP UNTIL DONE                      02
         ORG
.XXEXIT  MEND
         TITLE '$TIRC MACRO - TIME OR RECORS -USED OR REMAINING(PSU)'
         MACRO
LABEL   $TIRC TYPE                                                    02
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: $TIRC      GET TIME/RECORDS DATA FROM OPERATING SYSTEM.  *
.*             THIS MACRO USES PSU SVC CALL 250 TO OBTAIN TIME OR     *
.*       RECORDS INFORMATION.  TYPE IS TIMREM,TIMUSE,RECREM,RECUSE.  * 0
.*       RESULT IS RETURNED IN R0, IN EITHER RECORDS, OR IN TIMER     *
.*       UNITS OF 26.04 MICROSECOND.  DESTROYS R0,R1,R15.             *
.*       *NOTE* MAY HAVE TO BE REWRITTEN FOR LOCAL CONDITONS.         *
.*       TYPE CAN ALSO BE OF FORM  (NAME,ADDR)  WHERE ADDR IS AN     * 0
.*       RX-TYPE ADDRESS, AT WHICH THE MACRO PLACES THE FOLLOWING:    *
.*       BYTES  0-4  : ACCOUNT NUMBER       .... INFORMATION FROM     *
.*       BYTES  5-12 : JOB NAME             .... FROM                 *
.*       BYTES 13-32 : PROGRAMMER NAME      .... JOB CARD             *
.*       THIS FORM NEEDED ONLY IF $ACCT=1,  AND IS COMPLETELY LOCAL  * 0
.*       TO PSU CC, THUS MUST BE REWRITTEN IF USED ELSEWHERE.         *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   ('TYPE(1)' NE 'NAME').TIMREC          SKIP IF NOT NAME  0
         CNOP  0,4                 ALIGN FOR LATER ADCON
LABEL   LA    R1,TYPE(2)  .      GET @ WHERE INFO TO BE PUT           02
         ST    R1,*+8 .            STORE INTO PARAMATER LIST
         BAL   R1,*+8 .            SET R1==> ADCON, SKIP AROUND
         DS    A .                 FOR @ AREA FOR INFORMATION
         SR    R15,R15             R15 = 0 PART OF CONVENTION
         SR    R0,R0 .             SET R0 TO 0 FOR NAME CALL
         BCTR  R0,0 .              SET R0 TO -1==> WANT NAME
         SVC   250 .               GET ACCOUNTING INFO****PSU CC*******
         AGO   .XXEXIT             QUIT GENERATING
.TIMREC  ANOP
         AIF   ('TYPE'(1,3) EQ 'TIM').TIM  SKIP IF TIME DESITRED       0
LABEL   SR    R0,R0                                                    0
         SR    R15,R15
         SVC   250 .               MAKE RECORD CALL
         AIF   ('TYPE'(4,3) EQ 'USE').XXEXIT         SKIP IF DONE      0
         LR    R0,R1 .             MOVE RECORDS REMAINING OVER
         MEXIT
.TIM     ANOP
LABEL   LA    R0,1                                                     0
         SR    R15,R15
         SVC   250 .               MAKE CALL FOR TIME INFO
         AIF   ('TYPE'(4,3) EQ 'USE').TIM2 SKIP IF IN RIGHT REG        0
         LR    R0,R1 .             MOVE TIME REMAINING OVER
.TIM2    SLL   R0,2 .              *4 FOR # 26.04 MIC TIMER UNITS
.XXEXIT  MEND
         TITLE 'APCGN MACRO - GENERATE APCBLK IN CSECT APARMS'
         MACRO
LABEL   APCGN PARM,AJOFS,BITS,C=0,N=0,D=0,I1=0,Y=0,G=1,GC=0,#02102040
               LK=111                                                  0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: APCGN      GENERATE 1 APCBLK ELEMENT IN APARMS           *
.*       GENERATES BLOCK FOR PARM OPTION SCANNING CONTROL, DEPENDING  *
.*       ON DESIRED CHARACTERISTICS OF THE PARM. MAY SKIP GENERATION  *
.*       IF THE REQUIRED OPTION DOES NOT EXIST IN PARTICULAR SYSTEM.  *
.*       ***SEE DSECT APCBLK AND CSECT APARMS (FROM LABEL APFOUND)    *
.*       FOR FURTHER INFORMATION ON HANDLING OF BLOCK CREATED BY THIS.*
.*  PARM      NAME OF THE PARM OPTION.                               * 0
.*  AJOFS     NAME OF VARIABLE IN AJOBCON TO BE SET BY THIS PARM     * 0
.*  BITS      VALUE USED TO SET FLAG FOR YES/NO TYPE PARMS.          * 0
.*       IF =PARM AND NOT CALL TYPE, SHOULD BE GIVEN VALUE 0.         *
.*  G,GC     USED TO CONTROL GENERATION.  GENERATION IS SKIPPED     * 02
.*       IF G EQ GC, THUS ALLOWING CONDITIONAL ASSEMBLY OF PARMS.   * 02
.*       C THRU Y GIVE TYPE BITS TO BE PLACED INTO APCFLAG.  EACH   * 02
.*       CORRESPONDS TO 1 OR MORE EQU SYMBOLS, AS LISTED.             *
.*  C         =1 IF PARM IS NONSTANDARD AND A ROUTINE MUST BE CALLED.* 0
.*       APPLIES ONLY TO =VALUE TYPE PARMS.  THE ROUTINE CALLED MUST  *
.*       BE NAMED APAPARM.                           (APCCALL)       * 0
.*  N         =1 IF VALUE CANNOT BE GIVEN ANOTHER VALUE ONCE IT HAS  * 0
.*       BEEN SET ONCE.  MAY BE USED BY ANY PARM TYPE.(APCNRSET)      *
.*  D         =1 IF PARM IS PARM=DECIMAL VALUE.  IF THIS IS CODED    * 0
.*       AND PARM IS NOT A SPECIAL CALL TYPE, THEN IT IS ASSUMED THAT *
.*       THE VALUE CONVERTED IS TO BE STORED AS A FULLWORD AT THE     *
.*       GIVEN VARIABLE LOCATION IN AJOBCON.          (APCD)          *
.*  I1        =1 IF PARM IS A YES/NO TYPE AND  1BIT ON CORRESPONDS   * 0
.*       TO A YES VALUE (1BIT MEANS NO OTHERWISE).    (APCYES1B)      *
.*             =1 IF PARM IS =DECIMAL # PARM, AND MAY NEVER BE        *
.*       INCREMENTED AFTER IT HAS BEEN SET (BUT MAY BE DECREASED).    *
.*       USED PARTICULARLY FOR TIME/RECORDS LIMITS.   (APCNINCR)      *
.*  Y         =1 IF THE PARM IS A YES/NO TYPE.  OTHERWISE, IT IS     * 0
.*       AN =PARM OF SOME SORT.                       (APCYESNO)      *
.*  LK        DENOTES WHICH OF THE POSSIBLE CALLS IS ALLOWED TO SET  * 0
.*       A VALUE FOR THE GIVEN PARM.  CONSISTS OF 3 BITS: ###, WITH   *
.*       MEANINGS AS FOLLOW:                                          *
.*       100   CAN BE SET BY LIMIT OR DEFAULT VALUE  (APCSETLD)       *
.*       010   CAN BE SET FROM THE PARM FIELD         (APCSETP)       *
.*       001   CAN BE SET BY USER FROM $JOB CARD      (APCSETU)       *
.*             THIS MACRO USED ONLY IN APARMS CSECT.                  *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   ('G' EQ 'GC').XXEXIT       SKIP IF FLAGGED THAT WAY    02
LABEL   DC    CL(APCP$L)'PARM',B'LKCNDI1Y',AL1(AJOFS-AJO$APC)  02103680
         DC    B'0'
         AIF   (C EQ 1).APCC      SKIP IF CALL TYPE                    0
         DC    AL1(BITS)                                               0
         MEXIT
.APCC    DC    AL1(APAPARM-APAJUMP)                                    0
.XXEXIT  MEND
         TITLE '*** ASSIST CSECT MACROS: ASPRNT,ASTIME ***'
         MACRO
LABEL   ASPRNT XAREA,XNUM                                            021
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASPRNT     PRINT LINE INSIDE MAIN PROG ASSIST.           *
.*       ASPRNT SETS UP R0=@ LINE, R1=LENG, CALLS INSUB ASASPRNT OF   *
.*       ASSIST.  MODIFIES REGS R0,R1,R14.                            *
.*       XAREA,XNUM SAME AS THOSE FOR $PRNT = @, LENGTH TO PRINT.   * 02
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   LA    R0,XAREA  .        SHOW @ PRINT AREA                    02
         AIF   ('XNUM'(1,1) EQ '(').ASREG  SKIP IF REGISTER FORM       0
         LA    R1,XNUM  .         SHOW LENGTH                          0
         AGO   .ASBAL
.ASREG   LR    R1,XNUM  .         MOVE LENGTH REGISTER VALUE OVER      0
.ASBAL   BAL   R14,ASASPRNT .      CALL INSUB ASPRNT
         MEND
         SPACE 2
         MACRO
LABEL   ASTIME ASH,VALUE                                             021
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASTIME     UPDATE TIMER,PRINT TIMING MESSAGES(ASSIST).   *
.*       ASH      NAME OF MESSAGE, IF OMITTED UPDATE TIMER ONLY.     * 0
.*       VALUE    NAME OF VALUE TO BE CONVERTED, OMITTED-NO 2ND PART * 0
.*       *NOTE* ONLY USABLE INSIDE MAIN PROGRAM ASSIST.               *
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         AIF   (T'ASH NE 'O').ASCALL1       SKIP IF OPERAND USED       0
LABEL   SR    R2,R2 .             SHOW ASTIMER JUST UPDATE TIMER       0
         AGO   .ASCALL2            GO HAVE BAL GENREATED
.ASCALL1 ANOP
LABEL   LA    R2,ASH .           ENTER @ AREA TO BE PRINTED           02
         LA    R3,ASH.P                                                0
         LA    R4,ASH.L  .        LENGTH OF MESSAGE TO BE PRINTED      0
         AIF   ('VALUE' EQ '').ASCNV       SKIP IF NO VALUE            0
         LA    R6,ASH.N .         SHOW @ WHERE STMT/SEC GOES           0
         AIF   ('VALUE' EQ '*').ASCALL2    SKIP IF VALUE ALREADY IN    0
         L     R7,VALUE .         GET VALUE TO BE CONVERTED            0
         AGO   .ASCALL2
.ASCNV   SR    R6,R6 .             SHOW THERE IS NO 2ND PART MESSAGE
.ASCALL2 BAL   R14,ASTIMER .       CALL TEST TIMER ROUTINE
         MEND
         TITLE '*** ASSIST MACROS: ASPAGE,ASRECL,ASTIMR ***'
         MACRO
         ASPAGE CODE                                                   0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASPAGE     LINK TO SECTION OF PAGE CONTROL CODE          *
.*       CODE IS TWO-DIGIT # GIVING DESIRED SECTION OF PAGE CONTROL  * 0
.*       CALL IS GENERATED ONLY IF $PAGE = 1.                        * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLB  $PAGE              =1 PAGE CONTROL CODE EXISTS          0
         AIF   (NOT $PAGE).XXEXIT SKIP IF NO PAGE CODE EXISTS          0
         BAL   R9,ASPAGECODE .    CALL SECTION OF ASPAGE##             0
.XXEXIT  MEND
         SPACE 2
         MACRO
         ASRECL CODE                                                   0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASRECL     LINK TO RECORD LIMIT CONTROL CODE             *
.*       CODE IS TWO DIGIT NUMBER GIVING SECTION OF ASRECL## CALLED  * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         BAL   R9,ASRECLCODE .    CALL SECTION OF ASRECL##             0
         MEND
         SPACE 2
         MACRO
LABEL   ASTIMR CODE,TLEVEL                                           021
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: ASTIMR     LINK TO TIMER ROUTINES IN MAIN PROGRAM ASSIST *
.*       ASTIMR ALLOWS FOR CONDITIONAL GENERATION OF CALLS TO         *
.*       VARIOUS TIMING MODULES INSIDE ASSIST MAIN PROGRAM, DEPENDING *
.*       ON THE DESIRED TIMING METHOD BEING USED.                     *
.*       CODE  IS 2-DIGIT CODE, GIVING SECTION OF ASTIMR TO BE CALLED* 0
.*       TLEVEL IS 0,1,2.  NO CODE IS CREATED IF $TIMER<TLEVEL.    * 021
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         GBLA  $TIMER             TIMER LEVEL BEING USED               0
LABEL   DS    0H                                                       0
         AIF   ($TIMER LT TLEVEL).XXEXIT  SKIP IF NOT IN USE          02
         BAL   R9,ASTIMRCODE .    CALL ENTRY OF ASTIMR## CODE          0
.XXEXIT  MEND
         TITLE '*** XCALL - OS LINKAGE, LITERAL VCON ***'
         MACRO
LABEL   XCALL ENTRY                                                   02
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
.*--> MACRO: XCALL      SUBROUTINE CALL, OS LINKAGE, LITERAL FORM.    *
.*       ENTRY    NAME OF ENTRYPOINT TO BE CALLED.                   * 0
.*  * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
LABEL   L     REP,=V(ENTRY) .    GET @ ENTRY POINT                    02
         BALR  RET,REP .           CALL THE ROUTINE
         MEND
         TITLE '*** GLOBAL SET SYMBOLS AND EQUATES ***'
**       GLOBAL SET VARIABLES - SYSGEN TYPE - $------                * 0
         GBLB  $ACCT              =1 => ACCOUNT DISCRIMINATION POSSIBL 0
         GBLB  $ALIGN             =0 ==> MODEL REQUIRES DATA ALIGNED   0
*                                  =1 ==> MODEL DOES NOT REQUIRE ALIGN
         GBLB  $ASMLVL            =0==>DOS,=1==>OS                     0
         GBLC  $BATCH             LIMIT/DFLT: BATCH(DOS) - NOBATCH(OS) 0
         GBLC  $BTCC(4)           BATCH CONTROL CARD ITEMS: SEE SETC'S 0
         GBLA  $BLEN              SET TO BUFFER LENGTH IN BYTES        0
         GBLA  $BUFNO             THE NUMBER OF BUFFERS                0
         GBLB  $CMPRS             =0 NO CMPRS CODE, =1 CMPRS OPTION    0
         GBLA  $COMNT             >0 COMMENT CHECK ($COMNT % REQ)     02
         GBLB  $DATARD            =0 SOURCE,DATA THRU SYSIN ONLY(WATFV 0
*                                  =1 DATA MAY BE READ FROM FT05F001
*                                  (I.E.- SINGLE JOB PROCESSING-PSU)
         GBLB  $DECSA             SHOULD ASSEMBLER PERMIT DECIMALS     0
         GBLB  $DECSM             DOES MACHINE HAVE DECIMALS           0
         GBLB  $DECK              =0 NO OBJ DECKS PUNCHED. =1 CAN DO   0
         GBLB  $DMPAG             =1 BEGIN DUMP ON NEW PAGE, 0=> NO  J 0
         GBLC  $DSKUDV            DEVICE TYPE FOR DISK DEFAULT TO      0
*                                  2314 DISK DRIVE
         GBLA  $DISKU             0 FOR NO DISK UTILITY                0
*                                      1 FOR USER OPTION
*                                      2 FOR ALWAYS DISK
         GBLB  $FLOTA             SHOULD ASSEMBLER ALLOW FLOATING PT   0
         GBLB  $FLOTAX            SHOULD ASSEMBLER ALLOW EXTENDED FP'S 0
         GBLB  $DEBUG             0==>DEBUG MODE, 1==> PRODUCTION MODE 0
         GBLA  $ERNUM             # DIFFERENT ERROR MESSAGES           0
         GBLB  $EXINT             = 0 REGULAR INTERPRETER              0
*                                  = 1 EXTENDED INTERPRETER
         GBLB  $FLOTE             =1==> WILL INTERPRET FLT,0==> NO     0
         GBLB  $FLOTEX            =1==> WILL INTERPRET EX FP'S,0==> NO 0
         GBLB  $FLOTM             =1==> MACHINE HAS FLTING PT,0==> NO  0
         GBLB  $FLOTMX            =1==> MACHINE HAS EX FP'S,0==> NO    0
         GBLA  $FREE,$FREEMN     DEFAULT FREE=, MINIMUM FREE= (80A) J 02
         GBLC  $GENDAT            GENERATATION DATE FOR THIS ASSIST    0
         GBLB  $HASPBT            =1 HASP AUTOBATCH CODE SUPPORTED   J 0
         GBLB  $HEXO              =1==> HEXO ALLOWED,=0==> NOT ALLOWED 0
         GBLB  $HEXI              =1==> HEXI ALLOWED,=0==> NOT ALLOWED 0
         GBLA  $IDF,$IMX         DEFAULT,MAXIMUM I= # INSTRUCTIONS    02
         GBLC  $IOUNIT(8)         GLOBAL SUBLISTED VARIABLE FOR        0
*                                  DDNAMES IN DCB'S AND DTF'S
*
*        $IOUNIT(1)= PRIMARY INPUT, OS=> SYSIN, DOS=> SYSIPT           0
*        $IOUNIT(2)= SECONDARY INPUT, OS=> FT05F001, DOS=> SYSRDR      0
*        $IOUNIT(3)= PRINTER, OS=>FT06F001, DOS=> SYSLST               0
*        $IOUNIT(4)= PUNCH, OS=> FT07F001, DOS=> SYSPCH                0
*        $IOUNIT(5)= DISK INTERMEDIATE, OS=>FT08F001, DOS=> IJSYS01    0
*        $IOUNIT(6)= MACRO LIBRARY, OS=> SYSLIB, DOS=> N/A             0
*        $IOUNIT(7)= FUTURE USE                                        0
*        $IOUNIT(8)= FUTURE USE                                        0
*
         GBLB  $JRM               =1 FOR PSU LOCAL SPECIAL CODE: JRM   0
         GBLB  $KP26              =1 ALLOW KP=26 OR KP=29 OPTION       0
*                                  =0 ALLOW ONLY 029 KEYPUNCH CARDS
         GBLA  $LDF,$LMX         DEFAULT,MAX L= # LINES/PAGE          02
         GBLB  $MACOPC            =1 ==> ALLOW OPEN CODE COND ASMBL    0
         GBLB  $MACROG            =1 ==> ADD ASM G FEATURES TO ASM F   0
         GBLB  $MACROH            =1 ==> ADD SOME ASM H FEATURES TO F  0
         GBLB  $MACROV            OS/VS SUPPORT                        0
         GBLB  $MACROS            MACRO/CONDITIONAL ASSEMBLY ALLOWED   0
*              **NOTE** BASIC MACRO FACILITY IS ASSEMBLER F COMPATIBLE.
         GBLB  $MACSLB            =1 ==> MACRO LIBRARY ALLOWED         0
         GBLC  $MCHNE             MACHINE GENERATION OF EQUIPMENT      0
         GBLA  $MMACTR            LOCAL ACTR INITIAL VALUE DEFAULT     0
         GBLA  $MMNEST            MACRO NEST LIMIT DEFAULT             0
         GBLA  $MMSTMG            GLOBAL MACRO STMT LIMIT DEFAULT      0
         GBLA  $MODEL             MODEL NUMBER OF 360/370 BEING RUN ON 0
         GBLB  $OBJIN             =0 CANNOT READ OBJECT DECK. =1 CAN   0
         GBLA  $OPTMS             OPTIMIZE - 0==> MEMORY, 9==> SPEED   0
         GBLB  $PAGE              =0 NO PAGE COUNT/CONTROL CODE EXISTS 0
*                                  =1 PAGE CONTROL OPTIONS ALLOWED     0
         GBLA  $PDF,$PMX         DEFAULT,MAX P= # PAGES LIMIT         02
         GBLA  $PDDF,$PDMX       DEFAULT,MAX PD= # PAGES FOR DUMP     02
         GBLB  $PRIVOP            =0==>NO PRIV OPS, =1==> PRIV OPS OK  0
         GBLA  $PRTSIZ            MAX # CHARS IN PRINT LINE FOR ASM    0
         GBLB  $PUNCH             =0 WE DON'T ACTUALLY HAVE CARD PUNCH 0
*                                  =1 REAL PUNCH EXISTS, POSSIBLE USE
         GBLA  $PXDF,$PXMX       DEFAULT,MAX PX= PAGES FOR EXECUTION  02
         GBLB  $P370              =1 WILL INTERPRET PRIVELEGED S/370   0
         GBLB  $P370A             SHOULD ASSEMBLER PERMIT PRIV S/370'S 0
         GBLA  $RDF,$RMX         DEFAULT,MAX R= TOTAL # RECORDS       02
         GBLA  $RDDF,$RDMX       DEFAULT,MAX RD= RECORDS FOR DUMP     02
         GBLA  $RECORD            =0,1=> NO $TIRC RECREM, =2=> $TIRC   0
         GBLB  $RECOVR            (ONLY USED FOR $RECORD=2).          02
*              =0 => R= DOES NOT OVERRIDE $TIRC VALUE, =1 => IT DOES.
*              (AT PSU, OUTPUT CAN GO TO BAT FILES - DOESN'T COUNT).
         GBLB  $RELOC             =0==> NO RELOCATION CODE GENERATED   0
         GBLA  $REPL              0=> NO REPL,1=> LIMITED,2=> FULL     0
         GBLA  $RXDF,$RXMX       DEFAULT,MAX RD= RECORDS FOR EXECUTE  02
         GBLB  $SPECIO            SPECIAL ROUTINES EXIST(TYPE=$IS+)    0
         GBLA  $SYHASH            SIZE OF INITIAL PTR TABLE FOR SYMOPS 0
         GBLC  $SYSTEM            SYSTEM BEGIN RUN - DOS,PCP,MFT,MVT   0
         GBLA  $S370              =0==> NO S/370 INSTR INTERPRETED     0
*                                  =1==> S/370 INSTR INTERPRETED ON 370
*                                  =2==> S/370 INSTR INTERPRETED ON 360
         GBLB  $S370A             SHOULD ASSEMBLER PERMIT SYSTEM 370'S 0
         GBLC  $TDF,$TMX         DEFAULT,MAX T= TOTAL TIME FOR RUN    02
         GBLC  $TDDF,$TDMX       DEFAULT,MAX TD= TIME FOR DUMP        02
         GBLA  $TIMER             0==> NO TIMING AT ALL                0
*              1==> STIMER/TTIMER ONLY. =2==> LOCAL TIMER FOR TIMREM
         GBLC  $TXDF,$TXMX       DEFAULT,MAX TX= TIME FOR EXECUTION   02
         GBLC  $VERSLV            VERSION #.LEVEL #                    0
         GBLB  $XIOS              =0==>NO XIO MACROS,=1==>XIO MACROS   0
         GBLB  $XREF              CONTROL GENERATION OF XREF FACILITY  0
*        =1 FULL XREF, =0 NO XREF AT ALL                              A
         GBLA  $XREFDF(3)         DEFAULT VALUES FOR FLAGS           A 0
*        $XREFDF(1)=0       NO XREF(OTHERS =3MEANS COMPRESSED LISTING  0
*        $XREFDF(2)=3       COLLECT MODIFY AND FETCH DEFN            A 0
*        $XREFDF(3)=3       COLLECT REFERENCES MODIFY/FETCH          A 0
         GBLA  $XREF#B            NUMBER OF SLOTS FOR XREF BLKS      A 0
         GBLB  $XXIOS             =0==>XGET-XPUT MACROS,=1==> NO       0
         GBLB  X$DDMOR          ALLOW USER OWN DDNAMES:=1==>YES,0==>NO 0
**       GLOBAL SET VARIABLES - INTERNAL TYPE -                       *
         GBLC  DEBUG              DEBUG NUMBER FOR TESTING AVDEBUG     0
         GBLC  ID                 IDENT GENERATION CONTROL             0
         GBLC  TRACE              SPECIFIES FORM OF TRACE-SNAP,*,NO    0
$BTCC(1) SETC '$'            CONTROL CHARACTER FOR BATCH CARDS       J 0
$BTCC(2)  SETC  'JOB'            JOB BEGINNING INDICATOR       CPP     0
$BTCC(3) SETC 'ENTRY'        BEGIN DATA CARD: SET = '' IF NONE NEEDED  0
$BTCC(4)  SETC  'END'            TERMINATOR INDICATOR          CPP     0
         SPACE 1
*********  NOTE  ********  SHOULD THE VALUE OF $BLEN BE CHANGED        0
*        AND THE VERSION OF ASSIST TO BE GENERATED IS A DOS SYSTEM
*        THEN BE SURE TO CHANGE THE VALUE OF THE BLKSIZE PARAMETER
*        ON THE DTFSD DEFINITION IN CSECT XXXIOCO
$BLEN   SETA  3520                HALF-TRACK SIZE FOR IBM 2316 PACK    0
$BLEN   SETA  4*($BLEN/4)        ROUND BLEN DOWN TO FULLWORD MULTIPLE 02
$BUFNO  SETA  2                   SET FOR 4 BUFFERS                    0
$CMPRS  SETB  (1)                ALLOW 'CMPRS' OPTION          CPP     0
$COMNT  SETA  80                  REQUIRE 80% COMMENTS, IF COMNT OPT   0
$DATARD SETB  (1)                 ALLOW SINGLE JOB/TWO RDRS            0
$DEBUG  SETB  (1)                 FOR QUICK RUN, KILL GENERATION       0
$DECK   SETB  (1)                 ALLOW OBJECT DECKS TO BE PUNCHED     0
$DECSA  SETB  (1)                 ASSEMBLER WILL ACCEPT DECIMAL INSTS  0
$DECSM  SETB  (1)                 PSU 360/67 HAS DECIMAL INSTRUCTIONS  0
$DISKU  SETA  1                   SET FOR USER OPTION ON DISK UTILITY  0
$DMPAG  SETB  1                   ASSUME COMPLETION DUMP ON NEW PAGE J 0
$EXINT  SETB  1                   USE EXTENDED INTERPRETER           L 0
$FLOTA  SETB  (1)                 ASSEMBLER ALLOWS FLOATING POINT      0
$FLOTAX SETB  (1)                 ASSEMBLER ALLOWS EXTENDED F. P.      0
$FLOTE  SETB  (1)                 WE WILL EXECUTE FLTINGS,IF POSSIBLE  0
$FLOTEX SETB  (1)                 WILL EXECUTE EXTENDED F. P., IF POSS 0
$FLOTM  SETB  (1)                 PSU 360/67 HAS FLOATING POINT        0
$FLOTMX SETB  (0)                 PSU 360/67 HASN'T GOT EXTENDED F. P. 0
$FREE   SETA  30720               RETURN 30K TO OS/360               L 0
$FREEMN SETA  2048                MINIMUM ALLOWED FREE=;  *****NOTE  J 0
*              IF YOU HAVE 80A ABEND'S OFTEN, RAISE THIS AS NEEDED*** J
$GENDAT SETC  '08/26/82'          CURRENT GENERATION DATE              0
$IDF    SETA  150000              100 SECS ON /67                      0
$IMX    SETA  150000              100 SECS ON /67                      0
$KP26   SETB  (1)                 ALLOW 026 KEYPUNCH                   0
$LDF    SETA  63                  DEFAULT 63 LINES/PAGE                0
$LMX    SETA  66                  MAXIMUM OF 77 LINES/PAGE             0
*              MACRO SETS: ONLY SIGNIFICANT IF $MACROS=1.              0
$MACOPC SETB  1                   ALLOW OPEN CODE, AT LEAST FOR TEST   0
$MACROS SETB  1                   ALLOW MACROS TO BE PROC ESSED        0
$MACROG SETB  0                   NO ASM G CODE ***NOT SUPPORTED YET** 0
$MACROH SETB  0                   NO ASM H CODE ***NOT SUPPORTED YET** 0
$MACROV SETB  0                   NO OS/VS ASSEMBLER SUPPORT YET       0
$MACSLB SETB  1                   ALLOW MACRO LIBRARY FETCH            0
$MCHNE  SETC  '370'               PSU RUNS SYSTEM 370                  0
$MMACTR SETA  200                 DEFAULT ACTR VALUE = 200             0
$MMNEST SETA  15                  DEFAULT LIMIT OF 15 DEEP IN MACS     0
$MMSTMG SETA  4000                DEFAULT MAXIMUM TOTAL 4000 MAC STMTS 0
         SPACE 1
$MODEL  SETA  4341                DEFAULT MODEL NUMBER                 0
$OBJIN  SETB  (1)                 ALLOW OBJECT DECKS TO BE READ        0
$OPTMS  SETA  4                   MEDIUM OPTIMIZATION                  0
$PAGE   SETB  (1)                 ALLOW ALL PAGE CONTROL OPTIONS       0
$PDF    SETA  10                  TEN TOTAL PAGES                      0
$PMX    SETA  25                  MAXIMUM POSSIBLE OF 25 TOTAL         0
$PDDF   SETA  1                   NORMAL DUMP-JUST FIRST PAGE          0
$PDMX   SETA  5                   MAXIMUM OF 5 PAGES FOR THE DUMP      0
$PRIVOP SETB  1                   ALLOW ALL PRIVILEGED OPERATIONS      0
$PRTSIZ SETA  133                 LIMIT TO 121 CHARS AS DEFAULT LIM  J 0
$PUNCH  SETB  (1)                 A REAL PUNCH EXISTS                  0
$PXDF   SETA  5                   DEFAULT PAGES FOR EXECUTION          0
$PXMX   SETA  5                   MAXIMUM PAGES FOR EXECUTION          0
$RDF    SETA  100000              DEFAULT RECORDS FOR EXEC             0
$RMX    SETA  100000              MAX EXECUTION RECORDS                0
$RDDF   SETA  25                  DEFAULT RECORDS FOR A DUMP           0
$RDMX   SETA  5000                MAXIMUM RECORDS FOR DUMP             0
$RECORD SETA  1                   SHOW $TIRC RECREM CAN'T BE USED      0
$RELOC  SETB  (1)                 NEED RELOC SINCE WE HAVE REPL        0
$REPL   SETA  2                  ALLOW FULL REPL. OPTIONS      CEH     0
$RXDF   SETA  10000               DEFAULT EXECUTION RECORDS            0
$RXMX   SETA  10000               MAXIMUM EXECUTION RECORDS            0
$SYSTEM SETC  'OS-MUSIC'          SYSTEM IS OS OPTION MVT              0
$S370   SETA  2                   PSU WANTS S/370'S ON 360/67          0
$S370A  SETB  (1)                 ASSEMBLER ALLOWS S/370'S             0
$XIOS   SETB  (1)                 WE'RE ALLOWING XIO MACROS            0
$XXIOS  SETB  1                   ALLOW XGET - XPUT                    0
X$DDMOR SETB  1                   ALLOW USER OWN DD NAMES              0
$HEXI   SETB  (1)                 XHEXI ALLOWED THIS ASSEMBLY          0
$HEXO   SETB  (1)                 XHEXO ALLOWED                        0
$TDF    SETC  '100'               DEFAULT SECONDS FOR RUN              0
$TMX    SETC  '200'               MAX POSSIBLE SECONDS FOR RUN         0
$TDDF   SETC  '.1'                DEFAULT TIME FOR DUMP                0
$TDMX   SETC  '10'                MAXIMUM TIME FOR A DUMP              0
$TIMER  SETA  1                   SHOW WE WANT OVERALL TIMING DONE     0
$TXDF   SETC  '100'               DEFAULT TIME FOR EXECUTION           0
$TXMX   SETC  '200'               MAXIMUM TIME FOR EXECUTION           0
$VERSLV SETC  '4.0/A2'            VERSION LEVEL (CEH,CPP,TXM 12/02/75) 0
$XREF   SETB  1                   ALLOW CROSS REFERENCE                0
$XREFDF(1) SETA  3                PSU TESTING                        L 0
$XREFDF(2) SETA  3                COLLECT ALL MOD/FETCH DEFN         A 0
$XREFDF(3) SETA  3                COLLECT ALL MOD/FETCH REFERENCES   A 0
$XREF#B SETA  10                  ALLOCATE 10 SLOTS/BLOCK            A 0
$ASMLVL SETB  ('$SYSTEM'(1,2) EQ 'OS')     SET LEVEL OF ASSEMBLER     02
$FLOTE  SETB  ($FLOTE AND $FLOTM)         KILL GEN IF NO FLOATS      022
$FLOTEX SETB  ($FLOTEX AND $FLOTMX) KILL GEN IF NO EXTENDED FLOATS   022
$BATCH  SETC  'NOBATCH'          DEFAULT FOR OS IS NOBATCH     CEH     0
$IOUNIT(1)  SETC  'SYSIN'         SET OS PRIMARY INPUT                 0
*$IOUNIT(2)  SETC  'FT05F001'      SET OS SECONDARY INPUT              0
$IOUNIT(2)  SETC  'SYSRDR'      SET OS SECONDARY INPUT                 0
*$IOUNIT(3)  SETC  'FT06F001'      SET OS PRINTER                      0
$IOUNIT(3)  SETC  'SYSPRINT'      SET OS PRINTER                       0
*$IOUNIT(4)  SETC  'FT07F001'      SET OS PUNCH                        0
$IOUNIT(4)  SETC  'SYSPUNCH'      SET OS PUNCH                         0
$IOUNIT(5)  SETC  'FT08F001'      SET OS DISK INTERMEDIATE             0
$IOUNIT(6)  SETC  'SYSLIB'        SET OS MACRO LIBRARY                 0
ID      SETC  '*'                 DEBUG==> GENERATE ID'S AT ENTRIES    0
         ASSYSGEN ,                CALL TO POSSIBLY RESET SET VARIABLES
$P370   SETB  ($PRIVOP AND ($S370 NE 2)) KILL GEN IF NO PRIV OR S370 022
$P370A  SETB  ($PRIVOP AND $S370A) NO PRIV 370'S IF NO PRIV OR S370  022
$ALIGN  SETB  ($ALIGN OR ($S370 EQ 1 OR $MODEL EQ 85)) FORCE VALUE  0226
$MACSLB SETB  ($MACSLB AND $MACROS)  REMOVE LIBRARY IF NO MACROS   J 022
$RELOC  SETB  ($RELOC OR ($REPL NE 0))  IF REPL, MAKE SURE RELOC   J 022
*$HASPBT SETB  ($HASPBT AND $ASMLVL)  ELIM HASP IF NOT OS SYSTEM   J 022
$HASPBT SETB  (0)                       ELIM HASP                      0
         SPACE 2
         TITLE '*** OPCODTB DSECT - OPCODE CONTROL TABLE ENTRY ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: OPCODTB    DESCRIBES 1 ENTRY IN OPOCDE TABLE              *
*        LOCATION: ELEMENTS OF TABLE IN CSECT OPCOD1 OF ASSEMLBER.    *
*        GENERATION: 1 CALL TO MACRO OPG CREATES AN ELEMENT.          *
*        SECTIONS OPCTYPE,OPCHEX,OPCMASK CORRESPOND TO SIMILARLY-NAMED*
*        SECTIONS OF DUMMY SECTION RCODBLK. SEE CSECT OPCOD1.         *
*        NAMES: OPC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
OPCODTB  DSECT
OPCTYPE  DS    C                   TYPE BYTE FOR MNEMONIC
OPCHEX   DS    C                   HEX CODE FOR MACHINE OPS/SUBCODE
OPCMASK  DS    C                   MASK/ALIGNMENT(MACHINE) / SUBCODE
OPCMNEM  DS    CL8                 MNEMONIC- FROM 1 TO 8 CHARACTERS
         SPACE 4
* * * * * EQUATES USED FOR BCR INSTRUCTIONS * * * * * * * * * * * * * *
H        EQU   2                   HIGH
L        EQU   4                   LOW
E        EQU   8                   EQUAL
NH       EQU   13                  NOT HIGH
NL       EQU   11                  NOT LOW
NE       EQU   7                   NOT EQUAL
O        EQU   1                   ONES OR OVERFLOW
P        EQU   2                   POSITIVE
M        EQU   4                   MINUS
Z        EQU   8                   ZERO
NP       EQU   13                  NOT POSITIVE
NM       EQU   11                  NOT MINUS
NZ       EQU   7                   NOT ZERO
NO       EQU   14                  NOT ONES OR NOT OVERFLOW
         SPACE 1
$CHN     EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT
$        EQU   0                   FOR ANY FIELD CHANGED DURING EXECUT
         SPACE 1
$PRGFILC EQU   C'5'                CHAR USED TO FILL UNUSED PROG CORE
$PRGFILR EQU   C'4'                CHAR USED TO FILL USER REGS AT FIRST
         TITLE 'DSECT***X$SLOT*** FORMAT OF AN ENTRY FOR XGET-XPUT MON'
X$SLOT   DSECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*-->DSECT: X$SLOT FORMAT FOR XGET-XPUT MONITOR TABLE                  *
*        USED IN XDDGET AND XDDPUT TO CONTROL USE OF CERTAIN          *
*           DD NAMES BY USER WITH XGET-XPUT PERMITTED.                *
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
X$SLNAME DS    CL8                 DDNAME
X$SLFLAG DS    CL1                 FLAG BITS
X$SLWAY  DS    CL1
X$SLLONG EQU   *-X$SLNAME          GET LENGTH OF ENTRY
X$SLOPEN EQU   X'C0'               THESE BITS OFF IF FILE NOT OPEN
X$SLXGET EQU   X'40'               INPUT FILE
X$SLXPUT EQU   X'80'               OUTPUT FILE
X$SLPERM EQU   X'01'               PERMANENT FILE NAME
X$SLCLOS EQU   X'3F'               OPPOSITE OF X$SLOPEN
X$SLPOIN EQU   X'0C'               ON FOR POSSIBLE INPUT OR OUTPUT
X$SLXGPT EQU   X'00'               BITS OFF MEAN USE XGET-XPUT
         TITLE '*** REGISTER EQUATES AND CONVENTIONS ***'
*        *** ABSOLUTE REGISTER EQUATES ***                            *
F0       EQU   0                   FLOATING POINT REGISTER 0          *
F2       EQU   2                   FLOATING POINT REGISTER 2          *
F4       EQU   4                   FLOATING POINT REGISTER 4          *
F6       EQU   6                   FLOATING POINT REGISTER 6          *
         SPACE 1
R0       EQU   0                   SPECIAL WORK REGISTER 0            *
R1       EQU   1                   SPECIAL WORK REGISTER 1            *
R2       EQU   2                   SPECIAL WORK REGISTER 2            *
R3       EQU   3                   GENERAL WORK REGISTER 1            *
R4       EQU   4                   GENERAL WORK REGISTER 2            *
R5       EQU   5                   GENERAL WORK REGISTER 3            *
R6       EQU   6                   GENERAL WORK REGISTER 4            *
R7       EQU   7                   PARAMETER REGISTER 1               *
R8       EQU   8                   PARAMETER REGISTER 2               *
R9       EQU   9                   PARAMETER REGISTER 3               *
R10      EQU   10                  PARAMETER REGISTER 4               *
R11      EQU   11                  PARAMETER REGISTER 5               *
R12      EQU   12                  ASSEMBLER TABLE POINTER-READ ONLY  *
R13      EQU   13                  SAVE AREA POINTER/BASE REG FOR SOME*
R14      EQU   14                  RETURN ADDRESS USED IN CALLS       *
R15      EQU   15                  ENTRY POINT ADDRESS/OFTEN USED BASE*
         SPACE 1
*        *** SYMBOLIC REGISTER EQUATES ***                            *
RW       EQU   R3                  GENERAL WORK REGISTER 1            *
RX       EQU   R4                  GENERAL WORK REGISTER 2            *
RY       EQU   R5                  GENERAL WORK REGISTER 3            *
RZ       EQU   R6                  GENERAL WORK REGISTER 4            *
RA       EQU   R7                  PARAMETER REGISTER 1               *
RB       EQU   R8                  PARAMETER REGISTER 2               *
RC       EQU   R9                  PARAMETER REGISTER 3               *
RD       EQU   R10                 PARAMETER REGISTER 4               *
RE       EQU   R11                 PARAMETER REGISTER 5               *
RAT      EQU   R12                 ASSEMBLER TABLE POINTER-READ ONLY  *
RSA      EQU   R13                 SAVE AREA POINTER/BASE REG FOR SOME*
RET      EQU   R14                 RETURN ADDRESS USED IN CALLS       *
REP      EQU   R15                 ENTRY POINT ADDRESS/OFTEN USED BASE*
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        *** REGISTER CONVENTIONS ***                                 *
*        A. REGISTERS R0-R6 ARE PROTECTED ACROSS CALLS.               *
*        B. REGISTER RAT(R12) MAY NOT BE CHANGED BY ANY ROUTINE.      *
*        C.REGISTERS R7-R11 (RA-RE) ARE COMPLETELY UNPROTECTED ACROSS *
*         CALLS, AND MAY BE USED BY ANY ROUTINE .  PARAMATERS WILL    *
*         NORMALLY BE PLACED TO USE FIRST RA, THEN RB, ETC.  IF MORE  *
*         THAN 5 PARAMATERS ARE REQUIRED, REGISTER RE WILL POINT TO   *
*         AN OS TYPE PARAMATER LIST.                                  *
*        D. EXCEPT FOR THE ABOVE, THE CONVENTIONS ARE EXACTLY THE     *
*         SAME AS STANDARD IBM CONVENTIONS WITH REGARD TO LINKAGE,    *
*         SAVE AREA STRUCTURE, REQUIREMENTS, ETC.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         TITLE '*** ERROR CODE EQUATE SYMBOLS - $ER----- ***'
ALIGN    $SERR 'W-ALIGNMENT ERROR-IMPROPER BOUNDARY',000
ENTRY    $SERR 'W-ENTRY ERROR-CONFLICT OR UNDEFINED',001
EXTRN    $SERR 'W-EXTERNAL NAME ERROR OR CONFLICT',002
RGNUS    $SERR 'W-REGISTER NOT USED',003
ODDRG    $SERR 'W-ODD REGISTER USED-EVEN REQUIRED',004
NOEND    $SERR 'W-END CARD MISSING-SUPPLIED',005
ADDR     $SERR 'ADDRESSIBILITY ERROR',100
CNLNG    $SERR 'CONSTANT TOO LONG',101
CNTYP    $SERR 'ILLEGAL CONSTANT TYPE',102
CONT     $SERR 'CONTINUATION CARD COLS. 1-15 NONBLANK',103
CONTX    $SERR 'MORE THAN 2 CONTINUATION CARDS',104
CXREL    $SERR 'COMPLEX RELOCATABILITY ILLEGAL',105
DCEXT    $SERR 'TOO MANY OPERANDS IN DC',106
DPCSE    $SERR 'MAY NOT RESUME SECTION CODING',107
DUPLF    $SERR 'ILLEGAL DUPLICATION FACTOR',108
EXGTA    $SERR 'EXPRESSION TOO LARGE',109
EXLTA    $SERR 'EXPRESSION TOO SMALL',110
ICNOP    $SERR 'INVALID CNOP OPERAND(S)',111
ILLAB    $SERR 'LABEL NOT ALLOWED',112
ILORG    $SERR 'ORG VALUE IN WRONG SECTION OR TOO LOW',113
INVCN    $SERR 'INVALID CONSTANT',114
INVDM    $SERR 'INVALID DELIMITER',115
INVF     $SERR 'INVALID FIELD',116
INVSY    $SERR 'INVALID SYMBOL',117
IVOPC    $SERR 'INVALID OP-CODE',118
MULDF    $SERR 'PREVIOUSLY DEFINED SYMBOL',119
NEABS    $SERR 'ABSOLUTE EXPRESSION REQUIRED',120
NODLM    $SERR 'MISSING DELIMITER',121
NOIMP    $SERR 'FEATURE NOT CURRENTLY IMPLEMENTED',122
NOOPR    $SERR 'MISSING OPERAND',123
NONAM    $SERR 'LABEL REQUIRED',124
RELOC    $SERR 'RELOCATABLE EXPRESSION REQUIRED',126
SDINV    $SERR 'INVALID SELF-DEFINING TERM',127
START    $SERR 'ILLEGAL START CARD',128
TLIT     $SERR 'ILLEGAL USE OF LITERAL',129
UNDEF    $SERR 'UNDEFINED SYMBOL',130
UNRV     $SERR 'UNRESOLVED EXTERNAL REFERENCE',131
VILCH    $SERR 'ILLEGAL CHARACTER',132
VPARN    $SERR 'TOO MANY PARENTHESIS LEVELS',133
VRELO    $SERR 'RELOCATABLE VALUE USED WITH * OR /',134
VSYNT    $SERR 'SYNTAX',135
VTMTR    $SERR 'TOO MANY TERMS IN EXPRESSION',136
VUNEX    $SERR 'UNEXPECTED END OF EXPRESSION',137
INTPT    $SERR 'STATEMENT CAUSED INTERRUPT',138
         SPACE 1
ILOPR    $SERR 'OPERAND NOT ALLOWED',201
STMNA    $SERR 'STATEMENT OUT OF ORDER',202
SSDIM    $SERR 'SET SYMBOL DIMENSION ERROR',203
INSBV    $SERR 'INVALID NBR OF SUBSCRIPTS',204
ILCNV    $SERR 'ILLEGAL CONVERSION',205
MISQU    $SERR 'MISSING QUOTES IN CHAR EXPR',206
ILMNM    $SERR 'ILLEGAL OR DUP MACRO NAME',207
MXDMD    $SERR 'OPRND NOT COMPATIBLE WITH OPRTR',208
UNDKW    $SERR 'UNDFND OR DUP KEYWORD',209
EXMAC    $SERR 'MNEST LIMIT EXCEEDED',210
ILAT     $SERR 'ILLEGAL ATTRIBUTE USE',211
MEXST    $SERR 'GENERATED STMT TOO LONG',212
OVRGN    $SERR 'GENERATED STMTS OVERWRITTEN',298
         TITLE '*** INSTRUCTION TYPES AND CODES ***'
* * * * * INSTRUCTION TYPES FOR MACHINE INSTRUCTIONS(OPCTYPE FIELD)   *
$IA      EQU   X'00'               (OPCHEX)==> PREFIX FOR MACHINE OPS
$RRM     EQU   2                   RR EXTENDED MNEMONICS -R2
$RXM     EQU   4                   RX EXTENDED MNEMONICS - D2(X2,B2)
$RR      EQU   6                   NORMAL RR - R1,R2
$RX      EQU   8                   NORMAL RX - R1,D2(X2,B2)
$RS      EQU   10                  RS(LM,STM,BXH,BXLE)-R1,R3,D2(B2)
$RSH     EQU   12                  RS(SHIFTS) - R1,D2(B2)
$SI      EQU   14                  SI NORMAL - D1(B1),I2
$SS      EQU   16                  SS-1 LENGTH- D1(L,B1),D2(B2)
$SS2     EQU   18                  SS-2 LENGTHS - D1(L1,B1),D2(L2,B2)
$RSO     EQU   20                  ODD RR-SI'S (SPM,SVC,LPSW,SSM,TS,IO)
$SPC     EQU   22                  SPECIAL(FAKE) INSTRUCTIONS-XREAD,ETC
$ICTMX   EQU   11                  MAXIMUM IC TYPE / 2
         SPACE 1
IAA      EQU   X'10'               (RCMASK) - R1 REQUIRED TO BE EVEN
IAL1     EQU   X'00'               (RCMASK) - LITERAL OK-OP1==>NEVER!
IAL2     EQU   X'08'               (RCMASK) - LITERAL PERMITTED-OP2
IAB      EQU   X'20'               (RCMASK) - R2 REQUIRED TO BE EVEN
         SPACE 1
* * * * * ASSEMBLER INSTRUCTION TYPES - $I------ (OPCTYPE FIELD)  * * *
$IB      EQU   X'C0'               OPCODTB ENTRY TAG BITS FOR AM INST
*              *NOTE* SECTIONS MO, MT DEPEND ON $IB HAVING THIS VALUE *
$IUSING  EQU   2                   USING INSTRUCTION
$IDROP   EQU   4                   DROP INSTRUCTION
$ISTART  EQU   6                   START INSTRUCTION
$ICSECT  EQU   8                   CSECT INSTRUCTION
$IDSECT  EQU   10                  DSECT INSTRUCTION
$IENTRY  EQU   12                  ENTRY INSTRUCTION
$IEXTRN  EQU   14                  EXTRN INSTRUCTION
$IEQU    EQU   16                  EQU INSTRUCTION
$IDC     EQU   18                  DC INSTRUCTION
$IDS     EQU   20                  DS INSTRUCTION
$ICCW    EQU   22                  CCW INSTRUCTION
$ITITLE  EQU   24                  TITLE INSTRUCTION
$IEJECT  EQU   26                  EJECT INSTRUCTION
$ISPACE  EQU   28                  SPACE INSTRUCTION
$IPRINT  EQU   30                  PRINT INSTRUCTION
$IORG    EQU   32                  ORG INSTRUCTION
$ILTORG  EQU   34                  LTORG INSTRUCTION
$ICNOP   EQU   36                  CNOP INSTRUCTION
$IEND    EQU   38                  END INSTRUCTION
$IDEBUG  EQU   40                  DEBUG FLAG SETTING ROUTINE
         SPACE 1
IBNONAM  EQU   X'40'               (OPCHEX)==> LABEL NOT PERMITTED
IBNENAM  EQU   X'20'               (OPCHEX)==> LABEL IS REQUIRED
IBOMOP   EQU   X'10'               (OPCHEX)==> OPERAND MAY BE OMITTED
IBMOSPEC EQU   X'08'               (OPCHEX,RCHEX)==> REQUIRES SPECIAL
*              HANDLING OF SOME KIND IN MOCON1 (END, ALL PRINT CTRL).
IBMOPRCT EQU   X'04'               (OPCHEX,RCHEX)==> IS SOME KIND OF
*              PRINT CNTRL, SO REQUIRES SPEC HANDLING BY MOCON1.
IBMOPRCX EQU   IBMOSPEC+IBMOPRCT   (OPCHEX,RCHEX)==> PRT CNTRL
         TITLE '*** MISCELLANEOUS EQUATE SYMBOLS ***'
$ESDSECT EQU   1                   (AVCESDID)-IN DSECT, EVEN=>CSECT
$IS      EQU   X'40'               OPCTYPE CODE FOR SPECIALS
$IM      EQU   X'80'               OPCTYPE CODE FOR MACROS
         SPACE 1
$IBPON   EQU   X'80'               (AVPRINT,AVPRINT1)-PRINT ON
$IBPGEN  EQU   X'40'               (AVPRINT,AVPRINT1)- PRINT GEN
$IBPDAT  EQU   X'20'               (AVPRINT,AVPRINT1)- PRINT DATA
*                                  PRINT DATA, NODATA ONLY FOR COMPATIB
$IBPLIST EQU   X'02'               (AVPRINT)==> LIST IS ON
         SPACE 1
$IBSTAR1 EQU   X'80'               (AVTAGS1)==> START NO LONGER ALLOWED
$IBDSEC1 EQU   X'40'               (AVTAGS1)==> PROCESSING DSECT NOW
*              IF THIS FLAG IS NOT SET, CURRENT SECTION IS A CSECT.   *
$IBPRCD1 EQU   X'20'               (AVTAGS1) - PRIVATE CODE HAS OCCURRD
         SPACE 1
$INEND2  EQU   B'10000000'         (AVTAGS2)==> ENDFILE ON SYSIN-INCARD
         SPACE 1
$OUMACH  EQU   0                   CODE FOR MACHINE INSTRUCTIONS
$OUCONS  EQU   2                   CODE FOR CONSTANTS
$OULIST  EQU   4                   LISTING CONTROL INSTRUCTONS
$OUCOMM  EQU   6                   COMMENTS,ETC WITHOUT LOCATION COUNTE
* * * * * * * * EQUATES FOR MACRO-TYPE OPCODES* * * * * * * * * * * * *
         SPACE 2
$MACRO   EQU   2                   MACRO DECLARATION
$GBLA    EQU   4                   GLOBAL ARITHMETIC DECLARATION
$GBLB    EQU   6                   GLOBAL BINARY DECLARATION
$GBLC    EQU   8                   GLOBAL CHARACTER DECLARATION
$LCLA    EQU   10                  LOCAL ARITHMETIC DECLARATION
$LCLB    EQU   12                  LOCAL BINARY DECLARATION
$LCLC    EQU   14                  LOCAL CHARACTER DECLARATION
$ACTR    EQU   16                  ACTR INSTRUCTION
$SETA    EQU   18                  SET ARITHMETIC INSTRUCTION
$SETB    EQU   20                  SET BINARY INSTRUCTION
$SETC    EQU   22                  SET CHARACTER INSTRUCTION
$AIF     EQU   24                  AIF INSTRUCTION
$AGO     EQU   26                  AGO INSTRUCTION
$ANOP    EQU   28                  ANOP INSTRUCTION
$MNOTE   EQU   30                  MNOTE INSTRUCTION
$MEXIT   EQU   32                  MEXIT INSTRUCTION
$MEND    EQU   34                  MEND INST
         SPACE 1
$ARITH   EQU   4                   ARITHMETIC VLAUE
$BOOL    EQU   8                   LOGICAL VALUE
$CHAR    EQU   12                  CHARACTER VALUE
         SPACE 1
         TITLE '*** ICBLOCK - MACHINE INSTRUCTION CODE BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ICBLOCK    MACHINE INSTRUCTION OBJECT CODE BLOCK.         *
*        THIS DSECT IS USED TO TRANSMIT DATA FROM ICMOP2 CSECT TO     *
*        OUTPT2 FOR PRINTING MACHINE INSTRUCTIONS.                    *
*        LOCATION: TABLE ICYBLOCK IN CSECT ICMOP2 OF ASSEMBLER.       *
*        NAMES: ICB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ICBLOCK  DSECT
$ICBEA1  EQU   X'40'               (ICBFLAG) ==> EA1 EXISTS
$ICBEA2  EQU   X'20'               (ICBFLAG) ==> EA2 EXISTS
         SPACE 1
ICBEA1   DS    F                   1ST ADDRESS
ICBEA2   DS    F                   2ND ADDRESS
ICBOPR1R DS    0H                  OPCODE - R1 - R2
ICBOP    DS    C                   HEX OPCODE
ICBR1R2  DS    C                   REGISTERS OR LENGTHS OR IMMED.FIELD
ICBOPN1  DS    H                   1ST BASE DISPLACEMENT IN INSTRUCTION
ICBOPN2  DS    H                   2ND BASE DISPLACEMENT IN INSTRUCTION
ICBFLAG  DS    C                   FLAG BYTE FOR EXISTENCE OF EAU,EA2
         TITLE '*** SYMSECT DSECT - SYMBOL TABLE ENTRIES ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: SYMSECT    ASSEMBLER SYMBOL TABLE ENTRY.                  *
*        CREATED BY ENTRY SYENT1 OF CSECT SYMOPS, AND HAS VALUES ADDED*
*        BY MOCON1,IBASM1, FOR VALUE, SECTION ID, LENGTH ATTRIBUTE,   *
*        AND BY ESDOPRS FOR SPECIAL ATTRIBUTES(CSECT,ETC).            *
*        LOCATION:  FREEAREA HIGH END ($ALLOCH'D).                    *
*        NAMES: SY------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
SYMSECT  DSECT
$SYDEF   EQU   X'80'               (SYFLAGS) - SYMBOL HAS BEEN DEFINED
$SYENT   EQU   X'40'               (SYFLAGS) - DECLARED AN ENTRY
$SYCSE   EQU   X'20'               (SYFLAGS) - DECLARED A CSECT
$SYDSE   EQU   X'10'               (SYFLAGS) - DECLARED A DSECT
$SYEXT   EQU   X'08'               (SYFLAGS) - DECLARED EXTRN
$SYXRMD  EQU   X'02'               (SYFLAGS) - XREF HAS MODIFY REFERS A
$SYXRFT  EQU   X'01'               (SYFLAGS) - XREF HAS FETCH REF     A
         SPACE 1
SYLINK   DS    0F                  ADDRESS OF NEXT SYMBOL IN CHAIN
SYHASH2  DS    C                   SECONDARY HASH CODE OF NEXT SYMBOL
SYLINKA  DS    CL3                 ADDRESS REFERRED TO BY SYLINK
SYVALUE  DS    F                   VALUE OF THE SYMBOL
SYESDID  DS    C                   ESDID OF THE SYMBOL
SYLENG   DS    C                   LENGTH ATTRIBUTE OF THE SYMBOL
SYFLAGS  DS    C                   FLAG BYTE
SYCHARS  DS    C                   #-1 OF BYTES IN SYMBOL (RANGE:0-7)
SYMBOL   DS    CL8                4-8 CHARS OF SYMBOL,R-PADDED WITH BLK
         TITLE '*** CNCBLOCK DSECT - CONSTANT CODE BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: CNCBLOCK   CONSTANT CODE BLOCK-DC'S, LITERALS.            *
*        LOCATION: EACH CNCBLOCK IS CREATED IN AREA COBLK OF CODTL1.  *
*        1 OR MORE CNCBLOCKS MAY BECOME PART OF THE RCODBLK CREATED   *
*        IN AREA IBRCB BY IBASM1, AND 1 CNCBLOCK BECOMES PART OF THE  *
*        ENTRY FOR EACH DISTINCT LITERAL(SEE LTLENTRY DSECT, LTOPRS   *
*        CSECT.)                                                      *
*        NAMES: CNC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
CNCBLOCK DSECT
* * * * * CONSTANT TYPE,DESCRIPTOR CODES-USED IN CNCBLOCK AREAS * * * *
$CNA     EQU   0                   A-TYPE CONSTANT TYPE CODE
$CNB     EQU   1                   B-TYPE CONSTANT TYPE CODE
$CNC     EQU   2                   C-TYPE CONSTANT TYPE CODE
$CND     EQU   3                   D-TYPE CONSTANT TYPE CODE
$CNE     EQU   4                   E-TYPE CONSTANT TYPE CODE
$CNF     EQU   5                   F-TYPE CONSTANT TYPE CODE
$CNH     EQU   6                   H-TYPE CONSTANT TYPE CODE
$CNP     EQU   7                   P-TYPE CONSTANT TYPE CODE
$CNV     EQU   8                   V-TYPE CONSTANT TYPE CODE
$CNX     EQU   9                   X-TYPE CONSTANT TYPE CODE
$CNZ     EQU   10                  Z-TYPE CONSTANT TYPE CODE
$CNT$N   EQU   11                  1 MORE THAN MAX $CN# CODE=# TYPES
$CNALN   EQU   X'80'               (CNCTYP)==> ALIGNMENT REQUIRED
$CNVLN   EQU   X'40'               (CNCTYP)==> VARIABLE LENGTH (LIKE C)
$CNMUL   EQU   X'20'               (CNCTYP)==> MULTIPLE CONSTANTS OK
$CNERR   EQU   X'10'               (CNCTYP)==> RB HAS ERR CODE-PASS 2
         SPACE 1
CNCTYP   DS    C                   FLAGS AND TYPE CODE
CNCLEN   DS    C                   LENGTH-1 OF CONSTANT
CNCSCAN  DS    C                   SCAN POINTER TO 1ST CHAR OF 1ST CONS
CNCNUM   DS    C                   NUMBER OF CONSTANTS IN OPERAND
CNCDUP   DS    H                   DUPLICATION FACTOR
CNCTOT   DS    H                   TOTAL LENGTH OF OPERAND(<=65K)
CNC$LEN  EQU   *-CNCBLOCK          LENGTH OF CONSTANT CODE BLOCK
         TITLE '*** RECORD BLOCKS - RCODBLK, REBLK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RCODBLK    RECORD CODE BLOCK - VARIABLE DATA FOR STMT.    *
*        AN RCODBLK IS CREATED BY EITHER IAMOP1 OR IBASM1 DURING      *
*        ASSEMBLER PASS 1 FOR EVERY STATEMENT WITH AN ACCEPTABLE      *
*        OPERATION CODE.  IT CONTAINS VARIABLE INFORMATION WHICH      *
*        DEPENDS ON THE TYPE OF INSTRUCTION, AND MAY INCLUDE HEX      *
*        MACHINE CODES AND MASKS, ALIGNMENT INFORMATION, LITERAL      *
*        ADDRESSES, EQU SYMBOL ADDRESSES, AND 1 -10 CNCBLOCKS FOR DC  *
*        COMMANDS.  THE MOST COMMON LENGTHS ARE 8 AND 12.             *
*        LOCATION: CREATED IN AREA IARCB(IN IAMOP1) OR IBRCB(IN       *
*        IBASM1). STORED IN LOW AREA AFTER ITS RSBLOCK BY UTPUT1.     *
*        FOR MACHINE INSTRUCTIONS, MOVED TO ICRCB(IN ICMOP2) IN PASS 2*
*        NAMES: RC------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RCODBLK  DSECT
RCLENG   DS    C                   LENGTH OF RCB
RCLOC    DS    AL3                 LOCATION COUNTER VALUE
RCTYPE   DS    C                   PRIMARY INSTRUCTION TYPE
RCHEX    DS    C                   HEX CODE FOR MACH OPS, 2ND CODE OTHR
RCMASK   DS    C                   MASK-ALIGNMENT FOR MACH OPS
RCLQ     DS    C                   SLOT FOR LENGTH ATTRIBUTE L'*
RC$LEN   EQU   *-RCODBLK-1         NORMAL LENGTH,WITHOUT LITERAL/EQU
RCLITEQ  DS    A                   LITERAL/EQU ADDRESS
RC$LEN2  EQU   *-RCODBLK-1         LENGTH-1 INCLUDING EQU OR LITERAL
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: REBLK      SCAN POINTER/ERROR CODE PAIR BLOCK.            *
*        LOCATION: AVREBLK(AVWXTABL DSECT), CREATED BY ERRTAG SUBR.   *
*        MOVED INTO LOW AREA FOLLOWING CORRESPONDING RCODBLK. MOVED   *
*        BY UTGET2 BACK INTO AVREBLK AREA IN AVWXTABL DURING PASS 2.  *
*        *NOTE* ONLY EXISTS FOR STATEMENTS HAVING 1 OR MORE ERROR OR  *
*        WARNING MESSAGES ATTACHED TO IT.                             *
*        NAMES: REB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
REBLK    DSECT
REBLN    DS    C                   LENGTH-1 OF ERROR BLOCK
$ERREBMX EQU   4                   MAX # ERROR MESSAGES KEPT PER STMT
*              THERE IS 1 REBLN, UP TO $ERREBMX REBSCN-REBERR PAIRS.
REBSCN   DS    C                   SCAN OFFSET POINTER TO ERROR
REBERR   DS    C                   ERROR CODE
         TITLE '*** RECORD BLOCKS - RSBLOCK,RSCBLK,RSOURCE ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSBLOCK    RECORD SOURCE BLOCK-SOURCE CODE, FLAGS.        *
*        AN RSBLOCK IS CREATED FOR EVERY SOURCE STATEMENT BY INCARD   *
*        AND CONTAINS DATA COMMON TO EVERY STATEMENT, SUCH AS 1-3     *
*        SOURCE CARD IMAGES, FLAGS FOR EXISTENCE OF OTHER RECORD      *
*        BLOCKS.  ONLY RECORD BLOCK NECESSARY FOR A SOURCE STATEMENT. *
*        LOCATION: CREATED IN AVRSBLOC (AVWXTABL DSECT) BY INCARD,    *
*        WITH MODIFICATION BY ERRTAG AND MOCON1. MOVED TO LOW  END    *
*        OF FREEAREA BY UTPUT1, AND REMAINS THERE.                    *
*        NAMES: RSB-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSBLOCK  DSECT
$RSMXCRD EQU   3                   MAXIMUM # OF CARDS IN 1 STATEMENT
$RCBX    EQU   X'80'               (RSBFLAG)==>RECORD CODE BLOCK EXISTS
$REBX    EQU   X'40'               (RSBFLAG)==>RECORD ERROR BLOCK EXIST
$RSCX    EQU   X'20'               (RSBFLAG)==>RECORD SOURCE CODE BLOCK
*              FOLLOWING MAINLY INVOLVED WITH MACRO PROC.
$RSBGENR EQU   X'08'               (RSBFLAG)==> GENERATED STMT
*              I.E., SHOULD BE PRINTED WITH + BEFORE STMT.
$RSBNP## EQU   X'04'               (RSBFLAG)==> DO NOT PROCESS FURTHER,
*              EXCEPT TO PRINT.  HAS STMT #. (COMMENTS, OUTER MACROS).
$RSBNPNN EQU   X'02'               (RSBFLAG)==> DO NOT PROCESS FURTHER,
*              EXCEPT PRINT.  NO STMT #.  (INNER MACROS, SPEC ERRORS).
$RSBMERR EQU   X'01'               (RSBFLAG)==> ERROR RECORD, GIVEN
*              SPECIAL TREATMENT IN OUTPT2, COUNTS AS ERROR.  NOTE:
*              IF THIS FLAG ON, $RSBNPNN SHOULD BE ALSO.
         SPACE 1
RSBLENG  DS    C                   LENGTH-1 OF THIS RSB(0-216)
RSBFLAG  DS    C                   FLAG BITS FOR THIS RSB
RSBNUM   DS    C                   NUMBER OF CARDS USED IN RSB
RSBSCAN  DS    C                   SCAN POINTER OFFSET TO OPERAND FLD
RSB$L    EQU   *-RSBLOCK           LENGTH OF STANDARD PART OF RSBLOCK
RSBSOURC DS    0CL71               SPACE FOR 3 CARD IMAGES
RSBLOPC  DS    CL71                1ST CARD IMAGE
RSB$LN1  EQU   *-RSBLOCK-1         LENGTH-1 DEFAULT VALUE
         DS    2CL71               0-2 MORE CARD IMAGES
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSCBLK     RECORD SOURCE-CONTINUATIONS, SEQUENCE #'S      *
*        CREATED BY INCARD FOR ANY STATEMENT HAVING EITHER SEQUENCE   *
*        NUMBERS OR CONTINUATION PUNCHES.                             *
*        LOCATION: CREATED BY INCARD IN AVRSCBLK(AVWXTABL) DURING     *
*        ASSEMBLY PASS 1. MOVED TO LOW END OF DYNAMIC AREA BY UTPUT1, *
*        FOLLOWING CORRESPONDING REBLK(IF ONE EXISTS).  REMAINS IN    *
*        THAT AREA FOR REST OF PROCESSING.                            *
*        NAMES: RSC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSCBLK   DSECT
RSCLENG  DS    C                   LENGTH-1 OF THIS RSCBLK
* * * * * THE PREVIOUS ENTRIES ARE FIXED,THERE MAY BE UP TO 3 OF REST *
RSCILEN  DS    C                   LENGTH OF INDIVIDUAL CARD IMAGE
RSCONSQ  DS    CL9                 CONTINUATION-SEQUENCE NUMBER COLUMNS
RSC$LEN  EQU   *-RSCILEN           LENGTH OF 1 ENTRY OF VARIABLE PART
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: RSOURCE    DESCRIPTION OF A SINGLE SOURCE CARD            *
*        USED FOR INPUT PROCESSING BY SUBROUTINE INCARD.              *
*        LOCATION: AVRSBLOC(AVWXTABL) DURING CREATION OF RSBLOCK.     *
*        NAMES: RSO-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
RSOURCE  DSECT
RSOLOPC  DS    CL15                LABEL+OPCODE,NORMAL
RSOOPRCM DS    CL56                OPERAND+COMMENTS FIELD
RSOL1    EQU   *-RSOLOPC           LENGTH OF 1ST OR ONLY SOURCE CARD
RSOLC    EQU   *-RSOOPRCM          LENGTH OF SOURCE CONTINUATION CARD
RSOCONT  DS    C                   CONTINUATION COLUMN
RSOSEQN  DS    CL8                 SEQUENCE NUMBERS,IF ANY
         TITLE 'MACLIB DSECT AND EQUS'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT:  MACLIB   THIS DSECT GIVES THE FORMAT OF A MACRO          *
*         LIBRARY ENTRY.                                              *
*        NOTE: THIS IS ONLY MACRO DSECT NEEDED OUTSIDE MACRO PROCESSOR*
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE
MACLIB   DSECT
MCLIBNXT DS    F                   POINTER TO NEXT ENTRY
MCLBNMLN DS    C                   LENGTH OF MACRO LIB ENTRY NAME
MCLBNAM  DS    CL8                 MACRO LIBRARY ENTRY NAME
MCLBFLGS DS    0C                  MACRO LIBRARY ENTRY FLAGS
MCLBTAGS DS    C                   MACLIB ENTRY FLAG BYTE
MCLBFLG2 DS    C                   MACRO LIBRARY ENTRY FLAGS
MCLBFLG3 DS    C                   MACRO LIBRARY ENTRY FLAGS
MCPOPRNB DS    H                   NUMBER OF OPERANDS (NOT LABEL FLD)
MCKOPRNB DS    H                   NUMBER OF KEYWORD OPERANDS
MCDDVPNT DS    F                   LINK TO LOCAL DICT DOPE VECTORS
MCLOCDLN DS    F                   LENGTH OF LOCAL DICTIONARY
MCLDNBRE DS    F                   # OF LOCAL DICT. ENTRIES
MCPARPNT DS    F                   POINTER TO PARAMETER DOPE VECTORS
MCCODLNK DS    F                   POINTER TO DEFINITION CODE
$LMACLIB EQU   *-MACLIB            LENGTH OF MACLIB ENTRY
         SPACE 5                                                      S
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: MSGBLOCK        ERROR MESSAGE BLOCK                       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
MSGBLOCK DSECT                                                        S
MSGLENM1 DS    AL1                 L-1 OF NUMBR+MSG                   S
MSGFLAG  DS    AL1                 MISC FLAG BYTE                     S
MSGNMBR  DS    CL3                 ERROR #                            S
MSGMSG   DS    0C                  VARYING LEN MSG                    S
         SPACE 5                                                      S
AVMCLBDF EQU   X'80'               MCLBTAGS - MACRO DEFINED FLAG
AVMCLBNF EQU   X'40'               MCLBTAGS - MACRO SEARCHED FOR/LIBRY
         TITLE '*** AVWXTABL DSECT - MAIN ASSEMBLER TABLE ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AVWXTABL   MAIN CONTROL TABLE FOR THE ASSEMBLER.          *
*        THIS DSECT IS USED BY ALMOST ALL SUBROUTINES OF THE ASSEMBLER*
*        FOR COMMUNICATION, COMMON CONSTANTS, AND WORKAREAS, AND IS   *
*        ALSO USED SOMEWHAT BY THE MAIN PROGRAM ASSIST AND THE        *
*        REPLACE MONITOR REMONI.                                      *
*        LOCATION: CSECT VWXTABL, WITH SAME NAMES PREFIXED WITH 'A'.  *
*        NAMES: AX------,AW------,AV------  (DEPENDS ON SECTION)      *
*        THIS DSECT CONTAINS THE FOLLOWING SECTIONS:                  *
*                                                                     *
*              1. ADDRESS CONSTANTS(NAMES: AX, FOLLOWED BY ENTRY NAME)*
*        THIS SECTION CONTAINS 1 ADDRESS CONSTANT FOR EVERY CALLABLE  *
*        ENTRY POINT IN THE ASSIST ASSEMBLER.  THESE ARE READ-ONLY,   *
*        EXCEPT DURING A REPLACE RUN, IN WHICH THE ADCONS FOR A       *
*        SINGLE CSECT ARE TEMPORARILY MODIFIED.  THE LABEL AX$BASE IS *
*        USED AS A BASE ADDRESS FOR THE CALCULATION OF OFFSETS TO     *
*        INDIVIDUAL ADCONS, FOR THOSE ROUTINES REQUIRING TABLE-DRIVEN *
*        CALLING SEQUENCES (CNDTL2,CODTL1,MPCON0,REMONI).  NOTE THAT  *
*        ALL ENTRY POINTS HAVE 6-CHARACTER NAMES.  THE MACRO $CALL    *
*        IS USED IN CONJUNCTION WITH THIS PART OF AVWXTABL.           *
*                                                                     *
*              2. CONSTANT VALUES (NAMES: AW------)                   *
*        THIS SECTION CONTAINS USEFUL CONSTANT VALUES, SUCH AS        *
*        ZEROES, BLANKS, MASK VALUES, TRANSLATE TABLES, EDIT PATTERNS.*
*        ALL VALUES ARE READ-ONLY, EXCEPT THAT ANY ROUTINE MAY        *
*        MODIFY PART OF THIS SECTION IF IT RESTORES IT BEFORE         *
*        ALLOWING ANOTHER SUBROUTINE TO GAIN CONTROL.  TRANSLATE      *
*        TABLES INCLUDE ONES FOR SCANNING DECIMAL NUMBERS AND MACHINE *
*        INPUT CONVERSION - HEX TO BINARY, SCANNING SYMBOLS AND       *
*        INSTRUCTION OPERANDS, SCANNING HEXADECIMAL CONSTANTS, DOING  *
*        GENERAL EXPRESSIONS, CONVERTING BINARY TO OUPUT HEXADECIMAL. *
*        GENERATION: SECTION AWCONADS IS CREATED BY MACRO WCONG.      *
*                                                                     *
*              3. VARIABLES (NAMES: AV------)                         *
*        THIS SECTION CONTAINS ALL VARIABLE AREAS USED FOR            *
*        COMMUNICATION INSIDE THE ASSIST ASSEMBLER, IN ADDITION TO    *
*        VARIOUS WORKAREAS, WHICH MAY BE OVERLAPPED TO SAVE SPACE.    *
*        THE AREAS PROVIDED INCLUDE THE RECORD BLOCKS, LOCATION       *
*        COUNTER VALUES, CURRENT SECTION ID, CURRENT DYNAMIC STORAGE  *
*        AREA LIMITS, AND VARIOUS FLAGS.  TEMPORARY WORKAREAS ARE     *
*        SUPPLIED, ALL WITH 'WORK' INCLUDED IN THEIR NAMES, WHICH     *
*        CAN BE USED BY ANY ROUTINE , BUT ARE NOT SAFE ACROSS A       *
*        SUBROUTINE CALL.  NOTE THAT THIS SECTION REQUIRES EQU SYMBOLS*
*        FROM CNCBLOCK AND THE RECORD BLOCKS TO ASSEMBLE CORRECTLY.   *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         EJECT
AVWXTABL DSECT
         SPACE 1
* * * * * NAMES IN AVWXTABL DSECT ARE SAME, EXCEPT WITH A'S PREFIXED  *
* * * * * AVWXTABL SECTION X - ADDRESS CONSTANTS  * * * * * * * * * * *
AX$BASE  DS    0A                  BASE ADDRESS FOR OFFSETS TO ROUTINES
*              *** BROPS2 ENTRY POINTS ***                            *
AXBRINIT DS    V(BRINIT)           BASE-REG INITIALIZATION
AXBRUSIN DS    V(BRUSIN)           BASE-REG SET UP USING VALUE
AXBRDROP DS    V(BRDROP)           BASE REG DROP A REGISTER
AXBRDISP DS    V(BRDISP)           BASE REG GET BASE-DISPLACEMENT
AXC$BASE DS    0F                  BASE ADDRESS FOR CONSTANT ADDR OFFSE
*              *** CACONS ENTRY POINTS ***                            *
AXCACON1 DS    V(CACON1)           SCAN A-TYPE CONST
AXCACON2 DS    V(CACON2)           ASSEMBLE A-TYPE CONSTANT
*              *** CBCONS ENTRY POINTS ***                            *
AXCBCON1 DS    V(CBCON1)           SCAN BINARY CONSTANT
AXCBCON2 DS    V(CBCON2)           ASSEMBLE BINARY CONSTANT
*              *** CCCONS ENTRY POINTS ***                            *
AXCCCON1 DS    V(CCCON1)           SCAN CHARACTER CONSTANT
AXCCCON2 DS    V(CCCON2)           ASSEMBLE CHARACTER CONSTANT
*              *** CDECNS ENTRY POINTS ***                            *
AXCDECN1 DS    V(CDECN1)           SCAN FLOATING PT CONST
AXCDECN2 DS    V(CDECN2)           ASSEMBLE FLOATING PT CONSTANT
AXCDCON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES
AXCECON1 EQU   AXCDECN1            MAKE EQUATE FOR STANDARD NAMES
*              *** CFHCNS ENTRY POINTS ***                            *
AXCFHCN1 DS    V(CFHCN1)           SCAN FIXED POINT CONSTANT
AXCFHCN2 DS    V(CFHCN2)           ASSEMBLE FIXED POINT CONSTANT
AXCFCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES
AXCHCON1 EQU   AXCFHCN1            MAKE EQUATE FOR STANDARD NAMES
*              *** CONSTANT PROCESSOR CONTROL ROUTINES ***            *
AXCNDTL2 DS    V(CNDTL2)           PASS 2 CONSTANT PROCESSING
AXCODTL1 DS    V(CODTL1)           DUPLICATION FACTOR-TYPE-LENGTH PROC
*              *** CPCONS ENTRY POINTS ***                            *
AXCPCON1 DS    V(CPCON1)           SCAN PACKED CONSTANT
AXCPCON2 DS    V(CPCON2)           ASSEMBLE PACKED CONSTANT
*              *** CVCONS ENTRY POINTS ***                            *
AXCVCON1 DS    V(CVCON1)           SCAN V-TYPE CONSTANTS
AXCVCON2 DS    V(CVCON2)           ASSEMBLE V-TYPE ADDRESS CONSTANTS
*              *** CXCONS ENTRY POINTS ***                            *
AXCXCON1 DS    V(CXCON1)           SCAN HEXADECIMAL CONSTANTS
AXCXCON2 DS    V(CXCON2)           ASSEMBLE HEXADECIMAL CONSTANTS
*              *** CZCONS ENTRY POINTS ***                            *
AXCZCON1 DS    V(CZCON1)           SCAN ZONED CONSTANTS
AXCZCON2 DS    V(CZCON2)           ASSEMBLE ZONED CONSTANTS
*              *** ERRORS ENTRY POINTS ***                            *
AXERRTAG DS    V(ERRTAG)           FLAG ERROR
AXERRLAB DS    V(ERRLAB)           ERROR FLAG FOR A LABEL
*              *** ESDOPRS ENTRY POINTS ***                           *
AXESINT1 DS    V(ESINT1)           ESD ROUTINE INITIALIZATION
AXESCSEC DS    V(ESCSEC)           CSECT,START, OR DSECT
AXESENX1 DS    V(ESENX1)           ENTRY OR EXTRN - PASS 1
AXESENX2 DS    V(ESENX2)           PASS 2 ENTRY AND EXTRN
*              *** EVALUT - EXPRESSION EVALUATOR ***                  *
AXEVALUT DS    V(EVALUT)           GENERAL EXPRESSION EVALUATION ROUT
*              *** 2ND LEVEL PROCESSOR CSECTS ***                     *
AXIAMOP1 DS    V(IAMOP1)           MACHINE OPCODES-PASS 1
AXIBASM1 DS    V(IBASM1)           ASSEMBLER OPCODES - PASS 1
AXICMOP2 DS    V(ICMOP2)           MACHINE OPCODES - PASS 2
AXIDASM2 DS    V(IDASM2)           ASSEMBLER OPCODES - PASS 2
*              *** INPUT1 ENTRY POINTS ***                            *
AXINCARD DS    V(INCARD)           INPUT CARD PROCESSOR
*              *** LTOPRS ENTRY POINTS ***                            *
AXLTINT1 DS    V(LTINT1)           LITERAL TABLE INITIALIZATION
AXLTENT1 DS    V(LTENT1)           ENTER A LITERAL INTO POOL
AXLTDMP1 DS    V(LTDMP1)           RETURN LITERAL LENGTH-PASS 1
AXLTEND1 DS    V(LTEND1)           END PASS 1 FOR LITERAL TABLE
AXLTGET2 DS    V(LTGET2)           GET ADDRESS OF LITERAL
AXLTDMP2 DS    V(LTDMP2)           PRODUCE LITERAL RECORDS-PASS 2
*              ** MACROS ENTRY POINTS **                              *
AXMACINT DS    V(MACINT)           MACRO INITIALIZATION ENTRY
AXMACRO1 DS    V(MACRO1)           BUILD MACRO DEFINITION TABLES
AXMEXPND DS    V(MEXPND)           MACRO EXPANSION ENTRY
AXMCBODY DS    V(MCBODY)           PROCESS MACRO DEFINITION BODY
AXMACSCN DS    V(MACSCN)           SCAN MACRO STATEMENT
AXMACFND DS    V(MACFND)           SEARCH MACRO LIBRARY
AXMCVSCN DS    V(MCVSCN)           SCAN VARIABLE SYMBOL
AXMCSCOP DS    V(MCSCOP)           SCAN STANDARD OPERAND
AXMCGTST DS    V(MCGTST)           MOVE STRING TO LOW CORE
AXMCSYSR DS    V(MCSYSR)           SEARCH MACRO LIBRARIES FOR VAR SYMBL
AXMACLEX DS    V(MACLEX)           MACRO STMT LEX ANALYSIS
AXMCGNCD DS    V(MCGNCD)           MACRO DEFINITION CODE GENERATION
AXMXMVSR DS    V(MXMVSR)           MOVE GENERATED STMT TO HIGH CORE
AXMXERRM DS    V(MXERRM)           GENERATE ERROR MESSAGE
AXMCDTRM DS    V(MCDTRM)           CHAR TO BINARY CONVERSION
AXMCATRM DS    V(MCATRM)           TEST FOR ATTRIBUTE
         DS    2V                  SPACE FOR MACRO ENTRY POINTS
*              ***  MAIN PROGRAMS - PASS 12 ***                      * 0
AXMOCON1 DS    V(MOCON1)           MAIN CONTROL - PASS 1
AXMOSTOP DS    V(MOSTOP)           DISASTER EXIT-PASS 1
AXMTCON2 DS    V(MTCON2)           MAIN CONTROL - PASS 2
*              *** OPCOD1 ENTRY POINTS ***                            *
AXOPINIT DS    V(OPINIT)           INITIALIZATION,IF ANY
AXOPFIND DS    V(OPFIND)           LOOKUP OPCODE
*              *** OUTPUT ENTRY POINTS ***                            *
AXOUINT1 DS    V(OUINT1)           INITIALIZATION ENTRY FOR OUTPUT
AXOUTPT2 DS    V(OUTPT2)           OUTPUT LINE PRINTER
AXOUEND2 DS    V(OUEND2)           FINISH UP LAST PRINTING
*              *** SCANRS ENTRY POINTS ***                            *
AXSCANBL DS    V(SCANBL)           SCAN TO FIRST BLANK OUTSIDE OF C'
AXSCANCO DS    V(SCANCO)           SCAN TO COMMA OR BLANK
AXSCANEQ DS    V(SCANEQ)           SCAN TO = OR BLANK
*              *** SDTERM ENTRY POINTS ***                            *
AXSDBCDX DS    V(SDBCDX)           SELF DEFINING TERM-ALL 4 KINDS     *
AXSDBTRM DS    V(SDBTRM)           BINARY SELF-DEFINING TERM
AXSDCTRM DS    V(SDCTRM)           CHARACTER SELF-DEFINING TERM
AXSDDTRM DS    V(SDDTRM)           DECIMAL SELF-DEFINING TERM
AXSDXTRM DS    V(SDXTRM)           HEXADECIMAL SLEF-DEFINING TERM
*              *** SYMOPS ENTRY POINTS ***                            *
AXSYINT1 DS    V(SYINT1)           SYMBOL TABLE INITIALIZATION
AXSYENT1 DS    V(SYENT1)           ENTER A SYMBOL INTO SYMBOL TABLE
AXSYFIND DS    V(SYFIND)           LOOK UP A SYMBOL IN SYMBOL TABLE
AXSYEND2 DS    V(SYEND2)           CLEANUP/STATISTICS AT END OF SYM TAB
*              *** UTOPRS ENTRY POINTS ***                            *
AXUTINT1 DS    V(UTINT1)           UTILITIES INITIALIZATION
AXUTPUT1 DS    V(UTPUT1)           PASS 1 OUTPUT OF EXPANDED RECORDS
AXUTEND1 DS    V(UTEND1)           END PASS 1-INIT FOR PASS 2
AXUTGET2 DS    V(UTGET2)           GET ADDR'S OF EXPANDED RECRDS-PASS 2
AXUTPUT2 DS    V(UTPUT2)           OBJECT CODE CREATION-PASS 2
AXUTEND2 DS    V(UTEND2)           FINISH UP PASS 2
*    CROSS REFERENCE ENTRY POINTS                                     A
AXXRINT1 DS    V(XRINT1)           1ST PASS INIT ROUTINE              A
AXXRINT2 DS    V(XRINT2)           2ND PASS INIT ROUTINE              A
AXXRCOLL DS    V(XRCOLL)           COLLECTION ROUTINE                 A
AXXRPRNT DS    V(XRPRNT)           PRINT ROUTINE                      A
AXXRSCAN DS    V(XRSCAN)           CONTROL CARD SCANNING ROUTINE      A
AXSPECAD DS    A                   BASE ADDRESS FOR SPECIAL ROUTINES
AXSPECA2 DS    A                   BASE @ LEV2-PASS 2 - 'SPECIALS'
         EJECT
* * * * * AVWXTABL SECTION W - CONSTANTS  * * * * * * * * * * * * * * *
AWD0     DS    0D                  FLOATING POINT 0 FOR CDE
AWZEROS  DS    32D'0'              256 BYTES OF BINARY ZEROS
AWD10    DS    D'10'               DOUBLEWORD CONSTANT 10
AWF1     DS    F'1'                FULLWORD 1 CONSTANT
AWH1     EQU   AWF1+2              HALFWORD 1 CONSTANT
AWB1     EQU   AWF1+3              BYTE 1 CONSTANT
AWF3     DS    F'3'                FULLWORD 3 CONSTANT
AWH3     EQU   AWF3+2              HALFWORD 3 CONSTANT
AWB3     EQU   AWF3+3              BYTE 3 CONSTANT
AWF4     DS    F'4'                FULLWORD CONSTANT 4
AWF7     DS    F'7'                FULLWORD 7 CONSTANT
AWH7     EQU   AWF7+2              HALFWORD 7 CONSTANT
AWB7     EQU   AWF7+3              BYTE 7 CONSTANT
AWF10    DS    F'10'               FULLWORD CONSTANT 10
AWH10    EQU   AWF10+2             HALFWORD CONSTANT 10
AWF12    DS    F'12'               FULLWORD CONSTANT 12
AWF15    DS    F'15'               FULLWORD CONSTANT 15 (4 1 BITS)
AWFXF    EQU   AWF15               FULLWORD CONSTANT,4 1-BITS
AWFXFF   DS    F'255'              FULLWORD CONSTANT 255
AWF4095  DS    F'4095'             FULLWORD 4095 CONSTANT
AWFXFFF  EQU   AWF4095             XL4'FFF'      ON F BOUNDARY
AWHXFFF  EQU   AWFXFFF+2           XL2'0FFF'  ON H BOUNDARY
AWFX7FFF DS    X'00007FFF'         MAXIMUM SIZE, MASK VALUE
AWFXFFFF DS    X'0000FFFF'         65K DECIMAL NUMBER
AWFX6F   DS    XL4'FFFFFF'         FULLWORD 24-BIT MASK
AWFM4    DS    F'-4'               FULLWORD -4 CONSTANT
AWFM1    DS    F'-1'               FULLWORD -1 CONSTANT
AWHM1    EQU   AWFM1+2             HALFWORD -1 CONSTANT
         EJECT
*        TABLE USED TO SCAN DECIMAL NUMBERS                           *
*        CHARACTERS 0-9 HAVE ZERO VALUES,ALL OTHERS NONZERO           *
*        ALSO USED IN ICMOP2 FOR GENERAL SCANNING.                    *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
AWTDECT  DS    X'02020202020202020202020202020202'    0
         DS    X'02020202020202020202020202020202'    1
         DS    X'02020202020202020202020202020202'    2
         DS    X'02020202020202020202020202020202'    3
         DS    X'100202020202020202020202020C0202'    4 BLANK (
         DS    X'02020202020202020202020608020202'    5  $ *
         DS    X'02020202020202020202020E02020202'    6  ,
         DS    X'02020202020202020202020606020A02'    7 # @ =
         DS    X'02020202020202020202020202020202'    8
         DS    X'02020202020202020202020202020202'    9
         DS    X'02020202020202020202020202020202'    A
         DS    X'02020202020202020202020202020202'    B
         DS    X'02060404060606060606020202020202'    C B-C(4) ALPHS-6
         DS    X'02060604060606060606020202020202'    D L-(4) ALPHS-6
         DS    X'02020606060606040606020202020202'    E X-(4) ALPHS - 6
         DS    X'00000000000000000000020202020202'    F
         SPACE 1
*        TABLE USED TO SCAN HEXADECIMAL CONSTANTS FOR CORRECTNESS     *
*        CHARACTERS A-F,0-9 ARE ZERO,ALL OTHERS ARE NON-ZERO          *
AWTHEXT  DS    X'02020202020202020202020202020202'    0
         DS    X'02020202020202020202020202020202'    1
         DS    X'02020202020202020202020202020202'    2
         DS    X'02020202020202020202020202020202'    3
         DS    X'02020202020202020202020202020202'    4
         DS    X'02020202020202020202020202020202'    5
         DS    X'02020202020202020202020202020202'    6
         DS    X'02020202020202020202020202020202'    7
         DS    X'02020202020202020202020202020202'    8
         DS    X'02020202020202020202020202020202'    9
         DS    X'02020202020202020202020202020202'    A
         DS    X'02020202020202020202020202020202'    B
         DS    X'02000000000000020202020202020202'    C
         DS    X'02020202020202020202020202020202'    D
         DS    X'02020202020202020202020202020202'    E
         DS    X'00000000000000000000020202020202'    F
         SPACE 1
*        TABLE USED TO CONVERT HEXADECIMAL CONSTANTS                  *
AWTHEX2  EQU   *-C'A'              OFFSET SYMBOL FROM TABLE CORRECTLY
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
         DS      X'0A0B0C0D0E0F000000000000000000'    C
         DS    X'00000000000000000000000000000000'    D
         DS    X'00000000000000000000000000000000'    E
         DS    X'00010203040506070809'                F
         EJECT
*        USED TO SCAN ACROSS SYMBOLS,STOP ON DELIMITERS               *
*        CHARACTERS $,#,@,A-Z,0-9 ARE ZERO. ALL OTHERS ARE NONZERO    *
*        ALSO USED IN EVALUT FOR OPERATOR CODES- (+*)-/,              *
*   TR TABLE      0 1 2 3 4 5 6 7 8 9 A B C D E F                     *
AWTSYMT  DS    X'01010101010101010101010101010101'     0
         DS    X'01010101010101010101010101010101'     1
         DS    X'01010101010101010101010101010101'     2
         DS    X'01010101010101010101010101010101'     3
         DS    X'04010101010101010101010101020501'     4 BLANK (+
         DS    X'01010101010101010101010007030101'     5 $*)
         DS    X'06080101010101010101010401010101'     6 -/,
         DS    X'01010101010101010101010000010101'     7  #@
         DS    X'01010101010101010101010101010101'     8
         DS    X'01010101010101010101010101010101'     9
         DS    X'01010101010101010101010101010101'     A
         DS    X'01010101010101010101010101010101'     B
         DS    X'01000000000000000000010101010101'     C  A-I
         DS    X'01000000000000000000010101010101'     D  J-S
         DS    X'01010000000000000000010101010101'     E  S-Z
         DS    X'00000000000000000000010101010101'     F  0-9
         SPACE 1
AWTZTAB  EQU   AWZEROS             SPACE FOR 256-BYTE ZEROED TRT TABLE
         DS    0D                  LINE UP BLANKS ON D BOUNDARY
AWBLANK  DS    CL132' '            BLANKS
         ORG   AWBLANK+16          MAXIMUM OVERLAP OF AWBLANKAWTHEX3   0
*        TABLE USED TO CONVERT INTERNAL BINARY TO EXTERNAL HEX.       *
*   TR TABLE     0123456789ABCDEF0123456789ABCDEF                     *
AWTHEX3  DS    C'                                '    0-1
         DS    C'                                '    2-3
         DS    C'                                '    4-5
         DS    C'                                '    6-7
         DS    C'                                '    8-9
         DS    C'                                '    A-B
         DS    C'                                '    C-D
         DS    C'                0123456789ABCDEF'    E-F
AWEP4    DS    X'40202120'         4-BYTE DECIMAL EDIT PATTERN
AWEP6    DS    X'402020202120'     6-BYTE EDIT PATTERN FOR DEC #
AWP0     DS    PL1'0'              FOR ZEROING DECIMAL COUNTERS
AWP1     DS    P'1'                DECIMAL CONSTANT 1
AWCONADS DS    ($CNT$N)AL1         OFFSETS TO CONSTANT PROG ADCONS
         EJECT
AVOENTR  EQU   B'00000010'         (AVTAGS1)<AOBJIN> ENTRY @ FROM END
AVO1TXT  EQU   B'00000100'         (AVTAGS1)<AOBJIN> >=1 TXT CARDS FND
         SPACE 1
* * * * * AVWXTABL SECTION V - VARIABLES  * * * * * * * * * * * * * * *
         DS    0D                  GET ALIGNMENT
*        **NOTE  VARIABLES FROM HERE THRU AVAJL ARE GIVEN INITIAL     *
*        VALUES BY CALLING PROGRAM BEFORE CALLING MPCON0.             *
AVADDLOW DS    F                   POINTER TO HIGH END OF LOW AREA
*                        GIVES FIRST FREE LOCATION AT LOW END.        *
AVADDHIH DS    F                   POINTER TO LOW ADDR OF HIGH END
*                        GIVES LOWEST ADDR OF ALREADY USED SPACE      *
AVECONPT DS    A                   @ ECONTROL, IF NEEDED (REPLMON)
AVAJOBPT DS    A                   @ AJOBCON TABLE, IN CASE EVER NEEDED
         SPACE 1
*              VARIABLES FROM HERE TO AVAJL CORRESPOND TO AJOBOCN
*              SECTION AJONERR - AJOAVL, AND CANNOT BE CHANGED WITHOUT
*              EXTREME CARE.  AJOAVL MUST = AVAJL.
         CNOP  2,4                 ALIGN AVNERR LIKE AJONERR
AVNERR   DS    H                   MAX # ACTUAL ERRORS ALLOWED
         SPACE 1
         SPACE 1
*        AVMMACTR-AVMMSTMG MUST BE IN SAME ORDER AS AJOMACTR-AJOMSTMG.
AVMMACTR DS    F                   DEFAULT INITIAL VALUE OF MACRO ACTR
AVMMNEST DS    F                   ABSOLUTE LIMIT ON MACRO NEST LEVEL
AVMMSTMG DS    F                   GLOBAL LIMIT ON MACRO STMTS PROCESSD
AVTAGSM  DS    B                   MACRO OPTIONS BITS (FROM AJOASMFM)
*   BIT7=0 => NO MACROS ALLOWED.   =1(AJOMACRO) => MACROS ALLOWED
*   BIT6=0 => NO ASM G FEATURES.   =1(AJOMACRG) => ADD MACRO G TO ABOVE
*   BIT5=0 => NO ASM H FEATURES    =1(AJOMACRH) => ADD MACRO H TO F
*   REMAINING BITS RESERVED FOR FUTURE USE WITH MACRO PROCESSING.     *
AVTAGS0  DS    B                   FLAG- FUTURE USE FROM AJOBCON
         SPACE 1
AVTAGS1  DS    B                   1ST BYTE OF FLAG BITS
*   BIT0=0 => START ALLOWED, =1($IBSTAR1)=> START NO LONGER ALLOWED.  *
*   BIT1=0 => CURRENT SECTION IS CSECT, =1($IBDSEC1)=> IN DSECT NOW   *
*   BIT2=0 => NO PRIVATE CODE, =1($IBPRCD1)=> PRIV CODE HAS OCCURREC  *
*   BIT3=0 => NORMAL LOAD, =1(AJORELOC)=> LOAD RELOCATED TO REAL @'S  *
*   BIT4=0 => ALL IN CORE, =1(AJODISKU) => USE DISK INTERMEDIATE.     *
*   BIT5=0 => NORMAL PROGRAM, =1(AJOLARGE)=> PROG LARGE, CRUNCH MUCH  *
*   BIT6=0 => LIST SOURCE, =1(AJNLIST)=> NOLIST (EXCEPT ERRORS)       *
*   BIT7=0 => LOAD OBJECT CODE, =1(AJNLOAD)=> CREATE NO OBJECT CODE   *
*        *NOTE* BITS 3-7 ARE SET FROM AJOASMF, BITS 0-2 INIT  = 0.    *
*              AVTAGS1 BITS ALSO USED BY OBJECT CODE LOADER AOBJIN.
*   BIT0=0 => NO TXT CARDS FOUND YET. =1(AVO1TXT) => >= 1 CARD FOUND. *
*   BIT1=0 => NO ENTRY @ FND ON END CARD YET. =1(AVOENTR) => FOUND.   *
         SPACE 1
AVTAGS2  DS    B                   2ND BYTE OF FLAG BITS
*   BIT0=0 => NO EOF FOUND, =1($INEND2)=> EOF, CREATE END CARD
*   BIT1=0 => CONTINUE ASSEMBLY. =1(AJOASTOP) ==> STOP ASSEMBLY.
*   BIT0=0 => NODECK. =1(AJODECK) => OBJECT DECK(USES <AODECK>).      *
*   BIT6=0 => NO COMMENT CHECK. =1 REQUIRES $COMNT % OF MACH INSTS     0
*   BIT7=0=> NORMAL LISTING. =1 => CMPRS LISTING (2 STMTS/LINE)
*   OTHER BITS FOR FUTURE USE, SET FROM AJOASMF2 IN AJOBCON.          *
AVXRFLAG DS    C                   FLAG BYTE FOR CROSS REFERENCE      A
          SPACE 2
* THE FOLLOWING FLAGS USED IN TESTING THE ABOVE FLAG                  A
         SPACE
AVXRON   EQU   B'00100000'         XREF FACILITY ON                   A
AVXRCOMP EQU   B'00110000'         COMPRESSED LISTING                 A
AVXRSDMD EQU   B'00001000'         SD OPERAND MOD REFERENCE           A
AVXRSDFT EQU   B'00000100'         SD OPERAND FETCH REFERENCE         A
AVXRSRMD EQU   B'00000010'         SR OPERAND MOD                     A
AVXRSRFT EQU   B'00000001'         SR OPERAND FETCH                   A
AVAJL    EQU   *-AVNERR            LENGTH OF BLOCK FROM AJOBCON
*              VRADL,VRADH,VRELOC,VFENTER,VLOCLOW,VLOCHIH MUST BE IN  *
*        THE ORDER WHICH IS GIVEN.  THEY ARE USED IN LM-STM GROUPS    *
AVRADL   DS    A                   LOWEST REAL ADDRESS OF USER PROGRAM
AVRADH   DS    A                   HIGHEST REAL ADDRESS OF USER PROGRAM
AVRELOC  DS    F                   RELOCATION FACTOR FOR OBJECT CODE
AVZAREA1 DS    0F                  VARIABLE AREA TO BE ZEROED-BEGINNING
AVFENTER DS    A                   PROGRAM ENTRY POINT ADDRESS
*              AVLOCLOW,AVLOCHIH,AVLOCNTR,AVCSLOW,AVCSHIH-REQUIRED ORDR
AVLOCLOW DS    F                   LOWEST LOCATION COUNTER(START OR 0)
AVLOCHIH DS    F                   HIGHEST VALUE OF AVLOCCNTR
AVLOCNTR DS    F                   LOCATION COUNTER
AVCSLOW  DS    F                   CURRENT CSECT LOW LOCCNTR VALUE
AVCSHIH  DS    F                   CURRENT CSECT HIGH VALUE
         SPACE 1
AVSTMTNO DS    H                   TOTAL # OF STATEMENTS
AVSTMTER DS    H                   TOTAL # STMTS FLAGGED
AVNERRA  DS    H                   # FATAL ERROR MESSAGES
AVNWARN  DS    H                   # WARNING MESSAGES
AVOUCOUN DS    H                   WITHIN PAGE LINE COUNT (OUTPUT)
AVOULNCN DS    PL3                 STATEMENT NUMBER CURRENT
AVOUPGCN DS    PL2                 NUMBER OF PAGES (OUTPUT)
AVXRLAVS DS    F                   LIST OF AVAIL SPACE FOR XREF       A
AVXRHEAD DS    F                   HEADER POINTER FOR XREF TREE       A
AVXRCNT  DS    H                   COUNTER FOR NUMBER OF REFERENCES   A
AVXRLNCN DS    PL3                 ADDITIONAL LINE COUNTER FOR XREF   A
AVXRMDFT DS    C                   ADDITIONAL FLAG FOR XREF           A
* FLAG TO BE TESTED WITH THE FOLLOWING                                A
AVXRMOD1 EQU   B'10000000'         MODIFY FIRST OPERAND               A
AVXRMOD2 EQU   B'01000000'         MODIFY SECOND OPERAND              A
AVXRMOD3 EQU   B'00100000'         MODIFY THIRD OPERAND               A
AVXRMOD4 EQU   B'00010000'         MODIFY FIRST THRU SECOND OPERAND   A
AVXRFET1 EQU   B'00001000'         FETCH FIEST OPERAND                A
AVXRFET2 EQU   B'00000100'         FETCH SECOND OPERAND               A
AVXRFET3 EQU   B'00000010'         FETCH THIRD OPERAND                A
AVXRFET4 EQU   B'00000001'         FETCH FIRST THRU SECOND OPERAND    A
AVXRTYPE DS    C                   USED TO TEST M/F REFERENCE         A
AVXRFTCH EQU   X'08'               USED TO TEST ABOVE FLAG            A
* IF NOT TYPE , MUST BE MODIFY REFERNCE                               A
         SPACE
AVCESDID DS    C                   CURRENT CSECT ESDID
*              EVEN VALUE=> CSECT, ODD VALUE=> DSECT ($ESDSECT FLAG).
AVPRINT  DS    C                   LISTING CONTROL FLAG BYTE
AVPRINT1 DS    C                   LISTING CONTROL: 1ST PASS ONLY
AVPRSAVE EQU   B'00000001'         (AVPRINT1,AVPRINT)==> SAVE IN 1ST PS
AVDEBUG  DS    C                   DEBUGGING FLAG TESTED BY XSNAPS
AVTAGS3  DS    B                   VARIOUS FLAGS
*  BIT0=0 => NO STORAGE OVERFLOW. =1(AVOVERFL) => STORAGE EXCEEDED.
AVOVERFL EQU   B'10000000'         (AVTAGS3) => STORAGE OVERFLW OCCRD
AVMTAG00 DS    B                   MISC FLAG BYTE, MACRO COMMUNICATION
AVMOPENC EQU   B'00000001'         (AVMTAG00)==> GBLX,LCLX IN OPEN COD
AVMNOMAC EQU   B'00000010'         (AVMTAG00) => NO MORE MACROS       S
*                                  BECAUSE GBLX, LCLX, ETC. FOUND     S
AVMOPDIC EQU   B'00000100'         (AVMTAG00) => OPEN CODE LOCAL      S
*                                  DICTIONARY HAS BEEN ALLOCATED      S
AVMOPGO  EQU   B'00001000'         (AVMTAG00) => SUCCESSFUL AIF/AGO   S
AVMOPMIN EQU   B'00010000'         (AVMTAG00) - OPEN CODE MACLIB ENTRY X
                                   IS PROPERLY ZEROED  @ OF LOCAL    SX0
                                   DUMMY HAS BEEN ENTERED             S
AVMISC00 DS    B                   MISC FLAG BYTE, FUTURE USE
AVMISC01 DS    B                   MISC FLAG BYTE, FUTURE USE
AVMISC02 DS    B                   MISC FLAG BYTE, FUTURE USE
AVZAREA2 DS    0D                  VARIABLE AREA TO BE ZEROED - END
         EJECT
AVECONTR DS    0D                  ECONTROL DSECT WILL BE LOCATED HERE
AVCONCAT DS    CL256               SPACE FOR CONSTANT BUILDING(CNDTL2)
AVCONBLD DS    CL256               CONSTANT/CODE BUILDING AREA
AVRSBLOC DS    CL(RSB$L+RSOL1+80+RSOLC*($RSMXCRD-2)) RSBLOCK AREA
AVRSCBLK DS    (RSCONSQ-RSCBLK+$RSMXCRD*RSC$LEN)C AREA FOR RSCBLK
AVREBLK  DS    0C                  BEGINNING OF RECORD ERROR BLOCK
AVREBLN  DS    C                   RECORD ERROR BLOCK LENGTH-1
AVREBES  DS    ($ERREBMX)CL2       ERROR CODE AREAS
AVREBSCN EQU   AVREBES             BYTE FOR SCAN OFFSET
AVREBERR EQU   AVREBES+1           BYTE FOR ERROR CODE
         ORG   ,                   MAKE SURE BACK FAR ENOUGH
         SPACE 1
AVDWORK1 DS    D                   1ST DOUBLE WORD WORK AREA
AVDWORK2 DS    D                   2ND DOUBLE WORD WORK AREA
AVRCBPT  DS    A                   ADDRESS OF RECORD CODE BLOCK
AVREBPT  DS    A                   ADDRESS OF RECORD ERROR BLOCK
AVRSBPT  DS    A                   ADDRESS OF RECORD SOURCE BLOCK
AVRSCPT  DS    A                   RECORD SOURCE CODE BLOCK POINTER
AVLABPT  DS    F                   ADDRESS OF LABEL ENTRY,=0 IF NO LAB
AVFWORK1 DS    F                   1ST FULLWORD WORKAREA
AVMPSPIE DS    A                   @ SPIE BLOCK WHEN ENTERED ASSEMBLER
AVSOLAST DS    A                   @ BLANK BEFORE ' AFTER SOURCE STMT
         AIF   ($COMNT EQ 0).AVNOCOM       SKIP IF NO COMMENT CHECKING 0
*              FOLLOWING 2 VARIABLES MUST BE IN GIVEN ORDER.
AVMACHIN DS    H                   # MACHINE INSTS, SET BY IAMOP1
AVCOMNTN DS    H                   # MACHINE INSTS WITH COMMENTS
.AVNOCOM ANOP
         AIF   ($DISKU EQ 0).AVDKTA        SKIP IF NO DISK AT ALL      0
*
*        BUFFER CONTROL BLOCK FOR DISK UTILITY I/O SYNCHRONIZATION
*
AVBCB    DS    0F                  BUFFER CONTROL BLOCK
AVDECB   DS    A(0)                ADDRESS OF CURRENT DECB
AVBUFF@  DS    A(0)                ADDRESS OF CURRENT BUFFER
AVBUFINC DS    A(0)                POINTER TO 1ST UNUSED BYTE IN BUFFER
AVBUFEND DS    A(0)                POINTER TO END OF BUFFER
         AIF   ($BUFNO EQ 1).AVDKTA        SKIP IF ONLY 1 BUFFER       0
AVDECBNX DS    A(0)                ADDRESS OF NEXT DECB
AVDECBLT DS    A(0)                POINTER TO LAST DECB
.AVDKTA  ANOP
         AIF   (NOT $MACROS).AVNOMAC       SKIP IF NO MACROS           0
         SPACE 2
*              VARIABLES USED IN MACRO PROCESSING.                    *
AVSYSECT DS    D                   CURRENT CSECT/DSECT NAME
AVGEN1CD DS    A                   @ 1ST BYTE BEYOND 1ST GEN'D CARD-
*              SET BY MEXPND.  THEN USED AS PTR BY INCARD.
AVGEN2CD DS    A                   USED AS PTR BY INCARD. HAS @ LAST
*              CARD GENERATED BY MEXPND (ORIG SETTING OF AVADDHIH).
AVMACSPC EQU   *                   LABEL FOR SPACE FOR MACRO AVM'S
*
.AVNOMAC ANOP
         AIF   (NOT $MACROS).AVNLIB         SKIP IF NO MACROS          0
AVMFLD1  DS    F                   POINTER TO CURRENT LABEL FIELD
AVMFLDL1 DS    C                   LENGTH OF LABEL
AVMFLDT1 DS    C                   TYPE OF LABEL - SEQ, VAR OR OTHER
AVMFLD1H DS    H                   NOT CURRENTLY USED
AVMFLD2  DS    F                   POINTER TO OPCODE FIELD
AVMFLDL2 DS    C                   LENGTH OF OPCODE FIELD
AVMFLDT2 DS    C                   TYPE OF OPCODE - ASM, MACR OR MAC IN
AVMFLD2H DS    H                   NOT CURRENTLY USED
AVMFLD3  DS    F                   POINTER TO OPERAND FIELD
AVMFLDL3 DS    C                   LENGTH OF OPERAND FIELD
AVMFLDT3 DS    C                   TYPE OF OPERAND FIELD
AVMFLD3H DS    H                   NOT CURRENTLY USED
AVMFLD4  DS    F                   POINTER TO COMMENT FIELD
AVMFLDL4 DS    C                   LENGTH OF COMMENT FIELD
AVMFLDT4 DS    C                   TYPE OF COMMENT FIELD - NOT USED
AVMFLD4H DS    H                   NOT CURRENTLY USED
AVMFLD5  DS    F                   2ND CARD NON STND OPRND
AVMFLDL5 DS    C                   2ND CARD NON STND OPRND LENGTH
AVMFLDT5 DS    C                   2ND CARD NON STND OPRND TYPE
AVMFLD5H DS    H                   NOT CURRENTLY USED
AVMFLD6  DS    F                   2ND NON STND CARD COMMENT
AVMFLDL6 DS    C                   2ND NON STND CARD COMMENT LENGTH
AVMFLDT6 DS    C                   2ND NON STND CARD COMMENT TYPE
AVMFLD6H DS    H                   NOT CURRENTLY USED
AVMFLD7  DS    F                   3RD NON STND CARD OPRND
AVMFLDL7 DS    C                   3RD NON STND CARD OPRND LENGTH
AVMFLDT7 DS    C                   3RD NON STND CARD OPRND TYPE
AVMFLD7H DS    H                   NOT CURRENTLY USED
AVMFLD8  DS    F                   3RD NON STND CARD COMMENT
AVMFLDL8 DS    C                   3RD NON STND CARD COMMENT 6ENGTH
AVMFLDT8 DS    C                   3RD NON STND CARD COMMENT TYPE
AVMFLD8H DS    H                   NOT CURRENTLY USED
$LAVMFLD EQU   *-AVMFLD1           LENGTH OF FIELD INFO POINTERS
         SPACE 1
AVMBYTE1 DS    C                   1ST MACRO FLAG BYTE
AVMBYTE2 DS    C                   2ND MACRO FLAG BYTE
AVMBYTE3 DS    C                   3RD MACRO FLAG BYTE
AVMBYTE4 DS    C                   FLAG BYTE
AVMBYTE5 DS    C                   FLAG BYTE
         SPACE 1
AVMSYMLN DS    C                   LENGTH OF CURRENT SYMBOL
AVMSYMBL DS    CL8                 GLOBAL AREA FOR CURRENT SYMBOL
AVMSYSDX DS    PL2                 CURRENT SYSNDX COUNT                0
         SPACE 1
AVMSEQPT DS    F                   POINTER TO SEQ SYMBOL TABLE
AVMCRINS DS    F                   CURRENT GENERATED INSTRUCTION @
AVMMACID DS    F                   CONTAINS ID NUMBER OF CURRENT MACRO
AVMACNST DS    F                   CURRENT MACRO NESTING COUNT
AVMLDICT DS    F                   POINTER TO OPEN LOCAL DICTIONARY
AVMGDICT DS    F                   POINTER TO GLOBAL DICTIONARY
AVMACLIB DS    F                   POINTER TO MACRO LIBRARY
AVMOVRFL DS    A                   @ OVERFLOW EXIT ROUTINE
AVMTSCNP DS    F                   TEMP STORAGE FOR SCAN POINTER
         SPACE 1
AVMBSPIE DS    F                   TEMP STORAGE FOR MCBODY $SPIE INT @
         ORG   AVMBSPIE            PUT AVMXSPIE IN SAME PLACE**********
AVMXSPIE DS    F                   TEMP STORAGE FOR MXPEND SPIE INT @
         SPACE 1
AVMCHSTR DS    F                   @ OF CHARACTER WORK AREA
AVMCHLIM DS    F                   LAST AVAILABLE BYTE OF CHAR WORK
AVMWRKL1 DS    F                   @ OF LAST BYTE OF AVMWRK1
AVMWRKL2 DS    F                   @ OF LAST BYTE OF AVMWRK2
         SPACE 1
AVMWRK1  DS    CL256               MACRO WORK AREA 1
AVMWRK2  EQU   AVCONCAT            USE CONCAT FOR WORK AREA 2
         SPACE 1
AVMDWRK1 DS    D                   1ST DOUBLE WORD WORK AREA
AVMDWRK2 DS    D                   2ND DOUBLE WORD WORK AREA
AVMDWRK3 DS    D                   3RD DOUBLE WORD WORK AREA
AVMDWRK4 DS    D                   4TH DOUBLE WORD WORK AREA
         SPACE 1
AVMFWRK1 DS    F                   1ST FULL WORD WORK AREA
AVMFWRK2 DS    F                   2ND FULL WORD WORK AREA
AVMFWRK3 DS    F                   3RD FULL WORD WORK AREA
AVMFWRK4 DS    F                   4TH FULL WORD WORK AREA
         SPACE 1
AVMHWRK1 DS    H                   1ST HALFWORD WORK AREA
AVMHWRK2 DS    H                   2ND HALFWORD WORK AREA
AVMHWRK3 DS    H                   3RD HALFWORD WORK AREA
AVMHWRK4 DS    H                   4TH HALFWORD WORK AREA
         SPACE 1
AVMSNBY1 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS
AVMSNBY2 DS    C                   CONTAINS FLAGS TO CONTROL SNAPS
         AIF   (NOT $MACSLB).AVNLIB         SKIP IF NO LIBRARY FETCH   0
AVLIBBUF DS    F                   POINTER TO LIBRARY BUFFER SPACE
.AVNLIB  ANOP
AVWXEND  DS    0D                  ENDING @ AVWXTABL
         TITLE 'ERCOMPCD DSECT - COMPLETION CODE MESSAGE BLOCK'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ERCOMPCD   COMPLETION CODE/ERROR MESSAGE BLOCK            *
*        THIS GIVES FORMAT OF 1 COMPLETION CODE/MESSAGE BLOCK FOR     *
*        USE IN A USER COMPLETION DUMP BY SUBROUTINE XXXXSNAP.  THE   *
*        ADDRESS OF THE APPROPRIATE BLOCK IS PLACED INTO WORD ECERRAD *
*        IN DSECT ECONTROL, AND IS USED THEN BY XXXXSNAP TO PRINT THE *
*        INFORMATION IN THE ERCOMPCD BLOCK.                           *
*        LOCATION: INSIDE EXECUT, WILL BE ELSEWHERE(FUTURE).          *
*        GENERATION: 1 BLOCK CREATED BY 1 CALL TO $ERCGN MACRO.       *
*        NAMES: ERC-----                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ERCOMPCD DSECT
ERCSYST  EQU   0                   (ERCTYPE)==> SYSTEM COMPLETION CODE
ERCASSI  EQU   1                   (ERCTYPE)==> ASSIST SPECIAL MESSAGE
ERCUSER  EQU   2                   (ERCTYPE)==> USER ABEND COMPLETION
ERCLENG  DS    C                   LENGTH-1 OF ERCMSSG
ERCTYPE  DS    C                   CODE OF COMPLETION TYPE
ERCMSSG  DS    0C                  COMPLETION MESSAGE(VARIABLE LENGTH)
         TITLE 'AJOBCON - MAIN JOB CONTROL TABLE DSECT'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: AJOBCON    MAIN JOB CONTROL TABLE                         *
*        THIS DSECT PROVIDES THE PRIMARY COMMUNICATION TABLE USED     *
*        BY THE MAIN PROGRAM ASSIST, THE I/O ROUTINES(XXXXIOCO), THE  *
*        PARM FIELD ANALYZER (APARMS), THE MAIN PROGRAM OF THE        *
*        ASSEMBLER (MPCON0), AND THE REPLACE MONITOR (REMONI).  IT    *
*        PROVIDES FOR GLOBAL FLAG VALUES DEALING WITH THE OVERALL     *
*        JOB IN PROGRESS, PARM FIELD VALUES, USEFUL CONSTANTS, BLANKS,*
*        ZEROES, WORKAREAS, AND DYNAMIC STORAGE AREA LIMITS.          *
*        LOCATION: IN TABLE ASJOBCON OF CSECT ASSIST.                 *
*        NAMES: AJ------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
AJOBCON  DSECT
*              FOLLOWING EQU'S USED FOR COMMUNICATION BETWEEN ASSIST  J
*              AND XXXXSORC DURING CONTROL CARD CHECKING. VALUES ARE  J
*              PLACED INTO AJOBTRQ AND ATOBTYP.                       J
AJO$D    EQU   0                   (AJOBTRQ)- DATA READ (NORMAL CASE) J
AJO$J    EQU   1                   (AJOBTRQ)- LOOKING FOR $JOB CARD   J
AJO$E    EQU   2                   (AJOBTRQ)- LOOKING FOR $ENTRY      J
AJOAPRSE EQU   B'00000001'         (AJOAPMOD)- ZERO ALL APCFLAG SET
*                                  BITS BEFORE SCANNING PARM OPTIONS
AJOAPDEF EQU   B'00000010'         (AJOAPMOD)- DEFAULT CALL TO APARMS-
*                                  OVERRIDE NO VALUE ALREADY SET ANY WY
AJOAPFIN EQU   B'00000100'         (AJOAPMOD)- FINAL CALL TO APARMS-
*                                  SET ANY FINAL FLAGS NEEDED.
AJOAPMOV EQU   B'00001000'         (AJOAPMOD)- MOVE PARM FIELD INTO
*              AJOPARM, WITH BLANK PADDING.  IF NOT SET, APARMS WILL
*              LEAVE PARM WHERE IT IS, AND ASSUME THAT ITS LENGTH
*              INCLUDES AT LEAST ONE BLANK FOLLOWING ACTUAL PARM.
         SPACE 1
*        ----- NEXT 2 BITS POSSIBLY SET ONLY WHEN $TIMER=2,$RECORD=2  03
AJOAPUSR EQU   B'01000000'         (AJOAPMOD)- SET IF USER SUPPLIED R=
AJOAPUST EQU   B'10000000'         (AJOAPMOD)- SET IF USER SUPPLIED T=
AJOBATCH EQU   B'00000001'         (AJOMODE)==> BATCH MODE,DON'T CLOSE
         SPACE 1
AJOREPLF EQU   B'00000010'         (AJOMODE)==> REPLACE MODE RUN
AJOMONIT EQU   B'00000100'         (AJOMODE)==> RUNNING UNDER WATFR MON
AJNSYSIN EQU   B'00001000'         (AJOMODE)==> NO SYSIN, ABORT RUN
AJOSRECX EQU   B'00100000'         (AJOMODE)==> RECORD OVERRUN OCCURRED
AJOSOVRT EQU   B'00010000'         (AJOMODE)==> TIME OVERRUN OCCURRED
AJOREPHB EQU   B'01000000'         (AJOMODE)==>REPLACEMENT PHASE B
         SPACE 1
AJOMSINT EQU   B'00000001'         (AJOSTEP)- MAIN STORAGE INIT DONE
AJOSDUMP EQU   B'00100000'         (AJOSTEP)- PROGRAM IN DUMPING PHS
AJOSEXEC EQU   B'01000000'         (AJOSTEP)==> PROGR IN EXECUTION
AJOSASM  EQU   B'10000000'         (AJOSTEP)==> PROG IN ASSEMBLY PHASE
         SPACE 1
AJNLOAD  EQU   B'00000001'         (AJOASMF)==> CHECK ONLY, NO OBJCT CD
AJNLIST  EQU   B'00000010'         (AJOASMF)==> NO LISTING DESIRED
AJOLARGE EQU   B'00000100'         (AJOASMF)==> PROGRAM IS LARGE,OPTIM
AJODISKU EQU   B'00001000'         (AJOASMF,AVTAGS1) => DISK OPTION
AJORELOC EQU   B'00010000'         (AJOASMF)==> RELOC CODE TO REAL @'S
         SPACE 1
AJOCMPRS EQU   B'00000001'         (AJOASMF2,AVTAGS2)-COMPRESSD LISTING
AJOCOMNT EQU   B'00000010'         (AJOASMF2-AVTAGS2)- COMMENT CHECK
AJODECK  EQU   B'00000100'         (AJOASMF2-AVTAGS2)- PUNCH OBJ DECK
AJOASTOP EQU   B'01000000'         (AJOASMF2-AVATGS2)- STOP ASSEMBLY
         SPACE 1
AJOMACRO EQU   B'00000001'         (AJOASMFM,AVMTAGSM)=> MACROS(F) OK
AJOMACRG EQU   B'00000010'         (AJOASMFM,AVMTAGSM)=> ASM G MACROS
AJOMACRH EQU   B'00000100'         (AJOASMFM,AVMTAGSM)=> ASM H MACROS
AJOMACRV EQU   B'00001000'         (AJOASMFM,AVTAGSM)=> OS/VS ASM
         SPACE 1
AJOLIBMC EQU   B'10000000'         (AJOASMFM,AVMTAGSM)=>PRT LIB MACROS
AJOSUPER EQU   B'00000010'         (AJOEXEF)==> INIT USER IN SUPERVISOR
AJONALGN EQU   B'00000100'         (AJOEXEF-ECFLAG4)==>NO ALIGNMENT 0C6
         SPACE 1
AJIOPEN  EQU   B'00000001'         (AJIO-SO-RE-PR-PN)==> DCB OPEN
AJIOEOF  EQU   B'00000010'         (AJIO-SO-RE)==> END-FILE ENCOUNTERED
AJIODEOF EQU   B'00000100'         DISK END-OF-FILE FLAG
AJIOSYND EQU   B'00010000'         DISK SYNAD ERROR FLAG
AJIOSOHS EQU   B'00010000'         (AJIOSO)- OUTPUT BUFFER FLUSH      J
AJIOPSEO EQU   B'00000100'         (AJIO-SO-RE)=> PSEUDO ENDFILE(JCL)
AJIOPAGE EQU   B'01000000'         (AJIOPR)- PAGE CONTROL MODE ON
AJIOSORR EQU   B'01000000'         (AJIOSO)- REREAD LAST CARD READ    J
AJIODKNO EQU   B'10000000'         DISK DCB COULD NOT BE OPENED
AJIOKP26 EQU   B'10000000'         (AJIOSO) - KP=26 -TRANSLATE TO 029
AJIOSING EQU   B'10000000'         (AJIOPR)-SINGLE SPACE CARRIAGE CONT
*                                  EXCEPT  NEW PAGE==> DOUBLESPACE
AJIODFLT EQU   B'10000000'         (AJIO-RE,PN)==> USING SO OR PR DEFLT
         SPACE 1
AJOOBJIN EQU   B'00000001'         (AJODECKF) - OBJECT INPUT DECK
         SPACE 1
AJOZEROS DC    16F'0'              FOR USE IN ZEROING THINGS
AJ1000   DS    F'1000'             FOR CONVERSIONS
AJ2604   DC    F'2604'             FOR USE IN TIME CONVERSIONS
AJ100000 DC    F'100000'           FOR USE IN TIME CONVERSIONS
AJ100M   DC    F'100000000'        FOR USE IN SECS==>TIMER UNITS
AJOVWXPT DS    V(VWXTABL)          @ MAIN ASSEMBLER TABLE
AJOEXECU DS    V(EXECUT)           ADCON FOR INTERPRETER CODE
         DS    0D
         AIF   (NOT $KP26).AJNKP26         SKIP IF NO KP=26 OPT ALLWS  0
AJTRTB26 DS    XL256               026-->029 KEYPUNCH TRANSLATE TABLE
.AJNKP26 ANOP
AJOBLANK DC    CL136' '            FOR GENERAL SUPERVISOR BLANKING
AJOPARMA DS    C                   FOR CARRIAGE CONTROL
AJOP$L   EQU   100                 MAXIMUM LENGTH OF PARM FIELD
AJOPNDFT DS    0CL88               CARD IMAGE HERE IF NOPUNCH USED.
AJOPARM  DS    CL(AJOP$L+2)        SPACE FOR PARM,2 TRAILING BLANKS
AJOCP$L  EQU   5                   MAX # CHARACTERS IN EACH PARM
         DS    0D                  MAKE AJOCOMP PART OF AJODWORK
AJOCOMP  DS    0CL(AJOCP$L)        SPACE FOR COMPARE DURING PARM SCAN
         SPACE 1
AJODWORK DS    D                   GENERAL DOUBLEWORD WORKAREA
AJOPADL  DS    A                   PERMANENT LOW @ WORKAREA
AJOPADH  DS    A                   PERMANENT HIGH @ WORKAREA
AJOTADL  DS    A                   TEMPORARY LOW @ WORKAREA
AJOTADH  DS    A                   TEMPORARY HIGH @ WORKAREA
AJOECOPT DS    A                   @ ECONTROL, EXECUTION CONTROL BLK
         SPACE 1
AJO$APC  EQU   *                   BASE @ FOR OFFSETS TO PARM VARIABLES
AJOZER1  EQU   *                   PLACE TO BEGIN ZEROING ON INIT
         AIF   ($REPL EQ 0).AJNREPL        SKIP GEN IF NO REPL         0
AJORFLAF DS    0F,H                DUMMY RFLAG INTO FULLWORD-MAKES
*                                  CODE IN APARMS CSECT EASIER
AJORFLAG DS    H                   REPLACE FLAG FROM RFLAG=
.AJNREPL ANOP
         AIF   (NOT W$PAGE).AJNPAGE         SKIP IF NO PAGE CONTROL
AJOL     DS    F                   LINES/PAGE FROM PARM FIELDS
AJOP     DS    F                   TOTAL PAGES FROM PARM FIELDS
AJOPX    DS    F                   PAGES FOR EXECUTION TIME,PARM FIELD
AJOPD    DS    F                   PAGES FOR DUMP IF RECORDS EXCEEDED
*              AJOLREM-AJOPREM MUST BE IN ORDER GIVEN TOGETHER
AJOLREM  DS    F                   LINES REMAINING IN PAGE AT ANY TIME
AJOPREM  DS    F                   PAGES REMAINING AT ANY TIME
*              FOLLOWING VARIABLES MAY BE SET WITH AJIOSING FLAG TO
*              SHOW SINGLE SPACE CRUNCHING DURING NOTED PROG PHASE.
*              SINGLE SPACE ACTION TAKEN ONLY IF PAGE CONTROL OPT USED
AJIOSS   DS    B                   SET==> SINGLE SPACE DURING ASSEMBLY
AJIOSSD  DS    B                   SET==> SINGLE SPACE DURING DUMP
AJIOSSX  DS    B                   SET==> SINGLE SPACE DURING EXECUT
.AJNPAGE ANOP
AJORD    DS    F                   # RECORDS MINIMUM ALLLOWED FOR DUMP
AJORX    DS    F                   RECORDS FOR EXECUTION TIME
AJOTD    DS    F                   MINIMUM TIME SAVED FOR DUMP
AJOTX    DS    F                   TIME(SECS) FOR EECUTION TIME
AJOTIML  DS    F                   TIME LIMIT FOR JOB, FROM T=
AJORECNT DS    F                   # RECORDS REMAINING(DECREMENTED)
AJORECL  DS    F                   RECORD LIMIT, FROM R=
AJOINSL  DS    F                   # EXECUTED INST LJMIT, FROM I=
AJONERRF DS    0F,H                DUMMY AJONERR INTO FULLWORD.
*                                  SIMPLIFIES CODE IN APARMS
*        **NOTE** SECTION FROM AJONERR - AJOAVL MUST CORRESPOND       *
*        EXACTLY TO SECTION AVNERR - AVAJL, INC ALIGNMENT.            *
*        THIS SECTION MOVED TO CORRESPONDING SECTION IN AVWXTABL.     *
AJONERR  DS    H                   MAXIMUM # ERRORS TO STILL OK EXECUT
         SPACE 1
         AIF   (NOT $MACROS).AJNMACX       SKIP IF NO MACROS           0
*              MACRO  OPTIONS AND FLAG BYTES.
AJOMAC01 DS    0F                  START OF MACRO PARAMETER OPTIONS
AJOMACTR DS    F                   INITIAL ACTR VALUE FOR MACROS/MAIN
AJOMNEST DS    F                   MAXIMUM NEST LEVEL FOR MACROS
AJOMSTMG DS    F                   GLOBAL LIMIT: MACRO STMTS PROCESSED
AJOASMFM DS    B                   MACRO FLAGS (SETS AVTAGSM)
.AJNMACX ANOP
AJOASMF0 DS    B                   ASSEMBLER FLAG **FUTURE USE*********
AJOASMF  DS    C                   FLAG BYTE FOR ASSEMBLER SECTION
AJOASMF2 DS    B                   2ND BYTE OF FLAG BITS(FUTR USE)
         AIF   (NOT $XREF).NOXREF3                                   A 0
*  CROSS REFERENCE FLAG BYTE                                          A
AJOXREF  DS    C                   FLAG FOR XREF FACILITY             A
.NOXREF3 ANOP                                                         A
AJOAVL   EQU   *-AJONERR           LENGTH OF SECTION MOVED TO AVWXTABL
         SPACE 2
AJOMODE  DS    B                   MODE FLAG, MISC FLAGS.
AJOSTEP  DS    B                   FLAG SHOWING CURRENT STEP
*              EXECUTION CONTROL FLAGS, MUST BE IN GIVEN ORDER. SECTION
*        AJOEC - AJOECL MUST CORRESPOND WITH ECAJ - ECAJL.            *
AJOEC    DS    0F                  BEGIN AREA  --  ALIGNMENT
AJOIECF  DS    F                   IECF=  (ONLY NEEDED FOR $EXINT=1)   0
AJODMPF  DS    B                   DUMP FLAGS (SETS ECFLAG3)
AJOEXEF  DS    B                   GENRAL EXECUTION MODE FLAGS(ECFLAG4)
AJOEXEFA DS    B                   EXECUTION FLAGS (ECFLAG5) **FUTURE**
AJOECL   EQU   *-AJOEC             LENGTH OF FLAG BYTES
         SPACE 1
AJOAPMOD DS    B                   FLAG BYTE FOR RUNNING MODE OF APARMS
AJOAPSET DS    B                   SET BYTE - OR'D BY APARMS WHEN IT
*              SETS APCFLAG TO SHOW VALUE SET. SEE APCSET,SETLD,SETU
         SPACE 1
AJIOFLAG DS    0BL4                AREA OF FLAGS FOR DCB'S
AJIORE   DS    B                   FLAG BYTE FOR DATA READER(XXXXREAD)
AJIOSO   DS    B                   FLAG BYTE FOR SOURCE RDR (XXXXSORC)
AJIOPR   DS    B                   FLAG BYTE FOR PRINTER(XXXXPRNT)
AJIOPN   DS    B                   FLAG BYTE FOR PUNCH (XXXXPNCH)
AJIODSK  DS    B                   FLAG BYTE FOR RUNNING MODE DISKU
AJIOWRKB DS    B                   WORK BYTE FOR USE OF XXXXIOCO
         SPACE 1
AJODEBUG DS    B                   DEBUG FLAG BYTE
AJODECKF DS    B                   OBJECT DECK CONTROL FLAG
AJOBTRQ  DS    C                   ASSIST SETS FOR XXXXSORC USE       J
AJOBTYP  DS    C                   XXXXSORC SETS FOR ASSIST           J
AJOTIMR  DS    F                   TEMPORARY TIME WORK AREA
AJOFREE  DS    F                   MEMORY TO BE FREED TO OPERATING SYST
AJOZER$L EQU   *-AJOZER1           LENGTH OF AREA TO BE ZEROED
         DS    0D
AJOJCLCD DS    CL80                ASSIST JCL STORED HERE BY READ ROUTN
AJOJCLPM EQU   AJOJCLCD+15         LOCATION OF $JOB PARM FIELD
         AIF   (NOT $ACCT).AJONACC         SKIP IF NO ACCT INFO        0
         SPACE 1
*              ACCOUNT # CHECKING DATA - FROM $TIRC (NAME,AJOACCT)
AJOACCT  DS    CL5                 ACCOUNT #
AJOJOBNM DS    CL8                 JOB NAME
AJOPRGNM DS    CL20                PROGRAMMER'S NAME
.AJONACC ANOP
AJOB$L   EQU   *-AJOBCON           GET LENGTH OF AJOBCON
         TITLE '*** ECONTROL DSECT - EXECUTION CONTROL BLOCK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ECONTROL   EXECUTION CONTROL BLOCK                        *
*        THIS BLOCK CONTAINS ALL DATA REQUIRED TO DESCRIBE A USER     *
*        PROGRAM TO BE EXECUTED BY THE ASSIST INTERPRETER (EXECUT).   *
*        IT CONTAINS SIMULATED USER REGISTERS AND PROGRAM STATUS WORD,*
*        AN INSTRUCTION STACK, POINTERS TO THE USER PROGRAM CODE,     *
*        AND VARIOUS FLAGS DESCRIBING THE RUNNING MODE AND OPTIONS    *
*        ALLOWED TO THE USER PROGRAM.  IT IS CREATED FROM INFORMATION *
*        FROM THE ASSEMBLER, THE USER PARM FIELD, AND FROM THE        *
*        OPTIONS IN ASSIST, AND IS MODIFIED BY EXECUT.  IT ALSO       *
*        PROVIDES ALL DATA NEEDED BY XXXXSNAP TO DO A USER DUMP.      *
*        LOCATION: IN HIGH END OF DYNAMIC CORE AREA.                  *
*        NAMES: EC------                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
ECONTROL DSECT
EC$STACK EQU   10                  MAX # OF INSTS KEPT IN STACK
         SPACE 1
$ECCONT  EQU   X'80'               (ECFLAG0)==>CONTINUE,DO NOT INIT
$ECADSOK EQU   X'40'               (ECFLAG0)==>RELOCATIONLIMIT @'S OK  0
$ECEOF   EQU   X'20'               (ECFLAG0)==>EOF ON CARD READER
$ECPROT  EQU   X'10'               (ECFLAG0)==> ABSOLUTE PROTECT MODE
*              I.E. THIS FLAG MEANS FETCH PROTECT IN ADDITION TO STORE*
$ECSPIEA EQU   X'08'               (ECFLAG0)==> EXECUT SPIE IN EFFECT
$ECSPIEB EQU   X'04'               (ECFLAG0)==> REMOVE SPIE BEFORE EXIT
         SPACE 1
$ECBROUT EQU   2                   (ECFLAG1)==> BRANCH OUT OF RANGE
$ECTIMEX EQU   4                   (ECFLAG1)==> TIME COUNT EXCEEDED
$ECREADR EQU   6                   (ECFLAG1)==> ATTEMPT READ PAST EOF
$ECRECEX EQU   8                   (ECFLAG1)==> RECORDS EXCEEDED
$ECABEND EQU   10                  (ECFLAG1)==> USER REQUESTED ABEND
$ECBRN14 EQU   12                  (ECFLAG1)==> NORMAL RETURN (R14)
         SPACE 1
$ECREGS  EQU   B'00000001'         (ECFLAG3)==>PRINT REGS IN DUMP
$ECDINST EQU   B'00000010'         (ECFLAG3)==>PRINT INST TRACE IN DUMP
$ECSTORG EQU   B'00000100'         (ECFLAG3)==> PRINT USER STORAGE
$EC$JRM  EQU   B'10000000'         (ECFLAG3)==> SPECIAL JRM DEBUG
         SPACE 1
$ECPRBST EQU   X'01'               (ECKYAMWP) ==> PROBLEM STATE PROG
         SPACE 1
*              REPLACE MONITOR FLAGS, SET BY RFLAG= AND XREPL INSTR.
ECR$CARD EQU   B'00000001'         (ECRFLAG+1)PRINT CARDIMAGE
ECR$REGA EQU   B'00000010'         (ECRFLAG+1)PRINT REGS BEFORE ENTRY
ECR$REGB EQU   B'00000100'         (ECRFLAG+1)PRINT RESULTS FROM REAL P
ECR$REGC EQU   B'00001000'         (ECRFLAG+1)PRINT RESULTS OF USER PRG
ECR$REGD EQU   B'00010000'         (ECRFLAG+1) PRT IF USER CALLS
ECR$ERRC EQU   B'10000000'         (ECRFLAG+1)=> ERROR FOUND IN REGS
         SPACE 1
*              FLOATING POINT REGISTER SAVE AREA                      *
ECFPREGS DS    4D                  DUMMY FLOATING POINT REGS
ECDWORK  EQU   ECFPREGS            WE CAN USE FP REGS AS WORK AREA
         SPACE 1
*              SIMULATED GENERAL PURPOSE REGISTERS                    *
ECREGS   DS    16F                 FAKE REGISTERS FOR INTERPRETER
ECREG1   EQU   ECREGS+4            FAKE R1
ECREGRA  EQU   ECREGS+4*RA         FAKE RA
ECREG12  EQU   ECREGS+48           FAKE R12(RAT)
ECREG13  EQU   ECREGS+52           FAKE R13
ECREG14  EQU   ECREGS+56           FAKE R14, RETURN @ REG
ECREG15  EQU   ECREGS+60           FAKE R15, ENTRY PT REG
         DS    F                   DUMMY REG, SIMPLIFIES SINGLE SHIFTS
*              NECESSARY TO USE CURRENT CODE FOR SLL 15,1, FOR EXAMPLE
ECR14SAV DS    A                   ORIGINAL RETURN @ FOR COMPARISON
ECZER1   EQU   *                   BEGINNING FOR BLOCK ZEROING
         SPACE 1
*              SIMULATED PROGRAM STATUS WORD                          *
ECPSW    DS    0D                  PSW FOR PROG
ECSYSMSK DS    C                   SYSTEM MASK
ECKYAMWP DS    C                   PROT KEY, AMWP FIELD
ECINTCOD DS    H                   INTERRRUPT CODE
ECILCMSK DS    C                   ILC-CC-PROGRAM MASK
ECPSWIAD DS    CL3                 INSTRUCTION ADDRESS
         SPACE 1
*              CONTROL FLAGS                                          *
ECFLAGS  DS    0F                  A FULLWORD FOR FLAGS
ECFLAG0  DS    C                   MAJOR CONTROL BITS
ECFLAG1  DS    C                   USED TO RETURN SPECIAL ERROR CODES
ECFLAG2  DS    C                   CONTROLS DEBUG MODE SNAPS
ECAJ     DS    0F                  BEGIN AJOBCON FLAGS, ALIGN
ECOIECF  DS    F                   ORIGINAL IECF ($EXINT ONLY)         0
ECFLAG3  DS    B                   DUMP CONTROL FLAG (AJODMPF)
ECFLAG4  DS    B                   MISC. EXEC FLAGS (AJOEXEC)
ECFLAG5  DS    B                   MISC EXEC FLAGS (AJOEXEFA)*FUTURE***
ECAJL    EQU   *-ECAJ              LENGTH OF FLAGS GROUP MUST = AJECL
ECRFLAG  DS    H                   REPLACE MONITOR FLAG
         SPACE 1
ECERRAD  DS    A                   @ SPECIAL ASSIST COMPLETION MESSAGE
ECSVCADS DS    A                   @ ADDRESS LIST OF SVC'S,=0 IF NONE
ECZER$L  EQU   *-ECZER1            LENGTH OF AREA FOR BLOCK ZEROING
ECFADHC  DS    A                   HIGH @ PROG + SAVE = ECFADH-256
*              ECILIMT-ECILIMP MUST BE IN ORDER GIVEN, USED IN LM     *
ECILIMT  DS    F                   INST COUNT LIMIT (DECREMENTED)
ECILIMP  DS    F                   PERMANENT INSTRUCTION COUNT LIMIT
         SPACE 1
*              ECRDLIML-ECRDLIMH GIVE DUMP LIMTS. MUST BE IN GIVEN ORDR
ECRDLIML DS    A                   REAL DUMP LIMIT LOW(INIT=ECRADL)
ECRDLIMH DS    A                   REAL DUMP LIMIT HIH(INIT=ECRADH)
         SPACE 1
*              ADDRESS VALUES DESCRIBING LIMITS OF USER PROGRAM.      *
*              **NOTE** THEY MUST BE IN THE ORDER GIVEN BELOW.        *
ECRADL   DS    F                   REAL LOWEST ADDRESS OF PROGRAM
ECRADH   DS    F                   REAL HIGHEST ADDRESS
ECRELOC  DS    F                   RELOCATION CONTINUALLY APPLIED
ECFENTER DS    A                   USER PROGRAM FAKE ENTRY POINT @
ECFADL   DS    F                   FAKE LOWEST ADDRESS OF PROGRAM
ECFADH   DS    F                   FAKE HIGHEST ADDRESS OF PROGRAM
         SPACE 1
ECINSTAC DS    (EC$STACK)CL16      INSTRUCTION STACK
ECRSTK   DS    F                   SAVE WORD FOR RSTK POINTER
ECSAVE1  DS    A                   @ FAKE SAVE AREA FOR USER PROG
ECPICA   DS    F                   SAVE WORD FOR PREVIOUS PICA
ECTSAVE  DS    16F                 FOR SAVING REGS WHEN DOING CALLS
         AIF   (NOT $EXINT).ECOVER                                     0
         SPACE 2
EC$BRSTC EQU   10                  SIZE OF BRANCH STACK (# OF SLOTS)
ECBRSTAC DS    (EC$BRSTC)CL16      BRANCH STACK
ECBSTK   DS    F                   SAVE WORD FOR BSTK POINTER
ECBCUR   DS    F                   CURRENT STACK PTR SAVED HERE
         AIF   ($EXINT EQ 0).ECNOEXT   SKIP IF NO EXTENDED INTERPRETER 0
         SPACE 5
* * * * * * * * * * * * * * ##### EXTENSION ##### * * * * * * * * * * *
*                                                                     *
*        IMPORTANT-->  THIS SECTION IS AN EXTENSION TO THE            *
*        ECONTROL DSECT AND IS USED BY THE OPTIONAL ASSIST            *
*        INTERPRETER.  IT CONTAINS FLAGS, EQUATES, AND                *
*        ADDRESSES FOR USER INTERRUPT HANDLING AND OTHER              *
*        USER OPTIONS.  SEE PSEUDO-INSTRUCTION XOPC.                  *
*                                                                     *
*        NOTE:  DATA IN THIS AREA IS ACCESSABLE TO THE USER           *
*        PROGRAMMER BY MEANS OF VARIOUS XOPC INSTRUCTION              *
*        CODES, AND IN GENERAL BY XOPC 12  13.                       * 0
*                                                                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
ECPRCB   EQU   *
*              FLAGS USED BY THE OPTIONAL INTERPRETER
*
*              FLAGS FOR OPTIONS-IN-EFFECT CHECKING
*              NOTE: ECPRCBF1 WILL NOT BE USED FOR ANY OTHER
*                    FLAG TYPES.
ECPRTRCE EQU   B'00000001'         (ECPRFLG1)==> TRACE = ON
ECPRMODC EQU   B'00001000'         (ECPRFLG1)==> MODIFICATION CHECKING X
                                                 = ON
ECPRIECF EQU   B'00000010'         (ECPRFLG1)==> COUNT FACILITY ON
ECPRCTON EQU   B'00000100'         (ECPRFLG1)==> HAS COUNT ON BEFORE?
ECPRCTOF EQU   B'00000000'         (ECPRFLG1)==> COUNT FACILITY OFF
ECPRNOSP EQU   B'00001000'         (ECPRFLG1)==> NO SPACE FOR COUNT FAC
*
*              FLAGS FOR MACHINE EMULATION (ECPRCBF2 LOW ORDER NIBBLE)
*              AND OTHER DATA.
*
*              NOTE: THE FLAGS FOR MACHINE EMULATION CAN BE CHANGED
*              DYNAMICALLY BY THE USER PROGRAMMER BY WAY OF THE XOPC
*              INSTRUCTION.  THIS ALLOWS RUN-TIME CONTROL OF EMULATION
*              OPTIONS, SINCE THESE FLAGS ARE CHECKED BEFORE THE
*              INTERPRETATION OF EACH USER INSTRUCTION.  IF THE USER
*              PROGRAM SCREWS UP THESE FLAGS, IT MAY BE
*              TERMINATED 'CONFUSINGLY' WITH AN OC-1 ON A VALID
*              INSTRUCTION.
ECEM360  EQU   B'00000100'         (ECPRFLG2)==>  MACHINE = 360
ECEM370  EQU   B'00001000'         (ECPRFLG2)==>  MACHINE = 370
ECSUPRST EQU   B'01000000'         (ECPRFLG2)==> IN SUPERVISOR STATE
ECALNCHK EQU   B'10000000'         (ECPRFLG2)==> ALIGNMENT CHECKING=ON
ECSPISET EQU   B'10000000'         (ECPRFLG3)==> A PSEUDO SPIE IS SET
ECINHDST EQU   B'01000000'         (ECPRFLG3)==> INTERRUPT HANDLING ST
ECNOSPI  EQU   B'00000000'         (ECPRFLG3)==> NO SPIE INTERRUPT SET
ECLKADR  EQU   B'00000001'         (ECPRFLG4)==> CLOCK EXIT ADDR SET
*              PRCB STORAGE BEGINS HERE
ECPRFLG1 DS    B
ECPRFLG2 DS    B
ECPRFLG3 DS    B
ECPRFLG4 DS    B
ECPRFLG5 DS    B
ECPRFLG6 DS    B
ECPRFLG7 DS    B
ECPRFLG8 DS    B
*              INSTRUCTION TRACE AND MONITOR ADDRESSES
*              ***** NOTE: DO NOT CHANGE THE ORDER OF THESE SOURCE
*                          RECORDS
ECPRTRAL DS    A                   BEGINNING (LOW) @ OF TRACE         M
ECPRTRAH DS    A                   ENDING (HIGH) @ OF TRACE           M
ECPRMODL DS    A                   BEGINNING (LOW) @ OF CHECK FACILITY
ECPRMODH DS    A                   ENDING (HIGH) @ OF CHECK FACILITY
*              INSTRUCTION COUNTER (PSEUDO-CLOCK) INFORMATION
ECPRCLOK DS    F                   CLOCK (DECMTD BY 1 FOR EACH INSTR)
ECPRCMPR DS    F                   COMPARATOR (CHECKED AGAINST CLOCK   X
                                   FOR INTERRUPT TEST)
ECPRCLEA DS    A                   USER SPECIFIED CLOCK EXIT ADDRESS
*              EXIT ADDRESS FOR USER SPECIFIED PSUEDO-SPIE HANDLING
*              (IF NOT SPECIFIED, THIS ADDRESS WILL BE ZERO.)
ECPRSCDE DS    F                   USER SPECIFIED SPIE CODE MASK
ECPRSPIE DS    A                   EXIT ADDRESS FOR PSUEDO-SPIE XOPC 0
*              2 WORD SAVE AREA FOR INTERRUPT (REGS 0 - 1)
ECPRIRGS DS    2F                  DEFINE 2 WORD SAVE AREA
*              STORAGE FOR IECF (BY ADDRESS) INFORMATION
ECPRICA  DS    A                   BEGIN @ OF IECF (BY ADDR) COUNTERS
ECPRICAL DS    F                   LENGTH OF COUNTING AREA
ECPRICL  DS    A                   IECF LOW @ COMPARATOR (BEGINNING)  M
ECPRICH  DS    A                   IECF HIGH @ COMPARATOR (ENDING)    M
*              MISCELLANEOUS EQUATES FOR THE OPTIONAL INTERPRETER
EISSINST EQU   B'11000000'         IDENTIFIES SS INSTRUCTIONS
ECPROPON EQU   ECPRTRCE+ECPRIECF
EC#XOPC  EQU   22                  # OF THE MAX LEGAL XOPC CODE
ECREG0   EQU   ECREGS              FAKE REG 0
ECREG2   EQU   ECREGS+8            FAKE REG 2
         SPACE 1
ECPRWORK DS    8F                  WORK AREA FOR FUTURE GENERAL USE
         SPACE 1
ECPRCB$L EQU   *-ECPRCB            LENGTH OF PRCB
.ECNOEXT  ANOP
.ECOVER  ANOP
         DS    0D
EC$LEN   EQU   *-ECONTROL          LENGTH OF ECONTROL DSECT
         TITLE '*** ECSTACKD DSECT - ECONTROL INSTRUCTION STACK ***'
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*--> DSECT: ECSTACKD   SINGLE ENTRY IN ECONTROL INSTRUCTION STACK     *
*        THE ECONTROL INSTRUCTION STACK IS A CIRCULAR LINKED LIST     *
*        WHICH ALWAYS CONTAINS DATA ON UP TO THE LAST 10 INSTRUCTIONS *
*        INTERPRETED DURING EXECUTION.  IT IS FILLED IN BY EXECUT, AND*
*        IS USED BY XXXXSNAP TO PROVIDE THE INSTRUCTION TRACE PART    *
*        OF A USER COMPLETION DUMP.                                   *
*        LOCATION: INSIDE AREA ECINSTAC IN DSECT ECONTROL.            *
*        NAMES: EC------     (SAME AS ECONTROL NAME CHARACTERS)       *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
ECSTACKD DSECT
ECSTENT  DS    0CL16               INST STACK ENTRY
ECSTLINK DS    F                   ADDRESS OF NEXT STACK ENTRY
ECSTIADD DS    F                   INSTRUCTION ADDRESS
ECSTCCPM DS    H                   CON-CODE  PROGRAM MASK              0
         SPACE 1
ECSTINST DS    0CL6                UP TO 6 BYTES OF INSTRUCTION
ECOP     DS    C                   OPCODE
ECM1R2   DS    0C                  M1,R2 FIELD FOR BC'S
ECR1R2   DS    0C                  R1,R2 FIELD FOR RR INSTRUCTIONS
ECR1X2   DS    0C                  FIELD FOR RX INSTRUCTIONS
ECR1R3   DS    0C                  FIELD FOR RS INSTRUCTIONS
ECR1M3   DS    0C                  FIELD FOR RS INSTRUCTIONS
ECI2     DS    0C                  FIELD FOR SI INSTRUCTIONS
ECL1I3   DS    0C                  FIELD FOR SRP INSTRUCTION
ECOPEX   DS    0C                  2ND BYTE OF EXTENDED OP CODE
ECL1L2   DS    C                   FIELD FOR ALL SS INSTRUCTIONS
ECBD     DS    H                   1ST OR ONLY BASE-DISPLACEMENT FIELD
ECB2D2   DS    H                   2ND BASE-DISP(SS  SPECIALS ONLY)    0
