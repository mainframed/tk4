         AIF   (&$REPL EQ 0).RENREPL        SKIP IF NO REPLACE AT ALL
         TITLE 'RECORBLK DSECT - REPLACE CORRESPONDENCE TABLE'
**--> DSECT: RECORBLK   REPLACE MODULE-DESCRIBES 1 REAL-REPLACE PAIR. .
*.             THIS DSECT DESCRIBES 1 ENTRY IN THE TABLE RECORRAD.    .
*.       WHEN AN ENTRY POINT IS REPLACED, A RECORBLK IS CREATED FOR   .
*.       IT AND FILLED WITH VALUES FROM THE ENTRY POINT'S RFSYMBLK.   .
*.       THE ENTRY ADDRESS OF THE NEW ENTRY IS FOUND FROM THE SYMBOL  .
*.       TABLE (WHICH STILL EXISTS), AND IS SAVED INTO THE RECFPSW    .
*.       FIELD (OR A -1 PLACED HERE TO SHOW THE ENTRY COULD NOT BE    .
*.       FOUND IN THE USER PROGRAM).  USING THE RECAXAD FIELD, WHICH  .
*.       POINTS TO THE ADCON IN AVWXTABL OF THE REAL ROUTINE, THE REAL.
*.       ADCON IS SAVED IN RECADRE, AND IT IS REPLACED BY THE ADDRESS .
*.       OF REFAKE.  A CODE IS PLACED INTO THE HI-ORDER BYTE OF THE   .
*.       WORD IN AVWXTABL, WHICH IS USED BY REFAKE TO IDENTIFY WHICH  .
*.       ENTRY IS CALLED.                                             .
*.             AT THE END OF A REPLACE RUN, THE REAL ADCONS ARE MOVED .
*.       BACK TO THEIR PROPER PLACES IN AVWXTABL, USING THE RECAXAD   .
*.       FIELD OF EACH RECORBLK ELEMENT IN THE RECORRAD TABLE.        .
*.       **NOTE** FIRST SECTION OF DSECT SAME AS DSECT RFSYMBLK.      .
*.       LOCATION: CSECT REMONI, TABLE RECORRAD.                      .
*.       NAMES: REC-----                                              .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
RECORBLK DSECT
*              DATA TRANSFERRED FROM RFSYMS CSECT TABLES.
RECSYMB  DS    CL6                 ENTRY POINT NAME
RECAXAD  DS    H                   OFFSET IN AVWXTABL=AX#-AX$BASE
RECRGAD  DS    H                   OFFSET FOR CHECK CODE=RG#-RGENTS
         SPACE 1
RECADRE  DS    V                   SPACE TO SAVE REAL ADDRESS CONSTNAT
RECFPSW  DS    0F                  BEGINNING PSW FOR ONE ENTRY POINT
RECFPCC  DS    C                   ILC-CC-PM, ALSO USED AS FLAG
RECFPAD  DS    AL3                 BEGINNING @ FOR ENTRY POINT IN FAKE
         SPACE 1
*              RUN STATISTICS VARIABLES
RECINSTS DS    F                   CUMULATIVE # INSTRUCTIONS DONE
RECCALLS DS    H                   CUMULATIVE # TIMES ENTRY CALLED
RECWRONG DS    H                   CUMULATIVE # TIMES PROG WRONG VALUES
RECZ$L   EQU   *-RECINSTS          LENGTH TO BE ZEROED-COUNTERS
REC$LEN  EQU   ((*-RECORBLK+3)/4)*4         LENGTH, RNDED TO FULLWRD
         TITLE 'RFSYMBLK DSECT - REPLACE ENTRY INFORMATION TABLE'
**--> DSECT: RFSYMBLK   REPLACE MODULE: 1 ENTRY IN TABLE CSECT RFSYMS .
*.             EACH SECTION OF RFSYMS GIVES EITHER A REPLACABLE       .
*.       CSECT NAME OR ONE OF ITS ENTRY POINT NAMES.   THE ENTRY      .
*.       POINT ELEMENTS CONTAIN VARIOUS POINTERS WHICH ARE USED TO    .
*.       GIVE OFFSET ADDRESSES FOR REAL ENTRY ADDRESS CONSTANTS OR    .
*.       FOR VARIOUS CHECKING CODE IN THE REPLACE MONITOR.            .
*.       **NOTE** THIS DSECT IS SAME AS FIRST PART OF RECORBLK DSECT. .
*.       GENERATION: 1 CALL TO RFSGN MACRO CREATS 1 CSECT ELEMENT     .
*.             AND 1 TO REC$MAX  ENTRY ELEMENTS.                      .
*.       LOCATION: CSECT RFSYMS.                                      .
*.       NAMES: RFS-----                                              .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
RFSYMBLK DSECT
RFSYMB   DS    CL6                 CSECT/ENTRY NAME, ALPHAMERIC
RFSENTN  DS    AL1                 CSECT: NUMBER OF ENTRY POINTS
RFSENTL  DS    AL1                 CSECT: LENGTH OF CSECT+ENTRY BLKS
RFSRIAD  DS    H                   OFFSET TO RI&CSECT-PTRS TO CALLABLES
         SPACE 1
         ORG   RFSENTN             ORG BACK . DEFINE ENTRY FIELDS
RFSAXAD  DS    H                   OFFSET TO ENTRY ADCON IN AVWXTABL
*                                  = AXENTRY - AX$BASE
RFSRGAD  DS    H                   OFFSET TO REG CHECKING CODE FOR
*                                  RETURN VALUES. = RGENTRY-RGENTS
         ORG   RFSRGAD             BACK OVER, REALLY FOR RFSYMS PART 2
RFSRHAD  DS    H                   OFFSET TO CODE TO CHECK REGS FOR
*                                  CALLING OTHER PROGS.=RHENTRY-RHENTS
RFS$LEN  EQU   ((*-RFSYMBLK+1)/2)*2         LENGTH OF BLOCK,RD FULLWORD
         TITLE 'REMONI - REPLACE MONITOR CONTROL PROGRAM'
         PRINT NOGEN
REMONI   CSECT
**--> CSECT: REMONI     REPLACE MONITOR CONTROL PROGRAM . . . . . . . .
*.       REMONI HANDLES MOST OF THE DETIALS REQUIRED FOR A STUDENT TO .
*.  WRITE AN ASSIST CSECT, HAVE IT ASSEMBLED BY ASSIST, AND THEN RUN  .
*.  A TEST PROGRAM.  THE ENTRYPOINTS OF HIS PROGRAM ARE CALLED ALONG  .
*.  WITH THE ORIGINALS, AND HIS RESULTS CHECKED FOR ACCURACY.  WHILE  .
*.  ADDRESS CONSTANT MODIFCATION IS PERFORMED, THE ENTIRE PROCESS IS  .
*.  STILL A SERIALLY RESUABLE PROGRAM.  SEE THE ASSIST REPLACE USER'S .
*.  GUIDE   FOR DETAILS ON USING THE REPLACE MONITOR.                 .
*.       NAMES: RE------           MAIN CODE BODY AND INSUBS.         .
*.       NAMES: RG------           CHECKING CODE FOR RETURN VALUES.   .
*.       NAMES: RH------           EXTERNAL CALL CHECKING (&$REPL=2)  .
*.       CALLS SYFIND                                                 .
*.       USES DSECTS: AJOBCON,AVWXTABL,ECONTROL,RECORBLK,RFSYMBLK     .
*.       USES MACROS: $CALL,$PRNT,$RETURN,$SAVE,REPRNT,XDECO,XSNAP    .
*.                                                                    .
*.       OVERALL REGISTER CONVENTIONS AND USAGE.                      .
*.  R0,R1,R2,R3,R4,R15  WORK REGISTERS                                .
*.  R5 = @ RECORBLK ELEMENT FOR CURRENT ENTRY BEING PROCESSED.        .
*.  R6 = BASE REGISTER FOR MAIN CODE OF EACH REMONI ENTRY POINT.      .
*.  R7,R8      USUAL PARAMETER REGS FOR INTERNAL SUBROUTINES.         .
*.  R9 = LINK REGISTER FOR INSUBS WHICH MUST CALL OTHERS WITH R14.    .
*.  R10= @ ECONTROL (EXECUTION CONTROL BLOCK, USER PSEUDO REGISTERS.  .
*.  R11= @ AJOBCON DSECT (MAIN JOB CONTROL TABLE)                     .
*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .
*.  R13= SAVE AREA ADDRESS, BASE REGISTER FOR DATA, INTERNAL SUBRS.   .
*.  R14= INTERNAL LINK REGISTER. LOCAL WORK REGISTER.                 .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
         $DBG  ,NO                 NO DEBUG
         ENTRY REINTA,REENDA,REFAKE    ENTRIES ALWAYS PRESENT
         SPACE 1
*              REMONI FLAG EQUATES
READMOD  EQU   B'00000001'         (REFLAGS)=>ADCONS IN AX ARE MODIFID
REFPRT   EQU   B'00000010'         (REFLAGS)=> REFAKE PRTED >=1 MSG,SKP
         SPACE 1
REC$MAX  EQU   5                   MAXIMUM # ENTRIES TO BE REPLACED
         EJECT
**--> ENTRY: REINTA     INITIALZE BEFORE ASSEMBLER CALLED . . . . . . .
*.       THIS ENTRY IS CALLED 1 TIME BEFORE ASSIST ASSEMBLER IS CALLED.
*.  IT CHECKS FOR PRESENCE OF REAL ADDRESS CONSTANTS IN VWXTABL, AND  .
*.  REPLACES THEM IF THEY HAVE BEEN MODIFIED IN PREVIOUS REPLACE RUN. .
*.       IT ALSO MAY SET FLAGS IN AVWXTABL IF THE SYSTEM IS IN        .
*.       REPLACE PHASE A (ASSEMBLE REPLACEMENT PROGRAM AND LINK IT).  .
*.       ENTRY CONDITIONS                                             .
*.  R11= @ AJOBCON (MAIN JOB CONTROL BLOCK).                          .
*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .
*.                                                                    .
*.  AVWXTABL: HAS BEEN COMPLETELY INITIALIZED BY MAIN PROGRAM ASSIST. .
*.       THIS PERMITS REINTA TO MODIFY ASSEMBLER CONTROL FLAGS IF     .
*.       NEEDED TO MAKE ASSEMBLER PERFORM REQUIRED ACTIONS.           .
*.       USES DSECTS: AJOBCON,AVWXTABL                                .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
REINTA   $SAVE RGS=(R14-R12),BR=R6,SA=RESAVE
         USING RESAVE,R13          NOTE AVAIL AS BASE
         USING AVWXTABL,RAT        NOTE ASSEMBLER TABLE USING
         USING AJOBCON,R11         NOTE MAIN JOB CONTROL TABLE
         TM    AJOMODE,AJOREPLF+AJOREPHB    TEST REPLACE STATUS
         BZ    REINREAL            NOT REPLACE AT ALL, RESTORE ADCONS
         BM    REINPHSA            AJOREPLF ONLY==> REPLACE PHASE A-BR
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PRE-ASSEMBLY -- REPLACEMENT PHASE B                    *
*        THIS ACTION OCCURS JUST BEFORE THE ASSEMBLER IS CALLED WITH  *
*        MODIFIED ADCON TABLE FOR THE TEST RUN OF USER-WRITTEN CSECT. *
*        DON'T MODIFY ADCONS AGAIN, BUT FIX AVWXTABL FLAGS SO RUN     *
*        WILL BE NORMAL.                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         OI    AJOSTEP,AJOSEXEC    SHOW MAY BE IN INTERP FROM NOW ON
         NI    AVTAGS1,255-AJORELOC         SHOW NO RELOCATION
         B     REINRETA            BRANCH TO EXIT CODE
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              PRE-ASSEMBLY -- REPLACEMENT PHASE A                    *
*        THIS SECTION IS ENTERED JUST BEFORE A USER-WRITTEN REPLACE   *
*        CSECT IS ASSEMBLED.  MAKE SURE THAT THE REAL ADCONS ARE IN   *
*        AVWXTABL (MAY HAVE BEEN CHANGED BY PREVIOUS REPLACE RUN),    *
*        AND SET FLAGS REQUIRED FOR REPLACEMENT. THIS INCLUDES        *
*        MAKING THE ASSEMBLER RELOACTE THE OBJECT CODE TO ITS         *
*        ACTUAL LOCATION IN MEMORY, SIMPLIFYING DUMP PRINTING AND     *
*        DATA TRANSFERS.                                              *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
REINPHSA EQU   *                   ENTRY LABEL: REPLACE PHASE A
         OI    AVTAGS1,AJORELOC    WE WANT USER PROGR AT REAL ADDRESS
*              FALL THRU, HAVE ANY MODIFIED ADCONS RESTORED IF NEEDED.
         SPACE 1
REINREAL BAL   R14,REREAL          HAVE REAL ADCONS REPLACED, IF NEED
REINRETA EQU   *                   EXIT LABEL
REINRET  $RETURN RGS=(R14-R12)
         DROP  R6,R11,RAT,R13      REMV USINGS
         AIF   (&$REPL LT 2).RESY1     SKIP IF NO CALLING ALLOWED
         EJECT
**--> ENTRY: RESYMB     ENTER CODE IN SYMBOL TABLE OF CALLABLE ENTRY. .
*.       RESYMB IS CALLED FROM CVCON2 IF A SYMBOL FLAGGED EXTRN IS    .
*.  USED IN A VCON.  IT PLACES A CODE INTO THE SYVALUE ENTRY OF THE   .
*.  SYMBOLS SYMSECT.  THIS CODE (THE OFFSET TO A CALLABLE ENTRY       .
*.  ELEMENT IN THE SECOND SECTION OF RFSYMS), IS USED FOR CHECKING    .
*.  WHEN THE USER PROGRAM ACTUALLY CALLS THE ROUTINE.                 .
*.       ENTRY CONDITIONS                                             .
*.  RA = @ SYMSECT FOR THE EXTRN SYMBOL.                              .
*.  ALL OTHER REGS: SAME AS ASSEMBLER REGISTER CONVENTIONS.           .
*.       EXIT CONDITIONS                                              .
*.  RA = @ SAME SYMSECT, BUT CODE HAS BEEN ENTERED IN SYVALUE.        .
*.  RB = 0     IF SYMBOL WAS LEGITAMATE.                              .
*.     = 4     IF SYMBOL WAS NOT LEGITAMETE ENTRY TO BE CALLED.       .
*.       NAMES: RES-----                                              .
*.       USES DSECTS: RFSYMBLK,SYMSECT                                .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
         ENTRY RESYMB              DECLARE HERE, SINCE MAY NOT EXIST
RESYMB   $SAVE RGS=(R14-R6),SA=RESAVE,BR=R6
         USING RESAVE,R13          NOTE FOR SAFETY
         USING SYMSECT,RA          NOTE SYMBOL TABLE PTR
         L     R3,RERFSYMS         =V(RFSYMS)
         USING RFSYMS,R3           NOTE PTR TO TABLE CSECT
         LA    R0,RFS$LEN          INCREMENT FOR BXLE SEARCH
         LA    R1,RFSCALLZ-RFS$LEN LIMIT @ FOR BXLE
         LA    R2,RFSCALLA         INDEX FOR BXLE
         USING RFSYMBLK,R2         NOTE BLOCK PTR
         SPACE 1
*              SEARCH CALLABLE ENTRY TABLE FOR THE GIVEN ENTRY.
         CLC   RFSYMB,SYMBOL       IS IT? (IGNORE 7-8 CHAR SYMBOLS)
         BE    RESFOUND            YES, SKIP OUT
         BXLE  R2,R0,*-10          LOOP THROUTHE TABLE
         SPACE 1
         LA    RB,4                COULDNT FIND IT, FLAG SO ANDRETRN
RESRETA  EQU   *                   EXIT LABEL
         $RETURN RGS=(R14-R6)      RTURN, RESTORE ALL BUT PARM REGS
         SPACE 1
*              SYMBOL FOUND - PUT OFFSET TO TABLE ELEMENT IN SYMTAB.
RESFOUND SR    R2,R3               GET OFFSET FROM RFSYMS TO ELEMENT
         ST    R2,SYVALUE          SAVE THIS AS SYMBOL VALUE
         SR    RB,RB               CLEAR TO SHOW OK
         B     RESRETA             GO RETURN
         DROP  R2,R3,R6,RA,R13     RFSYMBLK,RFSYMS,BASE1,SYMSECT,BASE2
.RESY1   ANOP
         EJECT
**--> ENTRY: REENDA     REPLACE MODULE: POST-ASSEMBLY PROCESSING  . . .
*.       REENDA IS CALLED JUST AFTER AN ASSEMBLY IS COMPLETED.        .
*.       IF THE RUN IS NOT A REPLACE RUN, NOTHING IS DONE.            .
*.       IF IT IS REPLACE PHASE A, THE ASSEMBLED PROGRAM WAS A REPLACE.
*.  VERSION OF AN ASSIST MODULE, SO CHECK AND MODIFY ASSEMBLER ADCONS..
*.       IF THE RUN IS IN PHASE B, THE ASSEMBLY JUST FINISHED WAS     .
*.  A TEST PROGRAM, SO PRINT PERFORMANCE STATISTICS FOR THE MODULE.   .
*.       ENTRY CONDITIONS                                             .
*.  R11= @ AJOBCON (MAIN JOB CONTROL BLOCK).                          .
*.  R12(RAT)= @ VWXTABL CSECT (AVWXTABL DSECT).                       .
*.       CALLS SYFIND                                                 .
*.       USES DSECTS: AJOBCON,AVWXTABL,RECORBLK,RFSYMBLK,SYMSECT      .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
REENDA   $SAVE RGS=(R14-R12),BR=R6,SA=RESAVE
         USING RESAVE,R13          NOTE 2ND BASE REGISTER
         USING AVWXTABL,RAT        NOTE MAIN ASSEMBLER TABLE USING
         USING AJOBCON,R11         NOTE POINTER THERE
         SPACE 1
*              DETERMINE REPLACE PHASE (IF ANY). IF PHASE A, LINK
*              REPLACEMENT PROGRAM.  IF PHASE B, PRINT STATISTICS.
         TM    AJOMODE,AJOREPLF+AJOREPHB    REPLACE STATUS
         BZ    REENRET             NO REPLACE, DON'T DO ANYTHING
         BO    REEPHSB             BOTH FLAGS==> PHASE B-BRANCH
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              POST-ASSEMBLY -- REPLACEMENT PHASE A                   *
*        FIND CSECT NAME IN RFSYMS TABLE.  CREATE A RECORBLK BLOCK    *
*        FOR EACH ENTRY POINT, FILLING IN VALUES.  MODIFY THE ADCONS  *
*        IN AVWXTABL WHICH BELONG TO ENTRYPOINTS OF THE CSECT.        *
*        PRINT ERROR MESSAGES FOR ANY MISSING NAMES.                  *
*              ***** PHASE A REGISTER USAGE *****                     *
*   R1 = @ RFSYMBLK OF CSECT, THEN ENTRY POINT BEING PROCESSED        *
*   R2 = INCREMENT FROM EACH CSECT ELEMENT TO THE NEXT DURING SEARCH. *
*   R3 = OFFSET VALUE OF RECORBLK FROM BEGINNING OF RECORRAD          *
*      = NUMBER OF ENTRY ELEMENTS LEFT TO PROCESS FOR GIVEN CSECT     *
*   R4 = @ SYFIND. MUST BE SAVED HERE BECUASE IT IS LEGAL TO REPLACE  *
*        SYFIND, THUS LEADING TO INTERCEPTED CALL WHEN SYFIND IS      *
*        CALLED TO LOOKUP SYEND2, WITH ADCON ALREADY MODIFIED.        *
*   R5 = @ RECORBLK ELEMENT IN RECORRAD OF ENTRY BEING PROCESSED      *
*   R7(RA)= @ ENTRYPOINT SYMSECT, THEN ADDRESS OF THAT ENTRY          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              INITIALIZE FOR SEARCH FOR AJOREPL IN RFSYMS LIST.
         L     R1,RERFSYMS         GET ADCON FOR RFSYMS
         SR    R2,R2               CLEAR FOR INSERTIONS
         LA    R3,RFSYMS$L-RFS$LEN(R1) ADEQUATE LIMIT FOR BXLE
         USING RFSYMBLK,R1         OVERLAY DSECT ON 1ST SECTION RFSYMS
         L     R4,AXSYFIND         =V(SYFIND), GET IT NOW, SO SAFE
         EJECT
*              SEARCH FOR CSECT NAME TO BE REPLACED.
*              LOOK AT EACH CSECT NAME IN RFSYMS, UNTIL ONE IS FOUND
*              WHICH IS IN THE SYMBOL TABLE AND DECLARED CSECT.
REESEARC LA    RA,RFSYMB           SHOW @ OF CSECT NAME
         LA    RB,L'RFSYMB         SHOW LENGTH OF IT (ALWAYS 6)
         LR    REP,R4              REP= =V(SYFIND). MOVE OVER FOR CALL
         BALR  RET,REP             CALL SYFIND TO LOOKUP THE SYMBOL
         L     R11,AVAJOBPT        RESTORE THE PTR IN CASE NEEDED
         SPACE 1
         LTR   RB,RB               WAS THE SYMBOL IN THE SYMBOL TABLE
         BNZ   REESEARE            NO, SO SKIP TO LOOK AT NEXT ONE
         USING SYMSECT,RA          NOTE SYMBOL TABLE PTR, IT WAS IN
         TM    SYFLAGS,$SYCSE      WAS IT FLAGGED A CSECT (A MUST)
         BO    REEFOUND            YES, THIS IS ONE WE'RE LOOKING FOR
         DROP  RA                  REMOVE SYMSECT USING
         SPACE 1
REESEARE IC    R2,RFSENTL          GET LENGTH OF CSECT+ENTRY ENTIRES
         BXLE  R1,R2,REESEARC      ADD INCREM TO NEXT CSECT, LOOP OK
         SPACE 1
*              FALLS THRU==> CSECT NAME TO BE REPLACED NOT FOUND.
*              FLAG PROGRAM UNEXECUTABLE, NEVER ENTER PHASE B.
         OI    AVTAGS1,AJNLOAD     SHOW THE REPLACE PROG NOGOOD,NO EXEC
         REPRNT REZAR100,L'REZAR100    MISSING NAME MESSAGE
         B     REENRET             RETURN, NO ADCONS CHANGED
         SPACE 1
*              CSECT NAME FOUND, NOW LINK ITS ENTRY POINTS IN VWXTABL.
REEFOUND MVC   REZCSECT,RFSYMB     MOVE REPLACED CSECT NAME OVER
         REPRNT REZAR000,REZ000L   PRINT MESSAGE WITH CSECT NAME
         SPACE 1
         IC    R2,RFSENTN          GET # ENTRIES BELONGING TO CSECT
         STH   R2,RECORNUM         STORE COUNT INTO CORRESPONDENCE #
         MVC   REFRIAD,RFSRIAD     SAVE @ OFFSET TO CALL LIST CHK VALS
         LA    R1,RFS$LEN(R1)      SET RFSYMBLK TO 1ST ENTRY-TYPE ENTRY
         LA    R5,RECORRAD         INIT TO BEGINNING @ OF CORRES TABLE
         USING RECORBLK,R5         NOTE DSECT PTR
         SR    R3,R3               CLEAR, WILL BE INDEX TO RECORRAD
         SPACE 1
*              LOOP THRU ENTRY LIST.  LOOK EACH ONE UP IN SYMBOL
*              TABLE. OBTAIN EACH ENTRY POINT @ AND CREATE A RECORBLK
*              ELEMENT FOR IT.  MODIFY ADCON IN AVWXTABL.
REESYCAL LA    RA,RFSYMB           @ SYMBOLIC ENTRYPT NAME
         LA    RB,L'RFSYMB         LENGTH OF NAME(ALWAYS 6)
*              SYFIND MAY ERASE REGISTERS RA-RE (R7-R11).
         LR    REP,R4              REP= =V(SYFIND). MOVE OVER FOR CALL
         BALR  RET,REP             CALL SYFIND TO LOOKUP THE SYMBOL
         L     R11,AVAJOBPT        RESTORE R11 IN CASE WE NEED IT
         LTR   RB,RB               WAS IT THERE
         BNZ   REENOENT            NO, UNDEFINED, NOT IN TABLE AT ALL
         USING SYMSECT,RA          NOTE SYMBOL TABLE POINTER
         TM    SYFLAGS,$SYDEF      WAS SYMBOL DEFINED
         BZ    REENOENT            NO,FLAG IT
         TM    SYFLAGS,$SYENT+$SYCSE   WAS IT EITHER CSECT OR ENTRY
         BZ    REENOENT            NO, SO FLAG IT
         L     R7,SYVALUE          GET VALUE OF SYMBOL, FOR ENTRY
         DROP  RA                  NO MORE SYMBOL DSECT
         B     REENLINK            BRANCH TO LINKAGE SEGMENT
         EJECT
*              ENTRY NOT FOUND OR UNDEFINED - PRINT MESSAGE, FLAG.
REENOENT MVC   REZEN002,RFSYMB     MOVE THE ENTRY NAME OVER
         REPRNT REZAR002,REZ002L   MESSAGE SHOWING ENTRY NOT FOUND
         L     R7,AWFM1            TO GO INTO RECFPSW, SHOW NOGOOD
         SPACE 1
*              LINK NEEDED POINTERS AND CORRESPONDENCE TABLE RECORRAD.
REENLINK MVC   RECSYMB(RFS$LEN),RFSYMB      MOVE RFSYMBLK OVER
         ST    R7,RECFPSW          SAVE ENTRYPT IN USER PROGRAM
         LH    R14,RECAXAD         GET OFFSET INTO AVWXTABL FOR ADCON
         LA    R14,AX$BASE(R14)    GET ACTUAL @ OF THE ADCON
         MVC   RECADRE,0(R14)      SAVE THE REAL ADCON
         MVC   RECINSTS(RECZ$L),AWZEROS     ZERO STATS COUNTERS
*              FILL IN AVWXTABL WORD- @ REFAKE, OFFSET ID OF ENTRYPT
         MVC   0(4,R14),REREFAKE   PUT IN @ FAKE/CHECK ROUTINE
         STC   R3,0(,R14)          STORE RECORBLK OFFSET INTO ADCON BYT
         SPACE 1
*              CHECK IF ENTRY OK, PRINT MESSAGE IF SO.
         LTR   R7,R7               WAS ENTRY @ < 0 (I.E. NOT FOUND)
         BM    REENOENS            NO, MESSAGE ALREADY PRINTED
         LA    R8,REZLOCAT         SHOW @ FOR HEX CONVERSION
         BAL   R14,REXCON3         CONVERT TO HEX
         MVC   REZEN001,RFSYMB     MOVE SYMBOL IN FOR ENTRY NAME
         REPRNT REZAR001,REZ001L   MESSAGE DESCRIBNG OK ENTRY
         SPACE 1
REENOENS LA    R1,RFS$LEN(R1)      BUMP PTR TO NEXT RFSYMBLK ENTRY
         LA    R3,REC$LEN(R3)      INCREMENT OFFSET VALUE IN RECORRAD
         LA    R5,REC$LEN(R5)      BUMP PTR TO NEXT RECORBLK ELEMENT
         BCT   R2,REESYCAL         GO BACK FOR NEXT ENTRY. LOOP ON #
         DROP  R1,R5               REMV RFSYMBLK,RECORBLK
         SPACE 1
         OI    REFLAGS,READMOD     SHOW WE'VE MODIFIED ADCONS
         B     REENRET             RETURN TO CALLING PROGRAM
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              POST-ASSEMBLY -- REPLACEMENT PHASE B                   *
*        PRINT STATISTICS OF USER-PROGRAM PERFORMANCE.                *
*              ***** PHASE B REGISTER USAGE *****                     *
*   R0,R1,R2,R8,R9      WORK REGISTERS                                *
*   R4 = NUMBER OF RECORBLK ENTRIES LEFT TO PROCESS                   *
*   R5 = @ RECORBLK OF ENTRY WHOSE STATISTICS ARE BEING CALCULATED.   *
*   R7 = @ 12-BYTE FIELD WHERE NEXT OUTPUT NUMBER TO BE PLACED        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
REEPHSB  REPRNT REZAR003,REZ003L   PRINT HEADER LINE
         LH    R4,RECORNUM         # ENTRY POINTS FOR LOOP COINTER
         LA    R5,RECORRAD         INIT @ TO BEGINNING OF TABLE
         USING RECORBLK,R5         NOTE POINTER
         SPACE 1
REESTATS MVC   REZ004EN,RECSYMB    MOVE ENTRYPOINT NAME OVER
         LA    R7,REZ004NS         @ 1ST OUTPUT NUMBER, INCRD BY DECO
         SPACE 1
         L     R8,RECINSTS         # INSTRUCTIONS DONE
         BAL   R14,REEXDECO        PRINT IT, ADVANCE R7 PTR
         SPACE 1
         LR    R1,R8               SAVE # INSTRUCTIONS DONE FOR LATER
         LH    R8,RECCALLS         # CALLS TO ROUTINE
         BAL   R14,REEXDECO        CONVERT # CALLS, ADVANCE R7
         SPACE 1
         LR    R2,R8               SAVE # CALLS FOR LATER DIVIDESX
         LH    R8,RECWRONG         GET # WRONG RETURN TIMES
         BAL   R14,REEXDECO        CONVERT # WRONG, ADVANCE R7
         SPACE 1
         LR    R9,R8               SAVE # WRONG
         LTR   R2,R2               WAS # CALLS ZERO
         BNZ   *+8                 NO, SO LEAVE AS IS
         LA    R2,1                YES, =0, SO MAKE =1 FOR SAFE DIVIDES
         SR    R0,R0               CLEAR FOR DIVIDE SETUP
         DR    R0,R2               AVG # INSTRS/CALL
         LR    R8,R1               MOVE QUOTIENT OVER FOR CONVERT
         BAL   R14,REEXDECO        CALL CONVERT ROUTINE, ADVANCE R7
         SPACE 1
         LA    R8,100              VALUE FOR PERCENT CONVERT
         MR    R8,R8               # WRONG * 100, RESULT IN R9
         DR    R8,R2               #WRONG*100/#CALLS = PERCENT
         LR    R8,R9               MOVE QUOTIENT FOR CONVERT
         BAL   R14,REEXDECO        CONVERT, ADVANCE R7
         SPACE 1
         REPRNT REZAR004,REZ004L   PRINT MESSAGE FOR THIS ENTRY
         LA    R5,REC$LEN(R5)      INCREMENT THE RECORBLK PTR
         BCT   R4,REESTATS         LOOP BACK FOR NEXT RECORBLK VALS
         DROP  R5                  DON'T NEED RECORBLK ANYMORE
         SPACE 1
REENRET  $RETURN RGS=(R14-R12)
         DROP  R6,R11,RAT,R13      DROP TABLE USINGS, BASE REGS
         EJECT
**--> ENTRY: REFAKE     INTERCEPT REPLACED CALLS, CHECK REAL/USER . . .
*.       ENTRY CONDITIONS                                             .
*.  R15(BITS 0-7)= OFFSET CODE # FOR SPECIFIC ENTRY BEING CALLED.     .
*.  R0-R14     ARE AS DESCRIBED IN ASSEMBLER CALLING CONVENTIONS.     .
*.. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
* * * * * REFAKE ENTRY REGISTER USAGE * * * * * * * * * * * * * * * * *
*   R0,R1,R2,R3,R4,R15  WORK REGISTERS                                *
*   R5 = @ RECORBLK ELEMENT FOR THE ENTRY POINT BEING CALLED.         *
*   R6 = FIRST BASE REGISTER, USED FOR MAIN CODE.                     *
*   R9 = LINK REGISTER FOR INSUBS WHICH MUST CALL OTHERS WITH R14.    *
*   R10= @ ECONTROL (EXECUTION CONTROL BLOCK, USER PSEUDO REGISTERS.  *
*   R13= SAVE AREA @, ALSO SECOND BASE REGISTER, FOR INSUBS.          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
REFAKE   $SAVE RGS=(R14-R6),BR=R6,SA=RESAVE      SAVE ALL BUT PARM RGS
         USING AVWXTABL,RAT        NOTE MAIN ASM TABLE USING
         USING RESAVE,R13          NOTE SECONDARY BASE REG USING
         SPACE 1
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        REFAKE IS ENTERED VIA A MODIFIED ADCON IN AVWXTABL, WHICH    *
*   ALSO CONTAINS THE OFFSET IN RECORRAD OF THE RECORBLK FOR THE      *
*   REPLACED ENTRY BEING CALLED.  SET R5 TO THE @ THIS RECORBLK, TO BE*
*   USED THROUGHOUT THIS CODE.  CALL THE CORRESPONDING REAL ASSIST    *
*   ROUTINE.  SAVE INITIAL PARM REGISTER VALUES AND THOSE RETURNED    *
*   BY REAL ROUTINE FOR TESTING, OR PRINTING.  ALSO PRINT VARIOUS     *
*   REGISTER SETS OR THE CURRENT STATEMENT, IF REQUIRED BY SETTING    *
*   OF VARIOUS BITS IN ECRFLAG OF THE ECONTROL BLOCK.                 *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         STM   RA,RE,REGSAVA       SAVE ORIGINAL PARM REG VALUES
         SRL   R15,24              GET HI-ORDER BYTE BY ITSELF
         LA    R5,RECORRAD(R15)    ADD OFFSET TO TABLE @==>@RECORBLK
         USING RECORBLK,R5         NOTE @ TABLE ELEMENT
*              INCREMENT TOTAL NUMBER OF TIMES CALLED.
         LH    R15,RECCALLS        CURRENT TOTAL NUMBER OF CALLS
         LA    R15,1(R15)          +1 FOR THIS TIME
         STH   R15,RECCALLS        = NEW CURRENT TOTAL # CALLS
         SPACE 1
*              CALL THE REAL ASSIST ROUTINE FIRST.  SAVE THE VALUES
*              IT RETURNS IN REGISTERS RA-RE FOR LATER USE.
         SPACE 1
         L     R15,RECADRE         GET REAL ENTRY POINT @
         BALR  RET,REP             CALL THE REAL ROUTINE
         STM   RA,RE,REGSAVB       SAVE THE RETURNED PARAMETERS
         SPACE 2
*              ENTRY ACCEPTED, SET UP FOR INTERPRETATION
         L     R11,AVAJOBPT        GET PTR TO ,AIN CONTROL BLOCK
         USING AJOBCON,R11         NOTE PTR
         L     R10,AJOECOPT        GET PTR TO PARTIALLY-FILLED ECONTROL
         USING ECONTROL,R10        NOTE PTR
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        DEPENDING ON ECRFLAG (WHICH CAN BE CHANGED BY THE USER PROG  *
*   DURING EXECUTION), PRINT THE CURRENT CARDIMAGE (IF ANY), THE 5    *
*   PARAMETER REGISTERS ON ENTRY, AND/OR THE PARAMETER REGISTERS      *
*   RETURNED BY THE REAL ASSIST ROUTINE.                              *
*        THEN FLIP THESE BIT FLAGS, SO THAT IF AN ERROR OCCURS, WE    *
*   CAN PRINT ANYTHING WE DIDN'T ALREADY PRINT .                      *
*              INIT REFPRT BIT IN REFLAGS OFF.  USE OF REXPRINT INSUB *
*        SETS THIS BIT ON.  IF IT IS ON WHEN REFAKE EXITS, 2 LINES ARE*
*        SKIPPED TO SEPARATE OUR MESSAGES FROM FOLLOWING LISTING. THE *
*        LISTING IS VERY HARD TO FOLLOW IF THIS IS NOT DONE.          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         NI    REFLAGS,255-REFPRT      INIT FLAG TO SHOW NO MSGS PRT YT
         MVC   REFRFLAG,ECRFLAG    SAVE THE BYTES FOR LATER
         BAL   R9,REFRFC           CALL INSUB FOR 3 CHECKS/PRINTS
         XI    REFRFLG1,ECR$REGB+ECR$REGA+ECR$CARD    FLIP BITS
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*        FINISH CONSTRUCTION OF ECONTROL FOR INTERPRETIVE CALL TO     *
*   USER-WRITTEN REPLACEMENT PROGRAM.  CALL THE INTERPRETER, WITH THE *
*   USER PROGRAM AS ARGUMENT. INCREMENT STATISTICS, AND BRANCH TO     *
*   PROCESS POSSIBLE ERROR IF ANY BUT NORMAL RETURN INDICATED.        *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              TEST USER ENTRYPT TO MAKE SURE HAS BEEN FOUND.
         CLI   RECFPCC,0           WAS BYTE 0, I.E. LEGAL @
         BNE   REFNOCAL            NO, SO QUIT NOW, CAN'T EXECUT
         SPACE 1
         MVC   ECFENTER,RECFPSW    INIT ENTRY POINT TO RIGHT @
         MVI   ECFLAG0,$ECSPIEB+$ECEOF      SET FLAG PROPERLY
         SPACE 1
*              INITIALIZE REGISTER CONTENTS FOR USER PROGRAM.
         MVC   ECREGS(7*4),REFILLRG         PUT IN REGISTER FILLER
         MVC   ECREGRA(5*4),REGSAVA         MOVE ORIG PARM REGS TO FAKE
         MVC   ECFPREGS(32),ECREGS PUT 4'S OVER HERE ALSO
         ST    RAT,ECREG12         SAVE AVWXTABL PTR HERE
         MVC   ECREG13,ECSAVE1     MOVE @ DUMMY SAVEAREA INTO FAKE 13
         MVC   ECREG14,RERFSYMS    PUT DISTINCT, EASY-TO-CHECK RET @
         MVC   ECREG15,ECFENTER    PUT ENTRY PT @ IN FAKE R15
         SPACE 1
REEXECUT EQU   *                   ENTER HERE AFTER USER CALLED AN
*                                  ASSIST MODULE AND IT REURNED OK
         L     REP,AJOEXECU        =V(EXECUT)         PUT IN ADCON
         BALR  RET,REP             CALL THE INTERPRETER
         SPACE 1
*              UPDATE TOTAL NUMBER OF INSTRUCTIONS PERFORMED.
         LM    R14,R15,ECILIMT     GET ECILIMT-ECILIMP
         SR    R15,R14             # INSTRUCTIONS EXECUTED THIS TIME
         A     R15,RECINSTS        +  CUMULATIVE TOTAL FROM BEFORE
         ST    R15,RECINSTS        =  NEW CUMULATIVE TOTAL INSTRUCTIONS
         SPACE 1
         MVI   RERGEFLG,0          ZERO OUT RETURN CODE FLAG
         MVC   REZ059MS(REZ059ML),AWBLANK   BLANK OUT MESSAGE AREA
         SPACE 1
         CLI   ECFLAG1,$ECBRN14    WAS A PROPER RETURN DONE
         BNE   REFNORET            NO GOOD RETURN-BRANCH
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CHECKING SECTION FOR USER-RETURNED REGISTERS           *
*        1. CALL INSUB RGENTS TO CHECK REGS RA-RE FOR INDIVIDUAL CASES*
*        2. MAKE COMMON CHECK FOR MODIFIED REGS - R0-R6, R12, R13.    *
*        3. SET ECRFLAG IF NEEDED AND PRINT MESSAGE AR059 AND OTHER   *
*        MESSAGES, IF THERE WERE ONE OR MORE ERRORS.                  *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         LH    R15,RECRGAD         GET OFFSET FOR SPECIFIC ERROR
         BAL   R14,RGENTS          CALL CHECKING ROUTINE.INITS RERGEFLG
         SPACE 1
         NI    ECRFLAG+1,255-ECR$ERRC       INIT TO SHOW NO ERRORS
         SPACE 1
         CLC   ECREGS(7*4),REFILLRG         MAKE SURE DIDN'T MESS UP
         BE    *+14                OK, SKIP ERROR
         OI    RERGEFLG,RGE06      FLAG THIS ERROR
         MVC   REZ059R0,=C'R0-R6'  MOVE MESSAGE IN
         SPACE 1
         BAL   R14,REGC1213        CALL R1K R13 CHECKER
         SPACE 1
         TM    RERGEFLG,X'FF'      WERE THERE ANY ERRORS AT ALL
         BZ    REFNOERR            NO, SO SKIP PRINTING
         SPACE 1
         OI    ECRFLAG+1,ECR$ERRC  SET ERROR FLAG FOR THE USER
         BAL   R9,REFRFC           PRINT OUT ANYTHING NOT ALREADY DONE
         B     REF059PR            SKIP TEST, GO PRINT AR058-AR059
         SPACE 1
*              TEST FOR PRINTING REGS RETURNED BY USER PROGRAM.
REFNOERR TM    ECRFLAG+1,ECR$REGC  DID HE WANT TO SEE RETURN REGS
         BZ    REFRFZ08            NO, SKIP
         SPACE 1
REF059PR MVI   REZ05XN,C'8'        SHOW AR058 MESSAGE
         BAL   R14,REREGSRA        CALL REREGS, PRINT ECREGSRA-
REFRFZ08 EQU   *                   BRANCH LABEL IF PREVIOUS CODE SKIPPE
         SPACE 1
         TM    RERGEFLG,X'FF'      WERE THERE ANY ERRORS
         BZ    REFNOERS            NO ERRORS, BRANCH OUT AGAIN
         SPACE 1
*              AR058 MESSAGE JUST PRINTED. ADD AR059 WITH ERROR FLAGS.
         BAL   R9,REGCRARE         CALL TO CHK BITS, FLAG, PRINT AR059
         SPACE 1
         LH    R1,RECWRONG         GET CURRENT # WRONG
         LA    R1,1(R1)            +1 FOR THIS TIME
         STH   R1,RECWRONG         = NEW TOTAL # WRONG
         B     REFARETA            GO RESTORE PARM REGS, RETURN
         EJECT
*              EXIT TAKEN IF UNFOUND ENTRY POINT CALLED DURING EXEC.
REFNOCAL EQU   *                   CALLED ENTRY NOT FOUND EXIT
         MVC   REZEN101,RECSYMB    MOVE NAME OF ENTRY OVER-ERROR
         REPRNT REZAR101,REZ101L   PRINT UNFOUND ENTRY CALLED DURING EX
         LM    R14,R15,ECRDLIML    ECRDLIML-H - DUMP LIMITS
         XSNAP T=(PR,FL,1),STORAGE=(*0(R14),*0(R15)),                  #
               LABEL='REPLACE MONITOR AR101 DUMP'
         B     REFAREAL            GO RESTORE ADCONS
         SPACE 2
REFNORET EQU   *                   BRANCH HERE IF NOT RIGHT RETURN
         AIF   (&$REPL LT 2).REFNOBR        SKIP IF CAN'T CALL OTEHRS
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CHECK USER FOR CALLING ASSIST ROUTINE PROPERLY         *
*        CHECK USER ROUTINE FOR BRANCHING OUT IF ITSELF, USING A LEGAL*
*        OFFSET CODE GIVEN TO IT BY RESYMB.                           *
*              REGISTER USAGE IN CALL CHECKING SECTION                *
*   R4 = @ RFSYMBLK OF CALLED ROUTINE (SECTION 2 OR RFYSMS).          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
         CLI   ECFLAG1,$ECBROUT    WAS ERROR BRANCH OUT OF RANGE
         BNE   REFABEND            NO, SO MUST BE ACTUAL ERROR
         SPACE 1
         LH    R15,REFRIAD         GET OFFSET TO RI&CSECT IF ANY
         LTR   R15,R15             IS THIS CSECT ALLOWED TO CALL
         BZ    REFABEND            =0 ==> CAN'T CALL-BRANCH -ERROR
         SPACE 1
         L     R1,RERFSYMS         =V(RFYSMS), @ CONTROL TABLE
         LH    R0,0(R15,R1)        GET # ENTRY PTS CALLABLE FROM CSECT
         L     R4,ECREG15          GET USER REGISTER 15
         LA    R4,0(R4)            REMOVE ANY GARBAGE FROM FRONT
         SPACE 1
*              SEE IF USER BRANCHED TO LEGAL OFFSET GIVEN HIM BY RESYMB
REHSEARC LA    R15,2(R15)          INCREMENT COUNTER TO NEXT HALF
         LH    R2,0(R15,R1)        GET NEXT VALUE, EXPAND
         CR    R4,R2               WAS VALUE THE SAME
         BE    *+12                YES, ITS OK, SO JUMP OUT OF LOOP
         BCT   R0,REHSEARC         LOOP BACK FOR LIST OF CALLABLES
         B     REFABEND            VALUE WASN'T ONE OF OURS-QUIT
         SPACE 1
*              OFFSET INTO SECTION 2 OF RFSYMS CHECKED AND OK.
         AR    R4,R1               ADD =V(RFYSMS), GET @ ELEMENT
         DROP  R5                  TEMPORARILY REMOVE USING FOR USER
         USING RFSYMBLK,R4         NOTE PTR TO CALLED ASSIST PROG
         LH    R15,RFSRHAD         GET OFFSET OF CHECKING CODE
         BAL   R14,RHENTS          CALL CHECKER, NOTE RERGEFLG =0 ALRED
         SPACE 1
         BAL   R14,REGC1213        GET R12 CHECKED, R13 PARTIALLY
         TM    RERGEFLG,RGE13      WAS R13 FLAGGED
         BZ    REHN13              NO, SO IT WAS OLD SA PTR, OK
         SPACE 1
         TM    ECREG13+3,3         AS IT ON F BOUNDARY
         BNZ   REHN13              NO, ERROR, LEAVE IT FLAGGED
         L     R15,ECREG13         GET USER R13
         LA    R15,0(R15)          REMOVE LEADING BYTE
         C     R15,ECFADL          LOWER THAN LOWEST USER @
         BL    REHN13              OUT OF AREA, ALREADY MARKED,BR
         C     R15,ECFADHC         COMPARE TO HIGH LIMIT FOR USER
         BH    REHN13              OUTSIDE, NOGOOD, LAREADY FLAGGED
         NI    RERGEFLG,255-RGE13  IN USER AREA, OS OK, REMOVE FLAG
         MVC   REZ05913,AWBLANK    REMOVE R13 MESSAGE TOO
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              IF USER WANTS TO SEE THEM, OR IF THERE IS AN ERROR,    *
*        PRINT PARAMETER REGISTERS PASSED BY USER PROGRAM.  IF IN     *
*        ERROR, PRINT ERROR MESSAGE AND ABEND THE USER.  IF CORRECT,  *
*        CALL THE ASSIST ROUTINE, AND PASS ITS ANSWERS BACK TO THE    *
*        USER PROGRAM.  THE INTERPRETR CONTINUES FROM WHERE IT LEFT   *
*        OFF, WITHOUT REINITIALIZING INSTRUCTION STACK.               *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
REHN13   TM    ECRFLAG+1,ECR$REGD  DID USER WANT REGS PRINTED ON CALL
         BO    REF050PR            YES, OS GO PRINT
         SPACE 1
         TM    RERGEFLG,X'FF'      WAS NAYTHING WRONG WITH HIS REGS
         BZ    REHNOERS            NO, SO LEGIT CALL, GO DO IT
         SPACE 1
REF050PR MVI   REZ05XN,C'0'        SHOW AR050 MESSAGE
         MVC   REZ05XMS,=CL9'CALL TO'       MOVE IN MESSAGE
         MVC   REZ05XEN,RFSYMB     MOVE IN SYMBOL OF ENTRY CALLED
         BAL   R14,REREGSRA        GO PRINT USER REGS OUT
         SPACE 1
         TM    RERGEFLG,X'FF'      WERE THER ANY ERRORS
         BZ    REHNOERS            NO, USER JUST WANTED TO SEE, SKIP
         SPACE 1
         BAL   R9,REGCRARE         HAVE REGS RA-RE FLAGGED IF NEED,PRT
         B     REFABEND            USER MADE HIS MISTAKE-ABEND
         SPACE 1
REHNOERS LH    R15,RFSAXAD         OFFSET IN AVWXTABL OF V(REAL ROUT)
         DROP  R4                  DON'T NEED CALLED RFSYMBLK ANYMORE
         USING RFSYMBLK,R5         RESTORE NOREMAL USING FOR ELSEWHERE
         L     R15,AX$BASE(R15)    GET ACTUAL @ CALLED ROUTINE
         SPACE 1
         LR    R1,R10              SAVE @ ECONTROL
         LM    RA,R13,ECREGRA      GET USER REGS RA-RE,R12,R13
         USING ECONTROL,R1         TEMPORARY USING
         DROP  R10                 REMOVE USING SO WE CAN USE R1 TEMPRL
         DROP  R13                 WIPED OUT REG, SO ERASE USING
         BALR  R14,R15             CALL REAL ASSIST ROUTINE
         SPACE 1
         STM   RA,RE,ECREGRA       SAVE THE PARM REGS
         LR    R10,R1              GET @ ECONTROL BACK IN USUAL REG
         DROP  R1                  REMOVE TGEMP USING
         USING ECONTROL,R10        RESTORE NORMAL USING
         L     R11,AVAJOBPT        GET @ AJOBCON BACK
         LA    R13,RESAVE          GET @ OF OUR SAVE AREA BACK
         USING RESAVE,R13          RESOTRE NORMAL USING HERE
         SPACE 1
         MVC   ECPSWIAD,ECREG14+1  MOVE TO PSW @ SO STARTS THERE
         B     REEXECUT            GO TO START INTEPRETER UP AGAIN
         EJECT
.REFNOBR ANOP
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              REFAKE EXIT CODE SECTIONS                              *
*        IF USER ABENDED FOR ANY REASON, GIVE HIM A DUMP AND          *
*        HAVE ALL ADCONS REPLACED, THUS TERMINATING REPLACEMENT.      *
*        IN ANY CASE, PLACE THE CORRECT RETURN VALUES IN PARAMETER    *
*        REGISTERS RA-RE.  THEN RETURN TO THE ASSIST ASSEMBLER        *
*        ROUTINE WHICH UNWITTINGLY CALLED REFAKE.                     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
REFABEND EQU   *                   USER PROGRAM ABEND EXIT
         REPRNT REZAR102,REZ102L   ABEND MESSAGE
         BAL   R9,REFRFC           PRINT ANYTHING NOT ALREADY PRINTED
REFADUMP EQU   *                   ENTER HERE TO DUMP USER AND RESTORE
         LM    R14,R15,ECRDLIML    GET DUMP LIMITS
         XSNAP T=(PR,FL,10),STORAGE=(*0(R14),*0(R15)) GIVE DUMP
REFAREAL EQU   *                   ENTER HERE IF CANNOT USE DUMP ABOVE
         BAL   R14,REREAL          CANCEL REPLACEMENT
         SPACE 1
REFNOERS EQU   *                   BRANCH HERE IF NO ERRORS IN REG CHEC
REFARETA EQU   *                   EXIT LABEL FOR ENTIRE REFAKE
         TM    REFLAGS,REFPRT      HAVE WE PRINTED ANY MESSAGE
         BZ    REFARETE            NO, SO DON'T DO ANYTHING
         REPRNT  REZAR000,1        =C'0'.  SKIP 2 LINES FOR READABLE
REFARETE EQU   *                   BRANCH HERE IF DON'T HAVE TO SKIP
         LM    RA,RE,REGSAVB       RELOAD REAL SUBR'S RIGHT PARM RGS
REFARET  $RETURN RGS=(R14-R6)      RESTORE ALL BUT PARM REGS
         DROP  R5,R6,R10,R11,RAT,R13        ERASE ALL USINGS
         TITLE 'REPLACE MONITOR - INTERNAL DATA AREAS - BASE R13'
RESAVE   DS    18F                 SAVE AREA, SECONDARY BASE REG
         SPACE 1
REREFAKE DC    A(REFAKE)           ADCON TO PLACE INTO AVWXTABL
RERFSYMS DC    V(RFSYMS)           SYMBOLIC ENTRY TABLE CSECT
REFILLRG DC    (7*4)AL1($PRGFILR)  FILL CHARS FOR REGISTERS
REGSAVA  DS    5F                  REGS RA-RE BEFORE REAL PROG CALLED
REGSAVB  DS    5F                  REGS RA-RE AFTER CALL TO REAL SUBR
RECORRAD DS    0F,(REC$MAX)CL(REC$LEN)      ADCON CORRESPONDENCE TABLE
REXFWORK DC    F'0',X'04'          WORKAREA, WITH REVERSED ' ' FOR HEX
REFLAGS  DC    B'0'                FLAG BYTE
RECORNUM DC    H'0'                CURRENT # ENTRIES IN RECORRAD
REFRFLAG DS    H                   SAVE AREA FOR ECRFLAG OVER CALL
REFRFLG1 EQU   *-1                 @ 2ND BYTE REFRFLAG, WHERE BITS ARE
REFRIAD  DS    H                   OFFSET @ FROM RFSYMS TO COUNT, THEN
*              LIST OF OFFSETS TO RFSYMBLK ELEMENTS FOR CALLABLE SUBS
*              FOR REPLACED CSECT.  ONLY USED IF &$REPL=2.
RERGEFLG DS    B                   FLAG FOR ERROR CONDTIONS IN USER RGS
         SPACE 2
*              INFORMATION, WARNING MESSAGES - AR00# MESSAGES.        *
*        ///AR000 - LIST NAME OF CSECT BEING REPLACED.                *
*        ///AR001 - LIST NAME AND LOCATION OF EACH ENTRY BEING REPPD. *
*        ///AR002 - LIST NAME OF ENTRY REQUIRED BUT NOT FOUND.        *
*        ///AR003 - OUTPUT HEADER FOR PERFORMANCE STATISTICS          *
*        ///AR004 - LIST PERFORMANCE STATISTICS FOR SINGLE ENTRY.     *
         SPACE 1
REZAR000 DC    C'0///AR000 REPLACE CSECT: '
REZCSECT DC    CL6' ',C' ///'
REZ000L  EQU   *-REZAR000          LENGTH OF MESSAGE
         SPACE 1
REZAR001 DC    C'0///AR001 REPLACE ENTRY: '
REZEN001 DC    CL6' ',C' AT LOCATION: '
REZLOCAT DC    XL6'0',C' ///'
REZ001L  EQU   *-REZAR001          LENGTH OF MESSAGE
         SPACE 1
REZAR002 DC    C'0///AR002 REPLACE ENTRY: '
REZEN002 DC    CL6' ',C' NOT FOUND AS CSECT OR ENTRY ///'
REZ002L  EQU   *-REZAR002          LENGTH OF MESSAGE
         SPACE 1
REZAR003 DC    C'0///AR003 STATISTICS :  # INSTRUCTIONS    # CALLS    '
         DC    C'# WRONG    INSTRS/CALL   % WRONG'
REZ003L  EQU   *-REZAR003          LENGTH OF MESSAGE
         SPACE 1
REZAR004 DC    C' ///AR004     '
REZ004EN DC    CL6' ',C' : '       SPACE OFR ENTRY NAME
REZ004NS DS    5ZL12               5 SLOTS FOR OUTPUT NUMBERS
         DC    C' %'
REZ004L  EQU   *-REZAR004          LENGTH OF MESSAGE
         EJECT
*              DEBUG SERVICE MESSAGES - AR05# MESSAGES AND ITEMS.
*        ///AR050 - PARM REGISTERS ON CALL TO ANOTHER ROUTINE.        *
*        ///AR051 - CARDIMAGE BEFORE ENTRY TO ROUTINE.                *
*        ///AR052 - PARM REGISTERS BEFORE ENTRY TO ROUTINE.           *
*        ///AR054 - PARM REGISTERS RETURNED BY REAL ROUTINE.          *
*        ///AR058 - PARM REGISTERS RETURNED BY USER ROUTINE.          *
*        ///AR059 - REGISTER ERROR MESSAGE, SHOWING ONES IN ERROR     *
         SPACE 1
REZAR051 DC    C'0///AR051 ON ENTRY TO  '
REZ051EN DC    CL6' ',C' STMT ADDR: '       ENTRY NAME
REZ051AD DC    XL6'0',C' ->'       @ CARDIMAGE, PTR TO IT
REZ051CD DS    CL71                SPACE FOR MOST OF CARD
REZ051L  EQU   *-REZAR051          LENGTH OF MESSAGE
         SPACE 2
REZ05ENT DC    C'ENTRY TO '        ... THESE TWO CONSTANTS MUST
REZ05EXT DC    C'EXIT FROM'        ... BE OF THE SAME LENGTH.
         SPACE 1
REZAR05X DC    C'0///AR05'         HEADER BEGINNING
REZ05XN  DC    X'0',C' ON '        LAST DIGIT OF MESSAGE NUMBER
REZ05XMS DC    CL(L'REZ05ENT)' ',C' '       'ENTRY TO' OR 'EXIT FROM'
REZ05XEN DC    CL6' ',C' REGISTERS RA-RE: '           ENTRY NAME
         DC    C'RA/7/: '
REZ05XRG DC    XL8'0',C' RB/8/: ',XL8'0',C' RC/9/: ',XL8'0',C' RD/A/: '
         DC    XL8'0',C' RE/B/: ',XL8'0',C' '
REZ05XL  EQU   *-REZAR05X          LENGTH OF MESSAGE AREA
         SPACE 1
REZAR059 DC    C' ///AR059 WARNING: ERROR IN USER REGS: '
REZ059MS EQU   *                   BEGINNING OF AREA TO BE BLANKED
REZ059R0 DS    C'R0-R6',C' '       ERR IN ANY OF THESE
REZ05912 DS    C'R12',C' '         ASM TABLE REG-CAN'T CHANGE
REZ05913 DS    C'R13',C' '         SAVE AREA PTR
         ORG   REZAR059+(REZ05XRG-REZAR05X) ORG TO SIMILAR OFFSET
REZ059RG EQU   *                   BEGINNING OF MESSAGES FOR REGS
         ORG   REZAR059+REZ05XL    LEAVE SAME AMOUNT OF SPACE
REZ059ML EQU   *-REZ059MS          LENGTH TO BLANK OUT
REZ059L  EQU   *-REZAR059          LENGTH OF MESSAGE
         SPACE 2
*              SEVERE ERROR MESSAGES  - AR10# MESSAGES.               *
*              THESE ERRORS TERMINATE REPLACEMENT IMMEDIATELY.        *
*        ///AR100 - REPL= NAME COULD NOT BE FOUND.                    *
*        ///AR101 - UNFINDABLE ENTRY NAME CALLED DURING EXECUTION.    *
*        ///AR102 - USER PROGRAM ABENDED.                             *
         SPACE 1
REZAR100 DC    C'0///AR100 REPLACE CSECT NOT FOUND - REPLACE ABORT ///'
         SPACE 1
REZAR101 DC    C'0///AR101 INVALID ENTRYPOINT NAME: '
REZEN101 DC    CL6' ',C' CALLED. REPLACE ACTION ABORTED ///'
REZ101L  EQU   *-REZAR101          LENGTH OF MESSAGE
         SPACE 1
REZAR102 DC    C'0///AR102 USER PROGRAM ABENDED DURING REPLACEMENT ///'
REZ102L  EQU   *-REZAR102
         TITLE 'REPLACE MONITOR INTERNAL SUBROUTINES - BASE R13'
         SPACE 1
*              ***NOTE*** THE FOLLOWING USINGS ARE ASSUMED WHEN
*        NECESSARY BY ANY OF THE INSUBS WHICH NEED THEM.
         USING RECORBLK,R5         INDIVIDUAL ENTRY INFORMATION
         USING ECONTROL,R10        EXECUTION CONTROL TABLE
         USING AJOBCON,R11         JOB CONTROL TABLE PTR
         USING AVWXTABL,RAT        NOTE FOR REST OF CODE
         USING RESAVE,R13          NOTE SECONDARY BASE REGISTER
         SPACE 2
*              *****   LIST OF INSUBS *****                           *
*        REEXDECO  -   CONVERT NUMBER FROM BINARY TO EDITED DECIMAL   *
*        REFRFC    - PRINT REGISTER SETS DETERMINED BY USER           *
*        REGC1213  - CHECK USER REGS  12 AND 13, SET FLAGS            *
*        REGCRARE  - TEST FLAGS FOR REGS RA-RE. FORMAT AND PRINT MSG  *
*        REREAL    - RESTORE NORMAL ADDRESS CONSTANTS IN AVWXTABL     *
*        REREGS    - FORMAT,PRINT PARM REGS. REREGSRA PRINTS ECREGRA- *
*        REXCON3   - CONVERT REGISTER VALUE TO 3 BYTES OF HEXADECIMAL *
*        REXPRINT  - PRINT A LINE (CALLED BY REPRNT MACRO)            *
*                                                                     *
*        RGENTS    - RETURN VALUE CHECKING SECTION                    *
*        RGRAADDR  - (RGENTS INTERNAL) - CHECK RA FOR LEGAL SCAN PTR  *
*        RGRCADDR  - (RGENTS INTERNAL) - CHECK RC FOR @ IN USER PROGR *
*                                                                     *
*        RHENTS    - CHECK PARM REGS USER PASSED TO ASSIST SUBR.      *
*        RHRAADDR  - (RHENTS INTERNAL) CHECK RA FOR LEGALITY          *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 4
**--> INSUB: REEXDECO   CONVERT NUMBER TO DECIMAL   + + + + + + + + + +
*+       CALLED FROM REENDA, PHASE B, CONVERT NUMBER, ADVANCE PTR.    +
*+       ENTRY CONDITIONS                                             +
*+  R7 = @ 12-BYTE FIELD WHERE NUMBER SHOULD BE PLACED.               +
*+  R8 = NUMBER TO BE CONVERTED TO DECIMAL AND PLACED AT 0(R7).       +
*+  R14= RETURN @ TO CALLING CODE IN REENDA.                          +
*+       EXIT CONDITIONS                                              +
*+  R7 = INPUT VALUE OF R7 + 12, I.E., ADVANCED 1 POSITION.           +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REEXDECO XDECO R8,0(R7)            CONVERT NUMBER
         LA    R7,12(R7)           INCREMENT FIELD POINTER
         BR    R14                 RETURN
         EJECT
**--> INSUB: REFRFC     TEST ECRFLAG AND PRINT NEEDED INFOR + + + + + +
*+       ENTERED BEFORE USER PROGRAM EXECUTION (AND POSSIBLY AFTER,   +
*+       IF IT ABENDED), TO PRINT STATEMENT/AND/OR REGISTERS.         +
*+       ENTRY CONDITIONS                                             +
*+  R9 = RETURN @ TO CALLING CODE.                                    +
*+  R10= @ ECONTROL                                                   +
*+       EXIT CONDITIONS                                              +
*+  R7,R8,R14,R15  MAY BE CHANGED.                                    +
*+       MESSAGES AR051, AR052, AND/OR AR054 MAY BE PRINTED.          +
*+       MAY CALL INSUBS  REREGS,REXCON3,REXPRINT.                    +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
*              TEST FOR CARDIMAGE PRINTING AND DO IT IF NEEDED.
*              **NOTE** REQUIRES AVRSBPT=0 IF NO CARD YET PROCESSED.
REFRFC   TM    REFRFLG1,ECR$CARD   DOES HE WANT CARDIMAGE
         BZ    REFRFZ01            NO, SO SKIP ENTIRELY
         L     R8,AVRSBPT          GET @ RSBLOCK, IF ANY
         LTR   R8,R8               =0 IF THERE ISN'T ANY CARD YET
         BZ    REFRFZ01            NO CARDIMAGE, CAN'T PRINT-BRANCH
         USING RSBLOCK,R8          NOTE POINTER TO RSBLOCK
         SPACE 1
         MVC   REZ051EN,RECSYMB    MOVE ENTRY NAME INTO MESSAGE
         SR    R7,R7               CLEAR FOR INSERTION
         IC    R7,RSBLENG          GET LENGTH-1 OF ENTRIE BLOCK
         SH    R7,=AL2(RSB$L)      - LENGTH BEFORE CARDIMAGE STARTS
         LA    R15,RSOL1-1         LENGTH-1 OF SINGLE CARD (MAX ALLWD)
         CR    R7,R15              WAS ACTUAL L-1 > MAX
         BNH   *+6                 NO, SKIP, USE ACTUAL L-1
         LR    R7,R15              YES, USE JUST 1 CARD OF SEVERAL
         SPACE 1
         MVC   REZ051CD,AWBLANK    BLANK PUT THE CARDIMAGE
         STC   R7,*+5              STORE LENGTH-1 INTO NEXT MVC
         MVC   REZ051CD($),RSBSOURC         MOVE VARIABLE SIZE CARD OVR
REFRFX01 LA    R7,RSBSOURC         PUT @ IN REG FOR CONVERSION
         DROP  R8                  DON'T NEED RSBLOCK USING ANY MORE
         LA    R8,REZ051AD         SHOW @ WHERE CONVERTED VALUE GOES
         BAL   R14,REXCON3         CALL CONVERT ROUTINE
         REPRNT REZAR051,REZ051L   PRINT CARDIMAGE, MESSAGE
REFRFZ01 EQU   *                   BRANCH LABEL, PREVIOUS CODE SKIPPED
         EJECT
*              TEST FOR INITIAL REGISTER VALUE PRINTING.
         MVC   REZ05XEN,RECSYMB    MOVE ENTRY NAME NOW. CAN USE # TIMES
         TM    REFRFLG1,ECR$REGA   DOES HE WANT INPUT REGISTERS
         BZ    REFRFZ02            NO, SO DON'T DO IT, BRANCH
         SPACE 1
         MVC   REZ05XMS,REZ05ENT   MV ENTRY TO MESSAGE IN
         MVI   REZ05XN,C'2'        MAKE MESSAGE ***AR052
         LA    R7,REGSAVA          SHOW @ BLOCK OF 5 ORIGINAL REGS
         BAL   R14,REREGS          CALL REGISTER CONVERT AND PRINT CODE
REFRFZ02 EQU   *                   BRANCH LABEL FOR SKIP PREVIOUS CODE
         SPACE 1
*              TEST FOR PRINTING OF REGS RETURNED BY REAL PROGRAM.
         MVC   REZ05XMS,REZ05EXT   PUT  'EXIT FROM' IN NOW
         TM    REFRFLG1,ECR$REGB   DOES HE WANT RETURNED VALUES
         BCR   Z,R9                NO RETURN TO CALLER
         SPACE 1
         MVI   REZ05XN,C'4'        MESSAGE IS ***AR054
         LA    R7,REGSAVB          SHOW @ 5 REGISTERS
         BAL   R14,REREGS          CALL REG CONVERT AND PRINT
         BR    R9                  RETURN TO CALLER
         EJECT
**--> INSUB: REGCRARE   USING RERGEFLG, FLAG AND PRINT REG MSG  + + + +
*+       **NOTE** SEE SECTION RGENTS FOR RGE-- FLAGS, AS FOLLOWING    +
*+       CODE MAY NOT BE OBVIOUS WITHOUT THEM.                        +
*+       ENTRY CONDITIONS                                             +
*+  R9 = RETURN @ TO CALLING CODE                                     +
*+  RERGEFLG IS NONZERO, I.E. AT LEAST 1 ERROR EXISTS.                +
*+       EXIT CONDITIONS                                              +
*+  REZAR059 MESSAGE IS COMPLETED AND PRINTED.                        +
REGCRARE IC    R0,RERGEFLG         GET THE FLAG, WITHS BITS POSS IN 3-7
         SLL   R0,32-5             SHIFT SO 5 BITS AT LEFT END OF REG
         LA    R1,REZ059RG         @ 1ST SLOT FOR FLAGGING
         SPACE 1
REFRAREF ALR   R0,R0               SET CC BY 1ST BIT, REST OF REG
         BC    Z+M,*+10            SKIP IF 1ST BIT=0, NOT ERROR
         MVC   0(8,R1),=8C'$'      FLAG THIS REG
         LA    R1,8+8(R1)          INCREMENT POINTER TO NEXT AREA
         BC    M+O,REFRAREF        LOOP BACK IF ANY MORE TO DO
         SPACE 1
         REPRNT REZAR059,REZ059L   PRINT ERROR FLAG LINE
         BR    R9                  RETURN TO CALLER
         SPACE 4
**--> INSUB: REGC1213   CHECK USER REGS 12-13,FLAG RERGEFLG + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R14= RETURN @ TO CALLING CODE                                     +
*+  REZAR059MS  IS ASSUMED TO BE BLANKED OUT                          +
*+       EXIT CONDITIONS                                              +
*+  RERGEFLG   MAY BE FLAGGED WITH RGE12 OR RGE13 OR BOTH             +
*+  REZ059MS   MAY CONTAIN REGISTER FLAGS  R12  OR R13                +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REGC1213 C     RAT,ECREG12         DID HE LEAVE R12 ALONE
         BE    *+14                YES, SKIP
         OI    RERGEFLG,RGE12      SHOW R12 IN ERROR
         MVC   REZ05912,=C'R12'    SHOW ERROR MESSAGE
         SPACE 1
         CLC   ECREG13,ECSAVE1     DID HE SAVE SA PTR OK
         BCR   E,R14               YES, OK, RETURN
         OI    RERGEFLG,RGE13      NO, MODIFIED R13 ERROR
         MVC   REZ05913,=C'R13'    SHOW ERROR MESSAGE
         BR    R14                 RETURN TO CALLER
         EJECT
*+--> INSUB: REREAL     REPLACE REAL ADCONS IN VWXTABL IF NOT THERE.  +
*+       ENTRY CONDITIONS                                             +
*+  R11= @ AJOBCON JOB CONTROL TABLE.                                 +
*+  R12(RAT)= ADDRESS OF VWXTABL CSECT (FOR DSECT AVWXTABL)           +
*+  R14= RETURN ADDRESS TO CALLING CODE IN REMONI                     +
*+       EXIT CONDITIONS                                              +
*+  ALL ADCONS IN VWXTABL ARE CORRECT, REFLAGS IS MARKED UNMODIFIED.  +
*+  AJOSTEP IS FLAGGED TO SHOW NOT IN EXECUTION PHASE FOR SURE.       +
*+       USES REGS: R0,R1,R2,R15                                      +
*+       USES  DSECTS: AVWXTABL,RECORBLK                              +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
REREAL   EQU   *                   ENTRY FOR RESTORATION
         NI    AJOSTEP,255-AJOSEXEC         REMOVE INTERP FLAG FOR SURE
         TM    REFLAGS,READMOD     HAVE ADCONS BEEN MODIFIED
         BCR   Z,R14               NO,JUST RETURN TO CALLER
*              INITIALIZE FOR LOOP TO RESTORE ADCONS.
         LH    R0,RECORNUM         GET # ENTRIES IN RECORRAD
         LA    R1,RECORRAD         GET @ 1ST ENTRY IN RECORRAD
         USING RECORBLK,R1         NOTE DSECT POINTER
         DROP  R5                  ZAP NORMAL USING SO WE CAN USE R1
         SPACE 1
*              LOOP, RESTORING ADCONS FROM RECORRAD BACK TO VWXTABL.
REREALA  LH    R2,RECAXAD          GET ADCON OFFSET VALUE
         L     R15,RECADRE         GET ADCON FROM TABLE
         ST    R15,AX$BASE(R2)     STORE ADCON BACK IN ORIGINAL LOCAT
         LA    R1,REC$LEN(R1)      BUMP DSECT POINTER TO NEXT ONE
         BCT   R0,REREALA          LOOP ON # ENTRIES IN RECORRAD TABLE
         SPACE 1
         NI    REFLAGS,255-READMOD SHOW VWXTABL NOW IN UNMODIFIED STATE
         BR    R14                 RETURN TO CALLING SECTION
         DROP  R1                  KILL USING
         USING RECORBLK,R5         RESORE NORMAL USING FOR REST OF INSU
         EJECT
**--> INSUB: REREGS     FORMAT PARAMETER REGS AND PRINT THEM  + + + + +
*+       CONVERTS BLOCK OF 5 REGISTERS TO HEXADECIMAL, PLACES THEM    +
*+       IN LOCATIONS IN MESSAGE AREA REZAR05X, AND PRINTS MESSAGE.   +
*+       ENTRY CONDITIONS                                             +
*+  R7 = @ 5-WORD BLOCK OF REGISTERS TO BE PRINTED                    +
*+  R14= RETURN @ TO CALLING CODE                                     +
*+       EXIT CONDITIONS                                              +
*+  R7 = @ REZAR05X MESSAGE, WITH REGS FILLED IN, USED TO PRINT IT.   +
*+  R8 = LENGTH OF REZAR05X MESSAGE AREA, FOR PRINTING ALSO.          +
*+  R15  IS USED AS WORK REGISTER AND MODIFIED                        +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REREGSRA LA    R7,ECREGRA          @ 5 REGS IN ECONTROL BLOCK
         SPACE 1
REREGS   LA    R15,5               LOOP COUNTER = # REGS TO BE DONE
         LA    R8,REZ05XRG         INIT TO @ FIRST SLOT FOR HEX REG
         SPACE 1
REREGSA  UNPK  0(9,R8),0(5,R7)     UNPK 1 REGISTER VALUE, EXTRA BYTE
         TR    0(8,R8),AWTHEX3     TRANSLATE PROPERLY
         MVI   8(R8),C' '          ADD BLANK AFTERWARD
         LA    R7,4(R7)            ADVANCE REG PTR TO NEXT REGISTER
         LA    R8,8+8(R8)          ADVANCE HEX PTR TO NEXT SLOT
         BCT   R15,REREGSA         LOOP FOR 5 REGS TO BE DONE
         SPACE 1
         LA    R7,REZAR05X         SHOW @ MESSAGE AREA
         LA    R8,REZ05XL          SHOW LENGTH
         B     REXPRINT            BRANCH TO PRINT ROUTINE
         EJECT
**--> INSUB: REXCON3    CONVERT 3 BYTES OF REGISTER R7 TO HEX.  + + + +
*+       ENTRY CONDITIONS                                             +
*+  R7 = VALUE TO BE CONVERTED ( IN 3 LOW-ORDER BYTES )               +
*+  R8 = ADDRESS OF 7 BYTE AREA FOR FIELD TO BE PLACED (WITH TRL ' ') +
*+  RAT(R12)= ADDRESS OV VWXTABL CSECT, NEEDED FOR TRANSLATE TABL     +
*+  R14= RETURN @ TO CALLING SECTION IN REMONI                        +
*+       USES  DSECTS: AVWXTABL                                       +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REXCON3  ST    R7,REXFWORK         SAVE THE WORD FOR UNPK
         UNPK  0(7,R8),REXFWORK+1(4)        UNPK WITH TRAILING ' '
         TR    0(6,R8),AWTHEX3     TRANSLATE TO PRINTABLE HEX
         BR    R14                 RETURN TO CALLER
         SPACE 4
**--> INSUB: REXPRINT   PRINT MESSAGE + + + + + + + + + + + + + + + + +
*+       PRINT MESSAGE AND FLAG REFLAGS WITH REFPRT TO SHOW PRINTED.  +
*+       ENTRY CONDITIONS                                             +
*+  R7 = ADDRESS OF MESSAGE TO BE PRINTED                             +
*+  R8 = LENGTH OF MESSAGE TO BE PRINTED                              +
*+  R14= RETURN ADDRESS TO CALLING SECTION OF REMONI                  +
*++ + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
REXPRINT $PRNT 0(R7),(R8)          PRINT MESSAGE
         OI    REFLAGS,REFPRT      SHOW SOMETHING PRTED DURING REFAKE
         BR    R14                 RETURN TO CALLING CODE
         TITLE 'REMONI: INSUB RGENTS: PARAMETER REGISTER CHECKING'
**--> INSUB: RGENTS     CHECK USER VALUES IN PARAMETER REGISTERS+ + + +
*+       THIS CODE CHECKS THE VALUES RETUNRED IN USER REGISTERS RA-RE +
*+  AGAINST THE VALUES RETURNED BY THE REAL ASSIST ROUTINE.  THE      +
*+  BYTE FLAG RERGEFLG IS SET ACCORDINGLY, FOR ANY OF THE REGISTERS   +
*+  WHICH MAY HAVE INCORRECT VALUES.  NOTE THAT THE REGISTERS CAN'T   +
*+  JUST BE COMPARED DIRECTLY, SINCE SOME REGISTERS MAY BE IGNORED,   +
*+  DEPENDING ON THE CONTENTS OF OTHERS (FOR INSTANCE, IF RB HAS AN   +
*+  ERROR CODE, RA AND RC ARE INDETERMINATE FOR MANY ENTRIES.)        +
*+       ENTRY CONDITIONS                                             +
*+  R5 = @ RECORBLK ELEMENT FOR THE ENTRYPOINT CALLED.                +
*+  R6,R13 = FIRST AND SECOND BASE REGISTERS FOR REMONI(REFAKE).      +
*+  R10= @ ECONTROL BLOCK (WHICH CONTAINS USER RETURN REGS)           +
*+  R12(RAT) = @ AVWXTABL CONTROL BLOCK                               +
*+  R14= RETURN @ TO CALLING SECTION OF REMONI.                       +
*+  R15= OFFSET FROM RG$BASE TO CODE FOR CHECKING ENTRYPOINT CALLED.  +
*+             = 0 IF NO CHECKS ARE REQUIRED.                         +
*+       EXIT CONDITIONS                                              +
*+  R5,R6,R10,R11,R12,R13,R14,R15  ARE PRESERVED ACROSS THIS CODE.    +
*+  RERGEFLG   CONTAINS BITS SHOWING ERROR FLAGS, REGS RA-RE.         +
*+       NAMES: RG------                                              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 2
* * * * * * * * RGENTS  REGISTER ALLOCATION * * * * * * * * * * * * * *
*   R0 = WORK REGISTER                                                *
*   R1 = LINK REGISTER FOR INTERNAL SUBROUTINES (INTERNAL TO RGENTS)  *
*   R2,R3,R4 (RGRA,RGRB,RGRC) HAVE REAL ROUTINES RETURN VALUES.       *
*  R7,R8,R9 (RA,RB,RC) HAVE USER RETURN VALUES OF THESE REGS.         *
*              (NOTE MOST PROGS RETURN VALUES IN NOR MORE THAN THESE. *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
*              LOCAL REGISTER EQUATES FOR RGENTS.  THESE ARE USED FOR
*              EASE OF PROGRAMMING, AND MAY BE READ AS: RGRA:
*              REGISTER(GOOD) VALUE OF RA.
RGRA     EQU   R2                  GOOD VALUE OF RETURNED RA
RGRB     EQU   R3                  GOOD VALUE OF RETURNED RB
RGRC     EQU   R4                  GOOD VALUE OF RETURNED RC
         SPACE 1
*              ERROR EQUS USED IN USER-RETURN REGISTER CHECKING.
RGERE    EQU   B'00000001'         (RERGEFLG)- RE FOUND IN ERROR
RGERD    EQU   B'00000010'         (RERGEFLG)- RD FOUND IN ERROR
RGERC    EQU   B'00000100'         (RERGEFLG)- RC FOUND IN ERROR
RGERB    EQU   B'00001000'         (RERGEFLG)- RB FOUND IN ERROR
RGERA    EQU   B'00010000'         (RERGEFLG)- RA FOUND IN ERROR
RGE13    EQU   B'00100000'         (RERGEFLG)- R13 MODFIED
RGE12    EQU   B'01000000'         (RERGEFLG)- R12 MODIFIED
RGE06    EQU   B'10000000'         (RERGEFLG)- >=1 OF R0-R6 MODIFIED
         SPACE 1
RGENTS   EQU   *                   ENTRY FOR CHECKING CODE
         LM    RGRA,RGRC,REGSAVB   GET THE CORRECT VALUES RETURNED
         LM    RA,RC,ECREGRA       GET THE USER'S REGS
         B     RG$BASE(R15)        BRANCH TO CORRECT CODE
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INDIVIDUAL ROUTINE REGISTER CHECKING CODE              *
*        THE OFFSET VALUES STORED IN RFSYMS WERE CALCULATED RELATIVE  *
*        TO LABEL RG$BASE, WITH AN OFFSET OF 0 MEANING THAT NO        *
*        REGISTER CHECKING IS REQUIRED.  THE ENTRY LABELS IN THIS     *
*        SECTION ARE ALL OF THE FORM  'RG' FOLLOWED BY THE NAME OF    *
*        THE DESIRED ENTRY POINT.  NOTE THAT MANY OF THEM ARE EQU'D   *
*        TOGETHER AND USE EXACTLY THE SAME CODE FOR CHECKING.         *
*              THE ENTRY LABELS ARE IN ORDER FIRST BY WHETHER THEY    *
*        MAY CALL OTHER MODULES OR NOT, AND THEN ALPHABETICALLY.      *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
RG$BASE  EQU   *                   BASE LABEL FOR OFFSETS
         BR    R14                 RETURN, NO CHECKING
         SPACE 2
RGBRUSIN EQU   RG$BASE             NO CHECKING
         SPACE 1
RGBRINIT EQU   RG$BASE             NO CHECKING
         SPACE 1
RGBRDROP EQU   *                   RB AND GRB BOTH =0 OR =0
         LTR   RGRB,RGRB           WAS REAL RETURN CODE 0
         BNZ   RGBR10              NO, BRANCH
         LTR   RB,RB               WAS USER RETURN CODE ALSO ZERO
         BCR   Z,R14               YES, NO MORE, QUIT
         B     RGRBERR             RGRB=0, RB=08 ERROR
         SPACE 1
RGBRDISP EQU   *                   GRB=0==>RB=0 AND RA=GRA.
*                                  GRB=0 ==> RB=0
         LTR   RGRB,RGRB           WAS REAL RB =0
         BNZ   RGBR10              =0, GO CHECK USER RB
         LTR   RB,RB               RB MUST =0 ALSO
         BNZ   RGRBERR             IT DOESN'T, SO WORNG
         CR    RA,RGRA             RB=GRB=0, SO CHECK RA TOO
         BCR   E,R14               SAME, OK, RETURN
         B     RGRAERR             NO, ERRO, GO FLAG IT
RGBR10   LTR   RB,RB               WAS USER RB ALSO NOT ZERO
         BCR   NZ,R14              YES, OK, QUIT
         B     RGRBERR             NO, RGRB=0, RB=0, ERROR
         SPACE 2
RGCBCON1 EQU   *                   GRB=$ERINVCN==> RB=$ERINVCN, RA OK
*                                  GRB=0 ==> RA=GRA, RC=GRC
         CR    RB,RGRB             ARE THEY SAME
         BNE   RGRBERR             NO, GO FLAG, DON'T DO MORE
         LTR   RGRB,RGRB           WAS CONSTNAT GOOD
         BZ    RGCB10              YES, GO CONTINUE CHECK
         BAL   R1,RGRAADDR         BAD CONSTANT, BUT CHECK SCAN PTR
         BR    R14                 IF RETURNED HERE, OK
RGCB10   CR    RC,RGRC             SAME VALUE OF RC
         BE    RGCB20              YES, SKIP, OK
         OI    RERGEFLG,RGERC      NO, ERROR, FLAG IT
RGCB20   CR    RA,RGRA             WAS RA SAME
         BNE   RGRAERR             NO, ERROR, GO FLAG IT
         BR    R14                 RETURN, OK
         EJECT
RGCBCON2 EQU   *                   RA=GRA. CODE AT @RC = CODE @GRC.
*                                  LENGTH-1 FOR CLC FROM ORIG. RB
         CR    RA,RGRA             MAKE SURE SAME SCAN PTR
         BE    *+8                 SKIP IF OK
         OI    RERGEFLG,RGERA      FLAG SCAN PTR ERR  7
         BAL   R1,RGRCADDR         MAKE SURE RC HAS OK @, SO DON'T 0C5
         L     RB,REGSAVA+4        GET ORIGINAL INPUT VALUE OF RB
         EX    RB,RGCBCLC          SUPPY LENGTH-1 TO THE CLC
         BCR   E,R14               SAME, SO OK, RETURN
         B     RGRCERR             BAD, GO FLAG IT
RGCBCLC  CLC   0($,RC),0(RGRC)     COMPARE VALUE, EX SUPPLIES LENGTH
         SPACE 2
RGCCCON1 EQU   RGCBCON1            SAME CODE AS ABOVE
         SPACE 1
RGCCCON2 EQU   RGCBCON2            SAME CODE AS ABOVE
         SPACE 2
RGCDECN1 EQU   *                   RB=GRB. GRB=0==> RA=GRA.
         LR    RC,RGRC             DUPLICATE VALUE SO CHECK OK
         B     RGCBCON1            BRANCH BACK TO USE SAME CODE
         SPACE 1
RGCDECN2 EQU   *                   RB=GRB. OTHERWISE, SAME AS CBCON2
         CR    RB,RGRB             WAS IT SAME
         BE    RGCBCON2            YES  SO GO CONTIUE CHECK
         B     RGRBERR             NO, GO FLAG AS ERROR
         SPACE 2
RGCFHCN1 EQU   RGCDECN1            SAME AS DE CONSTANTS
         SPACE 1
RGCFHCN2 EQU   RGCDECN2            SAME AS DE CONSTANTS
         SPACE 2
RGCPCON1 EQU   RGCBCON1            SAME AS ABOVE
         SPACE 1
RGCPCON2 EQU   RGCBCON2            SAME AS ABOVE
         SPACE 2
RGCXCON1 EQU   RGCBCON1            SAME CODE AS ABOVE
         SPACE 1
RGCXCON2 EQU   RGCBCON2            SAME CODE AS ABOVE
         SPACE 2
RGCZCON1 EQU   RGCBCON1            SAME CODE AS ABOVE
         SPACE 1
RGCZCON2 EQU   RGCBCON2            SAME CODE AS ABOVE
         EJECT
RGOPINIT EQU   RG$BASE             NO CHECKING REQUIRED
         SPACE 1
RGOPFIND EQU   *                   RA=GRA. RG=GRB. RGRB=0 ==> RC OK
         CR    RA,RGRA             IS IT OK
         BE    *+8                 YES, SKIP
         OI    RERGEFLG,RGERA      NO, FLAG RA ERROR
         CR    RB,RGRB             WAS RETURN CODE OK
         BNE   RGRBERR             NO, GO FLAG IT AND QUIT
         LTR   RGRB,RGRB           WSS RETURN CODE ZERO
         BCR   NZ,R14              NO, QUIT NOW, OK
         BAL   R1,RGRCADDR         MAKE SURE OPCODTB PTR IN LEGAL AREA
         S     RA,REGSAVA          GET LENGTH OF OPCODE
         BCTR  RA,0                GET LENGTH-1
         USING OPCODTB,RC          NOTE PTR THERE
         EX    RA,RGOPCLC          IS SYMBOL THE SAME
         BCR   E,R14               YES, OK RETURN
         B     RGRCERR             NO, GO FLAG ERROR
RGOPCLC  CLC   OPCMNEM($),OPCMNEM-OPCODTB(RGRC)       COMPARE OPCODES
         DROP  RC                  REMOVE OPCODTB USING
         BR    R14                 RETURN , OK
         SPACE 2
RGSDBCDX EQU   *                   RB=GRB. GRB=0 OR -4 ==> RA=GRA,RC=
         CR    RB,RGRB             SAME
         BNE   RGRBERR             NO, QUIT NOW, ERROR
         LTR   RGRB,RGRB           WAS RETURN CODE 0 OR -4
         BNP   RGCB10              YES, SO GO TO COMMON CHECKING CODE
         BAL   R1,RGRAADDR         CHECK SCAN PTR FOR LEGALITY
         BR    R14                 RETURN, OK
         SPACE 1
RGSDBTRM EQU   RGSDBCDX            SAME CODE
         SPACE 1
RGSDCTRM EQU   RGSDBCDX            SAME CODE AS ABOVE
         SPACE 1
RGSDDTRM EQU   RGSDBCDX            SAME CODE AS ABOVE
         SPACE 1
RGSDXTRM EQU   RGSDBCDX            SAME CODE AS ABOVE
         EJECT
RGSYINT1 EQU   RG$BASE             NO CHECKING
         SPACE 1
RGSYENT1 EQU   *                   RB=GRB. (RA==> SYMBOL)=(GRA=>SYM)
         CR    RB,RGRB             SAME OR NOT
         BE    RGSY10              YES, OK
         OI    RERGEFLG,RGERB      NO, ERROR
         B     RGSY10              GO CONTINUE CHECKING
         SPACE 1
RGSYFIND EQU   *                   RG=GRB. GRB=0 ==> SYMBOLS SAME
         CR    RB,RGRB             RETURN CODE SAME
         BNE   RGRBERR             NO, ERROR RIGHT OFF
         LTR   RGRB,RGRB           WAS SYMBOL IN TABLE(RGRB=4)
         BCR   NZ,R14              NO, SO DON'T LOOK, RETURN
RGSY10   C     RA,ECFADL           BEGIN CHECK FOR WITHIN USER PROG
         BL    RGRAERR             RA TOO LOW-ERROR
         C     RA,ECFADHC          COMPARE WITH HIGH CHECK LIMIT
         BH    RGRAERR             TOO HIGH-BRANCH-ERROR
         L     RB,REGSAVA+4        GET ORIGINAL LENGTH OF SYMBOL 1-8.
         BCTR  RB,0                OBTAIN LENGTH-1 FOR EXECUTE MVC
         USING SYMSECT,RA          NOTE SYMBOL TABLE DSECT
         EX    RB,RGSYCLC          COMPARE THE SYMBOLS
         BNE   RGRAERR             NOT SAME SYMBOL, ERROR
         BR    R14                 OK, RETURN
RGSYCLC  CLC   SYMBOL($),SYMBOL-SYMSECT(RGRA)         COMPARE SYMBOLS
         DROP  RA                  REMOVE SYMSECT USING
         SPACE 1
RGSYEND2 EQU   RG$BASE             NO CHECKING
         SPACE 2
         AIF   (&$REPL LT 2).RGNERE2 SKIP IF REPL ENTRIES MAY NOT CALL
*                                     ASSIST SUBROUTINES
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              CHECKING CODE - ENTRIES WHICH MAY CALL OTHERS.         *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
RGEVALUT EQU   *                   GRB=0 ==> RB=0. GRB=0 ==> RA=GRA.
*                                  GRB=0 ==> RC=GRC, RD=GRD, RE=GRE.
         LTR   RGRB,RGRB           WAS REAL RETURN CODE ZERO
         BZ    RGEV10              YES, SKIP
         LTR   RB,RB               WAS USER CODE NO TZERO
         BZ    RGRBERR             DIDN'T MATCH, ERROR BRANCH
         BAL   R1,RGRAADDR         ERROR IN EXP-GO CHECK FOR OK SCAN PT
         BR    R14                 RETURN, SCAN PTR OK
RGEV10   LTR   RB,RB               WAS FAKE USER RB ZERO ALSO
         BNZ   RGRBERR             NO, ERROR, QUIT
         LM    R0,R1,ECREGRA+12    GET USER REGS RD-RE
         C     R0,REGSAVB+12       COMPARE WITH REAL RD
         BE    *+8                 SKIP IF OK
         OI    RERGEFLG,RGERD      FLAG RD WRONG
         C     R1,REGSAVB+16       COMPARE WITH REAL RE RETURNED
         BE    RGCB10              OK, GO CONTINUE CHK FOR RC,RA
         OI    RERGEFLG,RGERE      FLAG RE IN ERROR
         B     RGCB10              GO TO CHECK RC,RA
.RGNERE2 ANOP
         EJECT
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              MISC. CHECKING AND EXIT CODE SECTIONS.                 *
*        THESE SECTIONS OF CODE CAN BE CALLED OR BRANCHED TO BY ANY   *
*        OF THE INDIVIDUAL SECTIONS ABOVE.                            *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
**--> INSUB: RGRAADDR   CHECK LEGITAMACY OF SCAN PTR RA + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R1 = RETURN @ OF CALLING PROGRAM CODE.                            +
*+  RA = VALUE OF SCAN POINTER TO BE CHECKED.                         +
*+  R14= RETURN @ TO BE TAKEN IF RA IS IN ERROR.                      +
*+       EXIT CONDITIONS                                              +
*+  RB,RC ARE DESTROYED.  MUST BE RELOADED IF CALLER NEEDS THEM.      +
*+  RERGEFLG IS MARKED WITH RGERA IF RA IS INCORRECT.                 +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
RGRAADDR C     RA,REGSAVA          COMPARE TO ORIGINAL SCAN PTR
         BL    RGRAERR             ROUTINE BACKED UP SCAN PTR-ERROR
         LA    R0,200              MAXIMUM POSSIBLE DIF IN SCAN PTRS
         A     R0,REGSAVA          ADD ORIG RA TO MAX DIFFERENCE
         CR    RA,R0               CHECK GAINST THIS LIMIT
         BCR   L,R1                YES, OK, NO ERROR
         SPACE 1
*              EXIT POINT - FLAG RA IN ERROR, QUIT CHECKING.
RGRAERR  OI    RERGEFLG,RGERA      SHOW RA WRONG
         BR    R14                 RETURN, QUIT CHECKING
         SPACE 2
*              EXIT POINT - FLAG RB IN ERROR, QUIT CHECKING.
RGRBERR  OI    RERGEFLG,RGERB      FLAG RB IN ERROR
         BR    R14                 RETURN, NO MORE CHECKING
         SPACE 2
**--> INSUB: RGRCADDR   CHECK RC FOR @ INSIDE USER PROG.+ + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R1 = RETURN @ TO CALLING CODE IN RGENTS                           +
*+  RC = VALUE TO BE CHECKED                                          +
*+  R14= RETURN @ TO BE TAKEN IF RC HAS INCORRECT VALUE.              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
RGRCADDR C     RC,ECFADL           MUST BE >= LOWER FAKE LIMIT
         BL    RGRCERR             IT WASNT, SO ERROR-BRANCH
         C     RC,ECFADHC          MUST BE <= HIGH LIMIT FOR CHECKING
         BCR   NH,R1               NOT HIGH, SO OK, RETURN TO CALLER
         SPACE 1
*              EXIT POINT - FLAG RC IN ERROR, QUIT CHECKING
RGRCERR  OI    RERGEFLG,RGRC       FLAG ERROR IN RC
         BR    R14                 RETURN TO REGULAR PROG. QUIT CHECK
         AIF   (&$REPL LT 2).RHNREP         SKIP IF NO REPL CALLS
         TITLE 'REMONI - RHENTS SECTION - CHECK CALLING VALUES'
**--> INSUB: RHENTS     CHECK PARM REGS PASSED TO CALLED PROGRAM+ + + +
*+       RHENTS IS CALLED ONLY WHEN A CALL TO A REAL ASSIST MODULE    +
*+  IS MADE BY A REPLACABLE MODULE PERMITTED TO CALL OTHERS.  ITS     +
*+  PURPOSE IS TO PROTECT ASSIST FROM ABENDS CAUSED BY IMPROPER VALUES+
*+  BEING PASSED TO REAL ASSIST ROUTINES, WHICH EXECUTE DIRECTLY.     +
*+       ENTRY CONDITIONS                                             +
*+  R14= RETURN @ TO CALLLING CODE IN MAIN SECTION OF REFAKE.         +
*+  R15= OFFSET @ FROM RH$BASE TO INDIVIDUAL CODE CHECKING SECTION.   +
*+  RERGEFLG   BITS FOR RGERA-RGERE   ARE ZEROED.                     +
*+       EXIT CONDITIONS                                              +
*+  R0,R1,RA,RB,RC      MAY BE MODIFED.                               +
*+  R4-R6,R10-R15  ARE PRESERVED ACROSS CALLS TO RHENTS.              +
*+  RERGEFLG  BITS ARE SET AS NEEDED.                                 +
*+       NAMES: RH------                                              +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
* * * * * * * * RHENTS REGISTER ALLOCATION  * * * * * * * * * * * * * *
*   R0 = WORK REGISTER                                                *
*   R1 = INTERNAL LINK REGISTER FOR CHECKING ROUTINES.                *
*   R2,R3      UNUSED AT PRESENT, MAY BE USED IF REQUIRED IN FUTURE.  *
*   RA,RB,RC   HOLD VALUES OF CORRESPONDING USER REGISTERS.           *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 1
RHENTS   EQU   *
         LM    RA,RC,ECREGRA       GET PARM REGS, MOST USUAL ONES
         B     RH$BASE(R15)        BRANCH TO RIGHT SECTION OF CODE
         SPACE 1
RH$BASE  EQU   *                   BASE LABEL FOR CALL CHECKING SECTS
         BR    R14                 IF COMES HERE, NO CHECKING
         SPACE 2
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
*              INDIVIDUAL ROUTINE REGISTER CHECKING CODE SECTIONS     *
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
         SPACE 2
RHSDBCDX EQU   *                   RA IN MACHINE REASONABLY
         BAL   R1,RHRAADDR         CALL CHECKING ROUTINE
         BR    R14                 RETURN
         SPACE 1
RHSDBTRM EQU   RHSDBCDX            SAME CODE
RHSDCTRM EQU   RHSDBCDX            SAME CODE
RHSDDTRM EQU   RHSDBCDX            SAME CODE
RHSDXTRM EQU   RHSDBCDX            SAME CODE
         SPACE 2
RHSYFIND EQU   *                   RA REASONBALE, 1<= RB <= 7
         BAL   R1,RHRAADDR         CHECK RA FOR REAONABLENESS
         C     RB,AWF1             TEST
         LTR   RB,RB               WAS RB<=0
         BNP   RHRBERR             YES, ILLEGAL-BRANCH
         C     RB,AWF7             WAS IT TOO BIG
         BCR   NH,R14              NO,OK,RETURN
RHRBERR  OI    RERGEFLG,RGERB      RB IN ERROR
         BR    R14                 RETURN
         EJECT
*              RHENTS INTERNAL SUBROUTINES                            *
         SPACE 2
**--> INSUB: RHRAADDR   CHECK RA FOR REASONABLE @ + + + + + + + + + + +
*+       ENTRY CONDITIONS                                             +
*+  R1 = RETURN @ TO CALLING CODE                                     +
*+  RA = VALUE TO BE CHECKED FOR LEGALITY.                            +
*+  + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + + +
         SPACE 1
RHRAADDR EQU   *
*              CHECK FOR @ IN USER PROGRAM.
         C     RA,ECFADL           LOWER LIMIT OF USER
         BL    RHRA2               NO, NOT IN USER PROG
         C     RA,ECFADHC          HIGH CHECKING LIMIT
         BCR   NH,R1               INSIDE USER, OK, RETURN
         SPACE 1
*              CHECK FOR IN AVWXTABL
RHRA2    EQU   *
         CR    RA,RAT              LOWER TAHN PTR
         BL    RHRA3               YES, NOT THERE EIEHRE
         LA    R0,AVWXEND-8        HIGHEST @ IN TABLE
         CR    RA,R0               COMPARE TO UPPER LIMIT POSSIBLE
         BCR   NH,R1               IN THERE, OK RETURN
         SPACE 1
*              CHECK FOR @ IN DYNAMIC AREA.
RHRA3    EQU   *
         C     RA,AJOTADL          LOWER THAN LOWEST
         BL    RHRA4               YES
         C     RA,AJOTADH          HIGHER THAN HIGHEST
         BCR   NH,R1               NO, SO OK, RETURN
         SPACE 1
RHRA4    EQU   *
RHRAERR  OI    RERGEFLG,RGERA      FLAG RA WORNG
         BR    R1                  RETURN TO CALLER
.RHNREP  ANOP
         LTORG
         DROP  R5,R10,R11,RAT,R13  REMOVE ALL USINGS
         TITLE 'RFSYMS - REPLACE TABLE CSECT - CSECT,ENTRY NAMES'
         PRINT GEN
**--> CSECT: RFSYSMS    TABLE OF CSECT-ENTRY NAMES-REPLACE  . . . . . .
*.             RFYSMS (SECT.1) HAS AN ELEMENT FOR EACH CSECT WHICH CAN.
*.       BE DYNAMMICALLY REPLACED BY A USER-WRITTEN ROUTINE. EACH     .
*.       ELEMENT CONTAINS THE NAME OF THE CSECT, THE NUMBER OF        .
*.       ENTRY POINTS IN IT, AND A LIST OF ENTRY POINT NAMES AND      .
*.       OFFSETS TO THEIR ADCONS IN AVWXTABL, SO THEY CAN BE CHANGED. .
*.             THE 2ND SECTION IS PRESENT IF &$REPL=2.  IT LISTS ALL  .
*.       ENTRYPOINTS WHICH CAN BE CALLED FROMA USER PROGRAM, WITH     .
*.       OFFSET @ PTRS TO THEIR ADCONS IN AVWXTABL, AND TO CODE IN    .
*.       SECTION RHENTS OF REMONI.  THIS CODE IS USED TO CHECK THE    .
*.       REGISTERS PASSED BY THE USER TO THE CALLED PROGRAM.          .
*.             THE 3RD SECTION IS ALSO PRESENT ONLY IF &$REPL=2. IT   .
*.       HAS LABELS OF THE FORM RI&CSECT, WITH &CSECT BEING ONE WHICH .
*.       NOT ONLY CAN BE REPLACED, BUT CAN ALSO CALL OTHER ROUTINES.  .
*.       EACH ELEMNT CONTAINS A HALFWORD WITH THE NUMBER OF DIFFERENT .
*.       SUBROUTINE ENTRIES WHICH THIS CSECT IS PERMITTED TO CALL,    .
*.       FOLOWED BY THAT # OFFSET VALUES TO THE ELEMENTS IN THE 2ND   .
*.       SECTION OF THOSE ENTRIES IT CAN CALL.  REMONI OBTAINS AN     .
*.       OFFSET FROM RFSYMS TO RI&CSECT FROM THE RFSYMBLK BELONGING   .
*.       TO THAT CSECT.  NOTE, IF A CSECT CAN CALL NO OTHER, THE      .
*.       VALUE SAVED IS = 0.                                          .
*.       NAMES: RF------                                              .
*.       NAMES: RI------           (IN SECTION 3, IF &$REPL=2)
*.       DSECT RFSYMBLK IS USED TO DESCRIBE EACH ENTRY IN SECTS.1&2.  .
*.       USES MACROS: $AL2,RFSGN                                      .
*.  . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
         SPACE 1
RFSYMS   CSECT
*        **NOTE** COMMENTED ENTRIES ARE NOT CURRENTLY AVAILABLE.
         RFSGN BROPS2,(BRINIT,BRUSIN,BRDROP,BRDISP)
*        RFSGN CACONS,(CACON1,CACON2),TYPE=1
         RFSGN CBCONS,(CBCON1,CBCON2)
         RFSGN CCCONS,(CCCON1,CCCON2)
         RFSGN CDECNS,(CDECN1,CDECN2)
         RFSGN CFHCNS,(CFHCN1,CFHCN2)
*        RFSGN CODTL1,CODTL1,TYPE=1
         RFSGN CPCONS,(CPCON1,CPCON2)
*        RFSGN CVCONS,(CVCON1,CVCON2),TYPE=1
         RFSGN CXCONS,(CXCON1,CXCON2)
         RFSGN CZCONS,(CZCON1,CZCON2)
         RFSGN EVALUT,EVALUT,TYPE=1
         RFSGN OPCOD1,(OPINIT,OPFIND)
*        RFSGN SCANRS,(SCANBL,SCANCO,SCANEQ),TYPE=1
         RFSGN SDTERM,(SDBCDX,SDBTRM,SDCTRM,SDDTRM,SDXTRM)
         RFSGN SYMOPS,(SYINT1,SYENT1,SYFIND,SYEND2)
RFSYMS$L EQU   *-RFSYMS            LENGTH OF SEARCH IN RFSYMS CSECT
         SPACE 1
         AIF   (&$REPL LT 2).RENREPA        SKIP IF NO SECTS 2 & 3
         SPACE 2
*              SECTION 2 - CALLABLE ENTRY POINT INFORMATION.
RFSCALLA DS    0H                  BEGINNING OF LIST
         RFSGN SDBCDX,TYPE=2
         RFSGN SDBTRM,TYPE=2
         RFSGN SDCTRM,TYPE=2
         RFSGN SDDTRM,TYPE=2
         RFSGN SDXTRM,TYPE=2
         RFSGN SYFIND,TYPE=2
RFSCALLZ EQU   *-RFS$LEN           END @ - LENGTH FOR BXLE LIMIT
         SPACE 2
*              SECTION 3 - OFFSETS TO CALLABLES FROM EACH REPLACABLE.
*              ALTHOUGH EVALUT IS ONLY ONE NOW, OTHERS COULD BE ADDED.
         SPACE 1
RIEVALUT DC    H'6'                EVALUT CAN CALL 6 ENTRIES IF IT WANT
         $AL2  RFSYMS,(RFSDBCDX,RFSDBTRM,RFSDCTRM,RFSDDTRM,RFSDXTRM,RFS#
               YFIND)              OFFSETS TO SECTION 2 BLOCKS ABOVE
         SPACE 2
         PRINT NOGEN               TURN OFF GENERATION IN REST  CPP
.RENREPA ANOP
.RENREPL ANOP
