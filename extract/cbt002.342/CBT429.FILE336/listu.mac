LISTU     SAVEX LV=WORKLEN
          SPACE 2
          USING WORKAREA,R13
          ST    R1,CPPLADDR          SAVE PARAMETER LIST ADDRESS
          EJECT
          SPACE 2
*  THIS PROGRAM RETURNS THE USERIDS OF ALL ACTIVE TSO USERS
*    PLUS COUNTS OF ACTIVE USERS AND USERS LOGGING ON.
*    USERIDS ARE LISTED ALPHABETICALLY ACROSS THE FULL
*    OUTPUT LINE FOR ANY TERMINAL.
          SPACE 4
          BAL   R2,INIT
          SPACE 1
LISTU3    NOP   LISTUX
          BAL   R2,GETUID         GET AN ACTIVE USERID
          CLC   UIDEXIST,YES      DOES THE LAST CONTROL BLOCK
*                                   POINT TO AN ACTIVE USERID?
          BNE   LISTU5            BRANCH ON NO
          BAL   R2,SORT           SORT WITH PREVIOUSLY RETRIEVED UIDS
          CLC   EOUSERS,YES       HAS LAST CONTROL BLOCK BEEN CHECKED?
          BNE   LISTU3            BRANCH ON NO
          SPACE 1
LISTU5    NOP   LISTUX
          BAL   R2,INITOUT
LISTU7    NOP   LISTUX
          CLC   USERCTR,BIN0      ARE THERE ANY ACTIVE TSO USERS?
          BE    LISTU8            BRANCH ON NO
          BAL   R2,GETSRTU        GET A SORTED USERID
          BAL   R2,PUTUSER        POSITION THE USERID FOR OUTPUT,
*                                   WRITE A FULL LINE
          CLC   LASTUSER,YES      IS THIS THE LAST SORTED USERID?
          BNE   LISTU7            BRANCH ON NO
LISTU8    NOP   LISTUX
          BAL   R2,PUTTOTL        WRITE TOTAL LINE
          BAL   R2,CLOSE
LISTUX    BR    R14
          EJECT
INIT      NOP   INITX
          MVC   EOUSERS,NO        LAST CONTROL BLOCK INDICATOR
          MVC   UIDEXIST,NO       ACTIVE USER INDICATOR
          MVC   TESTINDX,BIN0     INITIALIZE POINTER
          SPACE 1
*  INITIALIZE THE ORIGINAL SORT POINTERS
          XC    POINTERS(PTRLEN),POINTERS   ZERO THE POINTERS
          SPACE 1
          L     R3,16               -> CVT
          USING CVT,R3
          L     R4,CVTASVT          -> ASVT
          USING ASVT,R4
          L     R5,ASVTMAXU         ASID COUNTER
          LA    R6,ASVTFRST         -> FIRST ASID
          DROP  R3
          DROP  R4
          SPACE 1
          SR    R3,R3              TSO USERS COUNTER
          SR    R4,R4              TSO USERS LOGGING ON COUNTER
INITX     BR    R2
          EJECT
*  SEARCH FOR ACTIVE TSO USERS AND USERS LOGGING ON.
*    INCREMENT APPROPRIATE COUNTERS.
*    LEAVE THE ROUTINE WITH AN ACTIVE TSO USERID
*      OR WHEN ALL CONTROL BLOCKS HAVE BEEN SEARCHED.
          SPACE 4
GETUID    NOP   GETUIDX
          MVC   UIDEXIST,NO        WE DO NOT HAVE A TSO USER
          SPACE 1
          TM    0(R6),X'80'        UNUSED?
          BO    GETUID2            YES, GET NEXT
          SPACE 1
          L     R7,0(0,R6)         -> ASCB
          USING ASCB,R7
          L     R8,ASCBTSB         -> TSB
          LTR   R8,R8              TSO SESSION?
          BZ    GETUID2            BRANCH ON "NO"
          SPACE 1
          L     R9,ASCBJBNS        -> TSO USERID
          LTR   R9,R9              USER LOGGING ON?
          BNZ   GETUID6            BRANCH ON "NO"
          A     R4,BIN1            INCREMENT USER LOGGING ON COUNTER
          SPACE 1
GETUID2   NOP   GETUIDX
          A     R6,BIN4            ADVANCE TO NEXT ASID
          BCT   R5,GETUID          REDUCE TOTAL ASID COUNT,
*                                    BRANCH IF MORE ASIDS AVAILABLE
          B     GETUID8            BRANCH ON LAST ASID
          SPACE 1
GETUID6   NOP   GETUIDX
          MVC   USERSAVE,0(R9)     STORE TSO USERID
          MVC   UIDEXIST,YES       WE FOUND A TSO USER
          A     R3,BIN1            INCREMENT ACTIVE USERS COUNTER
          A     R6,BIN4            ADVANCE TO NEXT ASID
          BCT   R5,GETUIDX         REDUCE TOTAL ASID COUNT,
*                                    BRANCH IF MORE ASIDS AVAILABLE
          SPACE 1
GETUID8   NOP   GETUIDX
          MVC   EOUSERS,YES        NO MORE ASID'S,
*                                    END OF USERID SEARCH
          ST    R4,LOGONCTR        STORE USERS LOGGING ON COUNT
          ST    R3,USERCTR         STORE ACTIVE USERS COUNT
GETUIDX   BR    R2
          EJECT
          SPACE 2
*  PLACE A TSO USERID IN ALPHABETICAL SEQUENCE.
*    THERE ARE 30 POINTERS, ONE FOR EACH OF $, #, AND @,
*    ONE FOR EACH LETTER AND ONE MORE AT THE END.
*    A POINTER VALUE OF BIN ZERO INDICATES AN
*    EMPTY STACK.  OTHERWISE THE POINTER POINTS TO THE FIRST
*    ENTRY IN THE STACK.  A STACK ENTRY CONSISTS OF A POINTER
*    AND A PREVIOUSLY STORED USERID.  AN ENTRY POINTER VALUE
*    OF BIN ZERO INDICATES THE LAST ENTRY IN THE STACK.
*    OTHERWISE THE POINTER POINTS TO THE NEXT ENTRY.
          SPACE 4
SORT      NOP   SORTX
          LA    R7,POINTERS        ADDRESS OF FIRST POINTER
          SPACE 1
SORT1     NOP   SORTX
          MVC   TESTUID(1),USERSAVE  MOVE THE FIRST LETTER OF
*                                    THE USERID TO TEST
          TR    TESTUID,TABLE      TRANSLATE LETTER TO DISPLACEMENT
          A     R7,TESTINDX        POINT TO STACK
          USING LIST,R7
*  WE HAVE SELECTED A STACK
          SPACE 1
SORT3     NOP   SORTX
          CLC   NEXTPTR,BIN0      IS THIS AN EMPTY STACK OR
*                                   THE LAST ENTRY IN THIS STACK?
          BE    SORT5             BRANCH ON YES
          ST    R7,LOWPTR         STORE CURRENT POINTER
          L     R7,NEXTPTR        POINT THE CURRENT POINTER TO THE NEXT
*                                   ENTRY IN THE STACK
          CLC   USERID,USERSAVE   COMPARE THE STACK USERID TO THE
*                                   USERID BEING SORTED
          BL    SORT3             BRANCH IF THE STACK USERID IS LOW
          L     R7,LOWPTR         THE STACK USERID IS HIGH,
*                                   POINT CURRENT POINTER TO PREVIOUS
*                                   ENTRY IN STACK (BACK UP ONE ENTRY)
          SPACE 1
SORT5     NOP   SORTX
          GETMAIN  R,LV=LISTLEN   GET STORAGE TO ADD TO STACK
          SPACE 1
          USING NEWLIST,R1
*  PLACE NEW STORAGE INTO STACK
          MVC   NEWPTR,NEXTPTR    MOVE THE STACK NEXT ENTRY ADDRESS
*                                   TO THE NEXT ENTRY ADDRESS IN THE
*                                   NEW STORAGE
          ST    R1,NEXTPTR        STORE THE ADDRESS OF THE NEW STORAGE
*                                   IN THE STACK NEXT ENTRY ADDRESS
*  NOW THE NEW STORAGE IS PART OF THE STACK
          SPACE 1
          MVC   NEWUSER,USERSAVE  MOVE THE SORTED USERID INTO THE
*                                   NEW ENTRY IN THE STACK
          DROP  R1
          DROP  R7
SORTX     BR    R2
          EJECT
INITOUT   NOP   INITOUTX
          ST    R2,R2SAVE
*  GET TERMINAL LINESIZE
          GTSIZE
          ST    R1,DATALEN      STORE TERMINAL LINESIZE
          CLC   DATALEN,BIN8    COMPARE LINESIZE TO USERID LENGTH
          BNL   INITOUT2        BRANCH ON ADEQUATE LINESIZE
          MVC   DATALEN,BIN8    INCREASE LINESIZE TO USERID LENGTH
INITOUT2  NOP   INITOUTX
          L     R0,DATALEN LOAD TERMINAL LINESIZE
          GETMAIN  R,LV=(0)     GET STORAGE FOR TERMINAL OUTPUT
          ST    R1,DATAADDR     STORE ADDRESS OF OUTPUT LINE
          BAL   R2,CLEARLN      MOVE SPACES TO OUTPUT LINE
          SR    R8,R8
          L     R9,DATALEN      LOAD TERMINAL LINESIZE
          D     R8,BIN8         DIVIDE BY 7 (USERID) + 1 (SPACE)
          ST    R9,MAXUOUT      STORE MAXIMUM USERS PER OUTPUT LINE
          SR    R10,R10
          MVC   BLANK,BLANKS    BLANK 1 POSITION TO RIGHT OF USERID
          MVC   LASTUSER,NO     THIS IS NOT THE LAST USERID
          SR    R4,R4
          LA    R5,POINTERS     LOAD ADDRESS OF FIRST POINTER (STACK A)
          LA    R7,POINTERS      "      "    "    "      "       "   "
          L     R8,DATAADDR     LOAD ADDRESS OF OUTPUT LINE
          L     R2,R2SAVE
INITOUTX  BR    R2
          EJECT
          SPACE 2
*  GET A SORTED USERID FOR OUTPUT.  START WITH STACK A.
*    LOOK FOR AN ENTRY IN THE STACK.  IF THERE IS NO ENTRY,
*    MOVE TO THE NEXT STACK.  WHEN AN ENTRY IS FOUND, MOVE
*    THE USERID TO HOLD AND LEAVE THE ROUTINE.
*  NOW, EACH TIME THE ROUTINE IS ENTERED, THE SEARCH WILL
*    BEGIN AT THE ENTRY LOCATED ON THE PREVIOUS PASS.
          SPACE 4
GETSRTU   NOP   GETSRTUX
          CLC   0(4,R7),BIN0       IS STACK EMPTY OR HAS LAST ENTRY
*                                    IN STACK BEEN PROCESSED?
          BNE   GETSRTU3           BRANCH ON NO
          A     R5,BIN4            MOVE TO NEXT STACK
          LR    R7,R5
          B     GETSRTU
GETSRTU3  NOP   GETSRTUX
          L     R7,0(R7)           MOVE TO NEXT ENTRY IN STACK
          MVC   USEROUT1,4(R7)     MOVE USERID TO HOLD
          A     R4,BIN1            COUNT USERIDS OUTPUT
          C     R4,USERCTR         DO WE HAVE ALL SORTED USERIDS?
          BNE   GETSRTUX           BRANCH ON NO
          MVC   LASTUSER,YES       THIS IS THE LAST SORTED USERID
GETSRTUX  BR    R2
          EJECT
          SPACE 2
*  POSITION A USERID ON THE OUTPUT LINE.  WHEN THE LINE IS FULL
*    OR AFTER LAST USERID IS POSITIONED, BRANCH TO WRITE THE LINE.
          SPACE 4
PUTUSER   NOP   PUTUSERX
          ST    R2,R2SAVE
          A     R10,BIN1           INCREMENT OUTPUT LINE USER COUNTER
          C     R10,MAXUOUT        IS OUTPUT LINE FULL?
          BNH   PUTUSER3           BRANCH ON YES
          BAL   R2,WRITE           WRITE AN OUTPUT LINE
          BAL   R2,CLEARLN         CLEAR THE OUTPUT LINE
          L     R10,BIN1           REINITIALIZE COUNTER
          L     R8,DATAADDR        LOAD ADDRESS OF OUTPUT LINE
PUTUSER3  NOP   PUTUSERX
          MVC   0(8,R8),USEROUT    MOVE USERID TO OUTPUT
          A     R8,BIN8            POINT TO NEXT AVAILABLE POSITION'
*                                    ON THE OUTPUT LINE
          CLC   LASTUSER,NO        IS THIS THE LAST USERID FOR OUTPUT?
          BE    PUTUSER6           BRANCH ON NO
          BAL   R2,WRITE           WRITE THE LINE
PUTUSER6  NOP   PUTUSERX
          L     R2,R2SAVE
PUTUSERX  BR    R2
          EJECT
          SPACE 2
*  WRITE AN OUTPUT LINE
          SPACE 4
WRITE     NOP   SORTX
          L     R1,DATAADDR       LOAD OUTPUT LINE ADDRESS
          L     R3,DATALEN        LOAD OUTPUT LINE LENGTH
          L     R9,CPPLADDR       LOAD PARAMETER LIST ADDRESS
          UPUT  (1),(3),CPPL=(9),DATA
WRITEX    BR    R2
          EJECT
          SPACE 2
*  BLANK THE OUTPUT LINE.
          SPACE 4
CLEARLN   NOP   CLEARLNX
          L     R1,DATAADDR      LOAD OUTPUT LINE ADDRESS
          MVC   0(1,R1),BLANKS   BLANK FIRST BYTE OF OUTPUT LINE
          L     R9,DATALEN       LOAD OUTPUT LINE LENGTH
          S     R9,BIN2          SUBTRACT 1 FROM LENGTH
          EX    R9,CLEARLNZ      LOAD SPACES
CLEARLNX  BR    R2
          SPACE 4
CLEARLNZ  MVC   1(0,R1),0(R1)
          EJECT
          SPACE 2
*  SET UP TOTALS LINE.  BRANCH TO WRITE.
          SPACE 4
PUTTOTL   NOP   PUTTOTLX
          ST    R2,R2SAVE
          CLC   DATALEN,TMSGLEN  IS OUTPUT LINE LENGTH LONG
*                                  ENOUGH FOR TOTALS MESSAGE
          BH    PUTTOTL2         BRANCH ON YES
          MVC   DATALEN,TMSGLEN  STORE TOTALS LINE LENGTH
          L     R0,DATALEN       LOAD    "     "     "
          GETMAIN R,LV=(0)       GET STORAGE FOR TOTALS LINE
          SPACE 1
          ST    R1,DATAADDR      STORE ADDRESS OF NEW STORAGE
          SPACE 1
PUTTOTL2  NOP   PUTTOTLX
          BAL   R2,CLEARLN       BLANK OUTPUT LINE
          L     R5,DATAADDR      LOAD OUTPUT LINE ADDRESS
          MVC   WORKCTR,USERCTR  MOVE USERID COUNTER TO WORK AREA
          BAL   R2,USERMSG       MOVE "NNN USER(S)" TO OUTPUT LINE
          MVC   0(6,R5),LOGGED   MOVE "LOGGED" TO OUTPUT
          LA    R5,7(,R5)
          MVC   0(2,R5),ON       MOVE "ON" TO OUTPUT
          LA    R5,3(,R5)
          MVC   0(3,R5),AND      MOVE "AND" TO OUTPUT
          LA    R5,4(,R5)
          MVC   WORKCTR,LOGONCTR MOVE LOGGING ON COUNTER TO WORK AREA
          BAL   R2,USERMSG       MOVE "NNN USER(S) TO OUTPUT LINE"
          MVC   0(7,R5),LOGGING  MOVE "LOGGING" TO OUTPUT
          LA    R5,8(,R5)
          MVC   0(2,R5),ON       MOVE "ON" TO OUTPUT
          BAL   R2,WRITE         BRANCH TO WRITE LINE
          L     R2,R2SAVE
PUTTOTLX  BR    R2
          EJECT
          SPACE 2
*  POSITION "NNN USER(S)" ON OUTPUT LINE
          SPACE 4
USERMSG   NOP   USERMSGX
          ST    R2,R2SAVE2
          L     R3,WORKCTR           LOAD COUNTER
          C     R3,BIN0              DOES COUNT EQUAL ZERO
          BE    USERMSG2             BRANCH ON YES
          CVD   R3,DOUBLCTR          CONVERT COUNT TO DECIMAL
          MVC   0(4,R5),MASK         MOVE EDIT MASK TO OUTPUT
          ED    0(4,R5),DOUBLCTR+6   MOVE COUNT TO OUTPUT
          B     USERMSG4
USERMSG2  NOP   USERMSGX
          MVC   0(4,R5),NO2          MOVE "NO" TO OUTPUT
USERMSG4  NOP   USERMSGX
          BAL   R2,MOVE              REMOVE SPACES TO LEFT OF COUNT
*                                      OR WORD "NO"
          MVC   0(4,R5),USER         MOVE "USER" TO OUTPUT
          LA    R5,4(,R5)
          C     R3,BIN1              DOES COUNT EQUAL 1?
          BE    USERMSG8             BRANCH ON YES
          MVC   0(1,R5),S            MOVE "S" TO OUTPUT
          LA    R5,1(,R5)
USERMSG8  NOP   USERMSGX
          LA    R5,1(,R5)
          L     R2,R2SAVE2
USERMSGX  BR    R2
          EJECT
          SPACE 2
*  REMOVE SPACES TO LEFT OF COUNT OR WORD "NO" ON OUTPUT LINE
          SPACE 1
*  UPON ENTRY, REGISTER 5 POINTS TO THE POSITION ON THE OUTPUT
*    LINE WHERE REMOVAL OF LEADING BLANKS WILL BEGIN.
*    ON LEAVING ROUTINE, REGISTER 5 POINTS TO THE NEXT
*    AVAILABLE POSITION ON THE OUTPUT LINE.
          SPACE 4
*  USE REGISTER 6 TO FIND RIGHTMOST BYTE ON THE OUTPUT LINE.
*  REGISTER 7 BEGINS AT THE POSITION IN REGISTER 5
*    AND MOVES ALONG THE OUTPUT LINE FROM LEFT TO RIGHT,
*    STOPPING AT THE FIRST NON-BLANK OR AT THE LAST POSITION
*    ON THE OUTPUT LINE.
          SPACE 1
MOVE      NOP   MOVEX
          L     R6,DATAADDR      LOAD ADDRESS OF OUTPUT LINE
          A     R6,DATALEN       ADD LENGTH OF OUTPUT LINE
          S     R6,BIN1          DECREASE BY 1 TO GET LAST POSITION
          ST    R6,LASTPOS       STORE LAST POSITION
          ST    R5,STARTPOS      STORE STARTING POSITION
          L     R7,STARTPOS      LOAD STARTING POSITION
*  LOCATE FIRST NON-BLANK
MOVE2     NOP   MOVEX
          ST    R7,CURRPOS       STORE TEST POINTER
          CLC   0(1,R7),BLANKS   IS THIS BYTE BLANK?
          BNE   MOVE4            BRANCH ON NO
          LA    R7,1(,R7)        MOVE 1 BYTE TO RIGHT
          CR    R7,R6            IS THIS THE BYTE TO THE RIGHT
*                                  OF THE OUTPUT LINE?
          BNH   MOVE2            BRANCH ON NO
          B     MOVEX            THERE ARE ONLY BLANKS FROM STARTING
*                                  POSITION THROUGH END OF LINE
MOVE4     NOP   MOVEX
          CLC   CURRPOS,STARTPOS WE ARE POINTING TO THE FIRST NON-
*                                  BLANK.  IS THIS ALSO THE
*                                  STARTING POSITION?
          BE    MOVE6            BRANCH ON YES
          SPACE 1
*  MOVE DATA FROM RIGHT TO LEFT ELIMINATING BLANKS
*    USE REGISTER 8 TO CALCULATE THE LENGTH OF THE MOVE.
*    LOAD REGISTER 8 WITH THE ADDRESS OF THE LAST POSITION ON
*    THE OUTPUT LINE.  SUBTRACT THE ADDRESS OF THE FIRST NON-BLANK,
*    LEAVING THE NUMBER OF CHARACTERS TO SHIFT RIGHT.
          L     R8,LASTPOS       LOAD LAST POSITION
          S     R8,CURRPOS       SUBTRACT ADDRESS OF FIRST NON-BLANK
          EX    R8,MOVEY         REMOVE BLANKS BY SHIFTING MESSAGE
*                                  RIGHT TO LEFT
          SPACE 1
*  FILL IN END OF LINE WITH BLANKS
*    USE REGISTER 8 TO CALCULATE THE LENGTH OF THE MOVE.
*    LOAD REGISTER 8 WITH THE ADDRESS OF THE FIRST NON-BLANK
*    BEFORE THE SHIFT RIGHT.  SUBTRACT THE ADDRESS OF THE
*    FIRST POSITION ON THE LINE AND ONE MORE, LEAVING
*    THE NUMBER OF POSITIONS TO BLANK FILL ON THE LEFT END
*    OF THE OUTPUT LINE.
          L     R8,CURRPOS       LOAD ADDRESS OF FIRST NON-BLANK
*                                  BEFORE MESSAGE SHIFT
          S     R8,STARTPOS      SUBTRACT ADDRESS OF STARTING POSITION
          S     R8,BIN1          SUBTRACT 1 TO GET LENGTH FOR EX MOVE
          L     R9,LASTPOS       LOAD LAST POSITION
          SR    R9,R8            CALCULATE FIRST POS TO BE BLANKED
          EX    R8,MOVEZ         MOVE BLANKS TO END OF LINE
          SPACE 1
*  LOOP TO FIND FIRST BLANK AND MOVE POINTER ONE BYTE TO ITS RIGHT
*    THIS IS THE NEXT AVAILABLE POSITION ON THE OUTPUT LINE.
MOVE6     NOP   MOVEX
          CLC   0(1,R5),BLANKS
          LA    R5,1(,R5)
          BNE   MOVE6
MOVEX     BR    R2
          SPACE 4
MOVEY     MVC   0(0,R5),0(R7)
MOVEZ     MVC   0(0,R9),BLANKS
          EJECT
CLOSE     NOP   CLOSEX
          RETURNX
CLOSEX    BR    R2
          EJECT
BIN0      DC    F'0'
BIN1      DC    F'1'
BIN2      DC    F'2'
BIN4      DC    F'4'
BIN8      DC    F'8'
MASK      DC    XL4'40202120'
          SPACE 4
          DS    0F
BLANKS    DC    CL50' '
          SPACE 4
NO        DC    CL1'N'
YES       DC    CL1'Y'
          SPACE 4
AND       DC    CL3'AND'
LOGGED    DC    CL6'LOGGED'
LOGGING   DC    CL7'LOGGING'
NO2       DC    CL4'  NO'
ON        DC    CL2'ON'
USER      DC    CL4'USER'
S         DC    CL1'S'
          SPACE 4
TMSG      DC    0C'NNNN USERS LOGGED ON AND NNNN USERS LOGGING ON'
TMSGLEN   DC    AL4(L'TMSG)
          SPACE 4
*  THE COLLATING SEQUENCE IS  $, #, @, A, ..., Z.
*    ANY CHANGE TO THE COLLATING SEQUENCE WILL REQUIRE
*    A CORRESPONDING CHANGE TO THE TABLE.
*  $ IS 5B;  # IS 7B;  @ IS 7C;
*  A - I IS C1 - C9;
*  J - R IS D1 - D9;
*  S - Z IS E2 - E9;
          SPACE 1
TABLE     DC    256X'74'
          ORG   TABLE+C'$'
          DC    X'00'
          ORG   TABLE+C'#'
          DC    X'0408'
          ORG   TABLE+C'A'
          DC    X'0C1014181C2024282C'
          ORG   TABLE+C'J'
          DC    X'3034383C4044484C50'
          ORG   TABLE+C'S'
          DC    X'54585C6064686C70'
          ORG   ,
          SPACE 4
LIST      DS    0F
NEXTPTR   DS    A
USERID    DS    CL7
LISTLEN   EQU   *-LIST
          SPACE 4
NEWLIST   DS    0F
NEWPTR    DS    A
NEWUSER   DS    CL7
NEWLLEN   EQU   *-NEWLIST
          SPACE 4
WORKAREA  DSECT
          DS    18A
EOUSERS   DS    CL1
LASTUSER  DS    CL1
UIDEXIST  DS    CL1
USERSAVE  DS    CL7
TESTINDX  DS    0F
TESTIND1  DS    CL3
TESTUID   DS    CL1
USEROUT   DS    0F
USEROUT1  DS    CL7
BLANK     DS    CL1
USERCTR   DS    A
LOGONCTR  DS    A
WORKCTR   DS    A
DOUBLCTR  DS    D
MAXUOUT   DS    A
LOWPTR    DS    A
CPPLADDR  DS    A
DATAADDR  DS    A
DATALEN   DS    A
STARTPOS  DS    A
CURRPOS   DS    A
LASTPOS   DS    A
R2SAVE    DS    A
R2SAVE2   DS    A
POINTERS  DS    0F
PTR$      DS    A
PTR#      DS    A
PTR@      DS    A
APTR      DS    A
BPTR      DS    A
CPTR      DS    A
DPTR      DS    A
EPTR      DS    A
FPTR      DS    A
GPTR      DS    A
HPTR      DS    A
IPTR      DS    A
JPTR      DS    A
KPTR      DS    A
LPTR      DS    A
MPTR      DS    A
NPTR      DS    A
OPTR      DS    A
PPTR      DS    A
QPTR      DS    A
RPTR      DS    A
SPTR      DS    A
TPTR      DS    A
UPTR      DS    A
VPTR      DS    A
WPTR      DS    A
XPTR      DS    A
YPTR      DS    A
ZPTR      DS    A
SPACEP    DS    A
ENDPTR    EQU   *-4
PTRLEN    EQU   *-POINTERS
WORKLEN   EQU   *-WORKAREA
          EJECT
          PRINT NOGEN
          CVT   DSECT=YES
          EJECT
          IHAASVT
          EJECT
          IHAASCB
          SPACE 4
          END
