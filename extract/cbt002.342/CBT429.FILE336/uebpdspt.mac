         TITLE 'PDSPRINT -- GENERALIZED PDS LISTER -- OCTOBER, 1980'
         MACRO
         DCBEQU &PRE,&DCB,&NAMES
         LCLA  &I
&I       SETA  1
.LOOP    ANOP
&PRE&NAMES(&I) EQU DCB&NAMES(&I)-IHADCB+&DCB
&I       SETA  &I+1
         AIF   (&I LE N'&NAMES).LOOP
         MEND
PDSPRINT SAVEX SA=SAVEAREA,PARMR=R11,XID='PDS LISTER WITH DIRECTORY'
         SPACE
         USING SAVEAREA,R13       USE 13 AS BASE FOR DATA
         EJECT
***********************************************************************
*        THIS ROUTINE IS A GENERALIZED PDS LISTER, CAPABLE OF HANDLING*
*        ALL INPUT RECORD FORMATS (INCLUDING SPANNED). PROVIDED WITH  *
*        THE LISTING IS A TALE OF CONTENTS, INDICATING THE PAGE(S)    *
*        WHERE EACH MEMBER IS TO BE FOUND, AND PROVIDING AN ALIAS-    *
*        TO-MAIN-MEMBER CROSS-REFERENCE.                              *
*        THIS PROGRAM WAS WRITTEN BY ALAN BEALE, BASED ON AN EARLIER  *
*        PROGRAM WRITTEN BY FARRELL GERBODE.                          *
***********************************************************************
         SPACE 3
***********************************************************************
*        BEGIN BY VALIDATING AND INTERPETING ANY PARAMETER. IF        *
*        SUPPLIED, THE PARAMETER MUST BE AN INTEGER, SPECIFYING THE   *
*        NUMBER OF LINES PER PAGE. IF NO PARM IS PROVIDED, THERE WILL *
*        BE 55 LINES PER PAGE.                                        *
***********************************************************************
         SPACE
         LTR   R11,R11            ANY PARM PASSED?
         BZ    NOPARM             NO.
         L     R11,0(,R11)        YES, FIND CHAR STRING
         CLC   0(2,R11),=H'0'     WAS A PARM PASSED?
         BE    NOPARM             NO.
         CLC   0(2,R11),=H'2'     YES, AT LEAST 2 CHARS?
         BL    BADPARM            NO, BAD LINECT
         CLC   0(2,R11),=H'4'     LINECT TOO BIG?
         BNL   BADPARM
         LH    R14,0(,R11)        LOAD THE LENGTH
         BCTR  R14,0
         EX    R14,TESTPARM       MOVE PARM FOR NUMERIC TEST
         CLC   NUMERIC,=C'000'    IS THE PARM NUMERIC?
         BNE   BADPARM            NO.
         EX    R14,PACKPARM       YES, GET IT TO BINARY
         CVB   R14,DECWORK
         CH    R14,=H'10'         IS THE LINECT TOO SMALL?
         BL    BADPARM            YES.
         STH   R14,LINEMAX        NO, SAVE IT FOR LATER
         B     NOPARM
         SPACE
BADPARM  LH    R14,0(,R11)
         CH    R14,=H'10'         ROOM IN MSG FOR 1ST 10 ONLY
         BNH   NOTRUNC
         LA    R14,10
         MVC   DOTROOM,=C'...'
NOTRUNC  BCTR  R14,0
         EX    R14,PARMSGMV       MOVE PARM TO MESSAGE
         LA    R2,PARMSG
         BAL   R11,ERRMSG         SEND WARNING MESSAGE
         MVI   RETC+1,4           SET EVENTUAL RETURN CODE
         EJECT
***********************************************************************
*        THIS SECTION READS THE PDS DIRECTORY AND BUILDS TABLES       *
*        CONTAINING MEMBER AND ALIAS INFORMATION. THREE TABLES ARE    *
*        DEFINED, A MEMBER TABLE (ONE ENTRY PER MEMBER), A FIRST-ALIAS*
*        TABLE (ONE ENTRY PER DISTINCT ALIAS TTR), AND AN OTHER ALIAS *
*        TABLE (ONE ENTRY PER DUPLICATE ALIAS).                       *
***********************************************************************
         SPACE
NOPARM   RDJFCB QSAMDCB           GET SYSLIB DSNAME THRU JFCB
         LTR   R15,R15            CHECK FOR DD CARD
         BZ    DDOK
         LA    R2,NOSYSLIB        SEND ERROR MSG
         BAL   R11,ERRMSG
         LA    R15,16
         B     ABORT              AND TERMINATE
         SPACE
DDOK     OI    JFCB+52,X'08'      INHIBIT REWRITE
         OPEN  (QSAMDCB,(INPUT)),TYPE=J  OPEN THE DIRECTORY
         LTR   R15,R15            OPEN SUCCESSFUL?
         BZ    QSAMREAD           YES.
         LA    R2,LIBNOP          NO, SEND MESSAGE
         BAL   R11,ERRMSG
         LA    R15,16
         B     ABORT              TERMINATE PROGRAM
         SPACE
***********************************************************************
*        READ THE NEXT DIRECTORY BLOCK.                               *
***********************************************************************
         SPACE
QSAMREAD GET   QSAMDCB,DIRBLK     GET NEXT DIRECTORY BLOCK
         LA    R9,DIRBLK+2        POINT TO 1ST ENTRY
         LH    R8,DIRBLK          LOAD DATA COUNT
         LA    R8,DIRBLK(R8)      ADDR END OF BLOCK
         SPACE
***********************************************************************
*        GET THE LOCATION OF THE NEXT MEMBER FROM THE DIRECTORY.      *
***********************************************************************
         SPACE
SAMEDIR  CR    R9,R8              REACHED END OF BLOCK?
         BNL   QSAMREAD           YES, READ AGAIN
         CLC   0(8,R9),=8X'FF'    IS THIS THE END OF DIRECTORY MARK?
         BE    ENDDIR             YES, CLOSE UP DIRECTORY
         LA    R2,MEMBLK          NO, GET A NEW MEMBER TABLE ENTRY
         BAL   R11,GETENT
         LR    R5,R2              SAVE ENTRY ADDR IN R5
         USING MEMBER,R5
         MVC   MEMNAME,0(R9)      COPY MEMBER NAME
         MVC   MEMTTR,8(R9)       AND TTR FROM DIRECTORY
         TM    11(R9),X'80'       IS THIS AN ALIAS?
         BZ    NEXTENT            NO, SKIP ALIAS PROCESSING
         MVI   MEMFLAGS,$ALIAS    YES, SET ALIAS FLAG
         SPACE
***********************************************************************
*        SEE IF ANOTHER ALIAS WITH THIS TTR HAS BEEN SEEN. IF SO, ADD *
*        THIS ONE TO THE CHAIN FOR THIS TTR; IF NOT, START A NEW      *
*        CHAIN. THE ALIASES ARE ADDRESSED VIA 2 TABLES, THE FIRST     *
*        INDEXED BY THE FIRST 3 NYBBLES OF THE TT, THE OTHER INDEXED  *
*        BY THE REST. THE SECOND TABLE ENTRY ADDRESSES THE HEAD OF A  *
*        CHAIN OF FIRST-ALIASES, ORDERED BY R. (THE OTHER ALIASES     *
*        ARE CHAINED FROM THE FIRST.)                                 *
***********************************************************************
         SPACE
         L     R6,TTTAB1          LOCATE THE FIRST TT TABLE
         LTR   R6,R6              HAS IT BEEN CREATED?
         BNZ   GOTTTAB            YES.
         GETMAIN R,LV=16384       NO, CREATE IT NOW
         LR    R6,R1              SAVE ITS ADDR
         ST    R6,TTTAB1
         LR    R0,R1              CLEAR IT OUT
         L     R1,=F'16384'
         SR    R15,R15            WITH X'00'S
         MVCL  R0,R14
         SPACE
GOTTTAB  SR    R14,R14
         ICM   R14,B'0011',MEMTTR LOAD THE TT
         SRDL  R14,4              ISOLATE TT MOD 16
         SRL   R15,26             * 4
         SLL   R14,2              FLOOR(TT/16) * 4
         AR    R14,R6             LOCATE THE TABLE ENTRY
         ICM   R1,B'1111',0(R14)  LOCATE LEVEL 2 TABLE
         BZ    NEWTT1             IF NONE, GET NEW LEVEL 2 TABLE
         LA    R14,0(R15,R1)      FIND LEVEL 2 ENTRY FOR THIS TT
         ICM   R6,B'1111',0(R14)  FIND HEAD OF CHAIN FOR TT
         BZ    NEWTT2             IF NONE, GO START CHAIN
         SPACE
***********************************************************************
*        SEARCH THE ALIAS CHAIN FOR THIS TT TO SEE IF ANOTHER ALIAS   *
*        FOR THIS TTR IS KNOWN. IF SO, ADD THIS ALIAS TO THE "OTHER-  *
*        ALIAS" CHAIN FOR THIS TTR.                                   *
***********************************************************************
         SPACE
         USING ALIAS1,R6
ALIASRCH L     R15,AL1MEMB        FIND MEMBER ENTRY FOR CHAIN ENTRY
         CLC   MEMTTR+2(1),MEMTTR-MEMBER+2(R15)  COMPARE R'S
         BE    ADDALIAS           IF THE SAME, ADD TO OTHER TABLE
         BL    NEWALIAS           IF CHAIN ENTRY BIGGER, ADD HERE
         LR    R14,R6             SAVE THIS ENTRY
         ICM   R6,B'1111',AL1CHAIN     GET NEXT ON CHAIN
         BNZ   ALIASRCH           IF ANY
         SPACE
***********************************************************************
*        GET A NEW "FIRST-ALIAS" ENTRY FOR THIS ALIAS, AND INSERT IT  *
*        INTO THE CHAIN FOR THIS TT (ORDERED BY R).                   *
***********************************************************************
         SPACE
NEWALIAS LR    R6,R14             RESTORE PRIOR POINTER
         LA    R2,AL1BLK
         BAL   R11,GETENT         GET A FIRST-ALIAS ENTRY
         MVC   AL1CHAIN-ALIAS1(,R2),AL1CHAIN
         ST    R2,AL1CHAIN        INSERT INTO CHAIN
         LR    R6,R2
         ST    R5,AL1MEMB         LINK TO MEMBER ENTRY
         ST    R6,MEMALIAS
         OI    MEMFLAGS,$PSMAIN   INDICATE MIGHT END UP MAIN
         B     NEXTENT            PROCEED TO NEXT ENTRY
         SPACE
***********************************************************************
*        ADD THIS ALIAS TO THE OTHER-ALIAS CHAIN FOR THIS TTR. THIS   *
*        CHAIN IS ORDERED ALPHABETICALLY BY MEMBER NAME.              *
***********************************************************************
         SPACE
ADDALIAS ST    R6,MEMALIAS        POINT MEMBER TO FIRST-ALIAS
         LA    R2,AL2BLK          GET AN "OTHER" ENTRY
         BAL   R11,GETENT
         USING ALIAS2,R2
         ST    R5,AL2MEMB         POINT OTHER ENTRY TO MEMBER ENTRY
         ICM   R15,B'1111',AL1LAST     GET PREVIOUS LAST ALIAS FOR TTR
         ST    R2,AL1LAST
         BZ    FIRSTOTH           BRANCH IF FIRST OTHER
         ST    R2,AL2CHAIN-ALIAS2(,R15)     ADD TO END OF CHAIN
         B     NEXTENT
FIRSTOTH ST    R2,AL1FIRST        ELSE MAKE FIRST
         DROP  R2
         B     NEXTENT            GET NEXT MEMBER FROM DIRECTORY
         SPACE
***********************************************************************
*        THIS TT FRAGMENT WAS NOT PREVIOUSLY KNOWN. GET A LEVEL 2     *
*        TABLE, AND PUT ITS ADDRESS IN THE LEVEL 1 TABLE.             *
***********************************************************************
         SPACE
NEWTT1   LR    R6,R14             SAVE LEVEL 1 ENTRY PTR
         LR    R10,R15            SAVE TT MOD 16 * 4
         LA    R2,TT2BLK          ASK FOR A LEVEL 2 TABLE
         BAL   R11,GETENT
         ST    R2,0(,R6)          STORE INTO LEVEL 1 TABLE
         LA    R14,0(R10,R2)      ADDRESS LEVEL 2 ENTRY
         SPACE
***********************************************************************
*        GET A NEW "FIRST-ALIAS" ENTRY AND ADD ITS ADDRESS TO THE     *
*        LEVEL 2 TABLE.                                               *
***********************************************************************
         SPACE
NEWTT2   LR    R6,R14             SAVE TABLE ENTRY ADDR
         LA    R2,AL1BLK          ASK FOR A FIRST-ALIAS ENTRY
         BAL   R11,GETENT
         ST    R2,0(,R6)          STORE ENTRY ADDR IN TABLE
         LR    R6,R2
         ST    R5,AL1MEMB         LINK TO MEMBER ENTRY
         ST    R6,MEMALIAS
         OI    MEMFLAGS,$PSMAIN   INDICATE MAY BECOME MAIN
         DROP  R5,R6
         SPACE
***********************************************************************
*        PROCEED TO THE NEXT DIRECTORY ENTRY.                         *
***********************************************************************
         SPACE
NEXTENT  SR    R2,R2
         IC    R2,11(,R9)         GET DIRECTORY HALFWORD COUNT
         SLL   R2,27              CLEAR ALIAS & TTRN COUNT
         SRL   R2,26              MULTIPLY BY 2
         LA    R9,12(R2,R9)       ON TO THE NEXT ONE
         B     SAMEDIR
         EJECT
***********************************************************************
*        CHECK EACH NON-ALIAS MEMBER FOR A MATCHING ALIAS, AND LINK   *
*        THE FIRST ALIAS TO ITS MAIN MEMBER IF SO. ALSO, TURN OFF THE *
*        PSEUDO-MAIN FLAG IN THE MEMBER ENTRY FOR EACH LINKED ALIAS.  *
*        THEN, AT COMPLETION OF THIS PROCESSING, ONLY THOSE ALIASES   *
*        WITHOUT A CORRESPONDING NON-ALIAS WILL HAVE THIS FLAG SET.   *
***********************************************************************
         SPACE
ENDDIR   L     R2,TTTAB1          LOAD LEVEL 1 TABLE ADDR
         LTR   R2,R2              WAS ONE EVER MADE?
         BZ    CLOSEDIR           NO, NO ALIASES EXIST
         L     R8,MEMBLK          YES, FIND FIRST MEMBER TABLE BLOCK
         LA    R5,BLKDATA(,R8)    FIND FIRST ENTRY IN BLOCK
         USING MEMBER,R5
CONNLOOP TM    MEMFLAGS,$ALIAS    IS THIS AN ALIAS?
         BNZ   NEXTCONN           YES, SKIP CONNECTION
         SR    R14,R14            NO, CHECK FOR ALIAS
         ICM   R14,B'0011',MEMTTR LOAD THE TT
         SRDL  R14,4              SPLIT OFF LAST NYBBLE
         SRL   R15,26
         SLL   R14,2              TO GET TABLE INDICES
         AR    R14,R2             FIND LEVEL 1 ENTRY
         ICM   R6,B'1111',0(R14)  ANYTHING AT LEVEL 2?
         BZ    NEXTCONN           NO, NO ALIASES
         AR    R6,R15             YES, FIND LEVEL 2 ENTRY
         ICM   R6,B'1111',0(R6)   DOES IT LEAD ANYWHERE?
         BZ    NEXTCONN           NO.
         SPACE
         USING ALIAS1,R6
ALISRCH2 L     R14,AL1MEMB        FIND MEMBER ENTRY FOR ALIAS
         CLC   MEMTTR+2(1),MEMTTR+2-MEMBER(R14)  SAME R?
         BE    CONNECT            YES, LINK ALIAS TO MAIN
         BL    NEXTCONN           TOO HIGH, NO ALIAS EXISTS
         ICM   R6,B'1111',AL1CHAIN     TOO LOW, LOOK AT NEXT
         BNZ   ALISRCH2           IF ANY MORE TO LOOK AT
         B     NEXTCONN           IF NOT, TRY NEXT MEMBER
         SPACE
CONNECT  ST    R6,MEMALIAS        CONNECT ALIAS TO MEMBER
         ST    R5,AL1MAIN         AND MEMBER TO ALIAS
         L     R6,AL1MEMB         LOCATE MEMBER ENTRY FOR ALIAS
         NI    MEMFLAGS-MEMBER(R6),255-$PSMAIN  INDICATE NOT MAIN
         SPACE
NEXTCONN LA    R5,MEMBLEN(,R5)    TO NEXT MEMBER ENTRY
         C     R5,BLKNEXT(,R8)    REACHED END OF USED BLOCK?
         BNH   CONNLOOP           NO, CONTINUE
         C     R8,MEMBLK+4        YES, COMPARE TO FINAL BLOCK
         BE    FREETTAB           READY TO PRINT IF SO
         L     R8,BLKCHAIN(,R8)   IF NOT, FIND NEXT BLOCK
         LA    R5,BLKDATA(,R8)    ADDRESS END OF BLOCK
         B     CONNLOOP           AND CONTINUE CONNECTION
         DROP  R5
         SPACE
FREETTAB FREEMAIN R,A=(R2),LV=16384   RETURN LEVEL 1 TABLE
         SPACE
CLOSEDIR CLOSE (QSAMDCB)          CLOSE UP THE DIRECTORY
         FREEPOOL QSAMDCB         AND RETURN ITS BUFFERS
         SPACE
         DROP  R6
         EJECT
         SPACE
***********************************************************************
*        OPEN FILES, AND GATHER RECORD FORMAT INFORMATION FOR LATER   *
*        USE.                                                         *
***********************************************************************
         SPACE
         OPEN  (BPAMDCB,(INPUT))  OPEN PDS AS PDS
         LTR   R15,R15            GOOD OPEN?
         BZ    PDSOK              YEAH.
         LA    R2,LIBNOP          NO, SEND MESSAGE
         BAL   R11,ERRMSG
         LA    R15,16
         B     ABORT              GO TERMINATE PROGRAM
         SPACE
PDSOK    MVC   DSNAME,JFCB        PUT DSNAME INTO TITLES
         MVC   TDSNAME,JFCB
         TM    BPMRECFM,X'80'     IS THIS V FORMAT?
         BNZ   NOTVFORM
         MVI   VARFORM,X'FF'      YES, SET FLAG
         TM    BPMRECFM,X'08'     YES, IS IT SPANNED?
         BZ    NOTVFORM
         MVI   SPANNED,X'FF'      YES, SET FLAG
NOTVFORM LH    R3,BPMLRECL        GET PDS RECLEN
         CLI   VARFORM,X'FF'      V FORMAT?
         BE    MINUS4             YES.
         TM    BPMRECFM,X'C0'     NO, IS IT U FORMAT?
         BNO   JLRECL             NO.
         LH    R3,BPMBLKSI        YES, BLKSIZE IS MAX RECLEN
         B     JLRECL
MINUS4   SH    R3,=H'4'           COMPENSATE FOR DESCRIPTOR WORD
JLRECL   CL    R3,=F'132'         MAY THERE BE MORE THAN A LINE?
         BL    ONELINE
         MVI   LINELEN+1,131      YES, RESERVE LAST COLUMN FOR +
         SPACE
ONELINE  OPEN  (SYSTOC,(OUTPUT),SYSOUT,(OUTPUT)) OPEN LISTINGS
         LTR   R15,R15            ANY TROUBLE?
         BZ    OUTOK              NO.
         LA    R2,NOUTPUT         YES, SEND ERROR MSG
         BAL   R11,ERRMSG
         LA    R15,16
         B     ABORT              AND GIVE UP
         SPACE
***********************************************************************
*        GET THE TIME AND DATE, AND ADD THEM TO THE PAGE HEADINGS.    *
***********************************************************************
         SPACE
OUTOK    TIME  DEC                GET DATE & TIME
         ST    R0,DECWORK+4
         OI    DECWORK+7,X'0F'
         ED    TTIME(9),DECWORK+4 EDIT TIME INTO TITLE
         ST    R1,DECWORK
         UNPK  JDATE,DECWORK(4)
         OI    JDATE+4,X'F0'
         CALL  JULIAN,(JDATE,GDATE),VL CALL JULIAN->GREGORIAN ROUTINE
         MVC   TDATE(2),GDATE     FORMAT INTO TITLE
         MVC   TDATE+3(2),GDATE+2
         MVC   TDATE+6(2),GDATE+4
         SPACE
         MVC   CDATE,TDATE        PUT DATE & TIME IN TOC TITLES TOO
         MVC   CTIME,TTIME+1
         BAL   R11,TOCEJECT       1ST TITLES ON SYSTOC
         SR    R10,R10            SET PAGE NUM TO 0
         EJECT
***********************************************************************
*        NOW READ EACH MEMBER OF THE PDS, LISTING ITS CONTENTS. SAVE  *
*        THE STARTING AND ENDING PAGE NUMBER FOR EACH MEMBER FOR      *
*        INCLUSION IN THE TABLE OF CONTENTS.                          *
***********************************************************************
         SPACE
         L     R8,MEMBLK          FIND FIRST MEMBER TABLE BLOCK
         LA    R9,BLKDATA(,R8)    ADDR 1ST ENTRY IN BLOCK
         SPACE
***********************************************************************
*        POSITION TO THE START OF THE NEXT MEMBER, AND START A NEW    *
*        LISTING PAGE.                                                *
***********************************************************************
         SPACE
         USING MEMBER,R9
NEXTMBLK TM    MEMFLAGS,$ALIAS+$PSMAIN IS THIS (PSEUDO-)MAIN?
         BM    NEXTMEM            NO, DON'T PRINT
         MVC   TTRZ(3),MEMTTR     YES, EXTRACT TTR FOR MEMBER
         MVI   TTRZ+3,0
         POINT BPAMDCB,TTRZ       POSITION TO THAT MEMBER
         MVC   TITLMEM,MEMNAME    MOVE MEMBER NAME TO TITLE
         MVC   STARTOF,=C'START OF'    FOR 1ST PAGE
         BAL   R2,EJECT           START A NEW PAGE
         MVI   PAGE1,X'F0'        NOTE EJECT FOR PAGE 1 OF MEMBER
         MVC   STARTOF,BLANKS     REMOVE START OF
         MVC   MEMPAGE1,PAGENUM+1 SAVE START PAGE IN MEMBER ENTRY
         STM   R8,R9,MBLKSAVE     SAVE MEMBER INFO TO FREE REGS
         SPACE
***********************************************************************
*        START THE READ FOR THE FIRST BLOCK OF THIS MEMBER.           *
***********************************************************************
         SPACE
         GETBUF BPAMDCB,R5        GET BUFFER FOR 1ST READ
         ST    R5,PREVBUF
         READ  DECB,SF,,(R5),MF=E BEGIN TO READ BLOCK 1
         LR    R6,R5              FORCE CHECK BY NEXTSEG
         LA    R8,BUFFER+1        START OF PRINT BUFFER
         LH    R9,LINELEN         AVAILABLE PRINT POSITIONS
         XC    CURBUF,CURBUF
         SPACE
***********************************************************************
*        READ BLOCKS AND PRINT BLOCKS UNTIL THE MEMBER IS CONSUMED.   *
***********************************************************************
         SPACE
PRINLOOP BAL   R11,NEXTSEG        GET THE NEXT RECORD SEGMENT
         BAL   R11,PRINTSEG       PRINT IT
         B     PRINLOOP           CONTINUE FOREVER
         SPACE
***********************************************************************
*        WE GET HERE AFTER END-OF-DATA FOR THE CURRENT MEMBER.        *
***********************************************************************
         SPACE
BPAMEOD  LM    R8,R9,MBLKSAVE     RESTORE MEMBER ENTRY PTRS
         MVC   MEMPAGEN,PAGENUM+1 SAVE FINAL PAGE NUMBER
         CLI   ERRFLAG,X'FF'      DID AN I/O ERROR OCCUR
         BNE   NOERROR            NO.
         OI    MEMFLAGS,$ERROR    YES, SET FLAG FOR CONTENTS
         MVI   ERRFLAG,X'00'      RESET FLAG FOR NEXT MEMBER
NOERROR  ICM   R5,B'1111',CURBUF     LOCATE CURRENT BUFFER
         BZ    SKIPFRE1
         FREEBUF BPAMDCB,R5       GIVE BACK TO THE POOL
SKIPFRE1 L     R5,PREVBUF         FREE THE OTHER BUFFER
         FREEBUF BPAMDCB,R5
         SPACE
***********************************************************************
*        PROCEED TO THE NEXT MEMBER.                                  *
***********************************************************************
         SPACE
NEXTMEM  LA    R9,MEMBLEN(,R9)    FIND NEXT ENTRY IN BLOCK
         C     R9,BLKNEXT(,R8)    REACHED THE LAST USED?
         BNH   NEXTMBLK           NO, CONTINUE
         ICM   R8,B'1111',BLKCHAIN(R8) YES, GET NEXT BLOCK
         BZ    ENDLIST            IF IT EXISTS
         LA    R9,BLKDATA(,R8)    ADDRESS 1ST ENTRY
         B     NEXTMBLK           AND PROCEED
         EJECT
***********************************************************************
*        NOW THAT THE PAGE NUMBERS ARE ALL KNOWN, WRITE THE TABLE     *
*        OF CONTENTS. THE ENTRY FOR EACH MAIN MEMBER WILL INCLUDE     *
*        ALL ITS ALIASES; THE ENTRY FOR EACH ALIAS WILL INCLUDE THE   *
*        CORRESPONDING MAIN MEMBER.                                   *
***********************************************************************
         SPACE
ENDLIST  L     R8,MEMBLK          FIND FIRST MEMBER BLOCK
         LA    R10,BLKDATA(,R8)   FIND FIRST MEMBER IN BLOCK
         SPACE
NEXTTOC  LR    R9,R10             SAVE CURRENT MEMBER PTR
         MVC   TMEMBER,MEMNAME    PUT MEMBER NAME IN LINE
         MVC   ERRSIGN,=CL3' '    BLANK OUT ERROR FLAG
         TM    MEMFLAGS,$ALIAS+$PSMAIN TREAT AS MAIN?
         BNM   TOCMAIN            YES.
         L     R15,MEMALIAS       NO, FIND MAIN MEMBER ENTRY
         ICM   R9,B'1111',AL1MAIN-ALIAS1(R15)
         BNZ   TOCMAIN            IF THERE IS ONE
         L     R9,AL1MEMB-ALIAS1(,R15) ELSE USE PSEUDO-MAIN MEMBER
TOCMAIN  MVC   TSTART,MEMPAGE1    ADD PAGE NUMBERS TO LINE
         MVC   TEND,MEMPAGEN
         TM    MEMFLAGS,$ERROR    I/O ERROR ON THIS MEMBER?
         BZ    NOTERR             NO.
         MVC   ERRSIGN,=C'***'    YES, FLAG LINE
         SPACE
NOTERR   CR    R9,R10             IS THIS AN ALIAS?
         BNE   ADDMAIN            YES, ADD THE MAIN NAME
         ICM   R5,B'1111',MEMALIAS     NO, FIND THE 1ST ALIAS
         BZ    SPILLTOC           IF ANY
         USING ALIAS1,R5
         MVI   TALSIGN,C' '       MAKE SURE NO '='
         LA    R6,TALIAS1         R6->1ST ALIAS POSITION
         LA    R7,90(,R6)         R7->PAST LAST ALIAS COLUMN
         TM    MEMFLAGS,$PSMAIN   IS THIS PSEUDO-MAIN
         BNZ   OTHA1              YES, SKIP FIRST ALIAS
         L     R9,AL1MEMB         FIND MEMBER FOR 1ST ALIAS
         MVC   0(8,R6),MEMNAME    PUT NAME INTO LINE
         LA    R6,10(,R6)         BUMP COLUMN POINTER
OTHA1    ICM   R5,B'1111',AL1FIRST     FIND FIRST OTHER ALIAS
         BZ    SPILLTOC           IF ANY
         SPACE
         USING ALIAS2,R5
OTHALOOP CR    R6,R7              REACHED END OF LINE?
         BL    ADDOTHAL           NO, ADD TO LINE
         BAL   R11,BUMPTOC        YES, BUMP LINE COUNTER
         PUT   SYSTOC,TOCLINE     PUT OUT LAST LINE
         MVI   TMEMBER,C' '       BLANK OUT TOC BUFFER
         MVC   TMEMBER+1(TOCLEN-5),TMEMBER  COMPLETELY
         LA    R6,TALIAS1         START OVER WITH FIRST ALIAS POS
ADDOTHAL L     R9,AL2MEMB         FIND MEMBER ENTRY FOR ALIAS
         MVC   0(8,R6),MEMNAME    ADD NAME TO LINE
         LA    R6,10(,R6)         ADVANCE OUTPUT POINTER
         ICM   R5,B'1111',AL2CHAIN     FIND NEXT ALIAS
         BNZ   OTHALOOP           CONTINUE IF ANY
         B     SPILLTOC           ELSE PRINT FINAL LINE
         SPACE
ADDMAIN  MVI   TALSIGN,C'='       INDICATE THIS IS ALIAS
         MVC   TALIAS1(8),MEMNAME STORE NAME OF MAIN MEMBER
         SPACE
SPILLTOC BAL   R11,BUMPTOC        ADD TO TOC LINE CTR
         PUT   SYSTOC,TOCLINE     WRITE THE LINE
         MVI   TMEMBER,C' '       BLANK OUT TOC BUFFER
         MVC   TMEMBER+1(TOCLEN-5),TMEMBER  COMPLETELY
         LA    R10,MEMBLEN(,R10)  FIND NEXT MEMBER IN BLOCK
         C     R10,BLKNEXT(,R8)   COMPARE TO LAST ENTRY USED
         BNH   NEXTTOC            PROCEED IF STILL IN BLOCK
         ICM   R8,B'1111',BLKCHAIN(R8) ELSE FIND NEXT BLOCK
         BZ    ENDPGM             IF ANY
         LA    R10,BLKDATA(,R8)   FIND START OF DATA
         B     NEXTTOC            AND CONTINUE
         EJECT
***********************************************************************
*        COME HERE TO TERMINATE, NORMALLY OR ABNORMALLY.              *
***********************************************************************
         SPACE
ABORT    STH   R15,RETC           SAVE ABNORMAL RETURN CODE
         SPACE
ENDPGM   CLOSE (BPAMDCB,,QSAMDCB,,SYSOUT,,SYSTOC,,MSGDCB) CLOSE UP
         LH    R15,RETC           LOAD THE RETURN CODE
         RETURNX RC=(15)          AND RETURN
         EJECT
***********************************************************************
*        THIS SUBROUTINE GETS A NEW ENTRY FROM A BLOCK OF DATA AND,   *
*        IF NO ENTRIES EXIST, ALLOCATES A NEW BLOCK. THIS IS USED     *
*        FOR MANAGEMENT OF THE MEMBER AND ALIAS TABLES.               *
***********************************************************************
         SPACE
GETENT   ICM   R1,B'1111',4(R2)   FIND THE CURRENT BLOCK
         BNZ   HAVEBLK            IF THERE IS ONE
         GETMAIN R,LV=4096        IF NOT, GET ONE
         ST    R1,0(,R2)          SAVE AS FIRST BLOCK
         SPACE
NEWBLK   ST    R1,4(,R2)          SAVE AS CURRENT BLOCK
         LA    R14,4095(,R1)      FIND END OF BLOCK
         S     R14,8(,R2)         BACK UP BY ENTRY LENGTH
         ST    R14,BLKEND(,R1)    STORE IN BLOCK HEADER
         LA    R14,BLKDATA(,R1)   POINT TO START OF DATA AREA
         S     R14,8(,R2)         BACK UP BY LENGTH
         ST    R14,BLKNEXT(,R1)   STORE IN NEXT PTR
         XC    BLKCHAIN(,R1),BLKCHAIN(R1)   ZERO THE CHAIN PTR
         SPACE
HAVEBLK  LM    R14,R15,BLKNEXT(R1)     LOAD NEXT & END
         L     R0,8(,R2)          LOAD ENTRY LENGTH
         BXLE  R0,R14,CLRENT      BRANCH IF SPACE LEFT
         GETMAIN R,LV=4096        ELSE GET ANOTHER BLOCK
         L     R14,4(,R2)         CHAIN TO PREVIOUS BLOCK
         ST    R1,BLKCHAIN(,R14)
         B     NEWBLK             AND GET FIRST ENTRY
         SPACE
CLRENT   ST    R0,BLKNEXT(,R1)    STORE NEW NEXT POINTER
         L     R1,8(,R2)          LOAD ENTRY LENGTH
         LR    R2,R0              SAVE NEW BLOCK PTR
         SR    R15,R15
         MVCL  R0,R14             CLEAR NEW ENTRY
         BR    R11                AND RETURN
         EJECT
***********************************************************************
*        THIS SUBROUTINE CHECKS FOR A FULL OUTPUT PAGE.               *
***********************************************************************
         SPACE
BUMPLINE TM    BPMRECFM,X'06'     IS THIS A PRINT PDS?
         BNZ   PAGECK             YES, DON'T COUNT LINES
         LA    R7,1(,R7)          INCREASE LINE NUMBER
         CH    R7,LINEMAX         REACHED THE MAX?
         BLR   R2                 NO, RETURN
         B     EJECT
PAGECK   CLI   BUFFER,C'1'        DOES THIS LINE WANT EJECT?
         BNE   RESETPG1           NO, JUST PROCEED
         TM    PAGE1,X'0F'        YES, IS THIS FIRST LINE OF MEMBER?
         BZ    POSTEJEC           YES, DON'T EJECT AGAIN
         SPACE
***********************************************************************
*        THIS SUBROUTINE STARTS A NEW LISTING PAGE.                   *
***********************************************************************
         SPACE
EJECT    LA    R10,1(,R10)        INCREASE PAGE NUMBER
         CVD   R10,DECWORK        CONVERT TO PRINTABLE
         MVC   PAGENUM+1(5),=X'2020202120'
         ED    PAGENUM(6),DECWORK+5
         PUT   SYSOUT,HEADER
         TM    BPMRECFM,X'06'     PRINT FORMAT PDS?
         BNZ   ASAHEAD            YES, CHANGE TITLE FORMAT
         PUT   SYSOUT,BLANKMSG    SKIP AFTER HEADING
         LA    R7,2               RESET LINE NUMBER
         BR    R2                 AND RETURN
         SPACE
ASAHEAD  MVC   UNDRSCOR,=120C'_'
         PUT   SYSOUT,UNDERMSG    UNDERLINE OUR TITLE
POSTEJEC MVI   BUFFER,C'0'        DOUBLE SPACE FOR HIS TITLE
RESETPG1 MVI   PAGE1,X'FF'
         BR    R2                 AND RETURN
         EJECT
***********************************************************************
*        THIS SUBROUTINE CHECKS FOR A FULL DIRECTORY PAGE.            *
***********************************************************************
         SPACE
BUMPTOC  LA    R2,1
         AH    R2,TOCLNCT         COMPUTE NEW LINE NUMBER
         STH   R2,TOCLNCT
         CH    R2,LINEMAX         IS THE PAGE FULL?
         BLR   R11                NO, PROCEED
         SPACE
***********************************************************************
*        THIS SUBROUTINE STARTS A NEW CONTENTS PAGE.                  *
***********************************************************************
         SPACE
TOCEJECT LA    R2,1
         AH    R2,TOCPAGE         COMPUTE NEW PAGE NUMBER
         STH   R2,TOCPAGE
         CVD   R2,DECWORK
         MVC   CPAGE+1(5),=X'2020202120'
         ED    CPAGE(6),DECWORK+5 EDIT INTO TITLE LINE
         PUT   SYSTOC,THEADER1    PUT OUT TOP TITLE
         PUT   SYSTOC,THEADER2    AND COLUMN HEADINGS
         PUT   SYSTOC,BLANKMSG    SKIP AFTERWARDS
         MVC   TOCLNCT,=H'4'      RESET LINE NUMBER
         BR    R11                AND RETURN
         EJECT
***********************************************************************
*        THIS ROUTINE GETS THE NEXT RECORD OR RECORD SEGMENT, ISSUING *
*        A READ IF NO DATA REMAINS IN THE CURRENT BLOCK.              *
***********************************************************************
         SPACE
NEXTSEG  MVI   SEGTYPE,0          ASSUME UNSPANNED RECORD
         TM    BPMRECFM,X'10'     IS THE PDS BLOCKED?
         BZ    READSEG            NO, LOOK AT NEXT BLOCK
         CR    R5,R6              YES, IS THE BLOCK USED UP?
         BNL   READSEG            YES, TRY THE NEXT
         CLI   VARFORM,X'FF'      NO, IS IT VB?
         BNE   FIXDSEG            NO.
         SPACE
VARSEG   LH    R4,0(,R5)          LOAD LENGTH OF THIS RECORD
         LA    R3,4(,R5)          SKIP TO DATA
         CLI   SPANNED,X'FF'      SPANNED FORMAT?
         BNE   NOTSPAND           NO.
         MVC   SEGTYPE,2(R5)      COPY SEGMENTATION FLAGS
NOTSPAND AR    R5,R4              POINT R5 TO NEXT RECORD
         SH    R4,=H'4'           GET DATA LENGTH IN R4
         B     CTLCHECK           GO CHECK FOR CTL CHARS
         SPACE
FIXDSEG  TM    BPMRECFM,X'40'     IS THIS F OR U FORMAT?
         BNZ   UFORM              U.
         LH    R4,BPMLRECL        F, LOAD RECORD LENGTH
UFORM    LR    R3,R5              POINT R3 TO DATA
         AR    R5,R4              POINT R5 TO NEXT RECORD OF BLOCK
         SPACE
***********************************************************************
*        FOR A OR M FORMAT DATA SETS, SPECIAL PROCESSING IS REQUIRED. *
*        FOR AN ASA DATA SET, WE JUST STORE THE CONTROL CHARACTER IN  *
*        THE OUTPUT BUFFER, EXCEPT THAT SKIP TO CHANNEL N>1 IS        *
*        REPLACED BY A DOUBLE SPACE. FOR A M TYPE DATA SET, WE        *
*        TRANSLATE THE CHARACTER TO THE CORRESPONDING ASA CHARACTER.  *
*        IF THE OPERATION IS A PRINT & CONTROL, WE SAVE THE ASA       *
*        CHARACTER FOR THE NEXT LINE. IF IT IS JUST A CONTROL, WE     *
*        SIMULATE AN EMPTY INPUT RECORD TO GET THE CONTROL CHAR SENT. *
***********************************************************************
         SPACE
CTLCHECK TM    SEGTYPE,X'02'      IS THIS A STARTING SEGMENT?
         BZ    STARTING           YES.
         CLI   THROWAY,X'FF'      SHOULD SEGMENT BE THROWN AWAY
         BE    NEXTSEG            YES, TRY AGAIN
         BR    R11                ELSE RETURN
STARTING MVI   THROWAY,0          STOP THROWING AWAY
         TM    BPMRECFM,X'06'     PRINT TYPE PDS?
         BZR   R11                NO, JUST RETURN
         TM    BPMRECFM,X'02'     YES, MACHINE CHARS?
         BNZ   MACHCTL            YES (GAG)
         MVC   BUFFER(1),0(R3)    NO, MOVE ASA CHAR TO BUFFER
         CLI   BUFFER,C'1'        IS IT A SKIP TO SPECIAL CHANNEL?
         BNH   CTLDONE            NO.
         MVI   BUFFER,C'0'        YES, CHANGE TO DOUBLE SPACE
CTLDONE  LA    R3,1(,R3)          POINT PAST CTL CHAR
         BCTR  R4,0               FIX UP LENGTH
         BR    R11                AND RETURN
         SPACE
MACHCTL  CLI   0(R3),X'8B'        IS THIS A SKIP TO SPECIAL CHAN?
         BNH   NOCHAN             NO.
         MVI   NEXTCARR,C'0'      YES, MAKE DOUBLE SPACE
         B     MACHDONE
NOCHAN   LA    R15,=C'1'          ASSUME PAGE THROW
         TM    0(R3),X'80'        WERE WE RIGHT?
         BNZ   TRANCTL            YES.
         SR    R15,R15
         IC    R15,0(,R3)
         SRL   R15,3
         LA    R15,ASATAB(R15)    YES, TRANSLATE TO ASA
TRANCTL  MVC   NEXTCARR,0(R15)    BUFFER FOR LATER
MACHDONE TM    0(R3),X'02'        IS THIS AN IMMEDIATE SKIP?
         BZ    CTLDONE            NO, PROCEED
         XI    PAGE1,X'F0'        STARTING NEW MEMBER?
         BNZ   NOTTOP             NO, PROCEED
         MVC   BUFFER(1),NEXTCARR YES, COPY OVER CTL CHAR
         B     NEXTSEG            AND PROCEED TO NEXT INPUT
NOTTOP   MVI   SEGTYPE,0          PRETEND ONLY SEGMENT
         MVI   THROWAY,X'FF'      THROW OUT FURTHER SEGMENTS
         SR    R4,R4              CLAIM 0 LENGTH LINE
         BR    R11                RETURN TO SEND CTL CHAR
         EJECT
***********************************************************************
*        WE GET HERE WHEN WE NEED THE NEXT INPUT BLOCK, FOR WHICH A   *
*        READ WAS PREVIOUSLY ISSUED. WE CHECK THIS READ, AND          *
*        ANTICIPATE THE NEXT BLOCK, SWITCHING TO THE OTHER BUFFER     *
*        FIRST.                                                       *
***********************************************************************
         SPACE
READSEG  ICM   R5,B'1111',CURBUF  FIND USED-UP BUFFER
         BZ    NOFREEB            IF ANY
         FREEBUF BPAMDCB,R5       PUT BACK IN POOL
         SPACE
NOFREEB  CHECK DECB               WAIT FOR INPUT TO WORK
         CLI   ERRFLAG,X'FF'      WAS THE SYNAD ENTERED?
         BE    BPAMERR            YES, GO TO ABORT MEMBER
         L     R5,PREVBUF         NO, FIND THE INPUT BUFFER
         ST    R5,CURBUF
         GETBUF BPAMDCB,R2        GET THE OTHER ONE FOR ANTICIPATION
         L     R6,DECB+16         FIND CSW RESIDUAL COUNT
         LH    R6,14(,R6)         BEFORE REUSING DECB
         READ  DECB,SF,,(R2),MF=E READ THE NEXT BLOCK
         ST    R2,PREVBUF         SAVE NEW INPUT BUFFER ADDR
         CLI   VARFORM,X'FF'      V TYPE FILE?
         BNE   FIXED              NO, F OR U
         LH    R6,0(,R5)
         AR    R6,R5              FIND THE END OF BLOCK
         LA    R5,4(,R5)          POINT R5 TO 1ST RECORD
         B     VARSEG             GO TO USE 1ST RECORD
         SPACE
FIXED    LH    R4,BPMBLKSI
         SR    R4,R6              COMPUTE AMOUNT READ
         LA    R6,0(R5,R4)        POINT TO BLOCK END
         B     FIXDSEG            GO HANDLE 1ST RECORD
         EJECT
***********************************************************************
*        THIS CODE IS ENTERED AFTER THE SYNAD EXIT DETECTS AN ERROR.  *
*        IT PRINTS A DIAGNOSTIC MESSAGE AND ABORTS THE PRINTING       *
*        OF THE CURRENT MEMBER.                                       *
***********************************************************************
         SPACE
BPAMERR  MVC   MEMBERR,TITLMEM    PUT MEMBER NAME INTO MSG
         LA    R2,IOMSG
         BAL   R11,ERRMSG         GO WRITE AN ERROR MSG
         MVI   RETC+1,8           SET NOTABLE RETURN CODE
         B     BPAMEOD            TERMINATE THIS MEMBER
         EJECT
***********************************************************************
*        THIS ROUTINE IS CALLED TO PRINT A LOGICAL RECORD OR RECORD   *
*        SEGMENT.  IF THE TEXT IS LONGER THAN A PRINT LINE, MULTIPLE  *
*        LINES ARE PRINTED, WITH EACH CONTINUED LINE HAVING A "+" IN  *
*        COLUMN 132 TO INDICATE CONTINUATION.  IF THE TEXT TO BE      *
*        PRINTED IS AN INTERNAL SEGMENT OF A SPANNED RECORD, THE FINAL*
*        LINE IS NOT PRINTED, AS ADDITIONAL TEXT CAN BE APPENDED FOR  *
*        THE FOLLOWING SEGMENT(S).                                    *
***********************************************************************
         SPACE
PRINTSEG LTR   R1,R4              ASSUME WHOLE RECORD TO PRINT
         BZ    SEGEND             HANDLE EMPTY LINE
         CR    R4,R9              IS THERE ROOM FOR ALL?
         BNH   SHORTSEG           YES.
         LTR   R1,R9              NO, JUST PRINT WHAT WILL FIT
         BZ    SPILLSEG           SPILL BUFFER IF NOTHING TO MOVE
SHORTSEG BCTR  R1,0
         EX    R1,MVSEG           MOVE TEXT TO PRINT LINE
         LA    R1,1(,R1)          RESTORE FULL LENGTH
         AR    R3,R1              BUMP INPUT POINTER
         AR    R8,R1              BUMP OUTPUT POINTER
         SR    R4,R1              COMPUTE LENGTH LEFT
         BZ    SEGEND             IF NO MORE INPUT LEFT
SPILLSEG MVI   BUFFER+132,C'+'    INDICATE CONTINUATION
         MVC   BUFLEN,=H'137'     SET RECORD LENGTH
         BAL   R2,BUMPLINE        CHECK FOR PAGE END
         PUT   SYSOUT,BUFLEN      NOW PRINT THE LINE
         LA    R8,BUFFER+1        RESET THE OUTPUT POINTER
         LH    R9,LINELEN         READY TO START NEW LINE
         MVI   BUFFER,C' '        SET CONTINUATION CONTROL CHAR
         B     PRINTSEG           CONTINUE WITH INPUT TEXT
         SPACE
SEGEND   TM    SEGTYPE,X'01'      IS THIS A FINAL SEGMENT?
         BNZ   NOTYET             NO.
         LH    R15,LINELEN
         SR    R15,R9
         LA    R1,5(R1,R15)       COMPUTE LENGTH OF PRINT LINE
         STH   R1,BUFLEN
         BAL   R2,BUMPLINE        BUMP THE LINE COUNTER
         PUT   SYSOUT,BUFLEN      PRINT THE LINE
         LA    R8,BUFFER+1        RESET OUTPUT POINTER
         LH    R9,LINELEN         AND LINE LENGTH
         TM    BPMRECFM,X'02'     MACHINE CTL DATA SET?
         BZR   R11                NO, RETURN
         MVC   BUFFER(1),NEXTCARR YES, INSERT BUFFERED CTL CHAR
         BR    R11                AND THEN RETURN
         SPACE
NOTYET   LA    R1,1(,R1)
         SR    R9,R1              ADJUST THE LENGTH LEFT IN LINE
         BR    R11                RETURN TO GET NEXT SEGMENT
         EJECT
***********************************************************************
*        THIS ROUTINE IS CALLED TO PRINT A DIAGNOSTIC MESSAGE. IT     *
*        ATTEMPTS TO WRITE THE MESSAGE TO SYSPRINT. IF SYSPRINT       *
*        CANNOT BE OPENED, IT USES WTP TO SEND THE MESSAGE INSTEAD.   *
***********************************************************************
         SPACE
ERRMSG   CLI   MSGOPEN,0          OPEN OF SYSPRINT ATTEMPTED?
         BNE   ALREADY            YES.
         OPEN  (MSGDCB,(OUTPUT))  NO, TRY IT NOW
ALREADY  TM    MSGOFLGS,X'10'     DID IT OPEN?
         BNZ   ERROPEN            YES.
         XWTO  MF=(E,(R2))        NO, SEND BY WTO
         BR    R11                AND RETURN TO CALLER
         SPACE
ERROPEN  MVI   2(R2),0            MAKE SURE V PREFIX OK
         PUT   MSGDCB,(R2)        PRINT THE MESSAGE
         BR    R11                AND RETURN
         EJECT
***********************************************************************
*        THIS ROUTINE IS A SYNAD EXIT FOR SYSLIB.  IF THE ERROR WAS   *
*        A LENGTH ERROR, A MESSAGE IS PRINTED AND THE RUN IS          *
*        TERMINATED. OTHERWISE, A FLAG IS SET AND RETURN IS MADE      *
*        TO THE SYSTEM. THIS WILL CAUSE TERMINATION OF PROCESSING     *
*        OF THE CURRENT MEMBER.                                       *
***********************************************************************
         SPACE
BPAMSYN  LR    R1,R0              MOVE DECB ADDR TO USABLE REG
         L     R1,16(,R1)         FIND THE IOB
         TM    12(R1),X'02'       UNIT CHECK?
         BNZ   ACCERR             YES, ALLOW CONTINUATION
         TM    13(R1),X'40'       NO, IS THIS A WRONG-LENGTH ERROR?
         BNZ   LENERR             YES, GO NO FURTHER
ACCERR   MVI   ERRFLAG,X'FF'      SET TROUBLE FLAG
         BR    R14                AND RETURN TO BPAM
         SPACE
LENERR   LA    R2,WRONGLEN
         BAL   R11,ERRMSG         SEND WRONG-LENGTH MSG
         LA    R15,16             TERMINAL ERROR
         B     ABORT              END THE PROGRAM
         SPACE 3
***********************************************************************
*        THIS ROUTINE IS A SYNAD EXIT FOR THE SYSLIB DIRECTORY.       *
*        IT PUTS OUT AN ERROR MESSAGE AND ABORTS THE JOB.             *
***********************************************************************
         SPACE
QSAMSYN  LA    R2,DIRERR
         BAL   R11,ERRMSG         SEND DIRECTORY ERROR MSG
         LA    R15,16             INDICATE HORRIBLE CONCLUSION
         B     ABORT
         SPACE 3
***********************************************************************
*        THIS ROUTINE ESTABLISHES A DEFAULT BLOCKSIZE FOR A PRINT DATA*
*        SET IF NONE IS SUPPLIED BY THE USER.                         *
***********************************************************************
         SPACE
         USING IHADCB,R1
OUTEX    LH    R0,DCBBLKSI        GET BLOCKSIZE FROM DCB
         LTR   R0,R0              IS IT THERE?
         BNZR  R14                YES, RETURN
         LA    R0,4               NO, USE LRECL+4
         AH    R0,DCBLRECL
         STH   R0,DCBBLKSI
         BR    R14                AND THEN RETURN
         EJECT
PACKPARM PACK  DECWORK(8),2(0,R11)     PACK THE PARM VALUE
TESTPARM NC    NUMERIC(0),2(R11)  AND THE PARM WITH 3C'0'
PARMSGMV MVC   PARMNAME(0),2(R11) PUT PARM VALUE INTO MSG
MVSEG    MVC   0(0,R8),0(R3)      MOVE TEXT TO PRINT LINE
         SPACE
SAVEAREA DC    18A(0)
JFCB     DS    CL176              SPACE FOR SYSLIB JFCB
DECWORK  DS    D                  DECIMAL WORK AREA
TTRZ     DC    F'0'               FOR POINT MACRO
MBLKSAVE DS    2A                 REGISTER SAVE AREA FOR DIRECTORY
QSAMXLST DCBEXLST JFCB=JFCB
OUTXLST  DCBEXLST DCBEXIT=OUTEX
         READ  DECB,SF,BPAMDCB,,'S',MF=L
BPAMDCB  DCB   DDNAME=SYSLIB,DSORG=PO,DEVD=DA,MACRF=(R),               *
               EODAD=BPAMEOD,BUFNO=2,SYNAD=BPAMSYN
QSAMDCB  DCB   DDNAME=SYSLIB,DSORG=PS,DEVD=DA,MACRF=(GM),              *
               EODAD=ENDDIR,BLKSIZE=256,LRECL=256,RECFM=F,             *
               SYNAD=QSAMSYN,EXLST=QSAMXLST
MSGDCB   DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=(PM),                    *
               LRECL=125,RECFM=VBA,EXLST=OUTXLST
SYSOUT   DCB   DDNAME=SYSOUT,DSORG=PS,MACRF=(PM),                      *
               LRECL=137,RECFM=VBA,EXLST=OUTXLST
SYSTOC   DCB   DDNAME=SYSTOC,DSORG=PS,MACRF=(PM),                      *
               LRECL=137,RECFM=VBA,EXLST=OUTXLST
PREVBUF  DC    A(0)               ADDR OF BUSY BUFFER
CURBUF   DC    A(0)               ADDR OF BUFFER IN USE
TTTAB1   DC    A(0)               FIRST-LEVEL TTR TABLE ADDR
LINEMAX  DC    H'55'              DEFAULT LINES PER PAGE
RETC     DC    H'0'               ULTIMATE RETURN CODE
LINELEN  DC    H'132'             DEFAULT LINE LENGTH
TOCPAGE  DC    H'0'               TABLE OF CONTENTS PAGE NUMBER
TOCLNCT  DS    H                  TABLE OF CONTENTS LINE NUMBER
BUFLEN   DC    2H'0'              LENGTH PART OF PRINT BUFFER
BUFFER   DC    CL133' '           DATA TO PRINT
DIRBLK   DS    CL256              DIRECTORY BLOCK AREA
NUMERIC  DC    C'000'             USED IN PARM VALIDATION
VARFORM  DC    X'00'              V FORMAT FLAG
SPANNED  DC    X'00'              SPANNED FORMAT FLAG
JDATE    DS    CL5                JULIAN DATE
GDATE    DC    CL6'000000'        GREGORIAN DATE
SEGTYPE  DC    X'00'              SPANNED SEGMENT TYPE
MSGOPEN  DC    X'00'              SYSPRINT OPEN ATTEMPT MADE FLAG
ERRFLAG  DC    X'00'              INPUT ERROR FLAG
ASATAB   DC    C'+ 0-'            RECFM M ASA EQUIVALENTS
NEXTCARR DC    C' '               NEXT LINE'S CTL CHAR
PAGE1    DC    X'00'              1ST PAGE FOR MEMBER FLAG
THROWAY  DC    X'00'              THROW AWAY REST OF LRECL FLAG
         PRINT NOGEN
THEADER1 XWTO  '1DIRECTORY OF DSN=',(TDSNAME,44' '),5' ',(CDATE,8),    *
               6' ',(CTIME,8),'     PAGE',(CPAGE,6' '),MF=L
THEADER2 XWTO  '0MEMBER    BEGIN PAGE    END PAGE   ERR   ALIAS NAMES',*
               MF=L
BLANKMSG XWTO  (BLANKS,16' '),MF=L
TOCLINE  XWTO  ' ',(TMEMBER,8),5' ',(TSTART,5),7' ',(TEND,5),          *
               5' ',(ERRSIGN,3' '),2' ',(TALSIGN,' '),(TALIAS1,90' '), *
               MF=L
TOCLEN   EQU   *-TOCLINE          LENGTH OF TOC LINE
HEADER   XWTO  '1',(STARTOF,8' '),' MEMBER ',(TITLMEM,8),'   DSN=',    *
               (DSNAME,44' '),5' ',(TDATE,'  /  /  '),5' ',            *
               (TTIME,X'4021204B20204B2020'),'     PAGE',              *
               (PAGENUM,6' '),MF=L
UNDERMSG XWTO  '+',(UNDRSCOR,120' '),MF=L
NOSYSLIB XWTO  ' UEB460T SYSLIB DD STATEMENT MISSING.  RUN TERMINATED',*
               ROUTCDE=11,DESC=7,MF=L
LIBNOP   XWTO  ' UEB461T UNABLE TO OPEN SYSLIB.  RUN TERMINATED',      *
               ROUTCDE=11,DESC=7,MF=L
PARMSG   XWTO  ' UEB462W INVALID PARM IGNORED: ',(PARMNAME,10' '),     *
               (DOTROOM,3' '),ROUTCDE=11,DESC=7,MF=L
NOUTPUT  XWTO  ' UEB463T UNABLE TO OPEN SYSTOC AND/OR SYSOUT.  RUN TERM*
               INATED',ROUTCDE=11,DESC=7,MF=L
IOMSG    XWTO  ' UEB464E INPUT ERROR.  LISTING OF MEMBER ',            *
               (MEMBERR,8),' TERMINATED',ROUTCDE=11,DESC=7,MF=L
WRONGLEN XWTO  ' UEB465T WRONG LENGTH RECORD.  THE SYSLIB DCB IS PROBAB*
               LY INCORRECT',ROUTCDE=11,DESC=7,MF=L
DIRERR   XWTO  ' UEB466T ERROR READING SYSLIB DIRECTORY.  RUN TERMINATE*
               D',ROUTCDE=11,DESC=7,MF=L
         EJECT
MEMBER   DSECT ,                  MAPPING FOR MEMBER TABLE ENTRY
         SPACE
MEMNAME  DS    CL8                NAME OF MEMBER
MEMTTR   DS    XL3                TTR FOR MEMBER
MEMFLAGS DS    BL1                PROCESSING FLAGS
         SPACE
$ALIAS   EQU   X'80'              MEMBER IS AN ALIAS
$PSMAIN  EQU   X'40'              ALIAS HAS NO MAIN MEMBER
$ERROR   EQU   X'20'              I/O ERROR IN MEMBER
         SPACE
MEMALIAS DS    A                  ADDR OF FIRST ALIAS FOR MEMBER
MEMPAGE1 DS    CL5                FIRST PAGE NUMBER
MEMPAGEN DS    CL5                FINAL PAGE NUMBER
         DS    0A                 FOR ALIGNMENT
MEMBLEN  EQU   *-MEMBER           LENGTH OF MEMBER ENTRY
         SPACE
ALIAS1   DSECT ,                  FIRST ALIAS ENTRY MAPPING
         SPACE
AL1CHAIN DS    A                  POINTER TO NEXT FOR THIS TTR
AL1MEMB  DS    A                  MEMBER ENTRY FOR THIS ALIAS
AL1MAIN  DS    A                  MAIN MEMBER FOR THIS ALIAS
AL1FIRST DS    A                  FIRST OTHER ALIAS
AL1LAST  DS    A                  LAST OTHER ALIAS
AL1LEN   EQU   *-ALIAS1           LENGTH OF FIRST ALIAS ENTRY
         SPACE
ALIAS2   DSECT ,                  OTHER ALIAS ENTRY MAPPING
         SPACE
AL2CHAIN DS    A                  POINTER TO NEXT OTHER ALIAS
AL2MEMB  DS    A                  MEMBER ENTRY FOR THIS ALIAS
AL2LEN   EQU   *-ALIAS2           LENGTH OF OTHER ALIAS ENTRY
         SPACE
PDSPRINT CSECT ,                  RESUME MAIN CSECT
         SPACE
MEMBLK   DC    A(0,0,MEMBLEN)     DESCRIPTOR FOR MEMBER ENTRIES
AL1BLK   DC    A(0,0,AL1LEN)      DESC. FOR FIRST ALIAS ENTRIES
AL2BLK   DC    A(0,0,AL2LEN)      DESC. FOR OTHER ALIAS ENTRIES
TT2BLK   DC    A(0,0,64)          DESC. FOR LEVEL 2 TTR TABLES
         SPACE
BLKCHAIN EQU   0                  OFFSET OF CHAIN FIELD IN BLK HDR
BLKNEXT  EQU   4                  OFFSET OF CURRENT ENTRY IN BLOCK
BLKEND   EQU   8                  OFFSET OF LAST ENTRY IN BLOCK
BLKDATA  EQU   12                 OFFSET OF DATA FROM BLOCK START
         EJECT
         DCBD  DSORG=(PO)
         SPACE
         PRINT GEN
         DCBEQU BPM,BPAMDCB,(RECFM,LRECL,BLKSI)
         DCBEQU MSG,MSGDCB,OFLGS
         END
