//GILBERTD JOB (ACCT#),SYSDEBUG,
//*RESTART=ASMH2,
// NOTIFY=&SYSUID,
// LINES=25,
// CLASS=A,MSGCLASS=X,COND=(0,NE),REGION=6M
//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)
*PROCESS NOBATCH,USING(WARN(8))
***********************************************************************
*                                                                     *
*       GSF-ENV DEBUGGING AID                                         *
*                                                                     *
*       This generalized ESTAE routine simplifies abend               *
*       resolution by formatting important MVS control                *
*       blocks in an easier-to-read fashion.                          *
*                                                                     *
*       This is not a system-wide debugging tool like ABEND-AID.      *
*       To use it, you must invoke it with the following              *
*       sequence:                                                     *
*                                                                     *
*                  LOAD  EP=SYSDEBUG                                  *
*                  LR    R15,R0                                       *
*                  BASSM R14,R15              invoke with AMODE31     *
*                                                                     *
*       Notes:                                                        *
*                                                                     *
*         1. This first invocation of the routine sets up a standard  *
*            recovery environment (ESTAE) to trap abends.             *
*                                                                     *
*         2. DO NOT try to replace LOAD/BASSM with LINK in the        *
*            invoking sequence.                                       *
*                                                                     *
*       The debugging routine may also be used from JCL,              *
*       without modifying the program, as follows:                    *
*                                                                     *
*         //MYSTEP  EXEC PGM=SYSDEBUG,                                *
*         //            ACCT=MYPROG,            <== program name      *
*         //            PARM=(a,b,c,d)          <== program's parm    *
*         //STEPLIB  DD DISP=SHR,DSN=GILBERT.LOAD                     *
*         //SYSDEBUG DD SYSOUT=*                                      *
*         //SYSUDUMP DD SYSOUT=*                                      *
*                                                                     *
*       The debugging report (written to DDN=SYSDEBUG) contains       *
*       the following data:                                           *
*                                                                     *
*         o  The abend PSW and registers                              *
*                                                                     *
*         o  The TCB tree and RB chains (if this is a multi-task step *
*                                                                     *
*         o  The RB chain of the abending TCB, in greater detail      *
*                                                                     *
*         o  The JPAQ and Load-list                                   *
*                                                                     *
*         o  The save-area chain (forward only)                       *
*                                                                     *
*         o  The TIOT (allocated DDs)                                 *
*                                                                     *
*         o  OPEN data sets (with current record)                     *
*                                                                     *
*       The debugging routine has a loop detection feature            *
*       that causes an U0322 abend if the program consumes            *
*       more that 5 seconds of CPU time without doing an IO.          *
*                                                                     *
***********************************************************************
&HDR  SETC 'GSF UTILITIES - SYSDEBUG R248'
      PUNCH ' SETSSI 02480000'
*$248 Add support for HLASM R3
*     Add support for JES2 OS 1.3.0
*$247 Title line displays date in YYYY-MM-DD format
*$246 Correct RECFM=U record length
*$245 Initialisation routine has been rewritten to no longer
*     require caller to provide addr of save area in R13.
*$244 Add support for callers in MODE=SUP and key 0-7
*     Minor changes to JOB card formatting routine
*     Locate DDname for JPAQ modules loaded from a PDSE
*$243 Allocate 4 pages below the line at initialization time.
*     Free-up 3 pages in recovery rtne to prevent GETMAIN failures.
*     Free-up all 4 pages if recovery invoked with R0=12 (no SDWA)
*$242 Use RTM2WA to distinguish between type-1 SVC and Program check
*     Inactivate ESPIE environment created by invoking pgm
*     Convert ESTAE to ESTAI if invoked from an SVC routine
*     Get addr of RMODE31 ACB from DEBRRQ
*$241 Do not display OPEN mode for VSAM ACB, it's meaningless
*     Do not issue U0322 abend if //DBGNO322 DD present in step's JCL
*     Prevent S30A-14 abend when invoked by a user in key 0-7
*     Retrieve buffer addr from ICB when chained scheduling is used
*     Implement NEXTLLE rtne to prevent stack overflow
*     Check for R0=12 on entry to recovery routine
*$240 Do not print lines with identical contents (PDUMP rtne)
*     Print PLH/RPL seq# when STRNO>1
*$239 Enhance JOB/STEP information reporting
*     Hash-code name to access CDX
*     Print all active PLHs if STRNO>1
*     Print contents of COM_REG area
*     Prevent S0C4 when IOBECBAD is bad
*     Provide support for QSAM buffers above the line (DFSMS/MVS)
*     Improve method to locate V/VB record in QSAM buffers
*$238 Prevent S806 when invoker doesn't set R13
*$237 Storage Allocation Table (using TCTCORE and LDA)
*     Some information from JOB and EXEC JCL statements
*$236 Use ESTAE instead of ESPIE to validate A(DYNAM31)
*$236 Convert DDN to DSN for JPAQ entries
*$235 Identify sub-tasks on TCB tree that have terminated already
*$234 Retrieve CDEX to display DDname for JPAQ modules
*$234 Flag Save Area pointed to by R13 at time of abend
*$233 Display contents of PARM field
*$232 Flag Abending RB, use NEXTRB routine
*$231 Display LABEL=(,SUL) if present on DD stmt for disk data sets
*$230 Display R14,R15,R0,R1 values for each RB
*$229 print RPLOPTCD options codes and DCBE
*$228 display attributes of SYSOUT data sets
*$227 Scan LPAQ in addition to JPAQ and LPAD
*$226 Display Reg1 for DATACOM subtask
*$225 Some modifications in VSAM control block display
*$224 Print SDWA at the end of the report
*$223 Identify OS/VS COBOL eye-catchers
*$222 Validate address of work area to prevent S0C4
*$220 Fixed bug in DUMP32 routine that prevented PLH/RPL display
*$212 Display current save area if not in fwd chain
*$211 Use NUCLKUP to enhance address identification
*$210 USE ONLY STANDARD MACRO LIBRARIES
*$209 IMPROVE SAVE AREA PROCESSING
*$208 GET RID OF @JDATE ROUTINE
*$206 ALLOW INVOCATION FROM JCL TO FRONT-END PGM
*$205 PRINT SYSOUT RCD FROM JES2 UNPROTECTED BUFFER
*$200 DO NOT USE SUBS SERVICES
***********************************************************************
SYSDEBUG CSECT                         MAIN CSECT
SYSDEBUG RMODE ANY                     MAIN CSECT
         USING *,R15
         B     BEGIN
*
*        Using the official ASMH/HLASM distinction trick,
*        simulate the SYSVER and SYSDATC variables
*        of HLASM when assembled under ASMH
*
         LCLA  &ASMH_HLASM
         AIF   (T'&ASMH_HLASM EQ 'N').ASMH1X
&SYSVER  SETC  'ASMH'
&SYSDATC SETC  '20'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
         AIF   ('&SYSDATC' LT '20900000').ASMH1X
&SYSDATC SETC  '19'.'&SYSDATE'(7,2)'&SYSDATE'(1,2)'&SYSDATE'(4,2)
.ASMH1X  ANOP
&STR     SETC  '&HDR &SYSDATC &SYSTIME'
&K       SETA  K'&STR
         DC    AL1(&K),C'&HDR &SYSDATC &SYSTIME',0H'0'
*---------------------------------------------------------------------*
*                                                                     *
*        Determine if recovery is already initialized for this task.  *
*        If it is, set R15 and R0 and goback to caller                *
*                                                                     *
*---------------------------------------------------------------------*
BEGIN    L     R1,PSATOLD-PSA          MY TCB
         USING TCB,R1
         ICM   R1,B'1111',TCBSTAB      FIRST SCB
         BZ    INIT12                  no SCB for this task, exit
         USING SCB,R1
         LA    R0,DEBUGAID             MY RECOVERY EXIT
*LOOP
INIT11B  CL    R0,SCBEXIT              IS THIS ME?
         BNE   INIT11N                 NO, EXIT
         L     R1,SCBXPTR              SCB EXTENSION
         LR    R15,R0                  A(DEBUGAID)
         BSM   R15,0                   set amode bit
         L     R0,SCBXPARM-SCBX(,R1)   PARM ADDRESS (DYNAM31)
         BSM   0,R14                   goback to caller
INIT11N  ICM   R1,B'1111',SCBCHAIN     NEXT SCB
         BNZ   INIT11B                 LOOP
*ENDLOOP
*---------------------------------------------------------------------*
*                                                                     *
*        Scan TIOT to see if a SYSDEBUG DD is allocated.              *
*        If it is allocated to a DD DUMMY, quit.                      *
*        If it is not allocated and we're under TSO, quit.            *
*                                                                     *
*---------------------------------------------------------------------*
INIT12   BALR  R15,0
         USING *,R15
         L     R1,PSATOLD-PSA          MY TCB
         USING TCB,R1
         L     R1,TCBTIO               TIOT
         USING TIOT1,R1
         SLR   R0,R0                   PREPARE IC
*LOOP
INIT12B  CLC   TIOEDDNM,DCBDDNAM-IHADCB+MODELDCB is this my ddname?
         BE    INIT12K                 yes, exit loop
         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY
         ALR   R1,R0                   BUMP UP TO NEXT ENTRY
         CLI   TIOELNGH,0              IS THIS THE END?
         BNZ   INIT12B                 NOT YET, LOOP THROUGH TIOT
*ENDLOOP
*
*        IF TSO AND DD MISSING, DO NOT ACTIVATE DEBUGGING
*
INIT12D  L     R1,PSAAOLD-PSA          MY ASCB
         L     R1,ASCBCSCB-ASCB(,R1)   MY CSCB
         LA    R0,1                    R0=1
         CLI   CHTRKID-CHAIN(R1),CHTSID  AM I A TSO USER?
         BE    INIT19                  YES, QUIT (R15=0,R0=1)
*
*        If //SYSDEBUG DD DUMMY, exit
*
INIT12K  BALR  R15,0                   (local base)
         USING *,R15
         TM    TIOELINK,TIOESSDS       SUB-system data set?
         BO    INIT20                  YES, continue
         ICM   R0,B'0111',TIOEFSRT     DD DUMMY?
         BNZ   INIT20                  no, continue
         DROP  R1                      TIOT
         LA    R0,2                    R0=2
*
*        Initialisation error: goback to caller with R15=0
*
INIT19   SLR   R15,R15                 YES, QUIT (R15=00)
         SLR   R1,R1                   R1=0
         BSM   0,R14
*---------------------------------------------------------------------*
*                                                                     *
*        Issue TESTAUTH to determine if we should take the            *
*        authorized or the non-authorized init path.                  *
*                                                                     *
*---------------------------------------------------------------------*
INIT20   BALR  R15,0                   (local base)
         USING *,R15
         TESTAUTH STATE=YES,RBLEVEL=1  Check PSW mode
         LTR   R15,R15                 running in mode=sup ?
         BALR  R15,0                   (local base)
         USING *,R15
         BNZ   INIT200                 no, jump
***********************************************************************
*                                                                     *
*        Authorized Initialisation Path (invoked with MODE=SUP)       *
*                                                                     *
*        1. GETMAIN protected save area (SP 252)                      *
*        2. Save caller's regs                                        *
*        3. Switch to TCB key                                         *
*        4. GETMAIN DYNAM31                                           *
*        5. GETMAIN DYNAM24                                           *
*        6. Issue ESTAE                                               *
*        7. Change ESTAE to ESTAI (if invoked from SVC routine)       *
*        8. Restore caller's regs and PSW key                         *
*        9. Free protected save area and goback to caller             *
*                                                                     *
***********************************************************************
INIT100  GETMAIN RU,LV=64,LOC=ANY,SP=252
         LR    R0,R2                   save R2 accross MODESET
         MODESET EXTKEY=ZERO,SAVEKEY=(2) switch to TCB key
         XR    R2,R0                   restore R2
         XR    R0,R2                   restore R2
         XR    R2,R0                   restore R2
         STM   R0,R15,0(R1)            save caller's regs and PSW key
         BALR  R11,0
         USING *,R11
         LR    R12,R1                  KEEP SAVE AREA ADDR
*
*        switch to TCB key
*
INIT101  L     R4,PSATOLD-PSA
         USING TCB,R4
         MODESET EXTKEY=TCB,WORKREG=2  switch to TCB key
*
INIT102  LA    R0,DYNAM31L-1
         GETMAIN RC,LV=(0),BNDRY=PAGE,LOC=ANY
         LTR   R15,R15                 GETMAIN OK?
         BNZ   INIT190                 no, quit
         LR    R13,R1                  pass address
         USING DYNAM31,R13
*
         BAL   R14,INIT900             allocate //SYSDEBUG DD
*
*        Allocate 4 pages below the line.  Most of this storage
*        is a place-holder which is FREEMAIN'd by the recovery
*        rtne when it is entered to prevent possible S80A or S878
*        abends during OPEN of the SYSDEBUG DCB.
*
         GETMAIN RC,LV=DYNAM24L,LOC=(BELOW,ANY)  RMODE24 WORK AREA
         LTR   R15,R15                 GETMAIN OK?
         BNZ   INIT190                 NO, GOBACK
         ST    R1,DYNAM24P             save A(DYNAM24)
*
*        Issue ESTAE
*
         ESTAE DEBUGAID,               RECOVERY ROUTINE                X
               CT,                     CREATE                          X
               PARAM=(R13),            PARAM FOR RECOVERY ROUTINE      X
               TERM=YES,               PROCESS CANCEL ABENDS           X
               MF=(E,ESTAEL)
         LTR   R0,R15                  ESTAE OK?
         BNZ   INIT190                 NO, GOBACK
*---------------------------------------------------------------------*
*                                                                     *
*        Convert the ESTAE to an ESTAI if I've been invoked from      *
*        an SVC routine.                                              *
*                                                                     *
*---------------------------------------------------------------------*
INIT130  L     R5,TCBRBP               MY PRB OR SVRB
         USING RBBASIC,R5
         LA    R0,130                  exit code
         TM    RBSTAB1,RBFTSVRB        running under an SVRB?
         BNO   INIT190                 NO, EXIT
*
INIT135  LA    R0,135                  exit code
         ICM   R6,B'1111',TCBSTAB      MOST RECENT SCB
         BZ    INIT190                 NO SCB, EXIT (very bizare!!!)
         USING SCB,R6
         LA    R15,DEBUGAID            exit addr without AMODE bit
         LA    R0,136                  exit code
         CL    R15,SCBEXIT             is this the addr of my exit?
         BNE   INIT190                 NO, QUIT
*---------------------------------------------------------------------*
*                                                                     *
*        Patch the SCB                                                *
*                                                                     *
*---------------------------------------------------------------------*
         BALR  R15,0
         USING *,R15
         MODESET EXTKEY=ZERO           switch to key zero
         STCM  R4,B'0111',SCBOWNRA     Associate SCB with TCB
         OI    SCBFLGS1,SCBSTAI        ESTAI
         NI    SCBFLGS2,255-SCBSUPER   MODE=PROB
         NI    SCBFLGS2,255-SCBKEY0    KEY=NZERO
*
*        Check if my SCB is the only one chained to my TCB.
*        If there are other SCBs on the queue, move my SCB
*        to the end of the queue to ensure I'm invoked last
*        and prevent S0C4 in IEAVTAS1.
*
         LA    R0,141                  exit code
         ICM   R2,B'1111',SCBCHAIN     ONLY SCB ON QUEUE?
         BZ    INIT190                 YES, EXIT
*LOOP
INIT144  LR    R1,R2                   PREVIOUS SCB
         ICM   R2,B'1111',SCBCHAIN-SCB(R1) LAST SCB ON QUEUE?
         BNZ   INIT144                 NO, LOOP MORE
*ENDLOOP
         ST    R6,SCBCHAIN-SCB(,R1)    MY SCB AT BOTTOM OF QUEUE
         MVC   TCBSTAB,SCBCHAIN        NEXT SCB AT TOP OF QUEUE
         XC    SCBCHAIN,SCBCHAIN       MY SCB IS LAST ON QUEUE
         LA    R0,145                  exit code
*---------------------------------------------------------------------*
*                                                                     *
*        Restore caller's environment and goback                      *
*                                                                     *
*---------------------------------------------------------------------*
         DROP
INIT190  BALR  R15,0
         USING *,R15
         L     R2,0(,R12)              R0 from protected save area
         MODESET KEYREG=(R2)           switch back to caller's key
         LR    R1,R12                  addr of protected save area
         LM    R2,R14,8(R12)           restore caller's R2-R14
*-DEL- R2,R0                           pass exit code
         FREEMAIN RU,LV=64,A=(R1),SP=252 free protected save area
*
         SLR   R15,R15                 R15=0
         BCTR  R15,0                   R15=-1
         SLR   R0,R0                   R0=0
         SLR   R1,R1                   R1=0
         BSM   0,R14                   goback to caller
         DROP
***********************************************************************
*                                                                     *
*        Non-Authorized Initialisation Path (invoked with MODE=PROB)  *
*                                                                     *
*        1. GETMAIN DYNAM31                                           *
*        2. save caller's regs in SAVER012                            *
*        3. GETMAIN DYNAM24                                           *
*        4. Issue ESTAE                                               *
*        5. Prime timer                                               *
*        6. Issue XCTL (if invoked from JCL)                          *
*        7. Restore caller's regs and goback (if invoked from pgm)    *
*                                                                     *
***********************************************************************
INIT200  BALR  R15,0
         USING *,R15
         LA    R0,DYNAM31L-1
         GETMAIN RC,LV=(0),BNDRY=PAGE,LOC=ANY
         DROP  R15
         LTR   R15,R15                 GETMAIN OK?
         BALR  R15,0
         BZ    INIT210-*(,R15)         no, quit
         SLR   R15,R15                 R15=0
         SLR   R0,R0                   R05=0
         SLR   R1,R1                   R1=0
         BSM   0,R14                   goback
*
INIT210  STM   R0,R15,SAVER012-DYNAM31(R1) save caller's regs
         LR    R13,R1                  A(DYNAM31)
         USING DYNAM31,R13
*
         BALR  R11,0
         USING *,R11
*
         BAL   R14,INIT900             allocate //SYSDEBUG DD
*
*        Allocate 4 pages below the line.  Most of this storage
*        is a place-holder which is FREEMAIN'd by the recovery
*        rtne when it is entered to prevent possible S80A or S878
*        abends during OPEN of the SYSDEBUG DCB.
*
         GETMAIN RC,LV=DYNAM24L,LOC=(BELOW,ANY)  RMODE24 WORK AREA
         LTR   R15,R15                 GETMAIN OK?
         BNZ   INIT209                 NO, QUIT
         ST    R1,DYNAM24P             save A(DYNAM24)
*
*        Issue ESTAE XCTL=YES
*
         ESTAE DEBUGAID,               RECOVERY ROUTINE                X
               CT,                     CREATE                          X
               PARAM=(R13),            PARAM FOR RECOVERY ROUTINE      X
               TERM=YES,               PROCESS CANCEL ABENDS           X
               XCTL=YES,               STAY ACTIVE ACROSS XCTL         X
               MF=(E,ESTAEL)
         LA    R0,X'0020'              RETCODE FOR XCTL/STACK CONFLICT
         CLR   R15,R0                  XCTL/STACK CONFLICT?
         BNE   INIT220                 NO, CONTINUE
*
*        Issue ESTAE XCTL=NO if there is at least a stack entry active
*
         ESTAE DEBUGAID,               RECOVERY ROUTINE                X
               CT,                     CREATE                          X
               PARAM=(R13),            PARAM FOR RECOVERY ROUTINE      X
               TERM=YES,               PROCESS CANCEL ABENDS           X
               MF=(E,ESTAEL)
         LTR   R15,R15                 ESTAE OK?
         BZ    INIT220                 yes, jump
*
INIT209  LM    R2,R14,SAVER012+8       restore caller's registers
         SLR   R15,R15                 R15=0
         SLR   R0,R0                   R05=0
         SLR   R1,R1                   R1=0
         BSM   0,R14                   goback
*---------------------------------------------------------------------*
*                                                                     *
*        Set-up timer for loop detection                              *
*                                                                     *
*---------------------------------------------------------------------*
INIT220  L     R4,PSATOLD-PSA          my TCB
         USING TCB,R4
         L     R5,TCBRBP               MY PRB OR SVRB
         USING RBBASIC,R5
         CL    R4,RBLINK               FIRST AND ONLY PRB IN CHAIN?
         BNE   INIT250                 NO, DO NOT SET TIMER
         DEVTYPE =C'DBGNO322',WKCELL1
         LTR   R15,R15                 //DBGNO322 DD specified?
         BZ    INIT250                 YES, DO NOT SET TIMER
         L     R1,TCBFSA               FIRST SAVE AREA
         MVI   044(R1),255             FOR U322, JUST IN CASE . . .
         SYNCH U322SET                 PRIME THE U322 PUMP
*---------------------------------------------------------------------*
*                                                                     *
*        XCTL TO PGMNM IN ACCT FIELD                                  *
*                                                                     *
*        //GO EXEC PGM=SYSDEBUG,ACCT=USERPROG,PARM=(USER-PARM)        *
*                                                                     *
*---------------------------------------------------------------------*
INIT250  CL    R4,TCBJSTCB             Is this the JOB-STEP TCB ?
         BNE   INIT290                 NO, GOBACK
         CLC   TCBFSA,SAVER012+R13*4   AM I INVOKED THRU JCL?
         BNE   INIT290                 NO, GOBACK
         L     R5,TCBRBP               POINT TO MY PRB
         SLR   R6,R6
         ICM   R6,B'0111',RBCDE1       Do we have a CDE?
         BZ    INIT290                 NO, GOBACK
         USING CDENTRY,R6
         CLC   CDENTPT,=A(SYSDEBUG+X'80000000')                        +
                                       Current PRB pointing at myself?
         BNE   INIT290                 NO, GOBACK
         MVC   SAVER012(8),RBGRSAVE    PASS R0-R1
*
         L     R5,TCBJSCB              MY JSCB
         USING IEZJSCB,R5
         LOAD  EPLOC=JSCBPGMN          BUMP MY USE COUNT FOR XCTL
         L     R6,JSCSCT               MY SCT
         USING SCT,R6
         SLR   R7,R7
         ICM   R7,B'0111',SCTAFACT     ACCOUNT DATA
         USING IEFAACTB-16,R7
         LA    R14,WKCELL1             8-BYTE WORK AREA
         LA    R15,L'WKCELL1           LENGTH
         LA    R0,ACTACCNT+1           FIRST ACCOUNT FIELD
         L     R1,=X'40000000'         PADDING
         IC    R1,ACTACCNT+0           LENGTH OF PGM NAME
         MVCL  R14,R0                  MOVE PGM NAME
         LA    R15,WKCELL2             WORK AREA
         LA    R0,WKCELL1              PGM NAME
         SLR   R1,R1
         STM   R0,R1,0(R15)            XCTL LIST
         LM    R0,R14,SAVER012         restore caller's registers
         XCTL  SF=(E,(15))             EXECUTE TARGET PROGRAM
         DROP  R4,R5,R6,R7
*
*        ESTAE executed, set R15/R0 and go back to caller
*
INIT290  LA    R15,DEBUGAID            R15=A(DEBUGAID)
         BSM   R15,0                   SET AMODE BIT
         LA    R0,DYNAM31              R0=A(DYNAM31)
         SLR   R1,R1                   R1=0
         LM    R2,R14,SAVER012+8       restore caller's registers
         BSM   0,R14                   GOBACK, PASS R15-R0
         DROP
*---------------------------------------------------------------------*
*                                                                     *
*        ALLOCATE SYSOUT DATA SET                                     *
*                                                                     *
*---------------------------------------------------------------------*
INIT900  BALR  R15,0
         USING *,R15
         LA    R1,TENWORDS-DYNAM31(,R13) WORK AREA FOR DYNALLOC
         XC    0(20,R1),0(R1)          CLEAR STORAGE
         MVI   0(R1),20                LENGTH
         MVI   1(R1),1                 VERB=ALLOC
         LA    R0,INIT9900             TEXT UNIT POINTERS
         ST    R0,8(,R1)               S99TUPTR
         ST    R1,20(,R1)              WORK AREA ADDRESS
         LA    R1,20(,R1)              S99RBPTR
         OI    0(R1),X'80'             S99RBPTR
         SVC   99                      ALLOCATE SYSDEBUG
         BR    R14                     continue
*
INIT9900 DC    A(INIT9901,INIT9918,INIT9952+X'80000000')
INIT9901 DC    AL2(1,1,8),C'SYSDEBUG'  DDNAME
INIT9918 DC    X'0018,0000'            SYSOUT=*
INIT9952 DC    X'0052,0000'            PERMANENTLY ALLOCATED
*---------------------------------------------------------------------*
*                                                                     *
*        LOOP DETECTOR (ABENDU0322 AFTER 5 SECONDS OF CPU WITHOUT I/O)*
*                                                                     *
*        Uses the R6 slot of the 1st save area to hold the EXCP count *
*                                                                     *
*---------------------------------------------------------------------*
U322SET  SAVE  (14,12),,DEBUG.U322SET  SAVE REGISTERS
         LR    R3,R15                  LOCAL BASE
         USING U322SET,R3
         L     R4,PSATOLD-PSA          MY TCB
         L     R5,PSAAOLD-PSA          MY ASCB
         L     R0,ASCBIOSC-ASCB(,R5)   CURRENT EXCP COUNT
         L     R1,TCBFSA-TCB(,R4)      FIRST SAVE AREA
         CL    R0,044(,R1)             SAME EXCP COUNT ?
         BE    U322ABND                YES, ABEND
         ST    R0,044(,R1)             SAVE EXCP COUNT INTO R6 SLOT
         STIMER TASK,U322SET,BINTVL=U322TIME
U322EXIT RETURN (14,12)                GOBACK TO FLIH
*
U322ABND L     R6,TCBRBP-TCB(,R4)      POINT TO MY RB (TIRB)
         LM    R0,R15,RBGRSAVE-RBBASIC(R6)  LOOPING PROGRAM'S REGISTERS
         BALR  R1,0
         ICM   R1,B'1111',U322CODE-*(R1)    LOAD ABEND CODE
         CNOP  6,8
         SVC   13                      ISSUE ABEND SVC
U322TIME DC    F'00500'                TIMER INTVL IN 1/100 OF A SECOND
U322CODE DC    X'80',FL3'322'          ABEND 0322,DUMP
         DROP
*
***********************************************************************
*                                                                     *
*        DEBUGGING ROUTINE                                            *
*                                                                     *
***********************************************************************
*
DEBUGAID LA    R15,012                 R0=12 means 'NO SDWA ALLOCATED'
         CLR   R0,R15                  SDWA ALLOCATED?
         BALR  R15,0                   LOCAL BASE
         USING *,R15
         BNE   DEBUGAID4               YES, JUMP
         USING DYNAM31,R2
         L     R1,DYNAM24P             ADDR OF MY 24-BIT WORK AREA
         LA    R1,DYNAM24H-DYNAM24(,R1) addr of place-holder
         FREEMAIN RC,LV=L'DYNAM24H,A=(1) free place holder
         LA    R13,SAVER012            save area
         LA    R0,12                   restore R0 contents
         DROP  R2,R15                  DYNAM31
*
DEBUGAID4 BALR R15,0                   set base reg for SAVE macro
         SAVE  (14,12),,'&HDR ESTAE &SYSDATC &SYSTIME'
         BALR  R11,0
         USING *,R11
         LR    R8,R1                   SDWA address
         USING SDWA,R8
         L     R9,PSATOLD-PSA          MY TCB
         USING TCB,R9
*
*        If I was invoked without an SDWA, copy RTM2's SDWA
*        into a work area
*
         CH    R0,=H'12'               did we get an SDWA from RTM2?
         BNE   DEBUGAID8               yes, jump
         USING DYNAM31,R2
         L     R3,TCBRTWA              RTM2WA
         USING RTM2WA,R3
         L     R14,RTM2SDW2            RTM2's SDWA
         LH    R15,SDWALNTH+1-SDWA(,R14) length of the SDWA
         LA    R0,D31SDWA              my own SDWA
         LA    R1,L'D31SDWA            my own SDWA
         MVCL  R0,R14                  move RTM2 SDWA to my work area
         LA    R8,D31SDWA              my own SDWA
         ST    R2,SDWAPARM             A(DYNAM31)
         OI    SDWAPARM,X'80'          prevent freemain
         MVC   SDWAEC1,RTM2EPSW        error psw
         MVC   SDWAAEC1,RTM2AEC1       additional error information
         MVC   SDWAEC2,RTM2EPSW        error psw
         MVC   SDWAABCC,RTM2CODE       completion code
         MVC   SDWAGRSV,RTM2EREG       REGISTERS AT TIME OF ABEND
         MVC   SDWAFLGS,RTM2FLGS       PASS FLAGS
         DROP  R2,R3                   DYNAM31,RTM2WA
DEBUGAID8 EQU  *
*
         CLC   =X'222000',SDWACMPC     CANCEL COMMAND?
         BE    GOBACK8                 YES, QUIT
*
         CLI   SDWARCDE,0              return code set by previous     +
                                       recovery routine?
         BNE   GOBACK9                 YES, QUIT
*
*        Inactivate any ESPIE environment created earlier
*        which could interfere with the trapping of my
*        own addressing and protection exceptions.
*
         ICM   R0,B'1111',TCBPIE       any ESPIE created earlier?
         BZ    ESPIE12                 no, exit
         TESTAUTH KEY=YES,STATE=YES,RBLEVEL=1    Check PSW key
         LTR   R15,R15                 running in mode=sup or key 0-7 ?
         BZ    ESPIE12                 yes, exit
         ESPIE SET,MF=(E,ESPIE11L)     Override existing PICA
         B     ESPIE12
ESPIE11L ESPIE SET,ESPIE11X,MF=L       INTERRUPT MASK ALL ZERO
ESPIE11X LR    R0,R1                   save addr of EPIE
         ICM   R1,B'1111',ESPIE11Z-ESPIE11X(R15)   get completion code
         ABEND (1)                     ABEND0C0
ESPIE11Z DC    X'80,0C0000'            S0C0 completion code
ESPIE12  EQU   *
*
*        Chain save areas
*        Use ESTAE to trap S0C4 if A(DYNAM31) is invalid
*
NEW_SAVE ESTAE ESPIEXIT,CT             RECOVERY ROUTINE
         L     R2,SDWAPARM             =A(DYNAM31)
         ST    R2,8(,R13)              bwd chain
         ST    R13,4(,R2)              fwd chain
         LR    R13,R2                  A(DYNAM31)
         USING DYNAM31,R13
         ESTAE 0                       PARM LOOKS GOOD, RESET MY ESPIE
*
DUMPOPT  TM    SDWACMPF,SDWAREQ        DUMP REQUESTED?
         BNO   ESTAE2                  NO, JUMP
         OI    SDWADPFS,SDWADLST       DUMP OPTIONS VALID
         MVC   SDWADDAT,=X'0F00,AF00'  MOVE SDATA/PDATA
         TM    SDWAMWP1,SDWAPGM1       Abend in SUPVR mode?
         BO    ESTAE2                  NO, JUMP
         OI    SDWASDA0,SDWALSQA       yes, dump LSQA too
*
ESTAE2   ESTAE RETRY00,                RECOVERY ROUTINE                X
               CT,                     CREATE                          X
               PARAM=DYNAM31,          PARAM FOR RECOVERY ROUTINE      X
               MF=(E,ESTAEL)
*
SETK7    TESTAUTH KEY=YES,STATE=YES,RBLEVEL=1    Check PSW key
         LTR   R15,R15                 caller in system key?
         BNZ   OPENDCB                 no, jump
         MODESET KEY=NZERO,MODE=SUP    yes, switch to a safe key
*
OPENDCB  L     R12,DYNAM24P            ADDR OF MY 24-BIT WORK AREA
         USING DYNAM24,R12
         LA    R1,DYNAM24H             place-holder (last 3 pages)
         FREEMAIN RC,LV=L'DYNAM24H,A=(1)   free place holder
         MVC   DCBDEBUG(DCBLNGQS),MODELDCB   MOVE MODEL DCB
         LA    R0,DCBDEBUG             OPEN LIST
         ST    R0,OPENLIST             OPEN LIST
         MVI   OPENLIST,X'8F'          OPEN LIST
         OPEN  MF=(E,OPENLIST)         OPEN MY DCB
*
         SLR   R0,R0                   R0=0
         BCTR  R0,0                    R0=-1
         ST    R0,MASKADDR             X'FFFFFFFF'
*
         MVI   TRTPRINT,C' '           PRINTABLE CHARACTERS
         MVC   TRTPRINT+1(255),TRTPRINT
         MVC   BLANKS,TRTPRINT         KEEP BLANKS
         SLR   R15,R15
         SLR   R0,R0
         BAL   R1,TRTPRT2
         DC    X'4A,7,5A,8,6A,6,7A,6'  Special characters
         DC    X'81,9,91,9,A2,8'       Lowercase
         DC    X'C1,9,D1,9,E2,8'       Uppercase
         DC    X'F0,A'                 Digits
         DC    X'00,0'                 end of table
*LOOP
TRTPRT2  IC    R15,0(,R1)              FIRST BYTE
         IC    R0,1(,R1)               ITERATIONS
*--LOOP
TRTPRT3  STC   R15,TRTPRINT(R15)       STORE X'4A' INTO TRTPRINT+X'4A'
         LA    R15,1(,R15)             BUMP INDEX
         BCT   R0,TRTPRT3              NEXT CHARACTER
*--ENDLOOP
         LA    R1,2(,R1)               NEXT ENTRY IN TABLE
         CLI   0(R1),0                 END OF TABLE?
         BNE   TRTPRT2                 NEXT STRING
*ENDLOOP
*
         BAL   R14,DIAG000         <== SET TITLE, DIAGNOSE
         BAL   R14,PSW00           <== PRINT PSW, GPRS
         BAL   R14,JOBSTEP         <== PRINT JOB/STEP DATA
         BAL   R14,PRB00           <== PRINT RB CHAIN
         BAL   R14,PGM00           <== PRINT JPAQ AND LOAD LIST
         BAL   R14,COMREG00        <== PRINT COM_REG area
         BAL   R14,LINK00          <== PRINT SAVE AREA TRACE
         BAL   R14,TIOT00          <== PRINT DATA SET ALLOCATIONS
         BAL   R14,DEB000          <== PRINT OPEN DATA SETS
*TEST    BAL   R14,PRWA00          <== PRINT SDWA
*
         CLOSE MF=(E,OPENLIST)         CLOSE DEBUG DD
         MVI   DCBBUFNO-IHADCB+DCBDEBUG,00
         FREEPOOL DCBDEBUG
         ESTAE 0                       DELETE RECOVERY ROUTINE
*
*----------------------------------------------------------------------
*
*        GOBACK TO RTM
*
*              Free working-storage (unless hi-order bit is on)
*
*----------------------------------------------------------------------
*
GOBACK   L     R0,DYN_TCB              getmain tcb
         LR    R1,R13                  A(DYNAM31)
         L     R13,4(,R13)             caller's save area
         TM    SDWAPARM,X'80'          hi-order bit on?
         BO    GOBACK7                 yes, skip freemain
         CL    R0,PSATOLD-PSA          is this the right TCB?
         BNE   GOBACK7                 no, skip freemain
         LA    R0,DYNAM31L-1           length of dynamic storage area
         FREEMAIN RU,LV=(0),A=(1)      free dynamic storage
*
GOBACK7  TESTAUTH KEY=YES,STATE=YES,RBLEVEL=1    Check PSW key
         LTR   R15,R15                 caller in system key?
         BNZ   GOBACK8                 no, jump
         MODESET KEY=ZERO,MODE=PROB    yes, switch to KEY=0
*
GOBACK8  SETRP WKAREA=(R8),            SDWA address                    X
               RC=00                   Continue with abend
GOBACK9  RETURN (14,12)                go back to R/TM
*
*----------------------------------------------------------------------
*
*        RETRY ROUTINE (FOR ESPIE)
*
*----------------------------------------------------------------------
*
ESPIEXIT SAVE  (14,12),,*              save registers
         BALR  R2,0                    local base
         USING *,R2
*WTO 'ESPIEXIT ENTERED'
         SETRP RETADDR=ESPIEBAD,RC=4,  <== RETRY                       X
               FRESDWA=YES,RETREGS=YES,                                X
               DUMP=NO,                suppress dump                   X
               REGS=(14,12)            restore registers
         DROP  R2
*
ESPIEBAD ESTAE 0                       RESET MY ESPIE
         SETRP WKAREA=(R8),            SDWA address                    X
               REGS=(14,12),           restore registers               X
               RC=00                   Continue with abend
*
MODELDCB DCB   DSORG=PS,MACRF=PM,DDNAME=SYSDEBUG,                      X
               RECFM=FBA,LRECL=121,BUFNO=1
*----------------------------------------------------------------------
         MACRO
&NAME    BEGIN_PROC &SAVE=YES
         GBLC  &#PROC
&#PROC   SETC  'IHB&SYSNDX'
$LTORG   LOCTR
&NAME    BAL   R15,BEGIN_PROC          BRANCH TO RELAY CODE
         DC    Y(&#PROC.A-*)           OFFSET TO FAR CODE
         AIF   ('&SAVE' EQ 'NO').NOSAVE
DYNAM31  DSECT
DYN31FAR LOCTR
&#PROC.S DS    2F                      SAVE AREA FOR R14 AND R10
$FARRTNE LOCTR
&#PROC.A LR    R15,R10                 BASE REG
         STM   R14,R15,&#PROC.S        SAVE REGISTERS
         BALR  R10,0
         USING *,R10
         MEXIT
.NOSAVE  ANOP
$FARRTNE LOCTR
&#PROC.A DS    0H
         USING *,R15
         MEND
         MACRO
&NAME    END_PROC &RC=
         GBLC  &#PROC
&NAME    L     R14,&#PROC.S            RESTORE LINKAGE REGISTER
         L     R10,&#PROC.S+4          RESTORE BASE REGISTER
         BR    R14
&SYSECT  LOCTR                         MAIN CODE
         MEND
*----------------------------------------------------------------------
         MACRO                                                    MACRO
&REF    #SETMASK &AMODE                                           MACRO
&REF     MVI   MASKADDR,X'7F'          X'7FFFFFFF'                MACRO
         TM    &AMODE,X'80'            CHECK AMODE BIT            MACRO
         BO    *+8                     AMODE31, JUMP              MACRO
         MVI   MASKADDR,X'00'          X'00FFFFFF'                MACRO
         MEND                                                     MACRO
*----------------------------------------------------------------------
         MACRO                                                    MACRO
&NAME   #S0C4  &ERRET,&PUSH                                       MACRO
         AIF   ('&ERRET' EQ 'RESET').RESET                        MACRO
         AIF   ('&ERRET' EQ 'POP').POP                            MACRO
&DD      SETC  '(&ERRET-RETRY11)'                                 MACRO
         AIF   ('&PUSH' EQ 'PUSH').PUSH                           MACRO
&NAME    MVI   #RETRY+0,&DD/256
         MVI #RETRY+1,&DD-((&DD/256)*256)
         MEXIT                                                    MACRO
.PUSH    ANOP                                                     MACRO
&NAME    MVC   #RETRY+2,#RETRY         push current address
         MVI   #RETRY+0,&DD/256
         MVI #RETRY+1,&DD-((&DD/256)*256)
         MEXIT                                                    MACRO
.RESET   ANOP                                                     MACRO
&NAME    MVI   #RETRY+0,0              RESET RETRY ADDRESS
         MEXIT                                                    MACRO
.POP     ANOP                                                     MACRO
&NAME    MVC   #RETRY,#RETRY+2         pop previous address
         MVI   #RETRY+2,0              RESET RETRY ADDRESS
.MEND    MEND                                                     MACRO
*----------------------------------------------------------------------
$LTORG   LOCTR                         ADDRESSABLE CODE
$FARRTNE LOCTR                         FAR ROUTINES
         SPLEVEL SET                   SET &SYSSPLV SYMBOL
         GBLC  &SYSSPLV                MVS/SP LEVEL
*
*----------------------------------------------------------------------
*
*        ABEND-SPECIFIC DIAGNOSTIC INFORMATION
*
*              FORMAT AND DISPLAY ABEND-CODE
*              LOCATE LAST PRB, FIRST SVRB
*              DETERMINE IF THIS IS AN OPEN/CLOSE/EOV (OCE) ABEND
*              INVOKE THE CORRESPONDING DIAGNOSIS ROUTINE
*
*----------------------------------------------------------------------
*
DIAG000  BEGIN_PROC
         L     R5,TCBRD                REGION DESCRIPTOR
         LM    R0,R1,RDSTART-RD(R5)    START/LENGTH OF MY REGION
         ALR   R1,R0                   START/END OF MY REGION
         STM   R0,R1,REGION24          START/END OF MY REGION
******   MVC   CURR_R13,RBGRS13        keep addr of current save area
******  #SETMASK RBOPSW+4              SET ADDRESS CLEAN-UP MASK
         MVC   CURR_R13,SDWAGR13       keep addr of current save area
        #SETMASK SDWANXT1              SET ADDRESS CLEAN-UP MASK
         NC    CURR_R13,MASKADDR       clean-up
*
*        BUILD A FAKE PSW2 IF PSW1=PSW2 OR PSW2=ZERO            @910624
*
         MVC   ORIGIN2,BLANKS          ORIGIN OF PSW2 IS SDWAEC2
         LM    R0,R1,SDWAEC2           pick up PSW2
         ALR   R0,R1                   PSW2=ZERO?
         BZ    DIAG005                 YES, JUMP
         CLC   SDWAEC1,SDWAEC2         PSW1=PSW2?
         BNE   DIAG010                 NO, QUIT
DIAG005 #S0C4  DIAG010
         L     R1,SDWAGR13             VALIDATE CALLER'S R13
         L     R1,4(,R1)               CALLER'S SAVE AREA
         CLC   0(72,R1),0(R1)          VALIDATE CALLER'S SAVE AREA
        #S0C4  RESET
         C     R1,TCBFSA               IS THIS THE FIRST SAVE AREA?
         BE    DIAG010                 YES, JUMP
         MVC   ORIGIN2,=C'  (HSA)'     ORIGIN OF PSW2 IS HIGH-SA
         MVC   SDWASR00(4*13),20(R1)   MOVE R0-R12
         ST    R1,SDWASR13             STORE R13
         MVC   SDWASR14(4*2),12(R1)    MOVE R14-R15
         MVC   SDWANXT2,12(R1)         USE R14 AS NEXT ADDRESS
         XC    SDWAAEC2(4),SDWAAEC2    ZERO ILC, INTC
*
*        BUILD RB CHAIN IN REVERSE ORDER
*
DIAG010  L     R6,TCBRBP               TOP OF RB CHAIN (MOST RECENT RB)
         LR    R0,R6                   POINT TO BASIC SECTION
         SH    R0,=Y(RBBASIC-RBPREFIX) POINT TO RBPREFIX
         ST    R0,MY_PRB               MY RBPREFIX
         SLR   R6,R6                   first time switch for NEXTRB
*
*        GET ADDR OF LAST PRB, FIRST SVRB, ABEND SVRB.
*
*LOOP
DIAG031  BAL   R14,NEXTRB              GET RB ADDRESS
         LTR   R6,R6                   eof?
         BZ    DIAG035                 yes, exit
         CL    R6,MY_PRB               END OF CHAIN?
         BE    DIAG035                 yes, exit
         USING RBPREFIX,R6
         CLI   RBSTAB1,RBFTPRB         IS THIS A PRB?
         BNE   DIAG031S                NO, JUMP
         ICM   R0,B'1111',FRSTSVRB     SET ALREADY?
         BNZ   DIAG031S                YES, JUMP
         ST    R6,LASTPRB              SAVE ADDR OF LAST PRB
*
DIAG031S TM    RBSTAB1,RBFTSVRB        IS THIS AN SVRB?
         BZ    DIAG031N                NO, JUMP
         ICM   R0,B'1111',FRSTSVRB     SET ALREADY?
         BNZ   DIAG031A                YES, JUMP
         ST    R6,FRSTSVRB             SAVE ADDR OF FIRST SVRB
*LOOP
DIAG031A TM    RBFLAGS1,RBABEND        IS THIS THE ABEND SVRB?
         BZ    DIAG031N                NO, JUMP
         ICM   R0,B'1111',ABNDSVRB     SET ALREADY?
         BNZ   DIAG031N                YES, JUMP
         ST    R6,ABNDSVRB             SAVE ADDR OF ABEND SVRB
*
DIAG031N B     DIAG031                 NEXT ENTRY IN RB STACK
*ENDLOOP
DIAG035  L     R6,LASTPRB              LAST PRB
         MVI   OCE_CODE,C'O'           ABEND DURING OPEN
         CLI   RBWLIC+3,19             O/C/E SVC?
         BE    DIAG040                 YES, JUMP
         CLI   RBWLIC+3,22             O/C/E SVC?
         BE    DIAG040                 YES, JUMP
         MVI   OCE_CODE,C'C'           ABEND DURING CLOSE
         CLI   RBWLIC+3,20             O/C/E SVC?
         BE    DIAG040                 YES, JUMP
         MVI   OCE_CODE,C'E'           ABEND DURING EOV
         CLI   RBWLIC+3,55             O/C/E SVC?
         BE    DIAG040                 YES, JUMP
         MVI   OCE_CODE,00
         DROP  R6                      RBPREFIX
*
DIAG040  STRING 'ABEND U',(SDWACMPC+1,H,R4Z),INTO=ABCODE ABEND=U0046
         CLC   =X'000F',SDWACMPC       SYSTEM CODE ALL ZEROES?
         BNL   DIAG044                 YES, JUMP
         STRING (SDWACMPC,,X),INTO=WKCELL1
         STRING 'ABEND S',(WKCELL1,3),'-',(SDWAGR15+3,1,X),            X
               INTO=ABCODE             ABEND=SD37-04
         TM    SDWAERRA,SDWASVCD       TASK ISSUED SVC 13?
         BNO   DIAG042                 NO, JUMP
         TM    SDWACMPF,SDWARCF        REASON-CODE SPECIFIED?
         BO    DIAG044                 YES, JUMP
         ICM   R15,B'1111',SDWAGR15    R15=00?
         BZ    DIAG042                 YES, JUMP
         ICM   R15,B'1110',SDWAGR15    R15>FF?
         BZ    DIAG044                 NO, JUMP
DIAG042  MVC   ABCODE+10(3),BLANKS     GET RID OF '-04'
*
DIAG044  L     R15,TCBTIO              MY TIOT
         LA    R1,MSG60
         MVC   MSG60,BLANKS
         MVC   0(8,R1),0(R15)          JOBNAME
         CLI   16(R15),C' '
         BNH   DIAG046
         LA    R1,1(,R1)
         CLI   0(R1),C' '
         BNE   *-8
         MVI   0(R1),C'.'
         MVC   1(8,R1),16(R15)         PROCSTEP
DIAG046  LA    R1,1(,R1)
         CLI   0(R1),C' '
         BNE   *-8
         MVI   0(R1),C'.'
         MVC   1(8,R1),8(R15)          STEPNAME
         TIME  DEC
         STM   R0,R1,WKCELL1           TIME, DATE
*
DIAG050  L     R1,CVTPTR               CVT ADDRESS
         USING CVTMAP,R1
         MVI   SPLEVEL,1               MVS/370                      370
         TM    CVTDCB,CVTMVSE          XA FLAG ON?
         BNO   DIAG055                 NO, JUMP
         MVI   SPLEVEL,2               MVS/XA
         AIF   ('&SYSSPLV' LT '3').DIAG55      MVS/XA MACLIB, JUMP
         TM    CVTDCB,CVTOSEXT         CHECK OSLVL EXTENSION
         BNO   DIAG055                 NO, JUMP
         TM    CVTOSLVL,CVTXAX         CHECK FOR ESA FLAG
         BNO   DIAG055                 NO, JUMP
         MVI   SPLEVEL,3               MVS SP/3
         AIF   ('&SYSSPLV' LT '4').DIAG55      ESA V3 MACLIB, JUMP
         TM    CVTOSLVL,CVTH4410       CHECK FOR ESA V4 FLAG
         BNO   DIAG055                 NO, JUMP
         MVI   SPLEVEL,4               MVS SP/4
.DIAG55  ANOP
DIAG055  SH    R1,=Y(CVTMAP-CVTFIX)    POINT TO CVT PREFIX
         USING CVTFIX,R1
         STRING '1&HDR - ',ABCODE,5X,(MSG60,,L),                       X
               3X,(WKCELL1+4+1,1,X),'.',(WKCELL1+4+2,P,R3Z), YY.DDD    X
               2X,(WKCELL1+4,P,YYYY-MM-DD),            YYYY-MM-DD      X
               2X,(WKCELL1,1,X),':',(WKCELL1+1,1,X),                   X
               2X,(CVTMDL,,X),2X,CVTPRODN,                             X
               INTO=TITLE121
         MVC   LINE121,TITLE121        TITLE LINE
         MVI   RLINES,0                RESET LINE COUNTER
         BAL   R14,SPACE1          <== Print line
         DROP  R1                      CVTFIX
*
*        INVOKE ABEND-SPECIFIC DIAG ROUTINE
*
DIAG060  LA    R1,DIAG094              INDEX
         LA    R14,0008                TABLE ENTRY
         LA    R15,DIAG095             LIMIT FOR BXLE
*LOOP
DIAG062  CLC   ABCODE+6(4),4(R1)       COMPARE ABEND CODE
         BE    DIAG066                 FOUND, JUMP
         BXLE  R1,R14,DIAG062
*ENDLOOP
         LA    R15,S0C0                PROGRAM CHECK RTNE
         TM    SDWAERRA,SDWAPCHK       IS THIS A PROGRAM CHECK?
         BO    DIAG067                 YES, JUMP
         LA    R15,S013                O/C/E ABEND RTNE
         CLI   OCE_CODE,0              IS THIS AN OPEN/CLOSE/EOV ABEND?
         BNE   DIAG067                 YES, JUMP
         B     DIAG999                 NO DIAG FOR THIS ABEND
*
DIAG066  L     R15,000(,R1)            ADDR OF DIAG RTNE
DIAG067  BALR  R14,R15             <== CALL THE ROUTINE
         B     DIAG999                 NO DIAG FOR THIS ABEND
*
DIAG094  DC    A(S001),C'S001'         SAM
DIAG095  DC    A(S001),C'S002'         SAM
*
DIAG999  END_PROC
*
*----------------------------------------------------------------------
*        DIAGNOSTIC FOR S001 & S002 ABENDS
*----------------------------------------------------------------------
*
S001     BEGIN_PROC
         CLI   OCE_CODE,C'E'           EOV SVC?
         BNE   S001ZZ                  NO, QUIT
         BAL   R14,BLANK1              BLANK LINE
         L     R1,FRSTSVRB             LOAD ADDR OF FIRST SVRB
         SLR   R5,R5                   no DEB
         L     R6,RBGRS1-RBPREFIX(,R1) R6 POINTS TO DCB
         ICM   R6,B'1000',X00          ZERO HI-ORDER BYTE OF DCB ADDR
         BAL   R14,SWA000          <== locate DEB/DSAB/SIOT/JFCB/TIOT
         BAL   R14,VALDCB          <== VALIDATE DCB
         LTR   R6,R6                   GOOD DCB?
         BZ    S001ZZ                  NO, QUIT
         STRING (ABCODE,,T),' OCCURED WHILE PROCESSING DDN=',          X
               DDNAME2,INTO=LINE
         BAL   R14,SPACE1          <== Print line
         BAL   R14,PRDCB           <== PRINT DCB
**      $PRTDSN DDNAME,INTO=LINE       PRINT ALLOCATION
S001ZZ   END_PROC
*
*----------------------------------------------------------------------
*        DIAGNOSTIC FOR O/C/E ABENDS
*----------------------------------------------------------------------
*
S013     BEGIN_PROC
        #S0C4  S013ZZ
         L     R6,SDWAGR02             R6 POINTS TO DCB
         USING IHADCB,R6
         L     R7,SDWAGR04             R7 POINTS TO O/C/E WORK AREA
         L     R1,FRSTSVRB             POINT TO 1ST SVRB        @921013
         CLI   RBWLIC-RBPREFIX(R1),0   THIS RB WAITING?         @921013
         BE    S013B                   NO, JUMP                 @921013
         L     R6,RBEXSAVE+00-RBPREFIX(,R1)  GET R2 VALUE       @921013
         L     R7,RBEXSAVE+08-RBPREFIX(,R1)  GET R4 VALUE       @921013
S013B    SLR   R5,R5                   no DEB
         BAL   R14,SWA000          <== locate DEB/DSAB/SIOT/JFCB/TIOT
         BAL   R14,VALDCB          <== VALIDATE DCB
         LTR   R6,R6                   GOOD DCB?
         BZ    S013ZZ                  NO, QUIT
         BAL   R14,BLANK1              BLANK LINE
         STRING (ABCODE,,T),' OCCURED WHILE PROCESSING DDN=',          X
               DDNAME2,INTO=LINE
         BAL   R14,SPACE1          <== PRINT MESSAGE
         BAL   R14,PRDCB           <== PRINT DCB
        #S0C4  S013ZZ
         CLI   0(R7),0                 ANY TAPE LABEL?
         BE    S013ZZ                  NO, QUIT
         CLC   0(256,R7),0             VALIDATE O/C/E WORK AREA
        #S0C4  RESET
         STRING '0   O/C/E WORK AREA:',INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,X'298'               LENGTH OF O/C/E WORK AREA
         LR    R1,R7                   PASS ADDRESS
         BAL   R14,PDUMP           <== DUMP IT
S013ZZ   END_PROC
         DROP  R6                      WAS IHADCB
*
*----------------------------------------------------------------------
*        DIAGNOSTIC FOR S0CX (PROGRAM CHECK) ABENDS
*----------------------------------------------------------------------
*
S0C0     BEGIN_PROC
         BAL   R14,BLANK1              BLANK LINE
        #SETMASK SDWANXT1              SET ADDRESS CLEAN-UP MASK
         L     R6,SDWANXT1             NEXT INSTRUCTION ADDRESS
         N     R6,MASKADDR             CLEAN-UP ADDRESS
         SR    R1,R1
         IC    R1,SDWAILC1             INSTR LEN CODE
         CLI   SDWAICD1,X'10'          SEGMENT TRANSLATION EXCEPTION?
         BE    S0C0F                   YES, JUMP
         CLI   SDWAICD1,X'11'          PAGE TRANSLATION EXCEPTION?
         BE    S0C0F                   YES, JUMP
         SR    R6,R1                   POINT TO INSTRUCTION
*
S0C0F    LR    R1,R6                   INSTRUCTION ADDR
         BAL   R14,CSVQRY00        <== FIND PROGRAM NAME
*
         IC    R0,SDWAICD1             EXCEPTION CODE IN R0
         L     R1,=A(PCKTABLE)         START OF PROGRAM-CHECK TABLE
         BAL   R14,SCANTBL             FIND EXCEPTION NAME
         BE    S0C0P                   FOUND, JUMP
         LA    R1,=C'..UNKNOWN'        FAKE IT
         LA    R2,7                    FAKE IT
S0C0P    STRING 2X,(2(R1),(R2)),' EXCEPTION OCCURED AT LOCATION ',     X
               ((R6),,X),2X,MSG20,INTO=LINE
         BAL   R14,SPACE1          <== PRINT MESSAGE
         BAL   R14,PRINTI          <== PRINT INSTRUCTION
         STRING '  INSTRUCTION IS ',(MSG20,(R1)),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         BAL   R14,EXECUTE         <== PRINT EXECUTED INSTRUCTION
*
         CLI   SDWAICD1,X'10'          SEGMENT TRANSLATION EXCEPTION?
         BE    S0C5                    YES, JUMP
         CLI   SDWAICD1,X'11'          PAGE TRANSLATION EXCEPTION?
         BNE   S0C0ZZ                  NO, EXIT
S0C5     STRING '  ADDRESS CAUSING EXCEPTION: ',                       X
               (SDWATRAN,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
S0C0ZZ   END_PROC
*
*----------------------------------------------------------------------
*        PRINT DATA SET ALLOCATIONS
*----------------------------------------------------------------------
*
TIOT00   BEGIN_PROC
         BAL   R14,BLANK1          <== BLANK LINE
         L     R1,CVTPTR               CVT ADDRESS
         L     R1,CVTLINK-CVTMAP(,R1)  LINKLIST DCB
         LOAD  EP=IEFEB4UV,DCB=(1)
         ST    R0,IEFEB4UV
**       L     R4,PSATOLD-PSA          MY TCB
**       USING TCB,R4
*
TIOT20   L     R5,TCBTIO               TIOT
         USING TIOT1,R5
         L     R6,PSAAOLD-PSA          MY ASCB
         L     R6,ASCBOUCB-ASCB(,R6)   MY OUCB
         USING OUCB,R6
         MVI   MINLINES,8
***      STRING '-  JOBNAME: ',TIOCNJOB,'  STEP: ',(TIOCSTEP+0,8),     X
               '  PROCSTEP: ',(TIOCSTEP+8,8),                          X
               '  PERFORM=',(OUCBNPG,H,L),                             X
               INTO=LINE121
         STRING '  DDNAME  DISP VOLSER   EXCP DATA SET NAME',32X,      X
               'DEVICE   CUU  MISCELLANEOUS',INTO=LINE
         BAL   R14,SPACE1          <== Print line
         MVI   LINE,C'0'               CTLCHR
         L     R1,PSATOLD-PSA          MY TCB
         L     R1,TCBJSCB-TCB(,R1)     MY JSCB
         L     R1,JSCDSABQ-IEZJSCB(,R1)  DSAB QDB
         L     R5,DSQFRSTP-DSABQDB(,R1)  FIRST DSAB ON CHAIN
         USING DSAB,R5
*LOOP
TIOT_GET ICM   R6,B'1111',DSABSIOT     POINT TO SIOT
         BNZ   TIOT31                  GOOD ADDRESS, USE IT
         LA    R6,TENWORDS+4           WORK AREA
         ST    R6,TENWORDS             WORK AREA
         USING ZB505,R6
         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA
         MVC   SWVA,DSABSSVA           SVA OF THE SIOT
         SWAREQ FCODE=RL,EPA=TENWORDS,MF=(E,SWAREQL1),UNAUTH=YES
         L     R6,SWBLKPTR             31-BIT ADDRESS OF SIOT
         USING INDMSIOT,R6
*
TIOT31   L     R7,SJFCBPTR             GET JFCB ADDRESS FROM SIOT
         USING INFMJFCB,R7
*
         MVC   MSG60,BLANKS            CLEAR WORK AREA
         MVC   STATUS,BLANKS           CLEAR WORK AREA
         MVC   UNITNAME,BLANKS         CLEAR WORK AREA
         MVC   VOLSER,BLANKS
         SLR   R1,R1                   EXCP=0
         SLR   R3,R3                   NO UCB
         MVC   VOLSER(4),SIOTSSNM      SYSIN/SYSOUT
         TM    JFCBTSDM,JFCSDS         IS THIS A JES DATA SET?
         BO    TIOT61                  YES, JUMP
         MVC   VOLSER,=C'DUMMY   '     DUMMY DATA SET
         TM    SCTSBYT1,SCTDUMMY       DD DUMMY?
         BO    TIOT62                  yes, jump
         ICM   R3,B'0111',SIOUCBAD     UCB ADDRESS
         USING UCBOB,R3
         MVC   UNITNAME+8(4),UCBTYP    DEVICE TYPE
         BAL   R14,GETUNIT         <== GET UNITNAME
         MVC   VOLSER,=C'VIO     '     UNIT=VIO
         TM    UCBJBNR,UCBVRDEV        IS THIS A VIO DATA SET?
         BO    TIOT41                  YES, JUMP
         MVC   VOLSER,UCBVOLI          NO, MOVE FIRST VOLSER
         TR    VOLSER,TRTPRINT         get rid of garbage
         CLC   VOLSER,UCBVOLI          is the volser ok?
         BE    TIOT41                  YES, JUMP
         MVC   VOLSER,BLANKS           NO, blank it out
*
TIOT41   BAS   R1,TIOT41IC
         DC    C'NEW',AL1(JFCNEW)
         DC    C'MOD',AL1(JFCMOD)
         DC    C'SHR',AL1(JFCOLD+JFCSHARE)
         DC    C'OLD',AL1(JFCOLD)
         DC    C'???',0H'0'
TIOT41TM TM    JFCBIND2,*-*            TEST LABEL TYPE FLAGS
*--LOOP
TIOT41IC IC    R15,3(,R1)              PICK UP MASK FOR "TM"
         EX    R15,TIOT41TM
         BO    TIOT41X
         LA    R1,3+1(,R1)             BUMP TABLE PTR
         CLI   0(R1),C'?'              END OF TABLE?
         BNE   TIOT41IC                NEXT TABLE ENTRY
*--ENDLOOP
TIOT41X  MVC   STATUS,0(R1)            DISP
*
TIOT43S  TM    UCBFL5,UCBSMS           SMS VOL?     X'20'
         BZ    TIOT43V                 NO, JUMP
         STRING (MSG60,,T),',SMS',INTO=MSG60
*
TIOT43V  CLC   JFCDSORG,=AL2(JFCORGAM) VSAM DATA SET?
         BNE   TIOT46                  NO, JUMP
         STRING (MSG60,,T),',VSAM',INTO=MSG60
         B     TIOT61
*
TIOT46   CLI   UCBTBYT3,UCB3TAPE       TAPE DEVICE?
         BE    TIOT46B                 yes, jump
         CLI   UCBTBYT3,UCB3DACC       DASD DEVICE?
         BNE   TIOT61                  NO, JUMP
         TM    JFCBLTYP,JFCSUL         LABEL=(,SUL) ?
         BNO   TIOT61                  no, jump
TIOT46B  BAS   R1,TIOT46IC
         DC    C'LTM',AL1(JFCBLTM)
         DC    C'BLP',AL1(JFCBLP)
         DC    C'SUL',AL1(JFCSUL)
         DC    C'AUL',AL1(JFCSUL+JFCBAL)
         DC    C'AL ',AL1(JFCBAL)
         DC    C'NSL',AL1(JFCNSL)
         DC    C'SL ',AL1(JFCSL)
         DC    C'NL ',AL1(JFCNL)
         DC    C'???',0H'0'
TIOT46TM TM    JFCBLTYP,*-*            TEST LABEL TYPE FLAGS
*--LOOP
TIOT46IC IC    R15,3(,R1)              PICK UP MASK FOR "TM"
         EX    R15,TIOT46TM
         BO    TIOT46X
         LA    R1,3+1(,R1)             BUMP TABLE PTR
         CLI   0(R1),C'?'              END OF TABLE?
         BNE   TIOT46IC                NEXT TABLE ENTRY
*--ENDLOOP
TIOT46X  LH    R0,JFCBFLSQ             PICK UP FILE SEQUENCE NUMBER
         LTR   R0,R0                   LABEL=0?
         BNZ   TIOT46Y                 NO, JUMP
         LA    R0,0001                 YES, CHANGE TO LABEL=1
TIOT46Y  STRING ',',((R0),,L),',',((R1),3),INTO=MSG60
*
TIOT61   L     R0,DSABTIOT             POINT TO CURRENT TIOT ENTRY
         SL    R0,TCBTIO               CHANGE ADDRESS TO OFFSET
         BAL   R14,EXCP00          <== GET EXCP COUNT IN R1
*
TIOT62   STRING ((R1),,R6B),INTO=WKCELL2
         CL    R1,=F'100000'           OVER 100K?
         BL    TIOT63                  NO, JUMP
         SLR   R0,R0                   YES, DIVIDE BY 1000
         LA    R1,500(,R1)             YES, DIVIDE BY 1000
         D     R0,=F'1000'             YES, DIVIDE BY 1000
         STRING ((R1),,R5B),'K',INTO=WKCELL2
*
TIOT63   TM    JFCBTSDM,JFCSDS         IS THIS A JES DATA SET?
         BZ    TIOT64                  NO, JUMP
         CLI   SCTOUTPN,C' '           DO WE HAVE A CLASS?
         BE    TIOT64                  NO, JUMP
         STRING ',SYSOUT=',SCTOUTPN,INTO=MSG60
         ICM   R0,B'0111',JFCOUTLI     OUTLIM=0?
         BE    TIOT64                  YES, JUMP
         STRING (MSG60,,T),',OUTLIM=',(JFCOUTLI,FL3,L),INTO=MSG60
*
TIOT64   LTR   R3,R3                   DO WE HAVE A UCB?
         BNZ   TIOT65                  YES, JUMP
         LA    R3,BLANKS               NO, POINT TO A DUMMY UCB
*
TIOT65   MVC   EYECATCH(L'JFCBDSNM),JFCBDSNM MOVE DATA SET NAME
         TM    JFCBIND1,JFCPDS         DO WE HAVE A MEMBER NAME?
         BZ    TIOT71                  NO, JUMP
         STRING (JFCBDSNM,,T),'(',(JFCBELNM,,T),')',INTO=EYECATCH
TIOT65L  CLI   EYECATCH+L'JFCBDSNM,C' ' OVERFLOW?
         BE    TIOT71                  NO, JUMP
         MVC   EYECATCH(60),EYECATCH+1 SHIFT DSN(MBR) TO THE LEFT
         B     TIOT65L                 TRY AGAIN
*
TIOT71   ICM   R0,B'0011',DSABOPCT     Any DCB OPEN?
         BZ    TIOT_PRT                NO, JUMP
         STRING (MSG60,,T),',OPEN',INTO=MSG60
*
TIOT_PRT STRING 2X,SCTDDNAM,1X,STATUS,1X,VOLSER,1X,(WKCELL2,7),        X
               (EYECATCH,L'JFCBDSNM),1X,UNITNAME,1X,UCBNAME,2X,        X
               (MSG60+1,L'MSG60-1),INTO=LINE
         BAL   R14,SPACE1          <== Print line
*
TIOT_NXT L     R5,DSABFCHN             NEXT DSAB                  -
         LTR   R5,R5                   end of chain?
         BNZ   TIOT_GET                NOT YET, LOOP THROUGH TIOT
*ENDLOOP
         DROP  R5,R6,R7,R3             DSAB, SIOT, JFCB, UCB
         DELETE EP=IEFEB4UV
TIOT90   END_PROC
*
*----------------------------------------------------------------------
*
*        PRINT PSW, REGISTERS
*
*              SDWA DATA (PSW1/PSW2)
*              LAST PRB DATA (IF REQUIRED)
*
*----------------------------------------------------------------------
*
PSW00    BEGIN_PROC
         BAL   R14,BLANK1          <== BLANK LINE
        #SETMASK SDWANXT1              SET ADDRESS CLEAN-UP MASK
         L     R1,SDWANXT1             NEXT INSTRUCTION
         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE
PSW11    STRING 'PSW1: ',(SDWAEC1,4,X),1X,(SDWAEC1+4,4,X),2X,MSG20,    X
               '  ILC: ',(SDWAILC1,FL1,L),                             X
               '  INTC: ',(SDWAINC1,,X),INTO=LINE
         MVI   MINLINES,8
         BAL   R14,SPACE1          <== Print line
         L     R1,SDWANXT1             NEXT INSTRUCTION
         N     R1,MASKADDR             CLEAN UP ADDRESS
         SH    R1,=H'6'                6 BYTES BEFORE
         BNP   PSW15                   LOW CORE
        #S0C4  PSW15
         CLC   0(12,R1),0(R1)          VALIDATE 12 BYTES
        #S0C4  RESET
         STRING ' DATA AROUND PSW1 ADDR:  ',INTO=LINE,                 X
               (00(R1),2,X),1X,(02(R1),2,X),1X,(04(R1),2,X),1X,        X
               (06(R1),2,X),1X,(08(R1),2,X),1X,(10(R1),2,X),1X
         BAL   R14,SPACE1          <== Print line
*SW15    BAL   R14,EXECUTE         <== PROCESS 'EX' OPCODE (X'44')
PSW15    STRING '0   GPR00-03: ',(SDWAGR00,,X),2X,(SDWAGR01,,X),2X,    X
               (SDWAGR02,,X),2X,(SDWAGR03,,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR04-07: ',(SDWAGR04,,X),2X,(SDWAGR05,,X),2X,     X
               (SDWAGR06,,X),2X,(SDWAGR07,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR08-11: ',(SDWAGR08,,X),2X,(SDWAGR09,,X),2X,     X
               (SDWAGR10,,X),2X,(SDWAGR11,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR12-15: ',(SDWAGR12,,X),2X,(SDWAGR13,,X),2X,     X
               (SDWAGR14,,X),2X,(SDWAGR15,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
*
PSW20    CLC   SDWAEC1,SDWAEC2         PSW1=PSW2?
         BE    PSW99                   YES, DON'T BOTHER
         L     R1,SDWANXT2             NEXT INSTRUCTION
         LTR   R1,R1                   ANY DATA THERE?
         BZ    PSW31                   NONE, DON'T BOTHER       @911019
        #SETMASK SDWANXT2              SET ADDRESS CLEAN-UP MASK
         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE
         BAL   R14,BLANK1          <== BLANK LINE
         MVI   MINLINES,8
         STRING 'PSW2: ',(SDWAEC2,4,X),1X,(SDWAEC2+4,4,X),2X,MSG20,    X
               '  ILC: ',(SDWAILC2,FL1,L),                             X
               '  INTC: ',(SDWAINC2,,X),ORIGIN2,INTO=LINE
         BAL   R14,SPACE1          <== Print line
         L     R1,SDWANXT2             NEXT INSTRUCTION
         N     R1,MASKADDR             CLEAN UP ADDRESS
         SH    R1,=H'6'                6 BYTES BEFORE
        #S0C4  PSW25
         CLC   0(12,R1),0(R1)          VALIDATE 12 BYTES
        #S0C4  RESET
         STRING ' DATA AROUND PSW2 ADDR:  ',INTO=LINE,                 X
               (00(R1),2,X),1X,(02(R1),2,X),1X,(04(R1),2,X),1X,        X
               (06(R1),2,X),1X,(08(R1),2,X),1X,(10(R1),2,X),1X
         BAL   R14,SPACE1          <== Print line
PSW25    STRING '0   GPR00-03: ',(SDWASR00,,X),2X,(SDWASR01,,X),2X,    X
               (SDWASR02,,X),2X,(SDWASR03,,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR04-07: ',(SDWASR04,,X),2X,(SDWASR05,,X),2X,     X
               (SDWASR06,,X),2X,(SDWASR07,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR08-11: ',(SDWASR08,,X),2X,(SDWASR09,,X),2X,     X
               (SDWASR10,,X),2X,(SDWASR11,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR12-15: ',(SDWASR12,,X),2X,(SDWASR13,,X),2X,     X
               (SDWASR14,,X),2X,(SDWASR15,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
*
*        PRINT PSW AND REGS FOR LAST PRB IF DIFFERENT FROM PSW1/2
*
PSW31    L     R6,LASTPRB              LAST PRB
         USING RBPREFIX,R6
         CLC   SDWAEC1,RBOPSW          SAME AS PSW1 IN SDWA?
         BE    PSW99                   YES, JUMP
         CLC   SDWAEC2,RBOPSW          SAME AS PSW2 IN SDWA?
         BE    PSW99                   YES, JUMP
        #SETMASK RBOPSW+4              SET ADDRESS CLEAN-UP MASK
         L     R1,RBOPSW+4             NEXT INSTRUCTION
         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE
         BAL   R14,BLANK1          <== BLANK LINE
         MVI   MINLINES,8
         STRING 'PSW3: ',(RBOPSW,4,X),1X,(RBOPSW+4,4,X),2X,MSG20,      X
               '  ILC: ',(RBWLIC+1,FL1,L),                             X
               '  INTC: ',(RBWLIC+2,2,X),                              X
               '  (LASTPRB)',INTO=LINE
         BAL   R14,SPACE1          <== Print line
         L     R1,RBOPSW+4             NEXT INSTRUCTION
         N     R1,MASKADDR             CLEAN UP ADDRESS
         SH    R1,=H'6'                6 BYTES BEFORE
        #S0C4  PSW35
         CLC   0(12,R1),0(R1)          VALIDATE 12 BYTES
        #S0C4  RESET
         STRING ' DATA AROUND PSW3 ADDR:  ',INTO=LINE,                 X
               (00(R1),2,X),1X,(02(R1),2,X),1X,(04(R1),2,X),1X,        X
               (06(R1),2,X),1X,(08(R1),2,X),1X,(10(R1),2,X),1X
         BAL   R14,SPACE1          <== Print line
PSW35    L     R6,FRSTSVRB             NEXT IRB/SVRB
         STRING '0   GPR00-03: ',(RBGRS0,,X),2X,(RBGRS1,,X),2X,        X
               (RBGRS2,,X),2X,(RBGRS3,,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR04-07: ',(RBGRS4,,X),2X,(RBGRS5,,X),2X,         X
               (RBGRS6,,X),2X,(RBGRS7,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR08-11: ',(RBGRS8,,X),2X,(RBGRS9,,X),2X,         X
               (RBGRS10,,X),2X,(RBGRS11,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR12-15: ',(RBGRS12,,X),2X,(RBGRS13,,X),2X,       X
               (RBGRS14,,X),2X,(RBGRS15,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         DROP  R6                      PRB
PSW99    END_PROC
*
*----------------------------------------------------------------------
*        PRINT JOB/STEP INFORMATION
*----------------------------------------------------------------------
*
JOBSTEP  BEGIN_PROC
         BAL   R14,BLANK1              blank line
         STRING 'JOB/STEP INFORMATION',INTO=LINE
         BAL   R14,SPACE2              Double Space
*
         L     R4,TCBJSCB              job step control block
         USING IEZJSCB,R4
         L     R5,JSCBJCT              Job Control Table
         USING JCT,R5
         SLR   R7,R7
         ICM   R7,B'0111',JCTACTAD     SVA OF ACT
         USING IEFAACTB-16,R7
*
         STRING '  //',(JCTJNAME,,T),' JOB ',INTO=LINE
         MVI   WKCELL3,C' '            no comma
         MVI   WKCELL3+1,C'('          begin sub-list
         SLR   R3,R3
         ICM   R3,B'0001',ACTJNFLD     # OF ACCT FIELDS
         BZ    JOBS120                 no account information
         CLC   =X'0100',ACTJNFLD       one null sub-field?
         BE    JOBS120                 yes, ignore
         LA    R1,ACTJNFLD+1           first sub-parm
         SLR   R2,R2
*loop
JOBS114  ICM   R2,B'0001',0(R1)        size of sub-parm
         STRING (1(R1),(R2)),INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
         LA    R1,1(R2,R1)             skip current sub-field
         BCT   R3,JOBS114              next sub-field
*endloop
         LA    R15,LINE(R15)           last pos in line
         MVI   0(R15),C')'             close sub-list
         B     JOBS121
*
JOBS120  MVI   WKCELL3+1,C','          ACCT field missing
*
JOBS121  CLC   ACTPRGNM,BLANKS         do we have a PROGRAMMER'S NAME ?
         BE    JOBS122                 no, jump
         STRING (ACTPRGNM,,T),INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
*
JOBS122  CLI   JCTJCSMF,X'E0'          TSO user?
         BE    JOBS125                 yes, jump
         CLI   JCTJCSMF,X'E0'          Started Task?
         BE    JOBS125                 yes, jump
         STRING 'CLASS=',JCTJCSMF,INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
*
JOBS125  STRING 'MSGCLASS=',JCTJMGPO,INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
*
JOBS130  STRING 'MSGLEVEL=(1,1)',INTO=MSG60     MSGLEVEL=(1,1)
         TM    JCTJMGLV,INCMMGL1       MSGLEVEL=1 ?
         BO    JOBS133                 yes, jump
         MVI   MSG60+10,C'2'           MSGLEVEL=(2,1)
         TM    JCTJMGLV,INCMMGL2       MSGLEVEL=2 ?
         BO    JOBS133                 yes, jump
         MVI   MSG60+10,C'0'           MSGLEVEL=(0,1)
JOBS133  TM    JCTJMGLV,INCMALL        MSGLEVEL=(,1) ?
         BO    JOBS134                 yes, jump
         MVI   MSG60+12,C'0'           MSGLEVEL=(,0)
JOBS134  BAL   R14,JOBS155             append new text to current line
*
JOBS136  SLR   R6,R6
         ICM   R6,B'0111',JCTJCTX      SVA OF JCTX
         USING JCTX,R6
         L     R1,JCTXJTL              JOB TIME limit (ESA410)
         CLI   SPLEVEL,4               running on ESA 410?
         BNL   JOBS136T                yes, jump
         SLR   R1,R1
         ICM   R1,B'0111',JCTJMRTL     JOB TIME limit (XA,ESA313)
JOBS136T LTR   R1,R1                   TIME=0 (TSO) ?
         BZ    JOBS140                 yes, exit
         SLR   R0,R0
         D     R0,=F'100'              get time in seconds
         SLR   R0,R0
         D     R0,=F'60'               get time in minutes
         STRING 'TIME=(',((R1),,L),',',((R0),,L),')',INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
*
JOBS140  L     R6,JSCSCT               Current step's SCT
         USING SCT,R6
         LH    R2,JCTEQREG             region parm from job card
         CH    R2,=H'16383'            region > 16M ?
         BE    JOBS146                 yes, jump
         CLM   R2,B'0111',SCTRGSZ      same as REGION on EXEC card ?
         BNE   JOBS147                 no, exit
JOBS146  ICM   R2,B'0111',SCTRGSZ      yes, use value from EXEC card
         STRING 'REGION=',((R2),,L),'K',INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
         BSM   R5,0                    make R5 negative
*
JOBS147  TM    JCTSTAT2,JCTPERFM       PERFORM specified on EXEC?
         BZ    JOBS149                 no, jump
         STRING 'PERFORM=',(SCTPRFMF,H,L),INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
         BSM   R6,0                    make R6 negative
*
JOBS149  L     R2,PSAAOLD-PSA          MY ASCB
         USING ASCB,R2
         L     R3,ASCBASXB             MY ASXB
         USING ASXB,R3
         STRING 'USER=',(ASXBUSER,,T),INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
         ICM   R3,B'1111',ASXBSENV     MY ACEE
         BNP   JOBS149Z                no RACF, exit
         USING ACEE,R3
         STRING 'GROUP=',(ACEEGRPN,,T),INTO=MSG60
         BAL   R14,JOBS155             append new text to current line
JOBS149Z BAL   R14,SPACE2          <== Double Space
         B     JOBS162
*
*        append MSG60 to LINE
*
JOBS155  ST    R14,WKCELL3+4           save return address
         LTR   R0,R15                  save length
         BZ    JOBS155C                zero length, jump
         LA    R14,MSG60               FIRST POS
JOBS155L CLI   0(R14),C' '             imbedded space?
         BE    JOBS155Q                YES, EXIT
**MSGL   CLI   0(R14),C','             imbedded comma?
**MSGL   BE    JOBS155Q                YES, EXIT
         LA    R14,1(,R14)             BUMP POINTER
         BCT   R15,JOBS155L            SCAN AREA
         B     JOBS155C                YES, EXIT
JOBS155Q MVC   EYECATCH,MSG60          move to work area
         STRING '''',(EYECATCH,(R0)),'''',INTO=MSG60
         LR    R0,R15                  save length
JOBS155C STRING (LINE,,T),(WKCELL3,2,T),(MSG60,(R0)),',',INTO=EYECATCH
         CL    R15,=F'80'              overflow?
         BH    JOBS155O                yes, jump
         STRING (LINE,,T),(WKCELL3,2,T),(MSG60,(R0)),INTO=LINE
         B     JOBS155X
JOBS155O STRING (LINE,,T),',',INTO=LINE
         BAL   R14,SPACE1          <== Single space
         STRING '  // ',(MSG60,(R0)),INTO=LINE
JOBS155X MVI   WKCELL3,C','            next parm needs a comma
         MVI   WKCELL3+1,C' '          next parm needs no space
         L     R14,WKCELL3+4           return address
         BR    R14
*
JOBS162  MVC   WKCELL1(5),=C'Below'    default placement for SWA
         TM    JCTSTAT2,JCTSWAUP       SWA above?
         BZ    JOBS163                 no, jump
         MVC   WKCELL1(5),=C'Above'    yes, remember it
JOBS163  MVC   WKCELL2(3),=C'No '      default
         TM    JCTSTAT2,JCTBLP         BLP authorized?
         BZ    JOBS164                 no, jump
         MVC   WKCELL2(3),=C'Yes'      yes, remember it
JOBS164  MVC   WKCELL3(3),=C'No '      default
         TM    JSCBJJSB,JSCBJNLF       Job Journaling active?
         BO    JOBS168                 no, jump
         MVC   WKCELL3(3),=C'Yes'      yes, remember it
JOBS168  L     R3,JSCBSSIB             point to the SSIB
         USING SSIB,R3
         STRING '    Sub-System(',SSIBSSNM,')',                        X
               '  JOB-Id(',SSIBJBID,')',                               X
               '  SWA(',(WKCELL1,5),')',     SWA(below/above)          X
               '  BLP(',(WKCELL2,3,T),')',     BLP(yes/no)             X
               '  Journal(',(WKCELL3,3,T),')', Job Journal (yes/no)    X
               '  ASID(X''',(ASCBASID,,X),''')',                       X
               INTO=LINE
         BAL   R14,SPACE1          <== Single space
*
JOBS170  SLR   R0,R0
         SLR   R1,R1
         ICM   R1,B'0111',JCTJMRJT     job start time (binary)
         D     R0,=F'00360000'         GET HOURS
         LR    R2,R1                   HH
         LR    R1,R0                   REMAINDER
         SLR   R0,R0
         D     R0,=F'6000'             GET MINUTES IN R1
         LR    R3,R1                   MM
         LR    R1,R0                   REMAINDER
         SLR   R0,R0
         D     R0,=F'100'              GET SECONDS IN R1
         STRING '    Job Start Date: ',(JCTJMRJD,P,YYYY-MM-DD),        X
               '  Time: ',((R2),,R2Z),'H',((R3),,R2Z),'M',((R1),,R2Z), X
               INTO=LINE
         BAL   R14,SPACE2          <== Double space
*
*        CPU time used (JOB)
*
JOBS180  SLR   R0,R0
         L     R1,ACTJTIME             Accumulated TCB time
         A     R1,JCTSRBT              Accumulated SRB time
         BZ    JOBS200                 zero, quit
         D     R0,=F'00360000'         GET HOURS
         LR    R2,R1                   HH
         LR    R1,R0                   REMAINDER
         SLR   R0,R0
         D     R0,=F'6000'             GET MINUTES IN R1
         LR    R3,R1                   MM
         LR    R1,R0                   REMAINDER
         SLR   R0,R0
         D     R0,=F'100'              GET SECONDS IN R1
         STRING '    CPU time used: ',((R2),,R3Z),'H',((R3),,R2Z),'M', X
               ((R1),,R2Z),'S',((R0),,R2Z),                            X
               INTO=LINE
**           1X,(ACTJTIME,,X),1X,(JCTSRBT,,X),                       X
         BAL   R14,SPACE2          <== Double Space
*
*        //stepname EXEC PGM=program,REGION=1234K,TIME=(30,0)
*
JOBS200  SLR   R7,R7                   SCTX address
         ICM   R7,B'0111',SCTXBTTR     address of SCTX (SCT extension)
         USING SCTX,R7
         SLR   R0,R0
         ICM   R1,B'1111',SCTXSTL      step time limit (ESA410)
         BNZ   *+8                     OK, jump
         ICM   R1,B'0111',SCTSTIME     step time limit (XA/ESA310)
         D     R0,=F'100'              get it in seconds
         SLR   R0,R0
         D     R0,=F'60'               get it in minutes
         STRING '  //',(SCTSNAME,,T),' EXEC PGM=',(SCTPGMNM,,T),       X
               ',TIME=(',((R1),,L),',',((R0),,L),')',                  X
               INTO=LINE
*
         LTR   R5,R5                   REGION specified on JOB card?
         BM    JOBS230                 yes, jump
         STRING (LINE,,T),',REGION=',(SCTRGSZ,FL3,L),'K',INTO=LINE
JOBS230  LH    R2,SCTNIUSL             max number of DD stmts
         SH    R2,SCTLALOC             minus # of godd DDs
         BZ    JOBS240                 zero, jump
         STRING (LINE,,T),',DYNAMNBR=',((R2),,L),INTO=LINE
JOBS240  EQU   *
         LTR   R6,R6                   PERFORM specified on JOB?
         BO    JOBS250                 yes, jump (JOB overrides EXEC)
         TM    SCTSDP,SCTEPRFM         PERFORM specified on EXEC?
         BZ    JOBS250                 no, jump
         STRING (LINE,,T),',PERFORM=',(SCTPRFMF,H,L),INTO=LINE
JOBS250  EQU   *
         SLR   R2,R2
         ICM   R2,B'0011',SCTSEXEC     PARM length
         BZ    JOBS270                 no PARM, jump
         STRING (LINE,,T),',',INTO=LINE
         BAL   R14,SPACE1          <== next line
         STRING '  // PARM=''',(SCTXPARM,(R2)),'''',                   X
               INTO=LINE
JOBS270  BAL   R14,SPACE2          <== Double Space
*
JOBS300  L     R6,PSAAOLD-PSA          ASCB
         USING ASCB,R6
         L     R7,ASCBOUCB             MY OUCB
         USING OUCB,R7
         STRING '    PERFORM(',(OUCBSPG,H,L),')',                      X
               '   DPRTY(X''',(ASCBDP,,X),''')',  dispatching priority X
               INTO=LINE
         BAL   R14,SPACE1          <== Print line
*
JOBS410  SLR   R0,R0
         SLR   R1,R1
         ICM   R1,B'0111',JCTJMRSS     Step start time (binary)
         D     R0,=F'00360000'         GET HOURS
         LR    R2,R1                   HH
         LR    R1,R0                   REMAINDER
         SLR   R0,R0
         D     R0,=F'6000'             GET MINUTES IN R1
         LR    R3,R1                   MM
         LR    R1,R0                   REMAINDER
         SLR   R0,R0
         D     R0,=F'100'              GET SECONDS IN R1
         STRING '    Step Start Date: ',(JCTSSD,P,YYYY-MM-DD),         X
               '  Time: ',((R2),,R2Z),'H',((R3),,R2Z),'M',((R1),,R2Z), X
               INTO=LINE
         BAL   R14,SPACE1          <== Print line
*
*        CPU TIME (STEP)
*
JOBS420  LM    R0,R1,ASCBEJST          GET ELAPSED JOB TCB TIME
         CLM   R0,B'1100',=F'0'        IS TOD ACCURATE?
         BE    JOBS421                 BRANCH IF YES
         SR    R0,R0                   ZERO OUT R0
         SR    R1,R1                   ZERO OUT R1
JOBS421  DS    0H
         SRDL  R0,0012                 IN MICRO-SECONDS
         LM    R14,R15,ASCBSRBT        GET ELAPSED SRB TIME
         CLM   R14,B'1100',=F'0'       IS TOD ACCURATE?
         BE    JOBS422                 BRANCH IF YES
         SR    R14,R14                 ZERO OUT R14
         SR    R15,R15                 ZERO OUT R15
JOBS422  DS    0H
         SRDL  R14,0012                IN MICRO-SECONDS
         ALR   R1,R15                  ADD TCB AND SRB TIME
         BNO   JOBS423                 BRANCH IF NO OVERFLOW
         AH    R0,=H'1'                HANDLE CARRY
JOBS423  DS    0H
         AR    R0,R14
         D     R0,=F'10000'            GET IN HUNDREDTHS
         CH    R0,=H'5000'          -  ROUND UP NEEDED ?
         BL    JOBS427              -  BRANCH IF NOT
         AH    R1,=H'1'             -  ROUND UP
*
JOBS427  SLR   R0,R0
         D     R0,=F'100'              TIME IN SECOND
         LR    R3,R0                   SAVE REMAINING 1/100
         SLR   R0,R0
         D     R0,=F'60'               TIME IN MINUTES
         LR    R2,R0                   SAVE REMAINING SECONDS
         SLR   R0,R0
         D     R0,=F'60'               TIME IN HOURS
         STRING ((R1),,L),'H',((R0),,R2Z),'M',INTO=WKCELL1
         LTR   R1,R1                   MORE THAN 1 HOUR?
         BNZ   JOBS429                 YES, JUMP
         STRING ((R0),,L),'M',((R2),,R2Z),'S',INTO=WKCELL1
         LTR   R0,R0                   MORE THAN 1 MINUTE?
         BNZ   JOBS429                 YES, JUMP
         STRING ((R2),,L),'.',((R3),,R2Z),INTO=WKCELL1
JOBS429  STRING '    CPU time used: ',WKCELL1,INTO=LINE
         BAL   R14,SPACE2          <== Double Space
*
*        Storage Allocation Table
*
JOBS600  MVI   MINLINES,6
         STRING '  Virtual Storage Usage:',INTO=LINE
         BAL   R14,SPACE2          <== Double Space
         L     R5,TCBTCT               SMF Timing Control Table
         USING SMFTCT,R5
         L     R5,TCTCRTBL             SMF Storage Control Table
         USING TCTCORE,R5
         L     R6,ASCBLDA              Local Data Area
         USING LDA,R6
         STRING 30X,'Limit      In Use    Available    High-watermark',x
               INTO=LINE
         BAL   R14,SPACE2          <== Double Space
         L     R0,LDALIMIT             LIMIT
         SRL   R0,10                   BYTES -> KILOS
         L     R1,LDALOAL              user region current value
         SRL   R1,10                   BYTES -> KILOS
         LR    R2,R0                   LIMIT
         SLR   R2,R1                   AVAILABLE
         L     R3,TCTLWM               high-watermark
         SRL   R3,10                   BYTES -> KILOS
         STRING '    User SPLS (Below)  ',INTO=LINE,((R0),,R11B),'K',  X
               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'
         BAL   R14,SPACE1          <== Print line
         L     R0,LDASIZA              SIZE OF PRIVATE AREA
         SL    R0,LDALIMIT             LIMIT
         SRL   R0,10                   BYTES -> KILOS
         L     R1,LDAHIAL              auth region current value
         SRL   R1,10                   BYTES -> KILOS
         LTR   R2,R0                   LIMIT
         BZ    *+6                     region>16M, jump
         SLR   R2,R1                   AVAILABLE
         L     R3,TCTHWM               high-watermark
         SRL   R3,10                   BYTES -> KILOS
         STRING '    Auth SPLS (Below)  ',INTO=LINE,((R0),,R11B),'K',  X
               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'
         BAL   R14,SPACE1          <== Print line
         L     R0,LDAELIM              LIMIT
         SRL   R0,10                   BYTES -> KILOS
         L     R1,LDAELOAL             user region current value
         SRL   R1,10                   BYTES -> KILOS
         LR    R2,R0                   LIMIT
         SLR   R2,R1                   AVAILABLE
         L     R3,TCTELWM              high-watermark
         SRL   R3,10                   BYTES -> KILOS
         STRING '    User SPLS (Above)  ',INTO=LINE,((R0),,R11B),'K',  X
               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'
         BAL   R14,SPACE1          <== Print line
         L     R0,LDAESIZA             SIZE OF PRIVATE AREA
         SL    R0,LDAELIM              LIMIT
         SRL   R0,10                   BYTES -> KILOS
         L     R1,LDAEHIAL             auth region current value
         SRL   R1,10                   BYTES -> KILOS
         LTR   R2,R0                   LIMIT
         BZ    *+6                     region=0M, jump
         SLR   R2,R1                   AVAILABLE
         L     R3,TCTEHWM              high-watermark
         SRL   R3,10                   BYTES -> KILOS
         STRING '    Auth SPLS (Above)  ',INTO=LINE,((R0),,R11B),'K',  X
               ((R1),,R11B),'K',((R2),,R12B),'K',((R3),,R14B),'K'
         BAL   R14,SPACE1              Print line
JOBSTP99 END_PROC
*
*----------------------------------------------------------------------
*        PRINT RB CHAIN
*----------------------------------------------------------------------
*
PRB00    BEGIN_PROC
         CL    R9,TCBJSTCB             MAIN TASK?               @920630
         BNE   PRB1000                 NO, JUMP                 @920630
         ICM   R0,B'1111',TCBLTC       YES, ANY SUB-TASKS?      @921020
         BZ    PRB20                   NONE, JUMP               @921020
*
*        DISPLAY TCB TREE AND RB CHAINS (IF TCB IS NOT JSTCB)
*
PRB1000  BAL   R14,BLANK1          <== BLANK LINE
         MVI   MINLINES,5
         STRING 'TCB TREE AND RB CHAINS:',INTO=LINE
         BAL   R14,SPACE1              PRINT LINE
         STRING '0   TCB ADDRESS',18X,INTO=LINE121,                    X
               'PROGRAM    IC  STAB  FLAGS1 CDFLGS    DDNAME'
         BAL   R14,SPACE1              PRINT LINE
         L     R9,TCBJSTCB             THE JOB STEP TCB
         SLR   R3,R3                   INDENTATION INDEX
*LOOP
PRB1100  STCM  R9,B'0111',WKCELL1      STORE TCB ADDR
         STRING (BLANKS,4(R3)),(WKCELL1,3,X),INTO=LINE121
         TM    TCBFLGS5,TCBFC          task ended already?
         BO    PRB1288                 yes, next TCB
         SLR   R6,R6                   first time switch for NEXTRB
*
*        Process RB chain from the oldest RB
*--LOOP
PRB1200  BAL   R14,NEXTRB              Point to next RB
         LTR   R6,R6                   end of chain?
         BZ    PRB1290                 yes, exit loop
         USING RBPREFIX,R6
         CLI   RBSTAB1,RBFTPRB         IS THIS A PRB?
         BNE   PRB1240                 NO, jump
*227     TM    RBCDFLGS,RBCDSYNC       CHECK FLAGS
*227     BO    PRB1260                 JUMP IF IT IS A SYNCH PRB
         SLR   R1,R1
         ICM   R1,B'0111',RBCDE1       Do we have a CDE?
         BZ    PRB1230                 No, jump (must be a SYNCH PRB)
         MVC   WKCELL1,BLANKS          TASKLIB DDNAME
         ICM   R15,B'1111',TCBJLB      LOAD/TEST DCB ADDRESS
         BZ    PRB1220                 NO TASKLIB, JUMP
         MVC   WKCELL1,=C'-LNKLST-'
         L     R14,CVTPTR              POINT AT CVT
         CL    R15,CVTLINK-CVTMAP(,R14) SYS1.LINKLIB
         BE    PRB1220                 JUMP IF SYS1.LINKLIB DCB ADDR
         LH    R15,DCBTIOT-IHADCB(,R15) LOAD TIOT OFFSET
         A     R15,TCBTIO              CHANGE OFFSET INTO AN ADDRESS
         MVC   WKCELL1,4(R15)          MOVE TASKLIB DDNAME
*
*        "LINK" PRB
*
PRB1220  STRING INTO=(LINE+30,L'LINE-30),2X,                           X
               (CDNAME-CDENTRY(R1),8),3X,      PGM NAME                X
               (RBWLIC+3,1,X),2X,      IC                              X
               (RBSTAB,2,X),4X,        STATUS BYTE                     X
               (RBFLAGS1,,X),5X,       Flags                           X
               (RBCDFLGS,,X),6X,       FLAGS                           X
               WKCELL1                 DDNAME OF TASKLIB
*        DISPLAY REG1 FOR DATACOM SUB-TASK                      @930824
         CLC   =C'DBISBPR ',CDNAME-CDENTRY(R1)    DATACOM/DB?   @930824
         BNE   PRB1270                 no, jump                 @930824
         LA    R1,LINE+30(R15)         END OF TEXT              @930824
         STRING ' R1=',(RBGRS1,,X),INTO=((R1),5+8)              @930824
         B     PRB1270
*
*        "SYNCH" PRB
*
PRB1230  MVC   WKCELL1,RBGRS15         PICK UP ENTRY POINT ADDRESS
         NI    WKCELL1+3,X'FE'         SET BIT 31 TO ZERO
         STRING INTO=(LINE+30,L'LINE-30),2X,                           X
               (WKCELL1,4,X),3X,       EP ADDRESS                      X
               (RBWLIC+3,1,X),2X,                                      X
               (RBSTAB,2,X),4X,        FLAGS                           X
               (RBFLAGS1,,X),5X,       FLAGS                           X
               (RBCDFLGS,,X)
         B     PRB1270
*
*        SVRB
*
PRB1240  TM    RBSTAB1,RBFTSVRB        IS THIS AN SVRB?
         BNO   PRB1250                 no, jump
         STRING INTO=(LINE+30,L'LINE-30),2X,                           X
               WKCELL1,3X,             SVC 055                         X
               (RBWLIC+3,1,X),2X,                                      X
               (RBSTAB,2,X),4X,        FLAGS                           X
               (RBFLAGS1,,X),5X,       FLAGS                           X
               (RBCDFLGS,,X)
         B     PRB1270
*
*        IRB
*
PRB1250  TM    RBSTAB1,RBFTIRB         IS THIS AN IRB?
         BNO   PRB1280                 no, ignore it
         STRING INTO=(LINE+30,L'LINE-30),2X,                           X
               '-IRB    ',3X,          IRB                             X
               (RBWLIC+3,1,X),2X,                                      X
               (RBSTAB,2,X),4X,        FLAGS                           X
               (RBFLAGS1,,X),5X,       FLAGS                           X
               (RBCDFLGS,,X)
*
PRB1270  CLC   RBOPSW,SDWAEC1          Abending RB?
         BNE   PRB1271                 No, jump
         MVI   LINE+29+1,C'*'          Yes, flag it
PRB1271  BAL   R14,SPACE1              PRINT LINE
         ICM   R1,B'1111',$RTM2WA      RTM2WA located?
         BNP   PRB1279                 NO, JUMP
         USING RTM2WA,R1
         TM    RTM2ERRA,RTM2ABTM       ABTERM?
         BO    PRB1275                 yes, jump
         TM    RTM2ERRA,RTM2PCHK       PROGRAM CHECK?
         BNO   PRB1279                 NO, JUMP
         L     R0,RTM2AEC1             GET INTERRUPT CODE IN R0
         DROP  R1                      RTM2WA
         STRING '-PCK',(RBWLIC+3,FL1,R3Z),'-',INTO=WKCELL1
         B     PRB1280                 NO, JUMP
PRB1275  MVC   WKCELL1,=C'-ABTERM-'
         B     PRB1280                 NO, JUMP
PRB1279  STRING '-SVC',(RBWLIC+3,FL1,R3Z),'-',INTO=WKCELL1
PRB1280  B     PRB1200                 LOOP THROUGH RB TABLE
*--ENDLOOP
PRB1288  STRING '  TASK TERMINATED',INTO=(LINE+30,L'LINE-30)
         BAL   R14,SPACE1              PRINT LINE
*
PRB1290  BAL   R14,SCANTCB             GET NEXT TCB
         BNZ   PRB1100                 PROCESS NEXT TCB
*ENDLOOP
         L     R9,PSATOLD-PSA          POINT TO ABENDING TCB
*
*        DISPLAY RB CHAIN FOR ABENDING TCB
*
PRB20    BAL   R14,BLANK1          <== BLANK LINE
         MVI   MINLINES,5
         STRING 'ABENDING TCB: ',(PSATOLD-PSA+1,3,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         SLR   R6,R6                   first time switch for NEXTRB
*
*        Process RB chain from the oldest RB
*--LOOP
PRB21    BAL   R14,NEXTRB              Point to next RB
         LTR   R6,R6                   end of chain?
         BZ    PRB99                   yes, exit loop
         CL    R6,MY_PRB               END OF CHAIN?
         BE    PRB99                   yes, exit loop
         USING RBPREFIX,R6
         LA    R0,RBBASIC              POINT TO BASIC SECTION
         ST    R0,WKCELL1              KEEP ADDR FOR DISPLAY
         MVI   MINLINES,3
*
         TM    RBSTAB1,RBFTSVRB        IS THIS AN SVRB?
         BO    PRB29                   YES, JUMP
*
         TM    RBSTAB1,RBFTIRB         IS THIS AN IRB?
         BO    PRB30                   YES, JUMP
*
*227     TM    RBCDFLGS,RBCDSYNC       CHECK FLAGS
*227     BO    PRB28                   JUMP IF IT IS A SYNCH PRB
*227     L     R5,RBCDE                GET ADDR OF CDE/LPDE
         SLR   R5,R5
         ICM   R5,B'0111',RBCDE1       Do we have a CDE?
         BZ    PRB28                   No, jump (must be a SYNCH PRB)
         STRING INTO=LINE121,                                          X
               '0  PRB: ',(WKCELL1+1,3,X),                             X
               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X
               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X
               '  CDFLGS: ',(RBCDFLGS,,X),        FLAGS                X
               '  CDNAME: ',(CDNAME-CDENTRY(R5),8) PROGRAM NAME
         BAL   R14,SPACE1          <== Print line
         B     PRB31
*
PRB28    MVC   WKCELL2,RBGRS15         PICK UP ENTRY POINT ADDRESS
         NI    WKCELL2+3,X'FE'         SET BIT 31 TO ZERO
         STRING INTO=LINE121,                                          X
               '0  PRB: ',(WKCELL1+1,3,X),                             X
               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X
               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X
               '  CDFLGS: ',(RBCDFLGS,,X),        FLAGS                X
               '  EPADDR: ',(WKCELL2,4,X)         ENTRY POINT
         BAL   R14,SPACE1          <== Print line
         CL    R6,MY_PRB               MY RBPREFIX ?
         BNE   PRB31                   NO, JUMP
         B     PRB39                   YES, QUIT
*
PRB29    STRING INTO=LINE121,                                          X
               '0 SVRB: ',(WKCELL1+1,3,X),                             X
               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X
               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X
               '  CDFLGS: ',(RBCDFLGS,,X)         FLAGS
         BAL   R14,SPACE1          <== Print line
         STRING 'SVC ROUTINE',INTO=MSG20
         TM    RBFLAGS1,RBABEND        IS THIS THE ABEND SVRB?
         BNO   PRB32                   NO, JUMP
         STRING 'RTM',INTO=MSG20
         B     PRB32                   JUMP OVER CSVQRY00 IF SVRB
*
PRB30    MVC   WKCELL2(4),RBCDE        IRB EP ADDRESS
         NI    WKCELL2+3,X'FE'         SET BIT 31 TO ZERO
         STRING INTO=LINE121,                                          X
               '0  IRB: ',(WKCELL1+1,3,X),                             X
               '  STAB: ',(RBSTAB,,X),            STATUS BYTES         X
               '  FLAGS1: ',(RBFLAGS1,,X),        FLAGS                X
               '  CDFLGS: ',(RBCDFLGS,,X),        FLAGS                X
               '  EPADDR: ',(WKCELL2,4,X)         ENTRY POINT
         BAL   R14,SPACE1          <== Print line
*
PRB31   #SETMASK RBOPSW+4              SET MASK FOR ADDR CLEAN-UP
         L     R1,RBOPSW+4             PICK UP ADDR OF NEXT INSTR.
         BAL   R14,CSVQRY00        <== FIND CORRESPONDING CDE
*
PRB32    TM    RBFLAGS1,RBXWAIT        THIS RB IN WAIT?
         BNO   PRB33                   NO, JUMP
         STRING 2X,(MSG20,,T),' *ISSUED WAIT',INTO=MSG60
         B     PRB38
*
PRB33    ICM   R1,B'1111',$RTM2WA      RTM2WA located?
         BNP   PRB37                   NO, JUMP
         USING RTM2WA,R1
         TM    RTM2ERRA,RTM2ABTM       ABTERM?
         BO    PRB36                   yes, jump
         TM    RTM2ERRA,RTM2PCHK       PROGRAM CHECK?
         BNO   PRB37                   NO, JUMP
         STRING 2X,(MSG20,,T),' *PROGRAM CHECK*',INTO=MSG60
         L     R0,RTM2AEC1             GET INTERRUPT CODE IN R0
         DROP  R1                      RTM2WA
         L     R1,=A(PCKTABLE)         START OF PCK TABLE
         BAL   R14,SCANTBL             FIND PCK NAME
         BNE   PRB38                   NOT FOUND, JUMP
         STRING (MSG60,,T),' (',(2(R1),(R2)),')',INTO=MSG60
         B     PRB38
*
PRB36    STRING 2X,(MSG20,,T),' *SYSTEM ISSUED SVC 13 (ABEND)',       --
               INTO=MSG60
         B     PRB38
*
PRB37    STRING 2X,(MSG20,,T),' ISSUED SVC ',(RBWLIC+3,FL1,L0),       --
               INTO=MSG60
         L     R0,RBWLIC               GET INTERRUPT CODE IN R0
         L     R1,=A(SVCTABLE)         START OF SVC TABLE
         BAL   R14,SCANTBL             FIND SVC NAME
         BNE   PRB38                   NOT FOUND, JUMP
         STRING (MSG60,,T),' (',(2(R1),(R2)),')',INTO=MSG60
*
PRB38    STRING 5X,INTO=LINE,                                          X
               'W-L-IC ',(RBWLIC,1,X),            WAIT COUNT           X
               '-',(RBWLIC+1,1,X),                INSTRUCTION LENGTH   X
               '-',(RBWLIC+2,2,X),                INTERRUPT CODE       X
               '  PSW ',(RBOPSW,4,X),1X,(RBOPSW+4,4,X),                X
               MSG60                   DIAGNOSTIC
         BAL   R14,SPACE1          <== Print line
*
*        Display R14-R1 from previous RB
*
         ST    R6,WKCELL1              save RB addr
         BAL   R14,NEXTRB              next RB
         STRING 5X,INTO=LINE,                                          X
               ' R14=',(RBGRS14,,X),                                   X
               '  R15=',(RBGRS15,,X),                                  X
               '  R0=',(RBGRS0,,X),                                    X
               '  R1=',(RBGRS1,,X)
         BAL   R14,SPACE1          <== Print line
         L     R6,WKCELL1              restore RB addr
*
PRB39    B     PRB21                   PROCESS NEXT RB
*ENDLOOP
PRB99    END_PROC
*----------------------------------------------------------------------
*        TCB TREE SCAN ROUTINE
*----------------------------------------------------------------------
SCANTCB  BEGIN_PROC SAVE=NO
         LR    R1,R9                   SAVE TCB ADDRESS
         L     R9,TCBLTC-TCB(,R9)      DAUGHTER
         LA    R3,1(,R3)               INDENTATION INDEX
*LOOP
SCANTCB2 LTR   R9,R9                   CHECK FOR END OF CHAIN
         BNZR  R14                     PASS VALID TCB ADDRESS
         L     R9,TCBNTC-TCB(,R1)      SISTER
         L     R1,TCBOTC-TCB(,R1)      MOTHER
         BCT   R3,SCANTCB2             INDENTATION INDEX
*ENDLOOP
         SR    R9,R9                   SET CC=0
         BR    R14                     GOBACK
*
*----------------------------------------------------------------------
*        SCAN RB chain backwards (from oldest RB)
*              Input:  R9 points to the TCB
*                      R6 points to current RBPREFIX
*              Output: R6 point to next RB
*----------------------------------------------------------------------
*
         USING RBPREFIX,R6
NEXTRB   BEGIN_PROC SAVE=NO
         LA    R0,RBBASIC              point to basic section
         SLR   R6,R6                   end of chain
         CL    R0,TCBRBP               end of chain?
         BER   R14                     yes, goback with R6=0
         ICM   R6,B'1111',TCBRBP       Point to top RB (most recent)
         BZR   R14                     no RB for this TCB, goback
*--LOOP
NEXTRB2  SH    R6,=Y(RBBASIC-RBPREFIX) POINT TO RBPREFIX
         CLM   R0,B'0111',RBLINK+1     is this the next RB?
         BE    NEXTRB4                 yes, exit loop
         TM    RBSTAB2,RBTCBNXT        oldest RB (end of chain) ?
         BO    NEXTRB4                 yes, exit loop
         LA    R1,RBBASIC              previous RB in chain
         ICM   R6,B'0111',RBLINK+1     POINT TO PREVIOUS RB (OR TCB)
         BNZ   NEXTRB2                 next RB in chain
*--ENDLOOP
         BR    R14                     goback with R6=0
*
*        Retrieve addr of RTM2WA associated with previous SVRB
*
NEXTRB4  ST    R1,$RTM2WA              previous RB
         ICM   R1,B'1111',TCBRTWA      RTM2WA
         BZ    NEXTRB4N                lost, exit
         USING RTM2WA,R1
*loop
NEXTRB4L CLC   RTM2VRBC,$RTM2WA        SVRB addr?
         BE    NEXTRB4X                yes, exit
         ICM   R1,B'1111',RTM2PREV     end of RTM2WA chain?
         BNZ   NEXTRB4L                no, process next one
*ensloop
NEXTRB4N BCTR  R1,0                    R1=FFFFFFFF
*
NEXTRB4X ST    R1,$RTM2WA              RTM2WA address or FFFFFFFF
         BR    R14                     goback
         DROP  R6,R1                   RBPREFIX,RTM2WA
*
*----------------------------------------------------------------------
*        SCAN SVC/PCK TABLES
*----------------------------------------------------------------------
*
SCANTBL  BEGIN_PROC SAVE=NO
         SLR   R2,R2
*LOOP
SCANTBL2 IC    R2,1(,R1)               PICK UP ENTRY LENGTH
         CLM   R0,B'0001',0(R1)        COMPARE SVC NUMBER WITH INTCODE
         BER   R14                     EQUAL, QUIT LOOP
         LA    R1,2(R2,R1)             BUMP TO NEXT ENTRY IN SVC TABLE
         CLI   0(R1),FF                END OF TABLE?
         BNE   SCANTBL2                NO, TRY NEXT ENTRY
*ENDLOOP
         LTR   R14,R14                 SET CC^
         BR    R14
*
*----------------------------------------------------------------------
*        PRINT JPAQ AND LOAD-LIST
*----------------------------------------------------------------------
*
PGM00    BEGIN_PROC
         BAL   R14,BLANK1          <== BLANK LINE
         MVI   MINLINES,6
         STRING 'JOB PACK AREA FOR ABENDING STEP',INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '0   NAME     ENTPT     ATTRB SP ATTR ATTR2',          X
               '  USE   MAJ-CDE   LENGTH   LOAD-PNT  DATA SET NAME',   X
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         SLR   R5,R5                   first-time switch
*LOOP
JPAQ21   BAL   R14,NEXTCDE          <- get next CDE
         LTR   R5,R5                   end of JPAQ?
         BZ    JPAQ31                  yes, exit
         USING CDENTRY,R5
         LA    R1,CDENTRY              CDE address
         BAL   R14,CDXSEARCH        <- look for a CDEX
         MVC   EYECATCH,BLANKS         no ddname
         LTR   R6,R1                   did we get one?
         BZ    JPAQ21XX                no, jump
         USING CDX1,R6
         MVC   WKCELL1,CDXDDNAM        move ddname from CDX
         TM    CDX1FLG4,CDX1PDSE       LOADED FROM PDSE?
         BZ    *+4+4+6                 NO, JUMP
         L     R1,CDXDDNAM+4           YES, LOAD ADDR OF LFMD
         MVC   WKCELL1,CDXDDNAM-CDX1(R1)    move ddname from LFMD
*
         CLI   WKCELL1,C'-'            -LNKLST- ?
         BE    JPAQ21L7                yes, jump
         CLI   WKCELL1,0               valid ddname?
         BNE   JPAQ21J                 yes, jump
*
JPAQ21L1 MVC   EYECATCH(2+2),=Y(1,80)  BLDL HDR
         MVC   EYECATCH+4(8),CDNAME    EPNAME
         L     R2,CVTPTR
         L     R2,CVTLINK-CVTMAP(,R2)  link-list DCB
         BLDL  (R2),EYECATCH           ISSUE BLDL (to LLA)
         LTR   R15,R15
         BNZ   JPAQ21XX                NOT FOUND, JUMP
         IC    R2,EYECATCH+4+8+3       pick-up concat#
         B     JPAQ21L8
*
JPAQ21L7 L     R2,CDX1TTRN             load TTRN from CDE extension
*
JPAQ21L8 N     R2,=F'255'              keep only concat#
         MH    R2,=Y(LLTNEXT-LLTENTRY) make it an offset into the LLT
         L     R3,CVTPTR
         L     R3,CVTLLTA-CVTMAP(,R3)  link-list table
         USING LLT,R3
         ALR   R3,R2                   add offset
         MVC   EYECATCH(L'LLTDSNAM),LLTDSNAM
         B     JPAQ21TR
*
JPAQ21J  STRING (WKCELL1,,T),'+',(CDX1TTRN+3,FL1,L),INTO=EYECATCH
         L     R3,TCBTIO               TIOT
         USING TIOT1,R3
         SLR   R0,R0                   PREPARE IC
*LOOP
JPAQ21J1 CLC   WKCELL1,TIOEDDNM        is this my ddname
         BE    JPAQ21J2                yes, exit loop
         IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY
         ALR   R3,R0                   BUMP UP TO NEXT ENTRY
         CLI   TIOELNGH,0              IS THIS THE END?
         BNZ   JPAQ21J1                NOT YET, LOOP THROUGH TIOT
*ENDLOOP
         B     JPAQ21TR
*
JPAQ21J2 SLR   R2,R2
         ICM   R2,B'0001',CDX1TTRN+3   concat#
         BZ    JPAQ21J6                first data set, exit
*loop
JPAQ21J3 IC    R0,TIOELNGH             LOAD LENGTH OF CURRENT ENTRY
         ALR   R3,R0                   BUMP UP TO NEXT ENTRY
         BCT   R2,JPAQ21J3             next concat#
*endloop
JPAQ21J6 LA    R2,TENWORDS+4           WORK AREA
         ST    R2,TENWORDS             WORK AREA
         USING ZB505,R2
         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA
         MVC   SWVA,TIOEJFCB           SVA OF THE JFCB
         SWAREQ FCODE=RL,EPA=TENWORDS,MF=(E,SWAREQL1),UNAUTH=YES
         L     R3,SWBLKPTR             31-BIT ADDRESS OF JFCB
         USING INFMJFCB,R3
         MVC   EYECATCH(44),JFCBDSNM   move dsname from JFCB
         DROP  R2,R3                   JFCB
*
JPAQ21TR TR    EYECATCH(44),TRTPRINT   make sure it's printable
         B     JPAQ22
*
JPAQ21XX MVC   EYECATCH(44),BLANKS     origin of load-module is unknown
*
JPAQ22   L     R6,CDXLMJP              POINT TO XL (OR MAJOR CDE)
         TM    CDATTR,CDMIN            CHECK ATTRIBUTES
         BO    JPAQ25                  JUMP IF THIS IS A MINOR CDE
         USING XTLST,R6
JPAQ21MAJ STRING 3X,CDNAME,1X,(CDENTPT,,X),4X,(CDATTRB,,X),2X,         X
               (CDSP,,X),2X,(CDATTR,,X),4X,(CDATTR2,,X),3X,            X
               (CDUSE,,X),12X,(XTLMSBLN,,X),3X,(XTLMSBAD,,X),          X
               2X,EYECATCH,            DDname from CDEX                X
               INTO=LINE
         BAL   R14,SPACE1          <== Print line
         B     JPAQ29
JPAQ25   STRING 3X,CDNAME,1X,(CDENTPT,,X),4X,(CDATTRB,,X),6X,          X
               (CDATTR,,X),4X,(CDATTR2,,X),9X,(CDNAME-CDENTRY(R6),8),  X
               21X,EYECATCH,           DDname from CDEX                X
               INTO=LINE
         BAL   R14,SPACE1          <== Print line
JPAQ29   B     JPAQ21                  next JPAQ entry
*ENDLOOP
JPAQ31   BAL   R14,BLANK1          <== BLANK LINE
         MVI   MINLINES,6
         STRING 'LOAD LIST FOR ABENDING TCB',INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '0   NAME     ENTPT     ATTRB SP ATTR ATTR2',          X
               '  COUNT  SYSCT    LENGTH   LOAD-PNT',INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         SLR   R7,R7                   first-time switch
*
*        PRINT LLE CHAIN
*LOOP
PGM51    BAL   R14,NEXTLLE          <- get next LLE
         LTR   R7,R7                   end of load-list ?
         BZ    PGM80                   yes, exit
         USING LLE,R7
         L     R5,LLECDPT              CDE PTR
         TM    CDATTR,CDMIN            CHECK ATTRIBUTES
         BNO   PGM52                   JUMP IF THIS IS A MAJOR CDE
         L     R5,CDXLMJP              POINT TO MAJOR CDE
PGM52    L     R6,CDXLMJP              POINT TO XL
         TM    CDATTRB,CDELPDE         CHECK ATTRIBUTES
         BO    PGM55                   JUMP IF THIS IS A LPA MODULE
         STRING 3X,CDNAME,1X,(CDENTPT,,X),4X,(CDATTRB,,X),2X,          X
               (CDSP,,X),2X,(CDATTR,,X),4X,(CDATTR2,,X),3X,            X
               (LLECOUNT,,X),3X,(LLESYSCT,,X),5X,                      X
               (XTLMSBLN,,X),3X,(XTLMSBAD,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         B     PGM51                   LOOP THROUGH LOAD LIST
         USING LPDE,R5
PGM55    STRING 3X,LPDENAME,1X,(LPDENTP,,X),4X,(LPDEATTB,,X),2X,       X
               (LPDESP,,X),2X,(LPDEATTR,,X),4X,(LPDEATT2,,X),3X,       X
               (LLECOUNT,,X),3X,(LLESYSCT,,X),5X,                      X
               (LPDEXTLN+1,3,X),3X,(LPDEXTAD,,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         B     PGM51                   LOOP THROUGH LOAD LIST
*ENDLOOP
PGM80    END_PROC
*
*----------------------------------------------------------------------
*        Scan JPAQ backwards (from oldest CDE)
*              Input:  R5 points to current CDENTRY
*              Output: R5 point to next CDE
*----------------------------------------------------------------------
*
NEXTCDE  BEGIN_PROC SAVE=NO
         USING *,R15
         LR    R0,R5                   point to current CDE
         L     R5,PSATOLD-PSA          my TCB
         L     R5,TCBJSTCB-TCB(,R5)    job-step TCB
         L     R5,TCBJPQ-TCB(,R5)      Top CDE (most recent)
         LTR   R5,R5                   empty JPAQ?
         BZR   R14                     yes, goback with R5=0
         USING CDENTRY,R5
*--LOOP
NEXTCDE2 CL    R0,CDCHAIN              is this the next RB?
         BER   R14                     yes, goback
         ICM   R5,B'1111',CDCHAIN      previous CDE
         BNZ   NEXTCDE2                not found yet, loop more
*--ENDLOOP
         BR    R14                     goback with R5=0
*
*----------------------------------------------------------------------
*        Scan LOAD-LIST backwards (from oldest LLE)
*              Input:  R7 points to current LLE
*              Output: R7 point to next LLE
*----------------------------------------------------------------------
*
NEXTLLE  BEGIN_PROC SAVE=NO
         USING *,R15
         LR    R0,R7                   point to current LLE
         L     R7,PSATOLD-PSA          my TCB
         L     R7,TCBLLS-TCB(,R7)      Top LLE (most recent)
         LTR   R7,R7                   empty load list?
         BZR   R14                     yes, goback with R7=0
         USING LLE,R7
*--LOOP
NEXTLLE2 CL    R0,LLECHN               is this the next RB?
         BER   R14                     yes, goback
         ICM   R7,B'1111',LLECHN       previous LLE
         BNZ   NEXTLLE2                not found yet, loop more
*--ENDLOOP
         BR    R14                     goback with R7=0
         DROP  R5,R6,R7                CDE, XL, LLE
*
*----------------------------------------------------------------------
*        PRINT COM-REG
*----------------------------------------------------------------------
*
COMREG00 BEGIN_PROC
         L     R5,PSATOLD-PSA          my TCB
         L     R5,TCBJSTCB-TCB(,R5)    job-step TCB
         L     R5,TCBJPQ-TCB(,R5)      Top CDE (most recent)
         LTR   R5,R5                   empty JPAQ?
         BZ    COMREG99                yes, exit
         USING CDENTRY,R5
*LOOP
COMREG12 CLC   =C'COM_REG ',CDNAME     is this the next RB?
         BE    COMREG21                yes, exit loop
         ICM   R5,B'1111',CDCHAIN      previous CDE
         BNZ   COMREG12                not found yet, loop more
*ENDLOOP
         B     COMREG99                not found, exit
COMREG21 L     R6,CDXLMJP              POINT TO XL
         USING XTLST,R6
         MVI   MINLINES,6
         BAL   R14,BLANK1          <== BLANK LINE
         STRING 'COM_REG',INTO=LINE
         BAL   R14,SPACE1          <== print header
         SLR   R0,R0
         ICM   R0,B'0111',XTLMSBLN     LENGTH
         L     R1,XTLMSBAD             ADDRESS
         BAL   R14,PDUMP           <== PRINT COM-REG
COMREG99 END_PROC
         DROP  R5,R6
*
*----------------------------------------------------------------------
*        PRINT PROGRAM LINKAGE INFORMATION (SAVE AREA TRACE)
*----------------------------------------------------------------------
*
LINK00   BEGIN_PROC
         BAL   R14,BLANK1          <== BLANK LINE
         L     R6,TCBFSA               FIRST SAVE AREA
         LA    R7,STACK128             LOOP PREVENTION
         XC    0(256,R7),0(R7)         CLEAN UP
         MVI   MASKADDR,X'7F'          31-BIT MODE
         MVI   MINLINES,10
         STRING '0SAVE AREA FORWARD TRACE (STARTING FROM TCBFSA)',     X
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
*LOOP
LINK10   CLM   R6,B'1000',=X'FF'       LO-SA FLAGGED?
         BNE   LINK11                  NO, JUMP
         ICM   R6,B'1000',X00          YES, ZERO IT
LINK11   LA    R6,0(,R6)               CLEAR HI-ORDER BIT
         CL    R6,REGION24             DOES THIS LOOK RIGHT?
         BL    LINK90                  NO, QUIT
        #S0C4  LINK90
         CLC   0(72,R6),0              VALIDATE 72 BYTES
        #S0C4  RESET
         BAL   R14,LINK200         <== edit save area data
         LA    R0,128                  MAX NUMBER OF SAVE AREAS
         LA    R1,STACK128             START OF STACK
*--LOOP
LINK18   CLC   0(4,R1),8(R6)           ALREADY PROCESSED OR ZERO?
         BE    LINK90                  YES, QUIT
         LA    R1,4(,R1)               BUMP INDEX
         BCT   R0,LINK18               NEXT STACK ENTRY
*--ENDLOOP
         ST    R6,0(,R7)               REMEMBER THIS SAVE AREA
         CL    R6,CURR_R13             is this the current save?
         BNE   LINK19                  no, jump
         MVI   CURR_R13,FF             yes, remember we saw it
LINK19   LR    R0,R6                   current save area
         L     R6,8(,R6)               NEXT SAVE AREA
         CLR   R6,R0                   points to itself?
         BE    LINK90                  yes, exit
         LA    R7,4(,R7)               NEXT STACK ENTRY
         B     LINK10                  DUMP IT TOO
*ENDLOOP
*        process save area at time of abend, if not processed already
*
LINK90   CLI   CURR_R13,FF             current save area processed?
         BE    LINK99                  yes, exit
         L     R6,CURR_R13             point to current save area
         CL    R6,REGION24             DOES THIS LOOK RIGHT?
         BL    LINK99                  NO, QUIT
        #S0C4  LINK99
         CLC   0(72,R6),0              VALIDATE 72 BYTES
        #S0C4  RESET
         STRING '0CURRENT SAVE AREA (R13 FROM LAST PRB)',              X
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         BAL   R14,LINK200         <== edit save area data
LINK99   END_PROC
*
*----------------------------------------------------------------------
*        Edit save-area fields
*----------------------------------------------------------------------
*
LINK200  BEGIN_PROC
         MVI   MINLINES,8
         MVC   WKCELL1,BLANKS          clear work area
         L     R1,FRSTSVRB             ABEND SVRB
         CLM   R6,B'0111',RBGRS13+1-RBPREFIX(R1)  R13 at time of abend?
         BNE   LINK203                 no, jump
         MVC   WKCELL1+3(3),=C'<=='    Current save area
LINK203  STRING INTO=LINE121,                                          X
               '0 SAVE AREA: ',((R6),,X),                              X
               '  WORD1: ',(0(R6),4,X),                                X
               '  PREVIOUS: ',(4(R6),4,X),                             X
               '  NEXT: ',(8(R6),4,X),WKCELL1
         BAL   R14,SPACE1          <== Print line
*
*        DECODE ENTRY ADDRESS
*
         MVC   VIACALL,=C'CALL '       CALL/LINK/SYNCH
         MVC   REGS(52),20(R6)         MOVE R0-R12
         MVC   REGS+56(8),12(R6)       MOVE R14-R15
         L     R14,CVTPTR          <== GET CVT ADDRESS
         LA    R0,CVTEXIT-CVTMAP(,R14) GET ADDR OF CVTEXIT FIELD
         CLM   R0,B'0111',13(R6)       IS THIS THE RETURN ADDRESS?
         BNE   LINK222                 NO, JUMP
         TM    12(R6),X'7F'            IS THIS A 24-BIT ADDR?
         BNZ   LINK222                 NO, JUMP
         MVC   VIACALL,=C'LINK '       YES, CHANGE 'CALL' TO 'LINK'
         B     LINK228
*
*        CHECK IF REGISTERS SAVED WITH "STM R14,R10,20(R13)"
*
LINK222 #S0C4  LINK228
**       L     R2,LASTPRB              POINT TO LAST PRB
**       CLI   RBOPSW+4-RBPREFIX(R2),0 AMODE24?
**       BNE   LINK228                 NO, JUMP
         L     R2,FRSTSVRB             POINT TO FIRST SVRB
**       CL    R6,RBGRS13-RBPREFIX(,R2) SAVE AREA AT TIME OF ABEND?
**       BNE   LINK228                 NO, JUMP
**       CLI   20(R6),X'00'            BAL/BALR?
**       BE    LINK228                 NO, JUMP
         LM    R14,R1,20(R6)           R14-R1 FROM R0-R3 SLOTS
         CLI   32(R6),FF               R1 IN COMPLEMENT FORM?
         BNE   LINK223                 NO, JUMP
         LPR   R1,R1                   YES, MAKE IT POSITIVE
*
LINK223  ICM   R1,B'1000',X00          CLEAN UP HI-ORDER BYTE
**       CL    R1,RBGRS1-RBPREFIX(,R2) IS THIS MY DCB ADDRESS?
**       BNE   LINK224                 NO, JUMP
         CLM   R15,B'0111',DCBPUT+1-IHADCB(R1)   R15 in R1 slot?
         BE    LINK225                 yes, JUMP
*read/write/check macro
         USING DECB,R1
LINK224  TM    DECBDCBA,X'7F'          valid DCB addr?
         BNZ   LINK228                 NO, JUMP
         TM    DECBDCBA+3,X'03'        valid DCB addr?
         BNZ   LINK228                 NO, JUMP
         L     R1,DECBDCBA             DCB address from DECB
         DROP  R1                      was DECB
         CL    R1,REGION24             DOES THIS LOOK RIGHT?
         BL    LINK228                 NO, QUIT
         CL    R1,REGION24+4           DOES THIS LOOK RIGHT?
         BH    LINK228                 NO, QUIT
         CLM   R15,B'0111',DCBREAD+1-IHADCB(R1)  R15 in R1 slot?
         BE    LINK225                 yes, jump
         CL    R15,DCBCHECK-IHADCB(,R1) DCBCHECK IN R1 SLOT?
         BNE   LINK228                 NO, JUMP
*
*        validate DCB/DEB pointers
*
LINK225  ICM   R14,B'0111',DCBDEBAD+1-IHADCB(R1)   DEB address
         BZ    LINK228                 BAD, QUIT
         CLM   R1,B'0111',DEBDCBAD+1-DEBBASIC(R14) COMP W/ DCB ADDR
         BNE   LINK228                 BAD, QUIT
*
*        make sure R15 points to IGG019xx
*
         LR    R1,R15                  PASS EP ADDR
         ICM   R1,B'1000',X00          CLEAN UP
         BAL   R14,CSVQRY00        <== FIND LOAD MODULE
         LTR   R5,R5                   CDE FOUND?
         BZ    LINK228                 NO, JUMP
         CLC   =C'IGG019',CDNAME-CDENTRY(R5)
         BNE   LINK228                 NO, JUMP
         MVC   REGS(44),28(R6)                   MOVE R0-R10
         MVC   REGS+44(8),RBGRS11-RBPREFIX(R2)        R11-R12
         MVC   REGS+56(8),20(R6)                      R14-R15
         MVI   MASKADDR,X'00'          24-BIT MODE              @921003
         B     LINK231                                          @921003
*
LINK228 #S0C4  LINK237
         ICM   R1,B'1111',REGS+60      R15 (ENTRY ADDRESS)
         BZ    LINK241                 NO EP ADDR, JUMP
         CLM   R1,B'1111',BLANKS       R15 (ENTRY ADDRESS)
         BE    LINK241                 NO EP ADDR, JUMP
         TM    REGS+56,X'80'           AMODE31 IN R14?
         BZ    LINK228C                NO, JUMP
         TM    REGS+56,X'40'           BAL R14,8(,R15) ?
         BO    LINK228C                YES, JUMP
         BAL   R14,CSVQRY00        <== FIND LOAD MODULE
         LTR   R5,R5                   CDE FOUND?
         BP    LINK231                 YES, JUMP
LINK228C MVI   MASKADDR,X'00'          24-BIT MODE
         L     R1,REGS+60              R15 (ENTRY ADDRESS)
         BAL   R14,CSVQRY00        <== FIND LOAD MODULE
         LTR   R5,R5                   CDE FOUND?
         BNP   LINK237                 NO, JUMP
*
*        EDIT EYE CATCHER AT ENTRY POINT
*
LINK231  MVC   EYECATCH,BLANKS
         TM    REGS+63,1               R15 HAS ODD VALUE?
         BO    LINK234                 YES, DO NOT IDENTIFY ENTRY ADDR
         L     R1,REGS+60              R15 (ENTRY ADDRESS)
         N     R1,MASKADDR             CLEAN-UP ADDRESS
        #S0C4  LINK234
         CLC   0(24,R1),0              VALIDATE 24 BYTES
        #S0C4  RESET
*sub-routine: B 4(15)
LINK232B LA    R0,64                   default length for eye-catcher
         LA    R2,4(,R1)               first byte of eye-catcher
         CLC   =X'47FF00',0(R1)        IS THIS A BRANCH?
         BE    LINK233                 yes, JUMP
*OS/VS COBOL INIT1
LINK232C LA    R0,8+4                  modulenmVSR1
         LA    R2,12(,R1)              first byte of eye-catcher
         CLC   =C'VSR1',8(R2)          OS/VS INIT1 signature?
         BE    LINK233                 yes, JUMP
*SAVE MACRO
LINK232S IC    R0,4(,R1)               LENGTH OF EYE CATCHER
         LA    R2,5(,R1)               first byte of eye-catcher
         CLC   =X'47F0',0(R1)          IS THIS A BRANCH?
         BNE   LINK232P                NO, JUMP
         TM    2(R1),X'F0'             IS THIS A BRANCH?
         BO    LINK233                 yes, JUMP
*PROGID macro
LINK232P LA    R0,X'001A'              eye catcher length
         LR    R2,R1                   entry address (R15)
         SLR   R2,R0                   point to CSECT origin
         CLC   0(4,R1),=X'90EC,D00C'   PROGID prolog?
         BNE   LINK234                 NO, JUMP
         CLC   8(10,R1),=X'50E0D008,50D0E004,18DE'
         BNE   LINK234                 NO, JUMP
         CLC   20(4,R1),=X'41F0001A'   PROGID prolog?
         BNE   LINK234                 NO, JUMP
*
LINK233  STRING ', EYE CATCHER IS "',((R2),(R0)),'"',INTO=EYECATCH
         TR    EYECATCH,TRTPRINT       KEEP ONLY PRINTABLE CHARACTERS
*
*INK234  STRING 2X,EPNAME,' WAS ENTERED VIA ',VIACALL,                 X
               ' AT OFFSET ',OFFSET,EYECATCH,INTO=LINE
LINK234  STRING 1X,(EPNAME,,T),(OFFSET,,T),                            X
               ' WAS ENTERED VIA ',(VIACALL,,T),EYECATCH,INTO=LINE
         BAL   R14,SPACE1L         <== print with lower-case
         B     LINK241
*
LINK237  STRING ' *UNKNOWN WAS ENTERED VIA ',VIACALL,                  X
               ' AT LOCATION ',(REGS+60,4,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
*
*        DECODE RETURN ADDRESS
*
LINK241  MVC   EYECATCH,BLANKS         CLEAR WORK AREA
         CLI   VIACALL,C'C'            WAS IT A CALL?
         BNE   LINK261                 NO, JUMP
         MVI   MASKADDR,X'7F'          31-BIT MODE
         L     R1,REGS+56              RETURN ADDRESS
         SRL   R1,1                    CLEAN UP "T" BIT
         SLL   R1,1                    CLEAN UP "T" BIT
         BAL   R14,CSVQRY00        <== FIND LOAD MODULE
         LTR   R5,R5                   CDE FOUND?
         BP    LINK248                 YES, JUMP
         SLR   R1,R1
         ICM   R1,B'0111',REGS+57 TRY 24-BIT ADDRESS
         BAL   R14,CSVQRY00        <== FIND LOAD MODULE
         LTR   R5,R5                   CDE FOUND?
         BZ    LINK261                 NO, JUMP
LINK248  STRING 4X,'RETURN ADDRESS IS ',MSG20,INTO=EYECATCH
*
LINK261  STRING '0   GPR00-03: ',(REGS,4,X),2X,(REGS+4,4,X),2X,        X
               (REGS+8,4,X),2X,(REGS+12,4,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR04-07: ',(REGS+16,4,X),2X,(REGS+20,4,X),2X,     X
               (REGS+24,4,X),2X,(REGS+28,4,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR08-11: ',(REGS+32,4,X),2X,(REGS+36,4,X),2X,     X
               (REGS+40,4,X),2X,(REGS+44,4,X),INTO=LINE
         BAL   R14,SPACE1          <== Print line
         STRING '   GPR12-15: ',(REGS+48,4,X),12X,                     X
               (REGS+56,4,X),2X,(REGS+60,4,X),EYECATCH,INTO=LINE
         BAL   R14,SPACE1          <== Print line
LINK299  END_PROC
*
*----------------------------------------------------------------------
*        PRINT OPEN FILES
*----------------------------------------------------------------------
*
DEB000   BEGIN_PROC
         ICM   R5,B'1111',TCBDEB       FIRST DEB
         BZ    DEB099                  NO DEB, JUMP
*LOOP
DEB011   SH    R5,=Y(DEBBASIC-DEBPREFX) POINT TO DEB PREFIX
         USING DEBPREFX,R5
         MVI   MINLINES,9
         LA    R0,DEBBASIC             POINT TO BASIC SECTION
         CLM   R0,B'0111',DCBDEBAD+1-IHADCB+DCBDEBUG  is it my own DCB?
         BE    DEB080                  YES, SKIP IT
         ST    R0,WKCELL1+4            DEB ADDRESS FOR $PRINT
*
         BAS   R3,DEB032
         DC    C'VSAM',AL1(DEBAMVSM)
         DC    C'EXCP',AL1(DEBAMXCP)
         DC    C'SAM ',AL1(DEBAMSAM)
         DC    C'BDAM',AL1(DEBAMBDM)
         DC    C'JES ',AL1(DEBAMSUB)
         DC    C'VTAM',AL1(DEBAMVTM)
         DC    C'????',0H'0'
*--LOOP
DEB032   CLC   DEBAMTYP,4(R3)          IS THIS MY AMTYPE?
         BE    DEB040                  YES, JUMP
         LA    R3,4+1(,R3)             BUMP TABLE PTR
         CLI   0(R3),C'?'              END OF TABLE?
         BNE   DEB032                  NEXT TABLE ENTRY
*--ENDLOOP
DEB040   SLR   R6,R6                   DCB/ACB addr set by VALDCB rtne
         BAL   R14,SWA000          <== locate DEB/DSAB/SIOT/JFCB/TIOT
         BAL   R14,VALDCB          <== LOCATE/VALIDATE DCB (or ACB)
         LTR   R6,R6                   CHECKED OUT OK?
         BZ    DEB048                  NO, SKIP IT
         ST    R6,WKCELL1              FOR $PRINT
         LH    R0,DCBTIOT-IHADCB(,R6)  GET TIOT OFFSET FOR THIS DCB
         BAL   R14,EXCP00          <== GET EXCP COUNT IN R0
         B     DEB050
*
DEB048   MVC   WKCELL1(4),DEBDCBAD     FOR $PRINT
         MVC   DDNAME2(8),=C'********' DCB is bad
         SLR   R0,R0                   EXCP=0
         ICM   R15,B'1111',$SIOT       SIOT addr good?
*EX 0,*
         BNP   DEB050                  no, exit
         MVC   DDNAME2(8),SCTDDNAM-SIOT(R15)
*
         L     R1,PSATOLD-PSA          MY TCB
         L     R1,TCBTCT-TCB(,R1)      TCBTCT
         USING SMFTCT,R1
         L     R1,TCTIOTBL             START OF I/O MEASUREMENT TABLE
         USING TCTTIOT,R1
         ICM   R15,B'1111',$DSAB       DSAB POINTER
         BNP   DEB050                  no, exit
         USING DSAB,R15
         LH    R15,DSABTCTL            OFFSET TO TCT DD ENTRY
         LA    R15,TCTTIOT(R15)        DD LOOKUP TABLE ENTRY
         USING TCTIODSP,R15
         L     R15,TCTIOTSD            OFFSET TO I/O CTR ENTRY
         LA    R1,TCTTIOT(R15)         ADDRESS OF I/O CTR ENTRY
         USING TCTDDENT,R1
         L     R0,TCTDCTR              EXCP COUNT
         DROP  R15,R1
*
DEB050   IC    R1,DEBOPATB             OPEN OPTION
         LA    R15,X'0F'               MASK FOR 'NR'
         NR    R1,R15                  KEEP ONLY X'0F' BITS
         IC    R1,OPENOPT1(R1)         GET OFFSET TO OPENOPT2 ENTRY
         LA    R1,OPENOPT2(R1)         POINT TO OPEN OPTION
*
         BAL   R14,BLANK1          <== BLANK LINE
         CLI   DEBAMTYP,DEBAMVSM       VSAM?
         BE    DEB060                  YES, JUMP
         CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?
         BE    DEB070                  YES, JUMP
***      STRING '0',INTO=LINE121,                                      X
               ((R3),4),' DEB: ',(WKCELL1+5,3,X),                      X
               2X,((R1),6),            IN/OUT/UPD                      X
               '  DCB: ',(WKCELL1+1,3,X),                              X
               '  DDN: ',DDNAME2,                                      X
               '  EXCP: ',((R0),,L)
         STRING '0DEB=',(WKCELL1+5,3,X),                               +
               ',',((R3),4,T),         SAM/VSAM/JES                    +
               ',',((R1),6,T),         INPUT/OUTPUT/UPDATE/EXTEND/OUTIN+
               ',DCB=',(WKCELL1+1,3,X),                                +
               ',DDN=',(DDNAME2,,T),                                   +
               ',EXCP=',((R0),,L),                                     +
               INTO=LINE121
         TM    DEBFLGS1,DEBEOFDF       EOF flag ON?     IECEQU=DEBF1EOF
*LASTVOL BO    DEB056                  yes, jump
*LASTVOL TM    DEBOFLGS,DEBEOF         EOF flag ON?     IECEQU=DEBOFEOF
         BZ    DEB057                  no, jump
DEB056   LA    R15,LINE121(R15)        end of text
         MVC   0(4,R15),=C',EOF'       append indicator
DEB057   BAL   R14,SPACE1          <== Print line
         CLI   DDNAME2,C'*'            DCB OK?
         BE    DEB080                  no, exit
         BAL   R14,PRDCB           <== PRINT DCB DATA
         B     DEB080
*
OPENOPT1 DC    AL1(0,06,0,12,18,0,0,24,0,0,0,0,0,0,30,36)
OPENOPT2 DC    C'INPUT RDBACKINOUT UPDAT OUTIN EXTENDOUTPUT'
*
DEB060   STRING '0DEB=',(WKCELL1+5,3,X),                           VSAM+
               ',',((R3),4,T),         VSAM                            +
               ',ACB=',(WKCELL1,4,X),                                  +
               ',DDN=',(DDNAME2,,T),                                   +
               ',EXCP=',((R0),,L),                                     +
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         CLI   DDNAME2,C'*'            ACB OK?
         BE    DEB080                  no, exit
         BAL   R14,PRACB           <== PRINT ACB/PLH (VSAM/JES)
         B     DEB080
*
DEB070   STRING '0DEB=',(WKCELL1+5,3,X),                         SUBSYS+
               ',',((R3),4,T),         SUBSYS                          +
               ',',((R1),6,T),         INPUT/OUTPUT/UPDATE/EXTEND/OUTIN+
               ',ACB=',(WKCELL1,4,X),                                  +
               ',DDN=',(DDNAME2,,T),                                   +
               ',EXCP=',((R0),,L),                                     +
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         CLI   DDNAME2,C'*'            ACB OK?
         BE    DEB080                  no, exit
         BAL   R14,PRACB           <== PRINT ACB/PLH (VSAM/JES)
*
DEB080   ICM   R5,B'0111',DEBDEBAD+1   NEXT DEB IN CHAIN
         BNZ   DEB011                  TRY NEXT DCB
*ENDLOOP
DEB099   END_PROC
*
*----------------------------------------------------------------------
*        Print SDWA
*----------------------------------------------------------------------
*
PRWA00   BEGIN_PROC
         STRING '0SCHEDULER WORK AREA',INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,SDWALEN              LENGTH
         LA    R1,SDWA                 ADDRESS
         BAL   R14,DUMP32          <== PRINT SDWA
PRWA99   END_PROC
*
*----------------------------------------------------------------------
*        GET EXCP COUNT FROM TCT
*----------------------------------------------------------------------
*
EXCP00   BEGIN_PROC
         L     R1,PSATOLD-PSA          MY TCB
         L     R1,TCBTCT-TCB(,R1)      TCBTCT
         L     R1,TCTIOTBL-SMFTCT(,R1) START OF I/O MEASUREMENT TABLE
         LA    R1,TCTIODSP-TCTTIOT(,R1) FIRST DD ENTRY
         USING TCTDCBTD,R1
*LOOP
EXCP11   CL    R0,TCTDCBTD             SAME TIOT OFFSET?
         BE    EXCP21                  YES, EXIT LOOP
         LA    R1,TCTDCBLE             NEXT LOOKUP TABLE ENTRY
         ICM   R15,B'1111',TCTDCBLE    END OF TABLE ?
         BNZ   EXCP11                  NOT YET, TRY NEXT DD ENTRY
*ENDLOOP
         SLR   R0,R0                   EXCP COUNT IS ZERO
         B     EXCP99
*
EXCP21   L     R1,TCTIOTSD             OFFSET IN I/O MEASURE. TABLE
         L     R15,PSATOLD-PSA         MY TCB
         L     R15,TCBTCT-TCB(,R15)    MY TCT
         A     R1,TCTIOTBL-SMFTCT(,R15) START OF I/O MEASUREMENT TABLE
         USING TCTDDENT,R1
         ICM   R0,B'1111',TCTDCTR      EXCP COUNT IN R0
EXCP99   LR    R1,R0                   EXCP COUNT IN R1 TOO
         END_PROC
         DROP  R1
*
*----------------------------------------------------------------------
*        CONVERT UCBTYP TO UNITNAME
*----------------------------------------------------------------------
*
GETUNIT  BEGIN_PROC
         MVI   TENWORDS+20,X'01'       RETURN A LOOK-UP VALUE (BIT7)
         MVI   TENWORDS+21,X'00'       CLEAR UNUSED BYTE
         LA    R14,UNITNAME        <== UNITNAME+DEVTYPE
         LA    R15,TENWORDS+20         FLAGS
         STM   R14,R15,TENWORDS    <==
         OI    TENWORDS+4,X'80'        END-OF-LIST FLAG
         LA    R1,TENWORDS             PARM LIST ADDRESS
         L     R15,IEFEB4UV            LOAD ROUTINE ADDRESS
         BALR  R14,R15             <== GET UNIT NAME
         LTR   R15,R15
         BNZ   GETUNIT6                BAD RETURN CODE, QUIT
         MVI   TENWORDS+20,X'20'       RETURN A UNIT NAME (BIT2)
         LA    R1,TENWORDS             PARM LIST ADDRESS
         L     R15,IEFEB4UV            LOAD ROUTINE ADDRESS
         BALR  R14,R15             <== GET UNIT NAME
         LTR   R15,R15
         BZ    GETUNIT9                GOOD RETURN CODE, GOBACK
GETUNIT6 MVC   UNITNAME,BLANKS         CONVERSION DID NOT WORK
GETUNIT9 DS    0H
         END_PROC
*
*----------------------------------------------------------------------
*        VALIDATE DCB, FIND TIOT OFFSET
*----------------------------------------------------------------------
*
VALDCB   BEGIN_PROC
        #S0C4  VALDCB8
         CLI   $ACB,FF                 VSAM/SUBSYS?
         BNZ   VALDCB3                 YES, JUMP
         USING DEBPREFX,R5
         USING IHADCB,R6
         TM    DCBTIOT,X'C0'           IS DCB OPEN?
         BNZ   VALDCB5                 NO, JUMP
*
*        VALIDATE DCB/DEB CROSS POINTERS
*
         CLI   OCE_CODE,C'O'           OPEN SVC?                @921015
         BE    VALDCB3                 YES, SKIP DEB VALIDATION
         LTR   R5,R5                   DEB address set already?
         BNZ   VALDCB3                 YES, SKIP DEB VALIDATION
         SLR   R1,R1
         ICM   R1,B'0111',DCBDEBAD+1   PICK UP DEB ADDRESS
         BZ    VALDCB8                 BAD, QUIT
         CLM   R6,B'0111',DEBDCBAD+1-DEBBASIC(R1) COMP W/ DCB ADDR
         BNE   VALDCB8                 BAD, QUIT
         SLR   R5,R5
         ICM   R5,B'0111',DCBDEBAD+1   GET DEB ADDRESS          @920408
         SH    R5,=Y(DEBBASIC-DEBPREFX) POINT TO DEB PREFIX     @920408
*
*        LOCATE CORRESPONDING TIOT ENTRY
*
VALDCB3  L     R1,TCBTIO               TIOT ADDRESS
         LA    R1,0024(,R1)            FIRST DD ENTRY
*LOOP
VALDCB3B CLI   4(R1),C' '              BLANK DDNAME?
         BNH   VALDCB3F                YES, JUMP
         MVC   DDNAME,4(R1)            SAVE DDNAME
         SLR   R15,R15                 CONCAT#
         B     VALDCB3G
VALDCB3F LA    R15,1(,R15)             BUMP CONCAT#
VALDCB3G CL    R1,$TIOT                is it my DD entry?
         BE    VALDCB4                 YES, QUIT
         SLR   R0,R0
         IC    R0,0(,R1)               LOAD TIOELNGH
         AR    R1,R0                   NEXT TIOT ENTRY
         CLI   0(R1),00                END-OF-TIOT REACHED?
         BNE   VALDCB3B                NOT YET, LOOP FURTHER
*ENDLOOP
         B     VALDCB8                 END OF TIOT, QUIT
*
VALDCB4  MVC   DDNAME2,BLANKS          CLEAR WORK AREA
         MVC   DDNAME2(8),DDNAME       SAVE DDNAME
         LTR   R0,R15                  PASS CONCAT#
         BZ    VALDCB9                 FIRST IN CONCAT, JUMP
         STRING (DDNAME,,T),'+',((R0),,R3Z),INTO=DDNAME2 SYSIN+002
         B     VALDCB9
*
*        NON-OPEN DCB
*
VALDCB5  CLI   DCBOFLGS,2              OPEN FLAGS OK?
         BNE   VALDCB8                 NO, JUMP
         MVC   DDNAME,DCBDDNAM         SAVE DDNAME
         MVC   DDNAME2,DCBDDNAM        SAVE DDNAME
         TR    DDNAME2,TRTPRINT
         CLC   DDNAME2,DCBDDNAM        GOOD DDNAME?
         BE    VALDCB9                 YES, JUMP
*
VALDCB8  SR    R6,R6                   NOT A DCB, GOBACK
         MVC   DDNAME,BLANKS           CLEAR DDN
         MVC   DDNAME2,BLANKS          CLEAR DDN
VALDCB9 #S0C4  RESET
         END_PROC
*
*----------------------------------------------------------------------
*        Locate DSAB/SIOT/JFCB/TIOT from DEB extension
*----------------------------------------------------------------------
*
SWA000   BEGIN_PROC
         MVI   $DCB,FF                 invalidate DCB address
         MVI   $ACB,FF                 invalidate ACB address
         MVI   $DSAB,FF                invalid address
         MVI   $SIOT,FF                invalid address
         MVI   $JFCB,FF                invalid address
         MVI   $TIOT,FF                invalid address
*
*        retrieve DCB/ACB address from DEB if R5=A(DEBPREFX)
*
SWA010   LTR   R5,R5                   DEB addr valid?
         BZ    SWA020                  no, jump
         USING DEBPREFX,R5
         LTR   R6,R6                   DCB/ACB addr valid?
         BNZ   SWA025                  yes, jump
         ICM   R6,B'0111',DEBDCBAD+1   24-bit DCB/ACB addr
         CLI   DEBAMTYP,DEBAMSUB       AM=SUBSYS?
         BE    SWA018                  yes, jump
         CLI   DEBAMTYP,DEBAMVSM       AM=VSAM?
         BNE   SWA025                  no, process DCB
*
*        AM=VSAM
*
SWA017   ST    R6,$ACB                 ACB address (24-bit)
         ICM   R0,B'1111',DEBRRQ       do we have an RMODE31 ACB?
         BZ    SWA030                  no, use RMODE24 ACB
         LR    R6,R0                   yes, use RMODE31 ACB
         B     SWA030                  Process ACB
*
*        AM=SUBSYS
*
SWA018   ST    R6,$ACB                 ACB address
         ICM   R0,B'1111',DEBRRQ       do we have a DCB?
         BZ    SWA030                  no, use ACB
         LR    R6,R0                   yes, use DCB
         B     SWA025                  Process ACB
*
*        if invoked with R5=0, set DEB addr from DCB/ACB
*
SWA020   LTR   R6,R6                   DCB/ACB addr valid?
         BZ    SWA090                  no, exit
         TM    DCBOFLGS,DCBOFOPN       OPEN DCB?
         BZ    SWA090                  no, exit
         ICM   R5,B'0111',DCBDEBAD+1   DEB address from DCB/ACB
         SH    R5,=Y(DEBBASIC-DEBPREFX)  point at DEB prefix
*
SWA025   ST    R6,$DCB                 DCB address
         USING IHADCB,R6
*
*        retrieve DSAB addr from DEB extension
*
SWA030   TM    DEBFLGS1,DEBXTNIN       do we have a DEB extension?
         BZ    SWA090                  no, exit
         ICM   R1,B'1111',DEBXTNP      DEB extension
         BZ    SWA090                  zero, exit
         USING DEBXTN,R1
         ICM   R2,B'1111',DEBXDSAB     OPENJ DSAB pointer
         BNZ   SWA035                  non-zero, jump
         ICM   R2,B'1111',DEBXDSAB     DSAB pointer
         BZ    SWA090                  no DSAB, exit
         USING DSAB,R2
SWA035   CLC   DSABID,=C'DSAB'         is this a DSAB?
         BNE   SWA090                  no DSAB, jump
         ICM   R1,B'1111',DSABSIOT     SIOT ptr
         BNZ   SWA040                  ok, jump
         LA    R1,TENWORDS+4           WORK AREA
         ST    R1,TENWORDS             WORK AREA
         USING ZB505,R1
         XC    SWAEPAX,SWAEPAX         CLEAR WORK AREA
         MVC   SWVA,DSABSSVA           SVA OF THE SIOT
         DROP  R1
         SWAREQ FCODE=RL,EPA=TENWORDS,MF=(E,SWAREQL1),UNAUTH=YES
         L     R1,SWBLKPTR-ZB505+TENWORDS+4  31-BIT ADDRESS OF SIOT
*
SWA040   ST    R2,$DSAB                DSAB ADDRESS
         ST    R1,$SIOT                SIOT ADDRESS
         USING INDMSIOT,R1
         MVC   $JFCB,SJFCBPTR          JFCB pointer
         MVC   $TIOT,DSABTIOT          TIOENTRY pointer
         DROP  R2,R1                   DSAB,SIOT
*
SWA090   END_PROC
         DROP  R5,R6                   DEB, DCB
*
*----------------------------------------------------------------------
*        PRINT DCB INFORMATION
*----------------------------------------------------------------------
*
PRDCB    BEGIN_PROC
         USING DEBPREFX,R5
         USING IHADCB,R6
         LTR   R6,R6                   DCBADDR=0?
         BNP   PRDCB99                 yes, ignore
         ST    R6,WKCELL1              STORE DCB ADDRESS
*
         LA    R15,=C'ISPSDAPOVS??'
         TM    DCBDSORG+0,X'80'        IS
         BO    PRDCB07                 IS
         LA    R15,2(,R15)
         TM    DCBDSORG+0,X'40'        PS
         BO    PRDCB07                 PS
         LA    R15,2(,R15)
         TM    DCBDSORG+0,X'20'        DA
         BO    PRDCB07                 DA
         LA    R15,2(,R15)
         TM    DCBDSORG+0,X'02'        PO
         BO    PRDCB07                 PO
         LA    R15,2(,R15)
         TM    DCBDSORG+1,X'08'        VS
         BO    PRDCB07                 VS
         LA    R15,2(,R15)
PRDCB07  MVC   XDSORG,0(R15)           MOVE DSORG
*
         MVC   XRECFM,BLANKS
         LA    R1,XRECFM               START OF WORK AREA
         TM    DCBRECFM,DCBRECF        F/V/U
         BNO   PRDCB08V                F/V/U
         MVI   0(R1),C'F'              F/V/U
PRDCB08V TM    DCBRECFM,DCBRECV        F/V/U
         BNO   PRDCB08U                F/V/U
         MVI   0(R1),C'V'              F/V/U
PRDCB08U TM    DCBRECFM,DCBRECU        F/V/U
         BNO   PRDCB08B                F/V/U
         MVI   0(R1),C'U'              F/V/U
PRDCB08B TM    DCBRECFM,DCBRECBR       .B
         BNO   PRDCB08S                .B
         MVI   1(R1),C'B'              .B
         LA    R1,1(,R1)
PRDCB08S TM    DCBRECFM,X'08'          ..S
         BNO   PRDCB08A                ..S
         MVI   1(R1),C'S'              ..S
         LA    R1,1(,R1)
PRDCB08A TM    DCBRECFM,X'04'          ...A
         BNO   PRDCB08M                ...A
         MVI   1(R1),C'A'              ...A
PRDCB08M TM    DCBRECFM,X'02'          ...M
         BNO   PRDCB08Z                ...M
         MVI   1(R1),C'M'              ...M
PRDCB08Z EQU   *
         TM    DCBMACRF,DCBMRECP       EXCP DCB?
         BO    PRDCB31                 YES, JUMP
         TM    DCBMACRF,DCBMRGET       QSAM DCB?
         BO    PRDCB41                 YES, JUMP
         TM    DCBMACRF+1,DCBMRPUT     QSAM DCB?
         BO    PRDCB41                 YES, JUMP
         MVI   WKCELL1,C'P'            A "P" FOR BPAM
         TM    DCBDSORG,JFCORGPO       BPAM DCB?
         BO    PRDCB11                 YES, JUMP
         MVI   WKCELL1,C'D'            A "D" FOR BDAM
         TM    DCBDSORG,JFCORGDA       BDAM DCB?
         BO    PRDCB11                 YES, JUMP
         MVI   WKCELL1,C'S'            A "S" FOR BSAM
PRDCB11  MVI   MINLINES,6
         STRING '0  B',(WKCELL1,1),'AM',                               X
               ' DCB AT LOCATION ',(WKCELL1+1,3,X),                    X
               6X,'RECFM=',(XRECFM,,T),                                X
               ',LRECL=',(DCBLRECL,H,L),                               X
               ',BLKSIZE=',(DCBBLKSI,H,L),                             X
               ',BUFNO=',(DCBBUFNO,FL1,L),                             X
               ',NCP=',(DCBNCP,FL1,L),                                 X
               ',BUFL=',(DCBBUFL,H,L),                                 X
               ',DSORG=',(XDSORG,,T),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,DCBLNGPO             LENGTH
         LA    R1,IHADCB               ADDRESS
         BAL   R14,DUMP32          <== PRINT IT
*
*        Print DCBE, if present
*
         TM    DCBEODAD,DCBH0+DCBH1    Is DCBDCBE valid ?
         BNO   PRDCB16                 no, jump
         L     R1,DCBDCBE              A(DCBE)
         USING DCBE,R1
         OC    DCBE(DCBEMINL),DCBE     validate
         MVI   MINLINES,6
         STRING '0  DCBE AT LOCATION ',(DCBDCBE,,X),INTO=LINE121
         BAL   R14,SPACE1          <== print header
         LH    R0,DCBELEN              length of DCBE
         BAL   R14,DUMP32          <== print DCBE
*
*        LOOK FOR DECB IF S001-XX ABEND
*
PRDCB16  CLI   OCE_CODE,C'E'           S001 ABEND?
         BNE   PRDCB21                 NO, JUMP
         L     R1,FRSTSVRB             LOAD ADDR OF FIRST SVRB
         L     R1,RBGRS4-RBPREFIX(,R1) R1 POINTS TO DECB
        #S0C4  PRDCB21
         C     R6,DECDCBAD-DECB(,R1)   IS THIS MY DCB?
         BNE   PRDCB21                 NO, QUIT
         ST    R1,WKCELL1              STORE DECB ADDRESS
         STRING '0  DECB AT LOCATION ',(WKCELL1+1,3,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,020                  LENGTH OF DECB
         BAL   R14,DUMP32          <== PRINT DECB
         L     R2,DECIOBPT-DECB(,R1)   PICK UP IOB ADDRESS FROM DECB+16
         USING IOBSTDRD-8,R2
         CL    R6,IOBDCBPT             IS THIS MY DCB?
         BE    PRDCB24                 YES, JUMP
*
*        LOCATE CURRENT IOB FROM DCBIOBA (DCB+68)
*
PRDCB21 #S0C4  RESET
         SLR   R2,R2
         ICM   R2,B'0111',DCBIOBA+1    GET IOB ADDRESS (DCB+68)
         CLI   DCBNCP,1                NCP>1?
         BNH   PRDCB24                 NO, JUMP
         ICM   R2,B'0111',DCBICQE+1    YES, GET ICQE ADDRESS (DCB+28)
         STRING '0  ICQE AT LOCATION ',(DCBICQE+1,3,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,032                  ICQE SIZE
         LR    R1,R2                   ICQE ADDRESS
         BAL   R14,DUMP32          <== PRINT ICQE
         L     R2,ICQFIRST-ICQE(,R2)   POINT TO FIRST IOB IN CHAIN
         ICM   R2,B'1000',X00          zero first byte
*SAMB    L     R2,ICQIOBAD-ICQE(,R2)   POINT TO IOB IN SAMB
*SAMB    SH    R2,=H'16'               POINT TO START OF SAMB
*SAMB    ST    R2,WKCELL1              STORE FOR STRING
*SAMB    STRING '0  SAMB AT ADDRESS ',(WKCELL1+1,3,X),INTO=LINE
*SAMB    BAL   R14,SPACE1          <== Print line
*SAMB    LA    R0,256                  SAMB SIZE
*SAMB    LR    R1,R2                   SAMB ADDRESS
*SAMB    BAL   R14,DUMP32          <== PRINT ICQE
*SAMB    LA    R2,8(,R2)               SAMIOB (IOB PREFIX)
*
*        PRINT CURRENT IOB
*
PRDCB24  CL    R2,REGION24             DOES THIS LOOK RIGHT?
         BL    PRDCB99                 NO, QUIT
         CLI   DEBAMTYP,DEBAMSUB       JES DEB?
         BE    PRDCB99                 YES, QUIT
         LA    R0,IOBSTDRD             STANDARD SECTION
         ST    R0,WKCELL1              STORE FOR STRING
         MVI   MINLINES,6
         STRING '0  IOB AT LOCATION ',(WKCELL1+1,3,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         STRING '0   -08 ',56X,(IOBPREFX+08,4,X),1X,(IOBPREFX+12,4,X), X
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,064                  IOB SIZE
         LA    R1,IOBSTDRD             IOB ADDRESS
         O     R1,=X'80000000'         NO CTLCHR
         BAL   R14,DUMP32          <== PRINT IOB
         ICM   R1,B'0111',IOBECBPT+1   PICK UP DECB ADDRESS
        #S0C4  PRDCB99                 DECB addr may be bad
         LA    R0,IOBSTDRD             STANDARD SECTION
         C     R0,DECIOBPT-DECB(,R1)   DOES THIS LOOK RIGHT?
         BNE   PRDCB99                 NO, QUIT
         MVI   MINLINES,4
         STRING '0  DECB AT LOCATION ',(IOBECBPT+1,3,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,020                  DECB SIZE
         BAL   R14,DUMP32          <== PRINT DECB
         B     PRDCB99
         DROP  R2                      IOB
*
PRDCB31  MVI   MINLINES,5
         STRING '0  EXCP DCB AT LOCATION ',(WKCELL1+1,3,X),            X
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LA    R0,DCBLNGXE             LENGTH
         LA    R1,IHADCB               ADDRESS
         BAL   R14,DUMP32          <== PRINT IT
         B     PRDCB99
*
PRDCB41  MVI   MINLINES,6
         STRING '(GL,PL)',INTO=XMACRF
         CLI   DEBOPATB,DEBUPDAT       OPENED FOR UPDATE?
         BE    PRDCB41S                yes, jump
*
*        edit MACRF codes
*
         BAS   R1,PRDCB41B             BR AROUND TABLE
         DC    C'G',AL1(DCBMRGET)      40 GET
         DC    C'M',AL1(DCBMRMVG)      10 MOVE MODE
         DC    C'L',AL1(DCBMRLCG)      08 LOCATE MODE
         DC    C'T',AL1(DCBMRSBG)      04 SUBSTITUTE MODE
         DC    C'C',AL1(DCBMRCRL)      02 CNTRL
         DC    C'D',AL1(DCBMRDMG)      01 DATA MODE
         DC    2X'00'
PRDCB41B MVC   WKCELL3,DCBMACF1        move macrf byte (input/update)
         TM    DEBOPATB,DEBEXTND       OPENED FOR EXTEND/OUTPUT?
         BNO   PRDCB41C                no, jump
         MVC   WKCELL3,DCBMACF2        move macrf byte (output/extend)
         BAS   R1,PRDCB41C             BR AROUND TABLE
         DC    C'P',AL1(DCBMRPUT)      40 PUT
         DC    C'M',AL1(DCBMRMVP)      10 MOVE MODE
         DC    C'L',AL1(DCBMRLCP)      08 LOCATE MODE
         DC    C'T',AL1(DCBMRTMD)      04 SUBSTITUTE MODE
         DC    C'C',AL1(DCBMRCTL)      02 CNTRL
         DC    C'D',AL1(DCBMRDMD)      01 DATA MODE
         DC    2X'00'
PRDCB41C TM    WKCELL3,*-*             DCBMACF1/DCBMACF2
         MVC   XMACRF,BLANKS
*loop
PRDCB41D IC    R14,1(,R1)              MASK
         EX    R14,PRDCB41C
         BZ    PRDCB41E
         STRING (XMACRF,,T),((R1),1),INTO=XMACRF
PRDCB41E LA    R1,1+1(,R1)             NEXT ENTRY
         CLI   0(R1),C'A'              end of table?
         BNL   PRDCB41D                not yet, loop more
*endloop
PRDCB41S MVC   OPNBLKSI+2(2),DCBBLKSI  move BLKSI from DCB
         MVC   OPNLRECL+2(2),DCBLRECL  move LRECL from DCB
         CLI   DEBAMTYP,DEBAMSUB       JES DEB?
         BE    PRDCB41Z                YES, EXIT
         CLI   DEBLNGTH,16             DEB long enough?
         BL    PRDCB41Z                NO, EXIT
         SR    R1,R1                   CLEAR REGISTER
         SR    R2,R2                   CLEAR REGISTER
         IC    R1,DEBNMEXT             NUMBER OF EXTENTS
         IC    R2,DEBEXSCL             EXTENT SCALE
         SLL   R1,0(R2)                SIZE OF EXTENT
         LA    R2,DEBBASND(R1)         ADJ TO PROPER OFFSET
         USING DEBACSMD,R2             Access Method Extension
         LH    R14,DEBLRECL            Get DCBLRECL before OPEN
         LH    R15,DEBBLKSI            Get DCBBLKSI before OPEN
         DROP  R2                      DEB
         LTR   R14,R14                 was zero?
         BNZ   PRDCB41X                no, jump
         LH    R14,DCBLRECL            yes, use current DCB value
PRDCB41X ST    R14,OPNLRECL            save it for later
         LTR   R15,R15                 was zero?
         BNZ   PRDCB41Y                no, jump
         LH    R15,DCBBLKSI            yes, use current DCB value
PRDCB41Y ST    R15,OPNBLKSI            save it for later
*
PRDCB41Z STRING '0  QSAM',                                             X
               ' DCB AT LOCATION ',(WKCELL1+1,3,X),                    X
               6X,'MACRF=',(XMACRF,,T),                                X
               ',RECFM=',(XRECFM,,T),                                  X
               ',LRECL=',(OPNLRECL,F,L),                               X
               ',BLKSIZE=',(OPNBLKSI,F,L),                             X
               ',BUFNO=',(DCBBUFNO,FL1,L),                             X
               ',DSORG=',(XDSORG,,T),INTO=LINE121
         BAL   R14,SPACE1          <== print header
         LA    R0,DCBLNGQS             LENGTH
         LA    R1,IHADCB               ADDRESS
         BAL   R14,DUMP32          <== print DCB
*
*        Print DCBE, if present
*
         TM    DCBEODAD,DCBH0+DCBH1    Is DCBDCBE valid ?
         BNO   PRDCB42                 no, jump
         L     R1,DCBDCBE              A(DCBE)
         USING DCBE,R1
         OC    DCBE(DCBEMINL),DCBE     validate
         MVI   MINLINES,6
         STRING '0  DCBE AT LOCATION ',(DCBDCBE,,X),INTO=LINE121
         BAL   R14,SPACE1          <== print header
         LH    R0,DCBELEN              length of DCBE
         BAL   R14,DUMP32          <== print DCBE
*
*        PRINT CURRENT RECORD FOR A QSAM DCB
*
PRDCB42  CLI   OCE_CODE,C'O'           ABEND DURING OPEN?
         BNE   PRDCB42J                NO, JUMP
         CL    R6,SDWAGR02             WAS THIS FOR THIS DCB?
         BE    PRDCB99                 YES, QUIT
*
*        If it's a SAM-CI DCB with MACRF=PM, do not print the record
*        pointed to by DCBRECAD; the DFP V3 version of IGG019DJ (the
*        SAM-CI QSAM processor) does not move any data to the buffer.
*        The record should be printed from the JES2 unprotected
*        buffer in the PRACB routine.
*
PRDCB42J CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?
         BNE   PRDCB43                 no, jump
         TM    DEBOPATB,DEBEXTND       OPENED FOR EXTEND/OUTPUT?
         BNO   PRDCB43                 NO, JUMP
         TM    DCBMACRF+1,DCBMRPUT+DCBMRMVP  MACRF=PM?
         BNO   PRDCB43                 NO, JUMP
         CLI   SPLEVEL,2               CHECK MVS/SP LEVEL
         BH    PRDCB99                 QUIT (MODE=O,MACRF=PM,SPLEVEL=3)
*
PRDCB43  LM    R0,R1,DCBEOBAD          R0=EOBAD,R1=RECAD
         TM    DCBEODAD,DCBH0+DCBH1    Is DCBDCBE valid ?
         BO    PRDCB43C                yes, jump
         ICM   R0,B'1000',X00          zero first byte (DCBNCP)
         ICM   R1,B'1000',X00          zero first byte (DCBRECBT)
*
*        locate start of current buffer
*
PRDCB43C MVC   REASON,=C'01'           invalid value in DCBEOBAD
         CL    R0,REGION24             EOBAD VALID?
         BL    PRDCB90                 NO RECORD YET, QUIT
         CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?
         BE    PRDCB43J                yes, jump
         L     R2,DCBIOBA              current IOB
         ICM   R2,B'1000',X00          zero first byte
         USING IOBSTDRD-8,R2
         CL    R6,IOBDCBPT             does this IOB look right?
         BNE   PRDCB43F                no, jump
         MVC   WKCELL2,IOBCCW          move r/w CCW
         B     PRDCB43G
*
*        Process ICB pointed to by DCBIOBS (chained scheduling)
*
PRDCB43F MVC   REASON,=C'06'           invalid IOB/ICB
         TM    DCBCIND2,DCBCNCHS       Chained scheduling (i.e. tape) ?
         BZ    PRDCB90                 no, we're lost
         USING IOBCCW-32,R2            CCW is at ICB+32
         MVC   WKCELL2,IOBCCW          move r/w CCW
         DROP  R2                      IOB
*
*        Get buffer addr from R/W CCW (or IDAW)
*
PRDCB43G SLR   R14,R14
         ICM   R14,B'0111',WKCELL2+1   get buffer addr from CCW
         TM    WKCELL2+4,X'04'         IDA bit on?
         BZ    PRDCB43S                no, jump
         L     R14,0(,R14)             get 31-bit buffer address
         B     PRDCB43S
*
PRDCB43J LR    R14,R0                  PASS DCBEOBAD
         SH    R14,DCBBLKSI            SUBTRACT BUFFER LENGTH FROM EOB
         BNP   PRDCB90                 NO RECORD YET, QUIT
*
PRDCB43S ST    R14,BUFFER              BEGINNING OF CURR BUFFER
*
         TM    DCBRECFM,DCBRECU        U?
         BO    PRDCB60                 YES, JUMP
         TM    DCBRECFM,DCBRECV        V/VB?
         BO    PRDCB70                 YES, JUMP
         LH    R2,DCBLRECL             RECORD LENGTH IF FB
         TM    DCBRECFM,DCBRECF+DCBRECBR   FB?
         BO    PRDCB50                 YES, JUMP
         LH    R2,DCBBLKSI             RECORD LENGTH IF F
*F/FB
PRDCB50  TM    DEBOPATB,DEBEXTND       OPENED FOR EXTEND/OUTPUT?
         BNO   PRDCB80                 NO, JUMP
         SR    R1,R2                   GET ADDR OF CURRENT RECORD
         MVC   REASON,=C'02'           invalid value in DCBRECAD
         C     R1,BUFFER               TOO LOW?
         BL    PRDCB90                 YES, JUMP
*
*        LOCATE PREVIOUS RECORD (RECFM=F/FB)
*
         TM    DCBRECFM,DCBRECF+DCBRECBR   FB?
         BNO   PRDCB80                 NO, JUMP
         LR    R0,R1                   GET ADDR OF CURRENT RECORD
         SR    R0,R2                   GET ADDR OF PREVIOUS RECORD
         C     R0,BUFFER               PREV RCD IN CURR BUFFER?
         BL    PRDCB80                 NO, JUMP
         MVI   MINLINES,6
         STRING '0    PREVIOUS RECORD:',INTO=LINE121
         BAL   R14,SPACE1          <== PRINT HEADER
         LR    R1,R0                   PASS ADDRESS
         LR    R0,R2                   LENGTH
         BAL   R14,PDUMP           <== DUMP PREVIOUS RECORD
         AR    R1,R2                   GET ADDR OF CURRENT RECORD
         B     PRDCB80
*
*        LOCATE CURRENT RECORD (RECFM=U)
*
PRDCB60  LH    R2,DCBLRECL             RECORD LENGTH IF U
         C     R1,BUFFER               IS THIS THE START OF THE BUFFER?
         BE    PRDCB80                 YES, JUMP
         SLR   R1,R2                   NO, POINT TO START OF RECORD (U)
         B     PRDCB80
*
*        LOCATE CURRENT RECORD (RECFM=V/VB)
*
*          MACRF=GM       DCBRECAD=next
*          MACRF=GL       DCBRECAD=current
*          MACRF=(GL,PL)  DCBRECAD=current
*          MACRF=PM       DCBRECAD=next
*          MACRF=PL       DCBRECAD=current
*
PRDCB70  TM    DEBOPATB,DEBEXTND       OPENED FOR EXTEND/OUTPUT?
         BO    PRDCB71                 yes, jump
         LH    R15,0(,R14)             pick up block length from BDW
         ALR   R15,R14                 1st byte after current block
         MVC   REASON,=C'11'           BUFFER/BDW/EOBAD incompatible
         CLR   R15,R0                  same as DCBEOBAD?
         BNE   PRDCB90                 NO, QUIT
*
PRDCB71  CLI   XMACRF+1,C'L'           LOCATE mode?
         BE    PRDCB78                 YES, JUMP
*
*        DCBRECAD=next, scan current buffer to locate record
*
         LR    R0,R1                   first byte after current record
         LA    R1,4(,R14)              first record (skip BDW)
         SLR   R2,R2
*--loop
PRDCB73L ICM   R2,B'0011',0(R1)        length of current record (RDW)
         MVC   REASON,=C'12'           RDW<4
         CH    R2,=H'4'                is record at least 4 bytes?
         BL    PRDCB90                 no, quit
         MVC   REASON,=C'13'           RDW is not LLLL0000
         CL    R2,OPNLRECL             record longer than LRECL?
         BH    PRDCB90                 yes, quit
         MVC   REASON,=C'14'           RDW is not LLLL0000
         ICM   R2,B'1100',2(R1)        3rd-4th bytes of RDW
         BNZ   PRDCB90                 NO, QUIT
         ALR   R1,R2                   1st byte after record
         CLR   R1,R0                   is this the record I want?
         BL    PRDCB73L                not yet, keep on scannin'
*--endloop
         MVC   REASON,=C'15'           V/VB scan failed
         BH    PRDCB90                 too high, exit
         SLR   R1,R2                   point to record again
*
PRDCB78  LH    R2,0(,R1)               RECORD LENGTH IF V/VB
         CLM   R2,B'0011',DCBLRECL     GOOD RDW?
         BH    PRDCB90                 NO, QUIT
*
*        PRINT CURRENT RECORD (F/V/U)
*
PRDCB80  MVC   REASON,=C'00'           length=0
         LTR   R0,R2                   LENGTH=0?
         BZ    PRDCB90                 YES, JUMP
         MVI   MINLINES,6
         STRING '0    CURRENT RECORD:',INTO=LINE121
** STRING '0    CURRENT RECORD ',((R0),,X),1X,((R1),,X),1X,((R2),,X),  X
               INTO=LINE
         BAL   R14,SPACE1          <== Print line
         BAL   R14,PDUMP           <== DUMP IT
         ST    R6,CURR_REC             CURRENT RECORD HAS BEEN PRINTED
         B     PRDCB99
*
PRDCB90  STRING '0    CURRENT RECORD IS NOT AVAILABLE (',REASON,')',   X
               INTO=LINE121
*ORG PRDCB90
*        STM   R14,R15,WKCELL1
*        STRING '0    CURRENT RECORD IS NOT AVAILABLE (',REASON,')',   X
               2X,(BUFFER,,X),1X,(WKCELL1,4,X),1X,(WKCELL1+4,4,X),     X
               1X,((R0),,X),1X,((R1),,X),1X,((R2),,X),                 X
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
PRDCB99  END_PROC
*
*----------------------------------------------------------------------
*        PRINT ACB INFORMATION (VSAM, JES)
*----------------------------------------------------------------------
*
PRACB    BEGIN_PROC
         USING DEBPREFX,R5
         L     R6,$ACB                 pick up ACB address
         STRING '0  ACB AT LOCATION ',((R6),,X),'   MACRF=(',          X
               INTO=LINE121
         USING IFGACB,R6
*
*        display MACRF
*
         BAS   R1,PRACB11A             BR AROUND TABLE
         DC    C'KEY',AL1(ACBKEY)      80 00 00
         DC    C'ADR',AL1(ACBADR)      40 00 00
         DC    C'CNV',AL1(ACBCNV)      20 00 00
         DC    C'SEQ',AL1(ACBSEQ)      10 00 00
         DC    C'DIR',AL1(ACBDIR)      08 00 00
         DC    C'IN ',AL1(ACBIN)       04 00 00
         DC    C'OUT',AL1(ACBOUT)      02 00 00
         DC    C'UBF',AL1(ACBUBF)      01 00 00
PRACB11A TM    ACBMACR1,*-*
*loop
PRACB11B IC    R14,3(,R1)              MASK
         EX    R14,PRACB11A
         BZ    PRACB11C
         STRING (LINE,,T),((R1),3,T),',',INTO=LINE
PRACB11C LA    R1,3+1(,R1)             NEXT ENTRY
         CLI   0(R1),C'A'              end of table?
         BNL   PRACB11B                not yet, loop more
*endloop
         BAS   R1,PRACB12A             BR AROUND TABLE
         DC    C'BWO',AL1(ACBBWO)      00 20 00
         DC    C'SKP',AL1(ACBSKP)      00 10 00
         DC    C'RST',AL1(ACBRST) NRS  80 04 00
         DC    C'DSN',AL1(ACBDSN)      00 02 00
         DC    C'AIX',AL1(ACBAIX) NRM  00 01 00
PRACB12A TM    ACBMACR2,*-*
*loop
PRACB12B IC    R14,3(,R1)              MASK
         EX    R14,PRACB12A
         BZ    PRACB12C
         STRING (LINE,,T),((R1),3,T),',',INTO=LINE
PRACB12C LA    R1,3+1(,R1)             NEXT ENTRY
         CLI   0(R1),C'A'              end of table?
         BNL   PRACB12B                not yet, loop more
*endloop
         BAS   R1,PRACB13A             BR AROUND TABLE
         DC    C'NLW',AL1(ACBNLW)      00 00 80    macr3
         DC    C'LSR',AL1(ACBLSR) NSR  00 00 40
         DC    C'GSR',AL1(ACBGSR)      00 00 20
         DC    C'ICI',AL1(ACBICI)      00 00 10
         DC    C'DFR',AL1(ACBDFR) NDF  00 00 08
         DC    C'SIS',AL1(ACBSIS)      00 00 04
**       DC    C'A31',AL1(ACBA31)      00 00 01
PRACB13A TM    ACBMACR3,*-*
*loop
PRACB13B IC    R14,3(,R1)              MASK
         EX    R14,PRACB13A
         BZ    PRACB13C
         STRING (LINE,,T),((R1),3,T),',',INTO=LINE
PRACB13C LA    R1,3+1(,R1)             NEXT ENTRY
         CLI   0(R1),C'A'              end of table?
         BNL   PRACB13B                not yet, loop more
*endloop
         LA    R15,LINE-1(R15)         last comma
         MVI   0(R15),C')'             close sub-list
*
         MVI   $AMBL,FF                invalidate AMBL address
         MVI   $AMB_D,FF               invalidate DATA AMB address
         MVI   $AMB_I,FF               invalidate INDX AMB address
         MVI   $AMDSB_D,FF             invalidate DATA AMDSB address
         MVI   $AMDSB_I,FF             invalidate INDX AMDSB address
         MVI   $PLHDR,FF               invalidate PLH HEADER address
*
*        Locate/validate AMBL (VSAM data set only)
*
         L     R2,ACBAMBL              POINT TO AMBL
         USING AMBL,R2
         C     R2,REGION24             VALIDATE AMBL
         BL    PRACB18                 LOST, QUIT
        #S0C4  PRACB18
         CLC   AMBL(64),0              VALIDATE
         CLI   AMBLID,X'50'            am I lost?
         BNE   PRACB18                 yes, exit
         CL    R6,AMBLACB              AM I LOST?
         BNE   PRACB18                 yes, exit
         ST    R2,$AMBL                AMBL address OK
*
*        BUFNI/BUFND/STRNO
*
PRACB16  CLI   DEBAMTYP,DEBAMVSM       VSAM?
         BNE   PRACB18                 NO, JUMP
        #S0C4  PRACB18
PRACB16I ICM   R3,B'1111',AMBLIX       INDEX AMB
         BZ    PRACB16D                NO INDEX, JUMP
         USING AMB,R3
         CLI   AMBID,X'40'             am I lost?
         BNE   PRACB16D                YES, JUMP
         L     R1,AMBBUFC              INDEX BUFC HEADER
         CLI   0(R1),X'70'             am I lost?
         BNE   PRACB16D                yes, exit
         ST    R3,$AMB_I               INDEX AMB address OK
         MVC   $AMDSB_I,AMBDSB         INDEX AMDSB address OK
         STRING (LINE,,T),',BUFNI=',(BUFCBUFN-BUFC(R1),FL1,L),         X
               INTO=LINE
PRACB16D L     R3,AMBLDTA              DATA AMB
         C     R3,REGION24             VALIDATE AMB
         BL    PRACB16S                LOST, QUIT
         CLI   AMBID,X'40'             VALIDATE AMB
         BNE   PRACB16S                LOST, QUIT
         CLC   AMB(188),0              VALIDATE DATA AMB
         ST    R3,$AMB_D               DATA AMB address OK
         MVC   $AMDSB_D,AMBDSB         DATA AMDSB address OK
         L     R1,AMBBUFC              DATA BUFC HEADER
         CLI   0(R1),X'70'             validate BUFC
         BNE   PRACB16S                LOST, QUIT
         STRING (LINE,,T),',BUFND=',(BUFCBUFN-BUFC(R1),FL1,L),         X
               INTO=LINE
         TM    AMBFLG1,AMBCREAT        CREATE MODE?
         BZ    PRACB16S                NO, JUMP
         STRING (LINE,,T),',CREATE',INTO=LINE
PRACB16S L     R1,AMBPH                PICK UP ADDR OF PLH HEADER
         CLI   PLHID-IDAPLHDR(R1),X'30' VALIDATE
         BNE   PRACB18                 LOST, QUIT
         STRING (LINE,,T),',STRNO=',(PLHCNT-IDAPLHDR(R1),H,L),         X
               INTO=LINE
         ST    R1,$PLHDR               PLH HEADER addr OK
*
PRACB18  MVI   MINLINES,6
         BAL   R14,SPACE1          <== print ACB address & MACRF
         LH    R0,ACBLENG              ACB LENGTH
         LA    R1,IFGACB               ACB ADDRESS
         BAL   R14,DUMP32          <== PRINT ACB
*
         CLI   DEBAMTYP,DEBAMSUB       SUB-SYSTEM DATA SET?
         BE    PRACB70                 YES, JUMP
         CLI   DEBAMTYP,DEBAMVSM       VSAM?
         BNE   PRACB99                 NO, EXIT
         CL    R2,$AMBL                AMBL address OK ?
         BNE   PRACB99                 NO, EXIT
*
*        PRINT VSAM CONTROL BLOCKS
*
PRACB20  MVC   MSG60,BLANKS            optional attributes
         LA    R1,=C'DUMMY'
         TM    AMBLFLG1,AMBLDUMY       DD DUMMY?
         BO    PRACB20X                YES, JUMP
         LA    R1,=C'KSDS '
         TM    AMBLQ,AMBLKSDS          IS THIS A KSDS?
         BO    PRACB20X                YES, JUMP
         ICM   R3,B'1111',$AMB_D       DATA AMB
         BNP   PRACB26                 BAD, JUMP
         LA    R1,=C'LDS  '
         TM    AMBFLG0,AMBLDS          Is this an LDS?
         BO    PRACB20X                YES, JUMP
         L     R14,$AMDSB_D            A(AMDSB)
         LA    R1,=C'RRDS '
         TM    AMDATTR-AMDSB(R14),AMDRRDS Is this an RRDS?
         BO    PRACB20X                YES, JUMP
         LA    R1,=C'ESDS '
PRACB20X MVC   MSG60(5),0(R1)          DUMMY/KSDS/LDS/RRDS/ESDS
*
         TM    AMBLSHAR,AMBLWRIT       Update mode?
         BNO   PRACB22                 NO, JUMP
         STRING (MSG60,,T),',UPDATE',INTO=MSG60
*
PRACB22  EQU   *
*
PRACB26  MVI   MINLINES,6
         STRING '0  AMBL AT LOCATION ',(ACBAMBL,,X),6X,MSG60,          X
               INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         SLR   R0,R0
         IC    R0,AMBLLEN              AMBL LENGTH
         LA    R1,AMBL                 AMBL ADDRESS
         BAL   R14,DUMP32          <== PRINT AMBL
*
*        Print DATA AMB
*
         LA    R0,188                  AMB LENGTH
         ICM   R1,B'1111',$AMB_D       DATA AMB
         BNP   PRACB99                 BAD, QUIT
         MVI   MINLINES,9
         STRING '0  DATA AMB AT LOCATION ',((R1),,X),                  X
               '  DSNAME=',AMBDSNM,                                    X
               INTO=LINE121
         BAL   R14,SPACE1          <== PRINT HEADER
         BAL   R14,DUMP32          <== PRINT AMB
         DROP  R1,R2                   AMBL
*
         L     R2,AMBPH-AMB(,R1)       PICK UP ADDR OF PLH HEADER
         USING IDAPLHDR,R2
         MVI   MINLINES,4
         STRING '0  PLH HEADER AT LOCATION ',((R2),,X),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         C     R2,REGION24             VALIDATE
         BL    PRACB99                 LOST, QUIT
        #S0C4  PRACB99
         CLC   IDAPLHDR(16),0          VALIDATE
         LA    R0,016                  PLHDR LENGTH
         LA    R1,IDAPLHDR             PLH Header
         BAL   R14,DUMP32          <== PRINT PLHDR
         CLI   PLHID,X'30'             VALIDATE
         BNE   PRACB99                 LOST, QUIT
         LA    R3,IDAPLH               POINT PAST PLH HEADER
         USING IDAPLH,R3
         MVI   STRNO,0                 PLH/RPL sequence number
*
*        Print PLH (one for each string)
*loop
PRACB40  C     R3,REGION24             VALIDATE
         BL    PRACB99                 LOST, QUIT
         IC    R14,STRNO               PLH sequence number
         LA    R14,1(,R14)             PLH sequence number
         STC   R14,STRNO               PLH sequence number
        #S0C4  PRACB99
         CLC   0(210,R3),0             VALIDATE
         CLC   =C'PLH',PLHIDENT        VALIDATE
         BNE   PRACB99                 LOST, QUIT
         STM   R2,R3,SAVPLHPT          save A(IDAPLHDR,IDAPLH)
         CLI   IDAPLH,FF               VALIDATE
         BNE   PRACB69                 PLH not in use, try next one
*
*        Check if the PLH entry points to my ACB;
*        If MACRF=LSR/GSR, the PLH entry could point to another
*        ACB that shares the same buffer pool.
*
         C     R6,PLHACB               VALIDATE
         BE    PRACB45                 OK, jump
         LA    R0,IFGACB+1             VALIDATE
         C     R0,PLHACB               VALIDATE
         BNE   PRACB69                 not for this ACB, ignore it
*
PRACB45  MVI   MINLINES,10
         STRING '0  PLH AT LOCATION ',((R3),,X),INTO=LINE121
         CLC   PLHCNT,=H'1'            STRNO=1?
         BE    PRACB45P                yes, do not count PLHs
         STRING '0  PLH',(STRNO,FL1,L),' AT LOCATION ',((R3),,X),      X
               INTO=LINE121
PRACB45P BAL   R14,SPACE1          <== Print line
*
PRACB46  LA    R0,210                  PLH LENGTH
         LA    R1,IDAPLH               PASS PLH ADDRESS
         BAL   R14,DUMP32          <== PRINT PLH
*
*        PRINT RPL
*
PRACB50  L     R4,PLHCRPL              PICK UP RPL ADDRESS
         USING IFGRPL,R4
         C     R4,REGION24             VALIDATE
         BL    PRACB99                 LOST, QUIT
        #S0C4  PRACB99
         CLC   IFGRPL(76),0            VALIDATE RPL
*
         BAL   R1,PRACB51R             BRANCH AROUND TABLE
         DC    C'GET  ',AL1(RPLGET)    REQUEST
         DC    C'PUT  ',AL1(RPLPUT)    REQUEST
         DC    C'POINT',AL1(RPLPOINT)  REQUEST
         DC    C'ERASE',AL1(RPLERASE)  REQUEST
         DC    C'*REQ ',AL1(255)       unknown request
*--loop
PRACB51R CLC   RPLREQ,5(R1)            compare RPL request code
         BE    PRACB51S                equal, exit loop
         LA    R1,5+1(,R1)             next entry
         CLI   5(R1),255               end of table?
         BNE   PRACB51R                no, try next entry
*--endloop
PRACB51S MVI   MINLINES,6
         STRING '0  RPL AT LOCATION ',((R4),,X),3X,                    X
               ((R1),5,T),',OPTCD=(',INTO=LINE121
         CLC   PLHCNT,=H'1'            STRNO=1?
         BE    PRACB51J                yes, do not count PLHs
         STRING '0  RPL',(STRNO,FL1,L),' AT LOCATION ',((R4),,X),3X,   X
               ((R1),5,T),',OPTCD=(',INTO=LINE121
*
*        display OPTCD
*
PRACB51J BAS   R1,PRACB51A             BR AROUND TABLE
         DC    C'LOC',AL1(RPLLOC)      80 00
         DC    C'DIR',AL1(RPLDIR)      40 00
         DC    C'SEQ',AL1(RPLSEQ)      20 00
         DC    C'SKP',AL1(RPLSKP)      10 00
         DC    C'KGE',AL1(RPLKGE)      04 00
         DC    C'GEN',AL1(RPLGEN)      02 00
PRACB51A TM    RPLOPT1,*-*
*loop
PRACB51B IC    R14,3(,R1)              MASK
         EX    R14,PRACB51A
         BZ    PRACB51C
         STRING (LINE,,T),((R1),3,T),',',INTO=LINE
PRACB51C LA    R1,3+1(,R1)             NEXT ENTRY
         CLI   0(R1),C'A'              end of table?
         BNL   PRACB51B                not yet, loop more
*endloop
         BAS   R1,PRACB52A             BR AROUND TABLE
         DC    C'KEY',AL1(RPLKEY)      00 80
         DC    C'ADR',AL1(RPLADR)      00 40
         DC    C'CNV',AL1(RPLCNV)      00 20
         DC    C'BWD',AL1(RPLBWD)      00 10
         DC    C'UPD',AL1(RPLUPD)      00 02
         DC    C'NSP',AL1(RPLNSP)      00 01
PRACB52A TM    RPLOPT2,*-*
*loop
PRACB52B IC    R14,3(,R1)              MASK
         EX    R14,PRACB52A
         BZ    PRACB52C
         STRING (LINE,,T),((R1),3,T),',',INTO=LINE
PRACB52C LA    R1,3+1(,R1)             NEXT ENTRY
         CLI   0(R1),C'A'              end of table?
         BNL   PRACB52B                not yet, loop more
*endloop
         LA    R15,LINE-1(R15)         last comma
         MVI   0(R15),C')'             close sub-list
         OC    RPLFDBK,RPLFDBK         any error?
         BZ    PRACB53                 no, jump
         STRING (LINE,,T),',FDBK=',(RPLFDBK,,X),INTO=LINE
PRACB53  BAL   R14,SPACE1          <== print RPL header
*
         SLR   R0,R0
         IC    R0,RPLLEN               RPL LENGTH
         LA    R1,IFGRPL               RPL address
         BAL   R14,DUMP32          <== PRINT RPL
*
         CL    R6,RPLDACB              VALIDATE
         BNE   PRACB99                 LOST, QUIT
         L     R1,RPLARG               SEARCH ARGUMENT
         C     R1,REGION24             VALIDATE
         BL    PRACB60                 NONE FOUND, JUMP
        #S0C4  PRACB60
         CLI   0(R1),0                 VALIDATE SEARCH ARGUMENT
         L     R14,$AMDSB_D            DATA AMDSB
         LH    R0,AMDKEYLN-AMDSB(,R14) KEY LENGTH
         MVI   MINLINES,5
         STRING '0    SEARCH ARGUMENT:',INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LTR   R0,R0                   IS THIS A KSDS?
         BNZ   PRACB59                 YES, JUMP
         LA    R0,004                  NO, ARG IS AN RBA
PRACB59  BAL   R14,PDUMP           <== PRINT KEY
         DROP  R4                      RPL
*
*        Print current record (from PLH)
*
PRACB60  MVI   MINLINES,6
         LM    R2,R3,SAVPLHPT          restore A(PLHDR,PLH)
         ICM   R0,B'1111',PLHLRECL     PICK UP RECORD LENGTH
         BNP   PRACB68                 zero, quit
         L     R1,PLHRECP              PICK UP RECORD ADDRESS
         C     R1,REGION24             VALIDATE
         BL    PRACB68                 LOST, QUIT
        #S0C4  PRACB68
         CLI   0(R1),0                 VALIDATE
         STRING '0    CURRENT RECORD:',INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         BAL   R14,PDUMP           <== PRINT RECORD
         B     PRACB69
PRACB68  STRING '0    CURRENT RECORD IS NOT AVAILABLE',INTO=LINE121
 STRING (LINE121,,T),' R0=',((R0),,X),' R1=',((R1),,X),INTO=LINE121,   X
               ' R2=',((R2),,X),' R3=',((R3),,X),' R4=',((R4),,X)
         BAL   R14,SPACE1          <== Print line
*
PRACB69  LM    R2,R3,SAVPLHPT          restore A(PLHDR,PLH)
*ORG PRACB69
         ICM   R3,B'1111',PLHCHAIN     do we have another PLH?
         BNZ   PRACB40                 yes, process it
*endloop
         DROP  R3                      IDAPLH
         B     PRACB99
*
*        PRINT DCB IF THIS IS A JES ACB
*
PRACB70  SLR   R1,R1
         ICM   R1,B'0111',DEBRRQ+1     DCB ADDRESS (JES)
         BZ    PRACB71                 NO DCB, JUMP
        #S0C4  PRACB71
         CLC   ACBDEB,ACBDEB-IFGACB(R1) DOES THIS LOOK LIKE A DCB?
         BNE   PRACB71                 NO, JUMP
         CLC   ACBTIOT,ACBTIOT-IFGACB(R1) DOES THIS LOOK LIKE A DCB?
         BNE   PRACB71                 NO, JUMP
         LR    R6,R1                   PASS DCB ADDRESS
         BAL   R14,PRDCB           <== PRINT DCB ALSO
**       L     R7,DCBCICB              CICB
**       USING CICB,R7
         CL    R6,CURR_REC             CURRENT RECORD PRINTED ALREADY?
         BE    PRACB99                 YES, QUIT
         ICM   R6,B'0111',DEBDCBAD+1   RELOAD ACB ADDRESS (JES)
*
*        Retrieve current record: DEB->SDB->UBF->BFD
*
PRACB71 #S0C4  PRACB99
         TM    DEBOPATB,DEBEXTND       OPEN FOR EXTEND/OUTPUT?
         BNO   PRACB99                 NO, QUIT
         L     R7,DEBIRBAD             SDB (SUB-SYSTEM DATA SET BLOCK)
         ICM   R7,B'1000',X00          CLEAN UP ADDRESS
         USING SDB,R7
         CLC   =C'SDB ',SDBID          SDBID
         BNE   PRACB99                 I'M LOST, QUIT
        #S0C4  PRACB72N
*        Offsets to SDBDEB,SDBUBF,BFDDATA,SDBLOC
         BAL   R2,PRACB72              br around table
         DC    X'007C,00B4,0036,0018'  XA 2.2
         DC    X'0084,00E4,0084,002C'  ESA 420
         DC    X'008C,00EC,0088,002C'  OS/390 1.3
*loop
PRACB72  LH    R1,0(,R2)               SDBDEB-SDB
         L     R1,SDB(R1)              SDBDEB
         CLM   R1,B'0111',ACBDEB       SDBDEB
         BNE   PRACB72N                NOT MY JES2, JUMP
         LH    R1,2(,R2)               SDBUBF-SDB
         L     R4,SDB(R1)              SDBUBF (BUFFER ADDRESS)
         USING UBF,R4
         CLC   =C'UBF ',UBFID          BFDID
         BE    PRACB81                 This is my JES2, jump
PRACB72N LA    R2,2+2+2+2(,R2)         next table entry
         CLC   PRACB72,0(R2)           SDBDEB-SDB
         BNE   PRACB72                 SCAN BUFFER
*endloop
         B     PRACB99                 I'M LOST, QUIT
*
*        Scan JES2 unprotected buffer to retrieve the current record
*
PRACB81  LH    R1,4(,R2)               BFDDATA-UBF
         LA    R0,UBF(R1)              BFDDATA
         LH    R1,6(,R2)               SDBLOC-UBF
         L     R3,UBF(R1)              SDBLOC (CURR POS IN BUFFER)
         SLR   R1,R1
         CR    R3,R0                   ANY RECORD YET?
         BE    PRACB98                 NO, QUIT
*LOOP
PRACB81C LR    R2,R0
         USING LRC,R2
         IC    R1,LRCTLENG             LENGTH OF TEXT
         TM    LRCFLAG1,LRC1CCTL       CTLCHR PRESENT?
         BNO   PRACB81N                NO, JUMP
         LA    R1,1(,R1)               YES, ADD 1 TO LENGTH
PRACB81N LA    R0,LRCTEXT(R1)          POINT PAST RECORD
         CLR   R0,R3                   WAS THIS THE LAST RECORD?
         BL    PRACB81C                NO, LOOP FURTHER
*ENDLOOP
         MVI   MINLINES,6
         STRING '0    CURRENT RECORD:',INTO=LINE121
         BAL   R14,SPACE1          <== Print line
         LR    R0,R1                   PASS LENGTH
         LA    R1,LRCTEXT              PASS ADDRESS
         BAL   R14,PDUMP           <== DUMP CURRENT RECORD
         B     PRACB99                 NO, QUIT
*
PRACB98  STRING '0    NO RECORD WRITTEN YET.',INTO=LINE121
         BAL   R14,SPACE1          <== Print line
*
PRACB99  END_PROC
         DROP  R4,R5,R6,R7             UBF, DEB, ACB, SDB
*
*----------------------------------------------------------------------
*        SCAN JPAQ/LPAD TO FIND CALLER'S CDE
*----------------------------------------------------------------------
*
CSVQRY00 BEGIN_PROC
         STM   R6,R7,TENWORDS          SAVE R6, R7
         N     R1,MASKADDR             CLEAN-UP ADDRESS
         L     R5,PSATOLD-PSA          MY TCB
         L     R5,TCBJSTCB-TCB(,R5)    JOB STEP TCB
         ICM   R5,B'1111',TCBJPQ-TCB(R5)  FIRST CDE ON JPA QUEUE
         BZ    CSVQRY20                EMPTY QUEUE, SKIP SEARCH
         USING CDENTRY,R5
*LOOP
CSVQRY11 TM    CDATTR2,CDXLE           IS THERE AN EXTENT LIST?
         BNO   CSVQRY12                NO, JUMP
         TM    CDATTR,CDNIC            this module being loaded?
         BO    CSVQRY12                yes, jump
         L     R7,CDXLMJP              EXTENT LIST
         USING XTLST,R7
         C     R1,XTLMSBAD             WITHIN BOUNDARIES?
         BL    CSVQRY12                NO, IGNORE
         L     R15,XTLMSBLA            LENGTH OF LOAD MOD
         LA    R15,0(,R15)             CLEAR HI-ORDER BIT
         A     R15,XTLMSBAD            ADD LOAD POINT ADDRESS
         CR    R1,R15                  WITHIN BOUNDARIES?
         BL    CSVQRY75                YES, PROCESS
CSVQRY12 ICM   R5,B'1111',CDCHAIN      NEXT CDE IN QUEUE
         BNZ   CSVQRY11                GOOD ADDR, PROCESS
*ENDLOOP
*
*        SCAN ACTIVE LPA QUEUE (MLPA/FLPA)
*
CSVQRY20 L     R5,CVTPTR
         L     R5,CVTQLPAQ-CVTMAP(,R5) ACTIVE LPA QUEUE
         ICM   R5,B'1111',0(R5)        FIRST CDE ON QUEUE
         BZ    CSVQRY60                EMPTY QUEUE, SKIP SEARCH
         USING CDENTRY,R5
*LOOP
CSVQRY21 TM    CDATTR2,CDXLE           IS THERE AN EXTENT LIST?
         BNO   CSVQRY22                NO, JUMP
         L     R7,CDXLMJP              EXTENT LIST
         USING XTLST,R7
         C     R1,XTLMSBAD             WITHIN BOUNDARIES?
         BL    CSVQRY22                NO, IGNORE
         L     R15,XTLMSBLA            LENGTH OF LOAD MOD
         LA    R15,0(,R15)             CLEAR HI-ORDER BIT
         A     R15,XTLMSBAD            ADD LOAD POINT ADDRESS
         CR    R1,R15                  WITHIN BOUNDARIES?
         BL    CSVQRY75                YES, PROCESS
CSVQRY22 ICM   R5,B'1111',CDCHAIN      NEXT CDE IN QUEUE
         BNZ   CSVQRY21                GOOD ADDR, PROCESS
*ENDLOOP
*
*        SCAN LPA DIRECTORY IF MODULE NOT FOUND IN JPAQ
*
CSVQRY60 L     R6,CVTPTR
         L     R6,CVTLPDIA-CVTMAP(,R6)
         USING LPDE,R6
*LOOP
CSVQRY61 TM    LPDEATTR,LPDEMIN        MINOR LPDE?
         BO    CSVQRY62                YES, JUMP
         LM    R15,R0,LPDEXTLN         LENGTH/LOAD ADDR
         CR    R0,R1
         BH    CSVQRY62                OUTSIDE BOUNDARIES, JUMP
         AR    R0,R15
         CR    R0,R1
         BH    CSVQRY71                MODULE FOUND, JUMP
CSVQRY62 LA    R6,LPDEXTAD+4           BUMP LPDE ADDR
         CLI   LPDENAME,FF             END OF LPA DIRECTORY?
         BNE   CSVQRY61                NO, LOOP FURTHER
*ENDLOOP
         B     CSVQRY81                not found in LPA
*
*        found in LPAD
*
CSVQRY71 LR    R5,R6                   CDE=LPDE
         S     R1,LPDEXTAD             GET OFFSET
         MVC   EPNAME,LPDENAME         PASS EP NAME
         B     CSVQRY85
*
*        found in JPAQ
*
CSVQRY75 S     R1,XTLMSBAD             GET OFFSET
         MVC   EPNAME,CDNAME           PASS EP NAME
         B     CSVQRY85
         DROP  R5,R6,R7                CDE, LPDE, XTLST
*
*        look for a nucleus module
*
CSVQRY81 LR    R5,R1                   save address
         LR    R0,R1                   pass address
         NUCLKUP BYADDR,ADDR=(R0),NAME=EPNAME
         LTR   R15,R15                 addr found in nucleus?
         BNZ   CSVQRY95                no, quit
         LR    R1,R5                   restore address
         SLR   R1,R0                   GET OFFSET in R1
*
CSVQRY85 ST    R1,TENWORDS+12          STORE OFFSET
         STRING '+X''',(TENWORDS+14,2,X),'''',INTO=OFFSET
         CLI   TENWORDS+13,00
         BE    CSVQRY88                OFFSET LT 64K, JUMP
         STRING '+X''',(TENWORDS+13,3,X),'''',INTO=OFFSET
CSVQRY88 STRING (EPNAME,,L),OFFSET,INTO=MSG20
         B     CSVQRY99                QUIT
*
*        not found anywhere
*
CSVQRY95 SR    R5,R5
         MVC   MSG20,BLANKS            NO PGM FOUND
         MVC   EPNAME,=C'*UNKNOWN'     NO PGM FOUND
*
CSVQRY99 LM    R6,R7,TENWORDS          RESTORE R6, R7
         END_PROC
*
*----------------------------------------------------------------------
*        Get address of a CDEX
*----------------------------------------------------------------------
*
         PUSH  USING
CDXSEARCH BEGIN_PROC SAVE=NO
         DROP
         LR    R0,R1                   CDE ADDRESS
         STM   R14,R12,12(R13)         SAVE REGISTERS
         BALR  R3,0
         USING *,R3
         USING CDENTRY,R1
         TM    CDATTRB,CDCDEX          do we have an extension?
         BZ    CDXS90                  no, exit
         L     R9,PSATOLD-PSA          My TCB
         USING TCB,R9
         L     R9,TCBJSTCB             Job-step TCB
         L     R5,TCBSTCB              Secondary TCB
         USING STCB,R5
         ICM   R5,B'1111',STCBCDXH     CDE Extension Hash table
         BZ    CDXS90                  no, exit
         USING CDXH,R5
         SLR   R6,R6
         L     R7,CDNAME+0             HASH module name
         X     R7,CDNAME+4             HASH module name
         D     R6,CDXHCNT              HASH module name
         SLL   R6,3                    HASH module name
         L     R4,CDXHFRST(R6)         point to first CDX1
         USING CDX1,R4
*LOOP
CDXS12   CL    R0,CDXCDE@              CDENTRY
         BE    CDXS98                  FOUND, EXIT
         CL    R4,CDXHLAST(R6)         END OF CHAIN?
         L     R4,CDX1NEXT             NEXT HOMONYM
         BNE   CDXS12                  NO, TRY IT TOO
*ENDLOOP
CDXS90   LA    R15,4                   RC=04 NOT FOUND
         SLR   R1,R1
         B     CDXS99                  EXIT
*
CDXS98   SLR   R15,R15                 RC=00
         LR    R1,R4                   A(CDX1)
*
CDXS99   LM    R2,R12,28(R13)          RESTORE REGISTERS
         BR    R14
         POP   USING
*
*----------------------------------------------------------------------
*        PRINT OBJECT INSTRUCTION IF X'44' OPCODE
*----------------------------------------------------------------------
*
EXECUTE  BEGIN_PROC
         CLI   SDWAILC1,4              ILC=4?
         BNE   EXEC999                 NO, QUIT
        #S0C4  EXEC999
         CLI   0(R6),X'44'             IS THIS AN EXECUTE?
         BNE   EXEC999                 NO, QUIT
*
         ICM   R0,B'0001',1(R6)        R1,RX
         LA    R2,X'000F'              MASK FOR NR
         NR    R2,R0                   R2=(RX)
         BZ    EXEC12                  NO RX, JUMP
         AR    R2,R2                   R*4
         AR    R2,R2                   R*4
         L     R2,SDWAGRSV(R2)         POINT TO RX SLOT
*
EXEC12   SR    R14,R14
         ICM   R14,B'0011',2(R6)       D2(B2)
         LA    R15,X'0FFF'             MASK FOR "NR"
         NR    R15,R14                 R15=D2
         SRL   R14,12                  R14=(B2)
         AR    R14,R14                 R14*2
         BZ    EXEC30                  B2=R0, JUMP
         AR    R14,R14                 R14*4
         AL    R2,SDWAGRSV(R14)        ADD VALUE(B2)
*
EXEC30   LA    R6,0(R15,R2)            ADD D2, CLEAN UP
         N     R6,MASKADDR             CLEAN-UP ADDRESS
         BAL   R14,PRINTI          <== PRINT INSTRUCTION (USES R6)
         STRING '   EXECUTED INSTRUCTION AT LOCATION ',((R6),,X),      X
               ' IS ',(MSG20,(R1)),INTO=LINE121
         BAL   R14,SPACE1          <== Print line
EXEC999  END_PROC
*
*----------------------------------------------------------------------
*        PRINT INSTRUCTION
*----------------------------------------------------------------------
*
PRINTI   BEGIN_PROC
         STRING '**** **** ****',INTO=MSG20 INIT OUTPUT AREA
         LA    R1,014                  MAX LENGTH
        #S0C4  PRINTI9
         MVC   WKCELL1(2),0(R6)        1ST HALFWORD
         UNPK  MSG20+0(5),WKCELL1+0(3) CONVERT TO HEX
         TR    MSG20+0(4),TABHEX-240   CONVERT TO HEX
         LA    R1,004                  4 BYTES
         CLI   0(R6),X'40'             TEST INSTRUCTION LENGTH
         BL    PRINTI9                 OK, JUMP
         MVC   WKCELL1(4),0(R6)        2 HALFWORDS
         MVI   MSG20+4,C' '            CLEAN UP
         UNPK  MSG20+5(5),WKCELL1+2(3) CONVERT TO HEX
         TR    MSG20+5(4),TABHEX-240   CONVERT TO HEX
         LA    R1,009                  9 BYTES
         CLI   0(R6),X'C0'             TEST INSTRUCTION LENGTH
         BL    PRINTI9                 OK, JUMP
         MVC   WKCELL1(6),0(R6)        6 HALFWORDS
         MVI   MSG20+9,C' '            CLEAN UP
         UNPK  MSG20+10(5),WKCELL1+4(3) CONVERT TO HEX
         TR    MSG20+10(4),TABHEX-240  CONVERT TO HEX
         MVI   MSG20+14,C' '           CLEAN UP
         LA    R1,014                  55 BYTES
PRINTI9 #S0C4  RESET
         END_PROC
*
*----------------------------------------------------------------------
*
*        PDUMP ROUTINE    R0=LENGTH,R1=ADDRESS
*
*+0000 00036800  C1C2C3C4 812653D8  00000000 00000000  *ABCDA  Q      *
*+0010 00036810-0003685F same as above (X'0050' bytes)
*+0060 00036860  00FD3BF0 00000000  078D2000 00C941A2  *   0          *
*----------------------------------------------------------------------
*
PDUMP    BEGIN_PROC
        #S0C4  PDUMP99,PUSH
         STM   R0,R3,TENWORDS          KEEP LENGTH AND ADDRESS
         LTR   R0,R0                   length=0?
         BNP   PDUMP99                 yes, quit
         MVI   LINE121,C'0'            CTLCHR
         L     R3,TENWORDS             LENGTH
         AL    R3,TENWORDS+4           LIMIT
         BCTR  R3,0                    BXLE LIMIT
*LOOP
PDUMP4   LR    R0,R1                   GET ADDRESS
         SL    R0,TENWORDS+4           MAKE OFFSET
         STM   R0,R1,TENWORDS+12       OFFSET, ADDRESS
         L     R2,TENWORDS             LENGTH
         AL    R2,TENWORDS+4           1ST BYTE AFTER AREA
         SR    R2,R1                   # OF REMAINING BYTES
         BNP   PDUMP99                 FINISHED, QUIT
*
         MVC   MSG20,BLANKS            CLEAR WORK AREA
         CH    R2,=H'16'
         BL    *+8
         LH    R2,=H'16'
         LR    R14,R2                  PASS LENGTH FOR MVC
         BCTR  R14,0                   FOR EX
**      #S0C4  PDUMP99
         EX    R14,*+4                 MOVE FIELD
         MVC   MSG20(*-*),0(R1)        MOVE FIELD
**      #S0C4  RESET
         TR    MSG20,TRTPRINT
*
         LR    R0,R2                   PASS LENGTH
         CH    R0,=H'12'
         BH    PDUMP16                 SNAP 16 BYTES
         CH    R0,=H'08'
         BH    PDUMP12                 SNAP 12 BYTES
         CH    R0,=H'04'
         BH    PDUMP08                 SNAP  8 BYTES
PDUMP04  STRING ((R1),(R0),X),INTO=(MSG60,36)
         B     PDUMP33
PDUMP08  SH    R0,=H'04'
         STRING ((R1),4,X),1X,(4(R1),(R0),X),INTO=(MSG60,36)
         B     PDUMP33
PDUMP12  SH    R0,=H'08'
         STRING ((R1),4,X),1X,(4(R1),4,X),2X,(8(R1),(R0),X),           X
               INTO=(MSG60,36)
         B     PDUMP33
PDUMP16  SH    R0,=H'12'
         STRING (0(R1),4,X),1X,(4(R1),4,X),2X,                         X
               (8(R1),4,X),1X,(12(R1),(R0),X),INTO=(MSG60,36)
PDUMP33  STRING '  +',(TENWORDS+12+2,2,X),1X,(TENWORDS+12+4,4,X),3X,   X
               (MSG60,36),'   *',(MSG20,16),'*',                       X
               INTO=LINE
         BAL   R14,SPACE1L         <== print with lower-case
*
*        do not print lines with identical contents
*
         CH    R2,=H'16'               increment
         BNE   PDUMP39                 no, jump
         LA    R14,48(,R1)             48 bytes beyond current addr
         CLR   R14,R3                  more than 48 bytes left?
         BH    PDUMP39                 no, jump
         CLC   16(32,R1),0(R1)         3 identical lines?
         BNE   PDUMP39                 no, jump
         LA    R0,16(,R1)              start of -SAME- area
*--loop
PDUMP37L CLC   16(16,R1),0(R1)         same contents?
         BNE   PDUMP38                 yes, exit
         ALR   R1,R2                   next line
         LA    R14,32(,R1)             32 bytes beyond current addr
         CLR   R14,R3                  more than 32 bytes left?
         BNH   PDUMP37L
*--endloop
PDUMP38  LR    R14,R0                  first -SAME- line
         SL    R14,TENWORDS+4          MAKE OFFSET
         LR    R15,R1                  last -SAME line
         ALR   R15,R2                  first non-SAME- line
         SLR   R15,R0                  size of -SAME- area
         STM   R14,R0,TENWORDS+12      offset, size, start
         LA    R0,15(,R1)              last -SAME- byte
         STRING '  +',(TENWORDS+12+2,2,X),1X,                          X
               (TENWORDS+20,4,X),'-',((R0),,X),                        X
               ' (X''',(TENWORDS+18,2,X),''' BYTES) SAME AS ABOVE',    X
               INTO=LINE
         BAL   R14,SPACE1          <== Print line
PDUMP39  BXLE  R1,R2,PDUMP4
*ENDLOOP
PDUMP99  LM    R0,R3,TENWORDS          LENGTH/START ADDRESS
        #S0C4  POP
         END_PROC
*
*----------------------------------------------------------------------
*        DUMP32 ROUTINE    R0=LENGTH,R1=ADDRESS
*----------------------------------------------------------------------
*
DUMP32   BEGIN_PROC
         LTR   R1,R1                   HI-ORDER BIT ON?
         LA    R1,0(,R1)               CLEAN UP HI-BIT
         STM   R0,R2,TENWORDS          KEEP LENGTH AND ADDRESS
         BM    DUMP32A                 YES, NO DOUBLE SPACE
         MVI   LINE121,C'0'            CTLCHR
*LOOP
DUMP32A  LR    R0,R1                   GET ADDRESS
         SL    R0,TENWORDS+4           MAKE OFFSET
         STM   R0,R1,TENWORDS+12       OFFSET, ADDRESS
         L     R0,TENWORDS             LENGTH (R0)
         AL    R0,TENWORDS+4           1ST BYTE AFTER AREA (add R1)
         SR    R0,R1                   # OF REMAINING BYTES
         BNP   DUMP32Z                 FINISHED, QUIT
         STRING '   +',(TENWORDS+12+3,1,X),INTO=LINE
         OC    TENWORDS(3),TENWORDS    offset > FF ?
         BZ    DUMP32L                 no, jump
         STRING '  +',(TENWORDS+12+2,2,X),INTO=LINE
DUMP32L  LA    R2,LINE+8               FIRST WORD
         BAL   R14,DUMP32X             00-03
         BAL   R14,DUMP32X             04-07
         BAL   R14,DUMP32X             08-11
         BAL   R14,DUMP32X             12-15
         LA    R2,1(,R2)               WIDE MARGIN IN THE MIDDLE
         BAL   R14,DUMP32X             16-19
         BAL   R14,DUMP32X             20-23
         BAL   R14,DUMP32X             24-27
         BAL   R14,DUMP32X             28-31
         BAL   R14,SPACE1          <== Print line
         LTR   R0,R0                   # OF REMAINING BYTES
         BP    DUMP32A                 PRINT NEXT 32 BYTES
*ENDLOOP
DUMP32Z  LM    R0,R2,TENWORDS          LENGTH/START ADDRESS
         END_PROC
*
DUMP32X  LTR   R0,R0                   # OF REMAINING BYTES
         BNPR  R14                     FINISHED, QUIT
         MVC   0(4,R2),0(R1)           PREVENT S0C4 IF R1=.....FFC
         UNPK  0(9,R2),0(5,R2)         TRANSLATE TO HEX
         TR    0(8,R2),TABHEX-240      TRANSLATE TO HEX
         SH    R0,=H'4'                DECREMENT LENGTH
         LA    R1,4(,R1)               PTR IN INPUT AREA
         MVI   8(R2),C' '
         LA    R2,9(,R2)               PTR IN OUTPUT LINE
         BR    R14
TABHEX   DC    C'0123456789ABCDEF'
*
*----------------------------------------------------------------------
*        PRINT ROUTINE (COPIED TO DYNAM24)
*----------------------------------------------------------------------
*
SPACE2   ST    R14,SPACE2RE            save R14
         BAL   R14,SPACE1          <== print current line
         L     R14,SPACE2RE            restore R14
         B     SPACE1L                 print blank line
*        print blank line
BLANK1   MVC   LINE121,BLANKS          BLANK LINE
         B     SPACE1L                 print blank line
*        convert to caps
SPACE1   TR    LINE,TRTPRINT           get rid of non-printable chars
         OC    LINE,BLANKS             make it all caps
*
SPACE1L  BALR  R15,0
         SAVE  (14,2),,SPACE1
         CLC   MINLINES,RLINES         ENOUGH LINES LEFT?
         BH    SPACE1D                 NO, JUMP
         LA    R0,3                    COUNT LINES
         CLI   LINE121,C'-'            COUNT LINES
         BE    SPACE1B                 COUNT LINES
         LA    R0,2                    COUNT LINES
         CLI   LINE121,C'0'            COUNT LINES
         BE    SPACE1B                 COUNT LINES
         LA    R0,1                    COUNT LINES
SPACE1B  SR    R1,R1
         ICM   R1,1,RLINES             ANY LINES LEFT?
         BZ    SPACE1D                 NO, JUMP
         SR    R1,R0                   DECREMENT LINE COUNT
         BNM   SPACE1K                 NOT END-OF-PAGE YET, JUMP
SPACE1D  MVI   LINE121,C'1'            NEW PAGE
         LA    R1,060-1                RESET LINE COUNTER
         CLC   LINE,BLANKS             BLANK LINE?
         BNE   SPACE1K                 NO, JUMP
         MVI   LINE121,C'+'            YES, KEEP IT
         SR    R1,R1                   RESET LINE COUNTER
SPACE1K  STCM  R1,1,RLINES             NUMBER OF REMAINING LINES
         MVI   MINLINES,0              RESET MINLINES
*
         ST    R13,DYNAM24+4           OLD SAVE AREA (DYNAM31)
         LA    R13,DYNAM24             NEW SAVE AREA (DYNAM24)
         PUSH  USING
         DROP  R13
         LA    R15,PRINT24             AMODE24
         MVC   0(PRINT24L,R15),PRINTPUT
         BASSM R2,R15                  AMODE24
         L     R13,4(,R13)             OLD SAVE AREA (DYNAM31)
         POP   USING
         MVC   LINE121,BLANKS          BLANK OUT
         RETURN (14,2)
PRINTPUT PUT   DCBDEBUG,LINE121        ISSUE PUT WITH AMODE24
         BSM   0,R2                    AMODE31
PRINT24L EQU   *-PRINTPUT
         DROP
*
*----------------------------------------------------------------------
*        RECOVERY ROUTINE FOR TRAPPING MY OWN ABENDS
*----------------------------------------------------------------------
*
         CNOP  0,8
         DC    C'RETRY00'              EYE CATCHER
RETRY00  LA    R15,012                 R0 VALUE FOR 'NO SDWA ALLOCATED'
         CLR   R0,R15                  SDWA ALLOCATED?
         BALR  R15,0                   LOCAL BASE
         BNE   RETRY04-*(,R15)         YES, JUMP
         SR    R15,R15                 SET RC=0 (IF R0=12)
         BR    R14                     RETURN TO EXIT PROLOG
*
RETRY04  BALR  R15,0                   LOCAL BASE
         SAVE  (14,12),,RETRY04        SAVE REGS
         BALR  R7,0
         USING *,R7
RETRY11  LR    R8,R1                   SAVE ADDR OF SDWA
         USING SDWA,R8
         L     R4,SDWAPARM             =A(DYNAM31)
         USING DYNAM31,R4
         CLI   #RETRY,0                ANY RETRY ADDRESS?
         BE    RETRY70                 NO, JUMP
*
RETRY40  CLC   =X'0C4000',SDWACMPC     S0C4 ABEND?
         BNE   RETRY70                 NO, IGNORE
         CL    R7,SDWANXT1             RETRY11 > ABEND ?
         BH    RETRY70                 YES, IGNORE
         SLR   R10,R10
         ICM   R10,B'0011',#RETRY      GET 16-BIT OFFSET
         ALR   R10,R7                  CHANGE OFFSET TO ADDRESS
         CL    R10,SDWANXT1            RETRY < ABEND ?
         BL    RETRY70                 YES, IGNORE
         NI    SDWACMPF,255-SDWAREQ    NO DUMP
         B     RETRY77
*
RETRY70  LA    R10,RETRY99             RETRY ADDRESS
         WTO   '==> DEBUGGING ROUTINE ABENDED <==',ROUTCDE=11
         MVC   SDWAGR13,DYNAM31+4      RTM SAVE AREA
*
RETRY77  MVC   SDWASRSV,SDWAGRSV       MOVE REGISTERS
         MVI   #RETRY,0                RESET RETRY ADDRESS
         SETRP WKAREA=(R8),                                            X
               RETADDR=(R10),RC=4,    <== RETRY                        X
               FRESDWA=YES,RETREGS=YES
RETRY99  RETURN (14,12)                GOBACK TO RTM
*---------------------------------------------------------------------*
*        BEGIN_PROC bootstrap                                         *
*---------------------------------------------------------------------*
BEGIN_PROC AH  R15,0(,R15)             add offset to far routine
         BR    R15                     branch to far routine
***********************************************************************
         MACRO
&NAME    TABLE &FN
&I       SETA  2
&J       SETA  &FN
&NAME2   SETC  '&NAME'
.LOOP    AIF   (T'&SYSLIST(&I) EQ 'O').NEXT
         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').HH
&K       SETA  K'&SYSLIST(&I)
&NAME2   DC    AL1(&J,&K),C'&SYSLIST(&I)'
.HH      AIF   ('&SYSLIST(&I)'(1,1) NE '''').NEXT
&K       SETA  K'&SYSLIST(&I)-2
&NAME2   DC    AL1(&J,&K),C&SYSLIST(&I)
.NEXT    ANOP
&NAME2   SETC  ''
&I       SETA  &I+1
&J       SETA  &J+1
         AIF   (&I LE N'&SYSLIST).LOOP
         MEND
***********************************************************************
TABLES   LOCTR
SVCTABLE TABLE 0,EXCP,WAIT,POST,EXIT,GETMAIN,FREEMAIN,LINK,XCTL,       X
               LOAD,DELETE,GETMAIN/FREEMAIN,TIME,SYNCH,ABEND,SPIE,     X
               ERREXCP,PURGE,RESTORE,BLDL/FIND,OPEN,CLOSE,STOW,        X
               'OPEN TYPE=J','CLOSE TYPE=T',DEVTYPE,TRKBAL,            X
               LOCATE/CATALOG,OBTAIN,CVOL,SCRATCH,RENAME,FEOV,REALLOC, X
               IOHALT,MGCR/QEDIT,WTO/WTOL,WTL,SEGLD/SEGWT,,LABEL,      X
               EXTRACT,IDENTIFY,ATTACH,CIRB,CHAP,OVLYBRCH,TTIMER,      X
               STIMER,DEQ,,,SNAP/SDUMP,RESTART,RELEX,DISABLE,EOV,      X
               ENQ/RESERVE,FREEDBUF,RELBUF/REQBUF,OLTEP,STAE/ESTAE,    X
               IKJEGS6A,DETACH,CHKPT,RDJFCB,,BTAMTEST,,                X
               SYNADAF/SYNADRLS,BSP,GSERV
         TABLE 79,STATUS,,SETPRT,,SMFWTM,GRAPHICS,DDRSWAP,ATLAS,DOM
         TABLE 91,VOLSTAT,TCBEXCP,TGET/TPUT,STCC,SYSEVENT,STAX,        X
               'TSO TEST',PROTECT,DYNALLOC,IKJEFFIB,,,XLATE,,IMGLIB,,  X
               MODESET,,'TYPE 3 ESR',DSTATUS,HASPSSSM,PGRLSE,PGFIX,    X
               EXCPVR,,'TYPE 1 ESR',DEBCHK,,TESTAUTH,                  X
               GETMAIN/FREEMAIN,VSAM,'TYPE 2 ESR',PURGEDEQ,,EVENTS
         TABLE 130,RACHECK,RACINIT,RACLIST,RACDEF
         TABLE 138,PGSER,CVAF,,,,CIPHER
         DC    X'FF',0D'0'             END OF TABLE
PCKTABLE TABLE 1,OPERATION,'PRIVILEGED OPERATION',EXECUTE,             X
               PROTECTION,ADDRESSING,SPECIFICATION,DATA,               X
               'FIXED-PT OVERFLOW','FIXED-PT DIVIDE',                  X
               'DECIMAL OVERFLOW','DECIMAL DIVIDE',                    X
               'EXPONENT OVERFLOW','EXPONENT UNDERFLOW',               X
               SIGNIFICANCE,'FLOATING-PT DIVIDE',                      X
               'SEGMENT TRANSLATION','PAGE TRANSLATION',               X
               'TRANSLATION SPECIFICATION','SPECIAL OPERATION'
         DC    X'FF',0D'0'             END OF TABLE
FF       EQU   X'FF'
*----------------------------------------------------------------------
*        DYNAMIC STORAGE
*----------------------------------------------------------------------
DYNAM31  LOCTR                     <== R13
         DS    18F                     SAVE AREA
TENWORDS DS    10F                     WORK
WKCELL1  DS    D                       WORK CELL
WKCELL2  DS    D                       WORK CELL
WKCELL3  DS    D                       WORK CELL
REGION24 DS    A,A                     START/END OF 24-BIT REGION
REGION31 DS    A,A                     START/END OF 31-BIT REGION
DYN_TCB  DS    A(TCB)                  TCB FOR FREEMAIN
DYNAM24P DS    A(DYNAM24)              24-BIT WORK AREA
SPACE2RE DS    A(R14)                  save area for R14
ESTAEL   ESTAE MF=L
MASKADDR DS    A(X'7FFFFFFF')          MASK FOR CLEANING UP ADDRESSES
LASTPRB  DS    A(RBPREFIX)             ADDR OF LAST PRB
FRSTSVRB DS    A(RBPREFIX)             ADDR OF FIRST SVRB
ABNDSVRB DS    A(RBPREFIX)             ADDR OF ABEND SVRB
MY_PRB   DS    A(RBPREFIX)             MY OWN RBPREFIX
CURR_R13 DS    A(R13)                  R13 at time of abend
BUFFER   DS    A                       START OF CURRENT BUFFER
CURR_REC DS    A(IHADCB)               CURRENT RCD PRINTED FOR THIS DCB
PREV_REC DS    A(IHADCB)               previous record
OPNLRECL DS    F                       LRECL from DEBLRECL/DCBLRECL
OPNBLKSI DS    F                       BLKSIZE from DEBBLKSI/DCBBLKSI
REGS     DS    16F
IEFEB4UV DS    V(IEFEB4UV)             IEFEB4UV
SWAREQL1 SWAREQ MF=L
SAVPLHPT DS    A(IDAPLHDR,IDAPLH)      save area
$DSAB    DS    A(DSAB)                 set by VALDCB
$JFCB    DS    A(INFMJFCB)             set by VALDCB
$SIOT    DS    A(INDMSIOT)             set by VALDCB
$TIOT    DS    A(TIOENTRY)             set by VALDCB
$DCB     DS    A(IHADCB)
$ACB     DS    A(IFGACB)
$AMBL    DS    A(AMBL)
$AMB_D   DS    A(AMB)
$AMB_I   DS    A(AMB)
$AMDSB_D DS    A(AMDSB)
$AMDSB_I DS    A(AMDSB)
$PLHDR   DS    A(IDAPLHDR)
$RPL     DS    A(IFGRPL)
$RTM2WA  DS    A(RTM2WA)               set by NEXTRB
#RETRY   DS    H,H                     OFFSET TO RETRY ADDRESS
SPLEVEL  DS    X                       MVS/SP LEVEL: 1, 2, 3, 4
RLINES   DS    FL1'60'                 LINE COUNT
MINLINES DS    FL1'01'                 MINIMUM NUMBER OF LINES
STRNO    DS    FL1                     string number (PLH/RPL)
DDNAME   DS    C'SYSPRINT'             SAVED DDNAME
DDNAME2  DS    C'SYSPRINT+002'         SAVED DDNAME
ABCODE   DS    C'ABEND=S013-18'        ABEND CODE
XDSORG   DS    C'PS'                   DATA SET ORG
XMACRF   DS    C'(GMC,PLC)'            DCBMACRF
XRECFM   DS    C'UTBSAM'               RECORD FORMAT
REASON   DS    C'00'                   reason code
OCE_CODE DS    C                       O/C/E CODE
ORIGIN2  DS    C'  (HSA)'              ORIGIN OF PSW2
EPNAME   DS    CL8                     EP NAME
OFFSET   DS    C'+X''123456'''         OFFSET FROM LOAD POINT
VIACALL  DS    C'SYNCH'                CALL/LINK/SYNCH
MSG20    DS    CL20
MSG60    DS    CL60
VOLSER   DS    CL6
STATUS   DS    C'OLD'
EYECATCH DS    CL120
TRTPRINT DS    XL256
BLANKS   DS    CL121                   LOTS OF BLANKS
UNITNAME DS    CL8,XL4,XL4             IEFEB4UV
TITLE121 DS    CL121                   TITLE LINE
X00      EQU   16,1                    X'00'
STACK128 DS    128A
SAVER012 DS    16F                     save area for R0=12 entry
         DS    0D
D31SDWA  DS    XL1000                  copy of RTM2's SDWA
DYN31FAR LOCTR
         DS    (DYNAM31+4096-*)C       MAKE IT A FULL PAGE
DYNAM31L EQU   *-DYNAM31
*
*        24-BIT WORKING STORAGE        <-- R12
*
DYNAM24  DSECT
         DS    18F                     SAVE AREA
OPENLIST OPEN  (DCBDEBUG,OUTPUT),MF=L
DCBDEBUG DCB   DSORG=PS,MACRF=PM,DDNAME=SYSDEBUG
PRINT24  DS    XL(PRINT24L)            CODE COPIED BY INIT RTNE
LINE121  DS    CL121                   PRINT LINE (control character)
LINE     EQU   LINE121+1,L'LINE121-1   PRINT LINE
         DS    0D                      align place-holder for freemain
DYNAM24H DS    CL(DYNAM24+16384-*)     PLACE HOLDER
DYNAM24L EQU   *-DYNAM24
         STRING GENERATE
***********************************************************************
         PRINT NOGEN
PRINT    OPSYN ANOP
         IHAPSA DSECT=YES              PREFIXED STORAGE AREA
         CVT   PREFIX=YES,DSECT=YES,LIST=NO
*@@@     IHALLT DSECT=YES              LNKLST/LPALST tables
LLT      DSECT
LLTLLT   DS    C'LLT '                 BLOCK ACRONYM
LLTNO    DS    F                       NUMBER OF ENTRIES
LLTENTRY DS    0CL45                   DSNAME ENTRY
LLTDSNL  DS    FL1                     DSNAME LENGTH AFTER TRUNCATION
LLTDSNAM DS    CL44                    DATA SET NAME
LLTNEXT  EQU   *                       NEXT ENTRY
         IHAASCB DSECT=YES             ADDRESS SPACE CONTROL BLOCK
         IHAASXB DSECT=YES             ADDRESS SPACE EXTENSION BLOCK
         IHAACEE                       Accessor Environment Element
         IHALDA                        Local Data Area
CSCB     DSECT
         IEECHAIN                      COMMAND SCHEDULER CONTROL BLOCK
         IKJTCB DSECT=YES              TASK CONTROL BLOCK
         IHASTCB                       Secondary TCB
         AIF   (D'STCBCDXH).CDEX1
STCBCDXH EQU   STCB+X'DC'              CDE extension hash table (ESA43)
.CDEX1   ANOP
         IKJRB  DSECT=YES              REQUEST BLOCK
         IHACDE                        CONTENTS DIRECTORY ENTRY
         AIF   (D'CDCDEX).CDEX2
CDCDEX   EQU   X'10'                   CDE extension exists (CDATTRB)
.CDEX2   ANOP
CDXH     DSECT                         CDE EXTENSION HASH TABLE
         DS    C'CDXHT 01'             CB ID
CDXHCNT  DS    F'103'                  NUMBER OF ENTRIES
CDXH$0C  DS    X'00000010'             WHATEVER
CDXHFRST DS    A(CDX1)                 HEAD OF CHAIN
CDXHLAST DS    A(CDX1)                 LAST ENTRY IN CHAIN
*
CDX1     DSECT                         CDE EXTENSION
CDX1NEXT DS    A(CDX1)                 FWD PTR
CDX1PREV DS    A(CDXHFRST)             BWD PTR
         DS    C'CDX1'                 CB ID
CDX1$0C  DS    A(CDX1NAME)             ADDR OF ENTRY POINT NAME
CDX1$10  DS    X'00080022'             10
CDX1$14  DS    X'80000000'             14
CDXCDE@  DS    A(CDENTRY)              BWD PTR
CDX1$1C  DS    X'00000000'             1C
CDX1$20  DS    X'00000002'             20
CDX1FLG4 DS    X'00020000'             24
CDX1PDSE EQU   X'80'                   LOADED FROM PDSE
CDX1TTRN DS    X'00010100'             TTRN
CDXDDNAM DS    C'STEPLIB '             DDNAME
CDX1SEQ  DS    X'00001C31'             SEQUENCE NUMBER
CDX1NAME DS    C'SYSDEBUG'             ENTRY NAME
CDX1_LEN EQU   *-CDX1
         IHALLE                        LOAD-LIST ELEMENT
         IHAXTLST                      EXTENT LIST
         IEFTCT                        SMF TCT
         IEFTIOT1                      TASK INPUT-OUTPUT TABLE
******** IEFZB4D5
DSABQDB  DSECT                         DSAB QUEUE DESCRIPTOR BLOCK
DSQDBID  DS    C'DSAB'                 ACRONYM
DSQATTRS DS    XL2                     ATTRIBUTES
DSQQDBLN DS    H'32'                   QDB LENGTH
DSQNELMS DS    F                       NUMBER OF ELEMENTS ON QUEUE
DSQFRSTP DS    A(DSAB)                 FIRST DSAB
DSQLASTP DS    A(DSAB)                 LAST DSAB
         IHADSAB                       DATA SET ASSOCIATION BLOCK
SIOT     DSECT
         IEFASIOT                      STEP I/O TABLE
JFCB     DSECT
         IEFJFCBN                      JOB FILE CONTROL BLOCK
         DCBD  DSORG=PS,DEVD=DA        IHADCB
         AIF   (D'DCBDCBE).SMS33
DCBDCBE  EQU   DCBRELAD                DCBE address
.SMS33   ANOP
         IEZDEB                        DATA EXTENT BLOCK
DEBEXTND EQU   X'0E'                   OPEN EXTEND
         IHADECB DSECT=YES             READ/WRITE
         IEZIOB  DSECT=YES             I/O BLOCK
         IEFUCBOB LIST=NO,PREFIX=NO    UNIT CONTROL BLOCK
         IEFJESCT                      JES VECTOR TABLE
         IHASCB  DSECT=YES             STAE CONTROL BLOCK
         IHASDWA DSECT=YES,VRAMAP=NO   SDWA DSECT
*@@      IHARTM2A
RTM2WA   DSECT
RTM2ID   DS    C'RTM2'                 CB ID
RTM2ADDR DS    A(RTM2WA)               Address
RTM2SPID DS    AL1(255)                sub-pool
RTM2LGTH DS    FL3'972'                length
RTM2CVT  DS    V(CVT)                  CVT addr
RTM2TCBC DS    V(TCB)                  TCB addr
RTM2VRBC DS    V(RBBASIC)              SVRB addr
RTM2ASC  DS    V(ASCB)                 addr of ASCB
RTM2CODE DS    0XL4                    completion code
RTM2CCF  DS    X                       flags
RTM2CC   DS    XL3                     Completion code
RTM2EREG DS    16F                     GPRs at time of abend
         DS    7F
RTM2EPSW DS    XL8                     EC PSW at time of error
RTM2AEC1 DS    XL8                     Additional EC mode information
         DS    10F
RTM2FLGS DS   0BL4                     Error Flags
RTM2ERRA DS    B                       Error type causing entry to RTM2
RTM2PCHK  EQU  X'40'                   Program Check
RTM2ABTM  EQU  X'08'                   ABTERM (SVC 13)
         DS    45F
RTM2PREV DS    A                       Previous RTM2WA
RTM2SDW2 EQU   RTM2WA+X'3DC',4,C'A'    RTM2's SDWA
         IRAOUCB DSECT=YES             OUCB DSECT
         IHALPDE                       LPDE DSECT
         IHARD                         REGION DESCRIPTOR
IFGACBVS OPSYN  ANOP
         IFGACB DSECT=YES              ACB DSECT
IFGRPLVS OPSYN  ANOP
         IFGRPL DSECT=YES              RPL DSECT
         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ
JCT      DSECT                         <--  JSCBJCT, LCTJCTAD
         DS    F,A,F,C'JCT '           PREFIX
JCTEQREG EQU   *+92,2,C'H'             REGION IN K (MAX VALUE IS 16383)
         IEFAJCTB                      JOB Control Table
         AIF   (D'JCTSWAUP).JCT2
JCTSISO  EQU   2                       JCTSTAT2, NEW WITH DFP 2.3
JCTSWAUP EQU   1                       JCTSTAT2, NEW WITH DFP 2.3
.JCT2    ANOP
         AIF   (D'JCTJMRTL).JCT3
JCTJMRTL EQU   INJMJCT+X'8C',3,C'F'    TIME limit (XA,ESA313)
.JCT3    ANOP
JCTX     DSECT                         <--  JCTJCTX
         DS    F,A,F,C'JCTX'           PREFIX
         IEFJCTX                       JCT Extension
         AIF   (D'JCTXJTL).JCTX3
JCTXJTL  EQU   JCTXIN+X'3C',4,C'F'     TIME limit (ESA410)
.JCTX3   ANOP
SCT      DSECT                         Step Control Table
         DS    XL16                    PREFIX
         IEFASCTB                      SCT
         AIF   (D'SCTSTIME).SCT2
SCTSTIME EQU   SCT+X'15',3,C'F'        step time limit (XA/ESA31)
.SCT2    ANOP
SCTX     DSECT                         Step Control Table Extension
         DS    XL16                    PREFIX
         IEFSCTX DSECT=NO              SYS1.MODGEN
         IEZJSCB                       JSCB
         IEFJSSIB                      Sub-System Identification Block
*@@      IGGICQE                       INTERRUPT CONTROL QUEUE ELEMENT
ICQE     DSECT                         INTERRUPT CONTROL QUEUE ELEMENT
ICQECB   DS    F                       ECB POINTED TO BY IOB IN SAMB
ICQIOBAD DS    A(IOB)                  ADDRESS OF IOB IN SAMB
ICQFIRST DS    A(IOB)                  FIRST USER IOB
ICQFLG   DS    X                       FLAG BYTE
ICQEXND  EQU   X'80'                   EXCPVR PROCESSING NEEDED
ICQENDAD DS    AL3(IOB)                LAST USER IOB
ICQFSTQ  DS    A(IOB)                  FIRST USER IOB IN QUEUE
ICQMAXQ  DS    FL1                     MAX NUMBER OF IOBS ON QUEUE
ICQNOQ   DS    FL1                     CURRENT NUMBER OF IOBS ON QUEUE
ICQSAVQ  DS    X,X                     SAVE AREA FOR ICQMAXQ (EOV)
ICQSAVCT DS    C'MBBCCHHR'             SAVE AREA FOR MBBCCHHR
ICQSAV   DS    18F                     SAVE AREA FOR EOB PROCESSING
*@@      VSAM MACROS
AMBL     DSECT
         DS    2F
AMBLACB  DS    V(IFGACB)               ADDRESS OF THE ACB
         DS    1F
AMBLDDNM DS    0CL8                    THE ACB'S DDNAME
AMBLCACB DS    A,XL3                   CATALOG ACB ADDR, CI NO
AMBLQ    DS    X                       QUALIFIER
AMBLDDC  EQU   X'80'                   DD CONNECT ONLY
AMBLGSR  EQU   X'40'                   GLOBAL SHARED RESOURCES
AMBLLSR  EQU   X'20'                   LOCAL SHARED RESOURCES
AMBLFSTP EQU   X'10'                   FAST PATH
AMBLUBF  EQU   X'08'                   USER BUFFERING
AMBLKSDS EQU   X'04'                   KEY-SEQUENCED DATA SET
AMBLESDS EQU   X'02'                   ENTRY-SEQUENCED DATA SET
AMBLDFR  EQU   X'01'                   DEFERRED WRITES
         DS    F,H                     XPT,LVC
AMBLTYPE DS    X                       TYPE OF CB ATRUCTURE OPENED
AMBLPATH EQU   X'80'                   PATH
AMBLUPGR EQU   X'40'                   UPGRADE SET
AMBLAIX  EQU   X'20'                   ALTERNATE INDEX
AMBLBASE EQU   X'10'                   BASE CLUSTER
AMBLQ2   DS    X                       QUALIFIED EXTENSION
AMBLSHR  EQU   X'20'                   SHR(3) OR SHR(4)
AMBLCRE8 EQU   X'10'                   CREATE MODE
AMBLID   DS    X'50'                   ID
AMBLSHAR DS    X                       Sharing indicators
AMBLPRIM EQU   X'80'                   Primary AMBL
AMBLWRIT EQU   X'20'                   OUTPUT or UPDATE mode
AMBLLEN  DS    FL1'80'                 Length of the AMBL
AMBLFLG1 DS    X,X                     FLG1, FLG2
AMBLDUMY EQU   X'01'                   DD DUMMY
AMBLNST  DS    FL1                     STRNO
         DS    H,A,A,F                 LNUM, MMIB, DSAB, SMFT
AMBLDTA  DS    A(AMB)                  DATA'S AMB
AMBLIX   DS    A(AMB)                  INDEX'S AMB
AMBLBIB  DS    V(BIB)                  BASE INFORMATION BLOCK
AMBLCMB  DS    V(CMB)                  CLUSTER MANAGEMENT BLOCK
*
AMB      DSECT
AMBID    DS    X'40',X,H,A             ID, TS, LEN, LINK
AMBBUFC  DS    A(BUFC)                 ADDRESS OF BUFC HEADER
AMBPH    DS    A(IDAPLHDR)             ADDRESS OF THE PLH HEADER
AMBCACB  DS    A(IFGACB)               ADDRESS OF THE ACB
AMBDSB   DS    A(AMDSB)                DATA SET STATISTICS BLOCK
AMBFLG0  DS    X                       FLAGS
AMBLDS   EQU   X'04'                   Linear Data Set
AMBFLG1  DS    X                       FLAGS
AMBCREAT EQU   X'80'                   CREATE MODE
AMBSPEED EQU   X'08'                   SPEED OPTION
AMBDSORG DS    X'0008'                 DSORG
         DS    A,XL3,AL3,H             IOB/IOMB, *, DDSN, *
AMBTIOT  DS    AL2,X,X,V(TCB)          TIOT, INFL, AMETH, TCB
AMBOFLGS DS    X,X,XL2                 OFLGS, FLG2
         DS    XL(136-52)
AMBDSNM  DS    CL44                    DATA SET NAME
*
BUFC     DSECT                         BUFC Header
BUFCID   DS    X'70'                   ID
BUFCBUFN DS    FL1                     BUFNI/BUFND
BUFCLEN  DS    H'88'                   length of BUFC entry
         DS    A,A,A,A                 more stuff
*
AMDSB    DSECT
AMDSBID  DS    X'60'                   ID
AMDATTR  DS    X                       ATTR
AMDRRDS  EQU   X'02'                   RRDS
AMDLEN   DS    H,H                     LEN, NEST
AMDRKP   DS    H                       KEY OFFSET
AMDKEYLN DS    H                       KEY LENGTH
*
IDAPLHDR DSECT
PLHID    DS    X'30',X,H               PLH HEADER
PLHCNT   DS    H                       COUNT OF PLH ENTRIES BEHIND HDR
PLHDRREQ DS    H                       COUNT OF DEFERRED REQUESTS
PLHDRMAX DS    H                       MAX NO OF PLH ENTRIES IN USE
PLHDRCUR DS    H                       NO OF ACTIVE ENTRIES
PLHIOSDQ DS    A                       DEFERRAL QUEUE HEADER
*
IDAPLH   DS    X'FF'               +16
PLHIDENT DS    C'PLH'
         DS    X,X,X,X,X,X,XL2         FLG0,1,2,3,4,5,EFLGS
         DS    X,X,X,FL1               RCODE, RMIN, FRCNT, BFRNO
PLHMRPL  DS    V(IFGRPL),0A            RPL HEADER, JRNAD
PLHCRPL  DS    V(IFGRPL)               CURRENT RPL
         DS    A,A,A,A,X,X,X,X,A
PLHLRECL DS    F,A,A                   LENGTH OF RECORD
PLHRECP  DS    A                       ADDRESS OF CURRENT RECORD
         DS    A,A,H,H,A,A,6F
PLHACB   DS    V(IFGACB),X,3X          ADDRESS OF THE ACB
PLHCHAIN DS    A(IDAPLH)               ADDRESS OF THE NEXT PLH
*        IHADCBE              DFSMS/MVS DCB extension
DCBE     DSECT
DCBEID   DS    CL4            DCBE eyecatcher 'DCBE'.
DCBELEN  DS    H              Length of DCBE.
DCBERSV1 DS    XL2            Reserved.
DCBEDCB  DS    A              DCB address. Set by system.
DCBERELA DS    CL4            Partitioned data set - TTRN
DCBEFLG1 DS    B              Flags set by system.
DCBEOPEN EQU   X'80'          DCBE has been successfully opened.
DCBEMD31 EQU   X'40'          User may call access method in AMODE31.
DCBEFLG2 DS    B              Flags set by user.
DCBEBU31 EQU   X'80'          RMODE31=BUFF.
DCBENEOD EQU   X'40'          PASTEOD=YES.
DCBENVER EQU   X'10'          NOVER=YES.
DCBEGSIZ EQU   X'08'          GETSIZE=YES.
DCBENSTR DS    H              The number of stripes
DCBERSV2 DS    XL12           Reserved.
DCBERSV3 DS    XL4            Reserved for future expansion of DCBESIZE
DCBESIZE DS    F              Number of blocks in current data set.
DCBEEODA DS    A              Address of user provided end-of-data
DCBESYNA DS    A              Address of user provided SYNAD routine.
DCBERSV4 DS    XL6            Reserved.
DCBEMACC DS    XL1            Accumulation number multiplier.
DCBEMSDN DS    XL1            Multiplier of System Determined NCP.
DCBEMINL EQU   *-DCBE         Minimal length of DCBE.
DCBEEND  EQU   *              End of DCBE.
         YREGS
        $LRC                           HASP LOGICAL RECORD
SDB      DSECT                         JES2
SDBID    EQU   SDB+X'0048',4           "SDB "
UBF      DSECT                         JES2
UBFID    EQU   UBF,4                   "UBF "
         END
//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB
//         DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=SYS1.V2R8M0.SHASMAC (OR HASPSRC)  $LRC
//         DD DISP=SHR,DSN=GILBERT.FILE183.PDS               STRING
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,5)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,2),DISP=(,PASS),DCB=BLKSIZE=3200
//*
//LKED    EXEC PGM=LINKEDIT,PARM='LIST,MAP,RENT'
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD *
  ORDER SYSDEBUG(P),@STRING
//         DD DISP=(OLD,PASS),DSN=*.ASMH.SYSLIN
//SYSLMOD  DD DISP=SHR,DSN=GILBERT.LOAD(SYSDEBUG),
// SPACE=(CYL,(0,1))
//*
//XCTL    EXEC PGM=SYSDEBUG,ACCT=IEFBR14
//STEPLIB  DD DISP=SHR,DSN=GILBERT.LOAD
//SYSDEBUG DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//*
//ASMH2 EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)
TESTDBUG CSECT
         SAVE  (14,12),,*
         BALR  R11,0
         USING *,R11
         LR    R14,R13
         LA    R13,=9C'SAVEAREA'
         ST    R14,4(,R13)
         ST    R13,8(,R14)
         LOAD  EP=SYSDEBUG
         LR    R15,R0
         BASSM R14,R15              <-- INITIALIZE DEBUGGING RTNE
         ESPIE SET,*+2,(4)              check my ESPIE override is OK
         OPEN  (STEPLIB,,SYSUT1,,ACB1,,                                X
               SYSUT2,OUTPUT,SYSPRINT,OUTPUT)
         GET   SYSUT1                   FIRST RECORD
         PUTX  SYSPRINT,SYSUT1
         READ  DECB1,SF,STEPLIB,WK256,256
         CHECK DECB1
         PUT   RPL=RPL1
         CLOSE ACB1
         OPEN  (DISKSUL,OUTPUT)
         LH    R2,=H'5000'
PUTSUL   PUT   DISKSUL,=AL2(21,0,1,2,3,4,5,6,7,8,9)
         BCT   R2,PUTSUL
         CLOSE DISKSUL
         MODCB ACB=ACB1,STRNO=2
         OPEN  (ACB1,,DISKSUL)
         GET   DISKSUL
         MVI   WK256,44
         PUT   RPL=RPL1
S80A     GETMAIN RC,LV=1024         <-- fill up private area below
         LTR   R15,R15
**       BZ    S80A
         EX 0,*                     <-- CAUSES S0C3
PUT2     PUT   SYSUT2               <-- CAUSES D37-04
*MVI SYSUT2+40,255
*EX 0,*
         B     PUT2                 <-- CAUSES D37-04
STEPLIB  DCB   DSORG=PO,MACRF=R,DDNAME=STEPLIB
SYSUT1   DCB   DSORG=PS,MACRF=GL,DDNAME=SYSLIN,DCBE=SYSUT1X
SYSUT1X  DCBE
ACB1     ACB   DDNAME=VSAMDD,MACRF=(KEY,SEQ,OUT),STRNO=1
RPL1     RPL   ACB=ACB1,OPTCD=KEY,AREA=WK256,AREALEN=256,RECLEN=100
SYSPRINT DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPRINT,RECFM=F,LRECL=80
SYSUT2   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSUT2,RECFM=FB,LRECL=80
DISKSUL  DCB   DSORG=PS,MACRF=(GL,PM),DDNAME=DISKSUL,RECFM=VB,LRECL=80
WK256    DS    256X
         YREGS
         END
//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//*
//GO      EXEC PGM=LOADER,PARM=NOPRINT
//STEPLIB  DD DISP=SHR,DSN=GILBERT.LOAD
//         DD DISP=SHR,DSN=GILBERT.LOAD
//SYSLIN   DD DISP=(OLD,PASS),DSN=*.ASMH2.SYSLIN
//$DMY     DD DUMMY
//SYSUT2   DD UNIT=SYSDA,SPACE=(TRK,(1,,1)),
// DSN=&&T2345678(M2345678)
//DISKSUL  DD UNIT=VIO,SPACE=(CYL,1),LABEL=(,SUL),BLKSIZE=32760
//*
//VSAMDD   DD UNIT=SYSDA,SPACE=(TRK,10),
//**          AMP='STRNO=1',
//            RECORG=KS,LRECL=100,KEYLEN=12
//*
//SYSPRINT DD SYSOUT=*
//SYSOUT   DD SYSOUT=*
//SYSIN    DD *
3333333
//SYSDEBUG DD SYSOUT=*,OUTLIM=01111
//SYSUDUMP DD SYSOUT=*,OUTLIM=22222
