//GILBERTB JOB (ACCT#),VSBROWSE,
// NOTIFY=&SYSUID,
// CLASS=A,MSGCLASS=X,COND=(0,NE)
//ASMH EXEC PGM=ASMA90,PARM=(NODECK,OBJECT,NOESD,NORLD,NOXREF)
***********************************************************************
*                                                                     *
* MODULE NAME = BR                                                    *
*                                                                     *
* DESCRIPTIVE NAME = VSAM/BDAM Browse Command for ISPF/PDF            *
*                                                                     *
* FUNCTION = This ISPF/PDF program allows you to browse most VSAM,    *
*            BDAM, and multi-volume data sets.  It may be invoked     *
*            as a TSO command, as a program, or as an edit macro.     *
*                                                                     *
* STATUS = R148                                                       *
*                                                                     *
* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*    DEPENDENCIES = MVS/XA or MVS/ESA                                 *
*                   ISPF V3 or V4                                     *
*                   STRING macro R400                                 *
*                                                                     *
*    AUTHORIZATION = NONE                                             *
*                                                                     *
*    RESTRICTIONS = NONE                                              *
*                                                                     *
* MODULE TYPE = PROCEDURE, (TSO Command Processor)                    *
*                                                                     *
*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *
*                IBM HIGH LEVEL ASSEMBLER/MVS                         *
*                                                                     *
*    MODULE SIZE = 8K                                                 *
*                                                                     *
*    ATTRIBUTES = REENTERABLE, RMODE 24, AMODE 31,                    *
*                 PROBLEM STATE, KEY 8                                *
*                                                                     *
* SYNTAX = See Below                                                  *
*                                                                     *
*        BR may be invoked as a TSO command, as a program,            *
*        or as an edit macro.                                         *
*                                                                     *
*        1. TSO command                                               *
*                                                                     *
*          Syntax:                                                    *
*                                                                     *
*            BR dsname                  data set name                 *
*               VOL(volser)             volume serial (optional)      *
*                                                                     *
*        2. EDIT macro                                                *
*                                                                     *
*          Syntax:                                                    *
*                                                                     *
*            !BR dsname                                               *
*                                                                     *
*        3. Program                                                   *
*                                                                     *
*            BR may be invoked via the ISPF SELECT service, the       *
*            TSO CALL command, or a LINK macro.  A fully-qualified    *
*            dsname and a volser may be specified in the parm.        *
*                                                                     *
*          Syntax:                                                    *
*                                                                     *
*            SELECT PGM(BR) <PARM(dsname<,volser>)>                   *
*                                                                     *
* OPERATION = See Below                                               *
*                                                                     *
*        BR first determines if the specified data set is             *
*        NOT supported by ISPF/PDF's BROWSE service, i.e. one         *
*        of the following:                                            *
*                                                                     *
*          1.  VSAM (ESDS, KSDS, RRDS, LDS)                           *
*          2.  BDAM                                                   *
*          3.  multi-volume                                           *
*          4.  BLKSIZE=0 or DSORG=0 or KEYLEN>0 or DS1LSTAR=0         *
*              or RECFM=VBS                                           *
*                                                                     *
*        Based on previous determination, BR will:                    *
*                                                                     *
*          a. Invoke the BROWSE service to process the data set,      *
*             if BROWSE supports it.                                  *
*                                                                     *
*          b. allocate the data set, process it using VSAM or EXCP,   *
*             and display the data via BRIF (the BROWSE interface),   *
*             if BROWSE does not support it.                          *
*                                                                     *
*    NOTES:                                                           *
*                                                                     *
*      a.  The dsname is optional.  When no dsname is specified,      *
*          BR tries to find a dsname on the screen (at the cursor     *
*          position).  If this fails, then BR prompts the user to     *
*          enter the dsname.                                          *
*                                                                     *
*      b.  If BR is invoked as a command or an edit macro             *
*          with a dsname that is not enclosed in quotes,              *
*          BR prefixes it with the userid.                            *
*                                                                     *
*      c.  A volume serial is optional.  BR assumes that the          *
*          data set is cataloged if no volser is specified.           *
*          If the data set is not cataloged, BR uses the ZDLVOL       *
*          variable (set when a command is invoked on the Data Set    *
*          List panel) to determine the volume serial.                *
*                                                                     *
*    Point-and-shoot Capabilities                                     *
*                                                                     *
*      If the user invokes BR without specifying a dsname,            *
*      BR tries to find a dsname on the screen, at the cursor         *
*      position; this technique, called "point-and-shoot",            *
*      is implemented here in two flavors:                            *
*                                                                     *
*      1. When it is invoked as an edit macro, BR uses standard       *
*         ISREDIT calls to retrieve the text under which the cursor   *
*         is currently located, scans the text for specific           *
*         delimiters, then extracts the data set name.                *
*                                                                     *
*      2. When it is invoked as a program or as a command,            *
*         BR extracts the screen image and cursor position            *
*         from the TLD, an ISPF control block that is not             *
*         part of the standard programming interface (this            *
*         technique may not work in future releases of ISPF).         *
*                                                                     *
*         Note that for this to work, it is imperative that BR        *
*         be invoked with MODE(FSCR).  Unfortunately, if you invoke   *
*         BR via the TSO command, the SELECT service invokes BR as    *
*         a command and uses MODE(LINE) as a default, which           *
*         prevents BR from retrieving the data set name.              *
*                                                                     *
*         So if you want use BR's point-and-shoot capabilities        *
*         outside of an EDIT session, you must use one of the         *
*         following options:                                          *
*                                                                     *
*           1. Instead of just TSO BR, type the following,            *
*              exactly as shown (no closing parenthesis)              *
*                                                                     *
*                TSO BR) MODE(FSCR                                    *
*                                                                     *
*              not something you want to type too often, but if       *
*              you set it up as a PFK, it's allright.                 *
*                                                                     *
*           2. Define BR as a command in the ISPF command table,      *
*              for example like this:                                 *
*                                                                     *
*                BR     0 SELECT PGM(BR) MODE(FSCR)                   *
*                                                                     *
*              then you can access BR just by typing BR on the        *
*              command line, on any screen.                           *
*                                                                     *
*           3. Write a simple REXX exec (or a CLIST) to invoke BR     *
*              with MODE(FSCR):                                       *
*                                                                     *
*                ARG dsn                                              *
*                "ISPEXEC SELECT CMD(BR" dsn ") MODE(FSCR)"           *
*                                                                     *
*              then you can access BR just by typing TSO %BR          *
*                                                                     *
*           4. Modify ISPCMDS to add MODE(FSCR) to the definition     *
*              of the TSO command                                     *
*                                                                     *
*                SELECT SUSPEND CMD(&ZPARM) MODE(FSCR)                *
*                                                                     *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*  $099 BR may now be invoked as a PGM or EDIT macro                  *
*  $099 Fixed a couple of bugs, added comments & TRACE macro          *
*  $110 Program made re-entrant, uses EXCP instead of BDAM            *
*  $120 Add limited support for Linear data sets (first 64 K only)    *
*  $121 Process RECFM=VS/VBS like RECFM=U                             *
*  $122 Process data sets with null DSORG                             *
*  $130 Prevent loop if track is empty                                *
*  $131 Issue ISRB603 message when VSAM data set is empty             *
*  $132 Do not ignore the member name, pass it to BROWSE              *
*  $133 Simplify processing of first record (ESDS/KSDS)               *
*  $134 Use standard BROWSE to process PDSEs                          *
*  $134 Use the SDSF SVC to open VVDS's and bypass ENQ                *
*  $135 Change APPLID to ISR if invoked under SDSF                    *
*  $136 Display program level on first screen                         *
*  $137 Finally figured out what was wrong with VSAM record #1 !!!    *
*  $138 Implement full support for linear data sets                   *
*  $138 Init message enhanced to help debugging                       *
*  $139 Add 8 to MAXLRECL if RECFM=U                                  *
*  $140 Display statistics at end of program                          *
*  $141 Retry with BUFSP=0 after FDBK=0C0004 error                    *
*  $142 Remove VVDS browse capability (it disables RACF protection)   *
*  $143 Work around ISPF V4 bug (ZDLDSORG='' for VSAM cluster)        *
*  $144 Improve dsname extraction from a window by using the          *
*       buffer address in TLDCLSP instead of TLD+128                  *
*  $145 Remove Authorized functions                                   *
*  $146 Use PANEL(ISRBROBA) in ISPF V4                                *
*  $147 Use standard BROWSE to process HFS, extended format,          *
*       and multi-volume (in ISPF V4)                                 *
*  $148 Re-invoke myself as a PGM when invoked as a CMD;              *
*       this should fix the FREEMAIN problems in SO5                  *
*                                                                     *
&REL     SETC  '148'                                                  *
***********************************************************************
VSBROWSE CSECT
VSBROWSE AMODE 31
         SAVE  (14,12),,'GSF UTILITIES - VSAM/BDAM BROWSE R&REL'
         LR    R12,R15                 1st base reg
         USING VSBROWSE,R12
         LA    R11,VSBROWSE+4095       2nd base reg
         USING VSBROWSE+4095,R11
         GETMAIN R,LV=DYNAML,SP=1      ALLOCATE DYNAMIC STORAGE AREA
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LA    R14,72(,R1)             clear working storage
         LA    R15,CLEARLEN-72         clear working storage
         SLR   R1,R1                   clear working storage
         MVCL  R14,R0                  clear working storage
         LM    R13,R1,8(R13)           SET R13, RELOAD R14-R1
         LR    R9,R1                   save PARM/CPPL address
         USING DYNAM,R13
         STM   R11,R12,BASEREGS        for read routines
*
         L     R1,X'021C'              PSATOLD (my TCB)
         L     R1,0(,R1)               TCBRBP (my PRB)
         ICM   R1,B'0111',X'00D'(R1)   RBCDE1 (my CDE)
         ST    R1,OWNCDE               keep the address of my CDE
         USING CDENTRY,R1
         TM    CDATTR,CDMIN            IS this a minor CDE?
         BZ    *+8                     no, jump
         L     R1,CDXLMJP              yes, point to major CDE
         MVC   OWNNAME,CDNAME          save my true name
         DROP  R1
*----------------------------------------------------------------------
         MACRO                                                    macro
&NAME    ISPLINK &OPRNDS,&ERRET=                                  macro
         GBLB  &IHBSWA                                            macro
&IHBSWA  SETB  1                       VL=1                       macro
&NAME    LA    R1,TENWORDS             parm list                  macro
         IHBOPLST ,&OPRNDS,MF=(E,(1))                             macro
         L     R15,ISPLINK@            ISPLINK bootstrap
         BALR  R14,R15                 invoke ISPLINK
         AIF   (T'&ERRET EQ 'O').MEND                             macro
         LTR   R15,R15                 Any error?
         BNZ   &ERRET                  yes, jump
.MEND    MEND                                                     macro
*----------------------------------------------------------------------
         LOAD  EP=ISPLINK
         ST    R0,ISPLINK@             save ISPLINK address
         LOAD  EP=ISPEXEC
         ST    R0,ISPEXEC@             save ISPEXEC address
         STRING 'CONTROL ERRORS RETURN',INTO=MESSAGE
         BAL   R14,ISPEXEC             execute command
         LTR   R15,R15                 ISPF active?
         BNZ   QUIT16                  no, quit
*
         LA    R0,L'ZAPPLID            max length of dsname
         ST    R0,DWD                  max length of dsname
         ISPLINK (=C'VCOPY ',=C'(ZAPPLID)',DWD,ZAPPLID,=C'MOVE '),     X
               ERRET=QUIT16
*
         LA    R0,L'ZENVIR             max length of dsname
         ST    R0,DWD                  max length of dsname
         ISPLINK (=C'VCOPY ',=C'(ZENVIR)',DWD,ZENVIR,=C'MOVE '),       X
               ERRET=QUIT16
         STRING 1X,INTO=PANEL          default panel
         CLI   ZENVIR+5,C'4'           ISPF V4
         BNE   *+10                    no, jump
         MVC   PANEL,=C'ISRBROBA'      ISPF V4 panel (with action bar)
*
         ICM   R3,B'1111',0(R9)        INVOKED AS A PGM?
         BM    PGM000                  Yes, jump
         OI    SWITCH1,SW1CMD          invoked as a command
         USING CPPL,R9                 SET UP ADDRESSABILITY TO CPPL
*
*        If no dsname has been specified, scan the screen buffer
*        at the cursor position to find a dsname
*
         L     R1,CPPLECT              ENVIRONMENT CONTROL TABLE
         TM    ECTSWS-ECT(R1),ECTNOPD  any operand specified?
         BZ    CALLPARS                yes, scan buffer
         BAL   R14,CURSOR           <- scan screen buffer for a dsname
         LTR   R0,R0                   dsname found?
         BNZ   MOVEDSN                 yes, used it
***********************************************************************
*                                                                     *
*        BUILD PARSE PARM LIST, CALL IKJPARS                          *
*                                                                     *
***********************************************************************
CALLPARS LA    R1,TENWORDS             POINT TO PPL
         USING PPL,R1                  SET UP ADDRESSABILITY TO PPL
         L     R0,CPPLUPT              USER PROFILE TABLE
         ST    R0,PPLUPT               STORE UPT ADDRESS IN PPL
         L     R0,CPPLECT              ENVIRONMENT CONTROL TABLE
         ST    R0,PPLECT               STORE ECT IN PPL
         LA    R0,ECB1                 EVENT CONTROL BLOCK
         ST    R0,PPLECB               STORE ECB IN PPL
         MVC   PPLPCL,=A(PCLCSECT)     STORE PCL ADDR INTO PPL
         LA    R0,DYNANSWR             ANSWER AREA
         ST    R0,PPLANS               STORE ANSWER ADDRESS IN PPL
         L     R0,CPPLCBUF             COMMAND BUFFER
         ST    R0,PPLCBUF              STORE BUFFER ADDRESS IN PPL
         LA    R14,=C'IKJPARS '        NAME OF PARSE ROUTINE
         L     R15,0016                CVTPTR
         L     R15,008(,R15)           CVTLINK
         STM   R14,R15,DWD             BUILD LINK PARMLIST
         LINK  SF=(E,DWD)              CALL THE PARSE ROUTINE
         LTR   R7,R15                  CHECK FOR ZERO PARSE RETURN
         BNZ   QUIT16                  GO AWAY UPSET
         DROP  R1                      PPL
***********************************************************************
*                                                                     *
*        PROCESS PARSED PARAMETERS                                    *
*                                                                     *
***********************************************************************
PARSE100 L     R2,DYNANSWR             LOAD PDL ADDRESS
         USING IKJPARMD,R2             SET UP ADDRESSABILITY TO PDL
         LA    R14,DSNAME              44-BYTE AREA
         LA    R15,L'DSNAME            GET LENGTH
         L     R0,DSNPCE               GET ADDRESS
         LH    R1,DSNPCE+4             ACTUAL LENGTH OF DSN
         ICM   R1,B'1000',=C' '        PADDING
         MVCL  R14,R0                  MOVE DATA SET NAME
         LA    R14,MEMBER              8-BYTE AREA
         LA    R15,L'MEMBER            GET LENGTH
         L     R0,DSNPCE+8             GET ADDRESS
         LH    R1,DSNPCE+8+4           ACTUAL LENGTH OF member name
         ICM   R1,B'1000',=C' '        PADDING
         MVCL  R14,R0                  MOVE DATA SET NAME
         TM    VOLPCE2+6,X'80'         CHECK VOLSER SUBPARAMETER
         BZ    PARSE300                JUMP IF NO SUBPARAM SPECIFIED
         L     R1,VOLPCE2+00           GET SUBPARAM ADDRESS
         MVC   VOLSER,0(R1)            MOVE 6-BYTE VOLUME SERIAL
         OI    SWITCH1,SW1UVOL         VOLSER given by user
         B     PARSE999                exit
         DROP  R2
*
*        retrieve the volser from PDF 3.4 panel
*
PARSE300 LA    R0,L'FULLDSN            length
         ST    R0,DWD
         ISPLINK (=C'VCOPY ',=C'ZDLDSN ',DWD,FULLDSN,=C'MOVE '),       X
               ERRET=PARSE999          VCOPY FAILED, QUIT
         CLC   DSNAME,FULLDSN          same data set name?
         BNE   PARSE999                no, exit
         LA    R0,L'ZDLDSORG           length
         ST    R0,DWD
         ISPLINK (=C'VCOPY ',=C'ZDLDSORG ',DWD,ZDLDSORG,=C'MOVE '),    X
               ERRET=PARSE999          VCOPY FAILED, QUIT
         CLC   =C'VS',ZDLDSORG         vsam data set?
         BE    PARSE999                yes, exit
         CLI   ZDLDSORG,C' '           vsam data set?    (OW14454)
         BE    PARSE999                yes, exit         (OW14454)
         LA    R0,L'VOLSER             length
         ST    R0,DWD
         ISPLINK (=C'VCOPY ',=C'ZDLVOL ',DWD,VOLSER,=C'MOVE '),        X
               ERRET=PARSE999          VCOPY FAILED, QUIT
         OI    SWITCH1,SW1UVOL         VOLSER given by user (faked)
*
PARSE999 IKJRLSA DYNANSWR              FREE PDL
         B     ALLOCATE
*----------------------------------------------------------------------
         MACRO
&LABEL   TRACE
&LABEL   LA    R1,=C'&LABEL'
&L       SETA  K'&LABEL
         LA    R0,&L                   length of literal
         SVC   93                      issue TPUT SVC
         MEND
         MACRO
&LABEL   TRACE ,                       (dummy macro)
         AIF   (T'&LABEL EQ 'O').MEND
&LABEL   DS    0H                      define label
.MEND    MEND
***********************************************************************
*                                                                     *
*        I've been invoked as a pgm, check if it is an edit macro     *
*                                                                     *
***********************************************************************
PGM000   TRACE
         LH    R0,0(,R3)               dsn length
         LA    R1,2(,R3)               dsn address
         LTR   R0,R0                   DO WE HAVE A PARM"
         BH    SCANPARM                yes, jump
         STRING 'ISREDIT MACRO (VAR)',INTO=MESSAGE
         BAL   R14,ISPEXEC             execute command
         LTR   R15,R15                 OK?
         BNZ   PGM500                  no, jump
*
*        BR has been invoked as an edit macro.  The first
*        parameter is used as dsname if a parm has been specified;
*        else, the dsname is picked up at the current cursor
*        location using standard edit macro calls.
*
PGM100   LA    R0,L'MESSAGE            max length of dsname
         ST    R0,DWD                  max length of dsname
         ISPLINK (=C'VCOPY ',=C'(VAR)',DWD,MESSAGE,=C'MOVE '),         X
               ERRET=PGM500
         ICM   R0,B'1111',DWD          Actual length of dsname
         BZ    PGM110                  no dsname, jump
         BCTR  R0,0
         BCTR  R0,0
         STRING (MESSAGE+1,(R0)),INTO=DSNAME
         CLI   MESSAGE,C''''           quoted dsn?
         BE    ALLOCATE                yes, jump
         MVC   DSNAME,MESSAGE          COPY DSNAME
         L     R1,CPPLUPT              USER PROFILE TABLE
         USING UPT,R1
         SLR   R0,R0
         ICM   R0,B'0001',UPTPREFL     PREFIX LENGTH
         BZ    ALLOCATE                yes, jump
         STRING (UPTPREFX,(R0)),'.',MESSAGE,INTO=DSNAME
         B     ALLOCATE                There is a dsname, ise it
         DROP  R1                      UPT
*
*        get the dsname at cursor location
*
PGM110   TRACE
         STRING 'ISREDIT (LINE,COL) = CURSOR',INTO=MESSAGE
         BAL   R14,ISPEXEC             execute command
         LTR   R15,R15                 OK?
         BNZ   PGM500                  no, jump
PGM110T  TRACE
         LA    R0,3                    max length of variable
         ST    R0,DWD                  max length of variable
         ISPLINK (=C'VCOPY ',=C'(COL)',DWD,MESSAGE,=C'MOVE '),         X
               ERRET=PGM500
PGM120T  TRACE
         PACK  DWD,MESSAGE(3)          pack cursor position
         CVB   R5,DWD                  cursor position
         LTR   R5,R5                   cursor in command line?
         BZ    PGM500                  yes, jump
         STRING 'ISREDIT (VAR) = LINE .ZCSR',INTO=MESSAGE
         BAL   R14,ISPEXEC             execute command
         LTR   R15,R15                 OK?
         BNZ   PGM500                  no, jump
PGM125T  TRACE
         LA    R0,255                  max length of line
         ST    R0,DWD                  max length of line
         LA    R4,BUFFER               work area
         ISPLINK (=C'VCOPY ',=C'(VAR)',DWD,(R4),=C'MOVE '),ERRET=PGM500
*
         BCTR  R5,0                    R5=0 if cursor is in pos 1
         BAL   R14,CURSOR21            scan line to extract dsname
         LTR   R0,R0                   dsname found?
         BP    MOVEDSN                 yes, process it
*
*        This is not an edit macro or no dsname has been found
*        at the cursor position; scan the screen buffer for a dsn
*
PGM500   BAL   R14,CURSOR           <- scan screen buffer for a dsname
         LTR   R0,R0                   dsname found?
         BNZ   MOVEDSN                 yes, used it
*
*        No dsname is available, re-invoke BR as a command,
*        which will prompt the user for the dsname
*
PGM600   STRING 'CMD(',OWNNAME,') MODE(FSCR) NEWAPPL(',ZAPPLID,')',    X
               INTO=MESSAGE
         B     SELECT
S99T15   DC    X'0015,0001,0008',C'SYSALLDA'
***********************************************************************
*                                                                     *
*        Allocate the data set                                        *
*                                                                     *
***********************************************************************
SCANPARM LR    R4,R1                   parm address
         LR    R5,R0                   parm length
         L     R15,=A(PARSE_PARM)      parse rtne addr
         BALR  R14,R15                 parse parm into DSNAME,VOLSER
         DC    S(L'DSNAME,DSNAME)      first operand
         DC    S(L'VOLSER,VOLSER)      second operand
         CLI   VOLSER,C' '             VOLSER given by user ?
         BNH   ALLOCATE                no, jump
         OI    SWITCH1,SW1UVOL         yes, remember it
         B     ALLOCATE
*
MOVEDSN  STRING ((R1),(R0)),INTO=DSNAME  move dsname
*
ALLOCATE TRACE
         LA    R0,L'DSNAME             Convert to uppercase
         LA    R1,DSNAME               Convert to uppercase
CAPSON   OI    0(R1),C' '              Convert to uppercase
         LA    R1,1(,R1)               Convert to uppercase
         BCT   R0,CAPSON               Convert to uppercase
*
         STRING DSNAME,INTO=FULLDSN
         CLI   MEMBER,C' '             do we have a member name?
         BNH   ALLOC100                no, jump
         STRING (DSNAME,,T),'(',(MEMBER,,T),')',INTO=FULLDSN
*----------------------------------------------------------------------
*                                                                     *
*        If I've been invoked as a TSO command or if ZAPPLID<>ISR,    *
*        re-invoke myself as a program with NEWAPPL(ISR) for the      *
*        following reasons:                                           *
*                                                                     *
*        1. prevent FREEMAIN errors when OPEN/GET/CLOSE are issued    *
*           under different TCBs (LDS, IAM, SO5)                      *
*                                                                     *
*        2. ensure PFK consistency when invoked under applications    *
*           (such as SDSF) that redefine the RFIND key                *
*                                                                     *
*----------------------------------------------------------------------
ALLOC100 STRING 'PGM(',(OWNNAME,,T),') PARM(',(FULLDSN,,T),',',        X
               (VOLSER,,T),')',INTO=MESSAGE
         CLC   =C'ISR ',ZAPPLID        APPLID=ISR?
         BNE   ALLOC105                no, jump
         TM    CPPL,X'80'              INVOKED AS A PGM?
         BO    ALLOC200                Yes, jump
         B     SELECT
ALLOC105 EQU   *
         STRING (MESSAGE,,T),' NEWAPPL(ISR)',INTO=MESSAGE
         B     SELECT
*----------------------------------------------------------------------
*                                                                     *
*        Allocate the data set                                        *
*                                                                     *
*----------------------------------------------------------------------
ALLOC200 LA    R14,ACB1_M              point to ACB, RPL, DCB models
         LA    R15,MODELS_L            length for move
         LA    R0,IFGACB               dynamic storage area
         LR    R1,R15                  length
         MVCL  R0,R14                  move models to dynamic storage
*
         IHBOPLST ,(S99T1,             return ddname                   X
               S99T2,                  dsname                          X
               =X'0004,0001,0001,08',  DISP=SHR                        X
               S99T15,                 UNIT=SYSALLDA                   X
               S99T57,                 return dsorg                    X
               S99T5D),                return volser                   X
               MF=(E,S99TUPTR)
         ST    R1,S99RB+8              Text unit pointers
         MVC   S99RB,=X'14,01,2000'
         MVC   S99T1(6),=X'0055,0001,0008'    return ddname
         MVC   S99T2(6),=X'0002,0001,002C'    dsname
         MVC   S99T57(6),=X'0057,0001,0002'   return dsorg
         MVC   S99T5D(6),=X'005D,0001,0006'   RETURN VOLSER
         TM    SWITCH1,SW1UVOL         VOLSER given by user ?
         BZ    ALLOC600                no, jump
         MVI   S99T5D+1,X'10'          yes, use volser
*
*        Allocate the data set
*
ALLOC600 LA    R1,S99RB                build SVC99 parm list
         ST    R1,S99RBPTR             build SVC99 parm list
         OI    S99RBPTR,X'80'          build SVC99 parm list
         LA    R1,S99RBPTR
         DYNALLOC ,                    ALLOCATE THE DATA SET
         LTR   R15,R15                 SVC99 went OK?
         BNZ   BROWSE                  no, quit
*
*        allocation is successful
*
ALLOC900 CLC   DSORG,=AL2(DS1ORGAM)    DSORG=VSAM?
         BNE   OPENDA                  NO, JUMP
*----------------------------------------------------------------------
*                                                                     *
*        INITIALIZE VSAM DATA SET                                     *
*                                                                     *
*----------------------------------------------------------------------
OPENVS   MVC   ACBDDNM,DDNAME          MOVE DDNAME
         LA    R2,IFGACB               point to ACB
         ST    R2,OPENLIST             build open list
         MVI   OPENLIST,X'80'          build open list
*
OPENVS1O OPEN  MF=(E,OPENLIST)         OPEN VSAM data set
         CH    R15,=H'4'               OPEN OK?
         BH    OPENVS7                 NO, QUIT
*
         SHOWCB ACB=(R2),AREA=(S,MAXRECNO),LENGTH=12,                  X
               FIELDS=(NLOGR,LRECL,ENDRBA),MF=(G,BUFFER)
         ICM   R0,B'1111',MAXLRECL     LRECL=0 (LDS)
         BZ    OPENVS3                 yes, jump
*
         ST    R2,RPLDACB-IFGRPL+RPL1  STORE ACB ADDRESS INTO RPL
         ST    R2,RPLDACB-IFGRPL+RPL2  STORE ACB ADDRESS INTO RPL
         LA    R0,RECAD                THE RIGHT WORD
         ST    R0,RPLAREA-IFGRPL+RPL1  STORE AREA ADDRESS INTO RPL
         ST    R0,RPLAREA-IFGRPL+RPL2  STORE AREA ADDRESS INTO RPL
         LA    R0,L'RECAD              LENGTH
         ST    R0,RPLBUFL-IFGRPL+RPL1  STORE AREA LENGTH INTO RPL
         ST    R0,RPLBUFL-IFGRPL+RPL2  STORE AREA LENGTH INTO RPL
         LA    R0,LOWRBA               ARGUMENT FOR POINT
         ST    R0,RPLARG-IFGRPL+RPL2   STORE ARG ADDR INTO RPL
*
         TESTCB ACB=(R2),ATRB=RRDS,MF=(G,BUFFER)  is this an RRDS?
         BE    OPENVS4                 YES, JUMP
*
         ICM   R1,B'1111',MAXRECNO     MAX NUMBER OF RECORDS
         BNZ   OPENVS2                 NOT ZERO, JUMP
         L     R1,=F'1000000'          file open, use 1 million
*
OPENVS2  SLL   R1,2                    MULT BY 4
         LA    R0,0(,R1)               31-bit only
         L     R1,=F'1000000'          minimum value
         CLR   R0,R1                   more than 1 million ?
         BL    OPENVS2G                yes, jump
*
*        file has more than 256K rec, get between 1meg and nrec*4 bytes
*
         GETMAIN VRU,LV=((R0),(R1)),LOC=ANY,BNDRY=PAGE
         LR    R14,R0                  actual length gotten
         SRL   R14,2                   convert to RECNO
         ST    R14,MAXRECNO            remember MAXRECNO
         B     OPENVS2S
*
OPENVS2G GETMAIN RU,LV=(R0),LOC=ANY,BNDRY=PAGE
*
OPENVS2S STM   R0,R1,RBATABLE          STORE LENGTH, ORIGIN
*
*        set up RPL for ESDS/KSDS
*
OPENVS2K MVI   VS_TYPE,C'K'            Cluster is a KSDS
         TESTCB ACB=(R2),ATRB=KSDS,MF=(G,BUFFER)  is this a KSDS?
         BE    OPENVS6                 YES, JUMP
         MVI   VS_TYPE,C'E'            Cluster is an ESDS
         MVI   RPLOPT2-IFGRPL+RPL1,RPLADR    OPTCD=ADR
         B     OPENVS6
*
*        If LRECL=0, the data set is a linear data set (LDS).
*        use the screen width as record length
*
OPENVS3  MVI   VS_TYPE,C'L'            Cluster is an LDS
         CLOSE MF=(E,OPENLIST)         close the ACB, we don't need it
*
         LA    R0,L'MAXLRECL           length for VCOPY
         ST    R0,DWD                  length for VCOPY
         ISPLINK (=C'VCOPY ',=C'(ZSCREENW)',DWD,MAXLRECL,=C'MOVE ')
         PACK  DWD,MAXLRECL            convert to binary
         CVB   R0,DWD                  convert to binary
         ST    R0,MAXLRECL             screen width (80 or 132)
         DIV   IDENTIFY,               identify                        X
               ID=DIV_TOKN,            identifier                      X
               TYPE=DA,                data set                        X
               DDNAME=DDNAME-1,        X'08',C'ddname  '               X
               MF=(E,DIV_LIST)
         LTR   R15,R15                 OK?
         BNE   X'800'                  no, quit
         DIV   ACCESS,                 access                          X
               MODE=READ,              read-only                       X
               SIZE=MAXRECNO,          size in pages                   X
               MF=(E,DIV_LIST)
         CH    R15,=H'4'               OK?
         BH    X'804'                  no, quit
*
*        calculate the number of records (display lines)
*
         SLR   R0,R0
         L     R1,MAXRECNO             number of pages
         SLDL  R0,12                   number of bytes
         AL    R1,MAXLRECL             round up
         BCTR  R1,0                    round up
         D     R0,MAXLRECL             round up
         ST    R1,MAXRECNO             number of display lines
         MVI   LOWRBA,X'7F'            first time switch
         B     OPENVS6
*
OPENVS4  MVI   VS_TYPE,C'R'            Cluster is an RRDS
*
OPENVS6  LA    R1,READVS00             read routine
         MVI   RECFM,C'V'              dummy RECFM for message
         B     BRIF
*
*        VSAM OPEN error
*
OPENVS7  CLI   ACBERFLG,160            empty data set?
         BNE   QUIT16                  no, quit
         MVC   ZERRMSG,=C'ISRB603 '    "no data to browse"
         LA    R7,4                    RC=4
         B     SETMSG8                 issue message
***********************************************************************
*                                                                     *
*        If DSORG=PO, invoke BROWSE with DATAID                       *
*                                                                     *
***********************************************************************
OPENPO   STRING 'LMINIT DATAID(BRDATAID) DDNAME(',DDNAME,') ENQ(SHRW)',X
               INTO=MESSAGE
         BAL   R14,ISPEXEC             invoke ISPEXEC service
         LTR   R15,R15                 went OK?
         BNZ   OPENDA                  no, jump
*
         LA    R0,L'BRDATAID           max length of dsname
         ST    R0,DWD                  max length of dsname
         ISPLINK (=C'VCOPY ',=C'(BRDATAID)',DWD,BRDATAID,=C'MOVE '),   X
               ERRET=OPENPO8
*
         STRING 'BROWSE DATAID(',BRDATAID,')',INTO=MESSAGE
         BAL   R14,ISPEXEC             invoke ISPEXEC service
         LR    R7,R15                  SAVE RETURN CODE FROM BROWSE
*
OPENPO8  STRING 'LMFREE DATAID(',BRDATAID,')',INTO=MESSAGE
         BAL   R14,ISPEXEC             invoke ISPEXEC service
         LTR   R15,R15                 went OK?
         BZ    SETMSG                  yes, exit
***********************************************************************
*                                                                     *
*        INITIALIZE BDAM DATA SET                                     *
*                                                                     *
***********************************************************************
OPENDA   L     R14,=X'C1,00,00,00'     CAMLST SEARCH
         LA    R15,DSNAME              GET WORK AREA ADDRESS
         LA    R0,VOLSER               GET WORK AREA ADDRESS
         LA    R1,DS1FMTID             GET WORK AREA ADDRESS
         STM   R14,R1,TENWORDS         STORE UPDATED CAMLST
         OBTAIN TENWORDS               GET F1-DSCB
         LTR   R15,R15                 OK?
         BNZ   BROWSE                  NO, QUIT
*
         TM    SWITCH1,SW1BRIF         Do we have to use BDAM?
         BO    OPENDA2                 YES, USE BDAM
         TM    DS1SMSFG,DS1PDSE+DS1STRP+DS1PDSEX+DS1DSAE PDSE/HFS ?
         BNZ   BROWSE                  YES, USE STANDARD BROWSE
         TM    DS1DSORG,DS1DSGPO       DSORG=PO?
         BO    BROWSE                  YES, USE STANDARD BROWSE
         TM    DS1DSORG,DS1DSGDA       DSORG=DA?
         BO    OPENDA2                 YES, USE BDAM
         OC    DS1DSORG,DS1DSORG       DSORG=0?
         BZ    OPENDA2                 YES, USE BDAM
         OC    DS1BLKL,DS1BLKL         BLKSIZE=0?
         BZ    OPENDA2                 YES, USE BDAM
         CLI   DS1KEYL,0               KEYLEN>0
         BH    OPENDA2                 YES, USE BDAM
         TM    DS1RECFM,DS1RECFV+DS1RECFS   VS/VBS?
         BO    OPENDA2                 YES, USE BDAM
         OC    DS1LSTAR,DS1LSTAR       EOF=0 ?
         BZ    OPENDA2                 YES, USE BDAM
*
*        Use BDAM for multi-volume data sets in ISPF V3
*        Use standard Browse in ISPF V4
*
         TM    DS1DSIND,DS1IND80       MULTI-VOLUME?
         BNO   BROWSE                  NO, USE STANDARD BROWSE
         CLI   ZENVIR+5,C'4'           ISPF V4 ?
         BNL   BROWSE                  YES, USE STANDARD BROWSE
*
*        determine the maximum lrecl
*
OPENDA2  DEVTYPE DDNAME,DVAREA,DEVTAB  get device type & track size
         LTR   R15,R15                 OK?
         BNZ   BROWSE                  NO, QUIT
*
         LA    R2,DCB1                 DCB address
         MVC   DCBDDNAM,DDNAME         MOVE DDNAME
         ST    R2,OPENLIST             build open list
         MVI   OPENLIST,X'80'          build open list
*
         TM    DS1RECFM,DS1RECFB       RECFM=.B?
         BZ    OPENDA2B                no, jump
         LH    R0,DS1LRECL             GET LRECL
         LTR   R0,R0                   LRECL=0?
         BNZ   OPENDA2C                no, jump
*
OPENDA2B ICM   R0,B'0011',DS1BLKL      GET BLKSIZE
         BNZ   OPENDA2C
         L     R0,DVAMAXRC             defaule blksize/lrecl
         STH   R0,DCBBLKSI             force BLKSIZE=32760 in DCB
*
OPENDA2C ST    R0,MAXLRECL             PASS IT TO BRIF
*
OPENDA2E CLI   DS1DSORG,DS1DSGPO       DSORG=PO?
         BNE   OPENDA2O                no, jump
         MVI   DCBDSORG,DS1DSGPO       yes, prevent S013-14 in ESA
*
OPENDA2O OPEN  MF=(E,OPENLIST)         OPEN DCB1
         LTR   R15,R15                 OK?
         BNZ   BROWSE                  NO, QUIT
*
*        determine record format
*
OPENDA3  TM    DCBRECFM,DCBRECU        RECFM=U?
         BO    OPENDA3U                yes, jump
         MVI   RECFM,C'F'              set RECFM=F
         TM    DCBRECFM,DCBRECF        RECFM=F?
         BO    OPENDA4                 yes, jump
         MVI   RECFM,C'V'              set RECFM=V
         TM    DCBRECFM,DCBRECV        RECFM=V?
         BO    OPENDA4                 yes, jump
OPENDA3U MVI   RECFM,C'U'              RECFM=U or no RECFM
         LA    R0,8                    add 8 to recsize
         AL    R0,MAXLRECL             add 8 to recsize
         ST    R0,MAXLRECL             add 8 to recsize
*
*        build IOB
*
OPENDA4  MVI   IOBFLAG1,IOBCMDCH+IOBSPSVC
         LA    R0,IOBNECB              ECB ADDRESS
         ST    R0,IOBECBPT             STORE ADDRESS
         LA    R0,CCW1                 FIRST CCW IN CHAIN
         ST    R0,IOBSTART             STORE ADDRESS
         ST    R2,IOBDCBPT             DCB ADDRESS
         LA    R15,SECTORNO            SECTOR NUMBER X'00'
         LA    R0,L'SECTORNO           LENGTH IS ONE BYTE
         STM   R15,R0,CCW1             SET SECTOR CCW
         MVI   CCW1+0,X'23'            COMMAND: SET SECTOR
         MVI   CCW1+4,CC               FLAGS: COMMAND CHAINING
*
         LA    R15,IOBCC               CCHHR ADDRESS
         LA    R0,5                    LENGTH IS FIVE BYTES
         STM   R15,R0,CCW2             SET SECTOR CCW
         MVI   CCW2+0,X'31'            COMMAND: SEARCH ID EQUAL
         MVI   CCW2+4,CC               FLAGS: COMMAND CHAINING
         LA    R15,CCW2                SEARCH CCW
         SLR   R0,R0                   2ND WORD
         STM   R15,R0,CCW3             TIC CCW
         MVI   CCW3+0,X'08'            COMMAND: TIC
*
         LA    R15,BUFFER              FIRST BLOCK
         SLR   R0,R0
         ICM   R0,B'0011',DVATRKLN     track length
         STM   R15,R0,CCW4             READ CCW
         MVI   CCW4,X'5E'              COMMAND CODE: READ MULTIPLE TRK
         OI    CCW4+4,SLI              FLAGS: SLI
*
*        Calculate the number of blocks per track
*
         TRKCALC FUNCTN=TRKCAP,                                        X
               TYPE=DVAUNIT,                                           X
               R=1,K=DCBKEYLE,DD=DCBBLKSI,                             X
               REGSAVE=YES,                                            X
               MF=(E,BUFFER)
         LTR   R15,R15
         BNZ   BROWSE                  TRKCALC ERROR
         ST    R0,BLKPTRK              NUMBER OF BLOCKS PER TRACK
         CLI   RECFM,C'F'              RECFM=F?
         BE    OPENDA8                 yes, jump
*
*        allocate RRNtable if RECFM=V or RECFM=U
*
OPENDA7  SLR   R0,R0
         ICM   R0,B'0111',DCBREL       number of tracks in data set
         SLL   R0,2                    mult by 4 (size of a word)
         GETMAIN RU,LV=(R0),LOC=ANY,BNDRY=PAGE
         STM   R0,R1,RBATABLE          STORE LENGTH, ORIGIN
         MVI   0(R1),X'7F'             end of table
         MVI   MAXRECNO,X'7F'          maximum record number
         B     OPENDA9
*
*        Calculate MAXRECNO for RECFM=F data sets
*
OPENDA8  SLR   R1,R1
         ICM   R1,B'0111',DCBREL       number of tracks in data set
         M     R0,BLKPTRK              number of blocks in data set
         LH    R14,DCBBLKSI            get blksize
         MR    R0,R14                  number of bytes  in data set
*PDUMP DCB1,ENDRBA+3
         D     R0,MAXLRECL             NUMBER OF RECORDS
         ST    R1,MAXRECNO             number of records in data set
*
OPENDA9  MVI   TTTR,X'FF'              force first read
         LA    R1,READDA00             read routine
         MVI   VS_TYPE,C'*'            dummy type for message
         B     BRIF
***********************************************************************
*                                                                     *
*        Invoke ISPF/PDF BROWSE                                       *
*                                                                     *
*        The BROWSE function is invoked in two situations:            *
*                                                                     *
*          1. the data set appears to be supported by BROWSE          *
*                                                                     *
*          or                                                         *
*                                                                     *
*          2. dynamic allocation failed, BROWSE will try to allocate  *
*             it also, will (probably) fail and issue an appropriate  *
*             message.                                                *
*                                                                     *
***********************************************************************
BROWSE   STRING '''',(FULLDSN,,T),'''',INTO=MESSAGE
         CLI   VOLSER,C' '             do we have a volser?
         BH    BROWSE2                 yes, jump
         ISPLINK (=C'BROWSE ',MESSAGE)
         LR    R7,R15                  save return-code from BROWSE
         B     SETMSG
BROWSE2  ISPLINK (=C'BROWSE ',MESSAGE,VOLSER)
         LR    R7,R15                  save return-code from BROWSE
         B     SETMSG
***********************************************************************
*
*        Invoke ISPF/PDF BRIF Service
*
***********************************************************************
BRIF     ST    R1,READRTNE             read routine
         LA    R0,SAVERRTN             DDATA FOR BRIF
         ST    R0,DDATA                DDATA FOR BRIF
*
         CLC   MAXLRECL,=F'32760'      IS RECSIZE TOO BIG?
         BNH   *+10                    NO, JUMP
         MVC   MAXLRECL,=F'32760'      YES, TRUNCATE IT
         MVC   VS_LRECL,=F'32760'      prime work area
*
         STRING 'DSORG=',(DSORG,,X),                                   X
               ' VS_TYPE=',VS_TYPE,                                    X
               ' RECFM=',RECFM,                                        X
               ' MAXLRECL=',(MAXLRECL,F,L),                            X
               ' MAXRECNO=',(MAXRECNO,F,L),                            X
               ' VOLSER=',VOLSER,                                      X
               INTO=MESSAGE
         BAL   R2,SETMSG44             issue opening message
*
         ISPLINK (=C'BRIF',                                            X
               DSNAME,                                                 X
               =C'V ',                                                 X
               MAXLRECL,                                               X
               READRTNE,                                               X
               0,                                                      X
               DDATA,                                                  X
               PANEL)
         LR    R7,R15                  SAVE RETURN CODE FROM BRIF
*
*        Display min/max record sizes for KSDS/ESDS
*
BRIF70   CLI   VS_TYPE,C'K'            KSDS?
         BE    BRIF72                  yes, jump
         CLI   VS_TYPE,C'E'            ESDS?
         BNE   SETMSG                  NO, JUMP
BRIF72   STRING VS_TYPE,'SDS',                                         X
               ' MAXRECNO=',(MAXRECNO,F,L),                            X
               ' Records_processed=',(VS_RECNO,F,L),                   X
               ' MINLRECL=',(VS_LRECL,F,L),                            X
               ' MAXLRECL=',(VS_LRECL+4,F,L),                          X
               INTO=MESSAGE
         BAL   R2,SETMSG44             issue VSAM statistics
***********************************************************************
*
*        PROGRAM EXIT
*
*           1. issue error message
*           2. clean up
*           3. goback to caller
*
***********************************************************************
SETMSG   LTR   R7,R7                   CHECK RC FROM BRIF/BROWSE
         BZ    QUIT50                  OK, exit
SETMSG4  TRACE
         LA    R0,L'ZERRMSG
         ST    R0,DWD
         ISPLINK (=C'VCOPY ',=C'ZERRMSG ',DWD,ZERRMSG,=C'MOVE ')
         LTR   R15,R15                 CHECK RC
         BNZ   QUIT50                  bad, exit
*
SETMSG8  ISPLINK (=C'SETMSG ',ZERRMSG)
         B     QUIT50
*
SETMSG44 LR    R0,R15                  save length of long message
         STRING '    BR R&REL',INTO=SHORTMSG
         STM   R15,R0,DWD              lengths of short & long msgs
         ISPLINK (=C'VREPLACE',=C'ZEDSMSG ',DWD,SHORTMSG)
         ISPLINK (=C'VREPLACE',=C'ZEDLMSG ',DWD+4,MESSAGE)
         ISPLINK (=C'SETMSG ',=C'ISRZ000 ')
         BR    R2
*----------------------------------------------------------------------
*
*        Re-invoke myself via the SELECT service
*
*----------------------------------------------------------------------
SELECT   ST    R15,DWD                 length
         ISPLINK (=C'SELECT ',DWD,MESSAGE)
         LR    R7,R15                  SAVE RETURN CODE FROM ISPLINK
         B     QUIT50
*
QUIT16   LA    R7,16                   RC=16
*----------------------------------------------------------------------
*
*        free work area and goback to ISPF
*
*----------------------------------------------------------------------
QUIT50   TM    OPENLIST,X'80'          OPEN list OK?
         BZ    QUIT53                  no, jump
         CLOSE MF=(E,OPENLIST)         CLOSE ACB/DCB
*
QUIT53   LM    R0,R1,RBATABLE          GET LENGTH, ORIGIN
         LTR   R0,R0
         BZ    QUIT55
         FREEMAIN RU,LV=(0),A=(1)      FREE TABLE OF POINTERS
*
QUIT55   TM    S99RBPTR,X'80'          SVC 99 req blk OK?
         BNO   QUIT60                  no, jump
         MVI   S99RB+1,2               VERB=FREE
         OI    S99TUPTR,X'80'          ONLY 1 T.U.
         MVI   S99T1+1,1               X'55' -> X'01'
         LA    R1,S99RBPTR
         DYNALLOC ,                    FREE THE DATA SET
*
QUIT60   CLI   DIV_LIST,0              DIV in progress?
         BE    QUIT90                  no, jump
         XC    DIV_LIST(4),DIV_LIST    clear flags to prevent S08B-0005
         DIV   UNIDENTIFY,             remove access                   X
               MF=(E,DIV_LIST)
*
QUIT90   LR    R1,R13                  Work area
         L     R13,4(,R13)
         FREEMAIN R,LV=DYNAML,SP=1,A=(1)
         LR    R15,R7                  Return code
         RETURN (14,12),RC=(15)
         DROP  R9                      CPPL
***********************************************************************
*        Invoke ISPEXEC service
***********************************************************************
ISPEXEC  ST    R15,DWD                 LENGTH
         LA    R0,DWD                  LENGTH
         LA    R1,MESSAGE              text
         STM   R0,R1,TENWORDS          build parm list
         OI    TENWORDS+4,X'80'        build parm list
         L     R15,ISPEXEC@            addr of ISPEXEC
         LA    R1,TENWORDS             parm list
         BR    R15                     invoke ISPEXEC service
***********************************************************************
*                                                                     *
*        Scan data at the cursor position for a dsname                *
*                                                                     *
*        Some of this code has been lifted from ISPCDSN,              *
*        (file 270 of the CBT tape), I hope they don't mind.          *
*                                                                     *
*        The TLD address is retrieved from ISPTASK's register 1,      *
*        as done by ISPEXEC and ISPLINK.  If BR is invoked as a       *
*        program, ISPF passes the TLD address in the second word      *
*        of the parameter list built by the SELECT service; when      *
*        BR is invoked as a command, no TLD address is passed, as     *
*        far as I know.                                               *
*                                                                     *
***********************************************************************
CURSOR   L     R1,X'21C'               PSATOLD (MY TCB)
*LOOP
CURSOR11 L     R2,112(,R1)             TCBFSA
         CLI   40(R2),C'I'             R5 SLOT CONTAINS 'ISPF'
         BNE   CURSOR14                NO, JUMP
         CLI   24(R2),X'00'            IS R1 A 24-BIT ADDR?
         BNE   CURSOR14                NO, JUMP
         ICM   R2,B'1111',24(R2)       R1 SLOT (ADDR OF TLD PTR)
         BZ    CURSOR14                NO, JUMP
         CLI   0(R2),X'00'             IS IT A CLEAN 24-BIT ADDR?
         BNE   CURSOR14                NO, JUMP
         L     R2,0(,R2)               R2->TLD
         CLC   =C'TLD',0(R2)           IS THIS REALLY A TLD?
         BE    CURSOR19                YES, EXIT LOOP
CURSOR14 L     R1,132(,R1)             TCBOTC (MOTHER TASK)
         CL    R1,124(,R1)             IS IT THE JSTCB?
         BNE   CURSOR11                NO, CHECK FOR A TLD
*ENDLOOP
         B     CURSOR98                exit with "no-dsname" rc
*
*        TLD located, now get the line address and cursor
*        position.
*
CURSOR19 SLR   R0,R0
         LH    R1,166(,R2)             get cursor offset (TLDCSR)
         L     R3,192(,R2)             screen width (TLDCLSWD)
         DR    R0,R3                   get line # (R0) and offset (R1)
         LR    R5,R0                   cursor offset in line
         MR    R0,R3                   get offset to current line
         AL    R1,096(,R2)             change offset to addr (TLDCLSP)
         LR    R4,R1                   Current line in screen image
*----------------------------------------------------------------------
*
*        Scan current line at cursor position for a dsname
*
*              R4: current line
*              R5: cursor position
*
*----------------------------------------------------------------------
CURSOR21 MVI   TRNTBL,255
         MVC   TRNTBL+1(255),TRNTBL    init table
         SLR   R15,R15
         SLR   R0,R0
         BAL   R1,CURSOR22             branch around table, set R1
         DC    C'$',AL1(1)
         DC    C'.',AL1(1)
         DC    C'(',AL1(1)
         DC    C')',AL1(1)
         DC    C'#',AL1(2)             #@
         DC    C'a',AL1(9)
         DC    C'j',AL1(9)
         DC    C's',AL1(8)
         DC    C'{',AL1(1)             C0
         DC    C'-',AL1(1)             60
         DC    C'A',AL1(9)
         DC    C'J',AL1(9)
         DC    C'S',AL1(8)
         DC    C'0',AL1(10)
         DC    X'00',0H'0'             end of table
*LOOP
CURSOR22 IC    R15,0(,R1)              FIRST BYTE
         IC    R0,1(,R1)               ITERATIONS
*--LOOP
CURSOR23 LA    R2,TRNTBL(R15)          point to TRNTBL+X'4A'
         MVI   0(R2),0                 STORE X'00' INTO TRNTBL+X'4A'
         LA    R15,1(,R15)             BUMP INDEX
         BCT   R0,CURSOR23             NEXT CHARACTER
*--ENDLOOP
         LA    R1,2(,R1)               NEXT ENTRY IN TABLE
         CLI   0(R1),0                 END OF TABLE?
         BNE   CURSOR22                NEXT STRING
*ENDLOOP
*
*        scan current line at cursor position to extract the dsn
*
         LA    R3,0(R5,R4)             R3-> cursor location
         CLI   0(R3),C'('              Is it left paren?
         BZ    CURSOR71                Yes, extract within parens
         TRT   0(1,R3),TRNTBL          Are we on data set name?
         BZ    CURSOR60                Yes, begin scanning for start
         CLI   0(R3),C''''             Is it a quote?
         BNZ   CURSOR98                No, cursor invalid
         MVI   QFLAG,X'80'             Yes, indicate left quote
         TRT   1(1,R3),TRNTBL          Is dsn to right of quote?
         BZ    CURSOR80                Yes, prepare to extract it
         LTR   R5,R5                   Cursor in pos 1?
         BZ    CURSOR98                yes, this is bad
         BCTR  R3,0                    No,  check left of quote
         TRT   0(1,R3),TRNTBL          Was it there?
         BNZ   CURSOR98                No,  cursor invalid
         MVI   QFLAG,X'01'             Yes, indicate right quote
*
*        scan backwards to locate beginning of dsname
*
CURSOR60 LTR   R5,R5                   Cursor in pos 1?
         BZ    CURSOR81                yes, dsn starts in pos 1
         LR    R0,R3                   current position
         SR    R0,R4                   subtract addr of pos 1
         BNP   CURSOR98                bad, quit
*loop
CURSOR62 BCTR  R3,0                    R3-> cursor location
         TRT   0(1,R3),TRNTBL          Byte in table?
         BNZ   CURSOR70                No,  found left delimiter
         BCT   R0,CURSOR62             Yes, decr offset; check next
*endloop
         B     CURSOR81                dsname starts in pos 1
*
*        R3 now points to start of dsname
*
CURSOR70 CLI   0(R3),C'('              Was delimiter left paren?
         BNE   CURSOR75                No, include parens in dsn
CURSOR71 MVI   TRNTBL+C')',C')'        Make right paren a delimiter
         MVI   TRNTBL+C'(',0           Include parens in dsn if present
         B     CURSOR80                Extract withing parens
CURSOR75 MVI   TRNTBL+C'(',0           Include parens in dsn if present
         CLI   0(R3),C''''             Was delimiter a quote?
         BNE   CURSOR80                No,  leave bits unchanged
         OI    QFLAG,X'80'             Yes, indicate left quote
*
*        scan dsname to locate its right boundary
*
CURSOR80 LA    R3,1(,R3)               R3-> left position of dsname
*
CURSOR81 TRT   0(56,R3),TRNTBL         Scan until not in table
         BZ    CURSOR98                end dlm not found, exit
         LR    R2,R1                   R2-> right delimiter
         CLI   0(R2),C''''             Was delimiter a quote?
         BNE   CURSOR90                No,  leave bits unchanged
         OI    QFLAG,X'01'             Yes, indicate right quote
*
CURSOR90 TM    QFLAG,X'81'             Quotes surrounding dsname ?
         BM    CURSOR98                no matching quotes
         LR    R0,R2                   R0 = first byte after dsname
         LR    R1,R3                   R1 = first byte of dsname
         SLR   R0,R1                   R0 = length
         BR    R14                     exit
*
CURSOR98 SLR   R0,R0                   no dsname
         SLR   R1,R1                   no dsname
*
CURSOR99 BR    R14                     GOBACK
***********************************************************************
*                                                                     *
*        PARSE A COMMA-DELIMITED JCL PARM                             *
*                                                                     *
*        LA    R4,PARM                 PARM VALUE                     *
*        LH    R5,LENGTH               PARM LENGTH                    *
*        L     R15,=A(PARSE_PARM)                                     *
*        BALR  R14,R15                                                *
*        DC    S(L'PARM1,PARM1)        LENGTH,ADDR                    *
*        DC    S(L'PARM2,PARM2)        LENGTH,ADDR                    *
*                                                                     *
***********************************************************************
PARSE_PARM SAVE (14,12),,*
         BCTR  R4,0                    START OF PARM - 1
         ALR   R5,R4                   LAST BYTE OF PARM
*LOOP
PARSE_PARM1 SLR R0,R0                  R0 = 00000000
         ICM   R0,B'0011',2(R14)       R0 = 0000BDDD
         SRDL  R0,12(0)                R0 = 0000000B, R1= BBB.....
         SRL   R1,20(0)                R1 = 00000DDD DISPLACEMENT
         ALR   R1,R13                  ADD CALLER'S SAVE AREA ADDR
         LR    R6,R1                   ADDR OF TARGET FIELD
         LH    R7,0(,R14)              LENGTH OF TARGET FIELD
*
         LA    R2,1(,R4)               FIRST BYTE OF CURRENT PARAMETER
*--LOOP
PARSE_PARM2 LA R4,1(,R4)               BUMP POINTER
         CLR   R4,R5                   END OF PARM REACHED?
         BH    PARSE_PARM4             YES, EXIT LOOP
         CLI   0(R4),C','              DELIMITER?
         BNE   PARSE_PARM2             NO, KEEP LOOPIN'
*--ENDLOOP
PARSE_PARM4 LR R3,R4                   POSITION OF ','
         SR    R3,R2                   LENGTH OF SOURCE PARAM
         ICM   R3,B'1000',=C' '        PADDING
         MVCL  R6,R2                   MOVE SOURCE TO TARGET
         LA    R14,2+2(,R14)           NEXT TARGET
         CLI   0(R14),0                IS THIS A FIELD DESCRIPTOR?
         BE    PARSE_PARM1             YES, PROCESS IT
*ENDLOOP
         RETURN (0,12),T
***********************************************************************
*
*        VSAM READ ROUTINE
*
***********************************************************************
$FARRTNE LOCTR
READVS00 SAVE  (14,12),,'VSBROWSE - VSAM READ RTNE'
         LM    R4,R7,0(R1)             INPUT PARMS
         L     R7,0(,R7)               A(SAVERRTN)
         ST    R13,4(,R7)
         ST    R7,8(,R13)
         LR    R13,R7
         USING SAVERRTN,R13
         LM    R11,R12,BASEREGS
*
READVS10 TRACE
         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)
         C     R3,MAXRECNO             BEYOND END OF FILE?
         BH    READVS80                YES, EXIT
*
         LA    R7,RPL1                 OPTCD=SEQ
         USING IFGRPL,R7
         CLI   VS_TYPE,C'R'            is this an RRDS?
         BE    RRDS00                  YES, JUMP
         CLI   VS_TYPE,C'L'            is this an LDS?
         BE    LDS000                  YES, JUMP
*
*        check rbatable if record has already been read
*
READVS30 LR    R2,R3                   RRN
         BCTR  R2,0                    RELATIVE TO ZERO
         SLL   R2,2                    MAKE IT AN INDEX IN RBA TABLE
         AL    R2,RBATABLE+4           CHANGE OFFSET TO ADDRESS
         ICM   R2,B'1111',0(R2)        GET RBA OF RECORD
         BNZ   READVS50                ALREADY READ, JUMP
*
*        the record requested has never been read; read the file
*        sequentially until the desired record is reached.
*
         L     R8,HIGH_RRN             LAST RECORD READ SEQUENTIALLY
*LOOP
READVS31 TRACE
         GET   RPL=RPL1                GET NEXT RECORD
         LTR   R15,R15                 OK?
         BZ    READVS45                YES, JUMP
*
*        actual end of data (should only occur when SHOWCB
*        returned MAXRECNO=0)
*
         CLI   RPLRTNCD,X'08'          IS THIS A LOGICAL ERROR?
         BNE   READVS38                NO, JUMP
         CLI   RPLFDB3,X'04'           end of data?
         BE    READVS81                YES, exit
*
*        The first time a spanned record is read (FDBK=X'84'),
*        switch RPL1 and RPL2 from OPTCD=LOC to OPTCD=MVE.
*        From that point on, all GETs will be move mode.
*        Note that a cluster defined with the SPANNED attribute
*        does not necessarily contain spanned records (ie records
*        made up of more than one segment).
*
READVS34 CLI   RPLFDB3,X'48'           OPTCD=KEY with DATA component?
         BE    READVS35                YES, JUMP
*
         CLI   RPLFDB3,X'84'           OPTCD=LOC WITH SPANNED RECORDS?
         BNE   READVS90                no, error
*
         NI    RPLOPT1,255-RPLLOC      OPTCD=MVE
         NI    RPLOPT1-IFGRPL+RPL2,255-RPLLOC  OPTCD=MVE
         LA    R0,BUFFER               THE RIGHT WORD
         ST    R0,RPLAREA              STORE AREA ADDRESS INTO RPL
         ST    R0,RPLAREA-IFGRPL+RPL2  STORE AREA ADDRESS INTO RPL2
         L     R0,=F'65536'            AREALEN=65536
         ST    R0,RPLBUFL              AREALEN=65536
         ST    R0,RPLBUFL-IFGRPL+RPL2  AREALEN=65536 INTO RPL2
         B     READVS40
*
READVS35 MVI   VS_TYPE,C'E'            Cluster is an ESDS
         MVI   RPLOPT2-IFGRPL+RPL1,RPLADR    OPTCD=ADR
         B     READVS40
*
*        Physical error (R15=0C)
*
READVS38 CLC   RPLFDBK,=X'0C0004'      R15=0C,ERRCD=04 ?
         BNE   READVS90                NO, exit
         TM    SWITCH1,SW1CMD          invoked as a command ?
         BO    READVS90                yes, exit to prevent S30A-18
         CLOSE MF=(E,OPENLIST)         close the ACB
         XC    ACBBUFSP,ACBBUFSP       BUFSP=0
         OPEN  MF=(E,OPENLIST)         re-open the ACB
*
*        re-read a record after X'48' or X'84'
*
READVS40 TRACE
         GET   RPL=RPL1                RE-READ RECORD AFTER 48 OR 84
         LTR   R15,R15                 OK?
         BNZ   READVS90                NO, QUIT
*
*        store RBA into RBATABLE for the next time this record is read
*
READVS45 LR    R2,R8                   RRN
         SLL   R2,2                    MAKE IT AN INDEX IN RBA TABLE
         AL    R2,RBATABLE+4           CHANGE OFFSET TO ADDRESS
         MVC   0(4,R2),RPLDDDD         SAVE RBA OF RECORD
         LA    R0,1                    count records actually read
         AL    R0,VS_RECNO             count records actually read
         ST    R0,VS_RECNO             count records actually read
         LA    R8,1(,R8)               BUMP CURRENT RRN
         CR    R8,R3                   Was it the record needed?
         BL    READVS31                no, get next
*ENDLOOP
         ST    R3,HIGH_RRN             SAVE RRN OF RECORD
         L     R1,RBATABLE+4           point to rbatable
         MVI   0(R1),X'7F'             dummy RBA for record 1
         B     READVS70
*
*        re-read a record already read, using the RBA kept in the table
*
READVS50 TRACE
         ST    R2,LOWRBA               store RBA into ARG
         CH    R3,=H'1'                first record?
         BNE   READVS51                no, jump
         MVI   LOWRBA,0                yes, clear hi-order X'FF'
*
READVS51 LA    R7,RPL2                 OPTCD=DIR
         LA    R0,LOWRBA               specify search argument
         ST    R0,RPLARG               store ARG addr into RPL2
         NI    RPLOPT1,255-RPLSEQ      clean up OPTCD=SEQ
         OI    RPLOPT1,RPLDIR          set OPTCD=(ADR,DIR,KGE)
         MVI   RPLOPT2,RPLADR          set OPTCD=(ADR,DIR,KGE)
         GET   RPL=RPL2                re-read record
         LTR   R15,R15                 OK?
         BZ    READVS70                yes, jump
         STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X
               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X
               ' RRN=',((R3),,L),' RBA=',(LOWRBA,,X),                  X
               INTO=MESSAGE
         SLR   R15,R15                 RC=00
         B     READVS95                ISSUE MESSAGE
*
*        KEYED ACCESS (RRDS)
*
RRDS00   ST    R3,LOWRBA               RRN
         LA    R7,RPL2                 OPTCD=DIR
         MVI   RPLOPT1,RPLLOC+RPLDIR   OPTCD=(DIR,KEQ,LOC,KEY)
         MVI   RPLOPT2,RPLKEY          OPTCD=(DIR,KEQ,LOC,KEY)
         GET   RPL=RPL2                GET RECORD (RRDS)
         LTR   R15,R15                 OK?
         BZ    READVS70                YES, JUMP
         STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X
               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X
               ' RRN=',((R3),,L),INTO=MESSAGE
         SLR   R15,R15                 RC=00
         B     READVS95                ISSUE MESSAGE
*
*        Linear data set
*
LDS000   BCTR  R3,0                    RRN relative to zero
         MH    R3,MAXLRECL+2           make it an RBA
         ST    R3,TTTR                 save RBA
         CL    R3,LOWRBA               this page in storage?
         BL    LDS020                  no, jump
         L     R1,=F'65536'            window size
         AL    R1,LOWRBA               first RBA after end of window
         SL    R1,MAXLRECL             end address
         CLR   R3,R1                   this page in storage?
         BL    LDS050                  yes, jump
*
*        un-stage previous pages
*
LDS020   CLI   LOWRBA,X'7F'            first time?
         BE    LDS022                  yes, jump
         XC    DIV_LIST(4),DIV_LIST    prevent S08B-0005
         DIV   UNMAP,                  unmap previous window           X
               AREA=CCW4,              pointer to my window            X
               MF=(E,DIV_LIST)
*
*        stage 16 pages
*
LDS022   LR    R14,R3                  current RBA
         SRL   R14,12                  convert RBA to block number
         LA    R15,16                  number of pages in window
         STM   R14,R15,TENWORDS        store pointers
         LA    R0,BUFFER               DIV window
         ST    R0,CCW4                 DIV window
         XC    DIV_LIST(4),DIV_LIST    prevent S08B-0005
         DIV   MAP,                    access                          X
               OFFSET=TENWORDS+0,      offset to 1st page              X
               SPAN=TENWORDS+4,        number of pages                 X
               AREA=CCW4,              pointer to my window            X
               MF=(E,DIV_LIST)
         LTR   R15,R15                 OK?
         BNE   X'808'                  no, quit
*
         ST    R3,LOWRBA               window offset
         NC    LOWRBA,=F'-4096'        beginning of page
*
LDS050   LA    R2,BUFFER(R3)           CHANGE OFFSET TO ADDRESS
         SL    R2,LOWRBA               RBA relative to begin of window
*STRING (LOWRBA,,X),1X,((R3),,X),1X,((R2),,X),INTO=(80-26(R2),26)
         MVC   RPLRLEN,MAXLRECL        RECORD LENGTH
         B     READVS74                goback to BRIF
*
*        return record just read to BRIF
*
READVS70 L     R2,RPLAREA              NO, GET RECORD ADDR (OPTCD=MVE)
         TM    RPLOPTCD,RPLLOC         OPTCD=MVE?
         BZ    READVS74                YES, JUMP
         L     R2,0(,R2)               GET RECORD ADDR (OPTCD=LOC)
READVS74 ST    R2,0(,R4)               PASS RECORD ADDRESS TO BRIF
         L     R0,RPLRLEN              pick up record length
         ST    R0,0(,R5)               PASS RECORD LENGTH TO BRIF
         CL    R0,VS_LRECL             smaller than minimum?
         BH    *+8                     no, jump
         ST    R0,VS_LRECL             keep smallest length
         CL    R0,VS_LRECL+4           larger than maximum?
         BL    *+8                     no, jump
         ST    R0,VS_LRECL+4           keep largest length
         L     R13,4(,R13)
         RETURN (14,12),RC=00
*
*        record number too high, return number of highest rcd to BRIF
*
READVS80 MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER
READVS81 L     R13,4(,R13)
         RETURN (14,12),RC=8
*
*        error in GET macro, show feedback code
*
READVS90 STRING '** ERROR ** RPLFDBWD=',(RPLFDBWD,,X),                 X
               ' REQ=',(RPLREQ,,X),' OPTCD=',(RPLOPTCD,2,X),           X
               ' RRN=',((R3),,L),' HIGH_RRN=',((R8),,L),               X
               INTO=MESSAGE
         ST    R3,0(,R6)               END OF FILE
         ST    R3,MAXRECNO             END OF FILE
         LA    R15,008                 RC=8 (EOF)
.@TEST2 SR 15,15
*
*        return error message to BRIF
*
READVS95 LA    R0,MESSAGE              MESSAGE
         ST    R0,0(,R4)               PASS ADDRESS
         LA    R0,L'MESSAGE            LENGTH
         ST    R0,0(,R5)               PASS LENGTH
         L     R13,4(,R13)
         RETURN (14,12),RC=(15)
***********************************************************************
*
*        NON-VSAM READ ROUTINE
*
*        This routine reads records from a non-vsam data-set
*        by issuing EXCP macros against a BDAM DCB.
*
*        This method (EXCP+BDAM DCB) offers the following advantages:
*
*        a. the program has access to all of the volumes of a
*           multi-volume data set at the same time, with a single
*           OPEN, a single DCB, and no need to go through EOV
*
*        b. full tracks may be read, which speeds up access
*           to un-blocked or poorly-blocked data sets
*
***********************************************************************
READDA00 SAVE  (14,12),,'DABROWSE - BDAM READ RTNE'
         LM    R4,R7,0(R1)             parameters from BRIF
         STM   R4,R7,TENWORDS          save them
         L     R7,0(,R7)               A(SAVERRTN)
         ST    R13,4(,R7)
         ST    R7,8(,R13)
         LR    R13,R7
         USING SAVERRTN,R13
         LM    R11,R12,BASEREGS
         L     R3,0(,R6)               RECORD NUMBER (FROM BROWSE)
         CL    R3,MAXRECNO             beyond end of file?
         BH    READDA80                yes, exit
         CLI   RECFM,C'F'              RECFM=F?
         BE    READDA30                yes, jump
*----------------------------------------------------------------------
*
*        Process RECFM=V/VB/U records
*
*        This routine reads the data set sequentially and
*        builds a table of high RRN (relative record number)
*        for each track.  This table is used to remember which
*        track holds a particular record.
*
*----------------------------------------------------------------------
READDA20 L     R1,RBATABLE+4           point to table
*PDUMP DCB1,ENDRBA+3
         BAL   R15,*+8                 set R15, skip LA first time
*--loop
         LA    R1,4(,R1)               bump index
         CL    R3,0(,R1)               record on this track?
         BHR   R15                     no, try next one
*--endloop
*PDUMP BUFFER,BUFFER+256
         LR    R3,R1                   address of table entry
         SH    R1,=H'4'                previous entry
         ST    R1,ENDRBA               save address of prev table entry
*
         SL    R3,RBATABLE+4           offset
         SRL   R3,2                    track number
         SLL   R3,8                    TTT0
         BAL   R14,EXCP00          <-- read a track
         LTR   R15,R15                 EOF?
         BZ    READDA21                no, jump
*
*        out-of-extents condition
*
         L     R1,ENDRBA               load address of prev table entry
         MVC   MAXRECNO,0(R1)          last RRN on last track
         B     READDA80                exit with RC=8
*CLC BUFFER(4),IOBSEEK+3
*BE XXX
*L R2,0(,R6)
*PDUMP DCB1,ENDRBA+3
*XX EQU *
*
*        scan track buffer to count records
*
READDA21 L     R1,ENDRBA               load address of table entry
         CLI   4(R1),X'7F'             end-of-table flag?
         BNE   READDA24                no, skip buffer scan
         SLR   R1,R1                   start of track
         SLR   R2,R2                   record number on this track
*--loop
READDA22 BAL   R14,GETREC              scan buffer
         LA    R2,1(,R2)               count records on this track
         LTR   R1,R1                   end of buffer reached?
         BNZ   READDA22                no, get next record
*--endloop
         BCTR  R2,0                    ignore last call
         STC   R2,TTTR+3               save number of records
*
*        store current track's RRN into rbatable
*
         L     R1,ENDRBA               load address of prev table entry
         CL    R1,RBATABLE+4           first track?
         BL    READDA23                yes, jump
         AL    R2,0(,R1)               no, add previous track's RRN
READDA23 ST    R2,4(,R1)               fill in table entry
         MVI   8(R1),X'7F'             set table stop
         L     R3,0(,R6)               RRN from BRIF
         B     READDA20                keep on reading sequentially
*endloop
*
READDA24 L     R3,0(,R6)               RRN from BRIF
         L     R1,ENDRBA               load address of prev table entry
         CL    R1,RBATABLE+4           first track?
         BL    READDA25                yes, jump
         SL    R3,0(,R1)               no, subtract RRN of prev trk
*
READDA25 SLR   R1,R1                   start of track
*loop
READDA26 BAL   R14,GETREC              scan buffer
         BCT   R3,READDA26             until my record is reached
*endloop
*****    LA    R1,8(,R1)               data address
         B     READDA70                goback
*----------------------------------------------------------------------
*
*        process RECFM=F/FB records
*
*        This routine assumes that the data set is RECFM=FS or FBS,
*        i.e. that it does not contain truncated records.
*        This assumption allows the track address of a particular
*        record to be calculated without reading the preceding
*        records.  For example, to access record # 1111 in a
*        data set that has 10 blocks per track and 10 records per
*        block, track 11 is read, then record # 1 of the block # 2
*        is returned to BRIF (1111 = 11*100 + 10 + 1)
*
*----------------------------------------------------------------------
READDA30 BCTR  R3,0                    first record is R0
         M     R2,MAXLRECL             OFFSET IN BYTES
         LH    R14,DCBBLKSI            PICK UP BLKSIZE
         DR    R2,R14                  BLOCK NUMBER IN R3, OFFSET IN R2
         ST    R2,0(,R4)               save offset
*
*        R3 = relative block address (first block is zero)
*
         SLR   R2,R2
         D     R2,BLKPTRK              get relative track number
         LA    R2,1(,R2)               first record on track is R1
         SLL   R3,8                    R3 = TTTTTT00
         OR    R3,R2                   R3 = TTTTTTRR
         BAL   R14,EXCP00          <-- read a track
         LTR   R15,R15
         BNZ   READDA80                out-of-extents
*
*        scan the buffer for the right block (R3 contains record #)
*
         SLR   R1,R1                   start of track
*loop
READDA32 BAL   R14,GETREC              scan buffer
         LTR   R1,R1                   end of buffer reached?
         BZ    READDA55                yes, error
         CLM   R3,B'0001',4(R1)        is this my record number?
         BNE   READDA32                no, try next block
*endloop
         ICM   R0,B'0111',5(R1)        is this an EOF?
         BZ    READDA51                yes, exit
         L     R0,MAXLRECL             maximum record length
         LA    R1,8(,R1)               point to the first record
         AL    R1,0(,R4)               add record offset
         B     READDA70                return record to BRIF
*
READDA51 L     R0,0(,R4)               load record offset
         LTR   R0,R0                   first record?
         BNZ   READDA55                no, jump
         LA    R0,L'READDA52           message length
         BAL   R1,READDA70             branch around message
READDA52 DC    C'**EOF**',0H'0'
*
READDA55 LA    R0,L'READDA56           message length
         BAL   R1,READDA70             branch around message
READDA56 DC    C'**NO RECORD FOUND**',0H'0'
*
READDA70 ST    R1,0(,R4)               PASS RECORD ADDRESS TO BRIF
READDA71 ST    R0,0(,R5)               PASS RECORD LENGTH TO BRIF
         L     R13,4(,R13)
         RETURN (14,12),RC=00
*
*        return to BRIF with RC=8 (high RRN)
*
READDA80 MVC   0(4,R6),MAXRECNO        RETURN MAX RECORD NUMBER
         L     R13,4(,R13)
         RETURN (14,12),RC=8        <- RC=8   (return highest rrn)
*----------------------------------------------------------------------
*        read a track
*----------------------------------------------------------------------
EXCP00   STM   R2,R14,12(R13)
         CLM   R3,B'1110',TTTR         track in buffer already?
         BE    EXCP80                  YES, JUMP
         ST    R3,TTTR                 STORE TRACK ADDRESS
*
*        convert TTRN to IOBSEEK (MBBCCHHR)
*
         L     R0,TTTR                 load TTTR
         SRL   R0,8                    make it 0TTT
         SLL   R0,16                   make it TT00
         L     R1,DCBDEBAD             DCBDEBAD
         LA    R2,IOBSEEK              MBBCCHHR FIELD
         LR    R6,R13                  SAVE R13
         L     R15,16                  CVTPTR
         L     R15,28(,R15)            CVTPCNVT
         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR
         LM    R6,R13,28(R6)           RESTORE R6-R13
         LTR   R15,R15                 OK?
         BNZ   EXCP90                  no, eof
         EXCP  IOBSTDRD             <- read a track
         WAIT  1,ECB=IOBNECB           wait for completion
*PDUMP BUFFER,BUFFER+400
EXCP80   SLR   R15,R15                 RC=00
         CLC   BUFFER(4),IOBSEEK+3     CHECK CCHH
         BE    EXCP90                  OK, exit with r15=0
         LA    R15,4                   no, eof
*
EXCP90   LM    R2,R14,12(R13)          restore registers
         BR    R14
*----------------------------------------------------------------------
*
*        scan read buffer
*
*----------------------------------------------------------------------
GETREC   CLI   RECFM,C'V'              RECFM=V?
         BE    GETRECV1                yes, jump
*
*        RECFM=U
*
         LTR   R1,R1                   First time?
         BZ    GETREC8                 yes, jump
         SLR   R15,R15
         ICM   R15,B'0011',6(R1)       get record length
         SLR   R0,R0
         IC    R0,5(,R1)               get key length
         LA    R1,8(R15,R1)            l'count+l'data
         ALR   R1,R0                   add l'key
         CLC   0(4,R1),IOBSEEK+3       is this my CCHH?
         BE    GETREC9                 yes, process it
         SLR   R1,R1                   no, end-of-track
         BR    R14
GETREC8  LA    R1,BUFFER               start-of-track
GETREC9  SLR   R0,R0
         ICM   R0,B'0011',6(R1)        block size (from count+6)
         AH    R0,=H'8'                add l'count
         CL    R0,MAXLRECL             too big?
         BNHR  R14                     no, goback
         L     R0,MAXLRECL             yes, truncate
         BR    R14
*
*        RECFM=V
*
GETRECV1 LTR   R1,R1                   First time?
         BZ    GETRECV5                yes, jump
         CLC   MAXLRECL+2(2),0(R1)     RDW length OK?              @133
         BL    GETRECV2                no, EOF                     @133
         AH    R1,0(,R1)               add length from RDW
         CL    R1,RECAD                end of block?
         BL    GETRECV9                not yet, process this record
         CLC   0(4,R1),IOBSEEK+3       is this my CCHH?
         BE    GETRECV8                yes, process it
GETRECV2 SLR   R1,R1                   no, end-of-track
         BR    R14
GETRECV5 SLR   R0,R0                                               @133
         SLR   R1,R1                                               @133
         ICM   R0,B'1100',BUFFER+6     get DD from CCHHRKDD        @133
         CL    R0,BUFFER+8             is this a BDW?              @133
         BNER  R14                     no, EOF                     @133
         LA    R1,BUFFER               start-of-track
GETRECV8 SLR   R15,R15
         ICM   R15,B'0011',6(R1)       block size (from count+6)
         LA    R0,7(R15,R1)            last byte of current block
         ST    R0,RECAD                save end of block address
         LA    R1,8(,R1)               skip count, point to BDW
         LA    R1,4(,R1)               first record in this block
GETRECV9 LH    R0,0(,R1)               length of the record from RDW
         BR    R14
*----------------------------------------------------------------------
*        MODEL DCB, ACB, RPL
*----------------------------------------------------------------------
*        PRINT NOGEN
ACB1_M   ACB   MACRF=(ADR,KEY,SEQ,DIR,IN),STRNO=2,RMODE31=ALL,         X
               BUFSP=200000
RPL1_M   RPL   ACB=*-*,OPTCD=(KEY,SEQ,LOC,NSP),AREA=*-*,AREALEN=4
RPL2_M   RPL   ACB=*-*,OPTCD=(ADR,DIR,LOC,KGE),AREA=0,AREALEN=4,ARG=0
DCB1_M   DCB   DSORG=DA,MACRF=RIC,DDNAME=SYSUT1
MODELS_L EQU   *-ACB1_M
*----------------------------------------------------------------------
*        DEFINE INPUT PARAMETERS FOR IKJPARS                          *
*----------------------------------------------------------------------
PCLCSECT IKJPARM
DSNPCE   IKJPOSIT DSNAME,LIST,USID,PROMPT='DATA SET NAME',             X
               HELP='NAME OF THE DATA SET TO BE BROWSED'
VOLPCE   IKJKEYWD
         IKJNAME 'VOLUME',SUBFLD=VOLSUBF,ALIAS='VOLSER'
VOLSUBF  IKJSUBF
VOLPCE2  IKJIDENT 'VOLUME',MAXLNTH=6,FIRST=ALPHANUM,OTHER=ALPHANUM
         IKJENDP
***********************************************************************
*                                                                     *
*        Dynamic Storage           <-- R13                            *
*                                                                     *
***********************************************************************
DYNAM    DSECT
         DS    18F                     SAVE AREA (MAIN LINE)
SAVERRTN DS    18F                     SAVE AREA (READ ROUTINE)
BASEREGS DS    A(VSBROWSE+4095,VSBROWSE)
TENWORDS DS    10F                     LEN/ADDR OF BDAM BUFFER
DWD      DS    D                       VCOPY
DIV_TOKN DS    D                       DIV token
DIV_LIST DIV   IDENTIFY,MF=L           DIV parm list
ZAPPLID  DS    C'ISR     '             current ISPF application ID
ZENVIR   DS    CL32'ISPF 3.2'          ISPF environment
ZDLDSORG DS    C'VS      '             data set org from PDF 3.4 panel
ZERRMSG  DS    C'12345678'             ERROR MESSAGE
BRDATAID DS    C'ISR12345'             DATA ID from LMINIT
DDATA    DS    A(SAVERRTN)             data addr for BRIF
PANEL    DS    C'ISRBROBF'             panel name
READRTNE DS    A(READDA00)             read routine
ISPLINK@ DS    V(ISPLINK)              ISPF interface
ISPEXEC@ DS    V(ISPEXEC)              ISPF interface
RBATABLE DS    A(0,0)                  RBA TABLE
HIGH_RRN DS    F                       RRN OF LAST RECORD
DYNANSWR DS    F                       LEN/ADDR OF BDAM BUFFER
ECB1     DS    F                       LEN/ADDR OF BDAM BUFFER
OWNCDE   DS    A(CDENTRY)              my own CDE
OWNNAME  DS    CL8                     my true name
SWITCH1  DS    B'00000000'             switches (1)
SW1CMD   EQU   B'10000000'             invoked as a command
SW1UVOL  EQU   B'01000000'             VOLSER given by user
SW1BRIF  EQU   B'00100000'             use BRIF, not standard BROWSE
VS_TYPE  DS    C'K'                    VSAM type: K E R
RECFM    DS    C'F'                    RECFM: F/V/U
OPENLIST OPEN  IFGACB,MF=L
         IFGACB DSECT=NO
RPL1     RPL   ACB=IFGACB,OPTCD=(KEY,SEQ,LOC)
RPL2     RPL   ACB=IFGACB,OPTCD=(ADR,DIR,LOC)
DCB1     DCB   DSORG=DA,MACRF=RIC,OPTCD=R,DDNAME=SYSUT1
DCBKEYLE EQU   DCB1+16,1,C'F'          key length
DCBREL   EQU   DCB1+17,3,C'F'          number of tracks in data set
DCBDSORG EQU   DCB1+26,2,C'X'          data set org
DCBDDNAM EQU   DCB1+40,8,C'C'          ddname
DCBDEBAD EQU   DCB1+44,4,C'A'          DEB pointer
DCBBLKSI EQU   DCB1+62,2,C'H'          BLKSIZE
DCBRECFM EQU   DCB1+36,1,C'X'          RECFM
DCBRECU  EQU   X'C0'
DCBRECF  EQU   X'80'
DCBRECV  EQU   X'40'
*
         IEZIOB DSECT=NO
CCW1     CCW   X'23',SECTORNO,CC,1     SET SECTOR
CCW2     CCW   X'31',IOBCC,CC,5        SEARCH ID EQUAL
CCW3     CCW   X'08',CCW2,0,1          TIC
CCW4     CCW   X'1E',BUFFER,SLI,8+256  READ KEY+DATA
CC       EQU   X'40'                   COMMAND CHAINING
SLI      EQU   X'20'                   SUPPRESS LENGTH ERROR
SECTORNO DS    FL1'0'                  Sector number for RPS devices
*
         DS    0F                      fix IHADVA bug #1
         IHADVA DSECT=NO               work area for DEVTYPE macro     X
                                       must be aligned on a FWD bdy
         ORG   ,                       fix IHADVA bug #2
RECAD    DS    A                       BLOCK NUMBER
LOWRBA   DS    F                       used for POINT and RRDS GET
TTTR     DS    F                       USED FOR BDAM
BLKPTRK  DS    F                       Number of blocks per track
MAXRECNO DS    F'12345678'          +0 MAX RECORD NUMBER
MAXLRECL DS    F'32760'             +4 MAX LRECL
ENDRBA   DS    F'32760'             +8 ENDRBA FOR RRDS
*
VS_LRECL DS    F'32760',F'0'           VSAM minimum, maximum
VS_RECNO DS    F'1'                    VSAM records actually read
*
S99RBPTR DS    A(S99RB+X'80000000')
S99RB    DS    A(X'14012000',0,S99TUPTR,0,0)
S99TUPTR DS    10A
S99T1    DS    X'0055,0001',AL2(L'DDNAME)   RETURN DDNAME
DDNAME   DS    CL8       '
S99T2    DS    X'0002,0001',AL2(L'DSNAME)   DSNAME
DSNAME   DS    CL44,C                       data set name
S99T3    DS    X'0003,0001',AL2(L'MEMBER)   MEMBER
MEMBER   DS    CL8                          member name
S99T57   DS    X'0057,0001',AL2(L'DSORG)    RETURN DSORG
DSORG    DS    X'0000'
S99T5D   DS    X'005D,0001',AL2(L'VOLSER)   RETURN VOLSER
VOLSER   DS    C'VOLSER'
*----------------------------------------------------------------------
BUFFER   DS    0D                      SPANNED RECORDS
         IECSDSL1 1                    F1-DSCB
QFLAG    DS    5X                      CCHHR
         AIF   (D'DS1SMSFG).SMS4
DS1SMSFG EQU   IECSDSL1+X'4A',1,C'X'   SMS flags
.SMS4    AIF   (D'DS1PDSE).SMS5
DS1PDSE  EQU   X'08'                   data set is a PDSE
.SMS5    ANOP
         AIF   (D'DS1STRP).SMS5B
DS1STRP  EQU   X'04'  .... .1..        EXTENDED FORMAT DATA SET
.SMS5B   ANOP
         AIF   (D'DS1PDSEX).SMS5C
DS1PDSEX EQU   X'02'  .... ..1.        HFS DATA SET
.SMS5C   ANOP
         AIF   (D'DS1DSAE).SMS5D
DS1DSAE  EQU   X'01'  ........1        EXTENDED ATTRIBUTES EXIST
.SMS5D   ANOP
FULLDSN  DS    CL56                    'data.set(member)'
MESSAGE  DS    CL256
SHORTMSG DS    CL32
TRNTBL   DS    CL256                   dsname scan
CLEARLEN EQU   *-DYNAM
         ORG   BUFFER+65536            buffer is 16 pages
DYNAML   EQU   *-DYNAM
*----------------------------------------------------------------------
         IKJCPPL                       Command Buffer Parm List
         IKJPPL                        Parse Parm List (IKJPARS)
         IKJECT                        Environment Control Table
         IKJUPT                        User Profile Table
IFGRPLVS OPSYN ANOP
         IFGRPL DSECT=YES
         IHACDE ,                      Contents Directory Entry
         YREGS
         STRING GENERATE
         END
//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB            DIV
//         DD DISP=SHR,DSN=SYS1.MODGEN            OBTAIN/IECSDSL1
//         DD DISP=SHR,DSN=GILBERT.FILE183.PDS    STRING
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//*-------------------------------------------------------------------
//LKED    EXEC PGM=HEWL,PARM='LIST,MAP,RENT'
//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)
//SYSLMOD  DD DISP=SHR,DSN=GILBERT.LOAD(BR)
//SYSPRINT DD SYSOUT=*
//*-------------------------------------------------------------------
//
