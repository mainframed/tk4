//GILBERTC JOB (ACCT#),CLEANUP,
//*RESTART=HMIG,
// NOTIFY=&SYSUID,
// CLASS=A,MSGCLASS=X,COND=(1,LT)
//ASMH EXEC PGM=ASMA90,PARM=(OBJECT,NODECK,NOESD,NORLD,NOXREF)
***********************************************************************
*                                                                     *
* MODULE NAME = CLEANUP                                               *
*                                                                     *
* DESCRIPTIVE NAME = Data Set Clean-up Utility                        *
*                                                                     *
* FUNCTION = The "CLEANUP" program deletes existing data sets         *
*            created and/or used in your job.  It has three modes     *
*            of operation:  Job restart, Job Clean-up, Never-open.    *
*                                                                     *
* STATUS = R405                                                       *
*                                                                     *
* AUTHOR = Gilbert Saint-flour <gsf@pobox.com>                        *
*                                                                     *
* NOTES = SEE BELOW                                                   *
*                                                                     *
*    DEPENDENCIES = MVS/XA, MVS/ESA, DFHSM                            *
*                                                                     *
*    AUTHORIZATION = NONE                                             *
*                                                                     *
*    RESTRICTIONS = NONE                                              *
*                                                                     *
* MODULE TYPE = PROCEDURE, (BATCH PROGRAM)                            *
*                                                                     *
*    PROCESSOR = IBM OS/ASSEMBLER H VERSION 2 OR                      *
*                IBM HIGH LEVEL ASSEMBLER/MVS                         *
*                                                                     *
*    MODULE SIZE = 4K                                                 *
*                                                                     *
*    ATTRIBUTES = REUSABLE, RMODE 24, AMODE 31,                       *
*                 PROBLEM STATE, KEY 8                                *
*                                                                     *
* OPERATION = See Below                                               *
*                                                                     *
*        1. Job restart                                               *
*                                                                     *
*            When executed at the beginning of the job you're         *
*            re-starting or re-running, CLEANUP deletes non-gdg       *
*            data sets that were created by a previous run of the     *
*            same job.  This prevents Job failures that would         *
*            result from "NOT CATLG 2" and IGD17001I messages.        *
*                                                                     *
*            Sample JCL :                                             *
*                                                                     *
*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *
*              //*                                                    *
*              //CLEANUP EXEC PGM=CLEANUP                             *
*              //*                                                    *
*              //STEP1   EXEC PROC=MYPROC, . . .                      *
*                                                                     *
*            Notes:                                                   *
*                                                                     *
*              o  no DD statements, control cards or PARM are         *
*                 necessary.  CLEANUP automatically retrieves data    *
*                 set names from in-storage images of the job's JCL.  *
*                                                                     *
*              o  CLEANUP may be executed more than once in a job.    *
*                 Each execution will consider data sets created      *
*                 in subsequent steps.                                *
*                                                                     *
*              o  If PARM=RECALL is specified, CLEANUP invokes        *
*                 the RECALL utility after it has completed its       *
*                 clean-up work.                                      *
*                                                                     *
*        2. Job clean-up                                              *
*                                                                     *
*            When executed as the very last step of a job,            *
*            CLEANUP deletes non-gdg data sets that were created      *
*            during the job's execution.                              *
*                                                                     *
*            Sample JCL :                                             *
*                                                                     *
*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *
*              //*                                                    *
*              //STEP1   EXEC PROC=MYPROC, . . .                      *
*              //*                                                    *
*              //CLEANUP EXEC PGM=CLEANUP                             *
*              //                                                     *
*                                                                     *
*        3. Never-OPEN                                                *
*                                                                     *
*            When executed with PARM=NEVEROPEN, CLEANUP deletes       *
*            data sets that have been allocated but have not been     *
*            opened for output by any program.  DD statements must    *
*            be explicitely specified in CLEANUP's step for the       *
*            data sets to delete.                                     *
*                                                                     *
*            Sample JCL :                                             *
*                                                                     *
*              //MYJOB   JOB (ACCT#),'JOHN DOE', . . .                *
*              //*                                                    *
*              //STEP1   EXEC PGM=MYPROG1, . . .                      *
*              //OUTDD    DD  DSN=SELDOM.OPEN1(+1),DISP=(,CATLG)      *
*              //*                                                    *
*              //STEP2   EXEC PGM=MYPROG2, . . .                      *
*              //OUTDD    DD  DSN=SELDOM.OPEN2,DISP=(,CATLG)          *
*              //*                                                    *
*              //CLEANUP EXEC PGM=CLEANUP,PARM=NEVEROPEN              *
*              //DD1      DD  DSN=SELDOM.OPEN1(+1),DISP=OLD           *
*              //DD2      DD  DSN=SELDOM.OPEN2,DISP=OLD               *
*                                                                     *
* Method of Operation (functions 1 & 2)                               *
*                                                                     *
*         o  CLEANUP scans the SWA control blocks of every step       *
*            of your job for non-GDG data sets that will be           *
*            (function 1) or have been (function 2) created           *
*            with DISP=(NEW,CATLG) or DISP=(MOD,CATLG).               *
*                                                                     *
*         o  Any of these data sets currently catalogued are          *
*            dynamically allocated and deleted.                       *
*                                                                     *
*         o  Data sets migrated by HSM are deleted                    *
*            with an HDELETE command.                                 *
*                                                                     *
* PARAMETERS = PARM=NEVEROPEN indicates that CLEANUP should only      *
*              delete those data sets that are allocated in its own   *
*              step and have a null BLKSIZE (i.e. have never been     *
*              OPEN'd for output).                                    *
*                                                                     *
*              PARM=RECALL indicates that CLEANUP should invoke       *
*              the RECALL utility at the end of its own processing.   *
*                                                                     *
* Return codes = See below                                            *
*                                                                     *
*            00     Normal end                                        *
*            16     Parm is invalid                                   *
*                                                                     *
* Messages = See below                                                *
*                                                                     *
*            PARM FIELD IS INVALID, when the PARM specifies           *
*              something other than NEVEROPEN.                        *
*                                                                     *
*            CLEANUP - data-set-name DELETED (volser)                 *
*              for each data set deleted                              *
*                                                                     *
*            CLEANUP - data-set-name DELETED (MIGRAT)                 *
*              for each migrated data set deleted with HDELETE        *
*                                                                     *
* Change Activity                                                     *
*                                                                     *
*04.02   XCTL to PGM=RECALL at EOJ if PARM=RECALL                     *
*04.03   IGNORE DISP=(MOD,DELETE) DATA SETS WITH PARM=NEVEROPEN       *
*04.04   Increase message length to 80 characters.                    *
*04.05   Pass PARM='' to RECALL program                               *
***********************************************************************
CLEANUP  CSECT
CLEANUP  AMODE 31                      SWAUP
CLEANUP  RMODE 24                      HDEL
         SAVE  (14,12),,'GSF UTILITIES - CLEANUP R405'
         BALR  R11,0
         USING *,R11
         GETMAIN R,LV=DYNAML
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LM    R13,R1,8(R13)
         USING DYNAM,R13
         L     R9,0(,R1)               SAVE THE PARM ADDR
*---------------------------------------------------------------------*
*                                                                     *
*        Set up SWA scan from first step after our own.               *
*                                                                     *
*        If we're the last step of the job, set up scan               *
*        from beginning of job.                                       *
*                                                                     *
*---------------------------------------------------------------------*
INIT50   L     R3,X'021C'              MY TCB (PSATOLD-PSA)
         L     R4,TCBJSCB-TCB(,R3)     MY JSCB
         USING IEZJSCB,R4
         L     R5,JSCSCT               CURRENT STEP'S SCT PREFIX
         USING SCT,R5
         MVI   MODE,C'F'               processing mode is "FIRST"
         ICM   R1,B'0111',SCTANSCT     last step of this job?
         BNZ   INIT59                  no, jump
         L     R1,JSCBJCT              yes, point to JCT
         ICM   R5,B'0111',JCTSDKAD-JCT(R1) SCT of first step to be run
         MVI   MODE,C'L'               processing mode is "LAST"
*
INIT59   SLR   R10,R10                 SET RC=00 (NOTHING DELETED)
         MVI   DO_RECALL,C'N'          No XCTL to PGM=RECALL at EOJ
*---------------------------------------------------------------------*
*                                                                     *
*        FIND RESTART STEP, IF SPECIFIED IN THE PARM                  *
*                                                                     *
*---------------------------------------------------------------------*
INIT60   LTR   R9,R9                   PARM FROM JCL OR CPPL
         BNM   LOOPSCT                 no parm or TMP-INVOKED
         CLI   1(R9),0                 PARM=""
         BE    LOOPSCT                 yes, jump
INIT63   CLI   1(R9),6                 PARM=RECALL   ?
         BNE   INIT64                  no, jump
         CLC   =C'RECALL',2(R9)        PARM=RECALL   ?
         BNE   BADPARM                 no, parm is invalid
         MVI   DO_RECALL,C'Y'          XCTL to PGM=RECALL at EOJ
         B     LOOPSCT
INIT64   CLI   1(R9),9                 PARM=NEVEROPEN?
         BNE   BADPARM                 no, parm is invalid
         CLC   =C'NEVEROPEN',2(R9)     PARM=NEVEROPEN?
         BNE   BADPARM                 no, parm is invalid
         MVI   MODE,C'O'               processing mode is "OPEN"
         L     R5,JSCSCT               CURRENT STEP'S SCT PREFIX
         B     LOOPSCT
*
BADPARM  WTO   'CLEANUP - Parm Field is invalid',ROUTCDE=(2,11)
         LA    R10,16                  RC=16
         B     GOBACK
***********************************************************************
*                                                                     *
*        SCAN SCT/SIOT CHAINS                                         *
*                                                                     *
*           1. SELECT NON-GDG DATA SETS THAT HAVE DISP=(NEW,CATLG)    *
*              OR DISP=(MOD,CATLG)                                    *
*                                                                     *
*           2. ALLOCATE SELECTED DATA SETS WITH DISP=(OLD,DELETE)     *
*                                                                     *
*           3. UNALLOCATE DATA SETS THAT WERE SUCCESSFULLY ALLOCATED  *
*              TO DELETE THEM                                         *
*                                                                     *
***********************************************************************
*LOOP
LOOPSCT  ICM   R1,B'0111',SCTFSIOT     SVA OF 1ST SIOT
         BZ    NEXTSTEP                NO DD STATEMENTS, TRY NEXT SCT
*--LOOP
LOOPSIOT BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS
         LR    R6,R1                   PASS SIOT ADDRESS
         USING INDMSIOT,R6
         ICM   R1,B'0111',SCTPJFCB     SVA OF JFCB
         BAL   R9,SWAREQ               CONVERT SVA TO 31-BIT ADDRESS
         LR    R7,R1                   LOAD JFCB ADDRESS
         USING INFMJFCB,R7
*
*        Set-up message
*
SETUPMSG MVC   DSNAME,JFCBDSNM         MOVE DSN TO UNPROTECTED STORAGE
         MVC   WTO1TEXT,WTO1TEXT-1     clear work area
         MVC   WTO1TEXT(L'DSNAME),DSNAME  move dsname
         LA    R2,WTO1TEXT             start of dsname
         LA    R2,1(,R2)             - BUMP POINTER
         CLI   0(R2),C' '            - END OF MSG?
         BNE   *-8                   - NOT YET, TRY NEXT CHARACTER
         MVC   1(7,R2),=C'deleted'     action taken
         CLI   MODE,C'O'               PARM=NEVEROPEN?
         BE    NO_OPEN                 yes, bypass filters
*
*        Filter data sets: DISP=(,CATLG),DSN=A.B.C(+1)
*
FILTER   TM    SCTSDISP,SIOTCTLG       DISP=(,CATLG) ?
         BNO   NEXTSIOT                NO, JUMP
         TM    SCTSBYT3,SCTSNEW+SCTSMOD   DISP=NEW/MOD ?
         BZ    NEXTSIOT                NO, JUMP
         TM    JFCBIND1,JFCGDG         CHECK FOR (+1)
         BO    NEXTSIOT                JUMP, THIS IS A GDG
         CLI   MODE,C'L'               MODE=LAST?
         BE    ALLOC                   yes, bypass catalog search
*
*        Look-up data set name in the catalog
*
LOCATE   LM    R14,R1,CAMLST26         MODEL CAMLST
         SLR   R0,R0                   no CVOL ptr
         LA    R1,WORK265              WORK AREA
         STM   R14,R1,CAMLST2          UPDATE CAMLST IN DYNAMIC STRGE
         LOCATE CAMLST2                GET VOLSER
         LTR   R15,R15                 IS IT CATALOGED?
         BNZ   NEXTSIOT                NO, IGNORE
         MVI   09(R2),C'('             surround volser with parentheses
         MVC   10(6,R2),WORK265+6      yes, move volser
         MVI   16(R2),C')'             surround volser with parentheses
*
*        If the data set has been migrated by HSM,
*        issue an HDELETE command.
*
HDELETE  CLC   =C'MIGRAT',WORK265+6    cataloged on MIGRAT ?
         BNE   ALLOC                   no, jump
         ARCHDEL DSN=DSNAME,WKAREA=WORK265,WAIT=YES
         LTR   R15,R15                 HDELETE OK?
         BNZ   ALLOC                   no, jump
         B     WTO1                    yes, issue WTO
*
*        PARM=NEVEROPEN
*
NO_OPEN  TM    SCTSDISP,SIOTDLET       DISP=(,DELETE)?
         BO    NEXTSIOT                YES, JUMP
         LM    R14,R1,CAMLST28         MODEL CAMLST
         LA    R0,JFCBVOLS             volser
         LA    R1,DS1FMTID             WORK AREA
         STM   R14,R1,CAMLST2          UPDATE CAMLST IN DYNAMIC STRGE
         OBTAIN CAMLST2                GET F1-DSCB
         LTR   R15,R15                 found on disk?
         BNZ   NEXTSIOT                NO, IGNORE
         OC    DS1BLKL,DS1BLKL         BLKSIZE=0?
         BNZ   NEXTSIOT                NO, IGNORE
         MVC   09(12,R2),=C'(Never OPEN)'
*
*        ALLOCATE
*
ALLOC    MVI   S99RB+1,1               FUNCTION=ALLOC
         NI    S99TUPTR,255-X'80'      USE ALL OF THE KEYS
         LA    1,=A(S99RB+VL)          SVC99 REQUEST BLOCK
         SVC   99                      ALLOCATE THE DATA SET
         LTR   R15,R15                 ALLOC OK?
         BNZ   NEXTSIOT                NO, JUMP
*
*        UNALLOCATE
*
         MVI   S99RB+1,2               FUNCTION=UNALLOC
         OI    S99TUPTR,X'80'          KEEP ONLY THE DDNAME KEY
         LA    1,=A(S99RB+VL)          SVC99 REQUEST BLOCK
         SVC   99                      ALLOCATE THE DATA SET
*
&STR     SETC  (80)' '
WTO1     WTO   'CLEANUP - &STR',ROUTCDE=11
WTO1TEXT EQU   WTO1+18,80
*
NEXTSIOT ICM   R1,B'0111',SCTPSIOT     NEXT SIOT'S PREFIX
         BNZ   LOOPSIOT                PROCESS NEXT DD CARD IN STEP
*--ENDLOOP
NEXTSTEP CLI   MODE,C'O'               PARM=NEVEROPEN?
         BE    GOBACK                  yes, we're done
         ICM   R5,B'0111',SCTANSCT     NEXT SCT PREFIX
         BNZ   LOOPSCT                 PROCESS NEXT STEP
*ENDLOOP
         DROP  R5,R6,R7                SCT, SIOT, JFCB
*
GOBACK   CLI   DO_RECALL,C'Y'          PARM=RECALL ?
         BE    XCTLRCAL                yes, jump
         L     R13,4(,R13)             CALLER'S SAVE AREA
         LR    R15,R10                 RETURN CODE
         RETURN (14,12),RC=(15)
*
XCTLRCAL L     R13,4(,R13)             CALLER'S SAVE AREA
         L     R1,24(,R13)             R1=parm_addr
         L     R14,0(,R1)              R14=>AL2(L'PARM)
         MVI   1(R14),0                L'PARM=0
         XCTL  (2,12),EP=RECALL        invoke RECALL program
*---------------------------------------------------------------------*
*                                                                     *
*        SUB-ROUTINE USED TO ACCESS THE SWA MANAGER                   *
*                                                                     *
*---------------------------------------------------------------------*
SWAREQ   LA    R2,DSNAME               WORK AREA
         ST    R2,EPAPTR               STORE POINTER
         USING ZB505,R2
         XC    SWAEPAX,SWAEPAX         CLEAR 32 BYTES
         STCM  R1,B'0111',SWVA         STORE 3-BYTE SVA
         SWAREQ FCODE=RL,EPA=EPAPTR,MF=(E,SWAREQL1),UNAUTH=YES
         L     R1,SWBLKPTR             LOAD SWA CONTROL BLOCK ADDRESS
         BR    R9
         DROP  R2                      ZB505
*---------------------------------------------------------------------*
*                                                                     *
*        DATA, WORK AREAS                                             *
*                                                                     *
*---------------------------------------------------------------------*
VL       EQU   X'80000000'
S99RB    DC    A(X'14010000',0,S99TUPTR,0,0)
S99TUPTR DC    A(S99TU01,S99TU02,S99TU04,S99TU05,S99TU6C+VL)
S99TU01  DC    AL2(X'01',1,L'DDNAME)   DDNAME KEY
DDNAME   DC    C'$CLEANUP'
S99TU02  DC    AL2(X'02',1,L'DSNAME)   DSNAME KEY
DSNAME   DS    CL44
S99TU04  DC    AL2(X'04',1,1),X'01'    STATUS=OLD
S99TU05  DC    AL2(X'05',1,1),X'04'    DISP=DELETE
S99TU6C  DC    AL2(X'6C',0)            UNIT=(,,DEFER)
CAMLST26 CAMLST NAME,DSNAME,,*-*       CAMLST FOR LOCATE MACRO
CAMLST28 CAMLST SEARCH,DSNAME,*-*,*-*  CAMLST FOR OBTAIN MACRO
*---------------------------------------------------------------------*
*                                                                     *
*        Dynamic storage                                              *
*                                                                     *
*---------------------------------------------------------------------*
DYNAM    DSECT
         DS    18F
MODE     DS    C'F'                    FIRST/LAST/OPEN
DO_RECALL DS   C'N'                    PARM=RECALL
CAMLST2  CAMLST NAME,DSNAME,,WORK265   CAMLST FOR LOCATE MACRO
SWAREQL1 SWAREQ MF=L                   PARM LIST FOR SWAREQ
EPAPTR   DS    F                       POINTER TO EPA (ZB505)
WORK265  DS    CL265                   LOCATE macro
         IECSDSL1 1                    F1-DSCB
         DS    5X                      CCHHR
DYNAML   EQU   *-DYNAM
*---------------------------------------------------------------------*
*                                                                     *
*        DSECTS FOR VARIOUS MVS CONTROL BLOCKS                        *
*                                                                     *
*---------------------------------------------------------------------*
         PRINT NOGEN
PRINT    OPSYN ANOP
         IKJTCB LIST=NO                SYS1.MODGEN
         IEZJSCB ,                     SYS1.MODGEN
JCT      DSECT                         Job Control Table
         DS    4F                      Prefix
         IEFAJCTB ,                    SYS1.MODGEN
SCT      DSECT                         Step Control Table
         DS    4F                      Prefix
         IEFASCTB ,                    SYS1.MODGEN
SIOT     DSECT                         Step I/O Table
         DS    4F                      Prefix
         IEFASIOT ,                    SYS1.MODGEN
JFCB     DSECT                         Job File Control Block
         DS    4F                      Prefix
         IEFJFCBN ,                    SYS1.MODGEN
         CVT   LIST=NO,DSECT=YES       COMMUNICATION VECTOR TABLE
         IEFJESCT TYPE=DSECT           JES CONTROL TABLE
         IEFZB505 LOCEPAX=YES          EPA MAPPING FOR SWAREQ
         YREGS                         SYS1.MACLIB
         END
//SYSLIB   DD DISP=SHR,DSN=SYS1.MODGEN
//         DD DISP=SHR,DSN=SYS1.MACLIB
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,4)
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//*
//LKED    EXEC PGM=IEWL,PARM=(MAP,REUS)
//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,PASS)
//SYSLMOD  DD DISP=SHR,DSN=GILBERT.LOAD(CLEANUP)
//SYSPRINT DD SYSOUT=*
//*
//NEVROPEN EXEC PGM=CLEANUP,PARM=NEVEROPEN
//STEPLIB  DD DISP=SHR,DSN=GILBERT.LOAD(CLEANUP)
//NODSORG  DD DISP=(NEW,CATLG),DSN=GILBERT.CLEANUP2,
// UNIT=VIO,SPACE=(TRK,1)
//*SORGPS  DD DISP=(NEW,CATLG),DSN=GILBERT.CLEANUP,
//*UNIT=VIO,SPACE=(TRK,1),DSORG=PS
//SYSDEBUG DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//*
//GO      EXEC PGM=CLEANUP
//STEPLIB  DD DISP=SHR,DSN=GILBERT.LOAD(CLEANUP)
//SYSDEBUG DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*
//*
//STEP1   EXEC PGM=IEFBR14
//TAPEOUT  DD DISP=(NEW,CATLG),DSN=GILBERT.CLEANUP,
// UNIT=VIO,SPACE=(TRK,1)
//*TEP2   EXEC PGM=IEFBR14
//*APEOUT  DD DISP=(OLD,DELETE),DSN=GILBERT.CLEANUP
//*
//HMIG    EXEC PGM=IKJEFT01
//SYSTSPRT DD SYSOUT=*
//SYSTSIN  DD *
HMIG 'IBMUSER.CLEANUP' WAIT
//*
//*ASTGO  EXEC PGM=CLEANUP
