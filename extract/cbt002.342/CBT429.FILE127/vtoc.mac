VTOCCMD  TITLE 'VTOC COMMAND - LIST DATA SETS AND ATTRIBUTES'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
* FUNCTION -   PROVIDE THE ABILITY FOR A TSO USER OR A BATCH JOB      *
*              TO LIST THE CONTENTS OF VARIOUS VOLUMES, WITH A        *
*              FAIR AMOUNT OF SELECTION.                              *
*                                                                     *
*                                                                     *
* OPERATION -  ACCEPT FROM THE TSO USER OR BATCH JOB A COMMAND        *
*              WITH THE FOLLOWING SYNTAX.  THEN CHECK THE COMMAND     *
*              AND LOOP THROUGH, GETTING A DSCB, FORMATTING IT,       *
*              PERFORMING THE DATA SET NAME AND LIMIT CHECKS, AND     *
*              CALLING AN EXIT ROUTINE IF DESIRED, THEN PUT THE       *
*              ENTRY IN THE CORRECT SORT SEQUENCE.                    *
*              FINALLY CALL THE PRINT ROUTINE TO PRINT THE            *
*              SPECIFIED ITEMS, HEADERS, AND BREAKS, OR JUST          *
*              THE TOTALS.                                            *
*                                                                     *
*                                                                     *
* INPUT -      STANDARD COMMAND PROCESSOR PARAMETER LIST              *
*              POINTED TO BY REGISTER 1                               *
*                                                                     *
*                                                                     *
* OUTPUT -     TO SYSOUT, A LIST OF THE REQUESTED DATA SETS AND       *
*              THEIR ATTRIBUTES.                                      *
*                                                                     *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*              FIREMAN'S FUND INSURANCE  CPSD 2N                      *
*              ONE LUCAS GREEN                                        *
*              SAN RAFAEL, CA  94911                                  *
*              ADDED ICF (123 EXTENT SUPPORT) CLARK            25JUN84
*                                                                     *
*                                                                     *
***********************************************************************
*
         MACRO
&LABEL   VTOCEXCP  &FUNC
         AIF   ('&FUNC' NE 'EQ').CALL
VTCOPEN  EQU   1              DEFINE FUNCTION CODES FOR VTOCEXCP
VTCCLOSE EQU   2
VTCREAD  EQU   0
         MEXIT
.CALL    ANOP                 CALL VTOCEXCP
&LABEL   MVI   VTCEFUNC,VTC&FUNC   SET THE FUNCTION CODE
         VTCALL EXCP          GO GET A DSCB
         MEND
*
*        MACRO FOR INITIALIZING SUBROUTINE WORK AREA ADDRESSES
*
         MACRO
&LABEL   WORKADDR &RTN,&PRMADDR
&LABEL   L     R1,=A(WORK&RTN-WORKAREA)  GET THE OFFSET ( OVER 4K )
         LA    R1,0(R1,R13)   RELOCATE IT
         ST    R1,&PRMADDR   THEN STORE IT FOR THE ROUTINES
         MEND
*
         EJECT
VTOCCMD  ENTERX 12,(1,LENWORK,C)     DO THE HOUSEKEEPING
         LR    R2,R1          SAVE ADDR OF CPPL
         SPACE
         USING WORKAREA,WORKREG
         EJECT
         BAL   R14,PARSINIT   PERFORM THE PARSING
         LTR   R15,R15        TEST THE RETURN CODE
         BNZ   RETURN         BAD NEWS, GET OUT
         VTCALL PRNT         INITIALIZE FOR PRINTING
         L     R9,ADDRANSR    ADDR OF PARSE DESCRIPTOR LIST
         USING PDL,R9         RETURNED BY PARSE
*
*
*        SCAN SORT PARSE LIST AND BUILD SORT FIELD TABLE
*
*
SORTPAR  LA    R4,SUBSORT     SORT PARSE LIST
         LA    R5,SORTTAB     SORT FIELD TABLE
         XC    0(64,R5),0(R5) CLEAR SORT FIELD TABLE
         MVC   0(4,R5),SORTTABX DEFAULT TO DSNAME
         SPACE 1
SORTPAR1 LA    R1,SORTTABX-12 SORT COMPARE TABLE
         SPACE 1
SORTPAR2 LA    R1,12(0,R1)    POINT TO NEXT COMPARE ENTRY
         CLC   0(4,R1),=F'0'  END OF TABLE
         BE    SORTPAR3       ITEM NOT FOUND, IGNORE
         L     R6,0(0,R4)     POINT TO TEXT
         LH    R3,4(0,R4)     TEXT LENGTH
         LTR   R3,R3          IGNORE IF ZERO
         BZ    SORTPAR3
         BCTR  R3,0
         EX    R3,SORTCOMP    FIELD NAME MATCH
         BE    SORTPAR4       YES
         B     SORTPAR2       NO, TRY NEXT
         SPACE 1
SORTPAR3 ICM   R4,7,9(R4)     NEXT ITEM
         BNZ   SORTPAR1       CONTINUE IF MORE
         B     SORTPAR5
         SPACE 1
SORTPAR4 MVC   0(4,R5),0(R1)  SET UP SORT FIELD
         ICM   R4,7,9(R4)     ASCENDING/DESCENDING INDICATOR
         BZ    PARMERR        ERROR IF MISSING
         L     R6,0(0,R4)     INDICATOR ADDR
         CLC   4(2,R4),=F'0'  ERROR IF MISSING
         BE    PARMERR
         MVC   0(1,R5),0(R6)  A/D INDICATOR
         LA    R5,4(0,R5)
         CLI   0(R6),C'A'     ASCENDING SORT
         BE    SORTPAR3       YES, OK
         CLI   0(R6),C'D'     DESCENDING SORT
         BNE   PARMERR        NO, ERROR
         B     SORTPAR3       CHECK IF ANY MORE
         SPACE 1
SORTCOMP CLC   4(0,R1),0(R6)
         SPACE 1
SORTPAR5 LA    R3,SORTKTAB-12 SORT HEADER INDEX TABLE
SORTK1   LA    R3,12(0,R3)    NEXT ENTRY
         CLC   0(4,R3),=F'0'  END OF TABLE
         BE    SORTK3         YES
         CLC   SORTTAB+1(1),1(R3)  ENTRY MATCH
         BNE   SORTK1         NO, CHECK NEXT
         SR    R4,R4
         LH    R5,2(0,R3)     LOAD TABLE LENGTH
         D     R4,=F'12'      TABLE ENTRIES
         LA    R5,1(0,R5)
         LA    R6,VTCSORTH
         L     R4,4(0,R3)     LOAD TABLE BEGIN ADDR
         CLI   SORTTAB,C'D'   DESCENDING SORT
         BE    SORTK2         YES
         L     R4,8(0,R3)     LOAD TABLE END ADDR
SORTK2   MVC   0(12,R6),0(R4)
         LA    R4,12(0,R4)
         LA    R6,12(0,R6)
         CLI   SORTTAB,C'D'   DESCENDING SORT
         BE    *+8            YES
         S     R4,=F'24'
         BCT   R5,SORTK2
         B     SORTK4
SORTK3   MVC   VTCSORTH(12),=3F'0'
SORTK4   MVC   0(12,R6),=3F'0'
*
*        CHECK THROUGH THE UCB'S TO SELECT THE VOLUMES TO PROCESS
*
*
**  FIND A VOLUME SERIAL NUMBER
*
         LA    R3,VOLS        POINT TO THE PDL
LOOP1    L     R5,0(R3)       GET THE ADDRESS OF THE TEXT
         LH    R4,4(R3)       ALSO GET ITS LENGTH
         LTR   R4,R4          FOR EXECUTES, GET THE LENGTH
         BZ    PHASE2         NO MORE VOLUMES, CONTINUE TO NEXT PHASE
         BCTR  R4,0           MAKE IT READY FOR THE EX INSTR
         MVC   VOLSER,BLANKS   INITIALIZE FIELD
         EX    R4,MOVVOL
*
**  VOLUME FOUND - VERIFY AND CHECK FOR GLOBAL OR SPECIAL REQUESTS
*
         CH    R4,H5          IS THE ENTIRE NAME THERE?
         BE    VOLSET         YES, IT'S A SPECIFIC VOLUME
         MVI   FLAG,X'01'     IT'S A GENERIC REQUEST
         CH    R4,H2          CHECK FOR THE ALL KEYWORD, FIRST LENGTH
         BNE   VOLSET         NOT A GLOBAL REQUEST
         CLC   0(3,R5),CHARALV  IS THIS THE KEYWORD 'ALLV'?
         BE    VOLSETV        NO, NOT A GLOBAL REQUEST
         CLC   0(3,R5),CHARALL  IS THIS THE KEYWORD 'ALL'?
         BNE   VOLSET         NO, NOT A GLOBAL REQUEST
SETGLOB  DS    0H
         MVI   FLAG,X'02'   GLOBAL REQUEST
         B     VOLSET
*
**  FIND THE A(UCB)
*
VOLSETV  MVI   FLAG,X'82'   GLOBAL REQUEST FOR VIRTUAL
LOCUCB   DS    0H  -----------------FORMAT IOS SCAN PARM LIST
VOLSET   DS    0H
         XC    DSXAWORK,DSXAWORK       ZERO OUT UCB WORKAREA
         LA    R1,DSXAWORK             ADDR OF UCB WORKAREA
         ST    R1,DSXAWA               STORE IT IN PARM LIST
         LA    R1,DSXACLAS             PTR TO DEV CLAS TO SEARCH
         ST    R1,DSXADEVT             STORE IN PARM LIST
         MVI   DSXACLAS,UCB3DACC       ONLY SEARCH DASD
         LA    R1,DSXAUCBP             AREA TO STORE UCB ADDR
         ST    R1,DSXAUCB              IN PARM LIST
         OI    DSXAUCB,X'80'           SIGNIFY END OF PARMLIST
LOCUCB1  DS    0H  -----------------SCAN FOR A UCB---------
NEXTUCB  DS    0H  -----------------SCAN FOR A UCB---------
         L     R15,CVTPTR
         ICM   R15,15,X'434'(R15)      CVTUCBSC VALID?(IOSVSUCB)
         BZ    LOCUCBE0                ZERO=OLD MVS
***>>>>>>----UCB SCAN SERVICE FOR MVS/SP1.2 AND ABOVE:-----<<<<<<***
** PARM:(100BYTE-WORK,1BYTE-DEV-CLASS,1WORD-UCB-PTR)              **
**RETURN CODES: R15 = 00-UCB RETURNED; 04-NO MORE UCBS            **
         LA    R1,DSXALIST             PTR TO PARM LIST
         BALR  R14,R15                 BRANCH TO IT
         B     LOCUCBXX                COMMON ENTRY POINT
***>>>>>>----- EMULATION UCB SCAN SERVICE FOR OLD MVS------<<<<<<***
LOCUCBE0 DS    0H
         ICM   R14,B'1111',DSXAEUCB    BR IF THIS IS
         BNZ   LOCUCBE1                SECOND OR LATER CALL
         L     R14,CVTPTR              ADDR-UCB VECTOR TABLE
         L     R14,X'24'(R14) CVTILK2-CVT(R14) ADDR-UCB VECTOR TABLE
         ST    R14,DSXAEILK            SAVE(TO CHECK FOR DUPS)
LOCUCBE1 DS    0H
         SR    R1,R1                   ZERO UCB ADDR PTR
LOCUCBE3 DS    0H
         LA    R14,2(,R14)             NEXT PTR(1ST UCB SKIPPED)
         ICM   R1,B'0011',0(R14)       ADDR OF UCB
         BZ    LOCUCBE3                BR IF NULL ENTRY
         LA    R15,4                   SHOW NO HITS (CC UNCHANGED)
         BO    LOCUCBEX                BR IF END
         LA    R15,0                   SHOW HITS (CC UNCHANGED)
LOCUCBE5 DS    0H
         CLC   DSXACLAS,UCBTBYT3-UCBCMSEG(R1) BR IF THIS UCB
         BNE   LOCUCBE3                IS NOT DESIRED CLASS
         ST    R1,DSXAUCB              PROVIDE ADDR OF UCB
         ST    R14,DSXAEUCB            REMEMBER WHERE TO RESUME
***>>>>> CHECK FOR DUPLICATE CHANNEL PATH
         L     R14,DSXAEILK            ADDR OF FIRST UCB PTR
LOCUCBE7 DS    0H
         CL    R14,DSXAEUCB            EXIT IF NO DUPLICATE
         BE    LOCUCBEX                CHANNEL PATH FOUND(R15=0)
         LA    R14,2(,R14)             ADDR OF NEXT PTR
         CLC   0(2,R14),DSXAUCB+2      CONTINUE LOOP IF THIS IS NOT
         BNE   LOCUCBE7                DUPLICATE CHANNEL PATH
         L     R14,DSXAEUCB            SETUP TO RESUME SCAN
         B     LOCUCBE3                AND GO RE-ENTER LOOP
LOCUCBEX DS    0H
***>>>>>>       UCB SCAN ROUTINE - COMMON RETURN POINT     <<<<<<***
LOCUCBXX LTR   R15,R15                 GOT ONE?
         BNZ   NOTMNT                  NO
         L     R6,DSXAUCBP GET ADR OF  UCB FROM PTR
         TM    FLAG,X'02'   CHECK FOR GLOBAL
         BO    FNDGBL   IT IS
         TM    FLAG,X'01'   CHECK FOR SPECIAL REQUESTS
         BO    SPECUCB   IT IS
         CLC   VOLSER,28(R6)   COMPARE FULL VOLSER
         BE    FNDUCB   FOUND IT
         B     INCR1
SPECUCB  DS    0H
         CLC   CHARALX,VOLSER          ALLX                    25JUN84
         BNE   CHKVOL                  NO-COMPARE FIRST X CHAR 25JUN84
         CLI   28(R6),C'X'             X VOLSERS?              25JUN84
         BE    INCR1                   YES-SKIP IT             25JUN84
         B     CHKRDY                  NO-HIT                  25JUN84
CHKVOL   DS    0H
         EX    R4,CLCVOL   COMPARE FIRST X CHARACTERS ONLY
         BE    CHKRDY
INCR1    DS    0H
         B     NEXTUCB   TRY NEXT UCB
*
*        VARIOUS ERRORS, LET THE PERSON KNOW
*
NOTMNT   TM    FLAG,X'04'     WAS A VOLUME  FOUND?
         BO    NEXTVOL        YES, LOOK FOR THE NEXT SPEC
         MVC   MSGTEXT2,MSGNOTMT  NO, GET THE ERROR MESSAGE
SETVOL   MVC   MSGTEXT2+5(6),VOLSER ADD THE VOLUME SERIAL NUMBER
         VTOCMSG MSGTEXT2     AND ISSUE THE MESSAGE
         B     NEXTVOL       GO GET THE NEXT VOLUME FROM PARSE
PENDING  MVC   MSGTEXT2,MSGPEND   SET UP THE MESSAGE
*
*        SEE IF THIS IS A GENERIC OR GLOBAL REQUEST
*
         TM    FLAG,X'03'    WAS IT ALL OR A PARTIAL VOLUME SERIAL?
         BNZ   INCR1         IN EITHER CASE, SKIP THE MESSAGE
*                            THEN FIND MORE VOLUMES
*
*        OUTPUT THE OFFLINE PENDING MESSAGE
         B     SETVOL         THEN ADD THE VOLUME
OFFLINE  MVC   MSGTEXT2,MSGOFFLN SET UP THE MESSAGE
         B     SETVOL         THEN ADD THE VOLUME
*
**  FOR GLOBAL REQUESTS JUST LIST ONLINE PACKS
*
FNDGBL   TM    3(R6),X'80'   ONLINE BIT
         BZ    INCR1   NOPE
*
**  FOR GLOBAL AND SPECIAL REQUESTS, CHECK FOR DEVICE READY
*
CHKRDY   TM    6(R6),X'40'   TEST READY BIT
         BO    INCR1   NOT READY
         TM    FLAG,X'80'   GLOBAL REQUEST FOR VIRTUAL
         BO    CHKVIRT
         TM    FLAG,X'02'   GLOBAL REQUEST
         BZ    FNDUCB
         TM    17(R6),X'08'  VIRTUAL UCB
         BO    INCR1   YES
         B     FNDUCB
CHKVIRT  TM    17(R6),X'08'  VIRTUAL UCB
         BZ    INCR1   NO
*
**  MOVE UCB INFORMATION TO OUTPUT LINE
*
FNDUCB   MVC   VOLID,28(R6)   MOVE VOLID
         MVC   ADDR,13(R6)   MOVE UNIT ADDRESS
         OI    FLAG,X'04'      NOTE THE VOLUME AS FOUND
*
**  IF OFFLINE, DO NOT PROCESS
*
         TM    3(R6),X'40'   PENDING BIT - SHOULD BE OFF
         BO    PENDING
         TM    3(R6),X'80'   ONLINE BIT - SHOULD BE ON
         BZ    OFFLINE
*
*        NOW GET DSCB'S FROM THE VOLUME
*
*
*        SET UP THE PARM LIST FOR VTOCEXCP
*
         VTOCEXCP OPEN        OPEN THE VTOC
         LTR   R15,R15        DID IT OPEN OK?
         BNE   RETURN         NO, JUST EXIT
READDSCB CLI   TABFULL,0     CHECK FOR FULL TABLES
         BNE   ENDVTOC       IF FULL, TRY END OF VTOC TO CLEAR
         VTOCEXCP READ        GET A DSCB
         CH    R15,H4         CHECK THE RETURN CODE
         BE    ENDVTOC        END OF VTOC
         BH    RETURN         BAD ERROR, VTOCEXCP GAVE THE MESSAGE
*
*        CHECK THE DATA SET QUALIFICATIONS, LIMIT, AND, OR
*
         VTCALL CHEK          CALL THE CHECK ROUTINE
         LTR   R15,R15        DOES THIS DATA SET GET PASSED ON?
         BNZ   READDSCB       NO, GET ANOTHER
*                             YES, CONTINUE PROCESSING
*
*        FORMAT THE DSCB INFORMATION
*
         TM    VTCFMTCK,VTCFMTCD WAS FORMAT CALLED BY CHECK?
         BO    CALLEXIT       YES, DON'T CALL IT AGAIN
         VTCALL FORM          CALL THE FORMATTING ROUTINE
         LTR   R15,R15        DID IT FUNCTION?
         BNZ   READDSCB       NO, GET ANOTHER DSCB
*
*        CALL THE EXIT ROUTINE IF ONE WAS SPECIFIED
*
CALLEXIT VTCALL EXIT,TEST     CALL THE EXIT ROUTINE
         LTR   R15,R15        SHOULD THE DATA SET BE PASSED ON?
         BNZ   READDSCB       NO, GET ANOTHER DSCB
*
*        SORT THE ENTRIES INTO THE NEW LIST
*
         VTCALL SORT          CALL THE SORT ROUTINE
         B     READDSCB       GET ANOTHER DSCB
*
*        END OF THE VOLUME, CHECK FOR MORE
*
ENDVTOC  VTOCEXCP CLOSE FIRST CLOSE THE VTOC
*
ENDVOL   TM    FLAG,X'03'         IS THIS A GENERIC VOLUME SEARCH
         BNZ   INCR1              YES, SEARCH FOR MORE
NEXTVOL  ICM   R3,B'0111',25(R3)  GET THE NEXT VOLUME FROM THE PDL
         BP    LOOP1              THERE IS ANOTHER, GET IT
*
*        PRINT THE SELECTED ITEMS FOR THE SELECTED DATA SETS
*
PHASE2   DS    0H
         VTCALL PRNT          CALL THE PRINT ROUTINE
         B     EXIT0
         EJECT
*
*        PROCESSING IS COMPLETE, EXEUNT
*
PARMERR  LA    R15,16
         B     RETURN
EXIT0    SR    R15,R15
         SPACE 3
RETURN   LTR   R2,R15         NORMAL EXIT?
         BZ    RETURN1        YES, LEAVE EVERY THING ALONE
         SPACE 2
         LA    R1,PARMLIST    AREA FOR STACK PARM LIST
         USING IOPL,R1        AN ERROR WAS FOUND, FLUSH THE STACK
         SPACE
         MVC   IOPLUPT,ADDRUPT
         MVC   IOPLECT,ADDRECT
         LA    R0,ATTNECB
         MVI   ATTNECB,0
         ST    R0,IOPLECB
         SPACE 2
         STACK PARM=PARMLIST+16,DELETE=ALL,MF=(E,(1))
         SPACE 3
         TCLEARQ INPUT        CLEAR INPUT BUFFERS
         SPACE 3
RETURN1  DS    0H
         BAL   R14,FREEPDL    FREE THE PARSE STROAGE
         MVI   VTCEPRNT,15    TELL PRINT TO CLEAN UP HIS ACT
*                                CLOSE DATA SETS AND FREE MAIN STORAGE
         VTCALL PRNT          CALL THE PRINT ROUTINE
         SPACE
         LR    R15,R2          GET THE RETURN CODE AGAIN
         LEAVE EQ
WORKREG  EQU   13
*
*        PARSE INITIALIZATION
*
         SPACE 3
PARSINIT DS    0H
         ST    R2,CPPLADDR    AND THE CPPL ADDRESS
         USING CPPL,R2        BASE FOR COMMAND PARM LIST
         MVC   ADDRUPT,CPPLUPT ADDR OF USER PROFILE TABLE
         MVC   ADDRPSCB,CPPLPSCB
         MVC   ADDRECT,CPPLECT ADDR OF ENVIROMENT TABLE
         MVC   ADDRCBUF,CPPLCBUF
         DROP  R2
         SPACE 3
*
*        PUT THE WORK AREA ADDRESSES INTO THE PARM LISTS
*
         WORKADDR MSG,VTCWMSG     WORK AREA FOR VTOCMSG
         WORKADDR EXCP,VTCWEXCP   WORK AREA FOR VTOCEXCP
         WORKADDR CHEK,VTCWCHEK   WORK AREA FOR VTOCCHEK
         WORKADDR FORM,VTCWFORM   WORK AREA FOR VTOCFORM
         WORKADDR EXIT,VTCWEXIT   WORK AREA FOR VTOCEXIT
         WORKADDR SORT,VTCWSORT   WORK AREA FOR VTOCSORT
         WORKADDR PRNT,VTCWPRNT   WORK AREA FOR VTOCPRNT
         SPACE 3
*        SET UP THE ADDRESSES FOR CALLING
*
         MVC   VADMSG(RTNADLEN),RTNADDRS  MOVE IN THE ADDRESSES
*
*
*
*        BUILD PARSE PARAMETER LIST AND INVOKE
*        IKJPARS TO ANALYZE COMMAND OPERANDS
*
         SPACE 3
GOPARSE  DS    0H
         ST    R14,R14PARSE   SAVE THE RETURN ADDRESS
         LA    R1,PARSELST    AREA FOR PARSE PARAMETERS
         USING PPL,R1         BASE FOR PARSE PARAMETER LIST
         SPACE 2
         MVC   PPLUPT,ADDRUPT PASS UPT ADDRESS
         MVC   PPLECT,ADDRECT AND ECT ADDRESS
         MVC   PPLCBUF,ADDRCBUF AND COMMAND BUFFER ADDR
         SPACE
         ST    WORKREG,PPLUWA ALSO WORK AREA ADDR FOR VALIDITY EXITS
         SPACE
         LA    R0,ATTNECB     ECB FOR ATTN INTERRUPTS
         MVI   ATTNECB,0      CLEAR ECB
         ST    R0,PPLECB      PASSE TO PARSE
         SPACE
         LA    R0,ADDRANSR    PASS ADDR OF WORD WHERE PARSE
         ST    R0,PPLANS      RETURNS PDL ADDRESS
         SPACE
         MVC   PPLPCL,ADDRPCL STORE PCL ADDRESS
         SPACE 3
         CALLTSSR EP=IKJPARS  INVOKE PARSE
         DROP  R1
         SPACE 2
         LA    R14,MAXPARSE   RETURN CODE LIMIT
         SPACE
         CR    R15,R14        VERIFY RETURN CODE WITHIN LIMITS
         BH    PARSEBAD       NO, ERROR
         SPACE
         B     *+4(R15)       PROCESS RETURN CODE
         SPACE
PARSERET B     PARSEOK         0- SUCESSFUL
         B     PARSEERR        4- PARSE UNABLE TO PROMPT
         B     PARSEERR        8- USER ENTERED ATTENTION
         B     PARSEBAD       12- INVALID PARAMETERS
         B     PARSEBAD       16- PARSE INTERNAL FAILURE
         B     PARSEERR       20 - VALIDITY CHECK ERROR
MAXPARSE EQU   *-PARSERET
         SPACE 5
PARSEBAD DS    0H
         MVC   MSGTEXT2+4(L'MSGPARSE),MSGPARSE
         LA    R1,MSGTEXT2+4+L'MSGPARSE
         SPACE
         CVD   R15,DOUBLE
         OI    DOUBLE+7,X'0F'
         UNPK  0(2,R1),DOUBLE
         SPACE
         LA    R0,MSGTEXT2-2
         SR    R1,R0
         SLL   R1,16
         ST    R1,MSGTEXT2
         SPACE 2
         VTOCMSG MSGCMDER,MSGTEXT2    PUT OUT 'COMMAND ERROR' MSG
         SPACE 3
PARSEERR LA    R15,12         ERROR CODE 12 - COMMAND FAILED
         B     PARSERTN       RETURN FROM PARSE
         SPACE
PARSEOK  SR    R15,R15        CLEAR THE RETURN CODE
PARSERTN L     R14,R14PARSE   GET THE RETURN LOCATION
         BR    R14            AND GET OUT OF HERE
         SPACE
         EJECT
*
*        PARSE CLEANUP ROUTINE
*
         SPACE 3
FREEPDL  DS    0H
         SPACE
         ST    R14,R14SAVE
         SPACE
         IKJRLSA ADDRANSR     RELEASE THE STORAGE
         SPACE 2
         XC    ADDRANSR,ADDRANSR
         SPACE
         L     R14,R14SAVE
         BR    R14
         EJECT
*
*
*        CONSTANTS
*
*
         LTORG
RTNADDRS DC    V(VTOCMSG)
         DC    A(0)           DUMMY ENTRY FOR THE EXIT ROUTINE
         DC    V(VTOCEXCP)
         DC    V(VTOCCHEK)
         DC    V(VTOCFORM)
         DC    V(VTOCPRNT)
         DC    V(VTOCSORT)
RTNADLEN EQU   *-RTNADDRS
ADDRPCL  DC    A(PCLMAIN)     ADDR OF MAIN PARSE CONTROL LIST
FMIN1    DC    X'0000FFFF'    END OF UCB LIST
BLANKS   DC    CL8' '         BALNKS
H2       DC    H'2'
H4       DC    H'4'
H5       DC    H'5'
*
*
*
*
*
CHARALL  DC    CL3'ALL'
CHARALV  DC    CL3'ALV'
CHARALX  DC    CL3'ALX'
MOVVOL   MVC   VOLSER(0),0(R5)
CLCVOL   CLC   VOLSER(0),28(R6)
         EJECT
SORTTABX DC    AL2(VTFDSN-VTFMT),AL2(43),CL8'DSNAME'
         DC    AL2(VTFVOLUM-VTFMT),AL2(5),CL8'VOLUME'
         DC    AL2(VTFALLOC-VTFMT),AL2(3),CL8'ALLOC'
         DC    AL2(VTFUSED-VTFMT),AL2(3),CL8'USED'
         DC    AL2(VTFUNUSD-VTFMT),AL2(3),CL8'UNUSED'
         DC    AL2(VTFPCT-VTFMT),AL2(1),CL8'PCT'
         DC    AL2(VTFNOEPV-VTFMT),AL2(0),CL8'EX'
         DC    AL2(VTFDSORG-VTFMT),AL2(2),CL8'DSO'
         DC    AL2(VTFRECFM-VTFMT),AL2(4),CL8'RFM'
         DC    AL2(VTFLRECL-VTFMT),AL2(1),CL8'LRECL'
         DC    AL2(VTFBLKSZ-VTFMT),AL2(1),CL8'BLKSZ'
         DC    AL2(VTFCREDT-VTFMT),AL2(2),CL8'CDATE'
         DC    AL2(VTFEXPDT-VTFMT),AL2(2),CL8'EXPDT'
         DC    AL2(VTFLSTAC-VTFMT),AL2(2),CL8'REFDT'
         DC    F'0'
         EJECT
*
*        PROGRAM MESSAGES
*
         SPACE 2
         PRINT NOGEN
         SPACE
MSGPARSE MSG   ' PARSE ERROR CODE '
MSGCMDER MSG   ' COMMAND SYSTEM ERROR'
MSGNOTMT MSG   ' VVVVVV VOLUME IS NOT MOUNTED'
MSGOFFLN MSG   ' VVVVVV VOLUME IS OFFLINE'
MSGPEND  MSG   ' VVVVVV VOLUME IS PENDING OFFLINE'
*
*
         EJECT
         DS    0F
SORTKTAB DC    AL2(VTFDSN-VTFMT),AL2(DSNSORTE-DSNSORT)
         DC    A(DSNSORT),A(DSNSORTE)
         DC    AL2(VTFVOLUM-VTFMT),AL2(VOLSORTE-VOLSORT)
         DC    A(VOLSORT),A(VOLSORTE)
         DC    AL2(VTFUSED-VTFMT),AL2(USESORTE-USESORT)
         DC    A(USESORT),A(USESORTE)
         DC    AL2(VTFALLOC-VTFMT),AL2(ALCSORTE-ALCSORT)
         DC    A(ALCSORT),A(ALCSORTE)
         DC    AL2(VTFUNUSD-VTFMT),AL2(UNUSORTE-UNUSORT)
         DC    A(UNUSORT),A(UNUSORTE)
         DC    AL2(VTFPCT-VTFMT),AL2(PCTSORTE-PCTSORT)
         DC    A(PCTSORT),A(PCTSORTE)
         DC    AL2(VTFNOEPV-VTFMT),AL2(EXTSORTE-EXTSORT)
         DC    A(EXTSORT),A(EXTSORTE)
         DC    AL2(VTFDSORG-VTFMT),AL2(DSOSORTE-DSOSORT)
         DC    A(DSOSORT),A(DSOSORTE)
         DC    AL2(VTFRECFM-VTFMT),AL2(RFMSORTE-RFMSORT)
         DC    A(RFMSORT),A(RFMSORTE)
         DC    AL2(VTFLRECL-VTFMT),AL2(LRCSORTE-LRCSORT)
         DC    A(LRCSORT),A(LRCSORTE)
         DC    AL2(VTFBLKSZ-VTFMT),AL2(BLKSORTE-BLKSORT)
         DC    A(BLKSORT),A(BLKSORTE)
         DC    AL2(VTFCREDT-VTFMT),AL2(CDTSORTE-CDTSORT)
         DC    A(CDTSORT),A(CDTSORTE)
         DC    AL2(VTFLSTAC-VTFMT),AL2(RDTSORTE-RDTSORT)
         DC    A(RDTSORT),A(RDTSORTE)
         DC    AL2(VTFEXPDT-VTFMT),AL2(EDTSORTE-EDTSORT)
         DC    A(EDTSORT),A(EDTSORTE)
         DC    2F'0'
         SPACE 3
DSNSORT  DC    A(0),AL2(0),CL6'Z'
         DC    A(0),AL2(1),CL6'TV'
         DC    A(0),AL2(1),CL6'TM'
         DC    A(0),AL2(2),CL6'T.Z'
         DC    A(0),AL2(2),CL6'T.Y'
         DC    A(0),AL2(2),CL6'T.X'
         DC    A(0),AL2(2),CL6'T.W'
         DC    A(0),AL2(2),CL6'T.V'
         DC    A(0),AL2(2),CL6'T.U'
         DC    A(0),AL2(2),CL6'T.T'
         DC    A(0),AL2(2),CL6'T.S'
         DC    A(0),AL2(2),CL6'T.R'
         DC    A(0),AL2(2),CL6'T.Q'
         DC    A(0),AL2(2),CL6'T.P'
         DC    A(0),AL2(2),CL6'T.O'
         DC    A(0),AL2(2),CL6'T.N'
         DC    A(0),AL2(2),CL6'T.M'
         DC    A(0),AL2(2),CL6'T.L'
         DC    A(0),AL2(2),CL6'T.K'
         DC    A(0),AL2(2),CL6'T.J'
         DC    A(0),AL2(2),CL6'T.I'
         DC    A(0),AL2(2),CL6'T.H'
         DC    A(0),AL2(2),CL6'T.G'
         DC    A(0),AL2(2),CL6'T.F'
         DC    A(0),AL2(2),CL6'T.E'
         DC    A(0),AL2(2),CL6'T.D'
         DC    A(0),AL2(2),CL6'T.C'
         DC    A(0),AL2(2),CL6'T.B'
         DC    A(0),AL2(2),CL6'T.A'
         DC    A(0),AL2(1),CL6'SY'
         DC    A(0),AL2(1),CL6'SV'
         DC    A(0),AL2(1),CL6'PV'
         DC    A(0),AL2(2),CL6'P.Z'
         DC    A(0),AL2(2),CL6'P.Y'
         DC    A(0),AL2(2),CL6'P.X'
         DC    A(0),AL2(2),CL6'P.W'
         DC    A(0),AL2(2),CL6'P.V'
         DC    A(0),AL2(2),CL6'P.U'
         DC    A(0),AL2(2),CL6'P.T'
         DC    A(0),AL2(2),CL6'P.S'
         DC    A(0),AL2(2),CL6'P.R'
         DC    A(0),AL2(2),CL6'P.Q'
         DC    A(0),AL2(2),CL6'P.P'
         DC    A(0),AL2(2),CL6'P.O'
         DC    A(0),AL2(2),CL6'P.N'
         DC    A(0),AL2(2),CL6'P.M'
         DC    A(0),AL2(2),CL6'P.L'
         DC    A(0),AL2(2),CL6'P.K'
         DC    A(0),AL2(2),CL6'P.J'
         DC    A(0),AL2(2),CL6'P.I'
         DC    A(0),AL2(2),CL6'P.H'
         DC    A(0),AL2(2),CL6'P.G'
         DC    A(0),AL2(2),CL6'P.F'
         DC    A(0),AL2(2),CL6'P.E'
         DC    A(0),AL2(2),CL6'P.D'
         DC    A(0),AL2(2),CL6'P.C'
         DC    A(0),AL2(2),CL6'P.B'
         DC    A(0),AL2(2),CL6'P.A'
         DC    A(0),AL2(0),CL6'N'
DSNSORTE DC    A(0),AL2(0),CL6' '
         SPACE 3
VOLSORT  DC    A(0),AL2(4),CL6'33509'
         DC    A(0),AL2(4),CL6'33508'
         DC    A(0),AL2(4),CL6'33507'
         DC    A(0),AL2(4),CL6'33506'
         DC    A(0),AL2(4),CL6'33505'
         DC    A(0),AL2(4),CL6'33504'
         DC    A(0),AL2(4),CL6'33503'
         DC    A(0),AL2(4),CL6'33502'
         DC    A(0),AL2(4),CL6'33501'
         DC    A(0),AL2(4),CL6'33500'
         DC    A(0),AL2(4),CL6'33309'
         DC    A(0),AL2(4),CL6'33308'
         DC    A(0),AL2(4),CL6'33307'
         DC    A(0),AL2(4),CL6'33306'
         DC    A(0),AL2(4),CL6'33305'
         DC    A(0),AL2(4),CL6'33304'
         DC    A(0),AL2(4),CL6'33303'
         DC    A(0),AL2(4),CL6'33302'
         DC    A(0),AL2(4),CL6'33301'
         DC    A(0),AL2(4),CL6'33300'
         DC    A(0),AL2(0),CL6'T'
         DC    A(0),AL2(0),CL6'R'
         DC    A(0),AL2(0),CL6'P'
         DC    A(0),AL2(0),CL6'M'
         DC    A(0),AL2(0),CL6'I'
         DC    A(0),AL2(0),CL6'H'
VOLSORTE DC    A(0),AL2(0),CL6' '
         SPACE 3
USESORT  DS    0F
UNUSORT  DS    0F
ALCSORT  DC    A(0),AL2(3),XL4'0000F000',XL2'00'
         DC    A(0),AL2(3),XL4'0000C000',XL2'00'
         DC    A(0),AL2(3),XL4'0000A000',XL2'00'
         DC    A(0),AL2(3),XL4'00008000',XL2'00'
         DC    A(0),AL2(3),XL4'00006000',XL2'00'
         DC    A(0),AL2(3),XL4'00005000',XL2'00'
         DC    A(0),AL2(3),XL4'00004000',XL2'00'
         DC    A(0),AL2(3),XL4'00003000',XL2'00'
         DC    A(0),AL2(3),XL4'00002000',XL2'00'
         DC    A(0),AL2(3),XL4'00001000',XL2'00'
         DC    A(0),AL2(3),XL4'00000C00',XL2'00'
         DC    A(0),AL2(3),XL4'00000800',XL2'00'
         DC    A(0),AL2(3),XL4'00000400',XL2'00'
         DC    A(0),AL2(3),XL4'00000300',XL2'00'
         DC    A(0),AL2(3),XL4'00000200',XL2'00'
         DC    A(0),AL2(3),XL4'00000100',XL2'00'
         DC    A(0),AL2(3),XL4'000000C0',XL2'00'
         DC    A(0),AL2(3),XL4'00000080',XL2'00'
         DC    A(0),AL2(3),XL4'00000040',XL2'00'
         DC    A(0),AL2(3),XL4'00000010',XL2'00'
USESORTE DS    0F
UNUSORTE DS    0F
ALCSORTE DC    A(0),AL2(3),XL6'00'
         SPACE 3
PCTSORT  DC    A(0),AL2(1),XL2'0064',XL4'00'
         DC    A(0),AL2(1),XL2'005A',XL4'00'
         DC    A(0),AL2(1),XL2'0050',XL4'00'
         DC    A(0),AL2(1),XL2'0046',XL4'00'
         DC    A(0),AL2(1),XL2'003C',XL4'00'
         DC    A(0),AL2(1),XL2'0032',XL4'00'
         DC    A(0),AL2(1),XL2'0028',XL4'00'
         DC    A(0),AL2(1),XL2'001E',XL4'00'
         DC    A(0),AL2(1),XL2'0014',XL4'00'
         DC    A(0),AL2(1),XL2'000A',XL4'00'
PCTSORTE DC    A(0),AL2(1),XL6'00'
         SPACE 3
EXTSORT  DC    A(0),AL2(0),CL6'0'
EXTSORTE DC    A(0),AL2(0),CL6'0'
         SPACE 3
DSOSORT  DC    A(0),AL2(1),CL6'VS'
         DC    A(0),AL2(1),CL6'PS'
         DC    A(0),AL2(1),CL6'PO'
         DC    A(0),AL2(1),CL6'DA'
DSOSORTE DC    A(0),AL2(1),CL6' '
         SPACE 3
RFMSORT  DC    A(0),AL2(1),CL6'VS'
         DC    A(0),AL2(2),CL6'VBS'
         DC    A(0),AL2(1),CL6'VB'
         DC    A(0),AL2(0),CL6'V'
         DC    A(0),AL2(0),CL6'U'
         DC    A(0),AL2(1),CL6'FS'
         DC    A(0),AL2(2),CL6'FBS'
         DC    A(0),AL2(1),CL6'FB'
         DC    A(0),AL2(0),CL6'F'
RFMSORTE DC    A(0),AL2(0),CL6' '
         SPACE 3
LRCSORT  DS    0F
BLKSORT  DC    A(0),AL2(1),XL2'4650',XL4'00'
         DC    A(0),AL2(1),XL2'3A98',XL4'00'
         DC    A(0),AL2(1),XL2'2EE0',XL4'00'
         DC    A(0),AL2(1),XL2'2328',XL4'00'
         DC    A(0),AL2(1),XL2'1770',XL4'00'
         DC    A(0),AL2(1),XL2'0BB8',XL4'00'
         DC    A(0),AL2(1),XL2'07D0',XL4'00'
         DC    A(0),AL2(1),XL2'0640',XL4'00'
         DC    A(0),AL2(1),XL2'04B0',XL4'00'
         DC    A(0),AL2(1),XL2'0320',XL4'00'
         DC    A(0),AL2(1),XL2'0258',XL4'00'
         DC    A(0),AL2(1),XL2'0190',XL4'00'
         DC    A(0),AL2(1),XL2'00C8',XL4'00'
         DC    A(0),AL2(1),XL2'00A0',XL4'00'
         DC    A(0),AL2(1),XL2'0078',XL4'00'
         DC    A(0),AL2(1),XL2'0050',XL4'00'
         DC    A(0),AL2(1),XL2'0028',XL4'00'
BLKSORTE DS    0F
LRCSORTE DC    A(0),AL2(1),XL6'00'
         SPACE 3
CDTSORT  DS    0F
EDTSORT  DS    0F
RDTSORT  DC    A(0),AL2(2),AL1(99),AL2(0),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(83),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(82),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(81),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(80),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(79),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(78),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(77),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(76),AL2(000),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(300),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(200),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(100),XL3'00'
         DC    A(0),AL2(2),AL1(75),AL2(000),XL3'00'
EDTSORTE DS    0F
RDTSORTE DS    0F
CDTSORTE DC    A(0),AL2(2),XL6'00'
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         SPACE 3
         COPY  VTOCPARS
         EJECT
*
*        DYNAMIC WORK AREA
*
         SPACE 3
WORKAREA DSECT
MAINSAVE DS    18A
         SPACE
         VTOCEXCP EQ          DEFINE VTOCEXCP CODES
         SPACE
PARSELST DS    8A             AREA FOR PARSE PARAMETER LIST
         SPACE
R14SAVE  DS    A
R14PARSE DS    A
******** ***** *********************** START OF UCB LOOKUP DSA
DSXALIST DS    0F                      PARMLIST FOR UCB
DSXAWA   DS    F                       %100-BYTE WORK AREA
DSXADEVT DS    F                       %DEV TYPE TO SEARCH
DSXAUCB  DS    F                       %UCB FULL WORD PTR
         DS    0D                      FOLLOWING MUST BE ALIGNED
DSXAWORK DS    CL100                   UCB WORK AREA
DSXAEUCB EQU   DSXAWORK+00,04          EMULATION CURR. UCB PTR
DSXAEILK EQU   DSXAWORK+04,04          EMULATION CVTILK2 ADDR
DSXACLAS DS    CL1                     DEVICE CLASS TO SEARCH
DSXAUCBP DS    F                       %UCB
******** ***** *********************** END OF UCB LOOKUP DSA
*
*        VTOC COMMAND COMMON AREA
*
         PRINT GEN
         VTOCOM  NODSECT
         PRINT NOGEN
         SPACE 3
*
*        WORK AREAS FOR SUBROUTINES
*
WORKMSG  DS    XL256
WORKEXCP DS    4XL256
WORKCHEK DS    XL256
WORKFORM DS    2XL256
WORKEXIT DS    8XL256
WORKSORT DS    XL256
WORKPRNT DS    10XL256
         DS    0D
LENWORK  EQU   *-WORKAREA
         SPACE 3
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
         IKJPPL
         SPACE 3
         IKJIOPL
         SPACE 3
         IKJPSCB
         SPACE 3
         IKJECT
         SPACE 3
         IKJCPPL
         SPACE 3
         IKJUPT
         SPACE 3
         PRINT NOGEN
         IEFUCBOB                      UCB MAPPING MACRO
         CVT   DSECT=YES
         END
VTOCCHEK TITLE 'VTOC COMMAND - CHECK  ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
* FUNCTION -   CHECK THE CONDITIONS SPECIFIED ON THE VTOC COMMAND.    *
*              SEE IF THE DATA SET PASSED SHOULD BE PROCESSED.        *
*              THE LIMIT, ENDING, CONTAINING, CCHH, LIMIT, AND,       *
*              AND OR KEYWORDS ARE PROCESSED BY THIS ROUTINE.         *
*                                                                     *
* OPERATION -  FIRST GET THE LENGTH OF THE DSNAME AND SAVE IT.        *
*              THEN GET THE FORMAT 3 DSCB, IF ONE EXISTS.  TRY        *
*              EACH KEYWORD TO SEE IF IT WILL EXCLUDE THE DATA        *
*              SET FROM FURTHER PROCESSING.                           *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, FORMAT 1, 3, AND 4 DSCB'S              *
*              FOR DSORG, RECFM, ALLOC, USED, PROT, CATLG, OR SECAL   *
*              CALL VTOCFORM TO FORMAT THE PARMS.  USE FORMATTED DSCB *
*                                                                     *
* OUTPUT -     A RETURN CODE OF 0 TO CONTINUE PROCESSING OR 8 TO      *
*              EXCLUDE THIS DATA SET.                                 *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*              ICF SUPPORT C. HUNTER  (313) 540-0900           25JUN84
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
*        MACROS FOR CHECK ROUTINE
*
         MACRO
&LABEL   VTCHL &KEY           CALL THE KEYWORD CHECK ROUTINE
&LABEL   L     R1,SUB&KEY.OPER    GET THE OPERATOR VALUE
         BAL   R8,GETOPER    TRANSLATE TO A NUMBER
         ST    R15,REFOPER     SAVE IT TOO
         LA    R1,SUB&KEY.VALU   GET THE VALUE PDL
         ST    R1,REFVAL      SAVE THAT ADDRESS THREE
         CLI   FLAGNM&KEY,0  HAS IT BEEN CONVERTED?
         BNE   VTP&SYSNDX    YES, SKIP ALONG
         MVI   FLAGNM&KEY,1  NOTE IT AS CONVERTED
         BAL   R8,PDLNUM     GO CONVERT IT
         ST    R15,NUMBER&KEY      SAVE THE VALUE
         LA    R4,SUB&KEY.KEY  POINT TO THE IKJIDENT FOR THE KEYWORD
         BAL   R8,GETKEY     CONVERT TEXT TO A NUMERIC KEY
         STC   R15,NUMKEY&KEY  SAVE THAT NUMERIC KEY
         LTR   R15,R15       WAS IT SUCCESSFUL?
         BNZ   VTP&SYSNDX    YES, SKIP ALONG
*        ISSUE A MESSAGE - A BAD LIM, AND, OR KEYWORD
         MVC   MSGTEXT2,KEYERR  START THE ERROR MESSAGE
         L     R1,0(R4)      POINT TO THE TEXT
         MVC   MSGTEXT2+49(6),0(R1)  THEN ADD IT TO THE MESSAGE
         VTOCMSG MSGTEXT2    ISSUE THE ERROR MESSAGE
VTP&SYSNDX DS  0H
         SR    R1,R1         CLEAR A REGISTER
         ICM   R1,1,NUMKEY&KEY GET THE KEYWORD VALUE
         BZ    VTE&SYSNDX    IF NOT SET, SKIP THE EVALUATION
         ST    R1,REFKEY      SAVE THE ADDRESS
         LA    R1,NUMBER&KEY  GET THE ADDRESS OF CONVERTED NUMBER
         ST    R1,REFNUM      SAVE IT'S ADDRESS
         BAL   R8,LIMEVAL     GO EVALUATE THE EXPRESSION
VTE&SYSNDX DS  0H
         MEND
         SPACE 3
         MACRO
&LABEL   VTANDOR &NUM         EVALUATE, THEN DO AND OR OR FUNCTION
&LABEL   CLI   ANDOR&NUM.K+1,0  WAS THIS KEYWORD SET?
         BE    LIMCOMP        NO, JUST CHECK THE FINAL RESULT
         VTCHL &NUM           YES, EVALUATE
         CLI   ANDOR&NUM.K+1,1  WAS IT AN AND ?
         BE    VTA&SYSNDX     YES, DO THE AND
         O     R15,LIMVAL     NO, OR IT
         B     VTE&SYSNDX     FINISHED WITH THIS EXPRESSION
VTA&SYSNDX N   R15,LIMVAL     AND THE EXPRESSION VALUE
VTE&SYSNDX ST  R15,LIMVAL     SAVE THE VALUE
         MEND
         MACRO                                                 25JUN84
         $FORMEX &I                                            25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+00-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+10-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+20-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+30-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+00-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+10-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+20-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+30-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+40-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+50-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+60-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84
         MEND                                                  25JUN84
*
         EJECT
VTOCCHEK ENTER 12,12          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING CHEKWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
*
*        SEE WHAT THE FORMAT ID IS
*
CHEKFMT  L     R7,DSCBADDR    POINT TO THE DSCB
         LA    R7,8(R7)       GET PAST THE HEADER
         USING DSCB1,R7       SET ADDRESSABILITY
         CLI   FORMATK+1,0    DID HE SPECIFY VARIOUS DSCB'S
         BNE   CHEKFMTI       YES, GO DO HIS CHECKS
CHEKFMTI DS    0H             NOT YET PROGRAMMED
*
*        STANDARD IS ONLY TO ALLOW FORMAT ONES TO GO
*
         CLI   DS1FMTID,C'1'  IS THIS A FORMAT 1?
         BNE   CHECKOUT       NO, EXCLUDE IT FROM FURTHER PROCESSING
*
*              FIRST SEE HOW BIG THE DSNAME IS
*
         LA    R1,DS1FMTID    POINT PAST THE DSNAME
         TRT   DS1DSNAM,BLKTRTAB  FIND THE FIRST BLANK
         SR    R1,R7          SUBTRACT TO GET THE LENGTH
         STH   R1,DSNLEN      SAVE THE DSNAME LENGTH
         LR    R3,R1          KEEP THE LENGTH FOR LATER
*
*        GET THE FORMAT 3 DSCB, IF IT EXISTS
*
         LA    R1,FMT3                 GET 1ST F3              25JUN84
CHEKF3XC DS    0H                                              25JUN84
         CLC   =XL10'0',0(R1)          CLEAR TIL EMPTY FOUND   25JUN84
         BE    CHEKFMT3                                        25JUN84
         XC    0(L'FMT3,R1),0(R1)      CLEAR F3                25JUN84
         LA    R1,L'FMT3(R1)           NEXT F3                 25JUN84
         B     CHEKF3XC                LOOP                    25JUN84
CHEKFMT3 DS    0H                                              25JUN84
         XC    FMT3,FMT3      CLEAR IT FIRST
         CLC   DS1PTRDS,=XL5'0000000000'  IS THERE A FORMAT 3?
         BE    FMT3NO         NO, SKIP ALONG
*
*        SET UP THE CAMLST
*
CHEKF3RD DS    0H                      READ F3S                25JUN84
         MVC   CAMSEEK(4),CAMSCON  MOVE IN THE FIRST WORD OF CAMLST
         LA    R1,DS1PTRDS    GET THE CCHHR ADDRESS
         ST    R1,CAMSEEK+4   SAVE IT
         LA    R1,VOLID       POINT TO THE VOLUME SERIAL
         ST    R1,CAMSEEK+8   SAVE IT
         LA    R1,FMT3        POINT TO THE AREA FOR THE DSCB3
         ST    R1,CAMSEEK+12  SAVE IT
CHEKF3R3 DS    0H                      READ F3S                25JUN84
         OBTAIN CAMSEEK       GET THE DSCB
         LTR   R15,R15        TEST THE RETURN CODE
         BNZ   OBT3ERR        BAD NEWS, ISSUE THE MESSAGE
         L     R1,CAMSEEK+12           GET F3 READ             25JUN84
         CLC   =XL5'0',DS3PTRDS-FMT3(R1) MORE F3? (ICF)        25JUN84
         BE    CHEKF3NO                NO                      25JUN84
         LA    R0,DS3PTRDS-FMT3(R1)    NEXT F3 ADDR            25JUN84
         ST    R0,CAMSEEK+4            SAVE IT                 25JUN84
         LA    R0,L'FMT3(R1)           NEXT AVAIL F3 AREA      25JUN84
         ST    R0,CAMSEEK+12           SAVE IT                 25JUN84
         B     CHEKF3R3                READ NEXT F3DSCB        25JUN84
CHEKF3NO DS    0H                                              25JUN84
*
*        PROCESS THE LEVEL KEYWORD
*
FMT3NO   CLI   LEVKEY+1,0     WAS LEVEL SPECIFIED?
         BE    LEVEND         NO, SKIP ON
         LA    R4,LEVEL       YES, POINT TO THE PDE
         USING PDEDSNAM,R4    SET ADDRESSABILITY
         LR    R2,R7          POINT TO THE START OF THE DSNAME
LEVNEXT  SR    R5,R5          CLEAR FOR INSERT
         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH
         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT
         L     R6,PDEDSN      POINT TO THE LEVEL
         CR    R3,R5          COMPARE LENGTHS
         BL    LEVINC         THIS LEVEL IS LONGER THAN DSN, NO MATCH
         BCTR  R5,0           MINUS ONE FOR THE EX
         EX    R5,COMPARE     CHECK THE LENGTHS
         BE    LEVEND         IT MATCHES, ALLOW IT
LEVINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT LEVEL PDE POINTER
         BNZ   LEVNEXT        IF IT'S THERE, KEEP LOOKING
         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME
LEVEND   DS    0H
         DROP  R4             FINISHED WITH THE PDE
*
*        PROCESS THE ENDING KEYWORD
*
         CLI   ENDKEY+1,0     WAS ENDING SPECIFIED?
         BE    ENDEND         NO, SKIP ON
         LA    R4,ENDING      YES, POINT TO THE PDE
         USING PDEDSNAM,R4    SET ADDRESSABILITY
ENDNEXT  SR    R5,R5          CLEAR FOR INSERT
         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH
         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT
         L     R6,PDEDSN      POINT TO THE ENDING
         CR    R3,R5          COMPARE LENGTHS
         BL    ENDINC         THIS ENDING IS LONGER THAN DSN, NO MATCH
         LR    R2,R7          POINT TO THE START OF THE DSNAME
         AR    R2,R3          POINT TO THE END
         SR    R2,R5          BACKUP TO COMPARE THIS LENGTH
         BCTR  R5,0           MINUS ONE FOR THE EX
         EX    R5,COMPARE     CHECK THE LENGTHS
         BE    ENDEND         IT MATCHES, ALLOW IT
ENDINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT ENDING PDE POINTER
         BNZ   ENDNEXT        IF IT'S THERE, KEEP LOOKING
         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME
ENDEND   DS    0H
         DROP  R4             FINISHED WITH THE PDE
*
*        PROCESS THE CONTAINING KEYWORD
*
         CLI   CONTAINK+1,0   WAS CONTAINING SPECIFIED?
         BE    CONEND         NO, SKIP ON
         LA    R4,CONTAIN     YES, POINT TO THE PDE
         USING PDEDSNAM,R4    SET ADDRESSABILITY
CONNEXT  SR    R5,R5          CLEAR FOR INSERT
         ICM   R5,B'0011',PDEDSNL  GET THE DSNAME LENGTH
         BZ    CHECKOUT       END OF THE LINE, EXCLUDE IT
         L     R6,PDEDSN      POINT TO THE CONTAINING
         CR    R3,R5          COMPARE LENGTHS
         BL    CONINC         THIS CONTAIN IS LONGER THAN DSN, NO MATCH
         LR    R1,R7          POINT TO THE START OF THE DSNAME
         AR    R1,R3          POINT TO THE END
         SR    R1,R5          BACKUP TO COMPARE THIS LENGTH - LAST ONE
         LR    R2,R7          POINT TO THE START OF THE DSNAME
         BCTR  R5,0           MINUS ONE FOR THE EX
CONCOMP  EX    R5,COMPARE     CHECK THE LENGTHS
         BE    CONEND         IT MATCHES, ALLOW IT
         LA    R2,1(R2)       CHECK THE WHOLE DSNAME
         CR    R2,R1          CHECK FOR THE END OF THE REAL DSN
         BNH   CONCOMP        NOT THERE YET
CONINC   ICM   R4,B'0111',PDEDCHN GET THE NEXT CONTAINING PDE POINTER
         BNZ   CONNEXT        IF IT'S THERE, KEEP LOOKING
         B     CHECKOUT       NO MATCHES, EXCLUDE THIS DSNAME
CONEND   DS    0H
         DROP  R4             FINISHED WITH THE PDE
*
*        NOW THE BIG MESS, CHECK FOR LIMIT, AND'S, AND OR'S
*
         CLI   LIMITK+1,0     WAS LIMIT SPECIFIED
         BE    LIMEND         NO, THEN THERE CAN BE NO AND'S OR OR'S
         NI    VTCFMTCK,255-VTCFMTCC  TURN OFF THE ROUTINE CALL FLAG
         VTCHL L              EVALUATE THE LIMIT 1=TRUE 0=FALSE
         ST    R15,LIMVAL     SAVE THE ANSWER
         VTANDOR 1            CHECK AND1 OR OR1
         VTANDOR 2            CHECK AND2 OR OR2
         VTANDOR 3            CHECK AND3 OR OR3
LIMCOMP  L     R15,LIMVAL     GET THE RESULT OF ALL THIS
         LTR   R15,R15        TEST IT
         BZ    CHECKOUT       IT GETS EXCLUDED
LIMEND   DS    0H
         B     CHECKIN        ALL TESTS PASSED, INCLUDE THIS ONE
         SPACE 5
*
*        EVALUATION ROUTINE FOR   KEYWORD  OPER  VALUE
*
LIMEVAL  L     R5,REFKEY      GET THE KEYWORD VALUE
         MH    R5,H12         MULTIPLY IT BY 12
         A     R5,ATABTITL    THEN RELOCATE IT
         SR    R10,R10         CLEAR THE ROUTINE POINTER
         TM    1(R5),X'80'    IS IT A FORMATTED ITEM?
         BO    LIMFORM        YES, GO DO IT
         SR    R6,R6         CLEAR A REGISTER
         IC    R6,2(R5)      GET THE OFFSET INTO VTFMT
         IC    R10,1(R5)      GET THE ROUTINE NUMBER
         LTR   R10,R10         SEE IF IT'S A GOOD NUMBER
         BP    LIMEVAL1       IT'S ALL RIGHT
LIMABEND ABEND 702,DUMP       CRASH AND BURN
LIMEVAL1 B     *(R10)         AND GO TO IT        +00
         B     LIMDATE        CDATE, EXPDT, REFDT +04
         B     LIMLUSE        *** DUMMY ENTRY *** +08
         B     LIMFORM        FORM , USED SPACE   +12
         B     LIMFORM        UNUSED SPACE        +16
         B     LIMFORM        PCT USED            +20
         B     LIMEXT         EXTENTS             +24
         B     LIMBLREC       LRECL, BLKSZ, SEC Q +28
         B     LIMCCHH       CCHH CHECKING        +32
         SPACE 5
*
*        PERFORM THE FORMATTED ITEM CHECKING
*
LIMFORM  DS    0H
         TM    VTCFMTCK,VTCFMTCC  WAS FORMAT CALLED BEFORE FOR THIS DS
         BO    LIMFCALD       YES, DON'T CALL IT AGAIN
         VTCALL FORM          NO, CALL IT TO GET THE ITEMS
         OI    VTCFMTCK,VTCFMTCC+VTCFMTCD  THEN SET THE SWITCHES
LIMFCALD SR    R2,R2          CLEAR A WORK REG
         A     R6,FORMATAD   RELOCATE THE BLOCK
         B     *+4(R10)         AND GO TO IT
         B     LIMFORMA      FORMATTED ITEM
         B     LIMABEND       CDATE, EXPDT
         B     LIMABEND       LAST USE DATE
         B     LIMALLOC       ALLOC, USED SPACE
         B     LIMUNUSD       UNUSED SPACE
         B     LIMPCT         PCT USED
LIMFORMA DS    0H
         IC    R2,2(R5)       GET THE OFFSET IN VTFMT
         A     R2,FORMATAD    THEN RELOCATE IT
         L     R4,REFVAL      GET THE VALUE PDE
         LH    R3,4(R4)       GET THE LENGTH OF THE STRING
         L     R1,0(R4)       AND ITS ADDRESS
*
*        DO THE ACTUAL COMPARE
*
         BCTR  R3,0           DOWN ONE FOR AN EX
         EX    R3,COMPLIM     COMPARE AS SPECIFIED
COMPDONE DS    0H             GET THE OPERATOR ADDRESS
         BL    COMPLOW        CHECK THE OPERATOR, VALUE LESS THAN ITEM
         BE    COMPEQ         CHECK THE OPERATOR, KEYWORD EQUALS VALUE
*                             KEYWORD IS GREATER THAN THE VALUE
COMPHI   CLI   REFOPER+3,NE       WAS OPERATOR NE
         BE    COMPYES        HIGH SATISFIES THE EXPRESSION
         CLI   REFOPER+3,GT       ALSO FOR GT
         BE    COMPYES        HIGH SATISFIES THE EXPRESSION
         CLI   REFOPER+3,GE       AND FOR GE
         BE    COMPYES        HIGH SATISFIES THE EXPRESSION
         B     COMPNO         THIS ONE DOESN'T FIT
*                             KEYWORD IS EQUAL TO THE VALUE
COMPEQ   CLI   REFOPER+3,EQ       WAS OPERATOR EQ
         BE    COMPYES        EQ   SATISFIES THE EXPRESSION
         CLI   REFOPER+3,LE       ALSO FOR LE
         BE    COMPYES        EQ   SATISFIES THE EXPRESSION
         CLI   REFOPER+3,GE       AND FOR GE
         BE    COMPYES        EQ   SATISFIES THE EXPRESSION
         B     COMPNO         THIS ONE DOESN'T FIT
*                             KEYWORD IS LESS THAN THE VALUE
COMPLOW  CLI   REFOPER+3,NE       WAS OPERATOR NE
         BE    COMPYES        LOW  SATISFIES THE EXPRESSION
         CLI   REFOPER+3,LT       ALSO FOR LT
         BE    COMPYES        LOW  SATISFIES THE EXPRESSION
         CLI   REFOPER+3,LE       AND FOR LE
         BE    COMPYES        LOW  SATISFIES THE EXPRESSION
         B     COMPNO         THIS ONE DOESN'T FIT
*
*        IT FITS OR IT DOESN'T
*
COMPYES  LA    R15,1          SET A TRUE VALUE
         BR    R8             THEN RETURN
COMPNO   SR    R15,R15        SET A FALSE VALUE
         BR    R8             THEN RETURN
*
*        SPECIAL ROUTINES TO CHECK NON-FORMATTED ITEMS
*
LIMDATE  DS    0H
*
*        COMPARE DATES
*
         LA    R14,DS1CREDT  POINT TO CREATION DATE
         CLI   REFKEY+3,CDATE      IS THAT IT?
         BE    LIMDGET       YES, THIS IS IT
         LA    R14,DS1EXPDT  POINT TO EXPIRATION DATE
         CLI   REFKEY+3,EXPDT      IS THAT IT?
         BE    LIMDGET       YES, THIS IS IT
         LA    R14,DS1REFD   NO, USE REFERENCE DATE
LIMDGET  SR    R15,R15       CLEAR A WORK REG
         IC    R15,0(R14)    GET THE YEAR
         MH    R15,H1000     TIMES 1000
         SR    R1,R1         CLEAR ANOTHER WORK REG
         ICM   R1,3,1(R14)    GET THE DAYS
         AR    R15,R1        PUT THE DATE TOGETHER
         L     R1,REFNUM     GET THE ADDRESS OF THE VALUE
         L     R1,0(R1)      GET THE VALUE ITSELF
         CR    R15,R1        COMPARE THEM
         B     COMPDONE      GO CHECK OPERANDS
LIMLUSE  DS    0H
*
*        LAST USE DATE
*
         SR    R14,R14       CLEAR THE DATE
         CLC   ZERO,75(R7)   CHECK FOR NO DATA
         BE    LIMLUCMP      RIGHT, SKIP ON
         MVC   CHEKDBLW+5(3),75(R7)  MOVE IN THE LAST USE DATE
         CVB   R14,CHEKDBLW  CONVERT IT TO BINARY
LIMLUCMP L     R1,REFNUM     GET THE ADDRESS OF THE VALUE
         L     R1,0(R1)      GET THE VALUE
         CR    R14,R1        DO THE COMPARE
         B     COMPDONE      THEN CHASE DOWN THE OPERANDS
LIMEXT   DS    0H
*
*        EXTENTS
*
         L     R1,REFNUM     GET THE COMPARE VALUE ADDRESS
         CLC   DS1NOEPV,3(R1)        COMPARE THEM
         B     COMPDONE      GO CHECK OPERANDS
LIMBLREC DS    0H
*
*        LRECL, BLKSZ, SECQ
*
         L     R1,REFNUM     GET THE ADDRESS OF THE COMPARE VALUE
         L     R15,0(R1)      THEN GET THE VALUE ITSELF
         CLI   REFKEY+3,BLKSZ      BLOCK SIZE?
         BNE   LIMB1         NO, KEEP CHECKING
         LH    R1,DS1BLKL    COMPARE TO THE BLOCK SIZE
         CR    R1,R15        COMPARE THEM
         B     COMPDONE      GO SIFT THROUGH THE OPERANDS
LIMB1    CLI   REFKEY+3,LRECL  LOGICAL RECORD LENGTH
         BNE   LIMB2         NO, KEEP GOING
         LH    R1,DS1LRECL   COMPARE TO THE LRECL
         CR    R1,R15        COMPARE THEM
         B     COMPDONE      GO CHECK THE OPERANDS
LIMB2    MVC   HWORK,DS1SCALO+2 GET THE SECONDARY QUANTITY
         LH    R1,HWORK      DO THE COMPARE
         CR    R1,R15        COMPARE THEM
         B     COMPDONE      THEN CHECK THE OPERANDS
*
*        SPACE CHECKING ROUTINES
*
LIMALLOC DS    0H
*
*        ALLOC AND USED
*
         L     R1,REFNUM     GET THE ADDRESS OF THE CONVERTED NUMBER
         L     R1,0(R1)      GET THE VALUE
         L     R15,0(R6)     GET THE AMOUNT
         CR    R15,R1        COMPARE THEM
         B     COMPDONE      THEN CHECK THE OPERANDS
LIMUNUSD DS    0H
*
*        UNUSED
*
         L     R6,FORMATAD   POINT TO THE FORMATTED VTOC
         USING VTFMT,R6      SET ADDRESSABILITY
         ICM   R14,15,VTFUSED      GET THE AMOUNT USED
         BM    LIMUNUAL      IF MINUS, WE DON'T KNOW
         L     R14,VTFALLOC  GET ALLOC
         S     R14,VTFUSED   MINUS THE AMOUNT USED
LIMUNUAL L     R1,REFNUM     GET THE ENTERED VALUE
         L     R1,0(R1)      NOW ITS VALUE FOR REAL
         CR    R14,R1        COMPARE THE VALUES
         B     COMPDONE      THEN GO CHECK THE OPERANDS
LIMPCT   DS    0H
*
*        PER CENT
*
         L     R6,FORMATAD   POINT TO THE FORMATTED VTOC
         USING VTFMT,R6      SET ADDRESSABILITY
         SR    R14,R14       CLEAR A REGISTER
         ICM   R15,15,VTFUSED      GET THE AMOUNT USED
         BM    LIMP100       IF UNKNOWN USED, SET 100 PER CENT
         CLC   VTFALLOC,ZERO ZERO ALLOCATED SPACE?
         BNE   LIMPCTOK      NO, CONTINUE
         CLC   VTFUSED,ZERO  ZERO USED SPACE?
         BE    LIMPCOMP      YES, PCT IS ZERO
*              ZERO ALLOCATED, NONZERO USED, INCLUDE THIS ONE
         B     COMPYES
LIMP100  LA    R15,100       SET UP 100 PER CENT
         B     LIMPCOMP      GO COMPARE
LIMPCTOK M     R14,F100      MULTIPLY BY 100 PERCENT
         D     R14,VTFALLOC  DIVIDE BY THE ALLOCATION
LIMPCOMP L     R1,REFNUM     GET THE VALUE ADDRESS
         L     R1,0(R1)      THEN THE VALUE
         CR    R15,R1        THEN COMPARE THEM
         B     COMPDONE      THEN GO SIFT THROUGH THE OPERANDS
*
*        CCHH CHECKING IS NOT QUITE STANDARD BECAUSE THERE MAY
*        MAY BE UP TO 16 EXTENTS TO COMPARE.  THE DATA MAY BE
*        CC OR CCHH FORMATS.  THE DATA SET MAY BE EQUAL TO,
*        LESS THAN, AND GREATER THAN ANY PARTICULAR VALUE.
*
LIMCCHH  DS    0H
*
*        FIRST SEE IF THE CCHH WAS CONVERTED
*              CONVERT IT IF NOT, SKIP IF IT'S DONE
*
         L     R5,REFNUM     GET THE ADDRESS OF THE COMPARISON VALUE
         L     R4,0(R5)      GET THE VALUE
         ICM   R6,3,4(R5)    GET THE COMPARE LENGTH
         BP    LIMCSET       IF IT'S SET, THE CONVERSION IS DONE
*                      IT WASN'T SET, CONVERT FROM CHARS TO BINARY
         L     R1,REFVAL     GET THE ADDRESS OF THE IKJIDENT
         L     R2,0(R1)      POINT TO THE TEXT
         LH    R3,4(R1)      GET THE LENGTH OF THE TEXT
*        IT SHOULD BE 4 OR 8 CHARACTERS
         XC    DOUBLE,DOUBLE CLEAR OUT A PLACE TO WORK
         CH    R3,H4         IS IT A CYLINDER ONLY?
         BH    LIMCCON2      NO, TRY FOR A CCHH
         BE    LIMCCON1      YES, JUST CONVERT IT
         VTOCMSG CCHHLEN     LESS THAN FOUR CHARS, ISSUE A MSG
LIMCCON1 LA    R6,1          SET THE COMPARE LENGTH
         B     LIMCMOVE      GO MOVE IT IN
LIMCCON2 LA    R6,3          SET THE COMPARE LENGTH
         CH    R3,H8         WAS IT A CCHH?
         BE    LIMCMOVE      YES, JUST THE RIGHT LENGTH
         VTOCMSG CCHHLEN     WARN THE PERSON
         CH    R3,H8         CHECK AGAIN
         BL    LIMCMOVE      IS IT OVER 8 CHARS?
         LH    R3,H8         YES, SET IT FOR THE MAX - IGNORE RR
LIMCMOVE BCTR  R3,0          MINUS ONE FOR THE EX
         EX    R3,MOVECCHH   MOVE IN THE CHARS
         TR    DOUBLE,DECTABLE TRANSLATE HEX EBCDIC TO HEX BINARY
         PACK  CYLH(5),DOUBLE(9)  SQUISH OUT THE ZONES
         L     R4,CYLH       GET THE CCHH
         ST    R4,0(R5)      SAVE IT FOR LATER
         STH   R6,4(R5)      SAVE THE LENGTH TOO
LIMCSET  DS    0H            THE NUMBER IS CONVERTED
*
*        COMPARE THE EXTENTS TO THE CCHH VALUE.
*        ANY EXTENT MAY BE LT, EQ, AND GT A PARTICULAR
*        VALUE, AND ALL THE EXTENTS MUST BE CHECKED.
*
         MVI   CCHHCOMP,0    CLEAR THE FLAGS
         SR    R2,R2         CLEAR A REG FOR AN EXTENT COUNTER
         ICM   R2,1,DS1NOEPV GET THE NUMBER OF EXTENTS
         BZ    COMPNO        NO EXTENTS, JUST GO SEE
*
*        GET EACH EXTENT AND PROCESS IT
*
         SR    R1,R1         FIRST EXTENT
EXTNEXT  LR    R3,R1         GET THE CURRENT EXTENT
         CH    R3,GETEXMAX             MAX EXTENTS             25JUN84
         BH    LIMCOPER                TOO MANY - SKIP         25JUN84
         SLL   R3,1                    MULT. BY 2              25JUN84
         LH    R3,GETEXT(R3)           GET EXTENT OFFSET       25JUN84
         CH    R1,=H'2'                IS EXTENT IN F1 OR F3   25JUN84
         BH    EXTNXF3                 F3                      25JUN84
         LA    R3,DS1EXT1(R3)          +F1 BASE = ADDR OF EXT  25JUN84
         B     EXTNXFX                 CONTINUE                25JUN84
EXTNXF3  DS    0H                                              25JUN84
         LA    R3,FMT3(R3)             +F3 BASE = ADDR OF EXT  25JUN84
EXTNXFX  DS    0H                                              25JUN84
*
*        CHECK THE BOTTOM OF THE EXTENT
*
         NI    CCHHCOMP,255-CCHHX TURN OFF THE STRADDLE FLAG
         EX    R6,CLCEXTLO    DO THE COMPARE
         BH    SETH1         THE FIELD IS HIGHER THAN THE VALUE
         BE    SETEQ1        THE FIELD IS EQUAL TO THE VALUE
         OI    CCHHCOMP,CCHHLOW+CCHHX  LOWER -  POSSIBLE STRADDLE
         B     CHECKHI       GO CHECK THE TOP OF THIS EXTENT
SETH1    OI    CCHHCOMP,CCHHHIGH  SET THE FLAG
         B     CHECKHI       GO CHECK THE TOP OF THIS EXTENT
SETEQ1   OI    CCHHCOMP,CCHHEQ   SET THE FLAG
*
*        CHECK THE TOP OF THE EXTENT
*
CHECKHI  EX    R6,CLCEXTHI   DO THE COMPARE
         BE    SETEQ2        EQUAL, GO SET IT
         BL    EXTSET        LOW, GO SET IT
*
*        THIS IS THE ONLY SLIGHTLY TRICKY PART, A STRADDLE
*        IF THE BOTTOM OF THE EXTENT IS LOWER THAN THE VALUE AND THE
*        TOP OF THE EXTENT IS HIGHER THAN THE VALUE, THEN THE
*        EQ FLAG SHOULD BE SET TOO.
*
         OI    CCHHCOMP,CCHHHIGH  SET THE HIGH FLAG
         TM    CCHHCOMP,CCHHX     WAS THE BOTTOM LOWER THAN THE VALUE?
         BZ    EXTSET        NO, SKIP ON
SETEQ2   OI    CCHHCOMP,CCHHEQ    SET THE EQ FLAG
*
*        FINISHED WITH THAT EXTENT, CHECK FOR MORE
*
EXTSET   DS    0H
         LA    R1,1(R1)      INCREMENT THE EXTENT COUNTER
         CR    R1,R2         CHECK THE EXTENT COUNTER
         BNL   LIMCOPER      THAT'S ALL FOLKS
         TM    CCHHCOMP,CCHHHIGH+CCHHEQ+CCHHLOW  ARE THEY ALL SET?
         BNO   EXTNEXT       NO, CONTINUE LOOKING
*                            YES, STOP NOW - ALL THE FLAGS ARE SET
LIMCOPER L     R4,REFOPER    GET THE NUMERIC VALUE OF THE KEY
         IC    R4,CCHHTAB(R4)  GET A FLAG MASK
         EX    R4,CCHHOPER   CHECK TO SEE IF THE CONDITION IS SET
         BZ    COMPNO        NOT THERE
         B     COMPYES       YES
*
*        EXECUTED INSTRUCTIONS TO GET THE ADDRESS OF THIS EXTENT
*
GETEXT   DC    AL2(DS1EXT1-DS1EXT1)    1ST EXTENT OFFSET       25JUN84
         DC    AL2(DS1EXT2-DS1EXT1)    2ND "                   25JUN84
         DC    AL2(DS1EXT3-DS1EXT1)    3RD "                   25JUN84
         $FORMEX ,                     4-16 EXT                25JUN84
         $FORMEX X1                    17-   EXTENT            25JUN84
         $FORMEX X2                    30-   EXTENT            25JUN84
         $FORMEX X3                    43-   EXTENT            25JUN84
         $FORMEX X4                    56-   EXTENT            25JUN84
         $FORMEX X5                    69-   EXTENT            25JUN84
         $FORMEX X6                    82-   EXTENT            25JUN84
         $FORMEX X7                    95-   EXTENT            25JUN84
         $FORMEX X8                    108-  EXTENT            25JUN84
         $FORMEX X9                    121-  EXTENT            25JUN84
GETEXMAX DC    AL2((*-GETEXT)/2)       MAX                     25JUN84
*                                                              25JUN84
*
*        ISSUE ERROR MESSAGES AND RETURN
*
OBT3ERR  VTOCMSG OBT3ERRM   OBTAIN ERROR MESSAGE
CHECKOUT LA    R15,8          EXCLUDE THIS DATA SET
         B     CHEKRET        RETURN
*
CHECKIN  SR    R15,R15        CLEAR THE REGISTER, PROCESS THIS DATA SET
CHEKRET  LEAVE EQ
*
*
         EJECT
*
*        ROUTINES USED ABOVE
*
         EJECT
*
*        PDLNUM - CONVERT FROM CHARACTERS ( EBCDIC ) TO AN INTEGER
*              BINARY FORM, PASSED BACK VIA REGISTER 15
*              A PARSE PDE IS THE INPUT AS SHOWN IN THE SAMPLE BELOW
*                       LA    R1,PDL     POINT TO THE PARSE DECRIPTION
*                       BAL   R8,PDLNUM  GO CONVERT TO NUMERICS
*              THE ROUTINE WILL TERMINATE IF IT FINDS NON-NUMERICS
*                 ANY CHARACTERS OTHER THEN 0-9, +, -
*              REGISTERS 1, 2, 5, 6, AND 7 ARE USED
*
PDLNUM   STM   R1,R8,PDLNSAVE SAVE THE REGISTERS
         LH    R2,4(R1)       GET THE STRING ADDRESS
         L     R1,0(R1)       GET THE STRING ADDRESS
         MVI   PDLMINUS,0     CLEAR THE NEGATIVE NUMBER FLAG
         SR    R5,R5          CLEAR THE CHARACTER COUNTER
         SR    R15,R15        CLEAR THE ANSWER
PDLLOOP  LA    R6,0(R5,R1)    POINT TO THIS DIGIT
         LA    R5,1(R5)       GET TO THE NEXT DIGIT
         CR    R5,R2          IS THIS THE END OF THE STRING?
         BH    PDLFINI        YES, EXIT
         SR    R7,R7          CLEAR A WORK REGISTER
         IC    R7,0(R6)       GET THE CHARACTER
         SH    R7,PDLH240     SUBTRACT THE CHARACTER C'0'
         BM    PDLSP          IF NEGATIVE, CHECK SPECIAL CHARACTERS
         MH    R15,PDLH10     IT'S A DIGIT, MULTIPLY PRIOR NUM BY TEN
         AR    R15,R7         ADD ON THE NEW DIGIT
         B     PDLLOOP        AND LOOP FOR MORE
*
*        CHECK FOR SPECIAL CHARACTERS
*
PDLSP    CLI   0(R6),C' '     IS IT A BLANK?
         BE    PDLLOOP        THEN IT'S OK
         CLI   0(R6),C'+'     IS IT A PLUS?
         BE    PDLLOOP        THAT'S ALSO OK
         CLI   0(R6),C'-'     IS IT A MINUS?
         BNE   PDLFINI        NO, JUST QUIT
         MVI   PDLMINUS,1     YES, NOTE IT
         B     PDLLOOP        AND LOOK FOR MORE
*
*        QUIT, AFTER SETTING R15 TO NEGATIVE IF NEEDED
*
PDLFINI  CLI   PDLMINUS,1     WAS A MINUS SIGN FOUND?
         BNE   PDLLEAVE       NO, EXIT
         LNR   R15,R15        YES, MAKE IT NEGATIVE
PDLLEAVE LM    R1,R8,PDLNSAVE RESTORE THE REGISTERS
         BR    R8             RETURN
PDLH10   DC    H'10'
PDLH240  DC    H'240'
         EJECT
*
*        ROUTINE TO CONVERT A TEXT DSCB ITEM
*        INTO ITS KEY NUMBER
*        INPUT IS REG 4 - IKJIDENT PTR
*        OUTPUT IS REG 15 - KEY NUMBER
*        ENTRY VIA BAL   R8,GETKEY
*
GETKEY   L     R1,ATABTITL     POINT TO THE TABLE
         LA    R1,12(R1)     POINT TO THE FIRST ENTRY
         LA    R15,1           SET UP THE KEY NUMBER COUNTER
         L     R6,0(R4)      POINT TO THE ENTERED TEXT
         ICM   R3,3,4(R4)    GET THE LENGTH OF THE ENTERED TEXT
         BNP   GETKNOTF      NOT FOUND IF ZERO
         BCTR  R3,0          MINUS ONE FOR THE EX
GETKLOOP LA    R2,4(R1)      POINT TO THE COMPARISON TEXT
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
GETKSTD  EX    R3,GETKCOMP   COMPARE THE KEY TEXT
         BE    GETKFND       I FOUND IT
         LA    R1,12(R1)     GET TO THE NEXT KEY
         LA    R15,1(R15)    INCREMENT THE KEY COUNTER
         CH    R15,H26       CHECK FOR THE END OF THE TABLE
         BNH   GETKLOOP      NOT YET, KEEP LOOKING
*
*        KEY WAS NOT FOUND, SEND BACK A ZERO
*
GETKNOTF SR    R15,R15       SET UP THE ZERO AND RETURN
GETKFND  BR    R8            JUST RETURN
GETKCOMP CLC   0(0,R6),0(R2) EXECUTED TEXT COMPARE
H26      DC    H'26'
         EJECT
*
*        ROUTINE TO CONVERT THE OPERATOR TEXT
*        INTO A NUMERIC VALUE
*
GETOPER  LA    R15,1         NUMERIC VALUE COUNTER
GETOLOOP LR    R14,R15       GET THE NUMBER
         SLA   R14,1         MULTIPLY BY 2
         LA    R14,OPERS(R14)      RELOCATE IT
         CLC   0(2,R14),0(R1)      IS THIS THE TEXT?
         BE    GETOFND       YES, RETURN THE NUMBER
         LA    R15,1(R15)    NO, TRY THE NEXT ONE
         CH    R15,H7        CHECK FOR THE END
         BL    GETOLOOP      NOT THERE YET, KEEP TRYING
         VTOCMSG OPERERR,OPERERR2  ISSUE THE MESSAGE
         LA    R15,1         SET THE DEFAULT OPERATOR, EQ
GETOFND  BR    R8            THEN RETURN
         EJECT
*
*        PROGRAM CONSTANTS
*
COMPLIM  CLC   0(0,R2),0(R1)  COMPARE KEYWORD TO VALUE
MOVECCHH MVC   DOUBLE(0),0(R2)
CLCEXTLO CLC   2(0,R3),0(R5)
CLCEXTHI CLC   6(0,R3),0(R5)
CCHHOPER TM    CCHHCOMP,0
CCHHTAB  DC    X'0040A0206080C0'  CCHHCOMP FLAGS
OPERS    DC    C'  EQNELTLEGTGE'
*    FOR  EQ, NE, LT, LE, GT, GE
EDMASK   DC    XL16'40202020202020202020202020202120'
BLANKS   DC    CL16'                '
STARS    DC    CL16'****************'
BLKTRTAB DC    XL64'00',X'04',XL192'00'
CAMSCON  CAMLST SEEK,*,*,*
COMPARE  CLC   0(0,R6),0(R2)  EXECUTED COMPARE
DECTABLE EQU   *-C'A'   CONVERT EBCDIC HEX TO BINARY
         DC    X'0A0B0C0D0E0F'
         DC    (C'0'-C'F'-1)X'FF'  FILLER
         DC    X'00010203040506070809'
*
*
*
H3       DC    H'3'
H4       DC    H'4'
H7       DC    H'7'
H8       DC    H'8'
H10      DC    H'10'
H12      DC    H'12'
ZERO     DC    F'0'
F100     DC    F'100'
H1000    DC    H'1000'
F127     DC    F'127'
*
*
         PRINT NOGEN
*
*        PROGRAM MESSAGES
*
OBT3ERRM MSG   ' VTOCCHEK - ERROR IN OBTAIN FOR FORMAT 3 DSCB '
KEYERR   MSG   ' VTOCCHEK - LIM, AND, OR OR SUBPARM ERROR - XXXXXX '
CCHHLEN  MSG   ' VTOCCHEK - CCHH SHOULD BE 4 OR 8 HEX CHARACTERS '
OPERERR  MSG   ' VTOCCHEK - OPERATOR WAS NOT EQ, NE, LT, LE, GT, OR GE'
OPERERR2 MSG   '          - WILL ASSUME EQ'
*
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
CHEKWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
CHARS    DS    CL16           CONVERSION TO CHARACTERS
CAMSEEK  CAMLST SEEK,*,*,*
CAMLEN   EQU   *-CAMSEEK
         DS    0D
CYLH     DS    F
         DS    X              PAD FOR CCHH
EQ       EQU   1              EQUATES FOR OPERATOR VALUES
NE       EQU   2
LT       EQU   3
LE       EQU   4
GT       EQU   5
GE       EQU   6
HWORK    DS    H
LIMVAL   DS    F
NUMBERL  DS    F
NUMLENL  DS    H
FLAGNML  DS    X
NUMKEYL  DS    X
NUMBER1  DS    F
NUMLEN1  DS    H
FLAGNM1  DS    X
NUMKEY1  DS    X
NUMBER2  DS    F
NUMLEN2  DS    H
FLAGNM2  DS    X
NUMKEY2  DS    X
NUMBER3  DS    F
NUMLEN3  DS    H
FLAGNM3  DS    X
NUMKEY3  DS    X
REFKEY   DS    F
REFOPER  DS    F
REFVAL   DS    A
REFNUM   DS    A
PDLNSAVE DS    8A             REGISTER SAVE AREA FOR PDLNUM RTN
PDLMINUS DC    X'00'
CHEKDBLW DS    D
CCHHCOMP DS    X
CCHHHIGH EQU   X'80'
CCHHEQ   EQU   X'40'
CCHHLOW  EQU   X'20'
CCHHX    EQU   X'08'
         DS    0D
LENWORK  EQU   *-CHEKWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
         SPACE 3
DSCB1    DSECT
         IECSDSL1 1
         END
VTOCEXCP TITLE 'VTOC COMMAND - VTOC READING SUBROUTINE'
***********************************************************************
*        SPACE
* AUTHOR;  R. F. MORSE, MIT INSTRUMENTATION LABORATORY  AUG 5,1968.
* MODIFIED;   E.BANK, FIREMAN'S FUND  MAY 15,1975.
* MODIFIED;   R.MILLER  FIREMAN'S FUND  MAR 20,1977.
* MODIFIED;   C.HUNTER  CHRYSLER PARTS  SEP 19,1979.             9257
* FUNCTION; THIS SUBROUTINE READS THE VOLUME TABLE OF CONTENTS (VTOC)
*        FROM A DIRECT-ACCESS DEVICE AND PRESENTS IT TO THE CALLER
*        ONE RECORD (DSCB) AT A TIME.
*
* OPERATION; THIS ROUTINE IS A SPECIALIZED SEQUENTIAL ACCESS METHOD
*        FOR VTOC'S.  ITS ADVANTAGE OVER ORDINARY BSAM IS THAT IT READS
*        AN ENTIRE TRACK IN ONE REVOLUTION, THUS SAVING CONSIDERABLE
*        TIME.  THE ROUTINE HAS THREE CALL MODES;
*
*        0 - READ.  RETURNS WITH THE CORE ADDRESS OF A DSCB IN THE 3RD
*              PARAMETER.  THE CORE CONSISTS OF 148 CONSECUTIVE BYTES,
*              CONTAINING THE COUNT (8 BYTES), KEY (44 BYTES), AND DATA
*              (96 BYTES) FOR ONE DSCB.  RETURN CODES (REGISTER 15)
*              ARE;
*                      0 - NORMAL;
*                      4 - END OF FILE, NO DATA PRESENTED;
*                      8 - PERMANENT I/O ERROR.  THE KEY AND DATA AREAS
*                          WILL BE SET TO ZEROS; THE COUNT AREA WILL
*                          CONTAIN THE CORRECT CCHHR.  SINCE READING
*                          IS DONE A TRACK AT A TIME, ALL THE DSCB'S
*                          FOR THAT TRACK WILL BE MARKED IN ERROR.
*                          READING MAY CONTINUE ON TO THE NEXT TRACK.
*
*        1 - OPEN.  THE SECOND PARAMETER SHOULD POINT TO
*              A  6-BYTE FIELD CONTAINING THE VOLSER TO BE USED FOR THE
*              ALLOCATION.
*              RETURN CODES ( REG 15 )  ARE DIRECT FROM DYNAMIC ALLOC.
*                      0 - NORMAL;
*                      4 - UNABLE TO OPEN (PROBABLY MISSING DD CARD);
*                      8 - DD CARD DID NOT REFER TO A DIRECT-ACCESS
*                          DEVICE, OR DEVICE TYPE UNKNOWN.
*
*        2 - CLOSE.  NO ARGUMENTS ARE REQUIRED OR RETURNED.  RETURN
*              CODE ( REG 15 ) IS FROM DYNAMIC UNALLOCATION.
*        3 - READ BY CCHHR (USED TO GET F2 AND F3 DSCBS FROM F1) 9257
*              CODE ( REG 15 ) IS FROM OBTAIN                    9257
*              INPUT: IN 'DS3PTRDS'                              9257
         SPACE
* ENTRY POINTS:  ENTRY IS ALWAYS TO 'VTOCEXCP'.
*        ARGUMENTS ARE:
*                      1 - A(FULL-WORD BINARY ENTRY TYPE);
*                      2 - A(PTR FOR DSCB);
*                      3 - A(VOLSER).
* DATA SETS:  READS VOLUME TABLE OF CONTENTS FROM ANY DIRECT-ACCESS
*        DEVICE.  USES EXCP TO EXECUTE A CHAINED CHANNEL PROGRAM TO
*        READ AN ENTIRE TRACK AT A TIME.
*
* EXTERNAL ROUTINES:  USES SUPERVISOR ROUTINE 'IECPCNVT' TO CONVERT
*        A RELATIVE TRACK NUMBER TO AN ABSOLUTE ADDRESS.
         SPACE
* EXITS - NORMAL;  RETURNS TO CALLER VIA R14 WITH RETURN
*        CODE IN REGISTER 15.       (SEE ABOVE FOR RETURN CODE VALUES.)
*
* TABLES AND WORK AREAS;  USES AN AREA PROVIDED BY THE CALLER FOR
*        ITS SAVEAREA AND FOR WORKING STORAGE IMMEDIATELY FOLLOWING
*        THE PRIOR SAVEAREA.  IT USES GETMAIN TO OBTAIN AN AREA FOR
*        THE DSCB'S TO BE READ INTO.  THIS COULD BE AS LARGE AS
*        8K FOR 3350'S.  IT IS FREED BY THE FINAL CALL.
*
* ATTRIBUTES;  REENTRANT, REFRESHABLE.
         EJECT
* ENTER HERE AND PERFORM STANDARD REGISTER SAVE AREA HOUSEKEEPING.
         SPACE
VTOCEXCP ENTER 12,8                    USE THE PROVIDED SAVEAREA
         USING VTOCWORK,R13   SET ADDRESSABILITY FOR WORK AREA
         LR    R11,R1                  SAVE PARAMETER REGISTER
         USING VTOCOM,R11              SET ADDRESSABILITY
*
*        POINT TO THE DCB FOR LATER REFERENCES
*
         LA    RDCB,VTOCDCB   POINT TO IT
         USING IHADCB,RDCB    SET ADDRESSABILITY
         SPACE
* SELECT MODE FROM CONTENTS AT ADDRESS IN REGISTER 1.
         SPACE
         SR    RWA,RWA                 CLEAR THE REGISTER
         IC    RWA,VTCEFUNC            GET CALL MODE
         SLL   RWA,2                   MODE TIMES 4
         B     *+4(RWA)                BRANCH ON MODE
         SPACE
         B     GETDSB                  MODE 0, GET A DSCB
         B     OPEN                    MODE 1, OPEN A NEW VTOC
         B     CLOSE                   MODE 2, CLOSE
         B     READCCHH                MODE 3, READ BY CCHHR     9257
*        B     RETURN0                 MODE 3 NOT DEFINED, NO OP
         SPACE 3
***********
* RETURNS *
***********
         SPACE
RETURN0  SR    R15,R15                 CLEAR THE RETURN CODE
RETURN   LEAVE EQ                      EXIT WITH THE CURRENT RET CODE
         EJECT
*********************
* MODE 0 - GET DSCB *
*********************
         SPACE
* IF END-OF-FILE WAS REACHED, RETURN AT ONCE.
         SPACE
GETDSB   LA    R15,4                   SET THE RETURN CODE, IN CASE
         TM    MODESW,EOFSW            TEST END-OF-FILE BIT
         BO    RETURN                  RETURN CODE 4 IF ON
         SPACE
* IF CHANNEL PROGRAM HAS BEEN STARTED, GO TO CHECK IT.  OTHERWISE,
* ASSUME THERE IS AT LEAST ONE FULL BUFFER.
         SPACE
         TM    MODESW,XCPRUN           TEST IF EXCP ISSUED
         BO    XCPTEST                 BRANCH IF SO
         SPACE
* SET BUFFER ADDRESS TO NEXT DSCB AND TEST IF LAST ON TRACK.  IF NOT,
* EXIT WITH ITS ADDRESS IN R1.
         SPACE
         L     RWA,DSCBADR             LOAD BUFFER POINTER
         LA    RWA,148(RWA)            ADVANCE TO NEXT DSCB
NDXSTORE ST    RWA,DSCBADR             STORE UPDATED POINTER
         C     RWA,DSCBLIM             TEST IF LAST DSCB IN BUFFER
         BNL   LASTDSCB                BRANCH IF SO
         LR    R1,RWA                  PASS ADDRESS TO USER
GETOUT   ST    R1,DSCBADDR             STORE IT FOR THE CALLER
         TM    MODESW,RDERR            TEST IF ERROR ON THIS TRACK
         BZ    RETURN0                 RETURN CODE 0 IF NOT
         LA    R15,8                   SET THE RETURN CODE
         B     RETURN                  RETURN CODE 8 IF ERROR
         SPACE
* IF THIS IS THE LAST DSCB, MOVE IT TO THE INTERNAL BUFFER AND START
* READING THE NEXT TRACK.
         SPACE
LASTDSCB MVC   BUFF(148),0(RWA)        MOVE LAST DSCB
         L     RWB,TTRN                LOAD RELATIVE TRACK NUMBER
         AL    RWB,=X'00010000'        INCREMENT TO NEXT TRACK
         ST    RWB,TTRN
         BAL   RRET,EXCP               START CHANNEL PROGRAM
         LA    R1,BUFF                 LOAD DSCB ADDRESS FOR CALLER
         B     GETOUT                  TO RETURN
         EJECT
* WAIT FOR CHANNEL PROGRAM COMPLETION AND TEST THE OUTCOME.
         SPACE
XCPTEST  WAIT  ECB=VTOCECB
         SPACE
         NI    MODESW,X'FF'-XCPRUN     TURN EXCP STARTED BIT OFF
         CLI   VTOCECB,X'7F'           TEST COMPLETION CODE
         BNE   PERMERR                 BRANCH IF ERROR
SETDSCBA L     RWA,DSCBSTRT            SET BUFFER POINTER TO 1ST DSCB
         B     NDXSTORE
         SPACE
* PERMANENT ERROR FOR THIS TRACK.  ZERO THE DSCB'S AND FILL IN THE
* CCHHR PORTIONS OF THE COUNT AREAS.
         SPACE
PERMERR  OI    MODESW,RDERR            SIGNAL READ ERROR
         NI    IOBFLAG1,X'FB'          TURN OFF BIT 5 OF IOB FLAG
         NI    DCBIFLGS,X'3F'          TURN OFF BITS 0 AND 1
         L     RWA,DSCBSTRT            LOAD ADDRESS OF FIRST DSCB
         LA    RWB,1                   LOAD RECORD NUMBER
         SPACE
DSCBELUP XC    0(148,RWA),0(RWA)       ZERO DSCB BUFFER
         MVC   0(4,RWA),IOBSEEK+3      INSERT CCHH IN COUNT FIELD
         STC   RWB,4(RWA)              INSERT R IN COUNT FIELD
         LA    RWA,148(RWA)            POINT TO NEXT BUFFER
         LA    RWB,1(RWB)              INCREMENT RECORD NUMBER
         C     RWA,DSCBLIM             TEST FOR LAST BUFFER
         BNH   DSCBELUP
         VTOCMSG TRACKERR       ISSUE THE ERROR MESSAGE
         B     SETDSCBA                BRANCH TO RESET BUFFER POINTER
         EJECT
*****************
* MODE 1 - OPEN *
*****************
         SPACE
* ENTER WITH A DDNAME IN SECOND PARAMETER POSITION.  PERFORM CLOSE
* SUBROUTINE FIRST TO BE SURE EVERYTHING IS INITIALIZED.
         SPACE
OPEN     DS    0H
         BAL   RRET,CLOSESUB           CALL CLOSE SUBROUTINE
         SPACE
*
*        INITIALIZE THE DATA AREAS
*
*        FIRST THE DCB
         MVC   VTOCDCB(DCBLEN),VTOCDCBM  SET UP THE DCB
*
*        SET UP THE JFCB LISTS
*
         LA    R1,JEXLST      POINT TO THE EXIT LIST
         STCM  R1,B'0111',DCBEXLSA  PUT IT INTO THE DCB
         LA    R1,JFCBAREA    POINT TO THE JFCB AREA
         ST    R1,JEXLST      AND PUT THAT INTO THE EXIT LIST
         MVI   JEXLST,X'87'   END OF LIST, JFCB EXIT
         MVI   OPENLIST,X'80' END OF THE OPEN LIST TOO
*        INITIALIZE THE IOB
         MVC   VTOCIOB(IOBCONL),IOBCONST START IT OUT
         LA    R1,VTOCECB     GET THE ECB ADDRESS
         ST    R1,IOBECB      AND STORE IT INTO THE IOB
         ST    RDCB,IOBDCB    STORE THE DCB ADDRESS INTO THE IOB
*        INITIALIZE THE CAMLST
         MVC   DSCBFMT4(4),DSCBCON SET UP THE FIRST WORD
         LA    R1,IOBSEEK+3   SEEK ADDRESS
         ST    R1,DSCBFMT4+4  INTO THE CAMLST
         LA    R1,VOLID       VOLUME SERIAL NUMBER
         ST    R1,DSCBFMT4+8  INTO THE CAMLST
         LA    R1,FMT4        DSCB AREA
         ST    R1,DSCBFMT4+12 INTO THE CAMLST
*        INITIALIZE THE CAMLST FOR READING BY CCHHR (FMT4)       9257
         MVC   DSCBFMT3(12),DSCBFMT4 SET UP LIKE FMT4 CAMLST     9257
         LA    R1,DSCBCCHH    SEEK ADDRESS                       9257
         ST    R1,DSCBFMT3+4  INTO THE CAMLST                    9257
         LA    R1,FMT3        DSCB AREA                          9257
         ST    R1,DSCBFMT3+12 INTO THE CAMLST                    9257
*
*        ALLOCATE THE VTOC OF THE CHOSEN PACK
*
         LA    R1,ADDR        POINT TO THE UNIT ADDRESS
         ST    R1,UNITADDR    SAVE THE ADDRESS
         LA    R1,3           ALSO GET THE LENGTH
         STH   R1,UNITLEN     AND SAVE IT FOR DYNAMIC ALLOCATION MACRO
         LA    R1,VOLID       POINT TO THE VOLUME SERIAL
         ST    R1,VOLADDR     SAVE THE ADDRESS
         LA    R1,6           ALSO GET THE LENGTH
         STH   R1,VOLLEN      AND SAVE IT FOR DYNAMIC ALLOCATION MACRO
*        ALLOC DSN=VTOCNM,VOL=VOLADDR,UNIT=UNITADDR,DISP=SHR,
         ALLOC DSN=VTOCNM,VOL=VOLADDR,UNIT='SYSALLDA',DISP=SHR,  9257  X
               DDNTO=DCBDDNAM,ERROR=S99FAIL
         MVC   FMT3(8),DCBDDNAM    GIVE CALLER A COPY OF DYNAMIC 9257
         OI    MODESW,ALLOCSW          SET ALLOCATE FLAG ON
         SPACE
* OPEN THE VTOC.
         SPACE
*
*        FIRST READ THE JFCB TO SWITCH THE DSNAME TO HEX 04'S
*
         RDJFCB ((RDCB)),MF=(E,OPENLIST)  READ THE JFCB
         LTR   R15,R15        TEST THE RETURN CODE
         BNZ   ERRJFCB        BAD NEWS
         LA    R1,JFCBAREA    POINT TO THE JFCB
         USING JFCB,R1        SET UP ADDRESSABILITY
         MVI   JFCBDSNM,X'04' PUT IN THE FIRST ONE
         MVC   JFCBDSNM+1(L'JFCBDSNM-1),JFCBDSNM  PROPAGATE IT
         OI    JFCBTSDM,JFCNWRIT  DON'T REWRITE IT
         DROP  R1
         OPEN  ((RDCB),(INPUT)),MF=(E,OPENLIST),TYPE=J  OPEN THE VTOC
         TM    DCBOFLGS,OPENBIT        TEST IF OPEN WORKED
         BZ    OPENERR                 ERROR IF OPEN FAILED
         SPACE
* ISSUE AN OBTAIN FOR THE FIRST DSCB ON THE VTOC ( FORMAT 4 )
D3       STM   R2,R13,EXCPSAVE         SAVE OUR REGS
         LA    R3,EXCPSAVE    POINT TO THE REGISTER SAVE AREA
         ICM   R0,B'1111',=X'00000100' FIRST DSCB
         L     R1,DCBDEBAD             DEB ADDRESS
         LA    R2,IOBSEEK              SAVE ADDRESS OF CCHHR
         L     R15,CVT                 GET ADDRESS OF CVT
         L     R15,CVTPCNVT(R15)       GET ADDRESS OF CONVERT ROUTINE
         BALR  R14,R15                 GO TO CONVERT ROUTINE
         LM    R2,R13,0(R3)            GET MY REGS BACK
         OBTAIN DSCBFMT4               GET FORMAT 4 DSCB
         LTR   R15,R15                 DID WE GET IT
         BNZ   OBTERR                  NO - THEN ERROR, KEEP R15
         CLI   DS4IDFMT,X'F4'          MAKE SURE WE HAVE FORMAT 4
         BNE   NOTFMT4                 NO - THEN ERROR
         IC    R15,DS4DEVDT            GET NUMBER OF DSCBS PER TRACK
         ST    R15,NDSCBS              SAVE THE NUMBER OF DSCBS
         OC    NDSCBS,NDSCBS           MAKE SURE NOT ZERO
         BZ    DSCBNUM0                YES - GO TELL CALLER
*
* OBTAIN CORE FOR CHANNEL PROGRAM AND DSCB BUFFERS.
         SPACE
         LA    R0,156                  CORE FOR ONE DSCB AND ITS CCW
         MH    R0,NDSCBS+2             TIMES NUMBER PER TRACK
         AH    R0,=H'15'               PLUS 1 CCW AND ROUNDING
         N     R0,=X'FFFFFFF8'         ROUND TO DOUBLE-WORD MULTIPLE
         ST    R0,CBSIZE               SAVE SIZE OF GOTTEN CORE
         GETMAIN  R,LV=(0)             GET TRACK BUFFERS
         ST    R1,CBADDR               SAVE ADDRESS OF GOTTEN CORE
         OI    MODESW,CBGOT            INDICATE CORE GOTTEN
         SPACE
* GENERATE CHANNEL PROGRAM.  IT CONSISTS OF A 'READ R0' ORDER WITH
* THE SKIP FLAG ON, FOLLOWED BY A 'READ COUNT-KEY-AND-DATA' ORDER FOR
* EACH DSCB.
         SPACE
         L     RWA,NDSCBS              NUMBER OF DSCB'S
         SLL   RWA,3                   TIMES   8
         LA    RWA,8(RWA,R1)           PLUS 8 AND BASE = 1ST BUFFER ADD
         ST    RWA,DSCBSTRT            SAVE ADDRESS OF FIRST BUFFER
         SPACE
         ST    R1,IOBSTART             ADDRESS OF CHANNEL PROGRAM
         MVC   0(8,R1),INITCCW         INSERT FIRST CCW
         LA    RWB,8(R1)               PLACE FOR NEXT CCW
         LA    RWC,1                   BUFFER COUNTER
         SPACE
CCWLOOP  MVC   0(8,RWB),READCCW        INSERT READ CCW FOR ONE DSCB
         ST    RWA,0(RWB)              SET ITS BUFFER ADDRESS
         MVI   0(RWB),READCKD          RESTORE COMMAND CODE
         C     RWC,NDSCBS              TEST BUFFER COUNTER
         BNL   LASTCCW                 BRANCH IF LAST BUFFER
         LA    RWB,8(RWB)              INCREMENT CCW ADDRESS
         LA    RWA,148(RWA)            INCREMENT BUFFER ADDRESS
         LA    RWC,1(RWC)              INCREMENT BUFFER COUNTER
         B     CCWLOOP                 DO NEXT BUFFER
         SPACE
LASTCCW  NI    4(RWB),X'FF'-CC         TURN OFF COMMAND CHAIN BIT
         ST    RWA,DSCBLIM             SAVE ADDRESS OF LAST DSCB BUFFER
         SPACE
* SET OTHER THINGS AND START PROGRAM TO FILL BUFFER.
         SPACE
         SR    R0,R0
         ST    R0,TTRN                 SET RELATIVE TRACK NUMBER TO 0
         NI    MODESW,X'FF'-XCPRUN-RDERR-EOFSW   SET FLAGS OFF
         BAL   RRET,EXCP               START CHANNEL PROGRAM
         B     RETURN0                 INDICATE SUCCESSFUL OPEN
         EJECT
******************
* MODE 2 - CLOSE *
******************
         SPACE
CLOSE    BAL   RRET,CLOSESUB           CALL CLOSED CLOSE SUBROUTINE
         B     RETURN0
         SPACE 2
* IF THE CHANNEL PROGRAM IS RUNNING, WAIT FOR IT BEFORE TAKING FURTHER
* ACTION.
         SPACE
CLOSESUB DS    0H
         TM    MODESW,XCPRUN           TEST IF CHANNEL PROGRAM RUNNING
         BZ    NOEXCP                  BRANCH IF NOT
         WAIT  ECB=VTOCECB             WAIT UNTIL COMPLETE
         NI    MODESW,X'FF'-XCPRUN     TURN RUNNING SWITCH OFF
NOEXCP   DS    0H
         SPACE
* CLOSE THE DCB.
         SPACE
         TM    DCBOFLGS,OPENBIT        TEST IF DCB OPEN
         BZ    NOCLOSE                 BRANCH IF NOT
         CLOSE ((RDCB)),MF=(E,OPENLIST)   CLOSE THE VTOC
NOCLOSE  DS    0H
         SPACE
* FREE UP THE DDNAME AND VOLUME
         SPACE
         TM    MODESW,ALLOCSW          DID WE ALLOCATE A DEVICE
         BNO   NOALLOC                 NO  - THEN NOTHING TO FREEUP
         LA    R1,DCBDDNAM   POINT TO THE DDNAME
         ST    R1,DDNPDL     SAVE IT FOR FREE
         LA    R1,8          GET THE DDNAME LENGTH
         STH   R1,DDNPDL+4   SAVE IT FOR FREE
         FREE  UNALC,DDN=DDNPDL,ERROR=S99FAIL  FREE THE DDNAME
         NI    MODESW,X'FF'-ALLOCSW    TURN OFF ALLOCATE SW
         SPACE
NOALLOC  DS    0H
         SPACE
* RELEASE CORE OBTAINED FOR DSCB BUFFERS.
         SPACE
         TM    MODESW,CBGOT            TEST IF CORE GOTTEN
         BZ    NOFREE                  BRANCH IF NOT
         LM    R0,R1,CBSIZE            LOAD SIZE AND LOCATION
         FREEMAIN  R,LV=(0),A=(1)      FREE CORE
         NI    MODESW,X'FF'-CBGOT      SET CORE GOTTEN BIT OFF
NOFREE   DS    0H
         SPACE
         NI    MODESW,X'FF'-RDERR      CLEAR ERROR SWITCH
         BR    RRET
         EJECT
******************************                                   9257
* MODE 3 - GET DSCB BY CCHHR *                                   9257
******************************                                   9257
READCCHH DS    0H                                                9257
         MVC   DSCBCCHH,DS3PTRDS       COPY CALLERS CCHHR        9257
         OBTAIN DSCBFMT3               GET DSCB INTO FMT3 FIELD  9257
         LTR   R15,R15                 DID WE GET IT             9257
         BNZ   OBTERR                  NO - THEN ERROR, KEEP R15 9257
         B     RETURN0                 YES-GOOD IO               9257
         EJECT                                                   9257
****************
* EXCP ROUTINE *
****************
         SPACE
* CONVERT RELATIVE TRACK ADDRESS IN 'TTRN' TO ABSOLUTE SEEK ADDRESS IN
* 'IOBSEEK', USING SUPERVISOR CONVERSION ROUTINE.
         SPACE
EXCP     DS    0H
         STM   R2,R13,EXCPSAVE         SAVE IMPORTANT REGISTERS
         LA    R3,EXCPSAVE             SAVE REGS FOR RESTORING AFTER CL
         L     R0,TTRN                 LOAD RELATIVE TRACK NUMBER
         L     R1,DCBDEBAD             LOAD DEB ADDRESS
         LA    R2,IOBSEEK              LOAD ADDR TO RECEIVE MBBCCHHR
         L     R15,CVT                 LOAD CVT ADDRESS
         L     R15,CVTPCNVT(R15)       LOAD ADDR OF CONVERT ROUTINE
         BALR  R14,R15                 CONVERT TTRN TO MBBCCHHR
*                                      THAT CLOBBERED BASE REG
         LM    R2,R13,0(R3)            RESTORE REGISTERS
         LTR   R15,R15                 TEST IF EXTENT VIOLATED (RC=4)
         BNZ   SETEOF                  IF SO, MEANS END-OF-FILE
         CLC   DS4HPCHR,IOBSEEK+3      CHECK FOR THE LAST FMT1
         BL    SETEOF                  IF SO, PRETEND END-OF-FILE
         SPACE
* ZERO ECB AND START CHANNEL PROGRAM.
         SPACE
         SR    R0,R0
         ST    R0,VTOCECB              CLEAR ECB
         NI    MODESW,X'FF'-RDERR      RESET ERROR SWITCH
         EXCP  VTOCIOB                 START CHANNEL PROGRAM
         OI    MODESW,XCPRUN           SET 'RUNNING' FLAG
         BR    RRET
         SPACE
* WHEN EXTENT IS VIOLATED, SET END-FILE AND EXIT VIA CLOSE ROUTINE.
         SPACE
SETEOF   OI    MODESW,EOFSW            SET END-OF-FILE BIT
         BR    RRET                    EXIT                      9257
         EJECT
********************************
* DAIRFAIL ROUTINE             *
********************************
S99FAIL  LR    RRCODE,R15     SAVE THE RETURN CODE               9257
         S99FAIL MF=(E,S99FLIST,S99FLEN)  ISSUE THE APPROPRIATE MSG
         LR    R15,RRCODE     RELOAD THE RETURN CODE
         B     RETURN         AND THEN EXIT
         SPACE 3
*
*        VARIOUS OTHER ERROR ROUTINES
*
OPENERR  VTOCMSG OPENERRM  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
OBTERR   VTOCMSG OBTERRM  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
NOTFMT4  VTOCMSG NOTFMT4M  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
DSCBNUM0 VTOCMSG DSCBNUMM  ISSUE THE MESSAGE
         B     ERRET          THEN RETURN
*
ERRJFCB  VTOCMSG ERRJFCBM   ERROR IN READING JFCB
*
ERRET    LA    R15,8          SET AN ERROR RETURN CODE
         B     RETURN         THEN EXIT
*
         EJECT
********************************
* CONSTANTS, VARIABLES, ETC... *
********************************
         SPACE
*        ERROR MESSAGES
*
OPENERRM MSG   ' VTOCEXCP - ERROR IN OPENING VTOC '
OBTERRM  MSG   ' VTOCEXCP - ERROR IN OBTAIN '
NOTFMT4M MSG   ' VTOCEXCP - FORMAT 4 DSCB WAS NOT FIRST'
DSCBNUMM MSG   ' VTOCEXCP - THE FORMAT 4 DSCB HAS DSCB S/TRK = 0 '
TRACKERR MSG   ' VTOCEXCP - A READ ERROR OCCURRED ON THE VTOC '
ERRJFCBM MSG   ' VTOCEXCP - A RDJFCB ERROR OCCURRED '
         SPACE
INITCCW  CCW   READR0,0,CC+SLI+SKIP,8
READCCW  CCW   READCKD,0,CC,148
         SPACE
DSCBCON  CAMLST SEEK,0,0,0   FILLED IN WITH IOBSEEK+3, VOLID, FMT4
         EJECT
* DATA CONTROL BLOCK
         PRINT   GEN
VTOCDCBM DCB   DDNAME=VTOCDD,MACRF=(E),EXLST=1
DCBLEN   EQU   *-VTOCDCBM
         SPACE
* IOB FOR CHANNEL PROGRAM
         SPACE
IOBCONST DS    0D
         DC    X'42000000'     COMMAND CHAIN, NOT RELATED
         DC    A(0)            ECB ADDRESS
         DC    2F'0'
         DC    A(0)            CHANNEL PROGRAM BEGINNING
         DC    A(0)            DCB ADDRESS
         DC    X'03000000'
         DC    F'0'
         DC    D'0'            INITIAL SEEK ADDRESS
IOBCONL  EQU   *-IOBCONST
* VTOC NAME FOR ALLOCATION
VTOCNM   DC    A(VTOCNAME)
         DC    Y(12)
VTOCNAME DC    CL12'FORMAT4.DSCB'   DATA SET NAME FOR VTOC
*
*
         LTORG
         EJECT
* SECTION DEFINITION AND REGISTER ASSIGNMENTS;
         SPACE 2
RWA      EQU   2
RWB      EQU   3
RWC      EQU   4
RDCB     EQU   8              DCB POINTER
RRCODE   EQU   10              RETURN CODE REGISTER
RRET     EQU   9               LOCAL SUBROUTINE EXIT REGISTER
         SPACE 3
* TAGS FOR CHANNEL COMMANDS AND FLAG BITS:
         SPACE
READR0   EQU   X'16'           READ RECORD 0
READCKD  EQU   X'1E'           READ COUNT, KEY, AND DATA
         SPACE
CC       EQU   X'40'           COMMAND CHAIN FLAG
SLI      EQU   X'20'           SUPPRESS LENGTH INDICATION FLAG
SKIP     EQU   X'10'           SKIP DATA TRANSFER FLAG
         SPACE 3
* COMMUNICATION VECTOR TABLE (CVT) DEFINITIONS:
         SPACE
CVT      EQU   16              LOCATION OF CVT BASE ADDRESS
CVTPCNVT EQU   28              OFFSET TO CONVERT ROUTINE ADDRESS
         EJECT
*
*        AREA USED BY VTOCREAD, PASSED VIA R13
*
VTOCWORK DSECT
         DS    18F             SAVE AREA
         SPACE
EXCPSAVE DS    18F             INTERNAL SAVE AREA
CBSIZE   DS    2F              SIZE AND LOCATION OF GOTTEN CORE
CBADDR   EQU   CBSIZE+4
NDSCBS   DS    F               NUMBER OF DSCB'S PER TRACK
DSCBSTRT DS    F               ADDRESS OF 1ST DSCB BUFFER
DSCBLIM  DS    F               ADDRESS OF LAST DSCB BUFFER
DSCBADR  DS    F               ADDRESS OF CURRENT DSCB
TTRN     DS    F               RELATIVE TRACK NUMBER
VOLADDR  DS    A               FAKE PDL FOR ALLOC MACRO - ADDRESS
VOLLEN   DS    H                       AND LENGTH OF VOLID
UNITADDR DS    A               FAKE PDL FOR ALLOC MACRO - ADDRESS
UNITLEN  DS    H                       AND LENGTH OF UNIT ADDRESS
DDNPDL   DS    2F            SPACE FOR DDNAME PDL
         SPACE
* MODE SWITCH AND BIT DEFINITIONS
         SPACE
MODESW   DC    X'00'
CBGOT    EQU   X'80'           CORE GOTTEN FOR BUFFER
XCPRUN   EQU   X'40'           CHANNEL PROGRAM STARTED BUT NOT CHECKED
RDERR    EQU   X'20'           PERMANENT I/O ERROR
EOFSW    EQU   X'10'           END-OF-FILE SENSED
ALLOCSW  EQU   X'08'           ALLOCATE VOLUME FLAG
         SPACE
VTOCDCB  DCB   DDNAME=VTOCDD,MACRF=(E),EXLST=1
         SPACE
OPENBIT  EQU   X'10'
OPENLIST DS    2F
         SPACE
* IOB FOR CHANNEL PROGRAM
         SPACE
VTOCIOB  DS    0D
IOBFLAG1 DC    X'42000000'     COMMAND CHAIN, NOT RELATED
IOBECB   DC    A(VTOCECB)
         DC    2F'0'
IOBSTART DC    A(0)            CHANNEL PROGRAM BEGINNING
IOBDCB   DC    A(VTOCDCB)
         DC    X'03000000'
         DC    F'0'
IOBSEEK  DC    D'0'            INITIAL SEEK ADDRESS
         SPACE
* EVENT CONTROL BLOCK FOR CHANNEL PROGRAM:
         SPACE
VTOCECB  DC    F'0'            EVENT CONTROL BLOCK
         SPACE 3
* INTERNAL BUFFER FOR LAST DSCB
BUFF     DS    XL148
         SPACE 2
DSCBFMT4 CAMLST SEEK,IOBSEEK+3,VOLID,FMT4
DSCBFMT3 CAMLST SEEK,IOBSEEK+3,VOLID,FMT3                        9257
DSCBCCHH DS    XL5                      FOR READING DSCB DIRECT  9257
         SPACE
*   WORK AREA FOR DYNAMIC ALLOCATION
         DYNSPACE
S99FLIST DS    XL(S99FLEN)
         SPACE
*
*        JFCB EXIT LIST AND AREA
*
JEXLST   DS    F
JFCBAREA DS    XL176
         DS    0D
VTOCWLEN EQU   *-VTOCWORK
         SPACE 2
         PRINT GEN
         VTOCOM
         PRINT NOGEN
         SPACE 2
         IEFZB4D0
         SPACE 2
         IEFZB4D2
         SPACE 2
         DCBD  DEVD=DA,DSORG=PS
         SPACE 2
JFCB     DSECT
         IEFJFCBN
         END
VTOCFORM TITLE 'VTOC COMMAND - FORMAT ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
* FUNCTION -   FORMAT THE DATA INTO THE VTFMT  DSECT FROM THE         *
*              FORMAT 1 ( AND 3 IF NEEDED ) DSCB.  THIS ROUTINE       *
*              ALSO GETS THE AREA TO CONTAIN THE FORMATTED            *
*              DSCB INFORMATION.                                      *
*                                                                     *
* OPERATION -  FIRST GET AN AREA FROM THE CURRENT BLOCK, OR GET       *
*              A BLOCK ( 32K ) OF STORAGE TO USE FOR THE FORMATTED    *
*              DSCB'S.  MOVE THE DATA OVER FROM THE FORMAT 1 DSCB.    *
*              THE SPACE CALCULATIONS MAY NEED THE FORMAT 3 DSCB.     *
*              CATALOG INFORMATION IS OBTIANED VIA LOCATE.  SOME      *
*              OF THE DSCB INFORMATION IS CONVERTED HERE.             *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, CURRENT FORMATTED DSCB, LOCATE         *
*                                                                     *
* OUTPUT -     THE FORMATTED DSCB INFORMATION WITH ITS ADDRESS IN     *
*              FORMATAD.                                              *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*         MODIFIED   BY C.    HUNTER  (313) 497-0524            0102  *
*         MODIFIED   BY C.    HUNTER  (313) 540-0900           25JUN84*
*                                                                     *
*                                                                     *
***********************************************************************
*
         EJECT
         MACRO
&LAB     DS1TST  &FIELD,&VALUE,&CODE
&LAB     TM    DS1&FIELD,X'&VALUE'  TEST IT
         BNO   D&SYSNDX       IF NOT THERE, SKIP ALONG
         MVC   VTF&FIELD,=CL3'&CODE'
D&SYSNDX DS    0H
         MEND
         MACRO                                                 25JUN84
         $FORMEX &I                                            25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+00-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+10-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+20-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3EXTNT+30-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+00-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+10-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+20-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+30-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+40-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+50-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+60-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84
         DC    AL2(FMT3&I.-FMT3+DS3ADEXT+70-FMT3)              25JUN84
         MEND                                                  25JUN84
*
*
         EJECT
VTOCFORM ENTER 12,16          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING FORMWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
         SPACE 3
*
*        CHECK FOR THE FIRST TIME THROUGH
*        IF SO, PERFORM SOME INITIALIZATION
*
         CLI   FIRSTFRM,0     IS THIS THE FIRST TIME?
         BNE   GETAREA        NO, KEEP ON TRUCKIN'
*
*        ROUTINE INITIALIZATION
*
         MVI   FIRSTFRM,255   NOTE THE INITIALIZATION AS DONE
         MVC   CAMLOC(CAMLEN),CAMCONST  SET UP THE CAMLST
*
*        FIND OR GET AN AREA FOR THE FORMATTED DSCB
*              FIRST SEE HOW BIG IT IS
*
GETAREA  L     R7,DSCBADDR    POINT TO THE DSCB
         LA    R7,8(R7)       GET PAST THE HEADER
         USING DSCB1,R7       SET ADDRESSABILITY
         LH    R1,DSNLEN     GET THE DSNAME LENGTH
         LA    R4,VTFMTL(R1)  GET THE FORMATTED DSCB LENGTH
*
*        SEE IF THE CURRENT BLOCK CAN HANDLE IT
*
FORMFIT  L     R3,VTCCURLN    GET THE CURRENT AVAILABLE
         SR    R3,R4          SEE IF IT WILL FIT
         BM    GOGETMN        NO, GET ANOTHER BLOCK
*
*        NO SWEAT, GET THE SPACE FROM THIS BLOCK
*
         ST    R3,VTCCURLN    STORE THE NEW ( REDUCED ) CURRENT LENGTH
         L     R3,VTCCURAD    POINT TO THE CURRENT ADDRESS
         LA    R5,0(R3,R4)    POINT TO THE END OF THE BLOCK
         ST    R5,VTCCURAD    AND PLACE THE NEW AVAILABLE ADDRESS
*
*        NOW FILL IN THE DATA IN THE FORMATTED DSCB
*
         USING VTFMT,R3       SET FORMATTED DSCB ADDRESSABILITY
         ST    R3,FORMATAD    SAVE THIS BLOCK'S ADDRESS
         XC    VTFNEXT,VTFNEXT  CLEAR THE SORT POINTER
         MVC   VTFVOLUM,VOLID SAVE THE VOLUME SERIAL NUMBER
         LH    R1,DSNLEN     GET THE LENGTH OF THE DSNAME
         STH   R1,VTFDSNL     SAVE THE DSNAME LENGTH
         BCTR  R1,0           SUBTRACT ONE FOR THE EX
         EX    R1,MOVEDSN     MOVE IN THE DSNAME
         MVC   VTFNOEPV,DS1NOEPV  NUMBER OF EXTENTS
         MVC   VTFLRECL,DS1LRECL  LOGICAL RECORD LENGTH
         MVC   VTFBLKSZ,DS1BLKL   BLOCK SIZE
*
*     MOVE IN THE CREATION DATE, EXPIRATION DATE, AND LAST ACCESS DATE
*
         MVC   VTFCREDT,DS1CREDT  MOVE OVER CREATION DATE
         MVC   VTFEXPDT,DS1EXPDT  MOVE OVER EXPIRATION DATE
         MVC   VTFLSTAC,DS1REFD   MOVE OVER LAST ACCESS DATE
*
*        FORMAT THE RECORD FORMAT INTO CHARACTERS
*
*
         MVC   VTFRECFM,BLANKS  BLANK THE FIELD TO START
         MVC   VTFACTON,BLANKS  ANOTHER BLANK FIELD
         MVI   VTFDSTYP,C' ' AND STILL ANOTHER
         LA    R2,VTFRECFM    POINT TO THE FIELD
         TM    DS1RECFM,X'C0' UNKNOWN RECFM?
         BZ    RECFM2         YES, TROUBLE
         TM    DS1RECFM,X'40' IS IT FIXED?
         BNZ   RECFM3         NO, KEEP TRYING
         MVI   0(R2),C'F'     YES, SET UP THE FIRST CHAR
         LA    R2,1(R2)       AND BUMP THE POINTER
         B     RECFM2         CHECK OTHER ATTRIBUTES
RECFM3   TM    DS1RECFM,X'80' SEE IF IT'S V OR U
         BZ    RECFM4         VARIABLE RECFM
         MVI   0(R2),C'U'     RECFM = U
         B     RECFM4A        ADD TO THE POINTER AND KEEP LOOKING
RECFM4   MVI   0(R2),C'V'     VARIABLE
RECFM4A  LA    R2,1(R2)       GET PAST THIS CHAR
RECFM2   DS    0H
RECFM5   TM    DS1RECFM,X'10' IS IT BLOCKED?
         BZ    RECFM6         NO, SKIP ON
         MVI   0(R2),C'B'     YES, SET THE SYMBOL
         LA    R2,1(R2)       GET PAST THE CHAR
RECFM6   TM    DS1RECFM,X'08' IS IT SPANNED OR STANDARD?
         BZ    RECFM6A        NO
         MVI   0(R2),C'S'     YES, SET IT
         LA    R2,1(R2)       GET PAST THIS CHARACTER
RECFM6A  TM    DS1RECFM,X'20' CHECK TRACK OVERFLOW
         BZ    RECFM7         NO DICE
         MVI   0(R2),C'T'     YES, SET IT
         LA    R2,1(R2)       PUSH THE POINTER ON
RECFM7   TM    DS1RECFM,X'04' IS IT ASA CONTROL
         BZ    RECFM8         NO, SKIP ON
         MVI   0(R2),C'A'     YES, SET IT
         LA    R2,1(R2)       GET PAST THIS CHAR
RECFM8   TM    DS1RECFM,X'02' HOW ABOUT MACHINE CARRIAGE CONTROL
         BZ    RECFM9         NO, SKIP ON
         MVI   0(R2),C'M'     YES, SET IT
RECFM9   DS    0H
*
*        FORMAT THE DSORG
*
         MVC   VTFDSORG,=CL3'   '  CLEAR THE FIELD
         DS1TST DSORG,80,IS   TRY ISAM
         DS1TST DSORG,40,PS   TRY SEQUENTIAL
         DS1TST DSORG,20,DA   TRY DIRECT ACCESS
         DS1TST DSORG,02,PO   TRY PARTITIONED
         CLC   DS1DSORG(2),=X'0008'  IS IT VSAM?
         BNE   DSORG05       NO, KEEP LOOKING
         MVC   VTFDSORG,=CL3'VS ' YES, FLAG IT
DSORG05  TM    DS1DSORG,X'01'      IS IT UNMOVEABLE?
         BNO   DSORG06       NO, KEEP ON TRUCKIN'
         MVI   VTFDSORG+2,C'U'     YES, NOTE IT
DSORG06  DS    0H
*
*        FORMAT THE SECONDARY ALLOCATION
*
         SR    R1,R1          CLEAR A WORK REGISTER
         IC    R1,DS1SCALO    GET THE ALLOCATION FLAG
         SRL   R1,6           REMOVE THE BOTTOM 6 BITS ( 75 CENTS )
         IC    R2,SECAL(R1)   GET THE CHARACTER CODE
         STC   R2,VTFSECAL    AND SAVE IT FOR LATER
         MVC   VTFSECAM,DS1SCALO+2  SAVE THE SECONDARY AMOUNT TOO
         MVI   VTFROUND,C'N'  SET CODE FOR NO ROUND
         TM    DS1SCALO,X'01' SEE IF ROUND WAS SET
         BNO   PROTFORM       NO, THE CODE IS SET RIGHT
         MVI   VTFROUND,C'R'  YES, RESET THE CODE
*
*        FORMAT THE PASSWORD PROTECTION
*
PROTFORM TM    DS1DSIND,X'14' CHECK THE PASSWORD BITS
         BO    PROTWRIT       WRITE PROTECT IS X'14'
         BM    PROTREAD       READ PROTECT IS X'10'
         MVI   VTFPROT,C'N'   NO PASSWORD PROTECTION
         B     PROTEND        END OF PROTECTION FORMATTING
PROTWRIT MVI   VTFPROT,C'W'   SET CODE FOR WRITE PROTECT
         B     PROTEND        THEN CHECK OTHER ITEMS
PROTREAD MVI   VTFPROT,C'R'   SET CODE FOR READ/WRITE PROTECT
PROTEND  DS    0H             END OF PROTECTION FORMATTING
*
*        FORMAT THE CATLG
*
         MVI   VTFCATLG,C' ' INITIALIZE IT TO BLANKS
         CLI   CATK+1,0       SHOULD WE DO THE LOCATE?
         BE    CATEND         NO, SKIP PAST IT
*
*        SET UP THE CAMLST
*
         LA    R1,DS1DSNAM    POINT TO THE DSNAME
         ST    R1,CAMLOC+4    SAVE IT IN THE CAMLST
         LA    R1,LOCWORK     LOCATE WORKAREA
         ST    R1,CAMLOC+12   SAVE IT IN THE CAMLST
         LOCATE CAMLOC        CHECK THE CATALOG
         LTR   R15,R15        TEST THE CATALOG RETURN CODE
         BZ    CATOK          ZERO, THERE IS AN ENTRY
         MVI   VTFCATLG,C'N'  SET CODE FOR NOT CATALOGED
         CH    R15,H8         SEE IF THAT'S THE CASE
         BE    CATEND         YES, LET IT STAND
         MVI   VTFCATLG,C'E'  CATALOG ERROR, PROBLEMS
*
*        CATALOG ENTRY IS THERE, SEE THAT THE VOLUME IS THIS ONE
*
CATOK    MVI   VTFCATLG,C'C'  SET UP AS A GOOD ENTRY
         CLC   VOLID,LOCWORK+6  COMPARE THE VOLUME SERIAL NUMBERS
         BE    CATEND         GOOD, WE'RE DONE
         MVI   VTFCATLG,C'W'  WRONG VOLUME, NOT CATALOGED
CATEND   DS    0H
*
*        FORMAT THE ALLOCATION AND USED QUANTITIES
*
         SPACE
*        CHECK THROUGH THE EXTENTS
         SPACE
         SR    R2,R2          CLEAR A WORK REGISTER
         ICM   R2,B'0001',DS1NOEPV  GET THE NUMBER OF EXTENTS
         BZ    SPACEND        NO EXTENTS MEANS NO SPACE
         SR    R4,R4          ZERO THE SPACE COUNTER FOR THE DATA SET
*
*        GET EACH EXTENT AND PROCESS IT
*
         SR    R6,R6          FIRST EXTENT
EXTNEXT  LR    R5,R6          GET THE CURRENT EXTENT NUMBER
         CH    R5,GETEXMAX             MAX EXTENTS             25JUN84
         BH    SPACEND                 TOO MANY - SKIP         25JUN84
         SLL   R5,1                    MULT. BY 2              25JUN84
         LH    R5,GETEXT(R5)           GET EXTENT OFFSET       25JUN84
         CH    R6,=H'2'                IS EXTENT IN F1 OR F3   25JUN84
         BH    EXTNXF3                 F3                      25JUN84
         LA    R5,DS1EXT1(R5)          +F1 BASE = ADDR OF EXT  25JUN84
         B     EXTNXFX                 CONTINUE                25JUN84
EXTNXF3  DS    0H                                              25JUN84
         LA    R5,FMT3(R5)             +F3 BASE = ADDR OF EXT  25JUN84
EXTNXFX  DS    0H                                              25JUN84
*
*        PROCESS THIS EXTENT
*
         USING XTDSECT,R5     SET ADDRESSABILITY
         CLI   XTFLAGS,XTNOEXT  IS THERE AN EXTENT
         BE    NOEXT          NO, THE EXTENT ISN'T THERE
         CLI   XTFLAGS,XTCYLBD  IS IT ON CYLINDER BOUNDARIES
         BNE   FORMALOC       NO, DO IT FOR CYLS AND TRACKS
*
*        CYLINDER BOUNDS - BE SURE THE ALLOCATION IS CORRECT
*
         ICM   R1,B'0011',XTLOWHH GET THE LOWER TRACK
         BZ    LOWOK          IT'S ZERO
         MVC   VTFACTON(6),=C'CYLERR'  NOTE THE ERROR
         MVI   VTFACTON+6,C'L'  ON THE LOW CCHH
LOWOK    LH    R1,XTHIHH      GET THE HIGH TRACK
         LA    R1,1(R1)       ADD ONE FOR ZERO ADDRESSING
         CH    R1,DS4DEVSZ+2  IS THIS THE NUMBER OF TRACKS/CYL
         BE    FORMALOC       YES, GO CALCULATE
         MVC   VTFACTON(6),=C'CYLERR'  NOTE THE ERROR
         MVI   VTFACTON+7,C'H'  ON THE HIGH CCHH
*
*        GET THE SPACE FOR NON-CYLINDER ALLOCATIONS
*
FORMALOC LH    R1,XTHICC      GET THE HIGH CYLINDER
         SH    R1,XTLOWCC     MINUS THE LOW CYLINDER
         MH    R1,DS4DEVSZ+2  TIMES THE NUMBER OF TRACKS PER CYLINDER
         LH    R8,XTHIHH      GET THE HIGH TRACK
         SH    R8,XTLOWHH     MINUS THE LOW TRACK
         AR    R8,R1          TRACKS IN THIS EXTENT ( MINUS 1 )
         LA    R4,1(R4,R8)    ADD THE TRACKS TOGETHER FOR THIS DATA SET
*
*        GET THE NEXT EXTENT
*
NOEXT    LA    R6,1(R6)       INCREMENT THE EXTENT COUNTER
         CR    R6,R2          CHECK FOR THE END
         BL    EXTNEXT        NOT YET, KEEP GOING
*
*        ALL THE EXTENTS ARE SUMMED REGISTER 4 HAS THE SUM
*
         BAL   R8,SPACUNIT    CHANGE IT TO THE APPROPRIATE UNITS
         ST    R4,VTFALLOC    STORE IT FOR LATER
SPACEND  DS    0H
*
*        GET THE TRACKS USED
*
         SR    R4,R4          CLEAR THE TRACK ( WOO WOO )
         CLC   DS1LSTAR,ZEROES IS THE TRACK USED COUNTER SET?
         BNE   USEDOK         YES, ACCEPT IT
*        NO, SEE IF THE ZERO IS VALID
         TM    DS1DSORG,X'40' IS IT SEQUENTIAL?
         BO    USEDOK0        YES,THE ZERO IS VALID
         CLC   DS1DSORG(4),ZEROES  MAYBE IT WASN'T EVER OPENED  0102
         BE    USEDOK0        THEN NO SPACE USED IS OK
         TM    DS1DSORG,X'0C' CHECK FOR AN INVALID DSORG
*        BO    USEDOK0        NO SPACE USED IS STILL OK   *NOP* 0102
         MVC   VTFUSED,VTFALLOC SET A FLAG UNUSED SPACE UNKNOWN 0102
         B     USEDEND        USED SPACE IS SET
*
*        THE TRACKS USED COUNTER SEEMS OK
*
USEDOK   LH    R4,DS1LSTAR    GET THE LAST TRACK USED
         LA    R4,1(R4)       ADD ONE ( ZERO ADDRESSING )
         BAL   R8,SPACUNIT    CONVERT TO APPROPRIATE UNITS
USEDOK0  ST    R4,VTFUSED     SAVE THE AMOUNT OF SPACE USED
USEDEND  DS    0H
         L     R14,VTFALLOC   ALLOCATED TRACKS
         S     R14,VTFUSED    MINUS USED TRACKS
         ST    R14,VTFUNUSD   EQUALS UNUSED TRACKS
         SR    R14,R14
         SR    R15,R15
         CLC   VTFALLOC(4),=F'0'
         BE    USEDEND1
         L     R15,VTFUSED    USED TRACKS
         M     R14,=F'100'    MULT BY 100 TO GET PCT
         D     R14,VTFALLOC   DIVIDE BY ALLOC TO GET PCT USED
USEDEND1 STH   R15,VTFPCT     SAVE PCT USED
*
*        RETURN
*
FORMRET  LEAVE EQ,RC=0
*
*
         EJECT
*
*        ROUTINES USED ABOVE
*
*
*        CONVERT FROM TRACKS TO THE APPROPRIATE UNITS
*              KBYTES, MBYTES, TRKS, OR CYLS
*
SPACUNIT LH    R1,SPACEK      GET THE UNIT TYPE
         SLL   R1,2           MULTIPLY BY 4
         B     *+4(R1)        THEN BRANCH TO THE CORRECT ROUTINE
         B     SPACTRK        R1=0  KILOBYTES
         B     SPACTRK        R1=1  KILOBYTES
         B     SPACTRK        R1=2  MEGABYTES
         B     SPACTRK        R1=3  TRACKS
         B     SPACTRK        R1=4  CYLINDERS
*        TRACKS
SPACTRK  BR    R8             WAS SET WHEN WE STARTED
*        CYLINDERS
SPACCYL  SR    R0,R0          CLEAR A REGISTER
         LR    R1,R4          GET THE NUMBER OF TRACKS
         LH    R4,DS4DEVSZ+2  GET THE NUMBER OF TRACKS PER CYLINDER
         SRL   R4,2           DIVIDE BY 2 FOR ROUNDING
         AR    R1,R4          ADD IT IN
         LH    R4,DS4DEVSZ+2  GET THE NUMBER OF TRACKS PER CYLINDER
         DR    R0,R4          DIVIDE TO GET ROUNDED CYLINDERS
         LR    R4,R1          GET THE ANSWER BACK INTO R4
         BR    R8             THEN RETURN
*        KILOBYTES
SPACKB   MH    R4,DS4DEVTK    MULTIPLY BY BYTES PER TRACK
         SR    R0,R0          CLEAR THE TOP
         LR    R1,R4          GET THE NUMBER TO DIVIDE
         A     R1,F500        ADD UP TO ROUND
         D     R0,F1000       DIVIDE TO GET KILOBYTES
         LR    R4,R1          GET THE ANSWER BACK INTO R4
         BR    R8             THEN RETURN
*        MEGABYTES
SPACMB   MH    R4,DS4DEVTK    MULTIPLY BY BYTES PER TRACK
         SR    R0,R0          CLEAR THE TOP
         LR    R1,R4          GET THE NUMBER TO DIVIDE
         A     R1,F500000     ADD UP TO ROUND
         D     R0,F1000000    DIVIDE TO GET MEGABYTES
         LR    R4,R1          GET THE ANSWER BACK INTO R4
         BR    R8             THEN RETURN
*
*        GET A NEW BLOCK OF MAIN STORAGE
*
GOGETMN  GETMAIN R,LV=VTCGETMS  GET SOME
         ST    R1,VTCCURAD    SET UP THE AVAILABLE ADDRESS
         LA    R2,VTCGETMS/1024   GET THE SIZE OF THE BLOCK IN K
         SLL   R2,10          GET IT INTO BYTES ( TIMES 1024 )
         ST    R2,VTCCURLN    SO THE FORMATTED DSCB'S CAN USE IT
*
*        SAVE THE BLOCK ADDRESS IN THE VTCGETMN TABLE
*
         LA    R2,VTCGETMN    POINT TO THE TABLE
         LA    R5,VTCGETMX    GET THE NUMBER OF ENTRIES IN THE TABLE
GOGETTAB ICM   R3,B'1111',0(R2) GET THIS ENTRY
         BNZ   GOGETINC       IF NOT ZERO, KEEP LOOKING
         ST    R1,0(R2)       SAVE THE NEW ENTRY
         B     FORMFIT        THEN GO ALLOCATE A FORMATTED DSCB
*
*        THIS ENTRY WAS TAKEN, GET THE NEXT ONE
*
GOGETINC LA    R2,4(R2)       POINT TO THE NEXT ENTRY
         BCT   R5,GOGETTAB    COUNT AND LOOP
*
*        TABLE OVERFLOW  - ISSUE ERROR MSG
*              SET A FLAG TO STOP INPUT
*
         VTOCMSG TABOVFLW,TABOVSEC  ISSUE A MESSAGE
         MVI   TABFULL,255    SET A STOP FLAG
         B     FORMRET        RETURN FROM FORMATTING
         EJECT
*
*
*
*        PROGRAM CONSTANTS
*
         SPACE
*        INSTRUCTIONS EXECUTED TO GET THE NEXT EXTENT
GETEXT   DC    AL2(DS1EXT1-DS1EXT1)    1ST EXTENT OFFSET       25JUN84
         DC    AL2(DS1EXT2-DS1EXT1)    2ND "                   25JUN84
         DC    AL2(DS1EXT3-DS1EXT1)    3RD "                   25JUN84
         $FORMEX ,                     4-16 EXT                25JUN84
         $FORMEX X1                    17-   EXTENT            25JUN84
         $FORMEX X2                    30-   EXTENT            25JUN84
         $FORMEX X3                    43-   EXTENT            25JUN84
         $FORMEX X4                    56-   EXTENT            25JUN84
         $FORMEX X5                    69-   EXTENT            25JUN84
         $FORMEX X6                    82-   EXTENT            25JUN84
         $FORMEX X7                    95-   EXTENT            25JUN84
         $FORMEX X8                    108-  EXTENT            25JUN84
         $FORMEX X9                    121-  EXTENT            25JUN84
GETEXMAX DC    AL2((*-GETEXT)/2)       MAX                     25JUN84
*                                                              25JUN84
MOVEDSN  MVC   VTFDSN(0),DS1DSNAM   EXECUTED COMPARE
ZEROES   DC    2F'0'
FMIN1    DC    F'-1'
F500     DC    F'500'
F1000    DC    F'1000'
F500000  DC    F'500000'
F1000000 DC    F'1000000'
BLANKS   DC    CL8'                '
CAMCONST CAMLST NAME,*,,*
H8       DC    H'8'
SECAL    DC    C'ABTC'        SECONDARY ALLOCATION CODES
*              ABSOLUTE TRK, BLOCKS, TRACKS, CYLINDERS
*
*
*
         PRINT NOGEN
*
*        PROGRAM MESSAGES
*
TABOVFLW MSG   ' THE VTOC TABLES (1.6 MEG) ARE NOT LARGE ENOUGH TO HANDX
               LE THIS REQUEST'
TABOVSEC MSG   ' PARTIAL PROCESSING WILL CONTINUE '
*
*
*
*
*
*
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
FORMWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
FIRSTFRM DS    X              INITIALIZATION FOR THIS ROUTINE
CHARS    DS    CL16           CONVERSION TO CHARACTERS
CAMLOC   CAMLST NAME,*,,*
CAMLEN   EQU   *-CAMLOC
         DS    0D
LOCWORK  DS    265C
         SPACE
         DS    0D
LENWORK  EQU   *-FORMWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         PRINT GEN
         VTFMT
         PRINT NOGEN
         SPACE 3
         PDEDSNAM
         SPACE 3
         SPACE 3
DSCB1    DSECT
         IECSDSL1 1
         SPACE 3
*        FORMAT 1 AND 3 EXTENT DESCRIPTION
XTDSECT  DSECT
XTFLAGS  DS    X
XTNOEXT  EQU   X'00'          NO EXTENT
XTDATAB  EQU   X'01'          DAT BLOCKS
XTOVFLW  EQU   X'02'          OVERFLOW AREA
XTINDEX  EQU   X'04'          INDEX AREA
XTUSRLAB EQU   X'40'          USER LABEL EXTENT
XTSHRCYL EQU   X'80'          SHARING CYLINDERS
XTCYLBD  EQU   X'81'          CYLINDER BOUNDARIES
XTSEQ    DS    X              EXTENT SEQUENCE NUMBER
XTLOWCC  DS    H              LOWER CYLINDER
XTLOWHH  DS    H              LOWER TRACK
XTHICC   DS    H              UPPER CYLINDER
XTHIHH   DS    H              UPPER TRACK
         END
VTOCMSG  TITLE 'VTOC COMMAND - MESSAGE ROUTINE'
*
*   VTOC ERROR MESSAGE ROUTINE, R1 POINTS TO VTOC COMMON AT ENTRY
*
VTOCMSG  ENTER 12,0           DO THE STANDARD HOUSEKEEPING
         LR    R11,R1         GET THE PARM REGISTER
         USING VTOCOM,R11     SET ADDRESSABILITY
         SPACE
         LM    R0,R1,MSGADDRS GET THE MESSAGE(S) TO SEND
         LTR   R0,R0          SECOND LEVEL MSG?
         BZ    ERRORM1        NO
         SPACE
         MVC   MSGTEXT1,0(R1) INSURE MSG IN WORK AREA
         LA    R1,MSGTEXT1
         SPACE
         LH    R14,0(R1)      LENGTH OF FIRST LEVEL MSG
         LA    R15,0(R14,R1)  ADDR OF END OF MSG
         LA    R14,1(R14)     JUMP MSG LENGTH
         STH   R14,0(R1)
         MVI   0(R15),C'+'    INDICATE SECOND LEVEL MSG EXISTS
         SPACE 2
         SR    R14,R14        CLEAR CHAIN FIELD
         LA    R15,1          ONE SEGMENT IN 2ND MSG
         STM   R14,R0,PUTOLD2 CREATE SECOND-LEVEL
*                             OUTPUT LINE DESCRIPTOR ('OLD')
         LA    R0,PUTOLD2
         SPACE 3
ERRORM1  LR    R14,R0         NEXT 'OLD' ADDR OR ZERO
         LA    R15,1          ONE SEGMENT
         LR    R0,R1          MSG ADDR
         STM   R14,R0,PUTOLD1 FIRST LEVEL 'OLD'
         SPACE
         LA    R1,PARMLIST
         USING IOPL,R1
         SPACE
         MVC   IOPLECT,ADDRECT
         MVC   IOPLUPT,ADDRUPT
         SPACE
         LA    R0,ATTNECB
         ST    R0,IOPLECB
         MVI   ATTNECB,0
         SPACE 3
         XC    PARMLIST+16(4),PARMLIST+16
         PUTLINE PARM=PARMLIST+16,MF=(E,(1)),                          X
               OUTPUT=(PUTOLD1,TERM,MULTLVL,INFOR)
         SPACE 3
         LEAVE EQ
         SPACE 3
         IKJIOPL
         SPACE 3
         VTOCOM
         END
VTOCPRNT TITLE 'VTOC COMMAND - PRINT ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
* FUNCTION -   PRINT THE DATA PASSED TO IT.  IT WILL USE THE DDNAME   *
*              SYSOUT IF IT IS ALLOCATED, AND WILL USE THE VTOCMSG    *
*              ROUTINE IF NOT.  IT CAN ALSO PUT OUT THE DATA TO       *
*              AN OUTPUT DATA SET.  TOTALS ARE COMPUTED HERE.         *
*                                                                     *
* OPERATION -  FOR UNSORTED DATA, GET THE CURRENT ENTRY, ADD TO THE   *
*              TOTALS, AND OUTPUT IT.  IF THE DATA IS SORTED, THE     *
*              ACTION IS MORE COMPLEX, BECAUSE ALL THE DATA SETS      *
*              ARE TO BE OUTPUT.  THE TOTALS AND BREAKS MAY BE        *
*              NEEDED AT ANY POINT.                                   *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, CURRENT FORMATTED DSCB, SORTED LIST    *
*                                                                     *
* OUTPUT -     TO SYSOUT, A LIST OF THE REQUESTED DATA SETS AND       *
*              THEIR ATTRIBUTES, WITH TOTALS AND BREAKS AS NEEDED.    *
*              ALSO TO THE OUTPUT DATA SET, IF NEEDED.  IF SYSOUT     *
*              IS NOT ALLOCATED, VTOCMSG IS USED FOR OUTPUT.          *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*                                                                     *
*                                                                     *
***********************************************************************
*
*        MACRO FOR DEFINING FAKE PDE FOR A DEFAULT LIST
*
         EJECT
VTOCPRNT ENTER 12,20          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING PRNTWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
         SPACE 3
*
*        CHECK FOR THE PRINT CLEAN - CLOSE AND FREEMAIN
*
         CLI   VTCEPRNT,0     IS IT TIME
         BNE   PRNTCLEN       YES, GO DO IT
*
*        CHECK FOR THE FIRST TIME THROUGH
*        IF SO, SET UP THE DCB'S AND OPEN THEM
*
         CLI   FIRSTIM,0      IS THIS THE FIRST TIME?
         BNE   CHKSORT        NO, KEEP ON TRUCKIN'
         B     PRTINIT    INITIALIZE FOR PRINTING
*
*        CHECK TO SEE IF THE DATA IS SORTED
*
CHKSORT  CLI   SORTK+1,2      IS THIS NOSORT?
         BNE   SORTED         NO, THE ENTRIES ARE SORTED
*
*        NOSORT WAS SPECIFIED.  ONLY THE CURRENT ENTRY IS AVAILABLE
*
         L     R3,FORMATAD    POINT TO THE ENTRY
         USING VTFMT,R3       FORMATTED DSCB ADDRESSABILITY
         LTR   R3,R3          IS IT THERE?
         BZ    CHEKTOT        NO, SEE IF A TOTAL HAS BEEN OUTPUT
         XC    FORMATAD,FORMATAD  CLEAR THE ADDRESS FOR LATER
*
*        ADD TO THE TOTALS
*
         BAL   R8,ADDTOT      GO DO IT
*
*        SEE IF THE OUTPUT DATA SET IS WANTED
*
         TM    OUTDCB+48,X'10'  IS THE DCB OPEN?
         BNO   NOOUTPT        NO, SKIP ALONG
         BAL   R8,OUTPUT      YES, GO DO IT
*
*        SEE IF THERE'S PRINTING TO DO
*
NOOUTPT  CLI   PRINTK+1,2     WAS NOPRINT SPECIFIED?
         BE    VTRET          YES, WE'RE DONE FOR NOW
         BAL   R8,PRINT       NO, PRINT OUT THE ENTRY
*
*        RETURN FROM WHENCE WE CAME
*
VTRET    LEAVE EQ,RC=0        EXEUNT
*
*        NOSORT, CHECK FOR OUTPUTTING THE TOTALS
*
CHEKTOT  TM    ENDTOTAL,ENTOTOUT  WAS THE TOTAL OUTPUT BEFORE?
         BO    VTRET          YES, JUST RETURN
         BAL   R8,PRNTOT      NO, OUTPUT THE TOTAL
         OI    ENDTOTAL,ENTOTOUT  REMEMBER THE TOTAL IS OUT
         B     VTRET          THEN RETURN
         EJECT
*
*        THE DATA IS SORTED, SO THE LISTS MUST BE EMPTIED.
*        CHECK EACH ITEM FOR A TOTAL AND FOR A BREAK
*        OUTPUT TO PRINT AND/OR THE OUTPUT DATA SET
*
*
*        FIRST GET THE TOTAL AND BREAK COUNTS FOR COMPARES
*
SORTED   LA    R1,TOTALN      POINT TO THE TOTAL PDL
         BAL   R8,PDLNUM      CONVERT IT TO A NUMBER
         LTR   R15,R15        IS IT ZERO?
         BNZ   SETTNUM        NO, IT'S GOOD
         OI    ENDTOTAL,ENDTONLY  YES, TOTALS AT THE END ONLY
SETTNUM  BCTR  R15,0          CUT IT DOWN ONE
         STH   R15,NUMTOTAL   SET THE TOTAL COUNT
         LA    R1,BREAK       POINT TO THE BREAK PDL
         BAL   R8,PDLNUM      CONVERT IT TO A NUMBER
         LTR   R15,R15        IS IT ZERO?
         BNZ   SETBNUM        NO, IT'S GOOD
         OI    ENDTOTAL,NOBREAK   YES, BREAK  AT THE END ONLY
SETBNUM  BCTR  R15,0          CUT IT DOWN ONE
         STH   R15,NUMBREAK   SET THE BREAK COUNT
*
*        START GOING THROUGH THE LISTS, PROCESS THE ENTRIES
*
         LA    R4,VTCSORTH    POINT TO THE LISTS
         LA    R5,VTCSORTE    POINT TO THE END OF THE LISTS
         ST    R5,ADDREND     SAVE THE ADDRESS
NEWLIST  L     R3,0(R4)       GET THE FIRST ENTRY FROM THIS LIST
         LTR   R3,R3          ANYTHING ON THIS LIST?
         BZ    NEXTLIST       NO, GET ANOTHER LIST
*
*        THIS IS AN ENTRY, DO THE TOTALS, PRINT, AND OUTPUT
*        CHECK FOR TOTALS AND BREAKS FIRST
*
GOTENTRY CLI   PRINTK+1,2     WAS NOPRINT SET?
         BE    CHKOUTPT       YES, SKIP INTERIM TOTALS
         MVI   TOTLAST,0      SET UP FLAG FOR TOTAL AS LAST ACTION
*        NOTE - EXTENSION - OUTPUT INTERIM TOTALS WITH THE KEY
         TM    ENDTOTAL,ENDTONLY  END TOTAL ONLY?
         BO    CHKBREAK       YES, SEE ABOUT BREAKS
         LH    R2,NUMTOTAL    GET THE LENGTH TO COMPARE
         L     R1,LASTKEY     GET THE LAST ENTRY
         EX    R2,COMPKEY     SEE IF THIS IS THE SAME
         BE    CHKBREAK       YES, KEEP COUNTING
*
*        THIS ONE IS DIFFERENT, PRINT THE TOTALS FIRST
*
         BAL   R8,PRNTOT      PRINT THE TOTALS
*
*        CHECK FOR A BREAK
*
CHKBREAK TM    ENDTOTAL,NOBREAK   NO BREAKS THIS TIME?
         BO    SKPBREAK       YES, SKIP PAST BREAKS
         LH    R2,NUMBREAK    GET THE LENGTH TO COMPARE
         L     R1,LASTKEY     GET THE LAST ENTRY
         EX    R2,COMPKEY     SEE IF THIS IS THE SAME
         BE    SKPBREAK       YES, KEEP COUNTING
*
*        THIS ONE IS DIFFERENT, GET A NEW PAGE
*
         MVC   LINECT,LINEMAX BE SURE THE NEXT ITEM GETS A NEW PAGE
         MVI   TOTLAST,0      DON'T SKIP A LINE AFTER TOTAL
         LA    R1,VTFDSN     POINT TO THE DSNAME
         ST    R1,LASTKEY    SAVE THE ADDRESS FOR BREAK COMPARES
*
*        PRINT THE ITEM
*
SKPBREAK CLI   TOTLAST,0      WAS A TOTAL NOT FOLLOWED BY A BREAK?
         BE    SKPBREA2       NO, CONTINUE NORMALLY
         MVC   MSGBL,MSGBLC   YES, SET UP A BLANK MESSAGE
         LA    R1,MSGBL       POINT TO IT
         BAL   R8,PRNTLINE    THEN PUTPUT IT
SKPBREA2 BAL   R8,PRINT       FINAL FORMAT AND PRINT
*
*        CHECK FOR DATA SET OUTPUT
*
CHKOUTPT TM    OUTDCB+48,X'10'     IS IT OPEN AND READY
         BNO   GOTOT          NO, GO DO THE TOTALS
         BAL   R8,OUTPUT      YES, PUT OUT THE DATA SET ENTRY
*
*        ADD UP THE TOTALS
*
GOTOT    BAL   R8,ADDTOT      SUM THEM
*
*        GET THE NEXT ENTRY
*
         ICM   R3,B'1111',VTFNEXT  FOLLOW THE CHAIN
         BNZ   GOTENTRY       SOMETHING'S THERE, USE IT
*
*        END OF THIS LIST, TRY THE NEXT LIST
*
NEXTLIST LA    R4,12(0,R4)    MOVE OVER ONE
         C     R4,ADDREND     WAS THAT THE LAST LIST?
         BL    NEWLIST        NO, KEEP TRYING
*
*        END OF THE LISTS, OUTPUT THE FINAL TOTAL AND RETURN
*
         BAL   R8,PRNTOT      LIST THE TOTAL
*
*        CLEAR OUT THE PRINT LISTS
*
         XC    VTCSORTH+000(256),VTCSORTH  CLEAR 64 ENTRIES
         XC    VTCSORTH+256(256),VTCSORTH+256 CLEAR 64 ENTRIES
         XC    VTCSORTH+512(256),VTCSORTH+512 CLEAR 64 ENTRIES
         XC    VTCSORTH+768(256),VTCSORTH+768 CLEAR 64 ENTRIES
         B     VTRET          THEN GET OUT OF HERE
         EJECT
*
*        PRINT CLEANUP ROUTINE - CLOSE DCB'S FIRST
*
PRNTCLEN TM    SYSOUT+48,X'10'  IS SYSOUT OPEN?
         BNO   PRNTCLO        NO, CHECK THE OUTDCB
         CLOSE (SYSOUT),MF=(E,OPENLIST)  DO THE CLOSE
PRNTCLO  TM    OUTDCB+48,X'10'  IS OUTDCB OPEN?
         BNO   PRNTFREE       NO, SKIP DOWN TO THE FREEMAINS
         CLOSE (OUTDCB),MF=(E,OPENLIST)  DO THE CLOSE
*
*        FREE UP THE STORAGE
*
PRNTFREE LA    R2,VTCGETMN    POINT TO THE TABLE
         LA    R5,VTCGETMX    GET THE NUMBER OF ENTRIES IN THE TABLE
PRNTFRL  ICM   R3,B'1111',0(R2)  GET THE STORAGE ADDRESS
         BZ    VTRET          IF ZERO, WE'RE DONE
         FREEMAIN R,LV=VTCGETMS,A=(R3)  FREE IT
         XC    0(4,R2),0(R2)  CLEAR THE ADDRESS
         LA    R2,4(R2)       GET THE NEXT BLOCK ADDRESS
         BCT   R5,PRNTFRL     AND LOOP UNTIL DONE
         B     VTRET          THEN RETURN
*
         EJECT
*
*        ROUTINES USED ABOVE
*              ADDTOT - ADD TO THE CURRENT TOTALS
*              PRNTOT - PRINT OUT THE TOTALS AND CLEAR THEM
*              PRINT  - PRINT OUT AN ENTRY
*              OUTPUT - OUTPUT THE DATA SET ENTRY
*              PDLNUM - GET A NUMBER FROM A PDL ENTRY
*              PRNTLINE - INTERNAL ROUTINE TO COUNT LINES, OUTPUT HEAD
*
ADDTOT   L     R1,TOTDS       NUMBER OF DATA SETS
         LA    R1,1(R1)       ADD ONE
         ST    R1,TOTDS       STORE IT BACK
         L     R1,TOTALLOC    TOTAL ALLOCATION
         A     R1,VTFALLOC    ADD IN THIS DATA SET
         ST    R1,TOTALLOC    STORE IT BACK
         L     R1,TOTUSED     TOTAL USED SPACE
         A     R1,VTFUSED     ADD IN THIS DATA SET
         ST    R1,TOTUSED     STORE IT BACK
         BR    R8             RETURN
*
         EJECT
*
*        PRINT THE TOTALS
*              FIRST FORMAT THEM, THEN PUT THE LINE OUT TO SYSOUT
*              OR USE VTOCMSG TO LIST IT
*
PRNTOT   ST    R8,PRNTTOT8   SAVE THE RETURN ADDRESS
         MVC   MSGWORK(MSGTLEN),MSGTOTC  INIT THE MSG
         CONV  MSGWORK+4+11,TOTDS,5  CONVERT NO OF DATA SETS
         CONV  MSGWORK+4+28,TOTALLOC,8  CONVERT ALLOCATION
         CONV  MSGWORK+4+51,TOTUSED,8   CONVERT USED SPACE
         MVC   MSGWORK+4+37(6),SPACTYPE MOVE IN THE UNITS
         MVC   MSGWORK+4+60(6),SPACTYPE MOVE IN THE UNITS
*
*        NOW OUTPUT THE MESSAGE
*
         MVI   MSGWORK+4,C'0' ADD A CARRIAGE CONTROL
         LA    R1,MSGWORK     POINT TO THE TOTAL LINE
         BAL   R8,PRNTLINE    PUT OUT THE TOTAL LINE
         MVI   TOTLAST,1      NOTE THAT A TOTAL WAS THE LAST ITEM
         L     R8,PRNTTOT8    GET THE RETURN ADDRESS
         BR    R8             THEN RETURN
         EJECT
*
*        PRINT OUT THE FORMATTED DSCB
*              FIRST FORMAT IT
*
PRINT    ST    R8,PRINTR8     SAVE REGISTER 8 FOR RETURNING
         MVI   WORKLINE+4,C' ' BLANK OUT THE LINE
         MVC   WORKLINE+5(250),WORKLINE+4 SO INDIVIUAL FIELDS DON'T
         L     R2,VTPRNTLS   GET THE PRINT ITEM LIST
         LA    R1,WORKLINE+4  POINT TO THE WORK  LINE
PRTLOOP  SR    R6,R6          GET THE RESERVED WORD NUMBER
         IC    R6,0(R2)       FROM THE TOP BYTE
         MH    R6,H12         MULTIPLY BY 12 FOR THE TABLE ENTRIES
         LA    R6,TABTITL(R6) THEN RELOCATE THE MESS
         SR    R7,R7          CLEAR A REGISTER
         IC    R7,0(R6)       GET THE EXECUTE LENGTH
         LA    R5,1(R1)       SAVE A PLACE TO MOVE FIELD INTO
         LA    R1,1(R1,R7)    MOVE THE POINTER OVER
         LA    R0,WORKLINE+4  POINT TO THE BEGINNING AGAIN
         SR    R1,R0          AND FIND THE CURRENT LENGTH
         CH    R1,LINELEN     IS IT TOO LONG?
         BNL   PRTEND         YES, WE'RE DONE
         AR    R1,R0          NO, KEEP GOING
*
*        MOVE IN OR CONVERT THIS ITEM
*
         SR    R14,R14       CLEAR A REG FOR LENGTH OF RTN NO
         IC    R14,1(R6)     GET THE LENGTH OR ROUTINE
         N     R14,F127      CLEAR THE TOP BIT
         SR    R15,R15       CLEAR A REG FOR VTFMT
         IC    R15,2(R6)       DISPLACEMENT
         AR    R15,R3        RELOCATE IT
*
*        DECIDE WHERE TO PUT IT
*
         TM    1(R6),X'80'   IS IT IN CHARS
         BNO   PRTRTN        NO, USE THE SPECIAL ROUTINE
         SR    R7,R14        GET THE DIFFERENCE IN LENGTHS
         SRL   R7,1          GET HALF THE DIFFERENCE
         AR    R5,R7         PUT THE DATA HERE
         EX    R14,PRTMOVE   MOVE IN THE CHARACTERS
PRTINC   LA    R2,1(R2)            GET THE NEXT CHAIN POINTER
         CLI   0(R2),0       ARE WE DONE?
         BNE   PRTLOOP        GO GET MORE ITEMS
PRTEND   LA    R1,WORKLINE   POINT TO THIS LINE
         BAL   R8,PRNTLINE   THEN GO PRINT IT
         L     R8,PRINTR8     GET THE RETURN ADDRESS
         BR    R8             RETURN
PRTMOVE  MVC   0(0,R5),0(R15)  EXECUTED MOVE
*
*        VARIOUS ROUTINES TO FORMAT BEFORE MOVING IN THE DATA
*
PRTRTN   LTR   R14,R14       BE SURE THE OFFSET IS OK
         BP    PRTRTN1        IT SEEMS ALL RIGHT
         ABEND 701,DUMP       CRASH AND BURN
PRTRTN1  B     *(R14)        GO DO YOUR THING
         B     PRDATES        4  CDATE, EXPDT
         B     PRLSTUS        8  LSTUS
         B     PRALLOC       12  ALLOC, USED
         B     PRUNUSED      16  ALLOC - USED
         B     PRPCT         20  100 * USED / ALLOC
         B     PREXT         24  EXT
         B     PRBLREC       28  BLKSZ LRECL
         B     PRDSN         32  DSNAME
*
*
*        CDATE AND EXPDT
*
PRDATES  SR    R14,R14       CLEAR REG FOR YEAR
         IC    R14,0(R15)    GET THE YEAR
         USING DUMMD,R5      ALLOW CONV TO USE SYMBOL
         CONV  DUMMA,(R14),2 CONVERT YEAR
         ICM   R14,B'0011',1(R15)  GET THE DAY
         CONV  DUMMA+2,(R14),3,EDMASK0,COMP0  CONVERT THE DAY
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        LAST USE DATE
*
PRLSTUS  MVC   CHARS,EDMASK   SET UP THE EDIT MASK
         ED    CHARS(6),0(R15)  CONVERT TO CHARACTERS
         MVC   0(5,R5),CHARS+1  THEN MOVE THEM IN
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        ALLOCATION AND USED
*
PRALLOC  ICM   R14,B'1111',0(R15)  GET THE AMOUNT
         BM    PRUNKN6       IF NEGATIVE, IT'S NOT KNOWN
         CONV  DUMMA,(R14),6 CONVERT THE NUMBER
         B     PRTINC        GO GET MORE PRINT ITEMS
PRUNKN6  MVC   0(6,R5),BLANKS  UNKNOWN AMOUNT, LEAVE IT BLANK
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        UNUSED SPACE
*
PRUNUSED ICM   R14,B'1111',VTFUSED  GET THE   USED SPACE
         BM    PRUNKN6       IF NOT KNOWN, SKIP ALONG
         L     R14,VTFALLOC  GET THE ALLOCATED SPACE
         S     R14,VTFUSED   MINUS THE USED SPACE GIVES UNUSED
         BZ    PRTINC        IF NO UNUSED SPACE, LEAVE BLANK
         CONV  DUMMA,(R14),6 CONVERT FOR PRINTING
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        PCT - PERCENTAGE USED
*
PRPCT    SR    R6,R6         CLEAR THE TOP PART OF THE NUMBER
         ICM   R7,B'1111',VTFUSED   GET THE AMOUNT OF USED SPACE
         BM    PRUNKN3       IF NOT KNOWN, LEAVE BLANK
         CLC   VTFALLOC,ZERO IS THE ALLOCATION ZERO?
         BNE   PRPCTM        NO, DO THE STANDARD STUFF
         CLC   VTFUSED,ZERO  IS THE USED SPACE ZERO?
         BE    PRUNKN3       YES, JUST USE BLANKS
PRPCTERR MVC   0(3,R5),=C'ERR'  NO, IT'S AN ERROR
         B     PRTINC        THEN GO TRY FOR MORE
PRPCTM   M     R6,F100       MULTIPLY BY 100 FOR PERCENT
         D     R6,VTFALLOC   DIVIDE BY ALLOC TO GET THE PERCENT
         LTR   R7,R7         IS IT LESS THAN ZERO?
         BM    PRPCTERR      YES, FLAG THE ERROR
         C     R7,F100       ALSO CHECK FOR OVER 100 PERCENT
         BH    PRPCTERR      THAT'S ALSO AN ERROR
         CONV  DUMMA,(R7),3  CONVERT FOR PRINTING
         B     PRTINC        GO GET MORE PRINT ITEMS
PRUNKN3  MVC   0(3,R5),BLANKS BLANK THE UNKNOWN
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        EXTENTS
*
PREXT    SR    R14,R14       CLEAR REG FOR YEAR
         IC    R14,0(R15)    GET THE YEAR
         CONV  DUMMA,(R14),2 CONVERT THE EXTENTS
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        LRECL AND BLKSZ
*
PRBLREC  LH    R14,0(R15)    GET THE DATA ( HALFWORD )
         CONV  DUMMA,(R14),5  CONVERT THE DATA
         B     PRTINC        GO GET MORE PRINT ITEMS
*
*        DATA SET NAME
*
PRDSN    LH    R14,VTFDSNL   GET THE DSNAME LENGTH
         CH    R14,DSNLENGT  CHACK FOR MAX LENGTH
         BL    PRDMOVE       THIS DSN IS SHORT ENOUGH
         LH    R14,DSNLENGT  CUT IT DOWN
PRDMOVE  BCTR  R14,0         COUNT DOWN ONE FOR THE EX
         EX    R14,PRTMOVE   MOVE IN THE DSNAME
         AH    R1,DSNLENOF   CORRECT THE LINE POINTER
         B     PRTINC        GO GET MORE PRINT ITEMS
         EJECT
*
*        OUTPUT THE FORMATTED DSCB AS IT IS
*
OUTPUT   CLEAR OUTWORK       CLEAR THE OUTPUT REC
         LH    R2,VTFDSNL     GET THE LENGTH OF THE DSNAME
         LA    R2,VTFMTL-1(R2)  GET THE FULL LENGTH MINUS ONE
         EX    R2,OUTMOVE    MOVE IN THE ACTUAL RECORD
         PUT   OUTDCB,OUTWORK    OUTPUT THE RECORD
         BR    R8             RETURN
OUTMOVE  MVC   OUTWORK(0),0(R3)  EXECUTED MOVE
         EJECT
*
*        PDLNUM - CONVERT FROM CHARACTERS ( EBCDIC ) TO AN INTEGER
*              BINARY FORM, PASSED BACK VIA REGISTER 15
*              A PARSE PDE IS THE INPUT AS SHOWN IN THE SAMPLE BELOW
*                       LA    R1,PDL     POINT TO THE PARSE DECRIPTION
*                       BAL   R8,PDLNUM  GO CONVERT TO NUMERICS
*              THE ROUTINE WILL TERMINATE IF IT FINDS NON-NUMERICS
*                 ANY CHARACTERS OTHER THEN 0-9, +, -
*              REGISTERS 1, 2, 5, 6, AND 7 ARE USED
*
PDLNUM   STM   R1,R8,PDLNSAVE SAVE THE REGISTERS
         LH    R2,4(R1)       GET THE STRING ADDRESS
         L     R1,0(R1)       GET THE STRING ADDRESS
         MVI   PDLMINUS,0     CLEAR THE NEGATIVE NUMBER FLAG
         SR    R5,R5          CLEAR THE CHARACTER COUNTER
         SR    R15,R15        CLEAR THE ANSWER
PDLLOOP  LA    R6,0(R5,R1)    POINT TO THIS DIGIT
         LA    R5,1(R5)       GET TO THE NEXT DIGIT
         CR    R5,R2          IS THIS THE END OF THE STRING?
         BH    PDLFINI        YES, EXIT
         SR    R7,R7          CLEAR A WORK REGISTER
         IC    R7,0(R6)       GET THE CHARACTER
         SH    R7,PDLH240     SUBTRACT THE CHARACTER C'0'
         BM    PDLSP          IF NEGATIVE, CHECK SPECIAL CHARACTERS
         MH    R15,PDLH10     IT'S A DIGIT, MULTIPLY PRIOR NUM BY TEN
         AR    R15,R7         ADD ON THE NEW DIGIT
         B     PDLLOOP        AND LOOP FOR MORE
*
*        CHECK FOR SPECIAL CHARACTERS
*
PDLSP    CLI   0(R6),C' '     IS IT A BLANK?
         BE    PDLLOOP        THEN IT'S OK
         CLI   0(R6),C'+'     IS IT A PLUS?
         BE    PDLLOOP        THAT'S ALSO OK
         CLI   0(R6),C'-'     IS IT A MINUS?
         BNE   PDLFINI        NO, JUST QUIT
         MVI   PDLMINUS,1     YES, NOTE IT
         B     PDLLOOP        AND LOOK FOR MORE
*
*        QUIT, AFTER SETTING R15 TO NEGATIVE IF NEEDED
*
PDLFINI  CLI   PDLMINUS,1     WAS A MINUS SIGN FOUND?
         BNE   PDLLEAVE       NO, EXIT
         LNR   R15,R15        YES, MAKE IT NEGATIVE
PDLLEAVE LM    R1,R8,PDLNSAVE RESTORE THE REGISTERS
         BR    R8             RETURN
PDLH10   DC    H'10'
PDLH240  DC    H'240'
         EJECT
*
*        PRNTLINE - GET EACH LINE FOR SYSOUT, THEN COUNT THE LINES
*              OUTPUT HEADERS AND TITLE LINES AS NECESSARY
*
PRNTLINE STM   R1,R8,PRTLSAVE SAVE THE REGISTERS
         TM    SYSOUT+48,X'10' IS SYSOUT OPEN FOR BUSINESS?
         BNO   PRNTTERM       NO, IT'S NOT OPEN, USE VTOCMSG
         CLI   HEADK+1,2     NOHEADING REQUEST?
         BE    PRNTLIN       YES, JUST OUTPUT THE DATA LINE
*
*        DO THE LINE COUNTING
*
         LH    R2,LINECT      GET THE LINE COUNT
         CLI   4(R1),C'1'     IS IT REQUESTING A NEW PAGE?
         BE    PRNTPAGE       YES, DO IT
         CLI   0(R1),C'-'     SKIP 3 LINES
         BE    PRNTSKP3       YES, TRY IT
         CLI   0(R1),C'0'     SKIP 2 LINES?
         BE    PRNTSKP2       YES, DO IT
         B     PRNTSKP1       JUST SKIP ONE
PRNTSKP3 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT
PRNTSKP2 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT
PRNTSKP1 LA    R2,1(R2)       ADD ONE TO THE LINE COUNT
         STH   R2,LINECT      SAVE THE LINE COUNT
         CH    R2,LINEMAX     DOES THIS OVERFLOW  HE PAGE?
         BL    PRNTLIN        NO, JUST PUT OUT THIS LINE
*
*        PRINT OUT THE PAGE HEADER AND ITEM TITLES
*
PRNTPAGE LH    R6,PAGECT      GET THE PAGE COUNT
         LA    R6,1(R6)       ADD ONE TO IT
         STH   R6,PAGECT      THEN STORE IT BACK
         L     R7,PAGEADDR    GET THE PLACE TO PUT THE PAGE
         USING DUMMD,R7       DUMMY DSECT
         CONV  DUMMA,(R6),5   GET THE CHARACTERS
         DROP  R7
         ST    R1,PRNTLSAV    SAVE THE INPUT REG1
         PUT   SYSOUT,PRNTHEAD  OUTPUT THE HEADER
         PUT   SYSOUT,PRNTTITL  OUTPUT THE ITEM TITLES
         L     R1,PRNTLSAV    GET THE ORIGINAL LINE
         MVI   4(R1),C'0'     ALWAYS SKIP THE FIRST LINE AFTER NEW PAGE
         LA    R7,5           SET THE LINE COUNT
         STH   R7,LINECT      SAVE IT FOR LATER
PRNTLIN  CLEAR OUTWORK       CLEAR A PRINT RECORD
         LH    R6,0(R1)      GET THE RECORD LENGTH
         SH    R6,H5         MINUS 4 FOR PREFIX, 1 FOR EX
         LA    R3,4(R1)      POINT TO THE TEXT
         EX    R6,OUTMOVE    THEN MOVE IN THE LINE
         PUT   SYSOUT,OUTWORK      AND FINALLY PRINT IT
         B     PRNTLRET       THEN RETURN
*
*        SIMPLER CHECKING FOR VTOCMSG OUTPUT
*
PRNTTERM LH    R2,LINECT      GET THE LINE COUNT
         LA    R2,1(R2)       IGNORE CARRIAGE CONTROL
         STH   R2,LINECT      SAVE IT BACK
         LR    R6,R1          SAVE THE ORIGINAL REG 1
         MVI   4(R1),C' '    BLANK THE CARRIAGE CONTROL
         CLI   HEADK+1,2     NOHEADING REQUEST?
         BE    PRNTTLIN       YES, JUST OUTPUT THE DATA LINE
         CH    R2,LINEMAX     NEED A NEW TITLE?
         BL    PRNTTLIN       NO, KEEP GOING
         VTOCMSG PRNTTITH     YES, PUT IT OUT
         MVC   LINECT,H2      RESET THE LINE COUNT
PRNTTLIN VTOCMSG 0(R6)        OUTPUT THE PASSED LINE
PRNTLRET LM    R1,R8,PRTLSAVE RESTORE THE REGISTERS
         BR    R8             THEN RETURN
         EJECT
PRTINIT  MVI   FIRSTIM,10    FLAG THE INITIALIZATION AS DONE
         LA    R1,TABTITL    POINT TO THE BUG TABLE
         ST    R1,ATABTITL   LET CHECK KNOW WHERE IT IS
*
*        SET UP THE CHARACTERS FOR TYPE OF SPACE ALLOC.
*
         LH    R2,SPACEK      GET THE SPACE TYPE KEYWORD
         SLA   R2,3           MULTIPLY BY 8
         LA    R2,TABSPACE(R2)  RELOCATE IT
         MVC   SPACTYPE,0(R2) SAVE THE CHARACTERS
         CLI   PRINTK+1,2     IS THIS NOPRINT?
         BE    NOOPEN         YES, SKIP THE OPEN
         MVC   SYSOUT(SYSOUTL),SYSOUTC  INITIALIZE THE DCB
         MVI   OPENLIST,X'80' TERMINATE THE LIST
         LA    R1,JFCB       POINT TO THE JFCB
         ST    R1,DCBEXIT    AND PUT THE ADDR IN THE DCB EXIT
         MVI   DCBEXIT,X'87' NOTE IT AS A JFCB EXIT
         LA    R1,DCBEXIT    POINT TO THE EXIT LIST
         LA    R2,SYSOUT     AND TO THE DCB FOR ADDRESSABILITY
         USING IHADCB,R2     TELL THE ASSEMBLER ABOUT IT
         STCM  R1,B'0111',DCBEXLSA  STUFF IT INTO THE DCB
         TM    CHARSPL+6,X'80'  CHARS PER LINE ENTERED?
         BZ    RDJFCB        NO, CONTINUE ALONG
         LA    R1,CHARSPL    YES, POINT TO THE PDL
         BAL   R8,PDLNUM     CONVERT TO A NUMBER
         STH   R15,DCBLRECL  SAVE THE NEW LRECL
         STH   R15,LINELEN   ALSO THE LINE LENGTH
         TM    BLKSZSET+6,X'80'  BLOCKSIZE ENTERED?
         BZ    BLKEQREC      NO, BLOCKSIZE EQUALS LRECL
         LA    R1,BLKSZSET      POINT TO THE PDL
         BAL   R8,PDLNUM     GET THE NUMBER
BLKEQREC STH   R15,DCBPRECL  STUFF IT AWAY
         DROP  R2            FINISHED WITH THE DCB
RDJFCB   RDJFCB ((R2)),MF=(E,OPENLIST)  SEE IF IT'S THERE
         LTR   R15,R15       WAS IT THERE?
         BNZ   NOOPEN        NO, SKIP ALONG
         OPEN  ((R2),OUTPUT),MF=(E,OPENLIST)  OPEN THE PRINT DCB
*
*        INITIALIZE PRINT VARIABLES
*
*        SET LINES/PAGE AND LINESIZE
*
NOOPEN   MVC   LINEMAX,DEFLMAX  SET THE DEFAULT NUMBER OF LINES/PAGE
         TM    LINESPP+6,X'80'     LINES PER PAGE ENTERED?
         BZ    DEFLINPP     NO, SKIP ON
         LA    R1,LINESPP    YES, POINT TO THE PDL
         BAL   R8,PDLNUM     CONVERT TO A NUMBER
         STH   R15,LINEMAX   AND SAVE IT
DEFLINPP MVC   LINECT,LINEMAX SET UP TO PAGE ON THE FIRST WRITE
         TM    CHARSPL+6,X'80'     CHARS PER LINE ENTERED?
         BO    LENSET        YES, USE IT
         MVC   LINELEN,DEFLEN SET UP A DEFAULT LENGTH
         TM    SYSOUT+48,X'10' DO WE USE SYSOUT?
         BO    LENSET         YES, USE WHAT WE'VE GOT
*        GET THE TERMINAL LINE SIZE TO SEE IF IT MAKES SENSE
         GTSIZE
         LTR   R1,R1          SEE IF IT'S GOOD
         BZ    LENSET         NO, JUST A ZERO, KEEP THE DEFAULTS
         BCTR  R1,0           CUT IT DOWN ONE TO AVOID A MESS
         STH   R1,LINELEN     SAVE THIS LENGTH
         LTR   R0,R0          FOR DISPLAYS, IT'S SCREEN SIZE
         BZ    LENSET         KEEP WHAT WE'VE GOT
         TM    LINESPP+6,X'80'  WAS LINES PER PAGE ENTERED?
         BO    LENSET           YES, DON'T OVERRIDE IT
         STH   R0,LINEMAX     AND SAVE THE NEW PAGE LOCATION
LENSET   DS    0H
*
*        SET UP THE PAGE COUNTER
*
PAGEAD   LH    R1,LINELEN     GET THE LENGTH OF THE LINE
         SH    R1,H10         MINUS TEN CHARACTERS
         LA    R1,PRNTHEAD(R1) THEN RELOCATE IT
         CLEAR PRNTHEAD       CLEAR THE LINE FIRST
         MVC   0(4,R1),CPAGE  MOVE IN THE CHARACTERS PAGE
         LA    R1,5(R1)       MOVE OVER 5 MORE
         ST    R1,PAGEADDR    THIS IS THE PLACE
*
*        BUILD THE PRINT HEADER LINE
*
         TM    HEADING+6,X'80' IS A USER HEADING PRESENT
         BO    USERHEAD       YES, USE IT
         MVC   PRNTHEAD(L'DEFHEAD),DEFHEAD  NO, GET A DEFAULT
*
*        ADD THE COMMAND BUFFER TO THE HEADING
*
         LH    R1,LINELEN    GET THE LINE LENGTHE
         SH    R1,H32        MINUS SPACES FOR PAGE, START OF HDR
         BNP   OUTOPEN       IF IT'S SHORT, SKIP ON
         L     R14,ADDRCBUF  POINT TO THE COMMAND BUFFER
         CH    R1,0(R14)     COMPARE LENGTHS
         BL    CBUFBIG       THE COMMAND BUFFER TOO BIG
         LH    R1,0(R14)     GET THE COMMAND BUFFER SIZE
CBUFBIG  SH    R1,H5         MINUS 1 FOR EX, 4 FOR CBUF PREFIX
         EX    R1,MOVEHED    MOVE THE CBUF TO THE DEFAULT HEADER
         B     OUTOPEN        GO SET UP THE PAGE COUNTER
USERHEAD LH    R1,HEADING+4   GET THE LENGTH
         BCTR  R1,0           MINUS ONE FOR THE EX
         L     R2,HEADING     POINT TO THE USER HEAD
         EX    R1,MOVEHEAD    THEN MOVE IT IN
OUTOPEN  DS    0H
*
*        SET UP THE WORK LINE
*
         LH    R1,LINELEN    GET THE LINE LENGTH
         LA    R1,4(R1)      ADD FOUR FOR THE PREFIX
         STH   R1,WORKLINE   OUTPUT TEXT
         STH   R1,PRNTTITH    ITEM TITLES
*        GET THE PRINT SPECIFICATION
*
         LA    R1,DEFPRNT
         ST    R1,VTPRNTLS   SAVE THE PRINT ITEM LIST ADDRESS
         TM    SUBPRTKY+6,X'80'  WERE ANY ITEMS SET UP
         BE    PRTITSET      NO, THE DEFAULT LIST IS OK
*
*        GET THE ADD, REPLACE, DELETE, AND NEW ITEMS
*        AND BUILD THE NEW LIST
*
*        FIRST CONVERT THE ENTERED TEXT INTO NUMERIC KEYS
*
         LA    R4,SUBPRTIT   POINT TO THE ITEMS
         LA    R5,VTPRNTEN   POINT TO THE OUTPUT KEYS
         LA    R0,VTPRNTEX   POINT TO THE END OF THE LIST
ENTKEY   BAL   R8,GETKEY     GET A KEY
         STC   R15,0(R5)     SAVE IT
         LA    R5,1(R5)      GET TO THE NEXT ONE
         CR    R0,R5         CHECK FOR THE END
         BNH   ENTKEND       IF THAT'S ALL
         ICM   R4,7,9(R4)    GET THE CHAIN POINTER
         BNZ   ENTKEY        AND KEEP GOING IF THERE'S MORE
ENTKEND  DS    0H            THE KEYS ARE ENTERED INTO THE LIST
*
*        MERGE THE ENTERED ITEMS AND THE DEFAULT LIST INTO A NEW LIST
*
         LA    R6,VTPRNTL    POINT TO THE NEW LIST
         ST    R6,VTPRNTLS   SAVE IT'S ADDRESS
         LA    R4,VTPRNTEN   POINT TO THE ENTERED ITEMS
         LA    R2,DEFPRNT    POINT TO THE DEFAULT LIST
         LR    R3,R2         POINT TO THE BEGINNING - NO DEFAULT IF NEW
         L     R1,SUBPRTKY   POINT TO THE KEYWORD
         CLI   0(R1),C'N'    IS THIS A NEW LIST?
         BE    PRTINEW       YES, SKIP PAST DEFAULT COPY
         LA    R3,DEFPRNTE   POINT TO THE END OF THE DEFAULT LIST
*
*        ADD, REPLACE, DELETE - COPY THE DEFAULT LIST
*
PRTICOPY CR    R2,R3         IS THIS THE END OF THE DEFAULT LIST?
         BNL   PRTITSET      YES, END OF PROCESSING FOR PRINT ITEMS
*
*        CHECK FOR ENTERED ITEMS THAT ARE ALSO
*              IN THE DEFAULT LIST.
*
PRTICDLP CLC   0(1,R2),0(R4) IS THIS THE SAME ITEM
         BE    PRTIFND       YES, SEE WHAT TO DO
         LA    R4,1(R4)      NO, GET TO THE NEXT ITEM
         CLI   0(R4),0       WAS THIS THE LAST ENTERED ITEM?
         BNE   PRTICDLP      NO, KEEP LOOKING
         LA    R4,VTPRNTEN   POINT BACK TO THE TOP OF THE LIST
*
*        ADD THIS ITEM TO THE NEW LIST
*
PRTICSKP MVC   0(1,R6),0(R2) MOVE IN THE NEW KEY
         LA    R6,1(R6)      POINT PAST IT
PRTICDEL LA    R2,1(R2)      GO DOWN THE DEFAULT LIST
         B     PRTICOPY      THEN KEEP ON CHECKING
*
*        AN ITEM WAS ENTERED AND WAS IN THE DEFAULT LIST
*        FOR DELETE, JUST DELETE ITEMS
*        FOR ADD AND REPLACE, DELETE ALL BUT THE FIRST ITEM
*              TO AVOID DUPLICATES
*              IF IT IS THE FIRST ITEM, INSERT THE ENTERED LIST
*
PRTIFND  LA    R0,VTPRNTEN   POINT TO THE FIRST ITEM
         CR    R0,R4         COMPARE WITH THE ITEM FOUND
         BH    PRTICDEL      NOT THE FIRST ITEM, DELETE IT
         CLI   0(R1),C'D'    IS THIS DELETE TIME?
         BE    PRTICDEL      THEN JUST DELETE IT
         CLI   0(R1),C'R'    IS THIS A REPLACE?
         BE    PRTIREPA      YES, IGNORE THIS DEFAULT ITEM
*
*        ADD THE DEFAULT ITEM FIRST
*
PRTIASKP MVC   0(1,R6),0(R2) MOVE IN THE NEW KEY
         LA    R6,1(R6)      POINT PAST IT
*
*        MOVE THE ITEMS IN FROM THE ADD OR REPLACE LIST
*
PRTIREPA LA    R2,1(R2)      GET PAST THE DEFAULT LIST ITEM
PRTIREP  LA    R4,1(R4)      GET PAST THE FIRST ENTRY
PRTINEXT CLI   0(R4),0       IS THIS THE LAST ITEM?
         BE    PRTICOPY      YES, SEE ABOUT MORE DEFAULTS
*
*        ADD AN ENTERED ITEM TO THE LIST
*
PRTINSKP MVC   0(1,R6),0(R4) MOVE IN THE NEW KEY
         LA    R6,1(R6)      POINT PAST IT
         B     PRTIREP       GO GET MORE ENTERED ITEMS
*
*        NEW LIST, JUST USE IT AS ENTERED
*
PRTINEW  LA    R1,VTPRNTEN   POINT TO THE ENTERED LIST
         ST    R1,VTPRNTLS   THEN SAVE ITS ADDRESS FOR LATER
PRTITSET DS    0H
*
*        BUILD THE TITLE LINE FOR THE DSNAME FIELDS
*
         CLEAR PRNTTITL        BLANK OUT THE TITLE LINE
         MVC   PRNTTITL+1(139),PRNTTITL  SO THE WHOLE THING IS GOOD
         L     R2,VTPRNTLS   GET THE PRINT ITEM LIST
         LA    R1,PRNTTITL    POINT TO THE TITLE LINE
TITLOOP  SR    R6,R6          GET THE RESERVED WORD NUMBER
         IC    R6,0(R2)       FROM THE TOP BYTE
         MH    R6,H12         MULTIPLY BY 12 FOR THE TABLE ENTRIES
         LA    R6,TABTITL(R6) THEN RELOCATE THE MESS
         SR    R7,R7          CLEAR A REGISTER
         IC    R7,0(R6)       GET THE EXECUTE LENGTH
         EX    R7,MOVETIT     MOVE IN THE TITLE
         LA    R1,1(R1,R7)    MOVE THE POINTER OVER
         CLI   0(R2),DSNAME  IS THIS THE DSNAME KEY
         BE    TITDSN        YES, SPECIAL PROCESSING
         LA    R0,PRNTTITL    POINT TO THE BEGINNING AGAIN
         SR    R1,R0          AND FIND THE CURRENT LENGTH
         CH    R1,LINELEN     IS IT TOO LONG?
         BNL   TITOVER        YES, PULL BACK
         AR    R1,R0          NO, KEEP GOING
TITINC   LA    R2,1(R2)            GET THE NEXT CHAIN POINTER
         CLI   0(R2),0       ARE WE DONE?
         BNE   TITLOOP        GO GET MORE TITLES
         B     TITEND         ALL DONE
TITDSN   LR    R6,R1         SAVE THE ADDRESS POINTER
         LA    R1,DSNPLN     POINT TO THE PDL FOR DSN LENGTH
         BAL   R8,PDLNUM     GO TRANSLATE IT
         LTR   R15,R15       WAS IT THERE?
         BP    TITDSN2       YES, USE IT
         LA    R15,44        NO, SET THE DEFAULT
TITDSN2  STH   R15,DSNLENGT  SAVE THE LENGTH
         SH    R15,H9        SUBTRACT THE 9 CHARS MOVED ALREADY
*              MINUS ONE FOR EX, PLUS ONE FOR SPACE
         MVI   0(R6),C' '    GET AN INITIAL BLANK
         EX    R15,DSNBLMOV  MOVE IN THE BLANKS
         LA    R1,1(R15,R6)  RESET THE POINTER ( INCLUDE A SPACE )
         LA    R15,1(R15)    ADD ON THE SPACE CHARACTER
         STH   R15,DSNLENOF  SAVE THE OFFSET
         B     TITINC        ALLOW DSNAME TO OVERFLOW THE LINE
*
*        TITLE RAN OFF THE END, CUT IT OFF
*
TITOVER  SR    R1,R7          SUBTRACT PAST THIS FIELD
         AR    R1,R0          RELOCATE IT
         BCTR  R1,0           THEN GET THE LAST CHARACTER
         MVC   0(9,R1),BLANKS THEN BLANK IT OUT
TITEND   TM    SYSOUT+48,X'10' IS THE DCB OPEN
         BNO   CKOUTPT       NO, TERMINAL OUTPUT, NO CC
         MVI   PRNTTITL,C'0'  ALWAYS SKIP A LINE FOR IT
CKOUTPT  CLI   OUTPUTK+1,1    OUTPUT THIS RUN?
         BNE   VTRET          YES, SKIP THE OPEN, JUST RETURN
         MVC   OUTDCB(OUTDCBL),OUTDCBC  INITIALIZE THE DCB
         MVI   OPENLIST,X'80' TERMINATE THE LIST
         OPEN  (OUTDCB,OUTPUT),MF=(E,OPENLIST)  OPEN THE DATA SET DCB
         B     VTRET          RETURN, INITIALIZATION IS DONE
         EJECT
*
*        ROUTINE TO CONVERT A TEXT DSCB ITEM
*        INTO ITS KEY NUMBER
*        INPUT IS REG 4 - IKJIDENT PTR
*        OUTPUT IS REG 15 - KEY NUMBER
*        ENTRY VIA BAL   R8,GETKEY
*
GETKEY   L     R1,ATABTITL     POINT TO THE TABLE
         LA    R1,12(R1)     POINT TO THE FIRST ENTRY
         LA    R15,1           SET UP THE KEY NUMBER COUNTER
         L     R6,0(R4)      POINT TO THE ENTERED TEXT
         ICM   R3,3,4(R4)    GET THE LENGTH OF THE ENTERED TEXT
         BNP   GETKNOTF      NOT FOUND IF ZERO
         BCTR  R3,0          MINUS ONE FOR THE EX
GETKLOOP LA    R2,4(R1)      POINT TO THE COMPARISON TEXT
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
         CLI   0(R2),C' '    IS IT HERE?
         BNE   GETKSTD       YES, THIS IS IT
         LA    R2,1(R2)      NO, MOVE OVER ONE MORE
GETKSTD  EX    R3,GETKCOMP   COMPARE THE KEY TEXT
         BE    GETKFND       I FOUND IT
         LA    R1,12(R1)     GET TO THE NEXT KEY
         LA    R15,1(R15)    INCREMENT THE KEY COUNTER
         CH    R15,H26       CHECK FOR THE END OF THE TABLE
         BNH   GETKLOOP      NOT YET, KEEP LOOKING
*
*        KEY WAS NOT FOUND, SEND BACK A ZERO
*
GETKNOTF SR    R15,R15       SET UP THE ZERO AND RETURN
GETKFND  BR    R8            JUST RETURN
GETKCOMP CLC   0(0,R6),0(R2) EXECUTED TEXT COMPARE
H26      DC    H'26'
         EJECT
*
*        PROGRAM CONSTANTS
*
ZERO     DC    F'0'
F100     DC    F'100'
F127     DC    F'127'
DEFLMAX  DC    H'60'          DEFAULT LINES PER PAGE
DEFLEN   DC    H'132'         DEFAULT CHARS PER LINE
H2       DC    H'2'
H5       DC    H'5'
H9       DC    H'9'
H10      DC    H'10'
H12      DC    H'12'
H18      DC    H'18'
H32      DC    H'32'
MOVETIT  MVC   0(0,R1),3(R6)  MOVE IN THE TITLE
COMPKEY  CLC   0(0,R1),VTFDSN  EXECUTED COMPARE
MOVEHEAD MVC   PRNTHEAD(0),0(R2)
MOVEHED  MVC   PRNTHEAD+21(0),4(R14)  MOVE CMD BUF TO DEFAULT HEADER
DSNBLMOV MVC   1(0,R6),0(R6)  BLANK OUT THE DSN SPACE IN THE TITLE
CPAGE    DC    C'PAGE'
EDMASK   DC    XL16'40202020202020202020202020202120'
EDMASK0  DC    XL16'F0202020202020202020202020202120'
SKIP     DC    C'0'
COMP0    DC    CL16'0000000000000000'
BLANKS   DC    CL16'                '
STARS    DC    CL16'****************'
TABSPACE DC    CL8'TRKS'
         DC    CL8'TRKS'
         DC    CL8'TRKS'
         DC    CL8'TRKS'
         DC    CL8'TRKS'
*
         PRINT NOGEN
SYSOUTC  DCB   DSORG=PS,DDNAME=VTOCOUT,MACRF=PM,                       X
               RECFM=FBA,LRECL=150,BLKSIZE=1500
OUTDCBC  DCB   DSORG=PS,DDNAME=OUTPUT,MACRF=PM,                        X
               RECFM=FB,LRECL=100,BLKSIZE=6000
*
*        PROGRAM MESSAGES
*
         SPACE 2
         SPACE
MSGTOTC  MSG   '  TOTALS -  NNNN DATA SETS, MMMMMMMM UUUUUU ALLOC, LLLLX
               LLLL UUUUUU USED '
MSGTLEN  EQU   *-MSGTOTC
MSGBLC   MSG   '                '
*
DEFHEAD  DC    CL20'1 VTOC COMMAND  V-84'
*
*        DEFAULT PRINT LIST
*
DEFPRNT  DC    AL1(ALLOC)
         DC    AL1(UNUSED)
         DC    AL1(PCT)
         DC    AL1(EXT)
         DC    AL1(DSORG)
         DC    AL1(RECFM)
         DC    AL1(LRECL)
         DC    AL1(BLKSZ)
         DC    AL1(CDATE)
         DC    AL1(LSTUS)
         DC    AL1(VOLUME)
         DC    AL1(DSNAME)
         DC    AL1(EXPDT)
         DC    AL1(SECQ)
         DC    AL1(SECT)
         DC    AL1(ROUND)
         DC    AL1(PASS)
         DC    AL1(ACTION)
         DC    AL1(TYPE)
         DC    AL1(0)        END OF THE LIST
DEFPRNTE EQU   *
DEFPRNTL EQU   *-DEFPRNT
*
*        TABLE OF PRINT ITEM LENGTHS AND TITLES
*
*        ENTRIES IN THE TABLE FOR EACH FORMATTED ITEM -
*        FIRST BYTE IS FIELD LENGTH FOR OUTPUT ( MINUS ONE FOR EX )
*        SECOND BYTE - X'80' BIT INDICATES A CHARACTER FIELD
*                            THEN BITS 0-7 GIVE VTFMT LENGTH
*                      OTHERWISE IT'S A KEY TO WHICH ROUTINE TO USE
*        THIRD BYTE - OFFSET IN FORMATTED DSCB, VTFMT
*        4-12 TH BYTES, THE TITLE FOR THE FIELD
*
*
TABTITL  DC    XL12'00'  DUMMY ENTRY FOR 0 ADDRESSING
         DC    AL1(8),AL1(128+7),AL1(VTFACTON-VTFMT),CL9' ACTION  '  1
         DC    AL1(6),AL1(128+5),AL1(VTFVOLUM-VTFMT),CL9' VOLUME  '  2
         DC    AL1(5),AL1(000+4),AL1(VTFCREDT-VTFMT),CL9' CDATE   '  3
         DC    AL1(5),AL1(000+4),AL1(VTFLSTAC-VTFMT),CL9' REFDT   '  4
         DC    AL1(5),AL1(000+4),AL1(VTFEXPDT-VTFMT),CL9' EXPDT   '  5
         DC    AL1(6),AL1(00+12),AL1(VTFALLOC-VTFMT),CL9'  ALLOC  '  6
         DC    AL1(6),AL1(00+16),AL1(VTFALLOC-VTFMT),CL9' UNUSED  '  7
         DC    AL1(3),AL1(00+20),AL1(VTFALLOC-VTFMT),CL9' PCT     '  8
         DC    AL1(2),AL1(00+24),AL1(VTFNOEPV-VTFMT),CL9' EXT     '  9
         DC    AL1(3),AL1(128+2),AL1(VTFDSORG-VTFMT),CL9' DSO     ' 10
         DC    AL1(3),AL1(128+3),AL1(VTFRECFM-VTFMT),CL9' RFM     ' 11
         DC    AL1(5),AL1(00+28),AL1(VTFBLKSZ-VTFMT),CL9' BLKSZ   ' 12
         DC    AL1(5),AL1(00+28),AL1(VTFLRECL-VTFMT),CL9' LRECL   ' 13
         DC    AL1(4),AL1(128+0),AL01(VTFPROT-VTFMT),CL9' PASS    ' 14
         DC    AL1(3),AL1(128+0),AL1(VTFCATLG-VTFMT),CL9' CAT     ' 15
         DC    AL1(4),AL1(128+0),AL1(VTFSECAL-VTFMT),CL9' SECT    ' 16
         DC    AL1(5),AL1(00+28),AL1(VTFSECAM-VTFMT),CL9'  SECQ   ' 17
         DC    AL1(4),AL1(00+36),AL1(VTFVOLUM-VTFMT),CL9' UNIT    ' 18
         DC    AL1(5),AL1(128+0),AL1(VTFROUND-VTFMT),CL9' ROUND   ' 19
         DC    AL1(4),AL1(128+0),AL1(VTFDSTYP-VTFMT),CL9' TYPE    ' 20
         DC    AL1(6),AL1(00+12),AL01(VTFUSED-VTFMT),CL9'   USED  ' 21
         DC    AL1(8),AL1(00+32),AL1(VTFVOLUM-VTFMT),CL9'   CCHH  ' 22
         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY3  ' 23
         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY4  ' 24
         DC    AL1(6),AL1(128+0),AL1(VTFVOLUM-VTFMT),CL9' DUMMY5  ' 25
         DC    AL1(8),AL1(00+32),AL001(VTFDSN-VTFMT),CL9' DSNAME  ' 26
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
PRNTWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
TOTDS    DS    F              TOTAL COUNTER
TOTALLOC DS    F              TOTAL ALLOCATION
TOTUSED  DS    F              TOTAL USED
FTOTDS   DS    F              FINAL TOTAL DATA SETS
FTOTALLC DS    F              FINAL TOTAL ALLOC
FTOTUSED DS    F              FINAL TOTAL USED
PRNTLSAV DS    A
PRINTR8  DS    A
PRNTTOT8 DS    A
ADDREND  DS    A
PAGEADDR DS    A
OPENLIST DS    2A             PARM LIST FOR OPEN
PDLNSAVE DS    8A             REGISTER SAVE AREA FOR PDLNUM RTN
PRTLSAVE DS    8A             REGISTER SAVE AREA FOR PRNTLINE RTN
LASTKEY  DS    A              ADDRESS OF LAST KEY FOR SUBTOTALS, BREAKS
NUMBREAK DS    H              CHARACTERS TO COMPARE FOR BREAK
NUMTOTAL DS    H              CHARACTERS TO COMPARE FOR SUBTOTALS
         PRINT NOGEN
SYSOUT   DCB   DSORG=PS,DDNAME=VTOCOUT,MACRF=PM,                       X
               RECFM=FBA,LRECL=150,BLKSIZE=1500
SYSOUTL  EQU   *-SYSOUT
OUTDCB   DCB   DSORG=PS,DDNAME=OUTPUT,MACRF=PM,                        X
               RECFM=FB,LRECL=100,BLKSIZE=6000
OUTDCBL  EQU   *-OUTDCB
ENDTOTAL DS    X              PROGRAM SWITCHES
ENTOTOUT EQU   X'80'          THE FINAL TOTALS HAVE BEEN OUTPUT
ENDTONLY EQU   X'10'          NO SUBTOTALS, END TOTALS ONLY
NOBREAK  EQU   X'08'          NO BREAKS
FIRSTIM  DS    X              INITIALIZATION FOR THIS ROUTINE
PDLMINUS DC    X'00'
TOTLAST  DS    X
SPACTYPE DS    CL6          CHARACTERS FOR SPACE UNITS
DSNLENGT DS    H
DSNLENOF DS    H
CHARS    DS    CL16           CONVERSION TO CHARACTERS
MSGWORK  DS    CL256          AREA FOR BUILDING MESSAGES
WORKLINE DS    CL256          AREA FOR DATA SET
PRNTHDRH DS    F
PRNTHEAD DS    CL256          AREA FOR HEADER
PRNTTITH DS    F
PRNTTITL DS    CL256          AREA FOR ITEM TITLES
MSGBL    DS    CL20           AREA FOR BLANK LINE
OUTWORK  DS    CL256          WORKING AREA FOR OUTPUT
DCBEXIT  DS    F
JFCB     DS    XL176
         SPACE
VTPRNTLS DS    A             PRINT ITEM LIST ADDRESS
VTPRNTL  DS    40C           PRINT ITEM LIST ( IF MODIFIED )
VTPRNTEN DS    40C
VTPRNTEX DS    C
         SPACE
         DS    0D
LENWORK  EQU   *-PRNTWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
DUMMD    DSECT
DUMMA    DS    C              DUMMY ENTRY TO USE FOR CONV
         PRINT NOGEN
         DCBD  DSORG=PS,DEVD=DA
         END
VTOCSORT TITLE 'VTOC COMMAND - SORT  ROUTINE'
***********************************************************************
*                                                                     *
*                                                                     *
*                                                                     *
* FUNCTION -   PUT THIS FORMATTED DSCB INTO THE SORTED LIST.          *
*                                                                     *
* OPERATION -  IF THIS IS A NOSORT RUN, JUST CALL THE PRINT ROUTINE.  *
*              TO BUILD THE SORTED LIST, FIRST DO A SIMPLE HASH       *
*              ON THE FIRST CHARACTER.  BUILD UP TO 256 SEPARATE      *
*              LISTS TO SAVE SORT TIME.  THEN SEARCH THROUGH THESE    *
*              LISTS SEQUENTIALLY.                                    *
*                                                                     *
* INPUT -      VTOC COMMON AREA ( VTOCOM )                            *
*              POINTED TO BY REGISTER 1                               *
*              USE PARSE DATA, CURRENT FORMATTED DSCB, SORTED LIST    *
*                                                                     *
* OUTPUT -     THE FORMATTED DSCB IS PLACED INTO THE SORTED LIST.     *
*                                                                     *
* ATTRIBUTES - REENTRANT, REUSEABLE, REFRESHABLE.                     *
*                                                                     *
*                                                                     *
*         PROGRAMMED BY R. L. MILLER  (415) 485-6241                  *
*                                                                     *
*                                                                     *
***********************************************************************
         EJECT
VTOCSORT ENTER 12,24          DO THE HOUSEKEEPING
         LR    R11,R1         SAVE ADDR OF VTOCOM
         USING VTOCOM,R11     SET ITS ADDRESSABILITY
         L     R9,ADDRANSR    POINT TO THE PARSE ANSWER
         USING PDL,R9         SET ITS ADDRESSABILITY
         USING SORTWORK,R13   SET ADDRESSABILITY FOR LOCAL WORK AREA
         SPACE 3
*
*        IS THIS A NOSORT RUN ?
*        IF SO, JUST CALL PRINT
*
         CLI   SORTK+1,2      IS THIS NOSORT?
         BNE   GOSORT         NO, KEEP ON TRUCKIN'
         VTCALL PRNT          YES, CALL PRINT AND GET OUT
         B     SORTRET        GET OUT OF HERE
*
*        PUT THIS ENTRY WHERE IT BELONGS
*
GOSORT   L     R3,FORMATAD    POINT TO THE FORMATTED DSCB
         USING VTFMT,R3       SET ADDRESSABILITY
         LA    R6,SORTTAB     POINT TO THE SORT FIELDS TABLE
         SR    R4,R4
         IC    R4,1(0,R6)     LOAD HIGH KEY OFFSET
         LA    R4,VTFMT(R4)   POINT TO HIGH KEY
         LA    R2,VTCSORTH-12 SORT HEADER AREA
GOSORT1  LA    R2,12(0,R2)    NEXT ENTRY
         LH    R5,4(0,R2)     LOAD COMAPRE LENGTH
         CLI   0(R6),C'D'     DESCENDING SORT
         BE    GOSORT3        YES
         B     GOSORT4        NO
GOSORT2  ICM   R5,B'1111',0(R2) GET THE HEAD OF THE LIST
         BNZ   NOTFIRST       IF NON-ZERO, SEARCH THE LIST
*
*        FIRST ENTRY ON THE LIST, IT'S EASY
*
         ST    R3,0(R2)       START UP THE LIST
         B     SORTRET        THEN RETURN
GOSORT3  EX    R5,GOSORTCL    COMPARE TO GET CORRECT LIST
         BL    GOSORT1
         B     GOSORT2
GOSORT4  EX    R5,GOSORTCL    COMPARE TO GET CORRECT LIST
         BH    GOSORT1
         B     GOSORT2
*
*        FIND A SLOT FOR THIS ENTRY
*              FIRST GET THE SHORTER DSN LENGTH
*
NOTFIRST SR    R1,R1
         IC    R1,1(0,R6)     OFFSET OF SORT FIELD
         LA    R7,0(R1,R5)    LOAD PREV ENTRY FIELD ADDR
         LA    R8,0(R1,R3)    LOAD NEW ENTRY FIELD ADDR
         C     R1,=A(VTFDSN-VTFMT)  DSN
         BNE   NOTFRST1
         LH    R1,VTFDSNL-VTFMT(0,R3)
         CH    R1,VTFDSNL-VTFMT(0,R5)
         BNH   NOTFRST0
         LH    R1,VTFDSNL-VTFMT(0,R5)
NOTFRST0 BCTR  R1,0
         B     NOTFRST2
NOTFRST1 LH    R1,2(0,R6)     LOAD SORT FIELD EXEC LENGTH
NOTFRST2 CLI   0(R6),C'D'     DESCENDING SORT
         BE    NOTFRST4       YES
NOTFRST3 EX    R1,COMPVTF     COMPARE THE FIELDS
         BL    NEXTENT        LIST ENTRY IS LOWER, UP THE CHAIN
         BE    CHECKNXT       IDENTICAL, CHECK NEXT FIELD
         B     INSERT
NOTFRST4 EX    R1,COMPVTF     COMPARE THE FIELDS
         BH    NEXTENT        LIST ENTRY IS LOWER, UP THE CHAIN
         BE    CHECKNXT       IDENTICAL, CHECK NEXT FIELD
*
*        THE NEW ENTRY GOES HERE
*
INSERT   ST    R3,0(R2)       SAVE THE NEW POINTER
         ST    R5,VTFNEXT     JUST BEFORE THIS LIST ENTRY
         B     SORTRET        THEN EXIT
*
*
CHECKNXT LA    R6,4(0,R6)     NEXT SORT FIELD
         CLC   0(4,R6),=F'0'  ANY MORE FIELDS
         BE    INSERT         NO, PUT IT HERE
         B     NOTFIRST       YES, CHECK IT
*
*        GET THE NEXT ENTRY ON THIS LIST
*
NEXTENT  LA    R2,VTFNEXT-VTFMT(R5)  POINT BACK TO THIS ENTRY
         LA    R6,SORTTAB     RELOAD SORT FIELD TABLE ADDR
         ICM   R5,B'1111',VTFNEXT-VTFMT(R5)  GET THE NEXT ENTRY
         BNZ   NOTFIRST       THERE IS ONE, CHECK IT
         ST    R3,0(R2)       LAST ENTRY ON THE LIST, PUT IT THERE
*
*        RETURN
*
SORTRET  LEAVE EQ,RC=0
*
*
*
*        PROGRAM CONSTANTS
*
COMPVTF  CLC   0(0,R7),0(R8)     EXECUTED COMPARE
GOSORTCL CLC   0(0,R4),6(R2)     EXECUTED COMPARE
*
*
         PRINT NOGEN
         EJECT
*
*
*        P A R S E   C O N T R O L   L I S T
*
*
         PRINT OFF
         COPY  VTOCPARS
         PRINT ON
*
*        DYNAMIC WORK AREA
*
         SPACE 3
SORTWORK DSECT
         DS    18A            PRINT ROUTINE SAVE AREA
         SPACE
         DS    0D
LENWORK  EQU   *-SORTWORK
*
*        VTOC COMMAND COMMON AREA
*
         PRINT NOGEN
         VTOCOM
         SPACE 3
*
*        FORMATTED DSCB
*
         VTFMT
         SPACE 3
         PDEDSNAM
         SPACE 3
         END
