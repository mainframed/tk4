#pragma eject
#pragma title win3270.c - display fields on a 3270 device

/*+-----------------------------------------------------------------+
  × Program:   win3270.c                                            ×
  × Language:  C - Some specific SAS/C v5.50C routines required.    ×
  × Support:   DAF                                                  ×
  × Purpose:   To allow a full screen dialog application to be      ×
  ×            created using the CLIST or REXX language in the      ×
  ×            TSO environment.                                     ×
  × History:   24Aug95 Inital coding, frame work only.          DAF ×
  ×            15Sep95 Added some more code.                    DAF ×
  ×                                                                 ×
  ×            The following publications have been used in the     ×
  ×            developement of this program:                        ×
  ×              SC28-1875 TSO/E v2 programming Services            ×
  ×              GA23-0059 3270 Info. Display Sys. Data Stream      ×
  ×                        Programmers Reference.                   ×
  ×              GA27-3831 3174 Establishment Controller Character  ×
  ×                        Set Reference.                           ×
  ×              GA27-2837 3270 Character Set Reference.            ×
  ×              HUR 9058  IBM3270 Personal Computer Graphics       ×
  ×                        Control Program Data Stream Reference.   ×
  ×              GA18-2589 IBM 3179-G/3192-G Color Graphics Display ×
  ×                        Station Description.                     ×
  ×              GG27-6999 Introduction to Programming the IBM 3270.×
  ×              SC28-1882 MVS/REXX Users Guide.                    ×
  ×              SC28-1883 Procedure Language MVS/REXX Reference.   ×
  ×                                                                 ×
  ×              56117     SAS/C Library Reference - Volume 1       ×
  ×              56118     SAS/C Library Reference - Volume 2       ×
  ×              56123     SAS/C Compiler and Library Users Guide   ×
  ×              59014     SAS Technical report C-109 Changes and   ×
  ×                        Enhancements to the C Library Reference  ×
  ×                        Release 5.00                             ×
  ×                                                                 ×
  × Notes:     1. Numeric fields do not work the same on all        ×
  ×               devices. The 3192-G allows lowercase character    ×
  ×               input. Many devices also upper case character     ×
  ×               input.                                            ×
  ×            2. Most devices do not support field attributes:     ×
  ×               Field Outlining, Background color, and Field      ×
  ×               Validation.                                       ×
  ×            3. The character set for APL does not appear to be   ×
  ×               allowed on the SFE order, only on the SA order.   ×
  × End.                                                            ×
  +-----------------------------------------------------------------+*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <exec.h>
#include <ctype.h>
#include <svc.h>
#include <tput.h>
#include <ostask.h>

#define _AMODE31

#include "ps9x16u.inc"
#include "ps9x15u.inc"
#include "ps9x12u.inc"

/* Token delimiters */
#define DELIMS " ="
#define DELIMQ "'="

/* Attribute value array indexes */
#define AVALUE  0
#define ATYPE   1
#define ACOLOR  2
#define AHILITE 3
#define ASYMBOL 4
#define AJUST   5

/* escape character and device commands */
#define ESC     0x27
#define EW      0xf5
#define EWA     0x7e
#define WRT     0xf1
#define WSF     0xf3
#define RB      0xf2

/* write control characters, or'd together as required */
#define WCCMDT  0x01
#define WCCKBD  0x02
#define WCCRES  0xc0
#define WCCBEL  0x04

/* 3270 data stream orders */
#define GE      0x08
#define FF      0x0c
#define CRR     0x0d
#define SBA     0x11
#define EUA     0x12
#define ICUR    0x13
#define NL      0x15
#define EM      0x19
#define DUP     0x1c
#define SF      0x1d
#define FM      0x1e
#define SA      0x28
#define SFE     0x29
#define MF      0x2c
#define RA      0x3c
#define SUB     0x3f

#define PROT    0x20
#define NUM     0x10

/* Type byte of the SA, SFE and MF orders */
#define ALL     0x00
#define NONE    0x00
#define DFLT    0x00

#define ATTR    0xc0
#define FVALID  0xc1
#define OUTLIN  0xc2
#define HILITE  0x41
#define COLOR   0x42
#define SYMSET  0x43
#define BAKCOL  0x45
#define TRANSP  0x46

#define APL     0xF1

/* Out lines for the value byte of the SA, SFE, or MF order */
#define UNDR    0x01
#define OVR     0x04
#define OVRUND  0x05
#define NOOVR   0x0b
#define NOUNDR  0x0e
#define RECT    0x0f

/* Hilites for the value byte of the SA, SFE, or MF order */
#define BLINK   0xf1
#define RVIDEO  0xf2
#define REVERSE 0xf2
#define USCORE  0xf4
#define ULINE   0xf4

/* Colors for the value byte of the SA, SFE, or MF order */
#define BLUE    0xf1
#define RED     0xf2
#define PINK    0xf3
#define GREEN   0xf4
#define TURQ    0xf5
#define CYAN    0xf5
#define YELLOW  0xf6
#define WHITE   0xf7

/* Attribute for the value byte of the SF, SFE and MF order */
#define UNPRT   0x40
#define UNNUM   0x50
#define UNNUMHI 0xd8
#define UNNON   0x4c
#define UNHI    0xc8
#define PRT     0x60
#define PRTHI   0xe4
#define PRTAS   0xf0
#define PRTHIAS 0xf8

/* Field input attribute settings */
#define INPUT   0x01
#define NOINPUT 0x00

/* Field subtype identifiers */
#define TEXT    'T'
#define CONTROL 'C'

/* Attention Identification (AID) Values */
#define NOAID   0x60
#define NOAIDP  0xe8
#define STRFLD  0x88
#define ENTER   0x7d
#define PF1     0xf1
#define PF2     0xf2
#define PF3     0xf3
#define PF4     0xf4
#define PF5     0xf5
#define PF6     0xf6
#define PF7     0xf7
#define PF8     0xf8
#define PF9     0xf9
#define PF10    0x7a
#define PF11    0x7b
#define PF12    0x7c
#define PF13    0xc1
#define PF14    0xc2
#define PF15    0xc3
#define PF16    0xc4
#define PF17    0xc5
#define PF18    0xc6
#define PF19    0xc7
#define PF20    0xc8
#define PF21    0xc9
#define PF22    0x4a
#define PF23    0x4b
#define PF24    0x4c
#define OID     0xe6
#define MAG     0xe7
#define PEN     0x7e
#define PA1     0x6c
#define PA2     0x6e
#define PA3     0x6b
#define CLEAR   0x6d
#define SYSREQ  0xf0

/* size constants */
#define BUFFMAX  5000
#define SFIDMAX  256
#define ATTRMAX  50
#define TSOVSIZE 32



/*--------------------------------------------------------------------*/
/* Special types                                                      */
/*--------------------------------------------------------------------*/
typedef
  struct LSTR     /* string with length */
  {
    int len ;             /* current length of data */
    char *data ;          /* pointer to data */
  } TLSTR ;

typedef
  struct SFLD     /* 3270 screen field information list entry */
  {
    int fid ;             /* unique field identifier */
    TLSTR fdata ;         /* field data (input or output) */
    int fxpos ;           /* X column position */
    int fypos ;           /* Y row position */
    char fattr ;          /* 3270 field attribute */
    char fcolor ;         /* 3270 color attribute */
    char fhilite ;        /* 3270 hilite attribute */
    char symbol ;         /* 0x00=normal 0xf1=APL else 0x40-0xef=PS */
    char just ;           /* justify, L=Left R=Right C=Center N=None */
    char modflg ;         /* field modified 01=yes 00=no */
    char inputflg ;       /* input allowed for field 01=yes 00=no */
    char type ;           /* widget type */
                          /* L = LABEL .....> tsovar = NULL */
                          /* I = INPUT */
                          /* O = OUTPUT */
                          /* B = BUTTON */
                          /* R = RADIO */
                          /* C = CHECKBOX */
    char subtype ;        /* widget sub type for radio and checkbox */
                          /* T = display text field */
                          /* C = control symbol field */
                          /* 00 = not used */
    char *tsovar ;        /* pointer to TSO variable name string */
    struct SFLD *next ;   /* next list entry */
  } TSFLD ;

typedef
  struct WINDOW   /* List of defined windows and their info. */
  {
    int srow ;            /* start row of window */
    int scol ;            /* start column of window */
    int delay ;           /* time to wait after display (secs.) */
    int lastcol ;         /* last cursor coloumn - on screen */
    int lastrow ;         /* last cursor row - on screen */
    int fidnext ;         /* next field id number to assign */
    TSFLD *fields ;       /* field list for window */
    TSFLD *sfidtab[SFIDMAX] ; /* field id address table */
    char name[9] ;        /* name of window */
    char lastvar[32] ;    /* last variable selected or empty */
    char lastword[32] ;   /* last word selected or empty */
    char lastkey ;        /* last key pressed */
    char eraseflg ;       /* erase screen required 01=yes 00=no */
    char inputflg ;       /* input flag 0=no input, 1=input allowed */
    char bdselflg ;       /* border selected flag, selected=1 */
    int bellflg ;         /* ring bell on next display */
    struct WINDOW *next ; /* next list entry */
  } TWINDOW ;



/*--------------------------------------------------------------------*/
/* Global Variables                                                   */
/*--------------------------------------------------------------------*/
int (*xtputn)(char *,int) ; /* tput noedit routine */
int (*xtgetn)(char *,int) ; /* tget routine */
int (*xtpgn)(char *,int) ;  /* tpg routine */

char attrtab[ATTRMAX][6] ; /* value character attribute mapping */
char msg[120] ;          /* output message buffer */
int attrnext ;           /* next attrtab entry to use */
int mlev ;               /* msg level,0=off, 1..9=level, 9++ =special */

char *buffer ;    /* buffer area for tput/tget */

TWINDOW *windows ;/* root of all windows */
TWINDOW *curwin ; /* currently active window */

int iotrace = 0 ;         /* trace terminal I/O flag */


struct DCB        /* Device control block */
  {
    int model ;         /* model number ie: 3279, 3278, 3277 */
    int type ;          /* model type ie: 2, 3, 4, 5 */
    int rows ;          /* number of rows (height) on device */
    int cols ;          /* number of columns (width) on device */
    int celheigh ;      /* cell height on device */
    int celwidth ;      /* cell width on device */
    int uacelh ;        /* usable area cell height on device */
    int uacelw ;        /* usable area cell width on device */
    int colors ;        /* number of colors on device */
    int colora ;        /* number of actual colors on device */
    int hilites ;       /* number of colors on device */
    int adrmode ;       /* device addressing mode: 12 or 14 or 16 bit*/
    char unit ;         /* 0 = inch 1 = mm */
    char edsflg ;       /* extended data stream flag */
    char psflg ;        /* program symbols on device flag */
    char altflg ;       /* use alternate flag */
    char aplflg ;       /* 0 or apl's lcid=supports APL on device */
    char graflg ;       /* graphics device flag */
    char loadflg ;      /* loadable symbol sets supported flag */
    char triflg ;       /* triple plane symbol sets supported flag */
    char dbcsflg ;      /* double byte characters supported flag */
    char colorlst[17] ; /* list of color attributes on device */
    char hilitlst[5] ;  /* list of hilite attributes on device */
    char modname[11] ;  /* name of device ie: IBM32793B IBM3179G ..*/
  } sdcb ;



/*-------------------------------------------------------------------*/
/* Function Prototypes                                               */
/*-------------------------------------------------------------------*/

/* win3270 */
void help() ;
int wacmd(char *) ;
int wecmd(char *) ;
int wccmd(char *) ;
int wscmd(char *) ;
int wdcmd(char *) ;
/* field handling */
int initscr() ;
void termscr() ;
char dspflds() ;
int insfld(TLSTR *, int, int, char, char, char, char, char, char) ;
int getvfid(char *) ;
int getdev() ;
int remflds() ;
int delfld(int) ;
int erasefld(int) ;
int setfvar(int, char *) ;
int getfld(int, TLSTR *) ;
int modfld(int, TLSTR *) ;
int setfld(int, int, char) ;
void dumpfld() ;
void var2fld() ;
void fld2var() ;
void cursorp(char *, char *) ;
/* 3270 support */
int tputn(char *, int) ;
int tgetn(char *, int) ;
int tpgn(char *, int) ;
void rc2sba(int, int, char *) ;
void sba2rc(char *, int *, int *, int) ;
void getkeynm(char *, char) ;
int modsym(char *, char) ;
int modcolor(char *, char) ;
int modhilit(char *, char) ;
int modattr(char *, char) ;
int getterm(int *, int *, int *, int *, int *) ;
int querydev() ;
int dsummary(char *, short) ;
int darea(char *, short) ;
int dcharset(char *, short) ;
int dcolor(char *, short) ;
int dhilite(char *, short) ;
int dmodes(char *, short) ;
int dimpart(char *, short) ;
int loadps1() ;
void termstat() ;
void clear() ;
/* varying length string */
void lstran(TLSTR *, char, char) ;
int lstrlen(TLSTR *) ;
void lstrload(TLSTR *, char *, int) ;
int lstrunld(char *, TLSTR *) ;
void lstrcopy(TLSTR *, TLSTR *) ;
void lstrnewx(TLSTR *, char *, int) ;
void lstrnew(TLSTR *, char *) ;
void lstrsub(TLSTR *, TLSTR *, int, int) ;
int lstrindx(TLSTR *, TLSTR *) ;
void lstrfill(TLSTR *, char *) ;
int lstrcmpc(TLSTR *, char *) ;
void lstrdel(TLSTR *) ;
void lstrover(TLSTR *, char, int) ;
void lstrrep(TLSTR *, char *, int) ;
void lstrcat(TLSTR *, TLSTR *, TLSTR *) ;
/* utility */
void fill(char *, char, int) ;
void dumpchar(char *, int) ;
void overlay(char *, int, char *, int, int) ;
void serror(int, char *) ;
void strtoupr(char *) ;



/*--------------------------------------------------------------------*/
/* Main program                                                       */
/*--------------------------------------------------------------------*/
main(int argc, char **argv, char **envp)
  {
    char *input, *cmdname, *operands ;
    char *number_end ;
    char *color ;
    char rexxnm[9] ;      /* if rexxflg, names a REXX to start */
    int interact ;
    int rexxflg = 0 ;     /* processing with REXX option */
    int cmdcnt = 0 ;
    int rcode ;
    int maxrc = 0 ;
    int i ;               /* counter */
    int t ;               /* temp */

    mlev = 0 ;
    attrnext = 0 ;
    windows = NULL ;  /* root of all windows */
    curwin = NULL ;   /* root of current 3270 window field list */

    /* extract program parameters */
    if (argc>0)
      {
        i = 1 ;           /* skip first arg(0)=(pgm name) */
        while(i<argc)
          {
            if (strcmp(argv[i],"-D")==0)
              mlev = 9 ;     /* debug on */
            else if (strcmp(argv[i],"-M")==0)
              mlev = 1 ;     /* debug on */
            else if (strcmp(argv[i],"-H")==0)
              {
                help() ;        /* print some help info and end */
                return 0 ; /* and exit */
              }
            else if (strcmp(argv[i],"-REXX")==0)
              {
                i++ ;
                if (i<argc)
                  {
                    rexxflg = 1 ;
                    strcpy(rexxnm,argv[i]) ;
                  }
              }
            else if (strcmp(argv[i],"-ML")==0)
              {               /* documentory name */
                i++ ;
                if (i<argc)
                  {
                    mlev = strtol(argv[i], &number_end,10) ;
                    if (!number_end)
                      {
                        sprintf(msg,"Invalid message level %s",argv[i]);
                        execmsg("WIN002E",msg) ;
                        rcode = 4 ;
                      }
                    else
                      {
                        if (mlev <= 9)
                          {
                            sprintf(msg,"Message level now %d",mlev) ;
                            execmsg("WIN003I",msg) ;
                          }
                        else
                          {
                            sprintf(msg,"Message too large, 0 used.") ;
                            execmsg("WIN003I",msg) ;
                            mlev = 0 ;
                          }
                      }
                  }
              }
            else
              {
                sprintf(msg,"Ingoring invalid parameter: %s \n",
                  argv[i]) ;
                execmsg("WIN006I",msg) ;
                sprintf(msg,"Use -H parm. for more info.\n") ;
                execmsg("WIN007I",msg) ;
                sprintf(msg,"Use WX sub-command to end.\n") ;
                execmsg("WIN009I",msg) ;
              }
            i++ ;
          }  /* of while more args */
      }  /* of if args */

    rcode = initscr() ;
    if (rcode != 0)
      {
        sprintf(msg,"WIN3270 create environment failed, rc=%d",rcode) ;
        execmsg("WIN020E",msg) ;
        return 8 ;
      }

    interact = 0 ;
    execinit("WIN3270",interact) ;    /* init - noninteractive mode */

    *msg = '\0' ;
    for (i=0;i<sdcb.hilites;i++)
      {
        switch (sdcb.hilitlst[i])
          {
          case BLINK:
            color = "BLINK" ;
            break ;
          case REVERSE:
            color = "REVERSE" ;
            break ;
          case ULINE:
            color = "ULINE" ;
            break ;
          case DFLT:
            color = "NONE" ;
            break ;
          default:
            color = "NONE" ;
            break ;
          }
        if (i==0)
          sprintf(msg,"%s",msg,color) ;  /* first hilite in list */
        else
          sprintf(msg,"%s %s",msg,color) ;  /* append hilite to list */
      }
    rcode = shvset("WINSYSDH",msg) ;
    if (rcode!=SHV_SUCCESS)
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Failed to set variable WINSYSDH") ;
            execmsg("WIN063E",msg) ;
          }
        execend() ;
        return 4 ;
      }

    *msg = '\0' ;
    for (i=0;i<sdcb.colora;i++)
      {
        switch (sdcb.colorlst[i])
          {
          case BLUE:
            color = "BLUE" ;
            break ;
          case RED:
            color = "RED" ;
            break ;
          case PINK:
            color = "PINK" ;
            break ;
          case GREEN:
            color = "GREEN" ;
            break ;
          case CYAN:
            color = "CYAN" ;
            break ;
          case YELLOW:
            color = "YELLOW" ;
            break ;
          case WHITE:
            color = "WHITE" ;
            break ;
          case DFLT:
            color = "BLACK" ;
            break ;
          default:
            color = "BLACK" ;
            break ;
          }
        if (i==0)
          sprintf(msg,"%s",msg,color) ;  /* first color in list */
        else
          sprintf(msg,"%s %s",msg,color) ;  /* append color to list */
      }
    rcode = shvset("WINSYSDC",msg) ;
    if (rcode!=SHV_SUCCESS)
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Failed to set variable WINSYSDC") ;
            execmsg("WIN057E",msg) ;
          }
        execend() ;
        return 4 ;
      }

    sprintf(msg,"%d",sdcb.rows) ;
    rcode = shvset("WINSYSNR",msg) ;
    if (rcode!=SHV_SUCCESS)
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Failed to set variable WINSYSNR") ;
            execmsg("WIN058E",msg) ;
          }
        execend() ;
        return 4 ;
      }

    sprintf(msg,"%d",sdcb.cols) ;
    rcode = shvset("WINSYSNC",msg) ;
    if (rcode!=SHV_SUCCESS)
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Failed to set variable WINSYSNC") ;
            execmsg("WIN059E",msg) ;
          }
        execend() ;
        return 4 ;
      }

    if (sdcb.aplflg)
      rcode = shvset("WINSYSAP","Y") ;
    else
      rcode = shvset("WINSYSAP","N") ;
    if (rcode!=SHV_SUCCESS)
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Failed to set variable WINSYSAP") ;
            execmsg("WIN060E",msg) ;
          }
        execend() ;
        return 4 ;
      }

    if (sdcb.loadflg)
      rcode = shvset("WINSYSPS","Y") ;
    else
      rcode = shvset("WINSYSPS","N") ;
    if (rcode!=SHV_SUCCESS)
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Failed to set variable WINSYSPS") ;
            execmsg("WIN061E",msg) ;
          }
        execend() ;
        return 4 ;
      }

    if (sdcb.graflg)
      rcode = shvset("WINSYSGR","Y") ;
    else
      rcode = shvset("WINSYSGR","N") ;
    if (rcode!=SHV_SUCCESS)
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Failed to set variable WINSYSGR") ;
            execmsg("WIN062E",msg) ;
          }
        execend() ;
        return 4 ;
      }

    if (rexxflg)       /* is there an initial REXX to start */
      rcode = execcall(rexxnm) ;           /* yes, start it */

    for (;;)
      {
        operands = input = execget() ;
        if (mlev>4)
          {
            sprintf(msg,"<> %s",input) ;
            execmsg(0,msg) ;
          }

        /* get next input line */
        if (!input)
          break ;

        cmdname = execid(&operands) ;

        /* obtain command name, if error in execid expect */
        /* CLIST/EXEC input next */
        if (!cmdname)
          {
            interact = 1 ;
            continue ;
          }

        if (!*cmdname)    /* check for null input */
          {
            continue ;
          }

        /* if execid did an EXEC for us, note and continue */
        else if (strcmp(cmdname,"*EXEC") == 0)
          {
            interact = 0 ;
            continue ;
          }

        /* if just switched from EXEC to the terminal, note this */
        else if (strcmp(cmdname,"*ENDEXEC") == 0 )
          {
            interact = 1 ;
            rcode = atoi(operands) ;
            /* extract the exec return code - it might be missing */
            if (operands)
              sprintf(msg,"Exec return code %d",rcode) ;
            else
               strcpy(msg,"Exec return code not available.") ;
            execmsg("WIN001I",msg) ;
          }

        /* WX sub command */
        else if (strcmp(cmdname,"WX") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            rcode = wxcmd(operands) ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
            break ;
          }

        /* Call exec for EXEC SUBCOMmand and expect input from it */
        else if (strcmp(cmdname,"EXEC") == 0)
          {
            /* call EXEC for EXEC sub-command */
            rcode = execcall(input) ;
            interact = 0 ;
            if (rcode != 0)
              {
                sprintf(msg,"Exec failed with return code %d",
                  rcode) ;
                execmsg("WIN005E",msg) ;
              }
          }

        /* WA sub command - set Window Attributes */
        else if (strcmp(cmdname,"WA") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            rcode = wacmd(operands) ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
          }

        /* WE sub command - set Window Erase  */
        else if (strcmp(cmdname,"WE") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            rcode = wecmd(operands) ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
          }

        /* WC sub command - set Window Create */
        else if (strcmp(cmdname,"WC") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            rcode = wccmd(operands) ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
          }

        /* WS sub command - set Window define row */
        else if (strcmp(cmdname,"WS") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            rcode = wscmd(operands) ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
          }

        /* WD sub command - set Window Display */
        else if (strcmp(cmdname,"WD") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            rcode = wdcmd(operands) ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
          }

        /* HELP sub command - Help */
        else if (strcmp(cmdname,"HELP") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            help() ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
          }

        /* WH sub command - Help */
        else if (strcmp(cmdname,"WH") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            help() ;
            if (mlev>2)
              {
                sprintf(msg,"Subcommand %s lastcc: %d",cmdname,rcode) ;
                execmsg("WIN069I",msg) ;
              }
          }

        /* WM sub command, set message level, 0 is off */
        else if (strcmp(cmdname,"WM") == 0)
          {
            if (mlev>3)
              {
                sprintf(msg,"Subcommand: %s (%s)",cmdname,operands) ;
                execmsg("WIN068I",msg) ;
              }
            t = strtol(operands, &number_end,10) ;
            if (!number_end)
              {
                sprintf(msg,"Invalid message level %s",operands) ;
                execmsg("WIN002E",msg) ;
                rcode = 4 ;
              }
            else
              {
                if (t <= 9)  /* valid message level */
                  {
                    sprintf(msg,"Message level now %d",t) ;
                    execmsg("WIN003I",msg) ;
                    mlev = t ;
                  }
                else  /* specific debugging function */
                  {
                    if (t == 10)
                      termstat() ;
                    else if (t == 11)
                      dumpfld() ;
                    else if (t == 12)
                      iotrace = 1 ;
                    else if (t == 13)
                      iotrace = 0 ;
                    else
                      {
                        sprintf(msg,"Invalid message level, 0 used.") ;
                        execmsg("WIN003I",msg) ;
                        mlev = 0 ;
                      }
                  }
              }
          }

        /* Uknown command, try to execute it. */
        else
          {
            rcode = execcall(input) ;
            interact = 0 ;
          }

        cmdcnt++ ;
        maxrc = execrc(rcode) ;    /* inform exec of return code */
      }  /* of for ever (until WX command) */


    if (mlev>1)
      {
        sprintf(msg,"%d commands executed, max. return code %d",
          cmdcnt,maxrc) ;
        execmsg("WIN004I",msg) ;
      }

    execend() ;
    return maxrc ;
  }

/*-------------------------------------------------------------------*/
/* Show a limited amount of help info.                               */
/*-------------------------------------------------------------------*/
void help()
  {
    int i ;
    char helpinfo[][60] = {
      {"Sub commands available are:"},
      {" WA - Set field attributes"},
      {" WE - Erase a window"},
      {" WC - Create a window"},
      {" WS - Define line in window"},
      {" WD - Display a window"},
      {" WX - Terminate WIN3270"},
      {" WM - Set debug level"},
      {"."}
    } ;
    sprintf(msg,"WIN3270 Help information follows:\n") ;
    execmsg("WIN008I",msg) ;
    i = 0 ;
    while(strcmp(helpinfo[i],".") != 0)
      {
        sprintf(msg,"%s\n",helpinfo[i]) ;
        execmsg(0,msg) ;
        i++ ;
      }
  }

/*-------------------------------------------------------------------*/
/* Window sub command environment termination processing             */
/*-------------------------------------------------------------------*/
int wxcmd(char *parm)
  {
    clear() ;
    termscr() ;
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* Window Attribute command processing                               */
/*-------------------------------------------------------------------*/
int wacmd(char *parm)
  {
    char *word ;         /* current token */
    char temp[10] ;      /* temp area for token */
    int i ;              /* counter */
    int n = 1 ;          /* current token number */
    int valueflg = 0 ;   /* flag - seen VALUE= parm */
    int found ;          /* flag - found value attr char */
    int attrix ;         /* index pos of this attr in table attrtab */
    char value ;         /* value (name) of attribute */
    char type ;          /* type of attribute */
    char color ;         /* color of attribute */
    char hilite ;        /* hilite of attribute */
    char symbol ;        /* symbol of attribute */
    char just ;          /* just of attribute */

    type = 'L' ;         /* default type of attribute */
    color = GREEN ;      /* default color of attribute */
    hilite = NONE ;      /* default hilite of attribute */
    symbol = NONE ;      /* default symbol of attribute */
    just = 'N' ;         /* default just of attribute */

    word = strtok(parm,DELIMS) ;
    while(word != NULL)
      {
        if (mlev>3)
          {
            sprintf(msg,"  Parm %d: %s",n,word) ;
            execmsg(0,msg) ;
          }
        if (strlen(word) >10)
          {
            if (mlev>0)
              {
                sprintf(msg,"Invalid parameter length for: %s",word) ;
                execmsg("WIN018E",msg) ;
              }
            return 36 ;
          }
        strcpy(temp,word) ;
        strtoupr(temp) ;

        if (strcmp(temp,"VALUE") == 0)
          {
            valueflg = 1 ;   /* indicate seen required parm */
            word = strtok(NULL,DELIMS) ;  /* get next word */
            found = 0 ;
            value = *word ;  /* value name is first char */
                             /* ignore extra characters in token */
            for(i=0;i<attrnext;i++)
              {
                if (attrtab[i][AVALUE] == value)
                  {        /* replace old value */
                    attrtab[i][AVALUE] = value ;
                    attrix = i ;
                    found = 1 ;
                  }
              }
            if (!found) /* add new value */
              {
                attrtab[attrnext][AVALUE] = value ;
                attrix = attrnext ;
                attrnext++ ;
              }
          }

        else if (strcmp(temp,"TYPE") == 0)
          {
            word = strtok(NULL,DELIMS) ;  /* get next word */
            if (strlen(word) >10)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid value length for: %s",word) ;
                    execmsg("WIN019E",msg) ;
                  }
                return 40 ;
              }
            strcpy(temp,word) ;
            strtoupr(temp) ;
            if (strcmp(temp,"LABEL") == 0)
              type = 'L' ;
            else if (strcmp(temp,"INPUT") == 0)
              type = 'I' ;
            else if (strcmp(temp,"OUTPUT") == 0)
              type = 'O' ;
            else if (strcmp(temp,"BUTTON") == 0)
              type = 'B' ;
            else if (strcmp(temp,"RADIO") == 0)
              type = 'R' ;
            else if (strcmp(temp,"CHECKBOX") == 0)
              type = 'C' ;
            else  /* invalid parm */
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid TYPE= value %s",temp) ;
                    execmsg("WIN012E",msg) ;
                  }
                return 8 ;
              }
          }

        else if (strcmp(temp,"COLOR") == 0)
          {
            word = strtok(NULL,DELIMS) ;  /* get next word */
            if (strlen(word) >10)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid value length for: %s",word) ;
                    execmsg("WIN019E",msg) ;
                  }
                return 40 ;
              }
            strcpy(temp,word) ;
            strtoupr(temp) ;
            if (strcmp(temp,"RED") == 0)
              color = RED ;
            else if (strcmp(temp,"BLUE") == 0)
              color = BLUE ;
            else if (strcmp(temp,"GREEN") == 0)
              color = GREEN ;
            else if (strcmp(temp,"WHITE") == 0)
              color = WHITE ;
            else if (strcmp(temp,"PINK") == 0)
              color = PINK ;
            else if (strcmp(temp,"YELLOW") == 0)
              color = YELLOW ;
            else if (strcmp(temp,"CYAN") == 0)
              color = CYAN ;
            else if (strcmp(temp,"NONE") == 0)
              color = NONE ;
            else if (strcmp(temp,"BLACK") == 0)
              color = NONE ;
            else  /* invalid parm */
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid COLOR= value %s",temp) ;
                    execmsg("WIN013E",msg) ;
                  }
                return 12 ;
              }
          }

        else if (strcmp(temp,"HILITE") == 0)
          {
            word = strtok(NULL,DELIMS) ;  /* get next word */
            if (strlen(word) >10)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid value length for: %s",word) ;
                    execmsg("WIN019E",msg) ;
                  }
                return 40 ;
              }
            strcpy(temp,word) ;
            strtoupr(temp) ;
            if (strcmp(temp,"BLINK") == 0)
              hilite = BLINK ;
            else if (strcmp(temp,"REVERSE") == 0)
              hilite = REVERSE ;
            else if (strcmp(temp,"ULINE") == 0)
              hilite = ULINE ;
            else if (strcmp(temp,"NONE") == 0)
              hilite = NONE ;
            else  /* invalid parm */
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid HILITE= value %s",temp) ;
                    execmsg("WIN014E",msg) ;
                  }
                return 16 ;
              }
          }

        else if (strcmp(temp,"SYMBOL") == 0)
          {
            word = strtok(NULL,DELIMS) ;  /* get next word */
            if (strlen(word) >10)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid value length for: %s",word) ;
                    execmsg("WIN019E",msg) ;
                  }
                return 40 ;
              }
            strcpy(temp,word) ;
            strtoupr(temp) ;
            if (strcmp(temp,"APL") == 0)
              symbol = APL ;
            else if (strcmp(temp,"PS") == 0)
              symbol = 0x40 ;
            else if (strcmp(temp,"NONE") == 0)
              symbol = NONE ;
            else  /* invalid parm */
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid SYMBOL= value %s",temp) ;
                    execmsg("WIN015E",msg) ;
                  }
                return 20 ;
              }
          }

        else if (strcmp(temp,"JUST") == 0)
          {
            word = strtok(NULL,DELIMS) ;  /* get next word */
            if (strlen(word) >10)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid value length for: %s",word) ;
                    execmsg("WIN019E",msg) ;
                  }
                return 40 ;
              }
            strcpy(temp,word) ;
            strtoupr(temp) ;
            if (strcmp(temp,"LEFT") == 0)
              just = 'L' ;
            else if (strcmp(temp,"CENTER") == 0)
              just = 'C' ;
            else if (strcmp(temp,"RIGHT") == 0)
              just = 'R' ;
            else if (strcmp(temp,"NONE") == 0)
              just = 'N' ;
            else  /* invalid parm */
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid JUST= value %s",temp) ;
                    execmsg("WIN016E",msg) ;
                  }
                return 24 ;
              }
          }

        else  /* invalid parm */
          {
            if (mlev>0)
              {
                sprintf(msg,"Invalid WA parameter %s",temp) ;
                execmsg("WIN010E",msg) ;
              }
            return 32 ;
          }

        word = strtok(NULL,DELIMS) ;  /* get next word */
        n++ ;
      }    /* of while tokens */

    if (valueflg)  /* value= parameter was specified - update entry */
      {
        if (mlev>3)
          {
            sprintf(msg,
            "  Value:%c Type:%c Color:%2X Hilite:%2X Symbol:%2X Just:%c"
              ,value,type,color,hilite,symbol,just) ;
            execmsg(0,msg) ;
          }
        attrtab[attrix][ATYPE] = type ;
        attrtab[attrix][ACOLOR] = color ;
        attrtab[attrix][AHILITE] = hilite ;
        attrtab[attrix][ASYMBOL] = symbol ;
        attrtab[attrix][AJUST] = just ;
      }
    else
      {
        if (mlev>0)
          {
            sprintf(msg,"Invalid WA sub-command, no VALUE= parameter") ;
            execmsg("WIN017E",msg) ;
          }
        return 28 ;
      }
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* Window Erase command processing                                   */
/*-------------------------------------------------------------------*/
int wecmd(char *parm)
  {
    int found = 0 ;      /* window found flag */
    int n = 1 ;          /* token counter */
    char *word ;         /* current token */
    char temp[10] ;      /* temp area for token */
    char name[9] ;       /* name of window to erase */
    char nameflg = 0 ;   /* flag - seen NAME= parm */
    TWINDOW *last, *top ;

    if (windows)
      {
        word = strtok(parm,DELIMS) ;
        while(word != NULL)
          {
            if (mlev>3)
              {
                sprintf(msg,"  Parm %d: %s",n,word) ;
                execmsg(0,msg) ;
              }
            if (strlen(word) >10)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid parameter length for: %s",
                      word) ;
                    execmsg("WIN018E",msg) ;
                  }
                return 8 ;
              }
            strcpy(temp,word) ;
            strtoupr(temp) ;

            if (strcmp(temp,"NAME") == 0)
              {
                word = strtok(NULL,DELIMS) ;  /* get next word */
                if (*word)
                  {
                    nameflg = 1 ;   /* indicate seen required parm */
                    if (strlen(word) >8)
                      {
                        if (mlev>0)
                          {
                             sprintf(msg,
                               "Length too long (>8) for name: %s",
                               word) ;
                             execmsg("WIN028E",msg) ;
                           }
                         return 12 ;
                      }
                    strcpy(name,word) ;
                    strtoupr(name) ;

                    /* locate window by name on window list */
                    /*   if not found do error lastcc 12 */
                    found = 0 ;
                    last = NULL ;
                    top = windows ;
                    while (top)
                      {
                        if (strcmp(top->name,name) == 0)
                          {
                            found = 1 ;
                            break ;
                          }
                        last = top ;
                        top = top->next ;
                      }
                    if (!found)
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,"Window %s not found.",name) ;
                            execmsg("WIN043E",msg) ;
                          }
                        return 12 ;
                      }

                    /* set found window as the current window */
                    curwin = top ;

                    /* do remflds() to this windows fields */
                    remflds() ;

                    /* remove the window from the list */
                    if (last)
                      last->next = top->next ;
                    else
                      windows = top->next ;
                    free((TWINDOW *)curwin) ;

                    /* set current window to first window */
                    /*   remaining on the window list */
                    curwin = windows ;
                    if (!curwin)
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,"No windows currently defined");
                            execmsg("WIN044I",msg) ;
                          }
                      }
                  }
              }

            else  /* invalid parm */
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid WE parameter %s",temp) ;
                    execmsg("WIN021E",msg) ;
                  }
                return 8 ;
              }

            word = strtok(NULL,DELIMS) ;  /* get next word */
            n++ ;
          }    /* of while tokens */

        if (! nameflg)  /* name= parameter not specified */
          {
            if (mlev>0)
              {
                sprintf(msg,
                  "Invalid WE sub-command, no NAME= parameter") ;
                execmsg("WIN022E",msg) ;
              }
            return 4 ;
          }

      }   /* of if windows */
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* Window Create command processing                                  */
/*-------------------------------------------------------------------*/
int wccmd(char *parm)
  {
    int n = 1 ;          /* token counter */
    char *word ;         /* current token */
    char temp[10] ;      /* temp area for token */
    char name[9] ;       /* name of window to erase */
    char nameflg = 0 ;   /* flag - seen NAME= parm */
    TWINDOW *newwin, *last, *top ;

    word = strtok(parm,DELIMS) ;
    while(word != NULL)
      {
        if (mlev>3)
          {
            sprintf(msg,"  Parm %d: %s",n,word) ;
            execmsg(0,msg) ;
          }
        if (strlen(word) >10)
          {
            if (mlev>0)
              {
                sprintf(msg,"Invalid parameter length for: %s",
                  word) ;
                execmsg("WIN018E",msg) ;
              }
            return 16 ;
          }
        strcpy(temp,word) ;
        strtoupr(temp) ;

        if (strcmp(temp,"NAME") == 0)
          {
            word = strtok(NULL,DELIMS) ;  /* get next word */
            if (*word)
              {
                nameflg = 1 ;   /* indicate seen required parm */
                if (strlen(word) >8)
                  {
                    if (mlev>0)
                      {
                         sprintf(msg,
                           "Length too long (>8) for name: %s",
                           word) ;
                         execmsg("WIN028E",msg) ;
                       }
                     return 16 ;
                  }
                strcpy(name,word) ;
                strtoupr(name) ;

                /* locate window on window list */
                /* if it exists do error lastcc 8 */
                top = windows ;
                while (top)
                  {
                    if (strcmp(top->name,name) == 0)
                      {
                        sprintf(msg,"Window %s already exists.",name) ;
                        execmsg("WIN023E",msg) ;
                        return 8 ;
                      }
                    top = top->next ;
                  }

                /* get storage for new window node */
                newwin = (TWINDOW *)malloc(sizeof(TWINDOW)) ;
                if (!newwin) serror(50,"Not enough memory") ;
                memset(newwin,0x00,sizeof(TWINDOW)) ;

                /* initialise window information */
                newwin->fields = NULL ; /* next field id number */
                newwin->fidnext = 0 ;   /* next field id number */
                strcpy(newwin->name,name) ;  /* name of window */
                newwin->inputflg = 1;   /* input flag 0=none,1=allowed*/
                newwin->delay = 0 ;     /* do not delay */
                newwin->srow = 1 ;      /* start row */
                newwin->scol = 1 ;      /* start col */
                newwin->lastrow = 1 ;   /* initial cursor row */
                newwin->lastcol = 1 ;   /* initial cursor col */
                newwin->eraseflg = 1 ;  /* ensure screen erase write */

                /* create a new window entry in list */
                newwin->next = NULL ;
                if (!windows) /* first entry in list (windows->00) */
                  windows = newwin ;
                else  /* insert new window at top of window list */
                  {
                    last = windows ;
                    windows = newwin ;
                    windows->next = last ;
                  }

                /* set this new window as the current window */
                curwin = newwin ;
              }
          }

        else  /* invalid parm */
          {
            if (mlev>0)
              {
                sprintf(msg,"Invalid WC parameter %s",temp) ;
                execmsg("WIN023E",msg) ;
              }
            return 12 ;
          }

        word = strtok(NULL,DELIMS) ;  /* get next word */
        n++ ;
      }    /* of while tokens */

    if (! nameflg)  /* name= parameter not specified */
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Invalid WC sub-command, no NAME= parameter") ;
            execmsg("WIN024E",msg) ;
          }
        return 4 ;
      }

    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* Window define row command processing                              */
/*-------------------------------------------------------------------*/
int wscmd(char *parm)
  {
    int len ;            /* length of current field */
    int fid ;            /* temp field id */
    int found ;          /* attribute character found flag */
    int infield = 0 ;    /* field start located yet flag */
    int row ;            /* row number being processed */
    int col ;            /* start col of current field being processed*/
    int i ;              /* counter */
    char crow[3] ;       /* char line number */
    char vname[TSOVSIZE];/* tso variable name */
    char *start ;        /* start of field definition area */
    char *c ;            /* current character */
    char *d ;            /* end field character */
    char *e ;            /* temp char pointer */
    char *f ;            /* temp char pointer */
    char *number_end;    /* end str marker */
    char type ;          /* type of attribute */
    char color ;         /* color of attribute */
    char hilite ;        /* hilite of attribute */
    char symbol ;        /* symbol of attribute */
    char just ;          /* just of attribute */
    TLSTR data ;         /* field data */
    TLSTR data1 ;        /* field data */
    TLSTR data2 ;        /* field data */
    TLSTR data3 ;        /* field data */

    if (curwin)
      {
        /*------------------------------------------------------*/
        /* Parm should contain the following format on entry    */
        /* nn %text    %  %text  % text   text                  */
        /* Where - nn is numeric with a length of 2 followed by */
        /*         one blank.                                   */
        /*       - % is an attribute character                  */
        /*         Column 4 is the first column of the field    */
        /*         definition area, and must contain an         */
        /*         attribute character.                         */
        /*       - text is any characters other than attribute  */
        /*         characters, including the blank character.   */
        /*------------------------------------------------------*/

        /* get row number and make sure it is a valid row number */
        memcpy(crow,parm,3) ;
        crow[2] = 0x00 ;
        row = strtol(crow, &number_end,10) ;
        if (!number_end)
          {
            if (mlev>0)
              {
                sprintf(msg,"Invalid row %s",crow) ;
                execmsg("WIN045E",msg) ;
              }
            return 8 ;
          }
        else
          {
            if ((row > sdcb.rows) ×× (row < 1))
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Row number %d out of range.",row) ;
                    execmsg("WIN046E",msg) ;
                  }
                return 4 ;
              }
          }

        /* examine each character and test if it is an attr char */
        c = parm+3 ;
        start = c ;
        while(*c)    /* for all characters in the row */
          {
            found = 0 ;
            /* look up the char in the attribute table and leave */
            /* the index in i if the char is found */
            for(i=0;i<attrnext;i++)
              {
                if (attrtab[i][AVALUE] == *c)
                  {
                    found = 1 ;
                    infield = 1 ;
                    break ;
                  }
              }
            if (!(found && infield)) /* error - first char not attrib */
              {
                if (mlev>0)
                  {
                    sprintf(msg,
                      "Row %d first char (%c) not attibute char.",
                      row,*c) ;
                    execmsg("WIN047E",msg) ;
                  }
                return 20 ;
              }

            /* if attr char look for next attr char to find field len*/
            if (found)
              {
                /* get widget attribs based on index for attrib char */
                col = (c-start)+1 ;
                type = attrtab[i][ATYPE] ;
                color = attrtab[i][ACOLOR] ;
                hilite = attrtab[i][AHILITE] ;
                symbol = attrtab[i][ASYMBOL] ;
                just = attrtab[i][AJUST] ;

                /* look for end of field */
                found = 0 ;
                d = c+1 ;
                while(*d && !found)
                  {
                    found = 0 ;
                    for(i=0;i<attrnext;i++)
                      {
                        if (attrtab[i][AVALUE] == *d)
                          {
                            found = 1 ;
                            break ;
                          }
                      }
                    d++ ;
                  }
                /* if not at end of string, decrement end string ptr */
                if ((*d) ×× ((*d == '\0') && (found == 1)) )
                  d-- ;

                /* set field length inclusive of field attribute byte */
                /* c points at attr byte, and d points at next        */
                /* attr byte or the end of the field definition area. */
                len = d-c-1 ;
                if ((len <= 1) && (type!='L'))
                  {
                    if (mlev>0)
                      {
                        sprintf(msg,"Attribute (%c) at "
                          "row %d col %d, field length too small.",
                          *c,row,col) ;
                        execmsg("WIN091E",msg) ;
                      }
                    return 20 ;
                  }

                /* define new field according to type */
                if (type == 'L')          /* label */
                  {
                    if (len < 1)
                      lstrnew(&data," ") ;
                    else
                      lstrnewx(&data,c+1,len) ;
                    fid = insfld(&data,row,col,PRTAS,color,hilite,
                      type,NONE,NOINPUT) ;
                    if (fid<0) serror(81,"Field insert failed") ;

                    if (sdcb.loadflg && (symbol==0x40))
                      setfld(fid,SYMSET,0x40) ; /* loaded PS symbols */
                    else if (sdcb.aplflg && (symbol==APL))
                      setfld(fid,SYMSET,APL) ; /* APL symbols */
                  }

                else if (type == 'I')     /* input */
                  {
                    /* copy and validate variable name */
                    e = vname ;
                    f = c+1 ;
                    i = 0 ;
                    while (isalnum(*f))
                      {
                        if (i==TSOVSIZE)
                          break ;
                        *e++ = *f++ ;
                        i++ ;
                      }
                    *e = '\0' ;
                    if ((i<=0) ×× (i>TSOVSIZE))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,
                              "Invalid var name length for %s",c) ;
                            execmsg("WIN049E",msg) ;
                          }
                        return 24 ;
                      }

                    /* create new field on current window */
                    lstrnew(&data," ") ;
                    fid = insfld(&data,row,col,UNPRT,color,hilite,
                      type,NONE,INPUT) ;
                    if (fid<0) serror(81,"Field insert failed") ;

                    if (sdcb.loadflg && (symbol==0x40))
                      setfld(fid,SYMSET,0x40) ; /* loaded PS symbols */
                    else if (sdcb.aplflg && (symbol==APL))
                      setfld(fid,SYMSET,APL) ; /* APL symbols */

                    /* add variable name to field definition */
                    setfvar(fid,vname) ;
                  }

                else if (type == 'O')     /* output */
                  {
                    /* copy and validate variable name */
                    e = vname ;
                    f = c+1 ;
                    i = 0 ;
                    while (isalnum(*f))
                      {
                        if (i==TSOVSIZE)
                          break ;
                        *e++ = *f++ ;
                        i++ ;
                      }
                    *e = '\0' ;
                    if ((i<=0) ×× (i>TSOVSIZE))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,
                              "Invalid var name length for %s",c) ;
                            execmsg("WIN050E",msg) ;
                          }
                        return 28 ;
                      }

                    /* create new field on current window */
                    lstrnew(&data," ") ;
                    fid = insfld(&data,row,col,PRTAS,color,hilite,
                      type,NONE,NOINPUT) ;
                    if (fid<0) serror(81,"Field insert failed") ;

                    if (sdcb.loadflg && (symbol==0x40))
                      setfld(fid,SYMSET,0x40) ; /* loaded PS symbols */
                    else if (sdcb.aplflg && (symbol==APL))
                      setfld(fid,SYMSET,APL) ; /* APL symbols */

                    /* add variable name to field definition */
                    setfvar(fid,vname) ;  /* save variable name */
                  }

                else if (type == 'B')     /* button */
                  {
                    /* copy and validate variable name */
                    e = vname ;
                    f = c+1 ;
                    i = 0 ;
                    while (isalnum(*f))
                      {
                        if (i==TSOVSIZE)
                          break ;
                        *e++ = *f++ ;
                        i++ ;
                      }
                    *e = '\0' ;
                    if ((i<=0) ×× (i>TSOVSIZE))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,
                              "Invalid var name length for %s",c) ;
                            execmsg("WIN051E",msg) ;
                          }
                        return 32 ;
                      }

                    /* create new field on current window */
                    lstrnewx(&data3,c+1,len-2) ;
                    if (sdcb.loadflg)
                      {
                        lstrnew(&data1,"\x64") ; /* left button end */
                        lstrnew(&data2,"\x63") ; /* right button end */
                        lstrcat(&data,&data1,&data3) ;
                        lstrcat(&data3,&data,&data2) ;

                        fid = insfld(&data3,row,col,UNPRT,color,NONE,
                          type,NONE,NOINPUT) ;
                        setfld(fid,SYMSET,0x40) ; /*loaded PS symbols*/
                      }
                    else
                      {
                        lstrnew(&data1,"(") ; /* left button end */
                        lstrnew(&data2,")") ; /* right button end */
                        lstrcat(&data,&data1,&data3) ;
                        lstrcat(&data3,&data,&data2) ;

                        fid = insfld(&data3,row,col,UNPRT,color,RVIDEO,
                          type,NONE,NOINPUT) ;
                      }
                    /* add variable name to field definition */
                    setfvar(fid,vname) ;  /* save variable name */
                  }

                else if (type == 'R')     /* radio */
                  {
                    /* copy and validate variable name */
                    e = vname ;
                    f = c+1 ;
                    i = 0 ;
                    while (isalnum(*f))
                      {
                        if (i==TSOVSIZE)
                          break ;
                        *e++ = *f++ ;
                        i++ ;
                      }
                    *e = '\0' ;
                    if ((i<=0) ×× (i>TSOVSIZE))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,
                              "Invalid var name length for %s",c) ;
                            execmsg("WIN052E",msg) ;
                          }
                        return 36 ;
                      }

                    /* create new field on current window */
                    /* subtract length of variable name and one  */
                    /* blank character, this should allow for    */
                    /* the control at the front of the text.     */
                    lstrnewx(&data,f+1,len-i-1) ;
                    fid = insfld(&data,row,col+2,UNPRT,color,hilite,
                      type,TEXT,NOINPUT) ;
                    /* add variable name to field definition */
                    setfvar(fid,vname) ;  /* save variable name */
                    if (sdcb.loadflg)
                      {
                        lstrnew(&data,"\x54") ;   /* un pressed sym */
                        fid = insfld(&data,row,col,UNPRT,color,hilite,
                          type,CONTROL,NOINPUT) ;
                        setfld(fid,SYMSET,0x40) ; /*loaded PS symbols*/
                      }
                    else if (sdcb.aplflg)
                      {
                        lstrnew(&data,"\x9d") ; /* un pressed sym */
                        fid = insfld(&data,row,col,UNPRT,color,hilite,
                          type,CONTROL,NOINPUT) ;
                        setfld(fid,SYMSET,APL) ; /* APL symbols */
                      }
                    else
                      {
                        lstrnew(&data,"o") ;  /* un pressed symbol */
                        fid = insfld(&data,row,col,UNPRT,color,hilite,
                          type,CONTROL,NOINPUT) ;
                      }
                    /* add variable name to field definition */
                    setfvar(fid,vname) ;  /* save variable name */
                  }

                else if (type == 'C')     /* checkbox */
                  {
                    /* copy and validate variable name */
                    e = vname ;
                    f = c+1 ;
                    i = 0 ;
                    while (isalnum(*f))
                      {
                        if (i==TSOVSIZE)
                          break ;
                        *e++ = *f++ ;
                        i++ ;
                      }
                    *e = '\0' ;
                    if ((i<=0) ×× (i>TSOVSIZE))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,
                              "Invalid var name length for %s",c) ;
                            execmsg("WIN052E",msg) ;
                          }
                        return 36 ;
                      }

                    /* subtract 2 from length to account for the */
                    /* control at the front of the text          */
                    lstrnewx(&data,c+1,len-2) ;
                    fid = insfld(&data,row,col+2,UNPRT,color,hilite,
                      type,TEXT,NOINPUT) ;
                    /* add variable name to field definition */
                    setfvar(fid,vname) ;  /* save variable name */
                    if (sdcb.loadflg)
                      {
                        lstrnew(&data,"\x56") ;   /* un cheched sym */
                        fid = insfld(&data,row,col,UNPRT,color,hilite,
                          type,CONTROL,NOINPUT) ;
                        setfld(fid,SYMSET,0x40) ; /*loaded PS symbols*/
                      }
                    else if (sdcb.aplflg)
                      {
                        lstrnew(&data,"\x90") ; /* un checked sym */
                        fid = insfld(&data,row,col,UNPRT,color,hilite,
                          type,CONTROL,NOINPUT) ;
                        setfld(fid,SYMSET,APL) ; /* APL symbols */
                      }
                    else
                      {
                        lstrnew(&data,"_") ;  /* un checked symbol */
                        fid = insfld(&data,row,col,UNPRT,color,hilite,
                          type,CONTROL,NOINPUT) ;
                      }
                    /* add variable name to field definition */
                    setfvar(fid,vname) ;  /* save variable name */
                  }

                else  /* nasty error */
                  {
                    if (mlev>0)
                      {
                        sprintf(msg,
                          "Logic error in WS, invalid type: %c",type) ;
                        execmsg("WIN048S",msg) ;
                      }
                    return 24 ;
                  }

                /* reposition c past this field */
                c = d ;

              }  /* of if found */
            else
              c++ ;

          }  /* of while characters in the row */

      }
    else /* error - no current window */
      {
        if (mlev>0)
          {
            sprintf(msg,
              "No current window exists, can not define rows") ;
            execmsg("WIN036E",msg) ;
          }
        return 16 ;
      }
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* Window Display command processing                                 */
/*-------------------------------------------------------------------*/
int wdcmd(char *parm)
  {
    char *number_end ;   /* end of number token */
    char *word ;         /* current token */
    char curvar[TSOVSIZE] ; /* current field variable name */
    char curword[80] ;   /* current word under cursor */
    char temp[10] ;      /* temp area for token */
    char keyname[8] ;    /* name of key pressed */
    char name[9] ;       /* name of window to display */
    char nameflg = 0 ;   /* flag - seen NAME= parm */
    char input = 1 ;     /* input flag, either Y=yes or N=no */
    int found ;          /* window found flag */
    int delay = 0 ;      /* window display delay */
    int prow = 1 ;       /* start row */
    int pcol = 1 ;       /* start col */
    int n = 1 ;          /* token counter */
    int svrc ;           /* set variable return code */
    TWINDOW *last, *top ;

    if (windows)
      {
        word = strtok(parm,DELIMS) ;
        while(word != NULL)
          {
            if (mlev>3)
              {
                sprintf(msg,"  Parm %d: %s",n,word) ;
                execmsg(0,msg) ;
              }
            if (strlen(word) >10)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid parameter length for: %s",
                      word) ;
                    execmsg("WIN018E",msg) ;
                  }
                return 12 ;
              }
            strcpy(temp,word) ;
            strtoupr(temp) ;

            if (strcmp(temp,"NAME") == 0)
              {
                word = strtok(NULL,DELIMS) ;  /* get next word */
                if (*word)
                  {
                    nameflg = 1 ;   /* indicate seen required parm */
                    if (strlen(word) >8)
                      {
                        if (mlev>0)
                          {
                             sprintf(msg,
                               "Length too long (>8) for name: %s",
                               word) ;
                             execmsg("WIN028E",msg) ;
                           }
                         return 20 ;
                      }
                    strcpy(name,word) ;
                    strtoupr(name) ;
                  }
              }

            else if (strcmp(temp,"ROW") == 0)
              {
                word = strtok(NULL,DELIMS) ;  /* get next word */
                prow = strtol(word, &number_end,10) ;
                if (!number_end)
                  {
                    if (mlev>0)
                      {
                        sprintf(msg,"Invalid start row %s",word) ;
                        execmsg("WIN036E",msg) ;
                      }
                    return 8 ;
                  }
                else
                  {
                    if ((prow > sdcb.rows) ×× (prow < 1))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,"Bad start row size %d",prow) ;
                            execmsg("WIN037E",msg) ;
                          }
                        return 12 ;
                      }
                  }
              }

            else if (strcmp(temp,"COL") == 0)
              {
                word = strtok(NULL,DELIMS) ;  /* get next word */
                pcol = strtol(word, &number_end,10) ;
                if (!number_end)
                  {
                    if (mlev>0)
                      {
                        sprintf(msg,"Invalid start column %s",word) ;
                        execmsg("WIN038E",msg) ;
                      }
                    return 8 ;
                  }
                else
                  {
                    if ((pcol > sdcb.cols) ×× (pcol < 1))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,"Bad start col size %d",pcol) ;
                            execmsg("WIN039E",msg) ;
                          }
                        return 12 ;
                      }
                  }
              }

            else if (strcmp(temp,"INPUT") == 0)
              {
                word = strtok(NULL,DELIMS) ;  /* get next word */
                if (toupper(*word)=='Y')
                  input = 1 ;
                else if (toupper(*word)=='N')
                  input = 0 ;
                else
                  {
                    if (mlev>0)
                      {
                        sprintf(msg,"Invalid input flag.") ;
                        execmsg("WIN042E",msg) ;
                      }
                    return 12 ;
                  }
                curwin->inputflg = input ; /* input flag 0=no, 1=yes */
              }

            else if (strcmp(temp,"DELAY") == 0)
              {
                word = strtok(NULL,DELIMS) ;  /* get next word */
                delay = strtol(word, &number_end,10) ;
                if (!number_end)
                  {
                    if (mlev>0)
                      {
                        sprintf(msg,"Invalid delay time %s",word) ;
                        execmsg("WIN040E",msg) ;
                      }
                    return 8 ;
                  }
                else
                  {
                    if ((delay > 60) ×× (delay < 0))
                      {
                        if (mlev>0)
                          {
                            sprintf(msg,"Delay %d out of range",delay);
                            execmsg("WIN041E",msg) ;
                          }
                        return 12 ;
                      }
                  }
                curwin->delay = delay ; /* wait after disp (secs.) */
              }

            else  /* invalid parm */
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Invalid WD parameter %s",temp) ;
                    execmsg("WIN025E",msg) ;
                  }
                return 8 ;
              }

            word = strtok(NULL,DELIMS) ;  /* get next word */
            n++ ;
          }    /* of while tokens */

        if (nameflg)  /* name= parameter specified */
          {
            /* locate window by name on window list */
            /*   if not found do error lastcc 4 */
            found = 0 ;
            last = NULL ;
            top = windows ;
            while (top)
              {
                if (strcmp(top->name,name) == 0)
                  {
                    found = 1 ;
                    break ;
                  }
                last = top ;
                top = top->next ;
              }
            if (!found)
              {
                if (mlev>0)
                  {
                    sprintf(msg,"Window %s not found.",name) ;
                    execmsg("WIN051E",msg) ;
                  }
                return 4 ;
              }

            /* if window changed, indicate erase write */
            if (curwin != top)
              top->eraseflg = 1 ;

            /* set found window as the current window */
            curwin = top ;

            /* set Twindow data for current window */
            curwin->srow = prow ;      /* start row of window */
            curwin->scol = pcol ;      /* start column of window */
            curwin->inputflg = input ; /* input flag 0=no, 1=yes */
            curwin->delay = delay ;    /* wait after disp (secs.) */

            /* look at all the TSO variables associated */
            /*   with fields and copy the variable data */
            /*   to the field depending on widget type */
            var2fld() ;

            /* dspflds() to display the window */
            if (delay > 0)
              /* if delay is set then sleep(nn) */
              curwin->lastkey = dspflds(delay) ; /* display */
            else
              {
                curwin->lastkey = dspflds(0) ; /* display */

                /* get the cursor field variable name and the */
                /* word the cursor is positioned on, also set */
                /* button, checkbox, or radio buttons if the  */
                /* cursor is on them.                         */
                cursorp(curword,curvar) ;

                /* get the modied field data from the fields */
                /*   into the TSO variables */
                fld2var() ;
              }

            /* if no input then return */
            if (input == 0)
              return 0 ;

            /* set TSO post display builtin variables */
            sprintf(msg,"%d",curwin->lastrow) ;  /* last cursor row */
            svrc = shvset("WINSYSR",msg) ;
            if (svrc!=SHV_SUCCESS)
              {
                if (mlev>0)
                  {
                    sprintf(msg,
                      "Failed to set variable WINSYSR") ;
                    execmsg("WIN052E",msg) ;
                  }
                return 28 ;
              }

            sprintf(msg,"%d",curwin->lastcol) ;  /* last cursor col */
            svrc = shvset("WINSYSC",msg) ;
            if (svrc!=SHV_SUCCESS)
              {
                if (mlev>0)
                  {
                    sprintf(msg,
                      "Failed to set variable WINSYSC") ;
                    execmsg("WIN053E",msg) ;
                  }
                return 28 ;
              }

            getkeynm(keyname,curwin->lastkey) ;
            sprintf(msg,"%s",keyname) ;  /* last key pressed */
            svrc = shvset("WINSYSK",msg) ;
            if (svrc!=SHV_SUCCESS)
              {
                if (mlev>0)
                  {
                    sprintf(msg,
                      "Failed to set variable WINSYSK") ;
                    execmsg("WIN054E",msg) ;
                  }
                return 28 ;
              }

            svrc = shvset("WINSYSV",curvar) ; /* var cursor is on */
            if (svrc!=SHV_SUCCESS)
              {
                if (mlev>0)
                  {
                    sprintf(msg,
                      "Failed to set variable WINSYSV") ;
                    execmsg("WIN055E",msg) ;
                  }
                return 28 ;
              }

            svrc = shvset("WINSYST",curword) ; /* word cursor is on */
            if (svrc!=SHV_SUCCESS)
              {
                if (mlev>0)
                  {
                    sprintf(msg,
                      "Failed to set variable WINSYST") ;
                    execmsg("WIN056E",msg) ;
                  }
                return 28 ;
              }

          }
        else  /* name= parameter not specified */
          {
            if (mlev>0)
              {
                sprintf(msg,
                  "Invalid WD sub-command, no NAME= parameter") ;
                execmsg("WIN026E",msg) ;
              }
            return 24 ;
          }

      }   /* of if windows */
    else /* no windows exist cant display */
      {
        if (mlev>0)
          {
            sprintf(msg,
              "Not windows exist, WD cant display") ;
            execmsg("WIN027E",msg) ;
          }
        return 16 ;
      }

    return 0 ;
  }



/*********************************************************************/
/* 3270 field handling routines                                      */
/*   rc = initscr()                                                  */
/*   termscr()                                                       */
/*   fid = insfld(data,row,col,attr,color,hilite,type,subtype,input) */
/*   fid = getvfid(vname)                                            */
/*   rc = remflds()                                                  */
/*   rc = delfld(fid)                                                */
/*   rc = erasefld(fid)                                              */
/*   rc = setfvar(fid,vname)                                         */
/*   rc = getfld(fid,returndata)                                     */
/*   rc = modfld(fid,newdata)                                        */
/*   rc = setfld(fid,attrtype,attrvalue)                             */
/*   key = dspflds(delay)                                            */
/*   dumpfld()                                                       */
/*   var2fld()                                                       */
/*   fld2var()                                                       */
/*                                                                   */
/*********************************************************************/


/*-------------------------------------------------------------------*/
/* Set up the screen environment.                                    */
/*-------------------------------------------------------------------*/
int initscr()
{
    int rc = 0 ;

    /* load i/o functions */
    loadm("TPUTN",&xtputn) ;
    loadm("TGETN",&xtgetn) ;
    loadm("TPGN",&xtpgn) ;

    /* get memory */
    buffer = (char *)malloc(BUFFMAX) ;  /* alloc tput/get buffer */
    if (buffer)
      {
        rc = getdev() ;  /* get3270 device information */
        if (rc==0 && sdcb.loadflg==1)
          loadps1() ;
      }
    else
      rc = 1 ;   /* could not get buffer */

    return rc ;
}

/*-------------------------------------------------------------------*/
/* Terminate screen environment.                                     */
/*-------------------------------------------------------------------*/
void termscr()
{
    TWINDOW *top, *curr ;

    /* free memory */
    top = windows ;
    while (top)
      {
        curr = top ;
        top = top->next ;
        if (curr->fields)
          {
            curwin = curr ;
            remflds() ;       /* remove fields in this window */
          }
        free((TWINDOW *)curr) ;  /* remove this window cntl block */
      }

    free((char *)buffer) ;  /* remove tput/get buffer */

    /* unload i/o functions */
    unloadm(xtputn) ;
    unloadm(xtgetn) ;
    unloadm(xtpgn) ;
}

/*-------------------------------------------------------------------*/
/* Display current contents of the 3270 field list.                  */
/*-------------------------------------------------------------------*/
char dspflds(int delay)
{
  TSFLD *curr ;         /* pointer to current display field */
  TSFLD *other ;        /* another pointer to display field list */
  TSFLD *last ;         /* pointer to last display field */
  int rc ;              /* return code */
  int bufpos ;          /* current buffer position */
  int trow = 0 ;        /* input data, field row */
  int tcol = 0 ;        /* input data, field column */
  int fstart ;          /* input data, field start pointer */
  int fend ;            /* input data, field end pointer */
  int ilen ;            /* inserted field data length */
  char sba[2] ;         /* 3270 buffer address */
  char aid ;            /* id of key pressed */

  /*-------------------------------------------------------------*/
  /* assemble buffer, it will contain: (EW WCC) followed by all  */
  /* the display fields. Each field will contain:                */
  /*   (SFE 0x03 0xC0 fattr HILITE fhilite COLOR fcolor data)    */
  /*-------------------------------------------------------------*/
redisply:
  if (curwin->eraseflg)  /* need to erase screen ? */
    {
      if (sdcb.altflg)
        buffer[0] = EWA ;     /* erase write alternate */
      else
        buffer[0] = EW ;      /* erase write */
    }
  else
    buffer[0] = WRT ;         /* write */

  /* determine if the bell should be rung */
  if (curwin->bellflg)
    {
      buffer[1] = WCCRES × WCCKBD × WCCMDT × WCCBEL ;
      curwin->bellflg = 0 ;  /* turn bell flag off, one ring only */
    }
  else
    buffer[1] = WCCRES × WCCKBD × WCCMDT ;

  bufpos = 2 ;
  curr = curwin->fields ;     /* first node in field list */
  while (curr)
    {
      if (curr->modflg ×× curwin->eraseflg)  /* need to write field?*/
        {
          curr->modflg = 0 ;        /* turn mod flag off */
          buffer[bufpos++] = SBA ;  /* set buffer address */
          rc2sba(curr->fypos,curr->fxpos,sba) ;
          buffer[bufpos++] = sba[0] ;
          buffer[bufpos++] = sba[1] ;
          if (sdcb.edsflg)
            {
              buffer[bufpos++] = SFE ;  /* start field extended */
              buffer[bufpos++] = 0x03 ;
              buffer[bufpos++] = 0xc0 ;
              buffer[bufpos++] = curr->fattr ;
              buffer[bufpos++] = HILITE ;
              buffer[bufpos++] = curr->fhilite ;
              buffer[bufpos++] = COLOR ;
              buffer[bufpos++] = curr->fcolor ;

              /* insert set character attribute before data if APL/PS */
              /* symbols are required and the field has protection    */
              /* turned on.                                           */
              if (((curr->symbol==APL) ×× (curr->symbol==0x40))
                && (curr->fattr & 0x40)) /* and protected field */
                {
                  buffer[bufpos++] = SA ;           /* set attribute */
                  buffer[bufpos++] = SYMSET ;       /* symbol */
                  if (curr->symbol==APL) /* APL ? */
                    buffer[bufpos++] = sdcb.aplflg ; /* use APL's lcid*/
                  else
                    buffer[bufpos++] = curr->symbol ; /*use symbol val*/
                }
            }
          else    /* dont used extended data stream */
            {
              buffer[bufpos++] = SF ;  /* start field */
              buffer[bufpos++] = curr->fattr ;
            }

          /* insert field data */
          ilen = lstrunld(&buffer[bufpos],&curr->fdata) ;
          bufpos = bufpos + ilen ;

          /* revert to standard symbols after APL/PS data symbols  */
          if (((curr->symbol==APL) ×× (curr->symbol==0x40)) /*APL/PS*/
            && (curr->fattr & 0x40)) /* and protected field */
            {
              buffer[bufpos++] = SA ;    /* set attribute */
              buffer[bufpos++] = SYMSET ;/* symbol */
              buffer[bufpos++] = DFLT ;  /* revert to default symbols */
            }

        }  /* of need  to write */

      curr = curr->next ;  /* go to next field */
    }
  curwin->eraseflg = 0 ;   /* reset erase flag */

  /* insert the cursor in the same location the user left it */
  buffer[bufpos++] = SBA ;     /* add set buffer address order */
  /* determine SBA for current row/col */
  rc2sba(curwin->lastrow,curwin->lastcol,sba) ;
  buffer[bufpos++] = sba[0] ;  /* add buffer addr part 1 */
  buffer[bufpos++] = sba[1] ;  /* add buffer addr part 2 */
  buffer[bufpos++] = ICUR ;    /* add insert cursor order */

  /* dumpchar(buffer,bufpos) ; */

  /* write buffer to the 3270 */
  rc = tputn(buffer, bufpos) ;

  fill(buffer,0x00,bufpos) ;

  if (delay > 0)      /* if delay specified only display the fields */
    {                 /* for the delay time and dont read any input */
      sleep(delay) ;
      return 0x00 ;
    }

  /* receive the response from the user */
  rc = tgetn(buffer, BUFFMAX ) ;

  /*---------------------------------------------------------*/
  /* Decode input, should be an AID, a cursor pos bufferaddr */
  /* and a list of fields (SBA addr1 addr2 data)             */
  /*---------------------------------------------------------*/

  aid = buffer[0] ;      /* get code of key that was pressed */
  if (aid == PA2)
    {
      curwin->eraseflg = 1 ;   /* set erase flag */
      goto redisply ;
    }
  sba[0] = buffer[1] ;
  sba[1] = buffer[2] ;

  /* convert and store cursor pos and adjust = 0 used for cursor pos */
  sba2rc(sba,&curwin->lastrow,&curwin->lastcol,0) ;

  curr = curwin->fields ;
  fstart = 0 ;
  bufpos = 3 ;
  while(bufpos<=BUFFMAX)
    {
      if (buffer[bufpos]==SBA)
        {
          /* get new buffer address */
          bufpos++ ;
          sba[0] = buffer[bufpos++] ;
          sba[1] = buffer[bufpos++] ;
          sba2rc(sba,&trow,&tcol,1) ; /* convert buf.addr to row/col */
                              /* adjust = 1 used for retn. buf. addr */
          fstart = bufpos ;

          /* locate field by r/c then write data to field list entry */
          last = NULL ;
          while( !((curr->fxpos==tcol) && (curr->fypos==trow)) )
            {                          /* locate */
              last = curr ;
              curr = curr->next ;
              if (!curr) break ; /* could not locate - real bad */
            }

          if (curr)    /* found field - copy the data into it */
            {
              curr->modflg = 1 ;  /* indicate field was modified */

              /* first locate end of data */
              fend = fstart ;
              while ((buffer[fend] != SBA) &&
                     (buffer[fend] != 0x00))
                fend++ ;  /* leaves fend pointing at next char. */

              if (curr->inputflg)
                {
                  /* copy data from buffer into field list */
                  ilen = fend - fstart ;
                  lstrload(&curr->fdata,&buffer[fstart],ilen) ;
                }

              if (curr->type == 'B')   /* push button */
                {
                  curr->fhilite = NONE ;  /* signal push */
                }

              else if (curr->type == 'C')   /* check box */
                {
                  if (curr->subtype == 'C')   /* control part */
                    {
                      if (sdcb.loadflg)   /* set new state */
                        {
                          if (*curr->fdata.data == 0x55)
                            *curr->fdata.data = 0x56 ; /* not checked */
                          else
                            *curr->fdata.data = 0x55 ; /* checked */
                        }
                      else if (sdcb.aplflg)
                        {
                          if (*curr->fdata.data == 0xee)
                            *curr->fdata.data = 0x90 ; /* not checked */
                          else
                            *curr->fdata.data = 0xee ; /* checked */
                        }
                      else
                        {
                          if (*curr->fdata.data == 'X')
                            *curr->fdata.data = '_' ; /* not checked */
                          else
                            *curr->fdata.data = 'X' ; /* checked */
                        }
                    }
                  else                        /* text part */
                    {
                      if (last->subtype == 'C')  /* control part */
                        {
                          last->modflg = 1 ; /* indicate modified */
                          if (sdcb.loadflg)   /* set new state */
                            {
                              if (*last->fdata.data == 0x55)
                                *last->fdata.data = 0x56 ; /* notcheck*/
                              else
                                *last->fdata.data = 0x55 ; /* checked */
                            }
                          else if (sdcb.aplflg)
                            {
                              if (*last->fdata.data == 0xee)
                                *last->fdata.data = 0x90 ; /* notcheck*/
                              else
                                *last->fdata.data = 0xee ; /* checked */
                            }
                          else
                            {
                              if (*last->fdata.data == 'X')
                                *last->fdata.data = '_' ; /* notcheck*/
                              else
                                *last->fdata.data = 'X' ; /* checked */
                            }
                        }
                      else
                        {
                          /* BAD ERROR: This should never happen */
                          sprintf(msg,
                            "Cant locate control part of checkbox %s",
                            curr->tsovar) ;
                          execmsg("WIN068S",msg) ;
                        }
                    }
                }

              else if (curr->type == 'R')   /* radio button */
                {
                  /* turn off all other radio buttons for this var */
                  other = curwin->fields ;
                  while(other)
                    {
                      if ((other->type == 'R') &&   /* radio button */
                          (other->subtype == 'C'))  /* control */
                        {
                          if (strcmp(other->tsovar,curr->tsovar) == 0)
                            {
                              other->modflg = 1 ; /*indicate modified*/
                              if (sdcb.loadflg)  /* radio off */
                                *other->fdata.data = 0x54 ;
                              else if (sdcb.aplflg)
                                *other->fdata.data = 0x9d ;
                              else
                                *other->fdata.data = 'o' ;
                            }
                        }
                      other = other->next ;
                    }

                  /* turn this radio button station on */
                  if (curr->subtype == 'C')   /* control part */
                    {
                      if (sdcb.loadflg)       /* indicate radio on */
                        *curr->fdata.data = 0x53 ;
                      else if (sdcb.aplflg)
                        *curr->fdata.data = 0xed ;
                      else
                        *curr->fdata.data = '*' ;
                    }
                  else                        /* text part */
                    {
                      if (last->subtype == 'C')  /* control part */
                        {
                          if (sdcb.loadflg)     /* indicate radio on */
                            *last->fdata.data = 0x53 ;
                          else if (sdcb.aplflg)
                            *last->fdata.data = 0xed ;
                          else
                            *last->fdata.data = '*' ;
                        }
                      else
                        {
                          /* BAD ERROR: This should never happen */
                          sprintf(msg,
                           "Cant locate control part of radio button %s"
                           ,curr->tsovar) ;
                          execmsg("WIN070S",msg) ;
                        }
                    }
                }

              /* adjust bufpos to last char of this returned SBA */
              bufpos = fend -1 ;
            }
          else
            {
              /* SEVERE ERROR: This should never happen */
              sprintf(msg,
                "Locate field failed: row %d col %d SBA %.2X %.2X\n",
                trow,tcol,sba[0],sba[1]) ;
              execmsg("WIN029S",msg) ;
              curr = curwin->fields ;  /* further searches from top */
            }
        }
      else
        bufpos++ ;   /* advance to next char */
    }

  return aid ;    /* data returned OK */
}


/*-------------------------------------------------------------------*/
/* Copy the contents of modifiable fields into their TSO variables.  */
/*-------------------------------------------------------------------*/
void fld2var()
{
  TSFLD *curr ;         /* pointer to current field */
  TSFLD *next ;         /* pointer to next field */
  int svrc ;            /* tso variable set return code */
  char temp[80] ;       /* temp buffer */
  char *pv ;            /* pointer to variable data */
  char *pn ;            /* pointer to next field fdata.data */

  curr = curwin->fields ;     /* first node in field list */
  while (curr)
    {
      if (curr->type=='I')   /* input field */
        {
          if (curr->tsovar)
            {
              lstrunld(temp,&curr->fdata) ;
              svrc = shvset(curr->tsovar,temp) ;
              if (svrc!=SHV_SUCCESS)
                {
                  if (mlev>0)
                    {
                      sprintf(msg,
                        "Failed to set field input variable %s"
                        ,curr->tsovar) ;
                      execmsg("WIN101E",msg) ;
                    }
                }
            }
          else
            {
              if (mlev>0)
                {
                  sprintf(msg,
                    "No variable for input field at row %d col %d",
                    curr->fypos,curr->fxpos) ;
                  execmsg("WIN102E",msg) ;
                }
            }
        }

      else if (curr->type=='B')  /* push button */
        {
          if (curr->tsovar)
            {
              if (curr->fhilite==NONE)
                svrc = shvset(curr->tsovar,"X") ;
              else
                svrc = shvset(curr->tsovar," ") ;
              if (svrc!=SHV_SUCCESS)
                {
                  if (mlev>0)
                    {
                      sprintf(msg,
                        "Failed to set button variable %s"
                        ,curr->tsovar) ;
                      execmsg("WIN103E",msg) ;
                    }
                }
            }
          else
            {
              if (mlev>0)
                {
                  sprintf(msg,
                    "No variable for button at row %d col %d",
                    curr->fypos,curr->fxpos) ;
                  execmsg("WIN104E",msg) ;
                }
            }
        }

      else if (curr->type=='C')  /* check box */
        {
          if (curr->subtype == 'C')  /* control part */
            {
              if (curr->tsovar)
                {
                  if (sdcb.loadflg)
                    {
                      if (*curr->fdata.data == 0x55)
                        svrc = shvset(curr->tsovar,"X") ;
                      else
                        svrc = shvset(curr->tsovar," ") ;
                    }
                  else if (sdcb.aplflg)
                    {
                      if (*curr->fdata.data == 0xee)
                        svrc = shvset(curr->tsovar,"X") ;
                      else
                        svrc = shvset(curr->tsovar," ") ;
                    }
                  else
                    {
                      if (*curr->fdata.data == 'X')
                        svrc = shvset(curr->tsovar,"X") ;
                      else
                        svrc = shvset(curr->tsovar," ") ;
                    }
                  if (svrc!=SHV_SUCCESS)
                    {
                      if (mlev>0)
                        {
                          sprintf(msg,
                            "Failed to set check box variable %s"
                            ,curr->tsovar) ;
                          execmsg("WIN105E",msg) ;
                        }
                    }
                }
              else
                {
                  if (mlev>0)
                    {
                      sprintf(msg,
                        "No variable for check box at row %d col %d",
                        curr->fypos,curr->fxpos) ;
                      execmsg("WIN106E",msg) ;
                    }
                }
            }
        }

      else if (curr->type=='R')  /* radio button */
        {
          if (curr->subtype == 'C')  /* control part */
            {
              if (curr->tsovar)
                {
                  svrc = SHV_SUCCESS ;
                  if (sdcb.loadflg)
                    {
                      if (*curr->fdata.data == 0x53) /* currently on */
                        {
                          /* extract first word of text for var */
                          next = curr->next ;
                          pn = next->fdata.data ;
                          pv = temp ;
                          while ((*pn!='\0') && (*pn!=' '))
                            *pv++ = *pn++ ;
                          *pv = '\0' ;
                          svrc = shvset(curr->tsovar,temp) ;
                        }
                    }
                  else if (sdcb.aplflg)
                    {
                      if (*curr->fdata.data == 0xed) /* currently on */
                        {
                          /* extract first word of text for var */
                          next = curr->next ;
                          pn = next->fdata.data ;
                          pv = temp ;
                          while ((*pn!='\0') && (*pn!=' '))
                            *pv++ = *pn++ ;
                          *pv = '\0' ;
                          svrc = shvset(curr->tsovar,temp) ;
                        }
                    }
                  else
                    {
                      if (*curr->fdata.data == '*') /* currently on */
                        {
                          /* extract first word of text for var */
                          next = curr->next ;
                          pn = next->fdata.data ;
                          pv = temp ;
                          while ((*pn!='\0') && (*pn!=' '))
                            *pv++ = *pn++ ;
                          *pv = '\0' ;
                          svrc = shvset(curr->tsovar,temp) ;
                        }
                    }
                  if (svrc!=SHV_SUCCESS)
                    {
                      if (mlev>0)
                        {
                          sprintf(msg,
                            "Failed to set radio button variable %s"
                          ,curr->tsovar) ;
                          execmsg("WIN064E",msg) ;
                        }
                    }
                }
              else
                {
                  if (mlev>0)
                    {
                      sprintf(msg,
                        "No variable for radio button at row %d col %d",
                        curr->fypos,curr->fxpos) ;
                      execmsg("WIN107E",msg) ;
                    }
                }
            }
        }
      curr = curr->next ;
    }
}


/*-------------------------------------------------------------------*/
/* Copy the contents of TSO variables into their fields.             */
/*-------------------------------------------------------------------*/
void var2fld()
{
  TSFLD *curr ;        /* pointer to current field */
  TSFLD *next ;        /* pointer to next field */
  char temp[81] ;      /* temp buffer */
  char word1[81] ;     /* first word of radio button text */
  int svrc ;           /* tso variable fetch return code */
  int len ;            /* length of tso variable data */
  int flen ;           /* length of field */
  int i ;              /* counter */
  char *pv ;           /* pointer to variable data */
  char *pn ;           /* pointer to next field fdata.data */

  curr = curwin->fields ;     /* first node in field list */
  next = curr->next ;
  while (curr)
    {
      if ((curr->type=='I') ××   /* input field */
          (curr->type=='O'))     /* output field */
        {
          if (curr->tsovar)
            {
              svrc = shvfetch(curr->tsovar,temp,sizeof(temp)) ;
              len = strlen(temp) ;
              if (svrc==SHV_TRUNC_VAL)
                {
                  if (mlev>0)
                    {
                      sprintf(msg,
                        "I/O field variable %s data truncated."
                        ,curr->tsovar) ;
                      execmsg("WIN066I",msg) ;
                    }
                  len = sizeof(temp) -1 ;
                }
              else if (svrc!=SHV_SUCCESS)
                {
                  if (mlev>0)
                    {
                      sprintf(msg,
                        "Failed to get I/O field variable %s"
                        ,curr->tsovar) ;
                      execmsg("WIN067E",msg) ;
                    }
                  len = 0 ;
                }

              if (len > 0)    /* got data to copy */
                {
                  /* figure out actual field length */
                  if (next)
                    {
                      if (next->fypos == curr->fypos) /* on same line */
                        flen = (next->fxpos - curr->fxpos) - 1 ;
                      else
                        flen = sdcb.cols - curr->fxpos;/*no field wrap*/
                    }
                  else
                    flen = sdcb.cols - curr->fxpos; /* no field wrap */

                  /* ensure data fits in field */
                  if (len < flen)
                    {   /* data less than field length - blank pad */
                      for (i=len;i<flen;i++)
                        temp[i] = ' ' ;
                      temp[i] = '\0' ;
                    }
                  lstrload(&curr->fdata,temp,flen) ;
                  curr->modflg = 1 ; /*indicate modified*/
                }
            }
          else
            {
              if (mlev>0)
                {
                  sprintf(msg,
                    "No variable for I/O field at row %d col %d",
                    curr->fypos,curr->fxpos) ;
                  execmsg("WIN065E",msg) ;
                }
            }
        }

      else if (curr->type=='B')  /* button */
        {
          if (curr->tsovar)
            {
              curr->fhilite = REVERSE ;
              curr->modflg = 1 ; /*indicate modified*/
            }
          else
            {
              if (mlev>0)
                {
                  sprintf(msg,
                    "No variable for button at row %d col %d",
                    curr->fypos,curr->fxpos) ;
                  execmsg("WIN093E",msg) ;
                }
            }
        }

      else if (curr->type=='C')  /* check box */
        {
          if (curr->tsovar)
            {
              if (curr->subtype=='C')  /* control part */
                {
                  svrc = shvfetch(curr->tsovar,temp,sizeof(temp)) ;
                  if (svrc!=SHV_SUCCESS)
                    {
                      if (mlev>0)
                        {
                          sprintf(msg,
                            "Failed to get check box variable %s"
                            ,curr->tsovar) ;
                          execmsg("WIN094E",msg) ;
                        }
                    }
                  else
                    {
                      curr->modflg = 1 ; /*indicate modified*/
                      if (*temp == 'X')
                        {
                          if (sdcb.loadflg)
                            *curr->fdata.data = 0x55 ;
                          else if (sdcb.aplflg)
                            *curr->fdata.data = 0xee ;
                          else
                            *curr->fdata.data = 'X' ;
                        }
                      else
                        {
                          if (sdcb.loadflg)
                            *curr->fdata.data = 0x56 ;
                          else if (sdcb.aplflg)
                            *curr->fdata.data = 0x90 ;
                          else
                            *curr->fdata.data = '_' ;
                        }
                    }
                }
            }
          else
            {
              if (mlev>0)
                {
                  sprintf(msg,
                    "No variable for check box at row %d col %d",
                    curr->fypos,curr->fxpos) ;
                  execmsg("WIN095E",msg) ;
                }
            }
        }

      else if (curr->type=='R')  /* radio button */
        {
          if (curr->tsovar)
            {
              if (curr->subtype=='C')  /* control part */
                {
                  svrc = shvfetch(curr->tsovar,temp,sizeof(temp)) ;
                  if (svrc!=SHV_SUCCESS)
                    {
                      if (mlev>0)
                        {
                          sprintf(msg,
                            "Failed to get radio button variable %s"
                            ,curr->tsovar) ;
                          execmsg("WIN096E",msg) ;
                        }
                    }
                  else
                    {
                      /* extract first word of this stations text */
                      pn = next->fdata.data ;
                      pv = word1 ;
                      while ((*pn!='\0') && (*pn!=' '))
                        *pv++ = *pn++ ;
                      *pv = '\0' ;

                      curr->modflg = 1 ; /*indicate modified*/
                      if (strcmp(temp,word1) == 0) /* var = text wrd1*/
                        {
                          if (sdcb.loadflg)
                            *curr->fdata.data = 0x53 ; /* indicate on */
                          else if (sdcb.aplflg)
                            *curr->fdata.data = 0xed ;
                          else
                            *curr->fdata.data = '*' ;
                        }
                      else
                        {
                          if (sdcb.loadflg)
                            *curr->fdata.data = 0x54 ; /* indicate off*/
                          else if (sdcb.aplflg)
                            *curr->fdata.data = 0x9d ;
                          else
                            *curr->fdata.data = 'o' ;
                        }
                    }
                }
            }
          else
            {
              if (mlev>0)
                {
                  sprintf(msg,
                    "No variable for radio button at row %d col %d",
                    curr->fypos,curr->fxpos) ;
                  execmsg("WIN097E",msg) ;
                }
            }
        }
      curr = curr->next ;
      next = curr->next ;
    }   /* of while more fields */
}


/*-------------------------------------------------------------------*/
/* Get variable and word at the cursor position.                     */
/*-------------------------------------------------------------------*/
void cursorp(char *word, char *var)
{
  TSFLD  *other, *last, *next, *curr ;
  int offset ;
  int nx ;
  int len ;
  char *f, *g ;

  strcpy(var," ") ;  /* initialise returned values */
  strcpy(word," ") ;

  curr = curwin->fields ;     /* first node in field list */
  last = NULL ;
  while (curr)  /* scan field list */
    {
      next = curr->next ;
      if (curwin->lastrow == curr->fypos)  /* on correct row */
        {
          /* determine end of this field */
          if (next)
            {
              if (next->fypos != curr->fypos)
                nx = sdcb.cols ;
              else
                nx = next->fxpos ;
            }
          else
            nx = sdcb.cols ;

          /* determine if this field is the field the cursor is in */
          if ((curwin->lastcol >= curr->fxpos) &&
              (curwin->lastcol < nx))  /* on correct field ? */
            {
              /* is cursor field - indicate field was modified */
              curr->modflg = 1 ;

              /* set TSO variable name if there is one */
              if (curr->tsovar)
                strcpy(var,curr->tsovar) ;
              else
                strcpy(var," ") ;

              /* set the word the cursor is on if one exists */
              offset = curwin->lastcol - curr->fxpos ;
              f = curr->fdata.data + offset ;
              if (isalnum(*f))
                {
                  g = curr->fdata.data ;
                  while (isalnum(*f) && (f>=g)) /* find word start */
                    f-- ;
                  f++ ;   /* start of word */
                  g = f ;
                  len = 0 ;
                  while (isalnum(*g++)) /* find word length */
                    len++ ;
                  memcpy(word,f,len) ;
                  g = word + len ;
                  *g = '\0' ;
                }
              else
                strcpy(word," ") ;

              /* make widget cursor is on be modified */
              if (curr->type == 'B')   /* push button */
                {
                  curr->fhilite = NONE ;  /* signal push */
                }

              else if (curr->type == 'C')   /* check box */
                {
                  if (curr->subtype == 'C')   /* control part */
                    {
                      if (sdcb.loadflg)   /* set new state */
                        {
                          if (*curr->fdata.data == 0x55)
                            *curr->fdata.data = 0x56 ; /* not checked */
                          else
                            *curr->fdata.data = 0x55 ; /* checked */
                        }
                      else if (sdcb.aplflg)
                        {
                          if (*curr->fdata.data == 0xee)
                            *curr->fdata.data = 0x90 ; /* not checked */
                          else
                            *curr->fdata.data = 0xee ; /* checked */
                        }
                      else
                        {
                          if (*curr->fdata.data == 'X')
                            *curr->fdata.data = '_' ; /* not checked */
                          else
                            *curr->fdata.data = 'X' ; /* checked */
                        }
                    }
                  else                        /* text part */
                    {
                      if (last->subtype == 'C')  /* control part */
                        {
                          if (sdcb.loadflg)   /* set new state */
                            {
                              if (*last->fdata.data == 0x55)
                                *last->fdata.data = 0x56 ; /* notcheck*/
                              else
                                *last->fdata.data = 0x55 ; /* checked */
                            }
                          else if (sdcb.aplflg)
                            {
                              if (*last->fdata.data == 0xee)
                                *last->fdata.data = 0x90 ; /* notcheck*/
                              else
                                *last->fdata.data = 0xee ; /* checked */
                            }
                          else
                            {
                              if (*last->fdata.data == 'X')
                                *last->fdata.data = '_' ; /* notcheck*/
                              else
                                *last->fdata.data = 'X' ; /* checked */
                            }
                        }
                      else
                        {
                          /* BAD ERROR: This should never happen */
                          sprintf(msg,
                            "Cant locate control part of checkbox %s",
                            curr->tsovar) ;
                          execmsg("WIN068S",msg) ;
                        }
                    }
                }

              else if (curr->type == 'R')   /* radio button */
                {
                  /* turn off all other radio buttons for this var */
                  other = curwin->fields ;
                  while(other)
                    {
                      if ((other->type == 'R') &&   /* radio button */
                          (other->subtype == 'C'))  /* control */
                        {
                          if (strcmp(other->tsovar,curr->tsovar) == 0)
                            {
                              if (sdcb.loadflg)  /* radio off */
                                *other->fdata.data = 0x54 ;
                              else if (sdcb.aplflg)
                                *other->fdata.data = 0x9d ;
                              else
                                *other->fdata.data = 'o' ;
                            }
                        }
                      other = other->next ;
                    }

                  /* turn this radio button station on */
                  if (curr->subtype == 'C')   /* control part */
                    {
                      if (sdcb.loadflg)       /* indicate radio on */
                        *curr->fdata.data = 0x53 ;
                      else if (sdcb.aplflg)
                        *curr->fdata.data = 0xed ;
                      else
                        *curr->fdata.data = '*' ;
                    }
                  else                        /* text part */
                    {
                      if (last->subtype == 'C')  /* control part */
                        {
                          if (sdcb.loadflg)     /* indicate radio on */
                            *last->fdata.data = 0x53 ;
                          else if (sdcb.aplflg)
                            *last->fdata.data = 0xed ;
                          else
                            *last->fdata.data = '*' ;
                        }
                      else
                        {
                          /* BAD ERROR: This should never happen */
                          sprintf(msg,
                            "Cant locate control part of checkbox %s",
                            curr->tsovar) ;
                          execmsg("WIN068S",msg) ;
                        }
                    }
                }

              /* field found - look no further through list */
              break ;

            }  /* of correct field */

        }  /* of correct row */

      last = curr ;
      curr = curr->next ;
    }  /* of scan field list */
}


/*-------------------------------------------------------------------*/
/* Dump field list.                                                  */
/*-------------------------------------------------------------------*/
void dumpfld()
{
  TSFLD *curr ;
  int i = 0, size = 0 ;
  char sba[2] ;

  sprintf(msg,"Field list follows:\n") ;
  execmsg("WIN030I",msg) ;
  curr = curwin->fields ;     /* first node in field list */
  while (curr)
    {
      sprintf(msg,"  Field at row %d col %d\n",curr->fypos,curr->fxpos);
      execmsg(0,msg) ;
      rc2sba(curr->fypos,curr->fxpos,sba) ;
      sprintf(msg,"    BufAddr: %.2X %.2X Attrib: %.2X Hilite: %.2X "
        "Color: %.2X Symbol: %.2X DataLen: %d\n",
        sba[0],sba[1],curr->fattr,curr->fhilite,curr->fcolor
        ,curr->symbol,curr->fdata.len) ;
      execmsg(0,msg) ;
      sprintf(msg,"    Type: %c Subtype: %c InputFlg: %.2X ",
        curr->type,curr->subtype,curr->inputflg ) ;
      execmsg(0,msg) ;
      if (curr->tsovar)
        {
          sprintf(msg,"    TSO variable: %s ",curr->tsovar ) ;
          execmsg(0,msg) ;
        }
      sprintf(msg,"    Data: %s",curr->fdata.data) ;
      execmsg(0,msg) ;
      size = size + curr->fdata.len  + 11 ;
      i++ ;
      curr = curr->next ;
    }
  sprintf(msg,"Total fields %d, buffer size required %d\n",i,size) ;
  execmsg(0,msg) ;
}


/*-------------------------------------------------------------------*/
/* Print terminal status.                                            */
/*-------------------------------------------------------------------*/
void termstat()
{
  int i ;     /* counter */

  sprintf(msg,"Terminal status follows:\n") ;
  execmsg("WIN031I",msg) ;
  sprintf(msg,"  Device name.........: %s\n",sdcb.modname) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Device model........: %d\n",sdcb.model) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Device type.........: %d\n",sdcb.type) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Addressing mode.....: %d\n",sdcb.adrmode) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Maximum rows........: %d\n",sdcb.rows) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Maximum columns.....: %d\n",sdcb.cols) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Cell height(ImpPart): %d\n",sdcb.celheigh) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Cell width(ImpPart).: %d\n",sdcb.celwidth) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Cell height(UseArea): %d\n",sdcb.uacelh) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Cell width(UseArea).: %d\n",sdcb.uacelw) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Supported colors....: %d\n",sdcb.colors) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Actual colors.......: %d\n",sdcb.colora) ;
  execmsg(0,msg) ;

  sprintf(msg,"  Color list: \n") ;
  execmsg(0,msg) ;
  for (i=0;i<sdcb.colors;i++)
    {
      sprintf(msg,"     %.2X\n",sdcb.colorlst[i]) ;
      execmsg(0,msg) ;
    }

  sprintf(msg,"  Number of Highlights: %d\n",sdcb.hilites) ;
  execmsg(0,msg) ;

  sprintf(msg,"  Highlight list: \n") ;
  execmsg(0,msg) ;
  for (i=0;i<sdcb.hilites;i++)
    {
      sprintf(msg,"     %.2X\n",sdcb.hilitlst[i]) ;
      execmsg(0,msg) ;
    }

  if (sdcb.unit)
    sprintf(msg,"  Unit................: mm\n") ;
  else
    sprintf(msg,"  Unit................: inch\n") ;
  execmsg(0,msg) ;
  sprintf(msg,"  Alternate device....: %d\n",sdcb.altflg) ;
  execmsg(0,msg) ;
  sprintf(msg,"  APL symbol set......: %.2X\n",sdcb.aplflg) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Extended data stream: %d\n",sdcb.edsflg) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Loadable symbols....: %d\n",sdcb.loadflg) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Load PS extended....: %d\n",sdcb.psflg) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Triple plane symbols: %d\n",sdcb.triflg) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Double byte symbols.: %d\n",sdcb.dbcsflg) ;
  execmsg(0,msg) ;
  sprintf(msg,"  Vector graphic......: %d\n",sdcb.graflg) ;
  execmsg(0,msg) ;
}


/*-------------------------------------------------------------------*/
/* Add a field to the 3270 field list.                               */
/*-------------------------------------------------------------------*/
int insfld(TLSTR *flddata,       /* the data */
            int ypos,            /* display at row */
            int xpos,            /* display at column */
            char attr,           /* field attribute PRT, UNPRT ...*/
            char color,          /* field color RED, BLUE, ...*/
            char hilite,         /* field hilite BLINK, RVIDEO,...*/
            char type,           /* type of field, RADIO,CHECKBOX,.. */
            char subtype,        /* sub type of field, TEXT, CONTROL */
            char inputflg )      /* input flag, INPUT or NOINPUT */
{
  int rc ;
  TSFLD *newfld, *last, *top ;

  /* get storage for new nodes */
  newfld = (TSFLD *)malloc(sizeof(TSFLD)) ;
  if (!newfld) serror(20,"Not enough memory") ;
  memset(newfld,0x00,sizeof(TSFLD)) ;

  /* verify contents of all parameters */
  if ((flddata->len > 0) &&
    (flddata->len <= (sdcb.rows * sdcb.cols)))
    lstrcopy(&newfld->fdata,flddata) ;
  else
    return -1 ;

  if ((xpos > 0) &&
    (xpos < sdcb.cols))
    newfld->fxpos = xpos ;
  else
    return -2 ;

  if ((ypos > 0) &&
    (ypos <= sdcb.rows))
    newfld->fypos = ypos ;
  else
    return -3 ;

  rc = modattr(&newfld->fattr,attr) ;
  if (rc) return -4 ;

  rc = modcolor(&newfld->fcolor,color) ;
  if (rc) return -5 ;

  rc = modhilite(&newfld->fhilite,hilite) ;
  if (rc) return -6 ;

  newfld->modflg = 1 ;   /* ensure new field is written to device */
  newfld->type = type ;
  newfld->subtype = subtype ;
  newfld->inputflg = inputflg ;

  /* insert the field into the field list in order of buffer offset */
  top = curwin->fields ;
  if (!top)   /* first entry in the list (screen->00) */
    {
      newfld->next = NULL ;
      curwin->fields = newfld ;
    }
  else
    {
      last = NULL ;  /* last node examined */
      while(top)    /* loop through fields for insert place */
        {
          if ((top->fxpos+top->fypos*sdcb.cols) <
            (newfld->fxpos+newfld->fypos*sdcb.cols)) /* rel.buff.pos */
            {    /* chain to next node */
              last = top ;
              top = top->next ;
            }
          else
            {
              if (last)  /* insert the new node, in middle of list */
                {
                  last->next = newfld ;
                  newfld->next = top ;
                }
              else   /* insert new first node in list */
                {
                  newfld->next = top ;
                  curwin->fields = newfld ;
                }
              break ;   /* exit loop */
            }
        }
      if (!newfld->next)  /* stil not inserted? - add to end */
        last->next = newfld ;
    }

  /* update field id table and field id in field struct */
  newfld->fid = curwin->fidnext ;
  curwin->sfidtab[curwin->fidnext] = newfld ;
  rc = curwin->fidnext++ ;
  return rc ;
}

/*-------------------------------------------------------------------*/
/* Remove all fields defined from the 3270 field list.               */
/*-------------------------------------------------------------------*/
int remflds()
{
  int i ;
  TSFLD *curr, *top ;

  for (i=0; i<SFIDMAX; i++)  /* empty fid table */
  curwin->sfidtab[i] = NULL ;
  curwin->fidnext = 0 ;              /* reset next fid */

  top = curwin->fields ;             /* free field list */
  while(top)
    {
      curr = top ;
      top = top->next ;
      if (curr->tsovar)
        free((char *)curr->tsovar) ;
      free((char *)curr->fdata.data) ;
      free((TSFLD *)curr) ;
    }
  curwin->fields = NULL ;
  curwin->eraseflg = 1 ;  /* ensure erase write on next display */
  return 0 ;
}

/*-------------------------------------------------------------------*/
/* Delete a field from the 3270 field list.                          */
/*-------------------------------------------------------------------*/
int delfld(int id)
{
    TSFLD *curr, *top, *last ;

    if ((id < SFIDMAX) && (id >= 0))
      {
        curr = curwin->sfidtab[id] ;
        if (curr)
          {
            top = curwin->fields ;
            last = NULL ;
            while (top)
              {
                if (top == curr)
                  {
                    if (!last)   /* ? found node at top */
                      curwin->fields = top->next ;
                    else if (!top->next)  /* ? last node */
                      last->next = NULL ;
                    else           /* in middle of list */
                      last->next = top->next ;
                    /* delete the node */
                    if (top->tsovar)
                      free((char *)top->tsovar) ;
                    free((char *)top->fdata.data) ;
                    free((TSFLD *)top) ;
                    curwin->sfidtab[id] = NULL ; /* invalidate id */

                    /* ensure erase write on next display */
                    curwin->eraseflg = 1 ;
                    return 0 ;  /* field id removed OK */
                  }
                last = top ;  /* remember last node */
                top = top->next ;   /* chain to next node */
              }    /* of while top */
          }
        else return 1 ;     /* invalid id */
      }
    else return 2 ;    /* out of range id */
    return 3 ;     /* idtab list mismatch */
}

/*-------------------------------------------------------------------*/
/* Erase the contents of a field in the 3270 field list.             */
/*-------------------------------------------------------------------*/
int erasefld(int id)
{
  TSFLD *curr ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = curwin->sfidtab[id] ;
      if (curr)
        {
          lstrfill(&curr->fdata,"\0") ; /* fill with zeros */
          curr->modflg = 1 ; /* ensure field re-written to device */
        }
      else
        return 1 ;     /* invalid id */
    }
  else
    return 2 ;    /* out of range id */

  return 0 ;    /* id erased OK */
}

/*-------------------------------------------------------------------*/
/* Set the variable name of a field in the 3270 field list.          */
/*-------------------------------------------------------------------*/
int setfvar(int id,
            char *vname)
{
  TSFLD *curr ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = curwin->sfidtab[id] ;
      if (curr)
        {
          if (curr->tsovar)
            strcpy(curr->tsovar,vname) ;
          else
            {
              curr->tsovar = (char *)malloc(TSOVSIZE) ;
              if (!curr->tsovar) serror(56,"Not enough memory") ;
              strcpy(curr->tsovar,vname) ;
            }
        }
      else
        return 1 ;     /* invalid id */
    }
  else
    return 2 ;    /* out of range id */

  return 0 ;    /* data returned OK */
}

/*-------------------------------------------------------------------*/
/* Return the field id for a given TSO variable name.                */
/*-------------------------------------------------------------------*/
int getvfid(char *vname)
{
  TSFLD *curr ;       /* current field pointer */

  curr = curwin->fields ;            /* free field list */
  while(curr)
    {
      if (curr->tsovar)
        {
          if (strcmp(curr->tsovar,vname) == 0)
            return curr->fid ;
        }
      curr = curr->next ;
    }
  return -1 ;
}

/*-------------------------------------------------------------------*/
/* Get the current contents of a field in the 3270 field list.       */
/*-------------------------------------------------------------------*/
int getfld(int id,
           TLSTR *retdata)
{
  TSFLD *curr ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = curwin->sfidtab[id] ;
      if (curr)
        lstrcopy(retdata,&curr->fdata) ; /* copy data */
      else
        return 1 ;     /* invalid id */
    }
  else
    return 2 ;    /* out of range id */

  return 0 ;    /* data returned OK */
}

/*-------------------------------------------------------------------*/
/* Modify the contents of a field in the 3270 field list.            */
/*-------------------------------------------------------------------*/
int modfld(int id,
           TLSTR *newdata)
{
  TSFLD *curr ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = curwin->sfidtab[id] ;
      if (curr)
        {
          if ((newdata->len > 0) &&
            (newdata->len <= (sdcb.rows * sdcb.cols)))
            {
              lstrcopy(&curr->fdata,newdata) ; /* alter field data */
              curr->modflg = 1 ; /* ensure field re-written to device */
            }
          else
            return 1 ;  /* data too large or 0 */
        }
      else
        return 2 ;     /* invalid id */
    }
  else
    return 3 ;    /* out of range id */

  return 0 ;    /* data returned OK */
}

/*-------------------------------------------------------------------*/
/* Change the attributes of a field in the 3270 field list.          */
/*-------------------------------------------------------------------*/
int setfld(int id,
           int type,
           char value)
{
  TSFLD *curr ;
  int rc = 0 ;

  if ((id < SFIDMAX) && (id >= 0))
    {
      curr = curwin->sfidtab[id] ;
      if (curr)
        {
          switch (type)
            {
            case ALL:
              rc = modcolor(&curr->fcolor,DFLT) ;
              rc = modhilite(&curr->fhilite,DFLT) ;
              rc = modattr(&curr->fattr,DFLT) ;
              break ;
            case HILITE:
              rc = modhilite(&curr->fhilite,value) ;
              break ;
            case COLOR:
              rc = modcolor(&curr->fcolor,value) ;
              break ;
            case ATTR:
              rc = modattr(&curr->fattr,value) ;
              break ;
            case SYMSET:
              rc = modsym(&curr->symbol,value) ;
              break ;
            default:
              return 1 ;    /* invalid type */
            }
          curr->modflg = 1 ; /* ensure field re-written to device */
        }
      else
        return 1 ;     /* invalid id */
    }
  else
    return 2 ;    /* out of range id */

  return rc ;   /* return */
}



/*********************************************************************/
/* 3270 support routines                                             */
/*   rc2sba(row,col,sba)                                             */
/*   sba2rc(sba,row,col,adjust)                                      */
/*   getkeynm(keyname,key)                                           */
/*   rc = modcolor(out,in)                                           */
/*   rc = modhilit(out,in)                                           */
/*   rc = modattr(out,in)                                            */
/*   rc = tputn(buf,buflen)                                          */
/*   rc = tgetn(buf,buflen)                                          */
/*   rc = tpgn(buf,buflen)                                           */
/*   rc = getdev()                                                   */
/*   rc = getterm(primrow,primcol,altrow,altcol,attrs)               */
/*   rc = querydev()                                                 */
/*   rc = dsummary(buf,buflen)                                       */
/*   rc = darea(buf,buflen)                                          */
/*   rc = dcharset(buf,buflen)                                       */
/*   rc = dcolor(buf,buflen)                                         */
/*   rc = dhilite(buf,buflen)                                        */
/*   rc = dmodes(buf,buflen)                                         */
/*   rc = dimpart(buf,buflen)                                        */
/*                                                                   */
/*********************************************************************/

/*-------------------------------------------------------------------*/
/* The TPUTN routine is loaded below the 16M line                    */
/* It issues the TPUT macro with the NOEDIT option                   */
/*-------------------------------------------------------------------*/
int tputn(char *buf, int buflen)
  {
    int rc = 0 ;

    if (iotrace)      /* trace terminal I/O ? */
      {
        sprintf(msg,"Outbound data stream:\n") ;
        execmsg("WIN032I",msg) ;
        dumpchar(buf,buflen) ;
      }
    rc = (*xtputn)(buf,buflen) ;
    return rc ;
  }

/*-------------------------------------------------------------------*/
/* The TGETN routine is loaded below the 16M line                    */
/* It issues the TGET macro with the FULLSCR option.                 */
/*-------------------------------------------------------------------*/
int tgetn(char *buf, int buflen)
  {
    int rc = 0 ;

    rc = (*xtgetn)(buf,buflen) ;
    if (iotrace)      /* trace terminal I/O ? */
      {
        sprintf(msg,"Inbound data stream:\n") ;
        execmsg("WIN033I",msg) ;
        dumpchar(buf,buflen) ;
      }
    return rc ;
  }

/*-------------------------------------------------------------------*/
/* The TPGN routine is loaded below the 16M line                     */
/* It issues the TPG macro with the NOEDIT option.                   */
/*-------------------------------------------------------------------*/
int tpgn(char *buf, int buflen)
  {
    int rc = 0 ;

    if (iotrace)      /* trace terminal I/O ? */
      {
        sprintf(msg,"Outbound data stream:\n") ;
        execmsg("WIN032I",msg) ;
        dumpchar(buf,buflen) ;
      }
    rc = (*xtpgn)(buf,buflen) ;
    return rc ;
  }

/*-------------------------------------------------------------------*/
/* Convert row/column to 3270 12/16 bit buffer address.              */
/*-------------------------------------------------------------------*/
void rc2sba(int row,
            int col,
            char *sba)
{
  int offset, byte1, byte2 ;

  offset = ((row-1)*sdcb.cols)+(col-1) ;
  if (sdcb.adrmode == 12)  /* addressing mode = 12 */
    {
      byte1 = offset >> 6 ;           /* extract high order bits */
      byte1 = byte1 × 0x000000c0 ;    /* turn on 12 bit ind */

      byte2 = offset & 0x0000003f ;   /* extract low order 6 bits */
      byte2 = byte2 × 0x000000c0 ;    /* turn on 12 bit ind */

      sba[0] = *((char *)&byte1+3) ;  /* assemble 2 byte sba */
      sba[1] = *((char *)&byte2+3) ;
    }
  else /* adrmode = 16 or 14 */
    {
      byte1 = offset >> 8 ;           /* extract high order byte */
      byte2 = offset & 0x00ff ;       /* extract low order byte */
      sba[0] = *((char *)&byte1+3) ;  /* assemble 2 byte sba */
      sba[1] = *((char *)&byte2+3) ;
    }
}

/*-------------------------------------------------------------------*/
/* Convert 12/14/16-bit address to an offset and row/column.         */
/*-------------------------------------------------------------------*/
void sba2rc(char *inaddr,  /* input buffer addr */
            int *row,      /* returned row */
            int *col,      /* returned column */
            int adjust)    /* amount to subtract - usuallu 0 for the */
                           /*   returned cursor position, but is set */
                           /*   to one to get correct returned buffer*/
                           /*   addresses.                           */
{
  int taddr,     /* Temporary address holder */
      offset ;
  short addr ;
  memcpy((char *)&addr,inaddr,sizeof(short)) ;

  /* If 12-bit address, then we need to massage it a little */
  if (addr & 0xc000)    /* 12-bit address ? */
    {
       addr &= 0x3f3f ;      /* turn off 2 hi bits in each byte */
       taddr = addr >> 8 ;   /* taddr is first 6 bits */
       addr &= 0x00ff ;      /* addr is second 6 bits */
       taddr = taddr << 6 ;  /* shift taddr left and .. */
       taddr ×= addr ;       /*   merge taddr with addr into taddr */
       offset = taddr ;      /* taddr is the offset into the buffer */
    }
  else
    offset = addr ;          /* addr is the offset into the buffer */

  offset = offset - adjust ; /* adjust is either 0 or 1 */

  /* turn offset into row and column based on device num of columns */
  *col = (offset % sdcb.cols) + 1 ;
  *row = (offset / sdcb.cols) + 1 ;
}

/*-------------------------------------------------------------------*/
/* Return the name of a 3270 action key given the AID value.         */
/*-------------------------------------------------------------------*/
void getkeynm(char *keyname,
              char key)
{
  if (key == ENTER)
    strcpy(keyname,"ENTER") ;
  else if (key == PF1)
    strcpy(keyname,"PF1") ;
  else if (key == PF2)
    strcpy(keyname,"PF2") ;
  else if (key == PF3)
    strcpy(keyname,"PF3") ;
  else if (key == PF4)
    strcpy(keyname,"PF4") ;
  else if (key == PF5)
    strcpy(keyname,"PF5") ;
  else if (key == PF6)
    strcpy(keyname,"PF6") ;
  else if (key == PF7)
    strcpy(keyname,"PF7") ;
  else if (key == PF8)
    strcpy(keyname,"PF8") ;
  else if (key == PF9)
    strcpy(keyname,"PF9") ;
  else if (key == PF10)
    strcpy(keyname,"PF10") ;
  else if (key == PF11)
    strcpy(keyname,"PF11") ;
  else if (key == PF12)
    strcpy(keyname,"PF12") ;
  else if (key == PF13)
    strcpy(keyname,"PF13") ;
  else if (key == PF14)
    strcpy(keyname,"PF14") ;
  else if (key == PF15)
    strcpy(keyname,"PF15") ;
  else if (key == PF16)
    strcpy(keyname,"PF16") ;
  else if (key == PF17)
    strcpy(keyname,"PF17") ;
  else if (key == PF18)
    strcpy(keyname,"PF18") ;
  else if (key == PF19)
    strcpy(keyname,"PF19") ;
  else if (key == PF20)
    strcpy(keyname,"PF20") ;
  else if (key == PF21)
    strcpy(keyname,"PF21") ;
  else if (key == PF22)
    strcpy(keyname,"PF22") ;
  else if (key == PF23)
    strcpy(keyname,"PF23") ;
  else if (key == PF24)
    strcpy(keyname,"PF24") ;
  else if (key == PA1)
    strcpy(keyname,"PA1") ;
  else if (key == PA2)
    strcpy(keyname,"PA2") ;
  else if (key == PA3)
    strcpy(keyname,"PA3") ;
  else if (key == CLEAR)
    strcpy(keyname,"CLEAR") ;
  else if (key == SYSREQ)
    strcpy(keyname,") SYSREQ") ;
  else if (key == OID)
    strcpy(keyname,"OID") ;
  else if (key == MAG)
    strcpy(keyname,"MAG") ;
  else if (key == PEN)
    strcpy(keyname,"PEN") ;
  else
    strcpy(keyname,"UNKNOWN") ;
}

/*-------------------------------------------------------------------*/
/* Check color attribute and copy if valid.                          */
/*-------------------------------------------------------------------*/
int modsym(char *out,
           char in )
{
  switch (in)
    {
    case DFLT:
      *out = in ;
      return 0 ;
    case APL:
      if (sdcb.aplflg)
        {
          *out = in ;
          return 0 ;
        }
      else
        return 1 ;
    default:
      if (sdcb.loadflg)
        {
          if ((in>=0x40) && (in<=0xef))
            {
              *out = in ;
              return 0 ;
            }
          else
            return 1 ;
        }
      else
        return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Check color attribute and copy if valid.                          */
/*-------------------------------------------------------------------*/
int modcolor(char *out,
             char in )
{
  switch (in)
    {
    case DFLT:
    case BLUE:
    case RED:
    case PINK:
    case GREEN:
    case TURQ:
    case YELLOW:
    case WHITE:
      *out = in ;
      return 0 ;
    default:
      return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Check hilite attribute and copy if valid.                         */
/*-------------------------------------------------------------------*/
int modhilit(char *out,
             char in )
{
  switch (in)
    {
    case NONE:
    case BLINK:
    case RVIDEO:
    case USCORE:
      *out = in ;
      return 0 ;
    default:
      return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Check field attribute and copy if valid.                          */
/*-------------------------------------------------------------------*/
int modattr(char *out,
            char in )
{
  switch (in)
    {
    case PRT:       /* protected normal intensity */
    case PRTHI:     /* protected high intensity */
    case PRTAS:     /* protected normal intensity auto skip */
    case PRTHIAS:   /* protected high intensity auto skip */
    case UNPRT:     /* unprotected normal intensity */
    case UNNUM:     /* unprotected numeric normal intensity */
    case UNNUMHI:   /* unprotected numeric high intensity */
    case UNNON:     /* unprotected non display */
    case UNHI:      /* unprotected high intensity */
      *out = in ;
      return 0 ;
    default:
      return 1 ;
    }
}

/*-------------------------------------------------------------------*/
/* Load programmed symbols - type 1 load                             */
/*   loads programmed symbols without compression                    */
/*-------------------------------------------------------------------*/
int loadps1()
  {
    int rc ;         /* return code */
    int hi ;         /* cell height */
    int bufpos ;     /* next buffer position */
    int i, j ;       /* counters */
    short s ;        /* temp */

    if (sdcb.celheigh == 0)
      hi = sdcb.uacelh ;     /* use usable area height */
    else
      hi = sdcb.celheigh ;   /* default to Implicit partition height */

    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */

    bufpos = 0 ;
    buffer[bufpos++] = WSF ;   /* write structured field */
    buffer[bufpos++] = 0x00 ;  /* structured field length */
    buffer[bufpos++] = 0x07 ;  /* structured field length contd. */
    buffer[bufpos++] = 0x06 ;  /* load PS structured field */
    buffer[bufpos++] = 0x41 ;  /* flags: clear sym.set and use type 1 */
    buffer[bufpos++] = 0xff ;  /* make associated RWS = not assigned */
    buffer[bufpos++] = 0x41 ;  /* starting code point */
    buffer[bufpos++] = 0x02 ;  /* RWS of PSA symbol set */

    /* write buffer to the 3270 */
    rc = tputn(buffer, bufpos) ;

    memset(buffer,0x00, bufpos) ;  /* clear buffer */

    bufpos = 0 ;
    buffer[bufpos++] = WSF ;   /* write structured field */
    buffer[bufpos++] = 0x00 ;  /* structured field length */
    buffer[bufpos++] = 0x00 ;  /* structured field length contd. */
    buffer[bufpos++] = 0x06 ;  /* load PS structured field */
    buffer[bufpos++] = 0x01 ;  /* flags: use type 1 */
    buffer[bufpos++] = 0x40 ;  /* make associated RWS = 0x40 */
    buffer[bufpos++] = 0x41 ;  /* starting code point (symbol=65) */
    buffer[bufpos++] = 0x02 ;  /* RWS of PSA symbol set */

 /* This extra stuff needs the flags bit 1 on to indicate extended
    I dont think I need to use it yet.

    buffer[bufpos++] = 0x08 ;     P length - length of extra parms
    buffer[bufpos++] = 0x00 ;     flags: operator selectable ...
    buffer[bufpos++] = 0x09 ;     LW - width of character
    buffer[bufpos++] = 0x10 ;     LH - width of character
    buffer[bufpos++] = 0x00 ;     SUBSN - only one byte codes
    buffer[bufpos++] = 0xf1 ;     COLOR - F1 - first attr ???
    buffer[bufpos++] = 0x00 ;     ST.SUBSN - default
    buffer[bufpos++] = 0xf9 ;     ECHAR - last symbol=249

    buffer[bufpos++] = 0x00 ;     NW - number width pairs
    buffer[bufpos++] = 0x00 ;     NH - number height pairs
    buffer[bufpos++] = 0x00 ;     RES - reserved
 */

    /* load specific font based on the cell height */
    if (hi >= 16)
      {
        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */
          {
            for (j=0;j<=17;j++)      /* for each slice  */
              {
                buffer[bufpos++] = ps9x16u[i][j] ;
              }
          }
      }
    else if (hi == 15)
      {
        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */
          {
            for (j=0;j<=17;j++)      /* for each slice  */
              {
                buffer[bufpos++] = ps9x15u[i][j] ;
              }
          }
      }
    else
      {
        for (i=65;i<=249;i++)   /* for each symbol, 0x41 to 0xF9 */
          {
            for (j=0;j<=17;j++)      /* for each slice  */
              {
                buffer[bufpos++] = ps9x12u[i][j] ;
              }
          }
      }

    s = bufpos - 1 ;
    memcpy(buffer+1,&s,sizeof(short)) ;

    /* write buffer to the 3270 to load the programmed symbols */
    rc = tputn(buffer, bufpos) ;

    memset(buffer,0x00,BUFFMAX) ;  /* clear buffer */
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* Get the display device attributes.                                */
/*-------------------------------------------------------------------*/
int getdev()
  {
    int rc, pr = 0, pc = 0, ar = 0, ac = 0, att = 0 ;
    int i ;

    /* set the default values, may get over ridden later */
    sdcb.adrmode = 12 ;  /* addressing mode */
    sdcb.altflg = 0 ;    /* use primary device */
    sdcb.edsflg = 0 ;    /* no extended data stream */
    sdcb.graflg = 0 ;    /* not a graphics device */
    sdcb.aplflg = 0 ;    /* no apl symbols on device */
    sdcb.psflg = 0 ;     /* no program symbols on device */
    sdcb.loadflg = 0 ;   /* no loadable symbols sets on device */
    sdcb.triflg = 0 ;    /* no triple plane symbols sets on device */
    sdcb.dbcsflg = 0 ;   /* no double byte symbols on device */
    sdcb.celheigh = 0 ;  /* zero cell height on device */
    sdcb.celwidth = 0 ;  /* zero cell width on device */
    sdcb.uacelh = 0 ;    /* zero usable area cell height on device */
    sdcb.uacelw = 0 ;    /* zero usable area cell width on device */
    sdcb.unit = 0 ;      /* units are inches */
    sdcb.colora = 1 ;    /* actual colors default to monochrome */
    sdcb.colors = 1 ;    /* supported colors default to monochrome */
    sdcb.hilites = 0 ;   /* supported hilites default to none */
    for (i=0;i<17;i++)
      sdcb.colorlst[i] = 0x00 ; /* list of color attributes on device*/
    for (i=0;i<5;i++)
      sdcb.hilitlst[i] = 0x00 ; /* list of hilite attributes on device*/


    /* get info from TSO about this device */
    rc = getterm(&pr,&pc,&ar,&ac,&att) ;
    if (rc==0)                 /* get terminal info worked ? */
      {
        if (att==0x00000001)   /* device has query structured fields */
          {
            /* set row and col may be later reset by query dev */
            if ((ar>0) && (ar!=pr) &&
                (ac>0) && (ac!=pc))
              {
                sdcb.altflg = 1 ;    /* use alternate device */
                sdcb.rows = ar ;     /* use alternate rows */
                sdcb.cols = ac ;     /* use alternate cols */
              }
            else
              {
                sdcb.rows = pr ;     /* use primary rows */
                sdcb.cols = pc ;     /* use primary cols */
              }

            rc = querydev() ;
            /* try to determine actual device */
            if (sdcb.rows == 32)
              {
                strcpy(sdcb.modname,"IBM3279-3") ;
                sdcb.model = 3279 ;
                sdcb.type = 3 ;
              }
            else if (sdcb.rows == 43)
              {
                strcpy(sdcb.modname,"IBM3278-4") ;
                sdcb.model = 3278 ;
                sdcb.type = 4 ;
              }
            else if (sdcb.rows == 27)
              {
                strcpy(sdcb.modname,"IBM3290") ;
                sdcb.model = 3290 ;
                sdcb.type = 5 ;
              }
            else  /* cant tell - use most primitive */
              {
                strcpy(sdcb.modname,"IBM3278-2") ;
                sdcb.model = 3278 ;
                sdcb.type = 2 ;
              }
          }
        else  /* dont know a lot about the device - make some guesses */
          {
            if ((ar>0) && (ar!=pr) &&
                (ac>0) && (ac!=pc))
              {
                sdcb.altflg = 1 ;    /* use alternate device */
                sdcb.rows = ar ;     /* use alternate rows */
                sdcb.cols = ac ;     /* use alternate cols */
              }
            else
              {
                sdcb.rows = pr ;     /* use primary rows */
                sdcb.cols = pc ;     /* use primary cols */
              }

            /* try to determine actual device */
            if (sdcb.rows == 32)
              {
                strcpy(sdcb.modname,"IBM3279-3") ;
                sdcb.model = 3279 ;
                sdcb.type = 3 ;
              }
            else if (sdcb.rows == 43)
              {
                strcpy(sdcb.modname,"IBM3278-4") ;
                sdcb.model = 3278 ;
                sdcb.type = 4 ;
              }
            else if (sdcb.rows == 27)
              {
                strcpy(sdcb.modname,"IBM3290") ;
                sdcb.model = 3290 ;
                sdcb.type = 5 ;
              }
            else  /* cant tell - use most primitive */
              {
                strcpy(sdcb.modname,"IBM3278-2") ;
                sdcb.model = 3278 ;
                sdcb.type = 2 ;
              }
          }
        return 0 ;
      }
    else  /* get term failed - return its code */
      return rc ;
  }

/*-------------------------------------------------------------------*/
/* This routine loads an assebbler module below the 16 MB line       */
/* that issues the GTTERM macro instruction to obtain the            */
/* dimensions of the screen and also some bit fields that            */
/* tell if the device can be queried. The module copies the          */
/* results from storage below the line to this routines              */
/* automatic storage.                                                */
/* Upon completion the module is unloaded.                           */
/*-------------------------------------------------------------------*/
int getterm(int *primrow, int *primcol,
             int *altrow, int *altcol,
             int *attrs)
  {
    struct {
      union {
        short sh ;
        char c[2] ;
      } prim ;
      union {
        short sh ;
        char c[2] ;
      } alt ;
      int attr ;
    } pm ;
    int rc = 0 ;
    int (*tgt327d)(void *) ;

    loadm("TGT327D",&tgt327d) ;   /* load ASM routine below 16M */
    rc = (*tgt327d)(&pm) ;        /* execute GTTERM macro */
    if (rc==0)      /* data returned OK ? */
      {             /* yes - convert single byte numbers to int */
        *primrow = pm.prim.c[0] ;
        *primcol = pm.prim.c[1] ;
        *altrow = pm.alt.c[0] ;
        *altcol = pm.alt.c[1] ;
        *attrs = pm.attr ;
      }
    unloadm(tgt327d) ;            /* unload ASM routine */
    return rc ;                   /* return code from GTTERM */
  }

/*-------------------------------------------------------------------*/
/* Clear 3270 screen.                                                */
/*-------------------------------------------------------------------*/
void clear()
  {
    int rc ;
    char sba[2] ;
    char out1[] = {      /* set up for erase */
      WRT, 0x40,
      SBA, 0x5d, 0x7f,   /* end addr - overlayed later */
      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */
      SBA, 0xe7, 0x7f,   /* insert cursor location, row/col max */
      ICUR               /* insert cursor */
      } ;
    char out2[] = {      /* erase write alternate */
      EWA, 0xc2
      } ;
    char out3[] = {      /* erase primary */
      WRT, 0xc2
      } ;

    /* set max screen size known so far sba */
    rc2sba(sdcb.rows,sdcb.cols,sba) ;
    out1[9] = sba[0] ;
    out1[10] = sba[1] ;

    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */
    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */
    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */
  }

/*-------------------------------------------------------------------*/
/* Select the entire screen buffer using SBA based on the            */
/* scrsize returned from GTTERM and EW/EWA to select the             */
/* primary or alternate buffer.                                      */
/* Then assemble a structured field query, and send it to the        */
/* device using TPG which will cause the device to imediately        */
/* send back the response without any user intervention.             */
/* Then decode the read partition, query operations, query and       */
/* put the interesting data in the sdcb structure.                   */
/*-------------------------------------------------------------------*/
int querydev()
  {
    short sflen ;      /* structured field length */
    char  sfid ;       /* structured field ID */
    char  qcode ;      /* query reply - query code */
    char input[256] ;  /* query buffer */
    char *ibuf ;       /* current query buffer pointer */
    int rc ;
    char sba[2] ;

    char out1[] = {      /* set up for erase */
      WRT, 0x40,
      SBA, 0x5d, 0x7f,   /* end addr - overlayed later, rc= 24,80 */
      SBA, 0x40, 0x40,   /* start addr row=1 col=1 */
      SBA, 0xe7, 0x7f,   /* insert cursor loc, rc= 32,80 *OVERLAYED**/
      ICUR               /* insert cursor */
      } ;

    char out2[] = {      /* erase write alternate */
      EWA, 0xc2
      } ;

    char out3[] = {      /* erase primary */
      WRT, 0xc2
      } ;

    char out4[] = {
      WSF,               /* write structured field */
      0x00, 0x05,        /* structured field length */
      0x01,              /* read partition */
      0xFF,              /* query operations */
      0x02               /* query */
      } ;

    /* set max screen size known so far sba */
    rc2sba(sdcb.rows,sdcb.cols,sba) ;
    out1[9] = sba[0] ;
    out1[10] = sba[1] ;

    fill(input,0x00,sizeof(input)) ;   /* zero input buffer */

    rc = tputn(out1,sizeof(out1) ) ;   /* define the buffer */
    rc = tputn(out2,sizeof(out2) ) ;   /* erase write alternate */
    rc = tputn(out3,sizeof(out3) ) ;   /* erase write primary */
    rc = tpgn(out4,sizeof(out4) ) ;    /* query the device */
    rc = tgetn(input,sizeof(input)) ;  /* receive device resp.*/

    ibuf = input ;       /* point at input */

    if (*input==0x88)    /* check for 88 AID byte */
      {
        ibuf = ibuf+1 ;         /* advance to 1st structured field */
        sfid = *(ibuf+2) ;      /* sfid should be 0x81 */

        while (sfid==0x81)  /* while structured fields remain */
          {
            sflen = *((short *)ibuf) ;  /* get structured field len */
            if (sflen==0)           /* bad error - should not happen */
              {
                sprintf(msg,"Error structured field len. zero at %p\n",
                  ibuf) ;
                execmsg("WIN034S",msg) ;
                dumpchar(input,sizeof(input)) ;
                return 1 ;
              }
            qcode = *(ibuf+3) ;     /* get query code */
            switch (qcode)
              {
                case 0x80:           /* Q-code summary */
                  rc = dsummary(ibuf,sflen) ;
                  break ;
                case 0x81:           /* Usable area */
                  rc = darea(ibuf,sflen) ;
                  break ;
                case 0x85:           /* Character sets */
                  rc = dcharset(ibuf,sflen) ;
                  break ;
                case 0x86:           /* Color */
                  rc = dcolor(ibuf,sflen) ;
                  break ;
                case 0x87:           /* Highlighting */
                  rc = dhilite(ibuf,sflen) ;
                  break ;
                case 0x88:           /* Modes */
                  rc = dmodes(ibuf,sflen) ;
                  break ;
                case 0xa6:           /* Implicit partition */
                  rc = dimpart(ibuf,sflen) ;
                  break ;
                default:
                  break ;
              }  /* of switch */
            ibuf = ibuf+sflen ; /* advance to next structured field */
            sfid = *(ibuf+2) ;  /* sfid should be 0x81 - else stop */

          } /* of while sfid=81 */

      } /* of AID=88 */
    return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x80: Qcode summary                                               */
/*-------------------------------------------------------------------*/
int dsummary(char *buf, short buflen)
  {
     int i ;
     char qcode ;

     for (i=4;i<buflen;i++)
       {
          qcode = *(buf+i) ;     /* get query code */
          if (qcode == 0xb4)
            sdcb.graflg = 1 ;    /* indicate graphic support */
       }  /* of for i=4 */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x81: Usable area                                                 */
/*-------------------------------------------------------------------*/
int darea(char *buf, short buflen)
  {
     char celunits[6] ;   /* screen size unit PEL or CELL */
     short w, h ;         /* screen size w=width h=height */
     char aw, ah ;        /* units per cell aw=width ah=height */
     float xr, xrd, yr, yrd ;  /* pel spacing ratio */
     float fw, fh ;       /* ratio - pels per unit */

     if ((*(buf+4) & 0x03)==0x03)
       sdcb.adrmode = 16 ;
     else if ((*(buf+4) & 0x01)==0x01)
       sdcb.adrmode = 12 ;

     w = *((short *)(buf+6)) ;   /* width of usable area */
     h = *((short *)(buf+8)) ;   /* height of usable area */

     if (*(buf+10) == 0x01)    /* pels/in or pels/mm */
       sdcb.unit = 1 ;  /* units are mm */
     else
       sdcb.unit = 0 ;  /* units are inch */

     xr = *((short *)(buf+11)) ;    /* x dim pel ratio numerator */
     xrd = *((short *)(buf+13)) ;   /* x dim pel ratio denominator */
     yr = *((short *)(buf+15)) ;    /* y dim pel ratio numerator */
     yrd = *((short *)(buf+17)) ;   /* y dim pel ratio denominator */

     fw = (float)(xr) / (float)(xrd) ; /* horiz. ratio pels per unit */
     fh = (float)(yr) / (float)(yrd) ; /* vert. ratio pels per unit */

     aw = *(buf+19) ;    /* number of X units in default cell */
     ah = *(buf+20) ;    /* number of Y units in default cell */
     sdcb.uacelh = ah ;  /* use alt. cell height */
     sdcb.uacelw = aw ;  /* use alt. cell width */

     if (*(buf+5) & 0x20)       /* byte 5 bit 3 on unit=pels */
       strcpy(celunits,"pels") ;
     else                       /* other wise unit=cells */
       strcpy(celunits,"cells") ;

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x85: Character sets                                              */
/*-------------------------------------------------------------------*/
int dcharset(char *buf, short buflen)
  {
     int i, j ;         /* counters */
     int cgcsgid ;      /* Coded graphic character set identifier */
     short ccsid ;      /* Coded character set identifier */
     char gf = 0 ;      /* CGCSGID not present flag */
     char ch2 = 0 ;     /* Two byte char. set flag */
     char ms = 0 ;      /* Multiple slot sizes flag */
     char cf = 0 ;      /* CCSID not present flag */
     char sdw ;         /* Default character slot width */
     char sdh ;         /* Default character slot height */
     char dl ;          /* character set descriptor (CSD) length */
     char *csd ;        /* character set descriptor (CSD) ptr */
     char set ;         /* character set ID (PS store no.) */
     char lcid ;        /* character set Local ID (alias) */
     char sw ;          /* character set slot width */
     char sh ;          /* character set slot height */
     char ssubsn ;      /* character set starting subsection */
     char esubsn ;      /* character set ending subsection */

     if (*(buf+4) & 0x10)
       sdcb.psflg = 1 ;   /* load PS Extended supported */
     else
       sdcb.psflg = 0 ;   /* load PS Extended not supported */

     if (*(buf+4) & 0x08)
       ms = 1 ;   /* More than one size character slot supported */

     if (*(buf+4) & 0x04)
       ch2 = 1 ;  /* Two byte code character sets are supported */

     if (*(buf+4) & 0x02)
       gf = 1 ;   /* CGCSGID present */

     if (*(buf+5) & 0x20)
       cf = 1 ;   /* CCSID present */

     sdw = *(buf+6) ;
     sdh = *(buf+7) ;

     dl = *(buf+12) ;   /* get CSD length */
     i = 13 ;
     while (i<buflen)
       {
         csd = buf + i ;  /* point at CSD to process */
         set = *csd ;     /* get character set ID (PS store no.) */
         if (*(csd+1) & 0x80)
           sdcb.loadflg = 1 ;  /* loadable symbol sets exist */

         if (*(csd+1) & 0x40)
           sdcb.triflg = 1 ;   /* Triple-plane character sets exist */

         if (*(csd+1) & 0x20)
           sdcb.dbcsflg = 1 ;  /* Double-byte coded character sets */

         lcid = *(csd+2) ;   /* get character set ID (PS store no.) */

         j = 0 ;
         if (ms)
           {
             sw = *(csd+3) ;  /* slot width */
             sh = *(csd+4) ;  /* slot height */
             j = j + 2 ;
           }

         if (ch2)
           {
             ssubsn = *(csd+j+3) ;  /* starting sub-section */
             esubsn = *(csd+j+4) ; /* ending sub-section */
             j = j + 2 ;
           }

         if (gf)
           {
             cgcsgid = *((int *)(csd+j+3)) ;  /* Graf char set ID */
             if (cgcsgid==0x03c30136)
               sdcb.aplflg = lcid ;   /* APL supported store lcid */
             j = j + 4 ;
           }

         if (cf)
           {
             ccsid = *((short *)(csd+j+3)) ;  /* char set ID */
           }

         i = i + dl ;  /* get pos of next CSD */
       }  /* of while i<buflen */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x86: Colors                                                      */
/*-------------------------------------------------------------------*/
int dcolor(char *buf, short buflen)
  {
     int colora = 0 ; /* number of actual colors on device */
     int icolor ;     /* color index */
     int i, j = 0 ;   /* counter */
     char attr ;      /* color attribute accepted by device */
     char dcolor ;    /* color displayed for this attribute */

     sdcb.colors = (int)*(buf+5) ; /* number of colors accepted */
     for (i=6;i<buflen;i=i+2)
       {
         attr = *(buf+i) ;        /* attribute used by appl. */
         sdcb.colorlst[j++] = attr ;
         dcolor = *(buf+i+1) ;    /* attr/color used by device */
         icolor = (int)(dcolor - 0xf0) ;
         if ((icolor >= 0) && (icolor <= 15))
           colora++ ;
       }
     sdcb.colora = colora ;  /* number of actual colors on device */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x87: Highlighting                                                */
/*-------------------------------------------------------------------*/
int dhilite(char *buf, short buflen)
  {
     int i, j = 0 ;    /* counter */
     char attr ;       /* color attribute accepted by device */
     char dhilite ;    /* color displayed for this attribute */

     sdcb.hilites = (int)*(buf+4) ;
     for (i=5;i<buflen;i=i+2)
       {
         attr = *(buf+i) ;        /* attribute used by appl. */
         dhilite = *(buf+i+1) ;   /* attr/highlight used by device */
         sdcb.hilitlst[j++] = attr ;
       }

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0x88: Modes                                                       */
/*-------------------------------------------------------------------*/
int dmodes(char *buf, short buflen)
  {
     int i ;           /* counter */
     char mode ;       /* device opperation mode */

     for (i=4;i<buflen;i++)
       {
         mode = *(buf+i) ;        /* attribute used by appl. */
         if ((mode==0x01) ××
             (mode==0x02))
           sdcb.edsflg = 1 ;  /* queryable device can use extended DS*/
       }   /* of for i */

     return 0 ;
  }

/*-------------------------------------------------------------------*/
/* 0xa6: Implicit partition                                          */
/*-------------------------------------------------------------------*/
int dimpart(char *buf, short buflen)
  {
     char *sdp ;                /* self defining parameter (SDP) ptr */
     short wd, wa, hd, ha ;     /* screen dimensions */
     short wcd, wca, hcd, hca ; /* cell sizes */
     int i ;                    /* counter */

     i = 6 ;        /* length of header */
     while(i < buflen)   /* loop over all SDPs */
       {
         sdp = buf + i ;
         if (*sdp==0x0b)    /* is it a SDP ? */
           {
             if (*(sdp+1)==0x01)
               {
                 wd = *((short *)(sdp+3)) ;  /* default width */
                 hd = *((short *)(sdp+5)) ;  /* default height */
                 wa = *((short *)(sdp+7)) ;  /* alternate width */
                 ha = *((short *)(sdp+9)) ;  /* alternate height */
                 if ((ha>hd) ×× (wa>wd))
                   {
                     sdcb.altflg = 1 ;    /* use alternate device */
                     sdcb.rows = ha ;     /* use alternate rows */
                     sdcb.cols = wa ;     /* use alternate cols */
                   }
                 else
                   {
                     sdcb.rows = hd ;     /* use primary rows */
                     sdcb.cols = wd ;     /* use primary cols */
                   }
                 i = i + 11 ;     /* add length of this SDP */
               }
             else if (*(sdp+1)==0x03)
               {
                 i = i + 11 ;     /* add length of this SDP */
               }
             else if (*(sdp+1)==0x02)
               {
                 wcd = *((short *)(sdp+3)) ;  /* default cell width */
                 hcd = *((short *)(sdp+5)) ;  /* default cell height */
                 wca = *((short *)(sdp+7)) ;  /* alternate cell width */
                 hca = *((short *)(sdp+9)) ;  /* alternate cell height*/
                 if (sdcb.altflg)
                   {
                     sdcb.celheigh = hca ;
                     sdcb.celwidth = wca ;
                   }
                 else
                   {
                     sdcb.celheigh = hcd ;
                     sdcb.celwidth = wcd ;
                   }
                 i = i + 11 ;     /* add length of this SDP */
               }
           }
       }  /* of while */

     return 0 ;
  }




/*********************************************************************/
/* General string handling routines for varying length strings.      */
/*   lstran(mod_lstr,fromchar,tochar)                                */
/*   lstrload(to_lstr,fromchar,len)                                  */
/*   lstrunld(tochar,from_lstr)                                      */
/*   lstrcopy(to_lstr,from_lstr)                                     */
/*   lstrnew(to,fromchars)                                           */
/*   lstrsub(to_lstr,from_lstr,start,length)                         */
/*   len = lstrlen(haystack_lstr)                                    */
/*   pos = lstrindex(haystack_lstr,needle_lstr)                      */
/*   lstrfill(to_lstr,fillchars)                                     */
/*   rc = lstrcmpc(cmp_lstr,cmpchars)                                */
/*   lstrdel(del-lstr)                                               */
/*   lstrover(to_lstr,char,position)                                 */
/*   lstrrep(to_lstr,repchars,copies)                                */
/*   lstrcat(to_lstr,left_lstr,right_lstr)                           */
/*********************************************************************/

/*-------------------------------------------------------------------*/
/* Translate a character in an lstr to another character.            */
/*-------------------------------------------------------------------*/
void lstran(TLSTR *in, char from, char to)
{
  int i ;      /* temp counter */

  if (in)      /* from string exists ? */
    {
      for (i=0;i<=in->len;i++)
        {
          if (*(in->data+i) == from)
            *(in->data+i) = to ;
        }
    }
}

/*-------------------------------------------------------------------*/
/* Get the length of an lstr.                                        */
/*-------------------------------------------------------------------*/
int lstrlen(TLSTR *in)
{
  if (in)      /* from string exists ? */
    {
      return in->len ;
    }
  else
    return 0 ;
}

/*-------------------------------------------------------------------*/
/* Unload varying length string contents into character buffer.      */
/*-------------------------------------------------------------------*/
int lstrunld(char *to,
             TLSTR *from)
{
  if (from)      /* from string exists ? */
    {
      memcpy(to,from->data,from->len) ;
      return from->len ;
    }
  else
    return 0 ;
}

/*-------------------------------------------------------------------*/
/* Load varying length string with contents of character buffer.     */
/*-------------------------------------------------------------------*/
void lstrload(TLSTR *to,
              char *from,
              int len)
{
  if (to)      /* to string exists ? */
    {
      if (len!=to->len)
        {
          free((char *)to->data) ;
          to->data = (char *)malloc(len) ;
          if (!to->data) serror(4,"Not enough memory") ;
          to->len = len ;
        }
      memcpy(to->data,from,len) ;
    }
}

/*-------------------------------------------------------------------*/
/* Copy varying length string.                                       */
/*-------------------------------------------------------------------*/
void lstrcopy(TLSTR *to,
              TLSTR *from)
{
  if (from)      /* from string exists ? */
    {
      if (!to)    /* to string does not exist */
        serror(2,"String does not exist") ;
      else     /* to string exists */
        {
          if (from->len > 0)
            {
              if (to->data == NULL)     /* does not exist yet ? */
                {
                  to->data = (char *)malloc(from->len) ;
                  if (!to->data) serror(14,"Not enough memory") ;
                }
              else if (from->len != to->len)   /* increase length ? */
                {
                  free((char *)to->data) ;
                  to->data = (char *)malloc(from->len) ;
                  if (!to->data) serror(4,"Not enough memory") ;
                }
              to->len = from->len ;
              memcpy(to->data,from->data,from->len) ;
            }
          else
            {
              if (to->len > 0)   /* empty data */
                free((char *)to->data) ;
              to->len = 0 ;
              to->data = NULL ;
            }
        }
    }
}

/*-------------------------------------------------------------------*/
/* Initialize a varying length string with a string supplied length. */
/*-------------------------------------------------------------------*/
void lstrnewx(TLSTR *newstr,
             char *from,
             int len)
{
  if (!newstr)
    serror(5,"String does not exist") ;
  else
    {
      if (len > 0)
        {
          newstr->data = (char *)malloc(len) ;
          if (!newstr->data) serror(17,"Not enough memory") ;
          newstr->len = len ;
          memcpy(newstr->data,from,len) ;
        }
      else
        {
          newstr->len = 0 ;
          newstr->data = NULL ;
        }
    }
}

/*-------------------------------------------------------------------*/
/* Initialize a varying length string with a string.                 */
/*-------------------------------------------------------------------*/
void lstrnew(TLSTR *newstr,
             char *from)
{
  int i ;

  if (!newstr)
    serror(5,"String does not exist") ;
  else
    {
      i = strlen(from) ;
      if (i > 0)
        {
          newstr->data = (char *)malloc(i) ;
          if (!newstr->data) serror(17,"Not enough memory") ;
          newstr->len = i ;
          memcpy(newstr->data,from,i) ;
        }
      else
        {
          newstr->len = 0 ;
          newstr->data = NULL ;
        }
    }
}

/*-------------------------------------------------------------------*/
/* Create substring of a varying length string to a varying length   */
/* string.                                                           */
/*-------------------------------------------------------------------*/
void lstrsub(TLSTR *to,
             TLSTR *from,
             int start,
             int len)
{
  int i ;

  if (start <= from->len)
    {
      i = from->len - start ;
      if (len < i)
        i = len ;       /* i is the length of the sub string */

      if (!to)
        serror(8,"String does not exist") ;
      else
        {
          if (i > 0)
            {
              if (to->data == NULL)     /* does not exist yet ? */
                {
                  to->data = (char *)malloc(i) ;
                  if (!to->data) serror(20,
                    "Not enough memory") ;
                }
              else if (to->len != i)          /* wrong size ? */
                {
                  free((char *)to->data) ;
                  to->data = (char *)malloc(i) ;
                  if (!to->data) serror(10,
                    "Not enough memory") ;
                }
              to->len = i ;
              memcpy(to->data,from->data+start,i) ;
            }
          else
            {
              if (to->len > 0)   /* empty data */
                free((char *)to->data) ;
              to->len = 0 ;
              to->data = NULL ;
            }
        }
    }
}

/*-------------------------------------------------------------------*/
/* Find the position in a varying length string of a varying length  */
/* sub-string.                                                       */
/*-------------------------------------------------------------------*/
int lstrindx(TLSTR *haystack, /* string to search */
             TLSTR *needle)   /* sub-string to search for */
{
  int i, j, k, endpos ;

  endpos = haystack->len - needle->len ;
  for (i=0; i<endpos; i++)
    {
      k = 0 ;
      for (j=0; j<needle->len; j++)
        {
          if (haystack->data[i+j] == needle->data[j])
            k ++ ;
          else break ;
        }
      if (k==needle->len)
        return(i+1) ;
    }
  return 0 ;
}

/*-------------------------------------------------------------------*/
/* Compare a varying length string with a string.                    */
/*   rc = 0  == strings same                                         */
/*   rc = 1  == lstr has larger value than charstr                   */
/*   rc = -1 == lstr has smaller value than charstr                  */
/*-------------------------------------------------------------------*/
int lstrcmpc(TLSTR *lstr,   /* string to compare */
             char *cstr)    /* characters to compare with */
{
  int i ;               /* counter */
  int t=0 ;             /* compare flag */
  int l ;               /* compare length */
  int ld=0 ;            /* length differ flag */
  char *lstrptr ;
  char *cstrptr ;

  l = strlen(cstr) ;    /* determine shortest string */
  if (l != lstr->len)   /* same lengths ? */
    {                   /*   no .. */
      ld = 1 ;          /*   flag lengths differ */
      if (l > lstr->len)
        l = lstr->len ; /*   use shortest length */
    }

  /* compare to shortest length */
  lstrptr = lstr->data ;
  cstrptr = cstr ;
  for (i=0; i<l; i++)
    {
      if (*lstrptr > *cstrptr)
        {
          t = 1 ;    /* indicate left larger than right */
          break ;    /* end scan now  */
        }
      if (*lstrptr < *cstrptr)
        {
          t = -1 ;   /* indicate left smaller than right */
          break ;    /* end scan now  */
        }
      lstrptr++ ;
      cstrptr++ ;
    }

  if ((t==0) && (ld==1)) /* same after shortest length compared ? */
    {
      if (strlen(cstr) > lstr->len)
        t = -1 ;     /* lstr smaller */
      else
        t = 1 ;      /* lstr larger */
    }
  return t ;
}

/*-------------------------------------------------------------------*/
/* Fill a varying length string with a string.                       */
/*-------------------------------------------------------------------*/
void lstrfill(TLSTR *string,   /* string to fill */
              char *fillstr)  /* filler characters to use */
{
  int i ;
  char *strptr ;

  strptr = fillstr ;
  for (i=0; i<=string->len; i++)
    {
      string->data[i] = *(strptr++) ;
      if (*strptr=='\0')
        strptr = fillstr ;    /* start over on fill string */
    }
}

/*-------------------------------------------------------------------*/
/* Delete a varying length string (free associated memory).          */
/*-------------------------------------------------------------------*/
void lstrdel(TLSTR *string)   /* string to delete */
{
  free((char *)string->data) ;
  string->data = NULL ;
  string->len = 0 ;
}

/*-------------------------------------------------------------------*/
/* Overlay a character in a varying length string.                   */
/*-------------------------------------------------------------------*/
void lstrover(TLSTR *string,
             char oc,
             int pos)
{
  char *cp ;

  if ((pos >= 1) && (pos <= string->len))    /* position ok ? */
    {
      cp = string->data + pos + 1 ;
      *cp = oc ;
    }
}

/*-------------------------------------------------------------------*/
/* Create a varying length string with multiple copies of a string.  */
/*-------------------------------------------------------------------*/
void lstrrep(TLSTR *string,
             char *repstr,
             int copies)
{
  int repstrlen ;
  char *strptr ;
  int newlen ;
  int i ;

  /* The input string that replications are made from is assumed */
  /* to have a length of one or longer.                          */

  repstrlen = strlen(repstr) ;
  if (repstrlen==0)  /* assume repitition of 0x00 */
    repstrlen = 1 ;
  newlen = repstrlen * copies ;
  if (string->data==NULL)          /* alloc storage ? */
    {
      string->data = (char *)malloc(newlen) ;
      if (!string->data) serror(21,"Not enough memory") ;
    }
  else if (string->len!=newlen)    /* alloc more/less storage ? */
    {
      if (string->data)
        free((char *)string->data) ;
      string->data = (char *)malloc(newlen) ;
      if (!string->data) serror(11,"Not enough memory") ;
    }
  string->len = newlen ;     /* alter string length */
  strptr = repstr ;
  for (i=0; i<newlen; i++)        /* replicate the repstr data */
    {
      string->data[i] = *strptr++ ;
      if (*strptr == '\0')
        strptr = repstr ;
    }
}

/*-------------------------------------------------------------------*/
/* Concatenate two varying length strings together placing the       */
/* in a varying length string.                                       */
/*-------------------------------------------------------------------*/
void lstrcat(TLSTR *result,   /* result of concatenation */
             TLSTR *left,     /* left string to concatenate */
             TLSTR *right)    /* right string to concatenate */
{
  char *rstr ;
  int newlen ;

  newlen = left->len + right->len ;    /* extend LSTR */
  rstr = (char *)malloc(newlen) ;
  if (!rstr) serror(12,"Not enough memory") ;

  memcpy(rstr,left->data,left->len) ;   /* make new string */
  memcpy(rstr+left->len,right->data,right->len) ;

  free((char *)result->data) ;   /* assemble new LSTR */
  result->data = rstr ;
  result->len = newlen ;
}


/*********************************************************************/
/* General sub routines.                                             */
/*   fill(haystack,fillchar,number)                                  */
/*   dumpchar(buffer,length)                                         */
/*   overlay(buffer,bufferlen,overlay,overlaylen,overlaypos)         */
/*********************************************************************/

/*-------------------------------------------------------------------*/
/* Fill a character string with a number of filler characters.       */
/*-------------------------------------------------------------------*/
void fill(char *haystack,   /* area to fill */
          char filler,      /* fill characters */
          int num)          /* number of repetitions */
{
  int i = 0 ;
  for(i=0;i<=num;i++)
    *haystack++ = filler ;
  *haystack = '\0' ;
}

/*-------------------------------------------------------------------*/
/* Dump the contents of a buffer, formatted in a way that makes a    */
/* 3270 data stream easier to interpret.                             */
/*-------------------------------------------------------------------*/
void dumpchar(char *dat,    /* data to dump */
              int len)      /* length to dump */
{
  char *cptr ;
  char c ;
  char cc[3] ;
  int i ;
  int n, m ;

  n = 0 ;
  m = 0 ;
  cptr = dat ;
  do
    {
      printf("      %.8X ",dat) ;
      for(i=1;i<=16;i++)
        {                   /* 0 indicates all */
          if (*dat=='\0' && len==0)
            break ;
          if (n==len && len>0)
            break ;
          c = *dat++ ;
          n++ ;
          printf("%.2X",c) ;
          if ((i%4)==0)
            printf(" ") ;
        }
      printf("\n               ") ;

      for(i=1;i<=16;i++)
        {
          if (*cptr=='\0' && len==0)
            break ;
          if (m==len && len>0)
            break ;
          c = *cptr++ ;
          m++ ;
          if (c <= 0x3f ×× c==0xff)
            {
              switch (c)
                {
                  case GE:   strcpy(cc,"GE") ;
                    break ;
                  case FF:   strcpy(cc,"FF") ;
                    break ;
                  case CRR:  strcpy(cc,"CR") ;
                    break ;
                  case SBA:  strcpy(cc,"SB") ;
                    break ;
                  case EUA:  strcpy(cc,"EU") ;
                    break ;
                  case ICUR: strcpy(cc,"IC") ;
                    break ;
                  case NL:   strcpy(cc,"NL") ;
                    break ;
                  case EM:   strcpy(cc,"EM") ;
                    break ;
                  case DUP:  strcpy(cc,"DU") ;
                    break ;
                  case SF:   strcpy(cc,"SF") ;
                    break ;
                  case FM:   strcpy(cc,"FM") ;
                    break ;
                  case SA:   strcpy(cc,"SA") ;
                    break ;
                  case SFE:  strcpy(cc,"SX") ;
                    break ;
                  case MF:   strcpy(cc,"MF") ;
                    break ;
                  case RA:   strcpy(cc,"RA") ;
                    break ;
                  case SUB:  strcpy(cc,"SU") ;
                    break ;
                  default:   strcpy(cc,". ") ;
                    break ;
                }
              printf("%s",cc) ;
            }
          else
            printf("%c ",c) ;
          if ((i%4)==0)
            printf(" ") ;
        }
      printf("\n") ;
    }
  while( ((*dat!='\0') && (len==0)) ××
         ((m!=len) && (len>20))
       ) ;
  printf("\n") ;
}

/*-------------------------------------------------------------------*/
/* Overlay characterc in a buffer.                                   */
/*-------------------------------------------------------------------*/
void overlay(char *haystack,    /* area to overlay */
             int haylen,        /* length to overlay */
             char *needle,      /* overlay characters */
             int len,           /* length of overlay */
             int pos)           /* start postition of overlay */
{
  int hlen, nlen ;   /* length of haystack and needle */
  int i = 0 ;        /* itterator */

  if (haylen==0)
    hlen = strlen(haystack) ;
  else
    hlen = haylen ;

  if (len==0)
    nlen = strlen(needle) ;
  else
    nlen = len ;

  if (hlen>(nlen+pos))
    {
      haystack = haystack+pos ;    /* move to overlay pos */
      for(i=0;i<nlen;i++)          /* copy the data */
        *haystack++ = *needle++ ;
    }
}

/*-------------------------------------------------------------------*/
/* General error message routine.                                    */
/*-------------------------------------------------------------------*/
void serror(int errno,
            char *msg)
{
  sprintf(msg,"Error: %d - %s\n",errno,msg) ;
  execmsg("WIN035S",msg) ;
  abort() ;
}

/*-------------------------------------------------------------------*/
/* Translate a string to upper case.                                 */
/*-------------------------------------------------------------------*/
void strtoupr(char *str)
  {
    char *strp ;

    strp = str ;
    while(*strp)
      {
        *strp = toupper(*strp) ;
        strp++ ;
      }
  }

