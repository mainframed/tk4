./       ADD   NAME=$ASM
//CBK0088A JOB (403-3,TECH),LANE,
//            MSGCLASS=X,
//            NOTIFY=CBK0088
/*JOBPARM TIME=1,FLASH=1501
//ASM      EXEC  PGM=IEV90,PARM='OBJECT',REGION=2048K
//SYSLIB   DD  DISP=SHR,DSN=CBK0088.SYSTEMS.LISTICAT
//         DD  DISP=SHR,DSN=SYS1.AMODGEN
//         DD  DSN=SYS1.MACLIB,DISP=SHR
//SYSUT1   DD  UNIT=WORK,SPACE=(CYL,(9,1)),DSN=&SYSUT1
//SYSPUNCH DD  DUMMY
//SYSPRINT DD SYSOUT=*
//SYSLIN   DD  DISP=SHR,DSN=CBK0088.SYSTEMS.OBJ(LISTICAT)
//SYSIN    DD  DISP=SHR,DSN=CBK0088.SYSTEMS.LISTICAT(LISTICAT)
./       ADD   NAME=$DOC
         TITLE 'DISCLAIMER - INSTALLATION INSTRUCTIONS'
***********************************************************************
*                                                                     *
*     THIS PROGRAM, DEVELOPED AT CONTINENTAL BANK OF CANADA OR        *
*     SUPPLIED BY OTHER USERS ON A NON-RESTRICTIVE BASIS, IS OF       *
*     GENERAL INTEREST AND IS SUBMITTED FOR UNRESTRICTED DISTRIBUTION.*
*                                                                     *
*     THE AUTHOR HAS, SINCE DEVELOPING THIS PROGRAM, MOVED TO SUNCOR  *
*     INC.  USERS ARE INVITED TO SUBMIT SUGGESTIONS OR ERROR          *
*     DOCUMENTATION TO SUNCOR.  HOWEVER, NO PROMISE CAN BE MADE THAT  *
*     SUCH SUGGESTIONS WILL BE IMPLEMENTED OR ERRORS CORRECTED.       *
*     SUBMIT COMMENTS TO:                                             *
*                                                                     *
*                                                                     *
*                                                                     *
*                                                                     *
*              JIM LANE                                               *
*              TECHNICAL SUPPORT GROUP                                *
*              SUNCOR INC.                                            *
*              36 YORK MILLS RD                                       *
*              TORONTO, ONTARIO M2P 2C5                               *
*                                                                     *
*                PHONE: (416)-733-7396                                *
*                                                                     *
*                SHARE INSTALLATION CODE: SNI                         *
*                                                                     *
*     THIS PROGRAM IS MADE AVAILABLE BY SUNCOR WITHOUT CHARGE OR      *
*     CONSIDERATION.  RECIPIENTS ARE FREE TO MAKE THIS PROGRAM        *
*     AVAILABLE TO OTHERS IN LIKE MANNER.  IT MAY NOT BE SOLD.        *
*                                                                     *
*                                                                     *
* NAME         LISTICAT                                               *
*                                                                     *
* FUNCTION     LIST THE CONTENTS OF AN ICF CATALOG AND SELECTED       *
*              DSCB AND VVDS FIELDS.                                  *
*                                                                     *
* DESCRIPTION  THE UCBS OF ALL ONLINE DASD VOLUMES ARE LOCATED AND    *
*              AN ATTEMPT IS MADE TO ALLOCATE SYS1.VVDS.VVOLSER.  IF  *
*              THIS WORKS AN ACB AND RPL ARE GENERATED AND THEIR      *
*              ADDRESSES ARE SAVED IN A LOOKUP TABLE.  THE BCS        *
*              CLUSTER IS OPENED AS A DATASET AND READ SEQUENTIALLY.  *
*              THE BCS RECORDS ARE SCANNED FOR CELL TYPES AND THE     *
*              FOLLOWING CELLS ARE LISTED:                            *
*                                                                     *
*                NONVSAM                                              *
*                CLUSTER                                              *
*                INDEX                                                *
*                DATA                                                 *
*                AIX                                                  *
*                PATH                                                 *
*                GDG BASE                                             *
*                GDG ENTRY                                            *
*                                                                     *
*              FOR NONVSAM ENTRIES THE FORMAT1 AND, IF IT EXISTS THE  *
*              FORMAT 3, DSCB IS "OBTAINED" TO DETERMINE IF THE       *
*              OBJECT EXISTS. IF IT DOES THE LRECL, BLKSIZE AND TOTAL *
*              TRACKS ALLOCATED ARE EXTRACTED.  IF THE OBJECT IS      *
*              CATALOGUED TO VOLSER "MIGRAT" THE HSM                  *
*              MIGRATIONCONTROLDATASET IS OPENED (SYSUT2) AND USED    *
*              INSTEAD OF THE VTOC.                                   *
*                                                                     *
*              FOR DATA AND INDEX ENTRIES THE VVDS OF THE VOLUME IN   *
*              QUESTION, IF AVAILABLE, IS SCANNED TO DETERMINE THE    *
*              LRECL, BLKSIZE AND TRACK ALLOCATION OF THE OBJECT.     *
*                                                                     *
* ENVIRONMENT  OS/VS2 MVS, JDM1113 OR HDQ1102                         *
*              MVS/XA 2.1.5 DF/HSM 2.1.0                           @122
*              MVS/XA 2.1.7  DF/HSM 2.2.0 DFP/XA 2.2.0             @131
*              MVS/XA 2.2.0  DF/HSM 2.3.1 DFP/XA 2.3.0             @132
*              MVS/ESA 3.1.3 DF/HSM 2.6.0 DFP/XA 2.3.0
*                                                                     *
* INPUT        THE BCS OF THE ICF CATALOG TO BE LISTED.               *
*                                                                     *
* OUTPUT       OUTPUT CONSISTS OF A LISTING OF THE CATALOG.           *
*                                                                     *
*                                                                     *
*                   DSNAME - THE NAME OF THE COMPONENT BEING LISTED.  *
*                        FOR GDG ENTRIES THIS IS DEVELOPED INTO THE   *
*                        FORMAT THAT WOULD BE IN A FORMAT1 DSCB.      *
*                                                                     *
*                   TYPE - THE TYPE OF THE CELL BEING LISTED.         *
*                                                                     *
*                   VOLUME - THE VOLSER OF THE VOLUME TO WHICH THE    *
*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *
*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *
*                                                                     *
*                   UNIT - THE NAME OF THE UNIT TO WHICH THE          *
*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *
*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *
*                                                                     *
*                   TRKS - THE NUMBER OF TRACKS ALLOCATED TO A DASD   *
*                        RESIDENT OBJECT. LEFT BLANK FOR CATALOGED,   *
*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *
*                                                                     *
*                   BLKSZ - THE PHYSICAL BLOCK SIZE OF THE OBJECT.    *
*                        LEFT BLANK FOR CATALOGED,                    *
*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *
*                                                                     *
*                   LRECL - THE LOGICAL RECORD LENGTH OF THE OBJECT.  *
*                        LEFT BLANK FOR CATALOGED,                    *
*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *
*                                                                     *
* CONSIDERATIONS                                                      *
*                                                                     *
*              ABEND CODES:                                           *
*                                                                     *
*                   U0014 - BCS CLUSTER FAILED TO OPEN.               *
*                        ERROR CODE IN REGISTER 2.                    *
*                                                                     *
*                   U0015 - BCS GET FAILED.                           *
*                                                                     *
*                   U0256 - VVDS TABLE OVERFLOW                    @131
*                                                                     *
* PARAMETERS   PARM=DUMP PRODUCES A HEX-TRANSLATED LISTING OF         *
*                        BCS AND VVDS CELLS.                          *
*                                                                     *
* EXECUTION    DDNAMES                                                *
*                                                                     *
*              STEPCAT  DEFINES THE ICF CATALOG TO BE LISTED.         *
*                                                                     *
*              SYSUT1   DEFINES THE ICF CATALOG TO BE LISTED.         *
*                                                                     *
*              SYSUT2   DEFINES THE HSM MIGRATIONCONTROLDATASET.      *
*                       IF YOU DON'T HAVE HSM THIS CAN BE LEFT OUT.   *
*                                                                     *
*              SYSPRINT DEFINES THE OUTPUT LISTING DATA SET.          *
*                                                                     *
* EXAMPLE                                                             *
*                                                                     *
*              //LCAT   EXEC  PGM=LISTICAT                            *
*              //SYSLIST  DD  SYSOUT=*                                *
*              //SYSPRINT DD  SYSOUT=*                                *
*              //STEPCAT  DD  DSN=ICF.CATALOG,DISP=OLD                *
*              //SYSUT1   DD  DSN=ICF.CATALOG,DISP=OLD                *
*              //SYSUT2   DD  DSN=HSM.MCDS,DISP=OLD                   *
*              //SYSUDUMP DD  SYSOUT=*                                *
*                                                                     *
* NON-IBM MACROS USED (IN MAINLINE OR SUBROUTINES)                    *
*              $EPILOG  - MAIN EXIT LINKAGE                           *
*              $IN      - SUBROUTINE ENTRY LINKAGE                    *
*              $OUT     - SUBROUTINE EXIT LINKAGE                     *
*              $PROLOG  - MAIN ENTRY LINKAGE                          *
*              $REGS    - REGISTER EQUATES                            *
*              ALLOC    - DYNAMIC ALLOCATION                          *
*              DYNSPACE - GENERATE PARMLIST FOR ALLOC                 *
*              EDIT     - FORMAT A DISPLAY NUMERIC FIELD              *
*              HEX      - CONVERT HEX TO PRINTABLE                    *
*              XPRCLOSE - CLOSE A PRINT FILE                          *
*              XPRDCB   - DEFINE A PRINT FILE                         *
*              XPRHEAD  - DEFINE A REPORT HEADING                     *
*              XPRLDEF  - DEFINE A REPORT LINE LAYOUT                 *
*              XPRNTLIN - PRINT A REPORT LINE                         *
*              XPROPEN  - OPEN A PRINT FILE                           *
*                                                                     *
* IBM MACROS USED  (IN MAINLINE OR SUBROUTINES)                       *
*              ABEND    - ABNORMAL TERMINATION.                       *
*              ACB      - DEFINE AN ACB                               *
*              CAMLST   - DEFINE A PARMLIST FOR OBTAIN                *
*              CLOSE    -                                             *
*              CVT      - MAP THE CVT FOR UCB SCAN.                   *
*              DCB      - DEFINE A DCB                                *
*              EXLST    - DEFINE AN EXIT LIST FOR EOF                 *
*              FREEPOOL - FREE BUFFERS                                *
*              GENCB    - GENERATE A VSAM CONTROL BLOCK               *
*              GET      - READ A VSAM LOGICAL RECORD                  *
*              GETMAIN  - ALLOCATE VIRTUAL STORAGE                    *
*              IEFUCBOB - MAP A UCB                                   *
*              IEFZB4D0 - DYNALLOC DATA AREAS                         *
*              IEFZB4D2 - DYNALLOC DATA AREAS                         *
*              IEZJSCB  - MAP MY JOBSTEP CONTROL BLOCK                *
*              IKJTCB   - MAP MY TCB                                  *
*              MODESET  - GET INTO AND OUT OF SUPR STATE/KEY 0        *
*              OBTAIN   - READ A DSCB                                 *
*              OPEN     -                                             *
*              POINT    - ESTABLISH POSITIONING WITHIN A VSAM FILE    *
*              SHOWCB   - PICK VSAM ERROR CODES.                      *
*              SYNADAF  - DIAGNOSE A NON-VSAM I/O ERROR               *
*              SYNADRLS - RELEASE SYNADAF WORKAREAS                   *
*              TIME                                                   *
*              WTO      - GIVE OPER THE BAD NEWS.                     *
*                                                                     *
* AUTHOR       THIS PORTIONS OF THIS PROGRAM HAVING TO DO WITH        *
*              PASSING THE BCS AND VVDS'S WERE WRITTEN BY J. LANE AT  *
*              CBOC. A LOT OF THE REST OF THE CODE HAS BEEN BORROWED  *
*              FROM VARIOUS SOURCES, MOSTLY OFF THE CBT TAPE. IF      *
*              SOMETHING IN HERE LOOKS FAMILIAR, IT'S PROBABLY        *
*              BECAUSE YOU WROTE IT!                                  *
*                                                                     *
* REGISTER USAGE                                                      *
*                                                                     *
*              R0  - WORK REGISTER.                                   *
*              R1  - WORK REGISTER.                                   *
*              R2  - WORK REGISTER.                                @122
*              R3  - ADDRESS OF CURRENT BCS CELL.                  @122
*              R4  - BASE ADDRESS OF DATASECT.                        *
*              R5  - WORK REGISTER.                                   *
*              R6  - ADDRESS OF CURRENT VVDS CELL.                    *
*              R7  - WORK REGISTER.                                   *
*              R8  - WORK REGISTER.                                   *
*              R9  - SUBROUTINE LINKAGE.                              *
*              R10 - PROGRAM BASE REGISTER 1                          *
*              R11 - PROGRAM BASE REGISTER 2                          *
*              R12 - PROGRAM BASE REGISTER 3                          *
*              R13 - SAVE AREA ADDRESS                                *
*              R14 - LINKAGE                                          *
*              R15 - LINKAGE                                          *
*                                                                     *
***********************************************************************
         SPACE 2
***********************************************************************
*                                                                     *
* NOTES  A PROGRAM MUST BE APF-AUTHORIZED IN MVS TO OPEN A CATALOG    *
*        AS A DATASET.                                                *
*                                                                     *
*        AT THE BANK I WAS GETTING PASSWORD PROMPTS WHEN I OPENED THE *
*        CATALOG. RATHER THAN FIGURE OUT WHY I TURNED ON THE          *
*        "NO-PASSWORD" BIT IN THE JSCB. THIS MAY NOT BE NECESSARY IN  *
*        YOUR ENVIRONMENT AND, IF SO, YOU CAN TAKE OUT THE LOGIC.     *
*                                                                     *
*        THE HEX-DUMP LISTING CAN BE A SECURITY EXPOSURE AS WRITTEN   *
*        BECAUSE IT PRINTS OUT THE "SECURITY" CELL, IF PRESENT, WHICH *
*        CONTAINS THE PASSWORDS FOR PROTECTED OBJECTS. SECURITY       *
*        OFFICERS MAY NOT TAKE THAT IN THE NICEST SORT OF WAY!        *
*                                                                     *
*        NO ATTEMPT IS MADE TO DISCERN WHETHER SYSUT1 IS ACTUALLY AN  *
*        ICFCATALOG OR NOT. IF, INADVERTENTLY, IT ISN'T THIS CODE     *
*        WILL PROBABLY LOOP.                                          *
*                                                                     *
*        I WROTE THIS CODE IN THE WINTER OF 1983-1984 WHEN CBOC WAS   *
*        CONVERTING TO ICF CATALOGS. SINCE THE CONVERSION WENT MORE   *
*        SMOOTHLY THAN IT MIGHT HAVE DONE, I NEVER HAD A BROKEN       *
*        CATALOG TO WORK WITH. THEREFORE, THIS CODE ASSUMES A VALIDLY *
*        STRUCTURED CATALOG. I MAKE NO GUARANTEES WHAT MIGHT HAPPEN   *
*        OTHERWISE.                                                   *
*                                                                     *
***********************************************************************
         SPACE 2
***********************************************************************
*                                                                     *
* CHANGE ACTIVITY SUMMARY:                                            *
*                                                                     *
*                                                                     *
*    @134    - REMOVE CODE FROM MAINLINE TO SUBROUTINES TO            *
*              MAINTAIN ADDRESSABILITY. WAS GETTING CLOSE TO USING    *
*              UP 3 BASE REGISTERS.                                   *
*            - FIX BUG. PERCENT FREE SPACE CALC FOR VSAM WAS BOGUS    *
*            - ADD DEVICE TYPE FOR 3480 IDRC CARTRIDGE.               *
*            - PRINT >>> IF MORE THAN 999 CI SPLITS.                  *
*            - UPDATE COMMENT SECTION TO SHOW SUPPORT OF              *
*              MVS/ESA 3.1.3 AND DFHSM 2.6.0                          *
*                                                                     *
*    @AVV    - OPENING A VVDS REQUIRES AUTHORIZATION.                 *
*            - FIX BUG. LOOP WHEN ZERO LENGTH (?) CELL FOUND.         *
*                                                                     *
*    @132    - FIX LOOP IN FINDVVDS ROUTINE.                          *
*            - UPDATE COMMENT SECTION TO SHOWN SUPPORT OF DFP/XA V2.3 *
*                                                                     *
*    @131    - INCREASE MAXIMUM NUMBER OF VVDS'S SUPPORTED TO 256.    *
*              ADD DIAGNOSTIC CHECKING TO DETECT AN OVERFLOW OF THAT  *
*              LIMIT. THIS CAUSES MESSAGE 9 AND A USER ABEND.  THAT   *
*              CONSTITUTES THE FIX TO A PROBLEM REPORTED BY SAM RENAUD*
*              OF CORRIDAN JEWELLERS. THE PROGRAM USED TO HANDLE 32   *
*              VVDS'S AND ABEND0C4 AFTER THAT.
*            - UPDATE COMMENT SECTION TO SHOWN SUPPORT OF DFP/XA V2.  *
*                                                                     *
*    @130    - PRINT OUT EXTRA DATA FIELDS FOR VSAM OBJECTS: CI AND CA*
*              SPLITS, BUFFERSPACE, CI AND CA FREESPACE, NUMBER OF    *
*              EXTENTS AND PERCENT USED.                              *
*            - PRODUCE MESSAGE IDENTIFYING DATASETS CATALOGUED THAT   *
*              AREN'T ON THE VOLUME IN QUESTION.                      *
*                                                                     *
*    @122    - ADDED EXTRA DIAGNOSTIC CHECKING AND MESSAGES TO HANDLE *
*              PROBLEM REPORTED BY R. DIETES OF H.E. BUTT GROCERY CO. *
*              SITUATION WAS THE CASE WHERE THE BCS INFO EXISTS, THE  *
*              VVDS EXISTS BUT IT DOESN'T CONTAIN ANYTHING TO MATCH   *
*              THE DATASET FOUND IN THE BCS.  FIX WAS TO SENSE END OF *
*              FILE REACHED WHILE SCANNING THE VVDS FOR THE VVR OF A  *
*              CLUSTER COMPONENT, PRODUCE MESSAGE ABOUT VVR NOT FOUND *
*              WHEN EXPECTED AND PASS A RETURN CODE TO THE CALLER.    *
*            - ADD 3480 DEVICE TYPE SUPPORT.                          *
*            - TEST HSM LOGIC WITH DFHSM 2.1.0                        *
*            - CLOSE MCDS AT EOJ IF IT WAS OPENED.                    *
*                                                                     *
*    @121    - WAS ASSUMING AN 8-CHARACTER CATALOG NAME FOR THE TITLE *
*              LINE. OOPS!                                            *
*                                                                     *
*    15JAN88 - DEUTZ-ALLIS MODIFICATION TO PROVIDE THE ABILITY TO LIST*
*              ONLY THOSE ENTRIES THAT MATCH THE PARTIAL DATASET NAME *
*              GIVEN IN A JCL PARM.   IT MATCHES COLUMN FOR COLUMN TO *
*              THE DATASET NAME. TOTAL FIELDS ARE ADJUSTED.           *
*                                                                     *
*    13JAN88 - DEUTZ-ALLIS MODIFICATION TO PRINT OUT ALL THE VOLUME   *
*              CELLS FOR NONVSAM, DATA, INDEX AND GDGENT CELLS.   THE *
*              ORIGINAL VERSION IGNORED ALL BUT THE FIRST VOLUME CELL *
*              WHICH THEN PRINTED ONLY THE FIRST VOLUME ON THE LIST.  *
*                                                                     *
*    09DEC87 - DEUTZ-ALLIS MODIFICATION ADDED TO PRINT A "+" BEFORE   *
*              THE DATA SET TYPE FIELD ON GDG BASE RECORDS THAT       *
*              CURRENTLY HAVE NO GDG ENTRY RECORDS                    *
*                                                                     *
*    30NOV87 - DEUTZ-ALLIS MODIFICATION ADDED TO PRINT AN "*" BEFORE  *
*              THE DATA SET TYPE FIELD ON NON-VSAM DATASETS IF THE    *
*              DATASET IS CATALOGED BUT NO FOUND ON THE PACK TO WHICH *
*              THE CATALOG POINTS.                                    *
*                                                                     *
*    16DEC86 - DEUTZ-ALLIS MODIFICATION ADDED TO READ THE GDG AGING   *
*              (ICF CATALOG) RECORD AND PRINT THE MAXIMUM GDG'S,      *
*              SCRATCH/NOSCRATCH AND EMPTY/NOEMPTY GDG ATTRIBUTES.    *
*              MODIFICATION MADE BY J. RAUSCH.  A CHANGE WAS ALSO MADE*
*              TO HANDLE A 12 POSITION CATALOG NAME (I.E.             *
*              "ICAT.VPROCPK").                                       *
*                                                                     *
*    @120    - CHANGES FOR MVS/XA. USE SCAN ROUTINE INSTEAD OF UCB    *
*              HALF-WORD LOOKUP TABLE.                                *
*            - LENGTHEN PRINTLINE AREA USED FOR PRINTING TOTALS TO    *
*              CORRECT FORMATTING PROBLEM.                            *
*            - BREAK OUT SOME PARTS OF THE CODE INTO COPY MEMBERS TO  *
*              MAKE IT MORE EDITABLE.                                 *
*            - AN RPL WAS NOT BEING CREATED PRIOR TO I/O IN THE       *
*              HEX-PRINT PART OF THE LOGIC.                           *
*            - ADD CELL TYPE COUNTING TO HEX LOGIC.                   *
*                                                                     *
*    24APR25 - BUGS FOUND AFTER AUTHOR'S MOVE TO MANULIFE.            *
*            . 3380 MISSING FROM DEVICE TYPE TABLE.                   *
*            . DONT BE SO SURE I KNOW HOW MANY TRACKS THERE ARE IN A  *
*              CYLINDER. AT CBOC I HAD ONLY 3375'S.                   *
***********************************************************************
./       ADD   NAME=$EPILOG
         MACRO
&LABEL   $EPILOG &RC
&LABEL   LR    R1,R13              GET SAVEAREA ADDRESS
         L     R13,4(R13)          GET BACK CHAIN POINTER
         L     R0,16(R13)          GET SAVEAREA LENGTH
         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)
         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA
         LM    R14,R12,12(R13)     RESTORE CALLERS REGS
         AIF   (T'&RC EQ 'O').SPEC
         LA    R15,&RC             SET RETURN CODE
.SPEC    ANOP
         L     R15,16(R13)         RESTORE RETURN CODE
         BR    R14                 RETURN TO CALLER
         MEND
./       ADD   NAME=$IN
         MACRO
&LABEL   $IN   &REG1=R14,&REG2=R15,&DEPTH=DEPTH,                       X
               &ENTRIES=ENTRIES,&EXITS=EXITS,&LREG=R9
         AIF   (T'&LABEL EQ 'O').ERR1   MUST HAVE A LABEL
&LABEL   DS    0H
         LA    &REG1,&LABEL             GET SUBROUTINE ENTRY ADDR
         L     &REG2,&DEPTH             GET CURRENT NESTING DEPTH
         ST    &REG1,&ENTRIES.(&REG2)   SAVE ENTRY ADDR IN ENTRY TABLE
         ST    &LREG,&EXITS.(&REG2)     SAVE RETURN ADDR
         LA    &REG2,4(0,&REG2)         UPDATE NESTING FOR NEXT CALL
         ST    &REG2,&DEPTH              AND SAVE IT...
         AGO   .MEND
.ERR1    MNOTE 8,'$IN MUST BE LABELLED'
.MEND    MEND
./       ADD   NAME=$JCL
//LANEJ     JOB LANEJ,TECHSUPPORT,
//*            USER=IBMUSER,
//         NOTIFY=LANEJ,
//         REGION=6M,
//             MSGLEVEL=(1,1),MSGCLASS=X,
//             CLASS=Z
//*JOBLIB DD DSN=LANE.TECTSG.LOAD,DISP=SHR
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//*   THIS JCL IS IN:        LANEJ.TECTSG.LISTICAT($JCL)
//* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
//LCAT    EXEC PGM=LISTICAT,REGION=4M PARM=APMP
//STEPLIB DD DSN=SYS1.LINKLIB,DISP=SHR
//STEPCAT DD DSN=UCAT.TSO,DISP=SHR                              TSG
//SYSUT1  DD DSN=UCAT.TSO,DISP=SHR
//SYSUT2   DD DUMMY
//SYSUDUMP DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//SYSLIST  DD SYSOUT=*
//ABNLDUMP DD DUMMY
//SYSIN    DD DUMMY
./       ADD   NAME=$MESSAGE
         MACRO
&LAB    $MESSAGE &MSGNO,&SKIP=0,&DATA=
         AIF   (T'&DATA EQ 'O').NODATA
         LA    R2,&DATA
.NODATA  ANOP
         LM    R15,R1,=A(MESGRTN,&SKIP,&MSGNO)
         BALR  R14,R15
         MEND
./       ADD   NAME=$MLI
//JIMLANE  JOB (,MDOA00-0000),LANE,NOTIFY=JIMLANE,MSGCLASS=A,
//         CLASS=X
/*JOBPARM T=1,L=99,R=N0GA
/*ROUTE  PRINT NTG
//LCAT    EXEC PGM=LISTICAT PARM='DUMP'
//STEPLIB  DD DSN=JIMLANE.SYSTEMS.LOAD,DISP=SHR
//STEPCAT  DD DSN=TICFCATA,DISP=SHR
//SYSUT1   DD DSN=TICFCATA,DISP=SHR
//SYSUT2   DD DSN=HSM.MCDS,DISP=SHR
//SYSUDUMP DD SYSOUT=*
//SYSLIST  DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//ABNLDUMP DD DUMMY
./       ADD   NAME=$OBJ
 SETCODE AC(1)
ESD      
ESD      
ESD      
ESD      
ESD      
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
TXT 
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
RLD      
END 
./       ADD   NAME=$OUT
         MACRO
&LABEL   $OUT  &REG1=R14,&DEPTH=DEPTH,                                 X
               &EXITS=EXITS,&LREG=R9
&LABEL   DS    0H
         L     &REG1,&DEPTH             GET CURRENT NESTING DEPTH
         S     &REG1,=F'4'              BACKUP TO OUR CALLER
         ST    &REG1,&DEPTH             AND SAVE NEW DEPTH
         L     &LREG,&EXITS.(&REG1)     PICK UP OUR RETURN ADDR
         BR    &LREG                    AND GO THERE.
         MEND
./       ADD   NAME=$PROLOG
         MACRO
&LABEL   $PROLOG &LV=0
.**********************************************************************
.*
.*       THIS MACRO WILL PROVIDE ENTRY LINKAGE AND OPTIONALLY
.*       MULTIPLE BASE REGISTERS.  ALSO, VIA THE 'LV=' KEYWORD
.*       PROVIDE ADDITIONAL USER STORAGE (APPENDED TO THE
.*       SAVE AREA) ADDRESSABLE FROM REG 13.  IF NO OPERANDS
.*       ARE CODED, REG 12 IS ASSUMED THE BASE. EXAMPLE:
.*              SECTNAME $PROLOG          = STANDARD REG 12 BASE
.*              SECTNAME $PROLOG 5        = STANDARD, REG 5 BASE
.*              SECTNAME $PROLOG 10,LV=20 = ADD 20 BYTES TO SAVE AREA
.*                                             REG 10 IS BASE
.*              SECTNAME $PROLOG R10,R11  = REGS 10 AND 11 ARE BASES
.*
.**********************************************************************
         LCLA  &AA,&AB,&AC
         GBLB  &PRORG
&AC      SETA  4096
&LABEL   CSECT
         B     32(R15)             BRANCH AROUND
         DC    AL1(26)
         DC    CL8'&LABEL'         CSECT NAME
         DC    C'-'
         DC    CL8'&SYSDATE'       COMPILE DATE
         DC    C'-'
         DC    CL8'&SYSTIME'       COMPILE TIME
         CNOP  0,4                 ALIGNMENT
         STM   R14,R12,12(R13)     SAVE REGISTERS
         LR    R12,R15             LOAD BASE REG
         USING &LABEL,R12          INFORM ASSEMBLER
         AIF   (&LV GT 4023).MERR
         LA    R0,&LV+72           LOAD REG 0 WITH LENGTH VARIABLE
         GETMAIN R,LV=(0)          GET CORE FOR SAVEAREA AND USER
         AIF   (&LV+72 LE 256).XC2
         AIF   (&LV+72 LE 512).XC1
         MVI   0(R1),X'00'         MOVE X'00' TO FIRST BYTE
         LR    R2,R1               SAVE POINTER IN EVEN REG
         LA    R4,1(R1)            SET RECEIVING POINTER
         LR    R5,R0               SET RECEIVING LENGTH
         BCTR  R5,R0               DECREMENT LENGTH
         LA    R5,0(R5)            CLEAR HIGH ORDER BYTE
         LA    R3,1                SET SENDING LENGTH
         MVCL  R4,R2               INSTRUCTION PADS WITH X'00'
         AGO   .STORE
.XC1     ANOP
         XC    256(&LV-184,R1),256(R1)  CLEAR SAVE AREA
         XC    0(256,R1),0(R1)          CLEAR SAVE AREA
         AGO   .STORE
.XC2     ANOP
         XC    0(&LV+72,R1),0(R1)       CLEAR SAVE AREA
.STORE   ANOP
         ST    R13,4(R1)           SAVE BACK CHAIN
         ST    R1,8(R13)           SET FORWARD CHAIN
         LR    R11,R1              SAVE NEW SAVEAREA ADDRESS
         L     R15,16(R13)         RESTORE REG 15
         ST    R0,16(R13)          SAVE SAVEAREA LENGTH
         LM    R0,R1,20(R13)       RESTORE REGS USED IN GETMAIN
         LR    R13,R11             SET SAVEAREA POINTER
         AIF   (N'&SYSLIST EQ 0).MEND
         AIF   ('&SYSLIST(1)' EQ 'R12').SKIPIT
         AIF   ('&SYSLIST(1)' EQ '12').SKIPIT
         LA    &SYSLIST(1),&LABEL  LOAD REQUESTED BASE REG
         DROP  R12                 DROP ASSUMED BASE REG
         USING &LABEL,&SYSLIST(1)  INFORM ASSEMBLER
.SKIPIT  ANOP
&AA      SETA  2
.LOOP    ANOP
         AIF   (&AA GT N'&SYSLIST).MEXIT
&AB      SETA  &AA-1
         LA    &SYSLIST(&AA),2048(&SYSLIST(&AB))  LOAD NEXT BASE REG
         LA    &SYSLIST(&AA),2048(&SYSLIST(&AA))  LOAD NEXT BASE REG
         USING &LABEL+&AC,&SYSLIST(&AA) INFORM ASSEMBLER
&AC      SETA  &AC+4096
&AA      SETA  &AA+1
         AGO   .LOOP
.MEXIT   ANOP
         AIF   (&PRORG).MEX2
         SPACE
         $REGS
         SPACE
.MEX2    ANOP
&AA      SETA  &LV+72
         MNOTE *,'TOTAL STORAGE AREA RECEIVED = &AA'
         MEXIT
.MEND    ANOP
         MNOTE *,'NO REGISTER SPECIFIED - R12 ASSUMED'
         AGO   .MEXIT
.MERR    ANOP
         MNOTE 12,'LV > 4023 - REQUEST IGNORED'
         AGO   .MEXIT
         MEND
./       ADD   NAME=$REGS
         MACRO
         $REGS
         GBLB  &PRORG
         AIF   (&PRORG).MEX2
&PRORG   SETB  1
 SPACE
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
 SPACE
REG0     EQU   0
REG1     EQU   1
REG2     EQU   2
REG3     EQU   3
REG4     EQU   4
REG5     EQU   5
REG6     EQU   6
REG7     EQU   7
REG8     EQU   8
REG9     EQU   9
REG10    EQU   10
REG11    EQU   11
REG12    EQU   12
REG13    EQU   13
REG14    EQU   14
REG15    EQU   15
 SPACE
.MEX2    ANOP
       MEND
./       ADD   NAME=$SUN
//TSGJCL   JOB T50000,LANE,NOTIFY=TSGJCL,MSGCLASS=X
//LCAT EXEC PGM=LISTICAT,REGION=6M
//STEPCAT DD DSN=UCAT.ICF.PROD,DISP=SHR                         TSG
//SYSUT1  DD DSN=UCAT.ICF.PROD,DISP=SHR
//SYSUT2  DD DUMMY
//SYSUDUMP DD SYSOUT=*
//SYSPRINT DD SYSOUT=*
//SYSLIST  DD SYSOUT=*
//ABNLDUMP DD DUMMY
//SYSIN    DD *
/*
./       ADD   NAME=$TEST
         MACRO
         $TEST   &FLAG,&MASK,&TABLE,&COMPRND,&LENGTH,                  X
               &FOUND,&NOTFND,&REGS
&R1      SETC  'R1'
&R2      SETC  'R14'
&R3      SETC  'R7'
&R4      SETC  'R8'
&R5      SETC  'R9'
         AIF   (T'&REGS EQ 'O').NOREGS
         AIF   (N'&REGS EQ 5).SETREGS
         MNOTE 12,'5 REGISTERS MUST BE SPECIFIED.'
         MEXIT
.SETREGS ANOP
&R1      SETC  '&REGS(1)'
&R2      SETC  '&REGS(2)'
&R3      SETC  '&REGS(3)'
&R4      SETC  '&REGS(4)'
&R5      SETC  '&REGS(5)'
.NOREGS  ANOP
&EXIT    SETC  'DEC'.'&SYSNDX'
&AGAIN   SETC  'REP'.'&SYSNDX'
&SCAN    SETC  'SCN'.'&SYSNDX'
         TM    &FLAG,&MASK
         BZ    &EXIT
         AIF   (N'&COMPRND GT 1).NOTFIRST
         LA    &R1,&TABLE
&AGAIN   SR    &R2,&R2
         IC    &R2,0(0,&R1)
         BCTR  &R2,0
         B     *+10
         CLC   1(0,&R1),&COMPRND
         EX    &R2,*-6
         AIF   ('&FOUND'(1,1) EQ '(').OUTREG
         BE    &FOUND
         AGO   .OUTEND
.OUTREG  ANOP
&ER      SETC  '&FOUND(1)'
         BER   &ER
.OUTEND  ANOP
         LA    &R1,&LENGTH.(0,&R1)
         CLI   0(&R1),255
         BNE   &AGAIN
         AIF   ('&NOTFND'(1,1) EQ '(').NOTREG
         B     &NOTFND
         AGO   .NOTEND
.NOTREG  ANOP
&NR      SETC  '&NOTFND(1)'
         BR    &NR
.NOTEND  ANOP
         AGO   .ENDTEST
.NOTFIRST ANOP
         AIF   (T'&COMPRND(2) EQ 'O').LAST
         LA    &R1,&TABLE
&AGAIN   LA    &R3,&COMPRND(1)
         LA    &R4,1
         LA    &R5,&COMPRND(1)
         LA    &R5,&COMPRND(3).(0,&R5)
         SR    &R2,&R2
         IC    &R2,0(0,&R1)
         SR    &R5,&R2
         BCTR  &R2,0
         B     *+10
         CLC   1(0,&R1),0(&R3)
&SCAN    EX    &R2,*-6
         AIF   ('&FOUND'(1,1) EQ '(').FOUTREG
         BE    &FOUND
         AGO   .FOUTEND
.FOUTREG ANOP
&ER      SETC  '&FOUND(1)'
         BER   &ER
.FOUTEND ANOP
         BXLE  &R3,&R4,&SCAN
         LA    &R1,&LENGTH.(0,&R1)
         CLI   0(&R1),255
         BNE   &AGAIN
         AIF   ('&NOTFND'(1,1) EQ '(').FNOTREG
         B     &NOTFND
         AGO   .FNOTEND
.FNOTREG ANOP
&NR      SETC  '&NOTFND(1)'
         BR    &NR
.FNOTEND ANOP
         AGO   .ENDTEST
.LAST    ANOP
         LA    &R1,&TABLE
&AGAIN   LA    &R3,&COMPRND(1)
         LA    &R4,1
         LA    &R5,&COMPRND(1)
         LA    &R5,&COMPRND(3).(0,&R5)
         CLI   0(&R3),X'41'
         BL    *+8
         BXLE  &R3,&R4,*-8
         SR    &R2,&R2
         IC    &R2,0(,&R1)
         SR    &R3,&R2
         BCTR  &R2,0
         B     *+10
         CLC   1(0,&R1),0(&R3)
&SCAN    EX    &R2,*-6
         AIF   ('&FOUND'(1,1) EQ '(').LOUTREG
         BE    &FOUND
         AGO   .LOUTEND
.LOUTREG ANOP
&ER      SETC  '&FOUND(1)'
         BER   &ER
.LOUTEND ANOP
         LA    &R1,9(,&R1)
         CLI   0(&R1),255
         BNE   &AGAIN
         AIF   ('&NOTFND'(1,1) EQ '(').LNOTREG
         B     &NOTFND
         AGO   .LNOTEND
.LNOTREG ANOP
&NR      SETC  '&NOTFND(1)'
         BR    &NR
.LNOTEND ANOP
.ENDTEST ANOP
&EXIT    DS    0H
         MEND
./       ADD   NAME=ALLOC
         MACRO
&NAME    ALLOC &DUMMY,&PERM,&DSN=,&DDN=,&DDNRET=,&MEMBER=,&DISP=,      X
               &TERM=,                                       CBOC      X
               &VOL=,&UNIT=,&SYSOUT=,&FREE=,&COPIES=,&LABEL=,          X
               &BLKSIZE=,&DEN=,&DSORG=,&KEYLEN=,&LRECL=,&RECFM=,       X
               &PASWORD=,&DSNRET=,&MF=AUTO,&PREFIX=,&ERROR=,           X
               &SPACE=,&F=,&FILE=,&DA=,&QNAME=,&DSORGRT=,              X
               &VOLRET=,&DCBDSN=,&DCBDDN=,&SPECIAL=,&DDNTO=,           X
               &FORMS=,&DEST=,&SSREQ=,&FORUSER=,&TU=,&DSNPDE=
.**********************************************************************
.*                                                                    *
.*    THIS MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION BY BUILDING   *
.*    A DYNAMIC ALLOCATION PARAMETER LIST AND INVOKING SVC 99.        *
.*    IT FIRST SETS UP A WORKAREA ENVIRONMENT FOR THE PARAMETER LIST  *
.*    AND THEN TESTS THE KEYWORDS SUPPLIED AND INVOKES INNER MACROS   *
.*    TO BUILD THE TEXT UNITS. THE INNER MACROS THEMSELVES USE INNER  *
.*    MACROS TO UPDATE GLOBAL VARIABLES, STORE TEXT UNIT POINTERS ETC *
.*    THERE ARE THREE WAYS OF SPECIFYING THE WORK AREA ADDRESS.       *
.*    A) MF=AUTO, MF=G, MF=(E,ADDRESS,LNTHSYMB).                      *
.*    IN THE FIRST FORM, AN INNER MACRO DYNSPACE IS CALLED TO NAME    *
.*    A WORK AREA, THE NAME BEING RETURNED IN THE GLOBAL SETC         *
.*    VARIABLE &DYNSP. A DSECT IS CREATED TO MAP THIS AREA.           *
.*    THE GLOBAL VARIABLES &DTUO (TEXT UNIT OFFSET COUNTER) AND       *
.*    &DTUPO (TEXT UNIT POINTER OFFSET ACCUMULATOR) ARE SET TO ZERO.  *
.*    THESE ACCUMULATORS ARE UPDATED AS EACH TEXT UNIT PROCESSOR      *
.*    AQUIRES STORAGE. AFTER ALL TEXT UNITS HAVE BEEN BUILT, THE      *
.*    AMOUNT OF SPACE USED IS CALCULATED, AND THE DYNSPACE MACRO IS   *
.*    THEN CALLED AGAIN TO LOG THE AMOUNT NEEDED. DYNSPACE SETS A     *
.*    GLOBAL VARIABLE &DYNSPQ TO THE HIGHEST AMOUNT ANY ALLOC OR      *
.*    FREE MACRO REQUESTED, AND WHEN CALLED WITH THE EXPAND OPTION,   *
.*    (NO OPERANDS OR NAME FIELD SUPPLIED), EXPANDS INTO A DS FOR     *
.*    THAT QUANTITY. (SEE DYNSPACE)                                   *
.*    MF=G SPECIFIES THAT THE ALLOC MACRO ENTER THE BEGIN MACRO       *
.*    WORKAREA TO ACQUIRE THE STORAGE NECESSARY. IT DOES THIS VIA     *
.*    THE RCPDS MACRO. (SEE RCPDS). HOWEVER, IF THE ALLOC MACRO IS    *
.*    CALLED SEVERAL TIMES WITH THIS OPTION, A LOT OF STORAGE WILL BE *
.*    USED UP, AS THE STORAGE WILL NOT BE SHARED. THUS, THIS FORM     *
.*    SHOULD ONLY BE USED IF THE ALLOC/FREE MACRO IS ONLY TO BE USED  *
.*    ONCE OR TWICE DURING AN ASSEMBLY.                               *
.*    MF=E CAUSES THE MACRO TO USE A USER SPECIFIED WORK AREA. THE    *
.*    SECOND PARAMETER GIVES THE NAME OF THE WORKAREA, AND AN         *
.*    OPTIONAL THIRD PARAMETER IS THE NAME OF A SYMBOL TO BE EQUATED  *
.*    TO THE LENGTH OF THE REQUIRED WORK AREA.                        *
.*                                                                    *
.*    DYNAMIC ALLOCATION FUNCTIONS ARE SIMILAR TO THOSE AVAILABLE    *
.*    WITH JCL, USING THE SAME KEYWORDS. HOWEVER, CERTAIN FORMATS    *
.*    ARE SLIGHTLY DIFFERENT. FOR INSTANCE, CERTAIN KEYWORDS CAN     *
.*    HAVE VARYING PARAMETERS, EG DATASET NAME, DDNAME, VOLSER ETC.  *
.*    PROVISION IS MADE FOR BOTH VARIABLE SPECIFICATION.             *
.*    IN THE ABSOLUTE FORM, THE PARAMETER IS ENTERED IN QUOTES,      *
.*    E.G.   ALLOC DSN='SYS1.LINKLIB',DISP=SHR                       *
.*    HOWEVER, THIS NAME REMAINS FIXED FOR THE ASSEMBLY.             *
.*    IN THE VARIABLE FORMAT, THE ADDRESS OF A LOCATOR IS SPECIFIED, *
.*    WHERE THE LOCATOR CONSISTS OF A SIX BYTE FIELD, THE FIRST 4    *
.*    BYTES OF WHICH POINT TO THE PARAMETER, WHILE THE NEXT TWO      *
.*    CONTAIN THE LENGTH.                                            *
.*    EG          ALLOC DSN=LOCATOR                                  *
.*       LOCATOR  DC    A(DSN),Y(12)                                 *
.*       DSN      DC    C'SYS1.LINKLIB'                              *
.*                                                                   *
.*       NUMERIC QUANTITIES E.G. COPIES= FOR SYSOUT, SHOULD EITHER   *
.*       SPECIFY A NUMERIC VALUE, COPIES=3,                          *
.*       A VALUE IN A REGISTER, COPIES=(R3),                         *
.*       OR THE NAME OFF A FULLWORD CONTAINING THE VALUE,            *
.*          COPIES=NUMCOPYS, WHERE NUMCOPYS IS THE NAME OF A         *
.*       FULLWORD FIELD.                                             *
.*                                                                   *
.*       OTHER KEYWORDS SUCH AS DISP= CAN ONLY HAVE THE ABSOLUTE     *
.*       FORM, AND VALUES SHOULD NOT BE ENTERED WITHIN QUOTES.       *
.*       ADDITIONAL FACILITIES NOT AVAILABLE WITH JCL ARE THE        *
.*       RETURN BY THE SYSTEM OF INFORMATION ON THE DATASET, EG      *
.*       DSORG. THIS IS DONE BY SPECIFYING DSORGRT=SYMBOL, WHERE     *
.*       SYMBOL IS A SYMBOL WHICH WILL BE EQUATED TO A TWO BYTE      *
.*       FIELD CONTAINING THE DSORG TYPE (SEE JOB MANAGEMENT,        *
.*       SUPERVISOR AND TSO).                                        *
.*       THE SYSTEM CAN ALSO GENERATE AND RETURN A DDNAME. THIS IS   *
.*       CARRIED OUT BY ENTERING DDNTO=(ADDR1,ADDR2,,...)            *
.*       WHERE ADDR1,ADDR2 ETC ARE THE NAMES OF 8 BYTE FIELDS WHICH  *
.*       ARE TO RECEIVE THE DDNAME.                                  *
.*       FOR FURTHER INFORMATION ON DYNAMIC ALLOCATION, SEE          *
.*       JOB MANAGEMENT, SUPERVISOR AND TSO.                         *
.*                                                                   *
.**********************************************************************
         GBLA  &RCPDYN            COUNTER FOR NO ENTRIES TO MACRO
         GBLA  &DTUO              OFFSET TO TEXT UNITS
         GBLA  &DTUPO             OFFSET TO TEXT UNIT POINTERS
         GBLB  &RCPS99(2)         TELL RCPDSECT NEED DSECTS
         GBLC  &DYNP              PREFIX FOR LABELS FOR THIS CALL
         GBLC  &DYNSP         NAME FOR AUTOMATIC STORAGE ALLOC
         LCLA  &DDNRTO,&DSNRTO         FOR EQUATES FOR RETURNED FLDS
         LCLA  &VOLRTO,&DSRGRTO        FOR EQUATES FOR RETURNED FIELDS
         LCLA  &I                 COUNTER
         LCLB  &DSECT             DSECT NEEDED FOR STORAGE, MF=E
         LCLC  &C,&T,&PAR
.*
.*   THE ALLOC MACRO PROVIDES A DYNAMIC ALLOCATION FUNCTION,
&RCPS99(1)     SETB           1
&RCPDYN  SETA  &RCPDYN+1          INCEREMENT COUNTER
&DYNP    SETC  'DYN&RCPDYN' SET DEFAULT PREFIX
&NAME    DS    0H
         AIF   ('&PREFIX' EQ '').TMF
         AIF   (K'&PREFIX LT 4).POK
         MNOTE 4,'PREFIX TOO LONG, 1ST 4 CHARS USED'
&DYNP    SETC  '&PREFIX'(1,4)
         AGO   .TMF
.POK     ANOP
&DYNP    SETC  '&PREFIX'
.TMF     AIF   ('&MF(1)' EQ 'G').GEN
         AIF   ('&MF' NE 'AUTO').TMFE
NAME     DYNSPACE             GET NAME FOR SPACE
         LA    R1,&DYNSP               LOAD ADDRESS OF PARAM LIST
         USING &DYNP.DS,R1             USE GENERATED DSECT
&T       SETC  'A'
&PAR     SETC  '&DYNSP+4'
&DSECT   SETB  1
         AGO   .START
.TMFE    AIF   ('&MF(2)' NE '').E2OK
         MNOTE 4,'PLIST ADDRESS OMITTED, MF=G USED'
         AGO   .GEN
.E2OK    ANOP
&DSECT   SETB  1
         AIF   ('&MF(2)' EQ '(').RMFE
         LA    R1,&MF(2)               LOAD PARAM LIST ADDRESS
         USING &DYNP.DS,R1             USE GENERATED DSECT
         AGO   .START
.RMFE    AIF   ('&MF(2)' EQ '(R1)' OR '&MF(2)' EQ '(1)').START
         LR    R1,&PAR                 LOAD S99 PARAM LIST ADDRESS
         AGO   .START
.GEN     LA    R1,&DYNP.RBP            LOAD ADDRESS OF S99 RBP
.START   LA    R15,&DYNP.RB            LOAD ADDRESS OF S99 RB
         USING S99RB,R15
         ST    R15,0(R1)               AND STORE IN RB POINTER
         XC    4(&DYNP.LEN-4,R1),4(R1) ZERO PARAMETER LIST
         MVI   S99RBLN,20              MOVE IN LIST LENGTH
         MVI   S99VERB,S99VRBAL        MOVE IN VERB CODE
         LA    R14,&DYNP.TUP           LOAD ADDRESS OF TU POINTERS
         ST    R14,S99TXTPP            STORE ADDRESS IN S99 RB
         LA    R15,&DYNP.TU            POINT TO SPACE FOR TEXT UNITS
         USING S99TUNIT,R15
&DTUO    SETA  0
&DTUPO   SETA  0
         AIF   ('&SSREQ' EQ 'YES').SSREQ
.TDSN    AIF   ('&DSN&DA' NE '').DSN
         AIF   ('&DSNPDE' NE '').DSNPDE
         AIF   ('&DSNRET' NE '').DSNRT
         AIF   ('&TERM' NE '').TERM             CBOC......
         AIF   ('&SYSOUT' NE '').SYSOUT
         AIF   ('&DUMMY' NE '').DUMMY
         AIF   ('&QNAME' NE '').QNAME
.TDDN    AIF   ('&DDN&FILE&F' NE '').DDN
         AIF   ('&DDNRET&DDNTO' NE '').DDNRT
.TUNIT   AIF   ('&UNIT&VOL' NE '').UNIT
.TVOLRET AIF   ('&VOLRET' NE '').VOLRET
.TDSRGO  AIF   ('&DSORGRT' NE '').DSORGRT
.TLABEL  AIF   ('&LABEL' NE '').LABEL
.TPSWD   AIF   ('&PASWORD' NE '').PASWORD
.TFORUSE AIF   ('&FORUSER' NE '').FORUSER
.TTU     AIF   ('&TU' NE '').TU
.TDISP   AIF   ('&DISP' NE '').DISP
.TSPACE  AIF   ('&SPACE' NE '').SPACE
.TLRECL  AIF   ('&LRECL' NE '').DCB
         AIF   ('&DEN' NE '').DCB
         AIF   ('&RECFM' NE '').DCB
         AIF   ('&BLKSIZE' NE '').DCB
         AIF   ('&DSORG' NE '').DCB
         AIF   ('&KEYLEN' NE '').DCB
.TDCBDSN AIF   ('&DCBDSN' NE '').DCBDSN
.TDCBDDN AIF   ('&DCBDDN' NE '').DCBDDN
.TFREE   AIF   ('&FREE' EQ 'CLOSE').FREE                         TE7343
.TPERM   AIF   ('&PERM' EQ 'PERM' OR '&PERM' EQ 'PERMANENT').PERM
         AIF   ('&DUMMY' EQ 'PERM' OR '&DUMMY' EQ 'PERMANENT').PERM
.TSPECI  AIF   ('&SPECIAL' NE '').SPECIAL
         AGO   .SVC99
.SSREQ   RCPSSREQ
         AGO   .TDSN
.DSN     RCPDSN &DSN&DA,&MEMBER
         AGO   .TDDN
.DSNPDE  RCPDSNPD &DSNPDE
         AGO   .TDDN
.DSNRT   RCPDSNRT &DSNRET
&DSNRTO  SETA  &DTUO-46
         AGO   .TDDN
.SYSOUT  RCPSYSOU &SYSOUT,COPIES=&COPIES,FREE=&FREE,DEST=&DEST,        X
               FORMS=&FORMS
         AGO   .TDDN
.TERM    RCPTERM &TERM           CBOC....
         AGO   .TDDN             CBOC..
.DUMMY   RCPDUMMY &DUMMY
         AGO   .TDDN
.QNAME   RCPQNAME &QNAME
         AGO   .TDDN
.DDN     RCPDDN &DDN&F&FILE
         AGO   .TUNIT
.DDNRT   RCPDDNRT &DDNRET
&DDNRTO  SETA  &DTUO-10
         AGO   .TUNIT
.UNIT   RCPUNIT &UNIT,&VOL
         AGO   .TVOLRET
.VOLRET  RCPVOLRT &VOLRET
&VOLRTO  SETA  &DTUO-8
         AGO   .TDSRGO
.DSORGRT RCPDSRGR
&DSRGRTO SETA  &DTUO-2
         AGO   .TLABEL
.LABEL   RCPLABEL &LABEL
         AGO   .TPSWD
.PASWORD RCPPSWD &PASWORD
         AGO   .TFORUSE
.FORUSER RCPFORUS &FORUSER
         AGO   .TTU
.TU      RCPTU &TU
         AGO   .TDISP
.DISP    RCPDISP &DISP
         AGO   .TSPACE
.SPACE   RCPSPACE &SPACE
         AGO   .TLRECL
.DCB     RCPDDCB LRECL=&LRECL,DEN=&DEN,RECFM=&RECFM,BLKSIZE=&BLKSIZE,  X
               DSORG=&DSORG,KEYLEN=&KEYLEN
         AGO .TDCBDSN
.DCBDSN  RCPDCBDS &DCBDSN
         AGO .TDCBDDN
.DCBDDN  RCPDCBDD &DCBDDN
         AGO .TFREE                                              TE7343
.FREE    RCPFREE  &FREE                                          TE7343
         AGO   .TPERM
.PERM    RCPPERM
         AGO   .TSPECI
.SPECIAL RCPSPEC &SPECIAL
.SVC99   ANOP
&DTUPO   SETA  &DTUPO-4
         SPACE
         MVI   &DYNP.TUP+&DTUPO,X'80'  SET HIGH ORDER BIT ON TEXT PTRS
         MVI   &DYNP.RBP,X'80'         SET HIGH ORDER BIT ON RB PTR
         RCPSR2 UNSAVE
&DTUPO   SETA  &DTUPO+4
         AIF   (NOT &DSECT).DYNA
         DROP  R1,R15                  DEACTIVATE ADDRESSABILITY
         LA    R14,4(R1)               POINT TO REQUEST BLOCK
.DYNA    DYNALLOC
         AIF   (NOT &DSECT).LTR
         USING &DYNP.RB,R14            SET UP ADDRESSABILITY
**       NOTE  R14 HAS RB ADDRESS, R15 HAS SVC 99 RETURN CODE        **
.LTR     AIF   ('&ERROR' EQ '').TDDTO
         LTR   R15,R15                 TEST RETURN CODE
         BNZ   &ERROR                  BRANCH IF NON ZERO
.TDDTO   AIF   ('&DDNTO' EQ '').RESERVE
&I       SETA  0
.DDNTOL  ANOP
&I       SETA  &I+1
         AIF   ('&DDNTO(&I)' EQ '').RESERVE
         AIF   ('&DDNTO(&I)'(1,1) EQ '(').DDNTOR
         MVC   &DDNTO(&I).(8),&DYNP.TU+&DDNRTO+2
         AGO   .DDNTOL
.DDNTOR  ANOP
&C       SETC  '&DDNTO(&I)'(2,K'&DDNTO(&I)-2)
         MVC   0(8,&C),&DYNP.TU+&DDNRTO+2
         AGO   .DDNTOL
.RESERVE AIF   (&DSECT).RESDS
         SPACE 1
***********************************************************************
**       RESERVE SPACE FOR DYNALLOC PARAMETER LIST                   **
***********************************************************************
         RCPDS
.SSP     ANOP
&DYNP.RBP DS   F                       SVC 99 REQ BLOCK POINTER
&DYNP.RB  DS   5F                      SVC 99 REQUEST BLOCK
&DYNP.TUP DS   CL&DTUPO                SPACE FOR TEXT POINTERS
         AIF   (&DTUO EQ 0).DTU21
&DYNP.TU  DS   CL&DTUO                 SPACE FOR TEXT UNITS
         AIF   (&DSNRTO EQ 0).TDDNRTO
&DSNRET  EQU   &DYNP.TU+&DSNRTO        OFFSET TO RETURNED DSN
.TDDNRTO AIF   ('&DDNRET' EQ '').DTU11
&DDNRET  EQU   &DYNP.TU+&DDNRTO        OFFSET TO RETURNED DDNAME
.DTU11   AIF   (&VOLRTO EQ 0).DTU12
&VOLRET  EQU   &DYNP.TU+&VOLRTO        OFFSET TO RETURNED VOLSER
.DTU12   AIF   (&DSRGRTO EQ 0).DTU10
&DSORGRT EQU   &DYNP.TU+&DSRGRTO       OFFSET TO RETURNED DSORG
         AGO   .DTU10
.DTU21   ANOP
&DYNP.TU  DS   0C                      NO SPACE NEEDED FOR TEXT UNITS
.DTU10   ANOP
&DYNP.LEN EQU  *-&DYNP.RBP             LENGTH OF SPACE USED
         AIF   (&DSECT).DSP
         RCPDS
         SPACE 3
         AGO   .EXIT
.RESDS   ANOP
         AIF   ('&DYNSP' EQ '').SP3
         DYNSPACE ADD
.SP3     SPACE
&DYNP.DS DSECT                         DSECT TO MAP SVC 99 DATA
         AGO   .SSP
.DSP     AIF   ('&MF(3)' EQ '').END1
&MF(3)   EQU   &DYNP.LEN               LENGTH OF AREA
.END1    ANOP
&SYSECT  CSECT
         SPACE 3
.EXIT    MEND
./       ADD   NAME=ALLVVDS
         TITLE ' - ALLOCATE ALL ONLINE VVDS''S.'
* PASS THROUGH THE UCB LOOKUP TABLE. USING UCBVOLI DEVELOP A DSNAME OF
* SYS1.VVDS.VVOLSER. TRY TO DYNAMICALLY ALLOCATE IT. IF SUCCESSFUL
* GENERATE AN ACB AND AN RPL AND SAVE THEIR ADDRESSES. FINALLY OPEN
* THE VVDS.
ALLVVDS  $PROLOG R12
         L     R4,=V(DATASECT)                                     @130
         USING DATASECT,R4                                         @130
         L     R0,=A(VVDSGETL)     LENGTH OF TABLE.                @131
         GETMAIN R,LV=(0)
         ST    R1,VVDSTAD          SAVE TABLE START ADDRESS
         LR    R5,R1               R5 AS BASE REG FOR VVDS TABLE.
         USING VVDSTAB,R5
         A     R1,=A(VVDSGETL)    ADD LENGTH OF TABLE              @131
         LA    R0,VVDSTLEN        PICK UP ENTRY LENGTH             @131
         SR    R1,R0              BACK UP 1 ENTRY                  @131
         ST    R1,VVDSTEND        SAVE LAST ENTRY ADDR.            @131
         SPACE ,
         L     R3,CVTPTR          GET CVT ADDRESS                  @120
         USING CVTMAP,R3          ADDRESS TO CVT                   @120
         XC    UCBWORK,UCBWORK    CLEAR WORK AREA                  @120
         LA    R1,UCBWORK         GET ADDRESS OF WORK AREA         @120
         ST    R1,PARMWA          STORE ADDR IN PARMLIST           @120
         LA    R1,DEVCLASS        ADDR OF DEVICE CLASS             @120
         ST    R1,PARMDEVT        STORE ADDR IN PARMLIST           @120
         MVI   DEVCLASS,UCB3DACC  SEARCH FOR DASD UCBS ONLY        @120
         LA    R1,ADDRUCB         ADDR OF RETURNED UCB             @120
         ST    R1,PARMUCB         STORE UCB IN PARMLIST            @120
         OI    PARMUCB,X'80'      END OF PARMLIST                  @120
         L     R1,CVTUCBSC        GET SCAN SERVICE ROUTINE         @120
         DROP  R3                                                  @120
         ST    R1,SCANSAVE        HOLD FOR LATER                   @120
UCBLOOP  LA    R1,PARMLIST        PUT ADDR INTO REG 1              @120
         L     R15,SCANSAVE       GET SCAN SERVICE RTN             @120
         BALR  R14,R15            GO TO SCAN SERVICE INTERFACE     @120
         LTR   R15,R15            WAS A UCB RETURNED?              @120
         BNZ   LASTUCB            NO.                              @120
         USING UCBOB,R2           ADDR TO UCB DSECT                @120
         L     R2,ADDRUCB         GET RETURNED UCB ADDR            @120
         TM    UCBSTAT,UCBONLI     IS IT ONLINE?                   @120
         BZ    UCBLOOP             NO, KEEP GOING                  @120
         B     ALLVVDS1            PROCESS DASD VOLUME.            @120
LASTUCB  B     ALLVVDS9                                            @120
         SPACE ,
ALLVVDS1 DS    0H
         MVI   VVDSFLG,C'O'        OSVTOC, BY DEFAULT.             @131
         CVAFTST UCB=(2)           IS IT IXVTOC?                   @131
         C     R15,=F'4'           LET'S SEE.                      @131
         BE    *+8                 NO INDEX.                       @131
         MVI   VVDSFLG,C'I'        IF INDEXED, REMEMBER FOR LATER  @131
         MVC   VVDSNAME,UCBVOLI    SET UP VOLSER IN DSNAME
         MVC   VVDDNAME,UCBVOLI    SET UP VOLSER IN DDNAME
         MVC   VVDSVOL,UCBVOLI     SAVE VOLSER IN TABLE.
         LA    R0,1                                                @AVV
         SVC   232                 AUTH ON.                        @AVV
         ALLOC DSN=LOCDSN,DISP=SHR,DDN=LOCDDN,ERROR=UCBLOOP
         GENCB BLK=ACB,                                                X
               AM=VSAM,                                                X
               BUFSP=32768,                                            X
               DDNAME=(*,VVDDN),                                       X
               MACRF=(ADR,SEQ)
         LTR   R15,R15             ACB GENERATED?
         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.
         STCM  R1,15,VVDSACB       STORE ACB ADDRESS
         GENCB BLK=RPL,                                                X
               AM=VSAM,                                                X
               ACB=(*,VVDSACB),                                        X
               AREA=(S,VVDSBUF),                                       X
               OPTCD=(ADR,SEQ,LOC),                                    X
               ARG=(S,VVDSARG)
         LTR   R15,R15             RPL GENERATED?
         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.
         STCM  R1,15,VVDSRPL       STORE RPL ADDRESS
         ICM   R8,15,VVDSACB       GET ACB ADDRESS
         OPEN  ((8))               OPEN VVDS
         LTR   R15,R15             DID IT OPEN?                    @122
         BZ    ALLVVDS2            YES.                            @122
         SR    R0,R0                                               @AVV
         SVC   232                                                 @AVV
        $MESSAGE 5,DATA=UCBVOLI                                    @122
         B     UCBLOOP             TRY NEXT VOLUME.                @122
ALLVVDS2 DS    0H                                                  @122
*        SR    R0,R0               AUTHORIZATION OFF.
*        SVC   232                 **** INSTALLATION DEPENDANT. ****
         LA    R5,VVDSTLEN(0,R5)   NEXT VVDSTAB ENTRY
         C     R5,VVDSTEND         AM I OFF THE DEEP END?          @131
         BNH   UCBLOOP             NO. TRY NEXT VOLUME.            @131
        $MESSAGE 9                 GIVE HIM THE BAD NEWS.          @131
         ABEND 256                 THEN CRASH AND BURN.            @131
ALLVVDS9 MVI   0(R5),255           SET END OF TABLE.
         $EPILOG ,                 ALL DONE.
         LTORG ,                                                   @130
./       ADD   NAME=DATASECT
         TITLE 'DATA AREAS'
DATASECT CSECT
         DS    0D
DTWORK   DC    D'0'                WORK FIELD FOR DATE CONVERSION
DTPARM   DC    AL4(0)
DTL5     EQU   DTWORK+3,5          5 BYTES FOR EDIT MACRO
DTL4     EQU   DTWORK+4,4          4 BYTES FOR EDIT MACRO
DTL3     EQU   DTWORK+5,3          3 BYTES FOR EDIT MACRO
DTL2     EQU   DTWORK+6,2          2 BYTES FOR EDIT MACRO
         DS    0F
BUFLEN   DC    AL4(1024*128)       128K RECORD BUFFER
OPENERR  DC    AL4(0)              OPEN ERROR CODE.
BUFPTR   DC    AL4(0)
RPLICAT  DC    AL4(0)              MOVE MODE RPL FOR BCS ACCESS.
ACBICAT  ACB   AM=VSAM,DDNAME=SYSUT1,EXLST=EXLICAT,                    X
               BUFNI=16,BUFND=16
EXLICAT  EXLST EODAD=EODICAT
PAGELEN  EQU   60
         DS    0F
MCDSPTR  DC    AL4(0)
MCDSKEY  DC    CL44' '
RPLMCDS  RPL   ACB=ACBMCDS,AM=VSAM,AREA=MCDSPTR,AREALEN=4,             X
               ARG=MCDSKEY,                                            X
               OPTCD=(KEY,DIR,LOC)
ACBMCDS  ACB   AM=VSAM,DDNAME=SYSUT2,BUFNI=16
MCDSOPEN DC    X'00'
         DS    0F
*
* THE FOLLOWING FIELDS ARE FILLED IN BY SUBROUTINES
*   VVDS: FOR VSAM OBJECTS
*   VTOC: FOR NONVSAM DATASETS
*
BLKSIZE  DC    F'0'
LRECL    DC    F'0'
TRACKS   DC    F'0'
         SPACE ,
FDBK     DC    CL4' '              RPL FEEDBACK CODE.              @122
         SPACE ,
CNTDATA  DC    PL4'0'              COUNT OF DATA CELLS READ.
CNTINDEX DC    PL4'0'              COUNT OF INDEX CELLS READ.
CNTNVSAM DC    PL4'0'              COUNT OF NVSAM CELLS READ.
CNTCLUST DC    PL4'0'              COUNT OF CLUSTER CELLS READ.
CNTGDGB  DC    PL4'0'              COUNT OF GDG BASE CELLS READ.
CNTGDGE  DC    PL4'0'              COUNT OF GDG ENTRY CELLS READ.
CNTPATH  DC    PL4'0'              COUNT OF PATH CELLS READ.
CNTAIX   DC    PL4'0'              COUNT OF ALTERNATE INDEX CELLS READ.
BCSGETS  DC    PL4'0'              GETS ISSUED AGAINST BCS.
VVDSGETS DC    PL4'0'              GETS ISSUED AGAINST VVDS'S.
CNTNF    DC    PL4'0'              NUMBER OF DATASETS NOT REALLY THERE.
CNTNOENT DC    PL4'0'              NUMBER OF GDGBASES WITH NO ENTRIES.
ONE      DC    PL1'1'
DSPFX    DC    CL44' '                                          15JAN88
DSPFXL   DC    F'0'                                             15JAN88
         SPACE ,
ENDVVD   DC    F'0'                BCS RECORD END ADDRESS
ENDBCS   DC    F'0'                BCS RECORD END ADDRESS
VVD0     DC    F'0'                PARAMETER AREA FOR FINDVVDS     @134
         SPACE ,
WORK     DC    D'0'
DWK1     EQU   WORK+7,1
DWK2     EQU   WORK+6,2
DWK3     EQU   WORK+5,3
DWK4     EQU   WORK+4,4
STARTTRK DC    F'0'
R2SAVE   DC    F'0'                SAVE R2 WHEN CHECKING FOR OPTIONAL
*                                  BCS CELLS
R6SAVE   DC    F'0'                SAVE R6 WHEN CHECKING FOR OPTIONAL
*                                  VVDS CELLS
R9SAVE   DC    F'0'                SAVE R9 WHEN HEXING VVDS DATA
SV1EXT1  DC    XL10'00'
SV1EXT2  DC    XL10'00'
SV1EXT3  DC    XL10'00'
SV3EXT4  DC    XL10'00'
SV3EXT5  DC    XL10'00'
SV3EXT6  DC    XL10'00'
SV3EXT7  DC    XL10'00'
SV3EXT8  DC    XL10'00'
SV3EXT9  DC    XL10'00'
SV3EXT10 DC    XL10'00'
SV3EXT11 DC    XL10'00'
SV3EXT12 DC    XL10'00'
SV3EXT13 DC    XL10'00'
SV3EXT14 DC    XL10'00'
SV3EXT15 DC    XL10'00'
SV3EXT16 DC    XL10'00'
         DS    0F
LOCDSN   DC    AL4(VVDSN),Y(17)
VVDSN    DC    C'SYS1.VVDS.V'
VVDSNAME DC    CL6' '
         DS    0F
LOCDDN   DC    AL4(VVDDN),Y(8)
VVDDN    DS    0CL8
         DC    C'V'
VVDDNAME DC    CL6' ',C' '
VVDSGETL EQU   256*VVDSTLEN        256 VVDS'S AT MOST              @131
VVDSTAD  DC    A(0)                ADDRESS OF VVDSTAB
VVDSTEND DC    A(0)                LAST ELEMENT IN VVDSTAB         @131
HIGHUCB  DC    Y(0)                HIGHEST UCB ADDR FOUND
RBASAVE  DC    F'0'                RBA ARG FOR VVDS GET
SHOWRBA1 DC    F'0'
SHOWRBA2 DC    F'0'
SVCOMPN  DC    CL44' '             BCS NAME. FOR COMPARE TO VVRCOMP
GDGSAVE  DC    CL44' '             GDG BASE NAME. SAVED TO DEVELOP
*                                    ENTRY NAMES FROM NAME CELLS
GDGWORK  DC    CL44' '             WORKAREA TO DEVELOP ENTRY NAME
GWORD    DC    D'0'
GWK3     EQU   GWORD+5,3
GWK2     EQU   GWORD+6,2
*
* THIS SWITCH IS USED TO DETECT THE FIRST BCS CELL READ IN. THE THEORY
* IS THAT THIS IS THE CLUSTER CELL FOR THE ICF CATALOG ITSELF. THE NAME
* OF THE FOLLOWING DATA CELL IS THE CATALOG NAME (AS IT WERE) AND
* IS INSERTED INTO THE HEADING FOR THE DELECTATION OF USERS WHO CAN'T
* REMEMBER WHAT CATALOG THEY WERE LISTING.
*
FIRST    DC    XL1'00'
* THIS SWITCH IS USED TO DETECT THE SITUATION OF A GDGBASE NOT BEING
* FOLLOWED BY ANY ENTRIES FOR THE GDG.
BASESW   DC    XL1'00'
* THIS SWITCH IS USED TO DETECT THE SITUATION OF A SECOND TO N-TH
* VOLUME CELL FOLLOWING A PREVIOUSLY READ VOLUME CELL.
VOLSW    DC    XL1'00'                                          13JAN88
* THIS SWITCH IS USED TO TELL IF THE PREFIX GIVEN BY THE PARM MATCHES
* THE DATASET OBJECT BEING PROCESSED.
         DS    0F
SAVECL   DC    AL4(0)              SAVE ADDR OF ICF CLUSTER CELL.
         SPACE ,
TRKCYL   DC    AL4(*-*)            TRACKS PER CYLINDER, CURRENT DS.
         SPACE ,
*
*
* DEVICE CODE NAME TABLE
*
DEVCDTBL DC    0H'0'
         DC    X'30008001',CL6'2400',Y(12)
         DC    X'3010200C',CL6'3375',Y(12)    CBOC  18JAN84
         DC    X'3010200E',CL6'3380',Y(15)    MLI   24APR85
         DC    X'3010200F',CL6'3390',Y(15)    TEC   18NOV91
         DC    X'3030200C',CL6'3375',Y(12)    CBOC  18JAN84
         DC    X'3050200B',CL6'3350',Y(30)    AFDSC 26MAR81
         DC    X'3050200D',CL6'3330-1',Y(19)  AFDSC 26MAR81
         DC    X'30502009',CL6'3330',Y(19)
         DC    X'30582009',CL6'3330V',Y(19)   AFDSC 26MAR81
         DC    X'3070200D',CL6'3330-1',Y(19)  AFDSC 26MAR81
         DC    X'30702009',CL6'3330',Y(19)
         DC    X'30782009',CL6'3330V',Y(19)   AFDSC 26MAR81
         DC    X'30808001',CL6'2400-1',Y(00)
         DC    X'30C08001',CL6'2400-2',Y(00)
         DC    X'30C08003',CL6'3400-2',Y(00)  AFDSC 11MAY78
         DC    X'32008003',CL6'3400-5',Y(00)  AFDSC 11MAY78
         DC    X'32108003',CL6'3400-6',Y(00)  AFDSC 11MAY78
         DC    X'34008001',CL6'2400-3',Y(00)
         DC    X'34008003',CL6'3400-3',Y(00)  AFDSC 11MAY78
         DC    X'34208001',CL6'2400-4',Y(00)
         DC    X'34208003',CL6'3400-4',Y(00)  AFDSC 11MAY78
         DC    X'78008080',CL6'3480',Y(00)    MLI   080CT86        @122
         DC    X'78048080',CL6'3480',Y(00)    TEC   12JAN93        @134
         DC    X'FFFFFFFF'
LSTENTRY EQU   *                   .
         SPACE ,
PWA      XPRDCB  DDNAME=SYSPRINT
HEADER1  XPRLDEF TEXT=HTEXT1,LENGTH=L'HTEXT1,SPB=(0,ATHOF),SPA=2
HTEXT1   DC    C'&NAME &VERSION -- LISTING OF ICF CATALOG --           X
                                            '                      @121
CATNAME  EQU   HTEXT1+44                                           @121
HEADER2  XPRLDEF TEXT=HTEXT2,LENGTH=132,SPA=1                      @130
HTEXT2   DS    0CL133                                              @130
         DC    CL133' '                                            @130
         ORG   HTEXT2                                              @130
         DC    CL44' ',CL2' '                                      @130
         DC    CL7' ',CL2' '                                       @130
         DC    CL6' ',CL2' '                                       @130
         DC    CL6' ',CL3' '                                       @130
         DC    CL5' ',CL2' '                                       @130
         DC    CL5' ',CL2' '                                       @130
         DC    CL5' ',CL2' '                                       @130
         DC    CL8' '                                              @130
         DC    CL9'   SPLITS'                                      @130
         DC    CL8'  BFRSPC'                                       @130
         DC    CL8' FRSPC'                                         @130
         DC    CL8'XT  %U'                                         @130
         ORG   HTEXT2+133                                          @130
HEADER2A XPRLDEF TEXT=HTEXT2A,LENGTH=132,SPA=2                     @130
HTEXT2A  DS    0CL133                                              @130
         DC    CL133' '                                            @130
         ORG   HTEXT2A                                             @130
         DC    CL44'DSNAME',CL2' '
         DC    CL7'TYPE',CL2' '
         DC    CL6'VOLUME',CL2' '
         DC    CL6'UNIT',CL3' '
         DC    CL5'TRKS',CL2' '
         DC    CL5'BLKSZ',CL2' '
         DC    CL5'LRECL',CL2' '
         DC    CL8'CREATED '                                       @130
         DC    CL6' LIMIT',CL1' '                                  @130
         DC    CL9'  SCRATCH',CL3' '                               @130
         DC    CL9'    EMPTY',CL1' '                               @130
         DC    CL8' '                                              @130
         ORG   HTEXT2A+133                                         @130
HEADER3  XPRLDEF TEXT=HTEXT3,LENGTH=132,SPA=2
HTEXT3   DS    0CL133
         DC    CL7'TYPE',CL2' '
         DC    124C'-'
         ORG   *-124
         DC    C'CELL FORMATS '
         ORG   HTEXT3+133
RPTLINE1 DS    0CL133
         DC    CL1' '
L1DSNAME DC    CL44' ',CL2' '
L1TYPE   DC    CL7' ',CL2' '
L1VOLUME DC    CL6' ',CL2' '
L1UNIT   DC    CL6' ',CL3' '
L1TRACKS DC    CL5' ',CL2' '
L1BLKSIZ DC    CL5' ',CL2' '
L1LRECL  DC    CL5' ',CL2' '
L1CREDT  DC    CL8' ',CL2' '
L1CISP   DC    CL3' ',CL1' '                                       @130
L1CASP   DC    CL3' ',CL1' '                                       @130
L1BFSP   DC    CL6' ',CL2' '                                       @130
L1CIFS   DC    CL2' ',CL1' '                                       @130
L1CAFS   DC    CL2' ',CL1' '                                       @130
L1XTNT   DC    CL3' ',CL1' '                                       @130
L1USED   DC    CL3' ',CL2' '                                       @130
         ORG    L1CISP
L1GDGMAX DC    CL4' ',CL3' '                                    16DEC86
L1GDGSCR DC    CL9' ',CL3' '                                    16DEC86
L1GDGEMP DC    CL7' ',CL3' '                                    16DEC86
         ORG   RPTLINE1+133
RPTLINE2 DS    0CL133
         DC    CL1' '
L2TYPE   DC    CL7' ',CL2' '
L2WORK   DC    CL124' '
NUMBERS  DC    C'0123456789ABCDEF'
TRHEX    EQU   *-256
DEPTH    DC    F'0'
ENTRIES  DS    16F
EXITS    DS    16F
         SPACE ,                                                   @120
PLINE1   DC    A(0,RPTLINE1+1)    PARMS TO PRINT RPTLINE1          @120
PLINE2   DC    A(0,RPTLINE2+1)    PARMS TO PRINT RPTLINE2          @120
PLINE2A  DC    A(1,RPTLINE2+1)    SKIP ONE, THEN PRINT RPTLINE2    @120
         SPACE ,                                                   @120
PARMLIST DS    3F                 PARMLIST MAPPING FOR UCB         @120
         ORG   PARMLIST                                            @120
PARMWA   DS    F                  ADDR OF 100-BYTE WORK AREA       @120
PARMDEVT DS    F                  ADDR OF DEV TYPE TO SCAN FOR     @120
PARMUCB  DS    F                  ADDR OF RETURNED UCB             @120
         SPACE ,                                                   @120
DEVCLASS DS    CL1                DEVICE CLASS TO SEARCH FOR       @120
ADDRUCB  DS    F                  RETURNED UCB ADDR                @120
SCANSAVE DS    F                  ADDR OF SCAN SERVICE ROUTINE     @120
XASWITCH DC    X'00'              INITIALIZE SWITCH                @120
         DS    0D                 FOR ALIGNMENT                    @120
UCBWORK  DS    CL100              UCB WORK AREA                    @120
         SPACE ,                                                   @120
         DYNSPACE  ,
         SPACE ,
         SPACE ,                                                   @130
*                                                                  @130
* FLAGS1                                                           @130
TAPE     EQU   B'10000000'                                         @130
DASD     EQU   B'00100000'                                         @130
DUMP     EQU   B'00010000'                                         @130
LEVEL    EQU   B'00000100'                                         @130
NOLEVEL  EQU   B'00000010'                                         @130
*                                                                  @130
* FLAGS2                                                           @130
VOLUME   EQU   B'10000000'                                         @130
NOVOLUME EQU   B'01000000'                                         @130
BRKLVL   EQU   B'00000010'                                         @130
*                                                                  @130
* FLAGS3                                                           @130
CONTAIN  EQU   B'00100000'                                         @130
ENDING   EQU   B'00010000'                                         @130
NOTCONT  EQU   B'00001000'                                         @130
NOTEND   EQU   B'00000100'                                         @130
*                                                                  @130
NOTAPE   EQU   255-TAPE                                            @130
NODASD   EQU   255-DASD                                            @130
NOBRKLVL EQU   255-BRKLVL                                          @130
*                                                                  @130
* DEFAULTS: NOTAPE,DASD                                            @130
*                                                                  @130
         DS    0F                                                  @130
FLAGS    DC    AL1(DASD),AL1(0),AL1(0)                             @130
FLAGS1   EQU   FLAGS,1                                             @130
FLAGS2   EQU   FLAGS+1,1                                           @130
FLAGS3   EQU   FLAGS+2,1                                           @130
         SPACE ,                                                   @130
DFLTFLAG DC    AL1(DASD),AL1(0),AL1(0)                             @130
         SPACE ,                                                   @130
ETAB     DS    0H                                                  @130
         DC    AL1(255),CL8' '                                     @130
         DC    16X'000000000000000000'                             @130
         DC    X'FF'                                               @130
CTAB     DS    0H                                                  @130
         DC    AL1(255),CL8' '                                     @130
         DC    16X'000000000000000000'                             @130
         DC    X'FF'                                               @130
NETAB    DS    0H                                                  @130
         DC    AL1(255),CL8' '                                     @130
         DC    16X'000000000000000000'                             @130
         DC    X'FF'                                               @130
NCTAB    DS    0H                                                  @130
         DC    AL1(255),CL8' '                                     @130
         DC    16X'000000000000000000'                             @130
         DC    X'FF'                                               @130
LTAB     DS    0H                                                  @130
         DC    AL1(255),CL8' '                                     @130
         DC    16X'000000000000000000'                             @130
         DC    X'FF'                                               @130
NLTAB    DS    0H                                                  @130
         DC    AL1(255),CL8' '                                     @130
         DC    16X'000000000000000000'                             @130
         DC    X'FF'                                               @130
NVTAB    DS    0H                                                  @130
         DC    AL1(255),CL6' '                                     @130
         DC    16X'00000000000000'                                 @130
         DC    X'FF'                                               @130
VTAB     DS    0H                                                  @130
         DC    AL1(255),CL6' '                                     @130
         DC    16X'00000000000000'                                 @130
         DC    X'FF'                                               @130
         SPACE ,
CVPLMAP  ICVAFPL DSECT=NO                                          @131
./       ADD   NAME=DSECTS
         TITLE 'DSECTS FOR CATALOG CELLS.'
VVDSTAB  DSECT ,
VVDSVOL  DS    CL6                 VOLSER OF A VOLUME WITH A VVDS
VVDSACB  DS    0F,AL4              ADDRESS OF A GENERATED ACB
VVDSRPL  DS    AL4                 ADDRESS OF A GENERATED RPL
VVDSBUF  DS    AL4                 ADDRESS OF A RECORD BUFFER
VVDSARG  DS    AL4                 ADDRESS OF RBA TO READ THE VVDS
VVDSFLG  DS    0CL1                INDEXED VTOC FLAG               @131
         DS    AL4                                                 @131
VVDSTLEN EQU   *-VVDSTAB           LENGTH OF AN ENTRY
         SPACE 2
VCNC     DSECT                     VSAM CLUSTER NAME CELL
CLCELLN  DS    XL2                 LENGTH OF VCNC INCLUDING ITSELF
CLTYPE   DS    CL1                 TYPE 'C' FOR CLUSTER
CLCOMPLN DS    XL2                 LENGTH OF THE CLUSTER COMPONENT
CLNOEXT  DS    XL1                 NUMBER OF EXTENSION RECORDS
CLNMLEN  DS    XL1                 LENGTH OF THE CLUSTER KEY (45)
CLNAME   DS    CL44                CLUSTER NAME
CLNMPAD  DS    XL1                 PAD VALUE, SET TO X'00'
         SPACE 2
DINC     DSECT                     DATA OR INDEX NAME CELL
DIDLEN   DS    XL2                 LENGTH OF DINC
DIDTYPE  DS    CL1                 TYPE 'D' FOR DATA OR INDEX
DIDCMPLN DS    XL2                 LENGTH OF DINC COMPONENT
DIDIRFLG DS    XL1                 INTERRUPT RECOGNITION FLAGS
DIDELETE EQU   B'1000000'          DELETE IN PROGRESS
DIDUPDAT EQU   B'0100000'          UPDATE-EXTEND IN PROGRESS
DIDSRMU  EQU   B'0010000'          SUB-RECORD MOVE/UPDATE IN PROGRESS
DIDKEYLN DS    XL1                 CONDENSED KEYLENGTH
DIDKEY   DS    0XL1                CONDENSED KEY
         SPACE 2
ANC      DSECT                     ALTERNAME INDEX CELL
AIXLEN   DS    XL2                 LENGTH OF ANC
AIXTYPE  DS    CL1                 TYPE 'G' FOR ANC
AIXCMPLN DS    XL2                 LENGTH OF AIX COMPONENT
AIXFLAG  DS    XL1                 FLAG BYTE
AIXUPG   EQU   B'1000000'          AIX IS MEMBER OF UPGRADE SET
AIXKEYLN DS    XL1                 CONDENSED KEYLENGTH
AIXKEY   DS    0XL1                CONDENSED KEY 2-45 BYTES
         SPACE 2
PNC      DSECT                     PATH NAME CELL
PATHCELN DS    XL2                 LENGTH OF PATH CELL
PATHTYPE DS    CL1                 TYPE 'R' FOR PATH
         DS    XL2
PATHATTR DS    XL1                 PATH ATTRIBUTES
PATHUPG  EQU   B'1000000'          UPGRADE IF RELATED TO AIX
PATHUPD  EQU   B'1000000'          UPDATE IF RELATED TO CLUSTER.
PATHREL  EQU   B'0010000'          0=RELATED TO AIX,1=RELATED TO
*                                  CLUSTER
PATHKYLN DS    XL1                 LENGTH OF PATH KEY
PATHNAME DS    CL44                PATH NAME.
         SPACE 2
NVNC     DSECT                     NONVSAM DATASET CELL
NVCELEN  DS    XL2                 LENGTH OF NVNC
NVTYPE   DS    CL1                 TYPE 'A' FOR NONVSAM
NVRESV   DS    XL1                 RESERVED
NVOLCNT  DS    XL2                 NUMBER OF VOLUME CELLS (255 MAX)
NVKEYLN  DS    XL1                 LENGTH OF THE NONVSAM KEY
NVNAME   DS    CL44                DATASET NAME
NVPAD    DS    XL1                 PAD VALUE X'00'
         SPACE 2
OWNERC   DSECT                     OWNERSHIP CELL FORMAT.
OWNCELLN DS    XL2                 LENGTH OF OWNERSHIP CELL
OWNTYPE  DS    XL1                 TYPE X'01' FOR OWNER
OWNID    DS    XL8                 OWNER ID
OWNFLAG  DS    XL1                 FLAG
OWNRACF  EQU   B'10000000'         RACF PROTECTED
OWNKSDS  EQU   B'01000000'         INDEX COMPONENT DATASET
OWNREUS  EQU   B'00100000'         REUSABLE DATASET.
OWNERASE EQU   B'00010000'         ERASE
OWNSWAP  EQU   B'00000010'         SWAPSPACE
OWNPAGE  EQU   B'00000001'         PAGESPACE
OWNCREDT DS    XL3                 CREATION DATE
OWNEXPDT DS    XL3                 EXPIRY DATE
         SPACE 2
SECURITY DSECT                     SECURITY CELL
SECELLN  DS    XL2                 LENGTH OF SECURITY CELL
SECTYPE  DS    XL1                 TYPE X'02' FOR SECURITY.
SECMSTR  DS    CL8                 MASTER PASSWORD.
SECCI    DS    CL8                 CONTROL INTERVAL PASSWORD.
SECUPDTE DS    CL8                 UPDATE PASSWORD.
SECREAD  DS    CL8                 READ PASSWORD.
SECPMTCD DS    CL8                 PASSWORD PROMPTING CODE.
SECATMP  DS    XL2                 MAXIMUM NUMBER OF ATTEMPTS.
SECVRMOD DS    CL8                 USER SECURITY VERIFICATION MOD.
SECRCDLN DS    XL2                 USER AUTHORIZATION RECORD LENGTH.
SECRCD   DS    0XL1                USER AUTHORIZATION RECORD (256 MAX)
         SPACE 2
ASSOCC   DSECT                     ASSOCIATION CELL
ASCLEN   DS    XL2                 ASSOCIATION CELL LENGTH
ASCTYPE  DS    XL1                 TYPE X'03' FOR ASSOC
ASCOUNT  DS    XL2                 COUNT OF ASSOCIATIONS
* THE FOLLOWING FIELDS ARE REPEATED THE NUMBER OF TIMES IN ASCOUNT
ASCKEYS  DS    0XL2
ASCFLAG  DS    XL1                 FLAG
ASCREUS  EQU   B'10000000'         USED IN RELATION CELL ONLY.
ASCKYLEN DS    XL1                 LENGTH OF CONDENSED ASSOC KEY.
ASCKEY   DS    0XL1                2-45 BYTE CONDENSED KEY.
         SPACE 2
GATC     DSECT
GATCELN  DS    XL2                 LENGTH OF GATC INCLUDING ITSELF
GATYPE   DS    CL1                 TYPE X'05' FOR GDG AGING TABLE
GATATTR  DS    XL1                 GDG SCRATCH/DELETE ATTRIBUTE
GATDELET EQU   B'10000000'         DELETE ALL GDGS
GATSCRTH EQU   B'01000000'         SCRATCH IF MOUNTED
GATLIMIT DS    XL1                 MAXIMUM GDS ENTRIES IN GDG BASE
GATCNT   DS    XL1                 CURRENT NUMBER OF ENTRIES IN GAT
* THE FOLLOWING FIELDS ARE REPEATED THE NUMBER OF TIMES IN GATCNT
GAT      DS    0XL4                4-BYTE ENTRY FOR EACH GDS
GATENT   DS    0XL4                GAT ENTRY
GATEXTNO DS    XL1                 EXTENSION RECORD SEQUENCE NUMBER
GATGEN   DS    XL2                 GENERATION NUMBER OF GDS
GATWRAP  EQU   B'10000000'         GENERATION EXCEEDED 9999
GATVER   DS    XL1                 VERSION NUMBER OF GDS
         SPACE 2
GDGNC    DSECT                     GDG BASE NAME CELL
GDGCELLN DS    XL2                 LENGTH OF GDGNC INCLUDING ITSELF
GDGTYPE  DS    CL1                 TYPE 'B' FOR GDG
GDGCMPLN DS    XL2                 LENGTH OF THE GDG COMPONENT
GDGNOEXT DS    XL1                 NUMBER OF EXTENSION RECORDS
GDGKYLEN DS    XL1                 LENGTH OF THE GDG
GDGNAME  DS    CL44                GDG NAME 1-35 BYTES BLANK PADDED
GDGPAD   DS    XL1                 PAD VALUE, SET TO X'00'
         SPACE 2
GDSNC    DSECT                     GDG ENTRY NAME CELL
GDSCELLN DS    XL2                 LENGTH OF GDSNC INCLUDING ITSELF
GDSTYPE  DS    CL1                 TYPE 'H' FOR GDS
GDSCMPLN DS    XL2                 LENGTH OF THE GDS COMPONENT
GDSGENO  DS    XL2                 GENERATION NUMBER
GDSVERNO DS    XL1                 VERSION NUMBER
GDSVOLCT DS    XL2                 NUMBER OF VOLUME CELLS IN GDS
         SPACE 2
VOLCELL  DSECT                     VOLUME CELL
VOLLEN   DS    XL2                 LENGTH OF VOLCELL
VOLTYPE  DS    XL1                 TYPE X'04' FOR VOLUME CELL
VOLOFSET DS    XL1                 UNUSED
VOLSERN  DS    CL6                 VOLUME SERIAL NUMBER
VOLDEVTP DS    XL4                 DEVICE TYPE
VOLFLAG1 DS    XL1                 FLAG
VOLPRIME EQU   B'10000000'         PRIME VOLUME-ALLOCATED SPACE
VOLCANDI EQU   B'01000000'         CANDIDATE VOLUME NOSPACE
VOLOFLOW EQU   B'00100000'         OVERFLOW KEYRANGE ONLY
VOLCONV  EQU   B'00010000'         CONVERTED VSAM DATASET VOLUME
VOLNVSAM EQU   B'00001000'         NONVSAM VOLUME CELL
VOLKYRNG EQU   B'00000100'         KEYRANGE QUALIFIER PRESENT
VOLVPCI  EQU   B'00000010'         PRIMARY VVR CI
VOLSSQWD EQU   B'00000001'         SEQUENCE SET WITH DATA
VOLFLAG2 DS    XL1                 RESERVED
VOLVVRBA DS    0XL4                RELATIVE BYTE ADDRESS OF VVR
VOLDSTTR DS    XL3                 NONVSAM FORMAT 1 DSCB TTR
         DS    XL1                 RESERVED
VOLFLSEQ DS    XL2                 NONVSAM FILE SEQUENCE NUMBER (TAPE)
VOLKRQL  DS    XL4                 KEYRANGE QUALIFIER (VSAM ONLY)
VOLLKYLN DS    XL2                 LENGTH OF LOW KEY RANGE KEY
         SPACE 2
RELCELL  DSECT                     RELATIONSHIP CELL.
RELLEN   DS    XL2                 CELL LENGTH.
RELTYPE  DS    XL1                 TYPE X'06'
RELRESV  DS    XL1                 RESERVED.
RELCNT   DS    XL1                 COUNT OF RELKEYS.
RELKEYS  DS    0XL2
RELFLAG  DS    XL1                 FLAG BYTE
RELUPG   EQU   B'10000000'         UPGRADE AIX.
RELGLEN  DS    XL1                 LENGTH OF AIX CONDENSED KEY.
RELGKEY  DS    0XL1                AIX CONDENSED KEY.
         SPACE 2
VVR      DSECT
*VVRLEN  DS    XL2                LENGTH OF ENTIRE VVR
VVRHDLEN DS    XL2                 LENGTH OF VVR HEADER
VVRTYPE  DS    CL1                 Z=PRIMARY VVR. Q=SECONDARY VVR
VVRFLAG  DS    XL1                 HEADER FLAG
VVRSELFD EQU   B'01000000'         SELF-DESCRIBING VVR FOR VVDS
VVRCATDS EQU   B'00100000'         CATALOG SELF-DESCRIBING VVR
VVRCOMTP EQU   B'00001000'         COMPONENT TYPE. 0='D' 1='I'
VVRKRQ   DS    XL4                 KEY RANGE QUALIFIER
VVRCMPNL DS    XL1                 COMPONENT NAME LENGTH
VVRCMPNM DS    0CL44               COMPONENT NAME
         SPACE 2
VVRDSINF DSECT                     DATASET INFORMATION CELL
VVRDSLEN DS    XL2                 CELL LENGTH.
VVRDSTYP DS    XL1                 TYPE CODE IS X'21'
VVRDSATR DS    0XL2                DATASET ATTRIBUTES
VVRATTR1 DS    XL1
VVRA1SPD EQU   B'10000000'         SPEED
VVRA1UNQ EQU   B'01000000'         UNIQUE
VVRA1REU EQU   B'00100000'         REUSE
VVRA1ERS EQU   B'00010000'         ERASE
VVRA1IUP EQU   B'00000100'         INHIBIT UPDATE
VVRA1TEX EQU   B'00000010'         EXPORT TEMPORARY.
VVRA1TKO EQU   B'00000001'         TRACK OVERFLOW
VVRATTR2 DS    XL1
VVRA2REG EQU   B'11000000'         CROSS-REGION SHROPTN
VVRA2SYS EQU   B'00110000'         CROSS-SYSTEM SHROPTN
VVRA2INT EQU   B'00000010'         INTERNAL DATASET
VVRA2NUS EQU   B'00000001'         COMPONENT IS NOT USABLE.
VVROPIND DS    XL1                 OPEN INDICATOR
VVRBUFSZ DS    XL4                 MINIMUM BUFFER SIZE
VVRPRISP DS    XL3                 PRIMARY SPACE ALLOCATION
VVRSECSP DS    XL3                 SECONDARY SPACE ALLOCATION
VVRSPCFG DS    XL1                 SPACE FLAGS
VVRSPCOP EQU   B'11000000'         SPACE OPTIONS
VVRDSHU  DS    XL4                 DATASET HIGH USED RBA
VVRDSHA  DS    XL4                 DATASET HIGH ALLOCATED RBA
VVRLRECL DS    XL4                 AVERAGE LOGICAL RECORD LENGTH
         DS    XL2
VVREXCPX DS    CL8                 EXCEPTION EXIT.
VVRDSHK  DS    XL4                 DATASET HIGH KEY RBA.
VVRCLSFG DS    XL1                 CLUSTER ATTRIBUTE FLAG
VVRCFSWS EQU   B'00000010'         CLUSTER DESCRIBES A SWAP SPACE
VVRCFPGS EQU   B'00000001'         CLUSTER DESCRIBES A PAGE SPACE
VVRAIXFG DS    XL1                 AIX ATTRIBUTE FLAG
VVRAIUPG EQU   B'00000001'         UPGRADE AIX.
VVRTMSTP DS    XL8                 TIMESTAMP (CATALOG ONLY).
         SPACE 2
VVRVOLIN DSECT                     VVR VOLUME INFORMATION CELL
VVRVOLLN DS    XL2                 LENGTH OF VOLUME CELL
VVRVOLTP DS    XL1                 TYPE CODE IS X'23'
VVRVOLFG DS    XL1                 VOLUME FLAGS
VVRPRIME EQU   B'10000000'         PRIME VOLUME
VVROVFLW EQU   B'00100000'         OVERFLOW VOLUME
VVRNOEXT DS    XL1                 NUMBER OF EXTENTS ON THIS VOLUME.
VVRHKRBA DS    XL4                 HIGH KEY RBA
VVRHURBA DS    XL4                 HIGH USED RBA
VVRHARBA DS    XL4                 HIGH ALLOCATED RBA
VVRBLKSZ DS    XL4                 BLOCK SIZE
VVRBLKTK DS    XL2                 NUMBER OF BLOCKS PER TRACK
VVRTRKAU DS    XL2                 NUMBER OF TRACKS PER ALLOCATION UNIT
VVRTPEXT DS    XL1                 EXTENT TYPE FLAG
VVRSSDAT EQU   B'10000000'         SEQUENCE SET WITH DATA
VVRNOPFM EQU   B'01000000'         EXTENTS NOT PRE-FORMATTED
VVRCONV  EQU   B'00100000'         CONVERTED VSAM DATASET VOLUME.
VVRTKCYL DS    XL2                 TRACKS PER CYLINDER
VVRBYTTK DS    XL4                 BYTES PER TRACK.
VVRBYTAU DS    XL4                 BYTES PER ALLOCATION UNIT
VVRLOKYL DS    XL2                 LOW KEY LENGTH
VVRLOKYV DS    0XL1                LOW KEY ON VOLUME
VVRXTENT DS    0XL1                EXTENT SECTION. FOLLOWS LOW KEY
*                                  VALUE
VVRXTNTL DS    XL2                 TOTAL LENGTH OF EXTENT SECTION.
VVRXTNT  DS    0XL20               20 BYTE EXTENT DESCRIPTION.
VVRXSEQN DS    XL2                 SEQUENCE NUMBER
VVRXSCH  DS    0XL4                STARTING CCHH
VVRXSC   DS    XL2                 STARTING CC
VVRXSH   DS    XL2                 STARTING HH
VVRXECH  DS    0XL4                ENDING CCHH
VVRXEC   DS    XL2                 ENDING CC
VVRXEH   DS    XL2                 ENDING HH
VVRXNTRK DS    XL2                 NUMBER OF TRACKS
VVRXSRBA DS    XL4                 STARTING RBA
VVRXERBA DS    XL4                 ENDING RBA
         SPACE 2
VVRAMDCL DSECT                     VVR AMDSB CELL
VVRAMDCN DS    XL2                 LENGTH OF AMDSB CELL
VVRAMCAT DS    0XL96               COPY OF AN AMDSB
VVRAMID  DS    XL1                 TYPE CODE IS X'60'
VVRAMATR DS    XL1                 ATTRIBUTES:
VVRAMDST EQU   B'10000000'         1=KSDS, 0=ESDS
VVRAMWCK EQU   B'01000000'         WRITE CHECK
VVRAMSDT EQU   B'00100000'         SEQUENCE SET WITH DATA
VVRAMREP EQU   B'00010000'         REPLICATION
VVRAMORD EQU   B'00001000'         USE VOLUMES IN LIST ORDER
VVRAMRGE EQU   B'00000100'         KEY RANGE DATASET
VVRAMRDS EQU   B'00000010'         RRDS
VVRAMRSN EQU   B'00000001'         SPANNED RECORDS ALLOWED
VVRAMLEN DS    XL2                 LENGTH OF AMDSB
VVRAMNST DS    0XL2                NUMBER OF ENTRIES IN INDEX SECTION
VVRAMAKP DS    XL2                 ALTERNATE KEY RKP
VVRAMRKP DS    XL2                 RKP
VVRAMKNL DS    XL2                 KEY LENGTH
VVRAMPCA DS    XL1                 % FREE CI IN CA
VVRAMPCI DS    XL1                 % FREE BYTES IN CI
VVRAMCCA DS    XL2                 CI'S PER CA
VVRAMFCA DS    XL2                 FREE CI'S PER CA
VVRAMFCI DS    XL4                 FREE BYTES PER CI
VVRAMCIV DS    XL4                 CONTROL INTERVAL SIZE
VVRAMLCL DS    XL4                 MAXIMUM RECORD SIZE
VVRAMHLR DS    0XL4                RBA OF HI LEVEL INDEX RECORD
VVRAMSLT DS    XL4                 SLOTS PER CI
VVRAMSSR DS    0XL4                RBA OF FIRST SEQUENCE SET RECORD
VVRAMMRR DS    XL4                 MAXIMUM RELATIVE RECORD NUMBER
VVRAMARB DS    XL4                 POINTER TO 1ST ARDB
VVRAMAT3 DS    XL1                 ATTRIBUTES
VVRAMUNQ EQU   B'10000000'         UNIQUE OR NON-UNIQUE KEYS
VVRAMFLT EQU   B'01000000'         CYLINDER FAULT MSS OR STAGE
VVRAMBND EQU   B'00100000'         BIND OR DO NOT BIND ON MSS
VVRAMWAT EQU   B'00010000'         WAIT OR DO NOT WAIT ON RELINQUISH
VVRAMLM  EQU   B'00001000'         LOAD MODE OR DATASET LOADED.
VVRAMSNO DS    XL1                 NUMBER OF CONCURRENT REQUESTS
         DS    XL4
VVRAMBFI DS    0XL2                NUMBER OF INDEX BUFFERS
VVRAMBFD DS    XL2                 NUMBER OF DATA BUFFERS
VVRAMSTS DS    XL8                 SYSTEM TIMESTAMP
VVRAMNIL DS    XL2                 NUMBER OF INDEX LEVELS
VVRAMNXT DS    XL2                 NUMBER OF EXTENTS
VVRAMNLR DS    XL4                 NUMBER OF LOGICAL RECORDS
VVRAMDLR DS    XL4                 NUMBER OF DELETED RECORDS
VVRAMINR DS    XL4                 NUMBER OF INSERTED RECORDS
VVRAMUPR DS    XL4                 NUMBER OF UPDATED RECORDS
VVRAMRTR DS    XL4                 NUMBER OF RETRIEVED RECORDS
VVRAMASP DS    XL4                 BYTES OF FREE SPACE IN DATASET
VVRAMCIS DS    XL4                 NUMBER OF CI SPLITS
VVRAMCAS DS    XL4                 NUMBER OF CA SPLITS
VVRAMEXC DS    XL4                 NUMBER OF EXCPS
         TITLE 'HSM - MCD DSECT.'
MCD      DSECT
MCDDSN   DS    CL44                DATASET NAME
MCDMCK   DS    CL20                CDS RECORD HEADER
MCDVSN   DS    CL6                 VOLSER OF MIGN. VOL HOLDING THE DS.
MCDFLGS  DS    0XL2                FLAGS
MCDFLG1  DS    X                   FLAGS - BYTE ONE
MCDFASN  EQU   B'10000000'         A MIGRATED COPY EXISTS
MCDFMIG  EQU   B'01000000'         DATA SET IS TO BE MIGRATED
MCDFNOMG EQU   B'00100000'         DATA SET IS TO BE RETAINED FROM
*                                  MIGRATION
MCDFDEL  EQU   B'00010000'         DATA SET WAS DELETED
MCDFSDP  EQU   B'00001000'         DATA SET IS SMALL-DATASET-PACKED
MCDFFL2  EQU   B'00000100'         WHEN SET TO 1, DATASET IS ON ML2,
*                                  ELSE ML1
MCDFNSCR EQU   B'00000010'         DATASET RECALLED BUT MIGRATED COPY
*                                  EXISTS
MCDJES3  EQU   B'00000001'         RECORD PROCESSED BY HSM-JES3 SETUP.
MCDFLG2  DS    X                   FLAGS - BYTE TWO
MCDFSMVL EQU   B'00000100'         SPACE MGMT FLAGS (MCDRECAL) ARE
*                                  VALID
MCDFDUMD EQU   B'00000010'         WHEN SET TO 1, THIS IS A DUMMY
*                                  RECORD
MCDJR3   EQU   B'00000001'         THIS RECORD WAS CREATED BY RELEASE
*                                  3.
MCDCOMPR DS    X                   PERCENT OF SPACE SAVED BY COMPACTION
         DS    XL3
MCDDLC   DS    CL4                 X'00YYDDDS' - DATE DS WAS CREATED.
MCDDLC3  EQU   MCDDLC+1,3,C'P'
MCDTLR   DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST USED.
MCDDLR   DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST
*                                  REFERENCED.
MCDDLR3  EQU   MCDDLR+1,3,C'P'
MCDTLU   DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST
*                                  UPDATED.
MCDDLU   DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST
*                                  UPDATED.
MCDDLU3  EQU   MCDDLU+1,3,C'P'
MCDTMIG  DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST
*                                  MIGRATED.
MCDDMIG  DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST
*                                  MIGRATED.
MCDDMIG3 EQU   MCDDMIG+1,3,C'P'
MCDDSORG DS    XL2                 DSORG FROM THE DSCB.
MCDBLKSZ DS    XL2                 MAXIMUM BLOCK SIZE OF THE DATASET.
MCDKEYLN DS    XL1                 KEY LENGTH OF THE DATASET.
MCDRECFM DS    XL1                 RECORD FORMAT
MCDRFTYP EQU   B'11000000'         FLAGS FOR A V,B, OR F FORMAT ???
MCDRFTO  EQU   B'01000000'         TRACK OVERFLOW IS PRESENT
MCDDSIND DS    XL1                 INDICATORS FROM THE FORMAT 1 DSCB.
MCDFRACF EQU   B'01000000'         DS IS RACF-PROTECTED
MCDFSCTY EQU   B'00010000'         DS IS PASSWORD PROTECTED.
MCDFWSEC EQU   B'00000100'         DS IS WRITE-PASSWORD PROTECTED
MCDFCHNG EQU   B'00000010'         OPENED FOR OTHER THAN READ-ONLY
MCDHID   DS    XL1                 ID OF THE PROCESSOR USING THIS
*                                  RECORD
MCDSIZE  DS    XL4                 SIZE ALLOCATED IN TRACKS, ON THE
*                                  USERS VOL
MCDSIZEB DS    XL4                 SIZE USED IN BYTES, ON THE USERS VOL
MCDCSZ   DS    XL4                 SIZE OF THE DS IN 2K BLKS ON MIG
*                                  VOLUME
MCDNMIG  DS    XL2                 COUNT OF TIME DS WAS MIGRATED.
MCDDAYS  DS    XL2                 NUMBER OF DAYS BEFORE DS WILL BE
*                                  MIGRATED
MCDFRVSN DS    CL6                 VOLSER OF PRIMARY WHERE DATASET WAS
         ORG   MCDFRVSN
MCDOVSN  DS    CL6                 VOLSER TO WHICH DS WAS RECALLED
         DS    XL1
MCDMCL43 DS    XL1
MCDCTID3 DS    CL4                 NAME OF COMPACTION TABLE USED ON
*                                  THIS DS
MCDUCBTY DS    XL4                 UCBTYP OF "FROM" PRIMARY VOLUME.
MCDTRES  DS    CL4                 X'HHMMSSTH' - TIME DS WAS
*                                  RECALLED/DELETED
MCDDRES  DS    CL4                 X'00YYDDDS' - DATE DS WAS
*                                  RECALLED/DELETED
MCDMDEVT DS    XL4                 DEVICE TYPE OF MIGRATION VOLUME
MCDJDAYS DS    XL1
MCDJDATE DS    XL3                 LAST DATE TO WHICH HSM WILL DELAY
*                                  MIG
MCDJVEXD DS    XL3
MCDPDEP  DS    XL1
MCDJCT   DS    XL1                 COUNT OF VOLS ELIGIBLE FOR DIRECTED
*                                  RECALL
MCDJVOLS DS    0CL10               5 SLOTS - VOLUMES FOR DATASET RECALL
MCDJVSN  DS    CL6                 VOLSER TO WHICH DS CAN BE RECALLED
MCDJDEVT DS    XL4                 DEVICE TYPE OF ABOVE
         DS    4CL10
MCDRECAL DS    X                   FLAGS
MCDFDBA  EQU   B'10000000'         WHEN 0, DS MUST BE RECALLED TO MIG
*                                  VOL
MCDFRBU  EQU   B'01000000'
MCDFBDCS EQU   B'00100000'         DS MIGRATED FROM A BACKED-UP VOLUME
MCDFBDCT EQU   B'00010000'
MCDFAM   EQU   B'00001000'         DS MUST BE RECALLED TO AUTOMIG
*                                  VOLUME
MCDFAB   EQU   B'00000100'         DS MUST BE RECALLED TO AUTOBACKUP
*                                  VOL
MCDEXPDT DS    CL4                 X'00YYDDDS' - EXPDT WHEN MIGRATED
MCDMCANM DS    CL44                DATASET NAME OF MIGRATED VERSION
         TITLE 'DSECTS FOR SYSTEM DATA AREAS.'
         CVT   DSECT=YES
UCB      DSECT ,
         IEFUCBOB  ,
         IEFZB4D0  ,
         IEFZB4D2  ,
         IEZJSCB ,
         IKJTCB  DSECT=YES
         IFGRPL  ,                                                 @122
./       ADD   NAME=DYNSPACE
         MACRO
&NAME    DYNSPACE &TYPE
.*
.*    THIS IS AN INNER MACRO TO ALLOC/FREE.
.*    IT IS CALLED TO   A) NAME AN AREA FOR THE PARMLIST
.*                      B) LOG THE VARIOUS AMOUNTS NEEDED BY
.*                         EACH, REMEMBERING THE LARGEST.
.*                      C) GENERATING A DS FOR THE LARGEST AMOUNT.
.*    THE FIRST TWO FUNCTIONS ARE INVOKED BY ALLOC/FREE MACROS ONLY,
.*    AND THE THIRD IS USED BY THE PROGRAMMER, EITHER EXPLICITLY,
.*    OR BY BEGINWKA, IF THE LATTER IS USED.
.*
.*     TO INVOKE THE NAMING FUNCTION, ALLOC/FREE GENERATE
.*     NAME DYNSPACE
.*     NOTE. THE NAMING OPERATION ONLY GENERATES A NAME ON THE
.*     FIRST CALL IN THE ASSEMBLY. THE NAME REMAINS THE SAME UNTIL
.*     DYNSPACE IS CALLED TO EXPAND INTO A DS.
.*
.*     THE SECOND FUNCTION IS INVOKED BY THE MACRO CALL
.*          DYNSPACE ADD
.*     (NO NAME FIELD AND ONE OPERAND)
.*     IT USES THE GLOBAL VARIABLES &DTUO AND &DTUPO TO CALCULATE
.*     THE SPACE FOR THIS REQUEST, AND UPDATES &DYNSPQ ONLY IF THE
.*     CURRENT REQUEST IS FOR A GREATER AMOUNT
.*
.*     THE THIRD FUNCTION IS INVOKED BY CALLING DYNSPACE WITH NO
.*     NAME OR OPERAND FIELD.
.*     THIS EXPANDS INTO A DEFINE STORAGE, CLEARS THE DYNSPACE NAME
.*     GLOBAL SETC, AND THE &DYNSPQ GLOBAL SETA.
.*     THUS, THE MACRO IS SERIALLY REUSABLE IN ALL FUNCTIONS.
.*
         GBLA  &DYNSPQ,&DTUO,&DTUPO,&RCPDYN
         GBLC  &DYNP,&DYNSP
         LCLA  &I
         AIF   ('&NAME' NE '').NAME
         AIF   ('&TYPE' EQ '').ALLOC
.*   THE ACCUMULATE FUNCTION IS REQUIRED
&I       SETA  24+&DTUO+&DTUPO         GET AMOUNT FOR THIS REQUEST
         AIF   (&I LE &DYNSPQ).EXIT    IF CURRENT < MAX, EXIT
&DYNSPQ  SETA  &I                      ELSE UPDATE CURRENT MAXIMUM
         MEXIT
.NAME    AIF   ('&DYNSP' NE '').EXIT   IF NAME ALREADY EXISTS, EXIT
&DYNSP   SETC  'DYNSP&RCPDYN'           ELSE GENERATE A NAME
.EXIT    MEXIT
.ALLOC   AIF   ('&DYNSP' EQ '').EXIT
*
**     RESERVE SPACE FOR ALLOC/FREE MACRO WORK AREA
*
&DYNSP   DS    0F,CL&DYNSPQ            RESERVE SPACE
&DYNSP   SETC  ''                      SET MAX QUANTITY TO 0
&DYNSPQ  SETA 0
         MEND
./       ADD   NAME=EDIT
         MACRO
&NAME    EDIT  &PR,&NUM,&ED
         LCLA  &A1,&A2,&A3,&A4
         LCLB  &B1,&B2
         LCLC  &C1,&C2,&C3
         ACTR  200
         AIF   (N'&SYSLIST EQ 2 AND K'&ED EQ 0).ANOP1
         AIF   (N'&SYSLIST NE 3).MNOTE1
         AIF   ('&ED'(1,1) EQ '-' OR '&ED'(1,1) EQ '$').EDMK
.ANOP1   ANOP
&A1      SETA  &A1+1
         AIF   (K'&ED LT &A1).CONT
&A2      SETA  &A2+1
&A4      SETA  &A4+1
         AIF   ('&ED'(&A1,1) NE 'Z' AND '&ED'(&A1,1) NE '&C2').NINE
.ANOP2   ANOP
&C1      SETC  '&C1.20'
         AGO   .ANOP1
.NINE    AIF   ('&ED'(&A1,1) NE '9').PER
         AIF   (&B1).ANOP2
&B1      SETB  1
         AIF   (&A1 EQ 1).SIGNIF
         AIF   (&A1 EQ 2 AND &B2).SIGNIF
&C3      SETC  '&C1'(&A4*2-3,2)
         AIF   ('&C3' NE '20').NINE2
&C1      SETC  '&C1'(1,&A4*2-4).'2120'
         AGO   .ANOP1
.NINE2   ANOP
&C1      SETC  '&C1'(1,&A4*2-6).'21&C3.20'
         AGO   .ANOP1
.SIGNIF  ANOP
&C1      SETC  '21'
         AGO   .ANOP1
.PER     AIF   ('&ED'(&A1,1) NE '.').COMMA
&C1      SETC  '&C1.4B'
&A2      SETA  &A2-1
         AGO   .ANOP1
.COMMA   AIF   ('&ED'(&A1,1) NE 'V').SLASH
&C1      SETC  '&C1.6B'
&A2      SETA  &A2-1
         AGO   .ANOP1
.SLASH   AIF   ('&ED'(&A1,1) NE '/').DBCR
&C1      SETC  '&C1.61'
&A2      SETA  &A2-1
         AGO   .ANOP1
.DBCR    AIF   (&A1+1 NE K'&ED).MNOTE2
         AIF   ('&ED'(&A1,2) NE 'CR').DB
&C1      SETC  '&C1.C3D9'
&A2      SETA  &A2-1
         AGO   .CONT
.DB      AIF   ('&ED'(&A1,2) NE 'DB').MNOTE2
&C1      SETC  '&C1.C4C2'
&A2      SETA  &A2-1
.CONT    ANOP
&C3      SETC  '&PR'
         AIF   (L'&NUM*2-1 NE &A2).EDSIZE
.ENDCHEC ANOP
&A2      SETA  0
         AIF   (K'&C1/2+1 NE L'&PR).AREASIZ
.LAST    AIF   (&B2).EDMKEND
&NAME    MVC   &C3,=X'40&C1'
         ED    &C3,&NUM
         MEXIT
.EDSIZE  AIF   (L'&NUM*2-1 LT &A2).LONG
.SHORT   ANOP
&C1      SETC  '20&C1'
&A3      SETA  &A3+1
         AIF   (L'&NUM*2-1 GT &A2+&A3).SHORT
         AGO   .ENDCHEC
.LONG    ANOP
&C1      SETC  '&C1'(3,K'&C1-2)
&A3      SETA  &A3+1
         AIF   (L'&NUM*2-1 LT &A2-&A3).LONG
         AGO   .ENDCHEC
.AREASIZ AIF   (K'&C1/2+1 LT L'&PR).LESS
&A2      SETA  K'&C1/2+1-L'&PR
&A3      SETA  K'&C1/2+1
&C3      SETC  '&C3-&A2.(&A3)'
&B1      SETB  1
         AGO   .LAST
.LESS    ANOP
&B1      SETB  0
&A3      SETA  K'&C1/2+1
         AIF   (K'&C1/2+5 GE L'&PR).PLUSET
&C3      SETC  '&C3.(&A3)'
         AGO   .LAST
.PLUSET  ANOP
&A2      SETA  L'&PR-K'&C1/2-1
&C3      SETC  '&C3+&A2.(&A3)'
         AGO   .LAST
.EDMK    AIF   ('&ED'(1,1) EQ '-').NEG
&C2      SETC  '$'
         AGO   .C2SET
.NEG     ANOP
&C2      SETC  '-'
.C2SET   ANOP
&A1      SETA  1
&B2      SETB  1
         AGO   .ANOP1
.EDMKEND ANOP
&A1      SETA  -1
.EDMKNOP ANOP
&A1      SETA  &A1+2
         AIF   (K'&C1 LT &A1).SETA
         AIF   ('&C1'(&A1,2) EQ '21').SETAA
         AIF   ('&C1'(&A1,2) NE '4B').EDMKNOP
&A1      SETA  (&A1+1)/2
         AGO   .LA
.SETA    ANOP
&A1      SETA  (&A1+1)/2-1
         AGO   .LA
.SETAA   ANOP
&A1      SETA  (&A1+1)/2+1
.LA      ANOP
         AIF   (&B1).MINUS
&A1      SETA  &A1+&A2
         AGO   .MVC
.MINUS   ANOP
&A1      SETA  &A1-&A2
.MVC     ANOP
&NAME    MVC   &C3,=X'40&C1'
         LA    1,&PR+&A1
         EDMK  &C3,&NUM
         AIF   ('&C2' EQ '$').DOLLAR
         BNM   EDIT&SYSNDX
         BCTR  1,0
         MVI   0(1),C'-'
&C3      SETC  '&SYSNDX'
EDIT&C3  EQU   *
         MEXIT
.DOLLAR  BCTR  1,0
         MVI   0(1),C'$'
         MEXIT
.MNOTE1  MNOTE 8,'THREE OPERANDS MUST BE SPECIFIED'
         MEXIT
.MNOTE2  MNOTE 8,'INVALID EDIT PATTERN'
         MEND
./       ADD   NAME=FINDVVDS
         TITLE ' - FINDVVDS. ADVANCE R6 TO A SPECIFIED VVDS CELL.'
* I ENTER HERE WITH R6 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF VVD0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF VVD0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF VVD0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
FINDVVDS $PROLOG R12
         L     R4,=V(DATASECT)                                     @130
         USING DATASECT,R4                                         @130
         L     R0,VVD0             PICK UP CALLERS PARM            @134
         ST    R6,VVD6             SAVE CELL ADDRESS
FINDVVD1 SR    R1,R1               CLEAR REGISTER
         SR    R15,R15             CLEAR PREVIOUS RETCODE.         @122
         ICM   R1,3,0(R6)          PICK UP LENGTH OF CURRENT CELL.
         LTR   R1,R1               IS THERE A LENGTH?              @132
         BNP   FINDVVDX            NO. HOW ODD!                    @132
         AR    R6,R1               SKIP OVER LENGTH
         C     R6,ENDVVD           ANY MORE CELLS IN THIS RECORD?
         BL    FINDVVD2            YES.
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDRESS
         ST    R0,VVD0             SAVE CALLERS PARM
         GET   RPL=(8)
         LTR   R15,R15             GET OK?                         @122
         BZ    FINDVVD3            YUP.                            @122
         C     R15,=F'8'           LOGICAL ERROR?                  @122
         BE    FINDVVD4            YES.                            @122
         ABEND 16,DUMP             OTHERWISE CRASH AND BURN.       @122
FINDVVD4 DS    0H                                                  @122
         SR    R2,R2                                               @122
         ICM   R2,1,RPLERRCD-IFGRPL(R1) GET REASON CODE.           @122
         CVD   R2,DTWORK           PACK IT.                        @122
         EDIT  FDBK,DWK3,ZZZ9      FORMAT NICELY.                  @122
        $MESSAGE 2,DATA=FDBK       SAY LOGICAL ERROR.              @122
         B     FINDVVDX            GO BACK WITH RC IN R15          @122
FINDVVD3 DS    0H                                                  @122
         AP    VVDSGETS,ONE        COUNT IT.
         L     R0,VVD0             RESTORE CALLERS PARM
         L     R6,VVDSBUF          ADDRESS OF RECORD JUST READ.
         L     R1,VVDSRPL          ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD JUST READ.
         AR    R1,R6               END OF RECORD.
         ST    R1,ENDVVD           SAVE FOR NEXT TIME.
         CLC   0(2,R6),=H'0'       ANYTHING IN THIS RECORD?        @132
         BNE   FINDVVD5            YES. LET'S DO IT.               @132
         SR    R0,R0               OOPS!                           @132
         B     FINDVVD9            GOBACK.                         @132
FINDVVD5 LA    R6,2(0,R6)          SKIP OVER PREFIX.
FINDVVD2 LTR   R0,R0               IF ZERO, ANYTHING WILL DO.
         BZ    FINDVVD9
         CLM   R0,1,2(R6)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDVVD9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDVVD1            NO, THEN KEEP LOOKING.
         L     R6,VVD6             RESTORE INITIAL CELL ADDRESS
         LA    R15,8               GIVE HIM THE SAD NEWS.          @134
FINDVVD9 DS    0H
         LR    R1,R13              GET SAVEAREA ADDRESS            @134
         L     R13,4(R13)          GET BACK CHAIN POINTER          @134
         L     R0,16(R13)          GET SAVEAREA LENGTH             @134
         ST    R15,16(R13)         SAVE REGISTER 15 (RETCODE)      @134
         ST    R6,44(R13)          SAVE REGISTER 15 (RETCODE)      @134
         FREEMAIN R,LV=(0),A=(1)   FREE SAVEAREA                   @134
         LM    R14,R12,12(R13)     RESTORE CALLERS REGS            @134
         L     R15,16(R13)         RESTORE RETURN CODE             @134
         BR    R14                 RETURN TO CALLER                @134
VVD9     DC    F'0'                SAVE R9 IN HERE.
VVD6     DC    F'0'                SAVE R6 IN HERE.
FINDVVDX LA    R15,8                                               @122
         B     FINDVVD9                                            @122
         DROP  R5
         LTORG ,                                                   @134
./       ADD   NAME=HEX
         MACRO
&NFS     HEX   &TO,&FROM,&L,&LEN=,&HEXTAB=,&BYTE=C' ',&DIGITS=
         GBLC  &HEXTAB#
         LCLA  &LT                      UNPK "TO" LENGTH
         LCLA  &LF                      UNPK "FROM" LENGTH
         LCLA  &LTR                     TR "TO" LENGTH
         LCLA  &LL                      &LEN ONE WAY OR ANOTHER
         LCLC  &F1,&F2,&T1,&T2,&LX
&F1      SETC  '&FROM(1)'               FOR SHORTER STRING LATER
&F2      SETC  '&FROM(2)'               FOR SHORTER STRING LATER
&T1      SETC  '&TO(1)'                 FOR SHORTER STRING LATER
&T2      SETC  '&TO(2)'                 FOR SHORTER STRING LATER
&LX      SETC  '&L&LEN'                 GET LENGTH USING EITHER METHOD
         AIF   ('&LX' EQ '').DEFLEN     LENGTH WILL DEFAULT TO 4
&LL      SETA  &LX                      GET IT
         AGO   .OKLEN
.DEFLEN  ANOP
&LL      SETA  4                        SET THE DEFAULT LENGTH
.OKLEN   AIF   ('&HEXTAB' EQ '').OKHEX1
&HEXTAB# SETC  '&HEXTAB'
.OKHEX1  AIF   ('&HEXTAB#' NE '').OKHEX2
&HEXTAB# SETC  'HEXTAB'
.OKHEX2  ANOP
&LT      SETA  &LL*2
         AIF   ('&DIGITS' EQ '').OKDIGIT
&LT      SETA  &DIGITS
.OKDIGIT AIF   (N'&TO NE 2).TO1
         AIF   (N'&FROM NE 2).T2F1
&NFS     UNPK  &T1.(&LT+1,&T2),&F1.(&LL+1,&F2)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.T2F1    AIF   (N'&FROM NE 1).ERRF
&NFS     UNPK  &T1.(&LT+1,&T2),&FROM.(&LL+1)
         TR    &T1.(&LT,&T2),&HEXTAB#
         MVI   &T1+&LT.(&T2),&BYTE
         AGO   .DONE
.TO1     AIF   (N'&TO NE 1).ERRT
         AIF   (N'&FROM NE 2).T1F1
&NFS     UNPK  &TO.(&LT+1),&F1.(&LL+1,&F2)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.T1F1    AIF   (N'&FROM NE 1).ERRF
&NFS     UNPK  &TO.(&LT+1),&FROM.(&LL+1)
         TR    &TO.(&LT),&HEXTAB#
         MVI   &TO+&LT,&BYTE
         AGO   .DONE
.ERRF    MNOTE 8,'ERROR IN "FROM" PARAMETER, MACRO TERMINATED'
         MEXIT
.ERRT    MNOTE 8,'ERROR IN "TO" PARAMETER, MACRO TERMINATED'
         MEXIT
.DONE    ANOP
         MEND
./       ADD   NAME=HEXPRINT
         TITLE ' - PRINT A HEX LISTING.'
*-------------------------------------------------------------*    @134
* EXIT FROM HERE IS BY EODAD TO EODICAT IN THE MAINLINE       *    @134
*-------------------------------------------------------------*    @134
HEXPRINT $PROLOG R10,R11,R12
         L     R4,=V(DATASECT)                                     @130
         USING DATASECT,R4                                         @130
         XPROPEN PWA,PAGELEN=PAGELEN,DDNAME=SYSPRINT
         LTR   R15,R15             DID SYSPRINT OPEN?
         BZ    HEXSYSOK            YES                             @134
         L     R15,=A(EODICAT)                                     @134
         BR    R15                 IF SYSPRINT DOESN'T OPEN        @134
HEXSYSOK DS    0H                                                  @134
         XPRHEAD PWA,LIST=(HEADER1,HEADER3)
         L     R15,=V(ALLVVDS)                                     @130
         BALR  R14,R15             ALLOCATE ALL VVDS'S             @130
         LA    R0,1                AUTHORIZATION ON.
         SVC   232                 **** INSTALLATION DEPENDANT ***
         SPACE ,
         L     R2,CVTPTR           A(CVT)
         L     R2,0(0,R2)          TCB WORDS
         L     R2,0(0,R2)          MY TCB.
         USING TCB,R2
         L     R2,TCBJSCB          TCB -> JSCB.
         DROP  R2
         USING IEZJSCB,R2
         L     R2,JSCBACT          ACTIVE JSCB.
         MODESET KEY=ZERO
         SPACE ,
*
* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING
* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER
* A BREAK.
*
         OI    JSCBSWT1,JSCBPASS
         SPACE ,
         MODESET KEY=NZERO
         OPEN  ACBICAT
         SR    R0,R0               AUTHORIZATION OFF.
         SVC   232                 **** INSTALLATION DEPENDANT ***
         L     R15,=A(GENRPL)                                      @134
         BALR  R9,R15              GENERATE RPL ADDR.              @134
GETNEXTH L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         LTR   R15,R15             RECORD READ OK?
         BZ    HEXGETOK            YES                             @AVV
         ICM   R2,15,RPLFDBK-IFGRPL(R1) GET FEEDBACK FIELD.        @AVV
         ABEND 16,DUMP             DIE, SUCKER.                    @AVV
HEXGETOK DS    0H                                                  @AVV
         L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R2,RPLICAT          GET RPL ADDR FROM LAST GET.
         L     R2,48(0,R2)         LENGTH OF RECORD READ
         AR    R2,R3               POINT TO END OF CATALOG RECORD
         LTR   R2,R2                                               @AVV
         BNP   GETNEXTH            SKIP A BOGUS RECORD.            @AVV
         ST    R2,ENDBCS           SAVE FOR FINDBCS ROUTINE
         LA    R3,2(,R3)           SKIP OVER PREFIX
HEXNEXT  CLI   2(R3),C'A'          A = NONVSAM
         BE    HEXNVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    HEXCLUST
         CLI   2(R3),C'D'          D = DATA COMPONENT
         BE    HEXDATA
         CLI   2(R3),C'I'          I = INDEX COMPONENT
         BE    HEXINDEX
ENDHEX   SR    R1,R1
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         LTR   R1,R1                                               @AVV
         BNP   GETNEXTH            SKIP IF BOGUS LENGTH.           @AVV
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    HEXNEXT             YES, KEEP GOING
         B     GETNEXTH            READ ANOTHER RECORD.
         TITLE ' - HEX PRINT A NONVSAM CELL.'
         USING NVNC,R3
HEXNVSAM MVC   L2TYPE,=CL7'NONVSAM'
         AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM             @120
         HEX   L2WORK,NVCELEN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF NVNC
         HEX   L2WORK+5,NVTYPE,                                        X
               1,HEXTAB=TRHEX      TYPE 'A' FOR NONVSAM
         HEX   L2WORK+8,NVRESV,                                        X
               1,HEXTAB=TRHEX      RESERVED
         HEX   L2WORK+11,NVOLCNT,                                      X
               2,HEXTAB=TRHEX      NUMBER OF VOLUME CELLS (255 MAX)
         HEX   L2WORK+16,NVKEYLN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE NONVSAM KEY
         MVC   L2WORK+19(44),NVNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAL   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX PRINT A CLUSTER CELL.'
         USING VCNC,R3
HEXCLUST MVC   L2TYPE,=CL7'CLUSTER'
         AP    CNTCLUST,ONE        COUNT A CLUSTER                 @120
         HEX   L2WORK,CLCELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF VCNC INCLUDING ITSELF
         HEX   L2WORK+5,CLTYPE,                                        X
               1,HEXTAB=TRHEX      TYPE 'C' FOR CLUSTER
         HEX   L2WORK+8,CLCOMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF THE CLUSTER COMPONENT
         HEX   L2WORK+13,CLNOEXT,                                      X
               1,HEXTAB=TRHEX      NUMBER OF EXTENSION RECORDS
         HEX   L2WORK+16,CLNMLEN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE CLUSTER KEY (45)
         MVC   L2WORK+19(44),CLNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAL   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAL   R9,HEXRELAT         RELATIONSHIP CELL (?)
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX PRINT A DATA OR INDEX CELL.'
         USING DINC,R3
HEXDATA  MVC   L2TYPE,=CL7'DATA'
         AP    CNTDATA,ONE         COUNT IT                        @120
         B     HEXDATA1
HEXINDEX MVC   L2TYPE,=CL7'INDEX'
         AP    CNTINDEX,ONE        COUNT IT.                       @120
HEXDATA1 HEX   L2WORK,DIDLEN,                                          X
               2,HEXTAB=TRHEX      LENGTH OF DINC
         HEX   L2WORK+5,DIDTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE 'D' FOR DATA OR INDEX
         HEX   L2WORK+8,DIDCMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF DINC COMPONENT
         HEX   L2WORK+13,DIDIRFLG,                                     X
               1,HEXTAB=TRHEX      INTERRUPT RECOGNITION FLAGS
         HEX   L2WORK+16,DIDKEYLN,                                     X
               1,HEXTAB=TRHEX      CONDENSED KEYLENGTH
         SR    R1,R1
         ICM   R1,1,DIDKEYLN       GET LENGTH OF NAME KEY.
         B     *+10
         MVC   L2WORK+19(0),DIDKEY
         EX    R1,*-6              MOVE IN NAME KEY.
         B     *+10
         MVC   SVCOMPN(0),DIDKEY   SAVE COMPONENT NAME
         EX    R1,*-6              MOVE IN NAME KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAL   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX AN OWNER CELL.'
HEXOWNER $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TYPE.
         L     R15,=V(FINDBCS)                                     @134
         BALR  R9,R15                                              @134
         USING OWNERC,R3
         MVC   L2TYPE,=CL7' OWNER'
         HEX   L2WORK,OWNCELLN,                                        X
               2,HEXTAB=TRHEX      LENGTH OF OWNERSHIP CELL
         HEX   L2WORK+5,OWNTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'01' FOR OWNER
         HEX   L2WORK+8,OWNID,                                         X
               4,HEXTAB=TRHEX      OWNER ID
         HEX   L2WORK+16,OWNID+4,                                      X
               4,HEXTAB=TRHEX      OWNER ID
         HEX   L2WORK+25,OWNFLAG,                                      X
               1,HEXTAB=TRHEX      FLAG
         HEX   L2WORK+28,OWNCREDT,                                     X
               3,HEXTAB=TRHEX      CREATION DATE
         HEX   L2WORK+35,OWNEXPDT,                                     X
               3,HEXTAB=TRHEX      EXPIRY DATE
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         $OUT  ,                   GET OUT.
         TITLE ' - HEX AN ASSOCIATION CELL.'
HEXASSOC $IN ,
         ICM   R0,3,=XL2'FF03'     TYPE X'03', OPTIONAL.
         L     R15,=V(FINDBCS)                                     @134
         BALR  R9,R15                                              @134
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXASS99            NO.
         USING ASSOCC,R3
         MVC   L2TYPE,=CL7' ASSOC'
         HEX   L2WORK,ASCLEN,                                          X
               2,HEXTAB=TRHEX      ASSOCIATION CELL LENGTH
         HEX   L2WORK+5,ASCTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'03' FOR ASSOC
         HEX   L2WORK+8,ASCOUNT,                                       X
               2,HEXTAB=TRHEX      COUNT OF ASSOCIATIONS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
HEXASS99 $OUT  ,                   GET OUT
         TITLE ' - HEX A SECURITY CELL.'
HEXSECUR $IN ,
         ICM   R0,3,=XL2'FF02'     TYPE X'02', OPTIONAL.
         L     R15,=V(FINDBCS)                                     @134
         BALR  R9,R15                                              @134
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXSEC99            NO.
         USING SECURITY,R3
         MVC   L2TYPE,=CL7' SECUR'
         HEX   L2WORK,SECELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF SECURITY CELL
         HEX   L2WORK+5,SECTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'02' FOR SECURITY.
         HEX   L2WORK+8,SECMSTR,                                       X
               4,HEXTAB=TRHEX      MASTER PASSWORD.
         HEX   L2WORK+16,                                              X
               SECMSTR+4,                                              X
               4,HEXTAB=TRHEX      MASTER PASSWORD.
         HEX   L2WORK+27,SECCI,                                        X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+35,SECCI+4,                                      X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+44,                                              X
               SECUPDTE,                                               X
               4,HEXTAB=TRHEX      UPDATE PASSWORD.
         HEX   L2WORK+52,                                              X
               SECUPDTE+4,                                             X
               4,HEXTAB=TRHEX      UPDATE PASSWORD.
         HEX   L2WORK+61,SECREAD,                                      X
               4,HEXTAB=TRHEX      READ PASSWORD.
         HEX   L2WORK+69,                                              X
               SECREAD+4,                                              X
               4,HEXTAB=TRHEX      READ PASSWORD.
         HEX   L2WORK+78,SECPMTCD,                                     X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+86,                                              X
               SECPMTCD+4,                                             X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+95,SECATMP,                                      X
               2,HEXTAB=TRHEX      MAXIMUM NUMBER OF ATTEMPTS.
         HEX   L2WORK+100,                                             X
               SECVRMOD,                                               X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+108,                                             X
               SECVRMOD+4,                                             X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+117,                                             X
               SECRCDLN,                                               X
               2,HEXTAB=TRHEX      USER AUTHORIZATION RECORD LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
HEXSEC99 $OUT  ,                   GET OUT
         TITLE ' - HEX A RELATION CELL.'
HEXRELAT $IN ,
         ICM   R0,3,=XL2'FF06'     OPTIONAL RELAT CELL
         L     R15,=V(FINDBCS)                                     @134
         BALR  R9,R15                                              @134
         LTR   R0,R0               WAS IT THERE?
         BZ    HEXREL99            NO.
         USING RELCELL,R3
         MVC   L2TYPE,=CL7' RELAT'
         HEX   L2WORK,RELLEN,                                          X
               2,HEXTAB=TRHEX      CELL LENGTH.
         HEX   L2WORK+5,RELTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'06'
         HEX   L2WORK+8,RELRESV,                                       X
               1,HEXTAB=TRHEX      RESERVED.
         HEX   L2WORK+11,RELCNT,                                       X
               1,HEXTAB=TRHEX      COUNT OF RELKEYS.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
HEXREL99 $OUT  ,                   GET OUT
         TITLE ' - HEX A VOLUME CELL.'
* THIS LOGIC IS ENTERED AT A POINT WHERE THERE MUST BE AT LEAST ONE
* VOLUME CELL POINTED TO BY R3. HOWEVER THERE COULD BE MORE THAN ONE.
* HENCE, AFTER THE FIRST NON-VOLUME CELL IS RECOGNIZED R3 MUST BE
* BACKED UP TO THE LAST VOLUME CELL SO THAT THE GENERAL CODE AT
* "ENDHEX" CAN SKIP OVER IT.
HEXVOL   $IN ,
HEXVOL0  ICM   R0,3,=XL2'FF04'     VOLUME CELL
         L     R15,=V(FINDBCS)                                     @134
         BALR  R9,R15                                              @134
         LTR   R0,R0               WAS THAT THE LAST ONE?
         BZ    HEXVOL99            YES.
         USING VOLCELL,R3
         MVC   L2TYPE,=CL7' VOLUME'
         HEX   L2WORK,VOLLEN,                                          X
               2,HEXTAB=TRHEX      LENGTH OF VOLCELL
         HEX   L2WORK+5,VOLTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'04' FOR VOLUME CELL
         HEX   L2WORK+8,VOLOFSET,                                      X
               1,HEXTAB=TRHEX      UNUSED
         MVC   L2WORK+11(6),VOLSERN
         HEX   L2WORK+18,VOLDEVTP,                                     X
               4,HEXTAB=TRHEX      DEVICE TYPE
         HEX   L2WORK+27,VOLFLAG1,                                     X
               1,HEXTAB=TRHEX      FLAG
         HEX   L2WORK+30,VOLFLAG2,                                     X
               1,HEXTAB=TRHEX      RESERVED
         HEX   L2WORK+33,VOLVVRBA,                                     X
               4,HEXTAB=TRHEX      RELATIVE BYTE ADDRESS OF VVR
         HEX   L2WORK+42,VOLFLSEQ,                                     X
               2,HEXTAB=TRHEX      NONVSAM FILE SEQUENCE NUMBER (TAPE)
         HEX   L2WORK+47,VOLKRQL,                                      X
               4,HEXTAB=TRHEX      KEYRANGE QUALIFIER (VSAM ONLY)
         HEX   L2WORK+56,VOLLKYLN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF LOW KEY RANGE KEY
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         TM    VOLFLAG1,VOLNVSAM   IS IT NONVSAM?
         BO    HEXVOL99            IF SO, THAT'S ALL
         TM    VOLFLAG1,VOLCANDI   IS IT A CANDIDATE VOLUME?
         BO    HEXVOL99            IF SO, THAT'S ALL
         MVC   RBASAVE,VOLVVRBA    SAVE RBA OF VVR
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
HEXVOL8  CLI   VVDSVOL,255         LAST ENTRY?
         BE    HEXVOL99            YES, OH WELL.
         CLC   VVDSVOL,VOLSERN     IS THIS THE VVDS?
         BNE   HEXVOL6             NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT TO ARG FIELD FOR THIS RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(8)             POSITION TO DESIRED RECORD
         GET   RPL=(8)             READ IN RECORD
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD ADDR
         LA    R6,2(,R6)           SKIP OVER PREFIX
         BAL   R9,HEXVVR           PRIMARY OR 2NDARY VVR
         BAL   R9,HEXDSINF         DATASET INFORMATION CELL (MAYBE)
         BAL   R9,HEXAMDSB         AMDSB CELL (IF PRESENT)
         BAL   R9,HEXVOLIN         VOLUME INFORMATION CELL.
         B     HEXVOL0             COULD BE MORE THAN ONE.
HEXVOL6  LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     HEXVOL8             WHAT IS IT JOHNNY?
HEXVOL99 $OUT  ,                   GET OUT.
         DROP  R3
         TITLE ' - HEX PRINT A VVR.'
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         USING VVR,R6
HEXVVR   $IN ,
         MVC   L2TYPE,=CL7' VVR'
HEXVVR0  CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
HEXVVR0A XC    VVD0,VVD0           NEXT CELL PLEASE.               @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         B     HEXVVR0             IS IT A VVR?
HEXVVR0B SR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     HEXVVR0C
         CLC   SVCOMPN(0),VVRCMPNM  (EXECUTED)
HEXVVR0C EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   HEXVVR0A            NO, MUST BE A RELATED COMPONENT.
         HEX   L2WORK,VVRHDLEN,                                        X
               2,HEXTAB=TRHEX
         HEX   L2WORK+5,VVRTYPE,                                       X
               1,HEXTAB=TRHEX
         HEX   L2WORK+8,VVRFLAG,                                       X
               1,HEXTAB=TRHEX
         HEX   L2WORK+11,VVRKRQ,                                       X
               4,HEXTAB=TRHEX
         HEX   L2WORK+20,VVRCMPNL,                                     X
               1,HEXTAB=TRHEX
         SR    R1,R1
         ICM   R1,1,VVRCMPNL       GET LENGTH OF COMPONENT KEY.
         B     *+10
         MVC   L2WORK+23(0),VVRCMPNM
         EX    R1,*-6              MOVE IN COMPONENT KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         $OUT  ,                   GET OUT.
         DROP  R6
         TITLE ' - HEX A DATASET INFORMATION CELL.'
HEXDSINF $IN ,
         MVC   VVD0,=X'0000FF21'   DATASET INFORMATION CELL.       @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         LTR   R15,R15             WAS THERE ONE?                  @134
         BNZ   HEXDSF99            NO.                             @134
         USING VVRDSINF,R6
         MVC   L2TYPE,=CL7' DSINFO'
         HEX   L2WORK,VVRDSLEN,                                        X
               2,HEXTAB=TRHEX      CELL LENGTH.
         HEX   L2WORK+5,VVRDSTYP,                                      X
               1,HEXTAB=TRHEX      TYPE CODE IS X'21'
         HEX   L2WORK+8,VVRATTR1,                                      X
               1,HEXTAB=TRHEX      DATASET ATTRIBUTES
         HEX   L2WORK+11,VVRATTR2,                                     X
               1,HEXTAB=TRHEX      DATASET ATTRIBUTES
         HEX   L2WORK+14,VVROPIND,                                     X
               1,HEXTAB=TRHEX      OPEN INDICATOR
         HEX   L2WORK+17,VVRBUFSZ,                                     X
               4,HEXTAB=TRHEX      MINIMUM BUFFER SIZE
         HEX   L2WORK+26,VVRPRISP,                                     X
               3,HEXTAB=TRHEX      PRIMARY SPACE ALLOCATION
         HEX   L2WORK+33,VVRSECSP,                                     X
               3,HEXTAB=TRHEX      SECONDARY SPACE ALLOCATION
         HEX   L2WORK+40,VVRSPCFG,                                     X
               1,HEXTAB=TRHEX      SPACE FLAGS
         HEX   L2WORK+43,VVRDSHU,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH USED RBA
         HEX   L2WORK+52,VVRDSHA,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH ALLOCATED RBA
         HEX   L2WORK+61,VVRLRECL,                                     X
               4,HEXTAB=TRHEX      AVERAGE LOGICAL RECORD LENGTH
         HEX   L2WORK+70,VVREXCPX,                                     X
               4,HEXTAB=TRHEX      EXCEPTION EXIT.
         HEX   L2WORK+78,VVREXCPX+4,                                   X
               4,HEXTAB=TRHEX      EXCEPTION EXIT.
         HEX   L2WORK+87,VVRDSHK,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH KEY RBA.
         HEX   L2WORK+96,VVRCLSFG,                                     X
               1,HEXTAB=TRHEX      CLUSTER ATTRIBUTE FLAG
         HEX   L2WORK+99,VVRAIXFG,                                     X
               1,HEXTAB=TRHEX      AIX ATTRIBUTE FLAG
         HEX   L2WORK+102,VVRTMSTP,                                    X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         HEX   L2WORK+110,VVRTMSTP+4,                                  X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
HEXDSF99 $OUT  ,                   GET OUT
         TITLE ' - HEX AN AMDSB CELL.'
HEXAMDSB $IN ,
         MVC   VVD0,=X'0000FF60'   AMDSB CELL                      @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         LTR   R15,R15             WAS THERE ONE?                  @134
         BNZ   HEXAMD99            NO.                             @134
         USING VVRAMDCL,R6
         MVC   L2TYPE,=CL7' AMDSB'
         HEX   L2WORK+00,VVRAMDCN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF AMDSB CELL
         HEX   L2WORK+05,VVRAMID,                                      X
               1,HEXTAB=TRHEX      TYPE CODE IS X'60'
         HEX   L2WORK+08,VVRAMATR,                                     X
               1,HEXTAB=TRHEX      ATTRIBUTES:
         HEX   L2WORK+11,VVRAMLEN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF AMDSB
         HEX   L2WORK+16,VVRAMNST,                                     X
               2,HEXTAB=TRHEX      NUMBER OF ENTRIES IN INDEX SECTION
         HEX   L2WORK+21,VVRAMRKP,                                     X
               2,HEXTAB=TRHEX      RKP
         HEX   L2WORK+26,VVRAMKNL,                                     X
               2,HEXTAB=TRHEX      KEY LENGTH
         HEX   L2WORK+31,VVRAMPCA,                                     X
               1,HEXTAB=TRHEX      % FREE CI IN CA
         HEX   L2WORK+34,VVRAMPCI,                                     X
               1,HEXTAB=TRHEX      % FREE BYTES IN CI
         HEX   L2WORK+37,VVRAMCCA,                                     X
               2,HEXTAB=TRHEX      CI'S PER CA
         HEX   L2WORK+42,VVRAMFCA,                                     X
               2,HEXTAB=TRHEX      FREE CI'S PER CA
         HEX   L2WORK+47,VVRAMFCI,                                     X
               4,HEXTAB=TRHEX      FREE BYTES PER CI
         HEX   L2WORK+56,VVRAMCIV,                                     X
               4,HEXTAB=TRHEX      CONTROL INTERVAL SIZE
         HEX   L2WORK+65,VVRAMLCL,                                     X
               4,HEXTAB=TRHEX      MAXIMUM RECORD SIZE
         HEX   L2WORK+74,VVRAMSLT,                                     X
               4,HEXTAB=TRHEX      SLOTS PER CI
         HEX   L2WORK+83,VVRAMMRR,                                     X
               4,HEXTAB=TRHEX      MAXIMUM RELATIVE RECORD NUMBER
         HEX   L2WORK+92,VVRAMARB,                                     X
               4,HEXTAB=TRHEX      POINTER TO 1ST ARDB
         HEX   L2WORK+101,VVRAMAT3,                                    X
               1,HEXTAB=TRHEX      ATTRIBUTES
         HEX   L2WORK+104,VVRAMSNO,                                    X
               1,HEXTAB=TRHEX      NUMBER OF CONCURRENT REQUESTS
         HEX   L2WORK+107,VVRAMBFD,                                    X
               2,HEXTAB=TRHEX      NUMBER OF DATA BUFFERS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         HEX   L2WORK+00,VVRAMSTS,                                     X
               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP
         HEX   L2WORK+08,VVRAMSTS+4,                                   X
               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP
         HEX   L2WORK+17,VVRAMNIL,                                     X
               2,HEXTAB=TRHEX      NUMBER OF INDEX LEVELS
         HEX   L2WORK+22,VVRAMNXT,                                     X
               2,HEXTAB=TRHEX      NUMBER OF EXTENTS
         HEX   L2WORK+27,VVRAMNLR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF LOGICAL RECORDS
         HEX   L2WORK+38,VVRAMDLR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF DELETED RECORDS
         HEX   L2WORK+47,VVRAMINR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF INSERTED RECORDS
         HEX   L2WORK+56,VVRAMUPR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF UPDATED RECORDS
         HEX   L2WORK+65,VVRAMRTR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF RETRIEVED RECORDS
         HEX   L2WORK+74,VVRAMASP,                                     X
               4,HEXTAB=TRHEX      BYTES OF FREE SPACE IN DATASET
         HEX   L2WORK+83,VVRAMCIS,                                     X
               4,HEXTAB=TRHEX      NUMBER OF CI SPLITS
         HEX   L2WORK+92,VVRAMCAS,                                     X
               4,HEXTAB=TRHEX      NUMBER OF CA SPLITS
         HEX   L2WORK+101,VVRAMEXC,                                    X
               4,HEXTAB=TRHEX      NUMBER OF EXCPS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
HEXAMD99 $OUT  ,                   GET OUT
         TITLE ' - HEX A VOLUME INFORMATION CELL.'
HEXVOLIN $IN ,
         MVC   VVD0,=X'0000FF23'   VOLUME INFORMATION CELL         @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         LTR   R15,R15             WAS THERE ONE?                  @134
         BNZ   HEXVLN99            NO.                             @134
         USING VVRVOLIN,R6
         MVC   L2TYPE,=CL7' VOLINF'
         HEX   L2WORK+00,VVRVOLLN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF VOLUME CELL
         HEX   L2WORK+05,VVRVOLTP,                                     X
               1,HEXTAB=TRHEX      TYPE CODE IS X'23'
         HEX   L2WORK+08,VVRVOLFG,                                     X
               1,HEXTAB=TRHEX      VOLUME FLAGS
         HEX   L2WORK+11,VVRNOEXT,                                     X
               1,HEXTAB=TRHEX      NUMBER OF EXTENTS ON THIS VOLUME.
         HEX   L2WORK+14,VVRHKRBA,                                     X
               4,HEXTAB=TRHEX      HIGH KEY RBA
         HEX   L2WORK+23,VVRHURBA,                                     X
               4,HEXTAB=TRHEX      HIGH USED RBA
         HEX   L2WORK+32,VVRHARBA,                                     X
               4,HEXTAB=TRHEX      HIGH ALLOCATED RBA
         HEX   L2WORK+41,VVRBLKSZ,                                     X
               4,HEXTAB=TRHEX      BLOCK SIZE
         HEX   L2WORK+50,VVRBLKTK,                                     X
               2,HEXTAB=TRHEX      NUMBER OF BLOCKS PER TRACK
         HEX   L2WORK+55,VVRTRKAU,                                     X
               2,HEXTAB=TRHEX      NUMBER OF TRACKS PER ALLOCATION UNIT
         HEX   L2WORK+60,VVRTPEXT,                                     X
               1,HEXTAB=TRHEX      EXTENT TYPE FLAG
         HEX   L2WORK+63,VVRTKCYL,                                     X
               2,HEXTAB=TRHEX      TRACKS PER CYLINDER
         HEX   L2WORK+68,VVRBYTTK,                                     X
               4,HEXTAB=TRHEX      BYTES PER TRACK.
         HEX   L2WORK+77,VVRBYTAU,                                     X
               4,HEXTAB=TRHEX      BYTES PER ALLOCATION UNIT
         HEX   L2WORK+86,VVRLOKYL,                                     X
               2,HEXTAB=TRHEX      LOW KEY LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         ST    R5,HEXR5            SAVE VVDSTAB BASE REG
         SR    R5,R5
         ICM   R5,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LR    R8,R6
         LA    R8,40(0,R8)         POINT TO EXTENT DESCR.
         USING VVRXTENT,R8
HEXVLN97 HEX   L2WORK+00,VVRXSEQN,                                     X
               2,HEXTAB=TRHEX      SEQUENCE NUMBER
         HEX   L2WORK+05,VVRXSCH,                                      X
               4,HEXTAB=TRHEX      STARTING CCHH
         HEX   L2WORK+14,VVRXECH,                                      X
               4,HEXTAB=TRHEX      ENDING CCHH
         HEX   L2WORK+23,VVRXNTRK,                                     X
               2,HEXTAB=TRHEX      NUMBER OF TRACKS
         HEX   L2WORK+28,VVRXSRBA,                                     X
               4,HEXTAB=TRHEX      STARTING RBA
         HEX   L2WORK+37,VVRXERBA,                                     X
               4,HEXTAB=TRHEX      ENDING RBA
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         L     R15,=V(PRINT)       PRINT SUBROUTINE                @134
         BALR  R9,R15              PRINT LINE                      @134
         LA    R8,20(0,R8)         POINT TO NEXT EXTENT DESCR.
         BCT   R5,HEXVLN97         FORMAT ALL EXTENTS
         L     R5,HEXR5            RESTORE VVDSTAB BASE REG
HEXVLN99 $OUT  ,                   GET OUT
HEXR5    DC    F'0'                I'M RUNNING OUT OF REGISTERS
         DROP  R8
         LTORG ,                                                   @134
./       ADD   NAME=LISTICAT
         PRINT NOGEN
         COPY  $DOC
&NAME    SETC  'LISTICAT'
&VERSION SETC  '1.3.4'
         PUNCH ' SETCODE AC(1) '
LISTICAT TITLE ' - LIST AN ICF CATALOG.'
         $REGS
LISTICAT $PROLOG R10,R11,R12
         LR    R6,R1               SAVE JCL PARM
         L     R4,=V(DATASECT)     COMMON DATA AREA
         USING DATASECT,R4
        $MESSAGE 1                                                 @122
         L     R15,=V(PARMS)       ADDRESS OF PARM DECODER.        @130
         BALR  R14,R15             GO TO IT.                       @130
         LR    R1,R6               RESTORE JCL PARM
         L     R1,0(0,R1)          GET PARM POINTER
         LH    R2,0(0,R1)          GET PARM SIZE
         LTR   R2,R2               ANY PARM GIVEN?
         BZ    NOPARM              NO, ASSUME LIST
         BCTR  R2,0                MAKE IT THE MACHINE LENGTH   15JAN88
         ST    R2,DSPFXL           SAVE PREFIX PARM LENGTH      15JAN88
         EX    R2,MOVEPFX          SAVE THE PARM PREFIX         15JAN88
         B     NOPARM                                           15JAN88
MOVEPFX  MVC   DSPFX(0),2(R1)      EXECUTED INSTRUCTION!        15JAN88
NOPARM   DS    0H
         TM    FLAGS1,DUMP         HEX LISTING WANTED?             @130
         BZ    NOTHEX              NO.                             @134
         L     R15,=V(HEXPRINT)    HEXPRINT ROUTINE                @134
         BR    R15                 GO THERE                        @134
NOTHEX   DS    0H                                                  @134
         XPROPEN PWA,                                                  X
               PAGELEN=PAGELEN,                                        X
               DDNAME=SYSPRINT     OPEN LISTING FILE.
         LTR   R15,R15             DID SYSPRINT OPEN?
         BNZ   EODICAT             IF NOT, NO REPORT.
         L     R15,=V(ALLVVDS)                                     @130
         BALR  R14,R15             ALLOCATE ALL VVDS'S             @130
         SPACE ,
         LA    R0,1                INDICATE AUTHORIZATION ON.
         SVC   232                 ***** INSTALLATION DEPENDANT ******
         SPACE ,
         L     R2,CVTPTR           A(CVT)
         L     R2,0(0,R2)          TCB WORDS
         L     R2,0(0,R2)          MY TCB.
         USING TCB,R2
         L     R2,TCBJSCB          TCB -> JSCB.
         DROP  R2
         USING IEZJSCB,R2
         L     R2,JSCBACT          ACTIVE JSCB.
         MODESET KEY=ZERO          JSCB IS IN KEY ZERO.
         SPACE ,
*
* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING
* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER
* A BREAK.
*
         OI    JSCBSWT1,JSCBPASS   SAY, NO PASSWORDS PLEASE.
         SPACE ,
         MODESET KEY=NZERO         BACK TO USER KEY.
         OPEN  ACBICAT             OPEN THE BCS CLUSTER.
         LTR   R15,R15             DID IT OPEN?
         BZ    OPENOK              YES.
         SHOWCB  ACB=ACBICAT,                                          X
               AREA=OPENERR,                                           X
               LENGTH=4,                                               X
               FIELDS=(ERROR)      STORE OPEN ERROR CODE.
         L     R3,OPENERR          PICK ERROR CODE.
         ABEND 14,DUMP             AND DIE.
OPENOK   MODESET KEY=ZERO          KEY ZERO TO MODIFY JSCB.
         NI    JSCBSWT1,255-JSCBPASS  BYPASS PASSWORD OFF.
         MODESET KEY=NZERO         BACK TO USER KEY.
         DROP  R2
         SR    R0,R0               INDICATE AUTHORIZATION OFF.
         SVC   232                 ***** INSTALLATION DEPENDANT. *****
         BAL   R9,GENRPL           GENERATE RPL FOR BCS.           @120
         TITLE ' - READ BCS RECORDS AND SCAN FOR CELL TYPES.'
GETNEXT  L     R1,RPLICAT          PICK UP RPL ADDRESS.
         GET   RPL=(1)             READ A BCS RECORD.
         AP    BCSGETS,ONE         KEEP TRACK OF GETS ISSUED.
         LTR   R15,R15             RECORD READ OK?
         BZ    GETOK               GO PROCESS IT.
         ABEND 15,DUMP             TOO BAD!
GETOK    L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R1,RPLICAT          ADDR OF BCS RPL.
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R3               POINT TO END OF CATALOG RECORD
         ST    R1,ENDBCS           SAVE END OF RECORD.
         LA    R3,2(,R3)           SKIP OVER PREFIX
NEXTCELL CLI   2(R3),C'A'          A = NONVSAM
         BE    NONVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    CLUSTER
         CLI   2(R3),C'D'          D = DATA
         BE    DATA
         CLI   2(R3),C'I'          I = INDEX
         BE    INDEX
         CLI   2(R3),C'B'          B = GDG BASE
         BE    GDGBASE
         CLI   2(R3),X'05'         X'05' = GDG AGING TABLE      16DEC86
         BE    GDGAGE                                           16DEC86
         CLI   2(R3),C'H'          H = GDG ENTRY
         BE    GDGENT
         CLI   2(R3),C'G'          G = ALTERNATE INDEX
         BE    AIX
         CLI   2(R3),C'R'          R = PATH
         BE    PATH
         CLI   2(R3),X'04'         X'04' = VOLUME CELL          13JAN88
         BE    VOLCEL                                           13JAN88
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
ENDCELL  XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         SR    R1,R1               CLEAR REGISTER.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         LTR   R1,R1                                               @AVV
         BNP   GETNEXT            SKIP ZERO LENGTH CELL (?)        @AVV
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    NEXTCELL            YES, KEEP GOING
         B     GETNEXT             READ ANOTHER RECORD.
EODICAT  EQU   *                   LAST BCS RECORD READ.
         CLOSE ACBICAT
         CLI   MCDSOPEN,255        DID WE OPEN THE MCDS?           @122
         BNE   EODICAT1            NO.                             @122
         CLOSE ACBMCDS             IF OPEN, CLOSE IT.              @122
EODICAT1 DS    0H                                                  @122
         BAL   R9,COUNTS           PRINT THE STATS.
         XPRCLOSE  PWA             CLOSE THE PRINT FILE.
        $MESSAGE 0                                                 @122
         $EPILOG ,                 AND GO HOME.
         TITLE ' - LIST A NONVSAM RECORD.'
         USING NVNC,R3
NONVSAM  AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   NONVSAM1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
NONVSAM1 MVC   L1DSNAME,NVNAME     SETUP DSNAME
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,NONVSAML,ENDCELL       @130
NONVSAML DS    0H                                                  @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,NONVSAMN    @130
NONVSAMN DS    0H                                                  @130
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    NONVCON2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    NONVCON1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTNVSAM,ONE        NO MATCH, DON'T PUT IN COUNT 15JAN88
         B     NONVCON2            CONTINUE PROCESS             15JAN88
NONVCON1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
NONVCON2 EQU   *                                                15JAN88
         MVC   L1TYPE,=C'NONVSAM'  SAY WHAT TYPE IT IS.
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,NONVSAMV,ENDCELL      @130
NONVSAMV DS    0H                                                  @130
        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,NONVSAMX   @130
NONVSAMX DS    0H                                                  @130
         MVC   L1UNIT,=C'????'     CALL IT ???? IF UNIT NOT FOUND.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
NONVSAM3 CLC   VOLDEVTP,0(R5)      IS THIS IT
         BE    NONVSAM4            YES. GO GET DEVICE TYPE.
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    NONVSAM5            LEAVE IT AT ????
         B     NONVSAM3            CHECK NEXT DEVICE TYPE.
NONVSAM4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
         TM    2(R5),X'20'         IS IT A DASD DEVICE?
         BZ    NONVSAM5            IF NOT, NO VTOC TO SEARCH.
         L     R15,=V(VTOC)                                        @134
         BALR  R14,R15             GET DSCB FIELDS.                @134
NONVSAM5 CLC   L1VOLUME,=C'MIGRAT' IS IT MIGRATED BY HSM
         BNE   NONVSAM6            IF NOT, SKIP MCDS CHECK.
         BAL   R9,CHKHSM           SETUP MCDS FIELDS.
NONVSAM6 L     R1,LRECL            PICK UP LRECL VALUE.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY
*  THE FULL WORD TRACKS IS BEING USED AS A INDICATOR FOR THE DATASET
*  BEING CATALOGED BUT NOT FOUND ON THE PACK THAT IT'S CATALOGED ON.
         CLC   TRACKS,=XL4'FFFFFFFF' IS THE DATAST NOT ON PACK  30NOV87
         BNE   NONVSAM7            IF WAS FOUND, BRANCH AROUND. 30NOV87
         XC    TRACKS,TRACKS       ELSE, CLEAR OUT TRACKS CTR.  30NOV87
         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87
NONVSAM7 EQU   *                                                30NOV87
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,                                               X
               DWK4,ZZZZZZZ        FORMAT IT NICELY.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         DROP  R3
         TITLE ' - LIST THE SECOND TO N-TH VOLUME CELLS'        13JAN88
         USING VOLCELL,R3                                       13JAN88
VOLCEL   EQU   *                                                13JAN88
         CLI   VOLSW,255           WAS VOL CELL IMMED. BEFORE   13JAN88
         BE    VOLCEL1        YES, PRINT THE CELL INFO          13JAN88
         B     ENDCELL        NO,  PROCESS NEXT BCS CELL.       13JAN88
VOLCEL1  MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER   13JAN88
         MVC   L1UNIT,=C'????'  CALL IT ???? IF UNIT NOT FOUND. 13JAN88
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.           13JAN88
VOLCEL2  CLC   VOLDEVTP,0(R5)      IS THIS IT                   13JAN88
         BE    VOLCEL3             YES. GO GET DEVICE TYPE.     13JAN88
         LA    R5,12(,R5)          NEXT DEVICE ENTRY            13JAN88
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE                 13JAN88
         BE    VOLCEL4             LEAVE IT AT ????             13JAN88
         B     VOLCEL2             CHECK NEXT DEVICE TYPE.      13JAN88
VOLCEL3  MVC   L1UNIT,4(R5)    SET UP DEVICE TYPE IN PRINT LINE 13JAN88
VOLCEL4  MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1 13JAN88
         BAL   R9,PRINT            PRINT LINE.                  13JAN88
         B     ENDCELL             PROCESS NEXT BCS CELL.       13JAN88
         DROP  R3                                               13JAN88
         TITLE ' - LIST A CLUSTER RECORD.'
         USING VCNC,R3
CLUSTER  AP    CNTCLUST,ONE        COUNT A CLUSTER.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER1 DS    0H
         CLI   CLNAME,X'00'        DOES THE NAME START WITH X'00'
         BNE   MVWHOLE             NO MOVE THE REAL NAME
         MVC   L1DSNAME(23),=C'INDEXED CATALOG CLUSTER'   ELSE USE THIS
         B     MVCLUSTR            CONTINUE WITH CLUSTER ROUTINE
MVWHOLE  EQU   *
         MVC   L1DSNAME,CLNAME     SETUP CLUSTER NAME.
MVCLUSTR EQU   *
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    CLSTCON2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    CLSTCON1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTCLUST,ONE        NOMATCH DON'T INCL IN COUNT  15JAN88
         B     CLSTCON2            CONTINUE PROCESS             15JAN88
CLSTCON1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
CLSTCON2 EQU   *                                                15JAN88
         MVC   L1TYPE,=C'CLUSTER'  CALL IT A CLUSTER.
         CLI   FIRST,0             FIRST CLUSTER CELL?
         BNE   NOTCL00             NO
         MVI   FIRST,255           THAT WAS THE ONE.
         ST    R3,SAVECL           FIRST CLUSTER HAS BCS NAME.
GETBCSD  SR    R1,R1               CLEAR A FEW BYTES.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         CLI   2(R3),C'D'          IS IT A DATA CELL?
         BNE   GETBCSD             KEEP ON LOOKING.
         DROP  R3
         USING DINC,R3
         SR    R1,R1                                               @121
         IC    R1,DIDKEYLN         GET LENGTH OF CATALOG NAME.     @121
         SH    R1,=H'2'            DROP TWO BYTES OF JUNK          @130
         B     *+10                                                @121
         MVC   CATNAME(0),DIDKEY   SETUP CATNAME IN HEADING.       @121
         EX    R1,*-6                                              @121
         BAL   R9,SETHEAD          DEFINE REPORT HEADING.
         L     R3,SAVECL           RESTORE CELL ADDR TO CLUSTER.
NOTCL00  BAL   R9,SETCREDT         FORMAT CREATION DATE.
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,CLUSTERL,ENDCELL       @130
CLUSTERL DS    0H                                                  @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,CLUSTERN    @130
CLUSTERN DS    0H                                                  @130
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         DROP  R3
         USING DINC,R3
DATA     MVC   L1TYPE,=CL7'DATA'   DATA CELL (PARDON THE EXPRESSION)
         AP    CNTDATA,ONE         COUNT IT.
         B     SKIPDATA            GOTO COMMON FORMATTING LOGIC.
INDEX    MVC   L1TYPE,=CL7'INDEX'  CALL IT AN INDEX
         AP    CNTINDEX,ONE        AND COUNT IT.
SKIPDATA SR    R1,R1               CLEAR A REGISTER.
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         IC    R1,DIDKEYLN         LENGTH OF INDEX/DATA NAME
         SH    R1,=H'2'            CORRECT LENGTH PLEASE           @130
         EX    R1,DIDMOVE          MOVE COMPONENT NAME FOR PRINT
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    CLSTRCN2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    CLSTRCN1            MATCH, TURN ON PRINT         15JAN88
         CLI   L1TYPE,C'D'         WAS IT DATA TYPE             15JAN88
         BNE   CLSTRCN3         NO,CHECK FOR INDEX              15JAN88
         SP    CNTDATA,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     CLSTRCN2            CONTINUE PROCESS             15JAN88
CLSTRCN3 CLI   L1TYPE,C'I'         WAS IT INDEX TYPE            15JAN88
         BNE   CLSTRCN2         NO,CONTINUE PROCESS             15JAN88
         SP    CNTINDEX,ONE        DON'T INCLUDE IN COUNT       15JAN88
         B     CLSTRCN2            CONTINUE PROCESS             15JAN88
CLSTRCN1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
CLSTRCN2 EQU   *                                                15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER2            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER2 BAL   R9,SETCREDT         FORMAT CREATION DATE.
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,DATIDXL,ENDCELL        @130
DATIDXL  DS     0H                                                 @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,DATIDXN     @130
DATIDXN  DS     0H                                                 @130
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,CLUSTERV,ENDCELL      @130
CLUSTERV DS    0H                                                  @130
        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,CLUSTERX   @130
CLUSTERX DS    0H                                                  @130
         MVC   L1UNIT,=C'????'     JUST IN CASE OF UNKNOWN DEVICE.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
CLUSTER3 CLC   VOLDEVTP,0(R5)      IS THIS IT?
         BE    CLUSTER4            YES
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    CLUSTER5            LEAVE IT ????
         B     CLUSTER3            TRY NEXT DEVICE TYPE.
CLUSTER4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
CLUSTER5 MVC   RBASAVE,VOLVVRBA    SAVE RBA OF CI CONTAINING VVR CELL.
         DROP  R3
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
CLUSTER8 CLI   VVDSVOL,255         LAST ENTRY?
         BE    CLUSTER7            YES, OH WELL.
         CLC   VVDSVOL,L1VOLUME    IS THIS THE VVDS?
         BNE   CLUSTER6            NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT INTO ARG FIELD FOR RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(8)             POSITION TO DESIRED RECORD
         GET   RPL=(8)             READ IN RECORD
         AP    VVDSGETS,ONE        KEEP A COUNT.
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD
         LA    R6,2(,R6)           SKIP OVER PREFIX
         L     R15,=V(VVDS)                                        @134
         BALR  R14,R15             PROCESS VVDS FIELDS.            @134
         C     R15,=F'8'           DID WE GET THEM?                @122
         BNE   CLUSTER6            YES.                            @122
        $MESSAGE 4,DATA=L1DSNAME                                   @122
         B     CLUSTER9            PRINT WHAT WE GOT.              @122
CLUSTER6 LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     CLUSTER8            TRY NEXT VVDS
         DROP  R5
CLUSTER7 L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          GET PHYSICAL BLOCK LENGTH.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,                                               X
               DWK3,ZZZZZ          FORMAT IT NICELY.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,                                               X
               DWK4,ZZZZZZZ        FORMAT IT NICELY.
CLUSTER9 DS    0H                                                  @122
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         USING DINC,R3
DIDMOVE  MVC   L1DSNAME(0),DIDKEY  -> (EXECUTED) <-
         DROP  R3
         TITLE ' - LIST AN ALTERNATE INDEX RECORD.'
         USING ANC,R3
AIX      AP    CNTAIX,ONE          COUNT AN AIX ENTRY.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   AIX0                NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
AIX0     MVC   L1TYPE,=CL7'AIX'    CALL IT AN AIX.
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,AIXKEYLN       PICK UP AIX NAME LENGTH
         SH    R1,=H'2'            CORRECT LENGTH.                 @130
         B     AIX1                BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),AIXKEY  EXECUTED
AIX1     EX    R1,*-6              MOVE AIX NAME TO PRINT LINE.
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    AIXCONT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    AIXCONT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTAIX,ONE          DON'T INCLUDE IN COUNT       15JAN88
         B     AIXCONT2            CONTINUE PROCESS             15JAN88
AIXCONT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
AIXCONT2 EQU   *                                                15JAN88
         HEX   RPTLINE1+75,                                            X
               ANC,7,HEXTAB=TRHEX  HEX TRANSLATE AIX CELL CONTENTS.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         TITLE ' - LIST A PATH RECORD.'
         USING PNC,R3
PATH     AP    CNTPATH,ONE         COUNT A PATH CELL.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   PATH0               NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
PATH0    MVC   L1TYPE,=CL7'PATH'   CALL IT A PATH.
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,PATHKYLN       PICK UP PATH NAME LENGTH
         SH    R1,=H'2'            CORRECT LENGTH                  @130
         B     PATH1               BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),PATHNAME  EXECUTED
PATH1    EX    R1,*-6              MOVE PATH NAME TO PRINT LINE.
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    PATHCNT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    PATHCNT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTPATH,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     PATHCNT2            CONTINUE PROCESS             15JAN88
PATHCNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
PATHCNT2 EQU   *                                                15JAN88
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         TITLE ' - LIST A GDG BASE OR GDG ENTRY RECORD.'
         USING GDGNC,R3
GDGBASE  AP    CNTGDGB,ONE         COUNT A BASE.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   GDGBASE1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
GDGBASE1 MVI   BASESW,255          IDENTIFY GDGBASE.
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,GDGBASEL,ENDCELL       @134
GDGBASEL DS    0H                                                  @134
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,GDGBASEN    @134
GDGBASEN DS    0H                                                  @134
         MVC   L1TYPE,=CL7'GDGBASE'  IDENTIFY RECORD TYPE
         MVC   L1DSNAME,GDGNAME    SETUP GDGNAME.
         MVC   GDGSAVE,GDGNAME     SAVE GDGNAME.
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    GDGBCNT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    GDGBCNT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTGDGB,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     GDGBCNT2            CONTINUE PROCESS             15JAN88
GDGBCNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
GDGBCNT2 EQU   *                                                15JAN88
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
*
* THE FOLLOWING HAVE BEEN TAKEN OUT FOR LOCAL DEUTZ-ALLIS       16DEC86
*  MODIFICATION TO GIVE GDG AGING INFORMATION ON THE REPORT     16DEC86
*                                                               16DEC86
*        LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1 16DEC86
*        BAL   R9,PRINT            PRINT LINE.                  16DEC86
*                                                               16DEC86
         B     ENDCELL             PROCESS NEXT CELL.
         DROP  R3
         USING GATC,R3
GDGAGE   EQU   *                    GDG AGING CELL ROUTINE      16DEC86
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,GDGAGEL1,ENDCELL       @134
GDGAGEL1 DS    0H                                                  @134
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,GDGAGEN1    @134
GDGAGEN1 DS    0H                                                  @134
         MVC   L1GDGSCR,=CL9'SCRATCH  '  MOVE SCRATCH TO PRINT  16DEC86
         TM    GATATTR,GATSCRTH        IS ATTRIBUTE "SCRATCH"?  16DEC86
         BO    GDGAGE1                YES, PRINT ALREADY MOVED  16DEC86
         MVC   L1GDGSCR,=CL9'NOSCRATCH'  ELSE, MOVE NOSCRATCH   16DEC86
GDGAGE1  MVC   L1GDGEMP,=CL7'EMPTY  '  MOVE EMPTY TO PRINT LINE 16DEC86
         TM    GATATTR,GATDELET        IS ATTRIBUTE "EMPTY"?    16DEC86
         BO    GDGAGE2                YES, PRINT ALREADY MOVED  16DEC86
         MVC   L1GDGEMP,=CL7'NOEMPTY'  ELSE, MOVE NOEMPTY       16DEC86
GDGAGE2  SR    R8,R8                  ZERO THE REGISTER         16DEC86
         ICM   R8,1,GATLIMIT          INSERT # MAX GDGS IN REG  16DEC86
         CVD   R8,WORK                CONVERT IT TO DECIMAL     16DEC86
         EDIT  L1GDGMAX,DWK2,ZZZZ     FORMAT NICE FOR PRINT     16DEC86
         CLC   GATCNT,=BL1'00'     NO GENERATIONS IN GDG?       09DEC87
         BNE   GDGAGE3             NUMBER OF ENTRIES NOT ZERO.  09DEC87
         MVI   L1DSNAME+45,C'+'    OTHERWISE MARK WITH A + SIGN 09DEC87
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN   15JAN88
         BE    GDGAGE2A         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD LENGTH OF PREFIX        15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BNE   GDGAGE3        YES, DON'T ADD TO COUNT           15JAN88
GDGAGE2A AP    CNTNOENT,ONE    COUNT A GDGBASE WITH NO ENTRIES. 09DEC87
GDGAGE3  LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1 16DEC86
         BAL   R9,PRINT            PRINT LINE.                  16DEC86
         B     ENDCELL             PROCESS NEXT CELL            16DEC86
         DROP  R3                                               16DEC86
         USING GDSNC,R3
GDGENT   AP    CNTGDGE,ONE         COUNT IT.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          PRECEEDED BY GDGBASE?
         BNE   GDGENT0             ???????
         MVI   BASESW,0            SWITCH OFF
GDGENT0  MVC   L1TYPE,=CL7'GDG ENT'  IDENTIFY RECORD TYPE
         MVC   GDGWORK,GDGSAVE     START WITH BASE NAME.
         LA    R1,GDGWORK          GET ADDRESS OF BASE NAME
         LA    R8,44               44 BYTES AT MOST
GDGENT1  CLI   0(R1),C' '          SCAN FOR A BLANK
         BE    GDGENT2             YES.
         LA    R1,1(0,R1)          TRY NEXT CHARACTER.
         BCT   R8,GDGENT1          KEEP LOOKING
GDGENT2  SR    R8,R8               CLEAR A REGISTER.
         ICM   R8,3,GDSGENO        PICK UP GENERATION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  2(4,R1),GWK3        UNPACK GENERATION NUMBER.
         OI    5(R1),X'F0'         FIX SIGN
         SR    R8,R8               CLEAR A REGISTER.
         ICM   R8,1,GDSVERNO       PICK UP VERSION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  7(2,R1),GWK2        UNPACK VERSION NUMBER.
         OI    8(R1),X'F0'         FIX SIGN
         MVC   0(2,R1),=C'.G'      SET G0000
         MVI   6(R1),C'V'          G0000V00
         MVC   L1DSNAME,GDGWORK    MOVE IN DEVELOPED NAME
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,GDGENTL1,ENDCELL       @134
GDGENTL1 DS    0H                                                  @134
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,GDGENTN1    @134
GDGENTN1 DS    0H                                                  @134
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    GDGECNT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    GDGECNT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTGDGE,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     GDGECNT2            CONTINUE PROCESS             15JAN88
GDGECNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
GDGECNT2 EQU   *                                                15JAN88
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,GDGENTL,ENDCELL        @130
GDGENTL DS     0H                                                  @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,GDGENTN     @130
GDGENTN DS     0H                                                  @130
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,GDGENTV,ENDCELL       @130
GDGENTV DS     0H                                                  @130
        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,GDGENTX    @130
GDGENTX DS     0H                                                  @130
         MVC   L1UNIT,=C'????'     JUST IN CASE.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
GDGENT5  CLC   VOLDEVTP,0(R5)      IS THIS IT
         BE    GDGENT6             GO TO SET IT UP.
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    GDGENT7             YES, LEAVE IT AT ????
         B     GDGENT5             NO, TRY NEXT DEVICE ENTRY.
GDGENT6  MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
         TM    2(R5),X'20'         IS IT A DASD DEVICE.
         BZ    GDGENT7             IF NOT, NO VTOC TO SEARCH.
         L     R15,=V(VTOC)                                        @134
         BALR  R14,R15             GET DSCB FIELDS                 @134
GDGENT7  CLC   L1VOLUME,=C'MIGRAT'  IS IT MIGRATED BY HSM?
         BE    GDGENT8             IF SO, THAT'S IT.
         L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,                                               X
               DWK3,ZZZZZ          FORMAT WITH ZERO SUPPRESSION.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,                                               X
               DWK4,ZZZZZZZ        MAKE IT PRINTABLE.
         DROP  R3
GDGENT8  LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         TITLE ' - FINDBCS. ADVANCE R3 TO A SPECIFIED BCS CELL.'
* I ENTER HERE WITH R3 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
         ENTRY FINDBCS                                             @134
FINDBCS  $IN ,
         ST    R3,BCS2             SAVE CELL ADDRESS.
FINDBCS1 SR    R1,R1               CLEAR REGISTER
         ICM   R1,3,0(R3)          PICK UP LENGTH OF CURRENT CELL.
         AR    R3,R1               AND SKIP OVER IT.
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    FINDBCS2            YES.
         ST    R0,BCS0             SAVE CALLERS PARMS
         L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         AP    BCSGETS,ONE         COUNT OFF A GET.
         L     R0,BCS0             RESTORE CALLERS PARMS
         LTR   R15,R15             RECORD READ OK?
         L     R3,BUFPTR           ADDRESS OF RECORD JUST READ.
         L     R1,RPLICAT          GET RPL ADDR.
         L     R1,48(0,R1)         RECORD LENGTH.
         AR    R1,R3               END OF RECORD.
         ST    R1,ENDBCS           SAVE FOR NEXT TIME.
         LA    R3,2(0,R3)          SKIP OVER PREFIX.
FINDBCS2 CLM   R0,1,2(R3)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDBCS9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDBCS1            NO, SO KEEP LOOKING.
         L     R3,BCS2             BACKUP TO WHERE WE STARTED.
         SR    R0,R0               LET HIM KNOW ABOUT IT.
FINDBCS9 $OUT  ,
BCS9     DC    F'0'                SAVE R9 IN HERE.
BCS2     DC    F'0'                SAVE R3 IN HERE.
BCS0     DC    F'0'                SAVE R0 IN HERE.
         TITLE ' - PRINT LINE SUBROUTINE.'
         ENTRY  PRINT                                              @134
PRINT    $IN ,
         ST    R1,PRINT1
         CLC   DSPFX(3),=C'   '        IS THERE DS PREFIX GIVEN 15JAN88
         BE    PRINT2              NO, CONTINUE A NORMAL        15JAN88
         CLI   PFXSW,255               IS THE PRINTIT SWITCH ON 15JAN88
         BNE   PRINT2A            YES, DON'T PRINT THE LINE.    15JAN88
PRINT2   EQU   *                                                15JAN88
         XPRNTLIN  PWA,TEXT=(R1),LENGTH=132,SPB=((R0)),SPA=1
PRINT2A  L     R1,PRINT1
         MVI   0(R1),C' '
         MVC   1(132,R1),0(R1)
         $OUT  ,
PRINT1   DC    F'0'
         TITLE ' - DEFINE REPORT HEADING.'
SETHEAD  $IN ,
         XPRHEAD PWA,LIST=(HEADER1,HEADER2,HEADER2A)
         $OUT
         TITLE ' - FORMAT THE CREATION DATE FROM AN OWNER CELL.'
SETCREDT $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         USING OWNERC,R3
         SR    R0,R0               CLEAR R0.
         ICM   R0,7,OWNCREDT       PICK UP CREATION DATE.
         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD
         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION
         LA    R1,DTWORK           SETUP ADDRESS
         ST    R1,DTPARM           OF PACKED FIELD
         LA    R1,DTPARM           IN PARMLIST
         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE
         BALR  R14,R15             CONVERT DATE
         MVC   L1CREDT,DTWORK      SETUP CONVERTED DATE
         $OUT
         TITLE ' - SETUP FIELDS FROM THE HSM MCD RECORD.'
CHKHSM   DS    0H
         CLI   MCDSOPEN,254        PREVIOUS OPEN FAILED?           @122
         BER   R9                  YES. GIVE UP HOPE.              @122
         CLI   MCDSOPEN,0          IS MCDS ALREADY OPEN?
         BNE   CHKHSM1A
         OPEN  (ACBMCDS)
         LTR   R15,R15             DID IT OPEN.                    @122
         BZ    CHKHSM1B            YES                             @122
        $MESSAGE 6                 NO. SAY SO.                     @122
         MVI   MCDSOPEN,254        FLAG NO SYSUT2.                 @122
         BR    R9                  AND GO HOME.                    @122
CHKHSM1B DS    0H                                                  @122
         MVI   MCDSOPEN,255        FLAG IT OPEN
CHKHSM1A MVC   MCDSKEY,L1DSNAME    DSN AS MCDS KEY.
         GET   RPL=RPLMCDS
         LTR   R15,R15             RECORD READ OK?
         BNZR  R9                  RETURN
         L     R1,MCDSPTR          GET ADDRESS OF HSM MCD RECORD.
         USING MCD,R1
         CLC   MCDSIZE,=F'32760'   DATA AND INDEX ENTRIES NO GOOD.
         BH    CHKHSM2             SO LEAVE THEM AT ZERO
         MVC   TRACKS,MCDSIZE      ORIGINAL SIZE IN TRACKS.
CHKHSM2  MVC   BLKSIZE+2(2),MCDBLKSZ  ORIGINAL BLOCK SIZE.
         DROP  R1
         BR    R9                  EXIT
         TITLE ' - PRINT OUT STATISTICS AT EOD.'
COUNTS   $IN ,
         XPREJECT  PWA
         XPRHEAD PWA,LIST=(HEADER1)
         EDIT  T1COUNT,CNTNVSAM,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NVSAM),T1NVSAM
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=2,SPA=1
         EDIT  T1COUNT,CNTCLUST,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1CLUST),T1CLUST
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTINDEX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1INDEX),T1INDEX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTDATA,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1DATA),T1DATA
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTAIX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1AIX),T1AIX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTPATH,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1PATH),T1PATH
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTGDGB,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGB),T1GDGB
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTGDGE,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGE),T1GDGE
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,BCSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1BCS),T1BCS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,VVDSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1VVDS),T1VVDS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTNF,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NF),T1NF
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTNOENT,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NOENT),T1NOENT
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX ENTERED 15JAN88
         BE    COUNTS1          NO,DON'T PRINT PARM LINE        15JAN88
         L     R9,DSPFXL           LOAD PARM LENGTH             15JAN88
         EX    R9,MVPARM           MOVE PARM TO PRINT LINE      15JAN88
         LA    R8,T1INPARM         POINT START OF OUTPUT AREA   15JAN88
         A     R9,=XL4'0000001'    BUMPUP TO GET CORRECT OFFSET 15JAN88
         AR    R8,R9               POINT TO MOVE AREA           15JAN88
         MVI   0(R8),C'"'          MOVE IN A DOUBLE QUOTE SIGN  15JAN88
         XPRNTLIN  PWA,TEXT=TOTAL1+1,LENGTH=132,SPB=2,SPA=1     15JAN88
COUNTS1  EQU   *                                                15JAN88
         $OUT
MVPARM   MVC   T1INPARM(0),DSPFX                                15JAN88
         SPACE
TOTAL    DS    0CL133
         DC    CL1' '
T1COUNT  DC    CL7' '
         DC    CL1' '
T1TEXT   DC    CL124' '                                            @120
T1NVSAM  DC    C'NONVSAM ENTRIES FOUND.'
T1CLUST  DC    C'CLUSTER ENTRIES FOUND.'
T1INDEX  DC    C'INDEX ENTRIES FOUND.'
T1DATA   DC    C'DATA ENTRIES FOUND.'
T1AIX    DC    C'ALTERNATE INDEX ENTRIES FOUND.'
T1PATH   DC    C'PATH ENTRIES FOUND.'
T1GDGB   DC    C'GENERATION DATA GROUP BASES FOUND.'
T1GDGE   DC    C'GENERATION DATA GROUP ENTRIES FOUND.'
T1BCS    DC    C'GETS ISSUED AGAINST THE BASIC CATALOG STRUCTURE.'
T1VVDS   DC    C'GETS ISSUED AGAINST VVDS(S).'
T1NF     DC    C'NONVSAM DATASETS CATALOGUED BUT NOT FOUND. (MARKED WIT-
               H A "*" BEFORE DATASET TYPE)'
T1NOENT  DC    C'GENERATION DATA GROUP BASES FOUND WITH NO ENTRIES. (MA-
               RKED WITH A "+" BEFORE DATASET TYPE)'
TOTAL1   DS    0CL133
         DC    CL1' '
         DC    CL13'SEARCH FOR: "'
T1INPARM DC    CL119' '
PFXSW    DC    XL1'00'                                          15JAN88
COMPDSN  CLC   DSPFX(0),L1DSNAME   EXECUTED COMMAND             15JAN88
         TITLE ' - GENERATE AN RPL TO ACCESS THE BCS CLUSTER.'
GENRPL   $IN ,                                                     @120
         L     R0,BUFLEN           LENGTH TO GETMAIN
         GETMAIN R,LV=(0)          INPUT BUFFER FOR BCS RECORDS.
         ST    R1,BUFPTR           SAVE ADDRESS OF RECORD BUFFER.
         GENCB BLK=RPL,                                                X
               ACB=(S,ACBICAT),                                        X
               AM=VSAM,                                                X
               AREA=(*,BUFPTR),                                        X
               AREALEN=131072,                                         X
               OPTCD=(KEY,SEQ,MVE)
         ST    R1,RPLICAT          SAVE GENERATED RPL ADDR.
         $OUT                                                      @120
         LTORG ,
         SPACE 2
         COPY  ALLVVDS                                             @130
         COPY  PARMS                                               @130
         COPY  DSECTS                                              @120
         COPY  DATASECT                                            @120
         COPY  PRINT                                               @120
         COPY  MESSAGES                                            @122
         COPY  VTOC                                                @134
         COPY  VVDS                                                @134
         COPY  FINDVVDS                                            @134
         COPY  HEXPRINT                                            @134
         END   LISTICAT
./       ADD   NAME=MESSAGES
         PRINT NOGEN
         TITLE 'MESSAGE ROUTINE.'
MESGRTN  $PROLOG R12
         L     R4,=V(DATASECT)
         USING DATASECT,R4
         CLI   MALLOC,255        HAS SYSLIST BEEN ALLOCATED?
         BE    MALLOC1           ONCE ONLY PLEASE.
         MVI   MALLOC,255        MARK IT AS ALLOCATED.
         ST    R1,MR1SAVE        FOLLOWING CODE BAGS R1
         XPROPEN PWL,                                                  X
               PAGELEN=PAGELEN,                                        X
               DDNAME=SYSLIST    AND OPEN IT.
         LTR   R15,R15           WELL......
         BZ    MSGOK             YUP.
         WTO   'SYSLIST NOT OPENED',ROUTCDE=11
         ABEND 13
MSGOK    XPREJECT PWL            SKIP TO A NEW PAGE.
         XPRHEAD PWL,                                                  X
               LIST=SLHEAD1      AND DEFINE THE HEADING.
         L     R1,MR1SAVE        MESSAGE NUMBER FROM CALLER.
MALLOC1  L     R3,=V(MESSAGES)   GET ADDRESS OF MESSAGE TABLE.
         SLL   R1,1              TIMES 2 FOR HALFWORD INDEX
         LH    R1,0(R1,R3)       PICKUP INDEX INTO MESSGAE TABLE.
         AR    R1,R3             DEVELOP OFFSET OF MESSAGE TEXT.
         SR    R3,R3             ZERO REGISTER.
         IC    R3,0(,R1)         PICKUP TEXT LENGTH
         SR    R4,R4             ZERO REGISTER.
         IC    R4,1(,R1)         LENGTH TO BE INSERTED.
         LTR   R4,R4             ANYTHING TO INSERT?
         BZ    MSKIP2            NO, PRINT MESSAGE AS IS.
         LR    R5,R3             MESSAGE LENGTH
         SR    R5,R4             MINUS INSERT LENGTH
         AR    R5,R1             PLUS START ADDR
         LA    R5,2(,R5)         PLUS 2 IS INSERT POINT.
         BCTR  R4,0              MINUS 1 FOR EX.
         EX    R4,MINSERT        ADD INSERT TEXT.
MSKIP2   LA    R1,2(,R1)         SKIP OVER LENGTH BYTES.
         XPRNTLIN PWL,                                                 X
               TEXT=(R1),                                              X
               LENGTH=(R3),                                            X
               SPB=((R0)),                                             X
               SPA=1             PRINT THE MESSAGE TEXT.
MSKIP1   EQU   *
         $EPILOG ,
NOSYSLST ABEND 130,DUMP
         LTORG ,
MINSERT  MVC   0(0,R5),0(R2)     CUSTOMIZE A MESSAGE.
MALLOC   DC    A(*-*)            HAS SYSLIST BEEN ALLOCATED.
MR1SAVE  DC    AL4(0)            SAVEAREA FOR REGISTER 1.
PWL      XPRDCB DDNAME=SYSLIST
SLHEAD1  XPRLDEF TEXT=SLHTXT1,                                         X
               LENGTH=L'SLHTXT1,                                       X
               SPB=(0,ATHOF),                                          X
               SPA=2
SLHTXT1  DC    C'&NAME &VERSION -- MESSAGES'
MESSAGES CSECT
         MACRO
         MESG  &N,&F,&T
&L       SETA  K'&SYSLIST(3)-2
         AIF   (&SYSLIST(2) EQ 0).NOFILL
&L       SETA  &L+&SYSLIST(2)
MESG&N   DC    YL1(&L),YL1(&F),C&T,CL&F' '
         MEXIT
.NOFILL  ANOP
MESG&N   DC    YL1(&L),YL1(&F),C&T
         MEND
         DC    Y(MESG0-MESSAGES)
         DC    Y(MESG1-MESSAGES)
         DC    Y(MESG2-MESSAGES)
         DC    Y(MESG3-MESSAGES)
         DC    Y(MESG4-MESSAGES)
         DC    Y(MESG5-MESSAGES)
         DC    Y(MESG6-MESSAGES)
         DC    Y(MESG7-MESSAGES)                                   @130
         DC    Y(MESG8-MESSAGES)                                   @130
         SPACE ,
         MESG  0,0,'&NAME &VERSION -- ENDED SUCCESSFULLY.'
         MESG  1,0,'&NAME &VERSION -- STARTING.'
         MESG  2,4,'VSAM LOGICAL ERROR ON VVDS GET. FDBK = '
         MESG  3,44,'VVR NOT FOUND WHEN EXPECTED. DSN: '
         MESG  4,44,'INCOMPLETE DATA FOR DSN: '
         MESG  5,8,'OPEN FAILED FOR VVDS ON VOLUME: '
         MESG  6,0,'OPEN FAILED FOR HSM MCDS, DDN: SYSUT2'
         MESG  7,44,'CATALOG ENTRY BUT NO DATASET FOR DSN: '       @130
         MESG  8,80,'SYSIN INPUT: '                                @130
         MESG  9,0,'MORE THAN 256 VVDS''S. RUN TERMINATED.'        @131
./       ADD   NAME=PARMS
         TITLE 'SCAN CONTROL CARDS.'
PARMS    $PROLOG R12
         L     R11,=V(DATASECT)
         USING DATASECT,R11
         OPEN  (SYSIN,INPUT)
         TM    SYSIN+48,X'10'      DID SYSIN DCB OPEN?
         BZ    PARM99              IF SYSIN NOT SUPPLIED, DEFAULT.
PARMS1   GET   SYSIN,CARD
         LA    R2,CARD             CARD IMAGE TO PRINT.
         LM    R15,R1,=A(MESGRTN,0,8)                              @130
         BALR  R14,R15             MESSAGE 8. PRINT CARD IMAGE.    @130
         LA    R3,CARD             ADDRESS OF PARAMETER CARD.
         LA    R4,1                SCAN 1 BYTE AT A TIME.
         LR    R5,R3               START OF CARD
         LA    R5,72(,R5)          PLUS 72 BYTES IS SCAN LIMIT.
PARMS2   DS    0H
         CLC   =C'LEVEL(',0(R3)    LEVEL IDENTIFIERS FOLLOW.
         BE    PARMS5              PROCESS SCANNED PARM VALUE.
         CLC   =C'NOLEVEL(',0(R3)  NOLEVEL IDENTIFIERS FOLLOW.
         BE    PARMS6              PROCESS SCANNED PARM VALUE.
         CLC   =C'VOLUME(',0(R3)   VOLSERS TO SELECT FROM.
         BE    PARMS7              PROCESS SCANNED PARM VALUE.
         CLC   =C'NOVOLUME(',0(R3)  VOLSER NOT TO SELECT FROM.
         BE    PARMS8              PROCESS SCANNED PARM VALUE.
         CLC   =C'TAPE.',0(R3)     SELECT TAPE DATASETS.
         BE    PARMSB              PROCESS SCANNED PARM VALUE.
         CLC   =C'NOTAPE.',0(R3)   DON'T SELECT TAPE DATASETS.
         BE    PARMSC              PROCESS SCANNED PARM VALUE.
         CLC   =C'DASD.',0(R3)     SELECT DASD DATASETS.
         BE    PARMSF              PROCESS SCANNED PARM VALUE.
         CLC   =C'NODASD.',0(R3)   DON'T SELECT DASD DATASETS.
         BE    PARMSG              PROCESS SCANNED PARM VALUE.
         CLC   =C'CONTAINING(',0(R3) SCAN DSNAME FOR STRING?
         BE    PARMSM              YES.
         CLC   =C'ENDING(',0(R3)   SELECT DSNAMES BY ENDING.
         BE    PARMSN              YES.
         CLC   =C'NOTCONTAINING(',0(R3) EXCLUDE BY CONTENTS.
         BE    PARMSO              YES.
         CLC   =C'NOTENDING(',0(R3) EXCLUDE DSNAMES BY ENDING
         BE    PARMSP              YES.
         SPACE ,
         CLC   =C'DUMP.',0(R3)     HEX LISTING WANTED?             @130
         BE    PARMSD              YES.                            @130
         SPACE ,
         CLC   =C'BREAKLEVEL.',0(R3)
         BE    PARMSBL             BREAK ON LEVEL WANTED.
         SPACE ,
PARMSL1  BXLE  R3,R4,PARMS2        SCAN THE WHOLE CARD.
         B     PARMS1              READ ANOTHER CARD.
PARMS5   OI    FLAGS1,LEVEL        INDICATE LEVEL WANTED.
         LA    R8,9                LENGTH OF A LEVEL
         LA    R3,6(,R3)           SKIP OVER 'LEVEL('
         LA    R7,LTAB             ADDR OF LEVEL TABLE.
         B     BLDTAB              GOTO BUILD SUBLIST TABLE.
PARMS6   OI    FLAGS1,NOLEVEL      INDICATE NOLEVEL WANTED.
         LA    R8,9                LENGTH OF A LEVEL
         LA    R3,8(,R3)           SKIP OVER 'NOLEVEL('
         LA    R7,NLTAB            ADDR OF NOLEVEL TABLE.
         B     BLDTAB              GOTO BUILD SUBLIST TABLE.
PARMS7   OI    FLAGS2,VOLUME       INDICATE VOLUME WANTED.
         LA    R8,7                LENGTH OF A VOLUME
         LA    R3,7(,R3)           SKIP OVER 'VOLUME('
         LA    R7,VTAB             ADDR OF VOLUME TABLE.
         B     BLDTAB              GOTO BUILD SUBLIST TABLE.
PARMS8   OI    FLAGS2,NOVOLUME     INDICATE NOVOLUME WANTED.
         LA    R8,7                LENGTH OF A VOLUME
         LA    R3,9(,R3)           SKIP OVER 'NOVOLUME('
         LA    R7,NVTAB            ADDR OF NOVOLUME TABLE.
         B     BLDTAB              GOTO BUILD SUBLIST TABLE.
PARMSB   OI    FLAGS1,TAPE         INDICATE TAPE WANTED.
         B     PARMSL1             CONTINUE SCAN.
PARMSC   NI    FLAGS1,NOTAPE       INDICATE TAPE NOT WANTED.
         LA    R3,3(,R3)           SKIP OVER 'NO'
         B     PARMSL1             CONTINUE SCAN.
         SPACE ,
PARMSD   OI    FLAGS1,DUMP         HEX LISTING WANTED.             @130
         B     PARMSL1             CONTINUE SCAN.                  @130
         SPACE ,
PARMSF   OI    FLAGS1,DASD         INDICATE DASD WANTED.
         B     PARMSL1             CONTINUE SCAN.
PARMSG   NI    FLAGS1,NODASD       INDICATE DASD NOT WANTED.
         LA    R3,3(,R3)           SKIP OVER 'NO'
         B     PARMSL1             CONTINUE SCAN.
         SPACE ,
PARMSM   OI    FLAGS3,CONTAIN      SAY SCAN DSNAME FOR STRINGS.
         LA    R3,11(0,R3)         SKIP OVER CONTAINING(
         LA    R8,9                8 CHARACTER SEARCH ARGS.
         LA    R7,CTAB             ARG TABLE.
         B     BLDTAB              GO EXTRACT SEARCH STRING.
PARMSN   OI    FLAGS3,ENDING       SAY SELECT BY ENDING.
         LA    R3,7(0,R3)          SKIP OVER ENDING(
         LA    R8,9                8 CHARACTER ENDING ARGS.
         LA    R7,ETAB             ARG TABLE.
         B     BLDTAB              GO EXTRACT ENDING STRING.
PARMSO   OI    FLAGS3,NOTCONT      SAY SCAN DSNAME FOR STRINGS.
         LA    R3,14(0,R3)         SKIP OVER NOTCONTAINING(
         LA    R8,9                8 CHARACTER SEARCH ARGS.
         LA    R7,NCTAB            ARG TABLE.
         B     BLDTAB              GO EXTRACT SEARCH STRING.
PARMSP   OI    FLAGS3,NOTEND       SAY EXCLUDE BY ENDING.
         LA    R3,10(0,R3)         SKIP OVER NOTENDING(
         LA    R8,9                8 CHARACTER ENDING ARGS.
         LA    R7,NETAB            ARG TABLE.
         B     BLDTAB              GO EXTRACT ENDING STRING.
PARMSBL  OI    FLAGS2,BRKLVL       PAGE EJECT EACH HI-LVL QUAL.
         B     PARMSL1             CONTINUE SCAN.
         SPACE ,
BLDTAB   SR    R1,R1               R1 WILL BE ADDR OF SCANNED CHAR.
         SR    R2,R2               R2 WILL CONTAIN SCANNED CHAR.
BLDTAB1  TRT   0(9,R3),SCANTAB     SCAN FOR ) OR ,
         LTR   R1,R1               DELIMITER FOUND
         BZ    SUBLERR             NO, SYNATX ERROR IN SUBLIST.
         CLC   0(2,R1),=C', '      END OF CARD?
         BE    BLDTAB9             YES
         LR    R15,R1              ADDR OF SCANNED DELIMITER.
         SR    R15,R3              R15 -> LENGTH OF SUBLIST ELEMENT
         STC   R15,0(,R7)          SAVE IT
         BCTR  R15,0               MINUS 1 FOR EX.
         EX    R15,BLDMVC          STORE MESSAGE ID.
         CLI   0(R1),C')'          END OF SUBLIST?
         BNE   BLDTAB2             NO, SKIP END OF TABLE.
         AR    R7,R8               SPAN OVER LAST ELEMENT.
         MVI   0(R7),255           SET END OF TABLE.
         B     PARMSL1             KEEP ON SCANNING
BLDTAB2  LA    R15,1(,R15)         ADD 1 AFTER EX.
         AR    R3,R15              SKIP OVER MESSAGE ID.
         AR    R7,R8               NEXT TABLE ENTRY.
         BXLE  R3,R4,BLDTAB1       FIND NEXT MESSAGE.
BLDTAB9  GET   SYSIN,CARD
         LA    R3,CARD             START OF CARD
         LA    R4,1                SCAN 1 COLUMN AT A TIME.
         LR    R5,R3               START OF CARD
         LA    R5,72(,R5)          PLUS 72 IS LAST COLUMN TO SCAN.
         TRT   0(72,R3),ALPHTAB    SCAN TO 1ST APHAMERIC CHARACTER.
         BZ    SUBLERR             SUBLIST ERROR IF NONE FOUND.
         LR    R3,R1               R1 -> 1ST ALPHA CHARACTER.
         B     BLDTAB1             RESUME DECODING OF SUBLIST ELEME
SUBLERR  ABEND 98,DUMP
BLDMVC   MVC   1(0,R7),0(R3)       SAVE A SUBLIST ITEM.
EODIN    DS    0H                                                  @130
         CLOSE (SYSIN)             ALL DONE. GET OUT.
PARM99   DS    0H
*       $CALL  OPTIONS
         SPACE ,
         $EPILOG ,
         LTORG ,
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,MACRF=(GM),EODAD=EODIN
         DS    0D
CARD     DC    CL80' '
         SPACE ,
SCANTAB  DS    0D
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'00000000000000000000000000000000'  0
         DC    X'00000000000000000000000000000000'  1
         DC    X'00000000000000000000000000000000'  2
         DC    X'00000000000000000000000000000000'  3
         DC    X'00000000000000000000000000000000'  4
         DC    X'00000000000000000000000000020000'  5
         DC    X'00000000000000000000000100000000'  6
         DC    X'00000000000000000000000000000000'  7
         DC    X'00000000000000000000000000000000'  8
         DC    X'00000000000000000000000000000000'  9
         DC    X'00000000000000000000000000000000'  A
         DC    X'00000000000000000000000000000000'  B
         DC    X'00000000000000000000000000000000'  C
         DC    X'00000000000000000000000000000000'  D
         DC    X'00000000000000000000000000000000'  E
         DC    X'00000000000000000000000000000000'  F
ALPHTAB  DS    0D
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    X'00000000000000000000000000000000'  0
         DC    X'00000000000000000000000000000000'  1
         DC    X'00000000000000000000000000000000'  2
         DC    X'00000000000000000000000000000000'  3
         DC    X'00000000000000000000000000000000'  4
         DC    X'0000000000000000000000FF00000000'  5
         DC    X'00000000000000000000000000000000'  6
         DC    X'00000000000000000000000000000000'  7
         DC    X'00000000000000000000000000000000'  8
         DC    X'00000000000000000000000000000000'  9
         DC    X'00000000000000000000000000000000'  A
         DC    X'00000000000000000000000000000000'  B
         DC    X'00FFFFFFFFFFFFFFFFFF000000000000'  C
         DC    X'00FFFFFFFFFFFFFFFFFF000000000000'  D
         DC    X'0000FFFFFFFFFFFFFFFF000000000000'  E
         DC    X'FFFFFFFFFFFFFFFFFFFF000000000000'  F
./       ADD   NAME=PRINT
         TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'
         SPACE
* FUNCTION/OPERATION:  THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE
*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION
*        FOR PRINTED OUTPUT.  IT IS INVOKED FROM A PROBLEM PROGRAM VIA
*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES:
*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER
*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING
*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME
*              IN DCB, AND OPENS THE DATA SET.
*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER
*              'OPEN' EXCEPT THE DDNAME.
*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED
*              PAGE HEADINGS.
*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.
*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.
*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.
*           CLOSE - CLOSES THE DATA SET.
         SPACE
* ENTRY POINTS:  EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM
*        THE BASE ADDRESS.  ENTRYS ARE EFFECTED BY A  BAL  14,D(15)
*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND
*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE
*        AREA.
         SPACE
* INPUT:  ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH
*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.
*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE
*        CALL MODE.  THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS
*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.
         SPACE
         SPACE
* OUTPUT:  PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM
*        TO A SEQUENTIAL DATA SET.  EACH LINE IS REDUCED TO ITS MIN-
*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.
         SPACE
* DATA SETS:  THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED
*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE
*        TO 1403 OR 1404 PRINTERS.  THE DDNAME IS SUPPLIED BY THE
*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.
         SPACE
* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE
*        PAGE HEADING LINE.
         SPACE
* EXITS - NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.
*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY
*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.
*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.
         SPACE
* EXITS - ERROR:  ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE
*        FOLLOWING COMPLETION CODES:
*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.
*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA
*              SET WHICH WAS NOT OPEN.
*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.
*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.
*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT
*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.
*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.
*           4007 - SYNCHRONOUS I/O ERROR.
         SPACE
* TABLES/WORK AREAS:  THE CALL PARAMETER LISTS, WORK AREA, AND PRINT
*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS
*        AT THE END OF THE PROGRAM.
         SPACE
* ATTRIBUTES:  REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA
*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.
         SPACE
* OPERATING ENVIRONMENT:  RUNS UNDER OPERATING SYSTEM/360, USING
*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE
*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.
         SPACE
* NOTES:  NONE.
         EJECT
XPRNTSUB CSECT
         SPACE 2
* REGISTER ASSIGNMENTS:
         SPACE 2
* N.B.  REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE
* KEPT IN ORDER FOR LM AND STM ORDERS.
         SPACE
RWA      EQU   2                   GENERAL WORK REG
RWB      EQU   3                   GENERAL WORK REG
RWC      EQU   4                   GENERAL WORK REG
RWD      EQU   5                   GENERAL WORK REG
RSPACE   EQU   6                   NUMBER OF LINES TO SPACE
RBAL     EQU   7                   NUMBER OF LINES LEFT ON PAGE
RLPEXIT  EQU   8                   EXIT FROM LIST PROCESSING ROUTINE
RPARM    EQU   9                   CALL PARAMETER LIST ADDR
RPLD     EQU   10                  PLD BLOCK BASE
RWKAREA  EQU   11                  BASE REGISTER FOR WORK AREA
RBASE    EQU   12                  BASE REGISTER FOR CODING
RRET     EQU   14                  STANDARD RETURN ADDR
         SPACE
* MASKS FOR CONTROL BYTE "SWITCHES":
         SPACE
HOFBIT   EQU   X'80'               PAGE IS AT PHYSICAL HEAD-OF-FORM
NOSKBIT  EQU   X'40'               DISALLOW EJECT DURING HEAD PRINTING
TXT1BIT  EQU   X'20'               ON FOR FIRST TEXT LINE ON PAGE
HD1BIT   EQU   X'10'               ON FOR FIRST HEAD LINE WITH PAGE
*                                  NO, ETC
SP0BIT   EQU   X'08'               LAST LINE SPACED 0
         SPACE 2
EJFORCE  EQU   255                 SPACING QUANTITY TO FORCE PAGE EJECT
OPENBIT  EQU   X'10'               TO TEST 'DCBOFLGS' FOR SUCCESSFUL
*                                  OPEN
MAXLNGTH EQU   254                 MAXIMUM PAGE LENGTH
MAXWIDTH EQU   132                 MAXIMUM PAGE WIDTH
DEFBLKSZ EQU   1692                DEFAULT DCB BLOCK SIZE
         EJECT
**********************
* ENTRY AND PROLOGUE *
**********************
         SPACE
* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION "BAL 14,X(0,15)".
* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT
* "X" SELECTS THE ENTRY POINT.  EACH ENTRY SAVES REGISTERS, LOADS THE
* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON
* PROLOGUE.  NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN
* AN ABEND.
         SPACE 2
BASEADDR B     20(0,R15)           BRANCH AROUND MODULE IDENTIFIER
         DC    AL1(15)             LENGTH OF IDENTIFIER
         DC    CL15'XPRNTSUB-028214'
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         SR    R1,R1               SET ABEND COMPLETION CODE
         LR    RBASE,R15           SET BASE REG FOR ABEND ROUTINE
         USING BASEADDR,RBASE
         B     ABEND
         DROP  RBASE
         SPACE 2
* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING
* AT BASEADDR+32.  EACH LOADS "RWA" WITH THE ADDRESS OF THE SUBROUTINE
* TO GO TO AFTER EXECUTING "PROLOGUE".
         SPACE
         ORG   XPRNTSUB+32
         USING BASEADDR,R15
         SPACE
PRENTRY  STM   R14,R12,12(R13)     PRINT
         LA    RWA,PRPROC
         B     PROLOGUE
SPENTRY  STM   R14,R12,12(R13)     SPACE
         LA    RWA,SPPROC
         B     PROLOGUE
OPENTRY  STM   R14,R12,12(R13)     OPEN
         LA    RWA,OPPROC
         B     PROLOGUE
CLENTRY  STM   R14,R12,12(R13)     CLOSE
         LA    RWA,CLPROC
         B     PROLOGUE
SHENTRY  STM   R14,R12,12(R13)     SETHEAD
         LA    RWA,SHPROC
         B     PROLOGUE
EJENTRY  STM   R14,R12,12(R13)     EJECT
         LA    RWA,EJPROC
         B     PROLOGUE
MDENTRY  STM   R14,R12,12(R13)     MODIFY
         LA    RWA,MDPROC
         B     PROLOGUE
         SPACE 2
* PROLOGUE.  SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN
* SAVE AREAS IN STANDARD FASHION.  LOAD "RBAL" WITH CURRENT PAGE
* BALANCE AND "RPARM" WITH THE CALLING PARAMETER LIST ADDRESS.
         SPACE
PROLOGUE LR    RBASE,R15           LOAD CODING BASE REG
         USING BASEADDR,RBASE
         DROP  R15
         SPACE
         LR    RWKAREA,R0          BASE REG FOR WORK AREA
         USING WORKAREA,RWKAREA
         SPACE
         LR    RWB,R13             ADDR OF CALLER'S SAVE AREA
         LA    R13,SAVEAREA        ADDR OF OUR SAVE AREA
         ST    R13,8(RWB)          CHAIN TO US FROM CALLER
         ST    RWB,SAVEAREA+4      CHAIN TO CALLER FROM US
         SPACE
         LR    RPARM,R1            LOAD PARAMETER LIST ADDR
         LH    RBAL,PAGEBAL        LOAD PAGE LINE COUNT BALANCE
         MVC   DCBSYNAD(3),=AL3(SYNAD)  PUT ERROR ROUTINE ADDRESS IN
*                                  DCB
         SPACE
         TM    DCBOFLGS,OPENBIT    MAKE SURE DATA SET IS OPEN
         BCR   1,RWA               BRANCH IF OPEN
         CL    RWA,=A(OPPROC)      IF NOT, ONLY OPEN CALL ALLOWED
         BCR   8,RWA               BR IF OPEN CALL
         LA    R1,2                ERROR CODE 2, GO TO ABEND
         SPACE 3
* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.
* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP
         SPACE
         CNOP  2,4                 ALIGN CONSTANT FOLLOWING SVC
ABEND    AL    R1,*+6              LOAD ABEND CODES
         SVC   13                  ISSUE ABEND SVC
         DC    X'80'               'DUMP' BIT FOR ABEND
         DC    AL3(4000)           BASE FOR COMPLETION CODE
         EJECT
************
* EPILOGUE *
************
         SPACE
* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE.  IT EXITS WITH
* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND
* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.
         SPACE 2
EXIT4    LA    R15,4               SET RETURN CODE 4
         B     EXIT
         SPACE
EXIT0    SR    R15,R15             SET RETURN CODE 0
         SPACE
EXIT     LH    R0,PAGENO           LOAD CURRENT PAGE NUMBER
         LR    R1,RBAL             LOAD NUMBER OF LINES LEFT
         STH   RBAL,PAGEBAL        SAVE PAGE BALANCE
         XC    DCBSYNAD(3),DCBSYNAD  CLEAR ERROR ROUTINE ADDRESS
         SPACE
         L     R13,SAVEAREA+4      ADDRESS OF CALLER'S SAVE AREA
         L     R14,12(R13)         LOAD RETURN ADDRESS
         LM    R2,R12,28(R13)      RESTORE CALLER'S REGISTERS
         MVI   12(R13),X'FF'       SET RETURN INDICATION
         BR    R14                 RETURN TO CALLER
         EJECT
******************
* PRINT FUNCTION *
******************
         SPACE
* PRINT LINE DELIVERY CALL.  THE PARAMETER LIST IS A VARIABLE-LENGTH
* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).
* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED.  CALL
* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.
         SPACE 2
PRPROC   BAL   RLPEXIT,LISTPROC    INVOKE LIST PROCESSOR
         SPACE
         B     EXIT0               EXIT TO CALLER
         EJECT
******************
* SPACE FUNCTION *
******************
         SPACE
* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES.  IF THE NUMBER
* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS
* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST.  IF THE PAGE
* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT
* IS SET IN THE PARAMETER LIST.  IN THE LATTER CASE, THE PAGE HEADINGS
* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.
         SPACE 2
         USING SPPARM,RPARM        ADDRESSING FOR PARM LIST
         SPACE
SPPROC   TM    SWITCHES,HOFBIT     TEST IF AT HEAD-OF-FORM
         BZ    SPSUBTR             BR IF NOT
         TM    SPCOND,SPATHOF      IS SPACE ALLOWED AT HOF?
         BZ    EXIT0               EXIT IF NOT
         BAL   RRET,HEADPRNT       IF SO, PRINT HEADINGS FIRST
         SPACE
SPSUBTR  SR    RSPACE,RSPACE
         IC    RSPACE,SPQUAN       LOAD SPACING AMOUNT
         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE
         SPACE
         BP    SPMOVE              BRANCH IF BAL STILL > 0
         TM    SPCOND,SPNOEJ       TEST IF EJECT ALLOWED
         BO    SPMOVE              BRANCH IF NOT
         LA    RSPACE,EJFORCE      IF ALLOWED, FORCE EJECT
         SPACE
SPMOVE   BAL   RWA,MOVE            CALL PAPER MOVING SUB
         B     EXIT0               EXIT TO CALLER
         SPACE
         DROP  RPARM
         EJECT
******************
* EJECT FUNCTION *
******************
         SPACE
* CALL TO MOVE THE PAPER TO HEAD-OF-FORM.  IF THE PAGE IS ALREADY
* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE
* PARAMETER LIST IS ON.  IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT
* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE.  IF THE MASK BITS
* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS
* REQUESTED.  THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY
* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT
* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.
         SPACE 2
         USING EJPARM,RPARM        FOR PARM LIST ADDRESSING
         SPACE
EJPROC   TM    SWITCHES,HOFBIT     TEST IF AT HOF
         BZ    EJTEST              BR IF NOT
         TM    EJCOND,EJATHOF      IF SO, IS EJECT ALLOWED?
         BZ    EXIT0               IF NOT, EXIT
         SPACE
EJTEST   SR    R0,R0
         IC    R0,EJQUAN           LOAD TEST QUANTITY
         IC    R1,EJCOND           GET CONDITIONAL TEST MASK
         N     R1,=XL4'000000F0'   KEEP BITS 24-27 ONLY
         CR    RBAL,R0             COMPARE BALANCE WITH TEST QUAN
         EX    R1,EJBC             EXECUTE BC WITH MASK FROM PARM
         B     EXIT0               EXIT IF CONDITION NOT MET
         SPACE
EJMOVE   LA    RSPACE,EJFORCE      TO FORCE EJECT
         BAL   RWA,MOVE            CALL PAPER MOVER SUB
         B     EXIT0               EXIT TO CALLER
         SPACE 2
EJBC     BC    0,EJMOVE            BRANCH IF EJECT REQUIRED
         SPACE
         DROP  RPARM
         EJECT
*****************
* OPEN FUNCTION *
*****************
         SPACE
* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET.  IT SETS THE DDNAME
* IN THE DCB AND OPENS THE DATA SET.   ALL COUNTERS AND SWITCHES ARE
* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH
* MAY HAVE BEEN SUPPLIED WITH THE CALL.  THE PAGE BALANCE IS SET TO
* ZERO, BUT THE PAGE IS NOT MOVED.  THE PROGRAMMER SHOULD NORMALLY
* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.
         SPACE
* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL
* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A
* 'MODIFY' CALL.
         SPACE 2
         USING OMPARM,RPARM
         SPACE
OPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS
         MVI   HLTEXT,C' '         CLEAR HEADING TEXT
         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT
         SPACE
         TIME  DEC                 GET CURRENT DATE & TIME
         STM   R0,R1,HPRSAVE       SAVE TIME AND DATE
         SPACE
* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'.  OTHERWISE, INSERT
* DDNAME AND OPEN IT.
         SPACE
         TM    DCBOFLGS,OPENBIT    TEST IF OPEN
         BO    OPJOIN              BR TO 'MDPROC' IF OPEN
         MVC   DCBDDNAM(8),OMDDNAME  INSERT DDNAME INTO CLOSED DCB
         MVC   DCBEXLST(3),=AL3(EXLST)  INSERT ADDRESS OF EXIT LIST
         SPACE
         MVI   DWORK,X'80'         SET END-OF-LIST BIT
         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)
         SPACE
         XC    DCBEXLST(3),DCBEXLST  CLEAR ADDRESS OF EXIT LIST
         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPEN
         BO    OPJOIN              TO 'MDPROC' IF O.K.
         B     EXIT4               EXIT WITH RC=4 IF OPEN FAILS
         SPACE
         DROP  RPARM
         EJECT
* DCB EXIT ROUTINE FOR OPEN.  SET BLOCK SIZE TO THE DEFAULT VALUE IF
* NOT SPECIFIED IN DS LABEL OR DD CARD.
         SPACE
EXLST    DS    0F                  EXIT LIST, ON BOUNDARY
         DC    X'85'
         DC    AL3(DCBMOD)
         SPACE
DCBMOD   LH    RWA,DCBBLKSZ        LOAD BLOCK SIZE
         LTR   RWA,RWA             TEST IF ZERO
         BNZ   DCBNZ               BRANCH IF NOT ZERO
SETDEF   LA    RWA,DEFBLKSZ        SET DEFAULT BLOCK SIZE
         STH   RWA,DCBBLKSZ        STORE IN DCB
         BR    R14                 RETURN TO OPEN ROUTINE
DCBNZ    CH    RWA,=H'141'         TEST FOR MINIMUM BLOCKSIZE
         BL    SETDEF              USE DEFAULT IF TOO LOW
         BR    R14                 RETURN TO OPEN IF OK
         EJECT
*******************
* MODIFY FUNCTION *
*******************
         SPACE
* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING: DATE, TIME, PAGE
* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.
* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST.  IF A PARAMETER IS
* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.
         SPACE
* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,
* WHICH JOINS THIS CODING AT 'OPJOIN'.  IN THAT CASE, THE VALUES
* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.
         SPACE
         USING OMPARM,RPARM
         SPACE
MDPROC   SR    R0,R0               GENERATE TWO ZERO WORDS
         SR    R1,R1
         STM   R0,R1,HPRSAVE       SET DATE & TIME FIELDS TO ZERO
         SPACE
* ENTER HERE FROM 'OPEN'.  THE OBJECT OF THE FOLLOWING IS TO GET THE
* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND
* 'HPRSAVE+4', RESPECTIVELY.  THOSE FIELDS MAY HAVE BEEN FILLED IN BY
* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'
* ABOVE.  NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE
* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.
         SPACE
OPJOIN   LM    RWA,RWB,OMTIMEAD    LOAD TIME & DATE ADDRS FROM PARM
         LTR   RWA,RWA             TEST FOR TIME ADDR SUPPLIED
         BZ    NOTIME              BRANCH IF ZERO
         MVC   HPRSAVE(4),0(RWA)   GET TIME AS DECIMAL 'HHMMSSTH'
NOTIME   LTR   RWB,RWB             TEST IF DATE ADDR SUPPLIED
         BZ    DATEEDIT            BR IF NOT
         MVC   HPRSAVE+4(4),0(RWB)  GET DECIMAL DATE AS '00YYDDD+'
         SPACE
* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT.  BOTH
* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.
         SPACE
DATEEDIT LM    RWA,RWB,HPRSAVE     LOAD TIME & DATE FOR TESTING
         LTR   RWB,RWB             TEST IF DATE WAS GIVEN
         BZ    TIMEEDIT            BRANCH IF ZERO
         SPACE
         MVC   HLDAY(4),=C'DAY='   INSERT DAY NUMBER
         UNPK  HLDAY+4(3),HPRSAVE+6(2)  UNPACK DAY NUMBER
         OI    HLDAY+6,X'F0'       TIDY UP SIGN BITS
         SPACE
         ST    RWB,DWORK+4         STORE DATE ARG FOR EDIT RTNE
         LA    R1,DWORK            CONSTRUCT ONE-WORD PARM LIST
         ST    R1,HPRSAVE+4        FOR XDATEDIT CALL
         LA    R1,HPRSAVE+4        LOAD PARM LIST ADDRESS
         L     R15,=V(XDATEDIT)    LOAD ADDRESS OF DATE EDIT RTNE
         BALR  R14,R15             TO EDIT DATE AS 'MM/DD/YY'
         MVC   HLDATE(8),DWORK     INSERT RESULT IN HL TEXT
         SPACE
* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.
         SPACE
TIMEEDIT LTR   RWA,RWA             TEST IF TIME GIVEN
         BZ    TSTPGNO             BR IF ZERO
         SRL   RWA,4               ADD LEADING ZERO TO TIME
         ST    RWA,HPRSAVE         STORE TIME IN WORK LOC
         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR
         ED    HLTIME(7),HPRSAVE   EDIT INTO ALPHA
         SPACE
* MODIFY PAGE NUMBER.  VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS
* INCREMENTED BEFORE USE.
         SPACE
TSTPGNO  LH    RWA,OMPAGENO        GET VALUE FROM PARM LIST
         LTR   RWA,RWA             TEST IF ZERO
         BZ    TSTPGWID            BR IF ZERO
         BCTR  RWA,0               DECREMENT BY 1
         STH   RWA,PAGENO          STORE
         SPACE
* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.
         SPACE
TSTPGWID SR    RWA,RWA
         IC    RWA,OMPAGWID        GET WIDTH FROM PARM LIST
         LTR   RWA,RWA             TEST IF ZERO
         BZ    TSTPGLNG            BRANCH IF SO
         CLI   OMPAGWID,MAXWIDTH   TEST MAXIMUM SIZE
         BNH   PGWIDOK
         LA    R1,3                ERROR, TOO LARGE
         B     ABEND
PGWIDOK  STH   RWA,PAGWIDTH
         SPACE
* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.
         SPACE
TSTPGLNG SR    RWA,RWA
         IC    RWA,OMPAGLNG        GET FROM PARM LIST
         LTR   RWA,RWA             TEST IF SUPPLIED
         BZ    TSTMAXLN            BR IF NOT
         CLI   OMPAGLNG,MAXLNGTH   TEST FOR LEGAL VALUE
         BNH   PGLNGOK
         LA    R1,4                ERROR, ABORT
         B     ABEND
PGLNGOK  STH   RWA,PAGELNG         STORE
         SPACE
* MODIFY PRINT LINE LIMIT COUNTER.
         SPACE
TSTMAXLN L     RWA,OMMAXLIN        GET FROM PARM LIST
         LTR   RWA,RWA             TEST IF SUPPLIED
         BZ    EXIT0               EXIT IF NOT
         ST    RWA,MAXLINES        STORE
         B     EXIT0               EXIT TO CALLER
         SPACE
         DROP  RPARM
         EJECT
********************
* SETHEAD FUNCTION *
********************
         SPACE
* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING
* AND SUB-HEADING LINES.  THE PARAMETER LIST IS A VARIABLE-LENGTH LIST
* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS.  THE FIRST LINE WILL
* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.
* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE
* FIELDS.  THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.
* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT
* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS
* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE
* ON THE PRECEDING PAGE.  THE ADDRESS OF THE PARAMETER LIST IS SAVED
* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH
* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED
* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY
* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE.  EACH CALL TO
* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL.  A CALL WITH
* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE
* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND
* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.
         SPACE 2
SHPROC   LTR   RPARM,RPARM         TEST FOR NULL LIST ADDR
         BNZ   SHOK                BRANCH IF NON-ZERO
         LA    RPARM,NOHDLIST      ADDRESS OF PLD FOR BLANK LINE
SHOK     ST    RPARM,HEADLIST      STORE ADDR OF HEADING PARMS
         B     EXIT0               EXIT
         EJECT
******************
* CLOSE FUNCTION *
******************
         SPACE
* THIS CALL CLOSES THE PRINTER DATA SET.  IT DOES NOT MOVE THE PAGE
* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.
* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.
         SPACE 2
CLPROC   TM    DCBOFLGS,OPENBIT    IS DCB OPEN NOW?
         BZ    EXIT0               EXIT IF ALREADY CLOSED
         MVI   DWORK,X'80'         SET END-OF-LIST BIT
         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)
         SPACE
         FREEPOOL  PRINTDCB        FREE THE BUFFER CORE
         SPACE
         B     EXIT0               EXIT TO CALLER
         EJECT
************
* LISTPROC *
************
         SPACE
* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT
* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.
* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND
* 'RLPEXIT' CONTAINING THE EXIT ADDRESS.  IT MAY DISCOVER THAT ITS
* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING
* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED.  WHEN THIS OCCURS,
* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND
* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.
* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,
* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF
* YET ANOTHER CALL TO 'HEADPRNT'.)  AFTER THE HEADINGS ARE PRINTED,
* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND
* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS
* CONTINUED.
         SPACE 2
         USING PLDBLOCK,RPLD       TO ADDRESS PLD BLOCKS
         SPACE
LISTPROC L     RPLD,0(RPARM)       LOAD A PLD BLOCK ADDRESS
         SPACE
* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.
         SPACE
         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN
         TM    SWITCHES,HOFBIT     SEE IF HEAD-OF-FORM FLAG IS ON
         BO    HEADPRNT            EXIT IF SO
         SPACE 2
* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,
* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION.  IF NOT, BYPASS
* PRE-SPACING ALTOGETHER.
         SPACE
         TM    SWITCHES,TXT1BIT    TEST IF FIRST TEXT LINE
         BZ    PRSUBTR             BRANCH IF NOT
         TM    PLDFLAGS,PRHOFBIT   TEST IF ALLOW SKIP AT HOF
         BZ    POSTSP              SKIP PRESPACING IF NOT
         SPACE
* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.
         SPACE
PRSUBTR  SR    RSPACE,RSPACE
         IC    RSPACE,PLDSPB       LOAD AMOUNT TO SPACE
         SR    RBAL,RSPACE         DECREMENT PAGE BALANCE
         SPACE
* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE
* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.
         SPACE
         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIP
         BO    PREMOVE             BRANCH IF NOT
         TM    PLDFLAGS,PRSKPBIT   TEST IF USER ALLOWS SKIP
         BO    PREMOVE             BRANCH IF NOT
         LTR   RBAL,RBAL           TEST PAGE BALANCE
         BP    PREMOVE             BRANCH IF SOME LINES LEFT
         LA    RSPACE,EJFORCE      FORCE A PAGE SKIP
         SPACE
* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.
         SPACE
PREMOVE  BAL   RWA,MOVE            TO PAPER MOVING SUBROUTINE
         SPACE
* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.
         SPACE
         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN
         TM    SWITCHES,HOFBIT     TEST HEAD-OF-FORM BIT
         BO    HEADPRNT            EXIT IF AT HEAD
         SPACE 2
* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE
* IS PRINTED.  BEGIN BY COMPUTING THE NEW PAGE BALANCE.
         SPACE
POSTSP   SR    RSPACE,RSPACE
         IC    RSPACE,PLDSPA       LOAD AMOUNT TO SPACE AFTER PRINT
         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE
         SPACE
* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,
* AND FORCE A SKIP IF <= ZERO.
         SPACE
         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIPPING
         BO    GETPRCC             BRANCH IF NOT
         TM    PLDFLAGS,SPSKPBIT   TEST IF USER ALLOWS SKIPPING
         BO    GETPRCC             BRANCH IF NOT
         LTR   RBAL,RBAL           TEST FOR PAGE END
         BP    GETPRCC             BRANCH IF SOME LINES LEFT
         LA    RSPACE,EJFORCE      FORCE PAGE SKIP
         SPACE
* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER.  IN THE INTERESTS
* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT
* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS.  IN THE
* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER
* AND MERELY SPACE.  IF THIS IS TO BE THE FIRST HEADING LINE OF THE
* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO
* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.
         SPACE
GETPRCC  DS    0H
         SR    RWA,RWA
         IC    RWA,PLDLNGTH        LOAD NOMINAL LENGTH OF TEXT
         SR    RWB,RWB
         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET
         SPACE
         LA    R0,0(RWA,RWB)       LINE LENGTH = TEXT + OFFSET
         CH    R0,PAGWIDTH         TEST AGAINST PAGE WIDTH
         BNH   TSTHD1              BR IF OK
         LA    R1,5                ERROR, LINE TOO LONG
         B     ABEND
         SPACE
TSTHD1   TM    SWITCHES,HD1BIT     TEST IF FIRST HEADING LINE
         BZ    BLNKSCAN            BR IF NOT
         LH    RWB,PAGWIDTH        SET RECORD LENGTH AS PAGE WIDTH
         B     GETBUF              SKIP BLANK SCANNING
         SPACE
* SET UP A 'BXH' FOR SCAN.  R0 IS INCREMENT, R1 IS COMPARAND, RWA
* VARIABLE.
         SPACE
BLNKSCAN LH    R0,=H'-1'           INCREMENT IS MINUS 1
         L     R1,PLDTXTAD-1       LOAD TEXT ADDRESS
         LA    R1,0(R1)            ZERO HIGH-ORDER BYTE
         BCTR  R1,0                DECREMENT BY ONE
         AR    RWA,R1              SET RWA TO RIGHT-MOST TEXT BYTE
         SPACE
* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK.  RESULT IS NEW TEXT
* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.
         SPACE
BLNKLOOP CLI   0(RWA),C' '         TEST FOR NON-BLANK CHAR
         BNE   BLNKDONE            EXIT WHEN FOUND
         BXH   RWA,R0,BLNKLOOP
BLNKDONE SR    RWA,R1              NOW RWA IS NEW TEXT LENGTH
         BC    13,POSTMOVE         NO PRINTING IF <= 0
         SPACE
* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.
         SPACE
         AR    RWB,RWA             ADD TEXT LENGTH
         SPACE
* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF
* THE LINE.  THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE
* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS.  GET
* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.
         SPACE
GETBUF   LA    RWC,5(RWB)          LOAD LENGTH OF RECORD IN RWC
         STH   RWC,DCBLRECL        PUT LRECL IN DCB FOR PUT CALL
         SPACE
         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1
         SPACE
         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE
         LR    RWD,R1              RWD BECOMES BUFFER BASE REG
         MVI   3(RWD),C' '         CLEAR BUFFER TO BLANKS
         EX    RWB,BLNKMOVE
         SLL   RWC,16              SET UP 4-BYTE 'V' CONTROL FIELD
         ST    RWC,DWORK           CAN'T ASSUME BUFFER ON ANY
         MVC   0(4,RWD),DWORK      BOUNDARY
         SPACE
* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT
* THE PAGE NUMBER.
         SPACE
         TM    SWITCHES,HD1BIT     TEST IF FIRST LINE
         BZ    MOVETEXT            BRANCH IF NOT
         SPACE
         LA    RWC,0(RWB,RWD)      ADDRESS RIGHT END -5
         SH    RWC,=AL2(HLTXTLNG+10-5)  LOCATE PLACE FOR HEADING INFO
         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME
         SPACE
         LH    R1,PAGENO           INCREMENT PAGE NUMBER
         LA    R1,1(R1)
         STH   R1,PAGENO
         CVD   R1,DWORK            CONVERT TO DECIMAL
         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS
         LA    R1,HLTXTLNG+9(RWC)  IN CASE SIGNIFIGANCE FORCED
         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR "PAGE"
         SH    R1,=H'5'
         MVC   0(4,R1),=C'PAGE'    INSERT WORD "PAGE"
         SPACE
* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.
* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.
         SPACE
MOVETEXT BAL   RWB,CCGEN           GO GET CONTROL CHAR
         STC   R0,4(RWD)           INSERT IN BUFFER
         NI    4(RWD),B'11111101'  CHANGE SPACE IMMEDIATE TO WRITE
         SPACE
         SR    RWB,RWB
         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET
         LA    RWB,5(RWB,RWD)      ADDRESS FOR FIRST TEXT BYTE
         BCTR  RWA,0               DECREMENT LENGTH BY 1 FOR MVC
         L     RWC,PLDTXTAD-1      LOAD ADDRESS OF CALLER'S TEXT
         EX    RWA,MOVEINST        MOVE TEXT
         SPACE
         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS
         SPACE
* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.
         SPACE
         L     R1,MAXLINES
         S     R1,=F'1'            BCTR WOULD NOT SET COND CODE
         ST    R1,MAXLINES
         BP    POSTMOVE            BRANCH IF POSITIVE
         LA    R1,6                ABORT, TOO MUCH OUTPUT
         B     ABEND
         SPACE
* DO ANY ADDITIONAL SPACING NECESSARY.  AMOUNT STILL IN 'RSPACE'.
         SPACE
POSTMOVE BAL   RWA,MOVE            CALL PAPER MOVING SUBROUTINE
         SPACE 2
* NOW WE ARE FINISHED WITH THAT LINE.  IF THE ADDRESS WHICH POINTED TO
* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.
* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.
         SPACE
         LTR   RPLD,RPLD           TEST CURRENT PLD ADDRESS
         BCR   4,RLPEXIT           EXIT IF NEGATIVE
         SPACE
         LA    RPARM,4(RPARM)      INCREMENT LIST POINTER
         B     LISTPROC            TO PROCESS NEXT LINE
         SPACE 2
* EXECUTED INSTRUCTIONS:
         SPACE
BLNKMOVE MVC   4(0,RWD),3(RWD)     SPREAD BLANKS IN OUTPUT BUFFER
MOVEINST MVC   0(0,RWB),0(RWC)     MOVE CALLER'S TEXT TO OUTPUT BUF
         SPACE
         DROP  RPLD
         EJECT
************
* HEADPRNT *
************
         SPACE
* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT
* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE.  SAVE THE REGISTERS
* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING
* THE HEADING AND SUB-HEADING LINES.
         SPACE 2
HEADPRNT ST    RRET,HPREXIT        SAVE RETURN ADDRESS
         STM   RLPEXIT,RPARM,HPRSAVE  STORE LISTPROC REGISTERS
         SPACE
* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS
* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER.  RESET PAGE BALANCE.
         SPACE
         NI    SWITCHES,255-HOFBIT  RESET HOF BIT
         OI    SWITCHES,HD1BIT+NOSKBIT  SET HEADING AND NOSKIP BITS
         LH    RBAL,PAGELNG        RESET PAGE BALANCE
         SPACE
* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.
         SPACE
         L     RPARM,HEADLIST      ADDRESS OF HEADINGS LIST
         BAL   RLPEXIT,LISTPROC    CALL PROCESSING ROUTINE
         SPACE
* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF
* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE
* PAGE YET.  THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO
* PROCESSING THE CALLER'S LINES.
         SPACE
         NI    SWITCHES,255-NOSKBIT  RESET NO-SKIP BIT
         OI    SWITCHES,TXT1BIT    SET FIRST-TEXT-LINE BIT
         SPACE
         LM    RLPEXIT,RPARM,HPRSAVE  RESTORE LISTPROC REGISTERS
         L     RRET,HPREXIT        RECOVER EXIT ADDRESS AND
         BR    RRET                RETURN TO CALLER
         EJECT
***********************************
* MOVE - VERTICAL SPACING ROUTINE *
***********************************
         SPACE
* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER
* 'RSPACE'.  RETURN ADDRESS IS IN 'RWA'.  IF THE CONTROL CHARACTER FOR
* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE
* GENERATING ANY EXTRA LINES.
         SPACE 2
MOVE     LTR   RSPACE,RSPACE       TEST NUMBER OF LINES TO BE MOVED
         BCR   13,RWA              EXIT IF <= ZERO
         TM    SWITCHES,SP0BIT     DID PREVIOUS LINE SPACE 0?
         BZ    PREVNOT0            BRANCH IF NOT
         L     R1,CCLAST           GET ADDRESS OF PREVIOUS LINE
         BAL   RWB,CCGEN           GENERATE NEW CONTROL CHAR
         NI    4(R1),X'02'         TEST WRITE/SPACE BIT IN OLD CC
         STC   R0,4(R1)            STORE NEW CC IN PREVIOUS LINE
         BNZ   *+8                 BR IF WRITE/SPACE BIT WAS ON
         NI    4(R1),255-X'02'     TURN WRITE/SPACE BIT OFF
PREVNOT0 DS    0H
         MVC   DCBLRECL(2),MOVELINE  SET LOGICAL RECORD LENGTH IN DCB
         SPACE
         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1
         SPACE
         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE
         MVC   0(6,R1),MOVELINE    INSERT FORMAT 'V' CONTROL RECORD
         BAL   RWB,CCGEN           GET PRINT CONTROL CHAR IN R0
         STC   R0,4(R1)            INSERT IN RECORD
         SPACE
         B     MOVE                LOOP UNTIL 'RSPACE' IS ZERO
         SPACE 3
MOVELINE DC    XL6'000600000340'   FORMAT 'V' CONTROL RECORD
         EJECT
*****************************************
* CCGEN - GENERATE PRINTER CONTROL CHAR *
*****************************************
         SPACE
* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT
* IMMEDIATELY (WITHOUT PRINTING).  ENTER WITH THE TOTAL NUMBER OF
* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'.  EXITS
* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT
* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.
* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL
* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM
* BIT.  NOTE:  MUST NOT USE R1.
         SPACE 2
CCGEN    NI    SWITCHES,255-SP0BIT  RESET 'PREVIOUS SPACED 0' BIT
         CH    RSPACE,=AL2(EJFORCE)  TEST FOR EJECT REQUEST
         BL    CCNOEJ              BRANCH IF NOT
         LA    R0,X'8B'            LOAD 'SKIP TO CHAN 1' CC
         OI    SWITCHES,HOFBIT     SET HEAD-OF-PAGE BIT
         SR    RBAL,RBAL           SET PAGE BALANCE TO ZERO
         SR    RSPACE,RSPACE       SET REMAINING SPACING TO ZERO
         BR    RWB                 EXIT
         SPACE
CCNOEJ   LR    R15,RSPACE          LOAD WORK REGISTER
         CH    RSPACE,=H'3'        TEST IF OVER THREE LINES
         BNH   CCOK                BR IF <= 3
         LA    R15,3               SET 3, MAXIMUM FOR 1 OPERATION
CCOK     SR    RSPACE,R15          DECR RSPACE BY AMOUNT SPACED
         SLL   R15,3               PUT AMOUNT IN BITS 2-4 OF BYTE
         LA    R0,X'03'(R15)       ADD COMMAND BITS AND PUT IN R0
         LTR   R15,R15             TEST FOR ZERO SPACING
         BCR   7,RWB               EXIT IF NOT ZERO
         OI    SWITCHES,SP0BIT     SET 'LINE SPACED 0' BIT
         BR    RWB                 EXIT
         EJECT
***********************
* SYNAD ERROR ROUTINE *
***********************
         SPACE
* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.
         SPACE
SYNAD    SYNADAF ACSMETH=QSAM      GET ERROR MESSAGE FROM O/S
         LR    RWA,R1              SAVE MESSAGE ADDRESS
         GETMAIN R,LV=128          GET BUFFER FOR MESSAGE
         MVC   0(LIOMSG,R1),IOMSG  INSERT MESSAGE BEGINNING
         MVC   LIOMSG(79,R1),49(RWA)  ADD TEXT FROM O/S
         LR    RWA,R1              SAVE MESSAGE ADDRESS
         SYNADRLS                  FREE O/S MESSAGE
         WTO   MF=(E,(RWA))        TYPE MESSAGE ON CONSOLE
         LA    R1,7                LOAD ERROR CODE
         B     ABEND               TO ABORT AND DUMP
         SPACE
IOMSG    DC    AL2(LIOMSG+78,0)    FORMAT V CONTROL FIELD
         DC    C'XPRNTSUB I/O ERROR'
LIOMSG   EQU   *-IOMSG
         EJECT
**************************
* CONSTANTS AND LITERALS *
**************************
         SPACE
* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.
         SPACE
NOHDLIST DS    0F
         DC    XL1'80'             VL LIST BIT
         DC    AL3(NOHDPLD)        ADDRESS OF PLD BELOW
         SPACE
NOHDPLD  DS    0F                  ALIGN ON FULL-WORD BOUNDARY
         DC    BL1'00010000'       OPTION BITS
         DC    AL3(BLANK1)         PRINT TEXT ADDRESS
         DC    AL1(1)              PRINT TEXT LENGTH
         DC    AL1(0)              LEFT MARGIN INDENTATION
         DC    AL1(0)              SPACING BEFORE PRINTING
         DC    AL1(3)              SPACING AFTER PRINTING
         SPACE
* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS
* RECEIVED.  THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.
         SPACE
DEFAULTS DS    0F
         DC    A(NOHDLIST)         PAGE HEADING PARM LIST ADDRESS
         DC    F'1000000'          MAXIMUM NUMBER OF OUTPUT LINES
         DC    H'132'              PAGE WIDTH
         DC    H'57'               PAGE LENGTH            ***TRW***
         DC    H'0'                PAGE NUMBER (-1)
         DC    H'0'                PAGE BALANCE
         DC    X'00'               SWITCHES
DEFSIZE  EQU   *-DEFAULTS
         SPACE
* MISCELLANEOUS CONSTANTS:
         SPACE
BLANK1   DC    C' '                TEXT OF DUMMY HEADING LINE
         LTORG
         EJECT
*******************
* WORK AREA DSECT *
*******************
         SPACE
* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM
* PROGRAM FOR EACH DATA SET.  ITS ADDRESS IS PASSED IN PARAMETER
* REGISTER 0 AT EACH CALL.
         SPACE 2
WORKAREA DSECT
         SPACE 2
* STANDARD 18-WORD SAVE AREA:
         SPACE
SAVEAREA DS    18F
         SPACE 2
* DATA CONTROL BLOCK FOR PRINTER DATA SET:
         SPACE
         PRINT NOGEN
PRINTDCB DCB   DDNAME=SYSPRINT,                                        X
               DSORG=PS,                                               X
               RECFM=VBM,                                              X
               LRECL=137,                                              X
               MACRF=PL,                                               X
               BFTEK=S,                                                X
               BUFNO=2,                                                X
               EROPT=ACC
         PRINT GEN
         SPACE
DCBEXLST EQU   PRINTDCB+37         ADDRESS OF EXIT LIST
DCBOFLGS EQU   PRINTDCB+48         CONTAINS 'OPENED SUCCESSFULLY' BIT
DCBDDNAM EQU   PRINTDCB+40         DDNAME (WHEN CLOSED)
DCBSYNAD EQU   PRINTDCB+57         ADDRESS OF SYNCHRONOUS ERROR ROUTINE
DCBBLKSZ EQU   PRINTDCB+62         BLOCK SIZE
DCBLRECL EQU   PRINTDCB+82         LOGICAL RECORD LENGTH
         SPACE 2
* ADDRESS OF LAST BUFFER OBTAINED BY "PUT" MACRO:
         SPACE
CCLAST   DS    1A
         SPACE
         DS    1F                  SPARE FULL WORD
         SPACE 2
* TEMPORARY WORK CELLS:
         SPACE
DWORK    DS    1D                  DOUBLE-WORD WORK CELL
HPREXIT  DS    1F                  HEADPRNT EXIT SAVE
HPRSAVE  DS    2F                  HEADPRNT REGISTER STORAGE
         SPACE 2
* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.
* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.
         SPACE
PAPARMS  DS    0F
HEADLIST DS    1A                  PAGE HEADING PARM LIST ADDRESS
MAXLINES DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES
PAGWIDTH DS    1H                  PAGE WIDTH
PAGELNG  DS    1H                  PAGE LENGTH
PAGENO   DS    1H                  PAGE NUMBER OF CURRENT PAGE
PAGEBAL  DS    1H                  PAGE BALANCE
SWITCHES DS    1X                  SWITCHES
         SPACE 2
* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING:
         SPACE
HLTXTLNG EQU   24
HLTEXT   DS    CL(HLTXTLNG)
HLDAY    EQU   HLTEXT
HLTIME   EQU   HLTEXT+7
HLDATE   EQU   HLTEXT+16
         EJECT
*************************
* PARAMETER LIST DSECTS *
*************************
         SPACE 2
* PARAMETER LIST FOR 'EJECT' CALL:
         SPACE
EJPARM   DSECT
         SPACE
EJCOND   DS    1X                  CONDITIONAL MASK AND SWITCHES
EJQUAN   DS    1X                  CONDITIONAL TEST QUANTITY
         SPACE
EJATHOF  EQU   X'01'               MASK FOR 'EJCOND'
         SPACE 6
* PARAMETER LIST FOR 'SPACE' CALL:
         SPACE
SPPARM   DSECT
         SPACE
SPCOND   DS    1X                  CONDITIONAL BITS
SPQUAN   DS    1X                  NUMBER OF LINES TO SPACE
         SPACE
SPATHOF  EQU   X'01'               MASK FOR 'SPCOND'
SPNOEJ   EQU   X'02'               MASK FOR 'SPCOND'
         SPACE 6
* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS:
         SPACE
OMPARM   DSECT
         SPACE
OMMAXLIN DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES
OMPAGENO DS    1H                  INITIAL PAGE NUMBER
OMPAGWID DS    1X                  PAGE WIDTH
OMPAGLNG DS    1X                  PAGE LENGTH
OMTIMEAD DS    1A                  ADDRESS OF TIME
OMDATEAD DS    1A                  ADDRESS OF DATE
OMDDNAME DS    CL8                 DDNAME (OPEN CALL ONLY)
         EJECT
*************
* PLD DSECT *
*************
         SPACE
* PRINT LINE DESCRIPTOR DUMMY SECTION:
         SPACE 2
*        ******************************************************
*        *            *                                       *
*        *   OPTION   *                                       *
*        *    BITS    *             TEXT ADDRESS              *
*        *            *                                       *
*        ******************************************************
*        *            *            *            *             *
*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *
*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *
*        *            *            *            *             *
*        ******************************************************
         SPACE 3
PLDBLOCK DSECT
         SPACE
PLDFLAGS DS    1X                  OPTION BITS
PLDTXTAD DS    AL3                 TEXT ADDRESS
PLDLNGTH DS    1X                  TEXT LENGTH
PLDOFFST DS    1X                  TEXT OFFSET, OR LEFT MARGIN
PLDSPB   DS    1X                  AMOUNT TO SPACE BEFORE PRINTING
PLDSPA   DS    1X                  AMOUNT TO SPACE AFTER PRINTING
         SPACE 2
PRHOFBIT EQU   B'00000010'         MASK FOR 'PLDFLAGS'
PRSKPBIT EQU   B'00000001'         MASK FOR 'PLDFLAGS'
SPSKPBIT EQU   B'00010000'         MASK FOR 'PLDFLAGS'
         TITLE 'DATE EDITING ROUTINE "XDATEDIT"'
* STATUS:  VERSION 0, MOD 2, 5 OCTOBER 1967.
         SPACE
* FUNCTION/OPERATION:  EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO
*        EBCDIC MONTH-DAY-YEAR FORM.  CORRECTS FOR LEAP YEARS AND
*        FOR THE TURN OF A CENTURY.
         SPACE
* ENTRY POINTS:  ENTER AT "XDATEDIT" VIA BALR 14,15 WITH REG 13 SET
*        TO A STANDARD 18-WORD SAVE AREA.  REGISTER 1 POINTS TO A
*        PARAMETER LIST CONTAINING ONE ADDRESS.
         SPACE
* INPUT:  THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED
*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS:
*        X'0000000000YYDDD+'.
         SPACE
* OUTPUT:  THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS
*        C'MM/DD/YY'.
         SPACE
* DATA SETS:  NONE.
         SPACE
* EXTERNAL ROUTINES:  NONE.
         SPACE
* EXITS-NORMAL:  RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.
         SPACE
* EXITS-ERROR:  IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE
*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4
*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.
         SPACE
* TABLES/WORK AREAS:  NONE.
         SPACE
* ATTRIBUTES:  REENTRANT, READ ONLY.
         SPACE
* NOTES:  NONE.
         EJECT
* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.
         SPACE
DUMMY    DSECT
DWORD    DS    1D
         SPACE 6
* BEGIN CONTROL SECTION HERE.  DEFINE REGISTER TAGS.
         SPACE
XDATEDIT CSECT
         SPACE
RDSECT   EQU   11                  BASE REG FOR ARGUMENT/RESULT
RPARMD   EQU   1                   PARAMETER LIST POINTER
RARGSAVE EQU   2                   TO SAVE ORIGINAL PACKED ARGUMENT
RMONTH   EQU   3
RDAY     EQU   4                   RDAY AND RYEAR ARE AN EVEN/ODD
RYEAR    EQU   5                   PAIR FOR DIVISION
RWORK    EQU   6
RLIST    EQU   7
         SPACE 6
* ENTER HERE.  SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.
         SPACE
         SAVE  (14,12),,*
         SPACE
         BALR  RBASE,0
         USING *,RBASE
         L     RDSECT,0(RPARMD)    LOAD ARGUMENT ADDRESS
         USING DWORD,RDSECT
         EJECT
* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.
         SPACE
         MVI   DWORD,X'00'         CLEAR HIGH DECIMAL DIGITS
         MVC   DWORD+1(4),DWORD    IN ARG TO ZEROS
         OI    DWORD+7,X'0F'       FORCE PLUS SIGN
         L     RARGSAVE,DWORD+4    SAVE ARGUMENT FOR 'BADDATE'
         SPACE
         CVB   RYEAR,DWORD         CONVERT YYDDD TO BINARY
         SR    RDAY,RDAY           CLEAR HIGH-ORDER DIVIDEND
         D     RDAY,F1000          QUOTIENT=YEAR; REMAINDER=DAY
         SPACE
* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE
* LIST OF MONTH SIZES.
         SPACE
DAYOK    DS    0H
         LA    RLIST,STDLIST       POINT RLIST TO STANDARD MONTHS
         LTR   RWORK,RYEAR         LOAD BINARY YEAR NUMBER
         BZ    NOTLEAP             BR IF TURN OF CENTURY
         N     RWORK,=F'3'         TEST LOW TWO BITS
         BC    4,NOTLEAP           BR IF NON-ZERO
         LA    RLIST,LPYLIST       POINT RLIST TO LEAP-YEAR MONTHS
NOTLEAP  DS    0H
         SPACE
* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY
* THE YEAR NUMBER.
         SPACE
         LTR   RDAY,RDAY           TEST FOR ZERO
         BZ    BADDATE             BR IF SO
         CH    RDAY,0(0,RLIST)     TEST FOR UPPER LIMIT
         BH    BADDATE             BR IF TOO LARGE
         SPACE
* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.
         SPACE
         LA    RMONTH,1            INITIAL MONTH NUMBER
         SR    RWORK,RWORK
DAYLOOP  IC    RWORK,1(RMONTH,RLIST)  LENGTH OF MONTH INTO RWORK
         CR    RDAY,RWORK          TEST IF DAY IN THIS MONTH
         BNH   DAYDONE             BR IF DAY LESS THAN MONTH SIZE
         SR    RDAY,RWORK          REDUCE DAY BY LENGTH OF MONTH
         LA    RMONTH,1(RMONTH)    INCREMENT MONTH
         B     DAYLOOP
DAYDONE  DS    0H
         SPACE
* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING
* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.
* THE TRICK IS THAT  1000(1000(MONTH)+DAY)+YEAR  GIVES  MM0DD0YY  WHEN
* CONVERTED TO DECIMAL.  AFTER UNPACKING, THE ZEROS ARE REPLACED BY
* SLASHES.
         SPACE
         MH    RMONTH,H1000
         AR    RMONTH,RDAY
         MH    RMONTH,H1000
         AR    RMONTH,RYEAR
         CVD   RMONTH,DWORD
         MVC   DWORD(5),DWORD+3    MOVE OVER FOR UNPACKING
         UNPK  DWORD(8),DWORD(5)   CONVERT TO ALPHA
         OI    DWORD+7,X'F0'       COVER UP SIGN
         MVI   DWORD+2,C'/'        INSERT SLASHES
         MVI   DWORD+5,C'/'
         SR    15,15               SET NORMAL RETURN CODE OF 0
         SPACE
EXITD    RETURN  (14,12),T,RC=(15)  RETURN TO CALLER
         SPACE 2
* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN
* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.
         SPACE
BADDATE  ST    RARGSAVE,DWORD      RESTORE ORIGINAL PACKED ARGUMENT
         UNPK  DWORD+2(5),DWORD+1(3)  UNPACK INTO ALPHA
         MVC   DWORD+1(2),DWORD+2  SHIFT YEAR 1 LEFT
         MVI   DWORD,C' '          APPLY COSMETICS
         MVI   DWORD+3,C'.'
         MVI   DWORD+7,C' '
         LA    15,4                SET RETURN CODE
         B     EXITD
         EJECT
* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS:
         SPACE
         SPACE
STDLIST  DC    H'365'              DAY LIMIT FOR STANDARD YEARS
         DC    AL1(31)
         DC    AL1(28)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         SPACE
LPYLIST  DC    H'366'              DAY LIMIT FOR LEAP YEARS
         DC    AL1(31)
         DC    AL1(29)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         SPACE
F1000    DC    F'1000'
H1000    EQU   F1000+2
         LTORG
./       ADD   NAME=RCPDDN
         MACRO
         RCPDDN &DDN
         GBLC  &DYNP
         SPACE 1
***********************************************************************
**   BUILD THE DDNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DDN'(K'&DDN,1) EQ '/').BTU
         AIF   ('&DDN'(1,1) EQ '''').Q
         RCPSR2
         AIF   ('&DDN'(1,1) EQ '(').R
         L     R14,&DDN                LOAD ADDRESS OF DDNAME
         LH    R2,&DDN+4               LOAD LENGTH OF DDNAME
         AGO   .STH
.R       L     R14,0&DDN               LOAD ADDRESS OF DDNAME
         LH    R2,4&DDN                LOAD LENGTH OF DDNAME
.STH     STH   R2,S99TULNG             STORE DDNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DDNAME
         MVI   S99TUKEY+1,DALDDNAM     MOVE IN DDNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.Q       RCPBTU DALDDNAM,1,&DDN
         MEXIT
.BTU     RCPTUBFR DALDDNAM,14,&DDN
         MEND
./       ADD   NAME=RCPDINC
         MACRO
         RCPDINC &L1
         GBLA  &DTUO,&DTUPO
         GBLC  &DYNP
         AIF   ('&L1' EQ '').T2
         ST    R15,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
         LA    R15,&L1.(R15)           BUMP TEXT UNIT PTR TO NEXT SLOT
&DTUPO   SETA  &DTUPO+4
&DTUO    SETA  &DTUO+&L1
         MEXIT
.T2      ST    R14,&DYNP.TUP+&DTUPO    STORE TEXT UNIT ADDRESS
&DTUPO   SETA  &DTUPO+4
         MEND
./       ADD   NAME=RCPDISP
         MACRO
         RCPDISP &DISP
         LCLA  &I
         LCLB  &B(4)
         AIF   ('&DISP(1)' EQ '').TD2
         SPACE
***********************************************************************
**     DATA SET INITIAL STATUS                                       **
***********************************************************************
&B(1)    SETB  ('&DISP(1)' EQ 'SHR')
&B(2)    SETB  ('&DISP(1)' EQ 'NEW')
&B(3)    SETB  ('&DISP(1)' EQ 'MOD')
&B(4)    SETB  ('&DISP(1)' EQ 'OLD')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK1
         MNOTE 8,'&DISP(1) IS INVALID, DISP=SHR USED'
&B(1)    SETB  1
.OK1     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DALSTATS,1,1,X'0&I.00')
         RCPDINC 8
.TD2     AIF   ('&DISP(2)' EQ '').TD3
         SPACE
***********************************************************************
**    DATA SET NORMAL DISPOSITION                                    **
***********************************************************************
&B(1)    SETB  ('&DISP(2)' EQ 'KEEP')
&B(2)    SETB  ('&DISP(2)' EQ 'DELETE')
&B(3)    SETB  ('&DISP(2)' EQ 'CATLG')
&B(4)    SETB  ('&DISP(2)' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK2
         MNOTE 8,'&DISP(2) IS INVALID, DISP=(,KEEP) USED'
&B(1)    SETB  1
.OK2     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVC   S99TUKEY(8),=Y(DALNDISP,1,1,X'0&I.00')
         RCPDINC 8
.TD3     AIF   ('&DISP(3)' EQ '').EXIT
         SPACE
***********************************************************************
**   DATASET CONDITIONAL DISPOSITION                                 **
***********************************************************************
&B(1)    SETB  ('&DISP(3)' EQ 'KEEP')
&B(2)    SETB  ('&DISP(3)' EQ 'DELETE')
&B(3)    SETB  ('&DISP(3)' EQ 'CATLG')
&B(4)    SETB  ('&DISP(3)' EQ 'UNCATLG')
         AIF   (&B(1) OR &B(2) OR &B(3) OR &B(4)).OK3
         MNOTE 8,'&DISP(3) IS INVALID, DISP=(,,KEEP) USED'
&B(1)    SETB  1
.OK3     ANOP
&I       SETA  8*&B(1)+4*&B(2)+2*&B(3)+&B(4)
         MVI   S99TUKEY(8),=Y(DALCDISP,1,1,X'0&I.00')
         RCPDINC 8
.EXIT    MEND
./       ADD   NAME=RCPDSN
         MACRO
         RCPDSN &DSN,&MEM
         LCLC  &MEMBER
         GBLC  &DYNP
         SPACE
***********************************************************************
**   BUILD THE DSNAME TEXT UNIT                                      **
***********************************************************************
         AIF   ('&DSN'(1,1) EQ '''').Q
         AIF   ('&DSN'(K'&DSN,1) EQ '/').BD
         AIF   ('&DSN'(1,1) EQ '(').REG
         AIF   ('&DSN'  EQ '*').TERM
         RCPSR2
         L     R14,&DSN                LOAD ADDRESS OF DSNAME
         LH    R2,&DSN+4               LOAD LENGTH OF DSNAME
.STH     STH   R2,S99TULNG             STORE DSNAME LENGTH
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE DSNAME
         MVI   S99TUKEY+1,DALDSNAM     MOVE IN DSNAME KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 50
         AGO   .TMEMBER
.REG     L     R14,0&DSN               LOAD ADDRESS OF DSNAME
         RCPSR2
         LH    R2,4&DSN                LOAD LENGTH OF DSNAME
         AGO   .STH
.TERM    MVI   S99TUKEY+1,DALTERM
         RCPDINC 4
         MEXIT
.BD      RCPTUBFR DALDSNAM,50,&DSN
         AGO   .TMEMBER
.Q       RCPBTU DALDSNAM,1,&DSN
.TMEMBER AIF   ('&MEM' EQ '').EXIT
         SPACE
***********************************************************************
**   BUILD THE MEMBER NAME TEXT UNIT                                 **
***********************************************************************
&MEMBER  SETC  '&MEM'
         AIF   ('&MEM' NE '*').MOK
         AIF   ('&DSN'(1,1) NE '''').MAST
         MNOTE 8,'MEMBER=* INVALID WITH QUOTED DSNAME'
         MEXIT
.MAST    ANOP
&MEMBER  SETC  '8+&DSN'
.MOK     ANOP
         AIF   ('&MEMBER'(K'&MEMBER,1) EQ '/').BM
         RCPSR2
         AIF   ('&MEMBER'(1,1) EQ '(').RM
         LH    R2,4+&MEMBER            LOAD LENGTH OF MEMBER NAME
         LTR   R2,R2                   TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,&MEMBER             LOAD ADDRESS OF MEMBER
         AGO   .STHM
.RM      LH    R2,4&MEMBER             LOAD LENGTH OF MEMBER
         LTR   R2,R2                   AND TEST FOR ZERO
         BZ    *+30                    IF NO MEMBER, SKIP
         L     R14,0&MEMBER            LOAD ADDRESS OF MEMBER
.STHM    STH   R2,S99TULNG             STORE LENGTH OF MEMBER
         BCTR  R2,0                    DECREMENT FOR EXECUTE
         EX    R2,&DYNP.MVC            MOVE IN MEMBER NAME
         MVI   S99TUKEY+1,DALMEMBR     MOVE IN MEMBER KEY
         MVI   S99TUNUM+1,1            SET NUMBER FIELD
         RCPDINC 14
         MEXIT
.BM      RCPTUBFR DALMEMBR,14,&MEMBER
         MEXIT
.QM      RCPBTU DALMEMBR,1,&MEMBER
.EXIT    MEND
./       ADD   NAME=RCPSR2
         MACRO
         RCPSR2 &A
         GBLB  &RCPSR2
         GBLC  &DYNP
         LCLC  &C
.*   TO SAVE REG 2 IN REG 0 FOR ALLOC INNER MACROS FIRST TIME ONLY
.*    IF OPERAND SUPPLIED AND SAVE DONE, RESTORES REG 2 AND
.*    GENERATES MOVE INSTRUCTION FOR EXECUTE
         AIF   ('&A' NE '').UNSAVE
         AIF   (&RCPSR2).EXIT
&RCPSR2  SETB  1
         LR    R0,R2                   SAVE CONTENTS OF REGISTER 2
         MEXIT
.UNSAVE  AIF   (NOT &RCPSR2).EXIT
         B     *+10                    SKIP NEXT INSTRUCTION
&C       SETC  '&DYNP.MVC'
&C       MVC   S99TUPAR(0),0(R14)      EXECUTED MOVE
         LR    R2,R0                   RESTORE CONTENTS OF REGISTER 2
&RCPSR2  SETB  0
.EXIT    MEND
./       ADD   NAME=SAVE
         PRINT NOGEN
         COPY  $DOC
&NAME    SETC  'LISTICAT'
&VERSION SETC  '1.3.3'
         PUNCH ' SETCODE AC(1) '
LISTICAT TITLE ' - LIST AN ICF CATALOG.'
         $REGS
LISTICAT $PROLOG R10,R11,R12
         LR    R6,R1               SAVE JCL PARM
         L     R4,=V(DATASECT)     COMMON DATA AREA
         USING DATASECT,R4
        $MESSAGE 1                                                 @122
         L     R15,=V(PARMS)       ADDRESS OF PARM DECODER.        @130
         BALR  R14,R15             GO TO IT.                       @130
         LR    R1,R6               RESTORE JCL PARM
         L     R1,0(0,R1)          GET PARM POINTER
         LH    R2,0(0,R1)          GET PARM SIZE
         LTR   R2,R2               ANY PARM GIVEN?
         BZ    NOPARM              NO, ASSUME LIST
         BCTR  R2,0                MAKE IT THE MACHINE LENGTH   15JAN88
         ST    R2,DSPFXL           SAVE PREFIX PARM LENGTH      15JAN88
         EX    R2,MOVEPFX          SAVE THE PARM PREFIX         15JAN88
         B     NOPARM                                           15JAN88
MOVEPFX  MVC   DSPFX(0),2(R1)      EXECUTED INSTRUCTION!        15JAN88
NOPARM   DS    0H
         TM    FLAGS1,DUMP         HEX LISTING WANTED?             @130
         BO    HEXPRINT            YES.                            @130
         XPROPEN PWA,                                                  X
               PAGELEN=PAGELEN,                                        X
               DDNAME=SYSPRINT     OPEN LISTING FILE.
         LTR   R15,R15             DID SYSPRINT OPEN?
         BNZ   EODICAT             IF NOT, NO REPORT.
         L     R15,=V(ALLVVDS)                                     @130
         BALR  R14,R15             ALLOCATE ALL VVDS'S             @130
         SPACE ,
         LA    R0,1                INDICATE AUTHORIZATION ON.
         SVC   232                 ***** INSTALLATION DEPENDANT ******
         SPACE ,
         L     R2,CVTPTR           A(CVT)
         L     R2,0(0,R2)          TCB WORDS
         L     R2,0(0,R2)          MY TCB.
         USING TCB,R2
         L     R2,TCBJSCB          TCB -> JSCB.
         DROP  R2
         USING IEZJSCB,R2
         L     R2,JSCBACT          ACTIVE JSCB.
         MODESET KEY=ZERO          JSCB IS IN KEY ZERO.
         SPACE ,
*
* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING
* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER
* A BREAK.
*
         OI    JSCBSWT1,JSCBPASS   SAY, NO PASSWORDS PLEASE.
         SPACE ,
         MODESET KEY=NZERO         BACK TO USER KEY.
         OPEN  ACBICAT             OPEN THE BCS CLUSTER.
         LTR   R15,R15             DID IT OPEN?
         BZ    OPENOK              YES.
         SHOWCB  ACB=ACBICAT,                                          X
               AREA=OPENERR,                                           X
               LENGTH=4,                                               X
               FIELDS=(ERROR)      STORE OPEN ERROR CODE.
         L     R3,OPENERR          PICK ERROR CODE.
         ABEND 14,DUMP             AND DIE.
OPENOK   MODESET KEY=ZERO          KEY ZERO TO MODIFY JSCB.
         NI    JSCBSWT1,255-JSCBPASS  BYPASS PASSWORD OFF.
         MODESET KEY=NZERO         BACK TO USER KEY.
         DROP  R2
         SR    R0,R0               INDICATE AUTHORIZATION OFF.
         SVC   232                 ***** INSTALLATION DEPENDANT. *****
         BAL   R9,GENRPL           GENERATE RPL FOR BCS.           @120
         TITLE ' - READ BCS RECORDS AND SCAN FOR CELL TYPES.'
GETNEXT  L     R1,RPLICAT          PICK UP RPL ADDRESS.
         GET   RPL=(1)             READ A BCS RECORD.
         AP    BCSGETS,ONE         KEEP TRACK OF GETS ISSUED.
         LTR   R15,R15             RECORD READ OK?
         BZ    GETOK               GO PROCESS IT.
         ABEND 15,DUMP             TOO BAD!
GETOK    L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R1,RPLICAT          ADDR OF BCS RPL.
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R3               POINT TO END OF CATALOG RECORD
         ST    R1,ENDBCS           SAVE END OF RECORD.
         LA    R3,2(,R3)           SKIP OVER PREFIX
NEXTCELL CLI   2(R3),C'A'          A = NONVSAM
         BE    NONVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    CLUSTER
         CLI   2(R3),C'D'          D = DATA
         BE    DATA
         CLI   2(R3),C'I'          I = INDEX
         BE    INDEX
         CLI   2(R3),C'B'          B = GDG BASE
         BE    GDGBASE
         CLI   2(R3),X'05'         X'05' = GDG AGING TABLE      16DEC86
         BE    GDGAGE                                           16DEC86
         CLI   2(R3),C'H'          H = GDG ENTRY
         BE    GDGENT
         CLI   2(R3),C'G'          G = ALTERNATE INDEX
         BE    AIX
         CLI   2(R3),C'R'          R = PATH
         BE    PATH
         CLI   2(R3),X'04'         X'04' = VOLUME CELL          13JAN88
         BE    VOLCEL                                           13JAN88
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
ENDCELL  XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         SR    R1,R1               CLEAR REGISTER.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         LTR   R1,R1                                               @AVV
         BNP   GETNEXT            SKIP ZERO LENGTH CELL (?)        @AVV
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    NEXTCELL            YES, KEEP GOING
         B     GETNEXT             READ ANOTHER RECORD.
EODICAT  EQU   *                   LAST BCS RECORD READ.
         CLOSE ACBICAT
         CLI   MCDSOPEN,255        DID WE OPEN THE MCDS?           @122
         BNE   EODICAT1            NO.                             @122
         CLOSE ACBMCDS             IF OPEN, CLOSE IT.              @122
EODICAT1 DS    0H                                                  @122
         BAL   R9,COUNTS           PRINT THE STATS.
         XPRCLOSE  PWA             CLOSE THE PRINT FILE.
        $MESSAGE 0                                                 @122
         $EPILOG ,                 AND GO HOME.
         TITLE ' - LIST A NONVSAM RECORD.'
         USING NVNC,R3
NONVSAM  AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   NONVSAM1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
NONVSAM1 MVC   L1DSNAME,NVNAME     SETUP DSNAME
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,NONVSAML,ENDCELL       @130
NONVSAML DS    0H                                                  @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,NONVSAMN    @130
NONVSAMN DS    0H                                                  @130
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    NONVCON2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    NONVCON1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTNVSAM,ONE        NO MATCH, DON'T PUT IN COUNT 15JAN88
         B     NONVCON2            CONTINUE PROCESS             15JAN88
NONVCON1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
NONVCON2 EQU   *                                                15JAN88
         MVC   L1TYPE,=C'NONVSAM'  SAY WHAT TYPE IT IS.
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,NONVSAMV,ENDCELL      @130
NONVSAMV DS    0H                                                  @130
        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,NONVSAMX   @130
NONVSAMX DS    0H                                                  @130
         MVC   L1UNIT,=C'????'     CALL IT ???? IF UNIT NOT FOUND.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
NONVSAM3 CLC   VOLDEVTP,0(R5)      IS THIS IT
         BE    NONVSAM4            YES. GO GET DEVICE TYPE.
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    NONVSAM5            LEAVE IT AT ????
         B     NONVSAM3            CHECK NEXT DEVICE TYPE.
NONVSAM4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
         TM    2(R5),X'20'         IS IT A DASD DEVICE?
         BZ    NONVSAM5            IF NOT, NO VTOC TO SEARCH.
         BAL   R9,VTOC             GET DSCB FIELDS
NONVSAM5 CLC   L1VOLUME,=C'MIGRAT' IS IT MIGRATED BY HSM
         BNE   NONVSAM6            IF NOT, SKIP MCDS CHECK.
         BAL   R9,CHKHSM           SETUP MCDS FIELDS.
NONVSAM6 L     R1,LRECL            PICK UP LRECL VALUE.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY
*  THE FULL WORD TRACKS IS BEING USED AS A INDICATOR FOR THE DATASET
*  BEING CATALOGED BUT NOT FOUND ON THE PACK THAT IT'S CATALOGED ON.
         CLC   TRACKS,=XL4'FFFFFFFF' IS THE DATAST NOT ON PACK  30NOV87
         BNE   NONVSAM7            IF WAS FOUND, BRANCH AROUND. 30NOV87
         XC    TRACKS,TRACKS       ELSE, CLEAR OUT TRACKS CTR.  30NOV87
         MVI   L1DSNAME+45,C'*'    HILITE DATASET IN LISTING.   30NOV87
NONVSAM7 EQU   *                                                30NOV87
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,                                               X
               DWK4,ZZZZZZZ        FORMAT IT NICELY.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         DROP  R3
         TITLE ' - LIST THE SECOND TO N-TH VOLUME CELLS'        13JAN88
         USING VOLCELL,R3                                       13JAN88
VOLCEL   EQU   *                                                13JAN88
         CLI   VOLSW,255           WAS VOL CELL IMMED. BEFORE   13JAN88
         BE    VOLCEL1        YES, PRINT THE CELL INFO          13JAN88
         B     ENDCELL        NO,  PROCESS NEXT BCS CELL.       13JAN88
VOLCEL1  MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER   13JAN88
         MVC   L1UNIT,=C'????'  CALL IT ???? IF UNIT NOT FOUND. 13JAN88
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.           13JAN88
VOLCEL2  CLC   VOLDEVTP,0(R5)      IS THIS IT                   13JAN88
         BE    VOLCEL3             YES. GO GET DEVICE TYPE.     13JAN88
         LA    R5,12(,R5)          NEXT DEVICE ENTRY            13JAN88
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE                 13JAN88
         BE    VOLCEL4             LEAVE IT AT ????             13JAN88
         B     VOLCEL2             CHECK NEXT DEVICE TYPE.      13JAN88
VOLCEL3  MVC   L1UNIT,4(R5)    SET UP DEVICE TYPE IN PRINT LINE 13JAN88
VOLCEL4  MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1 13JAN88
         BAL   R9,PRINT            PRINT LINE.                  13JAN88
         B     ENDCELL             PROCESS NEXT BCS CELL.       13JAN88
         DROP  R3                                               13JAN88
         TITLE ' - LIST A CLUSTER RECORD.'
         USING VCNC,R3
CLUSTER  AP    CNTCLUST,ONE        COUNT A CLUSTER.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER1 DS    0H
         CLI   CLNAME,X'00'        DOES THE NAME START WITH X'00'
         BNE   MVWHOLE             NO MOVE THE REAL NAME
         MVC   L1DSNAME(23),=C'INDEXED CATALOG CLUSTER'   ELSE USE THIS
         B     MVCLUSTR            CONTINUE WITH CLUSTER ROUTINE
MVWHOLE  EQU   *
         MVC   L1DSNAME,CLNAME     SETUP CLUSTER NAME.
MVCLUSTR EQU   *
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    CLSTCON2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    CLSTCON1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTCLUST,ONE        NOMATCH DON'T INCL IN COUNT  15JAN88
         B     CLSTCON2            CONTINUE PROCESS             15JAN88
CLSTCON1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
CLSTCON2 EQU   *                                                15JAN88
         MVC   L1TYPE,=C'CLUSTER'  CALL IT A CLUSTER.
         CLI   FIRST,0             FIRST CLUSTER CELL?
         BNE   NOTCL00             NO
         MVI   FIRST,255           THAT WAS THE ONE.
         ST    R3,SAVECL           FIRST CLUSTER HAS BCS NAME.
GETBCSD  SR    R1,R1               CLEAR A FEW BYTES.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         CLI   2(R3),C'D'          IS IT A DATA CELL?
         BNE   GETBCSD             KEEP ON LOOKING.
         DROP  R3
         USING DINC,R3
         SR    R1,R1                                               @121
         IC    R1,DIDKEYLN         GET LENGTH OF CATALOG NAME.     @121
         SH    R1,=H'2'            DROP TWO BYTES OF JUNK          @130
         B     *+10                                                @121
         MVC   CATNAME(0),DIDKEY   SETUP CATNAME IN HEADING.       @121
         EX    R1,*-6                                              @121
         BAL   R9,SETHEAD          DEFINE REPORT HEADING.
         L     R3,SAVECL           RESTORE CELL ADDR TO CLUSTER.
NOTCL00  BAL   R9,SETCREDT         FORMAT CREATION DATE.
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,CLUSTERL,ENDCELL       @130
CLUSTERL DS    0H                                                  @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,CLUSTERN    @130
CLUSTERN DS    0H                                                  @130
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         DROP  R3
         USING DINC,R3
DATA     MVC   L1TYPE,=CL7'DATA'   DATA CELL (PARDON THE EXPRESSION)
         AP    CNTDATA,ONE         COUNT IT.
         B     SKIPDATA            GOTO COMMON FORMATTING LOGIC.
INDEX    MVC   L1TYPE,=CL7'INDEX'  CALL IT AN INDEX
         AP    CNTINDEX,ONE        AND COUNT IT.
SKIPDATA SR    R1,R1               CLEAR A REGISTER.
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         IC    R1,DIDKEYLN         LENGTH OF INDEX/DATA NAME
         SH    R1,=H'2'            CORRECT LENGTH PLEASE           @130
         EX    R1,DIDMOVE          MOVE COMPONENT NAME FOR PRINT
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    CLSTRCN2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    CLSTRCN1            MATCH, TURN ON PRINT         15JAN88
         CLI   L1TYPE,C'D'         WAS IT DATA TYPE             15JAN88
         BNE   CLSTRCN3         NO,CHECK FOR INDEX              15JAN88
         SP    CNTDATA,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     CLSTRCN2            CONTINUE PROCESS             15JAN88
CLSTRCN3 CLI   L1TYPE,C'I'         WAS IT INDEX TYPE            15JAN88
         BNE   CLSTRCN2         NO,CONTINUE PROCESS             15JAN88
         SP    CNTINDEX,ONE        DON'T INCLUDE IN COUNT       15JAN88
         B     CLSTRCN2            CONTINUE PROCESS             15JAN88
CLSTRCN1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
CLSTRCN2 EQU   *                                                15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER2            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER2 BAL   R9,SETCREDT         FORMAT CREATION DATE.
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,DATIDXL,ENDCELL        @130
DATIDXL  DS     0H                                                 @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,DATIDXN     @130
DATIDXN  DS     0H                                                 @130
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,CLUSTERV,ENDCELL      @130
CLUSTERV DS    0H                                                  @130
        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,CLUSTERX   @130
CLUSTERX DS    0H                                                  @130
         MVC   L1UNIT,=C'????'     JUST IN CASE OF UNKNOWN DEVICE.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
CLUSTER3 CLC   VOLDEVTP,0(R5)      IS THIS IT?
         BE    CLUSTER4            YES
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    CLUSTER5            LEAVE IT ????
         B     CLUSTER3            TRY NEXT DEVICE TYPE.
CLUSTER4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
CLUSTER5 MVC   RBASAVE,VOLVVRBA    SAVE RBA OF CI CONTAINING VVR CELL.
         DROP  R3
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
CLUSTER8 CLI   VVDSVOL,255         LAST ENTRY?
         BE    CLUSTER7            YES, OH WELL.
         CLC   VVDSVOL,L1VOLUME    IS THIS THE VVDS?
         BNE   CLUSTER6            NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT INTO ARG FIELD FOR RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(8)             POSITION TO DESIRED RECORD
         GET   RPL=(8)             READ IN RECORD
         AP    VVDSGETS,ONE        KEEP A COUNT.
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD
         LA    R6,2(,R6)           SKIP OVER PREFIX
         BAL   R9,VVDS             PROCESS VVDS FIELDS.
         C     R15,=F'8'           DID WE GET THEM?                @122
         BNE   CLUSTER6            YES.                            @122
        $MESSAGE 4,DATA=L1DSNAME                                   @122
         B     CLUSTER9            PRINT WHAT WE GOT.              @122
CLUSTER6 LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     CLUSTER8            TRY NEXT VVDS
         DROP  R5
CLUSTER7 L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          GET PHYSICAL BLOCK LENGTH.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,                                               X
               DWK3,ZZZZZ          FORMAT IT NICELY.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,                                               X
               DWK4,ZZZZZZZ        FORMAT IT NICELY.
CLUSTER9 DS    0H                                                  @122
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         USING DINC,R3
DIDMOVE  MVC   L1DSNAME(0),DIDKEY  -> (EXECUTED) <-
         DROP  R3
         TITLE ' - LIST AN ALTERNATE INDEX RECORD.'
         USING ANC,R3
AIX      AP    CNTAIX,ONE          COUNT AN AIX ENTRY.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   AIX0                NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
AIX0     MVC   L1TYPE,=CL7'AIX'    CALL IT AN AIX.
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,AIXKEYLN       PICK UP AIX NAME LENGTH
         SH    R1,=H'2'            CORRECT LENGTH.                 @130
         B     AIX1                BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),AIXKEY  EXECUTED
AIX1     EX    R1,*-6              MOVE AIX NAME TO PRINT LINE.
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    AIXCONT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    AIXCONT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTAIX,ONE          DON'T INCLUDE IN COUNT       15JAN88
         B     AIXCONT2            CONTINUE PROCESS             15JAN88
AIXCONT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
AIXCONT2 EQU   *                                                15JAN88
         HEX   RPTLINE1+75,                                            X
               ANC,7,HEXTAB=TRHEX  HEX TRANSLATE AIX CELL CONTENTS.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         TITLE ' - LIST A PATH RECORD.'
         USING PNC,R3
PATH     AP    CNTPATH,ONE         COUNT A PATH CELL.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   PATH0               NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
PATH0    MVC   L1TYPE,=CL7'PATH'   CALL IT A PATH.
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,PATHKYLN       PICK UP PATH NAME LENGTH
         SH    R1,=H'2'            CORRECT LENGTH                  @130
         B     PATH1               BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),PATHNAME  EXECUTED
PATH1    EX    R1,*-6              MOVE PATH NAME TO PRINT LINE.
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    PATHCNT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    PATHCNT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTPATH,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     PATHCNT2            CONTINUE PROCESS             15JAN88
PATHCNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
PATHCNT2 EQU   *                                                15JAN88
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         TITLE ' - LIST A GDG BASE OR GDG ENTRY RECORD.'
         USING GDGNC,R3
GDGBASE  AP    CNTGDGB,ONE         COUNT A BASE.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   GDGBASE1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
GDGBASE1 MVI   BASESW,255          IDENTIFY GDGBASE.
         MVC   L1TYPE,=CL7'GDGBASE'  IDENTIFY RECORD TYPE
         MVC   L1DSNAME,GDGNAME    SETUP GDGNAME.
         MVC   GDGSAVE,GDGNAME     SAVE GDGNAME.
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    GDGBCNT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    GDGBCNT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTGDGB,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     GDGBCNT2            CONTINUE PROCESS             15JAN88
GDGBCNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
GDGBCNT2 EQU   *                                                15JAN88
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,GDGBASEL,ENDCELL       @130
GDGBASEL DS    0H                                                  @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,GDGBASEN    @130
GDGBASEN DS    0H                                                  @130
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
*
* THE FOLLOWING HAVE BEEN TAKEN OUT FOR LOCAL DEUTZ-ALLIS       16DEC86
*  MODIFICATION TO GIVE GDG AGING INFORMATION ON THE REPORT     16DEC86
*                                                               16DEC86
*        LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1 16DEC86
*        BAL   R9,PRINT            PRINT LINE.                  16DEC86
*                                                               16DEC86
         B     ENDCELL             PROCESS NEXT CELL.
         DROP  R3
         USING GATC,R3
GDGAGE   EQU   *                    GDG AGING CELL ROUTINE      16DEC86
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVC   L1GDGSCR,=CL9'SCRATCH  '  MOVE SCRATCH TO PRINT  16DEC86
         TM    GATATTR,GATSCRTH        IS ATTRIBUTE "SCRATCH"?  16DEC86
         BO    GDGAGE1                YES, PRINT ALREADY MOVED  16DEC86
         MVC   L1GDGSCR,=CL9'NOSCRATCH'  ELSE, MOVE NOSCRATCH   16DEC86
GDGAGE1  MVC   L1GDGEMP,=CL7'EMPTY  '  MOVE EMPTY TO PRINT LINE 16DEC86
         TM    GATATTR,GATDELET        IS ATTRIBUTE "EMPTY"?    16DEC86
         BO    GDGAGE2                YES, PRINT ALREADY MOVED  16DEC86
         MVC   L1GDGEMP,=CL7'NOEMPTY'  ELSE, MOVE NOEMPTY       16DEC86
GDGAGE2  SR    R8,R8                  ZERO THE REGISTER         16DEC86
         ICM   R8,1,GATLIMIT          INSERT # MAX GDGS IN REG  16DEC86
         CVD   R8,WORK                CONVERT IT TO DECIMAL     16DEC86
         EDIT  L1GDGMAX,DWK2,ZZZZ     FORMAT NICE FOR PRINT     16DEC86
         CLC   GATCNT,=BL1'00'     NO GENERATIONS IN GDG?       09DEC87
         BNE   GDGAGE3             NUMBER OF ENTRIES NOT ZERO.  09DEC87
         MVI   L1DSNAME+45,C'+'    OTHERWISE MARK WITH A + SIGN 09DEC87
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN   15JAN88
         BE    GDGAGE2A         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD LENGTH OF PREFIX        15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BNE   GDGAGE3        YES, DON'T ADD TO COUNT           15JAN88
GDGAGE2A AP    CNTNOENT,ONE    COUNT A GDGBASE WITH NO ENTRIES. 09DEC87
GDGAGE3  LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1 16DEC86
         BAL   R9,PRINT            PRINT LINE.                  16DEC86
         B     ENDCELL             PROCESS NEXT CELL            16DEC86
         DROP  R3                                               16DEC86
         USING GDSNC,R3
GDGENT   AP    CNTGDGE,ONE         COUNT IT.
         MVI   VOLSW,0             SWITCH OFF                   13JAN88
         MVI   PFXSW,0             SWITCH OFF                   15JAN88
         CLI   BASESW,255          PRECEEDED BY GDGBASE?
         BNE   GDGENT0             ???????
         MVI   BASESW,0            SWITCH OFF
GDGENT0  MVC   L1TYPE,=CL7'GDG ENT'  IDENTIFY RECORD TYPE
         MVC   GDGWORK,GDGSAVE     START WITH BASE NAME.
         LA    R1,GDGWORK          GET ADDRESS OF BASE NAME
         LA    R8,44               44 BYTES AT MOST
GDGENT1  CLI   0(R1),C' '          SCAN FOR A BLANK
         BE    GDGENT2             YES.
         LA    R1,1(0,R1)          TRY NEXT CHARACTER.
         BCT   R8,GDGENT1          KEEP LOOKING
GDGENT2  SR    R8,R8               CLEAR A REGISTER.
         ICM   R8,3,GDSGENO        PICK UP GENERATION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  2(4,R1),GWK3        UNPACK GENERATION NUMBER.
         OI    5(R1),X'F0'         FIX SIGN
         SR    R8,R8               CLEAR A REGISTER.
         ICM   R8,1,GDSVERNO       PICK UP VERSION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  7(2,R1),GWK2        UNPACK VERSION NUMBER.
         OI    8(R1),X'F0'         FIX SIGN
         MVC   0(2,R1),=C'.G'      SET G0000
         MVI   6(R1),C'V'          G0000V00
         MVC   L1DSNAME,GDGWORK    MOVE IN DEVELOPED NAME
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN?  15JAN88
         BE    GDGECNT2         NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD IN LENGTH OF PREFIX     15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BE    GDGECNT1            MATCH, TURN ON PRINT         15JAN88
         SP    CNTGDGE,ONE         DON'T INCLUDE IN COUNT       15JAN88
         B     GDGECNT2            CONTINUE PROCESS             15JAN88
GDGECNT1 MVI   PFXSW,255           TURN ON PRINT SWITCH         15JAN88
GDGECNT2 EQU   *                                                15JAN88
        $TEST  FLAGS1,LEVEL,LTAB,L1DSNAME,9,GDGENTL,ENDCELL        @130
GDGENTL DS     0H                                                  @130
        $TEST  FLAGS1,NOLEVEL,NLTAB,L1DSNAME,9,ENDCELL,GDGENTN     @130
GDGENTN DS     0H                                                  @130
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         MVI   VOLSW,255           TURN ON VOL CELL JUST READ   13JAN88
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
        $TEST  FLAGS2,VOLUME,VTAB,L1VOLUME,7,GDGENTV,ENDCELL       @130
GDGENTV DS     0H                                                  @130
        $TEST  FLAGS2,NOVOLUME,NVTAB,L1VOLUME,7,ENDCELL,GDGENTX    @130
GDGENTX DS     0H                                                  @130
         MVC   L1UNIT,=C'????'     JUST IN CASE.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
GDGENT5  CLC   VOLDEVTP,0(R5)      IS THIS IT
         BE    GDGENT6             GO TO SET IT UP.
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    GDGENT7             YES, LEAVE IT AT ????
         B     GDGENT5             NO, TRY NEXT DEVICE ENTRY.
GDGENT6  MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
         TM    2(R5),X'20'         IS IT A DASD DEVICE.
         BZ    GDGENT7             IF NOT, NO VTOC TO SEARCH.
         BAL   R9,VTOC             GET DSCB FIELDS
GDGENT7  CLC   L1VOLUME,=C'MIGRAT'  IS IT MIGRATED BY HSM?
         BE    GDGENT8             IF SO, THAT'S IT.
         L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         EDIT  L1LRECL,DWK3,ZZZZZ  FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         EDIT  L1BLKSIZ,                                               X
               DWK3,ZZZZZ          FORMAT WITH ZERO SUPPRESSION.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         EDIT  L1TRACKS,                                               X
               DWK4,ZZZZZZZ        MAKE IT PRINTABLE.
         DROP  R3
GDGENT8  LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         TITLE ' - READ FORMAT1 DSCB AND SETUP DCB AND SPACE INFO.'
* THIS CODE USES OBTAIN TO READ IN THE FORMAT 1 DSCB AND A FORMAT 3
* DSCB IF ONE EXISTS. INFORMATION IS EXTRACTED AND PLACED INTO THE
* FIELDS: LRECL, BLKSIZE AND TRACKS.
VTOC     $IN ,
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         MVC   CAMVOL,L1VOLUME     USE VOLSER FROM BCS VOLCELL.
         CLC   CAMVOL,=C'MIGRAT'   IS IT MIGRATED?
         BE    VTOC99              IF SO, WHY BOTHER.
         MVC   CAMDSN,L1DSNAME     USE DSNAME FROM BCS.
         OBTAIN  SEARCH            READ FORMAT 1 DSCB BY DSNAME.
         ST    R15,OBTAINRC        SAVE OBTAIN RETURN CODE.
         LTR   R15,R15             WAS IT THERE?
         BZ    VTOC1               YES.
         MVC   TRACKS,=XL4'FFFFFFFF' INDICATE DATASET NOT FOUND 30NOV87
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN   15JAN88
         BE    VTOC1A           NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD LENGTH OF PREFIX        15JAN88
         EX    R9,COMPDSN          COMPARE DSNAME TO PREFIX     15JAN88
         BNE   VTOC99         YES, DON'T ADD TO COUNT           15JAN88
VTOC1A   AP    CNTNF,ONE           OTHERWISE COUNT AN ORPHAN.
        $MESSAGE 7,DATA=L1DSNAME                                   @130
         B     VTOC99              AND LEAVE IT BLANK.
VTOC1    SR    R1,R1               CLEAR REGISTER 1.
         ICM   R1,3,FORMAT1+42     PICK UP BLKSIZE
         ST    R1,BLKSIZE          AND SAVE FOR PRINT OUT.
         ICM   R1,3,FORMAT1+44     PICK UP LRECL
         ST    R1,LRECL            AND SAVE FOR PRINT OUT.
         MVC   SV1EXT1(30),FORMAT1+61  SAVE EXTENTS 1 TO 3
         CLC   FORMAT1+91,=5X'00'  IS THERE A FORMAT 3?
         BE    VTOC2A              NO, SKIP IT.
         MVC   CCHHR3,FORMAT1+91   POINTER TO FORMAT 3 DSCB.
         OBTAIN  F3CAMLST          READ FORMAT 3 BY DISK ADDRESS.
         LTR   R15,R15             DID WE GET IT?
         BNZ   VTOC2A              OH WELL
         MVC   SV3EXT4(40),FORMAT3+4  EXTENTS 4,5,6 AND 7.
         MVC   SV3EXT8(90),FORMAT3+45  EXTENTS 8 TO 16.
VTOC2A   SR    R15,R15             ZERO LOOP REGISTER
         SR    R7,R7               ZERO INDEX REGISTER
         SR    R8,R8               ZERO COUNT OF TRACKS ALLOCATED.
         IC    R15,FORMAT1+15      GET NUMBER OF EXTENTS
         LTR   R15,R15             ARE THERE ANY EXTENTS?
         BZ    VTOC5A              SKIP IT IF ZERO EXTENT
VTOC5B   EX    R0,EXTLIST(R7)      GET AN EXTENT ADDR IN R5.
         CLI   0(R5),X'00'         IS THIS AN ACTIVE EXTENT?
         BE    VTOC5C              IF NOT, SKIP IT.
         SR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,2(R5)          STARTING CC
         SR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,4(R5)         STARTING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         ST    R1,STARTTRK         SAVE IT.
         SR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,6(R5)          ENDING CC
         SR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,8(R5)         ENDING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         S     R1,STARTTRK         TRACKS IN THIS EXTENT IN R1
         LA    R1,1(,R1)           KEEP IT HONEST
         AR    R8,R1               COUNT IT
         LA    R7,4(,R7)           SKIP TO NEXT LA INSTRUCTION.
VTOC5C   BCT   R15,VTOC5B          LOOP THROUGH ALL EXTENTS.
VTOC5A   LA    R8,0(0,R8)          PURIFY A REGISTER.
         STCM  R8,15,TRACKS        TRACKS ALLOCATED
VTOC99   $OUT  ,                   RETURN
EXTLIST  LA    R5,SV1EXT1
         LA    R5,SV1EXT2
         LA    R5,SV1EXT3
         LA    R5,SV3EXT4
         LA    R5,SV3EXT5
         LA    R5,SV3EXT6
         LA    R5,SV3EXT7
         LA    R5,SV3EXT8
         LA    R5,SV3EXT9
         LA    R5,SV3EXT10
         LA    R5,SV3EXT11
         LA    R5,SV3EXT12
         LA    R5,SV3EXT13
         LA    R5,SV3EXT14
         LA    R5,SV3EXT15
         LA    R5,SV3EXT16
         TITLE ' - COLLECT DATA FROM VVDS CELLS.'
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         SPACE
VVDS     $IN ,
         SR    R15,R15             RESET RETURN CODE.              @122
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         USING VVR,R6
VVDS0    CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
VVDS0A   SR    R0,R0               NEXT CELL PLEASE
         BAL   R9,FINDVVDS         ADVANCE R6 TO NEXT CELL.
         C     R15,=F'8'           PROBLEMS?                       @122
         BNE   VVDS0               NO. IS IT A VVR?                @122
        $MESSAGE 3,DATA=L1DSNAME                                   @122
         B     VVDS98              RETURN WITH RC=8                @122
VVDS0B   SR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     VVDS0C
         CLC   L1DSNAME(0),VVRCMPNM  (EXECUTED)
VVDS0C   EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   VVDS0A              NO, MUST BE A RELATED COMPONENT.
         CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS1               YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS2               YES, IS IT THE RIGHT ONE?
         B     VVDS99              SHOULD NEVER HAPPEN!
VVDS1    ICM   R0,1,=XL1'23'       VOLUME INFORMATION CELL
         BAL   R9,FINDVVDS         FIND NEXT VVDS CELL.
         USING VVRVOLIN,R6
         MVC   BLKSIZE,VVRBLKSZ    SAVE BLOCK SIZE.
         SR    R1,R1               COUNT OF TRACKS
         SR    R8,R8
         ICM   R8,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LA    R6,40(0,R6)         SKIP AHEAD TO EXTENT DESCR.
         USING VVRXTENT,R6
VVDS1B   AH    R1,VVRXNTRK         COUNT TRACKS THIS EXTENT
         LA    R6,20(0,R6)         SKIP TO NEXT EXTENT DESCR.
         BCT   R8,VVDS1B
         ST    R1,TRACKS           SAVE ALLOCATED TRACKS.
         B     VVDS99
         DROP  R6
VVDS2    ICM   R0,1,=XL1'21'       DATASET INFORMATION CELL.
         BAL   R9,FINDVVDS         FIND NEXT VVDS CELL.
         USING VVRDSINF,R6
         MVC   LRECL,VVRLRECL      SAVE AVERAGE LRECL
         ICM   R1,15,VVRBUFSZ      PICK UP BUFFER SIZE.            @130
         CVD   R1,WORK             CONVERT TO DECIMAL.             @130
         EDIT  L1BFSP,                                             @130X
               DWK3,ZZZZ9          FORMAT IT.                      @130
         ICM   R0,15,VVRDSHU       GET HIGH USED RBA.              @130
         SRDA  R0,32               READY FOR MULTIPLY              @130
         M     R0,=F'100'          TIMES 100.                      @130
         LR    R0,R1                                               @130
         SRDA  R0,32               READY FOR DIVIDE.               @130
         ICM   R2,15,VVRDSHA       GET HIGH ALLOC RBA              @130
         DR    R0,R2               (USED*100)/ALLOC                @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1USED,                                             @130X
               DWK2,ZZ9            FORMATTED.                      @130
         ICM   R0,3,=X'FF60'       NEED AN AMDSB NEXT.             @130
         BAL   R9,FINDVVDS         GO LOOK FOR ONE.                @130
         LTR   R0,R0               WAS THERE AN AMDSB?             @130
         BZ    VVDS1               NO. TRY A VOL INFO CELL.        @130
         USING VVRAMDCL,R6
         ICM   R1,15,VVRAMCIS      PICK UP CI SPLITS.              @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CISP,                                             @130X
               DWK2,ZZ9            FORMAT IT NICELY.               @130
         ICM   R1,15,VVRAMCAS      PICK UP CA SPLITS.              @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CASP,                                             @130X
               DWK2,ZZ9            FORMAT IT NICELY.               @130
         SR    R1,R1               CLEAR REGISTER                  @130
         ICM   R1,1,VVRAMPCA       PICK UP CA FREESPACE %          @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CAFS,                                             @130X
               DWK2,Z9             AND FORMAT.                     @130
         ICM   R1,1,VVRAMPCI       PICK UP CI FREESPACE %          @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CIFS,                                             @130X
               DWK2,Z9             AND FORMAT.                     @130
         ICM   R1,3,VVRAMNXT       GET NUMBER OF EXTENTS.          @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1XTNT,                                             @130X
               DWK2,ZZ9            AND FORMAT.                     @130
         B     VVDS1               LOOK FOR VOLUME INFORMATION CELL
         DROP  R6
VVDS99   $OUT  ,
VVDSR9   DC    F'0'
VVDS98   LA    R15,8               RC=8 FOR CALLER.                @122
         B     VVDS99                                              @122
         TITLE ' - PRINT A HEX LISTING.'
HEXPRINT XPROPEN PWA,PAGELEN=PAGELEN,DDNAME=SYSPRINT
         LTR   R15,R15             DID SYSPRINT OPEN?
         BNZ   EODICAT             IF NOT, NO REPORT.
         XPRHEAD PWA,LIST=(HEADER1,HEADER3)
         L     R15,=V(ALLVVDS)                                     @130
         BALR  R14,R15             ALLOCATE ALL VVDS'S             @130
         LA    R0,1                AUTHORIZATION ON.
         SVC   232                 **** INSTALLATION DEPENDANT ***
         SPACE ,
         L     R2,CVTPTR           A(CVT)
         L     R2,0(0,R2)          TCB WORDS
         L     R2,0(0,R2)          MY TCB.
         USING TCB,R2
         L     R2,TCBJSCB          TCB -> JSCB.
         DROP  R2
         USING IEZJSCB,R2
         L     R2,JSCBACT          ACTIVE JSCB.
         MODESET KEY=ZERO
         SPACE ,
*
* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING
* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER
* A BREAK.
*
         OI    JSCBSWT1,JSCBPASS
         SPACE ,
         MODESET KEY=NZERO
         OPEN  ACBICAT
         SR    R0,R0               AUTHORIZATION OFF.
         SVC   232                 **** INSTALLATION DEPENDANT ***
         BAL   R9,GENRPL           GENERATE RPL ADDR.              @120
GETNEXTH L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         LTR   R15,R15             RECORD READ OK?
         BZ    HEXGETOK            YES                             @AVV
         ICM   R2,15,RPLFDBK-IFGRPL(R1) GET FEEDBACK FIELD.        @AVV
         ABEND 16,DUMP             DIE, SUCKER.                    @AVV
HEXGETOK DS    0H                                                  @AVV
         L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R2,RPLICAT          GET RPL ADDR FROM LAST GET.
         L     R2,48(0,R2)         LENGTH OF RECORD READ
         AR    R2,R3               POINT TO END OF CATALOG RECORD
         LTR   R2,R2                                               @AVV
         BNP   GETNEXTH            SKIP A BOGUS RECORD.            @AVV
         ST    R2,ENDBCS           SAVE FOR FINDBCS ROUTINE
         LA    R3,2(,R3)           SKIP OVER PREFIX
HEXNEXT  CLI   2(R3),C'A'          A = NONVSAM
         BE    HEXNVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    HEXCLUST
         CLI   2(R3),C'D'          D = DATA COMPONENT
         BE    HEXDATA
         CLI   2(R3),C'I'          I = INDEX COMPONENT
         BE    HEXINDEX
ENDHEX   SR    R1,R1
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         LTR   R1,R1                                               @AVV
         BNP   GETNEXTH            SKIP IF BOGUS LENGTH.           @AVV
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    HEXNEXT             YES, KEEP GOING
         B     GETNEXTH            READ ANOTHER RECORD.
         TITLE ' - HEX PRINT A NONVSAM CELL.'
         USING NVNC,R3
HEXNVSAM MVC   L2TYPE,=CL7'NONVSAM'
         AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM             @120
         HEX   L2WORK,NVCELEN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF NVNC
         HEX   L2WORK+5,NVTYPE,                                        X
               1,HEXTAB=TRHEX      TYPE 'A' FOR NONVSAM
         HEX   L2WORK+8,NVRESV,                                        X
               1,HEXTAB=TRHEX      RESERVED
         HEX   L2WORK+11,NVOLCNT,                                      X
               2,HEXTAB=TRHEX      NUMBER OF VOLUME CELLS (255 MAX)
         HEX   L2WORK+16,NVKEYLN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE NONVSAM KEY
         MVC   L2WORK+19(44),NVNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAL   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX PRINT A CLUSTER CELL.'
         USING VCNC,R3
HEXCLUST MVC   L2TYPE,=CL7'CLUSTER'
         AP    CNTCLUST,ONE        COUNT A CLUSTER                 @120
         HEX   L2WORK,CLCELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF VCNC INCLUDING ITSELF
         HEX   L2WORK+5,CLTYPE,                                        X
               1,HEXTAB=TRHEX      TYPE 'C' FOR CLUSTER
         HEX   L2WORK+8,CLCOMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF THE CLUSTER COMPONENT
         HEX   L2WORK+13,CLNOEXT,                                      X
               1,HEXTAB=TRHEX      NUMBER OF EXTENSION RECORDS
         HEX   L2WORK+16,CLNMLEN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE CLUSTER KEY (45)
         MVC   L2WORK+19(44),CLNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAL   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAL   R9,HEXRELAT         RELATIONSHIP CELL (?)
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX PRINT A DATA OR INDEX CELL.'
         USING DINC,R3
HEXDATA  MVC   L2TYPE,=CL7'DATA'
         AP    CNTDATA,ONE         COUNT IT                        @120
         B     HEXDATA1
HEXINDEX MVC   L2TYPE,=CL7'INDEX'
         AP    CNTINDEX,ONE        COUNT IT.                       @120
HEXDATA1 HEX   L2WORK,DIDLEN,                                          X
               2,HEXTAB=TRHEX      LENGTH OF DINC
         HEX   L2WORK+5,DIDTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE 'D' FOR DATA OR INDEX
         HEX   L2WORK+8,DIDCMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF DINC COMPONENT
         HEX   L2WORK+13,DIDIRFLG,                                     X
               1,HEXTAB=TRHEX      INTERRUPT RECOGNITION FLAGS
         HEX   L2WORK+16,DIDKEYLN,                                     X
               1,HEXTAB=TRHEX      CONDENSED KEYLENGTH
         SR    R1,R1
         ICM   R1,1,DIDKEYLN       GET LENGTH OF NAME KEY.
         B     *+10
         MVC   L2WORK+19(0),DIDKEY
         EX    R1,*-6              MOVE IN NAME KEY.
         B     *+10
         MVC   SVCOMPN(0),DIDKEY   SAVE COMPONENT NAME
         EX    R1,*-6              MOVE IN NAME KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAL   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX AN OWNER CELL.'
HEXOWNER $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TYPE.
         BAL   R9,FINDBCS          LOOK FOR IT.
         USING OWNERC,R3
         MVC   L2TYPE,=CL7' OWNER'
         HEX   L2WORK,OWNCELLN,                                        X
               2,HEXTAB=TRHEX      LENGTH OF OWNERSHIP CELL
         HEX   L2WORK+5,OWNTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'01' FOR OWNER
         HEX   L2WORK+8,OWNID,                                         X
               4,HEXTAB=TRHEX      OWNER ID
         HEX   L2WORK+16,OWNID+4,                                      X
               4,HEXTAB=TRHEX      OWNER ID
         HEX   L2WORK+25,OWNFLAG,                                      X
               1,HEXTAB=TRHEX      FLAG
         HEX   L2WORK+28,OWNCREDT,                                     X
               3,HEXTAB=TRHEX      CREATION DATE
         HEX   L2WORK+35,OWNEXPDT,                                     X
               3,HEXTAB=TRHEX      EXPIRY DATE
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         $OUT  ,                   GET OUT.
         TITLE ' - HEX AN ASSOCIATION CELL.'
HEXASSOC $IN ,
         ICM   R0,3,=XL2'FF03'     TYPE X'03', OPTIONAL.
         BAL   R9,FINDBCS          IS THERE ONE?
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXASS99            NO.
         USING ASSOCC,R3
         MVC   L2TYPE,=CL7' ASSOC'
         HEX   L2WORK,ASCLEN,                                          X
               2,HEXTAB=TRHEX      ASSOCIATION CELL LENGTH
         HEX   L2WORK+5,ASCTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'03' FOR ASSOC
         HEX   L2WORK+8,ASCOUNT,                                       X
               2,HEXTAB=TRHEX      COUNT OF ASSOCIATIONS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXASS99 $OUT  ,                   GET OUT
         TITLE ' - HEX A SECURITY CELL.'
HEXSECUR $IN ,
         ICM   R0,3,=XL2'FF02'     TYPE X'02', OPTIONAL.
         BAL   R9,FINDBCS          IS THERE ONE?
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXSEC99            NO.
         USING SECURITY,R3
         MVC   L2TYPE,=CL7' SECUR'
         HEX   L2WORK,SECELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF SECURITY CELL
         HEX   L2WORK+5,SECTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'02' FOR SECURITY.
         HEX   L2WORK+8,SECMSTR,                                       X
               4,HEXTAB=TRHEX      MASTER PASSWORD.
         HEX   L2WORK+16,                                              X
               SECMSTR+4,                                              X
               4,HEXTAB=TRHEX      MASTER PASSWORD.
         HEX   L2WORK+27,SECCI,                                        X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+35,SECCI+4,                                      X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+44,                                              X
               SECUPDTE,                                               X
               4,HEXTAB=TRHEX      UPDATE PASSWORD.
         HEX   L2WORK+52,                                              X
               SECUPDTE+4,                                             X
               4,HEXTAB=TRHEX      UPDATE PASSWORD.
         HEX   L2WORK+61,SECREAD,                                      X
               4,HEXTAB=TRHEX      READ PASSWORD.
         HEX   L2WORK+69,                                              X
               SECREAD+4,                                              X
               4,HEXTAB=TRHEX      READ PASSWORD.
         HEX   L2WORK+78,SECPMTCD,                                     X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+86,                                              X
               SECPMTCD+4,                                             X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+95,SECATMP,                                      X
               2,HEXTAB=TRHEX      MAXIMUM NUMBER OF ATTEMPTS.
         HEX   L2WORK+100,                                             X
               SECVRMOD,                                               X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+108,                                             X
               SECVRMOD+4,                                             X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+117,                                             X
               SECRCDLN,                                               X
               2,HEXTAB=TRHEX      USER AUTHORIZATION RECORD LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXSEC99 $OUT  ,                   GET OUT
         TITLE ' - HEX A RELATION CELL.'
HEXRELAT $IN ,
         ICM   R0,3,=XL2'FF06'     OPTIONAL RELAT CELL
         BAL   R9,FINDBCS          LOOK FOR IT.
         LTR   R0,R0               WAS IT THERE?
         BZ    HEXREL99            NO.
         USING RELCELL,R3
         MVC   L2TYPE,=CL7' RELAT'
         HEX   L2WORK,RELLEN,                                          X
               2,HEXTAB=TRHEX      CELL LENGTH.
         HEX   L2WORK+5,RELTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'06'
         HEX   L2WORK+8,RELRESV,                                       X
               1,HEXTAB=TRHEX      RESERVED.
         HEX   L2WORK+11,RELCNT,                                       X
               1,HEXTAB=TRHEX      COUNT OF RELKEYS.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXREL99 $OUT  ,                   GET OUT
         TITLE ' - HEX A VOLUME CELL.'
* THIS LOGIC IS ENTERED AT A POINT WHERE THERE MUST BE AT LEAST ONE
* VOLUME CELL POINTED TO BY R3. HOWEVER THERE COULD BE MORE THAN ONE.
* HENCE, AFTER THE FIRST NON-VOLUME CELL IS RECOGNIZED R3 MUST BE
* BACKED UP TO THE LAST VOLUME CELL SO THAT THE GENERAL CODE AT
* "ENDHEX" CAN SKIP OVER IT.
HEXVOL   $IN ,
HEXVOL0  ICM   R0,3,=XL2'FF04'     VOLUME CELL
         BAL   R9,FINDBCS
         LTR   R0,R0               WAS THAT THE LAST ONE?
         BZ    HEXVOL99            YES.
         USING VOLCELL,R3
         MVC   L2TYPE,=CL7' VOLUME'
         HEX   L2WORK,VOLLEN,                                          X
               2,HEXTAB=TRHEX      LENGTH OF VOLCELL
         HEX   L2WORK+5,VOLTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'04' FOR VOLUME CELL
         HEX   L2WORK+8,VOLOFSET,                                      X
               1,HEXTAB=TRHEX      UNUSED
         MVC   L2WORK+11(6),VOLSERN
         HEX   L2WORK+18,VOLDEVTP,                                     X
               4,HEXTAB=TRHEX      DEVICE TYPE
         HEX   L2WORK+27,VOLFLAG1,                                     X
               1,HEXTAB=TRHEX      FLAG
         HEX   L2WORK+30,VOLFLAG2,                                     X
               1,HEXTAB=TRHEX      RESERVED
         HEX   L2WORK+33,VOLVVRBA,                                     X
               4,HEXTAB=TRHEX      RELATIVE BYTE ADDRESS OF VVR
         HEX   L2WORK+42,VOLFLSEQ,                                     X
               2,HEXTAB=TRHEX      NONVSAM FILE SEQUENCE NUMBER (TAPE)
         HEX   L2WORK+47,VOLKRQL,                                      X
               4,HEXTAB=TRHEX      KEYRANGE QUALIFIER (VSAM ONLY)
         HEX   L2WORK+56,VOLLKYLN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF LOW KEY RANGE KEY
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         TM    VOLFLAG1,VOLNVSAM   IS IT NONVSAM?
         BO    HEXVOL99            IF SO, THAT'S ALL
         TM    VOLFLAG1,VOLCANDI   IS IT A CANDIDATE VOLUME?
         BO    HEXVOL99            IF SO, THAT'S ALL
         MVC   RBASAVE,VOLVVRBA    SAVE RBA OF VVR
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
HEXVOL8  CLI   VVDSVOL,255         LAST ENTRY?
         BE    HEXVOL99            YES, OH WELL.
         CLC   VVDSVOL,VOLSERN     IS THIS THE VVDS?
         BNE   HEXVOL6             NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT TO ARG FIELD FOR THIS RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(8)             POSITION TO DESIRED RECORD
         GET   RPL=(8)             READ IN RECORD
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD ADDR
         LA    R6,2(,R6)           SKIP OVER PREFIX
         BAL   R9,HEXVVR           PRIMARY OR 2NDARY VVR
         BAL   R9,HEXDSINF         DATASET INFORMATION CELL (MAYBE)
         BAL   R9,HEXAMDSB         AMDSB CELL (IF PRESENT)
         BAL   R9,HEXVOLIN         VOLUME INFORMATION CELL.
         B     HEXVOL0             COULD BE MORE THAN ONE.
HEXVOL6  LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     HEXVOL8             WHAT IS IT JOHNNY?
HEXVOL99 $OUT  ,                   GET OUT.
         DROP  R3
         TITLE ' - HEX PRINT A VVR.'
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         USING VVR,R6
HEXVVR   $IN ,
         MVC   L2TYPE,=CL7' VVR'
HEXVVR0  CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
HEXVVR0A SR    R0,R0               NEXT CELL PLEASE.
         BAL   R9,FINDVVDS
         B     HEXVVR0             IS IT A VVR?
HEXVVR0B SR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     HEXVVR0C
         CLC   SVCOMPN(0),VVRCMPNM  (EXECUTED)
HEXVVR0C EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   HEXVVR0A            NO, MUST BE A RELATED COMPONENT.
         HEX   L2WORK,VVRHDLEN,                                        X
               2,HEXTAB=TRHEX
         HEX   L2WORK+5,VVRTYPE,                                       X
               1,HEXTAB=TRHEX
         HEX   L2WORK+8,VVRFLAG,                                       X
               1,HEXTAB=TRHEX
         HEX   L2WORK+11,VVRKRQ,                                       X
               4,HEXTAB=TRHEX
         HEX   L2WORK+20,VVRCMPNL,                                     X
               1,HEXTAB=TRHEX
         SR    R1,R1
         ICM   R1,1,VVRCMPNL       GET LENGTH OF COMPONENT KEY.
         B     *+10
         MVC   L2WORK+23(0),VVRCMPNM
         EX    R1,*-6              MOVE IN COMPONENT KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         $OUT  ,                   GET OUT.
         DROP  R6
         TITLE ' - HEX A DATASET INFORMATION CELL.'
HEXDSINF $IN ,
         ICM   R0,3,=XL2'FF21'     DATASET INFORMATION CELL.
         BAL   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXDSF99            NO.
         USING VVRDSINF,R6
         MVC   L2TYPE,=CL7' DSINFO'
         HEX   L2WORK,VVRDSLEN,                                        X
               2,HEXTAB=TRHEX      CELL LENGTH.
         HEX   L2WORK+5,VVRDSTYP,                                      X
               1,HEXTAB=TRHEX      TYPE CODE IS X'21'
         HEX   L2WORK+8,VVRATTR1,                                      X
               1,HEXTAB=TRHEX      DATASET ATTRIBUTES
         HEX   L2WORK+11,VVRATTR2,                                     X
               1,HEXTAB=TRHEX      DATASET ATTRIBUTES
         HEX   L2WORK+14,VVROPIND,                                     X
               1,HEXTAB=TRHEX      OPEN INDICATOR
         HEX   L2WORK+17,VVRBUFSZ,                                     X
               4,HEXTAB=TRHEX      MINIMUM BUFFER SIZE
         HEX   L2WORK+26,VVRPRISP,                                     X
               3,HEXTAB=TRHEX      PRIMARY SPACE ALLOCATION
         HEX   L2WORK+33,VVRSECSP,                                     X
               3,HEXTAB=TRHEX      SECONDARY SPACE ALLOCATION
         HEX   L2WORK+40,VVRSPCFG,                                     X
               1,HEXTAB=TRHEX      SPACE FLAGS
         HEX   L2WORK+43,VVRDSHU,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH USED RBA
         HEX   L2WORK+52,VVRDSHA,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH ALLOCATED RBA
         HEX   L2WORK+61,VVRLRECL,                                     X
               4,HEXTAB=TRHEX      AVERAGE LOGICAL RECORD LENGTH
         HEX   L2WORK+70,VVREXCPX,                                     X
               4,HEXTAB=TRHEX      EXCEPTION EXIT.
         HEX   L2WORK+78,VVREXCPX+4,                                   X
               4,HEXTAB=TRHEX      EXCEPTION EXIT.
         HEX   L2WORK+87,VVRDSHK,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH KEY RBA.
         HEX   L2WORK+96,VVRCLSFG,                                     X
               1,HEXTAB=TRHEX      CLUSTER ATTRIBUTE FLAG
         HEX   L2WORK+99,VVRAIXFG,                                     X
               1,HEXTAB=TRHEX      AIX ATTRIBUTE FLAG
         HEX   L2WORK+102,VVRTMSTP,                                    X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         HEX   L2WORK+110,VVRTMSTP+4,                                  X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXDSF99 $OUT  ,                   GET OUT
         TITLE ' - HEX AN AMDSB CELL.'
HEXAMDSB $IN ,
         ICM   R0,3,=XL2'FF60'     AMDSB CELL
         BAL   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXAMD99            NO.
         USING VVRAMDCL,R6
         MVC   L2TYPE,=CL7' AMDSB'
         HEX   L2WORK+00,VVRAMDCN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF AMDSB CELL
         HEX   L2WORK+05,VVRAMID,                                      X
               1,HEXTAB=TRHEX      TYPE CODE IS X'60'
         HEX   L2WORK+08,VVRAMATR,                                     X
               1,HEXTAB=TRHEX      ATTRIBUTES:
         HEX   L2WORK+11,VVRAMLEN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF AMDSB
         HEX   L2WORK+16,VVRAMNST,                                     X
               2,HEXTAB=TRHEX      NUMBER OF ENTRIES IN INDEX SECTION
         HEX   L2WORK+21,VVRAMRKP,                                     X
               2,HEXTAB=TRHEX      RKP
         HEX   L2WORK+26,VVRAMKNL,                                     X
               2,HEXTAB=TRHEX      KEY LENGTH
         HEX   L2WORK+31,VVRAMPCA,                                     X
               1,HEXTAB=TRHEX      % FREE CI IN CA
         HEX   L2WORK+34,VVRAMPCI,                                     X
               1,HEXTAB=TRHEX      % FREE BYTES IN CI
         HEX   L2WORK+37,VVRAMCCA,                                     X
               2,HEXTAB=TRHEX      CI'S PER CA
         HEX   L2WORK+42,VVRAMFCA,                                     X
               2,HEXTAB=TRHEX      FREE CI'S PER CA
         HEX   L2WORK+47,VVRAMFCI,                                     X
               4,HEXTAB=TRHEX      FREE BYTES PER CI
         HEX   L2WORK+56,VVRAMCIV,                                     X
               4,HEXTAB=TRHEX      CONTROL INTERVAL SIZE
         HEX   L2WORK+65,VVRAMLCL,                                     X
               4,HEXTAB=TRHEX      MAXIMUM RECORD SIZE
         HEX   L2WORK+74,VVRAMSLT,                                     X
               4,HEXTAB=TRHEX      SLOTS PER CI
         HEX   L2WORK+83,VVRAMMRR,                                     X
               4,HEXTAB=TRHEX      MAXIMUM RELATIVE RECORD NUMBER
         HEX   L2WORK+92,VVRAMARB,                                     X
               4,HEXTAB=TRHEX      POINTER TO 1ST ARDB
         HEX   L2WORK+101,VVRAMAT3,                                    X
               1,HEXTAB=TRHEX      ATTRIBUTES
         HEX   L2WORK+104,VVRAMSNO,                                    X
               1,HEXTAB=TRHEX      NUMBER OF CONCURRENT REQUESTS
         HEX   L2WORK+107,VVRAMBFD,                                    X
               2,HEXTAB=TRHEX      NUMBER OF DATA BUFFERS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         HEX   L2WORK+00,VVRAMSTS,                                     X
               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP
         HEX   L2WORK+08,VVRAMSTS+4,                                   X
               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP
         HEX   L2WORK+17,VVRAMNIL,                                     X
               2,HEXTAB=TRHEX      NUMBER OF INDEX LEVELS
         HEX   L2WORK+22,VVRAMNXT,                                     X
               2,HEXTAB=TRHEX      NUMBER OF EXTENTS
         HEX   L2WORK+27,VVRAMNLR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF LOGICAL RECORDS
         HEX   L2WORK+38,VVRAMDLR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF DELETED RECORDS
         HEX   L2WORK+47,VVRAMINR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF INSERTED RECORDS
         HEX   L2WORK+56,VVRAMUPR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF UPDATED RECORDS
         HEX   L2WORK+65,VVRAMRTR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF RETRIEVED RECORDS
         HEX   L2WORK+74,VVRAMASP,                                     X
               4,HEXTAB=TRHEX      BYTES OF FREE SPACE IN DATASET
         HEX   L2WORK+83,VVRAMCIS,                                     X
               4,HEXTAB=TRHEX      NUMBER OF CI SPLITS
         HEX   L2WORK+92,VVRAMCAS,                                     X
               4,HEXTAB=TRHEX      NUMBER OF CA SPLITS
         HEX   L2WORK+101,VVRAMEXC,                                    X
               4,HEXTAB=TRHEX      NUMBER OF EXCPS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXAMD99 $OUT  ,                   GET OUT
         TITLE ' - HEX A VOLUME INFORMATION CELL.'
HEXVOLIN $IN ,
         ICM   R0,3,=XL2'FF23'     VOLUME INFORMATION CELL
         BAL   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXVLN99            NO.
         USING VVRVOLIN,R6
         MVC   L2TYPE,=CL7' VOLINF'
         HEX   L2WORK+00,VVRVOLLN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF VOLUME CELL
         HEX   L2WORK+05,VVRVOLTP,                                     X
               1,HEXTAB=TRHEX      TYPE CODE IS X'23'
         HEX   L2WORK+08,VVRVOLFG,                                     X
               1,HEXTAB=TRHEX      VOLUME FLAGS
         HEX   L2WORK+11,VVRNOEXT,                                     X
               1,HEXTAB=TRHEX      NUMBER OF EXTENTS ON THIS VOLUME.
         HEX   L2WORK+14,VVRHKRBA,                                     X
               4,HEXTAB=TRHEX      HIGH KEY RBA
         HEX   L2WORK+23,VVRHURBA,                                     X
               4,HEXTAB=TRHEX      HIGH USED RBA
         HEX   L2WORK+32,VVRHARBA,                                     X
               4,HEXTAB=TRHEX      HIGH ALLOCATED RBA
         HEX   L2WORK+41,VVRBLKSZ,                                     X
               4,HEXTAB=TRHEX      BLOCK SIZE
         HEX   L2WORK+50,VVRBLKTK,                                     X
               2,HEXTAB=TRHEX      NUMBER OF BLOCKS PER TRACK
         HEX   L2WORK+55,VVRTRKAU,                                     X
               2,HEXTAB=TRHEX      NUMBER OF TRACKS PER ALLOCATION UNIT
         HEX   L2WORK+60,VVRTPEXT,                                     X
               1,HEXTAB=TRHEX      EXTENT TYPE FLAG
         HEX   L2WORK+63,VVRTKCYL,                                     X
               2,HEXTAB=TRHEX      TRACKS PER CYLINDER
         HEX   L2WORK+68,VVRBYTTK,                                     X
               4,HEXTAB=TRHEX      BYTES PER TRACK.
         HEX   L2WORK+77,VVRBYTAU,                                     X
               4,HEXTAB=TRHEX      BYTES PER ALLOCATION UNIT
         HEX   L2WORK+86,VVRLOKYL,                                     X
               2,HEXTAB=TRHEX      LOW KEY LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         ST    R5,HEXR5            SAVE VVDSTAB BASE REG
         SR    R5,R5
         ICM   R5,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LR    R8,R6
         LA    R8,40(0,R8)         POINT TO EXTENT DESCR.
         USING VVRXTENT,R8
HEXVLN97 HEX   L2WORK+00,VVRXSEQN,                                     X
               2,HEXTAB=TRHEX      SEQUENCE NUMBER
         HEX   L2WORK+05,VVRXSCH,                                      X
               4,HEXTAB=TRHEX      STARTING CCHH
         HEX   L2WORK+14,VVRXECH,                                      X
               4,HEXTAB=TRHEX      ENDING CCHH
         HEX   L2WORK+23,VVRXNTRK,                                     X
               2,HEXTAB=TRHEX      NUMBER OF TRACKS
         HEX   L2WORK+28,VVRXSRBA,                                     X
               4,HEXTAB=TRHEX      STARTING RBA
         HEX   L2WORK+37,VVRXERBA,                                     X
               4,HEXTAB=TRHEX      ENDING RBA
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         LA    R8,20(0,R8)         POINT TO NEXT EXTENT DESCR.
         BCT   R5,HEXVLN97         FORMAT ALL EXTENTS
         L     R5,HEXR5            RESTORE VVDSTAB BASE REG
HEXVLN99 $OUT  ,                   GET OUT
HEXR5    DC    F'0'                I'M RUNNING OUT OF REGISTERS
         DROP  R8
         TITLE ' - FINDBCS. ADVANCE R3 TO A SPECIFIED BCS CELL.'
* I ENTER HERE WITH R3 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
FINDBCS  $IN ,
         ST    R3,BCS2             SAVE CELL ADDRESS.
FINDBCS1 SR    R1,R1               CLEAR REGISTER
         ICM   R1,3,0(R3)          PICK UP LENGTH OF CURRENT CELL.
         AR    R3,R1               AND SKIP OVER IT.
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    FINDBCS2            YES.
         ST    R0,BCS0             SAVE CALLERS PARMS
         L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         AP    BCSGETS,ONE         COUNT OFF A GET.
         L     R0,BCS0             RESTORE CALLERS PARMS
         LTR   R15,R15             RECORD READ OK?
         L     R3,BUFPTR           ADDRESS OF RECORD JUST READ.
         L     R1,RPLICAT          GET RPL ADDR.
         L     R1,48(0,R1)         RECORD LENGTH.
         AR    R1,R3               END OF RECORD.
         ST    R1,ENDBCS           SAVE FOR NEXT TIME.
         LA    R3,2(0,R3)          SKIP OVER PREFIX.
FINDBCS2 CLM   R0,1,2(R3)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDBCS9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDBCS1            NO, SO KEEP LOOKING.
         L     R3,BCS2             BACKUP TO WHERE WE STARTED.
         SR    R0,R0               LET HIM KNOW ABOUT IT.
FINDBCS9 $OUT  ,
ENDBCS   DC    F'0'                BCS RECORD END ADDRESS
BCS9     DC    F'0'                SAVE R9 IN HERE.
BCS2     DC    F'0'                SAVE R3 IN HERE.
BCS0     DC    F'0'                SAVE R0 IN HERE.
         TITLE ' - FINDVVDS. ADVANCE R6 TO A SPECIFIED VVDS CELL.'
* I ENTER HERE WITH R6 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
FINDVVDS $IN ,
         ST    R6,VVD6             SAVE CELL ADDRESS
FINDVVD1 SR    R1,R1               CLEAR REGISTER
         SR    R15,R15             CLEAR PREVIOUS RETCODE.         @122
         ICM   R1,3,0(R6)          PICK UP LENGTH OF CURRENT CELL.
         LTR   R1,R1               IS THERE A LENGTH?              @132
         BNP   FINDVVDX            NO. HOW ODD!                    @132
         AR    R6,R1               SKIP OVER LENGTH
         C     R6,ENDVVD           ANY MORE CELLS IN THIS RECORD?
         BL    FINDVVD2            YES.
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDRESS
         ST    R0,VVD0             SAVE CALLERS PARM
         GET   RPL=(8)
         LTR   R15,R15             GET OK?                         @122
         BZ    FINDVVD3            YUP.                            @122
         C     R15,=F'8'           LOGICAL ERROR?                  @122
         BE    FINDVVD4            YES.                            @122
         ABEND 16,DUMP             OTHERWISE CRASH AND BURN.       @122
FINDVVD4 DS    0H                                                  @122
         SR    R2,R2                                               @122
         ICM   R2,1,RPLERRCD-IFGRPL(R1) GET REASON CODE.           @122
         CVD   R2,DTWORK           PACK IT.                        @122
         EDIT  FDBK,DWK3,ZZZ9      FORMAT NICELY.                  @122
        $MESSAGE 2,DATA=FDBK       SAY LOGICAL ERROR.              @122
         B     FINDVVDX            GO BACK WITH RC IN R15          @122
FINDVVD3 DS    0H                                                  @122
         AP    VVDSGETS,ONE        COUNT IT.
         L     R0,VVD0             RESTORE CALLERS PARM
         L     R6,VVDSBUF          ADDRESS OF RECORD JUST READ.
         L     R1,VVDSRPL          ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD JUST READ.
         AR    R1,R6               END OF RECORD.
         ST    R1,ENDVVD           SAVE FOR NEXT TIME.
         CLC   0(2,R6),=H'0'       ANYTHING IN THIS RECORD?        @132
         BNE   FINDVVD5            YES. LET'S DO IT.               @132
         SR    R0,R0               OOPS!                           @132
         B     FINDVVD9            GOBACK.                         @132
FINDVVD5 LA    R6,2(0,R6)          SKIP OVER PREFIX.
FINDVVD2 LTR   R0,R0               IF ZERO, ANYTHING WILL DO.
         BZ    FINDVVD9
         CLM   R0,1,2(R6)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDVVD9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDVVD1            NO, THEN KEEP LOOKING.
         L     R6,VVD6             RESTORE INITIAL CELL ADDRESS
         SR    R0,R0               GIVE HIM THE SAD NEWS.
FINDVVD9 $OUT  ,
ENDVVD   DC    F'0'                BCS RECORD END ADDRESS
VVD9     DC    F'0'                SAVE R9 IN HERE.
VVD6     DC    F'0'                SAVE R6 IN HERE.
VVD0     DC    F'0'                SAVE R0 IN HERE.
FINDVVDX LA    R15,8                                               @122
         B     FINDVVD9                                            @122
         DROP  R5
         TITLE ' - PRINT LINE SUBROUTINE.'
PRINT    $IN ,
         ST    R1,PRINT1
         CLC   DSPFX(3),=C'   '        IS THERE DS PREFIX GIVEN 15JAN88
         BE    PRINT2              NO, CONTINUE A NORMAL        15JAN88
         CLI   PFXSW,255               IS THE PRINTIT SWITCH ON 15JAN88
         BNE   PRINT2A            YES, DON'T PRINT THE LINE.    15JAN88
PRINT2   EQU   *                                                15JAN88
         XPRNTLIN  PWA,TEXT=(R1),LENGTH=132,SPB=((R0)),SPA=1
PRINT2A  L     R1,PRINT1
         MVI   0(R1),C' '
         MVC   1(132,R1),0(R1)
         $OUT  ,
PRINT1   DC    F'0'
         TITLE ' - DEFINE REPORT HEADING.'
SETHEAD  $IN ,
         XPRHEAD PWA,LIST=(HEADER1,HEADER2,HEADER2A)
         $OUT
         TITLE ' - FORMAT THE CREATION DATE FROM AN OWNER CELL.'
SETCREDT $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         USING OWNERC,R3
         SR    R0,R0               CLEAR R0.
         ICM   R0,7,OWNCREDT       PICK UP CREATION DATE.
         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD
         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION
         LA    R1,DTWORK           SETUP ADDRESS
         ST    R1,DTPARM           OF PACKED FIELD
         LA    R1,DTPARM           IN PARMLIST
         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE
         BALR  R14,R15             CONVERT DATE
         MVC   L1CREDT,DTWORK      SETUP CONVERTED DATE
         $OUT
         TITLE ' - SETUP FIELDS FROM THE HSM MCD RECORD.'
CHKHSM   DS    0H
         CLI   MCDSOPEN,254        PREVIOUS OPEN FAILED?           @122
         BER   R9                  YES. GIVE UP HOPE.              @122
         CLI   MCDSOPEN,0          IS MCDS ALREADY OPEN?
         BNE   CHKHSM1A
         OPEN  (ACBMCDS)
         LTR   R15,R15             DID IT OPEN.                    @122
         BZ    CHKHSM1B            YES                             @122
        $MESSAGE 6                 NO. SAY SO.                     @122
         MVI   MCDSOPEN,254        FLAG NO SYSUT2.                 @122
         BR    R9                  AND GO HOME.                    @122
CHKHSM1B DS    0H                                                  @122
         MVI   MCDSOPEN,255        FLAG IT OPEN
CHKHSM1A MVC   MCDSKEY,L1DSNAME    DSN AS MCDS KEY.
         GET   RPL=RPLMCDS
         LTR   R15,R15             RECORD READ OK?
         BNZR  R9                  RETURN
         L     R1,MCDSPTR          GET ADDRESS OF HSM MCD RECORD.
         USING MCD,R1
         CLC   MCDSIZE,=F'32760'   DATA AND INDEX ENTRIES NO GOOD.
         BH    CHKHSM2             SO LEAVE THEM AT ZERO
         MVC   TRACKS,MCDSIZE      ORIGINAL SIZE IN TRACKS.
CHKHSM2  MVC   BLKSIZE+2(2),MCDBLKSZ  ORIGINAL BLOCK SIZE.
         DROP  R1
         BR    R9                  EXIT
         TITLE ' - PRINT OUT STATISTICS AT EOD.'
COUNTS   $IN ,
         XPREJECT  PWA
         XPRHEAD PWA,LIST=(HEADER1)
         EDIT  T1COUNT,CNTNVSAM,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NVSAM),T1NVSAM
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=2,SPA=1
         EDIT  T1COUNT,CNTCLUST,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1CLUST),T1CLUST
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTINDEX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1INDEX),T1INDEX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTDATA,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1DATA),T1DATA
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTAIX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1AIX),T1AIX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTPATH,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1PATH),T1PATH
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTGDGB,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGB),T1GDGB
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTGDGE,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGE),T1GDGE
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,BCSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1BCS),T1BCS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,VVDSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1VVDS),T1VVDS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTNF,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NF),T1NF
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         EDIT  T1COUNT,CNTNOENT,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NOENT),T1NOENT
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX ENTERED 15JAN88
         BE    COUNTS1          NO,DON'T PRINT PARM LINE        15JAN88
         L     R9,DSPFXL           LOAD PARM LENGTH             15JAN88
         EX    R9,MVPARM           MOVE PARM TO PRINT LINE      15JAN88
         LA    R8,T1INPARM         POINT START OF OUTPUT AREA   15JAN88
         A     R9,=XL4'0000001'    BUMPUP TO GET CORRECT OFFSET 15JAN88
         AR    R8,R9               POINT TO MOVE AREA           15JAN88
         MVI   0(R8),C'"'          MOVE IN A DOUBLE QUOTE SIGN  15JAN88
         XPRNTLIN  PWA,TEXT=TOTAL1+1,LENGTH=132,SPB=2,SPA=1     15JAN88
COUNTS1  EQU   *                                                15JAN88
         $OUT
MVPARM   MVC   T1INPARM(0),DSPFX                                15JAN88
         SPACE
TOTAL    DS    0CL133
         DC    CL1' '
T1COUNT  DC    CL7' '
         DC    CL1' '
T1TEXT   DC    CL124' '                                            @120
T1NVSAM  DC    C'NONVSAM ENTRIES FOUND.'
T1CLUST  DC    C'CLUSTER ENTRIES FOUND.'
T1INDEX  DC    C'INDEX ENTRIES FOUND.'
T1DATA   DC    C'DATA ENTRIES FOUND.'
T1AIX    DC    C'ALTERNATE INDEX ENTRIES FOUND.'
T1PATH   DC    C'PATH ENTRIES FOUND.'
T1GDGB   DC    C'GENERATION DATA GROUP BASES FOUND.'
T1GDGE   DC    C'GENERATION DATA GROUP ENTRIES FOUND.'
T1BCS    DC    C'GETS ISSUED AGAINST THE BASIC CATALOG STRUCTURE.'
T1VVDS   DC    C'GETS ISSUED AGAINST VVDS(S).'
T1NF     DC    C'NONVSAM DATASETS CATALOGUED BUT NOT FOUND. (MARKED WIT-
               H A "*" BEFORE DATASET TYPE)'
T1NOENT  DC    C'GENERATION DATA GROUP BASES FOUND WITH NO ENTRIES. (MA-
               RKED WITH A "+" BEFORE DATASET TYPE)'
TOTAL1   DS    0CL133
         DC    CL1' '
         DC    CL13'SEARCH FOR: "'
T1INPARM DC    CL119' '
PFXSW    DC    XL1'00'                                          15JAN88
COMPDSN  CLC   DSPFX(0),L1DSNAME   EXECUTED COMMAND             15JAN88
         TITLE ' - GENERATE AN RPL TO ACCESS THE BCS CLUSTER.'
GENRPL   $IN ,                                                     @120
         L     R0,BUFLEN           LENGTH TO GETMAIN
         GETMAIN R,LV=(0)          INPUT BUFFER FOR BCS RECORDS.
         ST    R1,BUFPTR           SAVE ADDRESS OF RECORD BUFFER.
         GENCB BLK=RPL,                                                X
               ACB=(S,ACBICAT),                                        X
               AM=VSAM,                                                X
               AREA=(*,BUFPTR),                                        X
               AREALEN=131072,                                         X
               OPTCD=(KEY,SEQ,MVE)
         ST    R1,RPLICAT          SAVE GENERATED RPL ADDR.
         $OUT                                                      @120
         LTORG ,
         SPACE 2
         COPY  ALLVVDS                                             @130
         COPY  PARMS                                               @130
         COPY  DSECTS                                              @120
         COPY  DATASECT                                            @120
         COPY  PRINT                                               @120
         COPY  MESSAGES                                            @122
         END   LISTICAT
./       ADD   NAME=VTOC
         TITLE ' - READ FORMAT1 DSCB AND SETUP DCB AND SPACE INFO.'
* THIS CODE USES OBTAIN TO READ IN THE FORMAT 1 DSCB AND A FORMAT 3
* DSCB IF ONE EXISTS. INFORMATION IS EXTRACTED AND PLACED INTO THE
* FIELDS: LRECL, BLKSIZE AND TRACKS.
VTOC     $PROLOG R12
         L     R4,=V(DATASECT)                                     @130
         USING DATASECT,R4                                         @130
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         MVC   CAMVOL,L1VOLUME     USE VOLSER FROM BCS VOLCELL.
         CLC   CAMVOL,=C'MIGRAT'   IS IT MIGRATED?
         BE    VTOC99              IF SO, WHY BOTHER.
         MVC   CAMDSN,L1DSNAME     USE DSNAME FROM BCS.
         OBTAIN  SEARCH            READ FORMAT 1 DSCB BY DSNAME.
         ST    R15,OBTAINRC        SAVE OBTAIN RETURN CODE.
         LTR   R15,R15             WAS IT THERE?
         BZ    VTOC1               YES.
         MVC   TRACKS,=XL4'FFFFFFFF' INDICATE DATASET NOT FOUND 30NOV87
         CLC   DSPFX(3),=C'   '    WAS A DATASET PREFIX GIVEN   15JAN88
         BE    VTOC1A           NO,CONTINUE AS NORMAL           15JAN88
         L     R9,DSPFXL           LOAD LENGTH OF PREFIX        15JAN88
         EX    R9,COMPDSNV         COMPARE DSNAME TO PREFIX        @134
         BNE   VTOC99         YES, DON'T ADD TO COUNT           15JAN88
VTOC1A   AP    CNTNF,ONE           OTHERWISE COUNT AN ORPHAN.
        $MESSAGE 7,DATA=L1DSNAME                                   @130
         B     VTOC99              AND LEAVE IT BLANK.
VTOC1    SR    R1,R1               CLEAR REGISTER 1.
         ICM   R1,3,FORMAT1+42     PICK UP BLKSIZE
         ST    R1,BLKSIZE          AND SAVE FOR PRINT OUT.
         ICM   R1,3,FORMAT1+44     PICK UP LRECL
         ST    R1,LRECL            AND SAVE FOR PRINT OUT.
         MVC   SV1EXT1(30),FORMAT1+61  SAVE EXTENTS 1 TO 3
         CLC   FORMAT1+91,=5X'00'  IS THERE A FORMAT 3?
         BE    VTOC2A              NO, SKIP IT.
         MVC   CCHHR3,FORMAT1+91   POINTER TO FORMAT 3 DSCB.
         OBTAIN  F3CAMLST          READ FORMAT 3 BY DISK ADDRESS.
         LTR   R15,R15             DID WE GET IT?
         BNZ   VTOC2A              OH WELL
         MVC   SV3EXT4(40),FORMAT3+4  EXTENTS 4,5,6 AND 7.
         MVC   SV3EXT8(90),FORMAT3+45  EXTENTS 8 TO 16.
VTOC2A   SR    R15,R15             ZERO LOOP REGISTER
         SR    R7,R7               ZERO INDEX REGISTER
         SR    R8,R8               ZERO COUNT OF TRACKS ALLOCATED.
         IC    R15,FORMAT1+15      GET NUMBER OF EXTENTS
         LTR   R15,R15             ARE THERE ANY EXTENTS?
         BZ    VTOC5A              SKIP IT IF ZERO EXTENT
VTOC5B   EX    R0,EXTLIST(R7)      GET AN EXTENT ADDR IN R5.
         CLI   0(R5),X'00'         IS THIS AN ACTIVE EXTENT?
         BE    VTOC5C              IF NOT, SKIP IT.
         SR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,2(R5)          STARTING CC
         SR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,4(R5)         STARTING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         ST    R1,STARTTRK         SAVE IT.
         SR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,6(R5)          ENDING CC
         SR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,8(R5)         ENDING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         S     R1,STARTTRK         TRACKS IN THIS EXTENT IN R1
         LA    R1,1(,R1)           KEEP IT HONEST
         AR    R8,R1               COUNT IT
         LA    R7,4(,R7)           SKIP TO NEXT LA INSTRUCTION.
VTOC5C   BCT   R15,VTOC5B          LOOP THROUGH ALL EXTENTS.
VTOC5A   LA    R8,0(0,R8)          PURIFY A REGISTER.
         STCM  R8,15,TRACKS        TRACKS ALLOCATED
VTOC99   DS    0H
         $EPILOG ,                 ALL DONE.
         LTORG ,
COMPDSNV CLC   DSPFX(0),L1DSNAME   EXECUTED COMMAND                @134
EXTLIST  LA    R5,SV1EXT1
         LA    R5,SV1EXT2
         LA    R5,SV1EXT3
         LA    R5,SV3EXT4
         LA    R5,SV3EXT5
         LA    R5,SV3EXT6
         LA    R5,SV3EXT7
         LA    R5,SV3EXT8
         LA    R5,SV3EXT9
         LA    R5,SV3EXT10
         LA    R5,SV3EXT11
         LA    R5,SV3EXT12
         LA    R5,SV3EXT13
         LA    R5,SV3EXT14
         LA    R5,SV3EXT15
         LA    R5,SV3EXT16
         SPACE ,
SEARCH   CAMLST  SEARCH,CAMDSN,CAMVOL,FORMAT1
CAMDSN   DC    CL44' '
CAMVOL   DC    CL6' '
FORMAT1  DC    XL148'00'
OBTAINRC DC    F'0'
F3CAMLST CAMLST  SEEK,CCHHR3,CAMVOL,FORMAT3
CCHHR3   DC    XL5'00'
FORMAT3  DC    XL148'00'
./       ADD   NAME=VVDS
         TITLE ' - COLLECT DATA FROM VVDS CELLS.'
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         SPACE
VVDS    $PROLOG R12
         L     R4,=V(DATASECT)
         USING DATASECT,R4
         SR    R15,R15             RESET RETURN CODE.              @122
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         USING VVR,R6
VVDS0    CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
VVDS0A   XC    VVD0,VVD0           NEXT CELL PLEASE                @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         C     R15,=F'8'           PROBLEMS?                       @122
         BNE   VVDS0               NO. IS IT A VVR?                @122
        $MESSAGE 3,DATA=L1DSNAME                                   @122
         B     VVDS98              RETURN WITH RC=8                @122
VVDS0B   SR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     VVDS0C
         CLC   L1DSNAME(0),VVRCMPNM  (EXECUTED)
VVDS0C   EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   VVDS0A              NO, MUST BE A RELATED COMPONENT.
         CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS1               YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS2               YES, IS IT THE RIGHT ONE?
         B     VVDS99              SHOULD NEVER HAPPEN!
VVDS1    MVC   VVD0,=X'0000FF23'   VOLUME INFORMATION CELL         @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         LTR   R15,R15             WAS THERE A VOLINFO CELL?       @134
         BNZ   VVDS2               NO.                             @134
         USING VVRVOLIN,R6
         MVC   BLKSIZE,VVRBLKSZ    SAVE BLOCK SIZE.
         SR    R1,R1               COUNT OF TRACKS
         SR    R8,R8
         ICM   R8,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LA    R6,40(0,R6)         SKIP AHEAD TO EXTENT DESCR.
         USING VVRXTENT,R6
VVDS1B   AH    R1,VVRXNTRK         COUNT TRACKS THIS EXTENT
         LA    R6,20(0,R6)         SKIP TO NEXT EXTENT DESCR.
         BCT   R8,VVDS1B
         ST    R1,TRACKS           SAVE ALLOCATED TRACKS.
         B     VVDS99
         DROP  R6
VVDS2    MVC   VVD0,=X'00000021'   DATASET INFORMATION CELL.       @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         USING VVRDSINF,R6
         MVC   LRECL,VVRLRECL      SAVE AVERAGE LRECL
         ICM   R1,15,VVRBUFSZ      PICK UP BUFFER SIZE.            @130
         CVD   R1,WORK             CONVERT TO DECIMAL.             @130
         EDIT  L1BFSP,                                             @130X
               DWK3,ZZZZ9          FORMAT IT.                      @130
         ICM   R0,15,VVRDSHU       GET HIGH USED RBA.              @130
         SRDA  R0,32               READY FOR MULTIPLY              @130
         M     R0,=F'100'          TIMES 100.                      @130
*        LR    R0,R1                                               @130
*        SRDA  R0,32               READY FOR DIVIDE.               @130
         ICM   R2,15,VVRDSHA       GET HIGH ALLOC RBA              @130
         DR    R0,R2               (USED*100)/ALLOC                @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1USED,                                             @130X
               DWK2,ZZ9            FORMATTED.                      @130
         MVC   VVD0,=X'0000FF60'   NEED AN AMDSB NEXT              @134
         L     R15,=V(FINDVVDS)                                    @134
         BALR  R14,R15             SCAN VVDS                       @134
         LTR   R15,R15             WAS THERE AN AMDSB?             @134
         BNZ   VVDS1               NO. TRY A VOL INFO CELL.        @134
         USING VVRAMDCL,R6
         ICM   R1,15,VVRAMCIS      PICK UP CI SPLITS.              @130
         C     R1,=F'999'          MORE THAN 999 SPLITS            @134
         BNH   VVD1K1              NO. PRINT THE NUMBER            @134
         MVC   L1CISP,=C'>>>'      INDICATE "LOTS"                 @134
         B     VVD1K2              SKIP OVER NUMERIC SETUP.        @134
VVD1K1   DS    0H                                                  @134
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CISP,                                             @130X
               DWK2,ZZ9            FORMAT IT NICELY.               @130
VVD1K2   DS    0H                                                  @134
         ICM   R1,15,VVRAMCAS      PICK UP CA SPLITS.              @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CASP,                                             @130X
               DWK2,ZZ9            FORMAT IT NICELY.               @130
         SR    R1,R1               CLEAR REGISTER                  @130
         ICM   R1,1,VVRAMPCA       PICK UP CA FREESPACE %          @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CAFS,                                             @130X
               DWK2,Z9             AND FORMAT.                     @130
         ICM   R1,1,VVRAMPCI       PICK UP CI FREESPACE %          @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1CIFS,                                             @130X
               DWK2,Z9             AND FORMAT.                     @130
         ICM   R1,3,VVRAMNXT       GET NUMBER OF EXTENTS.          @130
         CVD   R1,WORK             CONVERT TO DECIMAL              @130
         EDIT  L1XTNT,                                             @130X
               DWK2,ZZ9            AND FORMAT.                     @130
         B     VVDS1               LOOK FOR VOLUME INFORMATION CELL
         DROP  R6
VVDS99   DS    0H
        $EPILOG ,                                                  @134
VVDSR9   DC    F'0'
VVDS98   LA    R15,8               RC=8 FOR CALLER.                @122
         B     VVDS99                                              @122
         LTORG ,                                                   @134
./       ADD   NAME=XPRCLOSE
         MACRO
&SYMBOL  XPRCLOSE  &WA
.* MACRO TO EXECUTE A CLOSE CALL TO 'XPRNTSUB'.
         CNOP  0,4
&SYMBOL  B     *+8                     BRANCH AROUND ADDRESS
         XPRINNRA  &WA,68
         MEND
./       ADD   NAME=XPRDCB
         MACRO
&SYMBOL  XPRDCB  &DDNAME=SYSPRINT,&BLKSIZE=0
         LCLC  &TAG
.* MACRO TO GENERATE A WORK AREA FOR A PRINTER DATA SET, CONTAINING
.* A SAVE AREA, THE DCB, OPEN AND CLOSE PARAMETER LISTS, AND VARIOUS
.* CELLS AND SWITCHES.
&TAG     SETC  '&SYMBOL'
         AIF   (T'&SYMBOL NE 'O').TOK  TEST IF NAME SUPPLIED
&TAG     SETC  'XPRDCB01'              SUPPLY STANDARD PRDCB NAME
.TOK     ANOP
&TAG     DS    0D                      ALIGN ON DOUBLE-WORD BOUNDARY
         DS    18F                     STANDARD SAVE AREA
         SPACE
*        DCB   DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,           X
*              BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2
IHB&SYSNDX DCB DDNAME=&DDNAME,DSORG=PS,RECFM=VBM,LRECL=137,            X
               BLKSIZE=&BLKSIZE,MACRF=PL,BFTEK=S,BUFNO=2
         SPACE
* PARAMETER LISTS FOR OPEN AND CLOSE:
         SPACE
         OPEN  (IHB&SYSNDX,(OUTPUT,LEAVE)),MF=L  PARM LIST FOR OPEN
         SPACE
         CLOSE (IHB&SYSNDX,LEAVE),MF=L PARM LIST FOR CLOSE
         SPACE
* WORK CELLS AND VARIABLE STORAGE:
         SPACE
         DS    1D                      WORK CELL
         DS    3F                      WORK CELLS
         DS    1A                      PAGE HEADING PARM LIST ADDRESS
         DS    1F                      MAXIMUM NUMBER OF OUTPUT LINES
         DS    1H                      PAGE WIDTH
         DS    1H                      PAGE LENGTH
         DS    1H                      PAGE NUMBER
         DS    1H                      PAGE BALANCE
         DS    1X                      SWITCHES
         DS    CL24                    DATE & TIME FOR PAGE HEADING
         SPACE 2
         MEND
./       ADD   NAME=XPREJECT
         MACRO
&SYMBOL  XPREJECT  &WA,&COND=
.* MACRO TO EXECUTE AN EJECT CALL TO 'XPRNTSUB'.
         LCLC  &TAG,&SYM,&OPT,&R
         LCLA  &K
&SYM     SETC  '&SYMBOL'
&TAG     SETC  'IHB&SYSNDX'
         CNOP  2,4
.TST1    AIF   ('&COND' NE '').TST2
&OPT     SETC  'F000'
         AGO   .SIMPLE
.TST2    AIF   ('&COND' NE 'ATHOF').TSTC
&OPT     SETC  'F100'
.SIMPLE  ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS
         DC    XL2'&OPT'               OPTION BITS
         AGO   .VCON
.TSTC    AIF   ('&COND(1)' NE 'EQ').NE
&OPT     SETC  '80'
.NE      AIF   ('&COND(1)' NE 'NE').LT
&OPT     SETC  '70'
.LT      AIF   ('&COND(1)' NE 'LT').GT
&OPT     SETC  '40'
.GT      AIF   ('&COND(1)' NE 'GT').LE
&OPT     SETC  '20'
.LE      AIF   ('&COND(1)' NE 'LE').GE
&OPT     SETC  'C0'
.GE      AIF   ('&COND(1)' NE 'GE').NOT
&OPT     SETC  'A0'
.NOT     AIF   ('&OPT' NE '').COK
         MNOTE 4,'COND OPERAND &COND(1) ILLEGAL'
.COK     AIF   ('&COND(2)' NE '').C2OK
         MNOTE 4,'COND TEST QUANTITY MISSING'
         AGO   .NOTREG
.C2OK    AIF   ('&COND(2)'(1,1) NE '(').NOTREG
&K       SETA  K'&COND(2)-2
&R       SETC  '&COND(2)'(2,&K)
&SYM     STC   &R,&TAG.A               STORE INTO PARM LIST
&SYM     SETC  ''
.NOTREG  ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM ADDRESS
         DC    XL1'&OPT'               CONDITION MASK
         AIF   ('&COND(2)' EQ '').NOTREG2
         AIF   ('&COND(2)'(1,1) NE '(').NOTREG2
&TAG.A   DC    AL1(0)                  TEST QUANTITY
         AGO   .VCON
.NOTREG2 DC    AL1(&COND(2))           TEST QUANTITY
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,92
         MEND
./       ADD   NAME=XPRHEAD
         MACRO
&SYMBOL  XPRHEAD  &WA,&LIST=
.* MACRO TO PRESENT A LIST OF PRINT LINE DESCRIPTORS FOR PAGE HEADINGS
.* TO 'XPRNTSUB'.
&SYMBOL  XPRLIST  &WA,LIST=&LIST,IHBPARM=80
         MEND
./       ADD   NAME=XPRINNRA
         MACRO
&TAG     XPRINNRA  &WA,&IHBPARM
.* INNER MACRO USED IN CALLS TO 'XPRNTSUB'
         DC    V(XPRNTSUB)             PRINTING SUBROUTINE ADDRESS
&TAG     L     15,*-4                  LOAD ENTRY POINT
         AIF   ('&WA' NE '').WOK
         LA    0,XPRDCB01              LOAD STANDARD WORK AREA ADDRESS
         AGO   .BAL
.WOK     AIF   ('&WA' EQ '(0)').BAL
         AIF   ('&WA'(1,1) EQ '(').REG
         LA    0,&WA                   LOAD WORK AREA ADDRESS
         AGO   .BAL
.REG     LR    0,&WA(1)                LOAD WORK AREA ADDRESS
.BAL     BAL   14,&IHBPARM.(15)        CALL PRINT SUBROUTINE
         MEND
./       ADD   NAME=XPRLDEF
         MACRO
&SYMBOL  XPRLDEF  &TEXT=,&LENGTH=132,&OFFSET=0,&SPA=1,&SPB=0
.* MACRO TO DEFINE PRINT LINE DESCRIPTOR BLOCKS ("PLD" BLOCKS) FOR
.* THE PRINTING SUBROUTINE "XPRNTSUB".
         LCLA  &N
         LCLC  &B3,&B6,&B7
         ACTR  25                      JUST IN CASE
&B3      SETC  '0'
&B6      SETC  '0'
&B7      SETC  '0'
.* PROCESS OPTIONS IN SPA OPERAND:
.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1
         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2
&B3      SETC  '1'
         AGO   .TSTB1
.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'
.* PROCESS OPTIONS IN SPB OPERAND:
.TSTB1   ANOP
&N       SETA  2
.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2
&B7      SETC  '1'
         AGO   .TSTB4
.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3
&B6      SETC  '1'
         AGO   .TSTB4
.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4
         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'
.TSTB4   ANOP
&N       SETA  &N+1
         AIF   (&N LE 3).TSTB5
.IFTEXT  AIF   ('&TEXT' NE '').TOK
         MNOTE 4,'TEXT ADDRESS MISSING'
.TOK     ANOP
&SYMBOL  DS    0F                      ALIGN ON FULL-WORD BOUNDARY
         DC    BL1'000&B3.00&B6&B7'    OPTION BITS
         DC    AL3(&TEXT)              TEXT ADDRESS
         DC    AL1(&LENGTH)            TEXT LENGTH
         DC    AL1(&OFFSET)            MARGIN OFFSET
.TESTB   AIF   ('&SPB(1)' EQ 'EJECT').BSKIP
         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP
         DC    AL1(&SPB(1))            PRE-SPACING
         AGO   .TESTA
.BSKIP   ANOP
         DC    AL1(255)                EJECT BEFORE PRINTING
.TESTA   AIF   ('&SPA(1)' EQ 'EJECT').ASKIP
         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP
         DC    AL1(&SPA(1))                 POST-SPACING
         MEXIT
.ASKIP   ANOP
         DC    AL1(255)                EJECT AFTER PRINTING
         MEND
./       ADD   NAME=XPRLIST
         MACRO
&SYMBOL  XPRLIST  &WA,&LIST=,&IHBPARM=32
.* MACRO TO DELIVER A LIST OF PRINT LINE DESCRIPTORS TO 'XPRNTSUB'.
         LCLA  &N,&K,&D
         LCLC  &TAG,&SYM,&R
         ACTR  100
&SYM     SETC  '&SYMBOL'
&TAG     SETC  'IHB&SYSNDX'
         AIF   ('&LIST' NE '').LOK
         MNOTE 8,'LIST OPERAND MUST BE SUPPLIED'
         MEXIT
.LOK     CNOP  0,4
         AIF   ('&LIST' NE '(1)').STLOOP
&SYMBOL  B     &TAG.L                  BRANCH AROUND ADDRESS
         AGO   .VCON
.STLOOP  ANOP
&N       SETA  &N+1
         AIF   (&N GT N'&LIST).STDONE
         AIF   ('&LIST(&N)'(1,1) NE '(').STLOOP
&K       SETA  K'&LIST(&N)-2
&R       SETC  '&LIST(&N)'(2,&K)
&D       SETA  4*(&N-1)
&SYM     ST    &R,&TAG.A+&D            STORE INTO PARM LIST
&SYM     SETC  ''
         AIF   (&N NE N'&LIST).STLOOP
         OI    &TAG.A+&D,X'80'         SET END-OF-LIST BIT
.STDONE  ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS
&SYM     SETC  '&TAG.A'
&N       SETA  0
.LOOP    ANOP
&N       SETA  &N+1
         AIF   (&N GT N'&LIST).VCON
         AIF   ('&LIST(&N)'(1,1) NE '(').NOTREG
&SYM     DC    A(0)
&SYM     SETC  ''
         AGO   .LOOP
.NOTREG  AIF   (&N EQ N'&LIST).LAST
&SYM     DC    A(&LIST(&N))
&SYM     SETC  ''
         AGO   .LOOP
.LAST    ANOP
&SYM     DC    X'80'                   END-OF-LIST BIT
         DC    AL3(&LIST(&N))
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,&IHBPARM
         MEND
./       ADD   NAME=XPRMOD
         MACRO
&SYMBOL  XPRMOD  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,       X
               &TIME=0,&DATE=0
.* MACRO TO EXECUTE A MODIFY CALL TO 'XPRINTSUB'.
&SYMBOL  XPROPEN  &WA,MAXLINE=&MAXLINE,PAGENO=&PAGENO,PAGEWID=&PAGEWID,X
               PAGELEN=&PAGELEN,TIME=&TIME,DATE=&DATE,IHBPARM=104
         MEND
./       ADD   NAME=XPRNTLIN
         MACRO
&SYMBOL  XPRNTLIN  &WA,&TEXT=00,&LENGTH=132,&OFFSET=0,&SPB=0,&SPA=1
         LCLA  &N
         LCLC  &B3,&B6,&B7,&T,&R
         ACTR  25
&T       SETC  'IHB&SYSNDX'
&B3      SETC  '0'
&B6      SETC  '0'
&B7      SETC  '0'
.* PROCESS OPTIONS IN SPA OPERAND:
.TSTA1   AIF   ('&SPA(2)' EQ '').TSTB1
         AIF   ('&SPA(2)' NE 'NOEJ').TSTA2
&B3      SETC  '1'
         AGO   .TSTB1
.TSTA2   MNOTE 4,'OPERAND &SPA(2) AFTER KEYWORD SPA IS ILLEGAL'
.* PROCESS OPTIONS IN SPB OPERAND:
.TSTB1   ANOP
&N       SETA  2
.TSTB5   AIF   ('&SPB(&N)' NE 'NOEJ').TSTB2
&B7      SETC  '1'
         AGO   .TSTB4
.TSTB2   AIF   ('&SPB(&N)' NE 'ATHOF').TSTB3
&B6      SETC  '1'
         AGO   .TSTB4
.TSTB3   AIF   ('&SPB(&N)' EQ '').TSTB4
         MNOTE 4,'OPERAND &SPB(&N) AFTER KEYWORD SPB IS ILLEGAL'
.TSTB4   ANOP
&N       SETA  &N+1
         AIF   (&N LE 3).TSTB5
.* GENERATE STORE INSTRUCTIONS IF REGISTER NOTATION IS USED:
         CNOP  0,4
         AIF   ('&SYMBOL' EQ '').IFR1
&SYMBOL  DS    0H
.IFR1    AIF   ('&TEXT' NE '00').TXTOK
         MNOTE 4,'TEXT ADDRESS MUST BE SUPPLIED'
.TXTOK   AIF   ('&TEXT'(1,1) NE '(').IFR2
         ST    &TEXT(1),&T.A           STORE TEXT ADDRESS
         MVI   &T.A,B'000&B3.00&B6&B7' INSERT OPTION BITS
.IFR2    AIF   ('&LENGTH'(1,1) NE '(').IFR3
         STC   &LENGTH(1),&T.A+4       STORE TEXT LENGTH
.IFR3    AIF   ('&OFFSET'(1,1) NE '(').IFR4
         STC   &OFFSET(1),&T.A+5       STORE MARGIN OFFSET
.IFR4    AIF   ('&SPB(1)'(1,1) NE '(').IFR5
&N       SETA  K'&SPB(1)-2
&R       SETC  '&SPB(1)'(2,&N)
         STC   &R,&T.A+6               STORE PRE-SPACING
.IFR5    AIF   ('&SPA(1)'(1,1) NE '(').LOAD1
&N       SETA  K'&SPA(1)-2
&R       SETC  '&SPA(1)'(2,&N)
         STC   &R,&T.A+7               STORE POST-SPACING
.* LOAD REG 1 AND GENERATE PLD LIST ADDRESS:
.LOAD1   BAL   1,&T.L                  LOAD PARM ADDRESS
         DC    X'80'                   MARK END OF ADDRESS LIST
         DC    AL3(&T.A)               ADDRESS OF PLD
.* GENREATE PLD PARAMETERS TO DESCRIBE THE PRINT LINE:
.IFR11   AIF   ('&TEXT'(1,1) NE '(').NOTR11
&T.A     DC    A(0)                    TEXT ADDRESS & OPTION BITS
         AGO   .IFR12
.NOTR11  ANOP
&T.A     DC    B'000&B3.00&B6&B7'      OPTION BITS
         DC    AL3(&TEXT)              TEXT ADDRESS
.IFR12   AIF   ('&LENGTH'(1,1) NE '(').NOTR12
         DC    AL1(0)                  TEXT LENGTH
         AGO   .IFR13
.NOTR12  DC    AL1(&LENGTH)            TEXT LENGTH
.IFR13   AIF   ('&OFFSET'(1,1) NE '(').NOTR13
         DC    AL1(0)                  MARGIN OFFSET
         AGO   .IFR14
.NOTR13  DC    AL1(&OFFSET)            MARGIN OFFSET
.IFR14   AIF   ('&SPB(1)'(1,1) NE '(').NOTR14
         DC    AL1(0)                  PRE-SPACING
         AGO   .IFR15
.NOTR14  AIF   ('&SPB(1)' EQ 'EJECT').BSKIP
         AIF   ('&SPB(1)' EQ 'SKIP').BSKIP
         DC    AL1(&SPB(1))            PRE-SPACING
         AGO   .IFR15
.BSKIP   DC    AL1(255)                SKIP BEFOR PRINTING
.IFR15   AIF   ('&SPA(1)'(1,1) NE '(').NOTR15
         DC    AL1(0)                  POST-SPACING
         AGO   .VCON
.NOTR15  AIF   ('&SPA(1)' EQ 'EJECT').ASKIP
         AIF   ('&SPA(1)' EQ 'SKIP').ASKIP
         DC    AL1(&SPA(1))            POST-SPACING
         AGO   .VCON
.ASKIP   DC    AL1(255)                SKIP AFTER PRINTING
.VCON    ANOP
&T.L    XPRINNRA  &WA,32
         MEND
./       ADD   NAME=XPROPEN
         MACRO
&SYMBOL  XPROPEN  &WA,&MAXLINE=0,&PAGENO=0,&PAGEWID=0,&PAGELEN=0,      X
               &TIME=0,&DATE=0,&DDNAME=SYSPRINT,&IHBPARM=56
.* MACRO TO EXECUTE AN 'OPEN' OR 'MODIFY' CALL TO 'XPRNTSUB'.
         LCLC  &TAG
&TAG     SETC  'IHB&SYSNDX'
         AIF   ('&SYMBOL' EQ '').T1
&SYMBOL  DS    0H
.T1      AIF   ('&MAXLINE'(1,1) NE '(').T2
         ST    &MAXLINE(1),&TAG.A      STORE IN PARM LIST
.T2      AIF   ('&PAGENO'(1,1) NE '(').T3
         STH   &PAGENO(1),&TAG.A+4     STORE IN PARM LIST
.T3      AIF   ('&PAGEWID'(1,1) NE '(').T4
         STC   &PAGEWID(1),&TAG.A+6    STORE IN PARM LIST
.T4      AIF   ('&PAGELEN'(1,1) NE '(').T5
         STC   &PAGELEN(1),&TAG.A+7    STORE IN PARM LIST
.T5      AIF   ('&TIME'(1,1) NE '(').T6
         ST    &TIME(1),&TAG.A+8       STORE IN PARM LIST
.T6      AIF   ('&DATE'(1,1) NE '(').T7
         ST    &DATE(1),&TAG.A+12      STORE IN PARM LIST
.T7      AIF   ('&DDNAME'(1,1) NE '(').CNOP
         MVC   &TAG.A+16(8),0(&DDNAME(1))  STORE IN PARM LIST
.CNOP    CNOP  0,4
         BAL   1,&TAG.L        LOAD PARM LIST ADDRESS
.P1      AIF   ('&MAXLINE'(1,1) EQ '(').PR1
&TAG.A   DC    A(&MAXLINE)             PRINT OUTPUT LIMIT
         AGO   .P2
.PR1     ANOP
&TAG.A   DC    A(0)                    PRINT OUTPUT LIMIT
.P2      AIF   ('&PAGENO'(1,1) EQ '(').PR2
         DC    AL2(&PAGENO)            PAGE NUMBER
         AGO   .P3
.PR2     DC    AL2(0)                  PAGE NUMBER
.P3      AIF   ('&PAGEWID'(1,1) EQ '(').PR3
         DC    AL1(&PAGEWID)           PAGE WIDTH
         AGO   .P4
.PR3     DC    AL1(0)                  PAGE WIDTH
.P4      AIF   ('&PAGELEN'(1,1) EQ '(').PR4
         DC    AL1(&PAGELEN)           PAGE LENGTH
         AGO   .P5
.PR4     DC    AL1(0)                  PAGE LENGTH
.P5      AIF   ('&TIME'(1,1) EQ '(').PR5
         DC    A(&TIME)                ADDRESS OF TIME
         AGO   .P6
.PR5     DC    A(0)                    ADDRESS OF TIME
.P6      AIF   ('&DATE'(1,1) EQ '(').PR6
         DC    A(&DATE)                ADDRESS OF DATE
         AGO   .P7
.PR6     DC    A(0)                    ADDRESS OF DATE
.P7      AIF   ('&IHBPARM' NE '56').VCON
         AIF   ('&DDNAME'(1,1) EQ '(').PR7
         DC    CL8'&DDNAME'            DDNAME FOR DATA SET
         AGO   .VCON
.PR7     DC    CL8' '                  DDNAME FOR DATA SET
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,&IHBPARM
         MEND
./       ADD   NAME=XPRSPACE
         MACRO
&SYMBOL  XPRSPACE  &WA,&LINES=1,&COND=
.* MACRO TO EXECUTE A SPACE CALL TO 'XPRNTSUB'.
         LCLA  &N,&B6,&B7
         LCLC  &TAG,&SYM
&SYM     SETC  '&SYMBOL'
&TAG     SETC  'IHB&SYSNDX'
.LOOP    ANOP
&N       SETA  &N+1
         AIF   (&N GT N'&COND).LDONE
.TST1    AIF   ('&COND(&N)' NE 'NOEJ').TST2
&B6      SETA  1
         AGO   .LOOP
.TST2    AIF   ('&COND(&N)' NE 'ATHOF').TST3
&B7      SETA  1
         AGO   .LOOP
.TST3    MNOTE 4,'OPERAND &COND(&N) AFTER KEYWORD COND IS ILLEGAL'
         AGO   .LOOP
.LDONE   CNOP  2,4
         AIF   ('&LINES'(1,1) NE '(').NOTREG1
&SYM     STC   &LINES(1),&TAG.A+1      STORE INTO PARM LIST
&SYM     SETC  ''
.NOTREG1 ANOP
&SYM     BAL   1,&TAG.L                LOAD PARM LIST ADDRESS
&TAG.A   DC    B'000000&B6&B7'         OPTION BITS
         AIF   ('&LINES'(1,1) NE '(').NOTREG2
         DC    X'00'                   SPACING AMOUNT
         AGO   .VCON
.NOTREG2 DC    AL1(&LINES)             SPACING AMOUNT
.VCON    ANOP
&TAG.L   XPRINNRA  &WA,44
         MEND
