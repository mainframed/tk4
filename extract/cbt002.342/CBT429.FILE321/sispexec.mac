./ ADD NAME=$$README 0101-1999159-1999362-2250-00044-00044-00000-DESTS03
     ----------------------- ISPF application --------------------------

     supplement to CBT File 321

     COBA      This Application analyse the output from the
               Cobol analyse program developed by Roland Schiradin
               Roland(at)Schiradin.de
               To simlify the procedure, the program COBANAL is
               included in this library
               This application requires ISPF Version 4
               The application consist of 4 datasets.
               Rexx library
               Panel Library
               Message and Skeleton Library
               Table Libary

               You have to change member $COBA in the Rexx library
               See section/label Coba_Parms thru End_Coba_Parms.
               Please change the following variables to your standards

               ACCOUNT
               CLASS
               MSGCLASS
               STEPLIB
               ISPFHLQ
               COBAAPPL
               COBAHLQ
               LLQCLIB
               LLQPLIB
               LLQMLIB
               LLQSLIB
               LLQTLIB
               LLQTABL

               After these changes you can execute procedure $COBA
               First you'll see a selection panel to display
               or create analyse tables.

               If you have any problems, comments or improvements
               please contact
               Alber(at)alber-edv.de
               If case of a problem please send the output from
               the COBANAL program and the edited output file.

./ ADD NAME=$$WHATSN 0101-1999348-1999348-1649-00003-00002-00000-DESTS03
COBANAL  A new version
SISP*    The ISPF interface changed rexx's and panels
         for new output from COBANAL program
./ ADD NAME=$COBA    0100-1999265-1999265-0720-00072-00072-00000-DESTS03
/*---- REXX -- COPYRIGHT - 1999 -- COBA ---- ISPF-DIALOG -----*/
/*                                                            */
/*     COBOL ANALYSE ISPF DIALOG                              */
/*     supplement to cbt file 419 program cobanal             */
/*     developed by roland schiradin                          */
/*                                                            */
/*     Fritz Alber                                            */
/*     Albstr. 19                                             */
/*     D 72649 Wolfschlugen                                   */
/*     TEL. 0049-7022/959234                                  */
/*     FAX. 0049-7022/959236                                  */
/*                                                            */
/*     E-MAIL  : Alberµalber-edv.de                           */
/*     INTERNET: www.alber-edv.de                             */
/*                                                            */
/*     Please customize section Coba_parms to your values     */
/*                                                            */
/*------------------------------------------------------------*/

Coba_Parms:              /*  -------- Start COBA Parms ------ */
                         /*  --------- JCL Parameters ------- */
ACCOUNT = 'T9SYSTEM'     /*  Account Info for JOB card        */
CLASS   = 'S'            /*  Job class                        */
MSGCLASS= 'Z'            /*  Job message class                */
ISPFHLQ = 'ISP'          /*  ISPFHLQ = HLQ for ISP system dsn */
                         /*  Steplib for COBANAL program      */
STEPLIB = 'DESTS03.COBA.SISPLOAD'
                         /*  ------- End JCL Parameters ----- */
                         /*  ----------- ISPF Parms --------- */
COBAHLQ = 'DESTS03.COBA' /*  COBAHLQ = HLQ for COBA ISPF appl */
                         /*                                   */
COBAAPPL = COBA          /*  ISPF Application name for COBA   */
                         /*  application                      */
LLQCLIB  = SISPEXEC      /*  LOW LEVEL QUALIFIER for EXEC and */
                         /*  CLISTS. Change to your value     */
LLQMLIB  = SISPMENU      /*  LOW LEVEL QUALIFIER for  MESSAGES*/
                         /*  Change to your value             */
LLQPLIB  = SISPPENU      /*  LOW LEVEL QUALIFIER for  PANELS  */
                         /*  Change to your value             */
LLQSLIB  = SISPMENU      /*  LOW LEVEL QUALIFIER for  SKELS   */
                         /*  Change to your value             */
LLQTLIB  = SISPTENU      /*  LOW LEVEL QUALIFIER for  TABLE   */
                         /*  INPUT. Change to your value      */
LLQTABL  = SISPTENU      /*  LOW LEVEL QUALIFIER for  TABLE   */
                         /*  OUTPUT. Change to your value     */
                         /*  ------- End of ISPF Parms ------ */
End_Coba_Parms:          /*  ------  End of Coba Parms ------ */

ADDRESS TSO
"ALTLIB ACTIVATE APPL(CLIST) DATASET('"COBAHLQ"."LLQCLIB"')"

ADDRESS ISPEXEC
"LIBDEF ISPMLIB DATASET ID('"COBAHLQ"."LLQMLIB"') STACK"
"LIBDEF ISPPLIB DATASET ID('"COBAHLQ"."LLQPLIB"') STACK"
"LIBDEF ISPSLIB DATASET ID('"COBAHLQ"."LLQSLIB"') STACK"
"LIBDEF ISPTLIB DATASET ID('"COBAHLQ"."LLQTLIB"') STACK"
"LIBDEF ISPTABL DATASET ID('"COBAHLQ"."LLQTABL"') STACK"

"SELECT CMD(COBANL " STEPLIB COBAAPPL COBAHLQ ,
            LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL ,
            ACCOUNT CLASS MSGCLASS ISPFHLQ") ,
            PASSLIB NEWAPPL("COBAAPPL")"

"LIBDEF ISPMLIB"
"LIBDEF ISPPLIB"
"LIBDEF ISPSLIB"
"LIBDEF ISPTLIB"
"LIBDEF ISPTABL"

ADDRESS TSO "ALTLIB DEACTIVATE APPL(CLIST)"

EXIT
./ ADD NAME=COBA#MAC 0100-1999362-1999362-2219-00239-00239-00000-DESTS03
/* REXX */
TRACE
ADDRESS ISPEXEC
"ISREDIT MACRO"
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'was loaded' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Sorry no'   ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'You better' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Can not estab' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND '=== End  ====' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'No call'    ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'No program' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Call Liter' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Call iden'  ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Call address'  ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Copy-'      ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Program has' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Program use' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND ' DATA DIVISION' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND ' ENVIROMENT DIVISION' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Additional' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'User supplied' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Following' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Installation def' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'hexadecimal' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Exponent' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Floating' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Basis-St' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Shift-In' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Compilation' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT CHANGE 'no Default' 'no-Default'                          ALL"
"ISREDIT RESET"
"ISREDIT CHANGE 'SIZE(value)SOURCE' 'SIZE(value) SOURCE'           ALL"
"ISREDIT RESET"
"ISREDIT CHANGE 'SIZE(value)NOSOURCE' 'SIZE(value) NOSOURCE'       ALL"
"ISREDIT RESET"
"ISREDIT CHANGE 'Go to' 'Go-to'                                    ALL"
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 50"
"ISREDIT FIND '                                                  ' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT CHANGE 'NO TRACE ' 'NO-TRACE '                            ALL"
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 50"
"ISREDIT FIND '==================================================' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 20"
"ISREDIT FIND 'Open Exten' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Error during load' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'DBCS-Name in' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 3"
"ISREDIT FIND 'No ' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT BOUNDS"
"ISREDIT END "
EXIT
./ ADD NAME=COBA#MA2 0101-1999106-1999106-1528-00251-00244-00039-FRALBER
/* REXX */
TRACE
ADDRESS ISPEXEC
"ISREDIT MACRO"
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'was loaded' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Sorry no'   ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'You better' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Can not estab' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND '=== End  ====' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'No call'    ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'No program' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Call Liter' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Call iden'  ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Call address'  ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Copy'       ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Program has' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Program use' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'DIVISION' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Additional' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'User supplied' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Following' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Installation def' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'hexadecimal' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Exponent' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Floating' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Basis-St' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Shift-In' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Compilation' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND '  N  ' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND '  Y  ' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT CHANGE 'no Default' 'no-Default'                          ALL"
"ISREDIT RESET"
"ISREDIT CHANGE 'SIZE(value)SOURCE' 'SIZE(value) SOURCE'           ALL"
"ISREDIT RESET"
"ISREDIT CHANGE 'SIZE(value)NOSOURCE' 'SIZE(value) NOSOURCE'       ALL"
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 50"
"ISREDIT FIND '                                                  ' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT CHANGE 'NO TRACE ' 'NO-TRACE '                            ALL"
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 50"
"ISREDIT FIND '==================================================' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND '                                                  ' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 20"
"ISREDIT FIND 'Open Exten' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'Error during load' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT FIND 'DBCS-Name in' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT EXCLUDE ALL"
"ISREDIT BOUNDS 1 3"
"ISREDIT FIND 'No ' ALL"
if rc = 0
then do
  "ISREDIT DELETE ALL NX"
end
"ISREDIT RESET"
"ISREDIT BOUNDS"
"ISREDIT END "
EXIT
./ ADD NAME=COBAI34  0100-1999362-1999362-2219-00031-00031-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display information ISPF 3.4 panel         */
/* callers    : COBA application                           */
/*---------------------------------------------------------*/
/*
   TRACE ?R
*/

arg type arg1 arg2

if type = 'VOL'
then do
  zdldsnlv = " "
  zdlpvl   = arg1
end
else do
  if type = 'BOTH'
  then do
    zdldsnlv = arg1
    zdlpvl   = arg2
  end
  else do
    zdldsnlv = arg1
    zdlpvl   = ""
  end
end

"ispexec vput (zdldsnlv zdlpvl) profile"
"ISPEXEC SELECT PGM(ISRUDL) PARM(ISRUDLP)"

exit
./ ADD NAME=COBANAL  0104-1999159-1999357-0824-01653-01634-00000-DESTS03
***********************************************************************
*                                                                     *
* Name:         COBANAL                                               *
*                                                                     *
* Author:       Roland Schiradin                                      *
*               roland(at)Schiradin.de                                *
*                                                                     *
* Date:         Februar 1996                                          *
*                                                                     *
* Description:  Show compile-settings and some other information      *
*                                                                     *
* Changes:      16.12.1996                                            *
*               Support for VS/COBOL1 (just a few)                    *
*               String macro no longer inside this source             *
*               (request FILE183 from Naspa or drop me an email)      *
*               28.04.1997                                            *
*               Support for COBOL for MVS and VM Release 2 (formally  *
*               called AD/Cycle COBOL/370)                            *
*               04.03.1998                                            *
*               MODID-marco dropped                                   *
*               Direct Load-Library support                           *
*               Some parts of Dave Alcocks code (DA$COBR)             *
*               (You can contact him at dalcock(at)csw.com)           *
*               24.03.1998                                            *
*               Prevent S15D abend you invoke COBANAL from TSO-CALL   *
*               (reported by Dave Alcock)                             *
*               Support for newer STRING macro STRING GENERATE instaed*
*               of STRING FINAL_CALL                                  *
*               (reported by Dave Alcock)                             *
*               Fixed a bug in statement list. Y now means Yes and not*
*               vice versa. Sorry                                     *
*               15.02.1999                                            *
*               Support for COBOL OS/390 and VM V2R1                  *
*               Some new Compile-options                              *
*               Compile-Date is European style, added long name       *
*               Some minor fixes I cant remember in detail            *
*               Support for MVS 4.3 (AMODE switching)                 *
*               10.06.1999                                            *
*               Fixed bugs reported by Mr. Smets (Thank you)          *
*               Show ?? as the century for COBOL2                     *
*               Support for Entrypoints (e.g. ENTRY 'DLITCBL')        *
*               Note: There is no need to do this for IMS             *
***********************************************************************
         TITLE 'Show Compile-Option and some more nice info'
COBANAL  CSECT
COBANAL  AMODE 31
COBANAL  RMODE 24
         BAKR  R14,R0             Save register
         LA    R10,1
         LR    R7,R15             set base register
         LA    R12,4095(R10,R7)   second base register
         USING COBANAL,R7,R12     Addressebility
         L     R9,0(R1)           Save Parmlist
         USING COBANAL_PARM,R9    addressebility
         LA    R0,COBANAL_WORK_LENGTH
         STORAGE OBTAIN,LENGTH=(R0),ADDR=(R1),COND=NO,LOC=BELOW
         LR    R11,R1             COBANAL_WORK register
         USING COBANAL_WORK,R11   addressebility
         MVC   EYECATCHER,=CL8'COBANAL'
         MVI   DOALL,C'N'         Default
         XC    SAVEAREA,SAVEAREA  clear saveare
         LA    R15,SAVEAREA       get address of savearea
         ST    R13,4(,R15)        chain the savearea back pointer
         ST    R15,8(,R13)        chain saveare forward
         LR    R13,R15            set new savearea
         ST    R11,ADR_COBANAL_WORK  save address
         ST    R9,ADR_COBANAL_PARM   save address
         OPEN  (SYSPRINT,OUTPUT)
*------------------------------------------------------------*
*        Check JCL-Parm                                      *
*------------------------------------------------------------*
         MVC   PARM_LENGTH,COBANAL_PARM_LENGTH
         LH    R10,PARM_LENGTH
         LA    R9,2(R9)            jump length field
         MVC   PGMNAME,BLANKS      clear PGMNANE
         LA    R8,PGMNAME          first parm
COBANAL_010 DS  0H                 do until first ',' or end
         CLI   0(R9),C','          parm separator
         BE    COBANAL_020         next parm
         MVC   0(1,R8),0(R9)
         LA    R8,1(R8)            next digit
         LA    R9,1(R9)            next digit
         BCT   R10,COBANAL_010     loop
COBANAL_020 DS  0H
         STRING 'COBOL module analysis is starting',INTO=RECORD
         BAS   R14,SPACE1                 Print starting message
         CLC   PGMNAME,BLANKS      check PGMNAME
         BE    COBANAL_PARM_ERROR  if clear ==> Error
         CLC   PGMNAME(3),=C'ALL'  PGMNAME = ALL indicate analyzing
         BNE   COBANAL_025           a complete Load
         MVI   DOALL,C'Y'          remember that
         OPEN  (INPUT,(INPUT))
** Loop
COBANAL_022 DS  0H
         BAS   R14,GETMEM          get the member name
         CLC   PGMNAME,XFF         more entries?
         BE    COBANAL_EXIT          leave
*------------------------------------------------------------*
*        Load the progamm from DD COBANAL                    *
*------------------------------------------------------------*
         LOAD  EPLOC=PGMNAME,DCB=INPUT,ERRET=COBANAL_LOAD_ERROR
         B     COBANAL_027
COBANAL_025 DS  0H
*------------------------------------------------------------*
*        Load the progamm                                    *
*------------------------------------------------------------*
         LOAD  EPLOC=PGMNAME,DCB=INPUT    Load the pgm
COBANAL_027 DS  0H
         LTR   R15,R15             check response
         BNZ   COBANAL_LOAD_ERROR if greater zero ==> Error
         ST    R0,ADR_PGMNAME      save the address
*------------------------------------------------------------*
*        Check length                                        *
*------------------------------------------------------------*
         CSVQUERY SEARCH=JPALPA,       SEARCH JPAQ                     +
               INADDR=ADR_PGMNAME,     ADDRESS                         +
               OUTLENGTH=CSV_LENGTH,                                   +
               MF=(E,CSVQRYWK)         WORK AREA
         LTR   R2,R15                  pass return code
         BNZ   COBANAL_CSV_ERROR if greater zero ==> Error
*------------------------------------------------------------*
*        Write info to sysprint                              *
*------------------------------------------------------------*
COBANAL_03 DS  0H
         STRING 'Program Name= ',PGMNAME,                              @
               ' was loaded into storage at EPA= ',(ADR_PGMNAME,,X),   @
               INTO=RECORD
         BAS   R14,SPACE1
*
*        Dump the first 200 Bytes for Identification.
*        Should be activate only in case of problems
*
*        L     R4,ADR_PGMNAME
*        LA    R3,1000/16               LOOP COUNTER
*LOOP
COBANAL_04 DS  0H
*        STRING 4X,((R4),4,X),1X,(4(R4),4,X),1X,(8(R4),4,X),1X,        X
               (12(R4),4,X),3X,((R4),16),                              $
               INTO=RECORD
*        BAL   R14,SPACE1          <== next line
*        LA    R4,016(,R4)             BUMP POINTER
*        BCT   R3,COBANAL_04
*ENDLOOP
         L     R4,ADR_PGMNAME       Load-Entry-Point
         USING COBOL_370_DSECT,R4
         CLC   CSV_LENGTH,=F'24'    At least 24 bytes!!!
         BNH   COBANAL_06            prevent S0C4
         CLC   0(8,R4),=X'47F0F01400C3C5C5' le-enabled Assembler
         BE    COBANAL_07            prevent S0C4
         CLC   CEE_EYECATCHER,C_COBOL370   COBOL/370 ?  X'00C3C5C5'
         BE    COBOL_370
         USING COBOL_2_DSECT,R4
         CLC   C2_EYECATCHER,=CL4' C2 '     COBOL/2 ?  X'40C3F240'
         BE    COBOL_2
         USING COBOL_1_DSECT,R4
* ???    CLC   C1_EYECATCHER,=CL2'AN'       ANS4 COBOL ?
* ???    BE    COBOL_1
         CLC   C1_EYECATCHER,=CL2'VS'       COBOL/1 ?
         BE    COBOL_1
COBANAL_06 DS  0H
         STRING 'Can not established the program_language',INTO=RECORD
         BAL   R14,SPACE1
         LA    R15,8                clear rc
         B     COBANAL_EXIT         no, leave
COBANAL_07 DS  0H
         STRING 'Program=',PGMNAME,'seems to be a LE-enabled',         X
               'Assembler',INTO=RECORD
         BAL   R14,SPACE1
         LA    R15,8                clear rc
         B     COBANAL_EXIT         no, leave
COBANAL_PARM_ERROR DS  0H
         STRING 'Error parm statement, check it',INTO=RECORD
         BAL   R14,SPACE1
         LA    R15,12
         B     COBANAL_EXIT         no, leave
COBANAL_LOAD_ERROR DS  0H
         STRING 'Error during load of program=',PGMNAME,INTO=RECORD
         BAL   R14,SPACE1
         LA    R15,12
         B     COBANAL_EXIT         no, leave
COBANAL_CSV_ERROR DS  0H
         STRING 'CSVQUERY failed, RC5=',((R2),,L),INTO=RECORD
         BAL   R14,SPACE1
         LA    R15,12
         B     COBANAL_EXIT         no, leave
COBANAL_EXIT       DS 0H
         DELETE EPLOC=PGMNAME       Delete the pgm
         CLI   DOALL,C'N'           Default
         BE    COBANAL_FIN
         CLC   PGMNAME,XFF          Last Programm?
         BE    COBANAL_FIN
         B     COBANAL_022          no loop
COBANAL_FIN        DS 0H
         PR
*============================================================*
*    COBOL/370 Programm                                      *
*============================================================*
COBOL_370 DS 0H
         USING COBOL_370_DSECT,R4
         MVI   LE_SWITCH,C'1'
         L     R4,CEE_PRI_EP_ADDRESS
         MVC   LE_VERS,CEE_VERS
         MVC   LE_REL,CEE_REL
         MVC   LE_MOD,CEE_MOD
         MVC   LE_PGM_NAME,CEE_PGM_NAME
         MVC   LE_COMP_DAY,CEE_COMP_DAY
         MVC   LE_COMP_MONTH,CEE_COMP_MONTH
         MVC   LE_COMP_YEAR,CEE_COMP_YEAR
         MVC   LE_COMP_HOURS,CEE_COMP_HOURS
         MVC   LE_COMP_MIN,CEE_COMP_MIN
         MVC   LE_COMP_SEC,CEE_COMP_SEC
         MVC   LE_DATA_STATEMENTS,CEE_DATA_STATEMENTS
         MVC   LE_PROC_LINES,CEE_PROC_LINES
         MVC   LE_YEAR_WINDOW,CEE_YEAR_WINDOW
         MVC   LE_STATUS_BYTE_01,CEE_STATUS_BYTE_01
         MVC   LE_STATUS_BYTE_02,CEE_STATUS_BYTE_02
         MVC   LE_STATUS_BYTE_03,CEE_STATUS_BYTE_03
         MVC   LE_STATUS_BYTE_04,CEE_STATUS_BYTE_04
         MVC   LE_STATUS_BYTE_05,CEE_STATUS_BYTE_05
         MVC   LE_STATUS_BYTE_06,CEE_STATUS_BYTE_06
         MVC   LE_STATUS_BYTE_07,CEE_STATUS_BYTE_07
         MVC   LE_STATUS_BYTE_08,CEE_STATUS_BYTE_08
         MVC   LE_STATUS_BYTE_09,CEE_STATUS_BYTE_09
         MVC   LE_STATUS_BYTE_10,CEE_STATUS_BYTE_10
         MVC   LE_STATUS_BYTE_11,CEE_STATUS_BYTE_11
         MVC   LE_STATUS_BYTE_12,CEE_STATUS_BYTE_12
         MVC   LE_STATUS_BYTE_13,CEE_STATUS_BYTE_13
         MVC   LE_STATUS_BYTE_14,CEE_STATUS_BYTE_14
         MVC   LE_STATUS_BYTE_15,CEE_STATUS_BYTE_15
         MVC   LE_STATUS_BYTE_16,CEE_STATUS_BYTE_16
         MVC   LE_STATUS_BYTE_17,CEE_STATUS_BYTE_17
         MVC   LE_STATUS_BYTE_18,CEE_STATUS_BYTE_18
         MVC   LE_STATUS_BYTE_19,CEE_STATUS_BYTE_19
         MVC   LE_STATUS_BYTE_20,CEE_STATUS_BYTE_20
         MVC   LE_STATUS_BYTE_21,CEE_STATUS_BYTE_21
         MVC   LE_STATUS_BYTE_22,CEE_STATUS_BYTE_22
         MVC   LE_STATUS_BYTE_23,CEE_STATUS_BYTE_23
         MVC   LE_STATUS_BYTE_24,CEE_STATUS_BYTE_24
         MVC   LE_STATUS_BYTE_25,CEE_STATUS_BYTE_25
         MVC   LE_STATUS_BYTE_26,CEE_STATUS_BYTE_26
         MVC   LE_STATUS_BYTE_27,CEE_STATUS_BYTE_27
         B     LE370_INFO
*============================================================*
*    COBOL/2 Programm                                        *
*============================================================*
COBOL_2 DS 0H
         USING COBOL_2_DSECT,R4
         MVI   LE_SWITCH,C'2'
         L     R4,C2_GET_ENTRY
         L     R4,0(R4)
         MVC   LE_VERS,C2_VERS
         MVC   LE_REL,C2_REL
         MVC   LE_MOD,C2_MOD
         MVC   LE_PGM_NAME,C2_PGM_NAME
         MVC   LE_COMP_DAY,C2_COMP_DAY
         MVC   LE_COMP_MONTH,C2_COMP_MONTH
         MVC   LE_COMP_YEAR(2),=C'??'    COBOL2 not Y2K ready
         MVC   LE_COMP_YEAR+2(2),C2_COMP_YEAR
         MVC   LE_COMP_HOURS,C2_COMP_HOURS
         MVC   LE_COMP_MIN,C2_COMP_MIN
         MVC   LE_COMP_SEC,C2_COMP_SEC
         MVC   LE_DATA_STATEMENTS,C2_DATA_STATEMENTS
         MVC   LE_PROC_LINES,C2_PROC_LINES
         MVC   LE_STATUS_BYTE_01,C2_STATUS_BYTE_01
         MVC   LE_STATUS_BYTE_02,C2_STATUS_BYTE_02
         MVC   LE_STATUS_BYTE_03,C2_STATUS_BYTE_03
         MVC   LE_STATUS_BYTE_04,C2_STATUS_BYTE_04
         MVC   LE_STATUS_BYTE_05,C2_STATUS_BYTE_05
         MVC   LE_STATUS_BYTE_06,C2_STATUS_BYTE_06
         MVC   LE_STATUS_BYTE_07,C2_STATUS_BYTE_07
         MVC   LE_STATUS_BYTE_08,C2_STATUS_BYTE_08
         MVC   LE_STATUS_BYTE_09,C2_STATUS_BYTE_09
         MVC   LE_STATUS_BYTE_10,C2_STATUS_BYTE_10
         MVC   LE_STATUS_BYTE_11,C2_STATUS_BYTE_11
         MVC   LE_STATUS_BYTE_12,C2_STATUS_BYTE_12
         MVC   LE_STATUS_BYTE_13,C2_STATUS_BYTE_13
         MVC   LE_STATUS_BYTE_14,C2_STATUS_BYTE_14
         MVC   LE_STATUS_BYTE_15,C2_STATUS_BYTE_15
         MVC   LE_STATUS_BYTE_16,C2_STATUS_BYTE_16
         MVC   LE_STATUS_BYTE_17,C2_STATUS_BYTE_17
         MVC   LE_STATUS_BYTE_18,C2_STATUS_BYTE_18
         MVC   LE_STATUS_BYTE_19,C2_STATUS_BYTE_19
         MVC   LE_STATUS_BYTE_20,C2_STATUS_BYTE_20
         MVC   LE_STATUS_BYTE_21,C2_STATUS_BYTE_21
         MVC   LE_STATUS_BYTE_22,C2_STATUS_BYTE_22
         MVC   LE_STATUS_BYTE_23,C2_STATUS_BYTE_23
         MVC   LE_STATUS_BYTE_24,C2_STATUS_BYTE_24
         MVC   LE_STATUS_BYTE_25,C2_STATUS_BYTE_25
         B     LE370_INFO
*============================================================*
* VS/COBOL   Program                                         *
*============================================================*
COBOL_1 DS 0H
         USING COBOL_1_DSECT,R4
         MVI   LE_SWITCH,C'3'
         MVC   LE_VERS,BLANKS
         MVC   LE_REL,C1_REL
         MVC   LE_MOD,BLANKS
         MVC   LE_PGM_NAME,C1_PGM_NAME
         MVC   LE_COMP_DAY,C1_COMP_DAY
         MVC   LE_COMP_MONTH,C1_COMP_MONTH
         MVC   LE_COMP_YEAR,C1_COMP_YEAR
         MVC   LE_COMP_HOURS,C1_COMP_HOURS
         MVC   LE_COMP_MIN,C1_COMP_MIN
         MVC   LE_COMP_SEC,C1_COMP_SEC
         L     R5,C1_TGT_PTR
         USING COBOL_1_TGT,R5
         CLC   C1_CHECK,=CL8'SYSOUT'     check
         BE    LE370_INFO
*
*        UNABLE TO FIND THE TASK GLOBAL TABLE  -
*
NOTTGT   DS    0H
         STRING 'Program ',PGMNAME,' failed the TGT (Task Global',     @
               'Table) test',INTO=RECORD
         BAL   R14,SPACE2
         LA    R15,8
         B     COBANAL_EXIT
LE370_INFO DS  0H
         STRING '============ Info ==================================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING 'Programm: ',PGMNAME,' is COBOL/370 Version ',LE_VERS, *
               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD
         CLI   LE_SWITCH,C'1'
         BE    JUMP_AROUND
         STRING 'Programm: ',PGMNAME,' is COBOL/2 Version ',LE_VERS,   *
               ' Release ',LE_REL,' Mod-Level ',LE_MOD,INTO=RECORD
         CLI   LE_SWITCH,C'2'
         BE    JUMP_AROUND
         STRING 'Programm: ',PGMNAME,' is VS/COBOL Release ',LE_REL,   *
               INTO=RECORD
JUMP_AROUND DS 0H
         BAL   R14,SPACE2
         STRING '============ Timestamps ============================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING 'Compiled program name ',LE_PGM_NAME,INTO=RECORD
         BAL   R14,SPACE1
         BAL   R9,LE_370_12
         DC    CL2'01',CL3'Jan'      Long name
         DC    CL2'02',CL3'Feb'      for our non-european user
         DC    CL2'03',CL3'Mar'
         DC    CL2'04',CL3'Apr'
         DC    CL2'05',CL3'May'
         DC    CL2'06',CL3'Jun'
         DC    CL2'07',CL3'Jul'
         DC    CL2'08',CL3'Aug'
         DC    CL2'09',CL3'Sep'
         DC    CL2'10',CL3'Okt'
         DC    CL2'11',CL3'Nov'
         DC    CL2'12',CL3'Dec'
         DC    X'0000',CL3'n/a'             end of table
LE_370_12 DS   0H
         CLC   LE_COMP_MONTH(2),0(R9)         check properties
         BE    LE_370_14               jump if on
         LA    R9,5(,R9)              Skip entry
         CLI   0(R9),0                 end of table?
         BNE   LE_370_12               not yet, loop
LE_370_14 DS   0H
         STRING 'Date: ',LE_COMP_DAY,'.',(LE_COMP_MONTH,2),'.',        *
               LE_COMP_YEAR,' (european) ',LE_COMP_DAY,'.',            *
               (2(R9),3,T),'.',LE_COMP_YEAR,' (long) ',                *
               ' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,                *
               ':',LE_COMP_SEC,INTO=RECORD
         CLI   LE_SWITCH,C'3'    VS/COBOL ?
         BNE   JUMP_AROUND_2       no, go ahead
         STRING 'Date: ',LE_COMP_DAY,'.',LE_COMP_MONTH,'.',            *
               LE_COMP_YEAR,' Time: ',LE_COMP_HOURS,':',LE_COMP_MIN,   *
               ':',LE_COMP_SEC,INTO=RECORD
         BAL   R14,SPACE2
         B     INFO_COBOL            sorry no more information
JUMP_AROUND_2 DS 0H
         BAL   R14,SPACE2
         STRING '============ Statistics ============================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING 'Number of data items  : ',(LE_DATA_STATEMENTS,F,R7B), *
               INTO=RECORD
         BAL   R14,SPACE1
         STRING 'Number of instructions: ',(LE_PROC_LINES,F,R7B),      *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING '============ Options in effect =====================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         MVC   RECORD,BLANKS
         LA    R15,RECORD
         MVC   1(3,R15),=C'ADV'
         TM    LE_STATUS_BYTE_01,BIT0
         BO    *+10
         MVC   1(5,R15),=C'NOADV'
         LA    R15,8(R15)
         MVC   0(5,R15),=C'APOST'
         TM    LE_STATUS_BYTE_01,BIT1
         BO    *+10
         MVC   0(5,R15),=C'QUOTE'
         LA    R15,8(R15)
         MVC   RECORD+16(9),=CL9'DATA(31)'
         TM    LE_STATUS_BYTE_01,BIT2
         BO    *+10
         MVC   RECORD+16(9),=CL9'DATA(24)'
         MVC   RECORD+25(6),=CL6'DECK'
         TM    LE_STATUS_BYTE_01,BIT3
         BO    *+10
         MVC   RECORD+25(6),=CL6'NODECK'
         MVC   RECORD+33(6),=CL6'DUMP'
         TM    LE_STATUS_BYTE_01,BIT4
         BO    *+10
         MVC   RECORD+33(6),=CL6'NODUMP'
         MVC   RECORD+40(8),=CL8'DYNAM'
         TM    LE_STATUS_BYTE_01,BIT5
         BO    *+10
         MVC   RECORD+40(8),=CL8'NODYNAM'
         MVC   RECORD+51(10),=CL10'FASTSRT'
         TM    LE_STATUS_BYTE_01,BIT6
         BO    *+10
         MVC   RECORD+51(10),=CL10'NOFASTSRT'
         MVC   RECORD+62(8),=CL8'FDUMP'
         TM    LE_STATUS_BYTE_01,BIT7
         BO    *+10
         MVC   RECORD+62(8),=CL8'NOFDUMP'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(6),=CL6'LIB'
         TM    LE_STATUS_BYTE_02,BIT0
         BO    *+10
         MVC   RECORD+1(6),=CL6'NOLIB'
         MVC   RECORD+8(7),=CL7'LIST'
         TM    LE_STATUS_BYTE_02,BIT1
         BO    *+10
         MVC   RECORD+8(7),=CL7'NOLIST'
         MVC   RECORD+16(9),=CL9'MAP'
         TM    LE_STATUS_BYTE_02,BIT2
         BO    *+10
         MVC   RECORD+16(9),=CL9'NOMAP'
         MVC   RECORD+25(6),=CL6'NUM'
         TM    LE_STATUS_BYTE_02,BIT3
         BO    *+10
         MVC   RECORD+25(6),=CL6'NONUM'
         MVC   RECORD+33(6),=CL6'OBJ'
         TM    LE_STATUS_BYTE_02,BIT4
         BO    *+10
         MVC   RECORD+33(6),=CL6'NOOBJ'
         MVC   RECORD+40(8),=CL8'OFFSET'
         TM    LE_STATUS_BYTE_02,BIT5
         BO    *+10
         MVC   RECORD+40(8),=CL8'NOOFFSET'
         MVC   RECORD+51(10),=CL10'OPTIMIZE'
         TM    LE_STATUS_BYTE_02,BIT6
         BO    *+10
         MVC   RECORD+51(10),=CL10'NOOPTIMIZE'
         MVC   RECORD+62(17),=CL17'DDNAME(no Default)'
         TM    LE_STATUS_BYTE_02,BIT7
         BO    *+10
         MVC   RECORD+62(17),=CL17'DDNAME(Default)'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(15),=CL15'NUMPROC(MIG)'
         TM    LE_STATUS_BYTE_05,BIT0
         BO    LE_370_21
         MVC   RECORD+1(15),=CL15'NUMPROC(PFD)'
         TM    LE_STATUS_BYTE_03,BIT0
         BO    *+10
         MVC   RECORD+1(15),=CL15'NUMPROC(NOPFD)'
LE_370_21 DS 0H
         MVC   RECORD+16(7),=CL7'RENT'
         TM    LE_STATUS_BYTE_03,BIT1
         BO    *+10
         MVC   RECORD+16(7),=CL7'NORENT'
         MVC   RECORD+25(6),=CL6'RES'
         TM    LE_STATUS_BYTE_03,BIT2
         BO    *+10
         MVC   RECORD+25(6),=CL6'NORES'
         MVC   RECORD+33(6),=CL6'SEQ'
         TM    LE_STATUS_BYTE_03,BIT3
         BO    *+10
         MVC   RECORD+33(6),=CL6'NOSEQ'
         MVC   RECORD+40(12),=CL12'SIZE(MAX)'
         TM    LE_STATUS_BYTE_03,BIT4
         BO    *+10
         MVC   RECORD+40(12),=CL12'SIZE(value)'
         MVC   RECORD+51(9),=CL9'SOURCE'
         TM    LE_STATUS_BYTE_03,BIT5
         BO    *+10
         MVC   RECORD+51(9),=CL9'NOSOURCE'
         MVC   RECORD+62(10),=CL10'SSRANGE'
         TM    LE_STATUS_BYTE_03,BIT6
         BO    *+10
         MVC   RECORD+62(10),=CL10'NOSSRANGE'
         MVC   RECORD+72(8),=CL8'TERM'
         TM    LE_STATUS_BYTE_03,BIT7
         BO    *+10
         MVC   RECORD+72(8),=CL8'NOTERM'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(8),=CL8'TEST'
         TM    LE_STATUS_BYTE_04,BIT0
         BO    *+10
         MVC   RECORD+1(8),=CL8'NOTEST'
         MVC   RECORD+8(10),=CL11'TRUNC(BIN)'
         TM    LE_STATUS_BYTE_05,BIT4
         BO    LE_370_33
         MVC   RECORD+8(10),=CL11'TRUNC(STD)'
         TM    LE_STATUS_BYTE_04,BIT1
         BO    *+10
         MVC   RECORD+8(10),=CL11'TRUNC(OPT)'
LE_370_33 DS 0H
         MVC   RECORD+25(8),=CL8'VBREF'
         TM    LE_STATUS_BYTE_04,BIT3
         BO    *+10
         MVC   RECORD+25(8),=CL8'NOVBREF'
         MVC   RECORD+33(6),=CL6'XREF'
         TM    LE_STATUS_BYTE_04,BIT4
         BO    *+10
         MVC   RECORD+33(6),=CL6'NOXREF'
         MVC   RECORD+40(6),=CL6'ZWB'
         TM    LE_STATUS_BYTE_04,BIT5
         BO    *+10
         MVC   RECORD+40(6),=CL6'NOZWB'
         MVC   RECORD+51(7),=CL7'NAME'
         TM    LE_STATUS_BYTE_04,BIT6
         BO    *+10
         MVC   RECORD+51(7),=CL7'NONAME'
         MVC   RECORD+62(8),=CL8'CMPR2'
         TM    LE_STATUS_BYTE_04,BIT7
         BO    *+10
         MVC   RECORD+62(8),=CL8'NOCMPR2'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(12),=CL12'NUMCLS'  other Cobol
         TM    LE_STATUS_BYTE_05,BIT1
         BO    *+10
         MVC   RECORD+1(12),=CL12'NONUMCLS'
         CLI   LE_SWITCH,C'1'   COBOL/370
         BNE   LE_370_42
         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM
         BL    LE_370_42             yes
         MVC   RECORD+1(12),=CL12'NUMCLS(ALT)'
         TM    LE_STATUS_BYTE_05,BIT1
         BO    *+10
         MVC   RECORD+1(12),=CL12'NUMCLS(PRIM)'
LE_370_42 DS 0H
         MVC   RECORD+16(7),=CL7'DBCS'
         TM    LE_STATUS_BYTE_05,BIT2
         BO    *+10
         MVC   RECORD+16(7),=CL7'NODBCS'
         MVC   RECORD+25(6),=CL6'AWO'
         TM    LE_STATUS_BYTE_05,BIT3
         BO    *+10
         MVC   RECORD+25(6),=CL6'NOAWO'
         CLI   LE_SWITCH,C'1'                  Cobol/370
         BNE   LE_370_48                       no, jump around
         MVC   RECORD+33(9),=CL9'EVENTS'       n/a COBOL/2
         TM    LE_STATUS_BYTE_05,BIT5
         BO    *+10
         MVC   RECORD+33(9),=CL9'NOEVENTS'
         MVC   RECORD+51(11),=CL11'CURRENCY'   n/a COBOL/2
         TM    LE_STATUS_BYTE_05,BIT6
         BO    *+10
         MVC   RECORD+51(11),=CL11'NOCURRENCY'
LE_370_48 DS 0H
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(40),=CL40'Compilation unit = Class'
         TM    LE_STATUS_BYTE_05,BIT7
         BO    *+10
         MVC   RECORD+1(40),=CL40'Compilation unit = Program'
         BAL   R14,SPACE1
         MVC   RECORD+1(40),=CL40'User supplied reserved word list'
         TM    LE_STATUS_BYTE_04,BIT2
         BO    *+10
         MVC   RECORD+1(40),=CL40'Installation default res. word list'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         CLI   LE_SWITCH,C'1'   COBOL/370 ?
         BNE   LE_370_50Z         no
         CLC   LE_VERS(4),=C'0102'  Vers+Rel < 0102 COBOL MVS and VM
         BL    LE_370_50Z         no
*                         Supportet only for COBOL MVS and VM R2
         MVC   RECORD+1(11),=CL11'RMODE(ANY)'
         TM    LE_STATUS_BYTE_26,BIT0
         BO    *+10
         MVC   RECORD+1(11),=CL11'RMODE(24)'
         MVC   RECORD+16(13),=CL13'TEST(STMT)'
         TM    LE_STATUS_BYTE_26,BIT1
         BO    *+10
         MVC   RECORD+16(13),=CL13'NO TEST(STMT)'
         MVC   RECORD+33(13),=CL13'TEST(PATH)'
         TM    LE_STATUS_BYTE_26,BIT2
         BO    *+10
         MVC   RECORD+33(13),=CL13'NO TEST(PATH)'
         MVC   RECORD+51(14),=CL14'TEST(BLOCK)'
         TM    LE_STATUS_BYTE_26,BIT3
         BO    *+10
         MVC   RECORD+51(14),=CL14'NO TEST(BLOCK)'
         MVC   RECORD+72(17),=CL17'OPT(FULL)'
         TM    LE_STATUS_BYTE_26,BIT4
         BO    *+10
         MVC   RECORD+72(17),=CL17'NOOPT OR OPT(STD)'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(13),=CL13'INTDATE(LIL)'
         TM    LE_STATUS_BYTE_26,BIT5
         BO    *+10
         MVC   RECORD+1(13),=CL13'INTDATE(ANSI)'
         MVC   RECORD+16(22),=CL22'PGMNAME(LONGUPPER)'
         TM    LE_STATUS_BYTE_27,BIT0
         BO    *+10
         MVC   RECORD+16(22),=CL22'NOT PGMNAME(LONGUPPER)'
         MVC   RECORD+40(22),=CL22'PGMNAME(LONGMIXED)'
         TM    LE_STATUS_BYTE_27,BIT1
         BO    *+10
         MVC   RECORD+40(22),=CL22'NOT PGMNAME(LONGMIXED)'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(5),=CL5'DLL'
         TM    LE_STATUS_BYTE_27,BIT2
         BO    *+10
         MVC   RECORD+1(5),=CL5'NODLL'
         MVC   RECORD+16(11),=CL11'EXPORTALL'
         TM    LE_STATUS_BYTE_27,BIT3
         BO    *+10
         MVC   RECORD+16(11),=CL11'NOEXPORTALL'
         MVC   RECORD+33(10),=CL10'DATEPROC'
         TM    LE_STATUS_BYTE_27,BIT4
         BO    *+10
         MVC   RECORD+33(10),=CL10'NODATEPROC'
         STRING 'YEARWINDOW(',(LE_YEAR_WINDOW,H,R4B),')',INTO=RECORD+51
LE_370_50Z DS 0H
         BAL   R14,SPACE2
         STRING '============ Additional information ================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE1
         STRING '============ about DATA DIVISION    ================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING 'Program use no QSAM or SAM access method',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT0
         BNO   LE_370_51
         STRING 'Program use QSAM or SAM access',INTO=RECORD
LE_370_51 DS 0H
         BAL   R14,SPACE1
         STRING 'Program use no VSAM sequential files',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT1
         BNO   LE_370_52
         STRING 'Program use VSAM sequential files',INTO=RECORD
LE_370_52 DS 0H
         BAL   R14,SPACE1
         STRING 'Program use no VSAM indexed files',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT2
         BNO   LE_370_53
         STRING 'Program use VSAM indexed files',INTO=RECORD
LE_370_53 DS 0H
         BAL   R14,SPACE1
         STRING 'Program use no VSAM rba files',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT3
         BNO   LE_370_54
         STRING 'Program use VSAM rba files',INTO=RECORD
LE_370_54 DS 0H
         BAL   R14,SPACE1
         STRING 'Program use no CODE-SET (ASCII files)',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT4
         BNO   LE_370_55
         STRING 'Program use CODE-SET (ASCII files)',INTO=RECORD
LE_370_55 DS 0H
         BAL   R14,SPACE1
         STRING 'Program use no spanned records',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT5
         BNO   LE_370_56
         STRING 'Program use spanned receords',INTO=RECORD
LE_370_56 DS 0H
         BAL   R14,SPACE1
         STRING 'Program has no picture G (DBCS) items',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT6
         BNO   LE_370_57
         STRING 'Program has picture G (DBCS) items',INTO=RECORD
LE_370_57 DS 0H
         BAL   R14,SPACE1
         STRING 'Program has no OCCURS DEPENDING ON items',INTO=RECORD
         TM    LE_STATUS_BYTE_06,BIT7
         BNO   LE_370_58
         STRING 'Program has OCCURS DEPENDING ON items',INTO=RECORD
LE_370_58 DS 0H
         BAL   R14,SPACE1
         STRING 'Program has no SYNCHRONIZED clause',INTO=RECORD
         TM    LE_STATUS_BYTE_07,BIT0
         BNO   LE_370_59
         STRING 'Program has SYNCHRONIZED clause',INTO=RECORD
LE_370_59 DS 0H
         BAL   R14,SPACE1
         STRING 'Program has no JUSTIFIED clause',INTO=RECORD
         TM    LE_STATUS_BYTE_07,BIT1
         BNO   LE_370_60
         STRING 'Program has JUSTIFIED clause',INTO=RECORD
LE_370_60 DS 0H
         BAL   R14,SPACE1
         STRING 'Program has no POINTER items',INTO=RECORD
         TM    LE_STATUS_BYTE_07,BIT2
         BNO   LE_370_61
         STRING 'Program has POINTER items',INTO=RECORD
LE_370_61 DS 0H
         BAL   R14,SPACE1
         STRING 'Program has no complex ODO clause',INTO=RECORD
         TM    LE_STATUS_BYTE_07,BIT3
         BNO   LE_370_62
         STRING 'Program has complex ODO clause',INTO=RECORD
LE_370_62 DS 0H
         BAL   R14,SPACE1
         STRING 'Program has no external floating-point items',        *
               INTO=RECORD
         TM    LE_STATUS_BYTE_07,BIT4
         BNO   LE_370_63
         STRING 'Program has external floating-point items',INTO=RECORD
LE_370_63 DS 0H
         CLI   LE_SWITCH,C'1'                  Cobol/370
         BNE   LE_370_64                       no, jump around
         BAL   R14,SPACE1
         STRING 'Program has no procedure-pointer items',INTO=RECORD
         TM    LE_STATUS_BYTE_07,BIT6          n/a cobol/2 or VS/COBOL
         BNO   LE_370_64
         STRING 'Program has procedure-pointer items',INTO=RECORD
LE_370_64 DS 0H
         BAL   R14,SPACE2
         STRING '============ Additional information    =============',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE1
         STRING '============ about ENVIROMENT DIVISION =============',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING 'Program use no FILE-STATUS clause',INTO=RECORD
         TM    LE_STATUS_BYTE_08,BIT0
         BNO   LE_370_66
         STRING 'Program use FILE-STATUS clause',INTO=RECORD
LE_370_66 DS 0H
         BAL   R14,SPACE1
         STRING 'Program use no RERUN clause in I/O-control',          *
               INTO=RECORD
         TM    LE_STATUS_BYTE_08,BIT1
         BNO   LE_370_67
         STRING 'Program has RERUN clause in I/O-control',INTO=RECORD
LE_370_67 DS 0H
         BAL   R14,SPACE1
         STRING 'Program use no UPSI switches',INTO=RECORD
         TM    LE_STATUS_BYTE_08,BIT2
         BNO   LE_370_68
         STRING 'Program use UPSI switches',INTO=RECORD
LE_370_68 DS 0H
         BAL   R14,SPACE2
         STRING '============ Additional information    =============',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE1
         STRING '============ about PROCEDURE DIVISION  =============',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING 'Following statements in control (check Y/N):',        *
               INTO=RECORD
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(6),=CL6'Accept'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_09,BIT0
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(3),=CL3'Add'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_09,BIT1
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(5),=CL5'Alter'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_09,BIT2
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(4),=CL4'Call'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_09,BIT3
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(6),=CL6'Cancel'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_09,BIT4
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(5),=CL5'Close'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_09,BIT7
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(7),=CL7'Compute'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_10,BIT0
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(6),=CL6'Delete'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_10,BIT2
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(7),=CL7'Display'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_10,BIT4
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(6),=CL6'Divide'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_10,BIT5
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(11),=CL11'End-Perform'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_11,BIT1
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(5),=CL5'Enter'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_11,BIT2
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(5),=CL5'Entry'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_11,BIT3
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(4),=CL4'Exit'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_11,BIT4
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(5),=CL5'Go to'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_11,BIT6
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(2),=CL2'If'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_11,BIT7
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(10),=CL10'Initialize'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_12,BIT0
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(7),=CL7'Inspect'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_12,BIT2
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(5),=CL5'Merge'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_12,BIT3
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(4),=CL4'Move'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_12,BIT4
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(8),=CL8'Multiply'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_12,BIT5
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(4),=CL4'Open'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_12,BIT6
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(7),=CL7'Perform'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_12,BIT7
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(4),=CL4'Read'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_13,BIT0
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(7),=CL7'Release'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_13,BIT2
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(6),=CL6'Return'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_13,BIT3
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(7),=CL7'Rewrite'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_13,BIT4
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(6),=CL6'Search'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_13,BIT5
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(3),=CL3'Set'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_13,BIT7
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(4),=CL4'Sort'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_14,BIT0
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(5),=CL5'Start'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_14,BIT1
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(4),=CL4'Stop'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_14,BIT2
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(6),=CL6'String'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_14,BIT3
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(4),=CL8'Subtract'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_14,BIT4
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(8),=CL8'Unstring'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_14,BIT7
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(3),=CL3'Use'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_15,BIT0
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(5),=CL5'Write'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_15,BIT1
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(8),=CL8'Continue'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_15,BIT2
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(7),=CL7'End-Add'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_15,BIT3
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(7),=CL7'End-Call'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_15,BIT4
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(11),=CL11'End-Compute'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_15,BIT5
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(10),=CL10'End-Delete'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_15,BIT6
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(10),=CL10'End-Divide'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_15,BIT7
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(12),=CL12'End-Evaluate'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_16,BIT0
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(6),=CL6'End-If'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_16,BIT1
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(11),=CL11'End-Muliply'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_16,BIT2
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(8),=CL8'End-Read'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_16,BIT3
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(10),=CL10'End-Return'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_16,BIT4
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(11),=CL11'End-Rewrite'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_16,BIT5
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(10),=CL10'End-Search'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_16,BIT6
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(9),=CL9'End-Start'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_16,BIT7
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(10),=CL10'End-String'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_17,BIT0
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(13),=CL13'End-Substract'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_17,BIT1
         BNO   *+8
         MVI   RECORD+83,C'Y'
         MVC   RECORD+86(12),=CL12'End-Unstring'
         MVI   RECORD+100,C'N'
         TM    LE_STATUS_BYTE_17,BIT2
         BNO   *+8
         MVI   RECORD+100,C'Y'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(9),=CL9'End-Write'
         MVI   RECORD+15,C'N'
         TM    LE_STATUS_BYTE_17,BIT3
         BNO   *+8
         MVI   RECORD+15,C'Y'
         MVC   RECORD+18(6),=CL6'Goback'
         MVI   RECORD+32,C'N'
         TM    LE_STATUS_BYTE_17,BIT4
         BNO   *+8
         MVI   RECORD+32,C'Y'
         MVC   RECORD+35(9),=CL9'Evaluate'
         MVI   RECORD+49,C'N'
         TM    LE_STATUS_BYTE_17,BIT5
         BNO   *+8
         MVI   RECORD+49,C'Y'
         MVC   RECORD+52(7),=CL7'Service'
         MVI   RECORD+66,C'N'
         TM    LE_STATUS_BYTE_17,BIT7
         BNO   *+8
         MVI   RECORD+66,C'Y'
         MVC   RECORD+69(10),=CL10'End-Invoke'
         MVI   RECORD+83,C'N'
         TM    LE_STATUS_BYTE_18,BIT0
         BNO   *+8
         MVI   RECORD+83,C'Y'
         BAL   R14,SPACE1
         STRING '====================================================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         STRING 'Procedure has no hexadecimal literals',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT0
         BNO   LE_370_128
         STRING 'Procedure include hexadecimal literals',INTO=RECORD
LE_370_128 DS 0H
         BAL   R14,SPACE1
         STRING 'No altered GO TO',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT1
         BNO   LE_370_129
         STRING 'Program contains altered GO TO',INTO=RECORD
LE_370_129 DS 0H
         BAL   R14,SPACE1
         STRING 'No I/O error declarative',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT2
         BNO   LE_370_130
         STRING 'I/O error declarative',INTO=RECORD
LE_370_130 DS 0H
         BAL   R14,SPACE1
         STRING 'No Label declarative',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT3
         BNO   LE_370_131
         STRING 'Label declarative',INTO=RECORD
LE_370_131 DS 0H
         BAL   R14,SPACE1
         STRING 'No debugging declarative',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT4
         BNO   LE_370_132
         STRING 'Debugging declarative',INTO=RECORD
LE_370_132 DS 0H
         BAL   R14,SPACE1
         STRING 'No program segmentation',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT5
         BNO   LE_370_133
         STRING 'Programm segmentation',INTO=RECORD
LE_370_133 DS 0H
         BAL   R14,SPACE1
         STRING 'No Open Extend',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT6
         BNO   LE_370_134
         STRING 'Open Extend',INTO=RECORD
LE_370_134 DS 0H
         BAL   R14,SPACE1
         STRING 'No exit program',INTO=RECORD
         TM    LE_STATUS_BYTE_21,BIT7
         BNO   LE_370_135
         STRING 'Exit Program',INTO=RECORD
LE_370_135 DS 0H
         BAL   R14,SPACE1
         STRING 'No call literal',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT0
         BNO   LE_370_136
         STRING 'Call literal (static?), see options',INTO=RECORD
LE_370_136 DS 0H
         BAL   R14,SPACE1
         STRING 'No call identifier',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT1
         BNO   LE_370_137
         STRING 'Call identifier',INTO=RECORD
LE_370_137 DS 0H
         BAL   R14,SPACE1
         STRING 'No call on overflow',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT2
         BNO   LE_370_138
         STRING 'Call on overflow',INTO=RECORD
LE_370_138 DS 0H
         BAL   R14,SPACE1
         STRING 'No call length of',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT3
         BNO   LE_370_139
         STRING 'Call length of',INTO=RECORD
LE_370_139 DS 0H
         BAL   R14,SPACE1
         STRING 'No call address of',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT4
         BNO   LE_370_140
         STRING 'Call address',INTO=RECORD
LE_370_140 DS 0H
         BAL   R14,SPACE1
         STRING 'No close reel/unit',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT5
         BNO   LE_370_141
         STRING 'Close reel/unit',INTO=RECORD
LE_370_141 DS 0H
         BAL   R14,SPACE1
         STRING 'No exponentiation used',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT6
         BNO   LE_370_142
         STRING 'Exponentiation used',INTO=RECORD
LE_370_142 DS 0H
         BAL   R14,SPACE1
         STRING 'No floating point items used',INTO=RECORD
         TM    LE_STATUS_BYTE_22,BIT7
         BNO   LE_370_143
         STRING 'Floating point items used',INTO=RECORD
LE_370_143 DS 0H
         BAL   R14,SPACE1
         STRING 'No Copy-Statements',INTO=RECORD
         TM    LE_STATUS_BYTE_23,BIT0
         BNO   LE_370_144
         STRING 'Copy-Statements used',INTO=RECORD
LE_370_144 DS 0H
         BAL   R14,SPACE1
         STRING 'No Basis-Statements',INTO=RECORD
         TM    LE_STATUS_BYTE_23,BIT1
         BNO   LE_370_145
         STRING 'Basis-Statements used',INTO=RECORD
LE_370_145 DS 0H
         BAL   R14,SPACE1
         STRING 'No DBCS-Name in Program',INTO=RECORD
         TM    LE_STATUS_BYTE_23,BIT2
         BNO   LE_370_146
         STRING 'DBCS-Name in Program',INTO=RECORD
LE_370_146 DS 0H
         BAL   R14,SPACE1
         STRING 'No Shift-In/Shift-Out',INTO=RECORD
         TM    LE_STATUS_BYTE_23,BIT3
         BNO   LE_370_147
         STRING 'Shift-In/Shift-Out',INTO=RECORD
LE_370_147 DS 0H
         BAL   R14,SPACE1
         STRING 'No DBCS literal',INTO=RECORD
         TM    LE_STATUS_BYTE_24,BIT0
         BNO   LE_370_148
         STRING 'DBCS literal',INTO=RECORD
LE_370_148 DS 0H
         BAL   R14,SPACE1
         STRING '============ End  ==================================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         LA    R15,0
         B     COBANAL_EXIT
INFO_COBOL DS 0H
         STRING '============ Options in effect =====================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         MVC   RECORD,BLANKS
         MVC   RECORD+1(8),=CL8'SYMDMP'
         TM    C1_STATUS_BYTE_01,X'08'
         BO    *+10
         MVC   RECORD+1(8),=CL8'NOSYMDMP'
         MVC   RECORD+10(6),=CL6'FLOW'
         TM    C1_STATUS_BYTE_01,X'04'
         BO    *+10
         MVC   RECORD+10(6),=CL6'NOFLOW'
         MVC   RECORD+17(7),=CL7'STATE'
         TM    C1_STATUS_BYTE_01,X'02'
         BO    *+10
         MVC   RECORD+17(7),=CL7'NOSTATE'
         MVC   RECORD+25(6),=CL6'OPT'
         TM    C1_STATUS_BYTE_01,X'01'
         BO    *+10
         MVC   RECORD+25(6),=CL6'NOOPT'
         MVC   RECORD+32(6),=CL6'TEST'
         TM    C1_STATUS_BYTE_02,X'10'
         BO    *+10
         MVC   RECORD+32(6),=CL6'NOTEST'
         MVC   RECORD+39(6),=CL6'RES'
         TM    C1_STATUS_BYTE_03,X'80'
         BO    *+10
         MVC   RECORD+39(6),=CL6'NORES'
         MVC   RECORD+46(8),=CL8'ENDJOB'
         TM    C1_STATUS_BYTE_03,X'40'
         BO    *+10
         MVC   RECORD+46(8),=CL8'NOENDJOB'
         MVC   RECORD+55(8),=CL8'OBJ370'
         TM    C1_STATUS_BYTE_03,X'20'
         BO    *+10
         MVC   RECORD+55(8),=CL8'NOOBJ370'
         MVC   RECORD+64(8),=CL8'COUNT'
         TM    C1_STATUS_BYTE_03,X'08'
         BO    *+10
         MVC   RECORD+64(8),=CL8'NOCOUNT'
         BAL   R14,SPACE1
         MVC   RECORD,BLANKS
         MVC   RECORD+1(11),=CL11'READY TRACE'
         TM    C1_STATUS_BYTE_03,X'04'
         BO    *+10
         MVC   RECORD+1(11),=CL11'NO TRACE'
         BAL   R14,SPACE1
         STRING 'Sorry no more infomation for VS/COBOL',INTO=RECORD
         BAL   R14,SPACE1
         STRING 'You better upgrade to COBOL for OS/390 (MVS) and VM', *
               INTO=RECORD
         BAL   R14,SPACE1
         STRING '============ End  ==================================',*
               '=============================================',        *
               INTO=RECORD
         BAL   R14,SPACE2
         LA    R15,0
         B     COBANAL_EXIT
*============================================================*
* Print                                                      *
*============================================================*
SPACE2   DS 0H
         ST    R14,SAVER14
         BAS   R14,AMODE24             AMode24
         PUT   SYSPRINT,RECORD
         PUT   SYSPRINT,BLANKS
         BAS   R14,AMODE31             AMode31
         L     R14,SAVER14
         BR    R14            return
SPACE1   DS 0H
         ST    R14,SAVER14
         PUT   SYSPRINT,RECORD
         L     R14,SAVER14
         BR    R14            return
***************************************************************
*
*                  get Member Name from PDS-Directory
*
***************************************************************
GETMEM   EQU   *
         ST    R14,GETMSAVE            save return address
         L     R4,ADBLKPTR             restore pointer
         CLC   DIRAREA(2),=XL2'0000'   Directory present?
         BNE   NEWNAME                   yes, get next
NEWBLOCK EQU   *
         BAS   R14,AMODE24             Amode24
         GET   INPUT,DIRAREA           get a new directory
         BAS   R14,AMODE31             Amode24
         LA    R4,DIRAREA              get work area address
         AH    R4,DIRAREA              + length
         ST    R4,ADBLKEND             save ending address
         LA    R4,DIRAREA+2            Skip LL bytes
         ST    R4,ADBLKPTR             save pointer
NEWNAME  EQU   *
         C     R4,ADBLKEND             end of current dir block
         BNL   NEWBLOCK                  yes, get new block
         MVC   PGMNAME,0(R4)           Save member-name
         IC    R5,11(R4)               LOOK FOR ANY USER TTRN'S
         SLL   R5,27                   SHIFT OFF UNWANTED BITS
         SRL   R5,26                   SHIFT BACK THE USABLE BI
         LA    R4,12(R4,R5)            ADD DISPL TO GET OVER TT
         ST    R4,ADBLKPTR             save Pointer next mem
         L     R14,GETMSAVE            restore return address
         BR    R14                     goback
AMODE24  LA    R14,0(,R14)             remove XA bit
         BSM   R0,R14                  return
         SPACE 2
AMODE31  O     R14,HIBIT               add XA bit
         BSM   R0,R14                  return
*
*============================================================*
* SONSTIGE DEFINITIONS                                       *
*============================================================*
****************************** CONSTANTS *****************************
C_COBOL370 DC X'00',C'CEE'                   COBOL/370 ?  X'00C3C5C5'
HIBIT    DC    A(X'80000000')         XA BIT CONSTANS
BLANKS   DC    CL255' '           just blanks
XFF      DC    XL8'FFFFFFFFFFFFFFFF' just High-value
SYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121
INPUT    DCB   DSORG=PS,          PDS but we read only the directory   *
               DDNAME=COBANAL,    DDNAME                               *
               BLKSIZE=256,                                            *
               RECFM=U,                                                *
               MACRF=(GM)         Read only
*
*============================================================*
* Workarea                                                   *
*============================================================*
COBANAL_WORK        DSECT
EYECATCHER          DS    CL8   'COBANAL'
PGMNAME             DS    CL8   Pgmname from the parmlist
ADR_COBANAL_WORK    DS    F     Save Workarea pointer
ADR_COBANAL_PARM    DS    F     Save Parmlist pointer
ADR_PGMNAME         DS    F     Save entry-point Application PGM
RC_PGMNAME          DS    F     Save application RC
PARM_LENGTH         DS    H     Parm length wihout header
GETMSAVE            DS    F     Parm length wihout header
ADBLKPTR            DS    F     Parm length wihout header
ADBLKEND            DS    F     Parm length wihout header
DIRAREA             DS    XL256 PDS-Directory input area
DOALL               DS    CL1   Analyze a complete loadlib
CSV_LENGTH          DS    F     Length returned by CSVQuery
         CSVQUERY MF=(L,CSVQRYWK)
****************************** VARIABLES *****************************
LE_SWITCH           DS    CL1   Switch for COBOL/370 or COBOL/2
LE_PGM_NAME         DS CL8  name of program
LE_COMP_YEAR        DS CL4  year of compilation
*  3 bytes because of VS/COBOL
LE_COMP_MONTH       DS CL3  month of compilation
LE_COMP_DAY         DS CL2  day of compilation
LE_COMP_HOURS       DS CL2  hours of compilation
LE_COMP_MIN         DS CL2  minutes of compilation
LE_COMP_SEC         DS CL2  seconds of compilation
LE_VERS             DS CL2  version
LE_REL              DS CL2  release
LE_MOD              DS CL2  modification level
LE_STATUS_BYTE      DS    0C   signature bytes
LE_STATUS_BYTE_01   DS X    status byte
LE_STATUS_BYTE_02   DS X    status byte
LE_STATUS_BYTE_03   DS X    status byte
LE_STATUS_BYTE_04   DS X    status byte
LE_STATUS_BYTE_05   DS X    status byte
LE_STATUS_BYTE_06   DS X    status byte
LE_STATUS_BYTE_07   DS X    status byte
LE_STATUS_BYTE_08   DS X    status byte
LE_STATUS_BYTE_09   DS X    status byte
LE_STATUS_BYTE_10   DS X    status byte
LE_STATUS_BYTE_11   DS X    status byte
LE_STATUS_BYTE_12   DS X    status byte
LE_STATUS_BYTE_13   DS X    status byte
LE_STATUS_BYTE_14   DS X    status byte
LE_STATUS_BYTE_15   DS X    status byte
LE_STATUS_BYTE_16   DS X    status byte
LE_STATUS_BYTE_17   DS X    status byte
LE_STATUS_BYTE_18   DS X    status byte
LE_STATUS_BYTE_19   DS X    status byte
LE_STATUS_BYTE_20   DS X    status byte
LE_STATUS_BYTE_21   DS X    status byte
LE_STATUS_BYTE_22   DS X    status byte
LE_STATUS_BYTE_23   DS X    status byte
LE_STATUS_BYTE_24   DS X    status byte
LE_STATUS_BYTE_25   DS X    status byte
LE_STATUS_BYTE_26   DS X    status byte Cobol for MVS and VM
LE_STATUS_BYTE_27   DS X    status byte Cobol for MVS and VM
LE_COBOL_SIGNAT     DS X    cobol signature level
LE_DATA_STATEMENTS  DS XL4  number of data items
LE_PROC_LINES       DS XL4  number of proc statements
LE_YEAR_WINDOW      DS H    YearWindow
SAVEAREA            DS 18F
SAVER14             DS F
RECORD              DS CL132
COBANAL_WORK_LENGTH EQU *-COBANAL_WORK  Length workarea
*
*============================================================*
* Parameter (JCL)                                            *
*============================================================*
COBANAL_PARM        DSECT
COBANAL_PARM_LENGTH DS H
*
*
*============================================================*
* COBOL/370 DCL
*============================================================*
COBOL_370_DSECT     DSECT
                    DS CL4  bypass
CEE_EYECATCHER      DS CL4  excatcher
CEE_STACK_FRAME     DS F    stack frame size
CEE_PPA1_OFFSET     DS F    offset to first ppa1
                    DS CL4  reserved
CEE_PPA1_START      DS 0C
CEE_OFFSET          DS X    offset to length of name from ppa1
CEE_SIGNATURE       DS X    CEL-Signature
CEE_FLAG1           DS X    CEL-FLAGS Bitmask
CEE_FLAG2           DS X    Member Flags for Cobol
CEE_ADDRESS_OF_PPA2 DS F    Address of PPA2
CEE_OFFSET_DBI      DS F    Offset BDI (None)
CEE_EP_DESCRIPTOR   DS F    Entry Point Descriptor
CEE_STACK_OVERFLOW  DS F    Offset for Stack overflow
                    DS F    available word
                    DS F    available word
                    DS F    available word
                    DS F    available word
CEE_PRIMARY_EP      DS 0C
CEE_PRI_EP_ADDRESS  DS A    primary entry-point address
CEE_PGT_ADDRESS     DS A    PGT-Address
CEE_TGT_ADDRESS     DS A    PGT-Address
CEE_EP_NAME         DS A    Offset to entry_point_name
CEE_CURRENT_EP      DS A    current EP-Address
CEE_START           DS A    procedure code Address
CEE_INIT_PROG       DS A    Initialize Routine
CEE_PARM_LIST       DS A    Address of parm list for CEEINT
                    DS F    available word
                    DS H    available half-word
CEE_LENGTH_NAME     DS XL2  length of program_name
CEE_NAME_PART       DS 0C
CEE_PGM_NAME        DS CL8  name of programm
CEE_COMP_YEAR       DS CL4  year of compilation
CEE_COMP_MONTH      DS CL2  month of compilation
CEE_COMP_DAY        DS CL2  day of compilation
CEE_COMP_HOURS      DS CL2  hours of compilation
CEE_COMP_MIN        DS CL2  minutes of compilation
CEE_COMP_SEC        DS CL2  seconds of compilation
CEE_VERS            DS CL2  version
CEE_REL             DS CL2  release
CEE_MOD             DS CL2  modification level
                    DS F    available word
                    DS H
CEE_YEAR_WINDOW     DS H    YearWindow
CEE_STATUS_BYTE_01  DS X    status byte
CEE_STATUS_BYTE_02  DS X    status byte
CEE_STATUS_BYTE_03  DS X    status byte
CEE_STATUS_BYTE_04  DS X    status byte
CEE_STATUS_BYTE_05  DS X    status byte
CEE_STATUS_BYTE_06  DS X    status byte
CEE_STATUS_BYTE_07  DS X    status byte
CEE_STATUS_BYTE_08  DS X    status byte
CEE_STATUS_BYTE_09  DS X    status byte
CEE_STATUS_BYTE_10  DS X    status byte
CEE_STATUS_BYTE_11  DS X    status byte
CEE_STATUS_BYTE_12  DS X    status byte
CEE_STATUS_BYTE_13  DS X    status byte
CEE_STATUS_BYTE_14  DS X    status byte
CEE_STATUS_BYTE_15  DS X    status byte
CEE_STATUS_BYTE_16  DS X    status byte
CEE_STATUS_BYTE_17  DS X    status byte
CEE_STATUS_BYTE_18  DS X    status byte
CEE_STATUS_BYTE_19  DS X    status byte
CEE_STATUS_BYTE_20  DS X    status byte
CEE_STATUS_BYTE_21  DS X    status byte
CEE_STATUS_BYTE_22  DS X    status byte
CEE_STATUS_BYTE_23  DS X    status byte
CEE_COBOL_SIGNAT    DS X    cobol signature level
CEE_DATA_STATEMENTS DS XL4  number of data items
CEE_PROC_LINES      DS XL4  number of proc statements
CEE_STATUS_BYTE_24  DS X    status byte
CEE_STATUS_BYTE_25  DS X    status byte
CEE_STATUS_BYTE_26  DS X    status byte
CEE_STATUS_BYTE_27  DS X    status byte
*============================================================*
* COBOL2 DCL
*============================================================*
COBOL_2_DSECT      DSECT
                   DS CL4  bypass
                   DS X
C2_PGM_NAME        DS CL8  name of programm
C2_EYECATCHER      DS CL4  eyecatcher
C2_VERS            DS CL2  version
C2_REL             DS CL2  release
C2_MOD             DS CL2  modification level
C2_COMP_MONTH      DS CL2  month of compilation
                   DS CL1
C2_COMP_DAY        DS CL2  day of compilation
                   DS CL1
C2_COMP_YEAR       DS CL2  year of compilation
                   DS CL1
C2_COMP_HOURS      DS CL2  hours of compilation
                   DS CL1
C2_COMP_MIN        DS CL2  minutes of compilation
                   DS CL1
C2_COMP_SEC        DS CL2  seconds of compilation
C2_GET_ENTRY       DS A    Address of address
C2_STATUS_BYTE_01  DS X    status byte
C2_STATUS_BYTE_02  DS X    status byte
C2_STATUS_BYTE_03  DS X    status byte
C2_STATUS_BYTE_04  DS X    status byte
C2_STATUS_BYTE_05  DS X    status byte
C2_STATUS_BYTE_06  DS X    status byte
C2_STATUS_BYTE_07  DS X    status byte
C2_STATUS_BYTE_08  DS X    status byte
C2_STATUS_BYTE_09  DS X    status byte
C2_STATUS_BYTE_10  DS X    status byte
C2_STATUS_BYTE_11  DS X    status byte
C2_STATUS_BYTE_12  DS X    status byte
C2_STATUS_BYTE_13  DS X    status byte
C2_STATUS_BYTE_14  DS X    status byte
C2_STATUS_BYTE_15  DS X    status byte
C2_STATUS_BYTE_16  DS X    status byte
C2_STATUS_BYTE_17  DS X    status byte
C2_STATUS_BYTE_18  DS X    status byte
C2_STATUS_BYTE_19  DS X    status byte
C2_STATUS_BYTE_20  DS X    status byte
C2_STATUS_BYTE_21  DS X    status byte
C2_STATUS_BYTE_22  DS X    status byte
C2_STATUS_BYTE_23  DS X    status byte
                   DS X    cobol signature level
C2_DATA_STATEMENTS DS XL4  number of data items
C2_PROC_LINES      DS XL4  number of proc statements
C2_STATUS_BYTE_24  DS X    status byte
C2_STATUS_BYTE_25  DS X    status byte
                   DS XL2  status byte
                   DS CL4  status byte
C2_PRI_EP_ADDRESS  DS A    primary entry-point address
*
*============================================================*
* VS/COBOL
*============================================================*
COBOL_1_DSECT      DSECT
                   DS CL12 bypass
C1_PGM_NAME        DS CL8  name of programm
C1_EYECATCHER      DS CL2  eyecatcher
C1_REL             DS CL2  release
                   DS CL36
C1_TGT_PTR         DS F    pointer to tgt
                   DS CL72
*                  DS CL112
C1_COMP_HOURS      DS CL2  hours of compilation
                   DS CL1
C1_COMP_MIN        DS CL2  minutes of compilation
                   DS CL1
C1_COMP_SEC        DS CL2  seconds of compilation
C1_COMP_MONTH      DS CL3  month of compilation
                   DS CL1
C1_COMP_DAY        DS CL2  day of compilation
                   DS CL2
C1_COMP_YEAR       DS CL4  year of compilation
COBOL_1_TGT        DSECT
                   DS CL72 ?
C1_STATUS_BYTE_01  DS X    status byte
C1_STATUS_BYTE_02  DS X    status byte
C1_STATUS_BYTE_03  DS X    status byte
                   DS CL369
C1_CHECK           DS CL8  check TGT for SYSOUT
*
         STRING GENERATE
ADV      EQU   B'10000000'
APOST    EQU   B'01000000'
DATA31   EQU   B'00100000'
DECK     EQU   B'00010000'
DUMP     EQU   B'00001000'
DYNAM    EQU   B'00000100'
FASTSRT  EQU   B'00000010'
FDUMP    EQU   B'00000001'
LIB      EQU   B'10000000'
LIST     EQU   B'01000000'
MAP      EQU   B'00100000'
NUM      EQU   B'00010000'
OBJ      EQU   B'00001000'
OFFSET   EQU   B'00000100'
OPTIMIZE EQU   B'00000010'
DDNAME   EQU   B'00000001'
NUMPROC  EQU   B'10000000'
RENT     EQU   B'01000000'
RES      EQU   B'00100000'
SEQUENCE EQU   B'00010000'
SIZE     EQU   B'00001000'
SOURCE   EQU   B'00000100'
SSRANGE  EQU   B'00000010'
TERM     EQU   B'00000001'
TEST     EQU   B'10000000'
TRUNC    EQU   B'01000000'
USERW    EQU   B'00100000'
VBREF    EQU   B'00010000'
XREF     EQU   B'00001000'
ZWB      EQU   B'00000100'
NAME     EQU   B'00000010'
CMPR2    EQU   B'00000001'
NUMPROCM EQU   B'10000000'
NUMCLASS EQU   B'01000000'
DBCS     EQU   B'00100000'
AWO      EQU   B'00010000'
TRUNCB   EQU   B'00001000'
EVENTS   EQU   B'00000100'
CURRENCY EQU   B'00000010'
CO_UN_CL EQU   B'00000001'
BIT0     EQU   B'10000000'
BIT1     EQU   B'01000000'
BIT2     EQU   B'00100000'
BIT3     EQU   B'00010000'
BIT4     EQU   B'00001000'
BIT5     EQU   B'00000100'
BIT6     EQU   B'00000010'
BIT7     EQU   B'00000001'
*------------------------------------------------------------*
* Programm equates                                           *
*------------------------------------------------------------*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
./ ADD NAME=COBANL   0100-1999362-1999362-2220-00257-00257-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display Cobanl selection menu              */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

arg steplib  ,              /* steplib for cobanal pgm       */
    cobaappl ,              /* applname for coba application */
    cobahlq  ,              /* hlq for coba datasets         */
    llqclib  ,              /* llq for exec und clist        */
    llqmlib  ,              /* llq for mlib                  */
    llqplib  ,              /* llq for plib                  */
    llqslib  ,              /* llq for slib                  */
    llqtlib  ,              /* llq for tlib                  */
    llqtabl  ,              /* llq tabl                      */
    account  ,
    class    ,
    msgclass ,
    ispfhlq

"ISPEXEC VPUT (STEPLIB COBAAPPL COBAHLQ)"
"ISPEXEC VPUT (LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL)"
"ISPEXEC VPUT (ACCOUNT CLASS MSGCLASS ISPFHLQ)"

START:
"ISPEXEC DISPLAY PANEL(COBANL)"

IF RC = 12 × RC = 20
THEN do
  CALL COBA000 cobanl cobanl rc
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC TBEND COBANL00"
  "ISPEXEC TBEND COBANL01"
  "ISPEXEC TBEND COBANL02"
  "ISPEXEC TBEND COBANL03"
  "ISPEXEC TBEND COBANL04"
  EXIT
end


select
  when zcmd = 1
  then do
    mess1   = 'Please edit the follwoing JCL to your '
    mess2   = 'namings and submit the job'
    mess3   = 'For permant change edit member COBANAL'
    mess4   = 'in ISPSLIB dataset'
    "ISPEXEC ADDPOP ROW(03) COLUMN(10)"
    "ISPEXEC DISPLAY PANEL(COBA000)"
    IF ZCMD = TRACE
    THEN DO
      zcmd = ' '
      trace ?r
    end
    IF RC = 8
    THEN do
      "ISPEXEC TBEND COBANL00"
      "ISPEXEC TBEND COBANL01"
      "ISPEXEC TBEND COBANL02"
      "ISPEXEC TBEND COBANL03"
      "ISPEXEC TBEND COBANL04"
      "ISPEXEC REMPOP"
      signal start
    end
    mess    = 'please enter dsn of loadlib to analyse'
    "ISPEXEC REMPOP"
    "ISPEXEC ADDPOP ROW(03) COLUMN(10)"
    "ISPEXEC DISPLAY PANEL(COBANLLO)"
    IF ZCMD = TRACE
    THEN DO
      zcmd = ' '
      trace ?r
    end
    IF RC = 8
    THEN do
      "ISPEXEC TBEND COBANL00"
      "ISPEXEC TBEND COBANL01"
      "ISPEXEC TBEND COBANL02"
      "ISPEXEC TBEND COBANL03"
      "ISPEXEC TBEND COBANL04"
      "ISPEXEC REMPOP"
      signal start
    end
    "ISPEXEC REMPOP"
    "ISPEXEC ADDPOP ROW(03) COLUMN(10)"
    "ISPEXEC DISPLAY PANEL(COBANL04)"
    IF ZCMD = TRACE
    THEN DO
      zcmd = ' '
      trace ?r
    end
    IF RC = 8
    THEN do
      "ISPEXEC TBEND COBANL00"
      "ISPEXEC TBEND COBANL01"
      "ISPEXEC TBEND COBANL02"
      "ISPEXEC TBEND COBANL03"
      "ISPEXEC TBEND COBANL04"
      "ISPEXEC REMPOP"
      signal start
    end
    "ISPEXEC REMPOP"
    call cobasubp dsn t
  end
  when zcmd = 2 THEN CALL COBANLDS
  when zcmd = 3
  then do
    call open_tables
    sel = 'all cobol programs '
    tkey1   = 'PGMKEY'
    "ispexec vput tkey1"
    call cobanldt ALL ,
                  COBANL00 ,
                  COBANL01 ,
                  COBANL02 ,
                  COBANL00 ,
                  COBANLF0 ,
                  COBANLL0 ,
                  COBANLS0 ,
                  COBANL  ,
                  sel
  end
  when zcmd = 4
  then do
    call open_tables
    sel = 'all cobol compile options'
    tkey1   = 'OPTION'
    "ispexec vput tkey1"
    call cobanldt ALL ,
                  COBANL01 ,
                  COBANL00 ,
                  COBANL02 ,
                  COBANL01 ,
                  COBANLF1 ,
                  COBANLLI ,
                  COBANLS1 ,
                  COBANL  ,
                  sel
  end
  when zcmd = 5
  then do
    call open_tables
    sel = 'all cobol compiler versions'
    tkey1   = 'COBVERS'
    "ispexec vput tkey1"
    call cobanldt ALL ,
                  COBANL02 ,
                  COBANL00 ,
                  COBANL01 ,
                  COBANL02 ,
                  COBANLF2 ,
                  COBANLLI ,
                  COBANLS2 ,
                  COBANL  ,
                  sel
  end
  when zcmd = 6
  then do
    call open_tables
    sel = 'all procedure division statements'
    tkey1   = 'STMT'
    "ispexec vput tkey1"
    call cobanldt ALL ,
                  COBANL03 ,
                  COBANL00 ,
                  COBANL01 ,
                  COBANL07 ,
                  COBANLF3 ,
                  COBANLLI ,
                  COBANLS3 ,
                  COBANL  ,
                  sel
  end
  when zcmd = 7
  then do
    call open_tables
    sel = 'all analyzed loadlibs'
    tkey1   = 'LOADLIB'
    "ispexec vput tkey1"
    call cobanldt ALL ,
                  COBANL04 ,
                  COBANL00 ,
                  COBANL01 ,
                  COBANL09 ,
                  COBANLF2 ,
                  COBANLL9 ,
                  COBANLS2 ,
                  COBANL  ,
                  sel
  end
  when zcmd = 8
  then do
    call cobanlpg
  end
  when zcmd = 9
  then do
    call open_tables
    tkey1   = 'OPTION'
    "ispexec vput tkey1"
    call cobanl03
  end
  when zcmd = 10
  then do
    zcmd = isplibd
    "ispexec display panel(ispllsa) command(zcmd)"
  end
  when zcmd = 11
  then do
    call isrddn
  end
  when zcmd = 12
  then do
    zcmd = sarea
    "ispexec display panel(ispsammn) command(zcmd)"
  end
  when zcmd = 13
  then do
    call cobasysi
  end
  otherwise  signal start
end

SIGNAL START

EXIT

open_tables:

"ISPEXEC TBOPEN COBANL00 NOWRITE"
"ISPEXEC TBOPEN COBANL01 NOWRITE"
"ISPEXEC TBOPEN COBANL02 NOWRITE"
"ISPEXEC TBOPEN COBANL03 NOWRITE"
"ISPEXEC TBOPEN COBANL04 NOWRITE"

return

failures:
say  "line = " strip(sourceline(sigl))
say  "Cond = " condition('C') condition('D')
say  "Error= " errortext(rc)
exit
./ ADD NAME=COBANLBL 0100-1999348-1999348-1607-00577-00577-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : build cobanal tables                       */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

arg ptyp loadlib

say 'create analyse report started'
say 'parameter ptyp    = ' ptyp
say 'parameter loadlib = ' loadlib

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

DSNAME   = LISTDSI(COBANAL FILE)
dsname   = sysdsname

if SYSDSN("'"DSNAME"'") ^= 'OK'
then do
  say "DSN = " dsname " notfound"
  exit
end

"ISPEXEC EDIT DATASET('"dsname"') MACRO(COBA#MAC)"

/*----- Cobal tables -----------------------------*/
/*                                                */
/*    COBANL00 Table Programm information         */
/*    COBANL01 Table Option   information         */
/*    COBANL02 Table Compiler information         */
/*    COBANL03 Table procedur information         */
/*    COBANL04 Table loadlib  information         */
/*                                                */
/*------------------------------------------------*/

"ISPEXEC TBEND    COBANL00"
"ISPEXEC TBEND    COBANL01"
"ISPEXEC TBEND    COBANL02"
"ISPEXEC TBEND    COBANL03"
"ISPEXEC TBEND    COBANL04"

loadlib  = strip(loadlib,L,' ')

if ptyp  ^= 'E'
then do
  "ISPEXEC TBERASE  COBANL00"
  names = "COBREL COBVERS COMPREL COMPNAME COMPDATE COMPTIME ANZITEM ANZ
  names = names ×× "O1 O2 O3 O4 O5 O6 O7 O8 O9 O10 O11 O12 O13 O14 O15 O
  names = names ×× "O18 O19 O20 O21 O22 O23 O24 O25 O26 O27 O28 O29 O30
  names = names ×× "O32 O33 O34 O35 O36 "
  names = names ×× "P1 P2 P3 P4 P5 P6 P7 P8 P9 "
  names = names ×× "P10 P11 P12 P13 P14 P15 P16 P17 P18 P19 "
  names = names ×× "P20 P21 P22 P23 P24 P25 P26 P27 P28 P29 "
  names = names ×× "P30 P31 P32 P33 P34 P35 P36 P37 P38 P39 "
  names = names ×× "P40 P41 P42 P43 P44 P45 P46 P47 P48 P49 "
  names = names ×× "P50 P51 P52 P53 P54 P55 P56 P57 P58 P59 "
  names = names ×× "PGMNAME LOADLIB"
  "ISPEXEC TBCREATE COBANL00 KEYS(PGMKEY) NAMES("names")"

 "ISPEXEC TBERASE  COBANL01"
 "ISPEXEC TBCREATE COBANL01 KEYS(OPTION) NAMES(FN ANZPGM)"

 "ISPEXEC TBERASE  COBANL02"
 "ISPEXEC TBCREATE COBANL02 KEYS(COBVERS) NAMES(COBREL ANZPGM)"

 "ISPEXEC TBERASE  COBANL03"
 "ISPEXEC TBCREATE COBANL03 KEYS(STMT) NAMES(FN ANZPGM)"

 "ISPEXEC TBERASE  COBANL04"
 "ISPEXEC TBCREATE COBANL04 KEYS(LOADLIB)
          NAMES (ANZPGMCO ANZCOBVS ANZCOBII ANZCOB37 REPDAY REPDATE)"
end
else do
  "ISPEXEC TBOPEN   COBANL04"
  "ispexec tbget cobanl04"
  if rc = 0
  then do
    say  "loadlib = " loadlib " already analyzed"
    "ISPEXEC TBCLOSE  COBANL04"
    exit
  end
  "ISPEXEC TBOPEN   COBANL00"
  "ISPEXEC TBOPEN   COBANL01"
  "ISPEXEC TBOPEN   COBANL02"
  "ISPEXEC TBOPEN   COBANL03"
end

repday   = '---n/a---'
anzpgmco = 0
anzcobvs = 0
anzcobii = 0
anzcob37 = 0

repdate  = date('E')

if sysvar(systsoe) >= 2060 then repday = date('W',repdate,'E')

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD
"EXECIO 1 DISKR COBANAL"

IF RC = 2
THEN
  EOF = J
ELSE
  EOF = N

DO WHILE EOF = N
  parse PULL RECORD
  select
    when pos('= Info =',record) > 0
    then do
      "EXECIO 1 DISKR COBANAL"
      parse PULL RECORD
      call pgm_record
    end
    when pos('= Timestamps =',record) > 0
    then do
      "EXECIO 1 DISKR COBANAL"
      parse PULL RECORD
      call timestamp_record
    end
    when pos('= Statistics =',record) > 0
    then do
      "EXECIO 1 DISKR COBANAL"
      parse PULL RECORD
      call statistic_record
    end
    when pos('= Options in effect =',record) > 0
    then do
      "EXECIO 1 DISKR COBANAL"
      parse PULL RECORD
      call option_record
      if cobrel     = 'VS/COBOL'
      then
        "ispexec tbmod cobanl00"
    end
    when pos('PROCEDURE DIVISION',record) > 0
    then do
      "EXECIO 1 DISKR COBANAL"
      parse PULL RECORD
      call procedure_record
      "ispexec tbmod cobanl00"
    end
    otherwise
  end
  "EXECIO 1 DISKR COBANAL"
  IF RC = 2
  THEN DO
    EOF = J
  END
END

"EXECIO 0 DISKR COBANAL (FINIS"
"FREE F(COBANAL)"

"ISPEXEC TBMOD   COBANL04"

"ISPEXEC TBSORT  COBANL00 FIELDS(PGMNAME)"
"ISPEXEC TBSORT  COBANL01 FIELDS(OPTION)"
"ISPEXEC TBSORT  COBANL02 FIELDS(COBREL,C,A,COBVERS,C,A)"
"ISPEXEC TBSORT  COBANL03 FIELDS(STMT)"
"ISPEXEC TBSORT  COBANL04 FIELDS(LOADLIB)"

"ISPEXEC TBCLOSE COBANL00"
"ISPEXEC TBCLOSE COBANL01"
"ISPEXEC TBCLOSE COBANL02"
"ISPEXEC TBCLOSE COBANL03"
"ISPEXEC TBCLOSE COBANL04"

say 'create analyse report ended'

exit

pgm_record:

pgmname       = word(record,2)
pgmkey        = pgmname××loadlib
cobrel        = word(record,4)
cobvers       = word(record,6)

if cobvers   ^= "R1"
then do
  cobvers     = 'V' ×× word(record,6)
  cobvers     = strip(cobvers,T,'.')
  cobvers     = cobvers ×× 'R' ×× word(record,8)
  cobvers     = strip(cobvers,T,'.')
  cobvers     = cobvers ×× 'M' ×× word(record,10)
  cobvers     = strip(cobvers,T,'.')
end

"ispexec        tbget cobanl02"
if rc         > 0
then do
  anzpgm      = 1
  "ispexec      tbadd cobanl02"
end
else do
  anzpgm      = anzpgm + 1
  "ispexec      tbmod cobanl02"
end

pcomprel      = pos('Version',record)
if pcomprel   = 0
then do
  pcomprel    = pos('Release',record)
end
comprel       = substr(record,pcomprel)

return

timestamp_record:

compname      = word(record,4)

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

compdate      = word(record,2)

if cobrel     = 'VS/COBOL'
then do
  comptime    = word(record,4)
  anzcobvs    = anzcobvs + 1
end
else do
  if cobrel     = 'COBOL/2'
  then do
    if cobvers  = 'V1R1M0' × cobvers = 'V1R2M0'
    then do
      comptime  = word(record,7)
      compdate  = word(record,4)
    end
    else do
      wordindd  = wordpos("(european)",record)
      compdate  = word(record,wordindd+1)
      wordindt  = wordpos('Time:',record)
      comptime  = word(record,wordindt+1)
    end
    if pos('??',compdate) > 0
    then do
      p1        = pos('??',compdate)
      if substr(compdate,p1+2,2)  > 70 then oj = 19
                                       else oj = 20
      compdate  = overlay(oj,compdate,p1)
    end
    anzcobii    = anzcobii + 1
  end
  else do
    comptime    = word(record,7)
    compdate    = word(record,4)
    anzcob37    = anzcob37 + 1
  end
end

anzpgmco      = anzpgmco + 1

anzitem       = 'n/a'
anzinstr      = 'n/a'

return

statistic_record:

anzitem       = word(record,6)

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD
anzinstr      = word(record,4)

return

option_record:

do i   = 1 to 60
  fn1  = 'o'××i
  ini  = ' '
  call   value fn1,ini
  fn1  = 'p'××i
  call   value fn1,ini
end

i      = 0

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'o'××i
  call   value fn,word(record,j)
  option='OPTION'
  call   value option,word(record,j)
  call   update_options
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'o'××i
  call   value fn,word(record,j)
  option='OPTION'
  call   value option,word(record,j)
  call   update_options
end

if cobrel     = 'VS/COBOL' then return

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'o'××i
  call   value fn,word(record,j)
  option='OPTION'
  call   value option,word(record,j)
  call   update_options
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'o'××i
  call   value fn,word(record,j)
  option='OPTION'
  call   value option,word(record,j)
  call   update_options
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'o'××i
  call   value fn,word(record,j)
  option='OPTION'
  call   value option,word(record,j)
  call   update_options
end

return

update_options:

"ispexec        tbget cobanl01"
if rc         > 0
then do
  anzpgm      = 1
  "ispexec      tbadd cobanl01"
end
else do
  anzpgm      = anzpgm + 1
  "ispexec      tbmod cobanl01"
end

return

procedure_record:

i      = 0

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

"EXECIO 1 DISKR COBANAL"
parse PULL RECORD

nword  = words(record)

do j   = 1 to nword
  i    = i + 1
  fn   = 'p'××i
  if word(record,j+1) = 'Y'
  then do
    call   value fn,word(record,j)
    option='STMT'
    call   value option,word(record,j)
    call   update_stmt
  end
  j = j + 1
end

return

update_stmt:

"ispexec        tbget cobanl03"
if rc         > 0
then do
  anzpgm      = 1
  "ispexec      tbadd cobanl03"
end
else do
  anzpgm      = anzpgm + 1
  "ispexec      tbmod cobanl03"
end

return

failures:
say  "line = " strip(sourceline(sigl))
say  "Cond = " condition('C') condition('D')
say  "Error= " errortext(rc)
exit
./ ADD NAME=COBANLDS 0100-1999362-1999362-2220-00057-00057-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display cobanal output                     */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

dsnlist = userid()××".COBANAL.LISTING"
dsnedit = userid()××".COBANAL.LISTEDIT"

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

start:
"ISPEXEC ADDPOP ROW(03) COLUMN(10)"
"ISPEXEC DISPLAY PANEL(COBANLDS)"

IF RC = 12 × RC = 20
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

if zcmd  = 1 then dsn = dsnlist
             else dsn = dsnedit

if SYSDSN("'"DSN"'") ^= 'OK'
then do
  mess = 'dataset ' dsn sysdsn("'"dsn"'")
  signal start
end

"ISPEXEC VIEW DATASET('"dsn"')"

signal start

failures:
say  "line = " strip(sourceline(sigl))
say  "Cond = " condition('C') condition('D')
say  "Error= " errortext(rc)
exit
./ ADD NAME=COBANLDT 0100-1999362-1999362-2220-00174-00174-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display information from table             */
/* callers    : cob application                            */
/* parameter  : kz        selection type                   */
/*            : table     table to display                 */
/*            : table2    table to process                 */
/*            : table3    table to process                 */
/*            : panel     panel to display                 */
/*            : filtproc  name of filter procedure         */
/*            : lineproc  name of line selection procedure */
/*            : sortproc  name of sort selection procedure */
/*            : fromproc  name of calling procedure        */
/*            : sel       selection comment                */
/*---------------------------------------------------------*/
/*
   trace ?r
*/

"ispexec   control errors return"
parse      source xx yy procname rest
signal     on syntax  name failures
signal     on failure name failures

"ispexec   vget (tkey1 debug)"

arg        kz  ,                   /*    reference /mark       */
           table    ,              /*    tablename             */
           table2   ,              /*    tablename             */
           table3   ,              /*    tablename             */
           panel    ,              /*    panel to display      */
           filtproc ,              /*    procedure for filter  */
           lineproc ,              /*    procedure line select */
           fromproc ,              /*    calling procname      */
           sel

cursor   = 'zcmd'
zcmd     = ' '
anzscan  = 0

if kz    = 'ALL' then rowsv = kz
else do
  rowsv  = SCAN
  signal display
  rc     = 0
  do while rc = 0
    "ISPEXEC TBSCAN " table
    if rc     > 0 then leave
    anzscan   = anzscan + 1
  end
end

/*------------------------------------------------------------*/
/*   Display table information                                */
/*------------------------------------------------------------*/

display:
a        = ""
"ispexec   tbdispl " table " panel("panel") cursor("cursor")"

if rc    = 12 × rc = 20
then do
  call     coba000 procname panel rc
  exit
end

if substr(zcmd,1,6) = filter
then do
  if sel = 'FILTERLINE'
  then do
    fi   = length(zcmd)
    if fi > 6
    then do
      zparm    =  substr(zcmd,8,fi-6)
      if zparm = 'CLEAR'
      then do
        "ispexec setmsg msg(coba006) msgloc(zcmd)"
        "ispexec vput zparm"
      end
    end
    zcmd     =  substr(zcmd,1,6)
    "ispexec vput zcmd"
    exit
  end
  fi     = length(zcmd)
  if fi  > 6
  then do
    zparm    =  substr(zcmd,8,fi-6)
    if zparm = 'CLEAR'
    then do
      "ispexec setmsg msg(coba006) msgloc(zcmd)"
      signal display
    end
  end
  zcmd   = " "                /*  zcmd clear wegen Abfrage in   */
  "ispexec vput zcmd"         /*  in Filtproc                   */
  filtproc 'FI'     ,
           table    ,
           table2   ,
           table3   ,
           panel    ,
           filtproc ,
           lineproc ,
           fromproc ,
           'filterline'
  zcmd   = ' '
  csel   = ' '
  f1     = ""
  f2     = ""
  f3     = ""
  f4     = ""
  f5     = ""
  f6     = ""
  f7     = ""
  f8     = ""
  f9     = ""
  signal     display
end

if zcmd = 'TRACE' × csel = 'TR'
then do
  zcmd  = ' '
  csel  = ' '
  trace ?r
end

if rc = 8
then do
  zcmd   = " "                /*  zcmd clear wegen Abfrage in   */
  "ispexec vput zcmd"         /*  in Filtproc                   */
  exit
end

if rc = 0
then do
  if substr(zcmd,1,1) = 'F' × substr(zcmd,1,1) = 'L'
  then do
    fi = length(zcmd)
    if fi < 3
    then do
      "ispexec setmsg msg(coba001)"
      signal display
    end
    else do
      call value tkey1,substr(zcmd,3,fi-2)
      "ispexec tbtop " table
      "ispexec tbscan " table " arglist("tkey1") condlist(ge)"
      signal display
    end
  end
end

do while ztdsels > 0
  if a = 'S' × a = '/'
  then do
    lineproc value(tkey1) table table2 fromproc a
  end
  if a = 'X'
  then do
    cobanllx value(tkey1) table table2 fromproc a
  end
  if ztdsels = 1 then signal display
  "ispexec tbdispl " table
end

signal display

exit

failures:
line = strip(sourceline(sigl))
cond = condition('c') condition('d')
"ispexec vput (cond line)"
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLF0 0100-1999362-1999362-2220-00226-00226-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : cobol information select program info      */
/*---------------------------------------------------------*/
/*
   TRACE ?R
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

arg           kz       ,
              table    ,
              table2   ,
              table3   ,
              panel    ,
              filtproc ,
              lineproc ,
              fromproc ,
              sel

"ispexec vget (csel f1 f2 f3)"

IF f1 = "" & f2 = "" & f3 = ""
then nop
else do
  v1   = EQ
  v2   = EQ
  v3   = EQ
  kz   = FS
  signal filter_done
end

START:
call fill_names
"ISPEXEC ADDPOP ROW(03) COLUMN(10)"
"ISPEXEC DISPLAY PANEL(COBAFI10)"

IF RC = 12 × RC = 20
THEN do
  CALL coba000 procname cobafi10 RC
  "ISPEXEC REMPOP"
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

if substr(zcmd,1,6) = filter
then do
  fi = length(zcmd)
  if fi > 6
  then do
    zparm =  substr(zcmd,8,fi-6)
    if zparm = 'CLEAR'
    then do
      "ispexec setmsg msg(coba006) msgloc(zcmd)"
      f1 = ""
      f2 = ""
      f3 = ""
      zparm  = ""
      "ispexec vput zparm"
      signal start
    end
  end
  signal start
end

IF f1 = "" & f2 = "" & f3 = ""
THEN do
  MESS1 = "no filter criteria specified"
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(coba000)"
  "ISPEXEC REMPOP"
  signal start
end

"ispexec vput (f1 f2 f3)"

filter_done:

"ISPEXEC TBVCLEAR " table

fieldn = ""

if f1 > ""
then do
  field  = 'PGMNAME,'
  field  = field××v1
  fieldn = field
  pkomma = pos(',',field)
  name   = substr(field,1,pkomma-1)
  f1n    = name
  if pos('*',f1) = 0 then f1 = f1××'*'
  fieldv = f1
  call value name,fieldv
end

if f2 > ""
then do
  field  = 'COBREL,'
  field  = field××v2
  if fieldn ^= "" then fieldn = fieldn××','
  fieldn = fieldn ×× field
  pkomma = pos(',',field)
  name   = substr(field,1,pkomma-1)
  f2n    = name
  if pos('*',f2) = 0 then f2 = f2××'*'
  fieldv = f2
  call value name,fieldv
end

if f3 > ""
then do
  field  = 'COBVERS,'
  field  = field××v3
  if fieldn ^= "" then fieldn = fieldn××','
  fieldn = fieldn ×× field
  pkomma = pos(',',field)
  name   = substr(field,1,pkomma-1)
  f3n    = name
  if pos('*',f3) = 0 then f3 = f3××'*'
  fieldv = f3
  call value name,fieldv
end

tabname = 'R'××time('S')

"ISPEXEC TBQUERY" table " KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)"
"ISPEXEC TBSARG " table " NEXT NAMECOND("fieldn")"

"ISPEXEC TBERASE  " tabname
"ISPEXEC TBCREATE " TABNAME " KEYS"TKEYS "NOWRITE NAMES"TNAMES

rc = 0
recfound = n

do while rc = 0
  "ISPEXEC TBSCAN " table
  if rc > 0 then leave
  "ISPEXEC TBADD " tabname " MULT(1000)"
  recfound = y
end

IF recfound = n
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument "
  MESS3 = f1n " = " f1
  MESS4 = f2n " = " f2
  MESS5 = f3n " = " f3
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(coba000)"
  "ISPEXEC REMPOP"
  "ISPEXEC TBEND" tabname
  signal start
end

"ISPEXEC TBTOP " tabname

call cobanldt ALL      ,
              tabname  ,
              table2   ,
              table3   ,
              panel    ,
              filtproc ,
              lineproc ,
              COBANLF0 ,
              sel

"ISPEXEC TBEND " tabname

"ispexec vget (zparm zcmd)"

if zcmd     = FILTER
then do
  if zparm  = 'CLEAR'
  then do
    f1      = ""
    f2      = ""
    f3      = ""
    zparm   = ""
    "ispexec  vput zparm"
  end
  signal      start
end

if kz       = FI then signal start

f1          = ""
f2          = ""
f3          = ""

"ispexec      vput (f1 f2 f3)"

exit

fill_names:

f1n    = 'Program'
f1K    = 'Name of program(s) to select'
f2n    = 'Cobol'
f2K    = 'Cobol version (COBOL/VS,COBOL/2)'
f3n    = 'Compiler'
f3K    = 'Compiler Version'

return

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLF1 0100-1999362-1999362-2220-00190-00190-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : cobol information select program info      */
/*---------------------------------------------------------*/
/*
   TRACE ?R
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

arg           kz       ,
              table    ,
              table2   ,
              table3   ,
              panel    ,
              filtproc ,
              lineproc ,
              fromproc ,
              sel

"ispexec vget (csel f1)"

IF f1 = ""
then nop
else do
  v1    = EQ
  v2    = EQ
  v3    = EQ
  kz    = FS
  signal filter_done
end

START:
call fill_names
"ISPEXEC ADDPOP ROW(03) COLUMN(10)"
"ISPEXEC DISPLAY PANEL(COBAFI10)"

IF RC = 12 × RC = 20
THEN do
  CALL coba000 procname cobafi10 RC
  "ISPEXEC REMPOP"
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

if substr(zcmd,1,6) = filter
then do
  fi = length(zcmd)
  if fi > 6
  then do
    zparm =  substr(zcmd,8,fi-6)
    if zparm = 'CLEAR'
    then do
      "ispexec setmsg msg(coba006) msgloc(zcmd)"
      f1 = ""
      zparm  = ""
      "ispexec vput zparm"
      signal start
    end
  end
  signal start
end

IF f1 = ""
THEN do
  MESS1 = "no filter criteria specified"
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(coba000)"
  "ISPEXEC REMPOP"
  signal start
end

"ispexec vput (f1)"

filter_done:

"ISPEXEC TBVCLEAR " table

fieldn = ""

if f1 > ""
then do
  field  = 'OPTION,'
  field  = field××v1
  fieldn = field
  pkomma = pos(',',field)
  name   = substr(field,1,pkomma-1)
  f1n    = name
  if pos('*',f1) = 0 then f1 = f1××'*'
  fieldv = f1
  call value name,fieldv
end

tabname = 'R'××time('S')

"ISPEXEC TBQUERY" table " KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)"
"ISPEXEC TBSARG " table " NEXT NAMECOND("fieldn")"

"ISPEXEC TBERASE  " tabname
"ISPEXEC TBCREATE " TABNAME " KEYS"TKEYS "NOWRITE NAMES"TNAMES

rc = 0
recfound = n

do while rc = 0
  "ISPEXEC TBSCAN " table
  if rc > 0 then leave
  "ISPEXEC TBADD " tabname " MULT(1000)"
  recfound = y
end

IF recfound = n
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument "
  MESS3 = f1n " = " f1
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(coba000)"
  "ISPEXEC REMPOP"
  "ISPEXEC TBEND" tabname
  signal start
end

"ISPEXEC TBTOP " tabname

call cobanldt kz       ,
              tabname  ,
              table2   ,
              table3   ,
              panel    ,
              filtproc ,
              lineproc ,
              COBANLF1 ,
              sel

"ISPEXEC TBEND " tabname

"ispexec vget (zparm zcmd)"

if zcmd     = FILTER
then do
  if zparm  = 'CLEAR'
  then do
    f1      = ""
    zparm   = ""
    "ispexec  vput zparm"
  end
  signal      start
end

if kz       = FI then signal start

f1          = ""

"ispexec      vput (f1)"

exit

fill_names:

f1n    = 'Option '
f1K    = 'select cobol option'
f2n    = ' '
f2K    = ' '
f3n    = ' '
f3K    = ' '

return

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLF3 0100-1999362-1999362-2220-00190-00190-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : cobol information select statement info    */
/*---------------------------------------------------------*/
/*
   TRACE ?R
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

arg           kz       ,
              table    ,
              table2   ,
              table3   ,
              panel    ,
              filtproc ,
              lineproc ,
              fromproc ,
              sel

"ispexec vget (csel f1)"

IF f1 = ""
then nop
else do
  v1    = EQ
  v2    = EQ
  v3    = EQ
  kz    = FS
  signal filter_done
end

START:
call fill_names
"ISPEXEC ADDPOP ROW(03) COLUMN(10)"
"ISPEXEC DISPLAY PANEL(COBAFI10)"

IF RC = 12 × RC = 20
THEN do
  CALL coba000 procname cobafi10 RC
  "ISPEXEC REMPOP"
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

if substr(zcmd,1,6) = filter
then do
  fi = length(zcmd)
  if fi > 6
  then do
    zparm =  substr(zcmd,8,fi-6)
    if zparm = 'CLEAR'
    then do
      "ispexec setmsg msg(coba006) msgloc(zcmd)"
      f1 = ""
      zparm  = ""
      "ispexec vput zparm"
      signal start
    end
  end
  signal start
end

IF f1 = ""
THEN do
  MESS1 = "no filter criteria specified"
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(coba000)"
  "ISPEXEC REMPOP"
  signal start
end

"ispexec vput (f1)"

filter_done:

"ISPEXEC TBVCLEAR " table

fieldn = ""

if f1 > ""
then do
  field  = 'STMT,'
  field  = field××v1
  fieldn = field
  pkomma = pos(',',field)
  name   = substr(field,1,pkomma-1)
  f1n    = name
  if pos('*',f1) = 0 then f1 = f1××'*'
  fieldv = f1
  call value name,fieldv
end

tabname = 'R'××time('S')

"ISPEXEC TBQUERY" table " KEYS(TKEYS) KEYNUM(TKEYNUM) NAMES(TNAMES)"
"ISPEXEC TBSARG " table " NEXT NAMECOND("fieldn")"

"ISPEXEC TBERASE  " tabname
"ISPEXEC TBCREATE " TABNAME " KEYS"TKEYS "NOWRITE NAMES"TNAMES

rc = 0
recfound = n

do while rc = 0
  "ISPEXEC TBSCAN " table
  if rc > 0 then leave
  "ISPEXEC TBADD " tabname " MULT(1000)"
  recfound = y
end

IF recfound = n
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument "
  MESS3 = f1n " = " f1
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(coba000)"
  "ISPEXEC REMPOP"
  "ISPEXEC TBEND" tabname
  signal start
end

"ISPEXEC TBTOP " tabname

call cobanldt kz       ,
              tabname  ,
              table2   ,
              table3   ,
              panel    ,
              filtproc ,
              lineproc ,
              COBANLF3 ,
              sel

"ISPEXEC TBEND " tabname

"ispexec vget (zparm zcmd)"

if zcmd     = FILTER
then do
  if zparm  = 'CLEAR'
  then do
    f1      = ""
    zparm   = ""
    "ispexec  vput zparm"
  end
  signal      start
end

if kz       = FI then signal start

f1          = ""

"ispexec      vput (f1)"

exit

fill_names:

f1n    = 'Statement'
f1K    = 'select cobol procedure division statement'
f2n    = ' '
f2K    = ' '
f3n    = ' '
f3K    = ' '

return

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLLI 0102-1999357-1999357-0811-00095-00096-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : select cobanal programs                    */
/* caller     : general table display procedure            */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

parse arg selection table table2 fromproc a

"ispexec vget tkey1"
ztkey1   = tkey1
tkey1    = 'PGMKEY'
"ispexec vput tkey1"

select
  when ztkey1 = 'OPTION'
  then do
    option    = selection
  end
  when ztkey1 = 'LOADLIB'
  then do
    fn        = 'LOADLIB'
    loadlib   = selection
  end
  when ztkey1 = 'COBVERS'
  then do
    fn        = 'COBVERS'
    cobvers   = selection
  end
  when ztkey1 = 'STMT'
  then do
    fn        = 'STMT'
    stmt      = selection
  end
  otherwise do
    MESS1 = "invalid option specified"
    MESS2 = "searchargument follows"
    MESS3 = 'TKEY1 = ' ztkey1
    MESS4 = 'Selection = ' selection
    "ISPEXEC ADDPOP"
    "ISPEXEC DISPLAY PANEL(COBA000)"
    "ISPEXEC REMPOP"
    signal finish
  end
end

"ispexec tbget " table

call value fn,selection

"ISPEXEC TBSARG " table2 " NEXT NAMECOND("fn",EQ)"

IF rc > 0
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument follows"
  MESS3 = 'TKEY1 = ' ztkey1
  MESS4 = 'Selection = ' selection
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  signal finish
end

Sel = 'programs with compile option ' option

call cobanldt 'OP'     ,
              table2   ,
              table2   ,
              table3   ,
              COBANL00 ,
              COBANLF0 ,
              COBANLL0 ,
              COBANLLI ,
              sel

finish:
tkey1    = ztkey1
"ispexec vput tkey1"

exit

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
parse source x y procname z
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLLX 0100-1999362-1999362-2220-00114-00114-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : select cobanal programs                    */
/* caller     : general table display procedure            */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

arg selection table table2 fromproc a

"ispexec vget tkey1"
ztkey1   = tkey1
tkey1    = 'PGMKEY'
"ispexec vput tkey1"

select
  when ztkey1 = 'OPTION'
  then do
    option    = selection
  end
  when ztkey1 = 'COBVERS'
  then do
    fn        = 'COBVERS'
    cobvers   = selection
  end
  when ztkey1 = 'STMT'
  then do
    fn        = 'STMT'
    stmt      = selection
  end
  when ztkey1 = 'LOADLIB'
  then do
    fn        = 'LOADLIB'
    loadlib   = selection
  end
  otherwise do
    MESS1 = "invalid option specified"
    MESS2 = "searchargument follows"
    MESS3 = 'TKEY1 = ' ztkey1
    MESS4 = 'Selection = ' selection
    "ISPEXEC ADDPOP"
    "ISPEXEC DISPLAY PANEL(COBA000)"
    "ISPEXEC REMPOP"
    signal finish
  end
end

"ispexec tbget " table

call value fn,selection

"ISPEXEC TBQUERY" table2 " KEYS(TKEY) KEYNUM(TKEYNUM) NAMES(TNAMES)"

tabname     = 'R'××time('S')

"ISPEXEC TBERASE " tabname

"ISPEXEC TBCREATE " TABNAME " KEYS"TKEY "NOWRITE NAMES"TNAMES

rc          = 0
recfound    = n

"ISPEXEC TBSARG " table2 " NEXT NAMECOND("fn")"

do while rc = 0
  "ISPEXEC TBSCAN " table2
  if rc     > 0 then leave
  "ISPEXEC TBADD " tabname " MULT(1000)"
  recfound  = y
end

IF recfound = n
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument follows"
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  "ISPEXEC TBEND" tabname
  signal finish
end

"ISPEXEC TBTOP " tabname

Sel = 'programs with ' ztkey1 '=' selection

call cobanldt 'ALL'    ,
              tabname  ,
              table2   ,
              table3   ,
              COBANL00 ,
              COBANLF0 ,
              COBANLL0 ,
              COBANLLI ,
              sel

finish:
tkey1    = ztkey1
"ispexec vput tkey1"

exit

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
parse source x y procname z
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLL0 0100-1999362-1999362-2220-00102-00102-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display cobanal programm compiler options  */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

arg pgmkey rest

"ispexec tbget cobanl00"

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

start:
"ISPEXEC ADDPOP ROW(03) COLUMN(10)"
"ISPEXEC DISPLAY PANEL(COBANLL0)"

IF RC = 12 × RC = 20
THEN do
  CALL COBA000 procname  procname rc
  "ISPEXEC REMPOP"
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

if COBREL = 'VS/COBOL'
then do
  mess1   = 'no more information for VS/COBOL program'
  "ISPEXEC ADDPOP ROW(03) COLUMN(10)"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  signal start
end

do i   = 1 to 59
  fn1  = 's'××i
  ini  = ' '
  call   value fn1,ini
end

j      = 0

do i   = 1 to 59
  fn1  = 'f'××i
  fn2  = 'p'××i
  if value(fn2) > ""
  then do
    j  = j + 1
    fn3= 's'××j
    call   value fn3,value(fn2)
  end
end

"ISPEXEC ADDPOP ROW(03) COLUMN(10)"
"ISPEXEC DISPLAY PANEL(COBANL08)"

IF RC = 12 × RC = 20
THEN do
  CALL COBA000 procname cobanl08 rc
  "ISPEXEC REMPOP"
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

signal start

exit

failures:
say  "line = " strip(sourceline(sigl))
say  "Cond = " condition('C') condition('D')
say  "Error= " errortext(rc)
exit
./ ADD NAME=COBANLL1 0110-1999102-1999106-1508-00090-00089-00031-FRALBER
/*-------- REXX -------------------------------------------*/
/* Function   : display cobanal programm compiler options  */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

arg option table table2 fromproc a

"ispexec tbget " table
"ispexec vget tkey1"
ztkey1   = tkey1
tkey1    = 'PGMNAME'
"ispexec vput tkey1"

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

"ISPEXEC TBTOP    " table2
"ISPEXEC TBVCLEAR " table2

call value fn,option

"ISPEXEC TBQUERY" table2 " KEYS(TKEY) KEYNUM(TKEYNUM) NAMES(TNAMES)"

tabname     = 'R'××time('S')

"ISPEXEC TBERASE " tabname

if tkeynum  = 0
then
  "ISPEXEC TBCREATE " TABNAME " NOWRITE NAMES"TNAMES
else
  "ISPEXEC TBCREATE " TABNAME " KEYS"TKEY" NOWRITE NAMES"TNAMES

rc          = 0
recfound    = n

"ISPEXEC TBSARG " table2 " NEXT NAMECOND("fn")"

do while rc = 0
  "ISPEXEC TBSCAN " table2
  if rc     > 0 then leave
  "ISPEXEC TBADD " tabname " MULT(1000)"
  recfound  = y
end

IF recfound = n
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument follows"
  MESS3 = fn
  MESS4 = option
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  "ISPEXEC TBEND" tabname
  exit
end

"ISPEXEC TBTOP " tabname

Sel = 'programs with compile option ' option

call cobanldt 'OP'     ,
              tabname  ,
              table2   ,
              table3   ,
              COBANL00 ,
              COBANLF0 ,
              COBANLL0 ,
              COBANLL1 ,
              sel

"ISPEXEC TBEND " tabname

tkey1    = ztkey1
"ispexec vput tkey1"

exit

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
parse source x y procname z
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLL2 0109-1999103-1999106-1507-00093-00089-00015-FRALBER
/*-------- REXX -------------------------------------------*/
/* Function   : display cobanal programm compiler versions */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

arg cobvers table table2 fromproc a

"ispexec tbget conanl02"

"ispexec vget tkey1"
ztkey1   = tkey1
tkey1    = 'PGMNAME'
"ispexec vput tkey1"

compv   = cobvers

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

"ISPEXEC TBTOP    " table2
"ISPEXEC TBVCLEAR " table2

cobvers = compv

"ISPEXEC TBQUERY" table2 " KEYS(TKEY) KEYNUM(TKEYNUM) NAMES(TNAMES)"

tabname     = 'R'××time('S')

"ISPEXEC TBERASE " tabname

if tkeynum  = 0
then
  "ISPEXEC TBCREATE " TABNAME " NOWRITE NAMES"TNAMES
else
  "ISPEXEC TBCREATE " TABNAME " KEYS"TKEY" NOWRITE NAMES"TNAMES

rc          = 0
recfound    = n

"ISPEXEC TBSARG " table2 " NEXT NAMECOND(cobvers,eq)"

do while rc = 0
  "ISPEXEC TBSCAN " table2
  if rc     > 0 then leave
  "ISPEXEC TBADD " tabname " MULT(1000)"
  recfound  = y
end

IF recfound = n
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument follows"
  MESS3 = fn
  MESS4 = cobvers
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  "ISPEXEC TBEND" tabname
  exit
end

"ISPEXEC TBTOP " tabname

Sel = 'programs with compiler ' cobrel compv

call cobanldt 'OP'     ,
              tabname  ,
              table2   ,
              table3   ,
              COBANL00 ,
              COBANLF0 ,
              COBANLL0 ,
              COBANLL1 ,
              sel

"ISPEXEC TBEND " tabname

tkey1    = ztkey1
"ispexec vput tkey1"

exit

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
parse source x y procname z
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLL3 0104-1999106-1999106-1539-00090-00089-00005-FRALBER
/*-------- REXX -------------------------------------------*/
/* Function   : display cobanal procedure statements       */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

arg stmt table table2 fromproc a

"ispexec tbget " table
"ispexec vget tkey1"
ztkey1   = tkey1
tkey1    = 'PGMNAME'
"ispexec vput tkey1"

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

"ISPEXEC TBTOP    " table2
"ISPEXEC TBVCLEAR " table2

call value fn,stmt

"ISPEXEC TBQUERY" table2 " KEYS(TKEY) KEYNUM(TKEYNUM) NAMES(TNAMES)"

tabname     = 'R'××time('S')

"ISPEXEC TBERASE " tabname

if tkeynum  = 0
then
  "ISPEXEC TBCREATE " TABNAME " NOWRITE NAMES"TNAMES
else
  "ISPEXEC TBCREATE " TABNAME " KEYS"TKEY" NOWRITE NAMES"TNAMES

rc          = 0
recfound    = n

"ISPEXEC TBSARG " table2 " NEXT NAMECOND("fn")"

do while rc = 0
  "ISPEXEC TBSCAN " table2
  if rc     > 0 then leave
  "ISPEXEC TBADD " tabname " MULT(1000)"
  recfound  = y
end

IF recfound = n
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument follows"
  MESS3 = fn
  MESS4 = stmt
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  "ISPEXEC TBEND" tabname
  exit
end

"ISPEXEC TBTOP " tabname

Sel = 'programs with statements ' stmt

call cobanldt 'ST'     ,
              tabname  ,
              table2   ,
              table3   ,
              COBANL00 ,
              COBANLF0 ,
              COBANLL0 ,
              COBANLL3 ,
              sel

"ISPEXEC TBEND " tabname

tkey1    = ztkey1
"ispexec vput tkey1"

exit

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
parse source x y procname z
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLL9 0100-1999362-1999362-2220-00113-00113-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display information for loadlibs           */
/* callers    : coba application                           */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

arg loadlib table table2 fromproc a

"ispexec tbget " table

"ispexec vget tkey1"
ztkey1   = tkey1

START:
"ISPEXEC ADDPOP ROW(05) COLUMN(04)"
"ISPEXEC DISPLAY PANEL(COBANLL9)"

IF RC = 12 × RC = 20
THEN do
  CALL COBA000 procname procname RC
  "ISPEXEC REMPOP"
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  tkey1    = ztkey1
  "ispexec vput tkey1"
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

select
  when zcmd   = 1
  then do
    call cobanlli loadlib table table2 COBANLL9 zcmd
    signal start
  end
  when zcmd   = 2
  then do
    cobrel    = 'VS/COBOL'
    ausw      = 'Cobol/VS '
  end
  when zcmd   = 3
  then do
    cobrel    = 'COBOL/2'
    ausw      = 'Cobol/II '
  end
  when zcmd   = 4
  then do
    cobrel    = 'COBOL/370'
    ausw      = 'Cobol/370 '
  end
  when zcmd   = 5
  then do
    call cobai34 'DSN' loadlib
    signal start
  end
  otherwise signal start
END

fn        = 'COBREL,EQ,LOADLIB,EQ'
ausw      = ausw 'programs from library' loadlib
tkey1     = 'PGMKEY'
"ispexec vput tkey1"

"ISPEXEC TBSARG COBANL00 NEXT NAMECOND("fn")"

IF rc > 0
THEN do
  MESS1 = "no rows with searchargument found"
  MESS2 = "searchargument follows"
  MESS3 = 'COBREL = ' cobrel
  MESS4 = 'LOADLIB= ' loadlib
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  signal start
end

call cobanldt 'LO'     ,
              COBANL00 ,
              table2   ,
              table3   ,
              COBANL00 ,
              COBANLF0 ,
              COBANLL0 ,
              COBANLLI ,
              ausw

signal start

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANLPG 0103-1999348-1999357-0833-00094-00094-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display Cobanl program selection panel     */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures

start:
mess    = 'please enter program name and loadlib'
"ISPEXEC ADDPOP ROW(03) COLUMN(10)"
"ISPEXEC DISPLAY PANEL(COBANLPG)"
IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end
IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  exit
end

"ISPEXEC REMPOP"

M = MSG(OFF)
X = SYSDSN("'"dsn"'")

IF X ^= 'OK'
THEN DO
  mess1   = 'load library = ' dsn
  mess2   = 'not cataloged'
  "ISPEXEC ADDPOP ROW(03) COLUMN(10)"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  signal start
END

"ispexec vget steplib"

"FREE F(SYSPRINT)"
"FREE F(COBANAL)"

odataset = userid()".COBANAL.PGMLIST"

ADDRESS TSO "DELETE '"odataset"'"

ADDRESS TSO "ALLOC F(SYSPRINT) ",
            "DA('"odataset"') ",
            "NEW REU ",
            "LRECL(121)",
            "RECFM(F B)",
            "BLKSIZE(0)",
            "TRACKS",
            "SPACE(1 1)"

ADDRESS TSO "ALLOC F(COBANAL) ",
            "DA('"dsn"') ",
            "SHR"

"CALL '"STEPLIB"(COBANAL)' '"pgm"'"
mess1 = 'CALL 'STEPLIB'(COBANAL)' pgm

if rc     > 4
then do
  mess2   = 'Returncode = ' rc
  mess3   = 'Possible reason could be S806'
  mess4   = 'module COBANAL not found'
  "ISPEXEC ADDPOP ROW(03) COLUMN(10)"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
end
else do
  "ISPEXEC VIEW DATASET('"ODATASET"')"
end

"FREE F(SYSPRINT)"
"FREE F(COBANAL)"

ADDRESS TSO "DELETE '"odataset"'"
M = MSG(ON)

SIGNAL START

failures:
line = strip(sourceline(sigl))
Cond = condition('C') condition('D')
"ispexec vput (cond line)"
parse source x y procname z
call cobasynt procname sigl errortext(rc) /* show what went wrong */
exit
./ ADD NAME=COBANL03 0100-1999362-1999362-2220-00375-00375-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : select  cobanal options                    */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

init:
"ISPEXEC ADDPOP"
"ISPEXEC DISPLAY PANEL(COBANL05)"

IF RC = 12 × RC = 20
THEN do
  "ISPEXEC REMPOP"
  CALL COBA000 procname cobanl05 rc
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

select
  when zcmd = 1
  then do
    call      cobanl06
    signal    init
  end
  when zcmd = 2 then nop
  otherwise   signal init
end

start:
"ISPEXEC ADDPOP"
"ISPEXEC DISPLAY PANEL(COBANL03)"

IF RC = 12 × RC = 20
THEN do
  "ISPEXEC REMPOP"
  CALL COBA000 procname procname rc
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  signal init
end

"ISPEXEC REMPOP"

select
  when zcmd = 1
  then do
    fieldv  = ADV
  end
  when zcmd = 2
  then do
    fieldv  = NOADV
  end
  when zcmd = 3
  then do
    fieldv  = QUOTE
  end
  when zcmd = 4
  then do
    fieldv  = NOQUOTE
  end
  when zcmd = 5
  then do
    fieldv  = 'DATA(24)'
  end
  when zcmd = 6
  then do
    fieldv  = 'DATA(31)'
  end
  when zcmd = 7
  then do
    fieldv  = DECK
  end
  when zcmd = 8
  then do
    fieldv  = NODECK
  end
  when zcmd = 9
  then do
    fieldv  = DUMP
  end
  when zcmd = 10
  then do
    fieldv  = NODUMP
  end
  when zcmd = 11
  then do
    fieldv  = DYNAM
  end
  when zcmd = 12
  then do
    fieldv  = NODYNAM
  end
  when zcmd = 13
  then do
    fieldv  = FASTSRT
  end
  when zcmd = 14
  then do
    fieldv  = NOFASTSRT
  end
  when zcmd = 15
  then do
    fieldv  = FDUMP
  end
  when zcmd = 16
  then do
    fieldv  = NOFDUMP
  end
  when zcmd = 17
  then do
    fieldv  = LIB
  end
  when zcmd = 18
  then do
    fieldv  = NOLIB
  end
  when zcmd = 19
  then do
    fieldv  = LIST
  end
  when zcmd = 20
  then do
    fieldv  = NOLIST
  end
  when zcmd = 21
  then do
    fieldv  = MAP
  end
  when zcmd = 22
  then do
    fieldv  = NOMAP
  end
  when zcmd = 23
  then do
    fieldv  = NUM
  end
  when zcmd = 24
  then do
    fieldv  = NONUM
  end
  when zcmd = 25
  then do
    fieldv  = OBJ
  end
  when zcmd = 26
  then do
    fieldv  = NOOBJ
  end
  when zcmd = 27
  then do
    fieldv  = OFFSET
  end
  when zcmd = 28
  then do
    fieldv  = NOOFFSET
  end
  when zcmd = 29
  then do
    fieldv  = OPTIMIZE
  end
  when zcmd = 30
  then do
    fieldv  = NOOPTIMIZE
  end
  when zcmd = 31
  then do
    fieldv  = 'DDNAME(Default)'
  end
  when zcmd = 32
  then do
    fieldv  = 'DDNAME(no-Default)'
  end
  when zcmd = 33
  then do
    fieldv  = 'NUMPROC(PFD)'
  end
  when zcmd = 34
  then do
    fieldv  = 'NUMPROC(NOPFD)'
  end
  when zcmd = 35
  then do
    fieldv  = RENT
  end
  when zcmd = 36
  then do
    fieldv  = NORENT
  end
  when zcmd = 37
  then do
    fieldv  = RES
  end
  when zcmd = 38
  then do
    fieldv  = NORES
  end
  when zcmd = 39
  then do
    fieldv  = SEQ
  end
  when zcmd = 40
  then do
    fieldv  = NOSEQ
  end
  when zcmd = 41
  then do
    fieldv  = 'SIZE(MAX)'
  end
  when zcmd = 42
  then do
    fieldv  = 'SIZE(NOMAX)'
  end
  when zcmd = 43
  then do
    fieldv  = SOURCE
  end
  when zcmd = 44
  then do
    fieldv  = NOSOURCE
  end
  when zcmd = 45
  then do
    fieldv  = SSRANGE
  end
  when zcmd = 46
  then do
    fieldv  = NOSSRANGE
  end
  when zcmd = 47
  then do
    fieldv  = TERM
  end
  when zcmd = 48
  then do
    fieldv  = NOTERM
  end
  when zcmd = 49
  then do
    fieldv  = TEST
  end
  when zcmd = 50
  then do
    fieldv  = NOTEST
  end
  when zcmd = 51
  then do
    fieldv  = 'TRUNC(BIN)'
  end
  when zcmd = 52
  then do
    fieldv  = 'TRUNC(OPT)'
  end
  when zcmd = 53
  then do
    fieldv  = VBREF
  end
  when zcmd = 54
  then do
    fieldv  = NOVBREF
  end
  when zcmd = 55
  then do
    fieldv  = XREF
  end
  when zcmd = 56
  then do
    fieldv  = NOXREF
  end
  when zcmd = 57
  then do
    fieldv  = ZWB
  end
  when zcmd = 58
  then do
    fieldv  = NOZWB
  end
  when zcmd = 59
  then do
    fieldv  = NAME
  end
  when zcmd = 60
  then do
    fieldv  = NONAME
  end
  when zcmd = 61
  then do
    fieldv  = CMPR2
  end
  when zcmd = 62
  then do
    fieldv  = NOCMPR2
  end
  when zcmd = 63
  then do
    fieldv  = NUMCLS
  end
  when zcmd = 64
  then do
    fieldv  = NONUMCLS
  end
  when zcmd = 65
  then do
    fieldv  = DBCS
  end
  when zcmd = 66
  then do
    fieldv  = NODBCS
  end
  when zcmd = 67
  then do
    fieldv  = AWO
  end
  when zcmd = 68
  then do
    fieldv  = NOAWO
  end
  when zcmd = 69
  then do
    fieldv  = EVENTS
  end
  when zcmd = 70
  then do
    fieldv  = NOEVENTS
  end
  when zcmd = 71
  then do
    fieldv  = CURRENCY
  end
  when zcmd = 72
  then do
    fieldv  = NOCURRENCY
  end
  otherwise   signal start
end

call cobanlli fieldv cobanl01 cobanl00 cobanl03 s

signal start

exit

failures:
say  "line = " strip(sourceline(sigl))
say  "Cond = " condition('C') condition('D')
say  "Error= " errortext(rc)
exit
./ ADD NAME=COBANL06 0100-1999362-1999362-2220-00136-00136-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : select  cobanal options                    */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

start:
"ISPEXEC ADDPOP"
"ISPEXEC DISPLAY PANEL(COBANL06)"

IF RC = 12 × RC = 20
THEN do
  "ISPEXEC REMPOP"
  CALL COBA000 procname cobanl06 rc
  EXIT
end

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

select
  when zcmd = 1
  then do
    fieldv  = SYMDMP
  end
  when zcmd = 2
  then do
    fieldv  = NOSYMDMP
  end
  when zcmd = 3
  then do
    fieldv  = FLOW
  end
  when zcmd = 4
  then do
    fieldv  = NOFLOW
  end
  when zcmd = 5
  then do
    fieldv  = STATE
  end
  when zcmd = 6
  then do
    fieldv  = NOSTATE
  end
  when zcmd = 7
  then do
    fieldv  = OPT
  end
  when zcmd = 8
  then do
    fieldv  = NOOPT
  end
  when zcmd = 9
  then do
    fieldv  = TEST
  end
  when zcmd = 10
  then do
    fieldv  = NOTEST
  end
  when zcmd = 11
  then do
    fieldv  = RES
  end
  when zcmd = 12
  then do
    fieldv  = NORES
  end
  when zcmd = 13
  then do
    fieldv  = ENDJOB
  end
  when zcmd = 14
  then do
    fieldv  = NOENDJOB
  end
  when zcmd = 15
  then do
    fieldv  = OBJ370
  end
  when zcmd = 16
  then do
    fieldv  = NOOBJ370
  end
  when zcmd = 17
  then do
    fieldv  = COUNT
  end
  when zcmd = 18
  then do
    fieldv  = NOCOUNT
  end
  when zcmd = 19
  then do
    fieldv  = LIST
  end
  when zcmd = 20
  then do
    fieldv  = TRACE
  end
  when zcmd = 21
  then do
    fieldv  = 'NO-TRACE'
  end
  otherwise   signal start
end

call cobanlli fieldv cobanl01 cobanl00 cobanl03 s

signal start

exit

failures:
say  "line = " strip(sourceline(sigl))
say  "Cond = " condition('C') condition('D')
say  "Error= " errortext(rc)
exit
./ ADD NAME=COBASUBP 0100-1999362-1999362-2220-00097-00097-00000-DESTS03
/*--- REXX -------------------------------------------*/
/*
   trace ?r
*/

ARG loadlib ptype

"ISPEXEC CONTROL ERRORS RETURN"

JCLLIB  = USERID()××.ISPF.ISPPROF

USERHLQ = USERID()

"ALLOC DD(ISPFILE) DSN('"JCLLIB"') SHR REUSE"

"ISPEXEC VGET (STEPLIB COBAAPPL)"
"ISPEXEC VGET (COBAHLQ LLQCLIB LLQMLIB LLQPLIB LLQSLIB LLQTLIB LLQTABL)"
"ISPEXEC VGET (ACCOUNT CLASS MSGCLASS ISPFHLQ)"

"ISPEXEC FTCLOSE NAME(COBAJOB0)"

"ISPEXEC FTOPEN"

if rc > 0
then do
  select
    when rc = 8
    then do
      MESS2 = "file tailoring already in progress"
    end
    when rc = 12
    then do
      MESS2 = "output file in use. ENQ failed"
    end
    when rc = 16
    then do
      MESS2 = "ISPFILE not allocated"
    end
    when rc = 20
    then do
      MESS2 = "severe error"
    end
    otherwise
  end
  MESS1 = "error FTOPEN"
  MESS3 = "returncode = " ×× rc
  MESS4 = "Procedur = COBASUBP"
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC REMPOP"
  "ISPEXEC FTCLOSE"
  signal free_file
end

"ISPEXEC FTINCL COBANAL"

if rc > 0
then do
  select
    when rc = 8
    then do
      MESS1 = "output skeleton not defined"
    end
    when rc = 12
    then do
      MESS1 = "output skeleton in use. ENQ failed"
    end
    when rc = 16
    then do
      MESS1 = "data truncation occured"
    end
    when rc = 20
    then do
      MESS1 = "severe error"
    end
    otherwise
  end
  MESS2 = "please contact system support"
  MESS3 = "skeleton = " ×× COBANAL
  "ISPEXEC ADDPOP"
  "ISPEXEC DISPLAY PANEL(COBA000)"
  "ISPEXEC FTCLOSE"
  "ISPEXEC REMPOP"
  signal ende
end

"ISPEXEC FTCLOSE NAME(COBAJOB0)"

"ISPEXEC EDIT DATASET('"JCLLIB"(COBAJOB0)')"

ende:
"ISPEXEC FTERASE COBAJOB0"

free_file:
"FREE DD(ISPFILE)"

EXIT
./ ADD NAME=COBASYNT 0100-1999362-1999362-2220-00032-00032-00000-DESTS03
/*--- REXX -------------------------------------------*/
/*
   TRACE ?R
*/

arg proc sline err

"ISPEXEC CONTROL ERRORS RETURN "

"ispexec vget (line cond)"

"ISPEXEC ADDPOP ROW(04) COLUMN(08)"

START:
"ISPEXEC DISPLAY PANEL(COBASYNT)"

IF RC = 12 × RC = 20
THEN do
  CALL COBA000 COBASYNT COBASYNT RC
  "ISPEXEC REMPOP"
  EXIT
end

IF RC = 8
THEN do
  "ISPEXEC REMPOP"
  EXIT
end

signal start

exit
./ ADD NAME=COBASYSI 0100-1999362-1999362-2220-00063-00063-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display information for system             */
/* callers    : coba information application               */
/*---------------------------------------------------------*/
/*
    trace ?r
*/

"ispexec control errors return"
parse source xx yy procname rest
signal on syntax  name failures
signal on failure name failures

cpu     = storage(208,4)
cpu     = storage(d2x(c2d(cpu)+12),4)
cvt     = storage(10,4)
cvtprod = d2x(c2d(cvt) - c2d('28'x))
mvslvl  = storage(cvtprod,16)

x = syscpus(cpu.)
cpun    = cpu.0
cpu1    = cpu.1
if cpun > 1 then cpu2    = cpu.2
if cpun > 2 then cpu3    = cpu.3
if cpun > 3 then cpu4    = cpu.4
if cpun > 4 then cpu5    = cpu.5
if cpun > 5 then cpu6    = cpu.6

mvslvl  = mvsvar(sysopsys)
syslvl  = mvsvar(sysname)
smfid   = mvsvar(syssmfid)
cput    = sysvar(syscpu)

jeslvl  = sysvar(sysjes)
tsolvl  = sysvar(systsoe)
racflvl = sysvar(syslracf)
parse version rexxlvl

"ISPEXEC ADDPOP ROW(08) COLUMN(10)"

"ISPEXEC DISPLAY PANEL(COBASYSI)"

IF RC = 12 × RC = 20
THEN do
  CALL COBA000 procname cobasysi RC
  "ISPEXEC REMPOP"
  EXIT
end

"ISPEXEC REMPOP"

IF ZCMD = TRACE
THEN DO
  zcmd = ' '
  trace ?r
end

EXIT

syntax:
parse source x y procname z
call cobasynt procname sigl errortext(rc)
exit
./ ADD NAME=COBA000  0100-1999362-1999362-2220-00039-00039-00000-DESTS03
/*-------- REXX -------------------------------------------*/
/* Function   : display information for panel error        */
/* callers    : cob analysys  application                  */
/*---------------------------------------------------------*/
/*
   TRACE ?R
*/

arg procname panel disrc

/* Rexx get panelid of last displayed panel                          */
/* Not a general use programming interface                           */
/* This method is subject to breakage by maintanence or new releases */
/* die folgende zuweisung zeigt letztes gezeigtes Panel an           */

pnl   = storage(d2x(ptr(ptr(ptr(ptr(ptr(540)+132)+112)+24))+352),8)

MESS1 = 'panel display/query error in procedur '
MESS2 = 'Procname   = '××procname
MESS3 = 'Panel name = '××panel
MESS4 = 'returncode = '××disrc

if disrc = 20 then mess6 = "severe error"
else do
  mess6 = "no table rows to display"
  mess7 = "or panel does not exist"
end

"ISPEXEC ADDPOP"
"ISPEXEC DISPLAY PANEL(COBA000)"
"ISPEXEC REMPOP"

exit

/* Rexx get panelid of last displayed panel                          */
/* Not a general use programming interface                           */
/* This method is subject to breakage by maintanence or new releases */

ptr: Return c2d(bitand(storage(d2x(Arg(1)),4),'7FFFFFFF'x))
./ ADD NAME=STRING   0100-1999159-1999159-0714-01212-01212-00000-DESTS03
*/IBMUSERM JOB (ACCT#),STRING,
*/ NOTIFY=&SYSUID,
*/ CLASS=A,MSGCLASS=X,COND=(0,NE)
*/ASMH EXEC PGM=IEV90,PARM=(OBJECT,NODECK,NOESD,NORLD,
*/ NOXREF)
***********************************************************************
*                                                                     *
* MACRO NAME = STRING                                                 *
*                                                                     *
* DESCRIPTIVE NAME = STRING MACRO INSTRUCTION.                        *
*                                                                     *
* FUNCTION = PROVIDE CAPABILITIES SIMILAR TO PUT EDIT (OF PL/I)       *
*            OR STRING (OF COBOL) TO ASSEMBLER PROGRAMS.              *
*                                                                     *
* STATUS = R504                                                       *
*                                                                     *
* AUTHOR = GILBERT SAINT-FLOUR                                        *
*                                                                     *
* ENVIRONMENT = SEE BELOW                                             *
*                                                                     *
*     AMODE = ANY                                                     *
*     SCP   = MVS/ESA OR OS/390                                       *
*     KEY   = ANY                                                     *
*     MODE  = ANY                                                     *
*     APF   = OFF                                                     *
*                                                                     *
* OPERATION = SEE DOCUMENTATION AT THE END OF THIS FILE               *
*                                                                     *
* INVOCATION = SEE DOCUMENTATION AT THE END OF THIS FILE              *
*                                                                     *
* NOTES = SEE DOCUMENTATION AT THE END OF THIS FILE                   *
*                                                                     *
* CHANGE ACTIVITY                                                     *
*                                                                     *
*  $301  FIX BUGS WITH (XYZ,,L8) AND INTO=((R1),(R2))                 *
*  $302  GENERATE $DEBUG BOOT-STRAP IN FINAL_CALL INVOCATION          *
*  $303  REPLACE @STRPAD WITH @STRBLANKS                              *
*  $304  USE @00-@15 INSTEAD OF R0-R15 FOR REGISTER EQUATES           *
*  $306  TAILOR @STRING CSECT TO PROGRAM'S REQUIREMENTS               *
*        LITERALS CAN BE CODED AS 'ABC' OR C'ABC' OR X'C1C2C3'        *
*        USE L'PSATOLD AS IMPLICIT LENGTH FOR (PSATOLD-PSA,,X)        *
*  $307  FINAL_CALL OPTION CHANGED TO GENERATE                        *
*        ADD NOCSECT AND LOCTR OPTIONS TO GENERATE CALL               *
*  $308  USE L'RBCDE AS IMPLICIT LENGTH FOR (PRB.RBCDE,,X)            *
*        PREVENT S0C4 WHEN ADDR IS BAD AND LENGTH IS ZERO             *
*  $400  REORG THE CODE TO SIMPLIFY FEATURE SELECTION                 *
*        BLANKS NO LONGER USED OR GENERATED                           *
*  $401  GENERATE @STRHEXT WHEN ((REG),,X) ONLY HEX FIELD             *
*  $502  @STRING ROUTINE REWRITTEN FOR MVS/ESA:                       *
*        -  USE LINKAGE STACK TO STORE CALLER'S REGISTERS             *
*        -  ADD SUPPORT FOR AR MODE                                   *
*  $503  DATE CONVERSION TO YYYY-MM-DD FORMAT (ISO STANDARD)          *
*        IMPROVE SUPPORT FOR AR MODE                                  *
*  $504  SET &STRBLANKS TO 10 WHEN PROCESSING DATES                   *
***********************************************************************
         MACRO
&NAME    STRING &INTO=,&PRINT=NOGEN
         GBLC  &STRING_MACRO_VERSION
&STRING_MACRO_VERSION SETC '504'       current version
         AIF   ('&PRINT' EQ 'NOGEN').NOGEN
         PUSH  PRINT
         PRINT GEN
.NOGEN   GBLA  &$_LIT
         GBLB  &$_FEAT(16)             FEATURES
.*                                       1 LITERALS
.*                                       2 REGISTER (BIN)
.*                                       3 REGISTER (HEX)
.*                                       4 PACKED
.*                                       5 JDATE
.*                                       6 BINARY
.*                                       7 HEX
.*                                       8 NUMERIC
.*                                       9 LEFT JUST (NUMERIC)
.*                                       10 LEADING ZEROES
.*                                       11 TRUNCATE (CHAR STRING)
.*                                       12 %TIME
         GBLC  &$_LITS(9999)           LITERALS
         LCLA  &I,&J,&N
         AIF   (N'&SYSLIST EQ 1 AND '&SYSLIST(1)' EQ 'GENERATE'        X
               AND T'&INTO EQ 'O').GENL
         AIF   (N'&SYSLIST EQ 2 AND '&SYSLIST(1)' EQ 'GENERATE'        X
               AND '&SYSLIST(2)' EQ 'FULL' AND T'&INTO EQ 'O').GENL
         AIF   (N'&SYSLIST EQ 2 AND '&SYSLIST(1)' EQ 'GENERATE'        X
               AND '&SYSLIST(2)' EQ 'LOCTR' AND T'&INTO EQ 'O').GENL
         AIF   (N'&SYSLIST EQ 2 AND '&SYSLIST(1)' EQ 'GENERATE'        X
               AND '&SYSLIST(2)' EQ 'NOCSECT' AND T'&INTO EQ 'O').GENL
&LABEL   SETC  'IHB&SYSNDX'            STEM FOR LOCAL LABELS
&LQ      SETC  'L'''                   LENGTH ATTRIBUTE
&STR     SETC  '  R&STRING_MACRO_VERSION'
&NAME    BAS   R14,$STRING&STR         CALL @STRING SUB-ROUTINE
         AIF   (N'&SYSLIST EQ 0).ERR1  NO POSITIONAL OPERANDS, ERROR
         AIF   (T'&INTO EQ 'O').ERR2   NO RECEIVING FIELD, ERROR
         AIF   (N'&INTO GT 2).ERR2     INTO=(A,32,BLURB)
         DC    AL2(&LABEL.P-*)         OFFSET TO FIELD DESCRIPTORS
         AIF   (D'$LITERAL).LOCTR2     NOT FIRST TIME, JUMP
$LTORG   LOCTR                         ADDRESSABLE CONSTANTS
$FARRTNE LOCTR                         FAR ROUTINES
.LOCTR2  ANOP
$LITERAL LOCTR                         NON-ADDRESSABLE CONSTANTS
&TO1     SETC  '&INTO(1)'
&TO2     SETC  '&LQ&INTO'
         AIF   (N'&INTO EQ 1).PUNTO8            JUMP IF INTO=XXX
         AIF   ('&INTO(1)'(1,1) NE '(').PUNTO3  JUMP IF INTO=(XXX,44)
&TO1     SETC  '0&INTO(1)'                              INTO=((R3),44)
.PUNTO3  ANOP
&TO2     SETC  '&INTO(2)'                               INTO=(XXX,LL)
         AIF   ('&INTO(2)'(1,1) NE '(').PUNTO8  JUMP IF INTO=(XXX,44)
&TO2     SETC  '0&INTO(2)'                              INTO=(XXX,(R1))
.PUNTO8  ANOP
&LABEL.P DC    S(&TO1,&TO2)
.*--------------------------------------------------------------------*
.*-------      FIELDS       ------------------------------------------*
.*--------------------------------------------------------------------*
         LCLB  &LAST,&BIN,&HEX,&REG,&PACKED,&LEFT,&ZERO,&TRUNC
&I       SETA  1
.*LOOP
.LOOP1   ANOP
         AIF   (N'&SYSLIST(&I) GT 3).FLD990   TOO MANY SUB-OPERANDS
&LAST    SETB  (&I EQ N'&SYSLIST)                LOOP
         AIF   ('&SYSLIST(&I)'(1,1) EQ '''').LIT00
         AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) EQ '''').LIT01
.*--------------------------------------------------------------------*
.*       PROCESS FIRST SUBPARAMETER (ADDRESS)                         *
.*--------------------------------------------------------------------*
&P1S     SETC  '&SYSLIST(&I,1)'
&P2L     SETC  '0'                     INPUT LENGTH
&P3L     SETC  '0'                     OUTPUT LENGTH
         AIF   ('&SYSLIST(&I)'(1,1) GE '0').FLD180 SPACES
         AIF   ('&SYSLIST(&I)' EQ '%TIME').FLD190 %TIME
         AIF   ('&SYSLIST(&I,1)'(1,1) NE '(').FLD115 (R2)
         AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD250
&P1S     SETC  '0&SYSLIST(&I,1)'       CHANGE (R1) TO 0(R1)
.FLD115  ANOP
.*
.*       EXTRACT RBCDE FROM PRB.RBCDE (HLASM)
.*
&L       SETA  1
.*--LOOP
.FLD131  AIF   ('&P1S'(&L,1) EQ '.').FLD133
&L       SETA  &L+1
         AIF   (&L LT K'&P1S).FLD131
.*--ENDLOOP
&P2L     SETC  '&P1S'                    ABCDEF FROM ABCDEF
         AGO   .FLD134
.FLD133  ANOP
&P2L     SETC  '&P1S'(&L+1,K'&P1S-&L)    RBCDE FROM PRB.RBCDE
.FLD134  ANOP
.*
         AIF   (T'&SYSLIST(&I,2) NE 'O').FLD200
.*
         AIF   (NOT D'&P2L).FLD140
&P2C     SETC  T'&P2L
.*MNOTE *,'&P1 &P2C'
         AIF   ('&P2C' EQ 'F' OR '&P2C' EQ 'H' OR '&P2C' EQ 'P').FLD220
         AIF   ('&P2C' EQ 'G').FLD210  FL2
.FLD140  ANOP
.*
.*       EXTRACT PSATOLD FROM PSATOLD-PSA
.*
&L       SETA  1
.*--LOOP
.FLD141  AIF   ('&P2L'(&L,1) EQ '-').FLD143
         AIF   ('&P2L'(&L,1) EQ '+').FLD143
&L       SETA  &L+1
         AIF   (&L LT K'&P2L).FLD141
.*--ENDLOOP
&P2L     SETC  '&LQ&P2L'               L'ABCDEF
         AGO   .FLD300
.FLD143  ANOP
&P2L     SETC  '&LQ'.'&P2L'(1,&L-1)    L'PSATOLD FROM PSATOLD-PSA
         AGO   .FLD300
.*
.FLD180  AIF   ('&SYSLIST(&I)'(K'&SYSLIST(&I),1) NE 'X').FLD800
&P2L     SETC  '&SYSLIST(&I)'(1,K'&SYSLIST(&I)-1) 12
&J       SETA  X'4000'+&LAST*X'8000'
         DC    AL2(0,&P2L,&J)          BLANKS
&$_FEAT(1) SETB 1                      LITERAL
         AGO   .LIT99
.*
.FLD190  ANOP                          %TIME
&P1S     SETC  '1(14)'                 %TIME
&$_FEAT(12) SETB 1                     %TIME
         AGO   .FLD800
.*--------------------------------------------------------------------*
.*       PROCESS SECOND SUBPARAMETER (LENGTH/TYPE)                    *
.*--------------------------------------------------------------------*
.FLD200  AIF   (T'&SYSLIST(&I,2) EQ 'O').FLD300 NO LENGTH SPECIFIED
&P2C     SETC  '&SYSLIST(&I,2)'
         AGO   .FLD220
.*T'&P1=G
.FLD210  ANOP
&L       SETA  L'&SYSLIST(&I)          T'&P1 = 'G'
&P2C     SETC  'FL&L'                  T'&P1 = 'G'
.*
.FLD220  ANOP
&P2L     SETC  '0&P2C'                 (R2) LENGTH
         AIF   ('&P2C'(1,1) EQ '(').FLD300
&P2L     SETC  '&P2C'                  3(R2) LENGTH
         AIF   ('&P2C'(K'&P2C,1) EQ ')').FLD300
&P2L     SETC  '0'
&PACKED  SETB  ('&P2C' EQ 'P')
         AIF   (&PACKED).FLD300
&P2L     SETC  '1'
         AIF   ('&P2C' EQ 'FL1').FLD240
&P2L     SETC  '3'
         AIF   ('&P2C' EQ 'FL2' OR '&P2C' EQ 'H').FLD240
&P2L     SETC  '7'
         AIF   ('&P2C' EQ 'FL3').FLD240
&P2L     SETC  '15'
         AIF   ('&P2C' EQ 'F').FLD240
&P2L     SETC  '&P2C'                  IMMEDIATE LENGTH, FIELD
         AGO   .FLD300
.*
.FLD240  ANOP                          BINARY VARIABLE
&BIN     SETB  1
         AGO   .FLD300
.*
.FLD250  ANOP                          REGISTER CONTENT
&REG     SETB  1
.*--------------------------------------------------------------------*
.*       PROCESS THIRD SUBPARAMETER (OUTPUT FORMAT)                   *
.*--------------------------------------------------------------------*
.FLD300  AIF   (T'&SYSLIST(&I,3) EQ 'O').FLD800
&HEX     SETB  ('&SYSLIST(&I,3)' EQ 'X') HEXADECIMAL
&TRUNC   SETB  ('&SYSLIST(&I,3)' EQ 'T') TRUNCATE
         AIF   (&HEX OR &TRUNC).FLD800
.*
&P3C     SETC  '&SYSLIST(&I,3)'
&P3L     SETC  '248'
         AIF   ('&P3C' EQ 'YYYY-MM-DD' AND &PACKED).FLD308
&P3L     SETC  '249'
         AIF   ('&P3C' EQ 'YYYYMMDD' AND &PACKED).FLD308
&P3L     SETC  '250'
         AIF   ('&P3C' EQ 'YY/MM/DD' AND &PACKED).FLD308
&P3L     SETC  '251'
         AIF   ('&P3C' EQ 'DD/MM/YY' AND &PACKED).FLD308
&P3L     SETC  '252'
         AIF   ('&P3C' EQ 'MM/DD/YY' AND &PACKED).FLD308
&P3L     SETC  '253'
         AIF   ('&P3C' EQ 'YYMMDD'   AND &PACKED).FLD308
&P3L     SETC  '0'
         AIF   (T'&SYSLIST(&I,2) NE 'N').FLD310
         MNOTE 8,'EDIT PATTERN NOT ALLOWED WITH CHARACTER STRING'
         AGO   .FLD310
.FLD308  ANOP
&$_FEAT(5) SETB 1                      JDATE
         AGO   .FLD800
.*--LOOP
.FLD310  AIF   ('&P3C'(1,1) EQ 'R').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) EQ 'B').FLD318       DEFAULT
         AIF   ('&P3C'(1,1) NE 'L').FLD311
&LEFT    SETB  1
         AGO   .FLD318
.FLD311  AIF   ('&P3C'(1,1) NE 'Z').FLD312
&ZERO    SETB  1
         AGO   .FLD318
.FLD312  AIF   ('&P3C'(1,1) LT '0').FLD993
&P3L     SETC  '&P3L'.'&P3C'(1,1)
.FLD318  ANOP
.*MNOTE *,'&SYSLIST(&I) P3C=/&P3C/ P3L=/&P3L/'
&P3C     SETC  '&P3C'(2,K'&P3C-1)     STRIP OFF FIRST CHARACTER
         AIF   (K'&P3C GT 0).FLD310
.*--ENDLOOP
.*--------------------------------------------------------------------*
.FLD800  ANOP
&NUMERIC SETB  (&BIN OR &PACKED OR (&REG AND NOT &HEX))
&TRUNC   SETB  (&TRUNC OR (&LEFT AND NOT &NUMERIC))
&LEFT    SETB  (&LEFT AND &NUMERIC)
         AIF   (NOT &NUMERIC).FLD810
         AIF   (&LEFT OR '&P3L' NE '0').FLD810
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH ((R3))
         AIF   (&REG).FLD810
&P3L     SETC  '3'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'FL1').FLD810
&P3L     SETC  '5'                     DEFAULT OUTPUT LENGTH
         AIF   ('&P2C' EQ 'H' OR '&P2C' EQ 'FL2').FLD810
&P3L     SETC  '7'                     DEFAULT OUTPUT LENGTH
.FLD810  ANOP
&FLAG    SETA  &LAST*128+&HEX*8+&BIN*4+&PACKED*2+&REG*1
&LEN2    SETA  &TRUNC*128+&LEFT*128+&ZERO*64+&P3L
         DC    S(&P1S,&P2L),AL1(&FLAG,&LEN2)
&$_FEAT(2) SETB (&$_FEAT(2) OR (&REG AND NOT &HEX))   REGISTER (BIN)
&$_FEAT(3) SETB (&$_FEAT(3) OR (&REG AND &HEX))       REGISTER (HEX)
&$_FEAT(4) SETB (&$_FEAT(4) OR &PACKED)               PACKED
&$_FEAT(6) SETB (&$_FEAT(6) OR &BIN)                  BINARY
&$_FEAT(7) SETB (&$_FEAT(7) OR (&HEX AND NOT &REG))   HEX
&$_FEAT(8) SETB (&$_FEAT(8) OR &NUMERIC)              BIN,PACKED
&$_FEAT(9) SETB (&$_FEAT(9) OR (&LEFT AND &NUMERIC))
&$_FEAT(10) SETB (&$_FEAT(10) OR &ZERO)
&$_FEAT(11) SETB (&$_FEAT(11) OR &TRUNC)
&BIN     SETB  0                    RESET FLAGS
&HEX     SETB  0                    RESET FLAGS
&REG     SETB  0                    RESET FLAGS
&PACKED  SETB  0                    RESET FLAGS
&LEFT    SETB  0                    RESET FLAGS
&ZERO    SETB  0                    RESET FLAGS
&TRUNC   SETB  0                    RESET FLAGS
         AGO   .LIT99
.FLD990  MNOTE 12,'OPERAND &I HAS TOO MANY SUB-OPERANDS'
         AGO   .LIT99
.FLD993  MNOTE 8,'THIRD SUBPARAMETER IS INVALID: ''&SYSLIST(&I,3)'''
         AGO   .LIT99
.*--------------------------------------------------------------------*
.*------------ LITERALS ----------------------------------------------*
.*--------------------------------------------------------------------*
.LIT00   ANOP
&LIT     SETC  'C&SYSLIST(&I)'
         AGO   .LIT09
.LIT01   ANOP
&LIT     SETC  '&SYSLIST(&I)'
.LIT09   AIF   (&$_LIT EQ 0).LIT50
&N       SETA  1
         ACTR  &$_LIT*3+200
.LIT10   AIF   (&N GT &$_LIT).LIT50                  LOOP
&L       SETA  &N+1000                               LOOP
         AIF   ('&LIT' EQ '&$_LITS(&N)').LIT80 LOOP
&N       SETA  &N+1                                  LOOP
         AGO   .LIT10                                LOOP
.LIT50   ANOP
&$_LIT   SETA  &$_LIT+1
&$_LITS(&$_LIT) SETC '&LIT'
&L       SETA  &$_LIT+1000
.LIT80   ANOP
&J       SETA  X'4000'+&LAST*X'8000'
         DC    AL2($LIT&L-*,&LQ.$LIT&L,&J)
&$_FEAT(1) SETB 1                      LITERAL
.LIT99   ANOP
.*--------------------------------------------------------------------*
&I       SETA  1+&I                              LOOP
         AIF   (&I LE N'&SYSLIST).LOOP1          LOOP
.*ENDLOOP
&SYSLOC  LOCTR
         AGO   .MEND
.ERR1    MNOTE 12,'AT LEAST ONE INPUT FIELD MUST BE SPECIFIED'
         AGO   .MEND
.ERR2    MNOTE 12,'INVALID OUTPUT AREA SPECIFICATION'
         AGO   .MEND
.**********************************************************************
.*       GENERATE: GENERATE LITERALS AND PROCESSING ROUTINE           *
.**********************************************************************
.GENL    ANOP
&STRBLANKS SETA 2
         AIF   ('&SYSLIST(2)' NE 'FULL').GENL1F
&$_FEAT(1) SETB 1,1,1,1,1,1,1,1,1,1,1,1
.GENL1F  ANOP
&ALLFEAT SETC  '&$_FEAT(1)&$_FEAT(2)&$_FEAT(3)&$_FEAT(4)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(5)&$_FEAT(7)&$_FEAT(6)&$_FEAT(8)'
&ALLFEAT SETC  '&ALLFEAT&$_FEAT(9)&$_FEAT(10)&$_FEAT(11)&$_FEAT(12)'
&STR     SETC  '&STRING_MACRO_VERSION'
         MNOTE *,'STRING/ESA R&STR - FEATURES GENERATED: &ALLFEAT'
         AIF   (&$_LIT EQ 0).GENL3
$LITERAL LOCTR
.GENL2   ANOP                                LOOP
&N       SETA  &N+1                          LOOP
&I       SETA  &N+1000                       LOOP
$LIT&I   DC    &$_LITS(&N)
         AIF   (&N LT &$_LIT).GENL2          LOOP
.GENL3   ANOP
         AIF   ('&SYSLIST(2)' EQ 'NOCSECT').GENL8
.**********************************************************************
.*                                                                    *
.*       STRING SUB-ROUTINE                                           *
.*                                                                    *
.*             CAUTION: BYTES 49-72 OF THE CALLER'S SAVE AREA         *
.*                      (R7-R12 SLOTS) ARE USED AS WORK SPACE         *
.*                                                                    *
.**********************************************************************
         AIF   ('&SYSLIST(2)' EQ 'LOCTR').GENL4L
@STRING  CSECT
@STRING  RMODE ANY
         AGO   .GENL4X
.GENL4L  PUSH  USING                   GENERATE,LOCTR
         DROP
@STRING@ LOCTR
@STRING  DS    0H                      ALIGNMENT
.GENL4X  ANOP
@00      EQU   0                       WORK REGISTER
@01      EQU   1                       WORK REGISTER
@02      EQU   2                       WORK REGISTER
@03      EQU   3                       WORK REGISTER
@04      EQU   4                       WORK REGISTER
@05      EQU   5                       WORK REGISTER
@06      EQU   6                       WORK REGISTER
@07      EQU   7                       WORK REGISTER
@08      EQU   8                       WORK REGISTER
@09      EQU   9                       WORK REGISTER
@10      EQU   10                      WORK REGISTER
@11      EQU   11                      WORK REGISTER
@12      EQU   12                      WORK REGISTER
@13      EQU   13                      CALLER'S SAVE AREA
@14      EQU   14                      WORK REGISTER
@15      EQU   15                      BASE REG
         USING @STRING,@15
         USING @STRSAVE,@13
         B     @STR003                 BRANCH AROUND EYE-CATCHER
         DC    C'@STRING R&STRING_MACRO_VERSION &ALLFEAT',0H'0'
@STR002  DC    H'2'
@STR003  STM   @14,R12,12(@13)         SAVE REGS (DEBUGGING ONLY)
         AH    @14,@STR002-@STRING(@15) POINT PARM PARM-LIST OFFSET
         BAKR  @14,0                   SAVE REGS AND RETURN ADDRESS
         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET
         BCTR  @14,0                   ADJUST ADDR OF PARM LIST OFFSET
         LAE   @06,0                   R6=0 AR6=0
         CPYA  @14,@06                 AR14=0
         CPYA  @15,@06                 AR15=0
         ICM   @06,B'0011',0(@14)      PICK UP PARM-LIST OFFSET
         ALR   @06,@14                 R6 NOW POINTS TO PARM LIST
         USING @STRPARM,@06
         LAE   @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         BAL   @14,@STRS2A             GET ADDRESS IN R2
         LAE   @04,0(,@02)             KEEP ADDRESS OF "INTO" FIELD
         EREG  @14,@14                 RESTORE ADDR OF STRING MACRO
         OI    0(@04),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         LAE   @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         BAL   @14,@STRS2A             GET LENGTH IN R2
         LR    @05,@02                 KEEP LENGTH OF "INTO" FIELD
         CR    @05,@04                 END ADDRESS?
         BL    @STR282                 NO, JUMP
         SR    @05,@04                 CALCULATE LENGTH
@STR282  MSTA  @04                     SAVE R4,R5 ON LINKAGE STACK
.*SLAC   DC    X'B247,0040'            SLAC assembler error
.**********************************************************************
.*       MOVE FIELDS TO OUTPUT AREA                                   *
.**********************************************************************
         LAE   @06,@STRFLAG            POINT TO 1ST FIELD DESC
.*LOOP
@STR310  EQU   *
         AIF   (NOT &$_FEAT(1)).FEAT1A
         TM    @STRFLAG,@STRLIT        IS THIS A LITERAL?
         BO    @STR372                 YES, JUMP
.FEAT1A  ANOP
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23A
         TM    @STRFLAG,@STRREG        REGISTER?
         BO    @STR323                 YES, JUMP
.FEAT23A ANOP
         AIF   (NOT &$_FEAT(12)).FEAT12A
         CLI   @STRSCON,X'E0'          IS IT %TIME ?
         BE    @STR378                 YES, JUMP
.FEAT12A ANOP
.*
.*       IT'S A FIELD (SCON)
.*
         LAE   @02,@STRFLEN            RESOLVE SECOND S-CON (LEN)
         BAL   @14,@STRS2A             GET LENGTH IN R2
         AIF   (&$_FEAT(9)).FEAT9E1    (LEFT JUSTIFICATION, NUMERIC)
         LTR   @03,@02                 KEEP/TEST LENGTH
         BZ    @STR398                 ZERO LENGTH, DO NOT EDIT
         AGO   .FEAT9E2
.FEAT9E1 LTR   @03,@02                 KEEP/TEST LENGTH
         BP    @STR313                 LENGTH POSITIVE, JUMP
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         BNO   @STR398                 NO, ZERO LENGTH IS NOT OK
@STR313  EQU   *
.FEAT9E2 ANOP
         LAE   @02,@STRSCON            RESOLVE FIRST SCON (ADDR)
         BAL   @14,@STRS2A             GET ADDRESS IN R2
         EREG  @14,@14                 RESTORE ADDR OF STRING MACRO
         CLI   0(@02),0                GET CLEAN S0C4 IF ADDRESS IS BAD
         CR    @03,@02                 END ADDRESS?
         BL    @STR314                 NO, JUMP
         LA    @00,X'0080'             PSA ADDRESS
         CLR   @02,@00                 PSA REFERENCE?
         BL    @STR314                 YES, JUMP
         SR    @03,@02                 CALCULATE LENGTH
@STR314  EQU   *
         AIF   (NOT &$_FEAT(6)).FEAT6A
         TM    @STRFLAG,@STRBIN        BINARY FIELD?
         BO    @STR328                 YES, JUMP
.FEAT6A  ANOP
         AIF   (NOT &$_FEAT(4)).FEAT4A
         TM    @STRFLAG,@STRPACK       PACKED FIELD?
         BO    @STR351                 YES, JUMP
.FEAT4A  ANOP
         AIF   (NOT &$_FEAT(7)).FEAT7A
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         BO    @STR376                 YES, JUMP
.FEAT7A  ANOP
.*
.*       TRUNCATE CHARACTER STRING
.*
         AIF   (NOT &$_FEAT(11)).FEAT11A
         CLI   @STRLEN2,@STRLEFT       CHECK JUSTIFICATION, OUTPUT LEN
         BNE   @STR390                 NO STRING TRUNCATION, JUMP
         LAE   @01,0(@03,@02)          FIRST BYTE AFTER FIELD
@STR318  BCTR  @01,0                   DOWN 1 BYTE                 LOOP
         CLI   0(@01),C' '             IS IT A SPACE ?             LOOP
         BNE   @STR390                 LAST NON-BLANK BYTE         LOOP
         BCT   @03,@STR318             LOOP UNTIL 1ST NON-BLANK    LOOP
         B     @STR398                 BLANK FIELD, DO NOT EDIT
         AGO   .FEAT11B
.FEAT11A ANOP
         AIF (&$_FEAT(2)+&$_FEAT(3)+&$_FEAT(4)+&$_FEAT(6) EQ 0).FEAT11B
         B     @STR390                 EDIT
.FEAT11B ANOP
.*
.*       REGISTER (R0-R13)
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(3)).FEAT23B
@STR323  LH    @01,@STRSCON            REG NUMBER IN BITS 28-31
         CLI   @STRSCON+1,@06          IS THIS R7-R13?
         BH    @STR323R                YES, JUMP
         LR    @07,@01                 SAVE R1 (R)
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREG  @00,@06                 RELOAD CALLER'S R0-R6
         EX    @07,@STR323L            COPY R0-R6 VALUE
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         B     @STR323T
@STR323L LR    @00,*-*                 COPY VALUE FOR EDIT
@STR323R EQU   *
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    @01,@STR323L            COPY R7-R13 INTO R0
@STR323T EQU   *
         AIF   (NOT &$_FEAT(3)).FEAT3R REG,HEX
         AIF   (NOT &$_FEAT(2)).FEAT2H REG,BIN
         TM    @STRFLAG,@STRHEX        EDIT IN HEX?
         BNO   @STR330                 NO, EDIT FWD
.FEAT2H  ANOP
         STCM  @00,B'1111',@STRDWD-1   STORE IT FOR CVD/UNPK
         LA    @03,8                   OUTPUT LENGTH
         B     @STR376X                EDIT IN HEX
.FEAT3R  ANOP
         AIF   (NOT &$_FEAT(6)).FEAT23B
         B     @STR330                 EDIT R0
.FEAT23B ANOP
.*
.*       BINARY VARIABLE: @03 CONTAINS THE ICM MASK (1 3 7 F)
.*
         AIF   (NOT &$_FEAT(6)).FEAT6B
@STR328M ICM   @00,*-*,0(@02)          **EXECUTED INSTRUCTION**
@STR328  SLR   @00,@00
         EX    @03,@STR328M            LOAD THE BINARY VARIABLE
.FEAT6B  ANOP
.*
         AIF   (NOT &$_FEAT(2) AND NOT &$_FEAT(6)).FEAT6C
@STR330  CVD   @00,@STRDWD             CONVERT VALUE TO DECIMAL
         AIF   (NOT &$_FEAT(4)).FEAT6C
         B     @STR361                 EDIT DWD
.FEAT6C  ANOP
.*
.*       PACKED FIELD
.*
         AIF   (NOT &$_FEAT(4)).FEAT4B
@STRZAP  ZAP   @STRDWD,0(*-*,@02)      MOVE TO @STRDWD
@STR351  LAE   @03,0(,@02)             FIRST BYTE OF PACKED FIELD
         BALR  @14,0
         TM    0(@03),X'0C'            IS THIS THE SIGN BYTE?
         LA    @03,1(,@03)              (NEXT BYTE)
         BNOR  @14                     NO, LOOP MORE
         SLR   @03,@02                 GET LENGTH OF PACKED FIELD
         BCTR  @03,0
         EX    @03,@STRZAP             EXECUTE ZAP
         AIF   (NOT &$_FEAT(5)).FEAT4B
         CLI   @STRLEN2,248            JULIAN-TO-YYMMDD CONV?
         BNL   @STR375                 YES, JUMP
.FEAT4B  ANOP                          PACKED
.*
.*       EDIT @STRDWD (BIN, REG, PACKED)
.*
         AIF   (NOT &$_FEAT(8)).FEAT8B
@STR361  IC    @00,@STRLEN2            OUTPUT LENGTH
         LA    @03,X'003F'             MASK FOR "AND"
         NR    @03,@00                 OUTPUT LENGTH
         MVC   @STRWK16(16),@STRMASK   EDIT MASK
.*
.*       LEFT-JUSTIFICATION (NUMERIC)
.*
         AIF   (NOT &$_FEAT(9)).FEAT9B
         TM    @STRLEN2,@STRLEFT       LEFT JUSTIFICATION?
         BNO   @STR367                 NO, JUMP
         LAE   @01,@STRWK16+15         PREVENT BAD R1
         EDMK  @STRWK16(16),@STRDWD    ZONED DECIMAL
         LAE   @02,0(,@01)             FIRST STRING POSITION
         LTR   @03,@03                 CHECK OUTPUT LENGTH
         BNZ   @STR363                 JUMP IF NOT ZERO
.*       L0    (LEFT JUSTIFIED, NO PADDING)
         LAE   @03,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @03,@02                 COMPUTE STRING LENGTH
         B     @STR390                 MOVE FIELD TO OUTPUT LINE
.*       L1-L63 (LEFT JUSTIFIED, PADDING)
@STR363  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN
         BNH   @STR364                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR364  SR    @05,@03                 COMPUTE REMAINING LENGTH
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 LENGTH WITH PADDING
         LA    @03,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @03,@02                 COMPUTE STRING LENGTH
         B     @STR392                 MOVE FIELD TO OUTPUT LINE
@STR367  EQU   *
.FEAT9B  ANOP
         AIF   (NOT &$_FEAT(10)).FEAT10B
         TM    @STRLEN2,@STRZERO       LEADING ZEROES REQ'D?
         BNO   @STR368                 NO, JUMP
         MVI   @STRWK16,C'0'           YES, CHANGE X'40' TO C'0'
@STR368  EQU   *
.FEAT10B ANOP
         ED    @STRWK16(16),@STRDWD    ZONED DECIMAL
         LAE   @02,@STRWK16+16         FIRST POSITION AFTER STRING
         SR    @02,@03                 FIRST STRING POSITION
.FEAT8B  ANOP
.*
.*       LITERAL (@STRSCON IS A 16-BIT OFFSET)
.*       BLANKS  (@STRSCON=ZERO)
.*
         AIF   (NOT &$_FEAT(1)).FEAT1B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR372  SLR   @02,@02
         SAR   @02,@02                 AR2=0
         ICM   @02,B'0011',@STRSCON    LOAD LITERAL OFFSET
         BZ    @STR372L                BLANKS, JUMP
         LAE   @02,@STRSCON(@02)       CONVERT OFFSET TO FULL ADDRESS
@STR372L LH    @03,@STRFLEN            GET LITERAL LENGTH
.FEAT1B  ANOP
.*
.*       CONVERT JULIAN DATE TO YYMMDD
.*
         AIF   (NOT &$_FEAT(5)).FEAT5F
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR375  LA    @00,248                 MASK FOR 'SLR'
         SLR   @01,@01
         IC    @01,@STRLEN2            248-255
         SLR   @01,@00                 000-007
         LA    @00,12                  L'@STR375W
         MR    @00,@00                 COMPUTE OFFSET
         LAE   @01,@STR375W(@01)       ENTRY IN "TR" MASK TABLE
         SLR   @03,@03
         IC    @03,0(,@01)             LENGTH OF DATE (6, 8 OR 10)
         ZAP   @STRDWD,@STRDWD         DATE=0000000?               @JDT
         BNZ   @STR375B                NO, JUMP                    @JDT
@STR375Z LAE   @02,@STRBLANKS          WORK AREA
&STRBLANKS SETA 10                     WE NEED AT LEAST 10 BLANKS
         B     @STR390                 MOVE FIELD TO OUTPUT LINE
@STR375W DC    AL1(10,C'-',0,1,2,3,8,4,5,8,6,7) YYYY-MM-DD   248
         DC    AL1(8,C' ',0,1,2,3,4,5,6,7,8,8)  YYYYMMDD//   249
         DC    AL1(8,C'/',2,3,8,4,5,8,6,7,8,8)  YY/MM/DD//   250
         DC    AL1(8,C'/',6,7,8,4,5,8,2,3,8,8)  DD/MM/YY//   251
         DC    AL1(8,C'/',4,5,8,6,7,8,2,3,8,8)  MM/DD/YY//   252
         DC    AL1(6,C' ',2,3,4,5,6,7,8,8,8,8)  YYMMDD       253
.*       DC    AL1(6,C' ',6,7,4,5,2,3,8,8,8,8)  DDMMYY       254
.*       DC    AL1(6,C' ',4,5,6,7,2,3,8,8,8,8)  MMDDYY       255
@STR375T DC    P'59,31,29,31,30,31,30,31,31,30,31,30,31'
@STR375B CLI   @STRDWD+4,X'01'         YEAR 2000 OR ABOVE?
         BH    @STR375C                CC>01, JUMP (MUST BE 19 OR 20)
         MVI   @STRDWD+4,X'20'         CC=01, CHANGE TO CC=20
         BE    @STR375C                CC=01, USE CC=20
         CLI   @STRDWD+4+1,X'50'       YY<50?
         BL    @STR375C                YES, USE CC=20
         MVI   @STRDWD+4,X'19'         NO, FORCE CC=19
@STR375C UNPK  @STRWK16(5),@STRDWD+4(3) CCYY?
         ZAP   @STRDWD+1(2),@STR375T+9(1) INIT MONTH COUNTER
         LAE   @02,@STR375T            TABLE OF MONTHS (NUMBER OF DAYS)
         TM    @STRDWD+4+1,X'01'       ODD YEARS
         BO    @STR375N                  AREN'T LEAP YEARS
         TM    @STRDWD+4+1,X'12'       ZEROES IN 1980, ALL ONES IN 1992
         BNM   @STR375L                MIXED IN 1982/1990
.*       IF IT'S NOT A LEAP YEAR AND DDD>59, THEN ADD 1 TO DDD
@STR375N CP    @STRDWD+4+2(2),@STR375T ARE WE PAST FEB 28 (DDD>59) ?
         BNH   @STR375L                NO, JUMP
         AP    @STRDWD+4+2(2),@STR375T+3(1) ADD 1 (FROM 31) TO DDD
.*--LOOP WHILE DDD > 0
@STR375L AP    @STRDWD+1(2),@STR375T+3(1)   ADD 1 (FROM 31) TO MONTH
         LA    @02,2(,@02)             NEXT ENTRY IN "MONTHS" TABLE
         SP    @STRDWD+4+2(2),0(2,@02) SUB DAYS-IN-MONTH FROM DDD
         BP    @STR375L
.*--ENDLOOP
         AP    @STRDWD+4+2(2),0(2,@02) UNDO LAST "SP" INSTRUCTION
         UNPK  @STRWK16+4(2),@STRDWD+1(2) FYFYFYFY,FMCM??
         UNPK  @STRWK16+6(2),@STRDWD+6(2) FYFYFYFY,FMCMFDCD
         MVZ   @STRWK16+1(7),@STRWK16     FYFYFYFY,FMCMFDCD
         MVC   @STRWK16+8(1),1(@01)    SEPARATOR
         LAE   @02,@STRWK16+9          WORK AREA
         MVC   0(10,@02),2(@01)        MOVE CORRESPONDING MASK
         TR    0(10,@02),@STRWK16      CONVERT DATE TO THE RIGHT FORMAT
.FEAT5F  ANOP                          JDATE
.*
.*       HEX STRING
.*
         AIF   (NOT &$_FEAT(7)).FEAT7B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STR376M MVC   @STRDWD-1(*-*),0(@02)   PREVENT S0C4 IN UNPK
@STR376  LA    @00,8                   MAX LENGTH
         CLR   @03,@00                 CHECK LENGTH
         BNH   @STR376B                JUMP IF LE 8
         LR    @03,@00                 TRUNCATE TO MAXIMUM LENGTH
@STR376B LR    @01,@03                 INPUT LENGTH
         BCTR  @01,0
         EX    @01,@STR376M            MOVE DATA TO SAFE STORAGE
         ALR   @03,@03                 OUTPUT LENGTH
         AGO   .FEAT37B
.FEAT7B  ANOP
         AIF   (NOT &$_FEAT(3)).FEAT37C
         B     @STR390                 MOVE STRING TO OUTPUT LINE
.FEAT37B ANOP
@STR376X LAE   @02,@STRWK16            WORK AREA
         UNPK  0(9,@02),@STRDWD-1(5)   EXPAND SOURCE BYTES FOR "TR"
         UNPK  8(9,@02),@STRDWD+3(5)   EXPAND SOURCE BYTES FOR "TR"
         TR    0(16,@02),@STRHEXT-240  =C'0123456789ABCDEF'
.FEAT37C ANOP
.*
.*       %TIME
.*
         AIF   (NOT &$_FEAT(12)).FEAT12B
         B     @STR390                 MOVE STRING TO OUTPUT LINE
@STRTIME DC    X'4021207A20207A20207A20204000'    0X.XX.XX.XX
@STR378  TIME  DEC                     GET HHMMSSHH
         EREG  @14,@15                 RESTORE BASE REG
         CPYA  @15,@06                 AR15=0
         ST    @00,@STRDWD             STORE HHMMSSHH
         MVC   @STRWK16(13),@STRTIME   MOVE EDIT MASK
         ED    @STRWK16(13),@STRDWD    EDIT HH:MM:SS:HH
         LAE   @02,@STRWK16+1          WORK AREA
         LA    @03,12                  HH:MM:SS:HH+ SPACE
.FEAT12B ANOP
.*MOVE
@STR390  CR    @03,@05                 COMPARE LENGTH TO REMAINING LEN
         BNH   @STR391                 LARGE ENOUGH, JUMP
         LR    @03,@05                 TOO BIG, TRUNCATE TO REM. LEN.
@STR391  SR    @05,@03                 COMPUTE REMAINING LENGTH
         LAE   @08,0(,@04)             POINTER IN OUTPUT LINE
         LR    @09,@03                 PASS REMAINING LENGTH
         LTR   @02,@02                 BLANKS?
         BNZ   @STR392                 NO, JUMP
         SLR   @03,@03                 YES, ZERO LENGTH
@STR392  ICM   @03,B'1000',@STRBLANKS  PAD WITH BLANKS
         MVCL  @08,@02                 MOVE FIELD TO OUTPUT LINE
         LR    @04,@08                 NEW POINTER IN OUTPUT LINE
@STR398  TM    @STRFLAG,@STRLAST       TEST LAST-ENTRY INDICATOR
         LA    @06,@STRNEXT            BUMP UP TO NEXT ENTRY
         BNO   @STR310                 PROCESS NEXT ENTRY
.*ENDLOOP
.*
.*       END-OF-LINE PROCESSING - PAD WITH BLANKS
.*
         SLR   @01,@01                 SET UP R1 FOR PADDING
         ICM   @01,B'1000',@STRBLANKS  SET UP R1 FOR PADDING
.***     DROP  @06,@13,@15
         LA    @15,3                   MODIFIABLE AREA
         ESTA  @14,@15                 R14 = START OF OUTPUT AREA
         LR    @15,@04                 END OF OUTPUT AREA
         SR    @15,@14                 R15 = LENGTH USED IN OUTPUT AREA
         MVCL  @04,@00                 PAD WITH BLANKS
         EREG  @00,@14                 RESTORE WORK REGISTERS
         STM   @14,@12,12(@13)         MAKE SAVE AREA LOOK NORMAL
         OI    15(@13),1               SIMULATE "T" OPTION OF RETURN
         PR                            RETURN TO CALLER
.*
         AIF   (NOT (&$_FEAT(3) OR &$_FEAT(7))).FEAT37T
@STRHEXT DC    C'0123456789ABCDEF'     HEX-TO-EBCDIC CONVERSION
.FEAT37T ANOP
         AIF   (NOT &$_FEAT(8)).FEAT8T
@STRMASK DC    X'4020202020202020,2020202020202120'
.FEAT8T  ANOP
.**********************************************************************
.*       CONVERT S-CON TO 31-BIT ADDRESS (RESULT RETURNED IN R2)      *
.**********************************************************************
@STRS2A  SLR   @00,@00
         ICM   @00,B'0011',0(@02)      R0 = 0000BDDD
         SRDL  @00,12                  R0 = 0000000B, R1= DDD.....
         SRL   @01,20                  R1 = 00000DDD (DISPLACEMENT)
         SLL   @00,2                   MULT BY 4
         CLI   0(@02),@07*16           R7-R13?
         BNL   @STRS2A7                YES, JUMP
.*BASE REG IS R0-R6
@STRS2A4 LTR   @02,@00                 IS R0 THE BASE REG?
         BNZ   @STRS2A5                NO, JUMP
         LTR   @02,@01                 IS THIS A PSA ADDRESS?
         BNZR  @14                     YES, GOBACK
         EREG  @00,@00                 POP R0
         SAR   @02,@02                 AR2=0
         LR    @02,@00                 PASS R0 VALUE
         LA    @02,0(,@02)             CLEAN UP
         BR    @14                     GOBACK
@STRS2A5 LR    @07,@00                 SAVE R0 (B*4)
         LR    @08,@01                 SAVE R1 (DDD)
         LR    @09,@03                 SAVE R3
         LAE   @10,0(,@04)             SAVE R4
         LR    @11,@05                 SAVE R5
         LAE   @12,0(,@06)             SAVE R6
         EREG  @01,@06                 RELOAD CALLER'S R1-R6
         EX    0,@STRS2A9-4(@07)       ADD BASE REG VALUE TO DISPL
         LR    @03,@09                 RESTORE R3
         LAE   @04,0(,@10)             RESTORE R4
         LR    @05,@11                 RESTORE R5
         LAE   @06,0(,@12)             RESTORE R6
         BR    @14                     GOBACK
.*BASE REG IS R7-R13
@STRS2A7 LR    @02,@00                 R2= 0000000B (BASE REG NUMBER)
         EREG  @07,@12                 RESTORE CALLER'S R7-R12
         EX    0,@STRS2A9-4(@02)       ADD BASE REG VALUE TO DISPL
         BR    R14                     GOBACK
@STRS2A9 LAE   @02,0(@08,@01)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@02)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@03)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@04)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@05)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@08,@06)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@07)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@08)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@09)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@10)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@11)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@12)          ADD BASE REG VALUE TO DISPL
         LAE   @02,0(@01,@13)          ADD BASE REG VALUE TO DISPL
&STR     SETC  '&STRBLANKS'
         AIF   ('&SYSLIST(2)' EQ 'LOCTR').GENL7L
@STRBLANKS DC  CL((((*+&STRBLANKS+7-@STRING)/8)*8)-(*-@STRING))' '
         AGO   .GENL7X
.GENL7L  ANOP
@STRBLANKS DC  CL&STRBLANKS.' '
.GENL7X  ANOP
@STRING_SIZE EQU *-@STRING             SIZE OF GENERATED CSECT
.**********************************************************************
.*       WORK AREA (CALLER'S SAVE AREA)                               *
.**********************************************************************
@STRSAVE DSECT                         24-BYTE WORK AREA
         DS    A(0,@STRSAVE,@STRSAVE,14,15,0,1,2,3,4,5,6)
@STRWK16 DS    F'7,8,9,10'             WORK AREA
@STRDWD  DS    D'1112'                 WORK AREA
@STRPARM DSECT
@STRSCON DS    S                   +0  FIELD ADDRESS
@STRFLEN DS    S                   +2  FIELD LENGTH
@STRFLAG DS    B                   +4  FORMAT, FLAGS
@STRLAST EQU   X'80'                     LAST ENTRY
@STRLIT  EQU   X'40'                     LITERAL, @STRSCON IS AN OFFSET
@STRJDT  EQU   X'20'                     JULIAN DATE
.*             X'3F'                   CONVERSION REQUIRED
@STRHEX  EQU   X'08'                     HEXADECIMAL
@STRBIN  EQU   X'04'                     BINARY
@STRPACK EQU   X'02'                     PACKED
@STRREG  EQU   X'01'                     REGISTER
@STRLEN2 DS    B                   +5  FORMAT, OUTPUT LENGTH
@STRLEFT EQU   X'80'                     LEFT JUSTIFICATION
@STRZERO EQU   X'40'                     LEADING ZEROES
.*             X'3F'                     OUTPUT LENGTH, 0 MEANS TRUNC.
@STRNEXT EQU   *                   +6
$LTORG   LOCTR
         AIF   ('&SYSLIST(2)' EQ 'LOCTR').GENL9L
         CNOP  0,4
$STRING  BALR  @15,0                   LOCAL BASE
         L     @15,6(@15,0)            ROUTINE ADDRESS           00
         BR    @15                     GO TO @STRING             04
         AGO   .GENL9
.GENL8   ANOP                          GENERATE,NOCSECT
$LTORG   LOCTR
         CNOP  0,4
$STRING  BALR  R15,0                   LOCAL BASE
         L     R15,6(R15,0)            ROUTINE ADDRESS           00
         BR    R15                     GO TO @STRING             04
.GENL9   ANOP
         DC    V(@STRING)              ROUTINE ADDRESS           06
         AGO   .MEND
.GENL9L  POP   USING                   GENERATE,LOCTR
$STRING  BAL   R15,=X'4AFF,0000,07FF'
         DC    Y(@STRING-*)            OFFSET TO @STRING ROUTINE
.MEND    AIF   ('&PRINT' EQ 'NOGEN').MEND99
         POP   PRINT
.MEND99  MEND
         EJECT
**********************************************************************
**********************************************************************
********* TEST PROGRAM FOR THE 'STRING' MACRO ************************
**********************************************************************
**********************************************************************
TESTPGM  START X'027000'
         BALR  R12,0
         USING *,R12
*-DEL- EP=SYSDEBUG
*-DEL- R15,R0
*-DEL- R14,R15
*STRING 1X,INTO=XXX
         OPEN  (SYSPRINT,OUTPUT)
RBPREFIX EQU   *
RBINTCOD EQU   *+6,2,C'H'
ASCBASID EQU   *+8,2,C'X'
         L     R1,PSATOLD-PSA
         L     R1,0(,R1)               TCBRBP
         STRING 'SVC',(RBINTCOD-RBPREFIX(R1),H,R3Z),                   X
               1X,(WWWW,,T),' - ',     VV.MM OF SVC RTNE               X
               ((R8),,X),1X,           COM-REG ADDR                    X
               (ASCBASID,,X),1X,       ASID                            X
               PARM1,1X,               MAIN PGM NAME                   X
               INTO=XXX
         PUT   SYSPRINT,XXX
*
         LA    R2,XXX
         STRING 1X,INTO=((R2),8)
         MACRO                                       JDATE MACRO
        @JDATE &DATE                                 JDATE MACRO
         LA    R1,=P'&DATE'                          JDATE MACRO
*** STRING ((R1),P),2X,((R1),P),INTO=XXX
         STRING ((R1),P),2X,((R1),P,YYMMDD),INTO=XXX,                  X
               3X,((R1),P,YY/MM/DD),                                   X
               3X,((R1),P,DD/MM/YY),                                   X
               3X,((R1),P,MM/DD/YY),                                   X
               3X,((R1),P,YYYYMMDD),                                   X
               3X,((R1),P,YYYY-MM-DD)
         PUT   SYSPRINT,XXX                          JDATE MACRO
         MEND                                        JDATE MACRO
        @JDATE 90058
        @JDATE 91059
        @JDATE 93060
        @JDATE 94365
        @JDATE 80058
        @JDATE 84059
        @JDATE 88060
        @JDATE 92061
        @JDATE 00366
         LA    R2,1234
         STRING 'CVTPTR=X''',(CVTPTR,4,X),'''',INTO=XXX,               X
               ' 1234=',((R2),,R4Z)
         PUT   SYSPRINT,XXX
         L     R1,CVTPTR
         STRING 'CVTDATE=',(56(R1),P,YYMMDD),INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R0,1000
         LA    R3,0033
         STRING 'D1=/',D1,'/,WWWW=/',WWWW,'/',                         X
               ((R3),,L),'/',((R3),,X),'/',((R0),,L),'/',              X
               ((R3),,R9B),'/',INTO=XXX
         LR    R4,R15                   LENGTH USED
         PUT   SYSPRINT,XXX
         STRING WWWW,                                                  X
               (4(R13),4,X),'''',(4(R13),F),'''',                      X
               (4(R13),F,L),'''',                                      X
               (4(R13),F,L11),'''',                                    X
               (4(R13),F,Z9),'''',                                     X
               8X,'R4=',((R4),,L),      LENGTH USED                    X
               INTO=XXX
         PUT   SYSPRINT,XXX
         STRING %TIME,D1,'B12345678B',5X,(CTR1,P),1X,PARM1,1X,PARM2,   X
               INTO=XXX
         PUT   SYSPRINT,XXX
         LA    R3,22
         STRING INTO=XXX,'CCC1234A',(D1,(R3)),'.',(CTR1,P,R7Z)
         PUT   SYSPRINT,XXX
         STRING C'DDN2(',(D1,,T),')',X'40C1C2C3C4',                    +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
         AIF   ('&SYSPARM' NE 'HLASM').HLASM99
PSABASE  USING PSA,R0
         STRING 'PSATOLD=',(PSABASE.PSATOLD,,X),                       +
               ' PSATOLD=',(PSATOLD-PSA,,X),                           +
               INTO=XXX
         PUT   SYSPRINT,XXX
.HLASM99 ANOP
         BALR  R0,0
         STRING 'R0=',((R0),,X),'   16(R0)=',(16(R0),4,X),INTO=XXX
         PUT   SYSPRINT,XXX
*
AMODE31  LA    R12,0(,R12)             BALR->BASR
         L     R15,=A(*+X'80000006')   AMODE=31
         BSM   0,R15                   AMODE=31
         DSPSERV CREATE,                                               X
               NAME==CL8'STRING00',    C'STRING00'                     X
               BLOCKS=HDRBLKS,         SIZE IN PAGES                   X
               STOKEN=DSPCSTKN,                                        X
               ORIGIN=DSPCORG
         ALESERV ADD,STOKEN=DSPCSTKN,ALET=DSPCALET
         LAM   R8,R8,DSPCALET          POINT TO THE DATA SPACE
         L     R8,DSPCORG              SPACE ORIGIN (0 OR 4096)
         SAC   512                     MODE=AR
 LAM R14,R6,TESTPGM+40                 S0E0-28
         STRING WWWW,INTO=(2048(R8),100)
*
.EXIT    SLR   R15,R15
         SVC   3                       GOBACK
D1       DC    C'D1-----D1    '
WWWW     DC    C'WWWW'
CTR1     DC    P'1'
PARM1    DC    C'<-PARM1->'
PARM2    DC    C'<-PARM2->'
XXX      DS    CL132
DSPCSTKN DS    XL8                  0  AS TOKEN
DSPCALET DS    F                    8  ALET
DSPCORG  DS    F                   12  ORIGIN
HDRBLKS  DC    F'100'
CVTPTR   EQU   0016,4,C'A'
SYSPRINT DCB   DSORG=PS,DDNAME=SYSPRINT,MACRF=PM,RECFM=FB,LRECL=121
XYZ      DSECT
         STRING GENERATE,LOCTR
**       STRING GENERATE
         YREGS
PSA      DSECT
PSATOLD  EQU   *+X'21C',4,C'A'
         END
//SYSPRINT DD SYSOUT=*
//SYSLIB   DD DISP=SHR,DSN=SYS1.MACLIB
//SYSUT1   DD UNIT=VIO,SPACE=(CYL,2)
//SYSLIN   DD UNIT=VIO,SPACE=(TRK,1),DISP=(,PASS),DCB=BLKSIZE=3200
//*
//GO      EXEC PGM=LOADER,PARM=NOPRINT
//SYSLIN   DD DSN=*.ASMH.SYSLIN,DISP=(OLD,DELETE)
//SYSPRINT DD SYSOUT=*
//ABNLTERM DD SYSOUT=*
//ABNLIGNR DD DUMMY
//SYSDEBUG DD SYSOUT=*
//SYSUDUMP DD SYSOUT=*

          +----------------------------------------+
          +                                        +
          +   Documentation for the STRING macro   +
          +                                        +
          +       Last update: 09 Sep 1996         +
          +----------------------------------------+

  The STRING macro is functionally similar to the COBOL DISPLAY
  or PL/I PUT EDIT instructions.

  Using STRING, you can concatenate any number of fields, edit
  each of them if necessary, and get the result in the work area
  you specify.

  Formats:

    (1) label  STRING {field_specification1}
                      {,field_specification2}...
                      ,INTO=workarea×(workarea,length)
                      {,PRINT=GEN×NOGEN}

    (2) label  STRING GENERATE
                      {,PRINT=GEN×NOGEN}


  field_specification

    Each field to be printed is described as a positional
    operand.  Each operand specifies the field address, its
    length, and its formatting requirements.

    Four field description formats are supported:

      1.   symbol
      2.   (symbol,length,format)
      3.   (d(r)×(r),length,format)
      4.   ((r),,format)
      5.   'character string'

  Symbol specifies the field address.  It must be an
    S-type (relocatable) address.

  d(r) may be used to specify the field address in S/370
    base-displacement format.  If d is zero, it may be omitted.
    If d(r) or (r) is used, length must also be specified.  R14
    and R15 may not be used.  If d(0) is used, it is handled the
    way the assembler does, i.e. R0 as a base register is assumed
    to contain zero: 16(0) is equivalent to 16, CVTPTR or, X'10'.

  ((r),,format) specifies that (r) contains the value
    itself, not an address.  R14 and R15 may not be used.

  'character string' specifies a literal enclosed in single quotes
    as specified in a DC instruction.  Hex strings or character
    strings are supported.  The following expressions are equivalent:
    'ABC' C'ABC' X'C1C2C3'

  Length specifies the length and/or the type of the input field.
    It may be specified as an integer, a symbol, a register, or a
    constant.  When used with symbol, it overrides the assembled
    length and/or type.  Length is required if field is specified
    as d(r) or (r).  If a zero length is specified, the field is
    ignored.

        nn   field length in bytes
        H    half-word
        F    full-word
        FL1  1-byte binary integer
        FL3  3-byte binary integer
        P    packed field
        (r)  length of character string (R0 thru R12)
        d(r) length of character string (R1 thru R12)

  Notes:  If the field address is specified as a symbol that
          has been defined previously in the program, the symbol
          type is known and there is no need to specify it.

          If the length is specified as (r) or d(r) and the value
          is greater than the address itself, (r) or d(r) is
          considered to be the end address +1 instead of the length.

          The length is not specified for packed fields.  The
          @STRING subroutine scans the field left-to-right until it
          finds a byte with a valid sign in the low-order 4 bits.

          If symbol is an arithmetic expression and no length is coded,
          the implicit length will be that of the first symbol in the
          expression;  for example, if symbol is coded as PSATOLD-PSA,
          then the implicit length will be L'PSATOLD.

          All numeric items are assumed positive.

  format  optionally indicates editing options that must
          be applied to a field.

      L        left justified
      R        right justified
      nn       output length
      0        adjust length
      Z        leading zeroes
      B        leading/trailing blanks
      T        truncate character string after last non-blank
      X        display in hexadecimal
      YYMMDD   convert julian date to YYMMDD
      YY/MM/DD convert julian date to YY/MM/DD
      DD/MM/YY convert julian date to DD/MM/YY
      MM/DD/YY convert julian date to MM/DD/YY
      YYYYMMDD convert julian date to YYYYMMDD
      YYYY-MM-DD convert julian date to YYYY-MM-DD

    The default format depends on the field type:

        Type                   Default Format

        character string             L
        FL1                          R3B
        H or FL2                     R5B
        other numeric fields         R7B

    Note: L0 and T are equivalent for character strings.

  'character string' is any character string enclosed in
  single quotes.  Blank spaces may be specified as nnX,
  where nn is the number of X'40' bytes you want to be
  inserted in the output line.  %TIME may be specified to
  obtain the current time in hh.mm.ss.hh format.

INTO=workarea×(workarea,length)

  INTO indicates the address and length of the output work area
  into which the result of the concatenation should be placed
  (left justified).  If the work area is too small, truncation
  will occur.  If it is too large, it is padded with blanks.

  The address may be a symbol, d(r) (S-type address) or (r).

  The length may be specified as an integer, a symbol, a register,
  or a constant; it is required if the address is coded as d(r) or
  (r).  If length is not specified for a symbol-type address, the
  assembled length of the symbol is used.

  Upon return from STRING, R15 contains the length actually used
  in the output work area (before padding).

PRINT=GEN×NOGEN

  This operand allows you to temporarily override the PRINT
  specification (GEN or NOGEN).

GENERATE (format 2)

  The GENERATE format must be specified once at the end of the
  program.  It generates the literals used in previous invocations
  and the @STRING sub-routine.

  The @STRING CSECT contains optional functions (such as %TIME or
  julian date conversion) that are only generated if they have
  been specified in the previous invocations of the STRING macro.
  Specifying GENERATE,FULL on the final invocation of STRING
  ensures generation of a @STRING CSECT that supports all
  optional functions.

Examples:

     STRING 'ERROR===>',LINE1,'<=== POS ',((R6),,L0),INTO=WORKAREA

     STRING 8X,C'ERRORS FOUND: ',(ERRORS,,L0),INTO=((R7),44)

     STRING 'CVT ADDR IS ',(CVTPTR,4,X),X'40C1C2C3C4',INTO=LINE

     LA    R5,WORK+16              end addr +1
     STRING 'R4=',((R4),,X),INTO=(WORK,(R5)),PRINT=GEN

     STRING '//JOBLIB DD DSN=',(DSN1,,T),',DISP=SHR',INTO=((R2),72)

     PUT31 SYSLIN
     LH    R0,SYSLIN+82            LRECL
     STRING '   NAME  ',(4(R3),8,T),'(R)',INTO=((R1),(R0))

     STRING GENERATE         Generate literals and sub-routine


Programming Notes:

  A STRING macro generates only 6 bytes that need to be covered by
  base registers.  More code is generated at the end of the
  current CSECT (using LOCTR pseudo instruction), but this code
  does not require addressability.  This is particularly useful
  when STRING calls specify a large number of literals.

  Additionally, STRING does not use A-type constants (ACON), but
  S-type constants (SCON) which require symbols to be addressable
  at the point in the program where STRING is issued.

  While this reduces the number of base registers required to
  cover the program's code and makes it easier to write reentrant
  programs, it will produce assembly errors in the following
  situations:

  a.  STRING is used in more than one CSECT in the same assembly

  b.  the CSECT in which STRING is used is longer than 64K

  c.  symbols are not addressable at the point in the program
      where STRING is issued

  d.  the $STRING symbol (generated in the $LTORG LOCTR during the
      GENERATE invocation of the STRING macro) is not addressable
      in some of the STRING calls.
