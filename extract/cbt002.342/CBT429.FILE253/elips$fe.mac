/*    REXX EXEC :
   CA-LIBRARIAN 3.9 LIB/ELIPS FE ( FUNCTION ENTRANCE )          */

TRACE O
/*     */
HOUSE_KEEPING:
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"VGET (ELI$DMF ELI$DMOD ELI$XNOD ELI$XFUN ELI$DPGR ELI$DLAN)"
IF ELI$XNOD ^= 'FE' THEN EXIT 0
MASTER = ELI$DMF
MODULE = ELI$DMOD
FUNCTION = SUBSTR(ELI$XFUN,1,1)
PROGRAMMER = ELI$DPGR
LANGUAGE = ELI$DLAN
LIBNODE = 'COPY JCL PROC RAMI SRCE SYSI'
DO I = 1 TO 6
   NODE = WORD(LIBNODE,I)
   X = POS(NODE,ELI$DMF)
   IF X ^= 0 THEN LEAVE
END
FROMMST = ELI$DMF
TOMST = 'SYS1.ARCH'NODE'.MASTER'
TSOID = SYSVAR(SYSUID)
JULDATE = DATE(J)
PDSMEMB = "J"××JULDATE
CDATE = DATE(U)
CTIME = TIME()
NOMEMB = 'MEMBER NOT FOUND'
TSOPRFX = SUBSTR(TSOID,1,6)
ERC = 0
ECNT = 2              /* EMRG LIB COUNT */
LCNT = 4              /* QA AND PROD LIB COUNT */
PCNT = 2              /* PROD COUNT */
LIBPRFX = 'TURN QA PROD EMRG'
HISTNODE = 'HISTCOPY HISTJCL HISTPROC HISTRAMI HISTSRCE HISTSYSI'
RECORD = ELI$DMF MODULE PROGRAMMER "DELETE BY:" TSOID CDATE CTIME
PARMLIB = 'SYSS.TECH.COMMON.PARMLIB'
CALL GET_PARMS
CALL CHECK_HISTORY_MASTER_ACCESS
IF HSTSW = 'YES' THEN CALL CHECK_HISTORY_AUTHORIZATION
DCLFUNC = 'A C D E EO EM EC ER ES I R UC UM'
DCLCNT = 13           /* DB2 DCL LANGCODE FUNCTION ENTRY COUNT */
LCNT = 4              /* QA AND PROD LIB COUNT */
IF ELI$DLAN = 'DCL' THEN CALL CHECK_DB2ADMIN
IF FUNCTION = 'D' THEN SIGNAL CHECK_DELETE
IF FUNCTION = 'E' THEN SIGNAL CHECK_EDIT
EXIT ERC
/*     M A I N   R O U T I N E   S E C T I O N     */
/*     */
CHECK_DELETE:
ADDRESS TSO
IF MASTER = 'SYS1.SYSTEM.CONTROL.MASTER' THEN EXIT 0
CALL CHECK_BYPASS_OWNER
IF DB2AUTH = 'YES' THEN AUTHSW = 'YES'
IF AUTHSW = 'YES' THEN DO
   CALL CHECK_PROD_DELETE
   IF PRODSW = 'YES' THEN DO
      IF AUTHSW = 'NO' THEN DO
         CALL PROD_DELETE_ERROR
         EXIT ERC
      END
      CALL ARCHIVE_MEMBER
      IF ERC ^= 0 THEN DO
         CALL ARCHIVE_ERROR
         EXIT ERC
      END
   END
   CALL ALLOC_JOURNAL
   INTERPRET CALL LABEL
   CALL DELETE_LOADMOD
   IF LMODSW = 'YES' THEN DO
      IF LANGUAGE = 'DYL' × LANGUAGE = 'DY2' THEN CALL DELETE_DYLAKOR_LO
   END
   QASW = 'NO'
   QALIB = POS('QA',MASTER)
   IF QALIB ^= 0 THEN DO I = 1 TO QACNTL.0
      IF QACNTL.I = TSOID THEN QASW = 'YES'
   END
   IF QASW = 'YES' THEN DO
      ADDRESS TSO
/*    "SEND '"MASTER"("MODULE") DELETED BY: ' USER(TECH207) LOGON"  */
   END
   EXIT ERC
END
CALL CHECK_MODULE_OWNER
IF OWNSW = 'YES' THEN DO
   CALL ALLOC_JOURNAL
   INTERPRET CALL LABEL
   CALL DELETE_LOADMOD
   IF LMODSW = 'YES' THEN DO
      IF LANGUAGE = 'DYL' × LANGUAGE = 'DY2' THEN CALL DELETE_DYLAKOR_LO
   END
   EXIT ERC
END
CALL DELETE_ERROR
EXIT ERC
/*     */
CHECK_EDIT:
ADDRESS TSO
ERC = 0
AUTHSW = 'NO'
MSW = 'NO'
DO L = 1 TO LCNT
   NOEDIT = SUBWORD(LIBPRFX,L,1)
   MATCH = POS(NOEDIT,MASTER)
   IF MATCH ^= 0 THEN MSW = 'YES'
END
IF MSW = 'NO' THEN EXIT ERC
DO I = 1 TO ADMIN.0
   IF ADMIN.I = TSOID THEN AUTHSW = 'YES'
END
IF AUTHSW = 'YES' THEN EXIT ERC
/*     */
CHECK_QALIB:
AUTHSW = 'NO'
QALIB = POS('QA',MASTER)
IF QALIB ^= 0 THEN DO I = 1 TO QACNTL.0
   IF QACNTL.I = TSOID THEN AUTHSW = 'YES'
END
IF AUTHSW = 'YES' THEN DO
   ADDRESS TSO
/* "SEND '"MASTER"("MODULE") EDITTED BY: ' USER(TECH207) LOGON" */
   EXIT ERC
END
/*     */
CHECK_EMERGENCY:
AUTHSW = 'NO'
EMRGLIB = POS('EMRG',MASTER)
IF EMRGLIB ^= 0 THEN DO
   IF TSOPRFX = 'TECH29' THEN EXIT ERC
   DO I = 1 TO AUTHUSR.0
      IF AUTHUSR.I = TSOID THEN AUTHSW = 'YES'
   END
   IF AUTHSW = 'YES' THEN EXIT ERC
END
/*     */
AUTHORIZATION_ERROR:
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
ERC = 4
ELIXMYN = 'Y'
ELILMSG = '$ELIE005'
"SETMSG MSG($ELIE005)"
"VPUT ("ELIXMYN") SHARED"
EXIT ERC
/*     S U B R O U T I N E S   S E C T I O N     */
/*     */
CHECK_HISTORY_MASTER_ACCESS:
HSTSW = 'NO'
DO I = 1 TO 6
   HSTLIB = WORD(HISTNODE,I)
   HST = POS(HSTLIB,MASTER)
   IF HST ^= 0 THEN HSTSW = 'YES'
END
RETURN
/*     */
CHECK_HISTORY_AUTHORIZATION:
HSTAUTH = 'NO'
DO I = 1 TO ADMIN.0
   IF ADMIN.I = TSOID THEN HSTAUTH = 'YES'
END
IF HSTAUTH = 'YES' THEN RETURN
IF USRSW = 'YES' THEN RETURN
IF FUNCTION = 'B' × FUNCTION = 'L' THEN RETURN
ERC = 4
ELIXMYN = 'Y'
ELILMSG = '$ELIE009'
ADDRESS ISPEXEC
"SETMSG MSG($ELIE009)"
"VPUT ("ELIXMYN") SHARED"
EXIT ERC
/*     */
CHECK_DB2ADMIN:
DB2AUTH = 'NO'
DB2SW = 'NO'
DO I = 1 TO DCLCNT
   DB2FUNC = WORD(DCLFUNC,I)
   IF DB2FUNC = ELI$XFUN THEN DB2SW = 'YES'
END
IF DB2SW = 'NO' THEN RETURN
DO I = 1 TO DB2ADMN.0
   IF DB2ADMN.I = TSOID THEN DB2AUTH = 'YES'
END
IF DB2AUTH = 'YES' THEN DO
   AUTHSW = 'YES'
   RETURN
END
ERC = 4
ELIXMYN = 'Y'
ELILMSG = 'LIBI083M'
ADDRESS ISPEXEC
"SETMSG MSG(LIBI083M)"
"VPUT ("ELIXMYN") SHARED"
EXIT ERC
/*     */
CHECK_BYPASS_OWNER:
AUTHSW = 'NO'
DO I = 1 TO AUTHUSR.0
   IF AUTHUSR.I = TSOID THEN AUTHSW = 'YES'
END
RETURN
/*     */
CHECK_MODULE_OWNER:
OWNSW = 'NO'
IF PROGRAMMER = TSOID THEN OWNSW = 'YES'
RETURN
/*     */
ALLOC_JOURNAL:
LABEL = 'NOOP_JOURNAL'
DSN = SYSDSN("'"JDSN"("PDSMEMB")'")
IF DSN = 'OK' THEN DO
   "ALLOC DA('"JDSN"("PDSMEMB")') F(ISPFILE) SHR"
   "DELSTACK"
   "EXECIO * DISKR ISPFILE (FINIS"
   RCDCNT = QUEUED()
   LABEL = 'REWRITE_JOURNAL'
END
IF DSN = NOMEMB THEN DO
   "ALLOC DA('"JDSN"("PDSMEMB")') F(ISPFILE) SHR"
   LABEL = 'WRITE_JOURNAL'
END
RETURN
/*     */
WRITE_JOURNAL:
"DELSTACK"
QUEUE RECORD
"EXECIO 1 DISKW ISPFILE (FINIS"
SRC = RC
"FREE F(ISPFILE)"
IF SRC = 0 THEN RETURN
CALL NOOP_JOURNAL
RETURN
/*     */
REWRITE_JOURNAL:
RCDCNT = RCDCNT + 1
QUEUE RECORD
"EXECIO" RCDCNT "DISKW ISPFILE (FINIS"
SRC = RC
"FREE F(ISPFILE)"
IF SRC = 0 THEN RETURN
CALL NOOP_JOURNAL
RETURN
/*     */
MISSING_MODNAME:
ERC = 4
ELIXMYN = 'Y'
ELILMSG = 'LIBI083L'
ADDRESS ISPEXEC
"SETMSG MSG(LIBI083L)"
"VPUT ("ELIXMYN") SHARED"
RETURN
/*     */
NOOP_JOURNAL:
ERC = 4
ELIXMYN = 'Y'
ELILMSG = '$ELIE003'
ADDRESS ISPEXEC
"SETMSG MSG($ELIE003)"
"VPUT ("ELIXMYN") SHARED"
RETURN
/*     */
DELETE_ERROR:
ERC = 4
ELIXMYN = 'Y'
ELILMSG = '$ELIE004'
ADDRESS ISPEXEC
"SETMSG MSG($ELIE004)"
"VPUT ("ELIXMYN") SHARED"
RETURN
/*     */
CHECK_PROD_DELETE:
PRODSW = 'NO'
PRODLIB = POS('PROD',MASTER)
IF PRODLIB ^= 0 THEN PRODSW = 'YES'
IF PRODSW = 'NO' THEN RETURN
AUTHSW = 'NO'
DO I = 1 TO ADMIN.0
   IF ADMIN.I = TSOID THEN AUTHSW = 'YES'
END
RETURN
/*     */
PROD_DELETE_ERROR:
ERC = 4
ELIXMYN = 'Y'
ELILMSG = '$ELIE006'
ADDRESS ISPEXEC
"SETMSG MSG($ELIE006)"
"VPUT ("ELIXMYN") SHARED"
RETURN
/*     */
ARCHIVE_MEMBER:
ERC = 0
PMAST = POS('PROD',ELI$DMF)
IF PMAST = 0 THEN RETURN
ADDRESS ISPEXEC
"CONTROL ERRORS RETURN"
"SELECT PGM(UTIMAIN) NEWAPPL(LIB@) NEWPOOL PARM(FDSN('"FROMMST"("MODULE"
 TDSN('"TOMST"("MODULE")') CMD(C,OPT(REP)) RETURN"
ERC = RC
RETURN
/*     */
ARCHIVE_ERROR:
ERC = 4
ELIXMYN = 'Y'
ELILMSG = '$ELIE008'
ADDRESS ISPEXEC
"SETMSG MSG($ELIE008)"
"VPUT ("ELIXMYN") SHARED"
RETURN
/*     */
DELETE_LOADMOD:
ERC = 0
LMODSW = 'NO'
SRCELIB = POS('SRCE',MASTER)
IF SRCELIB = 0 THEN RETURN
SRCENODE = 'TEST RJCT EMRG PROD'
LOADNODE = 'TEST REJECT EMERGNCY PROD'
LTYPES = 'BATCH CICS'
LLIBDD = 'BATCHDD CICSDD'
C = 0
DO 4
   C = C + 1
   SNODE = WORD(SRCENODE,C)
   SN = POS(SNODE,MASTER)
   IF SN ^= 0 THEN DO
      LNODE = WORD(LOADNODE,C)
      LEAVE
   END
END
L = 0
X = MSG("OFF")
DO 2
   L = L + 1
   LTYPE = WORD(LTYPES,L)
   LOADLIB = 'SYS1.'LNODE'.'LTYPE'.LOADLIB'
   DSNDD = WORD(LLIBDD,L)
   LMOD = SYSDSN("'"LOADLIB"("MODULE")'")
   IF LMOD = 'OK' THEN DO
      ADDRESS TSO
      LMODSW = 'YES'
      "ALLOC DA('"LOADLIB"')  FILE("DSNDD") SHR"
      "DELETE '"LOADLIB"("MODULE")' FILE("DSNDD")"
      "FREE FILE("DSNDD")"
   END
END
X = MSG("ON")
ADDRESS ISPEXEC
RETURN
/*     */
DELETE_DYLAKOR_LOADMOD:
ADDRESS TSO
MLEN = LENGTH(MODULE)
PREFIX = SUBSTR(MODULE,1,MLEN)
IF MLEN >= 6 THEN PREFIX = SUBSTR(MODULE,1,6)
LIBDSN = "'"MASTER"("MODULE")'"
LIBDD = LIBALLOC(LIBDSN)    /* DYNALLOC LIBMASTER W/LAM; RET DDNAME*/
IF LIBDD = "ERROR" THEN RETURN
"EXECIO 1 DISKR" LIBDD "(FINIS STEM REPORT."
SRC = RC
IF SRC ^= 0 THEN RETURN
REPTFLG = POS('* REPORTS = ',REPORT.1)
IF REPTFLG = 0 THEN RETURN
NUMREPTS = WORD(REPORT.1,4)
IF NUMREPTS = '' THEN RETURN
RTYP = DATATYPE(NUMREPTS)
IF RTYP ^= 'NUM' THEN RETURN
X = MSG("OFF")
LOADLIB = 'SYS1.'LNODE'.BATCH.LOADLIB'
"ALLOC DA('"LOADLIB"')  FILE(BATCHDD) SHR"
DO M = 1 TO NUMREPTS
   IF M = 1 THEN ITERATE
   MLEN = LENGTH(M)
   IF MLEN = 1 THEN DYLMOD = PREFIX××'0'M
   IF MLEN = 2 THEN DYLMOD = PREFIX××M
   LMOD = SYSDSN("'"LOADLIB"("DYLMOD")'")
   IF LMOD = 'MEMBER NOT FOUND' THEN LEAVE
   "DELETE '"LOADLIB"("DYLMOD")' FILE(BATCHDD)"
END
"FREE FILE(BATCHDD)"
X = MSG("ON")
ADDRESS ISPEXEC
RETURN
/*     */
GET_PARMS:
ADDRESS TSO
USRSW = 'NO'
X = MSG("OFF")
"FREE FILE(PARMDD)"
FROMDSN = 'SYSS.TESTCCF.HISTORY.CNTLLIB'
JDSN = 'SYSS.TESTCCF.JOURNAL.CNTLLIB'
"FREE FILE(PARMDD)"
"ALLOC DA('"PARMLIB"(ELIPSADM)') F(PARMDD) SHR"
"EXECIO * DISKR PARMDD (FINIS STEM ADMIN."
"FREE FILE(PARMDD)"
"ALLOC DA('"PARMLIB"(ELIPSAUS)') F(PARMDD) SHR"
"EXECIO * DISKR PARMDD (FINIS STEM AUTHUSR."
"FREE FILE(PARMDD)"
"ALLOC DA('"PARMLIB"(ELIPDB2A)') F(PARMDD) SHR"
"EXECIO * DISKR PARMDD (FINIS STEM DB2ADMN."
"FREE FILE(PARMDD)"
"ALLOC DA('"PARMLIB"(ELIPSQAP)') F(PARMDD) SHR"
"EXECIO * DISKR PARMDD (FINIS STEM QACNTL."
"FREE FILE(PARMDD)"
AUTHFLAG = SYSDSN("'"FROMDSN"("TSOID")'")
IF AUTHFLAG = 'OK' THEN DO
   "ALLOC DA('"FROMDSN"("TSOID")') F(PARMDD) SHR"
   "EXECIO 1 DISKR PARMDD (FINIS STEM USRPARM."
   "FREE FILE(PARMDD)"
   EUSER = WORD(USRPARM.1,1)
   EDATE = WORD(USRPARM.1,2)
   IF EUSER = TSOID & EDATE = JULDATE THEN USRSW = 'YES'
END
RETURN
