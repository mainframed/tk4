/* REXX EXEC : ( LIBPURGE )
   FUNCTION  : THIS UTILITY IS DESIGNED TO FACILITATE THE MAINTENANCE
               CLEANUP OF THE CCF EMERGENCY LIBRARIAN MASTERS AND
               MANAGED LOADLIB DATASETS.
               THE DELETION OF MEMBERS IS BASED ON A 24 HOUR
               RESIDENT PERIOD IN THE EMERGENCY LIBRARY DATASETS.
   AUTHOR    : DAN BOWEN.
                                                                      */
TRACE O
/*     */
HOUSE_KEEPING:
ADDRESS TSO
C = 0
E = 0
G = 0
P = 0
CURHOUR = TIME(H)
CURDATE = DATE(U)
JULDATE = DATE(J)
ACCTCDE = '5304010530000000'
LIBNODES = 'EMRGCOPY EMRGJCL EMRGPROC EMRGRAMI EMRGSYSI EMRGSRCE'
JOBNAMES = 'PTLB05D PTLB06D PTLB07D PTLB08D PTLB09D PTLB10D'
CCFMODS = 'MMRCNTL0 MTRCNTL0'
CCFDSN = 'SYSS.ZEKE.EMRGPARM.CNTLLIB'
LOADLIB.1 = 'SYS1.EMERGNCY.BATCH.LOADLIB BATCHDD'
LOADLIB.2 = 'SYS1.EMERGNCY.CICS.LOADLIB CICSDD'
NUMDAYS.1 = '31 28 31 30 31 30 31 31 30 31 30 31'
NUMDAYS.2 = '31 29 31 30 31 30 31 31 30 31 30 31'
PARSE VALUE CURDATE WITH CMM '/' CDD '/' CYY
X = MSG("OFF")
"FREE FILE(LBINDEX)"
"FREE FILE(LBCNTL)"
"FREE FILE(MMRDD)"
"FREE FILE(MTRDD)"
DO P = 1 TO 2
   CCFMOD = WORD(CCFMODS,P)
   MTR = SYSDSN("'"CCFDSN"("CCFMOD")'")
   IF MTR = 'OK' THEN DO
      LABEL = 'READ_MODULE_'CCFMOD
      INTERPRET CALL LABEL
      ITERATE
   END
   SAY '****************************************************************
   SAY '*** MEMBER ERROR: ('CCFDSN'('CCFMOD'). ***'
   SAY '*** MEMBER NOT FOUND - UNABLE TO READ CCF CONTROL MODULE. ***'
   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: (028). ***'
   SAY '****************************************************************
   EXIT 028
END
/*      M A I N   R O U T I N E   S E C T I O N     */
/*     */
MAIN_ROUTINE:
DO C = 1 TO 6
   R = 0
   NODE = WORD(LIBNODES,C)
   LIBINDEX = 'SYSS.ZEKE.'NODE'.LIBINDEX'
   LIBMASTR = 'SYS1.'NODE'.MASTER'
   CALL READ_LIBINDEX
   CALL GET_DELETE_CANDIDATES
   RCDCNT = R
   IF RCDCNT = 0 THEN DO
      SAY '+++ NO MODULES DELETED FROM: 'LIBMASTR' DATASET. +++'
      ITERATE
   END
   CALL BUILD_LIBDELET_JOB
   CALL WRITE_PDS_MEMBER
   IF NODE = 'EMRGSRCE' THEN DO
      GCNT = G
      IF GCNT > 0 THEN DO G = 1 TO GCNT
         PDSMEMB = LIBJOB.G
         CALL SUBMIT_LIBDELET_JOB
      END
      CALL BUILD_DELETE_LOADLIB_JOB
      IF LMODSW = 'YES' THEN DO
         CALL WRITE_PDS_MEMBER
         CALL SUBMIT_LIBDELET_JOB
      END
      CALL CHECK_DELETE_DYLAKOR_LOADMOD
      IF LMODSW = 'YES' THEN DO
         CALL WRITE_PDS_MEMBER
         CALL SUBMIT_LIBDELET_JOB
      END
      CALL CHECK_UNASSIGNED_LOADMOD
      CALL BUILD_DELETE_UNASSIGNED_LOADMOD
      IF LMODSW = 'YES' THEN DO
         CALL WRITE_PDS_MEMBER
         CALL SUBMIT_LIBDELET_JOB
      END
   END
   CALL BUILD_JOURNAL_MEMBER
   CALL WRITE_PDS_MEMBER
END
EXIT 0
/*
       S U B R O U T I N E S   S E C T I O N     */
/*     */
READ_MODULE_MMRCNTL0:
"ALLOC DA('"CCFDSN"("CCFMOD")') FILE(MMRDD) SHR"
SRC = RC
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** ALLOCATE ERROR: FOR ('CCFDSN'('CCFMOD'). ***'
   SAY '*** UNABLE TO READ ('CCFMOD') MODULE MOVEMENT RECORDS. ***'
   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'
   SAY '****************************************************************
   EXIT SRC
END
"EXECIO * DISKR MMRDD (STEM MMRDATA. FINIS"
SRC = RC
"FREE FILE(MMRDD)"
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** EXECIO ERROR: ('CCFDSN'('CCFMOD'). ***'
   SAY '*** UNABLE TO READ ('CCFMOD') MODULE MOVEMENT RECORDS. ***'
   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED - RC = ('SRC'). ***'
   SAY '****************************************************************
   EXIT SRC
END
RETURN
/*     */
READ_MODULE_MTRCNTL0:
"ALLOC DA('"CCFDSN"("CCFMOD")') FILE(MTRDD) SHR"
SRC = RC
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** ALLOCATE ERROR: FOR ('CCFDSN'('CCFMOD'). ***'
   SAY '*** UNABLE TO READ ('CCFMOD') MODULE TRACKING RECORDS. ***'
   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'
   SAY '****************************************************************
   EXIT SRC
END
"EXECIO * DISKR MTRDD (STEM MTRDATA. FINIS"
SRC = RC
"FREE FILE(MTRDD)"
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** EXECIO ERROR: ('CCFDSN'('CCFMOD'). ***'
   SAY '*** UNABLE TO READ ('CCFMOD') MODULE TRACKING RECORDS. ***'
   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'
   SAY '****************************************************************
   EXIT SRC
END
RETURN
/*     */
READ_LIBINDEX:
"ALLOC DA('"LIBINDEX"') FILE(LBINDEX) OLD"
SRC = RC
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** DATASET ALLOCATE ERROR: ( 'LIBINDEX' ). ***'
   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'
   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'
   SAY '****************************************************************
   EXIT SRC
END
"EXECIO * DISKR LBINDEX (STEM DATA. FINIS"
SRC = RC
"FREE FILE(LBINDEX)"
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** DATASET EXECIO ERROR: ( 'LIBINDEX' ). ***'
   SAY '*** EXECIO DATASET READ RETURN CODE: (' SRC '). ***'
   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'
   SAY '****************************************************************
   EXIT SRC
END
RETURN
/*     */
GET_DELETE_CANDIDATES:
DO I = 1 TO DATA.0
   UPDATE_SWITCH = 'YES'
   VALID_MODULE = POS('$NOJCL',DATA.I)
   IF VALID_MODULE = 0 THEN ITERATE
   MODULE = WORD(DATA.I,1)
   PASSWORD = WORD(DATA.I,2)
   DATE_ADDED = SUBSTR(DATA.I,49,8)
   DATE_UPDATED = SUBSTR(DATA.I,59,8)
   UPDATE_TIME = SUBSTR(DATA.I,68,2)
   PROGRAMMER = SUBSTR(DATA.I,107,7)
   NOT_UPDATED = POS('NOT UPDATED',DATA.I)
   IF NOT_UPDATED > 0 THEN DO
      UPDATE_SWITCH = 'NO'
      DATE_UPDATED = 'NOT-UPDATED'
      UPDATE_TIME = 'NO-UPDATE-TIME'
   END
   CALL CHECK_MMR_MODULE
   IF MMRSW = 'YES' THEN DO
      DATE_ADDED = MDATE_ADDED
      UPDATE_TIME = SUBSTR(MTIME_ADDED,1,2)
      UPDATE_SWITCH = 'YES'
   END
   CALL CHECK_MTR_MODULE
   IF MTRSW = 'YES' THEN DO
      DATE_ADDED = MDATE_ADDED
      UPDATE_TIME = SUBSTR(MTIME_ADDED,1,2)
      UPDATE_SWITCH = 'YES'
   END
   PARSE VALUE DATE_ADDED WITH OMM '/' ODD '/' OYY
   IF CYY > OYY THEN DO
      ELAPS_YEARS = CYY - OYY
      IF ELAPS_YEARS > 1 THEN DO
         CALL QUEUE_RECORD
         ITERATE
      END
      CALL CHECK_UPDATE_TIME
      IF DELETE_SWITCH = 'NO' THEN DO
         CALL CONVERT_JULIAN_DATE
         ELAPS_DAYS = JULDATE - JULDATEO
         IF ELAPS_DAYS > LDAYS THEN DELETE_SWITCH = 'YES'
      END
      IF DELETE_SWITCH = 'YES' THEN CALL QUEUE_RECORD
      ITERATE
   END
   CALL CONVERT_JULIAN_DATE
   IF JULDATEO = JULDATE THEN ITERATE
   ELAPS_DAYS = JULDATE - JULDATEO
   IF ELAPS_DAYS > 1 THEN DO
      CALL QUEUE_RECORD
      ITERATE
   END
   CALL CHECK_UPDATE_TIME
   IF DELETE_SWITCH = 'NO' THEN ITERATE
   CALL QUEUE_RECORD
END
RETURN
/*     */
CHECK_MMR_MODULE:
MMRSW = 'NO'
DO M = 1 TO MMRDATA.0
   TOPROD = POS('TO: PROD',MMRDATA.M)
   IF TOPROD ^= 0 THEN DO
      MMRMOD = WORD(MMRDATA.M,1)
      IF MMRMOD = MODULE THEN DO
         MDATE_ADDED = WORD(MMRDATA.M,7)
         MTIME_ADDED = WORD(MMRDATA.M,8)
         MMRSW = 'YES'
      END
   END
   CURRMAST = POS('CURR MASTER:',MMRDATA.M)
   IF CURRMAST ^= 0 THEN DO
      EMERGENCY_MASTER = WORD(MMRDATA.M,3)
      IF EMERGENCY_MASTER = LIBMASTR & MMRSW = 'YES' THEN LEAVE
      MMRSW = 'NO'
   END
END
RETURN
/*     */
CHECK_MTR_MODULE:
MTRSW = 'NO'
IF MMRSW = 'YES' THEN RETURN
DO M = 1 TO MTRDATA.0
   LOGSTAMP = POS('LOGOUT STAMP:',MTRDATA.M)
   IF LOGSTAMP ^= 0 THEN DO
      MTRMOD = WORD(MTRDATA.M,1)
      IF MTRMOD = MODULE THEN DO
         MDATE_ADDED = WORD(MTRDATA.M,6)
         MTIME_ADDED = WORD(MTRDATA.M,7)
         MTRSW = 'YES'
      END
   END
   TESTMAST = POS('TEST MASTER:',MTRDATA.M)
   IF TESTMAST ^= 0 THEN DO
      EMERGENCY_MASTER = WORD(MTRDATA.M,3)
      IF EMERGENCY_MASTER = LIBMASTR & MTRSW = 'YES' THEN LEAVE
      MTRSW = 'NO'
   END
END
RETURN
/*     */
CHECK_UPDATE_TIME:
DELETE_SWITCH = 'NO'
IF UPDATE_SWITCH = 'NO' THEN RETURN
IF UPDATE_TIME < CURHOUR THEN DELETE_SWITCH = 'YES'
RETURN
/*     */
QUEUE_RECORD:
R = R + 1
RECORD.R = MODULE PASSWORD DATE_ADDED DATE_UPDATED UPDATE_TIME PROGRAMME
RETURN
/*     */
CONVERT_JULIAN_DATE:
D = 0
NDAYS = 0
Y = 2
LEAPYR = OYY // 4
LDAYS = 635
IF LEAPYR > 0 THEN DO
   Y = 1
   LDAYS = 636
END
IMONTH = OMM - 1
DO IMONTH
   D = D + 1
   MDAYS = WORD(NUMDAYS.Y,D)
   NDAYS = NDAYS + MDAYS
END
NDAYS = NDAYS + ODD
NDAYS = RIGHT(NDAYS,3,'0')
JULDATEO = OYY××NDAYS
RETURN
/*     */
BUILD_LIBDELET_JOB:
JN = WORD(JOBNAMES,C)
PDSMEMB = WORD(JOBNAMES,C)
G = G + 1
LIBJOB.G = PDSMEMB
"DELSTACK"
JCL.1 = "//"JN"  JOB "ACCTCDE",'TECH.SUPP.DANBOWEN',NOTIFY=TECH103,"
JCL.2 = "//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M"
JCL.3 = "//LIBDLM   EXEC PGM=AFOLIBR"
JCL.4 = "//MASTER   DD DSN=SYS1."NODE".MASTER,DISP=SHR"
JCL.5 = "//OSJOB    DD DUMMY"
JCL.6 = "//SYSPRINT DD SYSOUT=*"
JCL.7 = "//LIST     DD SYSOUT=*"
JCL.8 = "//INDEX    DD SYSOUT=*"
JCL.9 = "//SYSIN    DD *"
DO J = 1 TO 9
   QUEUE JCL.J
END
DO R = 1 TO RCDCNT
   DELMOD = WORD(RECORD.R,1)
   PASSWORD = WORD(RECORD.R,2)
   DELRCD = "-DLM "DELMOD","PASSWORD
   QUEUE DELRCD
END
JCL.1 = "-END"
JCL.2 = "/*"
JCL.3 = "//"
DO J = 1 TO 3
   QUEUE JCL.J
END
RETURN
/*     */
BUILD_DELETE_LOADLIB_JOB:
J = 7
LMODSW = 'NO'
JN = 'PTLL04D'
PDSMEMB = JN
"DELSTACK"
JCL.1 = "//"JN" JOB "ACCTCDE",'SOURCE.LMOD.DELETE',NOTIFY=TECH103,"
JCL.2 = "//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M"
JCL.3 = "//DELETMEM EXEC PGM=IDCAMS"
JCL.4 = "//BATCHDD  DD DSN=SYS1.EMERGNCY.BATCH.LOADLIB,DISP=SHR"
JCL.5 = "//CICSDD   DD DSN=SYS1.EMERGNCY.CICS.LOADLIB,DISP=SHR"
JCL.6 = "//SYSPRINT DD SYSOUT=*"
JCL.7 = "//SYSIN    DD *"
DO R = 1 TO RCDCNT
   DELMOD = WORD(RECORD.R,1)
   DO L = 1 TO 2
      LOADLIB = WORD(LOADLIB.L,1)
      DSNDD = WORD(LOADLIB.L,2)
      LMOD = SYSDSN("'"LOADLIB"("DELMOD")'")
      IF LMOD = 'OK' THEN DO
         LMODSW = 'YES'
         E = E + 1
         LLMOD.E = DELMOD
         J = J + 1
         JCL.J = "  DELETE   "LOADLIB"("DELMOD")  FILE("DSNDD")"
      END
   END
END
IF LMODSW = 'NO' THEN RETURN
JCLCNT = J
DO J = 1 TO JCLCNT
   QUEUE JCL.J
END
EJCL.1 = "/*"
EJCL.2 = "//"
DO J = 1 TO 2
   QUEUE EJCL.J
END
RETURN
/*     */
CHECK_DELETE_DYLAKOR_LOADMOD:
ADDRESS TSO
J = 6
LMODSW = 'NO'
JN = 'PTLL05D'
PDSMEMB = JN
 LIBMASTR = 'SYS1.EMRGSRCE.MASTER'
"DELSTACK"
JCL.1 = "//"JN" JOB "ACCTCDE",'DYLAKOR.LMOD.DELETE',NOTIFY=TECH103,"
JCL.2 = "//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M"
JCL.3 = "//DELETMEM EXEC PGM=IDCAMS"
JCL.4 = "//BATCHDD  DD DSN=SYS1.EMERGNCY.BATCH.LOADLIB,DISP=SHR"
JCL.5 = "//SYSPRINT DD SYSOUT=*"
JCL.6 = "//SYSIN    DD *"
LOADLIB = WORD(LOADLIB.1,1)
DSNDD = WORD(LOADLIB.1,2)
DO R = 1 TO RCDCNT
   DELMOD = WORD(RECORD.R,1)
   M = 1
   MLEN = LENGTH(DELMOD)
   PREFIX = SUBSTR(DELMOD,1,MLEN)
   IF MLEN >= 6 THEN PREFIX = SUBSTR(DELMOD,1,6)
   LIBDSN = "'"LIBMASTR"("DELMOD")'"
   LIBDD = LIBALLOC(LIBDSN)
   IF LIBDD = "ERROR" THEN ITERATE
   "EXECIO 1 DISKR" LIBDD "(STEM REPORT. FINIS"
   SRC = RC
   "FREE FILE("LIBDD")"
   IF SRC ^= 0 THEN ITERATE
   REPTFLG = POS('* REPORTS = ',REPORT.1)
   IF REPTFLG = 0 THEN ITERATE
   NUMREPTS = WORD(REPORT.1,4)
   IF NUMREPTS = '' THEN ITERATE
   RTYP = DATATYPE(NUMREPTS)
   IF RTYP ^= 'NUM' THEN ITERATE
   DO M = 1 TO NUMREPTS
      IF M = 1 THEN ITERATE
      MLEN = LENGTH(M)
      IF MLEN = 1 THEN DYLMOD = PREFIX××'0'M
      IF MLEN = 2 THEN DYLMOD = PREFIX××M
      LMOD = SYSDSN("'"LOADLIB"("DYLMOD")'")
      IF LMOD = 'MEMBER NOT FOUND' THEN LEAVE
      LMODSW = 'YES'
      E = E + 1
      LLMOD.E = DYLMOD
      J = J + 1
      JCL.J = "  DELETE   "LOADLIB"("DYLMOD")  FILE("DSNDD")"
   END
END
IF LMODSW = 'NO' THEN RETURN
JCLCNT = J
DO J = 1 TO JCLCNT
   QUEUE JCL.J
END
EJCL.1 = "/*"
EJCL.2 = "//"
DO J = 1 TO 2
   QUEUE EJCL.J
END
RETURN
/*     */
CHECK_UNASSIGNED_LOADMOD:
ADDRESS TSO
H = 0
DO S = 1 TO DATA.0
   SRCEMOD = POS('$NOJCL',DATA.S)
   IF SRCEMOD = 0 THEN ITERATE
   SRCEMEM = WORD(DATA.S,1)
   E = E + 1
   LLMOD.E = SRCEMEM
END
ECNT = E
DO L = 1 TO 2
   LOADLIB = WORD(LOADLIB.L,1)
   M = OUTTRAP("MEMBLST.","*","CONCAT")
   "LISTDS ('"LOADLIB"') MEMBERS"
   IF RC ^= 0 THEN ITERATE
   IF MEMBLST.0 < 7 THEN ITERATE
   DO I = 7 TO MEMBLST.0
      LOADMOD = STRIP(MEMBLST.I)
      DO E = 1 TO ECNT
         IF LOADMOD = LLMOD.E THEN DO
            H = H + 1
            EXMEMB.H = LOADMOD
            LEAVE
         END
      END
   END
END
RETURN
/*     */
BUILD_DELETE_UNASSIGNED_LOADMOD:
HCNT = H
J = 7
LMODSW = 'NO'
JN = 'PTLL06D'
PDSMEMB = JN
"DELSTACK"
JCL.1 = "//"JN" JOB "ACCTCDE",'UNASSIGN.LMOD.DELETE',NOTIFY=TECH103,"
JCL.2 = "//             CLASS=P,MSGCLASS=G,MSGLEVEL=(1,1),REGION=6M"
JCL.3 = "//DELETMEM EXEC PGM=IDCAMS"
JCL.4 = "//BATCHDD  DD DSN=SYS1.EMERGNCY.BATCH.LOADLIB,DISP=SHR"
JCL.5 = "//CICSDD   DD DSN=SYS1.EMERGNCY.CICS.LOADLIB,DISP=SHR"
JCL.6 = "//SYSPRINT DD SYSOUT=*"
JCL.7 = "//SYSIN    DD *"
DO L = 1 TO 2
   LOADLIB = WORD(LOADLIB.L,1)
   DSNDD = WORD(LOADLIB.L,2)
   M = OUTTRAP("MEMBLST.","*","CONCAT")
   "LISTDS ('"LOADLIB"') MEMBERS"
   IF RC ^= 0 THEN ITERATE
   IF MEMBLST.0 < 7 THEN ITERATE
   DO I = 7 TO MEMBLST.0
      LOADMOD = STRIP(MEMBLST.I)
      DELETSW = 'YES'
      DO H = 1 TO HCNT
         IF LOADMOD = EXMEMB.H THEN DELETSW = 'NO'
      END
      IF DELETSW = 'NO' THEN ITERATE
      LMODSW = 'YES'
      J = J + 1
      JCL.J = "  DELETE   "LOADLIB"("LOADMOD")  FILE("DSNDD")"
   END
END
IF LMODSW = 'NO' THEN RETURN
JCLCNT = J
DO J = 1 TO JCLCNT
   QUEUE JCL.J
END
EJCL.1 = "/*"
EJCL.2 = "//"
DO J = 1 TO 2
   QUEUE EJCL.J
END
RETURN
/*     */
BUILD_JOURNAL_MEMBER:
PDSMEMB = WORD(LIBNODES,C)
DO R = 1 TO RCDCNT
   QUEUE RECORD.R
END
RETURN
/*     */
WRITE_PDS_MEMBER:
CALL ALLOC_CNTLLIB
NUMRCDS = QUEUED()
"EXECIO" NUMRCDS "DISKW LBCNTL (FINIS"
SRC = RC
"FREE FILE(LBCNTL)"
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** PDS WRITE ERROR: ('CCFDSN'('PDSMEMB'). ***'
   SAY '*** EXECIO WRITE RETURN CODE: (' SRC '). ***'
   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'
   SAY '****************************************************************
   EXIT SRC
END
RETURN
/*     */
ALLOC_CNTLLIB:
"ALLOC DA('"CCFDSN"("PDSMEMB")') FILE(LBCNTL) OLD"
SRC = RC
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** DATASET ALLOCATE ERROR: ('CCFDSN'('PDSMEMB'). **'
   SAY '*** DATASET IN USE OR UNAVAILABLE - RETURN CODE: (' SRC '). ***'
   SAY '*** LIBPURGE EXEC SUBTASK CANCELLED. ***'
   SAY '****************************************************************
   EXIT SRC
END
RETURN
/*     */
SUBMIT_LIBDELET_JOB:
"SUBMIT '"CCFDSN"("PDSMEMB")'"
SRC = RC
IF SRC ^= 0 THEN DO
   SAY '****************************************************************
   SAY '*** SUBMIT ERROR: MEMBER ('CCFDSN'('PDSMEMB'). ***'
   SAY '*** LIBPURGE EXEC TASK CANCELLED - RETURN CODE: ('SRC'). ***'
   SAY '****************************************************************
   EXIT SRC
END
RETURN
