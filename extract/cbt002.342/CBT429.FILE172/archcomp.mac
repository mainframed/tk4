COMP     TITLE 'ARCHIVER --- COMPARE FUNCTION'
*---------------------------------------------------------------------*
*---     THIS IS THE ARCHIVER CLUSTER-TO-CLUSTER COMPARE           ---*
*---     FUNCTION.  EACH ITEM IN THE VSAM1 DATASET IS COMPARED TO  ---*
*---     THE CORRESPONDING ITEM IN THE VSAM2 DATASET, MODIFYING    ---*
*---     QUALIFIERS AS PROVIDED BY THE USER IN THE CMP1 AND CMP2   ---*
*---     ARGUMENTS.  MATCHES AND MIS-MATCHES ARE DENOTED BY        ---*
*---     APPROPRIATE MESSAGES TO SYSPRINT AND THE COMPARE OF TWO   ---*
*---     ITEMS TERMINATES AT THE FIRST MIS-MATCH.  PLEASE TAKE     ---*
*---     CAREFUL NOTE: A MIS-MATCH IN NOTE DATA DOES NOT           ---*
*---     TERMINATE THE COMPARE OPERATION.  IT GENERATES A MESSAGE  ---*
*---     AND THE COMPARE CONTINUES WITH THE ACTUAL MEMBER DATA.    ---*
*---                                                               ---*
*---     IN THIS FUNCTION, GENERICS IN CMP2 QUALIFIERS ARE         ---*
*---     TREATED DIFFERENTLY THAN THE USUAL GENERICS.  IF A        ---*
*---     GENERIC QUALIFIER APPEARS IN CMP2, IT SIGNIFIES THAT THE  ---*
*---     CORRESPONDING VALUE IN CMP1 MUST BE USED.  FOR EXAMPLE,   ---*
*---     IF THE USER SPECIFIES CMP1=(*,A,B,C),CMP2=(*,Y,*,*)       ---*
*---     THEN ITEM (XYZ,A,B,C) WILL BE COMPARED TO ITEM            ---*
*---     (XYZ,Y,B,C).  BECAUSE OF THE NATURE OF THE COMPARE        ---*
*---     FUNCTION, IT WAS DECIDED THAT A 'BLANKET' COMPARE OF      ---*
*---     EACH ITEM IN VSAM1 AGAINST ALL ITEMS IN VSAM2 WAS TOO     ---*
*---     TIME-CONSUMING.                                           ---*
*---------------------------------------------------------------------*
ARCHCOMP CSECT
R0       EQU   0                   R
R1       EQU   1                    E
R2       EQU   2                     G
R3       EQU   3                      I
R4       EQU   4                       S
R5       EQU   5                        T
R6       EQU   6                         E
R7       EQU   7                          R
R8       EQU   8
R9       EQU   9                   E
R10      EQU   10                   Q
R11      EQU   11                    U
R12      EQU   12                     A
R13      EQU   13                      T
R14      EQU   14                       E
R15      EQU   15                        S
@RPL1    EQU   R2                  SOME
@RPL2    EQU   R3                    SPECIAL
@RPL3    EQU   R4                      EQUATES
@BUF1    EQU   R5                        FOR
@BUF2    EQU   R6                          VSAM
@BUF3    EQU   R7                            I/O MGMT
         COPY #ARCBITS
         USING ARCHCOMP,R15
         B     PASSIT              BRANCH AROUND
         DC    AL1(48)
         DC    CL8'ARCHCOMP'       CSECT IDENTIFIER
         DC    CL8' V5 R0 '        VERSION/RELEASE ID
         DC    CL8'BRC0500'        FMID FOR SMP
         DC    CL8'*NONE*'         PTF LEVEL
         DC    CL8'&SYSDATE'
         DC    CL8'&SYSTIME'
         DC    C' (C) 1990 RICHARD A. FOCHTMAN JR., '
         DC    C'LISLE, ILLINOIS '
         DC    H'4096'
PASSIT   DS    0H
         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS
         LR    R11,R15             COMP ROUTINE BASE REGISTER
         DROP  R15                 DROP THE OLD BASE
         USING ARCHCOMP,R11        DEFINE THE NEW BASE REGISTER
         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK
         ST    R14,8(,R13)         STORE FORWARD POINTER
         ST    R13,4(,R14)         AND BACK POINTER
         LR    R13,R14             COMP NEW SAVE AREA POINTER
         L     R14,4(,R13)         RECOPY BACK POINTER
         L     R14,12(,R14)        RECOPY ORIG. REG 14
         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER
         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH
         USING ARCHCOMP+4096,R10   AND DECLARE IT
         LA    R9,0(,R10)          COPY SECOND BASE REGISTER
         AH    R9,PASSIT-2         BUMP BY A BASE'S WORTH
         USING ARCHCOMP+8192,R9    AND DECLARE IT
         USING MAINWK,R12          BASE THE MAIN WORK AREA
         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT
         XC    MCNT,MCNT           AND MEMBER COUNT
         XC    ACNT,ACNT           AND MIS-MATCH COUNT
*---------------------------------------------------------------------*
*---     FIRST, RESOLVE ANY QUALIFIER MATCHING FUNCTION. WE DO     ---*
*---     THIS BY REPLACING ANY CL10'*' QUALIFIER IN THE CMP2       ---*
*---     QUALIFIER LIST WITH THE CORRESPONDING VALUE FROM THE      ---*
*---     CMP1 QUALIFIER LIST.                                      ---*
*---------------------------------------------------------------------*
         LA    R3,Q1               POINT TO FIRST CMP1 QUALIFIER
         LA    R4,10               LOAD QUALIFIER LENGTH
         LA    R5,Q4               AND LAST QUALIFIER
         LA    R6,QC1              POINT TO CMP2 LIST
QR1      DS    0H
         CLC   0(10,R6),=CL10'%%%%%%%%%%' 'SAME' GENERIC ??
         BE    QR2                 NOPE ---
         MVC   0(10,R6),0(R3)      YES; COPY CMP1 VALUE
QR2      DS    0H
         BXLE  R3,R4,QR1           LOOP, MOVINGLY (???)
*---------------------------------------------------------------------*
*---     NOW OPEN THE VSAM CLUSTERS FOR INPUT.                     ---*
*---------------------------------------------------------------------*
         MVC   VS1MODE,=CL8'INPUT' SET THE I/O MODE
         LA    R1,VSAM1DD          LOAD THE PARM POINTER
         LA    R0,0                AND THE 'OPEN' FLAG
         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION
         LTR   R15,R15             OPEN OK ??
         BNZ   ENDITALL            NOPE; CAN'T WORK
         MVC   VS2MODE,=CL8'INPUT' SET THE I/O MODE
         LA    R1,VSAM2DD          LOAD THE PARM POINTER
         LA    R0,0                AND THE 'OPEN' FLAG
         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION
         LTR   R15,R15             OPEN OK ??
         BNZ   ENDITALL            NOPE; CAN'T WORK
         EJECT
*---------------------------------------------------------------------*
*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*
*---           THIS:                                               ---*
*---                                                               ---*
*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*
*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*
*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF1 AREA FOR   ---*
*---        HEADER/KEY CONSTRUCTION.                               ---*
*---                                                               ---*
*---     2. LOCATE THE RELATED MEMBER IN THE VSAM2 CLUSTER. IF     ---*
*---        NOT PRESENT, ISSUE A MESSAGE AND RETURN TO STEP1 FOR   ---*
*---        THE NEXT ITEM.  UNTIL I GET THE BASIC COMPARE TO       ---*
*---        FUNCTION PROPERLY, ARCHIVER-TYPE ALIASES WILL BE       ---*
*---        IGNORED.  MAYBE LATER, FOLKS!!                         ---*
*---                                                               ---*
*---     3. COMPARE THE LMOD FLAGS IN THE TWO HEADERS. IF NOT      ---*
*---        EQUAL, THE COMPARISON IS COMPLETE AND THE APPROPRIATE  ---*
*---        MESSAGE IS ISSUED TO THE USER.  THEN GO BACK TO STEP1  ---*
*---        FOR THE NEXT ITEM IN VSAM1.                            ---*
*---                                                               ---*
*---     4. COMPARE THE HEADER DATA IN DETAIL. THAT MEANS THAT WE  ---*
*---        COMPARE THE RECFM, LRECL (IF NOT RECFM=U), COMPARE THE ---*
*---        VARIOUS PDS ALIASES, IF ANY, RECORD COUNTS, TIME/DATE  ---*
*---        OF UNLOAD, SPF STATISTICS IF PRESENT, LKED ATTRIBUTES  ---*
*---        IF ANY.  MESSAGE ANY MIS-MATCHES AND CONTINUE.         ---*
*---                                                               ---*
*---     PLEASE TAKE NOTE: A MIS-MATCH IN RECFM OR LRECL WILL      ---*
*---     TERMINATE THE COMPARE IMMEDIATELY.  THE COMPARE WILL      ---*
*---     ALSO BE TERMINATED IF THE RECORD COUNTS OR LOAD-MODULE    ---*
*---     LENGTHS (FROM PDS DIRECTORY DATA) ARE UNEQUAL.  MISSING   ---*
*---     ALIASES, UNEQUAL TIME/DATE STAMPS AND BLKSIZES WILL       ---*
*---     RESULT IN A MESSAGE.  COMPARISONS OF RECFM=U ITEMS WILL   ---*
*---     BE TERMINATED IF THE BLKSIZE IS UNEQUAL.                  ---*
*---                                                               ---*
*---     5. CHECK FOR NOTE DATA.  MESSAGE THE FIRST DIFFERENCE     ---*
*---        AND CONTINUE WITH THE DATA COMPARISON.                 ---*
*---                                                               ---*
*---     6. READ AND DEBLOCK THE DATA RECORDS IN PARALLEL,         ---*
*---        COMPARING AS WE GO. THE FIRST TIME WE GET A COMPARE    ---*
*---        THAT FAILS, MESSAGE THAT THE ITEMS ARE UNEQUAL AND     ---*
*---        TERMINATE THE COMPARE OF THESE TWO ITEMS.              ---*
*---                                                               ---*
*---     IF ANY OF THE QUALIFIER VALUES IN CMP2 WERE GENERIC,      ---*
*---     LOCATE THE NEXT POSSIBLE MATCH AND CONTINUE TO COMPARE    ---*
*---     TO THIS SAME CMP1 ITEM. OTHERWISE, GO BACK TO STEP1 AND   ---*
*---     LOCATE THE NEXT VSAM1-ITEM TO BE COMPARED.                ---*
*---                                                               ---*
*---------------------------------------------------------------------*
         EJECT
*---------------------------------------------------------------------*
*---     USING VS1BUF1, LOCATE THE FIRST ITEM IN VSAM1 TO BE       ---*
*---     COMPARED.                                                 ---*
*---------------------------------------------------------------------*
         L     R6,VS1BUF1          POINT TO THE VSAM BUFFER
         USING REC,R6              BASE THE RECORD DSECT
         XC    0(RECKLEN,R6),0(R6)    START AT THE BEGINNING !!
         MVI   RECTT,#RTHDR        INITIAL RECORD TYPE
         MODCB RPL=(*,RPL1),                                           X
               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X
               ACB=(*,ACB1),                                           X
               ARG=(*,VS1BUF1),                                        X
               AREA=(*,VS1BUF1),                                       X
               AREALEN=(*,VS1LIM),                                     X
               MF=(G,GENWK)        POSITION TO CLUSTER START
         L     R1,RPL1             COPY THE RPL ADDRESS
         POINT RPL=(1)             GET TO IT
NEXTHDR  DS    0H
         L     R6,VS1BUF1          POINT TO THE RECORD
         L     R1,RPL1             COPY RPL ADDRESS
         GET   RPL=(1)             AND READ A HEADER RECORD
         LTR   R15,R15             ANYTHING LEFT ??
         BNZ   ENDITALL            NOPE; ALL DONE
         SHOWCB RPL=(*,RPL1),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN1),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         CLI   RECTT,#RTHDR        HEADER RECORD ??
         BNE   ENDITALL            NOPE; ALL DONE ---
         #IF   RSRALIAS,ON,NEXTHDR SKIP ALIAS NAMES
         LA    R1,RECN             POINT TO THE HEADER
         LA    R0,0                USE DEFAULT QUALIFIER DATA
         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??
         LTR   R15,R15             PASS THE CHECK ??
         BNZ   NEXTHDR             NOPE ---
         #IF   CMPSHRTL,ON,NOL1    SKIP MSG IF SHORT-FORM LIST
         #PUT  SEPREC              OUTPUT A LINE OF HYPHENS
         #FORMAT 0(,R6),,SELECT1   SHOW WE SELECTED THIS ONE
         #PUT  LINE
NOL1     DS    0H
         EJECT
*---------------------------------------------------------------------*
*---     THE VSAM1 ITEM IS SELECTED FOR COMPARISON. NOW USE THE    ---*
*---     VS2 BUFFERS AND RPLS TO LOCATE, IF POSSIBLE, A            ---*
*---     CORRESPONDING ITEM ON VSAM2 TO COMPARE WITH THE VSAM1     ---*
*---     ITEM.  WE NEED TO REMEMBER POSITIONING FOR BOTH THE       ---*
*---     VS2RPL1 AND VS2RPL2 RPLS, SINCE WE MAY HAVE MULTIPLE      ---*
*---     ITEMS TO COMPARE WITH.                                    ---*
*---------------------------------------------------------------------*
         SPACE 3
         #SET  CMPSRCF,ON          TO START, SHO NO MATCHING ITEM
         L     R7,VS2BUF1          LOAD VSAM2 BUFFER POINTER
         DROP  R6
         USING REC,R7
         XC    0(RECKLEN,R7),0(R7) INITIALIZE THAT KEY
         MODCB RPL=(*,RPL4),                                           X
               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X
               ACB=(*,ACB2),                                           X
               ARG=(*,VS2BUF1),                                        X
               AREA=(*,VS2BUF1),                                       X
               AREALEN=(S,VS2LIM),                                     X
               MF=(G,GENWK)        POSITION TO CLUSTER START
         L     R1,RPL4             LOAD RPL POINTER
         POINT RPL=(1)             POSITION VSAM2 TO START
SRCH2    DS    0H
         L     R2,RPL4             COPY THE RPL ADDRESS
         GET   RPL=(R2)            GO READ A RECORD, MAYBE ---
         LTR   R15,R15             ANYTHING ??
         BNZ   SRCH2A              NOPE; ITEM DOESN'T EXIST
         SHOWCB RPL=(*,RPL4),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS2LEN1),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         CLI   RECTT,#RTHDR        DID WE GET A HEADER RECORD ??
         BE    SRCH2B              YES; CHECK NAMES FOR A MATCH
SRCH2A   DS    0H
         #IF   CMPSRCF,OFF,NEXTHDR
         MVC   LINE,NOMATCH        SEND THE 'NO-MATCH' MESSAGE
         #PUT  LINE
         B     NEXTHDR             AND TRY FOR ANOTHER VSAM1 ITEM
SRCH2B   DS    0H
         #IF   RSRALIAS,ON,SRCH2   SKIP ALIAS RECORDS
         LA    R0,QC1              POINT TO A QUALIFIER
         LA    R1,OFFN(,R7)        POINT TO RECORD KEY
         CALL  ARCHKNAM            GO CHECK FOR A INITIAL MATCH
         LTR   R15,R15             QUALIFIERS FIT ??
         BNZ   SRCH2               NOPE; KEEP SEARCHING
         CLC   QC1,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??
         BNE   SRCH2C              NOPE ---
         CLC   OFFN(10,R6),OFFN(R7) DO THEY MATCH ??
         BNE   SRCH2               NOPE; KEEP SEARCHING
SRCH2C   DS    0H
         CLC   QC2,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??
         BNE   SRCH2D              NOPE ---
         CLC   OFFG(10,R6),OFFG(R7) DO THEY MATCH ??
         BNE   SRCH2               NOPE; KEEP SEARCHING
SRCH2D   DS    0H
         CLC   QC3,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??
         BNE   SRCH2E              NOPE ---
         CLC   OFFSG(10,R6),OFFSG(R7) DO THEY MATCH ??
         BNE   SRCH2               NOPE; KEEP SEARCHING
SRCH2E   DS    0H
         CLC   QC4,=CL10'%%%%%%%%%%' 'SAME VALUE' QUALIFIER ??
         BNE   SRCH2F              NOPE ---
         CLC   OFFT(10,R6),OFFT(R7) DO THEY MATCH ??
         BNE   SRCH2               NOPE; KEEP SEARCHING
SRCH2F   DS    0H
         #IF   CMPSHRTL,ON,NOL3    SKIP MSG IF SHORT-FORM LIST
         #FORMAT 0(,R7),,SELECT2 SHOW WHAT WE SELECTED
         #PUT  LINE
NOL3     DS    0H
         DROP  R7                  DISCARD THAT BASE, FOR NOW
         EJECT
*---------------------------------------------------------------------*
*---     VS1BUF1 AND VS2BUF1 BOTH CONTAIN THE HEADERS OF A PAIR    ---*
*---     OF ITEMS TO BE COMPARED.  AT THIS POINT, WE MUST COMPARE  ---*
*---     THE BASIC FIELDS OF THE HEADER RECORD AND MAKE SOME       ---*
*---     CRITICAL DECISIONS.  LIKE, WHETHER OR NOTE TO CONTINUE.   ---*
*---------------------------------------------------------------------*
         SPACE 3
         #SET  CMPHDRF,OFF         ASSUME IT'S A MATCH, FOR NOW
         #SET  CMPSRCF,OFF         SHOW WE HAD ONE CORRESPONDING ITEM
         #SET  CMPABTF,OFF         ASSUME IT'S A MATCH, FOR NOW
         #SET  CMPDATF,OFF         ASSUME IT'S A MATCH, FOR NOW
         #SET  CMPNTDF,OFF         ASSUME IT'S A MATCH, FOR NOW
*---------------------------------------------------------------------*
*---     COMPARE LMOD FLAGS. ABORT ON MIS-MATCH                    ---*
*---------------------------------------------------------------------*
         CLC   OFFLMOD(1,R6),OFFLMOD(R7) BOTH LMODS ?? (OR NOT)
         BE    HC1                 YES ---
         MVC   LINE,FM1            MOVE A MESSAGE
         #PUT  LINE                OUTPUT THE MESSAGE
         B     SRCH2               AND KEEP SEARCHING ---
HC1      DS    0H
*---------------------------------------------------------------------*
*---     COMPARE RECFM FIELDS. ABORT ON MIS-MATCH                  ---*
*---------------------------------------------------------------------*
         CLC   OFFREC(1,R6),OFFREC(R7) COMPARE RECFM'S
         BE    HC2                 ALL MATCHES ---
         #SET  CMPABTF,ON          SET THE ABORT FLAG
         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE
         #IF   CMPSHRTL,ON,NOL5    SKIP MSG IF SHORT-FORM LIST
         MVC   LINE,FM2            COPY THE FAILURE MESSAGE
         #PUT  LINE                AND PRINT IT
NOL5     DS    0H
HC2      DS    0H
*---------------------------------------------------------------------*
*---     COMPARE LRECL FIELDS. ABORT ON MIS-MATCH                  ---*
*---------------------------------------------------------------------*
         TM    OFFREC(R6),X'C0'    RECFM = U ??
         BO    HC4                 YES ---
         TM    OFFREC(R7),X'C0'    RECFM = U ??
         BO    HC4                 YES ---
         CLC   OFFLRE(2,R6),OFFLRE(R7) COMPARE LRECLS
         BE    HC3                 ALL MATCHES ---
         #SET  CMPABTF,ON          SET THE ABORT FLAG
         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE
         #IF   CMPSHRTL,ON,NOL6    SKIP MSG IF SHORT-FORM LIST
         MVC   LINE,FM3            COPY THE FAILURE MESSAGE
         #PUT  LINE                AND PRINT IT
NOL6     DS    0H
HC3      DS    0H
         B     HC5                 SKIP BLKSIZE COMPARE
HC4      DS    0H
*---------------------------------------------------------------------*
*---     COMPARE BLKSIZE FIELDS FOR RECFM=U ITEMS.                 ---*
*---------------------------------------------------------------------*
         CLC   OFFBLK(2,R6),OFFBLK(R7) COMPARE BLKSIZE VALUES
         BE    HC5                 ALL MATCHES ---
         #SET  CMPABTF,ON          SET THE ABORT FLAG
         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE
         #IF   CMPSHRTL,ON,NOL7    SKIP MSG IF SHORT-FORM LIST
         MVC   LINE,FM4            COPY THE FAILURE MESSAGE
         #PUT  LINE                AND PRINT IT
NOL7     DS    0H
HC5      DS    0H
*---------------------------------------------------------------------*
*---     COMPARE LOGICAL RECORD COUNTS                             ---*
*---------------------------------------------------------------------*
         CLC   OFFRCNT(4,R6),OFFRCNT(R7) COMPARE COUNT VALUES
         BE    HC6                 ALL MATCHES ---
         #SET  CMPABTF,ON          SET THE ABORT FLAG
         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE
         #IF   CMPSHRTL,ON,NOL8    SKIP MSG IF SHORT-FORM LIST
         MVC   LINE,FM6            COPY THE FAILURE MESSAGE
         #PUT  LINE                AND PRINT IT
NOL8     DS    0H
HC6      DS    0H
*---------------------------------------------------------------------*
*---     COMPARE NOTEDATA RECORD COUNTS                            ---*
*---------------------------------------------------------------------*
         CLC   OFFNOT#(4,R6),OFFNOT#(R7) COMPARE BLKSIZE VALUES
         BE    HC7                 ALL MATCHES ---
         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE
         MVC   LINE,FM7            COPY THE FAILURE MESSAGE
         #IF   CMPSHRTL,ON,NOL9    SKIP MSG IF SHORT-FORM LIST
         #PUT  LINE                AND PRINT IT
NOL9     DS    0H
HC7      DS    0H
*---------------------------------------------------------------------*
*---     COMPARE UNLOAD DATE VALUES                                ---*
*---------------------------------------------------------------------*
         CLC   OFFDATE(4,R6),OFFDATE(R7) COMPARE DATE VALUES
         BE    HC8                 ALL MATCHES ---
         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE
         MVC   LINE,FM8            COPY THE FAILURE MESSAGE
         #IF   CMPSHRTL,ON,NOL10   SKIP MSG IF SHORT-FORM LIST
         #PUT  LINE                AND PRINT IT
NOL10    DS    0H
HC8      DS    0H
*---------------------------------------------------------------------*
*---     COMPARE UNLOAD TIME VALUES                                ---*
*---------------------------------------------------------------------*
         CLC   OFFTIME(4,R6),OFFTIME(R7) COMPARE DATE VALUES
         BE    HC9                 ALL MATCHES ---
         #SET  CMPHDRF,ON          SHOW FAILURE IN HEADER COMPARE
         MVC   LINE,FM9            COPY THE FAILURE MESSAGE
         #IF   CMPSHRTL,ON,NOL11   SKIP MSG IF SHORT-FORM LIST
         #PUT  LINE                AND PRINT IT
NOL11    DS    0H
HC9      DS    0H
*---------------------------------------------------------------------*
*---     PRINT 'COMPARE FAILED' MESSAGE IF CMPABTF FLAG SET.       ---*
*---------------------------------------------------------------------*
         #IF   CMPABTF,OFF,GDCMP   GOOD COMPARE
         #IF   CMPSHRTL,OFF,NOF1
         L     R6,VS1BUF1
         L     R7,VS2BUF1
         #FORMAT 0(,R6),,SELECT1
         #PUT  LINE
         #FORMAT 0(,R7),,SELECT2
         #PUT  LINE
NOF1     DS    0H
         MVC   LINE,FM5            COPY THE MESSAGE
         #PUT  LINE                OUTPUT THE MESSAGE
         B     SRCH2               GO FIND ANOTHER SELECTION
GDCMP    DS    0H
         MVC   LINE,SC1            COPY 'SUCCESSFUL COMPARE' MESSAGE
         #IF   CMPSHRTL,ON,NOL13   SKIP MSG IF SHORT-FORM LIST
         #PUT  LINE                OUTPUT THAT MESSAGE
NOL13    DS    0H
         EJECT
*---------------------------------------------------------------------*
*---     ALL COMPARES FOR THE HEADER RECORD ARE COMPLETE. NOT, IF  ---*
*---     BOTH HAVE NOTEDATA RECORDS, WE NEED TO FETCH AND COMPARE  ---*
*---     THE NOTE DATA.  IF ONE HAS NOTE DATA RECORDS AND THE      ---*
*---     OTHER DOESN'T, WE BYPASS THIS COMPARISON, FOR OBVIOUS     ---*
*---     REASONS.                                                  ---*
*---------------------------------------------------------------------*
         CLC   OFFNOT#(4,R6),=F'0' COMPARE NOTEDATA COUNTS
         BE    CMPDAT              NOTE HERE ---
         CLC   OFFNOT#(4,R7),=F'0' COMPARE NOTEDATA COUNTS
         BE    CMPDAT              NOTE HERE ---
*---------------------------------------------------------------------*
*---     BOTH ITEMS HAVE NOTE DATA. USING THE NUMBER-2 BUFFERS     ---*
*---     AND RPLS FOR EACH ARCHIVE CLUSTER, POINT TO THE ACTUAL    ---*
*---     NOTE DATA RECORDS AND START FETCHING LOGICAL RECORDS FOR  ---*
*---     COMPARISON.                                               ---*
*---------------------------------------------------------------------*
         L     R2,VS1BUF2          VSAM1'S #2 BUFFER
         L     R3,VS2BUF2          VSAM2'S #2 BUFFER
         MVC   0(RECKLEN,R2),0(R6) COPY VSAM1 KEY
         MVC   0(RECKLEN,R3),0(R7) COPY VSAM2 KEY
         MVI   0(R2),#RTNOTE       RECTYPE = NOTE DATA
         MVI   0(R3),#RTNOTE       RECTYPE = NOTE DATA
         LR    R6,R2               COPY BUFFER ADDRESS
         LR    R7,R3               DITTO ---
         XC    BLDLAREA,BLDLAREA   SAVE AREA FOR DEBLOCKING STUFF
         L     R2,RPL2             POINT TO AN RPL
         L     R3,RPL5             AND A SECOND RPL
         MODCB RPL=(R2),                                               X
               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X
               ACB=(*,ACB1),                                           X
               ARG=(R6),                                               X
               AREA=(R6),                                              X
               AREALEN=(*,VS1LIM),                                     X
               MF=(G,GENWK)        POSITION TO CLUSTER START
         POINT RPL=(2)             GET TO IT
         GET   RPL=(2)
         SHOWCB RPL=(*,RPL2),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         MODCB RPL=(R3),                                               X
               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X
               ACB=(*,ACB2),                                           X
               ARG=(R7),                                               X
               AREA=(R7),                                              X
               AREALEN=(*,VS2LIM),                                     X
               MF=(G,GENWK)        POSITION TO CLUSTER START
         POINT RPL=(3)             GET TO IT
         GET   RPL=(3)
         SHOWCB RPL=(*,RPL5),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS2LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
*---------------------------------------------------------------------*
*---     AT THIS POINT, THE FIRST ARCHIVE RECORD OF NOTE DATA IS   ---*
*---     IN STORAGE, IN THE NUMBER-2 BUFFERS.  HERE'S WHERE THE    ---*
*---     DEBLOCKING AND COMPARING GET REAL HAIRY.  SINCE THE       ---*
*---     VSAM1 AND VSAM2 CLUSTERS MAY HAVE DIFFERRING RECORD       ---*
*---     LENGTHS, EACH VSAM RECORD MUST BE DE-BLOCKED INTO         ---*
*---     INDIVIDUAL ARCHIVER-STYLE LOGICAL RECORDS FOR THE         ---*
*---     COMPARISON.  A CLCL INSTRUCTION THAT SUCCEEDS WILL        ---*
*---     UPDATE THE SOURCE AND COUNT REGISTERS, SAVING ME A FEW    ---*
*---     HEADACHES. FOR THAT REASON, MY REGISTER USAGE MAY SEEM A  ---*
*---     LITTLE STRANGE.  T2/T3 WILL BE THE SOURCE/COUNT           ---*
*---     REGISTERS FOR THE VSAM1 RECORDS AND R4/R5 WILL BE THE     ---*
*---     CORRESPONDING REGISTERS FOR THE VSAM2 RECORDS.  R6 WILL   ---*
*---     POINT TO THE VERY LAST BYTE OF THE VSAM1 RECORD AND R7    ---*
*---     THE SAME FOR THE VSAM2 RECORD.  SINCE THE VSAM ACCESS IS  ---*
*---     SEQUENTIAL, I DON'T NEED ANOTHER 'POINT' BUT I DO NEED    ---*
*---     TO CHECK THE KEY VALUES AFTER EACH 'GET' TO BE SURE THAT  ---*
*---     I HAVEN'T RUN OUT OF THE CURRENT ITEM'S NOTE RECORDS      ---*
*---     PREMATURELY.                                              ---*
*---------------------------------------------------------------------*
         LA    R2,RECKLEN(,R6)     POINT TO SOURCE DATA
         LA    R4,RECKLEN(,R7)     DITTO FOR THE SECOND RECORD
         A     R6,VS1LEN2          ADD THE BLOCK LENGTH
         BCTR  R6,R0               BACK UP TO LAST BYTE
         A     R7,VS2LEN2          ADD THE BLOCK LENGTH
         BCTR  R7,R0               BACK UP TO LAST BYTE
NOTEA    DS    0H
         LTR   R2,R2               INPUT ADDRESS ZERO ??
         BZ    *+16                YES; DON'T GET A LENGTH
         LA    R3,0                CLEAR THE LENGTH
         ICM   R3,7,0(R2)          AND INSERT THE LENGTH TO COMPARE
         LA    R3,3(,R3)           ACCOUNT FOR SEGMENT HEADER
         LTR   R4,R4               INPUT ADDRESS ZERO ??
         BZ    *+16                YES; DON'T GET A LENGTH
         LA    R5,0
         ICM   R5,7,0(R4)          AND ITS LENGTH
         LA    R5,3(,R5)           ACCOUNT FOR SEGMENT HEADER
         CLCL  R2,R4               COMPARE ---
         BNE   NOTEH               MIS-MATCH; ALL DONE HERE
         CR    R2,R6               AT RECORD END ??
         BL    NOTED               NOPE ---
         L     R1,RPL2             YES; LOAD RPL POINTER
         GET   RPL=(1)             READ ANOTHER 'BLOCK'
         LTR   R15,R15             ANYTHING COME BACK ??
         BNZ   NOTEB               NOPE; ALL DONE
         SHOWCB RPL=(*,RPL2),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         L     R6,VS1BUF1          LOAD THE HEADER'S ADDRESS
         L     R1,VS1BUF2          AND THIS RECORD'S ADDRESS
         CLC   1(44,R1),1(R6)      SAME KEY VALUES ??
         BE    NOTEC               YES; CONTINUE SETUP
NOTEB    DS    0H
         LA    R2,0                CLEAR THE SOURCE ADDRESS
         LR    R3,R3               AND LENGTH
         B     NOTED               AND CONTINUE
NOTEC    DS    0H
         LA    R2,RECKLEN(,R1)     POINT TO FIRST NOTEDATA SEGMENT
         LR    R6,R1               COPY THE RECORD POINTER
         A     R6,VS1LEN2          ADD ITS LENGTH
         BCTR  R6,R0               BACK UP TO LAST BYTE
NOTED    DS    0H
         STM   R2,R3,BLDLAREA      SAVE IN CHECKING AREA
         CR    R4,R7               AT RECORD END ??
         BL    NOTEG               NOPE ---
         L     R1,RPL5             YES; LOAD RPL POINTER
         GET   RPL=(1)             READ ANOTHER 'BLOCK'
         LTR   R15,R15             ANYTHING COME BACK ??
         BNZ   NOTEE               NOPE; ALL DONE
         SHOWCB RPL=(*,RPL5),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS2LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         L     R7,VS2BUF1          LOAD THE HEADER'S ADDRESS
         L     R1,VS2BUF2          AND THIS RECORD'S ADDRESS
         CLC   1(44,R1),1(R7)      SAME KEY VALUES ??
         BE    NOTEF               YES; CONTINUE SETUP
NOTEE    DS    0H
         LA    R4,0                CLEAR COMPARAND ADDRESS
         LR    R5,R4               AND LENGTH
         B     NOTEG               AND CONTINUE
NOTEF    DS    0H
         LA    R4,RECKLEN(,R1)     POINT TO FIRST NOTEDATA SEGMENT
         LR    R7,R1               COPY THE RECORD POINTER
         A     R7,VS2LEN2          ADD ITS LENGTH
         BCTR  R6,R0               BACK UP TO LAST BYTE
NOTEG    DS    0H
         STM   R4,R5,BLDLAREA+8    SAVE IN CHECKING AREA
         CLC   BLDLAREA(16),=4F'0' ALL ZEROS ??
         BNE   NOTEA               NOTE; MORE TO CHECK ---
         MVC   LINE,NOTEOK         MOVE 'COMPARE MATCHED' MESSAGE
         #IF   CMPSHRTL,ON,NOL14   SKIP MSG IF SHORT-FORM LIST
         #PUT  LINE                AND PRINT IT OUT
NOL14    DS    0H
         B     CMPDAT              AND TRY AGAIN
NOTEH    DS    0H
         MVC   LINE,NOTEFAIL       NOTEDATA COMPARE FAILED
         #PUT  LINE                OUTPUT THE MESSAGE
         B     CMPDAT              AND TRY AGAIN
CMPDAT   DS    0H
         EJECT
*---------------------------------------------------------------------*
*---     HEADER AND NOTEDATA RECORD COMPARES ARE COMPLETE. NOW     ---*
*---     START COMPARING THE DATA RECORDS. THE CODE IS THE SAME,   ---*
*---     EXCEPT FOR THE FIRST BYTE OF THE KEY OF EACH RECORD TO    ---*
*---     BE EXAMINED.                                              ---*
*---------------------------------------------------------------------*
*---------------------------------------------------------------------*
*---     AGAIN, WE USE THE NUMBER-2 BUFFERS AND RPLS.              ---*
*---------------------------------------------------------------------*
         L     R6,VS1BUF1          VSAM1'S #2 BUFFER
         L     R7,VS2BUF1          VSAM2'S #2 BUFFER
         L     R2,VS1BUF2          VSAM1'S #2 BUFFER
         L     R3,VS2BUF2          VSAM2'S #2 BUFFER
         MVC   0(RECKLEN,R2),0(R6) COPY VSAM1 KEY
         MVC   0(RECKLEN,R3),0(R7) COPY VSAM2 KEY
         MVI   0(R2),#RTDATA       RECTYPE = NOTE DATA
         MVI   0(R3),#RTDATA       RECTYPE = NOTE DATA
         LR    R6,R2               COPY BUFFER ADDRESS
         LR    R7,R3               DITTO ---
         XC    BLDLAREA,BLDLAREA   SAVE AREA FOR DEBLOCKING STUFF
         L     R2,RPL2             POINT TO AN RPL
         L     R3,RPL5             AND A SECOND RPL
         MODCB RPL=(R2),                                               X
               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X
               ACB=(*,ACB1),                                           X
               ARG=(R6),                                               X
               AREA=(R6),                                              X
               AREALEN=(S,VS1LIM),                                     X
               MF=(G,GENWK)        POSITION TO CLUSTER START
         POINT RPL=(2)             GET TO IT
         GET   RPL=(2)
         SHOWCB RPL=(*,RPL2),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         MODCB RPL=(R3),                                               X
               OPTCD=(SEQ,FKS,KGE,SYN,NUP),                            X
               ACB=(*,ACB2),                                           X
               ARG=(R7),                                               X
               AREA=(R7),                                              X
               AREALEN=(S,VS2LIM),                                     X
               MF=(G,GENWK)        POSITION TO CLUSTER START
         POINT RPL=(3)             GET TO IT
         GET   RPL=(3)
         SHOWCB RPL=(*,RPL5),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS2LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
*---------------------------------------------------------------------*
*---     AT THIS POINT, THE FIRST ARCHIVE RECORD OF ITEM DATA IS   ---*
*---     IN STORAGE, IN THE NUMBER-2 BUFFERS.  HERE'S WHERE THE    ---*
*---     DEBLOCKING AND COMPARING GET REAL HAIRY.  SINCE THE       ---*
*---     VSAM1 AND VSAM2 CLUSTERS MAY HAVE DIFFERRING RECORD       ---*
*---     LENGTHS, EACH VSAM RECORD MUST BE DE-BLOCKED INTO         ---*
*---     INDIVIDUAL ARCHIVER-STYLE LOGICAL RECORDS FOR THE         ---*
*---     COMPARISON.  A CLCL INSTRUCTION THAT SUCCEEDS WILL        ---*
*---     UPDATE THE SOURCE AND COUNT REGISTERS, SAVING ME A FEW    ---*
*---     HEADACHES. FOR THAT REASON, MY REGISTER USAGE MAY SEEM A  ---*
*---     LITTLE STRANGE.  R2/R3 WILL BE THE SOURCE/COUNT           ---*
*---     REGISTERS FOR THE VSAM1 RECORDS AND R4/R5 WILL BE THE     ---*
*---     CORRESPONDING REGISTERS FOR THE VSAM2 RECORDS.  R6 WILL   ---*
*---     POINT TO THE VERY LAST BYTE OF THE VSAM1 RECORD AND R7    ---*
*---     THE SAME FOR THE VSAM2 RECORD.  SINCE THE VSAM ACCESS IS  ---*
*---     SEQUENTIAL, I DON'T NEED ANOTHER 'POINT' BUT I DO NEED    ---*
*---     TO CHECK THE KEY VALUES AFTER EACH 'GET' TO BE SURE THAT  ---*
*---     I HAVEN'T RUN OUT OF THE CURRENT ITEM'S DATA RECORDS      ---*
*---     PREMATURELY.                                              ---*
*---------------------------------------------------------------------*
         LA    R2,RECKLEN(,R6)     POINT TO SOURCE DATA
         LA    R4,RECKLEN(,R7)     DITTO FOR THE SECOND RECORD
         A     R6,VS1LEN2          ADD THE BLOCK LENGTH
         BCTR  R6,R0               BACK UP TO LAST BYTE
         A     R7,VS2LEN2          ADD THE BLOCK LENGTH
         BCTR  R7,R0               BACK UP TO LAST BYTE
DATAA    DS    0H
         LTR   R2,R2               INPUT ADDRESS ZERO ??
         BZ    *+16                YES; DON'T GET A LENGTH
         LA    R3,0                CLEAR THE LENGTH
         ICM   R3,7,0(R2)          AND INSERT THE LENGTH TO COMPARE
         LA    R3,3(,R3)           ACCOUNT FOR SEGMENT HEADER
         LTR   R4,R4               INPUT ADDRESS ZERO ??
         BZ    *+16                YES; DON'T GET A LENGTH
         LA    R5,0
         ICM   R5,7,0(R4)          AND ITS LENGTH
         LA    R5,3(,R5)           ACCOUNT FOR SEGMENT HEADER
         CLCL  R2,R4               COMPARE ---
         BNE   DATAH               MIS-MATCH; ALL DONE HERE
         CR    R2,R6               AT RECORD END ??
         BL    DATAD               NOPE ---
         L     R1,RPL2             YES; LOAD RPL POINTER
         GET   RPL=(1)             READ ANOTHER 'BLOCK'
         LTR   R15,R15             ANYTHING COME BACK ??
         BNZ   DATAB               NOPE; ALL DONE
         SHOWCB RPL=(*,RPL2),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         L     R6,VS1BUF1          LOAD THE HEADER'S ADDRESS
         L     R1,VS1BUF2          AND THIS RECORD'S ADDRESS
         CLC   1(44,R1),1(R6)      SAME KEY VALUES ??
         BE    DATAC               YES; CONTINUE SETUP
DATAB    DS    0H
         LA    R2,0                CLEAR THE SOURCE ADDRESS
         LR    R3,R3               AND LENGTH
         B     DATAD               AND CONTINUE
DATAC    DS    0H
         LA    R2,RECKLEN(,R1)     POINT TO FIRST DATADATA SEGMENT
         LR    R6,R1               COPY THE RECORD POINTER
         A     R6,VS1LEN2          ADD ITS LENGTH
         BCTR  R6,R0               BACK UP TO LAST BYTE
DATAD    DS    0H
         STM   R2,R3,BLDLAREA      SAVE IN CHECKING AREA
         CR    R4,R7               AT RECORD END ??
         BL    DATAG               NOPE ---
         L     R1,RPL5             YES; LOAD RPL POINTER
         GET   RPL=(1)             READ ANOTHER 'BLOCK'
         LTR   R15,R15             ANYTHING COME BACK ??
         BNZ   DATAE               NOPE; ALL DONE
         SHOWCB RPL=(*,RPL5),                                          X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS2LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         L     R7,VS2BUF1          LOAD THE HEADER'S ADDRESS
         L     R1,VS2BUF2          AND THIS RECORD'S ADDRESS
         CLC   1(44,R1),1(R7)      SAME KEY VALUES ??
         BE    DATAF               YES; CONTINUE SETUP
DATAE    DS    0H
         LA    R4,0                CLEAR COMPARAND ADDRESS
         LR    R5,R4               AND LENGTH
         B     DATAG               AND CONTINUE
DATAF    DS    0H
         LA    R4,RECKLEN(,R1)     POINT TO FIRST DATADATA SEGMENT
         LR    R7,R1               COPY THE RECORD POINTER
         A     R7,VS2LEN2          ADD ITS LENGTH
         BCTR  R6,R0               BACK UP TO LAST BYTE
DATAG    DS    0H
         STM   R4,R5,BLDLAREA+8    SAVE IN CHECKING AREA
         CLC   BLDLAREA(16),=4F'0' ALL ZEROS ??
         BNE   DATAA               NOTE; MORE TO CHECK ---
         COPY  CRAMPON             CALL 'CRAMP'                 *DHC*
         #IF   CMPSHRTL,ON,NOL16   SKIP MSG IF SHORT-FORM LIST
         MVC   LINE,DATAOK         MOVE 'COMPARE MATCHED' MESSAGE
         #PUT  LINE                AND PRINT IT OUT
NOL16    DS    0H
         B     SRCH2               AND TRY AGAIN
DATAH    DS    0H
         #IF   CMPSHRTL,OFF,NOF2
         L     R6,VS1BUF1
         L     R7,VS2BUF1
         #FORMAT 0(,R6),,SELECT1
         #PUT  LINE
         #FORMAT 0(,R7),,SELECT2
         #PUT  LINE
NOF2     DS    0H
         MVC   LINE,DATAFAIL       DATADATA COMPARE FAILED
         #PUT  LINE                OUTPUT THE MESSAGE
         B     SRCH2               AND TRY AGAIN
*+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*
         B     SRCH2               AND TRY AGAIN
ENDITALL DS    0H
         #PUT  SEPREC
         #PUT  COMPCOMP
         LA    R1,VSAM1DD          POINT TO THE DDNAME
         LA    R0,4                SET 'CLOSE' REQUEST
         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE
         LA    R1,VSAM2DD          POINT TO THE DDNAME
         LA    R0,4                SET 'CLOSE' REQUEST
         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE
         COPY  CRAMPOFF            END 'CRAMP'                  *DHC*
         L     R13,4(,R13)         COPY BACK S.A. POINTER
         LM    R14,R12,12(R13)     RESTORE REGISTERS
         LA    R15,0               ALWAYS RC = 0
         MVI   12(R13),255
         BR    R14                 AND RETURN TO CALLER
ERR12    DC    CL133'0          COMPARE PROCESSING COMPLETED.  TOTALS FX
               OLLOW: '
MCMSG    DC    CL133' '
         ORG   MCMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202120'
         DC    C' TOTAL ITEM(S) PROCESSED.'
         ORG
         LTORG
SEPREC   DC    CL1' ',132C'-'
COMPCOMP DC    CL133'          ARCHIVER COMPARE FUNCTION IS COMPLETE.'
FM1      DC    CL133'          LMOD FLAGS MISMATCH. FURTHER COMPARES ABX
               ORTED.'
FM2      DC    CL133'          RECFM VALUES MISMATCH. HEADER CHECKS WILX
               L CONTINUE.'
FM3      DC    CL133'          LRECL VALUES MISMATCH. HEADER CHECKS WILX
               L CONTINUE.'
FM4      DC    CL133'          BLKSIZE VALUES MISMATCH. HEADER CHECKS WX
               ILL CONTINUE.'
FM5      DC    CL133'          HEADER COMPARE FAILED. REMAINDER OF COMPX
               ARE IS BYPASSED.'
FM6      DC    CL133'          RECORD COUNTS MISMATCH. HEADER CHECKS WIX
               LL CONTINUE.'
FM7      DC    CL133'          NOTE RECORD COUNTS MISMATCH.  HEADER CHEX
               CKS WILL CONTINUE.'
FM8      DC    CL133'          UNLOAD DATES MISMATCH.  HEADER CHECKS WIX
               LL CONTINUE.'
FM9      DC    CL133'          UNLOAD TIMES MISMATCH.  HEADER CHECKS WIX
               LL CONTINUE.'
SC1      DC    CL133'          HEADER COMPARE SUCCEEDED.  PROCEEDING TOX
                COMPARE NOTE AND DATA RECORDS.'
NOTEOK   DC    CL133'          COMPARE OF NOTE DATA INDICATES EQUALITY.X
                PROCEEDING TO DATA RECORDS.'
DATAOK   DC    CL133'          COMPARE OF ITEM DATA INDICATES EQUALITY.X
                ITEMS ARE PROBABLY EQUIVALENT.'
DATAFAIL DC    CL133'          COMPARE OF ITEM DATA FAILED. ITEMS ARE NX
               OT EQUAL TO EACH OTHER.'
NOTEFAIL DC    CL133'          COMPARE OF NOTE DATA FAILED. PROCEEDING X
               TO DATA RECORDS.'
SELECT1  DC    AL1(50),CL50' SELECTED FROM VSAM1 CLUSTER FOR COMPARE.'
SELECT2  DC    AL1(50),CL50' SELECTED FROM VSAM2 CLUSTER FOR COMPARE.'
NOMATCH  DC    CL133'  *** NO CORRESPONDING ITEM FOUND IN THE VSAM2 ARCX
               HIVE.'
*---------------------------------------------------------------------*
*---     THESE EQUATES REPRESENT THE BASIC OFFSETS INTO ARCHIVE    ---*
*---     RECORDS FOR VARIOUS FIELDS.  SINCE I CAN'T BASE THE SAME  ---*
*---     DSECT ON TWO REGISTERS AT THE SAME TIME, THIS APPROACH    ---*
*---     ALLOWS ME TO ACCOMPLISH THE SAME END, WITHIN LIMITS.      ---*
*---------------------------------------------------------------------*
OFFAG    EQU   RECAG-REC
OFFAN    EQU   RECAN-REC
OFFASG   EQU   RECASG-REC
OFFAT    EQU   RECAT-REC
OFFAVER  EQU   RECAVER-REC
OFFBLK   EQU   RSRBLK-REC
OFFDATA  EQU   RECDATA-REC
OFFDATE  EQU   RSRDATE-REC
OFFDEV   EQU   RSRDEV-REC
OFFDSO   EQU   RSRDSO-REC
OFFFLAG1 EQU   RSRFLAG1-REC
OFFFLAG2 EQU   RSRFLAG2-REC
OFFFLAG3 EQU   RSRFLAG3-REC
OFFFLAG4 EQU   RSRFLAG4-REC
OFFG     EQU   RECG-REC
OFFLMOD  EQU   RSRLMOD-REC
OFFLRE   EQU   RSRLRE-REC
OFFN     EQU   RECN-REC
OFFNOT#  EQU   RSRNOT#-REC
OFFNOTE  EQU   RDATNOTE-REC
OFFPDIR  EQU   RSRPDIR-REC
OFFRCNT  EQU   RSRRCNT-REC
OFFREC   EQU   RSRREC-REC
OFFSEQ#  EQU   RECSEQ#-REC
OFFSG    EQU   RECSG-REC
OFFT     EQU   RECT-REC
OFFTIME  EQU   RSRTIME-REC
OFFTT    EQU   RECTT-REC
OFFVER   EQU   RECVER-REC
*---------------------------------------------------------------------*
*---     SAME THING FOR SPF DIRECTORY ENTRY FIELDS                 ---*
*---------------------------------------------------------------------*
OSDCDATE EQU   SDECDATE-SDE
OSDCLINE EQU   SDECLINE-SDE
OSDID    EQU   SDEID-SDE
OSDILINE EQU   SDEILINE-SDE
OSDMDATE EQU   SDEMDATE-SDE
OSDMLINE EQU   SDEMLINE-SDE
OSDMOD   EQU   SDEMOD-SDE
OSDMTIME EQU   SDEMTIME-SDE
OSDNAME  EQU   SDENAME-SDE
OSDTTR   EQU   SDETTR-SDE
OSDVERS  EQU   SDEVERS-SDE
*---------------------------------------------------------------------*
*---     SAME THING FOR LMOD DIRECTORY ENTRIES (ONLY THE           ---*
*---     BASIC FIELDS)                                             ---*
*---------------------------------------------------------------------*
OPDBCEND EQU   PDSBCEND-PDS2
OPDATR   EQU   PDS2ATR-PDS2
OPDATR1  EQU   PDS2ATR1-PDS2
OPDATR2  EQU   PDS2ATR2-PDS2
OPDEPA   EQU   PDS2EPA-PDS2
OPDFTBL  EQU   PDS2FTBL-PDS2
OPDFTBO  EQU   PDS2FTBO-PDS2
OPDFTB1  EQU   PDS2FTB1-PDS2
OPDFTB2  EQU   PDS2FTB2-PDS2
OPDFTB3  EQU   PDS2FTB3-PDS2
OPDINDC  EQU   PDS2INDC-PDS2
OPDNAME  EQU   PDS2NAME-PDS2
OPDNL    EQU   PDS2NL-PDS2
OPDRLDS  EQU   PDS2RLDS-PDS2
OPDSTOR  EQU   PDS2STOR-PDS2
OPDTTRN  EQU   PDS2TTRN-PDS2
OPDTTRP  EQU   PDS2TTRP-PDS2
OPDTTRT  EQU   PDS2TTRT-PDS2
OPDUSRD  EQU   PDS2USRD-PDS2
OPDZERO  EQU   PDS2ZERO-PDS2
         COPY  #RECS
         COPY  ##ARCHWK
         IHAPDS DSECT=YES
         SDE
         END
