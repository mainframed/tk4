*
*  AUTHOR:   JEFF SPREHN
*
*
*  CCCC    OOOO   NN     NN   CCCC        A   TTTTTTTT EEEEE MM      MM
* CC   C  OOOOOO  NN     NN  CC   C      AAA  TTTTTTTT EEEEE MMM    MMM
*CC      OO    OO NNN    NN CC          AA AA    TT    EE    MMMM  MMMM
*CC      OO    OO NNNN   NN CC          AA AA    TT    EE    MM  MM  MM
*CC      OO    OO NN NN  NN CC         AA   AA   TT    EEEEE MM      MM
*CC      OO    OO NN  NN NN CC         AAAAAAA   TT    EEEEE MM      MM
*CC      OO    OO NN   NNNN CC        AA     AA  TT    EE    MM      MM
*CC      OO    OO NN    NNN CC        AA     AA  TT    EE    MM      MM
* CC   C  OOOOOO  NN     NN  CC    C AA       AA TT    EEEEE MM      MM
*  CCCC    OOOO   NN      N   CCCCC  AA       AA TT    EEEEE MM      MM
*
*
*  VER/MOD LEVELS:
*  ---------------
*
*      1.0  ORIGINAL DISTRIBUTION
*
*      1.1  (MARCH 85)  MADE MODIFICATION TO THE TWO BYTE S99FLAG1
*                       FOR THE DYNAMIC ALLOCATION (VERB CODE 01)
*                       (ALLOCPRM) FROM X'2000'
*                                  TO   X'A000'
*
*      1.2  (MAY 85)    MADE CORRECTION TO CODE IN ERROR IN ROUTINE
*                       UNPKHEX FROM  MVC  1,=CL3'HTC'
*                               TO    MVC  CNVTYPE,=CL3'HTC'
*
*      1.3  (APR 86)    1.  ADDED AN ALIAS OF DATASET TO THE KEYWORD
*                           DSNAME
*                       2.  ADDED A DEFAULT OF ACTCODE(A) IF THE
*                           ACTCODE KEYWORD PARAMETER WAS NOT
*                           SUPPLIED
*
*      2.0  (8/25/88)   REVISIONS MADE BY GORDON SCHILLINGER TO
*                       ALLOW COMMAND TO RUN RE-ENTRANT, DUE TO
*                       ITS HIGH USAGE.
*
*      2.G  (14AUG98)   REVISIONS MADE BY GREG PRICE AT GECITS
*                       TO VERSION FROM CBT (V418) FILE 270 TO
*                       USE INLINE SOURCE FOR SINGLE DECK PACKAGE:
*                       - DSNTAB SOURCE ADDED AFTER END STATEMENT.
*                       - ENTERR, LEAVER, KKPARSE AND MOVE MACROS
*                         ELIMINATED.
*                       - REPLACE HEXTRAN CALL WITH UNPK AND TR.
*                       - REPLACE IKJUPDT CALL WITH TPUT OF OUTMSG,
*                         SO CLIST VARIABLE &OUTMSG IS NO LONGER SET.
*                       - FIX GLITCHES FROM RE-ENTRANTCY CONVERSION.
*           (09OCT98)   REVISIONS MADE BY GREG PRICE AT GECITS:
*                       - ADD SWA=ABOVE SUPPORT (USE SOME AMODE-31).
*           (21OCT98)   REVISIONS MADE BY GREG PRICE AT GECITS:
*                       - CHANGE ALLOCPRM S99FLAG1 BACK TO X'2000'.
*           (06SEP99)   REVISIONS MADE BY GREG PRICE:
*                       - CLEAR R1 BEFORE LOADING JFCB POINTER.
*
*  --------------------------------------------------------------------
*  COMMAND     OPERANDS
*  --------------------------------------------------------------------
*  CONCATEM    ACTCODE('ACTION CODE') DDNAME('DDNAME') DSNAME('DSNAME')
*                                     OR FILE          OR DATASET
*  --------------------------------------------------------------------
*
*
*  OPERANDS -
*
*     REQUIRED -
*
*        ACTCODE('ACTION CODE') --'ACTION CODE' IS EITHER 'A' OR 'D'
*
*                                    'A'  FOR CONCATENATING THE
*                                         SUPPLIED DSNAME TO THE
*                                         SUPPLIED DDNAME AT THE
*                                         FRONT OF THE CONCATENATED
*                                         GROUP
*
*                                    'D'  FOR REMOVING THE SUPPLIED
*                                         DSNAME FROM THE CONCATENATED
*                                         GROUP ASSOCIATED WITH THE
*                                         SUPPLIED DDNAME
*
*
*
*        DDNAME('DDNAME') ------- 'DDNAME' IS THE DDNAME WITH WHICH WE
*        OR FILE                  WANT TO CONCATENATE OR DECONCATENATE
*                                 TO
*
*        DSNAME('DSNAME') ------- 'DSNAME' IS THE DSNAME WITH WHICH WE
*                                 WANT TO CONCATENATE OR REMOVE FROM
*                                 CONCATENATION
*
         EJECT
*
*
*        THIS COMMAND WILL ALSO MAKE AVAILABLE TWO VARIABLES THAT AN
*        INVOKING CLIST MAY INTERROGATE.  BELOW IS A TABLE OF VALUES
*        AFTER EXECUTION OF THIS COMMAND FOR THESE TWO VARIABLES
*        &OUTMSG AND &LASTCC (RETURN CODE)
*
*        ×---------×------------------------------------------------×
*        × &LASTCC ×                 &OUTMSG                        ×
*        ×---------×------------------------------------------------×
*        ×    0    × SUCCESSFUL COMPLETION                          ×
*        ×---------×------------------------------------------------×
*        ×    4    × DYNAMIC ALLOC ERROR (ERR REASON CODE = XXXX)   ×
*        ×---------×------------------------------------------------×
*        ×    8    × DYNAMIC DEALLOC ERROR (ERR REASON CODE = XXXX) ×
*        ×---------×------------------------------------------------×
*        ×    12   × MISSING ACTION CODE                            ×
*        ×---------×------------------------------------------------×
*        ×    16   × MISSING DDNAME PARAMETER                       ×
*        ×---------×------------------------------------------------×
*        ×    20   × MISSING DSNAME PARAMETER                       ×
*        ×---------×------------------------------------------------×
*        ×    24   × INVALID ACTION CODE  (MUST BE A OR D)          ×
*        ×---------×------------------------------------------------×
*        ×    28   × DYNAMIC CONCAT  ERROR (ERR REASON CODE = XXXX) ×
*        ×---------×------------------------------------------------×
*        ×    32   × MORE THAN 50 DATASETS ALREADY ALLOCATED        ×
*        ×---------×------------------------------------------------×
*        ×    36   × CANNOT DO DEALLOCATION -- DDNAME NOT ALLOCATED ×
*        ×---------×------------------------------------------------×
*        ×    40   × CANNOT DO DEALLOCATION -- DSNAME NOT ALLOCATED ×
*        ×---------×------------------------------------------------×
*        ×    96   × INVALID SYNTAX OF ONE OR MORE OPERANDS         ×
*        ×---------×------------------------------------------------×
*
         EJECT
CONCATEM CSECT
         SAVE  (14,12),,CONCATEM-V_2.G
         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING
         USING CONCATEM,R12
         LR    R10,R1             SAVE PARM PTR R10->PARM PTR
         L     R0,=A(WORKLEN)     R0=GET LENGTH
         GETMAIN R,LV=(0)         R1->WORKAREA
         LR    R11,R13            R11->CALLERS SAVEAREA
         LR    R13,R1             R13->WORKAREA
         USING WORKAREA,R13
         L     R15,=A(WORKLEN)    R0=GET LENGTH
         S     R15,=F'72'         SKIP REGS
         LA    R14,72(,R13)
         LA    R0,0
         LA    R1,0
         MVCL  R14,R0             ZERO WORK AREA AFTER SAVEAREA GP 8/98
         ST    R11,SAVEAREA+4     SAVE HIS SAVEAREA PTR
         LA    R13,SAVEAREA       R13->SAVEAREA (MINE)
         ST    R13,8(,R11)        MINE IN HIS
         LR    R11,R1             R11->WORKAREA IN CASE NOT SAME AS R13
*                       WORKAREA ADDR IS STILL R13 FOR
*                       THE ASSEMBLER - IF DIFFERENT FROM R13
*                       THEN USE: DROP R13 AND USING &WA.,R11
         LR    R1,R10             RESTORE PARM PTR PTR
*        LA    R3,BASEREG2   R3 IS TO BE THE SECOND BASE REGISTER
*        USING BASEREG2,R3
         EJECT
********************************************************************
*                                                                  *
*      M A I N   L I N E   L O G I C   F O R   C O N C A T E M     *
*                                                                  *
********************************************************************
*
         LR    R11,R1              SAVE THE PARM POINTER
         LA    R4,0                R4==> 0
         BAL   R14,DOPARSE         PERFORM THE PARSE SERVICE ROUTINE
         CLC   PROCESSW,=C'YES'    WAS PARSE SUCCESFUL ?
         BNE   INITL               IF NOT, BRANCH TO INITL
         BAL   R14,LOADFLDS        PERFORM ROUTINE TO LOAD THE PARSED
*                                    FIELDS INTO APPROP DATA FIELDS
         CLC   PROCESSW,=C'YES'    IS EVERTHING STILL HONKEY DOREY ?
         BNE   INITL               IF NOT, BRANCH TO INITL
*
*        INIT POINTERS IN DYNAMIC WORKAREA
         MVC   ALLOCPRM(ALLOCLEN),DALLINIT
         MVC   FREEPARM(FREELEN),FREEINIT
         MVC   CNCTPARM(CNCTLEN),CNCTINIT
         LA    R1,ALLOCRB
         ST    R1,ALLOCPRM         ALLOC REQUEST BLOCK PTR
         OI    ALLOCPRM,X'80'
         LA    R1,ALLOCTUA
         ST    R1,ALLOCERC+4       PTR TO TEXT UNIT PTRS
         LA    R1,ALLOCUT1
         ST    R1,ALLOCTUA         TEXT UNIT #1 PTR
         LA    R1,ALLOCUT2
         ST    R1,ALLOCTUA+4       TEXT UNIT #2 PTR
         LA    R1,ALLOCUT3
         ST    R1,ALLOCTUA+8       TEXT UNIT #3 PTR
         LA    R1,ALLOCUT4
         ST    R1,ALLOCTUA+12      TEXT UNIT #4 PTR
         OI    ALLOCTUA+12,X'80'
         LA    R1,FREERB
         ST    R1,FREEPARM         FREE REQEST BLOCK PTR
         OI    FREEPARM,X'80'
         LA    R1,FREETUPL
         ST    R1,FREEERC+4        PTR TO TEXT UNIT PTR
         LA    R1,FREEUNT1
         ST    R1,FREETUPL         TEXT UNIT #1 PTR
         LA    R1,FREEUNT2
         ST    R1,FREETUPL+4       TEXT UNIT #2 PTR
         OI    FREETUPL+4,X'80'
         LA    R1,CNCTRB
         ST    R1,CNCTPARM         CONCAT REQUEST BLOCK PTR
         OI    CNCTPARM,X'80'
         LA    R1,CNCTTUPL
         ST    R1,CNCTERC+4        PTR TO TEXT UNIT PTR
         LA    R1,CNCTUNT1
         ST    R1,CNCTTUPL         TEXT UNIT PTR
         OI    CNCTTUPL,X'80'
*
         BAL   R14,MAJORTN         PERFORM ROUTINE TO DO THE
*                                    CONCATENATION OR DECONCATENATION
*                                    AS REQUESTED
**       C    R4,=F'0'             WERE ANY ERRORS ENCOUNTERED?
**       BNE  INITL                IF THERE WERE, BRANCH TO INITL
         LTR  R4,R4                WERE ANY ERRORS ENCOUNTERED? GP 8/98
         BZ   SHUTDOWN             NO SO SKIP MESSAGE           GP 8/98
**       MVC  OUTMSG,GOODMSG       MOVE 'SUCCESSFUL COMPLETION'
*                                    TO OUTMSG
**INITL  BAL   R14,INITLIST        BUILD PARMLIST FOR IKJUPDT
**       MVC   DDNEOT,=H'-1'       MARK END OF DDN TABLE
**       BAL   R14,SETOUTMG        SET CLIST VARIABLE OUTMSG
INITL    LA    R1,OUTMSG                                        GP 8/98
         LA    R0,L'OUTMSG         ISSUE ERROR MESSAGE          GP 8/98
         TPUT  (1),(0),R                                        GP 8/98
         B     SHUTDOWN            BRANCH TO SHUTDOWN
         EJECT
********************************************************************
*                                                                  *
*        P A R S E   I N P U T   C O M M A N D   B U F F E R       *
*                                                                  *
********************************************************************
*
DOPARSE  ST    R14,SAVEIT1          SAVE REG 14 CONTENTS IN SAVEIT1
         USING CPPL,R11           POINTS TO CPPL (PARM LIST)
*
         LA    R1,PPLA            R1->PPL AREA
         USING PPL,R1             TELL ASSEMBLER POINTS TO PPL AREA
*
*                         CONSTRUCT PARSE PARAMETER LIST
*                                           FOR IKJPARS :
*
         MVC   PPLUPT,CPPLUPT     UPT
         MVC   PPLECT,CPPLECT     ECT
         LA    R15,ECB            ECB
         ST    R15,PPLECB
         L     R15,=V(PCL)        PCL
         ST    R15,PPLPCL
         LA    R15,ANS            ANS
         ST    R15,PPLANS
         MVC   PPLCBUF,CPPLCBUF   CBUF
         XC    PPLUWA,PPLUWA
*
         DROP  R1
         EJECT
*        CALLTSSR EP=IKJPARS      CALL PARSE:
         CALLTSSR EP=IKJPARS      CALL PARSE:
         LTR   R15,R15              RC = 0 ? (I.E PARSE GO OK ?)
         BNZ   PARSERR              IF NOT, BRANCH TO PARSERR
         MVC   PROCESSW,=C'YES'     MOVE 'YES' TO PROCESSW
         L     R10,ANS
         USING IKJPARMD,R10
         B     EXITPARS
PARSERR  MVC   PROCESSW,=C'NO '     MOVE 'NO ' TO PROCESSW
         LA    R4,96                SET REG 4 = 96
         MVC   OUTMSG,ERRMSG3       MOVE 'INVALID SYNTAX OF ONE OR
*                                     MORE OPERANDS' TO OUTMSG
EXITPARS L     R14,SAVEIT1
         BR    14
         EJECT
********************************************************************
*                                                                  *
*        THIS ROUTINE PROCESSES THE PARSED FIELDS, AND LOADS       *
*        THE FOLLOWING FIVE DATA FIELDS:                           *
*                                                                  *
*               INACTCD                                            *
*               INDDNAME                                           *
*               INDDNLEN                                           *
*               INDSNAME                                           *
*               INDSNLEN                                           *
*                                                                  *
********************************************************************
*
LOADFLDS ST    R14,SAVEIT2             SAVE REG 14 CONTENTS IN SAVEIT2
         MVC   PROCESSW,=CL3'YES'      MOVE 'YES' TO PROCESSW
*
         B     MODVER13                MODIFICATION (VER 1.3) MADE CUZ
*                                      THE FOLLOWING TEST IS NO LONGER
*                                      NEEDED
*
         TM    ACTCDSTR+6,X'80'        IS ACTION CODE PRESENT ?
         BNO   NOACTCD                 IF NOT, BRANCH TO NOACTCD
*
MODVER13 L     R8,ACTCDSTR             R8 ==> ADDRESS OF THE ACT CODE
         MVC   INACTCD(1),0(R8)        MOVE ACT CODE TO INACTCD
         CLI   INACTCD,C'A'            IS ACTION CODE = 'A' ?
         BE    LOADDDN                 IF SO, BRANCH TO LOADDDN
         CLI   INACTCD,C'D'            IS ACTION CODE = 'D' ?
         BE    LOADDDN                 IF SO, BRANCH TO LOADDDN
         MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW
         LA    R4,24                   SET REG 4 = 24
         MVC   OUTMSG,ERRMSG7          MOVE 'INVALID ACTION CODE'
*                                        TO OUTMSG
         B     EXITLOAD                BRANCH TO EXITLOAD
LOADDDN  TM    DDNSTRNG+6,X'80'        IS DDNAME PRESENT ?
         BNO   NODDNAME                IF NOT, BRANCH TO NODDNAME
         MVC   INDDNAME,=CL8' '        MOVE SPACES TO INDDNAME
         LA    R1,INDDNAME             R1 ==> ADDRESS OF INDDNAME
         L     R8,DDNSTRNG             R8 ==> ADDRESS OF THE DDNAME
         LH    R7,DDNSTRNG+4           R7 ==> LENGTH OF THE DDNAME
         S     R7,=F'1'                SUBTRACT 1 FOR EX
         SPACE 1
MOVEDDN  MVC   0(0,R1),0(R8)           MOVE THE DDNAME TO INDDNAME
         EX    R7,MOVEDDN
         SPACE 1
         MVC   INDDNLEN(2),DDNSTRNG+4  INDDNLEN ==> LENGTH OF DDNAME
         TM    DSNSTRNG+6,X'80'        IS DSNAME PRESENT ?
         BNO   NODSNAME                IF NOT, BRANCH TO NODSNAME
         MVC   INDSNAME,=CL44' '       MOVE SPACES TO INDSNAME
         LA    R1,INDSNAME             R1 ==> ADDRESS OF INDSNAME
         L     R8,DSNSTRNG             R8 ==> ADDRESS OF THE DSNAME
         LH    R7,DSNSTRNG+4           R7 ==> LENGTH OF THE DSNAME
         S     R7,=F'1'                SUBTRACT 1 FOR EX
         SPACE 1
MOVEDSN  MVC   0(0,R1),0(R8)           MOVE THE DSNAME TO INDSNAME
         EX    R7,MOVEDSN
         SPACE 1
         MVC   INDSNLEN(2),DSNSTRNG+4  INDSNLEN ==> LENGTH OF DSNAME
         B     EXITLOAD                BRANCH TO EXITLOAD
NOACTCD  MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW
         LA    R4,12                   SET REG 4 = 12
         MVC   OUTMSG,ERRMSG4          MOVE 'MISSING ACTION CODE'
*                                        TO OUTMSG
         B     EXITLOAD                BRANCH TO EXITLOAD
NODDNAME MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW
         LA    R4,16                   SET REG 4 = 16
         MVC   OUTMSG,ERRMSG5          MOVE 'MISSING DDNAME' TO OUTMSG
         B     EXITLOAD                BRANCH TO EXITLOAD
NODSNAME MVC   PROCESSW,=CL3'NO '      MOVE 'NO ' TO PROCESSW
         LA    R4,20                   SET REG 4 = 20
         MVC   OUTMSG,ERRMSG6          MOVE 'MISSING DSNAME' TO OUTMSG
EXITLOAD L     R14,SAVEIT2
         BR    R14
         EJECT
*
********************************************************************
*                                                                  *
*        THIS IS THE MAJOR ROUTINE OF THIS PROGRAM.  IT WILL       *
*        EXAMINE THE ACTION CODE TO SEE IF THE USER REQUESTED      *
*        CONCATENATION OR DECONCATENATION.  IF THE USER REQUESTED  *
*        CONCATENATION, THEN THIS ROUTINE WILL CONCATENATE THE     *
*        DSNAME PASSED TO IT IN FRONT OF THE EXISTING              *
*        CONCATENATED DATASETS TO THE GIVEN DDNAME.  IF THE USER   *
*        REQUESTED DECONCATENATION, THEN THIS ROUTINE WILL         *
*        REMOVE THE DSNAME PASSED TO IT FROM THE CONCATENATION.    *
*                                                                  *
********************************************************************
*
MAJORTN  ST    R14,SAVEIT3            SAVE REG 14 IN SAVEIT3
         MVI   DDNTABLE,X'FF'                  ---
         MVC   DDNTABLE+1(199),DDNTABLE          ---
         MVI   DDNTABLE+200,X'FF'                    --- INIT DDNTABLE
         MVC   DDNTABLE+201(199),DDNTABLE+200    ---
         MVI   DDNTABLE+400,X'FF'              ---
         MVC   DDNTABLE+401(99),DDNTABLE+400   ---
         CLI   INACTCD,C'A'           ACTION CODE = 'A' ?
         BNE   UNALLOC                IF NOT, BRANCH TO UNALLOC
         MVC   GTDSNDDN,INDDNAME      MOVE INDDNAME TO GTDSNDDN
         BAL   R14,GETDSNS            PERFORM ROUTINE TO DETERMINE
*                                        WHETHER THE DDNAME IS
*                                        ALLOCATED AND IF SO TO OBTAIN
*                                        LIST OF ASSOCIATED DSNAMES
         CLI   GTDSNSW,C'0'           WAS DDNAME ALREADY ALLOCATED ?
         BE    CONCAT3                IF SO, BRANCH TO CONCAT3
         CLI   GTDSNSW,C'1'           WAS DDNAME NOT ALREADY ALLOCATED?
         BE    CONCAT2                IF SO, BRANCH TO CONCAT2
         MVC   OUTMSG,ERRMSG9         MOVE 'MORE THAN 50 DATASETS
*                                        ALREADY ALLOCATED' TO OUTMSG
         LA    R4,32                  SET R4 TO 32
         B     EXITMAJR               BRANCH TO EXITMAJR
CONCAT2  LA    R7,DDNTABLE            R7==> ADDRESS OF DDNTABLE
         MVC   ALLOCDSN,INDSNAME      MOVE DSNAME TO ALLOCDSN
         MVC   ALLOCDDN,INDDNAME      MOVE DDNAME TO ALLOCDDN
         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN
         MVC   DSNLEN,INDSNLEN        MOVE LENGTH OF DSNAME TO DSNLEN
         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO
*                                        DYNAMIC ALLOCATION
         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?
         BE    CONCAT18               IF SO, BRANCH TO CONCAT15 GP07/98
         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG
*                                        TO OUTMSG
         B     EXITMAJR               BRANCH TO EXITMAJR
CONCAT3  MVC   DALLCDDN,INDDNAME      MOVE DDNAME TO DALLCDDN
         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN
         BAL   R14,DEALLOK            PERFORM ROUTINE TO DO DYNAMIC
*                                        DEALLOCATION
         CLC   DALLCOK,=CL3'YES'      WAS DEALLOCATION SUCCESSFUL ?
         BE    CONCAT4                IF SO, BRANCH TO CONCAT4
         MVC   OUTMSG,DALLCMSG        MOVE DYNAMIC DEALLOC ERR MSG
*                                        TO OUTMSG
         B     EXITMAJR               BRANCH TO EXITMAJR
CONCAT4  MVC   ALLOCDSN,INDSNAME      MOVE DSNAME TO ALLOCDSN
         MVC   ALLOCDDN,INDDNAME      MOVE DDNAME TO ALLOCDDN
         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN
         MVC   DSNLEN,INDSNLEN        MOVE LENGTH OF DSNAME TO DSNLEN
         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO
*                                        DYNAMIC ALLOCATION
         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?
         BE    CONCAT5                IF SO, BRANCH TO CONCAT5
         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG
*                                        TO OUTMSG
         B     EXITMAJR               BRANCH TO EXITMAJR
CONCAT5  LH    R6,DSNSCNT             R6==> NO OF SIGNIF ENTRIES IN
*                                        DSNAMES TABLE
         LA    R7,0                   R7==> 0
         LA    R8,DSNSTABL            R8==> ADDRESS OF DSNAMES TABLE
         LA    R9,DDNTABLE            R9==> ADDRESS OF GENERATED
*                                        DDNAMES TABLE
CONCAT6  CR    R7,R6                  HAVE WE ALLOCATED ALL OF THE
*                                        DSNAMES ?
         BE    CONCAT8                IF SO, BRANCH TO CONCAT8
         MVC   ALLOCDSN,6(R8)         ALLOCDSN==> DSNAME TO BE ALLOC
         MVC   ALLOCDDN,=CL8'DDNRETRN'
         MVC   DSNLEN,4(R8)           DSNLEN==> LENGTH OF DSNAME
         BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO DYNAMIC
*                                        ALLOC & RETURN GEN DDNAME
         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?
         BE    CONCAT7                IF SO, BRANCH TO CONCAT7
         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG
*                                        TO OUTMSG
         B     EXITMAJR               BRANCH TO EXITMAJR
CONCAT7  MVC   0(2,R9),ALLOCU1A       LOAD LENGTH OF DDNAME ENTRY
*                                        INTO DDNAMES TABLE
         MVC   2(8,R9),ALLOCU1B       LOAD DDNAME INTO DDNAMES TABLE
         A     R7,=F'1'               ADD 1 TO REG 7
         A     R8,=F'50'              ADD 50 TO REG 8
         A     R9,=F'10'              ADD 10 TO REG 9
         B     CONCAT6                BRANCH TO CONCAT6
CONCAT8  LA    R6,DSNSTABL            R6==> ADDRESS OF DSNSTABL
         LA    R7,0                   R7==> 0
         LH    R8,DSNSCNT             R8==> # OF SIGNIFICANT
*                                         ENTRIES IN DSNSTABL
CONCAT10 CR    R7,R8                  HAVE WE EXHAUSTED THE DSNSTABL ?
         BE    CONCAT13               IF SO, BRANCH TO CONCAT13
**       CLC   6(L'CLSTLIB1,R6),CLSTLIB1
**       BE    CONCAT11
         A     R6,=F'50'              BUMP R6 BY 50
         A     R7,=F'1'               BUMP R7 BY 1
         B     CONCAT10               BRANCH TO CONCAT10
**NCAT11 LA    R6,DSNSTABL            R6==> ADDRESS OF DSNSTABL
**       LA    R7,0                   R7==> 0
**NCAT12 CR    R7,R8                  HAVE WE EXHAUSTED THE DSNSTABL ?
**       BE    CONCAT13               IF SO, BRANCH TO CONCAT13
**       CLC   6(L'CLSTLIB2,R6),CLSTLIB2
**       BE    CONCAT18
**       A     R6,=F'50'              BUMP R6 BY 50
**       A     R7,=F'1'               BUMP R7 BY 1
**       B     CONCAT12               BRANCH TO CONCAT12
CONCAT13 LA    R7,DDNTABLE            R7==> ADDRESS OF DDNTABLE
         LA    R8,49
CONCAT14 CLC   0(2,R7),=X'FFFF'
         BE    CONCAT18                                         GP 8/98
         A     R7,=F'10'
         BCT   R8,CONCAT14
         MVC   OUTMSG,ERRMSG9         MOVE 'MORE THAN 50 DATASETS
*                                        ALREADY ALLOCATED' TO OUTMSG
         LA    R4,32                  SET R4 TO 32
         B     EXITMAJR               BRANCH TO EXITMAJR
**NCAT15 CLC   INDDNAME(7),=C'SYSPROC'
**       BNE   CONCAT18
**       MVC   ALLOCDSN,=CL44' '
**       MVC   ALLOCDSN(L'CLSTLIB1),CLSTLIB1
**       MVC   ALLOCDDN,=CL8'DDNRETRN'
**       LA    R8,L'CLSTLIB1
**       STH   R8,DSNLEN
**       BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO
*                                        ALLOC & RETURN GEN DDNAME
**       CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?
**       BE    CONCAT16               IF SO, BRANCH TO CONCAT16
**       MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG
*                                        TO OUTMSG
**       B     EXITMAJR               BRANCH TO EXITMAJR
**NCAT16 MVC   0(2,R7),ALLOCU1A
**       MVC   DDNLEN,ALLOCU1A
**       LH    R6,DDNLEN              R6==> LENGTH OF THE DDNAME
**       S     R6,=F'1'               SUBTRACT 1 FOR EX
         SPACE 1
**VEDDN1 MVC   2(0,R7),ALLOCU1B
**       EX    R6,MOVEDDN1
         SPACE 1
**       A     R7,=F'10'
**       MVC   ALLOCDSN,=CL44' '
**       MVC   ALLOCDSN(L'CLSTLIB2),CLSTLIB2
**       MVC   ALLOCDDN,=CL8'DDNRETRN'
**       LA    R8,L'CLSTLIB2
**       STH   R8,DSNLEN
**       BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO
*                                        ALLOC & RETURN GEN DDNAME
**       CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?
**       BE    CONCAT17               IF SO, BRANCH TO CONCAT17
**       MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG
*                                        TO OUTMSG
**       B     EXITMAJR               BRANCH TO EXITMAJR
**NCAT17 MVC   0(2,R7),ALLOCU1A
**       MVC   DDNLEN,ALLOCU1A
**       LH    R6,DDNLEN              R6==> LENGTH OF THE DDNAME
**       S     R6,=F'1'               SUBTRACT 1 FOR EX
         SPACE 1
**VEDDN2 MVC   2(0,R7),ALLOCU1B
**       EX    R6,MOVEDDN2
         SPACE 1
CONCAT18 CLC   DDNTABLE(2),=X'FFFF'
         BE    EXITMAJR
         MVC   CNCATDDN,INDDNAME
         BAL   R14,CONCAT             PERFORM ROUTINE TO DO THE
*                                        DYNAMIC CONCATENATION
         CLC   CNCATOK,=CL3'YES'      WAS THE CONCATENATION SUCCESSFUL
         BE    EXITMAJR               IF SO, BRANCH TO EXITMAJR
         MVC   OUTMSG,CNCATMSG        MOVE DYNAMIC CONCAT ERR MSG
*                                        TO OUTMSG
         B     EXITMAJR               BRANCH TO EXITMAJR
UNALLOC  MVC   GTDSNDDN,INDDNAME      MOVE INDDNAME TO GTDSNDDN
         BAL   R14,GETDSNS            PERFORM ROUTINE TO DETERMINE
*                                        WHETHER THE DDNAME IS
*                                        ALLOCATED AND IF SO TO OBTAIN
*                                        LIST OF ASSOCIATED DSNAMES
         CLI   GTDSNSW,C'0'           WAS DDNAME ALLOCATED ?
         BE    UNALLOC3               IF SO, BRANCH TO UNALLOC3
         CLI   GTDSNSW,C'1'           WAS DDNAME NOT ALLOCATED?
         BE    UNALLOC2               IF SO, BRANCH TO UNALLOC2
         MVC   OUTMSG,ERRMSG9         MOVE 'MORE THAN 50 DATASETS
*                                        ALREADY ALLOCATED' TO OUTMSG
         LA    R4,32                  SET R4 TO 32
         B     EXITMAJR               BRANCH TO EXITMAJR
UNALLOC2 MVC   OUTMSG,ERRMSG10        MOVE 'CANNOT DO DEALLOCATION --
*                                       DDNAME NOT ALLOCATED' TO OUTMSG
         LA    R4,36                  SET R4 TO 36
         B     EXITMAJR               BRANCH TO EXITMAJR
UNALLOC3 LA    R6,DSNSTABL            R6==> ADDRESS OF DSNAMES TABLE
         LH    R7,DSNSCNT             R7==> NO OF SIGNIFICANT ENTRIES
*                                        IN THAT TABLE
         LA    R8,0                   R8==> 0
UNALLOC4 CR    R7,R8                  HAVE WE EXHAUSTED THE TABLE ?
         BNE   UNALLOC5               IF NOT, BRANCH TO UNALLOC5
         MVC   OUTMSG,ERRMSG11        MOVE 'CANNOT DO DEALLOCATION --
*                                       DSNAME NOT ALLOCATED' TO OUTMSG
         LA    R4,40                  SET R4 TO 40
         B     EXITMAJR               BRANCH TO EXITMAJR
UNALLOC5 CLC   INDSNAME,6(R6)         GIVEN DSNAME = DSNAME OF
*                                         TABLE ENTRY ?
         BE    UNALLOC6               IF SO, BRANCH TO UNALLOC6
         A     R6,=F'50'              ADD 50 TO REG 6
         A     R8,=F'1'               ADD 1 TO REG 8
         B     UNALLOC4               BRANCH TO UNALLOC4
UNALLOC6 MVC   DALLCDDN,INDDNAME      MOVE DDNAME TO DALLCDDN
         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN
         BAL   R14,DEALLOK            PERFORM ROUTINE TO DO DYNAMIC
*                                        DEALLOCATION
         CLC   DALLCOK,=CL3'YES'      WAS DEALLOCATION SUCCESSFUL ?
         BE    UNALLOC7               IF SO, BRANCH TO UNALLOC7
         MVC   OUTMSG,DALLCMSG        MOVE DYNAMIC DEALLOC ERR MSG
*                                        TO OUTMSG
         B     EXITMAJR               BRANCH TO EXITMAJR
UNALLOC7 CLC   DSNSCNT,=BL2'0001'     WAS THERE ONLY ONE DSNAME
*                                        ALLOCATED TO THE DDNAME ?
         BE    EXITMAJR               IF SO, BRANCH TO EXITMAJR
         MVC   MAJORGUY,=CL3'YES'
         LH    R6,DSNSCNT             R6==> NO OF SIGNIF ENTRIES IN
*                                        DSNAMES TABLE
         LA    R7,0                   R7==> 0
         LA    R8,DSNSTABL            R8==> ADDRESS OF DSNAMES TABLE
         LA    R9,DDNTABLE            R9==> ADDRESS OF GENERATED
*                                        DDNAMES TABLE
UNALLOC8 CR    R7,R6                  HAVE WE ALLOCATED ALL OF THE
*                                        DSNAMES ?
         BE    UNALLC11               IF SO, BRANCH TO UNALLC11
         CLC   INDSNAME,6(R8)         IS THIS THE DSNAME THAT IS
*                                        TO BE DEALLOCATED ?
         BE    UNALLC10               IF SO, BRANCH TO UNALLC10
         MVC   ALLOCDSN,6(R8)         ALLOCDSN==> DSNAME TO BE ALLOC
         MVC   DSNLEN,4(R8)           DSNLEN==> LENGTH OF DSNAME
         CLC   MAJORGUY,=CL3'YES'     IS DIS DA 1ST GUY IN THE TABLE?
         BE    UNALLC8A               IF SO, BRANCH TO UNALLC8A
         MVC   ALLOCDDN,=CL8'DDNRETRN'
         B     UNALLC8B               BRANCH TO UNALLC8B
UNALLC8A MVC   ALLOCDDN,INDDNAME      MOVE DDNAME TO ALLOCDDN
         MVC   DDNLEN,INDDNLEN        MOVE LENGTH OF DDNAME TO DDNLEN
UNALLC8B BAL   R14,DYNALLOK           PERFORM ROUTINE TO DO DYNAMIC
*                                        ALLOC & RETURN GEN DDNAME
         CLC   ALLOCOK,=CL3'YES'      WAS ALLOCATION SUCCESSFUL ?
         BE    UNALLOC9               IF SO, BRANCH TO UNALLOC9
         MVC   OUTMSG,ALLOCMSG        MOVE DYNAMIC ALLOC ERR MSG
*                                        TO OUTMSG
         B     EXITMAJR               BRANCH TO EXITMAJR
UNALLOC9 CLC   MAJORGUY,=CL3'YES'     IS DIS DA 1ST GUY IN THE TABLE?
         BNE   UNALLC9A               IF NOT, BRANCH TO UNALLC9A
         MVC   MAJORGUY,=CL3'NO '     MOVE 'NO ' TO MAJORGUY
         B     UNALLC10               BRANCH TO UNALLC10
UNALLC9A MVC   0(2,R9),ALLOCU1A       LOAD LENGTH OF DDNAME ENTRY
*                                        INTO DDNAMES TABLE
         MVC   2(8,R9),ALLOCU1B       LOAD DDNAME INTO DDNAMES TABLE
         A     R9,=F'10'              ADD 10 TO REG 9
UNALLC10 A     R7,=F'1'               ADD 1 TO REG 7
         A     R8,=F'50'              ADD 50 TO REG 8
         B     UNALLOC8               BRANCH TO UNALLOC8
UNALLC11 LH    R7,DSNSCNT
         C     R7,=F'2'
         BNH   EXITMAJR
         MVC   CNCATDDN,INDDNAME
         BAL   R14,CONCAT             PERFORM ROUTINE TO DO THE
*                                        DYNAMIC CONCATENATION
         CLC   CNCATOK,=CL3'YES'      WAS THE CONCATENATION SUCCESSFUL
         BE    EXITMAJR               IF SO, BRANCH TO EXITMAJR
         MVC   OUTMSG,CNCATMSG        MOVE DYNAMIC CONCAT ERR MSG
*                                        TO OUTMSG
EXITMAJR L     R14,SAVEIT3
         BR    R14
         EJECT
*
********************************************************************
*                                                                  *
*        THIS ROUTINE IS RESPONSIBLE FOR DYNAMICALLY ALLOCATING    *
*        (VERB CODE 01) THE DSNAME PASSED TO THIS ROUTINE IN       *
*        DATA FIELD ALLOCDSN                                       *
*                                                                  *
*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:         *
*                                                                  *
*           1.  MOVE THE DSNAME TO BE ALLOCATED TO ALLOCDSN        *
*           2.  IF YOU WISH TO LET THE ROUTINE ASSIGN A UNIQUE     *
*                  DDNAME OF ITS CHOICE                            *
*                       MOVE 'DDNRETRN' TO ALLOCDDN                *
*               ELSE                                               *
*                       MOVE THE DDNAME TO ALLOCDDN.               *
*           3.  MOVE THE LENGTH OF THE DDNAME TO DDNLEN            *
*                  (NOT NEEDED IF WE WISH TO LET THE ROUTINE       *
*                   ASSIGN A UNIQUE DDNAME OF ITS CHOICE)          *
*           4.  MOVE THE LENGTH OF THE DSNAME TO DSNLEN            *
*                                                                  *
*                                                                  *
*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *
*                                                                  *
*           INTERROGATE ALLOCOK                                    *
*                                                                  *
*                IF ALLOCOK = 'YES'                                *
*                    THEN THE ALLOCATION WAS SUCCESSFUL AND        *
*                    DATA FIELD ALLOCMSG IS SPACES                 *
*                                                                  *
*                IF ALLOCOK IS NOT EQUAL TO 'YES'                  *
*                    THEN THE ALLOCATION WAS NOT SUCCESSFUL AND    *
*                    DATA FIELD ALLOCMSG CONTAINS A MEANINGFUL     *
*                    MESSAGE AS TO WHY IT WASN'T                   *
*                                                                  *
********************************************************************
*
DYNALLOK ST    R14,SAVEIT4             SAVE REG 14 IN SAVEIT4
         MVC   ALLOCOK,=CL3'YES'       MOVE 'YES' TO ALLOCOK
         MVC   ALLOCMSG,=CL44' '       MOVE SPACES TO ALLOCMSG
         CLC   ALLOCDDN,=CL8'DDNRETRN' ALLOCDDN = 'DDNRETRN' ?
         BE    DYNALLK1                IF SO, BRANCH TO DYNALLK1
         MVC   ALLOCUT1,=X'0001'       MOVE X'0001' TO ALLOCUT1
         MVC   ALLOCU1A,DDNLEN         MOVE LEN OF DDNAME TO ALLOCU1A
         MVC   ALLOCU1B,ALLOCDDN       MOVE DDNAME TO ALLOCU1B
         B     DYNALLK2                BRANCH TO DYNALLK2
DYNALLK1 MVC   ALLOCUT1,=X'0055'       MOVE X'0055' TO ALLOCUT1
         MVC   ALLOCU1A,=X'0008'       MOVE X'0008' TO ALLOCU1A
         MVC   ALLOCU1B,=CL8' '        MOVE SPACES TO ALLOCU1B
DYNALLK2 MVC   ALLOCU2A,DSNLEN         MOVE LEN OF DSNAME TO ALLOCU2A
         MVC   ALLOCU2B,ALLOCDSN       MOVE DSNAME TO ALLOCU2B
         LA    R1,ALLOCPRM
         DYNALLOC                      ALLOC F(DDNAME) DA(DSN) SHR
         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO
         BZ    EXITALLC                IF ZERO, BRANCH TO EXITALLC
         MVC   ALLOCOK,=CL3'NO '       MOVE 'NO ' TO ALLOCOK
         MVC   ALLOCMSG,ERRMSG1        MOVE DYNAMIC ALLOC ERR MSG
*                                        TO ALLOCMSG
         UNPK  ALLOCMSG+39(5),ALLOCERC(3)                       GP 8/98
         TR    ALLOCMSG+39(4),HEX-C'0'                          GP 8/98
         MVI   ALLOCMSG+43,C')'                                 GP 8/98
**       MVC   HEXINPUT,ALLOCERC       LOAD HEXINPUT WITH ERR REASON CD
**       BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE
*                                         ERR REASON CODE INTO HEXOUT
**       MVC   ALLOCMSG+39(4),HEXOUT   MOVE UNPACKED ERR REASON CODE
*                                        TO ALLOCMSG
         LA    R4,4                    SET R4 TO 4
EXITALLC L     R14,SAVEIT4             RESTORE REGISTER 14
         BR    R14                     RETURN
         EJECT
*
********************************************************************
*                                                                  *
*        THIS ROUTINE IS RESPONSIBLE FOR DYNAMICALLY DE-ALLOCATING *
*        (VERB CODE 02) THE DDNAME PASSED TO THIS ROUTINE IN       *
*        DATA FIELD DALLCDDN                                       *
*                                                                  *
*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:         *
*                                                                  *
*           1.  MOVE THE DDNAME TO BE FREED TO DALLCDDN            *
*           2.  MOVE THE LENGTH OF THAT DDNAME TO DDNLEN           *
*                                                                  *
*                                                                  *
*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *
*                                                                  *
*           INTERROGATE DALLCOK                                    *
*                                                                  *
*                IF DALLCOK = 'YES'                                *
*                    THEN THE DE-ALLOCATION WAS SUCCESSFUL AND     *
*                    DATA FIELD DALLCMSG IS SPACES                 *
*                                                                  *
*                IF DALLCOK IS NOT EQUAL TO 'YES'                  *
*                    THEN THE DE-ALLOCATION WAS NOT SUCCESSFUL AND *
*                    DATA FIELD DALLCMSG CONTAINS A MEANINGFUL     *
*                    MESSAGE AS TO WHY IT WASN'T                   *
*                                                                  *
********************************************************************
*
DEALLOK  ST    R14,SAVEIT5             SAVE REG 14 IN SAVEIT5
         MVC   DALLCOK,=CL3'YES'       MOVE 'YES' TO DALLCOK
         MVC   DALLCMSG,=CL44' '       MOVE SPACES TO DALLCMSG
         MVC   FREEUT1A,DDNLEN         MOVE LEN OF DDNAME TO FREEUT1A
         MVC   FREEUT1B,DALLCDDN       MOVE THE DDNAME TO FREEUT1B
         LA    R1,FREEPARM
         DYNALLOC                      FREE F(DDNAME)
         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO
         BZ    EXITFREE                IF ZERO, BRANCH TO EXITFREE
         MVC   DALLCOK,=CL3'NO '       MOVE 'NO ' TO DALLCOK
         MVC   DALLCMSG,ERRMSG2        MOVE DYNAMIC DEALLOC ERR MSG
*                                        TO DALLCMSG
         UNPK  DALLCMSG+41(5),FREEERC(3)                        GP 8/98
         TR    DALLCMSG+41(4),HEX-C'0'                          GP 8/98
         MVI   DALLCMSG+45,C')'                                 GP 8/98
**       MVC   HEXINPUT,FREEERC        LOAD HEXINPUT WITH ERR REASON CD
**       BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE
*                                         ERR REASON CODE INTO HEXOUT
**       MVC   DALLCMSG+41(4),HEXOUT   MOVE UNPACKED ERR REASON CODE
*                                        TO DALLCMSG
         LA    R4,8                    SET R4 TO 8
EXITFREE L     R14,SAVEIT5             RESTORE REGISTER 14
         BR    R14                     RETURN
         EJECT
*
********************************************************************
*                                                                  *
*        THIS ROUTINE IS RESPONSIBLE FOR CONCATENATING             *
*        (VERB CODE 03) ALL OF THE DDNAMES IN THE TABLE DDNTABLE   *
*        TO THE DDNAME GIVEN IN CNCATDDN                           *
*                                                                  *
*        BEFORE PERFORMING THIS ROUTINE, DO THE FOLLOWING:         *
*                                                                  *
*            1.  LOAD THE TABLE OF DDNAMES DDNTABLE                *
*            2.  LOAD THE DATA FIELD CNCATDDN WITH THE DDNAME      *
*                   THAT ALL OF THE OTHER DDNAMES ARE TO BE        *
*                   CONCATENATED TO                                *
*                                                                  *
*                                                                  *
*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *
*                                                                  *
*           INTERROGATE DALLCOK                                    *
*                                                                  *
*                IF CNCATOK = 'YES'                                *
*                    THEN THE CONCATENATION WAS SUCCESSFUL AND     *
*                    DATA FIELD CNCATMSG IS SPACES                 *
*                                                                  *
*                IF CNCATOK IS NOT EQUAL TO 'YES'                  *
*                    THEN THE CONCATENATION WAS NOT SUCCESSFUL AND *
*                    DATA FIELD CNCATMSG CONTAINS A MEANINGFUL     *
*                    MESSAGE AS TO WHY IT WASN'T                   *
*                                                                  *
********************************************************************
*
CONCAT   ST    R14,SAVEIT6             SAVE REG 14 IN SAVEIT6
         MVC   CNCATOK,=CL3'YES'       MOVE 'YES' TO CNCATOK
         MVC   CNCATMSG,=CL44' '       MOVE SPACES TO CNCATMSG
         MVC   CNCTABLE(2),INDDNLEN
         LA    R1,CNCTABLE+2
         LA    R8,CNCATDDN             R8==> ADDRESS OF CNCATDDN
         LH    R5,INDDNLEN             R5==> LENGTH OF INDDNAME
         S     R5,=F'1'                SUBTRACT 1 FOR EX
         SPACE 1
MOVEDD1  MVC   0(0,R1),0(R8)
         EX    R5,MOVEDD1              MOVE INDDNAME TO CNCTABLE
         LA    R6,1                    R6==> 1
         LA    R8,CNCTABLE
         A     R5,=F'3'
         AR    R8,R5
         LA    R7,DDNTABLE
CMPR4FF  CLC   0(2,R7),=X'FFFF'        HAVE WE EXHAUSTED THE DDNTABLE?
         BE    LOADNMBR                IF SO, BRANCH TO LOADNMBR
         MVC   0(2,R8),0(R7)
         A     R8,=F'2'
         LH    R5,0(R7)
         A     R7,=F'2'
         S     R5,=F'1'                SUBTRACT 1 FOR EX
         SPACE 1
MOVEDD2  MVC   0(0,R8),0(R7)
         EX    R5,MOVEDD2              MOVE INDDNAME TO CNCTABLE
         A     R6,=F'1'
         A     R7,=F'8'
         A     R5,=F'1'
         AR    R8,R5
         B     CMPR4FF
LOADNMBR STH   R6,CNCTNMBR
         LA    R1,CNCTPARM
         DYNALLOC                      DYNAMIC CONCATENATION
         LTR   R15,R15                 TEST REGISTER 15 FOR ZERO
         BZ    EXITCNCT                IF ZERO, BRANCH TO EXITCNCT
         MVC   CNCATOK,=CL3'NO '       MOVE 'NO ' TO CNCATOK
         MVC   CNCATMSG,ERRMSG8        MOVE DYNAMIC CONCAT ERR MSG
*                                        TO CNCATMSG
         UNPK  CNCATMSG+41(5),FREEERC(3)                        GP 8/98
         TR    CNCATMSG+41(4),HEX-C'0'                          GP 8/98
         MVI   CNCATMSG+45,C')'                                 GP 8/98
**       MVC   HEXINPUT,CNCTERC        LOAD HEXINPUT WITH ERR REASON CD
**       BAL   R14,UNPKHEX             PERFORM ROUTINE TO UNPACK THE
*                                         ERR REASON CODE INTO HEXOUT
**       MVC   CNCATMSG+41(4),HEXOUT   MOVE UNPACKED ERR REASON CODE
*                                        TO CNCATMSG
         LA    R4,28                   SET R4 TO 28
EXITCNCT L     R14,SAVEIT6
         BR    R14
         EJECT
*
********************************************************************
*                                                                  *
*        THIS ROUTINE IS RESPONSIBLE FOR DETERMINING WHETHER THE   *
*        DDNAME PASSED TO IT IS ALLOCATED.  IF IT IS ALLOCATED,    *
*        THEN THIS ROUTINE PASSES BACK ALL OF THE ASSOCIATED       *
*        DSNAMES (AND THEIR LENGTHS)                               *
*                                                                  *
*        BEFORE PERFORMING THIS ROUTINE, MOVE THE DDNAME TO        *
*        GTDSNDDN                                                  *
*                                                                  *
*        AFTER PERFORMING THIS ROUTINE, DO THE FOLLOWING:          *
*                                                                  *
*          .  INTERROGATE GTDSNSW                                  *
*                                                                  *
*             .  IF GTDSNSW = 0, THEN THE DDNAME WAS INDEED        *
*                  ALLOCATED AND THE DSNAMES TABLE IS THEN LOADED  *
*                  INTO DSNSTABL AND THE NUMBER OF SIGNIFICANT     *
*                  ENTRIES IN THAT TABLE IS IN DSNSCNT (EACH ENTRY *
*                  IN THE TABLE IS 50 BYTES LONG.  THE LENGTH OF   *
*                  THE DSNAME IS IN BYTES 5-6 AND THE DSNAME IS    *
*                  IN BYTES 7-50)                                  *
*                                                                  *
*             .  IF GTDSNSW = 1, THEN THE DDNAME WAS NOT ALLOCATED *
*                                                                  *
*             .  IF GTDSNSW = 2, THEN THERE ARE MORE THAN 50       *
*                  DATASETS CONCATENATED TO THE DDNAME FOUND IN    *
*                  GTDSNDDN                                        *
*                                                                  *
********************************************************************
*
GETDSNS  LA    R14,0(,R14)             ENSURE CLEAN ADDRESS   GP 10/98
         LA    R15,GETDSN31                                   GP 10/98
         ICM   R15,8,=X'80'            SET SIGN BIT           GP 10/98
         BSM   0,R15                   GET INTO 31-BIT AMODE  GP 10/98
GETDSN31 ST    R14,SAVEIT7             SAVE REG 14 IN SAVEIT7 GP 10/98
         CALL  DSNTAB,(GTDSNDDN,DSNSTABL,TABLSIZE,DSNSCNT),VL,         X
               MF=(E,LISTKALL)
         C     R15,=F'4'
         BE    RC4
         C     R15,=F'8'
         BE    RC8
         MVI   GTDSNSW,C'0'
         B     EXITDSNS
RC4      MVI   GTDSNSW,C'1'
         B     EXITDSNS
RC8      MVI   GTDSNSW,C'2'
EXITDSNS L     R14,SAVEIT7
         BSM   0,R14                   REVERT TO AMODE-24     GP 10/98
         EJECT
*
********************************************************************
*                                                                  *
*        THIS ROUTINE IS RESPONSIBLE FOR CONVERTING A TWO BYTE     *
*        BINARY FIELD (SUCH AS X'0438') TO A FOUR BYTE CHARACTER   *
*        FIELD (SUCH AS 0438)                                      *
*                                                                  *
*        BEFORE PERFORMING THIS ROUTINE, MOVE THE TWO BYTE BINARY  *
*        FIELD TO BE CONVERTED TO HEXINPUT                         *
*                                                                  *
*        AFTER PERFORMING THIS ROUTINE, YOUR TWO BYTE BINARY       *
*        FIELD WILL BE CONVERTED TO 4 CHARACTER BYTES IN HEXOUT    *
*                                                                  *
********************************************************************
*
**PKHEX  ST    R14,SAVEIT8             SAVE REG 14 IN SAVEIT8
**SEREG2 DS    0H
*ASEREG2 MVC   CHARLEN,=XL2'0004'      CHARLEN IS LENGTH OF HEXOUT
*        MVC   CNVTYPE,=CL3'HTC'       HTC ==> HEX TO CHAR CONVERSION
**       CALL  HEXTRAN,(HEXOUT,HEXINPUT,=XL2'0004',=CL3'HTC'),VL,
**             MF=(E,LISTKALL)
**       L     R14,SAVEIT8             RESTORE REGISTER 14
**       BR    R14                     RETURN
         EJECT
********************************************************************
*                                                                  *
*        BUILD UPDTLIST (IKJUPDT PARM LIST)                        *
*                                                                  *
********************************************************************
*
**INITLIST ST    R14,SAVEIT9
**       MVC   UPDTUPT,CPPLUPT          UPT
**       MVC   UPDTECT,CPPLECT          ECT
**       LA    R9,ECB
**       ST    R9,UPDTECB               ECB
**       LA    R8,UPLIST
**       ST    R8,UPDTUPL               UPLIST
**       L     R14,SAVEIT9
**       BR    14
         EJECT
********************************************************************
*                                                                  *
*        BUILD UPDATE PARM LIST FOR &OUTMSG AND CALL IKJUPDT       *
*                                                                  *
********************************************************************
*
**SETOUTMG ST    R14,SAVEIT10
**       LA    R9,=C'OUTMSG'       R9 ==> ADDRESS OF VAR NAME
**       ST    R9,LOCPTR           STORE ADDR OF VAR NAME IN LOCPTR
**       MVC   LOCLEN,=F'6'        LOCLEN = LENGTH OF VAR NAME
**       LA    R5,OUTMSG           R5 ==> ADDRESS OF VARIABLE
**       ST    R5,VALPTR           STORE ADDRESS OF VARIABLE IN VALPTR
**       MVC   VALLEN,=F'46'       VALLEN = LENGTH OF DATA FIELD
**       LA    R1,UPDTLIST         R1 ==> IKJUPDT PARM LIST
**       CALL  IKJUPDT             DO THE UPDATE
**       L     R14,SAVEIT10
**       BR    14
         EJECT
********************************************************************
*                                                                  *
*        E N D   O F   J O B   R O U T I N E                       *
*                                                                  *
********************************************************************
*
SHUTDOWN LR    R15,R4
         LR    R1,R13             WORKAREA ADDR FOR FREEMAIN
         L     R0,=A(WORKLEN)     WORKAREA LEN   "    "
         L     R13,4(R13)         GET CALLERS SAVEAREA ADDR
         LR    R11,R15            SAVE RETURN CODE
         FREEMAIN R,LV=(0),A=(1)
         LR    R15,R11            RESTORE RETURN CODE
         RETURN (14,12),RC=(15)
         EJECT
         SPACE 3
********************************************************************
*                                                                  *
*        D A T A   A R E A   C O N S T A N T S                     *
*                                                                  *
********************************************************************
*
CHARLEN  DS    BL2
**CLSTLIB1 DC    CL18'WDPSC.MASTER.CLIST'
**CLSTLIB2 DC    CL10'USER.CLIST'
GOODMSG  DC    CL46'SUCCESSFUL COMPLETION                         '
ERRMSG1  DC    CL46'DYNAMIC ALLOC ERROR (ERR REASON CODE =     )  '
ERRMSG2  DC    CL46'DYNAMIC DEALLOC ERROR (ERR REASON CODE =     )'
ERRMSG3  DC    CL46'INVALID SYNTAX OF ONE OR MORE OPERANDS        '
ERRMSG4  DC    CL46'MISSING ACTION CODE                           '
ERRMSG5  DC    CL46'MISSING DDNAME PARAMETER                      '
ERRMSG6  DC    CL46'MISSING DSNAME PARAMETER                      '
ERRMSG7  DC    CL46'INVALID ACTION CODE  (MUST BE A OR D)         '
ERRMSG8  DC    CL46'DYNAMIC CONCAT  ERROR (ERR REASON CODE =     )'
ERRMSG9  DC    CL46'MORE THAN 50 DATASETS ALREADY ALLOCATED       '
ERRMSG10 DC    CL46'CANNOT DO DEALLOCATION -- DDNAME NOT ALLOCATED'
ERRMSG11 DC    CL46'CANNOT DO DEALLOCATION -- DSNAME NOT ALLOCATED'
TABLSIZE DC    H'2500'
HEX      DC    CL16'0123456789ABCDEF'                           GP 8/98
*
*
*
*
         EJECT
*
********************************************************************
*                                                                  *
*        DYNAMIC ALLOCATION INIT BLOCK   (VERB CODE 01)            *
*                                                                  *
********************************************************************
*
DALLINIT DS    0F
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(0)        ADDRESS OF REQUEST BLOCK
         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)
         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)
         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)
         DC    X'0000'       S99ERROR (ERROR REASON CODE)
         DC    X'0000'       S99INFO (INFORMATION REASON CODE)
         DC    A(0)          S99TXTPP (ADDR OF POINTERS TO TEXT UNITS
         DC    X'00000000'   RESERVED
         DC    X'00000000'   S99FLAG2
         DC    A(0)          ADDRESS OF TEXT UNIT #1
         DC    A(0)          ADDRESS OF TEXT UNIT #2
         DC    A(0)          ADDRESS OF TEXT UNIT #3
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(0)        ADDRESS OF TEXT UNIT #4
         DC    XL2'0001'     EITHER X'0001' OR X'0055'
         DC    X'0001'
         DC    XL2'0008'     LENGTH OF DDNAME
         DC    CL8' '        DDNAME
         DC    X'0002'
         DC    X'0001'
         DC    XL2'0000'     LENGTH OF DSNAME
         DC    CL44' '       DSNAME
         DC    X'0004',X'0001',X'0001',X'08'
         DC    X'0052',X'0000'
ALLOCLEN EQU   *-DALLINIT
         EJECT
********************************************************************
*                                                                  *
*        DATA STRUCTURE FOR DE-ALLOCATION  (VERB CODE 02)          *
*                                                                  *
********************************************************************
FREEINIT DS    0F
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(0)        ADDRESS OF REQUEST BLOCK
         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)
         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)
         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)
         DC    X'0000'       S99ERROR (ERROR REASON CODE)
         DC    X'0000'       S99INFO (INFORMATION REASON CODE)
         DC    A(0)          S99TXTPP (ADDR OF POINTER TO TEXT UNIT)
         DC    X'00000000'   RESERVED
         DC    X'00000000'   S99FLAG2
         DC    A(0)          ADDRESS OF TEXT UNIT #1
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(0)        ADDRESS OF TEXT UNIT #2
         DC    X'0001'
         DC    X'0001'
         DC    XL2'0008'
         DC    CL8' '
         DC    X'0007'
         DC    X'0000'
FREELEN  EQU   *-FREEINIT
         EJECT
********************************************************************
*                                                                  *
*        DATA STRUCTURE FOR CONCATENATION   (VERB CODE 03)         *
*                                                                  *
********************************************************************
CNCTINIT DS    0F
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(0)        ADDRESS OF REQUEST BLOCK
         DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)
         DC    X'03'         S99VERB (REQUEST FOR CONCATENATION)
         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)
         DC    X'0000'       S99ERROR (ERROR REASON CODE)
         DC    X'0000'       S99INFO (INFORMATION REASON CODE)
         DC    A(0)          S99TXTPP (ADDR OF POINTER TO TEXT UNIT)
         DC    X'00000000'   RESERVED
         DC    X'00000000'   S99FLAG2
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(0)        ADDRESS OF TEXT UNIT
         DC    X'0001'
*        DS    BL2
*        DS    CL500
CNCTLEN  EQU   *-CNCTINIT
         EJECT
********************************************************************
*                                                                  *
*        S T A T I C   W O R K   A R E A                           *
*                                                                  *
********************************************************************
         LTORG
         EJECT
********************************************************************
*                                                                  *
*        D Y N A M I C   W O R K   A R E A                         *
*                                                                  *
********************************************************************
*
WORKAREA DSECT
SAVEAREA DS    18F
ALLOCDDN DS    CL8
ALLOCDSN DS    CL44
ALLOCMSG DS    CL46
ALLOCOK  DS    CL3
ANS      DS    F
CNCATDDN DS    CL8
CNCATMSG DS    CL46
CNCATOK  DS    CL3
DALLCDDN DS    CL8
DALLCMSG DS    CL46
DALLCOK  DS    CL3
DDNLEN   DS    H
DDNTABLE DS    50CL10
DDNEOT   DC    X'FFFF'
DSNLEN   DS    H
DSNSCNT  DS    H
DSNSTABL DS    50CL50
ECB      DS    F
GTDSNDDN DS    CL8
GTDSNSW  DS    CL1
**HEXINPUT DS    XL2
**HEXOUT   DS    CL4
INACTCD  DS    CL1
         DS    0D
INDDNAME DS    CL8
INDDNLEN DS    H
INDSNAME DS    CL44
INDSNLEN DS    H
MAJORGUY DS    CL3
OUTMSG   DS    CL46
PPLA     DS    7F
PROCESSW DS    CL3
SAVEIT1  DS    F
SAVEIT2  DS    F
SAVEIT3  DS    F
SAVEIT4  DS    F
SAVEIT5  DS    F
SAVEIT6  DS    F
SAVEIT7  DS    F
SAVEIT8  DS    F
SAVEIT9  DS    F
SAVEIT10 DS    F
*
**UPDTLIST DS    0F
**UPDTUPT  DS    F
**UPDTECT  DS    F
**UPDTECB  DS    F
**UPDTUPL  DS    F
*
**UPLIST   DS    0F
**LOCPTR   DS    AL4
**LOCLEN   DS    FL4
**VALPTR   DS    AL4
**VALLEN   DS    FL4
*
LISTKALL CALL  ,(0,0,0,0),VL,MF=L
*
*        DATA STRUCTURE FOR DYNAMIC ALLOCATION  (VERB CODE 01)
ALLOCPRM DS    0F
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(ALLOCRB)  ADDRESS OF REQUEST BLOCK
ALLOCRB  DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)
         DC    X'01'         S99VERB (REQUEST FOR DSNAME ALLOC)
         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)
ALLOCERC DC    X'0000'       S99ERROR (ERROR REASON CODE)
         DC    X'0000'       S99INFO (INFORMATION REASON CODE)
         DC    A(ALLOCTUA)   S99TXTPP (ADDR OF POINTERS TO TEXT UNITS
         DC    X'00000000'   RESERVED
         DC    X'00000000'   S99FLAG2
ALLOCTUA DC    A(ALLOCUT1)   ADDRESS OF TEXT UNIT #1
         DC    A(ALLOCUT2)   ADDRESS OF TEXT UNIT #2
         DC    A(ALLOCUT3)   ADDRESS OF TEXT UNIT #3
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(ALLOCUT4) ADDRESS OF TEXT UNIT #4
ALLOCUT1 DS    CL2           EITHER X'0001' OR X'0055'
         DC    X'0001'
ALLOCU1A DS    BL2           LENGTH OF DDNAME
ALLOCU1B DS    CL8           DDNAME
ALLOCUT2 DC    X'0002'
         DC    X'0001'
ALLOCU2A DS    BL2           LENGTH OF DSNAME
ALLOCU2B DS    CL44          DSNAME
ALLOCUT3 DC    X'0004',X'0001',X'0001',X'08'
ALLOCUT4 DC    X'0052',X'0000'
*
*        DATA STRUCTURE FOR DE-ALLOCATION  (VERB CODE 02)
FREEPARM DS    0F
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(FREERB)   ADDRESS OF REQUEST BLOCK
FREERB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)
         DC    X'02'         S99VERB (REQUEST FOR UNALLOCATION)
         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)
FREEERC  DC    X'0000'       S99ERROR (ERROR REASON CODE)
         DC    X'0000'       S99INFO (INFORMATION REASON CODE)
         DC    A(FREETUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)
         DC    X'00000000'   RESERVED
         DC    X'00000000'   S99FLAG2
FREETUPL DC    A(FREEUNT1)   ADDRESS OF TEXT UNIT #1
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(FREEUNT2) ADDRESS OF TEXT UNIT #2
FREEUNT1 DC    X'0001'
         DC    X'0001'
FREEUT1A DS    BL2
FREEUT1B DS    CL8
FREEUNT2 DC    X'0007'
         DC    X'0000'
*
*        DATA STRUCTURE FOR CONCATENATION   (VERB CODE 03)
CNCTPARM DS    0F
         DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(CNCTRB)   ADDRESS OF REQUEST BLOCK
CNCTRB   DC    X'14'         S99RBLN (LENGTH OF REQUEST BLOCK)
         DC    X'03'         S99VERB (REQUEST FOR CONCATENATION)
         DC    X'2000'       S99FLAG1 (DO NOT MOUNT VOLUMES)
CNCTERC  DC    X'0000'       S99ERROR (ERROR REASON CODE)
         DC    X'0000'       S99INFO (INFORMATION REASON CODE)
         DC    A(CNCTTUPL)   S99TXTPP (ADDR OF POINTER TO TEXT UNIT)
         DC    X'00000000'   RESERVED
         DC    X'00000000'   S99FLAG2
CNCTTUPL DC    X'80'         TURN ON HIGH ORDER BIT
         DC    AL3(CNCTUNT1) ADDRESS OF TEXT UNIT
CNCTUNT1 DC    X'0001'
CNCTNMBR DS    BL2
CNCTABLE DS    CL500
WORKLEN  EQU   *-WORKAREA
CONCATEM CSECT
         EJECT
********************************************************************
*                                                                  *
*                   P A R S E   M A C R O S                        *
*                                                                  *
********************************************************************
*
PCL      IKJPARM
ACTCODE  IKJKEYWD DEFAULT='ACTCODE(A)'
         IKJNAME 'ACTCODE',SUBFLD=ACTCD
DDNAME   IKJKEYWD
         IKJNAME 'DDNAME',SUBFLD=DDNAM,ALIAS=('FILE')
DSNAME   IKJKEYWD
         IKJNAME 'DSNAME',SUBFLD=DSNAM,ALIAS=('DATASET')
ACTCD    IKJSUBF
ACTCDSTR IKJIDENT 'ACT CODE',MAXLNTH=1,FIRST=ALPHA
DDNAM    IKJSUBF
DDNSTRNG IKJPOSIT DSNAME,DDNAM
DSNAM    IKJSUBF
DSNSTRNG IKJPOSIT DSNAME,USID
         IKJENDP
*
*                        DSECTS NEEDED BY PARSE:
*
*CPPL    IKJCPPL
CPPL     IKJCPPL
*PPL     IKJPPL
PPL      IKJPPL
*
CVTMAP   DSECT
         ORG   CVTMAP+524
CVTPARS  DS    F
CVTPTR   EQU   16
*
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
*          DATA SET 761KKDSNTB AT LEVEL 001 AS OF 08/30/82
* WRITTEN BY KERMIT KISER - WASHINGTON STATE DP SERVICE CENTER (WDPSC)
*
DSNTAB   CSECT
DSNTAB   AMODE 31                                             GP 10/98
         SAVE  (14,12),,DSNTAB-V1M0
         LR    R12,R15            HOPE HE KNOWS WHAT HE'S DOING
         USING DSNTAB,R12
         LR    R10,R1             SAVE PARM PTR R10->PARM PTR
         L     R0,=A(WORKLEN)     R0=GET LENGTH
         GETMAIN RU,LV=(0),LOC=ANY R1->WORKAREA               GP 10/98
         LR    R11,R13            R11->CALLERS SAVEAREA
         LR    R13,R1             R13->WORKAREA
         USING WORKAREA,R13
         L     R15,=A(WORKLEN)    R0=GET LENGTH
         S     R15,=F'72'         SKIP REGS
         LA    R14,72(,R13)
         LA    R0,0
         LA    R1,0
         MVCL  R14,R0             ZERO WORK AREA AFTER SAVEAREA GP 8/98
         ST    R11,SAVEAREA+4     SAVE HIS SAVEAREA PTR
         LA    R13,SAVEAREA       R13->SAVEAREA (MINE)
         ST    R13,8(,R11)        MINE IN HIS
         LR    R11,R1             R11->WORKAREA IN CASE NOT SAME AS R13
*                       WORKAREA ADDR IS STILL R13 FOR
*                       THE ASSEMBLER - IF DIFFERENT FROM R13
*                       THEN USE: DROP R13 AND USING &WA.,R11
         LR    R1,R10             RESTORE PARM PTR PTR
         LR    R11,R1             R11->PARM LIST
         SLR   R15,R15            R15=0
         EJECT
*
*        MAINLINE ROUTINE:
*
         BAL   R14,FINDDD         R9->DD ENTRY
         BXH   R15,R15,EXIT       STOP IF NOT FOUND
*
*
         SLR   R5,R5              R5=0  DSN COUNT
         L     R6,4(,R11)         R6->DSN TABLE
         L     R7,8(,R11)         R7->SIZE OF TABLE
         LH    R7,0(,R7)          R7=LENGTH OF TABLE
*
MOVELOOP BAL   R14,MOVEDSN        PUT THE DSN IN THE TABLE
         BXH   R15,R15,EXIT       STOP IF TABLE ERROR
         CLI   0(R9),X'00'        END OF TIOT?
         BE    MOVEND             YES
         CLC   4(8,R9),=CL8' '    BLANK DD NAME?
         BE    MOVELOOP           YES->MUST BE CONCATENATED
*
MOVEND   L     R1,12(,R11)        R1->ENTRY COUNT PARM
         STH   R5,0(R1)           PASS THE COUNT OF ENTRIES TO JEFF
         EJECT
*
*        CODE  TO LEAVE DSNTAB:
*
EXIT     LR    R1,R13             WORKAREA ADDR FOR FREEMAIN
         L     R0,=A(WORKLEN)     WORKAREA LEN   "    "
         L     R13,4(,R13)        GET CALLERS SAVEAREA ADDR
         ST    R15,16(,R13)       SAVE RETURN CODE
         FREEMAIN RU,LV=(0),A=(1)                             GP 10/98
         RETURN (14,12)
         EJECT
*                                 FIND THE DDNAME IN THE TIOT:
*
FINDDD   ST    R14,L1LS
         L     R1,540             R1->TCB NOW RUNNING
         L     R2,12(,R1)         R2->TIOT
         LA    R9,24(,R2)         R9->FIRST DD ENTRY IN TIOT
         L     R10,0(,R11)        R10->DDNAME PASSED BY JEFF
*
MTCHLOOP CLC   0(8,R10),4(R9)     DDNAMES MATCH?
         BE    FINDX              YES
         BAL   R14,NEXTDD         R9->NEXT DD ENTRY
         CLI   0(R9),X'00'        END OF TIOT?
         BNE   MTCHLOOP           NO->COMPARE DDNAME
*
         LA    R15,2              R15=2 RC=4
*
FINDX    L     R14,L1LS
         BR    R14                EXIT
         EJECT
*
*              SUBRTN TO MOVE A   DSN TO THE TABLE:
*
MOVEDSN  ST    R14,L1LS
         SLR   R1,R1                                          GP 09/99*
         ICM   R1,7,12(R9)        R1->JFCB
         CH    R7,=H'50'          ROOM IN TABLE FOR THIS NAME?
         BNL   MOVEIT             YES -> DO IT
         LA    R15,4              NO->SAY TABLE SIZE ERROR
         B     MX
*
MOVEIT   TM    14(R9),X'01'       JFCB SVA ODD?               GP 10/98*
         BZ    JFCBADOK           NO, EVEN AS EXPECTED FOR ADDRESS    *
         L     R2,540             YES, POINT TO CURRENT TCB           *
         L     R2,180(,R2)        POINT TO JSCB                       *
         L     R2,244(,R2)        POINT TO QMPA                       *
         L     R2,24(,R2)         POINT TO QMAT                       *
         LA    R2,1(R1,R2)        POINT TO JFCB POINTER               *
         L     R1,0(,R2)          POINT TO JFCB               GP 10/98*
*
JFCBADOK MVC   6(44,R6),16(R1)    MOVE THE DSN INTO THE TABLE
         MVC   0(4,R6),=X'00020001'    INIT TEXT UNIT KEY
*
*                                 FIND THE LENGTH OF THE DSN:
*
         LA    R2,6(,R6)          R2->DSN
         SLR   R3,R3              R3=0 INIT DSN LEN
DSL      IC    R4,0(R2,R3)        R4=NEXT DSN CHAR TO BE CHECKED
         CLM   R4,1,=C' '         IS IT BLANK?
         BE    DSEND              YES
         LA    R3,1(,R3)          R3+1->NEXT CHAR
         B     DSL                CHECK NEXT IF NO BLANK YET
*
DSEND    STH   R3,4(,R6)          PUT THE DSN LENGTH IN THE TABLE
         SH    R7,=H'50'          UPDATE LENGTH REMAINING IN TABLE
         LA    R5,1(,R5)          R5+1=DSN COUNT IN TABLE
         BAL   R14,NEXTDD         R9->NEXT DD ENTRY IN TIOT
         LA    R6,50(,R6)         R6->NEXT SLOT IN NAME TABLE
*
MX       L     R14,L1LS
         BR    R14                EXIT
         EJECT
*
*              SUBRTN TO MOVE R9  TO THE NEXT DD ENTRY IN THE TIOT
*
NEXTDD   SLR   R8,R8
         IC    R8,0(,R9)          R8=LENGTH OF CURRENT DD ENTRY
         LA    R9,0(R8,R9)        R9->NEXT DD ENTRY IN TIOT
         BR    R14                RETURN
         SPACE 2
         LTORG
         SPACE 2
WORKAREA DSECT
SAVEAREA DS    18F
L1LS     DS    F
L2LS     DS    F
WORKLEN  EQU   *-WORKAREA
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         END
