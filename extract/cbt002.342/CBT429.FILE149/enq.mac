//CSYSMASA JOB ACCT,MSGCLASS=A,COND=(0,NE)
/*ROUTE PRINT WYLBUR
//ASM EXEC ASMHCL
//ASM.SYSLIB DD
//           DD
//           DD DISP=SHR,DSN=SYS5.MSSMAC
         MACRO
         OACWORK &DUMMY
AREAA    DS    F                  ADDRESS OF Q AREA
AREAL    DS    F                  LENGTH OF AREA
RIBL     DS    H                  LENGTH OF RIB
RIBEL    DS    H                  LENGTH OF RIBE
TOKEN    DS    F                  TOKEN FOR GQSCAN
GQRC     DS    F                  RETURN CODE FROM GQSCAN
NRIBS    DS    F                  NUMBER OF RIBS RETURNED
NRIBES   DS    F                  NUMBER OF RIBES THIS RIB
NCRIBES  DS    F                  NUMBER OF RIBES IN THIS AREA
GQLIST   GQSCAN MF=L
IOPLL    DS    4F
TSOECB   DS    F
GETADDR  DS    F                  ADDR OF BUFFER RETURNED BY PUTGET
GETLEN   DS    F                  LENGTH OF BUFFER RETURNED BY PUTGET
CURIN    DS    F                  POINTER TO CURRENT INPUT POSITION
CUREND   DS    F                  POINTER PAST END OF CURRENT INPUT
OLD      DS    2F                 OUTPUT LINE DESCRIPTOR
PARMLSTS EQU   *
PUTLL    PUTLINE MF=L             PUTLINE PARM BLOCK
         ORG   PARMLSTS
PUTGETL  PUTGET  MF=L             PUTGET PARM BLOCK
         ORG   PARMLSTS
GETMAINL GETMAIN VC,MF=L
         ORG   PARMLSTS
FREEML   FREEMAIN VU,MF=L
         ORG
QNL      DS    H                  QNAME LENGTH
RNL      DS    H                  RNAME LENGTH
JNL      DS    H                  JOBNAME LENGTH
FLGS     DS    X
CONTFLG  EQU   X'80'              RIB HAS BEEN FORMATTED
CONFLG   EQU   X'40'              CONFLICT COMMAND IN EFFECT
FINDFLG  EQU   X'20'              FIND COMMAND IN EFFECT
GLOBFLG  EQU   X'10'              GLOBAL COMMAND IN EFFECT
QNAME    DS    CL8                QUEUE NAME
JNAME    DS    CL8                JOB NAME
RNAME    DS    CL255              RNAME
PRTLEN   DS    H                  PRINTLINE LENGTH
PRTOFF   DS    H                  OFFSET
PRTBUFF  DS    (300)CL1           OUTPUT BUFFER
         MEND
         MACRO
&LBL     MSG   &PARM
         LCLA  &A
&A       SETA  2+K'&PARM
&LBL     DC    0H'0',AL2(&A,0)
         DC    C&PARM
         MEND
ENQ      CSECT
ENQ      OACENTER DSECT=WDSECT,WORK=(,YES),EXIT=(EXIT,(R15)),          X
               PARM=(R9,LR,CPPL),STACK=(144,STACK,OVERFLOW,ABEND),     X
               ROUND=YES
         TITLE 'ENQ - INITIALIZATION'
*
*        INITIALIZATION
*
         LA    R8,IOPLL           INITIALIZE THE IOPL
         OACUSING IOPL,R8
         MVC   IOPLUPT(4),CPPLUPT COPY UPT ADD FROM CPPL
         MVC   IOPLECT(4),CPPLECT COPY ECT ADD FROM CPPL
         LA    R1,TSOECB          GET TSO ECB ADDRESS
         ST    R1,IOPLECB         STORE IN IOPL
         OACDROP R8,R9
         LA    R1,PRTLEN          INITIALIZE TO OLD
         ST    R1,OLD+4           STORE OUTPUT BUF ADD IN OLD
         LA    R1,1               GET NUMBER OF OUTPUT SEGMENTS
         ST    R1,OLD             STORE IN OLD
         XC    PRTOFF(2),PRTOFF   ZERO OFFSET OF FIRST SEGMENT
         MVC   GETMAINL(GETMLEN),GETMDC BUY AN AREA FOR GQSCAN
GETAREA  GETMAIN VC,LA=MEMLOW,A=AREAA,MF=(E,GETMAINL),SP=1,            X
               RELATED=(FREEAREA)
         LTR   R15,R15
         BZ    CONFL1
         LA    R1,NOMEM           COMPLAIN ABOUT LACK OF MEMORY
         OACCALL PRINT
         LA    R15,4
         B     EXIT
*
*        ON ENTRY WE ASSUME THE CONFLICT COMMAND
*
CONFL1   MVI   FLGS,CONFLG        INIT THE FLAG
         XC    QNL(6),QNL         ZERO LENGTHS
         MVC   GQLIST(CONQL),CONQ INIT PARM LIST
         TITLE 'ENQ - MAIN Q SCAN/FORM AT LOOP'
*
*        MAIN  Q SCAN/FORMAT LOOP  FOR ALL COMMANDS
*
ENQLP    OACCALL SCAN             GO SCAN QUEUES
         BNZ   GETCMD             NOTHING THERE
         L     R9,AREAA           POINT TO FIRST RIB
         OACUSING RIB,R9
*
*        LOOP  TO HERE AFTER RESCAN WHERE ALL RIBES FOR THE
*              PREVIOUS RIB OCCURED  IN THE PREVIOUS AREA
*
ENQLP1   MVC   NRIBES(4),RIBTRIBE TOTAL NUMBER OF RIBE'S FOR THIS RIB
         NI    FLGS,X'FF'-CONTFLG MARK START OF RIB
         MVC   NCRIBES(4),RIBNRIBE SAVE # RIBES THIS AREA
         LR    R8,R9              COPY RIB ADDR
         AH    R8,RIBL            ADD IN RIBLENGTH RETURN BY GQSCAN
         AH    R8,RIBVLEN         ADD IN LENGTH OF VARIABLE PORTION
         OACUSING RIBE,R8
*
*        LOOP  TO HERE TO PROCESS  A RIBE
*
ENQLP3   OACCALL FINDCHK          SEE IF WE PRINT THIS ONE
         BNZ   ENQ2               IF NOT NO PRINT
         OACCALL FMTRIBE          FORMAT JOB INFO
         OACCALL FMTRIB           FORMAT QNAME, RNAME INFO
         OACCALL PRINT
         BNZ   GETCMD             IF ATTN, QUIT
ENQ2     AH    R8,RIBEL           POINT TO NEXT RIBE
         L     R1,NRIBES         GET # UNPROCESSED RIBES THIS RIB
         BCT   R1,ENQ4            DECREMENT
*
*        FINISHED WITH THE RIBES IN THIS RIB
*        ADJUST POINTER AND DECREMENT NUMBER OF RIBS
*
ENQ2A    LR    R9,R8              ITS A RIB NOT A RIBE
         NI    FLGS,X'FF'-CONTFLG MARK START OF RIB
         L     R1,NRIBS           GET # UNPROCESSED RIBS
         BCT   R1,ENQ3            DECREMENT
*
*        FINISHED WITH ALL THE RIBS IN THIS AREA
*        CHECK RC TO SEE IF THAT  WAS THE LAST RIB
*
         ICM   R1,15,GQRC         CHECK FOR END OF LIST
         BZ    GETCMD
         OACCALL RESCAN           GET NEXT CHUNK OF STUFF
         L     R9,AREAA           POINT TO FIRST RIB
         BZ    ENQLP1
         B     GETCMD             TOTAL NUMBER OF RIBE'S FOR THIS RIB
*
*        THERE IS AT LEAST ONE UNPROCESSED RIB IN THIS AREA
*
ENQ3     ST    R1,NRIBS           STORE NEW #
         B     ENQLP1             GO PROCESS THIS RIB
*
*        THERE IS AT LEAST ONE UNPROCESSED RIBE IN THIS RIB
*
ENQ4     ST    R1,NRIBES          STORE NEW #
         L     R1,NCRIBES         GET # UNPROCESSED RIBS THIS AREA
         BCT   R1,ENQ5
*
*        THE RIBES FOR THIS RIB SPAN THIS AREA
*        SO WE  WANT THE NEXT CHUNK, BUT WE DONT
*        WANT  TO REDISPLAY THE QNAME, RNAME INFO
*
**       OACCALL RESCAN           GET NEXT CHUNK OF STUFF
**       BNZ   GETCMD
**       L     R9,AREAA           POINT TO FIRST RIB
**       OI    FLGS,CONTFLG       MARK CONTINUATION
**       B     ENQLP2
*
*        WELL  IT WAS A GOOD IDEA, BUT IT TURNS OUT THAT
*        GQSCAN TRUNCATES SPANNED RIBES UNLESS THE SCOPE
*        IS LOCAL OR GLOBAL, FOR WHICH YOU HAVE TO BE
*        KEY ZERO SUPERVISOR, SO JUST PUT OUT A MSG OF (*MORE*)
*        AND PROCESS THE NEXT RIB
         LA    R1,MOREM           POINT TO MORE MESSAGE
         ST    R1,OLD+4           STORE IN OLD
         OACCALL PRINT
         BZ    ENQ2A              PROCESS NEXT RIB
         B     GETCMD             IF ATTN PROCESS NEXT CMD
*
*        THERE  IS AT LEAST ONE UNPROCESSED RIBE IN THIS AREA
*
ENQ5     ST    R1,NCRIBES         STORE NEW #
         B     ENQLP3             GO FORMAT THIS ONE
         TITLE 'ENQ - COMMAND REQUESTOR'
*
*        COMMAND REQUESTOR
*
GETCMD   NI    FLGS,CONFLG+FINDFLG+GLOBFLG CLEANUP FLAGS
         LA    R1,HERALD          POINT TO HERALD
         ST    R1,OLD+4           STORE IN OLD
         MVC   PUTGETL(PUTGTDCL),PUTGETDC INIT PARM BLOCK
         XC    TSOECB(4),TSOECB   INIT ECB
         PUTGET PARM=PUTGETL,OUTPUT=(OLD,SINGLE,MODE),                 X
               TERMPUT=(EDIT,WAIT,NOHOLD,NOBREAK),                     X
               TERMGET=(EDIT,WAIT),MF=(E,IOPLL)
         CH    R15,=H'5'          SEE IF OK RETURN
         BL    GETCMD1
         CH    R15,=H'8'          WAS IT ATTENTION?
         BE    GETCMD             IF SO REPROMPT
         CH    R15,=H'32'         DID THE USER HANG UP?
         BE    CLEANUP            IF SO JUST EXIT
         EX    R0,*               SHOULD NEVER HAPPEN
GETCMD1  L     R9,PUTGETL+12      GET ADDR OF REPLY
         ST    R9,GETADDR         SAVE AS ADDR OF INPUT BUFFER
         LH    R8,0(R9)           GET LENGTH OF INPUT BUFFER
         ST    R8,GETLEN          SAVE LENGTH
         CH    R8,=H'4'           SEE IF EMPTY
         BH    GETCMD2            NO SO PROCESS IT
RECMD    TM    FLGS,CONFLG        DO LAST COMMAND AGAIN
         BO    CONFLICT           IF CONFLICT, DO IT AGAIN
         TM    FLGS,FINDFLG       IF FIND
         BO    FINDAG             DO THAT AGAIN
         TM    FLGS,GLOBFLG       IF GLOBAL
         BO    GLOBAL             DO THAT AGAIN
GETCMDAG OACCALL GETCMDFR         FREE THE INPUT BUFFER
         B     GETCMD             AND ASK AGAIN
GETCMD2  LA    R7,0(R8,R9)        POINT PAST END OF INPUT BUFFER
         ST    R7,CUREND          SAVE THIS POSITION
         LA    R6,4(R9)           POINT TO FIRST TEXT CHAR
         ST    R6,CURIN           INITIALIZE CURRENT INPUT POSITION
         OACCALL GETTOKEN
         BZ    RECMD              IF EMPTY LINE, DO PREVIOUS CMD
         CLI   0(R1),C'C'         SEE IF CONFLICT
         BE    CONFLICT
         CLI   0(R1),C'E'         SEE IF END
         BE    END
         CLI   0(R1),C'F'         SEE IF FIND
         BE    FIND
         CLI   0(R1),C'G'         SEE IF GLOBAL
         BE    GLOBAL
         LA    R1,CMDNF           POINT TO INVALID COMMAND MSG
         ST    R1,OLD+4
         OACCALL PRINT
         BZ    GETCMDAG           IF NO ATTN, ASK AGAIN
         B     END                IF ATTN, END
         TITLE 'ENQ - COMMANDS'
CONFLICT OACCALL GETCMDFR         CONFLICT
         B     CONFL1
*
END      OACCALL GETCMDFR         END
         B     CLEANUP
*
GLOBAL   OACCALL GETCMDFR         GLOBAL
         MVI   FLGS,GLOBFLG       CLEAR FLAGS
         MVC   GQLIST(ALLQL),ALLQ INIT PARM BLOCK
         B     ENQLP
*
FIND     XC    QNL(6),QNL         ZERO ALL LENGTHS
         OACCALL GETTOKEN
         BZ    FIND1              IF NONE LEAVE ALL EMPTY
         CLI   0(R1),C'*'         * IS SAME AS EMPTY
         BE    FIND1
         CH    R15,=H'8'          CHECK LENGTH
         BH    FINDPR
         STH   R15,QNL            SAVE QNAME LENGTH
         BCTR  R15,0              DECREMENT FOR  EXECUTE
         MVC   QNAME(1),0(R1)     < EXECUTED >
         EX    R15,*-6            MOVE INTO SAVE AREA
FIND1    OACCALL GETTOKEN
         BZ    FIND2              IF NONE LEAVE REST EMPTY
         CLI   0(R1),C'*'         * IS SAME AS EMPTY
         BE    FIND2
         CH    R15,=H'255'
         BH    FINDPR
         STH   R15,RNL            SAVE RNAME LENGTH
         BCTR  R15,0              DECREMENT FOR EXECUTE
         MVC   RNAME(1),0(R1)     < EXECUTED >
         EX    R15,*-6
FIND2    OACCALL GETTOKEN
         BZ    FINDAG             IF NONE LEAVE REST EMPTY
         CLI   0(R1),C'*'         * IS SAME AS EMPTY
         BE    FINDAG
         CH    R15,=H'8'          CHECK FOR VALID LENGTH
         BH    FINDPR
         STH   R15,JNL            SAVE JOBNAME LENGTH
         BCTR  R15,0              DECREMENT FOR EXECUTE
         MVC   JNAME(1),0(R1)     < EXECUTED >
         EX    R15,*-6
FINDAG   OACCALL GETCMDFR
         MVI   FLGS,FINDFLG       FIND
         MVC   GQLIST(ALLQL),ALLQ INIT PARM BLOCK
         B     ENQLP
FINDPR   LA    R1,FINDPRM         POINT TO INVALID PARM MSG
         ST    R1,OLD+4           STORE IN OLD
         OACCALL PRINT
         BZ    GETCMDAG           IF NO ATTN, ASK AGAIN
         B     END                IF ATTN, QUIT
*
CLEANUP  MVC   FREEML(FREEMLEN),FREEMDC
FREEAREA FREEMAIN VU,A=AREAA,MF=(E,FREEML),SP=1,RELATED=(GETAREA)
         SR    R15,R15
         B     EXIT
         TITLE 'ENQ - CONSTANTS'
MEMLOW   DC    X'00008000'        MEM LIMITS FOR GQ AREA
MEMHIGH  DC    X'7FFFFFFF'
GETMDC   GETMAIN VC,SP=1,MF=L
GETMLEN  EQU   *-GETMDC
FREEMDC  FREEMAIN VU,SP=1,MF=L
FREEMLEN EQU   *-FREEMDC
PUTGETDC PUTGET  OUTPUT=(0,,MODE),MF=L
PUTGTDCL EQU   *-PUTGETDC
ALLQ     GQSCAN REQLIM=MAX,SCOPE=ALL,SYSNAME=0,REQCNT=1,MF=L
ALLQL    EQU   *-ALLQ
CONQ     GQSCAN REQLIM=MAX,SCOPE=ALL,SYSNAME=0,WAITCNT=1,MF=L
CONQL    EQU   *-CONQ
NOMEM    MSG   ' NOT ENOUGH CORE TO PROCESS REQUEST'
HERALD   MSG   ' ENQ'
CMDNF    MSG   ' INVALID COMMAND'
FINDPRM  MSG   ' INVALID PARAMETER'
MOREM    MSG   ' (*MORE*)'
         LTORG
         OACDROP R10
         TITLE 'ENQ - SUBROUTINES'
*
*        SUBROUTINE TO PARSE AND  UPPERCASE NEXT TOKEN FROM INPUT LINE
*
*     ON ENTRY ASSUMES:
*        CURIN POINTS TO FIRST CHAR OF TEXT
*        CUREND POINTS PAST END OF TEXT
*
*     ON RETURN:
*        R1 POINTS TO FIRST CHAR OF TOKEN
*        R15 CONTAINS LENGTH OF TOKEN
*        CURIN POINTS TO NEXT POSITION IN INPUT STRING
*
GETTOKEN OACSUB
         L     R6,CURIN           POINT TO CURRENT POS
         L     R7,CUREND          POINT PAST END OF STRING
         SR    R15,R15            ASSUME ZERO LENGTH TOKEN
         CR    R6,R7              SEE IF AT END OF TEXT
         BNL   GETTR1             IF SO RETURN WITH EMPTY TOKEN
*
*        FIND  FIRST NON BLANK, OR COMMA
*
GETT1    OI    0(R6),C' '         UPPERCASE THE CHARACTER
         CLI   0(R6),C' '         SEE IF BLANK
         BNE   GETT2              BRANCH IF NOT
         LA    R6,1(R6)           POINT TO NEXT CHAR
         CR    R6,R7              SEE IF OFF END OF TEXT
         BL    GETT1              IF NOT OFF END CONTINUE
         B     GETTR1             IF OFF END RETURN EMPTY TOKEN
GETT2    CLI   0(R6),C','         IS IT A COMMA
         BNE   GETT3              IF NOT THEN START OF TOKEN
         B     GETTR              AND RETURN EMPTY TOKEN
*
*        NEXT  BLANK OR COMMA DELIMITS TOKEN
*
GETT3    LR    R1,R6              SAVE START OF TOKEN
GETT4    OI    0(R6),C' '         UPPERCASE THE CHARACTER
         CLI   0(R6),C' '         FIND NEXT BLANK
         BE    GETTR              END OF TOKEN
         CLI   0(R6),C','         COMMA IS ALSO A DELIMITER
         BE    GETTR              END OF TOKEN
         LA    R15,1(R15)         COUNT THIS CHAR
         LA    R6,1(R6)           BUMP POINTER
         CR    R6,R7              SEE IF OFF END OF TEXT
         BL    GETT4              IF NOT, CONTINUE SCAN
GETTR    LA    R6,1(R6)           POINT TO NEXT CHAR
GETTR1   ST    R6,CURIN           SAVE NEW CURRENT POSSITION
         OACRET RC=(R15)
         LTORG
         OACDROP R10
         EJECT
*
*        SUBROUTINE TO FREE INPUT BUFFER FROM PUTGET
*        ASSUMES ADDR IN R9, LENGTH IN R8
*
GETCMDFR OACSUB
         L     R9,GETADDR         POINT TO AREA TO BE FREED
         L     R8,GETLEN          GET LENGTH OF AREA TO BE FREED
         FREEMAIN R,A=(R9),LV=(R8),SP=1
         OACRET
         LTORG
         OACDROP R10
         EJECT
SCAN     OACSUB
         XC    TOKEN(4),TOKEN     ZERO TOKEN
         LM    R2,R3,AREAA        GET AREA ADDR AND LENGTH
         GQSCAN AREA=((R2),(R3)),TOKEN=TOKEN,MF=(E,GQLIST)
         ST    R15,GQRC           SAVE THE RC
         CH    R15,=H'4'          EMPTY
         BE    SCANRT             IF SO RETURN
         CH    R15,=H'12'         ERROR
         BL    SCAN1
         EX    R0,*               SHOULD NEVER HAPPEN
SCAN1    ST    R0,RIBL            SAVE LENGTHS OF RIB AND RIBE
         ST    R1,NRIBS           SAVE # RIBS THIS AREA
         SR    R15,R15
SCANRT   OACRET RC=(R15)
         LTORG
         OACDROP R10
         EJECT
*
*        CALL  TO GET NEXT CHUNK  OF DATA FROM GQSCAN
*
RESCAN   OACSUB
         GQSCAN MF=(E,GQLIST)
SCANCHK  ST    R15,GQRC           SAVE THE RC
         CH    R15,=H'4'          EMPTY
         BE    RESCANRT           IF SO RETURN
         CH    R15,=H'12'         ERROR
         BL    RESCAN1
         EX    R0,*               SHOULD NEVER HAPPEN
RESCAN1  ST    R0,RIBL            SAVE LENGTHS OF RIB AND RIBE
         ST    R1,NRIBS           SAVE # RIBS THIS AREA
         SR    R15,R15
RESCANRT OACRET RC=(R15)
         LTORG
         OACDROP R10
         EJECT
*
*        CHECK  TO SEE IF FIND IS  IN EFFECT
*        IF NOT RETURN RC=0
*
*        IF SO CHECK THAT SPECIFIED INITIAL PORTIONS OF
*        QNAME RNAME AND JOBNAME  MATCH
*        RETURN ZERO IF SO, NONZERO IF NOT
*
FINDCHK  OACSUB
         TM    FLGS,FINDFLG       IS FIND APPROPRIATE
         BNO   FINDC00            NO, EVERYTHING IS FOUND
         SR    R1,R1              CLEAR R1
         ICM   R1,3,QNL           GET QNAME LENGTH
         BZ    FINDC1
         BCTR  R1,0               DECREMENT FOR EXECUTE
         CLC   RIBQNAME(1),QNAME  < EXECUTED >
         EX    R1,*-6
         BNE   FINDNZ
FINDC1   ICM   R1,3,JNL           GET JOBNAME LENGTH
         BZ    FINDC2
         BCTR  R1,0               DECREMENT FOR EXECUTE
         CLC   RIBEJBNM(1),JNAME  < EXECUTED >
         EX    R1,*-6
         BNE   FINDNZ
FINDC2   ICM   R1,3,RNL           GET RNAME LENGTH
         BZ    FINDC00
         BCTR  R1,0               DECREMENT FOR EXECUTE
         LR    R15,R9             COPY RIB ADDR
         AH    R15,RIBL           POINT TO VARIABLE PORTION
         CLC   0(1,R15),RNAME     < EXECUTED >
         EX    R1,*-6
         BNE   FINDNZ
FINDC00  SR    R15,R15
FINDNZ   DS    0H                 R15 CONTAINS BASE AND IS NON-ZERO
FINDRET  OACRET RC=(R15)
         LTORG
         OACDROP R10
         EJECT
*
*        FORMAT THE REQUESTOR SPECIFIC INFO FROM THE RIB AND RIBE
*
FMTRIBE  OACSUB
         MVI   PRTBUFF,C' '       START WITH A BLANK
         MVI   PRTBUFF+1,C'J'     ASSUME SCOPE OF STEP
         TM    RIBSCOPE,RIBSTEP   SEE IF NOT STEP
         BO    FMTRIBE1
         MVI   PRTBUFF+1,C'S'     IF NOT, ASSUME SYSTEM
FMTRIBE1 MVI   PRTBUFF+2,C'S'     ASSUME SHARED
         TM    RIBERFLG,RIBETYPE  SEE IF SHARED
         BO    FMTRIBE2
         MVI   PRTBUFF+2,C'E'     IF NOT, ITS EXCLUSIVE
FMTRIBE2 MVI   PRTBUFF+3,C'G'     ASSUME OWNES THE RESOURCE
         TM    RIBESFLG,RIBESTAT  SEE IF OWNES
         BO    FMTRIBE3
         MVI   PRTBUFF+3,C'W'     IF NOT, ITS WAITING
FMTRIBE3 MVI   PRTBUFF+4,C'R'     ASSUME RESERVE
         TM    RIBERFLG,RIBERESV                 CBT-AXC
         BO    FMTRIBE4
         MVI   PRTBUFF+4,C' '     IF NOT, LEAVE BLANK
FMTRIBE4 MVI   PRTBUFF+5,C'M'     ASSUME MUST COMPLETE
         TM    RIBERFLG,RIBEMC                   CBT-AXC
         BO    FMTRIBE5
         MVI   PRTBUFF+5,C' '     IF NOT, LEAVE BLANK
FMTRIBE5 MVI   PRTBUFF+6,C' '     BLANK
         MVC   PRTBUFF+7(8),RIBEJBNM COPY JOBNAME
         MVC   PRTLEN(2),=H'19'   ASSUME NO VOL,UCB - LEN=15+4
         TM    RIBERFLG,RIBERESV  TEST FOR RESERVE    CBT-AXC
         BNO   FMTRIBE6
         MVI   PRTBUFF+15,C' '
         MVC   PRTLEN(2),=H'31'   LEN = 27+4
         L     R2,RIBEUCB         GET UCB ADDRESS
         MVC   PRTBUFF+16(6),UCBVOLI-UCBOB(R2)
         MVI   PRTBUFF+22,C'-'
         SLL   R2,4               SHIFT UCB ADDRESS LEFT 2
         ST    R2,PARMLSTS        STORE IN WORK AREA
         OI    PARMLSTS+3,X'0F'   OR IN SIGN
         UNPK  PRTBUFF+23(4),PARMLSTS+1(3) UNPACK
         L     R1,=A(FMTTRTBL)    BECAUSE OF ADDRESSABILITY
         TR    PRTBUFF+23(4),0(R1) CONVERT TO CHARACTER
FMTRIBE6 LA    R1,PRTLEN          POINT TO THE SEGMENT
         ST    R1,OLD+4           STORE IN OLD
         OACRET
FMTTRTBL EQU   *-X'F0'
         DC    C'0123456789ABCDEF' TRANSLATE TABLE
         LTORG
         OACDROP R10
         EJECT
*
*        FORMAT THE RESOURCE SPECIFIC INFO FROM THE RIB
*
*        ALTHOUGH THIS SUBROUTINE IS CALLED FOR EACH RIBE,
*        IT ONLY ADDS STUFF TO THE PRINT BUFFER ONCE FOR EACH
*        RIB.  IT ASSUMES THAT FMTRIBE HAS ALREADY BEEN CALLED
*
FMTRIB   OACSUB
         TM    FLGS,CONTFLG       SEE IF RIB ALREADY FORMATTED
         BO    FMTRIB00
         OI    FLGS,CONTFLG       MARK RIB AS FORMATTED
         LA    R1,PRTLEN          POINT TO OUTPUT BUFFER
         ST    R1,OLD+4           POINT OLD TO PRINT BUFFER
         LH    R2,PRTLEN          GET LENGTH
         LA    R1,0(R1,R2)        POINT PAST END OF BUFFER
         MVI   0(R1),C' '         MOVE IN QNAME
         MVC   1(8,R1),RIBQNAME
         MVI   9(R1),C' '
         AH    R2,=H'10'          ADDJUST LENGTH
         SR    R3,R3              CLEAR R3
         ICM   R3,1,RIBRNMLN      GET RNAME LENGTH
         BNZ   FMTRIB1
         STH   R2,PRTLEN          SAVE NEW LENGTH
         B     FMTRIB00
FMTRIB1  AR    R2,R3              ADD RNAME LENGTH TO PRINT LENGTH
         STH   R2,PRTLEN          SAVE NEW LENGTH
         LR    R4,R9              COPY RIB ADDR
         AH    R4,RIBL            POINT TO VARIABLE PORTION
         BCTR  R3,0               DECREMENT FOR EXECUTE
         MVC   10(1,R1),0(R4)     < EXECUTED >
         EX    R3,*-6             MOVE IN RNAME
FMTRIB00 OACRET
PRTSPACE MSG   '  '
         LTORG
         OACDROP R10
         EJECT
*
*        PUTLINE SUBROUTINE, ASSUMES OLD POINTS TO SEGMENT TO BE
*         PRINTED. RETURNS NON ZERO IF ATTENTION SIGNALLED
*
PRINT    OACSUB
         XC    TSOECB(4),TSOECB
         MVC   PUTLL(PUTLDCL),PUTLDC
         PUTLINE PARM=PUTLL,OUTPUT=OLD,MF=(E,IOPLL)
         LTR   R15,R15
         BZ    PRINTRET
         CH    R15,4              ATTENTION?
         BE    PRINTNZ            IF SO RETURN NON ZERO RC
         CH    R15,20             TERMINAL DISCONNECTED?
         BE    PRINTRET           IGNORE IT
         CH    R15,12             SEVERE ERROR
         BL    PRINTRET           IGNORE ALL OTHERS
         EX    R0,*               SHOULD NEVER HAPPEN
PRINTRET SR    R15,R15            ZERO RETURN CODE
PRINTNZ  OACRET  RC=(R15)
PUTLDC   PUTLINE MF=L
PUTLDCL  EQU   *-PUTLDC
         LTORG
         OACDROP R10
         TITLE 'ENQ - DSECTS'
         IKJCPPL
         IKJIOPL
UCB      DSECT
         IEFUCBOB
         EJECT
         ISGRIB
         END
//*
//C   EXEC PGM=COMPARE,
//  PARM='GO,ENQ'
//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD
//SYSPRINT DD SYSOUT=*
//I1       DD DISP=(SHR,PASS),DSN=&&GOSET
//I2       DD DISP=SHR,DSN=SYS1.OACLINK
