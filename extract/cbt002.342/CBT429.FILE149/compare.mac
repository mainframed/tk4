//CSYSMASA JOB CSYSMAS,MSGCLASS=A,COND=(0,NE)
/*ROUTE PRINT WYLBUR
//COMPARE  EXEC ASMHCL,PARM.LKED='LET,LIST,NCAL,RENT,REUS,REFR'
//ASM.SYSLIB DD DISP=SHR,DSN=SYS1.MACLIB
//           DD DISP=SHR,DSN=SYS1.AMODGEN
//           DD DISP=SHR,DSN=SYS5.MSSMAC
//ASM.SYSIN DD *
COMP     TITLE 'COMPARE: PROGRAM TO COMPARE TWO LOAD MODULES'
         MACRO
&LABEL   GETDSA &CLEAR=,&LENGTH=0,&OPTIONS=,&SUBPOOL=1,&BASEREG=10
         GBLA  &SP
         GBLB  &LTORG,&PL1,&RECUR,&STMT,&USEDDSA
         GBLC  &CSECT
         LCLA  &A
         LCLB  &B(8)
         LCLC  &BNAME,&CNAME,&LNGTH
.A       ANOP
&A       SETA  &A+1
&B(1)    SETB  (('&OPTIONS(&A)' EQ 'PL1') OR (&B(1)) OR (&B(2)))
&B(2)    SETB  (('&OPTIONS(&A)' EQ 'TASK')  OR (&B(2)))
&B(3)    SETB  (('&OPTIONS(&A)' EQ 'RECURSIVE') OR (&B(3)))
&B(4)    SETB  (('&OPTIONS(&A)' EQ 'STMTNO') OR (&B(4)))
&B(5)    SETB  (('&OPTIONS(&A)' EQ 'DIFF') OR (&B(5)))
&B(6)    SETB  (('&OPTIONS(&A)' EQ 'ENTRY')  OR (&B(6)))
&B(7)    SETB  (('&OPTIONS(&A)' EQ 'NOCSECT') OR (&B(7)))
&B(8)    SETB  (('&OPTIONS(&A)' EQ 'NODSA') OR (&B(8)))
.*
.*   DEFAULT OPTIONS:
.*      NOT 'PL1'       - NO SPECIAL PL1 CONVENTIONS
.*      NOT 'TASK'      - NOT PL1 TASKING OPTION ('TASK' IMPLIES 'PL1')
.*      NOT 'RECURSIVE' - NOT PL1 RECURSIVE (ONLY VALID IF 'PL1')
.*      NO  'STMTNO'    - PL1 STATEMENT NUMBERS ALLOWED (ONLY IF 'PL1')
.*      NOT 'DIFF'      - IGNORE 'LENGTH' AND PROVIDE STANDARD DSA
.*      NO  'ENTRY'     - DO NOT GENERATE ENTRY STATEMENT FOR &LABEL
.*          'CSECT'     - NEW CSECT (WITH LTORG IF NOT FIRST CSECT)
.*          'DSA'       - GENERATE A DSA (DYNAMIC STORAGE AREA)
.*
         AIF   (&A LE N'&OPTIONS).A
         AIF   ('&LABEL' NE '').B
         MNOTE 16,'&&LABEL OMITTED -- MACRO TERMINATED'
         MEXIT
.B       ANOP
&LNGTH   SETC  '72'
         AIF   (NOT &B(1)).C
.*       FALLS THRU IF 'PL1' SPECIFIED
&PL1     SETB  1
&LNGTH   SETC  '100'
         AIF   (NOT &B(2)).C
.*       FALLS THRU IF 'TASK' SPECIFIED
&LNGTH   SETC  '108'
.C       AIF   (NOT &B(5)).D
.*       FALLS THRU IF 'DIFF' SPECIFIED
&LNGTH   SETC  '&LENGTH'
.D       ANOP
&CSECT   SETC  '&LABEL'
         AIF   (NOT &B(1)).F
.*       FALLS THRU IF 'PL1' SPECIFIED
         AIF   (K'&LABEL  LE 7).E
         MNOTE 8,'EXTERNAL NAME &LABEL TRUNCATED TO 7 CHARACTERS'
&CSECT   SETC  '&LABEL'(1,7)
.E       ANOP
&BNAME   SETC  '&CSECT'.'B'
&BNAME   DXD   A                        ALLOCATE THE PSEUDO-REGISTER
         AIF   (NOT &B(3)).F
.*       FALLS THRU IF 'RECURSIVE' PL1
&CNAME   SETC  '&CSECT'.'C'
&CNAME   DXD   F                        ALLOCATE THE PSEUDO-REGISTER
.F       AIF   (NOT &B(6)).G
.*       FALLS THRU IF 'ENTRY' SPECIFIED
         ENTRY &CSECT                   MARK &CSECT AS AN ENTRY POINT
.G       AIF   (NOT &B(7)).H
.*       FALLS THRU IF 'NOCSECT' SPECIFIED
&CSECT   DS    0H                       ENTRY POINT
         AGO   .J
.H       AIF   (NOT &LTORG).I
         LTORG
         EJECT
.I       ANOP
&LTORG   SETB  1
&CSECT   CSECT                          ENTRY POINT
.J       USING &CSECT,15                ESTABLISH ADDRESSABILITY
         SAVE  (14,12),,&CSECT          SAVE CALLER'S REGISTERS
         AIF   (&B(7)).K
.*       FALLS THRU IF 'CSECT' SPECIFIED
         LR    &BASEREG,15              ESTABLISH BASE REGISTER
         USING &CSECT,&BASEREG          ESTABLISH ADDRESSABILITY
         AGO   .L
.K       L     &BASEREG,=A(&SYSECT)     LOAD OLD BASE ADDRESS
         USING &SYSECT,&BASEREG         ESTABLISH ADDRESSABILITY
.L       DROP  15                       DROP ENTRY BASE
         AIF   (&B(8)).R
.*       FALLS THRU IF A 'DSA' IS TO BE PROVIDED
         LR    2,13                     CALLER'S SAVE AREA ADDRESS
         AIF   (&SUBPOOL GT 0).L1
         L     0,=A(&LNGTH)             LOAD SUBPOOL AND NUMBER
         AGO   .L2
.L1      LA    0,&SUBPOOL.(0,0)         LOAD SUBPOOL NUMBER
         SLL   0,24(0)                  SHIFT TO HIGH ORDER BYTE
         O     0,=A(&LNGTH)             OR IN 'DSA' LENGTH
.L2      GETMAIN R,LV=(0)               BUY A 'DSA'
&USEDDSA SETB  1
&SP      SETA  &SUBPOOL
&A       SETA  108
         AIF   (&B(2)).M
.*       FALLS THRU IF 'TASK' NOT SPECIFIED
&A       SETA  100
         AIF   (&B(1)).M
.*       FALLS THRU IF 'PL1' NOT SPECIFIED
&A       SETA  72
         AIF   ('&CLEAR' EQ '').M
         AIF   (T'&CLEAR NE 'N').L3
&A       SETA  &CLEAR
         AIF   (&A LE 256).M
&A       SETA  256
         AGO   .M
.L3      XC    0(&CLEAR,1),0(1)         CLEAR THE NEW 'DSA'
         AGO   .M1
.M       XC    0(&A,1),0(1)             CLEAR THE NEW 'DSA'
.M1      ST    13,4(0,1)                STORE OLD ADDRESS IN NEW
         ST    1,8(0,13)                STORE NEW ADDRESS IN OLD
         LR    13,1                     PLACE NEW ADDRESS IN R13
         MVC   0(4,13),=A(&LNGTH)       MOVE IN 'DSA' LENGTH
         AIF   (NOT &B(1)).Q
.*       FALLS THRU IF 'PL1' SPECIFIED
&A       SETA  128
         AIF   (NOT &B(3)).N
.*       FALLS THRU IF 'RECURSIVE' PL1
&A       SETA  &A+4
&RECUR   SETB  1
.N       AIF   (NOT &B(4)).O
.*       FALLS THRU IF 'STMTNO' SPECIFIED
&A       SETA  &A+64
&STMT    SETB  1
.O       MVI   0(13),&A                 SET 'DSA' FLAGS
         LA    1,0(0,0)                 GET THE
         ORG   *-2                        OFFSET OF
         DC    QL2(&BNAME)                  THE PSEUDO-REGISTER
         ST    1,88(0,13)               STORE PSEUDO-REGISTER OFFSET
         AIF   (NOT &B(3)).P
.*       FALLS THRU IF 'RECURSIVE' PL1 SPECIFIED
         L     0,0(1,12)                LOAD OLD PSEUDO-REGISTER
         ST    0,92(0,13)               SAVE OLD PSEUDO-REGISTER
.P       ST    13,0(1,12)               STORE NEW PSEUDO-REGISTER
         AIF   (NOT &B(3)).Q
.*       FALLS THRU IF 'RECURSIVE' PL1 SPECIFIED
         LA    1,0(0,0)                 GET THE OFFSET
         ORG   *-2                        OF THE INVOCATION
         DC    QL2(&CNAME)                  COUNT PSEUDO-REGISTER
         STH   1,88(0,13)               SAVE PSEUDO-REGISTER OFFSET
         L     15,0(1,12)               LOAD OLD INVOCATION COUNT
         ST    15,84(0,13)              SAVE OLD INVOCATION COUNT
         LA    15,1(0,15)               ADD 1 TO INVOCATION COUNT
         ST    15,0(1,12)               STORE NEW PSEUDO-REGISTER
.Q       LM    15,2,16(2)               RESTORE PASSED REGISTERS
.R       OACREGS ,                      DEFINE SYMBOLIC REGISTERS
         MEND
         SPACE 4
         MACRO
&LABEL   FREEDSA &RC=0,&BRC=
         GBLA  &SP,&STMTNO
         GBLB  &BADSTMT,&PL1,&RECUR,&STMT,&USEDDSA
         AIF   ('&RC'(1,1) NE '(').C
         AIF   ((&RC(1) GE 0) AND (&RC(1) LE 15)).A
.ERR     MNOTE 8,'RC=&RC INVALID -- MACRO TERMINATED'
         MEXIT
.A       AIF   (&RC(1) EQ 15).B
&LABEL   LR    15,&RC(1)                LOAD THE RETURN CODE
         AGO   .F
.B       AIF   ('&LABEL' EQ '').F
&LABEL   DS    0H                       EXIT PROCEDURE
         AGO   .F
.C       AIF   (T'&RC NE 'N').E
         AIF   (&RC EQ 0).D
&LABEL   LA    15,&RC.(0,0)             LOAD THE RETURN CODE
         AGO   .F
.D       ANOP
&LABEL   SR    15,15                    CLEAR THE RETURN CODE TO ZERO
         AGO   .F
.E       AIF   ('&RC' EQ '').ERR
&LABEL   L     15,&RC                   LOAD THE RETURN CODE
.F       AIF   (NOT &USEDDSA).H
         LR    2,13                     SAVE CURRENT SAVE AREA ADDRESS
         L     13,4(0,13)               LOAD OLD SAVE AREA ADDRESS
         STM   15,1,16(13)              SAVE RETURN REGISTERS
         AIF   (NOT &PL1).G
         LH    1,90(0,2)                PSEUDO-REGISTER OFFSET
         L     0,92(0,2)                OLD PSEUDO-REGISTER
         ST    0,0(1,12)                RESTORE OLD PSEUDO-REGISTER
         AIF   (NOT &RECUR).G
         LH    1,88(0,2)                INVOCATION COUNT P-R OFFSET
         L     0,84(0,2)                OLD INVOCATION COUNT
         ST    0,0(1,12)                RESTORE INVOCATION COUNT P-R
.G       MVI   0(2),&SP                 MOVE SUBPOOL NUMBER WITH LENGTH
         L     0,0(0,2)                 LOAD SUBPOOL AND LENGTH
         LR    1,2                      WHERE TO FREE CORE
         FREEMAIN R,LV=(0),A=(1)        FREE THE DSA CORE
         AGO   .I
.H       STM   15,1,16(13)              SAVE RETURN REGISTERS
.I       LM    14,12,12(13)             RESTORE CALLER'S REGISTERS
         MVI   12(13),X'FF'             SET COMPLETION INDICATOR
         AIF   ('&BRC' EQ '').J
         B     0(14,15)                 BRANCH TO RETURN CODE OFFSET
         AGO   .K
.J       BR    14                       RETURN TO CALLER
.K       ANOP
&STMTNO  SETA  0
&BADSTMT SETB  0
&PL1     SETB  0
&RECUR   SETB  0
&STMT    SETB  0
&USEDDSA SETB  0
         MEND
         SPACE 4
         MACRO
         RCRD  &A,&B
         ORG   TRTTABLE+X'&A'
         DC    X'&B'
         ORG   ,
         MEND
         MACRO
         BLDLLIST
BLDLLIST DSECT
BLDLCNT  DC    H'1' .                   NUMBER OF ENTRIES
BLDLLEN  DC    H'64' .                  LENGTH OF ENTRY
BLDLNAME DC    CL8' ' .                 MODULE NAME
BLDLTTRC DC    F'0' .                   TTRC OF MEMBER
BLDLLIB  DC    X'00' .                  LIBRARY
BLDLIND1 DC    X'00' .                  INDICATORS AND LENGTH
BLDLTTRT DC    3X'00' .                 TTR OF TEXT RECORD
BLDLZ1   DC    X'00' .                  ZEROS
BLDLTTRN DC    3X'00' .                 TTR OF NOTE/SCTR LIST
BLDLNL   DC    X'00' .                  # ENTRIES IN NOTE LIST
         SPACE 1
BLDLATR1 DC    X'00' .                  ATTRIBUTES
BLDLRENT EQU   X'80' .                  REENTERABLE
BLDLREUS EQU   X'40' .                  REUSABLE
BLDLOVLY EQU   X'20' .                  OVERLAY
BLDLTEST EQU   X'10' .                  TESTRAN
BLDLOL   EQU   X'08' .                  ONLY LOADABLE
BLDLSCTR EQU   X'04' .                  SCTR FORMAT
BLDLEXEC EQU   X'02' .                  EXECUTABLE
         SPACE 1
BLDLATR2 DC    X'00' .                  ATTRIBUTES, 2ND BYTE
BLDLSIZE DC    3X'00' .                 LENGTH OF MODULE
         ORG   BLDLNAME+38
BLDLIAS  DC    CL8' ' .                 ALIAS NAME FOR RENT MODULE
BLDLTOT  EQU   68
         MEND
         EJECT ,
***********************************************************************
*                                                                     *
*        PROGRAM: COMPARES TWO LOAD MODULES OR PARTS OF LOAD MODULES. *
*                                                                     *
*        METHOD:  ACTS AS A PSEUDO-LOADER.  BUYS AND CLEARS TWO CORE  *
*                 AREAS INTO WHICH THE MODULES' TEXT BLOCKS ARE READ. *
*                 RELOCATABLE REFERENCES ARE RESOLVED USING A COMMON  *
*                 EXTERNAL SYMBOL TABLE TO SOLVE THE PROBLEMS OF      *
*                 DIFFERENT CSECT ORDER AND DIFFERENT LOAD POINTS.    *
*                                                                     *
*        ATTRIB:  REENTRANT, REUSABLE.                                *
*                                                                     *
*        MISSING: CAN'T HANDLE OVERLAY MODULES.                       *
*                                                                     *
*        AUTHOR:  LOU P. RIVAS  -  UCLA/CCN.                JUNE 1977 *
*                                                                     *
*        PARM='NAME1(OFFSET1),NAME2(OFFSET2),COUNT'                   *
*  (IF PARM IS OMMITED THEN ALL MODULES ON I1 WILL BE COMPARED        *
*   WITH CORRESPONDING NAMED MODULES IN I2 AND WTO'S WILL BE DONE     *
*   TO DDNAME 'WTO')                                                  *
*                                                                     *
* --> TTRL XCTL TABLES WILL BE MODIFIED SO DIFFERENT TTRL'S WILL      *
*     MATCH. (MODULE IS DETERMINED TO HAVE TTRL'S BY MODULE NAME)     *
*                                                                     *
*        //I1       DD ...              PDS WITH LOAD MODULE NAME1.   *
*        //I2       DD ...              PDS WITH LOAD MODULE NAME2.   *
*        //SNAP     DD SYSOUT=A,...     OUTPUT FILE/MISMATCHES+SNAP.  *
*        //SYSPRINT DD SYSOUT=A,...     OPTIONAL OUTPUT (NO SNAP).    *
*        //WTO      DD SYSOUT=A,...     WTO FILE IF NO PARM (ALL)     *
*                                                                     *
*        (OFFSET#) IS OPTIONAL AND TAKES THE FORM:                    *
*               (LABEL) WHERE 'LABEL' IS A CSECT OR ENTRY IN NAME#.   *
*               (+NUMBER) WHERE 'NUMBER' IS AN OFFSET INTO THE NAME#; *
*                   'NUMBER' IS ASSUMED HEX AND 'NUMBER.' IS DECIMAL. *
*               (LABEL+NUMBER) WHICH IS THE OFFSET INTO THE LABEL.    *
*                                                                     *
*        COUNT IS OPTIONAL AND TAKES THE FORM 'NUMBER.' OR 'NUMBER'.  *
*               IF COUNT IS NOT SPECIFIED, THE NUMBER OF BYTES THAT   *
*               ARE COMPARED IS THE LARGER OF THE TWO MODULE LENGTHS  *
*               OR THE LARGER OF THE TWO CSECT LENGTHS IF BOTH        *
*               (OFFSET#) SPECIFY CSECTS, ADJUSTED BY THE LENGTH IN   *
*               (OFFSET#) AS APPROPRIATE.  COUNT CAN ONLY BE USED TO  *
*               REDUCE THE COMPARE LENGTH.                            *
*                                                                     *
*        IF ANY 'NUMBER' IS INVALID (E.G. OUTSIDE MODULE OR CSECT),   *
*        IT IS IGNORED.  IF 'LABEL' IS NOT FOUND, IT IS IGNORED.      *
*                                                                     *
*        SYNTACTICAL ERRORS WILL CAUSE A 'PARM INVALID' ERROR         *
*        MESSAGE.  WRONG PARAMETERS WILL CAUSE UNPREDICTABLE RESULTS. *
*                                                                     *
* RETURN CODES: 00 - ALL MODULE(S) COMPARED SUCCESSFULLY              *
*               04 - COMPARE FAILED (AT LEAST 1 IF 'ALL)              *
*               08 - INITIALIZATION FAILED (LAST MODULE IF 'ALL')     *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        FLOW OF CONTROL:                                             *
*                                                                     *
*          1) ENTER, BUY WORK AREA, AND CHAIN SAVE AREAS.             *
*          2) PARSE PARM STRING.                                      *
*          3) 'OPEN' FILES.                                           *
*          4) 'BLDL', GET CORE FOR TEXT BLOCKS, AND 'FIND' MEMBER.    *
*          5) CLEAR TEXT BUFFER AND 'READ' ALL MEMBER BLOCKS.         *
*             A) CLEAR TEXT BUFFER; LENGTH IS FROM BLDLSIZE.          *
*             B) SET FLAG INDICATING "NOTE LIST" PRESENT.             *
*             C) IF FIRST RECORD IS TEXT, GO READ IT (AT III).        *
*             D) READ NON-TEXT RECORD.                                *
*                I) IF EOF THEN CLEAR LABEL IF NOT FOUND AND DONE.    *
*               II) IF "NOTE LIST" RECORD THEN IGNORE IT.             *
*              III) IF CONTROL THEN READ NEXT TEXT RECORD.            *
*               IV) IF CESD THEN RESOLVE LABEL AND BUILD COMMON ESD.  *
*                V) IF RLD THEN RESOLVE RELOCATABLE REFERENCES.       *
*          6) USE OFFSET# AND COUNT TO INITIALIZE FOR COMPARE LOOP.   *
*          7) COMPARE TEXT BUFFERS BYTE BY BYTE; OUTPUT EACH UNEQUAL. *
*          8) 'SNAP' TEXT BUFFERS IF ANY UNEQUALITIES.                *
*          9) FREE TEXT BUFFERS, 'CLOSE' FILES, AND EXIT.             *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
* UPDATES: 001 - 11/22/78 - 1) ALLOW DDNAME=SYSPRINT AS OPTIONAL      *
*                              OUTPUT FILE (REPLACES DDNAME=SNAP).    *
*                              IF SYSPRINT USED, THEN DO MISMATCH     *
*                              LOGGING, BUT DON'T DO PSEODO-SNAP.     *
*                           2) IF OUTPUT FILE (SNAP OR SYSPRINT) IS   *
*                              ALLOCATED TO TSO AS TERMFILE: 1) DON'T *
*                              OPEN FILE, AND 2) FAKE OUT WRITES TO   *
*                              GO TO CODE THAT TPUTS THE RECORDS.     *
*                           3) REMOVE MAIN STORAGE ADDRESSES FROM     *
*                              MISMATCH LINE SINCE REAL SNAP NO       *
*                              LONGER USED.                           *
*          002 - 09/11/79 - 1) FIX 4MEG CONSTANT DEPENDENCY.          *
*                           2) FIX XCTL TTR RESOLUTION CODE TO        *
*                              HANDLE SUBLISTS.                       *
*          003 - 04/23/80 - 1) CONVERT TO MVS.                        *
*          004 - 12/31/80 - 1) FIX UNPK 0C4 BUG.                      *
*                           2) ADD TWO NEW RETURN CODES:              *
*                              04 - COMPARE FAILED.                   *
*                              08 - INITIALIZATION FAILED.            *
*          005 - 12/17/81 - 1) FIX UNFINDABLE CSECT BUG - (1 BIT CHG) *
*                                                                     *
***********************************************************************
         EJECT
COMPARE  GETDSA SUBPOOL=0,LENGTH=WORKLEN,OPTIONS=DIFF,CLEAR=256
         SPACE 2
         USING WORKAREA,R13             ADDRESSABILITY
         SPACE 2
         XC    WORKAREA+1*256(256),WORKAREA+1*256 CLEAR
         XC    WORKAREA+2*256(256),WORKAREA+2*256 CLEAR
         XC    WORKAREA+3*256(BASELEN-3*256),WORKAREA+3*256 THE REST
         SPACE 2
SNAPBLKS EQU   1632                     BLKSIZE FOR 'SNAP' FILE
         SPACE 2
STABCESD EQU   1000                     NUMBER OF CESD TABLE ENTRIES
         EJECT
         MVI   RETCODE+3,8              SET INIT FAILED RETCODE     004
         MVC   DCBWTO(DCBPSQX),DCBPSQ   INITIALIZE WTO DCB
         MVC   SNAP(DCBPSX),DCBPS       INITIALIZE SNAP DCB
         MVC   I1(DCBPOX),DCBPO         INITIALIZE FIRST DCB
         MVC   I2(DCBPOX),DCBPO         INITIALIZE SECOND DCB
         MVI   I2+DCBDDNAM+1-IHADCB,C'2'  AND CORRECT THE DD NAME
         MVC   DECB(DECBX),DECBRW       INITIALIZE DECB
         XC    DCBLIST(16),DCBLIST      INIT OPEN LIST
         MVI   DCBLIST+8,X'80'          ASSUME NOT 'ALL' OPTION
         SPACE 2
         N     R1,=XL4'00FFFFFF'        PARM POINTER WORD THERE ?   002
         BZ    ERR1                     NO, GO TELL USER
         L     R1,0(R1)                 LOAD PARM ADDRESS
         N     R1,=XL4'00FFFFFF'        ANY PARM ?                  002
         BZ    ERR1                     NO, GO TELL USER
         LH    R2,0(R1)                 LOAD PARM LENGTH
         LTR   R2,R2                    ANY PARM ?
         BNZ   HAVEPARM                 YES, GO PROCESS IT
         SPACE 1
         MVI   DCBLIST+8,0
         MVI   DCBLIST+12,X'80'         OPEN 'WTO' TOO
         B     OPEN                     GO OPEN DATASETS
         SPACE 1
HAVEPARM CH    R2,=H'3'                 LONG ENOUGH ?
         BL    ERR2                     NO, GO TELL USER
         LA    R1,2(R1)                 POINT TO PARM PROPER
         SPACE 1
         LA    R3,NAME1                 WHERE TO PUT FIRST NAME
         BAL   R14,NAME                 GO MOVE IT IN
         SPACE 1
         LTR   R2,R2                    BACK WITH NOTHING LEFT ?
         BZ    ERR2                     YES, GO TELL USER
         LA    R3,NAME2                 WHERE TO PUT SECOND NAME
         BAL   R14,NAME                 GO MOVE IT IN
         SPACE 1
         LTR   R2,R2                    BACK WITH NOTHING LEFT ?
         BZ    OPEN                     YES, NO COUNT FIELD
         SPACE 1
         BAL   R15,NUMBER               GO CONVERT THE COUNT
         ST    R0,COUNT                 SAVE IT
         SPACE 1
OPEN     OPEN  (SNAP,OUTPUT,I1,,I2,,DCBWTO,OUTPUT),MF=(E,DCBLIST)
         ORG   *-2                      EMBARASSING KLUDGE HERE     001
         L     R15,=A(OPEN#CHK)         ADDR OF OPEN CHECK CODE     001
         BALR  R14,R15                  GO DO PRE-OPEN CHECKS       001
         EJECT
         TM    SNAP+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?
         BZ    NOWTO                    NO
         TM    I1+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?
         BZ    NOWTO                    NO
         TM    I2+DCBOFLGS-IHADCB,DCBOFOPN OPEN ?
         BZ    NOWTO                    NO
         SPACE 1
         TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001
         BZ    NOTALL                   NO - BRANCH                 001
ALLLOOP  L     R15,=A(GETENT)           @ GETENT ROUTINE
         BALR  R14,R15                  GO GET MODULE NAME
         SPACE 2
NOTALL   LA    R2,NAME1                 DO FIRST ONE
         LA    R3,ERR3                  ERROR EXIT
         BAL   R4,BLDLFIND              GO GET CORE FOR MODULE
         SPACE 1
         LA    R2,NAME2                 DO SECOND ONE
         LA    R3,ERR4                  ERROR EXIT
         BAL   R4,BLDLFIND              GO GET CORE FOR MODULE
         SPACE 2
         LA    R2,NAME1                 DO FIRST ONE
         BAL   R4,CLEAREAD              GO READ IN MODULE
         SPACE 1
         LA    R2,NAME2                 DO SECOND ONE
         BAL   R4,CLEAREAD              GO READ IN MODULE
         SPACE 1
         L     R15,=A(SUP)              BASE FOR IOSUP ROUTINE
         LA    R1,NAME1                 GO FIX TTRL'S MODULE 1
         BALR  R14,R15
         LA    R1,NAME2                 AND MODULE 2
         BALR  R14,R15
         SPACE 2
         L     R5,COMPADR1              FIRST MODULE COMPARE START
         L     R6,COMPADR2              SECOND MODULE COMPARE START
         L     R7,COMPLEN1              FIRST MODULE COMPARE LENGTH
         L     R8,COMPLEN2              SECOND MODULE COMPARE LENGTH
         SPACE 1
         A     R5,NUMBER1               ADJUST FIRST MODULE
         A     R6,NUMBER2               ADJUST SECOND MODULE
         S     R7,NUMBER1               ADJUST FIRST LENGTH
         S     R8,NUMBER2               ADJUST SECOND LENGTH
         SPACE 1
         OC    COUNT,COUNT              COMPARE LENGTH SPECIFIED ?
         BZ    NOCOUNT                  NO
         C     R7,COUNT                 NEED TO ADJUST AGAIN ?
         BNH   *+8                      NO, SKIP NEXT
         L     R7,COUNT                 ADJUST IT
         C     R8,COUNT                 NEED TO ADJUST AGAIN ?
         BNH   *+8                      NO, SKIP NEXT
         L     R8,COUNT                 ADJUST IT
         SPACE 2
NOCOUNT  XR    R2,R2                    INDICATE NO OUTPUT YET
         SPACE 1
         LTR   R7,R7                    IS FIRST LENGTH ZERO ?
         BZ    DONECOMP                 YES, ALMOST FINISHED
         LTR   R8,R8                    IS SECOND LENGTH ZERO ?
         BZ    DONECOMP                 YES, ALMOST FINISHED
         SPACE 2
         LA    R4,1                     USEFUL CONSTANT
         EJECT
COMPLOOP CLC   0(1,R5),0(R6)            ARE THESE TWO BYTES EQUAL ?
         BE    NEXTCOMP                 YES, NO OUTPUT THIS TIME
         SPACE 1
         BAL   R3,OUTPUT                INDICATE WHERE IT FAILED
         SPACE 1
NEXTCOMP AR    R5,R4                    NEXT MODULE1
         AR    R6,R4                    NEXT MODULE2
         SPACE 1
         BCT   R7,*+10                  SKIP NEXT TWO IF MORE MODULE1
         BCTR  R8,0                     ALSO DECREMENT MODULE2
         B     DONECOMP                 NEARLY DONE
         BCT   R8,COMPLOOP              LOOP IF MORE MODULE2
         SPACE 2
DONECOMP CR    R7,R8                    LENGTH MISMATCH ?
         BE    SNAPDUMP                 NO, ALL DONE
         SPACE 1
         XR    R4,R4                    INDICATE LENGTH CALL
         BAL   R3,OUTPUT                INDICATE WHERE IT FAILED
         SPACE 1
SNAPDUMP CLI   RETCODE+3,4              PREVIOUS COMPARE BOMBED?    004
         BE    *+8                      BIF YES - DON'T RESET CODE  004
         MVI   RETCODE+3,0              SET COMPARE WORKED RETCODE  004
         LTR   R2,R2                    ANY OUTPUT ?
         LA    R1,WTO00                 ASSUME 'COMPARES' MESSAGE
         BZ    WTOX                     NO, ALL DONE
         SPACE 1
         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004
         L     R0,COMPADR1              MODULE1 STARTING ADDRESS
         LR    R1,R0                    COPY FOR ENDING ADDRESS
         A     R1,COMPLEN1              ADD LENGTH FOR ENDING ADDRESS
         BCTR  R1,0                     IT IS INCLUSIVE
         L     R2,COMPADR2              MODULE2 STARTING ADDRESS
         LR    R3,R2                    COPY FOR ENDING ADDRESS
         A     R3,COMPLEN2              ADD LENGTH FOR ENDING ADDRESS
         BCTR  R3,0                     IT IS INCLUSIVE
         SPACE 1
         STM   R0,R3,WRKWRDS            SAVE LIST ADDRESSES
         SPACE 1
         LA    R2,2                     LOOP TWO TIMES
         LA    R1,WRKWRDS               WHERE LISTS START
         L     R15,=A(SNAPIT)           @ SNAP ROUTINE
SNAPLOOP BALR  R14,R15                  DUMP IT
         LA    R1,8(R1)                 NEXT LIST
         BCT   R2,SNAPLOOP              GO AGAIN
         SPACE 1
         XR    R4,R4                    FLUSH LAST OUTPUT BUFFER
         BCTR  R4,0                       INDICATOR
         LA    R2,RECORD                SET ADR FOR WRITE IF ANY
         BAL   R3,OUTPUT                INDICATE ALL DONE
         EJECT ,
         SPACE 1
         LA    R1,WTO01                 'COMPARE FAIL' MESSAGE
         SPACE 1
WTOX     MVC   RECORD(256),0(R1)        MOVE THE WTO TO WORK AREA
         MVC   RECORD+12(8),NAME1       FILL IN THE
         MVC   RECORD+36(8),NAME2         MODULE NAMES
WTOY     LA    R1,RECORD                FINISHED WTO
         SPACE 2
WTO      TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001
         BZ    WTO#                     NO - BRANCH                 001
         LR    R0,R1                    SET RECORD OUTPUT
         PUT   DCBWTO,(0)               PRINT THE MSG
         B     NOWTO                    AND CONTINUE
         SPACE 1
WTO#     WTO   MF=(E,(R1))              DONE
         SPACE 1
NOWTO    LM    R0,R1,LENGTH1            FIRST MODULE LENGTH AND ADDRESS
         LM    R2,R3,LENGTH2              AND SAME FOR SECOND MODULE
         STM   R0,R3,WRKWRDS            SAVE LENGTH AND ADDRESS PAIRS
         SPACE 1
         LA    R2,2                     LOOP TWO TIMES
         LA    R3,WRKWRDS               WHERE PAIRS START
         SPACE 1
FREELOOP LM    R0,R1,0(R3)              LOAD LENGTH AND ADDRESS PAIR
         LTR   R1,R1                    ANYTHING THERE ?
         BZ    NEXTFREE                 NO, NOTHING BOUGHT
         SPACE 1
         FREEMAIN R,LV=(0),A=(1)        FREE BOUGHT CORE
         SPACE 1
NEXTFREE LA    R3,8(R3)                 NEXT PAIR
         BCT   R2,FREELOOP              GO AGAIN
         SPACE 1
         XC    FRSTTAB(NEXTTAB-FRSTTAB+L'NEXTTAB),FRSTTAB  CLEAN UP
         XC    NAME1(BLDL1-NAME1),NAME1 CLEAN UP I1 STUFF
         XC    NAME2(BLDL2-NAME2),NAME2 AND I2
         MVI   FLAG,0                   AND ZERO FLAG
         SPACE 1
         TM    FLAGS,FG#ALL             PROCESSING ALL MEMBERS?     001
         BO    ALLLOOP                  YES - GO GET NEXT           001
         SPACE 1
ALLDONE  CLOSE MF=(E,DCBLIST)           CLOSE ALL FILES OPENED
         EJECT ,
         LA    R1,DCBWTO                GET @ DCB FOR FREEPOOL
         TM    23(R1),1                 ANY BUFFER POOL?
         BO    NOSWIM                   BRANCH IF NO POOL
         FREEPOOL (1)                   FREE BUFFER POOL
         SPACE 1
NOSWIM   FREEDSA RC=RETCODE             FREE WORKAREA/SET RC/RETURN 004
         SPACE 2
ERR1     LA    R1,WTO02                 ERROR MESSAGE
         B     WTO                      DO IT
         SPACE 1
ERR2     LA    R1,WTO03                 ERROR MESSAGE
         B     WTO                      DO IT
         SPACE 1
ERR3     LA    R3,C'1'                  INDICATE LIBRARY
         B     *+8                      SKIP NEXT
ERR4     LA    R3,C'2'                  ERROR MESSAGE
         MVC   RECORD(256),WTO04        MOVE THE WTO TO WORK AREA
         MVC   RECORD+12(8),0(R2)       FILL IN THE
         STC   R3,RECORD+35               NAME AND LIBRARY
         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004
         B     WTOY                     DO IT
         SPACE 1
ERR5     L     R1,WRKWRDS               GET REQUESTED SIZE
         LA    R1,1023(R1)              ROUND UP
         SRL   R1,10                    AND MAKE IT K
         CVD   R1,WRKWRDS               TO DECIMAL
         OI    WRKWRDS+7,X'0F'          FIX SIGN
         UNPK  WRKWRDS(5),WRKWRDS+5(3)  TO PRINTABLES
         MVC   RECORD(256),WTO05        MOVE THE WTO TO WORK AREA
         MVC   RECORD+26(5),WRKWRDS     FILL IN THE AMOUNT
         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004
         B     WTOY                     DO IT
         SPACE 1
ERR6     LA    R1,WTO06                 ERROR MESSAGE
         MVI   RETCODE+3,4              SET COMPARE FAILED RETCODE  004
         B     WTO                      DO IT
         EJECT
NAME     MVI   0(R3),C' '               BLANK THE NAME AND
         MVC   1(7+8,R3),0(R3)            LABEL RECEIVING FIELDS
         LA    R4,8(R3)                 SAVE LABEL FIELD START
         SPACE 1
         CLI   0(R1),C','               NO NAME ?
         BE    ERR2                     YES, GO TELL USER
         CLI   0(R1),C'('               OTHER NO NAME ?
         BE    ERR2                     YES, GO TELL USER
         SPACE 1
         BAL   R15,MOVENAME             COPY NAME
         B     ERR2                     WRONG SEPARATOR, GO TELL USER
         LA    R1,1(R1)                 STRIP SEPARATOR
         BCT   R2,*+8                   DECREMENT REMAINDER
         B     ERR2                     NOTHING LEFT, GO TELL USER
         SPACE 1
         LR    R5,R14                   SAVE RETURN ADDRESS
         LA    R14,ERR2                 NEW RETURN ADDRESS
         CLI   0(R1),C')'               ONLY '()' ?
         BER   R14                      YES, GO TELL USER
         CLI   0(R1),C'+'               NO LABEL ?
         BE    NOCSECT                  YES, SKIP THIS THEN
         SPACE 1
         LR    R3,R4                    NEW OUTPUT LOCATION
         BAL   R15,MOVENAME             COPY LABEL
         B     *+8                      SKIP ERROR RETURN
         B     ERR2                     WRONG SEPARATOR, GO TELL USER
         SPACE 1
         CLI   0(R1),C'+'               OFFSET ?
         BNE   ENDNAME                  NO, SKIP THIS THEN
         SPACE 1
NOCSECT  LA    R1,1(R1)                 STRIP '+' SEPARATOR
         BCT   R2,*+6                   DECREMENT REMAINDER
         BR    R14                      NOTHING LEFT, GO TELL USER
         SPACE 1
         BAL   R15,NUMBER               GO CONVERT NUMBER
         ST    R0,8(R4)                 SAVE THE NUMBER
         LTR   R2,R2                    ANYTHING LEFT ?
         BZR   R14                      NO, ERROR
         SPACE 1
ENDNAME  LR    R14,R5                   RESTORE RETURN ADDRESS
         LA    R1,1(R1)                 STRIP ')' SEPARATOR
         BCT   R2,*+6                   DECREMENT REMAINDER
         BR    R14                      NOTHING LEFT, RETURN
         CLI   0(R1),C','               RIGHT SEPARATOR ?
         BNE   ERR2                     NO, GO TELL USER
         SPACE 1
NAMEEND  LA    R1,1(R1)                 STRIP SEPARATOR
         BCTR  R2,0                     DECREMENT REMAINDER
         BR    R14                      RETURN ALL THE WAY
         EJECT
MOVENAME LA    R0,9                     LOOP PREVENTION
         SPACE 1
NAMELOOP MVC   0(1,R3),0(R1)            MOVE IN A CHARACTER
         BCT   R2,*+6                   SKIP NEXT IF ANY LEFT
         BR    R14                      RETURN ALL THE WAY
         LA    R1,1(R1)                 NEXT INPUT CHARACTER
         LA    R3,1(R3)                 NEXT OUTPUT LOCATION
         CLI   0(R1),C','               SEPARATOR ?
         BE    NAMEEND                  YES, GO STRIP IT OFF
         CLI   0(R1),C'('               OTHER SEPARATOR ?
         BE    4(R15)                   YES, RETURN FOR LABEL
         CLI   0(R1),C'+'               OFFSET SEPARATOR ?
         BER   R15                      YES, RETURN FOR OFFSET
         CLI   0(R1),C')'               OFFSET TERMINATOR ?
         BER   R15                      YES, RETURN AFTER OFFSET
         BCT   R0,NAMELOOP              GO AGAIN ?
         B     ERR2                     TELL USER OF PARM ERROR
         SPACE 5
         PRINT NOGEN
WTO00    WTO   'COMP00I XXXXXXXX IS THE SAME AS YYYYYYYY',             *
               ROUTCDE=11,MF=L
WTO01    WTO   'COMP01I XXXXXXXX DOES NOT MATCH YYYYYYYY',             *
               ROUTCDE=11,MF=L
WTO02    WTO   'COMP02I PARM OMITTED',ROUTCDE=11,MF=L
WTO03    WTO   'COMP03I PARM INVALID',ROUTCDE=11,MF=L
WTO04    WTO   'COMP04I XXXXXXXX NOT FOUND IN IY',ROUTCDE=11,MF=L
WTO05    WTO   'COMP05I NEED AT LEAST XXXXXK MORE CORE',ROUTCDE=11,MF=L
WTO06    WTO   'COMP06I SYMBOL TABLE TOO SMALL',ROUTCDE=11,MF=L
         PRINT GEN
         EJECT
NUMBER   CLI   0(R1),C'.'               NO NUMBER ?
         BE    ERR2                     YES, GO TELL USER
         CLI   0(R1),C')'               OTHER NO NUMBER ?
         BE    ERR2                     YES, GO TELL USER
         SPACE 1
         LA    R3,WRKWRDS+8             NUMBER OUTPUT LOCATION
         LA    R0,9                     LOOP PREVENTION
         SPACE 1
NUMLOOP  IC    R6,0(R1)                 INSERT CHARACTER
         CLI   0(R1),C'0'               NUMERIC ?
         BNL   *+8                      YES, NO CONVERT NEEDED
         LA    R6,X'39'(R6)             CONVERT TO HEX
         STC   R6,0(R3)                 TO OUTPUT LOCATION
         LA    R1,1(R1)                 NEXT INPUT CHARACTER
         LA    R3,1(R3)                 NEXT OUTPUT CHARACTER
         BCT   R2,*+8                   DECREMENT COUNT
         B     GOTNUM                   HAVE THE NUMBER
         CLI   0(R1),C')'               END OF NUMBER ?
         BE    GOTNUM                   YES, HAVE THE NUMBER
         BCT   R0,NUMLOOP               GO AGAIN ?
         B     ERR2                     TELL USER OF PARM ERROR
         SPACE 1
GOTNUM   LA    R6,WRKWRDS+8+1           START+1 SUBTRACTED FROM
         SR    R3,R6                      END YIELDS EXECUTE LENGTH
         LA    R6,WRKWRDS+8(R3)         LAST CHARACTER IN NUMBER
         CLI   0(R6),C'.'+X'39'         DECIMAL ?
         BE    DECIMAL                  YES, EASY CONVERT
         SPACE 1
         EX    R3,PACK                  PACK THE HEX
         MVO   WRKWRDS+8(5),WRKWRDS+3(5) ALIGN THIS GARBAGE
         L     R0,WRKWRDS+8             LOAD IT
         BR    R15                      RETURN TO CALLER
         SPACE 1
DECIMAL  BCTR  R3,0                     DROP THE '.'
         EX    R3,PACK                  PACK THE HEX
         CVB   R0,WRKWRDS               TO BINARY AND LOAD
         BR    R15                      RETURN TO CALLER
         SPACE 2
PACK     PACK  WRKWRDS(8),WRKWRDS+8(0)  << EXECUTED >>
         EJECT
         USING LIBWORK,R2               ADDRESSABILITY
         USING BLDLLIST,R5              ADDRESSABILITY
         SPACE 1
BLDLFIND LA    R5,BLDL#                 BLDL LIST AREA
         SPACE 1
         MVI   BLDLCNT+1,1              NUMBER OF BLDL ENTRIES
         MVI   BLDLLEN+1,64             LENGTH OF EACH ENTRY
         MVC   BLDLNAME,NAME#           MOVE IN NAME
         SPACE 1
         BLDL  I#,(R5)                  DO THE BLDL
         BXH   R15,R15,0(R3)            ERROR, TAKE EXIT
         SPACE 1
         CLI   BLDLLIB,0                IN SPECIFIED LIBRARY ?
         BNER  R3                       NO, TAKE EXIT
         TM    BLDLIND1,B'00011000'     ENTRY LONG ENOUGH ?
         BZR   R3                       NO, TAKE EXIT
         TM    BLDLATR1,BLDLOVLY        INVALID ATTRIBUTE ?
         BNZR  R3                       YES, TAKE EXIT
         SPACE 1
         L     R15,BLDLSIZE             LOAD SIZE OF MODULE (OFFSET 8)
         SRL   R15,8                    SHIFT TO LOW THREE BYTES
         ST    R15,LENGTH#              SAVE GETMAIN LENGTH
         ST    R15,COMPLEN#               AND AS COMPARE LENGTH
         C     R15,NUMBER#              OFFSET OUTSIDE NUMBER ?
         BH    *+10                     NO, SKIP NEXT
         XC    NUMBER#,NUMBER#          IGNORE NUMBER
         SPACE 1
         GETMAIN EC,A=ADDRESS#,LV=(R15),SP=0,MF=(E,WRKWRDS) BUY IT
         BXH   R15,R15,ERR5             EXIT IF ERROR
         SPACE 1
         MVC   COMPADR#,ADDRESS#        SAVE AS COMPARE ADDRESS
         SPACE 2
         FIND  I#,BLDLTTRC,C            PREPARE TO READ MODULE
         SPACE 1
         BR    R4                       RETURN
         EJECT
CLEAREAD LA    R5,BLDL#                 BLDL LIST AREA
         SPACE 1
         L     R1,LENGTH#               LOAD LENGTH
         L     R3,ADDRESS#              WHERE TO CLEAR CORE
         SPACE 1
         LA    R0,256                   USEFUL CONSTANT
         SPACE 1
CLEARLP  CR    R1,R0                    MORE THAN ONE XC ?
         BNH   CLEARLST                 NO, GO DO LAST XC
         XC    0(256,R3),0(R3)          CLEAR A PORTION
         SR    R1,R0                    LESS AMOUNT DONE
         AR    R3,R0                    NEXT OUTPUT
         B     CLEARLP                  GO AGAIN
         SPACE 1
XC       XC    0(0,R3),0(R3)            << EXECUTED >>
         SPACE 1
CLEARLST LTR   R1,R1                    ANYTHING AT ALL TO CLEAR ?
         BNP   CLEARDN                  NO, ALL DONE
         BCTR  R1,0                     -1 FOR EXECUTE
         EX    R1,XC                    CLEAR LAST PORTION
         SPACE 2
CLEARDN  L     R3,ADDRESS#              START OF TEXT BUFFER
         LR    R6,R3                    TEXT BUFFER ADDRESS
         L     R7,LENGTH#                 AND LENGTH FOR 'FIRST' READ
         SPACE 1
         OC    BLDLTTRN(3),BLDLTTRN     ANY NOTE LIST ?
         BZ    *+8                      NO, SKIP NEXT
         OI    BLDL#,X'F0'              MARK NOTE LIST
         SPACE 1
         CLC   BLDLTTRC(3),BLDLTTRT     IS FIRST RECORD TEXT ?
         BE    READTEXT                 YES, NO CONTROL RECORD
         SPACE 2
NEXTRCRD READ  DECB,SF,I#,RECORD,256,MF=E READ A RECORD
         CHECK DECB                     WAIT FOR COMPLETION
         EJECT
         TM    BLDL#,X'F0'              HAVE NOTE LIST ?
         BNO   RCRDTYPE                 NO, SKIP NOTE LIST CHECK
         SPACE 1
         NOTE  I#                       FIND TTR OF LAST BLOCK
         ST    R1,WRKWRDS               STORE TTRZ
         CLC   BLDLTTRN(3),WRKWRDS      THIS THE NOTE LIST ?
         BE    NEXTRCRD                 YES, SKIP IT
         SPACE 2
RCRDTYPE XR    R1,R1                    CLEAR FOR INSERT
         IC    R1,RECORD                INSERT RECORD TYPE
         IC    R1,TRTTABLE(R1)          DETERMINE ACTION
         B     *(R1)                    GO TO IT
         B     NEXTRCRD   04            IGNORE THE RECORD
         B     DOCESD     08            PROCESS CESD
         B     DOCNTRL    0C            PROCESS CONTROL RECORD
*        B     DORLD      10            PROCESS RLD OR CRLD
         SPACE 2
DORLD    LH    R1,RECORD+6              GET AMOUNT OF DATA
         LA    R6,RECORD+16             POINT TO R & P
         SH    R1,=H'4'                 DECREMENT COUNT
         LA    R7,RECORD+20             POINT TO F & A
         SPACE 1
RLDLOOP  TM    0(R7),B'01100000'        DON'T RELOCATE ?
         BNZ   NEXTRLD                  TRUE, SKIP IT
         SPACE 1
         LH    R8,0(R6)                 ESD ID OF EXTERNAL REFERENCE
         BCTR  R8,0                     ORIGIN ZERO
         MH    R8,=AL2(LTABCESD)        TIMES ENTRY LENGTH
         LA    R8,CESDTAB(R8)           THE REFERENCED ENTRY
         SPACE 1
         L     R14,TABCOMM-TABCESD(R8)  LOAD COMMON ADDRESS
         S     R14,TABADDR-TABCESD(R8)  LESS OFFSET IN CESD
         TM    0(R7),B'00000010'        NEGATIVE RELOCATION ?
         BNO   *+6                      NO, SKIP NEXT
         LCR   R14,R14                  ADJUST FOR NEGATIVE RELOCATION
         SPACE 1
         L     R15,0(R7)                OFFSET OF RELOCATABLE REFERENCE
         LA    R15,0(R3,R15)            NOW HAVE THE ADDRESS
         SPACE 1
         IC    R8,0(R7)                 GET FLAGS
         N     R8,=F'12'                ONLY WANT LENGTH INDICATION
         B     *(R8)                    GO RELOCATE ACCORDING TO LENGTH
         B     RLDLEN2                  LENGTH IS TWO
         B     RLDLEN3                  LENGTH IS THREE
*        B     RLDLEN4                  LENGTH IS FOUR
         EJECT
RLDLEN4  MVC   WRKWRDS(4),0(R15)        ALIGN IT
         AL    R14,WRKWRDS              RELOCATE
         ST    R14,WRKWRDS+4            STORE FOR MOVE
         MVC   0(4,R15),WRKWRDS+4       PUT IT BACK
         B     NEXTRLD                  GO DO NEXT ENTRY
         SPACE 1
RLDLEN3  MVC   WRKWRDS(3),0(R15)        ALIGN IT
         L     R8,WRKWRDS                 AND LOAD IT
         SRA   R8,8                         AND SHIFT IT
         ALR   R14,R8                   RELOCATE
         ST    R14,WRKWRDS+4            STORE FOR MOVE
         MVC   0(3,R15),WRKWRDS+5       PUT IT BACK
         B     NEXTRLD                  GO DO NEXT ENTRY
         SPACE 1
RLDLEN2  MVC   WRKWRDS(2),0(R15)        ALIGN IT
         LH    R8,WRKWRDS                 AND LOAD IT
         ALR   R14,R8                   RELOCATE
         STH   R14,WRKWRDS+4            STORE FOR MOVE
         MVC   0(2,R15),WRKWRDS+4       PUT IT BACK
         SPACE 1
NEXTRLD  TM    0(R7),B'00000001'        USE SAME R & P ?
         BO    *+14                     YES
         LA    R6,4(R7)                 NEXT R & P
         SH    R1,=H'4'                 ADJUST LENGTH
         LR    R7,R6                    PRETEND IT WAS LAST F & A
         SPACE 1
         LA    R7,4(R7)                 NEXT F & A
         SH    R1,=H'4'                 ADJUST LENGTH
         BP    RLDLOOP                  MORE TO DO
         SPACE 2
         TM    RECORD,B'00000001'       RLD ALSO A CONTROL RECORD ?
         BO    DOCNTRL                  YES, GO READ TEXT
         TM    RECORD,B'00001000'       LAST RLD RECORD ?
         BZ    NEXTRCRD                 NO, GO READ NEXT
         SPACE 2
EOM      TM    BLDL#,X'0F'              LABEL FOUND ?
         BOR   R4                       YES, RETURN
         MVI   LABEL#,C' '              CLEAR THE
         MVC   LABEL#+1(7),LABEL#         LABEL FIELD
         BR    R4                       RETURN
         EJECT
DOCNTRL  MVI   RECORD+8,0               CLEAR READ COMMAND FROM CCW
         LR    R6,R3                    COPY ADDRESS START
         A     R6,RECORD+8              ADD OFFSET TO DATA START
         LH    R7,RECORD+12+2             AND LOAD RECORD LENGTH
         SPACE 1
READTEXT READ  DECB,SF,I#,(R6),(R7),MF=E READ A TEXT RECORD
         CHECK DECB                     WAIT FOR COMPLETION
         SPACE 1
         B     NEXTRCRD                 GO READ NEXT RECORD
         SPACE 2
DOCESD   IC    R1,RECORD+7              LOAD LENGTH OF ESD ENTRIES
         SRL   R1,4                     DIVIDE BY LENGTH TO GET COUNT
         LH    R6,RECORD+4              LOAD FIRST ESD ID
         BCTR  R6,0                     ORIGIN ZERO
         MH    R6,=AL2(LTABCESD)        TIMES ENTRY LENGTH
         LA    R6,CESDTAB(R6)           NEXT AVAILABLE ENTRY
         USING TABCESD,R6               ADDRESSABILITY
         LA    R7,RECORD+8              START OF FIRST ENTRY
         USING CESDENT,R7               ADDRESSABILITY
         SPACE 1
CESDLOOP XC    TABNAME(LTABCESD),TABNAME CLEAR THE ENTRY
         TM    CESDTYPE,B'01011100'     UNWANTED TYPE ?             005
         BNZ   CESDBCT                  YES, ON TO NEXT ENTRY
         TM    CESDTYPE,B'00000011'     IS IT EXTERNAL REFERENCE ?
         BNM   CESDLRSD                 NO, SKIP SETTING FLAG
         OI    FLAG,X'F0'               MARK EXTERNAL REFERENCE FOUND
         SPACE 1
CESDLRSD MVC   TABNAME(TABCOMM-TABNAME),CESDNAME COPY NAME AND OFFSET
         MVI   TABADDR,0                CLEAR FIRST OFFSET BYTE
         L     R8,FRSTTAB               FIND FIRST ENTRY
         LTR   R8,R8                    VERY FIRST CALL ?
         BNZ   NOTFIRST                 NO, CONTINUE
         SPACE 1
         L     R8,=A(STABCESD*LTABCESD) LENGTH OF CESD TABLE
         LA    R8,CESDTAB(R8)           END OF TABLE
         ST    R8,FRSTTAB               FIRST ENTRY OF COMMON TABLE
         B     ADDCOMM                  GO ADD FIRST COMMON ENTRY
         EJECT
NOTFIRST LA    R14,8                    BXLE INCREMENT
         L     R15,NEXTTAB              LAST USED ENTRY
         SPACE 1
COMMLOOP CLC   TABNAME,0(R8)            ALREADY IN TABLE ?
         BE    CESDCHCK                 YES, NO NEED TO ADD AGAIN
         BXLE  R8,R14,COMMLOOP          KEEP LOOKING
         SPACE 1
ADDCOMM  MVC   0(8,R8),TABNAME          ADD THE NEW ENTRY
         ST    R8,NEXTTAB                 AND AS LAST USED
         SPACE 2
CESDCHCK ST    R8,TABCOMM               SAVE ADDRESS FOR RELOCATION
         SPACE 1
         CLC   LABEL#,CESDNAME          HAVE A CANDIDATE ?
         BNE   CESDBCT                  NO, ON TO NEXT ENTRY
         L     R8,TABADDR               SAVE OFFSET
         TM    CESDTYPE,B'00000011'     CSECT, ENTRY, OR EXTERNAL ?
         BM    CESDBCT                  SKIP IF EXTERNAL REFERENCE
         BO    ENTRY                    IT'S AN 'ENTRY' (LR) ENTRY
         SPACE 1
         A     R8,COMPADR#              ADD ADDRESS OF COMPARE
         ST    R8,COMPADR#              SAVE NEW COMPARE START
         MVC   COMPLEN#+1(3),CESDLEN+1    AND SAVE NEW COMPARE LENGTH
         CLC   COMPLEN#,NUMBER#         OFFSET OUTSIDE CSECT ?
         BH    CESDOI                   NO, GO INDICATE LABEL FOUND
         XC    NUMBER#,NUMBER#          IGNORE NUMBER
         B     CESDOI                   GO INDICATE LABEL FOUND
         SPACE 1
ENTRY    L     R14,NUMBER#              LOAD NUMBER OFFSET
         AR    R14,R8                   COMBINED OFFSET
         C     R14,COMPLEN#             OUTSIDE MODULE ?
         BNH   *+6                      NO, SKIP NEXT
         LR    R14,R8                   IGNORE NUMBER, USE ENTRY
         ST    R14,NUMBER#              STORE OFFSET
         SPACE 1
CESDOI   OI    BLDL#,X'0F'              MARK LABEL FOUND
         SPACE 1
CESDBCT  LA    R6,LTABCESD(R6)          NEXT ENTRY
         L     R8,=A(STABCESD*LTABCESD) LENGTH OF CESD TABLE
         LA    R8,CESDTAB(R8)           END OF TABLE
         CR    R6,R8                    OVERRUN ?
         BNL   ERR6                     YES, CAN'T CONTINUE
         LA    R7,LCESDENT(R7)          NEXT ENTRY
         BCT   R1,CESDLOOP              GO CHECK IT
         B     NEXTRCRD                 GO READ NEXT RECORD
         SPACE 1
         DROP  R2,R5,R6,R7
         EJECT
OUTPUT   LTR   R2,R2                    FIRST CALL ?
         BNZ   OUTCONT                  YES, CONTINUE
         SPACE 1
         MVC   RECORD(256),OUTREC1      MOVE IN HEADER DATA
         MVC   RECORD+256(LOUTREC1-256),OUTREC1+256 AND THE REST
         LA    R2,RECORD                ADDRESS OF OUTPUT AREA
         USING OUTREC1,R2               ADDRESSABILITY
         SPACE 1
         MVC   REC1T+D1I1(8),NAME1      MOVE IN
         MVC   REC1T+D1I2(8),NAME2        MEMBER NAMES
         UNPK  WRKWRDS(9),LENGTH1(5)    UNPK THE LENGTH
         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES
         MVC   REC2T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD
         UNPK  WRKWRDS(9),LENGTH2(5)    UNPK THE LENGTH
         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES
         MVC   REC2T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD
         MVC   REC3T+D1I1(8),LABEL1     MOVE IN
         MVC   REC3T+D1I2(8),LABEL2       LABEL  NAMES
         TM    BLDL1,X'0F'              LABEL FOUND ?
         BNO   *+14                     NO, CLEAR THE (C)
         CLC   LENGTH1,COMPLEN1         WAS IT A CSECT ?
         BNE   *+10                     YES, SKIP THE CLEAR
         MVC   REC3T+D1I1+8(3),=C'   '  CLEAR THE 'C'
         TM    BLDL2,X'0F'              LABEL FOUND ?
         BNO   *+14                     NO, CLEAR THE (C)
         CLC   LENGTH2,COMPLEN2         WAS IT A CSECT ?
         BNE   *+10                     YES, SKIP THE CLEAR
         MVC   REC3T+D1I2+8(3),=C'   '  CLEAR THE 'C'
         UNPK  WRKWRDS(9),COMPLEN1(5)   UNPK THE COMPARE LENGTH
         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES
         MVC   REC6T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD
         UNPK  WRKWRDS(9),COMPLEN2(5)   UNPK THE COMPARE LENGTH
         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES
         MVC   REC6T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD
         UNPK  WRKWRDS(9),NUMBER1(5)    UNPK THE OFFSET
         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES
         MVC   REC4T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD
         UNPK  WRKWRDS(9),NUMBER2(5)    UNPK THE OFFSET
         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES
         MVC   REC4T+D1I2(8),WRKWRDS    MOVE TO OUTPUT RECORD
         UNPK  WRKWRDS(9),COUNT(5)      UNPK THE COUNT
         TR    WRKWRDS(8),TRTABLE-C'0'  TO PRINTABLES
         MVC   REC7T+D1I1(8),WRKWRDS    MOVE TO OUTPUT RECORD
         SPACE 1
         TM    FLAG,X'F0'               ANY UNRESOLVED REFERENCES ?
         BO    OUTCONT                  YES, MESSAGE IS COMPLETE
         MVI   REC5T-1,C'0'             CHANGE TO DOUBLE SPACE
         SPACE 1
         DROP  R2
         SPACE 1
         MVC   RECORD(2),=AL2(LOUTRECA) REDUCE RECORD LENGTH
         EJECT
OUTCONT  LTR   R4,R4                    WHAT IS WANTED ?
         BP    OUTUNEQ                  ADD 'UNLIKE' OUTPUT LINE
         BZ    OUTDIFF                  ADD 'LONGER' OUTPUT LINE
*        BM    OUTBUFF                  DUMP THE BUFFER
         SPACE 1
OUTBUFF  CLC   =H'4',RECORD             NULL BUFFER ?
         BER   R3                       YES RETURN
         SPACE 1
         WRITE DECB,SF,SNAP,(R2),'S',MF=E WRITE THE OUTPUT RECORD
         CHECK DECB                     WAIT FOR COMPLETION
         SPACE 1
         MVC   RECORD(2),=H'4'          RESET BLOCK LENGTH
         B     OUTCONT                  TRY AGAIN
         SPACE 2
OUTDIFF  LH    R1,RECORD                FIND CURRENT LENGTH
         LR    R0,R1                      AND COPY IT
         AH    R0,CEND                  ADD LENGTH OF NEXT RECORD
         CH    R0,SNAP+DCBBLKSI-IHADCB  TOO LONG ?
         BH    OUTBUFF                  YES, GO DUMP CURRENT RECORD
         SPACE 1
         STH   R0,RECORD                SAVE NEW RECORD LENGTH
         AR    R1,R2                    ADD BUFFER START
         MVC   0(LCEND,R1),CEND         MOVE IN RECORD
         LTR   R7,R7                    IS FIRST MODULE EXHAUSTED ?
         BNZ   *+10                     NO, SKIP NEXT
         MVI   D3DDN(R1),C'2'           CHANGE 'I1' TO 'I2'
         LR    R7,R8                    COPY EXCESS LENGTH
         ST    R7,WRKWRDS+8             STORE IT
         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE LENGTH
         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES
         MVC   D3LEN(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD
         SPACE 1
         BR    R3                       RETURN
         SPACE 2
OUTUNEQ  LH    R1,RECORD                FIND CURRENT LENGTH
         LR    R0,R1                      AND COPY IT
         AH    R0,CREC                  ADD LENGTH OF NEXT RECORD
         CH    R0,SNAP+DCBBLKSI-IHADCB  TOO LONG ?
         BH    OUTBUFF                  YES, GO DUMP CURRENT RECORD
         EJECT
         STH   R0,RECORD                SAVE NEW RECORD LENGTH
         AR    R1,R2                    ADD BUFFER START
         MVC   0(LCREC,R1),CREC         MOVE IN RECORD
         MVC   12(1,R13),0(R5)          MOVE BYTE TO A WORKAREA     004
         UNPK  WRKWRDS(3),12(2,R13)     UNPK THE BYTE+GARBAGE BYTE  004
         TR    WRKWRDS(2),TRTABLE-C'0'  TO PRINTABLES
         MVC   D2I1B(2,R1),WRKWRDS      MOVE TO OUTPUT RECORD
         MVC   12(1,R13),0(R6)          MOVE BYTE TO A WORKAREA     004
         UNPK  WRKWRDS(3),12(2,R13)     UNPK THE BYTE+GARBAGE BYTE  004
         TR    WRKWRDS(2),TRTABLE-C'0'  TO PRINTABLES
         MVC   D2I2B(2,R1),WRKWRDS      MOVE TO OUTPUT RECORD
         ST    R5,WRKWRDS+12            STORE COMPARE ADDRESS
         LR    R0,R5                    COPY BYTE ADDRESS
         S     R0,COMPADR1              LESS COMPARE START
         ST    R0,WRKWRDS+8             STORE COMPARE OFFSET
         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE OFFSET
         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES
         MVC   D2I1A(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD
*001     UNPK  WRKWRDS(7),WRKWRDS+13(4) UNPK THE ADDRESS
*001     TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES
*001     MVC   D2I1A+8(6,R1),WRKWRDS    MOVE TO OUTPUT RECORD
         ST    R6,WRKWRDS+12            STORE COMPARE ADDRESS
         LR    R0,R6                    COPY BYTE ADDRESS
         S     R0,COMPADR2              LESS COMPARE START
         ST    R0,WRKWRDS+8             STORE COMPARE OFFSET
         UNPK  WRKWRDS(7),WRKWRDS+9(4)  UNPK THE OFFSET
         TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES
         MVC   D2I2A(6,R1),WRKWRDS      MOVE TO OUTPUT RECORD
*001     UNPK  WRKWRDS(7),WRKWRDS+13(4) UNPK THE ADDRESS
*001     TR    WRKWRDS(6),TRTABLE-C'0'  TO PRINTABLES
*001     MVC   D2I2A+8(6,R1),WRKWRDS    MOVE TO OUTPUT RECORD
         SPACE 1
         BR    R3                       RETURN TO CALLER
         SPACE 4
         PRINT NOGEN
TRTTABLE DC    256X'04'                 IGNORE EVERYTHING
         SPACE 1
         RCRD  80,04                    IDR      - IGNORE
         RCRD  40,04                    SYM      - IGNORE
         RCRD  20,08                    CESD     - PROCESS
         RCRD  10,04                    SC/TR    - IGNORE
         RCRD  01,0C                    CNTRL    - PROCESS
         RCRD  05,04                    CNT-EOS  - IGNORE
         RCRD  0D,0C                    CNT-EOM  - PROCESS
         RCRD  02,10                    RLD      - PROCESS
         RCRD  06,04                    RLD-EOS  - IGNORE
         RCRD  0E,10                    RLD-EOM  - PROCESS
         RCRD  03,10                    CRLD     - PROCESS
         RCRD  07,04                    CRLD-EOS - IGNORE
         RCRD  0F,10                    CRLD-EOM - PROCESS
         EJECT
TRTABLE  DC    C'0123456789ABCDEF'      GUESS WHAT THIS IS FOR
         SPACE 3
D1I1     EQU   9                        RECORD 1 DATA
D1I2     EQU   21
         SPACE 1
OUTREC1  DC    AL2(LOUTREC1,0)          NOTE ALIGNMENT
REC1     DC    AL2(LREC1,0),C'1'
REC1T    DC    C'MODULES: NNNNNNNN-I1 MMMMMMMM-I2'
LREC1    EQU   *-REC1
REC2     DC    AL2(LREC2,0),C' '
REC2T    DC    C'LENGTH:  HHHHHHHH    HHHHHHHH  (OF MODULES)'
LREC2    EQU   *-REC2
REC3     DC    AL2(LREC3,0),C' '
REC3T    DC    C'LABEL:   11111111(C) 22222222(C)'
LREC3    EQU   *-REC3
REC6     DC    AL2(LREC6,0),C' '
REC6T    DC    C'COMPLEN: HHHHHHHH    HHHHHHHH  (BASIC COMPARE LENGTH)'
LREC6    EQU   *-REC6
REC4     DC    AL2(LREC4,0),C' '
REC4T    DC    C'OFFSET:  HHHHHHHH    HHHHHHHH  (IN MODULE OR CSECT)'
LREC4    EQU   *-REC4
REC7     DC    AL2(LREC7,0),C' '
REC7T    DC    C'COUNT:   HHHHHHHH  (FORCED COMPARE LENGTH)'
LREC7    EQU   *-REC7
REC5     DC    AL2(LREC5,0),C' '
REC5T    DC    C' '
LREC5    EQU   *-REC5
LOUTRECA EQU   *-OUTREC1
REC8     DC    AL2(LREC8,0),C' '
REC8T    DC    C'NOTE: SOME UNRESOLVED EXTERNAL REFERENCES RESOLVED'
LREC8    EQU   *-REC8
REC9     DC    AL2(LREC9,0),C'0'
REC9T    DC    C' '
LREC9    EQU   *-REC9
LOUTREC1 EQU   *-OUTREC1
         DC    (LOUTREC1-2*(LOUTREC1/2))AL1(0) ALIGNMENT
         SPACE 1
ERROR1   EQU   SNAPBLKS-LOUTREC1        ERROR IF TOO SMALL
         SPACE 2
D2I1A    EQU   5+4                      RECORD 2 DATA
D2I1B    EQU   5+11                     WAS 5+20                    001
D2I2B    EQU   5+21                     WAS 5+30                    001
D2I2A    EQU   5+28                     WAS 5+37                    001
         SPACE 1
CREC     DC    AL2(LCREC,0),C' '
CRECT    DC    C'AT +HHHHHH XX UNLIKE XX AT +HHHHHH'
*001 CRECT DC  C'AT +HHHHHH (HHHHHH) XX UNLIKE XX AT +HHHHHH (HHHHHH)'
LCREC    EQU   *-CREC
         DC    (LCREC-2*(LCREC/2))AL1(0) ALIGNMENT
         EJECT
D3DDN    EQU   5+11                     RECORD 3 DATA
D3LEN    EQU   5+23
         SPACE 1
CEND     DC    AL2(LCEND,0),C'0'
CENDT    DC    C'MODULE IN I1 LONGER BY HHHHHH BYTES'
LCEND    EQU   *-CEND
         SPACE 4
DCBPSQ   DCB   BLKSIZE=400,DDNAME=WTO,DSORG=PS,LRECL=125,              X
               BUFNO=1,MACRF=PM,RECFM=VB
DCBPSQX  EQU   *-DCBPSQ
         SPACE 1
DCBPS    DCB   BLKSIZE=SNAPBLKS,DDNAME=SNAP,DSORG=PS,LRECL=125,        *
               MACRF=W,RECFM=VBA
DCBPSX   EQU   *-DCBPS                  LENGTH OF DCB
         SPACE 1
DCBPO    DCB   DDNAME=I1,DSORG=PO,EODAD=EOM,MACRF=R
DCBPOX   EQU   *-DCBPO                  LENGTH OF DCB
         SPACE 1
         READ  DECBRW,SF,MF=L
DECBX    EQU   *-DECBRW                 LENGTH OF DECB
         SPACE 2
         LTORG
         EJECT ,
*   SUP - CHECK IF MODULE CONTAINS TTRL'S OF OTHER MODULES,
*         IF SO, SET THEM ALL TO C'TTRL'
*     AT ENTRY R1 = @ NAME IN WORK OF MODULE TO TEST
*
         SPACE 1
SUP      STM   R0,R15,SAVE2             SAVE REGS
         LR    R9,R15                   GET BASE REG
         USING SUP,R9
         LR    R8,R1                    SAVE @ MODULE NAME ETC
         LA    R7,SUP#TB8               SEE IF 1ST LOAD WITH TTRL'S
         BAL   R14,SUP$SCN              GO SCAN TABLE
         B     SUP$FND1                 BRANCH IF FOUND IN TABLE
         LA    R7,SUP#TB6               SEE IF LATER LOAD
         BAL   R14,SUP$SCN              GO SCAN TABLE
         B     SUP$FND2
SUP$EXIT LM    R0,R15,SAVE2             RESTORE REGS
         BR    R14                      AND RETURN
         SPACE 1
SUP$FND2 TM    NAME1-NAME1+6(R8),X'F0'  NUMERIC 7TH CHAR?
         BNO   SUP$EXIT                 NO TTRL'S IF NOT
SUP$FND1 L     R1,ADDRESS1-NAME1(,R8)   GET BEGIN ADDR
         L     R2,LENGTH1-NAME1(,R8)    GET LENGTH
         CL    R2,=F'1024'              > 1024 LONG?
         BH    SUP$EXIT                 YES, NO TTRL'S
         LA    R3,0(R2,R1)              @ PAST END OF MODULE
         SH    R3,=H'4'                 BACK UP 4 BYTES
         SR    R4,R4                    CLEAR FOR IC
         IC    R4,3(,R3)                GET OFFSET/8 OF TTRL TABLE
         SLA   R4,3                     GET REAL OFFSET
         BZ    SUP$EXIT                 I WON'T BUY OFFSET 0
         ALR   R1,R4                    POINT TO TTRL TABLE
         SPACE 1
SUP$LOOP CR    R1,R3                    PAST END OF MODULE?
         BNL   SUP$EXIT                 BRANCH IF PAST
         OC    0(2,R1),0(R1)            END OF TABLE?
         BZ    SUP$EXIT                 DONE IF SO
         CLC   0(2,R1),=X'FFFF'         SUBLIST DELIMITER?          002
         BE    SUP$FF                   YES - SKIP PAST IT          002
         MVC   2(4,R1),=C'TTRL'         FIX UP TTRL
         LA    R1,6(,R1)                TO NEXT ENTRY
         B     SUP$LOOP
         SPACE 1
SUP$FF   LA    R1,2(,R1)                SKIP PAST SUBLIST DELIMITER 002
         B     SUP$LOOP                 AND GO CHECK FOR END        002
         SPACE 1
SUP$SCN  LH    R0,0(,R7)                GET NUMBER OF ENTRIES IN TABLE
         LH    R15,2(,R7)               GET LEN-1 OF EACH ENTRY
SUP$SCNL EX    R15,SUP$SCNC             CLC 4(0,R7),NAME1-NAME1(R8)
         BER   R14                      RETURN IF FOUND
         LA    R7,1(R15,R7)             TO NEXT ENTRY
         BCT   R0,SUP$SCNL              SCAN ALL ENTRIES
         B     4(,R14)                  RETURN NOT FOUND
SUP$SCNC CLC   4(0,R7),NAME1-NAME1(R8)  * EXECUTED *
         SPACE 1
SUP#TB8  DC    Y((SUP#TB8L-4)/8)        NUMBER OF ENTRIES
         DC    Y(7)                     LENGTH -1 OF EACH ENTRY
         DC    CL8'IGC0001I'            OPEN
         DC    CL7'IGC0002',X'C0'       CLOSE
         DC    CL8'IGC0002A'            STOW
         DC    CL8'IGC0002B'            OPENJ
         DC    CL8'IGC0002C'            TCLOSE
         DC    CL8'IGC0002I'            SCRATCH
         DC    CL8'IGC0003A'            FEOV
         DC    CL8'IGC0003B'            ALLOCATE
         DC    CL8'IGC0005E'            EOV
         DC    CL8'IGC0008A'            SETPRT
         DC    CL8'IGC0008F'            ATLAS
         DC    CL8'IGC0009C'            TSO
         DC    CL8'IGC0009D'            TSO
SUP#TB8L EQU   *-SUP#TB8                LENGTH OF TABLE
         SPACE 1
SUP#TB6  DC    Y((SUP#TB6L-4)/6)        NUMBER OF ENTRIES
         DC    Y(5)                     LENGTH OF ENTRY -1
         DC    CL6'IFG019'              OPEN
         DC    CL6'IFG020'              CLOSE
         DC    CL6'IFG023'              TCLOSE
         DC    CL6'IFG055'              EOV
         DC    CL6'IFGASR'              ASR MODULE NAMES
         DC    CL6'IGG019'              OPEN
         DC    CL6'IGG020'              CLOSE
         DC    CL6'IGG021'              STOW
         DC    CL6'IGG023'              TCLOSE
         DC    CL6'IGG029'              SCRATCH
         DC    CL6'IGG032'              ALLOCATE
         DC    CL6'IGG055'              EOV
         DC    CL6'IGG081'              SETPRT
         DC    CL6'IGG086'              ATLAS
         DC    CL6'IGG093'              TSO
         DC    CL6'IGG094'              TSO
SUP#TB6L EQU   *-SUP#TB6                LENGTH OF TABLE
         SPACE 1
         DROP  R9
         EJECT ,
*   SNAPIT: SNAP ROUTINE
*     R1 = @ (@ BEGIN, @ END)
*
         SPACE 1
SNAPIT   TM    FLAGS,FG#NSNAP           DON'T DO SNAP?              001
         BOR   R14                      YES - RETURN TO CALLER      001
         SPACE 2
         STM   R0,R15,SAVE2             SAVE REGS
         LR    R9,R15                   LOCAL BASE
         USING SNAPIT,R9
         LM    R2,R3,0(R1)              GET @ BEGIN, @ END
         LA    R4,4                     CONSTANT
         SR    R5,R5                    START AT OFFSET 0
         SPACE 1
SN$LOOP1 MVC   LINERDW(5),SN#RDW        INIT RDW, CTL CHAR (' ')
         MVC   LINE+1(L'LINE-1),LINE    BLANK REST OF LINE
         LTR   R5,R5                    1ST LINE?
         BNZ   *+8                      BRANCH IF NOT
         MVI   LINE,C'1'                NEW PAGE ON FIRST
         ST    R5,SN#WRK                OFFSET TO HEX
         UNPK  LINE+1(7),SN#WRK+1(4)
         TR    LINE+1(6),TRTABLE-C'0'
         MVI   LINE+1+6,C' '
         LA    R0,2                     DO TWO SETS OF 16 BYTES
         LA    R7,LINE+1+6+1            @ OF FIRST WORD OF HEX
         LA    R8,LINE+L'LINE-32-1      @ OF FIRST WORD OF CHAR
         SPACE 1
SN$LOOP2 MVC   0(3,R7),=CL3' '          ADD SOME BLANKS
         LA    R7,3(,R7)
         LR    R6,R4                    AND 4 SETS OF 4 IN EACH 16
         SPACE 1
SN$LOOP3 UNPK  0(9,R7),0(5,R2)          SET 4 BYTES HEX
         TR    0(8,R7),TRTABLE-C'0'
         MVI   8(R7),C' '               FIX GARBAGE BYTE
         MVC   0(4,R8),0(R2)            MOVE IN CHAR STUFF
         AR    R2,R4                    BUMP INPUT PTR
         LA    R7,9(,R7)                BUMP HEX OUTPUT PTR
         AR    R8,R4                    BUMP CHAR OUTPUT PTR
         AR    R5,R4                    BUMP OFFSET TOO
         CR    R2,R3                    NEXT WORD TO BE DUMPED?
         BNL   SN$DONE                  NO, PRINT, DONE
         BCT   R6,SN$LOOP3              DO 16 BYTES
         BCT   R0,SN$LOOP2              DO ABOVE TWICE
         SPACE 1
         BAL   R8,SN$PUT                PRINT LINE
         B     SN$LOOP1
         SPACE 1
SN$DONE  BAL   R8,SN$PUT                PRINT LAST LINE
         LM    R0,R15,SAVE2             RESTORE REGS
         BR    R14                      AND RETURN
         SPACE 1
SN$PUT   MVI   LINE+L'LINE-1,C'*'       STARS AROUND CHAR PART
         MVI   LINE+L'LINE-1-32-1,C'*'
         TR    LINE+L'LINE-1-32(32),SN#TR  CHANGE GARBAGE TO '.'
         LH    R1,RECORD                CURRENT RECORD LENGTH
         LR    R0,R1                    COPY IT
         AH    R0,LINERDW               ADD IN LENGTH OF NEW LINE
         CH    R0,SNAP+DCBBLKSI-IHADCB  OVER BLKSIZE?
         BNH   SN$FITS                  BRANCH IF NOT
         LA    R15,RECORD               @ RECORD TO WRITE
         PRINT GEN
         WRITE DECB,SF,SNAP,(R15),'S',MF=E WRITE BLOCK
         CHECK DECB                     WAIT FOR I/O
         PRINT NOGEN
         LA    R1,4                     RE-SET RECORD RDW
SN$FITS  LA    R15,RECORD(R1)           GET @ TO PLACE LINE
         MVC   0(L'LINE+4,R15),LINERDW  PUT LINE IN OUTPUT BUFFER
         AH    R1,LINERDW               GET NEW OUTPUT LENGTH
         STH   R1,RECORD                SET NEW OUTPUT LENGTH
         BR    R8                       AND RETURN
         SPACE 1
SN#RDW   DC    Y(L'LINE+4,0),C' '
SN#TR    DC    256X'4B'
         ORG   SN#TR+C' '
         DC    C' '
         ORG   SN#TR+X'4A'
         DC    X'4A4B4C4D4E4F'
         ORG   SN#TR+X'5A'
         DC    X'5A5B5C5D5E5F'
         ORG   SN#TR+C','
         DC    C',%_>?'
         ORG   SN#TR+X'7A'
         DC    X'7A7B7C7D7E7F'
         ORG   SN#TR+C'A'
         DC    C'ABCDEFGHI'
         ORG   SN#TR+C'J'
         DC    C'JKLMNOPQR'
         ORG   SN#TR+C'S'
         DC    C'STUVWXYZ'
         ORG   SN#TR+C'0'
         DC    C'0123456789'
         ORG   ,
         SPACE 1
         DROP  R9
         EJECT ,
GETENT   STM   R0,R15,SAVE2             SAVE CALLERS REGS
         LR    R9,R15                   SET LOCAL BASE
         USING GETENT,R9
         L     R6,DIRLST                @ LAST DIR ENTRY
         LTR   R6,R6                    FIRST TIME?
         BZ    GE$FIRST                 YES, GO READ
         SR    R5,R5                    CLEAR FOR IC
         IC    R5,11(,R6)               GET LENGTH OF LAST ENTRY
         N     R5,=X'0000001F'          GET LENGTH IN H-WORDS
         LA    R5,12(R5,R5)             LENGTH IN BYTES
         AR    R6,R5                    @ NEXT ENTRY IF ANY
         LH    R1,DIRBUF                GET LENGTH OF DATA IN BLOCK
         LA    R1,DIRBUF(R1)            @ PAST LAST ENTRY
         CR    R6,R1                    IS THIS ENTRY OK?
         BL    GE$OK                    BRANCH IF OK
GE$FIRST MVI   DIRTTR+3,1               SET GET NEXT BLOCK
         POINT I1,DIRTTR                POINT THERE
         READ  DECB,SF,I1,DIRBUF,256,MF=E  READ NEXT DIR BLOCK
         CHECK DECB                     WAIT FOR IT
         NOTE  I1                       GET IT'S TTR
         ST    R1,DIRTTR                SAVE FOR NEXT TIME
         LA    R6,DIRBUF+2              GET @ 1ST ENTRY
GE$OK    CLC   0(8,R6),=8X'FF'          LAST ENTRY?
         BE    ALLDONE                  YES, JUST LEAVE
         ST    R6,DIRLST                ELSE SAVE ENTRY ADDR
         MVC   NAME1,0(R6)              SET 1ST NAME
         MVC   NAME2,0(R6)              AND 2ND NAME
         LM    R0,R15,SAVE2             RESTORE REGS
         BR    R14                      AND RETURN
         SPACE 2
         DROP  R9
         EJECT
***********************************************************************
*                                                                     *
* DO PRE-OPEN CHECKS HERE. CHECK IF OUTPUT FILE IS SYSPRINT AND NOT   *
* SNAP; FLAG NO SNAP DUMP IF YES. CHECK IF OUTPUT FILE IS ALLOCATED   *
* TO TSO AS TERMFILE. SET UP WRITE INTERCEPT IF YES AND FAKE OUT OPEN *
* DCB. GENERATE FINAL FORM OF OPEN LIST AND DO THE ACTUAL OPEN.       *
*                                                                     *
* INPUT: R1 - POINTER TO OPEN LIST.                                   *
*                                                                     *
***********************************************************************
         SPACE 2
         USING OPEN#CHK,R9              SET ADDRESSIBILITY          001
         PRINT GEN                                                  001
         SPACE 2
OPEN#CHK STM   R0,R15,SAVE2             SAVE CALLER'S REGS          001
         LR    R9,R15                   SET BASE REG                001
         TM    DCBLIST+8,X'80'          OPENING DCBWTO?             001
         BO    *+8                      NO - CONTINUE               001
         OI    FLAGS,FG#ALL             SAY PROCESS ALL MEMBERS     001
         SPACE 2
         L     R3,PSATOLD-PSA           CURRENT TCB                 003
         LA    R0,24                    FIRST TIOT INCREMENT        001
         XR    R2,R2                    CLEAR FLAG REG              001
         L     R15,12(,R3)              TIOT ADDR                   001
         BALR  R14,0                    LOOP RETURN ADDR            001
         SPACE 2
         ALR   R15,R0                   NEXT TIOT ENTRY             001
         IC    R0,0(,R15)               LENGTH/THIS ENTRY           001
         LTR   R0,R0                    END OF TIOT?                001
         BZ    OP#END#T                 YES - SEE IF SYSPRINT FOUND 001
         SPACE 2
         CLC   4(8,R15),=CL8'SYSPRINT'  DDNAME=SYSPRINT?            001
         BNE   OP#SNAP                  NO - GO CHECK SNAP DDNAME   001
         LR    R2,R15                   SAVE ENTRY ADDR AS FLAG     001
         BR    R14                      AND CHECK NEXT ENTRY        001
         SPACE 2
OP#SNAP  CLC   4(8,R15),SNAP+DCBDDNAM-IHADCB DDNAME=SNAP?           001
         BNER  R14                      NO - LOOP                   001
         ICM   R2,B'0111',17(R15)       UCB ADDR FOR BELOW          003
         SPACE 2
*  ----  HAVE SNAP OR SYSPRINT DD ENTRY HERE.                       001
         SPACE 2
OP#DD    L     R15,PSAAOLD-PSA          CURRENT ASCB                003
         ICM   R15,B'1111',ASCBTSB-ASCB(R15) RUNNING AS A TSO TASK? 003
         BZ    OP#RET                   NO - CAN'T BE TERMFILE      001
         LTR   R2,R2                    NO UCB ADDR(THUS TERMFILE)? 001
         BNZ   OP#RET                   NO - EXIT                   001
         SPACE 2
*  ----  HAVE TERMFILE HERE - INTERCEPT IT.                         001
         SPACE 2
         MVC   SNAP+DCBWRITE+1-IHADCB(3),=AL3(TPUT#TSO) TPUT CODE   001
         MVC   SNAP+DCBCHECK+1-IHADCB(3),=AL3(TPUT#END) TPUT CODE   001
         OI    SNAP+DCBOFLGS-IHADCB,DCBOFOPN TELL MAINLINE DCB OPEN 001
         MVC   DCBLIST(12),DCBLIST+4    SQUISH OUT SNAP DCB ADDR    001
         SPACE 2
OP#RET   OPEN  MF=(E,(1))               NOW FINALLY DO THE OPEN     001
         LM    R0,R15,SAVE2             RESTORE CALLER'S REGS       001
         BR    R14                      AND RETURN
         SPACE 2
*  ----  GET HERE WITH END OF TIOT/SNAP NOT FOUND - CHECK SYSPRINT. 001
         SPACE 2
OP#END#T LTR   R2,R2                    SYSPRINT ENTRY FOUND?       001
         BZ    OP#RET                   NO - LET MAINLINE DIAG. ERR 001
         SPACE 2
         OI    FLAGS,FG#NSNAP           SAY DON'T DO A SNAP         001
         MVC   SNAP+DCBDDNAM-IHADCB(8),=CL8'SYSPRINT' RESET DDNAME  001
         ICM   R2,B'0111',17(R2)        GET UCB ADDR/THIS FILE      003
         B     OP#DD                    NOW CHECK FOR TERMFILE      001
         SPACE 2
         DROP  R9                                                   001
         EJECT
*  ----  THIS CODE GAINS CONTROL VIA A WRITE DECB,SF,...            001
*  ----  INPUT R1-->XL4'ECB',XL2'FLAGS',AL2(LEN),A(DCB),A(BUF).     001
         SPACE 2
         USING TPUT#TSO,R5              ADDRESSIBILITY              001
         SPACE 2
TPUT#TSO STM   R14,R5,16(R13)           SAVE WORK REGS/NOTE OFFSET  001
         LR    R5,R15                   SET BASE REGISTER           001
         L     R3,12(,R1)               GET OUTPUT BUFFER ADDR      001
         MVC   12(2,R13),0(R3)          GET BLOCK LENGTH            001
         LA    R3,0(,R3)                INSURE HI BYTE CLEAR        001
         LH    R4,12(,R13)              GET LENGTH/THIS BLOCK       001
         LA    R2,4                     SET FIRST REC INCREMENT     001
         ALR   R4,R3                    GEN END CHECK ADDR          001
         B     TPUT#CHK                 AND GO CHECK FOR END        001
         SPACE 2
TPUT#LP  LH    R0,=H'-5'                BYTES IN REC WE SKIP        001
         AR    R0,R2                    GEN TPUT LENGTH             001
         LA    R1,5(,R3)                POINT TO START OF TEXT      001
         BNP   TPUT#CHK                 SKIP TPUT IF FUNNY          001
         TPUT  (1),(0),R                ELSE TPUT THE MSG TEXT      001
         SPACE 2
TPUT#CHK ALR   R3,R2                    POINT TO NEXT RECORD        001
         CLR   R3,R4                    STILL WITHIN REC?           001
         IC    R2,1(,R3)                GET LEN/THIS REC            001
         BL    TPUT#LP                  YES - CONTINUE TPUT'ING     001
         SPACE 2
         LM    R14,R5,16(R13)           RESTORE WORK REGS           001
TPUT#END BR    R14                      RETURN TO CALLER            001
         SPACE 2
         DROP  R5                                                   001
         PRINT NOGEN                                                001
         SPACE 2
         LTORG
         EJECT ,
CESDENT  DSECT
CESDNAME DS    CL8                      IDENTIFIER
CESDTYPE DS    X                        TYPE OF ESD ENTRY
CESDADR  DS    AL3                      OFFSET INTO MODULE
CESDLEN  DS    F                        CSECT LENGTH
LCESDENT EQU   *-CESDENT                LENGTH OF ENTRY
         SPACE 2
TABCESD  DSECT
TABNAME  DS    CL8                      CESD IDENTIFIER
TABADDR  DS    F                        OFFSET INTO MODULE
TABCOMM  DS    A                        ADDRESS OF COMMON LABEL
LTABCESD EQU   *-TABCESD                LENGTH OF ENTRY
         SPACE 2
         DCBD  DEVD=DA,DSORG=(PO,PS)
         IHAPSA ,                                                   003
         IHAASCB ,                                                  003
         EJECT
WORKAREA DSECT                          DYNAMIC STORAGE AREA
         DS    18F                      SAVEAREA
         SPACE 1
WRKWRDS  DS    4F                       DOUBLEWORD ALIGNED WORK AREA
DCBLIST  DS    4F                       OPEN/CLOSE PARM LIST
SAVE2    DS    16F                      SUBROUTINE SAVE AREA
SN#WRK   DS    F                        SNAP WORK AREA
RETCODE  DS    F                        PROGRAM RETURN CODE         004
FLAGS    DS    F                        FLAG AREA                   001
FG#NSNAP EQU   X'80'                    DON'T DO A PSEUDO-SNAP DUMP 001
FG#ALL   EQU   X'40'                    PROCESS ALL PDS MEMBERS     001
         SPACE 1
LINERDW  DS    2H                       RDW FOR LINE
LINE     DS    CL121                    PRINT LINE
         SPACE 1
COUNT    DS    A                        NUMBER OF BYTES TO COMPARE
         SPACE 1
DCBWTO   DCB   DDNAME=*,DSORG=PS,MACRF=PM
         SPACE 1
SNAP     DCB   DDNAME=*,DSORG=PS,MACRF=W
         SPACE 1
FRSTTAB  DS    F                        FIRST COMMON SYMBOL IN TABLE
NEXTTAB  DS    F                        NEXT COMMON SYMBOL IN TABLE
         SPACE 2
NAME1    DS    CL8                      FIRST MODULE NAME
LABEL1   DS    CL8                      LABEL IN MODULE
NUMBER1  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL
LENGTH1  DS    A                        LENGTH OF MODULE
ADDRESS1 DS    A                        ADDRESS OF MODULE
COMPLEN1 DS    A                        LENGTH OF COMPARE
COMPADR1 DS    A                        ADDRESS OF COMPARE
BLDL1    DS    17F                      BLDL LIST
         SPACE 1
I1       DCB   DDNAME=*,DSORG=PO,MACRF=R FIRST DCB
         SPACE 2
NAME2    DS    CL8                      SECOND MODULE NAME
LABEL2   DS    CL8                      LABEL IN MODULE
NUMBER2  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL
LENGTH2  DS    A                        LENGTH OF MODULE
ADDRESS2 DS    A                        ADDRESS OF MODULE
COMPLEN2 DS    A                        LENGTH OF COMPARE
COMPADR2 DS    A                        ADDRESS OF COMPARE
BLDL2    DS    17F                      BLDL LIST
         SPACE 1
I2       DCB   DDNAME=*,DSORG=PO,MACRF=R SECOND DCB
         SPACE 2
         READ  DECB,SF,MF=L             DECB FOR PDS INPUT
         SPACE 1
FLAG     DS    X                        FLAG FOR EXTERNAL REFERENCE
         SPACE 1
BASELEN  EQU   *-WORKAREA               LENGTH TO CLEAR
         SPACE 1
         DS    0F                       ALIGNMENT
RECORD   DS    (SNAPBLKS)X              INPUT AND OUTPUT BUFFER
         SPACE 1
DIRLST   DS    A
DIRTTR   DS    F                        TTR OF LAST DIRECTORY  BLOCK
DIRBUF   DS    0F,256X                  DIRECTORY BUFFER FOR 'ALL' OPT
         SPACE 1
         DS    0F                       ALIGNMENT
CESDTAB  DS    (STABCESD)XL(LTABCESD)   CESD ENTRY TABLE
         SPACE 1
COMMNAME DS    (2*STABCESD)CL8
         SPACE 1
WORKLEN  EQU   *-WORKAREA
         EJECT
         PRINT GEN
         BLDLLIST
         ORG   BLDLNAME+27
BLDLFTBL DC    2X'00'                   FIRST TEXT BLOCK LENGTH
BLDLEPA  DC    3X'00'                   ENTRY POINT ADDRESS
         SPACE 2
LIBWORK  DSECT
NAME#    DS    CL8                      MODULE NAME
LABEL#   DS    CL8                      LABEL IN MODULE
NUMBER#  DS    A                        NUMBER (OFFSET) INTO NAME/LABEL
LENGTH#  DS    A                        LENGTH OF MODULE
ADDRESS# DS    A                        ADDRESS OF MODULE
COMPLEN# DS    A                        LENGTH OF COMPARE
COMPADR# DS    A                        ADDRESS OF COMPARE
BLDL#    DS    17F                      BLDL LIST
         SPACE 1
I#       EQU   *                        DCB
         SPACE 2
         END   COMPARE
//*
//*KED.SYSLMOD DD DISP=OLD,SPACE=,DSN=SYS5.MSSLOAD,UNIT=
//LKED.SYSIN   DD *
   IDENTIFY COMPARE('CS01395')
   NAME COMPARE$(R)
//*
//C   EXEC PGM=COMPARE,
//  PARM='COMPARE,COMPARE$'
//STEPLIB  DD DISP=SHR,DSN=SYS5.MSSLOAD
//SYSPRINT DD SYSOUT=*
//I1       DD DISP=SHR,DSN=SYS5.MSSLOAD
//I2       DD DISP=(SHR,PASS),DSN=&&GOSET
