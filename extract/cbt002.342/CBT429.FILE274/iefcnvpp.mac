CNVPP    TITLE 'IEFCNVPP - AMDAHL MVS DYNAMIC PROCLIB SUPPORT'
***********************************************************************
*                                                                     *
*        IEFCNVPP                                                     *
*        ********                                                     *
*                                                                     *
*        VERSION 4, RELEASE 1, MODIFICATION 1                         *
*        ******* ** ******* ** ************ *                         *
*                                                                     *
*        THIS CSECT CONTAINS THE DYNAMIC PROCEDURE LIBRARY            *
*        SUPPORT ROUTINES.                                            *
*                                                                     *
*        THIS PROGRAM IS A REWRITE OF THE DYNAMIC PROCLIB             *
*        SUPPORT PROGRAM, IEFVPP, WHICH HAS BEEN IN USE AND           *
*        HAS BEEN DISTRIBUTED BY AMDAHL CORPORATION SINCE 1977.       *
*                                                                     *
*        THIS CODE HAS BEEN SUBSTANTIALLY REWRITTEN TO SUPPORT THE    *
*        MVS/ESA (TM) VERSION 4 CONVERTER UNTIL SUCH TIME AS          *
*        AN INSTALLATION CAN CONVERT IT'S JCL TO USE THE JCLLIB       *
*        JCL STATEMENT.                                               *
*                                                                     *
*        MAJOR FEATURES OF THIS VERSION:                              *
*                                                                     *
*        FULL SUPPORT FOR A "JOBPROC" DD STATEMENT AND                *
*        CONCATENATIONS BEFORE THE FIRST EXEC STATEMENT.              *
*                                                                     *
*        ENABLING THE USE OF THE JCLLIB, IF, AND INCLUDE              *
*        STATEMENTS WITHOUT RUNNING A VERSION 4 JES.                  *
*                                                                     *
*        "JCLLIB" KEYWORD PARAMETER ON THE START COMMAND TO           *
*        SUPPLY DYNAMIC PROCLIB FOR STARTED TASKS.                    *
*                                                                     *
*        ABILITY TO HAVE THE SYSTEM PROCEDURE LIBRARIES SEARCHED      *
*        FIRST, LAST, OR NOT AT ALL.                                  *
*                                                                     *
*        JOBPROC DD DATA SETS MUST BE CATALOGUED.                     *
*                                                                     *
*        ABILITY TO LIMIT WHICH DATA SETS CAN OR CANNOT BE USED       *
*        AS DYNAMIC PROCLIB DATA SETS.                                *
*                                                                     *
*        FACILITY TO SPECIFY THE LOCATION OF THE SCHEDULER WORK       *
*        AREA, OVERRIDING THE DEFAULT FOR THE JOB.                    *
*                                                                     *
***********************************************************************
         TITLE 'SUMMARY OF CHANGES'
***********************************************************************
*                                                                     *
*        VERSION 4, RELEASE 1, MODIFICATION 1                         *
*                                                                     *
*        ADDITION OF PATCH AREAS TO EACH MAJOR SECTION OF IEFCNVPP.   *
*                                                                     *
*        SUPPORT FOR CONVERTER PTFS WHICH MOVED FIELDS IN THE         *
*        CONVERTER WORK AREA.                                         *
*                                                                     *
*        JOBPROC DATA SET(S) WERE BEING PREMATURELY DEALLOCATED       *
*        AT THE END OF THE FIRST EXPANDED PROCEDURE.                  *
*                                                                     *
***********************************************************************
*                                                                     *
*        VERSION 4, RELEASE 1, MODIFICATION 0                         *
*                                                                     *
*        INITIAL RELEASE OF DYANMIC PROCLIB SUPPORT FOR               *
*        MVS/ESA SP VERSION 4.                                        *
*                                                                     *
***********************************************************************
         TITLE 'DYNAMIC PROCLIB LINKAGE REQUIREMENTS'
***********************************************************************
*                                                                     *
*        ATTRIBUTES:                                                  *
*        REENTRANT, REFRESHABLE.                                      *
*        RMODE ANY, AMODE 31.                                         *
*                                                                     *
*        ENTRY POINT:                                                 *
*              IEFCNVPP (FROM JES2/JES3) FIRST INITIALIZATION         *
*                  PROCESSING AND TERMINATION CLEANUP                 *
*                                                                     *
*        EXTERNAL REFERENCES:                                         *
*              IEFCNINT - NORMAL CONVERTER ENTRY POINT                *
*                                                                     *
*        EXITS:                                                       *
*              TO CALLER (JES2/JES3)                                  *
*                                                                     *
***********************************************************************
*                                                                     *
*        ENTRY POINT:                                                 *
*              IEFCNVGS (FROM IEFCNJRT) FRONT END AND BACK END        *
*                  TO CONVERTER JCL STATEMENT BUILD                   *
*                                                                     *
*        EXTERNAL REFERENCES:                                         *
*              IEFCNGST - CONVERTER JCL STATEMENT BUILD               *
*                                                                     *
*        EXITS:                                                       *
*              RETURNS TO CALLER (IEFCNJRT) WHEN STATEMENT IS         *
*              NOT A JOBPROC STATEMENT                                *
*                                                                     *
***********************************************************************
*                                                                     *
*        ENTRY POINT:                                                 *
*              IEFCNVPS (FROM IEFCNWRT) FRONT END TO CONVERTER        *
*                  POST SCAN EXIT                                     *
*                                                                     *
*        EXTERNAL REFERENCES:                                         *
*              POST SCAN EXIT PASSED FROM JES2/JES3                   *
*                                                                     *
*        EXITS:                                                       *
*              RETURNS TO CALLER (IEFCNWRT) AFTER CALLING             *
*              POST SCAN EXIT                                         *
*                                                                     *
***********************************************************************
         EJECT
***********************************************************************
*                                                                     *
*        ADDITIONAL EXTERNAL REFERENCES (CONVERTER):                  *
*              IEFCNIMM - CONVERTER MESSAGE ROUTINE                   *
*                                                                     *
*        ADDITIONAL EXTERNAL REFERENCES (LOCAL):                      *
*              IEFCNVOP - DYNAMIC PROCLIB OPTIONS TABLE               *
*              IEFCNVXT - OCO PROCESSING MODULE                       *
*                                                                     *
*        ADDITIONAL LOAD MODULE REFERENCES (LOCAL):                   *
*              IEFCNVLS - DATA SET EXCLUSION TABLE                    *
*                                                                     *
***********************************************************************
*                                                                     *
*        SEE COMMENTS AT EACH INDIVIDUAL ENTRY POINT FOR MORE         *
*        INFORMATION.                                                 *
*                                                                     *
***********************************************************************
         TITLE 'DYNAMIC PROCLIB COPYRIGHT AND STATEMENT OF SUPPORT'
***********************************************************************
*                                                                     *
*        COPYRIGHT                                                    *
*        *********                                                    *
*                                                                     *
*        AMDAHL CORPORATION, 1991.                                    *
*                                                                     *
*        THIS COPYRIGHT IS NOT INTENDED TO LIMIT THE USE OF THIS      *
*        CODE BY THE RECEIVING INSTALLATION, BUT TO PREVENT ITS       *
*        REDISTRIBUTION FOR PROFIT.                                   *
*                                                                     *
*        SINCE THE DYNAMIC PROCLIB PROCESSING REQUIRED ACCESS TO      *
*        SEVERAL CONVERTER INTERNAL CONTROL BLOCKS, A SMALL PORTION   *
*        OF THIS MODIFICATION IS BEING DISTRIBUTED AS OBJECT CODE     *
*        ONLY.                                                        *
*                                                                     *
***********************************************************************
         SPACE 3
***********************************************************************
*                                                                     *
*        STATEMENT OF SUPPORT                                         *
*        ********* ** *******                                         *
*                                                                     *
*        THIS PROGRAM IS RUN IN THE CORPORATE COMPUTER CENTER         *
*        OF THE AMDAHL CORPORATION AND IT'S USERS ARE TOTALLY         *
*        DEPENDENT UPON IT.  HOWEVER, THAT DOES NOT IMPLY THAT        *
*        THE AMDAHL CORPORATION FORMALLY SUPPORTS THIS CODE           *
*        AND MAINTAINS RESPONSIBILITY FOR IT.  AS WITH ALL            *
*        MODIFICATIONS, THE USING INSTALLATION MUST DECIDE            *
*        WHETHER OR NOT TO INSTALL IT BASED ON THEIR ABILITY TO       *
*        MAINTAIN IT IN THE FUTURE.  NOTE THAT SUPPORT IS PRI-        *
*        MARILY A MATTER OF TIMING (I.E., WE MAY NOT BE RUNNING A     *
*        NEW VERSION AS SOON AS OTHER INSTALLATIONS).                 *
*                                                                     *
*        BECAUSE THIS MODIFICATION IS SUPPLIED WITH A SMALL           *
*        PART OF ITS FUNCTION DELIVERED IN AN OBJECT CODE ONLY        *
*        MODULE (BECAUSE OF USAGE OF INTERNAL CONVERTER DATA          *
*        AREA), THE AUTHOR PERSONALLY, NOT AMDAHL CORPORATION,        *
*        WILL MAKE EVERY EFFORT TO PROVIDE NECESSARY CHANGES TO       *
*        THIS MODIFICATION IN AS TIMELY MANNER AS POSSIBLE.           *
*                                                                     *
*        THIS VERSION OF DYNAMIC PROCLIB IS CONSIDERED TEMPORARY.     *
*        IT IS INTENDED TO BE USED AS A COMPATIBILITY TOOL FOR        *
*        INSTALLATIONS THAT HAVE BEEN USING PREVIOUS VERSION OF       *
*        THE DYNAMIC PROCLIB MODIFICATION AND WISH TO ALLOW THEIR     *
*        USERS SOME TIME TO CONVERT TO THE JCLLIB STATEMENT           *
*        INCLUDED AS PART OF MVS/ESA VERSION 4.                       *
*                                                                     *
*        THE SUPPORT FOR THE JCLLIB KEYWORD ON THE START COMMAND      *
*        AND THE SWA LOCATION PARAMETERS AND DDNAMES ARE              *
*        CONSIDERED PERMANENT.  OTHER FEATURES CAN BE DISABLED        *
*        AND LEAVE IT INTACT.                                         *
*                                                                     *
***********************************************************************
         TITLE 'AUTHOR'
***********************************************************************
*                                                                     *
*        ADDITIONAL INFORMATION CONCERNING THESE MODIFICATIONS        *
*        CAN BE OBTAINED BY CONTACTING:                               *
*                                                                     *
*        KEITH E. MOE                                                 *
*        AMDAHL CORPORATION                                           *
*        CORPORATE COMPUTER CENTER                                    *
*        MAIL STOP 201                                                *
*        POST OFFICE BOX 3470                                         *
*        1250 EAST ARQUES AVENUE                                      *
*        SUNNYVALE, CALIFORNIA  94088-3470                            *
*        (408) 746-6386                                               *
*                                                                     *
***********************************************************************
         TITLE 'CONVERTER/INTERPRETER MODIFICATIONS'
***********************************************************************
*                                                                     *
*        CONVERTER/INTERPRETER MODIFICATIONS                          *
*        ********************* *************                          *
*                                                                     *
*        THIS VERSION OF DYNAMIC PROCLIB IS TOTALLY CONTAINED         *
*        WITHIN MODULES IEFCNVPP, IEFCNVOP, AND IEFCNVXT AND DOES     *
*        NOT REQUIRE ANY ACTUAL MODIFICATION TO IBM CODE (I.E.,       *
*        SUPERZAPS).  IT IS, HOWEVER, LINK EDITED INTO THE            *
*        CONVERTER LOAD MODULE (IEFVH1) FRONT-ENDING SEVERAL          *
*        CONVERTER MODULE ENTRY POINTS.  WHILE THE NECESSARY          *
*        SMP/E JCLIN IS SUPPLIED, THE FIRST TIME IT IS INSTALLED,     *
*        A MANUAL LINK EDIT OF THE CONVERTER LOAD MODULE IS           *
*        NECESSARY ORDER IN ORDER TO ALTER THE APPROPRIATE            *
*        EXTERNAL REFERENCES.                                         *
*                                                                     *
*        THE THREE NEW MODULES, IEFCNVPP, IEFCNVOP, AND IEFCNVXT,     *
*        ARE LINK EDITTED AS PART OF IEFVH1, THE JCL CONVERTER.       *
*        THE LINK EDIT CHANGE STATEMENTS CAUSES IEFCNVPP TO BE        *
*        INVOKED AS THE NEW ENTRY POINT OF IEFVH1 AND                 *
*        TO FRONT END THE STATEMENT SCAN CSECT (IEFCNGST).            *
*                                                                     *
*        A SEPARATE LOAD MODULE, IEFCNVLS, CONTAINS DATA SET          *
*        INCLUSION AND EXCLUSION LISTS AND CAN BE USED TO LIMIT       *
*        THE DATA SETS THAT CAN BE USED AS DYNAMIC PROCLIB            *
*        DATA SETS.  IEFCNVLS IS TOTALLY OPTIONAL.                    *
*                                                                     *
*        PREVIOUS VERSIONS OF THIS MODIFICATION REQUIRED A            *
*        SUPERZAP IS TO MODULE IEFVDA IN LOAD MODULE IEFNB903.        *
*        THE ZAP TO IEFVDA (IN THE INTERPRETER) WAS INSTALLED TO      *
*        PREVENT A JOBPROC STATEMENT FROM CAUSING A MISPLACED DD      *
*        STATEMENT JCL ERROR IN THE INTERPRETER.  THIS SUPERZAP       *
*        IS NOT NECESSARY FOR THIS CODE, AS THE JOBPROC STATEMENTS    *
*        NEVER MAKE IT OUT OF THE CONVERTER.  HOWEVER, IF THE         *
*        INSTALLATION IS SHARING THE JES2 SPOOL WITH A VERSION 3      *
*        MVS/ESA SYSTEM (OR LOWER), IT IS POSSIBLE FOR A JOB TO       *
*        BE CONVERTED ON VERSION 3 AND ATTEMPT TO RUN ON VERSION 4,   *
*        SO THAT THE SUPERZAP WOULD BE NECESSARY IN THAT CASE.        *
*        ONCE ALL SYSTEMS HAVE BEEN CONVERTED TO VERSION 4,           *
*        THE ZAP TO IEFVDA CAN BE REMOVED.                            *
*                                                                     *
*        NO SUPERZAP IS NECESSARY TO SUPPLY THE "SYSPROC"             *
*        PARAMETER, AS THE CONVERTER DOES NOT ATTEMPT TO PROCESS      *
*        THE JOBPROC DD STATEMENT INTO INTERNAL TEXT.                 *
*                                                                     *
*        WITH THE SETTING OF THE APPROPRIATE OPTION, THE MVS/ESA      *
*        VERSION 4 JCLLIB STATEMENT CAN BE ENABLED WITHOUT THE        *
*        USE OF A VERSION 4 JES.                                      *
*                                                                     *
***********************************************************************
         TITLE 'DYNAMIC PROCLIB USER EXTERNALS'
***********************************************************************
*                                                                     *
*        THE USER WISHING TO SUPPLY A DYNAMIC PROCLIB NEED ONLY       *
*        CODE ONE OR MORE DD STATEMENTS (FOLLOWING THE NORMAL         *
*        RULES OF CONCATENATION) WITH THE DD NAME OF "JOBPROC".       *
*        THE JOBPROC DD MUST APPEAR BEFORE THE FIRST EXEC, IF,        *
*        OR INCLUDE STATEMENT OF A JOB.  THE ONLY JCL PARAMETERS      *
*        SUPPORTED ARE DSNAME AND SYSPROC.  USE OF OTHER JCL          *
*        PARAMETERS IS IGNORED, BUT COULD CAUSE UNPREDICTABLE         *
*        RESULTS IF CODED.  DSNAME IS MANDATORY.  SYSPROC IS          *
*        OPTIONAL AND INDICATES THE CONCATENATION AFTER THE USER      *
*        PROCLIBS (SYSPROC=YES), CONCATENATION BEFORE THE USER        *
*        PROCLIBS (SYSPROC=FIRST), OR NON-CONCATENATION               *
*        (SYSPROC=NO) OF THE SYSTEM PROCEDURE LIBRARIES WITH THE      *
*        USER SPECIFIED PROCEDURE LIBRARIES.                          *
*                                                                     *
*        SUPPORT FOR UNCATALOGUED JOBPROC DATA SETS HAS BEEN          *
*        ELIMINATED.                                                  *
*                                                                     *
***********************************************************************
         TITLE 'CONTROL BLOCK MAPPINGS'
IEFCNVPP CSECT ,                   CONTROL SECTION NAME
IEFCNVPP AMODE 31
IEFCNVPP RMODE ANY
*
         SPLEVEL SET=4             MVS/ESA VERSION 4 ONLY
*
         PUSH  PRINT
         PRINT NOGEN
*
         CVT   DSECT=YES
*
         IEFCNPRM                  MAP THE NEW CONVERTER PARM LIST
*
CNPREXLN EQU   CNPRXEND-CNPREXIT   LENGTH OF COMPLETE EXIT AREA
CNPRXELN EQU   CNPRXEND-CNPRXENT   LENGTH OF EXIT SUBSECTION
*
CNPRM    DSECT                     BACK TO THE ORIGINAL DSECT
         ORG   CNPRM               MAP THE OLD CONVERTER PARM LIST
         IEFNEL SUBCOM=C           OVER THE NEW PARM LIST (NEAT, HUH)
*
         IEFCNMB                   CONVERTER MESSAGE BUFFER
*
         IEFJMR                    JOB MANAGEMENT RECORD
*
         IEFZB4D0  ,               DYNAMIC ALLOCATION PARM LIST
S99RBXLN EQU   *-S99RBX
         AIF   (T'S99MSGL0 NE 'U').ZB4D0A
S99MSGL0 EQU   0                   NULL SUPPRES MESSAGE FLAG IF NOT
.ZB4D0A  ANOP
*
         IEFZB4D2  ,               DYNAMIC ALLOCATION TEXT KEYS
*
         IKJEFFDF  DFDSECT=YES     DAIRFAIL PARAMETER LIST
*
         DCBD  DSORG=PO,DEVD=DA
*
         IHASDWA DSECT=YES
*
         IHAPSA
*
         IHAASCB
*
         IKJTCB
*
         IEZJSCB
*
JCTDSECT DSECT
         IEFAJCTB ,                MVS (NOT JES) JOB CONTROL TABLE
*
TIODSECT DSECT
         IEFTIOT1 ,                TASK I/O TABLE
*
JFCBDSCT DSECT
         IEFJFCBN ,                JOB FILE CONTROL BLOCK
*
UCBDSECT DSECT
         IEFUCBOB ,                UNIT CONTROL BLOCK
*
         IEFJESCT                  JES CONTROL TABLE
*
         IEFZB505 LOCEPAX=YES      SWAREQ PARAMETER LIST
*
         IEFVKEYS                  INTERNAL TEXT KEYS
*
         IEFTXTFT                  INTERNAL TEXT HEADER
*
         POP  PRINT
*
         IEFCNFSA ,                CONVERTER SUBTASK FIRST SAVE AREA
*
         IEFCNOPT DSECT=YES        PROGRAM OPTIONS
*
         IEFCNPPW ,                DYNAMIC PROCLIB WORK AREA
*
         IEFCNMSG DSECT=YES        MESSAGE TABLE
*
         TITLE 'DYNAMIC PROCLIB REGISTER USAGE'
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4                   NOT USED
R5       EQU   5
R6       EQU   6
R7       EQU   7                   NOT USED
R8       EQU   8                   NOT USED
R9       EQU   9                   NOT USED
R10      EQU   10                  NOT USED
R11      EQU   11                  NOT USED
R12      EQU   12                  BASE REGISTER
R13      EQU   13                  PRIMARY WORK AREA
R14      EQU   14
R15      EQU   15
*
         TITLE 'IEFCNVPP - DYNAMIC PROCLIB INITIALIZATION'
***********************************************************************
*                                                                     *
*        IEFCNVPP                                                     *
*        ********                                                     *
*                                                                     *
*        THIS ROUTINE IS USED AS A FRONT END TO THE CONVERTER,        *
*        BECOMING THE NEW ENTRY POINT FOR THE CONVERTER.  IT          *
*        ESTABLISHES THE DYNAMIC PROCLIB BASE ENVIRONMENT AND         *
*        PASSES CONTROL THE TO ORIGINAL ENTRY POINT OF THE CONVERTER, *
*        IEFCNINT.                                                    *
*                                                                     *
*        THIS ROUTINE OBTAINS THE DYNAMIC PROCLIB WORK AREA AND       *
*        ANCHORS IT IN THE FIRST SAVE AREA OF THE TASK (POINTED TO    *
*        TCBFSA).  SINCE MOST OF THIS SAVE AREA IS NOT USED FOR       *
*        ANYTHING, IT IS A CONVENIENT PLACE TO PROVIDE AN ANCHOR      *
*        THAT SUBSEQUENT ENTRIES TO DYNAMIC PROCLIB PROCESSING        *
*        CAN LOCATE IT AND STILL REMAIN RE-ENTRANT.                   *
*                                                                     *
*        INPUT (FROM JES2/3):                                         *
*              CONVERTER PARAMETER LIST (EITHER FORM) IN R1           *
*                                                                     *
*        OUTPUT:                                                      *
*              DYNAMIC PROCLIB WORK AREA (PPWDSECT) ANCHORED IN       *
*              THE TASK'S FIRST SAVE AREA.                            *
*                                                                     *
*        EXTERNAL REFERENCES:                                         *
*              IEFCNINT (ORIGINAL CONVERTER ENTRY POINT)              *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER (JES2/3)                              *
*                                                                     *
***********************************************************************
         EJECT
IEFCNVPP CSECT ,                   CONTROL SECTION NAME
         USING *,R15               TEMPORARY BASE
         B     VPPSTM              BRANCH AROUND ID
*
         DC    AL1(VPPIDL)         LTH OF IDENTIFICATION PREFIX
VPPID    DC    CL8'IEFCNVPP'       USER PROCLIB SUPPORT MODULE ID
VPPVERSN DC    CL8'V4.1.1 '        CURRENT AMDAHL RELEASE NO.
VPPSDATE DC    CL8'&SYSDATE'       LAST ASSEMBLY DATE
VPPSTIME DC    CL8' &SYSTIME'      TIME OF LAST ASSEMBLY
VPPCPYRT DC    C'COPYRIGHT 1991 BY AMDAHL CORP.'
VPPIDL   EQU   *-VPPID             LENGTH OF IDENTIFICATION HEADER
*
VPPSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVPP,R12        ESTABLISH PERMANENT BASE
*
         LR    R2,R1               SAVE THE ENTRY PARM ADDRESS
*
         LA    R0,PPWORKLN         LENGTH OF PROCLIB WORK AREA
         GETMAIN RU,LV=(0),LOC=(BELOW,ANY),                            X
               BNDRY=PAGE          GET THE PROCLIB WORK AREA
         LR    R3,R1               SAVE IT FOR THE MOMENT
*
         LR    R0,R1               SET FOR MVCL
         LA    R1,PPWORKLN         LENGTH OF MVCL
         SLR   R15,R15             ZERO FROM LENGTH
         MVCL  R0,R14              CLEAR THE WORK AREA
*
         ST    R3,8(,R13)          STORE FORWARD POINTER
         ST    R13,4(,R3)          STORE BACKWARD POINTER
         LR    R13,R3              SET NEW SAVE AREA ADDRESS
         USING PPWDSECT,R13
*
         MVC   PPWPPWID,=A(PPWIDPPW)    SET EYECATCHER
*
         OI    PPWVPPFL,PPWVPPEX   INDICATE IEFCNVPP IS EXECUTING
*
         L     R15,PPWVPPCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVPPCN        STORE IT BACK
*
         ST    R13,PPWWORKA        SAVE THE ADDRESS OF THIS AREA
         LA    R0,PPWORKLN         LOAD THE LENGTH
         ST    R0,PPWWORKL         SAVE THE LENGTH
*
         ST    R2,PPWINTR1         STORE THE CONVERTER PARMS
*
         EJECT
***********************************************************************
*                                                                     *
*        GET THE TCB ADDRESS AND THE FIRST SAVE AREA ADDRESS AND      *
*        ANCHOR OUR WORK AREA IN IT FOR FUTURE REFERENCE.             *
*                                                                     *
***********************************************************************
*
         L     R15,PSATOLD-PSA     LOAD TCB ADDRESS
         ST    R15,PPWTCBAD        SAVE THE TCB ADDRESS
         USING TCB,R15
*
         ICM   R1,15,TCBTIO        LOAD TIOT ADDRESS
         ST    R1,PPWTIOTA         SAVE THE ADDRESS
         BZ    VPPISMST            ASSUME MASTER IF NULL
*
         USING TIODSECT,R1
         CLC   TIOCNJOB(6),=C'MSTJCL'   TEST IF MASTER'S TIOT
         BE    VPPISMST            BRANCH IF SO
         DROP  R1                  DONE WITH THE TIOT
*
         L     R1,PSAAOLD-PSA      LOAD ASCB ADDRESS
         USING ASCB,R1
         LH    R1,ASCBASID         LOAD THE ASID
         CH    R1,=H'1'            CHECK FOR THE MASTER ADDRESS SPACE
         BNE   VPPNOMST            BRANCH IF NOT
         DROP  R1                  DONE WITH THE ASCB
*
VPPISMST OI    PPWENVIR,PPWEMSTR   INDICATE THIS IS THE MASTER
*
VPPNOMST DS    0H
         L     R15,TCBFSA          POINT AT FIRST SAVE AREA
         ST    R15,PPWFSAAD        SAVE THIS ADDRESS
         USING FSADSECT,R15
*
         MVC   PPWFSAR2,FSAPPEYE   SAVE THE ORIGINAL CONTENTS
         MVC   PPWFSAR3,FSAPPWAD   SAME HERE
*
         MVC   FSAPPEYE,=A(FSAPPEID)    SET THE EYECATCHER
         ST    R13,FSAPPWAD        STORE THE WORK AREA ADDRESS
         DROP  R15
*
         L     R15,CVTPTR          LOAD THE CVT ADDRESS
         USING CVT,R15
         TM    CVTOSLV0,CVTH4410   ARE WE RUNNING A VERSION 4 SYSTEM
         BZ    *+8                 BRANCH IF NOT
         OI    PPWENVIR,PPWEESA4   INDICATE WE ARE ON AN SP V4 SYSTEM
         DROP  R15
*
         EJECT
***********************************************************************
*                                                                     *
*        INITIALIZE THE FREQUENTLY USED ADDRESS REFERENCES            *
*                                                                     *
***********************************************************************
*
         L     R0,=A(IEFCNVDE)     LOAD OUR DYNALLOC ERROR ROUTINE ADDR
         ST    R0,PPWCNVDE         STORE IN OUR WORK AREA
*
         L     R0,=A(IEFCNVKW)     LOAD OUR KEYWORD SCAN ROUTINE ADDR
         ST    R0,PPWCNVKW         STORE IN OUR WORK AREA
*
         L     R0,=A(IEFCNVPD)     LOAD OUR PARM DELETE ROUTINE ADDR
         ST    R0,PPWCNVPD         STORE IN OUR WORK AREA
*
         L     R0,=A(IEFCNVMS)     LOAD OUR MESSAGE ROUTINE ADDR
         ST    R0,PPWCNVMS         STORE IN OUR WORK AREA
*
         L     R0,=V(IEFCNVXT)     LOAD OUR DATA EXTRACT ROUTINE ADDR
         ST    R0,PPWCNVXT         STORE IN OUR WORK AREA
*
***********************************************************************
*                                                                     *
*        FLAG ALL THE SAVE AREAS FOR QUICK SPOTTING IN A DUMP         *
*                                                                     *
***********************************************************************
*
         MVC   PPWVGSID,=A(PPWIDVGS)    SET EYECATCHER FOR IEFCNVGS
*
         MVC   PPWVXTID,=A(PPWIDVXT)    SET EYECATCHER FOR IEFCNVXT
*
         MVC   PPWVJPID,=A(PPWIDVJP)    SET EYECATCHER FOR IEFCNVJP
*
         MVC   PPWVEXID,=A(PPWIDVEX)    SET EYECATCHER FOR IEFCNVEX
*
         MVC   PPWVKWID,=A(PPWIDVKW)    SET EYECATCHER FOR IEFCNVKW
*
         MVC   PPWVPDID,=A(PPWIDVPD)    SET EYECATCHER FOR IEFCNVPD
*
         MVC   PPWVPSID,=A(PPWIDVPS)    SET EYECATCHER FOR IEFCNVPS
*
         MVC   PPWVCLID,=A(PPWIDVCL)    SET EYECATCHER FOR IEFCNVCL
*
         MVC   PPWVDEID,=A(PPWIDVDE)    SET EYECATCHER FOR IEFCNVDE
*
         MVC   PPWVMSID,=A(PPWIDVMS)    SET EYECATCHER FOR IEFCNVMS
*
         MVC   PPWVSTID,=A(PPWIDVST)    SET EYECATCHER FOR IEFCNVST
*
         EJECT
***********************************************************************
*                                                                     *
*        EXTRACT KEY ADDRESSES FROM THE CONVERTER PARM LIST           *
*                                                                     *
***********************************************************************
*
         USING CNPRM,R2            CONVERTER PARAMETERS STILL HERE
*
         TM    CNPROPTS,CNPRNEW    TEST FOR NEW FORMAT PARM LIST
         BZ    VPPOLDPM            BRANCH IF OLD FORMAT (NEL)
*
         LA    R1,CNPRPROC         GET ADDRESS OF CONVERT DCB ADDRESS
         ST    R1,PPWPMDCB         SAVE THE PARM LIST ADDRESS
         MVC   PPWCNDCB,CNPRPROC   SAVE THE ACTUAL ADDRESS
*
         LA    R1,CNPRXLST         GET ADDRESS OF CNV EXIT LIST ADDR
         ST    R1,PPWPMTXT         SAVE THE PARM LIST ADDRESS
         MVC   PPWCNTXT,CNPRXLST   SAVE THE ACTUAL ADDRESS
*
         MVC   PPWJMR,CNPRJMR      SAVE THE JMR ADDRESS
*
         B     VPPPRMDN            AND BRANCH AROUND "OLD" CODE
*
VPPOLDPM DS    0H
         LA    R1,NELPROCB         GET ADDRESS OF CONVERT DCB ADDRESS
         ST    R1,PPWPMDCB         SAVE THE PARM LIST ADDRESS
         MVC   PPWCNDCB,NELPROCB   SAVE THE ACTUAL ADDRESS
*
         LA    R1,NELEXLST         GET ADDRESS OF CNV EXIT LIST ADDR
         ST    R1,PPWPMTXT         SAVE THE PARM LIST ADDRESS
         MVC   PPWCNTXT,NELEXLST   SAVE THE ACTUAL ADDRESS
*
         MVC   PPWJMR,NELJMR       SAVE THE JMR ADDRESS
*
         DROP  R2
*
VPPPRMDN DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        INITIALIZE THE ASSEMBLED OPTIONS                             *
*                                                                     *
***********************************************************************
*
         L     R15,=V(IEFCNVOP)    LOAD OPTIONS ADDRESS
         ST    R15,PPWCNVOP        STORE THIS FOR GOOD MEASURE
         USING OPTDSECT,R15
*
         XC    PPWGENWK(256),PPWGENWK   CLEAR FOR TRT TABLE
         MVI   PPWGENWK+C' ',X'FF' FLAG THE BLANK A-ROONEY
*
***********************************************************************
*                                                                     *
*        JOBPROC DD NAME                                              *
*                                                                     *
***********************************************************************
*
         MVC   PPWJBPRC,OPTJBPRC   COPY JOBPROC DDNAME
         LA    R1,L'PPWJBPRC       MAXIMUM LENGTH OF JOBPROC DDNAME
         TRT   PPWJBPRC,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWJBPRC         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWJBPRL         STORE DDNAME LENGTH
*
         LTR   R1,R1               TEST IF JOBPROC DDNAME IS NULL
         BZ    *+8                 BRANCH IF NULL
         OI    PPWOPTN1,PPWO1JPR   INDICATE WE PROCESS JOBPROC
*
***********************************************************************
*                                                                     *
*        SYSPROC KEYWORD ON JOBPROC DD STATEMENT                      *
*                                                                     *
***********************************************************************
*
         MVC   PPWSYSPR,OPTSYSPR   COPY SYSPROC KEYWORD
         LA    R1,L'PPWSYSPR       MAXIMUM LENGTH OF SYSPROC KEYWORD
         TRT   PPWSYSPR,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWSYSPR         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWSYSPL         STORE KEYWORD LENGTH
*
         EJECT
***********************************************************************
*                                                                     *
*        STARTED TASK JCLLIB KEYWORD PARAMETER                        *
*                                                                     *
***********************************************************************
*
         MVC   PPWSTCKW,OPTSTCKW   COPY STARTED TASK JCLLIB KEYWORD
         LA    R1,L'PPWSTCKW       MAXIMUM LENGTH OF STC JCLLIB KEYWD
         TRT   PPWSTCKW,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWSTCKW         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWSTCKL         STORE KEYWORD LENGTH
*
         LTR   R1,R1               TEST IF STC JCLLIB IS NULL
         BZ    *+8                 BRANCH IF NULL
         OI    PPWOPTN1,PPWO1STC   INDICATE WE HANDLE STC JCLLIBS
*
         EJECT
***********************************************************************
*                                                                     *
*        SWA PARAMETER ON THE JOB STATEMENT                           *
*                                                                     *
***********************************************************************
*
         MVC   PPWSWAKW,OPTSWAKW   COPY SWA KEYWORD PARAMETER
         LA    R1,L'PPWSWAKW       MAXIMUM LENGTH OF SWA KEYWORD
         TRT   PPWSWAKW,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWSWAKW         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWSWAKL         STORE KEYWORD LENGTH
*
         LTR   R1,R1               TEST IF SWA KEYWORD IS NULL
         BZ    *+8                 BRANCH IF NULL
         OI    PPWOPTN1,PPWO1SWA   INDICATE WE HANDLE SWA PARAMETER
*
***********************************************************************
*                                                                     *
*        SWA DDNAMES                                                  *
*                                                                     *
***********************************************************************
*
         MVC   PPWSWAAD,OPTDDSWA   COPY SWAABOVE DDNAME
         LA    R1,L'PPWSWAAD       MAXIMUM LENGTH OF SWA DDNAME
         TRT   PPWSWAAD,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWSWAAD         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWSWAAL         STORE DDNAME LENGTH
*
         MVC   PPWSWABD,OPTDDSWB   COPY SWABELOW DDNAME
         LA    R1,L'PPWSWABD       MAXIMUM LENGTH OF SWA DDNAME
         TRT   PPWSWABD,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWSWAAD         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWSWABL         STORE DDNAME LENGTH
*
         LTR   R1,R1               TEST IF SWABELOW DDNAME IS NULL
         BZ    *+16                BRANCH IF NULL
         ICM   R1,3,PPWSWAAL       LOAD SWAABOVE DDNAME LENGTH
         BZ    *+8                 BRANCH IF NULL
         OI    PPWOPTN1,PPWO1SDD   INDICATE WE HANDLE SWA DDNAMES
*
         EJECT
***********************************************************************
*                                                                     *
*        MESSAGE NUMBER PREFIX                                        *
*                                                                     *
***********************************************************************
*
         MVC   PPWMSGPF,OPTMSGPF   COPY MESSAGE NUMBER PREFIX
         LA    R1,L'PPWMSGPF       MAXIMUM LENGTH OF MESSAGE ID PREFIX
         TRT   PPWMSGPF,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWMSGPF         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWMSGPL         STORE MESSAGE PREFIX LENGTH
*
***********************************************************************
*                                                                     *
*        INCLUSION/EXCLUSION MODULE NAME                              *
*                                                                     *
***********************************************************************
*
         MVC   PPWDSNLS,OPTDSNLS   DATA SET INCL/EXCL MODULE NAME
         LA    R1,L'PPWDSNLS       MAXIMUM LENGTH OF MODULE NAME
         TRT   PPWDSNLS,PPWGENWK   SCAN FOR A BLANK
         BZ    *+10                BRANCH IF FULL LENGTH
         LA    R2,PPWDSNLS         POINT AT FIRST CHARACTER
         SR    R1,R2               CALCULATE LENGTH
*
         STH   R1,PPWDSNLL         STORE MODULE NAME LENGTH
*
         EJECT
***********************************************************************
*                                                                     *
*        SET THE MESSAGE SUPPRESSION OPTION                           *
*                                                                     *
***********************************************************************
*
         CLI   OPTMSGSP,C'Y'       DO WE WANT TO ALTER THE MESSAGE SUPP
         BNE   *+8                 BRANCH IF NOT
         OI    PPWOPTN1,PPWO1MSP   SUPPRESS THE MESSAGES
*
***********************************************************************
*                                                                     *
*        SET THE JES LEVEL CHANGE OPTION                              *
*                                                                     *
***********************************************************************
*
         CLI   OPTJESLV,C'Y'       DO WE WANT TO ALTER THE JES LEVEL
         BNE   *+8                 BRANCH IF NOT
         OI    PPWOPTN1,PPWO1JLV   ALTER THE JES LEVEL WHEN POSSIBLE
*
***********************************************************************
*                                                                     *
*        SET THE DEBUGGING OPTION                                     *
*                                                                     *
***********************************************************************
*
         CLI   OPTDEBUG,C'N'       CHECK FOR DEBUG=NO
         BE    *+8                 BRANCH IF SO
         OI    PPWOPTN1,PPWO1DBG   THIS IS HOW DEBUGGING IS TURNED ON
*
         TM    PPWENVIR,PPWEESA4   ARE WE RUNNING UNDER SP V4 BCP
         BO    *+8                 BRANCH IF SO
         OI    PPWOPTN1,PPWO1DBG   TURN ON DEBUGGING IF NOT
*
         EJECT
***********************************************************************
*                                                                     *
*        SET THE BATCH JOB SYSPROC DEFAULT                            *
*                                                                     *
***********************************************************************
*
         LA    R1,OPTSPRJB         POINT AT BATCH JOB SYSPROC DEFAULT
         BAL   R14,VPPSYSDF        GO CHECK DEFAULT
         B     VPPSYSJY            RETURN 0(R14) SYSPROC=YES
         B     VPPSYSJN            RETURN 4(R14) SYSPROC=NO
         B     VPPSYSJF            RETURN 8(R14) SYSPROC=FIRST
*
VPPSYSJY OI    PPWSPRDF,PPWSPRJY   SET BATCH DEFAULT SYSPROC=YES
         B     VPPSYSJD
*
VPPSYSJN NI    PPWSPRDF,255-PPWSPRJY-PPWSPRJF BATCH DEFAULT SYSPROC=NO
         B     VPPSYSJD
*
VPPSYSJF OI    PPWSPRDF,PPWSPRJY   SET BATCH DEFAULT SYSPROC=YES
         OI    PPWSPRDF,PPWSPRJF   SET BATCH DEFAULT SYSPROC=FIRST
         B     VPPSYSJD
*
VPPSYSJD DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        SET THE TIME SHARING USER SYSPROC DEFAULT                    *
*                                                                     *
***********************************************************************
*
         LA    R1,OPTSPRTS         POINT AT TSO USER SYSPROC DEFAULT
         BAL   R14,VPPSYSDF        GO CHECK DEFAULT
         B     VPPSYSTY            RETURN 0(R14) SYSPROC=YES
         B     VPPSYSTN            RETURN 4(R14) SYSPROC=NO
         B     VPPSYSTF            RETURN 8(R14) SYSPROC=FIRST
*
VPPSYSTY OI    PPWSPRDF,PPWSPRTY   SET TSO DEFAULT SYSPROC=YES
         B     VPPSYSTD
*
VPPSYSTN NI    PPWSPRDF,255-PPWSPRTY-PPWSPRTF TSO DEFAULT SYSPROC=NO
         B     VPPSYSTD
*
VPPSYSTF OI    PPWSPRDF,PPWSPRTY   SET TSO DEFAULT SYSPROC=YES
         OI    PPWSPRDF,PPWSPRTF   SET TSO DEFAULT SYSPROC=FIRST
         B     VPPSYSTD
*
VPPSYSTD DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        SET THE STARTED TASK SYSPROC DEFAULT                         *
*                                                                     *
***********************************************************************
*
         LA    R1,OPTSPRST         POINT AT STC SYSPROC DEFAULT
         BAL   R14,VPPSYSDF        GO CHECK DEFAULT
         B     VPPSYSSY            RETURN 0(R14) SYSPROC=YES
         B     VPPSYSSN            RETURN 4(R14) SYSPROC=NO
         B     VPPSYSSF            RETURN 8(R14) SYSPROC=FIRST
*
VPPSYSSY OI    PPWSPRDF,PPWSPRSY   SET STC DEFAULT SYSPROC=YES
         B     VPPSYSSD
*
VPPSYSSN NI    PPWSPRDF,255-PPWSPRSY-PPWSPRSF STC DEFAULT SYSPROC=NO
         B     VPPSYSSD
*
VPPSYSSF OI    PPWSPRDF,PPWSPRSY   SET STC DEFAULT SYSPROC=YES
         OI    PPWSPRDF,PPWSPRSF   SET STC DEFAULT SYSPROC=FIRST
         B     VPPSYSSD
*
VPPSYSSD DS    0H
*
         DROP  R15
*
         EJECT
***********************************************************************
*                                                                     *
*        NOW SET THE ACTUAL DEFAULT BASED ON THE ENVIRONMENT          *
*                                                                     *
***********************************************************************
*
         ICM   R1,15,PPWJMR        LOAD THE JMR ADDRESS
         BZ    VPPSYSSS            ASSUME STARTED TASK IF NONE
         USING JMR,R1
*
         CLI   JMRCLASS,X'D0'      CHECK FOR STARTED TASK
         BE    VPPSYSSS            BRANCH IF SO
         CLI   JMRCLASS,X'E0'      CHECK FOR TSO USER
         BE    VPPSYSTS            BRANCH IF SO
*
         DROP  R1
*
VPPSYSJS DS    0H
         OI    PPWENVIR,PPWEJOB    SET BATCH JOB
*
         TM    PPWSPRDF,PPWSPRJY   TEST FOR SYSPROC=YES
         BZ    *+8                 BRANCH IF NOT
         OI    PPWFLAG4,PPW4SYSP   INDICATE SYSPROC=YES
*
         TM    PPWSPRDF,PPWSPRJF   TEST FOR SYSPROC=FIRST
         BZ    *+8                 BRANCH IF NOT
         OI    PPWFLAG4,PPW4SYSF   INDICATE SYSPROC=FIRST
*
         B     VPPSYSDN            AND WE ARE DONE WITH SYSPROC OPTIONS
*
VPPSYSTS DS    0H
         OI    PPWENVIR,PPWETSU    SET TSO USER
*
         TM    PPWSPRDF,PPWSPRTY   TEST FOR SYSPROC=YES
         BZ    *+8                 BRANCH IF NOT
         OI    PPWFLAG4,PPW4SYSP   INDICATE SYSPROC=YES
*
         TM    PPWSPRDF,PPWSPRTF   TEST FOR SYSPROC=FIRST
         BZ    *+8                 BRANCH IF NOT
         OI    PPWFLAG4,PPW4SYSF   INDICATE SYSPROC=FIRST
*
         B     VPPSYSDN            AND WE ARE DONE WITH SYSPROC OPTIONS
*
VPPSYSSS DS    0H
         OI    PPWENVIR,PPWESTC    SET STARTED TASK
*
         TM    PPWSPRDF,PPWSPRSY   TEST FOR SYSPROC=YES
         BZ    *+8                 BRANCH IF NOT
         OI    PPWFLAG4,PPW4SYSP   INDICATE SYSPROC=YES
*
         TM    PPWSPRDF,PPWSPRSF   TEST FOR SYSPROC=FIRST
         BZ    *+8                 BRANCH IF NOT
         OI    PPWFLAG4,PPW4SYSF   INDICATE SYSPROC=FIRST
*
         B     VPPSYSDN            AND WE ARE DONE WITH SYSPROC OPTIONS
*
         EJECT
***********************************************************************
*                                                                     *
*        DECODE THE DEFAULT SYSPROC OPTION (SUBROUTINE)               *
*                                                                     *
***********************************************************************
*
VPPSYSDF DS    0H
         CLI   0(R1),C'Y'          CHECK FOR SYSPROC=YES
         BE    0(,R14)             BRANCH IF YES
*
         CLI   0(R1),C'L'          CHECK FOR SYSPROC=LAST
         BE    0(,R14)             BRANCH IF LAST
*
         CLI   0(R1),C'A'          CHECK FOR SYSPROC=AFTER
         BE    0(,R14)             BRANCH IF AFTER
*
         CLI   0(R1),C'F'          CHECK FOR SYSPROC=FIRST
         BE    8(,R14)             BRANCH IF FIRST
*
         CLI   0(R1),C'B'          CHECK FOR SYSPROC=BEFORE
         BE    8(,R14)             BRANCH IF BEFORE
*
         CLI   0(R1),C'N'          CHECK FOR SYSPROC=NO
         BE    4(,R14)             BRANCH IF NO
*
         B     0(,R14)             ASSUME SYSPROC=YES IF NOT VALID
*
VPPSYSDN DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        FIX THE MESSAGE LEVEL IF NOT IN DEBUGGING MODE               *
*                                                                     *
***********************************************************************
*
         MVC   PPWWTOMD(PPWWTOML),VPPWTOM1 INIT THE TRACING WTO LIST
*
         TM    PPWOPTN1,PPWO1DBG   TEST FOR DEBUGGING
         BO    VPPMSGLV            BRANCH IF SO
*
         MVC   PPWWTOMD(PPWWTOML),VPPWTOMD INIT THE NORMAL WTO LIST
*
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VPPMSGLV            LEAVE ALONE IF SO
*
         TM    PPWOPTN1,PPWO1MSP   DO WE WANT TO SUPPRESS THE MESSAGES
         BZ    VPPMSGLV            LEAVE ALONE IF NOT
*
         L     R2,PPWTCBAD         LOAD THE TCB ADDRESS
         USING TCB,R2
         ICM   R2,15,TCBJSTCB      LOAD THE JOB STEP TCB ADDRESS
         BZ    VPPMSGLV            SKIP THIS IF CONTROL BLOCK MISSING
         ICM   R2,15,TCBJSCB
         BZ    VPPMSGLV            SKIP THIS IF CONTROL BLOCK MISSING
         USING IEZJSCB,R2
         ICM   R2,15,JSCBJCT       LOAD THE JCT ADDRESS
         BZ    VPPMSGLV            SKIP THIS IF CONTROL BLOCK MISSING
         LA    R2,16(,R2)          INCREMENT PAST HEADER
         USING INJMJCT,R2
*
         MODESET KEY=ZERO
*
         MVC   PPWMSGLV,JCTJMGLV   SAVE THE CURRENT MESSAGE LEVEL
         OI    PPWFLAG2,PPW2MSGL   INDICATE WE CHANGED THE MSGLEVEL
         NI    JCTJMGLV,X'0F'      FORCE MSGCLASS=(0,0)
*
         MODESET KEY=NZERO
*
         DROP  R2
*
VPPMSGLV DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        LOAD THE INCLUSION/EXCLUSION MODULE                          *
*                                                                     *
***********************************************************************
*
         CLI   PPWDSNLS,C' '       DO WE HAVE AN EXCLUSION MODULE
         BE    VPPNODSL            BRANCH IF NOT
*
         LOAD  EPLOC=PPWDSNLS,ERRET=VPPERDSL LOAD THE ERROR MODULE
*
         ST    R0,PPWDSNAD         STORE THE LOADED ADDRESS
         OI    PPWFLAG3,PPW3DSNL   INDICATE IT'S BEEN LOADED
         B     VPPNODSL            AND PUSH ON
*
VPPERDSL LA    R0,MSGNO848         POINT AT ERROR MESSAGE NUMBER
         LA    R1,PPWDSNLL         POINT AT LENGTH
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             ISSUE MESSAGE
*
VPPNODSL DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTRUCT OUR DCB AND EXTRACT THE DATA SET NAMES FROM        *
*        THE DCB PASSED TO THE CONVERTER.                             *
*                                                                     *
***********************************************************************
*
         MVC   PPWDCB(VPPDCBML),VPPDCBMD INIT DCB AREA
         LA    R1,PPWDCB           POINT AT OUR DCB
         ST    R1,PPWPPDCB         SAVE IT'S ADDRESS
*
         MVC   PPWDDSUF,VPPDDPAT   SET THE DDNAME SUFFIXES
*
         UNPK  PPWGENWK(9),PPWTCBAD(5)  UNPACK THE TCB ADDRESS
         TR    PPWGENWK(8),PPWHEXTR     CONVERT TO PRINTABLE HEX
*
         MVI   PPWDDBSE,C'P'       SET DDNAME PREFIX CHARACTER
         MVC   PPWDDBSE+1(6),PPWGENWK+2 MOVE THE TCB ADDRESS
         MVI   PPWDDBSE+7,C' '     BLANK THE LAST CHARACTER
*
***********************************************************************
*                                                                     *
*        ALTER THE BLOCKSIZE IN THE PASSED DCB TO THE MAXIMUM         *
*        POSSIBLE, SO THAT THE CONVERTER WILL OBTAIN A LARGE          *
*        BUFFER.  THIS MEANS WE DON'T HAVE TO WORRY ABOUT THE         *
*        BLOCKSIZE OF ANY USER SPECIFIED PROCLIB DATA SET.            *
*                                                                     *
***********************************************************************
*
         ICM   R1,15,PPWCNDCB      LOAD THE CONVERTER'S DCB ADDRESS
         BZ    VPPSYMSG            SKIP A LOT OF STUFF IF NULL
*
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VPPSYMSG            SKIP A LOT OF STUFF IF SO
*
         USING IHADCB,R1
         MVC   DCBBLKSI,PPWDCB+DCBBLKSI-IHADCB
         DROP  R1
*
         EJECT
***********************************************************************
*                                                                     *
*        FIND THE TIOT ENTRY FOR THE SYSTEM PROCLIB AND EXTRACT       *
*        THE ADDRESSES OF THE JFCBS FOR EACH SYSTEM PROCLIB DATA SET. *
*                                                                     *
***********************************************************************
*
         MVC   PPWSWRPL(8),VPPSWARQ     INITIALIZE SWAREQ PARM LIST
         LA    R1,PPWSWREA         POINT AT EPA POINTER
         ST    R1,PPWSWRPL         STORE IN PARAMETER LIST
         XC    PPWSWREP,PPWSWREP   CLEAR THE SWA EPA
         LA    R1,PPWSWREP         POINT AT SWA EPA
         ST    R1,PPWSWREA         STORE IN POINTER
*
         SLR   R15,R15             ZERO FOR INSERTS
         SLR   R2,R2               ZERO FOR COUNTING
*
         L     R1,PPWCNDCB         LOAD CURRENT PROCLIB DCB ADDRESS
         USING IHADCB,R1
         TM    DCBOFLGS,DCBOFOPN   IS THIS DCB OPEN
         BZ    VPPSYSMS            IF NOT, SKIP COUNTING DATA SETS
*
         SLR   R3,R3               CLEAR FOR INSERT
         ICM   R3,3,DCBTIOT        LOAD THE DCB TIOT OFFSET
         DROP  R1
*
         A     R3,PPWTIOTA         ADD THE TIOT ADDRESS
         USING TIOENTRY,R3
*
         MVC   PPWSYSDD,TIOEDDNM   SAVE THIS DDNAME FOR POSTERITY
*
VPPSYCNT DS    0H
         TM    TIOEJFCB+2,X'01'    IS THE JFCB ADDRESS REALLY A TOKEN
         BO    VPPSYS31            BRANCH IF SO
         SLR   R1,R1               CLEAR FOR THE INSERT
         ICM   R1,7,TIOEJFCB       LOAD THE ADDRESS
         LA    R1,16(,R1)          POINT AT THE ACTUAL JFCB
         B     VPPSYSTO            AND GO STORE THIS ADDRESS
*
         EJECT
***********************************************************************
*                                                                     *
*        THE JFCB IS ABOVE THE LINE, SO USE SWAREQ TO OBTAIN          *
*        THE ACTUAL ADDRESS.                                          *
*                                                                     *
***********************************************************************
*
VPPSYS31 DS    0H
         STCM  R1,7,SWVA-ZB505+PPWSWREP STORE THE SVA
         SWAREQ MF=(E,PPWSWRPL),UNAUTH=YES
         LTR   R15,R15             TEST IF SUCCESSFUL
         BNZ   VPPSYMSG            BRANCH IF NOT GOOD
*
         L     R1,SWBLKPTR-ZB505+PPWSWREP LOAD THE ACTUAL SWA BLK ADDR
*
VPPSYSTO DS    0H
         LR    R14,R2              GET PROCLIB COUNT (-1)
         SLL   R14,2               MULTIPLY BY 4
         ST    R1,PPWSYSDS(R14)    STORE THE JFCB ADDRESS
*
         LA    R2,1(,R2)           BUMP SYSTEM PROCLIB COUNT
         IC    R15,TIOELNGH        LOAD THE LENGTH
         AR    R3,R15              INCREMENT THE ADDRESS
         CLI   TIOELNGH,0          CHECK FOR LAST ENTRY
         BE    *+12                SKIP CONCATENATION LOOP IF SO
         CLI   TIOEDDNM,C' '       CHECK FOR CONCATENATION
         BE    VPPSYCNT            LOOP IF IT IS
*
         DROP  R3                  DONE WITH TIOT ENTRY
*
         LA    R0,PPWCONCM         SET MAXIMUM PROCLIBS
         SR    R0,R2               DEDUCT FOR SYSTEM PROCLIBS
         STH   R2,PPWJPSYS         SET THE SYSTEM PROCLIB COUNT
         STH   R0,PPWJPMAX         SET THE MAX USER PROCLIB COUNT
         B     VPPSYSOK            AND FINISH INITIALIZATION
*
         EJECT
***********************************************************************
*                                                                     *
*        THE SYSTEM PROCLIB WAS NOT AVAILABLE.  IGNORE IF IT IS       *
*        THE MASTER ADDRESS SPACE.  ISSUE A MESSAGE OTHERWISE.        *
*                                                                     *
***********************************************************************
*
VPPSYMSG DS    0H
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VPPSYSMS            IF SO, DON'T ISSUE MESSAGE
*
         LA    R0,MSGNO850         LOAD THE MESSAGE NUMBER
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             GO ISSUE MESSAGE
*
VPPSYSMS DS    0H
         OI    PPWFLAG3,PPW3NOSY   INDICATE SYSPROC UNAVAILABLE
         LA    R0,PPWCONCM         SET MAXIMUM PROCLIBS
         STH   R0,PPWJPMAX         STASH THE MAX
*
VPPSYSOK DS    0H
         SR    R0,R0               CLEAR R0
         STH   R0,PPWJPCNT         INITIALIZE CONCATENATION COUNT
*
         EJECT
***********************************************************************
*                                                                     *
*        INITIALIZE THE DYNAMIC ALLOCATION PARAMETERS                 *
*                                                                     *
***********************************************************************
*
         LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET ADDRESSABILITY TO DARB
*
         ST    R15,PPWDARGL        SET PTR TO DARB IN PARM LIST->
         OI    PPWDARGL,S99RBPND   SET END OF PARM LIST INDICATOR
*
         XC    PPWDARB(L'PPWDARB),PPWDARB CLEAR ALLOC REQUEST BLOCK
         MVI   S99RBLN,L'PPWDARB   SET LENGTH OF REQUEST BLOCK
*
         MVI   S99FLG11,S99ONCNV+S99NOCNV+S99NOMNT SET FLAGS 1
*              NO CONVERTIBLE, NO EXISTING ALLOC, NO VOLUME MOUNT
         TM    PPWOPTN1,PPWO1MSP   TEST IF MESSAGE SUPPRESSION WANTED
         BZ    *+8                 BRANCH IF NOT
         OI    S99FLG11,S99MSGL0   SET SUPPRESS MESSAGE FLAGS
*
         MVI   S99FLG21,S99NORES   SET NO DATA SET ENQUEUE FLAGS 2
*
         LA    R0,PPWDATXT         -> DYNAMIC ALLOCATION TEXT
         ST    R0,S99TXTPP         SET TEXT LIST PTR IN DARB
*
         DROP  R15
*
         EJECT
***********************************************************************
*                                                                     *
*        INITIALIZE THE DYNAMIC ALLOCATION TEXT UNITS                 *
*                                                                     *
***********************************************************************
*
         LA    R1,1                GET A NICE CONSTANT
*
         LA    R0,DALDDNAM         GET DDNAME KEY
         STH   R0,PPWDDNMK         SET DDNAME KEY
         STH   R1,PPWDDNM#         SET NUMBER OF OPERANDS
         LA    R0,8                GET MAX DDNAME LENGTH
         STH   R0,PPWDDNML         SET DDNAME LENGTH
*
         LA    R0,DALRTORG         GET RETURN DSORG KEY
         STH   R0,PPWRTDSK         SET RETURN DSORG KEY
         STH   R1,PPWRTDS#         SET NUMBER OF OPERANDS
         LA    R0,2                GET DSORG LENGTH
         STH   R0,PPWRTDSL         SET DSORG LENGTH
*
         LA    R0,DALDSNAM         GET DSNAME TEXT KEY
         STH   R0,PPWDSNMK         SET DSNAME TEXT KEY
         STH   R1,PPWDSNM#         SET NUMBER OF OPERANDS
*
         LA    R0,DALSTATS         GET STATUS DISP KEY
         STH   R0,PPWDISPK         SET STATUS DISP KEY
         STH   R1,PPWDISP#         SET NUMBER OF OPERANDS
         STH   R1,PPWDISPL         SET LENGTH OF DISP CODE
         MVI   PPWDISP,X'08'       SET DISP TO "SHR"
*
         LA    R0,DALCLOSE         GET FREE=CLOSE KEY
         STH   R0,PPWCLOSK         SET FREE=CLOSE KEY
         XC    PPWCLOS#,PPWCLOS#   SET NUMBER OF OPERANDS
*
         EJECT
***********************************************************************
*                                                                     *
*        INITIALIZE THE DYNAMIC CONCATENTAION PARAMETERS              *
*                                                                     *
***********************************************************************
*
         LA    R0,DCCDDNAM         GET CONCATENATE DDNAME KEY
         STH   R0,PPWCONCK         SET CONCATENATE DDNAME KEY
*
         LA    R15,PPWCONCD        POINT AT FIRST CONCAT DDNAME
         LA    R14,PPWCONCM        GET MAXIMUM NUMBER OF DDNAMES
         LA    R0,8                GET THE DDNAME LENGTH
*
VPPCONCL STH   R0,0(,R15)          STORE THE LENGTH
         LA    R15,L'PPWCONCD(,R15)     INCREMENT TO NEXT DDNAME
         BCT   R14,VPPCONCL        LOOP THROUGH THE CONCATENATION LIST
*
         EJECT
***********************************************************************
*                                                                     *
*        BUILD THE DAIRFAIL PARAMETER LIST                            *
*                                                                     *
***********************************************************************
*
         LA    R15,PPWDFPRM        -> DAIRFAIL PARM LIST
         USING DFDSECTD,R15        MAKE IT ADDRESSABLE
*
         LA    R1,PPWDARB          -> DYNAMIC ALLOCATE RB
         ST    R1,DFS99RBP         SET IN DFPL
*
         LA    R1,PPWDFRCD         -> RETURN CODE HOLDING AREA
         ST    R1,DFRCP            SET IN DFPL
*
         L     R1,CVTPTR           LOAD THE CVT ADDRESS
         USING CVT,R1
         LA    R1,CVTEFF02         GET ADDRESS OF IKJEFF02 ADDRESS
         ST    R1,DFJEFF02         SET THIS ADDRESS IN PARM LIST
         DROP  R1
*
         LA    R1,PPWDFIDN         -> DAIRFAIL IDENTIFICATION NO.
         ST    R1,DFIDP            SET IN DFPL
         OI    DFIDP,X'80'         FLAG END OF PARM LIST
*
         XC    DFCPPLP,DFCPPLP     CLEAR CPPL POINTER
*
         LA    R1,50               INDICATE SVC 99 ERROR
         STH   R1,PPWDFIDN          IN DAIRFAIL PARM LIST
*
         OI    PPWDFIDN,DFWTP      INDICATE WTP REQUEST
*
         DROP  R15
*
         EJECT
***********************************************************************
*                                                                     *
*        CLEAN UP AFTER A PREVIOUS CONVERTER FAILURE                  *
*                                                                     *
***********************************************************************
*
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VPPCLNDN            IF SO, DON'T ATTEMPT CLEANUP
*
         L     R1,PPWTIOTA         GET THE TIOT ADDRESS
         USING TIODSECT,R1         SET UP ADDRESSIBILITY
*
         SLR   R15,R15             ZERO FOR INSERTS
*
VPPCLNL1 CLI   TIOELNGH,0          CHECK FOR END OF TIOT
         BE    VPPCLNDN            BRANCH IF NAME NOT FOUND
         CLC   TIOEDDNM(7),PPWDDBSE     CHECK FOR LEFT OVER DDNAME
         BE    VPPCLNUP            IF FOUND, WE HAVE TO CLEAN UP
*
         IC    R15,TIOELNGH        LOAD THE LENGTH
         AR    R1,R15              INCREMENT ADDRESS
         B     VPPCLNL1            CONTINUE TIOT SCAN
*
VPPCLNUP DS    0H                  NEED TO CLEAN UP LEFTOVERS
         LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET DARB ADDRESSABILITY
         MVI   S99VERB,S99VRBDC    INDICATE DE-CONCAT REQUEST
         LA    R15,PPWDATXT        -> TEXT UNIT PTR SLOTS
*
         USING S99TUPL,R15         GET TEXT PTR ADDRESSABILITY
         USING S99TUNIT,R14        GET TEXT UNIT ADDRESSABILITY
*
         LA    R14,PPWCONCK        -> DE-CONCATENATE TEXT UNIT
         LA    R0,DDCDDNAM         GET DE-CONCATENATE KEY
         STH   R0,S99TUKEY         SET DE-CONCATENATE KEY
         LA    R0,1                GET THE NUMBER OF DDNAMES
         STH   R0,S99TUNUM         SET NO. OF DDNAMES
         MVC   S99TUPAR(8),TIOEDDNM     SET THE FOUND DDNAME
         ST    R14,S99TUPTR        SET PTR TO DE-CONC TEXT UNIT
         OI    S99TUPTR,S99TUPLN   FLAG END OF TEXT UNIT PTR'S
*
         DROP  R1,R14,R15
*
         LA    R1,PPWDARGL         -> DYNAMIC ALLOC PARM PTR
         OI    PPWFLAG3,PPW3DALC   INDICATE WE ARE IN ALLOC. CODE
         DYNALLOC ,                DE-CONCATENATE PROCLIB'S
         NI    PPWFLAG3,255-PPW3DALC    INDICATE WE ARE BACK
*
         EJECT
         LA    R0,DCCDDNAM         GET CONCATENATE DDNAME KEY
         STH   R0,PPWCONCK         REPAIR CONCATENATE DDNAME KEY
*
         LA    R2,PPWDDSUF         POINT AT DDNAME SUFFIX STRING
         LA    R3,PPWCONCM         GET MAXIMUM CONCATENATIONS
*
         LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET DARB ADDRESSABILITY
         MVI   S99VERB,S99VRBUN    INDICATE UNALLOC REQUEST
         LA    R15,PPWDATXT        -> TEXT UNIT PTR SLOTS
*
         USING S99TUPL,R15         GET TEXT PTR ADDRESSABILITY
         USING S99TUNIT,R14        GET TEXT UNIT ADDRESSABILITY
*
         LA    R14,PPWDDNMK        -> DDNAME TEXT UNIT
         LA    R0,DUNDDNAM         SET DDNAME TEXT KEY
         STH   R0,PPWDDNMK         SET DDNAME TEXT KEY
*
         ST    R14,S99TUPTR        SET PTR TO DDNAME TEXT UNIT
         OI    S99TUPTR,S99TUPLN   FLAG END OF TEXT UNIT PTR'S
*
         MVC   S99TUPAR(8),PPWDDBSE     MOVE THE DDNAME BASE
*
         DROP  R15
*
VPPCLNDL DS    0H
         MVC   S99TUPAR+7(1),0(R2) MOVE THE DDNAME SUFFIX
         DROP  R14
*
         LA    R1,PPWDARGL         -> DYNAMIC ALLOC PARM PTR
         OI    PPWFLAG3,PPW3DALC   INDICATE WE ARE IN ALLOC. CODE
         DYNALLOC ,                FREE A PROCLIB DATA SET
         NI    PPWFLAG3,255-PPW3DALC    INDICATE WE ARE BACK
*
         LA    R2,1(,R2)           INCREMENT THE SUFFIX POINTER
         BCT   R3,VPPCLNDL         LOOP THROUGH DEALLOCATION
*
         LA    R0,DALDDNAM         GET DDNAME KEY
         STH   R0,PPWDDNMK         REPAIR DDNAME KEY
*
VPPCLNDN DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        RECONSTRUCT THE INTERNAL TEXT EXIT LIST                      *
*                                                                     *
***********************************************************************
*
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VPPNPOST            DON'T CHANGE ANYTHING IF SO
*
         ICM   R1,15,PPWCNTXT      LOAD ADDRESS OF PASSED TXT EXIT LIST
         BZ    VPPNPOST            IF NONE, THERE IS NO INTERCEPT
         USING CNPREXIT,R1
*
         MVC   PPWEXLST,CNPREXIT   SAVE A COPY OF THIS LIST
*
         MVC   PPWPPLST,CNPREXIT   MAKE A COPY TO MODIFY
         LA    R1,PPWPPLST         POINT AT OUR COPY
         ST    R1,PPWPPTXT         SAVE OUR ADDRESS
*
         L     R0,=A(IEFCNVPS+X'80000000') LOAD OUR POST SCAN EXIT ADDR
         ST    R0,CNPREXAD         STORE OUR ADDRESS
         MVI   CNPRLKID,CNPRXADD   INDICATE A 31-BIT ADDRESS
*
         L     R15,PPWPMTXT        POINT AT PARAMETER LIST
         ST    R1,0(,R15)          MODIFY THE PARAMETER LIST
*
         OI    PPWFLAG2,PPW2PSEI   INDICATE INTERCEPT IS IN PLACE
*
         DROP  R1
*
VPPNPOST DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        PASS CONTROL TO THE ORIGINAL CONVERTER ENTRY POINT           *
*                                                                     *
***********************************************************************
*
         OI    PPWFLAG3,PPW3INIT   INDICATE CNVPP HAS FINISHED INIT
*
         NI    PPWVPPFL,255-PPWVPPEX    TURN OFF IEFCNVPP EXECUTING
         OI    PPWCFLG1,PPWC1INT   INDICATE WE ARE GOING TO IEFCNINT
*
         L     R1,PPWINTR1         COPY THE ORIGINAL PARM ADDRESS
         L     R15,=V(IEFCNINT)    LOAD ADDRESS OF CONVERTER ENTRY PT
         BALR  R14,R15             AND GO THE THE REAL CONVERTER
*
         ST    R15,PPWINTRC        SAVE THE CONVERTER RETURN CODE
*
         OI    PPWVPPFL,PPWVPPEX   INDICATE WE ARE BACK
         NI    PPWCFLG1,255-PPWC1INT    INDICATE WE'RE BACK FROM CNINT
*
***********************************************************************
*                                                                     *
*        CLEAN UP IN CASE IF WE DID ANYTHING                          *
*                                                                     *
***********************************************************************
*
         L     R15,=A(IEFCNVCL)    POINT AT CLEAN UP SUBROUTINE
         BALR  R14,R15             GO CLEAN UP IF NECESSARY
*
         EJECT
***********************************************************************
*                                                                     *
*        FREE ANY CNMBS THAT HAVEN'T BEEN PASSED TO THE CONVERTER     *
*                                                                     *
***********************************************************************
*
         L     R2,PPWCNMB          LOAD FIRST CNMB ADDRESS
         USING CNMB,R2
*
VPPCNMBL LTR   R1,R2               COPY THE ADDRESS FOR FREEING
         BZ    VPPCNMBN            BRANCH IF NONE LEFT
*
         LH    R0,CNMBLEN          LOAD THE CNMB'S LENGTH
         SLR   R14,R14             CLEAR FOR INSERT
         ICM   R14,1,CNMBSUBP      LOAD THE CNMB'S SUBPOOL
         L     R2,CNMBNPTR         CHAIN TO THE NEXT CNMB
*
         FREEMAIN RU,A=(1),LV=(0),SP=(R14) FREE THE CNMB
*
         B     VPPCNMBL            AND GO FREE NEXT ONE
         DROP  R2                  DONE WITH CNMBS
*
VPPCNMBN DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        FREE THE WORK AREA AND RETURN TO THE CALLER (JES2/3)         *
*                                                                     *
***********************************************************************
*
         L     R1,PPWFSAAD         LOAD THE FIRST SAVE AREA ADDRESS
         USING FSADSECT,R1
*
         MVC   FSAPPEYE,PPWFSAR2   RESTORE THE ORIGINAL R2
         MVC   FSAPPWAD,PPWFSAR3   RESTORE THE ORIGINAL R3
         DROP  R1
*
         SLR   R2,R2               INITIALIZE RETURN CODE
         TM    PPWFLAG1,PPW1JPER   DID WE ENCOUNTER ANY ERRORS
         BZ    *+8                 BRANCH IF NOT
         LA    R2,4                SET ERROR RETURN CODE
*
         CL    R2,PPWINTRC         CHECK OUR RETURN CODE AGAINST CNV'S
         BNL   *+8                 BRANCH IF OUR'S HIGHER
         L     R2,PPWINTRC         LOAD THE CONVERTER'S RETURN CODE
*
         LR    R1,R13              COPY THE WORK AREA ADDRESS
         L     R0,PPWWORKL         LOAD THE GOTTEN AREA LENGTH
*
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
*
         FREEMAIN RU,LV=(0),A=(1)  FREE THE GOTTEN AREA
*
         L     R14,12(,R13)        RELOAD RETURN ADDRESS
         LR    R15,R2              COPY THE CONVERTER RETURN CODE
         LM    R0,R12,20(R13)      RELOAD REGS 0 - 12
         BSM   R0,R14              RETURN TO CALLER
*
         DROP  ,                   KILL ALL ADDRESSIBILITY
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS AND DATA AREAS USED BY IEFCNVPP                    *
*                                                                     *
***********************************************************************
*
VPPDCBMD DCB   DDNAME=********,    PATTERN DCB                         X
               DSORG=PO,                                               X
               MACRF=(R),                                              X
               BUFNO=0,                                                X
               BUFCB=0,                                                X
               BLKSIZE=32767/80*80,                                    X
               RECFM=FB,                                               X
               LRECL=80
VPPDCBML EQU   *-VPPDCBMD          PATTERN DCB LENGTH
*
VPPSWARQ SWAREQ FCODE=LA,EPA=*-*,UNAUTH=YES,MF=L
*
VPPWTOMD WTO   '',                 NORMAL WTO PARAMETER LIST           X
               ROUTCDE=11,DESC=6,MF=L
*
VPPWTOM1 WTO   '',                 DEBUGGING WTO PARAMETER LIST        X
               ROUTCDE=1,DESC=6,MF=L
*
VPPDDPAT DC    C'0123456789ABCDEF' CHARACTER STRING FOR HEX TRANSLATE
*
VPPPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVPP PATCH'
         DC    16F'0'
*
VPPLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVGS - INTERCEPT INITIAL JCL STATEMENT PARSE'
***********************************************************************
*                                                                     *
*        IEFCNVGS                                                     *
*        ********                                                     *
*                                                                     *
*        THIS ROUTINE RECEIVES CONTROL FROM THE CONVERTER WHEN A JCL  *
*        STATEMENT IS BEING CONSTRUCTED AND INITIALLY PARSED FROM     *
*        THE JCL CARD IMAGES.                                         *
*                                                                     *
*        THIS ROUTINE PASSES CONTROL TO THE STANDARD CONVERTER        *
*        ROUTINE (IEFCNGST).  UPON RETURN, IT DETERMINES IF THE       *
*        STATEMENT JUST BUILT IS A DYNAMIC PROCLIB DD STATEMENT       *
*        OR CONCATENATION.                                            *
*                                                                     *
*        INPUT:                                                       *
*              PARAMETER LIST FROM CALLER                             *
*                                                                     *
*        OUTPUT:                                                      *
*              NONE                                                   *
*                                                                     *
*        EXTERNAL REFERENCES:                                         *
*              IEFCNGST (ORIGINAL ROUTINE CONVERTER WAS CALLING)      *
*              IEFCNVXT (SPECIAL PROCESSING ROUTINE)                  *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER                                       *
*                                                                     *
***********************************************************************
*
IEFCNVGS DS    0D
         ENTRY IEFCNVGS            NEED ENTRY POINT FOR LINK EDIT
         USING *,R15               TEMPORARY BASE
         B     VGSSTM              BRANCH AROUND ID
*
         DC    AL1(VGSIDL)         LTH OF IDENTIFICATION PREFIX
VGSID    DC    CL8'IEFCNVGS'       USER PROCLIB SUPPORT MODULE ID
VGSIDL   EQU   *-VGSID             LENGTH OF IDENTIFICATION HEADER
*
VGSSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVGS,R12        ESTABLISH PERMANENT BASE
*
         L     R15,PSATOLD-PSA     LOAD THE TCB ADDRESS
         USING TCB,R15
         L     R15,TCBFSA          LOAD THE FIRST SAVE AREA ADDRESS
         USING FSADSECT,R15
*
         CLC   FSAPPEYE,=A(FSAPPEID)    IS THIS THE RIGHT SAVE AREA
         BE    VGSCONT             IF SO, CONTINUE ON
*
         L     R14,12(,R13)        THIS IS NOT SO GOOD, SO GET OUT
         L     R15,=V(IEFCNGST)    THIS IS WHERE WE GIVE UP
         LM    R0,R12,20(R13)      RESTORE THE REST OF THE REGISTERS
         BR    R15                 AND PASS ON TO IEFCNGST W/O RETURN
*
         EJECT
***********************************************************************
*                                                                     *
*        ESTABLISH THE SAVE AREA AND WORK AREA ADDRESS FROM           *
*        THE ANCHORED WORK AREA.                                      *
*                                                                     *
***********************************************************************
*
VGSCONT  DS    0H
         L     R15,FSAPPWAD        LOAD THE WORK AREA ADDRESS
         USING PPWDSECT,R15
         LA    R15,PPWVGSSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVGSSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVGSCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVGSCN        STORE IT BACK
*
         NI    PPWCFLG1,255-PPWC1INT    INDICATE WE AREN'T IN KANSAS
*
         OI    PPWVGSFL,PPWVGSEX   INDICATE WE ARE HERE
*
         ST    R1,PPWGSTR1         SAVE THE REGISTER 1 AT OUR ENTRY
*
         EJECT
***********************************************************************
*                                                                     *
*        CHECK FOR THIS BEING THE FIRST TIME HERE                     *
*                                                                     *
***********************************************************************
*
         LA    R0,1                LOAD A 1
         CL    R0,PPWVGSCN         CHECK IF THIS IS THE VERY FIRST TIME
         BNE   VGSNFRST            BRANCH IF NOT
*
         TM    PPWENVIR,PPWEMSTR   ARE WE MASTERING IT
         BO    VGSNFRST            IF SO, SKIP THIS STUFF
*
***********************************************************************
*                                                                     *
*        ESTABLISH AN ESTAE, SO THAT ANY CONVERTER ABENDS WILL        *
*        FUNNEL THROUGH US FOR CLEANUP.                               *
*                                                                     *
***********************************************************************
*
         MVC   PPWESTAE(PPWESTAL),VGSESTAE COPY ESTAE PARM LIST
*
         L     R15,PPWWORKA        LOAD BASE WORK AREA ADDRESS
         ESTAE PARAM=(R15),        CREATE THE ESTAE ENVIRONMENT        X
               MF=(E,PPWESTAE)
*
         OI    PPWFLAG3,PPW3ESTA   INDICATE ESTAE IN FORCE
*
***********************************************************************
*                                                                     *
*        CALL THE ROUTINE TO EXTRACT SENSITIVE CONVERTER ADDRESSES    *
*                                                                     *
***********************************************************************
*
         SLR   R0,R0               SET CODE FOR DATA EXTRACT
         L     R15,PPWCNVXT        LOAD THE EXTRACT SUBROUTINE ADDRESS
         BALR  R14,R15             CALL THE EXTRACT SUBROUTINE
*
VGSNFRST DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        PASS CONTROL TO THE IEFCNGST FOR NORMAL CONVERTER PROCESSING *
*                                                                     *
***********************************************************************
*
VGSLOOP  DS    0H
         L     R15,PPWGSTCN        COUNT THE CALLS TO IEFCNGST
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWGSTCN        STORE IT BACK
*
         IEFCNTRC CALLGST
*
         LA    R0,8                INDICATE DATA UPDATE
         SLR   R1,R1               INDICATE TOTAL UPDATE
         L     R15,PPWCNVXT        LOAD UPDATE ROUTINE ADDRESS
         BALR  R14,R15             GO DO THE UPDATE
*
         NI    PPWVGSFL,255-PPWVGSEX    TURN OFF IEFCNVGS EXECUTING
         OI    PPWCFLG1,PPWC1GST   INDICATE WE ARE GOING TO IEFCNGST
*
         L     R1,PPWGSTR1         LOAD THE REGISTER 1 AT OUR ENTRY
         L     R15,=V(IEFCNGST)    LOAD ADDRESS OF IEFCNGST ENTRY PT
         BALR  R14,R15             AND GO THE THE REAL CONVERTER
*
         ST    R15,PPWGSTRC        SAVE THE IEFCNGST RETURN CODE
*
         OI    PPWVGSFL,PPWVGSEX   INDICATE WE ARE BACK
         NI    PPWCFLG1,255-PPWC1GST    INDICATE WE'RE BACK FROM CNGST
*
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VGSEXIT             IF SO, LEAVE QUICKLY
*
         LA    R0,4                INDICATE STATEMENT EXTRACT
         L     R15,PPWCNVXT        LOAD UPDATE ROUTINE ADDRESS
         BALR  R14,R15             GO EXTRACT DATA
*
         EJECT
***********************************************************************
*                                                                     *
*        DETERMINE IF THIS IS A JCL STATEMENT THAT WE ARE INTERESTED  *
*        IN.                                                          *
*                                                                     *
***********************************************************************
*
         ICM   R15,15,PPWGSTRC     LOAD GST RETURN CODE
         BNZ   VGSEXIT             SKIP STATEMENT IF INVALID
*
         CLC   PPWSTMVR,=CL8'DD'   CHECK FOR DD
         BNE   VGSNOTDD
*
         TM    PPWFLAG2,PPW2NJBP   ARE WE THROUGH NEEDING TO ANALYZE
         BO    VGSISDD             IF SO, WE NEED TO CHECK FOR DUPS
*
         CLI   PPWSTMLL+1,0        CHECK FOR NO LENGTH (CONCAT)
         BNE   VGSNOTCN            BRANCH IF NOT
*
         TM    PPWFLAG2,PPW2JBPR   ARE WE PROCESSING A JOBPROC
         BZ    VGSISDD             BRANCH IF NOT
*
         TM    PPWOPTN1,PPWO1JPR   IS JOBPROC DD ENABLED
         BZ    VGSNOTDD            DON'T CHECK IF NOT
*
         OI    PPWFLAG2,PPW2JBPC   INDICATE A CONCATENTAION
*
         B     VGSJPROC            AND PROCESS THIS STATEMENT
*
VGSNOTCN DS    0H
         CLC   PPWJBPRC,PPWSTMLA   MATCH THE NAMES
         BNE   VGSISDD             BRANCH IF NOT JOBPROC DD
*
         TM    PPWOPTN1,PPWO1JPR   IS JOBPROC DD ENABLED
         BZ    VGSNOTDD            DON'T CHECK IF NOT
*
         TM    PPWFLAG2,PPW2JBPR   ARE WE ALREADY PROCESSING ONE
         BO    VGSER836            IF SO, WE BE BAD
*
         OI    PPWFLAG2,PPW2JBPR   INDICATE WE ARE JOBPROCING
*
         TM    PPWFLAG2,PPW2JCLB   HAVE WE HAD A JCLLIB
         BO    VGSER837            IF SO, TREAT AS AN ERROR
*
         EJECT
***********************************************************************
*                                                                     *
*        PROCESS THE JOBPROC DD STATEMENT                             *
*                                                                     *
***********************************************************************
*
VGSJPROC DS    0H
         L     R15,=A(IEFCNVJP)    LOAD JOBPROC ROUTINE ADDRESS
         BALR  R14,R15             GO ANALYZE/ALLOCATE JOBPROC DATASET
*
         LTR   R15,R15             WAS THERE AN ERROR
         BZ    VGSLOOP             BRANCH IF NOT - MAKE STATEMENT GONE
*
         LA    R0,8                INDICATE STATEMENT UPDATE
         LH    R1,=H'-1'           INDICATE ERROR UPDATE
         L     R15,PPWCNVXT        LOAD UPDATE ROUTINE ADDRESS
         BALR  R14,R15             GO UPDATE THE STATEMENT
*
         B     VGSEXIT             AND LET THE CONVERTER BARF
*
         EJECT
***********************************************************************
*                                                                     *
*        CHECK FOR OTHER DD STATEMENTS WE ARE INTERESTED IN           *
*                                                                     *
***********************************************************************
*
VGSISDD  DS    0H
         CLC   PPWJBPRC,PPWSTMLA   MATCH THE NAMES
         BE    VGSER836            MISPLACED JOBPROC IF MATCHED
*
         TM    PPWOPTN1,PPWO1SDD   DO WE SUPPORT THE SWA DDNAMES
         BZ    VGSDDNSW            BRANCH IF NOT
*
         CLC   PPWSTMTL,=H'5'      IS THE DATA EXACTLY 5 LONG
         BNE   VGSDDNSW            IF NOT, CAN'T BE SPECIAL DD
*
         L     R15,PPWSTMTX        LOAD THE DATA ADDRESS
         CLC   0(5,R15),=C'DUMMY'  IS THIS A DD DUMMY
         BNE   VGSDDNSW            IF NOT, CAN'T BE SPECIAL DD
*
         CLC   PPWSTMLA,PPWSWAAD   IS THIS SWAABOVE
         BE    VGSDDSWA            BRANCH IF SO
         CLC   PPWSTMLA,PPWSWABD   IS THIS SWABELOW
         BNE   VGSDDNSW            BRANCH IF NOT
*
         OI    PPWFLAG4,PPW4SWAB   TURN ON SWA BELOW THE LINE
         NI    PPWFLAG4,255-PPW4SWAA    MAKE SURE SWA ABOVE IS OFF
         LA    R1,VGSBELOL         POINT AT BELOW MESSAGE
         B     VGSDDSWM            AND GO ISSUE MESSAGE
*
VGSDDSWA OI    PPWFLAG4,PPW4SWAA   TURN ON SWA ABOVE THE LINE
         NI    PPWFLAG4,255-PPW4SWAB    MAKE SURE SWA BELOW IS OFF
         LA    R1,VGSABOVL         POINT AT ABOVE MESSAGE
*
VGSDDSWM DS    0H
         LA    R0,MSGNO832         POINT AT INFORMATION MESSAGE
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE
         BALR  R14,R15             ISSUE MESSAGE
*
         B     VGSLOOP             AND MAKE DD STATEMENT DISAPPEAR
*
VGSDDNSW DS    0H
         B     VGSEXIT             WE AREN'T INTERESTED IN THIS ONE
*
         EJECT
***********************************************************************
*                                                                     *
*        ANALYZE JCL STATEMENT THAT IS NOT A DD STATEMENT             *
*                                                                     *
***********************************************************************
*
VGSNOTDD DS    0H
         CLC   PPWSTMVR,=CL8'IF'   CHECK FOR IF
         BE    VGS1EXEC
*
VGSNOTIF DS    0H
         CLC   PPWSTMVR,=CL8'EXEC' CHECK FOR EXEC
         BNE   VGSNOTEX            BRANCH IF NOT
         TM    PPWENVIR,PPWESTC    IS THIS A STARTED TASK
         BZ    VGS1EXEC            BRANCH IF NOT
         B     VGSSTCEX            AND BRANCH IF IT IS
*
VGSNOTEX DS    0H
         CLC   PPWSTMVR,=CL8'JCLLIB'    CHECK FOR INCLUDE
         BNE   VGSNOTJC
*
         TM    PPWFLAG2,PPW2JBPR   DO WE HAVE A JOBPROC DD
         BO    VGSER838            IF SO, THIS IS AN ERROR
*
         OI    PPWFLAG2,PPW2JCLB   INDICATE WE HAVE A JCLLIB STATEMENT
         B     VGSEXIT
*
VGSNOTJC DS    0H
         CLC   PPWSTMVR,=CL8'INCLUDE'   CHECK FOR INCLUDE
         BE    VGS1EXEC
*
VGSNOTIN DS    0H
         CLC   PPWSTMVR,=CL8'JOB'  CHECK FOR A JOB CARD
         BE    VGSJOBCD            BRANCH IF SO
*
         B     VGSNOTJP
*
         EJECT
***********************************************************************
*                                                                     *
*        THIS IS A JOB STATEMENT - WE MAY NEED TO SCAN FOR SWA        *
*                                                                     *
***********************************************************************
*
VGSJOBCD DS    0H
         TM    PPWOPTN1,PPWO1SWA   IS THE SWA KEYWORD OPTION AVAILABLE
         BZ    VGSEXIT             IF NOT, WE ARE DONE
*
         LA    R1,PPWSWAKL         POINT AT SWA KEYWORD LENGTH
         L     R15,PPWCNVKW        LOAD KEYWORD SCAN ROUTINE ADDRESS
         BALR  R14,R15             GO SCAN FOR THE SWA KEYWORD
*
         B     *+4(R15)            DETERMINE WHAT THE RESULTS ARE
         B     VGSJBSWA          0 BRANCH IF SWA KEYWORD FOUND
         B     VGSEXIT           4 SYNTAX ERROR - LET CONVERTER JCL ERR
         B     VGSEXIT           8 NOT FOUND - DO NOTHING
*
***********************************************************************
*                                                                     *
*        WE HAVE FOUND THE SWA KEYWORD ON THE JOB STATEMENT           *
*                                                                     *
***********************************************************************
*
VGSJBSWA DS    0H
         LH    R15,PPWSWAKL        LOAD THE SWA KEYWORD LENGTH
         LA    R15,1(R15,R1)       POINT AT START OF SWA DATA
*
         LR    R14,R1              COPY THE STARTING ADDRESS
         AR    R14,R0              POINT AT END
         SR    R14,R15             GET LENGTH OF SWA KEYWORD DATA
*
         EJECT
***********************************************************************
*                                                                     *
*        VALIDATE THE SWA PARAMETER VALUE                             *
*                                                                     *
***********************************************************************
*
VGSSWAKW DS    0H
         CH    R14,VGSABOVL        CHECK FOR VALID LENGTH
         BNE   VGSNTABV            BRANCH IF NOT ABOVE
*
         CLC   VGSABOVE,0(R15)     CHECK FOR SWA=ABOVE
         BNE   VGSNTABV            IF NOT, MAYBE IT'S BELOW
*
         OI    PPWFLAG4,PPW4SWAA   INDICATE SWA ABOVE THE LINE
         NI    PPWFLAG4,255-PPW4SWAB    TURN OFF POSSIBLE SWA BELOW
         B     VGSWADEL            AND GO DELETE THE KEYWORD
*
VGSNTABV DS    0H
         CH    R14,VGSBELOL        CHECK FOR VALID LENGTH
         BNE   VGSER831            BRANCH IF NOT BELOW
*
         CLC   VGSBELOW,0(R15)     CHECK FOR SWA=BELOW
         BNE   VGSER831            IF NOT, ERROR
*
         OI    PPWFLAG4,PPW4SWAB   INDICATE SWA BELOW THE LINE
         NI    PPWFLAG4,255-PPW4SWAA    TURN OFF POSSIBLE SWA ABOVE
         B     VGSWADEL            AND GO DELETE THE KEYWORD
*
***********************************************************************
*                                                                     *
*        CALL SUBROUTINE TO DELETE THE SWA KEYWORD STRING             *
*                                                                     *
***********************************************************************
*
VGSWADEL DS    0H
         L     R15,PPWCNVPD        LOAD PARM DELETE ROUTINE ADDRESS
         BALR  R14,R15             GO EDLETE THE PARAMETER
*
         LA    R1,VGSABOVL         POINT AT ABOVE MESSAGE
         TM    PPWFLAG4,PPW4SWAA   ARE WE ABOVING IT
         BO    *+8                 BRANCH IF SO
         LA    R1,VGSBELOL         POINT AT BELOW MESSAGE
*
         LA    R0,MSGNO832         POINT AT INFORMATION MESSAGE
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE
         BALR  R14,R15             ISSUE MESSAGE
         B     VGSEXIT             AND CONTINUE ON AS IF NOTHING
*
         EJECT
***********************************************************************
*                                                                     *
*        ENCOUNTERED AN EXEC STATEMENT ASSOCIATED WITH A STARTED TASK *
*                                                                     *
***********************************************************************
*
VGSSTCEX DS    0H
         TM    PPWOPTN1,PPWO1STC   IS THE STC JCLLIB OPTION AVAILABLE
         BZ    VGS1EXEC            IF NOT, GO TO FIRST EXEC
*
         TM    PPWFLAG2,PPW2NJBP   HAVE WE GOTTEN TO THE FIRST EXEC
         BO    VGSEXIT             IF SO, WE BE DONE
*
         LA    R1,PPWSTCKL         POINT AT STC JCLLIB KEYWORD LENGTH
         L     R15,PPWCNVKW        LOAD KEYWORD SCAN ROUTINE ADDRESS
         BALR  R14,R15             GO SCAN FOR THE SWA KEYWORD
*
         B     *+4(R15)            DETERMINE WHAT THE RESULTS ARE
         B     VGSEXJCL          0 BRANCH IF JCLLIB KEYWORD FOUND
         B     VGS1EXEC          4 SYNTAX ERROR - LET CONVERTER JCL ERR
         B     VGS1EXEC          8 NOT FOUND - DO NOTHING
*
***********************************************************************
*                                                                     *
*        WE HAVE FOUND THE STC JCLLIB KEYWORD ON THE EXEC STATEMENT   *
*                                                                     *
***********************************************************************
*
VGSEXJCL DS    0H
         LH    R15,PPWSTCKL        LOAD THE JCLLIB KEYWORD LENGTH
         LA    R15,1(R15,R1)       POINT AT START OF JCLLIB DATA
*
         LR    R14,R1              COPY THE STARTING ADDRESS
         AR    R14,R0              POINT AT END
         SR    R14,R15             GET LENGTH OF JCLLIB KEYWORD DATA
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTRUCT A DSN=.... STRING FOR LATER SCANNING               *
*                                                                     *
***********************************************************************
*
         MVC   PPWKEYWD(4),=C'DSN='     SET DATA SET NAME KEYWORD
         LTR   R14,R14             IS DATA SET NAME NULL
         BZ    VGSEXNUL            BRANCH IF SO
*
         BCTR  R14,0               DECREMENT FOR MOVE INSTRUCTION
         EX    R14,VGSMVDSN        MOVE THE DATA SET NAME
         LA    R14,1(,R14)         INCREMENT LENGTH BACK
*
VGSEXNUL DS    0H
         LA    R14,4(,R14)         ADD THE DSN KEYWORD LENGTH
         STH   R14,PPWKEYWL        SAVE THIS LENGTH
*
***********************************************************************
*                                                                     *
*        DELETE THE JCLLIB PARAMETER FROM THE TEXT                    *
*                                                                     *
***********************************************************************
*
         L     R15,PPWCNVPD        LOAD PARM DELETE ROUTINE ADDRESS
         BALR  R14,R15             GO DELETE THE PARAMETER
*
         EJECT
***********************************************************************
*                                                                     *
*        PROCESS THE EXTRACTED DATA SET NAME                          *
*                                                                     *
***********************************************************************
*
         LA    R1,PPWKEYWD         POINT AT DSN KEYWORD
         ST    R1,PPWSTMTX         SET THE NEW TEXT POINTER
         LH    R1,PPWKEYWL         LOAD THE DSN KEYWORD LENGTH
         STH   R1,PPWSTMTL         STORE THE NEW LENGTH
*
         LA    R0,MSGNO857         POINT AT EXTRACTED TEXT
         LA    R1,PPWKEYWL         POINT AT TEXT LENGTH
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             DISPLAY EXTRACTED TEXT
*
         MVC   PPWSTMLL,PPWSTCKL   SET JCLLIB KEYWORD LENGTH
         MVC   PPWSTMLA,PPWSTCKW   SET JCLLIB KEYWORD VALUE
*
         L     R15,=A(IEFCNVJP)    LOAD JOBPROC PROCESSOR ADDRESS
         BALR  R14,R15             GO PROCESS THE KEYWORD
*
         B     VGS1EXEC            AND PROCESS THE FIRST EXEC STATEMENT
*
VGSMVDSN MVC   PPWKEYWD+4(*-*),0(R15)   *** EXECUTE ONLY ***
*
         EJECT
***********************************************************************
*                                                                     *
*        FIRST STATEMENT AFTER A JOBPROC DD OR FIRST "EXEC" STATEMENT *
*        ENCOUNTERED.                                                 *
*                                                                     *
***********************************************************************
*
VGSNOTJP DS    0H
         TM    PPWFLAG2,PPW2JBPR   ARE WE IN JOBPROC PROCESSING
         BZ    VGSEXIT             IF NOT, WE AREN'T INTERESTED
*
VGS1EXEC OI    PPWFLAG2,PPW2NJBP   INDICATE STATEMENT AFTER JOBPROC
*
         TM    PPWFLAG2,PPW2CMPL   ARE WE COMPLETE HERE
         BO    VGSEXIT             IF SO, LEAVE NOW
*
         L     R15,=A(IEFCNVEX)    LOAD FIRST EXEC ROUTINE ADDRESS
         BALR  R14,R15             GO COMPLETE JOBPROC SETUP
*
         NI    PPWFLAG2,255-PPW2JBPR-PPW2JBPC TURN OFF JOBPROC FLAGS
         B     VGSEXIT             AND EXIT
*
         EJECT
***********************************************************************
*                                                                     *
*        ERRORS ENCOUNTERED HERE                                      *
*                                                                     *
***********************************************************************
*
VGSER831 DS    0H
         LA    R0,MSGNO831         INVALID SWA PARAMETER
         B     VGSERRNS
*
VGSER836 DS    0H
         LA    R0,MSGNO836         MISPLACED OR DUPLICATE JOBPROC
         B     VGSERRNS
*
VGSER837 DS    0H
         LA    R0,MSGNO837         JOBPROC NOT ALLOWED WHEN JCLLIB USED
         B     VGSERRNS            GO PRODUCE ERROR MESSAGE
*
VGSER838 DS    0H
         LA    R0,MSGNO838         JCLLIB NOT ALLOWED WHEN JOBPROC USED
         B     VGSERRNS            GO PRODUCE ERROR MESSAGE
*
VGSERRNS DS    0H
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             PRODUCE ERROR MESSAGE
*
         B     VGSEXIT             RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO CALLER (IEFCNJRT)                                  *
*                                                                     *
***********************************************************************
*
VGSEXIT  DS    0H
         TM    PPWENVIR,PPWEESA4   TEST FOR A VERSION 4 BCP
         BO    VGSEXIT1            IF SO, LET THE CONVERTER CONTINUE
*
         TM    PPWFLAG1,PPW1NULL  HAS THE NULL STATEMENT BEEN RECEIVED
         BZ    VGSLOOP            RETRY WITH NEXT STATEMENT IF NOT
*
VGSEXIT1 DS    0H
         NI    PPWVGSFL,255-PPWVGSEX    TURN OFF IEFCNVGS EXECUTING
*
         OI    PPWCFLG1,PPWC1INT   INDICATE RETURN TO CONVERTER
*
         L     R15,PPWGSTRC        LOAD THE RETURN CODE
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         L     R14,12(,R13)        RELOAD RETURN ADDRESS
         LM    R0,R12,20(R13)      RELOAD REGS 0 - 12
         BR    R14                 RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS AND DATA AREAS USED BY IEFCNVGS                    *
*                                                                     *
***********************************************************************
*
VGSABOVL DC    Y(L'VGSABOVE)       LENGTH OF ABOVE
VGSABOVE DC    C'ABOVE'            ABOVE THE LINE
*
VGSBELOL DC    Y(L'VGSBELOW)       LENGTH OF BELOW
VGSBELOW DC    C'BELOW'            BELOW THE LINE
*
VGSESTAE ESTAE IEFCNVST,CT,        MODEL                               X
               TERM=YES,            ERROR                              X
               PARAM=*-*,            RECOVERY                          X
               MF=L                   ENVIRONMMENT
*
VGSPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVGS PATCH'
         DC    16F'0'
*
VGSLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVJP - SCAN AND ALLOCATE JOBPROC DATA SETS'
***********************************************************************
*                                                                     *
*        IEFCNVJP                                                     *
*        ********                                                     *
*                                                                     *
*        THE ROUTINE RECEIVES CONTROL FROM IEFCNVGS TO PROCESS        *
*        A JOBPROC DD (OR CONCATENATION).                             *
*                                                                     *
*        INPUT:                                                       *
*              DATA IN THE WORK AREA                                  *
*                                                                     *
*        OUTPUT:                                                      *
*              ALLOCATED DYNAMIC PROCLIB DATA SET                     *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER (R15 IS RETURN CODE)                  *
*                                                                     *
***********************************************************************
*
IEFCNVJP DS    0D
         USING *,R15               TEMPORARY BASE
         B     VJPSTM              BRANCH AROUND ID
*
         DC    AL1(VJPIDL)         LTH OF IDENTIFICATION PREFIX
VJPID    DC    CL8'IEFCNVJP'       USER PROCLIB SUPPORT MODULE ID
VJPIDL   EQU   *-VJPID             LENGTH OF IDENTIFICATION HEADER
*
VJPSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVJP,R12        ESTABLISH PERMANENT BASE
*
         LR    R15,R13             COPY THE CURRENT SAVE AREA ADDRESS
         N     R15,=X'FFFFF000'    ROUND BACK TO A PAGE BOUNDARY
         USING PPWDSECT,R15
         LA    R15,PPWVJPSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVJPSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVJPCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVJPCN        STORE IT BACK
*
         LA    R15,VJPEXIT         POINT AT RECOVERY ADDRESS
         ST    R15,PPWVJPRT        STORE IN RETRY ADDRESS
*
         OI    PPWVJPFL,PPWVJPEX   INDICATE WE ARE HERE
*
         EJECT
***********************************************************************
*                                                                     *
*        SET UP FOR THE PARAMETER SCAN                                *
*                                                                     *
***********************************************************************
*
         OI    PPWFLAG1,PPW1HVJP   INDICATE WE HAVE A JOBPROC
*
         CLC   PPWSTMLL,=H'0'      MISSING DDNAME = CONCATENATION
         BNE   *+8                 BRANCH IF NOT
         OI    PPWFLAG1,PPW1CNJP   SHOW CONCATENATED USER FILES
*
         XC    PPWDSNML,PPWDSNML   CLEAR DSNAME LENGTH TO ZEROS
         MVI   PPWDSNME,C' '       CLEAR DSNAME AREA
         MVC   PPWDSNME+1(43),PPWDSNME    TO BLANKS
*
         TM    PPWFLAG1,PPW1JPER   PREVIOUS ERROR NOTED ?
         BO    VJPEXIT             YES, JUST EXIT
*
         MVI   PPWSTMT1,0          CLEAR STATEMENT STATUS FLAGS
*
         EJECT
***********************************************************************
*                                                                     *
*        SEE IF THE SYSPROC PARAMETER WAS CODED                       *
*                                                                     *
***********************************************************************
*
         LA    R1,PPWSYSPL         POINT AT SYSPROC KEYWORD LENGTH
         L     R15,PPWCNVKW        LOAD THE SCAN ROUTINE ADDRESS
         BALR  R14,R15             GO SCAN FOR KEYWORD
*
         B     *+4(R15)            DETERMINE RESULTS
         B     VJPSYSPR          0 BRANCH IF FOUND
         B     VJPER800          4 SYNTAX ERROR IN STATEMENT
         B     VJPNSYSP          8 SYSPROC NOT FOUND
*
***********************************************************************
*                                                                     *
*        ANALYZE THE SYSPROC KEYWORD PARAMETER                        *
*                                                                     *
***********************************************************************
*
VJPSYSPR DS    0H
         TM    PPWFLAG1,PPW1CNJP   PRIMARY JOBPROC STATEMENT ?
         BO    VJPER801            NO -> ERROR, SYSPROC NOT VALID
*
         AH    R1,PPWSYSPL         ADD THE KEYWORD LENGTH
         LR    R15,R0              COPY LENGTH
         SH    R15,PPWSYSPL        SUBTRACT KEYWORD LENGTH
         BCT   R15,*+8             REDUCE BY ONE MORE
         B     VJPER843            INVALID IF NULL
*
         CH    R15,=Y(VJPSYSP#)    CHECK MAXIMUM LENGTH
         BH    VJPER843            ERROR IF TOO LONG
*
         BCTR  R15,0               SUBTRACT ONE FROM THE LENGTH
         LA    R14,0(R15,R15)      DOUBLE THE LENGTH-1
         LH    R14,VJPSYSPI(R14)   LOAD OFFSET TO VALUE TABLE
         LA    R14,VJPSYSPT(R14)   GET ADDRESS OF VALUE TABLE
*
VJPSYSPL DS    0H
         EX    R15,VJPSYSPC        COMPARE THE VALUES
         BE    VJPSYSPM            BRANCH IF MATCHED
*
         LA    R14,2(R15,R14)      INCREMENT TO NEXT ENTRY
         CLI   1(R14),C'*'         CHECK FOR END OF TABLE
         BNE   VJPSYSPL            LOOP IF NOT AT END
*
VJPSYSPM DS    0H
         IC    R15,0(,R14)         INSERT INDEX BYTE
         B     *+4(R15)            BRANCH TO SET VALUE
         B     VJPSYSPY            SYSPROC=YES
         B     VJPSYSPN            SYSPROC=NO
         B     VJPSYSPF            SYSPROC=FIRST
         B     VJPER843            SYSPROC=INVALID
*
         EJECT
***********************************************************************
*                                                                     *
*        SET SYSPROC VALUE                                            *
*                                                                     *
***********************************************************************
*
VJPSYSPY OI    PPWFLAG4,PPW4SYSP   SET SYSTEM PROCLIBS WANTED
         NI    PPWFLAG4,255-PPW4SYSF    TURN OFF SYS PROCS FIRST
         B     VJPNSYSP            AND WE ARE DONE HERE
*
VJPSYSPN NI    PPWFLAG4,255-PPW4SYSP-PPW4SYSF NO SYSTEM PROC WANTED
         LA    R0,PPWCONCM         SET MAXIMUM NUMBER OF PROCLIBS
         STH   R0,PPWJPMAX         SET IT FOR LATER USE
         B     VJPNSYSP            AND WE ARE DONE WITH SYSPROC
*
VJPSYSPF OI    PPWFLAG4,PPW4SYSP   SET SYSTEM PROCLIBS WANTED
         OI    PPWFLAG4,PPW4SYSF   SET SYSTEM PROCLIBS WANTED FIRST
         B     VJPNSYSP            AND WE ARE FINISHED WITH SYSPROC
*
VJPSYSPC CLC   1(*-*,R14),1(R1)    *** EXECUTE ONLY ***
*
***********************************************************************
*                                                                     *
*        SYSPROC KEYWORD ERROR MESSAGES                               *
*                                                                     *
***********************************************************************
*
VJPER801 DS    0H
         LA    R0,MSGNO801         ILLEGAL USE OF "SYSPROC" KEY
         B     VJPSYSPE            GO PRODUCE ERROR MESSAGE
*
VJPER843 DS    0H
         LA    R0,MSGNO843         UNIDENTIFIED PARAMETER IN SYSPROC
*
VJPSYSPE DS    0H
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             PRODUCE ERROR MESSAGE
         B     VJPNSYSP            AND CONTINUE ON FOR NOW
*
VJPNSYSP DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        SCAN FOR BOTH DSNAME KEYWORDS                                *
*                                                                     *
***********************************************************************
*
         LA    R1,VJPDSNK1         POINT AT DSN KEYWORD
         L     R15,PPWCNVKW        LOAD THE SCAN ROUTINE ADDRESS
         BALR  R14,R15             GO SCAN FOR DSN
*
         B     *+4(R15)            ANALYZE THE RETURN CODE
         B     VJPDSNAS          0 GOT A DATA SET NAME
         B     VJPER800          4 SYNTAX ERROR
         B     *+4               8 DSN NOT FOUND
*
         LA    R1,VJPDSNK2         POINT AT DSNAME KEYWORD
         L     R15,PPWCNVKW        LOAD THE SCAN ROUTINE ADDRESS
         BALR  R14,R15             GO SCAN FOR DSN
*
         B     *+4(R15)            ANALYZE THE RETURN CODE
         B     VJPDSNAL          0 GOT A DATA SET NAME
         B     VJPER800          4 SYNTAX ERROR
         B     VJPER802          8 DSNAME NOT FOUND
*
***********************************************************************
*                                                                     *
*        DSN OR DSNAME FOUND                                          *
*                                                                     *
***********************************************************************
*
VJPDSNAL LA    R15,3               SET THE ADDITIONAL LENGTH OF DSNAME
*
VJPDSNAS LA    R15,4(,R15)         ADD IN LENGTH OF DSN=
*
         SR    R0,R15              CALCULATE DATA SET NAME LENGTH
         BNH   VJPER844            IF NOT POSITIVE, BAD NAME
*
         AR    R1,R15              POINT TO START OF DATA SET NAME
         CLI   0(R1),C''''         DOES IT START WITH AN APOSTROPHE
         BNE   VJPDSNNA            BRANCH IF NOT
*
         LR    R14,R1              COPY STARTING ADDRESS
         AR    R14,R0              INCREMENT TO END
         BCTR  R14,0               AND BACK UP ONE
*
         CLI   0(R14),C''''        CHECK FOR ENDING APOSTROPHE
         BNE   VJPER844            SYNTAX ERROR IS NOT
*
         LA    R1,1(,R1)           BUMP STARTING ADDRESS
         BCTR  R0,0                SUBTRACT NOT ONE,
         BCTR  R0,0                 BUT TWO, TWO, TWO MINTS IN ONE
*
         EJECT
***********************************************************************
*                                                                     *
*        EXTRACT AND VALIDITY CHECK DATA SET NAME                     *
*                                                                     *
***********************************************************************
*
VJPDSNNA DS    0H
         CH    R0,=Y(L'PPWDSNME)   TEST STRING LENGTH FOR MAX
         BH    VJPER842            "EXCESSIVE PARAMETER LENGTH"
*
         STH   R0,PPWDSNML         SAVE STRING LENGTH
*
         LR    R15,R0              COPY LENGTH FOR EXECUTE
         BCTR  R15,0               GET LENGTH FOR MOVE
         EX    R15,VJPDSNMV        SET STRING ACCORDING TO MOVE
*
         EX    R15,VJPDSNTT        VALIDITY CHECK THE DSNAME
         BNZ   VJPER844            INVALID SYNTAX IF BAD
         CLI   PPWDSNME,C'0'       CHECK FIRST CHARACTER
         BNL   VJPER844            ERROR IF NOT ALPHA
         CLI   PPWDSNME,C'.'       ERROR IF STARTS WITH PERIOD
*
         CLC   PPWJPCNT,PPWJPMAX   ARE WE ALREADY AT THE MAXIMUM ?
         BNL   VJPER804            YES, GIVE UP
*
         B     VJPDSNDN            AND WE ARE DONE
*
VJPDSNMV MVC   PPWDSNME(*-*),0(R1) *** EXECUTE ONLY ***
*
VJPDSNTT TRT   PPWDSNME(*-*),VJPDSNTR   *** EXECUTE ONLY ***
*
VJPDSNDN DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        LOCATE THE APPROPRIATE INCLUSION/ EXCLUSION LIST             *
*                                                                     *
***********************************************************************
*
         TM    PPWFLAG3,PPW3DSNL   DO WE HAVE A DATA SET NAME LIST
         BZ    VJPNDSNL            IF NO LIST, SKIP IT
*
         ICM   R15,15,PPWDSNAD     DO WE REALLY HAVE IT
         BZ    VJPNDSNL            BRANCH IF NOT
         LA    R15,0(,R15)         CLEAN UP HIGH ORDER BIT
*
         SLR   R14,R14             ASSUME BATCH JOB
         TM    PPWENVIR,PPWEJOB    TEST FOR BATCH JOB
         BO    VJPDSNLO            BRANCH IF SO
*
         LA    R14,4               ASSUME TSO USER
         TM    PPWENVIR,PPWETSU    TEST FOR TSO USER
         BO    VJPDSNLO            BRANCH IF SO
*
         LA    R14,8               ASSUME STARTED TASK
         TM    PPWENVIR,PPWESTC    IS THIS AN STC
         BO    VJPDSNLO            BRANCH IF SO
*
         LA    R14,8               ASSUME STARTED TASK IF UNKNOWN
*
VJPDSNLO DS    0H
         LH    R1,2(R14,R15)       LOAD THE INCLUSION LIST ADDRESS
         LTR   R1,R1               DO WE HAVE ONE
         BZ    VJPNDSLI            BRANCH IF NOT
*
         AR    R1,R15              GET ADDRESS OF INCLUSION LIST
         CLI   0(R1),C' '          IS THERE ANYTHING IN THE LIST
         BE    VJPNDSLI            SKIP THE SEARCH IF SO
*
         EJECT
***********************************************************************
*                                                                     *
*        SEARCH THE INCLUSION LIST                                    *
*                                                                     *
***********************************************************************
*
VJPDSLIL CLI   0(R1),C' '          CHECK FOR END OF TABLE
         BNH   VJPER803            END OF TABLE - NOT FOUND - ERROR
*
         CLC   PPWDSNME,0(R1)      MATCH THE DATA SET NAMES
         BE    VJPNDSNL            IF MATCHED, THIS IS GOOD
*
         LA    R1,44(,R1)          INCREMENT TO NEXT ENTRY
         B     VJPDSLIL            AND LOOK AT NEXT INCLUDE NAME
*
***********************************************************************
*                                                                     *
*        INCLUSION LIST IS NULL - FIND THE EXCLUSION LIST             *
*                                                                     *
***********************************************************************
*
VJPNDSLI DS    0H
         LH    R1,0(R14,R15)       LOAD THE EXCLUSION LIST ADDRESS
         LTR   R1,R1               DO WE HAVE ONE
         BZ    VJPNDSNL            BRANCH IF NOT
*
         AR    R1,R15              GET ADDRESS OF EXCLUSION LIST
*
***********************************************************************
*                                                                     *
*        SEARCH THE EXCLUSION LIST                                    *
*                                                                     *
***********************************************************************
*
VJPDSLXL CLI   0(R1),C' '          CHECK FOR END OF TABLE
         BNH   VJPNDSNL            END OF TABLE - NOT FOUND - GOOD
*
         CLC   PPWDSNME,0(R1)      MATCH THE DATA SET NAMES
         BE    VJPER803            IF MATCHED, THIS IS BAD
*
         LA    R1,44(,R1)          INCREMENT TO NEXT ENTRY
         B     VJPDSLXL            AND LOOK AT NEXT EXCLUDE NAME
*
VJPNDSNL DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        ALLOCATE THE USER'S PROCLIB                                  *
*                                                                     *
***********************************************************************
*
VJPGOALC DS    0H
         OI    PPWVJPFL,PPWVJPAL   INDICATE PERFORMING DYNAMIC ALLOC
*
         IEFCNTRC JPROCALC
*
         LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET ADDRESSABILITY TO DARB
         MVI   S99VERB,S99VRBAL    INDICATE "ALLOC DSNAME" REQUEST
         LA    R15,PPWDATXT        -> ALLOCATION TEXT POINTERS
*
         USING S99TUPL,R15         MAKE TEXT PTRS ADDRESSABLE
         USING S99TUNIT,R14        MAKE TEXT UNITS ADDRESSABLE
*
         LH    R2,PPWJPCNT         GET CURRENT CONCATENATION NO.
         LA    R2,1(,R2)           BUMP BY ONE
*
         LA    R14,PPWDDNMK        -> DDNAME RETURN TEXT UNIT SLOT
         MVC   S99TUPAR(8),PPWDDBSE     SET THE BASE DDNAME
         LA    R1,PPWDDSUF-1(R2)   POINT AT SUFFIX CHARACTER
         MVC   S99TUPAR+7(1),0(R1) MOVE THE SUFFIX CHARACTER
         ST    R14,S99TUPTR        SET PTR TO RETURN DDNAME TEXT UNIT
*
         LA    R14,PPWRTDSK        -> DSORG RETURN TEXT UNIT SLOT
         LA    R15,L'S99TUPTR(,R15)     -> NEXT TEXT UNIT PTR
         XC    S99TUPAR(2),S99TUPAR     CLEAR THE DSORG
         ST    R14,S99TUPTR        SET PTR TO RETURN DSORG TEXT UNIT
*
         LA    R14,PPWDSNMK        -> DSNAME TEXT UNIT SLOT
         LA    R15,L'S99TUPTR(,R15)     -> NEXT TEXT UNIT PTR
         ST    R14,S99TUPTR        SET PTR TO "DSNAME" TEXT UNIT
*
         LA    R14,PPWDISPK        -> STATUS DISPOSITION TEXT
         LA    R15,L'S99TUPTR(,R15)     -> NEXT TEXT PTR SLOT
         ST    R14,S99TUPTR        SET PTR TO "STATUS" DISP TEXT
*
         LA    R14,PPWCLOSK        -> FREE=CLOSE TEXT
         LA    R15,L'S99TUPTR(,R15)     -> NEXT TEXT PTR SLOT
         ST    R14,S99TUPTR        SET PTR TO "STATUS" DISP TEXT
*
         OI    S99TUPTR,S99TUPLN   SET END OF TEXT UNITS INDICATOR
         LA    R1,PPWDARGL         R1 -> DYNAMIC ALLOC PARM LIST
*
         DROP  R14,R15             DONE WITH DYNAMIC ALLOC PARMS
*
         OI    PPWFLAG3,PPW3DALC   INDICATE WE ARE IN ALLOC. CODE
         DYNALLOC ,                ALLOCATE TO USER PROCLIB
         NI    PPWFLAG3,255-PPW3DALC    INDICATE WE ARE BACK
*
         LTR   R15,R15             ALLOCATION SUCCESSFUL ?
         BZ    VJPDYNOK            BRANCH IF YES
*
         ST    R15,PPWDARC         STORE THE RETURN CODE
         L     R15,PPWCNVDE        LOAD DYN ALLOC ERROR RTN ADDR
         BALR  R14,R15             DO ERROR ANALYSIS
*
         NI    PPWVJPFL,255-PPWVJPAL    TURN OFF IN DYNAMIC ALLOC RTN
*
         B     VJPEXIT             RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        VALIDATE THE DATA SET MAKING SURE THAT IT IS A               *
*        PARTITIONED DATA SET ON DASD.                                *
*                                                                     *
***********************************************************************
*
VJPDYNOK DS    0H
         NI    PPWVJPFL,255-PPWVJPAL    TURN OFF IN DYNAMIC ALLOC RTN
*
         STH   R2,PPWJPCNT         UPDATE CONCATENATION NO.
         BCTR  R2,0                SUBTRACT ONE
         MH    R2,=Y(L'PPWCONCD)   MULTIPLE BY 10
         LA    R2,PPWCONCD(R2)     CALCULATE DDNAME POSITION
         MVC   2(8,R2),PPWDDNME    COPY THE ALLOCATED DDNAME
*
         TM    PPWRTDSE,X'02'      TEST FOR DSORG=PO
         BZ    VJPER803            DATA SET NOT VALID IF WRONG DSORG
*
         L     R1,PPWTIOTA         LOAD THE TIOT ADDRESS
         USING TIODSECT,R1         SET UP ADDRESSIBILITY
         SLR   R15,R15             ZERO FOR INSERTS
*
VJPTIOLP CLI   TIOELNGH,0          CHECK FOR END OF TIOT
         BE    VJPER811            BRANCH IF NAME NOT FOUND (ERROR)
*
         CLC   TIOEDDNM,PPWDDNME   CHECK FOR THE ALLOCATED DD ENTRY
         BE    VJPTIOTF            BRANCH IF FOUND
*
         IC    R15,TIOELNGH        LOAD THE LENGTH
         AR    R1,R15              INCREMENT ADDRESS
         B     VJPTIOLP            CONTINUE TIOT SCAN
*
VJPTIOTF ICM   R1,7,TIOEFSRT       LOAD THE UCB ADDRESS
         BZ    VJPER811            IF NONE, THIS IS VERY BAD
         USING UCBDSECT,R1         TELL THE ASSEMBLER ABOUT THE UCB
*
         TM    UCBTBYT3,UCB3DACC   TEST FOR DIRECT ACCESS
         BZ    VJPER811            IF NOT, THIS CANNOT BE ALLOWED
*
         DROP  R1
*
         LA    R0,MSGNO821         FIRST PROCLIB MESSAGE
         TM    PPWFLAG1,PPW1CNJP   IS THIS A CONCATENATION
         BZ    *+8                 BRANCH IF NOT
         LA    R0,MSGNO822         CONCATENATION PROCLIB MESSAGE
*
         L     R15,PPWCNVMS        POINT AT MESSAGE ROUTINE
         BALR  R14,R15             ISSUE PROCLIB MESSAGE
*
         B     VJPEXIT             RETURN TO CONVERTER
*
         EJECT ,
***********************************************************************
*                                                                     *
*        DATA SET NAME ERROR MESSAGES                                 *
*                                                                     *
***********************************************************************
*
VJPER800 DS    0H
         LA    R0,MSGNO800         SYNTAX ERROR IN JOBPROC STATEMENT
         B     VJPDSNER            GO PRODUCE ERROR MESSAGE
*
VJPER802 DS    0H
         LA    R0,MSGNO802         JOBPROC DSNAME MISSING
         B     VJPDSNER
*
VJPER803 DS    0H
         LA    R0,MSGNO803         DATA SET NOT VALID FOR JOBPROC
         B     VJPDSNER
*
VJPER804 DS    0H
         LA    R0,MSGNO804         CONCATENATION LIMIT EXCEEDED
         B     VJPDSNER
*
VJPER811 DS    0H
         LA    R0,MSGNO811         JOBPROC VOLUME NOT ALLOWED
         B     VJPDSNER
*
VJPER842 DS    0H
         LA    R0,MSGNO842         EXCESSIVE PARAMETER LENGTH (DSNAME)
         B     VJPDSNER
*
VJPER844 DS    0H
         LA    R0,MSGNO844         INVALID SYNTAX IN DSNAME
         B     VJPDSNER
*
VJPDSNER DS    0H
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             PRODUCE ERROR MESSAGE
*
         B     VJPEXIT             RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO CALLER                                             *
*                                                                     *
***********************************************************************
*
VJPEXIT  DS    0H
         SLR   R15,R15             ASSUME NO ERROR
         TM    PPWFLAG1,PPW1JPER   ERROR NOTED IN JOBPROC ?
         BZ    *+8                 BRANCH IF GOOD
         LA    R15,4               INDICATE ERROR
*
         NI    PPWVJPFL,255-PPWVJPEX    TURN OFF WE ARE HERE
*
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         L     R14,12(,R13)        RELOAD RETURN ADDRESS
         LM    R0,R12,20(R13)      RELOAD REGS 0 - 12
         BR    R14                 RETURN TO CALLER
*
         DROP  ,                   KILL ALL ADDRESSIBILITY
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS AND DATA AREAS USED BY IEFCNVJP                    *
*                                                                     *
***********************************************************************
*
VJPDSNK2 DC    H'6',C'DSNAME'      DATA SET NAME KEYWORD
VJPDSNK1 DC    H'3',C'DSN'         ABBREVIATED DATA SET NAME KEYWORD
*
VJPERIOD DC    256X'00'            PERIOD TRANSLATE AND TEST TABLE
         ORG   VJPERIOD+C'.'
         DC    X'FF'
         ORG   ,
*
VJPDSNTR DC    256X'FF'            DATA SET NAME TRANSLATE TABLE
         ORG   VJPDSNTR+C'.'
         DC    X'00'               IS GOOD
         ORG   VJPDSNTR+C'@'
         DC    X'00'               IS GOOD
         ORG   VJPDSNTR+C'#'
         DC    X'00'               IS GOOD
         ORG   VJPDSNTR+C'$'
         DC    X'00'               IS GOOD
         ORG   VJPDSNTR+C'A'
         DC    9X'00'              IS GOOD
         ORG   VJPDSNTR+C'J'
         DC    9X'00'              IS GOOD
         ORG   VJPDSNTR+C'S'
         DC    8X'00'              IS GOOD
         ORG   VJPDSNTR+C'0'
         DC    10X'00'             IS GOOD
         ORG   ,
*
VJPSYSPI DS    0H                  SYSPROC VALUE LOOKUP OFFSETS
         DC    Y(VJPSYSP1-VJPSYSPT)     LENGTH 1 VALUES
         DC    Y(VJPSYSP2-VJPSYSPT)     LENGTH 2 VALUES
         DC    Y(VJPSYSP3-VJPSYSPT)     LENGTH 3 VALUES
         DC    Y(VJPSYSP4-VJPSYSPT)     LENGTH 4 VALUES
         DC    Y(VJPSYSP5-VJPSYSPT)     LENGTH 5 VALUES
         DC    Y(VJPSYSP6-VJPSYSPT)     LENGTH 6 VALUES
VJPSYSP# EQU   (*-VJPSYSPI)/2      MAXIMUM LENGTH OF SYSPROC PARMS
*
VJPSYSPT DS    0H                  SYSPROC VALUE TABLES
VJPSYSP1 DS    0H                  SYSPROC VALUES OF LENGTH ONE
         DC    AL1(0),C'Y'         SYSPROC=Y(ES)
         DC    AL1(0),C'L'         SYSPROC=L(AST)
         DC    AL1(0),C'A'         SYSPROC=A(FTER)
         DC    AL1(4),C'N'         SYSPROC=N(O)
         DC    AL1(8),C'F'         SYSPROC=F(IRST)
         DC    AL1(8),C'B'         SYSPROC=B(EFORE)
         DC    AL1(12),C'*'        SYSPROC=INVALID
*
VJPSYSP2 DS    0H                  SYSPROC VALUES OF LENGTH TWO
         DC    AL1(4),C'NO'        SYSPROC=NO
         DC    AL1(12),C'*'        SYSPROC=INVALID
*
VJPSYSP3 DS    0H                  SYSPROC VALUES OF LENGTH THREE
         DC    AL1(0),C'YES'       SYSPROC=YES
         DC    AL1(12),C'*'        SYSPROC=INVALID
*
VJPSYSP4 DS    0H                  SYSPROC VALUES OF LENGTH FOUR
         DC    AL1(0),C'LAST'      SYSPROC=LAST
         DC    AL1(4),C'NONE'      SYSPROC=NONE
         DC    AL1(12),C'*'        SYSPROC=INVALID
*
VJPSYSP5 DS    0H                  SYSPROC VALUES OF LENGTH FIVE
         DC    AL1(0),C'AFTER'     SYSPROC=AFTER
         DC    AL1(8),C'FIRST'     SYSPROC=FIRST
         DC    AL1(12),C'*'        SYSPROC=INVALID
*
VJPSYSP6 DS    0H                  SYSPROC VALUES OF LENGTH SIX
         DC    AL1(8),C'BEFORE'    SYSPROC=BEFORE
         DC    AL1(12),C'*'        SYSPROC=INVALID
*
VJPPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVJP PATCH'
         DC    16F'0'
*
VJPLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVEX - COMPLETE JOBPROC ALLOCATION AND OPEN'
***********************************************************************
*                                                                     *
*        IEFCNVEX                                                     *
*        ********                                                     *
*                                                                     *
*        THE ROUTINE RECEIVES CONTROL FROM IEFCNVGS WHEN THE          *
*        FIRST STATEMENT FOLLOWING A JOBPROC DD OR CONCATENATION      *
*        IS DETECTED.                                                 *
*                                                                     *
*        INPUT:                                                       *
*              NONE                                                   *
*                                                                     *
*        OUTPUT:                                                      *
*              CONCATENATED (IF NECESSARY) AND OPEN DYNAMIC PROCLIB   *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER                                       *
*                                                                     *
***********************************************************************
*
IEFCNVEX DS    0D
         USING *,R15               TEMPORARY BASE
         B     VEXSTM              BRANCH AROUND ID
*
         DC    AL1(VEXIDL)         LTH OF IDENTIFICATION PREFIX
VEXID    DC    CL8'IEFCNVEX'       USER PROCLIB SUPPORT MODULE ID
VEXIDL   EQU   *-VEXID             LENGTH OF IDENTIFICATION HEADER
*
VEXSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVEX,R12        ESTABLISH PERMANENT BASE
*
         LR    R15,R13             COPY THE CURRENT SAVE AREA ADDRESS
         N     R15,=X'FFFFF000'    ROUND BACK TO A PAGE BOUNDARY
         USING PPWDSECT,R15
         LA    R15,PPWVEXSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVEXSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVEXCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVEXCN        STORE IT BACK
*
         LA    R15,VEXEXIT         POINT AT DEFAULT RECOVERY ADDRESS
         ST    R15,PPWVEXRT        STORE IN RETRY ADDRESS
*
         OI    PPWVEXFL,PPWVEXEX   INDICATE WE ARE HERE
*
         EJECT
***********************************************************************
*                                                                     *
*        CHECK IF WE HAVE ANYTHING TO DO                              *
*                                                                     *
***********************************************************************
*
         IEFCNTRC 1STEXEC
*
         OI    PPWFLAG2,PPW2CMPL   INDICATE FIRST EXEC
*
         TM    PPWFLAG1,PPW1HVJP   HAVE JOBPROC TO PROCESS ?
         BZ    VEXEXIT             NO, RETURN
*
         TM    PPWFLAG1,PPW1JPER   ERROR NOTED IN JOBPROC ?
         BO    VEXEXIT             SO JUST RETURN
*
         LH    R0,PPWJPCNT         LOAD DD CARD COUNT
         LTR   R0,R0               TEST IF ANY
         BZ    VEXEXIT             FORGET THE WHOLE THING
*
         EJECT
***********************************************************************
*                                                                     *
*        ALLOCATE THE SYSTEM PROCLIB DATA SETS IF NECESSARY           *
*                                                                     *
***********************************************************************
*
         TM    PPWFLAG4,PPW4SYSP   TEST IF SYSTEM PROCLIB(S) WANTED
         BZ    VEXANSYS            NO, SKIP
         TM    PPWFLAG3,PPW3NOSY   TEST IF SYSPROC UNAVAILABLE
         BO    VEXANSYS            YES, SKIP CONCATENATION
         ICM   R3,3,PPWJPSYS       GET COUNT OF SYSTEM PROCLIBS
         BZ    VEXANSYS            BRANCH IF NOT
*
         OI    PPWVEXFL,PPWVEXAL   INDICATE WE ARE ALLOCATING
*
         OI    PPWFLAG1,PPW1CNJP   INDICATE CONCATENATION REQUIRED
         LA    R3,1                START SYSTEM PROCLIB COUNT AT 1
*
         IEFCNTRC SPROCALC
*
VEXASYSL LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET ADDRESSABILITY TO DARB
         MVI   S99VERB,S99VRBAL    INDICATE "ALLOC DSNAME" REQUEST
         LA    R15,PPWDATXT        -> ALLOCATION TEXT POINTERS
*
         USING S99TUPL,R15         MAKE TEXT PTRS ADDRESSABLE
         USING S99TUNIT,R14        MAKE TEXT UNITS ADDRESSABLE
*
         LH    R2,PPWJPCNT         GET CURRENT CONCATENATION NO.
         LA    R2,1(,R2)           BUMP BY ONE
*
         LA    R14,PPWDDNMK        -> DDNAME RETURN TEXT UNIT SLOT
         MVC   S99TUPAR(8),PPWDDBSE     SET THE BASE DDNAME
         LA    R1,PPWDDSUF-1(R2)   GET THE DDNAME SUFFIX
         MVC   S99TUPAR+7(1),0(R1) SET THE DDNAME SUFFIX
         ST    R14,S99TUPTR        SET PTR TO RETURN DDNAME TEXT UNIT
*
         LR    R1,R3               GET SYSTEM PROCLIB NUMBER
         BCTR  R1,0                SUBTRACT ONE
         SLL   R1,2                MULTIPLY BY 4
         L     R1,PPWSYSDS(R1)     LOAD PROCLIB JFCB ADDRESS
         USING JFCBDSCT,R1
*
         LA    R14,PPWDSNMK        -> DSNAME TEXT UNIT SLOT
         LA    R15,L'S99TUPTR(,R15)     -> NEXT TEXT UNIT PTR
         MVC   S99TULNG,=Y(L'JFCBDSNM)  SET DATA SET NAME LENGTH
         MVC   S99TUPAR(44),JFCBDSNM    MOVE THE DATA SET NAME
         ST    R14,S99TUPTR        SET PTR TO "DSNAME" TEXT UNIT
*
         DROP  R1
*
         LA    R14,PPWDISPK        -> STATUS DISPOSITION TEXT
         LA    R15,L'S99TUPTR(,R15)     -> NEXT TEXT PTR SLOT
         ST    R14,S99TUPTR        SET PTR TO "STATUS" DISP TEXT
*
         OI    S99TUPTR,S99TUPLN   SET END OF TEXT UNITS INDICATOR
*
         DROP  R14,R15             DONE WITH DYNAMIC ALLOCATION PARMS
*
         LA    R1,PPWDARGL         R1 -> DYNAMIC ALLOC PARM LIST
         OI    PPWFLAG3,PPW3DALC   INDICATE WE ARE IN ALLOC. CODE
         DYNALLOC ,                ALLOCATE TO USER PROCLIB
         NI    PPWFLAG3,255-PPW3DALC    INDICATE WE ARE BACK
*
         LTR   R15,R15             ALLOCATION SUCCESSFUL ?
         BZ    VEXSYSOK            BRANCH IF YES
*
         ST    R15,PPWDARC         SAVE THE RETURN CODE
         L     R15,PPWCNVDE        LOAD THE ANALYZE ROUTINE ADDR
         BALR  R14,R15             DO ERROR ANALYSIS
*
         NI    PPWVEXFL,255-PPWVEXAL    DONE WITH ALLOCATIONS FOR NOW
*
         B     VEXEXIT             RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        ALLOCATION OK - UPDATE COUNT AND DDNAME LIST                 *
*                                                                     *
***********************************************************************
*
VEXSYSOK STH   R2,PPWJPCNT         UPDATE CONCATENATION NO.
*
         BCTR  R2,0                SUBTRACT ONE
         MH    R2,=Y(L'PPWCONCD)   MULTIPLE BY 10
         LA    R2,PPWCONCD(R2)     CALCULATE DDNAME POSITION
         MVC   2(8,R2),PPWDDNME    COPY THE ALLOCATED DDNAME
*
         LA    R3,1(,R3)           INCREMENT SYSTEM PROCLIB COUNT
         CH    R3,PPWJPSYS         ARE WE DONE?
         BNH   VEXASYSL            LOOP IF WE AREN'T
*
         NI    PPWVEXFL,255-PPWVEXAL    DONE WITH ALLOCATIONS FOR NOW
*
         EJECT
***********************************************************************
*                                                                     *
*        INFORM THE USER OF THE TYPE OF SYSTEM PROCLIB SEARCH         *
*                                                                     *
***********************************************************************
*
         LA    R0,MSGNO823         SYSTEM CONCATENATION MESSAGE
         LA    R1,VEXAFTER         ASSUME AFTER USER DATA SETS
         TM    PPWFLAG4,PPW4SYSF   TEST FOR WANTING THEM FIRST
         BZ    *+8                 BRANCH IF NOT
         LA    R1,VEXBEFOR         POINT TO BEFORE TEXT
*
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             INFORM USER
*
         B     VEXSYSAL            AND THE SYSTEM DATA SETS ARE ALLOCED
*
VEXANSYS DS    0H
         LA    R0,MSGNO824         NO SYSTEM CONCATENATION MESSAGE
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             INFORM USER
*
         EJECT
***********************************************************************
*                                                                     *
*        CONCATENATE ALL USER AND SYSTEM PROCLIB DATA SETS TOGETHER   *
*                                                                     *
***********************************************************************
*
VEXSYSAL DS    0H
         TM    PPWFLAG1,PPW1CNJP   REQUIRE CONCATENATION ?
         BO    VEXCONCT            YES, PERFORM CONCATENATION
         TM    PPWFLAG4,PPW4SYSP   TEST IF SYSTEM PROCLIB(S) WANTED
         BZ    VEXOPEN             NO, SKIP
         TM    PPWFLAG3,PPW3NOSY   TEST IF SYSPROC UNAVAILABLE
         BO    VEXOPEN             YES, SKIP CONCATENATION
*
VEXCONCT DS    0H
         OI    PPWVEXFL,PPWVEXCO   INDICATE CONCATENATING
*
         IEFCNTRC JPROCCON
*
         LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET DARB ADDRESSABILITY
         MVI   S99VERB,S99VRBCC    INDICATE CONCATENATION REQUEST
         LA    R15,PPWDATXT        -> ALLOCATION TEXT PTR SLOTS
*
         USING S99TUPL,R15         GET TEXT LIST ADDRESSABILITY
         USING S99TUNIT,R14        MAKE TEXT UNITS ADDRESSABLE
*
         LA    R14,PPWCONCK        -> CONCATENATION TXT UNIT SLOT
         ST    R14,S99TUPTR        SET PTR TO CONCATENATE TEXT
*
         LH    R1,PPWJPCNT         LOAD COUNT OF DDNAMES
         STH   R1,S99TUNUM         SET NO. OF DDNAMES TO CONC.
*
         OI    S99TUPTR,S99TUPLN   FLAG END OF TEXT UNIT PTR'S
*
         DROP  R14,R15             DONE WITH DYNAMIC ALLOCATION PARMS
*
         EJECT
***********************************************************************
*                                                                     *
*        CHECK FOR SYSPROC=FIRST AND REARRANGE THE DDNAMES IF SO      *
*                                                                     *
***********************************************************************
*
         TM    PPWFLAG4,PPW4SYSF   DO WE WANT THE SYSTEM STUFF FIRST
         BZ    VEXDOCON            IF NOT, WE ARE SATISFIED
*
         LH    R15,PPWJPSYS        LOAD THE SYSTEM COUNT
         LTR   R15,R15             DO WE HAVE ANY
         BZ    VEXDOCON            BRANCH IF NOT
         TM    PPWFLAG3,PPW3NOSY   ARE THEY AVAILABLE
         BO    VEXDOCON            BRANCH IF NOT
*
         LNR   R15,R15             MAKE SYSTEM COUNT NEGATIVE
         AR    R15,R1              CALCULATE HOW MANY USER DATA SETS
*
         MH    R1,=Y(L'PPWCONCD)   CALCULATE LENGTH TO SHIFT
         LA    R14,PPWCONCD(R1)    CALCULATE PLACE FOR NEW NAME
         BCTR  R1,0                SUBTRACT THE TRADITIONAL ONE
*
VEXSYS1S DS    0H
         MVC   0(L'PPWCONCD,R14),PPWCONCD SHIFT THE FIRST NAME
         EX    R1,VEXMVCDD         RIPPLE DOWN THE DDNAME LIST
         BCT   R15,VEXSYS1S        LOOP THROUGH THE LIST
*
         EJECT
***********************************************************************
*                                                                     *
*        PERFORM THE CONCATENATION                                    *
*                                                                     *
***********************************************************************
*
VEXDOCON DS    0H
         OI    PPWFLAG3,PPW3DALC   INDICATE WE ARE IN ALLOC. CODE
*
         LA    R1,PPWDARGL         -> ALLOC REQUEST PARM PTR
         DYNALLOC ,                CONCATENATE THE PROCLIB'S
*
         NI    PPWFLAG3,255-PPW3DALC    INDICATE WE ARE BACK
*
         LTR   R15,R15             WAS CONCATENATION OK ?
         BZ    VEXSETCI            BRANCH IF YES
*
         ST    R15,PPWDARC         SAVE THE RETURN CODE
         L     R15,PPWCNVDE        LOAD THE ANALYZE ROUTINE ADDR
         BALR  R14,R15             DO ERROR ANALYSIS
*
         NI    PPWVEXFL,255-PPWVEXCO    TURN OFF CONCATENATING
*
         B     VEXEXIT             RETURN TO CALLER
*
VEXMVCDD MVC   PPWCONCD(*-*),PPWCONCD+L'PPWCONCD *** EXECUTE ONLY ***
*
VEXSETCI OI    PPWFLAG1,PPW1JPCN   SHOW FILES CONCATENATED
*
         NI    PPWVEXFL,255-PPWVEXCO    TURN OFF CONCATENATING
*
         EJECT
***********************************************************************
*                                                                     *
*        OPEN THE USER PROCLIB(S)                                     *
*                                                                     *
***********************************************************************
*
VEXOPEN  DS    0H
*
         L     R2,PPWPPDCB         NOW POINT AT OUR DCB
         USING IHADCB,R2
*
         MVC   DCBDDNAM,PPWCONCD+2 COPY OUR FIRST DCB NAME
*
         LA    R15,VEXTOPEN        POINT TO OPEN RECOVERY ADDRESS
         ST    R15,PPWVEXRT        STORE IN RETRY ADDRESS
*
         OI    PPWVEXFL,PPWVEXOP   SET "OPEN" TRACE EVENT
         ST    R2,PPWOCLST         STORE OUR DCB ADDRESS
         OI    PPWOCLST,X'80'      SET LISTEND
*
         OPEN  MF=(E,PPWOCLST)     REOPEN THE SYSTEM PROCLIB
*
VEXTOPEN DS    0H
         NI    PPWVEXFL,255-PPWVEXOP    RESET "OPEN" EVENT
*
         LA    R15,VEXEXIT         POINT AT DEFAULT RECOVERY ADDRESS
         ST    R15,PPWVEXRT        STORE IN RETRY ADDRESS
*
         TM    DCBOFLGS,DCBOFOPN
         BZ    VEXER812            NO, SKIP
         OI    PPWFLAG1,PPW1OPEN   ELSE SAVE STATUS
*
         L     R1,PPWJSDCB         LOAD ADDRESS OF CONVERTER'S DCB ADDR
         ST    R2,0(,R1)           STORE THE NEW DCB ADDRESS
         DROP  R2
*
         IEFCNTRC JPROCOPN
*
         B     VEXEXIT             RETURN
*
         EJECT
***********************************************************************
*                                                                     *
*        ERROR ROUTINES                                               *
*                                                                     *
***********************************************************************
*
VEXER812 DS    0H
         LA    R0,MSGNO812         USER PROCLIB OPEN FAILED
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             GIVE USER HIS ERROR
*
         B     VEXEXIT             RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO CALLER                                             *
*                                                                     *
***********************************************************************
*
VEXEXIT  DS    0H
         SLR   R15,R15             ASSUME NO ERROR
         TM    PPWFLAG1,PPW1JPER   ERROR NOTED IN JOBPROC ?
         BZ    *+8                 BRANCH IF GOOD
         LA    R15,4               INDICATE ERROR
*
         NI    PPWVEXFL,255-PPWVEXEX    TURN OFF WE ARE HERE
*
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         L     R14,12(,R13)        RELOAD RETURN ADDRESS
         LM    R0,R12,20(R13)      RELOAD REGS 0 - 12
         BR    R14                 RETURN TO CALLER
*
         DROP  ,                   KILL ALL ADDRESSIBILITY
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS AND DATA AREAS USED BY IEFCNVEX                    *
*                                                                     *
***********************************************************************
*
VEXBEFOR DC    H'6',C'BEFORE'      BEFORE CONSTANT FOR MESSAGE
VEXAFTER DC    H'5',C'AFTER'       AFTER CONSTANT FOR MESSAGE
*
VEXPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVEX PATCH'
         DC    16F'0'
*
VEXLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVKW - KEYWORD SCAN'
***********************************************************************
*                                                                     *
*        IEFCNVKW                                                     *
*        ********                                                     *
*                                                                     *
*        THE ROUTINE IS CALLED TO SCAN A TEXT STRING FOR A            *
*        SPECIFIC KEYWORD.                                            *
*                                                                     *
*        INPUT:                                                       *
*              R1 POINTS TO 2 BYTE KEYWORD LENGTH FOLLOWED BY KEYWORD *
*              PPWSTMTX -> TEXT STRING TO SCAN                        *
*              PPWSTMTL = LENGTH OF TEXT STRING                       *
*                                                                     *
*        OUTPUT:                                                      *
*              R15 = 0 IF KEYWORD FOUND                               *
*              R1  = ADDRESS OF KEYWORD START                         *
*              R0  = LENGTH OF KEYWORD AND DATA STRING                *
*              R15 = 4 IF BAD STATEMENT SYNTAX (R1/R0 UNPREDICTABLE)  *
*              R15 = 8 IF KEYWORD NOT FOUND (R1/R0 UNPREDICTABLE)     *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER                                       *
*                                                                     *
***********************************************************************
*
IEFCNVKW DS    0D
         USING *,R15               TEMPORARY BASE
         B     VKWSTM              BRANCH AROUND ID
*
         DC    AL1(VKWIDL)         LTH OF IDENTIFICATION PREFIX
VKWID    DC    CL8'IEFCNVKW'       USER PROCLIB SUPPORT MODULE ID
VKWIDL   EQU   *-VKWID             LENGTH OF IDENTIFICATION HEADER
*
VKWSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVKW,R12        ESTABLISH PERMANENT BASE
*
         LR    R15,R13             COPY THE CURRENT SAVE AREA ADDRESS
         N     R15,=X'FFFFF000'    ROUND BACK TO A PAGE BOUNDARY
         USING PPWDSECT,R15
         LA    R15,PPWVKWSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVKWSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVKWCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVKWCN        STORE IT BACK
*
         LA    R15,VKWEXIT         POINT AT RECOVERY ADDRESS
         ST    R15,PPWVKWRT        STORE IN RETRY ADDRESS
*
         OI    PPWVKWFL,PPWVKWEX   INDICATE WE ARE HERE
*
         MVC   PPWKYWDL,0(R1)      COPY THE KEYWORD LENGTH
         MVC   PPWKYWDT,2(R1)      COPY THE ACTUAL WORD (PLUS RESIDUAL)
*
         EJECT
***********************************************************************
*                                                                     *
*        SCAN THE TEXT STRING LOOKING FOR OUR PARAMETERS              *
*                                                                     *
***********************************************************************
*
         LH    R5,PPWSTMTL         LOAD THE LENGTH OF THE TEXT
         L     R6,PPWSTMTX         LOAD THE TEXT ADDRESS
*
VKWSCAN  DS    0H
         LTR   R5,R5               LOAD SCAN LENGTH
         BNH   VKWNTFND            IF AT THE END, STOP SCAN
*
         LA    R15,VKWCOMMA        LET'S LOOK FOR FIRST COMMA
         BAL   R14,VKWTRTXX        GO SCAN FOR A COMMA
         LR    R2,R15              SAVE IT'S ADDRESS
*
         LA    R15,VKWEQUAL        LET'S LOOK FOR FIRST EQUAL SIGN
         BAL   R14,VKWTRTXX        GO SCAN FOR A COMMA
         LR    R3,R15              SAVE IT'S ADDRESS
*
         CR    R2,R3               IS THE COMMA BEFORE THE FIRST EQUAL
         BH    VKWFIRST            IF NOT, BRANCH
         BE    VKWNTFND            IF EQUAL, NEITHER WAS FOUND
*
***********************************************************************
*                                                                     *
*        SINCE COMMA IS BEFORE EQUAL SIGN, SKIP THE POSITIONAL        *
*        PARAMETER.                                                   *
*                                                                     *
***********************************************************************
*
         LA    R1,1(,R2)           INCREMENT PAST COMMA
         SR    R1,R6               CALCULATE LENGTH TO SKIP
         SR    R5,R1               DECREMENT THE REMAINING LENGTH
         LA    R6,0(R6,R1)         INCREMENT PAST THE POSITIONAL PARM
*
         B     VKWSCAN             AND TRY AGAIN
*
         EJECT
***********************************************************************
*                                                                     *
*        MATCH THE KEYWORD PARAMETER WITH WHAT WE ARE LOOKING FOR     *
*                                                                     *
***********************************************************************
*
VKWFIRST DS    0H
         LR    R15,R3              COPY ADDRESS OF EQUAL SIGN
         SR    R15,R6              CALCULATE KEYWORD LENGTH
         SR    R5,R15              DECREMENT REMAINING LENGTH
*
         CH    R15,PPWKYWDL        IS IT THE SAME AS WHAT WE WANT
         BNE   VKWNEXT1            IF NOT, GET NEXT PARAMETER
         BCTR  R15,0               DECREMENT KEYWORD LENGTH
         EX    R15,VKWCLCKW        MATCH THE KEYWORDS
         BE    VKWGOTKW            BRANCH IF THIS IS WHAT WE WANT
*
         EJECT
***********************************************************************
*                                                                     *
*        KEYWORD IS NOT THE ONE WE WANT, SO GO FIND NEXT ONE          *
*                                                                     *
***********************************************************************
*
VKWNEXT1 DS    0H
         LA    R6,1(,R3)           BUMP PAST CURRENT EQUAL SIGN
         BCT   R5,*+8              AND CONTINUE SCAN
         B     VKWSYNTX            IF NOTHING LEFT, ERROR
*
         SLR   R2,R2               SET UP PARENTHESIS COUNTER
*
VKWNEXTL CLI   0(R6),C','          LOOK FOR A COMMA
         BNE   VKWNEXTC            BRANCH IF NOT
*
         LTR   R2,R2               ARE WE WITHIN PARENTHESES
         BNZ   VKWNEXTC            IF SO, THIS ISN'T THE ONE
*
         LA    R6,1(,R6)           INCREMENT PAST THIS COMMA
         BCT   R5,VKWSCAN          AND START THE SCAN
         B     VKWSYNTX            ERROR IF COMMA AT THE END
*
VKWNEXTC DS    0H
         CLI   0(R6),C'('          CHECK FOR LEFT PARENTHESIS
         BNE   *+8                 BRANCH IF NOT
         LA    R2,1(,R2)           INCREMENT COUNT
*
         CLI   0(R6),C')'          CHECK FOR RIGHT PARENTHESIS
         BNE   *+12                BRANCH IF NOT
         BCTR  R2,0                DECREMENT COUNT
         LTR   R2,R2               HAS IT GONE NEGATIVE
         BL    VKWSYNTX            IF SO, WE ARE IN TROUBLE
*
         LA    R6,1(,R6)           INCREMENT TO NEXT CHARACTER
         BCT   R5,VKWNEXTL         LOOP LOOKING FOR COMMAS
*
         B     VKWNTFND            AT THE END WE ARE THROUGH
*
VKWCLCKW CLC   0(*-*,R6),PPWKYWDT  *** EXECUTE ONLY ***
*
         EJECT
***********************************************************************
*                                                                     *
*        KEYWORD IS THE ONE WE WANT.                                  *
*                                                                     *
***********************************************************************
*
VKWGOTKW DS    0H
         SR    R2,R6               GET LENGTH OF KEYWORD DATA
*
         LR    R0,R2               COPY TOTAL STRING LENGTH
         LR    R1,R6               COPY STRING START
         SLR   R15,R15             INDICATE SUCCESS
         B     VKWEXIT             AND LEAVE
*
***********************************************************************
*                                                                     *
*        KEYWORD WAS NOT FOUND.                                       *
*                                                                     *
***********************************************************************
*
VKWNTFND DS    0H
         LA    R15,8               INDICATE NOT HERE
         B     VKWEXIT             AND LEAVE
*
***********************************************************************
*                                                                     *
*        TEXT STRING HAS A SYNTAX ERROR.                              *
*                                                                     *
***********************************************************************
*
VKWSYNTX DS    0H
         LA    R15,4               INDICATE SCAN WAS BAD
         B     VKWEXIT             AND LEAVE
*
         EJECT
***********************************************************************
*                                                                     *
*        SCAN THE TEXT STRING USING TRT TABLE IN R15.                 *
*                                                                     *
*        R15 ON RETURN IS ADDRESS OF CHARACTER OR END OF STRING ADDR. *
*                                                                     *
***********************************************************************
*
VKWTRTXX DS    0H
         STM   R14,R12,12(R13)     SAVE REGISTERS
         LR    R3,R6               SAVE THE STARTING ADDRESS FOR LATER
*
VKWTRTLP DS    0H
         LR    R1,R5               LOAD REMAINING SCAN LENGTH
         CH    R1,=H'256'          CHECK FOR MAX LENGTH
         BNH   *+8                 BRANCH IF NOT BIG
         LA    R1,256              SET MAXIMUM SCAN LENGTH
*
         BCTR  R1,0                DECREMENT FOR INSTRUCTION
         EX    R1,VKWTRTSC         SCAN FOR CHARACTER IN QUESTION
         BNZ   VKWTRTFN            BRANCH IF CHARACTER FOUND
*
         LA    R6,256(,R6)         ASSUME MAXIMUM LENGTH TRT
         SH    R5,=H'256'          AND THE SAME HERE
         BH    VKWTRTLP            AND LOOP IF SOME STRING LEFT
*
         LA    R1,1(R1,R3)         POINT PAST STRING IF NOT THERE
*
VKWTRTFN DS    0H
         LR    R15,R1              SET ADDRESS OF WHERE FOUND
         LM    R0,R12,20(R13)      RESTORE MOST REGISTERS
         BR    R14                 RETURN
*
VKWTRTSC TRT   0(*-*,R6),0(R15)    *** EXECUTE ONLY ***
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO CALLER                                             *
*                                                                     *
***********************************************************************
*
VKWEXIT  DS    0H
         NI    PPWVKWFL,255-PPWVKWEX    TURN OFF WE ARE HERE
*
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         L     R14,12(,R13)        RELOAD RETURN ADDRESS
         LM    R2,R12,28(R13)      RELOAD REGS 2 - 12
         BR    R14                 RETURN TO CALLER
*
         DROP  ,                   KILL ALL ADDRESSIBILITY
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS AND DATA AREAS USED BY IEFCNVKW                    *
*                                                                     *
***********************************************************************
*
VKWCOMMA DC    256X'00'            COMMA TRANSLATE AND TEST TABLE
         ORG   VKWCOMMA+C','
         DC    X'FF'
         ORG   ,
*
VKWEQUAL DC    256X'00'            EQUAL TRANSLATE AND TEST TABLE
         ORG   VKWEQUAL+C'='
         DC    X'FF'
         ORG   ,
*
VKWPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVKW PATCH'
         DC    16F'0'
*
VKWLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVPD - PARAMETER DELETE SUBROUTINE'
***********************************************************************
*                                                                     *
*        IEFCNVPD                                                     *
*        ********                                                     *
*                                                                     *
*        THE ROUTINE IS CALLED TO DELETE A PARAMETER STRING FROM      *
*        THE TEXT STRING ORIGINALLY PASSED FROM THE CONVERTER.        *
*                                                                     *
*        INPUT:                                                       *
*              R1 = STARTING ADDRESS OF TEXT STRING                   *
*              R0 = TOTAL LENGTH OF STRING TO BE DELETED              *
*              PPWSTMTX -> START OF FULL TEXT STRING                  *
*              PPWSTMTL = LENGTH OF FULL TEXT STRING                  *
*                                                                     *
*        OUTPUT:                                                      *
*              UPDATED TEXT STRING AND LENGTH                         *
*              UPDATED STATEMENT TEXT BLOCK (VIA IEFCNVXT)            *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER                                       *
*                                                                     *
***********************************************************************
*
IEFCNVPD DS    0D
         USING *,R15               TEMPORARY BASE
         B     VPDSTM              BRANCH AROUND ID
*
         DC    AL1(VPDIDL)         LTH OF IDENTIFICATION PREFIX
VPDID    DC    CL8'IEFCNVPD'       USER PROCLIB SUPPORT MODULE ID
VPDIDL   EQU   *-VPDID             LENGTH OF IDENTIFICATION HEADER
*
VPDSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVPD,R12        ESTABLISH PERMANENT BASE
*
         LR    R15,R13             COPY THE CURRENT SAVE AREA ADDRESS
         N     R15,=X'FFFFF000'    ROUND BACK TO A PAGE BOUNDARY
         USING PPWDSECT,R15
         LA    R15,PPWVPDSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVPDSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVPDCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVPDCN        STORE IT BACK
*
         OI    PPWVPDFL,PPWVPDEX   INDICATE WE ARE HERE
*
         EJECT
***********************************************************************
*                                                                     *
*        DETERMINE WHERE THE STRING IS                                *
*                                                                     *
***********************************************************************
*
         L     R15,PPWSTMTX        LOAD TEXT STARTING ADDRESS
         AH    R15,PPWSTMTL        POINT PAST THE END
*
         LR    R14,R1              COPY THE STRING ADDRESS
         AR    R14,R0              GET ADDRESS FOLLOWING STRING
*
         CR    R15,R14             ARE THEY EQUAL (AT END OF TEXT)
         BNE   VPDSHIFT            IF NOT WE NEED TO DO SOME SHIFTING
*
         BCTR  R1,0                BACK TEXT START TO THE COMMA
         SR    R15,R1              CALCULATE LENGTH TO ELIMINATE
*
         EJECT
***********************************************************************
*                                                                     *
*        PARAMETER STRING IS AT THE END OF THE TEXT                   *
*                                                                     *
***********************************************************************
*
         BCTR  R15,0               DECREMENT FOR CLEARING
         EX    R15,VPDXCJCL        ZERO OUT THE REMOVED PARAMETER
*
         LA    R1,1(,R15)          PASS THE AMOUNT TO THE UPDATE RTN
         B     VPDUPDTE            AND GO UPDATE TEXT LENGTH
*
         EJECT
***********************************************************************
*                                                                     *
*        PARAMETER STRING IS NOT AT THE END OF THE TEXT STRING        *
*                                                                     *
***********************************************************************
*
VPDSHIFT DS    0H
         LA    R14,1(,R14)         POINT PAST COMMA FOLLOWING STRING
         LR    R0,R14              COPY THIS ADDRESS
         SR    R0,R1               CALCULATE AMOUNT WE ARE ELIMINATING
         SR    R15,R14             CALCULATE THE AMOUNT THAT WE SHIFT
*
VPDSHFTL DS    0H
         LR    R2,R15              COPY LENGTH TO SHIFT
         CH    R2,=H'256'          CHECK MAXIMUM SHIFT
         BNH   *+8                 BRANCH IF NOT TOO BIG
         LA    R2,256              SET MAXIMUM SHIFT
*
         BCTR  R2,0                DECREMENT FOR MVC
         EX    R2,VPDMVJCL         SHIFT THE JCL
*
         LA    R1,1(R1,R2)         INCREMENT WHERE TO SHIFT TO
         LA    R14,1(R14,R2)       INCREMENT WHERE TO SHIFT FROM
*
         SR    R15,R2              DECREMENT MOVE LENGTH (-1)
         BCT   R15,VPDSHFTL        BRANCH IF ANY RESIDUAL LENGTH
*
         LR    R15,R0              COPY LENGTH TO ELIMINATE
         BCTR  R15,0               DECREMENT IT
         EX    R15,VPDXCJCL        ZERO OUT THIS LENGTH OF JCL
*
         LR    R1,R0               PASS THE AMOUNT TO THE UPDATE RTN
         B     VPDUPDTE            AND GO UPDATE THE LENGTH
*
VPDMVJCL MVC   0(*-*,R1),0(R14)    *** EXECUTE ONLY ***
*
VPDXCJCL XC    0(*-*,R1),0(R1)     *** EXECUTE ONLY ***
*
         EJECT
***********************************************************************
*                                                                     *
*        UPDATE TEXT LENGTH - ADJUSTMENT AMOUNT ALREADY IN R1         *
*                                                                     *
***********************************************************************
*
VPDUPDTE DS    0H
         LA    R0,8                INDICATE DATA UPDATE
         L     R15,PPWCNVXT        LOAD UPDATE ROUTINE ADDRESS
         BALR  R14,R15             GO DO THE UPDATE
*
***********************************************************************
*                                                                     *
*        RETURN TO CALLER                                             *
*                                                                     *
***********************************************************************
*
VPDEXIT  DS    0H
         NI    PPWVPDFL,255-PPWVPDEX    TURN OFF WE ARE HERE
*
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         LM    R14,R12,12(R13)     RELOAD REGS 14 - 12
         BR    R14                 RETURN TO CALLER
*
         DROP  ,                   KILL ALL ADDRESSIBILITY
*
         EJECT
***********************************************************************
*                                                                     *
*        CONSTANTS AND DATA AREAS USED BY IEFCNVPD                    *
*                                                                     *
***********************************************************************
*
VPDPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVPD PATCH'
         DC    8F'0'
*
VPDLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVPS - INTERCEPT CONVERTER POST SCAN EXIT'
***********************************************************************
*                                                                     *
*        IEFCNVPS                                                     *
*        ********                                                     *
*                                                                     *
*        THE ROUTINE RECEIVES CONTROL FROM IEFCNWRT WHENEVER A        *
*        CALL IS BEING MADE TO THE CONVERTER POST SCAN EXIT.          *
*                                                                     *
*        THIS ROUTINE WILL EXTRACT THE CNMB ANCHOR ADDRESS AND        *
*        PASS ANY QUEUED MESSAGES TO THE CONVERTER.  IT THEN          *
*        WILL INVOKE THE ORIGINAL POST SCAN EXIT AND THEN RETURNS     *
*        TO THE CONVERTER.                                            *
*                                                                     *
*        WHEN THE INTERNAL TEXT FOR THE JOB CARD IS PASSED, THE       *
*        SWA LOCATION FLAG IS SET IF EITHER THE SWA KEYWORD ON THE    *
*        JOB CARD OR THE SWAABOVE/SWABELOW DD STATEMENT HAVE BEEN     *
*        SPECIFIED.                                                   *
*                                                                     *
*        INPUT:                                                       *
*              CONVERTER POST SCAN PARAMETER LIST                     *
*                                                                     *
*        OUTPUT:                                                      *
*              ANY ACCUMULATED CNMBS QUEUED TO THE CONVERTER          *
*                                                                     *
*        EXTERNAL REFERENCES:                                         *
*              CALLS THE ORIGINAL POST SCAN EXIT                      *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER (IEFCNWRT)                            *
*                                                                     *
***********************************************************************
*
IEFCNVPS DS    0D
         USING *,R15               TEMPORARY BASE
         B     VPSSTM              BRANCH AROUND ID
*
         DC    AL1(VPSIDL)         LTH OF IDENTIFICATION PREFIX
VPSID    DC    CL8'IEFCNVPS'       USER PROCLIB SUPPORT MODULE ID
VPSIDL   EQU   *-VPSID             LENGTH OF IDENTIFICATION HEADER
*
VPSSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVPS,R12        ESTABLISH PERMANENT BASE
*
         L     R15,PSATOLD-PSA     LOAD THE TCB ADDRESS
         USING TCB,R15
         L     R15,TCBFSA          LOAD THE FIRST SAVE AREA ADDRESS
         USING FSADSECT,R15
*
         CLC   FSAPPEYE,=A(FSAPPEID)    IS THIS THE RIGHT SAVE AREA
         BE    VPSCONT             IF SO, CONTINUE ON
*
         LM    R14,R12,12(R13)     RELOAD REGS 14 - 12
         BR    R14                 RETURN AND HOPE FOR THE BEST
*
         EJECT
***********************************************************************
*                                                                     *
*        ESTABLISH THE SAVE AREA AND WORK AREA ADDRESS FROM           *
*        THE ANCHORED WORK AREA.                                      *
*                                                                     *
***********************************************************************
*
VPSCONT  DS    0H
         L     R15,FSAPPWAD        LOAD THE WORK AREA ADDRESS
         USING PPWDSECT,R15
         LA    R15,PPWVPSSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVPSSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVPSCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVPSCN        STORE IT BACK
*
         OI    PPWVPSFL,PPWVPSEX   INDICATE WE ARE HERE
*
         ST    R1,PPWPSER1         SAVE THE REGISTER 1 AT OUR ENTRY
         MVC   PPWPSEPM(PPWPSEPL),0(R1) COPY THE PASSED PARAMETER LIST
*
         EJECT
***********************************************************************
*                                                                     *
*        PASS ANY ACCUMULATED CNMBS TO THE CONVERTER                  *
*                                                                     *
***********************************************************************
*
         ICM   R2,15,PPWCNMB       DO WE HAVE ANY CNMBS
         BZ    VPSNCNMB            BRANCH IF NOT
         XC    PPWCNMB,PPWCNMB     CLEAR THE ACCUMULATED CNMBS
*
         L     R1,PPWPSER1         LOAD THE PARAMETER LIST ADDRESS
         LA    R1,4(,R1)           NOW POINT AT ANCHOR WORD
*
         ICM   R15,15,0(R1)        DO WE HAVE ANY ALREADY THERE
         USING CNMB,R15
         BNZ   VPSLCNMB            IF NOT RUN THE CHAIN
*
         ST    R2,0(,R1)           STICK OURS ON
         B     VPSNCNMB            AND WE ARE DONE
*
VPSLCNMB ICM   R14,15,CNMBNPTR     RUN THE CHAIN
         BZ    VPSCCNMB            BRANCH IF AT END
         LR    R15,R14             COPY THE CNMB ADDRESS
         B     VPSLCNMB            AND TRY AGAIN
*
VPSCCNMB DS    0H
         ST    R2,CNMBNPTR         CHAIN OURS ON THE END OF THEIRS
         DROP  R15
*
VPSNCNMB DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        SET THE SWA LOCATION FLAG IN THE JOB CARD TEXT HEADER        *
*                                                                     *
***********************************************************************
*
         L     R1,PPWPSER1         LOAD THE PARM LIST ADDRESS
         L     R1,0(,R1)           LOAD THE INTERNAL TEXT ADDRESS
         USING TEXT,R1
*
         TM    STRINDCS,JOBSTR     CHECK FOR A JOB STATEMENT
         BZ    VPSNJOB             BRANCH IF NOT
*
         TM    PPWFLAG4,PPW4SWAA   DID USER REQUEST SWA=ABOVE
         BO    VPSWABOV            BRANCH IF SO
         TM    PPWFLAG4,PPW4SWAB   DID USER REQUEST SWA=BELOW
         BZ    VPSNOSWA            BRANCH IF NOT
*
         NI    STRJIND2,255-JBXA   TURN OFF SWA ABOVE THE LINE FLAG
         B     VPSNOSWA
*
VPSWABOV OI    STRJIND2,JBXA       TRUN ON SWA ABOVE THE LINE FLAG
*
VPSNOSWA DS    0H
         B     VPSPOSTX            DONE WITH THE JOB STATEMENT
*
VPSNJOB  DS    0H
         AGO   .BYPASS1
         TM    STRINDCS,EXECSTR    IS THIS AN EXEC STATEMENT
         BZ    VPSPOSTX            BRANCH IF WE AREN'T INTERESTED
*
         LA    R2,STREKEY
         CLI   0(R2),EXECK         IS THIS REALLY AN EXEC
         BNE   VPSEXECN
         CLI   1(R2),2             ARE THERE TWO PARAMETERS
         BE    VPSEXEC2            BRANCH IF SO
*
         SLR   R15,R15             CLEAR FOR INSERT
         IC    R15,2(,R2)          INSERT LABEL LENGTH
         LA    R2,3(R2,R15)        INCREMENT TO NEXT TEXT UNIT
*
         CLI   0(R2),PROCEK        IS THIS A PROC=
         BNE   VPSEXECN            BRANCH IF NOT
         CLI   1(R2),1             IS THERE ONLY ONE PARAMETER
         BNE   VPSEXECN            BRANCH IF NOT
         CLI   2(R2),8             IS IT THE RIGHT LENGTH
         BNE   VPSEXECN            BRANCH IF NOT
*
         CLC   3(8,R2),=C'TESTPROC'     TEST FOR PHONEY NAME
         BNE   VPSEXECN            BRANCH IF NOT
         MVC   3(8,R2),=C'PROCTEST'     SUBSTITUTE ALTERNATE NAME
*
         B     VPSEXECN            BRANCH IF NOT
*
VPSEXEC2 SLR   R15,R15             CLEAR FOR INSERT
         IC    R15,2(,R2)          INSERT LABEL LENGTH
         LA    R2,3(R2,R15)        INCREMENT TO NEXT TEXT UNIT
*
         CLI   0(R2),8             IS IT THE RIGHT LENGTH
         BNE   VPSEXECN            BRANCH IF NOT
*
         CLC   1(8,R2),=C'TESTPROC'     TEST FOR PHONEY NAME
         BNE   VPSEXECN            BRANCH IF NOT
         MVC   1(8,R2),=C'PROCTEST'     SUBSTITUTE ALTERNATE NAME
*
         B     VPSEXECN            BRANCH IF NOT
*
VPSEXECN DS    0H
*
.BYPASS1 ANOP
         DROP  R1
*
         EJECT
***********************************************************************
*                                                                     *
*        PASS CONTROL TO THE ORIGINAL POST SCAN EXIT                  *
*                                                                     *
***********************************************************************
*
VPSPOSTX DS    0H
*
         LA    R3,PPWEXLST         POINT AT ORIGINAL EXIT LIST
         USING CNPREXIT,R3
*
         LA    R3,CNPRXENT         POINT AT OUR EXIT SECTION
         USING CNPRXENT,R3
*
         CLI   CNPRLKID,CNPRXNAM   DO WE HAVE AN NAME
         BNE   VPSADDR             BRANCH IF NOT
*
***********************************************************************
*                                                                     *
*        POST SCAN EXIT LIST CONTAINS A NAME FIELD                    *
*                                                                     *
***********************************************************************
*
VPSNAME  DS    0H
         MVC   PPWGENWK(6),CNPREXEP     COPY FIRST 6 CHARACTERS OF NAME
         MVI   PPWGENWK+6,C' '     BLANK THE 7TH CHARACTER
         MVI   PPWGENWK+7,C' '     BLANK THE 8TH CHARACTER
*
         MVC   PPWGENWK+8(VPSLINKL),VPSLINKM COPY MODEL LINK PARM LIST
*
         OI    PPWVPSFL,PPWVPSLK   INDICATE WE ARE GOING TO POST SCAN
*
         L     R1,PPWPSER1         POINT AT POST SCAN EXIT PARM LIST
         LINK  EPLOC=PPWGENWK,SF=(E,PPWGENWK+8)
*
         NI    PPWVPSFL,255-PPWVPSLK    INDICATE WE ARE BACK
*
         B     VPSNPST
*
         EJECT
***********************************************************************
*                                                                     *
*        POST SCAN EXIT LIST CONTAINS AN ADDRESS                      *
*                                                                     *
***********************************************************************
*
VPSADDR  DS    0H
         TM    CNPRLKID,CNPRXADD+NELEXADD TEST FOR 3 OR 4 BYTE ADDR
         BZ    VPSEXIT             IF NO EXIT, DO NOTHING
*
         L     R15,CNPREXAD        LOAD THE ACTUAL EXIT ADDRESS
*
         TM    CNPRLKID,CNPRXADD   TEST FOR 4 BYTE ADDRESS
         BO    *+8                 BRANCH IF SO
         N     R15,=X'00FFFFFF'    PURIFY HIGH ORDER BYTE
*
         L     R14,CVTPTR          LOAD THE CVT ADDRESS
         USING CVT,R14
         LA    R14,CVTBSM2         POINT AT BSM RETURN
         DROP  R14
*
         OI    PPWVPSFL,PPWVPSAD   INDICATE WE ARE GOING TO POST SCAN
*
         L     R1,PPWPSER1         POINT AT POST SCAN EXIT PARM LIST
         BASSM R2,R15              CALL THE POST SCAN EXIT
*
         NI    PPWVPSFL,255-PPWVPSAD    INDICATE WE ARE BACK
*
         EJECT
VPSNPST  DS    0H
*
         DROP  R3
*
***********************************************************************
*                                                                     *
*        RETURN TO CALLER (IEFCNWRT)                                  *
*                                                                     *
***********************************************************************
*
VPSEXIT  DS    0H
         NI    PPWVPSFL,255-PPWVPSEX    TURN OFF IEFCNVPS EXECUTING
*
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         LM    R14,R12,12(R13)     RELOAD REGS 14 - 12
         BR    R14                 RETURN TO CALLER
*
         DROP  ,                   KILL ALL ADDRESSIBILITY
*
***********************************************************************
*                                                                     *
*        CONSTANTS AND DATA AREAS USED BY IEFCNVPS                    *
*                                                                     *
***********************************************************************
*
VPSLINKM LINK  EPLOC=*-*,SF=L      MODEL LINK PARM LIST
VPSLINKL EQU   *-VPSLINKM
*
VPSPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVPS PATCH'
         DC    16F'0'
*
VPSLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVCL - CLEANUP ROUTINE'
***********************************************************************
*                                                                     *
*        IEFCNVCL                                                     *
*        ********                                                     *
*                                                                     *
*        THIS ROUTINE WILL PERFORM ANY CLEANUP IT CAN DETERMINE       *
*        NEEDS TO BE DONE.  IT IS CALLED MAY TIMES IN AN ATTEMPT      *
*        TO MAKE SURE THAT NOTHING RESIDUAL IS LEFT BEHIND FROM       *
*        ONE INVOCATION OF THE CONVERTER TO ANOTHER.                  *
*                                                                     *
***********************************************************************
*
IEFCNVCL DS    0D
         USING *,R15               TEMPORARY BASE
         B     VCLSTM              BRANCH AROUND ID
*
         DC    AL1(VCLIDL)         LTH OF IDENTIFICATION PREFIX
VCLID    DC    CL8'IEFCNVCL'       USER PROCLIB SUPPORT MODULE ID
VCLIDL   EQU   *-VCLID             LENGTH OF IDENTIFICATION HEADER
*
VCLSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVCL,R12        ESTABLISH PERMANENT BASE
*
         LR    R15,R13             COPY THE CURRENT SAVE AREA ADDRESS
         N     R15,=X'FFFFF000'    ROUND BACK TO A PAGE BOUNDARY
         USING PPWDSECT,R15
         LA    R15,PPWVCLSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVCLSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVCLCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVCLCN        STORE IT BACK
*
         LA    R15,VCLEXIT         SET RECOVERY ADDRESS
         ST    R15,PPWVCLRT        SET THIS RETRY ADDRESS
*
         OI    PPWVCLFL,PPWVCLEX   INDICATE WE ARE HERE
*
         EJECT
***********************************************************************
*                                                                     *
*        CLOSE THE DYNAMIC PROCLIB DATA SET AND RESTORE THE DCB       *
*        ADDRESS IN THE CONVERTER WORK AREA BACK TO WHAT IT WAS.      *
*                                                                     *
***********************************************************************
*
         TM    PPWFLAG1,PPW1OPEN   WAS DYNAMIC PROCLIB DCB OPENED ?
         BZ    VCLNOPEN            NO, SKIP
*
         LA    R15,VCLTCLOS        POINT AT RETRY FOR CLOSE ABEND
         ST    R15,PPWVCLRT        SET THIS RETRY ADDRESS
*
         OI    PPWVCLFL,PPWVCLCL   INDICATE WE ARE CLOSING DOWN
*
         CLOSE MF=(E,PPWOCLST)     CLOSE SYSTEM PROCLIB
*
VCLTCLOS NI    PPWVCLFL,255-PPWVCLCL    TURN OFF CLOSE IN PROGRESS
*
         LA    R15,VCLEXIT         SET RECOVERY ADDRESS BACK TO NORMAL
         ST    R15,PPWVCLRT        SET THIS RETRY ADDRESS
*
         TM    PPWVPPFL,PPWVPPEX   WERE WE CALLED FROM VPP
         BO    VCLNODCB            IF SO, WE CAN'T UPDATE THE DCB ADDR
*
         L     R15,PPWCNDCB        NOW POINT AT ORIGINAL DCB
         L     R1,PPWJSDCB         LOAD ADDRESS OF CONVERTER'S DCB ADDR
         ST    R15,0(,R1)          STORE THE OLD DCB ADDRESS
*
VCLNODCB DS    0H
         NI    PPWFLAG1,255-PPW1OPEN    CLEAR OPEN STATUS
*
VCLNOPEN DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        DE-CONCATENATE THE PROCLIB DATA SETS IF MORE THAN ONE        *
*                                                                     *
***********************************************************************
*
         TM    PPWFLAG1,PPW1JPCN   ANY CONCATENATIONS DONE ?
         BZ    VCLNDCON            NO, SKIP
*
         OI    PPWVCLFL,PPWVCLDC   INDICATE DECONCATENATING
*
         LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET DARB ADDRESSABILITY
         MVI   S99VERB,S99VRBDC    INDICATE DE-CONCAT REQUEST
         LA    R15,PPWDATXT        -> TEXT UNIT PTR SLOTS
*
         USING S99TUPL,R15         GET TEXT PTR ADDRESSABILITY
         USING S99TUNIT,R14        GET TEXT UNIT ADDRESSABILITY
*
         LA    R14,PPWCONCK        -> DE-CONCATENATE TEXT UNIT
         LA    R0,DDCDDNAM         GET DE-CONCATENATE KEY
         STH   R0,S99TUKEY         SET DE-CONCATENATE KEY
         LA    R1,1                GET THE NUMBER OF DDNAMES
         STH   R1,S99TUNUM         SET NO. OF DDNAMES
         ST    R14,S99TUPTR        SET PTR TO DE-CONC TEXT UNIT
         OI    S99TUPTR,S99TUPLN   FLAG END OF TEXT UNIT PTR'S
*
         DROP  R14,R15
*
         LA    R1,PPWDARGL         -> DYNAMIC ALLOC PARM PTR
         OI    PPWFLAG3,PPW3DALC   INDICATE WE ARE IN ALLOC. CODE
         DYNALLOC ,                DE-CONCATENATE PROCLIB'S
         NI    PPWFLAG3,255-PPW3DALC    INDICATE WE ARE BACK
*
         LTR   R15,R15             WAS DE-CONCATENATION OK ?
         BZ    VCLDCONS            RETURN IF YES
*
         ST    R15,PPWDARC         STORE THE RETURN CODE
         L     R15,PPWCNVDE        LOAD THE ALLOC ANALYZE ROUTINE ADDR
         BALR  R14,R15             DO ERROR ANALYSIS
*
VCLDCONS NI    PPWFLAG1,255-PPW1JPCN    CLEAR CONCATENATION STATUS
         NI    PPWVCLFL,255-PPWVCLDC    DONE WITH DECONCATENATING
*
VCLNDCON DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        DE-ALLOCATE THE USER AND SYSTEM PROCLIB DATA SETS            *
*                                                                     *
***********************************************************************
*
         LH    R2,PPWJPCNT         GET COUNT OF CONCATENATIONS
         LTR   R2,R2               DO WE HAVE ANYTHING TO FREE ?
         BZ    VCLNDALC            NO, GO RESET STATUS FLAGS
*
         OI    PPWVCLFL,PPWVCLDA   INDICATE DEALLOCATING
*
         LA    R15,PPWDARB         -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R15           GET DARB ADDRESSABILITY
         MVI   S99VERB,S99VRBUN    INDICATE UNALLOC REQUEST
         LA    R15,PPWDATXT        -> TEXT UNIT PTR SLOTS
*
         USING S99TUPL,R15         GET TEXT PTR ADDRESSABILITY
         USING S99TUNIT,R3         GET TEXT UNIT ADDRESSABILITY
*
         LA    R3,PPWDDNMK         -> DDNAME TEXT UNIT
         LA    R0,DUNDDNAM         SET DDNAME TEXT KEY
         STH   R0,PPWDDNMK         SET DDNAME TEXT KEY
*
         ST    R3,S99TUPTR         SET PTR TO DDNAME TEXT UNIT
         OI    S99TUPTR,S99TUPLN   FLAG END OF TEXT UNIT PTR'S
*
         DROP  R15
*
VCLDEDDN DS    0H
         LR    R15,R2              GET THE CURRENT COUNTER
         BCTR  R15,0               SUBTRACT ONE
         MH    R15,=Y(L'PPWCONCD)  GET OFFSET IN DDNAME LIST
         LA    R15,PPWCONCD(R15)   POINT TO ACTUAL NAME
         MVC   S99TUPAR(8),2(R15)  MOVE THE DDNAME
*
         DROP  R3
*
         LA    R1,PPWDARGL         -> DYNAMIC ALLOC PARM PTR
         OI    PPWFLAG3,PPW3DALC   INDICATE WE ARE IN ALLOC. CODE
         DYNALLOC ,                FREE A PROCLIB DATA SET
         NI    PPWFLAG3,255-PPW3DALC    INDICATE WE ARE BACK
*
         LTR   R15,R15             DID DE-ALLOCATE GO OK ?
         BZ    VCLDENXT            YES, CONTINUE ON
*
         ST    R15,PPWDARC         STORE THE RETURN CODE
         L     R15,PPWCNVDE        LOAD THE ALLOC ERROR ROUTINE ADDR
         BALR  R14,R15             DO ERROR ANALYSIS
*
VCLDENXT BCT   R2,VCLDEDDN         DE-ALLOCATE ALL PROCLIB'S
*
         STH   R2,PPWJPCNT         RESET CONCATENATION COUNTER
         NI    PPWVCLFL,255-PPWVCLDA    RESET DEALLOCATING
*
VCLNDALC DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        RESTORE THE POST SCAN EXIT PARAMETER IN THE PARAMETER LIST   *
*                                                                     *
***********************************************************************
*
         TM    PPWVPPFL,PPWVPPEX   ARE WE CALLED FROM IEFCNVPP
         BZ    VCLNPOST            BRANCH IF NOT
*
         TM    PPWFLAG2,PPW2PSEI   IS THE POST SCAN INTERCEPT ACTIVE
         BZ    VCLNPOST            BRANCH IF NOT
*
         L     R1,PPWCNTXT         LOAD ADDRESS OF PASSED TXT EXIT LIST
         L     R15,PPWPMTXT        POINT AT PARAMETER LIST
         ST    R1,0(,R15)          RESTORE THE PARAMETER LIST
*
         NI    PPWFLAG2,255-PPW2PSEI    INDICATE INTERCEPT IS NOW GONE
*
VCLNPOST DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        DELETE THE DATA SET INCLUSION/EXCLUSION MODULE               *
*                                                                     *
***********************************************************************
*
         TM    PPWFLAG3,PPW3DSNL   DID WE LOAD THE DATA SET NAME MODULE
         BZ    VCLNODSL            BRANCH IF NOT
*
         DELETE EPLOC=PPWDSNLS     DELETE THE MODULE
*
         NI    PPWFLAG3,255-PPW3DSNL    TURN OFF MODULE LOADED FLAG
*
VCLNODSL DS    0H
*
***********************************************************************
*                                                                     *
*        CANCEL THE ESTAE AS WE ARE ESSENTIALLY DONE.                 *
*                                                                     *
***********************************************************************
*
         TM    PPWFLAG3,PPW3ESTA   DO WE HAVE OUR ESTAE ACTIVE
         BZ    VCLNESTA            BRANCH IF NOT
*
         ESTAE 0
*
         NI    PPWFLAG3,255-PPW3ESTA    TURN OFF ESTAE STATUS FLAG
*
VCLNESTA DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO THE CALLER                                         *
*                                                                     *
***********************************************************************
*
VCLEXIT  DS    0H
         NI    PPWVCLFL,255-PPWVCLEX    REMOVE BEING HERE
*
         L     R13,4(,R13)         UNCHAIN SAVE AREAS
         LM    R14,R12,12(R13)     RESTORE REGISTERS
         BR    R14                 AND RETURN TO CALLER
*
         DROP  ,
*
***********************************************************************
*                                                                     *
*        DATA NEEDED FOR CLEANUP                                      *
*                                                                     *
***********************************************************************
*
VCLPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVCL PATCH'
         DC    16F'0'
*
VCLLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'DYNAMIC ALLOCATION ERROR ANALYSIS'
***********************************************************************
*                                                                     *
*        IEFCNVDE                                                     *
*        ********                                                     *
*                                                                     *
*        THIS ROUTINE ANALYZES ERRORS DETECTED BY THE OS/VS DYNAMIC   *
*        ALLOCATION ROUTINES. COMMON ERRORS WILL CAUSE A SPECIFIC     *
*        ERROR MESSAGE TO BE PRODUCED WHILE ALL OTHERS WILL CAUSE     *
*        A WTP MESSAGE GIVING A LESS PRECISE ERROR DESCRIPTION.       *
*        IN THIS LATTER CASE THE USER WILL ALSO RECEIVE MESSAGE       *
*        XXX808I INFORMING HIM THAT HE SHOULD EXAMINE THE WTP         *
*        MESSAGE FOR ERROR DIAGNOSIS.                                 *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER VIA R14.                              *
*              ABEND THE CONVERTER BECAUSE OF UNRECOVERABLE ERROR.    *
*                                                                     *
***********************************************************************
*
IEFCNVDE DS    0D
         USING *,R15               TEMPORARY BASE
         B     VDESTM              BRANCH AROUND ID
*
         DC    AL1(VDEIDL)         LTH OF IDENTIFICATION PREFIX
VDEID    DC    CL8'IEFCNVDE'       USER PROCLIB SUPPORT MODULE ID
VDEIDL   EQU   *-VDEID             LENGTH OF IDENTIFICATION HEADER
*
VDESTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVDE,R12        ESTABLISH PERMANENT BASE
*
         LR    R15,R13             COPY THE CURRENT SAVE AREA ADDRESS
         N     R15,=X'FFFFF000'    ROUND BACK TO A PAGE BOUNDARY
         USING PPWDSECT,R15
         LA    R15,PPWVDESA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVDESA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVDECN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVDECN        STORE IT BACK
*
         LA    R15,VDEEXIT         POINT AT RECOVERY ADDRESS
         ST    R15,PPWVDERT        AND STORE IN RETRY FIELD
*
         OI    PPWVDEFL,PPWVDEEX   INDICATE WE ARE HERE
*
         IEFCNTRC ENTERVDE
*
         LA    R2,PPWDARB          -> DYNAMIC ALLOC REQUEST BLOCK
         USING S99RB,R2            MAKE DARB ADDRESSABLE
*
         MVC   PPWDFRCD,PPWDARC    SET RETURN CODE FOR DAIRFAIL
*
         EJECT
***********************************************************************
*                                                                     *
*        ANALYZE ALLOCATION TIME ERRORS                               *
*                                                                     *
***********************************************************************
*
         CLI   S99VERB,S99VRBAL    IS THIS AN ALLOCATION FAILURE
         BNE   VDEAERRC            NO, TRY CONCATENATION
*
         CLI   S99ERROR,DALOCATE   IS THIS A CATALOG LOCATE ERROR
         BE    VDEER805            GO GIVE ERROR MESSAGE
         CLI   S99ERROR,DALOBTAN   IS THIS AN OBTAIN ERROR ?
         BE    VDEER807            GO GIVE ERROR MESSAGE
         CLI   S99ERROR,DALRNOTA   IS THIS A "RESOURCE" ERROR ?
         BNE   VDEER808            NO, GIVE ERROR CODE IN MESSAGE
*
         CLI   S99ERROR+1,DALDSNEX EXCLUSIVE "DSN" REQUEST ?
         BE    VDEER813            YES, GIVE ERROR MESSAGE
         CLI   S99ERROR+1,DALDSNNA DATA SET CURRENTLY "IN USE" ?
         BE    VDEER813            YES, GIVE ERROR MESSAGE
         CLI   S99ERROR+1,DALUNITE UNIT NOT AVAILABLE ?
         BE    VDEER814            YES, GIVE ERROR MESSAGE
         CLI   S99ERROR+1,DALUNITI INVALID UNIT NAME ?
         BE    VDEER814            YES, GIVE ERROR MESSAGE
         CLI   S99ERROR+1,DALVOLNM VOLUME NOT MOUNTED ?
         BE    VDEER806            YES, GIVE ERROR MESSAGE
         CLI   S99ERROR+1,DALVOLNA VOLUME NOT AVAILABLE ?
         BE    VDEER806            YES, GIVE ERROR MESSAGE
         CLI   S99ERROR+1,DALCVOLE CVOL NOT MOUNTED ?
         BE    VDEER815            YES, GIVE ERROR MESSAGE
*
         B     VDEER808            GIVE GENERAL FAILURE MESSAGE
*
         EJECT
***********************************************************************
*                                                                     *
*        ANALYZE CONCATENATION ERRORS                                 *
*                                                                     *
***********************************************************************
*
VDEAERRC CLI   S99VERB,S99VRBCC    CONCATENATION FAILURE ?
         BE    VDEER809            GIVE ERROR MESSAGE
*
***********************************************************************
*                                                                     *
*        ANALYZE DE-CONCATENATION ERRORS                              *
*                                                                     *
***********************************************************************
*
VDEAERRD CLI   S99VERB,S99VRBDC    DE-CONCATENATION FAILURE ?
         BNE   VDEAERRR            NO, TRY DE-ALLOCATION
*
         CLC   S99ERROR,=X'0438'   DDNAME NOT FOUND ?
         BNE   VDEER808            NO, GIVE MESSAGE AND ABEND
*
         B     VDEEXIT             RETURN -> IGNORE ERROR
*
***********************************************************************
*                                                                     *
*        ANALYZE DE-ALLOCATION ERRORS                                 *
*                                                                     *
***********************************************************************
*
VDEAERRR CLI   S99VERB,S99VRBUN    DE-ALLOCATION FAILURE ?
         BNE   VDEEXIT             IMPOSSIBLE ERROR -> RETURN
*
         CLC   S99ERROR,=X'0438'   DDNAME NOT FOUND ?
         BNE   VDEER808            NO, GIVE MESSAGE AND ABEND
*
         B     VDEEXIT             RETURN TO CALLER
*
         EJECT
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATION - CATALOG SEARCH ERROR                    *
*                                                                     *
***********************************************************************
*
VDEER805 DS    0H
         LA    R0,MSGNO805
         B     VDEAERRM
*
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATION - VOLUME NOT MOUNTED                      *
*                                                                     *
***********************************************************************
*
VDEER806 DS    0H
         LA    R0,MSGNO806
         B     VDEAERRM
*
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATION - DATA SET NOT ON VOLUME                  *
*                                                                     *
***********************************************************************
*
VDEER807 DS    0H
         LA    R0,MSGNO807
         B     VDEAERRM
*
         EJECT
***********************************************************************
*                                                                     *
*        GENERAL DEALLOCATION ERROR - USE DAIRFAIL                    *
*                                                                     *
***********************************************************************
*
VDEER808 DS    0H
         LA    R1,PPWDFPRM         -> DAIRFAIL PARM LIST
*
         OI    PPWVDEFL,PPWVDEDF   INDICATE WE ARE DAIRFAILING
         LINK  SF=(E,VDEDFAIL)     ISSUE WTP FOR FAILURE
         NI    PPWVDEFL,255-PPWVDEDF    WE ARE NOW BACK FROM DAIRFAIL
*
         CLI   S99VERB,S99VRBDC    FAILURE DURING DE-CONCAT. ?
         BE    VDEER816            YES, ABEND THE CONVERTER
         CLI   S99VERB,S99VRBUN    FAILURE DURING DE-ALLOCATION ?
         BE    VDEER817            YES, ABEND THE CONVERTER
*
         LA    R0,MSGNO808         PROCLIB ALLOCATION FAILED
         B     VDEAERRM            ISSUE ERROR MESSAGE
*
***********************************************************************
*                                                                     *
*        GENERAL CONCATENATION ERROR - USE DAIRFAIL                   *
*                                                                     *
***********************************************************************
*
VDEER809 DS    0H
         LA    R1,PPWDFPRM         -> DAIRFAIL PARM LIST
*
         OI    PPWVDEFL,PPWVDEDF   INDICATE WE ARE DAIRFAILING
         LINK  SF=(E,VDEDFAIL)     ISSUE WTP FOR FAILURE
         NI    PPWVDEFL,255-PPWVDEDF    WE ARE NOW BACK FROM DAIRFAIL
*
         LA    R0,MSGNO809         USER PROCLIB CONCATENATION ERR
         B     VDEAERRM
*
         EJECT
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATION - DATA SET IN USE                         *
*                                                                     *
***********************************************************************
*
VDEER813 DS    0H
         LA    R0,MSGNO813
         B     VDEAERRM
*
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATION - UNIT NOT AVAILABLE (INVALID)            *
*                                                                     *
***********************************************************************
*
VDEER814 DS    0H
         LA    R0,MSGNO814
         B     VDEAERRM
*
***********************************************************************
*                                                                     *
*        DYNAMIC ALLOCATION - CATALOG NOT AVAILABLE                   *
*                                                                     *
***********************************************************************
*
VDEER815 DS    0H
         LA    R0,MSGNO815
         B     VDEAERRM
*
         EJECT
***********************************************************************
*                                                                     *
*        DECONCATENTAION FAILURE                                      *
*                                                                     *
***********************************************************************
*
VDEER816 DS    0H
         LA    R0,MSGNO816         GIVE USER ERROR MESSAGE TOO
*
         B     VDEABEND            AND ABEND THE CONVERTER
*
***********************************************************************
*                                                                     *
*        DEALLOCATION FAILURE                                         *
*                                                                     *
***********************************************************************
*
VDEER817 DS    0H
         LA    R0,MSGNO817         LOAD THE MESSAGE NUMBER
*
VDEABEND DS    0H
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE ADDRESS
         BALR  R14,R15             GO ISSUE MESSAGE
*
***********************************************************************
*                                                                     *
*        ABEND THE CONVERTER                                          *
*                                                                     *
***********************************************************************
*
         ABEND PPABEND,DUMP,,SYSTEM LET JES CLEANUP CONVERTER
*
***********************************************************************
*                                                                     *
*        DISPLAY ERROR MESSAGE                                        *
*                                                                     *
***********************************************************************
*
VDEAERRM DS    0H
         L     R15,PPWCNVMS        GIVE USER ERROR MESSAGE
         BALR  R14,R15
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO CALLER                                             *
*                                                                     *
***********************************************************************
*
VDEEXIT  DS    0H
         NI    PPWVDEFL,255-PPWVDEEX    INDICATE WE ARE LEAVING
*
         L     R13,4(,R13)         UNCHAIN SAVE AREA
         LM    R14,R12,12(R13)     RESTORE ALL REGISTERS
         BR    R14                 RETURN TO CALLER
*
         DROP  ,
*
***********************************************************************
*                                                                     *
*        DATA AREA FOR DYNAMIC ALLOCATION ERROR MESSAGE ROUTINE       *
*                                                                     *
***********************************************************************
*
VDEDFAIL LINK EP=IKJEFF18,SF=L     DAIRFAIL LINK PARM LIST
*
DALOCATE EQU   X'17'               CATALOG LOCATE FAILED
DALOBTAN EQU   X'67'               DSCB OBTAIN FAILED
DALRNOTA EQU   X'02'               RESOURCE NOT AVAILABLE
DALDSNEX EQU   X'0C'                  UNABLE TO GET DATA SET EXCLUSIVE
DALDSNNA EQU   X'10'                  DATA SET IN USE
DALUNITE EQU   X'14'                  UNAVAILABLE UNIT SPECIFIED
DALVOLNM EQU   X'18'                  REQUIRED VOLUME NOT MOUNTED
DALUNITI EQU   X'1C'                  INVALID UNIT SPECIFIED
DALVOLNA EQU   X'20'                  VOLUME NOT AVAILABLE
DALCVOLE EQU   X'3C'                  CVOL NOT MOUNTED
*
VDEPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVDE PATCH'
         DC    8F'0'
*
VDELITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVMS - ISSUE MESSAGE ROUTINE'
***********************************************************************
*                                                                     *
*        IEFCNVMS                                                     *
*        ********                                                     *
*                                                                     *
*        THIS ROUTINE WILL ISSUE A MESSAGE.  THE MESSAGE WILL EITHER  *
*        BE ISSUED AS A WTO, STORED IN A CNMB FOR LATER PASSING TO    *
*        THE CONVERTER, OR PASSED TO THE CONVERTER INTERNAL MESSAGE   *
*        ROUTINE.                                                     *
*                                                                     *
*        SOME MESSAGE WILL RESULT IN THE JCL ERROR FLAG BEING SET.    *
*                                                                     *
*        INPUT:                                                       *
*              REGISTER 0 CONTAINS THE MESSAGE NUMBER                 *
*              IT WILL BE NEGATIVE IF A WTO IS TO BE ISSUED           *
*              (NO JCL ERROR IN THIS CASE).                           *
*              REGISTER 1 CONTAINS THE ADDRESS OF VARIABLE TEXT       *
*              (IF ANY) - A HALF WORD LENGTH FOLLOWED BY THE TEXT     *
*              REGISTER 14 IS THE RETURN ADDRESS UNLESS THE BYTE      *
*              IT POINTS TO IS ZERO.  IN THIS CASE, THE VARIABLE      *
*              DATA IS INLINE AND RETURN IS TO 2 BYTES PLUS THE       *
*              LENGTH OF THE INLINE DATA (PLUS ONE IF ODD) BEYOND     *
*              THE ADDRESS IN REGISTER 14.                            *
*                                                                     *
*        EXIT:                                                        *
*              RETURN TO CALLER OF THIS ROUTINE.                      *
*                                                                     *
***********************************************************************
*
IEFCNVMS DS    0D
         USING *,R15               TEMPORARY BASE
         B     VMSSTM              BRANCH AROUND ID
*
         DC    AL1(VMSIDL)         LTH OF IDENTIFICATION PREFIX
VMSID    DC    CL8'IEFCNVMS'       USER PROCLIB SUPPORT MODULE ID
VMSIDL   EQU   *-VMSID             LENGTH OF IDENTIFICATION HEADER
*
VMSSTM   STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVMS,R12        ESTABLISH PERMANENT BASE
*
         LR    R15,R13             COPY THE CURRENT SAVE AREA ADDRESS
         N     R15,=X'FFFFF000'    ROUND BACK TO A PAGE BOUNDARY
         USING PPWDSECT,R15
         LA    R15,PPWVMSSA        POINT AT NEW SAVE AREA
*
         ST    R13,4(,R15)         STORE BACK POINTER
         ST    R15,8(,R13)         STORE FORWARD POINTER
         LR    R13,R15             SET NEW SAVE AREA POINTER
*
         DROP  R15                 DROP AREA ADDRESSABILITY
         USING PPWVMSSA,R13        AND START IT AT THE SAVE AREA
*
         L     R15,PPWVMSCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVMSCN        STORE IT BACK
*
         LA    R15,VMSEXIT         POINT AT RECOVERY ADDRESS
         ST    R15,PPWVMSRT        STORE IN RETRY FIELD
*
         OI    PPWVMSFL,PPWVMSEX   INIDCATE WE ARE EXECUTING
*
         EJECT
***********************************************************************
*                                                                     *
*        GO FORMAT THE MESSAGE TEXT                                   *
*                                                                     *
***********************************************************************
*
         CLI   0(R14),X'00'        CHECK FOR INLINE VARIABLE DATA
         BNE   *+6                 BRANCH IF NOT INLINE
         LR    R1,R14              COPY DATA ADDRESS
*
         BAL   R14,VMSLOCMS        GO BUILD THE MESSAGE
*
         L     R2,PPWVMTAD         LOAD THE MESSAGE TABLE ADDRESS
         USING MSGDSECT,R2
*
         TM    MSGFLAG1,MSG1TRCE   IS THIS A TRACING MESSAGE
         BZ    VMSNTRCE            BRANCH IF NOT
         TM    PPWOPTN1,PPWO1DBG   ARE WE IN TRACE MODE
         BZ    VMSEXIT             RETURN WITH NO MESSAGE IF NOT
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VMSEXIT             NO TRACING MESSAGE IF MASTER
*
VMSNTRCE DS    0H
         TM    MSGFLAG1,MSG1ERR    TEST FOR FATAL ERROR MESSAGE
         BZ    *+8                 BRANCH IF NOT
         OI    PPWFLAG1,PPW1JPER   BYPASS ALL FURTHER PROCESSING
*
         LTR   R0,R0               TEST IF NEGATIVE
         BM    VMSDOWTO            IF SO, MESSAGE IS A WTO
*
         TM    MSGFLAG1,MSG1WTO    IS THIS A WTO ONLY MESSAGE
         BO    VMSDOWTO            BRANCH IF SO
*
         ICM   R0,15,PPWCNVWA      DO WE HAVE AN ADDRESS HERE
         BNZ   VMSIMMED            IF SO, USE IMMEDIATE MSG ROUTINE
*
         EJECT
***********************************************************************
*                                                                     *
*        BUILD A CNMB FOR LATER PASSING TO THE CONVERTER              *
*                                                                     *
***********************************************************************
*
         LA    R14,(CNMBSIZE+CNMBMAXL+7)/8*8 CALCULATE SIZE OF CNMB
*
         GETMAIN RU,LV=(R14),                                          X
               SP=230,LOC=(BELOW,ANY) GET A CNMB
*
         USING CNMB,R1
         XC    CNMB((CNMBSIZE+CNMBMAXL+7)/8*8),CNMB CLEAR THE CNMB
*
         MVC   CNMBID,=A(CNMBCID)  SET THE BLOCK ID
         MVI   CNMBVER,CNMBCVER    SET THE VERSION
         MVI   CNMBSUBP,230        SET THE SUBPOOL
         STH   R14,CNMBLEN         STORE THE LENGTH
*
         TM    MSGFLAG1,MSG1ERR    TEST FOR FATAL ERROR MESSAGE
         BZ    *+8                 BRANCH IF NOT
         OI    CNMBOPTS,CNMBFJOB   INDICATE THE JOB SHOULD BE FAILED
*
         LH    R15,PPWMSGLN        LOAD THE MESSAGE LENGTH
         CH    R15,=Y(CNMBMAXL)    CHECK MAXIMUM LENGTH MESSAGE
         BNH   *+8                 BRANCH IF OK
         LA    R15,CNMBMAXL        SET THIS AS THE MAXIMUM
*
         STC   R15,CNMBMLEN        STORE THE MESSAGE LENGTH
         BCTR  R15,0               SUBTRACT THE OBIGATORY ONE
         EX    R15,VMSMSGMV        MOVE THE TEXT
*
         DROP  R1
*
         EJECT
***********************************************************************
*                                                                     *
*        CHAIN THE NEW CNMB ONTO ANY PREVIOUS ONES                    *
*                                                                     *
***********************************************************************
*
         LA    R15,PPWCNMB-(CNMBNPTR-CNMB) FAKE THE CNMB POINTER
         USING CNMB,R15            FAKE A USING
*
VMSCNMBL ICM   R14,15,CNMBNPTR     LOAD POINTER TO NEXT CNMB
         BZ    VMSCNMBA            BRANCH IF AT THE END
         LR    R15,R14             SHIFT THIS ADDRESS
         B     VMSCNMBL            AND TRY AGAIN
*
VMSCNMBA ST    R1,CNMBNPTR         CHAIN ON THIS CNMB
*
         TM    PPWOPTN1,PPWO1DBG   ARE WE IN TRACING MODE
         BO    VMSDOWTO            IF SO, ALSO ISSUE WTO
         B     VMSEXIT             IF NOT, WE ARE DONE
*
         DROP  R15
*
         USING CNMB,R1
VMSMSGMV MVC   CNMBMSG(*-*),PPWMSGTX MOVE MESSAGE TEXT - EXECUTE ONLY
         DROP  R1
*
         EJECT
***********************************************************************
*                                                                     *
*        ISSUE MESSAGE USING CONVERTER IMMEDIATE MESSAGE ROUTINE      *
*                                                                     *
***********************************************************************
*
VMSIMMED DS    0H
         OI    PPWVMSFL,PPWVMSIM   INDICATE WE ARE IN THE IMM ROUTINE
*
         LA    R0,12               INDICATE WE NEED TO ISSUE A MESSAGE
         LR    R1,R2               PASS THE MESSAGE TABLE ADDRESS
         L     R15,PPWCNVXT        LOAD THE ROUTINE ADDRESS
         BALR  R14,R15             GO CALL THE SUBROUTINE
*
         NI    PPWVMSFL,255-PPWVMSIM    INDICATE WE ARE BACK
*
         TM    PPWOPTN1,PPWO1DBG   ARE WE IN TRACING MODE
         BO    VMSDOWTO            IF SO, ALSO ISSUE WTO
         B     VMSEXIT             IF NOT, WE ARE DONE
*
         DROP  R2                  DONE WITH MESSAGE TABLE
*
         EJECT
***********************************************************************
*                                                                     *
*        MESSAGE IS AN OPERATOR WTO                                   *
*                                                                     *
***********************************************************************
*
VMSDOWTO DS    0H
         MVC   PPWTOWRK(4),PPWWTOMD     MOVE THE WTO PREFIX
         LA    R15,PPWTOWRK+4
*
         LH    R1,PPWMSGLN         LOAD THE MESSAGE LENGTH
         BCTR  R1,0                SUBTRACT THE OBIGATORY ONE
         EX    R1,VMSWTOMV         MOVE THE TEXT
*
         LA    R15,1(R15,R1)       CALCULATE PAST THE TEXT
         MVC   0(4,R15),PPWWTOMD+4 MOVE THE ROUTE/DESC CODES
*
         LH    R1,PPWMSGLN         LOAD THE MESSAGE LENGTH
         AH    R1,PPWTOWRK         ADD IN MODEL LENGTH
         STH   R1,PPWTOWRK         STORE THE NEW LENGTH
*
         OI    PPWVMSFL,PPWVMSWT   INDICATE WE ARE WTOING
*
         WTO   MF=(E,PPWTOWRK)     ISSUE THE WTO
*
         NI    PPWVMSFL,255-PPWVMSWT    INDICATE WE ARE BACK
*
         B     VMSEXIT             AND RETURN
*
VMSWTOMV MVC   0(*-*,R15),PPWMSGTX MOVE THE TEXT - EXECUTE ONLY
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO CALLER                                             *
*                                                                     *
***********************************************************************
*
VMSEXIT  DS    0H
         NI    PPWVMSFL,255-PPWVMSEX    INIDCATE WE ARE RETURNING
*
         L     R13,4(,R13)         UNCHAIN SAVE AREAS
         L     R14,12(,R13)        LOAD RETURN ADDRESS
         CLI   0(R14),0            CHECK FOR INLINE DATA
         BNE   VMSEXITO            BRANCH IF NOT INLINE
*
         LH    R15,0(,R14)         LOAD THE TRACE ID LENGTH
         TM    1(R14),X'01'        TEST FOR ODD NUMBER
         BZ    *+8                 BRANCH IF NOT ODD
         LA    R15,1(,R15)         INCREMENT SIZE
*
         LA    R14,2(R14,R15)      INCREMENT PAST THE INLINE DATA
*
VMSEXITO DS    0H
         LM    R15,R12,16(R13)     RELOAD SAVED REGISTERS
         BR    R14                 RETURN
*
         EJECT
***********************************************************************
*                                                                     *
*        LOCATE THE MESSAGE TEXT ENTRY AND BUILD THE MESSAGE          *
*                                                                     *
*        R0 CONTAINS THE MESSAGE NUMBER (MAY BE NEGATIVE)             *
*        R1 CONTAINS THE VARIABLE TEXT POINTER                        *
*                                                                     *
*        ON EXIT, PPWVMTAD WILL CONTAIN MESSAGE TABLE ADDRESS         *
*                 PPWMSGTX WILL CONTAIN CONSTRUCTED MESSAGE TEXT      *
*                 PPWMSGLN WILL CONTAIN CONSTRUCTED MESSAGE LENGTH    *
*                                                                     *
***********************************************************************
*
VMSLOCMS DS    0H
         STM   R14,R12,12(R13)     SAVE ALL REGISTERS
         OI    PPWVMSFL,PPWVMSMB   INDICATE WE ARE BUILDING MESSAGE
*
         L     R2,=A(IEFCNMSG)     LOAD MESSAGE TABLE ADDRESS
         USING MSGDSECT,R2
*
         LPR   R0,R0               MAKE SURE NUMBER IS POSITIVE
*
VMSLOCLP CLC   MSGMSGNO,=H'0'      ARE WE AT THE END
         BE    VMSLOCFN            IF SO, RETURN NULL MESSAGE
         CLM   R0,3,MSGMSGNO       MATCH MESSAGE NUMBERS
         BE    VMSLOCFN            RETURN IF FOUND
*
         AH    R2,MSGNEXT          GET THE NEXT MESSAGE ADDRESS
         B     VMSLOCLP            AND TRY AGAIN
*
VMSLOCFN DS    0H
         ST    R2,PPWVMTAD         SAVE ADDRESS OF TABLE
*
         TM    MSGFLAG1,MSG1TRCE   IS THIS A TRACING MESSAGE
         BZ    VMSLOCNT            BRANCH IF NOT
         TM    PPWOPTN1,PPWO1DBG   ARE WE IN TRACE MODE
         BZ    VMSLOCEX            RETURN WITH NO MESSAGE IF NOT
         TM    PPWENVIR,PPWEMSTR   IS THIS THE MASTER
         BO    VMSLOCEX            NO TRACING MESSAGE IF MASTER
*
VMSLOCNT DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        BEGIN CONSTRUCTING THE MESSAGE                               *
*                                                                     *
***********************************************************************
*
         MVC   PPWMSGTX(8),PPWMSGPF     COPY THE MESSAGE PREFIX
         LA    R15,PPWMSGTX
         AH    R15,PPWMSGPL        ADD THE MESSAGE PREFIX LENGTH
*
         CVD   R0,PPWDOUBL         CONVERT TO DECIMAL
         OI    PPWDOUBL+7,X'0F'    FIX THE SIGN
         UNPK  0(3,R15),PPWDOUBL+6(2)   PUT NUMBER IN MESSAGE
         MVC   3(2,R15),=C'I '     SET THE SUFFIX AND SPACE
         LA    R15,5(,R15)         INCREMENT TO WHERE TEXT STARTS
*
         TM    MSGFLAG1,MSG1VAR    DO WE HAVE ANY VARIABLE DATA
         BO    VMSLOCVR            BRANCH IF SO
*
         LH    R14,MSGMSGLN        LOAD THE MESSAGE LENGTH
         BCTR  R14,0               SUBTRACT THE OBIGATORY ONE
         EX    R14,VMSLOCMV        MOVE THE TEXT
         LA    R15,1(R15,R14)      INCREMENT PAST THE TEXT
         B     VMSLOCRT            AND RETURN
*
         EJECT
***********************************************************************
*                                                                     *
*        MESSAGE IS TO CONTAIN VARIABLE DATA                          *
*                                                                     *
***********************************************************************
*
VMSLOCVR DS    0H
         LH    R14,MSGVAROF        LOAD THE VARIABLE OFFSET
         LTR   R14,R14
         BZ    VMSLOCVA            BRANCH IF 0 - OFFSET AT START
*
         BCTR  R14,0               SUBTRACT THE ONE
         EX    R14,VMSLOCMV        MOVE THE FIRST PART OF TEXT
         LA    R15,1(R15,R14)      INCREMENT PAST THE TEXT
*
***********************************************************************
*                                                                     *
*        DETERMINE IF VARIABLE DATA IS ONE OF THE "CANNED" TYPES      *
*                                                                     *
***********************************************************************
*
VMSLOCVA DS    0H
         TM    MSGFLAG2,MSG2JBPR   IS THIS A JOBPROC VARIABLE DATA
         BZ    *+8                 BRANCH IF NOT
         LA    R1,PPWJBPRL         IS SO, POINT AT JOBPROC DD LENGTH
*
         TM    MSGFLAG2,MSG2SYSP   IS THIS A SYSPROC VARIABLE DATA
         BZ    *+8                 BRANCH IF NOT
         LA    R1,PPWSYSPL         IS SO, POINT AT SYSPROC KEYWORD LEN
*
         TM    MSGFLAG2,MSG2DSN    IS THIS A DSNAME VARIABLE REQUEST
         BZ    *+8                 BRANCH IF NOT
         LA    R1,PPWDSNML         IS SO, POINT AT DSNAME LENGTH
*
         TM    MSGFLAG2,MSG2SWAK   IS THIS A SWA VARIABLE DATA
         BZ    *+8                 BRANCH IF NOT
         LA    R1,PPWSWAKL         IS SO, POINT AT KEYWORD LENGTH
*
         LH    R14,0(,R1)          LOAD THE VARIABLE LENGTH
         LTR   R14,R14             TEST FOR A NULL LENGTH
         BNZ   *+12                BRANCH IF LENGTH OK
         LA    R1,VMSLOCUK         POINT AT UNKNOWN VARIABLE DATA
         LH    R14,0(,R1)          LOAD THE UNKNOWN LENGTH
*
         EJECT
***********************************************************************
*                                                                     *
*        MOVE THE VARIABLE DATA                                       *
*                                                                     *
***********************************************************************
*
         LA    R1,2(,R1)           BUMP PAST THE LENGTH PREFIX
         BCTR  R14,0               DECREMENT THE TRADITIONAL 1
         EX    R14,VMSLOCVM        MOVE THE VARIABLE DATA
         LA    R15,1(R15,R14)      INCREMENT PAST THE TEXT
*
         LH    R14,MSGMSGLN        LOAD THE MESSAGE LENGTH
         LH    R0,MSGVAROF         LOAD THE VARIABLE OFFSET
         SR    R14,R0              GET THE RESIDUAL LENGTH
         BZ    VMSLOCRT            IF NONE, VARIABLE DATA WAS AT END
*
***********************************************************************
*                                                                     *
*        MOVE THE SECOND PART OF THE MESSAGE                          *
*                                                                     *
***********************************************************************
*
         LA    R1,MSGMSGTX         POINT AT START OF TEXT
         AR    R1,R0               POINT TO SECOND HALF OF MESSAGE
         BCTR  R14,0               SUBTRACT THE ONE
         EX    R14,VMSLOCVM        MOVE THE VARIABLE DATA
         LA    R15,1(R15,R14)      INCREMENT PAST THE TEXT
*
         EJECT
***********************************************************************
*                                                                     *
*        CALCULATE THE LENGTH OF THE MESSAGE TEXT                     *
*                                                                     *
***********************************************************************
*
VMSLOCRT DS    0H                  COPY MESSAGE ADDRESS
         LA    R14,PPWMSGTX        POINT AT TEXT START
         SR    R15,R14             CALCULATE THE LENGTH
         STH   R15,PPWMSGLN        STORE THE MESSAGE LENGTH
*
VMSLOCEX DS    0H                  COPY MESSAGE ADDRESS
         NI    PPWVMSFL,255-PPWVMSMB    INIDCATE MESSAGE BUILD DONE
         LM    R14,R12,12(R13)     RELOAD REGISTERS
         BR    R14
*
VMSLOCMV MVC   0(*-*,R15),MSGMSGTX MOVE MESSAGE TEXT - EXECUTE ONLY
VMSLOCVM MVC   0(*-*,R15),0(R1)    MOVE MESSAGE TEXT - EXECUTE ONLY
*
         DROP  ,
*
         EJECT
***********************************************************************
*                                                                     *
*        MESSAGE SUBROUTINE DATA AREAS                                *
*                                                                     *
***********************************************************************
*
VMSLOCUK DC    H'7',C'UNKNOWN'     BAD VARIABLE DATA SUBSTITUTE
*
VMSPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVMS PATCH'
         DC    16F'0'
*
VMSLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNVST - SYSTEM ERROR RECOVERY EXIT (ESTAE)'
***********************************************************************
*                                                                     *
*        IEFCNVST                                                     *
*        ********                                                     *
*                                                                     *
*        THIS ROUTINE SETS THE JOB ERROR FLAG FOR THE CONVERTER       *
*        AND PRINTS AN ERROR MESSAGE FOR THE USER.                    *
*                                                                     *
*        INPUT: R1 -> SYSTEM DIAGNOSTIC WORK AREA (SDWA).             *
*                                                                     *
*        OUTPUT:                                                      *
*              UPDATED SDWA FOR THE APPROPRIATE ERROR RECOVERY        *
*              ROUTINE.                                               *
*                                                                     *
*        EXIT:                                                        *
*              NORMAL:  RETURN TO R/TM2 VIA SETRP MACRO.              *
*              NO SDWA: RETURN TO R/TM2 WITH R15 = 0.                 *
*                                                                     *
*        IT IS HOPED THAT SDWAPARM CONTAINS A PTR TO THE              *
*        DYNAMIC PROCLIB WORK AREA.                                   *
*                                                                     *
***********************************************************************
*
IEFCNVST DS    0D
         USING *,R15               TEMPORARY BASE
         B     VSTSTM              BRANCH AROUND ID
*
         DC    AL1(VSTIDL)         LTH OF IDENTIFICATION PREFIX
VSTID    DC    CL8'IEFCNVST'       USER PROCLIB SUPPORT MODULE ID
VSTIDL   EQU   *-VSTID             LENGTH OF IDENTIFICATION HEADER
*
VSTSTM   DS    0H
         C     R0,=F'12'           CHECK FOR NO SDWA
         BE    VSTSTAEZ            GIVE UP IF NONE
         LTR   R1,R1               CHECK FOR NO SDWA
         BE    VSTSTAEZ            GIVE UP IF NONE
*
         STM   R14,R12,12(R13)     SAVE CALLERS REGS
         LR    R12,R15             COPY BASE REGISTER
         DROP  R15                 DROP TEMPORARY BASE
         USING IEFCNVST,R12        ESTABLISH PERMANENT BASE
*
         EJECT
***********************************************************************
*                                                                     *
*        PREPARE THE SDWA AND CHECK FOR UNRECOVERABLE ABENDS          *
*                                                                     *
***********************************************************************
*
         LR    R3,R1               SET PTR TO SDWA
         USING SDWA,R3             ESTABLISH SDWA ADDRESSABILITY
*
         L     R15,SDWAPARM        GET THE WORK AREA ADDRESS
         USING PPWDSECT,R15
*
         LA    R15,PPWVSTSA        ESTABLISH NEW SAVE AREA
         USING PPWVSTSA,R15        ESTABLISH SPECIAL ADDRESSABILITY
*
         ST    R13,4(,R15)         SAVE THE CURRENT SAVE AREA
         ST    R15,8(,R13)         CHAIN THIS TOO
*
         LR    R13,R15             ESTABLISH NEW SAVE AREA
         DROP  R15
         USING PPWVSTSA,R13        ESTABLISH NEW ADDRESSABILITY
*
         L     R15,PPWVSTCN        LOAD THE DEBUG FIELD
         LA    R15,1(,R15)         INCREMENT
         ST    R15,PPWVSTCN        STORE IT BACK
*
         CLI   PPWCFLG1,0          CHECK WHERE WE ARE - HERE OR CNV
         BNE   VSTSDUMP            IF IN CONVERTER, PERCOLATE
*
         TM    PPWVSTFL,PPWVSTEX   WERE WE HERE BEFORE
         BZ    *+8                 BRANCH IF NOT
         OI    PPWVSTFL,PPWVSTRC   INDICATE RECURSIVE ERROR
*
         OI    PPWVSTFL,PPWVSTEX   INDICATE ESTAE EXIT EXECUTING
*
         EJECT
***********************************************************************
*                                                                     *
*        FILL IN SDWA DATA FIELDS                                     *
*                                                                     *
***********************************************************************
*
         MVC   SDWAMODN,VSTSMODN   SET THE MODULE NAME
         MVC   SDWACSCT,VSTSCSCT   SET THE "CSECT NAME" BASE
         MVC   SDWAREXN,VSTID      SET THE RECOVERY ROUTINE NAME
*
         MVC   SDWANAME,SDWAMODN   SET THE MODULE NAME
         MVC   SDWAEPA,=A(IEFCNVPP)     SET THE ENTRY POINT
*
         MVI   SDWADPVA,SDWAHEX    DUMP USER DATA IN HEX
         MVI   SDWAURAL,PPWDBGLN   MOVE IN LENGTH OF USER DATA
         MVC   SDWAVRA(PPWDBGLN),PPWDBGST TRACE INFO FOR LOGREC
*
         ICM   R15,15,SDWAXPAD     LOAD POINTER POINTER
         BZ    VSTNEXTN            BRANCH IF NO POINTERS
*
         USING SDWAPTRS,R15
         ICM   R15,15,SDWASRVP     LOAD SERVICE DATA POINTER
         BZ    VSTNEXTN            BRANCH IF NONE
*
         USING SDWARC1,R15
         MVC   SDWACIDB,=C'DYNA'   COMPONENT PREFIX
         MVC   SDWACID,=C'PRCLB'   COMPONENT SUFFIX
         MVC   SDWASC,VSTSVCHD+1   COPY PART OF THE DUMP HEADER
         MVC   SDWARRL,VSTID       SET THE RECOVERY ROUTINE NAME
*
         L     R14,=A(IEFCNVPP)    LOAD MODULE ENTRY POINT
         USING IEFCNVPP,R14
*
         MVC   SDWAMDAT,VPPSDATE   SET THE MDOULE DATE
         MVC   SDWAMVRS,VPPVERSN   SET THE MODULE VERSION
*
         DROP  R14,R15
*
VSTNEXTN DS    0H
         OI    PPWFLAG1,PPW1JPER   ALSO FLAG ERROR FOR US
*
         TM    PPWVMSFL,PPWVMSEX   WERE WE IN THE MESSAGE ROUTINE
         BO    VSTNMSG             BRANCH IF SO - DON'T ISSUE MESSAGE
*
         LA    R0,MSGNO849         ABEND MESSAGE NUMBER
         L     R15,PPWCNVMS        LOAD MESSAGE ROUTINE
         BALR  R14,R15             ISSUE ERROR MESSAGE
*
VSTNMSG  DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        DETERMINE THE LOCATION OF THE ERROR                          *
*                                                                     *
***********************************************************************
*
         OI    SDWAACF2,SDWARCRD   INDICATE LOGREC RECORD REQ'D
*
         SR    R1,R1               CLEAR R1
         ICM   R1,3,SDWACMPC       R1 = ABEND CODE (XXX0)
         SRL   R1,4                DROP INSIGNIFICANT BITS
         CLM   R1,3,=Y(PPABEND)    IS THIS A SELF INFLICTED ABEND
         BE    VSTSDUMP            BRANCH IF YES
*
         TM    PPWVSTFL,PPWVSTRC   IS THIS A RECURSIVE ABEND ?
         BO    VSTSDUMP            BRANCH IF SO
*
***********************************************************************
*                                                                     *
*        IEFCNVXT                                                     *
*                                                                     *
***********************************************************************
*
         TM    PPWVXTFL,PPWVXTEX   FAILURE IN DATA EXTRACT/UPDATE
         BZ    VSTSNVXT            BRANCH IF NOT
         MVC   SDWACSCT+6(2),=C'XT'     INDICATE IEFCNVXT FAILED
*
         TM    PPWVXTFL,PPWVXTMS   TEST FOR BEING IN NON VXT
         BO    VSTSDUMP            NO RECOVERY IF SO
*
         L     R2,PPWVXTRT         GRACEFUL EXIT OF EXTRACT ROUTINE
         B     VSTSRTRY            RETURN TO R/TM
*
VSTSNVXT DS    0H
*
***********************************************************************
*                                                                     *
*        IEFCNVMS                                                     *
*                                                                     *
***********************************************************************
*
         TM    PPWVMSFL,PPWVMSEX   FAILURE IN MESSAGE ROUTINE
         BZ    VSTSNVMS            BRANCH IF NOT
         MVC   SDWACSCT+6(2),=C'MS'     INDICATE IEFCNVMS FAILED
*
         TM    PPWVMSFL,PPWVMSWT+PPWVMSIM TEST FOR BEING IN NON VMS
         BNZ   VSTSDUMP            NO RECOVERY IF EITHER
*
         L     R2,PPWVMSRT         GRACEFUL EXIT OF MESSAGE ROUTINE
         B     VSTSRTRY            RETURN TO R/TM
*
VSTSNVMS DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        IEFCNVDE                                                     *
*                                                                     *
***********************************************************************
*
         TM    PPWVDEFL,PPWVDEEX   FAILURE IN DYN ALLOC ERROR ROUTINE
         BZ    VSTSNVDE            BRANCH IF NOT
         MVC   SDWACSCT+6(2),=C'DE'     INDICATE IEFCNVDE FAILED
*
         TM    PPWVDEFL,PPWVDEDF   ARE WE IN DAIRFAIL
         BO    VSTSDUMP            NO RECOVERY IF SO
*
         L     R2,PPWVDERT         GRACEFUL EXIT OF DYN ALLOC ERR RTN
         B     VSTSRTRY            RETURN TO R/TM
*
VSTSNVDE DS    0H
*
***********************************************************************
*                                                                     *
*        IEFCNVKW                                                     *
*                                                                     *
***********************************************************************
*
         TM    PPWVKWFL,PPWVKWEX   FAILURE IN DYN ALLOC ERROR ROUTINE
         BZ    VSTSNVKW            BRANCH IF NOT
         MVC   SDWACSCT+6(2),=C'KW'     INDICATE IEFCNVKW FAILED
*
         L     R2,PPWVKWRT         GRACEFUL EXIT
         B     VSTSRTRY            RETURN TO R/TM
*
VSTSNVKW DS    0H
*
***********************************************************************
*                                                                     *
*        IEFCNVJP                                                     *
*                                                                     *
***********************************************************************
*
         TM    PPWVJPFL,PPWVJPEX   FAILURE IN JOBPROC PROCESSOR
         BZ    VSTSNVJP            BRANCH IF NOT
         MVC   SDWACSCT+6(2),=C'JP'     INDICATE IEFCNVJP FAILED
*
         L     R2,PPWVJPRT         GRACEFUL EXIT
*
         B     VSTSRTRY            RETURN TO R/TM
*
VSTSNVJP DS    0H
*
         EJECT
***********************************************************************
*                                                                     *
*        IEFCNVEX                                                     *
*                                                                     *
***********************************************************************
*
         TM    PPWVEXFL,PPWVEXEX   FAILURE IN 1ST EXEC PROCESSOR
         BZ    VSTSNVEX            BRANCH IF NOT
         MVC   SDWACSCT+6(2),=C'EX'     INDICATE IEFCNVEX FAILED
*
         L     R2,PPWVEXRT         LOAD THE RETRY ADDRESS
*
         TM    PPWVEXFL,PPWVEXOP   IS PROCLIB OPEN IN PROGRESS?
         BZ    VSTSRTRY            RETURN TO R/TM IF NOT
*
         NI    SDWAACF2,255-SDWARCRD    NO RECORDING FOR USER ERR
         B     VSTSRTRY            RETURN TO R/TM
*
VSTSNVEX DS    0H
*
***********************************************************************
*                                                                     *
*        IEFCNVCL                                                     *
*                                                                     *
***********************************************************************
*
         TM    PPWVCLFL,PPWVCLEX   FAILURE IN CLEANUP PROCESSING?
         BZ    VSTSNVCL            NO -> THINGS ARE IN BAD SHAPE
         MVC   SDWACSCT+6(2),=C'CL'     INDICATE IEFCNVCL FAILED
*
         L     R2,PPWVCLRT         LOAD THE RECOVERY ADDRESS
*
         TM    PPWVCLFL,PPWVCLCL   IS PROCLIB CLOSE IN PROGRESS?
         BZ    VSTSNCLC            BRANCH IF NOT
*
         NI    SDWAACF2,255-SDWARCRD    NO RECORDING FOR THIS ERROR
         B     VSTSRTRY            RETURN TO R/TM
*
VSTSNCLC DS    0H
         B     VSTSDUMP            DO NOT RECOVER FROM OTHER VCL ERROR
*
VSTSNVCL DS    0H
*
***********************************************************************
*                                                                     *
*        ALL OTHER CASES                                              *
*                                                                     *
***********************************************************************
*
         B     VSTSDUMP            DO NOT RECOVER FROM ANY OTHER ERRORS
*
         EJECT
***********************************************************************
*                                                                     *
*        TAKE AN SVC DUMP OF THE ERROR                                *
*                                                                     *
***********************************************************************
*
VSTSRTRY DS    0H
         OI    PPWVSTFL,PPWVSTRE   INDICATE WE WANT TO RECOVER
*
VSTSDUMP DS    0H
         OI    PPWVSTFL,PPWVSTDM   INDICATE A DUMP IS IN PROGRESS
         SDUMP MF=(E,VSTSVCDM)     INVOKE AN SVC DUMP
         NI    PPWVSTFL,255-PPWVSTDM    DUMP IS DONE
*
         NI    PPWVSTFL,255-PPWVSTEX    TURN OFF WE ARE HERE
*
         TM    PPWVSTFL,PPWVSTRE   ARE WE RETRYING
         BZ    VSTSNREC            IF NOT, DON'T RECOVER
*
***********************************************************************
*                                                                     *
*        RETURN TO RTM WITH RECOVERY                                  *
*                                                                     *
***********************************************************************
*
         NI    PPWVSTFL,255-PPWVSTRE    TURN OFF RETRY FOR RECURSION
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
*
         SETRP RC=4,RETADDR=(R2),FRESDWA=YES,WKAREA=(R3),              X
               REGS=(14,12)        RETURN TO R/TM
*
         EJECT
***********************************************************************
*                                                                     *
*        RETURN TO RTM WITH NO RECOVERY                               *
*                                                                     *
***********************************************************************
*
VSTSNREC DS    0H
         L     R13,4(,R13)         UNCHAIN THE SAVE AREA
         SETRP REGS=(14,12),RC=0,RECORD=YES, * CONTINUE ABEND *        X
               WKAREA=(R3)
*
***********************************************************************
*                                                                     *
*        RETURN TO RTM WITH NO RECOVERY (AND NO SDWA)                 *
*                                                                     *
***********************************************************************
*
VSTSTAEZ DS    0H                  NO SDWA ADDRESS PROVIDED
         SLR   R15,R15             INDICATE NO RETRY
         BR    R14                  AND RETURN
*
         EJECT
***********************************************************************
*                                                                     *
*        ESTAE EXIT DATA AREAS                                        *
*                                                                     *
***********************************************************************
*
VSTSMODN DC    CL8'IEFVH1'         LOAD MODULE NAME
VSTSCSCT DC    CL8'IEFCNVXX'       ERROR ROUTINE
*
VSTSVCDM SDUMP HDRAD=VSTSVCHD,     SVC DUMP PARAMETER LIST             X
               SDATA=(LSQA,PSA,RGN,TRT),                               X
               MF=L
*
VSTSVCHD DC    AL1(40),CL40'AMDAHL DYNAMIC PROCLIB ESTAE DUMP'
*
VSTPATCH DS    0D                  PATCH AREA
         DC    CL16'IEFCNVST PATCH'
         DC    16F'0'
*
VSTLITRL LTORG ,                   FLUSH LITERALS
*
         TITLE 'IEFCNMST - ALL USER AND OPERATOR MESSAGE TEXT'
IEFCNMSG DS    0D
         IEFCNMSG 800,                                                 X
               'SYNTAX ERROR IN ',                                     X
               ' DD STATEMENT',                                        X
               VARDATA=JOBPROC
*
         IEFCNMSG 801,                                                 X
               'ILLEGAL USE OF "',                                     X
               '" OPTION',                                             X
               VARDATA=SYSPROC
*
         IEFCNMSG 802,                                                 X
               ,' DATA SET NAME NOT SPECIFIED',                        X
               VARDATA=JOBPROC
*
         IEFCNMSG 803,                                                 X
               'DATA SET ',                                            X
               ' NOT ELIGIBLE FOR DYNAMIC PROCLIB USAGE',              X
               VARDATA=DSNAME
*
         IEFCNMSG 804,                                                 X
               ,' CONCATENATION LIMIT EXCEEDED',                       X
               VARDATA=JOBPROC
*
         IEFCNMSG 805,                                                 X
               ,' DATA SET NOT FOUND IN CATALOG',                      X
               VARDATA=JOBPROC
*
         IEFCNMSG 806,                                                 X
               'VOLUME CONTAINING ',                                   X
               ' DATA SET NOT MOUNTED',                                X
               VARDATA=JOBPROC
*
         IEFCNMSG 807,                                                 X
               ,' DATA SET NOT ON VOLUME',                             X
               VARDATA=JOBPROC
*
         IEFCNMSG 808,                                                 X
               ,' ALLOCATION FAILED',                                  X
               VARDATA=JOBPROC
*
         IEFCNMSG 809,                                                 X
               ,' CONCATENATION FAILED',                               X
               VARDATA=JOBPROC
*
         IEFCNMSG 811,                                                 X
               'VOLUME OR DEVICE TYPE NOT ALLOWED FOR ',               X
               ' USAGE',                                               X
               VARDATA=JOBPROC
*
         IEFCNMSG 812,                                                 X
               ,' OPEN FAILED',                                        X
               VARDATA=JOBPROC
*
         IEFCNMSG 813,                                                 X
               ,' DATA SET NOT AVAILABLE UNDER REQUESTED DISPOSITION', X
               VARDATA=JOBPROC
*
         IEFCNMSG 814,                                                 X
               ,' DATA SET HAS INCORRECT UNIT SPECIFICATION',          X
               VARDATA=JOBPROC
*
         IEFCNMSG 815,                                                 X
               'CATALOG VOLUME REQUIRED FOR ',                         X
               ' PROCESSING IS NOT MOUNTED',                           X
               VARDATA=JOBPROC
*
         IEFCNMSG 816,                                                 X
               ,' DE-CONCATENATION FAILED',                            X
               VARDATA=JOBPROC
*
         IEFCNMSG 817,                                                 X
               ,' DE-ALLOCATION FAILED',                               X
               VARDATA=JOBPROC
*
         IEFCNMSG 821,                                                 X
               'DATA SET ',                                            X
               ' ALLOCATED FOR USER PROCLIB PROCESSING',               X
               VARDATA=DSNAME,ERR=NO
*
         IEFCNMSG 822,                                                 X
               'DATA SET ',                                            X
               ' ALLOCATED FOR USER PROCLIB CONCATENATION',            X
               VARDATA=DSNAME,ERR=NO
*
         IEFCNMSG 823,                                                 X
               'SYSTEM PROCEDURE LIBRARIES WILL BE SEARCHED ',         X
               ' USER PROCLIB(S)',                                     X
               VARDATA=YES,ERR=NO
*
         IEFCNMSG 824,                                                 X
               'SYSTEM PROCEDURE LIBRARIES WILL NOT BE SEARCHED',      X
               ERR=NO
*
         IEFCNMSG 831,                                                 X
               'UNIDENTIFIED VALUE SPECIFIED IN THE ',                 X
               ' PARAMETER',                                           X
               VARDATA=SWA
*
         IEFCNMSG 832,                                                 X
               'SCHEDULER WORK AREA REQUESTED TO BE ',                 X
               ' THE 16 MEG LINE',                                     X
               VARDATA=YES,ERR=NO
*
         IEFCNMSG 836,                                                 X
               'MISPLACED ',                                           X
               ' STATEMENT',                                           X
               VARDATA=JOBPROC
*
         IEFCNMSG 837,                                                 X
               ,' NOT ALLOWED WHEN JCLLIB STATEMENT SPECIFIED',        X
               VARDATA=JOBPROC
*
         IEFCNMSG 838,                                                 X
               'JCLLIB NOT ALLOWED WHEN ',                             X
               ' DD STATEMENT SPECIFIED',                              X
               VARDATA=JOBPROC
*
         IEFCNMSG 842,                                                 X
               'EXCESSIVE PARAMETER LENGTH IN THE DSNAME FIELD'
*
         IEFCNMSG 843,                                                 X
               'UNIDENTIFIED PARAMETER IN THE ',                       X
               ' FIELD',                                               X
               VARDATA=SYSPROC
*
         IEFCNMSG 844,                                                 X
               'INVALID SYNTAX IN THE DSNAME FIELD ON THE ',           X
               ' STATEMENT',                                           X
               VARDATA=JOBPROC
*
         IEFCNMSG 848,                                                 X
               'DYNAMIC PROCLIB LIMITING MODULE ',                     X
               ' NOT FOUND',                                           X
               VARDATA=YES,ERR=NO,WTO=YES
*
         IEFCNMSG 849,                                                 X
               'DYNAMIC PROCLIB PROCESSING ABENDED'
*
         IEFCNMSG 850,                                                 X
               ,' LIBRARIES UNAVAILABLE',                              X
               ERR=NO,WTO=YES,                                         X
               VARDATA=SYSPROC
*
         IEFCNMSG 851,                                                 X
               'TRACE POINT ',                                         X
               ' ENCOUNTERED',                                         X
               VARDATA=INLINE,ERR=NO,WTO=YES,TRACE=YES
*
         IEFCNMSG 853,                                                 X
               'GST RC  ',                                             X
               VARDATA=YES,ERR=NO,WTO=YES,TRACE=YES
*
         IEFCNMSG 854,                                                 X
               'GST STM ',                                             X
               VARDATA=YES,ERR=NO,WTO=YES,TRACE=YES
*
         IEFCNMSG 855,                                                 X
               'GST TXT ',                                             X
               VARDATA=YES,ERR=NO,WTO=YES,TRACE=YES
*
         IEFCNMSG 856,                                                 X
               'MOD TXT ',                                             X
               VARDATA=YES,ERR=NO,WTO=YES,TRACE=YES
*
         IEFCNMSG 857,                                                 X
               'EXT TXT ',                                             X
               VARDATA=YES,ERR=NO,WTO=YES,TRACE=YES
*
         IEFCNMSG 858,                                                 X
               'OFFSETS ',                                             X
               VARDATA=YES,ERR=NO,WTO=YES,TRACE=YES
*
         IEFCNMSG 000,                                                 X
               'UNKNOWN MESSAGE NUMBER'
*
         END   IEFCNVPP,(IEFCNVPP,0411,91308)
