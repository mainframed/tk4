XT5      TITLE 'PRC COMMAND EXIT ROUTINE (EXIT 5)'
*
*        SP JES2 COMMAND EXIT - EXIT5
*
*        THIS ROUTINE PROVIDES A SAMPLE EXIT5 WITH SEVERAL FUNCTIONS
*        ADDED:
*          1. COMMAND LOOKUP ROUTINE
*          2. HASPCOMM MACROS AND SERVICES AVAILABLE
*          3. $ESTAE ENVIRONMENT ESTABLISHED AROUND COMMAND PROCESSING
*          4.  SEVERAL COMMANDS WHICH MAY OR MAY NOT BE OF INTEREST
*              A. $DMJ EXTENSION ALLOWS MESSAGE TO BE SENT TO JOB
*                 NOT IN EXECUTION.
*              B. ATTACH, DETACH SUBTASK COMMANDS. I ALSO HAVE
*                 DISPATCHER MODS TO ALLOW JES2 PCE TO COMMUNICATE
*                 WITH SUBTASK SO ATTACHED IF ANYONE IS INTERESTED.
*              C. DUMP JQE COMMAND
*
*        L=CCA VERIFICATION AND AUTOMATIC REDIRECTION IS NOT
*        DONE HERE BUT PROBABLY SHOULD BE. IF ANYONE DOES THESE
*        PLEASE SEND ME A COPY.
*
*        I THINK THE MOST SIGNIFICANT PART OF THIS EXIT IS THE
*        INCLUSION OF HASPCOMM MACRO FACILITIES IN IT. USER
*        COMMAND EXTENSIONS CAN BE CODED HERE IN THE SAME
*        MANNER AS IF THE CODE WERE IN HASPCOMM. SMALL
*        ADDITIONS TO SOME COMMANDS CAN BE DONE AS I DID THE
*        $DMJ ADDITION. I INTEND TO 'COPY' SOME STANDARD
*        COMMANDS INTO THIS CSECT FOR MODIFICATION RATHER
*        THAN MAKING HASPCOMM UPDATES.
*
*        I WILL OF COURSE OVER TIME ADD MANY LOCAL COMMANDS
*        HERE. I SUGGEST THAT THIS MIGHT BE A GOOD PLACE
*        FOR OTHERS TO PUT THEIR COMMANDS FOR DISTRIBUTION.
*
*
*        YOU MAY NEED TO RE-GENERATE X51010A  AFTER APPLYING
*        MAINTENANCE IF THERE ARE ANY HITS IN THIS AREA.
*
         MACRO
&NAME    MTAB  &D,&F
         DC    C'&NAME',X'FFFFFFFFFFFF000000000000'
         ORG   *-12+&D
         DC    AL1(255-QUEH&F)
         ORG   *+5
         DC    AL1(QUEH&F)
         ORG
         MEND
         TITLE 'PRC COMMAND EXIT ROUTINE (EXIT 5)'
*
*        MEMBER X51010A  IS GENERATED BY COPYING FROM HASPCOMM
*        SEQUENCE NUMBERS 00645000 TO 0870000
*
*
         COPY  X51010A            HASPCOMM MACRO DEFINITIONS
         TITLE 'HASPCOMM COMMAND EXIT (EXIT5) ROUTINE'
         USING PCEDSECT,R13
         USING HCTDSECT,R11
         USING JQEDSECT,R1
COWTO    EQU   12                 EQUATES
CORTNORM EQU   0                   NEEDED BY
CORTOK   EQU   4                    HASPCOMM
CORTMSG  EQU   8                     MACROS
*
*        SYMBOLS TO DEFINE COMMAND TABLE ELEMENT FIELDS
*
COMTEL   EQU   16                  LENGTH OF EACH COMTAB ELEMENT
COMTVBLN EQU   7                  VERB LENGTH
COMTOFF  EQU   5                  OFFSET WITHIN GROUP
COMTGRP  EQU   1                  ADR OF GROUP PROCESSOR
COMTFL   EQU   0                   LOCATION OF FLAGS WITHIN ELEMENT
COMTVB   EQU   8                   LOCATION OF VERB WITHIN GROUP
COMR     EQU   CMBFLAGR            LEVEL OF RESTRICTION FOR REMOTES  R4
COMS     EQU   DCTREJSY            REJECT UNLESS SYSTEM AUTHORIZATION
COMD     EQU   DCTREJDV            REJECT UNLESS DEVICE AUTHORIZATION
COMJ     EQU   DCTREJJB            REJECT UNLESS JOB AUTHORIZATION
COMJDS   EQU   COMJ+COMD+COMS      COMBINATION
COMJDSR  EQU   COMJDS+COMR        BIGGER COMBINATION
         SPACE 1
***********************************************************************
*                                                                     *
*        REDIRECTION VALUES FOR DISPLAY COMMANDS                      *
*                                                                     *
***********************************************************************
$D7D     EQU   4
$DA      EQU   1
$DF      EQU   2
$DI      EQU   3
$DJ      EQU   4
$DN      EQU   5
$DO      EQU   6
$DQ      EQU   7
$DS      EQU   4
$DT      EQU   4
$DU      EQU   8
         SPACE 2
CCMDLN   EQU   15
         TITLE 'USER EXIT COMMAND SCAN ROUTINE'
EXIT05   $ENTRY CSECT=YES,BASE=R12  DEFINE EXIT EP
COMXENT  $SAVE TRACE=YES          SAVE CALLERS REGISTERS
         LR    R12,R15            EST. BASE REG
         SPACE 2
***********************************************************************
*                                                                     *
*        SEARCH USER DEFINED COMMAND TABLE AT LOCATION "COMTAB"       *
*        TO DETERMINE IF THE COMMAND AT LOCATION "COMVERB" IN         *
*        THE PCE WORKAREA IS A USER DEFINED COMMAND. RETURN           *
*        TO HASPCOMM IF COMMAND NOT IN OUR TABLE. IF COMMAND MATCH    *
*        DO AUTHORIZATION CHECK, THEN BRANCH TO COMMAND               *
*        PROCESSING ROUTINE. PROCESSING ROUTINE HAS USE OF MOST       *
*        HASPCOMM MACROS, AND SHOULD RETURN VIA $CRET MACRO.          *
*                                                                     *
***********************************************************************
         SPACE 2
         LA    R4,COMTAB-COMTEL   POINT TO TABLE
         LA    R3,NBRCMDS         NBR COMMANDS IN TABLE
SEARCH   LA    R1,1(R3)           REMAINING COUNT + 1
         SRA   R3,1               DIVIDE BY 2
         SRA   R1,1               DIVIDE BY 2
         BZ    NOTFND             BIF NO MORE TO SCAN
CHKNEXT  MH    R1,=AL2(COMTEL)    MULT BY TABLE SIZE
         AR    R1,R4              GENERATE CURRENT ADR
         CLC   COMVERB(2),COMTVB(R1) CHECK VERB MATCH
**** NOTE THAT THIS BINARY SEARCH TECHNIQUE ALLOWS FOR ONLY
****  TWO CHARACTER COMMAND NAMES. ALL PRC COMMANDS ARE AT
****  LEAST 2 CHARS IN LENGTH SO THIS IS NO PROBLEM.
         BL    SEARCH             SEARCH NXT ENTRY IF LOW
         LR    R4,R1              ESTABLISH NEW BOUNDARY
         BH    SEARCH             BIF HIGH TO NXT HALF
         B     FOUND              RETURN IF FOUND
         SPACE 2
FOUND    DS    0H                 PRC COMMAND FOUND
         IC    R1,COMTFL(R4)      PICKUP AUTHORIZATION BITS
         N     R1,=F'15'          PURIFY
         EX    R1,COMTMI          TEST AUTHORIZED CONSOLE
         BNZ   COMMBAD            BIF NOT AUTHORIZED
         SPACE 1
***
***      X51010C  IS COPIED FROM HASPCOMM
***      SEQUENCE NUMBERS 21980000 - 22770000
***       WITH LINES 22665000 AND 22670000 DELETED
***
         COPY  X51010C
         SPACE 1
COMMBAD  DS    0H                 COMMAND INVALID
         $CFINVC ,
         SPACE 2
NOTFND   DS    0H                 NOT A PRC COMMAND, RETURN
         SR    R15,R15            ZERO RETURN CODE
*                                  TELLS JES2 TO CONTINUE
*                                   NORMAL PROCESSING OF COMMAND
RETURN   DS    0H                 RETURN FROM EXIT
COMXRET  $RETURN RC=(R15),TRACE=YES  RETURN TO HASPCOMM
         SPACE 1
*        $ESTAE RETURN ADDR AFTER RECOVERY
RECONT   LA    R15,8              SET NULL RETURN
         B     RETURN              AND RETURN
         TITLE 'USER COMMAND TABLE'
***********************************************************************
*                                                                     *
*                   USER COMMAND TABLE                                *
*                                                                     *
***********************************************************************
         SPACE 2
COMTAB   DS    0F                 MUST BE IN ALPHABETICAL ORDER
         $COMTAB DM,CMDDM,REJECT=COMJ  DEFINE DISP MSG COMMAND
         $COMTAB JQ,CMDJQ,REJECT=COMJDSR,REDIR=$DJ  JQE DUMP COMMAND
         $COMTAB OP,CMDOP,REDIR=$DQ   OUTPUT LIST COMMAND
         $COMTAB QQ,CMDQQ,REJECT=COMJDSR ABEND TEST COMMAND
NBRCMDS  EQU   (*-COMTAB)/COMTEL  NUMBER OF COMMANDS
         TITLE 'PRC COMMAND EXIT RECOVERY ROUTINE'
*        REGISTERS ON ENTRY:
*        R0    SAME AS AT ABEND
*        R1    --> ERA
*        R2-R10  SAME AS ABEND
*        R11   --> HCT
*        R13   --> PCE
*        R14   RETURN ADR
*        R15   ENTRY ADR
         SPACE 1
COMMRCVR $SAVE TRACE=YES          SAVE REGISTERS
         LR    R8,R15             ESTABLISH
         USING COMMRCVR,R8          RECOVERY BASE REG
         LR    R5,R1              ESTABLISH ERA
         USING ERADSECT,R5         ADDRESSABILITY
         SPACE 1
         CLC   =F'12',ERAESRG0    DO WE HAVE SDWA
         BE    RECPERC            BIF NOT
         L     R3,ERASDWA         --> SDWA
         USING SDWA,R3             AND DECLARE IT
         L     R4,ERAPRE          --> PRE
         USING PREDSECT,R4         AND DECLARE IT
         SPACE 1
         TM    SDWAERRA,SDWAPCHK  PROGRAM CHECK?
         BZ    RECPERC             BIF NOT
         DROP  R3
         SPACE 1
*        TERMINATE MULTIPLE LINE WTO IN PROGRESS
         SPACE 1
         TM    COMFLAG,CMBFLAGU   HAVE UCMID?
         BZ    RECBMSG            BIF NOT
         SPACE 1
         CLI   COMUCMA,0          IS THIS MLWTO?
         BZ    RECBMSG             BIF NOT
         OI    COMLINET,X'10'       ELSE SET END LINE
         SLR   R0,R0              SET NULL LENGTH
         BCTR  R0,0                TO TRUNC MLWTO
         SPACE 1
        $CWTO  L=(R0)             END ANY MLWTO
         MVI   COMUCMA,X'00'      CLEAR UCM AREA
         SPACE 1
*        TELL OPERATOR COMMAND BEING DISCARDED
         SPACE 1
RECBMSG  MVC   COMMAND(L'RECMSGT),RECMSGT  SETUP BASIC MSG TXT
         TM    COMINCON,X'80'     CHECK SSI FORMATTED COMMAND
         BZ    RECSCMD             BIF NOT SSI
         MVC   COMMAND+L'RECMSGT(RECCML),RECNETC
         B     RECDELMS           TELL OPERATOR CMD TERMINATED
         SPACE 1
RECSCMD  MVC   COMMAND+L'RECMSGT(RECCML),PRETRACK
         DROP  R4
         SPACE 1
*        TELL OPERATOR COMMAND WAS DELETED
         SPACE 1
RECDELMS $CWTO L=RECMDLN,MSGID=691  TELL ORIGINATING OPERATOR
         SPACE 1
*        NOW TELL MASTER CONSOLE OPERATOR
         $WTO   COMMID,RECMDLN+L'COMMID,JOB=NO,                        C
               ROUTE=$MAIN+$ERR,CLASS=$ALWAYS,PRI=$HI
         SPACE 1
*        SETUP TO RETURN OR PERCOLATE ERROR
         SPACE 1
         $SETRP RESUME=RECONT     SETUP RETURN ADR
         SPACE 1
         B     RECRET             RETURN FROM RECOVERY RTN
         SPACE 1
RECPERC  $SETRP PERCOLATE        SET PERCOLATE OPTION
         SPACE 1
RECRET   $RETURN                  RETURN TO CALLER
         SPACE 1
         DROP  R5
RECMSGT  DC    C'LOCAL COMMAND TERMINATED-'
RECCML   EQU   15                 LNGTH OF CMD TO PRINT
RECNETC  DC    C'NETWORK COMMAND' TXT FOR FORMATED CMDS
RECMDLN  EQU   L'RECMSGT+RECCML   TOTAL MSG LENGTH
         DROP  R8
         SPACE 2
         LTORG
         TITLE 'PRC COMMAND EXIT SERVICE ROUTINES'
*        COPIES OF THE STARDARD SERVICE ROUTINES ARE GENERATED
*        HERE TO ALLOW THEIR USE FROM WITHIN OUR EXIT.
COFCVB   $CFCVB TYPE=RES,INFO=YES,NUM=1
COFCVB2  $CFCVB TYPE=RES,INFO=YES,NUM=2
         EJECT
COFDCTL  $CFDCTL TYPE=RES,INFO=YES
         EJECT
COFINVC  $CFINVC TYPE=RES,INFO=YES
         EJECT
COFINVO  $CFINVO TYPE=RES,INFO=YES
         EJECT
         USING JQEDSECT,R1
COFVQE   $CFVQE TYPE=RES,INFO=YES
*
         SPACE 1
*        X51010B  IS GENERATED BY COPYING FROM HASPCOMM
*        SEQUENCE NUMBERS 12785000 TO 15090000
*
*
         COPY  X51010B            HASPCOMM ROUTINES
*
*        ROUTINES TO ALLOW SIMULATION OF COMMON ROUTINES
*
*        SIMULATE $CRET MACRO ENTRY POINT VIA EXIT RETURN
*
*        $CRET NORMALLY SETS R15 VALUES TO INDICATE DESIRED
*        ACTION. RETURN FROM EXIT 5 HAS DIFFERENT VALUES:
*          NORMAL  EXIT        MEANING
*            0       8         NULL RETURN
*            4      12         RETURN WITH 'OK'
*            8      16         RETURN WITH MSG, LENGTH IN R0
*
         SPACE 1
CORET    DS    0H                 ALLOW $CRET MACRO TO WORK
         LA    R15,8(R15)         CONVERT RETURN CODE TO
*                                  EXIT TYPE VALUE
         $STORE R0                SAVE LENGTH PARM FOR RETURN
         B     RETURN             RETURN TO CALLER
         SPACE 2
CVALIDTB DC    256X'01'            VALID JOB AND SYSOUT CLASSES
         ORG   CVALIDTB+C'A'
         DC      9X'00'            A-I
         ORG   CVALIDTB+C'J'
         DC      9X'00'            J-R
         ORG   CVALIDTB+C'S'
         DC      8X'00'            S-Z
         ORG   CVALIDTB+C'0'
         DC     10X'00'            0-9
         DC      6X'01'
         ORG   ,
         SPACE 5
CVALTABL EQU   *
         DC    75X'01'             X'00'-X'4A'  INVALID
         DC      X'00'             X'4B'        VALID (.)
         DC    15X'01'             X'4C'-X'5A'  INVALID
         DC      X'00'             X'5B'        VALID ($)
         DC    31X'01'             X'5C'-X'7A'  INVALID
         DC    2X'00'              X'7B',X'7C' VALID (#,@)
         DC    68X'01'             X'7D'-X'C0' INVALID
         DC     9X'00'             X'C1'-X'C9'  VALID (A-I)
         DC     7X'01'             X'CA'-X'D0'  INVALID
         DC     9X'00'             X'D1'-X'D9'  VALID (J-R)
         DC     8X'01'             X'DA'-X'E1'  INVALID
         DC     8X'00'             X'E2'-X'E9'  VALID (S-Z)
         DC     6X'01'             X'EA'-X'EF'  INVALID
         DC    10X'00'             X'F0'-X'F9'  VALID (0-9)
         DC     6X'01'             X'FA'-X'FF'  INVALID
         SPACE 1
         TITLE 'COMMAND RE-PARSE ROUTINE'
*
*        THIS ROUTINE IS USED TO RE-PARSE A COMMAND
*        BEFORE RETURNING TO HASPCOMM FOR PROCESSING.
*        FOR EXAMPLE - PRC REQUIRES BOTH JOBNUMBER AND
*        JOBNAME TO BE SUPPLIED ON THE CANCEL JOB COMMAND.
*        WE VERIFY JOBNAME/JOBNUMBER MATCH IN THE EXIT,
*        REMOVE JOBNAME, THEN REPARSE THE COMMAND HERE
*        AND RETURN TO HASPCOMM.  HASPCOMM ACTUALLY
*        PERFORMS THE CANCEL FUNCTION.
*
*        NOTE THAT THIS IS NOT A FULL REPARSE. IT IGNORES
*        QUOTES FOR EXAMPLE. IT DOES FUNCTION FOR THE SPECIFIC
*        PRC REQUIREMENTS AT THE MOMENT.
         SPACE 1
REPARSE  DS    0H                 SET OPERAND POINTERS
         LA    R5,COMOPRND        --> FIRST
         ST    R5,COMPNTER         OPERAND, SET POINTER
         LA    R7,COMMAND+99      --> END OF MSG
RENDLOP  CLI   0(R7),C' '         STILL BLANK?
         BNE   RENDGOT            BIF NOT
         BCT   R7,RENDLOP         CHECK PREVIOUS CHARACTER
RENDGOT  LA    R6,1               BXLE INCREMENT
         LA    R1,COMPNTER+4      NXT OPERAND POINTER
RECMALOP CLI   0(R5),C','         COMMA?
         BNE   RECSTEP            BIF NOT
         LA    R5,1(R5)           --> 1ST CHAR OF OPERAND
         ST    R5,0(R1)           SAVE OPRAND POINTER
         LA    R1,4(R1)           STEP TO NXT POINTER
RECSTEP  BXLE  R5,R6,RECMALOP     STEP TO NXT CHARACTER
         LA    R5,1(R5)           --> 1 CHAR PAST END
         ST    R5,0(R1)           SAVE END POINTER
         LA    R7,0(R1)           END OPERAND POINTER
         LA    R6,4               INCREMENT
         SR    R7,R6              --> BEGINNING LAST OPERAND
         LA    R5,COMPNTER        FIRST OPERAND POINTER
         SPACE 1
*        NOW SAVE REGISTERS FOR HASPCOMM
*        WE CAN'T USE A $STORE MACRO, BECAUSE WE MUST
*        GO BACK TWO SAVEAREAS AWAY.
         SPACE 1
         L     R1,PCELPSV         --> CURRENT SAVEAREA
         L     R1,PSVPREV-PSVID(R1)  --> PREVIOUS SAVEAREA
         STM   R5,R7,PSVR5-PSVID(R1) UPDATE HASPCOMM REGS
         B     NOTFND              THEN RETURN TO HASPCOMM
         TITLE 'BAD COMMAND'
*
*        STANDARD COMMANDS NOT ALLOWED AT PRC
*
*        TO DISALLOW A STANDARD COMMAND, ENTER A $COMTAB ENTRY
*        FOR IT WITH A ROUTINE ADDRESS OF 'CMDBAD'.
*
*        COMMANDS ARE:
*
CMDBAD   DS    0H                 DEFINE ENTRY
         USING *,R8               DECLARE ADDRESSABILITY
         $CRET MSG='COMMAND NOT ALLOWED AT PRC'
         LTORG
         TITLE 'HASP COMMAND PROCESSOR PARSE RULES'
***********************************************************************
*                                                                     *
*        COMMAND SUB-PROCESSOR CONVENTIONS                            *
*                                                                     *
* CONTENTS OF REGISTERS UPON ENTRY TO EACH COMMAND SUB-PROCESSOR      *
*                                                                     *
*    R0        = UNPREDICTABLE                                        *
*    R1        = SUB-PROCESSOR ENTRY POINT                            *
*    R2        = UNPREDICTABLE                                        *
*    R3        = UNPREDICTABLE                                        *
*    R4        = UNPREDICTABLE                                        *
*    R5        = FIRST OPERAND POINTER                                *
*    R6        = COUNT OF 4                                           *
*    R7        = LAST OPERAND POINTER ( SET FOR BXLE WD,WE,... )      *
*    R8        = BASE FOR COMMAND SUB-PROCESSOR                       *
*    R11       = HCTDSECT                                             *
*    R12       = BEGINNING OF MAIN COMMAND PROCESSOR                  *
*    R13       = PCE OF COMMAND PROCESSOR                             *
*    R14       = UNPREDICTABLE                                        *
*    R15       = UNPREDICTABLE                                        *
*                                                                     *
* EXAMPLE EDIT OF COMMAND TEXT BEFORE ENTRY TO SUB-COMMAND PROCESSOR  *
*                                                                     *
* ORIGIONAL IN $WTO BUFFER  ( S OVER CHARACTER = LOWER CASE )         *
*                                                                     *
*         S  S S S    S S S    S    S    S                            *
*        $V  A B C, ' A B,C '' D ', D '' E                            *
*                                                                     *
* FORM PASSED TO COMMAND SUB-PROCESSOR                                *
*                                                                     *
*                                                                     *
*        $VABC,' A B,C ' D ',D'E                                      *
*          1   2             3   4                                    *
*                                                                     *
*        $ IS LOCATED AT COMMAND                                      *
*                                                                     *
*        V IS SINGLE CHARACTER FORM OF VERB                           *
*                                                                     *
*        WD POINTS TO FIRST OF OPERAND POINTER TABLE WHICH, IN THIS   *
*        EXAMPLE, CONTAINS FOUR WORDS OF ADDRESSES WHICH IN TURN      *
*        LOCATES THE BEGINNING OF EACH OPERAND ( INCLUDING A NULL     *
*        END OPERAND ). THESE LOCATIONS ARE DENOTED BY REFERANCE      *
*        POINTS 1, 2, 3, AND 4 RESPECTIVELY. USING BXLE WD,WE,...     *
*        INSTRUCTION WILL FALL THROUGH WITH WD POINTING TO COMNULOP   *
*                                                                     *
***********************************************************************
         TITLE '$QQ COMMAND FOR TESTING $ESTAE'
CMDQQ    $COMGRUP QQ,DELAY=YES    DEFINE ENTRY POINT
*
*        $QQ COMMAND ABENDS TO TEST $ESTAE
*
         SPACE 1
CQQ      DS    0H                 DEFINE ENTRY
         $CWTO MSG='$QQ COMMAND ISSUED, IT CAUSES 0C1',MSGID=000
         SPACE 1
         DC    H'0'               CAUSE 0C1
         SPACE 1
         LTORG
         TITLE '$JQE HEX LIST COMMAND'
CMDJQ    $COMGRUP JQ,DELAY=YES    DEFINE ENTRY POINT
****************************************************************
*
*        $JQE  JOB NUMBER
*
*        LIST SPECIFIED JOB'S JQE IN HEX ON THE CONSOLE
*
****************************************************************
         SPACE 2
CJQ      DS    0H
         $CFCVB POINTER=(R5),NOK=BADJN        JOB NBR TO BINARY
         LR    R2,R1              SAVE JOB NUMBER
         SPACE 2
         $QLOC (R1)               FIND JQE FOR JOB
         BNZ   JQJFND             BIF JOB FOUND
BADJN    $CRET MSG='JOB NOT FOUND'  RETURN
         SPACE 1
****************************************************************
*
*        JQE FOUND (ADDRESSED IN R1), FORMAT AND DUMP IT
*
****************************************************************
         SPACE 2
JQJFND   DS    0H                 JQE FOUND
         LR    R5,R1              SAVE JQE ADR
         LA    R6,5               5 LINES OUTPUT
JQNXLINE LA    R3,4               CONVERT 4 WORDS/LINE
         LA    R2,COMMAND         POINT TO REPLY AREA
         SPACE 2
UNPKLOP  UNPK  0(9,R2),0(5,R5)  UNPACK 1 WORD
         L     R4,=A(HEXTAB)      ADR XLATE TABLE
         TR    0(8,R2),0(R4)      TRANSLATE IT
         MVI   8(R2),C' '         BLANK BETWEEN WORDS
         LA    R2,9(R2)           POINT TO NEW RECEIVING AREA
         LA    R5,4(R5)           NEW SENDING AREA
         BCT   R3,UNPKLOP         UNPACK NEXT WORD
         SPACE 1
         $CWTO L=35               SEND 1 LINE
         BCT   R6,JQNXLINE         THEN PROCESS NEXT LINE
         $CRET ,                  AND RETURN AFTER LAST LINE
         SPACE 1
HEXTAB   EQU   *-C'0'             DONT WASTE SPACE
         DC    C'0123456789ABCDEF'   HEX TRANSLATE TABLE
         LTORG
         TITLE '$DM (DISPLAY MESSAGE) COMMAND'
CMDDM    $COMGRUP DM,DELAY=YES    DISPLAY MSG ENTRY POINT
         SPACE 2
***********************************************************************
*                                                                     *
*        $ D M JOBID,TEXT -- DISPLAY MSG ON EXECUTING JOB'S LOG       *
*             (PRC EXTENSION REMOVES REQUIREMENT THAT JOB BE          *
*             BUSY IN EXECUTION - IT STILL MUST HAVE GONE THROUGH     *
*             CONVERSION HOWEVER.                                     *
*                                                                     *
*        $ D M 'JOBNAME',TEXT -- DISPLAY MSG ON EXECUTING JOB'S LOG   *
*                                                                     *
*        IF JOB IS IN EXECUTION, THIS EXIT RETURNS DIRECTLY TO        *
*        HASPCOMM TO PROCESS THE COMMAND. IN ADDITION MOST ERROR      *
*        CONDITIONS ARE RETURNED TO HASPCOMM FOR PROCESSING.          *
*        HASPCOMM SHOULD DISCOVER THE SAME ERROR AND ISSUE            *
*        THE APPROPRIATE ERROR MESSAGE.                               *
*                                                                     *
***********************************************************************
         USING JQEDSECT,R1                                           R4
CDM      DS    0H                                                    R4
*
*        THE FOLLOWING CODE BASICALLY COPIED FROM JES2 VER 4.1
*
         MVC   COMJNAME,=CL8' '    BLANK OUT JOB NAME SLOT          R41
         SLR   R2,R2               SET OFFSET FOR JOB NO            R41
         CLI   COMOPRND+1,C'J'     CHECK FOR JOB                    R41
         BE    CDMJOBID            BRANCH IF YES TO EXTRACT JOBID   R41
         LA    R2,QUESTC          CHECK STC
         CLI   COMOPRND+1,C'S'     CHECK FOR STC                    R41
         BE    CDMJOBID            BRANCH IF YES TO EXTRACT JOBID   R41
         LA    R2,QUETSU          CHECK TSU
         CLI   COMOPRND+1,C'T'     CHECK FOR TSU                    R41
         BE    CDMJOBID            BRANCH IF YES TO EXTRACT JOBID   R41
         CLI   COMOPRND+1,C''''    SEE IF JOBNAME (STARTS W/ QUOTE) R41
         BNE   NOTFND             RETURN TO HASPCOMM IF NOT
         SPACE 1
         LA    R1,COMOPRND+2       POINT TO 1ST CHAR OF JOBNAME     R41
         L     R4,4(,R5)           POINT TO END OF NAME + 2         R41
         SLR   R4,R1               COMPUTE MACHINE                  R41
         SH    R4,=H'3'              TEXT LENGTH                    R41
         BM    CDMERR              ERROR IF NOT VALID               R41
         LA    R0,7                ENSURE                           R41
         CLR   R4,R0                 LENGTH                         R41
         BNH   CDMJEX                NOT                            R41
         LR    R4,R0                 OVER 7                         R41
CDMJEX   EX    R4,CDMJNMV          MOVE IN JOB NAME                 R41
         SLR   R4,R4               SHOW JQE NOT FOUND YET           R41
CDMJSCAN DS    0H                  BRANCH HERE TO RE-SCAN           R41
        $CFJSCAN PROCESS=CDMJC0,   SCAN JOB QUEUE,                  R41C
               EMPTY=CDMJNJF,        LOOKING FOR                    R41C
               NEXT=CDMJNEXT,        MATCHING                       R41C
               IGNORE=CDMJNG         JOBNAME                        R41
         LTR   R2,R4               AT END OF SCAN, CHECK FOR ONLY 1 R41
         BNM   CDMJXEQ               JOB FOUND, BRANCH IF SO        R41
         SPACE 1
*        ERROR CONDITION - MULTIPLE OR NO JOBS FOUND
*        RETURN TO HASPCOMM AS IF WE DIDN'T PROCESS COMMAND
*        HASPCOMM WILL ISSUE ERROR MESSAGE
         SPACE 1
CDMJNJF  B     NOTFND             RETURN AND LET HASPCOMM DOIT
CDMERR   EQU   NOTFND             RETURN ON ERRORS
         SPACE 1
CDMJC0   CLC   JQEJNAME,COMJNAME   SEE IF DESIRED JOBNAME,          R41
         BNE   CDMJNG                CONTINUE SCAN IF NOT           R41
         LTR   R4,R4               SEE IF FOUND BEFORE,             R41
         BNZ   CDMJNJF            BIF ALREADY FOUND TO HASPCOMM     R41
         LR    R4,R1               SHOW JQE FOUND                   R41
         B     CDMJNEXT            CONTINUE SCAN                    R41
         SPACE 1
CDMJOBID $CFCVB POINTER=(R5),NOK=CDMERR        EXTRACT JOBID        R41
         CLR   R0,R1               RANGE CANNOT BE SPECIFIED        R41
         BNE   CDMERR              ERROR IF RANGE                   R41
        $QLOC  (R1)                SEE IF SPECIFIED JOB EXISTS      R41
         BZ    CDMJNJF             ERROR IF JOB NOT FOUND           R41
         IC    R15,JQEFLAG3       CHECK JOB TYPE
         N     R15,=F'3'           TO DETERMINE
         CR    R15,R2               IF JOB/STC/TSU
         BNE   CDMJNJF               CORRECT
         SPACE 1
         LR    R2,R1               SAVE JQE POINTER IN WA           R41
         MVC   COMJNAME,QUEJNAME(R2) SAVE JOB NAME                  R41
CDMJXEQ  DS    0H                  ENTRY FROM $DM'JOBNAME','TEXT    R41
         TM    QUETYPE(R2),$XEQ   QUEUED FOR XEQ?                   R41
         BZ    NOTXEQNG           NOT EXECUTING-PRC EXTENSTION
         CLI   QUETYPE(R2),$XEQ    RETEST FOR EXECUTION             R41
         BE    NOTFND              ERROR IF REALLY CONVERSION       R41
*                                  SO JUST RETURN TO HASPCOMM
*        PRC EXTENSION DOESN'T WORK UNTIL AFTER CONVERSION
         IC    R0,QUEFLAGS(R2)     PICK UP BUSY FLAGS FOR JOB       R41
         N     R0,=A(QUEBUSY)      ISOLATE BUSY SYSTEM ID           R41
         BNZ   NOTFND             BIF BUSY, LET HASPCOMM DOIT
         TITLE 'PRC EXTENSION TO $DMJ TO REMOVE EXECUTING RESTRICTION'
*        JOB FOR WHICH $DM HAS BEEN ISSUED IS NOT EXECUTING.
*        GO FIND ITS LOG, AND ADD THE MESSAGE TO IT.
         SPACE 1
NOTXEQNG DS    0H                 JOB NOT EXECUTING
         SR    R10,R10            SHOW NO JCT YET
         ST    R2,PCEJQE          SAVE JQE ADR
         MVC   COMEWORK,0(R2)     SAVE 1ST 4 BYTES FOR VERIFICATION
         L     R1,0(R5)           --> POTENTIAL BAD OPERAND
         BXLE  R5,R6,GOTXT        STEP TO NEXT OPERAND
         $CFINVO OPERAND=(R1)     SAY INVALID - NO MSG
GOTXT    LM    R4,R5,0(R5)        START/END TXT + 2
         MVI   0(R5),X'FF'        PRESET LAST REC INDICATOR
         SLR   R5,R4              MSG LENGTH
         $GETBUF ,                GET A WORKING BFR
         BNZ   GOTBFR             BIF GOT
         MVI   BADCODE,C'B'       ERROR REASON
         B     BADCBKS            GO SAY NOT OK
         SPACE 1
GOTBFR   DS    0H
         LR    R10,R1             FOR JCT ADDRESSABILITY
         MVI   PCEDEVTP,PCEDARD   READ DEV TYPE
         ST    R10,PCEBUFAD       BFR ADR TO DA DCT
         MVC   PCESEEK,QUETRAK(R2)  JCT MTTR TO DCT
         LA    R1,PCEDADCT        --> DCT
         MVI   BADCODE,C'J'       POTENTIAL BAD REASON
         $EXCP (R1),WAIT=YES      READ THE JCT
         BM    BADCBKS            BIF I/O ERROR
         SPACE 1
         USING JCTDSECT,R10
         MVC   COMDWORK,JCTJOBID  SAVE JOBID FOR MSG
         ICM   R3,15,JCTJBKEY     GET JOB KEY FOR VERIFICATION
         MVC   PCESEEK,JCTIOT     --> IOT TRACK
         LA    R1,PCEDADCT        --> DCT
         MVI   BADCODE,C'I'       POTENTIAL BAD REASON
         $EXCP (R1),WAIT=YES      READ THE IOT
         BM    BADCBKS            BIF I/O ERROR
         SPACE 1
         USING IOTDSECT,R10
         MVI   BADCODE,C'K'       POTENTIAL BAD REASON
         C     R3,IOTJBKEY        KEY MATCH JCT?
         BNE   BADCBKS            BIF NOT
         L     R2,$IOTPDDB        DISPL OF FIRST PDDB
         LA    R2,PDBLENG(R2)     --> 2ND PDDB
         AR    R2,R10             --> LOG PDDB
         USING PDBDSECT,R2
         MVI   BADCODE,C'L'       SET POTENTIAL REASON
         CLC   =H'2',PDBDSKEY     IS THIS THE LOG PDB?
         BNE   BADCBKS            BIF NOT
         MVC   PCESEEK,PDBMTTR    LOG MTTR
LOGRLOP  LA    R1,PCEDADCT        --> DCT
         $EXCP (R1),WAIT=YES      READ FIRST/NEXT LOG TRACK
         BM    BADCBKS            BIF I/O ERROR
         USING BUFDSECT,R10
         C     R3,HDBJBKEY        KEY MATCH?
         BNE   BADCBKS            BIF NOT
         CLC   =H'2',HDBPDDBK     LOG DATASET?
         BNE   BADCBKS            BIF NOT
         SPACE 1
         TM    COMEWORK+QUETYPE,$XEQ  XEQ JOB?
         BO    USEIT              USE FIRST REC FOR INPUT JOBS
         ICM   R1,15,HDBNXTRK     PICKUP NEXT TRACK
         BZ    USEIT              USE LAST REC FOR OTHER JOBS
         ST    R1,PCESEEK         ELSE SET CHAIN TRACK ADR
         B     LOGRLOP             AND READ NEXT TRACK
         SPACE 1
USEIT    DS    0H                 USE THIS LOG BUFFER
*        WE NOW HAVE THE LOG BUFFER WE ARE GOING TO USE. SCAN FOR THE
*        END OF THE BUFFER, AND ADD OUR MESSAGE.  ALL OUR MESSAGES
*        THEREFORE COME AT THE END OF CONVERSION MESSAGES.
         SPACE 1
         LA    R2,HDBSTART        --> FIRST DATA RECORD
         SR    R1,R1              CLEAR WORK REG
         USING LRCDSECT,R2        DECLARE IT
         MVI   BADCODE,C'S'       SET POTENTIAL SPANNED REC REASON
NXTLREC  CLI   LRCTLENG,255       LAST RECORD?
         BE    LASTLREC           BIF END
         IC    R1,LRCTLENG        PICKUP LENGTH
         TM    LRCFLAG1,LRC1CCTL  HAVE CARR CTL?
         BZ    NOCCTL             BIF NOT
         LA    R1,1(R1)           STEP LEN 1 FOR CAR CTL
NOCCTL   TM    LRCFLAG1,LRC1SPAN  SPANNED RECORD?
         BO    BADCBKS            CAN'T PROCESS SPANNED HERE
         LA    R2,3(R2,R1)        STEP TO NEXT RECORD
         B     NXTLREC             AND PROCESS IT
         SPACE 1
LASTLREC DS    0H                 HAVE POINTER TO LAST LOG REC
         LA    R3,35(R5)          LNGTH FULL MSG MINUS X'FF'
         LA    R15,5(R3,R2)       CALCULATE END ADR
         LR    R14,R10              AND DETERMINE
         AH    R14,$BUFSIZE         IF MSG WILL FIT
         CR    R15,R14            DOES IT?
         BL    FITSOK             BIF FITS
         MVI   BADCODE,C'F'       ERROR REASON
         B     BADCBKS            SAY NOT OK
         SPACE 1
FITSOK   DS    0H
         STC   R3,LRCTLENG        SAVE LENGTH
         MVI   LRCFLAG1,LRC1CCTL+LRC1TASA  FLAG ASA CONTROL
         STC   R3,LRCLRECL         AND ORIGINAL LENGTH
         LA    R2,1(R2)           STEP 1 MORE BECAUSE THIS CODE
*                                  WAS ORIGINALLY WRITTEN NOT
*                                  EXPECTING CARR. CTL AND THE
*                                  ABOVE INSTR. CORRECTS FOR ASA.
         SPACE 1
*        WC POINTS TO NEW MESSAGE TO BE ADDED
*        WA IS ITS NEW OUTPUT POSITION, AND WD IS ITS LENGTH
         SPACE 1
         TIME  DEC                TIME?
         ST    R0,$DOUBLE           SAVE HHMMSSTH
         MVC   2(CDMJEDTL,R2),CDMJEDIT MOVE EDIT & FILL CHARS
         ED    2(9,R2),$DOUBLE  EDIT TIME OF DAY
         MVC   12(8,R2),COMDWORK  JOBID TO MSG
         TM    COMFLAG,CMBFLAGU    IF MSG FROM LOCAL CONSOLE,       R41
         BO    CDMVCTX2              LEAVE ID AT 'OPER'             R41
         SPACE 1
*        THIS SECTION OF CODE ESSENTIALLY COPIED FROM JES2 R4.1
*        IT DOES NOT PROPERLY IDENTIFY NJE NODAL OPERATORS
*        IF SOMEONE CONVERTS THIS TO JES/SP WITH FULL NJE
*        IDENTIFICATION, PLEASE SEND ME A COPY.
         SPACE 1
         MVC   X'1F'(4,R2),=X'D9202120' MOVE 'R' & EDIT PATTERN
         SLR   R0,R0               PICK UP                          R41
         IC    R0,COMRMT             REMOTE NUMBER                  R41
         CVD   R0,$DOUBLE            CREATE DECIMAL NUMBER
         LA    R1,X'22'(R2)          PRESET SIGNIF. CHAR. POINTER
         EDMK  X'1F'(4,R2),$DOUBLE+6     EDIT NUMBER AND
         MVC   X'20'(4,R2),0(R1)         LEFT-JUSTIFY
         SPACE 1
CDMVCTX2 EX    R5,MVCLOGR         MOVE TEXT
*        END MSG MARKER (X'FF') MOVED WITH INSTR ABOVE
         L     R2,PCEJQE          --> OUR JQE
         CLC   COMEWORK,0(R2)     HAS JOBTYPE OR NUMBER CHANGED?
         BNE   BADCBKS            BIF SO
         SPACE 1
         MVI   PCEDEVTP,PCEDAWR   MAKE DCT FOR WRITE
         LA    R1,PCEDADCT        --> DCT
         $EXCP (R1),WAIT=YES      REWRITE THE CONSOLE BLOCK
         $FREEBUF (R10)           FREE OUR BUFFER
         $CRET MSG='OK'
         SPACE 1
BADCBKS  DS    0H                 BAD CONTROL BLOCKS/DATA/ETC.
         LTR   R10,R10            DID WE GET A BFR?
         BZ    BADMSG             BIF NOT
         $FREEBUF (R10)           FREE IT
         SR    R10,R10            NO MORE BFR
BADMSG   DS    0H                 SEND THE MESSAGE
         MVC COMMAND(16),=C'$DM NOT DONE (X)'  SAY NOT OK
         MVI   COMMAND+14,C'X'    BETTER REASON TO MSG
BADCODE  EQU   *-3
         $CRET L=16               THATS ALL FOLKS
         SPACE 1
MVCLOGR  MVC   38(*-*,R2),0(R4)   EXECUTED MOVE TEXT
CDMJNMV  MVC   COMJNAME(*-*),0(R1) *** EXECUTE ONLY ***             R41
CDMJEDIT DS    0C                  EDIT PATTERNS AND FILLER         R41
         DC    X'4021204B20204B2020'                                R41
         DC    C' JOB NNNN  '                                       R41
S34CONST DC    C'MSG FROM OPER:    '                                R41
S34HEADR EQU   S34DTEXT,L'S34CONST LOCATION OF ABOVE TEXT           R41
S34EDIT  EQU   S34HEADR+9,4        EDIT PATTERN OVERLAYS 'OPER'     R41
S34MSG   EQU   S34HEADR+16         TEXT OF MESSAGE                  R41
CDMJEDTL EQU   *-CDMJEDIT          LENGTH FOR INITIAL MOVE          R41
         LTORG
         SPACE 1
         TITLE '$OP COMMAND'
*
*        LIST NUMBER OF JOBS AND LINE COUNTS FOR A DESTINATION
*
         SPACE 1
CMDOP    $COMGRUP OP,DELAY=YES    DEFINE OP ENTRY
COP      DS    0H
         BAL   R14,COFRTD         SET DEFAULT ROUTE
         LR    R2,R1              SAVE ROUTE CODE
         BXH   R5,R6,DOPSCAN      BIF NO ROUTE SPECIFIED
         BAL   R14,COFRTR         GO DECODE ROUTE CODE
         BNZ   DOPSCAN            BIF COULDN'T DECODE
         LR    R2,R1              SAVE ROUTE CODE
         SPACE 1
DOPSCAN  DS    0H                 SCAN JOES FOR JOBS THIS DEST
*
*        COUNT NUMBER OF JOBS AND LINES FOR PRINT STD FORMS,
*        PRINT SPECIAL SETUP, AND PUNCH
*
*        COUNTS HELD IN REGS - HI BYTE = JOB COUNT, LO 3 = LINES
*        WF=PRINT STD.
*        WE=PRINT SPEC
*        WD=PUNCH
*
         SR    R5,R5              CLEAR
         SR    R6,R6               COUNTER
         SR    R7,R7                REGS
         SPACE 1
         SR    R3,R3              SET FOR CLASS A SCAN
         B     COPCLASS           PROCESS IT
COPNXTC  LA    R3,4(R3)           STEP TO NXT CLASS
         CH    R3,=AL2((2*4*36)-1)  FINISHED?
         BNL   COPTHRU            BIF SO
         SPACE 1
COPCLASS L     R1,$JOTABLE        --> JOT
         USING JOTDSECT,R1
         LA    R1,JOTNTWKQ-(JOENEXT-JOEDSECT)(R3)  --> QUEUE
         DROP  R1
         USING JOEDSECT,R1
CONXTJOE DS    0H                 --> NEXT JOE
         L     R1,JOENEXT         --> NEXT JOE
         LA    R1,0(R1)           CLEAR TOP BYTE
         LTR   R1,R1              END OF CHAIN?
         BZ    COPNXTC            NXT CLASS IF NONE
         A     R1,$JOTABLE        COMPUTE ACTUAL JOE ADR
         SPACE 1
         L     R14,JOEDEST        DEST FROM PDDB
         LTR   R14,R14            ONE SPECIFIED?
         BNZ   COGOTRT            BIF SO
         L     R4,JOEJQE          JQE OFFSET
         LA    R4,0(R4)           PURIFY
         AL    R4,$JOBQPTR        THEN REAL JQE ADR
         L     R14,JQEPRTRT-JQEDSECT(R4)  PICKUP JQE DEST
COGOTRT  CR    R2,R14             ROUTE MATCH?
         BNE   CONXTJOE           NXT JOE IF NOT
         CLI   JOECURCL,C'B'      CHECK CLASS
         BE    COPCH              COUNT PUNCH
         BH    COSPEC             COUNT SPECIAL IF HIGH
         SPACE 1
         ICM   R4,15,JOECHAR      CHAR JOE OFFSET
         BZ    COSTD              BIF NONE - NETWORK JOE
         LA    R4,0(R4)           PURIFY
         A     R4,$JOTABLE        REAL ADDRESS
         SPACE 1
COSTD    CLC   =C'STD ',JOEFORM-JOEDSECT(R4)  STANDARD FORMS?
         BNE   COSPEC             SPECIAL IF NOT
         CLC   =C'********        ',JOEFCB-JOEDSECT(R4) FCB,UCS,WTR
         BNE   COSPEC             SPECIAL IF NOT
         SPACE 1
         AL    R7,JOERECCT        SUMM RECORDS
         AL    R7,=X'01000000'    COUNT JOB
         B     CONXTJOE           NXT JOE
         SPACE 1
COSPEC   AL    R6,JOERECCT        SUM RECORDS
         AL    R6,=X'01000000'    COUNT JOB
         B     CONXTJOE           NXT JOE
         SPACE 1
COPCH    AL    R5,JOERECCT        SUM RECORDS
         AL    R5,=X'01000000'    COUNT JOB
         B     CONXTJOE           NXT JOE
         SPACE 1
COPTHRU  DS    0H                 JOES COUNTED, BUILD REPLY
         ST    R2,COMDWORK        INPUT PARM
         LA    R15,COMDWORK       POINT TO DESTINATION
         LA    R0,COMMAND         --> OUTPUT AREA
         BAL   R14,COFRTC         CONVERT ROUTE CODE TO PRINTABLE
         SPACE 1
COSPRI   MVC   COMMAND+12(11),=C'  PRINT STD'
         LA    R4,COMMAND+22      --> OUTPUT POSITION
         LR    R1,R7              STD COUNTS
         BAL   R14,COPCONV        CONVERT STD
         MVC   0(6,R4),=C' SPEC'
         LA    R4,5(R4)           STEP OVER IT
         LR    R1,R6              SPECIAL COUNTS
         BAL   R14,COPCONV        CONVERT SPECIAL
         MVC   0(6,R4),=C' PUNCH'
         LA    R4,6(R4)           STEP OVER
         LR    R1,R5              PUNCH COUNTS
         BAL   R14,COPCONV        CONVERT PUNCH
         LA    R1,COMMAND         --> FIRST POSITION
         SR    R4,R1              CALCULATE LENGTH
         $CRET  L=(R4)            RETURN WITH MESSAGE
         SPACE 1
COPCONV  DS    0H                 CONVERT JOB AND RECORD COUNTS
         LTR   R2,R1              SAVE INPUT
         BZ    CONONE             BIF NOTHING THIS CATEGORY
         SRL   R1,24              PURIFY JOE COUNT
         CVD   R1,COMDWORK        CONVERT TO DEC
         MVC   0(4,R4),=X'40202021' MASK
         ED    0(4,R4),COMDWORK+6 TO EBCDIC
         LA    R2,0(R2)           CLEAR HI BYTE OF LINECOUNT
         CVD   R2,COMDWORK        CONVERT
         MVC   4(8,R4),=X'4020202021202020'
         ED    4(8,R4),COMDWORK+4 TO EBCDIC
         LA    R4,12(R4)          STEP OVER THIS OUTPUT
         BR    R14                RETURN
CONONE   MVC   0(6,R4),=C' NONE '
         LA    R4,6(R4)           STEP OVER IT
         BR    R14                 AND RETURN
         DROP  R1
         LTORG
         SPACE 2
         PRINT GEN
         $MODEND
         SPACE 1
         END
