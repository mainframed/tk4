         MACRO
&LABEL   PROLOGUE  &COMMENT,&SAVEREG=12(13),                           X
               &USING=*,&ID=*,&REPA=15,&BASEREG=12,                    X
               &TRACE=NO,&OUTPUT=PUT,                                  X
               &SAVE=R13PLUS18F,&FORECHN=YES,&BACKCHN=YES,             X
               &EXBASE=,                                               X
               &DATE=68060
.**********************************************************************
.*                                                                    *
.*       PROLOGUE GENERATES A STANDARD LINKAGE HEADER FOR SUBROUTINES.*
.*       WHEN USED TO FULL CAPABILITY, IT WILL GENERATE STATEMENTS TO *
.*       ASSIGN A BASE REGISTER TO THE SUBROUTINE,                    *
.*       SAVE THE REGISTERS OF THE CALLING PROGRAM,                   *
.*       TRACE THE SUBROUTINE EXECUTION ON THE OPERATOR CONSOLE OR    *
.*       ON AN OUTPUT DATA SET OR BOTH,                               *
.*       OBTAIN A SAVE AREA, EITHER BY INCREMENTING REGISTER 13,      *
.*       USING A SAVE AREA WHOSE NAME IS SUPPLIED TO PROLOGUE,        *
.*       GENERATING AN AREA INLINE, OR ISSUING A GETMAIN,             *
.*       SET UP REGISTER 13 TO CONTAIN THE ADDRESS OF THAT SAVE AREA
.*       FOR LOWER LEVEL SUBROUTINES TO USE FOR SAVING REGISTERS,     *
.*       FORWARD CHAIN THE SAVE AREA ADDRESSES,                       *
.*       AND BACK CHAIN THE SAVE AREA ADDRESSES.                      *
.*                                                                    *
.*                                                                    *
.*       &COMMENT             THE POSITIONAL OPERAND &COMMENT INSURES *
.*                            THAT THE USE OF PROLOGUE IN THE FORM -- *
.*                                                                    *
.*                            LABEL PROLOGUE ERROR-GENERATING-COMMENT *
.*                                                                    *
.*                            DOES NOT GENERATE INVALID KEYWORD       *
.*                            ASSEMBLY ERRORS.                        *
.*                                                                    *
.*       &USING=*             OR SYMBOL OR OTHER LOCATION COUNTER     *
.*                            REFERENCE.  OPERAND OF USING STATEMENT. *
.*                            IF USING=0 IS SPECIFIED, NO USING       *
.*                            STATEMENT IS GENERATED.                 *
.*                                                                    *
.*       &SAVEREG=12(13)      OR SYMBOL OR NO.  UNLESS SAVEREG=NO,    *
.*                            THE REGISTERS ARE STORED WITH A         @
.*                                                                    *
.*                                     STM   14,12,&SAVEREG           *
.*                                                                    *
.*                            IF SAVEREG=NO, THE REGISTERS ARE NOT    *
.*                            SAVED AND ALL OTHER PARAMETERS EXCEPT   *
.*                            &USING AND &BASEREG ARE IGNORED.        *
.*                                                                    *
.*       &ID=*                OR SYMBOL.  IDENTIFIER.                 *
.*                            IF ID=*, THEN THE IDENTIFIER IS &LABEL  *
.*                            UNLESS &LABEL IS NULL, IN WHICH CASE    *
.*                            THE IDENTIFIER IS &SYSECT, THE CURRENT  *
.*                            CSECT NAME UNLESS &SYSECT IS NULL, IN   *
.*                            WHICH CASE THE IDENTIFIER IS 'ID ERROR'.*
.*                            IF &ID IS NOT '*', THEN &ID ITSELF      *
.*                            IS THE IDENTIFIER.                      *
.*                            THE IDENTIFIER DETERMINED BY &ID IS     *
.*                            USED AS FOLLOWS --                      *
.*                            1.  THE SAVE IDENTIFIER CONSISTS OF     *
.*                            THE IDENTIFIER DETERMINED BY &ID, CON-  *
.*                            CATENATED WITH A PERIOD, CONCATENATED   *
.*                            &DATE, UNLESS DATE=NO, IN WHICH CASE    *
.*                            BOTH THE PERIOD AND &DATE ARE OMITTED.  *
.*                            2. THE TRACE IDENTIFIER CONSISTS OF THE *
.*                            IDENTIFIER DETERMINED BY &ID UP TO THE  *
.*                            FIRST 126 CHARACTERS, THE LENGTH OF THE *
.*                            LINE ON THE CONSOLE TYPEWRITER.         *
.*                                                                    *
.*       &REPA=15             OR SYMBOL OR NUMBER.  REGISTER WHICH IS *
.*                            ASSUMED TO CONTAIN THE ADDRESS OF THE   *
.*                            FIRST INSTRUCTION GENERATED BY PROLOGUE.*
.*                            OS/360 CONVENTION IS 15, BUT ANY OTHER  *
.*                            REGISTER CAN BE USED, FOR EXAMPLE --    *
.*                                  BALR  11,0                        *
.*                                  PROLOGUE REPA=11                  *
.*                                                                    *
.*       &BASEREG=12          OR SYMBOL OR NUMBER.  BASE REGISTER TO  *
.*                            BE USED.  DEFAULT BASE REGISTER IS 12.  *
.*                            THE BASE REGISTER IS LOADED BY          *
.*                                                                    *
.*                                      LR   &BASEREG,15              *
.*                                                                    *
.*                            WHICH IS GENERATED UNLESS BASEREG=15.   *
.*                                                                    *
.*       &TRACE=NO            OR YES.                                 *
.*                                                                    *
.*                            IF TRACE=NO, NO TRACE CODE IS GENERATED.*
.*                                                                    *
.*                            IF TRACE=YES, TRACE CODE IS GENERATED   *
.*                            TO WRITE OUT A MESSAGE ON THE DEVICE(S) *
.*                            DETERMINED BY &OUTPUT.                  *
.*                            THE MESSAGE TEXT IS THE IDENTIFIER      *
.*                            DETERMINED BY &ID.                      *
.*                                                                    *
.*                            IF THE BINARY GLOBAL &PTRACE IS SET TO  *
.*                            1, THEN TRACE=NO IS SUPERSEDED AND      *
.*                            CODE IS GENERATED AS IF TRACE=YES.      *
.*                                                                    *
.*                            IF NEITHER YES OR NO, YES IS ASSUMED,   *
.*                            BUT AN ERROR COMMENT IS GENERATED.      *
.*                                                                    *
.*       &SAVE=R13PLUS18F     OR GETMAIN, OR INLINE, OR NONE.         *
.*                            IF NONE OF THESE, &SAVE IS ASSUMED TO BE*
.*                            THE NAME OF A USER SUPPLIED SAVE AREA.  *
.*                                                                    *
.*                            IF SAVE=R13PLUS18F, THE SAVE AREA IS    *
.*                            ASSUMED TO BE 18 FULL WORDS PAST THE    *
.*                            SAVE AREA POINTED TO BY REGISTER 13.    *
.*                                                                    *
.*                            IF SAVE=INLINE, THERE ARE TWO FORMS --  *
.*                            SAVE=INLINE, OR                         *
.*                            SAVE=(INLINE,LENGTH,NAME)               *
.*                            WHERE EITHER LENGTH OR NAME MAY         *
.*                            OPTIONALLY BE OMITTED.                  *
.*                            IF LENGTH IS A NUMBER OR A SYMBOL, IT   *
.*                            IS ASSUMED TO BE THE SAVE AREA LENGTH   *
.*                            IN BYTES.                               *
.*                            LENGTH MAY ALSO BE A NUMBER IMMEDIATELY *
.*                            FOLLOWED (WITH NO INTERVENING BLANKS) BY*
.*                            ONE OF THE LETTERS D,F,H,C, OR X,       *
.*                            SIGNIFYING DOUBLEWORDS, FULLWORDS,      *
.*                            HALFWORDS, OR BYTES RESPECTIVELY.       *
.*                            SYMBOLIC LENGTHS MUST NOT END IN D, F,  *
.*                            H, C, OR X.                             *
.*                            SYMBOLIC LENGTHS MAY NOT EXCEED         *
.*                            EIGHT CHARACTERS.                       *
.*                            IF LENGTH IS OMITTED, 18F IS ASSUMED.   *
.*                            IF NAME IS OMITTED, SAVE&SYSNDX IS      *
.*                            ASSUMED.                                *
.*                            AN AREA WITH THE CORRECT LENGTH AND NAME*
.*                            IS GENERATED INLINE AND BRANCHED AROUND.*
.*                                                                    *
.*                            IF SAVE=GETMAIN, THERE ARE TWO FORMS -- *
.*                            SAVE=GETMAIN, OR                        *
.*                            SAVE=(GETMAIN,LENGTH,SANAME,NOMARK)     *
.*                            WHERE LENGTH, SANAME, OR THE WORD       *
.*                            NOMARK MAY OPTIONALLY BE OMITTED.       *
.*                            THE INTERPRETATIONS OF LENGTH AND       *
.*                            SANAME ARE THE SAME AS FOR SAVE=INLINE. *
.*                            THE GLOBAL &SGBYTES IS SET TO THE       *
.*                            NUMBER OF BYTES OBTAINED BY THE GETMAIN,*
.*                            SO THAT THE EPILOGUE MACRO, IF INVOKED  *
.*                            WITH SAVE=FREEMAIN, WILL FREE THE       *
.*                            CORRECT AMOUNT.                         *
.*                            THE BINARY GLOBAL &NLE4095 IS SET IF    *
.*                            &SGBYTES IS KNOWN TO BE LESS THAN OR    *
.*                            EQUAL TO 4095 BYTES.                    *
.*                            PROLOGUE LEAVES &SGBYTES AND &NLE4095   *
.*                            UNCHANGED UNLESS SAVE=GETMAIN.          *
.*                            SAVE=GETMAIN IMPLIES BACKCHN=YES SO     *
.*                            THAT EPILOGUE WILL BE ABLE TO FIND      *
.*                            AND FREE THE SAVE AREA CORRECTLY.       *
.*                            NORMALLY, UNLESS THE WORD 'NOMARK' IS   *
.*                            INCLUDED AS THE FOURTH POSITIONAL SUB-  *
.*                            PARAMETER OF &SAVE, CODE IS GENERATED   *
.*                            TO STORE A 'G' INTO THE HIGH ORDER BYTE *
.*                            OF THE FORWARD CHAIN ADDRESS (WORD 2)   *
.*                            OF THE SAVE AREA OBTAINED WITH THE      *
.*                            GETMAIN, THUS MARKING THE SAVE  AREA AS *
.*                            HAVING BEEN OBTAINED WITH A GETMAIN.    .
.*                            IF THE EPILOGUE MACRO IS USED TO        *
.*                            GENERATE THE RETURN LINKAGE WITH        *
.*                            SAVE=FREEMAIN, IT WILL GENERATE CODE TO *
.*                            CHECK FOR THE 'G' AND NOT ISSUE THE     *
.*                            FREEMAIN IF THE 'G' IS NOT THERE.       *
.*                            IF PROLOGUE IS USED WITH                *
.*                            SAVE=(GETMAIN,,NOMARK), THEN THE        *
.*                            CORRESPONDING EPILOGUE SHOULD BE USED   *
.*                            WITH SAVE=(FREEMAIN,,NOCHECK), IN WHICH *
.*                            CASE EPILOGUE WILL NOT GENERATE CODE TO *
.*                            CHECK FOR A 'G' AND WILL ALWAYS DO THE  *
.*                            FREEMAIN.  THE NOMARK FORM OF PROLOGUE  *
.*                            AND THE NOCHECK FORM OF EPILOGUE SHOULD *
.*                            ONLY BE USED IN CASES WHERE THE         *
.*                            PROGRAMMER IS SURE THAT THE NUMBER OF   *
.*                            GETMAINS AND FREEMAINS WILL BE THE SAME.*
.*                                                                    *
.*                                                                    *
.*                            IF NONE, NO SAVE AREA IS GENERATED AND  *
.*                            USER IS RESPONSIBLE FOR SETTING UP      *
.*                            REGISTER 13.  THE &FORECHN AND &BACKCHN *
.*                            PARAMETERS ARE IGNORED.                 *
.*                                                                    *
.*       &FORECHN=YES         OR NO.                                  *
.*                            IF FORECHN=YES, THE ADDRESS OF THE      *
.*                            SAVE AREA OF THE CALLING PROGRAM IS     *
.*                            STORED INTO WORD 2 OF THE SAVE AREA OF  *
.*                            THIS PROGRAM.                           *
.*                            IF FORECHN=NO, NO FORWARD CHAINING CODE *
.*                            IS GENERATED.                           *
.*                            IF NEITHER YES OR NO, NO IS ASSUMED,    *
.*                            BUT AN ERROR COMMENT IS GENERATED.      *
.*                                                                    *
.*       &BACKCHN=YES         OR NO.                                  *
.*                            IF BACKCHN=YES, THE ADDRESS OF THE      *
.*                            SAVE AREA OF THIS PROGRAM IS STORED     *
.*                            INTO WORD 3 OF THE SAVE AREA OF THE     *
.*                            CALLING PROGRAM.                        *
.*                            IF BACKCHN=NO, NO CODE IS GENERATED TO  *
.*                            BACKCHAIN  (PUT THE ADDRESS OF THE SAVE *
.*                            AREA OF THIS PROGRAM INTO WORD 3 OF THE *
.*                            SAVE AREA OF THE CALLING PROGRAM).      *
.*                            IF NEITHER YES OR NO, NO IS ASSUMED,    *
.*                            BUT AN ERROR COMMENT IS GENERATED.      *
.*                                                                    *
.*       &DATE=               DATE TO BE CONCATENATED ONTO THE NORMAL *
.*                            SAVE IDENTIFIER UNLESS DATE=NONE.       *
.*                            &DATE IS NOT CONCATENATED ONTO THE      *
.*                            TRACE MESSAGE.                          *
.*                                                                    *
.**********************************************************************
.*
.*
.*
.**********************************************************************
.*                                                                    *
.*       DECLARATIONS                                                 *
.*                                                                    *
.**********************************************************************
         GBLB  &PTRACE        IF SET, OVERRIDES TRACE=NO, CAUSING TRACE
         GBLB  &NLE4095       SET IF &SBYTES IS KNOWN TO BE LE 4095
         GBLC  &SGBYTES       GETMAIN SAVE AREA LENGTH -- FOR FREEMAIN
         LCLA  &I,&J          TEMPORARY NUMERIC VARIABLE
         LCLA  &#SCHRS        NUMBER OF CHARACTERS IN SAVE ID
         LCLB  &SLE4095       INTERNAL VARIABLE LIKE &NLE4095
         LCLA  &#IDCHRS       NUMBER OF CHRS IN &ID OR &IDSTAR
         LCLC  &IDSTAR        IF ID=* THEN LABEL UNLESS '' THEN &SYSECT
         LCLC  &FILL          SEPARATOR BETWEEN ID AND DATE
         LCLC  &SAVNAME       SAVEAREA NAME.
         LCLC  &SNUMBER       NUMERIC PART OF LENGTH
         LCLC  &LP,&RP        LEFT AND RIGHT PARAMTHESES FOR &SNUMBER
         LCLC  &SUNIT         UNIT    PART OF LENGTH
         LCLC  &MULT          NUMERIC EQUIVALENT OF &SUNIT
         LCLC  &SBYTES        NUMBER OF BYTES IN SAVE AREA -- SYMBOLIC
         LCLC  &RTEMP         TEMPORARY REGISTER USED FOR BACK CHAINING
         LCLC  &OFFSET        SAVE AREA OFFSET TO RESTORE &RTEMP
         LCLC  &PLIFLAG       HIGH BYTE OF PL/I WORD IN DSA
         SPACE 3
***********************************************************************
*        PROLOGUE GENERATES A STANDARD HEADER FOR A SUBROUTINE.       *
***********************************************************************
.*
.*
.*
.**********************************************************************
.*                                                                    *
.*       SET UP &RTEMP                                                *
.*                                                                    *
.**********************************************************************
         AIF   ('&BASEREG' NE '15').RTEMP15
&RTEMP   SETC  '14'
&OFFSET  SETC  '12'
         AGO   .RTEMPOK
.RTEMP15 ANOP
&RTEMP   SETC  '15'
&OFFSET  SETC  '16'
.RTEMPOK ANOP
.**********************************************************************
.*                                                                    *
.*       SET UP SAVE AND TRACE IDENTIFIER PARAMETERS                  *
.*                                                                    *
.**********************************************************************
&#IDCHRS SETA  1
         AIF   ('&ID' NE '*').ID
         AIF   ('&LABEL' EQ '').USECS
&IDSTAR  SETC  '&LABEL'
         AGO   .GETKID
.USECS   AIF   ('&SYSECT' EQ '').IDERR
&IDSTAR  SETC  '&SYSECT'
         AGO   .GETKID
.IDERR   ANOP
&IDSTAR  SETC  'ID ERROR'
.GETKID  AIF   ('&IDSTAR'(1,&#IDCHRS) EQ '&IDSTAR').KIDOK
&#IDCHRS SETA  &#IDCHRS+1
         AGO   .GETKID
.ID      ANOP
&#IDCHRS SETA  K'&ID
.KIDOK   ANOP
&#SCHRS  SETA  &#IDCHRS
         AIF   ('&DATE' EQ 'NONE').DATEOK
&FILL    SETC  '.'
&#SCHRS  SETA  &#IDCHRS+K'&DATE+1
.DATEOK  ANOP
.**********************************************************************
.*                                                                    *
.*       GET SAVE AREA NAME                                           *
.*                                                                    *
.**********************************************************************
         AIF   ('&SAVE(1)' EQ 'R13PLUS18F').NAME72
         AIF   ('&SAVE(1)' EQ 'INLINE').NAMEIN
&SAVNAME SETC  '&SAVE(1)'    SET &SAVNAME, THE NAME OF THE SAVE AREA.
         AGO   .NAMEOK
.NAME72  ANOP
&SAVNAME SETC  '72(0,13)'
         AGO   .NAMEOK
.NAMEIN  AIF   ('&SAVE(3)' EQ '').NAMENDX
&SAVNAME SETC  '&SAVE(3)'     SET SAVE AREA NAME
         AGO   .NAMEOK
.NAMENDX ANOP
&SAVNAME SETC  'SAVE&SYSNDX'  UNIQUE SAVE AREA NAME.
.NAMEOK  ANOP
.**********************************************************************
.*                                                                    *
.*       GET SAVE AREA LENGTH FOR SAVE=INLINE, GETMAIN, OR DSA        *
.*                                                                    *
.**********************************************************************
         AIF   ('&SAVE(1)' EQ  'INLINE').SETVALS SET PARAMETER VALUES
         AIF   ('&SAVE(1)' EQ 'GETMAIN').SETVALS SET PARAMETER VALUES
         AIF   ('&SAVE(1)' EQ     'DSA').SETVALS SET PARAMETER VALUES
         AGO   .SAVEOK        NO NEED TO LOOK AT SAVE SUB-PARAMETERS
.SETVALS ANOP                 GET SAVE SUB-PARAMETER VALUES
&SBYTES  SETC   '&SAVE(2)'    GET SAVE AREA LENGTH
         AIF   ('&SBYTES' EQ '').DEFAULT
         AIF   (T'&SAVE(2) EQ 'N').BYTES  IF NUMERIC, ASSUME BYTES
&I       SETA  K'&SAVE(2)     GET NUMBER OF CHARACTERS IN LENGTH
&SNUMBER SETC  '&SBYTES'(1,&I-1)        GET PURE NUMERIC PART OF LENGTH
&SUNIT   SETC  '&SBYTES'(&I,1)          GET UNIT CHARACTER -- D,F,H,C,X
&I       SETA  1
.GETUNIT AIF   ('&SUNIT' EQ 'DFHCX'(&I,1)).MULT
&I       SETA  &I+1
         AIF   (&I LE 5).GETUNIT ELSE MUST BE SYMBOLIC SAVE AREA LENGTH
&LP      SETC  '('
&SNUMBER SETC  '&SAVE(2)'
&RP      SETC  ')'
.BYTES   ANOP
&SUNIT   SETC  'C'
         AGO   .LOK
.MULT    ANOP
&MULT    SETC  '84211'(&I,1)  GET MULTIPLIER CORRESPONDING TO UNIT
&I       SETA  &SNUMBER*&MULT
&SLE4095 SETB  (&I LE 4095)
&SBYTES  SETC  '&I'
         AGO   .LOK
.DEFAULT ANOP
         AIF   ('&SAVE(1)' NE 'DSA').L72
&SBYTES  SETC  '88'
&SLE4095 SETB  1
         AGO   .LOK
.L72     ANOP
&SBYTES  SETC  '72'
&SNUMBER SETC  '18'
&SLE4095 SETB  1
&SUNIT   SETC  'F'
.LOK     ANOP
.SAVEOK  ANOP
         AIF   ('&SAVE(1)' NE 'DSA').PLIFOK
&PLIFLAG SETC  '&SAVE(4)'
         AIF   ('&PLIFLAG' NE '').PLIFOK
&PLIFLAG SETC  'X''80'''
.PLIFOK  ANOP
.**********************************************************************
.*                                                                    *
.*       USING                                                        *
.*                                                                    *
.**********************************************************************
         AIF   ('&USING' EQ '0').NOUSING
         USING &USING,&BASEREG !          USE A BASE REGISTER.
         AIF   (T'&EXBASE EQ 'O').NOUSING
         AIF   ('&EXBASE'(1,1) EQ '(').USGMA
         USING &USING+4096,&EXBASE
         AGO   .NOUSING
.USGMA   ANOP
&J       SETA  4096
&I       SETA  1
.USGM    ANOP
         USING &USING+&J,&EXBASE(&I)
&J       SETA  &J+4096
&I       SETA  &I+1
         AIF   (N'&EXBASE GE &I).USGM
.NOUSING ANOP
&LABEL   DS    0H
.**********************************************************************
.*                                                                    *
.*       SAVE REGISTERS                                               *
.*                                                                    *
.**********************************************************************
         AIF   ('&SAVEREG' NE 'NO').RSAVE
***********************************************************************
*        REGISTERS WERE NOT SAVED IN CALLING PROGRAM SAVE AREA.       *
***********************************************************************
         AGO   .ENDPROL
.RSAVE   ANOP
&I       SETA  &#SCHRS+5      OFFSET FROM B TO STM
&I       SETA  ((&I+1)/2)*2   ROUND UP TO HALFWORD ALIGNMENT
         AIF   ('&USING' EQ '*').BRANCH
         AIF   ('&USING' EQ '0').BRANCH
         B     *-(&USING)+&I.(0,&REPA) BRANCH AROUND IDENTIFIER
         AGO   .BROK
.BRANCH  B     &I.(0,&REPA) !   BRANCH AROUND IDENTIFIER
.BROK    DC    AL1(&#SCHRS) !       IDENTIFIER LENGTH
         AIF   ('&ID' EQ '*').IDSTARS
         AIF   ('&DATE' EQ 'NONE').MAC001                          6060
         DC    C'&ID&FILL&DATE' ! IDENTIFIER
         AGO   .SAVE
.MAC001  DC    C'&ID'         IDENTIFIER                           6060
         AGO   .SAVE                                               6060
.IDSTARS AIF   ('&DATE' EQ 'NONE').MAC002                          6060
         DC    C'&IDSTAR&FILL&DATE'  IDENTIFIER                    6060
         AGO   .SAVE                                               6060
.MAC002  DC    C'&IDSTAR'     IDENTIFIER                           6060
.SAVE    STM   14,12,&SAVEREG !  SAVE REGISTERS
.**********************************************************************
.*                                                                    *
.*       LOAD BASE REGISTER                                           *
.*                                                                    *
.**********************************************************************
         AIF   ('&BASEREG' EQ '&REPA').NOLOAD
         LR    &BASEREG,&REPA !         SET UP THE BASE REGISTER.
         AGO   .BRSETUP
.NOLOAD  ANOP
*        BASE REGISTER IS ALREADY SET UP.  NO LR GENERATED.
.BRSETUP ANOP
         AIF   (T'&EXBASE EQ 'O').MBASE
         AIF   ('&EXBASE'(1,1) EQ '(').MLTP
         LA    &EXBASE,2048(&BASEREG)
         LA    &EXBASE,2048(&EXBASE)
         AGO   .MBASE
.MLTP    ANOP
&I       SETA  1
         LA    &EXBASE(1),2048(&BASEREG)
         LA    &EXBASE(1),2048(&EXBASE(1))
.MULLP   ANOP
&I       SETA  &I+1
         AIF   (N'&EXBASE LT &I).MBASE
         LA    &EXBASE(&I),2048(&EXBASE(&I-1))
         LA    &EXBASE(&I),2048(&EXBASE(&I))
         AGO   .MULLP
.MBASE   ANOP
.**********************************************************************
.*                                                                    *
.*       GENERATE TRACE CODE                                          *
.*                                                                    *
.**********************************************************************
         AIF   ('&TRACE' NE 'YES' AND NOT &PTRACE).NOTRACE
&I       SETA  &#IDCHRS+8     GET OFFSET FROM BAL TO IWT SVC
&I       SETA  ((&I+1)/2)*2   ROUND UP TO HALFWORD ALIGNMENT
         CNOP  0,4 !           ALIGN PARAMETER LIST
         BAL   1,*+&I !        BRANCH AROUND PARAMETER LIST
&#IDCHRS SETA  &#IDCHRS+4     ADD 4 FOR FULLWORD PRECEDING THE MESSAGE
         AIF   (&#IDCHRS LE 130).#CHRSOK
&#IDCHRS SETA  130
.#CHRSOK DC    AL2(&#IDCHRS) !        LENGTH OF PARAMETER LIST
         DC    AL2(0)
&#IDCHRS SETA  &#IDCHRS-4     RESTORE # OF ID CHRS TO TRUE VALUE
         AIF   ('&ID' EQ '*').IDSTART
         DC    CL&#IDCHRS'&ID' ! MESSAGE
         AGO   .MESSOK
.IDSTART DC    CL&#IDCHRS'&IDSTAR' ! MESSAGE
.MESSOK  SVC   35 !            ISSUE WRITE TO OPERATOR SVC
         AIF   ('&SAVE(1)' EQ 'GETMAIN').NOLM NO RESTORE IF OTHER SVC
         AIF   ('&SAVE(1)' EQ     'DSA').NOLM NO RESTORE IF OTHER SVC
         LM    14,1,12(13) !   RESTORE REGISTERS 14 TO 1 WHICH MAY BE
*                              DESTROYED BY THE TRACE, FROM SAVE AREA
.NOLM    ANOP
.NOTRACE ANOP
.**********************************************************************
.*                                                                    *
.*       SET UP SAVE AREA                                             *
.*                                                                    *
.**********************************************************************
         AIF   ('&SAVE'    EQ    'NONE').NOSAVE
         AIF   ('&SAVE(1)' EQ 'GETMAIN').GETMAIN
         AIF   ('&SAVE(1)' EQ     'DSA').GETMAIN
         AIF   ('&FORECHN' NE 'YES' AND '&BACKCHN' NE 'YES').NOCHAIN
         LR    &RTEMP,13 !         SAVE ADDRESS OF CALLER'S SAVE AREA
.NOCHAIN LA    13,&SAVNAME !   LOAD REGISTER 13 WITH SAVE AREA ADDRESS
         AIF   ('&FORECHN' NE 'YES').NOFORE
         ST    &RTEMP,4(13) !      FORWARD CHAIN.  PUT ADDRESS OF
*                              CALLER'S SAVE AREA INTO WORD 2 OF THIS
*                              PROGRAM'S SAVE AREA.
.NOFORE  ANOP
         AIF   ('&BACKCHN' NE 'YES').NOBACK
         ST    13,8(&RTEMP) !      BACK CHAIN. PUT ADDRESS OF SAVE AREA
*                              FOR THIS PROGRAM INTO WORD 3 OF CALLER'S
*                              SAVE AREA
.NOBACK  ANOP
         AIF   ('&FORECHN' NE 'YES' AND '&BACKCHN' NE 'YES').NOREST
         L     &RTEMP,&OFFSET.(&RTEMP) !     RESTORE WORKING REGISTER
*                              FROM SAVE AREA WHICH REGISTER POINTS TO
.NOREST  ANOP
         AIF   ('&SAVE' EQ 'R13PLUS18F').R13SAVE
         AIF   ('&SAVE(1)' EQ  'INLINE').INLINE
         AGO   .USESAVE       &SAVE MUST BE NAME OF USER SAVE AREA
.R13SAVE ANOP
***********************************************************************
*        SAVE AREA IS ASSUMED TO BE 18 FULLWORDS PAST                 *
*        THE SAVE AREA OF THE CALLING PROGRAM.                        *
***********************************************************************
         AGO   .ENDPROL
.INLINE  ANOP
.SAVEGEN B     &SAVNAME+&SBYTES     !   BRANCH AROUND SAVE AREA
&SAVNAME DS    &LP&SNUMBER&RP&SUNIT !           SAVE AREA
***********************************************************************
*        SAVE AREA GENERATED INLINE.  SUBROUTINE IS                   *
*        SERIALLY RE-USABLE, BUT IS NOT RE-ENTRANT.                   *
***********************************************************************
         AGO   .ENDPROL
.USESAVE ANOP
***********************************************************************
*        SAVE AREA SUPPLIED BY USER.  SUBROUTINE IS                   *
*        SERIALLY RE-USABLE, BUT IS NOT RE-ENTRANT.                   *
***********************************************************************
         AGO   .ENDPROL
.NOSAVE  ANOP
***********************************************************************
*        NO SAVE AREA GENERATED.  USER BEWARE                         *
*        IF CALLING LOWER LEVEL ROUTINES.                             *
***********************************************************************
         AGO   .ENDPROL
.**********************************************************************
.*                                                                    *
.*       GETMAIN FOR SAVE AREA                                        *
.*                                                                    *
.**********************************************************************
.GETMAIN ANOP
&NLE4095 SETB  (&SLE4095)
&SGBYTES SETC  '&SBYTES'      SET GLOBAL LENGTH FOR FREEMAIN
         AIF   (&NLE4095).LAR0
         CNOP  0,4 !           ALIGN PARAMETER LIST
         BAL   1,*+8 !         BRANCH AROUND LENGTH
         DC    A(&SBYTES) !       SAVE AREA LENGTH
         L     0,0(1,0) !      LOAD SAVE AREA LENGTH INTO REGISTER 0
         AGO   .GLOK
.LAR0    LA    0,&SBYTES.(0,0) !     LOAD SAVE AREA LENGTH INTO REG 0
         BAL   1,*+4 !         INDICATE GETMAIN
.GLOK    AIF   ('&SAVE(1)' NE 'DSA').PLILOK
         LR    2,0 !           SAVE LENGTH IN REGISTER 2
.PLILOK  ANOP
         SVC   10 !            ISSUE GETMAIN SVC
*                              ADDRESS OF GETMAIN AREA IS
*                              RETURNED IN REGISTER 1
         AIF   ('&FORECHN' EQ 'NO').NOFOREG
         ST    13,4(1) !       PUT ADDRESS OF CALLER'S SAVE AREA IN
*                              WORD 2 OF THIS PROGRAM'S SAVE AREA
.NOFOREG ANOP
         AIF   ('&SAVE(3)' EQ 'NOMARK').NOMARK
         MVI   4(1),C'G' !     MARK SAVE AREA AS OBTAINED BY A GETMAIN
.NOMARK  ANOP
         AIF   ('&SAVE(1)' NE 'DSA').PLIWOK
         ST    2,0(0,1) !      STORE LENGTH OF DSA INTO PL/I WORD
         MVI   0(1),&PLIFLAG !    MOVE PL/I FLAG BITS INTO PL/I WORD
         S     2,*+12 !        GET HARDWARE LENGTH OF DSA FROM BYTE 73
         EX    2,*+10 !        CLEAR OUT DSA FROM BYTE 73 ON
         B     *+12 !          BRANCH AROUND CONSTANT AND CLEAR INSTR
         DC    H'73'
         XC    72(0,1),0(1) !  CLEAR OUT DSA FROM BYT 73 ON
.PLIWOK  ANOP
         AIF   ('&BACKCHN' NE 'YES').NOBACKG
         ST    1,8(13) !       BACK CHAIN. PUT ADDRESS OF SAVE AREA FOR
*                              THIS PROGRAM INTO WORD 3 OF CALLER'S
*                              SAVE AREA
         LM    14,2,12(13) !   RESTORE REGISTERS 14 THROUGH 1, WHICH
*                              MAY BE DESTROYED BY AN SVC, AND 2
         L     13,8(13) !      LOAD REGISTER 13 WITH SAVE AREA ADDRESS
         AGO   .ENDGET
.NOBACKG ANOP
******** USER MUST EITHER FREE SAVE AREA HIMSELF OR BACK CHAIN BEFORE
******** ALLOWING EPILOGUE WITH SAVE=FREEMAIN TO FREE THE SAVE AREA
         LR    14,13 !         SAVE CALLER'S SAVE AREA ADDRESS IN R14
         LR    13,1 !          LOAD REGISTER 13 WITH SAVE AREA ADDRESS
         LM    14,1,12(14) !   RESTORE REGISTERS 14 TO 1 WHICH MAY BE
*                              DESTROYED BY GETMAIN, FROM SAVE AREA
.ENDGET  ANOP
***********************************************************************
*        SAVE AREA OBTAINED WITH GETMAIN.  IF SUBROUTINE              *
*        IS RE-ENTRANT, THEN IT IS ALSO RECURSIVE.                    *
***********************************************************************
.*
.*
.**********************************************************************
.*                                                                    *
.*       GENERATE WARNING ERROR MESSAGES                              *
.*                                                                    *
.**********************************************************************
.ENDPROL ANOP
         AIF   ('&TRACE' EQ 'YES' OR '&TRACE' EQ 'NO').TROK
         MNOTE *,'ERROR IN TRACE PARAMETER.  TRACE=YES ASSUMED.'
.TROK    ANOP
 AIF ('&OUTPUT'EQ'PUT' OR '&OUTPUT'EQ'WTO' OR '&OUTPUT'EQ'BOTH').OUTOK
         MNOTE *,'ERROR IN OUTPUT PARAMETER.  OUTPUT=BOTH ASSUMED.'
.OUTOK   ANOP
         AIF   ('&FORECHN' EQ 'YES' OR '&FORECHN' EQ 'NO').FCOK
         MNOTE *,'ERROR IN FORECHN PARAMETER.  FORECHN=NO ASSUMED.'
.FCOK    ANOP
         AIF   ('&BACKCHN' EQ 'YES' OR '&BACKCHN' EQ 'NO').BCOK
         MNOTE *,'ERROR IN BACKCHN PARAMETER.  BACKCHN=NO ASSUMED.'
.BCOK    ANOP
         AIF   ('&SAVE(1)' NE 'GETMAIN').NOGET
         AIF   ('&SAVE(3)' EQ '' OR '&SAVE(3)' EQ 'NOMARK').SMOK
         MNOTE *,'ERROR IN THIRD SAVE SUB-PARAMETER.  MARK ASSUMED.'
.SMOK    ANOP
.NOGET   ANOP
         EJECT
         MEND
