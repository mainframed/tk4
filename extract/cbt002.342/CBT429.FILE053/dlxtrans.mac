         TITLE 'DELUXE DATASET TRANSFER PROGRAM -- DLXTRANS'
DLXTRANS CSECT
**********************************************************************
*PROGRAM NAME:  DATA TRANSFER PROGRAM
*JOB ACCOUNT CODE: GDA1
**********************************************************************
*RUN INSTRUCTIONS:                                            10/13/82
*
*** OPTION 1  CREATE 80-BYTE RECORDS FOR TRANSMISSION
*
*FILES:
*SYSUT1  = INPUT FILE
*
*SYSPUNCH = 80-BYTE OUTPUT
*
*JCLIN = (OPTIONAL, SEE PARM INFO) JCL TO RECONSTRUCT THE FILE
*
*ENDJCLIN = (OPTIONAL, USED ONLY WHEN JCLIN IS PRESENT)
*           JCL TO EXECUTE WITH RECONSTRUCTED FILE
*
*
*PARM INFO:
*  PARM='NOJCL' -  NO JCL FILE INCLUDED
*           USING 'NOJCL' IMPLIES THAT DATA IS BEING SENT TO SERIES/1
*  PARM='DLM=XX' - JCL FILE IS INCLUDED, DELIMITER AS SPECIFIED
*
*
***** OPTION 2  REFORMAT 80-BYTE RECORDS TO ORIGINAL FILE
*
*FILES:
*SYSIN - 80-BYTE RECORDS (OUTPUT FROM OPTION 1)
*
*SYSUT2 - REFORMATTED FILE
*
*
*PARM INFO:  NONE.
*
******************************************************************
* PURPOSE: 10/13/82
*   TO REFORMAT ANY FILE TO 80 BYTE RECORDS FOR
*   TRANSMISSION AND TO RECONSTRUCT THE ORIGINAL FILE
*   AFTER TRANSMISSION.
*
* SOURCE OF INFORMATION:
*   ANY FILE EXCEPT RECFM=U AND PDS'S.
*   TO TRANSMIT A PDS, USE IEBCOPY TO CREATE A SEQUENTIAL FILE,
*   SEND THAT, AND RECREATE THE PDS AFTER TRANSMISSION.
*
* NOTES:
*      IF SYSUT2 JCL SPECIFIES AN LRECL DIFFERENT FROM THE
*      ORIGINAL FILE, THE PROGRAM WILL ISSUE AN ERROR MESSAGE
*      AND STOP.
*
************************************************************
*
* PROGRAM FLOW:
*   PARM AND DD INFORMATION IS ANALYZED AND CHECKED FOR CONSISTENCY.
*
*   IF SENDING (BUILDING 80-BYTE RECORDS):
*     OPEN SYSPUNCH
*     IF JCLIN PRESENT
*       OPEN JCLIN FILE, READ AND WRITE IT TO SYSPUNCH, CLOSE FILE,
*         AND CREATE '//SYSIN DD DATA,DLM=' RECORD ON SYSPUNCH.
*     DETERMINE DCB INFO FROM DSCB OR JCL
*     BUILD AND WRITE HEADER RECORD FROM DCB INFO AND DATASET NAME.
*     OPEN SYSUT1
*     READ SYSUT1 AND REFORMAT TO 80-BYTE RECORDS ON SYSUT1
*     AT END  MOVE '$$EOF' PATTERN TO FILL OUT FINAL RECORD.
*     IF JCL WAS INCLUDED, WRITE DELIMITER RECORD.
*     IF ENDJCLIN WAS INCLUDED, OPEN THAT FILE, READ AND WRITE EACH
*       RECORD IN IT, AND CLOSE IT.
*     CLOSE SYSUT1, SYSPUNCH.
*     END.
*
*   IF RECEIVING  (80-BYTE RECORDS INPUT):
*     OPEN SYSIN
*     READ HEADER RECORD TO GET OUTPUT DCB INFO.
*     READ JCL FOR OUTPUT INFO.
*     IF NO BLOCKSIZE GIVEN, FORCE MAX SIZE FOR TAPE, BLOCK 1 FOR DISK.
*     OPEN SYSUT2
*     READ SYSIN AND REFORMAT TO SYSUT2 SPECS
*     CHECK FOR END OF FILE PATTERN
*     CLOSE SYSUT2, SYSIN.
*     END.
*
*********************************************************************
*  ERROR MESSAGES:
*    'DLX001E  DLXTRANS -- SYSPUNCH DD CARD MISSING OR MISPELLED AND
*     SYSUT1 DD CARD PRESENT'                  RETURN CODE 16
*
*    'DLX002E  DLXTRANS -- JCLIN DD CARD MISSING OR MISPELLED AND
*     NOJCL PARM NOT SPECIFIED'                RETURN CODE 16
*
*    'DLX003I  DLXTRANS -- SYSUT1 DD CARD PRESENT AND NOT NEEDED'
*
*    'DLX004I  DLXTRANS -- SYSUT2 DD CARD PRESENT AND NOT NEEDED'
*
*    'DLX005I  DLXTRANS -- SYSIN DD CARD PRESENT AND NOT NEEDED'
*
*    'DLX006I  DLXTRANS -- JCLIN DD CARD PRESENT AND NOT NEEDED'
*
*    'DLX007I  DLXTRANS -- SYSPUNCH DD CARD PRESENT AND NOT NEEDED'
*
*    'DLX008E  DLXTRANS -- NEITHER SYSUT1 OR SYSUT2 DD CARDS ARE
*     PRESENT. ONE IS REQUIRED'                RETURN CODE 16
*
*    'DLX009E  DLXTRANS -- SYSIN DD CARD MISSING OR MISPELLED AND
*     SYSUT2 DD CARD PRESENT'                  RETURN CODE 16
*
*    'DLX010E  DLXTRANS -- LRECL FROM INPUT FILE DOES NOT MATCH
*     LRECL SPECIFIED FOR OUTPUT'              RETURN CODE 16
*
*    'DLX011E  DLXTRANS -- SYSUT1 FOR A RECEIVE OPERATION CANNOT
*     BE A NEW DATASET'                        RETURN CODE 16
*
*    'DLX012I  DLXTRANS -- SYSUT1 DATASET NAME HAS NO THIRD
*     QUALIFIER - "DUMMYFIL" SUBSTITUTED'      RETURN CODE 4
*
*    'DLX013E  DLXTRANS -- DELIMITER (DLM=) MUST BE SPECIFIED
*     WHEN JCL IS TRANSMITTED'                 RETURN CODE 16
*
*    'DLX014W  DLXTRANS -- RECFM TAKEN FROM HEADER RECORD - JCL
*     NOT USED'                                RETURN CODE 4
*
*    'DLX015E  DLXTRANS -- RECFM = U CANNOT BE PROCESSED -
*     PROGRAM TERMINATED'                      RETURN CODE 16
*
*    'DLX016E  DLXTRANS -- DELIMITER CHARACTERS HAVE OCCURRED
*     IN THE DATA -----
*     TRANSMITTED FILE IS INCOMPLETE. DELETE FILE & RERUN WITH
*     NEW DELIMITER'                           RETURN CODE 16
*
*    'DLX017I  DLXTRANS -- ENDJCLIN DD CARD PRESENT BUT CAN NOT
*     BE USED - IGNORED'
*
********************************************************************
* REVISION HISTORY:
*  10/13/82    NEW PROGRAM            NKH
*
*  01/14/83    ADDED CHECK FOR  SYSOUT SO THAT SYSUT2 CAN BE USED
*                   FOR PRINTOUTS
*              ADDED CHECK FOR DELIMITER OCCURRING WITHIN DATA
*              ADDED CAPABILITY FOR SECOND SYSIN  - ENDJCLIN
*
***********************************************************************
*
         SAVE  (14,12),,DLXTRANS_DELUXE_CHECK_&SYSDATE_&SYSTIME
         LR    R12,R15                  ESTABLISH R12 AS BASE REG
         USING DLXTRANS,R12,R11         TELL ASSEMBLER
         LA    R11,4095(R12)            R11 SECONDARY BASE
         LA    R11,1(R11)               4096 PLUS R12
         ST    R13,SAVEAREA+4           SAVE OS SAVE AREA ADDRESS
         LR    R6,R13                   SAVE IT IN R6
         LA    R13,SAVEAREA             POINT R13 AT OUR SAVE AREA
         ST    R13,8(R6)                STORE OUR SAVEAREA ADDR IN OS
* END OF PROLOGUE                       SAVE AREA
***********************************************************************
**********   GET PARMS, ANALYZE, SET JCL SWITCH IF NEEDED   ***********
***********************************************************************
GETPARM1 EQU   *                        GET PARM FIELD
         L     R2,0(R1)                 ADDRESS OF PARM TO R2
         LH    R3,0(R2)                 LENGTH OF PARM TO R3
         LTR   R3,R3                    CHECK FOR NO PARM
         BZ    PARMEXIT                 ALL DONE WITH PARMS
         LA    R3,1(R3)                 DECREMENT FOR EXECUTE
         EX    R3,MOVEPARM              EXECUTE MOVE
         LH    R3,PARMLNGT              RELOAD LENGTH
         LA    R2,PARMFLDS              ADDRESS OF FIRST BYTE OF PARMS
         LA    R4,PARMANAL              ADDRESS OF PARM WORKAREA
GETPARM2 EQU   *
         CLI   0(R2),C','               DELIMITING COMMA?
         BE    ANALYZEP                 IF SO GO ANALYZE PREVIOUS PARM
         BCT   R3,GETPARM3              IF MORE PARM INFO KEEP GOING
         MVI   MOREPARM,C'N'            SET LASTPARM SWITCH
         MVC   0(1,R4),0(R2)            MOVE LAST BYTE OF PARM INFO OUT
         B     ANALYZEP                 GO ANALYZE THE PARM INFO
GETPARM3 EQU   *
         MVC   0(1,R4),0(R2)            MOVE A BYTE OF PARM INFO TO
*                                       TEST AREA
         LA    R4,1(R4)                 POINT TO NEXT SLOT IN TEST AREA
         LA    R2,1(R2)                 POINT TO NEXT CHARACTER IN THE
*                                       PARM FIELD
         B     GETPARM2                 GO BACK AND DO IT AGAIN
ANALYZEP EQU   *                        ANALYZE THE PARM WE HAVE FOUND
         CLC   PARMANAL(5),=C'NOJCL'    IS NOJCL SPECIFIED?
         BE    GOTPARM1
         CLC   PARMANAL(4),=C'DLM='     IS DLM= SPECIFIED?
         BE    GOTPARM2
         B     NEXTPARM
GOTPARM1 EQU   *                        NOJCL WAS SPECIFIED
         MVI   JCLSW,C'0'               SET JCL SWITCH TO NO
         B     NEXTPARM
GOTPARM2 EQU   *                        DLM= WAS SPECIFIED
         MVC   JCLDLM(2),PARMANAL+4     MOVE DLM TO JCLDLM FIELD
         B     NEXTPARM
NEXTPARM EQU   *                        CHECK AND SET IF NECESSARY
*                                       FOR MORE PARM PROCESSING
         LA    R4,PARMANAL              RESET R4
         MVI   PARMANAL,X'40'
         MVC   PARMANAL+1(19),PARMANAL
         CLI   MOREPARM,C'N'            IS THIS THE LAST PARM?
         BE    PARMEXIT
         LA    R2,1(R2)                 BUMP PAST COMMA
         B     GETPARM2
PARMEXIT EQU   *
***********************************************************************
**********   FIND DDNAMES THAT ARE PRESENT                  ***********
***********************************************************************
         SLR   R3,R3                    CLEAR R3
         L     R2,16                    ADDRESS OF CVT
         L     R2,0(R2)                 ADDRESS OF TCB ADDRESS WORDS
         L     R2,4(R2)                 ADDRESS OF CURRENT TCB
         L     R2,12(R2)                ADDRESS OF THIS TCBS TIOT
         LA    R2,24(R2)                ADDRESS OF START OF DD ENTRY
         IC    R3,0(R2)                 LENGTH OF THIS ENTRY
FINDDD1  EQU   *
         LTR   R3,R3
         BZ    DONEDD
         CLC   4(8,R2),=CL8'SYSIN'      IS IT SYSIN?
         BE    GOTSYSIN
         CLC   4(8,R2),=CL8'SYSUT1'     IS IT SYSUT1?
         BE    GOTUT1
         CLC   4(8,R2),=CL8'SYSUT2'     IS IT SYSUT2?
         BE    GOTUT2
         CLC   4(8,R2),=CL8'JCLIN'      IS IT JCLIN?
         BE    GOTJCLIN
         CLC   4(8,R2),=CL8'ENDJCLIN'   IS IT ENDJCLIN?
         BE    GOTENDJ
         CLC   4(8,R2),=CL8'SYSPUNCH'   IS IT SYSPUNCH?
         BE    GOTPUNCH
         B     NEXTDD                   DONT KNOW WHY BUT TRY AGAIN
GOTSYSIN EQU   *
         MVI   SYSINSW,C'1'             SET SYSIN DD PRESENT
         B     NEXTDD
GOTUT1   EQU   *
         MVI   UT1SW,C'1'               SET SYSUT1 DD PRESENT
         B     NEXTDD
GOTUT2   EQU   *
         MVI   UT2SW,C'1'               SET SYSUT2 DD PRESENT
         B     NEXTDD
GOTJCLIN EQU   *
         MVI   JCLINSW,C'1'             SET JCLIN DD PRESENT
         B     NEXTDD
GOTENDJ  EQU   *
         MVI   ENDJSW,C'1'              SET ENDJCLIN DD PRESENT
         B     NEXTDD
GOTPUNCH EQU   *
         MVI   PUNCHSW,C'1'             SET PUNCH DD PRESENT
         B     NEXTDD
NEXTDD   EQU   *
         AR    R2,R3                    BUMP TO NEXT DD ENTRY
         IC    R3,0(R2)                 GET LENGTH OF ENTRY
         B     FINDDD1                  LOOP
DONEDD   EQU   *
***********************************************************************
*****    AT THIS POINT WE KNOW (OR CAN DECIDE) BASED ON COLLECTED
*****    INFORMATION WHETHER THIS IS A REBLOCK OR DEBLOCK RUN AND
*****    WHETHER THE OUTPUT OF A DEBLOCK RUN GOES TO A 370 OR A
*****    SERIES/1 MACHINE.  NOW VALIDATE THAT ALL FILES NEEDED
*****    ARE PRESENT.
***********************************************************************
*BEGIN VALIDATION
*
         CLI   UT1SW,C'0'               ARE WE SENDING?
         BE    VALIDAT3                 NO
         CLI   PUNCHSW,C'0'             IS OUTPUT FILE FOR SEND THERE?
         BE    ERROR01                  NO GO PRODUCE MESSAGE AND QUIT
*                                PARM=NOJCL IMPLIES SERIES/1
         CLI   JCLSW,C'1'               CHECK FOR SERIES/1 OR 370
         BNE   VALIDAT1                 FOR SERIES/1 DO NOT CHECK JCL
         CLI   JCLINSW,C'0'             IF JCLIN FILE THERE?
         BE    ERROR02                  NO GO PRODUCE MESSAGE AND QUIT
         B     VALIDAT2
***********************************************************************
****           WE HAVE ENOUGH DD'S TO SEND BUT PRODUCE AN
****           INFORMATIONAL ERROR MESSAGE FOR UNUSED DD CARDS
***********************************************************************
VALIDAT1 EQU   *                          JCLIN NOT USED FOR S/1
         CLI   JCLINSW,C'0'             IS JCLIN FILE THERE?
         BE    VALIDAT2                 NO, CONTINUE
         BAL   R9,ERROR06               INFORM USER
VALIDAT2 EQU   *
         CLI   SYSINSW,C'0'             IS SYSIN FILE THERE?
         BE    *+8                      NO, CONTINUE
         BAL   R9,ERROR05               INFORM USER
         B     VALIDATX                 DONE VALIDATION
VALIDAT3 EQU   *
         CLI   UT2SW,C'0'               SYSUT2 MUST BE SPECIFIED
         BE    ERROR08                  IF NOT, QUIT
         CLI   SYSINSW,C'0'             SYSIN MUST BE SPECIFIED
         BE    ERROR09                  IF NOT, QUIT
***********************************************************************
****           WE HAVE ENOUGH DD'S TO RECEIVE BUT PRODUCE AN
****           INFORMATIONAL ERROR MESSAGE FOR UNUSED DD CARDS
***********************************************************************
         CLI   UT1SW,C'0'               IS SYSUT1 FILE THERE?
         BE    *+8                      NO, CONTINUE
         BAL   R9,ERROR03               INFORM USER
         CLI   JCLINSW,C'0'             IS JCLIN FILE THERE?
         BE    *+8                      NO, CONTINUE
         BAL   R9,ERROR06               INFORM USER
         CLI   ENDJSW,C'0'              IS ENDJCLIN FILE THERE?
         BE    *+8                      NO, CONTINUE
         BAL   R9,ERROR17               INFORM USER
         CLI   PUNCHSW,C'0'             IS SYSPUNCH FILE THERE?
         BE    *+8                      NO, CONTINUE
         BAL   R9,ERROR07               INFORM USER
VALIDATX EQU   *                        END VALIDATION
*
***********************************************************************
*  AT THIS POINT EVERYTHING THAT IS GOING TO BE VALIDATED IS.
*  THE NEXT SECTION OF CODE SETS UP DATASET CHARACTERISTICS WHERE
*  NECESSARY AND OPENS THE REQUIRED DATASETS.
***********************************************************************
         CLI   SYSINSW,C'0'             IF SYSIN IS PRESENT
         BE    OPENSND1                 CONTINUE, ELSE GO SEND
***********************************************************************
*******     RECEIVE  -  SYSIN (80'S)  AND  SYSUT2 OUT       ***********
***********************************************************************
*  DETERMINE IF SYSIN IS REALLY SYSIN DATA OR A CATALOGUED DATASET
         LA    R8,JFCBAREA              ADDRESS OF WORK AREA TO R8
         USING JFCB,R8                  TELL ASSEMBLER
         LA    R7,SYSIN                 ADDRESS OF DCB TO R7
         USING IHADCB,R7                TELL ASSEMBLER
         RDJFCB (SYSIN)
         TM    JFCBTSDM,JFCSDS          CHECK FOR SYSIN/SYSOUT
         BNO   OPENRCV1                 IF NOT, CONTINUE
         MVC   DCBBLKSI(2),DCBLRECL     DEFAULT 80-80 LRECL-BLKSIZE
OPENRCV1 EQU   *
         OPEN  (SYSIN)
         LA    R6,RECAREA               ADDRESS OF INPUT RECORD
         USING HDR,R6                   TELL ASSEMBLER
         GET   SYSIN,RECAREA            GET FIRST RECORD
         MVC   UT1RECFM,HDRRECFM        MOVE
         MVC   UT1DSORG,HDRDSRG1          ALL
         MVC   UT1LRECL,HDRLRECL            DATASET CHARACTERISTICS
         MVC   UT1BLKSI,HDRBLKSZ              TO HOLD AREA FOR INPUT
         DROP  R6
         MVI   RECAREA,X'40'            CLEAR INPUT
         MVC   RECAREA+1(79),RECAREA        AREA
***********************************************************************
*        BEGIN TO PROCESS THE OUTPUT DATASET (OPEN)
***********************************************************************
         MVI   JFCBAREA,X'00'           CLEAR
         MVC   JFCBAREA+1(L'JFCBAREA-1),JFCBAREA ALL WORK AREAS
         LA    R7,SYSUT2                AND PREPARE TO PROCESS
         RDJFCB (SYSUT2)
         TM     JFCBIND2,JFCNEW         CHECK IF NEW DATASET
         BO     OPENRCV2                BYPASS OBTAIN
         TM     JFCBTSDM,JFCSDS         IF 'OLD' DATASET IS SYSOUT
         BO     OPENRCV2                BYPASS OBTAIN
         CLC    JFCBFLSQ,=X'0000'       WILL BE NONZERO IF TAPE
         BNE    OPENRCV2                BYPASS OBTAIN
*
*        DO OBTAIN FOR FORMAT1 DSCB FOR OLD OUTPUT DISK DATASET
*
         LA    R6,DSCB1WRK              ADDRESS OF WORK AREA
         USING DS1FMTID,R6              TELL ASSEMBLER
         MVI    CAMLDSNM,X'40'          CLEAR
         MVC    CAMLDSNM+1(L'CAMLDSNM-1),CAMLDSNM
         MVC    CAMLDSNM,JFCBDSNM       AND LOAD
         MVI    CAMLVOLS,X'40'          DATASET NAME
         MVC    CAMLVOLS+1(L'CAMLVOLS-1),CAMLVOLS
         MVC    CAMLVOLS(6),JFCBVOLS    AND VOLUME SERIAL
         OBTAIN DSCBLIST                GET DSCB FORMAT 1
         MVC    UT2DSORG,DS1DSORG
         MVC    UT2RECFM,DS1RECFM
         MVC    UT2LRECL,DS1LRECL
         MVC    UT2BLKSI,DS1BLKL
         DROP   R6
         B      OPENRCV3
OPENRCV2 EQU    *
         MVC   UT2DSORG,JFCDSRG1        BUILD UT2 INFO FROM JCL
         MVC   UT2RECFM,JFCRECFM
         MVC   UT2LRECL,JFCLRECL
         MVC   UT2BLKSI,JFCBLKSI
OPENRCV3 EQU   *
************* ( CAN'T PROCESS RECFM=U YET, SO CHECK FOR IT )
         TM    UT1RECFM,DCBRECU         TEST FOR RECFM=U
         BO    ERROR15                  YES, WRITE MSG AND QUIT
         TM    UT1RECFM,DCBRECV         TEST FOR VARIABLE
         BO    OPENRCV5                 IF SO GO PROCESS
         CLC   JFCBFLSQ,=X'0000'         TAPE?
         BE   OPNRCVD1                 IF NOT, GO TO DISK PROCESS
*
*****************   PROCESS  TAPE  ***********************************
OPNRCVT1 EQU   *
         MVC   DCBLRECL(2),UT1LRECL   MOVE HDR LRECL TO DCB
         CLC   UT2BLKSI,=X'0000'      IF OUTPUT BLKSIZE NOT 0
         BNE   OPNRCVT3                 BRANCH
OPNRCVT2 EQU   *                    *****  COMPUTE BLKSIZE
         SLR   R8,R8                  ELSE
         SLR   R9,R9                   CLEAR REGISTERS
         SLR   R5,R5                    AND COMPUTE
         A     R9,=F'32760'            MAX BLOCK SIZE
         LH    R5,DCBLRECL
         DR    R8,R5
         MR    R8,R5
         STH   R9,DCBBLKSI
         B     OPENRCV4
OPNRCVT3 EQU   *                    **** CHECK GIVEN BLKSIZE
         SLR   R5,R5
         SLR   R8,R8
         SLR   R9,R9
         A     R9,=F'32760'
         LH    R8,UT2BLKSI
         LH    R5,DCBLRECL
         SR    R9,R8                  MAX BLKSIZE MINUS GIVEN BLKSIZE
         CR    R9,R5                  IF > LRECL GO BACK AND CALCULATE
         BNL   OPNRCVT2               LARGER BLOCK
         B     OPENRCV4
*
*****************   PROCESS  DISK  ***********************************
OPNRCVD1 EQU   *
         CLC   UT2LRECL,UT1LRECL        LRECL NOT SPECIFIED?
         BNE   ERROR10
         MVC   DCBLRECL(2),UT2LRECL     MOVE LRECL TO DCB
         CLC   UT2BLKSI,=X'0000'       IF BLOCK = 0
         BNE   *+14
         MVC   DCBBLKSI(2),UT2LRECL    FORCE BLOCK 1
         B     OPENRCV4
         MVC   DCBBLKSI(2),UT2BLKSI    ELSE USE GIVEN BLKSIZE
*
OPENRCV4 MVI   DCBDSRG1,DCBDSGPS        DSORG=PS
         MVC   DCBRECFM(1),UT2RECFM     SET RECFM TO UT2RECFM
         B     OPENUT2                  GO OPEN
*
**********************************************************************
************        VARIABLE FORMAT SYSUT2                 ***********
**********************************************************************
OPENRCV5 EQU   *
         MVC   DCBLRECL(2),UT2LRECL     IF OUTPUT BLKSIZE=0
         CLC   UT2BLKSI,=X'0000'
         BNE   *+20                     FORCE TO BLOCK 1
         LH    R3,UT2LRECL              GET MAX LRECL
         LA    R3,4(R3)                 BUMP BY 4 FOR BDW
         STH   R3,DCBBLKSI              STORE IN DCB
         B     *+10
         MVC   DCBBLKSI(2),UT2BLKSI     ELSE MOVE UT2BLKSI TO DCB
*
         MVC   DCBRECFM(1),UT2RECFM     SET RECFM TO PREV SPEC
         TM    UT1RECFM,DCBRECSB        CHECK HEADER
         BNO   OPENRCV6                 BRANCH IF NOT S
         CLC   UT1RECFM,UT2RECFM        IF S, BUT HDR = JCL,
         BE    OPENRCV6                  BRANCH ANYWAY
*
         CLC   UT2RECFM,=X'00'          IF JCL DCB NOT GIVEN
         BE    *+8                       SKIP MESSAGE
*
         BAL   R9,ERROR14
         MVC   DCBRECFM(1),UT1RECFM      CHANGE RECFM TO = HEADER
         MVC   DCBBLKSI(2),UT1BLKSI      CHANGE BLOCKING TO MATCH
*
OPENRCV6 TM    DCBRECFM,DCBRECV+DCBRECBR+DCBRECSB
*        IF RECFM=VBS THEN CHANGE BFTEK TO A
         BNO   *+8
         OI    DCBBFTEK,DCBBFTA         BFTEK=A
         MVI   DCBDSRG1,DCBDSGPS        DSORG=PS
         B     OPENUT2V                 GO OPEN
*                                 ****************************
*                                  * R3 - OUTPUT  POINTER
*                                  * R5 - INPUT POINTER
*                                  * R6 - REMAINING OUTPUT LENGTH
*                                  * R7 - INPUT LRECL
*                                  * R9 - MISC. CONSTANTS
*                                 ****************************
*
OPENUT2V EQU   *
         MVC   UT2BLKSI,DCBBLKSI
         MVC   UT2RECFM,DCBRECFM
         MVC   UT2DSORG,DCBDSRG1
         XC    DCBMACR(2),DCBMACR       CLEAR MACRF= AND
         MVI   DCBMACR2,DCBMRPUT+DCBMRLCP  SET IT TO MACRF=(PL)
         OPEN  (SYSUT2,(OUTPUT))
         PUT   SYSUT2
         ST    R1,UT2AREA
RCVPS1V  EQU   *
         L     R3,UT2AREA               OUTPUT RECORD START ADDRESS
RCVPS2V  EQU   *
         MVI   RECAREA,X'40'            CLEAR RECORD AREA
         MVC   RECAREA+1(79),RECAREA
         GET   SYSIN,RECAREA            GET A RECORD
         LA    R5,RECAREA               ADDRESS OF INPUT RECORD START
         MVC   SAVLRECL(2),RECAREA      SAVE FIRST 2 BYTES OF RECAREA
         LH    R6,SAVLRECL              R6 = CURRENT LRECL - OUT
         LA    R7,80                    R7 = INPUT LRECL
         CR    R6,R7                    IF OUTPUT LRECL < 80
         BL    RCVPS4V                    BRANCH
RCVPS3V  EQU   *
         BCTR  R7,R0
         EX    R7,MOVEREC1           MOVE SYSIN (ALL OR WHAT IS LEFT)
         LA    R8,1(R7)              SAVE 'HOW MUCH WAS JUST MOVED'
         LA    R3,0(R8,R3)           AND BUMP R3 BY THAT MUCH
*
         MVI   RECAREA,X'40'            CLEAR RECORD AREA
         MVC   RECAREA+1(79),RECAREA
         GET   SYSIN,RECAREA            GET A RECORD
         LA    R5,RECAREA               ADDRESS OF INPUT RECORD START
         LA    R7,80                    INPUT LRECL
*
         SR    R6,R8               SET R6 = HOW MUCH IS LEFT IN OUTPUT
         CR    R7,R6               IF ROOM FOR ANOTHER WHOLE SYSIN,
         BH    RCVPS4V
         B     RCVPS3V               GO BACK AND GET ANOTHER
*
RCVPS4V  EQU   *
         LTR   R6,R6               SKIP FOLLOWING MOVE IF  R6=0
         BZ    RCVPS5V             (SYSUT2 AND SYSIN RECORDS HAVE
*                                   ENDED TOGTHER)
         BCTR  R6,R0
         EX    R6,MOVEREC1         MOVE AS MUCH AS THERE IS ROOM FOR
         LA    R6,1(R6)            PUT R6 COUNTER BACK
         L     R1,UT2AREA          PUT R1 BACK
         LA    R5,0(R6,R5)         BUMP R5 - HOW FAR INTO SYSIN
*
RCVPS5V  EQU   *
         PUT   SYSUT2                 WRITE SYSUT2
         ST    R1,UT2AREA
         L     R3,UT2AREA
         SR    R7,R6                  HOW MUCH SYSIN IS LEFT?
         LA    R9,1
         CR    R7,R9                  CHECK FOR ONLY ONE BYTE LEFT
         BNE   RCVPS6V                   IF NOT, SKIP
*
         MVC   SAVLRECL(1),0(R5)     SAVE THE ONE REMAINING BYTE
         MVI   RECAREA,X'40'          CLEAR RECAREA
         MVC   RECAREA+1(79),RECAREA
         GET   SYSIN,RECAREA          AND GET NEXT SYSIN
         LA    R5,RECAREA
         MVC   SAVLRECL+1(1),RECAREA  COMPLETE SAVED LRECL
         LA    R5,1(R5)               BUMP R5 - SYSIN
         MVC   0(R9,R3),SAVLRECL      MOVE SAVED LRECL TO OUTPUT
         LA    R9,2
         LH    R6,SAVLRECL
         SR    R6,R9                  ADJUST SAVLRECL SO THAT R6
         STH   R6,SAVLRECL              COMES OUT RIGHT LATER
         LA    R3,2(R3)               BUMP R3 BY 2
         LA    R7,79                  SET LENGTH OF REMAINING SYSIN
         B     RCVPS7V
*
RCVPS6V  EQU   *
         MVC   SAVLRECL(2),0(R5)      SAVE LRECL OF NEXT RECORD
RCVPS7V  EQU   *
         CLC   SAVLRECL(1),=C'$'
         BE    ENDSYSIN
         LH    R6,SAVLRECL            RE-INITIALIZE R6
         CR    R6,R7               COMPARE WHAT IS LEFT IN SYSIN TO
         BL    RCVPS4V               OUTPUT LRECL
         B     RCVPS3V
********************************************************************
***         PROCESS FIXED LENGTH SYSUT2
********************************************************************
*                                  * REG3 - OUTPUT  POINTER
*                                  * REG4 - OUTPUT LRECL
*                                  * REG5 - INPUT POINTER
*                                  * REG6 - REMAINING OUTPUT LENGTH
*                                  * REG7 - INPUT LRECL
*                                  * REG9 - MISC. CONSTANTS
*
OPENUT2  EQU   *
         MVC   UT2BLKSI,DCBBLKSI
         MVC   UT2RECFM,DCBRECFM
         MVC   UT2DSORG,DCBDSRG1
         XC    DCBMACR(2),DCBMACR       CLEAR MACRF= AND
         MVI   DCBMACR2,DCBMRPUT+DCBMRLCP  SET IT TO MACRF=(PL)
         OPEN  (SYSUT2,(OUTPUT))
         PUT   SYSUT2
         ST    R1,UT2AREA
RCVPS1   EQU   *
         L     R3,UT2AREA               OUTPUT RECORD START ADDRESS
         LH    R4,UT2LRECL              OUTPUT RECORD LENGTH
         LR    R6,R4                    R6 = LRECL
RCVPS2   EQU   *
         MVI   RECAREA,X'40'            CLEAR RECORD AREA
         MVC   RECAREA+1(79),RECAREA
         GET   SYSIN,RECAREA            GET A RECORD
         LA    R5,RECAREA               ADDRESS OF INPUT RECORD START
         LA    R7,80                    INPUT LRECL
         CR    R4,R7                    IF OUTPUT LRECL < 80
         BL    RCVPS4                     BRANCH
RCVPS3   EQU   *
         BCTR  R7,R0
         EX    R7,MOVEREC1           MOVE SYSIN (ALL OR WHAT IS LEFT)
         LA    R8,1(R7)              SAVE 'HOW MUCH WAS JUST MOVED'
         LA    R3,0(R8,R3)           AND BUMP R3 BY THAT MUCH
*
         MVI   RECAREA,X'40'            CLEAR RECORD AREA
         MVC   RECAREA+1(79),RECAREA
         GET   SYSIN,RECAREA            GET A RECORD
         LA    R5,RECAREA               ADDRESS OF INPUT RECORD START
SPECIAL  LA    R7,80                    INPUT LRECL
*
         SR    R6,R8               SET R6 = HOW MUCH IS LEFT IN OUTPUT
         CR    R7,R6               IF ROOM FOR ANOTHER WHOLE SYSIN,
         BH    RCVPS4
         B     RCVPS3                GO BACK AND GET ANOTHER
*
RCVPS4   EQU   *
         LTR   R6,R6               SKIP FOLLOWING MOVE IF  R6=0
         BZ    RCVPS5              (SYSUT2 AND SYSIN RECORDS HAVE
*                                   ENDED TOGTHER)
         BCTR  R6,R0
         EX    R6,MOVEREC1         MOVE AS MUCH AS THERE IS ROOM FOR
         LA    R6,1(R6)            PUT R6 COUNTER BACK
         L     R1,UT2AREA          PUT R1 BACK
         LA    R5,0(R6,R5)         BUMP R5 - HOW FAR INTO SYSIN
*
         SR    R7,R6              FIND LENGTH OF REMAINING INPUT
         LA    R9,5
         CR    R7,R9              AND COMPARE TO 5 (LENGTH OF $$EOF)
         BL    SHORTFIL           IF SHORT, BRANCH
*
RCVPS5   EQU   *
         MVC   HOLDPAT(5),0(5)
         CLC   HOLDPAT(5),ENDFILL  IS THIS END-OF-DATA ($$EOF)?
         BE    ENDSYSIN
         PUT   SYSUT2              WRITE SYSUT2
         ST    R1,UT2AREA
         L     R3,UT2AREA
*
*        SR    R7,R6               HOW MUCH SYSIN IS LEFT
         LR    R6,R4               RE-INITIALIZE R6
         CR    R4,R7               COMPARE WHAT IS LEFT IN SYSIN TO
         BL    RCVPS4                OUTPUT LRECL
         B     RCVPS3
*
SHORTFIL EQU   *
         ST    R5,SAVER5              SAVE INPUT POINTER
         GET   SYSIN,LASTAREA         GET NEXT RECORD TO TEST
         LA    R5,LASTAREA
         CLC   LASTAREA(5),ENDFILL
         BE    ENDSYSIN               IF SO, GO FINISH
         PUT   SYSUT2                 IF NOT AT END
         ST    R1,UT2AREA             WRITE CURRENT OUTPUT RECORD
         L     R3,UT2AREA             AND RESET R3
         LR    R6,R4                   AND R6
         LA    R8,80                  SET R8 = 80
         CR    R4,R8                  IF OUTPUT LRECL > 80
         BL    RESET4                   RESET BEFORE BRANCHING BACK.
*
RESET4   EQU   *
         L     R5,SAVER5               RESET R5
         BCTR  R7,R0                    DECREMENT COUNTER FOR MOVE
         EX    R7,MOVEREC1             MOVE END OF FORMER SYSIN RECORD
         LA    R8,1(R7)
         LA    R3,0(R8,R3)
         MVI   RECAREA,X'40'            CLEAR INPUT AREA
         MVC   RECAREA+1(79),RECAREA
         MVC   RECAREA(80),LASTAREA
         LA    R5,RECAREA
         B     SPECIAL
*
ENDSYSIN EQU   *
         CLOSE (SYSIN,,SYSUT2)           CLOSE FILES
         B     TERMINAT
RCVPART1 EQU   *
         B     TERMINAT
OPENSND1 EQU   *
         MVI   JFCBAREA,X'00'           CLEAR
         MVC   JFCBAREA+1(L'JFCBAREA-1),JFCBAREA ALL WORK AREAS
         LA    R8,JFCBAREA              ADDRESS OF WORK AREA TO R8
         USING JFCB,R8                  TELL ASSEMBLER
         LA    R7,SYSPUNCH              ADDRESS OF DCB TO R7
         USING IHADCB,R7                TELL ASSEMBLER
         RDJFCB (SYSPUNCH)
         TM    JFCBTSDM,JFCSDS          CHECK FOR SYSIN/SYSOUT
         BNO   OPENSND2                 IF NOT CONTINUE
         MVC   DCBBLKSI(2),DCBLRECL     DEFAULT 80-80 LRECL-BLKSIZE
OPENSND2 EQU   *
         TM     JFCBIND2,JFCNEW         CHECK IF NEW DATASET
         BO     OPENSND3                BYPASS OBTAIN
         TM     JFCBTSDM,JFCSDS         IF 'OLD' DATASET IS SYSOUT
         BO     OPENSND3                BYPASS OBTAIN
         CLC    JFCBFLSQ,=X'0000'       WILL BE NONZERO IF TAPE
         BNE    OPENSND3                BYPASS OBTAIN
*
*        DO OBTAIN FOR FORMAT1 DSCB FOR OLD OUTPUT DISK DATASET
*
         LA    R6,DSCB1WRK              ADDRESS OF WORK AREA
         USING DS1FMTID,R6              TELL ASSEMBLER
         MVI    CAMLDSNM,X'40'          CLEAR
         MVC    CAMLDSNM+1(L'CAMLDSNM-1),CAMLDSNM
         MVC    CAMLDSNM,JFCBDSNM       AND LOAD
         MVI    CAMLVOLS,X'40'          DATASET NAME
         MVC    CAMLVOLS+1(L'CAMLVOLS-1),CAMLVOLS
         MVC    CAMLVOLS(6),JFCBVOLS    AND VOLUME SERIAL
         OBTAIN DSCBLIST                GET DSCB FORMAT 1
         CLC    DS1BLKL(2),=X'0000'     CHECK FOR BLOCKSIZE OF 0
         BNE    OPENSND3                IF NOT CONTINUE
         MVC   DCBBLKSI(2),DCBLRECL     DEFAULT 80-80 LRECL-BLKSIZE
         DROP  R6
         DROP  R7
         DROP  R8
OPENSND3 EQU   *
         OPEN  (SYSPUNCH,(OUTPUT))
         CLI   JCLSW,C'0'               CHECK IF JCL NEEDED
         BE    OPENSND4                 IF NOT CONTINUE
*
OPENJCL  EQU   *
         MVI   JFCBAREA,X'00'           CLEAR
         MVC   JFCBAREA+1(L'JFCBAREA-1),JFCBAREA ALL WORK AREAS
         LA    R8,JFCBAREA
         USING JFCB,R8
         LA    R7,JCLIN
         USING IHADCB,R7
         RDJFCB (JCLIN)
         TM    JFCBTSDM,JFCSDS          CHECK FOR SYSIN/SYSOUT
         BNO   *+10                     IF NOT CONTINUE
         MVC   DCBBLKSI(2),DCBLRECL     DEFAULT 80-80 LRECL-BLKSIZE
         OPEN  (JCLIN)
*
SNDJCL1  EQU   *                        JCL COPY LOOP
         GET   JCLIN,JCLAREA            GET A RECORD
         PUT   SYSPUNCH,JCLAREA         PUT A RECORD
         MVI   JCLAREA,X'40'            CLEAR THE
         MVC   JCLAREA+1(L'JCLAREA-1),JCLAREA  RECORD AREA
         B     SNDJCL1                  CONTINUE
ENDJCL   EQU   *
         CLOSE (JCLIN)                  CLOSE JCL COPY FILE
         DROP  R7
         DROP  R8
         CLI   JCLDLM,X'40'             DLM= PARM SPECIFIED?
         BE    ERROR13                  NO CONTINUE, ELSE
         MVC   JCLAREA(20),=C'//SYSIN DD DATA,DLM='
         MVC   JCLAREA+20(2),JCLDLM      CREATE SYSIN CARD
         PUT   SYSPUNCH,JCLAREA          AND WRITE IT
OPENSND4 EQU   *                         BEGIN TO PROCESS SYSUT1 FILE
         MVI   JFCBAREA,X'00'           CLEAR
         MVC   JFCBAREA+1(L'JFCBAREA-1),JFCBAREA ALL WORK AREAS
         LA    R8,JFCBAREA              ADDRESS OF WORK AREA TO R8
         USING JFCB,R8                  TELL ASSEMBLER
         LA    R7,SYSUT1                ADDRESS OF DCB TO R7
         USING IHADCB,R7                TELL ASSEMBLER
         RDJFCB (SYSUT1)
         TM    JFCBTSDM,JFCSDS          CHECK FOR SYSIN/SYSOUT
         BNO   OPENSND5                 IF NOT CONTINUE
         MVC   DCBBLKSI(2),DCBLRECL     DEFAULT 80-80 LRECL-BLKSIZE
OPENSND5 EQU   *                         BEGIN TO PROCESS SYSUT1 FILE
         TM     JFCBIND2,JFCNEW         CHECK IF NEW DATASET
         BO     ERROR11                 IF SO ERROR AND QUIT
*********************************************************************
*
         MVI    CAMLDSNM,X'40'          CLEAR
         MVC    CAMLDSNM+1(L'CAMLDSNM-1),CAMLDSNM
         MVC    CAMLDSNM,JFCBDSNM       AND LOAD
*
         LOCATE CAMLIST
*
         CLI    LOCWORK+4,X'80'         WILL BE EQUAL IF TAPE
         BE     OPENSNDT                BRANCH IF  TAPE
*
*        DO OBTAIN FOR FORMAT1 DSCB FOR OLD OUTPUT DISK DATASET
*
         LA    R6,DSCB1WRK              ADDRESS OF WORK AREA
         USING DS1FMTID,R6              TELL ASSEMBLER
         MVI    CAMLDSNM,X'40'          CLEAR
         MVC    CAMLDSNM+1(L'CAMLDSNM-1),CAMLDSNM
         MVC    CAMLDSNM,JFCBDSNM       AND LOAD
         MVI    CAMLVOLS,X'40'          DATASET NAME
         MVC    CAMLVOLS+1(L'CAMLVOLS-1),CAMLVOLS
         MVC    CAMLVOLS(6),JFCBVOLS    AND VOLUME SERIAL
         OBTAIN DSCBLIST                GET DSCB FORMAT 1
         MVC    UT1DSORG,DS1DSORG
         MVC    UT1RECFM,DS1RECFM
         MVC    UT1LRECL,DS1LRECL
         MVC    UT1BLKSI,DS1BLKL
         DROP   R6
         B      OPENSND7
OPENSNDT EQU    *                      *** FIND TAPE DCB INFO
         OPEN  (SYSUT1,(INPUT,REREAD))
         MVC   UT1DSORG,DCBDSORG
         MVC   UT1RECFM,DCBRECFM
         MVC   UT1LRECL,DCBLRECL
         MVC   UT1BLKSI,DCBBLKSI
         CLOSE (SYSUT1)
         B     OPENSND7
OPENSND6 EQU    *
         MVC   UT1DSORG,JFCDSRG1       *** SHOULDN"T NEED THIS,
         MVC   UT1RECFM,JFCRECFM           SINCE FILE SHOULD BE
         MVC   UT1LRECL,JFCLRECL           CATALOGUED.
         MVC   UT1BLKSI,JFCBLKSI
OPENSND7 EQU    *
         TM    UT1RECFM,DCBRECV         TEST FOR VARIABLE
         BO    OPENSND8                 IF SO GO PROCESS
         MVC   DCBLRECL(2),UT1LRECL
         CLC   UT1BLKSI,X'0000'         IF OUTPUT BLKSIZE = 0
         BNE   *+14
         MVC   DCBBLKSI(2),UT1LRECL     FORCE TO BLOCK 1
         B     *+10
         MVC   DCBBLKSI(2),UT1BLKSI     ELSE SET DCBBLKSI = UT1BLKSI
*
         MVC   DCBRECFM(1),UT1RECFM     SET RECFM
*
         MVI   DCBDSRG1,DCBDSGPS        DSORG=PS
         B     OPENUT1                  GO OPEN
OPENSND8 EQU   *                        PROCESS RECFM=V*
         MVC  DCBLRECL(2),UT1LRECL      IF OUTPUT BLKSIZE=0
         CLC   UT1BLKSI,X'0000'
         BNE   *+20                     FORCE TO BLOCK 1
         LH    R3,UT1LRECL              GET MAX LRECL
         LA    R3,4(R3)                 BUMP BY 4 FOR BDW
         STH   R3,DCBBLKSI              STORE IN DCB
         B     *+10
         MVC   DCBBLKSI(2),UT1BLKSI     ELSE MOVE UT1BLKSIZE TO DCB
*
         MVC   DCBRECFM(1),UT1RECFM
*
         TM    DCBRECFM,DCBRECV+DCBRECBR+DCBRECSB
*        IF RECFM=VBS THEN CHANGE BFTEK TO A
         BNO   *+8
         OI    DCBBFTEK,DCBBFTA         BFTEK=A
         MVI   DCBDSRG1,DCBDSGPS        DSORG=PS
         B     OPENUT1                  GO OPEN
OPENUT1  EQU   *
         MVC   UT1BLKSI,DCBBLKSI
         MVC   UT1RECFM,DCBRECFM
         MVC   UT1DSORG,DCBDSRG1
         XC    DCBMACR(2),DCBMACR       CLEAR MACRF= AND
         MVI   DCBMACR1,DCBMRGET+DCBMRLCG  SET IT TO MACRF=(GL)
         MVI   RECAREA,X'40'            CLEAR RECORD AREA TO
         MVC   RECAREA+1(L'RECAREA-1),RECAREA     SPACES
         LA    R6,RECAREA               ADDRESS OF RECORD AREA
         USING HDR,R6                   TELL ASSEMBLER
*********************************************************************
*****        USE DCB INFO TO SET UP HEADER RECORD        ************
*********************************************************************
         MVC   HDRLRECL,DCBLRECL
         MVC   HDRBLKSZ,DCBBLKSI
         MVC   HDRRECFM,DCBRECFM
         MVC   HDRDSRG1,DCBDSRG1
         MVI   HDRDSN3Q,X'40'
         MVC   HDRDSN3Q+1(7),HDRDSN3Q
*********************************************************************
*****        FIND THIRD QUALIFIER FOR HEADER RECORD      ************
*********************************************************************
         LA    R5,JFCBDSNM
         LA    R4,0
         LA    R3,1                     CONTROL
DSN3Q1   CLI   0(R5),C'.'               CHECK FOR END OF A QUALIFIER
         BE    DSN3Q2                   CHECK FOR WHICH ONE
         CLI   0(R5),C' '               CHECK FOR END OF A QUALIFIER
         BE    DSN3Q2                   CHECK FOR WHICH ONE
         LA    R5,1(R5)                 BUMP R5
         B     DSN3Q1                   LOOP
DSN3Q2   CR    R3,R4
         BE    DSN3Q3                   IF 2ND QUALIFIER
         LA    R4,1(R4)                 BUMP QUALIFIER COUNT
         LA    R5,1(R5)                 BUMP R5
         B     DSN3Q1                   LOOP
*
DSN3Q3   LA    R3,HDRDSN3Q              LOAD OUTPUT ADDRESS
         CLI   0(R5),C'.'               IS THERE A THIRD QUALIFIER?
         BE    DSN3Q4                   IF SO, GO ON
         MVC   HDRDSN3Q(8),DUMMYNAM     ELSE MOVE DUMMY NAME TO HEADER
         BAL   R9,ERROR12               INFORM USER
         LA    R5,8(R5)                 FIX REG 5
         B     DSN3QX                   AND GO TO PUT
*
DSN3Q4   LA    R5,1(R5)
         CLI   0(R5),C'.'               ARE WE DONE MOVING?
         BE    DSN3QX
         CLI   0(R5),C' '
         BE    DSN3QX
         MVC   0(1,R3),0(R5)            MOVE A BYTE
         LA    R3,1(R3)                 BUMP THE
         B     DSN3Q4                   LOOP
*********************************************************************
*****        WRITE HEADER RECORD AND OPEN INPUT SYSUT1   ************
*********************************************************************
DSN3QX   EQU   *
         PUT   SYSPUNCH,RECAREA         PUT THE HEADER RECORD
         MVI   RECAREA,X'40'            CLEAR TO BLANKS
         MVC   RECAREA+1(L'RECAREA-1),RECAREA
         DROP  R6
         DROP  R7
         DROP  R8
         OPEN  (SYSUT1)
*
         LA    R2,SYSUT1
         USING IHADCB,R2
         GET   SYSUT1
*********************************************************************
*****        INITIALIZE REGISTERS FOR PROCESSING         ************
*********************************************************************
         ST    R1,UT1AREA
         L     R5,UT1AREA         R5 = INPUT START ADDRESS
         LA    R3,RECAREA         R3 = OUTPUT START ADDRESS
         LA    R4,80              R4 = OUTPUT LRECL (80)
         LR    R6,R4              R6 = OUTPUT LRECL COUNTER
         LH    R7,DCBLRECL        R7 = INPUT LRECL
         LR    R8,R7              R8 = INPUT LRECL COUNTER
*
         CR    R7,R4              COMPARE INPUT LRECL TO 80
         BH    SNDPS3              BRANCH IF MORE
*********************************************************************
*****       LENGTH OF INPUT TO BE PROCESSED NOT > 80     ************
*********************************************************************
SNDPS1   EQU   *
         LTR   R8,R8
         BZ    SNDPS2           SKIP THE MOVE, IF ZERO
         BCTR  R8,0
         EX    R8,MOVEREC1      MOVE WHAT INPUT IS AVAILABLE
         LA    R8,1(R8)         FIX R8
         LA    R3,0(R3,R8)      BUMP R3 - HOW FAR INTO OUTPUT ARE WE?
*
SNDPS2   EQU   *
         CLI   ENDT1SW,C'1'     AT END,
         BE    SNDPS4             DON'T DO ANOTHER GET
         GET   SYSUT1
         ST    R1,UT1AREA
         L     R5,UT1AREA
         LH    R7,DCBLRECL
*
         SR    R6,R8           DETERMINE REMAINING OUTPUT
         LR    R8,R7           RE-INITIALIZE R8 INPUT LRECL COUNTER
         CR    R7,R6           IF WHOLE INPUT WILL FIT, GO BACK AND
         BNH   SNDPS1           MOVE IT
*********************************************************************
*****       LENGTH OF INPUT TO BE PROCESSED > 80         ************
*********************************************************************
SNDPS3   EQU   *
         LTR   R6,R6              SKIP THE MOVE IF R6 = 0
         BZ    SNDPS4
*
         BCTR  R6,0               MOVE 80, OR WHATEVER FITS
         EX    R6,MOVEREC1
         LA    R6,1(R6)           FIX R6
         LA    R5,0(R6,R5)        BUMP R5 TO CURRENT POS. IN INPUT
*
SNDPS4   EQU   *
         CLI   JCLDLM,X'40'
         BE    PUTPUNCH              IF JCL DELIMITER IS SPECIFIED,
         CLC   RECAREA(2),JCLDLM      IF DATA MATCHES IT HERE,
         BE    ERROR16                ISSUE ERROR MESSAGE AND END
*
PUTPUNCH PUT   SYSPUNCH,RECAREA
         MVI   RECAREA,X'40'
         MVC   RECAREA+1(L'RECAREA-1),RECAREA
         LA    R3,RECAREA
         LR    R10,R3
         AR    R10,R4               R10 = ADDRESS OF END OF RECORD
         CLI   FILLSW,C'1'
         BE    ENDUT1C
         CLI   FILLSW,C'2'
         BE    EOFUT1
*
         SR    R8,R6            DETERMINE REMAINING INPUT
         CR    R8,R4            COMPARE REMAINING INPUT TO 80
         BNL   *+10             BRANCH BACK IF INPUT CONTAINS ANOTHER
*                                     WHOLE OUTPUT RECORD
         LR    R6,R4
         B     SNDPS1
         LA    R6,80
         B     SNDPS3
*********************************************************************
************               END OF SYSUT1                 ************
*********************************************************************
*
ENDUT1   EQU   *
         CLI   FILLSW,C'1'
         BE    ENDUT1C
         ST    R3,SAVER3
         LA    R3,5(R3)
         CR    R10,R3               IS THERE ROOM FOR "AT END"?
         L     R3,SAVER3
         BNL   ENDUT1C                BRANCH IF SO,
         LA    R9,4                   ELSE
         MVC   0(R9,R3),ENDFILL     MOVE "AT END" PATTERN (TRUNCATES)
         LA    R9,1(R9)             R9 = 5
         MVI   FILLSW,C'1'          SET FILLSW ON
         B     SNDPS4               GO PUT RECORD
*
ENDUT1C  EQU   *
         LA    R9,4                 R9 = 4
         MVC   0(R9,R3),ENDFILL     MOVE "AT END" PATTERN
         LA    R9,1(R9)             R9 = 5
         LA    R3,5(R3)
         MVI   FILLSW,C'2'          SET FILLSW TO 'FINISH'
         CR    R10,R3               IS THE RECORD FULL YET?
         BNL   ENDUT1C              IF NOT, GO BACK
         B     SNDPS4
EOFUT1   EQU   *
         CLI   JCLSW,C'1'           IF NO JCL
         BNE   TERMINAT             END
         MVC   0(2,R3),JCLDLM       ELSE WRITE DELIMITER
         PUT   SYSPUNCH,RECAREA
         CLI   ENDJSW,C'1'          IF NO ENDJCLIN
         BNE   TERMINAT             END
*
OPENENDJ EQU   *
         MVI   JFCBAREA,X'00'           CLEAR ALL WORK AREAS
         MVC   JFCBAREA+1(L'JFCBAREA-1),JFCBAREA
         LA    R8,JFCBAREA
         USING JFCB,R8
         LA    R7,ENDJCLIN
         USING IHADCB,R7
         RDJFCB (ENDJCLIN)
         TM    JFCBTSDM,JFCSDS          CHECK FOR SYSIN/SYSOUT
         BNO   *+10                     IF NOT CONTINUE
         MVC   DCBBLKSI(2),DCBLRECL     DEFAULT 80-80 LRECL-BLKSIZE
         OPEN  (ENDJCLIN)
*
ENDJCL1  EQU   *                        JCL COPY LOOP
         GET   ENDJCLIN,ENDJAREA        GET A RECORD
         PUT   SYSPUNCH,ENDJAREA        PUT A RECORD
         MVI   ENDJAREA,X'40'            CLEAR THE RECORD AREA
         MVC   ENDJAREA+1(L'ENDJAREA-1),ENDJAREA
         B     ENDJCL1                  CONTINUE
ENDENDJ  EQU   *
         CLOSE (ENDJCLIN)               CLOSE ENDJCL COPY FILE
         B     TERMINAT             END
**********************************************************************
* BEGINNING OF EPILOGUE
TERMINAT L     R13,SAVEAREA+4           LOAD OS SAVE AREA ADDR TO R13
         L     R15,RETCODE              LOAD STORED RETURN CODE
         RETURN (14,12),RC=(15)         RETURN TO OS RC=R15
* END OF EPILOGUE
**********************************************************************
* ERROR PROCESSING ROUTINES
*        IN GENERAL THESE ROUTINES WILL PRODUCE A WTO WITH ROUTCDE=11
*        SET AN APPROPRIATE RETURN CODE AND TERMINATE THE PROGRAM
*        IN THE CASE OF INFORMATIONAL MESSAGES THE ROUTINE WILL
*        ISSUE A WTO WITH ROUTCDE=11 AND RETURN FROM WHENCE IT CAME
*        USING REGISTER 9 FOR LINKAGE
         PRINT NOGEN
ERROR01  EQU   *                        SYSPUNCH DD MISSING ON SEND
         WTO   'DLX001E  DLXTRANS -- SYSPUNCH DD CARD MISSING OR MISPELX
               LED AND SYSUT1 DD CARD PRESENT',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         B     TERMINAT                 GET OUT
ERROR02  EQU   *                        SYSPUNCH DD MISSING ON SEND
         WTO   'DLX002E  DLXTRANS -- JCLIN DD CARD MISSING OR MISPELLEDX
                AND NOJCL PARM NOT SPECIFIED',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         B     TERMINAT                 GET OUT
ERROR03  EQU   *                        SYSUT1 PRESENT BUT NOT USED
         WTO   'DLX003I  DLXTRANS -- SYSUT1 DD CARD PRESENT AND NOT NEEX
               DED',ROUTCDE=(11)
         BR    R9                       RETURN
ERROR04  EQU   *                        SYSUT2 PRESENT BUT NOT USED
         WTO   'DLX004I  DLXTRANS -- SYSUT2 DD CARD PRESENT AND NOT NEEX
               DED',ROUTCDE=(11)
         BR    R9                       RETURN
ERROR05  EQU   *                        SYSIN PRESENT BUT NOT USED
         WTO   'DLX005I  DLXTRANS -- SYSIN DD CARD PRESENT AND NOT NEEDX
               ED',ROUTCDE=(11)
         MVI   SYSINSW,C'0'
         BR    R9                       RETURN
ERROR06  EQU   *                        JCLIN PRESENT BUT NOT USED
         WTO   'DLX006I  DLXTRANS -- JCLIN DD CARD PRESENT AND NOT NEEDX
               ED',ROUTCDE=(11)
         BR    R9                       RETURN
ERROR07  EQU   *                        SYSPUNCH PRESENT BUT NOT USED
         WTO   'DLX007I  DLXTRANS -- SYSPUNCH DD CARD PRESEND AND NOT NX
               EEDED',ROUTCDE=(11)
         BR    R9                       RETURN
ERROR08  EQU   *                        SYSPUNCH DD MISSING ON SEND
         WTO   'DLX008E  DLXTRANS -- NEITHER SYSUT1 OR SYSUT2 DD CARDS X
               ARE PRESENT. ONE IS REQUIRED',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         B     TERMINAT                 GET OUT
ERROR09  EQU   *                        SYSPUNCH DD MISSING ON SEND
         WTO   'DLX009E  DLXTRANS -- SYSIN DD CARD MISSING OR MISPELLEDX
                AND SYSUT2 DD CARD PRESENT',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         B     TERMINAT                 GET OUT
*
ERROR10  EQU   *                        SYSPUNCH DD MISSING ON SEND
         WTO   'DLX010E  DLXTRANS -- LRECL FROM INPUT FILE DOES NOT MATX
               CH LRECL SPECIFIED FOR OUTPUT',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         CLOSE (SYSIN)
         B     TERMINAT                 GET OUT
*
ERROR11  EQU   *                        SYSUT1 ON RECEIVE A NEW DATASET
         WTO   'DLX011E  DLXTRANS -- SYSUT1 FOR A RECEIVE OPERATION CANX
                NOT BE A NEW DATASET',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         CLOSE (SYSPUNCH)
         B     TERMINAT                 GET OUT
*
ERROR12  EQU   *                        NO THIRD QUALIFIER
         WTO   'DLX012I  DLXTRANS -- SYSUT1 DATASET NAME HAS NO THIRD QX
               UALIFIER - "DUMMYFIL" SUBSTITUTED',ROUTCDE=(11)
         MVI   RETCODE+3,X'04'          SET RETURN CODE TO 4
         BR    R9                       RETURN
*
ERROR13  EQU   *                        NO THIRD QUALIFIER
         WTO   'DLX013E  DLXTRANS -- DELIMITER (DLM=) MUST BE SPECIFIEDX
                WHEN JCL IS TRANSMITTED',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         B     TERMINAT                 END
*
ERROR14  EQU   *
         WTO   'DLX014W  DLXTRANS -- RECFM TAKEN FROM HEADER RECORD - JX
               CL IGNORED',ROUTCDE=(11)
         MVI   RETCODE+3,X'04'          SET RETURN CODE TO 4
         BR    R9                       RETURN
*
ERROR15  EQU   *                        NO THIRD QUALIFIER
         WTO   'DLX015E  DLXTRANS -- RECFM = U CANNOT BE PROCESSED - PRX
               OGRAM TERMINATED',ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         B     TERMINAT                 END
*
ERROR16  EQU   *                        DELIMITER NOT UNIQUE
         WTO   'DLX016E  DLXTRANS -- DELIMITER CHARACTERS HAVE OCCURREDX
                IN THE DATA -',ROUTCDE=(11)
         WTO   '-- TRANSMITTED FILE IS INCOMPLETE',ROUTCDE=(11)
         WTO   '-- DELETE FILE AND RERUN WITH NEW DELIMITER',          X
               ROUTCDE=(11)
         MVI   RETCODE+3,X'0F'          SET RETURN CODE TO 16
         B     TERMINAT                 END
*
ERROR17  EQU   *                     ENDJCLIN PRESENT BUT NOT USED
         WTO   'DLX017I  DLXTRANS -- ENDJCLIN DD CARD PRESENT BUT CAN NX
               OT BE USED - IGNORED',ROUTCDE=(11)
         BR    R9                       RETURN
***********************************************************************
         PRINT GEN
SAVEAREA DC    18F'0'                   OUR SAVE AREA
PARMAREA DS    0CL102                   AREA FOR PARM FIELD
PARMLNGT DC    XL2'0000'                LENGTH OF PARM FIELD
PARMFLDS DC    CL100' '                 MAX LENGTH PARM FIELD
PARMANAL DC    CL20' '                  WORK FIELD FOR PARM ANALYSIS
JCLSW    DC    C'1'                     JCL NEEDED 1 YES 0 NO
MOREPARM DC    C'Y'                     LAST PARM SWITCH
SYSINSW  DC    C'0'                     SYSIN DD 1 PRESENT 0 MISSING
UT1SW    DC    C'0'                     SYSUT1 DD 1 PRESENT 0 MISSING
UT2SW    DC    C'0'                     SYSUT2 DD 1 PRESENT 0 MISSING
JCLINSW  DC    C'0'                     JCLIN DD 1 PRESENT 0 MISSING
ENDJSW   DC    C'0'                  ENDJCLIN DD 1 PRESENT 0 MISSING
PUNCHSW  DC    C'0'                     SYSPUNCH DD 1 PRESENT 0 MISSING
ENDT1SW  DC    C'0'                     EOF INDICATOR - SYSUT1
FILLSW   DC    C'0'                     END PATTERN INDICATOR
RETCODE  DC    F'0'                     SAVE AREA FOR RETURN CODE
UT1RECFM DC    XL1'00'                  SYSUT1 RECFM
UT1DSORG DC    XL1'00'                  SYSUT1 DSORG
UT1LRECL DC    XL2'0000'                SYSUT1 LRECL
UT1BLKSI DC    XL2'0000'                SYSUT1 BLKSIZE
SAVLRECL DC    XL2'0000'
SAVLEN   DC    XL2'0000'
SAVER3   DC    F'0'
SAVER5   DC    F'0'
DUMMYNAM DC    C'DUMMYFIL'              DUMMY NAME FOR THIRD QUALIFIER
ENDFILL  DC    C'$$EOF'
HOLDPAT  DC    C'00000'
UT1AREA  DC    F'0'                     AREA ADDRESS RETURNED BY PUT
UT2RECFM DC    XL1'00'                  SYSUT2 RECFM
UT2DSORG DC    XL1'00'                  SYSUT2 DSORG
UT2LRECL DC    XL2'0000'                SYSUT2 LRECL
UT2BLKSI DC    XL2'0000'                SYSUT2 BLKSIZE
UT2AREA  DC    F'0'                     AREA ADDRESS RETURNED BY PUT
RECAREA  DC    CL80' '
LASTAREA DC    CL80' '
JCLAREA  DC    CL80' '
ENDJAREA DC    CL80' '
JCLDLM   DC    CL2'  '                  DLM=
CAMLDSNM DC    CL44' '
CAMLVOLS DC    CL6' '
DSCB1WRK DC    XL140'00'                FORMAT1 DSCB WORKAREA
MOVEPARM MVC   PARMAREA(0),0(R2)        MOVE PARM FIELD TO PARMSAVE
MOVEREC1 MVC   0(0,R3),0(R5)            MOVE RECORD FROM INPUT TO OUT
DSCBLIST CAMLST SEARCH,CAMLDSNM,CAMLVOLS,DSCB1WRK
CAMLIST  CAMLST NAME,CAMLDSNM,,LOCWORK
LOCWORK  DS    0D
         DS    265C
         PRINT NOGEN
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,LRECL=80,MACRF=(GM),              X
               RECFM=FB,EODAD=ENDSYSIN,EXLST=RDJFLIST
SYSUT1   DCB   DDNAME=SYSUT1,EODAD=ENDUT1,EXLST=RDJFLIST,DSORG=PS,     X
               MACRF=(RP)
SYSUT2   DCB   DDNAME=SYSUT2,EXLST=RDJFLIST,DSORG=PS,MACRF=(PM)
SYSPUNCH DCB   DDNAME=SYSPUNCH,DSORG=PS,LRECL=80,EXLST=RDJFLIST,       X
               MACRF=(PM),RECFM=FB
JCLIN    DCB   DDNAME=JCLIN,DSORG=PS,LRECL=80,MACRF=(GM),              X
               RECFM=FB,EODAD=ENDJCL,EXLST=RDJFLIST
ENDJCLIN DCB   DDNAME=ENDJCLIN,DSORG=PS,LRECL=80,MACRF=(GM),           X
               RECFM=FB,EODAD=ENDENDJ,EXLST=RDJFLIST
*
*DSNAP   DCB   DDNAME=DDSNAP,DSORG=PS,LRECL=125,BLKSIZE=1632,
*              MACRF=(W),RECFM=VBA
         PRINT GEN
RDJFLIST DC    X'07',AL3(JFCBAREA)
JFCBAREA DC    176X'0'
         SPACE 3
         LTORG
         EQUATE                         REGISTER EQUATES
         PRINT NOGEN
*        DSECTS FOR MAPPING MACROS
*
*  DSECT FOR HEADER CARD
HDR      DSECT
         COPY  BLKCHG
* DCB DSECT    GOOD FOR PS AND PO DATASETS ON DA OR TA
         DCBD  DSORG=(PS,PO),DEVD=(DA,TA)
* DSCB1 DSECT  GOOD FOR FORMAT1 DSCBS
         IECSDSL1 1
* JFCB DSECT
JFCB     DSECT
         IEFJFCBN LIST=YES
         PRINT GEN
         END   DLXTRANS
