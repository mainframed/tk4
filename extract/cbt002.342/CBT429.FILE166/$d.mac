/*                                 REXX                             */
/*                                                                  */
/*      This REXX exec will display different MVS control blocks    */
/*                                                                  */
/*      Note:  The HELP Text itself is part of this EXEC.           */
/*      It begins after '/*BEGHELP ... */' and ends at              */
/*      '/*ENDHELP ...*/'.  Any invalid parm will cause the         */
/*      Help text to be displayed.                                  */
/*                                                                  */
/*                                                                  */
/*      Vinh Vu - 5/21/92 - Origrinal codes - V1.0                  */
/*                                                                  */
/*------------------------------------------------------------------*/
/*                                                                  */
/*      6/10/92 - Vinh Vu - V1.1                                    */
/*              - Access SYSID from CVT, not from SMF (SMFID).      */
/*              - Pick up CPU model from CVT extenstion, not from   */
/*                serial number.                                    */
/*              - Also display DFP level.                           */
/*                                                                  */
/*     10/07/93 - Vinh Vu - V1.2                                    */
/*              - Add display for LPA List.                         */
/*                                                                  */
/*     01/10/96 - Vinh Vu - V2.0                                    */
/*              - Clean up the code                                 */
/*              - Add display for expanded storage & more stuff     */
/*              - Add display for Nucleus Map                       */
/*                                                                  */
/*     09/06/96 - Vinh Vu - V2.1                                    */
/*              - Add display for IPL Loadparm                      */
/*              - Check for Dynamic APF Table                       */
/*              - Add display for chpids                            */
/*              - Add 'ALL' to display all                          */
/*                                                                  */
/*     05/19/97 - Vinh Vu - V2.2                                    */
/*              - Add display for CPU version code                  */
/*                                                                  */
/*     12/17/97 - Vinh Vu - V2.3                                    */
/*              - Add *non-slot* for chpids not avail               */
/*              - Add display for 'MOVEPAGE' & 'COMPRESSION' svc    */
/*              - Make 'SYSTEM' as default if no parm was entered   */
/*              - Display IPL date in Gregorian dates               */
/*              - Display System area sizes along with the addr     */
/*                                                                  */
/*------------------------------------------------------------------*/

VERSION = '2.3'

Parse Source . . EXEC_NAME .
Parse Version REXX_VERSION

VERSION = EXEC_NAME××' '××VERSION
VERSION = VERSION××' - '××REXX_VERSION

Numeric Digits 256

/*BEGHELP       - - - - - - - - - - - - - - - - - - - - - - - - - - */
/*                                                                  */
/*                       HELP Text                                  */
/*                                                                  */
/*  Syntax:   $D PARM                                               */
/*                                                                  */
/*     PARM will be one of the following:                           */
/*                                                                  */
/*      o   APF(LIST) to display the APF libraries                  */
/*      o   CHP to display all chpids                               */
/*      o   LINK(LIST) or LLT to display the linklist libraries     */
/*      o   LPA(LIST) to display the LPA List libraries             */
/*      o   PAG(ING) to display paging statistics                   */
/*      o   NUC(MAP) to display Nucleus Map                         */
/*      o   SS(T) to list all SubSystem names                       */
/*      o   SVC to display the SVC table                            */
/*      o   SYS(TEM) to display system information                  */
/*      o   ALL to execute all above functions                      */
/*                                                                  */
/*ENDHELP       - - - - - - - - - - - - - - - - - - - - - - - - - - */


Parse Upper Arg P1
CVTADD  = Get_Stor('10'x)
SMCAADD = Get_Stor(CVTADD,'C4'x)               /* SMCA pointer      */
SMFID   = Get_Stor(SMCAADD,'10'x)              /* Get System SMF ID */

SYSID   = Strip(Get_Stor(CVTADD,'154'x,8))

/*                                                                  */
/*                                                                  */

Say '<'VERSION'>'

Select
   When P1 = ''                       Then Do
        Say
        Say ' ***>'
        Say " ***>  To display EXEC syntax, type '"EXEC_NAME" ??' <***"
        Say ' ***>'
        Call SYSDISP
        End
   When ABBREV('APFLIST',P1,3)        Then Do
        Call APFDISP
        End
   When ABBREV('CHP',P1,3)        Then Do
        Call CHPDISP
        End
   When (ABBREV('LINKLIST',P1,4)     ×,
         ABBREV('LLT',P1,3))          Then Do
        Call LLTDISP
        End
   When ABBREV('LPALIST',P1,3)        Then Do
        Call LPADISP
        End
   When ABBREV('NUCMAP',P1,3)         Then Do
        Call NUCDISP
        End
   When ABBREV('PAGING',P1,3)        ×,
        ABBREV('PAGE',P1,3)           Then Do
        Call PAGDISP
        End
   When ABBREV('SST',P1,2)            Then Do
        Call SSTDISP
        End
   When ABBREV('SVC',P1,3)            Then Do
        Call SVCDISP
        End
   When ABBREV('SYSTEM',P1,3)         Then Do
        Call SYSDISP
        End
   When ABBREV('ALL',P1,3)            Then Do
        Call APFDISP
        Call CHPDISP
        Call LLTDISP
        Call LPADISP
        Call NUCDISP
        Call PAGDISP
        Call SSTDISP
        Call SVCDISP
        Call SYSDISP
        End
   Otherwise Do
        LASTLINE = SourceLine()
        I = 1
        Do Until Substr(SourceLine(I),1,9) = '/*BEGHELP'
           I = I+1
           End
        I = I + 1                              /* Skip BEGHELP line */
        If I = LASTLINE Then Exit              /* In case ......... */
        Do Until Substr(SourceLine(I),1,9) = '/*ENDHELP'
           Say Left(SourceLine(I),72)
           I = I+1
           End
        Exit
        End
   End
Exit

/*------------------------------------------------------------------*/

/*                                                                  */
/*      DISPLAY APFLIST                                             */
/*                                                                  */
/*                                                                  */
/*      APF = CVT+x'1E4' = Pointer to the APFList                   */
/*      APF = '7FFFF001'x if APF format is Dynamic                  */
/*      COUNT will be how many DSN's in APFList                     */
/*                                                                  */

APFDISP:
APFADD  = Get_Stor(CVTADD,'1E4'x)
COUNT   = C2D(Get_Stor(APFADD,,2))
DSNDEC  = C2D(APFADD)+2                        /* Ptr to Dsn (dec)  */

/*                                                                  */
/*                                                                  */
/*                                                                  */


Say
Say '         --- APFList For' SYSID '---'
Say

If APFADD = '7FFFF001'x Then Do
   Say '     *-*-* APF Format is Dynamic - No data displayed *-*-* '
   Say
   Return
   End
DO I=1 to COUNT
   DSNLENG = C2D(Get_Stor(DSNDEC,,1))-6       /* DSname leng   */
   DSNDEC = DSNDEC+1                           /* Go past length    */
   VOLSER = Get_Stor(DSNDEC,,6)
   DSNDEC = DSNDEC+6                           /* Go past VOLSER    */
   DSNAME = Get_Stor(DSNDEC,,DSNLENG)
   DSNDEC = DSNDEC+DSNLENG                     /* Go to next entry  */
   DSNAME = Left(DSNAME,44)
   Say Format(I,3,0) ' ' VOLSER ' ' DSNAME
   End

Return
/*------------------------------------------------------------------*/


/*                                                                  */
/*      DISPLAY CHPIDS                                              */
/*                                                                  */
/*                                                                  */
/*      CHPTAB = CVT+x'4D0' = Pointer to the chpid table            */
/*                                                                  */

CHPDISP:
CHPTAB  = Get_Stor(CVTADD,'4D0'x)

/*                                                                  */
/*                                                                  */
/*                                                                  */


Say
Say '         --- CHPList For' SYSID '---'
Say
USECHP = 0
AVAILCHP = 0
Say ' CHP      Status'
Say ' ---     ' Copies('-',20)
Say
Do I=0 to 255
   CHPID = Get_Stor(CHPTAB,I,1)
   If CHPID = 'E0'x Then Do
      Say Right(D2X(I),4) '    ' 'InUse'
      USECHP = USECHP + 1
      End
   Else If CHPID = '80'x Then Do
         Say Right(D2X(I),4) '    ' Right('Avail',20)
         AVAILCHP = AVAILCHP + 1
         End
        Else Do
         Say Right(D2X(I),4) '    ' Right('*Non-slot*',15)
         End
   End

Say
Say 'Total Number of InUse Chpids:' USECHP
Say 'Total Number of Avail/NotUsed Chpids:' AVAILCHP
Say
Say 'Total Number of Avail Chpids:' USECHP+AVAILCHP
Say
Return
/*------------------------------------------------------------------*/

/*                                                                  */
/*      DISPLAY LINKLIST                                            */
/*                                                                  */
/*      LLT = CVT+x'4DC'(1244) = Pointer to Linklist Table          */
/*      COUNT will be how many DSN's in Linklist                    */
/*                                                                  */

LLTDISP:
LLTADD  = Get_Stor(CVTADD,'4DC'x)
COUNT   = C2D(Get_Stor(LLTADD,'4'x))
LLTDEC  = C2D(LLTADD)+9                        /* Ptr to Dsn (dec)  */
APFDEC  = C2D(LLTADD)+8+(45*COUNT)             /* Ptr to Flag (dec) */

/*                                                                  */
/*                                                                  */
/*                                                                  */

Say
Say '        --- LinkList For' SYSID '---'
Say
DO I=1 to COUNT
   DSNAME=Get_Stor(LLTDEC,,44)
   LLTDEC = LLTDEC + 45
   APFFLAG=Get_Stor(APFDEC,,1)
   If Bitand(APFFLAG,'80'x) = '80'x Then
      APFMSG = '- APF Lib - '
   Else
      APFMSG = '            '
   APFDEC = APFDEC + 1
   Say Format(I,3,0) ' ' APFMSG DSNAME
   End

Return


/*------------------------------------------------------------------*/

/*                                                                  */
/*      DISPLAY LPA Libraries List                                  */
/*                                                                  */
/*      CVTEXT  = CVT+x'4AC' = CVT extension                        */
/*      LPALST  = CVTEXT+x'38' = LPA Libraries List                 */
/*                                                                  */

LPADISP:

CVTEADD  = Get_Stor(CVTADD,'4AC'x)
LPALADD  = Get_Stor(CVTEADD,'38'x)
COUNT    = C2D(Get_Stor(LPALADD,'4'x))
DSNDEC   = C2D(LPALADD)+8                       /* Ptr to Dsn (dec)  */


/*                                                                  */
/*                                                                  */

Say
Say '         --- LPAList For' SYSID '---'
Say

DO I=1 to COUNT
   DSNAME = Get_Stor(DSNDEC,'1'x,44)
   DSNDEC = DSNDEC+45                          /* Go to next entry  */
   DSNAME = Left(DSNAME,44)
   Say Format(I,3,0) ' ' DSNAME
   End

Return


/*------------------------------------------------------------------*/

/*                                                                  */
/*      DISPLAY NUCLEUS Map                                         */
/*                                                                  */
/*      NUCMAP  = CVT+x'4B0'                                        */
/*                                                                  */

NUCDISP:

NUCADD   = C2D(Get_Stor(CVTADD,'4B0'x))
NUCLENG  = C2D(Get_Stor(NUCADD,12))
NUCEND   = NUCADD+NUCLENG

Say
Say ' ------- NUCLEUS Map Display for' SYSID '-------'
Say
Say '    MODNAME    ADDR    SIZE  CSECT RSECT'
Say

NUCADD = NUCADD+16

Do While (NUCADD < NUCEND)
   NUCNAME = Get_Stor(NUCADD,,8)
   NUCADDR = C2X(Get_Stor(NUCADD,8))
   NUCSIZE = C2X(Get_Stor(NUCADD,13,3))
   NUCFLAG = Get_Stor(NUCADD,12,1)
   If Bitand(NUCFLAG,'10'x) = '10'x Then NUCMSECT = 'CSECT'
      Else NUCMSECT = '     '
   If Bitand(NUCFLAG,'08'x) = '08'x Then NUCMRSEC = 'RSECT'
      Else NUCMRSEC = '     '
   NUCADD = NUCADD+16
   Say '   ' NUCNAME NUCADDR NUCSIZE NUCMSECT NUCMRSEC
   End

Return

/*------------------------------------------------------------------*/
/*                                                                  */
/*      DISPLAY Paging statistics                                   */
/*                                                                  */
/*                                                                  */
/*      ASMVT = CVT + x'2C0'                                        */
/*                                                                  */

PAGDISP:
ASMADD  = Get_Stor(CVTADD,'2C0'x)

SARTADD = Get_Stor(ASMADD,'4'x)
PARTADD = Get_Stor(ASMADD,'8'x)

/*                                                                  */
/*                                                                  */
/*                                                                  */

FIRSTADD= Get_Stor(PARTADD,52)
LASTADD = Get_Stor(PARTADD,56)
LPAADD  = Get_Stor(PARTADD,48)

Say
Say '             ------- Paging STAT Display for' SYSID '-------'
Say
Say '                               Burst         Avail Outst I/O' ,
    ' Num  Slots'
Say 'Type Volser Adr Devt Stat  Num Size    Size  Slots  I/O  Err' ,
    ' Cyls PerCyl'
Say

ENTADD  = LPAADD
LPALOOP:
Call PARTDATA
ENTADD  = Get_Stor(ENTADD)
If C2D(ENTADD) ^= 0 Then Signal LPALOOP


ENTADD  = FIRSTADD
PAGLOOP:
Call PARTDATA
If ENTADD ^= LASTADD Then Do
   ENTADD  = Get_Stor(ENTADD)
   Signal PAGLOOP
   End

Return

PARTDATA:
TYPE1   = Get_Stor(ENTADD,'8'x,1)
TYPE2   = Get_Stor(ENTADD,'9'x,1)
PATADD  = Get_Stor(ENTADD,32)
PCTADD  = Get_Stor(ENTADD,36)
UCBADD  = Get_Stor(ENTADD,44)

Select
   When Bitand(TYPE1,'80'x) = '80'x Then Do
      DSATTYPE = 'LPLA'
      End
   When Bitand(TYPE1,'40'x) = '40'x Then Do
      DSATTYPE = 'COMM'
      End
   When Bitand(TYPE1,'20'x) = '20'x Then Do
      DSATTYPE = 'DUPL'
      End
   When Bitand(TYPE1,'10'x) = '10'x Then Do
      DSATTYPE = 'LOCL'
      End
   Otherwise Do
      DSATTYPE = '    '
      End
   End       /* Select */

If Bitand(TYPE2,'40'x) = '40'x Then BADDSAT = 'BAD'
   Else BADDSAT = 'Ok '

UCBNUM   = Get_Stor(UCBADD,13,3)
UCBVOL   = Get_Stor(UCBADD,28,6)

PARTNUM = Right(C2D(Get_Stor(ENTADD,10,2)),3)
BURSTSZE= Right(C2D(Get_Stor(ENTADD,4,1)),3)
SIZE    = Right(C2D(Get_Stor(ENTADD,16)),8)
AVAIL   = Right(C2D(Get_Stor(ENTADD,20)),6)
OUTSTAND= Right(C2D(Get_Stor(ENTADD,62,2)),4)
IOERR   = Right(C2D(Get_Stor(ENTADD,24)),3)

CYLNO   = Right(C2D(Get_Stor(PATADD,8,2)),5)
CYLSIZE = Right(C2D(Get_Stor(PATADD,10,2)),5)

DEVTYPE = Get_Stor(PCTADD,'4'x,6)

Say DSATTYPE UCBVOL UCBNUM DEVTYPE BADDSAT PARTNUM  ,
    BURSTSZE SIZE AVAIL OUTSTAND IOERR ,
    CYLNO CYLSIZE
Return

/*------------------------------------------------------------------*/

/*                                                                  */
/*      DISPLAY SubSystems                                          */
/*                                                                  */
/*                                                                  */
/*      JESCT = CVT+x'128' = Pointer to the JESCT                   */
/*      JESCT points to first SSCT which chains to next SSCT        */
/*                                                                  */

SSTDISP:
JCTADD  = Get_Stor(CVTADD,'128'x)
SSCTADD = Get_Stor(JCTADD,24)

/*                                                                  */
/*                                                                  */
/*                                                                  */

I = 1
Say
Say '                       --- SUBSYSTEM List For' SYSID '---'
Say

SSTLOOP:
SUBSYS  = Get_Stor(SSCTADD,'8'x)               /* SubSys Name       */
SSVT    = Get_Stor(SSCTADD,16)                 /* SSVT Address      */

If C2D(SSVT) = 0 Then
   SSTMSG = '(Dormant)'
Else
   SSTMSG = ''

Say Format(I,3,0) ' ' SUBSYS '    SSCT Address = ' C2X(SSCTADD),
    '  SSVT Address = ' C2X(SSVT)  SSTMSG

SSCTADD = Get_Stor(SSCTADD,'4'x)               /* Next one in chain */
I = I+1
If C2D(SSCTADD) ^= 0 Then Signal SSTLOOP
Return

/*------------------------------------------------------------------*/

/*                                                                  */
/*      DISPLAY SVC Table                                           */
/*                                                                  */
/*      CVT -> CVTABEND -> SCVT -> SVCTABLE                         */
/*                                                                  */

SVCDISP:
SCVTADD  = Get_Stor(CVTADD,'C8'x)
SVCADD   = Get_Stor(SCVTADD,'84'x)

/*                                                                  */
/*                                                                  */
   SNUM.0   = 'EXCP/XDAP    '
   SNUM.1 =   'WAIT/WAITR/..'
   SNUM.2 =   'POST         '
   SNUM.3 =   'EXIT         '
   SNUM.4 =   'GETMAIN      '
   SNUM.5 =   'FREEMAIN     '
   SNUM.6 =   'LINK/LINKX   '
   SNUM.7 =   'XCTL/XCTLX   '
   SNUM.8 =   'LOAD         '
   SNUM.9 =   'DELETE       '
   SNUM.10 =  'GET/FREEM R  '
   SNUM.11 =  'TIME         '
   SNUM.12 =  'SYNCH/SYNCHX '
   SNUM.13 =  'ABEND        '
   SNUM.14 =  'SPIE         '
   SNUM.15 =  'ERREXCP      '
   SNUM.16 =  'PURGE        '
   SNUM.17 =  'RESTORE      '
   SNUM.18 =  'BLDL/FIND    '
   SNUM.19 =  'OPEN         '
   SNUM.20 =  'CLOSE        '
   SNUM.21 =  'STOW         '
   SNUM.22 =  'OPEN TYPE J  '
   SNUM.23 =  'CLOSE TYPE T '
   SNUM.24 =  'DEVTYPE      '
   SNUM.25 =  'TRKBAL       '
   SNUM.26 =  'LOCATE, ETC  '
   SNUM.27 =  'OBTAIN       '
   SNUM.28 =  '--Reserved-- '
   SNUM.29 =  'SCRATCH      '
   SNUM.30 =  'RENAME       '
   SNUM.31 =  'FEOV         '
   SNUM.32 =  'REALLOC      '
   SNUM.33 =  'IOHALT       '
   SNUM.34 =  'MGCR/QEDIT   '
   SNUM.35 =  'WTO/WTOR     '
   SNUM.36 =  'WTL          '
   SNUM.37 =  'SEGLD/SEGWT  '
   SNUM.38 =  '--Reserved-- '
   SNUM.39 =  'LABEL        '
   SNUM.40 =  'EXTRACT      '
   SNUM.41 =  'IDENTIFY     '
   SNUM.42 =  'ATTACH       '
   SNUM.43 =  'CIRB         '
   SNUM.44 =  'CHAP         '
   SNUM.45 =  'OVLYBRCH     '
   SNUM.46 =  'TTIMER       '
   SNUM.47 =  'STIMER       '
   SNUM.48 =  'DEQ          '
   SNUM.49 =  '--Reserved-- '
   SNUM.50 =  '--Reserved-- '
   SNUM.51 =  'SNAP/SDUMP   '
   SNUM.52 =  'RESTART      '
   SNUM.53 =  'RELEX        '
   SNUM.54 =  'DISABLE      '
   SNUM.55 =  'EOV          '
   SNUM.56 =  'ENQ/RESERVE  '
   SNUM.57 =  'FREEDBUF     '
   SNUM.58 =  'RELBUF/REQBUF'
   SNUM.59 =  'OLTEP        '
   SNUM.60 =  '(E)STAE/STAI '
   SNUM.61 =  'IKJEGS6A     '
   SNUM.62 =  'DETACH       '
   SNUM.63 =  'CHKPT        '
   SNUM.64 =  'RDJFCB       '
   SNUM.65 =  '--Reserved-- '
   SNUM.66 =  'BTAMTEST     '
   SNUM.67 =  '--Reserved-- '
   SNUM.68 =  'SYNADAF      '
   SNUM.69 =  'BSP          '
   SNUM.70 =  'GSERV        '
   SNUM.71 =  'ASGNBFR, ETC '
   SNUM.72 =  '--No MACRO-- '
   SNUM.73 =  'SPAR         '
   SNUM.74 =  'DAR          '
   SNUM.75 =  'DQUEUE       '
   SNUM.76 =  '--No MACRO-- '
   SNUM.77 =  '--Reserved-- '
   SNUM.78 =  'LSPACE       '
   SNUM.79 =  'STATUS       '
   SNUM.80 =  '--Reserved-- '
   SNUM.81 =  'SETPRT       '
   SNUM.82 =  '--Reserved-- '
   SNUM.83 =  'SMFWTM       '
   SNUM.84 =  'GRAPHICS     '
   SNUM.85 =  'DDRSWAP      '
   SNUM.86 =  'ATLAS        '
   SNUM.87 =  'DOM          '
   SNUM.88 =  '--Reserved-- '
   SNUM.89 =  '--Reserved-- '
   SNUM.90 =  '--Reserved-- '
   SNUM.91 =  'VOLSTAT      '
   SNUM.92 =  'TCBEXCP      '
   SNUM.93 =  'TPUT/TGET    '
   SNUM.94 =  'STCC         '
   SNUM.95 =  'SYSEVENT     '
   SNUM.96 =  'STAX         '
   SNUM.97 =  'IKJEGS9G     '
   SNUM.98 =  'PROTECT      '
   SNUM.99 =  'DYNALLOC     '
   SNUM.100 = 'IKJEFFIB     '
   SNUM.101 = 'QTIP         '
   SNUM.102 = 'AQCTL (TCAM) '
   SNUM.103 = 'XLATE        '
   SNUM.104 = 'TOPCTL (TCAM)'
   SNUM.105 = 'IMGLIB       '
   SNUM.106 = '--Reserved-- '
   SNUM.107 = 'MODESET      '
   SNUM.108 = '--Reserved-- '
   SNUM.109 = 'ESR TYPE 4   '
   SNUM.110 = '--Reserved-- '
   SNUM.111 = '--No MACRO-- '
   SNUM.112 = 'PGRLSE       '
   SNUM.113 = 'PGFIX/PGFREE/'
   SNUM.114 = 'EXCPVR       '
   SNUM.115 = '--Reserved-- '
   SNUM.116 = 'ESR TYPE 1   '
   SNUM.117 = 'DEBCHK       '
   SNUM.118 = '--Reserved-- '
   SNUM.119 = 'TESTAUTH     '
   SNUM.120 = 'GETMAIN/FREEM'
   SNUM.121 = 'VSAM         '
   SNUM.122 = 'ESR TYPE 2   '
   SNUM.123 = 'PURGEDQ      '
   SNUM.124 = 'TPIO         '
   SNUM.125 = 'EVENTS       '
   SNUM.126 = '--Reserved-- '
   SNUM.127 = '--Reserved-- '
   SNUM.128 = '--Reserved-- '
   SNUM.129 = '--Reserved-- '
   SNUM.130 = 'RACHECK      '
   SNUM.131 = 'RACINIT      '
   SNUM.132 = 'RACLIST      '
   SNUM.133 = 'RACDEF       '
   SNUM.134 = '--Reserved-- '
   SNUM.135 = '--Reserved-- '
   SNUM.136 = '--Reserved-- '
   SNUM.137 = 'ESR TYPE 6   '
   SNUM.138 = 'PGSER (XA)   '
   SNUM.139 = 'CVAF         '
   SNUM.140 = '             '
   SNUM.141 = '             '
   SNUM.142 = '             '
   SNUM.143 = 'GENKEY/RETKEY'
   SNUM.144 = 'PTRACE(DEBUG)'
   SNUM.145 = '             '
   SNUM.146 = '             '
   SNUM.147 = '             '
   SNUM.148 = '             '
   SNUM.149 = '             '
   SNUM.150 = '             '
   SNUM.151 = '             '
   SNUM.152 = '             '
   SNUM.153 = '             '
   SNUM.154 = '             '
   SNUM.155 = '             '
   SNUM.156 = '             '
   SNUM.157 = '             '
   SNUM.158 = '             '
   SNUM.159 = '             '
   SNUM.160 = '             '
   SNUM.161 = '             '
   SNUM.162 = '             '
   SNUM.163 = '             '
   SNUM.164 = '             '
   SNUM.165 = '             '
   SNUM.166 = '             '
   SNUM.167 = '             '
   SNUM.168 = '             '
   SNUM.169 = '             '
   SNUM.170 = '             '
   SNUM.171 = '             '
   SNUM.172 = '             '
   SNUM.173 = '             '
   SNUM.174 = '             '
   SNUM.175 = '             '
   SNUM.176 = '             '
   SNUM.177 = '             '
   SNUM.178 = '             '
   SNUM.179 = '             '
   SNUM.180 = '             '
   SNUM.181 = '             '
   SNUM.182 = '             '
   SNUM.183 = '             '
   SNUM.184 = '             '
   SNUM.185 = '             '
   SNUM.186 = '             '
   SNUM.187 = '             '
   SNUM.188 = '             '
   SNUM.189 = '             '
   SNUM.190 = '             '
   SNUM.191 = '             '
   SNUM.192 = '             '
   SNUM.193 = '             '
   SNUM.194 = '             '
   SNUM.195 = '             '
   SNUM.196 = '             '
   SNUM.197 = '             '
   SNUM.198 = '             '
   SNUM.199 = '             '
   SNUM.200 = '             '
   SNUM.201 = '             '
   SNUM.202 = '             '
   SNUM.203 = '             '
   SNUM.204 = '             '
   SNUM.205 = '             '
   SNUM.206 = '             '
   SNUM.207 = '             '
   SNUM.208 = '             '
   SNUM.209 = '             '
   SNUM.210 = '             '
   SNUM.211 = '             '
   SNUM.212 = '             '
   SNUM.213 = '             '
   SNUM.214 = '             '
   SNUM.215 = 'CICS(HPSVC)  '
   SNUM.216 = 'CICS(CSVC)   '
   SNUM.217 = '             '
   SNUM.218 = '             '
   SNUM.219 = '             '
   SNUM.220 = '             '
   SNUM.221 = '             '
   SNUM.222 = '             '
   SNUM.223 = '             '
   SNUM.224 = '             '
   SNUM.225 = '             '
   SNUM.226 = '             '
   SNUM.227 = '             '
   SNUM.228 = '             '
   SNUM.229 = '             '
   SNUM.230 = '             '
   SNUM.231 = '             '
   SNUM.232 = '             '
   SNUM.233 = '             '
   SNUM.234 = '             '
   SNUM.235 = '             '
   SNUM.236 = '             '
   SNUM.237 = '             '
   SNUM.238 = '             '
   SNUM.239 = '             '
   SNUM.240 = '             '
   SNUM.241 = 'VSAMTUNE     '
   SNUM.242 = 'UCC7         '
   SNUM.243 = '             '
   SNUM.244 = '             '
   SNUM.245 = 'UCC11        '
   SNUM.246 = '             '
   SNUM.247 = 'UCC1 (X)     '
   SNUM.248 = 'UCC1 (Y)     '
   SNUM.249 = 'DIAGNOSE     '
   SNUM.250 = '             '
   SNUM.251 = '             '
   SNUM.252 = '             '
   SNUM.253 = '             '
   SNUM.254 = '             '
   SNUM.255 = '             '
/*                                                                  */
/*                                                                  */
/*                                                                  */

Say
Say '         --- SVCTABLE Display For' SYSID '---'
Say
Say '                   ' Copies(' ',16) ,
            '                A S P A             '
Say '  SVC# (Hex)  Entry' Copies(' ',16) ,
            '  Amod  Type    P E R S  Lock(s) needed '
Say '                   ' Copies(' ',16) ,
            '                F R E T             '
Say

DO I=0 to 255
   ENTRYPT = Get_Stor(SVCADD)                 /*                   */
   AMODE = Substr(ENTRYPT,1,1)
   If Bitand(AMODE,'80'x) = '80'x Then
      ADDR = '31'
   Else
      ADDR = '  '
   SVCTYPE = Get_Stor(SVCADD,'4'x,1)
   If Bitand(SVCTYPE,'20'x) = '20'x Then Do
      TYPEMSG = 'T6   '
      End
   Else
      If Bitand(SVCTYPE,'C0'x) = 'C0'x Then Do
         TYPEMSG = 'T3/4 '
         End
      Else
         If Bitand(SVCTYPE,'80'x) = '80'x Then Do
            TYPEMSG = 'T2   '
            End
         Else
            If Bitand(SVCTYPE,'00'x) = '00'x Then Do
               TYPEMSG = 'T1   '
               End
            Else
               TYPEMSG = '?    '
   If Bitand(SVCTYPE,'08'x) = '08'x Then
      APF = 'A'
   Else
      APF = ' '
   If Bitand(SVCTYPE,'04'x) = '04'x Then
      ESR = 'E'
   Else
      ESR = ' '
   If Bitand(SVCTYPE,'02'x) = '02'x Then
      PRE = 'P'
   Else
      PRE = ' '
   If Bitand(SVCTYPE,'01'x) = '01'x Then
      AST = 'S'
   Else
      AST = ' '
   LOCK    = Get_Stor(SVCADD,'6'x,1)
   LMSG = ''
   If Bitand(LOCK,'80'x) = '80'x Then
      LMSG = LMSG××'LOCL'
   If Bitand(LOCK,'40'x) = '40'x Then
      LMSG = LMSG××',CMS'
   If Bitand(LOCK,'20'x) = '20'x Then
      LMSG = LMSG××',OPT'
   If Bitand(LOCK,'10'x) = '10'x Then
      LMSG = LMSG××',SALLOC'
   If Bitand(LOCK,'08'x) = '08'x Then
      LMSG = LMSG××',DISP'
   IHEX = '    '
   IHEX = Right(D2X(I),2)
   Say ' ' Format(I,3,0) '-' IHEX ' ' ,
       C2X(ENTRYPT) ' ' SNUM.I ' ' ADDR ' ',
       TYPEMSG ' ' APF ESR PRE AST ' ' LMSG
   SVCADD  = D2C(C2D(SVCADD)+8)                /* Bump to next entry */
   End
Say
Return

/*------------------------------------------------------------------*/

/*                                                                  */
/*      DISPLAY SYSTEM information                                  */
/*                                                                  */
/*                                                                  */
/*      PCCAT = CVT+x'2FC' = Pointer to the PCCA Vector Table       */
/*      PCCAVT has up to 16 PCCA pointers                           */
/*      PCCA Has CPU Serial # plus its physical CPU Id              */
/*                                                                  */
/*      STRGOFF = CVT+x'358' = Online Storage (K's) at IPL          */
/*                                                                  */

SYSDISP:

PVTADD  = Get_Stor(CVTADD,'2FC'x)
RCE     = Get_Stor(CVTADD,'490'x)              /* Get RCE Pointer   */
GDA     = Get_Stor(CVTADD,'230'x)              /* Get GDA Pointer   */
ECVT    = Get_Stor(CVTADD,'8C'x)               /* Get Extended CVT  */
EXT2CVT = Get_Stor(CVTADD,'148'x)              /* Get CVTEXT2       */

LOADPARM = Get_Stor(ECVT,'A0'x,8)

IODFID  = Get_Stor(EXT2CVT,'6'x,2)
NUCID   = Get_Stor(EXT2CVT,'4'x,1)

STRG    = Get_Stor(CVTADD,'358'x)
EXPSTOR = C2D(Get_Stor(RCE,'A0'x))
EXPSTOR = (EXPSTOR*4)/1024                     /* Convert To MEG    */

IPLTI  = C2D(Get_Stor(SMCAADD,'150'x))%360000
IPLTRM = C2D(Get_Stor(SMCAADD,'150'x))//360000
IPLTD  = RIGHT(IPLTRM%6000,2,'0')             /* Find # of Minutes  */

IPLT   = IPLTI××'.'××IPLTD
IPLD   = C2X(Get_Stor(SMCAADD,'154'x))

IPLYEAR  = Substr(IPLD,3,2)
IPLDAY   = Substr(IPLD,5,3)

If IPLYEAR > 60 Then IPLYEAR = IPLYEAR+1900

IPL_R   = $DATE('J2R',IPLYEAR××IPLDAY)
TODAY_J = $DATE('G2J',,
          Substr(DATE(S),5,2)××'/'××,
          Substr(DATE(S),7,2)××'/'××Substr(DATE(S),1,4))
TODAY_R = $DATE('J2R',TODAY_J)

If TODAY_R = IPL_R Then AGOS = '(Today)'
   Else If (TODAY_R - IPL_R) = 1 Then AGOS = '(Yesterday)'
      Else AGOS = '('××Value((TODAY_R - IPL_R))××' days ago)'

UCBADD   = Get_Stor(CVTADD,'30'x)

UCBNUM   = Get_Stor(UCBADD,'D'x,3)
UCBVOL   = Get_Stor(UCBADD,'1C'x,6)

CVTPRADD = D2C(C2D(CVTADD)-40)

OPSYS    = Get_Stor(CVTPRADD,,8)
FMIDS    = Get_Stor(CVTPRADD,'8'x,8)
CPUTYPE  = C2X(Get_Stor(CVTPRADD,34,2))
MVSREL   = Get_Stor(CVTPRADD,36)

DFAADD   = Get_Stor(CVTADD,'4C0'x)

DFPREL   = C2X(Get_Stor(DFAADD,'2'x,2))
DFPREL   = Substr(DFPREL,1,3)

ASMADD   = Get_Stor(CVTADD,'2C0'x)

IPLFLG   = Get_Stor(ASMADD,'1'x,1)

CVTEADD  = Get_Stor(CVTADD,'4AC'x)

MLPABEG  = C2X(Get_Stor(CVTEADD,8))
MLPAEND  = C2X(Get_Stor(CVTEADD,12))
MLPA_SIZE = Right(((X2D(MLPAEND)-X2D(MLPABEG)+1)%1024),8)××'K'

FLPABEG  = C2X(Get_Stor(CVTEADD,16))
FLPAEND  = C2X(Get_Stor(CVTEADD,20))
FLPA_SIZE = Right(((X2D(FLPAEND)-X2D(FLPABEG)+1)%1024),8)××'K'

PLPABEG  = C2X(Get_Stor(CVTEADD,24))
PLPAEND  = C2X(Get_Stor(CVTEADD,28))
PLPA_SIZE = Right(((X2D(PLPAEND)-X2D(PLPABEG)+1)%1024),8)××'K'

WNUCBEG  = C2X(Get_Stor(CVTEADD,32))
WNUCEND  = C2X(Get_Stor(CVTEADD,36))
WNUC_SIZE = Right(((X2D(WNUCEND)-X2D(WNUCBEG)+1)%1024),8)××'K'

RNUCBEG  = C2X(Get_Stor(CVTEADD,40))
RNUCEND  = C2X(Get_Stor(CVTEADD,44))
RNUC_SIZE = Right(((X2D(RNUCEND)-X2D(RNUCBEG)+1)%1024),8)××'K'

ENUCBEG  = C2X(Get_Stor(CVTEADD,48))
ENUCEND  = C2X(Get_Stor(CVTEADD,52))
ENUC_SIZE = Right(((X2D(ENUCEND)-X2D(ENUCBEG)+1)%1024),8)××'K'

EPLPABEG = C2X(Get_Stor(CVTEADD,56))
EPLPAEND = C2X(Get_Stor(CVTEADD,60))
EPLPA_SIZE = Right(((X2D(EPLPAEND)-X2D(EPLPABEG)+1)%1024),8)××'K'

EFLPABEG = C2X(Get_Stor(CVTEADD,64))
EFLPAEND = C2X(Get_Stor(CVTEADD,68))
EFLPA_SIZE = Right(((X2D(EFLPAEND)-X2D(EFLPABEG)+1)%1024),8)××'K'

EMLPABEG = C2X(Get_Stor(CVTEADD,72))
EMLPAEND = C2X(Get_Stor(CVTEADD,76))
EMLPA_SIZE = Right(((X2D(EMLPAEND)-X2D(EMLPABEG)+1)%1024),8)××'K'

CSASTRT  = Get_Stor(GDA,'6C'x)
CSASIZE  = Get_Stor(GDA,'70'x)

CSA_STRT = C2X(CSASTRT)
CSA_END  = Right((D2X(C2D(CSASTRT)+C2D(CSASIZE)-1)),8,0)

CSAESTRT = Get_Stor(GDA,'7C'x)
CSAESIZE = Get_Stor(GDA,'80'x)

ECSA_STRT = C2X(CSAESTRT)
ECSA_END  = Right((D2X(C2D(CSAESTRT)+C2D(CSAESIZE)-1)),8,0)

SQASTRT  = Get_Stor(GDA,'90'x)
SQASIZE  = Get_Stor(GDA,'94'x)

SQA_STRT = C2X(SQASTRT)
SQA_END  = Right((D2X(C2D(SQASTRT)+C2D(SQASIZE)-1)),8,0)

SQAESTRT = Get_Stor(GDA,'98'x)
SQAESIZE = Get_Stor(GDA,'9C'x)

ESQA_STRT = C2X(SQAESTRT)
ESQA_END  = Right((D2X(C2D(SQAESTRT)+C2D(SQAESIZE)-1)),8,0)

PRVSTRT  = Get_Stor(GDA,'A0'x)
PRVSIZE  = Get_Stor(GDA,'A4'x)

PVT_STRT = C2X(PRVSTRT)
PVT_END  = Right((D2X(C2D(PRVSTRT)+C2D(PRVSIZE)-1)),8,0)

PRVESTRT = Get_Stor(GDA,'A8'x)
PRVESIZE = Get_Stor(GDA,'AC'x)

EPVT_STRT = C2X(PRVESTRT)
EPVT_END  = Right((D2X(C2D(PRVESTRT)+C2D(PRVESIZE)-1)),8,0)

UNALLCSA   = Format((C2D(Get_Stor(GDA,'84'x))/1024),5,0)
CSA2SQA    = Format((C2D(Get_Stor(GDA,'8C'x))/1024),5,0)

CSA_ALLOC  = Format((C2D(Get_Stor(GDA,'1B0'x))/1204),9,0)
ECSA_ALLOC = Format((C2D(Get_Stor(GDA,'1B4'x))/1204),9,0)
SQA_ALLOC  = Format((C2D(Get_Stor(GDA,'1B8'x))/1204),9,0)
ESQA_ALLOC = Format((C2D(Get_Stor(GDA,'1BC'x))/1204),9,0)
/*                                                                  */
/*                                                                  */
/*                                                                  */
D1  = Substr(DATE('J'),1,2)
D2  = Substr(DATE('J'),3,3)
D1N2 = D1××'.'××D2

Say
Say '         --- SYSTEM INFO Display For' SYSID '---'
Say
Say ' Today =' D1N2 'or' DATE('W')××',' DATE('N')
Say ' System IPL''ed at' Format(IPLT,2,2) AGOS,
     'on' $DATE('R2D',IPL_R)××',' IPLYEAR××'.'××IPLDAY,
     '('××$DATE('J2G',IPLYEAR××IPLDAY)××')'
Say Copies(' ',7) 'using volume' UCBVOL 'at address' UCBNUM

If BitAnd(IPLFLG,'08'x) = '08'x Then Do
   QIPL = 'Non-CLPA'
   End
Else Do
   QIPL = 'CLPA    '
   End

If BitAnd(IPLFLG,'04'x) = '04'x Then Do
   WIPL = 'Non-CVIO'
   End
Else Do
   WIPL = 'CVIO    '
   End

Say ' IPL Type:  Quick Start =' QIPL  '   Warm Start =' WIPL

Say ' IPL LoadParm =' LOADPARM

Say ' IPL Nucleus id =' NUCID '   IPL IODF id =' IODFID

Say ' Online Real Storage at IPL =' Format(C2D(STRG)/1024,5,0)××'M'
Say ' Available Expanded Storage =' EXPSTOR'M'
Say ' OpSys = ' OPSYS '    FMID =' FMIDS '   SMFID =' SMFID ,
    '    Sysplex =' Get_Stor(ECVT,'8'x,8)
Say ' MVS Rel =' MVSREL '   DFP Rel =' DFPREL ,
    '  CPU Type ='  CPUTYPE

If Bitand(Get_Stor(CVTADD,'178'x,1),'10'x) = '10'x Then ,
   Say ' MOVEPAGE facility is enabled for this CPU'
Else ,
   Say ' MOVEPAGE facility is *NOT AVAILABLE* for this CPU'

If Bitand(Get_Stor(CVTADD,'179'x,1),'80'x) = '80'x Then ,
   Say ' MVS Compression/Expansion Service is available'
Else ,
   Say ' MVS Compression/Expansion Service is *NOT AVAILABLE*'

If Bitand(Get_Stor(CVTADD,'179'x,1),'40'x) = '40'x Then ,
   Say ' Hardware Data Compression/Expansion instruction is available'
Else ,
   Say ' Hardware Data Compression/Expansion instruction is *NOT',
       'AVAILABLE*'

Say

Do I=1 to 16
   PCCAADD = Get_Stor(PVTADD)                  /*                   */
   If C2D(PCCAADD) ^=0 Then Do
      VERCODE = Get_Stor(PCCAADD,'4'x,2)
      SERIAL  = Get_Stor(PCCAADD,'6'x,6)
      CPUTYPE = Get_Stor(PCCAADD,'C'x)
      CPUID   = C2D(Get_Stor(PCCAADD,'10'x,2))
      Say ' CPU =' CPUID ' Vers =' VERCODE ' Ser =' SERIAL
      End
   PVTADD  = D2C(C2D(PVTADD)+4)                /* Bump to next entry */
   End

  CSA_SIZE =  Right(C2D(CSASIZE)/1024,8)××'K'
 ECSA_SIZE =  Right(C2D(CSAESIZE)/1024,8)××'K'
  SQA_SIZE =  Right(C2D(SQASIZE)/1024,8)××'K'
 ESQA_SIZE =  Right(C2D(SQAESIZE)/1024,8)××'K'
  PVT_SIZE =  Right(C2D(PRVSIZE)/1024,8)××'K'
 EPVT_SIZE =  Right(C2D(PRVESIZE)/1024,8)××'K'

Say
Say ' Start/End Address for PVT REG ' PVT_STRT  '-'    PVT_END,
                                                PVT_SIZE
Say ' - - - - - - - - - - - CSA     ' CSA_STRT  '-'    CSA_END,
                                                CSA_SIZE
Say ' - - - - - - - - - - - MLPA    ' MLPABEG   '-'    MLPAEND,
                                                MLPA_SIZE
Say ' - - - - - - - - - - - FLPA    ' FLPABEG   '-'    FLPAEND,
                                                FLPA_SIZE
Say ' - - - - - - - - - - - PLPA    ' PLPABEG   '-'    PLPAEND,
                                                PLPA_SIZE
Say ' - - - - - - - - - - - SQA     ' SQA_STRT  '-'    SQA_END ,
                                                SQA_SIZE
Say ' - - - - - - READ/WRITE NUC    ' WNUCBEG   '-'    WNUCEND,
                                                WNUC_SIZE
Say ' - - - - - -  READ-ONLY NUC    ' RNUCBEG   '-'    RNUCEND,
                                                RNUC_SIZE
Say ' -  READ/WRITE EXTENDED NUC    ' ENUCBEG   '-'    ENUCEND,
                                                ENUC_SIZE
Say ' - - - - - -  EXTENDED SQA     ' ESQA_STRT '-'    ESQA_END,
                                                ESQA_SIZE
Say ' - - - - - -  EXTENDED PLPA    ' EPLPABEG  '-'    EPLPAEND,
                                                EPLPA_SIZE
Say ' - - - - - -  EXTENDED FLPA    ' EFLPABEG  '-'    EFLPAEND,
                                                EFLPA_SIZE
Say ' - - - - - -  EXTENDED MLPA    ' EMLPABEG  '-'    EMLPAEND,
                                                EMLPA_SIZE
Say ' - - - - - -  EXTENDED CSA     ' ECSA_STRT '-'    ECSA_END,
                                                ECSA_SIZE
Say ' - - - - - -  EXTENDED PVT REG ' EPVT_STRT '-'    EPVT_END,
                                                EPVT_SIZE
Say
Say 'CSA converted to SQA = ' CSA2SQA'K'  ' Avail CSA = ' UNALLCSA'K'
Say
Say 'GetMained CSA =' CSA_ALLOC'K'  '  ECSA = ' ECSA_ALLOC'K'
Say 'GetMained SQA =' SQA_ALLOC'K'  '  ESQA = ' ESQA_ALLOC'K'
Return

/*------------------------------------------------------------------*/


Get_Stor: PROCEDURE

/*------------------------------------------------------------------*/
/*                                                                  */
/*      This procedure will extract data using the MVS Storage      */
/*      function. Input arguments will be:                          */
/*                                                                  */
/*      1) Storage_Pointer or Literal, i.e. CVTPTR or '10'x, or     */
/*         16 (like '10'x)                                          */
/*      2) Offset in hex or dec (numnbe), i.e. 'FF'x or 256 or      */
/*         D2C(256)                                                 */
/*      3) Length of returned data in decimal, i.e. 256             */
/*                                                                  */
/*      NOTE - To make sure that this procedure will work all the   */
/*      times, just include 'NUMERIC DIGITS 256' at the beginning   */
/*      of the calling REXX exec.                                   */
/*                                                                  */
/*------------------------------------------------------------------*/

Parse Arg AREA,OFFSET,LENG

If Arg(2,'O') Then OFFSET=0

If Arg(3,'O') Then LENG=4

If DataType(AREA) = 'CHAR' Then Do
   AREA =  C2D(AREA)
   End

If DataType(OFFSET) = 'CHAR' Then Do
   OFFSET =  C2D(OFFSET)
   End

Return  Storage((D2X(AREA+OFFSET)),LENG)

/*                                 REXX                             */
/*------------------------------------------------------------------*/
/*                                                                  */
/*      This REXX exec will do date conversion:                     */
/*                                                                  */
/*      Call Format:  DATE = $DATE(CODE,INPUT)                      */
/*                                                                  */
/*          CODE = 'J2G' - Julian to Gregorian date                 */
/*          CODE = 'G2J' - Gregorian date to Julian                 */
/*          CODE = 'J2R' - Julian to Relative date                  */
/*          CODE = 'R2J' - Relative to Julian date                  */
/*          CODE = 'R2D' - Relative to day, i.e Sun, Mon, etc..     */
/*                                                                  */
/*          INPUT = either 'MM/DD/YYYY' or 'YYYYDDD' or 'nnnn'      */
/*                                                                  */
/*      Errors during processing will return 0 as result and        */
/*      an error message will be displayed as well.                 */
/*                                                                  */
/*------------------------------------------------------------------*/

$DATE: Procedure

Parse Upper Arg FUNC,DATE

If DATE = '' Then RET_DATE = 0
Else Select
      When FUNC = 'J2G' Then RET_DATE = J2G_PROC(DATE)
      When FUNC = 'G2J' Then RET_DATE = G2J_PROC(DATE)
      When FUNC = 'J2R' Then RET_DATE = J2R_PROC(DATE)
      When FUNC = 'R2J' Then RET_DATE = R2J_PROC(DATE)
      When FUNC = 'R2D' Then RET_DATE = R2D_PROC(DATE)
      Otherwise Do
         Say 'DT999E - Invalid function code as' FUNC
         RET_DATE = 0
         End
   End

Return RET_DATE



J2G_PROC: Procedure

Parse Arg JUL_DATE

Call VALIDATE_JULIAN
If RESULT = 0 Then G_DATE = 0
Else Do
   JULIAN_YYYY = Substr(JUL_DATE,1,4)
   JULIAN_DDD  = Substr(JUL_DATE,5,3)
   MO.1  = 31
   MO.2  = 28
   MO.3  = 31
   MO.4  = 30
   MO.5  = 31
   MO.6  = 30
   MO.7  = 31
   MO.8  = 31
   MO.9  = 30
   MO.10 = 31
   MO.11 = 30
   MO.12 = 31
   If LEAP_YEAR(JULIAN_YYYY) Then MO.2 = 29
   Do I=1 to 12 While JULIAN_DDD > MO.I
      JULIAN_DDD = JULIAN_DDD - MO.I
      End
   MM   = Right(I,2,'0')
   DD   = Right(JULIAN_DDD,2,'0')
   G_DATE = MM××'/'××DD××'/'××JULIAN_YYYY
   End

Return G_DATE


G2J_PROC: Procedure

Parse Arg GEO_DATE
Parse Var GEO_DATE MM '/' DD '/' YYYY
J_DATE = 0

If Datatype(MM)   ^= 'NUM' × ,
   Datatype(DD)   ^= 'NUM' × ,
   Datatype(YYYY) ^= 'NUM' × ,
   DD > 31                 × ,
   MM < 1                  × ,
   MM > 12                 × ,
   YYYY > 9999          Then ,
      Say 'DT001E - Invalid Gregorian date as' GEO_DATE
Else Do
   MO.1  = 31
   MO.2  = 28
   MO.3  = 31
   MO.4  = 30
   MO.5  = 31
   MO.6  = 30
   MO.7  = 31
   MO.8  = 31
   MO.9  = 30
   MO.10 = 31
   MO.11 = 30
   MO.12 = 31
   If LEAP_YEAR(YYYY) Then MO.2 = 29
   MM = Strip(MM,'L','0')
   If (DD > Value(MO.MM)) Then ,
       Say 'DT002E - Out-of-range date as' GEO_DATE
   Else Do
      J_ACCUM_DAY = 0
      If MM > 1 Then Do I=1 to (MM-1)
         J_ACCUM_DAY = J_ACCUM_DAY + MO.I
         End
      J_ACCUM_DAY = J_ACCUM_DAY + DD
      J_DATE      = YYYY××Right(J_ACCUM_DAY,3,'0')
      End
   End

Return J_DATE




J2R_PROC: Procedure

Parse Arg JUL_DATE

Call VALIDATE_JULIAN
If RESULT = 1 Then R_DATE = ((JULIAN_YYYY-1) * 365) + ,
                            ((JULIAN_YYYY-1) % 4) - ,
                            ((JULIAN_YYYY-1) % 100) + ,
                            ((JULIAN_YYYY-1) % 400) + (JULIAN_DDD)
   Else R_DATE = 0
Return R_DATE



R2J_PROC: Procedure
Parse Arg REL_DATE
RETURNED_J = 0

If Datatype(REL_DATE) ^= 'NUM' Then ,
   Say 'DT006E - Relative date non-numeric as' REL_DATE
Else Do
   If REL_DATE > 3652424 Then ,
      Say 'DT007E - Relative date out-of-range as' REL_DATE
   Else Do
      TEMP_YYYY = (REL_DATE % 366) + 1
      TEMP_REL = J2R_PROC(Right(TEMP_YYYY,4,'0')××'000')
      Do While (REL_DATE - TEMP_REL) > 0
         If LEAP_YEAR(TEMP_YYYY) Then LEFT_OVER = 366
         Else LEFT_OVER = 365
         If LEFT_OVER < (REL_DATE - TEMP_REL) Then Do
            TEMP_REL  = TEMP_REL  + LEFT_OVER
            TEMP_YYYY = TEMP_YYYY + 1
            End
         Else Do
            TEMP_DDD = (REL_DATE - TEMP_REL)
            Leave
            End
         End
      RETURNED_J =  Right(TEMP_YYYY,4,'0')××Right(TEMP_DDD,3,'0')
   End
End

Return RETURNED_J


R2D_PROC: Procedure
Parse Arg REL_DATE
RETURNED_DAY = 0
If Datatype(REL_DATE) ^= 'NUM' Then ,
   Say 'DT006E - Relative date non-numeric as' REL_DATE
Else Do
   If REL_DATE > 3652424 Then ,
      Say 'DT007E - Relative date out-of-range as' REL_DATE
   Else Do
      DAY_INDEX = (REL_DATE // 7)+1
      RETURNED_DAY  = Word('Sun Mon Tue Wed Thu Fri Sat',DAY_INDEX)
   End
End

Return RETURNED_DAY





VALIDATE_JULIAN:

VALID_DATE = 0

If Length(JUL_DATE) ^=7 × Datatype(JUL_DATE) ^= 'NUM' Then
   Say 'DT003E - Date too short/long or non-numeric as' JUL_DATE
Else Do
   JULIAN_YYYY = Substr(JUL_DATE,1,4)
   JULIAN_DDD  = Substr(JUL_DATE,5,3)
   If (JULIAN_DDD > 366) Then ,
      Say 'DT004E - Number of day > 366 as' JULIAN_DDD
   Else If (LEAP_YEAR(JULIAN_YYYY) = 0) & (JULIAN_DDD = 366) Then ,
          Say 'DT005E - Invalid days for a non-leap year as' JULIAN_YYYY
        Else If (JULIAN_YYYY < 1) Then ,
           Say 'DT008E - Invalid year as' JULIAN_YYYY
           Else VALID_DATE = 1
   End
Return VALID_DATE



LEAP_YEAR: Procedure
Parse Arg YEAR_CHECKED

If (YEAR_CHECKED // 100) = 0 Then ,
   If (YEAR_CHECKED // 400) = 0 Then LEAP_YEAR_FLAG = 1
   Else LEAP_YEAR_FLAG = 0
Else If (YEAR_CHECKED // 4) = 0 Then LEAP_YEAR_FLAG = 1
   Else LEAP_YEAR_FLAG = 0

Return LEAP_YEAR_FLAG
