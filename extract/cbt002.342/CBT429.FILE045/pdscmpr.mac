*          DATA SET CBT1274J   AT LEVEL 002 AS OF 07/20/83
* CHANGED PARM DEFAULT FROM 1000 TO 9999     AXC-CBT
         TITLE 'PDS COMPARE PROGRAM -- USE YALE COMPARE PGM LOGIC'
*
*   THIS IS AN ENHANCEMENT TO THE YALE COMPARE PROGRAM THAT IS
*   DISTRIBTED AS FILE 226 ON THE CONN. BANK MODS TAPE.  THE PURPOSE
*   OF THE ENHANCEMENT IS TO ALLOW THE COMPARE PROGRAM TO PROCESS
*   TWO PDS FILES RATHER THAN TWO SEQUENTIAL FILES.  THE ORIGINAL
*   PROGRAM HAS BEEN MODIFIED A LITTLE TO ACCOMODATE THE FRONT
*   END PDS PROCESSOR.
*
*   THE PROGRAM IS SELF CONTAINED;  SIMPLY ASSEMBLE ANDLINK
*   AND ITS READY TO USE.
*
*   THE JCL NEEDED TO EXECUTE THE PROGRAM FOLLOWS:
*       1) //         EXEC PGM=PDSCMPR,
*       2) //             PARM='SIZE=NNNN,TYPE=OPT1,PRINT=OPT2'
*       3) //SYSPRINT DD  SYSOUT=*
*       4) //NEW      DD  DSN=PDS1,DISP=SHR
*       5) //OLD      DD  DSN=PDS2,DISP=SHR
*   WHERE    NNNN IS 3 OR 4 NUMERICS INDICATING AN ESTIMATE OF HOW
*                 MANY MEMBERS EXIST IN THE PDS WITH THE MOST MEMBERS.
*                 THE DEFAULT VALUE IS 1000.  IF A VALUE OF LESS THAN
*                 100 IS SUPPLIED, THE PROGRAM WILL CHANGE THE VALUE
*                 TO 100.  IF THERE ARE MORE MEMBERS THAN INDICATED
*                 BY THE SIZE PARAMETER, THE PROGRAM MAY ABEND.
*
*            OPT1 IS EITHER 'FULL' OR 'PART'; 'PART' IS THE DEFAULT
*                 VALUE.  ACTUALLY, IF THE USER PROVIDES ANY VALUE
*                 OTHER THAN 'FULL', THEN 'PART' WILL BE ASSUMED.
*                 TYPE=FULL INDICATES THAT ALL 80 COLS OF THE CARD
*                 IMAGE PDS WILL BE USED IN THE COMPARISON.
*                 TYPE=PART INDICATES THAT ONLY COLS 1-72 WILL BE
*                 USED.
*
*            OPT2 IS 'MEM', 'DIR', OR 'NAME'; 'NAME' IS THE DEFAULT
*                 VALUE.  PRINT=MEM INDICATES THAT IF ONE PDS CONTAINS
*                 A MEMBER, BUT THE OTHER PDS DOES NOT CONTAIN A MEMBER
*                 WITH THE SAME NAME, THE  ENTIRE MEM WILL BE LISTED.
*                 PRINT=DIR INDICATES THAT THE COMPARISON OF MEMBERS
*                 WON'T TAKE PLACE, BUT THE RECAP RPT WILL BE PRODUCED
*                 TO SHOW WHICH MEMBERS EXISTS IN EACH PDS.  PRINT=NAME
*                 INDICATES THAT UNMATCHED MEMBERS WILL NOT BE PRINTED
*                 IN THEIR ENTIRITY, HOWEVER, THEY WILL BE FLAGGED AS
*                 UNMATCHED ON THE RECAP REPORT.
*
*   THE 'NEW' AND 'OLD' DD STATMENTS WILL BE USED TO PROCESS BOTH THE
*   DIRECTORIES AND MEMBERS OF THE PDS FILES.  MEMBER NAMES SHOULD NOT
*   BE CODED.  OPEN TYPE=J WILL BE USED TO ACCESS THE MEMBERS.
*
*
*   THE OUTPUT OF THE PROGRAM CONSISTS OF A DETAILED LISTING AND A
*   RECAP REPORT.  THE DETAILED LISTING SHOWS:
*      - THE MEMBER NAME, DATA SET NAME, AND VOL/SER OF EACH MEMBER
*        PROCESSED.
*      - ANY DIFFERENCES THAT EXIST BETWEEN THE MEMBERS.
*      - A COUNT OF UNEQUAL BLOCKS OF DATA AS WELL AS THE RECORD COUNTS
*        FOR EACH MEMBER.
*   THE RECAP LISTING FORMAT IS:
*      OLD MEM=XXXXXXXX PAGE NNNN NEW MEM=YYYYYYYY STATUS
*      THE STATUS MAY BE
*          - EQUAL           BOTH MEMBERS ARE THE SAME
*          - NOT EQUAL       THERE ARE DIFFERENCES
*          - NO MATCH        THE MEMBER EXISTS IN ONLY ONE PDS
*
*   WE USE THE PROGRAM TO COMPARE PARMLIB, PROCLIBS, ETC. FROM ONE
*   CPU TO ANOTHER AND ALSO AS AN AID WHEN INSTALLING NEW SCP RELEASES.
*
*   BRENT TOLMAN
*   TRANSPORTAION MANAGEMENT SERVICES
*   SALT LAKE CITY, UT
*
*
*
*
          EJECT
PDSCMPR  CSECT
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         SPACE 3
         STM   R14,R12,12(R13)     SAVE THEIR REGS IN THEIR AREA
         LR    R10,R15             LOAD BASE REG WITH ENTRY ADDR
         LA    R6,4095(,R10)       LOAD SECOND BASE
         LA    R6,1(,R6)           WITH PROPER ADDRESS
         USING PDSCMPR,R10,R6      ESTABLISH ADDRESSABILITY
         B     PDSLINK             NOW GO LINK SAVE AREAS
         SPACE
PDSPGM   DC    CL8'PDSCMPR'        PROGRAM NAME
PDSDATE  DC    CL8'&SYSDATE'       SYSTEM DATE OF ASSEMBLY
         DC    CL3' '
PDSTIME  DC    CL5'&SYSTIME'       SYSTEM TIME OF ASSEMBLY
         SPACE 2
PDSSAVE  DC    9D'0'               SAVE AREA FOR PDSCMPR
RETCODE  DC    F'0'                RETURN CODE
RETURN   L     R15,RETCODE         GET RETURN CODE
         L     R13,PDSSAVE+4       GET ADD OF THEIR SAVE AREA
         L     R14,12(,R13)        RESTORE RETURN ADDRESS
         LM    R0,R12,20(R13)      RESTORE R0 THRU R12
         BR    R14                 RETURN TO CALLER
         SPACE 2
PDSLINK  LA    R14,PDSSAVE         GET ADDR OF OUR SAVE AREA
         ST    R14,8(,R13)         SAVE OUR ADDR IN THEIR AREA
         ST    R13,4(,R14)         SAVE THEIR ADDR IN OUR AREA
         LR    R13,R14             POINT R13 TO OUR AREA NOW
         EJECT
PARM     EQU   *                   PROCESS PARM DATA SUPPLIED BY USER
* PARM
*        R1 - SCP POINTER TO PARM AT ENTRY
*        R2 - PARM LENGTH
*        R3 - POINTER TO PARM DATA WHILE EVALUATING
*        R4 - POINTER TO PARM VALUE SAVE AREAS
*        R5 - LOOP CONTROL AND SAVE AREA POINTER
*
*        BAL   R12,NUMB  - CONVERT VALUE TO BINARY
*        B     GETM
***********************************************************************
         L     R1,0(,R1)           POINT TO PARM AREA
         LH    R2,0(,R1)           GET LENGTH IN R2
         STM   R1,R2,PARMVALS      SAVE ADDR AND LEN
         LTR   R2,R2               IS THERE A PARM FROM USER?
         BZ    PARMEND             NO  -- TAKE DEFAULTS
         SPACE
         LA    R3,1(,R1)           IN LOOP R3 POINTS TO DATA
         LA    R2,1(,R2)           ADJUST LEN FOR 1ST PASS
PARM2    EQU   *                   EVALUATE NEXT KEYWORD
         LTR   R2,R2               IS THERE SOME LENGHT LEFT?
         BNP   PARMEND             NO  -- EVALUATION COMPLETE
         LA    R3,1(,R3)           POINT TO START OF KEYWORD
         BCT   R2,PARM2B           REDUCE LEN - BRANCH AT END
         B     PARMEND
PARM2B   EQU   *                   DETERMINE WHICH KEYWORD NOW
         CLC   =C'TYPE=',0(R3)     LIBRARY TYPE SPECIFICATION?    PAN
         BE    PARM5                                              PAN
         CLC   =C'PRINT=',0(R3)    RANGE SPECIFICATION?
         BE    PARM6               YES
         CLC   =C'SIZE=',0(R3)     SIZE OF PDS?
         BE    PARM8
         SPACE
PARM2D   EQU   *                   INVALID PARAMETER
         WTO   'INVALID PARM VALUE SPECIFIED -- PROCESSING TERMINATED'
         MVC   RETCODE,=F'16'      SET RETURN CODE TO 16
         B     RETURN              RETURN TO SCP
         SPACE
PARM5    EQU   *                   LIBRARY TYPE ANALYSIS
         LA    R3,5(,R3)           POINT PAST KEYWORD
         SH    R2,=H'5'            KEEP REMAINING LEN ACCURATE
         MVC   PARMTYPE,=F'0'      INITIALIZE SAVE AREA
         LA    R4,PARMTYPE         POINT TO SAVE AREA
         BAL   R12,PARM10          GO GET USER VAUE
         CLC   PARMTYPE,=C'FULL'   DID USER SPECIFY FULL COMPARE?
         BNE   PARM2               NO  -- USE DEFAULT VALUE 'PART'
         MVI   MLENGTH,X'4F'       YES -- SET MOVE LENGTH TO 80
         B     PARM2               NO FURTHER EVALUATION
         EJECT
PARM6    EQU   *                   RANGE PROCESSING
         LA    R3,6(,R3)           POINT PAST KEYWORD
         SH    R2,=H'6'            KEEP LEN CORRECT
         LA    R4,PARMPRNT         POINT TO FIRST SAVE AREA
         BAL   R12,PARM10          GO GET USER VALUE
         CLC   PARMPRNT(3),=C'MEM' DID USER SAY TO PRINT ENTIRE MEMBER?
         BE    PARM6H              YES
         CLC   PARMPRNT(3),=C'DIR' DID USER SAY TO PRINT DIRECTRY ONLY?
         BE    PARM6H              YES
         MVC   PARMPRNT,=C'NAME'   NO -- SET TO NAME ONLY
PARM6H   EQU   *                   EVALUATE
         B     PARM2               GO GET NEXT KEYWORD
         SPACE 2
PARM8    EQU   *                   SIZE SPECIFICATION
         LA    R3,5(,R3)           POINT TO VALUE
         SH    R2,=H'5'            CORRECT REMAINING LEN
         MVC   PARMSIZE,=F'0'      INITIALIZE SAVE AREA
         LA    R4,PARMSIZE         POINT TO SAVE AREA
         BAL   R12,PARM10          GO GET USER VALUE
PARM8D   EQU   *                   EVALUALTE
         LA    R5,PARMSIZE+3       POINT TO END OF SAVE AREA
         BAL   R12,NUMB            CONVERT VAUE TO BINARY
         CLC   PARMSIZE,=F'100'    LESS THAN 100 MEMBERS?
         BH    PARM8F              NO  -- OK
         MVC   PARMSIZE,=F'100'    PUT IN MINIMUM VALUE
PARM8F   EQU   *
         B     PARM2               AND RETURN
         SPACE 2
PARM10   EQU   *                   ISSOLATE VALUE SUPPLIED BY USER
         LA    R5,5                MAX OF FOUR CHAR + DLM ALLOWED
PARM10B  EQU   *                   MOVE VALUE TO SAVE AREA
         CLC   0(1,R3),PARMDLM     DELIMITING VALUE?
         BE    0(,R12)             YES -- WE NOW HAVE THE VALUE
         MVC   0(1,R4),0(R3)       MOVE ONE CHAR FROM PARM TO SAVE ARE
         LA    R4,1(,R4)           BUMP POINTER TO SAVE AREA
         LA    R3,1(,R3)           UPDATE PARM DATA POINTER
         BCT   R2,PARM10D          REDUCE REMAINING LEN
         BR    R12                 RETURN TO CALLER IF EXHAUSTED
PARM10D  EQU   *
         BCT   R5,PARM10B          LOOP TIL VALUE IS DONE
         B     PARM2D              MORE THAN FOUR CHARS IN VALUE
         SPACE 2
PARMEND  EQU   *                                                  PAN
         B     GETM                GET STORAGE FOR WORK AREAS AND TBLS
         EJECT
NUMB     EQU   *                   CONVERT PARM VALUE TO BINARY
* NUMB
*        R5 - PARM SAVE AREA POINTER AT ENTRY
*        R9 - LOOP CONTROL
*        R7    WORK AREA POINTER
*        R8 - PARM VALUE SAVE ARA POINTER
*
*        RETURN WITH BR R12
***********************************************************************
         SPACE 2
         LR    R8,R5               SAVE POINTER TO END OF SAVE ARA
         SH    R8,=H'3'            POINT TO START OF SAVE AREA
         LA    R7,FULL+3           POINT TO END OF WORK AREA
         LA    R9,4                MAX NUMBER OF TIMES THRU LOOP
         MVC   FULL,=C'0000'       INITIALIZE WORK AREAA
NUMB2    EQU   *                   MOVE DATA TO WORK AREA(RIGHT JUSTIFY
         CLI   0(R5),X'00'         DATA CHAR?
         BE    NUMB2D              NO  -- SKIP TO NEXT COL
         CLI   0(R5),C'0'          LESS THAN ZERO?
         BL    PARM2D              YES -- ERROR
         CLI   0(R5),C'9'          GREATERTHAN NINE
         BH    PARM2D              YES -- ERROR
         MVC   0(1,R7),0(R5)       MOVE ONE DATA CHAR
         BCTR  R7,0                BACKUP WORK AREA POINTER
NUMB2D   EQU   *
         BCTR  R5,0                BACKUP SAVE AREA POINTER
         BCT   R9,NUMB2            CHECK FOUR COLS
         SPACE
         PACK  DOUBLE,FULL         CONVERT FROM CHAR TO DECIMAL
         CVB   R7,DOUBLE           CONVERT DECIMAL TO BINARY
         ST    R7,0(,R8)           SAVE BINARY VALUE
         BR    R12                 RETURN TO CALLER
         EJECT
GETM     EQU   *                   OBTAIN STORAGE
* 1 12 BYTE ENTRY NEEDED FOR EACH NEW MEMBER
*           (8 BYTE MEMBER NAME, 2 BYTE PAGE NUMBER, 2 BYTE FLAGS)
*
* 1 12 BYTE ENTRY NEEDED FOR EACH OLD MEMBER
*           (SAME AS NEW ENTRY)
*
*
* GETM
*        R2 - PARMSIZE VALUE (ESTIMATED NUMBER OF MEMS)
*        R3 - GOTTEN STORAGE POINTER
*
*        B     NDIR
***********************************************************************
         SPACE 2
         L     R2,PARMSIZE         GET BINARY NUMBER OF MEMBERS
GETM2    EQU   *                   GET STORAGE FOR NEW OLD AND SEQ
         MH    R2,=H'24'           12 BYTES FOR NEW - 12 BYTES FOR OLD
GETM2D   EQU   *                   REQUEST STORAGE
         GETMAIN EC,LV=(R2),A=NMEM
         LTR   R15,R15             WAS SOTARAGE AVAILABLE?
         BZ    GETM4               YES -- CONTINUE
         WTO   'GETMAIN FAILURE -- RUN IN LARGER REGION'
         MVC   RETCODE,=F'16'      SET RETURN CODE TO U6
         B     RETURN              RETURN TO SCP
         SPACE 3
GETM4    EQU   *                   DIVIDE STORAGE UP
         L     R3,PARMSIZE         NUMBER OF ESTIMATED MEMBERS
         MH    R3,=H'12'           12 BYTES PER MEMBER IN EACH LIST
         L     R4,NMEM             ADDRESS OF OBTAINED STORAGE
         AR    R4,R3               END OF FIRST LIST
         ST    R4,OMEM             START ADDR OF OLD MEMBER LIST
         EJECT
GETM6    EQU   *
******************************************************************
*        THIS CODE HAS BEEN MOVED FROM THE YALE COMP PGM         *
******************************************************************
         GETMAIN VU,LA=MIN,A=STARTADD    GET ALL AVAILABLE STORAGE
         LM    R0,R2,FOURK         LOAD 4K, START, SIZE
         SR    R2,R0               SUBTRACT OFF 4K
         ST    R2,SIZE             UPDATE REGION SIZE
         AR    R1,R2               LAST USEABLE BYTE
         ST    R1,HIGHCORE         SAVE FOR LATER
         SPACE
         FREEMAIN R,LV=(0),A=(1)   FREE THE 4K DYNAMIC AREA
         L     R2,STARTADD         STARTADD
         ST    R2,FIRSTIG          SAVE AS FIRST IGNORE ADDR
         OPEN  (SYSPRINT,OUTPUT,IGNORE)
         TM    IGNORE+48,X'10'     DID IGNORE OPEN?
         BO    GETIG               YES -- GO READ AND STORE
         MVC   FIRSTIG(8),IGASMS   NO  -- FIRST AND LAST IGNORES
         ST    R2,LASTIG
         B     NDIR
GETIG    GET   IGNORE,(R2)         GET A RECORD
         LA    R2,80(,R2)          BUMP PONITER
         B     GETIG               READ TIL END OF FILE
ENDIG    CLOSE (IGNORE)            CLOSE THE DCB
         ST    R2,LASTIG           SAVE ADDR OF LAST IGNORE REC
         SPACE 3
         B     NDIR                GO PROCESS NEW DIRECTORY
         EJECT
NDIR     EQU   *                   OPEN AND PROCEES NEW DIRECTORY
*
* NDIR
*        R1 - WORK REG
*        R2 - LOOP CONTROL (MAX NUMBER OF MEMS)
*        R3 - POINTER TO NEW DIRECTORY LIST
*        R4 - DIRECTORY RECORD POINTER IN WORK AREA
*
*        BAL   R12,JSORT    SORT ENTRIES IN DESIRED SEQUENCE
*        B     ODIR
***********************************************************************
         RDJFCB (NEWDCB)
         MVC   NEWDSN,NEWJFCB
         MVC   NEWVOL,NEWJFCB+118
         RDJFCB (OLDDCB)
         MVC   OLDDSN,OLDJFCB
         MVC   OLDVOL,OLDJFCB+118
         SPACE 2
         RDJFCB (NEWDIR,,OLDDIR)   GET JFCB DATA FROM DD STATEMENT
         OI    NJFCB+52,X'0A'      TURN ON DON'T MERGE DCB TO JFCB BIT
         OI    OJFCB+52,X'0A'      TURN ON DON'T MERGE DCB TO JFCB BIT
         MVC   NJFCB+44(8),BLANK   SET MEMBER NAME TO BLANKS
         MVC   OJFCB+44(8),BLANK   SET MEMBER NAME TO BLANKS
         OPEN  (NEWDIR,INPUT,OLDDIR,INPUT),TYPE=J
         SPACE 2
         L     R2,PARMSIZE         ESTIMATED MEMBER COUNT
         L     R3,NMEM             POINT TO START OF LIST
NDIR2    EQU   *                   READ A DIRECTORY BLOCK
         READ  NDIR2ECB,SF,NEWDIR,DIRWORK
         CHECK NDIR2ECB            WAIT TIL READ COMPLETES
         LA    R4,DIRWORK+10       POINT PAST KEY TO FIRST DATA
NDIR2B   EQU   *                   PROCESS DIRECTORY LBOCK
         CLC   0(8,R4),=8X'FF'     LOGICAL END OF DATA?
         BE    NEWDEOD             YES -- TREAT AS PHYSICAL EOD
         MVC   0(08,R3),0(R4)      MEMBER NAME
         MVC   8(4,R3),=4X'0000FFFF' PAGE NUM. AND FLAGS
NDIR2D   EQU   *
         CLC   DIRWORK(8),0(R4)    AT END OF BLOCK?
         BNE   NDIR2F              NO  -- UPDATE POINTERS AND CONT.
         LA    R3,12(,R3)          YES -- POINT TO NEXT NEW MEMBER ENT
         BCT   R2,NDIR2                   READ NEXT BLOCK
         B     NDIR2H                     LIST EXCEEDED
         SPACE
NDIR2F   EQU   *
         SR    R1,R1               CLEAR WORK REG
         IC    R1,11(R4)           GET TYPE BYTE FROM DIRECTRY
         N     R1,=X'0000001F'     COUNT OF USER HALF WORDS
         MH    R1,=H'2'            NOW COUNT OF USER BYTES
         LA    R4,12(R1,R4)        POINT TO LNEXT ENTRY IN BLOCK
         LA    R3,12(,R3)          NEXT NEW MEMBER ENTRY
         BCT   R2,NDIR2B           PROCESS NEXT ENTRY IN BLOCK
NDIR2H   EQU   *                   TOO MANY MEMBERS
         WTO   'TOO MANY MEMBERS IN PDS -- PARM=''SIZE=XXX'' NEEDED'
         MVC   RETCODE,=F'16'      SET RETURN CODE
         B     RETURN              RETURN TO SCP
         SPACE 3
NEWDEOD  EQU   *
         MVC   0(8,R3),=X'FF'      SET LOGICAL END OF LIST
         CLOSE (NEWDIR)            CLOSE THE DIRECTORY DCB
         B     ODIR                PROCESS OLD DIRECTORY
         EJECT
ODIR     EQU   *                   PROCESS OLD DIRECTORY
*
* ODIR
*        R1 - WORK REG
*        R2 - LOOP CONTROL (MAX NUMBER OF MEMS)
*        R3 - POINTER TO OLD DIRECTORYL IST
*        R4 - DIRECTORY RECORD POINTER IN WORK AREA
*
*        B     OPEN1
***********************************************************************
         SPACE 2
         L     R2,PARMSIZE         NUMBER OF ESTIMATED MEMBERS
         L     R3,OMEM             POINT TO OLD MEMER LIST
ODIR2    EQU   *                   READ A DIRECTORY BLOCK
         READ ODIR2ECB,SF,OLDDIR,DIRWORK
         CHECK ODIR2ECB            WAIT TILL READ COMPLETES
         LA    R4,DIRWORK+10       POINT PAST KEY TO FIRST DATA
ODIR2B   EQU   *
         CLC   0(8,R4),=8X'FF'     LOGOCAL END OF DATA?
         BE    OLDDEOD             YES -- SAME AS PYSICAL EOD
         MVC   0(08,R3),0(R4)      MEMBER NAME
         MVC   8(4,R3),=4X'0000FFFF' PAGE NUMBER AND FLAGS
ODIR2D   EQU   *
         CLC   DIRWORK(8),0(R4)    AT END OF BLOCK?
         BNE   ODIR2F              NO
         LA    R3,12(,R3)          YES -- POINT TO NEXT OLD ENTRY
         BCT   R2,ODIR2                   READ NEXT BLOCK
         B     ODIR2H                     ESTIMATED MEMBERS EXCEEDED
         SPACE 3
ODIR2F   EQU   *
         SR    R1,R1               CLEAR WORK REG
         IC    R1,11(,R4)          GET TYPE BYTE
         N     R1,=X'0000001F'     ISOLATE USER HALF WORDS
         MH    R1,=H'2'            NOW USER BYTES
         LA    R4,12(R1,R4)        POINT TO NEXT DIRECTRY ENTRY
         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER ENTRY
         BCT   R2,ODIR2B           PROCESS NEXT ENTRY
ODIR2H   EQU   *
         B     NDIR2H
         SPACE 3
OLDDEOD  EQU   *                   END OF DATA FOR DIRECTORY
         MVC   0(8,R3),=X'FF'      LOGICAL END OF DATA
         CLOSE (OLDDIR)            CLOSE DIRECTORY
         B     LOOP
         EJECT
LOOP     EQU   *                   LOOP THRU DIRECTORIES
         L     R2,NMEM             R2 POINTS TO NEXT MEMBER IN NEW PDS
         L     R3,OMEM             R3 POINTS TO NEXT MEMBER IN OLD PDS
LOOP1    EQU   *                   COMPARE NEW TO OLD
         CLC   0(8,R2),0(R3)
         BE    COMPARE             SAME MEMBER NAME IN OLD AND NEW
         BL    NEWONLY             MEMBER IS ONLY IN NEW PDS
         BH    OLDONLY             MEMBER IS ONLY IN OLD PDS
         EJECT
COMPARE  EQU   *                   COMPARE OLD AND NEW MEMBERS
         CLI   0(R2),X'FF'         EQUAL AND X'FF'?
         BE    DIR                 YES -- TIME TO PRINT DIRECTORY
         MVC   OLDJFCB+44(8),0(R3) MOVE IN OLD MEMBER NAME
         MVC   NEWJFCB+44(8),0(R2) MOVE IN NEW MEMBER NAME
         MVC   OLDMEM,0(R3)
         MVC   NEWMEM,0(R3)
         OI    OLDJFCB+52,X'08'    DONT REWRITE JFCB
         OI    NEWJFCB+52,X'08'    DONT REWRITE JFCB
         OI    OLDJFCB+86,X'01'    DATA SET IS MEMBER OF PDS
         OI    NEWJFCB+86,X'01'    DATA SET IS MEMBER OF PDS
         CLC   PARMPRNT(3),=C'DIR' DIRECTORY ONLY?
         BE    COMPARE2
         OPEN  (OLDDCB,,NEWDCB),TYPE=J   ADD MEMBER NAMES TO JFCB
         BAL   R12,PAGE            TOP OF FORM
         BAL   R12,YALECOMP        GO DO THE COMPARISON
         MVC   10(2,R2),RC         SAVE RETURN CODE
         MVC   10(2,R3),RC         SAVE RETURN CODE
COMPARE2 EQU   *
*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP
         LA    R2,12(,R2)          POINT TO NEXT NEW MEMBER NAME
         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER NAME
         B     LOOP1               NOW GO CHECK CURRENT STATUS
         SPACE 3
NEWONLY  EQU   *                   COMPARE OLD AND NEW MEMBERS
         MVC   NEWJFCB+44(8),0(R2) MOVE IN NEW MEMBER NAME
         MVC   NEWMEM,0(R2)
         OI    NEWJFCB+52,X'08'    DONT REWRITE JFCB
         OI    NEWJFCB+86,X'01'    DATA SET IS A MEMBER OF PDS
         MVC   OLDMEM,=8C'*'       INDICATE NO MEMBER IN OLD PDS
         CLC   PARMPRNT(3),=C'MEM' DOES USER WANT MEMBERS?
         BNE   NEWONLY2            NO  -- SKIP YALECOMP
         OPEN  (NEWDCB),TYPE=J     ADD MEMBER NAMES TO JFCB
         BAL   R12,PAGE            TOP OF FORM
         BAL   R12,YALECOMP        YES -- COMPARE WILL LIST NEW
         MVC   10(2,R2),=X'0005'          NO MATCHING MEMBER
NEWONLY2 EQU   *
*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP
         LA    R2,12(,R2)          POINT TO NEXT NEW MEMBER NAME
         B     LOOP1               NOW GO CHECK CURRENT STATUS
         SPACE 3
OLDONLY  EQU   *                   COMPARE OLD AND NEW MEMBERS
         MVC   OLDJFCB+44(8),0(R3) MOVE IN OLD MEMBER NAME
         MVC   OLDMEM,0(R3)
         OI    OLDJFCB+52,X'08'    DONT REWRITE JFCB
         OI    OLDJFCB+86,X'01'    DATA SET IS MEMBER OF PDS
         MVC   NEWMEM,=8C'*'       INDICATE NO MEMBER IN NEW PDS
         CLC   PARMPRNT(3),=C'MEM' DOES USER WANT MEMBERS?
         BNE   OLDONLY2            NO  -- SKIP YALECOMP
         OPEN  (OLDDCB),TYPE=J     ADD MEMBER NAMES TO JFCB
         BAL   R12,PAGE            TOP OF FORM
         BAL   R12,YALECOMP        YES -- COMPARE WILL LIST NEW
         MVC   10(2,R3),=X'0005'
OLDONLY2 EQU   *
*        CLOSE (OLDDCB,,NEWDCB)    CLOSE IS DONE BY YALE COMP
         LA    R3,12(,R3)          POINT TO NEXT OLD MEMBER NAME
         B     LOOP1               NOW GO CHECK CURRENT STATUS
         EJECT
PAGE     EQU   *                   TOP OF FORM ROUTINE
         LH    R1,PAGECNT          GET OLD PAGE COUNT
         LA    R1,1(,R1)           ADD ONE
         STH   R1,PAGECNT          SAVE FOR NEXT TIME
         CLC   OLDMEM,=8C'*'       IS THERE AN OLD MEMBER NAME
         BE    PAGE2               NO  -- DON'T TRY TO SAVE PAGE NO.
         STH   R1,8(,R3)           YES -- SAVE PAGE NUMBER
PAGE2    EQU   *
         CLC   NEWMEM,=8C'*'       IS THERE A NEW MEMBER NAME
         BE    PAGE4               NO  -- DON'T TRY TO SAVE PAGE NO.
         STH   R1,8(,R2)           YES -- SAVE PAGE NUMBER
PAGE4    EQU   *
         CVD   R1,DOUBLE           CONVERT PAGE NUMBER TO PACKED
         UNPK  PAGENO,DOUBLE       NOW CHARACTER
         OI    PAGENO+3,C'0'       NOW FIX SIGN
         PUT   SYSPRINT,EJECT      GO TO TOP OF FORM AND PRINT PAGE
         PUT   SYSPRINT,NEWHDG     PRINT NEW PDS DSN AND MEMBER NAME
         PUT   SYSPRINT,OLDHDG     PRINT OLD PDS DSN AND MEMBER NAME
         BR    R12                 RETURN TO CALLER
         EJECT
DIR      EQU   *                   PRINT DIRECTORY
         MVC   OLDMEM,=CL8'* OLD *'
         MVC   NEWMEM,=CL8'* NEW *'
         BAL   R12,PAGE
         SPACE 3
         L     R2,NMEM             LIST OF NEW MEMBERS
         L     R3,OMEM             LIST OF OLD MEMBERS
DIR2     EQU   *
         CLC   0(8,R2),0(R3)       OLD AND NEW MATCH?
         BE    DIRE                MEMBER IN EACH
         BL    DIRN                ONLY NEW MEMBER
         BH    DIRO                ONLY OLD MEMBER
         SPACE  2
DIRE     EQU   *                   MEMBER IN EACH
         CLI   0(R2),X'FF'         BOTH EQUAL AND X'FF'
         BE    CLOSE               YES -- DIRECTORY IS DONE
         MVC   DIRLOLD,0(R3)       OLD MEMBER NAME
         MVC   DIRLNEW,0(R2)       NEW MEMBER NAME
         LH    R4,8(,R2)           PAGE NUMBER
         CVD   R4,DOUBLE           CONVERT TO PACKED
         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER
         OI    DIRLPGE+3,C'0'      NOW FIX SIGN
         MVC   DIRLEQ,BLANK
         MVC   DIRLNEQ,BLANK
         MVC   DIRLMTCH,BLANK
         CLI   11(R2),X'00'        EQUAL MATCH
         BNE   DIRE2               NO
         MVC   DIRLEQ,=CL8'EQUAL'
         B     DIRE10
DIRE2    EQU   *
         CLI   11(R2),X'04'        NOT EQUAL
         BNE   DIRE4               NO
         MVC   DIRLNEQ,=CL9'NOT EQUAL'
         B     DIRE10
DIRE4    EQU   *
         CLI   11(R2),X'05'        NO MATCH
         BNE   DIRE10
         MVC   DIRLMTCH,=CL8'NO MATCH'
DIRE10   EQU   *
         PUT   SYSPRINT,DIRLINE    PRINT THE LINE
         MVI   DIRLCC,C' '
         LA    R2,12(,R2)          NEXT NEW MEMBER
         LA    R3,12(,R3)          NEWT OLD MEMBER
         B     DIR2                LOOP TILL DONE
         EJECT
DIRN     EQU   *                   MEMBER IN EACH
         MVC   DIRLOLD,BLANK       OLD MEMBER NAME
         MVC   DIRLNEW,0(R2)       NEW MEMBER NAME
         LH    R4,8(,R2)           PAGE NUMBER
         CVD   R4,DOUBLE           CONVERT TO PACKED
         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER
         OI    DIRLPGE+3,C'0'      NOW FIX SIGN
         MVC   DIRLEQ,BLANK
         MVC   DIRLNEQ,BLANK
         MVC   DIRLMTCH,=CL8'NO MATCH'
DIRN10   EQU   *
         PUT   SYSPRINT,DIRLINE    PRINT THE LINE
         MVI   DIRLCC,C' '
         LA    R2,12(,R2)          NEXT NEW MEMBER
         B     DIR2                LOOP TILL DONE
         SPACE 3
DIRO     EQU   *                   MEMBER IN EACH
         MVC   DIRLOLD,0(R3)       OLD MEMBER NAME
         MVC   DIRLNEW,BLANK       NEW MEMBER NAME
         LH    R4,8(,R3)           PAGE NUMBER
         CVD   R4,DOUBLE           CONVERT TO PACKED
         UNPK  DIRLPGE,DOUBLE      NOW CHARACTER
         OI    DIRLPGE+3,C'0'      NOW FIX SIGN
         MVC   DIRLEQ,BLANK
         MVC   DIRLNEQ,BLANK
         MVC   DIRLMTCH,=CL8'NO MATCH'
DIRO10   EQU   *
         PUT   SYSPRINT,DIRLINE    PRINT THE LINE
         MVI   DIRLCC,C' '
         LA    R3,12(,R3)          NEXT NEW MEMBER
         B     DIR2                LOOP TILL DONE
         SPACE 3
CLOSE    EQU   *
         CLOSE (SYSPRINT)
         B     RETURN
         EJECT
         LTORG
         SPACE 3
BLANK    DC    80C' '
FULL     DC    F'0'
DOUBLE   DC    D'0'
PAGECNT  DC    H'0'
         SPACE 3
         EJECT
PARMVALS DS    0F                  PARAM REALTED VALUES
PARMADDR DC    F'0'                ADDR OF USER PARM
PARMLEN  DC    F'0'                LEN OF USER PARM
PARMPRNT DC    F'0'                PRINT NAME ONLY OR ENTIRE MEMBER
*ARMSIZE DC    F'1000'             ESTIMATED NUMBER MEMBERS IN PDS
PARMSIZE DC    F'9999'             ESTIMATED NUMBER MEMBERS IN PDS
PARMTYPE DC    F'0000'             LIBRARY TYPE                   PAN
PARMDLM  DC    C','                PARM VALUE DELIMITOR
         SPACE 3
         EJECT
NMEM     DC    F'0'                ADDR OF NEW MEMBER LIST
NMEMS    EQU   NMEM
OMEM     DC    F'0'                ADDR OF OLD EMMBER LIST
OMEMS    EQU   OMEM
         PRINT NOGEN
OLDDAD1  EQU   *
OLDDIR   DCB   BLKSIZE=256,DEVD=DA,DSORG=PS,DDNAME=OLD,EXLST=OXLST,    X
               KEYLEN=8,LRECL=256,MACRF=(R),RECFM=F,EODAD=OLDDEOD
         SPACE 3
NEWDAD1  EQU   *
NEWDIR   DCB   BLKSIZE=256,DEVD=DA,DSORG=PS,DDNAME=NEW,EXLST=NXLST,    X
               KEYLEN=8,LRECL=256,MACRF=(R),RECFM=F,EODAD=NEWDEOD
         SPACE 3
OXLST    DS    0F
         DC    X'87'
         DC    AL3(OJFCB)
         SPACE
OJFCB    DC    CL176' '
         SPACE 3
NXLST    DS    0F
         DC    X'87'
         DC    AL3(NJFCB)
         SPACE
NJFCB    DC    CL176' '
         SPACE 3
OLDXLIST DS    0F
         DC    X'05'
         DC    AL3(DCBEXIT)
OLDXLST2 EQU   *
         DC    X'87'
         DC    AL3(OLDJFCB)
         SPACE
OLDJFCB  DC    CL176' '
         SPACE 3
NEWXLIST DS    0F
         DC    X'05'
         DC    AL3(DCBEXIT)
NEWXLST2 EQU   *
         DC    X'87'
         DC    AL3(NEWJFCB)
         SPACE
NEWJFCB  DC    CL176' '
         EJECT
DIRWORK  DS    CL264               WORK AREA FOR DIRECOTRY BLOCK READS
         SPACE
MEMBR    DC    CL8' ',C'  '        SAVE AREA FOR MEMBER NAMES
MEMBR1   DC    CL8' '              SAVE AREA FOR MEMBER NAMES
MEMBR2   DC    CL8' '              SAVE AREA FOR MEMBER NAMES
OLDBLKSZ DC    F'0'                BLOCKSIZE FOR OLD PDS
NEWBLKSZ DC    F'0'                BLOCKSIZE FOR NEW PDS
OLDBLKA  DC    F'0'                ADDR OF OLD PDS BUFFER FOR READS
NEWBLKA  DC    F'0'                ADDR OF NEW BUFFER FOR READS
NEWBLKE  DC    F'0'                END ADDR FOR NEW BUFFER
OLDBLKE  DC    F'0'                END OF BUFFER ADDR FOR OLD
         EJECT
EJECT    DC    CL109' '
         ORG   EJECT
         DC    C'1',C'PAGE  '
PAGENO   DC    CL4' '
         ORG   EJECT+109
         SPACE 2
NEWHDG   DC    CL109' '
         ORG   NEWHDG
         DC    C'-',C'VOL=SER='
NEWVOL   DC    CL6' ',C'  MEMBER='
NEWMEM   DC    CL8' ',C'  NEW DSN='
NEWDSN   DC    CL44' '
         ORG   NEWHDG+109
         SPACE 3
OLDHDG   DC    CL109' '
         ORG   OLDHDG
         DC    C'-',C'VOL=SER='
OLDVOL   DC    CL6' ',C'  MEMBER='
OLDMEM   DC    CL8' ',C'  OLD DSN='
OLDDSN   DC    CL44' '
         ORG   OLDHDG+109
         SPACE 3
DIRLINE  DC    CL109' '
         ORG   DIRLINE
DIRLCC   DC    C'-',C'OLD MEM='
DIRLOLD  DC    CL8' ',C' PAGE '
DIRLPGE  DC    CL4' ',C' NEW MEM='
DIRLNEW  DC    CL8' ',C' '
DIRLEQ   DC    CL8' ',C' '
DIRLNEQ  DC    CL9' ',C' '
DIRLMTCH DC    CL8' ',C' '
         ORG   DIRLINE+109
*          DATA SET CBT881     AT LEVEL 003 AS OF 01/31/79
 TITLE 'YALE COMPARE     ---  BRUCE LELAND   ---  VERSION 2.0    '
*     CMPRSEQ  CSECT
*
*   THIS COMPARE PROGRAM ORIGINATED AT YALE UNIVERSITY AND WAS OBTAINED
*     FROM THE CONNECTICUT BANK AND TRUST COMPANY MODS TAPE (FILE 226)
*
*   THIS COMPARE PROGRAM USES ONLY COLUMNS ONE THROUGH 72; THUS, ANY
*     TWO VERSIONS OF A PROGRAM MAY BE EASILY COMPARED EVEN IF ONE
*     (OR BOTH) OF THE FILES HAS BEEN RESEQUENCED.  IF NEITHER FILE
*     HAS BEEN RESEQUENCED, A PARM OF "FULL" MAY BE CODED TO REQUEST
*     THAT ALL EIGHTY COLUMNS BE USED IN THE COMPARISON.  A FACILITY
*     IS ALSO PROVIDED TO IGNORE TRIVIAL CARD IMAGES (SUCH AS " EJECT "
*     OR " SPACE 3 " IN AN ASSEMBLER SOURCE PROGRAM).
*
*   THIS PROGRAM USES ALL AVAILABLE CORE IN ITS REGION AFTER OPENING
*     ITS INPUT/OUTPUT FILES (EXCEPT FOR 4K WHICH IS RELEASED).  THE
*     OBTAINED CORE AREA IS USED AS A COMPARE BUFFER WHICH IS ONLY
*     DUMPED (WRITTEN TO SYSPRINT) WHEN IDENTICAL RECORDS (BASED ON
*     THE FIRST 72 BYTES) ARE FOUND IN THE OLD AND NEW DATA SETS.  IF
*     THE COMPARE BUFFER OVERFLOWS, THE PROGRAM TERMINATES.  THEREFORE,
*     IF IT IS SUSPECTED THAT THE TWO DATA SETS MAY BE VERY FAR OUT OF
*     SYNC, A LARGE REGION SHOULD BE USED.  THE NUMBER OF UNMATCHED
*     RECORDS THAT CAN BE BUFFERED AT ONE TIME CAN BE CALCULATED FROM
*     THE EXPRESSION:  (REGION SIZE - 8K - BUFFERS) / 160
*     AS A GENERAL RULE, 30K IS SUFFICIENT FOR ABOUT 100 UNMATCHED
*     RECORDS AT A TIME, AND 100K IS SUFFICIENT FOR ABOUT 500 UNMATCHED
*     RECORDS AT A TIME.
*
*   CARD IMAGES OF THE TRIVAL DATA IS INPUT FROM THE IGNORE DDNAME;
*     IF THE DDCARD IS MISSING, A TABLE OF TRIVIAL DATA FOR ASSEMBLER
*     SOURCE CODE WILL BE ASSUMED (THIS INCLUDES " EJECT ", " SPACE   "
*     " SPACE 1 ", " SPACE 2 ", " SPACE 3 " AND BLANK COMMENT CARDS).
*
*
*
*   THE PROGRAM FORMAT ON THE CBT MODS TAPE WAS DISASSEMBLED SOURCE; IT
*     WAS RECOMMENTED, RESYMBOLIZED, REDOCUMENTED AND SLIGHTLY MODIFIED
*     BY  A. BRUCE LELAND (ABL)  OCTOBER, 1978
*
*
*   JCL:
*
*   //STEPNAME   EXEC  PGM=COMPARE,REGION=100K
*   //OLD        DD    DSN=OLD.SEQ.DSN ....
*   //NEW        DD    DSN=NEW.SEQ.DSN ....
*   //SYSPRINT   DD    SYSOUT=A
*   //IGNORE     DD    *      (OR DUMMY  --  OR OMITTED)
*     TRIVIAL CARD IMAGES THAT ARE TO BE IGNORED IN THE COMPARISON
*   /*
*
         EJECT
*        USING CMPRSEQ,R15
         DS    0D
YALECOMP EQU   *
         CLC   PARMPRNT(3),=C'DIR'
         BE    0(,R12)            USER ONLY WANT DIRECTORY LIST
         PRINT GEN
*        SAVE  (14,12),,*
         STM   R0,R15,SAVE
*        LR    R11,R13
*        LA    R13,SAVE
*        USING SAVE,R13
*        ST    R13,8(,R11)
*        ST    R11,4(,R13)
         B     INIT
SAVE     DC    18F'0'
*PARM     L     R1,0(,R1)
*         CLC   2(4,R1),FULL
*         BNE   OPEN
*         MVI   MLENGTH,X'4F'
*OPEN     OPEN  (NEW,,OLD,,SYSPRINT,OUTPUT,IGNORE)
*         SPACE
*         GETMAIN VU,LA=MIN,A=STARTADD      GET ALL AVAILABLE CORE
*         LM    R0,R2,FOURK                 LOAD 4K, START, SIZE
*         SR    R2,R0                       SUBTRACT OFF 4K
*         ST    R2,SIZE                     UPDATE REGION SIZE
*         AR    R1,R2                       LAST USEABLE BYTE
*         ST    R1,HIGHCORE                 SAVE FOR LATER
*         SPACE
*         FREEMAIN R,LV=(0),A=(1)           FREE THE 4K DYNAMIC AREA
*         L     R2,STARTADD
*         ST    R2,FIRSTIG
*         TM    IGNORE+48,X'10'             IGNORE OPEN?
*         BO    GETIG                       YES, BRANCH             ABL
*         MVC   FIRSTIG(8),IGASMS           FIRST AND LAST IGNORES  ABL
*         B     NOIG                          FOR ASSEMBLER SOURCE  ABL
*         SPACE
*GETIG    GET   IGNORE,(2)
*         LA    R2,80(,R2)
*         B     GETIG
*         SPACE
*ENDIG    CLOSE (IGNORE)
*         ST    R2,LASTIG                                          ABL
INIT     EQU   *
         L     R2,LASTIG           ADDRESS OF GOTTEN BUFFER+ IGNORES
         L     R3,SIZE             SIZE OF GOTTEN BUFFER
         S     R3,LASTIG
         A     R3,STARTADD         SIZE OF BUFFER TO BE CLEARED
         LA    R8,=F'0'            FULL WORD OF HEX ZERO
         LA    R9,4                LENGTH OF 2ND OPERAND + FILLER CHAR
         MVCL  R2,R8
         L     R2,LASTIG
         XC    COUNT,COUNT
         XC    RC,RC
         ST    R2,LOWOLD                                           ABL
         ST    R2,HIGHOLD
         ST    R2,CURROLD
         LA    R2,80(,R2)
         ST    R2,LOWNEW
         ST    R2,HIGHNEW
         ST    R2,CURRNEW
         LA    R8,OLDDCB
         LA    R9,NEWDCB
         ZAP   OLDCNT,=P'-1'        ALLOW FOR GET ON END OF DATA
         ZAP   NEWCNT,=P'-1'        ALLOW FOR GET ON END OF DATA
*
*    THIS COMPLETES THE PROGRAM INITIALIZATION
         EJECT
SWAP     XR    R9,R8
         XR    R8,R9
         XR    R9,R8
         L     R3,CURR(,R9)
         C     R3,HIGH(,R9)
         BL    NOINPUT
         TM    48(R9),X'10'            CURRENT DCB OPEN?
         BZ    SWAP                    NO, BRANCH (AND SWAP)
         LA    R1,0(,R9)
         C     R1,=A(NEWDCB)
         BE    SWAP2
         AP    OLDCNT,=P'1'
         B     SWAP4
SWAP2    EQU   *
         AP    NEWCNT,=P'1'
SWAP4    EQU   *
         GET   (1)
         LA    R0,80(,R3)
         C     R0,HIGHCORE             FIT IN CORE?
         BH    NOTCORE                 NO, BRANCH
         MVC   0(80,R3),0(R1)
         LA    R0,160(,R3)
         ST    R0,HIGH(,R9)
         SPACE 2
*  SEE IF THIS RECORD IS ANYWHERE IN THE OTHER BUFFER
*
NOINPUT  L     R2,LOW(,R8)
         IC    R1,MLENGTH
NEXT8    C     R2,CURR(,R8)
         BNL   NO8
         CLC   0(1,R3),0(R2)
         EX    R1,*-6
         BE    FOUND8
         LA    R2,160(,R2)
         B     NEXT8
NO8      LA    R3,160(,R3)          NOT IN THE BUFFER,
         ST    R3,CURR(,R9)           UPDATE THE CURRENT POINTER
         B     SWAP
         SPACE 2
*    DOES NOT FIT IN THE ALLOCATED CORE
*
NOTCORE  BAL   R12,NOTEQUAL               OUTPUT NOT EQUAL MESSAGE
         CLOSE (NEWDCB,,OLDDCB)
         MVI   RC+1,8                     RETURN CODE 8
         MVC   BUFFER(35),CORE-1          CORE OVERFLOW MESSAGE
         MVC   BUFFER+35(74),BUFFER+34    CLEAR THE REMAINDER
         PUT   SYSPRINT,BUFFER
         MVI   BUFFER,X'40'
         B     CORETERM
         EJECT
*   RECORD WAS FOUND -- SEE IF IT IS TO BE IGNORED
*
FOUND8   CLC   CURR(4,R9),LOW(R9)           RECORDS IN ACTIVE BUFFER?
         BNE   CHKIG                        YES, CHECK IGNORES
         ST    R2,CURR(,R8)
         B     IGEQUAL
CHKIG    L     R15,FIRSTIG                FIRST IGNORE
LOOPIG   C     R15,LASTIG                 LAST IGNORE?
         BNL   NOTIG                      YES, BRANCH
         CLC   0(1,R3),0(R15)
         EX    R1,*-6                     AN IGNORE RECORD?
         BE    NO8                        YES, BRANCH
         LA    R15,80(,R15)
         B     LOOPIG                     CHECK ALL IGNORES
*
NOTIG    ST    R2,CURR(,R8)               NOT AN IGNORE RECORD
         BAL   R12,NOTEQUAL               OUTPUT "NOT EQUAL"
IGEQUAL  BAL   R12,INBUFF                 ADD TO COMPARE BUFFER
         XR    R9,R8
         XR    R8,R9
         XR    R9,R8
         BAL   R12,INBUFF                 ADD TO OTHER BUFFER
         B     SWAP
         SPACE 2
*  END OF FILE (OLD OR NEW)
*
EOLDNEW  CLOSE ((9))                      CLOSE THE CURRENT FILE
         XR    R9,R8
         XR    R8,R9
         XR    R9,R8
         TM    48(R9),X'10'               OTHER FILE STILL OPEN?
         BNZ   SWAP                       YES, BRANCH
         CLC   LOWOLD(4),HIGHOLD          BUFFER EMPTY?
         BNE   *+14                       NO, BRANCH
         CLC   LOWNEW(4),HIGHNEW          OTHER BUFFER EMPTY TOO?
         BE    TRIPLE                     YES, QUIT
         BAL   R12,NOTEQUAL               FLUSH THE CURRENT BUFFERS
         B     TRIPLE
         EJECT
*  TERMINATE -- LIST NUMBER OF UNEQUAL COMPARES
*
TRIPLE   MVI   BUFFER,C'-'
CORETERM MVC   BUFFER+1(6),EDCOUNT          EDIT MASK
         MVC   BUFFER+7(35),BLOCKS          UNEQUAL BLOCKS MESSAGE
         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER
         LH    R1,COUNT
         CVD   R1,DOUBLE
         ED    BUFFER+1(6),DOUBLE+5
         PUT   SYSPRINT,BUFFER
         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER
         CP    NEWCNT,=P'-1'
         BNE   CKCNT2
         ZAP   NEWCNT,=P'0'
CKCNT2   EQU   *
         CP    OLDCNT,=P'-1'
         BNE   CKCNT4
         ZAP   OLDCNT,=P'0'
CKCNT4   EQU   *
         MVI   BUFFER,C'-'
         MVC   BUFFER+1(6),EDCOUNT          EDIT MASK
         MVC   BUFFER+7(35),NEWCMSG         UNEQUAL BLOCKS MESSAGE
         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER
         ED    BUFFER+1(6),NEWCNT+5
         PUT   SYSPRINT,BUFFER
         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER
         MVI   BUFFER,C' '
         MVC   BUFFER+1(6),EDCOUNT          EDIT MASK
         MVC   BUFFER+7(35),OLDCMSG         UNEQUAL BLOCKS MESSAGE
         MVC   BUFFER+42(67),BUFFER+41      BLANK REMAINDER
         ED    BUFFER+1(6),OLDCNT+5
         PUT   SYSPRINT,BUFFER
         MVC   BUFFER+7(35),BLANK   CLEAR MESSAGE FROM BUFFER
*        CLOSE (SYSPRINT)           CLOSE IS DONE BY FRONT END
         LH   R15,RC
*        L    R13,4(,R13)                                           ABL
*        RETURN (14,12),RC=(15)                                     ABL
         LM    R0,R14,SAVE
         BR    R12
         SPACE 2
*  RE-INITIALIZE THE ACTIVE BUFFER -- SLIDE UNUSED RECORDS DOWN
*
INBUFF   L     R1,LOW(,R9)
         L     R2,CURR(,R9)
         ST    R1,CURR(,R9)
NXTREC   LA    R2,160(,R2)
         C     R2,HIGH(,R9)                  FINISHED REINITIALIZING?
         BNL   REINIT                        YES, BRANCH
         MVC   0(80,R1),0(R2)
         LA    R1,160(,R1)
         B     NXTREC
REINIT   ST    R1,HIGH(,R9)                  RESET MAXIMUM POINTER
         BR    R12
         EJECT
*     FLUSH OUT THE NON-EQUAL RECORDS
*
NOTEQUAL MVI   RC+1,4                  RETURN CODE 4
         LH    R1,COUNT
         LA    R1,1(,R1)
         STH   R1,COUNT
         MVI   BUFFER,C'-'
         LA    R3,OLDDCB
MOVES    MVC   BUFFER+9(3),OLDNEW(R3)
         MVC   BUFFER+98(3),OLDNEW(R3)
         MVI   BUFFER+7,C'-'
         MVI   BUFFER+102,C'-'
         ZAP   NUMBER(3),ZERO
         L     R5,LOW(,R3)
FLUSHED  C     R5,CURR(,R3)               IS THIS BUFFER FLUSHED?
         BNL   GETNEW                     YES, BRANCH
         MVC   BUFFER+15(80),0(R5)
         AP    NUMBER(3),ONE
         MVC   DOUBLE(6),EDMKPAT
         EDMK  DOUBLE(6),NUMBER
         LA    R14,DOUBLE+5
         SR    R14,R1
         STC   R14,MOVEA+1
         NOPR  R0
MOVEA    MVC   BUFFER+103(1),0(R1)
         LA    R15,BUFFER+104(R14)
         MVI   0(R15),X'60'
         LA    R14,1(,R14)
         STC   R14,MOVEB+1
         LA    R1,BUFFER+6
         SR    R1,R14
MOVEB    MVC   0(1,R1),BUFFER+102
         PUT   SYSPRINT,BUFFER
         MVI   BUFFER,X'40'
         LA    R5,160(,R5)
         B     FLUSHED
*
GETNEW   LA    R1,NEWDCB
         CR    R3,R1                      NEW DONE?
         BER   R12                        YES, RETURN
         LR    R3,R1                      NOW SETUP THE NEW BUFFER
         MVC   BUFFER+1(7),BLANKS
         MVI   BUFFER+9,C'-'
         MVC   BUFFER+10(91),BUFFER+9
         MVC   BUFFER+102(7),BLANKS
         PUT   SYSPRINT,BUFFER            CENTER LINE OF DASHES
         MVI   BUFFER,X'40'
         B     MOVES
         EJECT
*        DCB EXIT ROUTINE (USED BY ALL FILES)
*
DCBEXIT  LH    R3,62(,R1)                 BLKSIZE
         LH    R4,82(,R1)                 LRECL
         SR    R2,R2
         DR    R2,R4                      BLOCKSIZE/LRECL
         MR    R2,R4                      BLOCKING*LRECL
         CR    R3,R4                      BLOCKSIZE >  LRECL?
         BH    *+10                       YES, BRANCH
         LR    R3,R4                      MAKE BLKSIZE=LRECL
         NI    36(R1),X'EF'               TURN OFF BLOCKING
         STH   R3,62(,R1)                 NEW BLOCKSIZE
         STH   R3,24(,R1)                 BUFLEN PARAMETER
         CLI   20(R1),X'00'               BUFNO=0?
         BNER  R14                        NO, QUIT
         MVI   20(R1),X'03'               DEFAULT TO 3 BUFFERS
         BR    R14                         EXIT
         EJECT
DUMP     DC    D'0'
         PRINT NOGEN
SYSPRINT DCB  LRECL=109,RECFM=FBA,EXLST=EXITDCB,DDNAME=SYSPRINT,       X
               MACRF=(PM),DSORG=PS
         SPACE 3
IGNORE   DCB  LRECL=80,RECFM=FB,EXLST=EXITDCB,DDNAME=IGNORE,           X
               EODAD=ENDIG,MACRF=(GM),DSORG=PS
FIRSTIG  DC    F'0'                     POINTER TO FIRST IGNORE RECORD
LASTIG   DC    F'0'                     POINTER TO LAST IGNORE RECORD
         SPACE 3
OLDDCB   DCB   DEVD=DA,DDNAME=OLD,MACRF=(GL),DSORG=PS,EXLST=OLDXLST2,  X
               EODAD=EOLDNEW,OPTCD=C
* OLD    DCB   EXLST=EXITDCB,DDNAME=OLD,                              X
*              EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C
LOWOLD   DC    F'0'                     FIRST OLD RECORD
HIGHOLD  DC    F'0'                     HIGHEST USED OLD RECORD
CURROLD  DC    F'0'                     CURRENT OLD RECORD
OLDLIT   DC    C'OLD'
         SPACE 3
NEWDCB   DCB   DEVD=DA,DDNAME=NEW,MACRF=(GL),DSORG=PS,EXLST=NEWXLST2,  X
               EODAD=EOLDNEW,OPTCD=C
* NEW    DCB   EXLST=EXITDCB,DDNAME=NEW,                              X
*              EODAD=EOLDNEW,MACRF=(GL),DSORG=PS,OPTCD=C
LOWNEW   DC    F'0'                     FIRST NEW RECORD
HIGHNEW  DC    F'0'                     HIGHEST USED NEW RECORD
CURRNEW  DC    F'0'                     CURRENT NEW RECORD
LOW      EQU   LOWNEW-NEWDCB      DISPLACEMENT TO LOWOLD AND LOWNEW
HIGH     EQU   HIGHNEW-NEWDCB     DISPLACEMENT TO HIGHOLD AND HIGHNEW
CURR     EQU   CURRNEW-NEWDCB     DISPLACEMENT TO CURROLD AND CURRNEW
NEWLIT   DC    C'NEW'
OLDNEW   EQU   NEWLIT-NEWDCB      DISPLACEMENT TO OLD OR NEW LITERAL
         EJECT
*OUBLE   DC    D'0'
EXITDCB  DC    X'85',AL3(DCBEXIT)
RC       DC    H'0'
COUNT    DC    H'0'
NUMBER   DC    XL3'0'
MLENGTH  DC    X'47'               COMPARE LENGTH FOR EACH RECORD
MIN      DC    F'05120'             MINIMUM CORE TO GETMAIN
*AX      DC    X'00800000'          MAXIMUM CORE TO GETMAIN
MAX      DC    X'00100000'  CBT     MAXIMUM CORE TO GETMAIN
FOURK    DC    F'04096'             AMOUNT OF CORE TO RELEASE
STARTADD DC    F'0'                 BUFFER START ADDRESS
SIZE     DC    F'0'                 SIZE OF THE BUFFER AREA
HIGHCORE DC    F'0'                 MAXIMUM BUFFER ADDRESS
BUFFER   DC    X'004040404040406040000000606060'
         DC    80X'00',X'606060000000',X'4060404040404040',7X'00'
*FULL    DC    C'FULL'
EDCOUNT  DC    X'402020202120'
EDMKPAT  DC    X'40202020202060'
CORE     DC    C'CORE OVERFLOW - COMPARE ABANDONED '
BLOCKS   DC    C' BLOCKS OF COMPARE ERRORS DETECTED '
NEWCMSG  DC    C' = NEW FILE RECORD COUNT           '
OLDCMSG  DC    C' = OLD FILE RECORD COUNT           '
NEWCNT   DC    PL8'0'
OLDCNT   DC    PL8'0'
ZERO     DC    PL1'0'
ONE      DC    PL1'1'
BLANKS   DC    C'       '
*R0       EQU   0
*R1       EQU   1
*R2       EQU   2
*R3       EQU   3
*R4       EQU   4
*R5       EQU   5
*R6       EQU   6
*R7       EQU   7
*R8       EQU   8
*R9       EQU   9
*R10      EQU   10
*R11      EQU   11
*R12      EQU   12
*R13      EQU   13
*R14      EQU   14
*R15      EQU   15
IGASMS   DC    A(DFTIG,ENDDFTIG)        DEFAULT IGNORE TABLE        ABL
DFTIG    DC    CL80'         EJECT   '                              ABL
         DC    CL80'         SPACE   '                              ABL
         DC    CL80'         SPACE 1 '                              ABL
         DC    CL80'         SPACE 2 '                              ABL
         DC    CL80'         SPACE 3 '                              ABL
         DC    CL80'*                '                              ABL
ENDDFTIG EQU   *                                                    ABL
         END
