***********************************************************************
*                                                                     *
*                *===================================*                *
*                *  COPYRIGHT NOTICE AND DISCLAIMER  *                *
*                *===================================*                *
*                                                                     *
*   Copyright (c) 1988 by Leonard D. Woren.                           *
*   All rights reserved, except as explicitly noted herein.  This     *
*   program may be used, modified, and distributed, provided that     *
*   all of the following conditions are met:                          *
*                                                                     *
*   (1)  This notice and all references to the original author(s)     *
*        are retained forever in all copies and versions of the       *
*        source.                                                      *
*                                                                     *
*   (2)  This program may be distributed via "public domain" mods     *
*        tapes, such as the SHARE mods tape, the CBT (Connecticut     *
*        Bank and Trust) tape, the LA MVSUG (Los Angeles MVS User's   *
*        Group) tape, etc, etc.  Only versions of this program        *
*        authorized by Leonard D. Woren may be placed on these        *
*        tapes.  Distribution of modified versions of this program,   *
*        via the above named tapes or via any method, is              *
*        specifically prohibited.  (Please see reason mentioned       *
*        below.)                                                      *
*                                                                     *
*   (3)  Permission is specifically NOT given to distribute MODIFIED  *
*        versions of this program.  Modified versions may be used     *
*        only at the site making the mods.  (Please see reason        *
*        mentioned below.)                                            *
*                                                                     *
*   (4)  The only charge which may be made for distribution is to     *
*        recover real costs, such as postage, or creating a tape.     *
*                                                                     *
*   (5)  The only charge for running the program which may be made    *
*        is your normal charge for computer time.                     *
*                                                                     *
*                                                                     *
*   The reason for the restrictions on distribution of modified       *
*   versions is to try to prevent circulation of many different       *
*   versions of the program, each with a few features that aren't     *
*   in any other version.                                             *
*                                                                     *
*   Since everyone will benefit from this, please send all updates    *
*   to me.  (Address below.)  I will try merge them in, if they       *
*   have been made to a reasonably current version of the source,     *
*   and if they are in keeping with the general design of the rest    *
*   of the program.  Mods may be altered by me for this purpose.      *
*   Any such mods which are incorporated into the program will then   *
*   become governed by the restrictions specified here for the whole  *
*   program, with appropriate credit to the contributor.              *
*                                                                     *
*   Although this program has been extensively tested, and is in use  *
*   in a production environment (MVS/ESA release 3.1.3, w/DFP 3.2),   *
*   no guarantee is made of (or responsibility assumed for) correct   *
*   or reliable operation.  I may try to help with problems.  I do    *
*   not assume any responsibility to distribute updates.              *
*                                                                     *
*   CONTACT:                                                          *
*          Leonard D. Woren                                           *
*        snail-mail:                                                  *
*          University of Southern California                          *
*          University Park  Mail Code 0251                            *
*          Los Angeles, CA   90089-0251                               *
*                                                                     *
*        e-mail:                                                      *
*          LDW@USCMVSA.BITNET                                         *
*          LDW@MVSA.USC.EDU                                           *
*          ...!usc!ldw                                                *
*                                                                     *
*          (213) 740-2875 (direct -- 11 am to 7 pm Pacific time)      *
*                                                                     *
*          I prefer electronic mail.  If you call me long distance    *
*          and leave a msg because you didn't get me, there's a good  *
*          chance that I won't call back.  Moral:  don't leave a      *
*          message for me to call you back unless you're in 213,      *
*          818, 714, or 310.  Sorry.                                  *
*                                                                     *
*          SHARE installation code:  USC                              *
*          GUIDE installation code:  OUY                              *
*                                                                     *
***********************************************************************
         EJECT ,
ENQ      TITLE '-----  DISPLAY MVS/SP ENQUEUES  -----'
*---------------------------------------------------------------------*
*                                                                     *
*   Program name:  ENQ                                                *
*                                                                     *
*   Purpose:       Enable a TSO user to display MVS/SP enqueues       *
*                                                                     *
*   Origin:        This program was obtained from UCLA-OAC in Nov82   *
*                                                                     *
*   Updates:                                                          *
*      05Aug89  U008 LDW  Correctly blank the char after jobname      *
*      10JAN89  U007 LDW  CHANGE UPPER LIMIT OF VC GETMAIN FROM 2G    *
*                            TO 2M TO REDUCE PROBLEMS WHEN RUNNING    *
*                            UNDER PIE/TSO/SESSIONS                   *
*      03FEB87  U006 LDW  FREE SOME STORAGE AFTER VC GETMAIN TO TRY   *
*                            AVOID S40D AND SIMILAR PROBLEMS          *
*      10OCT86  U005 LDW  DISPLAY RNAME IN CHAR FIRST, EVEN IF IT     *
*                            IS TO BE DISPLAYED IN HEX                *
*      04/24/85 U004 LDW  CHANGE DEFAULT TO 'NOCLEAR', DUE TO         *
*                            PROBLEMS UNDER SESSION MANAGER           *
*      06/11/84 U003 LDW  CLEAR SCREEN BEFORE EACH DISPLAY, UNLESS    *
*                            'NOCLEAR' SUBCOMMAND ENTERED ('CLEAR'    *
*                            WILL RESUME SCREEN CLEAR)                *
*                         ADD 'RESERVE' SUBCOMMAND TO LIST ONLY       *
*                            RESERVES                                 *
*      11/10/83 U002 SDM  ELIMINATE OAC MACROS                        *
*      01/31/83 U001 LDW  CHANGE SYSTEM WIDE ENQ CHAR FROM 'S' TO 'Y' *
*                         TEST FOR SYSTEMS WIDE ENQ, DISPLAY AS 'Z'   *
*                         NAME THE SUBFIELDS OF PRTBUFF, INSTEAD OF   *
*                            USING OFFSETS                            *
*                         CHANGE PUTGET PROMPT TO ASIS                *
*                         FIX TEST FOR '*' AS OPERAND OF 'FIND', SO   *
*                            'F * * *MASTER*' WORKS                   *
*                         PUT IN SPECIAL CHECK FOR QNAME='SPFEDIT'    *
*                         FORMAT RNAME IN HEX IF IT CONTAINS          *
*                            UNPRINTABLE CHARACTERS                   *
*                                                                     *
*---------------------------------------------------------------------*
         SPACE 3
         MACRO
&LBL     MSG   &PARM
         LCLA  &A
&A       SETA  2+K'&PARM
&LBL     DC    0H'0',AL2(&A,0)
         DC    C&PARM
         MEND
         SPACE 3
         MACRO -- XCALL -- CALL INTERNAL SUBROUTINE                U002
&L       XCALL &N                                                  U002
&L       LA    R15,&N                   -> ROUTINE ENTRY           U002
         BALR  R14,R15                  CALL ROUTINE               U002
         MEND                                                      U002
         SPACE 3
         MACRO -- XSUB -- DEFINE INTERNAL SUBROUTINE ENTRY         U002
&L       XSUB  ,                                                   U002
&L       SAVE  (14,12),,*               SAVE INCOMING REGS         U002
         LR    R10,R15                  SET SUBROUTINE BASE        U002
         LA    R15,PUSHSTAK-&L.(,R15)   -> PUSH STACK ROUTINE      U002
         BALR  R14,R15                  PUSH THE SAVE AREA STACK   U002
         USNGX &L,R10                   ADDRESS THE SUBROUTINE     U002
         MEND                                                      U002
         SPACE 3
         MACRO -- XRET -- RETURN FROM  INTERNAL SUBROUTINE         U002
&LBL     XRET  &RC=                                                U002
         LCLC  &L,&N                                               U002
&L       SETC  'IHB&SYSNDX.A'                                      U002
         AIF   ('&LBL' EQ '').NOLBL                                U002
&L       SETC  '&LBL'                                              U002
.NOLBL   ANOP                                                      U002
&N       SETC  '&L'                                                U002
         AIF   ('&RC' EQ '').NORC                                  U002
         AIF   ('&RC'(1,1) EQ '(').REGRC                           U002
&N       LA    R15,&RC                  SET RETURN CODE            U002
&N       SETC  ''                                                  U002
.REGRC   AIF   ('&RC' EQ '(15)').NORC                              U002
         AIF   ('&RC' EQ '(R15)').NORC                             U002
&N       LR    R15,&RC(1)               SET RETURN CODE            U002
&N       SETC  ''                                                  U002
.NORC    ANOP                                                      U002
&N       LA    R2,POPSTAK               -> POP STACK ROUTINE       U002
         BALR  R14,R2                   RETURN BY WAY OF POP RTN   U002
         MEND                                                      U002
         EJECT
ENQ      OSENTER BASE=R10,GETMAIN=(WORKALEN,WORKAREA),PARMREG=R2,  U002$
               ENV=(CP,SIM),EXIT=EXIT,RC=(R15),LOAD=K              U003
         TITLE 'ENQ - INITIALIZATION'
*
*        INITIALIZATION
*
         LR    R12,R13                  -> WORKAREA                U002
         DROPX R13                      WORKAREA                   U002
         USNGX WORKAREA,R12             SEPARATE WORK FROM SAVE    U002
         LA    R0,SAVESTK               -> FIRST STACK ENTRY       U002
         ST    R0,SAVESTKP              STACK POINTER              U002
         LA    R0,SAVESTKE              -> LAST STACK ENTRY        U002
         ST    R0,SAVESTKL              STACK LIMIT                U002
         LA    R8,IOPLL           INITIALIZE THE IOPL
         USNGX IOPL,R8                                             U002
         MVC   IOPLUPT(4),CPPLUPT COPY UPT ADD FROM CPPL
         MVC   IOPLECT(4),CPPLECT COPY ECT ADD FROM CPPL
         LA    R1,TSOECB          GET TSO ECB ADDRESS
         ST    R1,IOPLECB         STORE IN IOPL
         DROPX R8                                                  U002
         LA    R1,PRTLEN          INITIALIZE TO OLD
         ST    R1,OLD+4           STORE OUTPUT BUF ADD IN OLD
         LA    R1,1               GET NUMBER OF OUTPUT SEGMENTS
         ST    R1,OLD             STORE IN OLD
         XC    PRTOFF(2),PRTOFF   ZERO OFFSET OF FIRST SEGMENT
         MVC   GETMAINL(GETMLEN),GETMDC BUY AN AREA FOR GQSCAN
GETAREA  GETMAIN VC,LA=MEMLOW,A=AREAA,MF=(E,GETMAINL),SP=1,            X
               RELATED=(FREEAREA)
         LTR   R15,R15
         BZ    CONFL1
         LA    R1,NOMEM           COMPLAIN ABOUT LACK OF MEMORY
         XCALL PRINT                                               U002
         LA    R15,4
         B     EXIT
*
*        ON ENTRY WE ASSUME THE CONFLICT COMMAND
*
CONFL1   MVI   FLGS,CONFLG        INIT THE FLAG
         L     R1,AREAA                 -> GOTTEN STORAGE          U006
         L     R0,AREAA+4               GET LENGTH OF GOTTEN STG   U006
         AR    R1,R0                    -> PAST END                U006
         S     R1,=A(32*1024)           -> PART TO FREE            U006
         S     R0,=A(32*1024)           ADJUST LENGTH TO KEEP      U006
         ST    R0,AREAA+4               STORE UPDATED LENGTH       U006
*  CAN'T BE NON-POSITIVE, SINCE THE MINIMUM WE'LL ACCEPT WAS       U006
*  CHANGED FROM 32K TO 64K                                         U006
         FREEMAIN  RU,A=(1),LV=32*1024,SP=1  GIVE BACK 32K TO SYS  U006
         XC    QNL(6),QNL         ZERO LENGTHS
         MVC   GQLIST(CONQL),CONQ INIT PARM LIST
         TITLE 'ENQ - MAIN Q SCAN/FORM AT LOOP'
*
*        MAIN  Q SCAN/FORMAT LOOP  FOR ALL COMMANDS
*
ENQLP    TM    FLAG2,F2CLEAR      CLEAR SCREEN?                    U004
         BNO   ENQLP0             NO - SKIP                        U004
         L     R15,K              -> CLEAR SCREEN SUBROUTINE       U003
         BALR  R14,R15            CALL IT                          U003
         SPACE 2
ENQLP0   XCALL SCAN               GO SCAN QUEUES                   U002
         BNZ   GETCMD             NOTHING THERE
         L     R9,AREAA           POINT TO FIRST RIB
         USNGX RIB,R9                                              U002
*
*        LOOP  TO HERE AFTER RESCAN WHERE ALL RIBES FOR THE
*              PREVIOUS RIB OCCURED  IN THE PREVIOUS AREA
*
ENQLP1   MVC   NRIBES(4),RIBTRIBE TOTAL NUMBER OF RIBE'S FOR THIS RIB
         NI    FLGS,X'FF'-CONTFLG MARK START OF RIB
         MVC   NCRIBES(4),RIBNRIBE SAVE # RIBES THIS AREA
         LR    R8,R9              COPY RIB ADDR
         AH    R8,RIBL            ADD IN RIBLENGTH RETURN BY GQSCAN
         AH    R8,RIBVLEN         ADD IN LENGTH OF VARIABLE PORTION
         USNGX RIBE,R8                                             U002
*
*        LOOP  TO HERE TO PROCESS  A RIBE
*
ENQLP3   XCALL FINDCHK            SEE IF WE PRINT THIS ONE         U002
         BNZ   ENQ2               IF NOT NO PRINT
         XCALL FMTRIBE            FORMAT JOB INFO                  U002
         XCALL FMTRIB             FORMAT QNAME, RNAME INFO         U002
         XCALL PRINT                                               U002
         BNZ   GETCMD             IF ATTN, QUIT
ENQ2     AH    R8,RIBEL           POINT TO NEXT RIBE
         L     R1,NRIBES          GET # UNPROCESSED RIBES THIS RIB
         BCT   R1,ENQ4            DECREMENT
*
*        FINISHED WITH THE RIBES IN THIS RIB
*        ADJUST POINTER AND DECREMENT NUMBER OF RIBS
*
ENQ2A    LR    R9,R8              ITS A RIB NOT A RIBE
         NI    FLGS,X'FF'-CONTFLG MARK START OF RIB
         L     R1,NRIBS           GET # UNPROCESSED RIBS
         BCT   R1,ENQ3            DECREMENT
*
*        FINISHED WITH ALL THE RIBS IN THIS AREA
*        CHECK RC TO SEE IF THAT  WAS THE LAST RIB
*
         ICM   R1,15,GQRC         CHECK FOR END OF LIST
         BZ    GETCMD
         XCALL RESCAN             GET NEXT CHUNK OF STUFF          U002
         L     R9,AREAA           POINT TO FIRST RIB
         BZ    ENQLP1
         B     GETCMD             TOTAL NUMBER OF RIBE'S FOR THIS RIB
*
*        THERE IS AT LEAST ONE UNPROCESSED RIB IN THIS AREA
*
ENQ3     ST    R1,NRIBS           STORE NEW #
         B     ENQLP1             GO PROCESS THIS RIB
*
*        THERE IS AT LEAST ONE UNPROCESSED RIBE IN THIS RIB
*
ENQ4     ST    R1,NRIBES          STORE NEW #
         L     R1,NCRIBES         GET # UNPROCESSED RIBS THIS AREA
         BCT   R1,ENQ5
*
*        THE RIBES FOR THIS RIB SPAN THIS AREA
*        SO WE  WANT THE NEXT CHUNK, BUT WE DONT
*        WANT  TO REDISPLAY THE QNAME, RNAME INFO
*
**       XCALL RESCAN             GET NEXT CHUNK OF STUFF          U002
**       BNZ   GETCMD
**       L     R9,AREAA           POINT TO FIRST RIB
**       OI    FLGS,CONTFLG       MARK CONTINUATION
**       B     ENQLP2
*
*        WELL  IT WAS A GOOD IDEA, BUT IT TURNS OUT THAT
*        GQSCAN TRUNCATES SPANNED RIBES UNLESS THE SCOPE
*        IS LOCAL OR GLOBAL, FOR WHICH YOU HAVE TO BE
*        KEY ZERO SUPERVISOR, SO JUST PUT OUT A MSG OF (*MORE*)
*        AND PROCESS THE NEXT RIB
         LA    R1,MOREM           POINT TO MORE MESSAGE
         ST    R1,OLD+4           STORE IN OLD
         XCALL PRINT                                               U002
         BZ    ENQ2A              PROCESS NEXT RIB
         B     GETCMD             IF ATTN PROCESS NEXT CMD
*
*        THERE  IS AT LEAST ONE UNPROCESSED RIBE IN THIS AREA
*
ENQ5     ST    R1,NCRIBES         STORE NEW #
         B     ENQLP3             GO FORMAT THIS ONE
         TITLE 'ENQ - COMMAND REQUESTOR'
*
*        COMMAND REQUESTOR
*
GETCMD   NI    FLGS,CONFLG+FINDFLG+GLOBFLG CLEANUP FLAGS
         LA    R1,HERALD          POINT TO HERALD
         ST    R1,OLD+4           STORE IN OLD
         MVC   PUTGETL(PUTGTDCL),PUTGETDC INIT PARM BLOCK
         XC    TSOECB(4),TSOECB   INIT ECB
         PUTGET PARM=PUTGETL,OUTPUT=(OLD,SINGLE,MODE),                 X
               TERMPUT=(ASIS,WAIT,NOHOLD,NOBREAK),                 U001X
               TERMGET=(EDIT,WAIT),MF=(E,IOPLL)
         CH    R15,=H'5'          SEE IF OK RETURN
         BL    GETCMD1
         CH    R15,=H'8'          WAS IT ATTENTION?
         BE    GETCMD             IF SO REPROMPT
         CH    R15,=H'32'         DID THE USER HANG UP?
         BE    CLEANUP            IF SO JUST EXIT
         EX    R0,*               SHOULD NEVER HAPPEN
GETCMD1  L     R9,PUTGETL+12      GET ADDR OF REPLY
         ST    R9,GETADDR         SAVE AS ADDR OF INPUT BUFFER
         LH    R8,0(R9)           GET LENGTH OF INPUT BUFFER
         ST    R8,GETLEN          SAVE LENGTH
         CH    R8,=H'4'           SEE IF EMPTY
         BH    GETCMD2            NO SO PROCESS IT
RECMD    TM    FLGS,CONFLG        DO LAST COMMAND AGAIN
         BO    CONFLICT           IF CONFLICT, DO IT AGAIN
         TM    FLGS,FINDFLG       IF FIND
         BO    FINDAG             DO THAT AGAIN
         TM    FLGS,GLOBFLG       IF GLOBAL
         BO    GLOBAL             DO THAT AGAIN
GETCMDAG XCALL GETCMDFR           FREE THE INPUT BUFFER            U002
         B     GETCMD             AND ASK AGAIN
GETCMD2  LA    R7,0(R8,R9)        POINT PAST END OF INPUT BUFFER
         ST    R7,CUREND          SAVE THIS POSITION
         LA    R6,4(R9)           POINT TO FIRST TEXT CHAR
         ST    R6,CURIN           INITIALIZE CURRENT INPUT POSITION
         XCALL GETTOKEN                                            U002
         BZ    RECMD              IF EMPTY LINE, DO PREVIOUS CMD
*  THIS TEST MUST OCCUR BEFORE TEST FOR 'CONFLICT'                 U003
         CLC   =C'CLEAR',0(R1)    IS IT CLEAR?                     U003
         BE    SETCLEAR           YES - RESET FLAG                 U003
         CLI   0(R1),C'C'         SEE IF CONFLICT
         BE    CONFLICT
         CLI   0(R1),C'E'         SEE IF END
         BE    END
         CLI   0(R1),C'F'         SEE IF FIND
         BE    FIND
         CLI   0(R1),C'R'         SEE IF RESERVE                   U003
         BE    RESERVE                                             U003
         CLI   0(R1),C'G'         SEE IF GLOBAL
         BE    GLOBAL
         CLC   =C'NOCLEAR',0(R1)  IS IT CLEAR?                     U003
         BE    SETNOCLR           YES - SET FLAG                   U003
         LA    R1,CMDNF           POINT TO INVALID COMMAND MSG
         ST    R1,OLD+4
         XCALL PRINT                                               U002
         BZ    GETCMDAG           IF NO ATTN, ASK AGAIN
         B     END                IF ATTN, END
         TITLE 'ENQ - COMMANDS'
SETCLEAR OI    FLAG2,F2CLEAR      TURN ON CLEAR FLAG               U004
         B     ENQLP              NEW DISPLAY                      U003
*
SETNOCLR NI    FLAG2,255-F2CLEAR  TURN OFF CLEAR FLAG              U004
         B     ENQLP              NEW DISPLAY                      U003
*
CONFLICT XCALL GETCMDFR           CONFLICT                         U002
         B     CONFL1
*
END      XCALL GETCMDFR           END                              U002
         B     CLEANUP
*
GLOBAL   XCALL GETCMDFR           GLOBAL                           U002
         MVI   FLGS,GLOBFLG       CLEAR FLAGS
         MVC   GQLIST(ALLQL),ALLQ INIT PARM BLOCK
         B     ENQLP
*
RESERVE  OI    FLAG2,F2RSRV       INDICATE SELECT ONLY RESERVES    U003
         B     FINDX              JOIN COMMON CODE                 U003
*
FIND     NI    FLAG2,255-F2RSRV   DON'T RESTRICT TO RESERVES       U003
*      ( B     FINDX )            JOIN COMMON CODE                 U003
*
FINDX    XC    QNL(6),QNL         ZERO ALL LENGTHS
         XCALL GETTOKEN                                            U002
         BZ    FIND1              IF NONE LEAVE ALL EMPTY
         CH    R15,=H'1'                OPERAND EXACTLY 1 CHAR?    U001
         BNE   *+12                     NO - SKIP NEXT TEST        U001
         CLI   0(R1),C'*'         * IS SAME AS EMPTY
         BE    FIND1
         CH    R15,=H'8'          CHECK LENGTH
         BH    FINDPR
         STH   R15,QNL            SAVE QNAME LENGTH
         BCTR  R15,0              DECREMENT FOR  EXECUTE
         MVC   QNAME(1),0(R1)     < EXECUTED >
         EX    R15,*-6            MOVE INTO SAVE AREA
FIND1    XCALL GETTOKEN                                            U002
         BZ    FIND2              IF NONE LEAVE REST EMPTY
         CH    R15,=H'1'                OPERAND EXACTLY 1 CHAR?    U001
         BNE   *+12                     NO - SKIP NEXT TEST        U001
         CLI   0(R1),C'*'         * IS SAME AS EMPTY
         BE    FIND2
         CH    R15,=H'255'
         BH    FINDPR
         STH   R15,RNL            SAVE RNAME LENGTH
         BCTR  R15,0              DECREMENT FOR EXECUTE
         MVC   RNAME(1),0(R1)     < EXECUTED >
         EX    R15,*-6
FIND2    XCALL GETTOKEN                                            U002
         BZ    FINDAG             IF NONE LEAVE REST EMPTY
         CH    R15,=H'1'                OPERAND EXACTLY 1 CHAR?    U001
         BNE   *+12                     NO - SKIP NEXT TEST        U001
         CLI   0(R1),C'*'         * IS SAME AS EMPTY
         BE    FINDAG
         CH    R15,=H'8'          CHECK FOR VALID LENGTH
         BH    FINDPR
         STH   R15,JNL            SAVE JOBNAME LENGTH
         BCTR  R15,0              DECREMENT FOR EXECUTE
         MVC   JNAME(1),0(R1)     < EXECUTED >
         EX    R15,*-6
FINDAG   XCALL GETCMDFR                                            U002
         MVI   FLGS,FINDFLG       FIND
         MVC   GQLIST(ALLQL),ALLQ INIT PARM BLOCK
         B     ENQLP
FINDPR   LA    R1,FINDPRM         POINT TO INVALID PARM MSG
         ST    R1,OLD+4           STORE IN OLD
         XCALL PRINT                                               U002
         BZ    GETCMDAG           IF NO ATTN, ASK AGAIN
         B     END                IF ATTN, QUIT
*
CLEANUP  MVC   FREEML(FREEMLEN),FREEMDC
FREEAREA FREEMAIN VU,A=AREAA,MF=(E,FREEML),SP=1,RELATED=(GETAREA)
         SR    R15,R15
         B     EXIT
         TITLE 'ENQ - CONSTANTS'
*MEMLOW  DC    X'00008000'        MEM LIMITS FOR GQ AREA
MEMLOW   DC    X'00010000'        MEM LIMITS FOR GQ AREA           U006
*MEMHIGH DC    X'7FFFFFFF'
MEMHIGH  DC    X'001FFFFF'                                         U007
GETMDC   GETMAIN VC,SP=1,MF=L
GETMLEN  EQU   *-GETMDC
FREEMDC  FREEMAIN VU,SP=1,MF=L
FREEMLEN EQU   *-FREEMDC
PUTGETDC PUTGET  OUTPUT=(0,,MODE),MF=L
PUTGTDCL EQU   *-PUTGETDC
ALLQ     GQSCAN REQLIM=MAX,SCOPE=ALL,SYSNAME=0,REQCNT=1,MF=L
ALLQL    EQU   *-ALLQ
CONQ     GQSCAN REQLIM=MAX,SCOPE=ALL,SYSNAME=0,WAITCNT=1,MF=L
CONQL    EQU   *-CONQ
NOMEM    MSG   ' NOT ENOUGH CORE TO PROCESS REQUEST'
*HERALD  MSG   ' ENQ'
HERALD   MSG   ' ENQ:'                                             U001
CMDNF    MSG   ' INVALID COMMAND'
FINDPRM  MSG   ' INVALID PARAMETER'
MOREM    MSG   ' (*MORE*)'
         LTORG
         DROPX R10                                                 U002
         TITLE 'ENQ - SUBROUTINES'
*
*        SUBROUTINE TO PARSE AND  UPPERCASE NEXT TOKEN FROM INPUT LINE
*
*     ON ENTRY ASSUMES:
*        CURIN POINTS TO FIRST CHAR OF TEXT
*        CUREND POINTS PAST END OF TEXT
*
*     ON RETURN:
*        R1 POINTS TO FIRST CHAR OF TOKEN
*        R15 CONTAINS LENGTH OF TOKEN
*        CURIN POINTS TO NEXT POSITION IN INPUT STRING
*
GETTOKEN XSUB                                                      U002
         L     R6,CURIN           POINT TO CURRENT POS
         L     R7,CUREND          POINT PAST END OF STRING
         SR    R15,R15            ASSUME ZERO LENGTH TOKEN
         CR    R6,R7              SEE IF AT END OF TEXT
         BNL   GETTR1             IF SO RETURN WITH EMPTY TOKEN
*
*        FIND  FIRST NON BLANK, OR COMMA
*
GETT1    OI    0(R6),C' '         UPPERCASE THE CHARACTER
         CLI   0(R6),C' '         SEE IF BLANK
         BNE   GETT2              BRANCH IF NOT
         LA    R6,1(R6)           POINT TO NEXT CHAR
         CR    R6,R7              SEE IF OFF END OF TEXT
         BL    GETT1              IF NOT OFF END CONTINUE
         B     GETTR1             IF OFF END RETURN EMPTY TOKEN
GETT2    CLI   0(R6),C','         IS IT A COMMA
         BNE   GETT3              IF NOT THEN START OF TOKEN
         B     GETTR              AND RETURN EMPTY TOKEN
*
*        NEXT  BLANK OR COMMA DELIMITS TOKEN
*
GETT3    LR    R1,R6              SAVE START OF TOKEN
GETT4    OI    0(R6),C' '         UPPERCASE THE CHARACTER
         CLI   0(R6),C' '         FIND NEXT BLANK
         BE    GETTR              END OF TOKEN
         CLI   0(R6),C','         COMMA IS ALSO A DELIMITER
         BE    GETTR              END OF TOKEN
         LA    R15,1(R15)         COUNT THIS CHAR
         LA    R6,1(R6)           BUMP POINTER
         CR    R6,R7              SEE IF OFF END OF TEXT
         BL    GETT4              IF NOT, CONTINUE SCAN
GETTR    LA    R6,1(R6)           POINT TO NEXT CHAR
GETTR1   ST    R6,CURIN           SAVE NEW CURRENT POSSITION
         XRET  RC=(R15)                                            U002
         LTORG
         DROPX R10                                                 U002
         EJECT
*
*        SUBROUTINE TO FREE INPUT BUFFER FROM PUTGET
*        ASSUMES ADDR IN R9, LENGTH IN R8
*
GETCMDFR XSUB                                                      U002
         L     R9,GETADDR         POINT TO AREA TO BE FREED
         L     R8,GETLEN          GET LENGTH OF AREA TO BE FREED
         FREEMAIN R,A=(R9),LV=(R8),SP=1
         XRET                                                      U002
         LTORG
         DROPX R10                                                 U002
         EJECT
SCAN     XSUB                                                      U002
         XC    TOKEN(4),TOKEN     ZERO TOKEN
         LM    R2,R3,AREAA        GET AREA ADDR AND LENGTH
         GQSCAN AREA=((R2),(R3)),TOKEN=TOKEN,MF=(E,GQLIST)
         ST    R15,GQRC           SAVE THE RC
         CH    R15,=H'4'          EMPTY
         BE    SCANRT             IF SO RETURN
         CH    R15,=H'12'         ERROR
         BL    SCAN1
         EX    R0,*               SHOULD NEVER HAPPEN
SCAN1    ST    R0,RIBL            SAVE LENGTHS OF RIB AND RIBE
         ST    R1,NRIBS           SAVE # RIBS THIS AREA
         SR    R15,R15
SCANRT   XRET  RC=(R15)                                            U002
         LTORG
         DROPX R10                                                 U002
         EJECT
*
*        CALL  TO GET NEXT CHUNK  OF DATA FROM GQSCAN
*
RESCAN   XSUB                                                      U002
         GQSCAN MF=(E,GQLIST)
SCANCHK  ST    R15,GQRC           SAVE THE RC
         CH    R15,=H'4'          EMPTY
         BE    RESCANRT           IF SO RETURN
         CH    R15,=H'12'         ERROR
         BL    RESCAN1
         EX    R0,*               SHOULD NEVER HAPPEN
RESCAN1  ST    R0,RIBL            SAVE LENGTHS OF RIB AND RIBE
         ST    R1,NRIBS           SAVE # RIBS THIS AREA
         SR    R15,R15
RESCANRT XRET  RC=(R15)                                            U002
         LTORG
         DROPX R10                                                 U002
         EJECT
*
*        CHECK  TO SEE IF FIND IS  IN EFFECT
*        IF NOT RETURN RC=0
*
*        IF SO CHECK THAT SPECIFIED INITIAL PORTIONS OF
*        QNAME RNAME AND JOBNAME  MATCH
*        RETURN ZERO IF SO, NONZERO IF NOT
*
FINDCHK  XSUB                                                      U002
         TM    FLGS,FINDFLG       IS FIND APPROPRIATE
         BNO   FINDC00            NO, EVERYTHING IS FOUND
         TM    FLAG2,F2RSRV       WANT ONLY RESERVES?              U003
         BZ    FINDC0             NO - CONTINUE                    U003
         TM    RIBETYPE,RIBERESV  YES - IS THIS A RESERVE?         U003
         BNO   FINDNZ             NO - DON'T DISPLAY IT            U003
FINDC0   SR    R1,R1              CLEAR R1
         ICM   R1,3,QNL           GET QNAME LENGTH
         BZ    FINDC1
         BCTR  R1,0               DECREMENT FOR EXECUTE
         CLC   RIBQNAME(1),QNAME  < EXECUTED >
         EX    R1,*-6
         BNE   FINDNZ
FINDC1   ICM   R1,3,JNL           GET JOBNAME LENGTH
         BZ    FINDC2
         BCTR  R1,0               DECREMENT FOR EXECUTE
         CLC   RIBEJBNM(1),JNAME  < EXECUTED >
         EX    R1,*-6
         BNE   FINDNZ
FINDC2   ICM   R1,3,RNL           GET RNAME LENGTH
         BZ    FINDC00
         BCTR  R1,0               DECREMENT FOR EXECUTE
         LR    R15,R9             COPY RIB ADDR
         AH    R15,RIBL           POINT TO VARIABLE PORTION
         CLC   0(1,R15),RNAME     < EXECUTED >
         EX    R1,*-6
         BNE   FINDNZ
FINDC00  SR    R15,R15
FINDNZ   DS    0H                 R15 CONTAINS BASE AND IS NON-ZERO
FINDRET  XRET  RC=(R15)                                            U002
         LTORG
         DROPX R10                                                 U002
         EJECT
*
*        FORMAT THE REQUESTOR SPECIFIC INFO FROM THE RIB AND RIBE
*
FMTRIBE  XSUB                                                      U002
         MVI   PRTBUFF,C' '       START WITH A BLANK
         MVI   PRTSCOPE,C'J'      ASSUME SCOPE OF STEP             U001
         TM    RIBSCOPE,RIBSTEP   STEP?
         BO    FMTRIBE1           YES
         MVI   PRTSCOPE,C'Y'      IF NOT, ASSUME SYSTEM            U001
         TM    RIBSCOPE,RIBSYS    SYSTEM?                          U001
         BO    FMTRIBE1           YES                              U001
         MVI   PRTSCOPE,C'Z'      IF NOT, ASSUME SYSTEMS           U001
FMTRIBE1 MVI   PRTTYPE,C'S'       ASSUME SHARED
         TM    RIBERFLG,RIBETYPE  SEE IF SHARED
         BO    FMTRIBE2
         MVI   PRTTYPE,C'E'       IF NOT, ITS EXCLUSIVE
FMTRIBE2 MVI   PRTSTAT,C'G'       ASSUME OWNES THE RESOURCE
         TM    RIBESFLG,RIBESTAT  SEE IF OWNES
         BO    FMTRIBE3
         MVI   PRTSTAT,C'W'       IF NOT, ITS WAITING
FMTRIBE3 MVI   PRTRSRV,C'R'       ASSUME RESERVE
         TM    RIBETYPE,RIBERESV
         BO    FMTRIBE4
         MVI   PRTRSRV,C' '       IF NOT, LEAVE BLANK
FMTRIBE4 MVI   PRTMC,C'M'         ASSUME MUST COMPLETE
         TM    RIBETYPE,RIBEMC
         BO    FMTRIBE5
         MVI   PRTMC,C' '         IF NOT, LEAVE BLANK
FMTRIBE5 MVI   PRTBLNK1,C' '      BLANK
         MVC   PRTJOBNM(8),RIBEJBNM COPY JOBNAME
*U001    MVC   PRTLEN(2),=H'19'   ASSUME NO VOL,UCB - LEN=15+4
         MVC   PRTLEN,=Y(PRTDATA-PRTLEN)  ASSUME NO VOL,UCB        U001
         MVI   PRTBLNK2,C' '                                       U008
         TM    RIBETYPE,RIBERESV  TEST FOR RESERVE
         BNO   FMTRIBE6
*U001    MVC   PRTLEN(2),=H'31'   LEN = 27+4
         MVC   PRTLEN,=Y(PRTDATA+11-PRTLEN)                        U001
         L     R2,RIBEUCB         GET UCB ADDRESS
         MVC   PRTDATA(6),UCBVOLI-UCBOB(R2)
         MVI   PRTDATA+6,C'-'
         SLL   R2,4               SHIFT UCB ADDRESS LEFT 2
         ST    R2,PARMLSTS        STORE IN WORK AREA
         OI    PARMLSTS+3,X'0F'   OR IN SIGN
         UNPK  PRTDATA+7(4),PARMLSTS+1(3) UNPACK
         L     R1,=A(FMTTRTBL)    BECAUSE OF ADDRESSABILITY
         TR    PRTDATA+7(4),0(R1) CONVERT TO CHARACTER
FMTRIBE6 LA    R1,PRTLEN          POINT TO THE SEGMENT
         ST    R1,OLD+4           STORE IN OLD
         XRET                                                      U002
FMTTRTBL EQU   *-C'0'
         DC    C'0123456789ABCDEF' TRANSLATE TABLE
         LTORG
         DROPX R10                                                 U002
         EJECT
*
*        FORMAT THE RESOURCE SPECIFIC INFO FROM THE RIB
*
*        ALTHOUGH THIS SUBROUTINE IS CALLED FOR EACH RIBE,
*        IT ONLY ADDS STUFF TO THE PRINT BUFFER ONCE FOR EACH
*        RIB.  IT ASSUMES THAT FMTRIBE HAS ALREADY BEEN CALLED
*
FMTRIB   XSUB                                                      U002
         TM    FLGS,CONTFLG       SEE IF RIB ALREADY FORMATTED
         BO    FMTRIB00
         OI    FLGS,CONTFLG       MARK RIB AS FORMATTED
         LA    R1,PRTLEN          POINT TO OUTPUT BUFFER
         ST    R1,OLD+4           POINT OLD TO PRINT BUFFER
         LH    R2,PRTLEN          GET LENGTH
         LA    R1,0(R1,R2)        POINT PAST END OF BUFFER
         MVI   0(R1),C' '         MOVE IN QNAME
         MVC   1(8,R1),RIBQNAME
         MVI   9(R1),C' '
         AH    R2,=H'10'          ADDJUST LENGTH
         SR    R3,R3              CLEAR R3
         ICM   R3,1,RIBRNMLN      GET RNAME LENGTH
         BNZ   FMTRIB1
         STH   R2,PRTLEN          SAVE NEW LENGTH
         B     FMTRIB00
FMTRIB1  LR    R4,R9                    COPY RIB ADDR              U001
         AH    R4,RIBL                  POINT TO VARIABLE PORTION  U001
         CLC   =C'SPFEDIT ',RIBQNAME    SPECIAL?                   U001
         BNE   FMTRIB2                  NO - CONTINUE NORMALLY     U001
         CH    R3,=H'44'                MEMBER NAME PRESENT?       U001
         BNH   FMTRIB2                  NO - CONTINUE NORMALLY     U001
         CLC   =CL8' ',44(R4)           ANY MEMBER NAME THERE?     U001
         BE    FMTRIB2                  NO - CONTINUE NORMALLY     U001
         CH    R3,=H'52'                TOO BIG?                   U001
         BH    FMTRIB2                  YES - SOMETHING'S WRONG    U001
         MVC   10(44,R1),0(R4)          GET WHOLE DATASET NAME     U001
         LA    R14,10(,R1)              -> START OF DSNAME         U001
         LA    R3,43(,R14)              -> END OF DSN              U001
         CLI   0(R3),C' '               FIND END OF DSN?           U001
         BNE   *+8                      YES - GO FILL IN MEMBER    U001
         BCT   R3,*-8                   KEEP LOOKING               U001
         MVI   1(R3),C'('               PUT IN START DELIM         U001
         MVC   2(8,R3),44(R4)           GET MEMBER NAME            U001
         LA    R3,9(,R3)                -> END OF MEMBER NAME      U001
         CLI   0(R3),C' '               FIND END OF MEMBER NAME?   U001
         BNE   *+8                      YES                        U001
         BCT   R3,*-8                   NO - KEEP LOOKING          U001
         MVI   1(R3),C')'               PUT IN TRAILING DELIM      U001
         SR    R3,R14                   COMPUTE PHONY RNAME LEN    U001
         LA    R2,2(R3,R2)              ADD TO PREVIOUS PRINT LEN  U001
         STH   R2,PRTLEN                SAVE                       U001
         B     FMTRIB00                 RETURN TO CALLER           U001
FMTRIB2  AR    R2,R3              ADD RNAME LENGTH TO PRINT LENGTH
         STH   R2,PRTLEN          SAVE NEW LENGTH
         BCTR  R3,0               DECREMENT FOR EXECUTE
         MVC   10(1,R1),0(R4)     < EXECUTED >
         EX    R3,*-6             MOVE IN RNAME
*U005    LR    R14,R1                   PRESERVE PAST TRT          U001
*U005    LR    R15,R2                   ...                        U001
         LA    R14,1(R3,R1)             -> WHERE HEX MAY GO        U005
         LA    R15,1(R3,R2)             LENGTH SO FAR              U005
*U005    EX    R3,FMTRIBTR              SEE IF ANY INVALID CHARS   U001
*U005    BZ    FMTRIB00                 NONE - RETURN              U001
         EX    R3,FMTRIBTR              TRANSLATE OUT BAD CHARS    U005
         EX    R3,FMTRIBCL              SEE IF IT CHANGED          U005
         BE    FMTRIB00                 ALL CHARS GOOD - RETURN    U005
         LA    R2,1+4(R3,R15)           ADJUST FOR BCTR AND " X''" U001
         STH   R2,PRTLEN                SAVE NEW LENGTH            U001
         MVC   10(3,R14),=C' X'''       START IT OFF               U001
         LA    R14,10+3(,R14)           -> START OF HEX O/P AREA   U001
         LA    R3,1(,R3)                RESTORE LENGTH             U001
FMTRIB3  UNPK  0(2*7+1,R14),0(7+1,R4)   GET 7 BYTES OF RNAME       U001
         TR    0(2*7,R14),HEXTAB        MAKE IT PRINTABLE          U001
         MVI   2*7(R14),C''''           FIX FLIP BYTE              U001
         LA    R1,2*7+1(,R14)           -> PAST END                U001
         LA    R14,2*7(,R14)            BUMP OUTPUT POINTER        U001
         LA    R4,7(,R4)                BUMP INPUT POINTER         U001
         SH    R3,=H'7'                 ADJUST REMAINING LENGTH    U001
         BP    FMTRIB3                  LOOP IF MORE               U001
         BZ    FMTRIB00                 RETURN IF EXACTLY DONE     U001
         AR    R14,R3                   BACK UP OUTPUT POINTER     U001
         AR    R14,R3                   ...                        U001
         MVC   0(13,R14),=CL13''''      KILL THE EXTRA AMOUNT      U001
         LA    R1,1(,R14)               -> PAST END                U001
FMTRIB00 XRET                                                      U002
*MTRIBTR TRT   10(*-*,R1),TRTAB         << EXECUTED >>             U001
FMTRIBTR TR    10(*-*,R1),TRTAB         << EXECUTED >>             U005
FMTRIBCL CLC   10(*-*,R1),0(R4)         << EXECUTED >>             U005
PRTSPACE MSG   '  '
         LTORG
         DROPX R10                                                 U002
*TRTAB   DC    256X'01'                                            U001
*U005                                                              U005
*U005    ORG   TRTAB+C'A'-X'40'                                    U001
*U005    DC    9X'00'                                              U001
*U005    ORG   TRTAB+C'J'-X'40'                                    U001
*U005    DC    9X'00'                                              U001
*U005    ORG   TRTAB+C'S'-X'40'                                    U001
*U005    DC    8X'00'                                              U001
*U005    ORG   TRTAB+C'A'                                          U001
*U005    DC    9X'00'                                              U001
*U005    ORG   TRTAB+C'J'                                          U001
*U005    DC    9X'00'                                              U001
*U005    ORG   TRTAB+C'S'                                          U001
*U005    DC    8X'00'                                              U001
*U005    ORG   TRTAB+C'0'                                          U001
*U005    DC    10X'00'                                             U001
*U005    ORG   TRTAB+C' '                                          U001
*U005    DC    X'00'                                               U001
*U005    ORG   TRTAB+C'.'                                          U001
*U005    DC    6X'00'                                              U001
*U005    ORG   TRTAB+C'$'                                          U001
*U005    DC    7X'00'                                              U001
*U005    ORG   TRTAB+C','                                          U001
*U005    DC    5X'00'                                              U001
*U005    ORG   TRTAB+C':'                                          U001
*U005    DC    6X'00'                                              U001
*U005    ORG   TRTAB+256                                           U001
TRTAB    CHARTAB  FILL='?'                                         U005
HEXTAB   EQU   *-C'0'                                              U001
         DC    C'0123456789ABCDEF'                                 U001
         EJECT
*
*        PUTLINE SUBROUTINE, ASSUMES OLD POINTS TO SEGMENT TO BE
*         PRINTED. RETURNS NON ZERO IF ATTENTION SIGNALLED
*
PRINT    XSUB                                                      U002
         XC    TSOECB(4),TSOECB
         MVC   PUTLL(PUTLDCL),PUTLDC
         PUTLINE PARM=PUTLL,OUTPUT=OLD,MF=(E,IOPLL)
         LTR   R15,R15
         BZ    PRINTRET
         CH    R15,4              ATTENTION?
         BE    PRINTNZ            IF SO RETURN NON ZERO RC
         CH    R15,20             TERMINAL DISCONNECTED?
         BE    PRINTRET           IGNORE IT
         CH    R15,12             SEVERE ERROR
         BL    PRINTRET           IGNORE ALL OTHERS
         EX    R0,*               SHOULD NEVER HAPPEN
PRINTRET SR    R15,R15            ZERO RETURN CODE
PRINTNZ  XRET  RC=(R15)                                            U002
PUTLDC   PUTLINE MF=L
PUTLDCL  EQU   *-PUTLDC
         LTORG
         DROPX R10                                                 U002
         SPACE 3
         USNGX PUSHSTAK,R15                                        U002
PUSHSTAK L     R2,SAVESTKP              -> NEXT STACK ENTRY        U002
         C     R2,SAVESTKL              EXCEED STACK LIMIT?        U002
         BH    PSABEND                  YES, LEARN TO PROGRAM      U002
         LA    R3,L'SAVESTK(,R2)        -> NEW NEXT STACK ENTRY    U002
         ST    R3,SAVESTKP              -> NEXT STACK ENTRY        U002
         ST    R2,8(,R13)               FORWARD CHAIN AREAS        U002
         ST    R13,4(,R2)               BACKWARD CHAIN AREAS       U002
         LR    R13,R2                   -> NEW SAVE AREA           U002
         BR    R14                      RETURN TO CALLER           U002
PSABEND  ABEND 199,DUMP                 BAD NEWS BEARS             U002
         DROPX R15                      PUSHSTAK                   U002
         SPACE 3
         USNGX POPSTAK,R2                                          U002
POPSTAK  L     R3,SAVESTKP              -> NEXT STACK ENTRY        U002
         SH    R3,=Y(L'SAVESTK)         -> PREVIOUS ENTRY          U002
         ST    R3,SAVESTKP              -> NEW NEXT STACK ENTRY    U002
         L     R13,4(,R13)              -> PREVIOUS SAVE AREA      U002
         XC    8(4,R13),8(R13)          CLEAR FORWARD POINTER      U002
         LM    R2,R12,28(R13)           RESTORE CALLERS R2-R12     U002
         DROPX R2                       POPSTAK                    U002
         L     R14,12(,R13)             RESTORE RETURN REGISTER    U002
         LTR   R15,R15                  SET CC FROM RETURN CODE    U002
         BR    R14                      RETURN TO CALLER           U002
         LTORG                                                     U002
         TITLE 'ENQ - DSECTS'
WORKAREA DSECT                                                     U002
AREAA    DS    F                  ADDRESS OF Q AREA
AREAL    DS    F                  LENGTH OF AREA
RIBL     DS    H                  LENGTH OF RIB
RIBEL    DS    H                  LENGTH OF RIBE
TOKEN    DS    F                  TOKEN FOR GQSCAN
GQRC     DS    F                  RETURN CODE FROM GQSCAN
NRIBS    DS    F                  NUMBER OF RIBS RETURNED
NRIBES   DS    F                  NUMBER OF RIBES THIS RIB
NCRIBES  DS    F                  NUMBER OF RIBES IN THIS AREA
GQLIST   GQSCAN MF=L
IOPLL    DS    4F
TSOECB   DS    F
GETADDR  DS    F                  ADDR OF BUFFER RETURNED BY PUTGET
GETLEN   DS    F                  LENGTH OF BUFFER RETURNED BY PUTGET
CURIN    DS    F                  POINTER TO CURRENT INPUT POSITION
CUREND   DS    F                  POINTER PAST END OF CURRENT INPUT
OLD      DS    2F                 OUTPUT LINE DESCRIPTOR
PARMLSTS EQU   *
PUTLL    PUTLINE MF=L             PUTLINE PARM BLOCK
         ORG   PARMLSTS
PUTGETL  PUTGET  MF=L             PUTGET PARM BLOCK
         ORG   PARMLSTS
GETMAINL GETMAIN VC,MF=L
         ORG   PARMLSTS
FREEML   FREEMAIN VU,MF=L
         ORG
QNL      DS    H                  QNAME LENGTH
RNL      DS    H                  RNAME LENGTH
JNL      DS    H                  JOBNAME LENGTH
FLGS     DS    X
CONTFLG  EQU   X'80'              RIB HAS BEEN FORMATTED
CONFLG   EQU   X'40'              CONFLICT COMMAND IN EFFECT
FINDFLG  EQU   X'20'              FIND COMMAND IN EFFECT
GLOBFLG  EQU   X'10'              GLOBAL COMMAND IN EFFECT
FLAG2    DS    B                  OTHER MISC FLAGS                 U003
F2CLEAR  EQU   X'08'              CLEAR SCREEN BEFORE EACH DISPLAY U004
F2RSRV   EQU   X'04'              'RESERVE' SUBCOMMAND IN EFFECT   U003
QNAME    DS    CL8                QUEUE NAME
JNAME    DS    CL8                JOB NAME
RNAME    DS    CL255              RNAME
PRTLEN   DS    H                  PRINTLINE LENGTH
PRTOFF   DS    H                  OFFSET
PRTBUFF  DS    (900)CL1           OUTPUT BUFFER                    U005
         ORG   PRTBUFF+1                                           U001
PRTSCOPE DS    C                  J(JOB) Y(SYSTEM) Z(SYSTEMS)      U001
PRTTYPE  DS    C                  S(SHARED) E(EXCLUSIVE)           U001
PRTSTAT  DS    C                  G(OWNED) W(WAITING)              U001
PRTRSRV  DS    C                  R(RESERVE)                       U001
PRTMC    DS    C                  M(MUST COMPLETE)                 U001
PRTBLNK1 DS    C                                                   U001
PRTJOBNM DS    CL8                JOBNAME                          U001
PRTBLNK2 DS    C                                                   U001
PRTDATA  DS    0C                                                  U001
         ORG   ,                                                   U002
SAVESTKP DC    A(0)                     -> NEXT ENTRY ON STACK     U002
SAVESTKL DC    A(0)                     -> LAST ENTRY ON STACK     U002
         DC    0D'0'                                               U002
SAVESTK  DC    2XL72'00'                TWO INTERNAL SAVE AREAS    U002
SAVESTKE EQU   *-L'SAVESTK              LAST ENTRY IN STACK        U002
         DC    0D'0'                                               U002
WORKALEN EQU   *-WORKAREA                                          U002
         IKJIOPL
UCB      DSECT
         IEFUCBOB
         EJECT
         ISGRIB
         END
