DIS1     TITLE '*** DISASSEMBLY PHASE 1 ***'
         MACRO
&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=
         GBLC  &EQU
         GBLC  &GM
         GBLC  &CSECT
         LCLC  &REGA
         AIF   (T'&NAME EQ 'O').NOCSECT
         AIF   ('&NAME' EQ '*').NOCSECT
&CSECT   SETC  '&NAME'
&CSECT   CSECT                         NAME OF PROGRAM
         AGO   .RST
.NOCSECT ANOP
&CSECT   SETC  '*'
         CSECT                         BEGINNING OF PROGRAM
.RST     ANOP
         AIF   ('&EQU' EQ 'ON').NRQ
&EQU     SETC  'ON'
*
***REGISTER EQUATES***
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.NRQ     ANOP
*
*******************  PROGRAM INITIALIZATION  *************************
*
         AIF   (T'&REG1 EQ 'O').NOREG
&REGA    SETC  '&REG1'
         AIF   (T'&REG2 EQ 'O').ONEREG
         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY
         AGO   .BYUSE
.NOREG   ANOP
&REGA    SETC  'R3'
.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY
.BYUSE   ANOP
         STM   R14,R12,12(R13)         STORE REGS IN HIGH SAVE AREA
         LR    &REGA,R15                  INITIALIZE BASE REG
         AIF   (T'&REG2 EQ 'O').NOLA
         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND
         LA    &REG2,1(&REG2)                BASE REGISTER
.NOLA    ANOP
         AIF   (T'&REG3 EQ 'O').NOLNK
         L     &REG3,0(R1)                GET PARAMETER LIST ADDR
.NOLNK   ANOP
         AIF (T'&IND EQ 'O').GETIT
         CNOP  0,4
         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA
SAVEAREA DS    18F                     REGISTER SAVE AREA
         ST    R15,8(R13)
         ST    R13,SAVEAREA+4
         LR    R13,R15
         AGO   .NOSAVE
.GETIT   ANOP
         AIF   (T'&LV EQ 'O').GMD
&GM      SETC  '&LV'
         AGO   .DGM
.GMD     ANOP
&GM      SETC  '72'
.DGM     ANOP
*
***GET MAIN STORAGE FOR SAVE AREA***
*
         AIF   ('&GM' LT '4096').LA
         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA
         AGO   .EGM
.LA      ANOP
         LA    R0,&GM                  GET &GM BYTES
         GETMAIN R,LV=(0)
.EGM     ANOP
*
***SET UP SAVE AREA POINTERS***
*
         ST    R1,8(R13)               STORE LOW SAVE POINTER
         ST    R13,4(R1)               STORE HIGH SAVE POINTER
         LR    R13,R1                  INITIALIZE SAVE POINTER
         AIF   (T'&REG3  NE 'O').NOSAVE
         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG
         L     R1,24(R1)               RESTORE PARAMETER REGISTER
.NOSAVE  ANOP
         AIF   ('&CSECT' EQ '*').EXIT
         B     *+12
         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.
.EXIT    ANOP
*
*********************  END INITIALIZATION  ***************************
*
         MEND
         EJECT
DISASM1  SVLNK R3,R4
         PRINT NOGEN
* THIS SUB-PROGRAM IS CALLED BY DISASM, AND IS PHASE 2 OF
* THE DISASSEMBLY PROCESS. A COMMON DATA
* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
*    THE SYSIN FILE IS READ TO EXHAUSTION. USING CARDS ARE
* REFORMATTED AND STORED IN A TABLE - UP TO 256 USING
* STATEMENTS MAY BE ENTERED. DSECT CARDS MAY FOLLOW THE
* USING STATEMENTS. WHEN USED, DSECT STATEMENTS ARE
* REFORMATTED, AND BUILT INTO TABLES. A MAXIMUM OF 256 DSECTS
* MAY BE ENTERED. DATA ONLY CARDS MAY BE INCLUDED BEFORE, BETWEEN,
* OR AFTER DSECTS TO SHOW AREAS IN THE PROGRAM WHERE NO INSTRUCTIONS
* OCCUR. UP TO 256 DATA ONLY AREAS MAY BE SPECIFIED.
*
*     AT EOF ON SYSIN, A PSEUDO DIS-ASSEMBLY PASS IS MADE
* USING THE TEXT STORED BY DISASM. ANY RESOLVABLE ADDRESS
* WITHIN THE TEXT IS USED TO CREATE A NEW ENTRY IN THE
* LABEL TABLE, WHICH WILL BE USED BY DISASM2 IN THE
* ACTUAL DIS-ASSEMBLY PASS.
*
* THE USING CARDS FOR BASE REGISTERS ASSOCIATED WITH DSECT DEFINITIONS
* MUST BE ENTERED AT SOME POINT AFTER THE DSECT CARDS HAVE BEEN
* INCLUDED. USING CARDS FOR PROGRAM BASE REGISTERS MAY BE ENTERED
* AT ANY POINT. THE USING CARD FORMAT IS:
*       COL 1-5   : LITERAL 'USING'
*       COL 6     : BLANK
*       COL 7-12  : OFFSET TO BEGIN LOCATION FOR USING RANGE (HEX)
*       COL 13    : BLANK
*       COL 14-19 : OFFSET TO ENDING LOCATION FOR USING RANGE (HEX)
*       COL 20    : BLANK
*       COL 21    : BASE RESISTER TO BE USED (HEX, 1-F)
*       COL 22    : BLANK
*       COL 23    : TYPE, P=PROGRAM BASE, D=DSECT BASE
*       COL 24    : BLANK
*       COL 25-30 : INITIAL BASE REGISTER VALUE IF TYPE P (HEX)
*       COL 25-32 : DSECT NAME IF TYPE D
*
*     A DSECT IS ENTERED USING A HEADER CARD,FOLLOWED BY
* ONE OR MORE FIELD DEFINITION CARDS. ALL FIELD DEFINITION
* CARDS MUST FOLLOW THE DSECT HEADER CARD. USING CARDS MAY
* NOT BE INTERSPERSED WITH DSECT DEFINITIONS, BUT MAY PRECEDE
* OR FOLLOW ANY DSECT.
*     DSECT HEADER CARD FORMAT:
*        COL 1-8    : DSECT NAME
*        COL 9      : BLANK
*        COL 10-14  : LITERAL 'DSECT'
*        COL 15     : BLANK
*        COL 16-19  : NUMBER OF FIELD CARDS TO FOLLOW (DECIMAL)
*
*     DSECT FIELD CARD FORMAT:
*        COL 1-8    : FIELD NAME
*        COL 9      : BLANK
*        COL 10-13  : OFFSET TO LEFT END OF FIELD (DECIMAL)
*        COL 14     : BLANK
*        COL 15-17  : LENGTH OF FIELD IN BYTES (DECIMAL)
*
*     A DATA ONLY CARD IS USED TO DESIGNATE A RANGE OF OFFSETS
* BETWEEN WHICH NO INSTRUCTIONS EXIST. USE OF THESE CARDS ELIMINATES
* THE CHANCE THAT DATA ELEMENTS WILL BE TREATED AS INSTRUCTIONS
* BETWEEN THE OFFSETS SPECIFIED. FORMAT IS:
*        COL 1-4    : LITERAL 'DATA'
*        COL 5      : BLANK
*        COL 6-11   : OFFSET TO BEGINNING OF AREA (HEX)
*        COL 12     : BLANK
*        COL 13-18  : OFFSET TO END OF AREA (HEX)
*
*
*     USER LABEL CARDS ARE USED TO PERMIT SPECIFICATION OF
* LABELS OTHER THAN THE AXXXXXX NAMES CREATED BY DISASM. THEY
* MAY APPEAR ANYWHERE IN THE SYSIN STREAM EXCEPT AS THE FIRST
* CARD, OR WITHIN A DSECT DEFINITION.
*        COL  1-5  : LITERAL 'ULABL'
*        COL   6   : BLANK
*        COL  7-14 : FIELD NAME
*        COL   15  : BLANK
*        COL 16-21 : OFFSET TO LEFT END OF AREA (HEX)
*        COL   22  : BLANK
*        COL 23-25 : FIELD LENGTH (DECIMAL)
*
*      DISASSEMBLY TABLES ARE SET UP IDENTICALLY TO THOSE USED BY
* DISASM2 FOR THE SIMULATED DISASSEMBLY PERFORMED IN THIS
* MODULE WHEN ANY PROGRAM BASE REGISTER USING STATEMENTS
* ARE ENTERED.
*
*     STORAGE IS OBTAINED FOR THE DSECT TABLE AND USING TABLE,
* AND ADDRESSES OF THESE TABLES ARE STORED IN THE COMMON PARAMETER
* AREA. USING AND DSECT CARDS ARE EDITED, REFORMATTED, AND PLACED
* IN THE APPROPRIATE TABLES. IF ANY ERRORS ARE FOUND, THEY ARE
* PRINTED, AND THE DISASSEMBLY WILL BE TERMINATED ON RETURN
* TO DISASM.
*
*     STORAGE IS OBTAINED FOR THE LABEL TABLE, AND A SIMULATED
* DIS-ASSEMBLY IS PERFORMED TO CREATE LABEL TABLE ENTRIES FOR
* LABELS WHICH WILL BE GENERATED FOR BASE-DISPLACEMENT ADDRESSES
* BY DISASM2. ON RETURN TO DISASM, THESE LABELS WILL BE SORTED
* WITH EXTERNAL SYMBOL AND RLD LABELS TO FORM THE FINAL LABEL
* TABLE TO BE USED BY DISASM2.
*
*
*
*
* AUTHOR R THORNTON - FEB 1978
* UPDATED ROBERT STYMA - JAN 1989 AND MARCH 1991
* UPDATED ALAN C FIELD - APR 1990
*
*
******************************************************************
*                                                                *
* CHECK FOR PRIVILEGED AND/OR FLOATING POINT INSTRUCTION OPTION. *
* IF THESE INSTRUCTIONS ARE NOT TO BE ASSEMBLED, CLEAR THEIR     *
* INSTRUCTION TABLE ENTRIES.                                     *
*                                                                *
******************************************************************
*
         L     R5,0(R1)                GET PARM FIELD ADDRESS
         USING COMMPARM,R5
         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.
         BE    TSTPRIV                 YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TSTOPND  CLI   0(R12),X'FF'            END OF TBL
         BE    TSTPRIV                 YES
         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT
         BZ    FLPSTP                  NO
         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY
FLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TSTOPND                 LOOP THRU TABLE
TSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    GETUSGTB                YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TTOPND   CLI   0(R12),X'FF'            END OF TABLE
         BE    CKDBLS                  YES
         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR
         BZ    PRIVSTP                 NO
         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY
PRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TTOPND                  LOOP THRU TABLE
CKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL
CKDBND   CLI   0(R12),X'FF'            END OF TBL
         BE    GETUSGTB                YES
         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE
         BZ    DBSTP                   NO
         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY
DBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY
         B     CKDBND                  LOOP THRU TABLE
*
******************************************************************
*                                                                *
* GET STORAGE FOR USING AND DSECT POINTER TABLES.                *
*                                                                *
******************************************************************
*
GETUSGTB GETMAIN R,LV=2864             GET STORAGE FOR USING TABLE
         MVI   0(R1),X'FF'             SET TABLE END INDIC
         ST    R1,USGSTRT              SAVE TABLE START ADDR
         ST    R1,USGCUR               SET TABLE CURRENT ADDR
         LA    R1,2816(R1)             COMPUTE TABLE END ADDR
         ST    R1,USGEND               SAVE USING TABLE END ADDR
         L     R2,INDCB                GET SYSIN DCB ADDR
         LA    R1,EOFCARD              GET EOF ADDR
         STCM  R1,7,33(R2)             SET EOF ADDR IN DCB
         GETMAIN R,LV=2864             GET STORAGE FOR DSECT TABLE
         MVI   0(R1),X'FF'             SET TABLE END ADDR
         ST    R1,DTBSTRT              SAVE DSECT TABLE START ADDR
         ST    R1,DTBCUR               SAVE DSECT TABLE CURRENT ADDR
         LA    R1,2816(R1)             COMPUTE TABLE END ADDR
         ST    R1,DTBEND               SAVE DSECT TABLE END ADDR
         L     R1,INDCB                @ SYSIN DCB
         TM    48(R1),X'10'            IS IT OPEN
         BZ    EOFCARD                 NO
*
*
*
******************************************************************
*                                                                *
* READ SYSIN CARDS, AND DISTRIBUTE TO THE APPROPRIATE PROCESSING *
* ROUTINE: USINGS, DSECTS, OR DATAS. DETECT ANY ERRORS AND PRINT *
* ALL CARDS WITH MESSAGES AS NECESSARY.                          *
*                                                                *
******************************************************************
*
RDCARD   EQU   *                       *** PROCESS SYSIN CARDS ***
         L     R1,INDCB                GET SYSIN DCB ADDR
         GET   (1)                     READ NEXT CARD
         MVC   WORKREC,0(R1)           MOVE IT TO WORK AREA
         NOP   MVPRT                   FIRST TIME SWITCH
         MVI   *-3,C'0'                RESET FIRST TIME SWITCH
         MVI   PCC,C'1'                SET SKIP TO HEAD
         MVC   PRT+10(26),=C'*** USER ENTERED CARDS ***'
         BAL   R9,PRINT                GO PRINT
MVPRT    MVC   PRT(80),WORKREC         CARD TO PRINT
RDGRTN   LA    R9,RCCKERR              GET RETURN ADDRESS
         CLC   WORKREC(5),=C'USING'    IS IT A USING CARD
         BE    USINGS                  YES
         CLC   WORKREC+9(5),=C'DSECT'  IS IT A DSECT HEADER
         BE    DSECTS                  YES
         CLC   WORKREC(4),=C'DATA'     IS IT DATA ONLY CARD
         BE    DATAS                   YES
         CLC   WORKREC(5),=C'ULABL'    IS IT A USER LABEL
         BE    ULABLS                  YES
         MVC   PRT+85(21),=C'UNIDENT OR OUT OF SEQ'
         MVI   USERR,X'FF'             SET ERROR FLAG
RCCKERR  NI    USERR,X'FE'             RESET CURRENT ERROR FLAG
         BAL   R9,PRINT                GO PRINT
         B     RDCARD                  CONTINUE
EOFCARD  CLI   USERR,0                 ANY ERRORS FOUND
         BNE   EOJ                     YES, EXIT
*
******************************************************************
*                                                                *
* CHECK FOR ANY USING CARDS ENTERED. IF NOT, NO PRE-ASSEMBLY IS  *
* NECESSARY. IF ANY USING CARDS FOUND, CREATE LABEL TABLE ENTRIES*
* SO THAT USING STATEMENTS WILL BE VALID.                        *
*                                                                *
******************************************************************
*
         L     R1,DATOCUR              GET CURRENT DATA ONLY @
         MVC   NOINAD,DATONLY          SAVE DATA ONLY TBL ADDR
         MVC   0(3,R1),HIVAL           SET END
         L     R11,USGSTRT             GET USING TBL ADDR
CUSNGND  CLI   0(R11),X'FF'            END OF TABLE
         BE    CKPRE                   GO CHECK FOR PRE-DISASM
         L     R10,CURRLBL             GET LABEL ADDRESS
         USING USINGD,R11
         USING LABELD,R10
         MVC   LBLADR,USVALU           OFFSET TO LABEL
         MVI   LBLTYP,C'L'             LABEL TYPE ENTRY
         MVI   LBLLEN,1                SET LENGTH TO 1
         MVI   LBLNAME,C'A'            1ST CHAR OF NAME
         LA    R12,USVALU              @ OFFSET
         BAL   R9,HEXPRT3              CONVERT
         MVC   LBLNAME+1(6),PRTABL     MIDDLE OF NAME
         MVI   LBLNAME+7,C' '          BLANK LAST POS
         LA    R10,L'LABEL(R10)        STEP TO NEXT LABEL
         ST    R10,CURRLBL             SAVE IN CURRLBL     FIX******
         MVC   0(3,R10),HIVAL          SET END VALUE       FIX******
         LA    R11,L'USING(R11)        STEP TO NEXT USING
         B     CUSNGND                 LOOP
         DROP  R10
         DROP  R11
CKPRE    L     R1,USGSTRT              GET USING TBL START ADDR
         CLI   0(R1),X'FF'             ANY ENTRIES
         BNE   MAINLINE                YES, GO TO PRE-DISASM
         B     EOJ                     OTHERWISE GET OUT
*
*
*
*
******************************************************************
*                                                                *
* EDIT USING CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* USING TABLE.                                                   *
*                                                                *
******************************************************************
*
USINGS   EQU   *                       *** USING CARD PROCESSING ***
         L     R12,USGCUR              GET CURRENT USING TBL ADDR
         C     R12,USGEND              END OF TBL
         BNL   UERR6                   YES, TABLE FULL
         USING USINGD,R12
         TR    WORKREC+6(6),TRHEX      TRANSLATE TO MAKE HEX
         TRT   WORKREC+6(6),TRTHEX     CHECK VALID
         BNZ   UERR1                   INVALID BEGIN ADDR
         TR    WORKREC+13(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+13(6),TRTHEX    CHECK VALID
         BNZ   UERR2                   INVALID END ADDR
         TR    WORKREC+20(1),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+20(1),TRTHEX    CHECK VALID
         BNZ   UERR3                   INVALID BASE REG
*        CLI   WORKREC+20,0            VALID BASE REG
*        BE    UERR3                   NO
         CLI   WORKREC+22,C'P'         VALID TYPE
         BE    CKINIT                  YES, PROGRAM BASE
         CLI   WORKREC+22,C'D'         VALID TYPE
         BNE   UERR8                   NO, ERROR
         L     R1,DTBSTRT              GET DSECT TABLE STRT
CKDSEND  CLI   0(R1),X'FF'             END OF TABLE
         BE    UERR5                   YES, MISSING DSECT
         CLC   0(8,R1),WORKREC+24      THIS THE DSECT ENTRY
         BE    USDSMV                  YES
         LA    R1,11(R1)               TO NEXT ENTRY
         B     CKDSEND                 LOOP THRU DSECT TABLE
USDSMV   MVC   USVALU,8(R1)            MOVE DSECT TBL ADDR
         B     USFINI                  CONTINUE
CKINIT   TR    WORKREC+24(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+24(6),TRTHEX    CHECK VALIDITY
         BNZ   UERR4                   INVALID BASE REG VALUE
         PACK  DBLWD(4),WORKREC+24(7)  PACK TO MAKE HEX
         MVC   USVALU,DBLWD            BASE REG VALUE TO USING TBL
USFINI   PACK  DBLWD(4),WORKREC+6(7)   PACK TO MAKE HEX
         MVC   USBGN,DBLWD             BEGIN ADDR TO USING TABLE
         PACK  DBLWD(4),WORKREC+13(7)  PACK TO MAKE HEX
         MVC   USEND,DBLWD             END ADDR TO USING TABLE
         TM    USEND+2,1               IS IT ODD
         BO    UERR2                   YES, ERROR
         CLI   WORKREC+22,C'D'         DSECT BASE
         BE    USFREG                  YES
         CLC   USEND,LENGTH+1          WITHIN PROGRAM
         BH    UERR2                   YES, ERROR
USFREG   MVC   USREG,WORKREC+20        BASE REG TO USING TABLE
         MVC   USTYPE,WORKREC+22       TYPE TO USING TABLE
         CLC   USBGN,USEND             END < BEGIN
         BH    UERR7                   YES, ERROR
         LA    R12,L'USING(R12)        TO NEXT USING TBL ENTRY
         MVI   0(R12),X'FF'            SET TABLE END INDIC
         ST    R12,USGCUR              SAVE UPDATED TABLE ADDR
         BR    R9                      EXIT
UERR1    MVC   PRT+85(22),=C'INVALID BEGIN COL 7-12'
         B     UERRS                   CONTINUE
UERR2    MVC   PRT+85(21),=C'INVALID END COL 14-19'
         B     UERRS                   CONTINUE
UERR3    MVC   PRT+85(18),=C'INVALID REG COL 21'
         B     UERRS                   CONTINUE
UERR4    MVC   PRT+85(25),=C'INVALID ADDRESS COL 25-30'
         B     UERRS                   CONTINUE
UERR5    MVC   PRT+85(25),=C'UNDEFINED DSECT COL 25-32'
         B     UERRS                   CONTINUE
UERR6    MVC   PRT+85(20),=C'OVER 256 USING CARDS'
         B     UERRS                   CONTINUE
UERR7    MVC   PRT+85(16),=C'END BEFORE BEGIN'
         B     UERRS                   CONTINUE
UERR8    MVC   PRT+85(19),=C'INVALID TYPE COL 23'
UERRS    MVI   USBGN,X'FF'             INSURE TABLE END INDIC
         MVI   USERR,X'FF'             SHOW ERROR
         BR    R9                      EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* EDIT ULABL CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* LABEL TABLE. SEARCH FOR ANY TYPE A (ADCON) ENTRIES HAVING A    *
* SYMBOL OF AXXXXXX, WHERE XXXXXX IS THE HEX OFFSET TO THE USER  *
* LABEL. IF AN A TYPE ENTRY IS FOUND, CHANGE ITS SYMBOLIC NAME TO*
* THAT OF THE USER LABEL.                                        *
*                                                                *
******************************************************************
*
ULABLS   EQU   *                       PROCESS USER LABEL CARDS
         STM   R6,R12,ULSAV            SAVE REGS
         CLI   WORKREC+6,C' '          NAME VALID
         BE    ULERR1                  NO, 1ST CHAR CANNOT BE BLANK
         MVC   UNAME+1(6),WORKREC+15   BUILD AXXXXXX NAME
         TR    WORKREC+15(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+15(6),TRTHEX    CHECK VALID HEX
         BNZ   ULERR2                  NOT VALID
         MVZ   NUMCK,WORKREC+22        ZONES FOR NUMERIC TEST
         CLC   NUMCK(3),ZEROS          LENGTH IS NUMERIC
         BNE   ULERR3                  NO, ERROR
         L     R6,CURRLBL              GET CURRENT LABEL TABLE ADDRESS
         USING LABELD,R6
         C     R6,ENDLBL               END OF TABLE
         BNL   ULERR4                  YES, ERROR
         MVC   LBLNAME,WORKREC+6       NAME TO LABEL ENTRY
         MVI   LBLTYP,C'U'             TYPE TO LABEL ENTRY
         PACK  DBLWD,WORKREC+22(3)     PACK LENGTH
         CP    DBLWD,P256              LENGTH > 256
         BH    ULERR2                  YES, ERROR
         CVB   R12,DBLWD               CONVERT TO BINARY
         STC   R12,LBLLEN              LENGTH TO LABEL ENTRY
         PACK  DBLWD(4),WORKREC+15(7)  PACK TO MAKE VALID HEX
         MVC   LBLADR,DBLWD            OFFSET TO LABEL
         LA    R7,L'LABEL(R6)          @ NEXT LABEL ENTRY
         MVC   0(3,R7),HIVAL           SET END INDIC
         ST    R7,CURRLBL              SET NEW TABLE END ADDR
         LR    R7,R6                   SAVE NEW ENTRY ADDRESS
         L     R6,LBLTBL               GET 1ST LABEL ENTRY ADDR
ULBCKND  C     R6,CURRLBL              END OF TABLE
         BNL   ULXIT                   YES, EXIT
         CLI   LBLTYP,C'A'             IS IT ADCON ENTRY
         BNE   ULBSTEP                 NO
         CLC   LBLNAME,UNAME           ADCON SYMBOL AT USER LBL ADDR
         BNE   ULBSTEP                 NO
         MVC   LBLNAME,LBLNAME-LABEL(R7) SET USER SYMBOL IN ADCON
ULBSTEP  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         B     ULBCKND                 LOOP THRU LABEL TABLE
         B     ULXIT                   EXIT
ULERR1   MVC   PRT+85(21),=C'INVALID NAME COL 7-14'
         B     ULERRS                  CONTINUE
ULERR2   MVC   PRT+85(28),=C'INVALID HEX OFFSET COL 16-21'
         B     ULERRS                  CONTINUE
ULERR3   MVC   PRT+85(32),=C'INVALID DECIMAL LENGTH COL 23-25'
         B     ULERRS                  CONTINUE
ULERR4   MVC   PRT+85(20),=C'LABEL TABLE OVERFLOW'
ULERRS   MVI   USERR,X'FF'             SET ERROR FLAG
ULXIT    LM    R6,R12,ULSAV            RESTORE REGS
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* EDIT DSECT CARDS FOR VALIDITY. PUT APPROPRIATE COMMENT IN PRINT*
* LINE WHEN INVALID. WHEN NO ERRORS FOUND, CREATE AN ENTRY IN THE*
* DSECT HEADER TABLE, GETMAIN AN AREA TO CONTAIN THE FIELD       *
* DESCRIPTION ENTRIES, READ AND BUILD FIELD ENTRIES FOR ALL FIELD*
* DESCRIPTION CARDS ENTERED.                                     *
*                                                                *
******************************************************************
*
DSECTS   EQU   *                       *** DSECT PROCESSING ***
         ST    R9,DSCT9                SAVE RETURN ADDR
         CLI   WORKREC,C' '            NAME IS BLANK
         BE    DSERR1                  YES, ERROR
         MVZ   NUMCK,WORKREC+15        ZONES FOR CHECK
         CLC   NUMCK,ZEROS             IS NBR FIELDS NUMERIC
         BNE   DSERR2                  NO, ERROR
         L     R12,DTBCUR              GET CURRENT DSECT TBL ADDR
         C     R12,DTBEND              AT END OF TABLE
         BNL   DSERR3                  YES, ERROR
         MVC   0(8,R12),WORKREC        NAME TO DSECT TABLE
         PACK  DBLWD,WORKREC+15(4)     PACK NBR ENTRIES
         CVB   R10,DBLWD               CONVERT TO BINARY
         LA    R10,4(R10)              ADD FOR SAFETY
         MH    R10,DTBLEN              TIMES ENTRY LENGTH
         GETMAIN R,LV=(10)             GET STORAGE FOR FIELD TABLE
         STCM  R1,7,8(R12)             SAVE FIELD TABLE ADDRESS
         LA    R12,11(R12)             TO NEXT DSECT TABLE ENTRY
         ST    R12,DTBCUR              UPDATE CURRENT DSECT TBL ADDR
         MVI   0(R12),X'FF'            SET END INDIC
         LR    R12,R1                  COPY FIELD TABLE ADDR
         BAL   R9,PRINT                PRINT DSECT RECORD
         USING DSECTD,R12
         CVB   R11,DBLWD               NBR ENTRIES IN LOOP REG
RDFLD    L     R1,INDCB                GET SYSIN DCB ADDR
         GET   (1)                     READ NEXT CARD
         MVC   WORKREC,0(R1)           MOVE RECORD TO WORK AREA
         MVC   PRT(80),WORKREC         MOVE RECORD TO PRINT AREA
         CLI   WORKREC,C' '            NAME FIELD BLANK
         BE    DSERR1                  YES, ERROR
         MVC   DSNAME,WORKREC          NAME TO ENTRY
         MVI   DSLBTYP,C'L'            SET LABEL TYPE
         MVZ   NUMCK,WORKREC+9         ZONES FOR TEST
         CLC   NUMCK,ZEROS             IS OFFSET NUMERIC
         BNE   DSERR3                  NO, ERROR
         PACK  DBLWD,WORKREC+9(4)      PACK OFFSET
         CP    DBLWD,P4096             OFFSET > 4096
         BH    DSERR3                  YES, ERROR
         CVB   R1,DBLWD                CONVERT
         STCM  R1,7,DSOFSET            OFFSET TO TABLE ENTRY
         MVZ   NUMCK(3),WORKREC+14     ZONES FOR TEST
         CLC   NUMCK(3),ZEROS          IS LENGTH NUMERIC
         BNE   DSERR4                  NO, ERROR
         PACK  DBLWD,WORKREC+14(3)     PACK LENGTH
         CP    DBLWD,P256              LENGTH OVER 256
         BH    DSERR4                  YES, ERROR
         CVB   R1,DBLWD                CONVERT
         LTR   R1,R1                   LENGTH IS ZERO
         BZ    DSERR4                  YES, ERROR
         STC   R1,DSLENG               LENGTH TO TABLE ENTRY
         LA    R12,L'DSECT(R12)        TO NEXT ENTRY
         MVI   0(R12),X'FF'            SET TBL END INDIC
         BAL   R9,PRINT                GO PRINT CARD
         BCT   R11,RDFLD               LOOP THRU DSECT
         MVC   DSOFSET,HIVAL           TABLE STOPPER
         L     R9,DSCT9                GET RETURN ADDR
         BR    R9                      EXIT
DSERR1   MVC   PRT+85(20),=C'INVALID NAME COL 1-8'
         B     DSERRS                  CONTINUE
DSERR2   MVC   PRT+85(28),=C'INVALID NBR FIELDS COL 16-19'
         B     DSERRS                  CONTINUE
DSERR3   MVC   PRT+85(24),=C'INVALID OFFSET COL 10-13'
         B     DSERRS                  CONTINUE
DSERR4   MVC   PRT+85(24),=C'INVALID LENGTH COL 15-18'
         B     DSERRS                  CONTINUE
DSERRS   MVI   USERR,X'FF'             SHOW ERROR FOUND
         L     R9,DSCT9                GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* EDIT DATA ONLY CARDS FOR VALIDITY. PLACE ERROR DESCRIPTION IN  *
* PRINT LINE IF ERRORS FOUND. CREATE DATA ONLY TABLE ENTRY IF NO *
* ERRORS ARE FOUND.                                              *
*                                                                *
******************************************************************
*
DATAS    EQU   *                       *** DATA CARD PROCESSING ***
         TR    WORKREC+5(6),TRHEX      TRANSLATE TO MAKE HEX
         TRT   WORKREC+5(6),TRTHEX     CHECK VALID
         BNZ   DERR1                   INVALID HEX
         TR    WORKREC+12(6),TRHEX     TRANSLATE TO MAKE HEX
         TRT   WORKREC+12(6),TRTHEX    CHECK VALID
         BNZ   DERR2                   INVALID HEX
         PACK  DBLWD(4),WORKREC+5(7)   PACK TO MAKE HEX
         PACK  DBLWD+4(4),WORKREC+12(7) PACK TO MAKE HEX
         CLC   DBLWD(3),DBLWD+4        CHECK 1ST LOW
         BNL   DERR3                   1ST NOT LOW, ERROR
         L     R1,DATOCUR              GET TBL ADDR
         MVC   0(3,R1),DBLWD           MOVE 1ST OFFSET TO TBL
         MVC   3(3,R1),DBLWD+4         MOVE 2ND OFFSET TO TBL
         LA    R1,6(R1)                TO NEXT ENTRY
         ST    R1,DATOCUR              SAVE CURRENT ENTRY ADDR
         BR    R9                      EXIT
DERR1    MVC   PRT+85(22),=C'1ST OFFSET INVALID HEX'
         B     DERRS                   CONTINUE
DERR2    MVC   PRT+85(22),=C'2ND OFFSET INVALID HEX'
         B     DERRS                   CONTINUE
DERR3    MVC   PRT+85(23),=C'END OFFSET BEFORE BEGIN'
DERRS    MVI   USERR,X'FF'             FLAG ERROR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR THE PRE-DISASSEMBLY. PURPOSE OF THIS PART *
* OF THE PROGRAM IS TO ATTEMPT TO CREATE A LABEL ENTRY FOR INSTR-*
* UCTIONS HAVING STORAGE OPERANDS. THE RESULTING LABEL TABLE WILL*
* BE SORTED, AND DUPLICATE ENTRIES ELIMINATED BEFORE EXIT FROM   *
* THIS PHASE OF DISASSEMBLY.                                     *
*                                                                *
******************************************************************
*
MAINLINE EQU   *                       MAINLINE ROUTINE
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         BNL   EOJ                     YES             FIX********
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE USING TBLS
         BH    CKDARNG                 NO
         BAL   R9,NEXUSG               YES, GO DO IT
CKDARNG  L     R12,NOINAD              GET DATA ONLY ENTRY ADDRESS
         CLC   TXTOFSET,0(R12)         NOT YET TO THIS RANGE
         BL    CKLOSEQ                 TRUE
         CLC   TXTOFSET,3(R12)         NOW IN THE RANGE
         BNH   CONST                   TRUE, TREAT AS CONSTANT
         LA    R12,6(R12)              PAST THIS ONE, STEP TO NEXT
         ST    R12,NOINAD              SAVE NEW ADDRESS
         B     CKDARNG                 AND CHECK AGAIN
CKLOSEQ  DS    0H
         C     R6,CURRLBL              END OF USED LABEL TABLE?
         BNL   GCKODD                  IF SO, IGNORE LABEL STUFF
         CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         BNH   GCKODD                  NO, CONTINUE
         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL
         B     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTCURR+3,1             ODD ADDRESS
         BO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         BE    CONST                   YES, NOT INSTR
         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE
         BNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         BNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         BE    CONST                   YES, ADD THIS TO CONSTANT
CK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS
         BZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  SR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MH    R8,SGOPLEN              TIMES TABLE LENGTH
         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         BE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE
         BNE   INSTR                   NO
         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         BE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         BE    GOTDBLI                 YES
         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY
         B     DBLND                   LOOP THRU TBL
GOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES
*
*
*
******************************************************************
*                                                                *
* CHECK TO SEE IF THIS BYTE OF THE PROGRAM IS AN INSTRUCTION OP  *
* CODE. IF SO, PERFORM THE APPROPRIATE PROCESSING ROUTINE.       *
*                                                                *
******************************************************************
*
INSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***
         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         SR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE
         BNE   ICKSEC                  YES
         CLI   0(R7),X'45'             IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'4D'            IS IT BAS
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'0B'            IS IT BSM
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),7                 NO, IS IT BCR
         BE    POSSB                   YES
         CLI   0(R7),X'47'             IS IT BC
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
         B     ICKTBL                  ACCEPT UNCOND BRCHS
ICKSEC   SR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH
         AR    R1,R12                  ADDR OF NEXT OP CODE
         SR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT OP-CODE
         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE
         BNE   ICKTBL                  YES
         CLI   0(R12),X'45'            IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'4D'            IS IT BAS
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'0B'            IS IT BSM
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'07'            NO, IS IT BCR
         BE    POSSB2                  YES
         CLI   0(R12),X'47'            IS IT BC
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB2   TM    1(R12),X'F0'            IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         BCTR  R12,R0                  BACK UP 1
         S     R12,TXTSTRT             RELATIVIZE IN CSECT
         CLM   R12,7,LBLADR            LBL TBL ADDR HERE
         BL    NOILBL                  NO
         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START
         BNE   CONST                   NO, MUST BE CONSTANT
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CONST                   NO
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   SETLBL                  NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
SETLBL   LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         B     ICKTBL                  GO CHECK NEXT LABEL
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   MVMNE                   NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
OPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
         BO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED
         BE    PFMFMT                  NO
         B     IVERFY                  YES, GO EDIT
PFMFMT   SR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR
         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN
         B     INSTOUT                 TYPE=0, RR
         B     RXOPND                  TYPE=4, RX
         B     SOPND                   TYPE=8, S
         B     SIOPND                  TYPE=C, SI
         B     RSOPND                  TYPE=10, RS
         B     SS1OPND                 TYPE=14, 1-LENGTH SS
         B     SS2OPND                 TYPE=18, 2-LENGTH SS
         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES
         B     RXOPND                  TYPE=20, CONDITIONAL BRANCH
         B     SVCOPND                 TYPE=24, SVC
         B     SSEOPND                 TYPE=28, SSE
         B     EOPND                   TYPE=2C, E
         B     INSTOUT                 TYPE=30, RRE 1 OPERAND
         B     INSTOUT                 TYPE=34, RRE 2 OPERANDS
OPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN
         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS
INSTOUT  AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE
         B     GETCURR                 CONTINUE TXT PROCESSING
*
*
*
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT NON-FLOATING-POINT OP     *
* CODES ARE INDEED OP-CODES.                                     *
*                                                                *
******************************************************************
*
IVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION
         TM    IEDT,EPR                EVEN-ODD REG PAIR
         BZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         BO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         BE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         BNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         BO    CONST                   YES, NOT INSTR
         SR    R1,R1                   CLEAR WORK
         SR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         BE    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         BZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         BZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'47'             BC OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         BZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         BZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         BZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         BZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         BZ    CONST                   NO, NOT INSTR
         B     PFMFMT                  YES, INSTR O.K.
*
*
*
******************************************************************
*                                                                *
* GENERAL OP-CODE TESTS TO VERIFY THAT FLOATING-POINT OP-CODES   *
* ARE INDEED OP-CODES.                                           *
*                                                                *
******************************************************************
*
FPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C
         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         BE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         BNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         BNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         BNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         BNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         BZ    PFMFMT                  YES, GOOD INSTR
         B     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         BE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         BNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         BZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         BNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         BO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    PFMFMT                  YES, ACCEPT INSTR
         B     CONST                   NO, NOT INSTR
*
*
*
******************************************************************
*                                                                *
* PROCESS TEXT BYTES DETERMINED TO BE CONSTANT DATA.             *
*                                                                *
******************************************************************
*
CONST    EQU   *                       *** PROCESS CONSTANTS ***
         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         BNE   CGETYP                  NO
CSTNEW   BAL   R9,FORCONST             FORCE IT OUT
         B     CCNEW                   GO START A NEW ONE
CGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CHEX                    IT'S HEX
         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE
         B     CCKTYP                  GO COMPARE
CHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE
CCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE
         BNE   CSTNEW                  NO
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         LA    R11,1(R11)              ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         BE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         BO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         BZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         BE    CCXIT1                  YES
         B     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         BL    CCXIT1                  NOT YET
CCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT
         B     CCXIT1                  FINISH
CCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES
         BNL   CCFIN1                  YES
CCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         B     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONLEN,XZROS            CLEAR LENGTH
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         BE    CLBLD                   YES
TRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CDATACON                NO
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         BNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         BNE   CDATACON                NO
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         B     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         SR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         BAL   R9,FORCONST             FORCE CONSTANT OUT
         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY
         B     GETCURR                 CONTINUE TEXT PROCESS
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* CLEAR OUT AREAS SET UP FOR CONSTANT DATA.                      *
*                                                                *
******************************************************************
*
FORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE
         MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVI   CONTYPE,0               RESET TYPE
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* PROCESS RX-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
RXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK REG
         ICM   R11,3,TEXT+2            GET BDDD
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    RXBDDD                  YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    RXBDDD                  YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    RXBDDD                  NO
         LA    R10,8                   YES, SET LENGTH = 8
RXBDDD   B     BDLADR                  CHECK LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS S-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS   *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
SOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***
         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         BE    SCK2                    YES
         CLI   0(R7),X'80'             NO, IS IT SSM
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         BE    4(R9)                   YES, NOT INSTR
SCK2     CLI   0(R7),X'B2'             OP-CODE IS B2
         BNE   SSTRT                   NO
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO
         BE    SSTRT                   YES
         CLI   1(R7),X'0B'             IPK INSTRUCTION
         BE    4(R9)                   YES, NOT INSTR
         CLI   1(R7),X'0D'             PTLB INSTR
         BE    4(R9)                   YES, NOT INSTR
SSTRT    SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    SBDDD                   YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    SBDDD                   YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    SBDDD                   NO
         LA    R10,8                   YES, SET LENGTH = 8
SBDDD    B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SI-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
SIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LA    R10,0                   LENGTH=DON'T CARE
         B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS RS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESS  *
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION.         *
*                                                                *
******************************************************************
*
RSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'88'             IS IT SHIFT INSTR
         BL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         BH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZ    0(R9)                   YES, GOOD SHIFT
         B     4(R9)                   NO, NOT INSTR
RSCMA1   SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDD ADDRESS
         LA    R10,4                   SET LENGTH = 4
         TM    INLNG,E4                FULLWORD OPERAND
         BO    RSBDDD                  YES
         LA    R10,2                   SET LENGTH = 2
         TM    INLNG,E2                HALFWORD OPERAND
         BO    RSBDDD                  YES
         LA    R10,1                   SET LENGTH = 1
         TM    INLNG,E8                DOUBLEWORD OPERAND
         BZ    RSBDDD                  NO
         LA    R10,8                   YES, SET LENGTH = 8
RSBDDD   B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* SINGLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
*
SS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LA    R1,SS1RTN               GET RTEURN ADDR
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDR
         B     BDLADR                  CHECK LABEL
SS1RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         SR    R10,R10                 CLEAR LENGTH REG
         IC    R10,TEXT+1              GET INSTR LENGTH
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SS-FORMAT INSTRUCTIONS. THE BASE-DISPLACEMENT ADDRESSES*
* WILL BE SENT TO THE BDLADR ROUTINE FOR LABEL CREATION. THE     *
* DOUBLE-LENGTH SS FORMAT INSTRUCTIONS ARE HANDLED HERE.         *
*                                                                *
******************************************************************
*
SS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         LA    R1,SS2RTN               GET RETURN ADDR
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDRESS
         B     BDLADR                  CHECK LABEL
SS2RTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         BNE   SS2BDDD                 NO
         IC    R10,TEXT+1              GET INSTR LENGTH
         SRL   R10,4                   SHIFT OUT I3
SS2BDDD  LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         B     BDLADR                  CHECK LABEL
*
*
*
******************************************************************
*                                                                *
* PROCESS SVC INSTRUCTIONS. THE SOLE PROCESSING IS TO VERIFY THAT*
* THIS IS A VALID SVC.                                           *
*                                                                *
******************************************************************
*
SVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***
         CLI   TEXT+1,126              VALID OPERAND
         BH    NOTSVC                  NO, NOT SVC
         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         BE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         BE    GOTSVC                  YES
         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY
         B     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   BR    R9                      EXIT, NO STORAGE OPND
*
*
*
******************************************************************
*                                                                *
* PROCESS SSE INSTRUCTIONS.                                      *
*                                                                *
******************************************************************
*
SSEOPND  EQU   *                       *** SSE INSTRUCTIONS ***
         LA    R1,SSERTN               GET RTEURN ADDR
         MVC   SAVOP9,OPND9            SAVE NORMAL RETURN ADDR
         ST    R1,OPND9                CHANGE RETURN ADDR
         SR    R10,R10                 CLEAR LENGTH REG
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET FIRST BDDD ADDRESS
         B     BDLADR                  CHECK LABEL
SSERTN   MVC   OPND9,SAVOP9            RESTORE NORMAL RETURN ADDR
         SR    R10,R10                 CLEAR LENGTH REG
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         B     BDLADR                  CHECK FOR LABEL
*
*
*
******************************************************************
* PROCESS E INSTRUCTIONS                                         *
******************************************************************
EOPND    EQU   *
         BR    R9
*
*
*
******************************************************************
*                                                                *
* SET UP CURRENT BASE REGISTERS IN THE BASE TABLE. THE USING     *
* TABLE IS SCANNED FOR ENTRIES VALID AT THE CURRENT TEXT OFFSET. *
* WHEN A BASE REGISTER ENTRY IS FOUND TO BE VALID AT THE CURRENT *
* TEXT OFFSET, THE USING ENTRY IS MOVED TO THE APPROPRIATE LOC-  *
* ATION IN THE BASE TABLE FOR USE BY THE BDLADR ROUTINE. THE TEXT*
* OFFSET TO THE NEXT BASE REGISTER CHANGE IS SET SO THAT THIS    *
* ROUTINE WILL AGAIN BE ENTERED WHEN THE CURRENT BASE REGISTERS  *
* ARE EXHAUSTED.                                                 *
*                                                                *
******************************************************************
*
NEXUSG   EQU   *                       *** GET NEXT BASE REGS ***
         MVI   MORUSG,0                RESET INDICATOR
         XC    BASES,BASES             CLEAR OLD BASE REG VALUES
         MVC   NEXCHG,HIVAL            SET NEXT CHANGE LOC HIGH
         L     R2,USGSTRT              GET USING TBL START
         USING USINGD,R2
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BCR   8,R9                    YES, EXIT
         CLC   TXTOFSET,USEND          PAST THIS ONE
         BNL   ECSTEP                  YES
         OI    MORUSG,1                SHOW MORE BASES AVAILABLE
USBGCK   CLC   TXTOFSET,USBGN          THIS STARTS LATER
         BNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHG
         DS    0H
         BNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET NEW CHANGE OFFSET
         B     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            NEW LOW CHANGE ADDR
         BNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET LOWER OFFSET
ECMVC    SR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REGISTER
         MH    R1,USGLEN               TIMES ENTRY LENGTH
         LA    R1,BASES(R1)            @ TABLE ENTRY
         MVC   0(L'USING,R1),USING     ENTRY TO TABLE
         OI    MORUSG,X'80'            SHOW BASE REG CURRENT
ECSTEP   LA    R2,L'USING(R2)          TO NEXT USING TBL ENTRY
         B     ENDUS                   LOOP THRU USING TBL
         DROP  R2
*
*
*
******************************************************************
*                                                                *
* A BASE-DISPLACEMENT IS PROVIDED IN REG 11 ON ENTRY. IF ANY     *
* BASE REGISTERS ARE CURRENT, AND THE BASE REGISTER FOR THE GIVEN*
* ADDRESS IS A CURRENT PROGRAM BASE REGISTER, A LABEL ENTRY IS   *
* BUILT. OFFSET TO THE LABEL WILL BE FOUND BY ADDING THE ASSUMED *
* BASE REGISTER VALUE TO THE GIVEN DISPLACEMENT. THE LABEL NAME  *
* WILL BE THE LETTER 'A' FOLLOWED BY THE OFFSET.                 *
*                                                                *
******************************************************************
*
BDLADR   EQU   *                       *** BUILD LABEL ENTRIES ***
         TM    MORUSG,1                ANY BASES CURRENT
         BZ    BDLXIT                  NO
         LR    R2,R11                  COPY BDDD ADDRESS
         SRL   R2,12                   RIGHT JUSTIFY BASE REG
         MH    R2,USGLEN               TIMES ENTRY LENGTH
         LA    R2,BASES(R2)            @ BASE REG TABLE ENTRY
         USING USINGD,R2
         CLI   USTYPE,C'P'             IS IT A PROGRAM BASE
         BNE   BDLXIT                  NO
         SLL   R11,20                  ISOLATE THE
         SRL   R11,20                  DDD IN R11
         SR    R1,R1                   CLEAR WORK
         ICM   R1,7,USVALU             GET BASE REG VALUE
         AR    R11,R1                  COMPUTE PROGRAM OFFSET
         DROP  R2
         L     R1,CURRLBL              GET LBL TBL ADDR
         C     R1,ENDLBL               END OF TABLE
         BL    GOTHOLE                 NO
         BAL   R9,COMPLBL              YES, COMPRESS DUPLICATES
         L     R1,CURRLBL              GET NEW CURRENT LBL ADDR
         C     R1,ENDLBL               STILL AT END
         BNL   TXTEND                  YES, TERMINATE THIS STAGE
         USING LABELD,R1
GOTHOLE  STCM  R11,7,LBLADR            SET LABEL ENTRY OFFSET
         MVI   LBLNAME,C'A'            BEGIN LABEL NAME
         LA    R12,LBLADR              @ OFFSET
         BAL   R9,HEXPRT3              GO CONVERT
         MVC   LBLNAME+1(6),PRTABL     REST OF NAME
         MVI   LBLNAME+7,C' '          FINAL BLANK IN NAME
         MVI   LBLTYP,C'L'             SET LABEL TYPE
         CLI   TEXT,X'47'              THIS A CONDITIONAL BRANCH
         BE    INSTREF                 YES
         CLI   TEXT,X'45'              BAL INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'46'              BCT INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'44'              EX INSTR
         BE    INSTREF                 YES
         CLI   TEXT,X'87'              BXLE INSTRUCTION
         BE    INSTREF                 YES
         CLI   TEXT,X'86'              BXH INSTRUCTION
         BNE   BDLSTP                  NO
INSTREF  SR    R12,R12                 CLEAR WORK REG
         A     R11,TXTSTRT             BRCH ADDR IN STORED TEXT
         LA    R10,4                   ASSUME LENGTH IS 4
         TM    0(R11),X'C0'            TEST HI 2-BITS OF OP-CODE
         BM    BDLSTP                  01 OR 10 IS 4-BYTE INSTR
         BO    BDLSIX                  YES, SIX-BYTE INSTR
         LA    R10,2                   BOTH OFF, 2-BYTE INSTR
         B     BDLSTP                  CONTINUE
BDLSIX   LA    R10,6                   SET LENGTH TO 6
BDLSTP   STC   R10,LBLLEN              LENGTH TO LABEL ENTRY
         LA    R1,L'LABEL(R1)          TO NEXT ENTRY
         ST    R1,CURRLBL              SAVE UPDATED TBL ADDR
BDLXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R1
*
*
*
******************************************************************
*                                                                *
* SORT THE LABEL TABLE AND ELIMINATE ANY DUPLICATE ENTRIES.      *
*                                                                *
******************************************************************
*
COMPLBL  EQU   *                       *** COMPRESS AND SORT LABEL TABL
         USING LABELD,R6
         L     R6,LBLTBL               GET LABEL TABLE ADDR
LBSTPASS LA    R7,L'LABEL(R6)          @ NEXT LABEL TABLE ENTRY
LBLND    C     R7,CURRLBL              AT TABLE END
         BL    LBSAMPS                 NO
NEXPAS0  LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         C     R6,CURRLBL              END OF TABLE
         BL    LBSTPASS                NO
         B     LBFEND                  YES, FIND END
LBSAMPS  CLC   LBLADR,LBLADR-LABEL(R7) IDENTICAL OFFSETS
         BH    LBSWCH                  NO, FIRST HIGH, SWITCH
         BL    LBSTP                   NO, LOW, CONTINUE SCAN
         CLC   LABEL,0(R7)             ENTRIES ARE IDENTICAL
         BNE   LBCKLBL                 NO
LBNULL2  MVC   LBLADR-LABEL(3,R7),HIVAL YES, NULL 2ND
         B     LBSTP                   AND CONTINUE SCAN
LBCKLBL  CLC   LBLNAME,LBLNAME-LABEL(R7) IDENTICAL LABELS
         BNE   LBCKTYP                 NO, CHECK TYPES
LBCKLN   CLI   LBLLEN,0                THIS ENTRY LENGTH = 0
         BNE   LBCKLN2                 NO
         MVI   LBLLEN,X'FF'            YES, SET HIGH LENGTH
LBCKLN2  CLC   LBLLEN,LBLLEN-LABEL(R7) COMPARE LENGTHS
         BH    LBSWCH                  1ST LENGTH HIGH, SWITCH ENTRIES
         B     LBNULL2                 1ST LOW/=, NULL 2ND
LBCKTYP  CLC   LBLTYP,LBLTYP-LABEL(R7) SAME ENTRY TYPE
         BNE   LBCK1L                  NO, CHK TYPE ORDER
         CLI   LBLTYP,C'L'             ARE THEY TYPE L
         BE    LBSTP                   YES, CONTINUE SCAN
         CLI   LBLTYP,C'U'             USER LABEL
         BNE   LBNULL2                 NO
         B     LBSTP                   YES
LBCK1L   CLI   LBLTYP,C'U'             1ST IS USER LABEL
         BNE   LBCK2L                  NO
         CLI   LBLTYP-LABEL(R7),C'L'   2ND IS TYPE L
         BE    LBNULL2                 YES, NULL THE 2ND
         B     LBSTP                   CONTINUE SCAN
LBCK2L   CLI   LBLTYP-LABEL(R7),C'U'   2ND IS USER LABEL
         BE    LBSWCH                  YES
         CLI   LBLTYP,C'L'             1ST IS LABEL TYPE
         BE    LBSTP                   YES, CONTINUE SCAN
LBSWCH   MVC   WORKREC(L'LABEL),LABEL  HOLD 1ST ENTRY
         MVC   LABEL,0(R7)             MOVE 2ND ENTRY TO 1ST
         MVC   0(L'LABEL,R7),WORKREC   1ST ENTRY TO 2ND LOCATION
         B     LBSAMPS                 GO RECHECK
LBSTP    LA    R7,L'LABEL(R7)          TO NEXT LABEL ENTRY
         B     LBLND                   CONTINUE SCAN
LBFEND   L     R6,LBLTBL               @ LABEL TABLE
LBFCKFF  CLI   LABEL,X'FF'             NULL ENTRY
         BE    LBSTCURR                YES
         C     R6,CURRLBL              AT FORMER END
         BE    LBSTCURR                YES
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     LBFCKFF                 LOOP TO FIND END
LBSTCURR ST    R6,CURRLBL              SAVE NEW TBL END ADDR
         BR    R9                      EXIT
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* END OF PHASE 1. SORT/COMPRESS THE LABEL TABLE AND RETURN.      *
*                                                                *
******************************************************************
*
EOJ      EQU   *                       END OF JOB
         BAL   R9,COMPLBL              SORT/COMPRESS LABEL TBL
         L     R6,LBLTBL               GET LABEL TABLE ADDR
         USING LABELD,R6
EOJCKND  C     R6,CURRLBL              END OF TABLE
         BNL   EOJ2                    YES
         CLI   LBLTYP,C'U'             USER LABEL
         BNE   EOJSTEP                 NO
         MVI   LBLTYP,C'L'             YES, CHANGE TO TYPE L
EOJSTEP  LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     EOJCKND                 CONTINUE LOOP
         DROP  R6
EOJ2     MVC   PRT,BLANX               CLEAR PRINT
         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE
         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
*
*
*
******************************************************************
*                                                                *
* CONVERT HEX BYTES TO THEIR PRINTABLE EQUIVALENTS. ON ENTRY, REG*
* 12 CONTAINS THE ADDRESS OF THE FIRST BYTE TO BE CONVERTED. THE *
* NUMBER OF BYTES IS DETERMINED BY THE ENTRY SELECTED. PRINTABLE *
* HEX IS PLACED IN THE FIELD PRTABL, TWO CHARACTERS PER BYTE.    *
*                                                                *
******************************************************************
*
HEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
*
PRINT    EQU   *                       PRINT ROUTINE
         L     R1,PRINTDCB             @ SYSPRINT DCB
         TM    48(R1),X'10'            IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
*
*
*
*                 *** DATA AND WORK AREAS ***
*
******************************************************************
*                                                                *
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
******************************************************************
*
         DS    0D
COMMPARM DSECT ,                       COMMON AREAS
DBLWD    DS    D                       DOUBLEWORD WORK AREA
PUNCHDCB DS    F                       @ SYSPUNCH DCB
PRINTDCB DS    F                       @ SYSPRINT DCB
INDCB    DS    F                       @ SYSIN DCB
CSECT    DS    CL8                     SPECIFIED CSECT NAME
ESDID    DS    XL2                     ESD ID OF SPECIFIED CSECT
ENDLBLNM DS    CL8                     SYMBOL FOR END STMT BEGIN POINTE
LINECT   DS    PL2                     PRINT LINE COUNTER
START    DS    A                       LKED ASSIGNED START ADDR OF CSEC
END      DS    A                       CSECT END ADDRESS
LENGTH   DS    F                       LENGTH OF SPECIFIED CSECT
LBLTBL   DS    F                       @ LABEL TABLE
CURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR
ENDLBL   DS    F                       @ END OF LABEL TBL
LBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY
TXTSTRT  DS    F                       @ TEXT STORAGE AREA
TXTEND   DS    F                       @ END OF TEXT AREA
TXTCURR  DS    F                       @ CURRENT TEXT LOC
DTBCUR   DS    F                       @ CURRENT DSECT TBL ENTRY
DTBEND   DS    F                       @ DSECT TBL END
DTBSTRT  DS    F                       @ DSECT TBL START
USGSTRT  DS    F                       @ USING TBL START
USGCUR   DS    F                       @ CURRENT USING TBL ENTRY
USGEND   DS    F                       @ USING TBL END
DATONLY  DS    F                       @ DATA ONLY TABLE
DATOCUR  DS    F                       @ CURRENT DATA ONLY ENTRY
DATOEND  DS    F                       @ END OF DATA ONLY TABLE
FLPTASM  DS    XL1                     FLOATING POINT INDICATOR
PRIVASM  DS    XL1                     PRIVILEGED INDICATOR
USERR    DS    XL1                     ERROR INDIC FOR DISASM1
NBRLBLS  DS    H                       NBR LABELS FROM DISASM1
*
*
*
WORKREC  DS    0CL80                   DISASSEMBLY WORK AREA
NAME     DS    CL8                     NAME
         DS    CL1
MNEMONIC DS    CL5                     INSTRUCTION MNEMONIC
         DS    CL1
OPNDS    DS    CL27                    1ST OPERAND
         DS    CL1
COMMENT  DS    CL28                    COMMENT
COL72    DS    CL1                     CONTINUATION COLUMN
SEQNBR   DS    CL8                     CARD SEQUENCE NBR
*
*
*
CARDNO   DS    PL4                     CURRENT OUTPUT CARD NBR
PRTLINE  DS    0CL121                  PRINT LINE
PCC      DS    CL1                     CARRIAGE CONTROL
PRT      DS    CL120                   PRINT DATA
*
*
*
         DS    0F
BLDLIST  DS    0CL62                   BLDL LIST
         DC    H'1'                    ONE ENTRY
         DC    H'58'                   LENGTH OF ENTRY
MEMBER   DC    CL8' '                  MEMBER NAME
TTRMOD   DC    XL3'000000'             TTR OF MODULE
CCAT     DC    XL1'00'                 CONCATENATION NUMBER
         DC    XL1'00'
ALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR
*                           80=ALIAS
TTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD
         DC    XL1'00'
TTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST
NNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST
ATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1
*                           80=RENT
*                           40=REUS
*                           20=OVERLAY
*                           10=UNDER TEST
*                           08=ONLY LOADABLE
*                           04=SCATTER FORMAT
*                           02=EXECUTABLE
*                           01=ONE TXT, NO RLD RECORDS
ATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2
*                           80=CANNOT BE REPROCESSED BY LKED E
*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO
*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO
*                           10=CONTAINS NO RLD RECORD
*                           08=CANNOT BE REPROCESSED BY LKED
*                           04=CONTAINS TESTRAN SYMBOLS
*                           02=CREATED BY LKED
*                           01=REFR
TOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD
LENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD
LKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR
ATTR2    DC    XL1'00'                 ATTRIBUTES 2
*                           80=PROCESSED BY OS/VS LKED
*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE
*                           10=SSI PRESENT
         DC    XL2'0000'
SCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH
TTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH
SCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD
SCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT
ALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME
ALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS
SSI      DS    XL4'00000000'           SSI BYTES
AUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH
AUTHCOD  DC    XL1'00'                 AUTH CODE
*
*
*
COMMEND  EQU   *
*
*
*
LABELD   DSECT ,                       LABEL TABLE ENTRY
LABEL    DS    0CL13                   13-BYTE ENTRIES
LBLADR   DS    XL3                     RELATIVE ADDR IN TEXT
LBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,
LBLNAME  DS    CL8                     NAME (SYMBOL)
LBLLEN   DS    XL1                     LENGTH IF A, V, OR W
*
*
*
USINGD   DSECT ,                       USING TABLE ENTRY
USING    DS    0CL11
USBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE
USEND    DS    XL3                     OFFSET TO END OF RANGE
USREG    DS    XL1                     BASE REGISTER USED
USTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT
USVALU   DS    XL3                     BASE REG VALUE
*
*
*
DSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY
DSECT    DS    0CL13
DSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD
DSLBTYP  DS    CL1                     LABEL TYPE = L
DSNAME   DS    CL8                     FIELD NAME
DSLENG   DS    XL1                     FIELD LENGTH
*
*
*
DISASM1  CSECT
*
*
*
SVCTBLAD DC    A(SVCOP)                @ SVC TABLE
DBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES
DSCT9    DS    F                       RETURN FOR DSECTS
SAVOP9   DS    F                       SAVE AREA FOR OPND9
ULSAV    DS    7F                      SAVE AREA FOR CKADCON
NOINAD   DS    F                       DATA ONLY TABLE ADDRESS
SGOPLEN DC AL2(L'SGLOP) SINGLE BYTE OP COD TBL LEN                   */
DTBLEN DC AL2(L'DSECT) DSECT TABLE ENTRY LENGTH                      */
NUMCK    DC    C'0000'                 NUMERIC CHECK AREA
ZEROS    DC    C'0000'                 CONSTANT ZEROS
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
BASES    DC    XL256'0'                CURRENT BASE REGS
HIVAL    DC    4X'FF'                  CONSTANT F'S
         DS    0H
USGLEN DC AL2(L'USING) LENGTH OF USING TBL ENTRY                     */
NEXCHG   DC    XL3'00'                 NEXT BASE REG CHG OFFSET
MORUSG   DC    X'00'                   80=CURRENT BASE, 0=NO MORE BASES
CONTYPE  DS    CL1                     TYPE
CONLEN   DS    H                       CONSTANT LENGTH
CONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
TXTOFST  DS    0F
         DS    X
TXTOFSET DS    XL3                     OFFSET TO TEXT BYTE
OFFSET   DS    XL3                     OFFSET FROM PGM START
INSTYP   DS    CL1                     INSTRUCTION TYPE
TYPE     DS    XL1                     TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DS    XL1                     TEXT LENGTH
TEXT     DS    XL8                     TEXT
H1       DC    H'1'                    CONSTANT 1
H2       DC    H'2'                    CONSTANT 2
H4       DC    H'4'                    CONSTANT 4
H7       DC    H'7'                    CONSTANT 7
H8       DC    H'8'                    CONSTANT 8
H10      DC    H'10'                   CONSTANT 10
H11      DC    H'11'                   CONSTANT 11
H13      DC    H'13'                   CONSTANT 13
H14      DC    H'14'                   CONSTANT 14
H100     DC    H'100'                  CONSTANT 100
H1000    DC    H'1000'                 CONSTANT 1000
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
P256     DC    P'256'                  CONSTANT 256
P4096    DC    P'4096'                 CONSTANT 4096
BLANX    DC    CL121' '                CONSTANT BLANKS
UNAME    DC    CL8'A'                  USER NAME AREA
XZROS    DC    8X'00'                  CONSTANT ZEROS
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
PRTABL   DS    CL9                     PRINTABLE HEX WORK
CHARTRAN DC    256X'FF'                TRT TABLE FOR CHAR/HEX DETERMINA
         ORG   CHARTRAN+C' '
         DC    X'00'                   BLANK IS CHARACTER
         ORG   CHARTRAN+C'A'
         DC    9X'00'                  A-I ARE CHARACTERS
         ORG   CHARTRAN+C'J'
         DC    9X'00'                  J-R ARE CHARACTERS
         ORG   CHARTRAN+C'S'
         DC    8X'00'                  S-Z ARE CHARACTERS
         ORG   CHARTRAN+C'0'
         DC    10X'00'                 0-9 ARE CHARACTERS
         ORG
TRHEX    DC    256X'FF'                HEX TRANSLATION TABLE
         ORG   TRHEX+C'A'
         DC    X'0A0B0C0D0E0F'
         ORG   TRHEX+C'0'
         DC    X'00010203040506070809'
         ORG
TRTHEX   DS    0X                      VERIFY HEX TABLE
         DC    XL16'00'
         DC    XL240'FF'
         ORG
         LTORG
*
         COPY  DISASM3A                COPY INSTRUCTION TABLES
         COPY  DISASM3B                COPY SVC TABLE
*
         END
