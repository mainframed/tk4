DIS2     TITLE '*** DISASSEMBLY PHASE 2 ***'
         MACRO
&NAME    SVLNK &REG1,&REG2,&REG3,&IND,&LV=
         GBLC  &EQU
         GBLC  &GM
         GBLC  &CSECT
         LCLC  &REGA
         AIF   (T'&NAME EQ 'O').NOCSECT
         AIF   ('&NAME' EQ '*').NOCSECT
&CSECT   SETC  '&NAME'
&CSECT   CSECT                         NAME OF PROGRAM
         AGO   .RST
.NOCSECT ANOP
&CSECT   SETC  '*'
         CSECT                         BEGINNING OF PROGRAM
.RST     ANOP
         AIF   ('&EQU' EQ 'ON').NRQ
&EQU     SETC  'ON'
*
***REGISTER EQUATES***
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
.NRQ     ANOP
*
*******************  PROGRAM INITIALIZATION  *************************
*
         AIF   (T'&REG1 EQ 'O').NOREG
&REGA    SETC  '&REG1'
         AIF   (T'&REG2 EQ 'O').ONEREG
         USING &CSECT,&REGA,&REG2          ESTABLISH ADDRESSABILITY
         AGO   .BYUSE
.NOREG   ANOP
&REGA    SETC  'R3'
.ONEREG  USING &CSECT,&REGA              ESTABLISH ADDRESSABILITY
.BYUSE   ANOP
         STM   R14,R12,12(R13) :       STORE REGS IN HIGH SAVE AREA
         LR    &REGA,R15                  INITIALIZE BASE REG
         AIF   (T'&REG2 EQ 'O').NOLA
         LA    &REG2,4095(&REGA)       INITIALIZE THE SECOND
         LA    &REG2,1(&REG2)                BASE REGISTER
.NOLA    ANOP
         AIF   (T'&REG3 EQ 'O').NOLNK
         L     &REG3,0(R1)                GET PARAMETER LIST ADDR
.NOLNK   ANOP
         AIF (T'&IND EQ 'O').GETIT
         CNOP  0,4
         BAL   R15,SAVEAREA+72         BRANCH AROUND SAVE AREA
SAVEAREA DS    18F                     REGISTER SAVE AREA
         ST    R15,8(R13)
         ST    R13,SAVEAREA+4
         LR    R13,R15
         AGO   .NOSAVE
.GETIT   ANOP
         AIF   (T'&LV EQ 'O').GMD
&GM      SETC  '&LV'
         AGO   .DGM
.GMD     ANOP
&GM      SETC  '72'
.DGM     ANOP
*
***GET MAIN STORAGE FOR SAVE AREA***
*
         AIF   ('&GM' LT '4096').LA
         GETMAIN R,LV=&GM              GET CORE FOR SAVE AREA
         AGO   .EGM
.LA      ANOP
         LA    R0,&GM                  GET &GM BYTES
         GETMAIN R,LV=(0)
.EGM     ANOP
*
***SET UP SAVE AREA POINTERS***
*
         ST    R1,8(R13)               STORE LOW SAVE POINTER
         ST    R13,4(R1)               STORE HIGH SAVE POINTER
         LR    R13,R1                  INITIALIZE SAVE POINTER
         AIF   (T'&REG3  NE 'O').NOSAVE
         L     R1,4(R13)               GET POINTER TO RESTORE PARA REG
         L     R1,24(R1)               RESTORE PARAMETER REGISTER
.NOSAVE  ANOP
         AIF   ('&CSECT' EQ '*').EXIT
         B     *+12
         DC    CL8'&CSECT'             END INITIAL., BEGIN THIS PROG.
.EXIT    ANOP
*
*********************  END INITIALIZATION  ***************************
*
         MEND
         EJECT
DISASM2  SVLNK R3,R4
         PRINT NOGEN
* THIS SUB-PROGRAM IS CALLED BY DISASM AFTER THE DIRECTORY
* ENTRY AND LOAD MODULE ARE PROCESSED. THE ESD AND RLD
* ENTRIES HAVE BEEN USED TO CREATE A PROGRAM LABEL TABLE,
* AND MODULE TEXT IS IN AN AREA OF STORAGE. A COMMON PARAMETER
* AREA IS DEFINED IN DISASM, AND PASSED TO THIS PROGRAM.
*
* TEXT BYTES ARE USED TO CREATE ASSEMBLY LANGUAGE STATEMENTS,
* AND MACHINE INSTRUCTION STATEMENTS. OUTPUT IS WRITTEN
* TO THE WORK1 DATASET FOR FURTHER PROCESSING BY OTHER
* MODULES.
*   A TEXT BYTE IS CONSIDERED TO BE AN INSTRUCTION IF
* IT OCCURS ON A HALFWORD BOUNDARY, IS A VALID OP-CODE,
* AND IS FOLLOWED BY A VALID OP-CODE. UNCONDITIONAL BRANCHES
* NEED NOT BE FOLLOWED BY A VALID OP-CODE, HOWEVER. THE
* PRIVILEGED AND FLOATING POINT INSTRUCTIONS ARE NOT
* TREATED AS INSTRUCTIONS UNLESS THE USER SPECIFIED
* THEIR INCLUSION AT EXEC TIME.
*
*
*
*
* AUTHOR R THORNTON - NOV 1977
* UPDATED ROBERT STYMA - JAN 1989 AND MARCH 1991
* UPDATED ALAN C FIELD - APR 1990
*
*
******************************************************************
*                                                                *
* CHECK IF USER WISHES FLOATING POINT AND PRIVILEGED INSTRUCTIONS*
* IF NOT, CLEAR THE APPROPRIATE ENTRIES IN THE INSTRUCTION OP    *
* CODE TABLES.                                                   *
*                                                                *
******************************************************************
*
         L     R5,0(R1)                GET PARM FIELD ADDRESS
         USING COMMPARM,R5
         CLI   FLPTASM,1               FLOATING POINT INSTR O.K.
         BE    TSTPRIV                 YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TSTOPND  CLI   0(R12),X'FF'            END OF TBL
         BE    TSTPRIV                 YES
         TM    ICLASS-INSTENT(R12),FLTPT IS IT FLOATING POINT
         BZ    FLPSTP                  NO
         XC    0(L'SGLOP,R12),0(R12)   CLEAR ENTRY
FLPSTP   LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TSTOPND                 LOOP THRU TABLE
TSTPRIV  CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    MAINLINE                YES
         LA    R12,SGLOP               POINT TO OP-CODE TBL
TTOPND   CLI   0(R12),X'FF'            END OF TABLE
         BE    CKDBLS                  YES
         TM    ICLASS-INSTENT(R12),PRIV PRIVILEGED INSTR
         BZ    PRIVSTP                 NO
         XC    0(L'SGLOP,R12),0(R12)   YES, CLEAR ENTRY
PRIVSTP  LA    R12,L'SGLOP(R12)        TO NEXT ENTRY
         B     TTOPND                  LOOP THRU TABLE
CKDBLS   L     R12,DBLOPAD             @ 2-BYTE OP-CODE TBL
CKDBND   CLI   0(R12),X'FF'            END OF TBL
         BE    MAINLINE                YES
         TM    ICLASS-INSTENT+2(R12),PRIV PRIVILEGED OP-CODE
         BZ    DBSTP                   NO
         XC    0(L'DBLOP,R12),0(R12)   YES, CLEAR ENTRY
DBSTP    LA    R12,L'DBLOP(R12)        TO NEXT ENTRY
         B     CKDBND                  LOOP THRU TABLE
*
*
*
******************************************************************
*                                                                *
* MAINLINE ROUTINE FOR DISASSEMBLY. EACH BYTE OF TEXT IS CHECKED *
* TO DETERMINE WHETHER IT MAY BE AN INSTRUCTION OP-CODE. IF NOT, *
* THE CONST ROUTINE IS PERFORMED TO HANDLE CONSTANT DATA. IF IT  *
* APPEARS TO BE AN OP-CODE, THE INSTR ROUTINE IS PERFORMED.      *
* WHEN TEXT IS EXHAUSTED, THIS PHASE TERMINATES.                 *
*                                                                *
******************************************************************
*
MAINLINE EQU   *                       MAINLINE ROUTINE
         L     R6,LBLTBL               @ LABEL TABLE
         USING LABELD,R6
         MVC   TXTCURR,TXTSTRT         COPY TEXT START ADDR
GETCURR  L     R7,TXTCURR              @ CURRENT TXT BYTE
         C     R7,TXTEND               END OF TEXT
         BNL   EOJ                     YES          FIX******
         LR    R12,R7                  COPY TEXT ADDR
         S     R12,TXTSTRT             COMPUTE OFFSET
         ST    R12,TXTOFST             SAVE OFFSET TO THIS BYTE
         CLC   NEXCHG,TXTOFSET         TIME TO CHANGE BASES
         BH    CKDARNG                 NO
         BAL   R9,NEXUSG               YES, GO DO IT
CKDARNG  L     R12,DATONLY             GET DATA ONLY TBL ADDR
         CLC   TXTOFSET,0(R12)         RANGE BEGINS LATER
         BL    CKLOSEQ                 YES
         CLC   TXTOFSET,3(R12)         THIS BYTE IN THE RANGE
         BNH   CONST                   YES
         LA    R12,6(R12)              PAST THIS ENTRY, STEP OVER 1
         ST    R12,DATONLY             SAVE UPDATED ADDR
         B     CKDARNG                 GO CHECK AGAIN
CKLOSEQ  CLC   TXTOFSET,LBLADR         LABEL ENTRY OUT OF SEQ
         BNH   GCKODD                  NO, CONTINUE
         BAL   R9,FORCONST             YES, FORCE ANY CONSTANT OUT
         MVC   NAME,LBLNAME            NAME TO OUTPUT
         MVC   MNEMONIC,=CL5'EQU'      MNEMONIC
         MVI   OPNDS,C'*'              OPERAND
         MVC   COMMENT(14),=14C'?'     SHOW ERROR
         BAL   R9,WRTOUT               WRITE ERROR RECORD
         BAL   R9,PRINT                GO PRINT IT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL
         B     CKLOSEQ                 CONTINUE SEQ CHK
GCKODD   TM    TXTCURR+3,1             ODD ADDRESS
         BO    CONST                   YES, NOT INSTR
         CLC   1(3,R7),0(R7)           4 CONSEC IDENTICAL BYTES
         BE    CONST                   YES, NOT INSTR
         TRT   0(1,R7),CHARTRAN        TEST TEXT BYTE
         BNZ   CKINSTR                 NOT CHARACTER
         CLI   CONPROG,1               IS CONSTANT IN PROGRESS
         BNE   CK6                     NO
         CLI   CONTYPE,C'C'            IS IT CHARACTER TYPE
         BE    CONST                   YES, ADD THIS TO CONSTANT
CK6      TRT   0(6,R7),CHARTRAN        6 CONSECUTIVE CHARACTERS
         BZ    CONST                   YES, NOT INSTRUCTION
CKINSTR  SR    R8,R8                   CLEAR WORK
         IC    R8,0(R7)                PICK UP TXT BYTE
         MH    R8,SGOPLEN              TIMES TABLE LENGTH
         LA    R8,SGLOP(R8)            @ INSTR TBL ENTRY
         MVC   INSTENT,0(R8)           SAVE INSTRUCTION TBL ENTRY
         CLI   INAME,0                 IS IT AN INSTR OP-CODE
         BE    CONST                   NO
         CLI   ITYPE,TWO               TWO-BYTE OP-CODE
         BNE   INSTR                   NO
         L     R8,DBLOPAD              YES, GET 2-BYTE TBL ADDR
DBLND    CLI   0(R8),X'FF'             END OF TABLE
         BE    CONST                   YES, NOT INSTR
         CLC   0(2,R8),0(R7)           THIS ENTRY MATCHES TXT
         BE    GOTDBLI                 YES
         LA    R8,L'DBLOP(R8)          TO NEXT ENTRY
         B     DBLND                   LOOP THRU TBL
GOTDBLI  LA    R8,2(R8)                PASS OP-CODE BYTES
         MVC   INSTENT,0(R8)           SAVE INSTR TBL ENTRY
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED WHEN CURSORY CHECKS IN THE MAINLINE    *
* INDICATE THIS TEXT BYTE IS AN INSTRUCTION OP-CODE. FURTHER     *
* TESTING IS DONE BY THE IVERFY (NON-FLOATING POINT), OR FPVERFY *
* (FLOATING POINT) ROUTINES. BYTES PASSING THESE TESTS ARE       *
* ACCEPTED AS OP-CODES, AND ARE PASSED TO THE APPROPRIATE FORMAT *
* ROUTINES. FORMAT ROUTINES ARE ENTERED VIA A BRANCH TABLE USING *
* A BYTE IN THE INSTRUCTION OP-CODE TABLE ENTRY.                 *
*                                                                *
******************************************************************
*
INSTR    EQU   *                       *** INSTRUCTIONS (POSSIBLY) ***
         MVC   ILENG+1(1),INLNG        SET INSTR LENGTH
         LH    R12,ILENG               PICK UP LENGTH
         AR    R12,R7                  ADDR OF NEXT OP CODE
         SR    R15,R15                 CLEAR WORK
         IC    R15,0(R12)              PICK UP NEXT OP-CODE
         MH    R15,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R15,SGLOP(R15)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R15),0    IS IT AN OP-CODE
         BNE   ICKSEC                  YES
         CLI   0(R7),X'45'             IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),X'0B'             IS IT BSM
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),X'4D'             IS IT BAS
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R7),7                 NO, IS IT BCR
         BE    POSSB                   YES
         CLI   0(R7),X'47'             IS IT BC
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB    TM    1(R7),X'F0'             IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
         B     ICKTBL                  ACCEPT UNCOND BRCHS
ICKSEC   SR    R1,R1                   CLEAR WORK
         IC    R1,INLNG-INSTENT(R15)   GET INSTR LENGTH
         AR    R1,R12                  ADDR OF NEXT OP CODE
         SR    R14,R14                 CLEAR WORK
         IC    R14,0(R1)               PICK UP NEXT OP-CODE
         MH    R14,SGOPLEN             TIMES TBL ENTRY LENG
         LA    R14,SGLOP(R14)          INSTR TBL ENTRY ADDR
         CLI   INAME-INSTENT(R14),0    IS IT AN OP-CODE
         BNE   ICKTBL                  YES
         CLI   0(R12),X'45'            IS IT BAL
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'0B'            IS IT BSM
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'4D'            IS IT BAS
         BE    ICKTBL                  YES, CONTINUE
         CLI   0(R12),X'07'            NO, IS IT BCR
         BE    POSSB2                  YES
         CLI   0(R12),X'47'            IS IT BC
         BNE   CONST                   NO, THEN THIS NOT INSTR
POSSB2   TM    1(R12),X'F0'            IS IT UNCONDL BRCH
         BNO   CONST                   NO, THEN THIS NOT INSTR
ICKTBL   LH    R12,ILENG               GET INSTR LENGTH
         AR    R12,R7                  @ NEXT TEXT LOC
         BCTR  R12,R0                  BACK UP 1
         S     R12,TXTSTRT             RELATIVIZE IN CSECT
         CLM   R12,7,LBLADR            LBL TBL ADDR HERE
         BL    NOILBL                  NO
         CLC   TXTOFSET,LBLADR         LABEL AT INSTR START
         BNE   NOTINST                 NO, MUST BE CONSTANT      FIX***
         CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   NOTINST                 NO                        FIX***
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CKLBLNG                 NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
CKLBLNG  CLC   LBLLEN,INLNG            LENGTHS SAME
         BE    SETLBL                  YES
         CLI   LBLLEN,0                DON'T CARE LENGTH
         BE    SETLBL                  YES
         BAL   R9,EQUSTMT              NO, BUILD EQU STATEMENT
         B     ISTPLBL                 CONTINUE
SETLBL   MVC   NAME,LBLNAME            LABEL ENTRY NAME TO INSTR
         MVC   CONLEN,LBLLEN           SET CONSTANT LENGTH IN CASE
ISTPLBL  DS    0H
         LR    R9,R6                   GET TEMP COPY OF LABEL TAB ENT
         LA    R6,L'LABEL(R6)          TO NEXT LABEL TBL ENTRY
         CLC   LBLADR(3),LBLADR-LABEL(R9)  THIS ENTRY SAME ADDR?
         BNE   ICKTBL                  NO
         LR    R6,R9                   BACK UP TO PREV ENTRY
         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT ENTRY
         B     ICKTBL                  GO CHECK NEXT LABEL
NOILBL   CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   MVMNE                   NO
         BAL   R9,FORCONST             YES, FORCE IT OUT
MVMNE    MVC   MNEMONIC,0(R8)          SET INSTR MNEMONIC
         MVC   OFFSET,TXTOFSET         SET OFFSET
         MVC   INSTYP,5(R8)            SET INSTR TYPE
         MVI   TYPE,X'0D'              SHOW IT IS AN INSTRUCTION
         MVC   LEN,ILENG+1             SHOW LENGTH
         MVC   TEXT(6),0(R7)           MOVE ACTUAL TEXT
OPNDFMT  TM    ICLASS,FLTPT            FLOATING POINT OP-CODE
         BO    FPVERFY                 YES, GO VERIFY
         CLI   IEDT,0                  ANY EDIT REQUIRED
         BE    PFMFMT                  NO
         B     IVERFY                  YES, GO EDIT
PFMFMT   SR    R1,R1                   CLEAR WORK
         IC    R1,INSTYP               GET INSTRUCTION TYPE
         L     R9,OPND9                GET FORMAT ROUTINE RETURN ADDR
         B     *+4(R1)                 TO APPROPRIATE FORMATTING ROUTIN
         B     RROPND                  TYPE=0, RR
         B     RXOPND                  TYPE=4, RX
         B     SOPND                   TYPE=8, S
         B     SIOPND                  TYPE=C, SI
         B     RSOPND                  TYPE=10, RS
         B     SS1OPND                 TYPE=14, 1-LENGTH SS
         B     SS2OPND                 TYPE=18, 2-LENGTH SS
         B     SOPND                   TYPE=1C, 2-BYTE OP-CODES
         B     BCOPND                  TYPE=20, CONDITIONAL BRANCH
         B     SVCOPND                 TYPE=24, SVC
         B     SSEOPND                 TYPE=28, SSE
         B     EOPND                   TYPE=2C, E
         B     RROPND                  TYPE=30, RRE 1 OPERAND
         B     RROPND                  TYPE=34, RRE 2 OPERANDS
OPNDRTN  B     INSTOUT                 NORMAL OPERAND FORMAT RETURN
         MVC   CONNAME,NAME            ANY NAME TO CONSTANT AREA
         B     CONST                   ERROR INSTRUCTION, TREAT AS CONS
NOTINST  CLC   NAME,BLANX              IS NAME FILLED IN?        FIX***
         BE    CONST                                             FIX***
         SH    R6,LBLLGTH              BACK UP                   FIX***
         B     CONST                                             FIX***
INSTOUT  BAL   R9,WRTOUT               WRITE INSTRUCTION RECORD
         BAL   R9,TXTFMT               FORMAT HEX DATA
         BAL   R9,PRINT                GO PRINT IT
         AH    R7,ILENG                STEP TO NEXT TEXT BYTE
         ST    R7,TXTCURR              SAVE NEXT ADDR
         MVC   CCTYPE,ICCSET           SHOW COND CODE SET TYPE
         B     GETCURR                 CONTINUE TXT PROCESSING
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR NON FLOATING*
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
IVERFY   EQU   *                       *** VERIFY POSSIBLE INSTRUCTION
         TM    IEDT,EPR                EVEN-ODD REG PAIR
         BZ    IVE2                    NO
         TM    1(R7),X'10'             R1 IS ODD
         BO    CONST                   YES, NOT INSTR
         CLI   0(R7),X'0E'             IS IT MVCL
         BE    IVTRG2                  YES
         CLI   0(R7),X'0F'             IS IT CLCL
         BNE   IVE2                    NO
IVTRG2   TM    1(R7),X'01'             R2 IS ODD
         BO    CONST                   YES, NOT INSTR
         SR    R1,R1                   CLEAR WORK
         SR    R2,R2                   CLEAR WORK
         IC    R1,1(R7)                GET R1R2
         SRL   R1,4                    SHIFT OUT R2
         PACK  DBLWD(1),1(1,R7)        FLIP R1R2 BYTE
         IC    R2,DBLWD                PICK UP R2R1
         SRL   R2,4                    SHIFT OUT R1
         CR    R1,R2                   R1=R2
         BE    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVE2     TM    IEDT,E2                 HALFWORD STORAGE ALIGNMENT
         BZ    IVE4                    NO
         TM    3(R7),X'01'             DISPL IS ODD
         BZ    IVES2                   NO, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   0(R7),X'44'             EX OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'47'             BC OP CODE
         BE    CONST                   YES, NOT INSTR
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG IS 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   CONTINUE
IVE4     TM    IEDT,E4                 2ND OPND ON FULLWORD BOUND
         BZ    IVE8                    NO
         TM    3(R7),X'03'             DISPL DIV BY 4
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO, CONTINUE
         CLI   ITYPE,RS                RS INSTRUCTION OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     IVES2                   NO, CONTINUE
IVE8     TM    IEDT,E8                 2ND OPND ON DBLWD BOUND
         BZ    IVES2                   NO
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    IVES2                   YES, O.K.
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   IVES2                   NO
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
IVES2    CLI   PRIVASM,1               PRIVILEGED INSTR O.K.
         BE    PFMFMT                  YES
         TM    IEDT,S2                 OPND2 MUST HAVE BASE
         BZ    IVES1                   NO
         TM    2(R7),X'F0'             BASE REG = 0
         BNZ   PFMFMT                  NO, O.K.
         CLI   ITYPE,RS                RS INSTRUCTION
         BE    CONST                   YES, NOT INSTR
         CLI   0(R7),X'92'             IS IT MVI OP CODE
         BE    CONST                   YES, NOT INSTR
         TM    1(R7),X'0F'             INDEX REG = 0
         BZ    CONST                   YES, NOT INSTR
         B     PFMFMT                  NO, GOOD INSTR
IVES1    TM    IEDT,S1                 1ST OPND MUST HAVE BASE
         BZ    PFMFMT                  NO, CONTINUE
         TM    2(R7),X'F0'             1ST OPND HAS BASE
         BZ    CONST                   NO, NOT INSTR
         B     PFMFMT                  YES, INSTR O.K.
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM THE INSTR ROUTINE FOR FLOATING    *
* POINT INSTRUCTIONS. VARIOUS EDITS ARE PERFORMED TO INSURE THE  *
* INPUT TEXT BYTE IS AN OP-CODE. IF IT IS, RETURN IS TO LABEL    *
* PFMFMT, OTHERWISE THE CONST ROUTINE IS PERFORMED.              *
*                                                                *
******************************************************************
*
FPVERFY  EQU   *                       *** VALIDATE FLOATING POINT OP-C
         TM    1(R7),X'90'             R1 IS 0, 2, 4, OR 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'27'             MXDR OP-CODE
         BE    FPR1EXT                 YES
         CLI   0(R7),X'67'             MXD OP-CODE
         BNE   FPCKTYP                 NO
FPR1EXT  TM    1(R7),X'B0'             R1 IS 0 OR 4
         BNZ   CONST                   NO, NOT INSTR
FPCKTYP  CLI   ITYPE,RR                RR TYPE INSTRUCTION
         BNE   FPRXVER                 NO
         TM    1(R7),X'09'             R2 IS 0, 2, 4, 6
         BNZ   CONST                   NO, NOT INSTR
         CLI   0(R7),X'25'             LRDR OP CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'37'             SXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'26'             MXR OP-CODE
         BE    FPR2EXT                 YES
         CLI   0(R7),X'36'             AXR OP-CODE
         BNE   PFMFMT                  NO, GOOD INSTR
FPR2EXT  TM    1(R7),X'0B'             R2 IS 0 OR 4
         BZ    PFMFMT                  YES, GOOD INSTR
         B     CONST                   NO, NOT INSTR
FPRXVER  CLI   PRIVASM,1               PRIVILEGED INSTRUCTIONS O.K.
         BE    FPALIGN                 YES
         TM    2(R7),X'F0'             ANT BASE REG
         BNZ   FPALIGN                 YES
         TM    1(R7),X'0F'             ANY INDEX REG
         BZ    CONST                   NO, NOT INSTR
FPALIGN  TM    2(R7),X'F0'             ANY BASE REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    1(R7),X'0F'             ANY INDEX REG
         BNZ   PFMFMT                  YES, ACCEPT INSTR
         TM    3(R7),X'03'             DISPL DIV BY 4
         BNZ   CONST                   NO, NOT INSTR
         TM    ICLASS,FLSHT            SHORT PRECISION
         BO    PFMFMT                  YES, ACCEPT INSTRUCTION
         TM    3(R7),X'07'             DISPL DIV BY 8
         BZ    PFMFMT                  YES, ACCEPT INSTR
         B     CONST                   NO, NOT INSTR
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED FROM VARIOUS OTHER ROUTINES WHEN THE   *
* CURRENT TEXT BYTE IS DETERMINED NOT TO BE AN INSTRUCTION OP    *
* CODE. A CONSTANT AREA IS BUILT TO CONTAIN THE CONSTANT, IT'S   *
* DATA TYPE, SYMBOL TO BE USED FOR ADCONS, LABEL TO BE USED, IF  *
* ANY, ETC. THE CONSTANT IS BUILT BYTE BY BYTE, AND IS TERMINATED*
* FOR OUTPUT BY THE FORCONST ROUTINE. THIS ROUTINE DETECTS END OF*
* CONSTANT WHEN THE CONSTANT IN PROGRESS EXCEEDS 2 BYTES FOR A   *
* HALFWORD, 4 BYTES FOR A FULLWORD, OR 8 BYTES AS A MAXIMUM. IT  *
* IS ALSO TERMINATED WHEN A CHANGE IN DATA TYPE OCCURS.          *
*                                                                *
******************************************************************
*
CONST    EQU   *                       *** PROCESS CONSTANTS ***
         MVC   WORKREC,BLANX           CLEAR WORK RECORD AREA
         CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   CCNEW                   NO
         CLC   TXTOFSET,LBLADR         LABEL ENTRY HAS THIS OFFSET
         BNE   CGETYP                  NO
CSTNEW   BAL   R9,FORCONST             FORCE IT OUT
         B     CCNEW                   GO START A NEW ONE
CGETYP   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CHEX                    IT'S HEX
         MVI   CCKTYP+1,C'C'           SET TYPE IN COMPARE
         B     CCKTYP                  GO COMPARE
CHEX     MVI   CCKTYP+1,C'X'           SET TYPE IN COMPARE
CCKTYP   CLI   CONTYPE,C' '            TYPE IN PROG SAME AS THIS BYTE
         BNE   CSTNEW                  NO
CUPDCON  LH    R11,CONLEN              GET CURRENT LENGTH
         LA    R11,1(R11)              ADD 1
         STH   R11,CONLEN              UPDATE LENGTH
         L     R11,CONLOC              GET CURRENT LOC IN CONST DATA
         MVC   0(1,R11),0(R7)          MOVE BYTE TO DATA
         LA    R11,1(R11)              STEP OVER ONE BYTE
         ST    R11,CONLOC              SAVE UPDATED DATA ADDR
         CLI   CONTYPE,C'C'            CHARACTER CONSTANT
         BE    CCK8                    YES
         TM    CONOFST+3,1             OFFSET IS ODD
         BO    CCFIN1                  YES
         TM    CONOFST+3,2             HALFWORD OFFSET
         BZ    CCFWD                   NO
         CLI   CONLEN+1,1              HALFWORD, IS LENGTH = 1
         BE    CCXIT1                  YES
         B     CCFIN1                  NO
CCFWD    CLI   CONLEN+1,4              NO, IS HEX CONST 4 BYTES
         BL    CCXIT1                  NOT YET
CCFIN1   BAL   R9,FORCONST             MAX LENG, FORCE IT OUT
         B     CCXIT1                  FINISH
CCK8     CLC   CONLEN,H8               CHAR CONSTANT 8 BYTES
         BNL   CCFIN1                  YES
CCXIT1   LA    R7,1(R7)                STEP OVER 1 BYTE IN TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDR
         B     GETCURR                 CONTINUE TEXT PROCESSING
CCNEW    MVI   CONPROG,1               SHOW CONSTANT IN PROGRESS
         MVC   CONOFST,TXTOFST         SET OFFSET TO 1ST BYTE
         MVC   CONNAME,BLANX           CLEAR NAME
         XC    CONDATA,CONDATA         CLEAR DATA AREA
         MVC   CONSYM,BLANX            CLEAR SYMBOL NAME
         MVC   CONLEN,XZROS            CLEAR LENGTH
         LA    R11,CONDATA             GET 1ST DATA BYTE ADDR
         ST    R11,CONLOC              SET STARTING ADDRESS OF DATA
         CLC   TXTOFSET,LBLADR         LABEL AT THIS OFFSET
         BE    CLBLD                   YES
TRTYPE   TRT   0(1,R7),CHARTRAN        CHECK DATA TYPE OF BYTE
         BNZ   CCSHX                   IT'S HEX
         MVI   CONTYPE,C'C'            IT'S CHAR, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CCSHX    MVI   CONTYPE,C'X'            IT'S HEX, SO INDICATE
         B     CUPDCON                 GO COMPLETE
CLBLD    CLI   LBLTYP,C'L'             IS IT A LABEL ONLY
         BNE   CDATACON                NO
         MVC   CONNAME,LBLNAME         NAME TO CONSTANT WORK AREA
         MVC   CONLLEN,LBLLEN         SAVE LENGTH
         LA    R6,L'LABEL(R6)          TO NEXT LABEL ENTRY
         CLC   TXTOFSET,LBLADR         THIS LABEL AT SAME ADDR
         BNE   TRTYPE                  NO
         CLI   LBLTYP,C'L'             THIS ANOTHER LABEL ONLY
         BNE   CDATACON                NO
         SH    R6,LBLLGTH             BACK UP TO LABEL ENTRY
         BAL   R9,EQUSTMT             GO BUILD EQU STATEMENT
         LA    R6,L'LABEL(R6)          TO NEXT LABELENTRY
         B     CCNEW                   GO TO NEXT LABEL
CDATACON MVC   CONTYPE,LBLTYP          TYPE TO CONSTANT AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,LBLLEN               PICK UP CONSTNT LENGTH
         STH   R1,CONLEN               SAVE CONSTANT LENGTH
         BCTR  R1,R0                   COMPUTE CONSTANT LENGTH CODE
         STC   R1,MCD+1                SET MOVE LENGTH CODE
MCD      MVC   CONDATA,0(R7)           MOVE DATA TO RECORD
         MVC   CONSYM,LBLNAME          SYMBOL TO CONSTANT AREA
         SR    R11,R11                 CLEAR WORK REG
         IC    R11,LBLLEN              PICK UP LENGTH
         AR    R7,R11                  STEP PAST TEXT
         ST    R7,TXTCURR              UPDATE TEXT ADDRESS
         BAL   R9,FORCONST             FORCE CONSTANT OUT
         LA    R6,L'LABEL(R6)          STEP TO NEXT LABEL ENTRY
         B     GETCURR                 CONTINUE TEXT PROCESS
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS ENTERED BY VARIOUS ROUTINES WHEN IT IS         *
* NECESSARY TO WRITE THE CONSTANT CURRENTLY IN PROGRESS, AND     *
* CLEAR FIELDS FOR THE NEXT CONSTANT TO BE CREATED.              *
*                                                                *
******************************************************************
*
FORCONST EQU   *                       *** FORCE OUT CONSTANT IN PROGRE
         ST    R9,FC9                  SAVE RETURN ADDR
         CLC   CONNAME,BLANX           ANY LABEL NAME SET UP
         BE    CKCNPRG                 NO, CONTINUE
         CLC   CONLLEN,CONLEN+1        LENGTHS SAME
         BE    CKCNPRG                 YES, CONTINUE
         ST    R6,FC6                  SAVE LABEL TABLE ADDR
         LA    R6,CONPSLBL             @ PSEUDO LABEL ENTRY
         BAL   R9,EQUSTMT              GO BUILD EQU STATEMENT
         MVC   CONNAME,BLANX           CLEAR STATEMENT LABEL FIELD
         L     R6,FC6                  RESTORE LABEL TABLE POINTER
CKCNPRG  CLI   CONPROG,1               CONSTANT IN PROGRESS
         BNE   FCCLR                   NO
         CLI   CONLEN+1,0              ANY DATA LENGTH
         BE    FCCLR                   NO
         XC    TEXT,TEXT               CLEAR TEXT FIELD
*****************************************************************
         CLI   CONTYPE,C'W'            IS THIS A WEAK EXTERN?
         BNE   NOTWEXT                 IF NOT, LEAVE IT ALONE
         MVC   MNEMONIC(5),=C'WXTRN'   BUILD AN ENTRY STATEMENT
         MVC   OPNDS(8),CONSYM         FOR THE WEAK EXTERNAL REF
         BAL   R9,WRTOUT               PUT WEXTRN RECORD OUT
         BAL   R9,PRINT                TO THE PRINT FILE ALSO.
         MVI   CONTYPE,C'A'            CHANGE TO AN A CONSTANT
NOTWEXT  DS    0H
*****************************************************************
         MVC   MNEMONIC(2),=C'DC'      SET MNEMONIC
         MVC   OPNDS(1),CONTYPE        SET TYPE
         MVI   OPNDS+1,C''''           OPERAND DELIMITER
         MVC   NAME,CONNAME            NAME TO RECORD
         MVC   OFFSET,CONOFST+1        OFFSET TO RECORD
         MVI   INSTYP,0                NOT AN INSTRUCTION
         MVI   TYPE,2                  NON-ADDRESS CONSTANT
         MVC   LEN,CONLEN+1            DATA LENGTH
         LH    R11,CONLEN              DATA LENGTH
         BCTR  R11,R0                  DATA LENGTH CODE
         STC   R11,FMCON+1             MOVE LENGTH TO MVC
FMCON    MVC   TEXT,CONDATA            DATA TO RECORD
         CLI   CONTYPE,C'C'            CHARACTER TYPE
         BE    FCHAR                   YES
         CLI   CONTYPE,C'X'            HEX TYPE
         BNE   FSYMBOL                 NO
         TM    CONOFST+3,1             OFFSET TO CONSTANT IS ODD
         BO    FHEX                    YES
         TM    CONLEN+1,1              LENGTH IS ODD
         BO    FHEX                    YES
         TM    CONOFST+3,2             OFFSET DIVISIBLE BY 4
         BO    FHWD                    NO
         CLI   CONLEN+1,4              IS IT 4-BYTES
         BNE   FHWD                    NO, JUST HALFWORD
         CLC   CONDATA(4),XZROS        CONSTANT IS ALL ZEROS
         BNE   FFCKNEG                 NO
         MVC   OPNDS(4),=C'F''0'''     BUILD OPERANDS
         B     FCWRT                   CONTINUE
FFCKNEG  ICM   R11,15,CONDATA          GET DATA
         BM    FHEX                    NEG, TREAT AS HEX
         C     R11,=F'99999'           VALUE EXCEEDS 99,999
         BH    FHEX                    YES, TREAT AS HEX
         MVC   OPNDS(2),=C'F'''        OPERAND DATA TYPE IS F
         CVD   R11,DBLWD               CONVERT VALUE TO PACKED
         UNPK  OPNDS+2(5),DBLWD+5(3)   UNPACK INTO OPERAND
         OI    OPNDS+6,C'0'            SET SIGN = F
         MVI   OPNDS+7,C''''           ENDING QUOTE
         B     FCWRT                   CONTINUE
FHWD     LH    R11,CONDATA             PICK UP HALFWORD
         LTR   R11,R11                 TEST CONSTANT VALUE
         BM    FHEX                    NEGATIVE, TREAT AS HEX
         BNZ   FHCMAX                  NOT ZERO, CHECK MAX VALUE
         MVC   OPNDS(4),=C'H''0'''     SET OPERAND FOR ZERO
         B     FCWRT                   CONTINUE
FHCMAX   CH    R11,=H'9999'            VALUE EXCEEDS 9,999
         BH    FHEX                    YES, TREAT AS HEX
         CVD   R11,DBLWD               CONVERT TO PACKED
         OI    DBLWD+7,X'0F'           CLEAR SIGN TO F
         MVC   OPNDS(2),=C'H'''        SET DELIMITER IN OPERAND
         UNPK  OPNDS+2(4),DBLWD+5(3)   UNPACK VALUE TO OPERAND
         MVI   OPNDS+6,C''''           ENDING DELIMITER
         B     FCWRT                   CONTINUE
FCHAR    MVC   OPNDS(2),=C'C'''        OPERAND DELIMITER FOR CHARACTER
         LH    R11,CONLEN              GET DATA LENGTH
         BCTR  R11,R0                  LENGTH CODE
         STC   R11,FMCNT+1             SET MOVE LENGTH
FMCNT    MVC   OPNDS+2,CONDATA         DATA TO OPERAND
         LA    R11,OPNDS+3(R11)        STEP PAST OPERAND DATA
         MVI   0(R11),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
FSYMBOL  CLC   CONSYM,BLANX            IS IT BLANK
         BE    FHEX                    YES, TREAT AS HEX
         CLI   CONLEN+1,4              LENGTH IS 4
         BH    FHEX                    NO, GREATER
         BE    AC4                     YES, 4 BYTES
         CLI   CONLEN+1,3              LENGTH IS 3
         BE    AC3                     YES
         CLI   CONLEN+1,2              LENGTH IS 2
         BE    AC2                     YES
         MVC   OPNDS+1(2),=C'L1'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC2      MVC   OPNDS+1(2),=C'L2'       OPND LGTH
         B     FSLHE1                  CONTINUE
AC3      MVC   OPNDS+1(2),=C'L3'       OPND LENGTH
         B     FSLHE1                  CONTINUE
AC4      LA    R11,OPNDS+1             STEP TO ( POS
         B     FSLHE                   CONTINUE
FSLHE1   LA    R11,OPNDS+3             STEP TO ( POS
FSLHE    MVI   0(R11),C'('             DELIMITER
         MVC   1(8,R11),CONSYM         SYMBOL TO RECORD
         LA    R11,9(R11)              @ RHE SYMBOL IN OPERAND
FRHE     CLI   0(R11),C' '             CHARACTER IS BLANK
         BNE   SETRPAR                 NO
         BCT   R11,FRHE                LOOP TO FIND RHE
SETRPAR  MVI   1(R11),C')'             SET CLOSING PAREN
         B     FCWRT                   CONTINUE
FHEX     MVC   OPNDS(2),=C'X'''        TYPE AND BEGIN QUOTE
         LA    R12,CONDATA             @ CONSTANT DATA
         BAL   R9,HEXPRT4              CONVERT TO PRINTABLE
         LH    R12,CONLEN              GET DATA LENGTH
         SLL   R12,1                   DOUBLE IT
         BCTR  R12,R0                  -1 = LENGTH CODE
         STC   R12,MVHX+1              SET MOVE LENGTH
MVHX     MVC   OPNDS+2(1),PRTABL       HEX CHARS TO OPERAND
         LA    R12,OPNDS+2(R12)        OPERAND END ADDRESS
         MVI   1(R12),C''''            ENDING QUOTE
         B     FCWRT                   CONTINUE
FCWRT    BAL   R9,WRTOUT               WRITE RECORD
         BAL   R9,TXTFMT               GO FORMAT HEX DATA
         BAL   R9,PRINT                GO PRINT IT
FCCLR    MVI   CONPROG,0               RESET CONSTANT IN PROGRESS
         MVC   CONNAME,BLANX           CLEAR NAME
         MVI   CONTYPE,0               RESET TYPE
         XC    CONDATA,CONDATA         CLEAR CONSTANT DATA
         MVC   CONSYM,BLANX            CLEAR SYMBOL
         XC    CONLEN,CONLEN           CLEAR LENGTH
         MVC   CONLOC,XZROS            CLEAR LOCATION
         MVC   CONOFST,XZROS           CLEAR OFFSET TO CONSTANT
         L     R9,FC9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE FORMATS RR-FORMAT INSTRUCTIONS FOR OUTPUT.        *
*                                                                *
******************************************************************
*
RROPND   EQU   *                       *** RR FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'05'             IS IT BALR
         BNE   RRSTRT
         CLI   1(R7),X'EF'             IS IT BALR 14,15
         BE    RRSTDL                  YES
         TM    1(R7),X'0F'             NO, IS R2 = 0
         BNZ   RRNSTD                  NO
         MVC   COMMENT(11),=C'ADDRESS SET'
         B     RRSTRT                  CONTINUE
RRSTDL   MVC   COMMENT(11),=C'STD LINKAGE'
         B     RRSTRT                  CONTINUE
RRNSTD   MVC   COMMENT(14),=C'NONSTD LINKAGE'
RRSTRT   EQU   *
         LA    R15,TEXT+1              POINT TO TEXT
         LR    R11,R1                  COPY INSTRUCTION TYPE
         CH    R11,=H'48'              RRE TYPE?
         BL    *+8                     NO, JUST RR
         LA    R15,2(R15)              ADJ FO 2 BYTE OPCODE
         SR    R1,R1                   CLEAR WORK
         IC    R1,0(R15)               GET 2ND BYTE
         SRL   R1,4                    SHIFT OUT R2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN R1 OPERAND
         CH    R1,H10                  REG NBR > 9
         BL    RR11                    NO, 0-9
         MVC   OPNDS+1(2),DBLWD        YES, 10-15
         LA    R1,OPNDS+3              TO NEXT POS
         B     RRCMA                   CONTINUE
RR11     MVC   OPNDS+1(1),DBLWD+1      MOVE REG NBR
         LA    R1,OPNDS+2              TO NEXT POS
RRCMA    EQU   *
         CH    R11,=H'48'              RRE WITH ONE OPERAND?
         BE    RRXIT                   YES
         CLI   TEXT,X'04'              IS IT SPM
         BNE   RRCMA1                  NO
         TM    1(R7),X'0F'             YES, IS R2 FIELD = 0
         BZ    RRXIT                   YES, GOOD INSTR
         B     4(R9)                   ERROR RETURN (NOT INSTR)
RRCMA1   MVC   0(2,R1),=C',R'          DELIMITERS
         PACK  DBLWD(1),0(1,R15)       FLIP 2ND BYTE
         SR    R15,R15                 CLEAR WORK
         IC    R15,DBLWD               GET R2R1
         SRL   R15,4                   SHIFT OUT R1
         CVD   R15,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R15,H10                 R2 > 9
         BL    RR21                    NO, 0-9
         MVC   2(2,R1),DBLWD           YES, MOVE REG 10-15
         BR    R9                      EXIT
RR21     MVC   2(1,R1),DBLWD+1         MOVE REG 0-9
RRXIT    BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RX-TYPE  *
* INSTRUCTIONS. THE BDXADR ROUTINE IS CALLED TO FORMAT THE       *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
RXOPND   EQU   *                       *** RX FORMAT INSTRUCTIONS ***
         CLI   0(R7),X'45'             IS IT BAL OP CODE
         BNE   RXSTRT                  NO
         MVC   COMMENT(7),=C'PERFORM'
         TM    1(R7),X'E0'             R1 = 0 OR 1
         BNZ   RXSTRT                  NO
         MVC   COMMENT(13),=C'PARM SET BRCH'
RXSTRT   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET R1X2
         SRL   R1,4                    SHIFT OUT X2
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGIN 1ST OPERAND
         CH    R1,H10                  R1 < 10
         BL    RXR11                   YES, 0-9
         MVC   OPNDS+1(2),DBLWD        NO, MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RXCMA                   CONTINUE
RXR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RXCMA    MVI   0(R15),C','             DELIMITER
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2R1
         SRL   R10,4                   SHIFT OUT R1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         BAL   R9,BDXADR               CONVERT RX ADDRESS
         STC   R10,BDXMVC+1            SET MOVE LENGTH
BDXMVC   MVC   1(1,R15),OPNDWK         MOVE RX OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT S-TYPE   *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
SOPND    EQU   *                       *** S FORMAT INSTRUCTIONS ***
         CLI   1(R7),0                 BYTE 2 OF INSTR IS ZERO
         BE    SCK2                    YES
         CLI   0(R7),X'80'             NO, IS IT SSM
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'82'             NO, IS IT LPSW
         BE    4(R9)                   YES, NOT INSTR
         CLI   0(R7),X'93'             NO, IS IT TS
         BE    4(R9)                   YES, NOT INSTR
SCK2     CLI   0(R7),X'B2'             OP-CODE IS B2
         BNE   SSTRT                   NO
         CLC   2(2,R7),XZROS           3RD AND 4TH BYTES ZERO
         BE    SSTRT                   YES
         CLI   1(R7),X'0B'             IPK INSTRUCTION
         BE    4(R9)                   YES, NOT INSTR
         CLI   1(R7),X'0D'             PTLB INSTR
         BE    4(R9)                   YES, NOT INSTR
SSTRT    SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD
         BAL   R9,BDADR                CONVERT BDDD ADDRESS
         STC   R10,SOPMVC+1            SET MOVE LENGTH
SOPMVC   MVC   OPNDS,OPNDWK            MOVE OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SI-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
SIOPND   EQU   *                       *** SI FORMAT INSTRUCTIONS ***
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SIOMVC+1            SET MOVE LENGTH
SIOMVC   MVC   OPNDS,OPNDWK            MOVE BDDD OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         TRT   TEXT+1(1),CHARTRAN      TEST IF CHARACTER
         BNZ   HEXIMM                  NO, HEX
         CLI   TEXT,X'95'              IS IT CLI
         BE    CHIMM                   YES
         CLI   TEXT,X'92'              IS IT MVI
         BNE   HEXIMM                  NO
CHIMM    MVC   1(2,R15),=C'C'''        DELIMITER
         MVC   3(1,R15),TEXT+1         CHARACTER TO OPERAND
         MVI   4(R15),C''''            ENDING DELIMITER
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
HEXIMM   MVC   1(2,R15),=C'X'''        DELIMITER FOR HEX
         LA    R12,TEXT+1              @ HEX BYTE
         BAL   R9,HEXPRT1              CONVERT
         MVC   3(2,R15),PRTABL         PRINTABLE HEX TO OPERAND
         MVI   5(R15),C''''            FINAL QUOTE
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT RS-TYPE  *
* INSTRUCTIONS. THE BDADR ROUTINE IS CALLED TO FORMAT THE        *
* STORAGE OPERAND.                                               *
*                                                                *
******************************************************************
*
RSOPND   EQU   *                       *** RS FORMAT INSTRUCTIONS ***
         CLI   TEXT,X'90'              IS IT STM
         BE    RSSTM                   YES
         CLI   TEXT,X'98'              IS IT LM
         BNE   RSCLR1                  NO
         MVC   COMMENT(12),=C'RESTORE REGS'
         B     RSCLR1                  CONTINUE
RSSTM    MVC   COMMENT(9),=C'SAVE REGS'
RSCLR1   SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               PICK UP R1R3
         SRL   R1,4                    SHIFT OUT R3
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         MVI   OPNDS,C'R'              BEGINNING OPERAND 1
         CH    R1,H10                  REG NBR < 10
         BL    RSR11                   YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG 10-15
         LA    R15,OPNDS+3             TO NEXT POS
         B     RSCMA                   CONTINUE
RSR11    MVC   OPNDS+1(1),DBLWD+1      MOVE REG 0-9
         LA    R15,OPNDS+2             TO NEXT POS
RSCMA    CLI   0(R7),X'88'             IS IT SHIFT INSTR
         BL    RSCMA1                  NO
         CLI   0(R7),X'8F'             IS IT SHIFT INSTR
         BH    RSCMA1                  NO
         TM    1(R7),X'0F'             SHIFT, IS R3 POS = 0
         BZ    RSBDD                   YES, GOOD SHIFT
         B     4(R9)                   NO, NOT INSTR
RSCMA1   MVC   0(2,R15),=C',R'         DELIMITERS
         CLI   0(R7),X'BD'             CLM, STCM, OR ICM
         BL    RSPK2                   NO
         CLI   0(R7),X'BF'             CLM,STCM, OR ICM
         BH    RSPK2                   NO
         BCTR  R15,R0                  CLM, STCM, ICM HAVE MASK IN R3 P
RSPK2    PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         SR    R1,R1                   CLEAR WORK
         IC    R1,DBLWD                GET R3R1
         SRL   R1,4                    SHIFT OUT R1
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R1,H10                  REG NBR < 10
         BL    RSR31                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE REG 10-15
         LA    R15,4(R15)              TO NEXT POS
         B     RSBDD                   CONTINUE
RSR31    MVC   2(1,R15),DBLWD+1        MOVE REG 0-9
         LA    R15,3(R15)              TO NEXT POS
RSBDD    MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDD ADDRESS
         BAL   R9,BDADR                CONVERT BDDD ADDRESS
         STC   R10,RSMVC+1             SET MOVE LENGTH
RSMVC    MVC   1(1,R15),OPNDWK         MOVE BDDD ADDRESS
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE SINGLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE 1ST STRG OPND, AND BDADR FOR THE 2ND.  *
*                                                                *
******************************************************************
*
SS1OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - SIN
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDLADR               CONVERT ADDRESS
         STC   R10,SS1MV1+1            SET MOVE LENGTH
SS1MV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET SECOND BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SS1MV2+1            SET MOVE LENGTH
SS1MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SS-TYPE  *
* INSTRUCTIONS OF THE DOUBLE LENGTH VARIETY. THE BDLADR ROUTINE  *
* IS CALLED TO FORMAT THE STORAGE OPERANDS.                      *
*                                                                *
******************************************************************
*
SS2OPND  EQU   *                       *** SS FORMAT INSTRUCTIONS - 2 L
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET L1L2
         SRL   R10,4                   SHIFT OUT L2
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDLADR               CONVERT ADDRESS
         STC   R10,SS2MV1+1            SET MOVE LENGTH
SS2MV1   MVC   OPNDS,OPNDWK            MOVE 1ST OPERAND
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET 2ND BDDD ADDR
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP L2L1
         SRL   R10,4                   SHIFT OUT L1
         CLI   TEXT,X'F0'              SRP OP-CODE
         BE    SRPOP2                  YES
         TM    IEDT,M1                 SPECIAL MOVE INST OP-CODE
         BO    SRPOP2                  YES
         BAL   R9,BDLADR               CONVERT ADDRESS
         STC   R10,SS2MV2+1            SET MOVE LENGTH
SS2MV2   MVC   1(1,R15),OPNDWK         MOVE 2ND OPERAND
SS2XIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
SRPOP2   BAL   R9,BDADR                GO BUILD OPERAND 2
         STC   R10,SRMV1+1             SET MOVE LENGTH
SRMV1    MVC   1(1,R15),OPNDWK         MOVE OPERAND 2
         LA    R15,2(R10,R15)          TO NEXT OPERAND POS  FIX***
         PACK  DBLWD(1),TEXT+1(1)      FLIP LENGTH BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP I3/R3
         SRL   R10,4                   SHIFT OUT L1
         CVD   R10,DBLWD               CONVERT I3/R3
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         MVI   0(R15),C','             OPERAND SEPARATOR    FIX***
         UNPK  1(1,R15),DBLWD+7(1)     UNPACK I3/R3 TO OPERAND FIX***
         CH    R2,H10                  I3/R3 < 10
         BL    SS2XIT                  YES
         UNPK  1(2,R15),DBLWD+6(2)     NO, UNPACK MORE
         B     SS2XIT                  CONTINUE
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT COND-    *
* ITIONAL BRANCH INSTRUCTIONS. AN ATTEMPT IS MADE TO USE THE     *
* EXTENDED MNEMONICS WHERE POSSIBLE. FOR RR-TYPE BRANCHES, ONLY  *
* THE BR AND NOPR MNEMONICS ARE USED. FOR RX-TYPE BRANCHES, THE  *
* FULL SET OF EXTENDED MNEMONICS IS USED. THE TYPES USED ARE     *
* ARITHMETIC, COMPARE, AND 8=ZERO TYPES. THE SET TO BE USED IS   *
* DETERMINED BY THE TYPE SAVED BY THE LAST CONDITION-CODE-SETTING*
* INSTRUCTION GENERATED.                                         *
*
******************************************************************
*
BCOPND   EQU   *                       *** CONDITIONAL BRANCH INSTRUCTI
         TM    TEXT+1,X'F0'            UNCONDITIONAL BRANCH
         BZ    NOPS                    NO, NOP
         BO    UNCNDS                  YES, UNCONDITIONAL
         SR    R11,R11                 CLEAR WORK
         IC    R11,TEXT+1              PICK UP M1X2
         SRL   R11,4                   SHIFT OUT ALL BUT M1
         CLI   TEXT,X'07'              BCR OP CODE
         BE    NOEXTND                 YES, NO EXTENDED MNEMONICS
         CLI   CCTYPE,0                LAST INSTR SET CC
         BE    NOEXTND                 NO
         TM    CCTYPE,ARITH            YES, WAS IT ARITHMETIC
         BO    EXTARITH                YES
         TM    CCTYPE,CPR              WAS IT COMPARE
         BO    EXTCPR                  YES
         TM    CCTYPE,ZRO8             IS IT VALID FOR 8 = BZ
         BO    EXTZRO                  YES
NOEXTND  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 MASK < 10
         BL    BCM1                    YES, SINGLE DIGIT MASK
         MVC   OPNDS(2),DBLWD          2-DIGIT MASK TO OPERAND
         LA    R15,OPNDS+2             TO NEXT POS
         B     BCCMA                   CONTINUE
BCM1     MVC   OPNDS(1),DBLWD+1        SINGLE DIGIT MASK TO OPERAND
         LA    R15,OPNDS+1             TO NEXT POS
BCCMA    MVI   0(R15),C','             DELIMITER
         CLI   TEXT,X'07'              RR BRANCH
         BE    BCROPND                 YES
BCXOPND  PACK  DBLWD(1),TEXT+1(1)      PACK 2ND BYTE
         SR    R10,R10                 CLEAR WORK
         IC    R10,DBLWD               PICK UP X2M1
         SRL   R10,4                   SHIFT OUT M1
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            PICK UP BDDD ADDRESS
         BAL   R9,BDXADR               CONVERT ADDRESS
         STC   R10,BLDXMVC+1           SET MOVE LENGTH
BLDXMVC  MVC   1(1,R15),OPNDWK         MOVE OPERAND
         B     BCOXIT                  GO TO EXIT
BCROPND  MVI   1(R15),C'R'             REGISTER DELIMITER
         SR    R10,R10                 CLEAR WORK
         PACK  DBLWD(1),TEXT+1(1)      FLIP 2ND BYTE
         IC    R10,DBLWD               PICK UP R2M1
         SRL   R10,4                   SHIFT OUT M1
         CVD   R10,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 REG NBR < 10
         BL    BCRR1                   YES, 0-9
         MVC   2(2,R15),DBLWD          MOVE 2-DIGIT REG NBR
         B     BCOXIT                  GO TO EXIT
BCRR1    MVC   2(1,R15),DBLWD+1        MOVE 1-DIGIT REG NBR
         B     BCOXIT                  GO TO EXIT
NOPS     CLI   TEXT,X'07'              RR NOP
         BNE   BCXNOP                  NO, RX
         MVC   MNEMONIC,=CL5'NOPR'     SET MNEMONIC
         LA    R15,OPNDS-1             TO OPND POS
         B     BCROPND                 FINISH
BCXNOP   MVC   MNEMONIC,=CL5'NOP'      SET MNEMONIC
         LA    R15,OPNDS-1             TO OPND POS
         B     BCXOPND                 FINISH
UNCNDS   CLI   TEXT,X'07'              IS IT RR BRANCH
         BNE   BCXBRCH                 NO, RX
         MVC   MNEMONIC,=CL5'BR'       SET MNEMONIC
         LA    R15,OPNDS-1             OPERAND ADDR
         CLI   TEXT+1,X'FE'            IS IT BR 14
         BNE   BCROPND                 NO
         MVC   COMMENT(4),=C'EXIT'     COMMENT
         B     BCROPND                 FINISH FORMATTING
BCXBRCH  MVC   MNEMONIC(5),=CL5'B'     SET MNEMONIC
BCXTFIN  LA    R15,OPNDS-1             SET OPND POS
         B     BCXOPND                 FINISH FORMAT
BCOXIT   L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
EXTARITH CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES
         BL    ARLOW                   NO, LOWER
         CH    R11,H14                 COND CODE = 14
         BE    ARBNO                   YES
         CH    R11,H13                 COND CODE = 13
         BE    ARBNP                   YES
         CH    R11,H11                 COND CODE = 11
         BE    ARBNM                   YES
         B     NOEXTND                 NO, NOT EXTENDED
ARLOW    CH    R11,H7                  COND CODE = 7
         BE    ARBNZ                   YES
         CH    R11,H1                  COND CODE = 1
         BE    ARBO                    YES
         CH    R11,H2                  COND CODE = 2
         BE    ARBP                    YES
         CH    R11,H4                  COND CODE = 4
         BE    ARBM                    YES
         B     NOEXTND                 NO, NOT EXTENDED
ARBZ     MVC   MNEMONIC(2),=C'BZ'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNO    MVC   MNEMONIC(3),=C'BNO'     SET EXTENDED MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNP    MVC   MNEMONIC(3),=C'BNP'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNM    MVC   MNEMONIC(3),=C'BNM'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBNZ    MVC   MNEMONIC(3),=C'BNZ'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBO     MVC   MNEMONIC(2),=C'BO'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBP     MVC   MNEMONIC(2),=C'BP'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
ARBM     MVC   MNEMONIC(2),=C'BM'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
EXTZRO   CH    R11,H8                  COND CODE = 8
         BE    ARBZ                    YES, USE BZ MNEMONIC
         CH    R11,H7                  COND CODE IS 7
         BE    ARBNZ                   YES
         B     NOEXTND                 NO, NOT EXTENDED
EXTCPR   CH    R11,H8                  COND CODE = 8
         BE    CPBE                    YES
         CH    R11,H7                  COND CODE = 7
         BE    CPBNE                   YES
         BL    CPLOW                   NO, LOWER
         CH    R11,H13                 COND CODE = 13
         BE    CPBNH                   YES
         CH    R11,H11                 COND CODE = 11
         BE    CPBNL                   YES
         B     NOEXTND                 NO, NOT EXTENDED
CPLOW    CH    R11,H4                  COND CODE = 4
         BE    CPBL                    YES
         CH    R11,H2                  COND CODE = 2
         BE    CPBH                    YES
         B     NOEXTND                 NO, NOT EXTENDED
CPBE     MVC   MNEMONIC(2),=C'BE'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNE    MVC   MNEMONIC(3),=C'BNE'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNH    MVC   MNEMONIC(3),=C'BNH'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBNL    MVC   MNEMONIC(3),=C'BNL'     SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBL     MVC   MNEMONIC(2),=C'BL'      SET EXT MNEMONIC
         B     BCXTFIN                 CONTINUE
CPBH     MVC   MNEMONIC(2),=C'BH'      SET EXTENDED MNEMONIC
         B     BCXTFIN                 CONTINUE
*
*
*
******************************************************************
*                                                                *
* VALIDATE AND FORMAT SVC INSTRUCTIONS. IF THE SVC OP-CODE IS    *
* FOUND IN THE SVC TABLE, IT IS ACCEPTED AS AN SVC, AND THE TABLE*
* LITERAL IS MOVED TO THE COMMENTS FIELD OF THE INSTRUCTION.     *
*                                                                *
******************************************************************
*
SVCOPND  EQU   *                       *** SVC INSTRUCTIONS ***
         CLI   TEXT+1,126              VALID OPERAND
         BH    NOTSVC                  NO, NOT SVC
         L     R1,SVCTBLAD             GET SVC TABLE ADDRESS
SVCKND   CLI   0(R1),X'FF'             END OF SVC TABLE
         BE    NOTSVC                  YES, MUST NOT BE SVC
         CLC   0(1,R1),TEXT+1          THIS THE ENTRY
         BE    GOTSVC                  YES
         LA    R1,L'SVCOP(R1)          STEP TO NEXT ENTRY
         B     SVCKND                  LOOP THRU TABLE
NOTSVC   B     4(R9)                   ERROR RETURN
GOTSVC   MVC   COMMENT(14),1(R1)       COMMENT TO WORK AREA
         SR    R1,R1                   CLEAR WORK
         IC    R1,TEXT+1               GET SVC OPERAND
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R1,H100                 OPERAND > 100
         BL    SVCK10                  YES
         MVC   OPNDS(3),DBLWD          MOVE 3-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCK10   CH    R1,H10                  OPERAND < 10
         BL    SVCL10                  YES
         MVC   OPNDS(2),DBLWD+1        MOVE 2-DIGIT OPERAND
         B     SVCXIT                  EXIT
SVCL10   MVC   OPNDS(1),DBLWD+2        MOVE 1-DIGIT OPERAND
SVCXIT   BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* THIS ROUTINE IS CALLED BY THE INSTR ROUTINE TO FORMAT SSE-TYPE *
* INSTRUCTIONS. THE BDADDR ROUTINE IS CALLED TO FORMAT THE STOR- *
* AGE OPERANDS.                                                  *
*                                                                *
******************************************************************
SSEOPND  EQU   *
         SR    R10,R10                 CLEAR WORK
         IC    R10,TEXT+1              GET LENGTH CODE
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+2            GET BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SSEMV1+1            SET MOVE LENGTH
SSEMV1   MVC   OPNDS,OPNDWK            MOVE ADDRESS
         LA    R15,OPNDS+1(R10)        TO NEXT POS
         MVI   0(R15),C','             DELIMITER
         SR    R11,R11                 CLEAR WORK
         ICM   R11,3,TEXT+4            GET BDDD ADDRESS
         BAL   R9,BDADR                CONVERT ADDRESS
         STC   R10,SSEMV2+1            SET MOVE LENGTH
SSEMV2   MVC   1(1,R15),OPNDWK         MOVE ADDRESS
         L     R9,OPND9                GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*   E INSTR, NO OPERANDS                                         *
******************************************************************
EOPND    EQU   *
         BR    R9
*
*
*
******************************************************************
*   RRE INSTRUCTIONS, 1 OR 2 OPERANDS                            *
******************************************************************
RREOPND  EQU   *
         BR    R9
*
*
*
******************************************************************
* BUILD EQU STATEMENTS USING THE LABEL TABLE ENTRY ADDRESSED BY  *
* REG 6 ON ENTRY.                                                *
*                                                                *
******************************************************************
*                                                                *
EQUSTMT  EQU   *                       BUILD EQU STATEMENTS
         ST    R9,EQU9                 SAVE RETURN ADDR
         USING LABELD,R6
         MVC     NAME,LBLNAME          NAME TO EQU STMT
         MVC   MNEMONIC,=CL5'EQU'      BUILD EQU STATEMENT
         MVI   OPNDS,C'*'              SET EQU OPERAND
         CLI   LBLLEN,1                LENGTH 0 OR 1
         BNH   CCXEQU                  YES
         SR    R9,R9                   CLEAR WORK
         IC    R9,LBLLEN               GET LENGTH
         CVD   R9,DBLWD                CONVERT
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R9,H100                 LENGTH < 100
         BL    CCXQ10                  YES
         MVC   OPNDS+2(3),DBLWD        MOVE LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ10   CH    R9,H10                  LENGTH < 10
         BL    CCXQ1                   YES
         MVC   OPNDS+2(2),DBLWD+1      MOVE 2-DIGIT LENGTH
         B     CCXEQC                  GO SET COMMA
CCXQ1    MVC   OPNDS+2(1),DBLWD+2      MOVE 1-DIGIT LENGTH
CCXEQC   MVI   OPNDS+1,C','            SET COMMA
CCXEQU   BAL   R9,WRTOUT               OUTPUT EQU STATEMENT
         BAL   R9,PRINT                GO PRINT IT
         L     R9,EQU9                 GET RETURN ADDR
         BR    R9                      RETURN
         DROP  R6
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* LENGTH. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10 *
* CONTAINS THE LENGTH. THE SCHLBL ROUTINE IS CALLED TO CREATE A  *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(LLL,RRR) IS CREATED.                                      *
*                                                                *
******************************************************************
*
BDLADR   EQU   *                       *** FORMAT DDDD(LLL,RRR) OPERAND
         ST    R9,BDL9                 SAVE RETURN ADDR
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDLSCHL                 NO
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDLCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDLCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDLSCHL                 CONTINUE
BDLCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDLSCHL  BAL   R9,SCHLBL               SEARCH FOR LABEL
         B     BDLGLBL                 BRANCH IF LABEL FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DDD
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         MVC   OPNDWK,BLANX            CLEAR WORK AREA
         CH    R1,H1000                DISPL < 1000
         BL    BDLD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD100  CH    R1,H100                 DISPL < 100
         BL    BDLD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD10   CH    R1,H10                  DISPL < 10
         BL    BDLD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDLLPN                  CONTINUE
BDLD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDLLPN   MVI   0(R1),C'('              LEFT PAREN DELIMITER
         TM    IEDT,M1                 IS THIS A SPECIAL MOVE INSTR
         BO    *+8                     DON'T ADJUST LENGTH
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH FROM LENG
         CVD   R10,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(3),DBLWD+6(2)     UNPACK
         CH    R10,H100                LENGTH < 100
         BL    BDLL10                  YES
         MVC   1(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL10   CH    R10,H10                 LENGTH < 10
         BL    BDLL1                   YES
         MVC   1(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
         B     BDLCMA                  CONTINUE
BDLL1    MVC   1(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,2(R1)                TO NEXT POS
BDLCMA   MVC   0(2,R1),=C',R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 REG < 10
         BL    BDLR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT REGISTER
         LA    R1,4(R1)                TO NEXT POS
         B     BDLRPN                  CONTINUE
BDLR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT REG
         CLI   2(R1),C'0'              IS REG = 0
         BNE   BDLB1                   NO
         MVC   0(2,R1),BLANX           YES, BLANK IT
***      BCTR  R1,R0                   BACK UP 1            FIX***
         B     BDLRPN                  CONTINUE
BDLB1    LA    R1,3(R1)                TO NEXT POS
BDLRPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE OPERAND LENGTH CODE
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDLGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R10,1(R10)              COMPUTE ACTUAL LENGTH
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDLGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDLGCKLN                YES
         BCT   R1,BDLGRHE              LOOP TO RHE
BDLGCKLN CLM   R10,1,LBLLEN            LBL AND INSTR LENGTHS SAME
         BE    BDLGCMP                 YES
         MVI   1(R1),C'('              NO, DELIMITER
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(3),DBLWD+5(3)     UNPACK
         OI    DBLWD+2,C'0'            CLEAR SIGN
         CH    R10,H100                LENGTH < 100
         BL    BDLG10                  YES
         MVC   2(3,R1),DBLWD           MOVE 3-DIGIT LENGTH
         LA    R1,5(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG10   CH    R10,H10                 LENGTH < 10
         BL    BDLG1                   YES
         MVC   2(2,R1),DBLWD+1         MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDLGRPN                 CONTINUE
BDLG1    MVC   2(1,R1),DBLWD+2         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDLGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDLGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDL9                 GET RETURN ADDR
         BR    R9                      EXIT
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE AND DISPLACEMENT.      *
* THE SCHLBL ROUTINE IS CALLED TO SEE WHETHER A LABEL REFERENCE  *
* MAY BE USED, RATHER THAN AN EXPLICIT ADDRESS. IF LBLSCH IS NOT *
* SUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM DDDD(RRR) IS FORMED*
* ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS.                    *
*                                                                *
******************************************************************
*
BDADR    EQU   *                       *** FORMAT DDDD(RRR) OPERANDS **
         ST    R9,BD9                  SAVE RETURN ADDR
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDSCHL                  NO
         CLI   TEXT,X'8F'              IS IT SLDA??              FIX***
         BH    BDSADR1                 YES                       FIX***
         CLI   TEXT,X'88'              IS IT SRL                 FIX***
         BNL   BDSCHL                  YES                       FIX***
BDSADR1  SRL   R1,20                   RIGHT JUSTIFY DISPL       FIX***
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDCVTR                  YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDCVTR                  YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDSCHL                  CONTINUE
BDCVTR   MVC   COMMENT(11),=C'CVT ADDRESS'
BDSCHL   BAL   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDGLBL                  BRANCH IF FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT B
         SRL   R1,20                   RIGHT JUSTIFY DDD
         CVD   R1,DBLWD                CONVERT DISPL
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDAD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD100  CH    R1,H100                 DISPL < 100
         BL    BDAD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD10   CH    R1,H10                  DISPL < 10
         BL    BDAD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDALPN                  CONTINUE
BDAD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDALPN   MVC   0(2,R1),=C'(R'          DELIMITERS
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDAR1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDARPN                  CONTINUE
BDAR1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDARPN   MVI   0(R1),C')'              FINAL DELIMITER
         LR    R2,R1                   COPY END ADDRESS
         SH    R2,H4                   BACK UP 4
         CLC   1(4,R2),=C'(R0)'        BASE REG IS ZERO
         BNE   BDCE                    NO
         MVC   1(4,R2),BLANX           CLEAR BASE REG
         LR    R1,R2                   COPY NEW END ADDR
BDCE     LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDGLBL   MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDGRHE   CLI   0(R1),C' '              AT RHE
         BNE   BDGCMP                  YES
         BCT   R1,BDGRHE               LOOP TO RHE
BDGCMP   LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BD9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* BUILDS STORAGE OPERANDS CONTAINING BASE, DISPLACEMENT, AND     *
* INDEX. ON ENTRY, REG 11 CONTAINS THE BDDD ADDRESS, AND REG 10  *
* CONTAINS THE INDEX. THE SCHLBL ROUTINE IS CALLED TO CREATE A   *
* LABEL REFERENCE, IF THE BASE REG IS CURRENT, AND A LABEL EXISTS*
* IF SCHLBL IS UNSUCCESSFUL, AN EXPLICIT ADDRESS OF THE FORM     *
* DDDD(XXX,RRR) IS CREATED.                                      *
*                                                                *
******************************************************************
*
BDXADR   EQU   *                       *** FORMAT DDDD(XXX,BBB) OPERAND
         ST    R9,BDX9                 SAVE RETURN ADDR
         LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXSCHL                 YES
         SR    R0,R0                   CLEAR WORK REG
         LR    R1,R11                  COPY BDDD ADDRESS
         SLDL  R0,20                   BASE REG TO R0
         LTR   R0,R0                   IS BASE REG 0
         BNZ   BDXSCHL                 NO
         CLI   TEXT,X'41'              IS IT LA
         BE    BDXSCHL                 YES
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         CH    R1,H16                  REFERENCE TO CVT ADDR
         BE    BDXCVTR                 YES
         CH    R1,H76                  REF TO ALTERNATE CVT ADDR
         BE    BDXCVTR                 YES
         MVC   COMMENT(13),=C'PSA REFERENCE'
         B     BDXSCHL                 CONTINUE
BDXCVTR  MVC   COMMENT(11),=C'CVT ADDRESS'
BDXSCHL  BAL   R9,SCHLBL               GO SEARCH FOR LABEL
         B     BDXGLBL                 BRANCH IF FOUND
         LR    R1,R11                  COPY BDDD ADDRESS
         SLL   R1,20                   SHIFT OUT BASE REG
         SRL   R1,20                   RIGHT JUSTIFY DISPL
         SRL   R11,12                  RT JUSTIFY BASE REG
         CVD   R1,DBLWD                CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(4),DBLWD+5(3)     UNPACK
         CH    R1,H1000                DISPL < 1000
         BL    BDXD100                 YES
         MVC   OPNDWK(4),DBLWD         MOVE 4-DIGIT DISPL
         LA    R1,OPNDWK+4             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD100  CH    R1,H100                 DISPL < 100
         BL    BDXD10                  YES
         MVC   OPNDWK(3),DBLWD+1       MOVE 3-DIGIT DISPL
         LA    R1,OPNDWK+3             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD10   CH    R1,H10                  DISPL < 10
         BL    BDXD1                   YES
         MVC   OPNDWK(2),DBLWD+2       MOVE 2-DIGIT DISPL
         LA    R1,OPNDWK+2             TO NEXT POS
         B     BDXLPN                  CONTINUE
BDXD1    MVC   OPNDWK(1),DBLWD+3       MOVE 1-DIGIT DISPL
         LA    R1,OPNDWK+1             TO NEXT POS
BDXLPN   LTR   R10,R10                 ANY INDEX REG
         BNZ   BDXLPNR                 YES
         LTR   R11,R11                 ANY BASE REG
         BNZ   PREPB                   YES
         BCTR  R1,R0                   NO, BACK UP TO RHE
         B     BDXCE                   CONTINUE
PREPB    MVC   0(3,R1),=C'(,R'         DELIMITERS
         LA    R1,1(R1)                STEP OVER 1 BYTE
         B     BDXCBAS                 CONTINUE
BDXLPNR  MVC   0(2,R1),=C'(R'          DELIMITERS
         CVD   R10,DBLWD               CONVERT INDEX REG
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R10,H10                 INDEX REG < 10
         BL    BDXX1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT INDEX REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXCMA                  CONTINUE
BDXX1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT INDEX REG
         LA    R1,3(R1)                TO NEXT POS
BDXCMA   LTR   R11,R11                 ANY BASE REG
         BZ    BDXRPN                  NO
         MVC   0(2,R1),=C',R'          DELIMITERS
BDXCBAS  CVD   R11,DBLWD               CONVERT
         OI    DBLWD+7,X'0F'           CLEAR SIGN
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         CH    R11,H10                 BASE REG < 10
         BL    BDXB1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT BASE REG
         LA    R1,4(R1)                TO NEXT POS
         B     BDXRPN                  CONTINUE
BDXB1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT BASE REG
         LA    R1,3(R1)                TO NEXT POS
BDXRPN   MVI   0(R1),C')'              FINAL DELIMITER
BDXCE    LR    R10,R1                  COPY END ADDR
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
         USING LABELD,R12
BDXGLBL  MVC   OPNDWK(8),LBLNAME       LABEL ENTRY NAME TO WORK
         LA    R1,OPNDWK+7             @ LAST POSS CHARACTER
BDXGRHE  CLI   0(R1),C' '              AT RHE
         BNE   BDXGCKLN                YES
         BCT   R1,BDXGRHE              LOOP TO RHE
BDXGCKLN LTR   R10,R10                 ANY INDEX REGISTER
         BZ    BDXGCMP                 NO
         MVI   1(R1),C'('              YES, DELIMITER
         CVD   R10,DBLWD               CONVERT LENGTH
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
BDXG10   CH    R10,H10                 LENGTH < 10
         BL    BDXG1                   YES
         MVC   2(2,R1),DBLWD           MOVE 2-DIGIT LENGTH
         LA    R1,4(R1)                TO NEXT POS
         B     BDXGRPN                 CONTINUE
BDXG1    MVC   2(1,R1),DBLWD+1         MOVE 1-DIGIT LENGTH
         LA    R1,3(R1)                TO NEXT POS
BDXGRPN  MVI   0(R1),C')'              FINAL DELIMITER
BDXGCMP  LR    R10,R1                  COPY END ADDRESS
         S     R10,OWSTRT              COMPUTE LENGTH CODE
         L     R12,SLSAV+12            RESTORE R12
         L     R9,BDX9                 GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
WRTOUT   EQU   *                       WRITE OUTPUT RECORDS
         L     R1,PUNCHDCB             @ SYSPUNCH DCB
         MVC   PRT+30(80),WORKREC      SAVE IN PRINT
         TM    48(R1),X'10'            IS FILE OPEN
         BZ    CLRWKR                  NO
         AP    CARDNO,=P'10'           INCREMENT CARD NO
         UNPK  SEQNBR,CARDNO           UNPACK INTO CARD
         OI    SEQNBR+7,C'0'           CLEAR SIGN
         PUT   (1),WORKREC             WRITE SOURCE CARD
CLRWKR   MVC   WORKREC,BLANX           CLEAR OUTPUT RECORD
         BR    R9                      RETURN
*
*
*
******************************************************************
*                                                                *
* SEARCHES THE BASE REGISTER TABLE TO FIND THE BASE REGISTER     *
* ASSOCIATED WITH THE BDDD OPERAND ADDRESS PASSED IN REG 11 ON   *
* ENTRY. IF THE BASE REGISTER GIVEN IS NOT A CURRENT BASE REG    *
* THE UNSUCCESSFUL RETURN IS MADE TO 4 BYTES PAST THE ADDRESS    *
* IN REG 9 ON ENTRY. WHEN THE CURRENT BASE REGISTER ENTRY IS FOR *
* A PROGRAM BASE REG, THE DISPLACEMENT IS ADDED TO THE ASSUMED   *
* BASE REGISTER VALUE IS ADDED TO THE DISPLACEMENT TO GIVE AN    *
* OFFSET IN THE PROGRAM. THE LABEL TABLE IS SEARCHED FOR AN ENTRY*
* WITH THIS OFFSET, AND IF FOUND, IS RETURNED TO THE CALLER. WHEN*
* THE BASE REGISTER FOUND IS FOR A DSECT, THE DSECT HEADER ENTRY *
* ADDRESS IS GIVEN IN THE BASE TABLE ENTRY. THE DSECT HEADER HAS *
* THE ADDRESS OF THE FIELD DEFINITION TABLE FOR THE DSECT. THE   *
* FIELD DEFINITION TABLE IS SEARCHED FOR AN ENTRY HAVING THE     *
* DISPLACEMENT IN THE BDDD INSTRUCTION, AND IF FOUND IS PASSED   *
* BACK TO THE CALLER. IF THE LABEL/FIELD TABLE SEARCHES ARE      *
* UNSUCCESSFUL, RETURN IS TO 4 BYTES PAST REG 9.                 *
*                                                                *
******************************************************************
*
SCHLBL   EQU   *                       *** SEARCH FOR LABEL AT BDDD ADD
         TM    MORUSG,X'80'            ANY BASES ACTIVE
         BZ    4(R9)                   NO, UNSUCCESSFUL EXIT
         STM   R9,R12,SLSAV            YES, SAVE REGS USED
         LR    R12,R11                 COPY BDDD ADDRESS
         SRL   R12,12                  CLEAR WORK REG
*        LTR   R12,R12                 IS BASE REG ZERO
*        BZ    SCHNF                   YES, NO LABEL
         MH    R12,USGLEN              BASE X BASE TBL ENTRY LENG
         LA    R12,BASES(R12)          @ BASE TBL ENTRY
         USING USINGD,R12
         CLI   USTYPE,0                ENTRY IN USE
         BE    SCHNF                   NO, EXIT
         LR    R9,R11                  COPY BDDD ADDRESS
         SLL   R9,20                   SHIFT OUT BASE
         SRL   R9,20                   RIGHT JUSTIFY DDD
         ICM   R11,7,USVALU            GET BASE REG VALUE
         LA    R11,0(R11)              CLEAR HI-ORDER
         CLI   USTYPE,C'P'             PROGRAM BASE REG
         BE    PGMBASE                 YES
         DROP  R12
         LR    R12,R11                 COPY DSECT FIELD TBL ADDRESS
         USING DSECTD,R12
CKDSCTND CLM   R9,7,DSOFSET            THIS THE ENTRY
         BE    SCHFD                   YES
         CLC   DSOFSET,HIVAL           NO, AT TABLE END
         BE    SCHNF                   YES, NO LABEL FOUND
         LA    R12,L'DSECT(R12)        STEP TO NEXT ENTRY
         B     CKDSCTND                LOOP THRU DSECT FIELDS
PGMBASE  AR    R9,R11                  COMPUTE OFFSET
         DROP  R12
         L     R12,LBLTBL              @ LABEL TABLE
         USING LABELD,R12
CKENTFD  CLM   R9,7,LBLADR             THIS THE ENTRY
         BE    SCHFD                   YES
         LA    R12,L'LABEL(R12)        TO NEXT ENTRY
         C     R12,CURRLBL             END OF TBL
         BNL   SCHNF                   YES, NO LABEL
         B     CKENTFD                 NO, CONTINUE SEARCH
SCHNF    LM    R9,R12,SLSAV            NOT FOUND, RESTORE REGS
         B     4(R9)                   NOT FOUND RETURN
SCHFD    LM    R9,R11,SLSAV            FOUND RESTORE ALL BUT 12
         BR    R9                      FOUND RETURN
         DROP  R12
*
*
*
******************************************************************
*                                                                *
* PRINT A LINE USING THE SYSPRINT DCB DEFINED IN DISASM PHASE 0. *
*                                                                *
******************************************************************
*
PRINT    EQU   *                       PRINT ROUTINE
         L     R1,PRINTDCB             @ SYSPRINT DCB
         TM    48(R1),X'10'            IS SYSPRINT OPEN
         BNO   CLRPRT                  NO
         PUT   (1),PRTLINE             WRITE PRINT LINE
CLRPRT   MVC   PRT,BLANX               CLEAR PRINT LINE
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C' '                SINGLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'0'                DOUBLE SPACED
         BE    SETSGL                  YES
         AP    LINECT,P1               INCR LINE COUNTER
         CLI   PCC,C'-'                TRIPLE SPACED
         BE    SETSGL                  YES
         ZAP   LINECT,P0               NO, MUST BE NEW PAGE
SETSGL   MVI   PCC,C' '                SET SINGLE SPACING
         CP    LINECT,P58              PAST END OF PAGE
         BH    NEWPAGE                 YES
         BR    R9                      EXIT
NEWPAGE  MVI   PCC,C'1'                SET SKIP TO HOF
         ZAP   LINECT,P0               RESET LINE COUNTER
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* CONVERT HEX DATA TO PRINTABLE FORM: 2 CHARACTERS PER BYTE. ON  *
* ENTRY, REG 12 CONTAINS THE ADDRESS OF THE LEFT END OF THE FIELD*
* TO BE CONVERTED, AND THE ENTRY POINT USED DETERMINES THE LENGTH*
* FORMATTED OUTPUT IS PLACED IN THE PRTABL FIELD.                *
*                                                                *
******************************************************************
*
HEXPRT   EQU   *                       HEX TO PRINTABLE ROUTINE
HEXPRT1  UNPK  PRTABL(3),0(2,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT2  UNPK  PRTABL(5),0(3,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT3  UNPK  PRTABL(7),0(4,R12)      UNPACK HEX
         B     HEXCLTR                 CONTINUE
HEXPRT4  UNPK  PRTABL(9),0(5,R12)      UNPACK HEX
HEXCLTR  MVZ   PRTABL(8),XZROS         CLEAR FOR TRANSLATE
         TR    PRTABL(8),TRTBL         MAKE PRINTABLE
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* FORMATS THE HEX DATA CORRESPONDING TO THE FORMATTED INSTRUCTION*
* BEING OUTPUT. PRINTABLE HEX IS PLACED AT THE RIGHT OF THE LINE *
* ON THE SYSPRINT OUTPUT.                                        *
*                                                                *
******************************************************************
*
TXTFMT   EQU   *                       *** FORMAT TEXT FOR PRINT ***
         ST    R9,TX9                  SAVE RETURN ADDR
         LA    R11,PRT                 @ PRINT LINE
         CLI   TYPE,1                  ADCON
         BE    TFOFST                  YES
         CLI   TYPE,2                  CONSTANT
         BE    TFOFST                  YES
         CLI   TYPE,X'0D'              INSTRUCTION
         BNE   TXTCLEAN                NO
TFOFST   LA    R12,OFFSET              @ OFFSET TO INSTR
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   PRT+00(6),PRTABL        OFFSET TO PRINT
         LA    R12,LEN                 @ DATA LENGTH
         BAL   R9,HEXPRT1              MAKE PRINTABLE
         MVC   PRT+08(2),PRTABL        LENGTH TO PRINT
         LA    R12,TEXT                @ TEXT TO PRINT
         BAL   R9,HEXPRT4              CONVERT 1ST 4 BYTES
         CLI   LEN,4                   IS IT 4 BYTES
         BNL   TXT4                    YES, OR MORE
         CLI   LEN,3                   IS IT 3 BYTES
         BE    TXT3                    YES
         CLI   LEN,2                   IS IT 2 BYTES
         BE    TXT2                    YES
         MVC   PRT+14(2),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT2     MVC   PRT+14(4),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT3     MVC   PRT+14(6),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT4     MVC   PRT+14(8),PRTABL        TEXT TO PRINT
         CLI   LEN,4                   IS IT 4 BYTES
         BE    TXTCLEAN                YES, FINISH
         LA    R12,TEXT+4              @ TEXT
         BAL   R9,HEXPRT4              CONVERT
         CLI   LEN,8                   8 BYTES OF TEXT
         BE    TXT8                    YES
         CLI   LEN,7                   7 BYTES OF TEXT
         BE    TXT7                    YES
         CLI   LEN,6                   6 BYTES OF TEXT
         BE    TXT6                    YES
         MVC   PRT+18(2),PRTABL        TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT6     MVC   PRT+022(4),PRTABL       TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT7     MVC   PRT+022(6),PRTABL       TEXT TO PRINT
         B     TXTCLEAN                FINISH
TXT8     MVC   PRT+022(8),PRTABL       TEXT TO PRINT
TXTCLEAN XC    OFFSET,OFFSET           CLEAR
         L     R9,TX9                  GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* ENTERED WHENEVER THE CURRENT TEXT OFFSET IS PAST THE NEXCHG    *
* FIELD VALUE. THIS ROUTINE CREATES DROP CARDS FOR EXHAUSTED BASE*
* REGISTERS, AND USING STATEMENTS FOR NEW BASE REGISTERS. THE    *
* BASES TABLE IS SCANNED, AND ANY ENTRY WHICH IS NO LONGER IN USE*
* IS ZEROED OUT, AND A DROP RECORD IS CREATED. NEXT, THE USING   *
* TABLE IS SCANNED. WHEN AN ENTRY IS FOUND WHICH IS VALID AT THE *
* CURRENT OFFSET, THE BASE TABLE IS CHECKED. IF THE ENTRY IS NOT *
* IN USE, A USING STATEMENT IN CREATED, AND THE USING TABLE ENTRY*
* IS MOVED TO THE BASES TABLE. THE NEXCHG FIELD IS CHANGED TO    *
* CONTAIN THE OFFSET AT WHICH THE NEXT SCAN MUST BE MADE. AN IND-*
* ICATOR CALLED MORUSG IS SET TO SHOW WHEN ANY BASE REGISTERS ARE*
* CURRENTLY IN USE. WHEN NO MORE REGISTERS ARE AVAILABLE, THE    *
* NEXCHG FIELD IS SET TO HEX FF'S.                               *
*                                                                *
******************************************************************
*
NEXUSG   EQU   *                       *** GET NEXT BASE REG SET ***
         MVC   NEXCHG,HIVAL            RESET NEXT CHANGE ADDR
         MVI   MORUSG,0                CLEAR BASE REG AVAIL INDIC
         ST    R9,USG9                 SAVE RETURN ADDR
*        XC    BASES(L'USING),BASES    CLEAR R0 ELEMENT
         MVC   BASES+16*L'USING(4),HIVAL SET TABLE STOPPER
         USING USINGD,R2
         LA    R2,BASES                @ R0'S ELEMENT
*        LA    R2,BASES+L'USING        @ R1'S ELEMENT
DRPCKND  CLI   0(R2),X'FF'             END OF TABLE
         BE    USGUSG                  YES
         CLC   USEND,XZROS             ENTRY USED
         BE    DRPSTEP                 NO
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BL    DRPSTEP                 NO
         MVC   MNEMONIC(4),=C'DROP'    OPERATION IS DROP
         MVI   OPNDS,C'R'              DELIMITER FOR REGS
         SR    R12,R12                 CLEAR WORK
         IC    R12,USREG               GET REG
         CVD   R12,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R12,H10                 REG < 10
         BL    DPR1                    YES
         MVC   OPNDS+1(2),DBLWD        MOVE REG NBR
         B     WRTDROP                 GO WRITE DROP
DPR1     MVC   OPNDS+1(1),DBLWD+1      MOVE 1-DIGIT REG
WRTDROP  BAL   R9,WRTOUT               WRITE DROP RECORD
         BAL   R9,PRINT                PRINT DROP RECORD
         XC    USING,USING             CLEAR THE ENTRY
DRPSTEP  LA    R2,L'USING(R2)          TO NEXT BASE ELEMENT
         B     DRPCKND                 LOOP
USGUSG   L     R2,USGSTRT              GET FIRST USING TBL ADDR
ENDUS    CLI   0(R2),X'FF'             END OF TABLE
         BE    XITUS                   YES
         CLC   TXTOFSET,USEND          PAST END OF THIS ONE
         BNL   ECSTEP                  YES
         OI    MORUSG,1                SHOW MORE BASES AVAIL
USBGCK   CLC   TXTOFSET,USBGN          CURR LOC BEFORE THIS
         BNL   CKNEWLO                 NO
         CLC   USBGN,NEXCHG            BEGINS BEFORE NEXT CHANGE
         BNL   ECSTEP                  NO
         MVC   NEXCHG,USBGN            YES, SET LOWER CHANGE OFFSET
         B     ECSTEP                  CONTINUE
CKNEWLO  CLC   USEND,NEXCHG            THIS ENTRY ENDS EARLIER
         BNL   ECMVC                   NO
         MVC   NEXCHG,USEND            YES, SET NEW END
ECMVC    SR    R1,R1                   CLEAR WORK
         IC    R1,USREG                PICK UP REG
         MH    R1,USGLEN               TIMES ENTRY LENGTH
         LA    R1,BASES(R1)            @ BASE TABLE ENTRY
         OI    MORUSG,X'80'            SHOW BASE IN USE
         CLC   USING,0(R1)             OLD AND NEW IDENTICAL
         BE    ECSTEP                  YES
MAKUSG   MVC   0(L'USING,R1),USING     NEW USING TO TABLE
         MVC   MNEMONIC(5),=C'USING'   OPERATION IS USING
         CLI   USTYPE,C'D'             IS IT A DSECT
         BNE   CKUTPS                  NO
         ICM   R12,7,USVALU            YES, GET DSECT HEADER ADDR
         L     R11,DTBSTRT             @ 1ST DSECT HEADER ENTRY
DSCTEND  C     R11,DTBCURR             END OF TABLE
         BH    MVDSNAME                YES
         CLM   R12,7,8(11)             THIS THE HEADER ENTRY
         BNE   DSCTSTEP                NO
         LR    R12,R11                 YES, COPY IT'S ADDRESS
         B     MVDSNAME                CONTINUE
DSCTSTEP LA    R11,11(R11)             TO NEXT HEADER ENTRY
         B     DSCTEND                 LOOP THRU TABLE
MVDSNAME MVC   OPNDS(8),0(R12)         DSECT NAME TO OPERANDS
         LA    R12,OPNDS+7             TO END OF NAME
USFRHED  CLI   0(R12),C' '             FOUND RHE
         BNE   USFMADD                 YES
         BCT   R12,USFRHED             BACK UP 1 AND LOOP
USFMADD  LA    R12,1(R12)              TO NEXT BYTE
USFMCMA  MVC   0(2,R12),=C',R'         DELIMITERS
         SR    R11,R11                 CLEAR WORK
         IC    R11,USREG               GET REGISTER NBR
         CVD   R11,DBLWD               CONVERT TO PACKED
         UNPK  DBLWD(2),DBLWD+6(2)     UNPACK REG NBR
         OI    DBLWD+1,C'0'            CLEAR SIGN
         CH    R11,H10                 REG < 10
         BL    USFMR1                  YES
         MVC   2(2,R12),DBLWD          MOVE 2-DIGIT REG NBR
         B     USINGOUT                GO WRITE USING
USFMR1   MVC   2(1,R12),DBLWD+1        MOVE 1-DIGIT REG NBR
USINGOUT BAL   R9,WRTOUT               WRITE USING STMT
         BAL   R9,PRINT                PRINT USING STMT
         B     ECSTEP                  CONTINUE
CKUTPS   CLC   USVALU,TXTOFSET         USING AT CURR LOC
         BNE   USFMLBL                 NO
         MVI   OPNDS,C'*'              SET CURRENT LOC SYMBOL IN OPERAN
         LA    R12,OPNDS+1             GET NEXT POS ADDR
         B     USFMCMA                 GO FORMAT REG
USFMLBL  MVI   OPNDS,C'A'              SET 1ST CHAR OF LABEL NAME
         LA    R12,USVALU              GET OFFSET
         BAL   R9,HEXPRT3              CONVERT TO PRINTABLE
         MVC   OPNDS+1(6),PRTABL       PRINTABLE HEX TO LABEL
         LA    R12,OPNDS+7             TO NEXT LOC
         B     USFMCMA                 FORMAT REG
ECSTEP   LA    R2,L'USING(R2)          TO NEXT USING ENTRY
         B     ENDUS                   CONTINUE SCAN
XITUS    L     R9,USG9                 GET RETURN ADDR
         BR    R9                      EXIT
*
*
*
******************************************************************
*                                                                *
* END OF PHASE 2 - RETURN TO PHASE 0                             *
*                                                                *
******************************************************************
*
EOJ      EQU   *                       END OF JOB
         BAL   R9,FORCONST             YES, FORCE IT OUT
         L     R13,4(R13)              GET POINTER TO CALLER'S SAVE ARE
         LM    R14,R12,12(R13)         RESTORE CALLER'S REGS
         SR    R15,R15                 CLEAR RETURN CODE
         BR    R14                     RETURN TO CALLER
*
*
*
*                 *** DATA AND WORK AREAS ***
******************************************************************
*                                                                *
*
* FOLLOWING FIELDS: COMMPARM THRU COMMEND ARE COMMON AREAS SHARED
* BY THIS, AND CALLED SUB-PROGRAMS. ALL CHANGES MUST BE COORDINTAED
* WITH ALL OTHER PROGRAMS.
*
******************************************************************
*
         DS    0D
COMMPARM DSECT ,                       COMMON AREAS
DBLWD    DS    D                       DOUBLEWORD WORK AREA
PUNCHDCB DS    F                       @ SYSPUNCH DCB
PRINTDCB DS    F                       @ SYSPRINT DCB
INDCB    DS    F                       @ SYSIN DCB
CSECT    DS    CL8                     SPECIFIED CSECT NAME
ESDID    DS    XL2                     ESD ID OF SPECIFIED CSECT
ENDLBLNM DS    CL8                     SYMBOL FOR END STMT BEGIN POINTE
LINECT   DS    PL2                     PRINT LINE COUNTER
START    DS    A                       LKED ASSIGNED START ADDR OF CSEC
END      DS    A                       CSECT END ADDRESS
LENGTH   DS    F                       LENGTH OF SPECIFIED CSECT
LBLTBL   DS    F                       @ LABEL TABLE
CURRLBL  DS    F                       CURRENT LABEL ENTRY ADDR
ENDLBL   DS    F                       @ END OF LABEL TBL
LBLLGTH  DS    AL2                     LENGTH OF LABEL ENTRY
TXTSTRT  DS    F                       @ TEXT STORAGE AREA
TXTEND   DS    F                       @ END OF TEXT AREA
TXTCURR  DS    F                       @ CURRENT TEXT LOC
DTBCURR  DS    F                       @ CURRENT DSECT TABLE ENTRY
DTBEND   DS    F                       @ DSECT TABLE END
DTBSTRT  DS    F                       @ DSECT TABLE START
USGSTRT  DS    F                       @ USING TABLE START
USGCUR   DS    F                       @ CURRENT USING TABLE ENTRY
USGEND   DS    F                       @ USING TABLE END
DATONLY  DS    F                       @ DATA ONLY TABLE
DATOCUR  DS    F                       @ CURRENT DATA ONLY ENTRY
DATEND   DS    F                       @ END OF DATA ONLY TABLE
FLPTASM  DS    XL1                     FLOATING POINT INDICATOR
PRIVASM  DS    XL1                     PRIVILEGED INDICATOR
USERR    DS    XL1                     ERROR INDIC FOR DISASM1
NBRLBLS  DS    H                       NBR LABELS FROM DISASM1
*
*
*
WORKREC  DS    0CL80                   DISASSEMBLY WORK AREA
NAME     DS    CL8                     NAME
         DS    CL1
MNEMONIC DS    CL5                     INSTRUCTION MNEMONIC
         DS    CL1
OPNDS    DS    CL27                    1ST OPERAND
         DS    CL1
COMMENT  DS    CL28                    COMMENT
COL72    DS    CL1                     CONTINUATION COLUMN
SEQNBR   DS    CL8                     CARD SEQUENCE NBR
*
*
*
CARDNO   DS    PL4                     CURRENT OUTPUT CARD NBR
PRTLINE  DS    0CL121                  PRINT LINE
PCC      DS    CL1                     CARRIAGE CONTROL
PRT      DS    CL120                   PRINT DATA
*
*
*
         DS    0F
BLDLIST  DS    0CL62                   BLDL LIST
         DC    H'1'                    ONE ENTRY
         DC    H'58'                   LENGTH OF ENTRY
MEMBER   DC    CL8' '                  MEMBER NAME
TTRMOD   DC    XL3'000000'             TTR OF MODULE
CCAT     DC    XL1'00'                 CONCATENATION NUMBER
         DC    XL1'00'
ALIASIND DC    XL1'00'                 ALIAS AND MISC INDICATOR
*                           80=ALIAS
TTR1TXT  DC    XL3'000000'             TTR OF 1ST TXT RECORD
         DC    XL1'00'
TTRNS    DC    XL3'000000'             TTR OF NOTE OR SCATTER LIST
NNOTE    DC    XL1'00'                 NBR ENTRIES IN NOTE LIST
ATTR1A   DC    XL1'00'                 MODULE ATTRIBUTES 1, BYTE 1
*                           80=RENT
*                           40=REUS
*                           20=OVERLAY
*                           10=UNDER TEST
*                           08=ONLY LOADABLE
*                           04=SCATTER FORMAT
*                           02=EXECUTABLE
*                           01=ONE TXT, NO RLD RECORDS
ATTR1B   DC    XL1'00'                 ATTRIBUTES 1, BYTE 2
*                           80=CANNOT BE REPROCESSED BY LKED E
*                           40=ORIGIN OF 1ST TXT RECORD IS ZERO
*                           20=ASSIGNED ENTRY POINT ADDR IS ZERO
*                           10=CONTAINS NO RLD RECORD
*                           08=CANNOT BE REPROCESSED BY LKED
*                           04=CONTAINS TESTRAN SYMBOLS
*                           02=CREATED BY LKED
*                           01=REFR
TOTVIRT  DC    XL3'000000'             TOTAL VIRTUAL STRG REQRD FOR MOD
LENG1    DC    XL2'0000'               LENGTH OF 1ST TEXT RECORD
LKEPA    DC    XL3'000000'             ASSIGNED ENTRY POINT ADDR
ATTR2    DC    XL1'00'                 ATTRIBUTES 2
*                           80=PROCESSED BY OS/VS LKED
*                           20=PAGE ALIGNMENT REQUIRED FOR MODULE
*                           10=SSI PRESENT
         DC    XL2'0000'
SCTRLEN  DC    XL2'0000'               SCATTER LIST LENGTH
TTLEN    DC    XL2'0000'               TRANSLATION TABLE LENGTH
SCESDID  DC    XL2'0000'               CESD NBR FOR 1ST TXT RECD
SCEPESD  DC    XL2'0000'               CESD NBR FOR ENTRY POINT
ALEPA    DC    XL3'000000'             ENTRY POINT OF THE MEMBER NAME
ALMEM    DC    CL8' '                  REAL MEMBER NAME FOR ALIAS
SSI      DS    XL4'00000000'           SSI BYTES
AUTHLEN  DC    XL1'00'                 AUTH CODE LENGTH
AUTHCOD  DC    XL1'00'                 AUTH CODE
*
*
*
COMMEND  EQU   *
*
*
*
LABELD   DSECT ,                       LABEL TABLE ENTRY
LABEL    DS    0CL13                   13-BYTE ENTRIES
LBLADR   DS    XL3                     RELATIVE ADDR IN TEXT
LBLTYP   DS    CL1                     TYPE: L=LABEL, A=ADCON, V=VCON,
LBLNAME  DS    CL8                     NAME (SYMBOL)
LBLLEN   DS    XL1                     LENGTH IF A, V, OR W
*
*
*
USINGD   DSECT ,                       USING TABLE ENTRY
USING    DS    0CL11
USBGN    DS    XL3                     OFFSET TO BEGINNING OF RANGE
USEND    DS    XL3                     OFFSET TO END OF RANGE
USREG    DS    XL1                     BASE REGISTER USED
USTYPE   DS    XL1                     TYPE:P=PGM,D=DSECT
USVALU   DS    XL3                     BASE REG VALUE
*
*
*
DSECTD   DSECT ,                       DSECT FIELD TABLE ENTRY
DSECT    DS    0CL13
DSOFSET  DS    XL3                     OFFSET TO 1ST BYTE OF FIELD
DSLBTYP  DS    CL1                     LABEL TYPE = L
DSNAME   DS    CL8                     FIELD NAME
DSLENG   DS    XL1                     FIELD LENGTH
*
*
*
DISASM2  CSECT
*
*
*
*
*
*
SVCTBLAD DC    A(SVCOP)                @ SVC TABLE
DBLOPAD  DC    A(DBLOP)                @ TWO-BYTE OP-CODE TBL
OWSTRT   DC    A(OPNDWK)               @ OPERAND WORK AREA
OPND9    DC    A(OPNDRTN)              RETURN ADDR FOR OPERAND ROUTINES
USG12    DS    2F                      REG SAVE AREA
USG9     DS    F                       RETURN SAVE
EQU9     DS    F                       RETURN ADDR FOR EQUSTMT
FC6      DS    F                       SAVE AREA FOR R6
FC9      DS    F                       FORCONST RETURN ADDR
TX9      DS    F                       RETURN ADDR FOR TXTFMT
BD9      DS    F                       RETURN FOR BDADR
BDX9     DS    F                       RETURN FOR BDXADR
BDL9     DS    F                       RETURN FOR BDLADR
SLSAV    DS    4F                      SAVE FOR SCHLBL
SGOPLEN  DC    AL2(L'SGLOP)            SINGLE BYTE OP COD TBL LEN
ILENG    DC    H'0'                    INSTRUCTION LENGTH  FIX***
CONPROG  DC    X'00'                   CONSTANT IN PROGRESS INDIC
CONPSLBL DS    0CL13                   PSEUDO LABEL ENTRY FOR CONSTANTS
         DS    XL4
CONNAME  DS    CL8                     CONSTANT NAME
CONLLEN  DS    XL1                     LABEL LENGTH
CONTYPE  DS    CL1                     TYPE
         DS    0H
CONDATA  DS    XL8                     CONSTANT DATA
CONSYM   DS    CL8                     CONSTANT SYMBOL
CONLEN   DS    H                       CONSTANT LENGTH
CONOFST  DS    F                       RELATIVE OFFSET TO CONSTANT
CONLOC   DS    F                       @ CURRENT BYTE IN CONSTANT
CCTYPE   DC    X'00'                   CC SET TYPE OF INSTR SETTING
TXTOFST  DS    0F
         DS    X
TXTOFSET DS    XL3                     OFFSET TO TEXT BYTE
OPNDWK   DS    CL13                    OPERAND BUILD AREA
OFFSET   DS    XL3                     OFFSET FROM PGM START
INSTYP   DS    CL1                     INSTRUCTION TYPE
TYPE     DS    XL1                     TYPE CODE
*                                       0=CSECT, 1=ADCON, 2=CONST
*                                       E=USING, D=INSTRUCTION
*                                       C=COMMENT, 9=ENTRY
*                                       A=EQU
LEN      DS    XL1                     TEXT LENGTH
TEXT     DS    XL8                     TEXT
H1       DC    H'1'                    CONSTANT 1
H2       DC    H'2'                    CONSTANT 2
H4       DC    H'4'                    CONSTANT 4
H7       DC    H'7'                    CONSTANT 7
H8       DC    H'8'                    CONSTANT 8
H10      DC    H'10'                   CONSTANT 10
H11      DC    H'11'                   CONSTANT 11
H13      DC    H'13'                   CONSTANT 13
H14      DC    H'14'                   CONSTANT 14
H16      DC    H'16'                   CONSTANT 16
H76      DC    H'76'                   CONSTANT 76
H100     DC    H'100'                  CONSTANT 100
H1000    DC    H'1000'                 CONSTANT 1000
P0       DC    P'0'                    CONSTANT 0
P1       DC    P'1'                    CONSTANT 1
P58      DC    P'58'                   CONSTANT 58
BLANX    DC    CL121' '                CONSTANT BLANKS
XZROS    DC    16X'00'                 CONSTANT ZEROS
HIVAL    DC    4X'FF'                  CONSTANT X F'S
NEXCHG   DC    XL3'00'                 OFFSET TO NEXT BASE REG CHG
USGLEN DC AL2(L'USING) LENGTH OF USING TBL ENTRIES
MORUSG   DC    X'00'                   0=NO MORE BASES, 80=MORE BASES A
TRTBL    DC    C'0123456789ABCDEF'     TRANSLATE TBL
PRTABL   DS    CL9                     PRINTABLE HEX WORK
BASES    DC    XL256'00'               BASE REG TABLE
*        TRT TABLE FOR CHAR/HEX DETERMINATION
*        00 FOR VALID CHARACTERS, FF FOR HEX VALUES
*
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
CHARTRAN DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 0
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 1
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 2
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 3
         DC    X'00FFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 4   BLANK AND DOT
         DC    X'FFFFFFFFFFFFFFFFFFFFFF00FFFFFFFF' 5   $
         DC    X'0000FFFFFFFFFFFFFFFFFFFFFF00FFFF' 6   /, -, AND _
         DC    X'FFFFFFFFFFFFFFFFFFFFFF0000FFFFFF' 7   # AND @
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 8
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' 9
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' A
         DC    X'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF' B
         DC    X'FF000000000000000000FFFFFFFFFFFF' C   A-I
         DC    X'FF000000000000000000FFFFFFFFFFFF' D   J-R
         DC    X'FFFF0000000000000000FFFFFFFFFFFF' E   S-Z
         DC    X'00000000000000000000FFFFFFFFFFFF' F   0-9
*                 0 1 2 3 4 5 6 7 8 9 A B C D E F
         LTORG
*
         COPY  DISASM3A                COPY INSTRUCTION TABLES
         COPY  DISASM3B                COPY SVC TABLE
*
         END
