*   DARTH IS  A UTILITY PROGRAM THAT OFFLOADS SYS1.DUMP DATA SETS TO
* TAPE.  IT IS STARTED AS A STARTED TASK BUT CAN RUN AS A BATCH JOB.
* AT WFB IT IS STARTED AS 'S DARTH.VADER'  BY AN OPERATOR COMMAND.
*
*   UPON INITIATION DARTH CHECKS EACH FILE ASSOCIATED WITH THE DDNAME:
* //DARDMP__ (WHERE __ WILL BE DISCUSSED LATER) FOR THE PRESENCE OF A
* DUMP.  WHEN PRESENT, A TAPE FILE AND A CONTROL PDS ARE DYNAMICALLY
* ALLOCATED AND OPENED.    THE TIME STAMP AND DUMP TITLE ARE READ FROM
* THE DUMP AND PLACED IN A NEWLY CREATED MEMBER IN THE CONTROL PDS
* ALONG WITH THE  VOL ID OF THE TAPE HOLDING THE DUMP. THE DUMP IS THEN
* OFFLOADED TO TAPE AND RESET TO EMPTY STATUS.  WHEN ALL DEFINED DUMPS
* HAVE BEEN OFFLOADED, DARTH DEALLOCATES THE TAPE AND CONTROL DATA SETS
* AND DROPS INTO A WAIT STATE FOR 15 MINUTES.   UPON 'WAKING UP, IT
* STARTS THE CHECKING/OFFLOADING CYCLE AGAIN.
*
*   DARTH CAN BE AWAKENED FROM ITS 'SLEEP' BY A OPERATOR MODIFY COMMAND
* AS FOLLOWS:
*
*                     F DARTH,X
*
* WHERE X IS ANY CHARACTER. THE CHECK/DUMP CYCLE IS IMMEDIATELY STARTED
* AFTER WHICH DARTH DROPS INTO ANOTHER 15 MINUTE 'SLEEP' CYCLE.
*
*   THE DUMP DATA SETS ARE DUMPED IN THE ORDER IN WHICH THEY ARE
* DEFINED IN THE JCL.  DUMP DATA SETS MUST APPEAR ON DD STATEMENTS
* BEGINING WITH THE CHARACTERS 'DARDMP' IN A 8 CHARACTER DDNAME.
* CHARACTERS 7 AND 8 CAN BE ANYTHING BUT HAVE A DESIGNATED USE AT WFB.
* CHARACTER 7 IS USED TO IDENTIFY THE SYSTEM THAT ISSUED THE DUMP (AN
* 'A' FOR THE 'A' SYSTEM, A 'B' FOR THE 'B' SYSTEM, ETC). CHARACTER 8
* IS USED TO  IDENTIFY A PARTICULAR DUMP DATA SET  (A '3' FOR DUMP DATA
* SET 'SYS1.DUMP03').  THUS DDNAME //DARDMPB2 SHOULD DEFINE
* 'SYS1.DUMP02' DUMP DATA SET FOR SYSTEM 'B'.
*
* CHARACTERS 7 AND 8 ARE ALSO USED TO BUILD INFORMATION IN THE CONTROL
* DATA SET.   CHARACTER 7 IS USED AS THE FIRST LETTER OF THE MEMBER
* NAME.  THE MEMBER NAME HAS THE FOLLOWING FORMAT:
*
*                   SDDDHHMM
*
* WHERE           S    = SYSTEM IDENTIFIER  ('A' FOR SYSTEM, ETC )
*                 DDD  = JULIAN DAY THE CPU CREATED THE DUMP
*                                   (TAKEN FROM THE DUMP TIME STAMP)
*                 HHMM = HOUR AND MINUTE THE DUMP OCCURRED
*                                   (TAKEN FROM THE TIME STAMP IN THE
*                                   DUMP).
*
* IF THE SAME  MEMBER NAME ALREADY EXISTS IN THE CONTROL DATA SET WHEN
* DARTH ATTEMPTS TO STOW A NEW MEMBER, A '1' IS ADDED TO  THE
* NUMERICAL VALUE OF THE MINUTES FIELD IN THE NEW NAME UNTIL THAT NAME
* IS UNIQUE TO THE DIRECTORY.
*
* AT PRESENT, OLD MEMBERS MUST BE MANUALLY PURGED FROM THE PDS. IF THE
* DIRECTORY IS FULL WHEN DARTH ATTEMPTS TO STOW ANOTHER MEMBER, STOW
* ERROR MESSAGE (IN DECIMAL) ARE DISPLAYED ON THE OPERATOR CONSOLE AND
* THE STOW PROCESS IS BYPASSED. DARTH STILL OFFLOADS THE DUMP TO TAPE
* AND CLEARS THE SYS1.DUMP DATA SET.  WHEN THIS PROBLEM IS DISCOVERED,
* THE USER SHOULD PURGE OLD MEMBERS AND COMPRESS THE DATA SET.
*
* IF THE FIRST RECORD IN THE DUMP DOES NOT START WITH X'FE' IN BYTE 1
* (XA DUMP INDICATOR), DARTH ASSUMES THAT THE DUMP IS TRASHED AND WILL
* USE THE CURRENT TIME AND DATE FROM THE CPU WHERE IT IS RUNNING TO
* BUILD DDDHHMM PORTION OF THE MEMBER NAME.
*
*
*    THE CONTROL PDS MEMBER CONTAINS 2 80 BYTE RECORDS WHOSE CONTENTS
* APPEAR AS FOLLOWS:
*
*
* 023456 A2160650 CPUID=SYSAD1 ×<---  FIRST 50 BYTES OF DUMP TITLE -->×
* TIME:  06.50.50 DATE: 86.216 ×<--- SECOND 50 BYTES OF DUMP TITLE -->×
*
*
* WHERE: 023456   IS THE TAPE VOLID CONTAINING THE OFFLOADED DUMP.
*                 THIS HAS ALWAYS BEEN JUST ONE VOLUME. AT WFB, TAPE
*                 VOL IDS THAT START WITH 0 ARE 3480 TYPE. A T OR 8
*                 ARE 3420 TYPE TAPES. IF TWO VOLUMES WERE PRODUCED,
*                 ONLY THE FIRST VOLUME WOULD BE RECORDED HERE.   THE
*                 TAPE HAS A RETENTION PERIOD OF 7 DAYS. THE DAY THAT
*                 THE TAPE WAS CREATED IS CONSIDERED DAY 1 BY TMS.
*
*        A2160650 IS THE MEMBER NAME OF THIS MEMBER.
*
*        CPUID=   THE 'AD1' IN '=SYSAD1' REPRESENT THE SYSTEM THAT
*                 PRODUCED THE DUMP AND THE DUMP DATA SET TO WHERE IT
*                 WROTE IT.  THE 'A' AND THE '1' WERE EXTRATCED FROM
*                 POSITIONS 7 AND 8 RESPECTIVELY OF THE DDNAME THAT
*                 DEFINED THE DUMP DATA SET.    IN THIS EXAMPLE,  'A'
*                 IN THIS EXAMPLE, 'A' IS SYSTEM 'A' AND 'D1' DUMP
*                 DATA 'SYS1.DUMP01'
*
*        TIME & DATE ARE FROM THE DUMP TIME STAMP, OR THE OFFLOADING
*                 TIME AND DATE AS DISCUSSED ABOVE.
*
*
*  SOME FUTURE REQUIREMENTS CURRENTLY UNDER CONSIDERATION:
*
*    1.  ADD A F DARTH,SUSPEND COMMAND THAT WILL SUSPEND DARTH MORE
*        THAN 15 MINUTES SO THAT A USER CAN 'GRAB' A DUMP FROM DISK
*        BEFORE DARTH DOES.
*
*    2.  ADD A F DARTH,RESUME COMMAND TO REVERSE THE 'SUSPEND'
*        COMMAND.
*
*    3.  ADD CODE THAT WILL AUTOMATICALLY PURGE OBSOLETE MEMBERS.
*        USERS NOW HAVE TO EXAMINE THE HARD COPY LOG TO ASCERTAIN THE
*        VOLID OF THE OFFLOADED TAPE WHEN DARTH CANNOT ADD NEW MEMBERS
*        BECAUSE THE DIRECTORY IS FULL. USER HAS TO 'REMEMBER' TO
*        MANUALLY CLEAN-UP THE DIRECTORY PERIODICALLY.
*
*    4.  ADD CODE TO READ JCL EXECUTE PARM FIELD VALUES.   USER MUST
*        UPDATE THE CODE WHEN VARIABLES LIKE DATA SET NAMES AND TAPE
*        DRIVE TECHNOLOGY CHANGE.
         EJECT
UTDARTH  CSECT
         TITLE 'DARTH - DAMAGE ASSESMENT ROUTINE TAPE HANDLER'
         PRINT ON
*                  - PROGRAM ABSTRACT -
*          DARTH OFFLOADS TO TAPE SVC DUMPS WRITTEN TO SYS1.DUMP__ DATA
*        SETS. CALLS ARE MADE TO PGMS 'DARGETDD' TO EXTRACT DD NAME
*        INFORMATION, 'DARBLDCB' TO BUILD DCBS FOR THE SYS1.DUMP__
*        DATA SETS AND 'DARCONVRT' TO CONVERT THE TIME-OF-DAY CLOCK TO
*        A LEGIBLE DATE AND TIME.  THESE ROUTINES MUST BE LINKED INTO
*        'UTDARTH'. FOR EXAMPLE:
*
*        //        JOBCARD
*        //         EXEC PGM=IEWL, PARM=('IEWL,LIST,XREF,LET')
*        //         DD
*        //         DD
*        //         DD
*        //OLDLMOD  DD
*        //SYSLMOD  DD
*        //SYSLIN   DD  *
*          INCLUDE OLDLMOD(UTDARTH)
*          INCLUDE OLDLMOD(DARCNVRT)
*          INCLUDE OLDLMOD(DARGETDD)
*          INCLUDE OLDLMOD(DARBLDCB)
*          ENTRY UTDARTH
*          NAME UTDARTH(R)
*        /*
*
*          THE OUTPUT TAPE FILE AND A PDS CONTROL DATA SET ARE  DYNA-
*        MICALLY ALLOCATED. THE CONTROL DATA SET CONTAINS THE VOL ID
*        TO WHICH THE SVC DUMP WAS OFFLOAD, THE CPU ID THAT ISSUED THE
*        DUMP, THE DATE AND TIME THAT THE DUMP OCCURED AND THE DUMP
*        TITLE.  THE MEMBER NAMES OF THE PDS HAVE THE FORMAT SDDDHHMM
*        WHERE 'S' IS THE CPU ID THAT GENERATED THE DUMP AND 'DDD' AND
*        'HHMM' ARE THE JULIAN  DAY AND TIME THAT THE DUMP WAS ISSUED.
*
*           USER ABEND CODES FOR THIS CSECT ARE AS FOLLOWS:
*        600   FREEING OF START CIB FAILED.
*        605   CIB NOT A START, MODIFY OR STOP CIB.
*        610   FREEING OF MODIFY CIB FAILED.
*        620   NO RECORDS IN PDS DIRECTORY.
*        670   UNABLE TO DETERMINE WHICH ECB IN A LIST WAS POSTED.
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6                  BASE REG FOR COMMUNICATION DSECT.
R7       EQU   7
R8       EQU   8                  BASE REG FOR CIB DSECT.
R9       EQU   9                  POINTS TO DCB BEING PROCESSED
R10      EQU   10
R11      EQU   11                 HOLDS RETRN ADDRSS FRM BAL INSTRCNS
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         USING UTDARTH,15
ENTRY    B     STORE
         DC    AL1(L'ID)
ID       DC    C'VERSION 5 OF UTDARTH/DARTH-&SYSDATE &SYSTIME'
STORE    STM   14,12,12(13)
         DROP  15
         USING UTDARTH,12,7
         LR    12,15                 SET UP BASE REG
         ST    13,SAVE+4             SAVE SAVEAREA POINTER
         LR    11,13                 SAVE REG 13 FOR STORE
         LA    13,SAVE               GET NEW SAVEAREA ADDRESS
         ST    13,8(11)              STORE NEW SAVEAREA ADDR
         LA    7,4095(12)            SETUP SECOND BASE
         LA    7,1(7)
*
*
*
*        OBTAIN POINTERS TO COMMUNICATON CONTROL BLOCKS AND
*        PROCESS ANY START COMMAND PARAMETERS.  GET EXCLUSIVE
*        CONTROL (ENQUEUE) OF DUMP HISTORY DATA SET.
*
         EXTRACT COMAPTR,'S',FIELDS=(COMM) GET COMMUN AREA ADDR.
         L     R6,COMAPTR             GET PTR TO COMMUNICATION AREA.
         USING COMMAP,R6              ESTBLSH DSECT ADDRSSIBLTY.
         MVC   TWOECBS,COMAECB        PUT COM ECB PTR IN ECB LIST.
         L     R8,COMACIB             LOAD ADDRESS OF CIB POINTER.
         USING CIBMAP,R8              ESTBLSH ADDRSBLTY OF CIB DSECT.
         LA    R8,0(0,R8)             CLEAR FIRST BYTE OF REGISTER.
         LTR   R8,R8                  IF   COMACIB ADDRESS = ZERO
         BZ    CMDLIMIT               THEN BATCHJOB, GO SET CMD LIMIT.
         CLI   CIBVERB,CIBSTART       IF NOT START CIB,
         BNE   CMDLIMIT               THEN GO SET MODIFY CMD LIMITS.
         LH    R10,CIBDATLN           ELSE GET LENGTH OF CIB DATA.
         LTR   R10,R10                IF NO PARMS IN START COMMAND,
         BZ    CIBFREE0               THEN GO FREE THIS CIB.
         BCTR  R10,0                  ELSE DECREMENT VALUE BY ONE.
         EX    R10,CIBMDATA           MOVE DATA TO WORK FIELD.
         LA    R11,CIBFREE0           GET RETRN ADRES AFTR CMD PROCSSNG
         B     CIBBEGIN               GO PROCESS STRT CMDS.
CIBFREE0 DS   0H
         QEDIT BLOCK=(8),ORIGIN=COMACIB  RLSE STRT CIB AND RESET ECB.
         LTR   R15,R15                CHECK RETURN CODE FROM QEDIT.
         BZ    CMDLIMIT               IF RC = 0, THEN SET MODFY LIMTS.
         ABEND 600,DUMP               SOMETHING WRONG, KILL PGM.
CMDLIMIT DS    0H
         QEDIT ORIGIN=COMACIB,CIBCTR=1 SETY MODFY CMD LIMITS TO 1
ENQUEUE  DS    0H
         MVC   $ENQ(16),$ENQL         MOVE ENQ LIST        V 1.4
         ENQ   MF=(E,$ENQ)            ENQ THE DEATHSTAR.
         LTR   15,15                  WAS ENQ SUCESSFUL ?  V 1.4
         BNZ   $ERRENQ                NO...END.....        V 1.4
*
*
*        INITIALIZE PROGRAM PARAMETERS.
*
         MVC   ORRETN+6,RETENPD       ESTBLSH OUTPUT TAPE RETN PERIOD.
         MVC   CONTNAME+6(L'CONTDSN),CONTDSN GET CNTL DATA SET NAME.
*        LA    R1,PDSMNLST            GET PARM LIST FOR PDS MAINTNANCE.
*        CALL  DARPDSMN               INVOKE PDS MAINTENANCE ROUTINE.
*
*        BUILD  DDNAME TABLE AND EXTRACT SELECTED DDNAMES FROM
*        TIOT  CONTROL BLOCK.
*
         GETMAIN R,LV=816             GET MEMRY FOR DDNAME TBLE.
         CALL  DARGETDD               GET DDNAMES. R1= DD NAME TBL.
DDTBLPFX DSECT
NUMBRDD  DS    XL4                    NUMBER OF DD'S PRESENT
DCBADDRS DS    XL4                    PTR TO TABLE OF DCB ADDRESS.
DCBTBL   DS    XL4                    PTR TO TABLE OF DCB'S.
DCBMODL  DS    XL4                    POINTS TO A MODEL DCB.
DDNAMES  DS    XL800                  TABLE OF VALID DDNAMES.
UTDARTH  CSECT
*
*
*        BUILD  DCB LIST AND DATA CONTROL BLOCK (DCB) TABLES.
*
DCBREG   EQU   9                      USE TO REFERENCE DUMP DCBS.
         LR    R2,R1                  SAVE PTR TO DDNAME TBLE PRFIX.
         USING DDTBLPFX,R2            ESTBLSH DSECT  ADDRSSIBLTY.
         LA    R5,MODELDCB            GET ADDRESS OF MODL DCB.
         ST    R5,DCBMODL             SAVE THIS ADDRESS.
         L     R0,NUMBRDD             GET NUMBR OF DCBS TO CREATE.
         MH    R0,=H'100'             COMPUTE NMBR OF BYTS FOR DCBS.
         GETMAIN R,LV=(0)             GET AREA IN SUBPOOL 0, USING R0.
         ST    R1,DCBTBL              GET POINTER TO DCB TABLE.
         LR    DCBREG,R1              GET COPY FOR WORKING USE.
         USING DCBWORK,DCBREG         SETUP DCB DSECT ADDRSIBLTY.
         LA    R4,DCBLIST             GET PTR TO TBLE OF DCB ADDRESSES
         ST    R4,DCBADDRS            SAV THIS POINTER.
         LR    R1,R2                  R1 = PTR TO DDNAME TABLE PREFIX.
         DROP  R2
         CALL  DARBLDCB               BUILD DCBS. R1 = DD NAME TBL.
*
*
*        OPEN  ALL DARTH DUMP DATA SETS AND RELEASE DDNAME TABLE.
*
         LA    1,DCBLIST              GET OPEN DCB LIST POINTER
         SVC   19                     OPEN ALL DUMP DCBS.
         LR    R1,R2                  SETUP FOR FREEMAIN
         FREEMAIN R,LV=816,A=(1)      RLSE DDNAME TABLE.
         WTO   'IJBDARTH  DUMP DATASET MANAGER ACTIVE',ROUTCDE=2
         SPACE 2
***************************************************************
* READ EACH DAR DATA SET TO FIND OUT IF IT HAS BEEN USED.
* IF IT  HAS, DUMP IT TO TAPE AND CLEAR THE DATA SET,
*             CHECK FOR OPERATOR SERVICE REQUEST VIA MODIFY CMD.
* ELSE,       CHECK FOR OPERATOR REQUEST FOR SERVICE
*
* GO BACK TO SENTENCE 1 ABOVE.
***************************************************************
         SPACE 2
STRTCYCL DS    0H
         WTO   'IJBDARTH  CHECKING DUMP DATASETS',ROUTCDE=2 V 1.3
         LA    4,DCBLIST      GET ADDRESS OF START OF DCB LIST
         L     DCBREG,0(4)    GET DCB ADDRESS
OPSERVCE DS    0H
         LA    R11,READ               GET RETURN ADDRESS.
         L     R3,COMAECB             GET PTR TO COMMUNICATION ECB.
         TM    0(R3),B'01000000'      WAS COMMUNICATION ECB POSTED?
         BO    TESTMODF               YES, FIND OUT THE SRVCE DESIRED.
READ     READ  RDAR0,SF,(DCBREG),IOAREA READ RECORD FROM DAR DATASET
         CHECK RDAR0          CHECK READ
*                             IF DATASET EMPTY, CHECK WILL BRNCH TO
*                             LABEL 'POINT0', EODAD PROCESSING.
*                             OTHERWISE PROCESSING WILL CONTINUE BELOW.
         BAL   11,PROCDUMP             GO PROCESS DUMP
*
POINT0   EQU   *
         POINT (DCBREG),START         RESET DCB TO START OF DATASET
         LA    4,4(4)                 GET NEXT DCB POINTER.
         L     DCBREG,0(4)            GET NEXT DCB.
         CLI   0(4),X'FF'             IF NOT AT END OF DCB TBL,
         BNE   OPSERVCE               THEN CHCK FOR REQST FRM OPER.
TIMER    STIMER REAL,ASYNXIT,DINTVL=TIMELIMT  SET TIME AND WAIT ON
         WAIT  1,ECBLIST=TWOECBS,LONG=YES     CLOCK OR MODFY ECB.
         TTIMER CANCEL,TU             CANCEL UNUSED WAIT TIME
         TM    TIMERECB,B'01000000'   IF  TIMER ECB POSTED?
         BO    TIME0800               THEN GO DO SOME WORK.
         LA    R11,TIME0850           GET RETURN ADDRESS
         L     R3,COMAECB             GET PTR TO COMMUNICATION ECB.
         TM    0(R3),B'01000000'      IF OPER REQUEST SERVICE,
         BO    TESTMODF               THEN FIND OUT WHICH SERVICE.
         ABEND 670,DUMP               SOMETHING WRONG, KILL PGM.
TIME0800 MVC   TIMERECB,FRESHECB      REFRESH TIMER ECB.
TIME0850 B     STRTCYCL               GO DO SOME WRK (START THE CYCLE).
*
ASYNXIT  DS    0H
*
*        ASYNCHRONOUS EXIT ENTERED FROM A STIMER POP. IT POST AN
*        ECB COMPLETE INDICATING THAT A TIME PERIOD HAS ELAPSED.
*        ADDRESSABLITY OF DATA REFERENCE IN THE EXIT IS ESTABLISHED
*        BY USING ALL BASE REGISTERS EMPLOYED IN THE MAIN CSECT
*        RATHER THAN ESTABLISHING NEW ONES WITH A USING STATEMENT.
*        THIS  IS ACCOMPLISHED IN THE  FIRST THREE INSTRUCIONS AND
*        THE USE OF AN ADCON
*
*              R15 POINTS TO FIRST INTRUCTION IN THIS EXIT.
*              R15+16 POINTS TO ADCON THAT CONTAINS MAIN CSECT
*                     START LOCATION.
*              R11 POINTS TO RETRN POINT OF CALLING MODULE.
*
*
         SAVE  (14,12)                SAVE REGISTERS
         L     R12,16(R15)            GET MAIN BASE REG ADDRESS.
         LA    R7,4095(0,R12)         GET SECOND BASE ADDRESS.
         B     ASYN0050
         DC    A(UTDARTH)             ADDRESS OF MAIN CSECT.
ASYN0050 DS    0H
         POST  TIMERECB
         RETURN (14,12)               RESTOR REGISTERS AND RETURN.
*
*        END-OF-ASYNCHRONOUS-EXIT
*
*
CIBEND   DS    0H
         WTO    'IJBDARTH - STOP COMMAND ACCEPTED',ROUTCDE=2 V 1.3
         DEQ    RET=NONE,MF=(E,$ENQL)   DEQUEUE DEATH STAR   V 1.4
         L      13,SAVE+4             READY TO GET OUT
         RETURN (14,12),RC=0          LEAVE THE SYSTEM NOW.
CIBBEGIN DS    0H
         WTO   'IJBDARTH START PARAMETERS NOT SUPPORTED.'
         BR    R11                    RETURN TO CALLING SOURCE.
TESTMODF DS    0H
         L     R8,COMACIB             GET ADDRESS OF CIB.
         USING CIBMAP,R8              ESTABLSH CIB ADDRESSIBILTY.
         CLI   CIBVERB,CIBSTOP        IF STOP COMMAND ISSUED,
         BE    CIBEND                 THEN GO TO END ROUTINE.
         ST    R11,TEST0900           SAVE RETURN ADDRESS
         LA    R11,TEST0050           GET NEW RETURN ADDRESS.
         CLI   CIBVERB,CIBMODFY       IF OPER WANTS SERVICE,
         BE    CIBCHNGE               THEN PROCESS THE SERVICE.
         ABEND 605,DUMP               SOMETHING WRONG, KILL PGM.
TEST0050 DS    0H
         L     R11,TEST0900           RESTOR OLD RETRN ADDRESS.
         BR    R11                    RETURN TO CALLING SOURCE.
TEST0900 DS    F                      SAVE AREA, OLD RETRN ADDRESS.
*
CIBCHNGE DS    0H
         WTO   'IJBDARTH MODIFY COMMANDS NOT SUPPORTED.'
         L     R3,COMACIB
         QEDIT BLOCK=(3),ORIGIN=COMACIB  RLSE CIB AND RESET ECB.
         LTR   R15,R15                CHECK RETURN CODE FROM QEDIT.
         BZ    CIBCHN50               IF RC = 0, THEN EXIT
         ABEND 610,DUMP               SOMETHING WRONG, KILL PGM.
CIBCHN50 BR    R11                    RETURN TO CALLING SOURCE.
COMAPTR  DC     F'0'                  PTR TO COMMUNICATION AREA.
COMMAP   DSECT                        COMMUNICATION AREA DSECT.
COMAECB  DS    A                      COMMUNICATION ECB ADDRESS.
COMACIB  DS    A                      COMMUNICATION CIB ADDRESS.
         DS    F                      TOKEN FOR INTRNL STRT COMMNDS.
CIBMAP   DSECT                        COMM INPUT BUFER DSECT, BASE=R8,
         IEZCIB                       IBM SUPPLIED.
UTDARTH  CSECT                        END OF DSECT, RESUME CSECT.
TWOECBS  DS    0F
         DS    A                      CONTAINS COMMUNICATION ECB PTR.
         DC    X'80'                  LAST-ECB-IN-LIST FLAG.
         DC    AL3(TIMERECB)          CONTAINS STIMER ECB PTR.
TIMERECB DC    F'0'                   X'80' =PENDING, X'40'=POSTED
FRESHECB DC    F'0'                   USED TO RE-FRESH ECB.
CIBMDATA MVC  CIBWDATA(0),CIBDATA     XTRCT CIB DATA FOR EDITING.
CIBWDATA DC   4F'0'                   WRK FLD FOR CIB DATA.
         EJECT
PROCDUMP DS    0H
*******************************************************************
* PROCESS DUMP: ALLOCATE AN OUTPUT TAPE FOR THE DUMP.             *
*               ALLOCATE  THE PDS CONTROL DATA SET.               *
*               OPEN THE TAPE OUTPUT DATA SET.                    *
*               OPEN THE CONTROL DATA SET.                        *
*               BUILD CONTRL RECORD AND PDS MEMBER NAME.          *
*               WRITE  CONTROL RECORDS.                           *
*               STOW MEMBER NAME.
*               CLOSE THE CONTROL PDS.                            *
*               OFFLOAD THE DUMP DATA SET TO TAPE.                *
*               RESET THE DUMPED DATA SET.                        *
*               CLOSE DUMP DATA SET.                              *
*               RETURN TO CALLING ROUTINE.
* IF THE TIME AND DATE ARE NOT ABVAILABLE FROM THE DUMP DATA SET, *
* THEN THE CURRENT CPU TIME AND DATE ARE USED TO STORE IN THE     *
* MEMBER AND ITS NAME.                                            *
*******************************************************************
         ST    R11,PROC0050           SAVE RETURN ADDRESS.
         BAL   R11,DYALTAPE           DYNAMIC ALLOCATE A TAPE DRVE.
         BAL   R11,DYALCONT           DYNAMIC ALLOCATE CTL PDS.
         OPEN  (DARTAPE,(OUTPUT))     OPEN OUTPUT TAPE DATA SET.
         RDJFCB DARTAPE
*
*        EXTRACT TIME AND DATE FROM  SVC DUMP
*
         CLI   HDRID,X'FF'         TEST FOR GOOD HEADER RECORD
         BE    CONVTOD             IF GOOD, GOTO CONVERT TOD ROUTNE.
         TIME  DEC                 ELSE GET  CURRNT CPU TIME N DATE.
         SRL   0,4                 REMOVE HUND SEC.
         IC    0,ZONE              FORCE GOOD ZONE
         ST    0,TIMEDAY           STORE TIME AND DATE
         ST    1,DATE
         B     EDITTIME            GO EDIT TIME AND DATE
CONVTOD  LA    1,CONVPARM          GET ADDRESS OF TOD CONVERT LIST
         CALL  DARCNVRT
EDITTIME MVC   EDITFD1,PATTERN1    MOVE EDIT PATTERN
         ED    EDITFD1,TIMEDAY     EDIT TIME TO RECORD
         MVC   EDITFD2,PATTERN2    MOVE EDIT PATTERN
         ED    EDITFD2,DATE        EDIT DATE TO RECORD
*
*        BUILD PDS MEMBER NAME IN FOLLOWING FORMAT: SDDDHHMM
*        WHERE        S   = SYSTEM  ID
*                     DDD = JULIAN DATE
*                     HH  = HOUR
*                     MM  = MINUTE
*
         MVC   DARID(1),91(R9)        MOV SYSTM ID TO MEMBR NAME.
         MVC   DARID+1(3),EDITFD2+6   MOV JUILAN DAY TO MEMBR NAME
         MVC   DARID+4(2),EDITFD1+2   MOV HH TO MEMBR NAME.
         MVC   DARID+6(2),EDITFD1+5   MOV MM TO MEMBER  NAME
*
*        BUILD FIRST RECORD OF PDS MEMBER.
*
         CLI   HDRID,X'FF'            TEST FOR VALID HEADER RECORD
         BE    GOODHDR                BRANCH IF YES
         SR    15,15                     CLEAR R15
         IC    15,KEY1            GET STOR PROTECT KEY FOR THIS RECRD
         SLL   15,4                      MAKE ROOM FOR ZONE
         O     15,ZONECHAR               ADD ZONE CHARACTER
         ST    15,UNPKWORK               STORE VALUE INTO UNPKWORK
         UNPK  TITLKEY,UNPKWORK+2(2)     UNPACK KEY TO TITLE AREA
         SR    15,15                     CLEAR R15
         LH    15,ASID                   GET STOR ASID FOR THIS RECRD
         SLL   15,4                      MAKE ROOM FOR ZONE
         O     15,ZONECHAR               ADD ZONE CHARACTER
         ST    15,UNPKWORK               STORE VALUE INTO UNPKWORK
         UNPK  TITLASID,UNPKWORK+2(2)    UNPACK ASID TO TITLE AREA
         SR    15,15                     CLEAR R15
         L     15,ADDR                   GET STOR ADDR FOR THIS RECRD
         SLL   15,4                      MAKE ROOM FOR ZONE
         O     15,ZONECHAR               ADD ZONE CHARACTER
         ST    15,UNPKWORK               STORE VALUE INTO UNPKWORK
         UNPK  TITLADDR,UNPKWORK         UNPACK ADDR TO TITLE AREA
         MVC   TITLE,TITLE2              MOVE NEW TITLE TO TITLE AREA
         B     TITLETR                   GO TO TITLE TRANSLATE
GOODHDR  MVC   TITLE,DUMPTITL            SAV TITLE FRM DAR DMP DAT SET
TITLETR  TR    TITLE,TRTABLE
         MVC   TAPEID,JFCBVOL            GET VOL LABL OF OUTPUT TAPE
*
*        GET   CURRENT MEMBER 'DARNUMBS'
*
GETDAR#  MVC   CPUID,CPUPT        PUT CPUID INTO 1ST RECRD FRM WRK DCB
*        FIND  CONT1,MEMBER,D  LOCATE DARNUMBS MEMBER IN CONTROL
*        LA    2,CONTDECB      GET ADDRESS FOR READ
*        READ  (2),SF,MF=E     READ IN CURRENT DAR NUMBER RECORD
*        CHECK (2)             CHECK READ
*        CLC   CONTNUM(3),=CL3'NEW'   1ST ENTRY "DARNUMBS" ?
*        BNE   $NOPE                  NOPE.
*        PACK  CONTNUM(3),$FIRST
*        WTO   'IJBDARTH - MEMBER "DARNUMBS" INITIALIZED',ROUTCDE=2
*        B     $ZERO        ZERO THE BASE NUMBER
*$FIRST  DC    CL2'01'      FOR BASE NUMBER (CONSTANT)
*$NOPE   NOP   *
*        UNPK  DAR#,CONTNUM(3) ADD CURRENT DAR NUMBER TO CONTROL RECORD
*        CLC   DAR#,=C'09999' TEST FOR MAX NUMBER
*        BNE   ADDDAR#        BRANCH IF NO
*$ZERO   ZAP   CONTNUM(3),=P'0'   RESET DAR NUMBER TO ZERO
*
*        ADD 1  TO CURRENT DAR NUMBER
*
*ADDDAR# AP    CONTNUM(3),=PL1'1' UPDATE DAR NUMBER CONTROL
*        OI    CONTNUM+2,X'0F'    FORCE GOOD ZONE
*        WRITE (2),SF,MF=E     WRITE DARNUMBS CONTROL RECORD BACK
*        CHECK (2)             CHECK WRITE  UPDATE
*
*        THIS  ROUTINE WRITES THE NEW MEMBER AND UPDATES THE DIRECTRY.
*        IF MEMBR NAME EXIST, 1 IS ADDED TO NAME UNITL IT IS UNIQUE.
*
OPNCONT1 DS    0H
         OPEN  (CONT1,(OUTPUT))       OPEN DAR CNTL DATA SET AS MOD.
         NOTE  CONT1                  GET EOF TTR POINTER.
         ST    1,PDSLIST              SAVE TTR POINTER FOR STOW
         OI    PDSLIST+3,X'0F'        INDICATE 15 HLF WRDS OF USR DATA
*
TESTNAME MVC   TESTMEMN,DARID         MOVE DAR NAME TO BLDL LIST
         BLDL  CONT1,TESTMEMB         SEE IF MEMBER EXIST ALREADY.
         LTR   15,15                  IF CC = 0, MEMBR ALREADY EXITS,
         BZ    ADJUSTNO               THEN CHANGE MEMBER NAME.
         B     WRITEREC               ELSE WRITE MEMBER RECOREDS.
WRKFLD01 DS    PL2                    WORK FLD FOR MEMBR NAME ADJSMNT
WRKUNPCK DS    CL3                    SAME AS ABOVE
ADJUSTNO DS    0H
         PACK  WRKFLD01,DARID+6(2)    GET MINUTES FLD OF MEMBR NAME.
         AP    WRKFLD01,=PL1'1'       ADD ONE TO THIS FIELD.
         OI    WRKFLD01+1,X'0F'       ADJUST THE ZONE.
         UNPK  WRKUNPCK,WRKFLD01      CONVERT TO CHARACTER.
         MVC   DARID+6(2),WRKUNPCK+1  MOV BACK TO MEMBER NAME.
         MVI   DARID+8,C'*'           MOVE IN 'ADJUSTMENT-MADE' FLAG.
         B     TESTNAME               TEST AGAIN.
*
WRITEREC WRITE CONTWRIT,SF,CONT1,TAPEID WRITE FIRST RECORD
         CHECK CONTWRIT               CHECK WRITE.
         WRITE CONTWRT2,SF,CONT1,REC2 WRITE SECOND RECORD
         CHECK CONTWRT2               CHECK WRITE
         MVI   DARID+8,C' '           CLEAR  'ADJUSTMENT-MADE' FLAG.
         MVC   PDSTABLE,DARID         MOV DARID TO MEMBR NAME FOR STOW
         MVC   VOLID,TAPEID           PUT DUMP TAPE ID INTO USR DATA.
         MVC   DUMPNUM,CPUID+4        GET DUMP ID NUMBER
         STOW  CONT1,PDSTABLE         ADD MEMBR TO DAR CONTRL DATASET
         LTR   15,15                  WAS STOW SUCCESSFUL ?
         BZ    CLOSEFLE               YES
         B     GETRC                 NO, GET RETURN AND REASON CODES.
* MSG LENGTH    12345678901234567890123456789012345678
WTOLIST  WTO   'IJBDARTH - STOW FAILED, RC=NN, RS=NN ',ROUTCDE=2,MF=L
WKPACK   DS    0D
         DC    PL8'99'
WKUNPACK DC    3C'N'
GETRC    DS    0H
*        GET RETURN CODE.
         CVD   15,WKPACK
         UNPK  WKUNPACK,WKPACK+6(2)              GET LAST TWO BYTS
         OI    WKUNPACK+L'WKUNPACK-1,X'F0'       ADJST SIGN.
         MVC   WTOLIST+(L'WTOLIST-1+28)(2),WKUNPACK+1
*        GET REASON CODE.
         CVD   R0,WKPACK                         GET REASN COD FRM R0
         UNPK  WKUNPACK,WKPACK+6(2)              GET LAST TWO BYTS
         OI    WKUNPACK+L'WKUNPACK-1,X'F0'       ADJST SIGN.
         MVC   WTOLIST+(L'WTOLIST-1+35)(2),WKUNPACK+1
         WTO   MF=(E,WTOLIST)
CLOSEFLE CLOSE (CONT1,FREE)    CLOSE AND FREE DAR CONTROL DATASET
*
*        THIS  CODE WAS TO SAVE THE DUMP TITLE CARD FOR INPUT TO
*        AMPRDMP BUT WAS NEVER IMPLMENTED.
*
*        OPEN  (DARSYSIN,(OUTPUT)) OPEN DARSYSIN
*        MVI   TITLECD+71,C' ' CLEAR COL 72 OF TITLE CARD
*        PUT   DARSYSIN,TITLECD WRITE AMDPRDMP TITLE CARD TO SYSIN
*        CLOSE DARSYSIN        CLOSE DARSYSIN
*
         L     10,32(DCBREG)   SAVE DCB END OF DATA ADDRESS(EODAD)
         LA    1,COPYCOMP      GET COPY COMPLETE EODAD
         STCM  1,7,33(DCBREG)  STORE INTO DAR DCB
         SPACE 3
*
*        THIS  ROUTINE ACTUALLY WRITES THE DUMP DATASET TO TAPE.
*
DARCOPY  PUT   DARTAPE,IOAREA  WRITE DAR DUMP RECORD TO TAPE
         READ  RDARC,SF,(DCBREG),IOAREA READ NEXT RECORD FROM DAR
         CHECK RDARC           CHECK READ - AT EODAD GO TO COPYCOMP
         B     DARCOPY         GO WRITE RECORD
         SPACE 3
COPYCOMP CLOSE (DARTAPE,FREE)  CLOSE AND FREE OUTPUT TAPE
CLOSEDAR EQU   *
         CLOSE ((DCBREG))      CLOSE DAR DCB
         OPEN  ((DCBREG),(OUTPUT)) RESET DAR DATASET BY HAVING CLOSE
*                                  WRITE END-OF-FILE AT BEGINING
*                                  OF DAR DATA SET JUST PROCESS.
         CLOSE ((DCBREG))
         OPEN  ((DCBREG),(INPUT))  REOPEN DAR DATASET
         ST    10,32(DCBREG)  RESTORE EODAD POINTER IN DCB
         L     R11,PROC0050   LOAD RETURN ADDRS OF CALLING MODULE
         BR    11             RETURN.
PROC0050 DC    F'0'           SAVE ADDRESS OF CALLING MODULE.
         EJECT
DYALTAPE DS    0H
********************************************************************
*                                                                  *
*        DYNAMICALLY ALLOCATE A DUMP  TAPE DRIVE.           /V 1.4 *
*                                                                  *
********************************************************************
         LA    1,DARALLOC             GET A TAPE DRIVE
         DYNALLOC
         LTR   15,15          TEST FOR GOOD ALLOCATE
         BZ    TAPEXIT        BRANCH IF OK
         CLC   DARERROR(2),=X'0210' TEST FOR DSN ENQ PROBLEMS
         BE    $DARWAIT       ISSUE MESSAGE AN WAIT A MIN.. V 1.3
         CLC   DARERROR(2),=X'0484'  DID OPERATOR FAIL REQUEST? V 1.3
         BE    OPERFAIL       YES...NOTIFY AND TRY AGAIN  V 1.3
         CLC   DARERROR(2),=X'0214'  UNITS NOT AVAIL ?    V 1.3
         BNE   DARFAIL        BRANCH IF NO                V 1.3
         WTO   'IJBDARTH-UNIT NOT AVAILABLE FOR DUMP TAPE, WILL RETRY I*
               N 5 MINUTES',ROUTCDE=(2,11)                V 1.3
         B     $TURETRY                                   V 1.3
OPERFAIL WTO   'IJBDARTH-OPERATOR REPLIED TO TAPE ALLOCATION WITH "NO" X
               *RETRY* ',ROUTCDE=(2,11)                   V 1.3
$TURETRY MVC   DARERROR(2),=X'0000'  CLEAR ERROR INDICATOR   V 1.3
         SR    15,15                 CLEAR REG15             V 1.3
         STIMER WAIT,DINTVL=TIME5    WAIT BEFORE RETRY       V 1.3
         B     DYALTAPE              TRY TAPE ALLOCATION AGAIN V 1.3
$DARWAIT WTO   'IJBDARTH WAITING FOR SYS1.DARDUMP DATASET',            X
               ROUTCDE=(2,11)         V 1.3
         STIMER WAIT,DINTVL=TIME2     WAIT TWO MINUTES.
         B     DYALTAPE               GO TRY TO ALLOCATE
DARFAIL  WTO   'IJBDARTH - ALLOCATE FAILED FOR DDN=DARTAPE',ROUTCDE=2
         L     13,SAVE+4             GET SAVE AREA POINTER.
         RETURN (14,12),RC=30
TAPEXIT  DS    0H
         BR    R11                    RETURN TO CALLING SOURCE.
         EJECT
DYALCONT DS    0H
*******************************************************************
*                                                                 *
*         DYNAMICALLY ALLOCATE THE DARTH CONTROL PDS.             *
*                                                                 *
*******************************************************************
         LA    1,CT1ALLOC             GET POINTER TO SVC99 PRAMLIST.
         DYNALLOC                     ALLOCATE DAR CONTROL DATASET
         LTR   15,15                  TEST FOR GOOD ALLOCATE
         BZ    CONTEXIT               BRANCH IF OK
         CLC   CT1ERROR(2),=X'0210'   TEST FOR DSN ENQ PROBLEMS
         BNE   CT1FAIL                BRANCH IF NO
  WTO   'IJBDARTH WAITING FOR SYS3.DARCNTRL            ',ROUTCDE=2 WFB4
         STIMER WAIT,DINTVL=TIME2
         B      DYALCONT              GO TRY AGAIN TO ALLOCATE
CT1FAIL  WTO   'IJBDARTH - ALLOCATE FAILED FOR DDN=CONT1',ROUTCDE=2
         L     13,SAVE+4              GET SAVEAREA POINTER
         RETURN (14,12),RC=34
CONTEXIT BR    R11                    RETURN TO CALLING SOURCE.
         EJECT
$ERRENQ  EQU   *              VERSION 1.4
********************************************************************
*  ENQUEUE PROTECTION TO ALLOW ONLY 1 DARTH ACTIVE IN SYSTEM/V 1.4 *
********************************************************************
MLWTOMSG WTO   ('IJBDARTH-ENQUEUE FAILED                 ',D),         *
               ('        -MAJOR:SYSVADER, MINOR:DEATHSTR ',D),         *
               ('        -RETURN CODE=12    *DARTH*      ',D),         *
               ('        -ONLY ONE COPY OF THE DARTH IS  ',D),         *
               ('        -ALLOWED TO BE ACTIVE AT ONE    ',D),         *
               ('        -TIME. ENQUEUE NAME IN USE !    ',DE),        *
               ROUTCDE=2,DESC=7,MCSFLAG=NOCPY           V 1.4
         L    13,SAVE+4                                 V 1.4
         RETURN (14,12),RC=12                           V 1.4
         TITLE 'DARTEST - DATA AREAS'
         SPACE 2
********************************************************************
* DCBS FOR DARTEST
********************************************************************
         DC    CL8'MODELDCB'
MODELDCB DCB   DDNAME=DUMMMMMY,DSORG=PS,RECFM=F,MACRF=(RP,W),          C
               BLKSIZE=4104,EODAD=POINT0,EXLST=EXITLIST
         DC    CL8'DARTAPE'
DARTAPE  DCB   DDNAME=DARTAPE,DSORG=PS,RECFM=F,MACRF=(PM),             C
               BLKSIZE=4104,EXLST=EXITLIST
*        DC    CL8'DARSYSIN'
*ARSYSIN DCB   DDNAME=DARSYSIN,DSORG=PS,RECFM=FB,MACRF=(PM)
         DC    CL8'CONT1DCB'
CONT1    DCB   DDNAME=CONT1,DSORG=PO,MACRF=(R,W),EODAD=ABEND
         SPACE 2
ABEND    ABEND 620,DUMP               EODAD FOR DD 'CONT1'
********************************************************************
* GENERAL DATA CONSTANTS
********************************************************************
         DC    C'REG SAVEAREA'
SAVE     DC    18F'0'
TIME5    DS    0D
         DC    C'00050000'           ALLC RECOVRY WAIT TIME.
*                HHMMSSTT
TIMELIMT DS    0D
         DC    C'00150000'           WAIT TIME LIMIT:DARTH SLEEP TIME.
*                HHMMSSTH
TIME2    DS    0D                    WAIT FOR DATA SET TIME LIMIT.
         DC    C'00020000'
*                HHMMSSTH
START    DC    A(1)                  RELTV BLK ADDRS FOR POINT MACRO.
         SPACE 2
********************************************************************
* ALLOCATE LIST FOR DDNAME=DARTAPE (FOR DARTEST)
********************************************************************
         DS    0D
         DC    CL8'DARALLOC'
DARALLOC DC    AL1(128),AL3(ORBLK)
         DS    0F
ORBLK    DC    X'14'                  LENGTH OF REQUEST BLOCK
         DC    X'01'                  VERB CODE, X'01'= DSN ALLOCATN.
         DC    X'4000'                FLAGS1,DO NOT USE EXSTING ALLOC.
DARERROR DC    CL4' '                 ERROR CODE AND REASON.
         DC    A(ORTXT)               TEXT POINTERS
         DC    A(0)                   RESERVED.
         DC    X'000000'              FLAGS2, FOR AUTHRZED PGMS ONLY.
ORTXT    DC    A(DARDD)               START OF TEXT POINTERS.
         DC    A(ORDISP)
         DC    A(ORRETN)                                          WFB1
         DC    A(ORNEW)
         DC    A(ORDEV)
         DC    A(ORDSN)
         DC    AL1(128),AL3(ORUNALC)
*
*              KEY     # OF PRM  LEN     PARM VALUE
DARDD    DC    X'0001',X'0001',X'0007',C'DARTAPE'   DDNAME
ORDEV    DC    X'0015',X'0001',X'0004',C'TAPE    '  UNIT TYPE
ORDSN    DC    X'0002',X'0001',X'000C',C'SYS1.DARDUMP'
ORNEW    DC    X'0004',X'0001',X'0001',X'04'        DISP=NEW
ORDISP   DC    X'0005',X'0001',X'0001',X'08'        DISP=KEEP
ORRETN   DC    X'0023',X'0001',X'0002',X'0001'   SEE RETENPRD
ORUNALC  DC    X'001C',X'0000'        FREE DATA SET AFTR CLOSE.
*
RETENPD  DC    X'0007'                7 DAY RETENTION PERIOD
PDSMNLST DS    0F                     POINTER LIST. POINTER TO :
         DC    A(RETENPD)             PTR TO TAPE RETENTION PERIOD.
         DC    A(CONTDSN)             PTR TO CNTRL DATA SET NAME.
         SPACE 2
********************************************************************
* ALLOCATE LIST FOR DAR CONTROL DATASET (FOR DARTEST)
********************************************************************
         DS    0D
         DC    CL8'CT1ALLOC'
CT1ALLOC DC    AL1(128),AL3(CTBLK)
         DS    0F
CTBLK    DC    X'14'
         DC    X'01'          ALLOCATION
         DC    X'4000'
CT1ERROR DC    CL4' ' ERROR AND REASON
         DC    A(CTTXT)
         DC    A(0)
         DC    X'000000'
CTTXT    DC    A(CT1DD)
         DC    A(DISPMD)
         DC    AL1(128),AL3(CONTNAME)
*
*              KEY     # OF PRM  LEN     PARM VALUE
CT1DD    DC    X'0001',X'0001',X'0005',C'CONT1'
DISPMD   DC    X'0004',X'0001',X'0001',X'02' DISP=MOD
CONTNAME DC    X'0002',X'0001',X'002C'
         DC    C'SYS3.DARCNTRL                               ' WFB4
CONTDSN  DC    C'SYS3.DARCNTRL                               '
         SPACE 2
********************************************************************
* DCB EXIT LIST PARMS
********************************************************************
         DS    0F
EXITLIST DC    AL1(128+7),AL3(JFCB)
         DS    0D
JFCB     DC    CL200' '
JFCBVOL  EQU   JFCB+118
         SPACE 2
********************************************************************
* CONSTANTS FOR TITLE CARD AND CONTROL RECORD
********************************************************************
TITLECD  DC    C' TITLE  ''TAPE#'
TAPEID   DC    C'T00000'
         DC    C' '
DARID    DC    C'DAR'
DAR#     DC    C'00000'               IF A '*' FOLLOWS THIS FLD, A TIME
         DC    C' CPUID='             ADJSMNT WAS TO PDS MEMBER NAME.
CPUID    DC    CL6' '                 CONTAINS SYSTEM ID (SYSAD0,ETC)
         DC    C' '
TITLE    DC    CL50' '
         DC    C'  '''
         DC    CL40' '
         SPACE  2
TITLE2   DC    CL50' '
         ORG   TITLE2
         DC    C'STORAGE KEY='
TITLKEY  DC    CL3' ',C' ASID='
TITLASID DC    CL3' ',C' STORAGE ADDR='
TITLADDR DC    CL7' '
         ORG   TITLE2+50
         SPACE 2
********************************************************************
* GENERAL DATA CONSTANTS
********************************************************************
MEMBER   DC    CL8'DARNUMBS'
TESTMEMB DC    H'1',H'58'
TESTMEMN DC    CL8' ',CL50' '
         DS    0F
PDSTABLE DC    CL8' '                 DIRECTORY ENTRY, MEMBERNAME
PDSLIST  DC    F'0'                   TTR AND NBR OF BYTS IN USR DAT
USERDATA DS    0CL30                  USER DATA FIELD IN ISPF FORMAT.
         DC    XL2'0501'              VERSION AND MOD NUMBER.
         DC    XL2'0000'              RESERVED FOR FUTURE USE.
         DC    2XL4'0000000F'         CREATE AND LST MODIFIED DATE
         DC    XL2'0000'              TIME MODIFIED.
         DC    2XL2'0002'             CURRENT AND INITAL SIZE.
         DC    XL2'0000'              MOD.
VOLID    DS    CL6                    TAPE VOL ON WHICH DUMP RESIDES.
DUMPNUM  DS    CL2                    SYS1 DUMP DATA SET NUMBR.
         DC    CL2'  '                TWO BYTE FILLER TO COMPLETE FLD.
ZONE     DC    X'0C'
UNPKWORK DC    F'0'
ZONECHAR DC    F'15'
CONVPARM DC    A(DUMPTIME),A(DATE)    A(INPUT), A(OUTPUT)
DATE     DC    F'0'                   OUTPUT FROM CONVERT ROUTINE
TIMEDAY  DC    F'0'                   OUTPUT FROM CONVERT ROUTINE
REC2     DS    0CL80
         DC    C' TIME:'
EDITFD1  DC    C' 017.30.00'
         DC    C' DATE:'
EDITFD2  DC    C'   77.300'
         DC    CL51' '
PATTERN1 DC    X'402120204B20204B2020'
PATTERN2 DC    X'40202120204B202020'
         READ  CONTDECB,SF,CONT1,CONTIO,MF=L
CONTIO   DC    CL80' '
CONTNUM  EQU   CONTIO
         LTORG
DSN      EQU   X'80'
SYSID    EQU   X'81'
$ENQ     DC    CL16' '                                V 1.4
$ENQL    ENQ   (CP30,R2D2,E,,SYSTEM),RET=USE,MF=L     V 1.4
CP30     DC    CL8'SYSVADER'                          V 1.4
R2D2     DC    CL8'DEATHSTR'                          V 1.4
*        IEFZB4D0                     MACRO  TO LIST SV99 STUFF
*        IEFZB4D2                     ''        ''          ''
DCBWORK  DSECT                        DCB MASK.
DCBLNGTH DS    0XL100                 DCB WORK AREA LENGTH.
RDCB     DS    XL88                   DCB SYSTEM DATA.
CPUPT    DS    CL6                    DCB USER DATA.
         DS    XL(L'DCBLNGTH-(*-DCBLNGTH)) RESERVED FOR FUTURE USE.
UTDARTH  CSECT                        END OF DSECT.
DCBLIST  DC    99F'0'
TRTABLE  DC    CL193' ',C'ABCDEFGHI       JKLMNOPQR        STUVWXYZ'
         DC    C'      0123456789ABCDEF'
         ORG   TRTABLE+97
         DC    C'/'
         ORG   TRTABLE+126
         DC    C'='
         ORG   TRTABLE+256
**********************************************************************
*
*  THIS CODE DEFINES THE DUMP HEADER AND TITLE RECORD (FROM AMDSADMP)
*  'IOAREA'  IS ORG'ED OVER THIS AREA CAUSING THE CONSTANTS TO BE
*  LOST  AFTER  THE FIRST READ OF A DUMP DATA SET.
*
**********************************************************************
DUMPRCD  DS    0F
HDRID    DC    XL1'FF'   HEADER ID    HEADER ID
RECID    DC    XL1'FF'   RECORD ID    RECORD ID
ASID     DC    XL2'0000'              ASID BEING DUMPED
DUMPNAME DC    CL8'AMDSADMP'          NAME OF DUMP PROGRAM
DUMPTIME DC    F'0'                   TITEL OF DUMP
DUMPDATE DC    F'0'                   DATE OF DUMP
DUMPTITL DC    25CL4' '               TITLE OF DUMP
DUMPCSW  DC    2F'0'                  CSW AT TIME OF DUMP
DUMPCAW  DC    F'0'                   CAW AT TIME OF DUMP
*
KEY1     EQU   HDRID                  STORAGE
KEY2     EQU   RECID                  STORAGE
ADDR     EQU   DUMPNAME               ADDRESS BEING DUMPED.
STAFLAGS EQU   ASID                   RECORD FLAGS
RESERVD  EQU   ASID+1                 RSVD FIELD
CPUADDR  EQU   DUMPNAME+2             CPU BEING DUMPED
HEADLNGH EQU   DUMPTITL+68         SET UP FOR DUMP TITLE LENGTH
**********************************************************************
         ORG   DUMPRCD
IOAREA   DC    42XL100'00'
         END
TITLE    TITLE 'DARTH BUILD DCB ENTRIES '
*
*        THIS ROUTINE IS LINKED INTO PROGRAM 'UTDARTH'. ITS FUNCTION
*        IS TO BUILD A TABLE OF DCBS FROM A TABLE OF DDNAMES PASSED TO
*        IT FROM THE CALLING PROGRAM AND CONTROL INFORMATION USED BY
*        'UTDARTH'
*
*
*        R1    POINTS TO DDNAME TABLE PREFIX OR DD NAME  ENTRY.
*        R2    POINTS TO  BYTE 7 IN   DDAME.
*        R4    POINTS TO TABL OF DCB  ADDRESSES.
*        R5    POINTS TO A MODEL DCB  USED TO BUILD WRKING DCBS.
*        R8    LOOP COUNTER (# OF VAL ID DCBS).
*        R9    POINTS TO CURRENT DCB  IN DCB TABLE
*        R10   WORK REG, COPY OF R1.
*        R12   PGM BASE REGISTER.
*        R13   PTR TO THIS MODULS SAVE ADDRESS.
*
*
*
*
*
*
DARBLDCB CSECT
*
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
*
         PRINT ON
         STM   14,12,12(13)
         LR    12,15                  SET UP BASE REG
         USING DARBLDCB,12            ESTABLISH ADDRSIBLITY
         ST    13,SAVE+4              SAVE SAVEAREA POINTER
         LR    11,13                  SAVE REG 13 FOR STORE
         LA    13,SAVE                GET THIS CSECT'S SAVEAREA ADDR
         ST    13,8(11)               STORE NEW SAVEAREA ADDR
*
DDTBLPFX DSECT
NUMBRDD  DS    XL4                    NUMBR OF DDS PRESENT
DCBADDRS DS    XL4                    PTR TO TABLE  OF DCB ADDRSSES.
DCBTBL   DS    XL4                    PTR TO DCB TABLE.
DCBMODL  DS    XL4                    POINTS TO A MODEL DCB.
DDNAMES  DS    XL800                  TABLE OF DD NAMES.
DARBLDCB CSECT
         LR    R10,R1                 SAV POINTR TO DD NAME TBL PRFIX.
         USING DDTBLPFX,R1            ESTABLSH DSECT ADDRSIBLTY
         L     R8,NUMBRDD             GET NUMBR OF DCBS FOR LOOP
         L     R4,DCBADDRS            GET PTR TO DCB ADDRESS TABLE.
         L     R9,DCBTBL              GET POINTR TO DCB TABLE
         L     R5,DCBMODL             GET POINTR TO MODEL DCB.
         DROP  R1                     FINISH WITH DSECT
*
WORKDCB  DSECT
DCBAREA  DS    XL88                   ACTUAL DCB USED IN OPN/CLSE ETC.
DUMPTYPE DS    CL5                    DUMP IDENTIFER; SYSG,SYSA, ETC.
DUMPNMBR DS    CL1                    DUMP NUMBER, 0, 1, 2, ETC.
DARBLDCB CSECT
*
         USING WORKDCB,R9             ESTBLSH ADDRBLTY FOR DCB.
         LA    R1,16(0,R1)            POINT TO FIRST DDNAME.
BUILDDCB DS    0H
         ST    R9,0(4)                SAVE PTR TO THIS DCB FOR OPEN.
         MVI   0(4),X'00'             INDICATE 'OPEN,INPUT' DCB
         MVC   DCBAREA,0(R5)          SET UP WORKING DCB.
         MVC   DCBAREA+X'28'(8),0(R1) MOVE DDNAME TO WORKING DCB.
         LR    R2,R1                  WORKING POINTR TO DD NAME ENTRY
         LA    R2,6(0,R1)             POINT TO 7 BYTE IN DDNAME
         CLC   0(1,R2),=C'$'          IF NOT A CICS INDICATOR
         BNE   NOTCICS                THEN GO TO NXT ROUTINE
         MVC   DUMPTYPE,=C'CIC$D'     ELSE MOV IN DUMP IDENTIFIER
         MVC   DUMPNMBR,1(R2)         AND DUMP NMBR, BYT 8 IN DDNAME.
         B     BUILDXIT               EXIT TO LOOP THRU AGAIN.
NOTCICS  DS    0H
         MVC   DUMPTYPE(3),=C'SYS'    MOV IN DUMP IDENTIFIER
         MVC   DUMPTYPE+3(1),0(R2)    MOV IN CPU  IDENTIFIER
         MVC   DUMPTYPE+4,=C'D'       MOV IN 'DUMP' INDICATOR
         MVC   DUMPNMBR,1(R2)         MOVE IN DUMP NUMBER.
BUILDXIT DS    0H
         LA    R1,8(0,R1)             POINT TO NXT DD NAME IN TBL
         LA    R4,4(0,R4)             POINT TO NXT DCB TBL ADDRESS.
         LA    R9,100(0,R9)           POINT TO NXT WRK DCB IN TBL.
         BCT   R8,BUILDDCB            REDUCE LOOP BY 1.
         MVI   0(4),X'FF'             SET END OF DCB LIST FLAG.
         S     R4,FOUR                BACK UP PTR TO LAST DCB POINTER.
         OI    0(R4),X'80'            INDICATE LAST DCB FOR OPEN SVC.
         L     R13,SAVE+4             RESTOR CALLR'S SAVE ADDR.
         RETURN (14,12)               RETURN TO CALLER.
*
SAVE     DC    18F'0'
FOUR     DC    01F'4'
         END
DARCNVRT CSECT
*        THIS MODULE RECEIVES CONTROL FROM A    CALLING MODULE THAT
*        PASSES IT A POINTER VALUE IN REGISTER ONE. THE VALUE POINTS
*        TO A FIELD OF TWO WORDS, EACH OF WHICH CONTAINS A POINTER
*        VALUE TO A DATA FIELD.   THE FIRST DATA FIELD IS A DOUBLE-
*        WORD  AND IS INPUT TO THIS PROGRAM. THIS DOUBLE WORD
*        CONTAINS THE  TOD CLOCK EXTRACTED FROM THE DUMP HEADER OF AN
*        SVC OR STANDALONE DUMP.
*                THE SECOND DATA FIELD IS A DOUBLEWORD IN WHICH THE
*        FIRST WORD WILL CONTAIN A DATE CONVERTED FROM THE TOD CLOCK.
*        THE SECOND DATA FIELD WILL CONTAIN THE TIME ALSO CONVERTED
*        FROM  THE TOD CLOCK.
*
         USING DARCNVRT,15
         B     STORE
         DC    AL1(L'ID)
ID       DC    C'TOD CONVERT - JACK JACKSON - 4/20/77'
         DROP  15
         USING DARCNVRT,12
STORE    STM   14,12,12(13)   SAVE CALLING REGS
         LR    12,15          SETUP BASE REG
         ST    13,SAVE+4      SAVE CALLING SAVEAREA POINTER
         LA    13,SAVE        SETUP NEW SAVE AREA
         LM    2,3,0(1)       SET BASE FOR TOD VALUE AND DATE AND TIME
         USING TODPARM,2
         USING DATETIME,3
         L     1,TOD+4        GET LO32 BITS INTO REG1
         LM    14,15,TOD      GET TOD VALUE TO CONVERT
         SRDL  14,25
         D     14,DAYSFACT
         AL    15,LOGONE
         SLL   15,2           MULTI DAYS BY 4
         LR    0,14           SAVE NUMBER OF SECS SINCE MIDNIGHT
         SR    14,14          ZERO 14 FOR DIV.
         D     14,DAYS4YRS
         SRL   14,2
         LTR   15,15          TEST FOR YEAR 1900
         BZ    YEAR1900       BRANCH IF YES
         AL    14,LOGONE
         LR    7,15
         MH    7,K1000
         LR    15,7
YEAR1900 ALR   15,14
         CVD   15,CVDWORK     DATE
         OI    CVDWORK,X'0F'
         MVC   DATE,CVDWORK+4 MOVE DATE TO DATE RETURN AREA
**** GET TIME
         SLL   1,7
         SRDL  0,19
         D     0,MICSSEC
         SR    0,0
         D     0,SECSMIN
         LR    14,0
         SR    0,0
         D     0,MINSHOUR
         LR    7,0
         MH    7,K100
         ALR   7,14
         LR    6,1
         MH    6,K10000
         ALR   7,6
         CVD   7,CVDWORK     DATE
         OI    CVDWORK+7,X'0F'
         MVC   TIME,CVDWORK+4
         L     13,SAVE+4
         LM    14,12,12(13)
         SR    15,15
         BR    14
CVDWORK  DC    D'0'
SAVE     DC    18F'0'
LOGONE   DC    F'1'
DAYSFACT DC    F'10546875'
DAYS4YRS DC    F'1461'
MICSSEC  DC    F'1000000'
SECSMIN  DC    F'60'
MINSHOUR DC    F'60'
K10000   DC    H'10000'
K1000    DC    H'1000'
K100     DC    H'100'
TODPARM  DSECT
TOD      DC    D'0'
DATETIME DSECT
DATE     DC    PL4'0'
TIME     DC    PL4'0'
         END
TITLE    TITLE 'DARTH GET DDNAMES'
DARGETDD START
*
*        THIS ROUTINE IS LINKED WITH PROGRAM 'UTDARTH'  AND IS USED
*        TO BUILD A TABLE OF VALID DDNAMES. EACH DDNAME IS ASSOCIATED
*        WITH A SYS1.DUMP DATA SET DEFINED IN THE JOBS JCL.
*
*        THE ROUTINE  CAN BREAK WITH  A USER CODE FOR THE FOLLOWING
*        REASONS;
*
*               USER 004, NO DD'S FOUND THAT START WITH //DARDMP
*               USER 008, DUPLICATE '//DARDMP' DD'S ENCOUNTERED.
*               USER 012, //DARDMP  DD NOT 8 CHARACTRS LONG.
*               USER 016, OVER 99 '//DARDMPNN'  DD'S FOUND.
*
*
*
*
*
R0       EQU   0
R1       EQU   1                      POINTS TO DDNAME TABLE  PREFIX
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11                     RETRN ADDRSS FRM BAL INSTRCTNS.
R12      EQU   12                     PGM BASE REGISTER
R13      EQU   13                     POINTER TO THIS PGMS'S SAVE AREA
R14      EQU   14
R15      EQU   15
*
         PRINT ON
         STM   14,12,12(13)
         LR    12,15                  SET UP BASE REG.
         USING DARGETDD,12            ESTABLISH ADDRSIBLITY.
         ST    13,SAVE+4              SAVE SAVEAREA POINTER.
         LR    11,13                  SAVE REG 13 FOR STORE.
         LA    13,SAVE                GET THIS CSECT'S SAVEAREA ADDR.
         ST    13,8(11)               STORE NEW SAVEAREA ADDR.
         BAL   R11,GETDDNME           R1 = FRST DD TABL ENTRY.
         BAL   R11,VALDDNME           VALIDATE DDNAMES EXTRACTED.
*        BAL   R11,WTOCONT1           FOR TESTING. WTO THE CNT OF DD'S
         L     R13,SAVE+4             RESTOR CALLR'S SAVE ADDR.
         RETURN (14,12)               RETURN TO CALLER.
*
GETDDNME DS    0H
*
* R1           EQUALS  1              POINTS TO DDNAME TBL PRFIX.
* R3           EQUALS  3              POINTS TO A DD NAME TBL ENTRY.
* R4           EQUALS  4              LOOP COUNTER TO STEP THRU TIOT
* R5           EQUALS  5              BASE REG FOR TIOT DSECT.
* R6           EQUALS  6              CONTAIN # OF DD'S EXTRACTED
* R11          EQUALS 11              CALLING MODULS RETURN ADDRESS
* R12          EQUALS 12              PGM BASE REGISTER
*
TIOTDD   DSECT
TIOTLNGH DS    1X,3X
TIOEDDNM DS    CL8
DARGETDD CSECT
*
         LA    R4,1635                SET R4 TO # OF LOOPS TO EXECUTE.
         XR    R6,R6                  SET R6 TO ZERO
         LR    R2,R1                  SAVE R1 CONTENTS FOR BACKUP.
         LA    R3,16(0,R1)            POINT TO FIRST DDNAME TBL ENTRY.
         EXTRACT TIOTPTR,'S',FIELDS=(TIOT) GET PTR TO TIOT (USES R1).
         LR    R1,R2                  RESTORE R1.
         L     R5,TIOTPTR             GET ADDRESS OF TIOT
         LA    R5,24(0,R5)            POINT TO 1ST TIOT DD ENTRY.
         USING TIOTDD,R5              ESTBLISH DSECT ADDRSIBLTY
TESTIOT  DS    0H
         CLI   TIOTLNGH,X'00'         IF END OF TIOT
         BE    TIOTEND                THEN EXIT LOOP
         CLC   TIOEDDNM(6),=C'DARDMP' ELSE TEST FOR DDNAME PREFIX.
         BNE   GETNXTDD               IF NOT EQUAL THEN SKIP AROUND.
         MVC   0(8,R3),TIOEDDNM       ELSE XTRACT DDNAME FROM TIOT,
         LA    R3,8(0,R3)                  ADJST PTR TO NXT TBL ENTRY,
         LA    R6,1(0,R6)                  INCRMNT NUM OF DD'S XTRCTD,
GETNXTDD LA    R5,20(0,R5)            ADJST DSECT PTR TO NXT ENTRY.
         BCT   R4,TESTIOT             REPEAT CYCLE
         DROP  R5
TIOTEND  LTR   R6,R6                  IF # OF DD'S XTRACTED IS ZERO
         BZ    TIOERROR               THEN THERE IS AN ERROR
         ST    R6,0(0,R1)             STOR NUM OF DD'S XTRCTD,
         BR    R11                    AND  RETURN TO CALLING MODULE.
TIOERROR WTO   'IBJDARTH NO ''//DARDMP__'' DD''S FOUND, ABENDING'
         ABEND 004,DUMP,,USER
TIOTPTR  DC    F'0'
         EJECT
VALDDNME DS    0H
*
*        THIS  CODE CHECKS FOR DUPLICATION OF DDNAMES
*
*    DDNAME ENTRIES IN THE DDNAME TABEL  ARE COMPARED AGAINST EACH
*    OTHER FOR DUPLICATION.   ASSUME THAT  THE FOLLOWING 4 DDNAMES
*    EXIST IN THE TABLE: A, B, C AND D. THE COMPARSION PROCEDES AS
*    FOLLOWS; A IS COMPARED AGAINST B, THEN C AND FINALLY D.  B IS
*    THEN COMPARED AGAINST C, THEN D.   C  IS  COMPARED AGAINST D.
*    THE FIRST DUPLICATION CAUSES THE PROGRAM TO ABEND WITH A USER
*    008.
*
*
*  R1          EQUALS  1              POINTS TO DDNME TBLE PRFEX.
*  R2          EQUALS  2              LIMIT CTL VARIABL FOR OUTR LOOP
*  R3          EQUALS  3              LIMIT CTL VARIABL FOR INNR LOOP.
*  R4          EQUALS  4              POINTS TO DDNAME ENTRY TBL(I).
*  R5          EQUALS  5              POINTS TO DDNAME ENTRY TBL(I+8).
*  R6          EQUALS  6              CONTAIN # OF DD'S EXTRACTED.
*  R7          EQUALS  7              2ND BASE REGISTER.
*  R11         EQUALS 11              RETURN ADDRESS.
*  R12         EQUALS 12              PGM BASE REGISTER.
*
*
*
         LA    R1,16(0,R1)            POINT FORWD TO FRST DDNAME,
         C     R6,=F'1'               IF ONLY 1 DDNAME IN TABLE,
         BE    VALDLNGH               THEN GO TO NXT VALIDATN ROUTN.
         C     R6,=F'99'              IF OVER 99 DD'S IN TABLE,
         BH    VALMAXER               THEN GO TO MAX ERR ROUTINE
         LR    R2,R6                  ELSE GET WRK COPY OF # OF DD'S
         BCTR  R2,0                   FOR OUTR LOOP AND REDUCES BY 1.
         LR    R3,R2                  GET INNER LOOP COUNTER.
         LR    R4,R1                  GET PTR TO DDNME TBL ENTRY.
         LR    R5,R1                  GET PTR TO DDNME TBL AND ADJST
         LA    R5,8(0,R5)             TO NXT ENTRY.
VALOOP1  EQU   *
         CLC   0(8,R4),0(R5)          IF DD NAMES ARE EQUAL
         BE    VALDUPER               THEN DUPLICATION ERROR EXIST.
         LA    R5,8(0,R5)             ELSE POINT TO NXT DD ENTRY.
         BCT   R3,VALOOP1             REDUCE INNR LOOP CONT AND RETEST
         LR    R3,R2                  WHEN DONE, RESET INNR LOOP COUNT
         LA    R4,8(0,R4)             ADJST OUTR LOOP DD ENTRY PTR.
         LR    R5,R4                  RESET INNR LOOP DD ENTRY PTR.
         LA    R5,8(0,R5)             ADJST INNR DD PTR TO NXT ENTRY.
         BCT   R2,VALOOP1             REDUCE OUTR LOOP CONT & REPEAT
         B     VALDLNGH               WHEN DONE, GO TO NXT VALDATN RTN
VALDUPER DS    0H
         MVC   VALEMSG8+(L'VALEMSG8-1+11)(8),0(R5) MV IN BAD DD TO MSG.
         WTO   MF=(E,VALEMSG8)
         ABEND 008,DUMP,,USER
VALEMSG8 WTO   'IJBDARTH ''DDDDDDDD'' IS A DUPLICATE DD, ABENDING',ROUTX
               CDE=2,MF=L
*
VALMAXER DS    0H
         WTO   'IJBDARTH OVER 99 DUMP DATA SETS PRESENT, ABENDING',ROUTX
               CDE=2
         ABEND 016,DUMP,,USER
         EJECT
*
*
*        THIS  CODE CHECKS FOR 8 CHARACTER DDNAMES AND ABENDS WITH A
*        USER  012 ABEND CODE WHEN THE FIRST NON 8 CHAR DD IS FOUND.
*
*
*
*  R1          EQUALS  1              BASE POINTR TO TBL OF DDNAMES.
*  R2          EQUALS  2              POINTS TO 7TH BYTE OF DDNAME.
*  R3          EQUALS  3              CAN POINT TO BYT 7 OR 8 OF DDNME
*  R4          EQUALS  4              CONTAINS LIMIT OF INNR LOOP.
*  R5          EQUALS  5              CONATINS LIMIT OF OUTR LOOP.
*  R6          EQUALS  6              CONTAIN # OF DD'S EXTRACTED.
*  R7          EQUALS  7              2ND BASE REGISTER.
*  R11         EQUALS 11              RETURN ADDRESS.
*  R12         EQUALS 12              PGM BASE REGISTER.
*
*
*
VALDLNGH DS    0H
         LR    R2,R1                  GET POINTER TO DD NAME TABLE
         LA    R2,6(0,R2)             THEN POINT TO THE 7TH BYTE.
         LR    R3,R2                  GET A COPY OF THIS ADDR.
         LA    R4,2(0,0)              SET INNER LOOP CTL VARIBLE LMIT.
         LR    R5,R6                  SET OUTER LOOP CTL VARIBLE LMIT.
VALOOP2  DS    0H
         CLC   0(1,R3),=X'40'         IF BYTE 7 OR 8 BLANK,
         BE    VALNGHER               THEN THER IS AN ERR, EXIT.
         LA    R3,1(0,R3)             ELSE POINT TO NEXT BYTE.
         BCT   R4,VALOOP2             DECRMNT CONTR AND TEST NXT BYT
         LA    R2,8(0,R2)             POINT TO BYTE 7 OF NXT DDNAME.
         LR    R3,R2                  GET A COPY OF THIS ADDR.
         LA    R4,2(0,0)              RESET INNER LOOP LIMIT.
         BCT   R5,VALOOP2             DECRMNT OUTR LOOP VARIABLE.
         S     R1,=F'8'               POINT BCK TO DDNAME TBL PREFIX.
         ST    R6,0(R1)               SAVE # OF DDNAMES EXTRACTED.
         BR    11                     RETURN.
VALNGHER DS    0H
         S     R2,=F'6'               SET PTR TO STRT OF DD IN ERROR.
         MVC   VALEMSGC+(L'VALEMSGC-1+11)(8),0(R2) MV DDNAME TO MGS.
         WTO   MF=(E,VALEMSGC)
         ABEND 012,DUMP,,USER         ABEND.
*               1234567890 1
VALEMSGC WTO   'IJBDARTH ''D       '' DD IS NOT 8 CHARACTERS LONG, ABENX
               DING',ROUTCDE=2,MF=L
         EJECT
WTOCONT1 DS    0H
*
*        THE FOLLOWING INSTRUCTIONS ARE USED FOR TEST PURPOSES TO
*        DISPLAY HOW MANY DD'S  WERE EXTRACTED. PGM CONTROL IS DIRECTD
*        HERE THROUGH A BAL INSTRUCTION WHICH IS NOW COMMENTED OUT.
*        R11 CONTAINS THE RETURN ADDRESS.
*
         CVD   R6,PACKED
         UNPK  UNPACKED,PACKED+5(L'UNPACKED)
         OI    UNPACKED+(L'UNPACKED-1),X'F0'
         MVC   WTOLIST1+(L'WTOLIST1-1+10)(L'UNPACKED),UNPACKED
         WTO   MF=(E,WTOLIST1)
         BR    R11                    RETURN TO CALLER.
WTOLIST1 WTO   'IJBDARTH NNN DD''S EXTRACTED',MF=L (L' OF WTOLIST1=4)
PACKED   DC    D'0'
UNPACKED DC    CL3'999'
*
SAVE     DC    18F'0'
*
         END
