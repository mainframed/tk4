/*REXX*/ 
/*****************************************************************/
/*  IOAPFP: REXX program to create APF programs database.        */
/*    Note: Developed and tested on an MVS/SP 2.2.3 system.      */
/*****************************************************************/
/* MVS DATA AREAS:                                               */
/*                CVT - Communications Vector Table (@'10'x)     */
/*             APFTAB - Undocumented in MVS DATA AREAS book.     */
/*                                                               */
/*                                                               */
/*                                                               */
/*****************************************************************/
@cvt = STORAGE(10,4)                  /* get CVT address from PSAAOLD */
@cvt = D2X(C2D(@cvt))                    /* binary to hex             */
@cvtauthl = STORAGE(D2X(X2D(@cvt)+484),4)   /* get CVTAUTHL address   */
@cvtauthl = D2X(C2D(@cvtauthl))                /* binary to hex       */
apfcount  = C2D(STORAGE(D2X(X2D(@cvtauthl)+1),1)) /* APF libraries    */
apfllen   = C2D(STORAGE(D2X(X2D(@cvtauthl)+2),1)) /* length 1st entry */
@apfentry = X2D(@cvtauthl)+3          /* address of 1st APF entry     */
Say 'The CVT  is located at '@cvt '('X2D(@cvt)')'
Say 'The CVTAUTHL field points to '@cvtauthl '('X2D(@cvtauthl)')'
Say 'The APF table contains 'apfcount 'entries, as follows:'
Say ' '
lpadsn = 'NO'                /* SYS1.LPALIB is APF during NIP and not */
lpares = '  '                 /* normally in the APF table.  If it is */
                                 /* then must test for sysres volume. */
Do i = 1 to apfcount                            /* loop thru storage  */
   apflib.i = STORAGE(D2X(@apfentry),apfllen)   /* get the APF entry  */
   @apfentry = @apfentry + apfllen + 1          /* bump to next entry */
   apfllen = C2D(STORAGE(D2X(@apfentry-1),1))      /* length of next  */
   If i = 1 Then resvol = SUBSTR(apflib.i,1,6)       /* retain resvol */
   If SUBSTR(apflib.i,7) = 'SYS1.LPALIB' Then Do  /* check for LPALIB */
      lpadsn = 'YES' ; lpares = 'NO'
      If SUBSTR(apflib.i,1,6) = resvol Then lpares = 'YES'
      End
End
/***************************************************************/
/* The in-storage APF table has been fetched, now print it     */
/***************************************************************/
Say 'VOLSER --------------DATA SET NAME-----------------'
Say ' '
Do i = 1 To apfcount                            /* print the list     */
   Say SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i
End
/***************************************************************/
/* Save the APF table to a data set                            */
/***************************************************************/
Address TSO
dsn1 = 'MS01.CONYERS.APFLIST.DATA.WORK'
"ALLOC F(APFLIST) DA('"dsn1"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOAPFP failed on 'dsn1' error: 'RC
   Exit
   End
Newstack 
Do i = apfcount To 1 By -1                      /* write the list */
   Push ' 'SUBSTR(apflib.i,1,6) SUBSTR(apflib.i,7,44,' ') i
End
Push ' APFCOUNT: 'RIGHT(apfcount,4,0)'   Date: 'DATE()'   Time: 'TIME()
Queue
'EXECIO * DISKW APFLIST ( FINIS'
Delstack 
Say ' '
Say 'Saved APF table to DASD'
Say 'DSN: 'dsn1
Say 'Return Code: 'RC
"FREE F(APFLIST)"
Say ' '
/***************************************************************/
/* Now process the directory blocks of each APF library        */
/*   and save the member data to a data set.  Note that        */
/*   when we dynamically allocate each PDS, we are defining    */
/*   DCB parameters to enable reading the directory blocks.    */
/***************************************************************/
dsn2 = 'MS01.CONYERS.APFPGMS.DATA.WORK'
"ALLOC F(APFPGMS) DA('"dsn2"') OLD RELEASE"
If RC \= 0 Then Do
   Say 'IOAPFP failed on 'dsn2' error: 'RC
   Exit
   End
/***************************************************************/
/*   Add SYS1.LPALIB on sysres if not in APF list.             */
/***************************************************************/
If lpadsn = 'NO' | (lpadsn = 'YES' & lpares \= 'YES') Then Do
   Say '*** SYS1.LPALIB on sysres appended to list for programs analysis.'
   Say '         Reason:  lpadsn='lpadsn'  lpares='lpares
   Say '    Explanation:  SYS1.LPALIB on the sysres volume is APF'
   Say '                    authorized by MVS design during IPL.  It'
   Say '                    is added to the APF list for authorized'
   Say '                    programs analysis if not already contained'
   Say '                    in the APF table.  If a SYS1.LPALIB is on'
   Say '                    the APF table, a check is made for its'
   Say '                    volser.  If not the sysres volume, it is'
   Say '                    added to the APF list accordingly for the'
   Say '                    authorized programs analysis.'
   Say ' '
   apfcount = apfcount + 1
   apflib.apfcount = resvol'SYS1.LPALIB'
   End
totpgms = 0
Say 'Beginning APF library contents analysis'
Say '===> note any TSO allocation error messages for skipped libraries'
Say ' '
Do i = 1 To apfcount                            /* cycle the list */
   dsn = STRIP(SUBSTR(apflib.i,7,44))
   vol = STRIP(SUBSTR(apflib.i,1,6))
Say ' '
   Say RIGHT(i,3,0)'  Processing 'dsn' on 'vol'  Mark: 'DATE() TIME()
   "ALLOC F(PDS) DA('"dsn"') VOL("vol") SHR DSORG(PS) RECFM(F) LRECL(256) BLKSIZE(256)"
   RC1 = RC
   'EXECIO * DISKR PDS ( FINIS STEM line.'
   RC2 = RC
   "FREE F(PDS)"
   Say '       *** ALLOC RC: 'RC1'  EXECIO RC: 'RC2
   If RC2 = 0 Then Do
      Say '       *** Directory blocks read: 'line.0
      Newstack
      last = 0  /* flags when no more members indicator is detected */
      memcount = 0
      Do j = 1 To line.0
         blocklen = X2D(C2X(SUBSTR(line.j,1,2))) /* Not proud of this logic, */
         If blocklen = 0 or last = 1 Then Leave /* but seems to work --vlc  */
         ix = 3                          /* Initialize DIRBLOCK parse index */
         Do While ix < blocklen & last \= 1          /* parse this DIRBLOCK */
            pds2ftb1 = '00'x                         /* initialize apf not  */
            pds2mnm  = '        '                    /* initialize alias of */
            pds2name = SUBSTR(line.j,ix,8) ; ix = ix + 8    /* main section */
            pds2ttrp = SUBSTR(line.j,ix,3) ; ix = ix + 3
            pds2indc = SUBSTR(line.j,ix,1) ; ix = ix + 1
            udl = 0                           /* calculate user data length */
            If BITAND(pds2indc,'01'x) = '01'x Then udl = 1
            If BITAND(pds2indc,'02'x) = '02'x Then udl = udl + 2
            If BITAND(pds2indc,'04'x) = '04'x Then udl = udl + 4
            If BITAND(pds2indc,'08'x) = '08'x Then udl = udl + 8
            If BITAND(pds2indc,'10'x) = '10'x Then udl = udl + 16
            udl = udl * 2                 /* finish calc halfwords to bytes */
            If udl >= 22 & last \= 1 Then Do   /* only process likely stuff */
               ix = ix + 8             /* adjust index to skip misc 8 bytes */
               pds2atr1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2atr2 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               pds2stor = SUBSTR(line.j,ix,3) ; ix = ix + 3
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
               pds2epa  = SUBSTR(line.j,ix,3) ; ix = ix + 3
               pds2ftb1 = SUBSTR(line.j,ix,1) ; ix = ix + 1
               ix = ix + 2             /* adjust index to skip misc 2 bytes */
                                                            /* scatter sect */
               If BITAND(pds2atr1,'04'x) = '04'x Then Do
                  pds2scat = SUBSTR(line.j,ix+33,8)
                  ix = ix + 8
                  End
                                                              /* alias sect */
               If BITAND(pds2indc,'80'x) = '80'x Then Do
                  If udl >= 32 Then Do
                     pds2epm  = SUBSTR(line.j,ix,3) ; ix = ix + 3
                     pds2mnm  = SUBSTR(line.j,ix,8) ; ix = ix + 8
                     End
                  Else Do
                     Say '*** WARNING - Missing major for alias 'pds2name' DBLK:'i
                     pds2epm = '000000'x
                     pds2mnm = '????????'
                     End
                  End
                                                             /* ssi section */
               If BITAND(pds2ftb1,'10'x) = '10'x Then Do
                  If (ix-1)//2 \= 0 Then ix = ix + 1    /* halfword alignmt */
                  pdsssiwd = SUBSTR(line.j,ix,4) ; ix = ix + 4
                  End
                                                             /* apf section */
               If BITAND(pds2ftb1,'08'x) \= '08'x Then pdsapfac = ' '/* none*/
               Else Do                                         /* maybe apf */
                  pdsapfct = SUBSTR(line.j,ix,1)
                  If pdsapfct = '01'x Then Do                /* NORMAL path */
                     ix = ix + 1
                     pdsapfac = SUBSTR(line.j,ix,1)
                     ix = ix + 1
                     If pdsapfac \= '00'x & pdsapfac \= '01'x Then Do
                        Say '*** WARNING - Invalid AC for 'pds2name' DBLK:'i
                        nop
                        End
                     End
                  If pdsapfct \= '01'x & (BITAND(pds2indc,'80'x)='80'x) Then Do
                     pdsapfac=' '
                     ix = ix - 8
                     Say '*** WARNING - Compacted alias logic for 'pds2name' DBLK:'i
                     End
                  End
               End
            Else Do                              /* too short udl, leave it */
               ix = ix + udl
               If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
                  last = 1
                  Leave
                  End
               Say '*** WARNING - too short udl for 'pds2name' DBLK:'i
               pds2atr1 = '00'x
               pds2atr2 = '00'x
               pds2stor = '000000'x
               pds2mnm  = '        '
               pdsapfac = ' '
               End
            If (ix-1)//2 \= 0 Then ix = ix + 1          /* halfword alignmt */
            If pds2name = 'FFFFFFFFFFFFFFFF'x Then Do
               last = 1
               Leave
               End
            If pds2name \= '0000000000000000'x Then Do
               memcount = memcount + 1
               Push ' 'LEFT(dsn,44,' ')' 'LEFT(vol,6,' '),
                    ' 'pds2name' TTR:'C2X(pds2ttrp),
                    ' INDC:'C2X(pds2indc)' ATRBs:'C2X(pds2atr1),
                    C2X(pds2atr2)' SIZE:'C2X(pds2stor),
                    ' MAJ:'pds2mnm' AC:'C2X(pdsapfac),
                    ' DBLK:'RIGHT(i,4,0)' UDL:'RIGHT(udl,2,0),
                    ' IX:'RIGHT(ix,3,0)
               End
         End                                         /* DIRBLOCK parse done */
      End
      Say '       *** Directory blocks processed: 'j-1'  Members: 'memcount
      Queue
      'EXECIO * DISKW APFPGMS (      '
      Delstack
      totpgms = totpgms + memcount
   End
End
Newstack 
Queue
'EXECIO * DISKW APFPGMS ( FINIS'
Delstack 
Say ' '
Say 'Saved 'totpgms' APF program descriptor records to DASD'
Say 'DSN: 'dsn2
Say 'Return Code: 'RC
"FREE F(APFPGMS)"
Exit
