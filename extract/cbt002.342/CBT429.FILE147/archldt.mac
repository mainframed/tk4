LDT      TITLE 'ARCHIVER --- LOADT FUNCTION'
*---------------------------------------------------------------------*
*---     ARCHIVER DIRECT TAPE-LOAD FUNCTION                        ---*
*---------------------------------------------------------------------*
ARCHLDT  CSECT
R0       EQU   0                   R
R1       EQU   1                    E
R2       EQU   2                     G
R3       EQU   3                      I
R4       EQU   4                       S
R5       EQU   5                        T
R6       EQU   6                         E
R7       EQU   7                          R
R8       EQU   8
R9       EQU   9                   E
R10      EQU   10                   Q
R11      EQU   11                    U
R12      EQU   12                     A
R13      EQU   13                      T
R14      EQU   14                       E
R15      EQU   15                        S
         COPY #ARCBITS
         USING ARCHLDT,R15
         #STAMP
         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS
         LR    R11,R15             LOAD ROUTINE BASE REGISTER
         DROP  R15                 DROP THE OLD BASE
         USING ARCHLDT,R11         DEFINE THE NEW BASE REGISTER
         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK
         ST    R14,8(,R13)         STORE FORWARD POINTER
         ST    R13,4(,R14)         AND BACK POINTER
         LR    R13,R14             LOAD NEW SAVE AREA POINTER
         L     R14,4(,R13)         RELOAD BACK POINTER
         L     R14,12(,R14)        RELOAD ORIG. REG 14
         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER
         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH
         USING ARCHLDT+4096,R10    AND DECLARE IT
         USING MAINWK,R12          BASE THE MAIN WORK AREA
         #SET  LOADING,OFF         CLEAR STATUS FLAG
         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT
         XC    MCNT,MCNT           AND MEMBER COUNT
         XC    ACNT,ACNT           AND ALIAS COUNT
         BAL   R14,QSOPEN          GO OPEN THE EXPORT TAPE
         BAL   R14,OPNVO           OPEN THE OUTPUT DATASET
         EJECT
*---------------------------------------------------------------------*
*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*
*---           THIS:                                               ---*
*---                                                               ---*
*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*
*---        INFORMATION WE'VE DEVELOPED, READ THROUGH THE INPUT    ---*
*---        DATASET, LOOKING FOR AN ITEM TO LOAD.  WE'LL USE A     ---*
*---        GETMAIN'ED AREA, BASED FROM VS1BUF2, TO SAVE EACH      ---*
*---        'REAL' HEADER RECORD UNTIL THE HEADER AND ALL THE      ---*
*---        ALIASES ARE CHECKED.                                   ---*
*---                                                               ---*
*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*
*---        EXPLODING THEM INTO THE BPAM BUFFERS, WRITING AS EACH  ---*
*---        BUFFER GETS FULL.  THE I/O ROUTINES DESIGNATED BY THE  ---*
*---        BRANCH INSTRUCTION AT 'BLOCK' WILL DETERMINE THE       ---*
*---        BLOCKING MECHANISM USED.                               ---*
*---                                                               ---*
*---     3. AT END-OF-FILE FOR THE DATASET OR MEMBER, DO ANY STOW  ---*
*---        THAT MAY BE APPROPRIATE.  FOR PDS MEMBERS WITH         ---*
*---        ALIASES, WE ALSO STOW THE ALIASES AT THIS POINT.       ---*
*---------------------------------------------------------------------*
*---     FIRST, SET UP THE SAVE AREA FOR THE 'REAL' HEADER RECORD. ---*
*---------------------------------------------------------------------*
         GETMAIN R,LV=32768,SP=9   GRAB SOME STORAGE
         ST    R1,VS1BUF2          AND SAVE ITS ADDRESS
MEMBERS  DS    0H
         #SET  LOADING,OFF
         L     R1,ACB1             (ACTUALLY A DCB ADDRESS)
         GET   (1)                 READ A RECORD
         LA    R0,0                CLEAR A WORK REGISTER
         ICM   R0,3,0(R1)          INSERT RECORD LENGTH
         SH    R0,=H'4'            ACCOUNT FOR RDW
         ST    R0,VS1LEN1          SAVE RESULT
         LA    R1,4(,R1)           POINT TO DATA START
         ST    R1,VS1BUF1          SAVE RECORD ADDRESS
NEXTHDR  DS    0H
         #SET  LOADING,OFF
         L     R6,VS1BUF1          AND COPY FOR LATER USE
         USING REC,R6              AND BASE THE DSECT
         L     R1,VS1LEN1          LOAD THE RECORD LENGTH
         CLI   RECTT,#RTHDR        HEADER RECORD ??
         BNE   MEMBERS             NOPE; KEEP SEARCHING
HDRG     DS    0H
         #IF   RSRALIAS,ON,HDRG1   NOT AN ALIAS RECORD
         LR    R2,R6               COPY RECORD ADDRESS
         L     R3,VS1LEN1          AND LOAD ITS LENGTH
         ST    R3,VS1LEN2          SAVE HEADER LENGTH, FOR LATER
         L     R14,VS1BUF2         POINT TO HEADER SAVE AREA
         LR    R15,R3              AND SET LENGTH TO COPY
         MVCL  R14,R2              SAVE THE HEADER FOR LATER REFERENCE
HDRG1    DS    0H
         #IF   RSRALIAS,OFF,HDRG2  NOT AN ALIAS RECORD ??
         #IF   LDARCHA,OFF,MEMBERS NO ALIASES CHECKED ??
HDRG2    DS    0H
         LA    R1,RECN             POINT TO THE HEADER
         LA    R0,0                USE DEFAULT QUALIFIER DATA
         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??
         LTR   R15,R15             PASS THE CHECK ??
         BNZ   MEMBERS             NOPE ---
REAL     DS    0H
         L     R1,VS1BUF2          POINT TO THE HEADER RECORD AGAIN
         L     R6,VS1BUF2          POINT TO THE HEADER RECORD AGAIN
         CALL  ARCHKDCB            GO COMPARE DCB'S
         LTR   R15,R15             STILL OK ??
         BNZ   MEMBERS             NOPE; SKIP THIS ITEM
         #IF   NVSPO,OFF,NOTPO     CHECK THE DSORG FLAG
         #IF   REPL,ON,NOTPO       REPLACE ANYHOW
         MVC   BLDLAREA(4),=AL2(1,76)
         MVC   BLDLAREA+4(8),RECN  COPY THE MEMBER NAME IN
         L     R2,NDCBA            LOAD THE DCB ADDRESS
         BLDL  (2),BLDLAREA        CHECK: IS THE MEMBER THERE ??
         LTR   R15,R15             WAS IT FOUND ??
         BNZ   NOTPO               NOPE; CONTINUE ---
         #FORMAT RECTT,,STOWM1
         #PUT  LINE
         B     MEMBERS             AND GO FOR NEXT ITEM
NOTPO    DS    0H
         #SET  LOADING,ON          SET 'SELECTED FOR LOAD' STATUS
         CLI   RSRDSO,DCBDSGPO     IS IT A PO MEMBER UNLOADED ??
         BNE   NODIR               NOPE ---
         LA    R1,0                CLEAR A WORK REGISTER
         IC    R1,RSRPDIR+11       LOAD DIR ENTRY LENGTH
         N     R1,=A(X'1F')        TRIM TO BARE LENGTH
         SLL   R1,1                TIMES TWO
         LA    R1,11(,R1)          COMPUTE TOTAL ENTRY LENGTH
         EX    R1,NODIR-6          COPY DIR TO BLDLAREA
         B     NODIR               AND GO ---
         MVC   BLDLAREA(1),RSRPDIR 'EX'ED COPY OF DIR ENTRY
NODIR    DS    0H
         L     R1,VS1BUF2          COPY THE HEADER ADDRESS
         BAL   R14,IOSEP           GO DO A SEPARATOR (MAYBE)
         L     R6,VS1BUF1          RELOAD HEADER RECORD ADDRESS
         L     R7,VS1BUF2          LOAD SAVE-HEADER AREA POINTER
LDPRE    DS    0H
         L     R1,ACB1             LOAD THE DCB ADDRESS
         GET   (1)                 READ THE NEXT RECORD
         CLI   4(R1),#RTHDR        HEADER RECORD ??
         BNE   LDLP1               NOPE; START PROCESSING
         B     LDPRE               YES; SKIP IT ---
LDLOOP   DS    0H
         L     R1,ACB1             POINT TO THE TAPE DCB
         GET   (1)                 GO READ A TAPE RECORD
LDLP1    DS    0H
         LA    R0,0                CLEAR A WORK RECORD
         ICM   R0,3,0(R1)          LOAD THE LENGTH
         SH    R0,=H'4'            ACCOUNT FOR RDW
         ST    R0,VS1LEN1          SAVE THE LENGTH
         LA    R6,4(,R1)           POINT PAST THE RDW
         ST    R6,VS1BUF1          AND SAVE RECORD ADDRESS
         CLI   0(R6),#RTHDR        HEADER RECORD ??
         BE    LDDONE              YES; LOAD NEARLY COMPLETE
         CLI   0(R6),#RTDATA       DATA RECORD ??
         BNE   LDLOOP              NOPE; KEEP LOOKING
         CLC   1(RECKLEN-5,R6),1(R7) STILL IN THE RIGHT ITEM ??
         BNE   LDDONE              NOPE; DO STOWS 'N' STUFF
         LA    R3,RDATDATA         POINT TO ITEM DATA
         L     R4,VS1LEN1          LOAD RECORD LENGTH
         LA    R4,0(R4,R6)         POINT TO
         BCTR  R4,R0                 LAST DATA BYTE
WRTLOOP  DS    0H
         L     R0,TCOUNT           LOAD THE RECORD COUNT
         A     R0,=F'1'            COUNT THIS RECORD
         ST    R0,TCOUNT           STORE UPDATED COUNT
         LA    R0,0                CLEAR REGISTER ZERO
         ICM   R0,7,0(R3)          LOAD SEGMENT LENGTH
         LA    R1,3(,R3)           POINT TO SEGMENT START
         BAL   R14,PUT             GO WRITE A LOGICAL RECORD
         LA    R0,0                CLEAR REGISTER ZERO
         ICM   R0,7,0(R3)          LOAD SEGMENT LENGTH
         AR    R3,R0               BUMP TO
         LA    R3,3(,R3)             NEXT SEGMENT
         CR    R3,R4               ANOTHER SEGMENT TO PROCESS ??
         BL    WRTLOOP             YES ---
         B     LDLOOP              NOPE ---
ENDLOAD  DS    0H
         #SET  EOT,ON
         #IF   LOADING,OFF,ENDITALL
LDDONE   DS    0H
         #SET  NOEXP,ON            NOTE LIST ALREADY EXPANDED
         L     R1,NOTELIST         LOAD NOTELIST POINTER
         LTR   R1,R1               WAS ANY PRESENT ??
         BZ    LDDN1               NOPE ---
         L     R0,0(,R1)           LOAD ITS LENGTH
         SH    R0,=H'4'            ACCOUNT FOR TTR WORD
         LA    R1,4(,R1)           POINT TO ACTUAL DATA
         BAL   R14,PUT             GO WRITE THE NOTE LIST
         L     R1,NOTELIST
         L     R0,0(,R1)           LOAD ITS LENGTH
         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER
         FREEMAIN R,LV=(0),A=(1)
LDDN1    DS    0H
         #SET  NOEXP,OFF
         XC    NOTELIST,NOTELIST   AND RESET THE POINTER
         LA    R0,0                ZERO LENGTH RECORD
         BAL   R14,PUT             AND PURGE THE BUFFERS
         L     R6,VS1BUF2          POINT BACK TO HEADER RECORD
         LR    R0,R6               COPY RECORD ADDRESS
         A     R0,VS1LEN2          POINT TO RECORD END
         LA    R1,RSRPDIR          POINT TO DIRECTORY DATA
         SR    R0,R1               COMPUTE DIRDATA LENGTH
         BAL   R14,ENDSEP          TRAILING SEPARATORS FOR PS OUTPUT
         BAL   R14,PDSSTOW         GO DO STOWS (MAYBE)
         #IF   EOT,ON,ENDITALL     STOP AT TAPE END
         #IF   GENM,ON,NEXTHDR     LOOP IF GENERIC NAME
         #IF   GENG,ON,NEXTHDR     LOOP IF GENERIC GROUP
         #IF   GENSG,ON,NEXTHDR    LOOP IF GENERIC SUBGROUP
         #IF   GENT,ON,NEXTHDR     LOOP IF GENERIC TYPE
ENDITALL DS    0H
         L     R0,TCOUNT           LOAD TOTAL RECORD COUNT
         A     R0,FCOUNT           ADD FUNCTION COUNT
         ST    R0,TCOUNT           SAVE UPDATED COUNT
         #ERR  MSG=10
         L     R0,TCOUNT           LOAD TOTAL-RECORD COUNT
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
         L     R0,MCNT             LOAD MEMBER COUNT
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
         L     R0,ACNT             LOAD ALIAS COUNT
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??
         BE    NOACB               NOPE ---
         BAL   R14,QSCLOSE         CLOSE THE VSAM CLUSTER
NOACB    DS    0H
         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE
         L     R13,4(,R13)         LOAD BACK S.A. POINTER
         LM    R14,R12,12(R13)     RESTORE REGISTERS
         LA    R15,0               ALWAYS RC = 0
         MVI   12(R13),255
         BR    R14                 AND RETURN TO CALLER
         TITLE 'OPEN NONVSAM OUTPUT DATASET '
*---------------------------------------------------------------------*
*---     THIS LITTLE LOCAL SUBROUTINE DOES SEVERAL THINGS          ---*
*---     NECESSARY PRIMARILY FOR LOAD-MODULE RECOGNITION AND       ---*
*---     PROCESSING. FIRST AND FOREMOST, WE DETERMINE THE DSORG    ---*
*---     OF THE OUTPUT DATASET. IF OUTPUT IS A SEQUENTIAL          ---*
*---     DATASET, WE CAN ASSUME THAT ONLY ONE DCB WILL BE NEEDED.  ---*
*---     IF THE OUTPUT DATASET IS A PDS, WE NEED AT LEAST TWO      ---*
*---     DCBS; ONE FOR DATA AND ANOTHER FOR THE DIRECTORY          ---*
*---     INFORMATION PROCESSED BY ARCHDIR.  HERE'S A VERY          ---*
*---     SIMPLISTIC VIEW OF THE PROCESSING HERE.  (FURTHER MODS    ---*
*---     FOR PROCESSING PANVALET LIBRARIES ARE PLANNED BUT NOT     ---*
*---     YET IMPLEMENTED.)                                         ---*
*---                                                               ---*
*---     1. DETERMINE THE DSORG OR THE DATASET. IF NOT PS OR PO,   ---*
*---        WRITE NASTY MESSAGES TO THE USER AND QUIT RIGHT HERE.  ---*
*---                                                               ---*
*---     2. BUILD AND OPEN THE PRIMARY DCB.  SINCE WE USE BSAM     ---*
*---        FOR OUTPUT OF SEQUENTIAL DATASETS, WE CAN (ALMOST)     ---*
*---        USE THE SAME DCB FOR BOTH SEQUENTIAL AND PARTITIONED   ---*
*---        DATASETS.  WE ONLY NEED TO CHANGE THE DSORG VALUE IN   ---*
*---        THE DCB.  DURING THE 'OPEN' PROCESS, AN EXIT WILL      ---*
*---        BUILD A BUFFER POOL OF TWO BUFFERS.  BUFFERS ARE       ---*
*---        'GETBUF'ED AND SAVED IN THE ARCHIVER MAIN WORK AREA.   ---*
*---                                                               ---*
*---     3. IF THE DSORG IS PO AND RECFM = U, WE NEED ONE          ---*
*---        ADDITIONAL STEP: BUILD AN ADDITIONAL DCB AND OPEN IT   ---*
*---        FOR 'UPDAT' I/O.  THIS WILL BE USED BY THE MAINLINE    ---*
*---        CODE TO UPDATE NOTE LISTS IN LOAD MODULES, IF WE HAVE  ---*
*---        ANY.                                                   ---*
*---                                                               ---*
*---     NOTE: THE ARCHIVER MAKES NO ATTEMPT TO REASSEMBLE OR      ---*
*---     RECONSTRUCT A SPANNED RECORD.                             ---*
*---------------------------------------------------------------------*
         SPACE 3
OPNVO    DS    0H
         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS
*        #IF   NVPAN,ON,PANOPEN    REALLY A PANLIB ??
*---
*---     BUILD A DCB, TO START, FOR DSORG CHECKING
*---
         GETMAIN R,LV=BSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB
         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA
         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST
         MVC   0(BSDCBL,R1),BSDCB  COPY DCB TO DYNAMIC AREA
         USING IHADCB,R1           BASE THE DCB DSECT
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R1
*---
*---     GET THE VOLSER FROM THE UCB, STARTING FROM THE TIOT.
*---
         NC    TIOTA,TIOTA         HAVE WE ALREADY DONE THIS ??
         BNZ   OPNVO1              YES ---
         MVC   CALLIST(EXTL),EXTRPARM COPY PARMLIST FOR EXTRACT
         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT
         L     R1,TIOTA            LOAD THE TIOT POINTER
         LA    R1,24(,R1)          POINT TO THE FIRST TIOE
         ST    R1,TIOTA            SAVE UPDATED ADDRESS
OPNVO1   DS    0H
         L     R1,TIOTA            LOAD TIOT ELEMENT POINTER
OPNVO2   DS    0H
         CLI   0(R1),0             AT TIOT END ??
         BE    NODDERR             YES; DD STATEMENT IS MISSING
         CLC   NVSAMDD,4(R1)       IS THIS THE DD ENTRY ??
         BE    OPNVO3              YES; GO FETCH UCB ADDR
         IC    R0,0(,R1)           INSERT TIOE LENGTH
         N     R0,=F'255'          TRIM TO JUST THE LENGTH
         AR    R1,R0               BUMP TO NEXT ENTRY
         B     OPNVO2              AND CONTINUE THE SEARCH
OPNVO3   DS    0H
         L     R1,16(,R1)          LOAD UCB POINTER
         N     R1,=A(X'FFFFFF')    TRIM GARBAGE BYTES
         MVC   VOLSER,28(R1)       COPY THE VOLSER
         MVC   DEVT,16(R1)         AND UCB TYPE
         TM    DEVT+2,X'A0'        IS THIS A DASD OR TAPE DEVICE ??
         BZ    ERRDEV              NOPE; INVALID AS HELL
*---
*---     GET THE DSNAME. DISREGARD ANY MEMBER NAME
*---
         L     R2,NDCBA            LOAD THE DCB ADDRESS
         USING IHADCB,R2           AND BASE ITS DSECT
         LA    R0,DCBJFC           LOAD EXIT LIST POINTER
         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB
         LA    R0,JFC              POINT TO JFCB AREA
         ST    R0,DCBJFC           SAVE IN EXIT LIST
         MVI   DCBJFC,X'87'        EXIT TYPE, LAST FLAG
         RDJFCB ,MF=(E,NDCBA)      READ THE JFCB
         DROP  R2
*---
*---     BUILD AND EXECUTE THE CAMLIST/OBTAIN SEQUENCE IF DASD
*---     DATASET. USE THE FORMAT-1 DSCB TO DETERMINE IF THE
*---     DATASET IS PARTITIONED OR SEQUENTIAL.  IF THE DATASET
*---     IS SEQUENTIAL OR TAPE, WE BYPASS ANY BPAM STUFF.
*---
         TM    DEVT+2,X'80'        IS IT A TAPE DEVICE ??
         BO    OPNVO4              YES; ALWAYS SEQUENTIAL
         MVC   CALLIST(LCAMLST),CAMLST COPY CAMLIST TO WORK AREA
         LA    R0,JFC              LOAD DSNAME POINTER
         ST    R0,CALLIST+4        SAVE IN CAMLIST AREA
         LA    R0,VOLSER           POINT TO VOLSER
         ST    R0,CALLIST+8        SAVE IN CAMLIST AREA
         LA    R0,GENWK            POINT TO DSCB AREA
         ST    R0,CALLIST+12       SAVE IN CAMLIST AREA
GETDSCB  DS    0H
         OBTAIN CALLIST            FETCH THE DSCB
         LA    R1,GENWK            POINT TO THE WORK AREA
         USING DS1FMTID,R1         AND BASE THE DSECT PORTION
         TM    DS1DSORG,DS1DSGPS   SEQUENTIAL ??
         BO    OPNVO4              YES ---
         TM    DS1DSORG,DS1DSGPO   PARTITIONED ??
         BO    OPNVO5              YES ---
         B     ORGERR              UNABLE TO PROCESS ANY OTHER DSORG
         DROP  R1
*---
*---     SET THE DSORG IN THE PRIMARY DCB ACCORDING TO THE VALUE
*---     FOUND IN THE FORMAT-1 DSCB.  ALSO, SET A PAIR OF SPECIAL
*---     FLAGS IN THE ARCHIVER WORK AREA.  THIS ALLOWS ME TO
*---     DETERMINE IF I'M REALLY PROCESSING A PDS, REQUIRING
*---     FIND'S, ETC. OR JUST BE WARY OF AN END-OF-FILE THAT WILL
*---     ULTIMATELY TERMINATE THE PROCESS.  IT ALSO DETERMINES
*---     WHETHER I NEED A DIRECTORY DCB, FOR LATER.
*---
OPNVO4   DS    0H
         #SET  NVSPS,ON            SET THE DSORG FLAG
         #SET  NVSPO,OFF           SET THE DSORG FLAG
         L     R2,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R2
         MVC   0(BSDCBL,R2),BSDCB  COPY IN THE PROPER DCB
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R2
         CLC   SEPVAL,=CL8'IEBUPDTE' IEBUPDTE-TYPE SEPARATORS ??
         BNE   OPNVO4A             NOPE ---
         MVC   IOSEP(2),=X'47F0'
         MVC   IOSEP+2(2),=S(SEPUPDTE)
OPNVO4A  DS    0H
         B     OPNVO6              GO SET UP THE VSAM I/O BLOCKS,ETC.
OPNVO5   DS    0H
         #SET  NVSPO,ON            SET THE DSORG FLAG
         #SET  NVSPS,OFF           SET THE DSORG FLAG
         L     R2,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R2
         MVC   0(PODCBL,R2),PODCB  COPY IN THE PROPER DCB
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R2
OPNVO6   DS    0H
*---
*---     SET THE ADDRESS OF MY 'COMPLETION' EXIT INTO THE DCB AND
*---     PROCEED WITH THE NECESSARY OPEN, ETC.
*---
         L     R2,NDCBA            POINT TO PRIMARY DCB
         USING IHADCB,R2
         LA    R0,OPNVO13          LOAD EXIT LIST POINTER
         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB
         OPEN  (,OUTPUT),MF=(E,NDCBA) OPEN THE DCB
*---
*---     GRAB A PAIR OF BUFFERS FROM THE POOL BUILT DURING OPEN
*---     PROCESSING.
*---
         GETBUF (2),(3)            GRAB A BUFFER
         GETBUF (2),(4)            AND ANOTHER BUFFER
         LA    R0,4                INITIAL RECORD LENGTH
         SLL   R0,16               CREATE BDW VALUE
         ST    R0,0(,R3)
         ST    R0,0(,R4)
         STM   R3,R4,BPBUF1        SAVE POINTERS IN WORK AREA
         ST    R3,BLOCKWDS         START OF BUFFER
         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---
         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY
         #SET  IOGOING,OFF         NO I/O IN PROGRESS
         MVC   BLOCK,=X'47F0E000'  INITIALIZE ---
         MVC   NVSRECFM,DCBRECFM   COPY THE RECORD FORMAT
         MVC   NVSBLKL,DCBBLKSI    AND BLKSIZE
         MVC   NVSLRECL,DCBLRECL   AND LRECL
*---
*---     USING THE RECFM AS A GUIDE, SET THE S-TYPE ADDRESS OF
*---     THE APPROPRIATE DEBLOCKER INTO THE BRANCH INSTRUCTION AT
*---     'BLOCK'
*---
         TM    DCBRECFM,DCBRECU    U-FORMAT ??
         BNO   OPNVO7              NOPE ---
         MVC   BLOCK+2(2),=S(PUTU) SET 'U' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO7   DS    0H
         TM    DCBRECFM,DCBRECV+DCBRECBR VB FORMAT ??
         BNO   OPNVO8              NOPE ---
         MVC   BLOCK+2(2),=S(PUTVB) SET 'VB' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO8   DS    0H
         TM    DCBRECFM,DCBRECF+DCBRECBR FB FORMAT ??
         BNO   OPNVO9              NOPE ---
         MVC   BLOCK+2(2),=S(PUTFB) SET 'FB' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO9   DS    0H
         TM    DCBRECFM,DCBRECV    V FORMAT ??
         BNO   OPNVO10             NOPE ---
         MVC   BLOCK+2(2),=S(PUTV) SET 'V' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO10  DS    0H
         TM    DCBRECFM,DCBRECF    V FORMAT ??
         BNO   OPNVO11             NOPE ---
         MVC   BLOCK+2(2),=S(PUTF) SET 'F' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO11  DS    0H
         #PUT  =CL133'- UNABLE TO DETERMINE NONVSAM DATASET FORMAT'
         ABEND 999,DUMP
OPNVO12  DS    0H
         L     R0,=F'32768'        LOAD COMPRESS MAX LENGTH
         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER
         GETMAIN R,LV=(0)
         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS
         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS
         BR    R14                 AND RETURN TO LOCAL CALLER
         DROP  R2
*---
*---     THIS IS A SHORT AND SNEAKY DCB COMPLETION EXIT. ITS ONLY
*---     PURPOSE IS TO ESTABLISH THE BUFFER POOL FOR THE PRIMARY
*---     DCB. THIS POOL CONTAINS TWO BUFFERS, EACH BEING 4 BYTES
*---     LONGER THAN THE BLKSIZE OF THE DCB.
*---
*---     NOTE: THE GETPOOL ROUTINE WILL FAIL IF THE HIGH-ORDER
*---     BIT OF THE DCB ADDRESS IS NOT ZERO. SOME SPECIAL GLITCH
*---     IN THE IECQBFG1 CODE FOR A SPECIAL APPLICATION
*---     SOMEWHERE.
*---
OPNVO13  DS    0F
         DC    XL1'85',AL3(OPNVO13+4)
         USING IHADCB,R1
         LA    R1,0(,R1)           PURIFY DCB ADDRESS
         LH    R0,DCBBLKSI         LOAD THE BLKSIZE
         AH    R0,=H'4'            FOR LATER ---
         ICM   R0,12,=H'2'         BUFFER COUNT
         GETPOOL (1),(0)           BUILD A BUFFER POOL
         DROP  R1
         BR    R14                 AND RETURN TO O/C/EOV
         TITLE 'BSAM/BPAM CLOSE ROUTINE'
*---------------------------------------------------------------------*
*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET (ALL       ---*
*---     DCB'S), RELEASES ALL BUFFER POOLS, RESETS POINTER         ---*
*---     VALUES, RELEASE THE COMPRESSION WORK AREA AND CLEANS UP   ---*
*---     THE NONVSAM I/O IN GENERAL, INCLUDING THE RESETING OF     ---*
*---     ANY FLAG BITS.                                            ---*
*---------------------------------------------------------------------*
         SPACE 3
NVSCLOSE DS    0H
         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS
         L     R2,NDCBA            LOAD PRIMARY DCB ADDRESS
         LA    R2,0(,R2)           PURIFY THE ADDRESS
NVSCX    DS    0H
         LTR   R2,R2               ZERO ??
         BZ    NVC1                YES; NO DCB HERE ---
         TM    48(R2),X'10'        IS IT OPEN ??
         BZ    NVCA                NOPE ---
         CLOSE MF=(E,NDCBA)        CLOSE THE DCB
NVCA     DS    0H
         #FREE (2)                 RELEASE BUFFER POOL, IF ANY
         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD
NVC1     DS    0H
         XC    DEVT,DEVT           CLEAR SAVED VALUES
         XC    NVSDSORG,NVSDSORG
         XC    VOLSER,VOLSER
         XC    BLOCKWDS(8),BLOCKWDS
         XC    NVSRECFM,NVSRECFM
         XC    NVSBLKL,NVSBLKL
         XC    NVSLRECL,NVSLRECL
         XC    BPBUF1,BPBUF1
         XC    BPBUF2,BPBUF2
NOCMPW   DS    0H
         XC    CMPWRKL(8),CMPWRKL
         MVC   BLOCK+2(2),=S(0(R14))
         #SET  IOGOING,OFF
         #SET  BUFUSED,OFF
         #SET  TRUNC,OFF
         #SET  NVSPS,OFF
         #SET  NVSPO,OFF
         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS
         BR    R14                 AND RETURN TO CALLER
         TITLE 'DIRECTORY ''STOW'' SUBROUTINE'
*---------------------------------------------------------------------*
*---     THIS LOCAL SUBROUTINE TAKES CARE OF ALL STOW PROCESSING.  ---*
*---     FUNCTIONS INCLUDE UPDATING TTR'S IN THE DIRECTORY ENTRY   ---*
*---     AND STOWING ALIAS DATA, WHERE APPROPRIATE.                ---*
*---------------------------------------------------------------------*
PDSSTOW  DS    0H
         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS
         LR    R5,R1               COPY DIRDATA POINTER
         LR    R3,R0               COPY DIRDATA LENGTH
         LA    R3,0(R3,R5)         POINT TO END
         BCTR  R3,R0               DECREMENT, FOR LOOPING ---
         MVC   BLOCKWDS,BPBUF1     START OF BUFFER
         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---
         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY
         #SET  IOGOING,OFF         NO I/O IN PROGRESS
         CR    R5,R3               ANYTHING TO STOW ??
         BH    STOWDONE            NOPE; ALL DONE
         #IF   NVSPS,ON,STOWPS     SEQUENTIAL OUTPUT ??
         L     R2,NDCBA            LOAD PDS DCB ADDRESS
         LA    R2,0(,R2)           AND PURIFY ADDRESS
         LM    R7,R8,BPBUF1        LOAD BUFFER ADDRESSES
         MVC   0(4,R7),=X'00040000' RE-INIT FOR VB
         MVC   0(4,R8),=X'00040000' RE-INIT FOR VB
         LM    R7,R9,BLDLAREA+8    LOAD TTR DATA FROM BLDLAREA
STOW1    DS    0H
         CR    R5,R3               ANYTHING TO STOW ??
         BH    STOWDONE            NOPE; ALL DONE
         LA    R4,0                CLEAR A WORK REGISTER
         IC    R4,11(,R5)          LOAD DIR LENGTH BYTE
         N     R4,=A(X'1F')        TRIM TO BARE LENGTH
         LA    R4,11(R4,R4)        COMPUTE LENGTH TO MOVE
         EX    R4,DIRMOVE          COPY TO BLDLAREA
         LA    R5,1(R4,R5)         BUMP INPUT POINTER
         STCM  R7,14,BLDLAREA+8    SAVE MEMBER TTR
         TM    BLDLAREA+11,B'01100000' ANY TTR'S IN USER DATA ??
         BZ    STOW2               NOPE ---
         STCM  R8,14,BLDLAREA+12   FIRST TEXT RCD (MAYBE)
         TM    BLDLAREA+11,B'01000000' SECOND TTR IN USER DATA ??
         BZ    STOW2               NOPE ---
         STCM  R9,14,BLDLAREA+16   NOTE LIST (MAYBE)
STOW2    DS    0H
         TM    BLDLAREA+11,X'80'   IS THIS AN ALIAS ??
         BO    ALCNT               YES ---
         L     R14,MCNT            LOAD MEMBER COUNT
         A     R14,=F'1'           INCREMENT BY ONE
         ST    R14,MCNT            STORE UPDATED COUNT
         B     STOWD               GO ---
ALCNT    DS    0H
         L     R14,ACNT            LOAD MEMBER COUNT
         A     R14,=F'1'           INCREMENT BY ONE
         ST    R14,ACNT            STORE UPDATED COUNT
STOWD    DS    0H
         STCM  R7,14,BLDLAREA+8    INSERT THE TTR
         TM    BLDLAREA+11,X'80'   ALIAS ??
         BO    *+10
         XC    BLDLAREA+8(3),BLDLAREA+8
         #STOW (2),BLDLAREA        STOW (MAYBE) MEMBER NAME
         LR    R1,R15
STOWE    DS    0H
         ICM   R7,14,BLDLAREA+8    INSERT THE TTR
         LR    R15,R1
         SRL   R15,2               DIVIDE BY FOUR
         MH    R15,=H'51'          RC. TIMES MESSAGE LENGTH
         LA    R15,STOWM(R15)      POINT TO THE MESSAGE
         #FORMAT RECTT,,0(,R15)
         TM    BLDLAREA+11,X'80'   ALIAS NAME ??
         BZ    NOTALIAS            NOPE ---
         LR    R1,R0               POINT TO NEXT AREA
         MVC   0(7,R1),=CL7'(ALIAS)'
NOTALIAS DS    0H
         MVC   LINE+2(8),BLDLAREA  COPY THE REAL NAME OVER
         #PUT  LINE
         B     STOW1               AND CONTINUE ---
DIRMOVE  MVC   BLDLAREA(1),0(R5)
STOWDONE DS    0H
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 AND RETURN TO LOCAL CALLER
STOWPS   DS    0H
         L     R14,MCNT            LOAD MEMBER COUNT
         A     R14,=F'1'           INCREMENT BY ONE
         ST    R14,MCNT            STORE UPDATED COUNT
         #FORMAT RECTT,,SEQMSG     SEQUENTIAL DATASET MESSAGE
         #PUT  LINE
         B     STOWDONE            AND RETURN TO LOCAL CALLER
SEQMSG   DC    AL1(50),CL50' ADDED TO SEQUENTIAL OUTPUT DATASET.'
STOWM    DC    AL1(50),CL50' SUCCESSFULLY STOWED IN PDS.'
STOWM1   DC    AL1(50),CL50' NOT REPLACED IN OUTPUT PDS.'
         DC    AL1(50),CL50' '
         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'
         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'
         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'
         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'
         DC    AL1(50),CL50' REPLACED IN OUTPUT PDS'
         DC    AL1(50),CL50' '
         DC    AL1(50),CL50' NOT FOUND. ADD ASSUMED.'
         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'
         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'
         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'
         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'
         TITLE 'BSAM/BPAM WRITE ROUTINES '
*---------------------------------------------------------------------*
*---     REGS AT ENTRY:                                            ---*
*---              R0 ::= LOGICAL RECORD LENGTH                     ---*
*---              R1 --> LOGICAL RECORD                            ---*
*---              R14 -> RETURN ADDRESS                            ---*
*---                                                               ---*
*---     IN THE SPECIAL CASE OF RECFM=U, R1 WILL ACTUALLY POINT    ---*
*---     TO THE TTR WORD THAT PREFIXES THE DATA. R0 WILL BE ALSO   ---*
*---     BE ADJUSTED TO REFLECT THIS FACT.                         ---*
*---                                                               ---*
*---     THE BUFUSED FLAG DENOTES A BUFFER WITH GOOD STUFF IN IT   ---*
*---     BUT NO WRITE HAS STARTED FOR IT YET.                      ---*
*---                                                               ---*
*---     THE SPECIAL CASE OF A RECORD LENGTH OF ZERO SIGNALS A     ---*
*---     REQUEST TO WRITE ALL REMAINING DATA, SIMILAR TO A QSAM    ---*
*---     'TRUNC' MACRO.  THIS IS TYPICALLY NECESSARY WHEN THE      ---*
*---     LAST BLOCK OF THE MEMBER IS NOT FULL.                     ---*
*---------------------------------------------------------------------*
         SPACE 3
PUT      DS    0H
         STM   R14,R12,IOSAVE      SAVE INPUT REGISTERS
         #SET  TRUNC,OFF           NOT YET, ANYWAY
         L     R9,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R9           AND BASE ITS DSECT
         LR    R2,R1               AND ADDRESS
         LTR   R3,R0               ANYTHING TO ADD ??
         BNZ   EXPDR               YES ---
         #SET  TRUNC,ON            NOPE; SET 'TRUNC' FLAG
         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE
EXPDR    DS    0H
         #IF   NOEXP,ON,BLOCK
         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA
         ST    R4,IOSAVE+12        SAVE EXPANDED RECORD ADDRESS
         LH    R3,0(,R2)           LOAD EXPANDED RECORD LENGTH
         ST    R3,IOSAVE+8         SAVE NEW RECORD LENGTH
         LA    R2,2(,R2)           POINT TO ACTUAL RECORD DATA
         CALL  EXPAND,((4),IOSAVE+8,(2)),MF=(E,CALLIST)
         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE
         TITLE 'BSAM/BPAM WRITE FIXED RECORDS '
*---------------------------------------------------------------------*
*---     FIXED, UNBLOCKED RECORDS.                                 ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTF     DS    0H
         #IF   TRUNC,ON,PUTF1      JUST CLEANING UP
         L     R4,BPBUF1           LOAD BUFFER POINTER
         LH    R5,DCBBLKSI         LOAD LRECL FOR RETURN
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         MVCL  R4,R2               COPY RECORD TO BPAM BUFFER
PUTF1    DS    0H
         #IF   IOGOING,OFF,PUTF2   IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         SHOW NO MORE WRITE IN PROGRESS
PUTF2    DS    0H
         #IF   TRUNC,ON,PUTRET     ALL DONE ---
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         WRITE PDSDECB,SF,(9),(4),'S',MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         B     PUTRET              AND GO RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE FIXED BLOCKED RECORDS '
*---------------------------------------------------------------------*
*---     FIXED, BLOCKED RECORDS.                                   ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTFB    DS    0H
         #IF   TRUNC,ON,PUTFB3     JUST CLEAN UP WHAT'S LEFT
         #IF   BUFUSED,ON,PUTFBA   INIT. SETUP IS DONE ??
         L     R4,BPBUF1           POINT TO FIRST BUFFER
         LA    R5,0                AMOUNT USED ---
         STM   R4,R5,BLOCKWDS      INIT. THE BLOCKING VALUES
PUTFBA   DS    0H
         #SET  BUFUSED,ON          TURN ON 'BUFFER USED' FLAG
         LM    R4,R5,BLOCKWDS      NEXT-RECORD ADDRESS
         LR    R6,R5               COPY CURRENT BUFFER-USED VALUE
         AH    R6,DCBLRECL         ACCOUNT FOR A RECORD
         ST    R6,BLOCKWDS+4
         LA    R4,0(R5,R4)         POINT INTO THE BUFFER
         LH    R5,DCBLRECL         LOAD LOGICAL RECORD LENGTH
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
PUTFB1   DS    0H
         MVCL  R4,R2               MOVE RECORD INTO BUFFER
         L     R2,BLOCKWDS+4       LOAD BYTES-USED VALUE
         CH    R2,DCBBLKSI         AT END OF BUFFER ??
         BL    PUTRET              NOPE; RETURN TO LOCAL CALLER
         #IF   IOGOING,OFF,PUTFB2  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
         #SET  BUFUSED,OFF         NEXT BUFFER IS EMPTY
PUTFB2   DS    0H
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS
         XC    BLOCKWDS+4(4),BLOCKWDS+4 CLEAR 'BYTES-USED' VALUE
         WRITE PDSDECB,SF,(9),(4),'S',MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG
         B     PUTRET              AND GO RETURN TO LOCAL CALLER
*---------------------------------------------------------------------*
*---     BUFFER PURGE ROUTINE                                      ---*
*---------------------------------------------------------------------*
PUTFB3   DS    0H
         #IF   IOGOING,OFF,PUTFB4  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTFB4   DS    0H
         #IF   BUFUSED,OFF,PUTFB5  IS CURRENT BUFFER USED ??
         L     R2,BPBUF1           LOAD BUFFER POINTER WORD
         L     R3,BLOCKWDS+4       LOAD BYTES-USED VALUE
         LH    R4,DCBBLKSI         LOAD DCB BLKSIZE
         STH   R3,DCBBLKSI         STORE UPDATED BLKSIZE
         WRITE PDSDECB,SF,(9),(2),(3),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         CHECK PDSDECB             LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS
         STH   R4,DCBBLKSI         RESTORE BLKSIZE
         XC    BLOCKWDS+4(4),BLOCKWDS+4 ZERO BYTES USED
         ST    R2,BLOCKWDS         RESET NEXT-RECORD POINTER
PUTFB5   DS    0H
         B     PUTRET              RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE VARIABLE RECORDS '
*---------------------------------------------------------------------*
*---     VARIABLE, UNBLOCKED RECORDS.                              ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTV     DS    0H
         #IF   TRUNC,ON,PUTV1      JUST CLEAN UP ---
         L     R4,BPBUF1           LOAD BUFFER POINTER
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         AH    R3,=H'4'            ACCOUNT FOR RDW/BDW
         SLL   R3,16               SHIFT FOR RDW/BDW
         STCM  R3,15,0(R2)         STORE RDW/BDW PREFIX
         LA    R4,4(,R4)           POINT PAST IT
         L     R3,IOSAVE+8           AND LENGTH
         LR    R5,R3               COPY RECORD LENGTH AGAIN
         MVCL  R4,R2               MOVE RECORD TO BPAM BUFFER
PUTV1    DS    0H
         #IF   IOGOING,OFF,PUTV2   IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTV2    DS    0H
         #IF   TRUNC,ON,PUTRET     JUST CLEAN UP ---
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         LH    R5,0(,R4)           LOAD RECORD LENGTH
         WRITE PDSDECB,SF,(9),(4),(5),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         B     PUTRET              AND GO RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE VARIABLE BLOCKED RECORDS '
*---------------------------------------------------------------------*
*---     VARIABLE, BLOCKED RECORDS.                                ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTVB    DS    0H
         #IF   TRUNC,ON,PUTVB4     JUST CLEAN UP ---
PUTVB1   DS    0H
         #SET  BUFUSED,ON          SHOW THE BUFFER USED
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         L     R4,BPBUF1           LOAD BUFFER POINTER
         LH    R5,0(,R4)           LOAD BYTES-USED VALUE
         LA    R5,4(R3,R5)         ACCOUNT FOR NEW RDW
         CH    R5,DCBBLKSI         TOO LARGE FOR THIS BLOCK ??
         BNH   PUTVB3              NOPE ---
         #IF   IOGOING,OFF,PUTVB2  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS
PUTVB2   DS    0H
         LM    R4,R5,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R6,R4               SWAP BUFFERS
         MVC   0(4,R5),=X'00040000' START WITH 4 BYTES (BDW)
         STM   R5,R6,BPBUF1        ...
         LH    R5,0(,R4)           LOAD BYTES-USED VALUE
         WRITE PDSDECB,SF,(9),(4),(5),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG
         B     PUTVB1              AND RE-CHECK ---
PUTVB3   DS    0H
         #SET  BUFUSED,ON          SHOW THE BUFFER NON-EMPTY
         L     R4,BPBUF1           LOAD POINTER TO AREA
         LH    R5,0(,R4)           LOAD BYTES-USED VALUE
         LA    R4,0(R5,R4)         POINT TO NEXT RECORD AREA
         LA    R0,4(,R3)           BUILD RDW AND
         STH   R0,0(,R4)           STORE IT
         XC    2(2,R4),2(R4)       NO SPANNED-RECORD STUFF
         LR    R5,R3               COPY RECORD LENGTH
         LA    R4,4(,R4)           POINT TO DATA FIELD
         MVCL  R4,R2               AND MOVE THE RECORD
         L     R2,BPBUF1           LOAD POINTER TO AREA
         AH    R0,0(,R2)           LOAD CURRENT BLK LENGTH
         STH   R0,0(,R2)           UPDATE BDW
         ST    R0,BLOCKWDS+4       AND BYTES-USED VALUE
         B     PUTRET              AND EXIT
PUTVB4   DS    0H
*---------------------------------------------------------------------*
*---     BUFFER PURGE ROUTINE                                      ---*
*---------------------------------------------------------------------*
         #IF   IOGOING,OFF,PUTVB6  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTVB6   DS    0H
         #IF   BUFUSED,OFF,PUTVB7  IS CURRENT BUFFER USED ??
         L     R2,BPBUF1           LOAD BUFFER POINTER WORD
         LH    R3,0(,R2)           LOAD BYTES-USED VALUE
         WRITE PDSDECB,SF,(9),(2),(3),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         CHECK PDSDECB             LET IT COMPLETE
         MVC   0(4,R2),=X'00040000' RESET BDW
         L     R2,BPBUF2           LOAD BUFFER POINTER WORD
         MVC   0(4,R2),=X'00040000' RESET BDW
         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG
         #SET  IOGOING,OFF         TURN OFF 'WRITE-IN-PROGRESS' FLAG
PUTVB7   DS    0H
         B     PUTRET              RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE UNDEFINED RECORDS '
*---------------------------------------------------------------------*
*---     UNDEFINED-FORMAT RECORDS.                                 ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTU     DS    0H
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         #IF   TRUNC,ON,PUTU1      CLEAN UP LAST WRITE
         NC    NOTELIST,NOTELIST   NOTELIST ALREADY FOUND ??
         BNZ   PUTUA               YES; CONTINUE ---
         CLI   BLDLAREA+19,0       IS A NOTE LIST PRESENT ??
         BE    PUTUA               NOPE ---
         CLC   0(3,R2),BLDLAREA+16 IS THIS IT ??
         BNE   PUTUA               NOPE ---
         LA    R4,4(,R3)           ACCOUNT FOR LENGTH WORD
         GETMAIN R,LV=(4),SP=10    GRAB SOME STORAGE
         ST    R1,NOTELIST         SAVE AS NOTELIST POINTER
         ST    R4,0(,R1)           SAVE LENGTH, FOR RELEASING LATER
         LA    R4,4(,R1)           POINT TO DATA AREA
         LR    R5,R3               COPY ACTUAL RECORD LENGTH
         MVCL  R4,R2               COPY THE NOTE LIST
         B     PUTRET              END, FOR NOW
PUTUA    DS    0H
         LR    R5,R3               COPY RECORD LENGTH
         L     R4,BPBUF1           LOAD BUFFER ADDRESS
         MVCL  R4,R2               COPY RECORD TO BUFFER
         L     R5,IOSAVE+8         RE-COPY RECORD LENGTH
PUTU1    DS    0H
         #IF   IOGOING,OFF,PUTU2   IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTUF    DS    0H
         NOTE  (9)                 SAVE ADDRESS OF LAST RECORD
         LR    R2,R1               COPY RESULT TTR
         L     R1,BPBUF2           RELOAD BUFFER POINTER
         ICM   R1,14,0(R1)         INSERT OLD TTR VALUE
PUTA     DS    0H
         CLM   R1,14,BLDLAREA+8    MATCHING TTR ??
         BNE   *+8                 NOPE ---
         STCM  R2,14,BLDLAREA+8    YES; UPDATE IT ---
         CLM   R1,14,BLDLAREA+12   MATCHING TTR ??
         BNE   *+8                 NOPE ---
         STCM  R2,14,BLDLAREA+12   YES; UPDATE IT ---
         CLM   R1,14,BLDLAREA+16   MATCHING TTR ??
         BNE   *+8                 NOPE ---
         STCM  R2,14,BLDLAREA+16   YES; UPDATE IT ---
PUTB     DS    0H
*---------------------------------------------------------------------*
*---     IF A NOTE LIST WAS PRESENT, WE MUST EXAMINE EACH ENTRY,   ---*
*---     COMPARING THE OLD TTR OF THE RECORD WE JUST WROTE.  IF    ---*
*---     WE HAVE A MATCH, WE REPLACE THE OLD TTR WITH THE NEW      ---*
*---     TTR, BEING CAREFUL NOT TO ALTER THE SEGMENT NUMBER.       ---*
*---------------------------------------------------------------------*
         L     R6,NOTELIST         LOAD NOTELIST POINTER
         LTR   R6,R6               ANY NOTELIST PROCESSING ??
         BZ    PUTU2               NOPE ---
         L     R5,0(,R6)           LOAD SAVED-NOTELIST LENGTH
         LA    R6,8(,R6)           POINT TO FIRST TTR VALUE
         LA    R7,0(R6,R5)         POINT TO
         BCTR  R7,R0                 END OF LIST
         L     R4,BPBUF2           LOAD POINT TO THE BUFFER
PUTN1    DS    0H
         CLC   0(3,R4),0(R6)       TTR'S MATCH ??
         BE    PUTN2               YES ---
         LA    R6,4(,R6)           POINT TO NEXT ENTRY
         CR    R6,R7               FAR ENOUTH, YET ??
         BL    PUTN1               NOPE; KEEP CHECKING
         B     PUTU2               ALL DONE ---
PUTN2    DS    0H
         STCM  R2,14,0(R6)         STORE UPDATED TTR
PUTU2    DS    0H
         #IF   TRUNC,ON,PUTRET     ALL DONE ---
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS
         LA    R4,4(,R4)           POINT PAST THE TTR WORD
         L     R5,IOSAVE+8         RELOAD ORIGINAL LENGTH
         SH    R5,=H'4'            AND ACCOUNT FOR IT IN LENGTH
         WRITE PDSDECB,SF,(9),(4),(5),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         B     PUTRET              AND RETURN TO LOCAL CALLER
*---------------------------------------------------------------------*
*---     COMMON RETURN LINKAGE CODE                                ---*
*---------------------------------------------------------------------*
PUTRET   DS    0H
         LM    R14,R12,IOSAVE      RESTORE CALLER'S REGISTERS
         BR    R14                 RETURN ---
         DROP  R9
*---------------------------------------------------------------------*
*---     SOME ERROR STUFF                                          ---*
*---------------------------------------------------------------------*
NODDERR  DS    0H
         #ERR  MSG=1
         #ERR  MSG=6
         B     ENDITALL
ORGERR   DS    0H
         #ERR  MSG=3
         #ERR  MSG=6
         B     ENDITALL
ERRDEV   DS    0H
         #ERR  MSG=2
         #ERR  MSG=6
         B     ENDITALL
         TITLE 'VSAM CLOSE AND CONTROL-BLOCK FREEMAINS'
*---------------------------------------------------------------------*
*---     THIS LITTLE LOCAL SUBROUTINE IS THE COUNTERPART TO THE    ---*
*---     QSOPEN ROUTINE. HERE, THE VSAM CLUSTER # 1 IS CLOSED      ---*
*---     AND ALL RELATED STORAGE, WORK AREAS, ETC. ARE FREE'D.     ---*
*---     ALL RELATED VALUES IN THE ##ARCHWK AREA ARE ALSO RESET.   ---*
*---------------------------------------------------------------------*
QSCLOSE  DS    0H
         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS
         MVI   ACB1,X'80'          MARK AS LAST FOR CLOSE
         CLOSE ,MF=(E,ACB1)        CLOSE THE CLUSTER
         L     R1,ACB1             LOAD THE DCB ADDRESS
         FREEPOOL (1)              RELEASE THE BUFFER POOL
         LA    R0,0                LOAD A ZERO
         ST    R0,ACB1             SAVE
         ST    R0,VS1LIM                AS
         ST    R0,VS1BUF1
         ST    R0,VS1BUF2
         ST    R0,VS1LEN1
         ST    R0,VS1LEN2                       VALUES
         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS
         BR    R14                 RETURN TO (LOCAL) CALLER
         TITLE 'VSAM CLUSTER OPEN AND BLOCK-BUILD'
*---------------------------------------------------------------------*
*---     THIS LITTLE LOCAL SUBROUTINE OPENS THE VSAM CLUSTER       ---*
*---     FOR OUTPUT AND/OR UPDATE.  ALL VSAM-RELATED GETMAINS      ---*
*---     ARE DONE FROM SUBPOOL 10, TO ALLOW A SUBPOOL-WIDE         ---*
*---     FREEMAIN AT THE END OF PROCESSING. NOTE THAT ALL VSAM     ---*
*---     CONTROL BLOCKS ARE 'GENCB'D IN GETMAINED AREAS, FOR       ---*
*---     THE SAME FLEXIBILITY.                                     ---*
*---------------------------------------------------------------------*
QSOPEN   DS    0H
         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS
         #SET  EOT,OFF
         LA    R6,QSDCBL           LOAD THE DCB LENGTH
         GETMAIN R,LV=(6),SP=10    GRAB SOME STORAGE
         ST    R1,ACB1             SAVE AS ACB ADDRESS
         LR    R2,R1               COPY ITS ADDRESS
         MVC   0(QSDCBL,R2),QSDCB  COPY DCB INTO THE AREA
         USING IHADCB,R2           BASE THE DSECT
         MVC   DCBDDNAM,EXPTPDD    COPY THE DDNAME
         MVI   ACB1,X'80'          MARK AS LAST FOR OPEN
         OPEN  ,MF=(E,ACB1)        OPEN THE DATASET
         LH    R6,DCBLRECL         LOAD THE RECORD LENGTH
         GETMAIN R,LV=(6),SP=10    GRAB SPACE FOR A BUFFER AREA
         ST    R1,VS1BUF2          SAVE BUFFER
         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS
         BR    R14                 RETURN TO (LOCAL) CALLER
         DROP  R2
         SPACE 3
QSE      DS    0F
         DC    XL1'85',AL3(QSE+4)
         USING IHADCB,R1
         CLC   DCBBLKSI,=H'0'      BLKSIZE STILL ZERO ??
         BNER  R14                 NOPE ---
         MVC   DCBBLKSI,=H'32000'  YES; SET A DEFAULT
         BR    R14                 RETORN TO O/C/EOV
         DROP  R1
         TITLE 'SEQUENTIAL OUTPUT SEPARATOR ROUTINES'
*---------------------------------------------------------------------*
*---     THIS LITTLE ROUTINE GENERATES A IEBUPDTE-TYPE ./ ADD      ---*
*---     CARD AS A SEPARATOR BETWEEN ITEMS BEING LOADED TO A       ---*
*---     SEQUENTIAL DATASET.  NO CHECK OF THE OUTPUT DATASET       ---*
*---     CHARACTERISTICS IS MADE; THE USER IS ASSUMED TO KNOW      ---*
*---     WHAT HE'S DOING!                                          ---*
*---------------------------------------------------------------------*
SEPUPDTE DS    0H
         STM   R14,R12,SEPSAVE     SAVE THE INPUT REGISTERS
         LR    R2,R1               COPY INPUT HEADER ADDRESS
         MVI   GENWK,C' '          SEED IN A BLANK
         MVC   GENWK+1(79),GENWK   BUILD A BLANK CARD
         MVC   GENWK(12),=C'./ ADD NAME='
         MVC   GENWK+12(8),1(R2)   COPY MEMBER NAME TO CARD
         #IF   NOEXP,ON,SEP1
         #SET  NOEXP,ON
         LA    R1,GENWK
         LA    R0,80
         BAL   R14,PUT             OUTPUT THE SEPARATOR
         #SET  NOEXP,OFF
         B     SEP2
SEP1     DS    0H
         LA    R1,GENWK            LOAD RECORD ADDRESS
         LA    R0,80               AND ELNGTH
         BAL   R14,PUT             CALL THE 'PUTTER'
SEP2     DS    0H
         LM    R14,R12,SEPSAVE
         BR    R14                 AND RETURN TO CALLER
         LTORG
TCMSG    DC    CL133' '
         ORG   TCMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202120'
         DC    C' TOTAL LOGICAL RECORDS PROCESSED.'
         ORG
MCMSG    DC    CL133' '
         ORG   MCMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202120'
         DC    C' TOTAL MEMBERS PROCESSED.'
         ORG
ACMSG    DC    CL133' '
         ORG   ACMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202120'
         DC    C' TOTAL ALIAS NAMES PROCESSED.'
         ORG
         LTORG
NOGENS   DC    XL16'000102030405060708090A0B0C0D0E0F'
         DC    XL16'101112131415161718191A1B1C1D1E1F'
         DC    XL16'202122232425262728292A2B2C2D2E2F'
         DC    XL16'303132333435363738393A3B3C3D3E3F'
         DC    XL16'404142434445464748494A4B4C4D4E4F'
         DC    XL16'505152535455565758595A5B5C5D5E5F'
         DC    XL16'606162636465666768696A6B6C6D6E6F'
         DC    XL16'707172737475767778797A7B7C7D7E7F'
         DC    XL16'808182838485868788898A8B8C8D8E8F'
         DC    XL16'909192939495969798999A9B9C9D9E9F'
         DC    XL16'A0A1A2A3A4A5A6A7A8A9AAABACADAEAF'
         DC    XL16'B0B1B2B3B4B5B6B7B8B9BABBBCBDBEBF'
         DC    XL16'C0C1C2C3C4C5C6C7C8C9CACBCCCDCECF'
         DC    XL16'D0D1D2D3D4D5D6D7D8D9DADBDCDDDEDF'
         DC    XL16'E0E1E2E3E4E5E6E7E8E9EAEBECEDEEEF'
         DC    XL16'F0F1F2F3F4F5F6F7F8F9FAFBFCFDFEFF'
         ORG   NOGENS+C'%'
         DC    X'00'
         ORG   NOGENS+C'*'
         DC    X'00'
         ORG
LOADED   DC    AL1(LDMSGE-LDMSG)
LDMSG    DC    C' SUCCESSFULLY LOADED.'
LDMSGE   EQU   *
ALIASM   DC    AL1(ALIASE-ALIASS)
ALIASS   DC    C' IS AN ALIAS. CHECK SYSPUNCH OUTPUT FOR REAL '
         DC    C'QUALIFIER DATA.'
ALIASE   EQU   *
MINREC   DC    A(RECSIZE)
CAMLST   CAMLST SEARCH,0,0,0
LCAMLST  EQU   *-CAMLST
PODCB    DCB   DSORG=PO,MACRF=(R,W),DDNAME=X
PODCBL   EQU   *-PODCB
BSDCB    DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=X
BSDCBL   EQU   *-BSDCB
QSDCB    DCB   DSORG=PS,MACRF=GL,DDNAME=X,BFTEK=A,EXLST=QSE,           X
               EODAD=ENDLOAD
QSDCBL   EQU   *-QSDCB
PCHDCB   DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=FB,LRECL=80,    X
               EXLST=PCHEXIT
DCBL     EQU   *-QSDCB
PCHEXIT  DS    0F
         DC    XL1'85',AL3(PCHEXIT+4)
         USING IHADCB,R1
         CLC   DCBBLKSI,=H'0'      BLKSIZE STILL ZERO ??
         BNER  R14                 NOPE ---
         MVC   DCBBLKSI,DCBLRECL   YES; DEFAULT TO LRECL
         BR    R14                 RETORN TO O/C/EOV
         DROP  R1
EXTRPARM EXTRACT ,'S',FIELDS=TIOT,MF=L
EXTL     EQU   *-EXTRPARM
         READ  DECB,SF,0,0,0,MF=L
DECBL    EQU   *-DECB
         DCBD  DSORG=(PS,PO)
         IECSDSL1 (1)
         COPY  #RECS
         COPY  ##ARCHWK
         END
