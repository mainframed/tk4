UNLD     TITLE 'ARCHIVER --- UNLOAD FUNCTION'
*---------------------------------------------------------------------*
*---     THIS ROUTINE IS THE FIRST HALF OF THE ARCHIVER'S REASON   ---*
*---     FOR EXISTANCE.  THIS SUBROUTINE, WITH ALL ITS CALLS,      ---*
*---     ETC., PERFORM THE UNLOAD FUNCTIONS OF THE ARCHIVER.       ---*
*---------------------------------------------------------------------*
*---     THE ONLY MAJOR CHANGES TO THE UNLOAD FUNCTION ARE TO      ---*
*---     SUPPORT THE AUTOMATIC ASSIGNING OF ARCHIVE ALIASES, IF    ---*
*---     REQUESTED BY THE USER.  ANY ALIAS NAMES IN THE INPUT PDS  ---*
*---     DIRECTORY ARE USED TO ASSIGN ARCHIVE ALIASES OF THE SAME  ---*
*---     GROUP, SUBGROUP AND TYPE QUALIFIERS AS THE 'MAIN'         ---*
*---     MEMBER.                                                   ---*
*---------------------------------------------------------------------*
ARCHUNLD CSECT
R0       EQU   0                   R
R1       EQU   1                    E
R2       EQU   2                     G
R3       EQU   3                      I
R4       EQU   4                       S
R5       EQU   5                        T
R6       EQU   6                         E
R7       EQU   7                          R
R8       EQU   8
R9       EQU   9                   E
R10      EQU   10                   Q
R11      EQU   11                    U
R12      EQU   12                     A
R13      EQU   13                      T
R14      EQU   14                       E
R15      EQU   15                        S
@RPL1    EQU   R2                  SOME
@RPL2    EQU   R3                    SPECIAL
@RPL3    EQU   R4                      EQUATES
@BUF1    EQU   R5                        FOR
@BUF2    EQU   R6                          VSAM
@BUF3    EQU   R7                            I/O MGMT
         COPY #ARCBITS
         USING ARCHUNLD,R15
         #STAMP
         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS
         LR    R11,R15             LOAD ROUTINE BASE REGISTER
         DROP  R15                 DROP THE OLD BASE
         USING ARCHUNLD,R11        DEFINE THE NEW BASE REGISTER
         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK
         ST    R14,8(,R13)         STORE FORWARD POINTER
         ST    R13,4(,R14)         AND BACK POINTER
         LR    R13,R14             LOAD NEW SAVE AREA POINTER
         L     R14,4(,R13)         RELOAD BACK POINTER
         L     R14,12(,R14)        RELOAD ORIG. REG 14
         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER
         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH
         USING ARCHUNLD+4096,R10   AND DECLARE IT
         USING MAINWK,R12          BASE THE MAIN WORK AREA
         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT
         XC    MCNT,MCNT           AND MEMBER COUNT
         XC    ACNT,ACNT           AND ALIAS COUNT
         #IF   GENG,ON,GENQ        INVALID GENERICS
         #IF   GENSG,ON,GENQ
         #IF   GENT,ON,GENQ
         BAL   R14,OPNVI           GO OPEN THE NONVSAM INPUT DATASET
         MVC   VS1MODE,=CL8'OUTPUT' SET THE I/O MODE
         LA    R1,VSAM1DD          LOAD THE PARM POINTER
         LA    R0,0                AND THE 'OPEN' FLAG
         CALL  ARCHVSOP            CALL THE 'OPEN' FUNCTION
         LTR   R15,R15             OPEN OK ??
         BNZ   ENDITALL            NOPE; CAN'T WORK
         EJECT
*---------------------------------------------------------------------*
*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*
*---           THIS:                                               ---*
*---                                                               ---*
*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*
*---        INFORMATION WE'VE DEVELOPED, BUILD AND WRITE A HEADER  ---*
*---        RECORD ON THE VSAM CLUSTER.  WE'LL USE THE VS1BUF2     ---*
*---        AREA FOR HEADER/KEY CONSTRUCTION.                      ---*
*---                                                               ---*
*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*
*---        COMPRESSING THEM INTO THE VSAM BUFFER UNTIL WE CAN'T   ---*
*---        FIT ANOTHER RECORD WITHOUT EXCEEDING THE MAXIMUM       ---*
*---        LOGICAL RECORD LENGTH.  AT THAT POINT, WE WRITE THE    ---*
*---        VSAM RECORD, RESET IT AND CONTINUE.  NOTE THAT EACH    ---*
*---        RECORD WE GET FROM A LMOD DATASET CONTAINS A TTR       ---*
*---        VALUE AS A PREFIX.  THIS INFORMATION IS USEFUL DURING  ---*
*---        THE RELOAD PROCESS. WE ALSO SAVE, IN THE MEMBER        ---*
*---        HEADER, AN INDICATION THAT THIS IS OR IS NOT A LOAD    ---*
*---        MODULE.                                                ---*
*---                                                               ---*
*---     3. AT END-OF-FILE FOR THE DATASET OR MEMBER, UPDATE THE   ---*
*---        HEADER RECORD WITH THE ACTUAL BLOCK OR LOGICAL RECORD  ---*
*---        COUNT THAT WAS MAINTAINED BY THE READ ROUTINE.  THIS   ---*
*---        COMPLETES THE PROCESSING FOR A SINGLE MEMBER OR        ---*
*---        SEQUENTIAL DATASET.                                    ---*
*---                                                               ---*
*---     4. DELETE THE DIRECTORY-CHAIN ENTRY(S) THAT REPRESENT     ---*
*---        THIS ITEM. IF THAT'S NOT THE LAST ONE, THEN GO BACK    ---*
*---        TO STEP ONE FOR ANOTHER ITEM.                          ---*
*---------------------------------------------------------------------*
         L     @RPL1,RPL1          LOAD RPL AND
         L     @BUF1,VS1BUF1       BUFFER POINTER
         L     @BUF2,VS1BUF2       REGISTERS
MEMBERS  DS    0H
         #IF   NVSPS,ON,MBR2       PS DATASET ---
         L     R9,CHAIN            LOAD CHAIN ROOT POINTER
         LTR   R9,R9               IS IT EMPTY ??
         BZ    ENDITALL            YES; DO TERMINATION STUFF
MBR2     DS    0H
         USING REC,@BUF2           BASE THE RECORD DSECT
         MVC   RECN,Q1             COPY FIRST QUALIFIER, TO START
         #IF   NVSPS,ON,MBR3       LEAVE IT ALONE
         MVC   RECN(8),8(R9)       MOVE IN THE ITEM NAME
         MVC   RECN+8(2),=CL2' '   CLOBBER TWO EXTRA BYTES
MBR3     DS    0H
         MVI   RECTT,#RTHDR        MARK AS A HEADER RECORD
         MVC   RECG,Q2             SECOND QUALIFIER
         MVC   RECSG,Q3            THIRD QUALIFIER
         MVC   RECT,Q4             AND ITEM TYPE
         XC    RECSEQ#,RECSEQ#     SEQUENCE NUMBER IS ZERO
         XC    RSRNOT#,RSRNOT#     NO NOTES, YET ---
         MVI   @RSRFLG1,X'06'      SET THE VERSION NUMBER
         MVI   @RSRFLG2,X'01'      SET THE LEVEL NUMBER
         MVI   @RSRFLG3,X'00'      SET THE MISC. FLAGS
         MVI   @RSRFLG4,X'00'      SET THE ALIAS FLAGS
         MVC   RSRDEV,DEVT         MOVE IN THE DEVICE TYPE
         MVC   RSRREC,NVSRECFM     MOVE IN THE RECORD FORMAT
         MVC   RSRBLK,NVSBLKL      AND BLOCKSIZE
         MVC   RSRLRE,NVSLRECL     AND LOGICAL RECORD LENGTH
         MVC   RSRDSO,NVSDSORG     AND DATASET ORGANIZATION
         MVC   RSRTIME,TIME        TIME OF UNLOAD
         MVC   RSRDATE,DATE        AND DATE OF UNLOAD
         XC    RSRRCNT,RSRRCNT     AND CLEAR THE RECORD COUNT
*---------------------------------------------------------------------*
*---     NOW THE TRICKY PART; SETTING THE ITEM VERSION NUMBER      ---*
*---                                                               ---*
*---     IF THE USER SPECIFIED A VERSION NUMBER, WE DO A READ TO   ---*
*---     SEE IF THAT VERSION EXISTS. IF IT DOES, WE MUST DELETE    ---*
*---     IT BEFORE WE CONTINUE.  SINCE I'M A TRUSTING SOUL, I'LL   ---*
*---     CALL THE ARCHERAS ROUTINE TO DELETE THE DUPLICATE         ---*
*---     VERSION.                                                  ---*
*---                                                               ---*
*---     IF THE USER DIDN'T PROVIDE A VERSION, WE'LL DO A READ ON  ---*
*---     A GENERIC KEY, LOOKING FOR A PREVIOUS VERSION. WE'LL      ---*
*---     INCREMENT THE VERSION NUMBER FROM THERE AND GO.           ---*
*---------------------------------------------------------------------*
         #IF   VRS,OFF,NEWVERS
         MVC   RECVER,Q5           COPY IN HIS VERSION NUMBER
         LA    R1,RECTT            LOAD PARAMETER POINTER VALUE
         CALL  ARCHERAS            GO ERASE ANY DUPLICATE ITEM
         B     HDRX                NOPE; GO WRITE THE HEADER RECORD
*---------------------------------------------------------------------*
*---     POSSIBLE NEW VERSION OF THE SAME ITEM                     ---*
*---------------------------------------------------------------------*
NEWVERS  DS    0H
         MODCB RPL=(@RPL1),                                            X
               AREA=(@BUF1),                                           X
               AREALEN=(*,VS1LIM),                                     X
               ARG=(@BUF2),                                            X
               KEYLEN=41,                                              X
               OPTCD=(DIR,GEN,KEQ,NUP),                                X
               MF=(G,GENWK)
         GET   RPL=(@RPL1)
         LTR   R15,R15             DID WE GET A RECORD ??
         BNZ   VERS1               NOPE; THIS IS VERSION ONE
CHKVERS  DS    0H
         MODCB RPL=(@RPL1),OPTCD=(FKS),MF=(G,GENWK)
         ICM   R0,15,RECVER-RECTT(@BUF1) INSERT THE VERSION NUMBER
         BCTR  R0,R0               ONE GREATER
         STCM  R0,15,RECVER        IN NEW HEADER RECORD
         B     HDRX                AND GO ---
VERS1    DS    0H
         MVC   RECVER,=F'-2'       STARTING VERSION NUMBER (TRUST ME)
HDRX     DS    0H
         XC    RECSEQ#,RECSEQ#     CLEAR THE SEQUENCE NUMBER
         XC    RSRRCNT,RSRRCNT     RECORD COUNT INITS TO ZERO
         L     R9,CHAIN            LOAD MEMBER CHAIN POINTER
         LA    R8,RSRPDIR          POINT TO DIRECTORY AREA
         #IF   NVSPS,ON,UMNAX      BRANCH IF PS INPUT DATASET
         LA    R14,0               CLEAR A WORK REGISTER
         IC    R14,19(,R9)         INSERT LENGTH/FLAGS
         N     R14,=A(X'1F')       TRIM TO BARE LENGTH
         SLL   R14,1               TIMES 2
         LA    R14,12(,R14)        PLUS BASIC SECTION LENGTH
         BCTR  R14,R0              DECREMENT FOR THE MOVE
         EX    R14,UMNAMVC         COPY TO RECORD AREA
         EX    R14,SAVEMAIN        COPY TO BLDL AREA, TOO
         L     R15,MCNT            LOAD MEMBER COUNT
         LA    R15,1(,R15)         INCREMENT BY ONE
         ST    R15,MCNT            AND SAVE UPDATED COUNT
         LA    R8,1(R14,R8)        POINT TO NEXT AREA
UMNA0    DS    0H
         NC    4(4,R9),4(R9)       ANY ALIASES ??
         BZ    UMNA1               NOPE ---
         L     R9,4(,R9)           POINT TO ALIAS ENTRY
         LA    R14,0               CLEAR A WORK REGISTER
         IC    R14,19(,R9)         INSERT LENGTH/FLAGS
         N     R14,=A(X'1F')       TRIM TO BARE LENGTH
         SLL   R14,1               TIMES 2
         LA    R14,12(,R14)        PLUS BASIC SECTION LENGTH
         BCTR  R14,R0              DECREMENT FOR THE MOVE
         EX    R14,UMNAMVC         COPY TO RECORD AREA
         L     R15,ACNT            LOAD ALIAS COUNT
         LA    R15,1(,R15)         INCREMENT BY ONE
         ST    R15,ACNT            AND SAVE UPDATED VALUE
         LA    R8,1(R14,R8)        POINT TO NEXT AREA
         B     UMNA0               AND LOOP FOR MORE ALIASES
UMNAMVC  MVC   0(1,R8),8(R9)       COPY OF ALIAS DATA
SAVEMAIN MVC   BLDLAREA(1),8(R9)   COPY OF MAIN DIR ENTRY
UMNAX    DS    0H
         MVC   0(8,R8),Q1          MOVE ITEM NAME AS MEMBER NAME
         XC    8(4,R8),8(R8)       CLOBBER TTRZ AREA
         LA    R8,12(,R8)          AND ACCOUNT FOR DUMMY DIR ENTRY
UMNA1    DS    0H
         SR    R8,@BUF2            COMPUTE BYTES USED
         ST    R8,VS1LEN2          SAVE UPDATED COUNT
         TM    RSRREC,X'C0'        RECFM = U ??
         BNO   NOTU1               NOPE ---
         OI    RSRLMOD,128         MARK AS LMOD TYPE ---
NOTU1    DS    0H
         MVC   0(RECKLEN,@BUF1),0(@BUF2) COPY KEY TO DATA RECORD
         L     R0,VS1LEN2          SWITCH THE
         LR    R1,@BUF2            COPY THE RECORD POINTER
         BAL   R14,VSPUT           OUTPUT THE DUMMY HEADER RECORD
         EJECT
*---------------------------------------------------------------------*
*---     NOW UNLOAD THE MEMBER DATA, COMPRESSING AS WE GO AND      ---*
*---     KEEPING TRACK OF THE RECORD COUNT.                        ---*
*---                                                               ---*
*---     HERE'S WHERE THAT FANCY LITTLE BRANCH TABLE IS USED.      ---*
*---------------------------------------------------------------------*
         BAL   R14,PDSFIND         GO POINT OUT THE MEMBER
         LA    R0,RECKLEN          LOAD KEY LENGTH
         ST    R0,VS1LEN1          SAVE AS STARTING RECORD LENGTH
         DROP  @BUF2               DROP THE HEADER RECORD
         USING REC,@BUF1           MAP THE DATA RECORD
         LA    R0,1                LOAD STARTING SEQ#
         STCM  R0,15,RECSEQ#       INSERT INTO RECORD KEY
         MVI   RECTT,#RTDATA       MARK AS A DATA RECORD
UNLDLOOP DS    0H
         BAL   R14,READ            GO GET A RECORD
         LTR   R0,R0               ANY RECORD RETRIEVED ??
         BZ    EOM                 NOPE; MEMBER IS DONE
         L     R15,COUNT           LOAD RECORD COUNT
         LA    R15,1(,R15)         INCREMENT BY ONE
         ST    R15,COUNT           SAVE UPDATED COUNT
         LR    R14,R1              COPY RECORD ADDRESS
         L     R8,CMPWRK           POINT TO COMPACT WORK AREA
         STH   R0,3(,R8)           SAVE ORIGINAL RECORD LENGTH
         LA    R8,5(,R8)           POINT TO ACTUAL OUTPUT AREA
         ST    R0,CALLIST+12
         CALL  COMPACT,((R14),CALLIST+12,(R8)),MF=(E,CALLIST)
         L     R14,CMPWRK          LOAD NEW RECORD POINTER
         AH    R0,=H'2'            ACCOUNT FOR LENGTH FIELD
         STCM  R0,7,0(R14)         STORE IN THE RECORD
         #ADDBLK BUFFER=1,                                             X
               RECORD=3(,R14),                                         X
               LENGTH=0(R14),                                          X
               RTN=VSPUT,                                              X
               ERR=TOOLONG
         B     UNLDLOOP            AND GO FOR ANOTHER RECORD
EOM      DS    0H
         #ADDBLK BUFFER=1,                                             X
               RTN=VSPUT,                                              X
               LAST=YES
         MVI   RECTT,#RTHDR        MARK AS A HEADER RECORD
         XC    RECSEQ#,RECSEQ#     CLOBBER THE SEQUENCE NUMBER
         MODCB RPL=(@RPL1),AREA=(@BUF1),ARG=(@BUF1),                   X
               AREALEN=(S,VS1LIM),                                     X
               OPTCD=(FKS,MVE,UPD),MF=(G,GENWK)
         GET   RPL=(@RPL1)         READ THE HEADER RECORD
         MVC   RSRRCNT,COUNT       MOVE RECORD COUNT TO HEADER RECORD
         L     R0,FCOUNT           LOAD TOTAL RECORD COUNT
         A     R0,COUNT            AND MEMBER SIZE
         ST    R0,FCOUNT           STORE UPDATED COUNT
         XC    COUNT,COUNT         AND RESET THE COUNTER
         PUT   RPL=(@RPL1)         UPDATE THE RECORD
         MODCB RPL=(@RPL1),OPTCD=NUP,MF=(G,GENWK)
         #FORMAT RECTT,,UNLDED
         #PUT  LINE
KILLED   DS    0H
         L     R9,CHAIN            LOAD THE CHAIN POINTER
         LTR   R9,R9               WAS THERE A CHAIN ??
         BZ    ENDITALL            NOPE; ALL DONE
         L     R8,4(,R9)           ALIAS LINK ??
         LTR   R8,R8               REALLY THERE ??
         BZ    FREE                NOPE ---
         #IF   RETA,OFF,FREE       NO AUTOMATIC ALIASES
         MODCB RPL=(@RPL1),AREA=(@BUF1),ARG=(@BUF1),                   X
               AREALEN=(S,VS1LIM),                                     X
               OPTCD=(FKS,MVE,UPD),MF=(G,GENWK)
         GET   RPL=(@RPL1)         READ THE HEADER RECORD
         #SET  RSRHALS,ON          SHOW THAT WE HAVE ALIASES
         PUT   RPL=(@RPL1)         UPDATE THE RECORD
         MODCB RPL=(@RPL1),OPTCD=NUP,MF=(G,GENWK)
         DROP  @BUF1
         USING REC,@BUF2
         MVC   RECAN(44),1(@BUF1)  COPY ORIGINAL KEY
         MVC   RECN(44),1(@BUF1)   BASIC ALIAS VALUES
         MVI   RECTT,#RTHDR        MARK AS A HEADER RECORD
         #SET  RSRALIAS,ON         SHOW THIS AS AN ALIAS
         MODCB RPL=(@RPL1),AREA=(@BUF2),ARG=(@BUF2),                   X
               RECLEN=RECAVER+4-REC,MF=(G,GENWK)
ADDA0    DS    0H
         MVC   RECVER,RECAVER      START WITH SAME VERSION VALUE
         MVC   RECN(8),8(R8)       MOVE IN THE ALIAS NAME
         MVC   RECN+8(2),=CL2' '
PUTA1    DS    0H
         PUT   RPL=(@RPL1)         OUTPUT THE ALIAS RECORD
         LTR   R15,R15             WRITE OK ??
         BZ    ADDA1               YES ---
         ICM   R15,15,RECVER       INSERT THE VERSION NUMBER
         BCTR  R15,R0              INCREMENT BY ONE
         STCM  R15,15,RECVER       SAVE UPDATED VERSION
         B     PUTA1               AND TRY AGAIN ---
ADDA1    DS    0H
         #FORMAT RECTT,,ALIASED
         #PUT  LINE
         L     R8,4(,R8)           POINT TO NEXT ALIAS LINK
         LTR   R8,R8               ALIAS PRESENT ??
         BNZ   ADDA0               YES; ADD IT
FREE     DS    0H
         MVC   CHAIN,0(R9)         UNLINK THE MAIN ENTRY
         B     MEMBERS             AND CONTINUE UNLOADING
ENDITALL DS    0H
         L     R0,TCOUNT           LOAD TOTAL RECORD COUNT
         A     R0,FCOUNT           ADD FUNCTION COUNT
         ST    R0,TCOUNT           SAVE UPDATED COUNT
         #ERR  MSG=7
         L     R0,TCOUNT           LOAD TOTAL-RECORD COUNT
         LTR   R0,R0               ZERO COUNT ??
         BZ    END1                YES ---
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
END1     DS    0H
         L     R0,MCNT             LOAD MEMBER COUNT
         LTR   R0,R0               ZERO COUNT ??
         BZ    END2                YES ---
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
END2     DS    0H
         L     R0,ACNT             LOAD ALIAS COUNT
         LTR   R0,R0               ZERO COUNT ??
         BZ    END3                YES ---
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
END3     DS    0H
         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??
         BE    NOACB               NOPE ---
         LA    R1,VSAM1DD          POINT TO THE DDNAME
         LA    R0,4                SET 'CLOSE' REQUEST
         CALL  ARCHVSOP            CALL THE VSAM 'CLOSE' ROUTINE
NOACB    DS    0H
         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE
         FREEMAIN R,SP=84
         L     R13,4(,R13)         LOAD BACK S.A. POINTER
         LM    R14,R12,12(R13)     RESTORE REGISTERS
         LA    R15,0               ALWAYS RC = 0
         MVI   12(R13),255
         BR    R14                 AND RETURN TO CALLER
         SPACE 3
*---------------------------------------------------------------------*
*---     IF WE REACH THIS LABEL, WE'VE GOT AT LEAST ONE RECORD     ---*
*---     THAT CANNOT BE MADE TO FIT IN THE OUTPUT ARCHIVE          ---*
*---     CLUSTER. ISSUE AN ERROR MESSAGE AND ERASE THE             ---*
*---     PARTIALLY-COPIED ITEM.                                    ---*
*---------------------------------------------------------------------*
TOOLONG  DS    0H
         #IF   IOGOING,OFF,NOWAIT  LET CURRENT I/O END
         CHECK PDSDECB
NOWAIT   DS    0H
         #SET  IOGOING,OFF
         #FORMAT 0(,@BUF2),'* ERROR *',LNGREC
         #PUT  LINE                PRINT THE ERROR
         LR    R1,@BUF2            POINT TO THE RECORD KEY
         CALL  ARCHERAS            DELETE PARTIAL ITEM
         B     KILLED              GO FOR ANOTHER ITEM
LNGREC   DC    AL1(LNGRECE-LNGRECS)
LNGRECS  DC    C' CANNOT BE UNLOADED. AT LEAST ONE RECORD IS TOO LONG.'
LNGRECE  EQU   *
         TITLE 'BPAM ''FIND'' ROUTINE'
*---------------------------------------------------------------------*
*---     THIS SHORT LITTLE ROUTINE DOES A 'FIND' FOR A MEMBER OF   ---*
*---     THE INPUT PARTITIONED DATASET.                            ---*
*---------------------------------------------------------------------*
PDSFIND  DS    0H
         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS
         XC    NOTELIST,NOTELIST   RESET NOTELIST TTR WORD
         MVC   BLOCKWDS(8),=A(1,0)
         #IF   NVSPO,OFF,NOFIND    NO FIND FOR NON-PO D.S.
         L     R3,NDCBA            LOAD BPAM DCB ADDRESS
         LA    R3,0(,R3)           FORCE IT POSITIVE ...
         TM    BLDLAREA+11,X'60'   ANY TTR'S IN USER DATA ??
         BNM   JSTFIND             NOPE ---
         MVC   NOTELIST,BLDLAREA+16 COPY NOTELIST TTR
         NC    NOTELIST,NOTELIST   ANY PRESENT ??
         BZ    JSTFIND             NOPE ---
         CLI   NOTELIST+3,0        REALLY A SCTR TABLE PTR ??
         BE    JSTFIND             YES ---
         MVI   NOTELIST+3,0        PURIFY THE TTRN VALUE
         POINT (3),NOTELIST        POINT TO THE NOTE LIST
         XC    PDSDECB,PDSDECB     CLEAR THE DECB AREA
         LM    R2,R3,BPBUF1        LOAD BUFFER ADDRESSES
         LR    R4,R2               AND SWITCH
         STM   R3,R4,BPBUF1        THE PDS BUFFERS
         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB
         L     R2,NDCBA            LOAD THE PDS DCB ADDRESS
         READ  PDSDECB,SF,(2),(4),'S',MF=E
         CHECK PDSDECB             YES, LET IT COMPLETE
         #SET  IOGOING,OFF
         NOTE  (2)                 READ THE BLOCK'S ADDRESS
         L     R2,PDSDECB+16       LOAD IOB ADDRESS
         L     R3,PDSDECB+8        LOAD DCB ADDRESS FROM DECB
         LH    R3,62(,R3)          LOAD PDS BLOCK SIZE
         SH    R3,14(,R2)          SUBTRACT CCW RESIDUAL COUNT
         L     R2,BPBUF2           LOAD BUFFER ADDRESS
         SH    R2,=H'4'            BACK UP TO 'NOTE' WORD
         ST    R1,0(,R2)           STORE BLOCK'S 'TTR'
         LA    R2,4(,R2)           RESTORE ORIGINAL VALUE
         AR    R3,R2               POINT TO END OF BUFFER
         BCTR  R3,R0               BACK UP A BYTE AT END
         STM   R2,R3,BLOCKWDS      STORE NEW BUFFER POINTERS
JSTFIND  DS    0H
         L     R3,NDCBA            LOAD BPAM DCB ADDRESS
         XC    GENWK(4),GENWK      CLEAR A SMALL AREA
         MVC   GENWK(3),BLDLAREA+8 COPY STARTING TTR
         POINT (3),GENWK           POINT OUT THE MEMBER
         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB
NOFIND   DS    0H
         LM    R2,R3,BPBUF1        LOAD BUFFER ADDRESSES
         LR    R4,R2               AND SWITCH
         STM   R3,R4,BPBUF1        THE PDS BUFFERS
         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB
         L     R2,NDCBA            LOAD THE PDS DCB ADDRESS
         READ  PDSDECB,SF,(2),(4),'S',MF=E
         #SET  IOGOING,ON          SHOW  READ OUTSTANDING
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO LOCAL CALLER
         SPACE 3
* SOME OF MY ERROR PROCESSING GOES HERE
NODDERR  DS    0H
         #ERR  MSG=1
         #ERR  MSG=6
         B     ENDITALL
ORGERR   DS    0H
         #ERR  MSG=3
         #ERR  MSG=6
         B     ENDITALL
ERRDEV   DS    0H
         #ERR  MSG=2
         #ERR  MSG=6
         B     ENDITALL
GENQ     DS    0H
         #ERR  MSG=8
         #ERR  MSG=6
         B     ENDITALL
GENSEQ   DS    0H
         #ERR  MSG=9
         #ERR  MSG=6
         B     ENDITALL
         TITLE 'OPEN NONVSAM INPUT DATASET '
*---------------------------------------------------------------------*
*---     THIS LITTLE LOCAL SUBROUTINE DOES SEVERAL THINGS          ---*
*---     NECESSARY PRIMARILY FOR LOAD-MODULE RECOGNITION AND       ---*
*---     PROCESSING. FIRST AND FOREMOST, WE DETERMINE THE DSORG    ---*
*---     OF THE INPUT DATASET.  IF INPUT IS A SEQUENTIAL DATASET,  ---*
*---     WE CAN ASSUME THAT ONLY ONE DCB WILL BE NEEDED.  IF THE   ---*
*---     INPUT DATASET IS A PDS, WE NEED AT LEAST TWO DCBS; ONE    ---*
*---     FOR DATA AND ANOTHER FOR THE DIRECTORY INFORMATION        ---*
*---     PROCESSED BY ARCHDIR.  HERE'S A VERY SIMPLISTIC VIEW OF   ---*
*---     THE PROCESSING HERE.  (FURTHER MODS FOR PROCESSING        ---*
*---     PANVALET LIBRARIES ARE PLANNED BUT NOT YET IMPLEMENTED.)  ---*
*---                                                               ---*
*---     1. DETERMINE THE DSORG OR THE DATASET. IF NOT PS OR PO,   ---*
*---        WRITE NASTY MESSAGES TO THE USER AND QUIT RIGHT HERE.  ---*
*---                                                               ---*
*---     2. BUILD AND OPEN THE PRIMARY DCB.  SINCE WE USE BSAM     ---*
*---        FOR INPUT OF SEQUENTIAL DATASETS, WE CAN (ALMOST) USE  ---*
*---        THE SAME DCB FOR BOTH SEQUENTIAL AND PARTITIONED       ---*
*---        DATASETS.  WE ONLY NEED TO CHANGE THE DSORG VALUE IN   ---*
*---        THE DCB.  DURING THE 'OPEN' PROCESS, AN EXIT WILL      ---*
*---        BUILD A BUFFER POOL OF TWO BUFFERS, EACH BUFFER        ---*
*---        HAVING 4 EXTRA BYTES. (THESE EXTRA BYTES ARE USED TO   ---*
*---        SAVE THE TTR OF THE RECORD AFTER EACH 'CHECK' BY THE   ---*
*---        READ ROUTINE.)  BUFFERS ARE 'GETBUF'ED AND SAVE IN     ---*
*---        THE ARCHIVER MAIN WORK AREA.                           ---*
*---                                                               ---*
*---     3. IF THE DSORG IS PO, WE NEED ONE ADDITIONAL STEP: READ  ---*
*---        IN THE DIRECTORY OF THE PDS, USING THE ARCHDIR         ---*
*---        ROUTINE. FOR THIS, WE NEED A SECOND DCB OPEN'ED FOR    ---*
*---        THE DIRECTORY ONLY. WE THEN CALL THE ARCHIDR ROUTINE,  ---*
*---        WHICH READS IN THE DIRECTORY AND PERFORMS ANY          ---*
*---        FILTERING OF NAMES AS SPECIFIED BY USER-SUPPLIED       ---*
*---        CONTROL STATEMENTS.                                    ---*
*---                                                               ---*
*---     NOTE: THE ARCHIVER MAKES NO ATTEMPT TO REASSEMBLE OR      ---*
*---     RECONSTRUCT A SPANNED RECORD.                             ---*
*---------------------------------------------------------------------*
         SPACE 3
OPNVI    DS    0H
         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS
*        #IF   NVPAN,ON,PANOPEN    REALLY A PANLIB ??
*---
*---     BUILD A DCB, TO START, FOR DSORG CHECKING
*---
         GETMAIN R,LV=BSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB
         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA
         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST
         MVC   0(BSDCBL,R1),BSDCB  COPY DCB TO DYNAMIC AREA
         USING IHADCB,R1           BASE THE DCB DSECT
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R1
*---
*---     GET THE VOLSER FROM THE UCB, STARTING FROM THE TIOT.
*---
         NC    TIOTA,TIOTA         HAVE WE ALREADY DONE THIS ??
         BNZ   OPNVI1              YES ---
         MVC   CALLIST(EXTL),EXTRPARM COPY PARMLIST FOR EXTRACT
         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT
         L     R1,TIOTA            LOAD THE TIOT POINTER
         LA    R1,24(,R1)          POINT TO THE FIRST TIOE
         ST    R1,TIOTA            SAVE UPDATED ADDRESS
OPNVI1   DS    0H
         L     R1,TIOTA            LOAD TIOT ELEMENT POINTER
OPNVI2   DS    0H
         CLI   0(R1),0             AT TIOT END ??
         BE    NODDERR             YES; DD STATEMENT IS MISSING
         CLC   NVSAMDD,4(R1)       IS THIS THE DD ENTRY ??
         BE    OPNVI3              YES; GO FETCH UCB ADDR
         IC    R0,0(,R1)           INSERT TIOE LENGTH
         N     R0,=F'255'          TRIM TO JUST THE LENGTH
         AR    R1,R0               BUMP TO NEXT ENTRY
         B     OPNVI2              AND CONTINUE THE SEARCH
OPNVI3   DS    0H
         L     R1,16(,R1)          LOAD UCB POINTER
         N     R1,=A(X'FFFFFF')    TRIM GARBAGE BYTES
         MVC   VOLSER,28(R1)       COPY THE VOLSER
         MVC   DEVT,16(R1)         AND UCB TYPE
         TM    DEVT+2,X'A0'        IS THIS A DASD OR TAPE DEVICE ??
         BZ    ERRDEV              NOPE; INVALID AS HELL
*---
*---     GET THE DSNAME. DISREGARD ANY MEMBER NAME
*---
         L     R2,NDCBA            LOAD THE DCB ADDRESS
         USING IHADCB,R2           AND BASE ITS DSECT
         LA    R0,DCBJFC           LOAD EXIT LIST POINTER
         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB
         LA    R0,JFC              POINT TO JFCB AREA
         ST    R0,DCBJFC           SAVE IN EXIT LIST
         MVI   DCBJFC,X'87'        EXIT TYPE, LAST FLAG
         RDJFCB ,MF=(E,NDCBA)      READ THE JFCB
         DROP  R2
*---
*---     BUILD AND EXECUTE THE CAMLIST/OBTAIN SEQUENCE IF DASD
*---     DATASET. USE THE FORMAT-1 DSCB TO DETERMINE IF THE
*---     DATASET IS PARTITIONED OR SEQUENTIAL.  IF THE DATASET
*---     IS SEQUENTIAL OR TAPE, WE BYPASS ANY BPAM STUFF.
*---
         TM    DEVT+2,X'80'        IS IT A TAPE DEVICE ??
         BO    OPNVI4              YES; ALWAYS SEQUENTIAL
         MVC   CALLIST(LCAMLST),CAMLST COPY CAMLIST TO WORK AREA
         LA    R0,JFC              LOAD DSNAME POINTER
         ST    R0,CALLIST+4        SAVE IN CAMLIST AREA
         LA    R0,VOLSER           POINT TO VOLSER
         ST    R0,CALLIST+8        SAVE IN CAMLIST AREA
         LA    R0,GENWK            POINT TO DSCB AREA
         ST    R0,CALLIST+12       SAVE IN CAMLIST AREA
         OBTAIN CALLIST            FETCH THE DSCB
         LA    R1,GENWK            POINT TO THE WORK AREA
         USING DS1FMTID,R1         AND BASE THE DSECT PORTION
         TM    DS1DSORG,DS1DSGPS   SEQUENTIAL ??
         BO    OPNVI4              YES ---
         TM    DS1DSORG,DS1DSGPO   PARTITIONED ??
         BO    OPNVI5              YES ---
         B     ORGERR              UNABLE TO PROCESS ANY OTHER DSORG
         DROP  R1
*---
*---     SET THE DSORG IN THE PRIMARY DCB ACCORDING TO THE VALUE
*---     FOUND IN THE FORMAT-1 DSCB.  ALSO, SET A PAIR OF SPECIAL
*---     FLAGS IN THE ARCHIVER WORK AREA.  THIS ALLOWS ME TO
*---     DETERMINE IF I'M REALLY PROCESSING A PDS, REQUIRING
*---     FIND'S, ETC. OR JUST BE WARY OF AN END-OF-FILE THAT WILL
*---     ULTIMATELY TERMINATE THE PROCESS.  IT ALSO DETERMINES
*---     WHETHER I NEED A DIRECTORY DCB, FOR LATER.
*---
OPNVI4   DS    0H
         #IF   GENM,ON,GENSEQ      INVALID GENERIC FOR PS DATASET
         #SET  NVSPS,ON            SET THE DSORG FLAG
         #SET  NVSPO,OFF           SET THE DSORG FLAG
         L     R2,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R2
         MVC   DCBDSORG,=XL2'00'   CLEAR DSORG BIT(S)
         OI    DCBDSRG1,DCBDSGPS   MARK AS 'PS' ORGANIZATION
         DROP  R2
         B     OPNVI6              GO SET UP THE VSAM I/O BLOCKS,ETC.
OPNVI5   DS    0H
         #SET  NVSPO,ON            SET THE DSORG FLAG
         #SET  NVSPS,OFF           SET THE DSORG FLAG
         L     R2,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R2
         MVC   DCBDSORG,=XL2'00'   CLEAR DSORG BIT(S)
         OI    DCBDSRG1,DCBDSGPO   MARK AS 'PO' ORGANIZATION
         DROP  R2
         GETMAIN R,LV=QSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB
         ST    R1,NDCBB            AND STORE ADDRESS IN ARCHIVWA
         MVI   NDCBB,X'80'         BUILD OPEN PARM LIST
         MVC   0(QSDCBL,R1),QSDCB COPY DCB TO DYNAMIC AREA
         USING IHADCB,R1           BASE THE DSECT
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R1                  DROP THE DSECT
         OPEN  (,INPUT),MF=(E,NDCBB) OPEN THE DIRECTORY DCB
         CALL  ARCHDIR             BUILD DIRECTORY CHAIN STUFF
OPNVI6   DS    0H
*---
*---     SET THE ADDRESS OF MY 'COMPLETION' EXIT INTO THE DCB AND
*---     PROCEED WITH THE NECESSARY OPEN, ETC.
*---
         L     R2,NDCBA            POINT TO PRIMARY DCB
         USING IHADCB,R2
         LA    R0,OPNVI13          LOAD EXIT LIST POINTER
         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB
         OPEN  (,INPUT),MF=(E,NDCBA) OPEN THE DCB
*---
*---     GRAB A PAIR OF BUFFERS FROM THE POOL BUILT DURING OPEN
*---     PROCESSING. WE ALWAYS USE BUFFERS THAT ARE 4 BYTES
*---     LONGER THAN THE BLKSIZE OF THE DATASET. AFTER EACH
*---     'CHECK', WE DO A 'NOTE' AND SAVE THE BLOCK'S TTR IN THIS
*---     'PREFIX' FOR LATER.  IT'S NECESSARY FOR RE-BUILDING THE
*---     NOTE LIST, IF PRESENT, IN A LOAD MODULE.  MORE ABOUT
*---     LOAD MODULES LATER.  AT THIS STAGE, WE ASSUME THAT WE
*---     ALWAYS NEED THE TTR.
*---
         GETBUF (2),(3)            GRAB A BUFFER
         GETBUF (2),(4)            AND ANOTHER BUFFER
         LA    R3,4(,R3)           POINT PAST 'PREFIX'
         LA    R4,4(,R4)           -- DITTO --
         STM   R3,R4,BPBUF1        SAVE POINTERS IN WORK AREA
         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY
         #SET  IOGOING,OFF         NO I/O IN PROGRESS
         MVC   BLOCK,=X'47F0E000'  INIT. THE DEBLOCKING BRANCH
         MVC   NVSRECFM,DCBRECFM
         MVC   NVSLRECL,DCBLRECL
         MVC   NVSBLKL,DCBBLKSI
         MVC   NVSDSORG,DCBDSORG
*---
*---     USING THE RECFM AS A GUIDE, SET THE S-TYPE ADDRESS OF
*---     THE APPROPRIATE DEBLOCKER INTO THE BRANCH INSTRUCTION AT
*---     'BLOCK'
*---
         TM    DCBRECFM,DCBRECU    U-FORMAT ??
         BNO   OPNVI7              NOPE ---
         MVC   BLOCK+2(2),=S(READU) SET 'U' ROUTINE
         B     OPNVI12             SCAT ---
OPNVI7   DS    0H
         TM    DCBRECFM,DCBRECV+DCBRECBR VB FORMAT ??
         BNO   OPNVI8              NOPE ---
         MVC   BLOCK+2(2),=S(READVB) SET 'VB' ROUTINE
         B     OPNVI12             SCAT ---
OPNVI8   DS    0H
         TM    DCBRECFM,DCBRECF+DCBRECBR FB FORMAT ??
         BNO   OPNVI9              NOPE ---
         MVC   BLOCK+2(2),=S(READFB) SET 'FB' ROUTINE
         B     OPNVI12             SCAT ---
OPNVI9   DS    0H
         TM    DCBRECFM,DCBRECV    V FORMAT ??
         BNO   OPNVI10             NOPE ---
         MVC   BLOCK+2(2),=S(READV) SET 'V' ROUTINE
         B     OPNVI12             SCAT ---
OPNVI10  DS    0H
         TM    DCBRECFM,DCBRECF    V FORMAT ??
         BNO   OPNVI11             NOPE ---
         MVC   BLOCK+2(2),=S(READF) SET 'F' ROUTINE
         B     OPNVI12             SCAT ---
OPNVI11  DS    0H
         #PUT  =CL133'- UNABLE TO DETERMINE NONVSAM DATASET FORMAT'
         ABEND 999,DUMP
OPNVI12  DS    0H
         L     R0,=F'32768'        LOAD COMPRESS MAX LENGTH
         ICM   R0,8,=AL1(10)       INSERT THE SUBPOOL NUMBER
         GETMAIN R,LV=(0)
         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS
         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS
         BR    R14                 AND RETURN TO LOCAL CALLER
*---
*---     THIS IS A SHORT AND SNEAKY DCB COMPLETION EXIT. ITS ONLY
*---     PURPOSE IS TO ESTABLISH THE BUFFER POOL FOR THE PRIMARY
*---     DCB. THIS POOL CONTAINS TWO BUFFERS, EACH BEING 4 BYTES
*---     LONGER THAN THE BLKSIZE OF THE DCB.
*---
*---     NOTE: THE GETPOOL ROUTINE WILL FAIL IF THE HIGH-ORDER
*---     BIT OF THE DCB ADDRESS IS NOT ZERO. SOME SPECIAL GLITCH
*---     IN THE IECQBFG1 CODE FOR A SPECIAL APPLICATION
*---     SOMEWHERE.
*---
OPNVI13  DS    0F
         DC    XL1'85',AL3(OPNVI13+4)
         LA    R1,0(,R1)           PURIFY DCB ADDRESS
         LH    R0,DCBBLKSI-IHADCB(,R1) LOAD THE BLKSIZE
         AH    R0,=H'4'            FOR LATER ---
         ICM   R0,12,=H'2'         BUFFER COUNT
         GETPOOL (1),(0)           BUILD A BUFFER POOL
         BR    R14                 AND RETURN TO O/C/EOV
         SPACE 3
BSDCB    DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=X,EODAD=EODAD
BSDCBL   EQU   *-BSDCB
QSDCB    DCB   DSORG=PS,MACRF=GL,DDNAME=Y,RECFM=U,BLKSIZE=256
QSDCBL   EQU   *-QSDCB
         TITLE 'BSAM/BPAM INPUT ROUTINES '
*---------------------------------------------------------------------*
*---     REGS AT ENTRY: R14 --> RETURN ADDRESS                     ---*
*---                                                               ---*
*---     REGISTERS 14, 15, AND 2-12 ARE SAVED AND RESTORED         ---*
*---                                                               ---*
*---          AT EXIT:                                             ---*
*---              R0 ::= LOGICAL RECORD LENGTH                     ---*
*---              R1 --> LOGICAL RECORD                            ---*
*---                                                               ---*
*---     EOF SIGNALLED BY A ZERO LOGICAL RECORD LENGTH             ---*
*---                                                               ---*
*---     IN THE SPECIAL CASE OF RECFM=U, R1 ACTUALLY POINTS TO A   ---*
*---     FULLWORD RECORD PREFIX CONTAINING THE TTR OF THE RECORD.  ---*
*---                                                               ---*
*---     THIS IS FOR LOAD MODULE PROCESSING AND CANNOT BE BYPASSED ---*
*---------------------------------------------------------------------*
READ     DS    0H
         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS
         LM    R2,R3,BLOCKWDS      LOAD BUFFER POINTER STUFF
         CR    R2,R3               PAST END OF BLOCK ??
         BH    READ2               YES, GO FOR THE NEXT BLOCK
READ1    DS    0H
         B     BLOCK               BRANCH TO DEBLOCKING ROUTINE
*---------------------------------------------------------------------*
*---     START PROCESSING A NEW BLOCK                              ---*
*---------------------------------------------------------------------*
READ2    DS    0H
         #IF   IOGOING,OFF,READ4   IS A READ IN PROGRESS ??
         CHECK PDSDECB             YES, LET IT COMPLETE
         L     R1,NDCBA            LOAD DCB ADDRESS
         NOTE  (1)                 READ THE BLOCK'S ADDRESS
         L     R2,PDSDECB+16       LOAD IOB ADDRESS
         L     R3,PDSDECB+8        LOAD DCB ADDRESS FROM DECB
         LH    R3,62(,R3)          LOAD PDS BLOCK SIZE
         SH    R3,14(,R2)          SUBTRACT CCW RESIDUAL COUNT
         CLC   NOTELIST,=F'0'      WAS THERE A NOTE LIST ??
         BE    READ3               NOPE ---
         CLM   R1,14,NOTELIST      WAS THIS IT ??
         BE    EODAD               YES; WE'RE ALL DONE
READ3    DS    0H
         L     R2,BPBUF2           LOAD BUFFER ADDRESS
         SH    R2,=H'4'            BACK UP TO 'NOTE' WORD
         ST    R1,0(,R2)           STORE BLOCK'S 'TTR'
         LA    R2,4(,R2)           RESTORE ORIGINAL VALUE
         AR    R3,R2               POINT TO END OF BUFFER
         BCTR  R3,R0               BACK UP A BYTE AT END
         L     R14,NDCBA           LOAD DCB ADDRESS
         USING IHADCB,R14
         TM    DCBRECFM,DCBRECV+DCBRECBR VB RECORD FORMAT ??
         BNO   *+8                 NOPE ---
         DROP  R14
         LA    R2,4(,R2)           YES; ACCOUNT FOR BDW
         STM   R2,R3,BLOCKWDS      STORE NEW BUFFER POINTERS
READ4    DS    0H
         LM    R2,R3,BPBUF1        LOAD BUFFER ADDRESSES
         LR    R4,R2               AND SWITCH
         STM   R3,R4,BPBUF1        THE PDS BUFFERS
         XC    PDSDECB(DECBL),PDSDECB  CLEAR OUT THE ECB
         L     R2,NDCBA            LOAD THE PDS DCB ADDRESS
         READ  PDSDECB,SF,(2),(4),'S',MF=E
         #SET  IOGOING,ON          SHOW  READ OUTSTANDING
         LM    R2,R3,BLOCKWDS
         B     READ1               AND GO START DEBLOCKING
*---------------------------------------------------------------------*
*---     END OF FILE (OR END OF MEMBER) EXIT RTN                   ---*
*---------------------------------------------------------------------*
EODAD    DS    0H
         #SET  IOGOING,OFF         TURN OFF THE DEBLOCKING FLAG
         LM    R14,R12,IOSAVE      RESTORE ENTRY REGISTERS
         LA    R0,0
         LA    R1,0
         BR    R14                 AND RETURN TO CALLER
*---------------------------------------------------------------------*
*---     FIXED, UNBLOCKED RECORDS.                                 ---*
*---------------------------------------------------------------------*
READF    DS    0H
         LA    R1,0(,R2)           LOAD LRECL POINTER
         LA    R0,0                CLEAR A REGISTER
         L     R15,NDCBA           LOAD DCB ADDRESS
         LH    R0,62(,R15)         LOAD BLKSIZE
         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD
         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF
         STM   R0,R1,IOSAVE+8      SET RETURN VALUES
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
*---------------------------------------------------------------------*
*---     FIXED, BLOCKED RECORDS.                                   ---*
*---------------------------------------------------------------------*
READFB   DS    0H
         LA    R1,0(,R2)           LOAD LRECL POINTER
         L     R15,NDCBA           LOAD DCB ADDRESS
         LH    R0,82(,R15)         LOAD LRECL FROM DCB
         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD
         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF
         STM   R0,R1,IOSAVE+8      SET RETURN VALUES
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
*---------------------------------------------------------------------*
*---     VARIABLE, UNBLOCKED RECORDS.                              ---*
*---------------------------------------------------------------------*
READV    DS    0H
         LA    R1,4(,R2)           LOAD LRECL POINTER
         LH    R0,0(,R2)           LOAD LRECL FOR RETURN
         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD
         SH    R0,=H'4'            ACCOUNT FOR RDW WORD
         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF
         STM   R0,R1,IOSAVE+8      SET RETURN VALUES
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
*---------------------------------------------------------------------*
*---     VARIABLE, BLOCKED RECORDS.                                ---*
*---------------------------------------------------------------------*
READVB   DS    0H
         LA    R1,4(,R2)           LOAD LRECL POINTER
         LH    R0,0(,R2)           LOAD LRECL FOR RETURN
         AR    R2,R0               BUMP TO NEXT LOGICAL RECORD
         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF
         SH    R0,=H'4'            ACCOUNT FOR RDW
         STM   R0,R1,IOSAVE+8      SET RETURN VALUES
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
*---------------------------------------------------------------------*
*---     UNDEFINED-FORMAT RECORDS.                                 ---*
*---------------------------------------------------------------------*
READU    DS    0H
         LA    R0,1(,R3)           COPY RECORD END ADDRESS
         SR    R0,R2               SUBTRACT STARTING ADDRESS
         AH    R0,=H'4'            ACCOUNT FOR 'NOTE' WORD
         LA    R1,0(,R2)           LOAD LRECL POINTER
         SH    R1,=H'4'            BACK UP TO 'NOTE' WORD
         LA    R2,1(,R3)           POINT TO NEXT(HA HA) RECORD
         STM   R2,R3,BLOCKWDS      RESAVE POINTER STUFF
         STM   R0,R1,IOSAVE+8      SET RETURN VALUES
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 RETURN TO CALLER
         TITLE 'BSAM/BPAM CLOSE ROUTINE'
*---------------------------------------------------------------------*
*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET (ALL       ---*
*---     DCB'S), RELEASES ALL BUFFER POOLS, RESETS POINTER         ---*
*---     VALUES, RELEASE THE COMPRESSION WORK AREA AND CLEANS UP   ---*
*---     THE NONVSAM I/O IN GENERAL, INCLUDING THE RESETING OF     ---*
*---     ANY FLAG BITS.                                            ---*
*---------------------------------------------------------------------*
         SPACE 3
NVSCLOSE DS    0H
         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS
         L     R2,NDCBA            LOAD PRIMARY DCB ADDRESS
         LA    R2,0(,R2)           PURIFY THE ADDRESS
         LTR   R2,R2               ZERO ??
         BZ    NVC1                YES; NO DCB HERE ---
         CLOSE MF=(E,NDCBA)        CLOSE THE DCB
         #FREE (2)                 RELEASE BUFFER POOL, IF ANY
         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD
NVC1     DS    0H
         L     R2,NDCBB            LOAD PRIMARY DCB ADDRESS
         LA    R2,0(,R2)           PURIFY THE ADDRESS
         LTR   R2,R2               ZERO ??
         BZ    NVC2                YES; NO DCB HERE ---
         MVI   NDCBB,X'80'         BUILD OPEN PARM LIST
         CLOSE MF=(E,NDCBB)        CLOSE THE DCB
         #FREE (2)                 RELEASE BUFFER POOL, IF ANY
         XC    NDCBB,NDCBB         AND RESET THE POINTER FIELD
NVC2     DS    0H
         XC    DEVT,DEVT           CLEAR SAVED VALUES
         XC    NVSDSORG,NVSDSORG
         XC    VOLSER,VOLSER
         XC    BLOCKWDS(8),BLOCKWDS
         XC    NVSRECFM,NVSRECFM
         XC    NVSBLKL,NVSBLKL
         XC    NVSLRECL,NVSLRECL
         XC    BPBUF1,BPBUF1
         XC    BPBUF2,BPBUF2
         LM    R0,R1,CMPWRKL       LOAD COMPRESSION AREA LENGTH/PTR
         LTR   R0,R0               NULL LENGTH ??
         BZ    NVC2A               YES; NO FREEMAIN
         XC    CMPWRKL(8),CMPWRKL
NVC2A    DS    0H
         NC    SAVETTR,SAVETTR     ANY TTR CHAIN ??
         BZ    NVC3                NOPE ---
         XC    SAVETTR,SAVETTR
NVC3     DS    0H
         MVC   BLOCK+2(2),=S(0(R14))
         #SET  IOGOING,OFF
         #SET  BUFUSED,OFF
         #SET  TRUNC,OFF
         #SET  NVSPS,OFF
         #SET  NVSPO,OFF
         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS
         BR    R14                 AND RETURN TO CALLER
         TITLE 'VSAM I/O OUTPUT '
*---------------------------------------------------------------------*
*---     THIS LITTLE LOCAL SUBROUTINE DOES ALL THE VSAM WRITING    ---*
*---     FOR THE UNLOAD FUNCTION, WITH THE EXCEPTION OF THE        ---*
*---     ERASURE OF A DUPLICATE ITEM.  THE BASIC ASSUMPTIONS ARE   ---*
*---     THAT THE RECORD ADDRESS IS IN R1 AND THE LENGTH IS IN     ---*
*---     R0.  THE INITIAL-LOAD CONDITION NEED NOT BE HANDLED       ---*
*---     HERE, SINCE THE OPEN ROUTINE TAKES CARE OF ALL THAT.      ---*
*---------------------------------------------------------------------*
VSPUT    DS    0H
         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS
         L     R4,RPL1             LOAD RPL ADDRESS
         LR    R5,R1               LOAD BUFFER ADDRESS
         LR    R6,R0               LOAD RECORD LENGTH
         MODCB RPL=(4),            RPL ADDRESS                         X
               OPTCD=(DIR,FKS,NUP,MVE,KEQ), OPTION CODES ---           X
               ARG=(5),            KEY ADDRESS                         X
               AREA=(5),           BUFFER ADDRESS                      X
               RECLEN=(6),         RECORD LENGTH                       X
               MF=(G,GENWK)
         PUT   RPL=(4)             OUTPUT THE VSAM RECORD
         LR    R3,R15              SAVE THAT RETURN CODE
         SHOWCB RPL=(4),                                               X
               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X
               AREA=(S,DWORK),                                         X
               LENGTH=4,                                               X
               MF=(G,GENWK)        GET RECORD LENGTH
         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE
         B     VSPUT6              ALL IS OK
         B     VSPUT2              RPL SHOWS SOMETHING HAPPENING
         B     VSPUT4              LOGICAL ERROR
         B     VSPUTDIE            PHYSICAL ERROR
VSPUT2   DS    0H
         LA    R8,0                CLEAR A COUNTER REGISTER
VSPUT3   DS    0H
         CH    R8,=H'3'            PAST THE LIMIT YET ??
         BH    VSPUTDIE            YES ---
         LA    R8,1(,R8)           NOPE; INCREMENT COUNTER
         CHECK RPL=(4)             LET PENDING I/O COMPLETE
         PUT   RPL=(4)             OUTPUT THE VSAM RECORD
         LR    R3,R15              SAVE THAT RETURN CODE
         SHOWCB RPL=(4),                                               X
               FIELDS=FDBK,        FETCH THE RPL FEEDBACK FIELD        X
               AREA=(S,DWORK),                                         X
               LENGTH=4,                                               X
               MF=(G,GENWK)        GET RECORD LENGTH
         B     *+4(R3)             CHECK THE 'PUT' RETURN CODE
         B     VSPUT6              ALL IS OK
         B     VSPUT3              RPL SHOWS SOMETHING HAPPENING
         B     VSPUT4              LOGICAL ERROR
         B     VSPUTDIE            PHYSICAL ERROR
VSPUT4   DS    0H                  LOGICAL ERROR HAS OCCURED
         CLI   DWORK+3,8           DUPLICATE KEY ??
         BNE   VSPUT5              NOPE ---
         LA    R15,4               LOAD THE RETURN CODE
         B     VSPUT6              AND TERMINATE
VSPUT5   DS    0H
         CLI   DWORK+3,116         INITIAL LOAD IN PROGRESS ??
         BNE   VSPUTDIE            NOPE; SOME OTHER ERROR
         MODCB RPL=(4),            RPL ADDRESS                         X
               OPTCD=(SEQ,NUP,MVE,KEQ), OPTION CODES ---               X
               MF=(G,GENWK)
         LR    R7,R15
         PUT   RPL=(4)             RE-DO THE PUT
         LTR   R15,R15             OK NOW ??
         BNZ   VSPUTDIE            NOPE; STILL SHAFTED
         CLOSE ,MF=(E,ACB1)        CLOSE THE CLUSTER
         OPEN  ,MF=(E,ACB1)        AND RE-OPEN THE CLUSTER
VSPUT6   DS    0H
         L     R14,IOSAVE          RELOAD R14
         LM    R0,R12,IOSAVE+8     RESTORE OTHER REGS
         BR    R14                 AND RETURN TO CALLER
VSPUTDIE DS    0H
*        WTO   'ARCHIVER --- VSAM I/O ERROR. R4 --> RPL',ROUTCDE=11
         ABEND 100,DUMP
TCMSG    DC    CL133' '
         ORG   TCMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    C' TOTAL LOGICAL RECORDS PROCESSED.'
         ORG
MCMSG    DC    CL133' '
         ORG   MCMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    C' TOTAL MEMBER(S) PROCESSED.'
         ORG
ACMSG    DC    CL133' '
         ORG   ACMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    C' TOTAL ALIAS(ES) PROCESSED.'
         ORG
         LTORG
UNLDED   DC    AL1(UNLMSGE-UNLMSG)
UNLMSG   DC    C' SUCCESSFULLY UNLOADED.'
UNLMSGE  EQU   *
ALIASED  DC    AL1(ALIASEDE-ALIASEDS)
ALIASEDS DC    C' ALIAS HAS BEEN ASSIGNED.'
ALIASEDE EQU   *
MINREC   DC    A(RECSIZE)
CAMLST   CAMLST SEARCH,0,0,0
LCAMLST  EQU   *-CAMLST
EXTRPARM EXTRACT ,'S',FIELDS=TIOT,MF=L
EXTL     EQU   *-EXTRPARM
         READ  DECB,SF,0,0,0,MF=L
DECBL    EQU   *-DECB
         DCBD  DSORG=(PS,PO)
         IECSDSL1 (1)
         COPY  #RECS
         COPY  ##ARCHWK
         END
