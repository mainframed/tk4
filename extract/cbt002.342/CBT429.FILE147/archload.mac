LOAD     TITLE 'ARCHIVER --- LOAD FUNCTION'
*---------------------------------------------------------------------*
*---     THIS ROUTINE IS THE SECOND HALF OF THE ARCHIVER'S REASON  ---*
*---     FOR EXISTANCE: THE INFAMOUS LOAD FUNCTION.  THIS ROUTINE  ---*
*---     WAS MODIFIED IN LEVEL 4.1 TO ALLOW FOR THE POSSIBILITY    ---*
*---     OF ARCHIVER-TYPE ALIASES BEING SELECTED AS PART OF THE    ---*
*---     SELECTION CRITERIA.  IF WE GET AN ARCHIVER-TYPE ALIAS     ---*
*---     SELECTED, WE HAVE SOME ADDITIONAL 'SPECIAL' PROCESSING    ---*
*---     TO AVOID DUPLICATE LOADS.                                 ---*
*---                                                               ---*
*---     WHAT WE DO FOR A SELECTED 'ALIAS' IS THIS.  FIRST, WE     ---*
*---     CHECK THE 'REAL' NAME AGAINST THE ENTRIES IN A            ---*
*---     SINGLY-LINKED CHAIN IN STORAGE.  IF THE REAL NAME IS      ---*
*---     ALREADY PRESENT, WE IGNORE THIS ALIAS AND CONTINUE. IF    ---*
*---     NOT, WE'LL ADD THE 'REAL' NAME TO THE CHAIN AND LOAD THE  ---*
*---     'REAL' ITEM, RESTORING ALIASES AS APPROPRIATE.            ---*
*---------------------------------------------------------------------*
ARCHLOAD CSECT
R0       EQU   0                   R
R1       EQU   1                    E
R2       EQU   2                     G
R3       EQU   3                      I
R4       EQU   4                       S
R5       EQU   5                        T
R6       EQU   6                         E
R7       EQU   7                          R
R8       EQU   8
R9       EQU   9                   E
R10      EQU   10                   Q
R11      EQU   11                    U
R12      EQU   12                     A
R13      EQU   13                      T
R14      EQU   14                       E
R15      EQU   15                        S
@RPL1    EQU   R2                  SOME
@RPL2    EQU   R3                    SPECIAL
@BUF1    EQU   R4                        EQUATES
@BUF2    EQU   R5                          FOR
@BUF3    EQU   R6                            VSAM I/O
         COPY #ARCBITS
         USING ARCHLOAD,R15
         #STAMP
         STM   R14,R12,12(R13)     STORE ENTRY REGISTERS
         LR    R11,R15             LOAD ROUTINE BASE REGISTER
         DROP  R15                 DROP THE OLD BASE
         USING ARCHLOAD,R11        DEFINE THE NEW BASE REGISTER
         LA    R14,72(,R13)        POINT DOWN THE SAVE AREA STACK
         ST    R14,8(,R13)         STORE FORWARD POINTER
         ST    R13,4(,R14)         AND BACK POINTER
         LR    R13,R14             LOAD NEW SAVE AREA POINTER
         L     R14,4(,R13)         RELOAD BACK POINTER
         L     R14,12(,R14)        RELOAD ORIG. REG 14
         LA    R10,0(,R11)         COPY ORIGINAL BASE REGISTER
         AH    R10,PASSIT-2        BUMP BY A BASE'S WORTH
         USING ARCHLOAD+4096,R10   AND DECLARE IT
         USING MAINWK,R12          BASE THE MAIN WORK AREA
         XC    NAMEPOOL,NAMEPOOL   RESET THE POOL ID FIELD
         XC    NAMECHN,NAMECHN     AND THE 'REAL' NAME CHAIN ROOT
         XC    FCOUNT,FCOUNT       CLEAR FUNCTION RECORD COUNT
         XC    MCNT,MCNT           AND MEMBER COUNT
         XC    ACNT,ACNT           AND ALIAS COUNT
         LA    R0,0                LOAD 'OPEN' INDICATOR
         LA    R1,VSAM1DD          LOAD PARM POINTER
         CALL  ARCHVSOP            GO OPEN THE INPUT CLUSTER
         LTR   R15,R15             DID IT OPEN OK ??
         BNZ   ENDITALL            NOPE; QUIT RIGHT HERE
*---------------------------------------------------------------------*
*---     NOW OPEN THE NON-VSAM DATASET. THE OPEN ROUTINE WILL      ---*
*---     SET THE BLOCKER/DEBLOCKER BRANCH.                         ---*
*---------------------------------------------------------------------*
         BAL   R14,OPNVO           CALL THE OPEN ROUTINE
         EJECT
*---------------------------------------------------------------------*
*---     HERE'S THE MEAT OF THE PROCESSING. THE BASIC PROCESS IS   ---*
*---           THIS:                                               ---*
*---                                                               ---*
*---     1. USING THE CONTROL INFORMATION WE WERE GIVEN AND THE    ---*
*---        INFORMATION WE'VE DEVELOPED, LOCATE THE HEADER RECORD  ---*
*---        FOR THE FIRST MEMBER. WE'LL USE THE VS1BUF2 AREA FOR   ---*
*---        HEADER/KEY CONSTRUCTION.                               ---*
*---                                                               ---*
*---     2. LOOP THROUGH THE MEMBER, READING THE RECORDS AND       ---*
*---        EXPLODING THEM INTO THE BPAM BUFFERS, WRITING AS EACH  ---*
*---        BUFFER GETS FULL.  THE I/O ROUTINES DESIGNATED BY THE  ---*
*---        BRANCH INSTRUCTION AT 'BLOCK' WILL DETERMINE THE       ---*
*---        BLOCKING MECHANISM USED.                               ---*
*---                                                               ---*
*---     3. AT END-OF-FILE FOR THE DATASET OR MEMBER, DO ANY STOW  ---*
*---        THAT MAY BE APPROPRIATE.  FOR PDS MEMBERS WITH         ---*
*---        ALIASES, WE ALSO STOW THE ALIASES AT THIS POINT.       ---*
*---------------------------------------------------------------------*
         L     @RPL1,RPL1          LOAD THE VSAM REGS
         L     @RPL2,RPL2
         L     @BUF1,VS1BUF1
         L     @BUF2,VS1BUF2
         LA    @BUF3,0
         USING REC,@BUF1           BASE THE RECORD DSECT
         XC    0(RECKLEN,@BUF1),0(@BUF1) START AT THE BEGINNING !!
         MVI   RECTT,#RTHDR        WE ONLY WANT HEADERS
         MODCB RPL=(@RPL1),                                            X
               OPTCD=(SEQ,FKS,KGE,SYN),                                X
               ARG=(@BUF1),                                            X
               AREA=(@BUF1),                                           X
               AREALEN=(*,VS1LIM),                                     X
               MF=(G,GENWK)        POSITION TO CLUSTER START
         POINT RPL=(@RPL1)         GET TO IT
NEXTHDR  DS    0H
         GET   RPL=(@RPL1)         AND READ A HEADER RECORD
         SHOWCB RPL=(@RPL1),                                           X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN1),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         CLI   RECTT,#RTHDR        HEADER RECORD ??
         BNE   ENDITALL            NOPE; ALL DONE ---
         LA    R1,RECN             POINT TO THE HEADER
         LA    R0,0                USE DEFAULT QUALIFIER DATA
         CALL  ARCHKNAM            GO CHECK: DO WE PROCESS THIS ITEM ??
         LTR   R15,R15             PASS THE CHECK ??
         BNZ   NEXTHDR             NOPE ---
         #IF   RSRALIAS,OFF,REAL   NOT AN ALIAS RECORD
         #IF   LDARCHA,OFF,NEXTHDR SKIP IF NOT CHECK ARCHIVE ALIASES
         LR    @BUF3,@BUF1         COPY THE RECORD POINTER
         L     @BUF1,VS1BUF3       START A FRESH BUFFER
         MVC   RECN(44),RECAN-REC(@BUF3) GET 'REAL' QUALIFIERS
         MVI   RECTT,#RTHDR        SET FOR A HEADER RECORD
         MODCB RPL=(@RPL1),ARG=(@BUF1),AREA=(@BUF1),MF=(G,GENWK)
         POINT RPL=(@RPL1)
         GET   RPL=(@RPL1)         READ THE 'REAL' HEADER
         SHOWCB RPL=(@RPL1),                                           X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN1),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         CLC   1(44,@BUF1),RECAN-REC(@BUF3) RIGHT RECORD ??
         BE    REAL                YES; CONTINUE
         L     @BUF1,VS1BUF1       RELOAD BUFFER POINTER
         LA    @BUF3,0
         B     LDDN2               AND SCAT ---
REAL     DS    0H
         LA    R1,RECTT            POINT TO THE HEADER RECORD AGAIN
         CALL  ARCHKDCB            GO COMPARE DCB'S
         LTR   R15,R15             STILL OK ??
         BNZ   LDDN1A              NOPE; SKIP THIS ITEM
         LA    R1,RECN             POINT TO NAME START
         BAL   R14,CHKCHN          GO CHECK: DONE ALREADY ??
         LTR   R15,R15             CHECKED OUT OK ??
         BNZ   LDDN1A              NOPE; SKIP THIS ITEM
         LA    R1,RECN             POINT TO ITEM NAME
         BAL   R14,CHAINER         ADD IT TO MY CHAIN
         LTR   @BUF3,@BUF3         WAS LOAD TRIGGERED BY AN ALIAS ??
         BZ    NOTRIG              NOPE ---
         #FORMAT 0(@BUF1),,TRIGGER OUTPUT THE 'TRIGGER' MESSAGE
         #PUT  LINE
NOTRIG   DS    0H
         #IF   NVSPO,OFF,NOTPO     CHECK THE DSORG FLAG
         #IF   REPL,ON,NOTPO       REPLACE ANYHOW
         MVC   BLDLAREA(4),=AL2(1,76)
         MVC   BLDLAREA+4(8),RECN  COPY THE MEMBER NAME IN
         L     R1,NDCBA            LOAD THE DCB ADDRESS
         BLDL  (1),BLDLAREA        CHECK: IS THE MEMBER THERE ??
         LTR   R15,R15             WAS IT FOUND ??
         BNZ   NOTPO               NOPE; CONTINUE ---
         #FORMAT RECTT,,STOWM1
         #PUT  LINE
         B     LDDN1A              AND GO FORMAT THE MESSAGE
NOTPO    DS    0H
         CLI   RSRDSO,DCBDSGPO     IS IT A PO MEMBER UNLOADED ??
         BNE   NODIR               NOPE ---
         LA    R1,0                CLEAR A WORK REGISTER
         IC    R1,RSRPDIR+11       LOAD DIR ENTRY LENGTH
         N     R1,=A(X'1F')        TRIM TO BARE LENGTH
         SLL   R1,1                TIMES TWO
         LA    R1,11(,R1)          COMPUTE TOTAL ENTRY LENGTH
         EX    R1,NODIR-6          COPY DIR TO BLDLAREA
         B     NODIR               AND GO ---
         MVC   BLDLAREA(1),RSRPDIR 'EX'ED COPY OF DIR ENTRY
NODIR    DS    0H
         MVC   @BYTEC,@RSRFLG1     SAVE VERSION #                  V6.0
         LA    R1,RECTT            COPY THE HEADER ADDRESS
         BAL   R14,IOSEP           GO DO A SEPARATOR (MAYBE)
         DROP  @BUF1
         USING REC,@BUF2
         MVC   0(RECKLEN,@BUF2),0(@BUF1) COPY THAT KEY
         MVI   RECTT,#RTDATA       RESET TO DATA TYPE
         MODCB RPL=(@RPL2),                                            X
               OPTCD=(SEQ,FKS,KGE,SYN),                                X
               ARG=(@BUF2),                                            X
               AREA=(@BUF2),                                           X
               AREALEN=(*,VS1LIM),                                     X
               MF=(G,GENWK)        POSITION TO ITEM DATA START
         POINT RPL=(@RPL2)         GET TO IT
LDLOOP   DS    0H
         GET   RPL=(@RPL2)         GO READ A MEMBER DATA RECORD
         LTR   R15,R15             DID IT COMPLETE OK ??
         BNZ   LDDONE              NOPE; ASSUME WE'RE DONE
         SHOWCB RPL=(@RPL2),                                           X
               FIELDS=RECLEN,                                          X
               AREA=(S,VS1LEN2),                                       X
               LENGTH=4,                                               X
               MF=(G,GENWK)        FETCH THE RECORD LENGTH
         CLI   RECTT,#RTDATA       DATA RECORD ??
         BNE   LDDONE
         CLC   1(RECKLEN-5,@BUF2),1(@BUF1) STILL IN THE RIGHT ITEM ??
         BNE   LDDONE              NOPE; DO STOWS 'N' STUFF
         LA    R9,RDATDATA         POINT TO ITEM DATA
         L     R8,VS1LEN2          LOAD RECORD LENGTH
         LA    R8,0(R8,@BUF2)      POINT TO
         BCTR  R8,R0                 LAST DATA BYTE
WRTLOOP  DS    0H
         L     R0,TCOUNT           LOAD THE RECORD COUNT
         A     R0,=F'1'            COUNT THIS RECORD
         ST    R0,TCOUNT           STORE UPDATED COUNT
         LA    R0,0                CLEAR REGISTER ZERO
         ICM   R0,7,0(R9)          LOAD SEGMENT LENGTH
         LA    R1,3(,R9)           POINT TO SEGMENT START
         BAL   R14,PUT             GO WRITE A LOGICAL RECORD
         LA    R0,0                CLEAR REGISTER ZERO
         ICM   R0,7,0(R9)          LOAD SEGMENT LENGTH
         AR    R9,R0               BUMP TO
         LA    R9,3(,R9)             NEXT SEGMENT
         CR    R9,R8               ANOTHER SEGMENT TO PROCESS ??
         BL    WRTLOOP             YES ---
         B     LDLOOP              NOPE ---
LDDONE   DS    0H
         #SET  NOEXP,ON            NOTE LIST ALREADY EXPANDED
         L     R1,NOTELIST         LOAD NOTELIST POINTER
         LTR   R1,R1               WAS ANY PRESENT ??
         BZ    LDDN1               NOPE ---
         L     R0,0(,R1)           LOAD ITS LENGTH
         SH    R0,=H'4'            ACCOUNT FOR TTR WORD
         LA    R1,4(,R1)           POINT TO ACTUAL DATA
         BAL   R14,PUT             GO WRITE THE NOTE LIST
         L     R1,NOTELIST
         L     R0,0(,R1)           LOAD ITS LENGTH
         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER
         FREEMAIN R,LV=(0),A=(1)
LDDN1    DS    0H
         #SET  NOEXP,OFF
         XC    NOTELIST,NOTELIST   AND RESET THE POINTER
         LA    R0,0                ZERO LENGTH RECORD
         BAL   R14,PUT             AND PURGE THE BUFFERS
         DROP  @BUF2
         USING REC,@BUF1
         LR    R0,@BUF1            COPY RECORD ADDRESS
         A     R0,VS1LEN1          POINT TO RECORD END
         LA    R1,RSRPDIR          POINT TO DIRECTORY DATA
         SR    R0,R1               COMPUTE DIRDATA LENGTH
         BAL   R14,ENDSEP          TRAILING SEPARATORS FOR PS OUTPUT
         BAL   R14,PDSSTOW         GO DO STOWS (MAYBE)
LDDN1A   DS    0H
         LTR   @BUF3,@BUF3         WAS LOAD TRIGGERED BY AN ALIAS ??
         BZ    LDDN2               NOPE ---
         LR    @BUF1,@BUF3         RESTORE TO ALIAS VALUE
         LA    @BUF3,0             RESET THE INDICATOR
LDDN2    DS    0H
         LA    R15,0               CLEAR A WORK REGISTER
         IC    R15,RECT+9
         LA    R15,1(,R15)
         STC   R15,RECT+9
         MODCB RPL=(@RPL1),AREA=(@BUF1),ARG=(@BUF1),MF=(G,GENWK)
         POINT RPL=(@RPL1)
         #IF   GENM,ON,NEXTHDR     LOOP IF GENERIC NAME
         #IF   GENG,ON,NEXTHDR     LOOP IF GENERIC GROUP
         #IF   GENSG,ON,NEXTHDR    LOOP IF GENERIC SUBGROUP
         #IF   GENT,ON,NEXTHDR     LOOP IF GENERIC TYPE
         DROP  @BUF1
ENDITALL DS    0H
         NC    NAMEPOOL,NAMEPOOL   ANY NAME POOL ??
         BZ    NOPOOL              NOPE ---
         L     R0,NAMEPOOL         LOAD TOKEN VALUE
         CALL  CELLDEL             GO DELETE THE CELL POOL
NOPOOL   DS    0H
         XC    NAMEPOOL,NAMEPOOL   RESET THE FIELD
         XC    NAMECHN,NAMECHN     AND THE CHAIN ROOT
         L     R0,TCOUNT           LOAD TOTAL RECORD COUNT
         A     R0,FCOUNT           ADD FUNCTION COUNT
         ST    R0,TCOUNT           SAVE UPDATED COUNT
         #ERR  MSG=10
         L     R0,TCOUNT           LOAD TOTAL-RECORD COUNT
         LTR   R0,R0               ANY VALUES TO CONVERT ??
         BZ    CLOSES              NOPE ---
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,TCMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
         L     R0,MCNT             LOAD MEMBER COUNT
         LTR   R0,R0               ANY VALUES TO CONVERT ??
         BZ    CLOSES              NOPE ---
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,MCMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
         L     R0,ACNT             LOAD ALIAS COUNT
         LTR   R0,R0               ANY VALUES TO CONVERT ??
         BZ    CLOSES              NOPE ---
         CVD   R0,DWORK            DECIMALIZE IT
         MVC   LINE,ACMSG          COPY IN THE MESSAGE SKELETON
         ED    LINE+2(20),DWORK    ADD IN THE ACTUALS
         #PUT  LINE                AND OUTPUT THE RESULTS
CLOSES   DS    0H
         CLC   ACB1,=F'0'          WAS ACB EVER OPENED ??
         BE    NOACB               NOPE ---
         LA    R1,VSAM1DD          LOAD PARM POINTER
         LA    R0,4                LOAD 'CLOSE' INDICATOR
         CALL  ARCHVSOP            CALL THE 'CLOSE' ROUTINE
NOACB    DS    0H
         BAL   R14,NVSCLOSE        GO CLOSE THE INPUT FILE
         FREEMAIN R,SP=10          RELEASE ALL MY STORAGE
         L     R13,4(,R13)         LOAD BACK S.A. POINTER
         LM    R14,R12,12(R13)     RESTORE REGISTERS
         LA    R15,0               ALWAYS RC = 0
         MVI   12(R13),255
         BR    R14                 AND RETURN TO CALLER
         TITLE 'OPEN NONVSAM OUTPUT DATASET '
*---------------------------------------------------------------------*
*---     THIS LITTLE LOCAL SUBROUTINE DOES SEVERAL THINGS          ---*
*---     NECESSARY PRIMARILY FOR LOAD-MODULE RECOGNITION AND       ---*
*---     PROCESSING. FIRST AND FOREMOST, WE DETERMINE THE DSORG    ---*
*---     OF THE OUTPUT DATASET. IF OUTPUT IS A SEQUENTIAL          ---*
*---     DATASET, WE CAN ASSUME THAT ONLY ONE DCB WILL BE NEEDED.  ---*
*---     IF THE OUTPUT DATASET IS A PDS, WE NEED AT LEAST TWO      ---*
*---     DCBS; ONE FOR DATA AND ANOTHER FOR THE DIRECTORY          ---*
*---     INFORMATION PROCESSED BY ARCHDIR.  HERE'S A VERY          ---*
*---     SIMPLISTIC VIEW OF THE PROCESSING HERE.  (FURTHER MODS    ---*
*---     FOR PROCESSING PANVALET LIBRARIES ARE PLANNED BUT NOT     ---*
*---     YET IMPLEMENTED.)                                         ---*
*---                                                               ---*
*---     1. DETERMINE THE DSORG OR THE DATASET. IF NOT PS OR PO,   ---*
*---        WRITE NASTY MESSAGES TO THE USER AND QUIT RIGHT HERE.  ---*
*---                                                               ---*
*---     2. BUILD AND OPEN THE PRIMARY DCB.  SINCE WE USE BSAM     ---*
*---        FOR OUTPUT OF SEQUENTIAL DATASETS, WE CAN (ALMOST)     ---*
*---        USE THE SAME DCB FOR BOTH SEQUENTIAL AND PARTITIONED   ---*
*---        DATASETS.  WE ONLY NEED TO CHANGE THE DSORG VALUE IN   ---*
*---        THE DCB.  DURING THE 'OPEN' PROCESS, AN EXIT WILL      ---*
*---        BUILD A BUFFER POOL OF TWO BUFFERS.  BUFFERS ARE       ---*
*---        'GETBUF'ED AND SAVED IN THE ARCHIVER MAIN WORK AREA.   ---*
*---                                                               ---*
*---     3. IF THE DSORG IS PO AND RECFM = U, WE NEED ONE          ---*
*---        ADDITIONAL STEP: BUILD AN ADDITIONAL DCB AND OPEN IT   ---*
*---        FOR 'UPDAT' I/O.  THIS WILL BE USED BY THE MAINLINE    ---*
*---        CODE TO UPDATE NOTE LISTS IN LOAD MODULES, IF WE HAVE  ---*
*---        ANY.                                                   ---*
*---                                                               ---*
*---     NOTE: THE ARCHIVER MAKES NO ATTEMPT TO REASSEMBLE OR      ---*
*---     RECONSTRUCT A SPANNED RECORD.                             ---*
*---------------------------------------------------------------------*
         SPACE 3
OPNVO    DS    0H
         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS
*        #IF   NVPAN,ON,PANOPEN    REALLY A PANLIB ??
*---
*---     BUILD A DCB, TO START, FOR DSORG CHECKING
*---
         GETMAIN R,LV=BSDCBL,SP=10 GRAB STORAGE FOR BPAM DCB
         ST    R1,NDCBA            AND STORE ADDRESS IN ARCHIVWA
         MVI   NDCBA,X'80'         BUILD OPEN PARM LIST
         MVC   0(BSDCBL,R1),BSDCB  COPY DCB TO DYNAMIC AREA
         USING IHADCB,R1           BASE THE DCB DSECT
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R1
*---
*---     GET THE VOLSER FROM THE UCB, STARTING FROM THE TIOT.
*---
         NC    TIOTA,TIOTA         HAVE WE ALREADY DONE THIS ??
         BNZ   OPNVO1              YES ---
         MVC   CALLIST(EXTL),EXTRPARM COPY PARMLIST FOR EXTRACT
         EXTRACT TIOTA,'S',FIELDS=TIOT,MF=(E,CALLIST) LOCATE THE TIOT
         L     R1,TIOTA            LOAD THE TIOT POINTER
         LA    R1,24(,R1)          POINT TO THE FIRST TIOE
         ST    R1,TIOTA            SAVE UPDATED ADDRESS
OPNVO1   DS    0H
         L     R1,TIOTA            LOAD TIOT ELEMENT POINTER
OPNVO2   DS    0H
         CLI   0(R1),0             AT TIOT END ??
         BE    NODDERR             YES; DD STATEMENT IS MISSING
         CLC   NVSAMDD,4(R1)       IS THIS THE DD ENTRY ??
         BE    OPNVO3              YES; GO FETCH UCB ADDR
         IC    R0,0(,R1)           INSERT TIOE LENGTH
         N     R0,=F'255'          TRIM TO JUST THE LENGTH
         AR    R1,R0               BUMP TO NEXT ENTRY
         B     OPNVO2              AND CONTINUE THE SEARCH
OPNVO3   DS    0H
         L     R1,16(,R1)          LOAD UCB POINTER
         N     R1,=A(X'FFFFFF')    TRIM GARBAGE BYTES
         MVC   VOLSER,28(R1)       COPY THE VOLSER
         MVC   DEVT,16(R1)         AND UCB TYPE
         TM    DEVT+2,X'A0'        IS THIS A DASD OR TAPE DEVICE ??
         BZ    ERRDEV              NOPE; INVALID AS HELL
*---
*---     GET THE DSNAME. DISREGARD ANY MEMBER NAME
*---
         L     R2,NDCBA            LOAD THE DCB ADDRESS
         USING IHADCB,R2           AND BASE ITS DSECT
         LA    R0,DCBJFC           LOAD EXIT LIST POINTER
         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB
         LA    R0,JFC              POINT TO JFCB AREA
         ST    R0,DCBJFC           SAVE IN EXIT LIST
         MVI   DCBJFC,X'87'        EXIT TYPE, LAST FLAG
         RDJFCB ,MF=(E,NDCBA)      READ THE JFCB
         DROP  R2
*---
*---     BUILD AND EXECUTE THE CAMLIST/OBTAIN SEQUENCE IF DASD
*---     DATASET. USE THE FORMAT-1 DSCB TO DETERMINE IF THE
*---     DATASET IS PARTITIONED OR SEQUENTIAL.  IF THE DATASET
*---     IS SEQUENTIAL OR TAPE, WE BYPASS ANY BPAM STUFF.
*---
         TM    DEVT+2,X'80'        IS IT A TAPE DEVICE ??
         BO    OPNVO4              YES; ALWAYS SEQUENTIAL
         MVC   CALLIST(LCAMLST),CAMLST COPY CAMLIST TO WORK AREA
         LA    R0,JFC              LOAD DSNAME POINTER
         ST    R0,CALLIST+4        SAVE IN CAMLIST AREA
         LA    R0,VOLSER           POINT TO VOLSER
         ST    R0,CALLIST+8        SAVE IN CAMLIST AREA
         LA    R0,GENWK            POINT TO DSCB AREA
         ST    R0,CALLIST+12       SAVE IN CAMLIST AREA
         OBTAIN CALLIST            FETCH THE DSCB
         LA    R1,GENWK            POINT TO THE WORK AREA
         USING DS1FMTID,R1         AND BASE THE DSECT PORTION
         TM    DS1DSORG,DS1DSGPS   SEQUENTIAL ??
         BO    OPNVO4              YES ---
         TM    DS1DSORG,DS1DSGPO   PARTITIONED ??
         BO    OPNVO5              YES ---
         B     ORGERR              UNABLE TO PROCESS ANY OTHER DSORG
         DROP  R1
*---
*---     SET THE DSORG IN THE PRIMARY DCB ACCORDING TO THE VALUE
*---     FOUND IN THE FORMAT-1 DSCB.  ALSO, SET A PAIR OF SPECIAL
*---     FLAGS IN THE ARCHIVER WORK AREA.  THIS ALLOWS ME TO
*---     DETERMINE IF I'M REALLY PROCESSING A PDS, REQUIRING
*---     FIND'S, ETC. OR JUST BE WARY OF AN END-OF-FILE THAT WILL
*---     ULTIMATELY TERMINATE THE PROCESS.  IT ALSO DETERMINES
*---     WHETHER I NEED A DIRECTORY DCB, FOR LATER.
*---
OPNVO4   DS    0H
         #SET  NVSPS,ON            SET THE DSORG FLAG
         #SET  NVSPO,OFF           SET THE DSORG FLAG
         L     R2,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R2
         MVC   0(BSDCBL,R2),BSDCB  COPY IN THE PROPER DCB
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R2
         CLC   SEPVAL,=CL8'IEBUPDTE' IEBUPDTE-TYPE SEPARATORS ??
         BNE   OPNVO4A             NOPE ---
         MVC   IOSEP(2),=X'47F0'
         MVC   IOSEP+2(2),=S(SEPUPDTE)
OPNVO4A  DS    0H
         B     OPNVO6              GO SET UP THE VSAM I/O BLOCKS,ETC.
OPNVO5   DS    0H
         #SET  NVSPO,ON            SET THE DSORG FLAG
         #SET  NVSPS,OFF           SET THE DSORG FLAG
         L     R2,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R2
         MVC   0(PODCBL,R2),PODCB  COPY IN THE PROPER DCB
         MVC   DCBDDNAM,NVSAMDD    MOVE IN THE DDNAME
         DROP  R2
OPNVO6   DS    0H
*---
*---     SET THE ADDRESS OF MY 'COMPLETION' EXIT INTO THE DCB AND
*---     PROCEED WITH THE NECESSARY OPEN, ETC.
*---
         L     R2,NDCBA            POINT TO PRIMARY DCB
         USING IHADCB,R2
         LA    R0,OPNVO13          LOAD EXIT LIST POINTER
         STCM  R0,7,DCBEXLSA       SAVE IN THE DCB
         OPEN  (,OUTPUT),MF=(E,NDCBA) OPEN THE DCB
*---
*---     GRAB A PAIR OF BUFFERS FROM THE POOL BUILT DURING OPEN
*---     PROCESSING.
*---
         GETBUF (2),(3)            GRAB A BUFFER
         GETBUF (2),(4)            AND ANOTHER BUFFER
         LA    R0,4                LOAD INITIAL VB LENGTH
         SLL   R0,16               CREATE BDW WORD
         ST    R0,0(,R3)           FIRST BUFFER
         ST    R0,0(,R4)           AND SECOND BUFFER
         STM   R3,R4,BPBUF1        SAVE POINTERS IN WORK AREA
         ST    R3,BLOCKWDS         START OF BUFFER
         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---
         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY
         #SET  IOGOING,OFF         NO I/O IN PROGRESS
         MVC   BLOCK,=X'47F0E000'  INITIALIZE ---
         MVC   NVSRECFM,DCBRECFM   COPY THE RECORD FORMAT
         MVC   NVSBLKL,DCBBLKSI    AND BLKSIZE
         MVC   NVSLRECL,DCBLRECL   AND LRECL
*---
*---     USING THE RECFM AS A GUIDE, SET THE S-TYPE ADDRESS OF
*---     THE APPROPRIATE DEBLOCKER INTO THE BRANCH INSTRUCTION AT
*---     'BLOCK'
*---
         TM    DCBRECFM,DCBRECU    U-FORMAT ??
         BNO   OPNVO7              NOPE ---
         MVC   BLOCK+2(2),=S(PUTU) SET 'U' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO7   DS    0H
         TM    DCBRECFM,DCBRECV+DCBRECBR VB FORMAT ??
         BNO   OPNVO8              NOPE ---
         MVC   BLOCK+2(2),=S(PUTVB) SET 'VB' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO8   DS    0H
         TM    DCBRECFM,DCBRECF+DCBRECBR FB FORMAT ??
         BNO   OPNVO9              NOPE ---
         MVC   BLOCK+2(2),=S(PUTFB) SET 'FB' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO9   DS    0H
         TM    DCBRECFM,DCBRECV    V FORMAT ??
         BNO   OPNVO10             NOPE ---
         MVC   BLOCK+2(2),=S(PUTV) SET 'V' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO10  DS    0H
         TM    DCBRECFM,DCBRECF    V FORMAT ??
         BNO   OPNVO11             NOPE ---
         MVC   BLOCK+2(2),=S(PUTF) SET 'F' ROUTINE
         B     OPNVO12             SCAT ---
OPNVO11  DS    0H
         #PUT  =CL133'- UNABLE TO DETERMINE NONVSAM DATASET FORMAT'
         ABEND 999,DUMP
OPNVO12  DS    0H
         L     R0,=F'32768'        LOAD COMPRESS MAX LENGTH
         ICM   R0,8,=AL1(10)       INSERT SUBPOOL NUMBER
         GETMAIN R,LV=(0)
         STM   R0,R1,CMPWRKL       STORE COMPRESS WORK-AREA ADDRESS
         LM    R14,R12,IOSAVE      RELOAD ENTRY REGISTERS
         BR    R14                 AND RETURN TO LOCAL CALLER
         DROP  R2
*---
*---     THIS IS A SHORT AND SNEAKY DCB COMPLETION EXIT. ITS ONLY
*---     PURPOSE IS TO ESTABLISH THE BUFFER POOL FOR THE PRIMARY
*---     DCB. THIS POOL CONTAINS TWO BUFFERS, EACH BEING 4 BYTES
*---     LONGER THAN THE BLKSIZE OF THE DCB.
*---
*---     NOTE: THE GETPOOL ROUTINE WILL FAIL IF THE HIGH-ORDER
*---     BIT OF THE DCB ADDRESS IS NOT ZERO. SOME SPECIAL GLITCH
*---     IN THE IECQBFG1 CODE FOR A SPECIAL APPLICATION
*---     SOMEWHERE.
*---
OPNVO13  DS    0F
         DC    XL1'85',AL3(OPNVO13+4)
         USING IHADCB,R1
         LA    R1,0(,R1)           PURIFY DCB ADDRESS
         LH    R0,DCBBLKSI         LOAD THE BLKSIZE
         AH    R0,=H'4'            FOR LATER ---
         ICM   R0,12,=H'2'         BUFFER COUNT
         GETPOOL (1),(0)           BUILD A BUFFER POOL
         DROP  R1
         BR    R14                 AND RETURN TO O/C/EOV
         TITLE 'BSAM/BPAM CLOSE ROUTINE'
*---------------------------------------------------------------------*
*---     THIS LITTLE ROUTINE CLOSES THE NONVSAM DATASET (ALL       ---*
*---     DCB'S), RELEASES ALL BUFFER POOLS, RESETS POINTER         ---*
*---     VALUES, RELEASE THE COMPRESSION WORK AREA AND CLEANS UP   ---*
*---     THE NONVSAM I/O IN GENERAL, INCLUDING THE RESETING OF     ---*
*---     ANY FLAG BITS.                                            ---*
*---------------------------------------------------------------------*
         SPACE 3
NVSCLOSE DS    0H
         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS
         L     R2,NDCBA            LOAD PRIMARY DCB ADDRESS
         LA    R2,0(,R2)           PURIFY THE ADDRESS
NVSCX    DS    0H
         LTR   R2,R2               ZERO ??
         BZ    NVC1                YES; NO DCB HERE ---
         TM    48(R2),X'10'        IS IT OPEN ??
         BZ    NVCA                NOPE ---
         CLOSE MF=(E,NDCBA)        CLOSE THE DCB
NVCA     DS    0H
         #FREE (2)                 RELEASE BUFFER POOL, IF ANY
         XC    NDCBA,NDCBA         AND RESET THE POINTER FIELD
NVC1     DS    0H
         XC    DEVT,DEVT           CLEAR SAVED VALUES
         XC    NVSDSORG,NVSDSORG
         XC    VOLSER,VOLSER
         XC    BLOCKWDS(8),BLOCKWDS
         XC    NVSRECFM,NVSRECFM
         XC    NVSBLKL,NVSBLKL
         XC    NVSLRECL,NVSLRECL
         XC    BPBUF1,BPBUF1
         XC    BPBUF2,BPBUF2
NOCMPW   DS    0H
         XC    CMPWRKL(8),CMPWRKL
         MVC   BLOCK+2(2),=S(0(R14))
         #SET  IOGOING,OFF
         #SET  BUFUSED,OFF
         #SET  TRUNC,OFF
         #SET  NVSPS,OFF
         #SET  NVSPO,OFF
         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS
         BR    R14                 AND RETURN TO CALLER
         TITLE 'DIRECTORY ''STOW'' SUBROUTINE'
*---------------------------------------------------------------------*
*---     THIS LOCAL SUBROUTINE TAKES CARE OF ALL STOW PROCESSING.  ---*
*---     FUNCTIONS INCLUDE UPDATING TTR'S IN THE DIRECTORY ENTRY   ---*
*---     AND STOWING ALIAS DATA, WHERE APPROPRIATE.                ---*
*---------------------------------------------------------------------*
PDSSTOW  DS    0H
         USING REC,@BUF1
         STM   R14,R12,IOSAVE      SAVE ENTRY REGISTERS
         LR    R5,R1               COPY DIRDATA POINTER
         LR    R3,R0               COPY DIRDATA LENGTH
         LA    R3,0(R3,R5)         POINT TO END
         BCTR  R3,R0               DECREMENT, FOR LOOPING ---
         MVC   BLOCKWDS,BPBUF1     START OF BUFFER
         XC    BLOCKWDS+4(4),BLOCKWDS+4 BLOCK IS EMPTY YET ---
         #SET  BUFUSED,OFF         ALL BUFFERS EMPTY
         #SET  IOGOING,OFF         NO I/O IN PROGRESS
         CR    R5,R3               ANYTHING TO STOW ??
         BH    STOWDONE            NOPE; ALL DONE
         #IF   NVSPS,ON,STOWPS     SEQUENTIAL OUTPUT ??
         L     R2,NDCBA            LOAD PDS DCB ADDRESS
         LA    R2,0(,R2)           AND PURIFY ADDRESS
         LM    R7,R8,BPBUF1        LOAD BUFFER ADDRESSES
         MVC   0(4,R7),=X'00040000' RE-INIT FOR VB
         MVC   0(4,R8),=X'00040000' RE-INIT FOR VB
         LM    R7,R9,BLDLAREA+8    LOAD TTR DATA FROM BLDLAREA
STOW1    DS    0H
         CR    R5,R3               ANYTHING TO STOW ??
         BH    STOWDONE            NOPE; ALL DONE
         LA    R15,0               CLEAR A WORK REGISTER
         IC    R15,11(,R5)         LOAD DIR LENGTH BYTE
         N     R15,=A(X'1F')       TRIM TO BARE LENGTH
         LA    R15,11(R15,R15)     COMPUTE LENGTH TO MOVE
         EX    R15,DIRMOVE         COPY TO BLDLAREA
         LA    R5,1(R15,R5)        BUMP INPUT POINTER
         STCM  R7,14,BLDLAREA+8    SAVE MEMBER TTR
         TM    BLDLAREA+11,B'01100000' ANY TTR'S IN USER DATA ??
         BZ    STOW2               NOPE ---
         STCM  R8,14,BLDLAREA+12   FIRST TEXT RCD (MAYBE)
         TM    BLDLAREA+11,B'01000000' SECOND TTR IN USER DATA ??
         BZ    STOW2               NOPE ---
         STCM  R9,14,BLDLAREA+16   NOTE LIST (MAYBE)
STOW2    DS    0H
         TM    BLDLAREA+11,X'80'   IS THIS AN ALIAS ??
         BO    ALCNT               YES ---
         L     R14,MCNT            LOAD MEMBER COUNT
         A     R14,=F'1'           INCREMENT BY ONE
         ST    R14,MCNT            STORE UPDATED COUNT
         B     STOWD               GO ---
ALCNT    DS    0H
         #IF   RETA,OFF,STOW1      SKIP IF NOT RETAINING ALIASES
         L     R14,ACNT            LOAD MEMBER COUNT
         A     R14,=F'1'           INCREMENT BY ONE
         ST    R14,ACNT            STORE UPDATED COUNT
STOWD    DS    0H
         STCM  R7,14,BLDLAREA+8    INSERT THE TTR VALUE            ***
         TM    BLDLAREA+11,X'80'   ALIAS ??
         BO    *+10
         XC    BLDLAREA+8(3),BLDLAREA+8
         #STOW (2),BLDLAREA        STOW (MAYBE) MEMBER NAME
STOWE    DS    0H
         ICM   R7,14,BLDLAREA+8    INSERT THE TTR VALUE            ***
         SRL   R15,2               DIVIDE BY FOUR
         MH    R15,=H'51'          RC. TIMES MESSAGE LENGTH
         LA    R15,STOWM(R15)      POINT TO THE MESSAGE
         #FORMAT RECTT,,0(,R15)
         TM    BLDLAREA+11,X'80'   ALIAS NAME ??
         BZ    NOTALIAS            NOPE ---
         LR    R1,R0               POINT TO NEXT AREA
         MVC   0(7,R1),=CL7'(ALIAS)'
NOTALIAS DS    0H
         MVC   LINE+2(8),BLDLAREA  COPY THE REAL NAME OVER
         #PUT  LINE
         B     STOW1               AND CONTINUE ---
DIRMOVE  MVC   BLDLAREA(1),0(R5)
STOWDONE DS    0H
         LM    R14,R12,IOSAVE      RESTORE REGISTERS
         BR    R14                 AND RETURN TO LOCAL CALLER
STOWPS   DS    0H
         L     R14,MCNT            LOAD MEMBER COUNT
         A     R14,=F'1'           INCREMENT BY ONE
         ST    R14,MCNT            STORE UPDATED COUNT
         #FORMAT RECTT,,SEQMSG     SEQUENTIAL DATASET MESSAGE
         #PUT  LINE
         B     STOWDONE            AND RETURN TO LOCAL CALLER
SEQMSG   DC    AL1(50),CL50' ADDED TO SEQUENTIAL OUTPUT DATASET.'
STOWM    DC    AL1(50),CL50' SUCCESSFULLY STOWED IN PDS.'
STOWM1   DC    AL1(50),CL50' NOT REPLACED IN OUTPUT PDS.'
         DC    AL1(50),CL50' '
         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'
         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'
         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'
         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'
         DC    AL1(50),CL50' REPLACED IN OUTPUT PDS'
         DC    AL1(50),CL50' '
         DC    AL1(50),CL50' NOT FOUND. ADD ASSUMED.'
         DC    AL1(50),CL50' NOT STOWED. DIRECTORY OF PDS IS FULL.'
         DC    AL1(50),CL50' NOT STOWED. PERMANENT I/O ERROR.'
         DC    AL1(50),CL50' NOT STOWED. DCB INCORRECT OR NOT OPEN.'
         DC    AL1(50),CL50' NOT STOWED. GETMAIN WITHIN STOW FAILED.'
         DROP  @BUF1
         TITLE 'BSAM/BPAM WRITE ROUTINES '
*---------------------------------------------------------------------*
*---     REGS AT ENTRY:                                            ---*
*---              R0 ::= LOGICAL RECORD LENGTH                     ---*
*---              R1 --> LOGICAL RECORD                            ---*
*---              R14 -> RETURN ADDRESS                            ---*
*---                                                               ---*
*---     IN THE SPECIAL CASE OF RECFM=U, R1 WILL ACTUALLY POINT    ---*
*---     TO THE TTR WORD THAT PREFIXES THE DATA. R0 WILL BE ALSO   ---*
*---     BE ADJUSTED TO REFLECT THIS FACT.                         ---*
*---                                                               ---*
*---     THE BUFUSED FLAG DENOTES A BUFFER WITH GOOD STUFF IN IT   ---*
*---     BUT NO WRITE HAS STARTED FOR IT YET.                      ---*
*---                                                               ---*
*---     THE SPECIAL CASE OF A RECORD LENGTH OF ZERO SIGNALS A     ---*
*---     REQUEST TO WRITE ALL REMAINING DATA, SIMILAR TO A QSAM    ---*
*---     'TRUNC' MACRO.  THIS IS TYPICALLY NECESSARY WHEN THE      ---*
*---     LAST BLOCK OF THE MEMBER IS NOT FULL.                     ---*
*---------------------------------------------------------------------*
         SPACE 3
PUT      DS    0H
         STM   R14,R12,IOSAVE      SAVE INPUT REGISTERS
         #SET  TRUNC,OFF           NOT YET, ANYWAY
         L     R9,NDCBA            LOAD DCB ADDRESS
         USING IHADCB,R9           AND BASE ITS DSECT
         LR    R2,R1               AND ADDRESS
         LTR   R3,R0               ANYTHING TO ADD ??
         BNZ   EXPDR               YES ---
         #SET  TRUNC,ON            NOPE; SET 'TRUNC' FLAG
         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE
EXPDR    DS    0H
         #IF   NOEXP,ON,BLOCK
         L     R4,CMPWRK           POINT TO EXPAND OUTPUT AREA
         ST    R4,IOSAVE+12        SAVE EXPANDED RECORD ADDRESS
         LH    R3,0(,R2)           LOAD EXPANDED RECORD LENGTH
         ST    R3,IOSAVE+8         SAVE NEW RECORD LENGTH
         LA    R2,2(,R2)           POINT TO ACTUAL RECORD DATA
         CALL  EXPAND,((4),IOSAVE+8,(2)),MF=(E,CALLIST)
         B     BLOCK               GO TO THE BLOCK/WRITE ROUTINE
         TITLE 'BSAM/BPAM WRITE FIXED RECORDS '
*---------------------------------------------------------------------*
*---     FIXED, UNBLOCKED RECORDS.                                 ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTF     DS    0H
         #IF   TRUNC,ON,PUTF1      JUST CLEANING UP
         L     R4,BPBUF1           LOAD BUFFER POINTER
         LH    R5,DCBBLKSI         LOAD LRECL FOR RETURN
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         MVCL  R4,R2               COPY RECORD TO BPAM BUFFER
PUTF1    DS    0H
         #IF   IOGOING,OFF,PUTF2   IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         SHOW NO MORE WRITE IN PROGRESS
PUTF2    DS    0H
         #IF   TRUNC,ON,PUTRET     ALL DONE ---
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         WRITE PDSDECB,SF,(9),(4),'S',MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         B     PUTRET              AND GO RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE FIXED BLOCKED RECORDS '
*---------------------------------------------------------------------*
*---     FIXED, BLOCKED RECORDS.                                   ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTFB    DS    0H
         #IF   TRUNC,ON,PUTFB3     JUST CLEAN UP WHAT'S LEFT
         #IF   BUFUSED,ON,PUTFBA   INIT. SETUP IS DONE ??
         L     R4,BPBUF1           POINT TO FIRST BUFFER
         LA    R5,0                AMOUNT USED ---
         STM   R4,R5,BLOCKWDS      INIT. THE BLOCKING VALUES
PUTFBA   DS    0H
         #SET  BUFUSED,ON          TURN ON 'BUFFER USED' FLAG
         LM    R4,R5,BLOCKWDS      NEXT-RECORD ADDRESS
         LR    R6,R5               COPY CURRENT BUFFER-USED VALUE
         AH    R6,DCBLRECL         ACCOUNT FOR A RECORD
         ST    R6,BLOCKWDS+4
         LA    R4,0(R5,R4)         POINT INTO THE BUFFER
         LH    R5,DCBLRECL         LOAD LOGICAL RECORD LENGTH
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
PUTFB1   DS    0H
         MVCL  R4,R2               MOVE RECORD INTO BUFFER
         L     R2,BLOCKWDS+4       LOAD BYTES-USED VALUE
         CH    R2,DCBBLKSI         AT END OF BUFFER ??
         BL    PUTRET              NOPE; RETURN TO LOCAL CALLER
         #IF   IOGOING,OFF,PUTFB2  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
         #SET  BUFUSED,OFF         NEXT BUFFER IS EMPTY
PUTFB2   DS    0H
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS
         XC    BLOCKWDS+4(4),BLOCKWDS+4 CLEAR 'BYTES-USED' VALUE
         WRITE PDSDECB,SF,(9),(4),'S',MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG
         B     PUTRET              AND GO RETURN TO LOCAL CALLER
*---------------------------------------------------------------------*
*---     BUFFER PURGE ROUTINE                                      ---*
*---------------------------------------------------------------------*
PUTFB3   DS    0H
         #IF   IOGOING,OFF,PUTFB4  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTFB4   DS    0H
         #IF   BUFUSED,OFF,PUTFB5  IS CURRENT BUFFER USED ??
         L     R2,BPBUF1           LOAD BUFFER POINTER WORD
         L     R3,BLOCKWDS+4       LOAD BYTES-USED VALUE
         LH    R4,DCBBLKSI         LOAD DCB BLKSIZE
         STH   R3,DCBBLKSI         STORE UPDATED BLKSIZE
         WRITE PDSDECB,SF,(9),(2),(3),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         CHECK PDSDECB             LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS
         STH   R4,DCBBLKSI         RESTORE BLKSIZE
         XC    BLOCKWDS+4(4),BLOCKWDS+4 ZERO BYTES USED
         ST    R2,BLOCKWDS         RESET NEXT-RECORD POINTER
PUTFB5   DS    0H
         B     PUTRET              RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE VARIABLE RECORDS '
*---------------------------------------------------------------------*
*---     VARIABLE, UNBLOCKED RECORDS.                              ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTV     DS    0H
         #IF   TRUNC,ON,PUTV1      JUST CLEAN UP ---
         L     R4,BPBUF1           LOAD BUFFER POINTER
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         AH    R3,=H'4'            ACCOUNT FOR RDW/BDW
         SLL   R3,16               SHIFT FOR RDW/BDW
         STCM  R3,15,0(R2)         STORE RDW/BDW PREFIX
         LA    R4,4(,R4)           POINT PAST IT
         L     R3,IOSAVE+8           AND LENGTH
         LR    R5,R3               COPY RECORD LENGTH AGAIN
         MVCL  R4,R2               MOVE RECORD TO BPAM BUFFER
PUTV1    DS    0H
         #IF   IOGOING,OFF,PUTV2   IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTV2    DS    0H
         #IF   TRUNC,ON,PUTRET     JUST CLEAN UP ---
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         LH    R5,0(,R4)           LOAD RECORD LENGTH
         WRITE PDSDECB,SF,(9),(4),(5),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         B     PUTRET              AND GO RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE VARIABLE BLOCKED RECORDS '
*---------------------------------------------------------------------*
*---     VARIABLE, BLOCKED RECORDS.                                ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTVB    DS    0H
         #IF   TRUNC,ON,PUTVB4     JUST CLEAN UP ---
PUTVB1   DS    0H
         #SET  BUFUSED,ON          SHOW THE BUFFER USED
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         L     R4,BPBUF1           LOAD BUFFER POINTER
         LH    R5,0(,R4)           LOAD BYTES-USED VALUE
         LA    R5,4(R3,R5)         ACCOUNT FOR NEW RDW
         CH    R5,DCBBLKSI         TOO LARGE FOR THIS BLOCK ??
         BNH   PUTVB3              NOPE ---
         #IF   IOGOING,OFF,PUTVB2  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
         #SET  BUFUSED,OFF         NO WRITE IN PROGRESS
PUTVB2   DS    0H
         LM    R4,R5,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R6,R4               SWAP BUFFERS
         MVC   0(4,R5),=X'00040000' START WITH 4 BYTES (BDW)
         STM   R5,R6,BPBUF1        ...
         LH    R5,0(,R4)           LOAD BYTES-USED VALUE
         WRITE PDSDECB,SF,(9),(4),(5),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG
         B     PUTVB1              AND RE-CHECK ---
PUTVB3   DS    0H
         #SET  BUFUSED,ON          SHOW THE BUFFER NON-EMPTY
         L     R4,BPBUF1           LOAD POINTER TO AREA
         LH    R5,0(,R4)           LOAD BYTES-USED VALUE
         LA    R4,0(R5,R4)         POINT TO NEXT RECORD AREA
         LA    R0,4(,R3)           BUILD RDW AND
         STH   R0,0(,R4)           STORE IT
         XC    2(2,R4),2(R4)       NO SPANNED-RECORD STUFF
         LR    R5,R3               COPY RECORD LENGTH
         LA    R4,4(,R4)           POINT TO DATA FIELD
         MVCL  R4,R2               AND MOVE THE RECORD
         L     R2,BPBUF1           LOAD POINTER TO AREA
         AH    R0,0(,R2)           LOAD CURRENT BLK LENGTH
         STH   R0,0(,R2)           UPDATE BDW
         ST    R0,BLOCKWDS+4       AND BYTES-USED VALUE
         B     PUTRET              AND EXIT
PUTVB4   DS    0H
*---------------------------------------------------------------------*
*---     BUFFER PURGE ROUTINE                                      ---*
*---------------------------------------------------------------------*
         #IF   IOGOING,OFF,PUTVB6  IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTVB6   DS    0H
         #IF   BUFUSED,OFF,PUTVB7  IS CURRENT BUFFER USED ??
         L     R2,BPBUF1           LOAD BUFFER POINTER WORD
         LH    R3,0(,R2)           LOAD BYTES-USED VALUE
         WRITE PDSDECB,SF,(9),(2),(3),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         CHECK PDSDECB             LET IT COMPLETE
         MVC   0(4,R2),=X'00040000' RESET BDW
         L     R2,BPBUF2           LOAD BUFFER POINTER WORD
         MVC   0(4,R2),=X'00040000' RESET BDW
         #SET  BUFUSED,OFF         TURN OFF 'BUFFER USED' FLAG
         #SET  IOGOING,OFF         TURN OFF 'WRITE-IN-PROGRESS' FLAG
PUTVB7   DS    0H
         B     PUTRET              RETURN TO LOCAL CALLER
         TITLE 'BSAM/BPAM WRITE UNDEFINED RECORDS '
*---------------------------------------------------------------------*
*---     UNDEFINED-FORMAT RECORDS.                                 ---*
*---------------------------------------------------------------------*
         SPACE 3
PUTU     DS    0H
         L     R2,IOSAVE+12        LOAD RECORD ADDRESS
         L     R3,IOSAVE+8           AND LENGTH
         #IF   TRUNC,ON,PUTU1      CLEAN UP LAST WRITE
         NC    NOTELIST,NOTELIST   NOTELIST ALREADY FOUND ??
         BNZ   PUTUA               YES; CONTINUE ---
         CLI   BLDLAREA+19,0       IS A NOTE LIST PRESENT ??
         BE    PUTUA               NOPE ---
         CLC   0(3,R2),BLDLAREA+16 IS THIS IT ??
         BNE   PUTUA               NOPE ---
         LA    R4,4(,R3)           ACCOUNT FOR LENGTH WORD
         GETMAIN R,LV=(4),SP=10    GRAB SOME STORAGE
         ST    R1,NOTELIST         SAVE AS NOTELIST POINTER
         ST    R4,0(,R1)           SAVE LENGTH, FOR RELEASING LATER
         LA    R4,4(,R1)           POINT TO DATA AREA
         LR    R5,R3               COPY ACTUAL RECORD LENGTH
         MVCL  R4,R2               COPY THE NOTE LIST
         B     PUTRET              END, FOR NOW
PUTUA    DS    0H
         LR    R5,R3               COPY RECORD LENGTH
         L     R4,BPBUF1           LOAD BUFFER ADDRESS
         MVCL  R4,R2               COPY RECORD TO BUFFER
         L     R5,IOSAVE+8         RE-COPY RECORD LENGTH
PUTU1    DS    0H
         #IF   IOGOING,OFF,PUTU2   IS A WRITE IN PROGRESS ??
         CHECK PDSDECB             YES; LET IT COMPLETE
         #SET  IOGOING,OFF         NO WRITE IN PROGRESS
PUTUF    DS    0H
         NOTE  (9)                 SAVE ADDRESS OF LAST RECORD
         LR    R2,R1               COPY RESULT TTR
         L     R1,BPBUF2           RELOAD BUFFER POINTER
         ICM   R1,14,0(R1)         INSERT OLD TTR VALUE
PUTA     DS    0H
         CLM   R1,14,BLDLAREA+8    MATCHING TTR ??
         BNE   *+8                 NOPE ---
         STCM  R2,14,BLDLAREA+8    YES; UPDATE IT ---
         CLM   R1,14,BLDLAREA+12   MATCHING TTR ??
         BNE   *+8                 NOPE ---
         STCM  R2,14,BLDLAREA+12   YES; UPDATE IT ---
         CLM   R1,14,BLDLAREA+16   MATCHING TTR ??
         BNE   *+8                 NOPE ---
         STCM  R2,14,BLDLAREA+16   YES; UPDATE IT ---
PUTB     DS    0H
*---------------------------------------------------------------------*
*---     IF A NOTE LIST WAS PRESENT, WE MUST EXAMINE EACH ENTRY,   ---*
*---     COMPARING THE OLD TTR OF THE RECORD WE JUST WROTE.  IF    ---*
*---     WE HAVE A MATCH, WE REPLACE THE OLD TTR WITH THE NEW      ---*
*---     TTR, BEING CAREFUL NOT TO ALTER THE SEGMENT NUMBER.       ---*
*---------------------------------------------------------------------*
         L     R6,NOTELIST         LOAD NOTELIST POINTER
         LTR   R6,R6               ANY NOTELIST PROCESSING ??
         BZ    PUTU2               NOPE ---
         L     R5,0(,R6)           LOAD SAVED-NOTELIST LENGTH
         LA    R6,8(,R6)           POINT TO FIRST TTR VALUE
         LA    R7,0(R6,R5)         POINT TO
         BCTR  R7,R0                 END OF LIST
         L     R4,BPBUF2           LOAD POINT TO THE BUFFER
PUTN1    DS    0H
         CLC   0(3,R4),0(R6)       TTR'S MATCH ??
         BE    PUTN2               YES ---
         LA    R6,4(,R6)           POINT TO NEXT ENTRY
         CR    R6,R7               FAR ENOUTH, YET ??
         BL    PUTN1               NOPE; KEEP CHECKING
         B     PUTU2               ALL DONE ---
PUTN2    DS    0H
         STCM  R2,14,0(R6)         STORE UPDATED TTR
PUTU2    DS    0H
         #IF   TRUNC,ON,PUTRET     ALL DONE ---
         LM    R2,R3,BPBUF1        LOAD BUFFER POINTER WORDS
         LR    R4,R2               SWAP BUFFERS
         STM   R3,R4,BPBUF1        ...
         ST    R3,BLOCKWDS         STORE AS 'NEXT-RECORD' ADDRESS
         LA    R4,4(,R4)           POINT PAST THE TTR WORD
         L     R5,IOSAVE+8         RELOAD ORIGINAL LENGTH
         SH    R5,=H'4'            AND ACCOUNT FOR IT IN LENGTH
         WRITE PDSDECB,SF,(9),(4),(5),MF=E
         #SET  IOGOING,ON          SHOW THAT A WRITE IS IN PROGRESS
         B     PUTRET              AND RETURN TO LOCAL CALLER
*---------------------------------------------------------------------*
*---     COMMON RETURN LINKAGE CODE                                ---*
*---------------------------------------------------------------------*
PUTRET   DS    0H
         LM    R14,R12,IOSAVE      RESTORE CALLER'S REGISTERS
         BR    R14                 RETURN ---
         DROP  R9
*---------------------------------------------------------------------*
*---     SOME ERROR STUFF                                          ---*
*---------------------------------------------------------------------*
NODDERR  DS    0H
         #ERR  MSG=1
         #ERR  MSG=6
         B     ENDITALL
ORGERR   DS    0H
         #ERR  MSG=3
         #ERR  MSG=6
         B     ENDITALL
ERRDEV   DS    0H
         #ERR  MSG=2
         #ERR  MSG=6
         B     ENDITALL
         TITLE 'SEQUENTIAL OUTPUT SEPARATOR ROUTINES'
*---------------------------------------------------------------------*
*---     THIS LITTLE ROUTINE GENERATES A IEBUPDTE-TYPE ./ ADD      ---*
*---     CARD AS A SEPARATOR BETWEEN ITEMS BEING LOADED TO A       ---*
*---     SEQUENTIAL DATASET.  NO CHECK OF THE OUTPUT DATASET       ---*
*---     CHARACTERISTICS IS MADE; THE USER IS ASSUMED TO KNOW      ---*
*---     WHAT HE'S DOING!                                          ---*
*---------------------------------------------------------------------*
SEPUPDTE DS    0H
         STM   R14,R12,SEPSAVE     SAVE THE INPUT REGISTERS
         LR    R2,R1               COPY INPUT HEADER ADDRESS
         MVI   GENWK,C' '          SEED IN A BLANK
         MVC   GENWK+1(79),GENWK   BUILD A BLANK CARD
         MVC   GENWK(12),=C'./ ADD NAME='
         MVC   GENWK+12(8),1(R2)   COPY MEMBER NAME TO CARD
         #IF   NOEXP,ON,SEP1
         #SET  NOEXP,ON
         LA    R1,GENWK
         LA    R0,80
         BAL   R14,PUT             OUTPUT THE SEPARATOR
         #SET  NOEXP,OFF
         B     SEP2
SEP1     DS    0H
         LA    R1,GENWK            LOAD RECORD ADDRESS
         LA    R0,80               AND ELNGTH
         BAL   R14,PUT             CALL THE 'PUTTER'
SEP2     DS    0H
         LM    R14,R12,SEPSAVE
         BR    R14                 AND RETURN TO CALLER
         EJECT
*---------------------------------------------------------------------*
*---     THIS ROUTINE WILL ADD THE 'REAL' NAME WE JUST LOADED TO   ---*
*---     A CHAIN OF REAL NAMES IN STORAGE.  THE CHAIN IS 'ROOTED'  ---*
*---     IN THE 'COUNT' FIELD OF THE ARCHIVER'S MAIN WORK AREA.    ---*
*---     THE PURPOSE OF THIS CHAIN IS TO PREVENT LOADING THE SAME  ---*
*---     ITEM MULTIPLE TIMES IF IT HAS MULTIPLE ALIASES AND WE'RE  ---*
*---     LOADING BASED ON ALIAS CHECKS AS WELL AS REAL NAME        ---*
*---     CHECKS.                                                   ---*
*---                                                               ---*
*---     MY USE OF CELL POOL MANAGEMENT HERE PRECLUDES USING THIS  ---*
*---     ROUTINE IN ANY MVS/370 SYSTEM.                            ---*
*---                                                               ---*
*---     REGISTER 1 IS ASSUMED TO POINT TO THE 44-BYTE QUALIFIER   ---*
*---     DATA TO BE ADDED TO THE CHAIN.                            ---*
*---------------------------------------------------------------------*
CHAINER  DS    0H
         STM   R14,R12,IOSAVE      SAVE THE ENTRY REGISTERS
         LR    R2,R1               COPY THE DATA POINTER
         NC    NAMEPOOL,NAMEPOOL   IS CELL POOL INIT'D ??
         BNZ   CHAIN1              YES ---
         CNOP  0,4
         BAL   R1,BLDPOOL          BRANCH AROUND PARM LIST
         DC    F'100'
         DC    F'100'
         DC    F'48'
         DC    AL1(16)
         DC    AL1(20)
         DC    CL20'REAL NAMES LOADED  '
BLDPOOL  DS    0H
         CALL  CELLBLD
         ST    R0,NAMEPOOL         SAVE THE 'TOKEN' VALUE
CHAIN1   DS    0H
         L     R0,NAMEPOOL         LOAD THE TOKEN VALUE
         CALL  CELLGET             GO GRAB A QUICKCELL
         XC    0(48,R1),0(R1)      CLEAR IT OUT
         MVC   0(4,R1),NAMECHN     INSERT INTO THE
         ST    R1,NAMECHN            CHAIN
         MVC   4(44,R1),0(R2)      COPY DATA INTO THE CHAIN
         LM    R14,R12,IOSAVE      RESTORE THE REGISTERS
         LA    R15,0               ZERO RETURN CODE
         BR    R14                 AND RETURN TO MY CALLER
         EJECT
*---------------------------------------------------------------------*
*---     THIS ROUTINE CHECKS THROUGH THE CHAIN BUILT BY 'CHAIN'    ---*
*---     TO SEE IF WE'VE ALREADY PROCESSED THE ITEM WHOSE          ---*
*---     QUALIFIERS ARE POINTED TO BY REGISTER 1.  IF A MATCH IS   ---*
*---     FOUND, A RETURN CODE OF 4 IS SET IN REGISTER 15, ELSE     ---*
*---     THE RETURN CODE IS ZERO.                                  ---*
*---------------------------------------------------------------------*
CHKCHN   DS    0H
         STM   R14,R2,IOSAVE       SAVE THE ENTRY REGISTERS
         MVC   IOSAVE+4(4),=F'4'   SET INITIAL RETURN CODE
         L     R2,NAMECHN          LOAD THE FIRST LINK POINTER
         B     CHKCHN2             AND GO CHECK FOR ANY LINK
CHKCHN1  DS    0H
         CLC   4(44,R2),0(R1)      DOES IT MATCH ??
         BE    CHKCHN3             YES; ERROR RETURN CODE
         L     R2,0(,R2)           POINT TO NEXT LINK
CHKCHN2  DS    0H
         LTR   R2,R2               ANOTHER LINK ??
         BNZ   CHKCHN1             YES ---
         XC    IOSAVE+4(4),IOSAVE+4  NOPE; SET ZERO RETURN CODE
CHKCHN3  DS    0H
         LM    R14,R2,IOSAVE       RESTORE REGISTERS
         BR    R14                 AND RETURN TO CALLER
         EJECT
TCMSG    DC    CL133' '
         ORG   TCMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202120'
         DC    C' TOTAL LOGICAL RECORDS PROCESSED.'
         ORG
MCMSG    DC    CL133' '
         ORG   MCMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202120'
         DC    C' TOTAL MEMBERS PROCESSED.'
         ORG
ACMSG    DC    CL133' '
         ORG   ACMSG+2
         DC    X'40202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202020'
         DC    X'6B202120'
         DC    C' TOTAL ALIAS NAMES PROCESSED.'
         ORG
         LTORG
QSDCB    DCB   DSORG=PS,MACRF=PM,DDNAME=SYSPUNCH,RECFM=FB,             X
               LRECL=80,EXLST=PCHEXIT
DCBL     EQU   *-QSDCB
PCHEXIT  DS    0F
         DC    X'85',AL3(PCHEXIT+4)
         USING IHADCB,R1
         USING PCHEXIT+4,R15
         NC    DCBBLKSI,DCBBLKSI   BLKSIZE STILL ZERO ??
         BNZR  R14                 NOPE; RETURN TO CALLER
         MVC   DCBBLKSI,DCBLRECL   YES; MAKE BLKSIZE = LRECL
         BR    R14                 RETURN TO OPEN/CLOSE/EOV
         DROP  R1,R15
TRIGGER  DC    AL1(TRGE-TRGS)
TRGS     DC    C' SELECTED BY ARCHIVE ALIAS.'
TRGE     EQU   *
ALIASM   DC    AL1(ALIASE-ALIASS)
ALIASS   DC    C' IS AN ALIAS. CHECK SYSPUNCH OUTPUT FOR REAL '
         DC    C'QUALIFIER DATA.'
ALIASE   EQU   *
CAMLST   CAMLST SEARCH,0,0,0
LCAMLST  EQU   *-CAMLST
PODCB    DCB   DSORG=PO,MACRF=(R,W),DDNAME=X
PODCBL   EQU   *-PODCB
BSDCB    DCB   DSORG=PS,MACRF=(RP,WP),DDNAME=X
BSDCBL   EQU   *-BSDCB
EXTRPARM EXTRACT ,'S',FIELDS=TIOT,MF=L
EXTL     EQU   *-EXTRPARM
         READ  DECB,SF,0,0,0,MF=L
DECBL    EQU   *-DECB
         DCBD  DSORG=(PS,PO)
         IECSDSL1 (1)
         COPY  #RECS
         COPY  ##ARCHWK
         END
