//JEFFKZ   JOB (530000000000),'TECH.KAPLAN.JEFF',
// CLASS=S,MSGCLASS=G,MSGLEVEL=(1,1),NOTIFY=TECH110,REGION=8M
//S EXEC ASMHCLG
//C.SYSIN  DD *
POL      TITLE 'STORE POLLING MEMBER MERGE'
SDD81B   CSECT , /* CONVERT DATASET FORMAT */
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
RA       EQU   10
RB       EQU   11
RC       EQU   12
RD       EQU   13
RE       EQU   14
RF       EQU   15
K0       EQU   0
K1       EQU   1
K2       EQU   2
K3       EQU   3
K4       EQU   4
K5       EQU   5
K6       EQU   6
K7       EQU   7
K8       EQU   8
K9       EQU   9
K10      EQU   10
K11      EQU   11
K12      EQU   12
K13      EQU   13
K14      EQU   14
K15      EQU   15
K16      EQU   16
K17      EQU   17
K18      EQU   18
K19      EQU   19
K20      EQU   20
K23      EQU   23
K24      EQU   24
K28      EQU   28
K32      EQU   32
K36      EQU   36
K40      EQU   40
K44      EQU   44
K48      EQU   48
K52      EQU   52
K56      EQU   56
K60      EQU   60
K64      EQU   64
K68      EQU   68
K72      EQU   72
K76      EQU   76
K80      EQU   80
K84      EQU   84
K88      EQU   88
K92      EQU   92
K96      EQU   96
K255     EQU   255
K256     EQU   256
K264     EQU   264
K4095    EQU   4095
K4096    EQU   4096
K16384   EQU   16384
K32752   EQU   32752
K32756   EQU   32756
K32760   EQU   32760
X80      EQU   X'80'
X40      EQU   X'40'
X20      EQU   X'20'
X10      EQU   X'10'
X08      EQU   X'08'
X04      EQU   X'04'
X02      EQU   X'02'
X01      EQU   X'01'
X7F      EQU   X'7F'
XFF      EQU   X'FF'
SDD81B   AMODE 24
SDD81B   RMODE 24
         SAVE  (14,12),,SDD81B*&SYSDATE*&SYSTIME
         LR    RA,RF /*ADDRESSABILITY*/
         USING SDD81B,RA,RB,RC
         LA    RB,K4095(,RA)
         LA    RB,K1(,RB)
         LA    RC,K4095(,RB)
         LA    RC,K1(,RC)
         LR    RF,RD /*SAVEAREA HOUSEKEEPING*/
         CNOP  K0,K4
         BAL   RD,*+K76
         DC    (K18)AL4(K0)
         ST    RD,K8(,RF)
         ST    RF,K4(,RD)
         SPLEVEL SET=2 , /* MVS/XA EXPANSION */
OPENLIST OPEN  (DIRREAD,(INPUT),SYSUT2,(OUTPUT))
         LTR   RF,RF /* OPEN OKAY */
         BNZ   FOPEN /*NO*/
         LM    R6,R7,OPENLIST+K4 /* PICKUP DCB PTRS */
         USING IHADCB,R6
         TM    DCBOFLGS,DCBOFOPN
         BZ    FOPEN
         DROP  R6
         USING IHADCB,R7
         TM    DCBOFLGS,DCBOFOPN
         BZ    FOPEN
         DROP  R7
         SLR   R5,R5 /* TOTAL MEMBER COUNT */
         L     R3,=A(TTRLIST) /* START OF DIR LIST */
GETDIR   READ  DECBDIR,SF,MF=E
         CHECK DECBDIR
         LA    R4,DIRBLOCK+K10 /* PTR FIRST DIR BLOK ENTRY */
DIRBSCAN CLC   =X'FFFFFFFF',K0(R4) /* DIR END */
         BE    DIREND
         LA    R5,K1(,R5) +1 MEMBER
         C     R5,=A(K16384) EXCEEDED MAX # MEMBERS WE HANDLE
         BH    FMEMCOUN YES
         MVC   K0(K8,R3),K0(R4) SAVE MEMBER NAME
         MVC   K8(K3,R3),K8(R4) SAVE MEMBER TTR
         MVI   K11(R3),X'00' /* CLEAR LAST TTR UNUSED BYTE */
         MVC   K12(K4,R3),=X'00000000' BACKCHAIN PTR PER STORE
         LA    R3,K16(,R3) NEXT TTR SPOT; DO HALFWORD BOUND
         CLC   DIRBLOCK(K8),K0(R4) BLOCK END
         BE    GETDIR YES
         SLR   RF,RF /* CALC ENTRY LEN */
         NI    K11(R4),XFF-X80-X40-X20 OFF ALIAS AND TTRN BITS
         IC    RF,K11(,R4)
         SLL   RF,K1 /* NUMBER HALFWORDS */
         LA    R4,K12(RF,R4) NEXT SPOT
         B     DIRBSCAN /* CONTINUE */
DIREND   CLOSE (DIRREAD)
         LTR   R5,R5 /* ANY MEMBERS IN DATASET */
         BNP   FNOMEM NO
         L     R4,=A(TTRLIST) SCAN INFO ON ALL INPUT MEMBERS
         L     RF,=A(STORLIST) OUTPUT CHAINED STORE LIST
         XC    K0(K12,RF),K0(RF) PRIME STORE LIST
         B     NEXTITTR SKIP MEMBER DIRECTRY
STORLOP0 L     RF,=A(STORLIST) SCAN KNOWN STORE LIST
STORLOP1 OC    K0(K8,RF),K0(RF) SET END OF STORE LIST
         BZ    ADDNSTOR ADD NEW STORE TO LIST
         CLC   K1(K4,R4),K0(RF) KNOWN STOR NUMBER
         BE    ADDESTOR ADD EXISTING STORE
         LA    RF,K12(,RF) NEXT KNOWN STORE TO CHECK
         B     STORLOP1 ...
ADDESTOR LM    R6,R7,K4(RF) STOR MEMCTR AND BACKCHAIN PTR
         LA    R6,K1(,R6) #MEM IN THIS STORE
         ST    R7,K12(,R4) BACKCHAIN INPUT MEMBER LIST
         LR    R7,R4 NEW CHAIN END IN STOR
         STM   R6,R7,K4(RF) STORE INFO UPDATED
NEXTITTR LA    R4,K16(,R4) NEXT INPUT TTR
         BCT   R5,STORLOP0 RESCAN KNOWN STORE LIST FOR NEW MEM
         B     OPENSYT1 REOPEN FOR MEMBER READ
ADDNSTOR MVC   K0(K4,RF),K1(R4) SAVE STORE NUMBER
         XC    K4(K8,RF),K4(RF) INIT MEMCTR AND CHAIN PTR
         B     ADDESTOR CONTINUE
OPENSYT1 OPEN  (MEMREAD,(INPUT))
         LTR   RF,RF /* OPEN OKAY */
         BNZ   FOPEN /*NO*/
         L     R6,OPENSYT1+K4 /* PICKUP DCB PTRS */
         USING IHADCB,R6
         TM    DCBOFLGS,DCBOFOPN
         BZ    FOPEN
         DROP  R6
         L     R0,=A(7*1024*1024) 7M WORKAREA
         GETMAIN R,LV=(0)
         ST    R1,WORKPTR
         L     R7,=A(STORLIST) /* START OF DIR LIST */
STORSCAN LM    R4,R6,K0(R7) STOR#,MEMCTR,FIRSTPTR
         MVC   K0(K4,R1),=C'STOR' HEADER START
         ST    R4,K4(,R1) STORE #
         ST    R5,STORMEMC SAVE THIS STORE MEM CTR
         CVD   R5,WORK MEMBER CTR PER STORE
         UNPK  WORK(K5),WORK+K5(K3) PRINTABLE
         OI    WORK+K4,C'0'
         MVC   K8(K3,R1),=C'000' ...
         MVC   K11(K5,R1),WORK ...
         LR    RF,R5 CALC HEADER SIZE
         LA    R0,K24 ...
         SLR   RE,RE ...
         MR    RE,R0 ...
         LA    RF,K16(,RF) ADD FIXED HDR SIZE
         LA    R4,K16(,R1) PTR VAR HDR SECTION
         LA    R5,K0(RF,R1) PTR DATA SECTION
         ST    RF,K8(,R4) TEMP HOLD AREA FOR MEMBER OFFSET SAVE
STORLOOP MVC   K0(K8,R4),K0(R6) HDR MEMBER NAME
         XC    K16(K8,R4),K16(R4) CLEAR MEMBER ENTRY SIZE
         LA    R8,K8(,R6) PTR TO TTR TO START MEM READ
MEMLOOP  FIND  MEMREAD,(R8),C /* BPAM USES OUR TTR */
         LTR   RF,RF /* FIND OK */
         BNZ   FFIND ...
GETMEM   READ  DECBMEM,SF,MF=E /* INPUT DATA BLOCK */
         CHECK DECBMEM
         LH    R2,IOAREA+K4 /* INPUT VAR RCDSIZE */
         SH    R2,=H'4' /* CALC OUT RDW LEN - ALWAYS 1 RCD/BLK */
         L     R0,K16(,R4) GET TEMP AREA DATA FOR MEM SIZE
         ALR   R0,R2 THIS RCD LEN
         ST    R0,K16(,R4) SAVE SUM
         LR    R0,R5 TARGET DATA SECTION AREA
         LR    R1,R2 LEN
         LA    RE,IOAREA+K8 SOURCE DATA AREA
         LR    RF,R2 LEN
         MVCL  R0,RE SAVE DATA
         ALR   R5,R2 PTR NEXT DATA AREA
         B     GETMEM LOOP
MEMEND   ICM   R6,K15,K12(R6) RUN STORE MEM CHAIN
         LA    R4,K24(,R4) NEXT OUTPUT HDR LOC
         BNZ   STORLOOP CONTINUE
         L     R2,WORKPTR START OF OUTPUT DATA
         MVC   STOWLIST(K8),K0(R2) MEMBER NAME FOR STOW
         TR    K0(K16,R2),EBCASCII FIXED HDR TO ASCII
         L     R3,STORMEMC THIS STORE MEM CTR
         LA    R2,K16(,R2) PTR VAR HDR SECTION
         L     R4,K8(,R2) FIRST OFFSET SAVED HERE
         LR    R1,R4 SAVE IN R1 TOTAL STORE MEMBER LEN INCL HDR
PROCHDR1 L     R5,K16(,R2) LEN OF MEMBER IN BIN
         ALR   R1,R5 SUM TOTAL STOR LEN
         LR    R0,R4 CALC NEXT OFFSET
         ALR   R0,R5 ...
         CVD   R4,WORK OFFSET IN BIN
         LR    R4,R0 NEXT OFFSET
         UNPK  K8(K8,R2),WORK+K4(K4) PRINTABLE
         OI    K15(R2),C'0'
         CVD   R5,WORK LEN IN BIN
         UNPK  K16(K8,R2),WORK+K4(K4) PRINTABLE
         OI    K23(R2),C'0'
         TR    K0(K24,R2),EBCASCII VAR HDR TO ASCII
         LA    R2,K24(,R2) NEXT VAR HDR SEC
         BCT   R3,PROCHDR1
         SLR   R0,R0 CALC HOW MANY 32752 BYTE RCDS FOR STORE
         D     R0,=A(K32752) MAX RCD LEN,R1=COUNT,R0=RMDR
         LR    R2,R0 SAVE RMDR
         LR    R3,R1 SAVE RCD CTR
         XC    IOAREA(K8),IOAREA SETUP BDW AND RDW
         LTR   R3,R3 ANY MAXSIZE RCDS
         BZ    TRUNCMEM NO
         MVC   IOAREA(K2),=AL2(K32760) BDW
         MVC   IOAREA+K4(K2),=AL2(K32756) RDW
         L     R4,WORKPTR OUTPUT AREA HOLDER
WMEMLOOP LM    R0,R1,=A(IOAREA+K8,K32752) TARGET PTR
         LR    RE,R4 SOURCE PTR
         ALR   R4,R1 NEXT SOURCE PTR
         LR    RF,R1 LEN
         MVCL  R0,RE ...
         WRITE DECBOUT,SF,,IOAREA,MF=E /* OUTPUT A BLOCK */
         CHECK DECBOUT /* WAIT AND CHECK PREVIOUS WRITE */
         BCT   R3,WMEMLOOP CONTINUE
TRUNCMEM L     R0,=A(IOAREA+K8) TARGET PTR
         LR    R1,R2 SHORT LEN
         LR    RF,R2 SHORT LEN
         LR    RE,R4 SOURCE PTR
         MVCL  R0,RE ...
         LA    R2,K4(,R2) RDW TOTAL
         STH   R2,IOAREA+K4 ...
         LA    R2,K4(,R2) BDW TOTAL
         STH   R2,IOAREA ...
         WRITE DECBOUT,SF,,IOAREA,MF=E /* OUTPUT A BLOCK */
         CHECK DECBOUT /* WAIT AND CHECK PREVIOUS WRITE */
         STOW  SYSUT2,STOWLIST,A /* DIRECTORY UPDATE */
         LTR   RF,RF /* CHECK */
         BNZ   FSTOW /* ADD PDS DIR ENTRY FAILURE */
         L     R1,WORKPTR RESET STORE DATA PTR FOR NEXT STORE
         LA    R7,K12(,R7) PROCESS NEXT STORE
         OC    K0(K12,R7),K0(R7) STORE LIST END
         BNZ   STORSCAN CONTINUE
         CLOSE (MEMREAD,,SYSUT2)
         SLR   RF,RF
MAINEXIT L     RD,K4(,RD)
         RETURN (14,12),RC=(15)
FOPEN    LA    RF,K24 /* GENERAL OPEN FAILURE */
         B     MAINEXIT
FMEMCOUN LA    RF,K28 /* MORE THAN MAX MEMBERS */
         B     MAINEXIT
FNOMEM   LA    RF,K32 /* NO INPUT MEMBERS IN SYSUT1 */
         B     MAINEXIT
FFIND    LA    RF,K36 /* FIND FAILURE */
         B     MAINEXIT
FSTOW    LA    RF,K40 /* STOW FAILURE */
         B     MAINEXIT
         LTORG
         PRINT NOGEN
         READ  DECBDIR,SF,DIRREAD,DIRBLOCK,'S',MF=L /*READ DIR BLOCK*/
         READ  DECBMEM,SF,MEMREAD,IOAREA,'S',MF=L  /*READ MEM BLOCK*/
WORK     DC    D'0'
WORKPTR  DC    A(K0) GETMAINED AREA
STORMEMC DC    A(K0) SAVE AREA FOR STORE MEM CTR
DIRREAD  DCB   DDNAME=SYSUT1,DSORG=PS,MACRF=(R),                       X
               EODAD=*-*,KEYLEN=8,RECFM=F,LRECL=256,BLKSIZE=256
MEMREAD  DCB   DDNAME=SYSUT1,DSORG=PO,MACRF=(R),EODAD=MEMEND,RECFM=VB, X
               KEYLEN=0
SYSUT2   DCB   DDNAME=SYSUT2,DSORG=PO,MACRF=(R,W),NCP=1,RECFM=VB,      X
               LRECL=32756,BLKSIZE=32760,BUFNO=1
EBCASCII DC    (K256)AL1(K32) /* DEFAULT TO ASCII BLANK */
         ORG   EBCASCII+C' '
         DC    X'20'
         ORG   EBCASCII+C'.'
         DC    X'2E'
         ORG   EBCASCII+C':'
         DC    X'3A'
         ORG   EBCASCII+C'='
         DC    X'3D'
         ORG   EBCASCII+C'A'
         DC    X'414243444546474849'
         ORG   EBCASCII+C'J'
         DC    X'4A4B4C4D4E4F505152'
         ORG   EBCASCII+C'S'
         DC    X'535455565758595A'
         ORG   EBCASCII+C'0'
         DC    X'30313233343536373839'
         ORG
STOWLIST DC    (K0)A(K0),C'STOR????',A(K0) /* TTRC OF ZERO */
         WRITE DECBOUT,SF,SYSUT2,MF=L    /* OUTPUT A BLOCK */
SAVRECFM DC    AL1(K0)
DIRBLOCK DC    (K264)AL1(K0) /* A DIR BLOCK */
IOAREA   DS    0H'0',(K32760)AL1(K0) /* LARGE I/O WORKAREA */
TTRLIST  DS    (K0)A(K0),(K16384)CL16' ' 8NAME,4TTR,4STORECHAINPTR
STORLIST DS    (K4096)CL12' '  4STORE#,4STORMEMCTR,4STORMEMPTR
         DCBD  DSORG=(PO,QS),DEVD=DA
         END
/*
//G.SYSUDUMP DD SYSOUT=*
//G.SYSUT1 DD DSN=TECH110.POLLFVOL.OUTPUT,DISP=SHR
//G.SYSUT2 DD DISP=(NEW,CATLG),DSN=TECH110.TEST.PDS,
//  RECFM=VB,LRECL=32756,BLKSIZE=32760,
//  SPACE=(CYL,(300,50,180),RLSE)
