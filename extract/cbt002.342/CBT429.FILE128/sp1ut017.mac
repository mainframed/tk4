*          DATA SET SP1UT017   AT LEVEL 008 AS OF 02/27/89
*          DATA SET SP1UT017   AT LEVEL 002 AS OF 01/30/86
***********************************************************************
*                                                                     *
*    PROGRAM NAME:                SP1UT017                            *
*                                                                     *
*    AUTHOR:                      FRANCIS                             *
*                                                                     *
*    PURPOSE:                     SYSLOG HISTORY EXTRACTION           *
*                                                                     *
*    DATE WRITTEN:                JUNE 18, 1982                       *
*                                                                     *
*    SOURCE LIBRARY:              SYS.SYSPAN                          *
*                                                                     *
*    LOAD LIBRARY:                SYS1.SYS.LINKLIB                    *
*                                                                     *
*    ATTRIBUTES:                  STD                                 *
*                                                                     *
*    UPDATES:          02/07/85 - ADD PARTIAL MESSAGE SCAN            *
*                      12/27/85 - UPDATED FOR MVS/XA SYSLOG           *
*                      12/31/85 - UPDATED TO ACCEPT PDS AS INPUT      *
*                      02/24/89 - IHAHCLOG MACRO SUPPORT ADDED        *
*                               - MULTIPLE LINE MESSAGE SUPPORT       *
*                                                                     *
*    INPUT:            LOGIN    - SYSLOG HISTORY FILE                 *
*                      PDSIN    - SYSLOG HISTORY PDS                  *
*                      SYSIN    - PROGRAM PARAMETER CARDS             *
*                                 (SEE SEPARATE DOCUMENTATION)        *
*                                                                     *
*    OUTPUT:           SYSPRINT - PROGRAM MESSAGES AND SYSLOG RECORDS *
*                                                                     *
*    MESSAGES:         USR0315E - JOB ID TABLE OVERFLOW -- POSSIBLE   *
*                                 DATA LOSS                           *
*                      USR0316E - UNALLOCATION FAILED, RC=NNNN        *
*                      USR0317E - ALLOCATION FAILED, RC=NNNN          *
*                                                                     *
***********************************************************************
SP1UT017 TITLE 'SYSLOG EXTRACTION PROGRAM'
***********************************************************************
*                                                                     *
*    METHOD:                                                          *
*                                                                     *
*        1.  VALIDATE INPUT PARAMETER CARDS AND BUILD CONTROL TABLES. *
*                                                                     *
*        2.  READ EACH RECORD.  VERIFY THE RECORDS FITS WITHIN THE    *
*            DATE AND TIME RANGE.  IF NOT CONTINUE READING UNTIL A    *
*            RECORD IS FOUND THAT DOES.                               *
*                                                                     *
*        3.  IF NO OTHER TESTS WERE REQUESTED THEN PRINT THE RECORD.  *
*            IF OTHER TESTS WERE REQUESTED PRINT THE RECORD IF IT     *
*            PASSES ANY OF THE OTHER TESTS.                           *
*                                                                     *
*        4.  QUIT ON END OF FILE OR REACHING THE HIGH DATE AND TIME.  *
*                                                                     *
*    REGISTER USAGE:                                                  *
*                                                                     *
*        R0  - LINKAGE                                                *
*        R1  - LINKAGE, WORK                                          *
*        R2  - WORK                                                   *
*        R3  - WORK                                                   *
*        R4  - WORK                                                   *
*        R5  - WORK                                                   *
*        R6  - WORK                                                   *
*        R7  - WORK                                                   *
*        R8  - INTERNAL LINKAGE                                       *
*        R9  - ERROR CODE DURING INPUT DECIPHERING                    *
*        R10 - BASE FOR INPUT LINE DSECT (IHAHCLOG)                   *
*        R11 - PROGRAM BASE                                           *
*        R12 - PROGRAM BASE                                           *
*        R13 - LINKAGE, SAVE AREA, PROGRAM BASE                       *
*        R14 - LINKAGE, WORK                                          *
*        R15 - LINKAGE, WORK                                          *
*                                                                     *
***********************************************************************
         EJECT
SP1UT017 SYSENTER R13,R12,R11,SYMREG=YES
         PRINT NOGEN
         EJECT
         LA    R10,LOGRECD         R100<--A(INPUT RECORD)
         USING HCL,R10
         OPEN  (SYSPRINT,OUTPUT)
         BAL   R8,#PRM0000         GET CONTROL CARDS
         DEVTYPE PDSDD,DEVINFO
         LTR   R15,R15
         BNZ   #LOG1100
         MVI   PDSFLAG,X'FF'       SHOW PDS PRESENT
         RDJFCB (PDSIN)
         MVC   DSN,JFCBAREA        SET DSN IN TITLES
         OPEN  (PDSIN,INPUT)
         LA    R2,43               USED TO CALCULATE MEMBER NAME LENGTH
#LOG0100 DS    0H
         LA    R1,DSN              R1<--A(DATASET NAME)
         AR    R1,R2               POINT TO LAST BYTE
         CLI   0(R1),C' '          Q. STILL BLANK ???
         BNE   #LOG0200            ...NO: EXIT LOOP
         BCT   R2,#LOG0100         ..YES: TRY NEXT BYTE
#LOG0200 DS    0H
         LA    R2,1(,R2)           GET TRUE LENGTH
         STH   R2,DSNLEN           SAVE IN ALLOCATION TEXT
         LA    R7,MEMTABL
         USING PDS2,R6
***********************************************************************
*    GET (READ) A NEW DIRECTORY BLOCK
***********************************************************************
#LOG0300 DS    0H
         READ  DECB1,SF,PDSIN,DIRAREA   GET DIRECTORY BLOCK
         CHECK DECB1
         LH    R2,DIRAREA          SET DIR BLOCK LENGTH
         SH    R2,=H'2'            GET DIRECTORY DATA LENGTH
         LA    R6,DIRAREA+2        GET ADDRESS OF FIRST ENTRY
         CLI   PDS2NAME,X'FF'      END OF DIRECTORY ???
         BE    #LOG0600            ..YES
         B     #LOG0500            GO PROCESS THIS ENTRY
***********************************************************************
*    GET NEXT DIRECTORY ENTRY
***********************************************************************
#LOG0400 DS    0H
         SR    R1,R1
         IC    R1,PDS2INDC         GET BYTE CONTAINING ENTRY LENGTH
         SLL   R1,27               MASK OUT HIGH ORDER BITS
         SRL   R1,26               MULTIPLY BY TWO FOR USER DATA LENGTH
         LA    R1,PDS2USRD-PDS2(,R1)  ADD IN NON USER DATA LENGTH
         SR    R2,R1               SUBTRACT FROM REMAINING LENGTH
         BNP   #LOG0300            END OF BLOCK: GO GET NEW BLOCK
         AR    R6,R1               POINT TO NEXT ENTRY
         CLI   PDS2NAME,X'FF'      END OF DIRECTORY ???
         BE    #LOG0600
         B     #LOG0500            GO PROCESS THIS ENTRY
         EJECT
***********************************************************************
*    PROCESS DIRECTORY ENTRY
***********************************************************************
#LOG0500 DS    0H
         MVC   0(8,R7),PDS2NAME    SET MEMBER NAME
         LA    R7,8(,R7)           BUMP TO NEXT TABLE ENTRY
         AP    MEMCT,=P'+1'        BUMP MEMBER COUNT
         B     #LOG0400            CONTINUE FOR ALL MEMBERS
         DROP  R6
#LOG0600 DS    0H
         CLOSE (PDSIN)
         B     #LOG0800
***********************************************************************
*    UNALLOCATE LOGIN
***********************************************************************
#LOG0700 DS    0H
         LA    R1,DEARBPTR         R1<--A(DYNALLOC RB)
         DYNALLOC
         LTR   R15,R15             Q. DID IT FREE UP ???
         BZ    #LOG0800            ..YES
         UNPK  $UNAWTO+43(5),DEAERR(3)
         TR    $UNAWTO+43(4),HXTAB-240
         MVI   $UNAWTO+47,C' '
$UNAWTO  WTO   'USR0316E - UNALLOCATION FAILED, RC=XXXX ',             X
               ROUTCDE=(11)
         SYSRETRN RC=8
         EJECT
***********************************************************************
*    ALLOCATE EACH MEMBER FOUND IN PDSIN TO
*    DDNAME LOGIN FOR SEQUENTIAL PROCESSING
***********************************************************************
#LOG0800 DS    0H
         L     R7,NEXTMEM          R7<--A(NEXT MEMBER TO BE PROCESSED)
         MVC   MEMBER,0(R7)        SET MEMBER NAME IN TEXT
         LA    R7,8(,R7)           BUMP TO NEXT MEMBER
         ST    R7,NEXTMEM          SAVE MEMBER ADDRESS
         LA    R2,7                USED TO CALCULATE MEMBER NAME LENGTH
#LOG0900 DS    0H
         LA    R1,MEMBER           R1<--A(MEMBER NAME)
         AR    R1,R2               POINT TO LAST BYTE
         CLI   0(R1),C' '          Q. STILL BLANK ???
         BNE   #LOG1000            ...NO: EXIT LOOP
         BCT   R2,#LOG0900         ..YES: TRY NEXT BYTE
#LOG1000 DS    0H
         LA    R2,1(,R2)           GET TRUE LENGTH
         STH   R2,MEMBLEN          SAVE IN ALLOCATION TEXT
         LA    R1,DYNRBPTR         R1<--A(PERM LIST FOR ALLOCATION)
         DYNALLOC
         LTR   R15,R15             Q. DID IT ALLOCATE ???
         BZ    #LOG1100            ..YES
         UNPK  $ALCWTO+41(5),DYNERR(3)
         TR    $ALCWTO+41(4),HXTAB-240
         MVI   $ALCWTO+45,C' '
$ALCWTO  WTO   'USR0317E - ALLOCATION FAILED, RC=XXXX ',               X
               ROUTCDE=(11)
         SYSRETRN RC=8
         EJECT
#LOG1100 DS    0H
         OPEN  (LOGIN,INPUT)
         GET   LOGIN,LOGRECIN      GET FIRST INPUT RECORD
         MVC   FIRSDATE,HCLDATE    SET STARTING DATE
         MVC   FIRSTIME,HCLTIME    SET STARTING TIME
         PUT   SYSPRINT,HDR4       SHOW STARTING TIME OF HISTORY
         PUT   SYSPRINT,HDR3
         B     #LOG1300            CONTINUE ON
#LOG1200 DS    0H
         MVC   LOGRECIN(133),LOGRECIN-1 CLEAN OUT INPUT RECORD
         GET   LOGIN,LOGRECIN      GET EACH LOG RECORD
#LOG1250 DS    0H
         CLI   HCLDATE,C' '        Q. BLANK WHERE WE EXPECT DATE ???
         BE    #LOG1300            ..YES: DON'T SAVE DATE
         MVC   LASTDATE,HCLDATE    SAVE RECORD DATE
         MVC   LASTTIME,HCLTIME    SAVE RECORD TIME
#LOG1300 DS    0H
         CLI   FLAG,X'00'          Q. ANY OPTIONS SPECIFIED ???
         BE    #LOG4200            ...NO: PRINT ALL RECORDS
***********************************************************************
*    PROCESS DATERANGE OPTION IF SPECIFIED
***********************************************************************
#LOG1400 DS    0H
         TM    FLAG,DTRNG          Q. WAS DATERANGE SPECIFIED ???
         BZ    #LOG2000            ...NO: GO CHECK OTER OPTIONS
         CLC   HCLDATE,LOWDATE     CHECK AGAINST LOWDATE
         BL    #LOG1200            TOO LOW: KEEP READIN
         TM    OPTFLAG,HIDT        Q. WAS HIGHDATE GIVEN ???
         BZ    #LOG1500            ...NO: GO CHECK TIME
         CLC   HCLDATE,HIGHDATE    CHECK HIGH DATE
         BH    #LOG4300            HIGH: WE ARE ALL DONE
         EJECT
***********************************************************************
*    PROCESS TIMERANGE OPTION IF SPECIFIED
***********************************************************************
#LOG1500 DS    0H
         TM    FLAG,255-DTRNG      Q. ANY OTHER OPTIONS ???
         BZ    #LOG4200            ...NO: RECORD PASSED FILTERING
         TM    FLAG,TMRNG          Q. WAS TIMERANGE OPTION SPECIFIED ?
         BZ    #LOG2000            ...NO: GO CHECK OTHER OPTIONS
         TM    OPTFLAG,LOTIMOK     Q. LOW TIME REACHED ???
         BO    #LOG1700            ..YES: GO CHECK HIGH TIME
         CLC   HCLDATE,LOWDATE     Q. IS THIS LOWDATE ???
         BE    #LOG1600            ..YES: GO CHECK LOW TIME
         OI    OPTFLAG,LOTIMOK     ...NO: NO NEED TO CHECK LOW TIME
         B     #LOG1700            GO CHECK HIGH TIME
#LOG1600 DS    0H
         CLC   HCLTIME(L'LOWTIME),LOWTIME CHECK LOW TIME
         BL    #LOG1200            TOO LOW: GO TRY ANOTHER LOG RECORD
         OI    OPTFLAG,LOTIMOK     NOT TOO LOW: SHOW IT
         B     #LOG2000            GO CHECK OTHER OPTIONS
#LOG1700 DS    0H
         TM    OPTFLAG,HITIM       Q. HIGH TIME GIVEN ???
         BZ    #LOG2000            ...NO: GO CHECK OTHER OPTIONS
         TM    OPTFLAG,HIDT        Q. HIGH DATE GIVEN ???
         BZ    #LOG1800            ...NO: GO CHECK TIME FOR ONE DAY
         CLC   HCLDATE,HIGHDATE    CHECK HIGH DATE
         BL    #LOG2000            LOW: GO CHECK OTHER OPTIONS
         B     #LOG1900            GO CHECK TIME
#LOG1800 DS    0H
         CLC   HCLDATE,LOWDATE     CHECK DATE -- ONE DAY ONLY
         BNE   #LOG4300            ...NE: DONE
#LOG1900 DS    0H
         CLC   HCLTIME(L'HIGHTIME),HIGHTIME DATE MATCH: CHECK TIME
         BNH   #LOG2000            LOW: GO CHECK OTHER OPTIONS
         B     #LOG4300            HIGH: WE ARE ALL DONE
***********************************************************************
*    PROCESS OTHER OPTIONS IF SPECIFIED
***********************************************************************
#LOG2000 DS    0H
         TM    FLAG,255-(DTRNG+TMRNG)  Q. ANY OTHER OPTIONS ???
         BZ    #LOG4200            ...NO: RECORD PASSED FILTERING
         TM    FLAG,255-(DTRNG+TMRNG)  Q. ANY OTHER OPTIONS ???
         BZ    #LOG4200            ...NO: RECORD PASSED FILTERING
         EJECT
***********************************************************************
*    PROCESS JOBNAME OPTION IF SPECIFIED
***********************************************************************
#LOG2100 DS    0H
         TM    FLAG,JOBNAM         Q. WAS JOBNAME OPTION SPECIFIED ?
         BZ    #LOG3300            ...NO: GO PROCESS JOBNUMB
         ICM   R7,15,JOBNMCNT      Q. SPECIFIC JOBNAMES ???
         BNZ   #LOG2200            ..YES
         CLC   HCLJOBID+4(4),=CL4' ' Q. JOBNUMBER ON THIS MESSAGE ???
         BE    #LOG3600            ...NO: CONTINUE ON
         CLC   HCLJOBID(3),=C'JOB' Q. JOB ???
         BE    #LOG4200            ..YES: GO PRINT THIS MESSAGE
         CLC   HCLJOBID(3),=C'STC' Q. STC ???
         BE    #LOG4200            ..YES: GO PRINT THIS MESSAGE
         CLC   HCLJOBID(3),=C'TSU' Q. TSU ???
         BE    #LOG4200            ..YES: GO PRINT THIS MESSAGE
         B     #LOG3300            ...NO: GO CHECK JOB NUMBERS
#LOG2200 DS    0H
         CLC   HCLTEXT+1(8),=CL8'$HASP100' Q. JOB ON READER MESSAGE ???
         BE    #LOG2300            ..YES: GO CHECK NAME
         CLC   HCLTEXT+1(8),=CL8'$HASP373' Q. JOB STARTED MESSAGE ???
         BE    #LOG2600            ..YES: GO CHECK NAME
         CLC   HCLTEXT+1(8),=CL8'$HASP395' Q. JOB ENDED MESSAGE ???
         BE    #LOG2800            ..YES: GO CHECK NAME
         CLC   HCLTEXT+1(8),=CL8'$HASP250' Q. JOB PURGED MESSAGE ???
         BE    #LOG2800            ..YES: GO CHECK NAME
         B     #LOG3300
***********************************************************************
*    MESSAGE $HASP100 - JOB X ON READER - CHECK JOBNAME AGAINST TABLE
***********************************************************************
#LOG2300 DS    0H
         BAL   R8,#LOG3100         CHECK JOBNAME AGAINST JOBNAME TABLE
         LTR   R14,R14             Q. FOUND ???
         BNZ   #LOG3300            ...NO: TRUCK ON
***********************************************************************
*    JOBNAME MATCH - INSERT JOB NUMBER INTO JOBID TABLE
***********************************************************************
#LOG2400 DS    0H
         L     R1,JOBIDCNT         R1<--COUNT(TABLE ENTRIES)
         LA    R2,1(,R1)           R2<--NEW COUNT
         C     R2,=F'100'          Q. TABLE OVERFLOW ???
         BH    #LOG2500            ...YES: GO GIVE ERROR
         ST    R2,JOBIDCNT         SAVE NEW COUNT
         MH    R1,=H'4'            R1<--OFFSET INTO TABLE
         A     R1,=A(JOBIDS)       R1<--A(NEW TABLE ENTRY)
         MVC   0(4,R1),HCLJOBID+4  SAVE JOB NUMBER IN TABLE
         OC    0(4,R1),=CL4'0000'  MAKE IT ALL NUMERIC
         B     #LOG4200            GO WRITE THIS RECORD
***********************************************************************
*    JOB ID TABLE OVERFLOW -- GIVE ERROR
***********************************************************************
#LOG2500 DS    0H
         WTO   'USR0315E - JOB ID TABLE OVERFLOW - POSSIBLE DATA LOST',*
               ROUTCDE=(11)
         B     #LOG3300            CONTINUE TRYING THIS RECORD
         EJECT
***********************************************************************
*    $HASP373 - X STARTED - CHECK JOBNAME AGAINST TABLE
***********************************************************************
#LOG2600 DS    0H
         BAL   R8,#LOG3100         CHECK AGAINST JOBNAME TABLE
         LTR   R14,R14             Q. FOUND IN TABLE ???
         BNZ   #LOG3300            ...NO: GO TO NEXT OPTION TEST
***********************************************************************
*    JOBNAME FOUND IN JOBNAME TABLE -- CHECK JOBID TABLE -- IF ALREADY
*    IN TABLE (FROM $HASP100) THEN PRINT THIS RECORD -- IF NOT ALREADY
*    IN TABLE THEN GO ADD IT TO THE TABLE.
***********************************************************************
         ICM   R1,15,JOBIDCNT      R1<--COUNT(TABLE ENTRIES)
         BZ    #LOG2400            ..NONE: GO INSERT
         LA    R2,JOBIDS           R2<--A(JOBID TABLE)
         MVC   JOBTEMP,HCLJOBID+4  GET JOB NUMBER
         OC    JOBTEMP,=CL4'0000'  FORCE ALL NUMERICS
#LOG2700 DS    0H
         CLC   JOBTEMP,0(R2)       COMPARE AGAINST JOBID TABLE
         BE    #LOG4200            ..MATCH: GO WRITE THIS RECORD
         LA    R2,4(,R2)           R2<--A(NEXT TABLE ENTRY)
         BCT   R1,#LOG2700         LOOP FOR ALL TABLE ENTRIES
         B     #LOG2400            ..NOT FOUND -- GO INSERT THIS ID
***********************************************************************
*    $HASP250 - X IS PURGED      -- OR --
*    $HASP395 - X ENDED - FIND JOB ID IN TABLE AND DELETE IT
***********************************************************************
#LOG2800 DS    0H
         BAL   R8,#LOG3100         SEARCH JOBNAME TABLE THIS NAME
         LTR   R14,R14             Q. WAS JOBNAME FOUND IN TABLE ???
         BNZ   #LOG3300            ...NO: GO TO NEXT TEST
***********************************************************************
*    JOBNAME MATCH -- SEARCH JOBID TABLE AND DELETE ENTRY FOR THIS JOB
***********************************************************************
         ICM   R1,15,JOBIDCNT      R1<--COUNT(TABLE ENTRIES)
         BZ    #LOG3300            ..NONE -- NO NEED TO SEARCH TABLE
         LA    R2,JOBIDS           R2<--A(JOBID TABLE)
         MVC   JOBTEMP,HCLJOBID+4  GET JOB ID
         OC    JOBTEMP,=CL4'0000'  ENSURE ALL NUMERICS
#LOG2900 DS    0H
         CLC   JOBTEMP,0(R2)       CHECK AGAINST TABLE
         BE    #LOG3000            ..MATCH
         LA    R2,4(,R2)           R2<--ADDRESS(NEXT TABLE ENTRY)
         BCT   R1,#LOG2900         LOOP FOR ALL TABLE ENTRIES
         B     #LOG3300            ..NOT FOUND -- TO NEXT TEST
#LOG3000 DS    0H
         MVC   0(4,R2),4(R2)       MOVE IN NEXT ENTRY
         LA    R2,4(,R2)           POINT TO NEXT TABLE ENTRY
         BCT   R1,#LOG3000         LOOP FOR ALL TABLE ENTRIES
         L     R1,JOBIDCNT         GET ID COUNT
         BCTR  R1,R0               DECREMENT COUNT
         ST    R1,JOBIDCNT         SAVE UPDATED COUNT
         B     #LOG4200            GO WRITE THIS RECORD
         EJECT
***********************************************************************
*    JOBNAME TABLE SEARCH ROUTINE - ON ENTRY R7 HAS TABLE ENTRY COUNT
*    AND R8 HAS RETURN ADDRESS
***********************************************************************
#LOG3100 DS    0H
         LA    R6,JOBNAMES         R6<--ADDRESS(JOBNAME TABLE)
         USING JOBDSECT,R6
         SR    R14,R14             SET GOOD RETURN CODE
#LOG3200 DS    0H
         L     R5,@JLEN            R5<--LENGTH FOR COMPARE
         EX    R5,$JBNMCMP         COMPARE AGAINST TABLE ENTRY
         BER   R8                  ..MATCH: RETURN
         LA    R6,@JENTLEN(,R6)    R6<--ADDRESS(NEXT TABLE ENTRY)
         BCT   R7,#LOG3200         LOOP FOR ALL ENTRIES
         LA    R14,8               SET BAD RETURN CODE
         BR    R8                  RETURN TO CALLER
$JBNMCMP CLC   @JNAME(0),HCLTEXT+10  >>>>EXECUTED<<<<
         DROP  R6
***********************************************************************
*    PROCESS JOBNUMBER OPTION IF SPECIFIED
***********************************************************************
#LOG3300 DS    0H
         TM    FLAG,JOBNAM+JOBNUM  Q. WAS JOBNAM OR JOBNUM SPECIFIED ?
         BZ    #LOG3600            ...NO: GO PROCESS MESSAGE IDS
         CLC   HCLJOBID+4(4),=CL4' ' Q. JOB NUMBER IN LOG RECORD ???
         BE    #LOG3600            ...NO: SKIP ALL JOB PROCESSING
         CLC   HCLJOBID(3),=C'JOB' Q. JOB ???
         BE    #LOG3400            ..YES
         CLC   HCLJOBID(3),=C'STC' Q. STC ???
         BE    #LOG3400            ..YES
         CLC   HCLJOBID(3),=C'TSU' Q. TSU ???
         BE    #LOG3400            ..YES
         B     #LOG3600            ...NO: GO CHECK JOB NUMBERS
#LOG3400 DS    0H
         ICM   R2,15,JOBIDCNT      GET NUMBER OF TABLE ENTRIES
         BZ    #LOG3600            NONE: GO CHECK MESSAGE IDS
***********************************************************************
*    SEARCH TABLE FOR MATCH ON JOB NUMBER
***********************************************************************
         LA    R3,JOBIDS           GET TABLE OF JOB NUMBERS
         MVC   JOBTEMP,HCLJOBID+4  GET JOB ID
         OC    JOBTEMP,=CL4'0000'  FORCE ALL NUMERIC
#LOG3500 DS    0H
         CLC   0(4,R3),JOBTEMP     Q. LOG RECORD MATCH TABLE ENTRY ?
         BE    #LOG4200            ..YES: GO WRITE IT
         LA    R3,4(,R3)           POINT TO NEXT TABLE ENTRY
         BCT   R2,#LOG3500         LOOP FOR ALL TABLE ENTRIES
         EJECT
***********************************************************************
*    PROCESS MESSAGE ID OPTION IF SPECIFIED
***********************************************************************
#LOG3600 DS    0H
         TM    FLAG,MSGID          Q. WAS MESSAGE OPTION SPECIFIED ?
         BZ    #LOG3800            ...NO: GO CHECK FOR ABEND
         ICM   R1,15,MSGIDCNT      GET MESSAGE COUNT
         BZ    #LOG3800
         LA    R2,MSGIDS           GET MESSAGE ID TABLE
#LOG3700 DS    0H
         IC    R3,0(R2)           R3<--COMPARE LENGTH
         EX    R3,$MSGCMP         Q. DOES THE MESSAGE MATCH ???
         BE    #LOG4200            ..YES: PRINT IT
         LA    R2,9(,R2)           ...NO: GET NEXT TABLE ENTRY
         BCT   R1,#LOG3700         LOOP FOR ALL TABLE ENTRIES
***********************************************************************
*    PROCESS ABEND OPTION IF SPECIFIED
***********************************************************************
#LOG3800 DS    0H
         TM    FLAG,ABEND          Q. WAS ABEND OPTION SPECIFIED ???
         BZ    #LOG4000            ...NO: GO CHECK DATA OPTION
         CLC   HCLTEXT+1(8),=CL8'IEF450I' Q. JOB ABENDED MESSAGE ???
         BNE   #LOG4000            ...NO: GO CHECK FOR DATA CARDS
         TM    OPTFLAG,ABSTC+ABTSO+ABJOB  Q. TYPE CHECKING ???
         BZ    #LOG3840                   ...NO: GO CHECK FOR ABEND IDS
         TM    OPTFLAG,ABSTC       Q. STC ABENDS ???
         BZ    #LOG3820
         CLC   HCLJOBID(3),=C'STC' Q. STC ???
         BE    #LOG3840            ..YES: GO CHECK FOR SPECIFIC ID'S
         B     #LOG4000            ...NO: GO CHECK DATA OPTION
#LOG3820 DS    0H
         TM    OPTFLAG,ABTSO       Q. TSO ABENDS ???
         BZ    #LOG3830
         CLC   HCLJOBID(3),=C'TSU' Q. TSO ???
         BE    #LOG3840            ..YES: GO CHECK FOR SPECIFIC ID'S
         B     #LOG4000            ...NO: GO CHECK DATA OPTION
#LOG3830 DS    0H
         CLC   HCLJOBID(3),=C'JOB' Q. JOB ???
         BE    #LOG3840            ..YES: GO CHECK FOR SPECIFIC ID'S
         B     #LOG4000            ...NO: GO CHECK DATA OPTION
#LOG3840 DS    0H
         TM    OPTFLAG,ABIDS       Q. SPECIFIC ID'S ???
         BZ    #LOG4200            ...NO: PRINT THIS ABEND
         XC    TRTTAB,TRTTAB       CLEAN OUT TRT TABLE
         MVI   TRTTAB+C'-',C'-'    SET CHARACTER FOR SCAN
         TRT   HCLTEXT+9(30),TRTTAB FIND THE '-' IN THE MESSAGE
         BZ    #LOG4000            ..NOT THERE
         CLC   0(7,R1),=CL7'- ABEND' Q. IS IT WHAT WE EXPECTED ???
         BNE   #LOG4000            ...NO
         LA    R3,8(,R1)           R3<--A(SYSTEM ABEND ID FIELD)
         ICM   R1,15,ABNDCNT       GET COUNT OF ABEND ID'S
         BZ    #LOG4000
         LA    R2,ABNDIDS          R2<--A(ABEND ID TABLE)
#LOG3900 DS    0H
         CLC   0(4,R3),0(R2)       CHECK SYSTEM ABEND ID
         BE    #LOG4200            -->MATCH
         CLC   5(5,R3),0(R2)       CHECK USER ABEND ID
         BE    #LOG4200            -->MATCH
         LA    R2,5(,R2)           POINT TO NEXT TABLE ENTRY
         BCT   R1,#LOG3900         GO THROUGH ENTIRE TABLE
         EJECT
***********************************************************************
*    PROCESS DATA OPTION IF SPECIFIED
***********************************************************************
#LOG4000 DS    0H
         TM    FLAG,DATA
         BZ    #LOG1200
         ICM   R1,15,DATACNT       GET COUNT OF DATA ITEMS
         BZ    #LOG1200            ..NOT THERE
         LA    R2,DATATBL          R2<--ADDRESS(TABLE OF DATA ITEMS)
         USING DATDSECT,R2
#LOG4100 DS    0H
         LA    R3,HCLDATE          R3<--ADDRESS(DATE FIELD)
         AH    R3,@DOFF            R3<--ADDRESS(COMPARISON FIELD)
         LH    R4,@DLEN            R4<--LENGTH FOR COMPARE
         EX    R4,$DATACMP         DO THE DATA COMPARISON
         BE    #LOG4200            ..EQUAL: GO WRITE THIS RECORD
         LA    R2,@DENTLEN(,R2)    BUMP TO NEXT TABLE ENTRY
         BCT   R1,#LOG4100         CONTINUE FOR ALL DATA ITEMS
         B     #LOG1200            ..NOT FOUND: GO GET NEXT RECORD
$MSGCMP  CLC   HCLTEXT+1(0),1(R2)  >>>>EXECUTED<<<<
$DATACMP CLC   0(0,R3),@DATA       >>>>EXECUTED<<<<
         DROP  R2
***********************************************************************
*    RECORD PASSED FILTERING - PRINT IT
***********************************************************************
#LOG4200 DS    0H
         AP    LOGCOUNT,=P'+1'     KEEP RECORD TOTAL
         MVC   LINEDATA,LOGRECD    MOVE DATA TO OUTPUT LINE
         PUT   SYSPRINT,LINEOUT    WRITE OUTPUT LINE
         CLI   HCLRECTP,HCLMLWTO   CHECK FOR MULTI-LINE MESSAGE
         BNE   #LOG4225            NO, DON'T SET FLAG
         OI    OPTFLAG,MULTMSG     TURN OFF MULTI-LINE MSG FLAG
#LOG4225 DS    0H
         MVC   LINEOUT(133),LINEOUT-1  CLEAN OUT THE OUTPUT LINE
         MVC   LOGRECIN(133),LOGRECIN-1 CLEAN OUT INPUT RECORD
         GET   LOGIN,LOGRECIN      GET EACH LOG RECORD
         TM    OPTFLAG,MULTMSG     PROCESSING MULTIPLE LINE MESSAGE ???
         BNO   #LOG4250            ...NO: CONTINUE ON
         CLI   HCLRECTP,HCLLABEL   CHECK FOR MULTI-LINE MESSAGE
         BE    #LOG4200            YES, GO PRINT THIS PORTION
         CLI   HCLRECTP,HCLDATA    CHECK FOR MULTI-LINE MESSAGE
         BE    #LOG4200            YES, GO PRINT THIS PORTION
         NI    OPTFLAG,255-MULTMSG TURN OFF MULTI-LINE MSG FLAG
         CLI   HCLRECTP,HCLDTEND   CHECK FOR END OF MULTI-LINE MESSAGE
         BE    #LOG4200            YES, GO PRINT LAST PORTION
#LOG4250 DS    0H
         CLI   HCLRECTP,HCLSPLIT   CHECK FOR SPLIT MESSAGE
         BE    #LOG4200            YES, GO PRINT SECOND PORTION
         B     #LOG1250            GO PROCESS NEXT RECORD
         EJECT
***********************************************************************
*    END OF FILE ROUTINE FOR HISTORY FILE -- SHUT DOWN
***********************************************************************
#LOG4300 DS    0H
         CLOSE (LOGIN)
         PUT   SYSPRINT,TRLR3      SHOW LAST LOG RECORD TIME
         CLI   PDSFLAG,X'FF'       Q. PROCESSING A PDS ???
         BNE   #LOG4400            ...NO: EXIT
         SP    MEMCT,=P'+1'        Q. ANY MEMBERS LEFT ???
         BP    #LOG0700            ..YES
#LOG4400 DS    0H
         MVC   TRLR1+5(10),=X'40206B2020206B202120'  SET EDIT MASK
         ED    TRLR1+5(10),LOGCOUNT  SET RECORD COUNT IN MESSAGE
         PUT   SYSPRINT,TRLR1      WRITE REPORT
         PUT   SYSPRINT,TRLR2      TRAILER RECORDS
         CLOSE (SYSPRINT)
         PRINT GEN
         SYSRETRN RC=0
         PRINT NOGEN
         EJECT
***********************************************************************
*
*    THE PRMCHK ROUTINE READS THE INPUT DECK AND BUILDS TABLES FROM
*    THE INPUT CARDS TO CONTROL THE EXECUTION OF THE LOG SCAN.
*
*    REGISTER USAGE:
*
*    R4  = BASE FOR KYWDSECT
*    R7  = CURRENT POINTER INTO INPUT CARD
*    R8  = RETURN ADDRESS
*    R14 = ERROR CODE
*
***********************************************************************
#PRM0000 DS    0H
         PUT   SYSPRINT,HDR1
         OPEN  (SYSIN,INPUT)
#PRM0100 DS    0H
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         GET   SYSIN,CARD          GET EACH PARAMETER CARD
         LA    R7,CARD             R7<--A(START OF DATA CARD)
         PUT   SYSPRINT,CARD-1     ECHO EACH INPUT CARD
         MVI   CARD-1,C' '         RESET CARRAIGE CONTROL
         LA    R9,0                SET ERROR CODE
         TRT   CARD(71),BLNKTRT    FIND FIRST NON-BLANK CHAR
         BZ    #PRM2700            NON FOUND: ERROR
         LR    R7,R1               UPDATE POINTER
         MVI   TRTTAB+C' ',C' '    SETUP TRT TABLE
         MVI   TRTTAB+C'(',C'('
         TRT   0(10,R7),TRTTAB     FIND ' ' OR '('
         BZ    #PRM2700            NOTHING FOUND: ERROR
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         LR    R3,R1               R3<--A(END OF KEYWORD)
         SR    R3,R7               R3<--LENGTH(KEYWORD)
         LA    R4,KYWDTBL          R4<--A(KEYWORD TABLE)
         USING KYWDSECT,R4
         LA    R9,1                SET ERROR CODE
***********************************************************************
*    SEARCH TABLE FOR KEYWORD -- IF FOUND GO TO THE ROUTINE TO
*    HANDLE THE KEYWORD AND IT'S PARAMETERS
***********************************************************************
#PRM0200 DS    0H
         CH    R3,@LEN             Q. DOES LENGTH MATCH ???
         BL    #PRM0300            ..LOW: GO TRY NEXT TABLE ENTRY
         BE    #PRM0400            ..YES: GO TRY THIS TABLE ENTRY
         BH    #PRM2700            ...HI: NOT IN TABLE
         EJECT
***********************************************************************
*    LENGTH BAD -- GET NEXT TABLE ENTRY
***********************************************************************
#PRM0300 DS    0H
         LA    R4,@KLEN(,R4)       BUMP TO NEXT TABLE ENTRY
         CLI   @LEN,X'FF'          Q. END OF TABLE ???
         BNE   #PRM0200            ...NO: GO TRY THIS ENTRY
         LA    R9,1                SET ERROR CODE
         B     #PRM2700            ..YES: KEYWORD NOT IN TABLE
***********************************************************************
*    LENGTH EQUAL -- CHECK FOR KEYWORD MATCH  -- ON ENTRY TO THE
*    KEYWORD ROUTINES R9 = 0 IF R7 POINTS TO A PAREN AND R9 = 3
*    IF A PAREN WAS NOT FOUND (NO OPERANDS FOR THE KEYWORD)
***********************************************************************
#PRM0400 DS    0H
         SR    R9,R9               CLEAN OUT R9
         LR    R5,R3               R5<--ITEM LENGTH
         BCTR  R5,R0               GET LENTH FOR EXECUTE
         EX    R5,$KEYWCHK         COMPARE DATA WITH TABLE
         BNE   #PRM0300            ...NE: GO TRY NEXT TABLE ENTRY
         LR    R7,R1               POINT TO BLANK OR PAREN
         L     R6,@ADDR            R6<--A(KEYWORD ROUTINE)
         CLM   R2,1,=C'('          Q. WAS A PAREN FOUND ???
         BER   R6                  ..YES: GO PROCESS KEYWORD
         LA    R5,CARD+70          GET END OF DATA COLUMN - 1
         SR    R5,R7               GET EXECUTABLE LENGTH LEFT IN CARD
         LA    R9,3                SET ERROR CODE
         EX    R5,$KEYWPRN         TRY TO FIND PAREN
         BZR   R6                  ..NOT FOUND: GO PROCESS KEYWORD
         LR    R7,R1               ..FOUND: POINT TO IT
         SR    R9,R9               CLEAN OUT R9
         CLI   0(R1),C'('          Q. WAS A PAREN FOUND ???
         BER   R6                  ..YES: GO PROCESS KEYWORD
         LA    R9,4                SET ERROR MESSAGE
         B     #PRM2700            BAD DATA: ERROR
$KEYWCHK CLC   0(0,R7),@KYWD       >>>EXECUTED<<<
$KEYWPRN TRT   0(0,R7),BLNKTRT     >>>EXECUTED<<<
         DROP  R4
         EJECT
***********************************************************************
*
*    PROCESS DATERANGE CARD -- DATES IN FORMAT YY.DDD
*
*         MOVE FIRST DATE FIELD INTO 'LOWDATE'
*
*         MOVE SECOND DATE FIELD INTO 'HIGHDATE' AND SET 'HIDAT' FLAG
*
***********************************************************************
#PRM0600 DS    0H
         LTR   R9,R9               Q. WAS PAREN FOUND ???
         BNZ   #PRM2700            ...NO: ERROR
         LA    R9,6                SET ERROR CODE
         TM    FLAG,DTRNG          Q. PROCESSED KEYWORD BEFORE ???
         BO    #PRM2700            ..YES: ERROR
         OI    FLAG,DTRNG          SHOW OPTION
         LA    R7,1(,R7)           BUMP OVER PAREN
         LA    R9,4                SET ERROR CODE
         CLI   2(R7),C'.'          CHECK FORMAT
         BNE   #PRM2700            ..ERROR
         MVZ   DBLWD(6),0(R7)      CONTINUE CHECKING FORMAT
         CLC   DBLWD(6),=C'00 000'
         BNE   #PRM2700
         MVC   LOWDATE(2),0(R7)    SET LOW YEAR
         MVC   LOWDATE+2(3),3(R7)  SET LOW DATE
         LA    R7,6(,R7)           BUMP OVER FIRST DATE
         CLI   0(R7),C')'          Q. ONLY ONE TIME GIVEN ???
         BE    #PRM0100            ..YES: GO GET ANOTHER CARD
         CLI   0(R7),C','          CHECK FORMAT
         BNE   #PRM2700
         LA    R7,1(,R7)           BUMP OVER COMMA
         CLI   2(R7),C'.'          CHECK FORMAT
         BNE   #PRM2700
         MVZ   DBLWD(6),0(R7)      CONTINUE CHECKING FORMAT
         CLC   DBLWD(6),=C'00 000'
         BNE   #PRM2700
         LA    R9,8                SET ERROR CODE
         MVC   HIGHDATE(2),0(R7)   SET HIGH YEAR
         MVC   HIGHDATE+2(3),3(R7) SET HIGH DATE
         CLC   HIGHDATE,LOWDATE    VALIDATE HIGH DATE
         BL    #PRM2700
         OI    OPTFLAG,HIDT        SHOW DATE GIVEN
         LA    R7,6(,R7)           BUMP OVER DATE
         CLI   0(R7),C')'          CHECK FORMAT
         BE    #PRM0100            ...OK: GO GET NEXT CARD
         B     #PRM2700
         EJECT
***********************************************************************
*
*    PROCESS TIMERANGE CARD -- TIMES IN FORMAT HH.MM :
*
*         MOVE FIRST TIME FIELD INTO 'LOWTIME'
*
*         MOVE SECOND TIME FIELD INTO 'HIGHTIME' AND SET 'HITIM' FLAG
*
***********************************************************************
#PRM0700 DS    0H
         LTR   R9,R9               Q. WAS PAREN GIVEN ???
         BNZ   #PRM2700            ...NO
         LA    R9,6                SET ERROR CODE
         TM    FLAG,TMRNG          Q. PREVIOUSLY SPECIFIED ???
         BO    #PRM2700            ..YES
         LA    R9,5                SET ERROR CODE
         TM    FLAG,DTRNG          Q. WAS DATERANGE GIVEN ???
         BZ    #PRM2700            ...NO
         OI    FLAG,TMRNG          SET IN FLAG
         LA    R7,1(,R7)           BUMP OVER PAREN
         LA    R9,4                SET ERROR CODE
         CLI   2(R7),C':'          CHECK FORMAT
         BNE   #PRM2700
         MVZ   DBLWD(5),0(R7)      CHECK FORMAT
         CLC   DBLWD(5),=XL5'F0F070F0F0'
         BNE   #PRM2700
         MVC   LOWTIME,0(R7)       SET LOW TIME
         LA    R7,5(,R7)           POINT PAST TIME FIELD
         CLI   0(R7),C')'          Q. END OF TIME PARMS ???
         BE    #PRM0100            ..YES
         CLI   0(R7),C','          CHECK FORMAT
         BNE   #PRM2700
         LA    R7,1(,R7)           BUMP OVER COMMA
         CLI   2(R7),C':'          CHECK FORMAT
         BNE   #PRM2700
         MVZ   DBLWD(5),0(R7)      CONTINUE CHECKING FORMAT
         CLC   DBLWD(5),=XL5'F0F070F0F0'
         BNE   #PRM2700
         OI    OPTFLAG,HITIM       SHOW HIGH TIME GIVEN
         MVC   HIGHTIME,0(R7)      SAVE HIGH TIME
         LA    R7,5(,R7)           BUMP OVER THE TIME FIELD
         CLI   0(R7),C')'          CHECK FORMAT
         BE    #PRM0100
         B     #PRM2700
         EJECT
***********************************************************************
*
*    PROCESS JOB CARD -- IF JOBNAMES ARE GIVEN:
*
*         MOVE EACH JOBNAME AND IT'S LENGTH INTO TABLE 'JOBNAMES'
*
*         SET COUNT OF TABLE ENTRIES IN 'JOBNMCNT'
*
*              R4 = POINTER INTO JOBNAME TABLE
*              R5 = COUNT OF JOBNAMES
*
*    IF NO JOBNAMES ARE GIVEN LEAVE COUNT AT 0 AND GO GET NEXT CARD
*
***********************************************************************
#PRM0800 DS    0H
         LR    R6,R9               SAVE ENTRY CODE
         LA    R9,6                SET ERROR CODE
         TM    FLAG,JOBNAM         Q. ALREADY SPECIFIED ???
         BO    #PRM2700            ..YES: ERROR
         OI    FLAG,JOBNAM         SHOW JOBNAME SPECIFIFED
         LTR   R9,R6               Q. WAS PAREN GIVEN ???
         BNZ   #PRM0100            ...NO: GO GET NEXT PARM CARD
         LA    R7,1(,R7)           SKIP OVER PAREN
         LA    R4,JOBNAMES         R4<--A(TABLE OF JOBNAMES)
         USING JOBDSECT,R4
         SR    R5,R5               R5<--COUNT OF JOBNAMES
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         MVI   TRTTAB+C',',C','    SETUP TRT TABLE
         MVI   TRTTAB+C')',C')'
#PRM0900 DS    0H
         LA    R9,4                SET ERROR CODE
         TRT   0(9,R7),TRTTAB      FIND END OF JOBNAME
         BZ    #PRM2700            ERROR IN JOBNAME
         LR    R2,R1               SAVE ADDRESS
         SR    R1,R7               GET LENGTH OF JOBNAME
         BCTR  R1,R0               GET EXECUTABLE LENGTH
         ST    R1,@JLEN            SAVE LENGTH IN TABLE
         EX    R1,$JOBNMMV         MOVE JOBNAME INTO TABLE
         LA    R5,1(,5)            BUMP NUMBER OF JOB NAMES
         LA    R4,@JENTLEN(,R4)    BUMP TO NEXT TABLE ENTRY
         LA    R9,9                SET ERROR CODE
         C     R5,=F'50'           Q. TOO MANY JOBNAMES ???
         BH    #PRM2700            ..YES
         CLI   0(R2),C')'          Q. PAREN FOUND ???
         BE    #PRM1000            ..YES: END OF PARM CARD
         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???
         BE    #PRM1100            ..YES: GO PROCESS IT
         LA    R7,2(R1,R7)         SKIP OVER THIS JOB ID
         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)
         LA    R9,7                SET ERROR CODE
         CR    R7,R1               Q. PAST END OF CARD DATA ???
         BL    #PRM0900            ...NO
         B     #PRM2700            ..YES: ERROR
$JOBNMMV MVC   @JNAME(0),0(R7)     >>>EXECUTED<<<
         EJECT
***********************************************************************
*    ALL JOBNAMES PROCESSED -- SAVE COUNT
***********************************************************************
#PRM1000 DS    0H
         ST    R5,JOBNMCNT         SAVE COUNT OF JOBNAMES
         B     #PRM0100            GO GET NEXT PARM CARD
***********************************************************************
*    CONTINUATION CARD NEEDED -- CALL CONTINUATION ROUTINE
***********************************************************************
#PRM1100 DS    0H
         BAL   R6,#PRM2500         GO GET CONTINUATION CARD
         B     #PRM0900            GO PROCESS IT
         DROP  R4
         EJECT
***********************************************************************
*    PROCESS JOBNUMBER CARD -- SET EACH JOB NUMBER INTO TABLE AND SET
*         COUNT OF TABLE ENTRIES IN 'JOBIDCNT'
*
*         R4 = POINTER INTO JOBID TABLE
*         R5 = COUNT OF JOB NUMBERS
***********************************************************************
#PRM1200 DS    0H
         LTR   R9,R9               Q. WAS PAREN GIVEN ???
         BNZ   #PRM2700            ...NO: ERROR
         LA    R9,6                SET ERROR CODE
         TM    FLAG,JOBNUM         Q. ALREADY SPECIFIED ???
         BO    #PRM2700            ..YES: ERROR
         OI    FLAG,JOBNUM
         LA    R7,1(,R7)           SKIP OVER PAREN
         LA    R4,JOBIDS           R4<--A(TABLE OF JOB NUMBERS)
         SR    R5,R5               R5<--COUNT OF JOBNUMBERS
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         MVI   TRTTAB+C',',C','    SETUP TRT TABLE
         MVI   TRTTAB+C')',C')'
#PRM1300 DS    0H
         LA    R9,4                SET ERROR CODE
         TRT   0(5,R7),TRTTAB      FIND END OF JOB NUMBER
         BZ    #PRM2700            ERROR IN JOB NUMBER
         LR    R2,R1               SAVE ADDRESS
         SR    R1,R7               GET LENGTH OF JOB NUMBER
         LA    R6,4                R6<--EXPECTED LENGTH
         SR    R6,R1               R6<--OFFSET FOR MOVE
         AR    R6,R4               R6<--ADDRESS FOR MOVE
         BCTR  R1,R0               GET EXECUTABLE LENGTH
         EX    R1,$JOBIDMV         MOVE JOB NUMBER INTO TABLE
         LA    R5,1(,5)            BUMP NUMBER OF JOB NUMBERS
         OC    0(4,R4),=CL4'0000'  FORCE ALL NUMERICS
         LA    R4,4(,R4)           BUMP TO NEXT TABLE ENTRY
         LA    R9,14               SET ERROR CODE
         C     R5,=F'50'           Q. TOO MANY JOB NUMBERS ???
         BH    #PRM2700            ..YES
         CLI   0(R2),C')'          Q. PAREN FOUND ???
         BE    #PRM1400            ..YES: END OF PARM CARD
         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???
         BE    #PRM1500            ..YES: GO PROCESS IT
         LA    R7,1(,R2)           SKIP OVER THIS JOB ID
         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)
         LA    R9,7                SET ERROR CODE
         CR    R7,R1               Q. PAST END OF CARD DATA ???
         BL    #PRM1300            ...NO
         B     #PRM2700            ..YES: ERROR
#PRM1400 DS    0H
         ST    R5,JOBIDCNT         SAVE COUNT OF JOBNAMES
         B     #PRM0100            GO GET NEXT PARM CARD
$JOBIDMV MVC   0(0,R6),0(R7)       >>>EXECUTED<<<
#PRM1500 DS    0H
         BAL   R6,#PRM2500         GO GET CONTINUATION CARD
         B     #PRM1300            GO PROCESS IT
         EJECT
***********************************************************************
*    PROCESS MESSAGE CARD -- SET EACH MESSAGE ID INTO TABLE AND SET
*         COUNT OF TABLE ENTRIES IN 'MSGIDCNT'
*
*         R4 = POINTER INTO MSGIDS TABLE
*         R5 = COUNT OF MESSAGE IDS
***********************************************************************
#PRM1600 DS    0H
         LTR   R9,R9               Q. WAS PAREN GIVEN ???
         BNZ   #PRM2700            ...NO: ERROR
         LA    R9,6                SET ERROR CODE
         TM    FLAG,MSGID          Q. ALREADY SPECIFIED ???
         BO    #PRM2700            ..YES: ERROR
         OI    FLAG,MSGID          SET OPTION FLAG
         LA    R7,1(,R7)           SKIP OVER PAREN
         LA    R4,MSGIDS           R4<--A(TABLE OF MESSAGE IDS)
         SR    R5,R5               R5<--COUNT OF MESSAGE IDS
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         MVI   TRTTAB+C',',C','    SETUP TRT TABLE
         MVI   TRTTAB+C')',C')'
#PRM1700 DS    0H
         LA    R9,4                SET ERROR CODE
         TRT   0(9,R7),TRTTAB      FIND END OF MESSAGE ID
         BZ    #PRM2700            ERROR IN MESSAGE ID
         LR    R2,R1               SAVE ADDRESS
         SR    R1,R7               GET LENGTH OF MESSAGE ID
         BCTR  R1,R0               GET EXECUTABLE LENGTH
         STC   R1,0(R4)           SAVE COMPARE LENGTH
         EX    R1,$MSGIDMV         MOVE MESSAGE ID INTO TABLE
         LA    R5,1(,5)            BUMP NUMBER OF MESSAGE IDS
         LA    R4,9(,R4)           BUMP TO NEXT TABLE ENTRY
         LA    R9,11               SET ERROR CODE
         C     R5,=F'50'           Q. TOO MANY MESSAGE IDS ???
         BH    #PRM2700            ..YES
         CLI   0(R2),C')'          Q. PAREN FOUND ???
         BE    #PRM1800            ..YES: END OF PARM CARD
         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???
         BE    #PRM1900            ..YES: GO PROCESS IT
         LA    R7,2(R1,R7)         SKIP OVER THIS MESSAGE ID
         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)
         LA    R9,7                SET ERROR CODE
         CR    R7,R1               Q. PAST END OF CARD DATA ???
         BL    #PRM1700            ...NO
         B     #PRM2700            ..YES: ERROR
#PRM1800 DS    0H
         ST    R5,MSGIDCNT         SAVE COUNT OF MESSAGE IDS
         B     #PRM0100            GO GET NEXT PARM CARD
$MSGIDMV MVC   1(0,R4),0(R7)       >>>EXECUTED<<<
***********************************************************************
*    CONTINUATION CARD NEEDED -- CALL CONTINUATION ROUTINE
***********************************************************************
#PRM1900 DS    0H
         BAL   R6,#PRM2500         GO GET CONTINUATION CARD
         B     #PRM1700            GO PROCESS IT
         EJECT
***********************************************************************
*    PROCESS ABEND CARD -- IF IDS ARE SPECIFIED THEN SET EACH ABEND ID
*         INTO TABLE AND SET COUNT OF TABLE ENTRIES IN 'ABNDCNT'
*
*         R4 = POINTER INTO ABNDIDS TABLE
*         R5 = COUNT OF JOB NUMBERS
***********************************************************************
#PRM2000 DS    0H
         LR    R6,R9               SAVE ENTRY CODE
         LA    R9,6                SET ERROR CODE
         TM    FLAG,ABEND          Q. ALREADY SPECIFIED ???
         BO    #PRM2700            ..YES: ERROR
         OI    FLAG,ABEND          ...NO: SHOW IT NOW
         LTR   R9,R6               Q. PAREN FOUND ???
         BNZ   #PRM0100            ...NO: DONE WITH THIS CARD
         LA    R7,1(,R7)           ..YES: SKIP OVER IT
         CLC   =C'STC',0(R7)       Q. STC ABENDS ONLY ???
         BNE   #PRM2010            ...NO: CONTINUE CHECKING
         OI    OPTFLAG,ABSTC       SET STC ABEND ONLY FLAG
         LA    R7,3(,R7)           SKIP OVER PARAMETER
         B     #PRM2030
#PRM2010 DS    0H
         CLC   =C'TSO',0(R7)       Q. TSO ABENDS ONLY ???
         BNE   #PRM2020            ...NO: CONTINUE CHECKING
         OI    OPTFLAG,ABTSO       SET TSO ABEND ONLY FLAG
         LA    R7,3(,R7)           SKIP OVER PARAMETER
         B     #PRM2030
#PRM2020 DS    0H
         CLC   =C'JOB',0(R7)       Q. JOB ABENDS ONLY ???
         BNE   #PRM2040            ...NO: CONTINUE CHECKING
         OI    OPTFLAG,ABJOB       SET JOB ABEND ONLY FLAG
         LA    R7,3(,R7)           SKIP OVER PARAMETER
#PRM2030 DS    0H
         CLI   0(R7),C')'          Q. END OF ABEND PARMS
         BE    #PRM0100            ..YES: DONE WITH THIS CARD
         LA    R9,4                SET ERROR CODE
         CLI   0(R7),C','          Q. ABEND PARMS CONTINUE ???
         BNE   #PRM2700            ...NO: CAN'T DECIPHER IT
         LA    R7,1(,R7)           ..YES: SKIP OVER COMMA
#PRM2040 DS    0H
         OI    OPTFLAG,ABIDS       SET SUB-OPTION FLAG
         LA    R4,ABNDIDS          R4<--A(TABLE OF ABEND IDS)
         SR    R5,R5               R5<--COUNT OF ABEND IDS
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         MVI   TRTTAB+C',',C','    SETUP TRT TABLE
         MVI   TRTTAB+C')',C')'
#PRM2100 DS    0H
         LA    R9,4                SET ERROR CODE
         TRT   0(6,R7),TRTTAB      FIND END OF ABEND ID
         BZ    #PRM2700            ERROR IN ABEND ID
         LR    R2,R1               SAVE ADDRESS
         SR    R1,R7               GET LENGTH OF ABEND ID
         BCTR  R1,R0               GET EXECUTABLE LENGTH
         EX    R1,$ABDIDMV         MOVE ABEND ID INTO TABLE
         LA    R5,1(,5)            BUMP NUMBER OF ABEND IDS
         LA    R4,5(,R4)           BUMP TO NEXT TABLE ENTRY
         LA    R9,12               SET ERROR CODE
         C     R5,=F'50'           Q. TOO MANY ABEND IDS ???
         BH    #PRM2700            ..YES
         CLI   0(R2),C')'          Q. PAREN FOUND ???
         BE    #PRM2200            ..YES: END OF PARM CARD
         CLC   0(2,R2),=C', '      Q. CONTINUATION CARD NEEDED ???
         BE    #PRM2300            ..YES: GO PROCESS IT
         LA    R7,2(R1,R7)         SKIP OVER THIS ABEND ID
         LA    R1,CARD+72          R1<--A(END OF DATA ON CARD)
         LA    R9,7                SET ERROR CODE
         CR    R7,R1               Q. PAST END OF CARD DATA ???
         BL    #PRM2100            ...NO
         B     #PRM2700            ..YES: ERROR
#PRM2200 DS    0H
         ST    R5,ABNDCNT          SAVE COUNT OF ABEND IDS
         B     #PRM0100            GO GET NEXT PARM CARD
$ABDIDMV MVC   0(0,R4),0(R7)       >>>EXECUTED<<<
***********************************************************************
*    CONTINUATION CARD NEEDED -- CALL CONTINUATION ROUTINE
***********************************************************************
#PRM2300 DS    0H
         BAL   R6,#PRM2500         GO GET CONTINUATION CARD
         B     #PRM2100            GO PROCESS IT
         EJECT
***********************************************************************
*    PROCESS DATA CARD -- FOR EACH DATA CARD SET THE LENGTH AND DATA
*         IN THE DATA TABLE KEEPING THE COUNT IN 'DATACNT'
*
*         R5 = POINTER INTO DATATBL
***********************************************************************
#PRM2400 DS    0H
         LTR   R9,R9               Q. PAREN FOUND ???
         BNZ   #PRM2700            ...NO: ERROR
         OI    FLAG,DATA           SET OPTION FLAG
         L     R5,DATACNT          R5<--COUNT(DATA ITEMS)
         LA    R5,1(,R5)           R5<--NEW TOTAL
         LA    R9,13               R9<--ERROR CODE
         C     R5,=F'10'           Q. TOO MANY DATA ITEMS ???
         BH    #PRM2700            ..YES: ERROR
         ST    R5,DATACNT          ...NO: SAVE NEW COUNT
         BCTR  R5,R0               R5<--R5-1
         MH    R5,=Y(@DENTLEN)     R5<--OFFSET(NEXT DATA ITEM)
         A     R5,=A(DATATBL)      R5<--ADDRESS(NEXT DATA ITEM)
         USING DATDSECT,R5
         LA    R9,4                R9<--ERROR CODE
         LA    R7,1(,R7)           SKIP OVER PAREN
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         MVI   TRTTAB+C',',C','    SET SCAN FOR COMMA
         TRT   0(4,R7),TRTTAB      FIND NEXT COMMA
         BZ    #PRM2700            ..NOT FOUND: ERROR
         LR    R2,R1               R2<--ADDRESS(COMMA)
         SR    R1,R7               R1<--LENGTH(OFFSET)
         BCTR  R1,R0               R1<--R1-1  (EXECUTABLE LENGTH)
         EX    R1,$DATAMVZ         PICK UP ZONES OF OFFSET
         EX    R1,$DATACLC         Q. IS THE OFFSET FIELD NUMERIC ???
         BNE   #PRM2700            ...NO: ERROR
         LA    R9,15               R9<--ERROR CODE
         EX    R1,$DATAPAK         CONVERT THE OFFSET TO PD
         CVB   R3,DBLWD            CONVERT THE OFFSET TO BINARY
         C     R3,=F'116'          Q. OFFSET WITHIN BOUNDS ???
         BH    #PRM2700            ...NO: ERROR
         BCTR  R3,R0               CONVERT TO 0 BASED OFFSET
         STH   R3,@DOFF            SAVE OFFSET
         LA    R7,1(R2)            R7<--ADDRESS(COMMA+1)  (DATA FIELD)
         LA    R9,4                R9<-- ERROR CODE
         XC    TRTTAB(256),TRTTAB  CLEAN OUT TRT TABLE
         MVI   TRTTAB+C')',C')'    SET SCAN FOR RIGHT PAREN
         TRT   0(21,R7),TRTTAB     FIND END OF DATA STRING
         BZ    #PRM2700            ..NOT FOUND: ERROR
         SR    R1,R7               R1<--LENGTH(DATA)
         BCTR  R1,R0               R1<--R1-1  (EXECUTABLE LENGTH)
         EX    R1,$DATAMVC         MOVE DATA FIELD INTO TABLE
         STH   R1,@DLEN            SAVE DATA LENGTH
         B     #PRM0100            GO GET NEXT PARAMETER CARD
$DATAMVZ MVZ   DBLWD(0),0(R7)      >>>>EXECUTED<<<<
$DATACLC CLC   DBLWD(0),=CL3'000'  >>>>EXECUTED<<<<
$DATAPAK PACK  DBLWD(8),0(0,R7)    >>>>EXECUTED<<<<
$DATAMVC MVC   @DATA(0),0(R7)      >>>>EXECUTED<<<<
         DROP  R5
         EJECT
***********************************************************************
*    GET PARAMETER CONTINUATION CARD
***********************************************************************
#PRM2500 DS    0H
         OI    PRMFLAG,PRMCONT     SHOW CONTINUATION IN CASE OF EOF
         GET   SYSIN,CARD          GET NEXT PARM CARD
         NI    PRMFLAG,255-PRMCONT LIFT CONTINUATION FLAG
         LA    R7,CARD             POINT TO START OF CARD
         PUT   SYSPRINT,CARD-1     ECHO INPUT
         LA    R9,10               SET ERROR CODE
         TRT   CARD(71),BLNKTRT    FIND FIRST NON-BLANK
         BZ    #PRM2700            BLANK CARD NOT ALLOWED
         LR    R7,R1               RESET POINTER
         BR    R6                  RETURN TO CALLER
***********************************************************************
*    END OF FILE ON PARAMETER CARDS -- RETURN IF NO ERRORS
***********************************************************************
#PRM2600 DS    0H
         LA    R9,2                SET ERROR CODE
         TM    PRMFLAG,PRMCONT     Q. PROCESSING A CONTINUATION CARD ?
         BO    #PRM2700            ..YES: ERROR
         CLOSE (SYSIN)
         BR    R8                  RETURN TO CALLER
***********************************************************************
*    ERROR ROUTINE FOR PARAMETER CARD ERROR -- R9 CONTAINS ERROR CODE
***********************************************************************
#PRM2700 DS    0H
         S     R7,=A(CARD)         GET OFFSET TO DATA
         LA    R7,LINEDATA(R7)     GET OFFSET TO ERROR
         MVI   0(R7),C'$'          SET ERROR POINTER
         MVI   LINEOUT,C' '        SET CARRIAGE CONTROL
         PUT   SYSPRINT,LINEOUT
         MH    R9,=H'133'          GET OFFSET TO ERROR MESSAGE
         A     R9,=V(MSGCSECT)     POINT TO ACTUAL ERROR MESSAGE
         PUT   SYSPRINT,0(R9)      WRITE THE ERROR MESSAGE
         MVC   TRLR1+6(9),=C'        0'  SET RECORD COUNT
         PUT   SYSPRINT,TRLR1      WRITE REPORT
         PUT   SYSPRINT,TRLR2      TRAILER RECORDS
         CLOSE (SYSIN,,SYSPRINT)
         PRINT GEN
         SYSRETRN RC=8
         PRINT NOGEN
         EJECT
         LTORG
         SPACE
DBLWD    DC    D'0'              WORK AREA
KYWDTBL  DS    0D
         DC    A(#PRM0600),H'09',CL10'DATERANGE  '
         DC    A(#PRM0700),H'09',CL10'TIMERANGE  '
         DC    A(#PRM1200),H'09',CL10'JOBNUMBER  '
         DC    A(#PRM1600),H'07',CL10'MESSAGE    '
         DC    A(#PRM2000),H'05',CL10'ABEND      '
         DC    A(#PRM0800),H'04',CL10'JOBS       '
         DC    A(#PRM2400),H'04',CL10'DATA       '
         DC    A(#PRM0800),H'03',CL10'JOB        '
         DC    A(#PRM1600),H'03',CL10'MSG        '
         DC    A(#PRM0600),H'02',CL10'DT         '
         DC    A(#PRM0700),H'02',CL10'TM         '
         DC    A(#PRM1200),H'02',CL10'JN         '
         DC    A(#PRM0800),H'01',CL10'J          '
         DC    A(#PRM2400),H'01',CL10'D          '
         DC    A(#PRM2000),H'01',CL10'A          '
         DC    A(0),4X'FF'
         EJECT
PDSIN    DCB   DDNAME=PDSIN,DSORG=PS,EODAD=#LOG0600,MACRF=R,RECFM=F,   *
               LRECL=256,BLKSIZE=256,EXLST=LSTA
LOGIN    DCB   DDNAME=LOGIN,DSORG=PS,EODAD=#LOG4300,MACRF=GM
SYSIN    DCB   DDNAME=SYSIN,DSORG=PS,EODAD=#PRM2600,MACRF=GM
SYSPRINT DCB   DDNAME=SYSPRINT,DSORG=PS,MACRF=PM,                      C
               RECFM=FBA,LRECL=133,BLKSIZE=2660
         SPACE
LSTA     DS    0F
         DC    X'87'               JFCB AREA EXIT
         DC    AL3(JFCBAREA)
         SPACE
         DS    0F
         DC    CL8'JFCB'           EYE READABLE HEADER FOR DUMP
JFCBAREA DS    0F
         DC    CL176' '            AREA FOR JFCB
         SPACE
MEMCT    DC    PL4'+0'             COUNT OF MEMBER IN PDS
LOGCOUNT DC    PL4'+0'             COUNT OF RECORDS PRINTED
JOBIDCNT DC    F'0'                COUNT OF ACTIVE JOB ID'S
JOBNMCNT DC    F'0'                COUNT OF JOBNAME TABLE ENTRIES
MSGIDCNT DC    F'0'                COUNT OF MESSAGE ID TABLE ENTRIES
DATACNT  DC    F'0'                COUNT OF DATA ITEMS
ABNDCNT  DC    F'0'                COUNT OF ABEND ID TABLE ENTRIES
NEXTMEM  DC    A(MEMTABL)          A(MEMBER TABLE)
DEVINFO  DS    2F                  FOR INFORMATION FROM DEVTYPE
PDSDD    DC    CL8'PDSIN'          DDNAME FOR DEVTYPE
HXTAB    DC    C'0123456789ABCDEF' FOR HEX CONVERSIONS
JOBNAMES DC    50CL12' '           ALIGN ON FULLWORD BOUNDARY
DATATBL  DC    10CL24' '           ALIGN ON FULLWORD BOUNDARY
MSGIDS   DC    50CL9' '
ABNDIDS  DC    50CL5' '
JOBIDS   DC    100CL4' '
MEMTABL  DC    100CL8' '           DIRECTORY OF MEMBERS ON PDS
*
PDSFLAG  DC    X'00'               X'FF' IF INPUT IS FROM PDS
*
FLAG     DC    X'00'
*
DTRNG    EQU   X'40'               DATERANGE SPECIFIED
TMRNG    EQU   X'20'               TIMERANGE SPECIFIED
JOBNUM   EQU   X'10'               JOBNUMBER SPECIFIED
JOBNAM   EQU   X'08'               JOBNAME SPECIFIED
MSGID    EQU   X'04'               MESSAGE SPECIFIED
ABEND    EQU   X'02'               ABEND SPECIFIED
DATA     EQU   X'01'               DATA SPECIFIFED
*
OPTFLAG  DC    X'00'
*
HIDT     EQU   X'80'               HIGH DATE WAS GIVEN
LOTIMOK  EQU   X'40'               LOW TIME HAS BEEN PASSED
HITIM    EQU   X'20'               HIGH TIME WAS GIVEN
ABIDS    EQU   X'10'               ABEND IDS WERE GIVEN
MULTMSG  EQU   X'08'               MULTIPLE LINE MESSAGE
ABSTC    EQU   X'04'               STC ABENDS ONLY
ABTSO    EQU   X'02'               TSO ABENDS ONLY
ABJOB    EQU   X'01'               JOB ABENDS ONLY
*
PRMFLAG  DC    X'00'
*
PRMCONT  EQU   X'80'               PROCESSING CONTINUATION CARD
*
         DC    C' '
LINEOUT  DC    C'0'
LINEDATA DC    CL132' '
LOWDATE  DC    CL5' '
HIGHDATE DC    CL5' '
LOWTIME  DC    CL5' '
HIGHTIME DC    CL5' '
JOBTEMP  DC    CL4'0000'
SYSTEM   DC    CL2' '
         DC    C'0'                MUST BE IN FRONT OF CARD
CARD     DC    CL80' '
         DC    CL52' '             FOR ECHO OF INPUT
BLNKTRT  DC    64X'FF',X'00',191X'FF'
         DS    0F
TRTTAB   DC    256X'00'
DIRAREA  DC    CL256' '            I/O AREA FOR PDS DIRECTORY
         EJECT
HDR1     DC    CL133'1                                  SYSLOG HISTORY C
               SCAN PROGRAM'
HDR2     DC    CL133'0**** INPUT PARAMETER CARDS:'
HDR3     DC    CL133' **** SELECTED LOG RECORDS:'
HDR4     DS    0CL133
         DC    CL27'0**** HISTORY START DATE = '
FIRSDATE DC    CL5' '
         DC    CL8' TIME = '
FIRSTIME DC    CL5' '
         DC    CL87' '
TRLR1    DC    CL133' **** N,NNN,NNN LOG RECORDS PRINTED'
TRLR2    DC    CL133' **** END OF JOB'
TRLR3    DS    0CL133
         DC    CL25'0**** HISTORY END DATE = '
LASTDATE DC    CL5' '
         DC    CL8' TIME = '
LASTTIME DC    CL5' '
         DC    CL89' '
         DS    0F
***********************************************************************
*     MAP FOR INPUT SYSLOG RECORD
***********************************************************************
         DC    C' '                TO CLEAR INPUT RECORD
LOGRECIN DS    0CL133
LOGRECCC DC    C' '
LOGRECD  DC    CL132' '
         EJECT
***********************************************************************
*    CONTROL BLOCKS FOR DYNAMIC ALLOCATION
***********************************************************************
DYNRBPTR DC    A(DYNRB+X'80000000') PTR TO REQUEST BLOCK
         SPACE
DYNRB    DS    0F                  REQUEST BLOCK
         DC    AL1(20),AL1(S99VRBAL),AL2(0) ALLOCATE
DYNERR   DC    AL2(0),AL2(0)       ERROR & INFO CODES
         DC    A(DYNTUPL),A(0)     PTR TO TEXT POINTERS
         DC    A(0)
DYNTUPL  DC    A(DSNTEXT)
         DC    A(MEMBTEXT)
         DC    A(DDNTEXT)
         DC    A(STATTEXT+X'80000000')
         DS    0F
DSNTEXT  DC    AL2(DALDSNAM),AL2(1)
DSNLEN   DC    H'0'                LENGTH OF DATASET NAME
DSN      DC    CL44' '             DATASET NAME
         DS    0F
MEMBTEXT DC    AL2(DALMEMBR),AL2(1)
MEMBLEN  DC    H'0'                LENGTH OF MEMBER NAME
MEMBER   DC    CL8' '              MEMBER NAME
         DS    0F
DDNTEXT  DC    AL2(DALDDNAM),AL2(1),AL2(5),C'LOGIN'
         DS    0F
STATTEXT DC    AL2(DALSTATS),AL2(1),AL2(1),X'08'
DEARBPTR DC    A(DEARB+X'80000000') PTR TO REQUEST BLOCK
         SPACE
DEARB    DS    0F                  REQUEST BLOCK
         DC    AL1(20),AL1(S99VRBUN),AL2(0) ALLOCATE
DEAERR   DC    AL2(0),AL2(0)       ERROR & INFO CODES
         DC    A(DEATUPL),A(0)     PTR TO TEXT POINTERS
         DC    A(0)
DEATUPL  DC    A(DEATEXT+X'80000000')
         DS    0F
DEATEXT  DC    AL2(DUNDDNAM),AL2(1),H'5',C'LOGIN'
         DS    0F
         EJECT
MSGCSECT CSECT
MSG00    DC    CL133'-**** NO KEYWORD FOUND'
MSG01    DC    CL133'-**** UNKNOWN KEYWORD'
MSG02    DC    CL133'-**** END OF FILE RECEIVED DURING CONTINUATION OF X
               A PARAMETER CARD'
MSG03    DC    CL133'-**** THIS KEYWORD REQUIRES AN OPERAND BUT ONE WASX
                NOT SUPPLIED'
MSG04    DC    CL133'-**** INVALID OPERAND'
MSG05    DC    CL133'-**** DATERANGE MUST BE PREVIOUSLY SPECIFIED'
MSG06    DC    CL133'-**** THIS OPTION HAS BEEN PREVIOUSLY SPECIFIED'
MSG07    DC    CL133'-**** INVALID CONTINUATION'
MSG08    DC    CL133'-**** DATE2 NOT LATER THAN DATE1'
MSG09    DC    CL133'-**** MAXIMUM NUMBER OF JOB NAMES EXCEEDED'
MSG10    DC    CL133'-**** NO DATA ON CONTINUATION CARD'
         EJECT
KYWDSECT DSECT
@ADDR    DS    F
@LEN     DS    H
@KYWD    DS    CL10
@KLEN    EQU   *-KYWDSECT
         SPACE 2
DATDSECT DSECT
@DOFF    DS    H
@DLEN    DS    H
@DATA    DS    CL20
@DENTLEN EQU   *-DATDSECT
         SPACE 2
JOBDSECT DSECT
@JLEN    DS    F
@JNAME   DS    CL8
@JENTLEN EQU   *-JOBDSECT
         SPACE 2
         PRINT GEN
         IHAHCLOG
         PRINT NOGEN
         IEFZB4D0
         IEFZB4D2
         IHAPDS PDSBLDL=NO
        END
