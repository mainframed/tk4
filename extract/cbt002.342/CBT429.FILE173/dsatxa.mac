DSAT     TITLE '** TSO DATASET ATTRIBUTE COMMAND'
***********************************************************************
*    NAME - DSAT                                                      *
*                                                                     *
*    AUTHOR - TED BESTANI                                             *
*                                                                     *
*    PURPOSE - PROVIDE ONLINE (TSO) INFORMATION ABOUT DATASETS        *
*              SUCH AS DSORG, RECFM, CREATION DATE, SPACE, ETC.       *
*              IN ADDITION, PRIOR TO WRITING THE SCREEN DSAT          *
*              WILL SCAN THE TIOT FOR THE DDNAME "DSATPRNT".          *
*              IF THIS DDNAME IS FOUND, THE SCREEN WILL BE            *
*              WRITTEN TO THE DATA SET ALLOCATED FOR THIS PURPOSE.    *
*              DCB=(RECFM=FBA,LRECL=133)                              *
*                                                                     *
*    ATTRIBUTES - NON-REUSABLE                                        *
*                                                                     *
*    REQUIREMENTS - TCAM OR VTAM MUST SUPPORT THE FULL-SCREEN OPTION. *
*                   DSAT REQUIRES A 3270 DISPLAY STATION WITH AT      *
*                   LEAST 24 LINES.  IT WILL WORK ON BIGGER TOOBS,    *
*                   BUT IT WON'T USE THE ENTIRE SCREEN.               *
*                                                                     *
*    MACROS USED - TGET, TPUT, LOCATE, OBTAIN, STACK                  *
*                                                                     *
***********************************************************************
         EJECT
         PRINT ON,NOGEN,NODATA
DSAT     CSECT
         STM   R14,R12,12(R13)         SAVE CALLERS REGISTERS
         BALR  R9,0                    WHERE ARE WE?
         USING *,R9                    TEMPORARY BASE REGISTER
         ST    R13,SAVEAREA+4          SAVE BACKWARD SA PTR
         LA    R8,SAVEAREA             GET SA ADDR
         ST    R8,8(R13)               SAVE FORWARD SA PTR
         LR    R13,R8                  COPY SA ADDR
         LA    R12,4095(R13)           BASE2 = BASE1 + 4095 +
         LA    R12,1(R12)                                     1
         LA    R11,4095(R12)           BASE3 = BASE2 + 4095 +
         LA    R11,1(R11)                                     1
         LA    R10,4095(R11)           BASE4 = BASE3 + 4095 +
         LA    R10,1(R10)                                     1
         USING SAVEAREA,R13,R12,R11,R10    PERMANENT BASE REGISTERS
         DROP  R9                      DROP TEMPORARY BASE REGISTER
         MVC   SAVECPPL(16),0(R1)      SAVE CP PARM LIST
         SPACE 1
         BAL   R9,DRIVER               CALL MAIN DRIVER ROUTINE
         SPACE 1
         L     R13,SAVEAREA+4          GET BACKWARD SA PTR
         LM    R14,R12,12(R13)         RESTORE REGISTERS
         LA    R15,0                   SET RC=0
         BR    R14                     GO HOME......
         SPACE 1
SAVEAREA DS    18F    PROGRAM MAIN SAVE AREA
SAVECPPL DS    0F     ** TSO COMMAND PROCESSOR PARAMETER LIST **
CPPLCBUF DS    A      ADDRESS OF COMMAND INPUT BUFFER
CPPLUPT  DS    A                 USER PROFILE TABLE
CPPLPSCB DS    A                 PROTECTED STEP CONTROL BLOCK
CPPLECT  DS    A                 ENVIRONMENT CONTROL TABLE
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
***********************************************************************
*     THIS IS THE HIGHEST LEVEL WORK ROUTINE IN THE PROGRAM.  IT      *
*   DIRECTS THE FLOW OF CONTROL TO THE WORK ROUTINES.                 *
*     THE PROGRAM FOLLOWS BLOCK CODING CONVENTIONS.  FLOW             *
*   BETWEEN ROUTINES IS ACCOMPLISHED VIA REGISTER 9, WHICH IS ALWAYS  *
*   SAVED UPON ENTRY AND RESTORED BEFORE EXIT.                        *
***********************************************************************
         SPACE 2
DRIVER   DS    0H
         ST    R9,SAVE1
         B     BSAVE1
SAVE1    DC    F'-1'
         DC    CL8'DRIVER  '
BSAVE1   EQU   *
         SPACE 1
*------> PROCESS THE USERS REQUEST
         BAL   R9,GETDSN              PROCESS DSNAME
         BAL   R9,CATRTN              CHECK CATALOG
         BAL   R9,GETDSCB1            OBTAIN HEADER DSCB
         BAL   R9,GETDSCB3            OBTAIN EXTENSION DSCB
         BAL   R9,GETDATE             GET CURRENT TIME AND DATE
         BAL   R9,PRINTER             PRINT IF DDNAME PRESENT
         BAL   R9,FULLSCR             BUILD AND PAINT SCREEN
         CLI   SYSREQSW,C'1'          REQUEST EXTENTS?
         BNE   DRCHKSTK               NO, GO CHECK STACK SWITCH
         BAL   R9,EXTENTS             YES, PAINT EXTENTS
         B     EXIT1
DRCHKSTK EQU   *
         CLI   STACKSW,C'1'           SHOULD WE STACK A NEW DSAT CMND
         BNE   EXIT1                  NO, BYPASS THE STACK ROUTINE
         BAL   R9,STACKRTN            YES, STACK A NEW DSAT
         SPACE 1
EXIT1    EQU   *
         L     R9,SAVE1
         BR    R9
         EJECT
***********************************************************************
*    THE PURPOSE OF THIS ROUTINE IS TO PROCESS THE INPUT DSNAME.      *
*  THE DSNAME IS OBTAINED FROM ONE OF TWO SOURCES.  THE ROUTINE WILL  *
*  FIRST CHECK THE COMMAND INPUT BUFFER FOR AN OPERAND LENGTH OF      *
*  ZERO.  IF IT IS NOT ZERO, THE OPERAND WILL BE MOVED TO THE "DSN"   *
*  FIELD.  IF IT IS ZERO, IT WILL ASK THE USER TO INPUT THE DSNAME.   *
*  IN EITHER CASE, IT THEN CHECKS FOR APOSTROPHES.  IF THEY ARE NOT   *
*  PRESENT, THE USERID WILL BE PREFIXED TO THE DSNAME.  IF THEY ARE   *
*  PRESENT, THEY WILL BE STRIPPED OFF AND THE DSNAME WILL BE LEFT-    *
*  JUSTIFIED INTO THE "DSN" FIELD.  AFTER THIS IS FINISHED, THE       *
*  DSNAME FIELD IS CONVERTED TO EBCDIC UPPER-CASE BY "OR"-ING WITH    *
*  SPACES.                                                            *
***********************************************************************
         SPACE 1
GETDSN   DS    0H
         ST    R9,SAVE2
         B     BSAVE2
SAVE2    DC    F'-1'
         DC    CL8'GETDSN  '
BSAVE2   EQU   *
         SPACE 1
         L     R4,CPPLCBUF         GET CBUF ADDR
         LH    R2,0(R4)            GET TOTAL LENGTH
         LH    R3,2(R4)            GET RELATIVE OFFSET OF OPERAND
         LA    R3,4(R3)            BUMP BY BDW LENGTH
         CR    R2,R3               IF EQUAL, MEANS NO OPERAND
         BE    NODSN1                GO GET DSNAME
         SR    R2,R3               GET OPERAND LENGTH
         BCTR  R2,0                DEC BY 1 FOR EXECUTE
         AR    R4,R3               POINT R4 TO OPERAND
         EX    R2,EXMVC1           MOVE DSNAME
         B     PROCDSN             GO PROCESS DSNAME
EXMVC1   MVC   DSN(0),0(R4)        DUMMY MVC
NODSN1   EQU   *
         TPUT  MSG1,L'MSG1         PUT OUT DSN REQUEST MSG
         TGET  DSN,L'DSN           GO GET IT
         CH    R1,=H'1'            MUST BE AT LEAST 1 BYTE LONG
         BL    NODSN1
PROCDSN  EQU   *
         LA    R2,DSN              GET START ADDRESS
         LA    R3,L'DSN            GET LENGTH
CLAPOST1 EQU   *
         CLI   0(R2),C'/'          IS FLAG PRESENT?
         BE    SYSREQEX            YES, GO HANDLE FLAG
         CLI   0(R2),X'7D'         APOSTROPHE?
         BE    CLAPOST2            YES, CLEAR AND FLAG
         LA    R2,1(R2)            BUMP INDEX
         BCT   R3,CLAPOST1         DEC AND LOOP
         B     BCLAPOST            END OF SEARCH
SYSREQEX EQU   *
         MVI   0(R2),C' '          CLEAR FROM AREA
         OI    1(R2),C' '          MAKE UPPER-CASE
         CLI   1(R2),C'X'          REQUESTING EXTENTS?
         BNE   NOTEXTNT            NO, TRY OTHER
         MVI   1(R2),C' '          CLEAR WHATEVER IT IS
         MVI   SYSREQSW,C'1'       FLAG
         B     CLAPOST1            GO CHECK FOR DASH
NOTEXTNT EQU   *
         MVI   1(R2),C' '          CLEAR WHATEVER IT IS
         BE    CLAPOST1            GO CHECK FOR DSN
CLAPOST2 EQU   *
         MVI   APOSTSW,C'1'        POST NO-APPEND USERID FLAG
         MVI   0(R2),C' '          CLEAR APOSTROPHE
         BCT   R3,CLAPOST1         DEC AND LOOP
BCLAPOST EQU   *
         LA    R2,L'DSN-1          GET READY TO SHIFT OUT BLANKS
SHIFTL   EQU   *
         CLI   DSN,C' '            IS THERE A BLANK?
         BNE   ESHIFTL
         MVC   DSN(L'DSN-1),DSN+1  YES, OVERWRITE IT.
         BCT   R2,SHIFTL           TRY BUFLEN-1 TIMES MAX
ESHIFTL  EQU   *
         CLI   APOSTSW,C'1'        IS FIRST BYTE AN APOSTROPHE?
         BE    NOAPPEND            YES, DON'T PREFIX USERID
         L     R2,CPPLUPT
         MVC   DSN2(7),16(R2)      MOVE PREFIX (USERID)
         MVI   DSN2+7,C'.'         INSERT PERIOD
         MVC   DSN2+8(44-8),DSN    ADD DSN
         MVC   DSN(44),DSN2        MOVE IT BACK
         LA    R2,DSN
         LA    R3,8
         LA    R4,6
CLSPC    EQU   *
         CLI   0(R2),C' '          FIND SPACES DUE TO SHORT USERID
         BNE   NOSPC1              BYPASS MOVE STATEMENT
         MVC   0(44,R2),1(R2)      GET RID OF IT
         BCT   R4,CLSPC            RUN IN PLACE UP TO 6 STEPS
NOSPC1   EQU   *
         LA    R2,1(R2)            LOOK AT NEXT CHARACTER
         BCT   R3,CLSPC            TRY 8 TIMES MAX
NOAPPEND EQU   *
         LA    R2,DSN              GET ADDRESS OF DSN
         LA    R3,44               GET LENGTH FOR BCT
DASHSRCH EQU   *
         CLI   0(R2),C'-'          IS DASH PRESENT?
         BE    DASHFND             DASH FOUND - MOVE VOLSER
         LA    R2,1(R2)            BUMP INDEX BY 1
         BCT   R3,DASHSRCH         GO CHECK NEXT
         B     NODASH              NO DASH FOUND, BYPASS
DASHFND  EQU   *
         MVC   VOLSER,1(R2)        MOVE VOLSER
         OC    VOLSER,=CL6' '      CONVERT TO UPPERCASE
         MVC   0(7,R2),=CL7' '     CLEAR FROM DSN AREA
NODASH   EQU   *
         OC    DSN(80),=CL80' '    CONVERT TO UPPERCASE
         SPACE 1
EXIT2    EQU   *
         L     R9,SAVE2
         BR    R9
         EJECT
***********************************************************************
*    THE PURPOSE OF THIS ROUTINE IS TO CHECK THE CATALOG FOR THE      *
*  DSNAME THAT WE HAVE.  IF THE CATALOG SEARCH IS SUCCESSFUL, THE     *
*  "LOCATE" MACRO WILL BUILD A VOLUME TABLE IN OUR WORK AREA.         *
*  THE ROUTINE THEN CHECKS TO MAKE SURE THAT THE DATASET RESIDES ON   *
*  A DIRECT-ACCESS DEVICE, AND IF NOT ISSUE AN APPROPRIATE ERROR MSG. *
***********************************************************************
         SPACE 1
CATRTN   DS    0H
         ST    R9,SAVE3
         B     BSAVE3
SAVE3    DC    F'-1'
         DC    CL8'CATRTN  '
BSAVE3   EQU   *
         SPACE 1
         MVC   VOLIST+6(6),VOLSER  MOVE VOLSER TO PSEUDO INPUT AREA
CHEKUCB1 EQU   *
         CLC   VOLSER,=CL6' '      DID USER TYPE IN VOLSER
         BE    CATLOC              NO, GO SEARCH CATALOG
         L     R15,CVTPTR          GET PTR TO THE CVT
         MVC   DSADCB,CVTDCB-CVT(R15)  SAVE OP SYS TYPE
         TM    DSADCB,DSADCBXA     IS IT MVS/XA
         BO    UCBCHKXA            UCB CHECK FOR XA
*------> MUST BE AN OLD PRE-XA SYSTEM, USE THE UCB CHAIN
         L     R2,16               GET CVT
         L     R2,40(R2)           GET UCBILK2
         XR    R3,R3               CLEAR WORK REGISTER
NOCATLP  EQU   *
         CLC   0(2,R2),=X'FFFF'    END OF LOOKUP TABLE?
         BE    VSBAD
         CLC   0(2,R2),=X'0000'    NULL ENTRY?
         BE    BUMPIX
         ICM   R3,B'0011',0(R2)    PICK UP PTR
         CLC   28(6,R3),VOLSER     THIS VOLSER?
         BE    MVDEVTYP            MOVE THE DEVICE TYPE
BUMPIX   EQU   *
         LA    R2,2(R2)            BUMP TO NEXT ENTRY
         B     NOCATLP             GO CHECK NEXT
*------------------------------------------------------------------
***>>>>>>----UCB SCAN SERVICE FOR MVS/SP1.2 AND ABOVE:-----<<<<<<***
** PARM: (100BYTE-WORK, 1BYTE-DEV-CLASS, 1WORD-UCB-PTR)           **
** RETURN CODES: R15 = 00-UCB RETURNED; 04-NO MORE UCBS           **
*------------------------------------------------------------------
UCBCHKXA EQU   *
         XC    DSXAWORK,DSXAWORK       ZERO OUT UCB WORKAREA
         LA    R1,DSXAWORK             ADDR OF UCB WORKAREA
         ST    R1,DSXAWA               STORE IT IN PARM LIST
         LA    R1,DSXACLAS             PTR TO DEV CLAS TO SEARCH
         ST    R1,DSXADEVT             STORE IN PARM LIST
         MVI   DSXACLAS,UCB3DACC       ONLY SEARCH DASD
         LA    R1,DSXAUCBP             AREA TO STORE UCB ADDR
         ST    R1,DSXAUCB              IN PARM LIST
         OI    DSXAUCB,X'80'           SIGNIFY END OF PARMLIST
UCBLOOP  EQU   *
         L     R15,CVTPTR
         ICM   R15,15,CVTUCBSC-CVT(R15) CVTUCBSC VALID?(IOSVSUCB)
         LA    R1,DSXALIST             PTR TO PARM LIST
         BALR  R14,R15                 BRANCH TO IT
         LTR   R15,R15                 GOT ONE?
         BNZ   VSBAD                   NO
         L     R8,DSXAUCBP GET ADR OF  UCB FROM PTR
         USING UCBCMSEG,R8
         CLI   UCBID,UCBSTND           IS ADDRESS VALID
         BNE   UCBLOOP                 NO
         CLI   UCBDVCLS,UCB3DACC       IS IT DASDI
         BNE   UCBLOOP                 NO   SKIP
         TM    UCBSTAT,UCBONLI         IS IT ONLINE
         BNO   UCBLOOP                 NO  SKIP
         TM    UCBSTAT,UCBCHGS         IS IT CHANGING STATUS
         BO    UCBLOOP                 YES SKIP
         CLC   28(6,R8),VOLSER         COMPARE VOLSER
         BNE   UCBLOOP                 DONT WANT
MVDEVTYP EQU   *
         MVC   VOLIST+4(2),18(R8)      MOVE DEVICE TYPE
         MVC   VOLIST+0(2),=H'1'       SIMULATE VOLCNT=1
         MVC   SC1LN06+73(3),13(R8)    MOVE UCB NUMBER
         B     OKINCAT                 BYPASS THE LOCATE
*------> CAN'T LOCATE THE CORRECT VOLUME, ERR MSG THEN ABANDON SHIP
VSBAD    EQU   *
         TPUT  MSG10,L'MSG10       ISSUE ERROR MESSAGE
         L     R13,SAVEAREA+4      RETURN
         LM    R14,R12,12(R13)       WITH
         LA    R15,4                   RC=4
         BR    R14                       GO HOME
*------> GET THE DATASET INFORMATION FROM THE CATALOG
CATLOC   EQU   *
         LOCATE LOCLIST            ISSUE LOCATE MACRO
         LTR   R15,R15             CHECK RETURN CODE
         BZ    OKINCAT             IF OK, BYPASS
         TPUT  MSG2,L'MSG2         ISSUE ERROR MESSAGE
         TPUT  DSN,L'DSN-1         IDENTIFY DATASET
         L     R13,SAVEAREA+4      RETURN
         LM    R14,R12,12(R13)       WITH
         LA    R15,4                   RC=4
         BR    R14                       GO HOME
OKINCAT  EQU   *
         CLI   SC1LN06+73,C' '     HAVE WE ALREADY FOUND THE UNIT?
         BNE   FDEVICE0            YES, GO AROUND CODE
         MVC   VOLSER,VOLIST+6     SIMULATE USER ENTRY
         B     CHEKUCB1            GO CHECK UCB CHAIN
*------> FIND THE DEVICE TYPE IN THE TABLE AND GET THE TRK/CYL COUNT
FDEVICE0 EQU   *
         LA    R2,DEVTABLE
FDEVICE1 EQU   *
         CLC   0(2,R2),=X'0000'    END OF TABLE?
         BE    CHEKUCB2                YES, CHECK UCB
         CLC   0(2,R2),VOLIST+4    IF SAME DEVICE CODE....
         BE    FDEVICE2
         LA    R2,20(R2)           BUMP TO NEXT ENTRY
         B     FDEVICE1
*--> IF DATASET CATALOGED WITH A GENERIC NAME, THE CATALOG WILL
*    INDICATE THAT THE DATASET IS ON A DIRECT ACCESS DEVICE, BUT
*    IT WON'T TELL US WHAT KIND.  FOR THIS INFO, WE HAVE TO GO
*    BACK AND SEARCH THE UCB CHAIN; JUST AS IF THE USER HAD TYPED
*    IN THE VOLSER HIM/HERSELF.
CHEKUCB2 EQU   *
         TM    VOLIST+4,X'20'      IS THIS A DASD DATASET?
         BNO   NOTDASD             NO, INDICATE NOT DASD
         MVC   VOLSER,VOLIST+6     SIMULATE USER ENTRY
         B     CHEKUCB1            GO CHECK UCB CHAIN
FDEVICE2 EQU   *
         MVC   TRKCOUNT,2(R2)      SAVE TRACKS PER CYLINDER
         MVC   SC1LN06+50(06),VOLIST+6  MOVE VOLSER TO SCREEN
         MVC   SC1LN06+57(16),4(R2)     MOVE DEVICE NAME TO SCREEN
         LH    R3,VOLIST                GET VOLUME COUNT
         CVD   R3,WORKDBLW
         MVC   SC1LN06+42(4),=XL4'40202120'
         ED    SC1LN06+42(4),WORKDBLW+6
         MVI   SC1LN01+25,X'7D'    INSERT APOSTROPHE IN SCREEN
         MVC   SC1LN01+26(43),DSN  MOVE DSNAME TO OUTPUT SCREEN
         B     EXIT3
NOTDASD  EQU   *
         TPUT  MSG3,L'MSG3         ISSUE ERROR MESSAGE
         TPUT  DSN,44              DISPLAY DATASET NAME
         LH    R3,VOLIST           GET VOLUME COUNT
         CH    R3,=H'20'           MORE THAN TWENTY VOLUMES?
         BNH   VOLSINIT            NO, SET UP NORMALLY
         MVI   VOL20IND,C'1'       YES, INDICATE WITH SWITCH
         LA    R3,20               LIST ONLY FIRST TWENTY
VOLSINIT EQU   *
         LA    R4,VOLIST+6         GET ADDRESS OF FIRST VOLUME
DISPVOLS EQU   *
         AP    VOLSCNT,=PL1'1'     ADD 1 TO VOLUME COUNT
         UNPK  MSG5+0(2),VOLSCNT   UNPACK VOLUME COUNT
         OI    MSG5+1,X'F0'        CLEAR SIGN NIBBLE
         MVC   MSG5+11(6),0(R4)    MOVE VOLSER INTO MESSAGE
         TPUT  MSG5,L'MSG5         ISSUE VOLSER MESSAGE
         LA    R4,12(R4)           BUMP VOLSER POINTER
         BCT   R3,DISPVOLS         ITERATE
         CLI   VOL20IND,C'1'       WAS SWITCH TURNED ON?
         BNE   VOLSNMSG            NO, BRANCH AROUND MSG
         TPUT  MSG11,L'MSG11       PUT OUT REFERRAL MSG
VOLSNMSG EQU   *
         L     R13,SAVEAREA+4      RETURN
         LM    R14,R12,12(R13)       WITH
         LA    R15,4                   RC=4
         BR    R14                       GO HOME....
         SPACE 1
EXIT3    EQU   *
         L     R9,SAVE3
         BR    R9
         EJECT
***********************************************************************
*    THE PURPOSE OF THIS ROUTINE IS TO OBTAIN THE FORMAT 1 DSCB FOR   *
*  THE INDICATED DATASET AND EXTRACT THE BASIC INFORMATION FROM IT.   *
***********************************************************************
         SPACE 1
GETDSCB1 DS    0H
         ST    R9,SAVE4
         B     BSAVE4
SAVE4    DC    F'-1'
         DC    CL8'GETDSCB1'
BSAVE4   EQU   *
         SPACE 1
*--> GET THE FORMAT 1 DSCB
         OBTAIN OBLIST1            GET DSCB1
         LTR   R15,R15
         BZ    OBOK1
         MVC   MSG4+38(6),VOLSER   MOVE THE VOLUME NAME
         TPUT  MSG4,L'MSG4         IF NOT OK ISSUE ERROR MESSAGE
         L     R13,SAVEAREA+4
         LM    R14,R12,12(R13)
         LA    R15,0
         BR    R14
OBOK1    EQU   *
*--> IF THIS IS A VSAM DATASET, APOLOGIZE AND PRINT THE PACKS ONLY
         TM    DSCB1LST+39,X'08'   IS IT VSAM?
         BNO   EXTALLOC            NO, GO AROUND
         TPUT  MSG8,L'MSG8         ISSUE ERROR MESSAGE
         LH    R3,VOLIST           GET VOLUME COUNT
         LA    R4,VOLIST+6         GET ADDRESS OF FIRST VOLUME
VSAMVOLS EQU   *
         MVC   MSG5+8(6),0(R4)     MOVE VOLSER INTO MESSAGE
         TPUT  MSG5,L'MSG5         ISSUE VOLSER MESSAGE
         LA    R4,12(R4)           BUMP VOLSER POINTER
         BCT   R3,VSAMVOLS         ITERATE
         L     R13,SAVEAREA+4      RETURN
         LM    R14,R12,12(R13)       WITH
         LA    R15,4                   RC=4
         BR    R14                       GO HOME....
*--> GET THE NUMBER OF EXTENTS ALLOCATED
EXTALLOC EQU   *
         XR    R2,R2
         IC    R2,DSCB1LST+15
         CVD   R2,WORKDBLW
         MVC   SC1LN08+2(4),=XL4'40202120'
         ED    SC1LN08+2(4),WORKDBLW+6
*--> GET THE DSORG
         TM    DSCB1LST+38,X'80'   IS DSORG=IS?
         BNO   D1NOTIS
         MVC   SC1LN06+1(2),=CL2'IS'
         B     D1TESTRF
D1NOTIS  EQU   *
         TM    DSCB1LST+38,X'40'   IS DSORG=PS?
         BNO   D1NOTPS
         MVC   SC1LN06+1(2),=CL2'PS'
         B     D1TESTRF
D1NOTPS  EQU   *
         TM    DSCB1LST+38,X'20'   IS DSORG=DA?
         BNO   D1NOTDA
         MVC   SC1LN06+1(2),=CL2'DA'
         B     D1TESTRF
D1NOTDA  EQU   *
         TM    DSCB1LST+38,X'02'   IS DSORG=PO?
         BNO   D1TESTRF
         MVC   SC1LN06+1(2),=CL2'PO'
D1TESTRF EQU   *
         TM    DSCB1LST+38,X'01'   IS DSORG=U?
         BNO   D1NOTU
         MVI   SC1LN06+3,C'U'
D1NOTU   EQU   *
*--> GET THE LRECL
         LH    R2,DSCB1LST+44      GET LRECL
         CVD   R2,WORKDBLW
         MVC   SC1LN10+50(6),=XL6'402020202120'
         ED    SC1LN10+50(6),WORKDBLW+5
*--> GET THE BLKSIZE
         LH    R2,DSCB1LST+42      GET BLKSIZE
         CVD   R2,WORKDBLW
         MVC   SC1LN10+63(6),=XL6'402020202120'
         ED    SC1LN10+63(6),WORKDBLW+5
*--> GET THE KEYLEN
         XR    R2,R2
         IC    R2,DSCB1LST+46      GET KEYLEN
         CVD   R2,WORKDBLW
         MVC   SC1LN14+51(4),=XL4'40202120'
         ED    SC1LN14+51(4),WORKDBLW+6
*--> GET THE RKP
         MVC   WORKDBLW(2),DSCB1LST+47  GET OFFSET
         LH    R2,WORKDBLW
         CVD   R2,WORKDBLW
         MVC   SC1LN14+63(6),=XL6'402020202120'
         ED    SC1LN14+63(6),WORKDBLW+5
*--> GET THE CREATION DATE
         L     R1,DSCB1LST+8       POINT TO CREATION DATE
         BAL   R9,DATESUB          PROCESS IT
         MVC   SC1LN06+21(8),DATEWORK
*--> GET THE LAST REFERENCED DATE
         MVC   SC1LN18+55(8),=CL8'  NONE  '
         CLC   DSCB1LST+31(3),=XL3'00'
         BE    PEXPDATE
         L     R1,DSCB1LST+30      POINT TO LAST REFERENCED DATE
         BAL   R9,DATESUB          PROCESS IT
         MVC   SC1LN18+55(8),DATEWORK
*--> GET THE EXPIRATION DATE AND CHECK IT
PEXPDATE EQU   *
         L     R1,DSCB1LST+12      POINT TO EXPIRATION DATE
         SRL   R1,8                SHIFT TO PROPER POSITION
         BAL   R9,DATESUB          PROCESS IT
         MVC   SC1LN06+31(8),DATEWORK
         CLC   SC1LN06+31(2),=CL2'01'  MONTH 01-12 OK
         BL    CLEXDATE
         CLC   SC1LN06+31(2),=CL2'12'
         BH    CLEXDATE
         CLC   SC1LN06+34(2),=CL2'01'  DAY 01-31 OK
         BL    CLEXDATE
         CLC   SC1LN06+34(2),=CL2'31'
         BH    CLEXDATE
         CLC   SC1LN06+37(2),SC1LN06+27  YEAR => CR YEAR < 99
         BL    CLEXDATE
         CLC   SC1LN06+37(2),=CL2'99'
         BNH   EXDATEOK
CLEXDATE EQU   *
         MVC   SC1LN06+31(8),=CL8'  NONE  '
EXDATEOK EQU   *
*--> GET THE OPTCD AND RECFM (SUBROUTINES FOR EASIER READING)
         BAL   R9,PROPTCD          GO PROCESS THE OPTCD FIELD
         BAL   R9,PRRECFM          GO PROCESS THE RECFM FIELD
         SPACE 1
EXIT4    EQU   *
         L     R9,SAVE4
         BR    R9
         EJECT
***********************************************************************
*    THIS ROUTINE IS A SUBROUTINE OF ROUTINE 'GETDSCB1'.  IT'S ONLY   *
*  PURPOSE IS TO FORMAT THE DCB 'OPTCD' FIELD INTO THE OUTPUT SCREEN. *
***********************************************************************
         SPACE 1
PROPTCD  DS    0H
         ST    R9,SAVE5
         B     BSAVE5
SAVE5    DC    F'-1'
         DC    CL8'PROPTCD '
BSAVE5   EQU   *
         SPACE 1
         LA    R2,SC1LN06+14       PTR TO SCREEN FIELD
         LA    R3,DSCB1LST+41      OPTCD BYTE
         CLI   0(R3),X'00'         IF NO OPTCD
         BNE   OPTCDBR
NOPTCD1  EQU   *
         MVC   0(4,R2),=CL4'NONE'  LABEL FIELD
         B     BYPOPTCD            BYPASS OPTCD PROCESSING
OPTCDBR  EQU   *
         TM    DSCB1LST+38,X'80'   DSORG=IS?
         BO    BLDOPTIS
         TM    DSCB1LST+38,X'40'   DSORG=PS?
         BO    BLDOPTPS
         TM    DSCB1LST+38,X'20'   DSORG=DA?
         BO    BLDOPTDA
         TM    DSCB1LST+38,X'02'   DSORG=PO? (SAME AS PS)
         BO    BLDOPTPS
         B     NOPTCD1
BLDOPTIS EQU   *
         TM    0(R3),X'80'         TEST FOR OPTCD='W'
         BNO   OPTCD1IS
         MVI   0(R2),C'W'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD1IS EQU   *
         TM    0(R3),X'20'         TEST FOR OPTCD='M'
         BNO   OPTCD2IS
         MVI   0(R2),C'M'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD2IS EQU   *
         TM    0(R3),X'10'         TEST FOR OPTCD='I'
         BNO   OPTCD3IS
         MVI   0(R2),C'I'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD3IS EQU   *
         TM    0(R3),X'08'         TEST FOR OPTCD='Y'
         BNO   OPTCD4IS
         MVI   0(R2),C'Y'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD4IS EQU   *
         TM    0(R3),X'02'         TEST FOR OPTCD='L'
         BNO   OPTCD5IS
         MVI   0(R2),C'L'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD5IS EQU   *
         TM    0(R3),X'01'         TEST FOR OPTCD='R'
         BNO   BYPOPTCD
         MVI   0(R2),C'R'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
         B     BYPOPTCD
BLDOPTPS EQU   *
         TM    0(R3),X'80'         TEST FOR OPTCD='W'
         BNO   OPTCD1PS
         MVI   0(R2),C'W'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD1PS EQU   *
         TM    0(R3),X'40'         TEST FOR OPTCD='U'
         BNO   OPTCD2PS
         MVI   0(R2),C'U'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD2PS EQU   *
         TM    0(R3),X'20'         TEST FOR OPTCD='C'
         BNO   OPTCD3PS
         MVI   0(R2),C'C'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD3PS EQU   *
         TM    0(R3),X'10'         TEST FOR OPTCD='H'
         BNO   OPTCD4PS
         MVI   0(R2),C'H'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD4PS EQU   *
         TM    0(R3),X'08'         TEST FOR OPTCD='Q'
         BNO   OPTCD5PS
         MVI   0(R2),C'Q'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD5PS EQU   *
         TM    0(R3),X'04'         TEST FOR OPTCD='Z'
         BNO   OPTCD6PS
         MVI   0(R2),C'Z'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD6PS EQU   *
         TM    0(R3),X'02'         TEST FOR OPTCD='T'
         BNO   OPTCD7PS
         MVI   0(R2),C'T'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD7PS EQU   *
         TM    0(R3),X'01'         TEST FOR OPTCD='J'
         BNO   BYPOPTCD
         MVI   0(R2),C'J'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
         B     BYPOPTCD
BLDOPTDA EQU   *
         TM    0(R3),X'80'         TEST FOR OPTCD='W'
         BNO   OPTCD1DA
         MVI   0(R2),C'W'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD1DA EQU   *
         TM    0(R3),X'20'         TEST FOR OPTCD='E'
         BNO   OPTCD2DA
         MVI   0(R2),C'E'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD2DA EQU   *
         TM    0(R3),X'10'         TEST FOR OPTCD='F'
         BNO   OPTCD3DA
         MVI   0(R2),C'F'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD3DA EQU   *
         TM    0(R3),X'08'         TEST FOR OPTCD='A'
         BNO   OPTCD4DA
         MVI   0(R2),C'A'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
OPTCD4DA EQU   *
         TM    0(R3),X'01'         TEST FOR OPTCD='R'
         BNO   BYPOPTCD
         MVI   0(R2),C'R'          PUT IN SCREEN
         LA    R2,1(R2)            BUMP SCREEN POINTER
         B     BYPOPTCD
BYPOPTCD EQU   *
         SPACE 1
EXIT5    EQU   *
         L     R9,SAVE5
         BR    R9
         EJECT
***********************************************************************
*    THIS ROUTINE IS A SUBROUTINE OF ROUTINE 'GETDSCB1'.  IT'S ONLY   *
*  PURPOSE IS TO FORMAT THE DCB RECFM  FIELD INTO THE OUTPUT SCREEN.  *
***********************************************************************
         SPACE 1
PRRECFM  DS    0H
         ST    R9,SAVE6
         B     BSAVE6
SAVE6    DC    F'-1'
         DC    CL8'PRRECFM '
BSAVE6   EQU   *
         SPACE 1
         LA    R2,SC1LN06+8        POINT TO SCREEN ADDRESS
         TM    DSCB1LST+40,X'C0'   TEST FOR UNKNOWN RECFM
         BZ    RFT
         TM    DSCB1LST+40,X'40'   TEST FOR F RECFM
         BNZ   RFUORV
         MVI   0(R2),C'F'
         LA    R2,1(R2)            BUMP TO NEXT CHAR
         B     RFT
RFUORV   EQU   *
         TM    DSCB1LST+40,X'80'
         BZ    RFV
         MVI   0(R2),C'U'          OTHERWISE UNDEFINED
         LA    R2,1(R2)
         B     RFT
RFV      EQU   *
         MVI   0(R2),C'V'
         LA    R2,1(R2)
RFT      EQU   *
         TM    DSCB1LST+40,X'20'   TEST FOR T RECFM
         BZ    RFB
         MVI   0(R2),C'T'
         LA    R2,1(R2)
RFB      EQU   *
         TM    DSCB1LST+40,X'10'   TEST FOR B RECFM
         BZ    RFS
         MVI   0(R2),C'B'
         LA    R2,1(R2)
RFS      EQU   *
         TM    DSCB1LST+40,X'08'   TEST FOR S RECFM
         BZ    RFA
         MVI   0(R2),C'S'
         LA    R2,1(R2)
RFA      EQU   *
         TM    DSCB1LST+40,X'04'   TEST FOR A RECFM
         BZ    RFM
         MVI   0(R2),C'A'
         LA    R2,1(R2)
RFM      EQU   *
         TM    DSCB1LST+40,X'02'   TEST FOR M RECFM
         BZ    RFEND
         MVI   0(R2),C'M'
         LA    R2,1(R2)
RFEND    EQU   *
         SPACE 1
EXIT6    EQU   *
         L     R9,SAVE6
         BR    R9
         EJECT
***********************************************************************
*    THE PURPOSE OF THIS ROUTINE IS TO CONVERT A JULIAN (YDD) FORMAT  *
*  DATE INTO A GREGORIAN FORMAT.  AT ENTRY TO THE ROUTINE, R1 CONTAINS*
*  THE JULIAN DATE.  UPON EXIT, "DATEWORK" CONTAINS THE DATE.         *
***********************************************************************
         SPACE 1
DATESUB  DS    0H
         ST    R9,SAVE7
         B     BSAVE7
SAVE7    DC    F'-1'
         DC    CL8'DATESUB '
BSAVE7   EQU   *
         SPACE 1
*--------TEST FOR LEAP YEAR
         ST    R1,DATEWORK         STORE ARGUEMENT
         LH    R1,DATEWORK+2       LOAD DAY OF YEAR
         TM    DATEWORK+1,X'03'    TEST FOR YEAR MULTIPLE OF 4
         BZ    DATEMODA
*--------NOT A LEAP YEAR
         C     R1,=F'60'
         BL    DATEMODA
         LA    R1,1(R1)
*--------CONVERT DAY OF YEAR TO MONTH AND DAY OF MONTH
DATEMODA EQU   *
         XR    R2,R2               INIT MONTH COUNTER
DATECVT1 EQU   *
         SH    R1,DATEMNTH(R2)     SUBTRACT NO. OF DAYS IN MONTH
         LTR   R1,R1
         BNP   DATECVT2
         LA    R2,2(R2)
         B     DATECVT1
*--------ADD BACK NUMBER OF DAYS AND DIVIDE REGISTER BY 2
DATECVT2 EQU   *
         AH    R1,DATEMNTH(R2)
         SRA   R2,1
         LA    R2,1(R2)
         XR    R3,R3
         IC    R3,DATEWORK+1
*--------REG 1 = DAY OF MONTH
*--------REG 2 = MONTH
*--------REG 3 = YEAR
         CVD   R2,DATEPDEC
         UNPK  DATEUDEC(8),DATEPDEC+4(4)
         OI    DATEUDEC+7,X'F0'
         MVC   DATEWORK(2),DATEUDEC+6
         MVI   DATEWORK+2,C'/'
         CVD   R1,DATEPDEC
         UNPK  DATEUDEC(8),DATEPDEC+4(4)
         OI    DATEUDEC+7,X'F0'
         MVC   DATEWORK+3(2),DATEUDEC+6
         MVI   DATEWORK+5,C'/'
         CVD   R3,DATEPDEC
         UNPK  DATEUDEC(8),DATEPDEC+4(4)
         OI    DATEUDEC+7,X'F0'
         MVC   DATEWORK+6(2),DATEUDEC+6
         SPACE 1
EXIT7    EQU   *
         L     R9,SAVE7
         BR    R9
         EJECT
***********************************************************************
*   THE PURPOSE OF THIS ROUTINE IS TO COMPUTE THE AMOUNT OF SPACE     *
* ALLOCATED AND USED FOR THE DATASET, AND TO FORMAT THE EXTENT COUNT. *
* IF THE EXTENSION POINTER IN THE DSCB1 CONTAINS ZEROES, NO ATTEMPT   *
* WILL BE MADE TO READ THE DSCB3.  FOR ISAM, WE GET TO THE DSCB3 VIA  *
* THE DSCB2.  ALSO, WE DON'T DO SPACE USED CALCULATIONS FOR ISAM.     *
***********************************************************************
         SPACE 1
GETDSCB3 DS    0H
         ST    R9,SAVE8
         B     BSAVE8
SAVE8    DC    F'-1'
         DC    CL8'GETDSCB3'
BSAVE8   EQU   *
         SPACE 1
         CLC   DSCB1LST+91(5),=5XL1'00'    IS THERE AN EXTENSION?
         BE    NODSCB3                     NO, NOT ISAM EITHER
         TM    DSCB1LST+38,X'80'           IS IT ISAM?
         BNO   NOTISAM                     NO, GO GET DSCB3
         OBTAIN OBLIST2                    ASK FOR DSCB2
         LTR   R15,R15                     DID OBTAIN WORK?
         BZ    ISAMDSC3                    YES, GO AROUND
         TPUT  MSG9,L'MSG9                 PUT OUT AN ERROR MSG
         L     R13,SAVEAREA+4              GET SAVEAREA ADDRESS
         LM    R14,R12,12(R13)             RESTORE THE REGISTERS
         LA    R15,4                       SET BAD RETURN CODE
         BR    R14                         GO HOME......
ISAMDSC3 EQU   *
         CLC   DSCB2LST+135(5),=5XL1'00'   IS THERE AN EXTENSION?
         BE    NODSCB3                     NO, BYPASS DSCB3 OBTAIN
         MVC   DSCB1LST+91(5),DSCB2LST+135 MOVE THE DSCB3 PTR
NOTISAM  EQU   *
         OBTAIN OBLIST3                    ASK FOR DSCB3
         LTR   R15,R15                     DID OBTAIN WORK?
         BZ    NODSCB3                     YES, GO AROUND
         TPUT  MSG7,L'MSG7                 PUT OUT ERROR MSG
         L     R13,SAVEAREA+4
         LM    R14,R12,12(R13)
         LA    R15,4
         BR    R14
NODSCB3  EQU   *
         TM    DSCB1LST+50,X'C0'   TEST FOR CYLINDERS
         BNO   TYPETRK
         MVC   SC1LN11+17(09),=CL09'CYLINDERS'
         B     ETYPE
TYPETRK  EQU   *
         TM    DSCB1LST+50,X'80'   TEST FOR TRACKS
         BNO   TYPEBLK
         MVC   SC1LN11+17(06),=CL06'TRACKS'
         B     ETYPE
TYPEBLK  EQU   *
         TM    DSCB1LST+50,X'40'   TEST FOR PHYSICAL BLOCKS
         BNO   TYPEREL
         MVC   SC1LN11+17(06),=CL06'BLOCKS'
         B     ETYPE
TYPEREL  EQU   *
         MVC   SC1LN11+17(16),=CL16'ABSOLUTE TRACKS '
ETYPE    EQU   *
         LH    R2,DSCB1LST+52      GET SECONDARY COUNT
         CVD   R2,WORKDBLW
         MVC   SC1LN12+33(6),=XL6'402020202120'
         ED    SC1LN12+33(6),WORKDBLW+5
         MVC   SC1LN11(16),=CL16'ALLOCATION IS IN'
         MVC   SC1LN12(32),=CL32'SECONDARY ALLOCATION QUANTITY IS'
         XR    R2,R2               CLEAR BCT REGISTER
         IC    R2,DSCB1LST+15      GET EXTENT COUNT
         LA    R3,AEXTENTS         INIT EXTENT ADDR PTR
         XR    R5,R5               CLEAR ACCUMULATOR
ADDEMUP  EQU   *
         L     R4,0(R3)            LOAD ADDR OF EXTENT
         CLI   0(R4),X'00'         IS EXTENT IN USE
         BE    ADDONE              IT'S OVER....
         LA    R4,2(R4)
         LH    R7,4(R4)            LOAD ADDR OF START CYLINDER
         LH    R8,0(R4)                         END CYLINDER
         SR    R7,R8               SUBTRACT
         MH    R7,TRKCOUNT         * BY TRACKS PER CYLINDER
         LH    R8,6(R4)            LOAD ENDING TRACK
         AR    R7,R8               ADD TO TRACK TOTAL
         LH    R8,2(R4)            LOAD STARTING TRACK
         SR    R7,R8
         AR    R5,R7               ADD TO ACCUMULATOR
         LA    R5,1(R5)            INCLUSIVE - BUMP BY 1
         LA    R3,4(R3)            BUMP EXTENT POINTER
         BCT   R2,ADDEMUP          LOOP BACK
ADDONE   EQU   *
         CVD   R5,WORKDBLW
         MVC   SC1LN09+0(6),=XL6'402020202120'
         ED    SC1LN09+0(6),WORKDBLW+5
         MVC   SC1LN09+7(18),=CL18'= TRACKS ALLOCATED'
         TM    DSCB1LST+38,X'80'       IS IT ISAM?
         BNO   PROCUSED                NO, GO PROCESS TRACKS USED
         MVI   SC1LN12,C' '            CLEAR IRRELEVANT MESSAGE
         MVC   SC1LN12+1(40),SC1LN12
         XR    R5,R5                   CLEAR A REGISTER
         IC    R5,DSCB2LST+45          GET NUMBER OF INDEX LEVELS
         CVD   R5,WORKDBLW             CONVERT RADIX
         MVC   SC1LN13+4(4),=XL4'40202120'
         ED    SC1LN13+4(4),WORKDBLW+6
         MVC   SC1LN13+9(24),=CL24'= NUMBER OF INDEX LEVELS'
         ICM   R5,X'0F',DSCB2LST+67    GET NUMBER OF PRIME RECORDS
         CVD   R5,WORKDBLW
         MVC   SC1LN14(8),=XL8'4020202020202120'
         ED    SC1LN14(8),WORKDBLW+4
         MVC   SC1LN14+9(33),=CL33'= NUMBER OF RECORDS IN PRIME AREA'
         LH    R5,DSCB2LST+128
         CVD   R5,WORKDBLW
         MVC   SC1LN15(8),=XL8'4020202020202120'
         ED    SC1LN15(8),WORKDBLW+4
         MVC   SC1LN15+9(36),=C'= NUMBER OF RECORDS IN OVERFLOW AREA'
         B     BYPUSED
PROCUSED EQU   *
         LH    R5,DSCB1LST+54
         CLC   DSCB1LST+54(3),=XL3'000000'
         BE    NONEUSED
         LA    R5,1(R5)
NONEUSED EQU   *
         CVD   R5,WORKDBLW
         MVC   SC1LN10+0(6),=XL6'402020202120'
         ED    SC1LN10+0(6),WORKDBLW+5
         MVC   SC1LN10+7(13),=CL13'= TRACKS USED'
BYPUSED  EQU   *
         SPACE 1
EXIT8    EQU   *
         L     R9,SAVE8
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE OBTAINS THE CURRENT TIME AND DATE AND FORMATS THE    *
* INFORMATION ONTO THE SCREEN.                                        *
***********************************************************************
         SPACE 1
GETDATE  DS    0H
         ST    R9,SAVE9
         B     BSAVE9
SAVE9    DC    F'-1'
         DC    CL8'GETDATE '
BSAVE9   EQU   *
         SPACE 1
         TIME  DEC                     GET THE TIME IN DECIMAL
*--> FORMAT THE CURRENT TIME
         STM   R0,R1,WORKDBLW          STORE THE RESULTS
         UNPK  WORKTIME,WORKDBLW(4)    UNPACK THE TIME
         OI    WORKTIME+7,X'F0'        CLEAR THE SIGN NIBBLE
         MVC   SC1LN24+72(2),WORKTIME+1  MOVE THE HH
         MVC   SC1LN24+75(2),WORKTIME+3           MM
         MVC   SC1LN24+78(2),WORKTIME+5           SS
*--> FORMAT THE CURRENT DATE
         MVC   DIVFIELD+0(2),=XL2'0019'    MOVE ZEROES + 19
         MVC   DIVFIELD+2(1),WORKDBLW+5    MOVE YEAR
         MVI   DIVFIELD+3,X'0F'            MOVE SIGN NIBBLE
         DP    DIVFIELD,=PL2'40'       DIVIDE BY 4 X 10
         CP    DIVFIELD+2(2),=PL1'0'   IS IT A LEAP YEAR?
         BNE   NOTLEAP                 NO, DON'T CHANGE TABLE
         ZAP   MONTHTBL+2(2),=PL2'29'  FEBRUARY
NOTLEAP  EQU   *
         LA    R4,MONTHTBL             GET ADDRESS OF MONTHTBL
         LA    R5,12                   NUMBER OF MONTHS FOR BCT
         ZAP   MONTH,=PL1'1'           SOMEPLACE TO START
MONTH1   EQU   *
         CP    WORKDBLW+6(2),0(2,R4)   NUMBER OF DAYS IN MONTH
         BNH   MONTHEND                LESS THAN MONTH, GO FORMAT
         SP    WORKDBLW+6(2),0(2,R4)   MORE THAN A MONTH
         AP    MONTH,=PL1'1'           ADD 1 TO MONTH
         LA    R4,2(R4)                BUMP MONTH POINTER
         BCT   R5,MONTH1               GO TRY NEXT MONTH
MONTHEND EQU   *
         LA    R3,SC1LN24              ADDRESS OF DATE FIELD
         UNPK  0(2,R3),MONTH           UNPACK MONTH
         OI    1(R3),X'F0'             CLEAR SIGN NIBBLE
         MVI   2(R3),C'/'              INSERT THE SLASH
         UNPK  3(2,R3),WORKDBLW+6(2)   MOVE THE DAY
         OI    4(R3),X'F0'             CLEAR SIGN NIBBLE
         MVI   5(R3),C'/'              INSERT THE SLASH
         UNPK  WORKTIME+0(3),WORKDBLW+5(2) UNPACK THE YEAR
         OI    WORKTIME+2,X'F0'        CLEAR SIGN NIBBLE
         MVC   SC1LN24+6(2),WORKTIME   MOVE THE YEAR
         SPACE 1
EXIT9    EQU   *
         L     R9,SAVE9
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE WILL SCAN THE TIOT FOR THE DDNAME "DSATPRNT".  IF IT *
* IS FOUND, THE PROGRAM WILL ASSUME THAT THE USER HAS PRE-ALLOCATED   *
* A PRINT FILE WHICH THE SCREEN WILL BE WRITTEN TO.  IF THE DDNAME    *
* IS NOT FOUND, THE ROUTINE WILL RETURN VIA R9.                       *
***********************************************************************
         SPACE 1
PRINTER  DS    0H
         ST    R9,SAVE10
         B     BSAVE10
SAVE10   DC    F'-1'
         DC    CL8'PRINTER '
BSAVE10  EQU   *
         SPACE 1
         L     R2,16(0)            CVT
         L     R2,0(R2)            CVT -> TCB LIST
         L     R2,4(R2)            TCB LIST -> TCB
         L     R2,12(R2)           TCB -> TIOT
         LA    R2,24(R2)           TIOT + 12
SCANDD   EQU   *
         CLC   4(8,R2),=CL8'DSATPRNT'  IS THIS THE DDNAME?
         BE    FOUNDDD
         XR    R3,R3               CLEAR R3
         IC    R3,0(R2)            GET LENGTH OF TIOT ENTRY
         AR    R2,R3               ADD LENGTH
         L     R3,0(R2)            GET STUFF
         LTR   R3,R3               NULL POINTER?
         BZ    EXIT10              YES, NO PRINTER.
         B     SCANDD
FOUNDDD  EQU   *
         OPEN  (PRINTDCB,OUTPUT)
         MVI   PRINTREC,C' '               FORMAT FIRST LINE
         MVC   PRINTREC+1(132),PRINTREC
         MVI   PRINTREC,C'1'
         MVI   PRINTREC+25,C'*'
         MVC   PRINTREC+26(83),PRINTREC+25
         PUT   PRINTDCB,PRINTREC
         MVI   PRINTREC,C' '               FORMAT SECOND LINE
         MVC   PRINTREC+1(132),PRINTREC
         MVI   PRINTREC+25,C'*'
         MVI   PRINTREC+108,C'*'
         PUT   PRINTDCB,PRINTREC
         LA    R2,SCREEN1                  ADDR OF SCREEN
         LA    R3,24                       COUNT FOR BCT
PRNTLOOP EQU   *
         MVC   PRINTREC+27(80),0(R2)
         PUT   PRINTDCB,PRINTREC
         LA    R2,80(R2)
         BCT   R3,PRNTLOOP
         MVI   PRINTREC,C' '
         MVC   PRINTREC+1(132),PRINTREC
         MVI   PRINTREC+25,C'*'
         MVI   PRINTREC+108,C'*'
         PUT   PRINTDCB,PRINTREC
         MVC   PRINTREC+26(83),PRINTREC+25
         PUT   PRINTDCB,PRINTREC
         CLOSE (PRINTDCB)
         MVC   SC1LN20(27),=CL27'THIS SCREEN WILL BE PRINTED'
         SPACE 1
EXIT10   EQU   *
         L     R9,SAVE10
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE BUILDS THE FINAL SCREEN, DOES A FULL SCREEN TPUT,    *
* A DUMMY TGET, AND CLEARS THE SCREEN.  THE MAJOR PART OF THE CODE    *
* IS THE BUILDING OF THE FINAL SCREEN.  THE ROUTINE HAS THREE INPUTS. *
* SCREEN1 IS ASSUMED TO BE A STANDARD 1920 BYTE SCREEN IMAGE WITH NO  *
* ATTRIBUTE CHARACTERS.  'ALISTPTR' CONTAINS THE ADDRESS OF THE       *
* ATTRIBUTE LIST THAT WE WILL USE THIS TIME AROUND.  'SCPREFIX' IS    *
* THE CONTROL STREAM WHICH IS TO BE PREFIXED ONTO THE FINAL SCREEN.   *
*   USING THE THREE INPUTS, A TPUT'ABLE FINAL SCREEN IS BUILT IN THE  *
* 'SCRBLD' AREA AT THE END OF THE PROGRAM.                            *
***********************************************************************
         SPACE 1
FULLSCR  DS    0H
         ST    R9,SAVE11
         B     BSAVE11
SAVE11   DC    F'-1'
         DC    CL8'FULLSCR '
BSAVE11  EQU   *
         SPACE 1
*--> INIT REGISTERS
         L     R2,ALISTPTR             GET PTR TO ATTRIBUTE LIST
         L     R3,0(R2)                GET END OF ATTRIBUTE LIST
         LA    R2,4(R2)                BUMP PAST END ADDRESS
         LA    R4,SCRBLD               GET ADDR OF BUILD AREA
         XR    R5,R5                   INIT LENGTH REGISTER
         LA    R6,SCREEN1              GET ADDR OF INPUT SCREEN
         LA    R7,1920(R6)             GET END OF INPUT SCREEN
*--> INSERT PREFIX
         MVC   0(L'SCPREFIX,R4),SCPREFIX   MOVE PREFIX
         LA    R4,L'SCPREFIX(R4)       BUMP PTR
         LA    R5,L'SCPREFIX(R5)       ADD LENGTH
*--> FLAG ATTRIBUTE BYTES FIRST
FSLOOP10 EQU   *
         CR    R2,R3                   END OF ATTRIBUTE LIST?
         BE    FSLOOP20                YES, END OF FLAGGING
         L     R8,0(R2)                GET ADDR OF NEXT ATTR BYTE
         MVI   0(R8),X'1D'             FLAG BYTE WITH A X'FF'
         LA    R2,4(R2)                GET NEXT ATTRIBUTE ADDR
         B     FSLOOP10                GO TRY NEXT
FSLOOP20 EQU   *
         L     R2,ALISTPTR             GET PTR TO ATTRIBUTE LIST
         LA    R2,4(R2)                BUMP PAST END ADDRESS
FSLOOP30 EQU   *
         CR    R6,R7                   INPUT SCREEN EXHAUSTED?
         BE    FSLOOP50                GO TPUT
         CLI   0(R6),X'1D'             IS THIS A FLAG?
         BE    FSLOOP40                YES, GO PROCESS
         MVC   0(1,R4),0(R6)           NO, MOVE THIS BYTE TO OUTPUT
         LA    R4,1(R4)                BUMP PTR TO OUTPUT SCREEN
         LA    R5,1(R5)                BUMP LENGTH OF OUTPUT
         LA    R6,1(R6)                BUMP TO NEXT INPUT BYTE
         B     FSLOOP30                GO TRY NEXT BYTE
FSLOOP40 EQU   *
         MVC   0(1,R4),0(R6)           MOVE FLAG TO OUTPUT
         MVC   1(1,R4),0(R2)           MOVE ATTR TO OUTPUT
         LA    R2,4(R2)                BUMP TO NEXT ATTR
         LA    R4,2(R4)                BUMP TWO BYTES IN OUTPUT
         LA    R5,2(R5)                BUMP LENGTH BY TWO
         LA    R6,1(R6)                BUMP TO NEXT INPUT BYTE
         B     FSLOOP30                GO TRY NEXT BYTE
FSLOOP50 EQU   *
         MVC   0(L'SCSUFFIX,R4),SCSUFFIX  MOVE SUFFIX
         LA    R5,L'SCSUFFIX(R5)       BUMP LENGTH OF SUFFIX
*--> TGET'S AND TPUT'S
         STFSMODE ON,INITIAL=YES       SET FULL SCREEN MODE ON
         TPUT  SCRBLD,(R5),FULLSCR     PAINT OUTPUT SCREEN
         TGET  DSN,80                  GET DUMMY INPUT/NEW DSN
         LTR   R1,R1                   WAS A NEW DSN ENTERED?
         BZ    FSBYPSW                 NO, BYPASS SWITCH SETTING
         MVI   STACKSW,C'1'            YES, TURN SWITCH ON
         OC    DSN(80),=CL80' '        SET INPUT TO UPPER CASE
FSBYPSW  EQU   *
         TPUT  CLSCREEN,12,FULLSCR     CLEAR SCREEN
         STLINENO MODE=OFF,LINE=1      SET FULL SCREEN MODE OFF
         SPACE 1
EXIT11   EQU   *
         L     R9,SAVE11
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE IS ENTERED IF THE TERMINAL USER TYPED A NEW DSN INTO *
* THE FIRST LINE OF THE DISPLAY SCREEN.  IF THEY DID, THIS ROUTINE IS *
* USED TO RE-INVOKE DSAT USING THE STACK MACRO.                       *
***********************************************************************
         SPACE 1
STACKRTN DS    0H
         ST    R9,SAVE12
         B     BSAVE12
SAVE12   DC    F'-1'
         DC    CL8'STACKRTN'
BSAVE12  EQU   *
         SPACE 1
         GETMAIN LU,LA=STCKGMRQ,A=STCKGMRS,SP=78
         SPACE 1
         L     R4,STCKGMRS             ADDR OF LSD & COMMAND
         MVC   0(16,R4),STCKLSD        MOVE LSD TO SP 78 AREA
         L     R5,STCKGMRS+4           ADDR OF SP 78 COMMAND AREA
         MVC   0(5,R5),=CL5'DSAT '     MOVE OUR COMMAND NAME
         MVC   5(47,R5),DSN            MOVE INPUT DSN
         ST    R5,0(R4)                STORE COMMAND ADDR IN LSD
         ST    R5,8(R4)                STORE COMMAND ADDR IN LSD
         L     R2,CPPLUPT              ADDR OF USER PROFILE TABLE
         L     R3,CPPLECT              ADDR OF ENVIRONMENT CONTROL TBL
         SPACE 1
         STACK PARM=STCKLIST,          ADDR OF LIST FORM MACRO         X
               UPT=(R2),               ADDR OF USER PROFILE TABLE      X
               ECT=(R3),               ADDR OF ENVIRONMENT CONTROL TBL X
               ECB=STCKECB,            ADDR OF EVENT CONTROL BLOCK     X
               STORAGE=((R4),SOURCE),  ADDR OF LIST STORAGE DESCRIPTOR X
               MF=(E,STCKIOPL)         EXECUTE FORM & IOPL STORAGE
         LTR   R15,R15                 SUCCESSFUL OPERATION?
         BZ    EXIT12                  YES, EXIT
         ISK   0,0                     NO, ABEND RIGHT HERE
         SPACE 1
EXIT12   EQU   *
         L     R9,SAVE12
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE IS ENTERED IF THE TERMINAL USER TYPED A /X FLAG IN   *
* THE INPUT DSN FIELD SOMEWHERE.  THIS ROUTINE FORMATS THE EXTENT     *
* INFORMATION AND PRESENTS IT ON THE SCREEN.                          *
***********************************************************************
         SPACE 1
EXTENTS  DS    0H
         ST    R9,SAVE13
         B     BSAVE13
SAVE13   DC    F'-1'
         DC    CL8'EXTENTS '
BSAVE13  EQU   *
         SPACE 1
         TPUT  MSG12,L'MSG12           WRITE HEADING MESSAGE
         TPUT  MSG13,L'MSG13                 BLANK
         XR    R2,R2                   CLEAR WORK REGISTER
         IC    R2,DSCB1LST+15          INSERT EXTENT COUNT
         ZAP   VOLSCNT,=PL1'0'         CLEAR MSG COUNT
         LA    R3,AEXTENTS             GET EXTENTS ADDRESS LIST
EXTNT000 EQU   *
         LA    R6,8                    NUMBER OF NIBBLES IN FOUR
         XR    R4,R4                   CLEAR WORK REG
         L     R5,0(R3)                LOAD ADDR OF BEGINNING EXTENT
         L     R5,2(R5)                PICK UP FIRST EXTENT
         LA    R7,WORKDBLW             GET BEGINNING ADDRESS
EXTNT010 EQU   *
         SLDL  R4,4                    SHIFT FOUR BITS INTO R4
         STC   R4,0(R7)                STORE INTO WORK AREA
         XR    R4,R4                   CLEAR REGISTER
         LA    R7,1(R7)                BUMP WORK AREA POINTER
         BCT   R6,EXTNT010             ITERATE 8 TIMES
         MVC   MSG14+18(8),WORKDBLW    MOVE TO MESSAGE
         TR    MSG14+18(8),HEXTRT      TRANSLATE
         LA    R6,8                    NUMBER OF NIBBLES IN FOUR
         XR    R4,R4                   CLEAR WORK REG
         L     R5,0(R3)                LOAD ADDR OF BEGINNING EXTENT
         L     R5,6(R5)                PICK UP FIRST EXTENT
         LA    R7,WORKDBLW             GET BEGINNING ADDRESS
EXTNT020 EQU   *
         SLDL  R4,4                    SHIFT FOUR BITS INTO R4
         STC   R4,0(R7)                STORE INTO WORK AREA
         XR    R4,R4                   CLEAR REGISTER
         LA    R7,1(R7)                BUMP WORK AREA POINTER
         BCT   R6,EXTNT020             ITERATE 8 TIMES
         MVC   MSG14+33(8),WORKDBLW    MOVE TO MESSAGE
         TR    MSG14+33(8),HEXTRT      TRANSLATE
         AP    VOLSCNT,=PL1'1'         ADD ONE TO MSG COUNT
         UNPK  MSG14+7(2),VOLSCNT      UNPACK MSG COUNT
         OI    MSG14+8,X'F0'           CLEAR SIGN NIBBLE
         TPUT  MSG14,L'MSG14           PUT OUT EXTENT MSG
         LA    R3,4(R3)                BUMP TO NEXT EXTENT
         BCT   R2,EXTNT000             ITERATE
         SPACE 1
EXIT13   EQU   *
         L     R9,SAVE13
         BR    R9
         EJECT
MSG1     DC    CL29'PLEASE ENTER THE DATASET NAME'
MSG2     DC    CL40'UNABLE TO LOCATE DSNAME IN CATALOG, DSN='
MSG3     DC    CL43'DATASET NOT ON A DIRECT ACCESS DEVICE, DSN='
MSG4     DC    CL44'DATASET NOT FOUND ON INDICATED VOLUME XXXXXX'
MSG5     DC    CL17'   VOL=SER=XXXXXX'
MSG7     DC    CL42'UNABLE TO OBTAIN FORMAT 3 (EXTENSION) DSCB'
MSG8     DC    CL44'SORRY - DSAT DOES NOT CURRENTLY SUPPORT VSAM'
MSG9     DC    CL37'UNABLE TO OBTAIN FORMAT 2 (ISAM) DSCB'
MSG10    DC    CL43'VOLSER ENTERED BY USER NOT ACTIVE IN SYSTEM'
MSG11    DC    CL48'MORE VOLUMES THAN CAN BE LISTED, CONSULT LIBRARY'
MSG12    DC    CL41'------------ DATASET EXTENTS ------------'
MSG13    DC    CL1' '
MSG14    DC    CL41'EXTENT XX BEGIN = AAAAAAAA END = BBBBBBBB'
TRKCOUNT DC    H'0'       TRACKS PER CYLINDER
DSN      DC    CL80' '    INPUT BUFFER FOR DATASET NAME
DSN2     DC    CL80' '    WORKAREA FOR APPENDING USERID
PRMSZE   DS    CL2        PRIMARY SCREEN SIZE
ALTSZE   DS    CL2        ALTERNATE SCREEN SIZE
VOLSER   DC    CL6' '     VOLSER IF NOT IN CATALOG
APOSTSW  DC    CL1'0'     APPEND USERID FLAG 0 = YES, 1 = NO
STACKSW  DC    CL1'0'     STACK NEW DSAT CMND 0 = NO, 1 = YES
SYSREQSW DC    CL1'0'     REQUEST EXTENTS 0 = NO, 1 = YES
VOL20IND DC    CL1'0'     MORE THAN 20 VOLUMES? 0 = NO, 1 = YES
VOLSCNT  DC    PL2'0'     VOLUME COUNT FOR MSG 5 DISPLAY
DSADCB   DS    X          COPY OF CVTDCB - OP SYS
DSADCBXA EQU   X'80'      XA OPERATING SYSTEM
WORKTIME DS    CL8
MONTHTBL DC    PL2'31',PL2'28',PL2'31',PL2'30',PL2'31',PL2'30'
         DC    PL2'31',PL2'31',PL2'30',PL2'31',PL2'30',PL2'31'
DIVFIELD DS    PL4                     MEMORY FOR DIVIDE PACKED
MONTH    DS    PL2                     PACKED MONTH
WORKDBLW DC    D'0'       WORKAREA FOR CVD INSTRUCTIONS
PRINTDCB DCB   DSORG=PS,MACRF=PM,RECFM=FBA,LRECL=133,DDNAME=DSATPRNT
PRINTREC DS    CL133
         DS    0D
*--------CATALOG SEARCH MACRO
LOCLIST  CAMLST NAME,DSN,,VOLIST
         DS    0D
VOLIST   DS    CL265
*--------VTOC DSCB 1 OBTAIN MACRO (HEADER DSCB)
OBLIST1  CAMLST SEARCH,DSN,VOLIST+6,DSCB1LST
         DS    0D
DSCB1LST DS    CL148
*--------VTOC DSCB 2 OBTAIN MACRO (ISAM DSCB)
OBLIST2  CAMLST SEEK,DSCB1LST+91,VOLIST+6,DSCB2LST
         DS    0D
DSCB2LST DS    CL148
*--------VTOC DSCB 3 OBTAIN MACRO (EXTENSION DSCB)
OBLIST3  CAMLST SEEK,DSCB1LST+91,VOLIST+6,DSCB3LST
         DS    0D
DSCB3LST DS    CL148
*--------STACK MACRO OPERAND AREA
STCKGMRS DC    2F'0'                   GETMAIN RESPONSE AREA
STCKGMRQ DS    0F                      GETMAIN REQUEST AREA
         DC    F'16'                       16 BYTES FOR THE LSD
         DC    X'80'                       LAST REQUEST INDICATOR
         DC    AL3(52)                     52 BYTES FOR COMMAND
STCKLIST STACK MF=L                    LIST FORM STACK MACRO
STCKECB  DC    F'0'                    ECB FOR STACK MACRO USE
STCKIOPL DC    4F'0'                   INPUT/OUTPUT PARAMETER LIST
STCKLSD  DS    0F                      LIST SOURCE DESCRIPTOR
         DC    A(0)                        ADDR OF IN-STORAGE LIST
         DC    H'52'                       RECORD LENGTH OF ELEMENT
         DC    H'52'                       TOTAL LENGTH OF LIST
         DC    A(0)                        POINTER TO COMMAND
         DC    A(0)                        RESERVED
         SPACE 2
*--------DATE ROUTINE WORK AREA
DATEWORK DS    2F
DATEMNTH DC    H'31'  JAN
         DC    H'29'  FEB
         DC    H'31'  MAR
         DC    H'30'  APR
         DC    H'31'  MAY
         DC    H'30'  JUN
         DC    H'31'  JUL
         DC    H'31'  AUG
         DC    H'30'  SEP
         DC    H'31'  OCT
         DC    H'30'  NOV
         DC    H'31'  DEC
DATEPDEC DS    D
DATEUDEC DS    D
         SPACE 2
AEXTENTS EQU   *
         DC    A(DSCB1LST+061)  ADDRESS OF EXTENT 1
         DC    A(DSCB1LST+071)  ADDRESS OF EXTENT 2
         DC    A(DSCB1LST+081)  ADDRESS OF EXTENT 3
         DC    A(DSCB3LST+004)  ADDRESS OF EXTENT 4
         DC    A(DSCB3LST+014)  ADDRESS OF EXTENT 5
         DC    A(DSCB3LST+024)  ADDRESS OF EXTENT 6
         DC    A(DSCB3LST+034)  ADDRESS OF EXTENT 7
         DC    A(DSCB3LST+045)  ADDRESS OF EXTENT 8
         DC    A(DSCB3LST+055)  ADDRESS OF EXTENT 9
         DC    A(DSCB3LST+065)  ADDRESS OF EXTENT 10
         DC    A(DSCB3LST+075)  ADDRESS OF EXTENT 11
         DC    A(DSCB3LST+085)  ADDRESS OF EXTENT 12
         DC    A(DSCB3LST+095)  ADDRESS OF EXTENT 13
         DC    A(DSCB3LST+105)  ADDRESS OF EXTENT 14
         DC    A(DSCB3LST+115)  ADDRESS OF EXTENT 15
         DC    A(DSCB3LST+125)  ADDRESS OF EXTENT 16
         SPACE 2
HEXTRT   EQU   *     0 1 2 3 4 5 6 7 8 9 A B C D E F
         DC    XL16'F0F1F2F3F4F5F6F7F8F9C1C2C3C4C5C6' 0
         DC    XL16'F1000000000000000000000000000000' 1
         DC    XL16'F2000000000000000000000000000000' 2
         DC    XL16'F3000000000000000000000000000000' 3
         DC    XL16'F4000000000000000000000000000000' 4
         DC    XL16'F5000000000000000000000000000000' 5
         DC    XL16'F6000000000000000000000000000000' 6
         DC    XL16'F7000000000000000000000000000000' 7
         DC    XL16'F8000000000000000000000000000000' 8
         DC    XL16'F9000000000000000000000000000000' 9
         DC    XL16'C1000000000000000000000000000000' A
         DC    XL16'C2000000000000000000000000000000' B
         DC    XL16'C3000000000000000000000000000000' C
         DC    XL16'C4000000000000000000000000000000' D
         DC    XL16'C5000000000000000000000000000000' E
         DC    XL16'C6000000000000000000000000000000' F
         LTORG
         EJECT
***********************************************************************
*                                                                     *
*               D E V I C E   N A M E   T A B L E                     *
*                                                                     *
***********************************************************************
         SPACE 1
DEVTABLE EQU   *
         DC    X'2008'
         DC    X'0014'
         DC    CL16'   2314 DISK    '
         DC    X'2002'
         DC    X'00C8'
         DC    CL16'   2301 DRUM    '
         DC    X'2003'
         DC    X'000A'
         DC    CL16'   2303 DRUM    '
         DC    X'2001'
         DC    X'000A'
         DC    CL16'   2311 DISK    '
         DC    X'2004'
         DC    X'002E'
         DC    CL16' 2302 DISK FILE '
         DC    X'2005'
         DC    X'0514'
         DC    CL16' 2321 DATA CELL '
         DC    X'2006'
         DC    X'0008'
         DC    CL16'  2305-1 DRUM   '
         DC    X'2007'
         DC    X'0008'
         DC    CL16'  2305-2 DRUM   '
         DC    X'2009'
         DC    X'0013'
         DC    CL16'   3330 DISK    '
         DC    X'200D'
         DC    X'0013'
         DC    CL16'  3330-1 DISK   '
         DC    X'200B'
         DC    X'001E'
         DC    CL16'   3350 DISK    '
         DC    X'200E'
         DC    X'000F'
         DC    CL16'   3380 DISK    '
         DC    X'0000'         ** MARKS END OF DEVICE TABLE **
         EJECT
*--> THE FOLLOWING ARE USED BY THE 'FULLSCR' ROUTINE
CLSCREEN DC    XL12'C11140403C4040001140C113'
SCPREFIX DC    XL11'C11140403C404000114040'
SCSUFFIX DC    XL11'11C1C53CC14E001140D913'
         SPACE 1
ALISTPTR DC    A(ATRLST1B)             PTR TO ACTIVE ATTR LIST
         SPACE 1
ATRLST1B DS    0F
         DC    A(ATRLST1E)             END OF THIS LIST
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN01+00)         FIRST BYTE OF SCREEN
         DC    AL1(ATR@UH)             UNPROT-HIGH  / RED
         DC    AL3(SC1LN01+24)         JUST BEFORE DSN
         DC    AL1(ATR@PH)             PROTECT-LOW  / WHITE
         DC    AL3(SC1LN01+79)         END OF DSN
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN06+00)         BEGIN LINE 6
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN06+79)         END LINE 6
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN08+00)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN08+06)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN09+00)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN09+06)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN10+00)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN10+06)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN10+50)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN10+69)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN11+16)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN11+40)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN12+32)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN12+40)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN13+00)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN13+08)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN14+00)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN14+08)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN14+51)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN14+69)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN15+00)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN15+08)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN16+40)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN17+40)
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN18+54)
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN23+79)
ATRLST1E EQU   *
         SPACE 1
ATR@PL   EQU   X'E4'                   PROTECT-LOW  / BLUE
ATR@PH   EQU   X'E8'                   PROTECT-HIGH / WHITE
ATR@UL   EQU   X'C4'                   UNPROT-LOW   / GREEN
ATR@UH   EQU   X'C8'                   UNPROT-HIGH  / RED
         EJECT
SCREEN1  EQU   *
SC1LN01  DC    CL40' ATTRIBUTES OF DATASET -                '
         DC    CL40'                                        '
         DC    CL40'----------------------------------------'
         DC    CL40'----------------------------------------'
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'DSORG  RECFM  OPTCD  CR. DATE  EX. DATE '
         DC    CL40' VOLCNT  VOLSER-1  DEVICE TYPE   UNIT   '
         DC    CL40'-----  -----  -----  --------  -------- '
         DC    CL40' ------  --------  -----------   ----   '
SC1LN06  DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN08  DC    CL40'       = EXTENTS ALLOCATED              '
         DC    CL40'           LRECL       BLKSIZE          '
SC1LN09  DC    CL40'                                        '
         DC    CL40'           -----       -------          '
SC1LN10  DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN11  DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN12  DC    CL40'                                        '
         DC    CL40'           KEYLEN     KEY OFFSET        '
SC1LN13  DC    CL40'                                        '
         DC    CL40'           ------     ----------        '
SC1LN14  DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN15  DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN16  DC    CL40'                                        '
         DC    CL40'           LAST ACCESS DATE             '
SC1LN17  DC    CL40'                                        '
         DC    CL40'           ----------------             '
SC1LN18  DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN20  DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN23  DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN24  DC    CL40'MM/DD/YY          ---- PRESS ENTER TO CL'
         DC    CL40'EAR SCREEN ----                 99.99.99'
         SPACE 1
SCRBLD   DS    CL4096                  BUILD AREA FOR FINAL SCREEN
         EJECT
***********************************************************************
*      WORK AREA FOR UCB SCAN ROUTINE (FROM TSUCBSCN)                 *
***********************************************************************
         SPACE 1
DSXALIST DS    0F                      PARMLIST FOR UCB
DSXAWA   DS    F                       %100-BYTE WORK AREA
DSXADEVT DS    F                       %DEV TYPE TO SEARCH
DSXAUCB  DS    F                       %UCB FULL WORD PTR
         DS    0D                      FOLLOWING MUST BE ALIGNED
DSXAWORK DS    CL100                   UCB WORK AREA
DSXAEUCB EQU   DSXAWORK+00,04          EMULATION CURR. UCB PTR
DSXAEILK EQU   DSXAWORK+04,04          EMULATION CVTILK2 ADDR
DSXACLAS DS    CL1                     DEVICE CLASS TO SEARCH
DSXAUCBP DS    F                       %UCB
******** ***** *********************** END OF UCB LOOKUP DSA
DSAEND   EQU  *                         LENGTH OF WORK
         PRINT ON,NOGEN
         IEFUCBOB ,                    UCB
         CVT   DSECT=YES               CVT
         END   DSAT
