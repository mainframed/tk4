LISTLEV TITLE '** TSO LIST DATASETS BY LEVEL COMMAND ** '
***********************************************************************
*                                                                     *
*    NAME - LISTLEV                                                   *
*                                                                     *
*    AUTHOR - TED BESTANI                                             *
*                                                                     *
*    PURPOSE - THIS IS A FULL-SCREEN COMMAND PROCESSOR THAT IS ONLY   *
*              INTENDED TO BE USED BY SYSTEMS PROGRAMMERS.  IT CHECKS *
*              FOR OPERATOR AUTHORITY.  IT DISPLAYS ALL DATASETS THAT *
*              ARE CATALOGED WITHIN A GIVEN LEVEL (2ND LEVEL GENERIC) *
*                                                                     *
*    ATTRIBUTES - NON-REUSABLE                                        *
*                                                                     *
*    REQUIREMENTS - LISTLEV REQUIRES A 3270 DISPLAY STATION WITH AT   *
*                   LEAST 24 LINES.  IT WILL WORK ON LARGER TUBES,    *
*                   BUT DOES NOT REQUIRE THEM.                        *
*                                                                     *
*    MACROS USED - TGET, TPUT                                         *
*                                                                     *
***********************************************************************
         EJECT
         PRINT ON,NOGEN,NODATA
LISTLEV CSECT
         STM   R14,R12,12(R13)         SAVE CALLERS REGISTERS
         BALR  R9,0                    WHERE ARE WE?
         USING *,R9                    TEMPORARY BASE REGISTER
         ST    R13,SAVEAREA+4          SAVE BACKWARD SA PTR
         LA    R8,SAVEAREA             GET SA ADDR
         ST    R8,8(R13)               SAVE FORWARD SA PTR
         LR    R13,R8                  COPY SA ADDR
         LA    R12,4095(R13)           BASE2 = BASE1 + 4095 +
         LA    R12,1(R12)                                     1
         LA    R11,4095(R12)           BASE3 = BASE2 + 4095 +
         LA    R11,1(R11)                                     1
         LA    R10,4095(R11)           BASE4 = BASE3 + 4095 +
         LA    R10,1(R10)                                     1
         USING SAVEAREA,R13,R12,R11,R10    PERMANENT BASE REGISTERS
         USING EXTRAREA,R4             ESTABLISH ADDRESSABILITY
         USING SCRNLINE,R7             ESTABLISH ADDRESSABILITY
         DROP  R9                      DROP TEMPORARY BASE REGISTER
         MVC   SAVECPPL(16),0(R1)      SAVE CP PARM LIST
         SPACE 1
         BAL   R9,DRIVER               INVOKE MAIN ROUTINE
         SPACE 1
         L     R13,SAVEAREA+4          GET ADDR OF CALLER'S SA
         LM    R14,R12,12(R13)         RESTORE REGISTERS
         LA    R15,0                   SET RC=0
         BR    R14                     GO HOME....
         SPACE 1
SAVEAREA DS    18F    PROGRAM MAIN SAVE AREA
SAVECPPL DS    0F     ** TSO COMMAND PROCESSOR PARAMETER LIST **
CPPLCBUF DS    A      ADDRESS OF COMMAND INPUT BUFFER
CPPLUPT  DS    A                 USER PROFILE TABLE
CPPLPSCB DS    A                 PROTECTED STEP CONTROL BLOCK
CPPLECT  DS    A                 ENVIRONMENT CONTROL TABLE
         SPACE 1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         EJECT
***********************************************************************
*     THIS IS THE HIGHEST LEVEL WORK ROUTINE IN THE PROGRAM.  IT      *
*   DIRECTS THE FLOW OF CONTROL TO THE WORK ROUTINES.                 *
*     THE PROGRAM IS WRITTEN USING BASIC STRUCTURED PROGRAMMING. FLOW *
*   BETWEEN ROUTINES IS ACCOMPLISHED VIA REGISTER 9, WHICH IS ALWAYS  *
*   SAVED UPON ENTRY AND RESTORED BEFORE EXIT.                        *
***********************************************************************
         SPACE 2
DRIVER   DS    0H
         ST    R9,SAVE10
         B     BSAVE10
SAVE10   DC    F'-1'
         DC    CL8'DRIVER  '
BSAVE10  EQU   *
         SPACE 1
         L     R1,CPPLPSCB             ADDR OF THE PSCB
         TM    16(R1),X'80'            DOES USER HAVE OPERATOR AUTH?
         BO    GOWITHIT                YES, BYPASS ERROR MESSAGE
         TPUT  MSG1,L'MSG1             PUT OUT ERROR MESSAGE
         B     EXIT10                  EXIT COMMAND
GOWITHIT EQU   *
         GTTERM PRMSZE=PRMSZE,ALTSZE=ALTSZE,ATTRIB=ATTRIB
         L     R2,=A(ATTNRTN)          GET ADDR OF ATTN ROUTINE
         STAX  (R2)                    SET UP STAX QUEUE ELEMENT
         LTR   R15,R15                 GO OK?
         BZ    DRBYPERR                YES, BYPASS ERROR CODE
         TPUT  MSG6,L'MSG6             PUT OUT ERROR MESSAGE
         B     EXIT10                  GO HOME.....
DRBYPERR EQU   *
         BAL   R9,PARSEINP             PARSE INPUT COMMAND
         BAL   R9,LEVINFO              GO GET LISTC LEVEL() INFO
         BAL   R9,DEVINFO              BUILD VOLUME INFO
         BAL   R9,DSNINFO              BUILD DATASET INFO
         STFSMODE ON,INITIAL=YES       SET FULL SCREEN MODE ON
DRLOOPMN EQU   *
         BAL   R9,FORMATER             FORMAT EXTRACT DATA INTO SCREEN
         BAL   R9,TPUTMAIN             GO PAINT MAIN INPUT SCREEN
*        CLI   MESSAGE,C'3'            DID USER PRESS PF3? (IN FULLSCR)
*        BE    DRCLEAR                 GO TO DRIVER'S CLEAR/EXIT
*------> IF USER MOVED THE CURSOR WE WANT TO MOVE THE PAGE THERE
         CLC   MESSAGE+1(2),=XL2'5DC8' WHERE IT IS NORMALLY...
         BE    DRCSRNMV                CURSOR DIDN'T MOVE
*------> CODE ABOVE SHOULD BE A (BE) TO ACTIVATE SCREEN POSITIONING
         MVC   BUFFADDR,MESSAGE+1      MOVE THE CURSOR LANDING SPOT
         BAL   R9,TUBETORC             CONVERT TO ROW/COLUMN
         CLC   ROW,=CL2'05'            LESS THAN ROW 5?
         BL    DRCSRNMV                IGNORE REQUEST
         CLC   ROW,=CL2'22'            MORE THAN ROW 22?
         BH    DRCSRNMV                IGNORE REQUEST
         PACK  WORKDBLW,ROW            PACK THE ROW
         CVB   R6,WORKDBLW             MAKE IT HEX
         BCTR  R6,0                    NORMALIZE LINE NUMBER
         MH    R6,=H'80'               MULTIPLY LINE LENGTH
         LA    R7,SC1LN01              GET ORIGIN
         AR    R7,R6                   PTR TO START OF LINE
         PACK  WORKDBLW,SCLINENO       MOVE LINENO FOUND FROM SCREEN
         L     R4,EATBLFST             GET ORIGIN OF TABLE
         L     R5,EATBLAST             GET END OF TABLE
DRSRCH01 EQU   *
         CR    R4,R5                   END-OF-TABLE?
         BNL   DRCSRNMV                IGNORE REQUEST
         CP    WORKDBLW,EALINENO       IS IT THIS ENTRY?
         BE    DRSRCHFN                YES, GO TO FOUND
         LA    R4,EXTRLNTH(R4)         BUMP
         B     DRSRCH01                ITERATE
DRSRCHFN EQU   *
         ST    R4,EATBLNXT             SET NEW PTR
         ST    R4,EATBLTOP             SET NEW PTR
DRCSRNMV EQU   *
         CLI   MESSAGE,C'7'            DID USER PRESS PF7?
         BNE   DRNOTPB                 BYPASS PAGEBACK CODE
         L     R4,EATBLTOP             PTR TO NEXT ENTRY
         LA    R5,EXTRLNTH             GET LENGTH OF NODE
         MH    R5,=H'17'               GO BACK 17 LINES
         SR    R4,R5                   SUBTRACT 17 VOLUMES
         C     R4,EATBLFST             GONE TOO FAR?
         BNL   DRBYPTOO                OK, BYPASS RESET CODE
         L     R4,EATBLFST             RESET
DRBYPTOO EQU   *
         ST    R4,EATBLNXT             STORE NEW NEXT PTR (PAGEBACK)
DRNOTPB  EQU   *
         B     DRLOOPMN                MAIN DRIVER LOOP
DRCLEAR  EQU   *
         TPUT  CLSCREEN,12,FULLSCR     CLEAR SCREEN
         STLINENO MODE=OFF,LINE=1      SET FULL SCREEN MODE OFF
         SPACE 1
EXIT10   EQU   *
         L     R9,SAVE10
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE PARSES THE COMMAND INPUT                             *
***********************************************************************
         SPACE 2
PARSEINP DS    0H
         ST    R9,SAVE15
         B     BSAVE15
SAVE15   DC    F'-1'
         DC    CL8'PARSEINP'
BSAVE15  EQU   *
         SPACE 1
*--> GET THE INPUT PARAMETERS
         L     R2,CPPLCBUF             GET CBUF PTR
         LH    R3,0(R2)                GET LENGTH
         CH    R3,=H'13'               IS IT AT LEAST 13?
         BL    GETLEVEL                NO, GO ASK FOR IT
         LA    R3,7(R2)                EARLIEST POINT TO START LOOKING
         LH    R5,0(R2)                COPY LENGTH
         SH    R5,=H'8'                PREFIX + 1 FOR EX
         EX    R5,PIEXOC               RAISE TO UPPER-CASE
PIEXOC   OC    0(0,R3),=CL50' '        RAISE TO UPPER-CASE
         LH    R4,0(R2)                PICK UP COMPLETE LENGTH
         SH    R4,=H'7'                KNOCK OFF PREFIX
PIFNDFLD EQU   *
         CLC   0(4,R3),=CL4'LEV('      FIND THE LEVEL QUALIFIER
         BE    PIFOUNDL                FOUND, GO PROCESS
         LA    R3,1(R3)                BUMP
         BCT   R4,PIFNDFLD             ITERATE
         B     GETLEVEL                GO ASK FOR INFORMATION
PIFOUNDL EQU   *
         LA    R3,4(R3)                BUMP TO START OF LEVEL
         SH    R4,=H'4'                SUBTRACT FOR PREFIX
         LR    R5,R3                   SAVE LEVEL START ADDRESS
PIFNDPR1 EQU   *
         CLI   0(R3),C'.'              REACHED A DELIMITER?
         BE    PIPR1FND                YEP, GO PROCESS
         CLI   0(R3),C')'              REACHED THE END YET?
         BE    PIPR1FND                YEP, GO PROCESS
         LA    R3,1(R3)                BUMP
         BCT   R4,PIFNDPR1             ITERATE
         B     GETLEVEL                GO ASK FOR INFORMATION
PIPR1FND EQU   *
         LR    R6,R3                   COPY ENDING ADDRESS
         SR    R6,R5                   LENGTH OF LEVELNAME
         STH   R6,LEVLNTH              STORE LENGTH OF PRIMARY LEVEL
         BCTR  R6,0                    SUBTRACT 1 FOR EX
         EX    R6,PIEXMVC1             MOVE THE LEVEL
PIEXMVC1 MVC   LEVEL(1),0(R5)          MOVE THE LEVEL
         OC    LEVEL,=CL50' '          CHANGE IT TO UPPER CASE
         CLI   0(R3),C'.'              WAS IT A DELIMITER
         BNE   EXIT15                  YES, DONE, EXIT...
*------- ----- USER HAS SPECIFIED A SECONDARY LEVEL
         LA    R3,1(R3)                BUMP PAST PERIOD
         LR    R5,R3                   COPY START ADDR OF SECLEVEL
         BCTR  R4,0                    BUMP PAST PERIOD
PIFNDPR2 EQU   *
         CLI   0(R3),C'.'              REACHED A DELIMITER?
         BE    PIPR2FND                YEP, GO PROCESS
         CLI   0(R3),C')'              REACHED THE END YET?
         BE    PIPR2FND                YEP, GO PROCESS
         LA    R3,1(R3)                BUMP
         BCT   R4,PIFNDPR2             ITERATE
         B     EXIT15                  RUNOUT, GO WITH THE PRIMARY
PIPR2FND EQU   *
         LR    R6,R3                   COPY ENDING ADDRESS
         SR    R6,R5                   LENGTH OF LEVELNAME
         BCTR  R6,0                    SUBTRACT 1 FOR EX
         EX    R6,PIEXMVC2             MOVE THE LEVEL
PIEXMVC2 MVC   SECLEV(1),0(R5)         MOVE THE LEVEL
         STH   R6,SECLNTH              STORE THE LENGTH
         OC    SECLEV,=CL50' '         CHANGE IT TO UPPER CASE
         B     EXIT15                  YES, DONE, EXIT...
*------- ----- NOT SUCCESSFUL THUS FAR, ASK USER FOR LEVEL INFO
GETLEVEL EQU   *
         TPUT  MSG5,L'MSG5             ASK FOR THE LEVEL
         TGET  LEVEL,44                READ IT
         LTR   R1,R1                   IS IT ZERO?
         BZ    GETLEVEL                YES, GO ASK FOR IT AGAIN
         CH    R1,=H'44'               IS IT TOO BIG?
         BH    GETLEVEL                YES, GO ASK FOR IT AGAIN
BYPTGETS EQU   *
         OC    LEVEL,=CL50' '          CHANGE IT TO UPPER CASE
         SPACE 1
EXIT15   EQU   *
         L     R9,SAVE15
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE LINKS TO THE IKJEHCIR ROUTINE TO REQUEST A LIST OF *
*   ALL DATASETS THAT CORRESPOND TO THE LEVEL REQUESTED BY THE USER,  *
*   WHEREUPON WE EXIT AND LET THE FORMATER DO IT'S THING.             *
***********************************************************************
         SPACE 2
LEVINFO  DS    0H
         ST    R9,SAVE20
         B     BSAVE20
SAVE20   DC    F'-1'
         DC    CL8'LEVINFO '
BSAVE20  EQU   *
         SPACE 1
         L     R0,=A(EXTRLNTH)         SET FOR NODE LENGTH
         MH    R0,=AL2(300)            MAX NUMBER OF DATASETS
         GETMAIN R,LV=(R0),BNDRY=DBLWD GO GET SOME MEMORY
         LR    R4,R1                   COPY ORIGIN ADDRESS
         ST    R4,EATBLFST             STORE ORIGIN ADDRESS
         ST    R4,EATBLNXT             INITIALLY FIRST ENTRY
*------- ----- SET UP FOR THE IKJEHCIR ROUTINE
         XC    CIROPT,CIROPT        INITIALIZE PARM LIST
         LH    R0,=H'28672'            SET FOR REQUEST LENGTH
         GETMAIN R,LV=(R0),BNDRY=DBLWD GO GET SOME MEMORY
         ST    R1,CIRWA                SAVE PTR TO STORAGE FOUND
         LR    R2,R1                   COPY PTR
         LH    R1,=H'28672'
         STH   R1,0(R2)             LENGTH OF WORKAREA IN WKAREA
         LA    R8,LEVEL             GET PTR TO LEVEL
         ST    R8,CIRSRCH           POINT TO LEVEL
         LA    R8,SAVEAREA          GET ADDRESS OF SAVE AREA
         ST    R8,CIRSAVE           AND PUT IT IN PARM LIST
         MVI   CIROPT,X'02'         OPTION FOR SUPER LOCATE
         LA    R1,CIROPT            POINT TO PARAMETER LIST
         LINK  EP=IKJEHCIR
         B     *+4(R15)
         B     GOTCONT
         B     NOGOOD
GOTCONT  EQU   *
         CLI   CIRLOCR,X'00'       DID WE GET A GOOD LIST?
         BE    DILOOP00
NOGOOD   EQU   *
         TPUT  MSG2,L'MSG2             COMPLAIN ABOUT THE LEVEL
         B     EXIT10                  BRANCH TO DRIVER'S EXIT
DILOOP00 EQU   *
         L     R1,CIRWA                GET PTR TO WORKAREA
         LH    R2,2(R1)                GET RESIDUAL BYTE COUNT
         LA    R1,4(R1)                BUMP PAST LENGTH FIELDS
DILOOP01 EQU   *
         LTR   R2,R2                   SHOT PAST END YET?
         BL    AIEND                   YES, STORE END PTR
         CLI   0(R1),X'FF'             LAST ENTRY?
         BE    AIEND                   YES, STORE END PTR
         CLI   SECLEV,C' '             WAS A SECONDARY SPECIFIED?
         BE    NOSECLV                 NO SECONDARY, BYPASS
         LA    R3,1(R1)                POINT PAST ID FIELD
         AH    R3,LEVLNTH              ADD LENGTH OF PRIMARY
         LA    R3,1(R3)                BUMP PAST PERIOD
         LH    R5,SECLNTH              GET LENGTH OF SECONDARY ARG
         EX    R5,DISECEX              EXECUTE CLC
         BE    NOSECLV                 EQUAL, ACCEPT
         B     NEXTENT                 NO, BYPASS
DISECEX  CLC   0(1,R3),SECLEV          COMPARE TO SECONDARY
NOSECLV  EQU   *
         MVC   EADSN,1(R1)             MOVE DSN
         MVC   EAENTYPE,0(R1)          MOVE ENTRY TYPE, A=DSN
         AP    LINECNT,=PL1'1'         BUMP LINE NUMBER
         ZAP   EALINENO,LINECNT        COPY IT
         LA    R4,EXTRLNTH(R4)         BUMP TO NEXT ENTRY
NEXTENT  EQU   *
         LA    R1,45(R1)               BUMP TO NEXT ENTRY
         SH    R2,=H'45'               SUBTRACT FROM RESIDUAL BYTE CNT
         B     DILOOP01                ITERATE
AIEND    EQU   *
         ST    R4,EATBLAST             STORE PTR TO END OF TABLE
         LH    R0,=H'28672'            SET FOR REQUEST LENGTH
         L     R8,CIRWA                GET PTR TO MEMORY
         FREEMAIN R,LV=(R0),A=(R8)     FREE THE MEMORY
         SPACE 1
EXIT20   EQU   *
         L     R9,SAVE20
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE USES THE DSNAME LIST BUILT PREVIOUSLY AND ADDS       *
*   VOLUME INFORMATION TO IT.                                         *
***********************************************************************
         SPACE 2
DEVINFO  DS    0H
         ST    R9,SAVE30
         B     BSAVE30
SAVE30   DC    F'-1'
         DC    CL8'DEVINFO '
BSAVE30  EQU   *
         SPACE 1
         L     R4,EATBLFST             GET ADDRESS OF FIRST ENTRY
         L     R3,EATBLAST                            LAST
DVLOOP01 EQU   *
         CR    R4,R3                   LAST ENTRY YET?
         BNL   EXIT30                  YEP, EXIT
         MVC   DSN,EADSN               MOVE DSNAME
         XC    VOLIST+000(100),VOLIST  CLEAR THE VOLUME LIST AREA
         XC    VOLIST+101(165),VOLIST+101
         LOCATE LOCLIST            ISSUE LOCATE MACRO
         LTR   R15,R15             CHECK RETURN CODE
         BZ    DVOKINCT            IF OK, BYPASS
         MVC   EAVOLSER,=CL6'?'    MOVE NOT FOUND INDICATOR
         B     DVLOOP02            GO TRY NEXT ENTRY
DVOKINCT EQU   *
         MVC   EADEVTYP,VOLIST+4   MOVE FIRST VOLSER DEVICE TYPE
         MVC   EAVOLSER,VOLIST+6   MOVE FIRST VOLSER
         LA    R2,DEVTABLE
FDEVICE1 EQU   *
         CLC   0(2,R2),=X'0000'    END OF TABLE?
         BE    DVLOOP02                YES, ABANDON
         CLC   0(2,R2),EADEVTYP    IF SAME DEVICE CODE....
         BE    FDEVICE2
         LA    R2,10(R2)           BUMP TO NEXT ENTRY
         B     FDEVICE1
FDEVICE2 EQU   *
         MVC   EAUNITYP,4(R2)      MOVE DEVICE NAME
         MVC   EATRKCYL,2(R2)      MOVE TRK/CYL
DVLOOP02 EQU   *
         LA    R4,EXTRLNTH(R4)     BUMP
         B     DVLOOP01            ITERATE
         SPACE 1
EXIT30   EQU   *
         L     R9,SAVE30
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE USES THE DSNAME LIST BUILT PREVIOUSLY AND ADDS       *
*   DATASET INFORMATION TO IT USING THE DSCB1 / DSCB3 FROM THE VTOC.  *
***********************************************************************
         SPACE 2
DSNINFO  DS    0H
         ST    R9,SAVE40
         B     BSAVE40
SAVE40   DC    F'-1'
         DC    CL8'DSNINFO '
BSAVE40  EQU   *
         SPACE 1
         L     R4,EATBLFST             GET ADDRESS OF FIRST ENTRY
         L     R3,EATBLAST                            LAST
DSLOOP01 EQU   *
         CR    R4,R3                   LAST ENTRY YET?
         BNL   EXIT40                  YEP, EXIT
         MVC   DSN,EADSN               MOVE DSNAME
         XC    DSCB1LST,DSCB1LST       CLEAR THE VOLUME LIST AREA
         MVC   VOLSER,EAVOLSER         MOVE VOLSER INTO POSITION
         OBTAIN OBLIST1            GET DSCB1
         LTR   R15,R15             CHECK RETURN CODE
         BZ    DSOK                IF OK, BYPASS
         MVC   EADSORG,=CL2'?'     MOVE NOT FOUND INDICATOR
         B     DSLOOP02            GO TRY NEXT ENTRY
DSOK     EQU   *
         TM    DSCB1LST+38,X'80'   IS DSORG=IS?
         BNO   D1NOTIS
         MVC   EADSORG,=CL2'IS'
         B     D1TESTRF
D1NOTIS  EQU   *
         TM    DSCB1LST+38,X'40'   IS DSORG=PS?
         BNO   D1NOTPS
         MVC   EADSORG,=CL2'PS'
         B     D1TESTRF
D1NOTPS  EQU   *
         TM    DSCB1LST+38,X'20'   IS DSORG=DA?
         BNO   D1NOTDA
         MVC   EADSORG,=CL2'DA'
         B     D1TESTRF
D1NOTDA  EQU   *
         TM    DSCB1LST+38,X'02'   IS DSORG=PO?
         BNO   D1TESTRF
         MVC   EADSORG,=CL2'PO'
D1TESTRF EQU   *
         TM    DSCB1LST+38,X'01'   IS DSORG=U?
         BNO   D1NOTU
         MVC   EADSORG,=CL2'U '
D1NOTU   EQU   *
*--> GET THE LRECL
         LH    R8,DSCB1LST+44      GET LRECL
         STH   R8,EALRECL
*--> GET THE BLKSIZE
         LH    R8,DSCB1LST+42      GET BLKSIZE
         STH   R8,EABLKSIZ
*--> GET THE KEYLEN
         MVC   EAKEYLEN,DSCB1LST+46    KEYLEN
*--> GET THE RKP
         MVC   WORKDBLW(2),DSCB1LST+47 OFFSET
         LH    R8,WORKDBLW
         STH   R8,EARKPOFF
*--> GET THE RECFM
         LA    R8,EARECFM          POINT TO STORAGE ADDRESS
         TM    DSCB1LST+40,X'C0'   TEST FOR UNKNOWN RECFM
         BZ    RFT
         TM    DSCB1LST+40,X'40'   TEST FOR F RECFM
         BNZ   RFUORV
         MVI   0(R8),C'F'
         LA    R8,1(R8)            BUMP TO NEXT CHAR
         B     RFT
RFUORV   EQU   *
         TM    DSCB1LST+40,X'80'
         BZ    RFV
         MVI   0(R8),C'U'          OTHERWISE UNDEFINED
         LA    R8,1(R8)
         B     RFT
RFV      EQU   *
         MVI   0(R8),C'V'
         LA    R8,1(R8)
RFT      EQU   *
         TM    DSCB1LST+40,X'20'   TEST FOR T RECFM
         BZ    RFB
         MVI   0(R8),C'T'
         LA    R8,1(R8)
RFB      EQU   *
         TM    DSCB1LST+40,X'10'   TEST FOR B RECFM
         BZ    RFS
         MVI   0(R8),C'B'
         LA    R8,1(R8)
RFS      EQU   *
         TM    DSCB1LST+40,X'08'   TEST FOR S RECFM
         BZ    RFA
         MVI   0(R8),C'S'
         LA    R8,1(R8)
RFA      EQU   *
         TM    DSCB1LST+40,X'04'   TEST FOR A RECFM
         BZ    RFM
         MVI   0(R8),C'A'
         LA    R8,1(R8)
RFM      EQU   *
         TM    DSCB1LST+40,X'02'   TEST FOR M RECFM
         BZ    RFEND
         MVI   0(R8),C'M'
         LA    R8,1(R8)
RFEND    EQU   *
DSLOOP02 EQU   *
         LA    R4,EXTRLNTH(R4)     BUMP
         B     DSLOOP01            ITERATE
         SPACE 1
EXIT40   EQU   *
         L     R9,SAVE40
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE FORMATS THE DATA DERIVED IN THE EXTRACT ROUTINE    *
*   AND FORMATS IT INTO THE SCREEN THAT IS THEN PAINTED DURING THE    *
*   TPUTMAIN ROUTINE WHICH FOLLOWS.                                   *
***********************************************************************
         SPACE 2
FORMATER DS    0H
         ST    R9,SAVE50
         B     BSAVE50
SAVE50   DC    F'-1'
         DC    CL8'FORMATER'
BSAVE50  EQU   *
         SPACE 1
         L     R4,EATBLNXT             GET NEXT ADDRESS
         ST    R4,EATBLTOP             SAVE CURRENT TOP
         LA    R7,SC1LN05              GET ORIGIN IN SCREEN
         LA    R8,18                   18 LINES OF DATA PER SCREEN
FMTLOOP1 EQU   *
         C     R4,EATBLAST             END OF EXTRACT TABLE?
         BNL   FMTCLEAR                CLEAR REST OF SCREEN LINES
         MVI   0(R7),C' '              CLEAR FIRST BYTE
         MVC   1(79,R7),0(R7)          CLEAR THE REST OF THE LINE
         MVC   SCLINENO-1(4),=XL4'40202120' INSERT EDIT MASK
         ED    SCLINENO-1(4),EALINENO  EDIT IN THE LINE NUMBER
         MVC   SCDSN,EADSN             MOVE THE DSNAME
         CLI   EADSN+L'SCDSN,C' '      TRUNCATION OCCURRED?
         BE    FMTNTRNC                NOPE, BYPASS
         MVI   SCDSN+(L'SCDSN-1),C'>'  INDICATE TRUNCATION
FMTNTRNC EQU   *
         MVC   SCVOLSER,EAVOLSER       MOVE THE VOLSER
         MVC   SCUNITYP,EAUNITYP       MOVE THE UNIT NAME
         MVC   SCDSORG,EADSORG         MOVE THE DSORG
         MVC   SCRECFM,EARECFM         MOVE THE RECFM
*--> FMT THE LRECL
         LH    R1,EALRECL          GET LRECL
         CVD   R1,WORKDBLW
         MVC   SCLRECL,=XL7'4020206B202120'
         ED    SCLRECL,WORKDBLW+5
*--> FMT THE BLKSIZE
         LH    R1,EABLKSIZ         GET BLKSIZE
         CVD   R1,WORKDBLW
         MVC   SCBLKSIZ,=XL7'4020206B202120'
         ED    SCBLKSIZ,WORKDBLW+5
FMTNEXT  EQU   *
         LA    R7,80(R7)               BUMP TO NEXT SCREEN LINE
         LA    R4,EXTRLNTH(R4)         BUMP TO NEXT ENTRY
         BCT   R8,FMTLOOP1             ITERATE
         LA    R1,EXTRLNTH             GET LENGTH OF EXTRACT ENTRY
         SR    R4,R1                   SUBTRACT ONE ENTRY
         MVC   EATBLPRV,EATBLNXT       SAVE OLD ORIGIN PTR
         ST    R4,EATBLNXT             STORE NEW NEXT PTR
FMTCLEAR EQU   *
         LTR   R8,R8                   RUN OUT OF LINES YET?
         BZ    FMTEND                  YES, ENOUGH IS ENOUGH
         MVI   0(R7),C' '              CLEAR FIRST BYTE
         MVC   1(79,R7),0(R7)          CLEAR THE REST OF THE LINE
         LA    R7,80(R7)               BUMP TO NEXT LINE
         BCT   R8,FMTCLEAR             ITERATE
FMTEND   EQU   *
         SPACE 1
EXIT50   EQU   *
         L     R9,SAVE50
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE PAINTS THE INPUT SCREEN AND READS A RESPONSE FROM  *
*   THE TERMINAL.  UPON RETURN, REGISTER 1 WILL CONTAIN THE NUMBER    *
*   OF BYTES READ FROM THE TERMINAL.                                  *
***********************************************************************
         SPACE 2
TPUTMAIN DS    0H
         ST    R9,SAVE60
         B     BSAVE60
SAVE60   DC    F'-1'
         DC    CL8'TPUTMAIN'
BSAVE60  EQU   *
         SPACE 1
         LA    R2,ATRLST1B             ADDR OF ATTRIBUTE LIST
         ST    R2,ALISTPTR             STORE IN PTR AREA
         LA    R2,SCREEN1              ADDR OF ATTRIBUTE LIST
         ST    R2,ASCRNPTR             STORE IN PTR AREA
         LA    R2,SC1SUFIX             ADDR OF SUFFIX
         ST    R2,ASUFXPTR             STORE IN PTR AREA
         LA    R2,L'SC1SUFIX           GET LENGTH OF SUFFIX
         STC   R2,ASUFXPTR             STORE IN PTR AREA
         MVC   ASCRNSIZ,=F'1920'       STORE SIZE OF SCREEN
         BAL   R9,FULLSCR              GO DO DEMO SCREEN WORK
         LTR   R1,R1                   DID USER TYPE IN COMMAND?
         BZ    DRCLEAR                 YES, BYPASS CLEAR
         SPACE 1
EXIT60   EQU   *
         L     R9,SAVE60
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE BUILDS THE FINAL SCREEN, DOES A FULL SCREEN TPUT,    *
* A DUMMY TGET, AND CLEARS THE SCREEN.  THE MAJOR PART OF THE CODE    *
* IS THE BUILDING OF THE FINAL SCREEN.  THE ROUTINE HAS THREE INPUTS. *
* 'ASCRNPTR' POINTS TO A STANDARD 1920 BYTE SCREEN IMAGE WITH NO      *
* ATTRIBUTE CHARACTERS.  'ALISTPTR' CONTAINS THE ADDRESS OF THE       *
* ATTRIBUTE LIST THAT WE WILL USE THIS TIME AROUND.  'SCPREFIX' IS    *
* THE CONTROL STREAM WHICH IS TO BE PREFIXED ONTO THE FINAL SCREEN.   *
*   USING THE THREE INPUTS, A TPUT'ABLE FINAL SCREEN IS BUILT IN THE  *
* 'SCRBLD' AREA AT THE END OF THE PROGRAM.                            *
***********************************************************************
         SPACE 1
FULLSCR  DS    0H
         ST    R9,SAVE70
         B     BSAVE70
SAVE70   DC    F'-1'
         DC    CL8'FULLSCR '
BSAVE70  EQU   *
         SPACE 1
*--> INIT REGISTERS
         L     R2,ALISTPTR             GET PTR TO ATTRIBUTE LIST
         L     R3,0(R2)                GET END OF ATTRIBUTE LIST
         LA    R2,4(R2)                BUMP PAST END ADDRESS
         LA    R4,SCRBLD               GET ADDR OF BUILD AREA
         XR    R5,R5                   INIT LENGTH REGISTER
         L     R6,ASCRNPTR             GET ADDR OF INPUT SCREEN
         LR    R7,R6                   GET BEGINNING
         A     R7,ASCRNSIZ             ADD SIZE OF SCREEN TO GET END
*--> INSERT PREFIX
         MVC   0(L'SCPREFIX,R4),SCPREFIX   MOVE PREFIX
         LA    R4,L'SCPREFIX(R4)       BUMP PTR
         LA    R5,L'SCPREFIX(R5)       ADD LENGTH
*--> FLAG ATTRIBUTE BYTES FIRST
FSLOOP10 EQU   *
         CR    R2,R3                   END OF ATTRIBUTE LIST?
         BE    FSLOOP20                YES, END OF FLAGGING
         L     R8,0(R2)                GET ADDR OF NEXT ATTR BYTE
         MVI   0(R8),X'1D'             FLAG BYTE WITH A X'FF'
         LA    R2,4(R2)                GET NEXT ATTRIBUTE ADDR
         B     FSLOOP10                GO TRY NEXT
FSLOOP20 EQU   *
         L     R2,ALISTPTR             GET PTR TO ATTRIBUTE LIST
         LA    R2,4(R2)                BUMP PAST END ADDRESS
FSLOOP30 EQU   *
         CR    R6,R7                   INPUT SCREEN EXHAUSTED?
         BE    FSLOOP50                GO TPUT
         CLI   0(R6),X'1D'             IS THIS A FLAG?
         BE    FSLOOP40                YES, GO PROCESS
         MVC   0(1,R4),0(R6)           NO, MOVE THIS BYTE TO OUTPUT
         LA    R4,1(R4)                BUMP PTR TO OUTPUT SCREEN
         LA    R5,1(R5)                BUMP LENGTH OF OUTPUT
         LA    R6,1(R6)                BUMP TO NEXT INPUT BYTE
         B     FSLOOP30                GO TRY NEXT BYTE
FSLOOP40 EQU   *
         MVC   0(1,R4),0(R6)           MOVE FLAG TO OUTPUT
         MVC   1(1,R4),0(R2)           MOVE ATTR TO OUTPUT
         LA    R2,4(R2)                BUMP TO NEXT ATTR
         LA    R4,2(R4)                BUMP TWO BYTES IN OUTPUT
         LA    R5,2(R5)                BUMP LENGTH BY TWO
         LA    R6,1(R6)                BUMP TO NEXT INPUT BYTE
         B     FSLOOP30                GO TRY NEXT BYTE
FSEXMVC  MVC   0(0,R4),0(R8)           MOVE SUFFIX TO OUTPUT
FSLOOP50 EQU   *
         XR    R1,R1                   CLEAR REGISTER
         IC    R1,ASUFXPTR             GET LENGTH TO MOVE
         BCTR  R1,0                    SUBTRACT ONE FOR MVC
         L     R8,ASUFXPTR             ADDR OF SUFFIX
         EX    R1,FSEXMVC              MOVE THE SUFFIX TO OUTPUT
         AR    R4,R1                   BUMP LENGTH OF SUFFIX
         AR    R5,R1                   BUMP LENGTH OF SUFFIX
         LA    R4,1(R4)                RESTORE 1 BYTE FROM EX
         LA    R5,1(R5)                RESTORE 1 BYTE FROM EX
*--> TGET'S AND TPUT'S
         CLI   STAXSW,C'1'             HAVE WE BEEN INTERRUPTED?
         BE    FSINTRPT                YES, BYPASS THIS TPUT
FSREFRSH EQU   *
         TPUT  SCRBLD,(R5),FULLSCR     PAINT OUTPUT SCREEN
         TM    ATTRIB+3,X'01'          DOES THIS TUBE SUPPORT COLOR?
         BNO   NOCOLOR                 BRANCH AROUND COLORS
         TPUT  SC1COLOR,LSC1CLR,NOEDIT WRITE SPECIALTY COLORS
NOCOLOR  EQU   *
         TGET  MESSAGE,126,ASIS        GET DUMMY INPUT
         CLI   MESSAGE,C'3'            DID USER PRESS PF3?
         BE    DRCLEAR                 GO TO DRIVER'S CLEAR/EXIT
         CLI   MESSAGE,X'7D'           DID USER PRESS ENTER
         BE    FSREFRSH                RE-PAINT SCREEN
         CLI   STAXSW,C'1'             HAVE WE BEEN INTERRUPTED?
         BNE   EXIT70                  NO, CONTINUE
FSINTRPT EQU   *
         TPUT  CLSCREEN,12,FULLSCR     CLEAR SCREEN
         TPUT  MSG7,L'MSG7             SEND INTERRUPTED MESSAGE
         L     R13,SAVEAREA+4          GET ADDR OF SAVEAREA
         LM    R14,R12,12(R13)         RESTORE CALLERS REGISTERS
         LA    R15,4                   SET RC=4
         BR    R14                     RETURN TO CALLER
         SPACE 1
EXIT70   EQU   *
         L     R9,SAVE70
         BR    R9
         EJECT
***********************************************************************
*   THIS ROUTINE CALCULATES THE SCREEN ADDR'S FROM LINE START ADDRESS *
***********************************************************************
         SPACE 2
CALCADDR DS    0H
         ST    R9,SAVE100
         B     BSAVE100
SAVE100  DC    F'-1'
         DC    CL8'CALCADDR'
BSAVE100 EQU   *
         SPACE 1
*------> AT ENTRY, R8 MUST CONTAIN A PTR TO A VOLSER ON A SCREEN LINE
         LA    R7,SC1LN01              PICK UP ADDR OF START OF SCREEN
         SR    R8,R7                   GENERATE DISPLACEMENT
         CVD   R8,WORKDBLW             CONVERT TO DECIMAL
         DP    WORKDBLW,=PL2'80'       DIVIDE BY LINE LENGTH
         AP    WORKDBLW(6),=PL1'1'     VOLSER IS ON FOLLOWING LINE
         UNPK  ROW,WORKDBLW+4(2)       UNPACK
         OI    ROW+1,X'F0'             CLEAR SIGN NIBBLE
         MVC   COLUMN,=CL2'01'         SET UP COLUMN
         BAL   R9,RCTOTUBE             CONVERT ROW/COLUMN TO SCREEN ADR
         MVC   STARTADR,BUFFADDR       STARTING ADDRESS
         MVC   COLUMN,=CL2'26'         SET UP COLUMN
         BAL   R9,RCTOTUBE             CONVERT ROW/COLUMN TO SCREEN ADR
         MVC   ENDADDR,BUFFADDR        ENDING SCREEN ADDRESS
         SPACE 1
EXIT100  EQU   *
         L     R9,SAVE100
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE PROCESSES THE ROW/COLUMN TO BUFFER CONVERSION      *
***********************************************************************
         SPACE 2
RCTOTUBE DS    0H
         ST    R9,SAVE510
         B     BSAVE510
SAVE510  DC    F'-1'
         DC    CL8'RCTOTUBE'
BSAVE510 EQU   *
         SPACE 1
*--> USER WANTS A ROW/COLUMN TO BUFFER ADDRESS CONVERSION
         PACK  R327FLD1,ROW            PACK THE ROW NUMBER
         SP    R327FLD1,=PL1'1'        SUBTRACT 1
         MP    R327FLD1,=PL2'80'       NO, MULTIPLY BY 80
         PACK  R327FLD2,COLUMN         PACK THE COLUMN
         AP    R327FLD1,R327FLD2       ADD TO GET POSITION NUMBER
         SP    R327FLD1,=PL1'1'        SUBTRACT TO GET REL POSITION
         DP    R327FLD1,=PL2'64'       DIVIDE BY BASE 64
         ZAP   WORKDBLW,R327FLD1(2)    MOVE FOR CONVERSION
         CVB   R2,WORKDBLW             CONVERT FOR USE AS AN INDEX
         LA    R3,TABLE327             GET BASE ADDRESS
         AR    R3,R2                   ADD DISPLACEMENT TO BASE
         MVC   BUFFADDR+0(1),0(R3)     MOVE CHARACTERS FROM TABLE
         ZAP   WORKDBLW,R327FLD1+2(2)  MOVE FOR CONVERSION
         CVB   R2,WORKDBLW             CONVERT FOR USE AS AN INDEX
         LA    R3,TABLE327             GET BASE ADDRESS
         AR    R3,R2                   ADD DISPLACEMENT TO BASE
         MVC   BUFFADDR+1(1),0(R3)     MOVE CHARACTERS FROM TABLE
         SPACE 1
EXIT510  EQU   *
         L     R9,SAVE510
         BR    R9
         EJECT
***********************************************************************
*     THIS ROUTINE PROCESSES THE BUFFER TO ROW/COLUMN CONVERSION      *
***********************************************************************
         SPACE 2
TUBETORC DS    0H
         ST    R9,SAVE520
         B     BSAVE520
SAVE520  DC    F'-1'
         DC    CL8'TUBETORC'
BSAVE520 EQU   *
         SPACE 1
*--> USER WANTS A BUFFER ADDRESS TO ROW/COLUMN CONVERSION
         LA    R2,TABLE327             GET BASE ADDRESS OF TABLE
         LA    R3,64                   GET TABLE LENGTH
R3270510 EQU   *
         CLC   BUFFADDR(1),0(R2)       IS IT THIS POINT IN TABLE
         BE    R3270520                YES, BREAK OUT
         LA    R2,1(R2)                BUMP
         BCT   R3,R3270510             ITERATE
         ISK   0,0                     BUG, KILL IT RIGHT HERE
R3270520 EQU   *
         LA    R3,TABLE327             GET BASE ADDRESS OF TABLE
         SR    R2,R3                   GET OFFSET
         SLL   R2,6                    MULTIPLY BY 64
         CVD   R2,WORKDBLW             CONVERT TO DECIMAL
         ZAP   R327FLD1,WORKDBLW       PLACE IN SAFE-KEEPING
         LA    R2,TABLE327             GET BASE ADDRESS OF TABLE
         LA    R3,64                   GET TABLE LENGTH
R3270530 EQU   *
         CLC   BUFFADDR+1(1),0(R2)     IS IT THIS POINT IN TABLE
         BE    R3270540                YES, BREAK OUT
         LA    R2,1(R2)                BUMP
         BCT   R3,R3270530             ITERATE
         ISK   0,0                     BUG, KILL IT RIGHT HERE
R3270540 EQU   *
         LA    R3,TABLE327             GET BASE ADDRESS OF TABLE
         SR    R2,R3                   GET OFFSET
         CVD   R2,WORKDBLW             CONVERT TO DECIMAL
         AP    R327FLD1,WORKDBLW       ADD TO BASE
         DP    R327FLD1,=PL2'80'       NO, DIVIDE BY 80
         AP    R327FLD1+0(2),=PL1'1'   ADD 1 TO GET REAL ROW
         AP    R327FLD1+2(2),=PL1'1'   ADD 1 TO GET REAL COLUMN
         UNPK  ROW,R327FLD1(2)         RETURN THE ROW
         OI    ROW+1,X'F0'             CLEAR SIGN
         UNPK  COLUMN,R327FLD1+2(2)    RETURN THE COLUMN
         OI    COLUMN+1,X'F0'          CLEAR SIGN
         SPACE 1
EXIT520  EQU   *
         L     R9,SAVE520
         BR    R9
         EJECT
***********************************************************************
*           W O R K I N G   S T O R A G E   S E C T I O N             *
***********************************************************************
         SPACE 2
EATBLFST DS    F                       POINTER TO BGN OF EXTRACT TABLE
EATBLTOP DS    F                       POINTER TO TOP OF CURRENT SCREEN
EATBLAST DS    F                       POINTER TO END OF EXTRACT TABLE
EATBLPRV DS    F                       POINTER TO PREVIOUS SCREEN START
EATBLNXT DS    F                       POINTER TO NEXT ENTRY TO SHOW
MSG1     DC    CL36'COMMAND REQUIRES OPERATOR AUTHORITY'
MSG2     DC    CL26'LEVEL REQUESTED NOT FOUND'
MSG5     DC    CL36'PLEASE ENTER THE LISTC LEVEL NEEDED'
MSG6     DC    CL17'STAX MACRO FAILED'
MSG7     DC    CL19'COMMAND INTERRUPTED'
MESSAGE  DC    CL126' '                MESSAGE TO BE RECEIVED
PRMSZE   DS    CL2                     PRIMARY SCREEN SIZE
ALTSZE   DS    CL2                     SECONDARY SCREEN SIZE
ALTMOD3  EQU   X'20'                   TERMINAL = 3278/9 MOD 3
ATTRIB   DS    F                       TERMINAL ATTRIBUTES
LASTLNSW DC    CL1'0'                  LAST LINE PROCESSED SWITCH
STAXSW   DC    CL1'0'                  INTERRUPTED, YES/NO
LINECNT  DC    PL2'0'                  LINE NUMBER ON SCREEN
         SPACE 1
HEXTR    DC    CL16'0123456789ABCDEF'  TRANSLATE HEX TO CHAR
TRTALLOW DC    256XL1'FF'              TRT TABLE/ALLOWABLE CHARS
         ORG   TRTALLOW+C'0'           ALLOW 0-9
         DC    10XL1'00'                 CLEAR CHARS
         ORG
         SPACE 2
         LTORG                         LITERAL POOL
         EJECT
***********************************************************************
*      WORK AREAS FOR THE SUPER LOCATE ROUTINE (IKJHECIR)             *
***********************************************************************
         SPACE 1
LEVEL    DC    CL44' '                 LEVEL REQUESTED BY USER
SECLEV   DC    CL44' '                 SECONDARY LEVEL REQUESTED
LEVLNTH  DC    H'0'                    PRIMARY LEVEL LENGTH
SECLNTH  DC    H'0'                    SECONDARY LEVEL LENGTH
         DS    0F
CIRPARM  DS    0CL24
CIROPT   DS    C          OPTION CODE 2
         DS    CL2
CIRLOCR  DS    C          RETURN CODE FROM IKJHECIR
CIRSRCH  DS    A          POINTER TO LEVEL NAME
CIRCVOL  DS    A          POINTER TO USER CATALOG
CIRWA    DS    A          POINTER TO WORK AREA
CIRSAVE  DS    A          POINTER TO SAVE AREA
CIRPSWD  DS    A          POINTER TO DS PASSWORD
         SPACE 2
***********************************************************************
*      WORK AREAS FOR THE LOCATE ROUTINE                              *
***********************************************************************
         SPACE 1
*--------CATALOG SEARCH MACRO
         DS    0D
DSN      DS    CL44
LOCLIST  CAMLST NAME,DSN,,VOLIST
         DS    0D
VOLIST   DS    256C
         DS    CL16 PROTECT
*--------VTOC DSCB 1 OBTAIN MACRO (HEADER DSCB)
VOLSER   DS    CL6
OBLIST1  CAMLST SEARCH,DSN,VOLSER,DSCB1LST
         DS    0D
DSCB1LST DS    CL148
*--------VTOC DSCB 2 OBTAIN MACRO (ISAM DSCB)
OBLIST2  CAMLST SEEK,DSCB1LST+91,VOLIST+6,DSCB2LST
         DS    0D
DSCB2LST DS    CL148
*--------VTOC DSCB 3 OBTAIN MACRO (EXTENSION DSCB)
OBLIST3  CAMLST SEEK,DSCB1LST+91,VOLIST+6,DSCB3LST
         DS    0D
DSCB3LST DS    CL148
         DS    CL16 PROTECT THE DEVTABLE
         EJECT
***********************************************************************
*               D E V I C E   N A M E   T A B L E                     *
***********************************************************************
         SPACE 1
DEVTABLE EQU   *
         DC    X'2006'
         DC    X'0008'
         DC    CL6'2305-1'
         DC    X'2007'
         DC    X'0008'
         DC    CL6'2305-2'
         DC    X'2009'
         DC    X'0013'
         DC    CL6'3330  '
         DC    X'200D'
         DC    X'0013'
         DC    CL6'3330-1'
         DC    X'200B'
         DC    X'001E'
         DC    CL6'3350  '
         DC    X'200E'
         DC    X'000F'
         DC    CL6'3380  '
         DC    X'0000'         ** MARKS END OF DEVICE TABLE **
         EJECT
***********************************************************************
*      WORK AREAS FOR 3270 ADDRESS CONVERSION ROUTINES                *
***********************************************************************
         SPACE 1
WORKDBLW DC    D'0'                    HEX/DECIMAL CONVERSION AREA
ROW      DS    CL2                     ROW
COLUMN   DS    CL2                     COLUMN
BUFFADDR DS    XL2                     3270 BUFFER ADDRESS
STARTADR DS    XL2                     3270 BUFFER ADDRESS: STARTING
ENDADDR  DS    XL2                     3270 BUFFER ADDRESS: ENDING
*--> WORK DATA ITEMS FOR 3270 TRANSLATION ROUTINE
R327FLD1 DS    F                       WORK AREA
R327FLD2 DS    F                       WORK AREA
*--> IBM 3270 BASE 64 ENCODING TABLE (IS THERE A ROUTINE SOMEWHERE?)
TABLE327 EQU   *
         DC    X'40C1C2C3C4C5C6C7C8C94A4B4C4D4E4F'
         DC    X'50D1D2D3D4D5D6D7D8D95A5B5C5D5E5F'
         DC    X'6061E2E3E4E5E6E7E8E96A6B6C6D6E6F'
         DC    X'F0F1F2F3F4F5F6F7F8F97A7B7C7D7E7F'
         EJECT
*--> THE FOLLOWING ARE USED BY THE 'FULLSCR' ROUTINE
CLSCREEN DC    XL12'C11140403C4040001140C113'
SCPREFIX DC    XL11'C11140403C404000114040'
         SPACE 1
ALISTPTR DC    A(0)                    PTR TO ACTIVE ATTR LIST
ASCRNPTR DC    A(0)                    PTR TO ACTIVE INPUT SCREEN
ASCRNSIZ DC    F'0'                    SIZE OF THE SCREEN INPUT
ASUFXPTR DC    A(0)                    LENGTH/PTR TO SUFFIX
         SPACE 1
ATRLST1B DS    0F
         DC    A(ATRLST1E)             END OF THIS LIST
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN01+00)         FIRST BYTE OF SCREEN
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN02+00)         FIRST BYTE OF SECOND LINE
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN04+00)         FIRST BYTE OF FIFTH LINE
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN24+00)         BEGINNING OF LAST LINE
         DC    AL1(ATR@PH)             PROTECT-HIGH / WHITE
         DC    AL3(SC1LN24+22)         BEGINNING OF PFK LIST
         DC    AL1(ATR@PL)             PROTECT-LOW  / BLUE
         DC    AL3(SC1LN24+56)         END OF PFK LIST
ATRLST1E EQU   *
         SPACE 1
ATR@PL   EQU   X'E4'                   PROTECT-LOW  / BLUE
ATR@PH   EQU   X'E8'                   PROTECT-HIGH / WHITE
ATR@UL   EQU   X'C4'                   UNPROT-LOW   / GREEN
ATR@UH   EQU   X'C8'                   UNPROT-HIGH  / RED
         EJECT
***********************************************************************
*  EXTENDED COLOR FIELDS FOR FULL CAPABILITY SCREENS                  *
***********************************************************************
         SPACE 1
SC1COLOR EQU   *
         DC    XL1'F1'                 WRITE COMMAND
         DC    XL1'C2'                 WCC - RELEASE KEYBOARD
*--> BACK-LIGHT THE TITLE LINE
         DC    XL16'1140402903C0F841F442F311C14F1DE8'
*--> REVERSE VIDEO THE TITLE BLOCKS
         DC    XL16'11C2602903C0F841F242F111C36F1DE8'
ESC1CLR  EQU   *
LSC1CLR  EQU   ESC1CLR-SC1COLOR
         EJECT
         SPACE 2
***********************************************************************
*  THIS IS THE MAIN SCREEN                                            *
***********************************************************************
         SPACE 1
SCREEN1  EQU   *
SC1LN01  DC    CL40'                T S O   L I S T C A T   '
         DC    CL40'L E V E L   D I S P L A Y               '
SC1LN02  DC    CL40' ---------------------------------------'
         DC    CL40'--------------------------------------- '
SC1LN03  DC    CL40' NUM  DATASET NAME                    VO'
         DC    CL40'LSER  DVTYP  ORG  RECFM  LRECL  BLKSIZE '
SC1LN04  DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN05  DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
         DC    CL40'                                        '
SC1LN24  DC    CL40' --------------------   PF3=END  PF7=BAC'
         DC    CL40'K  PF8=FORWARD   ---------------------- '
SC1SUFIX DC    XL4'115DC813'
         SPACE 1
SCRBLD   DS    CL4096                  BUILD AREA FOR FINAL SCREEN
         EJECT
***********************************************************************
*  INTERRUPTION EXIT ROUTINE ---- STAX SERVICE ROUTINE                *
***********************************************************************
         SPACE 2
ATTNRTN  CSECT
         STM   R14,R12,12(R13)         SAVE CALLERS REGISTERS
         BALR  R12,R0                  SET UP BASE REGISTER
         DROP  R12                     DROP OLD BASE REGISTER
         USING *,R12                   SET UP NEW BASE REGISTER
         ST    R13,STAXSAVE+4          SAVEAREA BACKWARD PTR
         LA    R11,STAXSAVE            PICK UP OUR SAVEAREA ADDR
         ST    R11,8(R13)              SAVEAREA FORWARD PTR
         LR    R13,R11                 ESTABLISH NEW S/A PTR
         SPACE 1
         L     R3,STAXSWAD             GET ADDR OF SWITCH ADDR
         MVI   0(R3),C'1'              TURN SWITCH ON
         SPACE 1
         L     R13,STAXSAVE+4          PICK UP OLD S/A ADDR
         LM    R14,R12,12(R13)         RESTORE CALLERS REGISTERS
         LA    R15,0                   SET RC=0
         BR    R14                     RETURN TO CALLER
         SPACE 1
STAXSWAD DC    A(STAXSW)               ADDR OF INTERRUPT SWITCH
STAXSAVE DS    18F                     SAVE AREA FOR INTERRUPT RTN
         EJECT
***********************************************************************
*                     D S E C T S                                     *
***********************************************************************
         SPACE 2
         PRINT ON,NOGEN,NODATA
EXTRAREA DSECT
EALINENO DS    PL2                     LINE NUMBER (GENERATED)
EADSN    DS    CL44                    DSNAME
EAVOLSER DS    CL6                     VOLSER
EADEVTYP DS    CL2                     DEVICE TYPE
EAUNITYP DS    CL6                     DEVICE TYPE (CHARACTER)
EATRKCYL DS    CL2                     TRACKS PER CYLINDER
EADSORG  DS    CL2                     DSORG
EALRECL  DS    CL2                     LRECL
EABLKSIZ DS    CL2                     BLKSIZE
EARKPOFF DS    CL2                     RKP (OFFSET)
EARECFM  DS    CL4                     RECFM
EAENTYPE DS    CL1                     ENTRY TYPE
EAKEYLEN DS    CL1                     KEYLEN
EXTRLNTH EQU   *-EXTRAREA              LENGTH OF ENTRY
         SPACE 2
SCRNLINE DSECT
         DS    CL1
SCLINENO DS    CL3                     LINE NUMBER
         DS    CL2
SCDSN    DS    CL30                    DSNAME
         DS    CL2
SCVOLSER DS    CL6                     VOLSER
         DS    CL2
SCUNITYP DS    CL6                     DEVICE TYPE
         DS    CL2
SCDSORG  DS    CL2                     DATASET ORGANIZATION
         DS    CL2
SCRECFM  DS    CL4                     RECORD FORMAT
         DS    CL1
SCLRECL  DS    CL7                     LRECL
         DS    CL1
SCBLKSIZ DS    CL7                     BLKSIZE
         SPACE 2
         END   LISTLEV
