./ ADD NAME=ALLOC
         MACRO
&LISTNAM ALLOC &DUMMY,                                                 C
               &COPIES=NOTSPECIFIED,                                   C
               &DCB=NOTSPECIFIED,                                      C
               &DDN=NOTSPECIFIED,                                      C
               &DDNRET=NOTSPECIFIED,                                   C
               &DISP=NOTSPECIFIED,                                     C
               &DSN=NOTSPECIFIED,                                      C
               &DSNRET=NOTSPECIFIED,                                   C
               &FREE=NOTSPECIFIED,                                     C
               &LABEL=NOTSPECIFIED,                                    C
               &MBR=NOTSPECIFIED,                                      C
               &OUTLIM=NOTSPECIFIED,                                   C
               &SPACE=NOTSPECIFIED,                                    C
               &SYSOUT=NOTSPECIFIED,                                   C
               &DEST=NOTSPECIFIED,                                     C
               &HOLD=NOTSPECIFIED,                                     C
               &TERM=NOTSPECIFIED,                                     C
               &VOL=NOTSPECIFIED,                                      C
               &VOLRET=NOTSPECIFIED,                                   C
               &UNIT=NOTSPECIFIED,                                     C
               &PERMALLOC=NOTSPECIFIED,                                C
               &USEEXIST=NO,                                           C
               &MF=I
*
*           AA        LL         LL           OOOO         CCCCCCC
*          AAAA       LL         LL         OOOOOOOO      CCCCCCCCC
*         AA  AA      LL         LL        OO      OO    CC       CC
*        AA    AA     LL         LL        OO      OO    CC
*        AA    AA     LL         LL        OO      OO    CC
*        AAAAAAAA     LL         LL        OO      OO    CC
*        AAAAAAAA     LL         LL        OO      OO    CC
*        AA    AA     LL         LL        OO      OO    CC       CC
*        AA    AA     LLLLLLLL   LLLLLLLL   OOOOOOOO      CCCCCCCCC
*        AA    AA     LLLLLLLL   LLLLLLLL     OOOO          CCCCC
*
.**********************************************************************
.*                                                                    *
.*       AIR FORCE DATA SERVICES CENTER, SYSTEMS SUPPORT DIRECTORATE  *
.*       ROOM 1D987, THE PENTAGON, WASHINGTON, DC 20330               *
.*       TELEPHONE: COMMERCIAL: (202) 695-1274/695-2478               *
.*                  AUTOVON:          225-1274/225-2478               *
.*                                                                    *
.*       AUTHOR:  CAPT BRUCE E. HOGMAN, SYSTEMS PROGRAMMER            *
.*       DESIGNED: HALLOWEEN, 1978                                    *
.*       INSTALLED: THANKSGIVING, 1978                                *
.*       U.S. CUSTOMS SERVICE UPDATES: BRUCE E. HOGMAN 89-01-10       *
.*       -- ADD MISCELLANEOUS KEYWORDS LIKE COPIES.                   *
.* 1991-01:  AUTHOR IS NOW AT US CUSTOMS: (703) 440-6470              *
.*                                                                    *
.**********************************************************************
.*       THIS SYSTEM OF MACROS, ALLOC, ALLOC#0 - ALLOC#7, CANNOT BE   *
.*  COPYRIGHTED, IS PROVIDED FREE TO ALL REQUESTORS, AND IS FURNISHED *
.*  WITHOUT ANY WARRANTY STATED OR IMPLIED.  USERS ARE INVITED TO     *
.*  COMMUNICATE THEIR IDEAS AS TO IMPROVEMENTS TO THE CODE TO CORRECT *
.*  EXISTING ERRORS OR TO EXPAND CAPABILITIES TO THE AUTHOR AT THE    *
.*  ABOVE ADDRESS.  USERS WHO RECEIVE THIS SYSTEM OF MACROS WILL ALSO *
.*  RECEIVE NOTICE OF UPDATES TO THE SYSTEM.  THE SYSTEM OF MACROS    *
.*  SHOULD BE PRESENTED AT SHARE AUG 79 IN NEW YORK AND SHOULD BE     *
.*  AVAILABLE ON THE MVS GROUP TAPE SOON AFTER.                       *
.*                                                                    *
.**********************************************************************
.*                                                                    *
.*                                                                    *
.*       THE PURPOSE OF THE ALLOC MACRO IS TO ENABLE THE ASSEMBLER    *
.*   LANGUAGE PROGRAMMER TO WRITE PROGRAMS WHICH USE DYNAMIC ALLOCA-  *
.*   TION WITH A GREATER DEGREE OF EASE.  USING THIS MACRO, THE PRO-  *
.*   GRAMMER CODES THE MACRO CALL JUST LIKE A JCL DD STATEMENT TO     *
.*   DESCRIBE THE RESOURCE HE WISHES TO ALLOCATE DYNAMICALLY.  DUE    *
.*   TO THE CONSTRAINTS OF THE MACRO LANGUAGE, THERE ARE ONE OR TWO   *
.*   MINOR CODING DIFFERENCES BETWEEN CODING THE JCL DD STATEMENT AND *
.*   CODING THE ALLOC MACRO CALL.                                     *
.*                                                                    *
.*       FOR EXAMPLE:  CODE: VOL=(SER,NNNNNN) INSTEAD OF              *
.*                           VOL=SER=NNNNNN                           *
.*                     CODE: VOL=(PRIVATE,SER,NNNNNN) INSTEAD OF      *
.*                           VOL=(PRIVATE,SER=NNNNNN)                 *
.*                                                                    *
.*       THERE IS A DANGER IN INDISCRIMINATE USE OF DYNAMIC ALLOCATION
.*   OF WHICH THE USER MUST BE AWARE:  IT IS QUITE POSSIBLE TO LOCKUP *
.*   THE OPERATING SYSTEM WHEN TWO OR MORE JOBS ARE USING DYNAMIC ALLO-
.*   CATION TO ACQUIRE USE OF SEVERAL RESOURCES, AND THESE RESOURCES  *
.*   ARE CURRENTLY ALLOCATED TO THOSE JOBS WHICH ARE SEEKING FURTHER  *
.*   DYNAMIC ALLOCATION.  FOR EXAMPLE:  JOB 'A' HOLDS RESOURCE 'X'    *
.*   AND SEEKS TO HAVE EXCLUSIVE USE OF RESOURCE 'Y', WHILE AT THE    *
.*   SAME TIME, JOB 'B' HOLDS RESOURCE 'Y' AND SEEKS EXCLUSIVE USE OF *
.*   RESOURCE 'X'.  THE JOBS MAY INVOLVE THE SYSTEM IN AN ALLOCATION  *
.*   LOCKUP IF THEIR REQUESTS ALLOW DEFER MOUNTING.  IF THEIR REQUESTS*
.*   ARE OF THE IMMEDIATE TYPE, THEN ONE OR BOTH REQUESTS WILL FAIL,  *
.*   AND THE FAILING REQUEST(S) MUST BE RE-ACCOMPLISHED.  PROGRAM     *
.*   LOGIC MUST TAKE INTO ACCOUNT THE POSSIBILITY OF A FAILED REQUEST.*
.*                                                                    *
.*                                                                    *
.* PLANS FOR REL 2 CALL FOR CAPABILITY OF MF=E TO SUPPORT FULL
.* REENTERANT MF=E CODING, AT A COST OF MORE INSTRUCTIONS NEEDED
.* TO ACCOMPLISH THE SETTING OF ADDRESS POINTERS IN THE REQUEST
.* BLOCK.  AT THIS TIME, THE TARGET REQUEST BLOCK FOR EXEC FORM
.* OF THE MACRO SHOULD BE CONSIDERED UNMOVABLE.  BECAUSE OF THE
.* LARGE NUMBER OF ADDRESSES POSSIBLE IN A REQUEST, AND THE AMOUNT
.* OF INFORMATION THAT COULD BE MOVED INTO THE LIST, MAKING THE
.* CAPABILITY OF FULL REENTERANT CODING POSSIBLE AT THIS TIME
.* WOULD MOST LIKELY PROVE A SELDOM-USED CAPABILITY.
.*
.*
.*
.*
.**********************************************************************
.*                                                                    *
.*       DEFINE THE GLOBAL VARIABLES WHICH ARE USED IN COMMUNICATION  *
.*   BETWEEN THE VARIOUS MF=X FORMS OF THE MACRO.                     *
         GBLC  &S99LNAM(100)        LIST FORMAT NAMES
         GBLC  &S99ENAM(100)        EXEC FORMAT NAMES
         GBLC  &S99INAM(100)        IN-LINE NAMES
         GBLC  &S99LSYS(100)        SYSNDX VALUE FOR ASSOCIATED NAME
         GBLC  &S99ESYS(100)        -DO- FOR EXEC FORM NAME
         GBLC  &S99ISYS(100)        -DO- FOR IN-LINE USE.
         GBLA  &S99#NL              NUMBER OF MF=L USES
         GBLA  &S99#NE              NUMBER OF MF=E USES
         GBLA  &S99#NI              NUMBER OF IN-LINE USES
         GBLA  &S99ARGI             USED FOR COMMUNICATION WITH
         GBLA  &S99SP2X             USED TO OBTAIN SPACE INNER
.*                                  OPERANDS FROM ALLOC
.*                                  LOWER-LEVEL INNER MACROS.
.*
.*       DEFINE THE VARIOUS LOCAL VARIABLES IN USE BY EACH USE OF
.*   THE MACRO
         LCLB  &BCOP
         LCLB  &BDDN,&BDSN,&BMBR,&BDISP,&BSPACE,&BVOL,&BUNIT,&BSYSOUT
         LCLB  &BDEST  FOR DEST= SPECIFICATION
         LCLB  &BOUTLIM,&BFREE,&BLABEL,&BDCB,&BDDNRET,&BDSNRET,&BVOLRET
         LCLB  &BDUMMY,&BTERM,&BHOLD
.*             THESE LOCAL VARIABLES ABOVE ARE USED TO DETERMINE IF
.*             ANY PART OF THE MAJOR OPERANDS WAS SPECIFIED.
.*
         LCLA  &ERRLVL,&I,&J,&K,&EREF,&N
.*
         LCLC  &Q                  HAS THE REMEMBERED VALUE OF
.*                                 SYSNDX FOR ANOTHER USE OF THE
.*                                 SAME LIST NAME.  THIS VALUE IS
.*                                 USED TO CONNECT THE TWO USES OF
.*                                 THE SAME NAME, FOR MF=L AND MF=E.
         LCLC  &MFC                USED TO KEEP THE FIRST SUBFIELD
.*                                 OF MF OPERAND
.*
         LCLB  &MOUNT              THIS ITEM IS SET IF
.*                                 UNIT=(XXXX,,DEFER)
.*                                             *****
.*                                 TO INDICATE THAT WAITING ON MOUNT
.*                                 IS PERMITTED. TO BE USED CAREFULLY.
.*
         LCLB  &PALLOC,&UEXIST
.*
         LCLC  &C                  USED TO DEFINE STRINGS
         LCLC  &CC                 USED TO DEFINE STRINGS
.*
         LCLB  &T01,&T02,&T03,&T04,&T05,&T06,&T07,&T08,&T09,&T10
         LCLB  &T0A,&T0B,&T0C,&T0D,&T0E,&T0F
         LCLB  &T11,&T12,&T13,&T14,&T15,&T16,&T17,&T18,&T19,&T1A
         LCLB  &T1B,&T1C,&T1D,&T1E,&T1F,&T20,&T21,&T22,&T23,&T24
         LCLB  &T28 FOR TERM=TS VARIABLE
         LCLB  &T2C,&T2D,&T2DCB FOR DCB SUBFIELDS
         LCLB  &T52,&TXIST         PERMALLOC FLAG, USEEXIST
         LCLB  &T58 DEST=
         LCLB  &T55,&T56,&T59,&T5D
         LCLB  &T10EQ,&T14EQ FLAGS FOR EQUAL SIGN IN SER=,REF=
.*
         LCLA  &T01A,&T02A,&T03A,&T04A,&T05A,&T06A,&T07A,&T08A,&T09A
         LCLA  &T0AA,&T0BA,&T0CA,&T0DA,&T0EA,&T0FA,&T10A,&T11A,&T12A
         LCLA  &T13A,&T14A,&T15A,&T16A,&T17A,&T18A,&T19A,&T1AA,&T1BA
         LCLA  &T1CA,&T1DA,&T1EA,&T1FA,&T20A,&T21A,&T22A,&T23A,&T24A
         LCLA  &T28A FOR TERM=TS VARIABLE
         LCLA  &T2CA,&T2DA,&T56A,&T55A,&T5DA
.*
         LCLA  &T02#3A  USED TO DISTINGUISH BETWEEN DSN(MBR) CASES
.*
&Q       SETC  '&SYSNDX'(1,4)
.*
.*       DETERMINE WHICH OPERANDS ARE PRESENT IN ANY FORM.
&BDCB    SETB    ('&DCB' NE 'NOTSPECIFIED')
&BDDN    SETB    ('&DDN' NE 'NOTSPECIFIED')
&BDDNRET SETB ('&DDNRET' NE 'NOTSPECIFIED')
&BDISP   SETB   ('&DISP' NE 'NOTSPECIFIED')
&BDSN    SETB    ('&DSN' NE 'NOTSPECIFIED')
&BDSNRET SETB ('&DSNRET' NE 'NOTSPECIFIED')
&BDUMMY  SETB   ('&DUMMY' EQ 'DUMMY')
&BFREE   SETB   ('&FREE' NE 'NOTSPECIFIED')
&BCOP    SETB   ('&COPIES' NE 'NOTSPECIFIED')
&BLABEL  SETB  ('&LABEL' NE 'NOTSPECIFIED')
&BMBR    SETB    ('&MBR' NE 'NOTSPECIFIED')
&BOUTLIM SETB ('&OUTLIM' NE 'NOTSPECIFIED')
&BSPACE  SETB  ('&SPACE' NE 'NOTSPECIFIED')
&BSYSOUT SETB ('&SYSOUT' NE 'NOTSPECIFIED')
&BDEST   SETB   ('&DEST' NE 'NOTSPECIFIED')
&BHOLD   SETB   ('&HOLD' EQ 'YES')
&BTERM   SETB   ('&TERM' NE 'NOTSPECIFIED')
&BVOL    SETB    ('&VOL' NE 'NOTSPECIFIED')
&BVOLRET SETB ('&VOLRET' NE 'NOTSPECIFIED')
&BUNIT   SETB   ('&UNIT' NE 'NOTSPECIFIED' AND '&UNIT(1)' NE '')
&MFC     SETC  '&MF(1)'
&MOUNT   SETB  ('&UNIT(3)' NE 'DEFER') TO INDICATE WAIT OK FOR MOUNT
&PALLOC  SETB ('&PERMALLOC' EQ 'NOTSPECIFIED' OR '&PERMALLOC' EQ 'YES')
&T1C     SETB  (&BFREE AND '&FREE' EQ 'CLOSE')
&TID     SETB  (&BCOP)
&PALLOC  SETB  (&PALLOC AND NOT &T1C)
&T52     SETB  (&PALLOC)
&UEXIST  SETB  ('&USEEXIST' NE 'NO')
&TXIST   SETB  (NOT &UEXIST)
.*
.*       DETECT SIMPLE ERRORS IN MUTUALLY EXCLUSIVE OPERANDS
.*
.ERRLVL1 ANOP
         AIF   (&BDSN AND &BSYSOUT).ERR1
         AIF   (&BMBR AND &BSYSOUT).ERR1
.ERT2    AIF   (&BSYSOUT AND &BDSNRET).ERR2
         AIF   (&BSYSOUT AND &BVOLRET).ERR2
.ERT3    AIF   (&BHOLD AND NOT &BSYSOUT).ERR4
         AIF   (&BCOP  AND NOT &BSYSOUT).ERR6
         AIF   (&BDEST AND NOT &BSYSOUT).ERR6
         AIF   ('&MFC' EQ 'E').ERRLVLX
         AIF   ('&MFC' EQ 'L' AND &BDDNRET).ERR5
 AIF   (NOT &BDSN AND NOT &BSYSOUT AND NOT &BDUMMY AND NOT &BTERM).ERR3
         AGO   .ERRLVLX
.ERR1    MNOTE 8,'DSN, SYSOUT MUTUALLY EXCLUSIVE OPERANDS.'
         AGO   .ERT2
.ERR2    MNOTE 4,'DSNRET INVALID WITH SYSOUT'
         AGO   .ERT3
.ERR3    MNOTE 4,'DSN/SYSOUT/DUMMY/TERM=TS: ONE SHOULD BE USED.'
         AGO   .ERRLVL4
.ERR4    MNOTE 4,'HOLD=YES REQUIRES SYSOUT OPERAND ALSO.'
         AGO   .ERRLVL4
.ERR5    MNOTE 4,'DDNRET NOT RECOGNIZED FOR MF=L. USE IN MF=E FORMAT.'
         AGO   .ERRLVL4
.ERR6    MNOTE 8,'SYSOUT NEEDED WITH DEST OR COPIES'
         AGO   .ERRLVL8
.ERRLVL4 ANOP
&ERRLVL  SETA  4
         AGO   .ERRLVLX
.ERRLVL8 ANOP
&ERRLVL  SETA  8
.ERRLVLX ANOP
.*
.*********************************************************************
.*
.*       PROCESS THE MF= OPERAND IN ORDER TO DETERMINE WHAT TYPE OF
.* FORMAT IS THIS USE OF THE MACRO.THE VARIOUS FORMATS OF THE MACRO
.* ARE LINKED TOGETHER BY MEANS OF THE LISTNAM VARIABLE.  IN ORDER TO
.* CHANGE ITEMS IN THE LIST FORMAT, THE EXECUTE FORMAT MUST HAVE AVAIL-
.* ABLE THE VALUE OF SYSNDX THAT WAS USED FOR THE LIST FORMAT USAGE, OR
.* THE LIST FORMAT USAGE MUST HAVE AVAILABLE THE SYSNDX VALUE THAT WAS
.* USED BY THE EXECUTE FORMAT, SINCE EITHER USE OF THE MACRO MAY OCCUR
.* FIRST.  ALSO, TWO EXECUTE USES OF THE SAME LIST MUST USE THE SAME
.* VALUE OF SYSNDX IN ORDER TO BE ABLE TO REFERENCE THE SAME REQUEST
.* BLOCK.
.*       ALL OF THIS IS A PROBLEM IN THE FIRST PLACE BECAUSE OF THE
.* VARIABLE NATURE OF THE DYNAMIC ALLOCATION REQUEST BLOCK.  THERE MAY
.* A VARYING NUMBER OF TEXT UNITS, AND SIMILARLY, A VARYING NUMBER OF
.* POINTERS TO THESE TEXT UNITS, SO THE DISPLACEMENTS FOR THE VARIOUS
.* ITEMS CHANGE, NECESSITATING THE PROCEDURE DESCRIBED HERE OF LINKING
.* TOGETHER MULTIPLE USES OF THE SAME LIST NAME.
.*       AN EXAMPLE OF USES:
.*   1.  THE FIRST USE OF THE MACRO IS MF=(E,LIST1)
.*       A.  THE E-USE LIST S99ENAM(I) IS SEARCHED FOR DUPLICATE
.*           USE OF 'LIST1'.  LET US ASSUME THAT THERE IS NONE.
.*       B.  FINDING NO DUPLICATE IN THE E-USE, THE MACRO SEARCHES
.*           BOTH THE IN-LINE (S99INAM) AND MF=L (S99LNAM) LISTS.
.*           LET US ASSUME THERE IS NO MATCH, THAT THIS IS THE FIRST
.*           USE ANYWHERE OF THE NAME 'LIST1'.
.*       C.  HAVING FOUND NO PRIOR USE, A NEW ENTRY IS MADE IN THE
.*           E-NAME LIST, AND THE POINTER TO THE HIGHEST ENTRY IN
.*           THE E-NAME LIST (S99#NE) IS INCREASED BY ONE.
.*           S99ENAM(S99#NE) IS SET TO 'LIST1'.  SYSNDX=0001 <<
.*   2.  THE SECOND USE OF THE MACRO IS ALSO MF=(E,LIST1)
.*       A.  WHEN THE E-NAME LIST IS SEARCHED, THEN A MATCH IS FOUND
.*           FOR THE NAME 'LIST1'.
.*       B.  THE NAME QUALIFIER (Q) IS SET TO THE PREVIOUS VALUE OF
.*           SYSNDX WHICH WAS USED FOR THE PREVIOUS MF=E, WHICH
.*           POINTS ALL REFERENCES IN THE CURRENT USE OF THE MACRO
.*           TO THE SAME LIST, LIST1.
.*   3.  THE THIRD USE OF THE MACRO IS:   LIST1 ALLOC ...,MF=L
.*       A.  THE L-LIST IS SEARCHED, BUT NO DUPLICATE EXISTS, SO
.*           THE E-LIST IS SEARCHED.  (IT IS AN ERROR TO HAVE TWO
.*           LISTS BY THE SAME NAME, AND THE MACRO TELLS YOU THIS.)
.*       B.  THE NAME 'LIST1' IS FOUND IN THE E-LIST, SO THE VALUE
.*           0001 IS SET IN VARIABLE 'Q' AND THIS VALUE IS USED IN
.*           DEFINING THE REQUEST BLOCK, SO THE CORRESPONDENCE IS
.*           NOW MADE BETWEEN THE LIST FORMAT OF THE MACRO AND THE
.*           TWO EXECUTE FORMS WHICH REFERENCE THE SAME LIST.
.*
.*
.MFX0000 ANOP
.*
         AIF   ('&MFC' EQ 'E').MFE0000     GO TO EXECUTE FORMAT
         AIF   ('&MFC' EQ 'I').MFI0000     GO TO IN-LINE PROCESS
         AIF   ('&MFC' EQ 'L').MFL0000     GO TO LIST-FORMAT
         MNOTE 8,'MF=&MFC INVALID: NOT E, L, OR I.'
.MFX0001 MNOTE 'ASSUMED TO BE IN-LINE USE. DEFINITION CONTINUES'
&MFC     SETC  'I'
         AGO   .MFX0000                    IT WILL GO TO IN-LINE
.MFL0000 ANOP
         AIF   ('&LISTNAM' NE '').MFL0001  CHECK FOR MISSING NAME
         MNOTE 8,'NAME FIELD OMITTED. LIST HAS NO NAME.'
         AGO   .MFX0001                     ASSUME IN-LINE
.MFL0001 ANOP
.*
.*             CHECK FOR DUPLICATE LIST NAMES
.*
&I       SETA  0
.MFL0002 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NL).MFL0003
         AIF   ('&S99LNAM(&I)' NE '&LISTNAM').MFL0002
         MNOTE 8'&LISTNAM IS DUPLICATE OF PRIOR USE.'
.MFL00A2 MNOTE 'REFERENCES TO &LISTNAM WILL POINT TO 1ST DEFINITION.'
         MNOTE 'DEFINITION CONTINUES TO CHECK FOR ERRORS'
         AGO   .MFL0007            GO SET NEW ENTRY IN LIST
.MFL0003 ANOP
.*
.*       CHECK FOR DUPLICATE OF IN-LINE USE
.*
&I       SETA  0
.MFL0004 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NI).MFL0005
         AIF   ('&S99INAM(&I)' NE '&LISTNAM').MFL0004
         MNOTE 8,'&LISTNAM IS DUPLICATE OF IN-LINE PRIOR USE.'
         AGO   .MFL00A2
.MFL0005 ANOP
.*
.*       CHECK FOR PRIOR MF=E USE
.*
&I       SETA  0
.MFL0006 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NE).MFL0008
         AIF   ('&S99ENAM(&I)' NE '&LISTNAM').MFL0006
&Q       SETC  '&S99ESYS(&I)'      REMEMBER PRIOR VALUE OF SYSNDX
.MFL0007 ANOP
&S99#NL  SETA  &S99#NL+1           COUNT THE NUMBER OF ITEMS IN LIST
&S99LNAM(&S99#NL) SETC '&LISTNAM'  ENTER NEW ITEM IN THE LIST
&S99LSYS(&S99#NL) SETC '&Q'        ENTER NEW ITEM
         CNOP  0,4                 ALIGN TO A FULLWORD
&LISTNAM B S99Z&Q                  GO AROUND RB IF USED IN-LINE
         AGO   .MFXEXIT            COMPLETED MF=X PROCESSING
.MFL0008 ANOP
&Q       SETC  '&SYSNDX'(1,4)      NEW NAME IN LIST
         AGO   .MFL0007            NEW ENTRY
.*
.*
.* NOW DO MF=E PROCESSING
.*
.MFE0000 ANOP
         AIF   ('&MF(2)' NE '').MFE0001
         MNOTE 8,'MF=&MF GIVES NO LIST NAME'
.MFE00A0 MNOTE 'DEFINITION CONTINUES FOR ERROR SCAN'
         AGO   .MFE0008            ENTER NEW ITEM IN TABLE
.MFE0001 ANOP
&C       SETC  '&MF(2)'            KEEP THE LIST NAME HERE TEMPORARILY
&I       SETA  0
&J       SETA  K'&MF(2)
.MFE0002 ANOP
&I       SETA  &I+1
         AIF   (&I GT &J).MFE0003
         AIF   ('&MF(2)'(&I,1) NE '(').MFE0002
         MNOTE 8,'REGISTER NOTATION INVALID, REL 1.02'
         MNOTE 'LIST NAME MUST BE TEXT ONLY.'
         AGO   .MFE00A0
.MFE0003 ANOP
&I       SETA  0
.*
.*       CHECK FOR REFERENCE TO SAME NAME IN PREVIOUS MF=E
.*
.MFE00A3 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NE).MFE0004
         AIF   ('&S99ENAM(&I)' NE '&C').MFE00A3
&Q       SETC  '&S99ESYS(&I)'      REMEMBER PREVIOUS VALUE
         AGO   .MFXEXIT
.MFE0004 ANOP
.*
.*       CHECK FOR REFERENCE TO AN IN-LINE FORMAT
.*
&I       SETA  0
.MFE0005 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NI).MFE0006
         AIF   ('&S99INAM(&I)' NE '&C').MFE0005
         MNOTE 4,'WARNING: &C, IN LINE LIST, IS REFERENCED.'
&Q       SETC  '&S99ISYS(&I)'
         AGO   .MFXEXIT
.MFE0006 ANOP
.*
.*       CHECK FOR MF=L FORMAT ENTRY WHICH MATCHES LISTNAM
.*
&LISTNAM DS    0H DEFINE NAME
&I       SETA  0
.MFE0007 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NL).MFE0008
         AIF   ('&S99LNAM(&I)' NE '&C').MFE0007
&Q       SETC  '&S99LSYS(&I)'
         AGO   .MFXEXIT
.MFE0008 ANOP
&Q       SETC  '&SYSNDX'(1,4)
&S99#NE  SETA  &S99#NE+1
&S99ENAM(&S99#NE) SETC '&C'
&S99ESYS(&S99#NE) SETC '&Q'
         AGO   .MFXEXIT
.*
.*
.*  DO IN-LINE MF=I PROCESSING
.*
.*
.*
.MFI0000 ANOP
         AIF   ('&LISTNAM' EQ '').MFI000X
.*       CHECK FOR DUPLICATE IN-LINE LISTNAME (ASSEMBLER WILL HELP)
.*
&I       SETA  0
.MFI0001 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NI).MFI0002
         AIF   ('&S99INAM(&I)' NE '&LISTNAM').MFI0001
         MNOTE 8,'DUPLICATE IN-LINE LISTNAME.'
         AGO   .MFI0006             GO GEN NEW NAME ANYWAY
.MFI0002  ANOP
&I       SETA  0
.*
.*       CHECK FOR A DUPLICATE LIST NAME IN THE MF=L LIST
.*
.MFI0003 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NL).MFI0004
         AIF   ('&S99LNAM(&I)' NE '&LISTNAM').MFI0003
         MNOTE 8,'IN-LINE LIST NAME DUPLICATE OF PREVIOUS MF=L USE.'
         AGO   .MFI0006             CONSIDER IT A NEW NAME ANYWAY
.MFI0004 ANOP
.*
.*       CHECK FOR PREVIOUS MF=E USE OF THE LIST NAME
.*
&I       SETA  0
.MFI0005 ANOP
&I       SETA  &I+1
         AIF   (&I GT &S99#NE).MFI0006
         AIF   ('&S99ENAM(&I)' NE '&LISTNAM').MFI0005
&Q       SETC  '&S99ESYS(&I)'      REMEMBER PREVIOUS VALUE
         AGO   .MFI0007            GO ENTER NEW ENTRY IN I-TABLE
.MFI0006 ANOP
&Q       SETC  '&SYSNDX'(1,4)      SET NEW VALUE FOR FIRST USE
.MFI0007 ANOP
&S99#NI  SETA  &S99#NI+1           ADD ONE TO NUMBER IN THIS TABLE
&S99INAM(&S99#NI) SETC '&LISTNAM'  ENTER THIS NAME IN TABLE
&S99ISYS(&S99#NI) SETC '&Q'        SET ENTRY IN ISYS TABLE
.MFI000X ANOP
         CNOP  0,4             ALIGN TO A FULLWORD
&LISTNAM B S99Z&Q              GO AROUND REQUEST BLOCK
         AGO   .MFXEXIT
.MFXEXIT ANOP
.*
.* END OF MF= PROCESSING.
.*
.*
.*
.*       SET THE TXX PRESENCE FLAGS
.SETTXX  ANOP
&T01     SETB  (&BDDN)
&T01A    SETA  K'&DDN
         ALLOC#1 &DDN,&MFC,YES,C,DDN
&T02     SETB  (&BDSN)
&T02A    SETA  K'&DSN
&T03     SETB  (&BMBR)
&T03A    SETA  K'&MBR
         AIF   (&T02 AND NOT &T03).BYD1
         ALLOC#1 &DSN,&MFC,YES,C,DSN THIS IS DSNAME BY ITSELF
         ALLOC#1 &MBR,&MFC,YES,C,MBR
&T02#3A  SETA  2         SEPARATE DSN, MBR OR JUST DSN BY ITSELF
         AGO   .T04P
.BYD1    ALLOC#1 &DSN,&MFC,YES,C,DSN
         AIF   (&S99ARGI NE 5).T03PY
&T02#3A  SETA  3         BOTH DSN(MBR) TOGETHER
&I       SETA  0
.T03P    ANOP
&T03A    SETA  K'&DSN
         AIF   ('&DSN'(&T03A,1) NE ')').T03PX NOT A MEMBER NAME(?)
&I       SETA  &I+1
         AIF   (&I GT &T03A).T03PX
         AIF   ('&DSN'(&I,1) NE '(').T03P
&T03     SETB  1                   WE HAVE A MEMBER NAME
&T02A    SETA  &I-1                SET LENGTH OF DSN ALONE
&T03A    SETA  &T03A-&T02A-2       SET LENGTH OF MBR ALONE
.T03PX   ANOP
         AGO   .T04P
.T03PY   ANOP
&T02#3A  SETA  1                   JUST DSN BY ITSELF
.*
.*       PROCESS DISP FIELD
.*
.T04P    AIF   (NOT &BDISP).T07P   IF NO DISP AT ALL, GO TO NEXT
         ALLOC#3 &DISP(1),(OLD,MOD,NEW,SHR),(1,2,4,8),DISP,STATUS
&T04     SETB  (&S99ARGI NE 0)
&T04A    SETA  &S99ARGI
         ALLOC#3 &DISP(2),(UNCATLG,CATLG,DELETE,KEEP),(1,2,4,8),       C
               DISP,DISPOSITION
&T05     SETB  (&S99ARGI NE 0)
&T05A    SETA  &S99ARGI
         ALLOC#3 &DISP(3),(UNCATLG,CATLG,DELETE,KEEP),(1,2,4,8),       C
               DISP,CONDITIONAL#DISPOSITION
&T06     SETB  (&S99ARGI NE 0)
&T06A    SETA  &S99ARGI
.*
.T07P    AIF   (NOT &BSPACE).T10P  BY-PASS IF SPACE NOT GIVEN
         ALLOC#3 &SPACE(1),(CYL,TRK),(1,2),SPACE,TYPE#SPACE
         AIF   (&S99ARGI EQ 1).T07P2
         AIF   (&S99ARGI EQ 2).T07P3
         AIF   ('&SPACE(1)' EQ '').T0AP
&T09     SETB  1
&T09A    SETA  &SPACE(1)           SET BLKSIZE
         AGO   .T0AP
.T07P2   ANOP
&T08     SETB  1
         AGO   .T0AP
.T07P3   ANOP
&T07     SETB  1
.T0AP    ANOP
&K       SETA  K'&SPACE(2) GET COUNT OF CHARACTERS
         AIF   ('&SPACE(2)'(1,1) EQ '(').T0APPAR
&CC      SETC  '&SPACE(2)'(1,&K)
&S99SP2X SETA  0
         AIF   ('&SPACE(2)' EQ '0').T0AAA
         ALLOC#SX &CC,1
         AIF   (&S99SP2X EQ 0).T0BP NO PRIMARY SPACE GIVEN
.T0AAA   ANOP
&T0A     SETB  1
&T0AA    SETA  &S99SP2X
         AGO   .T0DP NO SECONDARY SPACE CAN BE PRESENT, NOR DIR.
.T0APPAR ANOP
         AIF   ('&SPACE(2)'(1,3) EQ '(0,').T0AAB1
         AGO   .T0AAB2
.T0AAB1  ANOP
&T0A     SETB  1
&T0AA    SETA  0 ABSOLUTE ZERO SPACE PRIMARY
         AGO   .T0BP
.T0AAB2  ALLOC#SX &SPACE(2),1
         AIF   (&S99SP2X EQ 0).T0BP NO PRIMARY SPACE GIVEN
.*0AP    AIF   ('&SPACE(2,1)' EQ '').T0BP NO PRIMARY SPACE GIVEN
&T0A     SETB  1
&T0AA    SETA  &S99SP2X SET TO VALUE RETURNED
.*0AA    SETA  &SPACE(2,1)
.T0BP    ALLOC#SX &SPACE(2),2
         AIF   (&S99SP2X EQ 0).T0CP
.*0BP    AIF   ('&SPACE(2,2)' EQ '').T0CP
&T0B     SETB  1
&T0BA    SETA  &S99SP2X
.*0BA    SETA  &SPACE(2,2)
.T0CP    ALLOC#SX &SPACE(2),3
         AIF   (&S99SP2X EQ 0).T0DP
.*0CP    AIF   ('&SPACE(2,3)' EQ '').T0DP
&T0C     SETB  1
&T0CA    SETA  &S99SP2X
.*0CA    SETA  &SPACE(2,3)
.T0DP    AIF   ('&SPACE(3)' NE 'RLSE').T0EP
&T0D     SETB  1
.T0EP    AIF   ('&SPACE(4)' EQ '').T0FP
         ALLOC#3 &SPACE(4),(ALX,MXIG,CONTIG),(2,4,8),SPACE,            C
               ALX#MXIG#CONTIG
&T0E     SETB  (&S99ARGI NE 0)
&T0EA    SETA  &S99ARGI
.T0FP    AIF   ('&SPACE(5)' NE 'ROUND').T10P
&T0F     SETB  1
.T10P    ANOP
.*
.*               DEFER T10 PROCESSING
.*       BEGIN PROCESSING TO DECODE VOL= ENTRY
.*
.T11P    AIF   (NOT &BVOL).T15P BY PASS FOR NO VOL= PARM
&T11     SETB  ('&VOL(1)' EQ 'PRIVATE')
&T10A    SETA  1
         AIF   ('&VOL(1)' EQ 'SER' OR '&VOL(1)' EQ 'REF').T12P
&N       SETA  K'&VOL(1)
         AIF   (&N LT 4).T11P001
         AIF   ('&VOL(1)'(1,4) EQ 'SER=').T12P
         AIF   ('&VOL(1)'(1,4) EQ 'REF=').T12P
.T11P001 ANOP
&T10A    SETA  2
         AIF   ('&VOL(2)' EQ 'SER' OR '&VOL(2)' EQ 'REF').T12P
&N       SETA  K'&VOL(2)
         AIF   (&N LT 4).T11P002
         AIF   ('&VOL(2)'(1,4) EQ 'SER=').T12P
         AIF   ('&VOL(2)'(1,4) EQ 'REF=').T12P
.T11P002 ANOP
&T10A    SETA  3
         AIF   ('&VOL(3)' EQ 'SER' OR '&VOL(3)' EQ 'REF').T12P
&N       SETA  K'&VOL(3)
         AIF   (&N LT 4).T11P003
         AIF   ('&VOL(3)'(1,4) EQ 'SER=').T12P
         AIF   ('&VOL(3)'(1,4) EQ 'REF=').T12P
.T11P003 ANOP
&T12     SETB  ('&VOL(3)' NE '')   VOL SEQ FIELD
         AIF   (NOT &T12).T12P004
&T12A    SETA  &VOL(3)
.T12P004 ANOP
&T10A    SETA  4
         AIF   ('&VOL(4)' EQ 'SER' OR '&VOL(4)' EQ 'REF').T12P
&N       SETA  K'&VOL(4)
         AIF   (&N LT 4).T11P004
         AIF   ('&VOL(4)'(1,4) EQ 'SER=').T12P
         AIF   ('&VOL(4)'(1,4) EQ 'REF=').T12P
.T11P004 ANOP
&T13     SETB  ('&VOL(4)' NE '')   VOL COUNT FIELD
         AIF   (NOT &T13).T13P004
&T13A    SETA  &VOL(4)
.T13P004 ANOP
&T10A    SETA  5
         AIF   ('&VOL(5)' EQ 'SER' OR '&VOL(5)' EQ 'REF').T12P
&N       SETA  K'&VOL(5)
         AIF   (&N LT 4).T11P005
         AIF   ('&VOL(5)'(1,4) EQ 'SER=').T12P
         AIF   ('&VOL(5)'(1,4) EQ 'REF=').T12P
.T11P005 ANOP
         AGO   .T15P               SER, REF NOT SPECIFIED.
.T12P    AIF   ('&VOL(&T10A)' EQ 'REF').T13P
&N       SETA  K'&VOL(&T10A)
         AIF   (&N LT 4).T11P006
         AIF   ('&VOL(&T10A)'(1,4) EQ 'REF=').T14PEQ
         AIF   ('&VOL(&T10A)'(1,4) EQ 'SER=').T10PEQ
.T11P006 ANOP
&T10     SETB  1
&T10A    SETA  &T10A+1
         AGO   .T15P
.T10PEQ  ANOP
&T10     SETB  1                   SER= PRESENT
&T10EQ   SETB  1                   EQUAL SIGN PRESENT
         AGO   .T15P
.T14PEQ  ANOP
&T14     SETB  1                   REF= PRESENT,
&T14A    SETA  &T10A
&T14EQ   SETB  1                   EQUAL SIGN PRESENT
         AGO   .T15P
.T13P    ANOP
&T14     SETB  1                   SER, REF USE SAME T10A PTR
&T14A    SETA  &T10A+1
.T15P    AIF   (NOT &BUNIT).T18P   NOT UNIT SPECIFIED
&T15     SETB  ('&UNIT(1)' NE '')
&T16     SETB  ('&UNIT(2)' NE '' AND '&UNIT(2)' NE 'P')
         AIF   (NOT &T16).T17P
&T16A    SETA  &UNIT(2)            UNIT COUNT
.T17P    ANOP
&T17     SETB  ('&UNIT(2)' EQ 'P') PARALLEL MOUNT
.*
.*       PROCESS SYSOUT SPECIFICATIONS
.*
.T18P    AIF   (NOT &BSYSOUT).T1BP IF NO SYSOUT, BY-PASS PROCESS
&T18     SETB  ('&SYSOUT(1)' NE '')
&T19     SETB  ('&SYSOUT(2)' NE '')
&T1A     SETB  ('&SYSOUT(3)' NE '')
.T1BP    AIF   (NOT &BOUTLIM).T1CP
&T1B     SETB  1
&T1BA    SETA  &OUTLIM             NO INDIRECT VALUES ALLOWED (? ? )
.T1CP    ANOP
&T1C     SETB  (&BFREE AND '&FREE' EQ 'CLOSE')
&T1D     SETB  (&BCOP)
         AIF   (NOT &BCOP).T1EP
&C       SETC  '&COPIES'
&T1DA    SETA  &C+0
.*
.*       PROCESS LABEL ENTRY
.*
.T1EP    AIF   (NOT &BLABEL).T24P  BY-PASS IF NO LABEL ENTRY
&T22A    SETA  1
&T23A    SETA  1
         AIF   ('&LABEL(1)' EQ 'EXPDT').T22P
         AIF   ('&LABEL(1)' EQ 'RETPD').T23P
         ALLOC#3 &LABEL(2),(NL,SL,NSL,SUL,BLP,LTM,AL,AUL),             C
               (1,2,4,8,16,33,64,72),LABEL,TYPE#LABEL
&T1E     SETB  (&S99ARGI NE 0)
&T1EA    SETA  &S99ARGI
         AIF   ('&LABEL(3)' EQ 'EXPDT').T22P00
         AIF   ('&LABEL(3)' EQ 'RETPD').T22P00
.T21P    AIF   ('&LABEL(4)' EQ 'EXPDT').T22P00
         AIF   ('&LABEL(4)' EQ 'RETPD').T22P00
         AIF   ('&LABEL(4)' EQ '').T1FP
         ALLOC#3 &LABEL(4),(IN,OUT),(128,64),LABEL,IN#OUT
&T21     SETB  (&S99ARGI NE 0)
&T21A    SETA  &S99ARGI
.T1FP    ANOP
&T22A    SETA  1
&T23A    SETA  1
         AIF   ('&LABEL(1)' EQ 'EXPDT').T22P
         AIF   ('&LABEL(1)' EQ 'RETPD').T23P
&T1F     SETB  ('&LABEL(1)' NE '')
&T1FA    SETA  &LABEL(1)
.T22P00  ANOP
&I       SETA  N'&LABEL
&J       SETA  1
.T22P0   ANOP
&J       SETA  &J+1
         AIF   (&J GT &I).T24P
&T22A    SETA  &J
&T23A    SETA  &J
         AIF   ('&LABEL(&J)' EQ 'EXPDT').T22P
         AIF   ('&LABEL(&J)' EQ 'RETPD').T23P
         AGO   .T22P0
.T22P    ANOP
&T22     SETB  1
&T22A    SETA  &T22A+1
         AGO   .T24P
.T23P    ANOP
&T23     SETB  1
&T23A    SETA  &T23A+1
.T24P    ANOP
&T24     SETB  (&BDUMMY)
.T25P    ANOP
.T28P    ANOP
&T28     SETB  (&BTERM)
.T2CP    ANOP
&T2C     SETB  (&BDCB AND '&DCB'(1,2) NE '*.' AND '&DCB'(1,1) NE '(')
&T2DCB   SETB  (&BDCB AND '&DCB'(1,1) EQ '(')
         AIF   (&T2DCB OR NOT &T2C).T2DP
&K       SETA  K'&DCB
&I       SETA  1
.DCBL01  ANOP  , THIS LOOP DETERMINES IF DCB=BLKSIZE=80 LIKE STATED
&I       SETA  &I+1
         AIF   (&I GT &K).T2DP
         AIF   ('&DCB'(&I,1) EQ '=').T2DCBEQ
         AGO   .DCBL01
.T2DCBEQ ANOP
&T2DCB   SETB  1
&T2C     SETB  0
.T2DP    ANOP
&T2D     SETB  (&BDCB AND '&DCB'(1,2) EQ '*.')
.T55P    ANOP   ,                  NOTE: VALID FOR I, E ONLY MF'S
&T55     SETB  (&BDDNRET)
&T56     SETB  (&BDSNRET)
&T58     SETB  (&BDEST)
&T59     SETB  (&BHOLD)
&T5D     SETB  (&BVOLRET)
         AIF   ('&MFC' EQ 'E').MFTEGEN GO DO MF=E PROCESSING
.*
.*
.*     PLACE THE REQUEST BLOCK CODING ITSELF HERE
.*
.*
S99R&Q   DC    A(*+4+X'80000000')
         DC    X'1401',B'0&TXIST&MOUNT&T1C.0000,0',A(0,*+12,0,0)
.*9R&Q DC X'80',AL3(*+3),X'1401',B'00&MOUNT&T1C.0000,0',A(0,*+12,0,0)
.* BIT 0 ALLOWS USE OF CONVERTIBLE RESOURCES WHEN POSSIBLE.
.* MOUNT BIT NOT 1 ALLOWS MOUNT REQUESTS (USE OF ,,DEFER IN UNIT)
.*
.*
.*
.* DEFINE TEXT POINTERS FOR MF=L AND MF=I (IN-LINE)
.*
.P01QP   AIF   (NOT &T01).P02QP
S01P&Q   DC    A(S01T&Q)        DDNAME TO USE
.P02QP   AIF   (NOT &T02).P03QP
S02P&Q   DC    A(S02T&Q)        DSNAME TO USE
.P03QP   AIF   (NOT &T03).P04QP
S03P&Q   DC    A(S03T&Q)        MEMBER NAME
.P04QP   AIF   (NOT &T04).P05QP
S04P&Q   DC    A(S04T&Q)        DISP(1)(STATUS)
.P05QP   AIF   (NOT &T05).P06QP
S05P&Q   DC    A(S05T&Q)        DISP(2)(DISP)
.P06QP   AIF   (NOT &T06).P07QP
S06P&Q   DC    A(S06T&Q)        DISP(3) (COND DISP)
.P07QP   AIF   (NOT &T07).P08QP
S07P&Q   DC    A(S07T&Q)        SPACE=(TRK...
.P08QP   AIF   (NOT &T08).P09QP
S08P&Q   DC    A(S08T&Q)        SPACE=(CYL
.P09QP   AIF   (NOT &T09).P0AQP
S09P&Q   DC    A(S09T&Q)        SPACE=("BLKSIZE"
.P0AQP   AIF   (NOT &T0A).P0BQP
S0AP&Q   DC    A(S0AT&Q)        SPACE=(,PRIMARYQUAN
.P0BQP   AIF   (NOT &T0B).P0CQP
S0BP&Q   DC    A(S0BT&Q)        SPACE=(,,2ND QUAN
.P0CQP   AIF   (NOT &T0C).P0DQP
S0CP&Q   DC    A(S0CT&Q)        SPACE=(,,,DIR SPACE
.P0DQP   AIF   (NOT &T0D).P0EQP
S0DP&Q   DC    A(S0DT&Q)        SPACE=(,(),RLSE
.P0EQP   AIF   (NOT &T0E).P0FQP
S0EP&Q   DC    A(S0ET&Q)        ALX/MXIG/CONTIG
.P0FQP   AIF   (NOT &T0F).P10QP
S0FP&Q   DC    A(S0FT&Q)        ROUND ALLOCATION
.P10QP   AIF   (NOT &T10).P11QP
S10P&Q   DC    A(S10T&Q)        VOL=(SER,SERNR  OR SER=SERNO
.P11QP   AIF   (NOT &T11).P12QP
S11P&Q   DC    A(S11T&Q)        VOL=(PRIVATE...
.P12QP   AIF   (NOT &T12).P13QP
S12P&Q   DC    A(S12T&Q)        VOL=(,,VOLSEQ
.P13QP   AIF   (NOT &T13).P14QP
S13P&Q   DC    A(S13T&Q)        VOL=(,,,VOLCOUNT
.P14QP   AIF   (NOT &T14).P15QP
S14P&Q   DC    A(S14T&Q)        VOL=(REF,DSNAME  OR REF=DSNAME
.P15QP   AIF   (NOT &T15).P16QP
S15P&Q   DC    A(S15T&Q)        UNIT=XXX
.P16QP   AIF   (NOT &T16).P17QP
S16P&Q   DC    A(S16T&Q)        UNIT=(,COUNT
.P17QP   AIF   (NOT &T17).P18QP
S17P&Q   DC    A(S17T&Q)        UNIT=(,P "PARALLEL"
.P18QP   AIF   (NOT &T18).P19QP
S18P&Q   DC    A(S18T&Q)        SYSOUT=X
.P19QP   AIF   (NOT &T19).P1AQP
S19P&Q   DC    A(S19T&Q)        SYSOUT=(X,PROGRAM
.P1AQP   AIF   (NOT &T1A).P1BQP
S1AP&Q   DC    A(S1AT&Q)        SYSOUT=(X,X,FORMS
.P1BQP   AIF   (NOT &T1B).P1CQP
S1BP&Q   DC    A(S1BT&Q)        OUTLIM=NNN
.P1CQP   AIF   (NOT &T1C).P1DQP
S1CP&Q   DC    A(S1CT&Q)        FREE=CLOSE
.P1DQP   AIF   (NOT &T1D).P1EQP
S1DP&Q   DC    A(S1DT&Q)        COPIES
.P1EQP   AIF   (NOT &T1E).P1FQP
S1EP&Q   DC    A(S1ET&Q)        LABEL TYPE
.P1FQP   AIF   (NOT &T1F).P20QP
S1FP&Q   DC    A(S1FT&Q)        LABEL: LABEL=(NNN,
.P20QP   AIF   (NOT &T20).P21QP
S20P&Q   DC    0A(S20T&Q)       LABEL: PASSWORD PROTECTION
.P21QP   AIF   (NOT &T21).P22QP
S21P&Q   DC    A(S21T&Q)        LABEL: IN/OUT ONLY
.P22QP   AIF   (NOT &T22).P23QP
S22P&Q   DC    A(S22T&Q)        LABEL=EXPDT=NNN
.P23QP   AIF   (NOT &T23).P24QP
S23P&Q   DC    A(S23T&Q)        LABEL=RETPD=NNNN
.P24QP   AIF   (NOT &T24).P28QP
S24P&Q   DC    A(S24T&Q)        DUMMY FIRST POSITIONAL
.P28QP   AIF   (NOT &T28).P2CQP
S28P&Q   DC    A(S28T&Q)        TERM=TS
.P2CQP   AIF   (NOT &T2C).P2DQP
S2CP&Q   DC    A(S2CT&Q)        DCB=DSNAME
.P2DQP   AIF   (NOT &T2D).P52QP
S2DP&Q   DC    A(S2DT&Q)        DCB=*.DDNAME
.P52QP   AIF   (NOT &T52).P56QP
S52P&Q   DC    A(S52T&Q)        PERMALLOC=YES/NOTSPECIFIED (DEFAULT)
.P56QP   AIF   (NOT &T56).P58QP
S56P&Q   DC    A(S56T&Q)        DSNAME RETURN
.P58QP   AIF   (NOT &T58).P59QP
S58P&Q   DC    A(S58T&Q)        DEST=DESTINATION-ID
.P59QP   AIF   (NOT &T59).P5DQP
S59P&Q   DC    A(S59T&Q)        HOLD=YES FOR SYSOUT
.P5DQP   AIF   (NOT &T5D).P55QP
S5DP&Q   DC    A(S5DT&Q)        VOL SER RETURN
.P55QP   ANOP
S55P&Q   DC    A(S55T&Q.+X'80000000') POINT TO DDNAME RETURN KEY.
.*5P&Q   DC    X'80',AL3(S55T&Q)     POINT TO DDNAME RETURN KEY.
.*             THIS POINTER IS ALWAYS PRESENT, WHETHER THE USER
.*             SPECIFIED DDNRET OR NOT.
.*
.*  END OF THE POINTERS TO THE TEXT UNITS.
.*
.*
.*
.*
.*
.*  NOW, DEFINE THE TEXT UNITS THEMSELVES.
.*
.P01TQ   AIF   (NOT &T01).P02TQ
         ALLOC#7 S01T&Q,&DDN,08,&MFC,YES,C,DDN DDNAME TEXT UNIT
.P02TQ   AIF   (NOT &T02).P03TQ
         AIF   (&T02#3A EQ 3).EBOTH23 BOTH PRESENT IN ONE
         ALLOC#7 S02T&Q,&DSN,44,&MFC,YES,C,DSN
         AGO   .P03TQ
.EBOTH23 ANOP
&C       SETC  '&DSN'(1,&T02A) CANNOT BE INDIRECT
         ALLOC#7 S02T&Q,&C,44,&MFC,NO,C,DSN
&C       SETC  '&DSN'(&T02A+2,&T03A) PICK UP MBR NAME
         ALLOC#7 S03T&Q,&C,8,&MFC,NO,C,DSN,MEMBER
         AGO   .P04TQ
.P03TQ   AIF   (NOT &T03).P04TQ
         ALLOC#7 S03T&Q,&MBR,8,&MFC,YES,C,MBR
.P04TQ   AIF   (NOT &T04).P05TQ
         ALLOC#7 S04T&Q,&T04A,1,&MFC,NO,N,DISP,STATUS
.P05TQ   AIF   (NOT &T05).P06TQ
         ALLOC#7 S05T&Q,&T05A,1,&MFC,NO,N,DISP,DISPOSITION
.P06TQ   AIF   (NOT &T06).P07TQ
         ALLOC#7 S06T&Q,&T06A,1,&MFC,NO,N,DISP,CONDITIONAL#DISPOSITION
.P07TQ   AIF   (NOT &T07).P08TQ
         ALLOC#7 S07T&Q,,0,&MFC,NO,N,SPACE,TRK,TRUNC
.P08TQ   AIF   (NOT &T08).P09TQ
         ALLOC#7 S08T&Q,,0,&MFC,NO,N,SPACE,CYL,TRUNC
.P09TQ   AIF   (NOT &T09).P0ATQ
         ALLOC#7 S09T&Q,&T09A,3,&MFC,YES,N,SPACE,BLKSIZE#FORMAT
.P0ATQ   AIF   (NOT &T0A).P0BTQ
         ALLOC#7 S0AT&Q,&T0AA,3,&MFC,YES,N,SPACE,PRIMARY#QUANTITY
.P0BTQ   AIF   (NOT &T0B).P0CTQ
         ALLOC#7 S0BT&Q,&T0BA,3,&MFC,YES,N,SPACE,SECONDARY#QUANTITY
.P0CTQ   AIF   (NOT &T0C).P0DTQ
         ALLOC#7 S0CT&Q,&T0CA,3,&MFC,YES,N,SPACE,DIRECTORY#BLOCKS
.P0DTQ   AIF   (NOT &T0D).P0ETQ
         ALLOC#7 S0DT&Q,,0,&MFC,NO,N,SPACE,RLSE,TRUNC
.P0ETQ   AIF   (NOT &T0E).P0FTQ
         ALLOC#7 S0ET&Q,&T0EA,1,&MFC,NO,N,SPACE,ALX#MXIG#CONTIG
.P0FTQ   AIF   (NOT &T0F).P10TQ
         ALLOC#7 S0FT&Q,,0,&MFC,NO,N,SPACE,ROUND,TRUNC
.P10TQ   AIF   (NOT &T10).P11TQ
         AIF   (&T10EQ).P10TQEQ  EQUAL SIGN PRESENT
         ALLOC#7 S10T&Q,&VOL(&T10A),6,&MFC,YES,C,VOL,SER
         AGO   .P11TQ
.P10TQEQ ANOP
&N       SETA  K'&VOL(&T10A)-4
&C       SETC  '&VOL(&T10A)'(5,&N)
         ALLOC#7 S10T&Q,&C,6,&MFC,YES,C,VOL,SER
         AGO   .P11TQ
.P11TQ   AIF   (NOT &T11).P12TQ
         ALLOC#7 S11T&Q,,0,&MFC,NO,N,VOL,PRIVATE,TRUNC
.P12TQ   AIF   (NOT &T12).P13TQ
         ALLOC#7 S12T&Q,&T12A,2,&MFC,YES,N,VOL,SEQUENCE#NUMBER
.P13TQ   AIF   (NOT &T13).P14TQ
         ALLOC#7 S13T&Q,&T13A,1,&MFC,YES,N,VOL,VOLCOUNT
.P14TQ   AIF   (NOT &T14).P15TQ
         AIF   (&T14EQ).P14TQEQ EQUAL SIGN PRESENT
&I       SETA  K'&VOL(&T14A)
         ALLOC#7 S14T&Q,&VOL(&T14A),44,&MFC,YES,C,VOL,REF#DSNAME
         AGO   .P15TQ
.P14TQEQ ANOP
&N       SETA  K'&VOL(&T14A)-4 REF= PRESENT
&C       SETC  '&VOL(&T14A)'(5,&N) DSNAME STRING AFTER
         ALLOC#7 S14T&Q,&C,44,&MFC,YES,C,VOL,REF#DSNAME
.P15TQ   AIF   (NOT &T15).P16TQ
&I       SETA  K'&UNIT(1)
         ALLOC#7 S15T&Q,&UNIT(1),8,&MFC,YES,C,UNIT,UNITNAME
.P16TQ   AIF   (NOT &T16).P17TQ
         ALLOC#7 S16T&Q,&T16A,1,&MFC,YES,N,UNIT,UNIT#COUNT
.P17TQ   AIF   (NOT &T17).P18TQ
         ALLOC#7 S17T&Q,,0,&MFC,NO,N,UNIT,PARALLEL#MOUNT,TRUNC
.P18TQ   AIF   (NOT &T18).P19TQ
         AIF   ('&SYSOUT(1)' EQ '*').MAIN18A  NO SYSOUT CLASS GIVEN
         ALLOC#7 S18T&Q,&SYSOUT(1),1,&MFC,YES,C,SYSOUT,CLASS IF GIVEN
         AGO   .MAIN19A
.MAIN18A ANOP
         ALLOC#7 S18T&Q,,0,&MFC,NO,N,SYSOUT,DEFAULT,TRUNC
.MAIN19A ANOP
.P19TQ   AIF   (NOT &T19).P1ATQ
&I       SETA  K'&SYSOUT(2)
         ALLOC#7 S19T&Q,&SYSOUT(2),8,&MFC,YES,C,SYSOUT,PROGRAM#NAME
.P1ATQ   AIF   (NOT &T1A).P1BTQ
&I       SETA  K'&SYSOUT(3)
         ALLOC#7 S1AT&Q,&SYSOUT(3),4,&MFC,YES,C,SYSOUT,FORMNUMBER
.P1BTQ   AIF   (NOT &T1B).P1CTQ
         ALLOC#7 S1BT&Q,&T1BA,3,&MFC,YES,N,OUTLIM
.P1CTQ   AIF   (NOT &T1C).P1DTQ
         ALLOC#7 S1CT&Q,,0,&MFC,NO,N,FREE,,TRUNC
.P1DTQ   AIF   (NOT &T1D).P1ETQ
         ALLOC#7 S1DT&Q,&T1DA,1,&MFC,NO,N,COPIES,COPY#COUNT
.P1ETQ   AIF   (NOT &T1E).P1FTQ
         ALLOC#7 S1ET&Q,&T1EA,1,&MFC,NO,N,LABEL,TYPE
.P1FTQ   AIF   (NOT &T1F).P20TQ
         ALLOC#7 S1FT&Q,&T1FA,2,&MFC,YES,N,LABEL,SEQUENCE#NUMBER
.P20TQ   AIF   (NOT &T20).P21TQ
.* ALLOC#7 S20T$Q,$DDNXXXXXX,08,$MFC,YES,C,DDNXXXXX,XXXXXXX
.P21TQ   AIF   (NOT &T21).P22TQ
         ALLOC#7 S21T&Q,&T21A,1,&MFC,NO,N,LABEL,IN#OUT#OPTION
.P22TQ   AIF   (NOT &T22).P23TQ
&C       SETC  '&LABEL(&T22A)'
         ALLOC#7 S22T&Q,&C,5,&MFC,YES,C,LABEL,EXPDT
.P23TQ   AIF   (NOT &T23).P24TQ
&I       SETA  &LABEL(&T23A)
         ALLOC#7 S23T&Q,&I,2,&MFC,YES,N,LABEL,RETPD
.P24TQ   AIF   (NOT &T24).P24TQ2
S24T&Q   DC    X'00240000' DUMMY DEFINITION
.P24TQ2  ANOP
.P28TQ   AIF   (NOT &T28).P28NTQ
S28T&Q   DC    X'00280000' TERM=TS SPECIFICATION
.P28NTQ  AIF   (NOT &BDCB).MAIN52A BYPASS DCB DEFINITIONS
.P2CTQ   AIF   (&T2D).P2DTQ
         ALLOC#7 S2CT&Q,&DCB,44,&MFC,YES,C,DCB,DSNAME#REFERENCE
.P2DTQ   AIF   (NOT &T2D).P52TQ
&I       SETA  K'&DCB-2
&C       SETC  '&DCB'(3,&I)
         ALLOC#7 S2DT&Q,&C,8,&MFC,YES,C,DCB,*.DDNAME
.MAIN52A ANOP
.P52TQ   AIF   (NOT &T52).P56TQ
         ALLOC#7 S52T&Q,,0,&MFC,NO,N,PERMALLOC,,TRUNC
.P56TQ   AIF   (NOT &T56).P58TQ
         ALLOC#7 S56T&Q,XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX,  +
               44,&MFC,NO,C,DSNRET
.P58TQ   AIF   (NOT &T58).P59TQ
         ALLOC#7 S58T&Q,&DEST,8,&MFC,YES,C,DEST
.P59TQ   AIF   (NOT &T59).P5DTQ
         ALLOC#7 S59T&Q,,0,&MFC,NO,N,HOLD,,TRUNC
.P5DTQ   AIF   (NOT &T5D).P55TQ
         ALLOC#7 S5DT&Q,000000,6,&MFC,NO,C,VOLRET
.P55TQ   ANOP
S55T&Q   DC    X'0055000100084040404040404040' DDNAME RETURN
.*             RESET IS DONE IF DDN= USED TO MAKE MAX LENGTH AGAIN.
.PXXTQ   ANOP
.*
.*  END OF TEXT UNIT DEFINITIONS
.*
.*
         AIF   ('&MFC' EQ 'I').MFTIGEN
S99Z&Q   DS    0H           BY-PASS SYMBOL IF RB DEFINED IN-STREAM
         MEXIT
.*
.* DO THE IN-LINE AND EXECUTE FORMS TO SET UP INDIRECT VALUES
.*
.MFTIGEN ANOP
S99Z&Q   DS    0H           NOW USE REQUEST BLOCK
.MFTEGEN ANOP
         ALLOC#6 &DDN,S01T&Q,&T01,,C,&MFC
.*       AIF   (NOT &T01).MFT02 BY-PASS RESET OF DDN RETURN KEY
         MVC   S55T&Q+4(2),=X'0008' RESET TXT UNIT COUNT TO MAX VALUE
.MFT02   AIF   (NOT &T02).MFT03A
         AIF   (&T02#3A EQ 3).MFTBTHA BOTH PRESENT IN ONE
         ALLOC#6 &DSN,S02T&Q,&T02,,C,&MFC
         AGO   .MFT03A
.MFTBTHA ANOP
&C       SETC  '&DSN'(1,&T02A) CANNOT BE INDIRECT
         ALLOC#6 &C,S02T&Q,&T02,,C,&MFC
&C       SETC  '&DSN'(&T02A+2,&T03A) PICK UP MBR NAME
         ALLOC#6 &C,S03T&Q,&T03,,C,&MFC
         AGO   .MFT04
.MFT03A  ANOP
         ALLOC#6 &MBR,S03T&Q,&T03,,C,&MFC
.MFT04   ANOP
         ALLOC#6 &T04A,S04T&Q,&T04,1,N,&MFC NOT ALLOWED INDIRECT
         ALLOC#6 &T05A,S05T&Q,&T05,1,N,&MFC NOT ALLOWED INDIRECT
         ALLOC#6 &T06A,S06T&Q,&T06,1,N,&MFC NOT ALLOWED INDIRECT
         AIF   (NOT &BSPACE).MFT10  BQH 811125
         AIF   ('&SPACE(1)' NE 'TRK').MFT08
         AIF   ('&MFC' NE 'E').MFT08
         LA    14,S07T&Q           MOVE THE ADDRESS TO POINTER
         ST    14,S07P&Q
         MVC   S07T&Q.(4),=X'00070000'
         MNOTE 4,'TRK DATA MAY OVLY OTHER SPACE DATA, S07T&Q'
.MFT08   AIF   ('&SPACE(1)' NE 'CYL').MFT09
         AIF   ('&MFC' NE 'E').MFT09
         LA    14,S08T&Q           MOVE THE ADDRESS TO POINTER
         ST    14,S08P&Q
         MVC   S08T&Q.(4),=X'00080000'
         MNOTE 4,'CYL DATA MAY OVLY OTHER SPACE DATA, S08T&Q'
.MFT09   AIF   ('&SPACE(1)' EQ 'CYL' OR '&SPACE(1)' EQ 'TRK').MFT0A
         ALLOC#6 &SPACE(1),S09T&Q,&T09,3,N,&MFC
.MFT0A   ANOP
         ALLOC#SX &SPACE(2),1
         ALLOC#6 &S99SP2X,S0AT&Q,&T0A,3,N,&MFC
.*       ALLOC#6 &SPACE(2,1),S0AT&Q,&T0A,3,N,&MFC
         ALLOC#SX &SPACE(2),2
         ALLOC#6 &S99SP2X,S0BT&Q,&T0B,3,N,&MFC
.*       ALLOC#6 &SPACE(2,2),S0BT&Q,&T0B,3,N,&MFC
         ALLOC#SX &SPACE(2),3
         ALLOC#6 &S99SP2X,S0CT&Q,&T0C,3,N,&MFC
.*       ALLOC#6 &SPACE(2,3),S0CT&Q,&T0C,3,N,&MFC
         AIF   ('&MFC' EQ 'I').MFT10
         AIF   ('&SPACE(3)' NE 'RLSE').MFT0E
         LA    14,S0DT&Q           MOVE THE ADDRESS TO POINTER
         ST    14,S0DP&Q
         MVC   S0DT&Q.(4),=X'000D0000'
         MNOTE 4,'RLSE SPECIFICATION MAY OVLY DATA, S0DT&Q'
.MFT0E   AIF   ('&SPACE(4)' EQ '').MFT0F
         ALLOC#3 &SPACE(4),(ALX,MXIG,CONTIG),(2,4,8),SPACE,            C
               ALX#MXIG#CONTIG
         AIF   (&S99ARGI EQ 0).MFT0F
         LA    14,S0ET&Q           MOVE THE ADDRESS TO POINTER
         ST    14,S0EP&Q
         MVC   S0ET&Q.(6),=X'000E00010001'
         MVI   S0ET&Q+6,&S99ARGI
.MFT0F   AIF   ('&SPACE(5)' NE 'ROUND').MFT10
         LA    14,S0FT&Q           MOVE THE ADDRESS TO POINTER
         ST    14,S0FP&Q
         MVC   S0FT&Q.(4),=X'000F0000'
.MFT10   AIF   (NOT &BVOL).MFT10NO
         AIF   (&T10EQ).MFT10EQ MUST PROCESS EQUAL SIGN
         AIF   (NOT &T10).MFT14
         ALLOC#6 &VOL(&T10A),S10T&Q,&T10,,C,&MFC
         AGO   .MFT10NO
.MFT14   AIF   (&T14EQ).MFT14EQ MUST PROCES EQUAL SIGN
         AIF   (NOT &T14).MFT10NO
         ALLOC#6 &VOL(&T14A),S14T&Q,&T14,,C,&MFC
         AGO   .MFT10NO
.MFT14EQ ANOP
&N       SETA  K'&VOL(&T14A)-4 SER= GIVEN
&C       SETC  '&VOL(&T14A)'(5,&N) SUBSTRING OF SER NUMBER
         ALLOC#6 &C,S14T&Q,&T14,,C,&MFC
         AGO   .MFT10NO
.MFT10EQ ANOP
&N       SETA  K'&VOL(&T10A)-4 SER= GIVEN
&C       SETC  '&VOL(&T10A)'(5,&N) SUBSTRING OF SER NUMBER
         ALLOC#6 &C,S10T&Q,&T10,,C,&MFC
         AGO   .MFT10NO
.MFT10NO AIF   ('&MFC' EQ 'I' OR NOT &T11).MFT11
         LA    14,S11T&Q           MOVE THE ADDRESS TO POINTER
         ST    14,S11P&Q
         MVC   S11T&Q,=X'00110000'
.MFT11   ALLOC#6 &UNIT(1),S15T&Q,&T15,,C,&MFC
         ALLOC#6 &SYSOUT(1),S18T&Q,&T18,,C,&MFC
         ALLOC#6 &SYSOUT(2),S19T&Q,&T19,,C,&MFC
         ALLOC#6 &SYSOUT(3),S1AT&Q,&T1A,,C,&MFC
         ALLOC#6 &OUTLIM,S1BT&Q,&T1B,3,N,&MFC
.MFT22   ANOP
         AIF   (&T22A LT 2).MFT22BP
         ALLOC#6 &LABEL(&T22A),S22T&Q,&T22,,C,&MFC
         AGO   .MFT23BP
.MFT22BP AIF   (&T23A LT 2).MFT23BP
         ALLOC#6 &LABEL(&T23A),S23T&Q,&T23,2,N,&MFC
.MFT23BP AIF     (&T2D).MFT2D
         ALLOC#6 &DCB,S2CT&Q,&T2C,,C,&MFC
         AGO      .MFT2E
.MFT2D   ANOP
&I       SETA     K'&DCB-2
&C       SETC     '&DCB'(3,&I) REFERENCE TO DDNAME
         ALLOC#6  &C,S2DT&Q,&T2D,,C,&MFC
.MFT2E   ANOP
.MFT58   ALLOC#6 &DEST,S58T&Q,&T58,,C,&MFC  DEST=
.*
.* GENERATE CODING TO PICK UP THE RETURNED ITEMS FROM DYNALLOC
.*
         LA    1,S99R&Q       GET THE @ OF THE REQUEST BLOCK POINTER
         SVC   99             ISSUE DYNAMIC ALLOCATION REQUEST
         L     0,S99R&Q+8     PICK UP THE 2 HALFWORD ERROR CODES
         AIF   (NOT &T56).MFTIM5D
         ALLOC#0 &DSNRET
         ALLOC#4 S56T&Q,&DSNRET
.MFTIM5D AIF   (NOT &T5D).MFTIM55
         ALLOC#0 &VOLRET
         ALLOC#4 S5DT&Q,&VOLRET
.MFTIM55 AIF   (NOT &T55).MFTIMXX
         ALLOC#0 &DDNRET
         ALLOC#4 S55T&Q,&DDNRET
.MFTIMXX MEXIT
         MEND
./ ADD NAME=ALLOC#AN
         MACRO
         ALLOC#AN &DCB,&OP,&TYPE
         GBLA  &S99DCB#(40),&S99DCBV(40)
         GBLC  &S99DCB$(40),&S99DCB@(40)
         LCLA  &KEEP,&I,&K,&L
         LCLC  &C
.* THIS MACRO CONVERTS THE NUMERIC FIELDS TO VALUES IN DCBV TABLE.
         ALLOC#8E &OP,&TYPE FIND SUBSCRIPT IF USED.
         AIF   (&S99ARGI EQ 0).EXIT
&KEEP    SETA  &S99ARGI KEEP # OF TABLE ENTRY
&I       SETA  &S99DCB#(&KEEP) PICK UP # OF SUBFLD
&K       SETA  K'&S99DCB@(&KEEP)+2 LENGTH OF FIELD
.* ALSO STARTING CHARACTER NUMBER FOR FIELD VALUE
&L       SETA  K'&DCB(&I)-&K+1 NUMBER OF CHARACTERS IN CODED VALUE
&C       SETC  '&DCB(&I)'(&K,&L) PICK UP VALUE AFTER KEYWORD=
&S99DCBV(&KEEP) SETA &C CONVERT THIS VALUE TO NUMERIC IN DCBV TABLE
.EXIT    MEND
./ ADD NAME=ALLOC#A3
         MACRO
         ALLOC#A3 &DCB,&OP,&TYPE,&VALIST,&CODELST,&MFC
.* THIS MACRO VERIFIES THE CODING OF AN ENTRY WHICH HAS A CODE LIST.
.* IF ERROR IN CODING, IT ERASES THE PRESENCE OF THE ITEM BY
.* ZEROING S99DCB# ENTRY IN TABLE, PRODUCING UNDEFINED SYMBOL ERROR.
         GBLA  &S99ARGI,&S99DCB#(40),&S99DCBV(40)
         GBLC  &S99DCB$(40),&S99DCB@(40)
         LCLA  &K,&KEEP,&I,&L
         LCLC  &C,&C1,&C2,&C3
         ALLOC#8E &OP,&TYPE FIND THE SUBSCRIPT
         AIF   (&S99ARGI EQ 0).EXIT NOT PRESENT
&KEEP    SETA  &S99ARGI KEEP NOTE OF SUBSCRIPT
&K       SETA  K'&S99DCB@(&KEEP)+1 LENGTH KEYWORD PLUS =
&I       SETA  &S99DCB#(&KEEP) NTH SUBFLD
&L       SETA  K'&DCB(&I)-&K
&C       SETC  '&DCB(&I)'(&K,&L) PICK UP CHAR STRING
&C3      SETC  '&S99DCB@(&KEEP)'
&C2      SETC  '&S99DCB$(&KEEP)'(3,1) TYPE C/N/D
&C1      SETC  '&S99DCB$(&KEEP)'(4,1) INDIRECT/DIRECT I/D
         AIF   ('&C1' NE 'I').NOI
&C1      SETC  'YES' IS INDIRECT
.NOI     ALLOC#1 &C,&MFC,&C1,&C2,DCB,&C3 SPEC OUT TYPE
         AIF   (&S99ARGI NE 0).INDRCT WAS NOT CODED DIRECT
         ALLOC#3 &C,&VALIST,&CODELST,DCB,&S99DCB@(&KEEP)
         AIF   (&S99ARGI EQ 0).ERROR
.EXIT    MEXIT
.ERROR   ANOP
&S99DCB#(&KEEP) SETA 0 ERASE ENTRY IN ERROR
         MEXIT
.INDRCT  ANOP
&S99DCBV(&KEEP) SETA -1 FLAG AS CHAR/INDIRECT DATA
         MEND
./ ADD NAME=ALLOC#SX
         MACRO
         ALLOC#SX
         GBLA  &S99SP2X             USED TO RETURN NUMERIC VALUE
.*                                  TO ALLOC MAIN MACRO AT .T0AP
         LCLA  &I,&J,&K,&WANT
         LCLC  &C,&S,&N
         LCLB  &SW1
&N       SETC  '0'
&WANT    SETA  &SYSLIST(2)
&C       SETC  '&SYSLIST(1)'
&K       SETA  K'&SYSLIST(1) GET LENGTH OF STRING
         AIF   ('&C'(1,1) EQ '(').MULTI
&N       SETC  '&C'(1,&K)
         AGO   .RPAREN
         MEXIT
.MULTI   ANOP
&J       SETA  1
.LOOP    ANOP
         AIF   (&K LT 1).ZEROK
         AIF   ('&C'(1,1) EQ '(').LPAREN
         AIF   ('&C'(1,1) EQ ',').COMMA
         AIF   ('&C'(1,1) EQ ')').RPAREN
         AIF   (NOT &SW1).BYPN SW1=1 MEANS GATHER STRING NOW
&N       SETC  '&N'.'&C'(1,1)
.BYPN    ANOP
&K       SETA  K'&C-1
&C       SETC  '&C'(2,&K)
         AGO   .LOOP
.LPAREN  ANOP
&J       SETA  1 THIS IS THE NUMBER OF THE FIELD THAT IS PROCESSING.
&K       SETA  K'&C-1
&C       SETC  '&C'(2,&K) STRIP OFF LPAREN
&SW1     SETB  (&J EQ &WANT)
         AGO   .LOOP
.COMMA   ANOP
&J       SETA  &J+1
         AIF   (&J GT &WANT).DONEJ
&SW1     SETB  (&J EQ &WANT)
&K       SETA  K'&C-1
         AIF   (&K LT 1).ZEROK
&C       SETC  '&C'(2,&K)
         AGO   .LOOP
.DONEJ   ANOP
.RPAREN  ANOP
.ZEROK   ANOP
&S99SP2X SETA  &N
         MEND
./ ADD NAME=ALLOC#0
         MACRO
         ALLOC#0 &OPERND,&DSNFLG
         GBLA  &S99ARGI
         LCLA  &I,&J
&S99ARGI SETA  0
         AIF   ('&OPERND' EQ '').EXIT NULL OPERAND
         AIF   ('&OPERND'(1,1) EQ '(' AND '&OPERND(1)' EQ '*').INDIRCT
         AIF   ('&OPERND'(1,1) EQ '(').REG
&I       SETA  K'&OPERND
         AIF   ('&OPERND'(&I,1) EQ ')').RX
         AIF   ('&OPERND'(1,1) EQ '''').APOST MUST BE VOL SER?
.EXIT    MEXIT
.INDIRCT ANOP
&S99ARGI SETA  1
         MEXIT
.REG     ANOP
         AIF   ('&OPERND'(1,3) EQ '(*,').INDIRCT
&S99ARGI SETA  2
         MEXIT
.RX      AIF   ('&DSNFLG' EQ 'DSN').DSN
.RX2     ANOP
&S99ARGI SETA  3
         MEXIT
.APOST   ANOP
&S99ARGI SETA  4  FOR APOSTROPHE DELIMITERS
         MEXIT
.DSN     ANOP
&J       SETA  0
.DSNL    ANOP
&J       SETA  &J+1
         AIF   (&J GT &I).RX2
         AIF   ('&OPERND'(&J,1) NE '.').DSNL
&S99ARGI SETA  5  FOR DSNAME FIELD DETECTED
         MEND
./ ADD NAME=ALLOC#0A
         MACRO
         ALLOC#0A &KEY,&NUM,&LENGTH,&USED,&Q
.* THIS MACRO IS USED BY THE SVC99RET MACRO TO RESET THE TEXT UNIT
.* FIELDS FOR MF=E
.* KEY IS THE VALUE OF THE TEXT UNIT KEY FIELD IN HEX
.* NUM IS THE NUMBER OF PARAMETERS (ALL "1" FOR SVC99RET)
.* LENGTH IS THE MAX LENGTH FOR THE FIELD
.* USED IS A 0/1 FLAG (LCLB IN SVC99RET) TO BY-PASS OPERATION
         AIF   ('&USED' EQ '0').EXIT
.* Q IS THE SUFFIX FOR THE RB
         MVC   S&KEY.T&Q+2(4),=AL2(&NUM,&LENGTH) RESET TO MAX SIZE
.EXIT    MEND
./ ADD NAME=ALLOC#1
         MACRO
         ALLOC#1 &OP,&MF,&INDIRCT,&TYPE,&FLD,&SUBFLD
.*   THIS MACRO IS USED TO REPORT ERRORS IN TYPE OF EXPRESSIONS FOR
.*   DIFFERENT OPERANDS.  IT IS CALLED FOR EACH OPERAND AND REPORTS
.*   TO THE USER IF THE OPERAND WAS CODED INCORRECTLY.  FOR EXAMPLE,
.*   THE DISP= OPERAND IS NOT ALLOWED TO BE CODED WITH AN INDIRECT
.*   EXPRESSION, SO SPECIFYING DISP=(*,DSP) WILL RESULT IN AN ERROR
.*   MESSAGE BY MNOTE, LVL 8 IN ALL CASES.
         GBLA  &S99ARGI
         LCLC  &C
         LCLA  &I,&K
         AIF   ('&FLD' NE 'DSN').GO00
&C       SETC  'DSN' ERROR-CHECK FOR DSN(MBR) LATER.
.GO00    ALLOC#0 &OP,&C SEE IF OP IS INDIRECT
         AIF   (&S99ARGI EQ 5).END DSN(MBR) COMBINATION PRESENT
         AIF   (&S99ARGI NE 0 AND '&INDIRCT' NE 'YES').ERR1
         AIF   (&S99ARGI NE 0 AND '&MF' EQ 'L').ERR2
         AIF   ('&TYPE' NE 'N').END         SCAN FOR ALL NUMERICS
         AIF   (&S99ARGI NE 0).END          CANNOT SCAN INDIRECT
&K       SETA  K'&OP                        PREPARE TO SCAN OPERAND
.NUMLOOP ANOP
&I       SETA  &I+1
         AIF   (&I GT &K).END
         AIF   ('&OP'(&I,1) GE '0' AND '&OP'(&I,1) LE '9').NUMLOOP
         AIF   ('&SUBFLD' NE '').NSUBF
 MNOTE 8,'&FLD OPERAND, CHAR #&I OF ''&OP'' IS NOT REQUIRED NUMERIC VALU
               UE'
         MEXIT
.NSUBF   ANOP
 MNOTE 8,'&FLD OPERAND, &SUBFLD SUBFIELD, CHAR #&I OF ''&OP'' IS NOT REQ
               QUIRED NUMERIC VALUE.'
         MEXIT
.ERR1    AIF   ('&SUBFLD' NE '').ERR1S
 MNOTE 8,'&FLD IS NOT ALLOWED INDIRECT: ''&FLD=&OP'' IS INVALID.'
         MEXIT
.ERR1S   ANOP
 MNOTE 8,'&SUBFLD SUBFIELD OF &FLD OPERAND IS NOT ALLOWED INDIRECT: ''&O
               OP'' IS INVALID.'
         MEXIT
.ERR2    ANOP
 MNOTE 8,'MF=L DOES NOT ALLOW ANY FORM OF INDIRECT SPECIFICATION.'
         AGO   .ERR1
.END     MEND
./ ADD NAME=ALLOC#2
         MACRO
         ALLOC#2 &TXTU,&OPERND
         GBLA  &S99ARGI
         LCLA  &K
         LCLC  &C
         AIF   (&S99ARGI EQ 1).INDIRCT
         AIF   (&S99ARGI EQ 2).REG
         AIF   (&S99ARGI EQ 3).RX
         MEXIT
.INDIRCT SR    15,15
&K       SETA  K'&OPERND-4
&C       SETC  '&OPERND'(4,&K)
         ICM   15,3,&C             GET THE LENGTH OF THE ITEM
         LA    15,1(15)            ACCT FOR LENGTH FIELD ALSO
         MVC   &TXTU+4(*-*),&C           MOVE CNT AND ITEM
         EX    15,*-6
         MEXIT
.REG     SR    15,15
         ICM   15,3,0&OPERND
         LA    15,1(15)            ACCT FOR LENGTH FIELD ALSO
         MVC   &TXTU+4(*-*),2&OPERND
         EX    15,*-6
         MEXIT
.RX      LA    14,&OPERND
         SR    15,15
         ICM   15,3,0(14)
         LA    15,1(15)            ACCT FOR LENGTH FIELD ALSO
         MVC   &TXTU+4(*-*),2(14)
         EX    15,*-6
         MEND
./ ADD NAME=ALLOC#3
         MACRO
         ALLOC#3 &OP,&VALIST,&CODELST,&FLD,&SUBFLD
.* THIS MACRO IS USED TO SEARCH AN OPERAND SUBLIST FOR A VALUE
.* THAT MATCHES ONE OF A LIST OF VALUES INPUT TO THE MATCH.
         GBLA  &S99ARGI
         LCLA  &I,&J
         LCLC  &C(8)
&S99ARGI SETA  0
         AIF   ('&OP' EQ '').NOOP  OPERAND IS NULL
&J       SETA  N'&VALIST
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &J).SPACE
         AIF   ('&OP' NE '&VALIST(&I)').LOOP
&S99ARGI SETA  &CODELST(&I)
         MEXIT
.SPACE   AIF   ('&FLD' EQ 'SPACE').NOOP COULD BE BLKSIZE
.ERROR   MNOTE 8,'&FLD &SUBFLD INVALID ENTRY'
&I       SETA  0
.ELUP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &J).ELUPX
&C(&I)   SETC  '&VALIST(&I)'
         AGO   .ELUP
.ELUPX   ANOP
 MNOTE '&FLD &SUBFLD VALID CODES: &C(1) &C(2) &C(3) &C(4) &C(5) &C(6)'
.NOOP    MEND
./ ADD NAME=ALLOC#4
         MACRO
         ALLOC#4 &TXTU,&OPERND,&FLDNAME
.* THIS MACRO IS USED TO RETURN ITEMS FROM THE RETURN-LIST
.* FROM DYNAMIC ALLOCAT, SUCH AS THE DSNRET, DDNRET, VOLRET
         GBLA   &S99ARGI
         LCLA   &I
         LCLC   &C
         AIF    (&S99ARGI EQ 0).DIRECT
         AIF    (&S99ARGI EQ 2).REG
         AIF    (&S99ARGI EQ 3).RX
         MNOTE  8,'&FLDNAME=&OPERND INVALID. A-TYPE, (R) OR RX-TYPE'
         MEXIT
.DIRECT  SR    14,14
         ICM   14,3,&TXTU+4         PICK UP THE LENGTH OF THE ITEM
         LA    14,1(14)             ACCT FOR LENGTH IN MOVING
         MVC   &OPERND.(*-*),&TXTU+4        MOVE LENGTH AND ITEM
         EX    14,*-6
         MEXIT
.REG     SR    14,14
&I       SETA  K'&OPERND-2
&C       SETC  '&OPERND'(2,&I)
         ICM   14,3,&TXTU+4 PICK UP LENGTH
         LA    14,1(14)             ACCT FOR LENGTH IN MOVING
         MVC   0(*-*,&C),&TXTU+4
         EX    14,*-6 MOVE THE VALUE RETURNED
         MEXIT
.RX      SR    14,14
         LA    1,&OPERND
         ICM   14,3,&TXTU+4 PICK UP THE LENGTH OF THE ITEM
         LA    14,1(14)             ACCT FOR LENGTH IN MOVING
         MVC   0(*-*,1),&TXTU+4          MOVE LENGTH AND ITEM
         EX    14,*-6 MOVE THE VALUE RETURNED
         MEND
./ ADD NAME=ALLOC#5
         MACRO
         ALLOC#5 &OPERND,&TXTU,&TFLG,&LENG,&TYPE,&MFC
         GBLA  &S99ARGI
         LCLA  &I
         LCLC  &C
         AIF   ('&TFLG' EQ '0').END
         AIF   ('&MFC' NE 'E').END
         AIF   (&S99ARGI NE 0).END
&I       SETA  K'&OPERND
         AIF   ('&LENG' EQ '').BYP1
&I       SETA  &LENG
.BYP1    MVC   &TXTU+4(2),=AL2(&I)               MOVE IN LENGTH
         AIF   ('&TYPE' EQ 'N').NUMBER
         MVC   &TXTU+6(&I),=C'&OPERND'           MOVE IN VALUE
         MEXIT
.NUMBER  MVC   &TXTU+6(&I),=AL&I.(&OPERND)       MOVE IN VALUE
.END     MEND
./ ADD NAME=ALLOC#6
         MACRO
         ALLOC#6 &OPERND,&TXTU,&TFLG,&LENG,&TYPE,&MFC
         GBLA  &S99ARGI
         ALLOC#0 &OPERND
         AIF   (&S99ARGI EQ 0).Z
         ALLOC#2 &TXTU,&OPERND
.END     MEXIT
.Z       AIF   ('&MFC' EQ 'I').END
         ALLOC#5 &OPERND,&TXTU,&TFLG,&LENG,&TYPE,&MFC
         MEND
./ ADD NAME=ALLOC#7
         MACRO
         ALLOC#7 &TU,&OP,&MAXL,&MF,&IND,&TYPE,&FLD,&SUBFLD,&TRUNC
.*   THIS MACRO IS USED TO GENERATE THE DC CONSTANTS FOR ALL FORMS
.* OF MF=.  IN THE MF=L OR MF=I, SPACE IS SET ASIDE IN A PARTICULAR
.* TEXT UNIT DEFINITION FOR THE MAXIMUM SIZE FIELD IF THE FIELD SIZE
.* IS VARIABLE, SUCH AS IN DSNAME.  THE LENGTH ASSEMBLED FOR THE
.* CURRENT VALUE IS ASSOCIATED WITH THE TEXT UNIT LABEL, BUT AN
.* ADDITIONAL 'NULL' SPACE IS CREATED FOLLOWING THE TEXT UNIT TO
.* ALLOW FOR MF=E REFERENCE TO THE TEXT UNIT.
         GBLA  &S99ARGI
         LCLA  &I,&IMX,&REM
         LCLC  &CML,&CMLX,&CT,&CNULL,&CLP,&CRP,&CTX
&I       SETA  K'&OP
         AIF   ('&TYPE' EQ 'C').T2
&CT      SETC  'A'                 THIS IS NUMERIC DATA
&CNULL   SETC  '*-*'               MEANING VARIABLE OF ZERO
&CLP     SETC  '('                 LEFT DELIMITER
&CRP     SETC  ')'                 RIGHT DELIMITER
&I       SETA  &MAXL
         AGO   .T2X
.T2      ANOP
&CT      SETC  'C'
&CNULL   SETC  ' '
&CLP     SETC  ''''
&CRP     SETC  ''''
.T2X     ANOP
&CML     SETC  '&I'                NO PADDING NEEDED ON LEFT
&IMX     SETA  &MAXL
&CMLX    SETC  '&IMX'
         AIF   ('&MAXL' EQ '').NOMAXL
&REM     SETA  &MAXL-&I
.NOMAXL  ANOP
&CTX     SETC  '&TU'(2,2)          PICK UP SYSNDX VALUE
         ALLOC#1 &OP,&MF,&IND,&TYPE,&FLD,&SUBFLD
         AIF   ('&TRUNC' NE '').MFTRUNC
         AIF   ('&MF' NE 'L').MFIORE
         AIF   (&S99ARGI EQ 0).MFLNORM
&TU      DC    X'00&CTX.0001',AL2(&CMLX),&CT.L&CMLX&CLP&CNULL&CRP
         MEXIT
.MFLNORM ANOP
&TU      DC    X'00&CTX.0001',AL2(&CML),&CT.L&CML&CLP&OP&CRP,&REM&CT.L1X
               &CLP&CNULL&CRP
         MEXIT
.MFIORE  ANOP
         AIF   ('&MF' EQ 'E').END  WE WILL DEAL WITH THIS LATER.
         AIF   (&S99ARGI NE 0).MFINULL PLACE NULL VALUE FOR NOW
&TU      DC    X'00&CTX.0001',AL2(&CML),&CT.L&CML&CLP&OP&CRP,&REM&CT.L1X
               &CLP&CNULL&CRP
         MEXIT
.MFINULL ANOP
&TU      DC    X'00&CTX.0001',AL2(&CMLX),&CT.L&CMLX&CLP&CNULL&CRP
         MEXIT
.MFTRUNC ANOP
&TU      DC    X'00&CTX.0000'
.END     MEND
./ ADD NAME=ALLOC#8
         MACRO
         ALLOC#8 &DCB
         GBLA  &S99DCB#(40),&S99DCBV(40)
         GBLC  &S99DCB$(40),&S99DCB@(40)
.* THE GLOBAL TABLES:
.* THERE IS ONE ENTRY FOR EACH DCB KEY.  THE KEY VALUES GO FROM 2E THRU
.* 5B (WITH SOME OMISSIONS).  THE SUBSCRIPTS CORRESPOND TO THE RELATIVE
.* POSITION OF THE KEYS.
.* THE DCB# TABLE CONTAINS THE SUBOPERAND NUMBER WITHIN THE DCB OPERAND
.* OF THE KEY CHARACTER-STRING FIELD (SUCH AS "RECFM").
.* THE DCBV TABLE WILL CONTAIN THE ENCODED INTERNAL REPRESENTATION OF
.* THE VALUE ENTERED AFTER THE EQUAL SIGN FOR ALL KEYS (EXCEPT DIAGNS).
.* THE DCB$ TABLE CONTAINS THE HEX KEYS AND A FLAG STRING (DESCRIBED
.* BELOW).
.* THE DCB@ TABLE CONTAINS THE TEXT CHARACTER STRING WHICH IS USED IN
.* THE USER'S CODING OF THE MACRO ("RECFM" FOR EXAMPLE).
.* IF A PARTICULAR KEY IS NOT USED, THEN DCB# WILL HAVE A ZERO IN THAT
.* TABLE ENTRY.  THE DCB# TABLE ENTRY IS ALSO ZEROED WHEN A SYNTAX
.* ERROR HAS BEEN DETECTED IN PROCESSING OF THE PARAMETER.
.*
.* THE FLAG STRING:
.* CHARS 1-2:  HEX KEY VALUE
.*         3:  C/N/D: CHAR DATA, NUMERIC DATA, DECODED DATA
.*             FOR THE MOST PART, THE DECODED DATA CANNOT BE SPECIFIED
.*             AS INDIRECT FIELDS.
.*
.*         4:  I/D: INDIRECT PERMITTED, DIRECT ONLY
.*       5-6:  MAXIMUM LENGTH OF INTERNAL TEXT UNIT FIELD.
.*         7:  S/N: SPECIAL PROCESSING FLAG.
.*
&S99DCB$(01) SETC '2CCI44N'
&S99DCB@(01) SETC '**'
&S99DCB$(02) SETC '2DCI08N'
&S99DCB@(02) SETC '*.'
&S99DCB$(03) SETC '2EDD01N'
&S99DCB@(03) SETC 'BFALN'
&S99DCB$(04) SETC '2FDD01N'
&S99DCB@(04) SETC 'BFTEK'
&S99DCB$(05) SETC '30NI02N'
&S99DCB@(05) SETC 'BLKSIZE'
&S99DCB$(06) SETC '31NI01N'
&S99DCB@(06) SETC 'BUFIN'
&S99DCB$(07) SETC '32NI02N'
&S99DCB@(07) SETC 'BUFL'
&S99DCB$(08) SETC '33NI01N'
&S99DCB@(08) SETC 'BUFMAX'
&S99DCB$(09) SETC '34NI01N'
&S99DCB@(09) SETC 'BUFNO'
&S99DCB$(10) SETC '35DD01N'
&S99DCB@(10) SETC 'BUFFOFF'
&S99DCB$(11) SETC '36NI01N'
&S99DCB@(11) SETC 'BUFOUT'
&S99DCB$(12) SETC '37NI01N'
&S99DCB@(12) SETC 'BUFRQ'
&S99DCB$(13) SETC '38NI02N'
&S99DCB@(13) SETC 'BUFSZ'
&S99DCB$(14) SETC '39DD01N'
&S99DCB@(14) SETC 'CODE'
&S99DCB$(15) SETC '3ADD01N'
&S99DCB@(15) SETC 'CPRI'
&S99DCB$(16) SETC '3BDD01N'
&S99DCB@(16) SETC 'DEN'
&S99DCB$(17) SETC '3CDD02N'
&S99DCB@(17) SETC 'DSORG'
&S99DCB$(18) SETC '3DDD01N'
&S99DCB@(18) SETC 'EROPT'
&S99DCB$(19) SETC '3ENI01N'
&S99DCB@(19) SETC 'GNCP'
&S99DCB$(20) SETC '3FNI01N'
&S99DCB@(20) SETC 'INTVL'
&S99DCB$(21) SETC '40NI01N'
&S99DCB@(21) SETC 'KEYLEN'
&S99DCB$(22) SETC '41NI03N'
&S99DCB@(22) SETC 'LIMCT'
&S99DCB$(23) SETC '42NI02N'
&S99DCB@(23) SETC 'LRECL'
&S99DCB$(24) SETC '43DD01N'
&S99DCB@(24) SETC 'MODE'
&S99DCB$(25) SETC '44NI01N'
&S99DCB@(25) SETC 'NCP'
&S99DCB$(26) SETC '45DD01N'
&S99DCB@(26) SETC 'OPTCD'
&S99DCB$(27) SETC '46DD01N'
&S99DCB@(27) SETC 'PCI'       RECEIVING
&S99DCB$(28) SETC '47DD01N'
&S99DCB@(28) SETC 'PCI'       SENDING
&S99DCB$(29) SETC '48DD01N'
&S99DCB@(29) SETC 'PRTSP'
&S99DCB$(30) SETC '49DD01N'
&S99DCB@(30) SETC 'RECFM'
&S99DCB$(31) SETC '4ANI01N'
&S99DCB@(31) SETC 'RESERVE'
&S99DCB$(32) SETC '4BNI01N'
&S99DCB@(32) SETC 'RESERVE'
&S99DCB$(33) SETC '4CNI02N'
&S99DCB@(33) SETC 'SOWA'
&S99DCB$(34) SETC '4DDD01N'
&S99DCB@(34) SETC 'STACK'
&S99DCB$(35) SETC '4ENI01N'
&S99DCB@(35) SETC 'THRESH'
&S99DCB$(36) SETC '4FDD01N'
&S99DCB@(36) SETC 'TRTCH'
&S99DCB$(37) SETC '51CI03N'
&S99DCB@(37) SETC 'IPLTXTID'
&S99DCB$(38) SETC '54DD00N'
&S99DCB@(38) SETC 'DIAGNS'
&S99DCB$(39) SETC '5ADD01N'
&S99DCB@(39) SETC 'FUNC'
&S99DCB$(40) SETC '5BCI04N'
&S99DCB@(40) SETC 'FRID'
&N       SETA  N'&DCB              OBTAIN THE NUMBER OF SUBFIELDS
&IMAX    SETA  40                  MAX NUMBER OF KEYS POSSIBLE
.LOOP0   ANOP
&I       SETA  &I+1
         AIF   (&I GT &IMAX).ELOOP0
&S99DCB#(&I) SETA 0                RESET ALL TABLE TO ZERO
&S99DCBV(&I) SETA 0                RESET ALL TABLE TO ZERO
         AGO   .LOOP0
.ELOOP0  ANOP
&I       SETA  0                   TABS THRU SUBFLDS
.LOOP1   ANOP
&I       SETA  &I+1                USED TO TAB THRU DCB SUBFLDS
         AIF   (&I GT &N).ENDFLDS
&K       SETA  K'&DCB(&I)          GET LENGTH OF SUBFLD
&J       SETA  0
.LOOP2   ANOP
&J       SETA  &J+1                USED TO ADDRESS TABLES
         AIF   (&J GT &IMAX).CHK1
&L       SETA  K'&S99DCB@(&J)      LENGTH OF ENTRY
         AIF   (&L GT &K).LOOP2
         AIF   ('&DCB(&I)'(1,&L) NE '&S99DCB@(&J)'(1,&L)).LOOP2
.SET     ANOP
&S99DCB#(&J) SETA &I               NUMBER OF SUBFLD MATCHED
         AGO   .LOOP1              SCAN FOR ALL ENTRIES
         MEXIT
.CHK1    AIF   (&I NE 1).LOOP1     DON'T DO FOR OTHER THAN FIRST
         AGO   .SET
.ENDFLDS MEND
./ ADD NAME=ALLOC#8E
         MACRO
         ALLOC#8E &OP,,&TYPE
.* THIS MACRO RETURNS SUBSCRIPT NUMBER OF TABLE ENTRY CORRESPONDING TO
.* HEX KEY VALUE OR TEXT CHAR STRING.  ZERO IF ITEM NOT CODED ON DCB=.
         GBLA  &S9ARGI,&S9DCB#(40)
         GBLC  &S99DCB$(40)&S99DCB@(40)
&S99ARGI SETA  0
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT 40).END
         AIF   ('&TYPE' EQ '@').@
         AIF   ('&S99DCB$(&I)'(1,2) EQ '&OP').FND
         AGO   .LOOP
.@       AIF   ('&S99DCB@(&I)' EQ '&OP').FND
         AGO   .LOOP
.FND     AIF   (&S99DCB(&I) EQ 0).END NOT USED
&S99ARGI SETA  &I # OF TABLE ENTRY
.END     MEND
./ ADD NAME=ALLOC#9
         MACRO
         ALLOC#9 &Q
.* THIS MACRO DEFINES @ PTRS TO TEXT UNITS FOR ALL CODED DCB PARAMETERS
.* IF AN ERROR OCCURS LATER IN SYNTAX CHECK, THEN AN UNDEFINED SYMBOL
.* REFERENCE OCCURS TO HALT ASSEMBLY.
         GBLA  &S99DCB#(40)
         GBLC  &S99DCB$(40),&S99DCB@(40)
         LCLA  &IMAX,&I
         LCLC  &C
&IMAX    SETA  40
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &IMAX).END
         AIF   (&S99DCB#(&I) EQ 0).LOOP
&C       SETC  '&S99DCB$(&I)'(1,2) GET HEX KEY VALUE
S&C.P&Q  DC    A(S&C.T&Q),0C'&S99DCB@(&I) OF DCB' POINT TO TEXT UNIT
         AGO   .LOOP
.END     MEND
./ ADD NAME=ALLOCMSG
         MACRO
&NAME    ALLOCMSG &S99RB=(1),&S99RC=(15),&FREE=,&WTP=NO
.*
.*        THIS MACRO BUILDS AN SVC99 (DYNALLOC) ERROR MESSAGE.
.*
.*        WRITTEN BY BILL GODFREY, PRC COMPUTER CENTER INC.
.*
.*        THE MACRO RETURNS, IN REGISTER 1, THE ADDRESS OF
.*        A 552 BYTE AREA MAPPED AS FOLLOWS.
.*        OFFSET  LENGTH   CONTENTS
.*         +0       2      LENGTH OF FIRST MESSAGE PLUS 4
.*         +2       2      RESERVED, WILL BE ZERO
.*         +4      252     FIRST MESSAGE TEXT
.*         +256     2      LENGTH OF SECOND MESSAGE PLUS 4
.*         +258     2      RESERVED, WILL BE ZERO
.*         +260    252     SECOND MESSAGE TEXT
.*         +512     40     IKJEFF18 PARAMETERS (INTERNAL USE ONLY)
.*
.*        THE MACRO RETURNS, IN REGISTER 0, THE SUBPOOL AND
.*        LENGTH OF THE ABOVE AREA SO IT MAY BE FREEMAINED.
.*
.*        THIS AREA WILL BE GETMAINED BY THE MACRO. THE USER
.*        SPECIFIES IN THE 'FREE=' OPERAND THE NAME OF A 2-WORD
.*        AREA WHERE INFORMATION NECESSARY FOR A FREEMAIN WILL
.*        BE PLACED BY THE MACRO.  FOR EXAMPLE, IF FREE=XXX
.*        IS SPECIFIED, THE USER COULD FREEMAIN THE AREA
.*        WITH ---- LM  0,1,XXX ---- FREEMAIN R,LV=(0),A=(1).
.*
.*        THE MACRO GENERATES RE-ENTRANT CODE IF THE 'FREE='
.*        OPERAND IS SPECIFIED.
.*
.*         OPTIONAL OPERANDS -
.*           S99RB=     NAME OF SVC99 REQUEST BLOCK, OR
.*                      REGISTER (1-12) IN PARENTHESES
.*                      CONTAINING ADDRESS OF REQUEST BLOCK.
.*                      IF OMITTED, S99RB=(1) IS THE DEFAULT.
.*           S99RC=     NAME OF A FULLWORD WHERE RETURN CODE
.*                      (REGISTER 15) FROM SVC99 IS STORED,
.*                      OPERAND MAY BE A REGISTER (2-12 OR 15)
.*                      IN PARENTHESES, IN WHICH CASE THE REGISTER
.*                      CONTAINS THE RETURN CODE, NOT AN ADDRESS.
.*                      IF OMITTED, S99RC=(15) IS THE DEFAULT.
.*           FREE=      NAME OF A 2-FULLWORD FIELD WHERE
.*                      THE MACRO WILL STORE FREEMAIN INFO.
.*                      IF OMITTED, THE MACRO WILL GENERATE 2
.*                      FULLWORDS INLINE (NON RE-ENTRANT).
.*                      FREEMAIN INFO IS ALWAYS RETURNED IN
.*                      REGISTERS 0 AND 1 ANYWAY.
.*           WTP=YES    CAUSES THE MESSAGE TO BE WRITTEN
.*                      VIA 'WTO' WITH ROUTING CODE 11.
.*                      IF NOT SPECIFIED, THE MESSAGE IS
.*                      ONLY RETURNED, NOT WRITTEN ANYWHERE.
.*
         LCLC  &F
************************************************************
*                                                          *
*         BUILD A DYNAMIC ALLOCATION FAILURE MESSAGE       *
*                                                          *
************************************************************
         SPACE
         AIF   ('&S99RB'(1,1) EQ '(').RBPAR
&NAME    LA    R14,&S99RB          GET ADDR OF SVC99 REQUEST BLOCK
         AGO   .GOTRBA
.RBPAR   AIF   ('&S99RB(1)' NE '*').RBREG
&NAME    LA    R14,&S99RB(2)+8     GET ADDR OF ALLOC MACRO REQ BLK
         AGO   .GOTRBA
.RBREG   ANOP
&NAME    LR    R14,&S99RB(1)       GET ADDR OF SVC99 REQUEST BLOCK
.GOTRBA  AIF   ('&S99RC'(1,1) EQ '(').RCREG
         L     R15,&S99RC          GET SVC99 RETURN CODE
         AGO   .GOTRC
.RCREG   AIF   ('&S99RC(1)' EQ '15' OR '&S99RC(1)' EQ 'R15').GOTRC
         LR    R15,&S99RC(1)       GET SVC99 RETURN CODE
.GOTRC   AIF   (T'&FREE NE 'O').FREESET
         CNOP  0,4                 ALIGNMENT
         B     *+12                BRANCH AROUND 2 WORDS
&F       SETC  'ALLM&SYSNDX'
&F       DC    2A(0)               STORAGE AREA
         AGO   .GOTF
.FREESET ANOP
&F       SETC  '&FREE'
.GOTF    STM   R14,R15,&F          SAVE RBA AND RC ACROSS GETMAIN
         LA    R0,512+24+16        LENGTH OF DATA AREA
         GETMAIN R,LV=(0)          ACQUIRE DATA AREA
         LM    R14,R15,&F          RESTORE RBA AND RC
         ST    R15,512+24+0(,R1)   STORE SVC99 RETURN CODE
         LA    R0,512+24+16        LENGTH OF DATA AREA
         STM   R0,R1,&F            SAVE R0 AND R1 FOR FREEMAIN
         LR    R15,R1              BASE ADDRESS OF GETMAINED AREA
         LA    R1,512(,R15)        POINT TO IKJEFF18 PARAM LIST, 6 WDS
*        USING DFDSECTD,R1         MAPPED BY IKJEFFDF DFDSECT=YES
         ST    R14,0(,R1)          DFS99RBP
         LA    R14,512+24+0(,R15)  POINT TO SVC99 RETURN CODE WORD
         ST    R14,4(,R1)          DFRCP
         SLR   R0,R0               ZERO ADDRESS OF IKJEFF02
         LA    R14,512+24+4(,R15)  POINT TO ZERO ADDRESS OF EFF02
         ST    R0,0(,R14)          STORE ZERO ADDRESS OF IKJEFF02
         ST    R14,8(,R1)          DFJEFF02
         LA    R14,512+24+8(,R15)  POINT TO DFID
         LA    R0,50               DFSVC99
         STH   R0,0(,R14)          STORE VALUE IN DFID
         AIF   ('&WTP' EQ 'YES').WTP
         OI    0(R14),X'40'        40 = DFBUFSW
         AGO   .DFIDX
.WTP     OI    0(R14),X'A0'        A0 = DFWTP+DFBUFS2
.DFIDX   ST    R14,12(,R1)         DFIDP
         SLR   R14,R14             ZERO CPPL ADDRESS
         ST    R14,16(,R1)         DFCPPLP
         ST    R15,20(,R1)         DFBUFP, POINTS TO MESSAGE AREA
*        DROP  R1                  DFDSECTD
         LINK  EP=IKJEFF18
         LM    R0,R1,&F            SET R0 AND R1 FOR FREEMAIN
         MEND
./ ADD NAME=ASMHCL
//ASMHCL PROC AOPT='NOTEST',
//            MAC1='CNB533.BHX.LSTVOL'
//ASM    EXEC PGM=IEV90,REGION=4M,
// PARM='BATCH,OBJ,NODECK,LIST,XREF(SHORT),TERM,&AOPT'
//SYSLIB   DD DISP=SHR,DSN=&MAC1
//*        DD DISP=SHR,DSN=SYS2.MACLIB
//         DD DISP=SHR,DSN=SYS1.HASPSRC,VOL=SER=SYSXA2,UNIT=SYSALLDA
//         DD DISP=SHR,DSN=SYS1.AMODGEN,VOL=SER=SYSXA2,UNIT=SYSALLDA
//         DD DISP=SHR,DSN=SYS1.MACLIB
//SYSUT1   DD UNIT=SYSDA,SPACE=(CYL,(10,5)),DSN=&SYSUT1
//SYSPUNCH DD DUMMY
//SYSPRINT DD SYSOUT=*,DCB=BLKSIZE=121
//SYSLIN   DD DISP=(,PASS),DSN=&&LOADSET,UNIT=SYSDA,SPACE=(CYL,(5,5)),
//            DCB=(BLKSIZE=400)
//SYSTERM  DD SYSOUT=*,TERM=TS
//LKED   EXEC PGM=IEWL,COND=(4,LT,ASM),REGION=220K,
// PARM=(XREF,LIST,'&LOPT')
//SYSLIB   DD DISP=SHR,DSN=CNB533.BHX.TEST.LOAD
//         DD DISP=SHR,DSN=SYS1.SYSLIB
//SYSLIN   DD DISP=(OLD,DELETE),DSN=&&LOADSET
//         DD DDNAME=SYSIN
//SYSLMOD  DD DISP=(,PASS),DSN=&&GOSET(GO),SPACE=(TRK,(1,2,2)),
//            UNIT=SYSALLDA
//SYSUT1   DD UNIT=SYSALLDA,SPACE=(TRK,(3,8)),DSN=&SYSUT1
//SYSPRINT DD SYSOUT=*
./ ADD NAME=DOEXIT
         MACRO
        DOEXIT &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,&P11,&P12,&P13,X
               &P14,&P15,&P16,&P17,&P18,&P19,&P20,&P21,&P22,&P23,&P24,&X
               P25,&P26,&P27,&P28,&P29,&P30,&P31,&P32,&P33,&P34,&P35,&PX
               36,&P37,&P38,&P39,&P40,&P41,&P42,&P43,&P44,&P45,&P46,&P4X
               7,&P48,&P49,&P50,&CC=
         COPY   STR@VARS
         STRILAB
&NEST(&NI) SETC '   Y'.'&NEST(&NI)'(5,4)
       STRIFPRO &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,&P11,&P12,X
               &P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,&P21,&P22,&P23,&X
               P24,&P25,&P26,&P27,&P28,&P29,&P30,&P31,&P32,&P33,&P34,&PX
               35,&P36,&P37,&P38,&P39,&P40,&P41,&P42,&P43,&P44,&P45,&P4X
               6,&P47,&P48,&P49,&P50
         MEND
./ ADD NAME=DOLOOP
         MACRO
         DOLOOP &P1,&FROM=,&TO=,&BY=,&UNTIL=,&WHILE=
         STRINEST DO
         STRDOPRO &FROM,&TO,&BY,&UNTIL,&WHILE,&P1
         MEND
./ ADD NAME=ELSE
            MACRO
            ELSE
            COPY  STR@VARS
&LIND(&LI+1) SETC '&LIND(&LI)'
&LI          SETA &LI-1
            STRILAB
             BC   15,&LIND(&LI)
&LIND(&LI+1) EQU  *
            MEND
./ ADD NAME=ENDDO
         MACRO
         ENDDO
         COPY STR@VARS
         STROINS &ST(&NI)
&II      SETA &II-1
         STRONEST DO
&LI      SETA &LI-2
         MEND
./ ADD NAME=ENDIF
            MACRO
            ENDIF
            COPY  STR@VARS
            STRONEST IF
&LIND(&LI)  EQU *
&LI         SETA &LI-1
            MEND
./ ADD NAME=ENDIF#
         MACRO
         ENDIF# &N
         LCLA  &I,&K
&K       SETA  &N
.LOOP    ANOP
&I       SETA  &I+1
         AIF   (&I GT &K).END
         ENDIF
         AGO   .LOOP
.END     MEND
./ ADD NAME=ENTERSUB
         MACRO
&NAME    ENTERSUB &SAVE=NO,&GETMAIN=NO
.*************************************************************
.* THIS MACRO FACILITITATES THE USE OF INTERNAL SUBROUTINES,
.* AS IT CAUSES THE SAVING OF THE RETURN ADDRESS (R14) IN A
.* FULLWORD PRECEDING THE ENTRY-POINT OF THE SUBROUTINE, AND
.* ALSO ALLOWS A NESTED DEFINITION OF SUBROUTINES, AS THE
.* SUBROUTINE IS BY-PASSED WHEN PLACED IN-LINE IF NOT ENTERED
.* THROUGH THE ENTRY-POINT.
.*
.*       AF DATA SERVICES CENTER, THE PENTAGON
.*       SYSTEMS SUPPORT DIVISION (SFI)
.*       WRITTEN BY CAPT BRUCE HOGMAN AUTOVON 225-1274,
.*                               COMMERCIAL (202) 695-1274
.*       MODIFIED BY BRUCE HOGMAN AT HOUSE INFO SYS
.*       --ADDS TEXT FOR DUMP LOCATION OF SUBROUTINE.
.*       MODIFIED BY BRUCE HOGMAN AT DEPT OF ENERGY TO CORRECT USE
.*       OF SYSLOC INSTEAD OF SYSECT TO RETURN TO PREV LOCTR
.************************************************************
         GBLA  &ESUB#N     NUMBER OF NESTED DEFINITIONS
         GBLC  &ESUB#C(50) NESTED DEFINITIONS ENTRY-POINTS
         GBLC  &ESUB#L(50) NESTED DEFINITIONS ENTRY-POINTS
         GBLC  &ESUB#S(50) WORKAREA LABELS
         GBLB  &DUMPID     WHETHER SUBR IDS SHOULD BE GENERATED
         GBLB  &RENTF      WHETHER THIS IS REENTERANT PROGRAM
         GBLB  &ESAVEF(50)
.*                         SAVE=YES SPECIFIES SAVE AREA IS GENERATED
         GBLB  &EGETMF(50)
.*                         GETMAIN=YES SPECIFIES GETMAIN IS DONE
         LCLC  &C
&ESUB#N  SETA  &ESUB#N+1
&ESAVEF(&ESUB#N) SETB  ('&SAVE' NE 'NO')
&EGETMF(&ESUB#N) SETB  ('&GETMAIN' EQ 'YES')
&ESUB#C(&ESUB#N) SETC 'EXIT&SYSNDX'
&ESUB#S(&ESUB#N) SETC 'EXSV&SYSNDX'
&ESUB#L(&ESUB#N) SETC '&NAME'
         AIF   (&ESAVEF(&ESUB#N)).GETMSV
&C       SETC  '*-4        STORE R14 IN-LINE'
         AIF   (NOT &RENTF).NORENT1
&C       SETC  'SV14'.'&ESUB#C(&ESUB#N)'(5,4)
WORKAREA DSECT , EXTEND DSECT
&C       DS    A RETURN ADDRESS SAVE AREA
&SYSLOC  LOCTR , RESUME PREVIOUS LOCTR
.NORENT1 ANOP
         B     &ESUB#C(&ESUB#N)    GO AROUND NESTED SUBROUTINE
         AIF  (NOT &DUMPID).NOID
         DC   C'SUB &NAME'         DUMPID NAME OF SUBROUTINE
.NOID    ANOP
         AIF  (&RENTF).NAME
         DC   A(X'DEAD0ADD')       FLAGGED RETURN ADDRESS
.NAME    ANOP
&NAME    ST   14,&C
         MEXIT
.GETMSV  B    &ESUB#C(&ESUB#N)     GO AROUND NESTED SUBROUTINE
         PUSH USING
         USING &NAME,R15           TEMPORARY BASE REG
         AIF  (&DUMPID).ESVID
&NAME    SAVE (14,12)
         AGO  .ESVIDX
.ESVID   ANOP
&NAME    SAVE (14,12),,SUB_&NAME
.ESVIDX  ANOP
         AIF  (&EGETMF(&ESUB#N)).OKGETM
WORKAREA LOCTR
&ESUB#S(&ESUB#N) DS 18F            DECLARE WORKAREA SAVEAREA
&SYSLOC  LOCTR
         ST   R13,&ESUB#S(&ESUB#N)+4
         LA   R1,&ESUB#S(&ESUB#N)
         AGO  .OKSVG
.OKGETM  LA   R0,18*4              SIZE OF SUBPOOL ZERO AREA
         GETMAIN RU,LV=(0)
         ST   R13,4(,R1)            DO SAVEAREA LINKAGE
.OKSVG   ST   R1,8(,R13)
         LR   R13,R1
         L    R1,4(,R13)
         LM   R15,R1,16(R1)        RESTORE REGS
         DROP R15
         POP  USING
         MEND
./ ADD NAME=EXITSUB
          MACRO
&NAME     EXITSUB
.************************************************************
.* THIS MACRO IS USED IN CONJUNCTION WITH THE ENTERSUB MACRO
.* TO EXIT FROM A SUBROUTINE.  IT ALSO PROVIDES THE BY-PASS
.* LABEL IF THE SUBROUTINE WAS DEFINED WITH A NESTED DEFINI-
.* TION. WHEN DUMPID=1, RETURN ADDRESS IS FLAGGED ON EXIT.
.*       INSTALLATION:
.*       AF DATA SERVICES CENTER, THE PENTAGON 1D987
.*       SYSTEMS SUPPORT DIVISION/SFI AUTOVON 225-1274
.*       WRITTEN BY CAPT BRUCE HOGMAN (202) 695-1274
.*       EDS, DEPT OF ENERGY B.HOGMAN BHX 91-03-08 INSTALLED
.*
.************************************************************
.*
.*       CALL TO ZSTACK ADDED 82-07-24 TO FORCE STRUCTURED STACKS
.*       EMPTY TO LOCALIZE ASSEMBLY ERRORS IN LARGE PROGRAMS.
.*
         GBLB  &DUMPID WHETHER SUBR IDS WILL BE GENERATED
         GBLB  &RENTF  WHETHER REENTERANT
         GBLA  &ESUB#N NUMBER OF NESTED DEFINITIONS
         GBLC  &ESUB#C(50) ENTRY-POINTS IN STACK
         GBLC  &ESUB#L(50) ENTRY-POINTS IN STACK
         GBLC  &ESUB#S(50) SAVE AREA NAME
         GBLB  &ESAVEF(50) WHETHER SAVE AREA WAS OBTAINED
         GBLB  &EGETMF(50) WHETHER GETMAIN WAS DONE
         AIF   (&ESAVEF(&ESUB#N)).FREESV
         LCLC  &C
&C       SETC  '&ESUB#L(&ESUB#N)'.'-4'
         AIF   (NOT &RENTF).NORENT
&C       SETC  'SV14'.'&ESUB#C(&ESUB#N)'(5,4)
.NORENT  ANOP
&NAME    L     R14,&C
         MVI   &C,X'FF'       FLAG ADDRESS WORD ON EXIT
         BR    14             GOBACK TO CALLER
         AGO   .MNX
.FREESV  ANOP
&NAME    LR    R1,R13         GET SAVEAREA ADDRESS
         L     R13,4(,R13)
         AIF   (NOT &EGETMF(&ESUB#N)).FREMG
         LR    R2,R15         SAVE RETURN-CODE
         LA    R0,18*4
         FREEMAIN RU,LV=(0),A=(1)
         LR    R15,R2
.FREMG   ANOP
         RETURN (14,12),T,RC=(15)
.MNX     ANOP
         AIF   (NOT &DUMPID).ND1
         DC    C'EXIT &ESUB#L(&ESUB#N)'
.ND1     ANOP
&ESUB#C(&ESUB#N) DS 0H        DEFINE BYPASS FOR NESTED USES
.CHKN    AIF   (&ESUB#N GT 0).OKDECR
&ESUB#N  SETA  0
         MNOTE 8,'ESUB#N ZERO IN EXITSUB. TOO MANY EXITSUBS.'
         MEXIT
.OKDECR  ANOP
&ESUB#N  SETA  &ESUB#N-1 DECREMENT NUMBER OF NESTED USES.
         AIF   (&ESUB#N GT 0).ENDR
         ZSTACK , FORCE STRUCTURED MACRO STACK EMPTY END OF SUBRTN
.ENDR    MEND
./ ADD NAME=HIRETCOD
         MACRO
&NAME    HIRETCOD &VALUE
         LCLC  &C,&REG
         LCLA  &N
         AIF   ('(' EQ '&VALUE'(1,1)).REG
         AIF   ('0' GE '&VALUE'(1,1)).NUM
         AIF   (T'&VALUE EQ 'N').NUM2
.REG     ANOP
&N       SETA  K'&VALUE-2
&REG     SETC  '&VALUE'(2,&N)
&NAME    C     &REG,HIRETCOD
         BL    *+4+4
         ST    &REG,HIRETCOD
         MEXIT
.NUM     ANOP
&N       SETA  K'&VALUE
         AIF   ('&VALUE'(&N,1) EQ ')').REG2
.NUM2    ANOP
&NAME    CLC   HIRETCOD,=A(&VALUE)
         BNL   *+4+6
         MVC   HIRETCOD,=A(&VALUE)
         MEXIT
.REG2    ANOP
         MNOTE 8,'HIRETCODE &VALUE CAN''T BE HANDLED BY MACRO.'
         MEND
./ ADD NAME=IF
         MACRO
         IF    &P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,&P11,&P12,&P13,X
               &P14,&P15,&P16,&P17,&P18,&P19,&P20,&P21,&P22,&P23,&P24,&X
               P25,&P26,&P27,&P28,&P29,&P30,&P31,&P32,&P33,&P34,&P35,&PX
               36,&P37,&P38,&P39,&P40,&P41,&P42,&P43,&P44,&P45,&P46,&P4X
               7,&P48,&P49,&P50,&CC=
         STRINEST IF
         STRILAB
       STRIFPRO &CC,&P1,&P2,&P3,&P4,&P5,&P6,&P7,&P8,&P9,&P10,&P11,&P12,X
               &P13,&P14,&P15,&P16,&P17,&P18,&P19,&P20,&P21,&P22,&P23,&X
               P24,&P25,&P26,&P27,&P28,&P29,&P30,&P31,&P32,&P33,&P34,&PX
               35,&P36,&P37,&P38,&P39,&P40,&P41,&P42,&P43,&P44,&P45,&P4X
               6,&P47,&P48,&P49,&P50
         MEND
./ ADD NAME=LC
//BHXULC   JOB (B533,SYBN),'HOGMAN   LC  TSO CP ',
// MSGCLASS=3,TIME=(,10)
/*PHOLD
/*PROCLIB CNB533.BHX.LSTVOL
//PORTRAIT OUTPUT PAGEDEF=M132C1,CLASS=3,DEFAULT=Y,JESDS=ALL
//LCV EXEC ASMHCL
 TITLE 'LC (DOCUMENTATION) --------------------------- LIST CAT LVL CP'
         GBLB  &DOE
&DOE     SETB  1 ASSEMBLE FOR DEPT OF ENERGY
* SPECIAL PROCESSING REQUIRED TO SUPPORT DEPT ENERGY USE OF UPTUSER
* INSTEAD OF UPTPREFX FIELD FOR TSO PREFIX
*=====================================================================*
*                                                                     *
*     DEPT OF ENERGY, ENERGY INFORMATION ADMINISTRATION (EIA)         *
*     FORRESTAL BLDG. BG-056/EI-10, 1000 INDEPENDENCE AVE., S.W.      *
*     WASHINGTON DC 20585  (EDS CORP.:  BHX B.HOGMAN (202)586-1965    *
*                                                                     *
*=====================================================================*
***********************************************************************
*                                                                     *
*     3SG  SYSTEMS SOFTWARE SUPPORT GROUP                             *
*          U.S. CUSTOMS - FRANCONIA                                   *
*                                                                     *
* ++++++ NAME: LC        AUTHOR: BRUCE HOGMAN     DATE: 81-01-21      *
*                                                                     *
* ++++++ FUNCTION: (NARRATIVE)                                        *
*                                                                     *
*     >  THIS COMMAND PROCESSOR INVOKES THE PROGRAM LSTVOL FROM       *
*        SYS  LINKLIB TO OBTAIN A CONDENSED LISTING OF THE VOLSERS    *
*        AND DSNAMES FOR A PARTICULAR LEVEL, SUCH AS THE USERID.      *
*        IF THE LEVEL IS NOT GIVEN, THEN THE USERID IS ASSUMED.       *
*        IF A DDNAME OR DSNAME IS NOT GIVEN FOR THE OUTPUT, THEN      *
*        THE OUTPUT IS SENT TO THE TERMINAL.                          *
*                                                                     *
* =====> CHANGE LOG: 84-02-22 BQH: 1.1 ADDED STRING OPERAND TO        *
*        ALLOW USE OF INCOMPLETE INDEX LEVELS TO REDUCE OUTPUT.       *
*        91-02-28 BHX B.HOGMAN EDS DEPT ENERGY RENAME TO LC FROM LV.  *
*        91-03-01 BHX DEPT OF ENERGY "D.E" TAG:  SUPPORT USE OF       *
*        UPTUSER FIELD INSTEAD OF UPTPREFX FOR USER PREFIX.           *
*                                                                     *
* ++++++ DEPENDENCIES: (SPECIAL MACROS, CALLS/LINKS, FILES)           *
*                                                                     *
*     >  LINKS EP=LSTVOL WITH PARAMETERS.                             *
*        USES ALLOC, STRUCTURED MACROS, ETC.                          *
*                                                                     *
* ++++++ INVOKING:     (HOW DO YOU USE THIS?)                         *
*                                                                     *
*     >  SEE SPS.TSO.SYSTEM.HELP(LC) FOR USAGE                        *
*                                                                     *
***********************************************************************
 TITLE 'LC (MAIN-LINE    ) --------------------------- LIST CAT LVL CP'
         PRINT NOGEN
LC       CSECT
LC       AMODE 24
LC       RMODE 24
         GBLB  &RENTF
&RENTF   SETB  0
         GBLC  &YYMMDD
         YYMMDD ,
         SAVE  (14,12),,'LC       &YYMMDD &SYSTIME TSO CP BHX EDS'
         LR    R11,R15            LOAD BASE REGISTER
         USING LC,R11
         ST    R13,SAVEAREA+4
         LA    R0,SAVEAREA
         ST    R0,8(,R13)
         LR    R13,R0             STD LINKAGE
*              DO CP THINGS TO SETUP PARS LISTS
         USING CPPL,R1
         MVC   PPLUPT,CPPLUPT
         MVC   PPLECT,CPPLECT
         MVC   PPLCBUF,CPPLCBUF
         XC    PPLUWA,PPLUWA       NO WORK AREA
         LA    R1,PPLUPT
         LINK  EP=IKJPARS
         L     R10,ANSR            PICK UP ADDR OF DSECT
         USING LCDSECT,R10
         IF (CLC,=H'1',NE,LCKEY1) LEVEL USED
            IF (CLC,=H'3',EQ,LCKEY1) STRING USED                    1.1
               L     R3,K1SUB4                                      1.1
               LH    R4,K1SUB4+4                                    1.1
               BCTR  R4,0                                           1.1
               MVC   LEVELL,K1SUB4+4                                1.1
               MVC   LEVELDS(*-*),0(R3) MOVE INDEX STRING(S)        1.1
               EX    R4,*-6                                         1.1
               LA    R4,LEVELDS(R4) POINT TO LAST CHARACTER         1.1
               IF (CLI,0(R4),NE,C'*')                               1.1
                  MVI   1(R4),C'*'                                  1.1
                  LH    R4,LEVELL                                   1.1
                  LA    R4,1(,R4)                                   1.1
                  STH   R4,LEVELL                                   1.1
               ENDIF ,                                              1.1
            ELSE ,                                                  1.1
               L     R3,K1SUB2
               LH    R4,K1SUB2+4
               BCTR  R4,0
               MVC   LEVELL,K1SUB2+4
               MVC   LEVELDS(*-*),0(R3) MOVE INDEX(ES)
               EX    R4,*-6
            ENDIF ,                                                 1.1
         ELSE , "NOLEVEL" - LEVEL PARM NOT USED AT ALL
            L     R2,PPLUPT        @UPT
            USING UPT,R2
            AIF (&DOE).DOE
            IF (CLI,UPTPREFL,NE,0) USER PREFIX IN EFFECT            D.E
               WTO 'TEST UPTPREFL NZ',ROUTCDE=11
               IF (CLI,UPTPREFX,EQ,C' '),OR,(CLI,UPTPREFX,EQ,0)     D.E
                  WTO 'TEST UPTPREFX BLANK',ROUTCDE=11
                  LA    R1,UPTUSER PTR USER FIELD IF PREFX BLANK    D.E
                  LA    R2,9(,R1)                                   D.E
               ELSE ,                                               D.E
                  WTO 'TEST UPTPREFX USED',ROUTCDE=11
                  LA    R1,UPTPREFX                                 D.E
                  LA    R2,6(,R1)                                   D.E
               ENDIF ,                                              D.E
            ELSE ,                                                  D.E
               WTO 'TEST UPTPREFL Z',ROUTCDE=11
               IF (CLI,UPTUSER,NE,C' '),AND,(CLI,UPTUSER,NE,0)
                  WTO 'TEST UPTUSER USED',ROUTCDE=11
                  LA    R1,UPTUSER PTR USER FIELD IF PREFX BLANK    D.E
                  LA    R2,UPTUSER+9                                D.E
               ELSE ,                                               D.E
                  WTO 'TEST ASCB PTR USED',ROUTCDE=11
                  L     R1,16            @CVT                       D.E
                  L     R1,0(,R1)        @DW                        D.E
                  L     R1,12(,R1)       @ASCB                      D.E
                  L     R1,176(,R1)      @USERID                    D.E
                  LA    R2,6(,R1)                                   D.E
               ENDIF ,                                              D.E
            ENDIF ,
            AGO .NODOE
.DOE        ANOP
            LA    R1,UPTUSER DEPT OF ENERGY MODE
            LA    R2,9(,R1)
.NODOE      ANOP
            DROP  R2
            DOLOOP INF
               DOEXIT (CLI,0(R2),NE,C' '),AND,(CLI,0(R2),NE,0)
               BCTR  R2,0
            ENDDO
            SR    R2,R1            COMPUTE LENGTH OF USERID
            MVC   LEVELDS(*-*),0(R1)
            EX    R2,*-6
            LA    R2,1(,R2)        CORRECT LENGTH
            STH   R2,LEVELL
         ENDIF
         IF (CLC,=H'1',NE,LCKEY2)
            IF (CLC,=H'2',EQ,LCKEY2)
               L     R2,K2SUB1F
               LH    R3,K2SUB1F+4
               BCTR  R3,0
               MVC   DDN(*-*),0(R2)
               EX    R3,*-6
            ELSE ,
               IF (CLC,=H'3',EQ,LCKEY2)
                  L     R2,K2SUB2F
                  LH    R3,K2SUB2F+4
                  STH   R3,DSN#
                  BCTR  R3,0
                  MVC   DSN(*-*),0(R2)
                  EX    R3,*-6
               ENDIF
            ENDIF
         ENDIF
         MVC   KEEPKEY2,LCKEY2
* =================================================================== *
*                                                                     *
*        ADD CODE FOR USER CATALOG PARAMETER FOR LSTVOL PROGRAM       *
*                                                                     *
* =================================================================== *
         NI    PARM1,X'7F'
         NI    DDPARM@,X'7F'
         XC    UCATL,UCATL         ZERO UCATDS NAME LENGTH IF UNUSED
         IF (CLC,=H'1',NE,LCKEY3)  'UCAT' WAS SPECIFIED
            L     R2,K3SUB1F       POINT TO DSNAME
            LH    R3,K3SUB1F+4     PICK UP LENGTH
            MVI   UCATL+1,C' '
            MVC   UCATDS,UCATDS-1  BLANK UCAT
            STH   R3,UCATL         STORE IT FOR LSTVOL PROGRAM
            BCTR  R3,0             REDUCE TO INTERNAL LENGTH VALUE
            MVC   UCATDS(*-*),0(R2) COPY UCAT NAME
            EX    R3,*-6
         ELSE ,
            OI    DDPARM@,X'80'    FLAG SECOND (OR FIRST) AS LAST
         ENDIF
         LA    R2,ANSR
         IKJRLSA (R2)
         IF (CLC,=H'1',EQ,KEEPKEY2) NODD OR NODSN
            IF (TM,DDPARM@,X'80',O) NO UCAT GIVEN:  NO 3RD PARM
               OI    PARM1,X'80'
            ELSE ,
               XC    DDPARM@,DDPARM@ OMIT THE 2ND PARM BUT KEEP 3RD
            ENDIF
         ENDIF
         IF (CLC,=H'3',EQ,KEEPKEY2)
            ALLOC DDNRET=DDN#,SPACE=(TRK,(1,1)),DISP=(MOD,CATLG),      +
               DSN=(*,DSN#)
         ENDIF
         LA    R1,PARMLIST
         LINK  EP=LSTVOL
         L     R13,4(,R13)
         RETURN (14,12),RC=(15)
 TITLE 'LC (STORAGE THINGS) -------------------------- LIST CAT LVL CP'
SAVEAREA DC    18F'-1'            LOCAL SAVE AREA
PARMLIST DS    0F
PARM1    DC    A(LEVELL)
DDPARM@  DC    A(DDN)
UCAT@    DC    A(UCATL+X'80000000')
*              PPL LIST
PPLUPT   DC    A(*-*)
PPLECT   DC    A(*-*)
PPLECB   DC    A(ECB)
PPLPCL   DC    A(LCPARS)
PPLANSR  DC    A(ANSR)
PPLCBUF  DC    A(*-*)
PPLUWA   DC    A(0)
         SPACE 2
LEVELL   DS    Y
LEVELDS  DC    CL44' '
         SPACE 2
UCATL    DS    Y
UCATDS   DC    CL44' '
         SPACE 2
KEEPKEY2 DC    Y(0)
DDN#     DC    Y(8)
DDN      DC    CL8' '
DSN#     DC    Y(0)
DSN      DC    CL44' '
ECB      DC    A(0)                ECB FOR IKJPARS
ANSR     DC    A(*-*)              ANSWER WORD FOR IKJPARS
 TITLE 'LC (IKJ STUFF     ) -------------------------- LIST CAT LVL CP'
LCPARS   IKJPARM DSECT=LCDSECT
         SPACE 4
LCKEY1   IKJKEYWD DEFAULT='NOLEVEL'
         SPACE 4
         IKJNAME 'NOLEVEL'
         SPACE 4
         IKJNAME 'LEVEL',SUBFLD=K1SUB1,ALIAS=('LVL','L','U')
         SPACE 4
         IKJNAME 'STRING',SUBFLD=K1SUB3,ALIAS=('STR','S')           1.1
         SPACE 4
LCKEY2   IKJKEYWD DEFAULT='NODDDS'
         SPACE 4
         IKJNAME 'NODDDS'
         SPACE 4
         IKJNAME 'DD',SUBFLD=K2SUB1,ALIAS=('DDN','FI','F','FILE','OUTFI+
               LE','OUTF','OUTFI')
         SPACE 4
         IKJNAME 'DS',SUBFLD=K2SUB2,ALIAS=('DSN','OUTDS','ODS','DATASET+
               ','DA')
         SPACE 4
LCKEY3   IKJKEYWD DEFAULT='NOUCAT'
         IKJNAME 'NOUCAT'
         IKJNAME 'UCAT',SUBFLD=K3SUB1,ALIAS=('USERCAT','CAT')
         SPACE 4
K1SUB1   IKJSUBF
         SPACE 4
K1SUB2   IKJPOSIT DSTHING,USID,PROMPT='INDEX LEVEL(S)',                +
               HELP=('IN QUOTES IF NOT YOURS +','I''LL USE USID.INDEX I+
               F NOT QUOTED.')
K1SUB3   IKJSUBF
         SPACE 4                                                    1.1
K1SUB4   IKJIDENT 'INDEX STRING',MAXLNTH=44,PROMPT='FULLY QUALIFIED IND+
               EX STRING PREFIX',CHAR                               1.1
         SPACE 4
K2SUB1   IKJSUBF
K2SUB1F  IKJPOSIT DSNAME,DDNAM,PROMPT='DDNAME PRE-ALLOCATED TO RECEIVE +
               LISTING',HELP=('THE RESULT OF YOUR REQUEST IS WRITTEN US+
               ING THIS DDNAME')
         SPACE 4
K2SUB2   IKJSUBF
         SPACE 4
K2SUB2F  IKJPOSIT DSNAME,USID,PROMPT='NEW DATASET TO RECEIVE OUTPUT LIS+
               TING',HELP=('NORMAL TSO FILE NAMING CONVENTIONS APPLY.')
         SPACE 4
K3SUB1   IKJSUBF
K3SUB1F  IKJPOSIT DSNAME,PROMPT='USER CATALOG NAME TO SEARCH',         +
               HELP=('FULLY QUALIFIED DATA SET NAME, PLEASE.')
         SPACE 4
         IKJENDP
         IKJCPPL ,
         IKJUPT ,
         YESNO ,
         REGS ,
         END
//LKED.SYSLMOD DD DISP=SHR,
// DSN=CNB533.BHX.TEST.LOAD(LC)
./ ADD NAME=LOCATE
//BHXULOCA JOB (B533,SYBN),'HOGMAN   LOCATE',
// MSGCLASS=3,TIME=(2)
/*PHOLD
/*PROCLIB CNB533.BHX.PROCLIB
//PORTRAIT OUTPUT PAGEDEF=M132C1,CLASS=3,DEFAULT=Y,JESDS=ALL
//LOCATE EXEC ASMHCL,AOPT=RENT,LOPT='AC=1,REUS,RENT,REFR'
 TITLE 'LOCATE -- SUBRTN TO DO CAMLST LOCATE'
************************************************************$DOC STRT$*
*=====================================================================*
* VERSION 910325                                                      *
*     DEPT OF ENERGY, ENERGY INFORMATION ADMINISTRATION (EIA)         *
*     FORRESTAL BLDG. BG-056/EI-10, 1000 INDEPENDENCE AVE., S.W.      *
*     WASHINGTON DC 20585  (EDS CORP.:  BHX B.HOGMAN (202)586-1965    *
*                                                                     *
*=====================================================================*
*     3SG:  SYSTEMS SOFTWARE SUPPORT GROUP
*           U.S. CUSTOMS SERVICE -- FRANCONIA
*
* > TITLE: LOCATE -- SUBRTN TO DO CAMLST LOCATE
*
* ++++++ NAME: LOCATE    AUTHOR: BRUCE E. HOGMAN  DATE: 85-09-26
*                        ORIGINAL SOURCE AT U.S. HOUSE REPS
*                        IMPORTED TO U.S. CUSTOMS       86-11-17
*                        IMPORTED TO DEPT OF ENERGY   1991-02-26
*
*        SOURCE CODE: SYSTEM SOURCE LIBRARY
*
*        LOAD MODULE: SYSTEM LNKLST           ATTR: AC=1,RENT,REFR,REUS
*                                             AMODE/RMODE ANY
*                                             SELF-RELATIVE RELOCATABLE
*        MAKE AC=1 APF AUTHORIZED IF LINK TO BY OTHER APF PROGRAMS.
*        PROC:        N/A
*
* ++++++ CHANGE ACTIVITY:               DATE INSTALLED: 85-09-26
*        910325 BHX B.HOGMAN DISTRIBUTE WITH CONCAT/DECONCAT
*        861117 USCS
*        871117 USCS ADD CODE TO RETURN TRUE NAME FOR ALIAS ENTRIES.
* ++++++ FUNCTION: (NARRATIVE)
*
*     >  LOCATE RETURNS THE DEVICE CODE, VOLSER, AND DATA SET SEQ NR
*        FOR A GIVEN DSNAME.  SEE THE INPUT/OUTPUT PARAMETERS BELOW.
*
* ++++++ DEPENDENCIES: (SPECIAL MACROS, CALLS/LINKS, FILES)
*
*     >  ISSUES LOCATE MACRO
*
*     >  MAY BE ENTERED IN ANY AMODE/RMODE.
*
* ++++++ XA COMPATIBLE? REQUIRES XA <========================== XA
*
* ++++++ CONTROL BLOCKS:
*        CATALOG VOLUME LIST AS DESCRIBED IN GC26-4041,
*        "MVS/XA CATALOG ADMINISTRATION GUIDE"
*        C - CREATED, M - MODIFIED, R - REFERENCED, D - DELETED
*
* ++++++ INVOKING:     (HOW DO YOU USE THIS?)
*
*     >  INPUT:   2 PARAMETERS:  44-BYTE DSNAME, FULLY QUALIFIED.
*                                12-BYTE RETURN AREA
*        IMPORTANT NOTE:  IF THE CATALOG HAS AN ALIAS FOR THE DSNAME,
*        THEN THE DSNAME INPUT AREA IS UPDATED <== WITH THE ALIAS.
*        THEREFORE, THE "INPUT 44-BYTE" AREA IS USED FOR OUTPUT.
*
*     >  OUTPUT:  44-BYTE AREA:   UPDATED WITH ALIAS FOR DSNAME,
*                                 IF ONE EXISTS IN THE CATALOG.
*                 THE USER/CALLER CANNOT ASSUME THAT THE 44-BYTE AREA
*                 WILL NOT BE UPDATED.
*
*                 12-BYTE AREA:   4-BYTE UCBTYPE (HEX FULLWORD)
*                                 6-BYTE VOLSER (EBCDIC)
*                                 2-BYTE SEQ NR (BINARY) 00 FOR DISK
*     >  RC:    0:  OK
*               8:  DSNAME NOT LOCATED.  OUTPUT AREA UNCHANGED.
*
************************************************************$DOC STOP$*
         EJECT
         PRINT GEN
LOCATE   CSECT
LOCATE   AMODE ANY
LOCATE   RMODE ANY
         GBLC  &YYMMDD
         YYMMDD
         SAVE  (14,12),,'LOCATE   &YYMMDD &SYSTIME SUBRTN CATLG LOCATE'
         LR    R12,R15             COPY BASE ADDRESS (AND AMODE BIT)
         USING LOCATE,R12          DECLARE BASE REGISTER
         LR    R9,R12              COPY BASE REGISTER
         IF (N,R9,=A(X'7F000000'),NZ) WE HAVE BASE ABOVE 16M LINE
            O     R12,=A(X'80000000') TURN ON AMODE 31 BIT
         ENDIF ,
         L     R11,0(,R1)          POINT TO DSNAME
         L     R10,4(,R1)          POINT TO RETURN
         L     R0,WORKSIZE
         GETMAIN RU,LV=(0),LOC=BELOW FORCE BELOW LINE
         ST    R13,4(,R1)
         ST    R1,8(,R13)          LINK SAVE AREAS
         LR    R13,R1
         USING WORKSAVE,R13
         MVC   WEXEC,XEXEC         COPY CODE BELOW 16M LINE
         LA    R0,WCAMDSN          POINT TO WORKAREA DSN COPY
         ST    R0,WDSNLOC          STORE @ FOR CAMLST
         LA    R0,WCAMWORK         POINT TO WORKAREA WCAMWORK
         ST    R0,WAREALOC         STORE @ FOR CAMLST
         MVC   WCAMDSN,0(R11)      COPY INPUT DSNAME TO LOCATE
         LR    R9,R12              COPY BASE REGISTER WITH AMODE BIT
         AL    R9,=A(AFTERLOC-LOCATE) COMPUTE ABSOLUTE RETURN ADDRESS
         LA    R8,WEXEC            POINT TO LOW CORE SUBROUTINE
         LA    R1,WCAMLST
         BSM   0,R8                GO TO AMODE 24
AFTERLOC DS    0H                  RETURN POINT FROM LOW CORE SUBRTN
         LTR   R15,R15             LOCATE RETURN CODE TESTED HERE
         BNZ   NOMOVE
         MVC   0(12,R10),WCAMWORK+2 COPY 12-BYTE VOL ENTRY
         MVC   0(44,R11),WCAMDSN   COPY BACK DSNAME (UPDATED IF ALIAS)
         SR    R15,R15
NOMOVE   LR    R2,R15
         LR    R1,R13              OBTAIN WORKAREA ADDRESS
         L     R13,4(,R13)         RESTORE SAVE AREA POINTER
         L     R0,WORKSIZE         PICK UP SIZE OF AREA
         FREEMAIN RU,LV=(0),A=(1)  FREE AREA
         LR    R15,R2              RESTORE RETURN CODE
         L     R14,12(,R13)
         LM    R0,R12,20(R13)      RESTORE REGISTERS
         BR    R14
***********************************************************************
*                                                                     *
*        DESCRIBE WORKAREA THAT RESIDES BELOW LINE                    *
*                                                                     *
***********************************************************************
                                                                SPACE 1
WORKAREA DSECT , <===============> MUST BE BELOW 16M LINE
WORKSAVE DS    18F                 SAVE AREA (MUST BE FIRST)
                                                                SPACE 1
*              AREA IMMEDIATELY BELOW IS FILLED BY COPY
WEXEC    DS    CL(LEXEC)           EXECUTABLE CODE
         ORG   WEXEC
         SVC   26
         BSM   0,R9
WCAMLST  CAMLST NAME,0,,0
         ORG   WCAMLST+4
WDSNLOC  DS    A,A                 LOCATION OF DSNAME TO LOCATE
WAREALOC DS    A                   LOCATION OF CAMLST OUTPUT AREA
WCHKLEN  EQU   *-WEXEC             SHOULD = LEXEC
         ORG
                                                                SPACE 1
WCAMWORK DS    CL265               WORK AREA FOR LOCATE/CAMLST
WCAMDSN  DS    CL44                DSNAME TO LOCATE
WORKZZZZ DS    0D
                                                                SPACE 1
***********************************************************************
*        DESCRIBE DATA AREAS, SOME USED TO INTIALIZE WORKAREA ITEMS   *
***********************************************************************
                                                                SPACE 1
LOCATE   LOCTR
WORKSIZE DC    A(WORKZZZZ-WORKAREA) SIZE OF WORKAREA NEEDED
         DS    0A                  ALIGN TO WORD BOUNDARY
XEXEC    SVC   26 INVOKE LOCATE SVC WHILE RESIDING BELOW 16M LINE
         BSM   0,R9                RETURN TO ORIGINAL MODE
XCAMLST  CAMLST NAME,0,,0          NAME,DSN,,AREA
LEXEC    EQU   *-XEXEC             DETERMINE THE LENGTH OF THE CODE
         REGS , DEFINE SYMBOLIC REGS
         LTORG
         END
//LKED.SYSLMOD DD DISP=SHR,
// DSN=CNB533.BHX.TEST.LOAD(LOCATE)
./ ADD NAME=LSTVOL
//BHXULSTV JOB (B533,SYBN),'HOGMAN   OBTAIN ASM ',        VERS 91-03-20
// MSGCLASS=3,TIME=(,10)
/*PHOLD
/*PROCLIB CNB533.BHX.LSTVOL
//PORTRAIT OUTPUT PAGEDEF=M132C1,CLASS=3,DEFAULT=Y,JESDS=ALL
//LSTVOL EXEC ASMHCL,AOPT=RENT,LOPT='RENT,REFR,AC=1'
*=====================================================================*
*                                                                     *
*     DEPT OF ENERGY, ENERGY INFORMATION ADMINISTRATION (EIA)         *
*     FORRESTAL BLDG. BG-056/EI-10, 1000 INDEPENDENCE AVE., S.W.      *
*     WASHINGTON DC 20585  (EDS CORP.:  BHX B.HOGMAN (202)586-1965    *
*                                                                     *
*=====================================================================*
***********************************************************************
*     IMPORTED 1991-02-27 BHX B.HOGMAN                                *
*                                                                     *
*     3SG - SYSTEMS SOFTWARE SUPPORT GROUP                            *
*           U.S. CUSTOMS SERVICE - ALEXANDRIA, VIRGINIA               *
*                                                                     *
* ++++++ NAME: LSTVOL    AUTHOR: BRUCE HOGMAN     DATE: 81-01-21      *
*        (ORIGINAL LSTVOL SOURCE DEVELOPED AT U.S. HOUSE OF REPS)     *
*        LSTVOL USES THE CURRENT CATALOG STRUCTURE.                   *
*                                                                     *
*                                                                     *
* ++++++ FUNCTION: (NARRATIVE)                                        *
*                                                                     *
*     >  LSTVOL USES THE PARM FIELD(S) TO ISSUE A LISTC LEVEL(XXX)    *
*        TO IDCAMS AND THEN TAKES THE RESULTING OUTPUT LISTING AND    *
*        CONDENSES IT INTO THE FORMAT:  VOLSER  DSNAME                *
*        IF A SECOND PARAMETER IS GIVEN, THEN IT IS AN ALTERNATE      *
*        DDNAME TO USE FOR THE OUTPUT LISTING INSTEAD OF THE TERMINAL.*
*        THIS PROGRAM IS USED AS A SUBPROGRAM BY THE CP "LV".         *
*        IT IS ALSO USED IN THE PROCESS OF FINDING UNCATALOGUED D/S   *
*        IF THE THIRD, UCAT, ARGUMENT IS PRESENT, THEN                *
*        LSTVOL INSERTS A "CAT" PHRASE TO INDICATE A USERCAT.         *
*                                                                     *
* =====> CHANGE LOG: 84-02-22 BQH 1.1 LEVEL, ADDED * SUFFIX FEATURE   *
*        84-08-16 BQH ADDED VIO SUPPORT FOR SYSIN TEMPORARY           *
*        86-12-18 BQH ADDED UCAT SUPPORT LEVEL 2.0                    *
*                                                                     *
*        VERS 3.0:                                                    *
*        89-06-20 BQH UPDATED TO MAKE RE-ENTERANT AS SYSTEMS APPL.    *
*                 AMODE 31 RMODE ANY NOW SUPPORTED.                   *
*        91-03-20 BHX B.HOGMAN UPDATED TO CORRECT FSEQN LOGIC TO      *
*                 DETECT TAPE DATASETS.                               *
*                                                                     *
* ++++++ DEPENDENCIES: (SPECIAL MACROS, CALLS/LINKS, FILES)           *
*                                                                     *
*     >  LKED:  RENT,REFR,AC=1 (FOR USE BY AUTHORIZED PROGRAMS)       *
*                                                                     *
*     >  XA:    AMODE 31 RMODE ANY                                    *
*                                                                     *
*     >  MACROS: ALLOC* PLUS ALL STRUCTURED MACROS.                   *
*                                                                     *
* ++++++ INVOKING:     (HOW DO YOU USE THIS?)                         *
*                                                                     *
*     >  VERSION 2.0:  CALL OR LINK USING THREE PARAMETERS ALWAYS.    *
*        CALL LSTVOL,(ULEVEL,,UCAT),VL FOR DISPLAY TO TERMINAL        *
*        CALL LSTVOL,(ULEVEL,DDNAME,UCAT),VL FOR OUTPUT TO DDNAME.    *
*        LINK SIMILAR.                                                *
*        NOTE: ULEVEL STRING PRECEDED BY HALFWORD COUNT OF CHARS IN   *
*        ULEVEL STRING WHICH FOLLOWS.                                 *
*        NOTE: UCAT STRING PRECEDED BY HALFWORD COUNT OF CHARS IN     *
*        CATALOG NAME WHICH FOLLOWS (FULLY-QUALIFIED)                 *
*                                                                     *
*     >  VERSION 3.0:  SAME AS VERS 2.0, EXCEPT NOW AC=1, RENT/REFR   *
*                                                                     *
***********************************************************************
         PRINT NOGEN
         AGO   .DEFINE#MACROS#INLINE
.DEFINE#MAIN#PROGRAM ANOP
         EJECT
LSTVOL   CSECT ,                   DECLARE BASE CONTROL SECTION
LSTVOL   AMODE 31                  DECLARE XA AMODE
LSTVOL   RMODE 24                  DECLARE XA RMODE
DATA     LOCTR ,                   LOCATION COUNTER FOR DATA
WORKAREA DSECT ,                   LOCATION COUNTER FOR WORK
WORKSAVE DS    18F                 SAVEAREA IS FIRST ITEM
WENTRYR1 DS    A                   R1 PARM PTR ON ENTRY
LSTVOL   LOCTR ,                   RETURN TO CSECT
         GBLC  &YYMMDD             DECLARE ISO FORMAT DATE SYMBOL
         LCLC  &VERS               DECLARE VERSION SYMBOL
&VERS    SETC  '3.0'               VERS IS 3.0: XA, AC=1, RENT/REFR
         YYMMDD ,                  SET ISO FORMAT DATE SYMBOL
         SAVE  (14,12),,'LSTVOL   &YYMMDD &SYSTIME &VERS EDS BHX'
         LR    R12,R15             LOAD BASE REGISTER
         LA    R11,2048(,R12)      LOAD BASE REGISTER 2
         LA    R11,2048(,R11)      LOAD BASE REGISTER 2
         USING LSTVOL,R12,R11      DECLARE BASE REGISTERS
         LR    R9,R1               SAVE R1 ON ENTRY
         L     R0,WORKSIZE         SIZE OF AREA TO GETMAIN
         LR    R3,R0               COPY SIZE OF AREA FOR MVCL CLEAR
         GETMAIN RU,LV=(0),LOC=BELOW FORCE LOCATION BELOW 16M LINE
         LR    R2,R1               COPY ADDRESS OF AREA
         LA    R14,*               DUMMY ADDRESS
         SLR   R15,R15             CLEAR FOR MVCL USE
         MVCL  R2,R14              CLEAR ALL WORKAREA
         ST    R13,4(,R1)          STD SAVE AREA LINKAGE
         ST    R1,8(,R13)          STD SAVE AREA LINKAGE
         LR    R13,R1              POINT TO NEW SAVE AREA
         LR    R1,R9               RESTORE R1 TO VALUE ON ENTRY
         LR    R9,R13              POINT TO WORKAREA
         USING WORKAREA,R9         ADDRESSABILITY TO WORKAREA
         ST    R1,WENTRYR1         SAVE R1 ON ENTRY
* =================================================================== *
*   SAVE THE ADDRESS MODE BEING USED WHEN PROGRAM WAS INVOKED.  IT    *
*   WILL BE USED WITH THE "XAMODE" MACRO TO RETURN FROM AMODE24 USED  *
*   FOR I/O MACROS "GET/PUT".                                         *
* =================================================================== *
         BASR  R15,0               SAVE THE AMODE BIT
         N     R15,=A(X'80000000') PRESERVE AMODE BIT
         ST    R15,WAMODE          SAVE AMODE ON INVOKE
* =================================================================== *
*   INITIALIZE WORKAREA ITEMS SUCH AS DCBS USED FOR I/O AND THE       *
*   SVC 99 RB AREAS USED FOR DYNAMIC ALLOCATION.                      *
* =================================================================== *
         MVC   WDCBSYSIN,DCBSYSIN  COPY DCB
         MVC   WDCBTERM,DCBTERM    COPY DCB
         MVC   WLISTCRD,LISTCARD
         MVC   WLISTCR2,LISTCAR2
         MVI   WULEV,C' '
         MVC   WULEV+1(L'WULEV-1),WULEV CLEAR TO BLANKS
         L     R15,=V(SVC99RBM)
         CALL  (15),(ATERM,WATERM,WSVC99RW),VL,MF=(E,WORKCALL)
DATA     LOCTR ,                   DEFINE OUT OF LINE DATA
ATERM    ALLOC TERM=TS,MF=L
WORKAREA LOCTR
WAMODE   DS    A
WORKCALL DS    6A
WATERM   ALLOC TERM=TS,MF=L
LSTVOL   LOCTR
* =================================================================== *
*   PROCESS PARMS PASSED.  INITIALIZE DCBS USED IN SUBPROGRAM.        *
* =================================================================== *
         L     R1,WENTRYR1         RESTORE R1 ON ENTRY
         L     R2,0(R1) PICK UP PARM ADDRESS
         LH    R3,0(,R2)           PICK UP PARM LENGTH
         MVC   WDDNRT#,=Y(8)       INIT SVC 99 RB TXT UNIT
         MVC   WDDNRT,=CL8' '
WORKAREA LOCTR
WDDNRT#  DS    Y
WDDNRT   DS    CL8
WALLOCF  DS    CL1                 'YES' IF WE ALLOC'D TERM OUTPUT DD
LSTVOL   LOCTR
         IF (TM,0(R1),X'80',NO),AND,           >1 PARMS                +
               (ICM,R4,B'1111',4(R1),NZ),AND,  #2 PARM .NZ.            +
               (N,R4,=A(X'7FFFFFFF'),NZ)       #2 PARM .NZ.
            MVC   WDDNRT,0(R4)
            MVI   WALLOCF,NO       WE DO NOT UNALLOCATE AT END
         ELSE ,
            ALLOC TERM=TS,DDNRET=WDDNRT#,MF=(E,WATERM)
            MVI   WALLOCF,YES
         ENDIF ,
         MVC   WDCBTERM+40(8),WDDNRT
* =================================================================== *
*   PROCESS THE PARM FIELD                                            *
* =================================================================== *
         L     R1,WENTRYR1
         IF (TM,4(R1),X'80',NO),AND,(ICM,R4,B'1111',8(R1),NZ)
            LH    R1,0(R4)      PICK UP ITS LENGTH
            ST    R1,WUCATL     SAVE THIS LENGTH
            BCTR  R1,0          REDUCE TO INTERNAL LENGTH
            LA    R4,2(R4)      POINT TO UCAT STRING ITSELF
            MVC   WUCAT(*-*),0(R4)
            EX    R1,*-6        COPY UCAT STRING
            MVC   WUCATX,=CL2' '
*           WTO   'UCAT PARM PRESENT',ROUTCDE=11
         ENDIF ,
WORKAREA LOCTR
WOPENL   DS    3A
WOPENLL  EQU   *-WOPENL
LSTVOL   LOCTR
         XC    WOPENL(WOPENLL),WOPENL
         OI    WOPENL,X'80'
         XAMODE 24
         OPEN  (WDCBTERM,EXTEND),MF=(E,WOPENL)
         XAMODE WAMODE
         IF (LTR,R3,R3,NP)
            PUSH  PRINT
            PRINT GEN
            XAMODE 24
            PUT   WDCBTERM,OOPSMSG
            CLOSE (WDCBTERM,FREE),MF=(E,WOPENL)
            XAMODE WAMODE
            POP   PRINT
            B     EXIT
         ELSE ,
            BCTR  R3,0
            ST    R3,WULEVLEN       KEEP THE INTERNAL LENGTH HANDY
            MVI   WULEVFLAG,NO      FLAG FOR ASTERISK ON END OF NAME
            MVC   WULEV(*-*),2(R2)  MOVE COMPLETE PARM WULEVEL
            EX    R3,*-6
            LA    R1,WULEV(R3)      POINT TO THE LAST CHARACTER
            LA    R0,WULEV
            MVI   WPUTFLAG,YES
            IF (CLI,0(R1),EQ,C'*')  THIS IS AN INCOMPLETE INDEX
               MVI   WULEVFLAG,YES  WE HAVE INCOMPLETE INDEX LEVEL
               L     R3,WULEVLEN
               BCTR  R3,0
               ST    R3,WULEVLEN
               DOLOOP WHILE=(CLI,0(R1),NE,C'.') SCAN BACKWARDS
                  DOEXIT (CR,R1,LE,R0)
                  BCTR  R1,0
               ENDDO ,
               SR    R1,R0          COMPUTE LENGTH OF LEVEL
               IF (LTR,R1,R1,P)     IF WE HAVE DATA
                  BCTR  R1,0
                  MVC   WULEVEL(*-*),WULEV
                  EX    R1,*-6
               ELSE ,
                  MVI   WULEVFLAG,NO
                  L     R1,WULEVLEN
                  MVC   WULEVEL(*-*),WULEV
                  EX    R1,*-6
               ENDIF ,
            ELSE ,
               L     R1,WULEVLEN
               MVC   WULEVEL(*-*),WULEV
               EX    R1,*-6
            ENDIF ,
         ENDIF ,
WORKAREA LOCTR
WAWRK    ALLOC DSN=&&LSTV,UNIT=SYSDA,SPACE=(TRK,(1)),MF=L
DATA     LOCTR
AWRK     ALLOC DSN=&&LSTV,UNIT=SYSDA,SPACE=(TRK,(1)),MF=L
LSTVOL   LOCTR
         L     R15,=V(SVC99RBM)    POINT TO EPA OF SUBRTN
         CALL  (15),(AWRK,WAWRK),VL,MF=(E,WORKCALL)
         MVC   WDDNSINR#,=Y(8)
         MVC   WDDNSINR,=CL8' '
         ALLOC DDNRET=WDDNSINR#,MF=(E,WAWRK)
         MVC   WDCBSYSIN+40(8),WDDNSINR
         MVC   WDNAMES,DNAMES
         MVC   WDDSYSIN,WDDNSINR
         MVI   WOUTREC,C' '
         MVC   WOUTREC+1(L'WOUTREC-1),WOUTREC
         PUSH  PRINT
         PRINT GEN
         XAMODE 24
         OPEN  (WDCBSYSIN,OUTPUT),MF=(E,WOPENL)
         PUT   WDCBSYSIN,WLISTCRD
         PUT   WDCBSYSIN,WLISTCR2
         CLOSE (WDCBSYSIN),MF=(E,WOPENL)
         XAMODE WAMODE
*        FREEPOOL WDCBSYSIN
         POP   PRINT
         MVC   WIDCAMSL,IDCAMSL
         LA    R0,WDNAMES
         ST    R0,WIDCAMD@
         LA    R0,WIOIOLST
         ST    R0,WIDCAMI@
         OI    WIDCAMI@,X'80'
         MVC   WIOIOLST,IOIOLIST   COPY IDCAMS IO PARMS LIST
         ST    R9,WIOIO@
         OI    WIOIO@,X'80'        MARK LAST PARM
         LA    R1,WIDCAMSL
         MVC   WLINKLST,LINKLST
         PUSH  PRINT
         PRINT GEN
         LINK  ,SF=(E,WLINKLST)
WORKAREA LOCTR
         DS    0A
WLINKLST DS    CL(LINKLSTL)
         DS    0A
WUNALL   UNALLOC XXXXXXXX
DATA     LOCTR
         DS    0A
UNALL    UNALLOC XXXXXXXX
UNALLL   EQU   *-UNALL
LINKLST  LINK  EP=IDCAMS,SF=L
LINKLSTL EQU   *-LINKLST
LSTVOL   LOCTR
         L     R15,=V(SVC99RBM)
         CALL  (15),(UNALL,WUNALL),VL,MF=(E,WORKCALL)
         LA    R1,WUNALL+4
         MVC   WUNALL+X'2A'(8),WDDNSINR
         SVC   99
         IF (CLI,WALLOCF,EQ,YES)
            XAMODE 24
            CLOSE (WDCBTERM,FREE),MF=(E,WOPENL)
            XAMODE WAMODE
         ELSE ,
            XAMODE 24
            CLOSE (WDCBTERM,DISP),MF=(E,WOPENL)
            XAMODE WAMODE
*           FREEPOOL WDCBTERM
         ENDIF ,
         POP   PRINT
EXIT     DS    0H
         L     R13,4(,R13)
         LR    R1,R9               POINT TO WORKAREA
         L     R0,WORKSIZE         PICK UP ITS SIZE
         FREEMAIN RU,LV=(0),A=(1)
         SLR   R15,R15
         RETURN (14,12),RC=(15)
 TITLE 'LSTVOL IDCAMS IOROUTINE FOR SYSPRINT HANDLING'
* =================================================================== *
*  ON LISTC LEVEL(USER) VOL,                                          *
*  DSNAME RETURNED IN COLS 18-XX ON RECORD STARTING WITH NONVSAM IN 2 *
*  FOLLOWED IN 6TH RECORD AFTER BY VOLSER IN 27-32 (6)                *
* =================================================================== *
IORTN    SAVE  (14,12),,LSTVOL_IORTN_&YYMMDD
         PUSH  USING
         BASR  R11,0
         USING *,R11
         LR    R8,R1               SAVE ADDR OF INFO LIST
         L     R9,0(,R8)           USER DATA:  PTR TO WORKAREA
         ST    R13,WIOSAVE+4
         LA    R2,WIOSAVE
         ST    R2,8(R13)
         LR    R13,R2
* =================================================================== *
*   PARAMETERS PASSED TO THE USER I/O ROUTINE ARE:                    *
*                                                                     *
*        @USER, @IOFLAGS, @IOINFO                                     *
*        IOFLAGS = X'00': OPEN, X'04': CLOSE, X'0C': PUT              *
*        IOINFO = @RECORD, FULLWORD LENGTH                            *
*                                                                     *
* =================================================================== *
         L     R2,4(R8)            @IOFLAGS
         IF (CLI,0(R2),EQ,X'0C')
            L    R3,8(R8)          @IOINFO
            L    R4,0(R3)          @RECORD
            IF (CLC,4(4,R3),GT,=F'17')
               MVI   WINREC,C' '
               MVC   WINREC+1(L'WINREC-1),WINREC
               L     R5,4(R3)
               BCTR  R5,0
               MVC   WINREC(*-*),0(R4)
               EX    R5,*-6
               LA    R4,WINREC
               IF (CLC,=C'CLUSTER',EQ,1(R4)),OR,                       +
               (CLC,=C'DATA -',EQ,1(R4)),OR,                           +
               (CLC,=C'INDEX -',EQ,1(R4))
                  MVC   WOUTREC+12(44),17(R4)
                  IF (CLI,WULEVFLAG,EQ,YES)
                     IF (CLC,=C'CLUSTER',EQ,1(R4))
                        L     R7,WULEVLEN
                        CLC   WULEV(*-*),WOUTREC+12
                        EX    R7,*-6
                        IF EQ
                           MVI   VSAMFLG,YES
                           MVI   WPUTFLAG,YES
                        ELSE ,
                           MVI   WPUTFLAG,NO
                        ENDIF ,
                     ENDIF ,
                  ELSE ,
                     MVI   VSAMFLG,YES
                     MVI   WPUTFLAG,YES
                  ENDIF ,
                  IF (CLC,=C'CLUSTER',EQ,1(R4))
                     MVC   WOUTREC+1(6),=X'40A5A2819440'
                  ENDIF ,
                  IF (CLC,=C'DATA -',EQ,1(R4))
                     MVC   WOUTREC+8(3),=X'84A381'
                     MVI   WPUTFLAG,NO
                  ENDIF ,
                  IF (CLC,=C'INDEX -',EQ,1(R4))
                     MVC   WOUTREC+8(3),=X'8984A7'
                     MVI   WPUTFLAG,NO
                  ENDIF ,
                  IF (CLI,WPUTFLAG,EQ,YES)
                     IF (CLC,=CL2' ',EQ,WUCATX) WUCAT IS PRESENT
                        LA      R5,WOUTREC+L'WOUTREC-2
                        S       R5,WUCATL
                        L       R6,WUCATL
                        BCTR    R6,0
                        LA      R7,WUCAT
                        DOLOOP WHILE=(CLI,0(R5),NE,C' ')
                           LA    R5,1(R5)
                           LA    R7,1(R7)
                           DOEXIT (LTR,R6,R6,Z)
                           BCTR  R6,0
                        ENDDO ,
                        IF (LTR,R6,R6,NZ)
                           MVC   0(*-*,R5),0(R7)
                           EX    R6,*-6
                        ENDIF ,
                     ENDIF ,
                     PUT   WDCBTERM,WOUTREC
                     MVI   WOUTREC,C' '
                     MVC   WOUTREC+1(L'WOUTREC-1),WOUTREC
                  ENDIF ,
               ELSE ,
               IF (CLC,=C'NONVSAM',EQ,1(R4))
                  MVI   VSAMFLG,NO
                  MVC   WOUTREC+12(44),17(R4)
                  IF (CLI,WULEVFLAG,EQ,YES)
                     L     R7,WULEVLEN
                     CLC   WULEV(*-*),WOUTREC+12
                     EX    R7,*-6
                     IF EQ
                        MVI   WPUTFLAG,YES
                     ELSE ,
                        MVI   WPUTFLAG,NO
                     ENDIF ,
                  ELSE ,
                     MVI   WPUTFLAG,YES
                  ENDIF ,
               ELSE ,
               IF (CLC,=C'VOLSER',EQ,8(R4))
                  IF (CLI,WPUTFLAG,EQ,YES),OR,(CLI,VSAMFLG,EQ,YES)
                     MVI   WPUTFLAG,YES
                  ENDIF ,
                  MVC   WOUTREC+1(6),18+8(R4)
                  DOLOOP WHILE=(CLI,WOUTREC+1,EQ,C'-')
                     MVC   WOUTREC+1(6),WOUTREC+2
                  ENDDO ,
                  IF (CLC,=C'FSEQN',EQ,66(R4)),AND,(CLI,56(R4),EQ,C'8')
                     MVI   WOUTREC+7,C','
                     MVC   WOUTREC+8(3),18+8+61(R4) MV FSEQN (LEAD '-'
                     IF (CLC,=C',--0',EQ,WOUTREC+7)
                        MVC   WOUTREC+7(4),=CL4' '
                     ELSE ,
                        LA    R6,WOUTREC+8
                        DOLOOP WHILE=(CLI,0(R6),EQ,C'-')
                           MVI   0(R6),C'0'
                           LA    R6,1(R6)
                        ENDDO ,
                     ENDIF ,
                  ENDIF ,
                  IF (CLI,WPUTFLAG,EQ,YES)
                     IF (CLC,=CL2' ',EQ,WUCATX) WUCAT IS PRESENT
                        LA      R5,WOUTREC+L'WOUTREC-2
                        S       R5,WUCATL
                        L       R6,WUCATL
                        BCTR    R6,0
                        LA      R7,WUCAT
                        DOLOOP WHILE=(CLI,0(R5),NE,C' ')
                           LA    R5,1(R5)
                           LA    R7,1(R7)
                           DOEXIT (LTR,R6,R6,Z)
                           BCTR  R6,0
                        ENDDO ,
                        IF (LTR,R6,R6,NZ)
                           MVC   0(*-*,R5),0(R7)
                           EX    R6,*-6
                        ENDIF ,
                     ENDIF ,
                     PUT   WDCBTERM,WOUTREC
                     IF (CLC,=X'8984A7',EQ,WOUTREC+8)
                        MVI   VSAMFLG,NO
                        MVI   WPUTFLAG,NO
                     ENDIF ,
                  ENDIF ,
                  MVI   WOUTREC,C' '
                  MVC   WOUTREC+1(L'WOUTREC-1),WOUTREC
               ENDIF# 3
            ENDIF ,
         ENDIF ,
         L     R13,4(,R13)
         RETURN (14,12),RC=0
         POP   USING
OOPSMSG  DC    CL80'DANG] YOU FORGOT THE PARM FIELD]'
WORKAREA LOCTR
WIOSAVE  DC    18F'-1'
WUCATL   DC    A(1-1)              LENGTH OF CATALOG NAME
VSAMFLG  DC    AL1(NO) FLAG FOR CLUSTERS
WOUTREC  DC    CL80' '
WLISTCRD DS    CL80
WLISTCR2 DS    CL80
WDDNSINR# DC   Y(8)
WDDNSINR DC    CL8' '
DATA     LOCTR
LISTCARD DC CL80' LISTC LVL(                                   ) ALL +'
WULEVEL  EQU   WLISTCRD+11,35,C'C'
LISTCAR2 DC CL80' /* CAT(                                            )'
WUCATX   EQU   WLISTCR2+1,2,C'C'
WUCAT    EQU   WLISTCR2+08,44,C'C' CATALOGUE NAME
IDCAMSL  DC    A(OPTIONS)
         DC    A(DNAMES)
         DC    A(PAGEN)
         DC    A(IOIOLIST+X'80000000')
IDCAMSLL EQU   *-IDCAMSL
OPTIONS  DC    H'0,0'
PAGEN    DC    H'0,0'
DNAMES   DC    AL2(5*8),4XL8'0'
DDSYSIN  DC    CL8' '
DDSYSP   DC    CL8' '
DNAMESL  EQU   *-DNAMES
IOIOLIST DC    A(1,SYSPRN,IORTN),A(X'80000000')
IOIOLSTL EQU   *-IOIOLIST          LENGTH OF I/O RTN PARM LIST
SYSPRN   DC    CL10'DDSYSPRINT'
DUMMY    DC    A(0)
WORKAREA LOCTR
         DS    0A
WDNAMES  DS    CL(DNAMESL)
WDDSYSIN EQU   WDNAMES+(DDSYSIN-DNAMES),8,C'C'
         DS    0A
WIDCAMSL DS    CL(IDCAMSLL)
WIDCAMD@ EQU   WIDCAMSL+4,4,C'A'
WIDCAMI@ EQU   WIDCAMSL+3*4,4,C'A' ADDRESS OF IOLIST LIST
         DS    0A
WIOIOLST DS    CL(IOIOLSTL)
WIOIO@   EQU   WIOIOLST+3*4,4,C'A' WORD FOR OUR USE IN IO ROUTINE
LSTVOL   LOCTR
         PUSH  PRINT
         PRINT NOGEN
DATA     LOCTR
DCBSYSIN DCB  DDNAME=X,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,BLKSIZE=800,+
               BUFNO=1
DCBINL   EQU   *-DCBSYSIN
DCBTERM  DCB  DDNAME=X,DSORG=PS,MACRF=PM,RECFM=FB,LRECL=80,BLKSIZE=800,+
               BUFNO=1
DCBOTL   EQU   *-DCBTERM
WORKAREA LOCTR
         DS    0A
WSVC99RW DS    CL80
WDCBSYSIN DS   CL(DCBINL)
         DS    0A
WDCBTERM DS    CL(DCBOTL)
WULEV    DC    CL44' '
WULEVLEN DC    A(0)
WULEVFLAG DC   AL1(NO)
WPUTFLAG DC    AL1(NO)
WINREC   DC    CL256' '
LSTVOL   LOCTR
         LTORG
WORKAREA LOCTR
WORKZZZZ DS    0D
LSTVOL   LOCTR
WORKSIZE DC    A(WORKZZZZ-WORKAREA) SIZE OF AREA NEEDED
         YESNO
         REGS
         AGO   .END#OF#PROGRAM
.DEFINE#MACROS#INLINE ANOP
 TITLE 'LSTVOL IN-LINE MACROS DEFINITIONS'
         MACRO
&NAME    XAMODE &TYPE,&REG=R15
         AIF   ('24' EQ '&TYPE').A24
         AIF   ('31' EQ '&TYPE').A31
&NAME    LA    &REG,*+10
         O     &REG,&TYPE
         AGO   .BSM
.A31     ANOP
&NAME    LA    &REG,*+10
         O     &REG,=A(X'80000000') INSERT AMODE31 BIT
         AGO   .BSM
.A24     ANOP
&NAME    LA    &REG,*+6 REMOVE AMODE31 BIT
.BSM     BSM   0,&REG SET MODE AND BRANCH TO NEXT INSTR
         MEXIT
.AMODE   ANOP
         MNOTE 8,'XAMODE=24/31 ONLY'
         MEND
         AGO  .DEFINE#MAIN#PROGRAM
.END#OF#PROGRAM ANOP
         END
//LKED.SYSLMOD DD DISP=SHR,
// DSN=CNB533.BHX.TEST.LOAD(LSTVOL)
./ ADD NAME=OBTAIN
//BHXUOBTA JOB (B533,SYBN),'HOGMAN   OBTAIN',
// MSGCLASS=3,TIME=(2)
/*PHOLD
/*PROCLIB CNB533.BHX.PROCLIB
//PORTRAIT OUTPUT PAGEDEF=M132C1,CLASS=3,DEFAULT=Y,JESDS=ALL
//OBTAIN EXEC ASMHCL,AOPT='RENT',LOPT='AC=1,REUS,RENT,REFR'
 TITLE 'OBTAIN -- SUBRTN TO DO CAMLST OBTAIN TO READ DSCB'
************************************************************$DOC STRT$*
*=====================================================================*
* VERSION 910325                                                      *
*     DEPT OF ENERGY, ENERGY INFORMATION ADMINISTRATION (EIA)         *
*     FORRESTAL BLDG. BG-056/EI-10, 1000 INDEPENDENCE AVE., S.W.      *
*     WASHINGTON DC 20585  (EDS CORP.:  BHX B.HOGMAN (202)586-1965    *
*                                                                     *
*=====================================================================*
*     3SG:  SYSTEMS SOFTWARE SUPPORT GROUP ORIGINAL SOFTWARE
*     U. S. CUSTOMS SERVICE
*
* > TITLE: OBTAIN -- SUBRTN TO DO CAMLST OBTAIN TO READ DSCB
*        NOTE:  CODE VERY SIMILAR TO THAT FOR LOCATE SUBROUTINE.
*
* ++++++ NAME: OBTAIN    AUTHOR: BRUCE E. HOGMAN  DATE: 85-09-26
*                        ORIGINAL SOURCE DEVELOPED AT U.S.HOUSE REPS
*                        IMPORTED TO CUSTOMS FRANCONIA  86-11-17
*
*        SOURCE CODE: SYSPROG.SOURCE
*
*        LOAD MODULE: SYS2.LINKLIB(OBTAIN)    ATTR: AC=1,RENT,REFR,REUS
*                     AMODE/RMODE ANY, SELF-RELATIVE RELOCATABLE
*                     (CAN BE COPIED AND USED ANYWHERE)
*        MAKE AC=1 IF USED BY APF-AUTHORIZED PROGRAMS AS SUBPROGRAM.
*        PROC:        N/A
*
*        $$$DOC:      SPS.DOC.TEXT(OBTAIN)    <=== DOCUMENTATION!
*
* ++++++ CHANGE ACTIVITY:               DATE INSTALLED: 85-09-26
*        910325 BHX B.HOGMAN VERSION DISTRIBUTED WITH CONCAT 910325
*
* ++++++ FUNCTION: (NARRATIVE)
*
*     >  OBTAIN RETURNS THE DSCB FROM THE VTOC, GIVEN DSNAME AND VOLSER
*        ON WHICH IT RESIDES.
*
* ++++++ DEPENDENCIES: (SPECIAL MACROS, CALLS/LINKS, FILES)
*     >  ISSUES OBTAIN MACRO
*
*     >  MAY BE ENTERED IN ANY AMODE/RMODE.
*
* ++++++ XA COMPATIBLE? REQUIRES XA <========================== XA
*
* ++++++ CONTROL BLOCKS:
*        DSCB1-R JFCB-R
*        C - CREATED, M - MODIFIED, R - REFERENCED, D - DELETED
*
* ++++++ INVOKING:     (HOW DO YOU USE THIS?)
*
*     >  INPUT:   3 PARAMETERS:  44-BYTE DSNAME, FULLY QUALIFIED.
*                                 6-BYTE VOLSER
*                               101-BYTE AREA: 96-BYTE DSCB, 5-CCHHR
*
*     >  OUTPUT:  101-BYTE AREA: 96-BYTES DSCB (FORMAT-1 OR -4)
*                                 5-BYTES CCHHR OF DSCB
*                                 (ZEROS FOR VSAM/VIO DATA SETS)
*     >  RC:    0:  OK
*               4:  VOLUME NOT MOUNTED
*               8:  DSCB NOT FOUND ON VOLUME.
*              12:  I/O ERROR OR OTHER UNEXPECTED ERROR
*
************************************************************$DOC STOP$*
         EJECT
         PRINT GEN
OBTAIN   CSECT
OBTAIN   AMODE ANY
OBTAIN   RMODE ANY
         GBLC  &YYMMDD
         YYMMDD
         SAVE  (14,12),,'OBTAIN   &YYMMDD &SYSTIME READ DSCB-1 3SG'
         LR    R12,R15             COPY BASE ADDRESS (AND AMODE BIT)
         USING OBTAIN,R12          DECLARE BASE REGISTER
         LR    R9,R12              COPY BASE REGISTER
         IF (N,R9,=A(X'7F000000'),NZ) WE HAVE BASE ABOVE 16M
            O     R12,=A(X'80000000') TURN ON AMODE INDICATOR
         ENDIF ,
         L     R11,0(,R1)          POINT TO DSNAME
         L     R10,4(,R1)          POINT TO VOLSER
         L     R9,8(,R1)           POINT TO DSCB RETURN AREA
         L     R0,WORKSIZE
         GETMAIN RU,LV=(0),LOC=BELOW FORCE BELOW LINE
         ST    R1,8(,R13)          LINK SAVE AREAS
         ST    R13,4(,R1)
         LR    R13,R1
         USING WORKSAVE,R13
         MVC   WEXEC,XEXEC         COPY CODE BELOW 16M LINE
         LA    R0,WCAMDSN          POINT TO WORKAREA DSN COPY
         ST    R0,WDSNLOC          STORE @ FOR CAMLST
         LA    R0,WCAMVOL          POINT TO WORKAREA VOLSER COPY
         ST    R0,WVOLLOC          STORE @ FOR CAMLST
         LA    R0,WCAMWORK         POINT TO WORKAREA WCAMWORK
         ST    R0,WAREALOC         STORE @ FOR CAMLST
         MVC   WCAMDSN,0(R11)      COPY INPUT DSNAME TO OBTAIN
         MVC   WCAMVOL,0(R10)      COPY INPUT VOLSER TO OBTAIN
         LR    R8,R12              COPY BASE REGISTER WITH AMODE BIT
         AL    R8,=A(AFTEROBT-OBTAIN) COMPUTE ABSOLUTE RETURN ADDRESS
         LA    R7,WEXEC            POINT TO LOW CORE SUBROUTINE
         LA    R1,WCAMLST
         BSM   0,R7                GO TO AMODE 24
AFTEROBT DS    0H                  RETURN POINT FROM LOW CORE SUBRTN
         LTR   R2,R15              CHECK RETURN CODE
         BNZ   NOMOVE              UNSUCCESSFUL
         MVC   0(101,R9),WCAMWORK COPY 96-BYTE DSCB PLUS CCHHR
NOMOVE   LR    R1,R13              OBTAIN WORKAREA ADDRESS
         L     R13,4(,R13)         RESTORE SAVE AREA POINTER
         L     R0,WORKSIZE         PICK UP SIZE OF AREA
         FREEMAIN RU,LV=(0),A=(1)  FREE AREA
         LR    R15,R2              RESTORE RETURN CODE
         L     R14,12(,R13)
         LM    R0,R12,20(R13)      RESTORE REGISTERS
         BR    R14
***********************************************************************
*                                                                     *
*        DESCRIBE WORKAREA THAT RESIDES BELOW LINE                    *
*                                                                     *
***********************************************************************
                                                                SPACE 1
WORKAREA DSECT , <===============> MUST BE BELOW 16M LINE
WORKSAVE DS    18F                 SAVE AREA (MUST BE FIRST)
                                                                SPACE 1
*              AREA IMMEDIATELY BELOW IS FILLED BY COPY
WEXEC    DS    CL(LEXEC)           EXECUTABLE CODE
         ORG   WEXEC
         SVC   27                  OBTAIN SVC
         BSM   0,R8
WCAMLST  CAMLST SEARCH,0,0,0       DSN,VOL,WORK
         ORG   WCAMLST+4
WDSNLOC  DS    A                   LOCATION OF DSNAME TO OBTAIN
WVOLLOC  DS    A                   LOCATION OF VOLSER
WAREALOC DS    A                   LOCATION OF CAMLST OUTPUT AREA
WCHKLEN  EQU   *-WEXEC             SHOULD = LEXEC
         ORG
                                                                SPACE 1
WCAMWORK DS    CL265               WORK AREA FOR OBTAIN/CAMLST
WCAMDSN  DS    CL44                DSNAME TO OBTAIN
WCAMVOL  DS    CL6                 VOLSER FOR OBTAIN
WORKZZZZ DS    0D
                                                                SPACE 1
***********************************************************************
*                                                                     *
*        DESCRIBE DATA AREAS, SOME USED TO INTIALIZE WORKAREA ITEMS   *
*                                                                     *
***********************************************************************
                                                                SPACE 1
OBTAIN   LOCTR
WORKSIZE DC    A(WORKZZZZ-WORKAREA) SIZE OF WORKAREA NEEDED
         DS    0A                  ALIGN TO WORD BOUNDARY
XEXEC    SVC   27 INVOKE OBTAIN SVC WHILE RESIDING BELOW 16M LINE
         BSM   0,R8                RETURN TO ORIGINAL MODE
XCAMLST  CAMLST SEARCH,0,0,0       SEARCH,DSN,VOL,WORK (SYS1.MACLIB)
LEXEC    EQU   *-XEXEC             DETERMINE THE LENGTH OF THE CODE
         REGS , DEFINE SYMBOLIC REGS
         LTORG
         END
//LKED.SYSLMOD DD DISP=SHR,
// DSN=CNB533.BHX.TEST.LOAD(OBTAIN)
./ ADD NAME=PERFORM
         MACRO
&NAME    PERFORM &ROUTIN,&PARAM,&MF=I,&EXTERN=NO
.**********************************************************************
.* THIS MACRO FACILITATES WRITING OF INTERNAL SUBROUTINES WITHOUT THE *
.* NEED TO ADD NEW CSECTS OR MODULES TO A PROGRAM. IT GENERATES EITHER*
.* A SIMPLE BAL 14,SUBROUTINE  OR IT MAY ALSO GENERATE A CALL (15),   *
.* USING THE PARAMETER LIST WHICH IS OPTIONAL. IF EXTERN IS SPECIFIED,*
.* THEN AN EXTERNAL CALL IS GENERATED.  THE MACRO MAY ALSO BE USED TO *
.* GENERATE A PARAMETER LIST FOR LATER USE.                           *
.*                                                                    *
.* THIS MACRO OR ANOTHER WHICH LOADS THE SUBROUTINE ADDRESS INTO R15  *
.* IS RECOMMENDED WITH THE ENTERSUB/EXITSUB COMBINATION, SINCE        *
.* ENTERSUB WITH SAVE=YES ASSUMES R15 POINTS TO THE SUBROUTINE.       *
.*                                                                    *
.*       INSTALLATION: AF DATA SERVICES CENTER, THE PENTAGON          *
.*       SYSTEMS SUPPORT DIVISION                                     *
.*       AUTHOR: CAPT BRUCE HOGMAN (AUTOVON 225-1274) (202)695-1274   *
.**********************************************************************
         AIF   ('&PARAM' NE '').CALL PARAMS WERE GIVEN
         AIF   ('&EXTERN' NE 'NO').CALLX EXTERNAL CALL GIVEN
         AIF   ('&ROUTIN' EQ '').CALL15 MUST HAVE LOADED R15
&NAME    LA    15,&ROUTIN LOAD ADDRESS OF INTERNAL ROUTINE
         BALR  14,15       GO VIA "CALL"
         MEXIT
.CALL    AIF   ('&EXTERN' NE 'NO').CALLX WITH PARAMS
         LA    15,&ROUTIN GET THE INTERNAL @ OF ROUTINE
         AGO   .CALL15
.CALLX   L     15,=V(&ROUTIN) LOAD EXTERNAL ADDRESS
.CALL15  CALL  (15),&PARAM,&MF USE STANDARD CALL MACRO
         MEND
./ ADD NAME=RDJFCB
//BHXURDJF JOB (B533,SYBN),'HOGMAN   RDJFCB ASM ',
// MSGCLASS=3,TIME=(2)
/*PHOLD
/*PROCLIB CNB533.BHX.PROCLIB
//PORTRAIT OUTPUT PAGEDEF=M132C1,CLASS=3,DEFAULT=Y,JESDS=ALL
//RDJFCB EXEC ASMHCL,AOPT=RENT,LOPT='REUS,RENT,REFR'
***********************************************************************
*=====================================================================*
* VERSION 910325                                                      *
*     DEPT OF ENERGY, ENERGY INFORMATION ADMINISTRATION (EIA)         *
*     FORRESTAL BLDG. BG-056/EI-10, 1000 INDEPENDENCE AVE., S.W.      *
*     WASHINGTON DC 20585  (EDS CORP.:  BHX B.HOGMAN (202)586-1965    *
*                                                                     *
*=====================================================================*
*                                                                     *
*     3SG  SYSTEMS SOFTWARE SUPPORT GROUP                             *
*          U.S. CUSTOMS SERVICE - FRANCONIA, VIRGINIA CENTER          *
*                                                                     *
* ++++++ NAME: RDJFCB    AUTHOR: BRUCE HOGMAN     DATE: 82-01-25      *
*        91-03-25 DISTRIBUTED WITH CONCAT/DECONCAT SYSTEM.            *
*        91-02-27 BHX B.HOGMAN INSTALLED AT DEPT OF ENERGY            *
*        90-10-10 BQH B.HOGMAN UPDATED FOR MVS/ESA                    *
*        (USE SWAREQ READ LOCATE SERVICE)                             *
*                                                                     *
* ++++++ FUNCTION: (NARRATIVE)                                        *
*                                                                     *
*     >  THIS SUBROUTINE READS THE JFCB FOR A GIVEN DDNAME, INCLUDING *
*        OPTIONAL CONCATENATION NUMBER FOR CONCATENATED PDS'S.        *
*        IT RETURNS THE 176-BYTE JFCB FOR THE DDNAME IN THE USER'S    *
*        AREA.                                                        *
*                                                                     *
* ++++++ DEPENDENCIES: (SPECIAL MACROS, CALLS/LINKS, FILES)           *
*        NO SVC'S.  AMODE/RMODE=ANY. LINKED: AC=1,RENT,REUS,REFR      *
*        SELF-RELATIVE RELOCATABLE (NO ADDRESS CONSTANTS)             *
*                                                                     *
*     >  MACROS PROLOGUE/EPILOGUE, STRUCTURED, IN SPS.SYS.MACLIB.ASM  *
*                                                                     *
* ++++++ INVOKING:     (HOW DO YOU USE THIS?)                         *
*                                                                     *
*     >  CALL RDJFCB,(DDNAME,JFCB,CONCAT),VL THIRD ARG OPTIONAL       *
*                                                                     *
***********************************************************************
         EJECT
         PRINT NOGEN
*        REGISTER USAGE:
*        R12   BASE REGISTER
*        R11 = CONCATENATION NUMBER
*        R10=> PARM2 (JFCB LOCATION)
*        R9 => PARM1 (DDNAME LOCATION)
RDJFCB   CSECT
RDJFCB   AMODE ANY
RDJFCB   RMODE ANY
         GBLC  &YYMMDD
         YYMMDD
         SAVE  (14,12),,'RDJFCB &YYMMDD &SYSTIME READ JFCB FROM TIOT'
         LA    R12,0(,R15)         LOAD BASE REGISTER
         USING RDJFCB,R12
         L     R14,=A(X'7F000000')
         LA    R14,0(,R14)
         IF (LTR,R14,R14,Z)        AMODE24
            L     R14,12(,R13)
            LA    R14,0(,R14)
         ELSE ,
            L     R14,12(,R13)
            O     R14,=A(X'80000000')  AMODE31 RETURN ADDRESS
         ENDIF ,
         ST    R14,12(,R13)        RESTORE R14 WITH AMODE RETURN SET
         L     R9,0(,R1)           POINT TO DDNAME
         LA    R9,0(,R9)           CLEAR ADDRESS IN AMODE CURRENT
         L     R10,4(,R1)          POINT TO JFCB TO RETURN
         LA    R10,0(,R10)         CLEAR ADDRESS IN AMODE CURRENT
         SLR   R11,R11             ASSUME ZERO CONCAT NUMBER
         IF (TM,4(R1),X'80',NO)    IF MORE THAN TWO PARMS,
            L     R11,8(,R1)       POINT TO LOCATION OF NUMBER
            L     R11,0(,R11)      PICK UP NUMBER
         ENDIF ,
         MVI   0(R10),X'0'         ZERO THE JFCB
         MVC   1(175,R10),0(R10)
         PUSH  PRINT
         PRINT GEN
         XAMODE 31                 CHANGE TO AMODE 31
         POP   PRINT
         L     R1,CVTPTR           @CVT
         L     R1,0(,R1)           @DW
         L     R1,4(,R1)           @TCB
         L     R1,12(,R1)          @TIOT
         LA    R8,TIOENTRY-TIOT1(,R1)
         USING TIOENTRY,R8
DDLOOP   SLR   R4,R4
         ICM   R4,B'0001',TIOELNGH LENGTH OF DD ENTRY
         BZ    ZEXIT
         CLC   TIOEDDNM,0(R9)      COMPARE TWO DDNAMES
         BE    FOUND
         LA    R8,0(R4,R8)         LOOK AT NEXT DD ENTRY
         B     DDLOOP
FOUND    LTR   R11,R11
         BZ    VALUE
LOOP2    LA    R8,0(R4,R8)
         ICM   R4,B'0001',TIOELNGH LENGTH OF DD ENTRY
         BZ    ZEXIT
         CLC   TIOEDDNM,=CL8' '    MUST KEEP BEING BLANKS
         BNE   ZEXIT
         BCT   R11,LOOP2
VALUE    SLR   R6,R6
* MVS/ESA CHANGE:  ADD INTERFACE TO SWAREQ MACRO
* REGISTER USAGE:  R8=>TIOENTRY
*                  R7=>SWAREQ AREA
         USING WORKAREA,R10        USE THE CALLER'S JFCB AREA
         LA    R7,SWAEPAX@         POINT TO EPA AREA OF 28 BYTES
         USING SWAEPAX,R7
         XC    SWAEPAX,SWAEPAX     INITIALIZE THE EPA
         ST    R7,SWEPAPTR         INIT EPA PTR IN SWAREQ AREA
         MVC   SWVA,TIOEJFCB       COPY JFCB TOKEN
         ST    R13,WSV+4
         ST    R10,8(,R13)
         LR    R13,R10             POINT TO NEW SAVE AREA
         SWAREQ FCODE=RL,EPA=SWEPAPTR,UNAUTH=YES,MF=(E,SWAREQ)
         IF (C,R15,EQ,=A(8))
            WTO 'INVALID SVA IN SWA PREFIX',ROUTCDE=11
         ELSE ,
            IF (C,R15,EQ,=A(24))
               WTO 'ATTEMPT READ BLOCK NOT YET WRITTEN',ROUTCDE=11
            ELSE ,
               IF (C,R15,EQ,=A(28))
                  WTO 'INVALID POINTER TO EPA',ROUTCDE=11
               ENDIF ,
            ENDIF ,
         ENDIF ,
         L     R13,4(,R13)
         L     R6,SWBLKPTR
         MVC   0(176,R10),0(R6)     MOVE JFCB
         B     EXIT
ZEXIT    LA    R15,4
EXIT     L     R14,12(,R13)
         LM    R0,R12,20(R13)
         BSM   0,R14               RETURN WITH AMODE
         LTORG ,
         REGS  ,                  DEFINE SYMBOLIC REG NAMES
         PUSH  PRINT
         PRINT GEN,DATA
         IEFZB505 LOCEPAX=YES      EPA MAP            (SYS1.MACLIB)
WORKAREA DSECT
WSV      DS    18F
SWEPAPTR DS    F
SWAEPAX@ DS    0A
         ORG   SWAEPAX@+L'SWAEPAX
SWAREQ   SWAREQ FCODE=LA,EPA=SWAREQ,MF=L              (SYS1.MACLIB)
SWAREQL  EQU   *-SWAREQ
TIOT     DSECT
         IEFTIOT1 ,                TIOT               (SYS1.AMODGEN)
         IEFQMIDS ,                LIST SYMBOLIC IDS  (SYS1.MACLIB)
         IEFJESCT ,                                   (SYS1.MACLIB)
         POP   PRINT
         CVT DSECT=YES,LIST=NO                        (SYS1.AMODGEN)
         END
//LKED.SYSLMOD DD DISP=SHR,
// DSN=CNB533.BHX.TEST.LOAD(RDJFCB)
./ ADD NAME=REGS
         MACRO
         REGS
         GBLB  &REGS000
         AIF   (NOT D'R0).UNDEF
&REGS000 SETB  1
         MEXIT
.UNDEF   AIF   (NOT &REGS000).OK
         MEXIT
.OK      ANOP
&REGS000 SETB  1
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
RA       EQU   10
RB       EQU   11
RC       EQU   12
RD       EQU   13
RE       EQU   14
RF       EQU   15
R10      EQU   10
R11      EQU   11
R12      EQU   12
R13      EQU   13
R14      EQU   14
R15      EQU   15
         MEND
./ ADD NAME=SAVEAREA
         MACRO -- SAVEAREA, DESCRIBE IBM STANDARD SAVEAREA
&NAME    SAVEAREA &DSECT=Y
         LCLC  &DSC,&NSECT,&TSECT
&NSECT   SETC  '&NAME'
         AIF   ('' NE '&NSECT').NAMEOK
&NSECT   SETC  'SAVEAREA'
.NAMEOK  ANOP
&DSC     SETC  'DS'
&TSECT   SETC  'DSECT'
         AIF   ('&DSECT'(1,1) EQ 'Y').YDSECT
&DSC     SETC  'DC'
&TSECT   SETC  'DS 0A'
.YDSECT  ANOP
&NSECT   &TSECT , DEFINE CSECT/DSECT
SVWORD1  &DSC  A(*-*)              RESERVED WORD
SVPREV   &DSC  A(*-*)              PREV SAVE AREA
SVNEXT   &DSC  A(*-*)              NEXT SAVE AREA
SVR14    &DSC  A(*-*)
SVR15    &DSC  A(*-*)
SVR0     &DSC  A(*-*)
SVR1     &DSC  A(*-*)
SVR2     &DSC  A(*-*)
SVR3     &DSC  A(*-*)
SVR4     &DSC  A(*-*)
SVR5     &DSC  A(*-*)
SVR6     &DSC  A(*-*)
SVR7     &DSC  A(*-*)
SVR8     &DSC  A(*-*)
SVR9     &DSC  A(*-*)
SVR10    &DSC  A(*-*)
SVR11    &DSC  A(*-*)
SVR12    &DSC  A(*-*)
         MEND
./ ADD NAME=STR@VARS
         GBLA  &CCVAL                   COND CODE VARIABLE
         GBLA  &CTR                     MACRO PARAMETER COUNTER
         GBLA  &SEQ                     LABEL NUMBER GENERATOR
         GBLA  &AI                      INDEX FOR TOTAL NO. CASES STK
         GBLA  &CI                      INDEX FOR CASE AND LBL NO. STKS
         GBLA  &II                      PTR TO INST STKS
         GBLA  &LI                      INDEX FOR LABEL NUMBER STK
         GBLA  &NI                      PTR TO NEST STK
         GBLA  &AIND(100)               TOTAL CASES STK
         GBLA  &CIND1(400)              CASE NUMBER STK
         GBLA  &MULT(100)               CASE NUMBER MULTIPLIER
         GBLA  &ST(102)                 INST STK INCREASE AT EACH LEVEL
         GBLC  &CIND2(400)              LABEL NUMBER STK FOR CASES
         GBLC  &IIND1(200)              INSTRUCTION STK 1
         GBLC  &IIND2(200)              INSTRUCTION STK 2
         GBLC  &I22(200)                INSTRUCTION STK 2, 2ND PART
         GBLC  &I23(200)                INSTRUCTION STK 2, 3RD PART
         GBLC  &I24(200)                INSTRUCTION STK 2, 4TH PART
         GBLC  &IIND3(200)              INSTRUCTION STK 3
         GBLC  &I32(200)                INSTRUCTION STK 3, 2ND PART
         GBLC  &I33(200)                INSTRUCTION STK 3, 3RD PART
         GBLC  &I34(200)                INSTRUCTION STK 3, 4TH PART
         GBLC  &IIND4(200)              INSTRUCTION STK 4
         GBLC  &I42(200)                INSTRUCTION STK 4, 2ND PART
         GBLC  &I43(200)                INSTRUCTION STK 4, 3RD PART
         GBLC  &IIND5(200)              INSTRUCTION NAME STACK
         GBLC  &LIND(202)               LABEL NUMBER STK
         GBLC  &NEST(100)               NESTING STK
         GBLC  &RIND(100)               REG STK FOR CASENTRY MACRO
./ ADD NAME=STRDOPRO
         MACRO
         STRDOPRO &FROM,&TO,&BY,&UNTIL,&WHILE,&P1
         COPY  STR@VARS
         LCLA  &I
         LCLC  &LCLWK1
           STRILAB
           STRIINS (EQU,*,,,,&LIND(&LI))
&ST(&NI)   SETA    &II+1
           STRILAB
           AIF   (T'&FROM EQ 'O').NOIND
         AIF   ('&FROM(3)' EQ '').INCR
           LA   &FROM(3),&LIND(&LI)
.INCR    ANOP
&I       SETA  &I+1
         AIF   ('&SYSLIST(&I,2)' EQ '').TEST
           AIF ('&SYSLIST(&I,2)' EQ '0').GENSR
             AIF ('&SYSLIST(&I,2)'(1,1) EQ '-').NEGVAL
               AIF (T'&SYSLIST(&I,2) EQ 'N').POSVAL
                 AIF ('&SYSLIST(&I,2)'(1,1) EQ '(').GENLR
                   L   &SYSLIST(&I,1),&SYSLIST(&I,2)
                   AGO .TEST
.GENLR           LR  &SYSLIST(&I,1),&SYSLIST(&I,2)
                 AGO .TEST
.POSVAL        AIF (&SYSLIST(&I,2) GE 4096).TSTMAG
                 LA  &SYSLIST(&I,1),&SYSLIST(&I,2)
                 AGO .TEST
.TSTMAG        AIF (&SYSLIST(&I,2) GE 32768).FULLIT
             AGO .HALFLIT
.NEGVAL      ANOP
&LCLWK1        SETC '&SYSLIST(&I,2)'(2,7)
               AIF (&LCLWK1 GE 32768).FULLIT
.HALFLIT     LH  &SYSLIST(&I,1),=H'&SYSLIST(&I,2)'
             AGO .TEST
.FULLIT      L   &SYSLIST(&I,1),=F'&SYSLIST(&I,2)'
             AGO .TEST
.GENSR     SR  &SYSLIST(&I,1),&SYSLIST(&I,1)
.TEST    AIF   (&I LT 3).INCR
           AIF   (T'&UNTIL NE 'O').ERRMG2
.CKWHILE     AIF   (T'&WHILE NE 'O').COMPGEN
&LIND(&LI) EQU   *
.POSTIND   AIF   (T'&P1 EQ 'O').GETIND
             AIF   (T'&BY NE 'O').PFB
               AIF   (T'&TO NE 'O').PFT
                 AIF   ('&FROM(3)' NE '').BCTRZ
                   STRIINS (BCT,&FROM(1),&LIND(&LI))
                 AGO   .ERRMG
.BCTRZ           STRIINS (BCTR,&FROM(1),&FROM(3))
               AGO     .ERRMG
.PFT           STRIINS (&P1,&FROM(1),&TO(1),&LIND(&LI))
             MEXIT
.PFB         STRIINS (&P1,&FROM(1),&BY(1),&LIND(&LI))
           MEXIT
.GETIND    AIF   ('&FROM(3)' EQ '').BCTR1
             STRIINS (BCTR,&FROM(1),&FROM(3))
           MEXIT
.BCTR1     AIF   (T'&BY NE 'O').FB
             AIF   (T'&TO EQ 'O').FONLY
               STRIINS (BXLE,&FROM(1),&TO(1),&LIND(&LI))
             MEXIT
.FONLY       STRIINS (BCT,&FROM(1),&LIND(&LI))
           MEXIT
.FB        AIF   (T'&TO NE 'O').FTB
             AIF   ('&BY(2)' EQ '').GENBXLE
             AIF   ('&BY(2)'(1,1) NE '-').GENBXLE
           AGO   .GENBXH
.FTB       AIF   ('&TO(2)' EQ '' OR '&FROM(2)' EQ '').GENBXLE
           AIF   ('&FROM(2)'(1,1) EQ '-').TRYTNEG
             AIF   (T'&FROM(2) NE 'N').GENBXLE
             AIF   ('&TO(2)'(1,1) EQ '-').GENBXH
             AIF   (T'&TO(2) NE 'N').GENBXLE
             AIF   (&FROM(2) GT &TO(2)).GENBXH
.GENBXLE   STRIINS (BXLE,&FROM(1),&BY(1),&LIND(&LI))
           MEXIT
.TRYTNEG   AIF   ('&TO(2)'(1,1) NE '-').GENBXLE
           AIF   ('&FROM(2)'(2,7) GE '&TO(2)'(2,7)).GENBXLE
.GENBXH    STRIINS (BXH,&FROM(1),&BY(1),&LIND(&LI))
           MEXIT
.NOIND       AIF   (T'&WHILE EQ 'O').NOWHILE
               AIF   (T'&UNTIL NE 'O').COMPGEN
                 BC    15,&LIND(&LI)
                 STRILAB
&LI              SETA &LI-1
&LIND(&LI+1)     EQU  *
                 AIF   ('&WHILE(6)' EQ '').OKSUBL
                   STRSTINS &WHILE
                   MEXIT
.OKSUBL          STRSTINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),    X
               &WHILE(5),&LIND(&LI))
                 AIF   ('&WHILE(2)' EQ '').LABEL
                   STRIINS (BC,&CCVAL,&LIND(&LI+1))
                   MEXIT
.LABEL           STRIINS   (BC,&CCVAL,&LIND(&LI+1),,,&LIND(&LI))
                 MEXIT
.NOWHILE     AIF   (T'&UNTIL EQ 'O').TRYINF
&LIND(&LI)   EQU   *
.UNT           STRSTINS &UNTIL
               STRIINS (BC,15-&CCVAL,&LIND(&LI))
             MEXIT
.TRYINF        AIF   ('&P1' NE 'INF').ERRMG1
&LIND(&LI)       EQU *
                 STRIINS (BC,15,&LIND(&LI))
               MEXIT
.COMPGEN     AIF   ('&WHILE(6)' EQ '').OK
               STRSTINS &WHILE
               AGO   .BCHINST
.OK          STRSTINS (&WHILE(1),&WHILE(2),&WHILE(3),&WHILE(4),        X
               &WHILE(5),&LIND(&LI))
             AIF   (N'&WHILE GT 1).ENDCOMP
&LIND(&LI)     BC    15-&CCVAL,&LIND(&LI-1)
               AGO   .FLAGEQU
.ENDCOMP     ANOP
&ST(&NI+1)   SETA  &II
             STROINS &ST(&NI+1)
.BCHINST     BC    15-&CCVAL,&LIND(&LI-1)
.FLAGEQU     ANOP
&NEST(&NI)   SETC  '   Y'.'&NEST(&NI)'(5,4)
             AIF   (T'&FROM NE 'O').POSTIND
           AGO   .UNT
.ERRMG   MNOTE 4,'POSITIONAL PARAMETER IGNORED. BCT/BCTR LOOP END USED'
         MEXIT
.ERRMG2  MNOTE 4,'UNTIL KEYWORD INVALID WITH INDEXING GROUP. IGNORED'
         AGO   .CKWHILE
.ERRMG1  MNOTE 4,'NO WHILE,UNTIL,OR INDEXING PARAMETERS ON DO MACRO.'
         MEND
./ ADD NAME=STRGETCC
         MACRO
         STRGETCC &COND
         GBLA  &CCVAL
         LCLC  &LWK1
         AIF   ('&COND'(1,1) LT '0' OR '&COND'(1,1) GT '9').NOTNUM
&CCVAL     SETA  &COND
           MEXIT
.NOTNUM  AIF   (K'&COND NE 1).TWOCHAR
&LWK1      SETC  '&COND'
           AGO   .CALCC
.TWOCHAR AIF   (K'&COND NE 2).INVCOND
           AIF   ('&COND'(1,1) NE 'N').OTHERMN
&LWK1        SETC  '&COND'(2,1)
           AGO   .CALCC
.OTHERMN   AIF   ('&COND' EQ 'EQ').BC8
           AIF   ('&COND' EQ 'LT').BC4
           AIF   ('&COND' NE 'LE').TRYGT
&CCVAL       SETA  13
           MEXIT
.TRYGT     AIF   ('&COND' EQ 'GT').BC2
           AIF   ('&COND' NE 'GE').INVCOND
&CCVAL       SETA  11
           MEXIT
.CALCC   AIF   ('&LWK1' NE 'O').TRYH
&CCVAL     SETA 1
         AGO   .TSTN
.TRYH    AIF   ('&LWK1' EQ 'P' OR '&LWK1' EQ 'H').BC2
           AIF ('&LWK1' EQ 'L' OR '&LWK1' EQ 'M').BC4
             AIF ('&LWK1' EQ 'E' OR '&LWK1' EQ 'Z').BC8
               AGO   .INVCOND
.BC8         ANOP
&CCVAL       SETA 8
             AGO   .TSTN
.BC4       ANOP
&CCVAL     SETA 4
           AGO   .TSTN
.BC2     ANOP
&CCVAL   SETA  2
.TSTN    AIF   ('&COND'(1,1) NE 'N').DONE
&CCVAL       SETA  15-&CCVAL
.DONE    MEXIT
.INVCOND ANOP
&CCVAL   SETA  15
         MNOTE 4,'INVALID CONDITION MNEMONIC. NOP GENERATED'
         MEND
./ ADD NAME=STRIFPRO
           MACRO
           STRIFPRO
           COPY  STR@VARS
           LCLB &ANDIND,&ORIND
           STRILAB
&CTR       SETA 2
&ST(&NI+1) SETA &II+1
&NEST(&NI) SETC '  R'.'&NEST(&NI)'(4,5)
           AIF  (T'&SYSLIST(1) EQ 'O').LOOP
           AIF (&SYSLIST(1) LE 0 OR &SYSLIST(1) GE 15).INVALCC
&CCVAL       SETA &SYSLIST(1)
             AIF ('&SYSLIST(2)' EQ '').ENDBOOL
         MNOTE 4,'CC KEYWORD USED. OTHER PARAMETERS IGNORED'
         AGO .ENDBOOL
.INVALCC MNOTE 4,'CC OUTSIDE VALID RANGE OF 1 TO 14. NOP GENERATED'
&CCVAL   SETA  15
           AGO .ENDBOOL
.LOOP      STRSTINS &SYSLIST(&CTR),&SYSLIST(&CTR+1),&SYSLIST(&CTR+2),  X
               &SYSLIST(&CTR+3),&SYSLIST(&CTR+4)
           AIF ('&SYSLIST(&CTR+1)' EQ 'AND').ANDPROC
           AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF').TESTOR
.ANDPROC     STRIINS (BC,15-&CCVAL,&LIND(&LI-1))
&ANDIND      SETB 1
             AIF ('&SYSLIST(&CTR+1)' NE 'ANDIF' OR NOT &ORIND).TESTLP
               STROINS &ST(&NI+1)
&LIND(&LI)     EQU *
&ORIND         SETB 0
&LI            SETA &LI-1
               STRILAB
             AGO .TESTLP
.TESTOR    AIF ('&SYSLIST(&CTR+1)' EQ 'OR').ORPROC
           AIF ('&SYSLIST(&CTR+1)' NE 'ORIF').TESTLP
.ORPROC      STRIINS (BC,&CCVAL,&LIND(&LI))
&ORIND       SETB 1
             AIF ('&SYSLIST(&CTR+1)' NE 'ORIF' OR NOT &ANDIND).TESTLP
               STRIINS (EQU,*,,,,&LIND(&LI-1))
&ANDIND        SETB 0
               STRILAB
&LI            SETA &LI-1
&LIND(&LI-1)   SETC '&LIND(&LI+1)'
.TESTLP    ANOP
&CTR       SETA &CTR+2
           AIF ('&SYSLIST(&CTR-1)' NE '').LOOP
.ENDBOOL     AIF ('&NEST(&NI)'(5,4) EQ 'DO').DOEND
             STROINS &ST(&NI+1)
             BC 15-&CCVAL,&LIND(&LI-1)
             AIF (NOT &ORIND).POPLBL
&LIND(&LI)     EQU *
.POPLBL      ANOP
&LI          SETA &LI-1
           MEXIT
.DOEND     ANOP
&CTR       SETA  &ST(&NI+1)
           AGO   .ENDLBL
.NXTLBL    AIF   ('&IIND3(&CTR)' NE '&LIND(&LI)').INCTR
&IIND3(&CTR) SETC  '&LIND(&LI-3)'
.INCTR     ANOP
&CTR       SETA  &CTR+1
.ENDLBL    AIF   (&CTR LE &II).NXTLBL
           STROINS &ST(&NI+1)
           BC    &CCVAL,&LIND(&LI-3)
           AIF   (NOT &ANDIND).POP2LBL
&LIND(&LI-1) EQU  *
.POP2LBL   ANOP
&LI        SETA   &LI-2
&NEST(&NI) SETC  '   Y'.'&NEST(&NI)'(5,4)
           MEND
./ ADD NAME=STRIINS
             MACRO
             STRIINS &PAM
             COPY STR@VARS
             LCLA &WK,&I,&J,&K
&I           SETA  3
&J           SETA  4
&K           SETA  4
             AIF ('&PAM(1)'(1,1) EQ 'B' OR '&PAM(1)' EQ 'EQU').BCH
               AIF ('&PAM(5)' EQ '').TWOPERS
                 AIF ('&PAM(1)'(1,1) EQ 'C').SETK
&J                 SETA  5
                 AGO .GETCOND
.TWOPERS       AIF ('&PAM(1)'(1,1) NE 'C').SETK
&I             SETA  4
&J             SETA  3
.SETK          ANOP
&K             SETA  5
.GETCOND         STRGETCC &PAM(&J)
.BCH         AIF   (&II GE 200).OVERI
&II            SETA  &II+1
&IIND1(&II)    SETC '&PAM(1)'
&IIND2(&II)    SETC '&PAM(2)'(1,8)
&WK        SETA K'&SYSLIST(1,2)
           AIF  (&WK GE 25).LD24
&I24(&II)    SETC ''
             AIF (&WK GE 17).LD23
&I23(&II)      SETC ''
               AIF (&WK GE 9).LD22
&I22(&II)        SETC ''
                 AGO .PAM3
.LD24          ANOP
&I24(&II)      SETC '&PAM(2)'(25,8)
.LD23        ANOP
&I23(&II)    SETC '&PAM(2)'(17,8)
.LD22      ANOP
&I22(&II)  SETC  '&PAM(2)'(9,8)
.PAM3      AIF ('&PAM(&I)' NE '').LD31
&IIND3(&II)  SETC ''
             AGO  .BLKOUT3
.LD31      ANOP
&IIND3(&II)    SETC '&PAM(&I)'(1,8)
.BLKOUT3   ANOP
&WK        SETA K'&SYSLIST(1,&I)
           AIF  (&WK GE 25).LD34
&I34(&II)    SETC ''
             AIF (&WK GE 17).LD33
&I33(&II)      SETC ''
               AIF (&WK GE 9).LD32
&I32(&II)        SETC ''
                 AGO .PAM4
.LD34          ANOP
&I34(&II)      SETC '&PAM(&I)'(25,8)
.LD33        ANOP
&I33(&II)    SETC '&PAM(&I)'(17,8)
.LD32      ANOP
&I32(&II)  SETC  '&PAM(&I)'(9,8)
.PAM4      AIF ('&PAM(&K)' NE '').LD41
&IIND4(&II)  SETC ''
             AGO  .BLKOUT4
.LD41      ANOP
&IIND4(&II)  SETC '&PAM(&K)'(1,8)
.BLKOUT4   ANOP
&WK        SETA K'&SYSLIST(1,&K)
           AIF (&WK GE 17).LD43
&I43(&II)    SETC ''
             AIF (&WK GE 9).LD42
&I42(&II)      SETC ''
               AGO .PAM5
.LD43        ANOP
&I43(&II)    SETC '&PAM(&K)'(17,8)
.LD42      ANOP
&I42(&II)  SETC '&PAM(&K)'(9,8)
.PAM5      AIF ('&PAM(6)' EQ '').BLKOUT5
             AIF ('&PAM(6)'(1,4) NE '#@LB').BLKOUT5
&IIND5(&II)    SETC '&PAM(6)'
             MEXIT
.BLKOUT5   ANOP
&IIND5(&II)  SETC ''
           MEXIT
.OVERI   MNOTE 8,'INSTRN STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'
         MEND
./ ADD NAME=STRILAB
         MACRO
         STRILAB
         COPY STR@VARS
         AIF   (&LI GE 200).OVER
&SEQ       SETA  &SEQ+1
&LI        SETA  &LI+1
&LIND(&LI) SETC '#@LB&SEQ'
         MEXIT
.OVER    MNOTE 8,' LABEL STK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'
           MEND
./ ADD NAME=STRINEST
         MACRO
         STRINEST &P1
         COPY STR@VARS
&NI      SETA  &NI+1
         AIF   (&NI GE 100).OVER
&NEST(&NI) SETC '    '.'&P1'
         MEXIT
.OVER    MNOTE 8,'NEST STACK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'
         MEND
./ ADD NAME=STRINEXT
         MACRO
         STRINEST &P1
         COPY STR@VARS
&NI      SETA  &NI+1
         AIF   (&NI GE 100).OVER
&NEST(&NI) SETC '    '.'&P1'
         MEXIT
.OVER    MNOTE 8,'NEST STACK SIZE EXCEEDED. FURTHER EXPANSIONS INVALID'
         MEND
./ ADD NAME=STROINS
         MACRO
         STROINS &P
         COPY   STR@VARS
         LCLA   &W
&W       SETA   &P
         AGO    .TEST
.UNSTACK   AIF  ('&IIND3(&W)' EQ '').ONEOP
             AIF ('&IIND4(&W)' NE '').THREEOP
&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)X
               &I32(&W)&I33(&W)&I34(&W)
             AGO .INCTR
.THREEOP       ANOP
&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W),&IIND3(&W)X
               &I32(&W)&I33(&W)&I34(&W),&IIND4(&W)&I42(&W)&I43(&W)
             AGO .INCTR
.ONEOP     ANOP
&IIND5(&W)     &IIND1(&W) &IIND2(&W)&I22(&W)&I23(&W)&I24(&W)
.INCTR     ANOP
&W         SETA  &W+1
.TEST    AIF    (&W LE &II).UNSTACK
&II      SETA   &P-1
         AIF ('&NEST(&NI)'(3,1) NE ' ' OR '&NEST(&NI)'(4,1) EQ ' ').NEQ
&IIND5(&II) &IIND1(&II) &IIND2(&II)
.NEQ     AIF (&II GT 0 OR (&II EQ 0 AND '&NEST(&NI)'(5,4) EQ 'IF')).END
         MNOTE 8,'NEGATIVE INSTRUCTION STACK PTR. EXPANSION INVALID.'
.END     MEND
./ ADD NAME=STRONEST
         MACRO
         STRONEST &P1
         COPY STR@VARS
         LCLC  &SUFFIX
&SUFFIX  SETC  '&NEST(&NI)'(5,4)
         AIF   ('&NEST(&NI)'(5,4) EQ '&P1').GOOD
         MNOTE 8,'&SUFFIX MACRO AT SAME LEVEL AS &P1 TERMINATOR.'
.GOOD    ANOP
&NI      SETA  &NI-1
         AIF   (&NI GE 0).OK
         MNOTE 8,'NEGATIVE NEST STACK POINTER. CHECK NUMBER OF ENDS.'
.OK      MEND
./ ADD NAME=STRSTINS
         MACRO
         STRSTINS &P1,&P2,&P3,&P4,&P5,&P6
         COPY  STR@VARS
         AIF    ('&P1(2)' EQ '').NOTSUBL
           AIF ('&P1(6)' EQ '' OR '&P1(6)' EQ '&LIND(&LI)').OKSUBL
             MNOTE 12,'TOO MANY OPERANDS INSIDE PARENTHESES'
             MEXIT
.OKSUBL      STRIINS (&P1(1),&P1(2),&P1(3),&P1(4),&P1(5),&P1(6))
             MEXIT
.NOTSUBL AIF   ('&P2' EQ '' OR '&P2' EQ 'OR' OR '&P2' EQ 'AND' OR '&P2'X
               EQ 'ORIF' OR '&P2' EQ 'ANDIF').SGLOPR
           AIF ('&P5' EQ 'OR' OR '&P5' EQ 'AND' OR '&P5' EQ 'ORIF' OR  X
               '&P5' EQ 'ANDIF').TWOPER2
             STRIINS (&P1,&P2,&P3,&P4,&P5,&P6)
&CTR         SETA  &CTR+4
             MEXIT
.TWOPER2   STRIINS (&P1,&P2,&P3,&P4,,&P6)
&CTR         SETA  &CTR+3
             MEXIT
.SGLOPR  STRGETCC &P1(1)
         MEND
./ ADD NAME=STRTDO
         MACRO
         STRTDO &P1,&FROM=,&TO=,&BY=,&UNTIL=,&WHILE=
         STRINEST DO
       STRDOPRO &FROM,&TO,&BY,&UNTIL,&WHILE,&P1
         MEND
./ ADD NAME=STRTSRCH
         MACRO
         STRTSRCH &P1,&FROM=,&TO=,&BY=,&UNTIL=,&WHILE=
           PUSHLAB
           PUSHNEST SRCH
         DOPROC &FROM,&TO,&BY,&UNTIL,&WHILE,&P1
           PUSHLAB
         MEND
./ ADD NAME=SVC99RBM
//BHXU99RB JOB (B533,SYBN),'HOGMAN   SVC99RBM   ',
// MSGCLASS=3,TIME=(2)
/*PHOLD
/*PROCLIB CNB533.BHX.PROCLIB
//PORTRAIT OUTPUT PAGEDEF=M132C1,CLASS=3,DEFAULT=Y,JESDS=ALL
//SVC99RBM EXEC ASMHCL,AOPT=RENT,LOPT='AC=1,RENT,REFR,REUS'
 TITLE 'SVC99RBM -- SUBR MOVE SVC 99 RB TO GOTTEN STORAGE'
*=====================================================================*
*                                                                     *
*     DEPT OF ENERGY, ENERGY INFORMATION ADMINISTRATION (EIA)         *
*     FORRESTAL BLDG. BG-056/EI-10, 1000 INDEPENDENCE AVE., S.W.      *
*     WASHINGTON DC 20585  (EDS CORP.:  BHX B.HOGMAN (202)586-1965    *
*                                                                     *
*=====================================================================*
**********************************************************************
*
*     3SG  SYSTEMS SOFTWARE SUPPORT SYSTEM
*          U.S. CUSTOMS SERVICE -- FRANCONIA, VIRGINIA CENTER
*
* > TITLE: SVC99RBM -- SUBR MOVE SVC 99 RB TO GOTTEN STORAGE
*
* ++++++ NAME: SVC99RBM  AUTHOR: BRUCE E. HOGMAN  DATE: 83-03-01
*
*        SOURCE CODE: SYSTEM SOURCE LIBRARY
*
*        LOAD MODULE: SYSTEM SUBRTN LOAD    ATTR:  RENT,REFR,REUS
*                                           SELF-RELATIVE RELOCATABLE
*        PROC:        (NONE)
*
* ++++++ CHANGE ACTIVITY:               DATE INSTALLED: 83-03-01
*        91-02-27 BHX B.HOGMAN IMPORTED TO DEPT OF ENERGY EIA
*        89-07-17 BQH UPDATED TO PERMIT USE OF LKED DXD NOT GETMAIN
*        86-07-16 BQH UPDATED FOR XA SUPPORT
*
* ++++++ FUNCTION: (NARRATIVE)
*
*     >  THIS SUBR MOVES A REQUEST BLOCK FOR SVC99 FROM ONE LOCATION
*        TO ANOTHER IN STORAGE, ADJUSTING ALL TEXT POINTERS.  THE
*        RB MUST HAVE BEEN CONSTRUCTED BY ONE OF THE ALLOC MACROS,
*        SVC99RET, OR UNALLOC MACRO, SINCE IT DEPENDS UPON A CERTAIN
*        FORMAT:  THE RB IS CONTIGUOUS.
*
* ++++++ DEPENDENCIES: (SPECIAL MACROS, CALLS/LINKS, FILES)
*
*     >  STRUCTURED PROGRAMMING MACROS.
*
* ++++++ CONTROL BLOCKS:
*        SVC 99 RB IS MOVED
*
*        C - CREATED, M - MODIFIED, R - REFERENCED, D - DELETED
*
* ++++++ INVOKING:     (HOW DO YOU USE THIS?)
*
*     >  INPUT:  CALL SVC99RBM,(FROM,TO)
*                THE "FROM" AND "TO" ARGUMENTS ARE THE NAMES OF
*                "LIST" FORMAT SVC 99 REQUEST BLOCKS BUILT BY THE
*                ALLOC MACRO.
*                OPTIONAL:  IF THIRD PARAMETER PASSED, IT IS ADDRESS
*                OF WORKAREA PRE-ALLOCATED TO USE FOR WORKAREA.
*
*     >  OUTPUT: THE "TO" AREA NAMED CONTAINS THE COPIED SVC 99 RB.
*
**********************************************************************
         EJECT
         PRINT NOGEN
SVC99RBM CSECT
SVC99RBM AMODE 31
SVC99RBM RMODE ANY
         GBLC  &YYMMDD
         YYMMDD
         REGS
         SAVE  (14,12),,'SVC99RBM &YYMMDD &SYSTIME EDS BHX SUBRTN SVC99+
                RB COPY'
         LR    R12,R15             LOAD BASE REG
         USING SVC99RBM,R12        DECLARE BASE REG
         LR    R11,R1              COPY PARMS ADDRESS
         L     R0,WORKSIZE         PICK UP SIZE OF WORKAREA
         LR    R3,R0               COPY SIZE FOR MVCL
         IF (TM,4(R1),X'80',O),OR,(ICM,R1,15,8(R1),Z)
            GETMAIN RU,LV=(0)
         ENDIF ,
         LR    R2,R1            COPY LOCATION
         LR    R4,R12           DUMMY @ FOR MVCL
         SLR   R5,R5            CLEAR FOR MVCL
         MVCL  R2,R4
         ST    R13,4(,R1)
         ST    R1,8(,R13)
         LR    R13,R1
         USING WORKAREA,R13
         ST    R11,@PARMS
         L     R1,@PARMS
         L     R6,0(,R1)          PICK UP FROM @
         L     R7,4(,R1)          PICK UP TO   @
         LA    R6,0(,R6)
         LA    R7,0(,R7)
********
*
* IF USER HAS SPECIFIED LIST-NAME OF ALLOC MACRO, THEN ARGUMENT
* POINTS TO A BRANCH INSTRUCTION AND WE MUST ADJUST THE POINTERS.
*
********
         IF (CLI,0(R6),EQ,X'47'),AND,(TM,1(R6),X'F0',O)
            MVC   0(4,R7),0(R6)   MOVE THE BRANCH INSTRUCTION
            LA    R6,4(,R6)
            LA    R7,4(,R7)
         ENDIF ,
********
*
* COMPUTE SIZE OF RB TO MOVE.
*
********
         USING SVC99RB,R6
         L     R1,S99RB@Z         GET LOC FIRST TEXT @ PTR
         DOLOOP WHILE=(TM,0(R1),X'80',NO)
            LA    R1,4(,R1)
         ENDDO ,
         L     R1,0(,R1)          POINT TO TEXT UNIT
         LA    R1,0(,R1)
         SR    R2,R2
         ICM   R2,B'0011',2(R1)   PICK UP COUNT OF FIELDS
         LA    R1,4(,R1)          ACCOUNT FOR KEY, COUNT OF FIELDS
         DOLOOP WHILE=(LTR,R2,R2,P)
            AH    R1,0(,R1)       ADD THE LENGTH OF THE PARAMETER
            LA    R1,2(,R1)       COUNT THE LENGTH OF THE LENGTH
            BCTR  R2,0
         ENDDO ,
         SR    R1,R6              COMPUTE TOTAL SIZE
         DROP  R6
********
*
* MOVE THE RB.
*
********
         LR    R2,R6
         LR    R3,R7
         DOLOOP WHILE=(C,R1,GT,=A(256))
            MVC   0(256,R3),0(R2)
            LA    R2,256(,R2)
            LA    R3,256(,R3)
            S     R1,=A(256)
         ENDDO ,
         IF (LTR,R1,R1,P)
            BCTR  R1,0
            MVC   0(*-*,R3),0(R2)
            EX    R1,*-6
         ENDIF ,
********
*
* ADJUST THE ADDRESSES IN THE COPIED RB
*
********
         USING SVC99RB,R7
         LR    R5,R7              COPY THE "TO" ADDRESS
         SR    R5,R6              COMPUTE SIGNED DIFFERENCE
         L     R1,S99RBPTR
         L     R0,=A(X'7FFFFFFF')
         NR    R1,R0
         AR    R1,R5
         ST    R1,S99RBPTR
         OI    S99RBPTR,X'80'     FORCE BIT ON
         L     R1,S99RB@Z
         NR    R1,R0
         AR    R1,R5
         ST    R1,S99RB@Z
         L     R4,S99RB@Z         POINT TO FIRST @ PTR
         DROP  R7
         L     R3,=A(X'80000000')
         DOLOOP INF               EXIT VIA INTERNAL DOEXIT
            L     R1,0(,R4)
            L     R2,0(,R4)
            NR    R2,R3           LEAVE ONLY LEFT BIT, IF ON
            NR    R1,R0
            AR    R1,R5
            OR    R1,R2
            ST    R1,0(,R4)
            DOEXIT (TM,0(R4),X'80',O)
            LA    R4,4(,R4)
         ENDDO ,
         OI    0(R4),X'80'
         SLR   R2,R2               CLEAR FOR RC
         L     R0,WORKSIZE
         L     R11,@PARMS          POINT TO INPUT PARM
         LR    R1,R13              POINT TO WORKAREA
         L     R13,4(,R13)         POINT TO PREV SAVE AREA
         IF (TM,4(R11),X'80',O),OR,(ICM,R11,15,8(R11),Z)
            FREEMAIN RU,LV=(0),A=(1)
         ENDIF ,
         LR    R15,R2
         RETURN (14,12),,RC=(15)
*        FORMAT OF SVC 99 RB BUILT BY ALLOC MACROS:
*
*      THIS SUBROUTINE DEPENDS UPON THE TEXT UNITS BEING CONTIGUOUS
*      WITHIN THE REQUEST BLOCK IN THE SAME RELATIVE ORDER AS THE
*      ADDRESS POINTERS.  IN OTHER WORDS, THE LAST TEXT UNIT IS LOCATED
*      PHYSICALLY AFTER THE TEXT UNIT WHOSE TEXT UNIT ADDRESS POINTER
*      IMMEDIATELY PRECEDES THE POINTER TO THE LAST TEXT UNIT.  IN THIS
*      WAY, THE SUBROUTINE CAN LOCATE THE LAST BYTE OF THE RB TO MOVE.
*      THE LAST TEXT UNIT MUST ALSO HAVE A COUNT OF ONE.
*
SVC99RB  DSECT
S99RBPTR DS    A POINTER TO RB PROPER
S99RB    DS    5A                 BASE RB
         ORG   S99RB
S99RBLEN DS    HL1                LENGTH OF RB (X'14')
S99RBVRB DS    HL1                VERB CODE
S99RBFL1 DS    Y                  FLAGS1
S99RBERR DS    Y                  ERROR CODE
S99RBINF DS    Y                  INFORMATION CODE
S99RB@Z  DS    A                  ADDRESS OF FIRST TEXT POINTER
S99RBRES DS    A                  RESERVED
S99RBFL2 DS    A                  FLAGS2
S99RBTX@ DS    A ---------------- TEXT POINTERS (MAY NOT BE CONTIG)
S99RBTXU DS    0CL1               TEXT UNITS
SVC99RBM CSECT
WORKAREA DSECT
WORKSAVE DS    18F
@PARMS   DS    A
WORKZZZZ DS    0D                 DEFINE END OF WORKAREA
SVC99RBM CSECT
WORKSIZE DC    A(WORKZZZZ-WORKAREA)
         LTORG
         END
//LKED.SYSLMOD DD DISP=SHR,
// DSN=CNB533.BHX.TEST.LOAD(SVC99RBM)
./ ADD NAME=UNALLOC
         MACRO
&NAME    UNALLOC &DD,&INUSE=NO
         GBLC  &UNALCNT
         LCLA  &K,&I,&J
         LCLB  &B,&NB,&DDI
         LCLC  &C
         CNOP  0,4                 ALIGN TO FULLWORD BOUNDARY
&UNALCNT SETC  '&SYSNDX'
&NAME    B     S99Z&SYSNDX         GO AROUND S99 REQUEST BLOCK
S99R&SYSNDX DC A(*+4+X'80000000'),X'14021000',A(0,*+12,0,0)
&K       SETA  K'&DD
&B       SETB  ('&INUSE' NE 'NO')
&NB      SETB  (NOT &B)
         AIF   (&B).INUSE
S01P&SYSNDX DC A(S01T&SYSNDX) TXT U PNTR TO DDNAME
S07P&SYSNDX DC A(S07T&SYSNDX+X'80000000') TXT U PNTR TO UNALLOC
         AGO   .MAIN
.INUSE   ANOP
S01P&SYSNDX DC A(S01T&SYSNDX) TXT U PNTR TO DDNAME
S08P&SYSNDX DC A(S08T&SYSNDX+X'80000000') TXT U PNTR TO INUSE KEY
.MAIN    ANOP
&DDI     SETB  ('&DD'(1,3) EQ '(*,')
         AIF   (NOT &DDI).LITDD
&I       SETA  K'&DD-4 ACCOUNT FOR (*,...)
&C       SETC  '&DD'(4,&I)
S01T&SYSNDX DC AL2(1,1,8),CL8' ' DDNAME TO UNALLOCATE (INDIRECT)
         AGO   .MAINDD
.LITDD   ANOP
S01T&SYSNDX DC AL2(1,1,&K),CL8'&DD' DDNAME TO UNALLOCATE
.MAINDD  ANOP
S07T&SYSNDX DC &NB.AL2(7,0) EVEN PERMANENTLY ALLOCATED
S08T&SYSNDX DC &B.AL2(8,0) REMOVE INUSE FLAG ONLY
S99Z&SYSNDX DS 0H
         AIF   (NOT &DDI).NOTDDI1
         SR    15,15
         ICM   15,3,&C             PICK UP LENGTH
         LA    15,1(15)            ADJUST TO INCLUDE LENGTH ALSO
         MVC   S01T&SYSNDX+4(*-*),&C MOVE BOTH LENGTH AND ITEM
         EX    15,*-6              MOVE THE ITEM
.NOTDDI1 LA    1,S99R&SYSNDX
         SVC   99
         L     0,S99R&SYSNDX+8     LOAD THE ERROR AND INFO RETURN CODES
         MEND
./ ADD NAME=XAMODE
         MACRO
&NAME    XAMODE &TYPE,&REG=R15,&SVREG=0
         AIF   ('24' EQ '&TYPE').A24
         AIF   ('31' EQ '&TYPE').A31
&NAME    LA    &REG,*+10
         O     &REG,&TYPE
         AGO   .BSM
.A31     ANOP
&NAME    LA    &REG,*+10
         O     &REG,=A(X'80000000') INSERT AMODE31 BIT
         AGO   .BSM
.A24     ANOP
&NAME    LA    &REG,*+6 REMOVE AMODE31 BIT
.BSM     BSM   &SVREG,&REG SET MODE AND BRANCH TO NEXT INSTR
         MEXIT
.AMODE   ANOP
         MNOTE 8,'XAMODE=24/31 ONLY'
         MEND
./ ADD NAME=YESNO
         MACRO
         YESNO
         GBLB  &YESNO00
         AIF   (NOT &YESNO00).OK
         MEXIT
.OK      ANOP
&YESNO00 SETB  1
YES      EQU   X'55'
NO       EQU   X'AA'
         MEND
./ ADD NAME=YYMMDD
         MACRO
         YYMMDD
.*             THIS MACRO RETURNS GLOBAL VARIABLE YYMMDD IN THAT FORM
         GBLC  &YYMMDD
&YYMMDD  SETC  '&SYSDATE'(7,2)
&YYMMDD  SETC  '&YYMMDD'.'&SYSDATE'(1,2)
&YYMMDD  SETC  '&YYMMDD'.'&SYSDATE'(4,2)
         MEND
./ ADD NAME=ZSTACK
         MACRO
         ZSTACK
.*       THIS MACRO COPIED FROM CHKSTACK.  IT DOES CHKSTACK FUNCTION
.*       AND FORCES EMPTY EACH STACK TO LIMIT ASSEMBLY ERRORS.
.*       BQH 82-07-24
         GBLA  &AI,&CI,&II,&LI,&NI
         LCLA  &SI
         LCLC  &STACK(5)
            AIF   (&AI EQ 0).FIXC
            AIF   (&AI GT 0).GTAI
              MNOTE 8,'TOTLCASE STACK POINTER NEGATIVE: FORCED ZERO'
&AI           SETA  0
            AGO   .FIXC
.GTAI       ANOP
&SI           SETA  &SI+1
&STACK(&SI)   SETC  'TOTLCASE'
&AI           SETA  0
.FIXC       AIF   (&CI EQ 0).FIXI
            AIF   (&CI GT 0).GTCI
              MNOTE 8,'CASELABL STACK POINTER NEGATIVE: FORCED ZERO'
&CI           SETA  0
            AGO   .FIXI
.GTCI       ANOP
&SI           SETA  &SI+1
&STACK(&SI)   SETC  'CASELABL'
&CI           SETA  0
.FIXI       AIF   (&II EQ 0).FIXL
            AIF   (&II GT 0).GTII
              MNOTE 8,'INSTRCTN STACK POINTER NEGATIVE: FORCED ZERO'
&II           SETA  0
            AGO   .FIXL
.GTII       ANOP
&SI           SETA  &SI+1
&STACK(&SI)   SETC  'INSTRCTN'
&II           SETA  0
.FIXL       AIF   (&LI EQ 0).FIXN
            AIF   (&LI GT 0).GTLI
              MNOTE 8,'LABEL STACK POINTER NEGATIVE: FORCED ZERO'
&LI           SETA  0
            AGO   .FIXN
.GTLI       ANOP
&SI           SETA  &SI+1
&STACK(&SI)   SETC  'LABEL'
&LI           SETA  0
.FIXN       AIF   (&NI EQ 0).TEST
            AIF   (&NI GT 0).GTNI
              MNOTE 8,'NESTING STACK POINTER NEGATIVE: FORCED ZERO'
&NI           SETA  0
            AGO   .TEST
.GTNI       ANOP
&SI           SETA  &SI+1
&STACK(&SI)   SETC  'NESTING'
&NI           SETA  0
.TEST       AIF   (&SI EQ 0).END
              MNOTE 8,'&STACK(&SI) STACK NOT EMPTY'
              MNOTE 4,'&STACK(&SI) FORCED EMPTY NOW.************'
&SI           SETA  &SI-1
              AGO   .TEST
.END        MEND

