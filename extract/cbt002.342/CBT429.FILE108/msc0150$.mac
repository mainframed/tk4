//MSC0150$ JOB (H2803302,S17,,8),'S17 ASSEMBLE&LINK',TIME=(,4)
/*JOBPARM Q=T,I
// EXEC ASMPCL,COPT=',RENT',LOPT=',RENT',
//     PDS='SYS1.LINK2LIB',NAME=MSC0150$,COND=(0,NE)
//P.SYSIN    DD  *
MSC0150 TITLE 'STRUCTURED MACRO LISTING PROGRAM'
*---------------------------------------------------------------------*
*
*  CSECT: MSC0150
*
*  COPYRIGHT: (C) COPYRIGHT CLEMSON UNIVERSITY 1983, 1988.
*
*  ABSTRACT: THIS PROGRAM READS AN ASSEMBLER SOURCE PROGRAM CONTAINING
*            THE CLEMSON STRUCTURED MACROS AND PRODUCES A LISTING
*            WITH TITLING, SPACING, AND NESTING INFORMATION.  THE
*            ASSEMBLER SOURCE IS WRITTEN TO DDNAME SYSPUNCH FOR
*            FURTHER PROCESSING BY THE ASSEMBLER.  SOME ERROR CHECKING
*            IS DONE FOR STRUCTURAL PROBLEMS BUT THIS CHECKING
*            IS BY NO MEANS EXTENSIVE.
*
*  FILES: SYSIN    - SOURCE INPUT FILE
*         SYSPRINT - LISTING FILE
*         SYSPUNCH - SOURCE OUTPUT FILE
*
*  RETURN CODES:  0 - GOOD
*                 4 - A WARNING ERROR WAS ENCOUNTERED
*                 8 - A ERROR WAS ENCOUNTERED
*                16 - A SEVERE ERROR CAUSED THE PROGRAM TO TERMINATE
*
*  ATTRIBUTES: REENTRENT, AMODE 24, RMODE 24
*
*  DEPENDENCIES: DEFAULT ICTL IS REQUIRED FOR SYSIN.  THIS ASSMEMBLY
*                REQUIRES THE CLEMSON STRUCTURED MACROS.
*
*  METHOD OF OPERATION:
*
*     OPEN FILES
*     READ FIRST SYSIN RECORD
*     DO WHILE NOT END OF FILE ON SYSIN
*       WRITE RECORD TO SYSPUNCH
*       IF NOT COMMENT CARD OR CONTINUED LINE
*         SCAN FOR OPCODE
*         IF OPCODE IS ONE OF THE STRUCTURED MACRO THAT START OR END
*           A STRUCTURE OR MACRO OR MEND , DO NESTING AND UNNESTING
*           PROCESSING FOR LISTING
*         ELSEIF 'SPACE', 'TITLE', OR 'EJECT', DO APPROPRIATE
*           LISTING PROCESSING
*       ENDIF
*       DO CONTINUATION PROCESSING
*       PRINT TITLE AND HEADING IF OVERFLOW
*       PRINT LINE IF APPROPRIATE
*       READ NEXT SYSIN RECORD
*     ENDDO
*     CLOSE FILES
*     RETURN
*
*  MODULE ACTIVITY:  MGG 07/29/83 NEW
*                    MGG 09/04/84 FIXED TITLE STATMENT PROCESSING.
*                                 PUT IN CONTINUED STATEMENT CHECK.
*                                 INSTREAM MACRO SUPPORT
*                                 GENERAL CLEANUP
*                    MGG 01/29/87 RESTRUCTURED AND REMOVED @CN.
*                    MGG  8/08/88 ADDED SMLIST SUPPORT              @C4
*---------------------------------------------------------------------*
  EJECT                               ×
 BLOCK NAME=MSC0150,TYPE=PROGRAM,OPTIONS=(*PWA),SUBOPTS=*SWA,       @C4$
               BASEREG=(R12,R11)      ×                             @C4
* *-------------------------------------------------------------------*
* *  INITIALIZE THE PROGRAM WORK AREA.
* *-------------------------------------------------------------------*
  CALLSUB INITIALIZE_PWA              × INITIALIZE PWA
* *-------------------------------------------------------------------*
* *  OPEN SOURCE INPUT AND OUTPUT FILES AND PRINT FILE.
* *-------------------------------------------------------------------*
  MVC   PWADIN,PSDDIN                 × MOVE SYSIN DCB TO PWA
  MVC   PWADOUT,PSDDOUT               × MOVE SYSPUNCH DCB TO PWA
  MVC   PWADPRT,PSDDPRT               × MOVE SYSPRINT DCB TO PWA
  MVC   PWAOPN3,PSDOPN3               × MOVE OPEN LIST FORM TO PWA
  OPEN  (PWADIN,INPUT,PWADOUT,OUTPUT,PWADPRT,OUTPUT),MF=(E,PWAOPN3)
  ERREXIT (TBIT,PWADIN+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=0
  ERREXIT (TBIT,PWADOUT+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=1
  ERREXIT (TBIT,PWADPRT+DCBOFLGS-IHADCB,DCBOFOPN,OFF),CODE=2
* *-------------------------------------------------------------------*
* *  PRINT LISTING UNTIL END OF FILE ON SYSIN.
* *-------------------------------------------------------------------*
  CALLSUB READ_SYSIN_AND_WRITE_SRCOUT × DO PRIMING READ
  LOOP WHILE,NOT,(TBIT,PWAF1EOF)      × LOOP WHILE NOT END OF FILE
*  *------------------------------------------------------------------*
*  *  IF NOT A COMMENT CARD, SEARCH FOR AN OPCODE ON THE LINE AND
*  *  DO THE APPROPRIATE LISTING PROCESSING.
*  *------------------------------------------------------------------*
   IF (CLI,PWATEXT,NE,C'*'),AND,      ×  IF NOT A COMMENT CARD         $
               (CLC,PWATEXT(2),NE,=C'.*')
    LA    R1,PWALNE                   ×   POINT R1 TO START OF TEXT
    LA    R15,PWATEXT+L'PWATEXT       ×   POINT R15 TO LAST BYTE
    LA    R14,1                       ×   SET INCREMENT TO 1
    LOOP  BXLE                        ×   USE BXLE TO FIND THE
     LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')     FIRST BLANK AFTER
    ENDLOOP BXLE,R1,R14               ×    AN OPTIONAL TAG
    XC    PWAAOPR,PWAAOPR             ×   CLEAR POINTER TO OPCODE
    LOOP  BXH,R1,R14                  ×   SEARCH FOR NONBLANK
     IF  (CLI,0(R1),NE,X'40')         ×    IF NONBLANK FOUND
      ST    R1,PWAAOPR                ×     SAVE POINTER TO OPCODE
      CALLSUB PROCESS_OPCODE          ×     PROCESS THE OPCODE
      LEAVE LOOP=*                    ×     LEAVE SEARCH FOR OPCODE
     ENDIF                            ×    ENDIF
    ENDLOOP BXH                       ×   END OF SEARCH
   ENDIF                              ×  ENDIF
*  *------------------------------------------------------------------*
*  *  IF A STATEMENT IS CONTINUED, PROCESS CONTINUATION LINES.
*  *------------------------------------------------------------------*
   IF (CLI,PWACONT,NE,X'40')          ×  IF CONTINUED STATEMENT
    CALLSUB PROCESS_CONTINUATION_LINES    PROCESS CONTINUATION LINES
   ENDIF                              ×  ENDIF
*  *------------------------------------------------------------------*
*  *  IF THE NOWRITE FLAG IS NOT SET,  PRINT A STATEMENT LINE.
*  *------------------------------------------------------------------*
   IF (TBIT,PWAF1NOW,OFF)             ×  IF NO WRITE FLAG IS OFF
    CALLSUB PRINT_STATEMENT_LINE      ×   PRINT STATEMENT
   ENDIF                              ×  ENDIF
   RBIT  PWAF1NOW                     ×  RESET NOWRITE FLAG
*  *------------------------------------------------------------------*
*  *  READ NEXT STATEMENT
*  *------------------------------------------------------------------*
   IF NOT,(TBIT,PWAF1EOF)             ×  IF NOT END OF FILE
    CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   GET NEXT RECORD
   ENDIF                              ×  ENDIF
*  *------------------------------------------------------------------*
  ENDLOOP WHILE                       × ENDLOOP
* *-------------------------------------------------------------------*
* *  IF STRUCTURAL LEVEL IS NON-ZERO, ISSUE ERROR MESSAGE.
* *-------------------------------------------------------------------*
  IF (CLC,PWANSTL,NE,=H'0')           × IF LEVEL NOT ZERO
   PUT   PWADPRT,PSDERLVL             ×  ISSUE ERROR MESSAGE
   IF (CLI,PWAMAXRC,LT,8)             ×  IF MAX RETURN CODE < 8
    MVI   PWAMAXRC,8                  ×   MOVE 8 TO MAX RETURN CODE
   ENDIF                              ×  ENDIF
  ENDIF                               × ENDIF
* *-------------------------------------------------------------------*
* *  CLOSE FILES AND RETURN WITH MAXIMUM RETURN CODE.
* *-------------------------------------------------------------------*
  MVC   PWAOPN3,PSDOPN3               × MOVE OPEN LIST FORM TO PWA
  CLOSE (PWADIN,,PWADOUT,,PWADPRT),MF=(E,PWAOPN3) CLOSE FILES
* *-------------------------------------------------------------------*
* *  SET RETURN CODE.
* *-------------------------------------------------------------------*
  SLR   R15,R15                    CLEAR R15
  IC    R15,PWAMAXRC               LOAD MAXIMUM RETURN CODE
* *-------------------------------------------------------------------*
 ENDBLK BLOCK=MSC0150,RC=(R15)  END OF PROGRAM BLOCK
 EJECT                                ×
**--------------------------------------------------------------------*
**  EODAD EXIT - FOR SYSIN FILE
**--------------------------------------------------------------------*
 SPACE 1                              ×
 BLOCK NAME=EODADIN,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS
  SBIT  PWAF1EOF                      × SET END OF FILE FLAG
 ENDBLK BLOCK=EODADIN                 ×
 EJECT                                ×
**--------------------------------------------------------------------*
**  SUBROUTINE: INITIALIZE_PWA
**
**  THIS SUBROUTINE INITIALIZES FIELDS IN THE PWA.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=INITIALIZE_PWA
  ZAP   PWALNUM,=P'999'               × FORCE TITLES
  ZAP   PWAPGN,=P'0'                  × SET PAGE NUMBER TO ZERO
  ZAP   PWAMNL,=P'0'                  × SET MACRO NESTING LEVEL TO ZERO
  FILL  PWANSTK,X'40'                 × INITIALIZE NESTING STACK
  MVC   PWAT,PSDT                     × INITIALIZE TITLE LINE
  MVC   PWAH,PSDH                     × INITIALIZE HEADING LINE
  TIME  ,                             × GET TIME
  ST    R1,PWAD                       × STORE DATE
  MVC   PWAHDTE,PSDMDTE               × MOVE MASK FOR DATE
  ED    PWAHDTE,PWAD+1                × EDIT DATE INTO HEADING LINE
  ST    R0,PWAD                       × STORE TIME
  MVC   PWAHTME,PSDMTME               × MOVE EDIT MASK FOR TIME
  ED    PWAHTME,PWAD                  × EDIT TIME INTO HEADING LINE
  MVC   PWAL,PSDL                     × INITIALIZE TEXT LINE
  MVC   PWABLINE,PSDBLINE             × INITIALIZE BLANK LINE
 ENDBLK BLOCK=INITIALIZE_PWA          ×
 EJECT                                ×
**--------------------------------------------------------------------*
**  SUBROUTINE: PROCESS_OPCODE
**
**  THIS SUBROUTINE WILL CHECK TO SEE IF THE OPCODE POINTED TO
**  BY REGISTER 1 IS ONE OF THE STRUCTURED MACROS, TITLE, EJECT,
**  SPACE, MACRO OR MEND AND TAKE THE APPROPRIATE LISTING ACTIONS.
**  IF THE OPCODE IS ONE OF THE MACROS THAT START A STRUCTURE, CALLS
**  NEST.  IF IT IS ONE OF THE MACROS THAT END A STRUCTURE, CALL
**  UNNEST.  IF WE ARE INSIDE A MACRO DEFINITION,  ALL THAT IS LOOKED
**  FOR IS MEND AND MACRO MNEMONICS.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_OPCODE
  IF (CP,PWAMNL,GT,=P'0')             × IF MACRO NESTING IS NON-ZERO
   IF (CLC,=C'MEND ',EQ,0(R1))        ×  IF 'MEND'
    CALLSUB UNNEST,('M')              ×   CALL UNNEST
    SP    PWAMNL,=P'1'                ×   DEC MACRO NESTING LVL
   ELSEIF (CLC,=C'MACRO ',EQ,0(R1))   ×  ELSE IF 'MACRO'
    CALLSUB NEST,('M')                ×   CALL NEST
    AP    PWAMNL,=P'1'                ×   INC MACRO NESTING LVL
   ENDIF                              ×  ENDIF
  ELSEIF (CLC,=C'BLOCK ',EQ,0(R1))    × ELSEIF 'BLOCK'
   CALLSUB NEST,('B')                 ×  CALL NEST
  ELSEIF (CLC,=C'ENDBLK ',EQ,0(R1))   × ELSEIF 'ENDBLK'
   CALLSUB UNNEST,('B')               ×  CALL UNNEST
  ELSEIF (CLC,=C'CASEBLK ',EQ,0(R1))  × ELSEIF 'CASEBLK'
   CALLSUB NEST,('C')                 ×  CALL NEST
  ELSEIF (CLC,=C'ENDCASE ',EQ,0(R1))  × ELSEIF 'ENDCASE'
   CALLSUB UNNEST,('C')               ×  CALL UNNEST
  ELSEIF (CLC,=C'IF ',EQ,0(R1))       × ELSEIF 'IF'
   CALLSUB NEST,('I')                 ×  CALL NEST
  ELSEIF (CLC,=C'ENDIF ',EQ,0(R1))    × ELSEIF 'ENDIF'
   CALLSUB UNNEST,('I')               ×  CALL UNNEST
  ELSEIF (CLC,=C'LOOP ',EQ,0(R1))     × ELSEIF 'LOOP'
   CALLSUB NEST,('L')                 ×  CALL NEST
  ELSEIF (CLC,=C'ENDLOOP ',EQ,0(R1))  × ELSEIF 'ENDLOOP'
   CALLSUB UNNEST,('L')               ×  CALL UNNEST
  ELSEIF (CLC,=C'MACRO ',EQ,0(R1))    × ELSEIF 'MACRO'
   CALLSUB NEST,('M')                 ×  CALL NEST
   AP    PWAMNL,=P'1'                 ×  UP MACRO NESTING LEVEL
  ELSEIF (CLC,=C'MEND ',EQ,0(R1))     × ELSEIF 'MEND'
   MVC   PWALMSG(26),=C'>E-4 MEND OUTSIDE OF MACRO'
   IF (CLI,PWAMAXRC,LT,4)             ×  IF MAX RETURN CODE < 4
    MVI   PWAMAXRC,4                  ×   SET RETURN CODE TO 4
   ENDIF                              ×  ENDIF
  ELSEIF (CLC,=C'TITLE ',EQ,0(R1))    × ELSEIF 'TITLE'
   CALLSUB PROCESS_TITLE              ×  PROCESS TITLE
  ELSEIF (CLC,=C'SPACE ',EQ,0(R1))    × ELSEIF 'SPACE'
   CALLSUB PROCESS_SPACE              ×  PROCESS SPACE
  ELSEIF (CLC,=C'EJECT ',EQ,0(R1))    × ELSEIF 'EJECT'
   ZAP   PWALNUM,=P'999'              ×  CAUSE TITLE TO PRINT
   SBIT  PWAF1NOW                     ×  INDICATE NO WRITE
  ELSEIF (CLC,=C'END ',EQ,0(R1))      × ELSEIF 'END'
   SBIT  PWAF1EOF                     ×  INDICATE END OF FILE
  ELSEIF (CLC,=C'SMLIST ',EQ,0(R1))   × ELSEIF 'SMLIST'             @C4
   CALLSUB PROCESS_SMLIST             ×  PROCESS SMLIST COMMAND     @C4
  ENDIF                               × ENDIF
 ENDBLK BLOCK=PROCESS_OPCODE          ×
  EJECT                               ×
**--------------------------------------------------------------------*
**  SUBROUTINE - PROCESS_TITLE
**
**  IF 'TITLE' IS THE OPCODE, ISOLATE THE TITLE, MOVE IT TO THE TITLE
**  LINE, AND FORCE OVERFLOW.  THIS CODE HANDLES DOUBLE QUOTES BUT
**  DOES NOT AND IN FACT CAN NOT HANDLE SYMBOLIC VARIABLE
**  SUBSTITUTION.  IF THIS CODE DETECTS A SYNTAX ERROR, THE MOVE OF
**  THE TITLE IS TERMINATED BUT NO SYNTAX ERROR IS ISSUED.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_TITLE
* *-------------------------------------------------------------------*
* *  IF NAME FIELD IS NON-BLANK AND NOT A SEQUENCE SYMBOL AND AN
* *  IDENTIFICATION IS SPECIFIED IN THE NAME FIELD OF THE TITLE
* *  STATEMENT AND WE HAVE NOT ALREADY DONE SO, MOVE THE
* *  IDENTIFICATION TO THE MODEL OUTPUT TITLE LINE.
* *-------------------------------------------------------------------*
  IF (CLI,PWATEXT,NE,C'.'),AND,       × IF NAME FIELD IS NOT A         $
               (CLI,PWATEXT,NE,X'40'),AND, SEQUENCE SYMBOL OR BLANK    $
               (CLI,PWATID,EQ,X'40')  ×    AND THIS IS THE 1ST TIME
   L     R3,PWAAOPR                   ×  POINT R3 TO 'TITLE'
   LA    R2,PWALNE                    ×  POINT R2 TO START OF LINE
   SLR   R3,R2                        ×  CALC LENGTH BEFORE 'TITLE'
   LA    R4,PWATID                    ×  POINT TO ID IN TITLE LINE
   LA    R5,L'PWATID                  ×  LOAD R5 WITH LENGTH OF ID
   ICM   R3,B'1000',=X'40'            ×  FILL CHAR IS SPACE
   MVCL  R4,R2                        ×  MOVE ID TO TITLE
  ENDIF                               × ENDIF
* *-------------------------------------------------------------------*
* *  BLANK OUT PLACE TO PUT TITLE IN MODEL TITLE OUTPUT LINE AND
* *  POINT R4 TO PLACE, LOAD R5 WITH LENGTH OF PLACE, AND POINT R1
* *  TO FIRST NON-BLANK AFTER 'TITLE'.
* *-------------------------------------------------------------------*
  FILL  PWATDTA,X'40'                 × BLANK OUT PLACE TO PUT TITLE
  LA    R4,PWATDTA                    × POINT R4 TO PLACE
  LA    R5,L'PWATDTA                  × LOAD R5 WITH IT'S LENGTH
  L     R1,PWAAOPR                    × POINT R1 TO 'TITLE'
  LA    R1,5(,R1)                     × POINT R1 PAST 'TITLE'
  LA    R14,1                         × SET INCREMENT TO 1
  LA    R15,PWATEXT+L'PWATEXT         × POINT R15 TO LAST BYTE
  LOOP  BXH,R1,R14                    × SEARCH FOR NON-BLANK
   LEAVE LOOP=*,(CLI,0(R1),NE,X'40')  ×  PAST 'TITLE'
  ENDLOOP BXH                         × END SEARCH
* *-------------------------------------------------------------------*
* *  IF THERE WAS A NON-BLANK AND IT IS A QUOTE, MOVE TITLE TO
* *  MODEL TITLE OUTPUT LINE ONE BYTE AT A TIME.
* *-------------------------------------------------------------------*
  IF (CLR,R1,LT,R15),AND,(CLI,0(R1),EQ,C'''')
   LA    R1,1(,R1)                    ×  POINT R1 PAST QUOTE
   LOOP BCT                           ×  LOOP FOR EACH BYTE
*   *-----------------------------------------------------------------*
*   *  IF WE HAVE SCANNED TO THE END OF THE TEXT AREA ON THE CARD
*   *  AND IT IS A CONTINUATION,  READ ANOTHER CARD AND REESTABLISH
*   *  R1 AND R15.  IF END OF FILE ON SYSIN, CONSIDER MOVE COMPLETE.
*   *-----------------------------------------------------------------*
    IF (CLR,R1,GE,R15)                ×   IF AT END OF TEXT AREA
     LEAVE LOOP=*,(CLI,PWACONT,EQ,X'40')   FINISHED IF NOT CONTINUATION
     CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   READ A NEW RECORD
     LEAVE LOOP=*,(TBIT,PWAF1EOF)     ×    FINISHED IF EOF
     LA    R1,PWATEXT+16-1            ×    POINT R1 TO COL 16
     LA    R14,1                      ×    REESTABLISH R14
     LA    R15,PWATEXT+L'PWATEXT      ×    REESTABLISH R15
    ENDIF                             ×   ENDIF
*   *-----------------------------------------------------------------*
*   *  IF NEXT CHARACTER IN INPUT RECORD IS A QUOTE, INCREMENT TO
*   *  NEXT CHARACTER.  IF NEXT CHARACTER IS NOT A QUOTE, ASSUME
*   *  THE MOVE IS COMPLETE EVEN IF IT IS A NON-SPACE.
*   *-----------------------------------------------------------------*
    IF (CLI,0(R1),EQ,C'''')           ×   IF QUOTE
     LA    R1,1(,R1)                  ×    INCREMENT POINTER
     IF (CLR,R1,GE,R15)               ×    IF AT END OF CARD
      LEAVE LOOP=*,(CLI,PWACONT,EQ,X'40')   THROUGH IF NOT CONTINUATION
      CALLSUB READ_SYSIN_AND_WRITE_SRCOUT   READ A NEW RECORD
      LEAVE LOOP=*,(TBIT,PWAF1EOF)    ×     FINISHED IF EOF
      LEAVE LOOP=*,(CLI,PWATEXT+16-1,NE,C'''')
      LA    R1,PWATEXT+16-1           ×     POINT R1 TO COL 16
      LA    R14,1                     ×     REESTABLISH R14
      LA    R15,PWATEXT+L'PWATEXT     ×     REESTABLISH R15
     ELSE                             ×    ELSEIF NEXT CHAR IS NOT AN
      LEAVE LOOP=*                    ×     QUOTE, LEAVE LOOP
     ENDIF                            ×    ENDIF
    ENDIF                             ×   ENDIF
*   *-----------------------------------------------------------------*
*   *  MOVE ONE CHARACTER TO OUTPUT AREA AND ADJUST POINTERS.
*   *-----------------------------------------------------------------*
    MVC   0(1,R4),0(R1)               ×   MOVE A CHARACTER
    LA    R1,1(,R1)                   ×   BUMP POINTER INTO INPUT
    LA    R4,1(,R4)                   ×   BUMP POINTER INTO OUTPUT
   ENDLOOP BCT,R5                     ×  ENDLOOP
  ENDIF                               × ENDIF
* *-------------------------------------------------------------------*
  ZAP   PWALNUM,=P'999'               × CAUSE TITLE TO PRINT
  SBIT  PWAF1NOW                      × INDICATE NO WRITE
 ENDBLK BLOCK=PROCESS_TITLE           ×ENDBLK
  EJECT                               ×
**--------------------------------------------------------------------*
**  SUBROUTINE - PROCESS_SPACE
**
**  IF SPACE IS OPCODE, ISOLATE NUMBER OF LINES TO SPACE AND PRINT
**  BLANK LINES IF NECESSARY.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_SPACE
  L     R1,PWAAOPR                    × POINT R1 TO OPCODE FIELD
  LA    R14,1                         × SET INCREMENT TO 1
  LA    R15,PWATEXT+L'PWATEXT         × POINT R15 TO LAST BYTE
  LA    R0,1                          × ASSUME ONE SPACE
  LA    R1,5(,R1)                     × POINT R1 PAST 'SPACE'
  LOOP  BXH,R1,R14,NAME=SCANSP        × SCAN FOR NUMBER AFTER SPACE
   IF (CLI,0(R1),NE,X'40')            ×  IF NON-BLANK FOUND
    LR   R2,R1                        ×   SAVE ADDRESS IN R2
    LOOP BXH,R1,R14                   ×   SCAN FOR NEXT BLANK
     IF (CLI,0(R1),EQ,X'40')          ×    IF NEXT BLANK FOUND
      SLR   R1,R2                     ×     CALC LENGTH OF NON-BLANKS
      IF (CH,R1,LT,=H'3')             ×     IF LENGTH < 3
       BCTR  R1,0                     ×      PACK INTO
       EXI   R1,(PACK,PWAD,0(*-*,R2)) ×      .PWAD
      ELSE                            ×     IF LENGTH >= 3
       ZAP   PWALNUM,=P'999'          ×      FORCE EJECT ON NEXT PRINT
      ENDIF                           ×     ENDIF
      LEAVE LOOP=SCANSP               ×     LEAVE SCANSP
     ELSE                             ×    ELSE IF NOT BLANK
      LEAVE LOOP=*,                   ×     JUST TAKE DEFAULT OF       $
               (CLI,0(R1),LT,C'0'),OR,       ONE IF NON-NUMERIC        $
               (CLI,0(R1),GT,C'9')    ×      ENCOUNTERED
     ENDIF                            ×    ENDIF
    ENDLOOP BXH                       ×   ENDLOOP
    LEAVE LOOP=SCANSP                 ×   LEAVE SCANSP
   ENDIF                              ×  ENDIF
  ENDLOOP BXH,LOOP=SCANSP             × ENDLOOP
* *-------------------------------------------------------------------*
* *  GENERATE SPACING
* *-------------------------------------------------------------------*
  LR    R2,R0                         × R2 = COUNT ON 'SPACE'
  LEAVE BLOCK=*,(CP,PWALNUM,GT,PSDLPP)  LEAVE IF OVERFLOW
  MVC   PWABLCC,PWALCC                × PUT BLANK LINES BASED ON
  PUT   PWADPRT,PWABLINE              × .CC IN STATMENT LINE
  MVI   PWALCC,X'40'                  × SET STMT LINE TO SINGLE SPACE
  BCTR  R2,0                          × ADJUST COUNT
  AP    PWALNUM,=P'1'                 × ADD ONE TO LINE NUMBER
  LOOP WHILE,(TREG,R2,NZ)             × SET CC FOR NEXT LINE
   IF (CH,R2,EQ,=H'1')                ×  IF ONE SPACE
    AP    PWALNUM,=P'1'               ×   ADD 1 TO LINE NUMBER
    MVI   PWALCC,C'0'                 ×   SET CC TO DOUBLE SPACE
    LEAVE LOOP=*                      ×   LEAVE LOOP
   ENDIF                              ×  ENDIF
   IF (CH,R2,EQ,=H'2')                ×  IF TWO SPACES
    AP    PWALNUM,=P'2'               ×   ADD 2 TO LINE NUMBER
    MVI   PWALCC,C'-'                 ×   SET CC TO TRIPLE SPACE
    LEAVE LOOP=*                      ×   LEAVE LOOP
   ENDIF                              ×  ENDIF
   AP    PWALNUM,=P'3'                ×  ADD 3 TO LINE NUMBER
   SH    R2,=H'3'                     ×  SUB 3 FROM SPACING
   LEAVE LOOP=*,(CP,PWALNUM,GT,PSDLPP)   LEAVE IF OVERFLOW
   MVI   PWABLCC,C'-'                 ×  SET CC TO TRIPLE SPACE
   PUT   PWADPRT,PWABLINE             ×  PUT 3 BLANK LINES
  ENDLOOP WHILE                       × KEEP LOOPING IF MORE
  SBIT  PWAF1NOW                      × INDICATE NO WRITE
 ENDBLK BLOCK=PROCESS_SPACE           ×ENDBLK
 EJECT                                ×
**------------------------------------------------------------------@C4
**  SUBROUTINE - PROCESS_SMLIST                                     @C4
**                                                                  @C4
**  IF SMLIST IS OPCODE, PROCESS THE LISTING OPTIONS.               @C4
**                                                                  @C4
**------------------------------------------------------------------@C4
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_SMLIST                          @C4
  L     R1,PWAAOPR                    × POINT R1 TO OPCODE FIELD    @C4
  LA    R14,1                         × SET INCREMENT TO 1          @C4
  LA    R15,PWATEXT+L'PWATEXT         × POINT R15 TO LAST BYTE      @C4
  LA    R0,1                          × ASSUME ONE SPACE            @C4
  LA    R1,6(,R1)                     × POINT R1 PAST 'SMLIST'      @C4
  LOOP  BXH,R1,R14                    × SCAN FOR NUMBER AFTER SPACE @C4
   IF (CLI,0(R1),NE,X'40')            ×  IF NON-BLANK FOUND         @C4
    LR    R2,R15                      ×   CALCULATE                 @C4
    SLR   R2,R1                       ×    REMAINING LENGHT         @C4
    IF (CH,R2,GE,=H'11'),AND,         ×   IF OPERAND IS             @C4$
               (CLC,=C'CONVERT=YES',EQ,0(R1))  CONVERT=YES          @C4
     SBIT  PWAF1CUP                   ×    TURN CONVERSION ON       @C4
    ELSEIF (CH,R2,GE,=H'10'),AND,     ×   ELSE IF OPERAND IS        @C4$
               (CLC,=C'CONVERT=NO',EQ,0(R1))   CONVERT=NO           @C4
     RBIT  PWAF1CUP                   ×    TURN CONVERSION OFF      @C4
    ELSE                              ×   ELSE                      @C4
     MVC   PWALMSG,=CL27'>E-8 INVALID SMLIST STATEMENT'  ERROR      @C4
     IF (CLI,PWAMAXRC,LT,8)           ×    IF HIGHEST RC < 8        @C4
      MVI  PWAMAXRC,8                 ×     SET HIGHEST TO 8        @C4
     ENDIF                            ×    ENDIF                    @C4
    ENDIF                             ×   ENDIF                     @C4
    LEAVE LOOP=*                      ×   LEAVE LOOP                @C4
   ENDIF                              ×  ENDIF                      @C4
  ENDLOOP BXH                         × ENDLOOP                     @C4
 ENDBLK BLOCK=PROCESS_SMLIST          ×ENDBLK                       @C4
 EJECT                                ×                             @C4
**--------------------------------------------------------------------*
**  SUBROUTINE - PROCESS_CONTINUATION_LINES
**
**  THIS SUBROUTINE PROCESSES CONTINUATION LINES AND ISSUES WARNING
**  MESSAGES FOR POSSIBLE CONTINUATION ERRORS.  A POSSIBLE
**  CONTINUATION ERROR IN WHEN COLUMN 16 OF A CONTINUATION CARD IS
**  BLANK WHEN IT IS NOT PART OF A QUOTED STRING.
**
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=PROCESS_CONTINUATION_LINES
  L     R1,PWAAOPR                    × POINT R1 TO OPCODE FIELD
* *-------------------------------------------------------------------*
* *  IF NOT A CONDITIONAL ASSEMBLY STATEMENT, CHECK FOR POSSIBLE
* *  CONTINUATION ERRORS.
* *-------------------------------------------------------------------*
  IF           (CLC,0(4,R1),NE,=C'AGO '),AND,                          $
               (CLC,0(4,R1),NE,=C'AIF '),AND,                          $
               (CLC,0(5,R1),NE,=C'GBLA '),AND,                         $
               (CLC,0(5,R1),NE,=C'GBLB '),AND,                         $
               (CLC,0(5,R1),NE,=C'GBLC '),AND,                         $
               (CLC,0(5,R1),NE,=C'LCLA '),AND,                         $
               (CLC,0(5,R1),NE,=C'LCLB '),AND,                         $
               (CLC,0(5,R1),NE,=C'LCLC '),AND,                         $
               (CLC,0(5,R1),NE,=C'SETA '),AND,                         $
               (CLC,0(5,R1),NE,=C'SETB '),AND,                         $
               (CLC,0(5,R1),NE,=C'SETC ')
*  *------------------------------------------------------------------*
*  *  SEARCH FOR SPACE PAST MNEUMONIC.
*  *------------------------------------------------------------------*
   LA    R14,1                        ×  LOAD R14 WITH INCREMENT
   LA    R15,PWATEXT+L'PWATEXT        ×  POINT R15 TO BYTE AFTER TEXT
   LOOP BXH,R1,R14                    ×  SEARCH FOR BLANK
    LEAVE LOOP=*,(CLI,0(R1),EQ,X'40') ×   COMPLETE IF FOUND
   ENDLOOP BXH                        ×  END OF SEARCH
*  *------------------------------------------------------------------*
*  *  SCAN CHARACTER BY CHARACTER THRU RECORDS
*  *------------------------------------------------------------------*
   LOOP BXH,R1,R14,NAME=SCAN_RECORD   ×
*   *-----------------------------------------------------------------*
*   *  IF A COMMA IS FOUND THAT IS FOLLOWED BY A SPACE, READ
*   *  NEXT LINE AND IF COLUMN 16 IS BLANK, WARN OF A POSSIBLE
*   *  ERROR.
*   *-----------------------------------------------------------------*
    IF (CLI,0(R1),EQ,C',')            ×   IF COMMA FOUND
     LA   R2,1(,R1)                   ×    POINT R2 TO NEXT BYTE
     IF (CLR,R2,GE,R15),OR,           ×    IF END OF CARD OR SPACE     $
               (CLI,0(R2),EQ,X'40')   ×
      CALLSUB READ_CONTINUATION_LINE  ×     READ CONTINUATION
      LEAVE LOOP=SCAN_RECORD,(TREG,R15,NZ)  LEAVE IF READ UNSUCCESSFUL
      IF (CLI,PWATEXT+16-1,EQ,X'40')  ×     IF COL 16 BLANK
       MVC   PWALMSG(23),=C'>E-4 COLUMN 16 IS BLANK' MOVE IN ERROR MSG
       IF (CLI,PWAMAXRC,LT,4)         ×      IF MAX RETURN CODE < 4
        MVI   PWAMAXRC,4              ×       SET MAX TO 4
       ENDIF                          ×      ENDIF
       LEAVE LOOP=SCAN_RECORD         ×      STOP SCAN OF RECORD
      ENDIF                           ×     ENDIF
      LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')  STOP SCAN IF NOT CONTINUED
      LA    R1,PWATEXT+16-1           ×     POINT R1 TO COL 16
      LA    R14,1                     ×     REESTABLISH R14
      LA    R15,PWATEXT+L'PWATEXT     ×     REESTABLISH R15
     ENDIF                            ×    ENDIF
    ENDIF                             ×   ENDIF
*   *-----------------------------------------------------------------*
*   *  IF QUOTE IS FOUND THAT IS NOT PRECEEDED BY A SPECIAL CHARACTER
*   *  OTHER THAN '&' FOLLOWED BY THE CHARACTER 'L', SEARCH FOR THE
*   *  ENDING QOUTE.  AN ERROR IS WARNED OF IF COLUMN 71 IS A SINGLE
*   *  QUOTE AND COLUMN 16 OF THE NEXT CARD IS A SPACE.
*   *-----------------------------------------------------------------*
    IF (CLI,0(R1),EQ,C'''')           ×   IF QUOTE FOUND
     LR    R2,R1                      ×    POINT R2 TWO BYTES
     SL    R2,=F'2'                   ×     BEFORE CURRENT CHARACTER
     LA    R3,=C'+-,=.*()''/ '        ×    POINT R3 TO SPECIAL CHARS
     LA    R4,11                      ×    LOAD R4 WITH NUMBER OF CHARS
     LOOP BCT                         ×    CHECK TO SEE IF CHARACTER
      LEAVE LOOP=*,(CLC,0(1,R2),EQ,0(R3))   TWO BYTES BEFORE CURRENT
      LA    R3,1(,R3)                 ×     CHARACTER IS ONE OF THE
     ENDLOOP BCT,R4                   ×     SPECIAL CHARS EXCEPT &
     LA     R3,0                      ×    ZERO R0 WITHOUT CHANGING CC
     IF NE,OR,(CLI,1(R2),NE,C'L')     ×    IF NOT SPECIAL FOLLOWED BY L
      LOOP BXH,R1,R14                 ×     SCAN FOR OTHER QUOTE
       LA    R2,1(,R1)                ×      POINT R2 TO NEXT BYTE
       IF (CLR,R2,GE,R15)             ×      IF OUT OF CHAR ON THIS LIN
        CALLSUB READ_CONTINUATION_LINE READ CONTINUATION LINE
        LEAVE LOOP=SCAN_RECORD,(TREG,R15,NZ) LEAVE IF READ FAILED
        LA    R1,PWATEXT+16-1         ×      POINT R1 TO COL 16
        LA    R14,1                   ×      REESTABLISH R14
        LA    R15,PWATEXT+L'PWATEXT   ×      REESTABLISH R15
        IF (CLM,R3,B'0001',EQ,=C'''') ×      IF LAST CHAR WAS QUOTE
         IF (CLI,PWATEXT+16-1,EQ,X'40')       IF COL 16 IS BLANK
          MVC   PWALMSG(23),=C'>E-4 COLUMN 16 IS BLANK' MOVE ERR MSG
          IF (CLI,PWAMAXRC,LT,4)      ×        IF MAX RC < 4
           MVI   PWAMAXRC,4           ×         SET MAX RC TO 4
          ENDIF                       ×        ENDIF
         ENDIF                        ×       ENDIF
         LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')
         LEAVE LOOP=*,(CLI,PWATEXT+16-1,NE,C'''') LEAVE IF NOT ''
        ELSE                          ×      ELSE
         LEAVE BLOCK=*,(CLI,PWACONT,EQ,X'40')
         LEAVE LOOP=*,(CLI,1(R1),NE,C'''')    LEAVE IF NOT ''
         LA    R1,1(,R1)              ×       SKIP SECOND '
        ENDIF                         ×      ENDIF
       ENDIF                          ×     ENDIF
       IC    R3,1(,R1)                ×     LOAD R3 WITH NEXT BYTE
      ENDLOOP BXH                     ×    ENDLOOP
     ENDIF                            ×   ENDIF
    ENDIF                             ×  ENDIF
*   *-----------------------------------------------------------------*
*   *  LEAVE IF SPACE FOUND OUTSIDE OF QUOTES.
*   *-----------------------------------------------------------------*
    LEAVE LOOP=*,(CLI,0(R1),EQ,X'40') ×
   ENDLOOP BXH,LOOP=SCAN_RECORD       ×  ENDLOOP
  ENDIF                               × ENDIF
* *-------------------------------------------------------------------*
* *  EAT REST OF CONTINUATION LINES.
* *-------------------------------------------------------------------*
  LOOP WHILE,NOT,(TBIT,PWAF1EOF),AND, × LOOP UNTIL END OF CONTINUATION $
               (CLI,PWACONT,NE,X'40') ×  LINES
   CALLSUB READ_CONTINUATION_LINE     ×  READ A CONTINUATION LINE
  ENDLOOP WHILE                       × ENDLOOP
 ENDBLK BLOCK=PROCESS_CONTINUATION_LINES
 EJECT                                ×
**--------------------------------------------------------------------*
**  SUBROUTINE - READ_CONTINUATION_LINE
**
**  PRINT LAST LINE AND READ CONTINUATION LINE.  IF COL 1-15 IS
**  NOT BLANK, ISSUE A WARNING.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=READ_CONTINUATION_LINE
  CALLSUB PRINT_STATEMENT_LINE        × PRINT STATEMENT LINE
  CALLSUB READ_SYSIN_AND_WRITE_SRCOUT × GET NEXT RECORD
  LA    R15,8                         × ASSUME 8 RETURN CODE FOR SUB
  LEAVE BLOCK=*,(TBIT,PWAF1EOF)       × LEAVE IF END OF FILE
  SLR   R15,R15                       × ASSUME 0 RETURN CODE FOR SUB
  IF (CLI,PWATEXT,NE,X'40'),OR,       × IF COLUMN 1-15 IS NOT BLANK    $
               (CLC,PWATEXT+1(15-1),NE,PWATEXT)
   MVC   PWALMSG(26),=C'>E-4 COLUMN 1-16 NOT BLANK'
   IF (CLI,PWAMAXRC,LT,4)             ×  IF PROGRAM RETURN CODE < 4
    MVI   PWAMAXRC,4                  ×   SET PROGRAM RETURN CODE TO 4
   ENDIF                              ×  ENDIF
  ENDIF                               × ENDIF
 ENDBLK BLOCK=READ_CONTINUATION_LINE  ×
 EJECT                                ×
**--------------------------------------------------------------------*
**  SUBROUTINE - READ_SYSIN_AND_WRITE_SRCOUT
**
**  READ A RECORD FROM SYSIN AND PLACE IT IN THE PWA.
**--------------------------------------------------------------------*
 BLOCK TYPE=SUBROUTINE,NAME=READ_SYSIN_AND_WRITE_SRCOUT
* *-----------------------------------------------------------------@C4
* *  GET A RECORD FROM THE SYSIN FILE AND IF NOT AT END OF FILE,    @C4
* *  PROCESS IT.                                                    @C4
* *-----------------------------------------------------------------@C4
  GET   PWADIN                        × GET RECORD FROM SYSIN
  IF NOT,(TBIT,PWAF1EOF)              × IF NOT END OF FILE ON SYSIN
*  *----------------------------------------------------------------@C4
*  *  MAKE TWO COPIES OF THE RECORD, ONE TO ALTER AND ONE TO LEAVE  @C4
*  *  ALONE.                                                        @C4
*  *----------------------------------------------------------------@C4
   MVC   PWALNE,0(R1)                 ×  MOVE RECORD TO PWA
   MVC   PWAUNALT,0(R1)               ×  MOVE UNALTERED RECORD TO PW@C4
*  *----------------------------------------------------------------@C4
*  *  IF TRANSLATION IS ON, TRANSLATE LOWER CASE TO UPPER IF IT IS N@C4
*  *  WITHIN A "ED STRING.                                          @C4
*  *----------------------------------------------------------------@C4
   IF (TBIT,PWAF1CUP),AND,            ×  IF CONVERSION IS ON        @C4$
               (CLI,PWATEXT,NE,C'*'),AND, AND NOT COMMENT LINE      @C4$
               (CLC,=C'.*',NE,PWATEXT)                              @C4
    LA    R1,PWATEXT                  ×   POINT R1 TO TEXT          @C4
    LA    R14,1                       ×   SET INCREMENT TO 1        @C4
    LA    R15,L'PWATEXT+PWATEXT-1     ×   POINT R15 TO TEXT         @C4
    LOOP  BXLE                        ×   LOOP THROUGH LINE         @C4
     IF (TBIT,PWAF1QT)                ×    IF WORKING ON QUOTED STNG@C4
      IF (CLI,0(R1),EQ,C'"')          ×     IF DOUBLE QUOTE         @C4
       RBIT  PWAF1QT                  ×      RESET "INSIDE QUOTED"  @C4
       MVI   0(R1),C''''              ×      CHANGE TO SINGLE QUOTE @C4
      ENDIF                           ×     ENDIF                   @C4
     ELSEIF (CLI,0(R1),EQ,C'"')       ×    ELSEIF DOUBLE QUOTE      @C4
      SBIT PWAF1QT                    ×     TURN ON "INSIDE QUOTED" @C4
      MVI  0(R1),C''''                ×     CHANGE TO SINGLE QUOTE  @C4
     ELSE                             ×    ELSE                     @C4
      TR   0(1,R1),S01_TRT_TABLE      ×     TRANSLATE TO UPPER      @C4
     ENDIF                            ×    ENDIF                    @C4
    ENDLOOP BXLE,R1,R14               ×   ENDLOOP                   @C4
   ENDIF                              ×  ENDIF                      @C4
*  *----------------------------------------------------------------@C4
*  *  IF THIS IS NOT A CONTINUED LINE AND THE QUOTED FLAG IS STILL O@C4
*  *  CONSIDER IT AN ERROR AND TURN OFF THE FLAG.                   @C4
*  *----------------------------------------------------------------@C4
   IF (TBIT,PWAF1QT),AND,(CLI,PWACONT,EQ,C' ') IF UNMATCHED QUOTE   @C4
    MVC   PWALMSG,=CL27'>E-8 ENDING QUOTE EXPECTED'  ERROR          @C4
    IF (CLI,PWAMAXRC,LT,8)            ×         SET MAX             @C4
     MVI  PWAMAXRC,8                  ×           RETURN            @C4
    ENDIF                             ×           CODE              @C4
    RBIT  PWAF1QT                     ×         RESET "INSIDE QUOTE"@C4
   ENDIF                              ×        ENDIF                @C4
*  *----------------------------------------------------------------@C4
*  *  WRITE THE MODIFIED COPY OF THE RECORD TO THE OUTPUT FILE.     @C4
*  *----------------------------------------------------------------@C4
   PUT   PWADOUT,PWALNE               ×  PUT COPY OF RECORD IN SRCOU@C4
  ENDIF                               × ENDIF
 ENDBLK BLOCK=READ_SYSIN_AND_WRITE_SRCOUT
 SPACE 1                              ×                             @C4
         PSD ,                        ×                             @C4
S01_TRT_TABLE DC 256AL1(*-S01_TRT_TABLE)                            @C4
         ORG   S01_TRT_TABLE+C'a'     ×                             @C4
         DC    C'ABCDEFGHI'           ×                             @C4
         ORG   S01_TRT_TABLE+C'j'     ×                             @C4
         DC    C'JKLMNOPQR'           ×                             @C4
         ORG   S01_TRT_TABLE+C's'     ×                             @C4
         DC    C'STUVWXYZ'            ×                             @C4
         ORG   ,                      ×                             @C4
         ENDPSD ,                     ×                             @C4
 EJECT                                ×
**------------------------------------------------------------------
**  SUBROUTINE - PRINT_STATEMENT_LINE
**
**  IF A PAGE OVERFLOW OCCURS,  SKIP TO THE TOP OF A NEW PAGE
**  AND PRINT NEW TITLE AND HEADING LINES.  PAGE OVERFLOW IS
**  FORCED IN VARIOUS PARTS OF THIS PROGRAM BY SETTING CURRENT
**  LINE NUMBER TO 999.  PRINT THE PRE-PREPARED OUTPUT LINE THEN
**  CLEAR THE MESSAGE AREA IN THE LINE AND RESET THE CARRIAGE
**  CONTROL TO SINGLE SPACING.
**------------------------------------------------------------------
 BLOCK TYPE=SUBROUTINE,NAME=PRINT_STATEMENT_LINE
  IF (CP,PWALNUM,GT,PSDLPP)           × IF PAGE OVERFLOW THEN
   AP    PWAPGN,=P'1'                 ×  ADD ONE TO PAGE NUMBER
   MVC   PWATPGN,PSDMPGN              ×  MOVE PAGE NUM MASK TO TITLE
   ED    PWATPGN,PWAPGN               ×  EDIT PAGE NUMBER INTO TITLE
   PUT   PWADPRT,PWAT                 ×  PUT TITLE LINE
   PUT   PWADPRT,PWAH                 ×  PUT HEADING LINE
   MVI   PWALCC,C'0'                  ×  NEXT LINE SHOULD DOUBLE SPACE
   ZAP   PWALNUM,=P'5'                ×  SET LINE NUMBER
  ENDIF                               × ENDIF
  MVC   PWALTEXT,PWAUNALT             × MOVE LINE TO OUTPUT LINE    @C4
  PUT   PWADPRT,PWAL                  × PUT LINE
  FILL  PWALMSG,X'40'                 × CLEAR MESSAGE
  MVI   PWALCC,X'40'                  × RESET TO SINGLE SPACEING
  AP    PWALNUM,=P'1'                 × ADD ONE TO LINE NUMBER
 ENDBLK BLOCK=PRINT_STATEMENT_LINE    ×
 EJECT                                ×
**--------------------------------------------------------------------*
**  SUBROUTINE - NEST
**
**  PARAMETERS - (CL1-TYPE)
**
**  THE ONE BYTE TYPE PASSED IS PUSHED ON THE NESTING STACK.  IF THE
**  STACK DOES NOT OVERFLOW, THE CURRENT NESTING LEVEL AND A GROUP OF
**  16 BYTE FROM SIZE DIV 16 * 16 INTO THE STACK ARE MOVED TO THE
**  PRINT LINE.  IF THE STACK OVERFLOWS, AN ERROR MESSAGE IS MOVED TO
**  THE MESSAGE AREA OF THE PRINT LINE AND *'S MOVED WHERE THE 16
**  BYTES OF THE STACK WOULD HAVE BEEN MOVED.
**--------------------------------------------------------------------*
   SPACE 1                            ×
 BLOCK NAME=NEST,TYPE=SUBROUTINE      ×
  L     R1,0(,R1)                     × POINT R1 TO ONLY PARAMETER
  IC    R0,0(,R1)                     × INSERT TYPE PASSED IN R0
  LH    R15,PWANSTL                   × LOAD LENGTH OF STACK
  IF (CH,R15,LT,=Y(L'PWANSTK))        × IF STACK WILL NOT OVERFLOW
   STC   R0,PWANSTK(R15)              ×  STORE BYTE ON STACK
   SRA   R15,4                        ×  DIVIDE LENGTH BY 16
   SLA   R15,4                        ×  CALCULATE LENGTH / 16 * 16
   LA    R15,PWANSTK(R15)             ×  POINT R15 TO GROUP TO 16 BYTES
   MVC   PWALNST,0(15)                ×  MOVE GROUP TO PRINT LINE
  ELSE                                × IF STACK OVERFLOWED
   FILL  PWALNST,C'*'                 ×  MOVE *'S TO NESTING PART OF LI
   MVC   PWALMSG(19),=C'>E-4 STACK OVERFLOW' MOVE ERROR MESSAGE
   IF (CLI,PWAMAXRC,LT,4)             ×  IF MAX RETURN CODE < 4
    MVI   PWAMAXRC,4                  ×   MOVE 4 TO MAX RETURN CODE
   ENDIF                              ×  ENDIF
  ENDIF                               × ENDIF
  LH    R15,PWANSTL                   × LOAD LENGTH OF STACK
  LA    R15,1(,R15)                   × INCREMENT
  STH   R15,PWANSTL                   × STORE NEW LENGTH OF STACK
  CVD   R15,PWAD                      × CONVERT NESTING DEPTH TO DEC
  UNPK  PWALNL,PWAD                   × UNPACK INTO LINE
  OI    PWALNL+L'PWALNL-1,X'F0'       × REMOVE SIGN
  MVI   PWALPLS,X'40'                 × MOVE SPACE TO >16 FLAG
  IF (CH,R15,GT,=H'16')               × IF DEPTH > 16
   MVI   PWALPLS,C'+'                 ×  MOVE PLUS SIGN TO >16 FLAG
  ENDIF                               × ENDIF
 ENDBLK BLOCK=NEST                    ×
 EJECT                                ×
**--------------------------------------------------------------------*
**  SUBROUTINE - UNNEST
**
**  PARAMETERS - (CL1-TYPE)
**
**  THE ONE BYTE TYPE PASSED SHOULD BE EQUAL TO THE TOP ELEMENT ON THE
**  NESTING STACK.  IF IT MATCHES, THE ELEMENT IS POPPED OFF THE
**  STACK.  IF NOT, AN ERROR MESSAGE IS MOVED TO THE PRINT LINE.  IN
**  BOTH CASES,  16 BYTES OF THE STACK ARE MOVE TO THE PRINT LINE AS
**  DISCRIBED IN SUBROUTINE NEST.
**--------------------------------------------------------------------*
   SPACE 1                            ×
 BLOCK NAME=UNNEST,TYPE=SUBROUTINE    ×
  L     R1,0(,R1)                     × POINT R1 TO ONLY PARAMETER
  IC    R0,0(,R1)                     × INSERT TYPE PASSED IN R0
  LH    R15,PWANSTL                   × LOAD LENGTH OF STACK
  BCTR  R15,0                         × SUBTRACT 1
  IF (TREG,R15,NM)                    × IF STACK HAS NOT UNDERFLOWED
   IF (CH,R15,LT,=Y(L'PWANSTK))       ×  IF STACK IS NOT IN OVERFLOW
    LA    R1,PWANSTK(R15)             ×   POINT R1 TO TO ELEMENT OF STK
    IF (CLM,R0,B'0001',EQ,0(R1))      ×   IF TOP ELEMENT IS CORRECT
     STH   R15,PWANSTL                ×    STORE NEW LENGTH OF STACK
     CVD   R15,PWAD                   ×    CONVERT NESTING DEPTH TO DEC
     UNPK  PWALNL,PWAD                ×    UNPACK INTO LINE
     OI    PWALNL+L'PWALNL-1,X'F0'    ×    REMOVE SIGN
     MVI   PWALPLS,X'40'              ×    MOVE SPACE TO >16 FLAG
     IF (CH,R15,GT,=H'16')            ×    IF DEPTH > 16
      MVI   PWALPLS,C'+'              ×     MOVE PLUS SIGN TO >16 FLAG
     ENDIF                            ×    ENDIF
     MVI   0(R1),X'40'                ×    BLANK OUT OLD ELEMENT
     BCTR  R15,0                      ×    SUB 1 FROM R15
     SRA   R15,4                      ×    DIVIDE LENGTH BY 16
     SLA   R15,4                      ×    CALCULATE LENGTH / 16 * 16
     IF M                             ×    IF NEGATIVE
      LA    R15,0                     ×     SET R15 TO ZERO
     ENDIF                            ×    ENDIF
     LA    R15,PWANSTK(R15)           ×    POINT R15 TO 16 BYTE GROUP
     MVC   PWALNST,0(15)              ×    MOVE GROUP TO PRINT LINE
    ELSE                              ×   IF TOP ELEMENT NOT CORRECT
     MVC   PWALMSG(20),=C'>E-8 NESTING PROBLEM' MOVE ERROR MESSAGE
     IF (CLI,PWAMAXRC,LT,8)           ×    IF MAX RC < 8
      MVI   PWAMAXRC,8                ×     SET MAX RC TO 8
     ENDIF                            ×    ENDIF
    ENDIF                             ×   ENDIF
   ELSE                               ×  IF STACK IS STILL OVERFLOWED
    STH   R15,PWANSTL                 ×   SAVE NEW LENGTH OF STACK
    CVD   R15,PWAD                    ×   CONVERT NESTING DEPTH TO DEC
    UNPK  PWALNL,PWAD                 ×   UNPACK INTO LINE
    OI    PWALNL+L'PWALNL-1,X'F0'     ×   REMOVE SIGN
   ENDIF                              ×  ENDIF
  ELSE                                × IF STACK WILL UNDERFLOW
   MVC   PWALMSG(22),=C'>E-8 NESTING UNDERFLOW' MOVE ERROR MESSAGE
   IF (CLI,PWAMAXRC,LT,8)             ×  IF MAX RETURN CODE < 8
    MVI   PWAMAXRC,8                  ×   MOVE 8 TO MAX RETURN CODE
   ENDIF                              ×  ENDIF
  ENDIF                               × ENDIF
 ENDBLK BLOCK=UNNEST                  ×
 EJECT                                ×
**--------------------------------------------------------------------*
**  ERREXIT (UNNAMED)
**
**  WTO ERROR MESSAGE BASED ON CODE IN R14
**
**--------------------------------------------------------------------*
   SPACE 1                            ×
 BLOCK TYPE=ERREXIT                   ×ERREXIT (UNNAMED)
  MVC   PWAOPNER,PSDOPNER             × MOVE WTO LIST FORM TO PWA
  CASEBLK REG=R14                     × MOVE DDNAME FAILING TO WTO MSG
  CASE 0                              × CASE 0
   MVC   PWAEDDN,=CL8'SYSIN'          ×  SYSIN DATASET OPEN ERROR
  CASE 1                              × CASE 1
   MVC   PWAEDDN,=CL8'SYSPUNCH'       ×  SYSPUNCH DATASET OPEN ERROR
  CASE 2                              × CASE 2
   MVC   PWAEDDN,=CL8'SYSPRINT'       ×  SYSPRINT DATASET OPEN ERROR
  ENDCASE                             × ENDCASE
  WTO   MF=(E,PWAOPNER)               × USE WTO TO ISSUE MESSAGE
  LA    R15,16                        × SET BASE RETURN CODE
 ENDBLK ,                             ×ENDBLK
         TITLE 'PROGRAM STATIC DATA'  ×
         PSD                          ×
PSDOPNER WTO   'ERROR OPENING DDNAME=........',MF=L,ROUTCDE=11
PSDEDDN  EQU   PSDOPNER+4+21,8,C'C'   × TAG FOR DDNAME
PSDOPNER_LENGTH EQU *-PSDOPNER        × LENGTH OF WTO LIST FORM
         SPACE 1                      ×
PSDMTME  DC    X'402120',C':',X'2020' × MASK FOR TIME
PSDMDTE  DC    X'402120',C'.',X'202020' MASK FOR DATE
PSDMPGN  DC    X'402020202120'        × MASK FOR PAGE
         SPACE 1                      ×
PSDLPP   DC    PL2'60'                × MAXIMUM LINES PER PAGE
         SPACE 1                      ×
*        TITLE LINE
PSDT     DC    CL137' '               × TITLE LINE 1
         ORG   PSDT                   × ORG TO START OF TITLE LINE
         DC    AL2(137)               × LENGTH OF LINE
         DC    AL2(0)                 ×
         DC    C'1'                   × SKIP TO TOP OF PAGE
PSDTID   DC    CL8' '                 × ID FROM TITLE
         DC    C' '                   × SPACE
PSDTDTA  DC    CL100' '               × DATA FROM TITLE STATEMENT
         DC    CL12' '                × TIME
         DC    C' PAGE'               × C'PAGE'
PSDTPGN  DC    CL6' '                 × PAGE NUMBER
         ORG   ,                      ×
         SPACE 1                      ×
*        HEADING LINE
PSDH     DC    CL137' '               × PRINT LINE
         ORG   PSDH                   × ORG TO START OF LINE
         DC    AL2(137)               ×
         DC    AL2(0)                 ×
         DC    C'-'                   × CC
         DC    CL3'LVL'               × NESTING DEPTH
         DC    C' '                   × SPACE
         DC    C'+'                   × PLUS SIGN IF DEEPER THAN 16
         DC    CL16'    NESTING     ' × NESTING INFO
         DC    C'  '                  ×
         DC    CL80' SOURCE STATEMENT'  TEXT OF LINE
         DC    C'  '                  ×
         DC    C'MSC0150$ V1R4 '      × PROGRAM VERSION AND RELEASE @C4
PSDHTME  DC    CL6' '                 × TIME
PSDHDTE  DC    CL7' '                 × DATE
         ORG   ,                      ×
         SPACE 1                      ×
*        LINE
PSDL     DC    CL137' '               × PRINT LINE
         ORG   PSDL                   × ORG TO START OF LINE
         DC    AL2(137)               ×
         DC    AL2(0)                 ×
PSDLCC   DC    C' '                   × CC
PSDLNL   DC    CL3' '                 × NESTING LEVEL
         DC    C' '                   × SPACE
PSDLPLS  DC    C' '                   × PLUS SIGN IF DEEPER THAN 16
PSDLNST  DC    CL16' '                × NESTING INFO
         DC    C' ×'                  ×
PSDLTEXT DC    CL80' '                × TEXT OF LINE
         DC    C'× '                  ×
PSDLMSG  DC    CL27' '                × MESSAGE
         ORG   ,                      ×
         SPACE 1                      ×
*        BLANK LINE USED IN SPACING
PSDBLINE DC    AL2(6),AL2(0)          × BLANK LINE
PSDBLCC  DC    C' '                   × CC
         DC    C' '                   × BLANK FOR BLANK LINE
PSDBLINE_LENGTH EQU *-PSDBLINE        × LENGTH OF BLANK LINE
         SPACE 1                      ×
*        NOT AT LEVEL ZERO ERROR MESSAGE
PSDERLVL DC    AL2(45),AL2(0),C'0>E-8 ENDING STRUCTURAL LEVEL IS NON-ZE$
               RO'                    ×
         SPACE 1                      ×
*        LITERAL POOL                                               @C4
         LTORG ,                      ×                             @C4
         SPACE 1                      ×                             @C4
PSDOPN3  OPEN  (*,,*,,*),MF=L         ×
PSDOPN3_LENGTH EQU *-PSDOPN3          ×
         SPACE 3                      ×
PSDDIN   DCB   DDNAME=SYSIN,MACRF=GL,EODAD=EODADIN,DSORG=PS
PSDDIN_LENGTH EQU *-PSDDIN            ×
         SPACE 3                      ×
PSDDOUT  DCB   DDNAME=SYSPUNCH,MACRF=PM,LRECL=80,DSORG=PS,RECFM=FB
PSDDOUT_LENGTH EQU *-PSDDOUT          ×
         SPACE 3                      ×
PSDDPRT  DCB   DDNAME=SYSPRINT,MACRF=PM,LRECL=137,                     $
               RECFM=VBA,DSORG=PS     ×
PSDDPRT_LENGTH EQU *-PSDDPRT          ×
         SPACE 3                      ×
         ENDPSD ,                     ×                             @C4
         TITLE 'DSECTS'               ×
         PUSH  PRINT                  ×
         PRINT NOGEN                  ×
         DCBD  DSORG=PS               ×
         POP   PRINT                  ×
         SPACE 3                      ×
         TITLE 'PROGRAM WORK AREA'    ×
         PWA                          ×
PWAD     DS    D                      × WORK DOUBLE WORD
PWAAOPR  DS    A                      × ADDRESS OF OPERATION FIELD
PWAF1    DS    BL1                    × BIT FLAG
PWAF1EOF EQU   B'10000000'            ×   END OF FILE ON SYSIN
PWAF1NOW EQU   B'01000000'            ×   DO NOT WRITE
PWAF1QT  EQU   B'00100000'            ×   INSIDE OF A QUOTED STRING @C4
PWAF1CUP EQU   B'00010000'            ×   CONVERT TO UPPER IS ON    @C4
PWALNUM  DS    PL2                    × LINE NUMBER (TITLES FIRST TIME)
PWAPGN   DS    PL3                    × PAGE NUMBER
PWAMNL   DS    PL3                    × MACRO NESTING LEVEL
PWAMAXRC DS    X                      × MAXIMUM RETURN CODE
PWANSTK  DS    CL256                  × NESTING STACK
PWANSTL  DS    H                      × DISP OF NEXT ELEMENT ON STACK
*        INPUT LINE
PWALNE   DS    0CL80                  × INPUT LINE
PWATEXT  DS    CL71                   × LINE TEXT
PWACONT  DS    C                      × CONTINUE
         DS    CL8                    × LINE NUMBER
*        TITLE LINE
PWAT     DS    CL(L'PSDT)             × TITLE LINE 1
PWATID   EQU   PWAT+PSDTID-PSDT,L'PSDTID,C'C'      SEE PSDTID
PWATDTA  EQU   PWAT+PSDTDTA-PSDT,L'PSDTDTA,C'C'    SEE PSDTDTA
PWATPGN  EQU   PWAT+PSDTPGN-PSDT,L'PSDTPGN,C'C'    SEE PSDTPGN
*        HEADING LINE
PWAH     DS    CL(L'PSDH)             × HEADING LINE
PWAHTME  EQU   PWAH+PSDHTME-PSDH,L'PSDHTME,C'C'    SEE PSDHTME
PWAHDTE  EQU   PWAH+PSDHDTE-PSDH,L'PSDHDTE,C'C'    SEE PSDHDTE
*        UNALTERED LINE                                             @C4
PWAUNALT DS    CL80                   × UNALTERED PRINT LINE        @C4
*        LINE
PWAL     DS    CL(L'PSDL)             × PRINT LINE
PWALCC   EQU   PWAL+PSDLCC-PSDL,L'PSDLCC,C'C'      SEE PSDLCC
PWALNL   EQU   PWAL+PSDLNL-PSDL,L'PSDLNL,C'C'      SEE PSDLNL
PWALPLS  EQU   PWAL+PSDLPLS-PSDL,L'PSDLPLS,C'C'    SEE PSDLPLS
PWALNST  EQU   PWAL+PSDLNST-PSDL,L'PSDLNST,C'C'    SEE PSDLNST
PWALTEXT EQU   PWAL+PSDLTEXT-PSDL,L'PSDLTEXT,C'C'  SEE PSDLTEST
PWALMSG  EQU   PWAL+PSDLMSG-PSDL,L'PSDLMSG,C'C'    SEE PSDLMSG
*        BLANK LINE USED IN SPACING
PWABLINE DS    CL(PSDBLINE_LENGTH)    × BLANK LINE
PWABLCC  EQU   PWABLINE+PSDBLCC-PSDBLINE,L'PSDBLCC SEE PSDBLCC
*        ERROR WTO STORAGE
         DS    0F                     × INSURE FULLWORD ALIGNMENT
PWAOPNER DS    CL(PSDOPNER_LENGTH)    ×
PWAEDDN  EQU   PWAOPNER+PSDEDDN-PSDOPNER           SEE PSDEDDN
*        DCB STORAGE
         DS    0F                     × INSURE FULLWORD ALIGNMENT
PWAOPN3  DS    XL(PSDOPN3_LENGTH)     ×
         DS    0D                     × INSURE DOUBLEWORD ALIGNMENT
PWADIN   DS    XL(PSDDIN_LENGTH)      ×
         DS    0D                     × INSURE DOUBLEWORD ALIGNMENT
PWADOUT  DS    XL(PSDDOUT_LENGTH)     ×
         DS    0D                     × INSURE DOUBLEWORD ALIGNMENT
PWADPRT  DS    XL(PSDDPRT_LENGTH)     ×
         ENDPWA ,                     ×
         END     ,                    ×
