SCRIPT/VS 3.2.1: DEVICE 1403W8S CHARS MONO
¯
¸
¸
¸
¸
¸

                                         Clemson University Computer Ce
                                         Clemson University Computer Ce
                                         Clemson University Computer Ce
°                                         Clemson University Computer Ce
                                              Structured Programming Ma
                                              Structured Programming Ma
                                              Structured Programming Ma
°                                              Structured Programming Ma
                                                 User's Guide And Refer
                                                 User's Guide And Refer
                                                 User's Guide And Refer
°                                                 User's Guide And Refer
¸
¸
¸
¸
¸
¸
°                                                           March 27th,
¸
¸
¸
¸
°                                            Last revision: November 6,
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          ii    Clemson Structured Macros
¯
¸
                                                                    PRE
                                                                    PRE
                                                                    PRE
                                                                    PRE
°                                                                    ___
¸
°          The Structured Programming Macros is a programming tool devel
°          at  Clemson  University for internal use by the staff of the
°          puter Center.  However, after they were written, the decision
°          made to release them to the public since they are very useful
°          anyone who is programming in System/370 Assembler language.

°          The  macros  were designed to make the programmer's job easie
°          handling the often confusing but necessary  code  needed  in
°          program.    Things  like  program linkage, subroutines, param
°          lists, loops, and conditional sections are handled easily by
°          of  the macros.   This allows the user to concentrate on the
°          gram instead of the details, and also helps make  the  code
°          easier to read and debug.

°          The  Structured  Programming  Macros provide a means by which
°          Assembler  programmer  can  use  logical  programming  struct
°          normally available only in high-level languages.  Structures
°          DO WHILE, DO UNTIL, IF-THEN-ELSE, and CASE are available dire
°          through the macros.  More complex structures, such as SEARCH,
°          be  coded  simply  through a combination of the macros.  In a
°          tion, some useful macros that perform common functions  (such
°          flipping  bits  and  clearing  storage) are provided as a con
°          ience.

°          The macros are packaged in a macro library which may  be  con
°          enated  to  SYSLIB for Assembler H.  (There are catalogued pr
°          dures available at Clemson that concatenate this macro librar
°          SYS1.MACLIB.)

°          Among other things, the Structured Programming Macros may be
°          to handle addressing mode switching  and  linkage  under  MVS
°          Should you wish to use the 31-bit addressing features, you sh
          be familiar with the concepts described in MVS/XA SPL: 31-Bit
°                                                     __________________
          dressing, GC28-1158.  Using the macros, it becomes very simpl
°          _________
°          change  and restore addressing modes, both inline and for sub
°          tine calls.

°          Since the Structured Programming Macros provide all of the ne
°          control structures, the user should not have to code  any  br
°          instructions  (and  associated  statement  labels)  in a prog
°          This makes the source code much neater and easier to read.

°          This document will serve as an  introduction  to  the  Struct
°          Programming Macros, and assumes that the reader is already fa
°          iar  with  the  uses of common structured programming techniq
°          While the Structured Programming Macros serve  as  a  program
°          aid,  they  are  not meant to be a substitute for a working k
°          ledge of System/370 Assembler language and  System/370  archi
°          tures.      When  using  these  macros,  the  reader  should
°          arbitrarily assume that what the macros generate is some kind

°                                                             Preface
¯
¸
°          "magic code". It's not: in fact, the code generated by the ma
°          tends to look a lot like what a competent programmer would wr
°          When using the macros, look at the macro expansions occasiona
°          Knowing  a little about how the macros work will help you to
°          better use of them.

        × Note: In order to achieve  the  desired  level  of  functiona
          Note:
          Note:
°          Note:
°        × within  the  Structured  Macros, they have been written in su
°        × way as to require the use of the Level  H  Assembler.    Alth
°        × some  of  the  macros might not currently require Assembler H
°        × guarantee is made that any of the features  described  here
°        × work  with  the Level F Assembler.  Use of these macros with
        × thing other than Assembler H is not recommended.
                                          not
                                          not
°                                          not
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          iv    Clemson Structured Macros
¯
¸
                                                          TABLE OF CONT
                                                          TABLE OF CONT
                                                          TABLE OF CONT
                                                          TABLE OF CONT
°                                                          _____________
¸
          I. Structured Macros User's Guide  . . . . . . . . . . . . .
          I. Structured Macros User's Guide  . . . . . . . . . . . . .
          I. Structured Macros User's Guide  . . . . . . . . . . . . .
°          I. Structured Macros User's Guide  . . . . . . . . . . . . .

          Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . .
          Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . .
          Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . .
°          Chapter 1. Nesting Levels  . . . . . . . . . . . . . . . . .

          Chapter 2. Conditional Statements  . . . . . . . . . . . . .
          Chapter 2. Conditional Statements  . . . . . . . . . . . . .
          Chapter 2. Conditional Statements  . . . . . . . . . . . . .
°          Chapter 2. Conditional Statements  . . . . . . . . . . . . .
°          Standard Conditions  . . . . . . . . . . . . . . . . . . . .
°          Coding Conditional Expressions   . . . . . . . . . . . . . .
°        × User-Defined Conditions  . . . . . . . . . . . . . . . . . .

          Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . .
          Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . .
          Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . .
°          Chapter 3. Blocks  . . . . . . . . . . . . . . . . . . . . .
°          The Program Block  . . . . . . . . . . . . . . . . . . . . .
°          The Inline Block   . . . . . . . . . . . . . . . . . . . . .
°          The Subroutine Block   . . . . . . . . . . . . . . . . . . .
°          The ErrExit Block  . . . . . . . . . . . . . . . . . . . . .

          Chapter 4. Program Environments  . . . . . . . . . . . . . .
          Chapter 4. Program Environments  . . . . . . . . . . . . . .
          Chapter 4. Program Environments  . . . . . . . . . . . . . .
°          Chapter 4. Program Environments  . . . . . . . . . . . . . .
°          DC Environment   . . . . . . . . . . . . . . . . . . . . . .
°            System Mode And User Mode  . . . . . . . . . . . . . . . .
°            Reentrancy Under IDMS/DC   . . . . . . . . . . . . . . . .
°            *NORENT  . . . . . . . . . . . . . . . . . . . . . . . . .
°            *NORENTSYS   . . . . . . . . . . . . . . . . . . . . . . .
°            *RENT  . . . . . . . . . . . . . . . . . . . . . . . . . .
°            *RENTSYS   . . . . . . . . . . . . . . . . . . . . . . . .
°            *PWA   . . . . . . . . . . . . . . . . . . . . . . . . . .
°            *PWASYS  . . . . . . . . . . . . . . . . . . . . . . . . .
°          OS Environment   . . . . . . . . . . . . . . . . . . . . . .
°            *NORENT  . . . . . . . . . . . . . . . . . . . . . . . . .
°            *RENT  . . . . . . . . . . . . . . . . . . . . . . . . . .
°            *PWA   . . . . . . . . . . . . . . . . . . . . . . . . . .
°            *MAIN  . . . . . . . . . . . . . . . . . . . . . . . . . .
°            *NOMAIN  . . . . . . . . . . . . . . . . . . . . . . . . .
°            *SRVPRC  . . . . . . . . . . . . . . . . . . . . . . . . .
°          PL/I Environment   . . . . . . . . . . . . . . . . . . . . .
°            *STDPLI  . . . . . . . . . . . . . . . . . . . . . . . . .
°          Other Environments   . . . . . . . . . . . . . . . . . . . .
°          Subroutine Block Super Options   . . . . . . . . . . . . . .
°            *SWA   . . . . . . . . . . . . . . . . . . . . . . . . . .
°            *NOSUBOPTS   . . . . . . . . . . . . . . . . . . . . . . .
°          Conclusion   . . . . . . . . . . . . . . . . . . . . . . . .

          Chapter 5. Program and Subroutine Work Areas   . . . . . . .
          Chapter 5. Program and Subroutine Work Areas   . . . . . . .
          Chapter 5. Program and Subroutine Work Areas   . . . . . . .
°          Chapter 5. Program and Subroutine Work Areas   . . . . . . .
°          Program Work Areas   . . . . . . . . . . . . . . . . . . . .
°        × Reusable Program Work Areas  . . . . . . . . . . . . . . . .
°          Subroutine Work Areas  . . . . . . . . . . . . . . . . . . .
°          SWA Placement  . . . . . . . . . . . . . . . . . . . . . . .
°          PSDs and SSDs  . . . . . . . . . . . . . . . . . . . . . . .

          Chapter 6. Large Program Management  . . . . . . . . . . . .
          Chapter 6. Large Program Management  . . . . . . . . . . . .
          Chapter 6. Large Program Management  . . . . . . . . . . . .
°          Chapter 6. Large Program Management  . . . . . . . . . . . .
°          PWAs and SWAs with Dynamic Storage Management  . . . . . . .
°            Recursive Subroutines with the DYN Option  . . . . . . . .

°                                                     Table of Contents
¯
¸
°            Storage Calculations with the DYN Option   . . . . . . . .
°            SWA Addressability with the DYN Option   . . . . . . . . .
°            Super Options Used with the DYN Option   . . . . . . . . .
°            Storage Optimization with the DYN Option   . . . . . . . .
°          LONG and LOADBASE  . . . . . . . . . . . . . . . . . . . . .
°          Size Limitations   . . . . . . . . . . . . . . . . . . . . .
°          Conclusion   . . . . . . . . . . . . . . . . . . . . . . . .

          Chapter 7. The IF Structure  . . . . . . . . . . . . . . . .
          Chapter 7. The IF Structure  . . . . . . . . . . . . . . . .
          Chapter 7. The IF Structure  . . . . . . . . . . . . . . . .
°          Chapter 7. The IF Structure  . . . . . . . . . . . . . . . .

          Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . .
          Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . .
          Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 8. Loops   . . . . . . . . . . . . . . . . . . . . .

          Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . .
          Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . .
          Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . .
°          Chapter 9. CASEs and CASE Blocks   . . . . . . . . . . . . .

        × Chapter 10. Parameter Lists and Standard Linkage   . . . . .
          Chapter 10. Parameter Lists and Standard Linkage   . . . . .
          Chapter 10. Parameter Lists and Standard Linkage   . . . . .
°          Chapter 10. Parameter Lists and Standard Linkage   . . . . .
°        × Referencing Input Parameter Lists  . . . . . . . . . . . . .
°          Generating Parameter Lists   . . . . . . . . . . . . . . . .
°          Automatic Parameter Lists  . . . . . . . . . . . . . . . . .
°          Permanent Parameter Lists  . . . . . . . . . . . . . . . . .
°        × Calling Subroutines  . . . . . . . . . . . . . . . . . . . .
°          Parameter Lists on CALLSUB and CALLX   . . . . . . . . . . .
°          Recommendations  . . . . . . . . . . . . . . . . . . . . . .
°        × Example Source   . . . . . . . . . . . . . . . . . . . . . .

        × Chapter 11. Location and Scope of Data Structures  . . . . .
          Chapter 11. Location and Scope of Data Structures  . . . . .
          Chapter 11. Location and Scope of Data Structures  . . . . .
°          Chapter 11. Location and Scope of Data Structures  . . . . .
°        × Local Scope within Subroutines   . . . . . . . . . . . . . .

          Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . .
          Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . .
          Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . .
°          Chapter 12. Miscellaneous Macros   . . . . . . . . . . . . .
°          Bit Manipulation   . . . . . . . . . . . . . . . . . . . . .
°          Testing A Register   . . . . . . . . . . . . . . . . . . . .
°          Initializing Storage   . . . . . . . . . . . . . . . . . . .
°          Register Loading   . . . . . . . . . . . . . . . . . . . . .
°          Executing Instructions   . . . . . . . . . . . . . . . . . .
°          Loading control block addresses  . . . . . . . . . . . . . .
°        × Controlling Structured Macro Operation   . . . . . . . . . .

          Chapter 13. Miscellaneous Examples   . . . . . . . . . . . .
          Chapter 13. Miscellaneous Examples   . . . . . . . . . . . .
          Chapter 13. Miscellaneous Examples   . . . . . . . . . . . .
°          Chapter 13. Miscellaneous Examples   . . . . . . . . . . . .
°          A Search Loop  . . . . . . . . . . . . . . . . . . . . . . .
°          Scanning Text  . . . . . . . . . . . . . . . . . . . . . . .
°          A DCB EODAD Exit   . . . . . . . . . . . . . . . . . . . . .
°          Returning R0 and R1 with ENDBLK  . . . . . . . . . . . . . .

        × Chapter 14. Structured Macros Listing Program  . . . . . . .
          Chapter 14. Structured Macros Listing Program  . . . . . . .
          Chapter 14. Structured Macros Listing Program  . . . . . . .
°          Chapter 14. Structured Macros Listing Program  . . . . . . .
°        × Output of the Listing Program  . . . . . . . . . . . . . . .
°        × Controlling Listing Program Operation  . . . . . . . . . . .

          II. Structured Macros Reference  . . . . . . . . . . . . . .
          II. Structured Macros Reference  . . . . . . . . . . . . . .
          II. Structured Macros Reference  . . . . . . . . . . . . . .
°          II. Structured Macros Reference  . . . . . . . . . . . . . .

          Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . .
          Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . .
          Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . .
°          Chapter 15. BLOCK  . . . . . . . . . . . . . . . . . . . . .
°          BLOCK TYPE=ERREXIT   . . . . . . . . . . . . . . . . . . . .
°          BLOCK TYPE=INLINE  . . . . . . . . . . . . . . . . . . . . .
°          BLOCK TYPE=PROGRAM,ENVIRON=DC  . . . . . . . . . . . . . . .
°          BLOCK TYPE=PROGRAM,ENVIRON=OS  . . . . . . . . . . . . . . .
°          BLOCK TYPE=PROGRAM,ENVIRON=PLI   . . . . . . . . . . . . . .

°          vi    Clemson Structured Macros
¯
¸
°          BLOCK TYPE=SUBROUTINE  . . . . . . . . . . . . . . . . . . .

          Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . .
          Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . .
          Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . .
°          Chapter 16. CALLSUB  . . . . . . . . . . . . . . . . . . . .

          Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . .
          Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . .
          Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . .
°          Chapter 17. CALLX  . . . . . . . . . . . . . . . . . . . . .

          Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . .
          Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . .
          Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 18. CASE   . . . . . . . . . . . . . . . . . . . . .

          Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . .
          Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . .
          Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . .
°          Chapter 19. CASEBLK  . . . . . . . . . . . . . . . . . . . .

        × Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . .
          Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . .
          Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . .
°          Chapter 20. DEFUCOND   . . . . . . . . . . . . . . . . . . .

          Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . .
          Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . .
          Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 21. ELSE   . . . . . . . . . . . . . . . . . . . . .

          Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . .
          Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . .
          Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . .
°          Chapter 22. ELSEIF   . . . . . . . . . . . . . . . . . . . .

          Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . .
          Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . .
          Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . .
°          Chapter 23. ENDBLK   . . . . . . . . . . . . . . . . . . . .

          Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . .
          Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . .
          Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . .
°          Chapter 24. ENDCASE  . . . . . . . . . . . . . . . . . . . .

          Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . .
          Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . .
          Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . .
°          Chapter 25. ENDIF  . . . . . . . . . . . . . . . . . . . . .

          Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . .
          Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . .
          Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . .
°          Chapter 26. ENDLOOP  . . . . . . . . . . . . . . . . . . . .

          Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . .
          Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . .
          Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . .
°          Chapter 27. ENDPSD   . . . . . . . . . . . . . . . . . . . .

          Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . .
          Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . .
          Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . .
°          Chapter 28. ENDPWA   . . . . . . . . . . . . . . . . . . . .

          Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . .
          Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . .
          Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . .
°          Chapter 29. ENDSSD   . . . . . . . . . . . . . . . . . . . .

          Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . .
          Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . .
          Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . .
°          Chapter 30. ENDSWA   . . . . . . . . . . . . . . . . . . . .

          Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . .
          Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . .
          Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . .
°          Chapter 31. ERREXIT  . . . . . . . . . . . . . . . . . . . .

          Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . .
°          Chapter 32. EXI  . . . . . . . . . . . . . . . . . . . . . .

          Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . .
          Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . .
          Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 33. FILL   . . . . . . . . . . . . . . . . . . . . .

          Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 34. IBIT   . . . . . . . . . . . . . . . . . . . . .

          Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .
          Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .
          Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .
°          Chapter 35. IF   . . . . . . . . . . . . . . . . . . . . . .

          Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .
          Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .
          Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 36. LCBA   . . . . . . . . . . . . . . . . . . . . .

          Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .
          Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .
          Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .
°          Chapter 37. LEAVE  . . . . . . . . . . . . . . . . . . . . .

          Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .
          Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .
          Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 38. LOOP   . . . . . . . . . . . . . . . . . . . . .

          Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .
          Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .
          Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .
°          Chapter 39. L8, L16, L24, L32  . . . . . . . . . . . . . . .

          Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .
          Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .
          Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .
°          Chapter 40. PLIST  . . . . . . . . . . . . . . . . . . . . .

          Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .
°          Chapter 41. PSD  . . . . . . . . . . . . . . . . . . . . . .
¸
°                                                   Table of Contents
¯
¸
          Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .
°          Chapter 42. PWA  . . . . . . . . . . . . . . . . . . . . . .

          Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 43. RBIT   . . . . . . . . . . . . . . . . . . . . .

          Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 44. SBIT   . . . . . . . . . . . . . . . . . . . . .

          Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .
          Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .
          Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .
°          Chapter 45. SMCTRL   . . . . . . . . . . . . . . . . . . . .

        × Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .
          Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .
          Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .
°          Chapter 46. SMLIST   . . . . . . . . . . . . . . . . . . . .

        × Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .
          Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .
          Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .
°          Chapter 47. SMSYMS   . . . . . . . . . . . . . . . . . . . .

          Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .
°          Chapter 48. SSD  . . . . . . . . . . . . . . . . . . . . . .

          Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .
          Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .
          Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .
°          Chapter 49. STRSA  . . . . . . . . . . . . . . . . . . . . .

          Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .
          Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .
°          Chapter 50. SWA  . . . . . . . . . . . . . . . . . . . . . .

          Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .
          Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 51. TBIT   . . . . . . . . . . . . . . . . . . . . .

          Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .
          Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .
          Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .
°          Chapter 52. TREG   . . . . . . . . . . . . . . . . . . . . .

        × Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .
          Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .
          Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .
°          Chapter 53. ##COND   . . . . . . . . . . . . . . . . . . . .

          Appendix A. Catalogued ASM Procedures At Clemson   . . . . .
          Appendix A. Catalogued ASM Procedures At Clemson   . . . . .
          Appendix A. Catalogued ASM Procedures At Clemson   . . . . .
°          Appendix A. Catalogued ASM Procedures At Clemson   . . . . .

          Appendix B. Internal Macros Error Messages   . . . . . . . .
          Appendix B. Internal Macros Error Messages   . . . . . . . .
          Appendix B. Internal Macros Error Messages   . . . . . . . .
°          Appendix B. Internal Macros Error Messages   . . . . . . . .

          Appendix C. Work Area Storage Layout   . . . . . . . . . . .
          Appendix C. Work Area Storage Layout   . . . . . . . . . . .
          Appendix C. Work Area Storage Layout   . . . . . . . . . . .
°          Appendix C. Work Area Storage Layout   . . . . . . . . . . .
°          Work Area Layout with the DYN Option   . . . . . . . . . . .
°          Work Area Layout with NODYN and ENVIRON=DC   . . . . . . . .
°          Work Area Layout with NODYN and ENVIRON=OS   . . . . . . . .
°          Work Area Layout with NODYN and ENVIRON=PLI  . . . . . . . .

          Appendix D. Program Code and Static Data Layout  . . . . . .
          Appendix D. Program Code and Static Data Layout  . . . . . .
          Appendix D. Program Code and Static Data Layout  . . . . . .
°          Appendix D. Program Code and Static Data Layout  . . . . . .

          Appendix E. Register Usage   . . . . . . . . . . . . . . . .
          Appendix E. Register Usage   . . . . . . . . . . . . . . . .
          Appendix E. Register Usage   . . . . . . . . . . . . . . . .
°          Appendix E. Register Usage   . . . . . . . . . . . . . . . .
°          Register Usage for ENVIRON=DC  . . . . . . . . . . . . . . .
°            IDMS/DC User Mode Registers And Linkage  . . . . . . . . .
°            IDMS/DC System Mode Registers And Linkage  . . . . . . . .
°          Register Usage for ENVIRON=OS  . . . . . . . . . . . . . . .
°          Register Usage for ENVIRON=PLI   . . . . . . . . . . . . . .
¸
¸
¸
¸

°          viii    Clemson Structured Macros
¯
¸
                                                      SUMMARY OF AMENDM
                                                      SUMMARY OF AMENDM
                                                      SUMMARY OF AMENDM
                                                      SUMMARY OF AMENDM
°                                                      _________________
¸
        × Update November 6, 1989
          Update November 6, 1989
          Update November 6, 1989
          Update November 6, 1989
°          _______________________

°        × 1.   Two  new  macros (DEFUCOND and ##COND) are provided to a
°        ×      the programmer to define new conditional tests that  can
°        ×      inserted into any conditional expression.

°        × 2.   The  COPYERROR  and  COUNT suboptions have been added to
°        ×      PARMS option.
¸
        × Update April 19, 1989
          Update April 19, 1989
          Update April 19, 1989
          Update April 19, 1989
°          _____________________

°        × 1.   The Structured Macros now require the Level H Assembler
°        ×      correct  operation.  Do not use them with the Level F As
°        ×      bler.

°        × 2.   Changes were made in the PLIST macro to allow more  flex
°        ×      specification  of parameters.  Most notably, indirect re
°        ×      encing is now supported.

°        × 3.   Symbols have been provided to allow the  program  to  lo
°        ×      the start of major structures such as the PWA, PSD, SWA,
°        ×      SSD.

°        × 4.   An automatic prefixing facility has been added to allow
°        ×      grammers to name storage tags in a subroutine without ha
°        ×      to  worry  about  what  tags  in other subroutines have
°        ×      named.

°        × 5.   A SMLIST macro has been added to control the output  of
°        ×      Structured  Macros listing program.  Currently, the only
°        ×      tion is to provide for automatic conversion of  the  pro
°        ×      to uppercase before assembly.
¸
          Update October 1, 1987
          Update October 1, 1987
          Update October 1, 1987
          Update October 1, 1987
°          ______________________

°          1.   Support  was  added  for writing Service Processors with
°               Structured Macros.  Service Processors are programs that
°               called repeatedly to process one of a variety of  functi
°               and that retain their workarea between calls.  To learn
               about  Service  Processors,  see Clemson University Comp
°                                                _______________________
               Center Service Processor User's Guide and  Reference.
°               ____________________________________________________
°               Service  Processor support includes new options and keyw
°               on the BLOCK macro and a new super option.

°                                                Summary of Amendments
¯
¸
°          2.   The SMCTRL macro was added to set internal flags that af
°               the operation of the Structured Macros.  Currently, this
°               only used for Service Processor support.
¸
          Update March 11, 1987
          Update March 11, 1987
          Update March 11, 1987
          Update March 11, 1987
°          _____________________

°          1.   An ENVIRON keyword was added to the BLOCK TYPE=PROGRAM m
°               to  allow for the different linkage conventions in diffe
°               program environments.  Currently, the supported environm
°               are:  OS, DC, and PLI.

°          2.   Support was added for PWAs in non-reentrant programs.

°          3.   R0 and R1 keywords were added to the ENDBLK macro  for
°               grams  to enable a program to pass back registers 0 and
°               its caller.

°          4.   The error messages issued by internal macros have been m
°               to their own section.

°          5.   Minor editorial changes have been made.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          x    Clemson Structured Macros
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
                                          I. STRUCTURED MACROS USER'S G
                                          I. STRUCTURED MACROS USER'S G
                                          I. STRUCTURED MACROS USER'S G
                                          I. STRUCTURED MACROS USER'S G
°                                          _____________________________
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          2    Structured Macros Users's Guide
¯
¸
                                                  CHAPTER 1. NESTING LE
                                                  CHAPTER 1. NESTING LE
                                                  CHAPTER 1. NESTING LE
                                                  CHAPTER 1. NESTING LE
°                                                  _____________________
¸
°          There  are  4 major building blocks that can be nested. These
          the block, the if/elseif, the loop, and  the  case  block.
°              ______     __________     _____           ____________
°          Structured  Programming  Macros  support nesting to a depth o
°          for each structure. The structures may be intermixed:  for  e
°          ple,  a BLOCK can contain IF structures, and a LOOP may conta
°          CASE block, which may in turn contain  more  LOOPs.    Levels
°          nesting are opened and closed by the use of complementary mac
°          like BLOCK/ENDBLK, LOOP/ENDLOOP, IF/ENDIF and CASEBLK/ENDCASE

°          The user of these macros might find it helpful to start inden
°          source  statements  as  nesting levels vary.  Since no labels
°          required in the program code, the user can code statement  st
°          ing  in  column  two and indent while still leaving room for
°          ments.  Consider the following examples: in the  first,  oper
°          are coded in fixed columns, as is common practice.

°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿

°                   BLOCK   NAME=TEST
°                   IF  (condition1),THEN
°                   LOOP      WHILE,(condition2)
°                   LEAVE     (condition3,),IF=*
°                   ENDLOOP  WHILE
°                   ENDIF
°                   ENDBLK

°            Figure 1.  Unindented Assembler Source
°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿

°          In  Figure 2  on  page  2, however, the same instructions are
°          dented based on the nesting level of each.  While the second
°          ample may look unusual to the hardened Assembler programmer,
°          easier  to follow the nesting levels, and thus the logical st
°          ture, by sight alone.

°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿

°             BLOCK NAME=TEST
°              IF   (condition1),THEN
°               LOOP      WHILE,(condition2)
°                LEAVE    LOOP=*,(condition3)
°               ENDLOOP   WHILE
°              ENDIF
°             ENDBLK

°            Figure 2.  Indented Assembler Source
°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
¸

°                                             Chapter 1. Nesting Levels
¯
¸
°          Since the macros require proper nesting of structures to gene
°          tags  for branches and the like, correct pairing of complemen
°          macros is important.  The structured assembler  cataloged  pr
°          dures  in  use  at  Clemson include a pre-step that examines
°          source for  nesting  problems  and  lists  your  program  wit
°          nesting-level  report.  This  pre-processor is described late
°          "Appendix A. Catalogued ASM Procedures At Clemson" on page 12

°          The nesting of structures provides a very specific path  for
°          program  to  follow.   This can be interrupted where necessar
°          the use of the LEAVE macro.   This macro allows  the  program
°          leave  a  structure  prematurely either conditionally or unco
°          tionally.  By default, the LEAVE macro will leave  the  inner
°          structure of the type specified.  However, it can be used to
°          a  structure  from  any depth.   If you are leaving from a de
°          nested series of inline blocks, restoring  registers  and  AM
°          properly  is a complicated task.  The LEAVE macro can handle
°          task nicely.  The programmer should not have to worry about t
°          You can leave an arbitrarily complex  structure  and  LEAVE
°          handle the details.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°          4    Structured Macros Users's Guide
¯
¸
                                          CHAPTER 2. CONDITIONAL STATEM
                                          CHAPTER 2. CONDITIONAL STATEM
                                          CHAPTER 2. CONDITIONAL STATEM
                                          CHAPTER 2. CONDITIONAL STATEM
°                                          _____________________________
¸
°          Using  the Structured Macros, conditional expressions are def
°          in terms of the instruction(s) that  will  make  the  compari
°          Conditional expressions are mandatory on some macros (IF, ELS
°          and  some  forms  of  LOOP)  and  optional  on  others (LEAVE
°          ERREXIT).   The syntax of a conditional  expression  on  each
°          these macros is identical.
¸

          STANDARD CONDITIONS
          STANDARD CONDITIONS
          STANDARD CONDITIONS
          STANDARD CONDITIONS
°          ___________________

°          The format of a single condition can be any of the following:

              (CLC,operand1,condition,operand2)
               CLC,
               CLC,
°               CLC,

              (CR,operand1,condition,operand2)
               CR,
               CR,
°               CR,

              (C,operand1,condition,operand2)
               C,
               C,
°               C,

              (CP,operand1,condition,operand2)
               CP,
               CP,
°               CP,

              (CH,operand1,condition,operand2)
               CH,
               CH,
°               CH,

              (CLR,operand1,condition,operand2)
               CLR,
               CLR,
°               CLR,

              (CL,operand1,condition,operand2)
               CL,
               CL,
°               CL,

              (CLI,operand1,condition,operand2)
               CLI,
               CLI,
°               CLI,

              (CLCL,operand1,condition,operand2)
               CLCL,
               CLCL,
°               CLCL,

              (TM,operand1,condition,operand2)
               TM,
               TM,
°               TM,

              (CLM,operand1,mask,condition,operand2)
               CLM,
               CLM,
°               CLM,

              (TREG,operand1,condition)
               TREG,
               TREG,
°               TREG,

              (TBIT,[operand1,]operand2[,ON×OFF×ANY×MIXED ])  default O
               TBIT,                    ,ON×OFF×ANY×MIXED
               TBIT,                    ,ON×OFF×ANY×MIXED
°               TBIT,                    ,ON×OFF×ANY×MIXED

              (#TEST,operand1[,ON×OFF×ANY ])  default ON
               #TEST,         ,ON×OFF×ANY
               #TEST,         ,ON×OFF×ANY
°               #TEST,         ,ON×OFF×ANY

°          where:

°          ø   The  first parameter is the machine or macro instruction
°              is to be used to perform the comparison.  CLC, CR, C, CP,
°              CLR, CL, CLI, CLCL, TM and CLM  are  all  S/370  machine
°              structions.   TREG is a macro that tests a register for z
°              positive, or negative.  TBIT is another macro  that  is

°                                     Chapter 2. Conditional Statements
¯
¸
°              for testing bits.  As signified, the only conditions that
°              be specified for TBIT are ON, OFF, ANY and MIXED.  #TEST
°              ports the IDMS/DC #TEST macro.  #TEST supports the condit
°              ON, OFF and ANY.

          ø   operand1 is the first operand of the specified instructio
              operand1
              operand1
°              operand1
°              macro.   Any valid form of the operand for the comparison
°              ing performed is allowed.

          ø   operand2 is the second operand of the  specified  instruc
              operand2
              operand2
°              operand2
°              or  macro.   Any valid form of the operand for the compar
°              being performed is allowed.

          ø   mask is the mask operand of the CLM instruction  and  can
              mask
              mask
°              mask
°              any form that is valid in the instruction itself.

          ø   condition may be coded as one of the following:
              condition
              condition
°              condition

              EQ      Equal
              EQ
              EQ
°              EQ
              E       Equal
              E
              E
°              E
              NE      Not equal
              NE
              NE
°              NE
              LT      Less than
              LT
              LT
°              LT
              GT      Greater than
              GT
              GT
°              GT
              LE      Less than or equal
              LE
              LE
°              LE
              GE      Greater than or equal
              GE
              GE
°              GE
              Z       Zero
              Z
              Z
°              Z
              NZ      Not zero
              NZ
              NZ
°              NZ
              M       Minus or mixed
              M
              M
°              M
              NM      Not minus or not mixed
              NM
              NM
°              NM
              P       Positive
              P
              P
°              P
              NP      Not positive
              NP
              NP
°              NP
              O       Ones or overflow
              O
              O
°              O
              NO      Not ones or not overflow
              NO
              NO
°              NO
              ON      All flags on
              ON
              ON
°              ON
              OFF     All flags off
              OFF
              OFF
°              OFF
              ANY     Any flags on
              ANY
              ANY
°              ANY
              MIXED   Mixed
              MIXED
              MIXED
°              MIXED
              CCnn    Condition code, CC1 through CC14
              CCnn
              CCnn
°              CCnn

°          The conditional expression coded will expand using the compar
°          instruction(s)  provided  and  appropriate  conditional branc
°          For example, instead of the expression "IF A=B,THEN",  one  w
°          code "IF (CLC,A,EQ,B),THEN", which would generate a "CLC A,B"
°          a BNE instruction to the appropriate ELSE, ELSEIF or ENDIF ma
¸
          CODING CONDITIONAL EXPRESSIONS
          CODING CONDITIONAL EXPRESSIONS
          CODING CONDITIONAL EXPRESSIONS
          CODING CONDITIONAL EXPRESSIONS
°          ______________________________

°          Boolean  expressions and nested conditions are available when
°          ing the Structured Macros.  Using the Boolean operators  AND,
°          and  NOT,  conditional  expressions  may be nested and/or con
°          enated on a single macro.  Under Assembler H (IEV90),  the  d

°          6    Structured Macros Users's Guide
¯
¸
°          of  nesting  is limited to 255 characters within the outer pa
°          theses.  Multiple conditions are evaluated following  the  no
°          precedence  rules  with expressions in parentheses taking pre
°          ence and NOT being done before AND, and AND being done before

°          For example, one may code:

°             IF   NOT,(CLC,A,EQ,B)

°          which is equivalent to:

°             IF   (CLC,A,NE,B)

°          Multiple conditions may be coded together, as in this example

°             IF   ((CLC,A,EQ,B),OR,(CLC,C,EQ,D),AND,(CLC,E,EQ,D))

°          which is equivalent to:

°             IF   ((CLC,A,EQ,B),OR,((CLC,C,EQ,D),AND,(CLC,E,EQ,D)))

°          The  rules  of  Boolean  algebra  are  followed by the Struct
°          Macros.  For example, the Boolean expression "NOT (x AND  y)"
°          equivalent to "NOT (x) OR NOT (y)".  Similarly, the IF statem

°             IF   (NOT,((CLC,A,EQ,B),AND,(CLC,C,EQ,D))),THEN

°          and the IF statement

°             IF   (NOT,(CLC,A,EQ,B),OR,NOT,(CLC,C,EQ,D)),THEN

°          and the IF statement

°             IF   ((CLC,A,NE,B),OR,(CLC,C,NE,D)),THEN

°          will all generate identical code.

°          Although  parentheses and the precedence rules affect the mea
°          of the expressions, the comparisons are always generated  in
°          order  that  they  are coded.   There are two cases where thi
°          significant.  Consider the following example:

°             IF   ((CLI,A,EQ,C'Y'),AND,(C,R3,EQ,B))

°          The second comparison will only be done if  the  first  one
°          ceeds.    This can be very useful if you only have addressabi
°          for the second comparison if the first one is true.  Another
°          where coding order is important can be illustrated by the fol
°          ing two IF statements:

°             IF   ((Z),OR,(CLC,A,EQ,B))
°             IF   ((CLC,A,EQ,B),OR,(Z))
¸

°                                     Chapter 2. Conditional Statements
¯
¸
°          In the first example, the zero conditional  test  refers  to
°          condition code that exists from a previous instruction before
°          IF  is encountered.   In the second example, the zero conditi
°          test refers to the result of the compare that precedes it.
°          cause  it  is  sometimes difficult to determine which compari
°          will actually be performed in a particular multiple condition
°          statement,  it is usually a good practice to put a condition
°          with no comparison only at the beginning of an IF.
¸
        × USER-DEFINED CONDITIONS
          USER-DEFINED CONDITIONS
          USER-DEFINED CONDITIONS
          USER-DEFINED CONDITIONS
°          _______________________

°        × Although the conditions supported by the Structured Macros  c
°        × most  of  the  standard  types  of  comparisions, there are o
°        × sionally instances where they are not sufficient.   To avoid
°        × pleasant  side-effects,  we have decided that our conditions
°        × never modify storage locations or registers.   Therefore,  we
°        × not  have  conditions  for  things  like TRT (Translate and T
°        × which modifies registers one and two.  In addition, many prog
°        × will have tests involving more than a simple compare that the
°        × repeatedly.  It would be helpful to be able to code  these  t
°        × within a Structured Macros conditional expression.

°        × Fortunately, there is a very easy way to get around both of t
°        × situations.    The  Structured Macros provide a facility to a
°        × you to define your own  conditional  tests  that  can  be  pl
°        × within  any  conditional expression.  User-defined conditions
°        × identified by a percent sign (%) and may have any number of o
°        × ands following them.  For example, suppose you wanted to be
°        × to code something like this:

°        ×   IF    ((TREG,R4,NZ),AND,(%TRT,0(8,R4),NE,PSDVALID))
°        ×   &invellip.
°        ×   ENDIF

°        × Before you can use the %TRT condition, you need to do two thi
°        × First, you must define the condition name itself and identify
°        × macro  that  will  process  it.    This is done with the DEFU
°        × macro.  Second, you must code the macro itself.  For our %TRT
°        × ample, these two steps would look like this:

°        ×      DEFUCOND NAME=TRT,MACRO=TRT_UCOND   × Define the conditi
°        ×             MACRO
°        ×    &NAME    TRT_UCOND &EXPR,&S=,&F=,&L=  × Our TRT macro.
°        ×             AIF (N'&EXPR NE 4).ERR0001   × Were we called wro
°        ×    &NAME    TRT   &EXPR(2),&EXPR(4)      × Do TRT instruction
°        ×             ##COND &EXPR(3),             × Test result and br
°        ×                   S=&S,F=&F,L=&L         ×   as appropriate.
°        ×             MEXIT
°        ×    .ERR0001 MNOTE 8,'Too many parameters in %TRT expr'
°        ×             MEND
¸
°          8    Structured Macros Users's Guide
¯
¸
°        × There are several important requirements that all  user-condi
°        × macros  must  meet.    Once  those  are understood, writing t
°        × macros becomes quite simple.  First, the &NAME label is  requ
°        × and  must  identify  the  first executable statement generate
°        × your  macro.   The Structured Macros will generate a unique l
°        × for &NAME so that they can branch to your condition  when  it
°        × part of a compound conditional expression.

°        × Next  come  the  parameters  that your macro will be called w
°        × The first parameter is positional and will be the  entire  co
°        × tion  that  invoked this macro including the condition name.
        × our previous example, this would  be  (%TRT,0(8,R4),NE,PSDVAL
                                                (%TRT,0(8,R4),NE,PSDVAL
                                                (%TRT,0(8,R4),NE,PSDVAL
°                                                (%TRT,0(8,R4),NE,PSDVAL
°        × The  individual  fields  within the condition can be extracte
°        × subscripting the expression.  For example &EXPR(3) for the  t
°        × item  in  the expression (NE).  The next three keyword parame
°        × (S=, F=, and L=) define the  tag  names  that  the  macro  sh
°        × branch  to  on success and failure and indicate the logic of
°        × conditional (P for positive and N for negative).

°        × The Logic keyword (L=) needs a little explaining.  Positive l
°        × says that the macro should branch to the success tag if the
°        × dition is true and fall through to the following code if the
°        × dition  is false.  Positive logic is used for things like ERR
°        × and LEAVE.  Negative logic says to branch to the failure  tag
°        × the  condition  is false and fall through if it is true.  Thi
°        × used in standard IF statements.

°        × The ##COND macro is an internal macro that should  only  be
°        × within  other  macros.   Its purpose is to evaluate a conditi
°        × expression and properly process the S=, F=, and L= keywords.
°        × expression passed to ##COND can  be  any  valid  conditional
°        × pression  including  boolean  expressions, nested conditions,
°        × other  user-defined  conditions.    Most  user-defined  condi
°        × macros will include a ##COND macro to perform the actual test
°        × process the S=, F=, and L= keywords.  This greatly simplifies
°        × macro.

°        × For  another  example, what if you wanted to be able to check
°        × status of ISPF like this?

°        ×   IF    (%ISPFACT)
°        ×   &invellip.
°        ×   ELSE
°        ×   &invellip.
°        ×   ENDIF

°        × You would need to define the %ISPFACT condition like this:
¸
¸
¸
°                                     Chapter 2. Conditional Statements
¯
¸
°        ×     DEFUCOND NAME=ISPFACT,MACRO=ISPF_UCOND
°        ×             MACRO
°        ×    &NAME    ISPF_UCOND &EXPR,&S=,&F=,&L=
°        ×             AIF (N'&EXPR NE 1).ERR0001   × Check number of pa
°        ×    &NAME    LINK  EP=ISPQRY              × Call ISPF status r
°        ×             ##COND (TREG,R15,Z),         × Check condition co
°        ×                   S=&S,F=&F,L=&L
°        ×             MEXIT
°        ×    .ERR0001 MNOTE 8,'Too many parameters in %ISPFACT expr'
°        ×             MEND

°        × There are several user-defined conditions provided in a copy
°        × ber  called SMPUCOND.   These should provide good examples of
°        × to code user conditions and may also be useful in programs.
        × can  include  them  in  your  programs by placing a COPY SMPU
                                                              COPY SMPU
                                                              COPY SMPU
°                                                              COPY SMPU
°        × statement at the start of your program.

        × Note: Be careful when using conditions that modifiy registers
          Note:
          Note:
°          Note:
°        × storage  locations.   When these conditions are used as part
°        × compound conditional expression, they can effect the other co
°        × tions in the expression.  Be careful of your  register  usage
°        × these  cases and remember that although some conditions in an
°        × pression may be skipped because of the logic, conditions are
°        × ways evaluated in the order they are coded.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          10    Structured Macros Users's Guide
¯
¸
                                                          CHAPTER 3. BL
                                                          CHAPTER 3. BL
                                                          CHAPTER 3. BL
                                                          CHAPTER 3. BL
°                                                          _____________
¸
          There  are  4  types of blocks available with the Structured
°                                  ______
          gramming Macros. These are:  the program block, the inline bl
°                                           _______            ______
          the subroutine, block, and the errexit block.  Each type of b
°              ___________                _______
°          may be named, and this name may be used as a reference on the
°          sociated ENDBLK macro, and also on the LEAVE macro.
¸
          THE PROGRAM BLOCK
          THE PROGRAM BLOCK
          THE PROGRAM BLOCK
          THE PROGRAM BLOCK
°          _________________

          The program block encloses the main body of a program and  co
°              _____________
°          sponds  roughly  to  a  "mainline". Program blocks may not be
          closed by any other structure:  e.g. they must be used  at  b
°                                                                      _
          level  zero.    The program block should be the first block c
°          ____________
°          for a program.   Options and the ENVIRON  keyword  on  the  B
°          TYPE=PROGRAM  macro determine the type of linkage, initializa
°          and other program attributes to be  established.  The  associ
°          ENDBLK  macro  will  reverse  the linkage when it is executed
°          LEAVE macro which either names the program block or is  coded
°          "BLOCK=*"  at the program block's block level will cause a br
°          to the ENDBLK macro, thus terminating the program.

°          When writing a program that uses both 24-bit and 31-bit  addr
°          ing under MVS/XA, a Structured Macro Workarea (SMWA) must be
°          vided for the macros' use.  This is automatically provided by
°          SWA  and  PWA services, or can be specified with a keyword on
°          block macro.  The SMWA is a doubleword of storage which  is
°          to  save  work  registers  and addressing modes, thus allowin
°          AMODE change without disturbing the registers.
¸
          THE INLINE BLOCK
          THE INLINE BLOCK
          THE INLINE BLOCK
          THE INLINE BLOCK
°          ________________

°          Inline blocks are generally used to  set  off  a  procedure
°          neighboring code.  Inline blocks provide a structure which ma
°          exited  with  the  LEAVE BLOCK=* macro.  Inline blocks are pl
°          within the other types of blocks and may be nested  within  t
°          selves.  If desired, registers may be saved and restored when
°          tering  and leaving an inline block by use of the SAVE operan
°          the BLOCK macro.

°          When writing programs that will be  run  on  MVS/XA,  the  in
°          block  may  be  used to switch addressing modes "on the fly".
°          example, the program section in Figure 3 is running AMODE 31
°          RMODE  24,  but  needs  to  issue a PUT, which requires AMODE
°          These instructions will generate  the  correct  sequence  of
°          structions  to  save the current addressing mode, switch to A

°                                                    Chapter 3. Blocks
¯
¸
°          24, and then restore the saved addressing mode at the end of
°          block.

°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿

°            -- AMODE 31 code --
°               :
°            BLOCK  AMODE=24
°             PUT   SYSPRINT,RECORD
°            ENDBLK
°               :
°            -- AMODE 31 code --

°            Figure 3.  Switching AMODE
°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
¸
          THE SUBROUTINE BLOCK
          THE SUBROUTINE BLOCK
          THE SUBROUTINE BLOCK
          THE SUBROUTINE BLOCK
°          ____________________

°          Subroutine  blocks  contain  code that is reached via the CAL
°          macro.  Subroutines coded in this manner must be at  block  l
°          zero  (i.e. cannot be contained within any other block).  Sub
°          tine blocks should be coded after the program block to which
°          belong.  Subroutine blocks are meant for "internal"  subrouti
°          not  for  a  called program that follows standard OS linkage
°          ventions.

          A subroutine block is called by CALLSUB using "BAL   R14,rout
°                                                        _______________
°          or an equivalent sequence.  By using the SAVE operand,  the
°          routine may have some or all of its registers saved and resto
°          although  its  use is optional.   If Subroutine Work Areas (S
°          are used, registers R0-R14 are automatically saved in the SWA
°          restored when the subroutine is exited.  In this case,  the
°          operand is invalid.  The user can also specify that the USING
°          vironment  should  be  saved  and restored around the subrout
°          This prevents any USINGs within the subroutine from affecting
°          rest of the program.  Furthermore, a subroutine may request
°          its AMODE be switched and restored on entry and exit by using
°          AMODE operand.

°          The CALLSUB macro uses register 14 to link to the subroutine,
°          all other registers will have the same value on entry to the
°          routine  that  they  had in the calling program.  However, if
°          namic Storage Management or the  LONG  program  option  is  u
°          register  15  will also be destroyed by the CALLSUB linkage.
°          "Chapter 6. Large Program Management" on page 24 for more  in
°          mation on dynamic storage.
¸
¸

°          12    Structured Macros Users's Guide
¯
¸
          THE ERREXIT BLOCK
          THE ERREXIT BLOCK
          THE ERREXIT BLOCK
          THE ERREXIT BLOCK
°          _________________

°          The  errexit block is executed whenever an ERREXIT macro that
°          fers to it is executed. Like the subroutine  block,  the  err
°          block  must  be coded at block level zero.  Errexit blocks sh
°          be coded with the subroutine blocks after the  program  block
°          which  they belong.   The ENDBLK macro associated with an err
°          block generates a branch to the program block's ENDBLK expans
°          and also allows you to specify a return code with which the
°          gram  will terminate.  This return code overrides any return
°          that may appear on the program block's ENDBLK macro.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°                                                    Chapter 3. Blocks
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          14    Structured Macros Users's Guide
¯
¸
                                            CHAPTER 4. PROGRAM ENVIRONM
                                            CHAPTER 4. PROGRAM ENVIRONM
                                            CHAPTER 4. PROGRAM ENVIRONM
                                            CHAPTER 4. PROGRAM ENVIRONM
°                                            ___________________________
¸
°          There  are several types of environments for which the Struct
°          Macros contain explicit support.  These environments are sele
°          with the ENVIRON keyword of the program block macro.   The  e
°          ronments  are: the "OS" program environment which supports st
°          ard OS linkages; the  "DC"  program  environment  which  supp
°          Cullinet  IDMS/DC  linkage;  and the "PLI" environment which
°          ports the execution time environment of release 5 of the OS O
°          mizing Compiler.  Other types of environments can be accommod
°          by coding your own linkage.

°          The options and keywords on  the  program  and  subroutine  b
°          macros  allow  you to control virtually all phases of the pro
°          linkage as well as the Structured Macros options.  All of the
°          jor initialization and termination functions are  represented
°          their  individual  keywords.   However, there are certain pro
°          types that occur frequently.   To  cut  down  on  the  number
°          options  that  need to be coded to represent these program ty
°          the super options can be used.  They contain the correct comb
°          tion of options for the most common program  types.    The  s
°          options for each environment are discussed in their correspon
°          sections below.
¸
          DC ENVIRONMENT
          DC ENVIRONMENT
          DC ENVIRONMENT
          DC ENVIRONMENT
°          ______________

°          Specifying  ENVIRON=DC  generates support for programs to exe
°          in the IDMS/DC run-time environment.  This support is  relati
°          new and perhaps does not support all of the functions require
°          its  users:  however,  a  basic  set of options and super opt
°          should satisfy most IDMS/DC programmers' needs.
¸
          System Mode And User Mode
          System Mode And User Mode
          System Mode And User Mode
          System Mode And User Mode
°          _________________________

          IDMS/DC programs generally are called in either  system  mode
°                                                           ____________
          user mode. As a rule, user-mode programs are called by a #LIN
°          _________
°          #XCTL  and  use  #RETURN to return to their caller, while sys
°          mode programs are called by #CALL and return with #RTN, and
°          have  a  slightly  different  set  of  register  and linkage
°          ventions.  IDMS/DC applications whose program names  are  inv
°          by  a  task  code  or  called by #LINK or #XCTL are almost al
°          user-mode programs, while DC numbered exits and map edit rout
°          are usually system-mode programs.   Both types are  supported
°          ENVIRON=DC.
¸

°                                      Chapter 4. Program Environments
¯
¸
          Reentrancy Under IDMS/DC
          Reentrancy Under IDMS/DC
          Reentrancy Under IDMS/DC
          Reentrancy Under IDMS/DC
°          ________________________

°          Since  any  IDMS/DC program may be in use by several users at
°          given time, reentrancy in application programs and DC system
°          tines is much more valuable than under the standard MVS  envi
°          ment.  The  savings  in  execution  time  gained  by  avoidin
°          #GETSTG/#FREESTG  and  management of a reentrant program work
°          are usually far outweighed by the program pool savings and av
°          ance of program management overhead gained by  making  a  pro
°          truly reentrant. System-mode programs, where speed and effici
°          are prime considerations, can take advantage of IDMS/DC's #GE
°          service  for "fast storage" if their PWA storage requirements
°          small.
¸
          *NORENT
          *NORENT
          *NORENT
          *NORENT
°          _______

°          A non-reentrant user-mode program in  IDMS/DC  terms  means
°          ically  the same as a non-reentrant program under the OS envi
°          ment: IDMS/DC does not  allow  users  to  share  a  copy  of
°          program,  but loads a new copy each time a new user requests
°          As a result, the program can contain  its  variables  within
°          CSECT without having to acquire storage from IDMS/DC for them
¸
          *NORENTSYS
          *NORENTSYS
          *NORENTSYS
          *NORENTSYS
°          __________

°          This super option defines a non-reentrant system mode program
°          IDMS/DC.  This option is provided for consistency: however, i
°          recommended that any system mode program be  assembled  as  r
°          trant, using either the *RENTSYS or *PWASYS super option.
¸
          *RENT
          *RENT
          *RENT
          *RENT
°          _____

°          Reentrancy  in  an  IDMS/DC  user  mode program allows IDMS/D
°          share a single copy of the program among multiple users, and
°          allows the program to be loaded into the IDMS/DC  reentrant
°          gram  pool.    The *RENT super option causes reentrant linkag
°          occur, but does not acquire any variable storage for the prog
¸
¸
¸
°          16    Structured Macros Users's Guide
¯
¸
          *RENTSYS
          *RENTSYS
          *RENTSYS
          *RENTSYS
°          ________

°          The *RENTSYS super option causes reentrant linkage to  occur
°          an IDMS/DC system mode routine. Like *RENT, *RENTSYS does not
°          quire  any variable storage for the program: thus, if local v
°          able storage is not needed, the overhead of #GETSTG/#FREESTG
°          be avoided.
¸
          *PWA
          *PWA
          *PWA
          *PWA
°          ____

°          The  *PWA  super  option  causes a #GETSTG and #FREESTG to be
°          cluded in the linkage and delinkage for the program, thus  al
°          ing  reentrancy and providing storage for variables. This pro
°          (except for actually acquiring the storage) is basically the
°          as described in the *PWA section under "*PWA" on page 16.
¸
          *PWASYS
          *PWASYS
          *PWASYS
          *PWASYS
°          _______

°          This is generally the option that system-mode programs would
°          if  they  have  any need for variable storage. If a small PWA
°          fullwords or less) is all that's needed, the option GETSTK ca
°          coded among the program block's OPTIONS: this causes  #GETSTK
°          be  used  to  acquire variable storage from the task's TCE st
°          which is much faster than calling #GETSTG and #FREESTG.
¸
          OS ENVIRONMENT
          OS ENVIRONMENT
          OS ENVIRONMENT
          OS ENVIRONMENT
°          ______________

°          The OS environment is the default environment and supports st
°          ard OS linkage.  By specifying different options,  you  can
°          the  Structured  Macros do as little or as much of the linkag
°          desired.  For most situations, there are super options that
°          pick the correct set of options for you.
¸
          *NORENT
          *NORENT
          *NORENT
          *NORENT
°          _______

°          If  a program is non-reentrant, the system will load a fresh
°          of it every time the program is invoked.   Because of  this,
°          program  is allowed to modify itself.  Data and work areas ca
°          stored in the load module itself.  Most user programs can be
°          reentrant.  The *NORENT super option will automatically defin
¸
°                                      Chapter 4. Program Environments
¯
¸
°          save  area  in  the  program ID section and perform non-reent
°          linkage.
¸
          *RENT
          *RENT
          *RENT
          *RENT
°          _____

°          Since reentrant programs are not reloaded every time they are
°          voked,  they  are  not  allowed to modify any fields within t
°          selves.  Any data that might be  modified  must  be  copied
°          working  storage  that  has  been  GETMAINed, and modified th
°          This preserves the integrity of the load module for other  us
°          The  *RENT  super  option provides the reentrant linkage and
°          automatically GETMAIN storage for a save area.   No provision
°          made  for a Program Work Area (PWA).  Any storage (other than
°          save area) needed by the program must be acquired  by  the  u
°          Because  of  this,  the *RENT super option is not very useful
°          new programs.  *PWA provides much better  support  for  reent
°          programs.  (see below)  *RENT was included to provide support
°          those programs that already acquire their own storage or that
°          some reason could not use the storage provided by *PWA.
¸
          *PWA
          *PWA
          *PWA
          *PWA
°          ____

°          *PWA provides all the functions of *RENT, plus it  will  auto
°          ically  GETMAIN  and FREE a Program Work Area (PWA) for the u
°          The best way to illustrate this is with an example:

°             BLOCK NAME=MAINPROG,TYPE=PROGRAM,OPTIONS=(*PWA)
°                    :
°                    :
°             ENDBLK BLOCK=MAINPROG
°             PSD
°                    :
°               Static Data
°                    :
°             ENDPSD
°             PWA
°                    :
°               Work Area
°                    :
°             ENDPWA

°          In the example above, the static data (constants and  other
°          that are not modified by the program) is placed at the end of
°        × program  in  an  area called the PSD (Program Static Data) an
°          included in the load module.  The PWA and ENDPWA macros defin
°          DSECT  for  a block of storage that will be acquired for the
°          by the BLOCK macro and freed at the end of the  program.    S
°          for  the  save  area is automatically reserved in the PWA, so

°          18    Structured Macros Users's Guide
¯
¸
°          user does not need to worry about this.  The user simply need
°          define any work area fields that the program  needs  between
°          PWA  and  ENDPWA  macros.   After this storage is acquired by
°          BLOCK macro, it is cleared for the user and addressability is
°          up  using register 13.  This super option makes writing reent
°          programs almost as easy  as  writing  non-reentrant  ones.
°          bothersome  details of computing storage requirements, GETMAI
°          storage, keeping up with addresses, and FREEMAINing the  acqu
°          storage are handled by the Structured Programming Macros.

°          The *PWA option and the PWA macro also provide a variety of o
°          features that are described in more detail in "Chapter 5. Pro
°          and Subroutine Work Areas" on page 20.
¸
          *MAIN
          *MAIN
          *MAIN
          *MAIN
°          _____

°          The  *MAIN  super option provides all of the features of *PWA
°          adds the options DYN and MAIN.  This allows SWAs to be  alloc
°          from  dynamic  storage instead of being statically defined in
°          PWA.  See "Chapter 6. Large Program Management" on  page  24
°          more  information  on  dynamic  storage.   The *MAIN super op
°          should be used on the program block for  any  main  program
°          uses dynamic storage.
¸
          *NOMAIN
          *NOMAIN
          *NOMAIN
          *NOMAIN
°          _______

°          The  *NOMAIN  super  option provides all of the features of *
°          except that it specifies option NOMAIN instead of MAIN.  This
°          per option should be used on a program block that  represents
°          external subroutine that will be called from another program
°          uses dynamic storage.
¸
          *SRVPRC
          *SRVPRC
          *SRVPRC
          *SRVPRC
°          _______

°          The *SRVPRC super option is used by service processors.  Refe
          Clemson University Computer Center Service Processor User's G
°          _____________________________________________________________
          and Reference for more information on this super option.
°          _____________
¸
          PL/I ENVIRONMENT
          PL/I ENVIRONMENT
          PL/I ENVIRONMENT
          PL/I ENVIRONMENT
°          ________________

°          ENVIRON=PLI  supports the execution time environment of relea
°          of the OS PL/I Optimizing Compiler.   At the  current  time

°                                      Chapter 4. Program Environments
¯
¸
°          support  is  minimal, but it should satisfy the needs of most
°          sembler programs that run as subroutines to PL/I programs and
°          the PL/I environment.
¸
          *STDPLI
          *STDPLI
          *STDPLI
          *STDPLI
°          _______

°          This  is the only PL/I environment super option and should al
°          be specified.  The Structured Macros' support of PL/I is  not
°          fully  developed as it is for the OS and DC environments.  Sp
°          fying this option will help insure future compatibility.

°          This super option will provide the proper reentrant linkage f
°          majority of assembler programs that run in an OS PL/I  Optimi
°          Compiler  execution  time environment.  Storage is obtained f
°          PWA in the same manner as a PL/I program obtains storage for
°          DSA.  A DSA in PL/I contains an OS save area, control informa
°          and program variables.
¸
          OTHER ENVIRONMENTS
          OTHER ENVIRONMENTS
          OTHER ENVIRONMENTS
          OTHER ENVIRONMENTS
°          __________________

°          If you want to use the Structured Macros in other than one of
°          explicitly  supported environments, you can code your own lin
°          or add support for the environment with prolog and epilog mac

°          If you want to code your own linkage, let the environment def
°          to OS and do not code any linkage-related options.  Put your
°          linkage before or after the program block macro and after the
°          block macro for the program.  If you do your own linkage you
°          not be able to use PWAs, SWAs, PSDs, SSDs or anything related

°          If  the  Structured Macros will be used often in this environ
°          or if you need to use PWAs, etc., it may be worth the time to
°          support for the environment.  Refer to the internals  manual
°          the  Structured  Macros  for  information  on  writing prolog
°          epilog macros if you would like to take this approach.

°          To add support for an environment requires a thorough underst
°          ing of the internals of the Structured Macros and the support
°          have to be updated each time the Structured Macros themselves
°          updated.  If the environment needed is of general  interest,
°          may  want  to  request that it be added as a standard part of
°          Structured Macros and supported as such.
¸
¸

°          20    Structured Macros Users's Guide
¯
¸
          SUBROUTINE BLOCK SUPER OPTIONS
          SUBROUTINE BLOCK SUPER OPTIONS
          SUBROUTINE BLOCK SUPER OPTIONS
          SUBROUTINE BLOCK SUPER OPTIONS
°          ______________________________

°          Currently, all environments use the same subroutine block opt
°          and super options.
¸
          *SWA
          *SWA
          *SWA
          *SWA
°          ____

°          In any program that uses the PWA option, the internal subrout
°          for that program can each have an individual Subroutine Work
°          (SWA).    The  *SWA  super  option is specified on the subrou
°          block (or the SUBOPTS= on the program block) to  provide  an
°          for a subroutine.  There are SWA and ENDSWA macros to delimit
°          SWA  just  as the PWA was delimited.  The details about the f
°          tions of an SWA and its relation to a PWA are described in "C
°          ter 5. Program and Subroutine Work Areas" on page 20.
¸
          *NOSUBOPTS
          *NOSUBOPTS
          *NOSUBOPTS
          *NOSUBOPTS
°          __________

°          This super option clears all the subroutine options to their
°          state.  If the program block has specified a default set of
°          routine  options with the SUBOPTS= keyword, this super option
°          be used on a subroutine block  to  create  a  subroutine  wit
°          those default options.  For example, a *NOSUBOPTS,CUSTOM migh
°          coded to create a subroutine with just the CUSTOM option.
¸
          CONCLUSION
          CONCLUSION
          CONCLUSION
          CONCLUSION
°          __________

°          The  environment  support and super options make programming
°          easier, since all of the tedious initialization  and  termina
°          details  are taken care of with a minimum of effort.  This al
°          you to worry about program logic, and not the linkage.  They
°          do not lock you into only these combinations of options.  If
°          wish  to  override  any  of the options in a super option, si
°          code them after the super option on the OPTIONS=  keyword.
°          example:

°             BLOCK  TYPE=PROGRAM,NAME=PROG,OPTIONS=(*PWA,XA,NOREGEQU),E
¸
¸
¸
°                                      Chapter 4. Program Environments
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          22    Structured Macros Users's Guide
¯
¸
                               CHAPTER 5. PROGRAM AND SUBROUTINE WORK A
                               CHAPTER 5. PROGRAM AND SUBROUTINE WORK A
                               CHAPTER 5. PROGRAM AND SUBROUTINE WORK A
                               CHAPTER 5. PROGRAM AND SUBROUTINE WORK A
°                               ________________________________________
¸
°          The  Program and Subroutine Work Area (PWA and SWA) support b
°          into the Structured Programming Macros is a  powerful  tool
°          can  be invaluable to someone writing a complex program, and
°          provides services that can be useful in even a  relatively  s
°          program.    Although PWAs and SWAs are normally used in reent
°          programs, even non-reentrant programs can take advantage  of
°          services  they provide.  If option NORENT is in effect, the s
°          age for the work areas will be defined in the load module ins
°          of being dynamically obtained at execution time.
¸
          PROGRAM WORK AREAS
          PROGRAM WORK AREAS
          PROGRAM WORK AREAS
          PROGRAM WORK AREAS
°          __________________

°          The PWA option and PWA macro provide many services  besides
°          defining  a  block  of  storage  to be obtained for the user.
°          specifying that the program will  have  a  PWA,  you  allows
°          Structured  Macros  to automatically perform many functions.
°          example, space for a SMWA for the main program and one  for
°          of  the  subroutines  will  be reserved in the PWA preventing
°          from having to code the SMWA= keyword on the program block.
°          you  wish  to  override this and force the SMWA to a specific
°          cation, the SMWA= keyword can still be used.

°          Also, you can have parameter lists placed in the PWA without
°          ing to explicitly define storage for them.  The Structured Ma
°          can compute the largest parameter list in the program and res
°          enough space in the PWA.  A separate parameter list area  is
°          served for the program and each subroutine.  This is required
°          cause  the  program  parameter  storage  may  be  in  use  wh
°          subroutine is called.  For more information on  parameter  li
°          see  "Chapter  10.  Parameter Lists and Standard Linkage" on
°          34.

°          Option PWA allows you to define a Subroutine Work Area (SWA)
°          each  subroutine  that  contains  any  work  area fields that
°          needed only while the subroutine is executing.  This SWA is a
°          ogous to the PWA for the program.
¸
        × REUSABLE PROGRAM WORK AREAS
          REUSABLE PROGRAM WORK AREAS
          REUSABLE PROGRAM WORK AREAS
          REUSABLE PROGRAM WORK AREAS
°          ___________________________

°        × Under normal circumstances, the PWA for a program will  be  a
°        × cated  whenever  the program is called, and freed before the
°        × gram terminates.   However, there are cases  when  a  program
°        × loaded  into memory once, and called repeatedly to perform a
°        × ticular function.  Not only would it be inefficient to repeat

°                         Chapter 5. Program and Subroutine Work Areas
¯
¸
°        × acquire and free storage for this program, it may cause  prob
°        × if the program is required to retain information between call

        × This  problem  is  solved  by a mechanism known as Reusable P
°                                                             __________
°        × Using this capabilility, the Structured Macros will only allo
°        × a new PWA when given a start-up call and will not free the  s
°        × age  when  the program terminates.  When the program detects
°        × it is being called for the final time, it can issue  a  macro
°        × instruct  the  Structured  Macros  to free the PWA storage at
°        × termination of the current invocation.

°        × When reusable PWAs are being used, the caller of the program
°        × keep track of the PWA address and pass it in the  parameter
°        × on  every call.  The position of the PWA address in the param
°        × list is customizable.   If this  address  is  binary  zeros,
°        × Structured  Macros  will allocate storage for a new PWA and s
°        × its address back into the parameter list.   Otherwise, they
°        × use the passed value.

°        × Alternatively,  you  can specify a parameter position for a f
°        × tion code that will be provided on every call and  a  value
°        × means  "Start".  With this form, the Structured Macros will a
°        × cate a new PWA on the Start call, and use the passed PWA valu
°        × other cases.

°        × When the program is in its final invocation (either because o
°        × error or when called to terminate), the SMCTRL macro is  used
°        × force  the  Structured  Macros  to free the PWA at program te
°        × nation.

        × This concept is used heavily at Clemson by what we  call  Ser
°                                                                    ___
        × Processors.    These  are programs that are started once and
°          __________
°        × called repeatedly to perform a particular  type  of  service
°        × their  invoker.    File handling, string manipulation, and sy
°        × management are all examples of functions that may be  handled
°        × service  processors.   For more information about the working
        × Service Processors, see Clemson University Computer  Center
°                                  _____________________________________
        × vice Processor User's Guide and Reference.
°          _________________________________________
¸
          SUBROUTINE WORK AREAS
          SUBROUTINE WORK AREAS
          SUBROUTINE WORK AREAS
          SUBROUTINE WORK AREAS
°          _____________________

°          Any  subroutine  that will be using an SWA should use the SWA
°          ENDSWA macros to define its  boundaries,  just  as  the  PWA
°          ENDPWA  macros are used for the program's PWA.  There are opt
°          on the subroutine block to control SWA usage, and a super  op
°          (*SWA)  that  provides the correct combination of options for
°          usage.

°          SWAs provide useful functions for subroutines just as PWAs do
°          programs.  SMWAs and parameter lists for the subroutines are
°          ated as part of the SWA instead of as PWA fields.  R0-R14 are

°          24    Structured Macros Users's Guide
¯
¸
°          tomatically saved and restored for any  subroutine  that  has
°          SWA.   Space for this is reserved by the SWA macro, so you do
°          have to code the SAVE keyword, or explicitly reserve  the  sp
°          The  registers  are  saved  as R0-R14 so that R15 will not be
°          stored and the subroutine can pass a return  code  back  in
°          register.

°          You  should  be aware of the implications of saving and resto
°          registers.  Because of this, a subroutine can not pass  back
°          values  to  its caller by way of the registers.  It would hav
°          use the PWA to pass back any information.   To  get  around
°          problem, the STRSA macro was created.  This macro stores the
°          rent  value  of  a  register in the SWA save area for the cur
°          subroutine.  Then when the subroutine ends, the register will
°          restored to the value it had when the STRSA macro was issued,
°          stead  of  the  value it had when the subroutine was called.
°          can use the STRSA macro to pass back any registers that the c
°          ing routine needs, while allowing the other registers to  be
°          stored to their original values.

°          There  is  a CLEARPWA option on program blocks that instructs
°          macros to clear the PWA after it has been obtained.  This  op
°          is included in all of the super options that use PWAs so that
°          can count on the PWA being all zeros on entry.  However, ther
°          not  a  similar  option on the subroutine block to clear the
°          You should never count on the SWA contents anytime  a  subrou
°          is  entered.    If  the fields within the SWA need to be set
°          specific value, the subroutine must include  code  to  initia
°          these fields.

°          These  functions of SWA usage can be a great help to the prog
°          mer, even the subroutine does not need to have  any  of  its
°          fields  defined  in  the SWA.   If you select the SWA option,
°          Structured Macros will generate an SWA for internal use in sa
°          registers, etc. even if you do not code the SWA and ENDSWA ma
°          at the end of your subroutine.
¸
          SWA PLACEMENT
          SWA PLACEMENT
          SWA PLACEMENT
          SWA PLACEMENT
°          _____________

°          With the *PWA option, these SWAs will be included as part of
°          PWA for the program to which they belong.  They will be place
°          the  PWA's partial area and addressability will be off of the
°        × register (R13).  This configuration of PWAs and SWAs  is  cha
°        × in  programs that use the Structured Macros' dynamic storage
°        × agement support.  For more information on  this,  see  "PWAs
°        × SWAs with Dynamic Storage Management" on page 24.
¸
¸

°                         Chapter 5. Program and Subroutine Work Areas
¯
¸
          PSDS AND SSDS
          PSDS AND SSDS
          PSDS AND SSDS
          PSDS AND SSDS
°          _____________

°          The PSD and SSD macros (and their respective end macros) are
°          to  define  the Program and Subroutine Static Data areas, jus
°          PWA and SWA are used to define the work areas.  These macros
°          used in conjunction with the LOCTR option on the program bloc
°          insure  proper  placement  of  the  program code and static d
°          They also allow fields to be defined from within the program
°          that will be placed with the static data when the program is
°          sembled.    This  facility  is used by the EXI macro.  These
°        × areas are addressed off of the same base registers as the pro
°        × and subroutine code.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          26    Structured Macros Users's Guide
¯
¸
                                        CHAPTER 6. LARGE PROGRAM MANAGE
                                        CHAPTER 6. LARGE PROGRAM MANAGE
                                        CHAPTER 6. LARGE PROGRAM MANAGE
                                        CHAPTER 6. LARGE PROGRAM MANAGE
°                                        _______________________________
¸
°          As  a  program becomes larger and contains more subroutines,
°          tain problems arise.  The PWA (which contains  an  SWA  for
°          subroutine)  can grow to an unmanageable size.  Also, the pro
°          code along with the subroutine code can become so  long  that
°          would  take  several  base  registers to maintain addressabil
°          The Structured Macros provide two tools to help manage such l
°          programs.  They are Dynamic Storage Management and the  LONG
°          LOADBASE  options.   Dynamic Storage Management is only avail
°          for program blocks which are using ENVIRON=OS.
¸
          PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
          PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
          PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
          PWAS AND SWAS WITH DYNAMIC STORAGE MANAGEMENT
°          _____________________________________________

°          If your program has a large number of internal  subroutines
°          heavily  use  SWA storage, the size of the PWA can easily gro
°          an unmanageable size.  If the fields defined in the SWA  are
°          ally only necessary when the subroutine is active, it is not
°          essary to allocate enough space for all of the SWAs.  Only en
°          storage to contain the PWA itself, and the largest combinatio
°          active  SWAs  is required.  If there were some way to dynamic
°          allocate and free SWA storage as subroutines were entered and
°          ited, a great savings in storage could be realized.

°          To solve this problem, the storage for an SWA could be  GETMA
°          as the subroutine is entered and FREEd at the end, but this w
°          slow down the operation of the program greatly.

°          A  much more efficient system is to obtain a large block of s
°          age at the beginning of the program, allocate the first  part
°          the  PWA,  and  allocate  the rest to SWAs as it is needed.
°          block of storage can be much smaller than the  size  of  the
°          plus  all  of  the SWAs, since not all of the subroutines wil
°          active at once.  Also, since new SWA storage is allocated  fo
°          subroutine  each  time  it  is entered, subroutines can be ca
°          recursively.  With this system, a GETMAIN is never done more
°          once for a single program.  Enough storage is allocated  for
°          the  program and subroutines' needs at the beginning, and sto
°          is assigned and taken back as subroutines are entered and exi

°          This is just what the Structured Macros' Dynamic Storage  Man
°          ment does. The DYN option on the program block is used to tur
°          Dynamic  Storage Management.  Dynamic Storage also allows sub
°          tines to call themselves, which  adds  more  complexity.    A
°          there  is  hidden recursion, such as when subroutine A calls
°          routine B, and subroutine B in turn calls subroutine A.
¸

°                                  Chapter 6. Large Program Management
¯
¸
          Recursive Subroutines with the DYN Option
          Recursive Subroutines with the DYN Option
          Recursive Subroutines with the DYN Option
          Recursive Subroutines with the DYN Option
°          _________________________________________

°          Recursive subroutines cause another  problem.    Since  they
°          called  again without the previous invocation being ended, mu
°          ple copies of the subroutine's SWA need to be allocated from
°          namic  storage.    Since  the  Structured  Macros  have no wa
°          knowing  how deep the recursion might go, you need to supply
°          information.  On any subroutine that will be  called  recursi
°          (this  includes  all the programs in a recursive loop such as
°          one described above), you need to use the RECUR keyword  to
°          the  macros  the  maximum  number of times the subroutine wil
°          called recursively.   This keyword  tells  the  macros  how
°          copies  of  that  subroutines  SWA  could  be active at once,
°          therefore how much room to allocate.  If you miscalculate on
°          RECUR  keyword,  the  Structured  Macros will miscalculate on
°          space required.  If you use too big a number, the macros will
°          locate more space than is needed.  If you use too small a num
°          the macros will allocate too little space, and a dynamic  sto
°          error  will  result.   By default, the macros will force an A
°          0C1 when your program runs out of dynamic storage.  However,
°          can specify an error exit that will get control when this hap
°          with the DYNERR keyword on the program block.
¸
          Storage Calculations with the DYN Option
          Storage Calculations with the DYN Option
          Storage Calculations with the DYN Option
          Storage Calculations with the DYN Option
°          ________________________________________

°          The  Structured  Macros' algorithm is very comprehensive and
°          allocate enough space for all known cases.  It uses  an  inte
          macro called ##ORGS to trace the subroutine call structure of
°                       ______
°          program.    From this, it determines the subroutines that wil
°          active together, and how big their SWAs are.  Using this info
°          tion and the size of the PWA, the macros determine how much s
°          they will need to GETMAIN to  accommodate  your  program.
°          tracing of the subroutine structure is more difficult than it
°          seem,  since  the  main program and each subroutine may call
°          other subroutines forming a very complex tree.    However,  t
°          are certain very complicated and unlikely combinations of sub
°          tines  that  will trick them into allocating more space than
°          need.  If this ever becomes a problem, it can  be  adjusted
°          the DYNSIZE keyword on the program block.  The DYNSIZE keywor
°          used  to  replace  or  adjust the value for the amount of dyn
°          storage calculated by the macros.   It can  be  used  in  cer
°          cases to fine-tune the dynamic storage requirements.  However
°          most  cases  the  macros  themselves should calculate the cor
°          amount, and the DYNSIZE keyword should not be needed.
¸
¸

°          28    Structured Macros Users's Guide
¯
¸
          SWA Addressability with the DYN Option
          SWA Addressability with the DYN Option
          SWA Addressability with the DYN Option
          SWA Addressability with the DYN Option
°          ______________________________________

°          These SWAs will be based off of register 11, while the subrou
°          itself will be addressed off of the program  base,  and  the
°          base  will remain with register 13.  It should be noted that
°          ister 11 will be in use in DYN programs even  when  a  subrou
°          has not been invoked.
¸
          Super Options Used with the DYN Option
          Super Options Used with the DYN Option
          Super Options Used with the DYN Option
          Super Options Used with the DYN Option
°          ______________________________________

°          There  are  two  program block super options for use with Dyn
°          Storage Management.  They are *MAIN and *NOMAIN.  *MAIN  cont
°          all  of  the  options in *PWA plus the options DYN and MAIN.
°          MAIN option tells DYN that this is a main program  and  that
°          namic  storage should always be obtained when this program is
°          tered.   By contrast,  *NOMAIN  says  that  this  program  is
°          external  subroutine that will be called from a main program
°          uses DYN.   In a *NOMAIN program,  the  dynamic  storage  of
°          caller  will  be  used if there is enough of it.  Otherwise,
°          storage will be GETMAINed to accommodate the program and its
°          routines.  It should be emphasized that a program  compiled
          option *NOMAIN should only be called from a program that uses
                                only
                                only
°                                only
°          namic  Storage Management.   Even if the *NOMAIN program GETM
°          its own storage, it requires that registers and storage areas
°          set up by the calling program.

°          Any  *MAIN program that will be calling external subroutines
°          *NOMAIN might need to use the DYNSIZE keyword to adjust  its
°          namic  storage  to  allow  for what the *NOMAIN program will
°          Since the *NOMAIN program will  most  likely  be  compiled  s
°          rately,  there  is  no way for the Structured Macros to calcu
°          its requirements.  However, since the *NOMAIN will get more s
°          age if it needs it, adjusting the storage on  the  *MAIN  pro
°          will only affect performance by preventing an extra GETMAIN.
¸
          Storage Optimization with the DYN Option
          Storage Optimization with the DYN Option
          Storage Optimization with the DYN Option
          Storage Optimization with the DYN Option
°          ________________________________________

°          When  using the DYN option, there is a short routine added to
°          beginning of each internal subroutine  to  obtain  the  new
°          This is not a real problem, but if the program has a large nu
°          of  small  subroutines,  this can significantly lengthen the
°          module.  If the size of the load module is critical, the  OPT
°          option can be used on the program block to help remedy this.
°          OPTSTOR  option will create a single copy of the subroutine l
°          age code and have each subroutine branch to it.  This makes
°          routine  calls  slower,  but  will  reduce  the  size of the
¸
°                                  Chapter 6. Large Program Management
¯
¸
°          module.  However, space is rarely this critical, so  the  OPT
°          option should not be needed in most cases.
¸
          LONG AND LOADBASE
          LONG AND LOADBASE
          LONG AND LOADBASE
          LONG AND LOADBASE
°          _________________

°          When  a  program  gets  to be very long with a lot of subrout
°          (such as a server routine or a command processor), the CSECT
°          become  so large that it takes two, three, or even more base
°          isters to maintain addressability.  It would be nice if there
°          some way to allow a subroutine to have its own base register
°          arate from the program's base register.  The LOADBASE  option
°          subroutine  blocks  and the LONG option on the program block
°          vide this support.

°          The LOADBASE option on the subroutine block instructs the sub
°          tine linkage routines to establish a separate  addressability
°          that  subroutine using the subroutine base register.  This re
°          ter defaults to R10, but another register can  be  selected
°          the  BASEREG= keyword.  Any subroutines coded in this manner
°          be located at the end of the CSECT, so that they will not  in
°          fere with the program's addressability.

°          If  a  program  has any subroutines that use the LOADBASE opt
°          the program block must have the LONG option coded.   This  op
°          causes  CALLSUB to generate the correct linkage for LOADBASE
°          routines.  Since both of these options make use of partial  P
°          the  LOCTR  option  is  also required when using these.  Howe
°          LOCTR is included in all of the super  options,  so  usually
°          will not have to code it.

°          With  this  scheme,  the macros always keep a base to the pro
°          and to the current subroutine.   Therefore, the program  will
°          able  to  address  anything in the program and its PSD as wel
°          the current subroutine and its SSD.  However, one subroutine
°          not address anything in another subroutine's SSD.   If  you
°          any  static data that will be shared among subroutines, it sh
°          be placed in the PSD.

°          Since a separate base register is kept for the  program  and
°          current subroutine, this facility is only useful in programs
°          already  need  two  or more base registers.   However, with t
°          options the program base register only needs to address the
°          program  code  and its static data.  If even this can not be
°          with a single base register, the main program code can  be  m
°          to  an internal subroutine with only a single CALLSUB in the
°          gram block.
¸
¸

°          30    Structured Macros Users's Guide
¯
¸
          SIZE LIMITATIONS
          SIZE LIMITATIONS
          SIZE LIMITATIONS
          SIZE LIMITATIONS
°          ________________

°          With the techniques described here, a very large program  can
°          created  quite easily.   Although most programmers will never
°          ceed the Structured Macros' limits, it may be useful to know
°          how large a program can become.  The only limitation  on  pro
°          length (and it's static data) is the number of base registers
°          are willing to use to address it.  But with the LONG and LOAD
°          options,  this  is  not necessarily a problem.  PWAs can be u
°          16M in size, but again you must maintain  addressibility  on
°          SWAs  can  be up to a maximum of 32K in size if DYN is in eff
°          If the majority of one of your data or work  areas  is  a  si
°          very  large data area that you only need to address the start
°          you can place it at the end of the data area.   The  user  fi
°          always go after the fields generated by the Structured Macros
¸
          CONCLUSION
          CONCLUSION
          CONCLUSION
          CONCLUSION
°          __________

°          The  long program management routines provide very useful sup
°          for large or memory intensive  programs.    A  great  savings
°          GETMAINed  storage can be achieved in programs with large num
°          of subroutines, and many of the  tedious  details  of  subrou
°          linkage  and program storage can be automated.  A savings in
°          registers can also be achieved in extremely long programs.
°          more  information  on  the  actual layout of dynamic storage,
°          "Appendix C. Work Area Storage Layout" on page 129, while  a
°          scription  of program code and static data layout can be foun
°          "Appendix D. Program Code and Static Data  Layout"  on  page
°          along with an example of how these options should be coded.
¸
¸
¸
¸
¸
¸
¸

°                                  Chapter 6. Large Program Management
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          32    Structured Macros Users's Guide
¯
¸
                                                CHAPTER 7. THE IF STRUC
                                                CHAPTER 7. THE IF STRUC
                                                CHAPTER 7. THE IF STRUC
                                                CHAPTER 7. THE IF STRUC
°                                                _______________________
¸
°          There are four macros that are used to build IF structures: t
          are  IF,  ELSEIF, ELSE and ENDIF.  Of these, conditions to go
               IF,  ELSEIF, ELSE     ENDIF.
               IF,  ELSEIF, ELSE     ENDIF.
°               IF,  ELSEIF, ELSE     ENDIF.
°          statements are coded on the IF and ELSEIF  macros.  Like  the
°          services in many higher-level languages, there are Boolean op
°          tors  available  (AND, OR, NOT) for building complex expressi
°          however, the conditional statements themselves  are  coded  u
°          the actual assembler compare instructions. For example,

°             IF    (CLC,TAG1(8),NE,6(R2)),THEN
°                     :
°               -- success code --
°                     :
°             ELSE
°                     :
°               -- fail code --
°                     :
°             ENDIF

°          will generate:

°            +            CLC  TAG1(8),6(R2)       generated by IF
°            +            BE   failtag             generated by IF
°                                  :
°                         -- success code --
°                                  :
°            +            B    endiftag            generated by ELSE
°            +failtag     DS   0H                  generated by ELSE
°                                  :
°                         -- fail code --
°                                  :
°            +endiftag    DS   0H                  generated by ENDIF

°          Similarly,

°             IF    ((CH,R1,EQ,A),OR,(CH,R1,EQ,B)),THEN
°                   :
°               -- success code --
°                   :
°             ENDIF

°          will generate:
¸
¸
¸

°                                          Chapter 7. The IF Structure
¯
¸
°            +              CH   R1,A              first comparison
°            +              BE   successtag        branch if test succee
°            +              CH   R1,B              second comparison
°            +              BNE  failtag           branch if test fails
°            +successtag    DS   0H                generated by IF
°                                    :
°                           -- success code --
°                                    :
°            +failtag       DS   0H                generated by ENDIF
°            +endiftag      DS   0H                generated by ENDIF

°          In  these  examples,  one thing that you may have noticed is
°          the macro expansions will generate tags and branches to  them
°          may  be  appropriate.  Although  these  tags are used only by
°          macros at assembly time, it is very handy to have them  avail
°          under TSO TEST.

°          The  IF  and ELSEIF macros allow you to specify "conditions"
°          number of ways, which are fully described in "Chapter  2.  Co
°          tional  Statements" on page 4.  Simply stated, the "condition
°          the IF statement provides the instruction that will be  used
°          the  actual comparison and the appropriate condition for the
°          sequent branch.  For example, the statement

°             IF   (CLC,A(6),NE,3(R1)),THEN

°          will generate the instructions

°            +            CLC  A(6),3(R1)
°            +            BE   failtag

°          Conditions may be combined on the IF statement using Boolean
°          pressions NOT, AND and OR.  Also, if a condition code is know
°          exist when an IF is executed, only the desired conditional op
°          tor needs to be coded. For example,

°             TRT   TEXT,TABLE
°             IF    Z,THEN
°              MVC   MESSAGE(15),=CL15'TEXT NOT FOUND'
°              PUT   SYSPRINT,MESSAGE
°             ELSE
°                :
°                :
°             ENDIF

°          In  this example, the TRT instruction will set a "zero" condi
°          code if the translate-and-test operation fails.   The  subseq
°          IF  statement  is used to generate a conditional branch witho
°          compare instruction.  This form of the IF statement is useful
°          non-comparison instructions that set a condition  code,  such
°          arithmetic and logical instructions. The user should avoid mi
°          this  form of condition with conditions that generate compare
°          structions, though, because the order in which  the  instruct
¸
°          34    Structured Macros Users's Guide
¯
¸
°          are  generated  may cause the condition code to be changed pr
°          turely.

°          The  ELSEIF  macro  is similar to an ELSE macro followed by a
°          macro, except the IF nesting level is not changed.   This  al
°          the  user  to test for one condition out of a list of conditi
°          For example:

°             IF      (CLC,FUNC,EQ,=C'READ'),THEN
°                :
°                :
°             ELSEIF  (CLC,FUNC,EQ,=C'WRITE'),THEN
°                :
°                :
°             ELSEIF  (CLC,FUNC,EQ,=C'CLOSE'),THEN
°                :
°                :
°             ENDIF

°          This is similar to the CASE structure, except that the CASE m
°          is mainly used to select one out of a sequence of numerically
°          dered items.  For more information on the CASE macro, See  "C
°          ter 9. CASEs and CASE Blocks" on page 33.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°                                          Chapter 7. The IF Structure
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          36    Structured Macros Users's Guide
¯
¸
                                                           CHAPTER 8. L
                                                           CHAPTER 8. L
                                                           CHAPTER 8. L
                                                           CHAPTER 8. L
°                                                           ____________
¸
          Variations  of  the LOOP and ENDLOOP macros may be used to cr
°                              ____     _______
°          the most commonly used loop structures. The types of loop  av
          able  are:   WHILE loops, where completion tests are performe
°                       _____
          the top of the loop; UNTIL loops, where  completion  checking
°                               _____
          done  at  the  bottom of the loop; BCT and BXLE loops, where
°                                             ___     ____
          pletion tests are performed at the end of the  loop;  BXH  lo
°                                                                ___
          where completion checks are made at the top of the loop; and
°
          less  loops,  where completion checks are made within the loo
°          ____
°          the programmer's code.

°          The WHILE and UNTIL loops provide the Assembly language  prog
°          mer with the standard loop structures available in any high-l
°          language  and the ability to control the loops with any condi
°          that is legal in an IF statement.   See "Chapter  2.  Conditi
°          Statements"  on  page  4 for a complete description of the co
°          tions that can be specified with the Structured Macros.  The
°          BXH, and BXLE loop provide support for  the  standard  System
°          looping statements, while preserving the structured nature of
°          code.

°          As in the other structures, the LEAVE macro may be used to ex
°          loop if desired. In the case of an endless loop, a LEAVE macr
°          usually the only way to exit the loop.

°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°                    LOOP      WHILE,condition     ×   LOOP      BXH,r1,
°                         :                        ×            :
°                    ENDLOOP   WHILE               ×   ENDLOOP   BXH

°                    LOOP      UNTIL               ×   LOOP      BXLE
°                         :                        ×            :
°                    ENDLOOP   UNTIL,condition     ×   ENDLOOP   BXLE,r1

°                    LOOP      UNTIL               ×   LOOP      BCT
°                         :                        ×            :
°                    ENDLOOP   UNTIL,LEAVE         ×   ENDLOOP   BCT,reg

°            Figure 4.  Types of LOOP macros
°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
¸
¸
¸
¸

°                                                     Chapter 8. Loops
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          38    Structured Macros Users's Guide
¯
¸
                                           CHAPTER 9. CASES AND CASE BL
                                           CHAPTER 9. CASES AND CASE BL
                                           CHAPTER 9. CASES AND CASE BL
                                           CHAPTER 9. CASES AND CASE BL
°                                           ____________________________
¸
°          The  CASE  structure  may be used in place of the "jump-table
°          "go-to-depending-on" structure and serves the  same  function
°          the  Pascal  CASE structure.   The macros used to create the
°          structure are CASEBLK, CASE and ENDCASE.  The CASEBLK macro o
°          a case block and generates code that selects  a  handler  rou
°          based  on  the contents of a register.  The ENDCASE macro den
°          the end of a CASE block, and will be branched to at  the  end
°          each  individual  CASE.   CASE macros within the CASE block f
°          code that will handle an individual case, or occurrence.

°          A common example of the use of a CASE block might appear afte
°          call  to  some  routine  which  may  return one of several re
°          codes, each of which must be handled differently, as in  Figu
°          on page 33.

°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°            IF  (TREG,R15,NZ),THEN
°              CASEBLK REG=R15,MULT=4

°                CASE 4
°                -- code handles return code 4

°                CASE 12,16
°                -- code handles return codes 12 and 16

°                CASE OTHER
°                -- code handles other return codes

°              ENDCASE

°            ENDIF

°            Figure 5.  The CASE Block
°          ¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿

°          Please note that since the CASE and CASEBLK macros generate a
°          ries  of  branches  that are selected by the value in the CAS
°          register, it should be used to select one value from  a  list
°          numerically  ordered  choices.   For comparing character data
°          selecting from widely separated values, the IF - ELSEIF struc
°          should be used.   For more information on  ELSEIF,  see  its
°          scription in "Chapter 7. The IF Structure" on page 29.
¸
¸
¸

°                                     Chapter 9. CASEs and CASE Blocks
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          40    Structured Macros Users's Guide
¯
¸
        ×                  CHAPTER 10. PARAMETER LISTS AND STANDARD LIN
                           CHAPTER 10. PARAMETER LISTS AND STANDARD LIN
                           CHAPTER 10. PARAMETER LISTS AND STANDARD LIN
                           CHAPTER 10. PARAMETER LISTS AND STANDARD LIN
°                           ____________________________________________
¸
°        × The Structured Macros provide excellent support for the main
°        × gram  being  called and for calling internal and external sub
°        × tines using standard OS linkage conventions.   A  large  part
°        × this  is handling standard OS parameter lists.  The standard
°        × for these parameter lists is a sequence of  fullwords,  each
°        × address  of  a  particular data item.  If a data item is miss
°        × the address pointing to it is filled in with a fullword of ze
°        × Upon entry to the routine, register 1 should point to  the  f
°        × fullword in the parameter list.

°        × The  handling  of parameter lists consists of two pieces.  Fi
        × there must be some way to reference input parameter lists.  T
                                              input parameter lists
                                              input parameter lists
°                                              input parameter lists
°        × lists are processed by a program or  subroutine  block  and
°        × created by the invoking program.  Secondly, support is needed
        × generated  parameter  lists.   These are parameter lists that
          generated  parameter  lists
          generated  parameter  lists
°          generated  parameter  lists
°        × created by a program or subroutine block and are then  passed
°        × an  external  routine or another subroutine.  These functions
°        × intertwined, since a program that calls  an  internal  subrou
°        × may  create a generated parameter list that becomes the input
°        × rameter list of the subroutine being called.
¸
        × REFERENCING INPUT PARAMETER LISTS
          REFERENCING INPUT PARAMETER LISTS
          REFERENCING INPUT PARAMETER LISTS
          REFERENCING INPUT PARAMETER LISTS
°          _________________________________

°        × The input parameter list for a program  is  referred  to  by
        × Structured  Macros  as  the Program Parameter List (or PPL).
                                      Program Parameter List
                                      Program Parameter List
°                                      Program Parameter List
        × corresponding structure for subroutines is the Subroutine Par
                                                         Subroutine Par
                                                         Subroutine Par
°                                                         Subroutine Par
        × ter List (or SPL).   The Structured Macros provide  a  number
          ter List
          ter List
°          ter List
°        × options  to control the handling of input parameter lists.  T
°        × options are specified as sub-options of the PARMS option.

°        × The VL×NOVL parameter option identifies the input parameter
°        × as being either variable or fixed length.

°        × The  COPY parameter option instructs the macros to copy the i
°        × parameter list into the current work area (PWA for  programs
°        × SWA  for subroutines).  In this case, the PPL (or SPL for sub
°        × tines) is not the original input parameter list, but  a  copy
°        × the  original  made  in working storage.   This has several u
°        × First, it prevents the program from modifying the original pa
°        × eter list.  Modifying an input parameter list is not  allowed
°        × the  standard  linkage  rules.   Second, by copying the param
°        × list, it is addressed with the work area base register and a
°        × arate parameter list register is not required.

°        × Lastly, the COPY option makes it easier to determine which pa
°        × eters were specified on a variable length parameter  list.
°        × work  area  storage  is  always  large enough to hold the max

°                                                     Standard Linkage
¯
¸
°        × length parameter list and is filled with zeros before  the  i
°        × parameter  list  is  copied there.   Because of this, the pro
°        × only needs to test any parameter address for zero to  see  if
°        × was  specified  in  the original parameter list.  The COPY op
°        × requires that the PWA  option  has  been  specified  for  pro
°        × blocks  and  that the SWA option has been specified on subrou
°        × blocks.

°        × The COPYERROR parameter option is required if the COPY option
°        × used  with VL input parameter lists and is used to name the e
°        × exit that will be invoked if the  input  parameter  list  is
°        × large  to  fit  in  the space reserved for it in working stor
°        × This will happen if the parameter list is larger than expecte
°        × if it is not a VL parameter list, making it  impossible  for
°        × Structured  Macros  to  determine the last parameter.   Any e
°        × exit in the program can be specified including the unnamed  e
°        × exit  and an exit code may be passed to the error exit identi
°        × the type of error to a multi-purpose exit.

°        × The COUNT parameter option specifies the location of  a  full
°        × into which the Structured Macros will place the number of par
°        × ters  in  a  VL input parameter list.  This can be used to ve
°        × that the program was called with the correct  number  of  par
°        × ters.

°        × The  USING  parameter  option  specifies  a register that wil
°        × loaded with the starting address of  the  input  parameter  l
°        × This will either be the original input parameter list, or an
°        × within  the current work area (if COPY was also specified).
°        × the register is loaded, a USING is done to provide addressibi
°        × on the parameter list.

°        × The PREFIX option instructs the macros to use a unique  param
°        × list ID when generating the tag names within the PPL or SPL.
°        × more  information  about  how  this is used, see "Chapter 11.
°        × cation and Scope of Data Structures" on page 43.

°        × In order to make use of these options, a description of the i
°        × parameter list must be provided.  There are two  mutually  ex
°        × sive keywords on the BLOCK macro provided for this purpose.

°        × If  a  mapping macro is already available for the input param
°        × list, the PARMMAP keyword can be used to specify the  Dsect
°        × and  length.    This provides a name for a USING on the param
°        × list, and defines the size of the area that must be reserved
°        × a COPY.

°        × If  a  mapping  macro  is not available, the PARMS keyword ca
°        × used to specify a list of tags that will be used to map  the
°        × rameter  list.    These tag names will either be used to gene
°        × the parameter list Dsect, or will be  mapped  to  the  work
°        × storage if COPY is being used.
¸

°          42    Structured Macros Users's Guide
¯
¸
        × Note: Whether  a  parameter list is mapped by a supplied Dsec
          Note:
          Note:
°          Note:
°        × tags generated by the PARMS keyword, these tags will not refe
°        × the parameters themselves, but rather to the addresses of the
°        × rameters.  This is not a deficiency in the Structured Macros;
°        × is simply the way that standard OS parameters work.
¸
          GENERATING PARAMETER LISTS
          GENERATING PARAMETER LISTS
          GENERATING PARAMETER LISTS
          GENERATING PARAMETER LISTS
°          __________________________

°          Most  external  subroutines (and some internal ones) will req
°          some sort of parameter list to pass data between the calling
°          gram and the subroutine.

°          The Structured Macros provide  excellent  support  for  build
°          maintaining,  and  passing  parameter lists.   The PLIST macr
°          used to create or modify a parameter list.  It also loads  re
°          ter  one  with  the address of the completed list.  The follo
°          example illustrates some of the capabilities of the PLIST mac

°        ×    PLIST  (DATA1,,*DATA3,*),PL=(PARMSTOR,4)

°          This example will build a parameter list of four items at the
°        × cation pointed to by PARMSTOR.  First is a simple data item
°        × will have its address loaded into the parameter list.  The se
°        × item  in  the  list  is missing, so its address will be fille
°        × with a full word of zeros.  The third item in the  list  will
°        × filled  in  with  the  contents  of DATA3 instead of a pointe
°        × DATA3.  This form of indirect addressing is used when the  re
°        × enced  storage  contains  a pointer to the actual parameter.
°          asterisk in the fourth position tells the  PLIST  macro  to
°          over  that  position  in  the  list and leave the value there
°          changed.  This is useful if you are modifying  a  parameter
°          that  was  created  earlier,  and you only want to update cer
°          fields.  The fields that are not to be changed can be marked
°          asterisks.  Once the parameter list has been  built,  PLIST
°          load register one with the address of PARMSTOR.

°          The  PLIST  macro  allows  the use of constants as well as la
°          when defining parameter lists.  Observe the following example

°             PLIST (0,,'HELLO?',=X'FF')

°          which is equivalent to:

°             PLIST (=F'0',,=C'HELLO?',=X'FF')

°          Both examples generate literal constants, and then  fill  in
°          parameter  list with the addresses of these constants.  Any d
°          mal self-defining constant will be treated as a full word lit
°          and any character string in quotes will be treated as a chara
°          literal.  Note that any other type of literal (such as hex or
°          nary) has to be coded as a literal.  Since decimal and  chara

°                                                     Standard Linkage
¯
¸
°          constants  can  be coded as constants instead of as literals,
°          PLIST macro makes generating parameter lists even more painle

°          Please  note  in  the  examples above the distinction between
°          first and second parameter in each list.  The first parameter
°          a decimal constant of zero.  The macros will generate a full
°          of zero and fill in the first position in the parameter list
°          the  address  of  it.    The  second parameter is missing, so
°          macros will put a full word of zeros into the parameter list
°          self.  This is an important distinction to remember.

°          There are two main types of parameter lists: variable length
°          and fixed length (NOVL).  In variable length parameter lists,
°          last  address  in the list has its high bit set to one to mar
°          as the end of the list.  Since the length of fixed length par
°          ter lists is known in advance,  the  end  does  not  need  to
°          marked.  The VL or NOVL option on the program block macro is
°        × to  set  up  the default for all parameter lists generated by
°        × program or any of its internal subroutines.   Note that  this
°        × distinct from the VL parameter option (specified by the PARMS
°        × tion).    The  VL  parameter option describes the input param
°        × list.  You can specify a VL (or NOVL) keyword on the PLIST  m
°          to  override  this  default.   Note that all of the super opt
°          specify VL so that you will get variable length  parameter  l
°          by default.  If the PLIST macro is generating a VL parameter
°          (either  because  of the VL option on the program block or th
°          keyword on the PLIST macro), the last address  in  the  param
°          list  will have its high bit set to one.  This occurs even if
°          last parameter has been marked with an asterisk.

°        × You have many choices as to where the parameter list itself
°        × built.   As you have already seen, you can use the PL= keywor
°        × specify a tag and a number of parameters for the parameter  l
°        × This  number  should  represent the size of the storage avail
°        × for the parameter list.   The number  is  necessary  because
°        × PLIST macro verifies that there is enough room to hold the pa
°        × eter  list.   This prevents PLIST from running over the param
°        × list storage into other data fields.   If the  tag  has  a  s
°        × defining length attribute, the number field can be omitted.
°        × ever,  because  of  the way the assembler interprets lengths,
°        × need to be careful.  To illustrate this:

°        ×   PARMS1  DS  3F
°        ×   PARMS2  DS  XL(3*4)

°        × Both of the definitions above reserve enough space for a  par
°        × ter list at least three items long.  However, the assembler v
°        × the  first  tag as having a length of 4 since it is just a se
°        × of fullwords.  Therefore, PLIST will assume that this storage
°        × cation can hold a parameter list of only one item.    The  se
°        × example actually has a length of 12, which is what PLIST will
°        × quire if you try to build a parameter list of three items her
¸

°          44    Structured Macros Users's Guide
¯
¸
          AUTOMATIC PARAMETER LISTS
          AUTOMATIC PARAMETER LISTS
          AUTOMATIC PARAMETER LISTS
          AUTOMATIC PARAMETER LISTS
°          _________________________

°        × If  your  program has a PWA, you can have storage for your ge
°        × ated parameter lists automatically allocated within the PWA.
°          parameter lists that do not include a PL= keyword in their  d
°          nitions  will  be  placed in a special parameter list area in
°          PWA.   This area is only big enough to contain the single lar
°          parameter list in the program and is reused when a new  param
°          list is needed.  For this reason, it is most useful for param
°          lists  that  are  created, immediately used, and can then be
°          carded.

°          A separate parameter list area is also created for  any  inte
°          subroutines  that  generate  parameter lists themselves.  Thi
°          because a subroutine that generates a  parameter  list  may
°          been  called  with  one  and that one must remain even though
°        × subroutine is generating new ones.  The subroutine parameter
°        × area is created within the SWA for the subroutine.

°          If your program does not have a PWA, you can achieve the same
°          fect with the PL= keyword on the block macro.   This  keyword
°          identical  to  the  PL=  keyword on the PLIST, CALLSUB, and C
°          macros and defines a default parameter list area for any  par
°          ter  lists within that enclosing block.  This keyword can be
°          on any type block to create a unique parameter list area for
°          program section.
¸
          PERMANENT PARAMETER LISTS
          PERMANENT PARAMETER LISTS
          PERMANENT PARAMETER LISTS
          PERMANENT PARAMETER LISTS
°          _________________________

°          There are still cases where you would want to code PL= for a
°          rameter list.  If your program requires that a subroutine wil
°          called  many  times with the same parameter list it would hel
°          be able to create it just once, then refer to it as often as
°          essary.  Also, it may be desirable to create a parameter list
°          then modify it conditionally before its use.  In either of  t
°          cases,  you can use PLIST with the PL= keyword to create the
°          in its own unique location.  This prevents the  list  from  b
°          overwritten  by  the  next  parameter  list.   These lists ma
°          viewed as permanent since they remain until specifically  wri
°          over,  while  the automatic parameter lists only remain until
°          storage is needed for the next list.

°          If a permanent parameter list is needed, you  can  code  a  P
°          macro  with  the PL= keyword and define storage for the param
°          list, most likely in the PWA or SWA.  However, this requires
°          upkeep than the other types of parameter lists.   You  must
°          sure that enough storage has been reserved to contain all the
°          rameters  in  the list and if the number of parameters is cha
°          later, the storage definition must be changed.
¸
°                                                     Standard Linkage
¯
¸
°          It would be nice if there was a way to get the Structured  Ma
°          to  generate  the  DS commands for you.  That way, if the siz
°          the parameter list changed, the storage area  would  change
°          it.   This would give the advantages of the temporary lists w
°          still  allowing  you  to  keep the list around and refer to i
°          name for subroutine calls or modifications to the list.  Ther
°          such a mechanism in the macros.  It is done with the DS=  key
°          on  the  PLIST macro.  With the DS= keyword, you can instruct
°          macros to set aside storage for a particular  parameter  list
°          the  PWA  or in an SWA (of course you can only specify SWA if
°          parameter list is being built in a subroutine that has one.)
°          example:

°             PLIST  (DATA1,DATA2,DATA3),PL=PARM1,DS=PWA
°             PLIST  (DATA4,DATA5),PL=(PARM2,3),DS=SWA

°          When the DS= keyword is used, the PLIST macro counts the  par
°          ters in the list and sets aside just enough storage for them
°          a  label  supplied  by  the PL= keyword.   You can also force
°          macro to allocate a specific amount of space by including a
°          ber  in the PL= keyword.  After a parameter list is created u
°          the DS= keyword, it can be referred to with just a PL=tag.
°          caution  on  using this keyword:   Since the PLIST macro actu
°          defines the parameter list storage within a partial PWA, the
°          keyword  should  appear  on  the first reference to the param
°          list that the assembler sees and no others.  All other refere
°          to the parameter list should just use PL= to specify the tag
°          that list.
¸
        × CALLING SUBROUTINES
          CALLING SUBROUTINES
          CALLING SUBROUTINES
          CALLING SUBROUTINES
°          ___________________

°        × Two macros are provided for calling subroutines.  CALLSUB is
°        × to  call  an  internal subroutine that is included as part of
°        × assembly of the main program.   CALLX is used  to  call  exte
°        × routines  that have been linked with the main program or that
°        × dynamically loaded.  These external routines may  be  other
°        × grams, or they may be IBM or vendor supplied service routines

°        × The  CALLSUB  macro generates a BAL instruction (or BAS if th
°        × option is being used) to jump to a subroutine  that  the  pro
°        × has direct addressability to.  The return address will be in
°        × ister  14.    Otherwise,  all  registers have the same value
°        × entry to the subroutine  that  they  had  in  the  main  prog
°        × CALLSUB  also  provides the necessary linkage for Dynamic Sto
°        × Management if DYN is being used, and  for  subroutines  that
°        × LOADBASE.   In either of these cases, the contents of registe
°        × are also destroyed by the CALLSUB macro.

°        × The CALLX macro is for external subroutines and generates a
°        × instruction  (or BASR) with the return address in register 14
°        × the subroutine address in register 15.  This is the standard

°          46    Structured Macros Users's Guide
¯
¸
°        × mat for external subroutines.  Registers 14 and 15 are  the
°        × ones destroyed by the CALLX macro.  All others will have the
°        × value in the subroutine that they had in the calling program.

°        × CALLX  also  differs  from CALLSUB in the way that the subrou
°        × address is specified.  Since CALLSUB is used for internal sub
°        × tines, the name of the subroutine is  specified  on  the  CAL
°        × macro.    To  call  an external subroutine with CALLX, you sh
°        × specify the address in a register, or give the  CALLX  macro
°        × address  of  a  location  that contains a pointer to the exte
°        × routine.
¸
          PARAMETER LISTS ON CALLSUB AND CALLX
          PARAMETER LISTS ON CALLSUB AND CALLX
          PARAMETER LISTS ON CALLSUB AND CALLX
          PARAMETER LISTS ON CALLSUB AND CALLX
°          ____________________________________

°          If you are going to build a parameter list and  then  immedia
°          issue  a  CALLSUB or CALLX macro, you can combine these funct
°          in a single macro.  The CALLSUB and CALLX macros can generate
°          rameter lists just as PLIST does, so you can  have  these  ma
°          build your parameter list for you.  For example:

°        ×    CALLSUB  SUBONE,(DATA1,*DATA2,100),PL=(PARMS1,3),NOVL
°        ×    CALLX    (R15),(DATA3,'ERROR')

°          This  method  of calling subroutines is very simple.  However
°          should be noted that the parameter list will be  recreated  e
°          time the subroutine is called.  If you are going to make repe
°          calls  to  a subroutine with the same parameter list, it woul
°          better to create the parameter list once and simply load the
°          dress  of  it  before the subroutine call.  This can be done
°          this:

°             CALLX   (R15),PL=PARMSTOR
¸
          RECOMMENDATIONS
          RECOMMENDATIONS
          RECOMMENDATIONS
          RECOMMENDATIONS
°          _______________

°          To help you better understand the types of  parameter  lists
°          calls,  here  are some general conventions to remember when u
°          the Structured Macros for parameter lists.  These rules  are
°          enforced  by the macros, but are good programming practice.
°          reading these rules, remember the distinction  between  perma
°          lists  that  use  the PL= keyword to point to a specific loca
°          and automatic lists that are defined in  default  parameter
°          storage.

°        × ø   If the PARMS keyword was used to describe the input param
°        ×     list,  you  will  generally want a parameter option of ei
°        ×     COPY or USING, but not both.
¸
°                                                     Standard Linkage
¯
¸
°        × ø   Since it frees a register that otherwise would be used to
°        ×     the parameter list, COPY will probably be the most common
°        ×     tion.

°        × ø   If the PARMMAP keyword was used to describe the input par
°        ×     ter list, you will generally want the USING parameter opt
°        ×     The COPY option may be specified if you want the function
°        ×     provides.

°          ø   When  using CALLSUB and CALLX, the PL= keyword is only re
°              necessary when referring to a permanent  list  created  b
°              previous PLIST macro.

°          ø   The  PLIST  macro  is  only needed for creating and modif
°              permanent parameter lists or when the call must be done w
°              out CALLSUB or CALLX (With LINK for example).

°          ø   Permanent parameter lists should only be created with PLI

°          ø   The * notation for modifying parameters should only  be
°              in permanent parameter lists.

°        × ø   Temporary parameter lists should only be created with CAL
°        ×     or  CALLX  (Except  when forced to use PLIST because the
°        ×     cannot be made with CALLSUB or CALLX).
¸
        × EXAMPLE SOURCE
          EXAMPLE SOURCE
          EXAMPLE SOURCE
          EXAMPLE SOURCE
°          ______________

°        × Here is an example to show you some of the various ways in  w
°        × parameter lists can be used:
¸
¸
¸
¸
¸
¸
¸

°          48    Structured Macros Users's Guide
¯
¸
°        ×    BLOCK   TYPE=PROGRAM,NAME=PROG1,OPTIONS=(*PWA)
°        ×   *  Call external routine and pass a parameter list
°        ×     LOAD   EP=PROG2
°        ×     CALLX  (R0),(MYDATA,'OPEN',),NOVL
°        ×    ENDBLK  BLOCK=PROG1

°        ×   *  And under a separate assembly, you have
°        ×    BLOCK   TYPE=PROGRAM,NAME=PROG2,PARMS=(DATA,FUNCTION,OPT)
°        ×                  OPTIONS=(*PWA,(PARMS,COPY,NOVL))
°        ×   *  Copy actual parameter data to working storage
°        ×     L      R1,DATA               Get address of 1st parameter
°        ×     MVC    DATA1,0(R1)           Save data away
°        ×   *  Create a permanent list for later use.  Note that FUNCTI
°        ×   *  the address of the parameter we want to pass.
°        ×     PLIST  (DATA1,*FUNCTION,53),PL=PARM1,DS=PWA
°        ×   *  Call subroutine using temporary list
°        ×     CALLSUB SUBONE,(DATA3,,'INIT')
°        ×   *  Modify permanent list
°        ×     PLIST  (*,DATA5,*),PL=PARM1
°        ×   *  Call subroutine using previous list
°        ×     CALLX  =V(EXTRSUB),PL=PARM1
°        ×    ENDBLK  BLOCK=PROG2

°        ×    BLOCK   TYPE=SUBROUTINE,NAME=SUBONE,PARMMAP=(SUBPARM,SUBPA
°        ×                  OPTIONS=(*SWA,(PARMS,(USING,R9),VL))
°        ×   *  Call subroutine using temporary list
°        ×   *  This list will be created in SWA
°        ×     CALLX  (R15),(155,'NAME',=X'FF')
°        ×   *  Create a permanent list within SWA
°        ×     PLIST  (DATA4,DATA5),PL=SWAPARM,DS=SWA
°        ×    ENDBLK  BLOCK=SUBONE
°        ×            SUBPARM DSECT=YES            Generate Dsect for in
°        ×   SUBPARML EQU   *-SUBPARM
¸
¸
¸
¸
¸
¸
¸

°                                                     Standard Linkage
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          50    Structured Macros Users's Guide
¯
¸
        ×                 CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCT
                          CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCT
                          CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCT
                          CHAPTER 11. LOCATION AND SCOPE OF DATA STRUCT
°                          _____________________________________________
¸
°        × Since  the Structured Macros handle all of the implementation
°        × tails of PWAs, PSDs, SWAs, etc., a programmer should not have
°        × reference any of these data areas directly.  However, on the
°        × occasions that it is necessary, symbols are defined by the St
°        × tured Macros that contain unique tags located at the beginnin
°        × these structures.  These symbols are listed below:

°        ×      &PWA - Program Work Area           &SWA - Subroutine Wor
°        ×      &PSD - Program Static Data         &SSD - Subroutine Sta
°        ×      &PPL - Program Parameter List      &SPL - Subroutine Par

°        × In  order  to  have  these symbols available to your program,
°        × need to include an assembler COPY statement at the  beginning
°        × your program for the member SMSYMS.  This is necessary becaus
°        × the  Assembler  H requirement that all global symbols be decl
°        × in open code and not from within macros.

°        × These symbols can be used by any programs that needs to calcu
°        × offsets within any of these structures.   However, these  sym
°        × have a much better use when used within subroutines.
¸
        × LOCAL SCOPE WITHIN SUBROUTINES
          LOCAL SCOPE WITHIN SUBROUTINES
          LOCAL SCOPE WITHIN SUBROUTINES
          LOCAL SCOPE WITHIN SUBROUTINES
°          ______________________________

°        × One  of the nicer concepts of high-level languages is local s
°        × within subroutines.   This isolates the working  storage  of
°        × subroutine  from  the main program, and helps to prevent the
°        × routine from affecting the program's storage in  unforseen  w
°        × To some extent, Subroutine Work Area accomplish this goal for
°        × sembler  programs.    By giving each subroutine its own work
°        × instead having to share work areas within  the  PWA,  the  ch
°        × that two subroutines will overlay each other's storage is gre
°        × reduced.

°        × Another  very nice feature of local scope becomes evident whe
°        × comes time to think up names for variables and work areas.  I
°        × language with local scoping, you can name variables within a
°        × routine  without  any regard for what the variables in other
°        × routines have been named.  This also makes it easier  to  cop
°        × subroutine  from  one  program  to another, since the new pro
°        × does not have to be checked for variable name conflicts.

°        × Unfortunately, 370 assembler requires that every  tag  be  un
°        × and does not allow for local scoping of names.  However, the
°        × routine  data  area symbols described above can be used to ac
°        × plish the same effect.  They contain the name of  a  tag  at
°        × beginning  of  a  data area, but this can also be thought of
°        × unique id that can be prefixed to tag names to  distinguish

°                    Chapter 11. Location and Scope of Data Structures
¯
¸
°        × from  identically named tags in other subroutines.  To facili
°        × this use of the symbols, abbreviated versions of them  were
°        × ated.  The short versions are:

°        ×      &SWA = &W
°        ×      &SSD = &S
°        ×      &SPL = &P

°        × With  these tags, a subroutine like the following can be writ
°        × Note the use of the PREFIX parameter option to force the  use
°        × the &P. symbol in the SPL.

°        ×          .
°        ×     COPY    SMSYMS
°        ×          .
°        ×          .
°        ×          .
°        ×    EDITDATA    TITLE 'SUBROUTINE TO EDIT PASSED FULLWORD'
°        ×    *---------------------------------------------------------
°        ×    *  SUBROUTINE  EDITDATA
°        ×    *
°        ×    *  ABSTRACT    THIS SUBROUTINE WILL TAKE THE FULLWORD PASS
°        ×    *              FIRST PARAMETER PASSED TO IT, EDIT IT INTO
°        ×    *              AND COPY THE RESULTS INTO THE AREA POINTED
°        ×    *              SECOND PARAMETER.
°        ×    *---------------------------------------------------------
°        ×             SPACE 3
°        ×     BLOCK   NAME=EDITDATA,TYPE=SUBROUTINE,
°        ×                   OPTIONS=(*SWA,(PARMS,(USING,R9),PREFIX)),
°        ×                   PARMS=(DATAPTR,RESULT)
°        ×      L      R1,&P.DATAPTR                × GET ADDR OF FULL W
°        ×      L      R2,0(,R1)                    × LOAD FULL WORD TO
°        ×      CVD    R2,&W.DOUBL                  × CONVERT TO DECIMAL
°        ×      MVC    &W.MASK,&S.MASK              × COPY EDIT MASK TO
°        ×      EDIT   &W.MASK,&W.DOUBL             × EDIT DECIMAL NUMBE
°        ×      L      R1,&P.RESULT                 × GET PTR TO RESULT
°        ×      MVC    0(11,R1),&W.MASK             × COPY RESULT.
°        ×     ENDBLK  BLOCK=EDITDATA
°        ×             SSD
°        ×    &S.MASK  DC    CL'4020202020202020202120'
°        ×             ENDSSD
°        ×             SWA
°        ×    &W.MASK  DC    CL'4020202020202020202120'
°        ×    &W.DOUBL DS    D
°        ×             ENDSWA

°        × Although  this  may  seem strange at first, most programmers
°        × find that the advantages outweigh any inconveniences.
¸
¸

°          52    Structured Macros Users's Guide
¯
¸
                                           CHAPTER 12. MISCELLANEOUS MA
                                           CHAPTER 12. MISCELLANEOUS MA
                                           CHAPTER 12. MISCELLANEOUS MA
                                           CHAPTER 12. MISCELLANEOUS MA
°                                           ____________________________
¸
°          There  are  several  macros  packaged  with the Structured Ma
°          that, while they are not true structured programming  aids,
°          form commonly used functions and relieve some coding effort.
¸
          BIT MANIPULATION
          BIT MANIPULATION
          BIT MANIPULATION
          BIT MANIPULATION
°          ________________

°          There  are  macros  provided that perform the 4 most common f
          tions performed on a bit:  setting (OI), resetting (NI),  inv
°                                     __________________________________
          ing  (XI)  and testing (TM).  The macros that perform these t
°          _________      _____________
          are called SBIT, RBIT, IBIT and TBIT, respectively.   Each  m
°                     ________________     _____
°          uses the appropriate immediate instruction to operate on a si
°          byte;  however,  multiple  bits  within  the  target  byte ma
°          changed at once.  For example, the macro

°             SBIT  FLAGBYTE,(BIT1,BIT2,BIT3)

°          would generate:

°            +            OI   FLAGBYTE,BIT1+BIT2+BIT3

°          There is also a naming convention which is  optional  when  u
°          these  macros. If the address of the target byte is not provi
°          the macros assume that the target byte's tag is the first 5 c
°          acters of the flag name. For example, the macro

°             IBIT  PWAF1OK

°          would assume the flag was named "PWAF1" and generate:

°            +            XI   PWAF1,PWAF1OK

°          The TBIT macro is valid as a "compare" instruction, allowing
°          use  of  TBIT  in  conditional expressions on IF, LEAVE, LOOP
°          ERREXIT.
¸
          TESTING A REGISTER
          TESTING A REGISTER
          TESTING A REGISTER
          TESTING A REGISTER
°          __________________

°          The TREG macro may be used in place  of  the  "LTR"  instruct
°          TREG  always issues a LTR that loads the target register from
°          self, thus setting the condition code without modifying any
°          isters.  TREG is valid in a conditional expressions.
¸

°                                     Chapter 12. Miscellaneous Macros
¯
¸
          INITIALIZING STORAGE
          INITIALIZING STORAGE
          INITIALIZING STORAGE
          INITIALIZING STORAGE
°          ____________________

°          The  FILL  macro  may  be  used to set areas of storage to a
°          value, such as spaces or low-values.   There are three  types
          FILL  which may be done:  short, the default, for 1 to 256 by
°                                    ______
          medium, for up to 4095 bytes, and long, for up to  16  megaby
°          _______                           _____
°          Medium  FILL may use any length constant which the LA instruc
°          can handle, while a long FILL must have its length in a regis
°          otherwise, medium and long FILL are identical.  A short FILL
°          not destroy any registers, as it uses MVI and  MVC  to  propa
°          its  fill  character, but medium and long FILL both use MVCL,
°          will destroy the contents of R14, R15, R0 and R1.
¸
          REGISTER LOADING
          REGISTER LOADING
          REGISTER LOADING
          REGISTER LOADING
°          ________________

°          Often  it  is necessary to load one, two, three, or four byte
°          data into a register from storage.   The L8, L16,  L24,  and
°          macros  allow  this  to be easily accomplished.  For example,
°          instruction

°             L16   R4,DATA1

°          will load the low-order two bytes of register four with  the
°          bytes  at  location  DATA1  and clear the high-order two byte
°          register four.  These macros clear the  specified  register,
°          issue an appropriate ICM to load the required data.

          Important  note:   Since all of these macros except L32 clear
          Important  note:
          Important  note:
°          Important  note:
°          register before doing the ICM, they should never be used to
°          a  register that is referred to in the address being loaded f
°          To illustrate this:

°             L16   R2,10(R2)

°          would generate the following code:

°            +            SLR  R2,R2                    CLEAR REGISTER
°            +            ICM  R2,B'0011',10(R2)        LOAD 16 BITS

°          In this example, register two is cleared to zero, then is  lo
°          with  the  two bytes at the location pointed to by ten off of
°          contents of register two.  But since register two  has  been
          roed,  this loads from absolute location ten.  This type of p
°                                 _____________________
°          lem can be very difficult to debug because without looking at
°          macro expansion, it is difficult to understand  exactly  what
°          going on.
¸
¸
°          54    Structured Macros Users's Guide
¯
¸
          EXECUTING INSTRUCTIONS
          EXECUTING INSTRUCTIONS
          EXECUTING INSTRUCTIONS
          EXECUTING INSTRUCTIONS
°          ______________________

°          The EX instruction is a very powerful tool in System/370 asse
°          language.    There are many cases where it is the simplest me
°          to operate on a variable amount of  data.    However,  there
°          problems  with using the EX instruction.  Most of these stem
°          the placement of the instruction to be EXecuted.  The instruc
°          can be placed inline, right next to the  EX  instruction  wit
°          branch  around  it.   This is convenient, but wasteful becaus
°          requires unnecessary branch instructions.  The instruction ca
°          placed with the static  data,  but  this  causes  more  probl
°          First,  the  EX instruction is removed in the source from the
°          struction being EXecuted, making  the  program  harder  to  r
°          Second,  the USING environment of the EXecuted instruction ma
°          completely different from that of the EX instruction, making
°          coding of meaningful labels difficult or impossible.

°          Perhaps  the best solution is to use the LOCTR assembler inst
°          tion.  This instruction establishes a new  location  counter
°          whatever  data  follows.   Any data or instruction defined wi
°          new location counter will be collected and placed at the  end
°          the  load module.   This way, the EXecuted instruction can be
°          fined inline with the current  USING  environment,  but  will
°          placed at the end of the load module where no branch is neede
°          skip over it.

°          However,  all  of  these  methods have one problem in common
°          used with the Structured Macros.  They all require  you  to
°          tags  in  the  body of the program.   Since the Structured Ma
°          eliminate the need for tags in the rest of the program, this
°          upset  the  indentation  scheme and make the program look "me
°          and difficult to read.

°          A solution to all of these problems would be to provide  a  m
°          to generate the EX instruction and its object and to generate
°          tags  automatically.    This way, the source could still be c
°          without the use of any tags.  The EXI macro is included with
°          Structured  Macros  to  provide this function.  It can accept
°          register for the EX instruction, and allows the user  to  spe
°          any opcode and one to three operands.  For example:

°             EXI   R3,(MVC,DEST(0),0(R10))

°          This  will generate a MVC instruction with the operands speci
°          and an EX instruction using register 3 and the MVC.

°          If the LOCTR option was specified on the program block,  the
°          macro  puts the EXecuted instruction in the PSD (or the SSD i
°          is within a subroutine).  If NOLOCTR was specified, EXI will
°          erate the instruction inline with a branch around it.
¸

°                                     Chapter 12. Miscellaneous Macros
¯
¸
          LOADING CONTROL BLOCK ADDRESSES
          LOADING CONTROL BLOCK ADDRESSES
          LOADING CONTROL BLOCK ADDRESSES
          LOADING CONTROL BLOCK ADDRESSES
°          _______________________________

°          There  are  certain  system  control blocks that programmers
°          themselves accessing often.  The LCBA macro is provided  to
°          you  a  standard  way  of finding these control blocks.  The
°          macro locates the address of  the  specified  control  block
°          places  it in the specified register.  The mapping macros for
°          control blocks LCBA uses to find the desired  control  block
°          not  required.  The LCBA macro can be used to load the addres
°          the:

°              current ACEE,
°              current ASCB,
°              current ASXB,
°              CVT,
°              current TCB,
°              UJT (Clemson dependent),
°              and UVT (Clemson dependent).

°          For example:

°             LCBA   R8,ACEE
°             IF     (Z)
°                -- ACEE not found code --
°             ENDIF
°             USING  ACEE,R8
°                -- Now have ACEE --
¸
        × CONTROLLING STRUCTURED MACRO OPERATION
          CONTROLLING STRUCTURED MACRO OPERATION
          CONTROLLING STRUCTURED MACRO OPERATION
          CONTROLLING STRUCTURED MACRO OPERATION
°          ______________________________________

°        × There are times when a decision must be made in the middle  o
°        × program  that  needs  to  affect  the operation of the Struct
°        × Macros at a later time.   To provide  for  this  capability,
°        × SMCTRL  macro  was created to set flags that are checked by o
°        × macros.

°        × One example of this use is the reusable PWA  support.    You
°        × SMCTRL to inform the macros that the PWA should be freed when
°        × current invocation of the program is terminated.
¸
¸
¸
¸

°          56    Structured Macros Users's Guide
¯
¸
                                         CHAPTER 13. MISCELLANEOUS EXAM
                                         CHAPTER 13. MISCELLANEOUS EXAM
                                         CHAPTER 13. MISCELLANEOUS EXAM
                                         CHAPTER 13. MISCELLANEOUS EXAM
°                                         ______________________________
¸
°          This  section  will provide some examples for pieces of code
°          programmers find themselves writing often.
¸
          A SEARCH LOOP
          A SEARCH LOOP
          A SEARCH LOOP
          A SEARCH LOOP
°          _____________

°          While search routines can be as different as the data  struct
°          they  are  accessing,  they  are usually similar in their gen
°          structure.  This is an example of  a  sequential  search  rou
°          that looks through a RACF access list.

°              BLOCK NAME=SEARCH
°            *
°            *   Set up list pointer and count for search.
°            *
°               LA   R2,ACL
°               LH   R3,ACLCNT
°            *
°            *   Now loop through the access list (ACLCNT) times.
°            *
°               LOOP BCT
°                IF  (CLC,USERID(8),EQ,0(R2)),THEN
°            *
°            *   If compare succeeds, do success code and leave.
°            *
°                      :
°                 -- success code --
°                      :
°                 LEAVE BLOCK=SEARCH
°                ENDIF
°            *
°            *  Point to next entry, try again.
°            *
°                LA  R2,ACLLEN(,R2)
°               ENDLOOP BCT,R3
°            *
°            *  Entire ACL searched without a hit, do fail code.
°            *
°                      :
°                -- fail code --
°                      :
°              ENDBLK BLOCK=SEARCH
°                      :
¸
¸

°                                   Chapter 13. Miscellaneous Examples
¯
¸
          SCANNING TEXT
          SCANNING TEXT
          SCANNING TEXT
          SCANNING TEXT
°          _____________

°          This routine (lifted from the nesting level pre-processor) us
°          BXLE  and  a  BXH loop to scan a line of assembler source for
°          opcode.

°            *
°            *   Set up for BXLE loop:
°            *     R1 points to start of source code line
°            *     R14 contains increment for R1
°            *     R15 contains A(end of line) as limit for R1
°            *
°              LA   R1,LINE                               R1 -> start of
°              LA   R14,1                                 Set increment
°              LA   R15,LINE+L'LINE                       R15 -> end of

°              LOOP  BXLE                                 Skip past any
°               LEAVE LOOP=*,(CLI,0(R1),EQ,X'40')
°              ENDLOOP BXLE,R1,R14

°            *
°            *   Now use remaining value in R1 as start for BXH loop.
°            *
°              LOOP  BXH,R1,R14                           Now scan for o

°               IF   (CLI,0(R1),NE,X'40')

°                IF  (CLC,0(6,R1),EQ,=C'BLOCK ')          If 'BLOCK'
°                 IC R0,=C'B'                             Set type to 'B
°                 CALLSUB NEST                            Call NEST

°                ELSEIF (CLC,0(7,R1),EQ,=C'ENDBLK ')      Elseif 'ENDBLK
°                 IC R0,=C'B'                             Set type to 'B
°                 CALLSUB UNNEST                          Call UNNEST

°                ELSEIF                                    ( etc. )
°                   :
°                ENDIF

°            *
°            *   If outer IF succeeded, line is processed, so leave.
°            *
°                LEAVE  LOOP=*
°               ENDIF

°              ENDLOOP BXH                                End of search
¸
¸
¸
°          58    Structured Macros Users's Guide
¯
¸
          A DCB EODAD EXIT
          A DCB EODAD EXIT
          A DCB EODAD EXIT
          A DCB EODAD EXIT
°          ________________

°          One  way to use a DCB EODAD exit (or SYNAD, EOV and other DCB
°          its) would be to "fake out" the macros by coding  a  tag  at
°          place  your  end-of-file code started and specifying EODAD=ta
°          the  DCB.    This,  however,  becomes  dangerous   when   run
°          mixed-AMODE  programs,  since  the EODAD routine would have t
°          the same AMODE as the routine where the GET was issued. To  a
°          this,  one  can take advantage of the fact that R14 points to
°          instruction following the GET or READ macro whenever a  DCB
°          is called by using an implied CALLSUB, as follows:

°              OPEN  DCB,INPUT

°              LOOP  UNTIL                         Do 'endless' loop

°            *
°            *  PWAF1EOF gets set if end-of-file was found.
°            *
°               GET      DCB,RECORD
°               LEAVE    LOOP=*,(TBIT,PWAF1EOF,ON)
°               CALLSUB  EATREC

°              ENDLOOP   UNTIL,LEAVE

°              CLOSE DCB
°                     :
°                     :
°              BLOCK NAME=EOF,TYPE=SUBROUTINE,OPTIONS=*NOSUBOPTS
°               SBIT  PWAF1EOF
°              ENDBLK BLOCK=EOF
°                     :
°                     :
°            PWAF1        DC   X'00'
°            PWAF1EOF     EQU  X'80'
°              :
°            DCB          DCB  EODAD=EOF,  ...

°          If  this sample were bimodal, subroutine EOF would have to be
°          same AMODE as the code that issued the GET macro.
¸
¸
¸
¸
¸
°                                   Chapter 13. Miscellaneous Examples
¯
¸
          RETURNING R0 AND R1 WITH ENDBLK
          RETURNING R0 AND R1 WITH ENDBLK
          RETURNING R0 AND R1 WITH ENDBLK
          RETURNING R0 AND R1 WITH ENDBLK
°          _______________________________

°          There  are  many  programming situations where it is desirabl
°          return values or pointers to a calling  program  using  regis
°          zero and one. Common examples are Sort exits, lookup routines
°          user SVC's.

°          The Structured Macros provide a method for passing back R0 an
°          R1  from  a  program  block.   You can use the RTNR0 and/or R
°          options on the program block macro and specify the R0= and/or
°          keyword on the ENDBLK for the program and all error exits.

°             BLOCK NAME=TEST,TYPE=PROGRAM,OPTIONS=*PWA,RTNR0,RTNR1
°                   :
°                   :
°             ENDBLK BLOCK=TEST,RC=0,R0=8,R1=PARMLIST
°                   :
°             BLOCK NAME=ERR1,TYPE=ERREXIT
°                   :
°             ENDBLK BLOCK=TEST,RC=8,R0=0,R1=0

°          If you are using an internal subroutine that has an SWA and w
°          like to have the subroutine return a register to its caller,
°          can use the STRSA macro.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          60    Structured Macros Users's Guide
¯
¸
        ×                     CHAPTER 14. STRUCTURED MACROS LISTING PRO
                              CHAPTER 14. STRUCTURED MACROS LISTING PRO
                              CHAPTER 14. STRUCTURED MACROS LISTING PRO
                              CHAPTER 14. STRUCTURED MACROS LISTING PRO
°                              _________________________________________
¸
°        × To  aid  the  programmer, a listing program was written that
°        × analyze the nesting structure of a  program  and  report  on
°        × problems.    It  also  provides a listing of the original pro
°        × without the macro expansions that tend to blur the structured
°        × ture of the program.  Once they have gotten used to it, many
°        × grammers use this listing for most of their work, and only  r
°        × to  the assembler listing occasionally.  JCL procedures have
°        × provided that will run this listing program and then feed the
°        × sembler source into the Level H Assembler.  See "Appendix A.
°        × alogued ASM Procedures At Clemson" for more information.
¸
        × OUTPUT OF THE LISTING PROGRAM
          OUTPUT OF THE LISTING PROGRAM
          OUTPUT OF THE LISTING PROGRAM
          OUTPUT OF THE LISTING PROGRAM
°          _____________________________

°        × Below is an example of the output of the  listing  program.
°        × displays  the original input source, along with the current n
°        × ing level depth and a diagram of the nesting type  (Block,  L
°        × or If).

°        ×   LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4

°        ×   001  B    × BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) ×
°        ×   001  B    ×*                                              ×
°        ×   002  BL   ×  LOOP   WHILE,(CR,R4,LT,R5)                   ×
°        ×   003  BLI  ×   IF    (C,R3,GE,XYZ)                         ×
°        ×   003  BLI  ×    MVC  ABC,XYZ                               ×
°        ×   002  BL   ×   ENDIF                                       ×
°        ×   001  B    ×  ENDLOOP WHILE                                ×
°        ×   001  B    ×  CALLSUB SUB1                                 ×
°        ×   001  B    ×*                                              ×
°        ×   000       × ENDBLK  BLOCK=TEST                            ×
°        ×   000       ×*                                              ×
°        ×   001  B    × BLOCK   NAME=SUB1,TYPE=SUBROUTINE             ×
°        ×   001  B    ×  LR     R1,R2                                 ×
°        ×   000       × ENDBLK  BLOCK=SUB1                            ×
°        ×   000       ×*                                              ×
°        ×   000       ×         PSD                                   ×
°        ×   000       ×         LTORG                                 ×
°        ×   000       ×XYZ      DC    F'9'                            ×
°        ×   000       ×ABC      DC    F'4'                            ×
°        ×   000       ×         ENDPSD                                ×
°        ×   000       ×*                                              ×
°        ×   000       ×         PWA                                   ×
°        ×   000       ×PWAFLAG  DS    18F                             ×
°        ×   000       ×         ENDPWA                                ×
°        ×   000       ×*                                              ×
°        ×   000       ×         END                                   ×
¸
°                        Chapter 14. Structured Macros Listing Program
¯
¸
°        × The Structured Macros Listing Program will also point out any
°        × regularities  in  the nesting structure of the program.  Belo
°        × the listing produced by feeding an incorrect program into it.

°        ×   LVL NESTING    SOURCE STATEMENT              MSC0150$ V1R4

°        ×   001  B    × BLOCK   NAME=TEST,TYPE=PROGRAM,OPTIONS=(*PWA) ×
°        ×   001  B    ×*                                              ×
°        ×   002  BI   ×  IF     (C,R3,GE,XYZ)                         ×
°        ×   002  BI   ×*                                              ×
°        ×   002  BI   × ENDBLK  BLOCK=TEST                            ×
°        ×   002  BI   ×*                                              ×
°        ×   002  BI   ×         END                                   ×

°        ×   >E-8 ENDING STRUCTURAL LEVEL IS NON-ZERO
¸
        × CONTROLLING LISTING PROGRAM OPERATION
          CONTROLLING LISTING PROGRAM OPERATION
          CONTROLLING LISTING PROGRAM OPERATION
          CONTROLLING LISTING PROGRAM OPERATION
°          _____________________________________

°        × To  control  the  operation of the Structured Macros Listing
°        × gram, the SMLIST macro has been provided.    Parameters  on
°        × macro  are  processed  by  the listing program itself, before
°        × source statements are sent to the assembler.

°        × Currently,  the  only  parameter  available  is   CONVERT=YES
°        × CONVERT=YES  instructs  the  listing program to convert the i
°        × source to all uppercase before feeding it to the assembler.
°        × allows you to write programs in upper and lower case.  Many
°        × ple find mixed case programs and comments easier to read and
°        × parameter makes it easy to do.

°        × Although  the assembler requires that its input be in upper c
°        × lower case letters are allowed in text strings.   To prevent
°        × listing  program  from converting your mixed case text string
°        × upper case, place them in double quotes  (")  instead  of  si
°        × quotes  (').   The listing programs will not convert the text
°        × tween double quotes and will change the  double  quotes  back
°        × single quotes before passing the line to the assembler.

°        × With  this  facility, programmers can write programs like the
°        × below.
¸
¸
¸
¸

°          62    Structured Macros Users's Guide
¯
¸
°        ×    TRYLOWER    TITLE 'Example program for Structured Macros'
°        ×                SMLIST CONVERT=YES
°        ×    *---------------------------------------------------------
°        ×    *  Program     TRYLOWER
°        ×    *
°        ×    *  Abstract    This illustrates the use of lower case in a
°        ×    *              source using the SMLIST CONVERT=YES functio
°        ×    *              Structured Macros Listing Program.
°        ×    *---------------------------------------------------------
°        ×             space 3
°        ×     block   name=trylower,type=program,options=(*pwa,xa),amod
°        ×                   rmode=any,r1save=r9
°        ×      l      r15,4(r9)                    × Get output routine
°        ×      la     r1,psdtext                   × Get pointer to tex
°        ×      balr   r14,r15                      × Call output routin
°        ×     endblk  block=trylower
°        ×             psd
°        ×    psdtext  dc    cl80"This is a test that is true."
°        ×             endpsd
°        ×             pwa
°        ×             endpwa
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°                        Chapter 14. Structured Macros Listing Program
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          64    Structured Macros Users's Guide
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
                                            II. STRUCTURED MACROS REFER
                                            II. STRUCTURED MACROS REFER
                                            II. STRUCTURED MACROS REFER
                                            II. STRUCTURED MACROS REFER
°                                            ___________________________
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          66    Structured Macros Reference
¯
¸
                                                          CHAPTER 15. B
                                                          CHAPTER 15. B
                                                          CHAPTER 15. B
                                                          CHAPTER 15. B
°                                                          _____________
¸
          Macro:    BLOCK
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to start a block.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   BLOCK
          Syntax:
          Syntax:
°          Syntax:
°                    [NAME=name][,TYPE=type][,ENVIRON=environ][,keyword[

          Operands:
          Operands:
          Operands:
°          Operands:

                    name      Name  of block.  This operand is required
°                    ____
°                              program and subroutine blocks.

                    type      Type of block.   This keyword  specifies
°                    ____
°                              type of block.  If this keyword is not sp
°                              fied, INLINE is assumed.

°                              The  type of blocks are ERREXIT, INLINE,
°                              GRAM, and SUBROUTINE.

°                              An errexit block contains code to be exec
°                              when an ERREXIT macro is executed.  This
°                              of block must be coded at block level zer

°                              Inline blocks are used to group a section
°                              code into a logical structure.

°                              Subroutine  blocks  contain code that is
°                              cuted when a  CALLSUB  macro  specifying
°                              name is executed.  A subroutine block mus
°                              coded at block level zero.

°                              A  program  block is used to contain the
°                              code body of a program.   Program blocks
°                              only be specified at block level zero.

                    environ   Program  environment.  This keyword speci
°                    _______
°                              the type of environment the program will
°                              in.    The  currently  supported environm
°                              are: OS for OS linkage, DC  for  IDMS/DC
°                              PLI for the execution environment of the
°                              Optimizing  Compiler.   This keyword defa
°                              to OS.

                    keyword   Indicates linkage and  initialization  to
°                    _______
°                              done.    Using  these keywords will cause
°                              associated ENDBLK to do the reverse  link
°                              The  keywords  allowed  depend on the typ
°                              block being defined.   (See the  sections
°                              the  individual block types for more info
°                              tion on the keywords allowed.)

°                                                    Chapter 15. BLOCK
¯
¸
          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Too many parameters specified on PL keyword
°                    ø   INLINE BLOCK must be contained within PROGRAM,
°                        ROUTINE, or ERREXIT BLOCK
°                    ø   PROGRAM BLOCK must be at block nesting level 1
°                    ø   PROGRAM BLOCK requires NAME keyword
°                    ø   SUBROUTINE BLOCK requires NAME keyword
°                    ø   ENVIRON must be less than 5 alphanumeric charac
°                    ø   SUBROUTINE  BLOCK  must  follow  ENDBLK for PRO
°                        BLOCK and be at block level zero
°                    ø   ERREXIT BLOCK must follow ENDBLK for PROGRAM  B
°                        and be at block level zero
°                    ø   Maximum nesting level for blocks is 20
°                    ø   Invalid BLOCK type <type>
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          68    Structured Macros Reference
¯
¸
          BLOCK TYPE=ERREXIT
          BLOCK TYPE=ERREXIT
          BLOCK TYPE=ERREXIT
          BLOCK TYPE=ERREXIT
°          __________________

°          The  errexit  block  surrounds code to be performed after a f
°          error is detected.   It is invoked by the  ERREXIT  macro.
°          ENDBLK  macro associated with an errexit block generates a br
°          to the ENDBLK code of the most recent program block,  and  al
°          you  to  specify a return code with which the program will te
°          nate.  This return code overrides any return code that may ap
°          on the program block's ENDBLK macro.  One errexit block witho
°          name keyword can be associated with a  program  block,  in  w
°          case,  a generated name is used.  Therefore, if you have only
°          errexit block, the NAME parameter may be left off  of  the  B
°          and  the  ERREXIT  macros and a name will be automatically ge
°          ated.

          Keywords for ERREXIT blocks:
°          ____________________________

          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
°          AMODE= 24 × 31 × ANY
°                Specifies the addressing mode  the  block  should  run
°                Amode  switching  code  will be generated if required.
°                default is AMODE=ANY which specifies that the errexit
°                run in the amode in effect when it is invoked.

          PL= tag×(tag,num)
          PL= tag×(tag,num)
          PL= tag×(tag,num)
°          PL= tag×(tag,num)
°        ×       Defines  the  default place to build parameter lists ge
        ×       ated within this block.   Tag defines  the  label  for
°                                          ___
                start  of parameter list storage and num is a self-defi
°                                                     ___
°                term that represents the maximum number of  parameter
                entries  that  the  storage at tag will hold.  This mus
°                                               ___
°                large enough to contain the largest parameter list  in
°                block.  If num is not specified, the tag must have a le
°                modifier that is a self-defining term.

          SAVE= (r1[,r2],address)
          SAVE= (r1[,r2],address)
          SAVE= (r1[,r2],address)
°          SAVE= (r1[,r2],address)
°                Requests that the register(s) named should be saved and
                stored.    The  address  operand  provides the address
°                                _______
°                place to save the register(s).  If more than  one  regi
°                is  specified, a "STM" instruction is generated: theref
°                specification of something like "R14,R12,address" is va
°                The SAVE keyword may be used on errexit blocks to  pres
°                some  or all registers without requiring a standard OS
°                area.  The SAVE operand is not valid on program blocks,
°                should not be confused with OPTIONS=SAVE.

          Errors:
          Errors:
          Errors:
°          Errors:
°                Refer to "Appendix B. Internal Macros  Error  Messages"
°                page 123 for macros that start with "##EP".
¸
¸

°                                                    Chapter 15. BLOCK
¯
¸
          BLOCK TYPE=INLINE
          BLOCK TYPE=INLINE
          BLOCK TYPE=INLINE
          BLOCK TYPE=INLINE
°          _________________

°          The  inline  block  is  used  to  surround a section of code
°          should be treated as a single unit.  With the inline block, A
°          can be changed at the beginning of the block and restored at
°          end.  Registers can also be saved and restored.  The inline b
°          also  allows  the user to define a logical group of code that
°          be exited with the LEAVE macro.

          Keywords for INLINE blocks:
°          ___________________________

          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
°          AMODE= 24 × 31 × ANY
°                Specifies the addressing mode  the  block  should  run
°                Amode  switching  code  will be generated if required.
°                default is AMODE=ANY which specifies that  the  block
°                run in the amode in effect when it is entered.

          PL= tag×(tag,num)
          PL= tag×(tag,num)
          PL= tag×(tag,num)
°          PL= tag×(tag,num)
°        ×       Defines  the  default place to build parameter lists ge
        ×       ated within this block.   Tag defines  the  label  for
°                                          ___
                start  of parameter list storage and num is a self-defi
°                                                     ___
°                term that represents the maximum number of  parameter
                entries  that  the  storage at tag will hold.  This mus
°                                               ___
°                large enough to contain the largest parameter list  in
°                block.  If num is not specified, the tag must have a le
°                modifier that is a self-defining term.

          SAVE= (r1[,r2],address)
          SAVE= (r1[,r2],address)
          SAVE= (r1[,r2],address)
°          SAVE= (r1[,r2],address)
°                Requests that the register(s) named should be saved and
                stored.    The  address  operand  provides the address
°                                _______
°                place to save the register(s). If more than one registe
°                specified, a "STM"  instruction  is  generated:  theref
°                specification of something like "R14,R12,address" is va
°                The  SAVE  keyword may be used on inline blocks to pres
°                some or all registers without requiring a standard OS
°                area.  The SAVE operand is not valid on program blocks,
°                should not be confused with OPTIONS=SAVE.

          Errors:
          Errors:
          Errors:
°          Errors:
°                Refer  to  "Appendix  B. Internal Macros Error Messages
°                page 123 for macros that start with "##IP".
¸
¸
¸
¸

°          70    Structured Macros Reference
¯
¸
          BLOCK TYPE=PROGRAM,ENVIRON=DC
          BLOCK TYPE=PROGRAM,ENVIRON=DC
          BLOCK TYPE=PROGRAM,ENVIRON=DC
          BLOCK TYPE=PROGRAM,ENVIRON=DC
°          _____________________________

°          The  IDMS/DC  program block, like the OS program block, surro
°          the main body of executable code. Options on the IDMS/DC  pro
°          block  determine  what type of IDMS/DC linkage is to be used,
°          IDMS/DC macros are to be expanded,  and  end-of-task  informa
°          for  application  programs (for example, NEXT TASK CODE), as
°          as reentrancy, register equating, and PWA allocation.

          Keywords for program blocks with ENVIRON=DC specified:
°          ______________________________________________________

          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
°          OPTIONS= option × (option[,option[,...]])
                Regular options:  These are the  options  for  individu
                Regular options:
                Regular options:
°                Regular options:
°                controlling  each  of the BLOCK macro's functions.  The
°                fault value for each of these options is the negative
°                (NOCSECT, NOREGEQU, etc.) but note that many of the opt
°                are included in all of the super options.

                CSECT×NOCSECT:   Indicates that a CSECT card should be
°                ______________
°                erated with the name of the block.   If NOCSECT  is  sp
°                fied,  you  will  need  to code a USING name,R15 before
°                BLOCK macro if the LOADBASE option is in affect.

                ID×NOID:  Specifies that a DC should be  generated  at
°                ________
°                start  of  the  program, containing the program block n
°                assembly date, and assembly time.  If the  CPYRGHT  key
°                is specified, it will also be DC'ed.

                LOCTR×NOLOCTR:   Cause  the  macros  to  generate LOCTR
°                ______________
°                structions for the program, subroutines,  and  static
°                areas  to insure proper placement.  This option must be
°                lected if the program is using PSDs and SSDs  or  LONG
°                LOADBASE.

                LONG×NOLONG:   Indicates  that  CALLSUBs  should genera
°                ____________
°                BALR (or equivalent) instead of a BAL to allow  subrout
°                to  establish  a base register.  This option is require
°                the program has any subroutines that  use  LOADBASE.
°                LOCTR option is required if this option is specified.

                MODE×NOMODE:  Enables generation of AMODE and RMODE car
°                ____________

                PWA×NOPWA:   Specifies  that  this program will have a
°                __________
°                The PWA will be acquired  using  #GETSTG  and  freed  u
°                #FREESTG if option RENT is in effect.  If the NORENT op
°                is  in effect, the ENDPWA macro will generate a DS inst
°                tion to reserve storage for the PWA within the CSECT.
°                PWA  and  ENDPWA macros should be used to define the li
°                of the PWA.  This option is required  if  the  program
°                subroutines that use SWAs.
¸

°                                                    Chapter 15. BLOCK
¯
¸
                REGEQU×NOREGEQU:  Specifies that register equates are t
°                ________________
°                generated.

                RENT×NORENT:   Specifies  that the program is reentrant
°                ____________
°                that the macros should  generate  reentrant  code  wher
°                necessary.

                RTNR0×NORTNR0:   Indicates  that  register  zero  shoul
°                ______________
°                passed back to the caller.   Use the  R0=  keyword  on
°                ENDBLK macro for the program block and error exits to s
°                ify  the  value  to  be  returned.  This is only valid
°                OPTIONS=SYSTEM, unless the routine is handling its own
°                linkage  and  needs  a  value in R0 from within the pro
°                block.

                RTNR1×NORTNR1:   Indicates  that  register  one  should
°                ______________
°                passed  back  to  the  caller.   Use the R1= keyword on
°                ENDBLK macro for the program block and error exits to s
°                ify the value to be  returned.  This  is  only  valid
°                OPTIONS=SYSTEM,  unless the routine is handling its own
°                linkage and needs a value in R1  from  within  the  pro
°                block.

                VL×NOVL:   Forces  all  generated  parameter  lists (PL
°                ________
°                CALLSUB, CALLX) to default to VL unless overridden.

                XA×NOXA:   Generates  support  for  linkage  using  XA
°                ________
°                structions.   If neither XA or 370 is specified, 370 is
°                default.

                370×NO370:  Generates support for  linkage  using  370
°                __________
°                structions.    If OPTIONS=XA is also specified, OPTIONS
°                causes generation of code which determines whether the
°                gram is  running  under  MVS/XA  or  not,  and  will  c
°                branches  around XA-dependent instructions generated by
°                Structured Macros such as the amode switches.

                DCMACPRT/NODCMACPRT:   Provides  support  for   the   #
°                ____________________
°                MACPRNT=ON/OFF  operand, for those IDMS/DC macros that
°                use of it.

                DCPRGPRT/NODCPRGPRT:   Provides  support  for   the   #
°                ____________________
°                PRGPRNT=ON/OFF  operand, for those IDMS/DC macros that
°                use of it.

                SYSTEM or (SYSTEM,module#) /  NOSYSTEM:   Presence  of
°                _______________________________________
°                SYSTEM  keyword  causes  IDMS/DC  system-mode linkage t
°                generated.

                #START/NO#START:  Causes a #START macro to be generated
°                ________________
°                the BLOCK macro. Valid only with the SYSTEM option.

                #RTN/NO#RTN:   Causes  a  #RTN macro to be generated by
°                ____________
°                ENDBLK macro. Valid only with the SYSTEM option.

°          72    Structured Macros Reference
¯
¸
                #RETURN/NO#RETURN:  Causes ENDBLK  to  generate  a  #RE
°                __________________
°                macro. Valid only with NOSYSTEM option.

                GETSTK:   Causes  BLOCK  to  generate  a #GETSTK instea
°                _______
°                #GETSTG. Valid only with SYSTEM and PWA options.

                (NXTTASK,taskcode):  Specifies the IDMS/DC task code  w
°                ___________________
°                should be initiated next.  Valid only with #RETURN opti

                (TYPE,returntype):   Specifies  the  type of program te
°                __________________
°                nation (NORMAL, ABORT or CONTINUE). This option  is  ge
°                ally used only with IDMS/DC #STAE routines. Valid only
°                #RETURN option.

                (RESINT,interval):  Specifies the resource timeout inte
°                __________________
°                for this task termination.  Valid only with #RETURN opt

                (RESPGM,pgmname):   Specifies  a  resource  timeout han
°                _________________
°                program, which will be called if the resource  timeout
°                terval  was specified and reached.  Valid only with #RE
°                option.

                (EP,entrypoint):  Specifies an entry point name (other
°                ________________
°                the CSECT name) to be included on the #START macro. If
°                option is not coded, the entry point name is assumed to
°                "#ST"  followed  by the internal program block number (
°                ally 1).  Valid only with SYSTEM and #START options.

°                If a type of regular option is specified  more  than  o
°                the last occurrence (ie. PWA or NOPWA) is used.

                Super  options:   These are provided as combinations of
                Super  options:
                Super  options:
°                Super  options:
°                most popular options. If one or more options is not nee
°                it should be  specified  as  desired  following  the  s
°                option's specification.

°                *NORENT  -  selects options CSECT, ID, LOCTR, MODE, REG
°                VL and #RETURN.

°                *NORENTSYS  -  selects  options  CSECT,  ID,  LOCTR,  M
°                REGEQU, VL, #START, #RTN and SYSTEM.

°                *RENT  -  selects  options  CSECT, ID, LOCTR, MODE, REG
°                RENT, VL and #RETURN.

°                *RENTSYS - selects options CSECT, ID, LOCTR, MODE,  REG
°                RENT, VL, #START, #RTN and SYSTEM.

°                *PWA - selects options CSECT, ID, LOCTR, MODE, PWA, REG
°                RENT, VL and #RETURN.

°                *PWASYS  -  selects  options  CSECT,  ID, LOCTR, MODE,
°                REGEQU, RENT, VL, #START, #RTN and SYSTEM.
¸
°                                                    Chapter 15. BLOCK
¯
¸
          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
°          AMODE= 24 × 31 × ANY
°                Specifies the addressing mode.    This  keyword  causes
°                AMODE card to be generated by the assembler with the sp
°                fied  amode.    If  this keyword is not specified, no A
°                card will be generated.

          BASEREG= reg × (reg[,reg[,...]])
          BASEREG= reg × (reg[,reg[,...]])
          BASEREG= reg × (reg[,reg[,...]])
°          BASEREG= reg × (reg[,reg[,...]])
°                Specifies  the register or registers to be used for pro
°                addressability.  The register can not be R0,  R1,  R14,
°                R15.    BASEREG will default to R13 if the NORENT optio
°                in effect and the SVAREA keyword is not  specified;  ot
°                wise, it will default to R12.

          CPYRGHT= notice
          CPYRGHT= notice
          CPYRGHT= notice
°          CPYRGHT= notice
°                Specifies  a quoted string that will be DC'ed if the ID
°                tion is in effect.

          PL= tag×(tag,num)
          PL= tag×(tag,num)
          PL= tag×(tag,num)
°          PL= tag×(tag,num)
°        ×       Defines the default place to build parameter  lists  ge
        ×       ated  within  this  block.    Tag defines the label for
°                                              ___
                start of parameter list storage and num is a  self-defi
°                                                    ___
°                term  that  represents the maximum number of parameter
                entries that the storage at tag will hold.   This  must
°                                            ___
°                large  enough  to contain the largest parameter list in
°                block.  If num is not specified, the tag must have a le
°                modifier that is a self-defining term.

          PWAREG= R11 × (R11,[reg[,...]])
          PWAREG= R11 × (R11,[reg[,...]])
          PWAREG= R11 × (R11,[reg[,...]])
°          PWAREG= R11 × (R11,[reg[,...]])
°                Specifies the register or registers to be used for PWA
°                dressability.

          RMODE= 24 × ANY
          RMODE= 24 × ANY
          RMODE= 24 × ANY
°          RMODE= 24 × ANY
°                Specifies the residency mode.

          R1SAVE= register
          R1SAVE= register
          R1SAVE= register
°          R1SAVE= register
°                The number of the register that register 1 should be co
°                to.    Program  linkage  (notably  the  use  of  #GETST
°                #GETSTK) sometimes destroys the contents of register 1
°                entry.  This keyword is useful for copying the contents
°                the parameter register to another register before it is
°                stroyed.

          SMWA= address
          SMWA= address
          SMWA= address
°          SMWA= address
°                Provides the address of a Structured Macro Workarea (SM
°                The  SMWA  is a doubleword of storage which is used to
°                serve addressing mode and a work register while  perfor
°                AMODE  switching.  The SMWA keyword is valid only on a
°                GRAM block, and is  required  when  both  the  370  and
°                options  are in effect, or when AMODE=ANY is specified.
°                SMWA may reside in the PWA.   If the  program  has  a
°                space  for  the SMWA is automatically allocated in the
°                and this keyword is not necessary.
¸

°          74    Structured Macros Reference
¯
¸
          SUBOPTS= (option,...)
          SUBOPTS= (option,...)
          SUBOPTS= (option,...)
°          SUBOPTS= (option,...)
°                Can be used to specify a default set  of  options  for
°                subroutine  blocks  associated  with  this  program.
°                options specified on subsequent subroutine blocks  will
°                in  addition to these options.  See "BLOCK TYPE=SUBROUT
°                for a description of the valid subroutine block options

                Errors:
                Errors:
                Errors:
°                Errors:
°                      Refer to ##PPDC in "Appendix B. Internal Macros E
°                      Messages" on page 123.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°                                                    Chapter 15. BLOCK
¯
¸
          BLOCK TYPE=PROGRAM,ENVIRON=OS
          BLOCK TYPE=PROGRAM,ENVIRON=OS
          BLOCK TYPE=PROGRAM,ENVIRON=OS
          BLOCK TYPE=PROGRAM,ENVIRON=OS
°          _____________________________

°          The program block surrounds the main body of executable code.
°          can  perform a wide variety of linkage types and initializati
°          including standard save area linkage, register equates, autom
°          allocation of Program Work Area, and Dynamic Storage  Managem
°          If  the program block keywords and options are not used to es
°          lish linkage,  the BLOCK macro call should  follow  linkage
°          and the associated ENDBLK macro should be followed by the rev
°          linkage.

          Keywords for program blocks with ENVIRON=OS specified:
°          ______________________________________________________

          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
°          OPTIONS= option × (option[,option[,...]])
                Regular  options:    These are the options for individu
                Regular  options:
                Regular  options:
°                Regular  options:
°                controlling each of the BLOCK macro's functions.   The
°                fault  value for each of these options is the negative
°                (NOBR14, NOCSECT, etc.) but note that many of  the  opt
°                are included in all of the super options.

                BR14×NOBR14:   Determines  whether a program block's EN
°                ____________
°                macro should generate a BR 14 instruction or not.  The
°                fault is NOBR14, but note that BR14 is included in each
°                per option.

                CLEARPWA×NOCLEARPWA:   Specifies  whether the PWA shoul
°                ____________________
°                cleared to zeros or not.

                CLRDEBUG×NOCLRDEBUG:  Specifies whether the debug  area
°                ____________________
°                the  ESV  should be cleared at entry to this program bl
°                CLRDEBUG requires the ESV option.

                CSECT×NOCSECT:  Indicates that a CSECT card should be
°                ______________
°                erated  with  the  name  of  the  block  along with a U
°                name,R15.  If NOCSECT is specified, you will need to co
°                USING name,R15 before the BLOCK macro if the  LOADBASE
°                tion is in affect.

                DYN×NODYN:    Indicates  that  Dynamic  Storage  Manage
°                __________
°                should be used.  With this option, PWA and SWA  storage
°                allocated  from the dynamic storage area.  When the DYN
°                tion is on, register 11 is used as a base for SWAs and
°                not be used by the programmer.

                ERRADDR×NOERRADDR:  Indicates that the ERREXIT macro sh
°                __________________
°                use  a  BAS instruction when branching to an errexit bl
°                If a code is specified, it will be defined in the  half
°                immediately  following  the BAS instruction.  The effec
°                the ERRADDR option is that at entry to  an  errexit  bl
°                the  CODEREG has the address of the invoking ERREXIT ma
°                If NOERRADDR is specified, a BCC instruction  is  gener
¸
°          76    Structured Macros Reference
¯
¸
°                by  the  ERREXIT  macro  to invoke an errexit block and
°                CODEREG is loaded with the code itself.

                (ESV,[parmnum],[esvtag])×NOESV:  Specifies that an Envi
°                _______________________________
°                ment  Support  Vector is present.   The macros will use
°                ESV to locate routines to do all environment dependent
                vices.  Parameter parmnum defaults to 3 and is  the  nu
°                                  _______
°                of  the  parameter  at input to the program block that
°                tains a pointer to the ESV.  If the FNCODE option is in
°                fect, this parameter is only referenced  on  the  "star
                call.   Parameter esvtag defaults to PWAAESV and is the
°                                  ______
°                to be generated in the PWA for a word into which  the
°                gram  block  macro  will store the address of the ESV.
°                ESV option requires the PWA and RENT options.    The  N
°                option  indicates  that  the macros should call OS serv
°                directly.

                (FNCODE,[parmnum],[startcode])×NOFNCODE:  Specifies tha
°                ________________________________________
°                function  code  is  passed  as a parameter to this prog
                Parameter parmnum defaults to 2 and is the  number  of
°                          _______
°                parameter  at  input  to  the program block that contai
                pointer to the function code.  Parameter startcode defa
°                                                         _________
°                to AL4(1) and is the value of the  startup  function  c
°                This  parameter  can be any form that is valid to the r
°                of a DC instruction.   This option  is  ignored  if  op
°                REUSPWA is not in effect.

                ID×NOID:   Specifies  that  a DC should be generated at
°                ________
°                start of the program, containing the  program  block  n
°                assembly  date,  and assembly time.  If the CPYRGHT key
°                is specified, it will also be DC'ed.

                LOADBASE×NOLOADBASE:  Specifies that program base regis
°                ____________________
°                are to be loaded.  LOADBASE  is  assumed  if  the  BASE
°                keyword is specified.

                LOCTR×NOLOCTR:   Cause  the  macros  to  generate LOCTR
°                ______________
°                structions for the program, subroutines,  and  static
°                areas  to insure proper placement.  This option must be
°                lected if the program is using PSDs and SSDs  or  LONG
°                LOADBASE.

                LONG×NOLONG:   Indicates  that  CALLSUBs  should genera
°                ____________
°                BALR (or equivalent) instead of a BAL to allow  subrout
°                to  establish  a base register.  This option is require
°                the program has any subroutines that  use  LOADBASE.
°                LOCTR option is required if this option is specified.

                MAIN×NOMAIN:  Indicates that this is a main program and
°                ____________
°                namic  storage should always be obtained if Dynamic Sto
°                Management is being used.   If  NOMAIN  is  specified,
°                storage  already  allocated  by the calling program wil
°                used if it is sufficient, otherwise extra storage  will
°                obtained.

°                                                    Chapter 15. BLOCK
¯
¸
                MODE×NOMODE:  Enables generation of AMODE and RMODE car
°                ____________

                OPTSTOR×NOOPSTOR:   Turns on storage optimization to re
°                _________________
°                the size of the load module.  If your program has  a  l
°                number of internal subroutines, this can save you a sig
°                icant  amount  of  storage,  but  will slow down subrou
°                calls slightly.   This option in only  valid  for  prog
°                with the DYN option.

        ×       (PARMS[,options...])×NOPARMS:   Indicates that this pro
°                _____________________________
°        ×       has an input parameter  list  and  therefore  register
°        ×       should be preserved during program linkage.  This optio
°        ×       also used to specify options for handling the input par
°        ×       ter  list.  Any parameter option not specified will tak
°        ×       its default, "NO" state.  The available  parameter  opt
°        ×       are:

        ×       COPY×NOCOPY:   Specifies  that  the  input  parameter
                COPY×NOCOPY:
                COPY×NOCOPY:
                COPY×NOCOPY:
°                ____________
°        ×       should be copied to the PWA.  An area large enough to
°        ×       tain  the  entire list is reserved and the entire param
°        ×       list is copied here at the start of the program.  Any m
°        ×       ing parameters (including those left off the end  of  a
°        ×       parameter  list)  will  contain an address of zero.  Us
°        ×       this option requires the PWA option.
        ×       (COPYERROR,errexit[,exitcode])×NOCOPYERROR:  Identifies
                (COPYERROR,errexit[,exitcode])×NOCOPYERROR:
                (COPYERROR,errexit[,exitcode])×NOCOPYERROR:
                (COPYERROR,errexit[,exitcode])×NOCOPYERROR:
°                ___________________________________________
°        ×       error exit and optionally an exit code that will be inv
°        ×       if the input parameter list overruns the space reserved
°        ×       it  in  the  PWA  during a (PARMS,COPY,VL) operation.
°        ×       suboption is required when  (PARMS,COPY,VL)  is  specif
        ×       If specified, exitcode is passed in the default code re
°                              ________
°        ×       ter  R14  and must follow the same restrictions as CODE
        ×       the ERREXIT macro.   If errexit  is  specified  as  a
°                                        _______
°        ×       string, e.g.  (COPYERROR,), the unnamed error exit for
°        ×       program block will be invoked in case of a copy failure
        ×       (COUNT,tag)×NOCOUNT:  Specifies that a count of the par
                (COUNT,tag)×NOCOUNT:
                (COUNT,tag)×NOCOUNT:
                (COUNT,tag)×NOCOUNT:
°                ____________________
°        ×       ters actually specified in the input parameter list be
°        ×       and  that  the result be placed in the fullword at loca
        ×       tag.  The use of this option requires the VL  suboption
°                ___
°        ×       PARMS.
        ×       PREFIX×NOPREFIX:   Specifies  that  the  tags listed in
                PREFIX×NOPREFIX:
                PREFIX×NOPREFIX:
                PREFIX×NOPREFIX:
°                ________________
°        ×       PARMS keyword for this block should be  prefixed  with
°        ×       &PPL  symbol before placing them within the PPL.  This
°        ×       all the tags within the PPL a unique prefix so  there
°        ×       not  be  any  collisions with tags within other structu
°        ×       If this option is specified, any references to tags  wi
°        ×       the  PPL  from  the  program  will  have  to  be  coded
        ×       &PPL.tag
°                     ___
        ×       (USING,reg)×NOUSING:  Specifies that reg should be used
                (USING,reg)×NOUSING:                 ___
                (USING,reg)×NOUSING:
                (USING,reg)×NOUSING:
°                ____________________
°        ×       establish  addressibility on the input parameter list.
°        ×       specified register is loaded with the contents of  regi
°        ×       one  unless  the  COPY  option is also specified.   In
        ×       case, reg will be loaded with the address of the input
°                      ___
°        ×       rameter list storage in the PWA.
¸
°          78    Structured Macros Reference
¯
¸
        ×       VL×NOVL:  Specifies that the input parameter list is a
                VL×NOVL:
                VL×NOVL:
                VL×NOVL:
°                ________
°        ×       iable  length (VL) parameter list.  For VL parameter li
°        ×       the COPY option will loop through the parameters instea
°        ×       doing a block copy.  If the COPY option is being used,
°        ×       high  order  bit  in  the last item of the copied param
°        ×       list will be cleared.

                PWA×NOPWA:  Specifies that this program will  have  a
°                __________
°                The  PWA  will be either GETMAINed or obtained from dyn
°                storage if option RENT is in effect.  If the NORENT  op
°                is  in effect, the ENDPWA macro will generate a DS inst
°                tion to reserve storage for the PWA within the CSECT.
°                PWA  and  ENDPWA macros should be used to define the li
°                of the PWA.  This option is required  if  the  program
°                subroutines that use SWAs.

                REGEQU×NOREGEQU:  Specifies that register equates are t
°                ________________
°                generated.

                RENT×NORENT:   Specifies  that the program is reentrant
°                ____________
°                that the macros should  generate  reentrant  code  wher
°                necessary.

                (REUSPWA,[parmnum])×NOREUSPWA:  Specifies that the same
°                ______________________________
°                storage  should  be  used  on multiple calls to the pro
                block.  Parameter parmnum defaults to 1 and is  the  nu
°                                  _______
°                of  the  parameter  at input to the program block that
°                tains a pointer to the PWA anchor.  If the FNCODE optio
°                in effect, the PWA is obtained and its  address  stored
°                the  anchor  on  the "startup" call.  If NOFNCODE is in
°                fect, the PWA is obtained and its address stored  when
°                anchor at entry contains binary zeros.  The PWA is free
°                the  ENDBLK  macro  when  the SMCTRL macro with FREEPWA
°                specified has been executed.   REUSPWA  requires  the
°                RENT  and  SAVE options.   NOREUSPWA indicates that the
°                should be obtained and freed each time the program bloc
°                called.

                RTNR0×NORTNR0:  Indicates  that  register  zero  should
°                ______________
°                passed  back  to  the  caller.   Use the R0= keyword on
°                ENDBLK macro for the program block and error exits to s
°                ify the value to be returned.

                RTNR1×NORTNR1:   Indicates  that  register  one  should
°                ______________
°                passed  back  to  the  caller.   Use the R1= keyword on
°                ENDBLK macro for the program block and error exits to s
°                ify the value to be returned.

                SAVE×NOSAVE:   Save  R14-R12  in  the  standard  save
°                ____________
°                pointed to by register 13.

                SAVEAREA×NOSAVEAREA:   Obtain  a  save area, do forward
°                ____________________
°                backward linking, and point R13  to  new  save  area.
°                NORENT  was  specified,  the save area will be obtained

°                                                    Chapter 15. BLOCK
¯
¸
°                line.  If RENT was specified, it will be GETMAINed  or
°                tained from the PWA.  SAVEAREA is assumed if the PWA op
°                is specified.

                VL×NOVL:   Forces  all  generated  parameter  lists (PL
°                ________
°                CALLSUB, CALLX) to default to VL unless overridden.

                XA×NOXA:   Generates  support  for  linkage  using  XA
°                ________
°                structions.   If neither XA or 370 is specified, 370 is
°                default.

                370×NO370:  Generates support for  linkage  using  370
°                __________
°                structions.    If OPTIONS=XA is also specified, OPTIONS
°                causes generation of code which determines whether the
°                gram is  running  under  MVS/XA  or  not,  and  will  c
°                branches  around XA-dependent instructions generated by
°                Structured Macros such as the amode switches.

°                If a type of regular option is specified  more  than  o
°                the last occurrence (ie. PWA or NOPWA) is used.

                Super  options:   These are provided as combinations of
                Super  options:
                Super  options:
°                Super  options:
°                most popular options.   If  one  or  more  options  is
°                needed, it should be specified as desired following the
°                per option's specification.

°                *NORENT  -  selects  options  NOPWA,  SAVE, BR14, SAVEA
°                NORENT, ID,  CSECT,  REGEQU,  LOADBASE,  MODE,  VL,  NO
°                NOMAIN,   NOLONG,   LOCTR,   NORTNR0,  NORTNR1,  NOREUS
°                NOFNCODE, NOESV, NOERRADDR and NOCLRDEBUG.

°                *RENT - selects options NOPWA, SAVE, BR14, SAVEAREA,  R
°                ID,  CSECT,  REGEQU,  LOADBASE,  MODE,  VL,  NODYN, NOM
°                NOLONG,  LOCTR,  NORTNR0,  NORTNR1,  NOREUSPWA,   NOFNC
°                NOESV, NOERRADDR and NOCLRDEBUG.

°                *PWA - selects options PWA, CLEARPWA, SAVE, BR14, SAVEA
°                RENT, ID, CSECT, REGEQU, LOADBASE, MODE, VL, NODYN, NOM
°                NOLONG,   LOCTR,  NORTNR0,  NORTNR1,  NOREUSPWA,  NOFNC
°                NOESV, NOERRADDR and NOCLRDEBUG.

°                *MAIN  -  selects  options  PWA,  CLEARPWA,   SAVE,   B
°                SAVEAREA, RENT, ID, CSECT, REGEQU, LOADBASE, MODE, VL,
°                MAIN, NOLONG, LOCTR, NORTNR0, NORTNR1, NOREUSPWA, NOFNC
°                NOESV, NOERRADDR and NOCLRDEBUG.

°                *NOMAIN  -  selects  options  PWA,  CLEARPWA,  SAVE,  B
°                SAVEAREA, RENT, ID, CSECT, REGEQU, LOADBASE, MODE, VL,
°                NOMAIN,  NOLONG,  LOCTR,   NORTNR0,   NORTNR1,   NOREUS
°                NOFNCODE, NOESV, NOERRADDR and NOCLRDEBUG.

°                *SRVPRC  -  selects  options  PWA,  CLEARPWA,  SAVE,  B
°                SAVEAREA, RENT, ID,  CSECT,  REGEQU,  LOADBASE,  MODE,
°                NO370,  VL, NODYN, NOMAIN, NOLONG, LOCTR, NORTNR0, NORT

°          80    Structured Macros Reference
¯
¸
°                (REUSPWA,1),  (FNCODE,2,AL4(1)),  (ESV,3,PWAAESV),  ERR
°                and CLRDEBUG.

          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
°          AMODE= 24 × 31 × ANY
°                Specifies  the  addressing  mode.    This keyword cause
°                AMODE card to be generated by the assembler with the sp
°                fied amode.  If this keyword is  not  specified,  no  A
°                card will be generated.

          BASEREG= reg × (reg[,reg[,...]])
          BASEREG= reg × (reg[,reg[,...]])
          BASEREG= reg × (reg[,reg[,...]])
°          BASEREG= reg × (reg[,reg[,...]])
°                Specifies  the register or registers to be used for pro
°                addressability.  The register can not be R0,  R1,  R14,
°                R15.    BASEREG will default to R13 if the NORENT optio
°                in effect and the SVAREA keyword is not  specified;  ot
°                wise, it will default to R12.

          CPYRGHT= notice
          CPYRGHT= notice
          CPYRGHT= notice
°          CPYRGHT= notice
°                Specifies  a quoted string that will be DC'ed if the ID
°                tion is in effect.

          DYNERR= name
          DYNERR= name
          DYNERR= name
°          DYNERR= name
°                Specifies the name of the dynamic storage error exit  n
°                If  DYNERR is not specified and a dynamic storage error
°                curs, an ABEND 0C1 will occur.

          DYNSIZE= [+×-]size
          DYNSIZE= [+×-]size
          DYNSIZE= [+×-]size
°          DYNSIZE= [+×-]size
°                Defines the amount of storage to be added to the PWA to
°                used  for  additional  PWAs and SWAs.   A "+" or "-" ca
°                specified to indicate that the size should be added or
°                tracted from the size calculated by the macros.    If
°                keyword is not specified, the size calculated by the ma
°                is used.

        × PARMMAP=(dsect[,len])
          PARMMAP=(dsect[,len])
          PARMMAP=(dsect[,len])
°          PARMMAP=(dsect[,len])
°        ×       Defines  the  Dsect  to  be used to map the input param
°        ×       list and its length.  This keyword can be used if the i
°        ×       parameter list is too  complicated  to  describe  with
°        ×       PARMS  keyword or if the input parameter list is a stan
        ×       form described by an existing Dsect.  len is only  requ
°                                                      ___
°        ×       if  COPY  is specified with the PARMS option.  This key
°        ×       is mutually exclusive with the PARMS keyword.

        × PARMS=(tag[,tag[,...]])
          PARMS=(tag[,tag[,...]])
          PARMS=(tag[,tag[,...]])
°          PARMS=(tag[,tag[,...]])
°        ×       Defines the tags used to  map  the  input  parameter  l
°        ×       These  will  be used to generate the Program Parameter
°        ×       (PPL) Dsect or to map the input parameter list  storage
°        ×       the  PWA  (if  parameter  option COPY was specified).
°        ×       also defines the size of the input parameter list  for
°        ×       COPY  option.   This keyword is mutually exclusive with
°        ×       PARMMAP keyword.

          PL= tag×(tag,num)
          PL= tag×(tag,num)
          PL= tag×(tag,num)
°          PL= tag×(tag,num)
°        ×       Defines the default place to build parameter  lists  ge
        ×       ated  within  this  block.    Tag defines the label for
°                                              ___

°                                                    Chapter 15. BLOCK
¯
¸
                start of parameter list storage and num is a  self-defi
°                                                    ___
°                term  that  represents the maximum number of parameter
                entries that the storage at tag will hold.   This  must
°                                            ___
°                large  enough  to contain the largest parameter list in
°                block.  If num is not specified, the tag must have a le
°                modifier that is a self-defining term.

          PWAREG= R13 × (R13,[reg[,...]])
          PWAREG= R13 × (R13,[reg[,...]])
          PWAREG= R13 × (R13,[reg[,...]])
°          PWAREG= R13 × (R13,[reg[,...]])
°                Specifies the register or registers to be used for PWA
°                dressability.

          PWASP= number × symbol
          PWASP= number × symbol
          PWASP= number × symbol
°          PWASP= number × symbol
°                Specifies  the number of the subpool in which the PWA i
°                be GETMAINed.   PWASP may  only  be  specified  on  PRO
°                blocks  with  PWA  included  among the OPTIONS. The def
°                subpool is zero.

          RMODE= 24 × ANY
          RMODE= 24 × ANY
          RMODE= 24 × ANY
°          RMODE= 24 × ANY
°                Specifies the residency mode.

          R1SAVE= register
          R1SAVE= register
          R1SAVE= register
°          R1SAVE= register
°                The number of the register that register 1 should be co
°                to.   Program linkage sometimes destroys  the  contents
°                register  1 from entry.  This keyword is useful for cop
°                the contents of the parameter register to another  regi
°                before it is destroyed.

          SMWA= address
          SMWA= address
          SMWA= address
°          SMWA= address
°                Provides the address of a Structured Macro Workarea (SM
°                The  SMWA  is a doubleword of storage which is used to
°                serve addressing mode and a work register while  perfor
°                AMODE  switching.  The SMWA keyword is valid only on a
°                GRAM block, and is  required  when  both  the  370  and
°                options  are in effect, or when AMODE=ANY is specified.
°                SMWA may reside in the PWA.   If the  program  has  a
°                space  for  the SMWA is automatically allocated in the
°                and this keyword is not necessary.

          SUBOPTS= (option,...)
          SUBOPTS= (option,...)
          SUBOPTS= (option,...)
°          SUBOPTS= (option,...)
°                Can be used to specify a default set  of  options  for
°                subroutine  blocks  associated  with  this  program.
°                options specified on subsequent subroutine blocks  will
°                in  addition to these options.  See "BLOCK TYPE=SUBROUT
°                for a description of the valid subroutine block options

          SVAREA= tag
          SVAREA= tag
          SVAREA= tag
°          SVAREA= tag
°                Can be specified if the NORENT  option  is  in  effect
°                specifies  a  relocatable  tag that will be used to add
°                the program save area.

          Errors:
          Errors:
          Errors:
°          Errors:
°                Refer to ##PPOS in "Appendix B. Internal Macros Error
°                sages" on page 123.
¸
°          82    Structured Macros Reference
¯
¸
          BLOCK TYPE=PROGRAM,ENVIRON=PLI
          BLOCK TYPE=PROGRAM,ENVIRON=PLI
          BLOCK TYPE=PROGRAM,ENVIRON=PLI
          BLOCK TYPE=PROGRAM,ENVIRON=PLI
°          ______________________________

°          The program block surrounds the main body of executable code.
°          ENVIRON=PLI  is specified, options can be specified to do var
°          initialization and termination functions specific to the OS
°          Optimizing  Compiler's  execution  time environment including
°          taining and freeing a DSA, doing register  equates  and  auto
°          ically defining a DSA within the Program Work Area.

          Keywords for program blocks with ENVIRON=PLI specified:
°          _______________________________________________________

          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
°          OPTIONS= option × (option[,option[,...]])
                Regular  options:    These are the options for individu
                Regular  options:
                Regular  options:
°                Regular  options:
°                controlling each of the BLOCK macro's functions.   The
°                fault  value for each of these options is the negative
°                (NOREGEQU, NOCSECT, etc.) but note that many of the opt
°                are included in all of the super options.

                CLEARPWA×NOCLEARPWA:  Specifies whether the PWA  should
°                ____________________
°                cleared to zeros or not.

                ID×NOID:   Specifies  that  a DC should be generated at
°                ________
°                start of the program, containing the  program  block  n
°                assembly  date,  and assembly time.  If the CPYRGHT key
°                is specified, it will also be DC'ed.

                LOCTR×NOLOCTR:  Cause the  macros  to  generate  LOCTR
°                ______________
°                structions  for  the  program, subroutines, and static
°                areas to insure proper placement.  This option must be
°                lected  if  the  program is using PSDs and SSDs or LONG
°                LOADBASE.

                LONG×NOLONG:  Indicates that  CALLSUBs  should  generat
°                ____________
°                BALR  (or equivalent) instead of a BAL to allow subrout
°                to establish a base register.  This option is  required
°                the  program  has  any  subroutines that use LOADBASE.
°                LOCTR option is required if this option is specified.

                MODE×NOMODE:  Enables generation of AMODE and RMODE car
°                ____________

                PWA:  PWA can not be specified if ENVIRON=PLI is specif
°                ____
°                but it is implied.  ENVIRON=PLI programs will  have  a
°                and can take advantage of all of a PWA's features.  The
°                will  be  obtained  in the same manner as and have the
°                format as a Dynamic Storage Area that is obtained by  P
°                The PWA and ENDPWA macros should be used to define the
°                its of the PWA.

                REGEQU×NOREGEQU:  Specifies that register equates are t
°                ________________
°                generated.
¸

°                                                    Chapter 15. BLOCK
¯
¸
                VL×NOVL:   Forces  all  generated  parameter  lists (PL
°                ________
°                CALLSUB, CALLX) to default to VL unless overridden.

                XA×NOXA:   Generates  support  for  linkage  using  XA
°                ________
°                structions.  If neither XA or 370 is specified, 370 is
°                default.

                370×NO370:   Generates  support  for  linkage using 370
°                __________
°                structions.  If OPTIONS=XA is also  specified,  OPTIONS
°                causes generation of code which determines whether the
°                gram  is  running  under  MVS/XA  or  not,  and  will c
°                branches around XA-dependent instructions generated by
°                Structured Macros such as the amode switches.

°                If  a  type  of regular option is specified more than o
°                the last occurrence (ie. REGEQU or NOREGEQU) is used.

                Super options:  These are provided as combinations  of
                Super options:
                Super options:
°                Super options:
°                most popular options. If one or more options is not nee
°                it  should  be  specified  as  desired  following the s
°                option's specification.

°                *STDPLI - selects options CLEARPWA, ID, REGEQU, MODE, N
°                NO370, VL, LOCTR, NOLONG.

          BASEREG= R11 × (R11[,reg[,...]])
          BASEREG= R11 × (R11[,reg[,...]])
          BASEREG= R11 × (R11[,reg[,...]])
°          BASEREG= R11 × (R11[,reg[,...]])
°                Specifies the register or registers to be used for  pro
°                addressability.    The  first  register must be R11 and
°                other registers can not  be  R0,  R1,  R12,  R14,  or
°                BASEREG defaults to R11.

          CPYRGHT= notice
          CPYRGHT= notice
          CPYRGHT= notice
°          CPYRGHT= notice
°                Specifies  a quoted string that will be DC'ed if the ID
°                tion is in effect.

          PL= tag×(tag,num)
          PL= tag×(tag,num)
          PL= tag×(tag,num)
°          PL= tag×(tag,num)
°        ×       Defines the default place to build parameter  lists  ge
°        ×       ated  within this block.  If this keyword is not specif
°                the correct amount of storage  will  automatically  be
                served  and used in the PWA.  Tag defines the label for
°                                              ___
                start of parameter list storage and num is a  self-defi
°                                                    ___
°                term  that  represents the maximum number of parameter
                entries that the storage at tag will hold.   This  must
°                                            ___
°                large  enough  to contain the largest parameter list in
°                block.  If num is not specified, the tag must have a le
°                modifier that is a self-defining term.

          PWAREG= R13 × (R13,[reg[,...]])
          PWAREG= R13 × (R13,[reg[,...]])
          PWAREG= R13 × (R13,[reg[,...]])
°          PWAREG= R13 × (R13,[reg[,...]])
°                Specifies the register or registers to be used for PWA
°                dressability.

          RMODE= 24 × ANY
          RMODE= 24 × ANY
          RMODE= 24 × ANY
°          RMODE= 24 × ANY
°                Specifies the residency mode.
¸
°          84    Structured Macros Reference
¯
¸
          SUBOPTS= (option,...)
          SUBOPTS= (option,...)
          SUBOPTS= (option,...)
°          SUBOPTS= (option,...)
°                Can  be  used  to  specify a default set of options for
°                subroutine  blocks  associated  with  this  program.
°                options  specified  on subsequent subroutine blocks wil
°                in  addition to these options.  See "BLOCK TYPE=SUBROUT
°                for a description of the valid subroutine block options

          Errors:
          Errors:
          Errors:
°          Errors:
°                Refer to ##PPPLI in "Appendix B. Internal Macros Error
°                sages" on page 123.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°                                                    Chapter 15. BLOCK
¯
¸
          BLOCK TYPE=SUBROUTINE
          BLOCK TYPE=SUBROUTINE
          BLOCK TYPE=SUBROUTINE
          BLOCK TYPE=SUBROUTINE
°          _____________________

°          The  subroutine  block  contains  code  that  is  reached via
°          CALLSUB macro.  This block must be at block level zero.   Sub
°          tine  blocks are meant for internal subroutines, not for a ca
°          program that follows standard OS linkage conventions.

          Keywords for subroutine blocks:
°          _______________________________

          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
          OPTIONS= option × (option[,option[,...]])
°          OPTIONS= option × (option[,option[,...]])
                Regular options:  These are the  options  for  individu
                Regular options:
                Regular options:
°                Regular options:
°                controlling  each  of the BLOCK macro's functions.  The
°                fault value for each of these options is the negative
°                (NOSWA, NOCUSTOM, etc.).

                CUSTOM×NOCUSTOM:  Specifies that the return instruction
°                ________________
°                the  end  of  the subroutine block should not be genera
°                This option should be used if you are going to  handle
°                of  the linkage details yourself.  If this option is sp
°                fied, no other option or keywords on the  subroutine  b
°                can be specified.

                LOADBASE×NOLOADBASE:   Indicates  that  a base register
°                ____________________
°                registers) should be loaded to establish separate  addr
°                ability  to  this subroutine.  The program base registe
°                left  intact  providing  addressability  to  the  progr
°                static data.

        ×       (PARMS[,options...])×NOPARMS:   Indicates that this sub
°                _____________________________
°        ×       tine has an input parameter list and therefore register
°        ×       should be preserved during subroutine linkage.  This op
°        ×       is also used to specify options for handling the input
°        ×       rameter list.  Any parameter option not specified will
°        ×       on  its  default,  "NO"  state.    The  available param
°        ×       options are:

        ×       COPY×NOCOPY:   Specifies  that  the  input  parameter
                COPY×NOCOPY:
                COPY×NOCOPY:
                COPY×NOCOPY:
°                ____________
°        ×       should  be copied to the SWA.  An area large enough to
°        ×       tain the entire list is reserved and the  entire  param
°        ×       list  is  copied  here at the start of the subroutine.
°        ×       missing parameters (including those left off the end  o
°        ×       VL parameter list) will contain an address of zero.  Us
°        ×       this option requires the SWA option.
        ×       PREFIX×NOPREFIX:   Specifies  that  the  tags listed in
                PREFIX×NOPREFIX:
                PREFIX×NOPREFIX:
                PREFIX×NOPREFIX:
°                ________________
°        ×       PARMS keyword for this block should be  prefixed  with
°        ×       &SPL  symbol before placing them within the SPL.  This
°        ×       all the tags within the SPL a unique prefix so  there
°        ×       not  be  any  collisions with tags within other structu
°        ×       If this option is specified, any references to tags  wi
°        ×       the  SPL  from  the  subroutine  will  have to be coded
        ×       &SPL.tag or &P.tag.
°                     ___       ___
¸
°          86    Structured Macros Reference
¯
¸
        ×       (USING,reg)×NOUSING:  Specifies that reg should be used
                (USING,reg)×NOUSING:                 ___
                (USING,reg)×NOUSING:
                (USING,reg)×NOUSING:
°                ____________________
°        ×       establish  addressibility on the input parameter list.
°        ×       specified register is loaded with the contents of  regi
°        ×       one  unless  the  COPY  option is also specified.   In
        ×       case,  reg will be loaded with the address of the input
°                       ___
°        ×       rameter list storage in the SWA.
        ×       VL×NOVL:  Specifies that the input parameter list is a
                VL×NOVL:
                VL×NOVL:
                VL×NOVL:
°                ________
°        ×       iable length (VL) parameter list.  For VL parameter  li
°        ×       the COPY option will loop through the parameters instea
°        ×       doing  a block copy.  If the COPY option is being used,
°        ×       high order bit in the last item  of  the  copied  param
°        ×       list will be cleared.

                SAVEUSING×NOSAVEUSING:    Specifies  that  a  "PUSH  US
°                ______________________
°                should be done before the  subroutine  and  a  "POP  US
°                should be done after to save and restore the USING envi
°                ment around the subroutine.  This isolates any changes
°                to the USING environment in the subroutine from the res
°                the program.

                SWA×NOSWA:  Specifies that this subroutine has an SWA.
°                __________
°                PWA  option  must be specified on the program block opt
°                to use this option.  The SWA will be obtained  out  of
°                namic  storage  if the DYN option is being used, otherw
°                it is allocated within the program's PWA.  R0-R14 are a
°                matically saved and restored if this option  is  specif
°                This option can not be used with the SAVE= keyword.

                Super  options:   These are provided as combinations of
                Super  options:
                Super  options:
°                Super  options:
°                most popular options. If one or more options is not nee
°                it should be  specified  as  desired  following  the  s
°                option's specification.

°                *SWA - selects options SWA, SAVEUSING

°                *NOSUBOPTS    -   selects   options   NOSWA,   NOSAVEUS
°        ×       NOLOADBASE, NOCUSTOM, NOPARMS

          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
          AMODE= 24 × 31 × ANY
°          AMODE= 24 × 31 × ANY
°                Specifies the addressing mode  the  block  should  run
°                Amode  switching  code  will be generated if required.
°                default is AMODE=ANY which specifies  that  the  subrou
°                will run in the amode of its caller.

                Restriction:  AMODE 24 or 31 must be specified on a sub
                Restriction:
                Restriction:
°                Restriction:
°                tine block if it contains inline blocks with AMODE 24 o
°                specified.

          BASEREG= reg×(reg,...)
          BASEREG= reg×(reg,...)
          BASEREG= reg×(reg,...)
°          BASEREG= reg×(reg,...)
°                Defines  the  base  register(s) to be used to establish
°                dressability to this subroutine.   If this keyword  is
°                specified,  register 10 is used.  The register(s) speci
°                with this keyword are only used when LOADBASE is in eff
¸
°                                                    Chapter 15. BLOCK
¯
¸
        × PARMMAP=(dsect[,len])
          PARMMAP=(dsect[,len])
          PARMMAP=(dsect[,len])
°          PARMMAP=(dsect[,len])
°        ×       Defines the Dsect to be used to  map  the  input  param
°        ×       list and its length.  This keyword can be used if the i
°        ×       parameter  list  is  too  complicated  to describe with
°        ×       PARMS  keyword or if the input parameter list is a stan
        ×       form described by an existing Dsect.  len is only  requ
°                                                      ___
°        ×       if  COPY  is specified with the PARMS option.  This key
°        ×       is mutually exclusive with the PARMS keyword.

        × PARMS=(tag[,tag[,...]])
          PARMS=(tag[,tag[,...]])
          PARMS=(tag[,tag[,...]])
°          PARMS=(tag[,tag[,...]])
°        ×       Defines the tags used to  map  the  input  parameter  l
°        ×       These  will  be  used  to generate the Subroutine Param
°        ×       List (SPL) Dsect or to map the input parameter list sto
°        ×       in the SWA (if parameter option COPY was specified).
°        ×       also  defines  the size of the input parameter list for
°        ×       COPY option.  This keyword is mutually exclusive  with
°        ×       PARMMAP keyword.

          PL= tag×(tag,num)
          PL= tag×(tag,num)
          PL= tag×(tag,num)
°          PL= tag×(tag,num)
°        ×       Defines  the  default place to build parameter lists ge
        ×       ated within this block.   Tag defines  the  label  for
°                                          ___
                start  of parameter list storage and num is a self-defi
°                                                     ___
°                term that represents the maximum number of  parameter
                entries  that  the  storage at tag will hold.  This mus
°                                               ___
°                large enough to contain the largest parameter list  in
°                block.  If num is not specified, the tag must have a le
°                modifier that is a self-defining term.

          RECUR= number
          RECUR= number
          RECUR= number
°          RECUR= number
°                Specifies  the  maximum number of times the subroutine
°                be called recursively.   This is used  in  Dynamic  Sto
°                Management  to  calculate  the  amount  of space needed
                SWAs.  Number should be a self-defining term.
°                       ______

          SAVE= (r1[,r2],address)
          SAVE= (r1[,r2],address)
          SAVE= (r1[,r2],address)
°          SAVE= (r1[,r2],address)
°                Requests that the register(s) named should be saved and
                stored.   The address operand provides  the  address  o
°                              _______
°                place to save the register(s). If more than one registe
°                specified,  a  "STM"  instruction  is generated: theref
°                specification of something like "R14,R12,address" is va
°                The SAVE keyword may be used on subroutine blocks  to
°                serve some or all registers without requiring a standar
°                save  area.    The  SAVE  operand  is  not valid on pro
°                blocks, and should not be confused with OPTIONS=SAVE.

          SWAREG= R11×(R11,reg...)
          SWAREG= R11×(R11,reg...)
          SWAREG= R11×(R11,reg...)
°          SWAREG= R11×(R11,reg...)
°                Specifies the register or registers to be used for SWA
°                dressability.   The register(s) specified with this key
°                are only used when DYN is in effect.

          Errors:
          Errors:
          Errors:
°          Errors:
°                Refer to "Appendix B. Internal Macros  Error  Messages"
°                page 123 for macros that start with "##SP".
¸
°          88    Structured Macros Reference
¯
¸
                                                        CHAPTER 16. CAL
                                                        CHAPTER 16. CAL
                                                        CHAPTER 16. CAL
                                                        CHAPTER 16. CAL
°                                                        _______________
¸
          Macro:    CALLSUB
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used to call an internal subroutine with lin
          Abstract:
          Abstract:
°          Abstract:
°                    provided by the Structured Macros.   A  parameter
°                    can be created for the call and its address loaded
°                    register  one,  or  register one can be loaded with
°                    address of a previously created list.

          Syntax:   CALLSUB name[,(parms)][,VL×NOVL][,PL=tag×(tag,num)]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Specifies the name of the internal subroutine
°                    ____
°                          be  called.    The  call is performed with a
                          R14,name" or equivalent instruction.  If the
°                              ____
°                          gram block option LONG has been selected, a
°                          R14,R15"  is generated destroying the content
°                          register 15.   The contents of  register  15
°                          also destroyed if DYN is used.

                    parms A  list  of  the parameters to be included in
°                    _____
°                          parameter list that the subroutine will be ca
°                          with.   A missing parameter  causes  zero  to
°                          filled  in  for the parameter address.  An *
°                          cause the macro to skip over that parameter,
°                          serving  the  space in the parameter list but
°        ×                 modifying the data there.  An * before a tag
°        ×                 cause the macro to load the parameter  list
°        ×                 the contents of the storage referenced by the
°        ×                 instead of the address of the tag.  This prov
°        ×                 a form of indirect addressing.  Numeric and c
°                          acter  constants  can  be  coded and will be
°                          verted  to  fullword   and   character   lite
                          respectively.    If parms is missing, the CAL
°                                              _____
°                          macro will simply load register one with the
°                          dress specified by PL=.

                    VL×NOVL VL specifies that this is a variable length
°                    _______
°                          rameter  list  and  therefore the high bit of
°                          last address in the list should be  set  to
°                          NOVL  says  to not set the bit.  NOVL is norm
°                          the default, but all of the super options  es
°                          lish  VL  as  the  default  so that NOVL migh
°                          needed in certain cases.

                    tag   Specifies the address of the  parameter  list
°                    ___
°                          used  for  the call to this subroutine.  Regi
                          one will be loaded with the address of tag be
°                                                                 ___
°                          the subroutine is entered.  If a  parameter
                          is  being  created  for this subroutine, tag
°                                                                   ___

°                                                  Chapter 16. CALLSUB
¯
¸
°                          specifies where to build it.  If the PL=  key
°                          is not specified, the parameter list will be
°                          ated in the default parameter list storage es
°                          lished  by an enclosing BLOCK macro, or in PW
°                          SWA storage if no other default was set up.

                    num   Specifies the maximum number  of  the  parame
°                    ___
                          that  the storage at tag can accommodate.  If
°                                               ___
°                          has a length attribute that  is  a  self-defi
°                          term,  this  operand  is not necessary.   Thi
°                          used to insure that the specified parameter
                          will fit into the storage at tag.
°                                                       ___

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Can not CALLSUB program block or subroutine in
°                        vious program block
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          90    Structured Macros Reference
¯
¸
                                                          CHAPTER 17. C
                                                          CHAPTER 17. C
                                                          CHAPTER 17. C
                                                          CHAPTER 17. C
°                                                          _____________
¸
          Macro:    CALLX
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to call an external subroutine with stan
          Abstract:
          Abstract:
°          Abstract:
°                    OS  linkage.    A parameter list can be created for
°                    call and its address loaded into register one, or
°                    ister  one  can  be loaded with the address of a pr
°                    ously created list.

          Syntax:   CALLX addr[,(parms)][,VL×NOVL][,PL=tag×(tag,num)]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    addr  Specifies the address of the external subrout
°                    ____
°                          This   address    can    be    of    the    f
                          (R15)×=V(name)×tag.  If the tag form is used,
                          (R15)×=V(name)×tag          ___
                          (R15)×=V(name)×tag
°                          (R15)×=V(name)×tag
°                          should  be  the  label  of the address of the
°                          ternal subroutine.  The call is performed wit
°                          BALR R14,R15 or equivalent instruction.

                    parms A  list  of  the parameters to be included in
°                    _____
°                          parameter list that the subroutine will be ca
°                          with.   A missing parameter  causes  zero  to
°                          filled  in  for the parameter address.  An *
°                          cause the macro to skip over that parameter,
°                          serving  the  space in the parameter list but
°        ×                 modifying the data there.  An * before a tag
°        ×                 cause the macro to load the parameter  list
°        ×                 the contents of the storage referenced by the
°        ×                 instead of the address of the tag.  This prov
°        ×                 a form of indirect addressing.  Numeric and c
°                          acter  constants  can  be  coded and will be
°                          verted  to  fullword   and   character   lite
                          respectively.    If  parms  is missing, the C
°                                               _____
°                          macro will simply load register one with the
°                          dress specified by PL=.

                    VL×NOVL VL specifies that this is a variable length
°                    _______
°                          rameter  list  and  therefore the high bit of
°                          last address in the list should be  set  to
°                          NOVL  says  to not set the bit.  NOVL is norm
°                          the default, but all of the super options  es
°                          lish  VL  as  the  default  so that NOVL migh
°                          needed in certain cases.

                    tag   Specifies the address of the  parameter  list
°                    ___
°                          used  for  the call to this subroutine.  Regi
                          one will be loaded with the address of tag be
°                                                                 ___
°                          the subroutine is entered.  If a  parameter
                          is  being  created  for this subroutine, tag
°                                                                   ___
°                          specifies where to build it.  If the PL=  key

°                                                    Chapter 17. CALLX
¯
¸
°                          is not specified, the parameter list will be
°                          ated in the default parameter list storage es
°                          lished  by an enclosing BLOCK macro, or in PW
°                          SWA storage if no other default was set up.

                    num   Specifies  the  maximum number of parameters
°                    ___
                          the storage at tag can accommodate.  If tag h
°                                         ___                      ___
°                          length attribute that is  a  self-defining  t
°                          this  operand  is not necessary.  This is use
°                          insure that the specified parameter list will
                          in the storage at tag.
°                                            ___

          Errors:   None
          Errors:
          Errors:
°          Errors:
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          92    Structured Macros Reference
¯
¸
                                                           CHAPTER 18.
                                                           CHAPTER 18.
                                                           CHAPTER 18.
                                                           CHAPTER 18.
°                                                           ____________
¸
          Macro:    CASE
          Macro:
          Macro:
°          Macro:

          Abstract: Structured  macro  used to start the code for a par
          Abstract:
          Abstract:
°          Abstract:
°                    ular case within a case block.    This  macro  must
°                    coded  between  a  CASEBLK and ENDCASE macro.  The
°                    macro is always associated with the innermost CASEB

          Syntax:   CASE n[,n[,...]]×OTHER[,CASEBLK=name]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    n     Specifies the case number or numbers  whose
°                    _
°                          follows  the case statement.  OTHER indicates
°                          cases not associated with a particular case.
°                          case number can not  be  larger  than  the  M
°                          value on the associated CASEBLK macro times 1

                    name  Name specified on the associated CASEBLK macr
°                    ____

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   CASE <casenumber> already used
°                    ø   No operand was specified on CASE statement
°                    ø   OTHER has already been specified in this CASEBL
°                    ø   CASE is not numeric
°                    ø   CASE number can not be larger then 'MULT' * 100
°                    ø   CASE number must be a multiple of 'MULT'
°                    ø   CASEBLK= does not match CASE name
°                    ø   CASE  macro  is  not  at same structural level
°                        CASEBLK macro
¸
¸
¸
¸
¸
¸
¸

°                                                     Chapter 18. CASE
¯
¸
          CHAPTER 19. CASEBLK
          CHAPTER 19. CASEBLK
          CHAPTER 19. CASEBLK
          CHAPTER 19. CASEBLK
°          ___________________
¸
          Macro:    CASEBLK
          Macro:
          Macro:
°          Macro:

          Abstract: Structured  macro  used  to  start a case block.
          Abstract:
          Abstract:
°          Abstract:
°                    blocks can be nested up to twenty deep.

          Syntax:   CASEBLK REG=reg[,WREG=wreg][,MULT=1×2×4×8][,NAME=na
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    reg   Specifies the register  that  contains  the
°                    ___
°                          number.

                    wreg  Specifies  the  register  that  CASEBLK  can
°                    ____
°                          internally as a work register for address  ca
°                          lations.   If WREG= is not specified, the REG
°                          used as a work register.  This destroys the
°                          tents  of  REG.    The work register can neve
°                          register 0.

                    mult  This keyword specifies that all the case  num
°                    ____
°                          on  the  associated CASE macros are a multipl
°                          1, 2, 4, or 8.  1 is the default.

                    name  Specifies the name of the case block.
°                    ____

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Invalid MULT= specified. Must be 1, 2, 4, or 8.
°                    ø   CASEBLK can not be nested more than 20 deep
°                    ø   REG= must be specified
¸
¸
¸
¸
¸
¸
¸

°          94    Structured Macros Reference
¯
¸
        ×                                              CHAPTER 20. DEFU
                                                       CHAPTER 20. DEFU
                                                       CHAPTER 20. DEFU
                                                       CHAPTER 20. DEFU
°                                                       ________________
¸
        × Macro:    DEFUCOND
          Macro:
          Macro:
°          Macro:

        × Abstract: Structured macro used to define the name of a user
          Abstract:
          Abstract:
°          Abstract:
°        ×           dition  and  identify  the  macro that will process
°        ×           With DEFUCOND the programmer can add special case
°        ×           ditions to the list of standard conditions availabl
°        ×           conditional  expressions.  For information on writi
°        ×           user condition macro, see "User-Defined Conditions"
°        ×           page 7.

        × Syntax:   DEFUCOND NAME=name,MACRO=macro
          Syntax:
          Syntax:
°          Syntax:

        × Operands:
          Operands:
          Operands:
°          Operands:

        ×           name  Name  of  the user condition being defined.
°                    ____
°        ×                 name will be used in conditional  expressions
°        ×                 invoke this condition.

        ×           macro Name  of  the  macro that will perform this u
°                    _____
°        ×                 defined conditional test.  This macro will be
°        ×                 voked  by  the  Structured  Macros   whenever
°        ×                 conditional  expression  is encountered that
°        ×                 tains the named condition.

        × Errors:
          Errors:
          Errors:
°          Errors:

°        ×           ø   NAME= must be specified
°        ×           ø   MACRO= must be specified
¸
¸
¸
¸
¸
¸
¸
¸
°                                                 Chapter 20. DEFUCOND
¯
¸
          CHAPTER 21. ELSE
          CHAPTER 21. ELSE
          CHAPTER 21. ELSE
          CHAPTER 21. ELSE
°          ________________
¸
          Macro:    ELSE
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to start the else code for an
          Abstract:
          Abstract:
°          Abstract:
°                    sociated  IF  or ELSEIF macro.  An ELSE macro is al
°                    associated with the innermost IF structure.

          Syntax:   ELSE [IF=name]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name of associated IF macro.
°                    ____

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   IF nesting level is zero
°                    ø   ELSE already encountered for this IF
°                    ø   NAME= does not match corresponding IF
°                    ø   ELSE structural level is not the same as the co
°                        sponding IF
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°          96    Structured Macros Reference
¯
¸
                                                         CHAPTER 22. EL
                                                         CHAPTER 22. EL
                                                         CHAPTER 22. EL
                                                         CHAPTER 22. EL
°                                                         ______________
¸
          Macro:    ELSEIF
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to start the else code for an
          Abstract:
          Abstract:
°          Abstract:
°                    sociated IF or ELSEIF macro.  An ELSEIF macro is al
°                    associated  with the innermost IF structure.  An EL
°                    is like an ELSE macro followed by an  IF  macro  ex
°                    that the IF nesting level stays the same.

          Syntax:   ELSEIF cond[,THEN][,IF=name]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    cond  Conditional  expression.  (See "Chapter 2. Co
°                    ____
°                          tional Statements" on page 4.)

                    name  Name on associated IF macro.
°                    ____

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   ELSEIF must be contained in IF structure
°                    ø   ELSE for this IF precedes ELSEIF
°                    ø   IF= does not match corresponding IF
°                    ø   ELSEIF structural level is not the same  as  co
°                        sponding IF
°                    ø   Refer  to  "Appendix  B. Internal Macros Error
°                        sages" on page 123, for possible condition erro
¸
¸
¸
¸
¸
¸
¸
¸

°                                                   Chapter 22. ELSEIF
¯
¸
          CHAPTER 23. ENDBLK
          CHAPTER 23. ENDBLK
          CHAPTER 23. ENDBLK
          CHAPTER 23. ENDBLK
°          __________________
¸
          Macro:    ENDBLK
          Macro:
          Macro:
°          Macro:

          Abstract: Structured  macro used to end a block structure.  R
          Abstract:
          Abstract:
°          Abstract:
°                    to the description of the BLOCK macro for more info
°                    tion.

          Syntax:   ENDBLK [BLOCK=name][,RC=rc][,R0=r0][,R1=r1]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name on associated BLOCK macro.
°                    ____

                    rc    Return code.  The return code can be specifie
°                    __
°                          a symbol or (Rn) where n is the number of a
°                          ister.   The default for RC is (R15).  RC= is
°                          nored on the ENDBLK macro of a program block
°                          is using the PLI environment.

                    r0    Value to be returned  in  register  zero.
°                    __
°                          keyword requires the RTNR0 option to be in ef
°                          and  is  only  valid  on the ENDBLK for a pro
°                          block and its error exits.   This  value  can
°                          specified as a symbol or (Rn) where n is the
°                          ber of a register.  The default for R0 is (R0

                    r1    Value  to  be  returned  in  register one.
°                    __
°                          keyword requires the RTNR1 option to be in ef
°                          and is only valid on the  ENDBLK  for  a  pro
°                          block  and  its  error exits.   This value ca
°                          specified as a symbol or (Rn) where n is the
°                          ber of a register.  The default for R1 is (R1

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   <RC> invalid on RC=
°                    ø   Block nesting level is already zero
°                    ø   BLOCK= does not match current block
°                    ø   Structural nesting level does not  match  level
°                        entry to corresponding block
°                    ø   Refer  to  "Appendix  B. Internal Macros Error
°                        sages" on page  123  for  macros  that  start
°                        "##EE", "##IE", "##PE" or "##SE" for other poss
°                        errors.
¸
¸
¸
°          98    Structured Macros Reference
¯
¸
                                                        CHAPTER 24. END
                                                        CHAPTER 24. END
                                                        CHAPTER 24. END
                                                        CHAPTER 24. END
°                                                        _______________
¸
          Macro:    ENDCASE
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to end a case block structure
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   ENDCASE [CASEBLK=name]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name on associated CASEBLK macro.
°                    ____

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   CASEBLK nesting level is zero
°                    ø   CASEBLK= does not match CASE name
°                    ø   Structural  nesting  level  of ENDCASE is diffe
°                        than corresponding CASEBLK macro
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°                                                  Chapter 24. ENDCASE
¯
¸
          CHAPTER 25. ENDIF
          CHAPTER 25. ENDIF
          CHAPTER 25. ENDIF
          CHAPTER 25. ENDIF
°          _________________
¸
          Macro:    ENDIF
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to end an IF structure.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   ENDIF [IF=name]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name on associated IF macro.
°                    ____

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   IF nesting level is zero
°                    ø   IF= does not match corresponding IF
°                    ø   ENDIF  is  not  at  same structural level as co
°                        sponding IF
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°          100    Structured Macros Reference
¯
¸
                                                        CHAPTER 26. END
                                                        CHAPTER 26. END
                                                        CHAPTER 26. END
                                                        CHAPTER 26. END
°                                                        _______________
¸
          Macro:    ENDLOOP
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to end a LOOP structure.  See
          Abstract:
          Abstract:
°          Abstract:
°                    LOOP macro for more information.

          Syntax:   ENDLOOP [LOOP=name,]
          Syntax:
          Syntax:
°          Syntax:
°                                WHILE          ×
°                                UNTIL,cond     ×
°                                UNTIL,LEAVE    ×
°                                BCT,reg        ×
°                                BXH            ×
°                                BXLE,reg,reg

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name on associated LOOP macro.
°                    ____

                    cond  Conditional  expression.  (See "Chapter 2. Co
°                    ____
°                          tional Statements" on page 4.)

                    reg   Register to be used on associated instruction
°                    ___

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Additional positional parameters can not be  sp
°                        fied on ENDLOOP <type>
°                    ø   Nesting level for loops is 0
°                    ø   LOOP= does not match corresponding LOOP
°                    ø   <type> does not match type on corresponding LOO
°                    ø   Incorrect   number   of  parameters  specified
°                        ENDLOOP <type>
°                    ø   LOOP type <type> is invalid
°                    ø   Incorrect number of parameters specified on END
°                        UNTIL,LEAVE
°                    ø   ENDLOOP structural level is not  the  same  as
°                        corresponding LOOP
°                    ø   Refer  to  "Appendix  B. Internal Macros Error
°                        sages" on page 123, for possible condition erro
¸
¸
¸
¸

°                                                 Chapter 26. ENDLOOP
¯
¸
          CHAPTER 27. ENDPSD
          CHAPTER 27. ENDPSD
          CHAPTER 27. ENDPSD
          CHAPTER 27. ENDPSD
°          __________________
¸
          Macro:    ENDPSD
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to define the end of the Program Static
          Abstract:
          Abstract:
°          Abstract:
°                    (PSD).  The ENDPSD macro is used to close either a
°                    tial  PSD  within  the program code, or the last PS
°                    the end of the program.

          Syntax:   ENDPSD
          Syntax:
          Syntax:
°          Syntax:

          Operands: None
          Operands:
          Operands:
°          Operands:

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   ENDPSD does not correspond to a PSD
°                    ø   ENDPSD is not at the same nesting level as PSD
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          102    Structured Macros Reference
¯
¸
                                                         CHAPTER 28. EN
                                                         CHAPTER 28. EN
                                                         CHAPTER 28. EN
                                                         CHAPTER 28. EN
°                                                         ______________
¸
          Macro:    ENDPWA
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to define the end of the Program Work
          Abstract:
          Abstract:
°          Abstract:
°                    (PWA) or to close a partial PWA.  The ENDPWA macro
°                    define the PWAPLLEN tag to establish the length of
°                    PWA.    Also,  if  the DYN option is being used, EN
°                    will use the ##ORGS macro  to  reserve  space  for
°                    SWAs.   If option NORENT is in effect, a DS instruc
°                    is generated to reserve storage in the  CSECT  for
°                    PWA.

          Syntax:   ENDPWA
          Syntax:
          Syntax:
°          Syntax:

          Operands: None
          Operands:
          Operands:
°          Operands:

          Errors:   None
          Errors:
          Errors:
°          Errors:
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°                                                  Chapter 28. ENDPWA
¯
¸
          CHAPTER 29. ENDSSD
          CHAPTER 29. ENDSSD
          CHAPTER 29. ENDSSD
          CHAPTER 29. ENDSSD
°          __________________
¸
          Macro:    ENDSSD
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to define the end of the Subroutine St
          Abstract:
          Abstract:
°          Abstract:
°                    Data (SSD).  The ENDSSD macro is used to close eith
°                    partial SSD within the subroutine code, or the last
°                    at the end of the subroutine.

          Syntax:   ENDSSD
          Syntax:
          Syntax:
°          Syntax:

          Operands: None
          Operands:
          Operands:
°          Operands:

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   ENDSSD does not correspond to a SSD
°                    ø   ENDSSD is not at the same nesting level as SSD
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          104    Structured Macros Reference
¯
¸
                                                         CHAPTER 30. EN
                                                         CHAPTER 30. EN
                                                         CHAPTER 30. EN
                                                         CHAPTER 30. EN
°                                                         ______________
¸
          Macro:    ENDSWA
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to  define  the end of the Subroutine
          Abstract:
          Abstract:
°          Abstract:
°                    Area (SWA).  It is also used to end a partial SWA d
°                    nition.  The ENDSWA macro will establish the length
°                    the  SWA for Dynamic Storage calculations.  ENDSWA
°                    insures double word alignment for  anything  that
°                    follow the SWA.

          Syntax:   ENDSWA
          Syntax:
          Syntax:
°          Syntax:

          Operands: None
          Operands:
          Operands:
°          Operands:

          Errors:   None
          Errors:
          Errors:
°          Errors:
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°                                                  Chapter 30. ENDSWA
¯
¸
          CHAPTER 31. ERREXIT
          CHAPTER 31. ERREXIT
          CHAPTER 31. ERREXIT
          CHAPTER 31. ERREXIT
°          ___________________
¸
          Macro:    ERREXIT
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to conditionally cause an err
          Abstract:
          Abstract:
°          Abstract:
°                    block to be executed.

          Syntax:   ERREXIT [cond][,CODE=code][,CODEREG=reg][,NAME=name
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name of errexit block to execute.  If the nam
°                    ____
°                          omitted the unnamed error exit block for the
°                          gram is executed.

                    code  Symbol  representing  a value from 0 to 4095.
°                    ____
°                          specified, this code will be passed to the  e
°                          exit block in the CODEREG= register.

                    reg   Register  used  for  passing error code.  The
°                    ___
°                          fault is R14.

                    cond  Conditional expression. (See "Chapter  2.  Co
°                    ____
°                          tional Statements" on page 4.)  If the expres
°                          is  true,  the  error  exit is taken.   If an
°                          pression is not specified, the error exit is
°                          ways taken.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Refer  to  "Appendix  B. Internal Macros Error
°                        sages" on page 123, for possible condition erro
¸
¸
¸
¸
¸
¸
¸

°          106    Structured Macros Reference
¯
¸
                                                            CHAPTER 32.
                                                            CHAPTER 32.
                                                            CHAPTER 32.
                                                            CHAPTER 32.
°                                                            ___________
¸
          Macro:    EXI
          Macro:
          Macro:
°          Macro:

          Abstract: This  is  the  EXecute Immediate macro.   It is use
          Abstract:
          Abstract:
°          Abstract:
°                    generate an EX instruction and the  instruction  to
°                    executed.  This allows the EXecuted statement to be
°                    fined  at  the same time the EX instruction is defi
°                    minimizing confusion.  It also insures that  the  U
°                    environment  is the same as that of the EX instruct
°                    The EXecuted instruction will be generated in  the
°                    for  the  program (or SSD for a subroutine) if the
°                    gram has selected option LOCTR.  Otherwise, it will
°                    generated inline with a branch around it.

          Syntax:   EXI reg,(opcode,op1[,op2[,op3]])
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    reg   Specifies  the  register to be used in the EX
°                    ___
°                          struction.

                    opcode Defines the opcode to be used for  the  EXec
°                    ______
°                          instruction.

                    op1-3 Defines  the  operands  for the EXecuted inst
°                    _____
°                          tion.  There can be one, two, or three operan

          Errors:   None
          Errors:
          Errors:
°          Errors:
¸
¸
¸
¸
¸
¸
¸
¸

°                                                     Chapter 32. EXI
¯
¸
          CHAPTER 33. FILL
          CHAPTER 33. FILL
          CHAPTER 33. FILL
          CHAPTER 33. FILL
°          ________________
¸
          Macro:    FILL
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to fill an area of storage with a charac
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   FILL op1[,op2][,LENGTH=len×(len,type)]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    op1   Provides  the  starting address of the storag
°                    ___
°                          be cleared.  May be given as an RX-type addre

                    op2   Provides a byte other  than  X'00'  to  propa
°                    ___
°                          through the storage to be cleared.  May be sp
°                          fied  in  X'nn' or C'c' form (suitable for us
°                          MVI).  If not specified, X'00' is assumed.

                    len   Provides the length of the  storage  area  to
°                    ___
°                          cleared.    May  be  a  numeric value, a cons
°                          value or a register specification.   The  def
°                          is (L'op1,SHORT).

                    type  Specifies  the  type  of clearing operation t
°                    ____
°                          performed: e.g.  "short", "medium" or "long".

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   FILL  operation  type  invalid:  Must  be   S)h
°                        M)edium, or L)ong
°                    ø   Long form FILL requires R-Form length
°                    ø   Length for FILL required but not specified
°                    ø   Unable to parse FILL destination

          Caution:  If  a  tag  is  defined  in a macro, FILL does not
          Caution:
          Caution:
°          Caution:
                    L'tag resolved for it and gets an assembly error.
°                      ___
°                    correct this, you can code:

°                       FILL  tag,X'00',LENGTH=L'tag
¸
¸
¸
¸
¸
°          108    Structured Macros Reference
¯
¸
                                                           CHAPTER 34.
                                                           CHAPTER 34.
                                                           CHAPTER 34.
                                                           CHAPTER 34.
°                                                           ____________
¸
          Macro:    IBIT
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to invert bit flags in a byte.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   IBIT [byte,]flag×(flag[,flag[,...]])
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    byte  Byte  that  contains  bit(s) to be inverted.
°                    ____
°                          this operand is omitted,  the name of the byt
°                          assumed to be the first five  characters  of
°                          first flag name.

                    flag  Byte  mask  with a binary one in the bit posi
°                    ____
°                          of the mask that corresponds to the bit to be
°                          verted in the byte.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   No more than eight flags can be specified
°                    ø   IBIT macro can have no more than two operands
°                    ø   If byte is not specified,  flag  name  must  be
°                        least six characters long
°                    ø   If byte is not specified, the first five charac
°                        of all flags must match
¸
¸
¸
¸
¸
¸
¸
¸
¸
°                                                    Chapter 34. IBIT
¯
¸
          CHAPTER 35. IF
          CHAPTER 35. IF
          CHAPTER 35. IF
          CHAPTER 35. IF
°          ______________
¸
          Macro:    IF
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to start an IF structure.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   IF cond[,THEN][,NAME=name]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name to be associated with IF structure.
°                    ____

                    cond  Conditional  expression.  (See "Chapter 2. Co
°                    ____
°                          tional Statements" on page 4.)

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   IFs can only be 20 deep
°                    ø   Refer to "Appendix B. Internal  Macros  Error
°                        sages" on page 123, for possible condition erro
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          110    Structured Macros Reference
¯
¸
                                                           CHAPTER 36.
                                                           CHAPTER 36.
                                                           CHAPTER 36.
                                                           CHAPTER 36.
°                                                           ____________
¸
          Macro:    LCBA
          Macro:
          Macro:
°          Macro:

          Abstract: This  macro loads the address of certain control bl
          Abstract:
          Abstract:
°          Abstract:
°                    into a register.  No registers are changed  except
°                    the register specified.  A zero condition is set if
°                    control  block can not be located.  It is not neces
°                    for the mapping macros  for  the  control  blocks
°                    internally  by this macros to be included in the so
°                    program.

          Syntax:   LCBA reg,cb
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    reg   This operand specifies the register to be loa
°                    ___
°                          The register must be specified as R1 through

                    cb    One of the following control blocks can be sp
°                    __
°                          fied:

                          ACEE      The  address  of   the   current
                          ACEE
                          ACEE
°                          ACEE
°                                    Accessor  Environment  Element  wil
°                                    loaded.  This address will be the
°                                    tents  of the TCBSENV field of the
°                                    rent  TCB  if  non-zero  and   pres
°                                    otherwise, the address will be the
°                                    tents of the ASXBSENV field of the
°                                    rent ASXB.

                          ASCB      The  address  of  the  current  Add
                          ASCB
                          ASCB
°                          ASCB
°                                    Space Control  Block  will  be  loa
°                                    This address is loaded from PSAAOLD

                          ASXB      The  address  of  the  current  Add
                          ASXB
                          ASXB
°                          ASXB
°                                    Space Extension Block will  be  loa
°                                    This address is loaded from ASCBASX

                          CVT       The  address of the Communications
                          CVT
                          CVT
°                          CVT
°                                    tor Table will be loaded.  This add
°                                    is loaded from location decimal 16.

                          TCB       The address of the current Task Con
                          TCB
                          TCB
°                          TCB
°                                    Block will be loaded.  This address
°                                    loaded from PSATOLD.

                          UJT       The  address of the User Job Table
                          UJT
                          UJT
°                          UJT
°                                    be  loaded.    This  control  block
°                                    Clemson dependent.  TCBUSER of the
°                                    rent  TCB  and  its  parents  TCBs
¸
°                                                    Chapter 36. LCBA
¯
¸
°                                    searched to find  the  address  of
°                                    UJT.

                          UVT       The  address  of the User Communica
                          UVT
                          UVT
°                          UVT
°                                    Vector Table will be loaded.  This
°                                    trol block is Clemson dependent.
°                                    address  is  loaded  from the three
°                                    order bytes of CVTUSER.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   <reg> is invalid.  Register must be R1-R15.
°                    ø   <cb> is not a supported control block.
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          112    Structured Macros Reference
¯
¸
                                                          CHAPTER 37. L
                                                          CHAPTER 37. L
                                                          CHAPTER 37. L
                                                          CHAPTER 37. L
°                                                          _____________
¸
          Macro:    LEAVE
          Macro:
          Macro:
°          Macro:

          Abstract: Structured macro used to leave a structure.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   LEAVE struc=name[,cond]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    struc Type  of  structure  to leave.   Can be IF, L
°                    _____
°                          BLOCK, or CASEBLK.

                    name  Name of the structure to leave.    An  *  can
°                    ____
°                          coded  to indicate the current (innermost) st
°                          ture of the specified type.

                    cond  Conditional expression. (See "Chapter  2.  Co
°                    ____
°                          tional Statements" on page 4.)  If the expres
°                          is true, the structure is left.  If an expres
°                          is  not specified, the structure is left unco
°                          tionally.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   SMWA= keyword needs  to  be  specified  on  pro
°                        block macro
°                    ø   Only one keyword can be specified on LEAVE
°                    ø   Nesting level for <structure> is zero
°                    ø   <name> is not an active <structure> name
°                    ø   One keyword must be specified on LEAVE
°                    ø   Refer  to  "Appendix  B. Internal Macros Error
°                        sages" on page 123, for possible condition erro
¸
¸
¸
¸
¸
¸
¸
°                                                   Chapter 37. LEAVE
¯
¸
          CHAPTER 38. LOOP
          CHAPTER 38. LOOP
          CHAPTER 38. LOOP
          CHAPTER 38. LOOP
°          ________________
¸
          Macro:    LOOP
          Macro:
          Macro:
°          Macro:

          Abstract: Structured  macro  used to start a loop structure.
          Abstract:
          Abstract:
°          Abstract:
°                    LOOP WHILE loops, tests are done at the  start  of
°                    loop.  For LOOP UNTIL loops, tests are done at the
°                    tom of the loop.  If the ENDLOOP specifies UNTIL,LE
°                    the  loop  will continue until a LEAVE macro is use
°                    leave the loop.  BCT, BXH, and BXLE loop use the as
°                    bler instruction by the same name.    BXH  instruct
°                    are  generated  at the top of the loop and BXLE and
°                    instructions are generated at the bottom of the loo

          Syntax:   LOOP [NAME=name,]
          Syntax:
          Syntax:
°          Syntax:
°                             WHILE,cond     ×
°                             UNTIL          ×
°                             BCT            ×
°                             BXH,reg,reg    ×
°                             BXLE

          Operands:
          Operands:
          Operands:
°          Operands:

                    name  Name to be associated with loop structure.
°                    ____

                    cond  Conditional expression. (See "Chapter  2.  Co
°                    ____
°                          tional Statements" on page 4.)

                    reg   Register to be used on associated instruction
°                    ___

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Additional  positional parameters can not be sp
°                        fied on LOOP <type>
°                    ø   LOOPs can only be nested 20 deep
°                    ø   Incorrect number of parameters specified  for
°                        BXH
°                    ø   LOOP type <type> is invalid
°                    ø   Refer  to  "Appendix  B. Internal Macros Error
°                        sages" on page 123, for possible condition erro
¸
¸
¸
¸

°          114    Structured Macros Reference
¯
¸
                                              CHAPTER 39. L8, L16, L24,
                                              CHAPTER 39. L8, L16, L24,
                                              CHAPTER 39. L8, L16, L24,
                                              CHAPTER 39. L8, L16, L24,
°                                              _________________________
¸
          Macro:    L8, L16, L24, L32
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used to load a register with one, two, three
          Abstract:
          Abstract:
°          Abstract:
°                    four bytes of data  from  non-aligned  storage.
°                    macro  clears  the  register and issues the appropr
°                    ICM to accomplish this.

          Syntax:   Ln  reg,addr
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    n     Defines the size of the load operation  in  b
°                    _
                          n  should  be  either  8, 16, 24 or 32 for si
°                          _
°                          byte, half word, three byte, or  full  word
°                          respectively.

                    reg   Specifies  the register to load.  Warning:  S
                    ___                                     Warning:  S
                                                            Warning:  S
°                                                            Warning:  S
                          this register is  cleared  before  the  load,
                          this register is  cleared  before  the  load,
                          this register is  cleared  before  the  load,
°                          this register is  cleared  before  the  load,
                          should  not  be  used (directly or indirectly
                          should  not  be  used (directly or indirectly
                          should  not  be  used (directly or indirectly
°                          should  not  be  used (directly or indirectly
                          specify addr.
                          specify ____.
                          specify     .
°                          specify     .

                    addr  Specifies the address that register reg shoul
°                    ____                                      ___
°                          loaded from.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Invalid number of operands on L<n> instruction
¸
¸
¸
¸
¸
¸
¸
¸

°                                       Chapter 39. L8, L16, L24, L32
¯
¸
          CHAPTER 40. PLIST
          CHAPTER 40. PLIST
          CHAPTER 40. PLIST
          CHAPTER 40. PLIST
°          _________________
¸
          Macro:    PLIST
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to generate or modify a parameter list.
          Abstract:
          Abstract:
°          Abstract:
°                    parameter list can be created in default parameter
°                    storage or routed to a specific location.  Register
°                    is also loaded with the address of the completed li

          Syntax:   PLIST
          Syntax:
          Syntax:
°          Syntax:
°                    [(parms)][,VL×NOVL][,PL=tag×(tag,num)][,DS=PWA×SWA]

          Operands:
          Operands:
          Operands:
°          Operands:

                    parms A  list  of  the parameters to be included in
°                    _____
°                          parameter list.  A missing parameter causes
°                          to  be filled in for the parameter address.
°                          will cause the macro to skip over that parame
°                          reserving the space in the parameter list but
°        ×                 modifying the data there.  An * before a tag
°        ×                 cause the macro to load the parameter  list
°        ×                 the contents of the storage referenced by the
°        ×                 instead of the address of the tag.  This prov
°        ×                 a form of indirect addressing.  Numeric and c
°                          acter  constants  can  be  coded and will be
°                          verted  to  fullword   and   character   lite
                          respectively.    If  parms  is missing, the P
°                                               _____
°                          macro will simply load register one with the
°                          dress specified by PL=.

                    VL×NOVL VL specifies that this is a variable length
°                    _______
°                          rameter  list  and  therefore the high bit of
°                          last address in the list should be  set  to
°                          NOVL  says  to not set the bit.  NOVL is norm
°                          the default, but all of the super options  es
°                          lish  VL  as  the  default  so that NOVL migh
°                          needed in certain cases.

                    tag   Specifies the address of the parameter list t
°                    ___
°                          created or modified.  If the PL= keyword  is
°                          specified,  the parameter list will be create
°                          the default parameter list storage establishe
°                          an enclosing BLOCK macro, or in PWA or SWA  s
°                          age if no other default was set up.

                    num   Specifies  the  maximum  number of the parame
°                    ___
                          that the storage at tag can accommodate.  If
°                                              ___
°                          has  a  length  attribute that is a self-defi
°                          term, this operand is not  necessary.    This
°                          used  to insure that the specified parameter
                          will fit into the storage at tag.
°                                                       ___
¸
°          116    Structured Macros Reference
¯
¸
                    DS=   Specifies that space for this list should be
°                    ___
                          ated in the PWA or SWA with a label of tag.
°                                                                 ___
°                          PL=  keyword is required when using this oper
                          The size of parms is used to calculate  the
°                                      _____
                          of  the storage created, unless num was speci
°                                                          ___
°                          on the PL= keyword.  In this case, the size s
                          ified by num is used.
°                                   ___

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   First operand of  PL  keyword  is  required  if
°                        keyword is specified
°                    ø   <ds> is not valid on the DS keyword
°                    ø   The  PL  keyword must be specified on this macr
°                        on an enclosing BLOCK macro
°                    ø   <tag> is not large enough to contain parameter
°                    ø   Invalid parameter <vl>
°                    ø   Too many parameters specified
°                    ø   Too many parameters on PL keyword
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°                                                   Chapter 40. PLIST
¯
¸
          CHAPTER 41. PSD
          CHAPTER 41. PSD
          CHAPTER 41. PSD
          CHAPTER 41. PSD
°          _______________
¸
          Macro:    PSD
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to  define  the  beginning  of the Pro
          Abstract:
          Abstract:
°          Abstract:
°                    Static Data (PSD).  The PSD macro uses LOCTR to  lo
°                    the static data after the instructions for the prog
°                    The  PSD  should  be  defined just before the PWA f
°                    particular program block if there is one.

          Syntax:   PSD [TYPE=LAST×PARTIAL]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    TYPE= Defines whether this is the PSD  macro  that
°                    _____
°                          fines  the main body of the PSD at the end of
°                          program (LAST), or a PSD  macro  that  define
°                          portion  of  the  PSD from within the body of
°                          program (PARTIAL).   If TYPE= is  not  specif
°                          TYPE=LAST is assumed.  The TYPE=PARTIAL optio
°                          included  to  allow macros within the body of
°                          program to define fields in the PSD and have
°                          placed with the static data.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Nested PSD and SSD macros are not allowed
¸
¸
¸
¸
¸
¸
¸
¸
¸
°          118    Structured Macros Reference
¯
¸
                                                            CHAPTER 42.
                                                            CHAPTER 42.
                                                            CHAPTER 42.
                                                            CHAPTER 42.
°                                                            ___________
¸
          Macro:    PWA
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used to define the beginning of the Program
          Abstract:
          Abstract:
°          Abstract:
°                    Area (PWA).  The PWA macro will  automatically  res
°                    space  for  a  standard OS save area, the SMWA, and
°                    parameter lists if it is appropriate  for  the  cur
°                    environment.    Also,  if the DYN option is being u
°                    PWA will set up  the  dynamic  storage  pointers  (
°                    EOS-64).    The PWA should be defined as the last t
°                    associated with a particular program block.

          Syntax:   PWA [TYPE=LAST×PARTIAL]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    TYPE= Defines whether this is the PWA  macro  that
°                    _____
°                          fines  the main body of the PWA at the end of
°                          program (LAST), or a PWA  macro  that  define
°                          portion  of  the  PWA from within the body of
°                          program (PARTIAL).   If TYPE= is  not  specif
°                          TYPE=LAST is assumed.  The TYPE=PARTIAL optio
°                          included  to  allow macros within the body of
°                          program to define fields in the PWA and also
°                          erate the code to initialize them.  So far,
°                          feature  is only used by the PLIST macro, but
°                          be used by any user macro.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   PWA option should be specified on the program b
°                        macro
°                    ø   Invalid TYPE <type> specified on PWA macro
¸
¸
¸
¸
¸
¸

°                                                     Chapter 42. PWA
¯
¸
          CHAPTER 43. RBIT
          CHAPTER 43. RBIT
          CHAPTER 43. RBIT
          CHAPTER 43. RBIT
°          ________________
¸
          Macro:    RBIT
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to reset bit flags in a byte.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   RBIT [byte,]flag×(flag[,flag[,...]])
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    byte  Byte  that  contains bit(s) to be reset.  If
°                    ____
°                          operand is omitted,  the name of the byte is
°                          sumed  to  be  the  first  five characters of
°                          first flag name.

                    flag  Byte mask with a binary one in the  bit  posi
°                    ____
°                          of the mask that corresponds to the bit to be
°                          set in the byte.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   No more than eight flags can be specified
°                    ø   RBIT macro can have no more than two operands
°                    ø   If  byte  is  not  specified,  flag name must b
°                        least six characters long
°                    ø   If byte is not specified, the first five charac
°                        of all flags must match
¸
¸
¸
¸
¸
¸
¸
¸
¸
°          120    Structured Macros Reference
¯
¸
                                                           CHAPTER 44.
                                                           CHAPTER 44.
                                                           CHAPTER 44.
                                                           CHAPTER 44.
°                                                           ____________
¸
          Macro:    SBIT
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to set bit flags in a byte.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   SBIT [byte,]flag×(flag[,flag[,...]])
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    byte  Byte that contains bit(s) to be set.  If this
°                    ____
°                          erand  is  omitted,   the name of the byte is
°                          sumed to be the  first  five  characters  of
°                          first flag name.

                    flag  Byte  mask  with a binary one in the bit posi
°                    ____
°                          of the mask that corresponds to the bit to be
°                          in the byte.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   No more than eight flags can be specified
°                    ø   SBIT macro can have no more than two operands
°                    ø   If byte is not specified,  flag  name  must  be
°                        least six characters long
°                    ø   If byte is not specified, the first five charac
°                        of all flags must match
¸
¸
¸
¸
¸
¸
¸
¸
¸
°                                                    Chapter 44. SBIT
¯
¸
          CHAPTER 45. SMCTRL
          CHAPTER 45. SMCTRL
          CHAPTER 45. SMCTRL
          CHAPTER 45. SMCTRL
°          __________________
¸
          Macro:    SMCTRL
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to set internal flags to affect the op
          Abstract:
          Abstract:
°          Abstract:
°                    tion of the Structured Macros.

          Syntax:   SMCTRL FREEPWA=yesno
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    yesno Can be YES or NO to set an internal free PWA
°                    _____
°                          on or off.   When this flag  is  on,  the  EN
°                          macro  for  the  program block will free the
°                          This parameter in only valid if the  REUSPWA
°                          tion is in effect.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   The  FREEPWA  keyword  is only valid if the REU
°                        option is in effect
°                    ø   FREEPWA=<value> is not valid
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          122    Structured Macros Reference
¯
¸
        ×                                                CHAPTER 46. SM
                                                         CHAPTER 46. SM
                                                         CHAPTER 46. SM
                                                         CHAPTER 46. SM
°                                                         ______________
¸
        × Macro:    SMLIST
          Macro:
          Macro:
°          Macro:

        × Abstract: Macro  used  to  set  options  for the operation of
          Abstract:
          Abstract:
°          Abstract:
°        ×           Structured Macros Listing Program.  This macro is p
°        ×           essed by the listing program and not the assembler.

        × Syntax:   SMLIST CONVERT=yesno
          Syntax:
          Syntax:
°          Syntax:

        × Operands:
          Operands:
          Operands:
°          Operands:

        ×           yesno Can be YES or NO to begin or  end  the  autom
°                    _____
°        ×                 conversion  of  assembler  source  to upper c
°        ×                 All non-comment lines will be converted to  u
°        ×                 case  with  the  exception of text between do
°        ×                 quotes.  This text will  remain  unconverted
°        ×                 the  double quotes (") will be replaced with
°        ×                 gle quotes (') before passing the  source  on
°        ×                 the assembler.

        × Errors:
          Errors:
          Errors:
°          Errors:

°        ×           ø   INVALID SMLIST STATEMENT
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
°                                                  Chapter 46. SMLIST
¯
¸
        × CHAPTER 47. SMSYMS
          CHAPTER 47. SMSYMS
          CHAPTER 47. SMSYMS
          CHAPTER 47. SMSYMS
°          __________________
¸
        × Macro:    SMSYMS
          Macro:
          Macro:
°          Macro:

        × Abstract: This  is not a macro, but is a copy member that mus
          Abstract:
          Abstract:
°          Abstract:
°        ×           included at the beginning of any program that uses
°        ×           structure  location  symbols  described in "Chapter
°        ×           Location and Scope of Data Structures" on page 43.

        × Syntax:   COPY SMSYMS
          Syntax:
          Syntax:
°          Syntax:

        × Operands: None.
          Operands:
          Operands:
°          Operands:

        × Errors:   None.
          Errors:
          Errors:
°          Errors:
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          124    Structured Macros Reference
¯
¸
                                                            CHAPTER 48.
                                                            CHAPTER 48.
                                                            CHAPTER 48.
                                                            CHAPTER 48.
°                                                            ___________
¸
          Macro:    SSD
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to  define the beginning of the Subrou
          Abstract:
          Abstract:
°          Abstract:
°                    Static Data (SSD).  The SSD macro uses LOCTR to  lo
°                    the  static  data.   If the subroutine has selected
°                    LOADBASE option, the static data is placed  immedia
°                    after the subroutine code in the object module.  If
°                    subroutine is not using LOADBASE, the subroutine st
°                    data  is  placed with the program static data.  The
°                    should be defined just before the SWA for a  partic
°                    subroutine block.

          Syntax:   SSD [TYPE=LAST×PARTIAL]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    TYPE= Defines  whether  this  is the SSD macro that
°                    _____
°                          fines the main body of the SSD at the end of
°                          subroutine (LAST), or an SSD macro that defin
°                          portion  of  the  SSD from within the body of
°                          subroutine (PARTIAL).  If TYPE= is not specif
°                          TYPE=LAST is assumed.  The TYPE=PARTIAL optio
°                          included to allow macros within the body  of
°                          subroutine  to  define fields in the SSD and
°                          them placed with the static data.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Nested PSD and SSD macros are not allowed
¸
¸
¸
¸
¸
¸
¸

°                                                     Chapter 48. SSD
¯
¸
          CHAPTER 49. STRSA
          CHAPTER 49. STRSA
          CHAPTER 49. STRSA
          CHAPTER 49. STRSA
°          _________________
¸
          Macro:    STRSA
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to store a register's value in the Sub
          Abstract:
          Abstract:
°          Abstract:
°                    tine Work Area (SWA) save area.  If an internal sub
°                    tine  contains  an  SWA,  registers  are  automatic
°                    restored  when  the  subroutine  is  exited.    If
°                    internal subroutine needs to pass back the value  o
°                    register,  it  can  use this macro to save a regist
°                    current value in the subroutine save area, so  that
°                    will  not  be  restored  to the original value when
°                    subroutine returns.

          Syntax:   STRSA reg
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    reg   Defines the register that should be saved.
°                    ___
°                          should be one of the registers R0-R14.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   Invalid register specified - <reg>
°                    ø   This  macro  can  only be used in subroutine bl
°                        with the SWA option specified
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          126    Structured Macros Reference
¯
¸
                                                            CHAPTER 50.
                                                            CHAPTER 50.
                                                            CHAPTER 50.
                                                            CHAPTER 50.
°                                                            ___________
¸
          Macro:    SWA
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to  define the beginning of the Subrou
          Abstract:
          Abstract:
°          Abstract:
°                    Work Area (SWA).  The SWA macro will automatically
°                    serve space for a subroutine save area, a SMWA, any
°                    rameter  lists  used by the subroutine, and the Dyn
°                    Storage Management pointers if needed.  The SWA  fo
°                    subroutine  should  be  defined  immediately  after
°                    ENDBLK for that subroutine.  The SWA macro insures
°                    any fields specified within the  SWA  will  be  ali
°                    properly.

          Syntax:   SWA [TYPE=LAST×PARTIAL]
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    TYPE= Defines  whether  this  is the SWA macro that
°                    _____
°                          fines the main body of the SWA at the end of
°                          subroutine (LAST), or an SWA macro that defin
°                          portion  of  the  SWA from within the body of
°                          subroutine (PARTIAL).  If TYPE= is not specif
°                          TYPE=LAST is assumed.  The TYPE=PARTIAL optio
°                          included to allow macros within the body  of
°                          subroutine  to  define fields in the SWA and
°                          generate the code to initialize them.    So
°                          this feature is only used by the PLIST macro,
°                          can be used by any user macro.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   SWA  option  was  not  specified  on the subrou
°                        block macro or SWA already defined
°                    ø   Invalid TYPE <type> specified on SWA macro
¸
¸
¸
¸
¸
¸

°                                                     Chapter 50. SWA
¯
¸
          CHAPTER 51. TBIT
          CHAPTER 51. TBIT
          CHAPTER 51. TBIT
          CHAPTER 51. TBIT
°          ________________
¸
          Macro:    TBIT
          Macro:
          Macro:
°          Macro:

          Abstract: Macro used to test bit flags in a byte.
          Abstract:
          Abstract:
°          Abstract:

          Syntax:   TBIT [byte,]flag×(flag[,flag[,...]])
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    byte  Byte  that contains bit(s) to be tested.  If
°                    ____
°                          operand is omitted,  the name of the byte is
°                          sumed  to  be  the  first  five characters of
°                          first flag name.

                    flag  Byte mask with a binary one in the  bit  posi
°                    ____
°                          of  the  mask  that  corresponds to the bit t
°                          tested in the byte.

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   No more than eight flags can be specified
°                    ø   TBIT macro can have no more than two operands
°                    ø   If byte is not specified,  flag  name  must  be
°                        least six characters long
°                    ø   If byte is not specified, the first five charac
°                        of all flags must match
°                    ø   This expression requires the Level H assembler
¸
¸
¸
¸
¸
¸
¸
¸

°          128    Structured Macros Reference
¯
¸
                                                           CHAPTER 52.
                                                           CHAPTER 52.
                                                           CHAPTER 52.
                                                           CHAPTER 52.
°                                                           ____________
¸
          Macro:    TREG
          Macro:
          Macro:
°          Macro:

          Abstract: Macro  used  to  test a register for zero, positive
          Abstract:
          Abstract:
°          Abstract:
°                    negative.

          Syntax:   TREG reg
          Syntax:
          Syntax:
°          Syntax:

          Operands:
          Operands:
          Operands:
°          Operands:

                    reg   Register to be tested.
°                    ___

          Errors:
          Errors:
          Errors:
°          Errors:

°                    ø   TREG macro can have one and only one operand
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°                                                    Chapter 52. TREG
¯
¸
        × CHAPTER 53. ##COND
          CHAPTER 53. ##COND
          CHAPTER 53. ##COND
          CHAPTER 53. ##COND
°          __________________
¸
        × Macro:    ##COND
          Macro:
          Macro:
°          Macro:

        × Abstract: This is an "internal" macro for use within other ma
          Abstract:
          Abstract:
°          Abstract:
°        ×           and  not  in  open code.   The ##COND macro will te
°        ×           conditional expression and branch  to  the  appropr
°        ×           success  or  failure tags.   This macro is intended
°        ×           use in user condition macros.  For information on w
°        ×           ing a user condition macro,  see  "User-Defined  Co
°        ×           tions" on page 7.

        × Syntax:   ##COND expr,S=stag,F=ftag,L=logic
          Syntax:
          Syntax:
°          Syntax:

        × Operands:
          Operands:
          Operands:
°          Operands:

        ×           expr  The conditional expression to be evaluated.
°                    ____
°        ×                 can  be  any valid conditional expression and
°        ×                 contain previously defined user conditions.

        ×           stag  The name of the tag that marks the  beginning
°                    ____
°        ×                 the code to be executed if the condition is t

        ×           ftag  The  name  of the tag that marks the beginnin
°                    ____
°        ×                 the code to  be  executed  if  the  condition
°        ×                 false.

        ×           logic Either P for positive logic (branch to succes
°                    _____
°        ×                 condition  is  true)  or  N  for  negative  l
°        ×                 (branch to failure, skipping over success cod
°        ×                 condition is false).  These last  three  oper
°        ×                 are  usually  passed  unchanged from the oper
°        ×                 passed in on the user condition macro that is
°        ×                 voking ##COND.

        × Errors:
          Errors:
          Errors:
°          Errors:

°        ×           ø   Invalid option <cond> for #TEST condition
°        ×           ø   Invalid or missing condition expression
°        ×           ø   Invalid number of parms for <op>
°        ×           ø   This expression requires the Level H assembler
°        ×           ø   Invalid condition <cond>
°        ×           ø   No more than 51 positional parameters can be sp
°        ×               fied in a condition
¸
¸
¸

°          130    Structured Macros Reference
¯
¸
                           APPENDIX A. CATALOGUED ASM PROCEDURES AT CLE
                           APPENDIX A. CATALOGUED ASM PROCEDURES AT CLE
                           APPENDIX A. CATALOGUED ASM PROCEDURES AT CLE
                           APPENDIX A. CATALOGUED ASM PROCEDURES AT CLE
°                           ____________________________________________
¸
°          There  are  four  catalogued procedures available at Clemson
°          will provide access to the Structured  Macros:  these  are  A
°          ASMPC,  ASMPCL, and ASMPCLG.  These procs will perform a prep
°          ess; preprocess and assemble; preprocess, assemble, and link;
°          preprocess, assemble, link, and go respectively.

°          The  Structured Macro preprocessor (MSC0150$) does not change
°          source input, but analyzes the use of the Structured  Macros
°          produces  a nesting level report.  Once you have had some tim
°          get used to it, the nesting level  report  becomes  very  use
°          Use //P.SYSIN to provide it with your assembler source.

°          The assembly step executes the Level H Assembler with the opt
°          XREF(SHORT),  TERM  and  OBJECT.  A //SYSTERM DD statement is
°          cluded in the procs, since it appears to be one of the more p
°          lar assembler  options.  //SYSLIB  concatenates  SYS1.MACLIB
°          SYS2.STRUC.MACLIB.    Note  that SYS2.MACLIB is not included,
°          must be included manually if desired.

°          The link-edit step follows the  same  conventions  as  the  o
°          Clemson  compile-and-link  procs, in that link-edit control c
°          may be provided via //L.SYSIN. Parms LIST and MAP are provide
°          the proc.

°          The three procs have the following keyword parameters availab

°           Keyword:    In Procs:           Default:    Used For:

°           SYSOUT      All                    A        Listing SYSOUT c
°           OBJECT      All but ASMP         DUMMY      ASM SYSPUNCH
°           COPT        All but ASMP         <null>     ASM parameters
°           LOPT        ASMPCL, ASMPCLG      <null>     Linkedit paramet
°           PDS         ASMPCL               <null>     Loadlib
°          L.SYSLMOD
°           NAME        ASMPCL               <null>     Load module name
¸
¸
¸
¸
¸

°                    Appendix A. Catalogued ASM Procedures At Clemson
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          132    Structured Macros Reference
¯
¸
                                 APPENDIX B. INTERNAL MACROS ERROR MESS
                                 APPENDIX B. INTERNAL MACROS ERROR MESS
                                 APPENDIX B. INTERNAL MACROS ERROR MESS
                                 APPENDIX B. INTERNAL MACROS ERROR MESS
°                                 ______________________________________
¸
°          The following is a list of error messages that can be produce
°          internal  macros  used  by the Structured Macros.   The chara
°          preceding the message indicates:  *-informational, 4-warning
°          8-error.   Words enclosed in angle brackets are replaced with
°          appropriate text when the message is issued.

          ##COND
          ##COND
          ##COND
°          ##COND

°                    ø   8-Invalid option <cond> for #TEST condition
°                    ø   8-Invalid or missing condition expression
°                    ø   8-Invalid number of parms for <op>
°                    ø   8-This expression requires the Level H assemble
°                    ø   8-Invalid condition <cond>
°                    ø   8-Invalid T=
°                    ø   8-No more than  51  positional  parameters  can
°                        specified in a condition

          ##EESTD
          ##EESTD
          ##EESTD
°          ##EESTD

°                    ø   8-R0  keyword  can not be specified if option R
°                        is not in effect
°                    ø   8-R1 keyword can not be specified if  option  R
°                        is not in effect
°                    ø   8-SMWA=  keyword  needs  to be specified on pro
°                        block

          ##EPSTD
          ##EPSTD
          ##EPSTD
°          ##EPSTD

°                    ø   8-AMODE=<amode> is invalid on <type> block, key
°                        ignored
°                    ø   *-AMODE ignored unless XA option specified for
°                        gram block
°                    ø   8-Invalid number of parameters in SAVE= keyword

          ##IESTD
          ##IESTD
          ##IESTD
°          ##IESTD

°                    ø   8-SMWA= keyword needs to be  specified  on  pro
°                        block macro

          ##IGMSG
          ##IGMSG
          ##IGMSG
°          ##IGMSG

°                    ø   4-<kwdname>=<kwd> ignored

          ##IPSTD
          ##IPSTD
          ##IPSTD
°          ##IPSTD

°                    ø   8-AMODE=<amode> is invalid on <type> block, key
°                        ignored
°                    ø   *-AMODE ignored unless XA option specified for
°                        gram block
¸
°                          Appendix B. Internal Macros Error Messages
¯
¸
°                    ø   8-AMODE  24  or  31 must be specified on contai
°                        subroutine
°                    ø   8-Invalid number of parameters in SAVE= keyword

          ##L
          ##L
          ##L
°          ##L

°                    ø   8-Decimal  self-defining terms are the only typ
°                        self-defining terms allowed
°                    ø   8-WREG is required if R0,*ADDR is used

          ##LA
          ##LA
          ##LA
°          ##LA

°                    ø   8-Decimal self-defining terms are the only type
°                        self-defining terms allowed

          ##MREG
          ##MREG
          ##MREG
°          ##MREG

°                    ø   8-Register specification <reg> is invalid
°                    ø   8-Register <reg> specified multiple times
°                    ø   8-Register <reg> was not used - internal error
°                    ø   8-Invalid type of <type> on ##MREG macro - inte
°                        error

          ##ORGS
          ##ORGS
          ##ORGS
°          ##ORGS

°                    ø   *-For subroutine <subname> when called from sub
°                        tine <subname>

          ##PEDC
          ##PEDC
          ##PEDC
°          ##PEDC

°                    ø   8-R0= invalid if option RTNR0 not specified
°                    ø   8-R1= invalid if option RTNR1 not specified

          ##PEOS
          ##PEOS
          ##PEOS
°          ##PEOS

°                    ø   8-R0  keyword  can not be specified if option R
°                        is not in effect
°                    ø   8-R1 keyword can not be specified if  option  R
°                        is not in effect

          ##PPDC
          ##PPDC
          ##PPDC
°          ##PPDC

°                    ø   8-Invalid option <opt>
°                    ø   4-RMODE and AMODE ignored if MODE option not sp
°                        fied
°                    ø   4-RMODE  and  AMODE ignored if XA option not sp
°                        fied
°                    ø   *-SYSTEM-MODE GETSTG generated
°                    ø   *-#GETSTK generated: #GETSTK =(value)
°                    ø   8-#START option required if SYSTEM option speci
°                    ø   8-#RETURN-related operands not allowed with  SY
°                        option
°                    ø   8-#START/#RTN options not allowed with NOSYSTEM
°                        tion

°          134    Structured Macros Reference
¯
¸
°                    ø   8-#RETURN option not allowed with SYSTEM option
°                    ø   8-EP option not allowed with NOSYSTEM option
°                    ø   8-AMODE and RMODE requested are inconsistent
°                    ø   8-GETSTK option requires SYSTEM option
°                    ø   8-GETSTK option requires PWA option
°                    ø   8-MPMODE option requires SYSTEM and #START opti

          ##PPOS
          ##PPOS
          ##PPOS
°          ##PPOS

°                    ø   8-Invalid option &OPT
°                    ø   4-Option DYN assumed because of option MAIN
°                    ø   4-Option PWA assumed because of option DYN
°                    ø   4-DYNSIZE can not be specified without option D
°                    ø   8-Name required on program block macro
°                    ø   4-RMODE and AMODE ignored if MODE option not sp
°                        fied
°                    ø   4-RMODE  and  AMODE ignored if XA option not sp
°                        fied
°                    ø   4-SVAREA= ignored when PWA option specified
°                    ø   8-First PWAREG must be R13
°                    ø   *-SAVEAREA option assumed because of PWA option
°                    ø   4-SVAREA= ignored when  RENT  and  SAVEAREA  op
°                        specified
°                    ø   *-SAVEAREA   option   assumed  because  of  SVA
°                        keyword
°                    ø   *-Assuming register 1 is saved
°                    ø   8-Option REUSPWA requires the PWA,  RENT  and
°                        options
°                    ø   4-Option  FNCODE is ignored when the REUSPWA op
°                        is not in effect
°                    ø   8-Option ESV requires the PWA and RENT options
°                    ø   8-Option CLRDEBUG requires the ESV option

          ##PPPLI
          ##PPPLI
          ##PPPLI
°          ##PPPLI

°                    ø   8-Invalid option <opt>
°                    ø   8-With ENVIRON=PLI, first BASEREG must be R11
°                    ø   8-With ENVIRON=PLI, first PWAREG must be R13
°                    ø   8-Name required on program block macro
°                    ø   4-RMODE and AMODE ignored if MODE option not sp
°                        fied
°                    ø   4-RMODE and AMODE ignored if XA option  not  sp
°                        fied

          ##PRMOPT
          ##PRMOPT
          ##PRMOPT
°          ##PRMOPT

°                    ø   8-USING option requires two parameters
°                    ø   8-COPYERROR option requires two or three parame
°                    ø   8-<opt> is an invalid suboption of the PARMS op
°                    ø   8-PARMS  and PARMMAP keywords require the PARMS
°                        tion
°                    ø   8-PARMS and PARMMAP keywords are mutually exclu
°                    ø   8-Too many parameters specified on PARMMAP keyw
¸
°                          Appendix B. Internal Macros Error Messages
¯
¸
°                    ø   8-Second parameter required on PARMMAP  keyword
°                        COPY PARMS option is specified
°                    ø   8-<type> is invalid
°                    ø   8-##PRMOPT does not support <opt> option
°                    ø   8-<process> is an invalid value for PROCESS key
°                    ø   8-The first parameter in PARM options must be P

          ##SPSTD
          ##SPSTD
          ##SPSTD
°          ##SPSTD

°                    ø   8-SAVE= invalid if SWA option specified
°                    ø   8-SWA option requires PWA option on program blo
°                    ø   8-SWAREG= can not be specified unless OPTION=SW
°                        specified
°                    ø   8-AMODE= invalid for custom subroutine blocks
°                    ø   8-SAVE= invalid for custom subroutine blocks
°                    ø   8-CUSTOM must be specified alone
°                    ø   8-AMODE=<amode>  is  invalid  on  subroutine bl
°                        keyword ignored
°                    ø   *-LOADBASE assumed because BASEREG= specified
°                    ø   8-BLOCK TYPE=SUBROUTINE requires NAME=
°                    ø   8-LOADBASE option requires LONG option  on  pro
°                        block
°                    ø   8-RECUR  keyword  requires  DYN  option  on pro
°                        block
°                    ø   8-R11 must be the first register specified  on
°                        SWAREG= keyword
°                    ø   *-AMODE  ignored unless XA option specified on
°                        gram block
°                    ø   8-Invalid number of parameters in SAVE= keyword

          ##ST
          ##ST
          ##ST
°          ##ST

°                    ø   8-*ADDR form of second operand requires WREG=

          ##SUBOPT
          ##SUBOPT
          ##SUBOPT
°          ##SUBOPT

°                    ø   8-<opt> is an invalid option for subroutine blo

          ##SWREG
          ##SWREG
          ##SWREG
°          ##SWREG

°                    ø   8-SMWA= keyword is required on  the  program  b
°                        macro to support this function

          ##UCOND
          ##UCOND
          ##UCOND
°          ##UCOND

°                    ø   8-Invalid or undefined user condition name: <co

          ##UPSTD
          ##UPSTD
          ##UPSTD
°          ##UPSTD

°                    ø   8-SWA  option  was  not specified on the subrou
°                        block macro or SWA already defined
°                    ø   8-Invalid type <type> specified on SWA macro

          ##WESTD
          ##WESTD
          ##WESTD
°          ##WESTD

°          136    Structured Macros Reference
¯
¸
°                    ø   *-<subname> first from index is <num>
°                    ø   *-<num>    CALLSUB    from    <subname>(<num>)
°                        <subname>(<num>)

          ##WPDC
          ##WPDC
          ##WPDC
°          ##WPDC

°                    ø   8-PWA option should be  specified  on  the  pro
°                        block macro
°                    ø   8-Invalid type <type> specified on PWA macro

          ##WPOS
          ##WPOS
          ##WPOS
°          ##WPOS

°                    ø   8-PWA  option  should  be  specified on the pro
°                        block macro
°                    ø   8-Invalid type <type> specified on PWA macro

          ##WPPLI
          ##WPPLI
          ##WPPLI
°          ##WPPLI

°                    ø   8-PWA option should be  specified  on  the  pro
°                        block macro
°                    ø   8-Invalid type <type> specified on PWA macro
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°                          Appendix B. Internal Macros Error Messages
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          138    Structured Macros Reference
¯
¸
                                       APPENDIX C. WORK AREA STORAGE LA
                                       APPENDIX C. WORK AREA STORAGE LA
                                       APPENDIX C. WORK AREA STORAGE LA
                                       APPENDIX C. WORK AREA STORAGE LA
°                                       ________________________________
¸
°          If  you are using PWAs and SWAs (with or without the DYN opti
°          the Structured Macros automatically allocate many fields for
°          Since the macros also manage these fields,  you  rarely  need
°          worry  about them.   However, there may be some cases in whic
°          would be useful to know the layout of PWA and SWA storage.
°          is what this appendix describes.
¸
          WORK AREA LAYOUT WITH THE DYN OPTION
          WORK AREA LAYOUT WITH THE DYN OPTION
          WORK AREA LAYOUT WITH THE DYN OPTION
          WORK AREA LAYOUT WITH THE DYN OPTION
°          ____________________________________

°          The  DYN  option  is  only  available  for  program  blocks
°          ENVIRON=OS in effect.

°          As described in "Chapter 5. Program and Subroutine Work Areas
°          page 20, the DYN option acquires a single large chunk of  sto
°          at the beginning of the program and partitions it as it is ne
°          for  internal subroutine SWAs.  The layout of the dynamic sto
°          is shown below.

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°                    ¼      ¼      ¼     ¼      ¼      ¼      ¼        ¼
°             × PWA  × SWA  × SWA  × - - × PWA  × SWA  × - -  × Free   ×
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°                    ¨      ¨      ¨     ¨      ¨      ¨      ¨        ¨
°                                                             ×        ×
°                                                            NAB     EOS

°          The first thing in dynamic storage is the main program's PWA
°          lowed by any SWAs that happen to be active for that program.
°          the  main  program  invokes  an  external  subroutine  that
°          *NOMAIN, another PWA will be generated for that program  foll
°          by its SWAs.  At the end is free storage waiting to be alloca
°          The  current  NAB (Next Available Byte) will contain a pointe
°          the beginning of free storage.  See below to see how to find
°          current NAB.

°          While EOS (End Of Storage) actually marks the end of the bloc
°          storage  that was GETMAINed, a pointer is kept to EOS-64 inst
°          This provides a 16 word (64 byte) "safety zone" for  use  by
°          internal  subroutine  linkage routines.  These extra bytes in
°          that there will always be at least 16 words left in dynamic s
°          age when a subroutine is entered.   Because of this  buffer,
°          subroutine  can save its registers before it has to calculate
°          maining space and update the pointers.

°          Within dynamic storage, all PWAs and SWAs start on a double
°          boundary.  This is to insure that any fields defined within t
°          DSECTs as double word will actually have that alignment.
¸

°                                Appendix C. Work Area Storage Layout
¯
¸
°          The  diagram  above shows that dynamic storage is divided up
°          PWAs and SWAs.  The format of a single PWA is shown below.

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°                         ¼        ¼          ¼     ¼         ¼      ¼
°             × Save Area × EOS-64 × Reserved × NAB × Partial × SMWA × P
°             ×    (18F)  ×        ×          ×     ×  PWA    × (1)  × (
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°                         ¨        ¨          ¨     ¨         ¨      ¨
°             ×
°            R13

          Note:
          Note:
          Note:
°          Note:
°           (1) The SMWA is variable in length.
°           (2) The PL storage will be as large as required.

°          First  is  a 18 word, standard OS save area for this program.
°          is used anytime the program calls an external subroutine.
°          could  be  either an IBM service or a separately compiled mod
°          By putting the save area at the beginning of the PWA and poin
°          register 13 at it, we can use this register to keep up with
°          the current save area and the beginning of PWA storage.

°          After  the  save area is a pointer to EOS-64.  This field def
°          the end of the block of dynamic storage that this PWA resides
°          This field is filled in even for  a  *NOMAIN  PWA.    The  EO
°          pointer  is  used in subroutine linkages to determine if ther
°          enough storage left for an SWA.   Following  this  pointer  i
°          fullword reserved for future use.

°          Next  comes the NAB (Next Available Byte) for this PWA.  This
°          points to the first byte after this PWA.  If there are no  ac
°          SWAs  following this PWA, the NAB will point to the start of
°          storage.  Otherwise, it will point to the first SWA following
°          PWA.

°          Following the NAB are any fields  that  were  defined  by  a
°          TYPE=PARTIAL  macro.   These fields may have been defined by
°          macros, or by the DS=PWA keyword  on  the  PLIST  macro.    T
°          fields  may be any length.  Also in the partial PWA are param
°          list fields for any internal subroutines that do not have SWA

°          Following the partial fields is the SMWA (Structured Macros
°          Area).    Note that the SMWA can be variable in length or abs
°          If you specify a relocatable address for the SMWA, one  will
°          be allocated automatically.

°          Next  is  any  space  reserved  for dynamically defined param
°          lists in the program block.  These lists are any that do not
°          a PL=tag coded on the PLIST macro or any enclosing block.
°          that  only enough space for the largest such list is reserved
°          stead of for all the lists.  All of these dynamic lists are
°          ated   in  the  same  place.    For  more  information  on  P
°          processing, see "Chapter 10. Parameter Lists and  Standard  L
°          age"  on  page 34.   This field may also be variable in lengt
°          missing.

°          140    Structured Macros Reference
¯
¸
°          Finally come any fields that you coded between the PWA and EN
°          macros.  These continue until the end of the PWA.

°          A  PWA  remains in dynamic storage as long as its program is
°          ning.  The PWA is followed by any active SWAs for that  progr
°          internal  subroutines.  The SWAs are created and destroyed as
°          subroutines are entered and exited.  The format of a  single
°          is shown below.

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¼
°                    ¼         ¼         ¼        ¼     ¼
°             × NAB  × R0-R14  × Partial × SMWA   × PL  × User - -    ×
°             ×      ×  Save   ×  SWA    × (1)    × (2) × Defined     ×
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿³
°                    ¨         ¨         ¨        ¨     ¨
°             ×
°            R11

          Note:
          Note:
          Note:
°          Note:
°           (1) The SMWA for subroutines is not used and is of zero leng
°           (2) The PL storage will be as large as required.

°          The  SWA  looks  very  much like a PWA with a few fields miss
°          The only significant difference is the 15  word  subroutine
°          area.    Note  that this is an internal subroutine save area,
°          not a standard OS save area.  The NAB for a subroutine points
°          the first available byte after that subroutine's SWA.  If thi
°          the last SWA currently in dynamic storage, this NAB will poin
°          the  beginning of free space.  Otherwise, it will contain the
°          dress of the next SWA (or PWA) in dynamic storage.

°          R11 always points to the beginning (i.e. the  NAB)  of  the
°          rently  active subroutine.  If there is no subroutine active,
°          will point to the NAB from the current PWA.   Therefore, R11
°          only provides us with a base for our SWA, it always points to
°          most current NAB.

°          This storage scheme is very easy to maintain and perform link
°          on.  When an internal subroutine is entered, it uses R15 (thi
°          why  R15 is destroyed with the DYN option) to calculate where
°          SWA will go from the current NAB (pointed to by R11).    It
°          saves its registers in this new SWA and calculates a new NAB.
°          there is enough room for this SWA, the subroutine will update
°          to  point  to  its NAB and the linkage is complete.  Adding a
°          PWA is a similar process.  The reverse linkage  is  even  eas
°          Since  the  pointer to the current NAB is kept in a register,
°          act of restoring registers at the end of a subroutine returns
°          dynamic storage environment to the state it  was  in  before
°          subroutine  was  entered.   The same holds true for eliminati
°          PWA when an *NOMAIN program is exited.
¸
¸

°                                Appendix C. Work Area Storage Layout
¯
¸
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=DC
°          __________________________________________

°          The work area layout for an ENVIRON=DC program is nearly  ide
°          cal  with that of an ENVIRON=OS program: the only differences
°          that the PWA does not contain an 18-word OS savearea, and the
°          in an ENVIRON=DC program is addressed by some register other
°          R13 (usually R11).

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¼
°                         ¼         ¼           ¼
°             × Partial   × SMWA    × PL        × User - -   ×
°             ×  PWA      × (1)     × (2)       × Defined    ×
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿³
°                         ¨         ¨           ¨
°             ×
°            R11

          Note:
          Note:
          Note:
°          Note:
°           (1) The SMWA is variable in length.
°           (2)  The  PL  storage will be as large as required.  An SWA
°          NODYN program is represented below.  It is identical to  the
°          for an ENVIRON=OS program with the NODYN option.  field.

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¼
°                       ¼         ¼        ¼     ¼
°             × R0-R14  × Partial × SMWA   × PL  × User - -    ×
°             ×  Save   ×  SWA    × (1)    × (2) × Defined     ×
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿³
°                       ¨         ¨        ¨     ¨
°             ×
°            (3)

          Note:
          Note:
          Note:
°          Note:
°           (1) The SMWA for subroutines is not used and is of zero leng
°           (2) The PL storage will be as large as required.
°           (3) With NODYN, the SWA will be addressed off of the PWA bas

°          ENVIRON=DC does not currently support the DYN option.
¸
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=OS
°          __________________________________________

°          If the DYN option is not being used, the program can still ha
°          PWA.  If this is the case, the PWA is of the following format

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¼
°                         ¼         ¼      ¼    ¼
°             × Save Area × Partial × SMWA × PL × User - -   ×
°             ×   (18F)   ×  PWA    × (1)  × (2)× Defined    ×
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿³
°                         ¨         ¨      ¨    ¨
°             ×
°            R13

          Note:
          Note:
          Note:
°          Note:
°           (1) The SMWA is variable in length.
°           (2) The PL storage will be as large as required.

°          142    Structured Macros Reference
¯
¸
°          The  PWA for a NODYN program looks very much like the PWA cre
°          in dynamic storage, except that the pointers used to keep up
°          dynamic storage are not there.  Also, any SWAs  defined  by
°          program will reside in the partial PWA area.

°          An  SWA  in  a NODYN program is represented below.  Remember
          this storage is  actually  allocated  within  the  PWA's  par
°                                                                    ___
°          field.

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¼
°                       ¼         ¼        ¼     ¼
°             × R0-R14  × Partial × SMWA   × PL  × User - -    ×
°             ×  Save   ×  SWA    × (1)    × (2) × Defined     ×
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿³
°                       ¨         ¨        ¨     ¨
°             ×
°            (3)

          Note:
          Note:
          Note:
°          Note:
°           (1) The SMWA for subroutines is not used and is of zero leng
°           (2) The PL storage will be as large as required.
°           (3) With NODYN, the SWA will be addressed off of the PWA bas

°          The  SWA  within a NODYN program is just like that for a DYN
°          gram, except that the NAB is absent.
¸
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
          WORK AREA LAYOUT WITH NODYN AND ENVIRON=PLI
°          ___________________________________________

°          The work area layout for ENVIRON=PLI is the same  as  the  la
°          for  ENVIRON=OS  with  option  NODYN in effect with the excep
°          that the save area is replace by a PL/I DSA.  A DSA  starts
°          an  OS  save area with the first word used for PL/I housekeep
°          The forward link in the save area is not used.  The save area
°          followed  by  other  PL/I housekeeping fields.  The format of
°          DSA is described in detail in the execution time logic manual
°          the PL/I Optimizing Compiler.

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¼
°                         ¼         ¼      ¼    ¼
°             × PL/I DSA  × Partial × SMWA × PL × User - -   ×
°             ×           ×  PWA    × (1)  × (2)× Defined    ×
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿³
°                         ¨         ¨      ¨    ¨
°             ×
°            R13

          Note:
          Note:
          Note:
°          Note:
°           (1) The SMWA is variable in length.
°           (2) The PL storage will be as large as required.
¸
¸

°                                Appendix C. Work Area Storage Layout
¯
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸
¸

°          144    Structured Macros Reference
¯
¸
                            APPENDIX D. PROGRAM CODE AND STATIC DATA LA
                            APPENDIX D. PROGRAM CODE AND STATIC DATA LA
                            APPENDIX D. PROGRAM CODE AND STATIC DATA LA
                            APPENDIX D. PROGRAM CODE AND STATIC DATA LA
°                            ___________________________________________
¸
°          The  use of the LOCTR instruction in the Level H Assembler al
°          the Structured Macros to gather  code  under  different  loca
°          counters  and  place them at the proper point in the load mod
°          To preserve the  integrity  of  the  structure  that  the  ma
°          produce, a program should be coded in the manner shown below.

°             BLOCK  TYPE=PROGRAM,NAME=MAINPROG,OPTIONS=(*MAIN,LONG),
°                           SUBOPTS=(*SWA,LOADBASE)
°                   :
°              CALLSUB SUBONE
°                   :
°             ENDBLK BLOCK=MAINPROG

°             BLOCK  TYPE=SUBROUTINE,NAME=SUBONE
°                   :
°              CALLSUB SUBTWO
°                   :
°             ENDBLK BLOCK=SUBONE
°             SWA
°              --- SWA Fields for SUBONE ---
°             ENDSWA

°             BLOCK  TYPE=SUBROUTINE,NAME=SUBTWO,RECUR=10
°                   :
°              CALLSUB SUBTWO
°                   :
°             ENDBLK BLOCK=SUBTWO
°             SSD
°              --- Subroutine Static Data for SUBTWO ---
°             ENDSSD
°             SWA
°              --- SWA Fields for SUBTWO ---
°             ENDSWA

°             BLOCK  TYPE=SUBROUTINE,NAME=SUBTHREE,OPTIONS=(NOLOADBASE)
°                   :
°              CALLSUB SUBTHREE
°                   :
°             ENDBLK BLOCK=SUBTHREE
°             SSD
°              --- Subroutine Static Data for SUBTHREE ---
°             ENDSSD

°             PSD
°              --- Program Static Data ---
°             ENDPSD
°             PWA
°              --- PWA FIELDS ---
°             ENDPWA
¸
°                     Appendix D. Program Code and Static Data Layout
¯
¸
°          Note that not all programs will require all of these options.
°          SUBTWO  was not recursive, we would not need Dynamic Storage
°          agement.   However, it still may be  of  assistance  in  redu
°          storage  needs.  SWAs, SSDs, and the PSD only need to be code
°          there are fields to define there.  If these areas are  needed
°          the  macros, they will create them if you have not.  However,
          PWA and ENDPWA macros must always be coded if the program is
                                     always
                                     always
°                                     always
°          ing to use the PWA option.

          Note: If  the  NOLOCTR  option has been selected, the macros
          Note:
          Note:
°          Note:
°          not generate LOCTRs to arrange the code, and the  CSECT  will
°          arranged as it was coded.

°          When  the  load  module is actually created by the Assembler,
°          layout of a single CSECT looks like the figure below:

             ö¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°                        ¼             ¼          ¼            ¼
°             × Program  × Subroutine  × Partial  × PSD User   × Subrout
°             × Code (1) ×  Code (2)   × PSD (3)  × Fields (4) × Code (5
             ¨¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿¿
°                        ¨             ¨          ¨            ¨

°          (1)   First in the CSECT is the code from the program  block
°                self.

°          (2)   Following  the program code is the code for any subrout
°                that did not specify LOADBASE.  This allows  these  sub
°                tines to be addressed off of the program's base registe

°          (3)   The  partial  PSD contains any PSD fields that were def
°                within the body of the program.  Also included here are
°                SSDs from the subroutines without LOADBASE.    The  par
°                PSD along with the PSD user fields are addressed off of
°                program's base register.

°          (4)   The  PSD  user fields are any static data coded between
°                PSD and ENDPSD macros at the end of the program.

°          (5)   The subroutine  code  for  any  subroutines  that  use
°                LOADBASE  option  is placed after the PSD.  If there ar
°                subroutines that use LOADBASE, this area and the  next
°                are missing.

°          (6)   Following  the code for a LOADBASE subroutine is the st
°                data (SSD) for that subroutine.  This data is addressed
°                of the subroutine's base register.   These last  two  a
°                can  be repeated any number of times, once for each sub
°                tine that uses the LOADBASE option.
¸
¸
¸
°          146    Structured Macros Reference
¯
¸
                                                 APPENDIX E. REGISTER U
                                                 APPENDIX E. REGISTER U
                                                 APPENDIX E. REGISTER U
                                                 APPENDIX E. REGISTER U
°                                                 ______________________
¸
°          With so many things being done by the macros, you may not be
°          exactly  what  registers are available for general use.  This
°          pendix describes the registers used by the Structured Macros.
¸
          REGISTER USAGE FOR ENVIRON=DC
          REGISTER USAGE FOR ENVIRON=DC
          REGISTER USAGE FOR ENVIRON=DC
          REGISTER USAGE FOR ENVIRON=DC
°          _____________________________
¸
          IDMS/DC User Mode Registers And Linkage
          IDMS/DC User Mode Registers And Linkage
          IDMS/DC User Mode Registers And Linkage
          IDMS/DC User Mode Registers And Linkage
°          _______________________________________

°          ø   User mode programs are invoked by:

°              ¿   A #LINK from RHDCTSKC (task create)
°              ¿   A #LINK or #XCTL from another program

°          ø   User mode registers are used as follows:

              R15       Entry point address from caller;  loaded  into
              R15
              R15
°              R15
°                        specified   program  base  register  by  the  B
°                        TYPE=PROGRAM macro. Also used for subroutine  l
°                        age if the LONG option is used.

              R14       This is used for returning from subroutine bloc
              R14
              R14
°              R14

              R13       Not used.
              R13
              R13
°              R13

              R12       Default program base register.
              R12
              R12
°              R12

              R11       Default PWA base register.
              R11
              R11
°              R11

              R10       Address  of the IDMS/DC CSA on entry, although
              R10
              R10
°              R10
°                        register may be used for other things by  the
°                        gram.

              R9        Address  of  the  IDMS/DC  task's TCE on entry,
              R9
              R9
°              R9
°                        though this register may be used for  other  th
°                        by the program.

              R2-R8     Not used.
              R2-R8
              R2-R8
°              R2-R8

              R1        Address  of parameter list from calling program
              R1
              R1
°              R1
°                        any

              R0        Not used.
              R0
              R0
°              R0

°          ø   Registers are always saved across requests for  IDMS/DC
°              vices, except for R14, R15, R0 and R1.

°                                          Appendix E. Register Usage
¯
¸
°          ø   The  assembler program should include an interface, eithe
°              coding a #BALI macro among your constants  somewhere,  or
°              specifying INCLUDE IDMSLIB(IDMSBALI) to the linkage edito

°          ø   User  mode  programs must return to IDMS/DC using the #RE
°              macro.  If you use the NO#RETURN  option,  you  must  cod
°              #RETURN  yourself  at  some  point  after the program blo
°              ENDBLK macro.
¸
          IDMS/DC System Mode Registers And Linkage
          IDMS/DC System Mode Registers And Linkage
          IDMS/DC System Mode Registers And Linkage
          IDMS/DC System Mode Registers And Linkage
°          _________________________________________

°          ø   System mode programs are invoked  by  a  #CALL  from  ano
°              system-mode program. Should you wish to call an external
°              tine, you should use #CALL instead of CALLX.

°          ø   System mode registers are used as follows:

              R15       Entry  point  address  from caller; loaded into
              R15
              R15
°              R15
°                        specified  program  base  register  by  the   B
°                        TYPE=PROGRAM  macro. Also used for internal sub
°                        tine linkage if the LONG option is used.

              R14       This is used for returning from subroutine bloc
              R14
              R14
°              R14

              R13       Not used.
              R13
              R13
°              R13

              R12       Program base register.
              R12
              R12
°              R12

              R11       Default PWA base register, for  PWA's  obtained
              R11
              R11
°              R11
°                        either #GETSTG or #GETSTK.

              R10       Address of the IDMS/DC CSA. This should not be
              R10
              R10
°              R10
°                        ified by the program.

              R9        Address  of the IDMS/DC task's TCE. This should
              R9
              R9
°              R9
°                        be modified by the program.

              R2-R8     Not used.
              R2-R8
              R2-R8
°              R2-R8

              R1        Address of parameter list from calling program,
              R1
              R1
°              R1
°                        any

              R0        Not used.
              R0
              R0
°              R0

°          ø   Registers R13 and R15-R1 are never saved across #CALLs.

°          ø   Registers  R11,  R12  and R14 are always saved in the cur
°              TCE's save area stack.
¸

°          148    Structured Macros Reference
¯
¸
°          ø   The caller of a routine is responsible for  specifying  w
°              of the remaining registers (R2-R8) are to be saved. For e
°              ple,
°                    #CALL  pgmname,(R2-R8)
°              will  cause R2 through R8 to be saved on the TCE stack, a
°              with R11, R12 and R14.
¸
          REGISTER USAGE FOR ENVIRON=OS
          REGISTER USAGE FOR ENVIRON=OS
          REGISTER USAGE FOR ENVIRON=OS
          REGISTER USAGE FOR ENVIRON=OS
°          _____________________________

          R15       This register is used for the address of the subrou
          R15
          R15
°          R15
°                    when CALLSUB is used with the LONG  Program  Block
°                    tion.

          R14       This register holds the return address from any sub
          R14
          R14
°          R14
°                    tine block called by the macros.

          R13       This  is  the  base register for the PWA.  Although
          R13
          R13
°          R13
°                    PWA can have multiple base  registers,  the  first
°                    must  always be R13 since the standard OS save area
°                    the program is at the beginning of the PWA.  If *NO
°                    is used and SVAREA= is not specified, R13 is the  f
°                    program base as well as pointing to the OS save are

          R12       This  is normally the base register for the program
          R12
          R12
°          R12
°                    self along with any static data.  If the NORENT  op
°                    is  being  used and the SVAREA=  keyword was not sp
°                    fied, R13 is used for the base register instead of
°                    The BASEREG=  keyword on the Program Block can be
°                    to  specify a different base register (or multiple
°                    registers).

          R11       If the DYN option was specified on the  Program  Bl
          R11
          R11
°          R11
°                    R11 will be used to establish addressibility on the
°                    of  the  current  subroutine.   This register is in
°                    even when no subroutine is currently active.   Alth
°                    the  Subroutine  Block  allows  you to specify mult
°                    base registers for the SWA,  R11  must  always  be
°                    first one.

          R10       If the LOADBASE options was specified on the Subrou
          R10
          R10
°          R10
°                    Block,  R10  will  be used as the base register for
°                    subroutine code.  This register is only  in  use  w
°                    the  LOADBASE  subroutine  is  currently  active.
°                    BASEREG=  keyword on the Subroutine Block can  be
°                    to  specify a different base register (or multiple
°                    registers).
¸
¸

°                                          Appendix E. Register Usage
¯
¸
          REGISTER USAGE FOR ENVIRON=PLI
          REGISTER USAGE FOR ENVIRON=PLI
          REGISTER USAGE FOR ENVIRON=PLI
          REGISTER USAGE FOR ENVIRON=PLI
°          ______________________________

          R15       This register is used for the address of the subrou
          R15
          R15
°          R15
°                    when CALLSUB is used with the LONG  Program  Block
°                    tion.

          R14       This register holds the return address from any sub
          R14
          R14
°          R14
°                    tine block called by the macros.

          R13       This  is  the base register for the PWA.  A PL/I DS
          R13
          R13
°          R13
°                    contained in the first part of the PWA; therefore,
°                    is  also  the  base for the DSA.   Although the PWA
°                    have multiple base registers, the first one must al
°                    be R13 because PL/I requires that R13 contain a poi
°                    to the DSA.

          R12       This is the pointer to PL/I's Task Communications
          R12
          R12
°          R12
°                    (TCA) and should never be modified by a program.

          R11       This is the first program base register for the pro
          R11
          R11
°          R11
°                    itself along with any static data.

          R10       If the LOADBASE options was specified on the Subrou
          R10
          R10
°          R10
°                    Block,  R10  will  be used as the base register for
°                    subroutine code.  This register is only  in  use  w
°                    the  LOADBASE  subroutine  is  currently  active.
°                    BASEREG= keyword on the Subroutine Block can be use
°                    specify a different base  register  (or  multiple
°                    registers).
¸
¸
¸
¸
¸
¸
¸
¸

°          150    Structured Macros Reference
