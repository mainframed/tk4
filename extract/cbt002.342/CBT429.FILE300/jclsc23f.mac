*  GOTTEN FROM MEMOREX MODS FILE.  TST2SSG.MEMOREX.MODS - OR
*         FROM FILE 313 OF ANY CBT TAPE, LEVEL 260 OR PREVIOUS.
*      THIS IS THE SVC TO RUN THE "JCLSCAN" TSO COMMAND.
RCASHE   EQU   5                  CASHE ADDRESS REGISTER
RADDR    EQU   6                  I/O ADDRESS REGISTER
RLEN     EQU   7                  LENGTH ADDRESS REGISTER
RACB     EQU   8                  ACB ADDRESS REGISTER
RRPL     EQU   9                  RPL ADDRESS REGISTER
RTEXT    EQU   9                  TEXT ADDRESS REGISTER
RPARM    EQU   9                  PARM ADDRESS REGISTER
WORKREG  EQU   10                 WORK AREA ADDRESS REGISTER
BASEREG  EQU   11                 BASE REGISTER
RCODE    EQU   12                 RETURN CODE REGISTER
R12      EQU   12                 REGISTER 12
R13      EQU   13                 O/S SAVE AREA ADDRESS REGISTER
R14      EQU   14                 O/S LINKAGE REGISTER
R15      EQU   15                 O/S ENTRY AND RC REGISTER
         SPACE 2
RPLEODER EQU   X'04'              EOD
RPLNOEXT EQU   X'1C'              NO MORE EXTENET
RPLINRBA EQU   X'20'              INVALID RBA
RPLNOVRT EQU   X'28'              NO VIRTUAL STORAGE AVAILIBLE
RPLINBUF EQU   X'2C'              ************
RPLINACC EQU   X'44'              INVALID REQUEST
RPLINUPD EQU   X'5C'              INVALID UPDATE REQUEST
RPLDLCER EQU   X'64'              ********
RPLINLEN EQU   X'6C'              INCORRECT LENGTH
         SPACE 2
CXP      EQU   128                CONTINUATION EXPECTED
CXPN     EQU   64                 CONTINUATION EXPECTED AND NOT RECV
CXPC     EQU   32                 CONTINUATION EXPECTED
         SPACE 2
FGEOD    EQU   X'80'               END OF FILE ON GET FUNCTION
FSUPRESS EQU   X'20'               SUPPRESS INPUT TO DELIMITER STMT
FDATA    EQU   X'10'               DATA MODE IS 'DD DATA'
FINPUT   EQU   X'08'               INPUT MODE ESTABLISHED
FEODAD   EQU   X'04'               REAL END OF FILE
FFIRST   EQU   X'02'               FIRST TIME THRU CODE
JCLS     TITLE 'CONVERTER/INTERPRETER INTERFACE SVC'
***********************************************************************
*                                                                     *
* TITLE -      CONVERTER/INTERPRETER INTERFACE SVC                    *
*                                                                     *
* RELEASE -    1.0         CONVERTER/INTERPRETER INTERFACE RELEASE    *
*                                                                     *
* AUTHOR -     MICHAEL LEE EMIGH                                      *
*              UNITED AIR LINES - EXOKF COMPUTER CENTER               *
*              1200 W. ALGONQUIN ROAD                                 *
*              ELK GROVE VILLAGE, ILLINOIS                            *
*              PHONE: 312-952-4371
*                                                                     *
* FUNCTION -   PROVIDES INTERFACE BETWEEN AN APPLICATION PROGRAM AND  *
*              THE O/S CONVERTER FOR SYNTAX CHECKING JCL AND          *
*              OBTAINING CONVERTER MESSAGES, JCL, AND INTERNAL TEXT.  *
*                                                                     *
* INPUT -      STANDARD LINKAGE CONVENTIONS                           *
*              REGISTER 0 -                                           *
*                           BYTE 0 - OPTION SWITCHES                  *
*                                    BIT 0 - TAKE SMF EXITS           *
*                                    BIT 1 - INTERPRET
*                           BYTE 1-3 - ADDRESS OF CONVERTER PARMS     *
*              REGISTER 1 - ADDRESS OF PROGRAM EXIT LIST              *
*                           WORD 1 - JCL EXIT ENTRY POINT             *
*                           WORD 2 - MSG EXIT ENTRY POINT             *
*                           WORD 3 - STMT IMAGE EXIT ENTRY POINT      *
*                           WORD 4 - INTERNAL TEXT EXIT ENTRY POINT   *
*                           WORD 5 - N/A                              *
*                           WORD 6 - INTERPRETED JCT EXIT ENTRY POINT *
*              REGISTER 3 - ADDRESS OF CVT                            *
*              REGISTER 4 - ADDRESS OF TCB                            *
*              REGISTER 5 - ADDRESS OF SVRB                           *
*              REGISTER 6 - ADDRESS OF SVC ENTRY POINT                *
*              REGISTER 7 - ADDRESS OF ASCB                           *
*              REGISTER 15 - ADDRESS OF PROCLIB DDNAME OR ZERO        *
*                                                                     *
* OUTPUT -     RETURN CODE TO APPLICATION PROGRAM                     *
*              REGISTER 15 CONTAINS RETURN CODE AS FOLLOWS            *
*                 0 - JCL CONTAINS NO ERRORS                          *
*                 4 - JCL ERRORS FOUND                                *
*                 8 - UNABLE TO OPEN PROCLIB DDNAME                   *
*                12 - INVALID OR MISSING JOB CARD                     *
*                16 - INVALID PARAMETER LIST                          *
*                20 - CONVERTER/INTERPRETER FAILURE                   *
*                                                                     *
* ATTRIBUTES - REENTERANT, REUSABLE, REFRESHABLE                      *
*                                                                     *
* NOTES -      THIS ROUTINE INTERFACES TO THE MVS CONVERTER           *
*              TO PROVIDE TSO JCL SYNTAX CHECKING.                    *
*              EXITS 5 AND 6 WILL NOT BE TAKEN AFTER AN ERROR.        *
*                                                                     *
***********************************************************************
         EJECT
IGC0023F CSECT                     CONVERTER INTERFACE SVC
         USING IGC0023F,BASEREG    EST. ADDRESSIBILITY
         USING RBSECT,R5           SET SVRB ADDRESSIBILITY
         USING CVT,R3              SET CVT ADDRESSIBILITY
         USING TCB,R4              SET TCB ADDRESSIBILITY
         STM   R14,R1,CIRETURN     SAVE RETURN ADDRESS AND PARM REGS
         LR    BASEREG,R6          LOAD BASE ADDRESS
         LR    RPARM,R1            SAVE EXIT LIST ADDRESS
         USING EXITLIST,RPARM      SET EXIT LIST ADDRESSIBILITY
         LA    R6,CORESIZE         LOAD MAIN STORAGE REQUIRED
         GETMAIN R,LV=(R6)         GET MAIN STORAGE
         LR    WORKREG,R1          SET WORK AREA BASE REGISTER
         ST    WORKREG,CISWA       SAVE WORK AREA ADDRESS IN SVRB
         USING SYNTAXD,WORKREG     EST. WORK AREA ADDR
         LR    R0,R1               SET R0 FOR CLEAR
         LR    R1,R6               SET R1 FOR CLEAR LENGTH
         SR    R15,R15             CLEAR PAD CHAR AND 0 LENGTH
         MVCL  R0,R14              CLEAR WORK AREA
         ST    R5,ASVRB            SAVE SVRB ADDRESS
         LR    R13,WORKREG         LOAD O/S SAVE AREA ADDRESS REG
         EJECT
         LA    RCODE,16            ASSUME INVALID PARAMETER LIST
         SLR   R1,R1               CLEAR INSERT REGISTER
         TM    EXTJCLE+3,1         HALFWORD BOUNDARY?
         BO    RETURN              IF NOT THEN ERROR
         ICM   R1,7,EXTJCLE+1      LOAD JCL EXIT ENTRY POINT
         BZ    RETURN              IF ZERO THEN INVALID ENTRY
         ST    R1,EJCL             STORE IN WORK AREA
         TM    EXTJCLE,X'80'       END OF LIST?
         BO    JOBFIND             YES, THEN GO FIND JOB CARD
         TM    EXTMSGE+3,1         HALFWORD BOUNDARY?
         BO    RETURN              IF NOT THEN ERROR
         ICM   R1,7,EXTMSGE+1      LOAD MSG EXIT ADDR
         ST    R1,EMSG             STORE EXIT ADDR IN WA
         TM    EXTMSGE,X'80'       END OF LIST?
         BO    JOBFIND             YES, THEN GO FIND JOB CARD
         TM    EXTSTMTE+3,1        HALFWORD BOUNDARY?
         BO    RETURN              IF NOT THEN ERROR
         ICM   R1,7,EXTSTMTE+1     LOAD STMT EXIT ADDR
         ST    R1,ESTMT            STORE EXIT ADDR IN WA
         TM    EXTSTMTE,X'80'      END OF LIST?
         BO    JOBFIND             YES, THEN GO FIND JOB CARD
         TM    EXTTEXTE+3,1        HALFWORD BOUNDARY?
         BO    RETURN              IF NOT THEN ERROR
         ICM   R1,7,EXTTEXTE+1     LOAD TXT EXIT ADDR
         ST    R1,ETEXT            STORE EXIT ADDR IN WA
         TM    EXTTEXTE,X'80'      END OF LIST?
         BO    JOBFIND             YES, THEN GO FIND JOB CARD
         TM    EXTCTXTE+3,1        HALFWORD BOUNDARY?
         BO    RETURN              IF NOT THEN ERROR
         ICM   R1,7,EXTCTXTE+1     LOAD CONVERTED TEXT EXIT ADDR
         ST    R1,ERCTXT           STORE EXIT ADDR IN WA
         TM    EXTCTXTE,X'80'      END OF LIST?
         BO    JOBFIND             YES, THEN GO FIND JOB CARD
         TM    EXTINTE+3,1         HALFWORD BOUNDARY?
         BO    RETURN              IF NOT THEN ERROR
         ICM   R1,7,EXTINTE+1      LOAD INTERPRET TEXT EXIT ADDR
         ST    R1,EINTPRET         STORE EXIT ADDR IN WA
         SPACE 2
         DROP  RPARM               DROP EXIT LIST ADDRESSIBLITY
         EJECT
JOBFIND  DS    0H                  SCAN FOR A JOB CARD
         LA    RCODE,12            LOAD INV OR MISS JOB CARD RC
         SPACE 2
JOBGETC  DS    0H                  GET A CARD
         L     R15,EJCL            LOAD JCL EXIT ADDRESS
         SR    R1,R1               CLEAR JCL CARD ADDRESS REGISTER
         BAL   R14,SYNCHEX         EXIT TO PROGRAM FOR A JCL CARD
         LTR   R15,R15             END OF DATA?
         BNZ   RETURN              YES, THEN ERROR
         LTR   R1,R1               ADDRESS PRESENT?
         BZ    RETURN              NO, THEN ERROR
         CLC   =C'/*',0(R1)        JES2 JCL CARD?
         BE    JOBGETC             YES, THEN SKIP IT
         CLC   =C'//*',0(R1)       COMMENTS CARD?
         BE    JOBGETC             YES, THEN SKIP IT
         CLC   =C'//',0(R1)        JCL CARD?
         BNE   RETURN              NO, THEN ERROR
         CLI   2(R1),C' '          JOB NAME PRESENT?
         BE    RETURN              NO, THEN ERROR
         MVC   JCLCARD,0(R1)       SAVE JCL CARD
         LA    R2,2(R1)            POINT TO FIRST CHARACTER OF JOB NAME
         LA    R14,1               SET INCREMENT TO 1
         LA    R15,66(,R1)         POINT TO END OF SCAN FIELD
         SPACE 2
JOBSCAN  DS    0H                  JOB SCAN LOOP
         BXH   R2,R14,RETURN       INCREMENT TO NEXT BYTE
         CLC   =C' JOB ',0(R2)     JOB CARD?
         BNE   JOBSCAN             YES, THEN EXIT LOOP
         LA    R1,2(R1)            POINT TO FIRST BYTE OF JOB NAME
         LR    R2,R1               SET SCAN POINTER
         LA    R15,9(,R2)          POINT TO END OF SCAN FIELD
         EJECT
BLDJMR   DS    0H                  BUILD JMR FOR SMF
         BXH   R2,R14,RETURN       INCREMENT TO NEXT BYTE
         CLI   0(R2),C' '          END OF JOB NAME?
         BNE   BLDJMR              NO, THEN NEXT BYTE
         SR    R2,R1               COMPUTE JOB NAME LENGTH
         BNP   RETURN              IF NOT GT ZERO THEN ERROR
         BCTR  R2,0                MINUS 1 FOR EXECUTE
         LA    R6,JMRAREA          LOAD JMR AREA ADDRESS
         USING JMR,R6              SET JMR ADDRESSIBILITY
         MVC   JMRJOB(8),=CL8' '   SET JMR JOB NAME TO SPACE
         MVC   JMRJOB(0),0(R1)     MOVE JOB NAME TO JMR
         EX    R2,*-6              EXECUTE MOVE FOR PROPER LENGTH
         L     R1,CVTSMCA          LOAD SMF CONTROL AREA ADDR
         USING SMCABASE,R1         SET SMCA ADDRESSIBILITY
         MVC   JMRCPUID,SMCASID    MOVE SYSTEM ID TO JMR
         MVC   JMROPT,SMCAOPT      MOVE SMF OPTIONS TO JMR
         DROP  R1                  DROP SMCA
         TIME  BIN                 GET TIME
         ST    R1,JMREDATE         STORE DATE IN JMR
         ST    R0,JMRENTRY         STORE TIME IN JMR
         STM   R0,R1,JMRDRSTP      SET RDR STOP DATE/TIME
         MVC   JMRUSEID(8),=CL8' ' CLEAR USER FIELD
         ST    R6,NELJMR           STORE JMR ADDR IN NEL
         TM    PPLOPT,X'80'        SMF INDICATED?
         BZ    BLDNEL              IF NOT THEN SKIP JMR BUILD
         OI    NELOPSWT,NELSMF     TURN ON SMF SWITCH
         EJECT
BLDNEL   DS    0H                  BUILD NEL PARAMETER LIST
         SR    R0,R0               CLEAR SCRATCH REGISTER
         ICM   R0,8,=AL1(NELEXADD) INSERT ADDRESS INDICATOR
         ICM   R0,4,=AL1(NELTXTEX) INSERT TEXT EXIT INDICATOR
         LA    R1,SYNTXTX          LOAD TEXT EXIT ADDRESS
         STM   R0,R1,TXTEXIT       STORE IN NEL EXIT LIST
         MVC   NELEXLEN,=H'16'     INDICATE LENGTH OF EXIT LIST
         LA    R0,NELEXITS         LOAD EXIT LIST ADDRESS
         ST    R0,NELEXLST         STORE EXLIST ADDRESS IN NEL
         LA    R1,QMPAAREA         LOAD QUEUE MANAGER PARM AREA ADDR
         USING IOPARAMS,R1         SET QMPA DSECT
         ST    R1,NELQMPA          STORE QMPA ADDRESS IN NEL
         MVI   QMSWSP,237          GETMAINS FROM SUBPOOL 237
         L     R15,TCBJSCB         LOAD JSCB ADDRESS
         CLI   JSCBSWSP-IEZJSCB(R15),236 SUBPOOL 236 IN USE?
         BE    *+8                 YES, THEN SUBPOOL 237 OK
         MVI   QMSWSP,236          ELSE USE SUBPOOL 236 FOR GETMAINS
         DROP  R1                  DROP QMPA ADDRESSIBILITY
         MVI   NELPARMO,NELPGMN+NELACCT PGMR AND ACCT REQUIRED
         MVC   NELJPRTY,=C'00'     SET DEFAULT PRIORITY
         MVC   NELTIME,=C'006000'  SET DEFAULT TIME LIMIT
         MVC   NELREG,=C'512'      SET DEFAULT REGION SIZE
         MVI   NELCOMDS,C'1'       IGNORE COMMANDS
         MVI   NELLABEL,C'1'       LABEL=BLP
         MVC   NELAUTH,=C'E000'    CMD AUTHORITY
         MVI   NELMSGL1,C'1'       JCL MSGLVL DEFAULT
         MVI   NELMSGL2,C'1'       ALLOC MSGLVL DEFAULT
         MVI   NELMSGCL,C'A'       SET DEFAULT MSGCLASS=A
         ICM   R1,7,PPLCONVP       CONVERTER PARM OVERRIDES?
         BZ    BLDACBS             NO, THEN GO BUILD ACBS
         MVC   NELPARMO(NELMSGCL-NELPARMO),0(R1) MOVE OVERRIDES
         EJECT
BLDACBS  DS    0H                  BUILD ACBS
         MVC   MSGCL,NELMSGCL      SAVE DEFAULT MESSAGE CLASS
         MVC   JCLACB(LACB),ACB    BUILD JCL ACB
         MVC   TEXTACB(LACB),ACB   BUILD TEXT ACB
         MVC   STMTACB(LACB),ACB   BUILD STMT ACB
         MVC   MSGACB(LACB),ACB    BUILD MSG ACB
         USING IFGACB,RACB         SET ACB DSECT
         LA    RACB,JCLACB         LOAD JCL ACB ADDRESS
         MVI   ACBMACR1,ACBADR+ACBSEQ+ACBIN RESET MACRO FLAGS
         LA    R0,SYNJMGR          LOAD JCL EXIT ADDRESS
         ST    R0,ACBINRTN         LOAD JCL EXIT ADDRESS
         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN
         ST    RACB,NELJCLCB       STORE IN NEL
         LA    RACB,MSGACB         LOAD MSG ACB ADDRESS
         MVI   ACBCCTYP,ACBCCASA   INDICATE ASA CNTL CHAR
         LA    R0,SYNMMGR          LOAD MSG EXIT ADDRESS
         ST    R0,ACBINRTN         LOAD MSG EXIT ADDRESS
         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN
         ST    RACB,NELMSGCB       STORE IN NEL
         LA    RACB,TEXTACB        LOAD TXT ACB ADDRESS
         OI    ACBMACR1,ACBUBF+ACBIN RESET MACRO FLAGS
         LA    R0,SYNTMGR          LOAD TXT MGR ADDRESS
         ST    R0,ACBINRTN         LOAD TXT MGR ADDRESS
         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN
         ST    RACB,NELTXTCB       STORE IN NEL
         LA    RACB,STMTACB        LOAD STM ACB ADDRESS
         LA    R0,SYNSMGR          LOAD STM EXIT ADDRESS
         ST    R0,ACBINRTN         LOAD STM EXIT ADDRESS
         OI    ACBOFLGS,ACBOPEN    INDICATE ACB OPEN
         ST    RACB,NELSTMCB       STORE IN NEL
         ICM   R1,7,PPLPDDN+1      LOAD PROCLIB DDNAME ADDRESS
         BZ    CONVERT             IF NO DDNAME THEN NO PROCLIB
         MVC   PROCDCB(LBSDCB),BSDCB BUILD PROCLIB DCB
         MVC   PROCDCB+40(8),0(R1) MOVE PROCLIB DDNAME TO DCB
         LA    R1,PROCDCB          LOAD PROCLIB DCB ADDRESS
         ST    R1,NELPROCB         STORE PROCLIB DCB ADDRESS IN NEL
         ST    R1,OPLIST           STORE DCB ADDRESSES
         MVI   OPLIST,128          SET UP FOR OPEN INPUT
         OPEN  ,MF=(E,OPLIST)      OPEN JCL DATASET
         LA    RCODE,8             SET RETURN CODE TO 8
         TM    PROCDCB+48,X'10'    OPEN SUCCESSFUL?
         BZ    RETURN              ERROR RC=8
         EJECT
CONVERT  DS    0H                  LINK TO CONVERTER
         GETMAIN R,LV=4088         GET MAIN STORAGE FOR 1ST CASHE
         ST    R1,CASHEPTR         SAVE CASHE ADDRESS
         USING CASHE,R1            SET CASHE ADDRESSIBILITY
         LA    R0,CASHDATA         LOAD CASHE DATA ADDRESS
         ST    R0,CASHADDR         SAVE ADDRESS OF NEXT AVAIL ENTRY
         LA    R0,4088-LCASHE      LOAD NUMBER OF BYTES AVAIL
         ST    R0,CASHENBL         SAVE NUMBER OF BYTES
         ST    R1,CASHECUR         SAVE CASHE ADDRESS
         DROP  R1                  DELETE ADDRESSIBILITY
         LOAD  EPLOC=IEFVH1        LOAD CONVERTER
         LR    R15,R0              LOAD CONVERTER ENTRY POINT ADDR
         LA    R1,NELLIST          LOAD NEL PARAMTER LIST ADDRESS
         BALR  R14,R15             BRANCH TO CONVERTER
         LR    RCODE,R15           SAVE CONVERTER RETURN CODE
         DELETE EPLOC=IEFVH1       DELETE CONVERTER
         TM    PROCDCB+48,X'10'    DCB OPEN?
         BZ    INTRPRET            NO, THEN SKIP CODE
         CLOSE ,MF=(E,OPLIST)      CLOSE DCB
         EJECT
INTRPRET DS    0H                  CHECK IF INTERPRETATION WANTED
         LTR   RCODE,RCODE         CONVERTION SUCCESSFUL?
         BNZ   FREE                NO, THEN RETURN IMMEDIATELY
         TM    PPLOPT,X'40'        INTERPRETATION REQUESTED?
         BZ    FREE                NO, THEN GO RETURN
         SLR   R0,R0               CLEAR SCRATCH REGISTER
         ICM   R0,8,QMPAAREA       INSERT SUBPOOL NUMBER
         FREEMAIN R,SP=(0)         FREE CONVERTER MAIN STORAGE
         XC    NELEXLST,NELEXLST   CANCEL NEL EXIT LIST
         XC    NELJCT,NELJCT       CLEAR JCT ADDRESS
         XC    NELOPSW2(8),NELOPSW2 CLEAR INTERPRETER OPTION SWITCH
         XC    FLAGS,FLAGS         RESET STATUS FLAGS
         L     R2,CASHEPTR         LOAD 1ST CASHE ADDRESS
         USING CASHE,R2            GIVE CASHE ADDRESSIBLITY
         ST    R2,CASHECUR         CURRENT CASHE = 1ST CASHE
         LA    R0,CASHDATA         POINT TO FIRST RECORD
         ST    R0,CBFUPTR          SET CURRENT RECORD POINTER
         SLR   R0,R0               CLEAR SEQUENCE NUMBER
         STM   R0,R1,CBFRBAR       SET FIRST RBA ADDRESS
         DROP  R2                  DROP CASHE ADDRESSIBILITY
         LOAD  EPLOC=IEFNB903      LOAD INTERPRETER
         LR    R15,R0              LOAD CONVERTER ENTRY POINT ADDR
         LA    R1,NELLIST          LOAD NEL PARAMTER LIST ADDRESS
         BALR  R14,R15             BRANCH TO CONVERTER
         LR    RCODE,R15           SAVE INTERPRETER RETURN CODE
         DELETE EPLOC=IEFNB903     DELETE INTERPRETER
         ICM   R15,15,EINTPRET     LOAD INTERPRET EXIT ADDRESS
         BZ    FREE                IF NONE THEN DONE
         LTR   R0,RCODE            LOAD INTERPRETER RC
         BNZ   FREE                IF NOT ZERO,THEN DONE
         ICM   R1,7,NELJCT         LOAD JCT QMPA ADDRESS
         BZ    FREE                IF NONE THEN DONE
         LA    R1,16(,R1)          POINT TO JCT
         BAL   R14,SYNCHEX         EXIT TO INTERPRET EXIT
         EJECT
FREE     DS    0H                  FREE MAIN STORAGE
         SLR   R0,R0               CLEAR SCRATCH REGISTER
         ICM   R0,8,QMPAAREA       INSERT SUBPOOL NUMBER
         FREEMAIN R,SP=(0)         FREE CONVERTER MAIN STORAGE
         L     R2,CASHEPTR         LOAD 1ST CASHE ADDRESS
         USING CASHE,R2            SET CASHE DSECT
         SPACE 2
FREECASH DS    0H                  FREE CASHE BUFFERS
         LR    R1,R2               LOAD CASHE ADDRESS
         L     R2,CASHNEXT         LOAD NEXT CASHE ADDRESS
         FREEMAIN R,LV=4088,A=(1)  FREE CASHE BUFFER
         LTR   R2,R2               END OF CASHE BUFFERS?
         BNZ   FREECASH            NO, THEN REPEAT LOOP
         DROP  R2                  DROP CASHE ADDRESSIBILITY
         C     RCODE,=F'4'         CHECK IF RETURN CODE TOO HIGH
         BNH   RETURN              IF NOT HIGH, THEN CONVERTION OK
         LA    RCODE,20            ESLE CONVERSION FAILURE
         SPACE 2
RETURN   DS    0H
         LA    R0,CORESIZE         LOAD FREEMAIN LENGTH
         LR    R1,WORKREG          LOAD FREEMAIN ADDRESS
         L     R5,ASVRB            RELOAD SVRB ADDRESS
         FREEMAIN R,LV=(0),A=(1)   FREE WORK AREA
         L     R14,CIRETURN        RELOAD RETURN ADDRESS
         LR    R15,RCODE           RETURN CODE TO REG 15
         BR    R14                 RETURN TO CALLING PGM
         EJECT
         LTORG
         SPACE 1
         DS    0F
         EJECT
         PRINT NOGEN
         SPACE 2
IEFVH1   DC    CL8'IEFVH1'
         SPACE 2
IEFNB903 DC    CL8'IEFNB903'
         SPACE 2
BSDCB    DCB   DSORG=PO,DDNAME=IEFPDSI,MACRF=R
         SPACE 2
LBSDCB   EQU   *-BSDCB
         SPACE 2
ACB      ACB   MACRF=(ADR,SEQ,OUT)
         SPACE 2
LACB     EQU   *-ACB
         SPACE 3
         PRINT GEN
         TITLE 'CONVERTER JCL MANAGER'
***********************************************************************
*                                                                     *
* TITLE -      SYNTAX   JCL MANAGER                                   *
*                                                                     *
* FUNCTION -   SIMULATE A VSAM GET REQUEST FROM THE CONVERTER TO      *
*              READ THE NEXT JCL CARD FROM THE INPUT DATASET.         *
*                                                                     *
***********************************************************************
         SPACE 2
SYNJMGR  DS    0H                  SYNTAX JCL ACB EXIT
         SAVE  (14,12)             SAVE CALLERS REGISTERS
         LR    BASEREG,R15         EST. BASE REGISTER
         USING SYNJMGR,BASEREG
         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER
         USING IFGRPL,RRPL         SET RPL DSECT
         STC   R0,RPLREQ           SAVE RPL REQUEST
         L     RACB,RPLDACB        LOAD ACB ADDRESS
         USING IFGACB,RACB         SET ACB DSECT
         LA    WORKREG,0(RACB)     LOAD WORK REG W/ ACB ADDRESS
         LA    R0,JCLACB-SYNTAXD   LOAD ACB OFFSET
         SR    WORKREG,R0          COMPUTE DSECT ADDRESS
         LA    R15,EXITSAVE        LOAD NEW SAVE AREA ADDRESS
         ST    R13,4(,R15)         CHAIN OLD SAVE AREA
         ST    R15,8(,R13)         CHAIN NEW SAVE AREA
         LR    R13,R15             LOAD O/S SAVE AREA REGISTER
         USING COMWA,RC            BASE FOR COMMON WA
         TM    FLAGS,FEODAD        EOF?
         BZ    SYNJCHK1            NO, GO GET NEXT CARD
         LA    R0,RPLEODER         LOAD EOD VSAM ERROR CODE
         B     SYNVSAM             GO TO VSAM EXIT
         SPACE 2
SYNJCHK1 DS    0H                  CHECK FOR FIRST TIME THRU
         TM    FLAGS,FFIRST        FIRST TIME THRU
         BO    SYNJGETC            NO, THEN SKIP CODE
         OI    FLAGS,FFIRST        INDICATE NOT FFIRST TIME THRU
         B     SYNJPASS            GO GIVE CARD TO CONVERTER
         SPACE 2
SYNJGETC DS    0H
         SLR   R0,R0               ASSUME NO DATA MODE
         SLR   R1,R1               ASSUME NO DELIMITER
         TM    FLAGS,FSUPRESS      DATA MODE?
         BZ    SYNJEXIT            NO, THEN TAKE EXIT
         LA    R1,DLM              LOAD DELIMITER ADDRESS
         LA    R0,4                ASSUME DD *
         TM    FLAGS,FDATA         DD DATA?
         BZ    SYNJEXIT            NO, THEN TAKE EXIT
         LA    R0,8                INDICATE DD DATA
         EJECT
SYNJEXIT DS    0H                  EXIT TO PROGRAM TO OBTAIN CARD
         L     R15,EJCL            LOAD JCL EXIT ADDRESS
         BAL   R14,SYNCHEX         EXIT TO PROGRAM
         LTR   R15,R15             END OF DATA?
         BNZ   SYNJEOD             YES, THEN GO PASS NULL CARD
         LTR   R1,R1               LOAD R5 W/ RCD ADDRESS
         BZ    SYNJEOD             IF ZERO THEN ASSUME EOD
         CLC   =C'//*',0(R1)       COMMENT CARD?
         BE    SYNJGETC            YES, THEN SKIP CARD
         MVC   JCLCARD,0(R1)       MOVE JCL CARD TO SVC STORAGE
         TM    SWB,CXP             JCL CONTINUATION EXPECTED?
         BO    SYNJCONT            YES, THEN CHECK FOR JCL
         TM    FLAGS,FSUPRESS      SUPPRESS INPUT(DATA MODE)?
         BZ    SYNJJCLC            NO
         TM    FLAGS,FDATA         DATA MODE?
         BO    SYNJDATA            YES
         CLC   JCLID,JCLCARD       JCL CARD?
         BE    SYNJPASS            YES, RETURN IT TO CONVERTER
         SPACE 2
SYNJDATA DS    0H
         CLC   DLM,JCLCARD         DELIMITER STATEMENT?
         BNE   SYNJGETC            NO, THEN FLUSH CARD
         NI    FLAGS,255-FSUPRESS-FDATA
         B     SYNJGETC
         SPACE 2
SYNJJCLC DS    0H                  *
         CLC   EOFID,JCLCARD       /* CARD?
         BE    SYNJGETC            YES, THEN IGNORE IT
         SPACE 2
SYNJCONT DS    0H                  CONTINUE JCL CHECK
         CLC   JCLID,JCLCARD       JCL STATEMENT?
         BE    SYNJPASS            YES, THEN ACCEPT IT
         OI    FLAGS,FSUPRESS      SET SUPPRESS DATA FLAG ON
         B     SYNJGETC
         SPACE 2
SYNJEOD  DS    0H                  END OF DATA
         OI    FLAGS,FEODAD        SET END FOR NEXT TIME
         MVC   JCLCARD,NULLCARD    RETURN NULL
         SPACE 2
SYNJPASS DS    0H
         NI    FLAGS,255-FSUPRESS-FDATA CLEAR STATEMENT FLAGS
         L     R2,RPLAREA          LOAD USER AREA ADDRESS
         MVC   0(80,R2),JCLCARD    MOVE JCL STATEMENT TO USER
         MVC   RPLRLEN,=F'80'      SET RPL RECORD LENGTH
         SR    R0,R0               LOAD VSAM CODE
         B     SYNVSAM             GO TO VSAM EXIT
         EJECT
NULLCARD DC    CL80'//'       FOR END OF DATA
EOFID    DC    C'/*'
JCLID    DC    C'//'
         SPACE 2
         LTORG
         TITLE 'CONVERTER STATEMENT IMAGE MANAGER'
***********************************************************************
*                                                                     *
* TITLE -      SYNTAX STATEMENT IMAGE MANAGER                         *
*                                                                     *
* FUNCTION -   SIMULATE A VSAM PUT REQUEST FROM THE CONVERTER TO      *
*              WRITE A JCL IMAGE TO THE STATEMENT IMAGE DATASET.      *
*                                                                     *
***********************************************************************
         SPACE 2
SYNSMGR  DS    0H                  SYNTAX STATEMENT IMAGE HANDLER
         SAVE  (14,12)             SAVE CALLERS REGISTERS
         LR    BASEREG,R15         EST. BASE REGISTER
         USING SYNSMGR,BASEREG
         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER
         USING IFGRPL,RRPL         SET RPL DSECT
         STC   R0,RPLREQ           SAVE RPL REQUEST
         L     RACB,RPLDACB        LOAD ACB ADDRESS
         USING IFGACB,RACB         SET ACB DSECT
         LA    WORKREG,0(RACB)     LOAD ADDRESS OF ACB
         LA    R0,STMTACB-SYNTAXD  LOAD ACB OFFSET
         SR    WORKREG,R0          COMPUTE WORK AREA ADDRESS
         LA    R15,EXITSAVE        LOAD NEW S.A. ADDRESS
         ST    R13,4(,R15)         CHAIN OLD SAVE AREA
         ST    R15,8(,R13)         CHAIN NEW SAVE AREA
         LR    R13,R15             LOAD SAVE AREA REGISTER
         CLI   RPLREQ,RPLPUT       PUT REQUEST?
         BE    SYNSTMTP            YES, THEN GO PROCESS
         SR    R0,R0               ASSUME END REQUEST
         CLI   RPLREQ,RPLENDRE     END REQUEST?
         BE    *+8                 YES, THEN RETURN CODE 0
         LA    R0,RPLINACC         LOAD VSAM ERROR CODE FOR OUTPUT GET
         B     SYNVSAM             GO TO VSAM EXIT
         SPACE 2
SYNSTMTP DS    0H                  PROCESS PUT REQUEST
         L     R1,RPLAREA          LOAD USER AREA ADDRESS
         LH    R0,RPLRLEN+2        LOAD USER AREA LENGTH
         ICM   R15,15,ESTMT        LOAD STMT EXIT ADDRESS
         BZ    *+8                 IF ZERO THEN SKIP EXIT
         BAL   R14,SYNCHEX         EXIT TO PROGRAM
         SR    R0,R0               SET RETURN CODE TO ZERO
         B     SYNVSAM             GO TO VSAM EXIT
         TITLE 'CONVERTER/INTERPRETER MESSAGE MANAGER'
***********************************************************************
*                                                                     *
* TITLE -      CONVERTER/INTERPRETER MESSAGE MANAGER                  *
*                                                                     *
* FUNCTION -   SIMULATE VSAM PUT REQUEST FROM THE CONVERTOR           *
*              TO THE ERROR MESSAGE DATASET. THE ERROR MESSGAGE IS    *
*              SAVED UNTIL THE JCL STATEMENT IS PUT TO THE JCL DS.    *
*                                                                     *
***********************************************************************
         SPACE 2
SYNMMGR  DS    0H                  SYNTAX MSG ACB EXIT
         SAVE  (14,12)             SAVE CALLERS REGISTERS
         LR    BASEREG,R15         EST. BASE REGISTER
         USING SYNMMGR,BASEREG
         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER
         USING IFGRPL,RRPL         SET RPL DSECT
         STC   R0,RPLREQ           SAVE RPL REQUEST
         L     RACB,RPLDACB        LOAD ACB ADDRESS
         USING IFGACB,RACB         SET ACB DSECT
         LA    WORKREG,0(RACB)     LOAD WORK REG W/ ACB ADDRESS
         LA    R0,MSGACB-SYNTAXD   LOAD ACB OFFSET
         SR    WORKREG,R0          COMPUTE DSECT ADDRESS
         LA    R15,EXITSAVE        LOAD NEW SAVE AREA ADDRESS
         ST    R13,4(,R15)         CHAIN OLD SAVE AREA
         ST    R15,8(,R13)         CHAIN NEW SAVE AREA
         LR    R13,R15             LOAD O/S SAVE AREA REGISTER
         CLI   RPLREQ,RPLPUT       PUT REQUEST?
         BE    SYNMSGP             YES, THEN GO PROCESS
         SR    R0,R0               ASSUME END REQUEST
         CLI   RPLREQ,RPLENDRE     END REQUEST?
         BE    *+8                 YES, THEN RETURN CODE = 0
         LA    R0,RPLINACC         LOAD VSAM ERROR CODE FOR INV OP
         B     SYNVSAM             GO TO VSAM EXIT
         SPACE 2
SYNMSGP  DS    0H                  PROCESS PUT REQUEST
         L     R1,RPLAREA          LOAD USER AREA ADDRESS
         LH    R0,RPLRLEN+2        LOAD USER AREA LENGTH
         ICM   R15,15,EMSG        LOAD MSG EXIT ADDRESS
         BZ    *+8                IF ZERO THEN SKIP EXIT
         BAL   R14,SYNCHEX        EXIT TO PROGRAM
         SR    R0,R0              RETURN CODE = ZERO
         B     SYNVSAM            GO TO VSAM EXIT
         TITLE 'CONVERTER/INTERPRETER INTERNAL TEXT MANAGER'
***********************************************************************
*                                                                     *
* TITLE -      CONVERTER INTERFACE INTERNAL TEXT MANAGER              *
*                                                                     *
* FUNCTION -   SIMULATE VSAM REQUESTS FROM THE CONVERTER TO THE       *
*              INTERNAL TEXT DATASET.  REQUESTS MAY BE GETS OR PUTS   *
*              WITH OR WITHOUT UPDATE.                                *
*                                                                     *
***********************************************************************
         SPACE 2
SYNTMGR  DS    0H                  SYNTAX TEXT MANAGER
         SAVE  (14,12)             SAVE CALLERS REGISTERS
         LR    BASEREG,R15         EST. BASE REGISTER
         USING SYNTMGR,BASEREG
         LR    RRPL,R1             LOAD RPL ADDRESS REGISTER
         USING IFGRPL,RRPL         SET RPL DSECT
         STC   R0,RPLREQ           SAVE RPL REQUEST
         LR    R15,R13             SAVE OLD SAVE AREA ADDRESS
         L     RACB,RPLDACB        LOAD ACB ADDRESS
         USING IFGACB,RACB         SET ACB DSECT
         LA    WORKREG,0(RACB)     LOAD RPL ACB ADDRESS
         LA    R0,TEXTACB-SYNTAXD  LOAD ACB OFFSET
         SR    WORKREG,R0          COMPUTE WORK AREA ADDRESS
         LA    R13,EXITSAVE        LOAD NEW SAVE AREA ADDRESS
         USING IOPARAMS,R2
         ST    R13,8(,R15)         CHAIN NEW SAVE AREA
         ST    R15,4(,R13)         CHAIN OLD SAVE AREA
         SR    R15,R15             CLEAR SCRATCH REGISTER
         IC    R15,RPLREQ          INSERT REQUEST CODE
         CL    R15,=A(RPLERASE)    ERASE IS HIGHEST ALLOWABLE CODE
         BNH   QROUTE              IF NOT HIGH THEN OK
         LA    R0,RPLINACC         ELSE LOGICAL ERROR
         B     SYNVSAM             EXIT TO VSAM ROUTINE
         EJECT
QROUTE   DS    0H                  ROUTE VSAM REQUEST
         SLL   R15,2               MULT TIMES 4
         B     *+4(R15)            BRANCH TABLE
         B     QGET                REQUEST 0
         B     QPUT                REQUEST 1
         B     QCHECK              REQUEST 2
         B     QPOINT              REQUEST 3
         B     QENDREQ             REQUEST 4
         B     QERASE              REQUEST 5
         SPACE 2
QCHECK   DS    0H                  CHECK
         L     R15,RPLFDBK-1       LOAD RETURN CODE
         LA    R0,0(R15)           STRIP HIGH ORDER BYTE
         B     SYNVSAM             EXIT TO VSAM ROUTINE
         SPACE 2
QENDREQ  DS    0H                  END REQUEST
         SPACE 2
QERASE   DS    0H                  ERASE INTERNAL TEXT RECORD
         SR    R0,R0               RETURN CODE 0
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         SPACE 2
         USING CASHE,RCASHE        SET CASHE DSECT
         EJECT
QGET     DS    0H                  RETRIEVE INTERNAL TEXT RECORD
         TM    FLAGS,FGEOD         END OF FILE?
         BZ    QGET0               NO, THEN CONTINUE
         LA    R0,RPLEODER         RETURN CODE = RPLEODER
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         SPACE 2
QGET0    DS    0H                  CHECK GET REQUEST TYPE
         L     RADDR,RPLAREA       LOAD TARGET ADDRESS
         TM    RPLOPT2,RPLUPD      GET UPDATE REQUEST?
         BO    QGETU               YES, THEN GO TO GET UPDATE ROUTINE
         L     R4,CBFUPTR          LOAD CURRENT RECORD ADDRESS
         LH    R3,0(R4)            LOAD CURRENT RECORD LENGTH
         LA    R2,2(R4)            POINT TO ACTUAL RECORD
         LR    RLEN,R3             COPY LENGTH
         ICM   R3,8,=C' '          INSERT PAD CHARACTER
         MVCL  RADDR,R2            MOVE RECORD TO TARGET ADDRESS
         ST    RLEN,RPLRLEN        STORE LENGTH IN RPL
         MVC   RPLRBAR,CBFRBAR     MOVE RBA TO RPL
         L     RCASHE,CASHECUR     LOAD CASHE ADDRESS
         LM    R2,R3,CBFRBAR       LOAD RBA ADDRESS
         AH    R4,0(R4)            ADD LENGTH TO NEXT RECORD
         LA    R4,2(R4)            POINT TO NEXT RECORD
         C     R4,CASHADDR         CHECK FOR EOB
         BL    QGET2               IF NOT EOB THEN CONTINUE
         L     RCASHE,CASHNEXT     ELSE POINT TO NEXT CASHE
         LTR   RCASHE,RCASHE       END OF DATA?
         BNZ   QGET1               NO, THEN CONTINUE
         OI    FLAGS,FGEOD         INDICATE END OF DATA
         SR    R0,R0               RETURN CODE = 0
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         SPACE 2
QGET1    DS    0H                  PICK UP NEXT CASHE RBA
         L     R2,CASHESEQ         LOAD NEW CASHE SEQ NUMBER
         SR    R3,R3               RBA = 0
         LA    R4,CASHDATA         POINT TO 1ST CASHE RECORD
         SPACE 2
QGET2    DS    0H                  SAVE CURRENT BUFFER ADDRESS
         LA    R3,1(R3)            POINT TO NEXT RBA
         STM   R2,R3,CBFRBAR       SAVE NEW RBA
         ST    R4,CBFUPTR          SAVE CURRENT RECORD ADDRESS
         ST    RCASHE,CASHECUR     SAVE CURRENT CASHE ADDRESS
         SR    R0,R0               RETURN CODE = 0
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         EJECT
QGETU    DS    0H                   GET UPDATE ROUTINE
         L     R1,RPLARG            LOAD RBA ADDRESS
         BAL   R14,QLOCATE          LINK AND FIND RECORD
         B     QGETUE               RETURNS HERE IF NOT FOUND
         LA    R2,2(R1)             POINT TO CASHE RECORD
         LH    R3,0(R1)             LOAD RECORD LENGTH
         LR    RLEN,R3              COPY RECORD LENGTH
         ICM   R3,8,=C' '           SET PAD CHARACTER
         MVCL  RADDR,R2             MOVE RECORD TO USER AREA
         ST    RLEN,RPLRLEN         STORE RECORD LENGTH IN RPL
         SR    R0,R0                RETURN CODE = 0
         B     SYNVSAM              GO TO VSAM EXIT ROUTINE
         SPACE 2
QGETUE   DS    0H                   GET UPDATE ERROR
         LA    R0,100               GET UPDATE ERROR
         B     SYNVSAM              GO TO VSAM EXIT ROUTINE
         EJECT
QPUT     DS    0H                  STORE INTERNAL TEXT RECORD
         L     RADDR,RPLAREA       LOAD RECORD ADDRESS
         LH    RLEN,RPLRLEN+2      LOAD RECORD LENGTH
         TM    RPLOPT2,RPLUPD      PUT UPDATE REQUEST
         BO    QPUTU               YES, THEN GO UPDATE
         L     RCASHE,CASHECUR     LOAD CURRENT CASHE POINTER
         LA    R3,2(RLEN)          LOAD NUMBER OF BYTES NEEDED
         C     R3,CASHENBL         COMPARE TO NUMBER OF BYTES LEFT
         BNH   QPUT0               IF NOT HIGH THEN RECORD WILL FIT
         GETMAIN R,LV=4088         ELSE GET NEW CASHE BUFFER
         ST    R1,CASHNEXT         CHAIN NEW CASHE TO OLD
         L     R2,CASHESEQ         LOAD CURRENT CASHE SEQ NO
         LA    R2,1(R2)            INCREMENT BY 1
         LR    RCASHE,R1           LOAD NEW CASHE ADDRESS
         ST    R2,CASHESEQ         SAVE NEW SEQUENCE NUMBER
         ST    RCASHE,CASHECUR     SAVE PTR TO CURRENT CASHE
         LA    R0,CASHDATA         LOAD CASHE DATA ADDRESS
         ST    R0,CASHADDR         SAVE ADDRESS OF NEXT AVAIL ENTRY
         LA    R0,4088-LCASHE      LOAD NUMBER OF BYTES AVAIL
         ST    R0,CASHENBL         SAVE NUMBER OF BYTES
         SPACE 2
QPUT0    DS    0H                  MOVE RECORD TO CASHE
         L     R2,CASHADDR         LOAD NEXT AVAIL ENTRY ADDR
         ST    R2,CBFUPTR          SAVE POINTER
         STH   RLEN,0(R2)          SAVE RECORD LENGTH
         LA    R2,2(R2)            POINT TO RECORD AREA
         LR    R3,RLEN             DUPLICATE RECORD LENGTH
         MVCL  R2,RADDR            MOVE RECORD TO CASHE
         LA    R2,0(RLEN,R2)       POINT TO NEXT AVAIL ENTRY
         ST    R2,CASHADDR         SAVE NEXT AVAIL ENTRY ADDR
         LA    R1,CASHE+4088       LOAD EOB ADDRESS
         SR    R1,R2               COMPUTE NUMBER OF BYTES LEFT
         ST    R1,CASHENBL         SAVE NUMBER OF BYTES LEFT
         L     R1,CASHERBA         LOAD RELATIVE RECORD NUMBER
         LA    R1,1(R1)            INCREMENT BY 1
         ST    R1,CASHERBA         SAVE NEW RBA
         MVC   RPLRBAR,CASHRBAR    RETURN ADDRESS TO USER
         SR    R0,R0               SET RETURN CODE TO USER
         B     SYNVSAM              GO RETURN TO CALLER
         EJECT
QPUTU    DS    0H                  PUT UPDATE REQUEST
         L     R1,RPLARG           LOAD RBA ADDRESS
         BAL   R14,QLOCATE         LINK AND LOCATE RECORD
         B     QPUTUE              RETURNS HERE IF NOT FOUND
         CH    RLEN,0(R1)          COMPARE RECORD LENGTHS
         BE    QPUTU0              IF EQUAL THEN OK
         LA    R0,RPLDLCER         RECORD LENGTH ERROR
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         SPACE 2
QPUTU0   DS    0H                  REPLACE RECORD
         LR    R3,RLEN             DUPLICATE LENGTH
         LA    R2,2(R1)            POINT TO RECORD
         MVCL  R2,RADDR            REPLACE RECORD
         SR    R0,R0               RETURN CODE = 0
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         SPACE 2
QPUTUE   DS    0H                  PUT UPDATE ERROR
         LA    R0,RPLINUPD         LOAD INVALID UPDATE RETURN CODE
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         EJECT
QPOINT   DS    0H                  POINT TO INTERNAL TEXT RECORD
         L     R1,RPLARG           LOAD RBA ADDRESS FOR POINT
         MVC   CBFRBAR,0(R1)       MOVE RBA ADDRESS
         NC    CBFRBAR,CBFRBAR     CHECK FOR START OF DS POS.
         BNZ   *+10                IF NOT, THEN SKIP NEXT STMT
         MVC   CBFRBA,=F'1'        ELSE SET TO 1
         LA    R1,CBFRBAR          LOAD RBA ADDRESS
         BAL   R14,QLOCATE         LINK TO LOCATE ROUTINE
         B     QPOINTE             RETURNS HERE IS NOT FOUND
         ST    R1,CBFUPTR          SAVE RECORD ADDRESS
         ST    RCASHE,CASHECUR     SAVE CASHE ADDRESS
         SR    R0,R0               RETURN CODE = 0
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         SPACE 2
QPOINTE  DS    0H                  POINT ERROR
         LA    R0,100              POINT ERROR
         B     SYNVSAM             GO TO VSAM EXIT ROUTINE
         EJECT
QLOCATE  DS    0H                  LOCATE A CASHE RECORD
         LM    R2,R3,0(R1)         LOAD SEQ# AND REL RECORD NUMBER
         L     RCASHE,CASHEPTR     POINT TO 1ST CASHE BUFFER
         SPACE 2
QLOCATE0 DS    0H                  FIND CASHE BUFFER
         C     R2,CASHESEQ         COMPARE CASHE BUFFER SEQ#
         BE    QLOCATE1            IF EQUAL THEN GOT BUFFER
         L     RCASHE,CASHNEXT     ELSE POINT TO NEXT BUFFER
         LTR   RCASHE,RCASHE       END OF CASHE BUFFERS?
         BCR   8,R14               YES, THEN RETURN AT ERROR OFFSET
         B     QLOCATE0            ELSE CONTINUE SEARCH
         SPACE 2
QLOCATE1 DS    0H                  CASHE BUFFER FOUND
         LA    R4,CASHDATA         POINT TO CASHE DATA AREA
         LTR   R3,R3               MAKE SURE RBA NOT ZERO
         BCR   8,R14               IF ZERO, THEN ERROR
         SPACE 2
QLOCATE2 DS    0H                  SEARCH FOR RELATIVE RECORD
         C     R4,CASHADDR         END OF BUFFER?
         BNL   0(R14)              IF EOB, THEN ERROR
         LR    R1,R4               SAVE CURRENT RECORD ADDRESS
         LH    R2,0(R4)            ELSE LOAD RECORD LENGTH
         LA    R4,2(R2,R4)         POINT TO NEXT ENTRY
         BCT   R3,QLOCATE2         LOOP R3 TIMES
         B     4(R14)              RETURN WITH RECORD ADDR IN R1
         SPACE 2
         LTORG
         TITLE 'CONVERTER/INTERPRETER VSAM SIMULATION EXIT'
***********************************************************************
*                                                                     *
* TITLE -      SYNTAX SIMULATED VSAM EXIT                             *
*                                                                     *
* FUNCTION -   SIMULATE VSAM RETURN AND ERROR HANDLING ROUTINES       *
*              TO PROCESS RETURNS TO THE CONVERTER FORM THE VSAM      *
*              SIMULATION ROUTINES.                                   *
*                                                                     *
***********************************************************************
         SPACE 2
SYNVSAM  DS    0H                 VSAM SIMULATED EXIT
         BALR  BASEREG,0          ESTABLISH BASE REGISTER
         USING *,BASEREG          SET BASE ADDRESS
         L     R13,4(R13)         RELOAD OLD SAVE AREA ADDRESS
         LTR   R0,R0              NORMAL EXIT?
         BZ    *+8                YES, THEN SKIP NEXT INSTR
         AL    R0,=A(RPLLOGER*65536) ELSE LOGICAL ERROR
         STCM  R0,7,RPLFDBK       SET COMPLETION CODE IN RPL
         MVI   RPLCMPON,2         SET COMPONENT ID
         SRL   R0,16              RIGHT JUSTIFY RPLRTNCD
         ST    R0,16(R13)         SET IN R15 SLOT IN SAVE AREA
         LA    R1,RPLECB          ASSUME INTERNAL ECB
         TM    RPLOPT1,RPLECBSW   TEST TO MAKE SURE
         BZ    *+8                SKIP IF INTERNAL
         L     R1,RPLECB          POINT TO EXTERNAL ECB
         MVI   0(R1),X'40'        POST THE ECB
         LTR   R0,R0              TEST FOR ERROR
         BZ    VSAMRET            IF NOT THEN GO RETURN
         L     R4,ACBEXLST        POINT TO ACB EXLST
         CL    R4,=F'1'           0 OR 1
         BNH   VSAMRET            GET OUT IF NO EXIT
         USING IFGEXLST,R4        SET EXLST ADDRESSIBILITY
         CLI   EXLID,EXLIDD       IS IDENTIFIER OK?
         BNE   VSAMRET            NO, THEN GET OUT
         LA    R2,EXLEODF         POINT TO EOD ENTRY
         LA    R3,EXLEODL         GET MIN. LENGTH FOR IT
         CLI   RPLRTNCD,RPLLOGER  LOGICAL ERROR
         BNE   VSAMRET            IF NOT LOGICAL ERROR THEN ?
         CLI   RPLERRCD,RPLEODER  TEST IF EOD
         BE    VSAMCEXL           IF EOD GO TAKE EXIT
         LA    R2,EXLLERF         POINT TO LOGICAL ERROR ENTRY
         LA    R2,EXLLERL         GET MIN LENGTH FOR IT
         EJECT
VSAMCEXL DS    0H                 TAKE EXLST EXIT
         CH    R3,EXLLEN          IS EXIT LIST LONG ENOUGH
         BH    VSAMRET            NO, THEN GET OUT
         USING IFGEXLEF,R2        SET ENTRY ADDRESSIBILITY
         TM    EXLFLAG,EXLPRES+EXLACTV ENTRY PRESENT OR ACTIVE?
         BNO   VSAMRET            NO, THEN NO USER EXIT
         ICM   R0,15,EXLEXITP     LOAD ADDRESS IN EXLST ENTRY
         TM    EXLFLAG,EXLLINK    LOAD REQUIRED?
         BZ    VSAMEXIT           NO, THEN GO TAKE EXIT
         LOAD  EPLOC=(0)          LOAD USERS EXIT ROUTINE
         STCM  R0,15,EXLEXITP     SAVE ADDRESS IN EXLST ENTRY
         NI    EXLFLAG,255-EXLLINK SHOW ENTRY POINTS TO CODE
         SPACE 2
VSAMEXIT DS    0H                 LINK TO EXIT
         LM    R1,R12,24(R13)     RELOAD USER REGISTERS
         LR    R15,R0             LOAD USERS EXIT ENTRY POINT
         BALR  R14,R15            TAKE USER EXIT
         SPACE 2
VSAMRET  DS    0H                 RETURN TO CALLER
         RETURN (14,12)           RETURN TO CALLER
         SPACE 3
         LTORG
         TITLE 'CONVERTER INTERNAL TEXT PROCESSOR'
***********************************************************************
*                                                                     *
* TITLE -      CONVERTER INTERFACE INTERNAL TEXT PROCESSOR            *
*                                                                     *
* FUNCTION -   1) PROVIDE SUPPORT FOR PROCESSING INSTREAM DATA        *
*              WITHOUT REQUIRING SPOOLING OPERATIONS.                 *
*              2) PROVIDE SUPPORT FOR SYSOUT DEFAULT MSGCLASSES       *
*              (*, $, 0, ETC).                                        *
*              3) SCAN THE JOB CARD FOR THE MSGCLASS PARAMETER.       *
*                                                                     *
***********************************************************************
         SPACE 2
SYNTXTX  DS    0H                  SYNTAX INTERNAL TEXT EXIT
         SAVE  (14,12)             SAVE CALLERS REGISTERS
         LR    BASEREG,R15         LOAD BASE REGISTER
         USING SYNTXTX,BASEREG     ESTABLIST ADDRESSIBILITY
         LR    R2,R1               SAVE PARAMETER LIST ADDR
         USING COMWA,RC            BASE FOR COMMON WA
         L     WORKREG,WANELPTR    LOAD NEL ADDRESS
         LA    R0,NELLIST-SYNTAXD  LOAD NEL OFFSET
         SR    WORKREG,R0          ESTABLISH ADDRESSIBILITY
         LA    R15,EXITSAVE        LOAD NEW SAVE AREA ADDRESS
         ST    R15,8(,R13)         CHAIN NEW SAVE AREA
         ST    R13,4(,R15)         CHAIN OLD SAVE AREA
         LR    R13,R15             LOAD O/S SAVE AREA REGISTER
         L     RTEXT,0(R2)         LOAD TEXT STRING ADDRESS
         USING TEXT,RTEXT          ESTABLISH ADDRESSIBILITY
         TM    STRINDCS,DDSTR      DD STATEMENT?
         BZ    SYNTEXIT            NO, THEN SKIP STATEMENT
         NI    FLAGS,255-FSUPRESS-FDATA CLEAR FLAGS FOR NEW STATEMENT
         TM    STRDINDC,DTXSYOUT   SYSOUT STATEMENT?
         BO    DDSYSOUT            YES, THEN GO PROCESS SYSOUT
         TM    STRDINDC,DTXSYSIN   SYSIN STATEMENT?
         BO    DDSYSIN             YES, THEN GO PROCESS SYSIN
         SPACE 3
SYNTEXIT DS    0H
         LR    R1,RTEXT            LOAD TEXT AREA ADDRESS
         ICM   R15,15,ETEXT        LOAD TEXT EXIT ADDRESS
         BZ    *+8                 IF ZERO THEN SKIP EXIT
         BAL   R14,SYNCHEX         EXTI TO PROGRAM
         L     R13,4(,R13)         RELOAD CALLERS SAVE AREA ADDRESS
         RETURN (14,12),T          EXIT
         EJECT
DDSYSIN  DS    0H                  PROCESS SYSIN DD STATEMENT
         SR    R1,R1               CLEAR SCRATCH REGISTER
         IC    R1,STRDKEY+2        LOAD LENGTH OF DDNAME PARM
         LA    R2,STRDKEY+3(R1)    LOAD ADDRESS OF * OR DATA PARM
         CLC   =X'015C',0(R2)      LENGTH = 1 AND *?
         BE    DDSYSDLM            YES, THEN DD *
         CLI   0(R2),4             LENGTH=4?
         BNE   SYNTEXIT            NO, THEN NOT DD DATA
         CLC   =C'DATA',1(R2)      CHECK FOR SYSIN DD DATA
         BNE   SYNTEXIT            NO, THEN NOT DD * OR DATA
         OI    FLAGS,FDATA         INDICATE DD DATA
         SPACE 2
DDSYSDLM DS    0H                  CHECK DLM=
         MVC   DLM,=C'/*'          INDICATE /* DLM
         SR    R15,R15             CLEAR PARM REGISTER
         ICM   R15,8,=AL1(DLMK)    INSERT DLM KEY
         LA    R14,STRDKEY         POINT TO START OF TEXT KEYS
         BAL   R7,LOCKEY           LINK AND LOCATE DSNAME KEY
         BZ    DDSYSINX            IF NOT FOUND GO EXIT
         SR    R15,R15             CLEAR LENGTH REGISTER
         IC    R15,2(R14)          INSERT DSNAME LENGTH
         MVC   DLM,=C'  '          CLEAR DLM
         BCTR  R15,0               ADJ LENGTH FOR EXECUTE
         MVC   DLM(0),3(R14)       MOVE DLM
         EX    R15,*-6             EXECUTE FOR PROPER LENGTH
         SPACE 2
DDSYSINX DS    0H                  EXIT SYSIN ROUTINE
         OI    FLAGS,FSUPRESS      SUPPRESS INPUT UNTIL DLM
         LH    R5,STRLTH           LOAD LENGHT OF TEXT STRING
         SLR   R2,R2               CLEAR LENGTH REGISTER
         IC    R2,STRDKEY+1        INSERT # OF FIELDS
         BCTR  R2,0                DECREMENT # OF POSITIONAL PARMS
         STC   R2,STRDKEY+1        SAVE NEW COUNT
         IC    R2,STRDKEY+2        LOAD LENGTH OF DDNAME PARM
         LA    R3,STRDKEY+3(R2)    LOAD ADDRESS OF * OR DATA PARM
         LA    R6,0(R5,RTEXT)      POINT TO END OF TEXT
         BCTR  R6,0                DELETE END OF TEXT KEY
         IC    R2,0(R3)            GET LENGTH OF * OR DATA PARM
         LA    R5,DDIENDKE-DDDSECT-1(R5) ADD LENGHT OF NEW TEXT - 1
         SLR   R5,R2               SUBTRACT LENGTH OF OLD TEXT - 1
         STH   R5,STRLTH           SAVE NEW TEXT LENGTH
         LA    R1,1(R3,R2)         GET ADDRESS OF 1ST BYTE TO BE MOVED
         SLR   R6,R1               COMPUTE LENGTH OF TEXT TO BE MOVED
         MVC   0(0,R3),0(R1)       MOVE TEXT
         EX    R6,*-6              EXECUTE FOR PROPER LENGTH
         LA    R1,0(R3,R6)         POINT TO END OF REMAINING TEXT
         MVC   0(XSYSINKL,R1),XSYSINK MOVE IN NEW PARAMETER
         B     SYNTEXIT            EXIT
         EJECT
DDSYSOUT DS    0H                  PROCESS SYSOUT DD STATEMENT
         SR    R15,R15             CLEAR KEY REGISTER
         ICM   R15,8,=AL1(SYSOUTK) INSERT SYSOUT= K
         LA    R14,STRDKEY         POINT TO FIRST KEY
         BAL   R7,LOCKEY           LINK AND LOCATE KEY
         TM    STRDINDC,DTXDUMMY   DUMMY SPECIFIED?
         BO    SYNTEXIT            YES, THEN SKIP DD STATEMENT
         CLI   3(R14),C'*'         SYSOUT=*?
         BE    *+12                YES, SKIP $ CHECK
         CLI   3(R14),C'$'         SYSOUT=$?
         BNE   SYNTEXIT            NO, THEN LEAVE IT UNCHANGED
         MVC   3(1,R14),MSGCL      SET SYSOUT CLASS = MSGCLASS
         B     SYNTEXIT            GO EXIT
         EJECT
LOCKEY   DS    0H                  LOCATE KEY WITHIN TEXT STRING
         SLR   R1,R1               CLEAR SCRATCH REGISTER
         SLR   R2,R2               CLEAR SCRATCH REGISTER
         SPACE 2
LOCKEY0  DS    0H                  LOAD NUMBER OF PARMS
         ICM   R1,1,1(R14)         SET R1 TO NUMBER OF PARMS
         LA    R14,2(R14)          GET ADDRESS OF FIRST PARM
         BZ    LOCKEY3             BRANCH IF NONE
         SPACE 2
LOCKEY1  DS    0H                  SET R2 TO PARM LENGTH
         ICM   R2,1,0(R14)         SET R2 TO PARM LENGTH
         BM    LOCKEY4             BRANCH IF SUBPARM COUNT
         LA    R14,0(R14,R2)       ELSE GET ADDRESS OF NEXT PARM
         SPACE 2
LOCKEY2  DS    0H                  SKIP OVER LENGTH BYTE
         LA    R14,1(R14)          SKIP OVER LENGTH BYTE
         BCT   R1,LOCKEY1          REPEAT IF MORE PARMS TO SKIP
         SPACE 2
LOCKEY3  DS    0H                  TEST FOR KEY TYPE
         CLI   0(R14),ENDK         TEST FOR KEY TYPE
         BCR   8,R7                RETURN IF END OF TEXT STRING
         CLM   R15,8,0(R14)        TEST FOR DESIRED KEY
         BNE   LOCKEY0             IF NOT KEY, CONTINUE SEARCH
         SLR   R1,R1               SET RETURN CODE TO ZERO
         BR    R7                  RETURN TO CALLING ROUTINE
         SPACE 2
LOCKEY4  DS    0H                  *
         SL    R2,=A(X'80')        CLEAR HI-ORDER BIT OF SUBPARM CT
         ALR   R1,R2               ADD SUBPARM COUNT TO PARM COUNT
         B     LOCKEY2             RESUME PARM FIELD SCAN
         EJECT
XSYSINK  DC    AL1(DSNAMEK,1,DDOENDKE-DDDSKEY-3)
         DC    C'JES2.JOB00001.SI0000'
         DC    AL1(SYSINCTK,1,4)
         DC    C'0001'
         DC    AL1(ENDK)
         SPACE 1
XSYSINKL EQU   *-XSYSINK           LENGTH OF DSN PARAMETER
         SPACE 2
XSYSOUTK DC    AL1(DSNAMEK,1,DDOENDKE-DDDSKEY-3)
         DC    C'JES2.JOB00001,SO0000'
         DC    AL1(ENDK)
         SPACE 1
XSYSOTKL EQU   *-XSYSOUTK          LENGTH OF DSN PARAMETER
         SPACE 2
         LTORG
         TITLE 'CONVERTER/INTERPRETER INTERFACE SYNCH EXIT'
SYNCHEX  DS    0H                  SYNCH EXIT EFFECTOR
         STM   R2,R14,PGMREGS      SAVE PROGRAM REGISTERS
         L     R5,ASVRB            LOAD SVRB ADDRESS
         USING RBSECT,R5           SET RB DSECT
         LM    R2,R13,RBGRS2       RELOAD REGS 2 - 13
         SYNCH (15)                EXIT TO PROGRAM
         L     R3,CVTPTR           LOAD CVT ADDRESS
         L     R4,CVTTCBP-CVT(,R3) LOAD TCB WORDS ADDRESS
         L     R4,4(,R4)           LOAD CURRENT TCB ADDRESS
         L     R5,TCBRBP-TCB(,R4)  LOAD CURRENT RB ADDRESS
         L     WORKREG,CISWA       RELOAD WORK AREA ADDRESS
         LM    R2,R14,PGMREGS      RESTORE SVC REGISTERS
         BR    R14                 RETURN TO CALLING ROUTINE
         TITLE 'CONVERTER/INTERPRETER INTERFACE DSECTS'
         PRINT NOGEN
         SPACE 3
         IEFQMNGR
         ORG
LQMPA    EQU   *-IOPARAMS
         SPACE 3
         IEFCOMWA
         SPACE 1
         ORG   COMWA+X'31D'
SWA      DS    C
SWB      DS    C
         SPACE 3
         PRINT GEN
         EJECT
         IEFVKEYS
         EJECT
         IEFTXTFT
         EJECT
         IKJTCB
         EJECT
         CVT   DSECT=YES
         EJECT
         PRINT NOGEN
         SPACE 2
         IHARB
         SPACE 2
         ORG   RBEXSAVE
CISWA    DS    A             WORK AREA ADDRESS
CIRETURN DS    A             SVC EXIT ADDRESS
PPLPDDN  DS    A             --> PROCLIB DDNAME
PPLOPT   DS    AL1           OPTION BYTE
PPLCONVP DS    AL3           --> CONVERSION PARAMETERS
PPLEXIT  DS    A             --> EXIT LIST
         SPACE 3
         IEESMCA
         SPACE 2
         IFGACB
         SPACE 2
         IFGRPL
         SPACE 2
         IFGEXLST
         SPACE 2
         IEZJSCB
         SPACE 2
JCT      DSECT
         IEFAJCTB
         SPACE 2
         PRINT GEN
         EJECT
         IEFJMR
         SPACE 2
LJMR     EQU   *-JMR               TOTAL JMR LENGTH
         EJECT
DDDSECT  DSECT                     DD CARD INTERNAL TEXT DSECT
DDDSKEY  DC    AL1(DSNAMEK,1,DDOENDKE-DDDSKEY-3)
DDJOBID  DC    C'JES2.JOB00001.S'
DDTYPE   DS    C                   SYSIN/SYSOUT TYPE (I OR O)
DDDSNUM  DS    CL4                 PERIPHERAL DATA SET NUMBER
DDOENDKE DS    C                   END OF TEXT FOR SYSOUT
         ORG   DDOENDKE            REDEFINE FOR SYSIN
DDCTKEY  DC    AL1(SYSINCTK,1,4)   SYSIN COUNT KEY SEQUENCE
DDINCT   DS    CL4                 SYSIN COUNT
DDIENDKE DS    C                   END OF TEXT FOR SYSIN
         SPACE 2
CASHE    DSECT
CASHNEXT DS    A             FORWARD CASHE POINTER
CASHADDR DS    A             ADDRESS OF NEXT AVAILABLE ENTRY
CASHENBL DS    A             NUMBER OF BYTES LEFT IN CASHE
         DS    A             *********************************
CASHRBAR DS    0D            RELATIVE BYTE ADDRESS
CASHESEQ DS    F             CASHE SEQUENCE NUMBER
CASHERBA DS    F             CURRENT/LAST RELATIVE RECORD NUMBER
CASHDATA DS    0D
LCASHE   EQU   *-CASHE
         SPACE 2
EXITLIST DSECT               EXIT LIST
EXTJCLE  DS    A             JCL EXIT ENTRY POINT ADDRESS
EXTMSGE  DS    A             MSG EXIT ENTRY POINT ADDRESS
EXTSTMTE DS    A             STMT IMAGE EXIT ENTRY POINT ADDRESS
EXTTEXTE DS    A             INTERNAL TEXT EXIT ENTRY POINT ADDRESS
EXTCTXTE DS    A             CONVERTED TEXT EXIT ENTRY POINT ADDRESS
EXTINTE  DS    A             INTERPRETED TEXT EXIT ENTRY POINT ADDRESS
         EJECT
SYNTAXD  DSECT
SAVE     DS    18F            PRIMARY SAVE AREA
EXITSAVE DS    18F                 EXIT SAVE AREA
PGMREGS  DS    16F                 PROGRAM REGISTERS
ASVRB    DS    A                   SVC SVRB ADDRESS
MSGCL    DS    C                   DEFAULT MSGCLASS
DLM      DS    CL2                 SYSIN DELIMITER
FLAGS    DS    H                   INTERNAL FLAGS
INOUTCT  DS    H                   SYSIN/SYSOUT COUNTER
         SPACE 2
CASHEPTR DS    A                   POINTER TO 1ST CASHE BUFFER
CASHECUR DS    A                   POINTER TO CURRENT CASHE
CBFUPTR  DS    A                   CASHE BUFFER UPDATE POINTER
CBFRBAR  DS    0D                  CASHE CURRENT RBA
CBFSEQ   DS    A                   CASHE CURRENT SEQUENCE NUMBER
CBFRBA   DS    A                   CASHE CURRENT RELATIVE RECORD
         SPACE 2
PROCDCB  DS    (LBSDCB)C           PROCLIB DCB
JCLACB   DS    (LACB)C             JCL ACB
TEXTACB  DS    (LACB)C             INTERNAL TEXT ACB
MSGACB   DS    (LACB)C             MSGACB
STMTACB  DS    (LACB)C             STMT IMAGE ACB
         SPACE 2
         DS    0F
QMPAAREA DS    XL(LQMPA)           QUEUE MANAGER PARAMETER AREA
         SPACE 2
         DS    0F
JMRAREA  DS    XL(LJMR)            AREA FOR JMR
         SPACE 2
EJCL     DS    A                   PARM ADDRESS
ESTMT    DS    A                   PARM ADDRESS
EMSG     DS    A                   PARM ADDRESS
ETEXT    DS    A                   PARM ADDRESS
ERCTXT   DS    A                   PARM ADDRESS
EINTPRET DS    A                   PARM ADDRESS
OPLIST   DS    A                   OPEN LIST
         SPACE 2
JCLCARD  DS    CL80                JCL CARD
         DS    0D                  ALIGN
         EJECT
         IEFNEL SUBCOM=C,EXITS=(TXT)
         SPACE 2
         ORG   NELJCLCB            REDEFINE NEL FOR INTERPRETER
NELJCT   DS    A                   PTR TO JCT IN SWA
NELOPSW2 DS    XL1                 OPTION SWITCHES - BYTE 2
         DS    CL7                 RESERVED
         ORG
         SPACE 2
CORESIZE EQU   *-SYNTAXD
         END
