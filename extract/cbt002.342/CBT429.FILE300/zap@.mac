./       ADD NAME=###DOC
         MACRO
         ###DOC
.*------------------------------------------------------------------*
.*       THIS MEMBER IS NOT REALLY A MACRO BUT A DOCUMENTATION      *
.*       MEMBER FOR THE MACRO MEMBER. THE REASON WHY I HAVE         *
.*       CHANGED THE './ ADD' CARDS TO '>< ADD' IS SO I CAN         *
.*       GENERATE MICROFICHE.  YOU NEED TO DO A MASS CHANGE OF      *
.*       '><' TO './'                                               *
.*                                                                  *
.*       JIM MARSHALL, CAPT, USAF (RET)                             *
.*------------------------------------------------------------------*
         MEND
./ ADD NAME=OACDROP  0100-81272-81272-2009-00050-00050-00000-UCLA
         MACRO
         OACDROP &PARMS
         GBLC  &USELAB(16)        SAVED PROGRAM LABELS
         GBLC  &USEREG(16)        SAVED REGISTER TABLE
         LCLA  &UNDX,&II          USE INDICES,TEMP USAGE
         LCLA  &PNDX,&DNDX        INPUT PARM,DROP STRING INDICES
         LCLB  &GOTREG,&DROPALL   HAVE REGS TO DROP,DROP ALL TO DO
         LCLC  &R(4),&B(4)        REGS TO DROP,PREVIOUS BASES FOR REGS
         LCLC  &BLANKS            BLANKS TO PAD DROP LINE TO COMMENTS
&DROPALL SETB  ((N'&SYSLIST EQ 0) OR ('&PARMS' EQ '')) SET DROPALL FLAG
.LP#SYS  AIF   (&DROPALL).LP#SAV  BIF DROP ALL IN PROGRESS
         AIF   (&PNDX GE N'&SYSLIST).CK#DROP LOOP TIL DONE WITH REGS
&PNDX    SETA  &PNDX+1            UP THE COMMA/REG INDEX
&UNDX    SETA  0                  RE-INITIALIZE USE ARRAY INDEX
.LP#SAV  ANOP                     VALID DROP REG CHECK LOOP
&UNDX    SETA  &UNDX+1            UP THE USE ARRAY COUNT
         AIF   (&DROPALL).CK#ALL  BIF DROP ALL IN PROGRESS
         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DROP#R BIF MATCH
         AIF   (&UNDX LT 16).LP#SAV LOOP FOR ALL ENTRIES IF NEEDED
         MNOTE 4,'REGISTER &SYSLIST(&PNDX) WAS NOT A USNGX OPERAND'
         AGO   .LP#SYS            CONTINUE
.CK#ALL  AIF   (&UNDX GT 16).CK#DROP BIF END OF SAVE TABLE/CHECK DROPS
         AIF   ('&USEREG(&UNDX)'  EQ '').LP#SAV BIF EMPTY SLOT
.DROP#R  AIF   (&DNDX EQ 0).DROP$R BIF NO PREVIOUS REGISTER/BASE
&R(&DNDX) SETC '&R(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS REG
&B(&DNDX) SETC '&B(&DNDX)'.','    APPEND COMMA AFTER PREVIOUS BASE
.DROP$R  ANOP
&DNDX    SETA  &DNDX+1            UP THE DROP STRING INDEX
&R(&DNDX) SETC '&USEREG(&UNDX)'   GET PREVIOUS REGISTER
&B(&DNDX) SETC '&USELAB(&UNDX)'   GET PREVIOUS BASE
&USEREG(&UNDX) SETC ''            BLANK THE SAVE TABLE REG FIELD
&USELAB(&UNDX) SETC ''            BLANK THE SAVE TABLE BASE FIELD
         AIF   (&DNDX GE 4).DO#DR BIF DROP LINE FULL
&GOTREG  SETB  1                  SAY HAVE SOMETHING TO DROP
         AGO   .LP#SYS            GO CHECK FOR &SYSLIST/TABLE END
.CK#DROP AIF   (NOT &GOTREG).EXIT SKIP THE DROP IF NOTHING TO DO
.* NOTE THAT THIS MACRO ASSUMES OPERAND/COMMENT COLUMNS 16 AND 35.
.DO#DR   ANOP
&BLANKS  SETC  ' '                SET ONE BLANK IN CASE TOO LONG
&II      SETA  (35-16)-K'&R(1)-K'&R(2)-K'&R(3)-K'&R(4) BLANK COUNT
         AIF   (&II LE 1).DO$DR   BIF ONE BLANK CORRECT
&BLANKS  SETC  '                  '(1,&II) ELSE SET CORRECT NUMBER
.DO$DR   DROP  &R(1)&R(2)&R(3)&R(4)&BLANKS&B(1)&B(2)&B(3)&B(4)
&GOTREG  SETB  0                  NOTHING TO DROP
.DROP#CL AIF   (&DNDX EQ 0).LP#SYS BIF CLEARING DONE
&R(&DNDX) SETC ''                 BLANK REG FIELD
&B(&DNDX) SETC ''                 BLANK BASE FIELD
&DNDX    SETA  &DNDX-1            DECREMENT INDEX
         AGO   .DROP#CL           CONTINUE
.EXIT    MEND
./ ADD NAME=OACGBLS  0100-81272-81272-2009-00004-00004-00000-UCLA
         GBLA  &OACPRTS
         GBLB  &OACPRTF
         GBLC  &OACPRT,&OACPRTG,&OACSTMX,&OACSTER
         GBLC  &OACNAME
./ ADD NAME=OACINNER 0100-81272-81272-2009-00452-00452-00000-UCLA
         MACRO
&LABEL   OACINNER &DUMMY,&F=,&FO=+0,&T=,&TO=+0,&L=4,&OP=MA,            X
               &SETCC=NO,&RS=R0,&RT=R15,&COM=''
         GBLC  &OACNAME
         LCLC  &S,&SRC,&SRC1,&SRCT
         LCLB  &SRCI
         LCLC  &G,&TGT,&TGT1,&TGTT
         LCLB  &TGTI
         LCLC  &C,&COMM,&ARGS,&OPR,&LEN
         LCLA  &P
         LCLB &CC
         AIF   ('&F' EQ '').MEND
&CC      SETB  ('&SETCC' EQ 'YES')
&OACNAME SETC  '&LABEL'
&LEN     SETC  '&L'
&COMM    SETC  '&COM'(2,K'&COM-2) STRIP OFF QUOTES
&G       SETC  '&T'
.TGT     ANOP
&C       SETC  '&G'(1,1)          GET FIRST CHAR OF SOURCE
         AIF   ('&C' NE '(').TGTA MUST BE A FORM ADDRESS
         AIF   (K'&G LT 5).TGTR   MUST BE R FORM ADDRESS
&C       SETC  '&G'(K'&G-2,3)     GET LAST THREE CHARS
         AIF   ('&C' NE ',I)').TGTR MUST BE R FORM ADDRESS
&TGTI    SETB  1                  MARK AS INDIRECT
&G       SETC  '&G'(2,K'&G-4)     EXTRACT ADDRESS
         AGO   .TGT               GO PROCESS THAT
.TGTR    ANOP                     ADDRESS IS R FORM
         AIF   ('&TO' EQ '+0').TGTR1 CHECK FOR OFFSET
         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'
         MNOTE 4,'WILL FORCE ADDRESS FORM'
&G       SETC  '0&G'              FORCE ADDR FORM
         AGO   .TGTA              IT IS ADDR FORM
.TGTR1   AIF   (NOT &TGTI).TGTR2
         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'
         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'
&G       SETC  '0&G'
         AGO   .TGTA              DO ADDRESS SCAN
.TGTR2   ANOP                     ITS REALLY (R) FORM
&TGTT    SETC  'R'                MARK TYPE
&TGT     SETC  '&G'(2,K'&G-2)     STRIP OFF PARENS
         AGO   .TGTEND
.TGTA    ANOP                     ADDRESS FORM
&C       SETC  '&G'(K'&G,1)       LOOK AT LAST CHAR
         AIF   ('&C' EQ ')').TGTAR IT IS A O(R) FORM ADDRESS
&TGTT    SETC  'A'
&TGT     SETC  '&G'
         AIF   ('&TO' EQ '+0').TGTEND
&TGT     SETC  '&G.&TO'
         AGO   .TGTEND
.TGTAR   ANOP                     ITS A 0(R) FORM ADDRESS
&P       SETA  K'&G               SCAN FOR THE LEFT PAREN
.TGTLP   AIF   (&P EQ 0).TGTSNTX
&C       SETC  '&G'(&P,1)
&P       SETA  &P-1
         AIF   ('&C' NE '(').TGTLP
&TGTT    SETC  'AR'
&TGT1    SETC  '&G'(&P+2,K'&G-&P+1) SAVE REG AND RIGHT PAREN
         AIF   ('&TO' NE '+0').TGTAR1
&TGT     SETC  '&G'(1,&P+1)
         AGO   .TGTEND
.TGTAR1  ANOP  MUST ADD OFFSETS
&TGT     SETC  '&G'(1,&P)
&TGT     SETC  '&TGT.&TO.('
         AGO   .TGTEND
.TGTSNTX MNOTE 12,'ILLEGAL SYNTAX: &T'
         MEXIT
.TGTEND  ANOP
&C       SETC  '&TGT  '(1,2)
         AIF   ('&C' NE '0+').TGTEND1
&TGT     SETC  '&TGT'(3,K'&TGT-2)
.TGTEND1 ANOP
&S       SETC  '&F'
.SRC     ANOP
&C       SETC  '&S'(1,1)          GET FIRST CHAR OF SOURCE
         AIF   ('&C' NE '(').SRCA MUST BE A FORM ADDRESS
         AIF   (K'&S LT 5).SRCR   MUST BE R FORM ADDRESS
&C       SETC  '&S'(K'&S-2,3)     GET LAST THREE CHARS
.* BREAK
         AIF   ('&C' NE ',I)').SRCR MUST BE R FORM ADDRESS
&SRCI    SETB  1                  MARK AS INDIRECT
&S       SETC  '&S'(2,K'&S-4)     EXTRACT ADDRESS
         AGO   .SRC               GO PROCESS THAT
.SRCR    ANOP                     ADDRESS IS R FORM
         AIF   ('&FO' EQ '+0').SRCR1 CHECK FOR OFFSET
         MNOTE 4,'ENCOUNTERED OFFSET FROM (R) FORM ADDRESS'
         MNOTE 4,'WILL FORCE ADDRESS FORM'
&S       SETC  '0&S'              FORCE ADDR FORM
         AGO   .SRCA              IT IS ADDR FORM
.SRCR1   AIF   (NOT &SRCI).SRCR2
         MNOTE 4,'ENCOUNTERED INDIRECT FROM (R)'
         MNOTE 4,'WILL FORCE INDIRECT FROM 0(R)'
&S       SETC  '0&S'
         AGO   .SRCA              DO ADDRESS SCAN
.SRCR2   ANOP                     ITS REALLY (R) FORM
&SRCT    SETC  'R'                MARK TYPE
&SRC     SETC  '&S'(2,K'&S-2)     STRIP OFF PARENS
         AGO   .SRCEND
.SRCA    ANOP                     ADDRESS FORM
&C       SETC  '&S'(K'&S,1)       LOOK AT LAST CHAR
         AIF   ('&C' EQ ')').SRCAR IT IS A O(R) FORM ADDRESS
&SRCT    SETC  'A'
&SRC     SETC  '&S'
         AIF   ('&FO' EQ '+0').SRCEND
&SRC     SETC  '&S.&FO'
         AGO   .SRCEND
.SRCAR   ANOP                     ITS A 0(R) FORM ADDRESS
&P       SETA  K'&S               SCAN FOR THE LEFT PAREN
.SRCLP   AIF   (&P EQ 0).SRCSNTX
&C       SETC  '&S'(&P,1)
&P       SETA  &P-1
         AIF   ('&C' NE '(').SRCLP
&SRCT    SETC  'A'
&SRC1    SETC  '&S'(&P+2,K'&S-&P+1) SAVE REG AND RIGHT PAREN
         AIF   ('&FO' NE '+0').SRCAR1
&SRC     SETC  '&S'
&SRC1    SETC  ''
         AGO   .SRCEND
.SRCAR1  ANOP  MUST ADD OFFSETS
&SRC     SETC  '&S'(1,&P)
&SRC     SETC  '&SRC.&FO.(&SRC1'
&SRC1    SETC  ''
         AGO   .SRCEND
.SRCSNTX MNOTE 12,'ILLEGAL SYNTAX: &F'
         MEXIT
.SRCEND  ANOP
&C       SETC  '&SRC  '(1,2)
         AIF   ('&C' NE '0+').SRCEND1
&SRC     SETC  '&SRC'(3,K'&SRC-2)
.SRCEND1 AIF   (NOT &TGTI).SIN    CHECK FOR TARGET INDIRECT
&ARGS    SETC  '&RT,&TGT.&TGT1'   BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).TI1
&ARGS    SETC  '&ARGS                   '(1,18)
.TI1     ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).TI2 CHECK FOR OVERFLOW
&OACNAME L     &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .TI3
.TI2     ANOP                     NO ROOM FOR COMMENT
&OACNAME L     &RT,&TGT.&TGT1
.TI3     ANOP
&OACNAME SETC  ''
&TGT     SETC  '0('               NEW TARGET
&TGT1    SETC  '&RT)'
&TGTT    SETC  'AR'               NEW TARGET TYPE
&TGTI    SETB  0
.SIN     AIF   (NOT &SRCI).OP     CHECK FOR SOURCE INDARECT
         AIF   ('&OP' EQ 'MA').SIMA SPECIAL CASE FOR MA, SRCI
         AIF   ('&OP' NE 'MAC').SIN1 MAC MAY ALSO BE SPECIAL
         AIF   ('&TGTT' EQ 'A' OR '&TGTT' EQ 'AR').SIMAC
.SIN1    ANOP
&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).SIN2
&ARGS    SETC  '&ARGS                   '(1,18)
.SIN2    ANOP
.* BREAK
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).SIN3 CHECK FOR OVERFLOW
&OACNAME L     &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .SIN4
.SIN3    ANOP                     NO ROOM FOR COMMENT
&OACNAME L     &RS,&SRC
.SIN4    ANOP
&OACNAME SETC  ''
&SRC     SETC  '0(&RS)'           NEW SOURCE
&SRCT    SETC  'A'                NEW SOURCE TYPE
&SRCI    SETB  0
         AGO   .OP
.SIMA    ANOP
&SRCI    SETB  0
         AIF   ('&TGTT' EQ 'R').L GENERATE LOAD INSTRUCTION
         AGO   .MVC               MA SRCI IS A MVC
.SIMAC   ANOP                     MAC SRCI IS MVC AND MVI
         AIF   ('&TGTT' EQ 'AR').SIMACAR
&C       SETC  '&TGT.(4),&SRC'     A FORM TARGET
         AGO   .SIMAC1
.SIMACAR ANOP
&C       SETC  '&TGT.4,&TGT1,&SRC' AR FROM TARGET
.SIMAC1  ANOP
&ARGS    SETC  '&C'               BUILD ARGS AND COMMENT
         AIF   (K'&ARGS GE 18).SIMAC2
&ARGS    SETC  '&ARGS                   '(1,18)
.SIMAC2  ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).SIMAC3 CHECK FOR OVERFLOW
&OACNAME MVC   &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .SIMAC4
.SIMAC3  ANOP                     NO ROOM FOR COMMENT
&OACNAME MVC   &C
.SIMAC4  ANOP
&OACNAME SETC  ''
         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE
&SRC     SETC  '&TGT,&TGT1'
         AIF   (&CC).OC
         MEXIT
.OP      ANOP
&C       SETC  '&TGTT'(1,1)
         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'R').OPRR   RR FORM INST
         AIF   ('&C' EQ 'R' AND '&SRCT' EQ 'A').OPRA
         AIF   ('&C' EQ 'A' AND '&SRCT' EQ 'R').OPAR
         AIF   ('&OP' EQ 'MA').LAST AA FORM
         AIF   ('&OP' EQ 'MAC').LAST LA ST
         AIF   ('&OP' EQ 'M').MVC
         AIF   ('&OP' EQ 'O').OC
         AIF   ('&OP' EQ 'X').XC
         AIF   ('&OP' EQ 'N').NC
         AIF   ('&OP' EQ 'CL').CLC
&LEN     SETC  '1'
         AIF   ('&OP' EQ 'MVI').MVI
         AIF   ('&OP' EQ 'OI').OI
         AIF   ('&OP' EQ 'XI').XI
         AIF   ('&OP' EQ 'NI').NI
         AIF   ('&OP' EQ 'CLI').CLI
         AIF   ('&OP' EQ 'TM').TM
.BADOP   MNOTE 12,'&OP IS UNSUPORTED WITH SUPPLIED ARGS'
         MEXIT
.OPRR    AIF   ('&OP' EQ 'MA').LR
         AIF   ('&OP' EQ 'MAC').LA
         AIF   ('&LEN' EQ '4').OPRR1
.RLENERR MNOTE 12,'INVALID LENGTH WITH R FORM ADDRESS'
         MEXIT
.OPRR1   AIF   ('&OP' EQ 'M').LR
         AIF   ('&OP' EQ 'O').OR
         AIF   ('&OP' EQ 'X').XR
         AIF   ('&OP' EQ 'N').NR
         AIF   ('&OP' EQ 'CL').CR
         AGO   .BADOP
.OPRA    AIF   ('&OP' EQ 'MA').LA
         AIF   ('&OP' EQ 'MAC').LA
         AIF   ('&OP' NE 'M').OPRA1
         AIF   ('&LEN' EQ '1').IC
.* BREAK
         AIF   ('&LEN' EQ '2').LH
         AIF   ('&LEN' EQ '4').L
         AGO   .RLENERR
.OPRA1   AIF   ('&LEN' EQ '4').OPRA4
         AIF   ('&LEN' NE '2').RLENERR
         AIF   ('&OP' EQ 'CL').CH
         AGO   .BADOP
.OPRA4   AIF   ('&OP' EQ 'O').O
         AIF   ('&OP' EQ 'X').X
         AIF   ('&OP' EQ 'N').N
         AIF   ('&OP' EQ 'CL').C
         AGO   .BADOP
.OPAR    AIF   ('&OP' EQ 'MA').ST
         AIF   ('&OP' EQ 'MAC').STMVI ST THEN MVI
         AIF   ('&OP' NE 'M').BADOP
         AIF   ('&LEN' EQ '1').STC
         AIF   ('&LEN' EQ '2').STH
         AIF   ('&LEN' EQ '4').ST
         AGO   .RLENERR
.LR      AIF   (&CC).LTR
         AIF   ('&TGT.&TGT1' NE '&SRC').LR1
         AIF   ('&OACNAME' EQ '').LR0
&OACNAME DC    0H'0'
         MEXIT
.LR1     ANOP
&OPR     SETC  'LR'
         AGO   .RR
.LTR     ANOP
&OPR     SETC  'LTR'
&CC      SETB  0
         AGO   .RR
.OR      ANOP
&OPR     SETC  'OR'
&CC      SETB  0
         AGO   .RR
.XR      ANOP
&OPR     SETC  'XR'
&CC      SETB  0
         AGO   .RR
.NR      ANOP
&OPR     SETC  'NR'
&CC      SETB  0
         AGO   .RR
.CR      ANOP
&OPR     SETC  'CR'
&CC      SETB  0
         AGO   .RR
.MVI     ANOP
&OPR     SETC  'MVI'
         AGO   .SI
.NI      ANOP
&OPR     SETC  'NI'
&CC      SETB  0
         AGO   .SI
.OI      ANOP
&OPR     SETC  'OI'
&CC      SETB  0
         AGO   .SI
.XI      ANOP
&OPR     SETC  'XI'
&CC      SETB  0
         AGO   .SI
.CLI     ANOP
&OPR     SETC  'CLI'
&CC      SETB  0
         AGO   .SI
.TM      ANOP
&OPR     SETC  'TM'
&CC      SETB  0
         AGO   .SI
.IC      ANOP
&OPR     SETC  'IC'
         AGO   .SR
.L       ANOP
&OPR     SETC  'L'
         AGO   .SR
.LH      ANOP
.* BREAK
&OPR     SETC  'LH'
         AGO   .SR
.LA      ANOP
&OPR     SETC  'LA'
&CC      SETB  0
&C       SETC  '&SRC'(1,2)
         AIF   ('&C' NE '0(').SR
         AIF   ('&OP' EQ 'MAC').SR
&SRC     SETC  '&SRC'(3,K'&SRC-3)
&SRCT    SETC  'R'
         AGO   .LR
.CH      ANOP
&OPR     SETC  'CH'
&CC      SETB  0
         AGO   .SR
.O       ANOP
&OPR     SETC  'O'
&CC      SETB  0
         AGO   .SR
.X       ANOP
&OPR     SETC  'X'
&CC      SETB  0
         AGO   .SR
.N       ANOP
&OPR     SETC  'N'
&CC      SETB  0
         AGO   .SR
.C       ANOP
&OPR     SETC  'C'
&CC      SETB  0
         AGO   .SR
.STC     ANOP
&OPR     SETC  'STC'
         AGO   .RS
.STH     ANOP
&OPR     SETC  'STH'
         AGO   .RS
.ST      ANOP
&OPR     SETC  'ST'
         AGO   .RS
.MVC     ANOP
&OPR     SETC  'MVC'
         AGO   .SS
.OC      ANOP
&OPR     SETC  'OC'
&CC      SETB  0
         AGO   .SS
.XC      ANOP
&OPR     SETC  'XC'
&CC      SETB  0
         AGO   .SS
.NC      ANOP
&OPR     SETC  'NC'
&CC      SETB  0
         AGO   .SS
.CLC     ANOP
&OPR     SETC  'CLC'
&CC      SETB  0
         AGO   .SS
.SI      ANOP
.RR      ANOP
.SR      ANOP
&ARGS    SETC  '&TGT.&TGT1,&SRC'
         AGO   .INSTGEN
.RS      ANOP
&ARGS    SETC  '&SRC,&TGT.&TGT1'
         AGO   .INSTGEN
.SS      AIF   ('&TGTT' EQ 'AR').SSAR
&ARGS    SETC  '&TGT.(&LEN),&SRC'
         AGO   .INSTGEN
.SSAR    ANOP
&ARGS    SETC  '&TGT.&LEN,&TGT1,&SRC'
.INSTGEN ANOP
&C       SETC  '&ARGS'            BUILD OPERANDS AND COMMENT
         AIF   (K'&C GE 18).INSTGN1
&C       SETC  '&C                   '(1,18)
.INSTGN1 ANOP
.* BREAK
&C       SETC  '&C &COMM'         TACK ON THE COMMENTS
         AIF   (K'&C GT 55).INSTGN2 CHECK FOR OVERFLOW
&OACNAME &OPR  &C
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .INSTGN3
.INSTGN2 ANOP                     NO ROOM FOR COMMENT
&OACNAME &OPR  &ARGS
.INSTGN3 ANOP
&OACNAME SETC  ''
         AIF   (&CC).INSTGN4      CHECK FOR SET CONDITION CODE
         MEXIT
.INSTGN4 AIF   ('&TGTT' EQ 'R').INSTGNR
&ARGS    SETC  '&ARGS'(1,K'&ARGS-K'&SRC) STRIP OFF OLD SRC
         CLC   &ARGS.&TGT.&TGT1
         MEXIT
.INSTGNR ANOP
         LTR   &TGT,&TGT
         MEXIT
.LAST    AIF   ('&OP' EQ 'MAC').LAST0
&C       SETC  '&SRC'(1,2)
         AIF   ('&C' NE '0(').LAST0
&SRC     SETC  '&SRC'(3,K'&SRC-3)
&SRCT    SETC  'R'
         AGO   .ST
.LAST0   ANOP
&ARGS    SETC  '&RS,&SRC'         BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).LAST1
&ARGS    SETC  '&ARGS                   '(1,18)
.LAST1   ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).LAST2 CHECK FOR OVERFLOW
&OACNAME LA    &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .LAST3
.LAST2   ANOP                     NO ROOM FOR COMMENT
&OACNAME LA    &RS,&SRC
.LAST3   ANOP
&OACNAME SETC  ''
         ST    &RS,&TGT.&TGT1
         MEXIT
.STMVI   ANOP
&ARGS    SETC  '&SRC,&TGT.&TGT1'  BUILD OPERANDS AND COMMENT
         AIF   (K'&ARGS GE 18).STMVI1
&ARGS    SETC  '&ARGS                   '(1,18)
.STMVI1  ANOP
&ARGS    SETC  '&ARGS &COMM'      TACK ON THE COMMENTS
         AIF   (K'&ARGS GT 55).STMVI2 CHECK FOR OVERFLOW
&OACNAME ST    &ARGS
&COMM    SETC  ''                 COMMENT ONLY ON FIRST LINE
         AGO   .STMVI3
.STMVI2  ANOP                     NO ROOM FOR COMMENT
&OACNAME ST    &SRC,&TGT.&TGT1
.STMVI3  ANOP
&OACNAME SETC  ''
         MVI   &TGT.&TGT1,0       CLEAR HIGH BYTE
         MEXIT
         AIF   (NOT &CC).MEND
&SRC     SETC  '&TGT.&TGT1'
&SRCT    SETC  'A'
&LEN     SETC  '4'
         AGO   .CLC
.MEND    MEND
./ ADD NAME=OACINUSE 0100-81272-81272-2009-00025-00025-00000-UCLA
         MACRO
         OACINUSE &DUMMY,&PRINT=
         COPY  OACGBLS
         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,REGISTERS USED
         LCLA  &UCNT                    USE INDEX
         LCLB  &GOTREG                  WHETHER WE FOUND REGS IN USE
         AIF   ((T'&PRINT EQ 'O') AND                                  @
               (NOT &OACPRTF)).GO#USE   SKIP PUSH IF NOT NEEDED
         OACPRTPM PRINT=&PRINT
.GO#USE  SPACE 1
         MNOTE *,'THE FOLLOWING REGISTER(S) ARE IN USE:'
         SPACE 1
.USELOOP ANOP                           USED REGS LOOP
&UCNT    SETA  &UCNT+1                  UP THE USE INDEX
         AIF   ('&USEREG(&UCNT)' EQ '').CHKEND THIS ENTRY IN USE?
         MNOTE *,'       &USELAB(&UCNT),&USEREG(&UCNT)'
&GOTREG  SETB  1                        SAY WE FOUND SOMETHING
.CHKEND  AIF   (&UCNT LT 16).USELOOP    CHECK FOR END OF ARRAY
         AIF   (&GOTREG).FINI           LEAVE IF WE HAD REGS IN USE
         MNOTE *,'       *** NONE ****'
.FINI    SPACE 2
         AIF   ((T'&PRINT EQ 'O') AND                                  @
               (NOT &OACPRTF)).EXIT     SKIP POP IF NOT NEEDED
         POP   PRINT
.EXIT    MEND
./ ADD NAME=OACPRTPM 0100-81272-81272-2009-00041-00041-00000-UCLA
         MACRO
         OACPRTPM &DUMMY,&PRINT=
.*
.*       SETS  VALUES OF &OACPRT AND &OACPRTS DEPENDING ON
.*       VALUES OF &OACPRTG, &OACPRTF, AND &PRINT
.*
.*       DOES  A PUSH PRINT AND A PRINT ON,GEN OR A
.*       PRINT OFF,NOGEN DEPENDING ON THE CALCULATED VALUE
.*       OF &OACPRT
.*
         COPY  OACGBLS
&OACPRT  SETC  '&OACPRTG'
         AIF   (&OACPRTF).L4
         AIF   ('&PRINT' EQ '').L1DEF
         AIF   ('&PRINT' NE 'ALL' ).L1
&OACPRT  SETC  'ALL'
         AGO   .L4
.L1      AIF   ('&PRINT' NE 'SHORT').L2
.L1DEF   ANOP                     DEFAULT PRINT VALUE
&OACPRT  SETC  'SHORT'
         AGO   .L4
.L2      AIF   ('&PRINT' EQ 'NONE').L3
         MNOTE 4,'UNRECOGNIZABLE PRINT VALUE ''NONE'' USED'
.L3      ANOP
&OACPRT  SETC  'NONE'
.L4      ANOP
         PUSH  PRINT
         AIF   ('&OACPRT' NE 'ALL').L5
&OACPRTS SETA  99
         AGO   .L8
.L5      AIF   ('&OACPRT' NE 'SHORT').L6
&OACPRTS SETA  1
         AGO   .L8
.L6      AIF   ('&OACPRT' EQ 'NONE').L7
         MNOTE 4,'UNRECOGNIZABLE VALUE OF &OACPRTG ''NONE'' SET'
&OACPRTG SETC  'NONE'
&OACPRT  SETC  '&OACPRTG'
.L7      ANOP
         PRINT OFF,GEN
&OACPRTS SETA  1
.L8      MEND
./ ADD NAME=OACTMP   0100-81272-81272-2009-00255-00255-00000-UCLA
         MACRO
&LBL     OACTMP &CMD=(0,0),&CBUF=,&PGM=,&PARM=,                        X
               &DCB=0,&TASKLIB=0,&CMDLIB=YES,                          X
               &EXEC=YES,&STACK=YES,&SCMD=NO,&STAX=YES,&CMDFAIL=MSG,   X
               &MF=I
         LCLA  &F,&F1,&A
         LCLC  &C
         LCLB  &CBF,&CBR,&CS,&CR1,&CR2,&PGF,&PGS,&PGR
         LCLB  &PRF,&PRS,&PRR,&HF,&HS,&HR
         LCLB  &DCBR,&DCB0,&TSKR
         LCLB  &STRS
         LCLB  &MFL,&MFI,&MFB,&MFE
         AIF   (('&LBL' EQ '') OR ('&MF' EQ 'L') ).L
&LBL     DS    0H
.L       AIF   ('&CBUF' EQ '').L1
&CBF     SETB  1
&F       SETA  X'80'
&C       SETC  '&CBUF'(1,1)
         AIF   ('&C' NE '(').L8
&CBR     SETB  1
         AGO   .L8
.L1      ANOP
&C       SETC  '&CMD(1)'(1,1)
         AIF   ('&C' NE '''').L2
&CS      SETB  1
&STRS    SETB  1
         AGO   .L4
.L2      AIF   ('&C' NE '(').L3
&CR1     SETB  1
.L3      ANOP
&C       SETC  '&CMD(2)'(1,1)
         AIF   ('&C' NE '(').L4
&CR2     SETB  1
.L4      AIF   ('&PGM' EQ '').L7A
&PGF     SETB  1
&F1      SETA  X'80'
&C       SETC  '&PGM'(1,1)
         AIF   ('&C' NE '''').L5
&PGS     SETB  1
&STRS    SETB  1
         AGO   .L6
.L5      AIF   ('&C' NE '(').L6
&PGR     SETB  1
.L6      AIF   ('&PARM' EQ '').L8
&PRF     SETB  1
&C       SETC  '&PARM'(1,1)
         AIF   ('&C' NE '''').L7
&PRS     SETB  1
&STRS    SETB  1
         AGO   .L8
.L7      AIF   ('&C' NE '(').L8
&PRR     SETB  1
         AGO   .L8
.L7A     AIF   ('&CMD(1)' NE '0').L8
         AIF   ('&MF(1)' EQ 'L').L8
         MNOTE 8,'CMD, CBUF, OR PGM MUST BE SPECIFIED'
         MEXIT
.L8      AIF   ('&DCB' NE 'ENV').L8A
&F       SETA  &F+X'40'
&DCB0    SETB  1
         AGO   .L9
.L8A     AIF   ('&DCB' NE '0').L8B
&DCB0    SETB  1
         AGO   .L9
.L8B     ANOP
&C       SETC  '&DCB'(1,1)
         AIF   ('&C' NE '(').L9
&DCBR    SETB  1
.L9      ANOP
&C       SETC  '&TASKLIB'(1,1)
         AIF   ('&C' NE '(').L10
&TSKR    SETB  1
.L10     AIF   ('&CMDLIB' NE 'NO').L11
&F       SETA  &F+X'20'
.L11     AIF   ('&EXEC'  NE 'NO').L12
&F       SETA  &F+X'10'
.L12     AIF   ('&STACK' NE 'NO').L13
&F       SETA  &F+X'02'
.L13     AIF   ('&SCMD' EQ 'NO').L14
&F       SETA  &F+X'08'
.L14     AIF   ('&STAX' NE 'NO').L15
&F       SETA  &F+X'04'
         AGO   .L17
.L15     AIF   ('&STAX' EQ 'YES').L17
&HF      SETB  1
&C       SETC  '&STAX'(1,1)
         AIF   ('&C' NE '''').L16
&HS      SETB  1
&STRS    SETB  1
         AGO   .L17
.L16     AIF   ('&C' NE '(').L17
&HR      SETB  1
.L17     AIF   ('&CMDFAIL' NE 'NOMSG').L18
&F       SETA  &F+X'01'
.L18     AIF   ('&MF' NE 'L').L19
&MFL     SETB  1
         AGO   .L23
.L19     AIF   ('&MF' NE 'I').L20
&MFI     SETB  1
         AGO   .L23
.L20     ANOP
&C       SETC  '&MF(1)'
         AIF   ('&C' NE 'B').L21
&MFB     SETB  1
         AGO   .L23
.L21     AIF   ('&C' NE 'E').L22
&MFE     SETB  1
         AGO   .L23
.L22     MNOTE 8,'UNRECOGNIZABE MF'
         MEXIT
.L23     AIF   (NOT &MFL).L37
         AIF   (NOT (&CBR OR &CR1 OR &CR2 OR &PGR OR &PRR OR &DCBR OR  X
               &TSKR)).L24
         MNOTE 8,'R FORM NOT ALOWED WITH MF=L'
         MEXIT
.L24     ANOP
&LBL     DS    0F                       FULLWORD ALIGNMENT
         DC    AL1(&F)                  FLAGS
         AIF   (NOT &DCB0).L25
         DC    AL3(0)                   DCB ADDR
         AGO   .L26
.L25     DC    AL3(&DCB)                DCB ADDR
.L26     AIF   (&PGF).L29
         AIF   (&CBF).L28
         AIF   (&CS).L27
         DC    AL1(&CMD(2))             CMD LNTH
         DC    AL3(&CMD(1))             CMD ADDR
         AGO   .L31
.L27     DC    AL1(L'TMPC&SYSNDX)       CMD LNTH
         DC    AL3(TMPC&SYSNDX)         CMD ADDR
         AGO   .L31
.L28     DC    AL4(&CBUF)               PTR TO CBUF
         AGO   .L31
.L29     AIF   (&PGS).L30
         DC    AL4(&PGM)                PGM NAME ADDR
         AGO   .L31
.L30     DC    AL4(TMPG&SYSNDX)         PGM NAME ADDR
.L31     DC    AL1(&F1)                 FLAGS
         DC    AL3(&TASKLIB)            TASKLIB
         AIF   (&PRF).L32
         DC    AL4(0)                   RETURN/COMPLETION CODE
         AGO   .L34
.L32     AIF   (&PRS).L33
         DC    AL4(&PARM)               PARM PTR/RETURN-COMPLETION CODE
         AGO   .L34
.L33     DC    AL4(TMPR&SYSNDX)         PARM PTR/RETURN-COMPLETION CODE
.L34     AIF   (&HF).L35
         DC    AL4(0)                   UNUSED HERALD FIELD
         AGO   .L38
.L35     AIF   (&HS).L36
         DC    AL4(&STAX)               HERALD/REPLY
         AGO   .L38
.L36     DC    AL4(TMPH&SYSNDX)         HERALD/REPLY
.L37     AIF   (NOT (&STRS OR &MFI)).L38
         B     TMPL&SYSNDX
.L38     AIF   (NOT &CS).L39
TMPC&SYSNDX DC C&CMD
.L39     AIF   (NOT &PGS).L40
TMPG&SYSNDX DC CL8&PGM                  PGM NAME
.L40     AIF   (NOT &PRS).L41
&A       SETA  K'&PARM
&A       SETA  &A-2
TMPR&SYSNDX DC 0F'0',XL1'80',AL3(TMPR&SYSNDX+6)
         DC    F'&A'
         DC    C&PARM
.L41     AIF   (NOT &HS).L42
&A       SETA  K'&STAX
&A       SETA  &A-2
TMPH&SYSNDX DC H'&A',C&STAX
.L42     AIF   (NOT &MFL).L43
         MEXIT
.L43     AIF   (NOT &MFI).L44
TMPT&SYSNDX DC 5F'0'                    CMD BLK FOR OACTMP
TMPL&SYSNDX LA 1,TMPT&SYSNDX GET TBL ADDR
         AGO   .L45A
.L44     AIF   (NOT &STRS).L45
TMPL&SYSNDX DS 0H
.L45     AIF   ('&MF(2)' EQ '(1)').L45A
         LA    1,&MF(2)                 GET TBL ADDR
.L45A    ANOP
         XC    0(20,1),0(1)             CLEAR TBL
.L46     AIF   (&DCBR).L47
         AIF   (&DCB0).L48
         LA    0,&DCB                   GET DCB ADDR
         ST    0,0(1)                   STORE IN TBL
         AGO   .L48
.L47     ST    &DCB(1),0(1)             STORE DCB ADDR
.L48     AIF   ('&F' EQ '0').L49
         MVI   0(1),&F                  MOVE IN FLAGS
.L49     AIF   (&PGF).L54
         AIF   (&CBF).L53A
         AIF   (&CS).L53
         AIF   (&CR1).L50
         LA    0,&CMD(1)                GET CMD ADDR
         ST    0,4(1)                   STORE IN LST
         AGO   .L51
.L50     ST    &CMD(1),4(1)
.L51     AIF   (&CR2).L52
         MVI   4(1),&CMD(2)             MOVE IN LNTH
         AGO   .L57
.L52     STC   &CMD(2),4(1)             STORE CMD LNTH
         AGO   .L57
.L53     LA    0,TMPC&SYSNDX            GET CMD ADDR
         ST    0,4(1)                   STORE IN TBL
         MVI   4(1),L'TMPC&SYSNDX       MOVE IN LNTH
         AGO   .L57
.L53A    AIF   (&CBR).L53B
         LA    0,&CBUF                  GET CBUF ADDR
         ST    0,4(1)                   STORE IN TBL
         AGO   .L57
.L53B    ST    &CBUF(1),4(1)            STORE CBUF ADDR
         AGO   .L57
.L54     AIF   (&PGS).L56
         AIF   (&PGR).L55
         LA    0,&PGM                   GET PGM NAME ADDR
         ST    0,4(1)                   STORE IN TABLE
         AGO   .L57
.L55     ST    &PGM(1),4(1)             STORE PGM NAME ADDR
         AGO   .L57
.L56     LA    0,TMPG&SYSNDX            GET PGM NAME ADDR
         ST    0,4(1)                   STORE IN TABLE
.L57     AIF   ('&TASKLIB' EQ '0').L59
         AIF   (&TSKR).L58
         LA    0,&TASKLIB               GET ADDR OF TSK DCB
         ST    0,8(1)                   STORE IN TAB
         AGO   .L59
.L58     ST    &TASKLIB(1),8(1)         STORE TSK DCB ADDR
.L59     AIF   ('&F1' EQ '0').L60
         MVI   8(1),&F1                 MOVE IN FLGS
.L60     AIF   (NOT &PRF).L63
         AIF   (&PRS).L62
         AIF   (&PRR).L61
         L     0,&PARM                  GET PARM ADDR
         ST    0,12(1)                  STORE IN TABLE
         AGO   .L63
.L61     ST    &PARM(1),12(1)           ST PRM ADDR IN TABLE
         AGO   .L63
.L62     LA    0,TMPR&SYSNDX            GET PARM ADDR
         ST    0,12(1)                  STORE IN TABLE
.L63     AIF   (NOT &HF).L67
         AIF   (&HS).L65
         AIF   (&HR).L64
         LA    0,&STAX                  GET HERALD ADDR
         ST    0,16(1)                  STORE IN TABLE
         AGO   .L67
.L64     ST    &STAX(1),16(1)           STORE HERALD ADDR
         AGO   .L67
.L65     LA    0,TMPH&SYSNDX            GET HERALD ADDR
         ST    0,16(1)                  STORE IN TBL
.L67     AIF   (&MFB).L68
         LINK  EP=OACTMP
.L68     MEND
./ ADD NAME=OACUSING 0100-81272-81272-2009-00062-00062-00000-UCLA
         MACRO
         OACUSING &PARMS
         GBLC  &USELAB(16),&USEREG(16)  PGM LABELS,USE REGISTERS
         LCLA  &RCNT,&PNDX,&UNDX        # OF OPERANDS,PARM/USE INDICES
         LCLA  &TP1,&HOLE               TEMP WORK,1ST UNUSED SAVE ENTRY
         LCLB  &GOTREG                  WHETHER TO DO USING OR NOT
         LCLC  &CHR1,&CHR2,&C(16)       TEMPORARY WORK CHARS,COMMAS
         LCLC  &R(16),&S                REGS
         LCLC  &U,&V,&W                 R(15),C(16),R(16)
&PNDX    SETA  1                        SET UP PARM STRING INDEX
&RCNT    SETA  N'&SYSLIST               GET NUMBER OF OPERANDS
         AIF   (&RCNT LE 1).ERR01       TOO FEW INPUT PARAMETERS
         AIF   (&RCNT LE 17).SYS1#CK    CONTINUE IF LOW ENOUGH
         MNOTE 4,'TOO MANY INPUT PARAMETERS. ONLY 17 PROCESSED'
&RCNT    SETA  17                       SET MAX ALLOWABLE
.SYS1#CK ANOP
&S       SETC  '&SYSLIST(1)'            SET FOR SHORTER STRING BELOW
.COMLOOP ANOP
&PNDX    SETA  &PNDX+1                  INCREMENT INPUT STRING INDEX
&UNDX    SETA  0                        INITIALIZE USE INDEX
&HOLE    SETA  0                        INITIALIZE UNUSED ENTRY INDEX
.USELOOP AIF   ('&SYSLIST(&PNDX)' EQ '').CHK#END BR IF NULL STRING
&UNDX    SETA  &UNDX+1                  UP THE USE INDEX
         AIF   ('&USEREG(&UNDX)' EQ '&SYSLIST(&PNDX)').DO#USE PREVUSE?
         AIF   ((&HOLE NE 0) OR ('&USEREG(&UNDX)' NE '')).CHKEND
.* WE BRANCH TO CHKEND IF WE ALREADY HAVE A HOLE OR NO HOLE EXISTS HERE
&HOLE    SETA  &UNDX                    KEEP THE SAVE TABLE FREE INDEX
.CHKEND  AIF   (&UNDX LT 16).USELOOP    LOOP FOR ALL ENTRIES
&UNDX    SETA  &HOLE                    GET FREE ENTRY INDEX IN CASE
         AIF   (&HOLE NE 0).DO#USE1     BRANCH IF SPACE FOR ENTRY
         MNOTE 4,'OACUSING SAVE TABLE FULL. OPERAND TRUNCATED'
         AGO   .USINGGO                 GO DO JUST WHAT WE CAN
.DO#USE  ANOP
&CHR1    SETC  '********'(1,K'&SYSLIST(&PNDX)) STARS FOR THE REG
&CHR2    SETC  '****************'(1,K'&USELAB(&UNDX)) MAX 16 CHAR LABEL
         MNOTE *,'*********&CHR1*********************&CHR2'
         MNOTE *,'REGISTER &SYSLIST(&PNDX) PREVIOUSLY BASED ON &USELAB(@
               &UNDX)'
         MNOTE *,'*********&CHR1*********************&CHR2'
.DO#USE1 ANOP                           LOG THE REG USE HERE
&CHR1    SETC  '&SYSLIST(1)'            GET A DEFAULT LABEL
         AIF   (&PNDX EQ 2).SETLAB      IF FIRST REG, NO +NNNN TO ADD
&TP1     SETA  (&PNDX-2)*4096           ELSE GET ADDED AMOUNT
&CHR1    SETC  '&CHR1'.'+'.'&TP1'       APPEND THE +NN FOR EXTRA REGS
.SETLAB  ANOP                           MOVE IN THE SAVE LABELS HERE
&USELAB(&UNDX) SETC '&CHR1'             SET SAVE TABLE DATA
&USEREG(&UNDX) SETC '&SYSLIST(&PNDX)'   GET THE REG VALUE IN SAVEAREA
&R(&PNDX-1) SETC '&SYSLIST(&PNDX)'      GET THE REG VALUE FOR USING
&C(&PNDX-1) SETC ','                    AND A LEADING COMMA ALSO
&GOTREG  SETB  1                        SAY WE CAN DO USING
.CHK#END AIF   (&PNDX LT &RCNT).COMLOOP LOOP FOR ALL ENTRIES
.USINGGO AIF   (NOT &GOTREG).EXIT       NOW TELL ASSEMBLER IF WE CAN
&U       SETC  '&R(15)'                 SO WE HAVE A SHORTER STRING
&V       SETC  '&C(16)'                 SO WE HAVE A SHORTER STRING
&W       SETC  '&R(16)'                 SO WE HAVE A SHORTER STRING
         USING &S&C(1)&R(1)&C(2)&R(2)&C(3)&R(3)&C(4)&R(4)&C(5)&R(5)&C(6@
               )&R(6)&C(7)&R(7)&C(8)&R(8)&C(9)&R(9)&C(10)&R(10)&C(11)&R@
               (11)&C(12)&R(12)&C(13)&R(13)&C(14)&R(14)&C(15)&U&V&W
         MEXIT
.ERR01   MNOTE 4,'MISSING INPUT PARAMETERS'
         MEXIT
.EXIT    MEND
./ ADD NAME=IECSDSL1 0100-81272-81272-2020-00247-00247-00000-AMODGEN
*/*      %INCLUDE SYSLIB(IECSDSL1)                                   */
* %      GOTO PLSDSCB;                  /*  GO TO THE PL/S VERSION   */
*/* **************************************************************** */
*/*                                                                  */
*/*                IECSDSL1 --- DSCB MAPPING MACRO                   */
*/*                                                                  */
*/* **************************************************************** */
*/*                                                                  */
*/*              ASSEMBLY LANGUAGE VERSION OF IECSDSL1               */
*/*                                                                  */
*/*      ******************************************************      */
*/*                                                                  */
*/*      THE FORMAT OF EACH OF THE DATA SET CONTROL                  */
*/*      BLOCKS (DSCB'S) CAN BE GENERATED BY CODING                  */
*/*                    IECSDSL1 (N)                                  */
*/*      WHERE N IS A NUMBER 1 - 6 CORRESPONDING TO THE              */
*/*      FORMAT NUMBER OF THE DSCB TO BE MAPPED.  MORE               */
*/*      THAN ONE DSCB CAN BE MAPPED PER MACRO CALL BY               */
*/*      SEPARATING THE FORMAT NUMBERS BY COMMAS.  THE               */
*/*      DSCB'S THUS GENERATED WILL BE MAPPED IN THE                 */
*/*      ORDER IN WHICH THE FORMAT NUMBERS ARE CODED.                */
*/*                                                                  */
*/*      ******************************************************      */
*/*                                                                  */
         MACRO
         IECSDSL1 &PARA
.*
.*       MACRO DELETIONS/CHANGES FOR SU60                      @G60ASBJ
.*                                                             @G60ASBJ
.*C 100000,534000                                              @G60ASBJ
.*A 100500-101000,116100-117700,534400-535200,550080-551920    @G60ASBJ
.*C 551920                                                     @ZA46658
         LCLA  &CTR
&CTR     SETA  1
.* LABEL DS2LPDT INSERTED IN RELEASE 21.6 FOR APAR 49466.
.LOOP    AIF   (&CTR GT N'&PARA).ENDOFIT
         AIF   ('&PARA(&CTR)' EQ '1').FIRSTON
         AIF   ('&PARA(&CTR)' EQ '2').SECNDON
         AIF   ('&PARA(&CTR)' EQ '3').THIRDON
         AIF   ('&PARA(&CTR)' EQ '4').FORTHON
         AIF   ('&PARA(&CTR)' EQ '5').FIFTHON
         AIF   ('&PARA(&CTR)' EQ '6').SIXTHON
         AGO   .ERROR
.FIRSTON ANOP
IECSDSL1 EQU   *                   FORMAT 1 DSCB
IECSDSF1 EQU   IECSDSL1
DS1DSNAM DS    CL44                DATA SET NAME
DS1FMTID DS    CL1                 FORMAT IDENTIFIER
DS1DSSN  DS    CL6                 DATA SET SERIAL NUMBER
DS1VOLSQ DS    XL2                 VOLUME SEQUENCE NUMBER
DS1CREDT DS    XL3                 CREATION DATE
DS1EXPDT DS    XL3                 EXPIRATION DATE
DS1NOEPV DS    XL1                 NUMBER OF EXTENTS ON VOLUME
DS1NOBDB DS    XL1                 NUMBER OF BYTES USED IN LAST
*                                     DIRECTORY BLOCK
         DS    XL1                 RESERVED
DS1SYSCD DS    CL13                SYSTEM CODE
DS1REFD  DS    XL3                 DATE LAST REFERENCED OR    @G60ASBJ
*                                     ZERO IF NOT MAINTAINED  @G60ASBJ
         DS    XL4                 RESERVED                   @G60ASBJ
DS1DSORG DS    XL2                 DATA SET ORGANIZATION
DS1RECFM DS    XL1                 RECORD FORMAT
DS1OPTCD DS    XL1                 OPTION CODE
DS1BLKL  DS    XL2                 BLOCK LENGTH
DS1LRECL DS    XL2                 RECORD LENGTH
DS1KEYL  DS    XL1                 KEY LENGTH
DS1RKP   DS    XL2                 RELATIVE KEY POSITION
DS1DSIND DS    XL1                 DATA SET INDICATORS
DS1IND80 EQU   X'80'               LAST VOLUME ON WHICH A DATA@G60ASBJ
*                                  SET RESIDES                @G60ASBJ
DS1IND40 EQU   X'40'               DATA SET IS RACF DEFINED   @G60ASBJ
DS1IND20 EQU   X'20'               BLOCK LENGTH IS A MULTIPLE @G60ASBJ
*                                  OF 8 BYTES                 @G60ASBJ
DS1IND10 EQU   X'10'               PASSWORD IS REQUIRED TO    @G60ASBJ
*                                  READ OR WRITE OR BOTH-SEE  @G60ASBJ
*                                  DS1IND04                   @G60ASBJ
DS1IND08 EQU   X'08'               RESERVED                   @G60ASBJ
DS1IND04 EQU   X'04'               IF DS1IND10 IS 1 THEN IF   @G60ASBJ
*                                  DS1IND04 IS . . .          @G60ASBJ
*                                  1-PASSWORD REQUIRED TO     @G60ASBJ
*                                  WRITE BUT NOT TO READ      @G60ASBJ
*                                  0-PASSWORD REQUIRED TO     @G60ASBJ
*                                  WRITE AND TO READ          @G60ASBJ
DS1IND02 EQU   X'02'               DATASET OPENED FOR OTHER   @G60ASBJ
*                                  THAN INPUT SINCE LAST      @G60ASBJ
*                                  BACKUP COPY MADE.          @G60ASBJ
DS1DSCHA EQU   DS1IND02            SAME USE AS BIT DS1IND02   @G60ASBJ
DS1IND01 EQU   X'01'               RESERVED                   @G60ASBJ
DS1SCALO DS    XL4                 SECONDARY ALLOCATION
DS1LSTAR DS    XL3                 LAST USED TRACK AND BLOCK ON TRACK
DS1TRBAL DS    XL2                 BYTES REMAINING ON LAST TRACK USED
         DS    XL2                 RESERVED
DS1EXT1  DS    XL10                FIRST EXTENT DESCRIPTION
*        FIRST BYTE                EXTENT TYPE INDICATOR
*        SECOND BYTE               EXTENT SEQUENCE NUMBER
*        THIRD - SIXTH BYTES       LOWER LIMIT
*        SEVENTH - TENTH BYTES     UPPER LIMIT
DS1EXT2  DS    XL10                SECOND EXTENT DESCRIPTION
DS1EXT3  DS    XL10                THIRD EXTENT DESCRIPTION
DS1PTRDS DS    XL5                 POSSIBLE PTR TO A FORMAT 2 OR 3 DSCB
DS1END   EQU   *
&CTR     SETA  &CTR+1
         AGO   .LOOP
.SECNDON ANOP
IECSDSL2 EQU   *                   FORMAT 2 DSCB
IECSDSF2 EQU   IECSDSL2
         DS    XL1                 KEY IDENTIFIER
DS22MIND DS    XL7                 ADDRESS OF 2ND LEVEL MASTER INDEX
DS2L2MEN DS    XL5                 LAST 2ND LEVEL MASTER INDEX ENTRY
DS23MIND DS    XL7                 ADDRESS OF 3RD LEVEL MASTER INDEX
DS2L3MIN DS    XL5                 LAST 3RD LEVEL MASTER INDEX ENTRY
         DS    XL11                RESERVED
DS2LPDT  DS    XL8                 LAST PRIME TRACK ON LAST PRIME CYL
DS2FMTID DS    CL1                 FORMAT IDENTIFIER
DS2NOLEV DS    XL1                 NUMBER OF INDEX LEVELS
DS2DVIND DS    XL1                 HIGH LEVEL INDEX DEVELOPMENT
*                                     INDICATOR
DS21RCYL DS    XL3                 FIRST DATA RECORD IN CYLINDER
DS2LTCYL DS    XL2                 LAST DATA TRACK IN CYLINDER
DS2CYLOV DS    XL1                 NUMBER OF TRACKS FOR CYLINDER
*                                     OVERFLOW
DS2HIRIN DS    XL1                 HIGHEST 'R' ON HIGH-LEVEL INDEX TRK
DS2HIRPR DS    XL1                 HIGHEST 'R' ON PRIME DATA TRACK
DS2HIROV DS    XL1                 HIGHEST 'R' ON OVERFLOW DATA TRACK
DS2RSHTR DS    XL1                 'R' OF LAST DATA RECORD ON SHARED
*                                     TRACK
DS2HIRTI DS    XL1                 HIGHEST 'R' ON UNSHARED TRACK OF
*                                     TRACK INDEX
DS2HIIOV DS    XL1                 HIGHEST 'R' FOR INDEPENDENT OVERFLOW
*                                     DATA TRACKS
DS2TAGDT DS    XL2                 TAG DELETION COUNT
DS2RORG3 DS    XL3                 NON-FIRST OVERFLOW REFERENCE COUNT
DS2NOBYT DS    XL2                 NUMBER OF BYTES FOR HIGHEST-LEVEL
*                                     INDEX
DS2NOTRK DS    XL1                 NUMBER OF TRACKS FOR HIGHEST-LEVEL
*                                     INDEX
DS2PRCTR DS    XL4                 PRIME RECORD COUNT
DS2STIND DS    XL1                 STATUS INDICATORS
DS2CYLAD DS    XL7                 ADDRESS OF CYLINDER INDEX
DS2ADLIN DS    XL7                 ADDRESS OF LOWEST LEVEL MASTER INDEX
DS2ADHIN DS    XL7                 ADDRESS OF HIGHEST LEVEL MASTER
*                                     INDEX
DS2LPRAD DS    XL8                 LAST PRIME DATA RECORD ADDRESS
DS2LTRAD DS    XL5                 LAST TRACK INDEX ENTRY ADDRESS
DS2LCYAD DS    XL5                 LAST CYLINDER INDEX ENTRY ADDRESS
DS2LMSAD DS    XL5                 LAST MASTER INDEX ENTRY ADDRESS
DS2LOVAD DS    XL8                 LAST INDEPENDENT OVERFLOW RECORD
*                                     ADDRESS
DS2BYOVL DS    XL2                 BYTES REMAINING ON OVERFLOW TRACK
DS2RORG2 DS    XL2                 TRACKS REMAINING IN INDEPENDENT
*                                     OVERFLOW AREA
DS2OVRCT DS    XL2                 OVERFLOW RECORD COUNT
DS2RORG1 DS    XL2                 CYLINDER OVERFLOW AREA COUNT
DS2NIRT  DS    XL3                 DUMMY TRACK INDEX ENTRY ADDRESS
DS2PTRDS DS    XL5                 POSSIBLE POINTER TO A FORMAT 3 DSCB
DS2END   EQU   *
&CTR     SETA  &CTR+1
         AGO   .LOOP
.THIRDON ANOP
IECSDSL3 EQU   *                   FORMAT 3 DSCB
IECSDSF3 EQU   IECSDSL3
         DS    XL4                 KEY IDENTIFIER
DS3EXTNT DS    XL40                FOUR EXTENT DESCRIPTIONS
*        FIRST BYTE                EXTENT TYPE INDICATOR
*        SECOND BYTE               EXTENT SEQUENCE NUMBER
*        THIRD - SIXTH BYTES       LOWER LIMIT
*        SEVENTH - TENTH BYTES     UPPER LIMIT
DS3FMTID DS    CL1                 FORMAT IDENTIFIER
DS3ADEXT DS    XL90                NINE ADDITIONAL EXTENT DESCRIPTIONS
DS3PTRDS DS    XL5                 RESERVED
DS3END   EQU   *
&CTR     SETA  &CTR+1
         AGO   .LOOP
.FORTHON ANOP
IECSDSL4 EQU   *                   FORMAT 4 DSCB
IECSDSF4 EQU   IECSDSL4
DS4IDFMT DS    CL1                 FORMAT IDENTIFIER
DS4HPCHR DS    XL5                 HIGHEST ADDRESS OF A FORMAT 1 DSCB
DS4DSREC DS    XL2                 NUMBER OF AVAILABLE DSCB'S
DS4HCCHH DS    XL4                 CCHH OF NEXT AVAILABLE ALTERNATE TRK
DS4NOATK DS    XL2                 NUMBER OF REMAINING ALTERNATE TRACKS
DS4VTOCI DS    XL1                 VTOC INDICATORS
DS4DOSBT EQU   X'80'               DOS BIT
DS4DSTKP EQU   X'10'               DOS STACKED PACK
DS4DOCVT EQU   X'08'               DOS CONVERTED VTOC
DS4DIRF  EQU   X'04'               DIRF BIT
DS4DICVT EQU   X'02'               DIRF RECLAIMED
DS4NOEXT DS    XL1                 NUMBER OF EXTENTS IN THE VTOC
         DS    XL2                 RESERVED
DS4DEVCT DS    0XL14               DEVICE CONSTANTS
DS4DEVSZ DS    XL4                 DEVICE SIZE
DS4DEVTK DS    XL2                 DEVICE TRACK LENGTH
DS4DEVOV DS    0XL2                KEYED RECORD OVERHEAD
DS4DEVI  DS    XL1                    NON-LAST KEYED RECORD OVERHEAD
DS4DEVL  DS    XL1                    LAST KEYED RECORD OVERHEAD
DS4DEVK  DS    XL1                 NON-KEYED RECORD OVERHEAD
*                                     DIFFERENTIAL
DS4DEVFG DS    XL1                 FLAG BYTE
DS4DEVTL DS    XL2                 DEVICE TOLERANCE
DS4DEVDT DS    XL1                 NUMBER OF DSCB'S PER TRACK
DS4DEVDB DS    XL1                 NUMBER OF DIRECTORY BLOCKS PER TRACK
DS4AMTIM DS    XL8                 VSAM TIME STAMP
DS4AMCAT DS    0XL3                VSAM CATALOG INDICATOR
DS4VSIND DS    XL1                 VSAM INDICATORS
DS4VSCRA DS    XL2                 RELATIVE TRACK LOCATION OF THE CRA
DS4R2TIM DS    XL8                 VSAM VOLUME/CATALOG MATCH
*                                  TIME STAMP
         DS    XL5                 RESERVED
DS4F6PTR DS    XL5                 POINTER TO FIRST FORMAT 6 DSCB
DS4VTOCE DS    XL10                VTOC EXTENT DESCRIPTION
         DS    XL25                RESERVED
DS4END   EQU   *
&CTR     SETA  &CTR+1
         AGO   .LOOP
.FIFTHON ANOP
IECSDSL5 EQU   *                   FORMAT 5 DSCB
IECSDSF5 EQU   IECSDSL5
DS5KEYID DS    XL4                 KEY IDENTIFIER
DS5AVEXT DS    XL5                 AVAILABLE EXTENT
*        BYTES 1 - 2     RELATIVE TRACK ADDRESS OF THE FIRST TRACK
*                        IN THE EXTENT
*        BYTES 3 - 4     NUMBER OF UNUSED CYLINDERS IN THE EXTENT
*        BYTE  5         NUMBER OF ADDITIONAL UNUSED TRACKS
DS5EXTAV DS    XL35                SEVEN AVAILABLE EXTENTS
DS5FMTID DS    CL1                 FORMAT IDENTIFIER
DS5MAVET DS    XL90                EIGHTEEN AVAILABLE EXTENTS
DS5PTRDS DS    XL5                 POINTER TO NEXT FORMAT 5 DSCB
DS5END   EQU   *
&CTR     SETA  &CTR+1
         AGO   .LOOP
.SIXTHON ANOP
IECSDSL6 EQU   *                   FORMAT 6 DSCB
IECSDSF6 EQU   IECSDSL6
DS6KEYID DS    XL4                 KEY IDENTIFIER
DS6AVEXT DS    XL5                 SHARED EXTENT DESCRIPTION
*        BYTES 1 - 2     RELATIVE TRACK ADDRESS OF THE FIRST CYLINDER
*        BYTES 3 - 4     NUMBER OF FULL CYLINDERS BEING SHARED
*        BYTE  5         NUMBER OF DATA SETS SHARING THE EXTENT
DS6EXTAV DS    XL35                SEVEN SHARED EXTENTS
DS6FMTID DS    CL1                 FORMAT IDENTIFIER
DS6MAVET DS    XL90                EIGHTEEN SHARED EXTENTS
DS6PTRDS DS    XL5                 POINTER TO NEXT FORMAT 6 DSCB
DS6END   EQU   *
&CTR     SETA  &CTR+1
         AGO   .LOOP
.ERROR   MNOTE 7,'***INCORRECT FORMAT NUMBER'
.ENDOFIT MEND
