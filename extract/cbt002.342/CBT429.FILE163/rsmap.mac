//RSMAP    JOB
//*
//*  RSMAP -
//*    THIS TSO COMMAND RUNS ON 3270 DEVICES ONLY.  IT REPORTS
//*    REAL STORAGE USAGE FOR EACH ADDRESS SPACE IN THE SYSTEM.
//*
//*  INSTALLATION -
//*    MODIFY THE JOB CARD ABOVE AND THE PROCEDURE DEFAULTS
//*    BELOW TO SUIT YOUR TASTE.
//*
//*
//*  333333   7777777   00000       OOOOOOO  N     N  L        Y     Y
//*        3        7  0     0      O     O  NN    N  L         Y   Y
//*        3       7   0     0      O     O  N N   N  L          Y Y
//*     333       7    0     0 ---- O     O  N  N  N  L           Y
//*        3      7    0     0      O     O  N   N N  L           Y
//*        3      7    0     0      O     O  N    NN  L           Y
//*  333333       7     00000       OOOOOOO  N     N  LLLLLLL     Y
//*
//*
//INSTALL PROC SOUT=$,               <=== SYSOUT CLASS
//             LIB='SYS1.CMDLIB',    <=== TARGET LOAD LIBRARY
//             MBR=RSMAP,            <=== COMMAND NAME
//             HELP='SYS1.HELP',     <=== HELP LIBRARY
//             SYSTS=SYSDA,          <=== UNITNAME FOR WORK DATASETS
//             ASMBLR=IEV90,         <=== NAME OF YOUR ASSEMBLER
//             ALIB='SYS1.LINKLIB',  <=== LOCATION OF YOUR ASSEMBLER
//             SMPMTS='SYS1.SMPMTS', <=== SMPMTS DATASET NAME
//             MACLIB='SYS1.MACLIB', <=== MACLIB DATASET NAME
//             AMODGEN='SYS1.AMODGEN' <=== AMODGEN DATASET NAME
//*
//IEBUPDTE EXEC PGM=IEBUPDTE,PARM=NEW
//SYSPRINT DD  SYSOUT=&SOUT
//SYSUT1   DD  DSN=&HELP,DISP=SHR
//SYSUT2   DD  DSN=&HELP,DISP=SHR
//*
//ASM     EXEC PGM=&ASMBLR,REGION=2048K,PARM='NOOBJECT,DECK,NOALIGN'
//STEPLIB  DD  DSN=&ALIB,DISP=SHR
//SYSTERM  DD  SYSOUT=&SOUT
//SYSPRINT DD  SYSOUT=&SOUT
//SYSLIB   DD  DSN=&SMPMTS,DISP=SHR
//         DD  DSN=&MACLIB,DISP=SHR
//         DD  DSN=&AMODGEN,DISP=SHR
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,(15,1))
//SYSUT2   DD  UNIT=&SYSTS,SPACE=(TRK,(15,1))
//SYSUT3   DD  UNIT=&SYSTS,SPACE=(TRK,(15,1))
//SYSPUNCH DD  DSN=&&SYSLIN,UNIT=&SYSTS,DISP=(,PASS,DELETE),
//             SPACE=(TRK,(5,1),RLSE)
//*
//LKED    EXEC PGM=HEWL,COND=(0,NE),PARM='LIST,MAP,XREF,RENT,REFR'
//SYSPRINT DD  SYSOUT=&SOUT
//SYSUT1   DD  UNIT=&SYSTS,SPACE=(TRK,5)
//SYSLMOD  DD  DSN=&LIB(&MBR),DISP=SHR
//SYSLIN   DD  DSN=&&SYSLIN,DISP=(OLD,DELETE)
//         DD  DDNAME=SYSIN
//        PEND
//*
//        EXEC INSTALL
//IEBUPDTE.SYSIN DD *
./         ADD    NAME=RSMAP,LIST=ALL
./         NUMBER NEW1=1000,INCR=1000
)F FUNCTION -
             THIS PROGRAM REPORTS REAL STORAGE USAGE FOR EACH ADDRESS
             SPACE IN THE SYSTEM.

  AUTHOR -
             DAVE PHILLIPS
             A. DUDA AND SONS, INC.
             P.O. BOX 257
             OVIEDO, FL  32765

  OPERATION -
             RSMAP RUNS AS A FULL-SCREEN 3270 COMMAND.  IT TAKES
             TWO SUBCOMMANDS: "F" AND "Z".  THE "F" SUBCOMMAND
             DISPLAYS THE NEXT FRAME IN THE DISPLAY, IF ANY.
             THE "Z" SUBCOMMAND SHUTS DOWN RSMAP (PF3 AND PA1
             ALSO SHUT DOWN RSMAP).

  OUTPUT -
             THE TOP OF EACH SCREEN SUMMARIZES GLOBAL REAL STORAGE
             USAGE BY SUBPOOL TYPE:
                SQA:         SYSTEM QUEUE AREA
                CSA, CSAF:   PAGEABLE AND FIXED COMMON STORAGE AREAS
                LPA, LPAF:   PAGEABLE AND FIXED LINKPACK AREAS
                PRIV, PRIVF: PAGEABLE AND FIXED PRIVATE AREAS
                LSQA:        LOCAL SYSTEM QUEUE AREAS
                NUC:         MVS NUCLEUS
                AVAL:        AVAILABLE FRAME QUEUE
                VIO:         VIO STORAGE FRAMES
                BAD:         BAD STORAGE FRAMES
                CPU UTIL:    INSTANTANEOUS CPU UTILIZATION
                ASMQ:        AUXILIARY STORAGE MANAGER QUEUE LENGTH
                HI UIC:      HIGH UNREFERENCED INTERVAL COUNT
                AVG UIC:     AVERAGE UNREFERENCED INTERVAL COUNT
                TOTAL:       TOTAL STORAGE FRAMES IN SYSTEM

             THE REMAINDER OF THE SCREEN DETAILS SPECIFIC USAGE, ONE
             OUTPUT LINE PER ADDRESS SPACE.  VALUES DISPLAYED ARE:
                JOBNAME:     JOB NAME ASSOCIATED W/ ADDRESS SPACE
                ASID:        ADDRESS SPACE ID
                TOT FRAME:   TOTAL REAL STORAGE FRAMES USED
                PRIVATE:     PRIVATE AREA PAGEABLE FRAMES
                PRIV FIX:    PRIVATE AREA FIXED FRAMES
                LSQA:        LOCAL SYSTEM QUEUE AREA FRAMES
                WORKSET:     WORKING SET
                CPU TIME:    STEP CPU TIME

)X SYNTAX -
      RSMAP

)O OPERANDS - NONE
./        ENDUP
/*
//ASM.SYSIN DD *
         TITLE 'REAL STORAGE MAP'
         MACRO
&NAME    INCRMENT &VALUE,&INDEX=0
&NAME    L     R7,&VALUE.(&INDEX)
         LA    R7,1(R7)
         ST    R7,&VALUE.(&INDEX)
         MEND
         SPACE 4
         MACRO
&NAME    PLUS  &VALUE
&NAME    LR    R1,R4                   LOAD ASID INTO R1
         SLA   R1,2                    MULTIPLY BY FOUR FOR OFFSET
         L     R7,&VALUE.(R1)
         LA    R7,1(R7)
         ST    R7,&VALUE.(R1)
         MEND
         EJECT
         MACRO
&NAME    PERCENT &COUNT,&REG,&BASE=0,&VERSION=,&TYPE=,&VAR=
.*********************************************************************
.*                                                                   *
.*  THIS MACRO WILL PRODUCE PACKED DECIMAL TOTALS AND PERCENTAGES    *
.*       FROM GIVEN INPUT AT THREE DIFFERENT POINTS FROM THE PROGRAM.*
.*       TYPEA---TOP PORTION OF OUTPUT FOR VALUES THAT HAVE          *
.*               ACCOMPANYING PERCENTAGES.  EX. LSQA,CSA,PRIV...     *
.*       TYPEB---TOP PORTION OF OUTPUT FOR VALUES THAT DO NOT HAVE   *
.*               ACCOMPANYING PERCENTAGES.  EX. HIUIC,TOTAL          *
.*       TYPEC---BOTTOM PORTION OF GRAPH                             *
.*                                                                   *
.*       &BASE WILL ONLY BE USED FOR TYPE C AND IT WILL ALWAYS USE   *
.*             REGISTER 1.                                           *
.*                                                                   *
.*       &REG CONTAINS EITHER THE TOTAL SYSTEM FRAMES OR THE TOTAL   *
.*            FRAMES FOR A PARTICULAR ASID.                          *
.*                                                                   *
.*       &VERSION---USED ONLY IN TYPE "A"                            *
.*            EX.  TITLE&VERSION WILL BECOME TITLE1,TITL2,...        *
.*                                                                   *
.*       &VAR---USED ONLY IN TYPE "B"                                *
.*            EX.  TITLE&VAR WILL BECOME TITLEALL,TITLEUIC,...       *
.*                                                                   *
.*********************************************************************
&NAME    L     R3,&COUNT.(&BASE)
         AIF   ('&TYPE' NE 'C').NCHK0
         LTR   R3,R3              COUNT ZERO ?
         BNZ   NZER&SYSNDX        NOPE
         MVC  TOT&VAR,BLANK       PRINT BLANKS FOR COUNT
         MVC  PER&VAR,BLANK       PRINT BLANKS FOR PERCENT
         B    OUT&SYSNDX          ALL DONE
NZER&SYSNDX DS 0H
.NCHK0   ANOP
         LR    R0,&REG
         BAL   R14,CONVERT
         LR    &REG,R0
         CL    &REG,&COUNT.(&BASE)     SEE IF 100% WILL OCCUR
         BE    SAME&SYSNDX             YES....EDIT LINE FOR 100%
         ED    CHAR2,COUNTX10+4        EDIT % FOR OUTPUT
         MVI   CHAR2+10,C' '           IF %<99 BLANK OUT AFTER ")"
         B     PCTD&SYSNDX             BYPASS THE MVC FOR 100%
SAME&SYSNDX    MVC  CHAR2+5(6),HUNDPER  MOVE CHARACTERS "(100%)
PCTD&SYSNDX DS 0H
.DECTYPE AIF   ('&TYPE' EQ 'A').AMVC   TYPE "A"
         AIF   ('&TYPE' EQ 'B').BMVC   TYPE "B"
         AIF   ('&TYPE' EQ 'C').CMVC   TYPE "C"
         MNOTE 8,'ILLEGAL TYPE &TYPE'
.AMVC          ANOP
               MVC  TITLE&VERSION.(6),XX&COUNT
               MVC  VALUE&VERSION.(4),CHAR+4
               MVC  PERCENT&VERSION.(5),CHAR2+5
               AGO  .MVCDONE
.BMVC          ANOP
               MVC  TITLE&COUNT.(10),XX&COUNT
               MVC  VALUE&COUNT.(4),CHAR+4
               AGO  .MVCDONE
.CMVC          ANOP
               MVC  TOT&VAR,CHAR+4
               MVC  PER&VAR,CHAR2+5
OUT&SYSNDX DS 0H
.MVCDONE       ANOP
         MEND
         MACRO
&NAME    CALCSBA &POS,&ORDER=,&CHAR=
         LCLA  &O,&L,&R
         LCLC  &TAB,&LC,&RC,&OR,&CH
.*
         AIF   ('&POS(1)' NE '').HAVEPOS
         MNOTE 8,'MISSING ROW/OFFSET SPECIFICATION'
         MEXIT
.HAVEPOS AIF   (N'&POS LE 2).OKNPOS
         MNOTE 8,'TOO MANY OPERANDS FOR ROW/COLUMN SPECIFICATION'
         MEXIT
.OKNPOS  AIF   ('&POS(2)' EQ '').OFFSET
.*
         AIF   (&POS(1) GE 1 AND &POS(1) LE 24).OKROW
         MNOTE 8,'ROW SPECIFICATION IS OUT OF BOUNDS'
         MEXIT
.OKROW   AIF   (&POS(2) GE 1 AND &POS(1) LE 80).OKCOL
         MNOTE 8,'COLUMN SPECIFICATION IS OUT OF BOUNDS'
         MEXIT
.OKCOL   ANOP
&O       SETA  (((&POS(1)-1)*80)+(&POS(2)-1))
         AGO   .GOTOFF
.OFFSET  ANOP
         AIF   (&POS(1) GE 1 AND &POS(1) LE 1919).OKOFF
         MNOTE 8,'OFFSET SPECIFICATION IS OUT OF BOUNDS'
         MEXIT
.OKOFF   ANOP
&O       SETA  &POS(1)
.*
.GOTOFF  ANOP
&TAB     SETC  ' ABCDEFGHIÖ.<(+×'.'&&'(1,1).'JKLMNOPQR!$*);^-/STUVWXYZ|*
               ,%_>?0123456789:#@''="'
&L       SETA  &O/64
&R       SETA  (&O-(&L*64))
&LC      SETC  '&TAB'(&L+1,1)
&RC      SETC  '&TAB'(&R+1,1)
.*
.CHKL1   AIF   ('&LC' NE '&&'(1,1)).CHKL2
&LC      SETC  '&&'
         AGO   .CHKR1
.CHKL2   AIF   ('&LC' NE '''').CHKR1
&LC      SETC  (2)''''
.*
.CHKR1   AIF   ('&RC' NE '&&'(1,1)).CHKR2
&RC      SETC  '&&'
         AGO   .GOTSBA
.CHKR2   AIF   ('&RC' NE '''').GOTSBA
&RC      SETC  (2)''''
.*
.GOTSBA  ANOP
.*
&OR      SETC  ''
         AIF   ('&ORDER' EQ 'SBA').GOTORD
&OR      SETC  ''
         AIF   ('&ORDER' EQ 'RA').GOTORD
&OR      SETC  ''
         AIF   ('&ORDER' EQ 'EUA').GOTORD
&OR      SETC  ''
         AIF   ('&ORDER' EQ '').GOTORD
         MNOTE 8,'ORDER ''&ORDER'' IS INVALID'
         MEXIT
.GOTORD  ANOP
.*
         AIF   (T'&CHAR EQ 'O').NOCHAR
         AIF   ('&CHAR'(1,1) EQ '''').CHARQ
         AIF   (K'&CHAR EQ 2).CHARHEX
&CH      SETC  '''&CHAR'''
         AGO   .CHAROK
.CHARQ   ANOP
&CH      SETC  '&CHAR'
.CHAROK  ANOP
&NAME    DC    C'&OR&LC&RC',C&CH
         MEXIT
.*
.CHARHEX ANOP
&NAME    DC    C'&OR&LC&RC',X'&CHAR'
         MEXIT
.*
.NOCHAR  ANOP
&NAME    DC    C'&OR&LC&RC'
         MEXIT
         MEND
         MACRO
&NAME    RA    &POS,&CHAR=
&NAME    CALCSBA &POS,ORDER=RA,CHAR=&CHAR
         MEND
         MACRO
&NAME    SBA   &POS
&NAME    CALCSBA &POS,ORDER=SBA
         MEND
         MACRO
&NAME    SF    &ATTRIB
         LCLA  &ARG                3270 ATTRIBUTE CHAR RESOLUTION     @
         LCLB  &PEN                ATTRB = DET                        @
         LCLB  &KEYED              ATTRB = UNPROT                     @
         LCLB  &IC                 ATTRB = IC                         @
         LCLB  &NUMERIC            NUMERIC FIELD INDICATOR
         LCLB  &X(10),&XON
         LCLA  &COUNT,&INDEX,&HIGH,&A,&B,&C                           @
         LCLA  &Y(10)
         LCLC  &ATRC
.*
.**********************************************************************
.*       COMPONENTS OF &X GLOBALS                                     *
.**********************************************************************
.*                                                                    *
.*               &X                         MEANING                   *
.*                                                                    *
.*                1                     ATTRB = ASKIP                 *
.*                2                     ATTRB = PROT                  *
.*                3                     ATTRB = UNPROT                *
.*                4                     ATTRB = NUM                   *
.*                5                     ATTRB = DET                   *
.*                6                     ATTRB = BRT                   *
.*                7                     ATTRB = DRK                   *
.*                8                     ATTRB = FSET                  *
.*                9                     ATTRB = IC                    *
.*               10                     ATTRB = NORM                  *
.*                                                                    *
.**********************************************************************
.*
.**********************************************************************
.*       ANALYZE SPECIFICATION OF ATTRB OPERAND                       *
.**********************************************************************
&ATRC    SETC  '
         AIF   (T'&ATTRIB EQ 'O').MDFATRB
.**********************************************************************
.*       ANALYZE ATTRB FOR ATTRIBUTE CHARACTER                        *
.**********************************************************************
.*
&INDEX   SETA  1
&HIGH    SETA  10
&IC      SETB  0                   INITIALIZE ATTRB = IC GLOBAL       @
&ARG     SETA  0                   INIT ATTRIBUTE CHAR RESOLUTION     @
         AIF   (T'&ATTRIB EQ 'O').ATRDF  IS ATTRB = NULL ?            @
.REPEAT  ANOP
&COUNT   SETA  &COUNT+1            BUMP THE COUNT BY 1.
         AIF   ('&ATTRIB(&INDEX)' EQ 'ASKIP').SETBIT           @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'PROT').SETBIT            @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'UNPROT').SETBIT          @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'NUM').SETBIT             @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'DET').SETBIT             @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'BRT').SETBIT             @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'DRK').SETBIT             @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'FSET').SETBIT            @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'IC').SETBIT              @BA49862
&COUNT   SETA  &COUNT+1                                        @BA49862
         AIF   ('&ATTRIB(&INDEX)' EQ 'NORM').SETBIT            @BA49862
.*DELETED BY APAR P49862                                       @BA49862
         AIF   (&COUNT LE &HIGH).REPEAT  CHECK FOR END OF LIST.
         AGO   .ATRE01             GO TO ATTRB PARAMETER ERROR        @
.CHEKIND ANOP                      CHECK INDEX ENTRY                  @
         AIF   (&INDEX EQ N'&ATTRIB).ATRLDUN  IS # PARMS EXCEEDED ?   @
&INDEX   SETA  &INDEX+1
&COUNT   SETA  0
         AGO   .REPEAT
.*
.*  SET X MATRIX FOR CHARACTER DISPLACEMENT.
.*
.SETBIT  ANOP
&XON     SETB  1                   SHEW SOME X HAS BEEN SET.
&X(&COUNT) SETB 1                  SHEW THIS ATTRIBUTE CHOSEN.
&Y(&COUNT) SETA &INDEX
         AGO   .CHEKIND
.ATRDF   ANOP                      DEFAULT ATTRIBUTE CHAR ENTRY       @
&X(1)    SETB  1                   SET ASKIP ON
&XON     SETB  1                   SHEW AN X BIT SET.
.*
.*  ANALYZE THE MATRIX
.*
.ATRLDUN ANOP                      ATTRIBUTE CHARACTER COMPLETION     @
         AIF   (&XON).ANALYSE      CHECK FOR ANY X SET.
&X(1)    SETB  1                   TAKE THE DEFAULT
.ANALYSE ANOP
&PEN     SETB  (&X(5))                  .. YES, SET ATTRB = DET ON    @
.*
.*  OUTPUT ANALYSIS.
.*
&A       SETA  1                   SET ATTRB = ASKIP                  @
&B       SETA  3                   SET ATTRB =UNPROT                  @
         AIF   (&X(1) AND &X(3)).ATRE02  IS ATTRB = ASKIP AND UNPROT ?@
&A       SETA  2                   SET ATTRB = PROT                   @
         AIF   (&X(2) AND &X(3)).ATRE02  IS ATTRB = PROT AND UNPROT ? @
&A       SETA  5                   SET ATTRB = DET                    @
&B       SETA  7                   SET ATTRB = DRK                    @
         AIF   (&X(5) AND &X(7)).ATRE02  IS ATTRB = DET AND DRK ?     @
&A       SETA  6                   SET ATTRB = BRT                    @
         AIF   (&X(6) AND &X(7)).ATRE02  IS ATTRB = BRT AND DRK ?     @
&B       SETA  10                  SET ATTRB = NORM                   @
         AIF   (&X(6) AND &X(10)).ATRE02  IS ATTRB = BRT AND NORM ?   @
&A       SETA  7                   SET ATTRB = DRK                    @
         AIF   (&X(7) AND &X(10)).ATRE02  IS ATTRB = DRK AND NORM ?   @
         AIF   (&X(1) AND &X(9)).ATRE03  IS ATTRB = ASKIP AND IC ?    @
         AIF   (&X(2) AND &X(9)).ATRE03  IS ATTRB = PROT AND IC ?     @
         AIF   (&X(2) AND &X(4)).ATRE04  IS ATTRB = PROT AND NUM ?    @
.*
.*
.*
.BITCALC ANOP
&NUMERIC SETB  (&X(4))             SET NUMERIC FIELD INDICATOR
&X(2)    SETB  (&X(1) OR &X(2))    PROT IF ASKIP.
&X(4)    SETB  (&X(1) OR &X(4))    NUM IF ASKIP
&X(5)    SETB  (&X(7) OR (&X(5) AND NOT &X(6))) SET IF DARK OR LGHT PEN
&X(6)    SETB  (&X(7) OR &X(6))    BRT IF DARK.
&IC      SETB  (&X(9))             IC IF REQUESTED
&ARG     SETA  (32*&X(2)+16*&X(4)+4*&X(5)+8*&X(6)+&X(8))
&KEYED   SETB  (&X(3))             FLAG AS KEYABLE IF UNPROTECTED.
.*
.**********************************************************************
.*       CONVERT THE BINARY ATTRB TO A VALID 3270 TRANSMITTABLE CHAR  *
.**********************************************************************
         AIF   (&ARG NE 16).MDFFA  IS ATTRB = & ?                     @
&ATRC    SETC  '&&'                .. YES, SET ATTRB = & GLOBAL       @
         AGO   .MDFATRB            GO TO ATTRIBUTE BYPASS             @
.MDFFA   ANOP                      .. NO, ATTRB = & BYPASS            @
         AIF   (&ARG NE 61).MDFFB  IS ATTRB = ' ?                     @
&ATRC    SETC  ''''''              .. YES, SET ATTRB = ' GLOBAL       @
         AGO   .MDFATRB            GO TO ATTRIBUTE BYPASS             @
.MDFFB   ANOP                      .. NO, ATTRB = ' BYPASS            @
&ATRC    SETC  ' ABCDEFGHIÖ.<(+× JKLMNOPQR!$*);^-/STUVWXYZ|,%_>?0123456*
               789:#@''="'(&ARG+1,1)  SUBSTRING FOR CORRECT CHARACTER @
.MDFATRB ANOP                      ATTRIBUTE BYPASS                   @
         AIF   (&IC).ADDIC
&NAME    DC    C'&ATRC'
         MEXIT
.ADDIC   ANOP
&NAME    DC    C'&ATRC.'
         MEXIT
.*
.*
.*
.ATRE01  ANOP                      ATTRB PARAMETER ERROR ENTRY        @
         MNOTE 4,'INVALID ATTRIBUTE PARAMETER IS SPECIFIED,'   @BA19555
         MNOTE *,'ATTRB = &ATTRIB(&INDEX) IS IGNORED.'                @
         AGO   .CHEKIND            GO TO CHECK INDEX                  @
.ATRE02  ANOP                      INCOMPATIBLE ATTRB OP ERROR        @
&A       SETA  &Y(&A)              SET PARAMETER INDEX VALUE
&B       SETA  &Y(&B)              SET PARAMETER INDEX VALUE
         MNOTE 4,'&ATTRIB(&A) AND &ATTRIB(&B) ARE INCOMPATIBLE PARAMETE*
               RS,'                                            @BA19555
         MNOTE *,'ATTRB = &ATTRIB(&A) IS IGNORED,'                    @
         MNOTE *,'ATTRB = &ATTRIB(&B) IS IGNORED,'                    @
         MNOTE *,'ATTRB = ASKIP IS ASSUMED BY DEFAULT.'               @
&X(1)    SETB  1                   ASKIP DEFAULT.
&C       SETA  2                   SET C FOR CLEARING X TABLE.
.ZEROX   ANOP
&X(&C)   SETB  0                   CLEAR
&C       SETA  &C+1                DOWN
         AIF   (&C LT 11).ZEROX    X TABLE.
         AGO   .BITCALC
.ATRE03  ANOP                      ATTRB = IC ERROR ENTRY             @
         MNOTE 4,'ATTRB = IC IS REQUESTED FOR PROTECTED FIELD' @BA19555
         AGO   .BITCALC
.ATRE04  ANOP                      ATTRB = PROT AND NUM ERROR         @
         MNOTE *,'ATTRB = PROT AND NUM ALSO IMPLIES THE ASKIP PARAMETER*
               .'                                                     @
         AGO   .BITCALC
         MEND
         MACRO
&NAME    WCC   &CTRL
         LCLA  &ARG                3270 WCC RESOLUTION                @
         LCLB  &BITS(6)            WRITE CONTROL CHARACTER BITS       @
         LCLA  &KOWNT              CONTROL PARAMETER COUNTER          @
         LCLB  &HONSW              NEW LINE & END OF MESSAGE BIT      @
         LCLC  &FUNC
.*
.**********************************************************************
.*       COMPONENTS OF &ARG GLOBAL                                    *
.**********************************************************************
.*                                                                    *
.*             &BITS       VALUE            MEANING                   *
.*                                                                    *
.*               1           32           CTRL = L64                  *
.*               1 & 2                    CTRL = L80                  *
.*               2           16           CTRL = L40                  *
.*               3            8           CTRL = PRINT                *
.*               4            4           CTRL = ALARM                *
.*               5            2           CTRL = FREEKB               *
.*               6            1           CTRL = FRSET                *
.*                                                                    *
.**********************************************************************
.*
&ARG     SETA  0                   INITIALIZE 3270 WCC RESOLUTION     @
&FUNC    SETC  '
&HONSW   SETB  0                   INITIALIZE NL AND EOM BIT          @
&BITS(1) SETB  0                   INIT 64 CHAR LINE LENGTH BIT       @
&BITS(2) SETB  0                   INIT 40 CHAR LINE LENGTH BIT       @
&BITS(3) SETB  0                   INITIALIZE 3270 PRINTER BIT        @
&BITS(4) SETB  0                   INITIALIZE 3270 ALARM BIT          @
&BITS(5) SETB  0                   INITIALIZE FREE KEYBOARD BIT       @
&BITS(6) SETB  0                   INIT MODIFIED DATA TAG RESET       @
.*
         AIF   (T'&CTRL EQ 'O').WCCEXT2  IS CTRL = NULL ?             @
.*
.**********************************************************************
.*       ANALYZE CTRL FOR WCC                                         *
.**********************************************************************
.WCCLOOP ANOP                      CTRL OPERAND LOOP ENTRY            @
&KOWNT   SETA  &KOWNT+1            INCREMENT NUMBER OF PARAMETERS     @
         AIF   (&KOWNT GT N'&CTRL).WCCEXIT  IS # OF PARMS EXCEEDED ?  @
         AIF   ('&CTRL(&KOWNT)' NE 'PRINT').WCCPRTB  IS CTRL = PRINT ?@
&BITS(3) SETB  1                   .. YES, SET CTRL = PRINT BIT       @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCPRTB ANOP                      .. NO, CTRL = PRINT BYPASS         @
         AIF   ('&CTRL(&KOWNT)' NE 'L80').WCCL80B  IS CTRL = L80 ?    @
         AIF   (&BITS(1) AND &BITS(2)).WCCLOOP  IS L80 PREV SPECIFIED ?
         AIF   (&BITS(1)).WCCE1    IS L64 PREVIOUSLY SPECIFIED ?      @
         AIF   (&BITS(2)).WCCE2    IS L40 PREVIOUSLY SPECIFIED ?      @
         AIF   (&HONSW).WCCE3      HONEOM PREVIOUSLY SPECIFIED ?      @
&BITS(1) SETB  1                   SET CTRL = L80 BITS                @
&BITS(2) SETB  1                   SET CTRL = L80 BITS                @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCL80B ANOP                      .. NO, CTRL = L80 BYPASS           @
         AIF   ('&CTRL(&KOWNT)' NE 'L64').WCCL64B  IS CTRL = L64 ?    @
         AIF   (&BITS(1) AND (NOT &BITS(2))).WCCLOOP  L64 PREV SPEC ? @
         AIF   (&BITS(1) AND &BITS(2)).WCCE1  IS L80 PREV SPECIFIED ? @
         AIF   (&BITS(2)).WCCE4    IS L40 PREVIOUSLY SPECIFIED ?      @
         AIF   (&HONSW).WCCE5      HONEOM PREVIOUSLY SPECIFIED ?      @
&BITS(1) SETB  1                   SET CTRL = L64 BIT                 @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCL64B ANOP                      .. NO, CTRL = L64 BYPASS           @
         AIF   ('&CTRL(&KOWNT)' NE 'L40').WCCL40B  IS CTRL = L40 ?    @
         AIF   (&BITS(2) AND (NOT &BITS(1))).WCCLOOP  L40 PREV SPEC ? @
         AIF   (&BITS(1) AND &BITS(2)).WCCE2  IS L80 PREV SPECIFIED ? @
         AIF   (&BITS(1)).WCCE4    IS L64 PREVIOUSLY SPECIFIED ?      @
         AIF   (&HONSW).WCCE6      HONEOM PREVIOUSLY SPECIFIED ?      @
&BITS(2) SETB  1                   SET CTRL = L40 BIT                 @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCL40B ANOP                      .. NO, CTRL = L40 BYPASS           @
         AIF   ('&CTRL(&KOWNT)' NE 'HONEOM').WCCEOMB  CTRL = HONEOM ? @
         AIF   (&HONSW).WCCLOOP    HONEOM PREVIOUSLY SPECIFIED ?      @
         AIF   (&BITS(1) AND &BITS(2)).WCCE3  IS L80 PREV SPECIFIED ? @
         AIF   (&BITS(1)).WCCE5    IS L64 PREVIOUSLY SPECIFIED ?      @
         AIF   (&BITS(2)).WCCE6    IS L40 PREVIOUSLY SPECIFIED ?      @
&HONSW   SETB  1                   SET CTRL = HONEOM BIT              @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCEOMB ANOP                      .. NO, CTRL = HONEOM BYPASS        @
         AIF   ('&CTRL(&KOWNT)' NE 'FREEKB').WCCFRKB  CTRL = FREEKB ? @
&BITS(5) SETB  1                   .. YES, SET CTRL = FREEKB BIT      @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCFRKB ANOP                      .. NO, CTRL = FREEKB BYPASS        @
         AIF   ('&CTRL(&KOWNT)' NE 'FRSET').WCCRSTB  IS CTRL = FRSET ?@
&BITS(6) SETB  1                   .. YES, SET CTRL = FRSET BIT       @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCRSTB ANOP                      .. NO, CTRL = FRSET BYPASS         @
         AIF   ('&CTRL(&KOWNT)' NE 'ALARM').WCCLRMB  IS CTRL = ALARM ?@
&BITS(4) SETB  1                   .. YES, SET CTRL = ALARM BIT       @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCLRMB ANOP                      .. NO, CTRL = ALARM BYPASS         @
         AIF   ('&CTRL(&KOWNT)' EQ 'PAGE').WCCLOOP  IS CTRL = PAGE ?  @
         AIF   ('&CTRL(&KOWNT)' EQ 'AUTOPAGE').WCCLOOP  AUTOPAGE ?    @
         AIF   ('&CTRL(&KOWNT)' EQ 'RETAIN').WCCLOOP  CTRL = RETAIN ? @
         AIF   ('&CTRL(&KOWNT)' EQ 'RELEASE').WCCLOOP  CTRL = RELEASE ?
         MNOTE 4,'INVALID WCC PARAMETER IS SPECIFIED,'         @BA19555
         MNOTE *,'WCC PARAMETER IS IGNORED.'                          @
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.WCCE1   ANOP                      CTRL = L80 AND L64 ERROR ENTRY     @
         MNOTE 4,'L80 AND L64 PARMS ARE INCONSISTENT,'         @BA19555
         MNOTE *,'L80 PARAMETER IS IGNORED,'                          @
         MNOTE *,'L64 PARAMETER IS IGNORED,'                          @
         AGO   .WCCE6A             GO TO CTRL = HONEOM DEFAULT        @
.WCCE2   ANOP                      CTRL = L80 AND L40 ERROR ENTRY     @
         MNOTE 4,'L80 AND L40 PARMS ARE INCONSISTENT,'         @BA19555
         MNOTE *,'L80 PARAMETER IS IGNORED,'                          @
         MNOTE *,'L40 PARAMETER IS IGNORED,'                          @
         AGO   .WCCE6A             GO TO CTRL = HONEOM DEFAULT        @
.WCCE3   ANOP                      CTRL = L80 AND HONEOM ERROR        @
         MNOTE 4,'L80 AND HONEOM PARMS NOT CONSISTENT,' @BA19555
         MNOTE *,'L80 PARAMETER IS IGNORED,'                          @
         AGO   .WCCE6A             GO TO CTRL = HONEOM DEFAULT        @
.WCCE4   ANOP                      CTRL = L64 AND L40 ERROR ENTRY     @
         MNOTE 4,'L64 AND L40 PARMS ARE INCONSISTENT,'         @BA19555
         MNOTE *,'L64 PARAMETER IS IGNORED,'                          @
         MNOTE *,'L40 PARAMETER IS IGNORED,'                          @
         AGO   .WCCE6A             GO TO CTRL = HONEOM DEFAULT        @
.WCCE5   ANOP                      CTRL = L64 AND HONEOM ERROR        @
         MNOTE 4,'L64 AND HONEOM PARMS NOT CONSISTENT,' @BA19555
         MNOTE *,'L64 PARAMETER IS IGNORED,'                          @
         AGO   .WCCE6A             GO TO CTRL = HONEOM DEFAULT        @
.WCCE6   ANOP                      CTRL = L40 AND HONEOM ERROR        @
         MNOTE 4,'L40 AND HONEOM PARMS NOT CONSISTENT,' @BA19555
         MNOTE *,'L40 PARAMETER IS IGNORED,'                          @
.WCCE6A  ANOP                      CTRL = HONEOM DEFAULT ENTRY        @
         MNOTE *,'HONEOM PARAMETER IS ASSUMED BY DEFAULT.'            @
&BITS(1) SETB  0
&BITS(2) SETB  0
         AGO   .WCCLOOP            GO TO CTRL OPERAND LOOP ENTRY      @
.*
.WCCEXIT ANOP                      WCC COMPLETION                     @
&ARG     SETA  &BITS(1)*32+&BITS(2)*16+&BITS(3)*8+&BITS(4)*4
&ARG     SETA  &ARG+&BITS(5)*2+&BITS(6)
.WCCEXT2 ANOP
.*
.*
.**********************************************************************
.*       CONVERT THE BINARY WCC TO A VALID 3270 TRANSMITTABLE CHARACTER
.**********************************************************************
         AIF   (&ARG NE 16).MDIFA  IS WCC = & ?                       @
&FUNC    SETC  '&&'                .. YES, SET WCC = & GLOBAL         @
         AGO   .MDIWCCB            GO TO WCC BYPASS                   @
.MDIFA   ANOP                      .. NO, WCC = & BYPASS              @
         AIF   (&ARG NE 61).MDIFB  IS WCC = ' ?                       @
&FUNC    SETC  ''''''              .. YES, SET WCC = ' GLOBAL         @
         AGO   .MDIWCCB            GO TO WCC BYPASS                   @
.MDIFB   ANOP                      .. NO, WCC = ' BYPASS              @
&FUNC    SETC  ' ABCDEFGHIÖ.<(+× JKLMNOPQR!$*);^-/STUVWXYZ|,%_>?0123456*
               789:#@''="'(&ARG+1,1) SUBSTR FOR CORRECT CHAR   @BCC5E01
.MDIWCCB ANOP                      WCC BYPASS                  @BCC5E01
.*
&NAME    DC    C'&FUNC'
         MEND                                                  @BCAD311
         EJECT
R0       EQU   0                       WORK
R1       EQU   1                       WORK
R2       EQU   2                       INDEX TO CURRENT PFTE
R3       EQU   3                       INDEX TO LAST PFTE
R4       EQU   4                       ADDRESS SPACE ID
R5       EQU   5                       VIRTUAL BLOCK NUMBER OF OWNER
R6       EQU   6                       INDEX REGISTER
R7       EQU   7                       WORK
R8       EQU   8                       WORK
R9       EQU   9                       CVT
R10      EQU   10                      PVT ADDRESS
R11      EQU   11                      ASVT
R12      EQU   12                      BASE REGISTER FOR CSECT RSMAP
R13      EQU   13                      BASE REGISTER FOR DSECT CORE
R14      EQU   14                      LINK REGISTER
R15      EQU   15
         EJECT
RSMAP    CSECT
         SAVE  (14,12),,RSMAP-&SYSDATE-&SYSTIME
         LR    R12,R15                 LOAD BASE REGISTER
         USING RSMAP,R12               TELL ASSEMBLER ABOUT IT
         SPACE
         L     R0,=A(CORESIZE)         LENGTH OF WORKAREA
         GETMAIN R,LV=(0)              GET IT
         ST    R1,8(,R13)              CHAIN NEW TO OLD SAVEAREA
         ST    R13,4(,R1)              CHAIN OLD TO NEW SAVEAREA
         LR    R13,R1                  POINT TO OUR NEW SAVEAREA
         USING CORE,R13                WHICH ALSO HAS OUR WORKAREA
         SPACE
         STFSMODE ON,INITIAL=YES       TELL VTAM ABOUT FULL SCREEN MODE
         EJECT
**********************************************************************
*                                                                    *
*   START --- WHEN UPDATE IS REQUESTED THIS IS WHERE WE COME TO.     *
*             ALL ADDRESSABILITY HAS PREVIOUSLY BEEN TAKEN CARE OF.  *
*             CORE DSECT HAS ALREADY BEEN GETMAINED, ALL WE NEED TO  *
*             DO IS MAKE SURE IT GETS ZEROED.                        *
*                                                                    *
**********************************************************************
         SPACE 3
START    DS    0H
         PRINT NOGEN                   I DONT WANT ALL THOSE EXPANSIONS
         LA    R0,AREA                 ADDRESS OF WORK AREA
         LA    R1,AREASIZE             SIZE OF WORK AREA
         SR    14,14
         SR    15,15                   LENGHT OF ZERO, SO ZEROES WILL  +
                                       PAD ENTIRE WORK AREA
         MVCL  R0,R14                  MOVE ZEROES INTO WORK AREA
         L     R9,CVTPTR               ---> CVT
         USING CVTMAP,R9               ESTABLISH ADDRESSABILITY TO CVT
         L     R11,CVTASVT             ---> ASVT
         LA    R11,ASVTFRST-ASVT(R11)  ASVT ENTRY
         L     R10,CVTPVTP             ---> PVT
         USING PVT,R10
         L     R2,PVTPFTP              APPARENT PFTE ADDRESS
         LH    R8,PVTFPFN              + INDEX FIRST PFTE => FIRST PFTE
         SLL   R8,4                APPEND 0
         AR    R2,R8               POINT TO FIRST PFTE
         L     R3,PVTPFTP              APPARENT PFTE ADDRESS
         LH    R8,PVTLPFN              + INDEX LAST PFTE => LAST PFTE
         SLL   R8,4                APPEND 0
         AR    R3,R8               POINT TO FIRST PFTE
         LH    R7,PVTAFC               LOAD AVAILABLE FRAME COUNT
         ST    R7,AVAIL                STORE AFC
         LH    R7,PVTFPFN              INDEX OF FIRST PFTE
         ST    R7,NUC                  NUMBER OF FRAMES IN NUCLEUS
         LH    R7,PVTLPFN              INDEX OF LAST PFTE
         LA    R7,1(R7)                LAST PFTE GIVES TOTAL FRAMES-1
         ST    R7,ALL                  TOTAL NUMBER OF FRAMES ON SYSTEM
         L     R7,CVTOPCTP         ---> RMCT
         L     R7,RMCTMCT(,R7)     ---> MCT (STRG MGMT CNTL TABLE)
         LH    R7,MCVSTCRI(,R7)    HIGHEST SYSTEM UIC
         ST    R7,UIC              SAVE IT
         L     R7,CVTOPCTP         ---> RMCT
         L     R7,RMCTRCT(,R7)     ---> RCT
         LH    R7,RCVUICA(,R7)     UIC AVERAGE
         ST    R7,AVG
         L     R7,CVTOPCTP             ---> RMCT
         L     R7,X'4'(7)              ---> CCT
         LH    R7,CCVUTILP(R7)         SRM CPU UTILIZATION
         ST    R7,CPU
         L     R8,CVTASMVT             ---> ASMVT
         L     R7,ASMIORQR(,R8)        COUNT OF REQUESTS RECEIVED BY   +
                                       I/O CONTROL.
         S     R7,ASMIORQC(,R8)        COUNT OF I/O REQUESTS COMPLETED +
                                       AND RETURNED TO RSM.
         ST    R7,ASM                  CURRENT ASMQ
         EJECT
**********************************************************************
*                                                                    *
*     FRAME --- LOOPS THROUGH ALL THE PAGE FRAME TABLE ENTRIES FOR   *
*            THE SYSTEM.  R2 CONTAINS THE ADDRESS OF THE CURRENT     *
*            PFTE.  R3 CONTAINS THE ADDRESS OF THE LAST PFTE.        *
*            EACH PFTE IS X'16' BYTES LONG.  R2 IS INCREMENTED BY    *
*            X'16' UNTIL ITS VALUE REACHES THAT OF THE LAST PFTE     *
*            ENDING THE LOOP.  THERE ARE NO PFTE ENTRIES FOR THE     *
*            NUCLEUS.                                                *
*                                                                    *
**********************************************************************
         SPACE 3
FRAME    DS    0H                      LOOP TO LOOK AT EACH PFTE
         CR    R3,R2                   SEE IF LAST ADDRESS IS GREATER
*                                      THAN CURRENT PFTE ADDRESS.
*                                      IF SO THAN ALL FRAME ENTRIES
*                                      HAVE BEEN CHECKED AND TOTALED.
         BL    NOMORE                  NO MORE PFTE ENTRIES
         SR    R4,R4                   CLEAR FOR INSERT
         ICM   R4,B'0011',0(R2)        LOAD ASID
         LTR   R4,R4                   TEST FOR ZERO ASID
         BZ    ASIDZERO                ASID NON-ZERO
         EJECT
**********************************************************************
*                                                                    *
*   VBN ---  VIRTUAL BLOCK NUMBER (HIGH ORDER 12 BITS OF 24 BIT      *
*        VIRTUAL ADDRESS, LEFT ADJUSTED WITH 4 LOW ORDER BINARY      *
*        ZEROES) CURRENTLY OWNING THE REAL FRAME.                    *
*                                                                    *
**********************************************************************
         SPACE 1
VBN      LH    R5,2(R2)                VBN (PFTE+2)
         SPACE 5
         SLL   R5,8                    MAKE 24 BIT ADDRESS OUT OF IT
         LA    R5,0(R5)                ZERO HIGH ORDER BITS
         SR    R6,R6                   SET FLAG FOR NON FIXED FRAME    +
                                       COUNT TO ZERO.
         CLC   8(2,R2),=X'0000'        SEE IF FIXED COUNT EQUALS ZERO
         BNZ   FINDFRM                 NO...FRAME IS FIXED
         LA    R6,4                    SET INCREMENT FOR NON-FIXED
         EJECT
**********************************************************************
*                                                                    *
*    FINDFRM --- BIT2 OF PFTFLAG1 IS SQA/LSQA FLAG. WHEN 1 PAGE      *
*             FRAME CONTAINS AN LSQA OR SQA FRAME. IF PFTASID='FFFF' *
*             THE FRAME CONTAINS AN SQA FRAME.                       *
*                                                                    *
**********************************************************************
         SPACE 2
FINDFRM  SR    R7,R7
         ICM   R7,B'1100',12(R2)       PFTFLAG1 AND PFTFLAG2
         SLL   R7,2                    FIND BIT 2
         LTR   R7,R7                   SEE IF BIT IS TURNED ON
         BM    LSQASQA                 FRAME IS EITHER LSQA OR SQA
         SLL   R7,3                    FIND BIT 5 OF PFTFLAG1
         LTR   R7,R7                   SEE IF BIT IS TURNED ON
         BM    BADFRAME                FRAME MARKED AS BAD
         SLL   R7,6                    FIND BIT 3 OF PFTFLAG2
         LTR   R7,R7                   SEE IF BIT IS TURNED ON
         BM    VIOFRAME                FRAME IS VIO
         B     OWNER                   GOTO ROUTINE WHICH DETERMINES   +
                                       WHETHER FRAME IS IN CSA,LPA,    +
                                       OR PRIVATE AREA.
         SPACE 1
LSQASQA  CLM   R4,B'0011',=X'FFFF'     SEE IF ASID="FFFF"
         BE    ITISSQA                 IF "FFFF" THEN FRAME IS IN SQA
TLSQA    PLUS  LSQACNT
         INCRMENT LSQA                 INCREMENT LSQA FRAME COUNT
         B     NXTFRAME
         SPACE 1
BADFRAME DS    0H
         INCRMENT BAD                  INCREMENT BAD FRAME COUNT
         B     NXTFRAME
         SPACE 1
ITISSQA  DS    0H
         INCRMENT SQA                  INCREMENT SQA FRAME COUNT
         B     NXTFRAME
         SPACE 1
VIOFRAME DS    0H
         INCRMENT VIO                  INCREMENT VIO FRAME COUNT
         B     NXTFRAME
         SPACE 1
OWNER    LTR   R5,R5                   SEE IF VIRT. BLOCK # IS ZERO
         BZ    ASIDZERO                YES...GO SEE IF SQA RESERVED
         C     R5,CVTSHRVM             SEE IF VIRTUAL BLOCK NUMBER
*                                      OF FRAME IS BELOW CSA ADDRESS
*                                      WHICH MEANS FRAME IS IN THE
*                                      PRIVATE AREA.
         BNL   NOTPRIV
         LTR   R6,R6                   SEE IF FIXED OR NOT FIXED
         BZ    PLUSFIX                 FRAME IS FIXED
TPRIV    PLUS  PRIVCNT                 INCREMENT PRIV COUNT FOR ASID
         B     INCPRIVF
         SPACE 1
PLUSFIX  PLUS  PRIVFCNT                INCREMENT PRIV FIX FOR THIS ASID
INCPRIVF INCRMENT PRIVF,INDEX=6        INCREMENT PRIVATE FRAME COUNT   +
                                       IF REGISTER 6 IS EQUAL TO 4     +
                                       THEN THE FRAME IS NOT FIXED     +
                                       AND PRIVF+4 WHICH IS PRIV       +
                                       IS INCREMENTED INSTEAD.
         B     NXTFRAME
         SPACE 1
NOTPRIV  CLM   R5,B'0111',CVTLPDIA+1   COMPARE TO LPA ADDRESS          +
                                       HIGH ORDER BYTE CONTAINS FLAGS
         BNL   NOTCSA
         INCRMENT CSAF,INDEX=6         INCREMENT CSAF OR CSA
         B     NXTFRAME
         SPACE 1
NOTCSA   DS    0H
         INCRMENT LPAF,INDEX=6         INCREMENT LPAF OR LPA
         B     NXTFRAME
         EJECT
**********************************************************************
*                                                                    *
*  ASIDZERO --- WHEN TESTING THIS PROGRAM IT WAS FOUND THAT 1 FRAME  *
*            HAD AN ASID OWNER OF ZERO.  ITS FLAGS INDICATE THAT IT  *
*            IS ON THE SQA RESERVE QUEUE AND THUS WE HAVE THIS       *
*            ROUTINE TO MAKE SURE THAT THIS IS THE CASE.             *
*                                                                    *
**********************************************************************
         SPACE 2
ASIDZERO TM    14(R2),X'04'            SEE IF ON SQA RESERVE QUEUE
         BO    ITISSQA                 YES...COUNT IT AS SQA
         B     BADFRAME                ?????????????
         SPACE 3
NXTFRAME DS    0H
         LA    R2,X'10'(,R2)       POINT TO NEXT PFTE
         B     FRAME
         EJECT
**********************************************************************
*                                                                    *
*   NOMORE  ---  WE HAVE LOOPED THROUGH ALL PAGE FRAME TABLES AND    *
*            HAVE ALL THE DATA NEEDED.  NOW WE WILL CONVERT NUMBERS  *
*            AND PERCENTAGES TO EBCDIC SO THAT THEY ARE READABLE.    *
*            WE CALL SCRNMGR AFTER EACH OUTPUT LINE IS PRODUCED SO   *
*            THAT HE CAN MOVE IT INTO THE SCREEN BUFFER AND UPDATE   *
*            THE NECESSARY POINTERS.                                 *
*                                                                    *
**********************************************************************
         SPACE 3
NOMORE   DS    0H
         XC    PAGE,PAGE               ZERO FLAGS
         LA    R1,LTOP                 3270 DATA FOR PARTS OF SCREEN
         LA    R0,TOPSCRN
         LA    R15,SCRNMGR
         BALR  R14,R15                 PUT IN SCREEN BUFFER
         SPACE 5
         MVI   LINE,C' '               BLANK OUT OUTPUT LINE
         MVC   LINE+1(L'LINE-1),LINE
         DROP  R9                      NEED ALL REGISTERS WE CAN GET
         L     R9,ALL                  TOTAL SYSTEM FRAMES
         PERCENT SQA,R9,VERSION=1,TYPE=A
         PERCENT CSA,R9,VERSION=2,TYPE=A
         PERCENT LPA,R9,VERSION=3,TYPE=A
         PERCENT PRIV,R9,VERSION=4,TYPE=A
         PERCENT LSQA,R9,VERSION=5,TYPE=A
         LA    R0,LINE                 LOAD ADDRESS TO LINE
         LA    R1,L'LINE               LOAD LENGTH OF OUTPUT LINE
         LA    R15,SCRNMGR
         BALR  R14,R15                 PUT IN SCREEN BUFFER
         SPACE 5
         MVI   LINE,C' '               BLANK OUT OUTPUT LINE
         MVC   LINE+1(L'LINE-1),LINE
         PERCENT AVAIL,R9,VERSION=1,TYPE=A
         PERCENT CSAF,R9,VERSION=2,TYPE=A
         PERCENT LPAF,R9,VERSION=3,TYPE=A
         PERCENT PRIVF,R9,VERSION=4,TYPE=A
         PERCENT NUC,R9,VERSION=5,TYPE=A
         LA    R0,LINE                 LOAD ADDRESS TO LINE
         LA    R1,L'LINE               LOAD LENGTH OF OUTPUT LINE
         LA    R15,SCRNMGR
         BALR  R14,R15                 PUT IN SCREEN BUFFER
         SPACE 5
         MVI   LINE,C' '               BLANK OUT OUTPUT LINE
         MVC   LINE+1(L'LINE-1),LINE
         PERCENT VIO,R9,VERSION=1,TYPE=A
         PERCENT BAD,R9,VERSION=2,TYPE=A
         PERCENT UIC,R9,TYPE=B
         PERCENT ALL,R9,TYPE=B
         LA    R0,LINE                 LOAD ADDRESS TO LINE
         LA    R1,L'LINE               LOAD LENGTH OF OUTPUT LINE
         LA    R15,SCRNMGR
         BALR  R14,R15                 PUT IN SCREEN BUFFER
         SPACE 5
         MVI   LINE,C' '               BLANK OUT OUTPUT LINE
         MVC   LINE+1(L'LINE-1),LINE
         PERCENT CPU,R9,TYPE=B
         PERCENT ASM,R9,TYPE=B
         PERCENT AVG,R9,0,TYPE=B
         LA    R0,LINE                 LOAD ADDRESS TO LINE
         LA    R1,L'LINE               LOAD LENGTH OF OUTPUT LINE
         LA    R15,SCRNMGR
         BALR  R14,R15                 PUT IN SCREEN BUFFER
         SPACE 5
         LA    R0,HEADLINE             HEADER LINE
         LA    R1,LHEADER              ITS LENGTH
         LA    R15,SCRNMGR
         BALR  R14,R15
         SPACE 5
         LA    R1,LMID
         LA    R0,MIDSCRN              SBA"S FOR DA PORTION OF SCREEN
         LA    R15,SCRNMGR
         BALR  R14,R15                 PUT IN SCREEN BUFFER
         SPACE 5
         LA    R1,SCREEN
         A     R1,LSCREEN
         ST    R1,DASTART              START OF DA PART OF OUTPUT SCRN
         EJECT
**********************************************************************
*                                                                    *
*   ASCBNEXT --- THE ASVT CONTAINS A LIST OF ADRESSES FOR            *
*             THE ASCB'S IN THE SYSTEM.  AN ENTRY OF ZERO INDICATES  *
*             THE END OF THE LIST.                                   *
*                THIS ROUTINE GO THROUGH ALL THE ASCB'S AND FINDS    *
*             THE JOBNAME AND ASID AND WORKING SET AND CPU TIME AND  *
*             WRITES THEM OUT TO THE SCREEN BUFFER VIA SCRNMGR.      *
*                                                                    *
**********************************************************************
         SPACE 2
ASCBNEXT DS    0H
         NI    FLAGS,X'FF'-STRTASK     RESET STARTED TASK FLAG
ASCBNXT  MVI   LINE,C' '
         MVC   LINE+1(L'LINE-1),LINE
         LA    R11,4(R11)              ---> NEXT ASVT ENTRY
         L     R2,0(R11)               ---> ASCB
         LA    R2,0(R2)                ZERO HIGH ORDER BIT
         LTR   R2,R2                   SEE IF ADDRESS IS ZERO
         BZ    LASTASCB                YES...GO HANDLE OUTPUT LINE
         USING ASCB,R2
         TM    0(R11),X'80'            SEE IF ASID IS AVAILABLE
         BO    ASCBNXT
         CLC   ASCBASCB,=CL4'ASCB'     SEE IF CONTROL BLOCK IS VALID
         BNE   ASCBNXT
GOTASCB  L     R8,ASCBJBNI             POINTER TO JOB NAME FIELD
         LTR   R8,R8                   SEE IF POINTER IS ZERO
         BZ    STASK                   YES...SEE IF STARTED TASK
BATCH    MVC   LINEJOBN,0(R8)          MOVE JOB NAME TO PRINT LINE
         B     EDITASID                EDIT LINE FOR OUTPUT
         SPACE 1
STASK    DS    0H
         L     R8,ASCBJBNS             POINTER TO JOBNAME FIELD
         LTR   R8,R8                   SEE IF POINTER IS ZERO
         BZ    NOJOBN                  YES...NO JOBNAME
         MVC   LINEJOBN,0(R8)          MOVE JOBNAME TO PRINT LINE
         SR    0,0
         C     R0,ASCBTSB              TSB POINTER ZERO?
         BNE   EDITASID                NO...TSU (OFFSET LIKE BATCH)
         OI    FLAGS,STRTASK           REMEMBER ITS A STARTED TASK
         SH    R8,=H'8'                ADJUST PTR SO SAME AS INIT JOB
         B     EDITASID                EDIT OUTPUT LINE
         SPACE 1
NOJOBN   DS    0H
         MVC   LINEJOBN,NOJOB          MOVE "   *   " TO PRINT LINE
EDITASID DS    0H
         LH    R4,36(R2)               LOAD ADDRESS SPACE ID
         CVD   R4,PACK
         MVC   CHAR(L'EDMSK),EDMSK
         ED    CHAR,PACK+4
         MVC   LINEASID,CHAR+6         MOVE ASID TO PRINT LINE
         L     R0,64(R2)               TCB TIMER FIRST 4 BYTES
         L     R1,68(R2)               TCB TIMER SECOND 4 BYTES
         AL    R1,204(,R2)             ADD LOW WORD OF SRB TIME
         BC    12,*+8                  NO CARRY - SKIP THE INCREMENT
         AL    R0,=F'1'                CARRY - INCREMENT HIGH WORD
         AL    R0,200(,R2)             ADD HIGH WORD OF SRB TIME
         SRDA  R0,12                   SHIFT SO BIT 51=1 MICROSECOND
         D     R0,CONSTANT             CHANGE MICROSECONDS INTO SECONDS
         CVD   R1,PACK                 PACK THE SECONDS
         MVC   CHAR(L'EDMSK3),EDMSK3
         ED    CHAR,PACK+4
         MVC   LINECPU,CHAR            MOVE SECONDS TO OUTPUT LINE
         L     R8,ASCBOUCB             ---> OUCB
         USING OUCB,R8                 ADDRESSIBILITY TO OUCB
         LH    R7,OUCBWSS              WORKING SET IN
         ICM   R7,B'1100',ZERO         ZERO UPPER TWO BYTES
         DROP  R8                      FREE REGISTER 8
         CVD   R7,PACK
         MVC   CHAR(L'EDMSK),EDMSK     PACK WORKING SET FOR OUTPUT
         ED    CHAR,PACK+4
         MVC   LINEWRKS,CHAR+4         MOVE WORKING SET TO OUTPUT LINE
         LR    R1,R4                   LOAD ASID INTO R1
         SLA   R1,2                    4 TIMES ASID TO FIND OFFSET
         L     R7,PRIVCNT(R1)          LOAD PRIVATE COUNT FOR THIS ASID
         A     R7,PRIVFCNT(R1)         LOAD PRIVATE FIXED FOR THIS ASID
         A     R7,LSQACNT(R1)          LOAD LSQA COUNT FOR THSI ASID
         LTR   R7,R7                   SEE IF TOTAL REAL FRAMES=0
         BZ    ASCBNEXT                IF SO ASSUME ASID IS SWAPPED OUT+
                                       AND OUTPUT NOTHING
         ST    R7,THISTEMP             TEMPORARY LOCATION FOR TOT FRMS
         PERCENT THISTEMP,R9,TYPE=C,VAR=FRAME
         PERCENT PRIVCNT,R7,BASE=R1,TYPE=C,VAR=PRIV
         PERCENT PRIVFCNT,R7,BASE=R1,TYPE=C,VAR=PRIVF
         PERCENT LSQACNT,R7,BASE=R1,TYPE=C,VAR=LSQA
         LA    R0,LINE
         LA    R1,L'LINE
         LA    R15,SCRNMGR
         BALR  R14,R15                 PUT IN SCREEN BUFFER
         B     ASCBNEXT
         DROP  R2
         EJECT
**********************************************************************
*                                                                    *
*  CONVERT --- TAKES A NUMBER REPRESENTING A PERCENTAGE AND CONVERTS *
*      IT INTO AN EBCDIC NUMBER RIGHT JUSTIFIED IN A FIELD WITH A    *
*      % SIGN FOLLOWING.                                             *
*           IT IS ONLY CALLED FROM THE PERCENT MACRO.                *
*                                                                    *
**********************************************************************
         SPACE 2
CONVERT  DS    0H
         CVD   R3,PACKED
         LA    R4,1000
         SR    R2,R2
         MR    R2,R4                   MULTIPLY TOTAL COUNT BY 1000
         DR    R2,R0                   FIND % TIMES 10
         CVD   R3,COUNTX10             STORE % X 10 PACKED IN DW
         SRP   COUNTX10(8),64-1,5      DIVIDE COUNTX10 BY 10 AND       +
                                       ROUND TO THE NEAREST %
         SRP   COUNTX10(8),1,0         SHIFT BACK TO LINE UP FOR EDIT
         MVC   CHAR(L'EDMSK),EDMSK
         ED    CHAR,PACKED+4           EDIT &COUNT FOR OUTPUT
         MVC   CHAR2(L'EDMSK2),EDMSK2
         BR    R14
         EJECT
**********************************************************************
*                                                                    *
*    LASTASCB --- WE HAVE COLLECTED ALL OUTPUT LINES INTO "SCREEN".  *
*              SINCE WE DO NOT HAVE AN INFINITELY LENGTHY SCREEN     *
*              WE MUST NOW DETERMINE WHICH PORTIONS OF THE "SCREEN"  *
*              BUFFER ARE TO BE TPUTED DEPENDING ON THE              *
*              CIRCUMSTANCES.  "LASTASCB" UPDATES THE NECESSARY      *
*              POINTERS AND FLAGS AND THEN CALLS "SCRNMGR" TO HANDLE *
*              ALL THE DIRTY WORK.                                   *
*                                                                    *
*     DASTART  --- ADDRESS OF FIRST LINE OF INDIVIDUAL JOB OUTPUT    *
*               SECTION OF SCREEN.  (WHERE *MASTER* BEGINS)          *
*     LSCREEN  --- LENGTH OF ALL DATA IN "SCREEN BUFFER".            *
*               THIS INCLUDES ALL 3270 CONTROL CHARACTERS FOR TPUT.  *
*     LDA      --- LENGTH FROM DASTART TO SCREEN+LSCREEN.            *
*     TPUTSTRT --- BEGINNING ADDRESS OF WHERE TO TPUT FROM           *
*     @ENDTPUT --- ENDING ADDRESS OF TPUT BUFFER                     *
*                                                                    *
**********************************************************************
         SPACE 2
LASTASCB DS    0H                      GONE THRU ALL ASCB"S            +
                                       FOR NEXT RESPONSE
         OI    PAGE,ENDLINES           END OF PUTTING LINES INTO BUFFER
         L     R1,DASTART
         LA    R0,SCREEN
         A     R0,LSCREEN              ADDRESS OF END OF SCREEN
         SR    R0,R1
         ST    R0,LDA                  LENGTH OF DA SECTION OF SCREEN
         SPACE 2
GOTREPLY TM    PAGE,MOREPAGE           ARE WE HERE CAUSE OF "FOREWARD"?
         BNO   CHKPAGE                 NO,,,SEE IF F NEEDED NEXT TIME
         OI    PAGE,NOTPAGE1           THIS IS NOT THE FIRST PAGE
         L     R1,DASTART              START OF DA
         LA    R1,LINE16(,R1)          UPDATE POINTER FOR 1 PAGE
         ST    R1,DASTART
         XI    PAGE,MOREPAGE           IF STILL MORE PAGES,,WILL BE SET+
                                           BY CHKPAGE.
         SPACE 1
CHKPAGE  DS    0H
         CLC   LDA,LINES16             MORE PAGES NEEDED?
         BNH   ONEPAGE
         OI    PAGE,MOREPAGE           SET FLAG FOR MORE PAGES
         L     R2,LDA
         S     R2,LINES16              DECREMENT LDA FOR PAGE
         ST    R2,LDA
         LA    R1,LINE16(,R1)          R1 STILL CONTAINS DASTART
         ST    R1,@ENDTPUT             ADDRESS OF END OF TPUT BUFFER
         B     DOSCREEN
         SPACE 1
ONEPAGE  LA    R1,SCREEN               FOR 1 PAGE THE LENGTH FOR TPUT -
         A     R1,LSCREEN                WILL EQUAL LSCREEN           -
         ST    R1,@ENDTPUT               AND WILL BE END OF TPUT BUFFER
         SPACE 2
DOSCREEN DS    0H
         LA    R15,SCRNMGR
         BALR  R14,R15                 LET SCRNMGR HANDLE TPUT
         LA    R1,RESPONSE
         LA    R0,L'RESPONSE
         ICM   R1,B'1000',=X'81'       TGET ASIS OPTIONS
         TGET  (1),(0),R               GET RESPONSE
         CLI   RESPONSE,C'3'           SEE IF PF3 WAS ENTERED
         BE    RETURN                  IF YES THEN END
         OI    RESPONSE+6,C' '         CHANGE TO UPPER CASE
         CLI   RESPONSE+6,C'Z'         SEE IF "Z" WAS ENTERED.
*                                      SEVENTH BYTE OF TERMINAL INPUT
*                                      REPRESENTS LOWER CASE OF
*                                      CHARACTER THAT WAS ENTERED
         BE    RETURN                  IF YES THEN END
         TM    PAGE,MOREPAGE           ARE MORE PAGES AVAILABLE?
         BNO   START                   NO,,,START OVER
         CLI   RESPONSE,C'7'           PF7?
         BE    START                   YES,,,START OVER
         CLI   RESPONSE+6,C'F'         FOREWARD?
         BE    GOTREPLY                LET SCREEN MANAGER HANDLE IT
         CLI   RESPONSE,C'8'           PF8?
         BE    GOTREPLY                LET SCREEN MANAGER HANDLE IT
         B     START                   ELSE FREE AREA THEN START OVER
         EJECT
**********************************************************************
*                                                                    *
*   SCRNMGR --- WHEN MOVING OUTPUT LINES INTO SCREEN BUFFER ONLY     *
*            SCRNMGR GETS USED.                                      *
*               WHEN A TPUT IS NEEDED THEN MANAGER2 GET INVOKED.     *
*                                                                    *
**********************************************************************
         SPACE 2
SCRNMGR  SAVE  (2,4),,*
         TM    PAGE,NOTHING            NOTHING SPECIAL?
         BM    MANAGER2                YES,,,GO TO SECOND LEVEL
         LA    R2,SCREEN
         A     R2,LSCREEN              NEXT AVAILABLE BYTE IN SCREEN
         LR    R3,R1                   MOVE AREAS OF EQUAL SIZE
         L     R4,LSCREEN              CURRENT LENGTH OF SCREEN
         AR    R4,R3                   UPDATE LENGTH
         ST    R4,LSCREEN              STORE IT BACK
         MVCL  R2,R0                   PUT IT INTO SCREEN BUFFER
         RETURN (2,4)                  RESTORE WORK REGISTERS
         EJECT
**********************************************************************
*                                                                    *
*   MANAGER2 --- IF THIS IS PAGE 1 THEN ALL CONTROL CHARACTERS ARE   *
*             ALREADY TAKEN CARE OF.  IF NOT THAN THEY MUST BE       *
*             INSERTED BEFORE DASTART AND ALL APPROPRIATE POINTERS   *
*             MUST BE UPDATED.  IF THIS IS THE CASE THAN THE UPPER   *
*             PORTION OF THE SCREEN IS NOT ERASED AND THUS NOT       *
*             RETRANSMITTED.  IF THERE IS MORE INFO THAN WILL FIT ON *
*             THIS SCREEN THAN AN "F" NEEDS TO BE INSERTED AT THE    *
*             BOTTOM OF THE SCREEN WITH THE MODIFIED DATA TAG        *
*             ALREADY SET.                                           *
*                                                                    *
**********************************************************************
         SPACE 2
MANAGER2 DS    0H
         TM    PAGE,NOTPAGE1           SEE IF SBA"S NEED TO BE FOUND
         BNO   ISPAGE1                 NO,,, BRANCH AROUND SBA ROUTINE
SETSBA   LA    R0,LSBA
         L     R1,DASTART
         SR    R1,R0                   BUFFER START FOR TPUT
         ST    R1,TPUTSTRT
         MVC   0(LSBA,R1),WCCDA        MOVE IT TO TPUT BUFFER
         TM    PAGE,MOREPAGE
         BNO   TPUTIT
         MVI   EFF2(R1),C'F'
         B     TPUTIT
         SPACE 3
ISPAGE1  LA    R1,SCREEN
         ST    R1,TPUTSTRT             START OF TPUT ADDRESS FOR 1 PAGE
         TM    PAGE,MOREPAGE
         BNO   TPUTIT
         MVI   EFF(R1),C'F'
         SPACE 3
TPUTIT   DS    0H
         L     R2,@ENDTPUT             END OF TPUT BUFFER
         L     R3,TPUTSTRT             START OF TPUT BUFFER
         SR    R2,R3                   LENGTH OF BUFFER
         TPUT  (3),(2),FULLSCR
         RETURN (1,3)                  RESTORE WORK REGISTERS
         EJECT
RETURN   DS    0H
         TPUT NEWSCRN,L'NEWSCRN,FULLSCR        CLEAR SCREEN
         STFSMODE OFF
         LA    R1,CORE                 -> ADDRESS OF WORKAREA
         L     R0,=A(CORESIZE)         LENGTH OF WORKAREA
         L     R13,4(,R13)             -> OUR ORIGINAL SAVEAREA
         FREEMAIN R,A=(1),LV=(0)       FREE IT
         SPACE
         SR    R15,R15                 ALWAYS ZERO RC
         RETURN (14,12),,RC=(15)       RETURN
         EJECT
         LTORG
         SPACE 3
         CVT  DSECT=YES,LIST=NO
         IHAASVT DSECT=YES
         IHAPVT DSECT=YES
         IHAASCB DSECT=YES
         IRAOUCB                       OUCB
         EJECT
CORE     DSECT
         DS    18F                     SAVEAREA
DASTART  DS    F                       START OF DA SECTION OF SCREEN
AREA     DS    F                       BEGINNING OF WORK AREA
PRIVFCNT DS    120F
PRIVCNT  DS    120F
LSQACNT  DS    120F
CPU      DS    F
ASM      DS    F
THISTEMP DS    F
SQA      DS    F
LSQA     DS    F
NUC      DS    F
AVAIL    DS    F
BAD      DS    F
VIO      DS    F
ALL      DS    F
CSAF     DS    F
CSA      DS    F
LPAF     DS    F
LPA      DS    F
PRIVF    DS    F
PRIV     DS    F
UIC      DS    F                       HI UIC (MCVSTCRI OF MCT)
AVG      DS    F                       AVG UIC (RCVUICA OF RCT)
FLAGS    DS    X
         SPACE 2
STRTASK  EQU   X'80'
         SPACE 10
LINE     DS    CL80
         SPACE 2
         ORG   LINE                    OVERLAY ON TOP OF LINE
TITLE1   DS    CL6
VALUE1   DS    CL4
PERCENT1 DS    CL5
TITLE2   DS    CL6
VALUE2   DS    CL4
PERCENT2 DS    CL5
TITLE3   DS    CL6
VALUE3   DS    CL4
PERCENT3 DS    CL5
TITLE4   DS    CL6
VALUE4   DS    CL4
PERCENT4 DS    CL5
TITLE5   DS    CL6
VALUE5   DS    CL4
PERCENT5 DS    CL5
         SPACE 1
         ORG   TITLE3                  OVERLAY FOR OUTPUT LINE 3
TITLEUIC DS    CL10
VALUEUIC DS    CL4
TITLEALL DS    CL9
VALUEALL DS    CL4
         SPACE 2
         ORG   LINE
TITLECPU DS    CL9
VALUECPU DS    CL4
TITLEASM DS    CL8
VALUEASM DS    CL9
TITLEAVG DS    CL10
VALUEAVG DS    CL4
         SPACE 2
         ORG   LINE
         DS    C
LINEJOBN DS    CL8
         DS    CL2
LINEASID DS    CL2
         DS    CL2
TOTFRAME DS    CL4
PERFRAME DS    CL6                     PERCENT FOR TOTAL FRAMES
         DS    CL1
TOTPRIV  DS    CL4
PERPRIV  DS    CL6                     PERCENT FOR TOTAL PRIVATE FRAMES
         DS    CL1
TOTPRIVF DS    CL4
PERPRIVF DS    CL6                     PERCENT FOR TOTAL FIXED PRIVATE
         DS    CL1
TOTLSQA  DS    CL4
PERLSQA  DS    CL6                     PERCENT FOR TOTAL LSQA FRAMES
         DS    CL1
LINEWRKS DS    CL4
         DS    CL5
LINECPU  DS    CL9                     CPU TIME FOR JOB
         SPACE 1
         ORG   ,                       RESET OFFSETS
CHAR     DS    CL9
CHAR2    DS    CL11
RESPONSE DS    CL80
PACK     DS    D
COUNTX10 DS    D
PACKED   DS    D
LSCREEN  DS    F                       LENGTH OF BUFF FOR FULLSCR TPUT
LDA      DS    F
@ENDTPUT DS    F
TPUTSTRT DS    F
         SPACE 5
PAGE     DS    X
MOREPAGE EQU   X'80'
NOTPAGE1 EQU   X'40'
ENDLINES EQU   X'20'
NOTHING  EQU   X'FF'                   ENABLES US TO TEST FOR ANY BITS
         SPACE 3
AREASIZE EQU   *-AREA                  AREA OF WORKAREA TO BE ZEROED
SCREEN   DS    CL10000
         DS    0D                      ROUND UP TO DOUBLEWORD
CORESIZE EQU   *-CORE                  SIZE OF WORKAREA
         EJECT
RSMAP    CSECT
         DS    0D
NEWSCRN  DC    X'27F1115D7E114040133C404000'                    **DWP**
TOPSCRN  DC    X'27F5'                 ESCAPE 5 --- CLEAR AND WRITE
         WCC   (FREEKB,FRSET)          UNLOCK KEYBOARD AND RESET MDT"S
         SBA   (24,1)                  BOTTOM LINE OF SCREEN
         SF    (UNPROT,IC,FSET,BRT)    SET MDT AND PUT "F" AND _ HERE
EFF      EQU   *-TOPSCRN               WHERE TO PUT "F"
         DC    C' '
         SBA   (1,1)                   HI INTENSE FOR TOP OF SCREEN
         SF    (PROT,BRT)
LTOP     EQU   *-TOPSCRN
         SPACE 3
MIDSCRN  SBA   (7,1)                   FIRST LINE FOR LOW INTENSITY
         SF    (PROT,NORM)
LMID     EQU   *-MIDSCRN
         SPACE 3
HEADLINE SBA   (6,2)                   HEADER LINE FOR DA SECTION
HEADER   DC   CL80' JOBNAME  ASID TOT FRAME    PRIVATE   PRIV FIX      *
               LSQA   WORKSET   CPU TIME'
LHEADER  EQU   *-HEADLINE
         SPACE 3
WCCDA    WCC   (FREEKB,FRSET)          FREE KEYBOARD AND RESET MDT'S
         SBA   (7,1)                   DASTART
         RA    (23,80),CHAR=' '        CLEAR BOTTOM HALF OF SCREEN
         SBA   (24,1)                  BOTTOM LINE OF SCREEN
         SF    (UNPROT,IC,FSET,BRT)    SET MDT AND PUT "F" AND _ HERE
EFF2     EQU   *-WCCDA                 WHERE TO PUT "F"
         DC    C' '
         SBA   (7,1)
         SF    (NORM,PROT)             UNHIGHLIGHTED AND PROTECTED
LSBA     EQU   *-WCCDA                 LENGTH OF SBA SEQUENCE
         SPACE 5
XXSQA    DC    C' SQA  '
XXCSA    DC    C' CSA  '
XXLPA    DC    C' LPA  '
XXPRIV   DC    C' PRIV '
XXLSQA   DC    C' LSQA '
XXAVAIL  DC    C' AVAL '
XXCSAF   DC    C' CSAF '
XXLPAF   DC    C' LPAF '
XXPRIVF  DC    C' PRIVF'
XXNUC    DC    C' NUC  '
XXVIO    DC    C' VIO  '
XXBAD    DC    C' BAD  '
XXUIC    DC    C' HI  UIC '
XXALL    DC    C'  TOTAL '
XXCPU    DC    C' CPU UTIL'
XXASM    DC    C'   ASMQ '
XXAVG    DC    C' AVG UIC  '
HUNDPER  DC    C'(100%)'
BLANK    DC    C'      '
EDMSK    DC    XL8'4020202020202120'
EDMSK2   DC    XL11'40202020214D20216C5D20'
EDMSK3   DC    XL9'4020202020214B2020'
ZERO     DC    X'0000'
CCVUTILP EQU   X'66',2             CCT CPU UTILIZATION
ASMIORQR EQU   X'28'                   I/O REQUESTS RECEIVED
ASMIORQC EQU   X'2C'                   I/O REQUESTS COMPLETED
RMCTMCT  EQU   X'C',4              ---> MCT
MCVSTCRI EQU   X'80',2             HIUIC COUNT
RMCTRCT  EQU   X'E4',4             ---> RCT
RCVUICA  EQU   X'3E',2             AVERAGE UIC COUNT
CHTRKID  EQU   20
CHINITID EQU   X'03'
CONSTANT DC    F'10000'
NOJOB    DC    C'   **   '
LINES16  DC    F'1280'                 16 X 80 = 1280
LINE16   EQU   1280
         END   RSMAP
/*
