 /* DRAW: ISPF/PDF edit macro to produce line drawings                */
 DRAW: PROCEDURE OPTIONS(MAIN,REENTRANT);
 /*********************************************************************/
 /*                                                                   */
 /*  ISPF/PDF edit macro to produce straight-line graphic drawings    */
 /*  and to manipulate blocks of text.                                */
 /*                                                                   */
 /*           ZDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD?          */
 /*           3                                            3          */
 /*           3  This program and its associated panels,   3          */
 /*           3   messages, and clists is a handout for:   3          */
 /*           3                                            3          */
 /*           DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD          */
 /*           3                                            3          */
 /*           3         GUIDE 70 Session MP-7292A          3          */
 /*           3      'Advanced ISPF/PDF Edit Macros'       3          */
 /*           3              March 16, 1988                3          */
 /*           3                                            3          */
 /*           DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDD          */
 /*           3                                            3          */
 /*           3                Dan Dirkse                  3          */
 /*           3           ISPF/PDF Development             3          */
 /*           3                   IBM                      3          */
 /*           3                                            3          */
 /*           @DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDY          */
 /*                                                                   */
 /*  To run:                                                          */
 /*   Enter !DRAW HELP on the edit command line and read the          */
 /*   tutorial for information on the various functions.              */
 /*                                                                   */
 /*  Panels used:                                                     */
 /*    DRAWOPT1 - Options panel                                       */
 /*    DRAW0000 - Top Tutorial Panel                                  */
 /*    DRAW0100 - Tutorial Panel                                      */
 /*    DRAW0200 - Tutorial Panel                                      */
 /*    DRAW0210 - Tutorial Panel                                      */
 /*    DRAW0300 - Tutorial Panel                                      */
 /*    DRAW0400 - Tutorial Panel                                      */
 /*    DRAW0500 - Tutorial Panel                                      */
 /*    DRAW0600 - Tutorial Panel                                      */
 /*    DRAW0700 - Tutorial Panel                                      */
 /*    DRAW0800 - Tutorial Panel                                      */
 /*    DRAW0900 - Tutorial Panel                                      */
 /*    DRAW1000 - Tutorial Panel                                      */
 /*    DRAW1100 - Tutorial Panel                                      */
 /*    DRAW1200 - Tutorial Panel                                      */
 /*    DRAW1300 - Tutorial Panel                                      */
 /*    DRAW1400 - Tutorial Panel                                      */
 /*    DRAW1500 - Tutorial Panel                                      */
 /*    DRAW1510 - Tutorial Panel                                      */
 /*    DRAW1520 - Tutorial Panel                                      */
 /*                                                                   */
 /*  Messages members used:                                           */
 /*    DRAW00                                                         */
 /*    DRAW01                                                         */
 /*    DRAW02                                                         */
 /*    DRAW03                                                         */
 /*                                                                   */
 /*  Shared pool variables used:                                      */
 /*    PT1COL   - Column of current point                             */
 /*    MARKTLBL - Top label of marked block                           */
 /*    MARKBLBL - Bottom label of marked block                        */
 /*    MARKTROW - Top row number of marked block                      */
 /*    MARKBROW - Bottom row number of marked block                   */
 /*    MARKLCOL - Left column number of marked block                  */
 /*    MARKRCOL - Right column number of marked block                 */
 /*    DRAWDSN  - Data set in which last POINT/MARK was done          */
 /*    DRAWMEMB - Member in which last POINT/MARK was done            */
 /*                                                                   */
 /*  Profile pool variables used:                                     */
 /*    DRAWCSET - Current character set in use                        */
 /*    DRAWPT   - Point character                                     */
 /*    DRAWLNH  - Horizontal line character                           */
 /*    DRAWLNV  - Vertical line character                             */
 /*    DRAWARU  - Up arrow character                                  */
 /*    DRAWARD  - Down arrow character                                */
 /*    DRAWARL  - Left arrow character                                */
 /*    DRAWARR  - Right arrow character                               */
 /*    DRAWBXHT - Top horizontal line character for boxes             */
 /*    DRAWBXHB - Bottom horizontal line character for boxes          */
 /*    DRAWBXVL - Left vertical line character for boxes              */
 /*    DRAWBXVR - Right vertical line character for boxes             */
 /*    DRAWBXUL - Upper left hand corner character for boxes          */
 /*    DRAWBXUR - Upper right hand corner character for boxes         */
 /*    DRAWBXLL - Lower left hand corner character for boxes          */
 /*    DRAWBXLR - Lower right hand corner character for boxes         */
 /*    DRAWFILL - Fill character                                      */
 /*    DRAWJOIN - Status of AUTOJOIN (ON or OFF)                      */
 /*                                                                   */
 /*  This macro will run in both the MVS and VM environments.         */
 /*                                                                   */
 /*********************************************************************/


 /*********************************************************************/
 /*                        C o n s t a n t s                          */
 /*********************************************************************/
   DECLARE
     1 PARM_LIST STATIC,
       2 HELP     CHAR(8) INIT('HELP    '),
       2 OPTIONS  CHAR(8) INIT('OPTIONS '),
       2 POINT    CHAR(8) INIT('POINT   '),
       2 LINE     CHAR(8) INIT('LINE    '),
       2 ARROW    CHAR(8) INIT('ARROW   '),
       2 DARROW   CHAR(8) INIT('DARROW  '),
       2 BOX      CHAR(8) INIT('BOX     '),
       2 JOIN     CHAR(8) INIT('JOIN    '),
       2 AUTOJOIN CHAR(8) INIT('AUTOJOIN'),
       2 MARK     CHAR(8) INIT('MARK    '),
       2 COPY     CHAR(8) INIT('COPY    '),
       2 OCOPY    CHAR(8) INIT('OCOPY   '),
       2 MOVE     CHAR(8) INIT('MOVE    '),
       2 OMOVE    CHAR(8) INIT('OMOVE   '),
       2 FILL     CHAR(8) INIT('FILL    '),
       2 OFILL    CHAR(8) INIT('OFILL   '),
       2 ERASE    CHAR(8) INIT('ERASE   '),
       2 FINDMARK CHAR(8) INIT('FINDMARK'),
       2 RESET    CHAR(8) INIT('RESET   ');
   DECLARE
     PARM_ARRAY(19) CHAR(8) DEFINED(PARM_LIST);
   DECLARE
     CSR_IN_DATA_ARRAY(19) CHAR(1) STATIC
       INIT((2)(1)'N',(6)(1)'Y',(1)(1)'N',(5)(1)'Y',(5)(1)'N'),
     POINT_NEEDED_ARRAY(19) CHAR(1) STATIC
       INIT((3)(1)'N',(4)(1)'Y',(12)(1)'N'),
     NUM_OFF_ARRAY(19)     CHAR(1) STATIC
       INIT((2)(1)'N',(15)(1)'Y',(1)(1)'N',(1)(1)'Y');
   DECLARE
     /* Message and panel name constants                              */
     DRAW000  CHAR(8) STATIC INIT('DRAW000 '),
     DRAW001  CHAR(8) STATIC INIT('DRAW001 '),
     DRAW002  CHAR(8) STATIC INIT('DRAW002 '),
     DRAW003  CHAR(8) STATIC INIT('DRAW003 '),
     DRAW004  CHAR(8) STATIC INIT('DRAW004 '),
     DRAW005  CHAR(8) STATIC INIT('DRAW005 '),
     DRAW006  CHAR(8) STATIC INIT('DRAW006 '),
     DRAW007  CHAR(8) STATIC INIT('DRAW007 '),
     DRAW008  CHAR(8) STATIC INIT('DRAW008 '),
     DRAW009  CHAR(8) STATIC INIT('DRAW009 '),
     DRAW010  CHAR(8) STATIC INIT('DRAW010 '),
     DRAW011  CHAR(8) STATIC INIT('DRAW011 '),
     DRAW012  CHAR(8) STATIC INIT('DRAW012 '),
     DRAW015  CHAR(8) STATIC INIT('DRAW015 '),
     DRAW016  CHAR(8) STATIC INIT('DRAW016 '),
     DRAW017  CHAR(8) STATIC INIT('DRAW017 '),
     DRAW018  CHAR(8) STATIC INIT('DRAW018 '),
     DRAW019  CHAR(8) STATIC INIT('DRAW019 '),
     DRAW020  CHAR(8) STATIC INIT('DRAW020 '),
     DRAW021  CHAR(8) STATIC INIT('DRAW021 '),
     DRAW022  CHAR(8) STATIC INIT('DRAW022 '),
     DRAW023  CHAR(8) STATIC INIT('DRAW023 '),
     DRAW024  CHAR(8) STATIC INIT('DRAW024 '),
     DRAW025  CHAR(8) STATIC INIT('DRAW025 '),
     DRAW027  CHAR(8) STATIC INIT('DRAW027 '),
     DRAW028  CHAR(8) STATIC INIT('DRAW028 '),
     DRAW029  CHAR(8) STATIC INIT('DRAW029 '),
     DRAW030  CHAR(8) STATIC INIT('DRAW030 '),
     DRAW031  CHAR(8) STATIC INIT('DRAW031 '),
     DRAWOPT1 CHAR(8) STATIC INIT('DRAWOPT1'),
     /* Dialog manager service name constants                         */
     CONTROL  CHAR(8) STATIC INIT('CONTROL '),
     DISPLAY  CHAR(8) STATIC INIT('DISPLAY '),
     ERRORS   CHAR(8) STATIC INIT('ERRORS  '),
     ISREDIT  CHAR(8) STATIC INIT('ISREDIT '),
     RETURN   CHAR(8) STATIC INIT('RETURN  '),
     PROFILE  CHAR(8) STATIC INIT('PROFILE '),
     SETMSG   CHAR(8) STATIC INIT('SETMSG  '),
     SHARED   CHAR(8) STATIC INIT('SHARED  '),
     SELECT   CHAR(8) STATIC INIT('SELECT  '),
     VDEFINE  CHAR(8) STATIC INIT('VDEFINE '),
     VDELETE  CHAR(8) STATIC INIT('VDELETE '),
     VGET     CHAR(8) STATIC INIT('VGET    '),
     VPUT     CHAR(8) STATIC INIT('VPUT    '),
     CHR      CHAR(8) STATIC INIT('CHAR'),
     LEN0     BIN FIXED(31) STATIC INIT(0),
     LEN3     BIN FIXED(31) STATIC INIT(3),
     LEN6     BIN FIXED(31) STATIC INIT(6),
     LEN8     BIN FIXED(31) STATIC INIT(8),
     LEN9     BIN FIXED(31) STATIC INIT(9),
     LEN28    BIN FIXED(31) STATIC INIT(28),
     LEN44    BIN FIXED(31) STATIC INIT(44),
     LEN50    BIN FIXED(31) STATIC INIT(50),
     LEN72    BIN FIXED(31) STATIC INIT(72),
     LEN256   BIN FIXED(31) STATIC INIT(256),
     /* Translation constants                                         */
     LOWCASE CHAR(26) STATIC INIT('abcdefghijklmnopqrstuvwxyz'),
     UPPCASE CHAR(26) STATIC INIT('ABCDEFGHIJKLMNOPQRSTUVWXYZ'),
     /* Miscellaneous constants                                       */
     BLANK1   CHAR(1) STATIC INIT(' ');
 /*********************************************************************/
 /*      V D E F I N E   N a m e   L i s t   S t r u c t u r e s      */
 /*********************************************************************/
   DECLARE
     1 CHAR6_VARS_LIST STATIC,
       2 NL1_CNT  BIN FIXED(31) INIT(16),
       2 NL1_RES  BIN FIXED(31) INIT(8),
       2 NL1_NAMES,
         3 NL1_V01  CHAR(8) INIT('CSRROW  '),
         3 NL1_V02  CHAR(8) INIT('PT1ROW  '),
         3 NL1_V03  CHAR(8) INIT('PT2ROW  '),
         3 NL1_V04  CHAR(8) INIT('BOX1ROW '),
         3 NL1_V05  CHAR(8) INIT('BOX2ROW '),
         3 NL1_V06  CHAR(8) INIT('MARK1ROW'),
         3 NL1_V07  CHAR(8) INIT('MARK2ROW'),
         3 NL1_V08  CHAR(8) INIT('MARKTROW'),
         3 NL1_V09  CHAR(8) INIT('MARKBROW'),
         3 NL1_V10  CHAR(8) INIT('LINECNT '),
         3 NL1_V11  CHAR(8) INIT('CURROW  '),
         3 NL1_V12  CHAR(8) INIT('ROWNUM  '),
         3 NL1_V13  CHAR(8) INIT('MSGV1   '),
         3 NL1_V14  CHAR(8) INIT('MSGV2   '),
         3 NL1_V15  CHAR(8) INIT('MSGV3   '),
         3 NL1_V16  CHAR(8) INIT('MSGV4   ');
   DECLARE
     1 CHAR3_VARS_LIST STATIC,
       2 NL2_CNT  BIN FIXED(31) INIT(11),
       2 NL2_RES  BIN FIXED(31) INIT(8),
       2 NL2_NAMES,
         3 NL2_V01  CHAR(8) INIT('CSRCOL  '),
         3 NL2_V02  CHAR(8) INIT('PT1COL  '),
         3 NL2_V03  CHAR(8) INIT('PT2COL  '),
         3 NL2_V04  CHAR(8) INIT('BOX1COL '),
         3 NL2_V05  CHAR(8) INIT('BOX2COL '),
         3 NL2_V06  CHAR(8) INIT('MARK1COL'),
         3 NL2_V07  CHAR(8) INIT('MARK2COL'),
         3 NL2_V08  CHAR(8) INIT('MARKLCOL'),
         3 NL2_V09  CHAR(8) INIT('MARKRCOL'),
         3 NL2_V10  CHAR(8) INIT('LRECL   '),
         3 NL2_V11  CHAR(8) INIT('NUMBER  ');
   DECLARE
     1 DRAW_CHARS_LIST STATIC,
       2 NL3_CNT  BIN FIXED(31) INIT(16),
       2 NL3_RES  BIN FIXED(31) INIT(8),
       2 NL3_NAMES,
         3 NL3_V01  CHAR(8) INIT('DRAWPT  '),
         3 NL3_V02  CHAR(8) INIT('DRAWLNH '),
         3 NL3_V03  CHAR(8) INIT('DRAWLNV '),
         3 NL3_V04  CHAR(8) INIT('DRAWARU '),
         3 NL3_V05  CHAR(8) INIT('DRAWARD '),
         3 NL3_V06  CHAR(8) INIT('DRAWARL '),
         3 NL3_V07  CHAR(8) INIT('DRAWARR '),
         3 NL3_V08  CHAR(8) INIT('DRAWBXHT'),
         3 NL3_V09  CHAR(8) INIT('DRAWBXHB'),
         3 NL3_V10  CHAR(8) INIT('DRAWBXVL'),
         3 NL3_V11  CHAR(8) INIT('DRAWBXVR'),
         3 NL3_V12  CHAR(8) INIT('DRAWBXUL'),
         3 NL3_V13  CHAR(8) INIT('DRAWBXUR'),
         3 NL3_V14  CHAR(8) INIT('DRAWBXLL'),
         3 NL3_V15  CHAR(8) INIT('DRAWBXLR'),
         3 NL3_V16  CHAR(8) INIT('DRAWFILL');
   DECLARE
     1 CHAR8_VARS_LIST STATIC,
       2 NL4_CNT  BIN FIXED(31) INIT(7),
       2 NL4_RES  BIN FIXED(31) INIT(8),
       2 NL4_NAMES,
         3 NL4_V01  CHAR(8) INIT('CORNERCH'),
         3 NL4_V02  CHAR(8) INIT('ARROW1  '),
         3 NL4_V03  CHAR(8) INIT('ARROW2  '),
         3 NL4_V04  CHAR(8) INIT('DRAWCSET'),
         3 NL4_V05  CHAR(8) INIT('DRAWJOIN'),
         3 NL4_V06  CHAR(8) INIT('DRAWMEMB'),
         3 NL4_V07  CHAR(8) INIT('CURRMEMB');
   DECLARE
     1 CHAR9_VARS_LIST STATIC,
       2 NL5_CNT  BIN FIXED(31) INIT(5),
       2 NL5_RES  BIN FIXED(31) INIT(8),
       2 NL5_NAMES,
         3 NL5_V01  CHAR(8) INIT('MARK1LBL'),
         3 NL5_V02  CHAR(8) INIT('MARK2LBL'),
         3 NL5_V03  CHAR(8) INIT('MARKTLBL'),
         3 NL5_V04  CHAR(8) INIT('MARKBLBL'),
         3 NL5_V05  CHAR(8) INIT('ROWLABEL');
   DECLARE
     1 CHAR44_VARS_LIST STATIC,
       2 NL6_CNT  BIN FIXED(31) INIT(2),
       2 NL6_RES  BIN FIXED(31) INIT(8),
       2 NL6_NAMES,
         3 NL6_V01  CHAR(8) INIT('DRAWDSN '),
         3 NL6_V02  CHAR(8) INIT('CURRDSN ');
 /*********************************************************************/
 /*                        V a r i a b l e s                          */
 /*********************************************************************/
   DECLARE BLOCK(BLOCK_HEIGHT) CHAR(BLOCK_WIDTH) CONTROLLED;
   DECLARE
     1 CHAR6_VARS,
       2 CSRROW   PIC'999999',
       2 PT1ROW   PIC'999999',
       2 PT2ROW   PIC'999999',
       2 BOX1ROW  PIC'999999',
       2 BOX2ROW  PIC'999999',
       2 MARK1ROW PIC'999999',
       2 MARK2ROW PIC'999999',
       2 MARKTROW PIC'999999',
       2 MARKBROW PIC'999999',
       2 LINECNT  PIC'999999',
       2 CURROW   PIC'999999',
       2 ROWNUM   PIC'999999',
       2 MSGV1    CHAR(6),
       2 MSGV2    CHAR(6),
       2 MSGV3    CHAR(6),
       2 MSGV4    CHAR(6);
   DECLARE
     1 CHAR3_VARS,
       2 CSRCOL   PIC'999',
       2 PT1COL   PIC'999',
       2 PT2COL   PIC'999',
       2 BOX1COL  PIC'999',
       2 BOX2COL  PIC'999',
       2 MARK1COL PIC'ZZ9',
       2 MARK2COL PIC'ZZ9',
       2 MARKLCOL PIC'999',
       2 MARKRCOL PIC'999',
       2 LRECL    PIC'999',
       2 NUMBER   CHAR(3);
   DECLARE
     1 DRAWING_CHARS,
       2 DRAWPT   CHAR(8),
       2 DRAWLNH  CHAR(8),
       2 DRAWLNV  CHAR(8),
       2 DRAWARU  CHAR(8),
       2 DRAWARD  CHAR(8),
       2 DRAWARL  CHAR(8),
       2 DRAWARR  CHAR(8),
       2 DRAWBXHT CHAR(8),
       2 DRAWBXHB CHAR(8),
       2 DRAWBXVL CHAR(8),
       2 DRAWBXVR CHAR(8),
       2 DRAWBXUL CHAR(8),
       2 DRAWBXUR CHAR(8),
       2 DRAWBXLL CHAR(8),
       2 DRAWBXLR CHAR(8),
       2 DRAWFILL CHAR(8);
   DECLARE
     1 CHAR8_VARS,
       2 CORNERCH CHAR(8),
       2 ARROW1   CHAR(8),
       2 ARROW2   CHAR(8),
       2 DRAWCSET CHAR(8),
       2 DRAWJOIN CHAR(8),
       2 DRAWMEMB CHAR(8),
       2 CURRMEMB CHAR(8);
   DECLARE
     1 CHAR9_VARS,
       2 MARK1LBL CHAR(9),
       2 MARK2LBL CHAR(9),
       2 MARKTLBL CHAR(9),
       2 MARKBLBL CHAR(9),
       2 ROWLABEL CHAR(9);
   DECLARE
     1 CHAR44_VARS,
       2 DRAWDSN  CHAR(44),
       2 CURRDSN  CHAR(44);
   DECLARE
     PARM                CHAR(8),
     PARM1               CHAR(50),
     PARM2               CHAR(50),
     POINT_NEEDED        CHAR(1),
     CSR_MUST_BE_IN_DATA CHAR(1),
     NUM_MUST_BE_OFF     CHAR(1),
     JOIN_CHAR           CHAR(1),
     MSGID               CHAR(8),
     TEMP_COL            PIC'ZZ9',
     COLS_STR            CHAR(7)  VARYING,
     TOPSTR              CHAR(12) VARYING,
     BOTSTR              CHAR(15) VARYING,
     PREFIX              CHAR(72) VARYING,
     DASHES              CHAR(72) VARYING,
     MSGLINET            CHAR(72),
     MSGLINEB            CHAR(72),
     DATALINE            CHAR(256),
     I                   FIXED BIN(31),
     J                   FIXED BIN(31),
     NEWCNT              FIXED BIN(31),
     RISE                FIXED BIN(31),
     RUN                 FIXED BIN(31),
     BLOCK_HEIGHT        FIXED BIN(31),
     BLOCK_WIDTH         FIXED BIN(31),
     JOIN_INDEX          FIXED BIN(31),
     CENTERPT            FIXED BIN(31),
     POSITION            FIXED BIN(31),
     COLRANGE            FIXED BIN(31),
     FOUND               FIXED BIN(31),
     PARMLENG            FIXED BIN(31),
     RETURN_CODE         FIXED BIN(31);

 /*********************************************************************/
 /*            E n t r y   P o i n t s / B u i l t i n s              */
 /*********************************************************************/
   DCL ISPLINK   ENTRY OPTIONS(ASM,INTER,RETCODE);
   DCL PLIRETV   BUILTIN;
   DCL PLIRETC   BUILTIN;
   DCL DIM       BUILTIN;
   DCL LENGTH    BUILTIN;
   DCL MAX       BUILTIN;
   DCL MIN       BUILTIN;
   DCL SUBSTR    BUILTIN;
   DCL TRANSLATE BUILTIN;
   DCL VERIFY    BUILTIN;

 /*********************************************************************/
 /*                    M a i n   P r o c e d u r e                    */
 /*********************************************************************/
   CALL ISPLINK(CONTROL,ERRORS,RETURN);
   CALL VDEFINE_VARIABLES;
   CALL ISPLINK(ISREDIT,LEN0,'$ MACRO (PARM1,PARM2) $');
   SELECT(PLIRETV());
     WHEN (20)
       MSGID = DRAW031;
     WHEN (16)
       MSGID = DRAW030;
     OTHERWISE
       DO;
         CALL INITIALIZE_VARIABLES;
         CALL CHECK_PARM;
       END;
   END; /* Select */
   IF NUM_MUST_BE_OFF = 'Y' & MSGID = ' ' THEN
     CALL CHECK_NUMBER;
   IF POINT_NEEDED = 'Y' & MSGID = ' ' THEN
     CALL FIND_POINT;
   IF CSR_MUST_BE_IN_DATA = 'Y' & MSGID = ' ' THEN
     CALL CHECK_CURSOR;
   IF MSGID = ' ' THEN
     DO;
       /* Save the user state (Last find string, etc.)                */
       CALL ISPLINK(ISREDIT,LEN0,'$ (STATES) = USER_STATE $');
       SELECT;
         WHEN (PARM = HELP)
           CALL PROCESS_HELP;
         WHEN (PARM = OPTIONS)
           CALL PROCESS_OPTIONS(PARM2);
         WHEN (PARM = POINT)
           CALL PROCESS_POINT;
         WHEN (PARM = LINE)
           CALL PROCESS_LINE;
         WHEN (PARM = ARROW)
           CALL PROCESS_ARROWS;
         WHEN (PARM = DARROW)
           CALL PROCESS_ARROWS;
         WHEN (PARM = BOX)
           CALL PROCESS_BOX;
         WHEN (PARM = JOIN)
           CALL PROCESS_JOIN(CSRROW,CSRCOL);
         WHEN (PARM = AUTOJOIN)
           CALL PROCESS_AUTOJOIN;
         WHEN (PARM = MARK)
           CALL PROCESS_MARK;
         WHEN (PARM = COPY)
           CALL PROCESS_COPY;
         WHEN (PARM = OCOPY)
           CALL PROCESS_COPY;
         WHEN (PARM = MOVE)
           CALL PROCESS_MOVE;
         WHEN (PARM = OMOVE)
           CALL PROCESS_MOVE;
         WHEN (PARM = FILL)
           CALL PROCESS_FILL;
         WHEN (PARM = OFILL)
           CALL PROCESS_FILL;
         WHEN (PARM = ERASE)
           CALL PROCESS_ERASE;
         WHEN (PARM = FINDMARK)
           CALL PROCESS_FINDMARK;
         WHEN (PARM = RESET)
           CALL PROCESS_RESET(PARM2);
         OTHERWISE
           ;
       END; /* Select */
       /* Restore the user state (Last find string, etc.)             */
       CALL ISPLINK(ISREDIT,LEN0,'$ USER_STATE = (STATES) $');
     END;
   IF MSGID ^= ' ' THEN
     CALL ISPLINK(SETMSG,MSGID);
   IF CSR_MUST_BE_IN_DATA = 'Y' & RETURN_CODE = 0 THEN
     CALL ISPLINK(ISREDIT,LEN0,'$ CURSOR = (CSRROW,CSRCOL) $');
   CALL VDELETE_VARIABLES;
   CALL PLIRETC(RETURN_CODE);
   RETURN;
 /*********************************************************************/
 /*                V d e f i n e _ V a r i a b l e s                  */
 /* Vdefines all the variables used for edit macro, message, and      */
 /* panel communication.                                              */
 /*********************************************************************/
 VDEFINE_VARIABLES: PROCEDURE;
   CALL ISPLINK(VDEFINE,'(PARM1)',PARM1,CHR,LEN50);
   CALL ISPLINK(VDEFINE,'(PARM2)',PARM2,CHR,LEN50);
   CALL ISPLINK(VDEFINE,'(MSGLINET)',MSGLINET,CHR,LEN72);
   CALL ISPLINK(VDEFINE,'(MSGLINEB)',MSGLINEB,CHR,LEN72);
   CALL ISPLINK(VDEFINE,'(DATALINE)',DATALINE,CHR,LEN256);
   CALL ISPLINK(VDEFINE,CHAR6_VARS_LIST,CHAR6_VARS,CHR,LEN6);
   CALL ISPLINK(VDEFINE,CHAR3_VARS_LIST,CHAR3_VARS,CHR,LEN3);
   CALL ISPLINK(VDEFINE,DRAW_CHARS_LIST,DRAWING_CHARS,CHR,LEN8);
   CALL ISPLINK(VDEFINE,CHAR8_VARS_LIST,CHAR8_VARS,CHR,LEN8);
   CALL ISPLINK(VDEFINE,CHAR9_VARS_LIST,CHAR9_VARS,CHR,LEN9);
   CALL ISPLINK(VDEFINE,CHAR44_VARS_LIST,CHAR44_VARS,CHR,LEN44);
 END; /* VDEFINE_Variables */
 /*********************************************************************/
 /*            I n i t i a l i z e _ V a r i a b l e s                */
 /*********************************************************************/
 INITIALIZE_VARIABLES: PROCEDURE;
   RETURN_CODE = 0;
   MSGID = ' ';
   /* Get the record length and number of records.                    */
   CALL ISPLINK(ISREDIT,LEN0,'$ (LRECL) = LRECL $');
   CALL ISPLINK(ISREDIT,LEN0,'$ (LINECNT) = LINENUM .ZLAST $');
   /* Get the current data set name and member.                       */
   CALL ISPLINK(ISREDIT,LEN0,'$ (CURRDSN) = DATASET $');
   CALL ISPLINK(ISREDIT,LEN0,'$ (CURRMEMB) = MEMBER $');
   /* Get the current drawing characters from the profile             */
   CALL ISPLINK(VGET,DRAW_CHARS_LIST,PROFILE);
   /* If a variable was not found then call PROCESS_OPTIONS           */
   /* to set the default character set to the non-Text set.           */
   IF PLIRETV() ^= 0 THEN
     DO;
       CALL PROCESS_OPTIONS('2       ');
       /* Reissue the VGET                                            */
       CALL ISPLINK(VGET,DRAW_CHARS_LIST,PROFILE);
     END;
   /* Get the current character set in use.                           */
   CALL ISPLINK(VGET,'(DRAWCSET)',PROFILE);
   /* Get the current AUTOJOIN setting from the profile               */
   CALL ISPLINK(VGET,'(DRAWJOIN)',PROFILE);
   IF PLIRETV() ^= 0 THEN
     DRAWJOIN = 'ON';
   /* Get the last data set name and member used for pointing/marking */
   CALL ISPLINK(VGET,'(DRAWDSN, DRAWMEMB)',SHARED);
   IF DRAWDSN = ' ' THEN
     DRAWDSN = CURRDSN;
   IF DRAWMEMB = ' ' THEN
     DRAWMEMB = CURRMEMB;
 END; /* Initialize_Variables */

 /*********************************************************************/
 /*                      C h e c k _ P a r m                          */
 /* Convert the parameter passed from the edit macro to upper case    */
 /* and decide what was entered.  Abbreviations are accepted as long  */
 /* as they are unambiguous.                                          */
 /*********************************************************************/
 CHECK_PARM: PROCEDURE;
   PARM1 = TRANSLATE(PARM1,UPPCASE,LOWCASE);
   PARM2 = TRANSLATE(PARM2,UPPCASE,LOWCASE);
   DO PARMLENG = 1 TO 50 WHILE (SUBSTR(PARM1,PARMLENG,1) ^= ' ');
   END;
   PARMLENG = PARMLENG - 1;

   SELECT;
     WHEN (PARMLENG = 0)          /* No parm specified               */
       DO;
         MSGID = DRAW000;
         RETURN_CODE = 12;
       END;
     WHEN (PARMLENG > 8)          /* Parm too long                   */
       DO;
         MSGID = DRAW001;
         RETURN_CODE = 12;
       END;
     OTHERWISE
       DO;
         /* Search parm array for word                               */
         FOUND = 0;
         CSR_MUST_BE_IN_DATA = BLANK1;
         NUM_MUST_BE_OFF = BLANK1;
         POINT_NEEDED = BLANK1;
         DO I = 1 TO DIM(PARM_ARRAY,1);
           IF SUBSTR(PARM1,1,PARMLENG) =
              SUBSTR(PARM_ARRAY(I),1,PARMLENG) THEN
             DO;
               FOUND = FOUND + 1;
               PARM = PARM_ARRAY(I);
               CSR_MUST_BE_IN_DATA = CSR_IN_DATA_ARRAY(I);
               POINT_NEEDED = POINT_NEEDED_ARRAY(I);
               NUM_MUST_BE_OFF = NUM_OFF_ARRAY(I);
             END;
         END;
         SELECT;
           WHEN(FOUND=0)          /* Not found                       */
             DO;
               MSGID = DRAW002;
               RETURN_CODE = 12;
             END;
           WHEN(FOUND^=1)         /* Found - Ambiguous               */
             DO;
               MSGID = DRAW003;
               RETURN_CODE = 12;
             END;
           OTHERWISE              /* Found - Unambiguous             */
             ;
         END; /* Select */
       END;
   END; /* Select */
 END; /* Check_Parm */
 /*********************************************************************/
 /*                     C h e c k _ N u m b e r                       */
 /* Query the number status and issue a message if number is on.      */
 /* This is done because column numbers are stored between            */
 /* invocations of this macro and are affected by whether or not      */
 /* number is on or off.  With numbers off it is also possible to     */
 /* place the cursor within a sequence number field.                  */
 /*********************************************************************/
 CHECK_NUMBER: PROCEDURE;
   CALL ISPLINK(ISREDIT,LEN0,'$ (NUMBER) = NUMBER $');
   IF NUMBER = 'ON ' THEN
     DO;
       MSGID = DRAW022;
       /* Position cursor to command line                             */
       RETURN_CODE = 1;
     END;
 END; /* Check_Number */
 /*********************************************************************/
 /*                       F i n d _ P o i n t                         */
 /* Verifies that a point has previously been defined and if so that  */
 /* it is still valid.                                                */
 /*********************************************************************/
 FIND_POINT: PROCEDURE;
   /*******************************************************************/
   /* Check to see if the .Point label is set                         */
   /*******************************************************************/
   CALL ISPLINK(ISREDIT,LEN0,
     '$ (PT1ROW) = LINENUM .POINT $');
   IF PLIRETV() ^= 0 THEN
     DO;
       MSGID = DRAW016;
       RETURN_CODE = 12;
     END;
   ELSE
     DO;
       /***************************************************************/
       /* Check if DRAW was used under a recursive edit               */
       /***************************************************************/
       IF CURRDSN ^= DRAWDSN × CURRMEMB ^= DRAWMEMB THEN
         MSGID = DRAW029;
       ELSE
         DO;
           /***********************************************************/
           /* Get the point column                                    */
           /***********************************************************/
           CALL ISPLINK(VGET,'(PT1COL)',SHARED);
           IF PLIRETV() ^= 0 THEN
             DO;
               IF PT1COL = '' THEN
                 PT1COL = 0;
               IF PT1COL < 1 × PT1COL > LRECL THEN
               MSGV1 = LEFT_JUSTIFY(PT1ROW,6);
               MSGV2 = LEFT_JUSTIFY(PT1COL,3);
               MSGID = DRAW017;
               RETURN_CODE = 12;
             END;
         END;
     END;
 END; /* Find_Point */
 /*********************************************************************/
 /*                    C h e c k _ C u r s o r                        */
 /* Query the cursor position and verify that the cursor is within    */
 /* the data.                                                         */
 /*********************************************************************/
 CHECK_CURSOR: PROCEDURE;
   CSRROW = 0;
   CSRCOL = 0;
   CALL ISPLINK(ISREDIT,LEN0,'$ (CSRROW,CSRCOL) = CURSOR $');
   IF PLIRETV() ^= 0 × CSRCOL = 0 × CSRCOL > LRECL THEN
     DO;
       MSGID = DRAW012;
       RETURN_CODE = 12;
     END;
 END; /* Check_Cursor */
 /*********************************************************************/
 /*                     P r o c e s s _ H e l p                       */
 /* Calls the ISPF tutorial processor with the DRAW tutorial panel    */
 /*********************************************************************/
 PROCESS_HELP: PROCEDURE;
   CALL ISPLINK(SELECT,LEN28,'PGM(ISPTUTOR) PARM(DRAW0000)');
 END; /* Process_Help */
 /*********************************************************************/
 /*                  P r o c e s s _ O p t i o n s                    */
 /* Displays a panel on which the user can select the active          */
 /* character set to be used for drawing.  If CHARSET is non-Blank    */
 /* and it is a valid panel option, the panel will be displayed with  */
 /* the command set to CHARSET.  This will cause the panel to be      */
 /* 'displayed' in non-display mode with the option passed to the     */
 /* Panel.  This allows a user or another edit macro to change        */
 /* character sets without displaying the panel.                      */
 /*********************************************************************/
 PROCESS_OPTIONS: PROCEDURE(CHARSET);
   DECLARE
     CHARSET  CHAR(50);
   IF CHARSET = ' ' THEN
     CALL ISPLINK(DISPLAY,DRAWOPT1);
   ELSE
     DO;
       CALL ISPLINK(VDEFINE,'(CHARSET)',CHARSET,CHR,LEN50);
       IF CHARSET >= '1' & CHARSET <= '5' THEN
         CALL ISPLINK(DISPLAY,DRAWOPT1,BLANK1,BLANK1,BLANK1,'CHARSET ');
       ELSE
         MSGID = DRAW015;
       CALL ISPLINK(VDELETE,'(CHARSET)');
     END;
 END; /* Process_Options */
 /*********************************************************************/
 /*                    P r o c e s s _ P o i n t                      */
 /* Changes the character at the current cursor position to the       */
 /* point character.                                                  */
 /*********************************************************************/
 PROCESS_POINT: PROCEDURE;
   /*******************************************************************/
   /* Put the current cursor position onto the stack                  */
   /*******************************************************************/
   CALL PUSH_POINT;
   /*******************************************************************/
   /* Draw the point                                                  */
   /*******************************************************************/
   /* Set a label on the line that is to receive the point            */
   CALL SET_POINT_LABEL;
   /* Change the character at the cursor to the point character       */
   CALL ISPLINK(ISREDIT,LEN0,
     '$ C FIRST P"=" &DRAWPT .POINT .POINT &PT1COL &PT1COL $');
   /*******************************************************************/
   /* Left justify the message variables and set the message id       */
   /*******************************************************************/
   MSGV1 = LEFT_JUSTIFY(PT1ROW,6);
   MSGV2 = LEFT_JUSTIFY(PT1COL,3);
   MSGID = DRAW004;
   /*******************************************************************/
   /* Store the data set and member in the shared pool so that        */
   /* a recursive call can be identified.                             */
   /*******************************************************************/
   DRAWDSN = CURRDSN;
   DRAWMEMB = CURRMEMB;
   CALL ISPLINK(VPUT,'(DRAWDSN DRAWMEMB)',SHARED);
 END; /* Process_Point */
 /*********************************************************************/
 /*                      P u s h _ P o i n t                          */
 /* Pushes the current cursor position onto the point stack.          */
 /*********************************************************************/
 PUSH_POINT: PROCEDURE;
   PT2ROW = PT1ROW;
   PT2COL = PT1COL;
   PT1ROW = CSRROW;
   PT1COL = CSRCOL;
   CALL ISPLINK(VPUT,'(PT1COL)',SHARED);
 END; /* Push_Point */
 /*********************************************************************/
 /*                       P o p _ P o i n t                           */
 /* Removes the top item from the point stack.                        */
 /*********************************************************************/
 POP_POINT: PROCEDURE;
   PT1ROW = PT2ROW;
   PT1COL = PT2COL;
   CALL ISPLINK(VPUT,'(PT1COL)',SHARED);
 END; /* Pop_Point */
 /*********************************************************************/
 /*                 S e t _ P o i n t _ L a b e l                     */
 /* Sets the .POINT label to the line specified by PT1ROW.  Before    */
 /* setting the label, it checks to see if a mark label is already    */
 /* on that row.  If one is, then RESET_MARK is called to remove the  */
 /* marked block.                                                     */
 /*********************************************************************/
 SET_POINT_LABEL: PROCEDURE;
   /*******************************************************************/
   /* Look for a label on the PT1ROW line.                            */
   /*******************************************************************/
   CALL ISPLINK(ISREDIT,LEN0,'$ (ROWLABEL) = LABEL &PT1ROW $');
   IF PLIRETV() = 0 THEN
     DO;
       IF ROWLABEL = '.MARK ' ×
          ROWLABEL = '.MARKT' ×
          ROWLABEL = '.MARKB' THEN
         CALL RESET_MARK;
     END;
   /*******************************************************************/
   /* Set the point label                                             */
   /*******************************************************************/
   CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &PT1ROW = .POINT 0 $');
 END; /* Set_Point_Label */
 /*********************************************************************/
 /*                     P r o c e s s _ L i n e                       */
 /* Draws a line between the two points in the stack.  A bent line    */
 /* will be drawn if the two points do not share a common row or      */
 /* column.  An appropriate corner character will be placed at the    */
 /* corner of a bent line.  Sets the rise and run variables.          */
 /*********************************************************************/
 PROCESS_LINE: PROCEDURE;
   /* Put the current cursor position onto the stack                  */
   CALL PUSH_POINT;
   /* Move the .Point label to the cursor position                    */
   CALL SET_POINT_LABEL;
   /*******************************************************************/
   /* Draw the horizontal segment or a single point line              */
   /*******************************************************************/
   /* Set a label on the line to receive the horizontal segment       */
   CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &PT2ROW = .LINET $');
   /* Change the characters to the horizontal line character          */
   CALL ISPLINK(ISREDIT,LEN0,
     '$ C ALL P"=" &DRAWLNH .LINET .LINET &PT1COL &PT2COL $');
   /*******************************************************************/
   /* Draw the vertical segment if necessary                          */
   /*******************************************************************/
   /* If the two points are not on the same row                       */
   IF PT1ROW ^= PT2ROW THEN
     DO;
       /* Label the top and bottom rows                               */
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &PT1ROW = .LINEB $');
       /* Change the characters to the vertical line character        */
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C ALL P"=" &DRAWLNV .LINET .LINEB &PT1COL &PT1COL $');
     END;
   /*******************************************************************/
   /* Reset the ==CHG> Flags                                          */
   /*******************************************************************/
   IF PT1ROW ^= PT2ROW THEN
     CALL ISPLINK(ISREDIT,LEN0,'$ RESET CHANGE .LINET .LINEB $');
   ELSE
     CALL ISPLINK(ISREDIT,LEN0,'$ RESET CHANGE .LINET .LINET $');
   /*******************************************************************/
   /* Fix up the corner if necessary                                  */
   /*******************************************************************/
   /* Compute the rise and run of a line between the two points       */
   RISE = PT1ROW - PT2ROW;
   RUN  = PT1COL - PT2COL;
   /* If a corner exists                                              */
   IF RISE ^= 0 & RUN ^= 0 THEN
     DO;
       /* Determine type of corner and set appropriate character      */
       SELECT;
         WHEN(RISE > 0 & RUN > 0) /* Upper right hand corner  DD?     */
           CORNERCH = DRAWBXUR;   /*                            3     */
         WHEN(RISE > 0 & RUN < 0) /* Upper left hand corner   ZDD     */
           CORNERCH = DRAWBXUL;   /*                          3       */
         WHEN(RISE < 0 & RUN > 0) /* Lower right hand corner    3     */
           CORNERCH = DRAWBXLR;   /*                          DDY     */
         WHEN(RISE < 0 & RUN < 0) /* Lower left hand corner   3       */
           CORNERCH = DRAWBXLL;   /*                          @DD     */
         OTHERWISE                /* No corner                        */
           ;
       END; /* Select */
       /* Change the character at the corner to the corner character  */
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C FIRST P"=" &CORNERCH .LINET .LINET &PT1COL &PT1COL $');
     END; /* If */
   /*******************************************************************/
   /* If autojoin is on then call PROCESS_JOIN with the two           */
   /* endpoints.  Call it only for the points that will not be        */
   /* overlayed with arrows.                                          */
   /*******************************************************************/
   IF DRAWJOIN = 'ON' THEN
     DO;
       IF PARM = LINE × PARM = ARROW THEN
         CALL PROCESS_JOIN(PT2ROW,PT2COL);
       IF PARM = LINE THEN
         CALL PROCESS_JOIN(PT1ROW,PT1COL);
     END;
   /*******************************************************************/
   /* Left justify the message variables and set the message id       */
   /*******************************************************************/
   MSGV1 = LEFT_JUSTIFY(PT2ROW,6);
   MSGV2 = LEFT_JUSTIFY(PT2COL,3);
   MSGV3 = LEFT_JUSTIFY(PT1ROW,6);
   MSGV4 = LEFT_JUSTIFY(PT1COL,3);
   MSGID = DRAW005;
 END; /* Process_Line */
 /*********************************************************************/
 /*                   P r o c e s s _ A r r o w s                     */
 /* Draws a line with either a single or double arrow based upon the  */
 /* macro parameter.                                                  */
 /*********************************************************************/
 PROCESS_ARROWS: PROCEDURE;
   /*******************************************************************/
   /* Call process_Line to draw the line without any arrows           */
   /*******************************************************************/
   CALL PROCESS_LINE;
   /*******************************************************************/
   /* Call set_Arrows to set the appropriate arrow(s) to use          */
   /*******************************************************************/
   CALL SET_ARROWS;
   /*******************************************************************/
   /* Draw the arrow point at the cursor position                     */
   /*******************************************************************/
   /* Set a label on the line that is to receive the arrow            */
   CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &PT1ROW = .ARROW $');
   /* Change the character at the cursor to the arrow character       */
   CALL ISPLINK(ISREDIT,LEN0,
     '$C FIRST P"=" &ARROW1 .ARROW .ARROW &PT1COL &PT1COL $');
   /*******************************************************************/
   /* Draw the arrow point at the other endpoint if necessary         */
   /*******************************************************************/
   IF PARM = 'DARROW  ' THEN
     DO;
       /* Set a label on the line that is to receive the arrow        */
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &PT2ROW = .ARROW $');
       /* Change the character at the other endpoint to an arrow      */
       CALL ISPLINK(ISREDIT,LEN0,
     '$C FIRST P"=" &ARROW2 .ARROW .ARROW &PT2COL &PT2COL $');
     END;
   /*******************************************************************/
   /* Change the message id that was set by PROCESS_LINE              */
   /*******************************************************************/
   IF PARM = ARROW THEN
     MSGID = DRAW010;
   ELSE
     MSGID = DRAW011;
 END; /* Process_Arrows */
 /*********************************************************************/
 /*                       S e t _ A r r o w s                         */
 /* Sets variables ARROW1 and ARROW2 to the 2 types of arrows needed  */
 /* for the current line.                                             */
 /*********************************************************************/
 SET_ARROWS: PROCEDURE;
   /* Determine type of arrows based on rise and run of line.  Rise   */
   /* and run are computed in PROCESS_LINE.                           */
   SELECT;
     WHEN(RISE > 0 & RUN > 0)     /* Upper right hand corner          */
       DO;                        /*                       DDD?       */
         ARROW1 = DRAWARD;        /*     Arrow down           3       */
         ARROW2 = DRAWARL;        /*     Arrow left           3       */
       END;
     WHEN(RISE > 0 & RUN < 0)     /* Upper left hand corner           */
       DO;                        /*                       ZDDD       */
         ARROW1 = DRAWARD;        /*     Arrow down        3          */
         ARROW2 = DRAWARR;        /*     Arrow right       3          */
       END;
     WHEN(RISE < 0 & RUN > 0)     /* Lower right hand corner          */
       DO;                        /*                          3       */
         ARROW1 = DRAWARU;        /*     Arrow up             3       */
         ARROW2 = DRAWARL;        /*     Arrow left        DDDY       */
       END;
     WHEN(RISE < 0 & RUN < 0)     /* Lower left hand corner           */
       DO;                        /*                       3          */
         ARROW1 = DRAWARU;        /*     Arrow up          3          */
         ARROW2 = DRAWARR;        /*     Arrow right       @DDD       */
       END;
     WHEN(RISE = 0 & RUN > 0)     /* Horizontal line to right         */
       DO;                        /*                       DDDD       */
         ARROW1 = DRAWARR;        /*     Arrow right                  */
         ARROW2 = DRAWARL;        /*     Arrow left                   */
       END;
     WHEN(RISE = 0 & RUN < 0)     /* Horizontal line to left          */
       DO;                        /*                       DDDD       */
         ARROW1 = DRAWARL;        /*     Arrow left                   */
         ARROW2 = DRAWARR;        /*     Arrow right                  */
       END;
     WHEN(RISE > 0 & RUN = 0)     /* Vertical line down               */
       DO;                        /*                       3          */
         ARROW1 = DRAWARD;        /*     Arrow down        3          */
         ARROW2 = DRAWARU;        /*     Arrow up          3          */
       END;
     WHEN(RISE < 0 & RUN = 0)     /* Vertical line up                 */
       DO;                        /*                       3          */
         ARROW1 = DRAWARU;        /*     Arrow up          3          */
         ARROW2 = DRAWARD;        /*     Arrow down        3          */
       END;
     OTHERWISE                    /* Single point                     */
       DO;                        /*                                  */
         ARROW1 = DRAWARR;        /*     Arrow right                  */
         ARROW2 = DRAWARL;        /*     Arrow left                   */
       END;
   END; /* Select */
 END; /* Set_Arrows */
 /*********************************************************************/
 /*                     P r o c e s s _ B o x                         */
 /* Draws a box with endpoints at the two points in the stack.        */
 /*********************************************************************/
 PROCESS_BOX: PROCEDURE;
   /* Put the current cursor position onto the stack                  */
   CALL PUSH_POINT;
   /* Compute the rise and run of a line between the two points       */
   /* and verify that there is enough room for a box                  */
   RISE = PT1ROW - PT2ROW;
   RUN  = PT1COL - PT2COL;
   IF RISE = 0 × RUN = 0 THEN     /* Insufficient room for box        */
     DO;
       CALL POP_POINT;
       MSGID = DRAW006;
     END;
   ELSE                           /* Sufficient room for box          */
     DO;
       /* Move the .POINT label to the cursor position                */
       CALL SET_POINT_LABEL;
       /***************************************************************/
       /* Set box1row,box1col to the upper left hand point and set    */
       /* box2row,box2col to the lower right hand point.              */
       /***************************************************************/
       BOX1ROW = MIN(PT1ROW,PT2ROW);
       BOX1COL = MIN(PT1COL,PT2COL);
       BOX2ROW = MAX(PT1ROW,PT2ROW);
       BOX2COL = MAX(PT1COL,PT2COL);
       /***************************************************************/
       /* Draw the horizontal lines of the box                        */
       /***************************************************************/
       /* Set labels on the top and bottom rows                       */
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &BOX1ROW = .BOXT $');
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &BOX2ROW = .BOXB $');
       /* Change the characters to the horizontal box character on    */
       /* both of the lines                                           */
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C ALL P"=" &DRAWBXHT .BOXT .BOXT &BOX1COL &BOX2COL $');
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C ALL P"=" &DRAWBXHB .BOXB .BOXB &BOX1COL &BOX2COL $');
       /***************************************************************/
       /* Draw the vertical lines of the box                          */
       /***************************************************************/
       /* Change the characters to the vertical on all lines between  */
       /* the rows and in both columns.                               */
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C ALL P"=" &DRAWBXVL .BOXT .BOXB &BOX1COL &BOX1COL $');
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C ALL P"=" &DRAWBXVR .BOXT .BOXB &BOX2COL &BOX2COL $');
       /***************************************************************/
       /* Draw the corners of the box                                 */
       /***************************************************************/
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C FIRST P"=" &DRAWBXUL .BOXT .BOXT &BOX1COL &BOX1COL $');
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C FIRST P"=" &DRAWBXUR .BOXT .BOXT &BOX2COL &BOX2COL $');
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C FIRST P"=" &DRAWBXLL .BOXB .BOXB &BOX1COL &BOX1COL $');
       CALL ISPLINK(ISREDIT,LEN0,
         '$ C FIRST P"=" &DRAWBXLR .BOXB .BOXB &BOX2COL &BOX2COL $');
       /***************************************************************/
       /* Reset the ==CHG> Flags                                  */
       /***************************************************************/
       CALL ISPLINK(ISREDIT,LEN0,'$ RESET CHANGE .BOXT .BOXB $');
       /***************************************************************/
       /* Left justify the message variables and set the message id   */
       /***************************************************************/
       MSGV1 = LEFT_JUSTIFY(PT2ROW,6);
       MSGV2 = LEFT_JUSTIFY(PT2COL,3);
       MSGV3 = LEFT_JUSTIFY(PT1ROW,6);
       MSGV4 = LEFT_JUSTIFY(PT1COL,3);
       MSGID = DRAW007;
     END; /* Else */
 END; /* Process_Box */
 /*********************************************************************/
 /*                     P r o c e s s _ J o i n                       */
 /* Checks the characters around the character at the position passed */
 /* to it and if the current character set is 1 or 2 then attempts to */
 /* choose a joining character that is appropriate.                   */
 /*********************************************************************/
 PROCESS_JOIN: PROCEDURE(JOINROW,JOINCOL);
   DECLARE
     JOINROW  PIC'999999',
     JOINCOL  PIC'999';
   IF DRAWCSET = '1' × DRAWCSET = '2' THEN
     DO;
       JOIN_INDEX = 0;
       /***************************************************************/
       /* Look at character above                                     */
       /***************************************************************/
       IF JOINROW ^= 1 THEN
         DO;
           ROWNUM = JOINROW - 1;
           CALL ISPLINK(ISREDIT,LEN0,'$ (DATALINE) = LINE &ROWNUM $');
           IF VERIFY(SUBSTR(DATALINE,JOINCOL,1),'3>EZ?×+A')=0 THEN
             JOIN_INDEX = JOIN_INDEX + 8;
         END;
       /***************************************************************/
       /* Look at character below                                     */
       /***************************************************************/
       IF JOINROW ^= LINECNT THEN
         DO;
           ROWNUM = JOINROW + 1;
           CALL ISPLINK(ISREDIT,LEN0,'$ (DATALINE) = LINE &ROWNUM $');
           IF VERIFY(SUBSTR(DATALINE,JOINCOL,1),'3JE@Y»×+V')=0 THEN
             JOIN_INDEX = JOIN_INDEX + 4;
         END;
       /***************************************************************/
       /* Look at character to the left                               */
       /***************************************************************/
       ROWNUM = JOINROW;
       CALL ISPLINK(ISREDIT,LEN0,'$ (DATALINE) = LINE &ROWNUM $');
       IF JOINCOL ^= 1 THEN
         IF VERIFY(SUBSTR(DATALINE,JOINCOL-1,1),'DJ>EZ@#-+<')=0 THEN
           JOIN_INDEX = JOIN_INDEX + 2;
       /***************************************************************/
       /* Look at character to the right                              */
       /***************************************************************/
       IF JOINCOL ^= LRECL THEN
         IF VERIFY(SUBSTR(DATALINE,JOINCOL+1,1),'DJ>E?Y-+>')=0 THEN
           JOIN_INDEX = JOIN_INDEX + 1;
       /***************************************************************/
       /* If a join character is needed, select the proper character  */
       /* and place it into the line                                  */
       /***************************************************************/
       IF JOIN_INDEX > 0 THEN
         DO;
           IF DRAWCSET = '1' THEN
             JOIN_CHAR = SUBSTR('DDD3Z?>3@YJ3E',JOIN_INDEX,1);
           ELSE
             JOIN_CHAR = SUBSTR('---×+++×+++×+++',JOIN_INDEX,1);
           SUBSTR(DATALINE,JOINCOL,1) = JOIN_CHAR;
           CALL ISPLINK(ISREDIT,LEN0,'$ LINE &ROWNUM = (DATALINE) $');
         END;
     END;
   ELSE
     /*****************************************************************/
     /* If not called for autojoining, then set message               */
     /*****************************************************************/
     IF PARM = JOIN THEN
       MSGID = DRAW028;
 END; /* Process_Join */
 /*********************************************************************/
 /*              P r o c e s s _ A u t o j o i n                      */
 /* Sets the value of DRAWJOIN based on PARM2 and VPUTs it to the     */
 /* profile.                                                          */
 /*********************************************************************/
 PROCESS_AUTOJOIN: PROCEDURE;
   SELECT;
     WHEN (PARM2 = ' ' × PARM2 = 'ON')
       DRAWJOIN = 'ON';
     WHEN (PARM2 = 'OFF')
       DRAWJOIN = 'OFF';
     OTHERWISE
       DO;
         MSGID = DRAW027;
         RETURN_CODE = 12;
       END;
   END; /* Select */
   /*******************************************************************/
   /* If OK, VPUT the variable to the profile pool.                   */
   /*******************************************************************/
   IF MSGID = ' ' THEN
     CALL ISPLINK(VPUT,'(DRAWJOIN)',PROFILE);
 END; /* Process_Autojoin */
 /*********************************************************************/
 /*                    P r o c e s s _ M a r k                        */
 /* Sets labels for the block to be processed and adds msg lines to   */
 /* the data set to indicate the range of rows and columns marked.    */
 /*********************************************************************/
 PROCESS_MARK: PROCEDURE;
   /*******************************************************************/
   /* Test if a block is marked, if not push the cursor onto the      */
   /* mark stack again so that the new marked block will be a single  */
   /* character.                                                      */
   /*******************************************************************/
   CALL FIND_BLOCK;
   IF MSGID ^= ' ' THEN
     DO;
       CALL PUSH_MARK;
       MSGID = ' ';
     END;
   /*******************************************************************/
   /* Put the current cursor position onto the stack                  */
   /*******************************************************************/
   CALL PUSH_MARK;
   /*******************************************************************/
   /* Call reset_Mark to remove any previous labels and msg lines.    */
   /*******************************************************************/
   CALL RESET_MARK;
   /*******************************************************************/
   /* Call mark_Block to add labels and msg lines                     */
   /*******************************************************************/
   CALL MARK_BLOCK;
   /*******************************************************************/
   /* Left justify the message variables and set the message id       */
   /*******************************************************************/
   MSGV1 = LEFT_JUSTIFY(MARKTROW,6);
   MSGV2 = LEFT_JUSTIFY(MARKLCOL,3);
   MSGV3 = LEFT_JUSTIFY(MARKBROW,6);
   MSGV4 = LEFT_JUSTIFY(MARKRCOL,3);
   MSGID = DRAW018;
   /*******************************************************************/
   /* Store the data set and member in the shared pool so that        */
   /* a recursive call can be identified.                             */
   /*******************************************************************/
   DRAWDSN = CURRDSN;
   DRAWMEMB = CURRMEMB;
   CALL ISPLINK(VPUT,'(DRAWDSN DRAWMEMB)',SHARED);
 END; /* Process_Mark */
 /*********************************************************************/
 /*                    F i n d _ B l o c k                            */
 /* Finds the current marked block and sets the block_Height and      */
 /* block_Width.  Sets the msgid if the block could not be found.     */
 /*********************************************************************/
 FIND_BLOCK: PROCEDURE;
   /* Get the current mark labels and columns                        */
   CALL ISPLINK(VGET,'(MARKTLBL MARKLCOL MARKBLBL MARKRCOL)',SHARED);
   /* If a variable was not found then set the message                */
   IF PLIRETV() ^= 0 THEN
     MSGID = DRAW019;
   ELSE
     DO;
       /* Set the row and column numbers                              */
       CALL ISPLINK(ISREDIT,LEN0,'$ (MARK1ROW) = LINENUM &MARKTLBL $');
       MARK1COL = MARKLCOL;
       CALL ISPLINK(ISREDIT,LEN0,'$ (MARK2ROW) = LINENUM &MARKBLBL $');
       MARK2COL = MARKRCOL;
     END;
   IF MSGID = ' ' THEN
     DO;
       /***************************************************************/
       /* Check to see if the labels are set in the data              */
       /***************************************************************/
       CALL ISPLINK(ISREDIT,LEN0,
         '$ (MARKTROW) = LINENUM &MARKTLBL $');
       IF PLIRETV() ^= 0 THEN
         MSGID = DRAW019;
       ELSE
         DO;
           CALL ISPLINK(ISREDIT,LEN0,
             '$ (MARKBROW) = LINENUM &MARKBLBL $');
           IF PLIRETV() ^= 0 THEN
             MSGID = DRAW019;
         END;
     END;
   IF MSGID = ' ' THEN
     DO;
       /***************************************************************/
       /* Test if top and bottom labels were manually switched        */
       /***************************************************************/
       IF MARKTROW > MARKBROW THEN
         MSGID = DRAW020;
       ELSE
         DO;
           MARKLCOL = MIN(MARK1COL,MARK2COL);
           MARKRCOL = MAX(MARK1COL,MARK2COL);
           BLOCK_HEIGHT = MARKBROW - MARKTROW + 1;
           BLOCK_WIDTH = MARKRCOL - MARKLCOL + 1;
         END;
     END;
   IF MSGID = ' ' THEN
     DO;
       /* Check if DRAW was run under a recursive edit                */
       IF CURRDSN ^= DRAWDSN × CURRMEMB ^= DRAWMEMB THEN
         MSGID = DRAW021;
     END;
 END; /* Find_Block */
 /*********************************************************************/
 /*                      P u s h _ M a r k                            */
 /* Pushes the current cursor position onto the mark stack.           */
 /*********************************************************************/
 PUSH_MARK: PROCEDURE;
   MARK2ROW = MARK1ROW;
   MARK2COL = MARK1COL;
   MARK1ROW = CSRROW;
   MARK1COL = CSRCOL;
 END; /* Push_Mark */
 /*********************************************************************/
 /*                        M a r k _ B l o c k                        */
 /* Sets labels for the block to be processed and adds msg lines to   */
 /* the data set to indicate the range of rows and columns marked.    */
 /*********************************************************************/
 MARK_BLOCK: PROCEDURE;
   /*******************************************************************/
   /* Label the top and bottom of the marked block                    */
   /*******************************************************************/
   MARKTROW = MIN(MARK1ROW,MARK2ROW);
   MARKLCOL = MIN(MARK1COL,MARK2COL);
   MARKBROW = MAX(MARK1ROW,MARK2ROW);
   MARKRCOL = MAX(MARK1COL,MARK2COL);
   IF MARKTROW = MARKBROW THEN
     DO;
       MARK1LBL = '.MARK';
       MARK2LBL = '.MARK';
       MARKTLBL = '.MARK';
       MARKBLBL = '.MARK';
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &MARKTROW = .MARK 0 $');
     END;
   ELSE
     DO;
       MARKTLBL = '.MARKT';
       MARKBLBL = '.MARKB';
       IF MARK1ROW < MARK2ROW THEN
         DO;
           MARK1LBL = '.MARKT';
           MARK2LBL = '.MARKB';
         END;
       ELSE
         DO;
           MARK1LBL = '.MARKB';
           MARK2LBL = '.MARKT';
         END;
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &MARKTROW = .MARKT 0 $');
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL &MARKBROW = .MARKB 0 $');
     END;
   /*******************************************************************/
   /* VPUT current top and bottom labels and left and right columns.  */
   /*******************************************************************/
   CALL ISPLINK(VPUT,'(MARKTLBL MARKLCOL MARKBLBL MARKRCOL)',SHARED);
   /*******************************************************************/
   /* Call build_Msg_Line to build the message lines to be inserted.  */
   /*******************************************************************/
   CALL BUILD_MSGLINES;
   /*******************************************************************/
   /* Write the msg line before and after the marked block            */
   /*******************************************************************/
   CALL ISPLINK(ISREDIT,LEN0,
     '$ LINE_BEFORE &MARKTLBL = MSGLINE (MSGLINET) $');
   CALL ISPLINK(ISREDIT,LEN0,
     '$ LINE_AFTER  &MARKBLBL = MSGLINE (MSGLINEB) $');
 END; /* Mark_Block */
 /*********************************************************************/
 /*                  B u i l d _ M s g l i n e s                      */
 /* Builds the strings for the top and bottom message lines based on  */
 /* the column range of the marked block.  If the marked block is     */
 /* beyond column 72, a default string will be used.  Otherwise the   */
 /* range of the block will be shown graphically.                     */
 /*********************************************************************/
 BUILD_MSGLINES: PROCEDURE;
   TEMP_COL = MARKLCOL;
   COLS_STR = TEMP_COL ×× '-' ×× LEFT_JUSTIFY(MARKRCOL,3);
   /*******************************************************************/
   /* If beyond column 72, use default messages                       */
   /*******************************************************************/
   IF MARKRCOL > 72 THEN
     DO;
       MSGLINET = '    Top of Block     ' ×× COLS_STR;
       MSGLINEB = '   Bottom of Block   ' ×× COLS_STR;
     END;
   ELSE
     DO;
       /***************************************************************/
       /* Place <----> In proper location                             */
       /***************************************************************/

       COLRANGE = MARKRCOL - MARKLCOL + 1;
       PREFIX = '';
       DO I = 1 TO MARKLCOL-1;
         PREFIX = PREFIX ×× ' ';
       END;
       IF COLRANGE = 1 THEN
           MSGLINET = PREFIX ×× '-';
       ELSE
         DO;
           DASHES = '';
           DO I = 1 TO COLRANGE-2;
             DASHES = DASHES ×× '-';
           END;
           MSGLINET = PREFIX ×× '<' ×× DASHES ×× '>';
         END;
       /***************************************************************/
       /* Place columns in a visible location                         */
       /***************************************************************/
       SELECT;
         WHEN (MARKRCOL < 65)
           SUBSTR(MSGLINET,MARKRCOL+2,7) = COLS_STR;
         WHEN (MARKLCOL > 8)
           SUBSTR(MSGLINET,MARKLCOL-8,7) = COLS_STR;
         OTHERWISE
           SUBSTR(MSGLINET,MARKLCOL+2,7) = COLS_STR;
       END; /* Select */
       /***************************************************************/
       /* Copy top msgline to bottom msgline                          */
       /***************************************************************/
       MSGLINEB = MSGLINET;
       /***************************************************************/
       /* Select proper message to appear                             */
       /***************************************************************/
       SELECT;
         WHEN (COLRANGE >= 14)
           TOPSTR = 'Top of Block';
         WHEN (COLRANGE >= 5)
           TOPSTR = 'Top';
         WHEN (COLRANGE >= 3)
           TOPSTR = 'T';
         OTHERWISE
           ;
       END; /* Select */
       SELECT;
         WHEN (COLRANGE >= 17)
           BOTSTR = 'Bottom of Block';
         WHEN (COLRANGE >= 8)
           BOTSTR = 'Bottom';
         WHEN (COLRANGE >= 5)
           BOTSTR = 'Bot';
         WHEN (COLRANGE >= 3)
           BOTSTR = 'B';
         OTHERWISE
           ;
       END; /* Select */
       /***************************************************************/
       /* Overlay the message over the <----->                        */
       /***************************************************************/
       IF COLRANGE > 2 THEN
         DO;
           CENTERPT = MARKLCOL + (COLRANGE-1)/2;
           POSITION = CENTERPT - LENGTH(TOPSTR)/2 + 1;
           SUBSTR(MSGLINET,POSITION,LENGTH(TOPSTR)) = TOPSTR;
           POSITION = CENTERPT - LENGTH(BOTSTR)/2 + 1;
           SUBSTR(MSGLINEB,POSITION,LENGTH(BOTSTR)) = BOTSTR;
         END;
     END;
 END; /* Build_Msglines */
 /*********************************************************************/
 /*                  P r o c e s s _ C o p y                          */
 /* Copies the current marked block to the cursor position            */
 /*********************************************************************/
 PROCESS_COPY: PROCEDURE;
   /*******************************************************************/
   /* Store the block of data into storage                            */
   /*******************************************************************/
   CALL GET_BLOCK;
   /*******************************************************************/
   /* If OK, perform the copy                                         */
   /*******************************************************************/
   IF MSGID = ' ' THEN
     DO;
       CALL COPY_BLOCK;
       /***************************************************************/
       /* Let the marked block travel with the data for a copy        */
       /* if the entire block was copied.                             */
       /***************************************************************/
       IF PARM = COPY & CSRCOL+BLOCK_WIDTH-1 <= LRECL THEN
         CALL REMARK_BLOCK;
       /***************************************************************/
       /* Left justify the message variables and set the message id   */
       /***************************************************************/
       MSGV1 = LEFT_JUSTIFY(CSRROW,6);
       MSGV2 = LEFT_JUSTIFY(CSRCOL,3);
       MSGID = DRAW024;
     END;
 END; /* Process_Copy */
 /*********************************************************************/
 /*                      G e t _ B l o c k                            */
 /* Gets the current marked block and stores it into the block array  */
 /* which is dynamically allocated.                                   */
 /*********************************************************************/
 GET_BLOCK: PROCEDURE;
   /*******************************************************************/
   /* Find the marked block                                           */
   /*******************************************************************/
   CALL FIND_BLOCK;
   /*******************************************************************/
   /* If OK, copy the block of data into the block array              */
   /*******************************************************************/
   IF MSGID = ' ' THEN
     DO;
       /* Dynamically allocate the block array                        */
       ALLOCATE BLOCK;
       /* Copy data into block                                        */
       DO I = 1 TO BLOCK_HEIGHT;
         /* Get the line                                              */
         CURROW = I + MARKTROW - 1;
         CALL ISPLINK(ISREDIT,LEN0,'$ (DATALINE) = LINE &CURROW $');
         /* Copy the data into the array                              */
         BLOCK(I) = SUBSTR(DATALINE,MARKLCOL,BLOCK_WIDTH);
       END;
     END;
 END; /* Get_Block */
 /*********************************************************************/
 /*                      C o p y _ B l o c k                          */
 /* Copies the current marked block to the cursor position.  Will     */
 /* either copy the block in overlay or non-Overlay mode depending    */
 /* on the option being performed.                                    */
 /*********************************************************************/
 COPY_BLOCK: PROCEDURE;
   /*******************************************************************/
   /* Insert new lines if necessary                                   */
   /*******************************************************************/
   NEWCNT = (CSRROW + BLOCK_HEIGHT - 1) - LINECNT;
   DO I = 1 TO NEWCNT;
     CALL ISPLINK(ISREDIT,LEN0,'$ LINE_AFTER .ZLAST = MASKLINE $');
     LINECNT = LINECNT + 1;
   END;
   /*******************************************************************/
   /* Copy the block to the cursor position                           */
   /*******************************************************************/
   DO I = 1 TO BLOCK_HEIGHT;
     /* Get the line                                                  */
     CURROW = I + CSRROW - 1;
     CALL ISPLINK(ISREDIT,LEN0,'$ (DATALINE) = LINE &CURROW $');
     /* Change the replace the characters in the line with those in   */
     /* the block.                                                    */
     IF PARM = COPY × PARM = MOVE THEN
       SUBSTR(DATALINE,CSRCOL,BLOCK_WIDTH) = BLOCK(I);
     ELSE /* Ocopy × Omove */
       DO;
         DO J = CSRCOL TO CSRCOL + BLOCK_WIDTH - 1;
           IF SUBSTR(DATALINE,J,1) = ' ' THEN
             SUBSTR(DATALINE,J,1) = SUBSTR(BLOCK(I),J-CSRCOL+1,1);
         END;
       END;
     /* Replace the line with the changed value                       */
     CALL ISPLINK(ISREDIT,LEN0,'$ LINE &CURROW = (DATALINE) $');
   END;
 END; /* Copy_Block */
 /*********************************************************************/
 /*                  R e m a r k _ B l o c k                          */
 /* Moves the marked block to the cursor position                     */
 /*********************************************************************/
 REMARK_BLOCK: PROCEDURE;
   MARK1ROW = CSRROW;
   MARK1COL = CSRCOL;
   MARK2ROW = CSRROW + BLOCK_HEIGHT - 1;
   MARK2COL = CSRCOL + BLOCK_WIDTH - 1;
   MARKLCOL = MARK1COL;
   MARKRCOL = MARK2COL;
   CALL ISPLINK(VPUT,'(MARKLCOL MARKRCOL)',SHARED);
   /*******************************************************************/
   /* Call RESET_MARK to remove any previous labels and msg lines.    */
   /*******************************************************************/
   CALL RESET_MARK;
   /*******************************************************************/
   /* Call MARK_BLOCK to mark the block at the new position           */
   /*******************************************************************/
   CALL MARK_BLOCK;
 END; /* Remark_Block */
 /*********************************************************************/
 /*                  P r o c e s s _ M o v e                          */
 /* Moves the current marked block to the cursor position             */
 /*********************************************************************/
 PROCESS_MOVE: PROCEDURE;
   /*******************************************************************/
   /* Store the block of data into storage                            */
   /*******************************************************************/
   CALL GET_BLOCK;
   /*******************************************************************/
   /* If OK, verify that no data will be lost                         */
   /*******************************************************************/
   IF MSGID = ' ' & CSRCOL+BLOCK_WIDTH-1 > LRECL THEN
     MSGID = DRAW023;
   /*******************************************************************/
   /* If OK, erase the block of data                                  */
   /*******************************************************************/
   IF MSGID = ' ' THEN
     DO;
       CALL ERASE_BLOCK;
       /***************************************************************/
       /* If OK, perform the copy                                     */
       /***************************************************************/
       CALL COPY_BLOCK;
       /***************************************************************/
       /* Let the marked block travel with the data for a move        */
       /***************************************************************/
       IF PARM = MOVE THEN
         CALL REMARK_BLOCK;
       /***************************************************************/
       /* Left justify the message variables and set the message id   */
       /***************************************************************/
       MSGV1 = LEFT_JUSTIFY(CSRROW,6);
       MSGV2 = LEFT_JUSTIFY(CSRCOL,3);
       MSGID = DRAW025;
     END;
 END; /* Process_Move */
 /*********************************************************************/
 /*                   P r o c e s s _ F i l l                         */
 /* Fills the current marked block with the fill character.           */
 /*********************************************************************/
 PROCESS_FILL: PROCEDURE;
   /*******************************************************************/
   /* Store the block of data into storage                            */
   /*******************************************************************/
   CALL GET_BLOCK;
   /*******************************************************************/
   /* If OK, perform the fill                                         */
   /*******************************************************************/
   IF MSGID = ' ' THEN
     DO;
       /***************************************************************/
       /* Change the characters in the block to the fill character    */
       /***************************************************************/
       IF PARM = FILL THEN
         /* Change any characters in the block to the fill character  */
         CALL ISPLINK(ISREDIT,LEN0,
           '$ C ALL P"=" &DRAWFILL &MARKTLBL &MARKBLBL
                                   &MARKLCOL &MARKRCOL $');
       ELSE /* PARM = OFILL */
         /* Change only blanks characters to the fill character       */
         CALL ISPLINK(ISREDIT,LEN0,
           '$ C ALL " " &DRAWFILL &MARKTLBL &MARKBLBl
                                  &MARKLCOL &MARKRCOL $');
       /***************************************************************/
       /* Reset the ==CHG> Flags within the block                 */
       /***************************************************************/
       CALL ISPLINK(ISREDIT,LEN0,'$ RESET CHANGE &MARKTLBL &MARKBLBL$');
       /***************************************************************/
       /* Left justify the message variables and set the message id   */
       /***************************************************************/
       MSGV1 = LEFT_JUSTIFY(PT2ROW,6);
       MSGV2 = LEFT_JUSTIFY(PT2COL,3);
       MSGV3 = LEFT_JUSTIFY(PT1ROW,6);
       MSGV4 = LEFT_JUSTIFY(PT1COL,3);
       MSGID = DRAW009;
     END;
 END; /* Process_Fill */
 /*********************************************************************/
 /*                  P r o c e s s _ E r a s e                        */
 /* Verifies that a block has been marked and then calls ERASE_Block  */
 /*********************************************************************/
 PROCESS_ERASE: PROCEDURE;
   /*******************************************************************/
   /* Find the marked block                                           */
   /*******************************************************************/
   CALL FIND_BLOCK;
   /*******************************************************************/
   /* If OK, blank out the block                                      */
   /*******************************************************************/
   IF MSGID = ' ' THEN
     CALL ERASE_BLOCK;
 END; /* Process_Erase */
 /*********************************************************************/
 /*                    E r a s e _ B l o c k                          */
 /* Sets the current marked block to blanks.                          */
 /*********************************************************************/
 ERASE_BLOCK: PROCEDURE;
   DO CURROW = MARKTROW TO MARKBROW;
     /* Get the line                                                  */
     CALL ISPLINK(ISREDIT,LEN0,'$ (DATALINE) = LINE &CURROW $');
     /* Blank out the characters                                      */
     SUBSTR(DATALINE,MARKLCOL,BLOCK_WIDTH) = ' ';
     /* Replace the line                                              */
     CALL ISPLINK(ISREDIT,LEN0,'$ LINE &CURROW = (DATALINE) $');
   END;
 END; /* Erase_Block */
 /*********************************************************************/
 /*                  P r o c e s s _ F i n d m a r k                  */
 /* Looks to see if a block is marked.  If so, it places the top and  */
 /* bottom row numbers into the shared pool and issues a return code  */
 /* of 0.  Otherwise, it issues a return code of 8.  The findmark     */
 /* option is intended for use by other macros.                       */
 /*********************************************************************/
 PROCESS_FINDMARK: PROCEDURE;
   /*******************************************************************/
   /* Find the marked block                                           */
   /*******************************************************************/
   CALL FIND_BLOCK;
   /*******************************************************************/
   /* If OK, blank out the block                                      */
   /*******************************************************************/
   IF MSGID = ' ' THEN
     DO;
       CALL ISPLINK(VPUT,'(MARKTROW MARKBROW)',SHARED);
       RETURN_CODE = 0;
     END;
   ELSE
     DO;
       MSGID = ' ';
       RETURN_CODE = 8;
     END;
 END; /* Process_Findmark */
 /*********************************************************************/
 /*                  P r o c e s s _ R e s e t                        */
 /* Removes point labels and/Or mark labels and message lines.        */
 /*********************************************************************/
 PROCESS_RESET: PROCEDURE(RESET_TYPE);
   DECLARE
     RESET_TYPE CHAR(50);
   /*******************************************************************/
   /* Check parm2 for valid values                                    */
   /*******************************************************************/
   SELECT (SUBSTR(RESET_TYPE,1,1));
     WHEN(SUBSTR(POINT,1,1))
       RESET_TYPE = POINT;
     WHEN(SUBSTR(MARK,1,1))
       RESET_TYPE = MARK;
     WHEN(' ')
       ;
     OTHERWISE
       DO;
         MSGID = DRAW008;
         RETURN_CODE = 12;
       END;
   END; /* Select */
   IF RESET_TYPE = POINT × RESET_TYPE = BLANK1 THEN
     CALL RESET_POINT;
   IF RESET_TYPE = MARK × RESET_TYPE = BLANK1 THEN
     CALL RESET_MARK;
 END; /* Process_Reset */
 /*********************************************************************/
 /*                    R e s e t _ P o i n t                          */
 /* Removes point labels if they exist and resets the point column.   */
 /*********************************************************************/
 RESET_POINT: PROCEDURE;
   CALL ISPLINK(ISREDIT,LEN0,'$ (ROWNUM) = LINENUM .POINT $');
   IF PLIRETV() = 0 THEN
     CALL ISPLINK(ISREDIT,LEN0,'$ LABEL .POINT = " " 0 $');
   /* Clear the point column value                                    */
   PT1COL = 0;
   CALL ISPLINK(VPUT,'(PT1COL)',SHARED);
 END; /* Reset_Point */
 /*********************************************************************/
 /*                    R e s e t _ M a r k                            */
 /* Removes mark labels if they exist and removes mark msg lines.     */
 /*********************************************************************/
 RESET_MARK: PROCEDURE;
   /*******************************************************************/
   /* Check first for a .MARK label.  If found, then reset it.        */
   /*******************************************************************/
   CALL ISPLINK(ISREDIT,LEN0,'$ (ROWNUM) = LINENUM .MARK $');
   IF PLIRETV() = 0 THEN
     DO;
       ROWNUM = ROWNUM - 1;
       CALL ISPLINK(ISREDIT,LEN0,
         '$ RESET SPECIAL &ROWNUM .MARK $');

       ROWNUM = ROWNUM + 2;
       IF ROWNUM > LINECNT THEN
         ROWNUM = 999999;
       CALL ISPLINK(ISREDIT,LEN0,
         '$ RESET SPECIAL .MARK &ROWNUM $');
       CALL ISPLINK(ISREDIT,LEN0,'$ LABEL .MARK = " " 0 $');
     END;
   ELSE
     DO;
       /***************************************************************/
       /* Check for .MARKT and .MARKB labels                          */
       /***************************************************************/
       CALL ISPLINK(ISREDIT,LEN0,'$ (ROWNUM) = LINENUM .MARKT $');
       IF PLIRETV() = 0 THEN
         DO;
           ROWNUM = ROWNUM - 1;
           CALL ISPLINK(ISREDIT,LEN0,
             '$ RESET SPECIAL &ROWNUM .MARKT $');
           CALL ISPLINK(ISREDIT,LEN0,'$ LABEL .MARKT = " " 0 $');
         END;
       CALL ISPLINK(ISREDIT,LEN0,'$ (ROWNUM) = LINENUM .MARKB $');
       IF PLIRETV() = 0 THEN
         DO;
           ROWNUM = ROWNUM + 1;
           IF ROWNUM > LINECNT THEN
             ROWNUM = 999999;
           CALL ISPLINK(ISREDIT,LEN0,
             '$ RESET SPECIAL .MARKB &ROWNUM $');
           CALL ISPLINK(ISREDIT,LEN0,'$ LABEL .MARKB = " " 0 $');
         END;
     END;
 END; /* Reset_Mark */
 /*********************************************************************/
 /*               V d e l e t e _ V a r i a b l e s                   */
 /*********************************************************************/
 VDELETE_VARIABLES: PROCEDURE;
   CALL ISPLINK(VDELETE,'(PARM1)');
   CALL ISPLINK(VDELETE,'(PARM2)');
   CALL ISPLINK(VDELETE,'(MSGLINET)');
   CALL ISPLINK(VDELETE,'(MSGLINEB)');
   CALL ISPLINK(VDELETE,'(DATALINE)');
   CALL ISPLINK(VDELETE,CHAR6_VARS_LIST);
   CALL ISPLINK(VDELETE,CHAR3_VARS_LIST);
   CALL ISPLINK(VDELETE,DRAW_CHARS_LIST);
   CALL ISPLINK(VDELETE,CHAR8_VARS_LIST);
   CALL ISPLINK(VDELETE,CHAR9_VARS_LIST);
   CALL ISPLINK(VDELETE,CHAR44_VARS_LIST);
 END; /* VDELETE_Variables */
 /*********************************************************************/
 /*                    L e f t _ J u s t i f y                        */
 /* Left justifies the string by shifting the string by the number of */
 /* leading blanks (Character strings) or zeros (Picture strings).    */
 /*********************************************************************/
 LEFT_JUSTIFY: PROCEDURE(STRIN,STRLENG) RETURNS(CHAR(6));
   DECLARE
     STRIN    CHAR(6) VARYING,
     STRLENG  FIXED BIN(31),
     STROUT   CHAR(6),
     FIRSTNUM FIXED BIN(31);
   /* Count number of blanks and 0's */
   DO FIRSTNUM = 1 TO STRLENG-1 WHILE(SUBSTR(STRIN,FIRSTNUM,1) = '0' ×
                                      SUBSTR(STRIN,FIRSTNUM,1) = ' ');
   END;
   /* Left justify the number stripping off leading 0's */
   STROUT = SUBSTR(STRIN,FIRSTNUM,STRLENG-FIRSTNUM+1);

   RETURN(STROUT);
 END; /* Left_Justify */

 END DRAW;
