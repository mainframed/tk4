         PRINT NOGEN
         TITLE 'DISCLAIMER - INSTALLATION INSTRUCTIONS'
***********************************************************************
*                                                                     *
*     THIS PROGRAM, DEVELOPED AT CONTINENTAL BANK OF CANADA OR        *
*     SUPPLIED BY OTHER USERS ON A NON-RESTRICTIVE BASIS, IS OF       *
*     GENERAL INTEREST AND IS SUBMITTED FOR UNRESTRICTED DISTRIBUTION.*
*                                                                     *
*     THE AUTHOR HAS, SINCE DEVELOPING THIS PROGRAM, MOVED TO         *
*     MANUFACTURER'S LIFE INSURANCE.  USERS ARE INVITED TO SUBMIT     *
*     SUGGESTIONS OR ERROR DOCUMENTATION TO MANULIFE. HOWEVER, NO     *
*     PROMISE CAN BE MADE THAT SUCH SUGGESTIONS WILL BE IMPLEMENTED   *
*     OR ERRORS CORRECTED.  SUBMIT COMMENTS TO:                       *
*                                                                     *
*              JIM LANE                                               *
*              HARDWARE MANAGEMENT                                    *
*              MANUFACTURER'S LIFE INSURANCE                          *
*              200 BLOOR ST E.                                        *
*              TORONTO, ONTARIO M4W 1E5                               *
*                                                                     *
*                PHONE: (416)-926-3076                                *
*                                                                     *
*                SHARE INSTALLATION CODE: MLF                         *
*                                                                     *
*     THIS PROGRAM IS MADE AVAILABLE BY MLI WITHOUT CHARGE OR         *
*     CONSIDERATION.  RECIPIENTS ARE FREE TO MAKE THIS PROGRAM        *
*     AVAILABLE TO OTHERS IN LIKE MANNER.  IT MAY NOT BE SOLD.        *
*                                                                     *
*                                                                     *
* NAME         LISTICAT                                               *
*                                                                     *
* FUNCTION     LIST THE CONTENTS OF AN ICF CATALOG AND SELECTED       *
*              DSCB AND VVDS FIELDS.                                  *
*                                                                     *
* DESCRIPTION  THE UCBS OF ALL ONLINE DASD VOLUMES ARE LOCATED AND    *
*              AN ATTEMPT IS MADE TO ALLOCATE SYS1.VVDS.VVOLSER.      *
*              IF THIS WORKS AN ACB AND RPL ARE GENERATED AND THEIR   *
*              ADDRESSES ARE SAVED IN A LOOKUP TABLE.                 *
*              THE BCS CLUSTER IS OPENED AS A DATASET AND READ        *
*              SEQUENTIALLY. THE BCS RECORDS ARE SCANNED FOR CELL     *
*              TYPES AND THE FOLLOWING CELLS ARE LISTED:              *
*                                                                     *
*                NONVSAM                                              *
*                CLUSTER                                              *
*                INDEX                                                *
*                DATA                                                 *
*                AIX                                                  *
*                PATH                                                 *
*                GDG BASE                                             *
*                GDG ENTRY                                            *
*                                                                     *
*              FOR NONVSAM ENTRIES THE FORMAT1 AND, IF IT EXISTS THE  *
*              FORMAT 3, DSCB IS "OBTAINED" TO DETERMINE IF THE       *
*              OBJECT EXISTS. IF IT DOES THE LRECL, BLKSIZE AND       *
*              TOTAL TRACKS ALLOCATED ARE EXTRACTED.                  *
*              IF THE OBJECT IS CATALOGUED TO VOLSER "MIGRAT" THE     *
*              HSM MIGRATIONCONTROLDATASET IS OPENED (SYSUT2) AND     *
*              USED INSTEAD OF THE VTOC.                              *
*                                                                     *
*              FOR DATA AND INDEX ENTRIES THE VVDS OF THE VOLUME IN   *
*              QUESTION, IF AVAILABLE, IS SCANNED TO DETERMINE THE    *
*              LRECL, BLKSIZE AND TRACK ALLOCATION OF THE OBJECT.     *
*                                                                     *
* ENVIRONMENT  OS/VS2 MVS, JDM1113 OR HDQ1102                         *
*              MVS/XA 2.1.5 DF/HSM 2.1.0                           @122
*                                                                     *
* INPUT        THE BCS OF THE ICF CATALOG TO BE LISTED.               *
*                                                                     *
* OUTPUT       OUTPUT CONSISTS OF A LISTING OF THE CATALOG.           *
*                                                                     *
*                                                                     *
*                   DSNAME - THE NAME OF THE COMPONENT BEING LISTED.  *
*                        FOR GDG ENTRIES THIS IS DEVELOPED INTO THE   *
*                        FORMAT THAT WOULD BE IN A FORMAT1 DSCB.      *
*                                                                     *
*                   TYPE - THE TYPE OF THE CELL BEING LISTED.         *
*                                                                     *
*                   VOLUME - THE VOLSER OF THE VOLUME TO WHICH THE    *
*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *
*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *
*                                                                     *
*                   UNIT - THE NAME OF THE UNIT TO WHICH THE          *
*                        OBJECT IS CATALOGED. FILLED IN ONLY FOR      *
*                        NONVSAM, DATA, INDEX AND GDG ENTRIES.        *
*                                                                     *
*                   TRKS - THE NUMBER OF TRACKS ALLOCATED TO A DASD   *
*                        RESIDENT OBJECT. LEFT BLANK FOR CATALOGED,   *
*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *
*                                                                     *
*                   BLKSZ - THE PHYSICAL BLOCK SIZE OF THE OBJECT.    *
*                        LEFT BLANK FOR CATALOGED,                    *
*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *
*                                                                     *
*                   LRECL - THE LOGICAL RECORD LENGTH OF THE OBJECT.  *
*                        LEFT BLANK FOR CATALOGED,                    *
*                        NON-EXISTING AND TAPE-RESIDENT OBJECTS.      *
*                                                                     *
* CONSIDERATIONS                                                      *
*                                                                     *
*              ABEND CODES:                                           *
*                                                                     *
*                   U0014 - BCS CLUSTER FAILED TO OPEN.               *
*                        ERROR CODE IN REGISTER 2.                    *
*                                                                     *
*                   U0015 - BCS GET FAILED.                           *
*                                                                     *
* PARAMETERS   PARM=DUMP PRODUCES A HEX-TRANSLATED LISTING OF         *
*                        BCS AND VVDS CELLS.                          *
*                                                                     *
* EXECUTION    DDNAMES                                                *
*                                                                     *
*              STEPCAT  DEFINES THE ICF CATALOG TO BE LISTED.         *
*                                                                     *
*              SYSUT1   DEFINES THE ICF CATALOG TO BE LISTED.         *
*                                                                     *
*              SYSUT2   DEFINES THE HSM MIGRATIONCONTROLDATASET.      *
*                       IF YOU DON'T HAVE HSM THIS CAN BE LEFT OUT.   *
*                                                                     *
*              SYSPRINT DEFINES THE OUTPUT LISTING DATA SET.          *
*                                                                     *
* EXAMPLE                                                             *
*                                                                     *
*              //LCAT   EXEC  PGM=LISTICAT                            *
*              //SYSPRINT DD  SYSOUT=*                                *
*              //STEPCAT  DD  DSN=ICF.CATALOG,DISP=OLD                *
*              //SYSUT1   DD  DSN=ICF.CATALOG,DISP=OLD                *
*              //SYSUT2   DD  DSN=HSM.MCDS,DISP=OLD                   *
*              //SYSUDUMP DD  SYSOUT=*                                *
*                                                                     *
* NON-IBM MACROS USED (IN MAINLINE OR SUBROUTINES)                    *
*              $EPILOG  - MAIN EXIT LINKAGE                           *
*              $IN      - SUBROUTINE ENTRY LINKAGE                    *
*              $OUT     - SUBROUTINE EXIT LINKAGE                     *
*              $PROLOG  - MAIN ENTRY LINKAGE                          *
*              $REGS    - REGISTER EQUATES                            *
*              ALLOC    - DYNAMIC ALLOCATION                          *
*              DYNSPACE - GENERATE PARMLIST FOR ALLOC                 *
*              EDIT     - FORMAT A DISPLAY NUMERIC FIELD              *
*              HEX      - CONVERT HEX TO PRINTABLE                    *
*              XPRCLOSE - CLOSE A PRINT FILE                          *
*              XPRDCB   - DEFINE A PRINT FILE                         *
*              XPRHEAD  - DEFINE A REPORT HEADING                     *
*              XPRLDEF  - DEFINE A REPORT LINE LAYOUT                 *
*              XPRNTLIN - PRINT A REPORT LINE                         *
*              XPROPEN  - OPEN A PRINT FILE                           *
*                                                                     *
* IBM MACROS USED  (IN MAINLINE OR SUBROUTINES)                       *
*              ABEND    - ABNORMAL TERMINATION.                       *
*              ACB      - DEFINE AN ACB                               *
*              CAMLST   - DEFINE A PARMLIST FOR OBTAIN                *
*              CLOSE    -                                             *
*              CVT      - MAP THE CVT FOR UCB SCAN.                   *
*              DCB      - DEFINE A DCB                                *
*              EXLST    - DEFINE AN EXIT LIST FOR EOF                 *
*              FREEPOOL - FREE BUFFERS                                *
*              GENCB    - GENERATE A VSAM CONTROL BLOCK               *
*              GET      - READ A VSAM LOGICAL RECORD                  *
*              GETMAIN  - ALLOCATE VIRTUAL STORAGE                    *
*              IEFUCBOB - MAP A UCB                                   *
*              IEFZB4D0 - DYNALLOC DATA AREAS                         *
*              IEFZB4D2 - DYNALLOC DATA AREAS                         *
*              IEZJSCB  - MAP MY JOBSTEP CONTROL BLOCK                *
*              IKJTCB   - MAP MY TCB                                  *
*              MODESET  - GET INTO AND OUT OF SUPR STATE/KEY 0        *
*              OBTAIN   - READ A DSCB                                 *
*              OPEN     -                                             *
*              POINT    - ESTABLISH POSITIONING WITHIN A VSAM FILE    *
*              SHOWCB   - PICK VSAM ERROR CODES.                      *
*              SYNADAF  - DIAGNOSE A NON-VSAM I/O ERROR               *
*              SYNADRLS - RELEASE SYNADAF WORKAREAS                   *
*              TIME                                                   *
*              WTO      - GIVE OPER THE BAD NEWS.                     *
*                                                                     *
* AUTHOR       THIS PORTIONS OF THIS PROGRAM HAVING TO DO WITH        *
*              PASSING THE BCS AND VVDS'S WERE WRITTEN BY J. LANE     *
*              AT CBOC. A LOT OF THE REST OF THE CODE HAS BEEN        *
*              BORROWED FROM VARIOUS SOURCES, MOSTLY OFF THE CBT      *
*              TAPE. IF SOMETHING IN HERE LOOKS LIKE YOU WROTE IT,    *
*              YOU PROBABLY DID.                                      *
*                                                                     *
* REGISTER USAGE                                                      *
*                                                                     *
*              R0  - WORK REGISTER.                                   *
*              R1  - WORK REGISTER.                                   *
*              R2  - WORK REGISTER.                                @122
*              R3  - ADDRESS OF CURRENT BCS CELL.                  @122
*              R4  - BASE ADDRESS OF DATASECT.                        *
*              R5  - WORK REGISTER.                                   *
*              R6  - ADDRESS OF CURRENT VVDS CELL.                    *
*              R7  - WORK REGISTER.                                   *
*              R8  - WORK REGISTER.                                   *
*              R9  - SUBROUTINE LINKAGE.                              *
*              R10 - PROGRAM BASE REGISTER 1                          *
*              R11 - PROGRAM BASE REGISTER 2                          *
*              R12 - PROGRAM BASE REGISTER 3                          *
*              R13 - SAVE AREA ADDRESS                                *
*              R14 - LINKAGE                                          *
*              R15 - LINKAGE                                          *
*                                                                     *
***********************************************************************
         SPACE 2
***********************************************************************
*                                                                     *
* NOTES  A PROGRAM MUST BE APF-AUTHORIZED IN MVS TO OPEN A CATALOG    *
*        AS A DATASET. I DO THIS WITH A USER SVC. IF YOU HAVE SUCH A  *
*        THING, CHANGE FROM SVC 232 TO WHATEVER NUMBER YOU HAVE.      *
*                                                                     *
*        AT THE BANK I WAS GETTING PASSWORD PROMPTS WHEN I OPENED THE *
*        CATALOG. RATHER THAN FIGURE OUT WHY I TURNED ON THE          *
*        "NO-PASSWORD" BIT IN THE JSCB. THIS MAY NOT BE NECESSARY IN  *
*        YOUR ENVIRONMENT AND, IF SO, YOU CAN TAKE OUT THE LOGIC.     *
*                                                                     *
*        THE HEX-DUMP LISTING CAN BE A SECURITY EXPOSURE AS WRITTEN   *
*        BECAUSE IT PRINTS OUT THE "SECURITY" CELL, IF PRESENT, WHICH *
*        CONTAINS THE PASSWORDS FOR PROTECTED OBJECTS. SECURITY       *
*        OFFICERS MAY NOT TAKE THAT IN THE NICEST SORT OF WAY!        *
*                                                                     *
*        NO ATTEMPT IS MADE TO DISCERN WHETHER SYSUT1 IS ACTUALLY AN  *
*        ICFCATALOG OR NOT. IF, INADVERTENTLY, IT ISN'T THIS CODE     *
*        WILL PROBABLY LOOP.                                          *
*                                                                     *
*        I WROTE THIS CODE IN THE WINTER OF 1983-1984 WHEN CBOC WAS   *
*        CONVERTING TO ICF CATALOGS. SINCE THE CONVERSION WENT MORE   *
*        SMOOTHLY THAN IT MIGHT HAVE DONE, I NEVER HAD A BROKEN       *
*        CATALOG TO WORK WITH. THEREFORE, THIS CODE ASSUMES A         *
*        VALIDLY STRUCTURED CATALOG. I MAKE NO GUARANTEES WHAT MIGHT  *
*        HAPPEN OTHERWISE.                                            *
*                                                                     *
***********************************************************************
         SPACE 2
***********************************************************************
*                                                                     *
* CHANGE ACTIVITY SUMMARY:                                            *
*                                                                     *
*    @122    - ADDED EXTRA DIAGNOSTIC CHECKING AND MESSAGES TO HANDLE *
*              PROBLEM REPORTED BY R. DIETES OF H.E. BUTT GROCERY CO. *
*              SITUATION WAS THE CASE WHERE THE BCS INFO EXISTS, THE  *
*              VVDS EXISTS BUT IT DOESN'T CONTAIN ANYTHING TO MATCH   *
*              THE DATASET FOUND IN THE BCS.                          *
*              FIX WAS TO SENSE END OF FILE REACHED WHILE SCANNING    *
*              THE VVDS FOR THE VVR OF A CLUSTER COMPONENT, PRODUCE   *
*              MESSAGE ABOUT VVR NOT FOUND WHEN EXPECTED AND PASS A   *
*              RETURN CODE TO THE CALLER.                             *
*            - ADD 3480 DEVICE TYPE SUPPORT.                          *
*            - TEST HSM LOGIC WITH DFHSM 2.1.0                        *
*            - CLOSE MCDS AT EOJ IF IT WAS OPENED.                    *
*    @121    - WAS ASSUMING AN 8-CHARACTER CATALOG NAME FOR THE       *
*              TITLE LINE. OOPS!                                      *
*    @120    - CHANGES FOR MVS/XA. USE SCAN ROUTINE INSTEAD OF        *
*              UCB HALF-WORD LOOKUP TABLE.                            *
*            - LENGTHEN PRINTLINE AREA USED FOR PRINTING TOTALS TO    *
*              CORRECT FORMATTING PROBLEM.                            *
*            - BREAK OUT SOME PARTS OF THE CODE INTO COPY MEMBERS TO  *
*              MAKE IT MORE EDITABLE.                                 *
*            - AN RPL WAS NOT BEING CREATED PRIOR TO I/O IN THE       *
*              HEX-PRINT PART OF THE LOGIC.                           *
*            - ADD CELL TYPE COUNTING TO HEX LOGIC.                   *
*    24APR25 - BUGS FOUND AFTER AUTHOR'S MOVE TO MANULIFE.            *
*            . 3380 MISSING FROM DEVICE TYPE TABLE.                   *
*            . DONT BE SO SURE I KNOW HOW MANY TRACKS THERE ARE IN A  *
*              CYLINDER. AT CBOC I HAD ONLY 3375'S.                   *
***********************************************************************
&NAME    SETC  'LISTICAT'
&VERSION SETC  '1.2.2'
LISTICAT TITLE ' - LIST AN ICF CATALOG.'
         $REGS
LISTICAT $PROLOG R10,R11,R12
         L     R4,=V(DATASECT)     COMMON DATA AREA
         USING DATASECT,R4
         L     R1,0(0,R1)          GET PARM POINTER
         LH    R3,0(0,R1)          GET PARM SIZE
         LTR   R3,R3               ANY PARM GIVEN?
         BZ    NOPARM              NO, ASSUME LIST
         CLC   2(4,R1),=C'DUMP'    HEX LISTING WANTED
         BNE   NOPARM              NO, ASSUME LIST
         B     HEXPRINT            DO A HEX LISTING
NOPARM   DS    0H
        $MESSAGE 1                                                 @122
         XPROPEN PWA,                                                  X
               PAGELEN=PAGELEN,                                        X
               DDNAME=SYSPRINT     OPEN LISTING FILE.
         LTR   R15,R15             DID SYSPRINT OPEN?
         BNZ   EODICAT             IF NOT, NO REPORT.
         BAL   R9,ALLVVDS          ALLOCATE ALL VVDS'S
         SPACE ,
*        LA    R0,1                INDICATE AUTHORIZATION ON.
*        SVC   232                 ***** INSTALLATION DEPENDANT ******
         SPACE ,
         L     R2,CVTPTR           A(CVT)
         L     R2,0(0,R2)          TCB WORDS
         L     R2,0(0,R2)          MY TCB.
         USING TCB,R2
         L     R2,TCBJSCB          TCB -> JSCB.
         DROP  R2
         USING IEZJSCB,R2
         L     R2,JSCBACT          ACTIVE JSCB.
         MODESET KEY=ZERO          JSCB IS IN KEY ZERO.
         SPACE ,
*
* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING
* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER
* A BREAK.
*
         OI    JSCBSWT1,JSCBPASS   SAY, NO PASSWORDS PLEASE.
         SPACE ,
         MODESET KEY=NZERO         BACK TO USER KEY.
         OPEN  ACBICAT             OPEN THE BCS CLUSTER.
         LTR   R15,R15             DID IT OPEN?
         BZ    OPENOK              YES.
         SHOWCB  ACB=ACBICAT,                                          X
               AREA=OPENERR,                                           X
               LENGTH=4,                                               X
               FIELDS=(ERROR)      STORE OPEN ERROR CODE.
         L     R3,OPENERR          PICK ERROR CODE.
         ABEND 14,DUMP             AND DIE.
OPENOK   MODESET KEY=ZERO          KEY ZERO TO MODIFY JSCB.
         NI    JSCBSWT1,255-JSCBPASS  BYPASS PASSWORD OFF.
         MODESET KEY=NZERO         BACK TO USER KEY.
         DROP  R2
*        SR    R0,R0               INDICATE AUTHORIZATION OFF.
*        SVC   232                 ***** INSTALLATION DEPENDANT. *****
         BAL   R9,GENRPL           GENERATE RPL FOR BCS.           @120
         TITLE ' - READ BCS RECORDS AND SCAN FOR CELL TYPES.'
GETNEXT  L     R1,RPLICAT          PICK UP RPL ADDRESS.
         GET   RPL=(1)             READ A BCS RECORD.
         AP    BCSGETS,ONE         KEEP TRACK OF GETS ISSUED.
         LTR   R15,R15             RECORD READ OK?
         BZ    GETOK               GO PROCESS IT.
         ABEND 15,DUMP             TOO BAD!
GETOK    L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R1,RPLICAT          ADDR OF BCS RPL.
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R3               POINT TO END OF CATALOG RECORD
         ST    R1,ENDBCS           SAVE END OF RECORD.
         LA    R3,2(,R3)           SKIP OVER PREFIX
NEXTCELL CLI   2(R3),C'A'          A = NONVSAM
         BE    NONVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    CLUSTER
         CLI   2(R3),C'D'          D = DATA
         BE    DATA
         CLI   2(R3),C'I'          I = INDEX
         BE    INDEX
         CLI   2(R3),C'B'          B = GDG BASE
         BE    GDGBASE
         CLI   2(R3),C'H'          H = GDG ENTRY
         BE    GDGENT
         CLI   2(R3),C'G'          G = ALTERNATE INDEX
         BE    AIX
         CLI   2(R3),C'R'          R = PATH
         BE    PATH
ENDCELL  XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         SR    R1,R1               CLEAR REGISTER.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    NEXTCELL            YES, KEEP GOING
         B     GETNEXT             READ ANOTHER RECORD.
EODICAT  EQU   *                   LAST BCS RECORD READ.
         CLOSE ACBICAT
         CLI   MCDSOPEN,255        DID WE OPEN THE MCDS?           @122
         BNE   EODICAT1            NO.                             @122
         CLOSE ACBMCDS             IF OPEN, CLOSE IT.              @122
EODICAT1 DS    0H                                                  @122
         BAL   R9,COUNTS           PRINT THE STATS.
         XPRCLOSE  PWA             CLOSE THE PRINT FILE.
        $MESSAGE 0                                                 @122
         $EPILOG ,                 AND GO HOME.
         TITLE ' - LIST A NONVSAM RECORD.'
         USING NVNC,R3
NONVSAM  AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   NONVSAM1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
NONVSAM1 MVC   L1DSNAME,NVNAME     SETUP DSNAME
         MVC   L1TYPE,=C'NONVSAM'  SAY WHAT TYPE IT IS.
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
         MVC   L1UNIT,=C'????'     CALL IT ???? IF UNIT NOT FOUND.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
NONVSAM3 CLC   VOLDEVTP,0(R5)      IS THIS IT
         BE    NONVSAM4            YES. GO GET DEVICE TYPE.
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    NONVSAM5            LEAVE IT AT ????
         B     NONVSAM3            CHECK NEXT DEVICE TYPE.
NONVSAM4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
         TM    2(R5),X'20'         IS IT A DASD DEVICE?
         BZ    NONVSAM5            IF NOT, NO VTOC TO SEARCH.
         BAL   R9,VTOC             GET DSCB FIELDS
NONVSAM5 CLC   L1VOLUME,=C'MIGRAT' IS IT MIGRATED BY HSM
         BNE   NONVSAM6            IF NOT, SKIP MCDS CHECK.
         BAL   R9,CHKHSM           SETUP MCDS FIELDS.
NONVSAM6 L     R1,LRECL            PICK UP LRECL VALUE.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         $EDIT L1LRECL,DWK3,ZZZZZ FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         $EDIT L1BLKSIZ,DWK3,ZZZZZ FORMAT IT NICELY
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         $EDIT L1TRACKS,                                               X
               DWK4,ZZZZZZZ        FORMAT IT NICELY.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE DESCRIBING THIS DATASET.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         DROP  R3
         TITLE ' - LIST A CLUSTER RECORD.'
         USING VCNC,R3
CLUSTER  AP    CNTCLUST,ONE        COUNT A CLUSTER.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER1 MVC   L1DSNAME,CLNAME     SETUP CLUSTER NAME.
         MVC   L1TYPE,=C'CLUSTER'  CALL IT A CLUSTER.
         CLI   FIRST,0             FIRST CLUSTER CELL?
         BNE   NOTCL00             NO
         MVI   FIRST,255           THAT WAS THE ONE.
         ST    R3,SAVECL           FIRST CLUSTER HAS BCS NAME.
GETBCSD  SR    R1,R1               CLEAR A FEW BYTES.
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         CLI   2(R3),C'D'          IS IT A DATA CELL?
         BNE   GETBCSD             KEEP ON LOOKING.
         DROP  R3
         USING DINC,R3
         SR    R1,R1                                               @121
         IC    R1,DIDKEYLN         GET LENGTH OF CATALOG NAME.     @121
         B     *+10                                                @121
         MVC   CATNAME(0),DIDKEY   SETUP CATNAME IN HEADING.       @121
         EX    R1,*-6                                              @121
         BAL   R9,SETHEAD          DEFINE REPORT HEADING.
         L     R3,SAVECL           RESTORE CELL ADDR TO CLUSTER.
NOTCL00  BAL   R9,SETCREDT         FORMAT CREATION DATE.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         DROP  R3
         USING DINC,R3
DATA     MVC   L1TYPE,=CL7'DATA'   DATA CELL (PARDON THE EXPRESSION)
         AP    CNTDATA,ONE         COUNT IT.
         B     SKIPDATA            GOTO COMMON FORMATTING LOGIC.
INDEX    MVC   L1TYPE,=CL7'INDEX'  CALL IT AN INDEX
         AP    CNTINDEX,ONE        AND COUNT IT.
SKIPDATA SR    R1,R1               CLEAR A REGISTER.
         IC    R1,DIDKEYLN         LENGTH OF INDEX/DATA NAME
         EX    R1,DIDMOVE          MOVE COMPONENT NAME FOR PRINT
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   CLUSTER2            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
CLUSTER2 BAL   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
         MVC   L1UNIT,=C'????'     JUST IN CASE OF UNKNOWN DEVICE.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
CLUSTER3 CLC   VOLDEVTP,0(R5)      IS THIS IT?
         BE    CLUSTER4            YES
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    CLUSTER5            LEAVE IT ????
         B     CLUSTER3            TRY NEXT DEVICE TYPE.
CLUSTER4 MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
CLUSTER5 MVC   RBASAVE,VOLVVRBA    SAVE RBA OF CI CONTAINING VVR CELL.
         DROP  R3
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
CLUSTER8 CLI   VVDSVOL,255         LAST ENTRY?
         BE    CLUSTER7            YES, OH WELL.
         CLC   VVDSVOL,L1VOLUME    IS THIS THE VVDS?
         BNE   CLUSTER6            NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT INTO ARG FIELD FOR RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(8)             POSITION TO DESIRED RECORD
         GET   RPL=(8)             READ IN RECORD
         AP    VVDSGETS,ONE        KEEP A COUNT.
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD
         LA    R6,2(,R6)           SKIP OVER PREFIX
         BAL   R9,VVDS             PROCESS VVDS FIELDS.
         C     R15,=F'8'           DID WE GET THEM?                @122
         BNE   CLUSTER6            YES.                            @122
        $MESSAGE 4,DATA=L1DSNAME                                   @122
         B     CLUSTER9            PRINT WHAT WE GOT.              @122
CLUSTER6 LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     CLUSTER8            TRY NEXT VVDS
         DROP  R5
CLUSTER7 L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH.
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         $EDIT L1LRECL,DWK3,ZZZZZ FORMAT IT NICELY
         L     R1,BLKSIZE          GET PHYSICAL BLOCK LENGTH.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         $EDIT L1BLKSIZ,                                               X
               DWK3,ZZZZZ          FORMAT IT NICELY.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         $EDIT L1TRACKS,                                               X
               DWK4,ZZZZZZZ        FORMAT IT NICELY.
CLUSTER9 DS    0H                                                  @122
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         USING DINC,R3
DIDMOVE  MVC   L1DSNAME(0),DIDKEY  -> (EXECUTED) <-
         DROP  R3
         TITLE ' - LIST AN ALTERNATE INDEX RECORD.'
         USING ANC,R3
AIX      AP    CNTAIX,ONE          COUNT AN AIX ENTRY.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   AIX0                NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
AIX0     MVC   L1TYPE,=CL7'AIX'    CALL IT AN AIX.
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,AIXKEYLN       PICK UP AIX NAME LENGTH
         B     AIX1                BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),AIXKEY  EXECUTED
AIX1     EX    R1,*-6              MOVE AIX NAME TO PRINT LINE.
         HEX   RPTLINE1+75,                                            X
               ANC,7,HEXTAB=TRHEX  HEX TRANSLATE AIX CELL CONTENTS.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         TITLE ' - LIST A PATH RECORD.'
         USING PNC,R3
PATH     AP    CNTPATH,ONE         COUNT A PATH CELL.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   PATH0               NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
         MVI   BASESW,0            SWITCH OFF.
PATH0    MVC   L1TYPE,=CL7'PATH'   CALL IT A PATH.
         SR    R1,R1               CLEAR A REGISTER.
         ICM   R1,1,PATHKYLN       PICK UP PATH NAME LENGTH
         B     PATH1               BRANCH AROUND EXECUTED INSTRUCTION.
         MVC   L1DSNAME(0),PATHNAME  EXECUTED
PATH1    EX    R1,*-6              MOVE PATH NAME TO PRINT LINE.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         TITLE ' - LIST A GDG BASE OR GDG ENTRY RECORD.'
         USING GDGNC,R3
GDGBASE  AP    CNTGDGB,ONE         COUNT A BASE.
         CLI   BASESW,255          WAS A GDGBASE JUST BEFORE THIS.
         BNE   GDGBASE1            NO.
         AP    CNTNOENT,ONE        COUNT A GDGBASE WITH NO ENTRIES.
GDGBASE1 MVI   BASESW,255          IDENTIFY GDGBASE.
         MVC   L1TYPE,=CL7'GDGBASE'  IDENTIFY RECORD TYPE
         MVC   L1DSNAME,GDGNAME    SETUP GDGNAME.
         MVC   GDGSAVE,GDGNAME     SAVE GDGNAME.
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
         LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT CELL.
         DROP  R3
         USING GDSNC,R3
GDGENT   AP    CNTGDGE,ONE         COUNT IT.
         CLI   BASESW,255          PRECEEDED BY GDGBASE?
         BNE   GDGENT0             ???????
         MVI   BASESW,0            SWITCH OFF
GDGENT0  MVC   L1TYPE,=CL7'GDG ENT'  IDENTIFY RECORD TYPE
         MVC   GDGWORK,GDGSAVE     START WITH BASE NAME.
         LA    R1,GDGWORK          GET ADDRESS OF BASE NAME
         LA    R8,44               44 BYTES AT MOST
GDGENT1  CLI   0(R1),C' '          SCAN FOR A BLANK
         BE    GDGENT2             YES.
         LA    R1,1(0,R1)          TRY NEXT CHARACTER.
         BCT   R8,GDGENT1          KEEP LOOKING
GDGENT2  SR    R8,R8               CLEAR A REGISTER.
         ICM   R8,3,GDSGENO        PICK UP GENERATION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  2(4,R1),GWK3        UNPACK GENERATION NUMBER.
         OI    5(R1),X'F0'         FIX SIGN
         SR    R8,R8               CLEAR A REGISTER.
         ICM   R8,1,GDSVERNO       PICK UP VERSION NUMBER.
         CVD   R8,GWORD            PACK IT.
         UNPK  7(2,R1),GWK2        UNPACK VERSION NUMBER.
         OI    8(R1),X'F0'         FIX SIGN
         MVC   0(2,R1),=C'.G'      SET G0000
         MVI   6(R1),C'V'          G0000V00
         MVC   L1DSNAME,GDGWORK    MOVE IN DEVELOPED NAME
         BAL   R9,SETCREDT         FORMAT CREATION DATE.
         ICM   R0,1,=XL1'04'       VOLUME CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         DROP  R3
         USING VOLCELL,R3
         MVC   L1VOLUME,VOLSERN    SETUP VOLUME SERIAL NUMBER
         MVC   L1UNIT,=C'????'     JUST IN CASE.
         LA    R5,DEVCDTBL         DEVICE TYPE TABLE.
GDGENT5  CLC   VOLDEVTP,0(R5)      IS THIS IT
         BE    GDGENT6             GO TO SET IT UP.
         LA    R5,12(,R5)          NEXT DEVICE ENTRY
         CLC   0(2,R5),=XL2'FFFF'  END OF TABLE
         BE    GDGENT7             YES, LEAVE IT AT ????
         B     GDGENT5             NO, TRY NEXT DEVICE ENTRY.
GDGENT6  MVC   L1UNIT,4(R5)        SET UP DEVICE TYPE IN PRINT LINE
         SR    R1,R1
         ICM   R1,3,10(R5)         TRACKS PER CYLINDER.
         ST    R1,TRKCYL           SAVE FOR LATER CALCULATION.
         TM    2(R5),X'20'         IS IT A DASD DEVICE.
         BZ    GDGENT7             IF NOT, NO VTOC TO SEARCH.
         BAL   R9,VTOC             GET DSCB FIELDS
GDGENT7  CLC   L1VOLUME,=C'MIGRAT'  IS IT MIGRATED BY HSM?
         BE    GDGENT8             IF SO, THAT'S IT.
         L     R1,LRECL            PICK UP LOGICAL RECORD LENGTH
         CVD   R1,WORK             CONVERT LRECL TO PACKED
         $EDIT L1LRECL,DWK3,ZZZZZ FORMAT IT NICELY
         L     R1,BLKSIZE          PICK UP BLOCK SIZE.
         CVD   R1,WORK             CONVERT BLKSIZE TO PACKED
         $EDIT L1BLKSIZ,                                               X
               DWK3,ZZZZZ          FORMAT WITH ZERO SUPPRESSION.
         L     R1,TRACKS           PICK UP ALLOCATED TRACKS.
         CVD   R1,WORK             CONVERT TRACKS TO PACKED
         $EDIT L1TRACKS,                                               X
               DWK4,ZZZZZZZ        MAKE IT PRINTABLE.
         DROP  R3
GDGENT8  LM    R0,R1,PLINE1        PARMS TO PRINT LINE RPTLINE1
         BAL   R9,PRINT            PRINT LINE.
         B     ENDCELL             PROCESS NEXT BCS CELL.
         TITLE ' - READ FORMAT1 DSCB AND SETUP DCB AND SPACE INFO.'
* THIS CODE USES OBTAIN TO READ IN THE FORMAT 1 DSCB AND A FORMAT 3
* DSCB IF ONE EXISTS. INFORMATION IS EXTRACTED AND PLACED INTO THE
* FIELDS: LRECL, BLKSIZE AND TRACKS.
VTOC     $IN ,
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         MVC   CAMVOL,L1VOLUME     USE VOLSER FROM BCS VOLCELL.
         CLC   CAMVOL,=C'MIGRAT'   IS IT MIGRATED?
         BE    VTOC99              IF SO, WHY BOTHER.
         MVC   CAMDSN,L1DSNAME     USE DSNAME FROM BCS.
         OBTAIN  SEARCH            READ FORMAT 1 DSCB BY DSNAME.
         ST    R15,OBTAINRC        SAVE OBTAIN RETURN CODE.
         LTR   R15,R15             WAS IT THERE?
         BZ    VTOC1               YES.
         AP    CNTNF,ONE           OTHERWISE COUNT AN ORPHAN.
         B     VTOC99              AND LEAVE IT BLANK.
VTOC1    SR    R1,R1               CLEAR REGISTER 1.
         ICM   R1,3,FORMAT1+42     PICK UP BLKSIZE
         ST    R1,BLKSIZE          AND SAVE FOR PRINT OUT.
         ICM   R1,3,FORMAT1+44     PICK UP LRECL
         ST    R1,LRECL            AND SAVE FOR PRINT OUT.
         MVC   SV1EXT1(30),FORMAT1+61  SAVE EXTENTS 1 TO 3
         CLC   FORMAT1+91,=5X'00'  IS THERE A FORMAT 3?
         BE    VTOC2A              NO, SKIP IT.
         MVC   CCHHR3,FORMAT1+91   POINTER TO FORMAT 3 DSCB.
         OBTAIN  F3CAMLST          READ FORMAT 3 BY DISK ADDRESS.
         LTR   R15,R15             DID WE GET IT?
         BNZ   VTOC2A              OH WELL
         MVC   SV3EXT4(40),FORMAT3+4  EXTENTS 4,5,6 AND 7.
         MVC   SV3EXT8(90),FORMAT3+45  EXTENTS 8 TO 16.
VTOC2A   SR    R15,R15             ZERO LOOP REGISTER
         SR    R7,R7               ZERO INDEX REGISTER
         SR    R8,R8               ZERO COUNT OF TRACKS ALLOCATED.
         IC    R15,FORMAT1+15      GET NUMBER OF EXTENTS
         LTR   R15,R15             ARE THERE ANY EXTENTS?
         BZ    VTOC5A              SKIP IT IF ZERO EXTENT
VTOC5B   EX    R0,EXTLIST(R7)      GET AN EXTENT ADDR IN R5.
         CLI   0(R5),X'00'         IS THIS AN ACTIVE EXTENT?
         BE    VTOC5C              IF NOT, SKIP IT.
         SR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,2(R5)          STARTING CC
         SR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,4(R5)         STARTING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         ST    R1,STARTTRK         SAVE IT.
         SR    R0,R0               CLEAR A REGISTER.
         ICM   R0,3,6(R5)          ENDING CC
         SR    R14,R14             CLEAR A REGISTER.
         L     R14,TRKCYL          TRACKS PER CYLINDER
         SRDA  R0,32               SETUP FOR MULTIPLY.
         MR    R0,R14              R1 = TRKS IN FULL CYLINDERS.
         ICM   R14,3,8(R5)         ENDING TT
         AR    R1,R14              STARTING RELATIVE TRACK.
         S     R1,STARTTRK         TRACKS IN THIS EXTENT IN R1
         LA    R1,1(,R1)           KEEP IT HONEST
         AR    R8,R1               COUNT IT
         LA    R7,4(,R7)           SKIP TO NEXT LA INSTRUCTION.
VTOC5C   BCT   R15,VTOC5B          LOOP THROUGH ALL EXTENTS.
VTOC5A   LA    R8,0(0,R8)          PURIFY A REGISTER.
         STCM  R8,15,TRACKS        TRACKS ALLOCATED
VTOC99   $OUT  ,                   RETURN
EXTLIST  LA    R5,SV1EXT1
         LA    R5,SV1EXT2
         LA    R5,SV1EXT3
         LA    R5,SV3EXT4
         LA    R5,SV3EXT5
         LA    R5,SV3EXT6
         LA    R5,SV3EXT7
         LA    R5,SV3EXT8
         LA    R5,SV3EXT9
         LA    R5,SV3EXT10
         LA    R5,SV3EXT11
         LA    R5,SV3EXT12
         LA    R5,SV3EXT13
         LA    R5,SV3EXT14
         LA    R5,SV3EXT15
         LA    R5,SV3EXT16
         TITLE ' - ALLOCATE ALL ONLINE VVDS''S.'
* PASS THROUGH THE UCB LOOKUP TABLE. USING UCBVOLI DEVELOP A DSNAME OF
* SYS1.VVDS.VVOLSER. TRY TO DYNAMICALLY ALLOCATE IT. IF SUCCESSFUL
* GENERATE AN ACB AND AN RPL AND SAVE THEIR ADDRESSES. FINALLY OPEN
* THE VVDS.
ALLVVDS  $IN ,
         LA    R0,VVDSGETL         LENGTH OF TABLE.
         GETMAIN R,LV=(0)
         ST    R1,VVDSTAD          SAVE TABLE START ADDRESS
         LR    R5,R1               R5 AS BASE REG FOR VVDS TABLE.
         USING VVDSTAB,R5
         L     R3,CVTPTR          GET CVT ADDRESS                  @120
         USING CVTMAP,R3          ADDRESS TO CVT                   @120
         XC    UCBWORK,UCBWORK    CLEAR WORK AREA                  @120
         LA    R1,UCBWORK         GET ADDRESS OF WORK AREA         @120
         ST    R1,PARMWA          STORE ADDR IN PARMLIST           @120
         LA    R1,DEVCLASS        ADDR OF DEVICE CLASS             @120
         ST    R1,PARMDEVT        STORE ADDR IN PARMLIST           @120
         MVI   DEVCLASS,UCB3DACC  SEARCH FOR DASD UCBS ONLY        @120
         LA    R1,ADDRUCB         ADDR OF RETURNED UCB             @120
         ST    R1,PARMUCB         STORE UCB IN PARMLIST            @120
         OI    PARMUCB,X'80'      END OF PARMLIST                  @120
         L     R1,CVTUCBSC        GET SCAN SERVICE ROUTINE         @120
         DROP  R3                                                  @120
         ST    R1,SCANSAVE        HOLD FOR LATER                   @120
UCBLOOP  LA    R1,PARMLIST        PUT ADDR INTO REG 1              @120
         L     R15,SCANSAVE       GET SCAN SERVICE RTN             @120
         BALR  R14,R15            GO TO SCAN SERVICE INTERFACE     @120
         LTR   R15,R15            WAS A UCB RETURNED?              @120
         BNZ   LASTUCB            NO.                              @120
         USING UCBOB,R2           ADDR TO UCB DSECT                @120
         L     R2,ADDRUCB         GET RETURNED UCB ADDR            @120
         TM    UCBSTAT,UCBONLI     IS IT ONLINE?                   @120
         BZ    UCBLOOP             NO, KEEP GOING                  @120
         B     ALLVVDS1            PROCESS DASD VOLUME.            @120
LASTUCB  B     ALLVVDS9                                            @120
         SPACE ,
ALLVVDS1 MVC   VVDSNAME,UCBVOLI    SET UP VOLSER IN DSNAME
         MVC   VVDDNAME,UCBVOLI    SET UP VOLSER IN DDNAME
         MVC   VVDSVOL,UCBVOLI     SAVE VOLSER IN TABLE.
         ALLOC DSN=LOCDSN,DISP=SHR,DDN=LOCDDN,ERROR=UCBLOOP
         GENCB BLK=ACB,                                                X
               AM=VSAM,                                                X
               BUFSP=32768,                                            X
               DDNAME=(*,VVDDN),                                       X
               MACRF=(ADR,SEQ)
         LTR   R15,R15             ACB GENERATED?
         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.
         STCM  R1,15,VVDSACB       STORE ACB ADDRESS
         GENCB BLK=RPL,                                                X
               AM=VSAM,                                                X
               ACB=(*,VVDSACB),                                        X
               AREA=(S,VVDSBUF),                                       X
               OPTCD=(ADR,SEQ,LOC),                                    X
               ARG=(S,VVDSARG)
         LTR   R15,R15             RPL GENERATED?
         BNZ   UCBLOOP             IF NOT, SKIP THIS VOLUME.
         STCM  R1,15,VVDSRPL       STORE RPL ADDRESS
*        LA    R0,1                AUTHORIZATION ON.
*        SVC   232                 **** INSTALLATION DEPENDANT. ****
         ICM   R8,15,VVDSACB       GET ACB ADDRESS
         OPEN  ((8))               OPEN VVDS
         LTR   R15,R15             DID IT OPEN?                    @122
         BZ    ALLVVDS2            YES.                            @122
*        SR    R0,R0                                               @122
*        SVC   232                                                 @122
        $MESSAGE 5,DATA=UCBVOLI                                    @122
         B     UCBLOOP             TRY NEXT VOLUME.                @122
ALLVVDS2 DS    0H                                                  @122
*        SR    R0,R0               AUTHORIZATION OFF.
*        SVC   232                 **** INSTALLATION DEPENDANT. ****
         LA    R5,VVDSTLEN(0,R5)   NEXT VVDSTAB ENTRY
         B     UCBLOOP             TRY NEXT VOLUME                 @120
ALLVVDS9 MVI   0(R5),255           SET END OF TABLE.
         $OUT  ,                   ALL DONE.
         TITLE ' - COLLECT DATA FROM VVDS CELLS.'
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         SPACE
VVDS     $IN ,
         SR    R15,R15             RESET RETURN CODE.              @122
         XC    BLKSIZE,BLKSIZE     RESET BLKSIZE
         XC    LRECL,LRECL         RESET LRECL
         XC    TRACKS,TRACKS       RESET TRACKS.
         USING VVR,R6
VVDS0    CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS0B              YES, IS IT THE RIGHT ONE?
VVDS0A   SR    R0,R0               NEXT CELL PLEASE
         BAL   R9,FINDVVDS         ADVANCE R6 TO NEXT CELL.
         C     R15,=F'8'           PROBLEMS?                       @122
         BNE   VVDS0               NO. IS IT A VVR?                @122
        $MESSAGE 3,DATA=L1DSNAME                                   @122
         B     VVDS98              RETURN WITH RC=8                @122
VVDS0B   SR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     VVDS0C
         CLC   L1DSNAME(0),VVRCMPNM  (EXECUTED)
VVDS0C   EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   VVDS0A              NO, MUST BE A RELATED COMPONENT.
         CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    VVDS1               YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    VVDS2               YES, IS IT THE RIGHT ONE?
         B     VVDS99              SHOULD NEVER HAPPEN!
VVDS1    ICM   R0,1,=XL1'23'       VOLUME INFORMATION CELL
         BAL   R9,FINDVVDS         FIND NEXT VVDS CELL.
         USING VVRVOLIN,R6
         MVC   BLKSIZE,VVRBLKSZ    SAVE BLOCK SIZE.
         SR    R1,R1               COUNT OF TRACKS
         SR    R8,R8
         ICM   R8,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LA    R6,40(0,R6)         SKIP AHEAD TO EXTENT DESCR.
         USING VVRXTENT,R6
VVDS1B   AH    R1,VVRXNTRK         COUNT TRACKS THIS EXTENT
         LA    R6,20(0,R6)         SKIP TO NEXT EXTENT DESCR.
         BCT   R8,VVDS1B
         ST    R1,TRACKS           SAVE ALLOCATED TRACKS.
         B     VVDS99
         DROP  R6
VVDS2    ICM   R0,1,=XL1'21'       DATASET INFORMATION CELL.
         BAL   R9,FINDVVDS         FIND NEXT VVDS CELL.
         USING VVRDSINF,R6
         MVC   LRECL,VVRLRECL      SAVE AVERAGE LRECL
         B     VVDS1               LOOK FOR VOLUME INFORMATION CELL
         DROP  R6
VVDS99   $OUT  ,
VVDSR9   DC    F'0'
VVDS98   LA    R15,8               RC=8 FOR CALLER.                @122
         B     VVDS99                                              @122
         TITLE ' - PRINT A HEX LISTING.'
HEXPRINT XPROPEN PWA,PAGELEN=PAGELEN,DDNAME=SYSPRINT
         LTR   R15,R15             DID SYSPRINT OPEN?
         BNZ   EODICAT             IF NOT, NO REPORT.
         XPRHEAD PWA,LIST=(HEADER1,HEADER3)
         BAL   R9,ALLVVDS          ALLOCATE ALL VVDS'S
*        LA    R0,1                AUTHORIZATION ON.
*        SVC   232                 **** INSTALLATION DEPENDANT ***
         SPACE ,
         L     R2,CVTPTR           A(CVT)
         L     R2,0(0,R2)          TCB WORDS
         L     R2,0(0,R2)          MY TCB.
         USING TCB,R2
         L     R2,TCBJSCB          TCB -> JSCB.
         DROP  R2
         USING IEZJSCB,R2
         L     R2,JSCBACT          ACTIVE JSCB.
         MODESET KEY=ZERO
         SPACE ,
*
* OPENING A CATALOG AS A DATASET SEEMS TO CAUSE PASSWORD PROMPTING
* EVEN FOR READING. HERE I SET THE BYPASS PASSWORD BIT TO GIVE OPER
* A BREAK.
*
         OI    JSCBSWT1,JSCBPASS
         SPACE ,
         MODESET KEY=NZERO
         OPEN  ACBICAT
*        SR    R0,R0               AUTHORIZATION OFF.
*        SVC   232                 **** INSTALLATION DEPENDANT ***
         BAL   R9,GENRPL           GENERATE RPL ADDR.              @120
GETNEXTH L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         LTR   R15,R15             RECORD READ OK?
         L     R3,BUFPTR           ADDR OF CATALOG RECORD
         L     R2,RPLICAT          GET RPL ADDR FROM LAST GET.
         L     R2,48(0,R2)         LENGTH OF RECORD READ
         AR    R2,R3               POINT TO END OF CATALOG RECORD
         ST    R2,ENDBCS           SAVE FOR FINDBCS ROUTINE
         LA    R3,2(,R3)           SKIP OVER PREFIX
HEXNEXT  CLI   2(R3),C'A'          A = NONVSAM
         BE    HEXNVSAM
         CLI   2(R3),C'C'          C = CLUSTER
         BE    HEXCLUST
         CLI   2(R3),C'D'          D = DATA COMPONENT
         BE    HEXDATA
         CLI   2(R3),C'I'          I = INDEX COMPONENT
         BE    HEXINDEX
ENDHEX   SR    R1,R1
         ICM   R1,3,0(R3)          PICK UP CELL LENGTH
         AR    R3,R1               POINT TO NEXT CELL
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    HEXNEXT             YES, KEEP GOING
         B     GETNEXTH            READ ANOTHER RECORD.
         TITLE ' - HEX PRINT A NONVSAM CELL.'
         USING NVNC,R3
HEXNVSAM MVC   L2TYPE,=CL7'NONVSAM'
         AP    CNTNVSAM,ONE        COUNT OFF A NONVSAM             @120
         HEX   L2WORK,NVCELEN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF NVNC
         HEX   L2WORK+5,NVTYPE,                                        X
               1,HEXTAB=TRHEX      TYPE 'A' FOR NONVSAM
         HEX   L2WORK+8,NVRESV,                                        X
               1,HEXTAB=TRHEX      RESERVED
         HEX   L2WORK+11,NVOLCNT,                                      X
               2,HEXTAB=TRHEX      NUMBER OF VOLUME CELLS (255 MAX)
         HEX   L2WORK+16,NVKEYLN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE NONVSAM KEY
         MVC   L2WORK+19(44),NVNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAL   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX PRINT A CLUSTER CELL.'
         USING VCNC,R3
HEXCLUST MVC   L2TYPE,=CL7'CLUSTER'
         AP    CNTCLUST,ONE        COUNT A CLUSTER                 @120
         HEX   L2WORK,CLCELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF VCNC INCLUDING ITSELF
         HEX   L2WORK+5,CLTYPE,                                        X
               1,HEXTAB=TRHEX      TYPE 'C' FOR CLUSTER
         HEX   L2WORK+8,CLCOMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF THE CLUSTER COMPONENT
         HEX   L2WORK+13,CLNOEXT,                                      X
               1,HEXTAB=TRHEX      NUMBER OF EXTENSION RECORDS
         HEX   L2WORK+16,CLNMLEN,                                      X
               1,HEXTAB=TRHEX      LENGTH OF THE CLUSTER KEY (45)
         MVC   L2WORK+19(44),CLNAME
         LM    R0,R1,PLINE2A       PARMS TO SKIP BEFORE RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAL   R9,HEXASSOC         ASSOCIATION (IF PRESENT).
         BAL   R9,HEXRELAT         RELATIONSHIP CELL (?)
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX PRINT A DATA OR INDEX CELL.'
         USING DINC,R3
HEXDATA  MVC   L2TYPE,=CL7'DATA'
         AP    CNTDATA,ONE         COUNT IT                        @120
         B     HEXDATA1
HEXINDEX MVC   L2TYPE,=CL7'INDEX'
         AP    CNTINDEX,ONE        COUNT IT.                       @120
HEXDATA1 HEX   L2WORK,DIDLEN,                                          X
               2,HEXTAB=TRHEX      LENGTH OF DINC
         HEX   L2WORK+5,DIDTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE 'D' FOR DATA OR INDEX
         HEX   L2WORK+8,DIDCMPLN,                                      X
               2,HEXTAB=TRHEX      LENGTH OF DINC COMPONENT
         HEX   L2WORK+13,DIDIRFLG,                                     X
               1,HEXTAB=TRHEX      INTERRUPT RECOGNITION FLAGS
         HEX   L2WORK+16,DIDKEYLN,                                     X
               1,HEXTAB=TRHEX      CONDENSED KEYLENGTH
         SR    R1,R1
         ICM   R1,1,DIDKEYLN       GET LENGTH OF NAME KEY.
         B     *+10
         MVC   L2WORK+19(0),DIDKEY
         EX    R1,*-6              MOVE IN NAME KEY.
         B     *+10
         MVC   SVCOMPN(0),DIDKEY   SAVE COMPONENT NAME
         EX    R1,*-6              MOVE IN NAME KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         BAL   R9,HEXOWNER         OWNER CELL NEXT.
         BAL   R9,HEXSECUR         SECURITY CELL (IF PRESENT).
         BAL   R9,HEXVOL           VOLUME CELL(S).
         B     ENDHEX
         DROP  R3
         TITLE ' - HEX AN OWNER CELL.'
HEXOWNER $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TYPE.
         BAL   R9,FINDBCS          LOOK FOR IT.
         USING OWNERC,R3
         MVC   L2TYPE,=CL7' OWNER'
         HEX   L2WORK,OWNCELLN,                                        X
               2,HEXTAB=TRHEX      LENGTH OF OWNERSHIP CELL
         HEX   L2WORK+5,OWNTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'01' FOR OWNER
         HEX   L2WORK+8,OWNID,                                         X
               4,HEXTAB=TRHEX      OWNER ID
         HEX   L2WORK+16,OWNID+4,                                      X
               4,HEXTAB=TRHEX      OWNER ID
         HEX   L2WORK+25,OWNFLAG,                                      X
               1,HEXTAB=TRHEX      FLAG
         HEX   L2WORK+28,OWNCREDT,                                     X
               3,HEXTAB=TRHEX      CREATION DATE
         HEX   L2WORK+35,OWNEXPDT,                                     X
               3,HEXTAB=TRHEX      EXPIRY DATE
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         $OUT  ,                   GET OUT.
         TITLE ' - HEX AN ASSOCIATION CELL.'
HEXASSOC $IN ,
         ICM   R0,3,=XL2'FF03'     TYPE X'03', OPTIONAL.
         BAL   R9,FINDBCS          IS THERE ONE?
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXASS99            NO.
         USING ASSOCC,R3
         MVC   L2TYPE,=CL7' ASSOC'
         HEX   L2WORK,ASCLEN,                                          X
               2,HEXTAB=TRHEX      ASSOCIATION CELL LENGTH
         HEX   L2WORK+5,ASCTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'03' FOR ASSOC
         HEX   L2WORK+8,ASCOUNT,                                       X
               2,HEXTAB=TRHEX      COUNT OF ASSOCIATIONS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXASS99 $OUT  ,                   GET OUT
         TITLE ' - HEX A SECURITY CELL.'
HEXSECUR $IN ,
         ICM   R0,3,=XL2'FF02'     TYPE X'02', OPTIONAL.
         BAL   R9,FINDBCS          IS THERE ONE?
         LTR   R0,R0               SO WAS THERE?
         BZ    HEXSEC99            NO.
         USING SECURITY,R3
         MVC   L2TYPE,=CL7' SECUR'
         HEX   L2WORK,SECELLN,                                         X
               2,HEXTAB=TRHEX      LENGTH OF SECURITY CELL
         HEX   L2WORK+5,SECTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'02' FOR SECURITY.
         HEX   L2WORK+8,SECMSTR,                                       X
               4,HEXTAB=TRHEX      MASTER PASSWORD.
         HEX   L2WORK+16,                                              X
               SECMSTR+4,                                              X
               4,HEXTAB=TRHEX      MASTER PASSWORD.
         HEX   L2WORK+27,SECCI,                                        X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+35,SECCI+4,                                      X
               4,HEXTAB=TRHEX      CONTROL INTERVAL PASSWORD.
         HEX   L2WORK+44,                                              X
               SECUPDTE,                                               X
               4,HEXTAB=TRHEX      UPDATE PASSWORD.
         HEX   L2WORK+52,                                              X
               SECUPDTE+4,                                             X
               4,HEXTAB=TRHEX      UPDATE PASSWORD.
         HEX   L2WORK+61,SECREAD,                                      X
               4,HEXTAB=TRHEX      READ PASSWORD.
         HEX   L2WORK+69,                                              X
               SECREAD+4,                                              X
               4,HEXTAB=TRHEX      READ PASSWORD.
         HEX   L2WORK+78,SECPMTCD,                                     X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+86,                                              X
               SECPMTCD+4,                                             X
               4,HEXTAB=TRHEX      PASSWORD PROMPTING CODE.
         HEX   L2WORK+95,SECATMP,                                      X
               2,HEXTAB=TRHEX      MAXIMUM NUMBER OF ATTEMPTS.
         HEX   L2WORK+100,                                             X
               SECVRMOD,                                               X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+108,                                             X
               SECVRMOD+4,                                             X
               4,HEXTAB=TRHEX      USER SECURITY VERIFICATION MOD.
         HEX   L2WORK+117,                                             X
               SECRCDLN,                                               X
               2,HEXTAB=TRHEX      USER AUTHORIZATION RECORD LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXSEC99 $OUT  ,                   GET OUT
         TITLE ' - HEX A RELATION CELL.'
HEXRELAT $IN ,
         ICM   R0,3,=XL2'FF06'     OPTIONAL RELAT CELL
         BAL   R9,FINDBCS          LOOK FOR IT.
         LTR   R0,R0               WAS IT THERE?
         BZ    HEXREL99            NO.
         USING RELCELL,R3
         MVC   L2TYPE,=CL7' RELAT'
         HEX   L2WORK,RELLEN,                                          X
               2,HEXTAB=TRHEX      CELL LENGTH.
         HEX   L2WORK+5,RELTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'06'
         HEX   L2WORK+8,RELRESV,                                       X
               1,HEXTAB=TRHEX      RESERVED.
         HEX   L2WORK+11,RELCNT,                                       X
               1,HEXTAB=TRHEX      COUNT OF RELKEYS.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXREL99 $OUT  ,                   GET OUT
         TITLE ' - HEX A VOLUME CELL.'
* THIS LOGIC IS ENTERED AT A POINT WHERE THERE MUST BE AT LEAST ONE
* VOLUME CELL POINTED TO BY R3. HOWEVER THERE COULD BE MORE THAN ONE.
* HENCE, AFTER THE FIRST NON-VOLUME CELL IS RECOGNIZED R3 MUST BE
* BACKED UP TO THE LAST VOLUME CELL SO THAT THE GENERAL CODE AT
* "ENDHEX" CAN SKIP OVER IT.
HEXVOL   $IN ,
HEXVOL0  ICM   R0,3,=XL2'FF04'     VOLUME CELL
         BAL   R9,FINDBCS
         LTR   R0,R0               WAS THAT THE LAST ONE?
         BZ    HEXVOL99            YES.
         USING VOLCELL,R3
         MVC   L2TYPE,=CL7' VOLUME'
         HEX   L2WORK,VOLLEN,                                          X
               2,HEXTAB=TRHEX      LENGTH OF VOLCELL
         HEX   L2WORK+5,VOLTYPE,                                       X
               1,HEXTAB=TRHEX      TYPE X'04' FOR VOLUME CELL
         HEX   L2WORK+8,VOLOFSET,                                      X
               1,HEXTAB=TRHEX      UNUSED
         MVC   L2WORK+11(6),VOLSERN
         HEX   L2WORK+18,VOLDEVTP,                                     X
               4,HEXTAB=TRHEX      DEVICE TYPE
         HEX   L2WORK+27,VOLFLAG1,                                     X
               1,HEXTAB=TRHEX      FLAG
         HEX   L2WORK+30,VOLFLAG2,                                     X
               1,HEXTAB=TRHEX      RESERVED
         HEX   L2WORK+33,VOLVVRBA,                                     X
               4,HEXTAB=TRHEX      RELATIVE BYTE ADDRESS OF VVR
         HEX   L2WORK+42,VOLFLSEQ,                                     X
               2,HEXTAB=TRHEX      NONVSAM FILE SEQUENCE NUMBER (TAPE)
         HEX   L2WORK+47,VOLKRQL,                                      X
               4,HEXTAB=TRHEX      KEYRANGE QUALIFIER (VSAM ONLY)
         HEX   L2WORK+56,VOLLKYLN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF LOW KEY RANGE KEY
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         TM    VOLFLAG1,VOLNVSAM   IS IT NONVSAM?
         BO    HEXVOL99            IF SO, THAT'S ALL
         TM    VOLFLAG1,VOLCANDI   IS IT A CANDIDATE VOLUME?
         BO    HEXVOL99            IF SO, THAT'S ALL
         MVC   RBASAVE,VOLVVRBA    SAVE RBA OF VVR
         L     R5,VVDSTAD          GET VVDSTAB START ADDR
         USING VVDSTAB,R5
HEXVOL8  CLI   VVDSVOL,255         LAST ENTRY?
         BE    HEXVOL99            YES, OH WELL.
         CLC   VVDSVOL,VOLSERN     IS THIS THE VVDS?
         BNE   HEXVOL6             NO, TRY AGAIN
         ICM   R1,15,RBASAVE       GET VVR RBA
         STCM  R1,15,VVDSARG       INSERT TO ARG FIELD FOR THIS RPL
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDR
         POINT RPL=(8)             POSITION TO DESIRED RECORD
         GET   RPL=(8)             READ IN RECORD
         LTR   R15,R15             RECORD READ OK?
         L     R6,VVDSBUF          ADDR OF CATALOG RECORD
         L     R1,VVDSRPL          GET ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD READ
         AR    R1,R6               POINT TO END OF CATALOG RECORD
         ST    R1,ENDVVD           SAVE END OF RECORD ADDR
         LA    R6,2(,R6)           SKIP OVER PREFIX
         BAL   R9,HEXVVR           PRIMARY OR 2NDARY VVR
         BAL   R9,HEXDSINF         DATASET INFORMATION CELL (MAYBE)
         BAL   R9,HEXAMDSB         AMDSB CELL (IF PRESENT)
         BAL   R9,HEXVOLIN         VOLUME INFORMATION CELL.
         B     HEXVOL0             COULD BE MORE THAN ONE.
HEXVOL6  LA    R5,VVDSTLEN(0,R5)   NEXT ENTRY
         B     HEXVOL8             WHAT IS IT JOHNNY?
HEXVOL99 $OUT  ,                   GET OUT.
         DROP  R3
         TITLE ' - HEX PRINT A VVR.'
* I ENTER AT THIS POINT HAVING READ IN THE 1ST RECORD IN THE CI
* CONTAINING THE DATA I WANT. FIRSTLY I HAVE TO SKIP AHEAD TO FIND
* THE VVR FOR THE OBJECT I AM LISTING (NB: THE FIRST VVR I FIND MAY
* NOT BE IT, IE. A DATA VVR IF I'M LISTING AN INDEX).
         USING VVR,R6
HEXVVR   $IN ,
         MVC   L2TYPE,=CL7' VVR'
HEXVVR0  CLI   2(R6),C'Q'          Q = SECONDARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
         CLI   2(R6),C'Z'          Z = PRIMARY VVR
         BE    HEXVVR0B            YES, IS IT THE RIGHT ONE?
HEXVVR0A SR    R0,R0               NEXT CELL PLEASE.
         BAL   R9,FINDVVDS
         B     HEXVVR0             IS IT A VVR?
HEXVVR0B SR    R1,R1
         ICM   R1,1,VVRCMPNL       PICK UP NAME LENGTH.
         BCTR  R1,0
         BCTR  R1,0
         B     HEXVVR0C
         CLC   SVCOMPN(0),VVRCMPNM  (EXECUTED)
HEXVVR0C EX    R1,*-6              COMPARE VVR NAME TO BCS NAME.
         BNE   HEXVVR0A            NO, MUST BE A RELATED COMPONENT.
         HEX   L2WORK,VVRHDLEN,                                        X
               2,HEXTAB=TRHEX
         HEX   L2WORK+5,VVRTYPE,                                       X
               1,HEXTAB=TRHEX
         HEX   L2WORK+8,VVRFLAG,                                       X
               1,HEXTAB=TRHEX
         HEX   L2WORK+11,VVRKRQ,                                       X
               4,HEXTAB=TRHEX
         HEX   L2WORK+20,VVRCMPNL,                                     X
               1,HEXTAB=TRHEX
         SR    R1,R1
         ICM   R1,1,VVRCMPNL       GET LENGTH OF COMPONENT KEY.
         B     *+10
         MVC   L2WORK+23(0),VVRCMPNM
         EX    R1,*-6              MOVE IN COMPONENT KEY.
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         $OUT  ,                   GET OUT.
         DROP  R6
         TITLE ' - HEX A DATASET INFORMATION CELL.'
HEXDSINF $IN ,
         ICM   R0,3,=XL2'FF21'     DATASET INFORMATION CELL.
         BAL   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXDSF99            NO.
         USING VVRDSINF,R6
         MVC   L2TYPE,=CL7' DSINFO'
         HEX   L2WORK,VVRDSLEN,                                        X
               2,HEXTAB=TRHEX      CELL LENGTH.
         HEX   L2WORK+5,VVRDSTYP,                                      X
               1,HEXTAB=TRHEX      TYPE CODE IS X'21'
         HEX   L2WORK+8,VVRATTR1,                                      X
               1,HEXTAB=TRHEX      DATASET ATTRIBUTES
         HEX   L2WORK+11,VVRATTR2,                                     X
               1,HEXTAB=TRHEX      DATASET ATTRIBUTES
         HEX   L2WORK+14,VVROPIND,                                     X
               1,HEXTAB=TRHEX      OPEN INDICATOR
         HEX   L2WORK+17,VVRBUFSZ,                                     X
               4,HEXTAB=TRHEX      MINIMUM BUFFER SIZE
         HEX   L2WORK+26,VVRPRISP,                                     X
               3,HEXTAB=TRHEX      PRIMARY SPACE ALLOCATION
         HEX   L2WORK+33,VVRSECSP,                                     X
               3,HEXTAB=TRHEX      SECONDARY SPACE ALLOCATION
         HEX   L2WORK+40,VVRSPCFG,                                     X
               1,HEXTAB=TRHEX      SPACE FLAGS
         HEX   L2WORK+43,VVRDSHU,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH USED RBA
         HEX   L2WORK+52,VVRDSHA,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH ALLOCATED RBA
         HEX   L2WORK+61,VVRLRECL,                                     X
               4,HEXTAB=TRHEX      AVERAGE LOGICAL RECORD LENGTH
         HEX   L2WORK+70,VVREXCPX,                                     X
               4,HEXTAB=TRHEX      EXCEPTION EXIT.
         HEX   L2WORK+78,VVREXCPX+4,                                   X
               4,HEXTAB=TRHEX      EXCEPTION EXIT.
         HEX   L2WORK+87,VVRDSHK,                                      X
               4,HEXTAB=TRHEX      DATASET HIGH KEY RBA.
         HEX   L2WORK+96,VVRCLSFG,                                     X
               1,HEXTAB=TRHEX      CLUSTER ATTRIBUTE FLAG
         HEX   L2WORK+99,VVRAIXFG,                                     X
               1,HEXTAB=TRHEX      AIX ATTRIBUTE FLAG
         HEX   L2WORK+102,VVRTMSTP,                                    X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         HEX   L2WORK+110,VVRTMSTP+4,                                  X
               4,HEXTAB=TRHEX      TIMESTAMP (CATALOG ONLY).
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXDSF99 $OUT  ,                   GET OUT
         TITLE ' - HEX AN AMDSB CELL.'
HEXAMDSB $IN ,
         ICM   R0,3,=XL2'FF60'     AMDSB CELL
         BAL   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXAMD99            NO.
         USING VVRAMDCL,R6
         MVC   L2TYPE,=CL7' AMDSB'
         HEX   L2WORK+00,VVRAMDCN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF AMDSB CELL
         HEX   L2WORK+05,VVRAMID,                                      X
               1,HEXTAB=TRHEX      TYPE CODE IS X'60'
         HEX   L2WORK+08,VVRAMATR,                                     X
               1,HEXTAB=TRHEX      ATTRIBUTES:
         HEX   L2WORK+11,VVRAMLEN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF AMDSB
         HEX   L2WORK+16,VVRAMNST,                                     X
               2,HEXTAB=TRHEX      NUMBER OF ENTRIES IN INDEX SECTION
         HEX   L2WORK+21,VVRAMRKP,                                     X
               2,HEXTAB=TRHEX      RKP
         HEX   L2WORK+26,VVRAMKNL,                                     X
               2,HEXTAB=TRHEX      KEY LENGTH
         HEX   L2WORK+31,VVRAMPCA,                                     X
               1,HEXTAB=TRHEX      % FREE CI IN CA
         HEX   L2WORK+34,VVRAMPCI,                                     X
               1,HEXTAB=TRHEX      % FREE BYTES IN CI
         HEX   L2WORK+37,VVRAMCCA,                                     X
               2,HEXTAB=TRHEX      CI'S PER CA
         HEX   L2WORK+42,VVRAMFCA,                                     X
               2,HEXTAB=TRHEX      FREE CI'S PER CA
         HEX   L2WORK+47,VVRAMFCI,                                     X
               4,HEXTAB=TRHEX      FREE BYTES PER CI
         HEX   L2WORK+56,VVRAMCIV,                                     X
               4,HEXTAB=TRHEX      CONTROL INTERVAL SIZE
         HEX   L2WORK+65,VVRAMLCL,                                     X
               4,HEXTAB=TRHEX      MAXIMUM RECORD SIZE
         HEX   L2WORK+74,VVRAMSLT,                                     X
               4,HEXTAB=TRHEX      SLOTS PER CI
         HEX   L2WORK+83,VVRAMMRR,                                     X
               4,HEXTAB=TRHEX      MAXIMUM RELATIVE RECORD NUMBER
         HEX   L2WORK+92,VVRAMARB,                                     X
               4,HEXTAB=TRHEX      POINTER TO 1ST ARDB
         HEX   L2WORK+101,VVRAMAT3,                                    X
               1,HEXTAB=TRHEX      ATTRIBUTES
         HEX   L2WORK+104,VVRAMSNO,                                    X
               1,HEXTAB=TRHEX      NUMBER OF CONCURRENT REQUESTS
         HEX   L2WORK+107,VVRAMBFD,                                    X
               2,HEXTAB=TRHEX      NUMBER OF DATA BUFFERS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         HEX   L2WORK+00,VVRAMSTS,                                     X
               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP
         HEX   L2WORK+08,VVRAMSTS+4,                                   X
               4,HEXTAB=TRHEX      SYSTEM TIMESTAMP
         HEX   L2WORK+17,VVRAMNIL,                                     X
               2,HEXTAB=TRHEX      NUMBER OF INDEX LEVELS
         HEX   L2WORK+22,VVRAMNXT,                                     X
               2,HEXTAB=TRHEX      NUMBER OF EXTENTS
         HEX   L2WORK+27,VVRAMNLR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF LOGICAL RECORDS
         HEX   L2WORK+38,VVRAMDLR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF DELETED RECORDS
         HEX   L2WORK+47,VVRAMINR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF INSERTED RECORDS
         HEX   L2WORK+56,VVRAMUPR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF UPDATED RECORDS
         HEX   L2WORK+65,VVRAMRTR,                                     X
               4,HEXTAB=TRHEX      NUMBER OF RETRIEVED RECORDS
         HEX   L2WORK+74,VVRAMASP,                                     X
               4,HEXTAB=TRHEX      BYTES OF FREE SPACE IN DATASET
         HEX   L2WORK+83,VVRAMCIS,                                     X
               4,HEXTAB=TRHEX      NUMBER OF CI SPLITS
         HEX   L2WORK+92,VVRAMCAS,                                     X
               4,HEXTAB=TRHEX      NUMBER OF CA SPLITS
         HEX   L2WORK+101,VVRAMEXC,                                    X
               4,HEXTAB=TRHEX      NUMBER OF EXCPS
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
HEXAMD99 $OUT  ,                   GET OUT
         TITLE ' - HEX A VOLUME INFORMATION CELL.'
HEXVOLIN $IN ,
         ICM   R0,3,=XL2'FF23'     VOLUME INFORMATION CELL
         BAL   R9,FINDVVDS         LOOK FOR IT.
         LTR   R0,R0               WAS THERE ONE?
         BZ    HEXVLN99            NO.
         USING VVRVOLIN,R6
         MVC   L2TYPE,=CL7' VOLINF'
         HEX   L2WORK+00,VVRVOLLN,                                     X
               2,HEXTAB=TRHEX      LENGTH OF VOLUME CELL
         HEX   L2WORK+05,VVRVOLTP,                                     X
               1,HEXTAB=TRHEX      TYPE CODE IS X'23'
         HEX   L2WORK+08,VVRVOLFG,                                     X
               1,HEXTAB=TRHEX      VOLUME FLAGS
         HEX   L2WORK+11,VVRNOEXT,                                     X
               1,HEXTAB=TRHEX      NUMBER OF EXTENTS ON THIS VOLUME.
         HEX   L2WORK+14,VVRHKRBA,                                     X
               4,HEXTAB=TRHEX      HIGH KEY RBA
         HEX   L2WORK+23,VVRHURBA,                                     X
               4,HEXTAB=TRHEX      HIGH USED RBA
         HEX   L2WORK+32,VVRHARBA,                                     X
               4,HEXTAB=TRHEX      HIGH ALLOCATED RBA
         HEX   L2WORK+41,VVRBLKSZ,                                     X
               4,HEXTAB=TRHEX      BLOCK SIZE
         HEX   L2WORK+50,VVRBLKTK,                                     X
               2,HEXTAB=TRHEX      NUMBER OF BLOCKS PER TRACK
         HEX   L2WORK+55,VVRTRKAU,                                     X
               2,HEXTAB=TRHEX      NUMBER OF TRACKS PER ALLOCATION UNIT
         HEX   L2WORK+60,VVRTPEXT,                                     X
               1,HEXTAB=TRHEX      EXTENT TYPE FLAG
         HEX   L2WORK+63,VVRTKCYL,                                     X
               2,HEXTAB=TRHEX      TRACKS PER CYLINDER
         HEX   L2WORK+68,VVRBYTTK,                                     X
               4,HEXTAB=TRHEX      BYTES PER TRACK.
         HEX   L2WORK+77,VVRBYTAU,                                     X
               4,HEXTAB=TRHEX      BYTES PER ALLOCATION UNIT
         HEX   L2WORK+86,VVRLOKYL,                                     X
               2,HEXTAB=TRHEX      LOW KEY LENGTH
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         ST    R5,HEXR5            SAVE VVDSTAB BASE REG
         SR    R5,R5
         ICM   R5,1,VVRNOEXT       GET NUMBER OF EXTENTS
         LR    R8,R6
         LA    R8,40(0,R8)         POINT TO EXTENT DESCR.
         USING VVRXTENT,R8
HEXVLN97 HEX   L2WORK+00,VVRXSEQN,                                     X
               2,HEXTAB=TRHEX      SEQUENCE NUMBER
         HEX   L2WORK+05,VVRXSCH,                                      X
               4,HEXTAB=TRHEX      STARTING CCHH
         HEX   L2WORK+14,VVRXECH,                                      X
               4,HEXTAB=TRHEX      ENDING CCHH
         HEX   L2WORK+23,VVRXNTRK,                                     X
               2,HEXTAB=TRHEX      NUMBER OF TRACKS
         HEX   L2WORK+28,VVRXSRBA,                                     X
               4,HEXTAB=TRHEX      STARTING RBA
         HEX   L2WORK+37,VVRXERBA,                                     X
               4,HEXTAB=TRHEX      ENDING RBA
         LM    R0,R1,PLINE2        PARMS TO PRINT RPTLINE2
         BAL   R9,PRINT            PRINT LINE.
         LA    R8,20(0,R8)         POINT TO NEXT EXTENT DESCR.
         BCT   R5,HEXVLN97         FORMAT ALL EXTENTS
         L     R5,HEXR5            RESTORE VVDSTAB BASE REG
HEXVLN99 $OUT  ,                   GET OUT
HEXR5    DC    F'0'                I'M RUNNING OUT OF REGISTERS
         DROP  R8
         TITLE ' - FINDBCS. ADVANCE R3 TO A SPECIFIED BCS CELL.'
* I ENTER HERE WITH R3 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
FINDBCS  $IN ,
         ST    R3,BCS2             SAVE CELL ADDRESS.
FINDBCS1 SR    R1,R1               CLEAR REGISTER
         ICM   R1,3,0(R3)          PICK UP LENGTH OF CURRENT CELL.
         AR    R3,R1               AND SKIP OVER IT.
         C     R3,ENDBCS           ANY MORE CELLS IN THIS RECORD?
         BL    FINDBCS2            YES.
         ST    R0,BCS0             SAVE CALLERS PARMS
         L     R1,RPLICAT          GET RPL ADDR.
         GET   RPL=(1)
         AP    BCSGETS,ONE         COUNT OFF A GET.
         L     R0,BCS0             RESTORE CALLERS PARMS
         LTR   R15,R15             RECORD READ OK?
         L     R3,BUFPTR           ADDRESS OF RECORD JUST READ.
         L     R1,RPLICAT          GET RPL ADDR.
         L     R1,48(0,R1)         RECORD LENGTH.
         AR    R1,R3               END OF RECORD.
         ST    R1,ENDBCS           SAVE FOR NEXT TIME.
         LA    R3,2(0,R3)          SKIP OVER PREFIX.
FINDBCS2 CLM   R0,1,2(R3)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDBCS9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDBCS1            NO, SO KEEP LOOKING.
         L     R3,BCS2             BACKUP TO WHERE WE STARTED.
         SR    R0,R0               LET HIM KNOW ABOUT IT.
FINDBCS9 $OUT  ,
ENDBCS   DC    F'0'                BCS RECORD END ADDRESS
BCS9     DC    F'0'                SAVE R9 IN HERE.
BCS2     DC    F'0'                SAVE R3 IN HERE.
BCS0     DC    F'0'                SAVE R0 IN HERE.
         TITLE ' - FINDVVDS. ADVANCE R6 TO A SPECIFIED VVDS CELL.'
* I ENTER HERE WITH R6 POINTING TO A CELL I HAVE JUST PROCESSED. THIS
* CODE EITHER MOVES AHEAD TO THE NEXT CELL BE IT WHATEVER OR SEARCHES
* FOR A PARTICULAR CELL TYPE.
* ON ENTRY THE NEXT-TO-RIGHT-MOST BYTE OF R0 CONTAINS X'FF' IF THE
* CELL TYPE THE CALLER WANTS IS OPTIONAL (IT'S EITHER THE NEXT ONE OR
* IT'S NOT THERE AT ALL) OR X'00' IF THE DESIRED CELL TYPE IS REQUIRED
* BUT MAY NOT BE THE NEXT ONE.
* THE RIGHT-MOST BYTE OF R0 CONTAINS THE ID OF THE CELL TYPE THE
* CALLER WANTS.
* IF R0 IS ALL ZEROS THE CALLER JUST WANTS THE NEXT CELL.
* IF THE REQUESTED CELL TYPE WAS FOUND R0 IS CLEARED.
FINDVVDS $IN ,
         ST    R6,VVD6             SAVE CELL ADDRESS
FINDVVD1 SR    R1,R1               CLEAR REGISTER
         SR    R15,R15             CLEAR PREVIOUS RETCODE.         @122
         ICM   R1,3,0(R6)          PICK UP LENGTH OF CURRENT CELL.
         AR    R6,R1               AND SKIP OVER IT.
         C     R6,ENDVVD           ANY MORE CELLS IN THIS RECORD?
         BL    FINDVVD2            YES.
         ICM   R8,15,VVDSRPL       PICK UP RPL ADDRESS
         ST    R0,VVD0             SAVE CALLERS PARM
         GET   RPL=(8)
         LTR   R15,R15             GET OK?                         @122
         BZ    FINDVVD3            YUP.                            @122
         C     R15,=F'8'           LOGICAL ERROR?                  @122
         BE    FINDVVD4            YES.                            @122
         ABEND 16,DUMP             OTHERWISE CRASH AND BURN.       @122
FINDVVD4 DS    0H                                                  @122
         SR    R2,R2                                               @122
         ICM   R2,1,RPLERRCD-IFGRPL(R1) GET REASON CODE.           @122
         CVD   R2,DTWORK           PACK IT.                        @122
         $EDIT FDBK,DWK3,ZZZ9      FORMAT NICELY.                  @122
        $MESSAGE 2,DATA=FDBK       SAY LOGICAL ERROR.              @122
         B     FINDVVDX            GO BACK WITH RC IN R15          @122
FINDVVD3 DS    0H                                                  @122
         AP    VVDSGETS,ONE        COUNT IT.
         L     R0,VVD0             RESTORE CALLERS PARM
         L     R6,VVDSBUF          ADDRESS OF RECORD JUST READ.
         L     R1,VVDSRPL          ADDR OF RPL
         L     R1,48(0,R1)         LENGTH OF RECORD JUST READ.
         AR    R1,R6               END OF RECORD.
         ST    R1,ENDVVD           SAVE FOR NEXT TIME.
         LA    R6,2(0,R6)          SKIP OVER PREFIX.
FINDVVD2 LTR   R0,R0               IF ZERO, ANYTHING WILL DO.
         BZ    FINDVVD9
         CLM   R0,1,2(R6)          CHECK FOR REQUESTED CELL TYPE
         BE    FINDVVD9            YES.
         CLM   R0,2,=XL1'FF'       IS THIS CELL TYPE OPTIONAL?
         BNE   FINDVVD1            NO, THEN KEEP LOOKING.
         L     R6,VVD6             RESTORE INITIAL CELL ADDRESS
         SR    R0,R0               GIVE HIM THE SAD NEWS.
FINDVVD9 $OUT  ,
ENDVVD   DC    F'0'                BCS RECORD END ADDRESS
VVD9     DC    F'0'                SAVE R9 IN HERE.
VVD6     DC    F'0'                SAVE R6 IN HERE.
VVD0     DC    F'0'                SAVE R0 IN HERE.
FINDVVDX LA    R15,8                                               @122
         B     FINDVVD9                                            @122
         DROP  R5
         TITLE ' - PRINT LINE SUBROUTINE.'
PRINT    $IN ,
         ST    R1,PRINT1
         XPRNTLIN  PWA,TEXT=(R1),LENGTH=132,SPB=((R0)),SPA=1
         L     R1,PRINT1
         MVI   0(R1),C' '
         MVC   1(132,R1),0(R1)
         $OUT  ,
PRINT1   DC    F'0'
         TITLE ' - DEFINE REPORT HEADING.'
SETHEAD  $IN ,
         XPRHEAD PWA,LIST=(HEADER1,HEADER2)
         $OUT
         TITLE ' - FORMAT THE CREATION DATE FROM AN OWNER CELL.'
SETCREDT $IN ,
         ICM   R0,1,=XL1'01'       OWNER CELL TO BE FOUND.
         BAL   R9,FINDBCS          SO GO LOOK FOR IT.
         USING OWNERC,R3
         SR    R0,R0               CLEAR R0.
         ICM   R0,7,OWNCREDT       PICK UP CREATION DATE.
         XC    DTWORK,DTWORK       CLEAR DOUBLE WORD
         ST    R0,DTWORK+4         STORE FOR DATE CONVERSION
         LA    R1,DTWORK           SETUP ADDRESS
         ST    R1,DTPARM           OF PACKED FIELD
         LA    R1,DTPARM           IN PARMLIST
         L     R15,=V(XDATEDIT)    ADDRESS OF DATE CONVERT ROUTINE
         BALR  R14,R15             CONVERT DATE
         MVC   L1CREDT,DTWORK      SETUP CONVERTED DATE
         $OUT
         TITLE ' - SETUP FIELDS FROM THE HSM MCD RECORD.'
CHKHSM   DS    0H
         CLI   MCDSOPEN,254        PREVIOUS OPEN FAILED?           @122
         BER   R9                  YES. GIVE UP HOPE.              @122
         CLI   MCDSOPEN,0          IS MCDS ALREADY OPEN?
         BNE   CHKHSM1A
         OPEN  (ACBMCDS)
         LTR   R15,R15             DID IT OPEN.                    @122
         BZ    CHKHSM1B            YES                             @122
        $MESSAGE 6                 NO. SAY SO.                     @122
         MVI   MCDSOPEN,254        FLAG NO SYSUT2.                 @122
         BR    R9                  AND GO HOME.                    @122
CHKHSM1B DS    0H                                                  @122
         MVI   MCDSOPEN,255        FLAG IT OPEN
CHKHSM1A MVC   MCDSKEY,L1DSNAME    DSN AS MCDS KEY.
         GET   RPL=RPLMCDS
         LTR   R15,R15             RECORD READ OK?
         BNZR  R9                  RETURN
         L     R1,MCDSPTR          GET ADDRESS OF HSM MCD RECORD.
         USING MCD,R1
         CLC   MCDSIZE,=F'32760'   DATA AND INDEX ENTRIES NO GOOD.
         BH    CHKHSM2             SO LEAVE THEM AT ZERO
         MVC   TRACKS,MCDSIZE      ORIGINAL SIZE IN TRACKS.
CHKHSM2  MVC   BLKSIZE+2(2),MCDBLKSZ  ORIGINAL BLOCK SIZE.
         DROP  R1
         BR    R9                  EXIT
         TITLE ' - PRINT OUT STATISTICS AT EOD.'
COUNTS   $IN ,
         XPREJECT  PWA
         XPRHEAD PWA,LIST=(HEADER1)
         $EDIT T1COUNT,CNTNVSAM,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NVSAM),T1NVSAM
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=2,SPA=1
         $EDIT T1COUNT,CNTCLUST,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1CLUST),T1CLUST
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTINDEX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1INDEX),T1INDEX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTDATA,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1DATA),T1DATA
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTAIX,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1AIX),T1AIX
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTPATH,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1PATH),T1PATH
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTGDGB,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGB),T1GDGB
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTGDGE,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1GDGE),T1GDGE
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,BCSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1BCS),T1BCS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,VVDSGETS,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1VVDS),T1VVDS
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTNF,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NF),T1NF
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $EDIT T1COUNT,CNTNOENT,ZZZZZZ9
         MVI   T1TEXT,C' '
         MVC   T1TEXT+1(122),T1TEXT
         MVC   T1TEXT(L'T1NOENT),T1NOENT
         XPRNTLIN  PWA,TEXT=TOTAL+1,LENGTH=132,SPB=0,SPA=1
         $OUT
         TITLE ' - GENERATE AN RPL TO ACCESS THE BCS CLUSTER.'
GENRPL   $IN ,                                                     @120
         L     R0,BUFLEN           LENGTH TO GETMAIN
         GETMAIN R,LV=(0)          INPUT BUFFER FOR BCS RECORDS.
         ST    R1,BUFPTR           SAVE ADDRESS OF RECORD BUFFER.
         GENCB BLK=RPL,                                                X
               ACB=(S,ACBICAT),                                        X
               AM=VSAM,                                                X
               AREA=(*,BUFPTR),                                        X
               AREALEN=131072,                                         X
               OPTCD=(KEY,SEQ,MVE)
         ST    R1,RPLICAT          SAVE GENERATED RPL ADDR.
         $OUT                                                      @120
         LTORG ,
         SPACE 2
         TITLE 'DSECTS FOR CATALOG CELLS.'
VVDSTAB  DSECT ,
VVDSVOL  DS    CL6                 VOLSER OF A VOLUME WITH A VVDS
VVDSACB  DS    0F,AL4              ADDRESS OF A GENERATED ACB
VVDSRPL  DS    AL4                 ADDRESS OF A GENERATED RPL
VVDSBUF  DS    AL4                 ADDRESS OF A RECORD BUFFER
VVDSARG  DS    AL4                 ADDRESS OF RBA TO READ THE VVDS
VVDSTLEN EQU   *-VVDSTAB           LENGTH OF AN ENTRY
         SPACE 2
VCNC     DSECT                     VSAM CLUSTER NAME CELL
CLCELLN  DS    XL2                 LENGTH OF VCNC INCLUDING ITSELF
CLTYPE   DS    CL1                 TYPE 'C' FOR CLUSTER
CLCOMPLN DS    XL2                 LENGTH OF THE CLUSTER COMPONENT
CLNOEXT  DS    XL1                 NUMBER OF EXTENSION RECORDS
CLNMLEN  DS    XL1                 LENGTH OF THE CLUSTER KEY (45)
CLNAME   DS    CL44                CLUSTER NAME
CLNMPAD  DS    XL1                 PAD VALUE, SET TO X'00'
         SPACE 2
DINC     DSECT                     DATA OR INDEX NAME CELL
DIDLEN   DS    XL2                 LENGTH OF DINC
DIDTYPE  DS    CL1                 TYPE 'D' FOR DATA OR INDEX
DIDCMPLN DS    XL2                 LENGTH OF DINC COMPONENT
DIDIRFLG DS    XL1                 INTERRUPT RECOGNITION FLAGS
DIDELETE EQU   B'1000000'          DELETE IN PROGRESS
DIDUPDAT EQU   B'0100000'          UPDATE-EXTEND IN PROGRESS
DIDSRMU  EQU   B'0010000'          SUB-RECORD MOVE/UPDATE IN PROGRESS
DIDKEYLN DS    XL1                 CONDENSED KEYLENGTH
DIDKEY   DS    0XL1                CONDENSED KEY
         SPACE 2
ANC      DSECT                     ALTERNAME INDEX CELL
AIXLEN   DS    XL2                 LENGTH OF ANC
AIXTYPE  DS    CL1                 TYPE 'G' FOR ANC
AIXCMPLN DS    XL2                 LENGTH OF AIX COMPONENT
AIXFLAG  DS    XL1                 FLAG BYTE
AIXUPG   EQU   B'1000000'          AIX IS MEMBER OF UPGRADE SET
AIXKEYLN DS    XL1                 CONDENSED KEYLENGTH
AIXKEY   DS    0XL1                CONDENSED KEY 2-45 BYTES
         SPACE 2
PNC      DSECT                     PATH NAME CELL
PATHCELN DS    XL2                 LENGTH OF PATH CELL
PATHTYPE DS    CL1                 TYPE 'R' FOR PATH
         DS    XL2
PATHATTR DS    XL1                 PATH ATTRIBUTES
PATHUPG  EQU   B'1000000'          UPGRADE IF RELATED TO AIX
PATHUPD  EQU   B'1000000'          UPDATE IF RELATED TO CLUSTER.
PATHREL  EQU   B'0010000'          0=RELATED TO AIX,1=RELATED TO
*                                  CLUSTER
PATHKYLN DS    XL1                 LENGTH OF PATH KEY
PATHNAME DS    CL44                PATH NAME.
         SPACE 2
NVNC     DSECT                     NONVSAM DATASET CELL
NVCELEN  DS    XL2                 LENGTH OF NVNC
NVTYPE   DS    CL1                 TYPE 'A' FOR NONVSAM
NVRESV   DS    XL1                 RESERVED
NVOLCNT  DS    XL2                 NUMBER OF VOLUME CELLS (255 MAX)
NVKEYLN  DS    XL1                 LENGTH OF THE NONVSAM KEY
NVNAME   DS    CL44                DATASET NAME
NVPAD    DS    XL1                 PAD VALUE X'00'
         SPACE 2
OWNERC   DSECT                     OWNERSHIP CELL FORMAT.
OWNCELLN DS    XL2                 LENGTH OF OWNERSHIP CELL
OWNTYPE  DS    XL1                 TYPE X'01' FOR OWNER
OWNID    DS    XL8                 OWNER ID
OWNFLAG  DS    XL1                 FLAG
OWNRACF  EQU   B'10000000'         RACF PROTECTED
OWNKSDS  EQU   B'01000000'         INDEX COMPONENT DATASET
OWNREUS  EQU   B'00100000'         REUSABLE DATASET.
OWNERASE EQU   B'00010000'         ERASE
OWNSWAP  EQU   B'00000010'         SWAPSPACE
OWNPAGE  EQU   B'00000001'         PAGESPACE
OWNCREDT DS    XL3                 CREATION DATE
OWNEXPDT DS    XL3                 EXPIRY DATE
         SPACE 2
SECURITY DSECT                     SECURITY CELL
SECELLN  DS    XL2                 LENGTH OF SECURITY CELL
SECTYPE  DS    XL1                 TYPE X'02' FOR SECURITY.
SECMSTR  DS    CL8                 MASTER PASSWORD.
SECCI    DS    CL8                 CONTROL INTERVAL PASSWORD.
SECUPDTE DS    CL8                 UPDATE PASSWORD.
SECREAD  DS    CL8                 READ PASSWORD.
SECPMTCD DS    CL8                 PASSWORD PROMPTING CODE.
SECATMP  DS    XL2                 MAXIMUM NUMBER OF ATTEMPTS.
SECVRMOD DS    CL8                 USER SECURITY VERIFICATION MOD.
SECRCDLN DS    XL2                 USER AUTHORIZATION RECORD LENGTH.
SECRCD   DS    0XL1                USER AUTHORIZATION RECORD (256 MAX)
         SPACE 2
ASSOCC   DSECT                     ASSOCIATION CELL
ASCLEN   DS    XL2                 ASSOCIATION CELL LENGTH
ASCTYPE  DS    XL1                 TYPE X'03' FOR ASSOC
ASCOUNT  DS    XL2                 COUNT OF ASSOCIATIONS
* THE FOLLOWING FIELDS ARE REPEATED THE NUMBER OF TIMES IN ASCOUNT
ASCKEYS  DS    0XL2
ASCFLAG  DS    XL1                 FLAG
ASCREUS  EQU   B'10000000'         USED IN RELATION CELL ONLY.
ASCKYLEN DS    XL1                 LENGTH OF CONDENSED ASSOC KEY.
ASCKEY   DS    0XL1                2-45 BYTE CONDENSED KEY.
         SPACE 2
GDGNC    DSECT                     GDG BASE NAME CELL
GDGCELLN DS    XL2                 LENGTH OF GDGNC INCLUDING ITSELF
GDGTYPE  DS    CL1                 TYPE 'B' FOR GDG
GDGCMPLN DS    XL2                 LENGTH OF THE GDG COMPONENT
GDGNOEXT DS    XL1                 NUMBER OF EXTENSION RECORDS
GDGKYLEN DS    XL1                 LENGTH OF THE GDG
GDGNAME  DS    CL44                GDG NAME 1-35 BYTES BLANK PADDED
GDGPAD   DS    XL1                 PAD VALUE, SET TO X'00'
         SPACE 2
GDSNC    DSECT                     GDG ENTRY NAME CELL
GDSCELLN DS    XL2                 LENGTH OF GDSNC INCLUDING ITSELF
GDSTYPE  DS    CL1                 TYPE 'H' FOR GDS
GDSCMPLN DS    XL2                 LENGTH OF THE GDS COMPONENT
GDSGENO  DS    XL2                 GENERATION NUMBER
GDSVERNO DS    XL1                 VERSION NUMBER
GDSVOLCT DS    XL2                 NUMBER OF VOLUME CELLS IN GDS
         SPACE 2
VOLCELL  DSECT                     VOLUME CELL
VOLLEN   DS    XL2                 LENGTH OF VOLCELL
VOLTYPE  DS    XL1                 TYPE X'04' FOR VOLUME CELL
VOLOFSET DS    XL1                 UNUSED
VOLSERN  DS    CL6                 VOLUME SERIAL NUMBER
VOLDEVTP DS    XL4                 DEVICE TYPE
VOLFLAG1 DS    XL1                 FLAG
VOLPRIME EQU   B'10000000'         PRIME VOLUME-ALLOCATED SPACE
VOLCANDI EQU   B'01000000'         CANDIDATE VOLUME NOSPACE
VOLOFLOW EQU   B'00100000'         OVERFLOW KEYRANGE ONLY
VOLCONV  EQU   B'00010000'         CONVERTED VSAM DATASET VOLUME
VOLNVSAM EQU   B'00001000'         NONVSAM VOLUME CELL
VOLKYRNG EQU   B'00000100'         KEYRANGE QUALIFIER PRESENT
VOLVPCI  EQU   B'00000010'         PRIMARY VVR CI
VOLSSQWD EQU   B'00000001'         SEQUENCE SET WITH DATA
VOLFLAG2 DS    XL1                 RESERVED
VOLVVRBA DS    0XL4                RELATIVE BYTE ADDRESS OF VVR
VOLDSTTR DS    XL3                 NONVSAM FORMAT 1 DSCB TTR
         DS    XL1                 RESERVED
VOLFLSEQ DS    XL2                 NONVSAM FILE SEQUENCE NUMBER (TAPE)
VOLKRQL  DS    XL4                 KEYRANGE QUALIFIER (VSAM ONLY)
VOLLKYLN DS    XL2                 LENGTH OF LOW KEY RANGE KEY
         SPACE 2
RELCELL  DSECT                     RELATIONSHIP CELL.
RELLEN   DS    XL2                 CELL LENGTH.
RELTYPE  DS    XL1                 TYPE X'06'
RELRESV  DS    XL1                 RESERVED.
RELCNT   DS    XL1                 COUNT OF RELKEYS.
RELKEYS  DS    0XL2
RELFLAG  DS    XL1                 FLAG BYTE
RELUPG   EQU   B'10000000'         UPGRADE AIX.
RELGLEN  DS    XL1                 LENGTH OF AIX CONDENSED KEY.
RELGKEY  DS    0XL1                AIX CONDENSED KEY.
         SPACE 2
VVR      DSECT
*VVRLEN  DS    XL2                LENGTH OF ENTIRE VVR
VVRHDLEN DS    XL2                 LENGTH OF VVR HEADER
VVRTYPE  DS    CL1                 Z=PRIMARY VVR. Q=SECONDARY VVR
VVRFLAG  DS    XL1                 HEADER FLAG
VVRSELFD EQU   B'01000000'         SELF-DESCRIBING VVR FOR VVDS
VVRCATDS EQU   B'00100000'         CATALOG SELF-DESCRIBING VVR
VVRCOMTP EQU   B'00001000'         COMPONENT TYPE. 0='D' 1='I'
VVRKRQ   DS    XL4                 KEY RANGE QUALIFIER
VVRCMPNL DS    XL1                 COMPONENT NAME LENGTH
VVRCMPNM DS    0CL44               COMPONENT NAME
         SPACE 2
VVRDSINF DSECT                     DATASET INFORMATION CELL
VVRDSLEN DS    XL2                 CELL LENGTH.
VVRDSTYP DS    XL1                 TYPE CODE IS X'21'
VVRDSATR DS    0XL2                DATASET ATTRIBUTES
VVRATTR1 DS    XL1
VVRA1SPD EQU   B'10000000'         SPEED
VVRA1UNQ EQU   B'01000000'         UNIQUE
VVRA1REU EQU   B'00100000'         REUSE
VVRA1ERS EQU   B'00010000'         ERASE
VVRA1IUP EQU   B'00000100'         INHIBIT UPDATE
VVRA1TEX EQU   B'00000010'         EXPORT TEMPORARY.
VVRA1TKO EQU   B'00000001'         TRACK OVERFLOW
VVRATTR2 DS    XL1
VVRA2REG EQU   B'11000000'         CROSS-REGION SHROPTN
VVRA2SYS EQU   B'00110000'         CROSS-SYSTEM SHROPTN
VVRA2INT EQU   B'00000010'         INTERNAL DATASET
VVRA2NUS EQU   B'00000001'         COMPONENT IS NOT USABLE.
VVROPIND DS    XL1                 OPEN INDICATOR
VVRBUFSZ DS    XL4                 MINIMUM BUFFER SIZE
VVRPRISP DS    XL3                 PRIMARY SPACE ALLOCATION
VVRSECSP DS    XL3                 SECONDARY SPACE ALLOCATION
VVRSPCFG DS    XL1                 SPACE FLAGS
VVRSPCOP EQU   B'11000000'         SPACE OPTIONS
VVRDSHU  DS    XL4                 DATASET HIGH USED RBA
VVRDSHA  DS    XL4                 DATASET HIGH ALLOCATED RBA
VVRLRECL DS    XL4                 AVERAGE LOGICAL RECORD LENGTH
         DS    XL2
VVREXCPX DS    CL8                 EXCEPTION EXIT.
VVRDSHK  DS    XL4                 DATASET HIGH KEY RBA.
VVRCLSFG DS    XL1                 CLUSTER ATTRIBUTE FLAG
VVRCFSWS EQU   B'00000010'         CLUSTER DESCRIBES A SWAP SPACE
VVRCFPGS EQU   B'00000001'         CLUSTER DESCRIBES A PAGE SPACE
VVRAIXFG DS    XL1                 AIX ATTRIBUTE FLAG
VVRAIUPG EQU   B'00000001'         UPGRADE AIX.
VVRTMSTP DS    XL8                 TIMESTAMP (CATALOG ONLY).
         SPACE 2
VVRVOLIN DSECT                     VVR VOLUME INFORMATION CELL
VVRVOLLN DS    XL2                 LENGTH OF VOLUME CELL
VVRVOLTP DS    XL1                 TYPE CODE IS X'23'
VVRVOLFG DS    XL1                 VOLUME FLAGS
VVRPRIME EQU   B'10000000'         PRIME VOLUME
VVROVFLW EQU   B'00100000'         OVERFLOW VOLUME
VVRNOEXT DS    XL1                 NUMBER OF EXTENTS ON THIS VOLUME.
VVRHKRBA DS    XL4                 HIGH KEY RBA
VVRHURBA DS    XL4                 HIGH USED RBA
VVRHARBA DS    XL4                 HIGH ALLOCATED RBA
VVRBLKSZ DS    XL4                 BLOCK SIZE
VVRBLKTK DS    XL2                 NUMBER OF BLOCKS PER TRACK
VVRTRKAU DS    XL2                 NUMBER OF TRACKS PER ALLOCATION UNIT
VVRTPEXT DS    XL1                 EXTENT TYPE FLAG
VVRSSDAT EQU   B'10000000'         SEQUENCE SET WITH DATA
VVRNOPFM EQU   B'01000000'         EXTENTS NOT PRE-FORMATTED
VVRCONV  EQU   B'00100000'         CONVERTED VSAM DATASET VOLUME.
VVRTKCYL DS    XL2                 TRACKS PER CYLINDER
VVRBYTTK DS    XL4                 BYTES PER TRACK.
VVRBYTAU DS    XL4                 BYTES PER ALLOCATION UNIT
VVRLOKYL DS    XL2                 LOW KEY LENGTH
VVRLOKYV DS    0XL1                LOW KEY ON VOLUME
VVRXTENT DS    0XL1                EXTENT SECTION. FOLLOWS LOW KEY
*                                  VALUE
VVRXTNTL DS    XL2                 TOTAL LENGTH OF EXTENT SECTION.
VVRXTNT  DS    0XL20               20 BYTE EXTENT DESCRIPTION.
VVRXSEQN DS    XL2                 SEQUENCE NUMBER
VVRXSCH  DS    0XL4                STARTING CCHH
VVRXSC   DS    XL2                 STARTING CC
VVRXSH   DS    XL2                 STARTING HH
VVRXECH  DS    0XL4                ENDING CCHH
VVRXEC   DS    XL2                 ENDING CC
VVRXEH   DS    XL2                 ENDING HH
VVRXNTRK DS    XL2                 NUMBER OF TRACKS
VVRXSRBA DS    XL4                 STARTING RBA
VVRXERBA DS    XL4                 ENDING RBA
         SPACE 2
VVRAMDCL DSECT                     VVR AMDSB CELL
VVRAMDCN DS    XL2                 LENGTH OF AMDSB CELL
VVRAMCAT DS    0XL96               COPY OF AN AMDSB
VVRAMID  DS    XL1                 TYPE CODE IS X'60'
VVRAMATR DS    XL1                 ATTRIBUTES:
VVRAMDST EQU   B'10000000'         1=KSDS, 0=ESDS
VVRAMWCK EQU   B'01000000'         WRITE CHECK
VVRAMSDT EQU   B'00100000'         SEQUENCE SET WITH DATA
VVRAMREP EQU   B'00010000'         REPLICATION
VVRAMORD EQU   B'00001000'         USE VOLUMES IN LIST ORDER
VVRAMRGE EQU   B'00000100'         KEY RANGE DATASET
VVRAMRDS EQU   B'00000010'         RRDS
VVRAMRSN EQU   B'00000001'         SPANNED RECORDS ALLOWED
VVRAMLEN DS    XL2                 LENGTH OF AMDSB
VVRAMNST DS    0XL2                NUMBER OF ENTRIES IN INDEX SECTION
VVRAMAKP DS    XL2                 ALTERNATE KEY RKP
VVRAMRKP DS    XL2                 RKP
VVRAMKNL DS    XL2                 KEY LENGTH
VVRAMPCA DS    XL1                 % FREE CI IN CA
VVRAMPCI DS    XL1                 % FREE BYTES IN CI
VVRAMCCA DS    XL2                 CI'S PER CA
VVRAMFCA DS    XL2                 FREE CI'S PER CA
VVRAMFCI DS    XL4                 FREE BYTES PER CI
VVRAMCIV DS    XL4                 CONTROL INTERVAL SIZE
VVRAMLCL DS    XL4                 MAXIMUM RECORD SIZE
VVRAMHLR DS    0XL4                RBA OF HI LEVEL INDEX RECORD
VVRAMSLT DS    XL4                 SLOTS PER CI
VVRAMSSR DS    0XL4                RBA OF FIRST SEQUENCE SET RECORD
VVRAMMRR DS    XL4                 MAXIMUM RELATIVE RECORD NUMBER
VVRAMARB DS    XL4                 POINTER TO 1ST ARDB
VVRAMAT3 DS    XL1                 ATTRIBUTES
VVRAMUNQ EQU   B'10000000'         UNIQUE OR NON-UNIQUE KEYS
VVRAMFLT EQU   B'01000000'         CYLINDER FAULT MSS OR STAGE
VVRAMBND EQU   B'00100000'         BIND OR DO NOT BIND ON MSS
VVRAMWAT EQU   B'00010000'         WAIT OR DO NOT WAIT ON RELINQUISH
VVRAMLM  EQU   B'00001000'         LOAD MODE OR DATASET LOADED.
VVRAMSNO DS    XL1                 NUMBER OF CONCURRENT REQUESTS
         DS    XL4
VVRAMBFI DS    0XL2                NUMBER OF INDEX BUFFERS
VVRAMBFD DS    XL2                 NUMBER OF DATA BUFFERS
VVRAMSTS DS    XL8                 SYSTEM TIMESTAMP
VVRAMNIL DS    XL2                 NUMBER OF INDEX LEVELS
VVRAMNXT DS    XL2                 NUMBER OF EXTENTS
VVRAMNLR DS    XL4                 NUMBER OF LOGICAL RECORDS
VVRAMDLR DS    XL4                 NUMBER OF DELETED RECORDS
VVRAMINR DS    XL4                 NUMBER OF INSERTED RECORDS
VVRAMUPR DS    XL4                 NUMBER OF UPDATED RECORDS
VVRAMRTR DS    XL4                 NUMBER OF RETRIEVED RECORDS
VVRAMASP DS    XL4                 BYTES OF FREE SPACE IN DATASET
VVRAMCIS DS    XL4                 NUMBER OF CI SPLITS
VVRAMCAS DS    XL4                 NUMBER OF CA SPLITS
VVRAMEXC DS    XL4                 NUMBER OF EXCPS
         TITLE 'HSM - MCD DSECT.'
MCD      DSECT
MCDDSN   DS    CL44                DATASET NAME
MCDMCK   DS    CL20                CDS RECORD HEADER
MCDVSN   DS    CL6                 VOLSER OF MIGN. VOL HOLDING THE DS.
MCDFLGS  DS    0XL2                FLAGS
MCDFLG1  DS    X                   FLAGS - BYTE ONE
MCDFASN  EQU   B'10000000'         A MIGRATED COPY EXISTS
MCDFMIG  EQU   B'01000000'         DATA SET IS TO BE MIGRATED
MCDFNOMG EQU   B'00100000'         DATA SET IS TO BE RETAINED FROM
*                                  MIGRATION
MCDFDEL  EQU   B'00010000'         DATA SET WAS DELETED
MCDFSDP  EQU   B'00001000'         DATA SET IS SMALL-DATASET-PACKED
MCDFFL2  EQU   B'00000100'         WHEN SET TO 1, DATASET IS ON ML2,
*                                  ELSE ML1
MCDFNSCR EQU   B'00000010'         DATASET RECALLED BUT MIGRATED COPY
*                                  EXISTS
MCDJES3  EQU   B'00000001'         RECORD PROCESSED BY HSM-JES3 SETUP.
MCDFLG2  DS    X                   FLAGS - BYTE TWO
MCDFSMVL EQU   B'00000100'         SPACE MGMT FLAGS (MCDRECAL) ARE
*                                  VALID
MCDFDUMD EQU   B'00000010'         WHEN SET TO 1, THIS IS A DUMMY
*                                  RECORD
MCDJR3   EQU   B'00000001'         THIS RECORD WAS CREATED BY RELEASE
*                                  3.
MCDCOMPR DS    X                   PERCENT OF SPACE SAVED BY COMPACTION
         DS    XL3
MCDDLC   DS    CL4                 X'00YYDDDS' - DATE DS WAS CREATED.
MCDDLC3  EQU   MCDDLC+1,3,C'P'
MCDTLR   DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST USED.
MCDDLR   DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST
*                                  REFERENCED.
MCDDLR3  EQU   MCDDLR+1,3,C'P'
MCDTLU   DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST
*                                  UPDATED.
MCDDLU   DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST
*                                  UPDATED.
MCDDLU3  EQU   MCDDLU+1,3,C'P'
MCDTMIG  DS    CL4                 X'HHMMSSTH' - TIME DS WAS LAST
*                                  MIGRATED.
MCDDMIG  DS    CL4                 X'00YYDDDS' - DATE DS WAS LAST
*                                  MIGRATED.
MCDDMIG3 EQU   MCDDMIG+1,3,C'P'
MCDDSORG DS    XL2                 DSORG FROM THE DSCB.
MCDBLKSZ DS    XL2                 MAXIMUM BLOCK SIZE OF THE DATASET.
MCDKEYLN DS    XL1                 KEY LENGTH OF THE DATASET.
MCDRECFM DS    XL1                 RECORD FORMAT
MCDRFTYP EQU   B'11000000'         FLAGS FOR A V,B, OR F FORMAT ???
MCDRFTO  EQU   B'01000000'         TRACK OVERFLOW IS PRESENT
MCDDSIND DS    XL1                 INDICATORS FROM THE FORMAT 1 DSCB.
MCDFRACF EQU   B'01000000'         DS IS RACF-PROTECTED
MCDFSCTY EQU   B'00010000'         DS IS PASSWORD PROTECTED.
MCDFWSEC EQU   B'00000100'         DS IS WRITE-PASSWORD PROTECTED
MCDFCHNG EQU   B'00000010'         OPENED FOR OTHER THAN READ-ONLY
MCDHID   DS    XL1                 ID OF THE PROCESSOR USING THIS
*                                  RECORD
MCDSIZE  DS    XL4                 SIZE ALLOCATED IN TRACKS, ON THE
*                                  USERS VOL
MCDSIZEB DS    XL4                 SIZE USED IN BYTES, ON THE USERS VOL
MCDCSZ   DS    XL4                 SIZE OF THE DS IN 2K BLKS ON MIG
*                                  VOLUME
MCDNMIG  DS    XL2                 COUNT OF TIME DS WAS MIGRATED.
MCDDAYS  DS    XL2                 NUMBER OF DAYS BEFORE DS WILL BE
*                                  MIGRATED
MCDFRVSN DS    CL6                 VOLSER OF PRIMARY WHERE DATASET WAS
         ORG   MCDFRVSN
MCDOVSN  DS    CL6                 VOLSER TO WHICH DS WAS RECALLED
         DS    XL1
MCDMCL43 DS    XL1
MCDCTID3 DS    CL4                 NAME OF COMPACTION TABLE USED ON
*                                  THIS DS
MCDUCBTY DS    XL4                 UCBTYP OF "FROM" PRIMARY VOLUME.
MCDTRES  DS    CL4                 X'HHMMSSTH' - TIME DS WAS
*                                  RECALLED/DELETED
MCDDRES  DS    CL4                 X'00YYDDDS' - DATE DS WAS
*                                  RECALLED/DELETED
MCDMDEVT DS    XL4                 DEVICE TYPE OF MIGRATION VOLUME
MCDJDAYS DS    XL1
MCDJDATE DS    XL3                 LAST DATE TO WHICH HSM WILL DELAY
*                                  MIG
MCDJVEXD DS    XL3
MCDPDEP  DS    XL1
MCDJCT   DS    XL1                 COUNT OF VOLS ELIGIBLE FOR DIRECTED
*                                  RECALL
MCDJVOLS DS    0CL10               5 SLOTS - VOLUMES FOR DATASET RECALL
MCDJVSN  DS    CL6                 VOLSER TO WHICH DS CAN BE RECALLED
MCDJDEVT DS    XL4                 DEVICE TYPE OF ABOVE
         DS    4CL10
MCDRECAL DS    X                   FLAGS
MCDFDBA  EQU   B'10000000'         WHEN 0, DS MUST BE RECALLED TO MIG
*                                  VOL
MCDFRBU  EQU   B'01000000'
MCDFBDCS EQU   B'00100000'         DS MIGRATED FROM A BACKED-UP VOLUME
MCDFBDCT EQU   B'00010000'
MCDFAM   EQU   B'00001000'         DS MUST BE RECALLED TO AUTOMIG
*                                  VOLUME
MCDFAB   EQU   B'00000100'         DS MUST BE RECALLED TO AUTOBACKUP
*                                  VOL
MCDEXPDT DS    CL4                 X'00YYDDDS' - EXPDT WHEN MIGRATED
MCDMCANM DS    CL44                DATASET NAME OF MIGRATED VERSION
         TITLE 'DSECTS FOR SYSTEM DATA AREAS.'
         CVT   DSECT=YES
UCB      DSECT ,
         IEFUCBOB  ,
         IEFZB4D0  ,
         IEFZB4D2  ,
         IEZJSCB ,
         IKJTCB  DSECT=YES
         IFGRPL  ,                                                 @122
         TITLE 'DATA AREAS'
DATASECT CSECT
         DS    0D
DTWORK   DC    D'0'                WORK FIELD FOR DATE CONVERSION
DTPARM   DC    AL4(0)
DTL5     EQU   DTWORK+3,5          5 BYTES FOR EDIT MACRO
DTL4     EQU   DTWORK+4,4          4 BYTES FOR EDIT MACRO
DTL3     EQU   DTWORK+5,3          3 BYTES FOR EDIT MACRO
DTL2     EQU   DTWORK+6,2          2 BYTES FOR EDIT MACRO
         DS    0F
BUFLEN   DC    AL4(1024*128)       128K RECORD BUFFER
OPENERR  DC    AL4(0)              OPEN ERROR CODE.
BUFPTR   DC    AL4(0)
RPLICAT  DC    AL4(0)              MOVE MODE RPL FOR BCS ACCESS.
ACBICAT  ACB   AM=VSAM,DDNAME=SYSUT1,EXLST=EXLICAT,                    X
               BUFNI=16,BUFND=16
EXLICAT  EXLST EODAD=EODICAT
PAGELEN  EQU   60
         DS    0F
MCDSPTR  DC    AL4(0)
MCDSKEY  DC    CL44' '
RPLMCDS  RPL   ACB=ACBMCDS,AM=VSAM,AREA=MCDSPTR,AREALEN=4,             X
               ARG=MCDSKEY,                                            X
               OPTCD=(KEY,DIR,LOC)
ACBMCDS  ACB   AM=VSAM,DDNAME=SYSUT2,BUFNI=16
MCDSOPEN DC    X'00'
         DS    0F
*
* THE FOLLOWING FIELDS ARE FILLED IN BY SUBROUTINES
*   VVDS: FOR VSAM OBJECTS
*   VTOC: FOR NONVSAM DATASETS
*
BLKSIZE  DC    F'0'
LRECL    DC    F'0'
TRACKS   DC    F'0'
         SPACE ,
FDBK     DC    CL4' '              RPL FEEDBACK CODE.              @122
         SPACE ,
CNTDATA  DC    PL4'0'              COUNT OF DATA CELLS READ.
CNTINDEX DC    PL4'0'              COUNT OF INDEX CELLS READ.
CNTNVSAM DC    PL4'0'              COUNT OF NVSAM CELLS READ.
CNTCLUST DC    PL4'0'              COUNT OF CLUSTER CELLS READ.
CNTGDGB  DC    PL4'0'              COUNT OF GDG BASE CELLS READ.
CNTGDGE  DC    PL4'0'              COUNT OF GDG ENTRY CELLS READ.
CNTPATH  DC    PL4'0'              COUNT OF PATH CELLS READ.
CNTAIX   DC    PL4'0'              COUNT OF ALTERNATE INDEX CELLS READ.
BCSGETS  DC    PL4'0'              GETS ISSUED AGAINST BCS.
VVDSGETS DC    PL4'0'              GETS ISSUED AGAINST VVDS'S.
CNTNF    DC    PL4'0'              NUMBER OF DATASETS NOT REALLY THERE.
CNTNOENT DC    PL4'0'              NUMBER OF GDGBASES WITH NO ENTRIES.
ONE      DC    PL1'1'
         SPACE ,
WORK     DC    D'0'
DWK1     EQU   WORK+7,1
DWK2     EQU   WORK+6,2
DWK3     EQU   WORK+5,3
DWK4     EQU   WORK+4,4
         SPACE
TOTAL    DS    0CL133
         DC    CL1' '
T1COUNT  DC    CL7' '
         DC    CL1' '
T1TEXT   DC    CL124' '                                            @120
T1NVSAM  DC    C'NONVSAM ENTRIES FOUND.'
T1CLUST  DC    C'CLUSTER ENTRIES FOUND.'
T1INDEX  DC    C'INDEX ENTRIES FOUND.'
T1DATA   DC    C'DATA ENTRIES FOUND.'
T1AIX    DC    C'ALTERNATE INDEX ENTRIES FOUND.'
T1PATH   DC    C'PATH ENTRIES FOUND.'
T1GDGB   DC    C'GENERATION DATA GROUP BASES FOUND.'
T1GDGE   DC    C'GENERATION DATA GROUP ENTRIES FOUND.'
T1BCS    DC    C'GETS ISSUED AGAINST THE BASIC CATALOG STRUCTURE.'
T1VVDS   DC    C'GETS ISSUED AGAINST VVDS(S).'
T1NF     DC    C'NONVSAM DATASETS CATALOGUED BUT NOT FOUND.'
T1NOENT  DC    C'GENERATION DATA GROUP BASES FOUND WITH NO ENTRIES.'
         SPACE ,
SEARCH   CAMLST  SEARCH,CAMDSN,CAMVOL,FORMAT1
CAMDSN   DC    CL44' '
CAMVOL   DC    CL6' '
FORMAT1  DC    XL148'00'
OBTAINRC DC    F'0'
F3CAMLST CAMLST  SEEK,CCHHR3,CAMVOL,FORMAT3
CCHHR3   DC    XL5'00'
FORMAT3  DC    XL148'00'
STARTTRK DC    F'0'
R2SAVE   DC    F'0'                SAVE R2 WHEN CHECKING FOR OPTIONAL
*                                  BCS CELLS
R6SAVE   DC    F'0'                SAVE R6 WHEN CHECKING FOR OPTIONAL
*                                  VVDS CELLS
R9SAVE   DC    F'0'                SAVE R9 WHEN HEXING VVDS DATA
SV1EXT1  DC    XL10'00'
SV1EXT2  DC    XL10'00'
SV1EXT3  DC    XL10'00'
SV3EXT4  DC    XL10'00'
SV3EXT5  DC    XL10'00'
SV3EXT6  DC    XL10'00'
SV3EXT7  DC    XL10'00'
SV3EXT8  DC    XL10'00'
SV3EXT9  DC    XL10'00'
SV3EXT10 DC    XL10'00'
SV3EXT11 DC    XL10'00'
SV3EXT12 DC    XL10'00'
SV3EXT13 DC    XL10'00'
SV3EXT14 DC    XL10'00'
SV3EXT15 DC    XL10'00'
SV3EXT16 DC    XL10'00'
         DS    0F
LOCDSN   DC    AL4(VVDSN),Y(17)
VVDSN    DC    C'SYS1.VVDS.V'
VVDSNAME DC    CL6' '
         DS    0F
LOCDDN   DC    AL4(VVDDN),Y(8)
VVDDN    DS    0CL8
         DC    C'V'
VVDDNAME DC    CL6' ',C' '
VVDSGETL EQU   32*VVDSTLEN         32 VVDS'S AT MOST
VVDSTAD  DC    A(0)                ADDRESS OF VVDSTAB
HIGHUCB  DC    Y(0)                HIGHEST UCB ADDR FOUND
RBASAVE  DC    F'0'                RBA ARG FOR VVDS GET
SHOWRBA1 DC    F'0'
SHOWRBA2 DC    F'0'
SVCOMPN  DC    CL44' '             BCS NAME. FOR COMPARE TO VVRCOMP
GDGSAVE  DC    CL44' '             GDG BASE NAME. SAVED TO DEVELOP
*                                    ENTRY NAMES FROM NAME CELLS
GDGWORK  DC    CL44' '             WORKAREA TO DEVELOP ENTRY NAME
GWORD    DC    D'0'
GWK3     EQU   GWORD+5,3
GWK2     EQU   GWORD+6,2
*
* THIS SWITCH IS USED TO DETECT THE FIRST BCS CELL READ IN. THE THEORY
* IS THAT THIS IS THE CLUSTER CELL FOR THE ICF CATALOG ITSELF. THE NAME
* OF THE FOLLOWING DATA CELL IS THE CATALOG NAME (AS IT WERE) AND
* IS INSERTED INTO THE HEADING FOR THE DELECTATION OF USERS WHO CAN'T
* REMEMBER WHAT CATALOG THEY WERE LISTING.
*
FIRST    DC    XL1'00'
* THIS SWITCH IS USED TO DETECT THE SITUATION OF A GDGBASE NOT BEING
* FOLLOWED BY ANY ENTRIES FOR THE GDG.
BASESW   DC    XL1'00'
         DS    0F
SAVECL   DC    AL4(0)              SAVE ADDR OF ICF CLUSTER CELL.
         SPACE ,
TRKCYL   DC    AL4(*-*)            TRACKS PER CYLINDER, CURRENT DS.
         SPACE ,
*
*
* DEVICE CODE NAME TABLE
*
DEVCDTBL DC    0H'0'
         DC    X'3010200E',CL6'3380',Y(15)    MLI   24APR85
         DC    X'32008003',CL6'3400-5',Y(00)  AFDSC 11MAY78
         DC    X'32108003',CL6'3400-6',Y(00)  AFDSC 11MAY78
         DC    X'78008080',CL6'3480',Y(00)    MLI   080CT86        @122
         DC    X'3010200C',CL6'3375',Y(12)    CBOC  18JAN84
         DC    X'3030200C',CL6'3375',Y(12)    CBOC  18JAN84
         DC    X'30008001',CL6'2400',Y(12)
         DC    X'30502009',CL6'3330',Y(19)
         DC    X'3050200B',CL6'3350',Y(30)    AFDSC 26MAR81
         DC    X'3050200D',CL6'3330-1',Y(19)  AFDSC 26MAR81
         DC    X'3070200D',CL6'3330-1',Y(19)  AFDSC 26MAR81
         DC    X'30702009',CL6'3330',Y(19)
         DC    X'30808001',CL6'2400-1',Y(00)
         DC    X'30C08001',CL6'2400-2',Y(00)
         DC    X'30C08003',CL6'3400-2',Y(00)  AFDSC 11MAY78
         DC    X'34008001',CL6'2400-3',Y(00)
         DC    X'34008003',CL6'3400-3',Y(00)  AFDSC 11MAY78
         DC    X'34208001',CL6'2400-4',Y(00)
         DC    X'34208003',CL6'3400-4',Y(00)  AFDSC 11MAY78
         DC    X'30582009',CL6'3330V',Y(19)   AFDSC 26MAR81
         DC    X'30782009',CL6'3330V',Y(19)   AFDSC 26MAR81
         DC    X'FFFFFFFF'
LSTENTRY EQU   *                   .
         SPACE ,
PWA      XPRDCB  DDNAME=SYSPRINT
HEADER1  XPRLDEF TEXT=HTEXT1,LENGTH=L'HTEXT1,SPB=(0,ATHOF),SPA=1
HTEXT1   DC    C'&NAME &VERSION -- LISTING OF ICF CATALOG --           X
                                            '                      @121
CATNAME  EQU   HTEXT1+44                                           @121
HEADER2  XPRLDEF TEXT=HTEXT2,LENGTH=132,SPA=2
HTEXT2   DS    0CL133
         DC    CL44'DSNAME',CL2' '
         DC    CL7'TYPE',CL2' '
         DC    CL6'VOLUME',CL2' '
         DC    CL6'UNIT',CL3' '
         DC    CL5'TRKS',CL2' '
         DC    CL5'BLKSZ',CL2' '
         DC    CL5'LRECL',CL2' '
         DC    CL8'CREATED ',CL33' '
HEADER3  XPRLDEF TEXT=HTEXT3,LENGTH=132,SPA=2
HTEXT3   DS    0CL133
         DC    CL7'TYPE',CL2' '
         DC    124C'-'
         ORG   *-124
         DC    C'CELL FORMATS '
         ORG   HTEXT3+133
RPTLINE1 DS    0CL133
         DC    CL1' '
L1DSNAME DC    CL44' ',CL2' '
L1TYPE   DC    CL7' ',CL2' '
L1VOLUME DC    CL6' ',CL2' '
L1UNIT   DC    CL6' ',CL3' '
L1TRACKS DC    CL5' ',CL2' '
L1BLKSIZ DC    CL5' ',CL2' '
L1LRECL  DC    CL5' ',CL2' '
L1CREDT  DC    CL8' ',CL33' '
RPTLINE2 DS    0CL133
         DC    CL1' '
L2TYPE   DC    CL7' ',CL2' '
L2WORK   DC    CL124' '
NUMBERS  DC    C'0123456789ABCDEF'
TRHEX    EQU   *-256
DEPTH    DC    F'0'
ENTRIES  DS    16F
EXITS    DS    16F
         SPACE ,                                                   @120
PLINE1   DC    A(0,RPTLINE1+1)    PARMS TO PRINT RPTLINE1          @120
PLINE2   DC    A(0,RPTLINE2+1)    PARMS TO PRINT RPTLINE2          @120
PLINE2A  DC    A(1,RPTLINE2+1)    SKIP ONE, THEN PRINT RPTLINE2    @120
         SPACE ,                                                   @120
PARMLIST DS    3F                 PARMLIST MAPPING FOR UCB         @120
         ORG   PARMLIST                                            @120
PARMWA   DS    F                  ADDR OF 100-BYTE WORK AREA       @120
PARMDEVT DS    F                  ADDR OF DEV TYPE TO SCAN FOR     @120
PARMUCB  DS    F                  ADDR OF RETURNED UCB             @120
         SPACE ,                                                   @120
DEVCLASS DS    CL1                DEVICE CLASS TO SEARCH FOR       @120
ADDRUCB  DS    F                  RETURNED UCB ADDR                @120
SCANSAVE DS    F                  ADDR OF SCAN SERVICE ROUTINE     @120
XASWITCH DC    X'00'              INITIALIZE SWITCH                @120
         DS    0D                 FOR ALIGNMENT                    @120
UCBWORK  DS    CL100              UCB WORK AREA                    @120
         SPACE ,                                                   @120
         DYNSPACE  ,
         SPACE ,
         TITLE 'XPRNTSUB - GENERAL PRINTING SUBROUTINE'
         SPACE
* FUNCTION/OPERATION:  THIS IS A GENERAL PRINTING SUBROUTINE TO MANAGE
*        THE DETAILS OF PAGINATION, HEADINGS, AND OUTPUT COMPRESSION
*        FOR PRINTED OUTPUT.  IT IS INVOKED FROM A PROBLEM PROGRAM VIA
*        THE MACRO 'XPRNT', WHICH HAS THE FOLLOWING CALL MODES:
*           OPEN - INITIALIZES PAGE SIZE PARAMETERS AND MAXIMUM NUMBER
*              OF OUTPUT LINES, RESETS PAGE NUMBER, CLEARS HEADING
*              LINES AND INSERTS CURRENT DATE AND TIME, INSERTS DDNAME
*              IN DCB, AND OPENS THE DATA SET.
*           MODIFY - ALTERS ANY OR ALL OF THE PARAMETERS LISTED UNDER
*              'OPEN' EXCEPT THE DDNAME.
*           SETHEAD - SUPPLIES TEXT FOR ONE OR MORE LINES TO BE USED
*              PAGE HEADINGS.
*           PRINT - DELIVERS ONE OR MORE LINES TO BE PRINTED.
*           SPACE - MOVES THE PAGE VERTICALLY A GIVEN NUMBER OF LINES.
*           EJECT - CONDITIONAL OR UNCONDITIONAL SKIP TO HEAD-OF-FORM.
*           CLOSE - CLOSES THE DATA SET.
         SPACE
* ENTRY POINTS:  EACH MODE HAS A SEPARATE ENTRY AT A FIXED OFFSET FROM
*        THE BASE ADDRESS.  ENTRYS ARE EFFECTED BY A  BAL  14,D(15)
*        (WHERE D IS A DISPLACEMENT WHICH SELECTS THE DESIRED MODE) AND
*        ASSUMES THAT REGISTER 13 ADDRESSES A STANDARD 18-WORD SAVE
*        AREA.
         SPACE
* INPUT:  ON ENTRY, REG 0 POINTS TO A WORK AREA FOR THE DATA SET, WHICH
*        IS DESCRIBED IN THIS CODING BY THE DUMMY SECTION 'WORKAREA'.
*        REG 1 POINTS TO A PARAMETER LIST OF A FORM APPROPRIATE TO THE
*        CALL MODE.  THESE LISTS ARE EITHER DESCRIBED BY DUMMY SECTIONS
*        OR ARE STANDARD VARIABLE-LENGTH ADDRESS LISTS.
         SPACE
         SPACE
* OUTPUT:  PRINT LINES AND SPACE CONTROL RECORDS ARE DELIVERED VIA QSAM
*        TO A SEQUENTIAL DATA SET.  EACH LINE IS REDUCED TO ITS MIN-
*        IMUM LENGTH BY TRUNCATING TRAILING BLANKS.
         SPACE
* DATA SETS:  THE OUTPUT DATA SET IS SEQUENTIAL, ARRANGED FOR BLOCKED
*        FORMAT V RECORDS USING MACHINE CONTROL CHARACTERS APPROPRIATE
*        TO 1403 OR 1404 PRINTERS.  THE DDNAME IS SUPPLIED BY THE
*        'OPEN' CALL; THE STANDARD VALUE IS 'SYSPRINT'.
         SPACE
* EXTERNAL ROUTINES:  CALLS 'XDATEDIT' TO FORMAT THE DATE FOR THE
*        PAGE HEADING LINE.
         SPACE
* EXITS - NORMAL:  RETURNS VIA REG 14 WITH RETURN CODE 0 IN REG 15.
*        THE CURRENT PAGE NUMBER (IN BINARY) IS IN REG 0 AND THE BINARY
*        NUMBER OF LINES REMAINING ON THE CURRENT PAGE IS IN REG 1.
*        IF AN OPEN CALL CANNOT OPEN THE DCB, THE RETURN CODE IS 4.
         SPACE
* EXITS - ERROR:  ERRONEOUS CALLS RESULT IN AN 'ABEND' WITH ONE OF THE
*        FOLLOWING COMPLETION CODES:
*           4000 - ROUTINE WAS ILLEGALLY ENTERED AT ITS BASE ADDRESS.
*           4002 - A CALL MODE OTHER THAN 'OPEN' WAS DIRECTED TO A DATA
*              SET WHICH WAS NOT OPEN.
*           4003 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LARGE A PAGE WIDTH.
*           4004 - 'OPEN' OR 'MODIFY' SPECIFIED TOO LONG A PAGE.
*           4005 - 'PRINT' OR 'SETHEAD' SPECIFIED A LINE WHOSE TEXT
*              LENGTH PLUS OFFSET EXCEEDED THE PAGE WIDTH.
*           4006 - THE MAXIMUM NUMBER OF OUTPUT LINES WAS EXCEEDED.
*           4007 - SYNCHRONOUS I/O ERROR.
         SPACE
* TABLES/WORK AREAS:  THE CALL PARAMETER LISTS, WORK AREA, AND PRINT
*        LINE DESCRIPTOR BLOCK ARE ALL DESCRIBED BY DUMMY SECTIONS
*        AT THE END OF THE PROGRAM.
         SPACE
* ATTRIBUTES:  REENTRANT, READ-ONLY.  WILL HANDLE ANY NUMBER OF DATA
*        SETS SIMULTANEOUSLY, USING A SEPARATE WORK AREA FOR EACH.
         SPACE
* OPERATING ENVIRONMENT:  RUNS UNDER OPERATING SYSTEM/360, USING
*        QSAM DATA MANAGEMENT WITH LOCATE-MODE PUT MACROS AND SIMPLE
*        BUFFERING.  ASSUMES OPTION 6A OR 6B FOR TIME OF DAY.
         SPACE
* NOTES:  NONE.
         EJECT
XPRNTSUB CSECT
         SPACE 2
* REGISTER ASSIGNMENTS:
         SPACE 2
* N.B.  REGISTER GROUPS 'RWA,RWB,RWC,RWD' AND 'RLPEXIT,RPARM' MUST BE
* KEPT IN ORDER FOR LM AND STM ORDERS.
         SPACE
RWA      EQU   2                   GENERAL WORK REG
RWB      EQU   3                   GENERAL WORK REG
RWC      EQU   4                   GENERAL WORK REG
RWD      EQU   5                   GENERAL WORK REG
RSPACE   EQU   6                   NUMBER OF LINES TO SPACE
RBAL     EQU   7                   NUMBER OF LINES LEFT ON PAGE
RLPEXIT  EQU   8                   EXIT FROM LIST PROCESSING ROUTINE
RPARM    EQU   9                   CALL PARAMETER LIST ADDR
RPLD     EQU   10                  PLD BLOCK BASE
RWKAREA  EQU   11                  BASE REGISTER FOR WORK AREA
RBASE    EQU   12                  BASE REGISTER FOR CODING
RRET     EQU   14                  STANDARD RETURN ADDR
         SPACE
* MASKS FOR CONTROL BYTE "SWITCHES":
         SPACE
HOFBIT   EQU   X'80'               PAGE IS AT PHYSICAL HEAD-OF-FORM
NOSKBIT  EQU   X'40'               DISALLOW EJECT DURING HEAD PRINTING
TXT1BIT  EQU   X'20'               ON FOR FIRST TEXT LINE ON PAGE
HD1BIT   EQU   X'10'               ON FOR FIRST HEAD LINE WITH PAGE
*                                  NO, ETC
SP0BIT   EQU   X'08'               LAST LINE SPACED 0
         SPACE 2
EJFORCE  EQU   255                 SPACING QUANTITY TO FORCE PAGE EJECT
OPENBIT  EQU   X'10'               TO TEST 'DCBOFLGS' FOR SUCCESSFUL
*                                  OPEN
MAXLNGTH EQU   254                 MAXIMUM PAGE LENGTH
MAXWIDTH EQU   132                 MAXIMUM PAGE WIDTH
DEFBLKSZ EQU   1692                DEFAULT DCB BLOCK SIZE
         EJECT
**********************
* ENTRY AND PROLOGUE *
**********************
         SPACE
* ENTER FROM THE CALLING SEQUENCE VIA THE INSTRUCTION "BAL 14,X(0,15)".
* REGISTER 15 IS SET TO THE BASE OF THE ROUTINE AND THE DISPLACEMENT
* "X" SELECTS THE ENTRY POINT.  EACH ENTRY SAVES REGISTERS, LOADS THE
* ADDRESS OF THE APPROPRIATE SUBROUTINE, AND GOES TO A COMMON
* PROLOGUE.  NOTE THAT AN ATTEMPT TO ENTER AT THE BASE RESULTS IN
* AN ABEND.
         SPACE 2
BASEADDR B     20(0,R15)           BRANCH AROUND MODULE IDENTIFIER
         DC    AL1(15)             LENGTH OF IDENTIFIER
         DC    CL15'XPRNTSUB-028214'
         STM   R14,R12,12(R13)     SAVE CALLER'S REGISTERS
         SR    R1,R1               SET ABEND COMPLETION CODE
         LR    RBASE,R15           SET BASE REG FOR ABEND ROUTINE
         USING BASEADDR,RBASE
         B     ABEND
         DROP  RBASE
         SPACE 2
* ENTRY POINTS FOR VARIOUS FUNCTIONS, AT 12-BYTE INTERVALS BEGINNING
* AT BASEADDR+32.  EACH LOADS "RWA" WITH THE ADDRESS OF THE SUBROUTINE
* TO GO TO AFTER EXECUTING "PROLOGUE".
         SPACE
         ORG   XPRNTSUB+32
         USING BASEADDR,R15
         SPACE
PRENTRY  STM   R14,R12,12(R13)     PRINT
         LA    RWA,PRPROC
         B     PROLOGUE
SPENTRY  STM   R14,R12,12(R13)     SPACE
         LA    RWA,SPPROC
         B     PROLOGUE
OPENTRY  STM   R14,R12,12(R13)     OPEN
         LA    RWA,OPPROC
         B     PROLOGUE
CLENTRY  STM   R14,R12,12(R13)     CLOSE
         LA    RWA,CLPROC
         B     PROLOGUE
SHENTRY  STM   R14,R12,12(R13)     SETHEAD
         LA    RWA,SHPROC
         B     PROLOGUE
EJENTRY  STM   R14,R12,12(R13)     EJECT
         LA    RWA,EJPROC
         B     PROLOGUE
MDENTRY  STM   R14,R12,12(R13)     MODIFY
         LA    RWA,MDPROC
         B     PROLOGUE
         SPACE 2
* PROLOGUE.  SET UP BASE REGISTERS FOR CODING AND WORK AREA.  CHAIN
* SAVE AREAS IN STANDARD FASHION.  LOAD "RBAL" WITH CURRENT PAGE
* BALANCE AND "RPARM" WITH THE CALLING PARAMETER LIST ADDRESS.
         SPACE
PROLOGUE LR    RBASE,R15           LOAD CODING BASE REG
         DROP  R15
         USING BASEADDR,RBASE
         SPACE
         LR    RWKAREA,R0          BASE REG FOR WORK AREA
         USING WORKAREA,RWKAREA
         SPACE
         LR    RWB,R13             ADDR OF CALLER'S SAVE AREA
         LA    R13,SAVEAREA        ADDR OF OUR SAVE AREA
         ST    R13,8(RWB)          CHAIN TO US FROM CALLER
         ST    RWB,SAVEAREA+4      CHAIN TO CALLER FROM US
         SPACE
         LR    RPARM,R1            LOAD PARAMETER LIST ADDR
         LH    RBAL,PAGEBAL        LOAD PAGE LINE COUNT BALANCE
         MVC   DCBSYNAD(3),=AL3(SYNAD)  PUT ERROR ROUTINE ADDRESS IN
*                                  DCB
         SPACE
         TM    DCBOFLGS,OPENBIT    MAKE SURE DATA SET IS OPEN
         BCR   1,RWA               BRANCH IF OPEN
         CL    RWA,=A(OPPROC)      IF NOT, ONLY OPEN CALL ALLOWED
         BCR   8,RWA               BR IF OPEN CALL
         LA    R1,2                ERROR CODE 2, GO TO ABEND
         SPACE 3
* ABEND ROUTINE FOR SERIOUS ERRORS.  ENTER WITH ERROR NUMBER IN R1.
* ADD DECIMAL 4000 FOR USER CONPLETION CODE AND ISSUE 'ABEND' WITH DUMP
         SPACE
         CNOP  2,4                 ALIGN CONSTANT FOLLOWING SVC
ABEND    AL    R1,*+6              LOAD ABEND CODES
         SVC   13                  ISSUE ABEND SVC
         DC    X'80'               'DUMP' BIT FOR ABEND
         DC    AL3(4000)           BASE FOR COMPLETION CODE
         EJECT
************
* EPILOGUE *
************
         SPACE
* ALL MODES RETURN TO THE CALLER VIA THIS ROUTINE.  IT EXITS WITH
* THE RETURN CODE IN REGISTER 15, THE PAGE NUMBER IN REGISTER 0, AND
* THE NUMBER OF LINES REMAINING ON THE PAGE IN REGISTER 1.
         SPACE 2
EXIT4    LA    R15,4               SET RETURN CODE 4
         B     EXIT
         SPACE
EXIT0    SR    R15,R15             SET RETURN CODE 0
         SPACE
EXIT     LH    R0,PAGENO           LOAD CURRENT PAGE NUMBER
         LR    R1,RBAL             LOAD NUMBER OF LINES LEFT
         STH   RBAL,PAGEBAL        SAVE PAGE BALANCE
         XC    DCBSYNAD(3),DCBSYNAD  CLEAR ERROR ROUTINE ADDRESS
         SPACE
         L     R13,SAVEAREA+4      ADDRESS OF CALLER'S SAVE AREA
         L     R14,12(R13)         LOAD RETURN ADDRESS
         LM    R2,R12,28(R13)      RESTORE CALLER'S REGISTERS
         MVI   12(R13),X'FF'       SET RETURN INDICATION
         BR    R14                 RETURN TO CALLER
         EJECT
******************
* PRINT FUNCTION *
******************
         SPACE
* PRINT LINE DELIVERY CALL.  THE PARAMETER LIST IS A VARIABLE-LENGTH
* LIST OF ADDRESSES, THE LAST OF WHICH IS NEGATIVE (I.E. BIT 0 IS A 1).
* EACH ADDRESS POINTS TO A PLD DESCRIBING A LINE TO BE PRINTED.  CALL
* THE GENERAL LIST PROCESSING ROUTINE TO DO THE DIRTY WORK.
         SPACE 2
PRPROC   BAL   RLPEXIT,LISTPROC    INVOKE LIST PROCESSOR
         SPACE
         B     EXIT0               EXIT TO CALLER
         EJECT
******************
* SPACE FUNCTION *
******************
         SPACE
* CALL TO MOVE THE PAPER A SPECIFIED NUMBER OF LINES.  IF THE NUMBER
* OF LINES EXCEEDS THE CURRENT PAGE BALANCE, AN EJECT RESULTS, UNLESS
* SUPPRESSED BY THE 'SPNOEJ' BIT IN THE PARAMETER LIST.  IF THE PAGE
* IS AT HEAD-OF-FORM, SPACING IS SUPPRESSED UNLESS THE 'SPATHOF' BIT
* IS SET IN THE PARAMETER LIST.  IN THE LATTER CASE, THE PAGE HEADINGS
* WILL BE PRINTED BEFORE THE SPACING IS EXECUTED.
         SPACE 2
         USING SPPARM,RPARM        ADDRESSING FOR PARM LIST
         SPACE
SPPROC   TM    SWITCHES,HOFBIT     TEST IF AT HEAD-OF-FORM
         BZ    SPSUBTR             BR IF NOT
         TM    SPCOND,SPATHOF      IS SPACE ALLOWED AT HOF?
         BZ    EXIT0               EXIT IF NOT
         BAL   RRET,HEADPRNT       IF SO, PRINT HEADINGS FIRST
         SPACE
SPSUBTR  SR    RSPACE,RSPACE
         IC    RSPACE,SPQUAN       LOAD SPACING AMOUNT
         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE
         SPACE
         BP    SPMOVE              BRANCH IF BAL STILL > 0
         TM    SPCOND,SPNOEJ       TEST IF EJECT ALLOWED
         BO    SPMOVE              BRANCH IF NOT
         LA    RSPACE,EJFORCE      IF ALLOWED, FORCE EJECT
         SPACE
SPMOVE   BAL   RWA,MOVE            CALL PAPER MOVING SUB
         B     EXIT0               EXIT TO CALLER
         SPACE
         DROP  RPARM
         EJECT
******************
* EJECT FUNCTION *
******************
         SPACE
* CALL TO MOVE THE PAPER TO HEAD-OF-FORM.  IF THE PAGE IS ALREADY
* THERE, THE EJECT IS NOT EXECUTED UNLESS THE 'EJATHOF' BIT IN THE
* PARAMETER LIST IS ON.  IN THE LATTER CASE, A SKIP IS EXECUTED WITHOUT
* PRINTING ANY HEADINGS, RESULTING IN A BLANK PAGE.  IF THE MASK BITS
* IN THE 'EJCOND' PARAMETER ARE NOT ALL ONES, A CONDITIONAL EJECT IS
* REQUESTED.  THE PAGE BALANCE IS COMPARED AGAINST THE TEST QUANTITY
* 'EJQUAN' IN THE PARAMETER LIST, THEN THE DECISION TO EJECT OR NOT
* IS MADE WITH A 'BC' ORDER USING THE 'EJCOND' BITS AS A MASK.
         SPACE 2
         USING EJPARM,RPARM        FOR PARM LIST ADDRESSING
         SPACE
EJPROC   TM    SWITCHES,HOFBIT     TEST IF AT HOF
         BZ    EJTEST              BR IF NOT
         TM    EJCOND,EJATHOF      IF SO, IS EJECT ALLOWED?
         BZ    EXIT0               IF NOT, EXIT
         SPACE
EJTEST   SR    R0,R0
         IC    R0,EJQUAN           LOAD TEST QUANTITY
         IC    R1,EJCOND           GET CONDITIONAL TEST MASK
         N     R1,=XL4'000000F0'   KEEP BITS 24-27 ONLY
         CR    RBAL,R0             COMPARE BALANCE WITH TEST QUAN
         EX    R1,EJBC             EXECUTE BC WITH MASK FROM PARM
         B     EXIT0               EXIT IF CONDITION NOT MET
         SPACE
EJMOVE   LA    RSPACE,EJFORCE      TO FORCE EJECT
         BAL   RWA,MOVE            CALL PAPER MOVER SUB
         B     EXIT0               EXIT TO CALLER
         SPACE 2
EJBC     BC    0,EJMOVE            BRANCH IF EJECT REQUIRED
         SPACE
         DROP  RPARM
         EJECT
*****************
* OPEN FUNCTION *
*****************
         SPACE
* THIS MUST BE THE FIRST CALL FOR A NEW DATA SET.  IT SETS THE DDNAME
* IN THE DCB AND OPENS THE DATA SET.   ALL COUNTERS AND SWITCHES ARE
* SET TO THEIR NOMINAL VALUES BEFORE PROCESSING ANY OPTIONS WHICH
* MAY HAVE BEEN SUPPLIED WITH THE CALL.  THE PAGE BALANCE IS SET TO
* ZERO, BUT THE PAGE IS NOT MOVED.  THE PROGRAMMER SHOULD NORMALLY
* ISSUE AN 'EJECT' CALL BEFORE BEGINNING HIS OUTPUT.
         SPACE
* IF THE DATA SET IS ALREADY OPEN, THE DDNAME IS IGNORED, THE NOMINAL
* OPTIONS ARE SET, THEN THIS CALL IS TREATED EXACTLY AS IF IT WERE A
* 'MODIFY' CALL.
         SPACE 2
         USING OMPARM,RPARM
         SPACE
OPPROC   MVC   PAPARMS(DEFSIZE),DEFAULTS  SET STANDARD OPTIONS
         MVI   HLTEXT,C' '         CLEAR HEADING TEXT
         MVC   HLTEXT+1(HLTXTLNG-1),HLTEXT
         SPACE
         TIME  DEC                 GET CURRENT DATE & TIME
         STM   R0,R1,HPRSAVE       SAVE TIME AND DATE
         SPACE
* NOW IF DATA SET IS ALREADY OPEN, GO TO 'MDPROC'.  OTHERWISE, INSERT
* DDNAME AND OPEN IT.
         SPACE
         TM    DCBOFLGS,OPENBIT    TEST IF OPEN
         BO    OPJOIN              BR TO 'MDPROC' IF OPEN
         MVC   DCBDDNAM(8),OMDDNAME  INSERT DDNAME INTO CLOSED DCB
         MVC   DCBEXLST(3),=AL3(EXLST)  INSERT ADDRESS OF EXIT LIST
         SPACE
         MVI   DWORK,X'80'         SET END-OF-LIST BIT
         OPEN  (PRINTDCB,(OUTPUT,LEAVE)),MF=(E,DWORK)
         SPACE
         XC    DCBEXLST(3),DCBEXLST  CLEAR ADDRESS OF EXIT LIST
         TM    DCBOFLGS,OPENBIT    TEST FOR SUCCESSFUL OPEN
         BO    OPJOIN              TO 'MDPROC' IF O.K.
         B     EXIT4               EXIT WITH RC=4 IF OPEN FAILS
         SPACE
         DROP  RPARM
         EJECT
* DCB EXIT ROUTINE FOR OPEN.  SET BLOCK SIZE TO THE DEFAULT VALUE IF
* NOT SPECIFIED IN DS LABEL OR DD CARD.
         SPACE
EXLST    DS    0F                  EXIT LIST, ON BOUNDARY
         DC    X'85'
         DC    AL3(DCBMOD)
         SPACE
DCBMOD   LH    RWA,DCBBLKSZ        LOAD BLOCK SIZE
         LTR   RWA,RWA             TEST IF ZERO
         BNZ   DCBNZ               BRANCH IF NOT ZERO
SETDEF   LA    RWA,DEFBLKSZ        SET DEFAULT BLOCK SIZE
         STH   RWA,DCBBLKSZ        STORE IN DCB
         BR    R14                 RETURN TO OPEN ROUTINE
DCBNZ    CH    RWA,=H'141'         TEST FOR MINIMUM BLOCKSIZE
         BL    SETDEF              USE DEFAULT IF TOO LOW
         BR    R14                 RETURN TO OPEN IF OK
         EJECT
*******************
* MODIFY FUNCTION *
*******************
         SPACE
* THIS CALL MAY ALTER ANY  OR ALL OF THE FOLLOWING: DATE, TIME, PAGE
* NUMBER, PAGE LENGTH, PAGE WIDTH, MAXIMUM NUMBER OF OUTPUT LINES.
* THE NEW VALUES ARE PRESENTED IN A PARAMETER LIST.  IF A PARAMETER IS
* ZERO, THE CORRESPONDING QUANTITY IS NOT ALTERED.
         SPACE
* THE DATE AND TIME FIELDS MAY BE SUPPLIED BY THE 'OPEN' ROUTINE,
* WHICH JOINS THIS CODING AT 'OPJOIN'.  IN THAT CASE, THE VALUES
* INSERTED BY 'OPEN' ARE USED UNLESS OVERRIDDEN BY THE PARAMETER LIST.
         SPACE
         USING OMPARM,RPARM
         SPACE
MDPROC   SR    R0,R0               GENERATE TWO ZERO WORDS
         SR    R1,R1
         STM   R0,R1,HPRSAVE       SET DATE & TIME FIELDS TO ZERO
         SPACE
* ENTER HERE FROM 'OPEN'.  THE OBJECT OF THE FOLLOWING IS TO GET THE
* ACTUAL TIME AND DATE (IN PACKED DECIMAL) INTO 'HPRSAVE' AND
* 'HPRSAVE+4', RESPECTIVELY.  THOSE FIELDS MAY HAVE BEEN FILLED IN BY
* THE OPEN ROUTINE, OR THEY MAY HAVE BEEN SET TO ZEROS BY 'MDPROC'
* ABOVE.  NOW WE SEE IF ADDRESSES FOR TIME AND/OR DATE VALUES WERE
* PROVIDED IN THE PARAMETER LIST, AND TRANSFER THE VALUES IF SO.
         SPACE
OPJOIN   LM    RWA,RWB,OMTIMEAD    LOAD TIME & DATE ADDRS FROM PARM
         LTR   RWA,RWA             TEST FOR TIME ADDR SUPPLIED
         BZ    NOTIME              BRANCH IF ZERO
         MVC   HPRSAVE(4),0(RWA)   GET TIME AS DECIMAL 'HHMMSSTH'
NOTIME   LTR   RWB,RWB             TEST IF DATE ADDR SUPPLIED
         BZ    DATEEDIT            BR IF NOT
         MVC   HPRSAVE+4(4),0(RWB)  GET DECIMAL DATE AS '00YYDDD+'
         SPACE
* IF THE DATE VALUE IS NOT ZERO, EDIT INTO THE HEADING LINE TEXT.  BOTH
* THE DAY NUMBER AND THE MONTH-DAY-YEAR FORM ARE USED.
         SPACE
DATEEDIT LM    RWA,RWB,HPRSAVE     LOAD TIME & DATE FOR TESTING
         LTR   RWB,RWB             TEST IF DATE WAS GIVEN
         BZ    TIMEEDIT            BRANCH IF ZERO
         SPACE
         MVC   HLDAY(4),=C'DAY='   INSERT DAY NUMBER
         UNPK  HLDAY+4(3),HPRSAVE+6(2)  UNPACK DAY NUMBER
         OI    HLDAY+6,X'F0'       TIDY UP SIGN BITS
         SPACE
         ST    RWB,DWORK+4         STORE DATE ARG FOR EDIT RTNE
         LA    R1,DWORK            CONSTRUCT ONE-WORD PARM LIST
         ST    R1,HPRSAVE+4        FOR XDATEDIT CALL
         LA    R1,HPRSAVE+4        LOAD PARM LIST ADDRESS
         L     R15,=V(XDATEDIT)    LOAD ADDRESS OF DATE EDIT RTNE
         BALR  R14,R15             TO EDIT DATE AS 'MM/DD/YY'
         MVC   HLDATE(8),DWORK     INSERT RESULT IN HL TEXT
         SPACE
* EDIT TIME IN HOURS AND MINUTES, IF SUPPLIED.
         SPACE
TIMEEDIT LTR   RWA,RWA             TEST IF TIME GIVEN
         BZ    TSTPGNO             BR IF ZERO
         SRL   RWA,4               ADD LEADING ZERO TO TIME
         ST    RWA,HPRSAVE         STORE TIME IN WORK LOC
         MVC   HLTIME(7),=X'402120207A2020'  EDIT CONTROL CHAR
         ED    HLTIME(7),HPRSAVE   EDIT INTO ALPHA
         SPACE
* MODIFY PAGE NUMBER.  VALUE GIVEN IS DECREMENTED BY ONE, SINCE IT IS
* INCREMENTED BEFORE USE.
         SPACE
TSTPGNO  LH    RWA,OMPAGENO        GET VALUE FROM PARM LIST
         LTR   RWA,RWA             TEST IF ZERO
         BZ    TSTPGWID            BR IF ZERO
         BCTR  RWA,0               DECREMENT BY 1
         STH   RWA,PAGENO          STORE
         SPACE
* MODIFY PAGE WIDTH, TESTING FOR MAXIMUM ALLOWED.
         SPACE
TSTPGWID SR    RWA,RWA
         IC    RWA,OMPAGWID        GET WIDTH FROM PARM LIST
         LTR   RWA,RWA             TEST IF ZERO
         BZ    TSTPGLNG            BRANCH IF SO
         CLI   OMPAGWID,MAXWIDTH   TEST MAXIMUM SIZE
         BNH   PGWIDOK
         LA    R1,3                ERROR, TOO LARGE
         B     ABEND
PGWIDOK  STH   RWA,PAGWIDTH
         SPACE
* MODIFY PAGE LENGTH, TESTING FOR MAXIMUM VALUE.
         SPACE
TSTPGLNG SR    RWA,RWA
         IC    RWA,OMPAGLNG        GET FROM PARM LIST
         LTR   RWA,RWA             TEST IF SUPPLIED
         BZ    TSTMAXLN            BR IF NOT
         CLI   OMPAGLNG,MAXLNGTH   TEST FOR LEGAL VALUE
         BNH   PGLNGOK
         LA    R1,4                ERROR, ABORT
         B     ABEND
PGLNGOK  STH   RWA,PAGELNG         STORE
         SPACE
* MODIFY PRINT LINE LIMIT COUNTER.
         SPACE
TSTMAXLN L     RWA,OMMAXLIN        GET FROM PARM LIST
         LTR   RWA,RWA             TEST IF SUPPLIED
         BZ    EXIT0               EXIT IF NOT
         ST    RWA,MAXLINES        STORE
         B     EXIT0               EXIT TO CALLER
         SPACE
         DROP  RPARM
         EJECT
********************
* SETHEAD FUNCTION *
********************
         SPACE
* THIS CALL PRESENTS A LIST OF LINES WHICH WILL BE USED AS PAGE HEADING
* AND SUB-HEADING LINES.  THE PARAMETER LIST IS A VARIABLE-LENGTH LIST
* OF PLD ADDRESSES, EXACTLY AS FOR 'PRINT' CALLS.  THE FIRST LINE WILL
* HAVE ADDED TO ITS RIGHT END THE DATE, TIME, AND PAGE NUMBER.
* HOWEVER, IF ITS LENGTH EXCEEDS 98 BYTES, IT WILL OVERLAY THOSE
* FIELDS.  THE SECOND AND SUBSEQUENT LINES WILL BE PRINTED NORMALLY.
* NOTE THAT THESE LINES ARE NOT PRINTED WHEN THE PAGE IS EJECTED, BUT
* WHEN THE LINE WHICH WILL BE FIRST ON THE NEW PAGE IS DELIVERED, THUS
* ALLOWING THE HEADINGS TO BE ALTERED AFTER DELIVERY OF THE LAST LINE
* ON THE PRECEDING PAGE.  THE ADDRESS OF THE PARAMETER LIST IS SAVED
* BY THE PRINTING ROUTINE, BUT THE PARAMETER LIST, THE PLD'S TO WHICH
* IT POINTS, AND THE LINE TEXTS TO WHICH THEY POINT, MUST BE PRESERVED
* BY THE PROBLEM PROGRAM FOR AS LONG AS THEY ARE IN USE, SINCE THEY
* ARE REFERRED TO AT THE BEGINNING OF EACH NEW PAGE.  EACH CALL TO
* TO 'SETHEAD' SUPERSEDES THE EFFECT OF THE PREVIOUS CALL.  A CALL WITH
* A PARAMETER LIST ADDRESS OF ZERO INDICATES THAT NO HEADINGS ARE
* PROVIDED BY THE PROBLEM PROGRAM, AND ONLY THE PAGE NUMBER, DATE, AND
* TIME WILL BE PRINTED, WITH A STANDARD SPACING OF THREE.
         SPACE 2
SHPROC   LTR   RPARM,RPARM         TEST FOR NULL LIST ADDR
         BNZ   SHOK                BRANCH IF NON-ZERO
         LA    RPARM,NOHDLIST      ADDRESS OF PLD FOR BLANK LINE
SHOK     ST    RPARM,HEADLIST      STORE ADDR OF HEADING PARMS
         B     EXIT0               EXIT
         EJECT
******************
* CLOSE FUNCTION *
******************
         SPACE
* THIS CALL CLOSES THE PRINTER DATA SET.  IT DOES NOT MOVE THE PAGE
* OR ALTER ANY SWITCHES OR VARIABLES EXCEPT THE DCB ITSELF.
* AFTER CLOSING THE DCB, IT RELEASES THE PRINT BUFFERS.
         SPACE 2
CLPROC   TM    DCBOFLGS,OPENBIT    IS DCB OPEN NOW?
         BZ    EXIT0               EXIT IF ALREADY CLOSED
         MVI   DWORK,X'80'         SET END-OF-LIST BIT
         CLOSE (PRINTDCB,LEAVE),MF=(E,DWORK)
         SPACE
         FREEPOOL  PRINTDCB        FREE THE BUFFER CORE
         SPACE
         B     EXIT0               EXIT TO CALLER
         EJECT
************
* LISTPROC *
************
         SPACE
* THIS ROUTINE PROCESSES A LIST OF PLD ADDRESSES, FORMATTING EACH PRINT
* LINE AND PERFORMING THE NECESSARY PRE- AND POST-SPACING OPERATIONS.
* IT IS ENTERED WITH 'RPARM' POINTING TO THE LIST OF ADDRESSES AND
* 'RLPEXIT' CONTAINING THE EXIT ADDRESS.  IT MAY DISCOVER THAT ITS
* SPACING OPERATIONS HAVE BROUGHT THE PAGE TO HEAD OF FORM, REQUIRING
* THAT THE HEADING AND SUB-HEADING LINES BE PRINTED.  WHEN THIS OCCURS,
* IT BRANCHES TO 'HEADPRNT', WHICH SAVES 'RPARM' AND 'RLPEXIT' AND
* REENTERS THIS ROUTINE WITH AN ADDRESS LIST FOR THE HEADING LINES.
* (WHEN THIS SECOND-LEVEL CALL IS MADE, SWITCH 'NOSKPBIT' IS ON,
* PREVENTING ANY FURTHER PAGE SKIPS AND ELIMINATING THE POSSIBILITY OF
* YET ANOTHER CALL TO 'HEADPRNT'.)  AFTER THE HEADINGS ARE PRINTED,
* THE ORIGINAL VALUES ARE RETURNED TO 'RPARM' AND 'RLPEXIT' AND
* PROCESSING OF THE LIST OF TEXT LINES PROVIDED BY THE CALLER IS
* CONTINUED.
         SPACE 2
         USING PLDBLOCK,RPLD       TO ADDRESS PLD BLOCKS
         SPACE
LISTPROC L     RPLD,0(RPARM)       LOAD A PLD BLOCK ADDRESS
         SPACE
* IF PAGE IS NOW AT HEAD OF FORM, EXECUTE 'HEADPRNT'.
         SPACE
         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN
         TM    SWITCHES,HOFBIT     SEE IF HEAD-OF-FORM FLAG IS ON
         BO    HEADPRNT            EXIT IF SO
         SPACE 2
* TEST WHETHER WE ARE AT THE FIRST TEXT LINE ON A PAGE, AND, IF SO,
* WHETHER PRE-SPACING IS ALLOWED IN THAT POSITION.  IF NOT, BYPASS
* PRE-SPACING ALTOGETHER.
         SPACE
         TM    SWITCHES,TXT1BIT    TEST IF FIRST TEXT LINE
         BZ    PRSUBTR             BRANCH IF NOT
         TM    PLDFLAGS,PRHOFBIT   TEST IF ALLOW SKIP AT HOF
         BZ    POSTSP              SKIP PRESPACING IF NOT
         SPACE
* DECREMENT THE PAGE BALANCE BY THE AMOUNT TO BE SPACED.
         SPACE
PRSUBTR  SR    RSPACE,RSPACE
         IC    RSPACE,PLDSPB       LOAD AMOUNT TO SPACE
         SR    RBAL,RSPACE         DECREMENT PAGE BALANCE
         SPACE
* IF SKIPPING IS ALLOWED BY BOTH THE SYSTEM AND THE USER, TEST THE
* BALANCE AND FORCE A PAGE SKIP IF <= ZERO.
         SPACE
         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIP
         BO    PREMOVE             BRANCH IF NOT
         TM    PLDFLAGS,PRSKPBIT   TEST IF USER ALLOWS SKIP
         BO    PREMOVE             BRANCH IF NOT
         LTR   RBAL,RBAL           TEST PAGE BALANCE
         BP    PREMOVE             BRANCH IF SOME LINES LEFT
         LA    RSPACE,EJFORCE      FORCE A PAGE SKIP
         SPACE
* MOVE THE PAGE THE NUMBER OF LINES IN 'RSPACE'.
         SPACE
PREMOVE  BAL   RWA,MOVE            TO PAPER MOVING SUBROUTINE
         SPACE
* IF THAT MOVING PUT US AT HEAD-OF-FORM, PRINT THE HEADINGS.
         SPACE
         LA    RRET,LISTPROC       EXIT FROM HEADPRNT STARTS AGAIN
         TM    SWITCHES,HOFBIT     TEST HEAD-OF-FORM BIT
         BO    HEADPRNT            EXIT IF AT HEAD
         SPACE 2
* NOW CONSIDER THE SPACING TO BE PERFORMED WHEN THE TEXT OF THE LINE
* IS PRINTED.  BEGIN BY COMPUTING THE NEW PAGE BALANCE.
         SPACE
POSTSP   SR    RSPACE,RSPACE
         IC    RSPACE,PLDSPA       LOAD AMOUNT TO SPACE AFTER PRINT
         SR    RBAL,RSPACE         COMPUTE NEW PAGE BALANCE
         SPACE
* IF THE SYSTEM AND USER BOTH ALLOW SKIPPING, TEST THE PAGE BALANCE,
* AND FORCE A SKIP IF <= ZERO.
         SPACE
         TM    SWITCHES,NOSKBIT    TEST IF SYSTEM ALLOWS SKIPPING
         BO    GETPRCC             BRANCH IF NOT
         TM    PLDFLAGS,SPSKPBIT   TEST IF USER ALLOWS SKIPPING
         BO    GETPRCC             BRANCH IF NOT
         LTR   RBAL,RBAL           TEST FOR PAGE END
         BP    GETPRCC             BRANCH IF SOME LINES LEFT
         LA    RSPACE,EJFORCE      FORCE PAGE SKIP
         SPACE
* NOW CONSTRUCT THE PRINT LINE IN AN OUTPUT BUFFER.  IN THE INTERESTS
* OF SAVING BUFFER SPACE, THE CALLER'S TEXT IS SCANNED FROM THE RIGHT
* TO REDUCE ITS NOMINAL LENGTH BY THE NUMBER OF RIGHT BLANKS.  IN THE
* EXTREME CASE THAT IT IS ENTIRELY BLANK, BYPASS PRINTING ALTOGETHER
* AND MERELY SPACE.  IF THIS IS TO BE THE FIRST HEADING LINE OF THE
* PAGE ('HD1BIT' SET), SCANNING IS OMITTED, THE RECORD LENGTH IS SET TO
* THE PAGE WIDTH, AND THE DATE, TIME, AND PAGE NUMBER ARE INSERTED.
         SPACE
GETPRCC  DS    0H
         SR    RWA,RWA
         IC    RWA,PLDLNGTH        LOAD NOMINAL LENGTH OF TEXT
         SR    RWB,RWB
         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET
         SPACE
         LA    R0,0(RWA,RWB)       LINE LENGTH = TEXT + OFFSET
         CH    R0,PAGWIDTH         TEST AGAINST PAGE WIDTH
         BNH   TSTHD1              BR IF OK
         LA    R1,5                ERROR, LINE TOO LONG
         B     ABEND
         SPACE
TSTHD1   TM    SWITCHES,HD1BIT     TEST IF FIRST HEADING LINE
         BZ    BLNKSCAN            BR IF NOT
         LH    RWB,PAGWIDTH        SET RECORD LENGTH AS PAGE WIDTH
         B     GETBUF              SKIP BLANK SCANNING
         SPACE
* SET UP A 'BXH' FOR SCAN.  R0 IS INCREMENT, R1 IS COMPARAND, RWA
* VARIABLE.
         SPACE
BLNKSCAN LH    R0,=H'-1'           INCREMENT IS MINUS 1
         L     R1,PLDTXTAD-1       LOAD TEXT ADDRESS
         LA    R1,0(R1)            ZERO HIGH-ORDER BYTE
         BCTR  R1,0                DECREMENT BY ONE
         AR    RWA,R1              SET RWA TO RIGHT-MOST TEXT BYTE
         SPACE
* SCAN THE LINE, SEARCHING FOR FIRST NON-BLANK.  RESULT IS NEW TEXT
* LENGTH IN RWA, WHICH WILL BE ZERO FOR BLANK LINES.
         SPACE
BLNKLOOP CLI   0(RWA),C' '         TEST FOR NON-BLANK CHAR
         BNE   BLNKDONE            EXIT WHEN FOUND
         BXH   RWA,R0,BLNKLOOP
BLNKDONE SR    RWA,R1              NOW RWA IS NEW TEXT LENGTH
         BC    13,POSTMOVE         NO PRINTING IF <= 0
         SPACE
* NOW ADD OFFSET TO LENGTH OF SURVIVING TEXT TO GET ACTUAL LINE LENGTH.
         SPACE
         AR    RWB,RWA             ADD TEXT LENGTH
         SPACE
* NOW RWA IS THE LENGTH OF THE CALLER'S TEXT, AND RWB IS THE LENGTH OF
* THE LINE.  THE RECORD LENGTH WILL BE FIVE MORE THAT THE LENGTH OF THE
* LINE, TO INCLUDE FORMAT 'V'  AND PRINTER CONTROL CHARACTERS.  GET
* A BUFFER OF THE PROPER LENGTH, KEEPING ITS ADDRESS IN R1.
         SPACE
GETBUF   LA    RWC,5(RWB)          LOAD LENGTH OF RECORD IN RWC
         STH   RWC,DCBLRECL        PUT LRECL IN DCB FOR PUT CALL
         SPACE
         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1
         SPACE
         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE
         LR    RWD,R1              RWD BECOMES BUFFER BASE REG
         MVI   3(RWD),C' '         CLEAR BUFFER TO BLANKS
         EX    RWB,BLNKMOVE
         SLL   RWC,16              SET UP 4-BYTE 'V' CONTROL FIELD
         ST    RWC,DWORK           CAN'T ASSUME BUFFER ON ANY
         MVC   0(4,RWD),DWORK      BOUNDARY
         SPACE
* IF THIS IS THE FIRST HEADING LINE, INSERT DATE AND TIME, AND EDIT
* THE PAGE NUMBER.
         SPACE
         TM    SWITCHES,HD1BIT     TEST IF FIRST LINE
         BZ    MOVETEXT            BRANCH IF NOT
         SPACE
         LA    RWC,0(RWB,RWD)      ADDRESS RIGHT END -5
         SH    RWC,=AL2(HLTXTLNG+10-5)  LOCATE PLACE FOR HEADING INFO
         MVC   0(HLTXTLNG,RWC),HLTEXT  INSERT DATE & TIME
         SPACE
         LH    R1,PAGENO           INCREMENT PAGE NUMBER
         LA    R1,1(R1)
         STH   R1,PAGENO
         CVD   R1,DWORK            CONVERT TO DECIMAL
         MVC   HLTXTLNG(10,RWC),=XL10'40404040402020202120'  EDIT CHARS
         LA    R1,HLTXTLNG+9(RWC)  IN CASE SIGNIFIGANCE FORCED
         EDMK  HLTXTLNG+4(6,RWC),DWORK+5  EDIT AND MARK SPOT FOR "PAGE"
         SH    R1,=H'5'
         MVC   0(4,R1),=C'PAGE'    INSERT WORD "PAGE"
         SPACE
* PUT PRINTER CONTROL CHARACTER AND CALLER'S TEXT INTO THE BUFFER.
* REGISTER RWA CONTAINS THE LENGTH OF THE TEXT.
         SPACE
MOVETEXT BAL   RWB,CCGEN           GO GET CONTROL CHAR
         STC   R0,4(RWD)           INSERT IN BUFFER
         NI    4(RWD),B'11111101'  CHANGE SPACE IMMEDIATE TO WRITE
         SPACE
         SR    RWB,RWB
         IC    RWB,PLDOFFST        LOAD LEFT MARGIN OFFSET
         LA    RWB,5(RWB,RWD)      ADDRESS FOR FIRST TEXT BYTE
         BCTR  RWA,0               DECREMENT LENGTH BY 1 FOR MVC
         L     RWC,PLDTXTAD-1      LOAD ADDRESS OF CALLER'S TEXT
         EX    RWA,MOVEINST        MOVE TEXT
         SPACE
         NI    SWITCHES,255-HD1BIT-TXT1BIT  RESET ONE-SHOT BITS
         SPACE
* DECREMENT PRINT LINE LIMIT COUNTER, ABORTING IF IT GOES NEGATIVE.
         SPACE
         L     R1,MAXLINES
         S     R1,=F'1'            BCTR WOULD NOT SET COND CODE
         ST    R1,MAXLINES
         BP    POSTMOVE            BRANCH IF POSITIVE
         LA    R1,6                ABORT, TOO MUCH OUTPUT
         B     ABEND
         SPACE
* DO ANY ADDITIONAL SPACING NECESSARY.  AMOUNT STILL IN 'RSPACE'.
         SPACE
POSTMOVE BAL   RWA,MOVE            CALL PAPER MOVING SUBROUTINE
         SPACE 2
* NOW WE ARE FINISHED WITH THAT LINE.  IF THE ADDRESS WHICH POINTED TO
* ITS PLD WAS NEGATIVE, THE LIST IS EXHAUSTED AND THE ROUTINE EXITS.
* OTHERWISE, INCREMENT THE LIST POINTER BY 4 AND START THE NEXT ONE.
         SPACE
         LTR   RPLD,RPLD           TEST CURRENT PLD ADDRESS
         BCR   4,RLPEXIT           EXIT IF NEGATIVE
         SPACE
         LA    RPARM,4(RPARM)      INCREMENT LIST POINTER
         B     LISTPROC            TO PROCESS NEXT LINE
         SPACE 2
* EXECUTED INSTRUCTIONS:
         SPACE
BLNKMOVE MVC   4(0,RWD),3(RWD)     SPREAD BLANKS IN OUTPUT BUFFER
MOVEINST MVC   0(0,RWB),0(RWC)     MOVE CALLER'S TEXT TO OUTPUT BUF
         SPACE
         DROP  RPLD
         EJECT
************
* HEADPRNT *
************
         SPACE
* ENTER THIS ROUTINE WHEN IT IS DISCOVERED THAT WE ARE AT
* HEAD-OF-FORM AND ARE ABOUT TO PRINT A LINE.  SAVE THE REGISTERS
* DEFINING THE STATE OF 'LISTPROC' AND CALL IT WITH A LIST SPECIFYING
* THE HEADING AND SUB-HEADING LINES.
         SPACE 2
HEADPRNT ST    RRET,HPREXIT        SAVE RETURN ADDRESS
         STM   RLPEXIT,RPARM,HPRSAVE  STORE LISTPROC REGISTERS
         SPACE
* RESET HEAD-OF-FORM BIT AND SET NO-SKIP BIT TO SUPPRESS FORM SKIPS
* AND HEADING LINE BIT TO INCLUDE THE PAGE NUMBER.  RESET PAGE BALANCE.
         SPACE
         NI    SWITCHES,255-HOFBIT  RESET HOF BIT
         OI    SWITCHES,HD1BIT+NOSKBIT  SET HEADING AND NOSKIP BITS
         LH    RBAL,PAGELNG        RESET PAGE BALANCE
         SPACE
* LOAD ADDRESS OF HEADINGS LIST AND CALL LIST PROCESSOR.
         SPACE
         L     RPARM,HEADLIST      ADDRESS OF HEADINGS LIST
         BAL   RLPEXIT,LISTPROC    CALL PROCESSING ROUTINE
         SPACE
* AFTER PRINTING THE HEADINGS, TURN SYSTEM SKIP-SUPPRESSION BIT OFF
* AND SET 'TXT1BIT' TO INDICATE THAT THERE ARE NO TEXT LINES ON THE
* PAGE YET.  THEN RESTORE THE 'LISTPROC' REGISTERS AND RETURN TO
* PROCESSING THE CALLER'S LINES.
         SPACE
         NI    SWITCHES,255-NOSKBIT  RESET NO-SKIP BIT
         OI    SWITCHES,TXT1BIT    SET FIRST-TEXT-LINE BIT
         SPACE
         LM    RLPEXIT,RPARM,HPRSAVE  RESTORE LISTPROC REGISTERS
         L     RRET,HPREXIT        RECOVER EXIT ADDRESS AND
         BR    RRET                RETURN TO CALLER
         EJECT
***********************************
* MOVE - VERTICAL SPACING ROUTINE *
***********************************
         SPACE
* SUBROUTINE TO MOVE THE PAPER BY THE NUMBER OF LINES IN REGISTER
* 'RSPACE'.  RETURN ADDRESS IS IN 'RWA'.  IF THE CONTROL CHARACTER FOR
* THE LAST LINE SPACED 0 LINES, REPLACE IT WITH A NEW ONE BEFORE
* GENERATING ANY EXTRA LINES.
         SPACE 2
MOVE     LTR   RSPACE,RSPACE       TEST NUMBER OF LINES TO BE MOVED
         BCR   13,RWA              EXIT IF <= ZERO
         TM    SWITCHES,SP0BIT     DID PREVIOUS LINE SPACE 0?
         BZ    PREVNOT0            BRANCH IF NOT
         L     R1,CCLAST           GET ADDRESS OF PREVIOUS LINE
         BAL   RWB,CCGEN           GENERATE NEW CONTROL CHAR
         NI    4(R1),X'02'         TEST WRITE/SPACE BIT IN OLD CC
         STC   R0,4(R1)            STORE NEW CC IN PREVIOUS LINE
         BNZ   *+8                 BR IF WRITE/SPACE BIT WAS ON
         NI    4(R1),255-X'02'     TURN WRITE/SPACE BIT OFF
PREVNOT0 DS    0H
         MVC   DCBLRECL(2),MOVELINE  SET LOGICAL RECORD LENGTH IN DCB
         SPACE
         PUT   PRINTDCB            GET BUFFER ADDRESS IN R1
         SPACE
         ST    R1,CCLAST           SAVE LOCATION OF THIS LINE
         MVC   0(6,R1),MOVELINE    INSERT FORMAT 'V' CONTROL RECORD
         BAL   RWB,CCGEN           GET PRINT CONTROL CHAR IN R0
         STC   R0,4(R1)            INSERT IN RECORD
         SPACE
         B     MOVE                LOOP UNTIL 'RSPACE' IS ZERO
         SPACE 3
MOVELINE DC    XL6'000600000340'   FORMAT 'V' CONTROL RECORD
         EJECT
*****************************************
* CCGEN - GENERATE PRINTER CONTROL CHAR *
*****************************************
         SPACE
* THIS ROUTINE GENERATES A PRINTER CONTROL CHARACTER TO SPACE OR EJECT
* IMMEDIATELY (WITHOUT PRINTING).  ENTER WITH THE TOTAL NUMBER OF
* LINES TO BE MOVED IN 'RSPACE' AND RETURN ADDRESS IN 'RWB'.  EXITS
* WITH THE CONTROL CHARACTER IN BITS 24-31 OF REGISTER 0 AND THE COUNT
* IN 'RSPACE' DECREMENTED BY THE AMOUNT WHICH THE CHARACTER WILL SPACE.
* A SPACE VALUE OF 255 OR GREATER WILL GENERATE AN EJECT CONTROL
* CHARACTER, SET 'RSPACE' AND 'RBAL' TO ZERO, AND SET THE HEAD-OF-FORM
* BIT.  NOTE:  MUST NOT USE R1.
         SPACE 2
CCGEN    NI    SWITCHES,255-SP0BIT  RESET 'PREVIOUS SPACED 0' BIT
         CH    RSPACE,=AL2(EJFORCE)  TEST FOR EJECT REQUEST
         BL    CCNOEJ              BRANCH IF NOT
         LA    R0,X'8B'            LOAD 'SKIP TO CHAN 1' CC
         OI    SWITCHES,HOFBIT     SET HEAD-OF-PAGE BIT
         SR    RBAL,RBAL           SET PAGE BALANCE TO ZERO
         SR    RSPACE,RSPACE       SET REMAINING SPACING TO ZERO
         BR    RWB                 EXIT
         SPACE
CCNOEJ   LR    R15,RSPACE          LOAD WORK REGISTER
         CH    RSPACE,=H'3'        TEST IF OVER THREE LINES
         BNH   CCOK                BR IF <= 3
         LA    R15,3               SET 3, MAXIMUM FOR 1 OPERATION
CCOK     SR    RSPACE,R15          DECR RSPACE BY AMOUNT SPACED
         SLL   R15,3               PUT AMOUNT IN BITS 2-4 OF BYTE
         LA    R0,X'03'(R15)       ADD COMMAND BITS AND PUT IN R0
         LTR   R15,R15             TEST FOR ZERO SPACING
         BCR   7,RWB               EXIT IF NOT ZERO
         OI    SWITCHES,SP0BIT     SET 'LINE SPACED 0' BIT
         BR    RWB                 EXIT
         EJECT
***********************
* SYNAD ERROR ROUTINE *
***********************
         SPACE
* IF A PERMANENT I/O ERROR OCCURS, TYPE A DIAGNOSTIC MESSAGE AND ABORT.
         SPACE
SYNAD    SYNADAF ACSMETH=QSAM      GET ERROR MESSAGE FROM O/S
         LR    RWA,R1              SAVE MESSAGE ADDRESS
         GETMAIN R,LV=128          GET BUFFER FOR MESSAGE
         MVC   0(LIOMSG,R1),IOMSG  INSERT MESSAGE BEGINNING
         MVC   LIOMSG(79,R1),49(RWA)  ADD TEXT FROM O/S
         LR    RWA,R1              SAVE MESSAGE ADDRESS
         SYNADRLS                  FREE O/S MESSAGE
         WTO   MF=(E,(RWA))        TYPE MESSAGE ON CONSOLE
         LA    R1,7                LOAD ERROR CODE
         B     ABEND               TO ABORT AND DUMP
         SPACE
IOMSG    DC    AL2(LIOMSG+78,0)    FORMAT V CONTROL FIELD
         DC    C'XPRNTSUB I/O ERROR'
LIOMSG   EQU   *-IOMSG
         EJECT
**************************
* CONSTANTS AND LITERALS *
**************************
         SPACE
* DUMMY PARAMETER LIST AND PLD FOR USE WHEN NO HEADING IS PROVIDED.
         SPACE
NOHDLIST DS    0F
         DC    XL1'80'             VL LIST BIT
         DC    AL3(NOHDPLD)        ADDRESS OF PLD BELOW
         SPACE
NOHDPLD  DS    0F                  ALIGN ON FULL-WORD BOUNDARY
         DC    BL1'00010000'       OPTION BITS
         DC    AL3(BLANK1)         PRINT TEXT ADDRESS
         DC    AL1(1)              PRINT TEXT LENGTH
         DC    AL1(0)              LEFT MARGIN INDENTATION
         DC    AL1(0)              SPACING BEFORE PRINTING
         DC    AL1(3)              SPACING AFTER PRINTING
         SPACE
* CONSTANTS TO INITIALIZE PARAMETERS AND SWITCHES WHEN 'OPEN' CALL IS
* RECEIVED.  THE ORDER MUST MATCH THE 'PAPARMS' LIST IN THE WORK AREA.
         SPACE
DEFAULTS DS    0F
         DC    A(NOHDLIST)         PAGE HEADING PARM LIST ADDRESS
         DC    F'1000000'          MAXIMUM NUMBER OF OUTPUT LINES
         DC    H'132'              PAGE WIDTH
         DC    H'57'               PAGE LENGTH            ***TRW***
         DC    H'0'                PAGE NUMBER (-1)
         DC    H'0'                PAGE BALANCE
         DC    X'00'               SWITCHES
DEFSIZE  EQU   *-DEFAULTS
         SPACE
* MISCELLANEOUS CONSTANTS:
         SPACE
BLANK1   DC    C' '                TEXT OF DUMMY HEADING LINE
         LTORG
         EJECT
*******************
* WORK AREA DSECT *
*******************
         SPACE
* THIS DUMMY SECTION DEFINES THE WORK AREA PROVIDED BY THE PROBLEM
* PROGRAM FOR EACH DATA SET.  ITS ADDRESS IS PASSED IN PARAMETER
* REGISTER 0 AT EACH CALL.
         SPACE 2
WORKAREA DSECT
         SPACE 2
* STANDARD 18-WORD SAVE AREA:
         SPACE
SAVEAREA DS    18F
         SPACE 2
* DATA CONTROL BLOCK FOR PRINTER DATA SET:
         SPACE
         PRINT NOGEN
PRINTDCB DCB   DDNAME=SYSPRINT,                                        X
               DSORG=PS,                                               X
               RECFM=VBM,                                              X
               LRECL=137,                                              X
               MACRF=PL,                                               X
               BFTEK=S,                                                X
               BUFNO=2,                                                X
               EROPT=ACC
         PRINT GEN
         SPACE
DCBEXLST EQU   PRINTDCB+37         ADDRESS OF EXIT LIST
DCBOFLGS EQU   PRINTDCB+48         CONTAINS 'OPENED SUCCESSFULLY' BIT
DCBDDNAM EQU   PRINTDCB+40         DDNAME (WHEN CLOSED)
DCBSYNAD EQU   PRINTDCB+57         ADDRESS OF SYNCHRONOUS ERROR ROUTINE
DCBBLKSZ EQU   PRINTDCB+62         BLOCK SIZE
DCBLRECL EQU   PRINTDCB+82         LOGICAL RECORD LENGTH
         SPACE 2
* ADDRESS OF LAST BUFFER OBTAINED BY "PUT" MACRO:
         SPACE
CCLAST   DS    1A
         SPACE
         DS    1F                  SPARE FULL WORD
         SPACE 2
* TEMPORARY WORK CELLS:
         SPACE
DWORK    DS    1D                  DOUBLE-WORD WORK CELL
HPREXIT  DS    1F                  HEADPRNT EXIT SAVE
HPRSAVE  DS    2F                  HEADPRNT REGISTER STORAGE
         SPACE 2
* PARAMETERS AND SWITCHES WHICH DEFINE THE PAGE SIZE AND STATUS.
* SEQUENCE MUST MATCH THAT IN 'DEFAULTS', WHICH INITIALIZES THEM.
         SPACE
PAPARMS  DS    0F
HEADLIST DS    1A                  PAGE HEADING PARM LIST ADDRESS
MAXLINES DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES
PAGWIDTH DS    1H                  PAGE WIDTH
PAGELNG  DS    1H                  PAGE LENGTH
PAGENO   DS    1H                  PAGE NUMBER OF CURRENT PAGE
PAGEBAL  DS    1H                  PAGE BALANCE
SWITCHES DS    1X                  SWITCHES
         SPACE 2
* STORAGE FOR DATE AND TIME PORTION OF PAGE HEADING:
         SPACE
HLTXTLNG EQU   24
HLTEXT   DS    CL(HLTXTLNG)
HLDAY    EQU   HLTEXT
HLTIME   EQU   HLTEXT+7
HLDATE   EQU   HLTEXT+16
         EJECT
*************************
* PARAMETER LIST DSECTS *
*************************
         SPACE 2
* PARAMETER LIST FOR 'EJECT' CALL:
         SPACE
EJPARM   DSECT
         SPACE
EJCOND   DS    1X                  CONDITIONAL MASK AND SWITCHES
EJQUAN   DS    1X                  CONDITIONAL TEST QUANTITY
         SPACE
EJATHOF  EQU   X'01'               MASK FOR 'EJCOND'
         SPACE 6
* PARAMETER LIST FOR 'SPACE' CALL:
         SPACE
SPPARM   DSECT
         SPACE
SPCOND   DS    1X                  CONDITIONAL BITS
SPQUAN   DS    1X                  NUMBER OF LINES TO SPACE
         SPACE
SPATHOF  EQU   X'01'               MASK FOR 'SPCOND'
SPNOEJ   EQU   X'02'               MASK FOR 'SPCOND'
         SPACE 6
* PARAMETER LIST FOR 'OPEN' AND 'MODIFY' CALLS:
         SPACE
OMPARM   DSECT
         SPACE
OMMAXLIN DS    1F                  MAXIMUM NUMBER OF OUTPUT LINES
OMPAGENO DS    1H                  INITIAL PAGE NUMBER
OMPAGWID DS    1X                  PAGE WIDTH
OMPAGLNG DS    1X                  PAGE LENGTH
OMTIMEAD DS    1A                  ADDRESS OF TIME
OMDATEAD DS    1A                  ADDRESS OF DATE
OMDDNAME DS    CL8                 DDNAME (OPEN CALL ONLY)
         EJECT
*************
* PLD DSECT *
*************
         SPACE
* PRINT LINE DESCRIPTOR DUMMY SECTION:
         SPACE 2
*        ******************************************************
*        *            *                                       *
*        *   OPTION   *                                       *
*        *    BITS    *             TEXT ADDRESS              *
*        *            *                                       *
*        ******************************************************
*        *            *            *            *             *
*        *    TEXT    *    TEXT    *   SPACE    *    SPACE    *
*        *   LENGTH   *   OFFSET   *   BEFORE   *    AFTER    *
*        *            *            *            *             *
*        ******************************************************
         SPACE 3
PLDBLOCK DSECT
         SPACE
PLDFLAGS DS    1X                  OPTION BITS
PLDTXTAD DS    AL3                 TEXT ADDRESS
PLDLNGTH DS    1X                  TEXT LENGTH
PLDOFFST DS    1X                  TEXT OFFSET, OR LEFT MARGIN
PLDSPB   DS    1X                  AMOUNT TO SPACE BEFORE PRINTING
PLDSPA   DS    1X                  AMOUNT TO SPACE AFTER PRINTING
         SPACE 2
PRHOFBIT EQU   B'00000010'         MASK FOR 'PLDFLAGS'
PRSKPBIT EQU   B'00000001'         MASK FOR 'PLDFLAGS'
SPSKPBIT EQU   B'00010000'         MASK FOR 'PLDFLAGS'
         TITLE 'DATE EDITING ROUTINE "XDATEDIT"'
* STATUS:  VERSION 0, MOD 2, 5 OCTOBER 1967.
         SPACE
* FUNCTION/OPERATION:  EDITS A PACKED DECIMAL DATE IN YEAR-DAY FORM TO
*        EBCDIC MONTH-DAY-YEAR FORM.  CORRECTS FOR LEAP YEARS AND
*        FOR THE TURN OF A CENTURY.
         SPACE
* ENTRY POINTS:  ENTER AT "XDATEDIT" VIA BALR 14,15 WITH REG 13 SET
*        TO A STANDARD 18-WORD SAVE AREA.  REGISTER 1 POINTS TO A
*        PARAMETER LIST CONTAINING ONE ADDRESS.
         SPACE
* INPUT:  THE ADDRESS IN THE PARAMETER LIST IS THAT OF AN ALIGNED
*        DOUBLE WORD CONTAINING THE ARGUMENT IN PACKED DECIMAL AS:
*        X'0000000000YYDDD+'.
         SPACE
* OUTPUT:  THE RESULT IS RETURNED IN THE SAME DOUBLE WORD IN EBCDIC AS
*        C'MM/DD/YY'.
         SPACE
* DATA SETS:  NONE.
         SPACE
* EXTERNAL ROUTINES:  NONE.
         SPACE
* EXITS-NORMAL:  RETURN VIA REG 14 WITH RETURN CODE 0 IN REG 15.
         SPACE
* EXITS-ERROR:  IF THE DAY NUMBER IS ZERO OR EXCEEDS THE MAXIMUM VALUE
*        APPROPRIATE TO THE YEAR, RETURN VIA REG 14 WITH RETURN CODE 4
*        IN REG 15 AND THE RESULT FIELD SET TO C' YY.DDD '.
         SPACE
* TABLES/WORK AREAS:  NONE.
         SPACE
* ATTRIBUTES:  REENTRANT, READ ONLY.
         SPACE
* NOTES:  NONE.
         EJECT
* DUMMY SECTION TO DEFINE THE ARGUMENT AND RETURN FIELD.
         SPACE
DUMMY    DSECT
DWORD    DS    1D
         SPACE 6
* BEGIN CONTROL SECTION HERE.  DEFINE REGISTER TAGS.
         SPACE
XDATEDIT CSECT
         SPACE
RDSECT   EQU   11                  BASE REG FOR ARGUMENT/RESULT
RPARMD   EQU   1                   PARAMETER LIST POINTER
RARGSAVE EQU   2                   TO SAVE ORIGINAL PACKED ARGUMENT
RMONTH   EQU   3
RDAY     EQU   4                   RDAY AND RYEAR ARE AN EVEN/ODD
RYEAR    EQU   5                   PAIR FOR DIVISION
RWORK    EQU   6
RLIST    EQU   7
         SPACE 6
* ENTER HERE.  SAVE GENERAL REGISTERS AND SET UP BASE REGISTERS.
         SPACE
         SAVE  (14,12),,*
         SPACE
         BALR  RBASE,0
         USING *,RBASE
         L     RDSECT,0(RPARMD)    LOAD ARGUMENT ADDRESS
         USING DWORD,RDSECT
         EJECT
* CONVERT YEAR AND DAY TO BINARY, AND SEPARATE BY DIVISION.
         SPACE
         MVI   DWORD,X'00'         CLEAR HIGH DECIMAL DIGITS
         MVC   DWORD+1(4),DWORD    IN ARG TO ZEROS
         OI    DWORD+7,X'0F'       FORCE PLUS SIGN
         L     RARGSAVE,DWORD+4    SAVE ARGUMENT FOR 'BADDATE'
         SPACE
         CVB   RYEAR,DWORD         CONVERT YYDDD TO BINARY
         SR    RDAY,RDAY           CLEAR HIGH-ORDER DIVIDEND
         D     RDAY,F1000          QUOTIENT=YEAR; REMAINDER=DAY
         SPACE
* CHECK FOR LEAP YEAR, AND LOAD RLIST WITH BASE ADDRESS OF APPROPRIATE
* LIST OF MONTH SIZES.
         SPACE
DAYOK    DS    0H
         LA    RLIST,STDLIST       POINT RLIST TO STANDARD MONTHS
         LTR   RWORK,RYEAR         LOAD BINARY YEAR NUMBER
         BZ    NOTLEAP             BR IF TURN OF CENTURY
         N     RWORK,=F'3'         TEST LOW TWO BITS
         BC    4,NOTLEAP           BR IF NON-ZERO
         LA    RLIST,LPYLIST       POINT RLIST TO LEAP-YEAR MONTHS
NOTLEAP  DS    0H
         SPACE
* TEST DAY NUMBER AGAINST ZERO AND THE UPPER LIMIT DETERMINED BY
* THE YEAR NUMBER.
         SPACE
         LTR   RDAY,RDAY           TEST FOR ZERO
         BZ    BADDATE             BR IF SO
         CH    RDAY,0(0,RLIST)     TEST FOR UPPER LIMIT
         BH    BADDATE             BR IF TOO LARGE
         SPACE
* REDUCE JULIAN DAY TO DAY-OF-MONTH, ACCUMULATING MONTH NUMBER.
         SPACE
         LA    RMONTH,1            INITIAL MONTH NUMBER
         SR    RWORK,RWORK
DAYLOOP  IC    RWORK,1(RMONTH,RLIST)  LENGTH OF MONTH INTO RWORK
         CR    RDAY,RWORK          TEST IF DAY IN THIS MONTH
         BNH   DAYDONE             BR IF DAY LESS THAN MONTH SIZE
         SR    RDAY,RWORK          REDUCE DAY BY LENGTH OF MONTH
         LA    RMONTH,1(RMONTH)    INCREMENT MONTH
         B     DAYLOOP
DAYDONE  DS    0H
         SPACE
* COMBINE MONTH, DAY, AND YEAR IN BINARY IN ONE REGISTER, MULTIPLYING
* EACH BY A FACTOR TO PLACE IT PROPERLY IN THE DECIMAL RESULT.
* THE TRICK IS THAT  1000(1000(MONTH)+DAY)+YEAR  GIVES  MM0DD0YY  WHEN
* CONVERTED TO DECIMAL.  AFTER UNPACKING, THE ZEROS ARE REPLACED BY
* SLASHES.
         SPACE
         MH    RMONTH,H1000
         AR    RMONTH,RDAY
         MH    RMONTH,H1000
         AR    RMONTH,RYEAR
         CVD   RMONTH,DWORD
         MVC   DWORD(5),DWORD+3    MOVE OVER FOR UNPACKING
         UNPK  DWORD(8),DWORD(5)   CONVERT TO ALPHA
         OI    DWORD+7,X'F0'       COVER UP SIGN
         MVI   DWORD+2,C'/'        INSERT SLASHES
         MVI   DWORD+5,C'/'
         SR    15,15               SET NORMAL RETURN CODE OF 0
         SPACE
EXITD    RETURN  (14,12),T,RC=(15)  RETURN TO CALLER
         SPACE 2
* FOR ARGUMENTS WHOSE DAY NUMBER IS ZERO OR TOO LARGE, RETURN IN
* 'DWORD' THE EDITED VALUE  C' YY.DDD ' AND SET A RETURN CODE OF 4.
         SPACE
BADDATE  ST    RARGSAVE,DWORD      RESTORE ORIGINAL PACKED ARGUMENT
         UNPK  DWORD+2(5),DWORD+1(3)  UNPACK INTO ALPHA
         MVC   DWORD+1(2),DWORD+2  SHIFT YEAR 1 LEFT
         MVI   DWORD,C' '          APPLY COSMETICS
         MVI   DWORD+3,C'.'
         MVI   DWORD+7,C' '
         LA    15,4                SET RETURN CODE
         B     EXITD
         EJECT
* LISTS OF MONTH SIZES FOR STANDARD AND LEAP YEARS:
         SPACE
         SPACE
STDLIST  DC    H'365'              DAY LIMIT FOR STANDARD YEARS
         DC    AL1(31)
         DC    AL1(28)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         SPACE
LPYLIST  DC    H'366'              DAY LIMIT FOR LEAP YEARS
         DC    AL1(31)
         DC    AL1(29)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         DC    AL1(30)
         DC    AL1(31)
         SPACE
F1000    DC    F'1000'
H1000    EQU   F1000+2
         LTORG
         PRINT NOGEN
         TITLE 'MESSAGE ROUTINE.'
MESGRTN  $PROLOG R12
         L     R4,=V(DATASECT)
         USING DATASECT,R4
         CLI   MALLOC,255        HAS SYSLIST BEEN ALLOCATED?
         BE    MALLOC1           ONCE ONLY PLEASE.
         MVI   MALLOC,255        MARK IT AS ALLOCATED.
         ST    R1,MR1SAVE        FOLLOWING CODE BAGS R1
         XPROPEN PWL,                                                  X
               PAGELEN=PAGELEN,                                        X
               DDNAME=SYSLIST    AND OPEN IT.
         LTR   R15,R15           WELL......
         BZ    MSGOK             YUP.
         WTO   'SYSLIST NOT OPENED',ROUTCDE=11
         ABEND 13
MSGOK    XPREJECT PWL            SKIP TO A NEW PAGE.
         XPRHEAD PWL,                                                  X
               LIST=SLHEAD1      AND DEFINE THE HEADING.
         L     R1,MR1SAVE        MESSAGE NUMBER FROM CALLER.
MALLOC1  L     R3,=V(MESSAGES)   GET ADDRESS OF MESSAGE TABLE.
         SLL   R1,1              TIMES 2 FOR HALFWORD INDEX
         LH    R1,0(R1,R3)       PICKUP INDEX INTO MESSGAE TABLE.
         AR    R1,R3             DEVELOP OFFSET OF MESSAGE TEXT.
         SR    R3,R3             ZERO REGISTER.
         IC    R3,0(,R1)         PICKUP TEXT LENGTH
         SR    R4,R4             ZERO REGISTER.
         IC    R4,1(,R1)         LENGTH TO BE INSERTED.
         LTR   R4,R4             ANYTHING TO INSERT?
         BZ    MSKIP2            NO, PRINT MESSAGE AS IS.
         LR    R5,R3             MESSAGE LENGTH
         SR    R5,R4             MINUS INSERT LENGTH
         AR    R5,R1             PLUS START ADDR
         LA    R5,2(,R5)         PLUS 2 IS INSERT POINT.
         BCTR  R4,0              MINUS 1 FOR EX.
         EX    R4,MINSERT        ADD INSERT TEXT.
MSKIP2   LA    R1,2(,R1)         SKIP OVER LENGTH BYTES.
         XPRNTLIN PWL,                                                 X
               TEXT=(R1),                                              X
               LENGTH=(R3),                                            X
               SPB=((R0)),                                             X
               SPA=1             PRINT THE MESSAGE TEXT.
MSKIP1   EQU   *
         $EPILOG ,
NOSYSLST ABEND 130,DUMP
         LTORG ,
MINSERT  MVC   0(0,R5),0(R2)     CUSTOMIZE A MESSAGE.
MALLOC   DC    A(*-*)            HAS SYSLIST BEEN ALLOCATED.
MR1SAVE  DC    AL4(0)            SAVEAREA FOR REGISTER 1.
PWL      XPRDCB DDNAME=SYSLIST
SLHEAD1  XPRLDEF TEXT=SLHTXT1,                                         X
               LENGTH=L'SLHTXT1,                                       X
               SPB=(0,ATHOF),                                          X
               SPA=2
SLHTXT1  DC    C'&NAME &VERSION -- MESSAGES'
MESSAGES CSECT
         MACRO
         MESG  &N,&F,&T
&L       SETA  K'&SYSLIST(3)-2
         AIF   (&SYSLIST(2) EQ 0).NOFILL
&L       SETA  &L+&SYSLIST(2)
MESG&N   DC    YL1(&L),YL1(&F),C&T,CL&F' '
         MEXIT
.NOFILL  ANOP
MESG&N   DC    YL1(&L),YL1(&F),C&T
         MEND
         DC    Y(MESG0-MESSAGES)
         DC    Y(MESG1-MESSAGES)
         DC    Y(MESG2-MESSAGES)
         DC    Y(MESG3-MESSAGES)
         DC    Y(MESG4-MESSAGES)
         DC    Y(MESG5-MESSAGES)
         DC    Y(MESG6-MESSAGES)
         SPACE ,
         MESG  0,0,'&NAME &VERSION -- ENDED SUCCESSFULLY.'
         MESG  1,0,'&NAME &VERSION -- STARTING.'
         MESG  2,4,'VSAM LOGICAL ERROR ON VVDS GET. FDBK = '
         MESG  3,44,'VVR NOT FOUND WHEN EXPECTED. DSN: '
         MESG  4,44,'INCOMPLETE DATA FOR DSN: '
         MESG  5,8,'OPEN FAILED FOR VVDS ON VOLUME: '
         MESG  6,0,'OPEN FAILED FOR HSM MCDS, DDN: SYSUT2'
         END   LISTICAT
